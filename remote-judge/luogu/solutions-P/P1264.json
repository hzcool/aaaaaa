[
    {
        "content": "\u770b\u4e00\u4e2a\u961f\u662f\u5426\u6709\u5e0c\u671b\u593a\u51a0\uff0c\u5373\u8fd9\u4e2a\u961f\u4f0d\u5c06\u6240\u6709\u80fd\u8d62\u7684\u6bd4\u8d5b\u90fd\u8d62\u4e0b\u6765\uff0c\u7b97\u51fa\u8fd9\u4e2a\u961f\u6700\u591a\u62ff\u591a\u5c11\u5206\uff0c\u518d\u5224\u65ad\u5176\u4ed6\u961f\u7684\u79ef\u5206\u662f\u5426\u6709\u53ef\u80fd\u90fd\u4f4e\u4e8e\u8fd9\u4e2a\u6700\u9ad8\u5206\u3002\n\n\u5c06\u6240\u6709\u7403\u961f\u4f5c\u4e3a\u56fe\u4e2d\u7ed3\u70b9\uff0c\u6bcf\u4e24\u961f\u6bd4\u8d5b\u4e5f\u4f5c\u4e3a\u56fe\u4e2d\u7ed3\u70b9\u3002\u4eceS\u5f15\u4e00\u6761\u8fb9\u5230\u6bd4\u8d5b\u7ed3\u70b9\uff0c\u5bb9\u91cf\u4e3a\u4e24\u961f\u8fd8\u5269\u7684\u6bd4\u8d5b\u6570\uff0c\u4ece\u6bcf\u961f\u7ed3\u70b9\u8fde\u4e00\u6761\u8fb9\u5230T\uff0c\u5bb9\u91cf\u4e3a\u8fd9\u4e2a\u961f\u548c\u5f53\u524d\u6700\u9ad8\u5206\u7684\u5dee\uff0c\u5982\u679c\u4e00\u4e2a\u6bd4\u8d5b\u7ed3\u70b9\u4ee3\u8868\u7684\u662fA\u548cB\u7684\u6bd4\u8d5b\uff0c\u90a3\u4e48\u4ece\u8fd9\u4e2a\u7ed3\u70b9\u8fde\u4e24\u6761\u8fb9\u5206\u522b\u5230A\u7684\u7ed3\u70b9\u548cB\u7684\u7ed3\u70b9 \u5bb9\u91cf\u4e3aINF\n\n\u5982\u679c\u8fd9\u4e2a\u7f51\u7edc\u7684\u6700\u5927\u6d41\u7b49\u4e8e\u6240\u6709\u672a\u8fdb\u884c\u7684\u6bd4\u8d5b\u573a\u6b21\u4e4b\u548c\uff0c\u5219\u5f53\u524d\u7403\u961f\u53ef\u4ee5\u6210\u4e3a\u51a0\u519b\n\n\u628a\u6bcf\u4e2a\u961f\u679a\u4e3e\u4e00\u904d\u5373\u53ef\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 700;\nconst int INF = 1000000000;\nstruct Edge {\n  int from, to, cap, flow;\n};\nbool operator < (const Edge& a, const Edge& b) {\n  return a.from < b.from || (a.from == b.from && a.to < b.to);\n}\nstruct Dinic {\n  int n, m, s, t;\n  vector<Edge> edges;    // \u8fb9\u6570\u7684\u4e24\u500d\n  vector<int> G[maxn];   // \u90bb\u63a5\u8868\uff0cG[i][j]\u8868\u793a\u7ed3\u70b9i\u7684\u7b2cj\u6761\u8fb9\u5728e\u6570\u7ec4\u4e2d\u7684\u5e8f\u53f7\n  bool vis[maxn];        // BFS\u4f7f\u7528\n  int d[maxn];           // \u4ece\u8d77\u70b9\u5230i\u7684\u8ddd\u79bb\n  int cur[maxn];         // \u5f53\u524d\u5f27\u6307\u9488\n  void init(int n) {\n    for(int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back((Edge){from, to, cap, 0});\n    edges.push_back((Edge){to, from, 0, 0});\n    m = edges.size();\n    G[from].push_back(m-2);\n    G[to].push_back(m-1);\n  }\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(s);\n    vis[s] = 1;\n    d[s] = 0;\n    while(!Q.empty()) {\n      int x = Q.front(); Q.pop();\n      for(int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if(!vis[e.to] && e.cap > e.flow) {\n          vis[e.to] = 1;\n          d[e.to] = d[x] + 1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return vis[t];\n  }\n  int DFS(int x, int a) {\n    if(x == t || a == 0) return a;\n    int flow = 0, f;\n    for(int& i = cur[x]; i < G[x].size(); i++) {\n      Edge& e = edges[G[x][i]];\n      if(d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap-e.flow))) > 0) {\n        e.flow += f;\n        edges[G[x][i]^1].flow -= f;\n        flow += f;\n        a -= f;\n        if(a == 0) break;\n      }\n    }\n    return flow;\n  }\n  int Maxflow(int s, int t) {\n    this->s = s; this->t = t;\n    int flow = 0;\n    while(BFS()) {\n      memset(cur, 0, sizeof(cur));\n      flow += DFS(s, INF);\n    }\n    return flow;\n  }\n};\nDinic g;\nconst int maxt = 25 + 5;\nint n, w[maxt], d[maxt], a[maxt][maxt];\ninline int ID(int u, int v) { return u*n+v+1; }\ninline int ID(int u) { return n*n+u+1; }\nbool canWin(int team) {\n  // \u8ba1\u7b97team\u5168\u80dc\u540e\u7684\u603b\u80dc\u5229\u573a\u6570\n  int total = w[team];\n  for(int i = 0; i < n; i++)\n    total += a[team][i];\n  for(int i = 0; i < n; i++)\n    if(w[i] > total) return false;\n  // \u6784\u56fe\u3002s=0, \u7ed3\u70b9(u,v)\u7684\u7f16\u53f7\u4e3au*n+v+1, \u7ed3\u70b9u\u7684\u7f16\u53f7\u4e3an^2+u+1, t=n^2+n+1\n  g.init(n*n+n+2);\n  int full = 0;\n  int s = 0, t = n*n+n+1;\n  for(int u = 0; u < n; u++) {\n    for(int v = u+1; v < n; v++) {\n      if(a[u][v] > 0) g.AddEdge(s, ID(u,v), a[u][v]); // S\u5230(u,v)\u7684\u5f27\n      full += a[u][v];\n      g.AddEdge(ID(u,v), ID(u), INF); // (u,v)\u5230u\u7684\u5f27\n      g.AddEdge(ID(u,v), ID(v), INF); // (u,v)\u5230v\u7684\u5f27\n    }\n    if(w[u] < total) g.AddEdge(ID(u), t, total-w[u]); // u\u5230T\u7684\u5f27\n  }\n  return g.Maxflow(s, t) == full;\n}\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++) scanf(\"%d%d\", &w[i], &d[i]);\n    for(int i = 0; i < n; i++)\n      for(int j = 0; j < n; j++)\n        scanf(\"%d\", &a[i][j]);\n     bool first = true;\n    for(int i = 0; i < n; i++)\n      if(canWin(i)) {\n        if(first) first = false; else printf(\" \");\n        printf(\"%d\", i+1);\n      }\n    printf(\"\\n\");\n    return 0;\n}\n```",
        "postTime": 1493690966,
        "uid": 21385,
        "name": "PrimoPan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1264 \u3010K-\u8054\u8d5b\u3011"
    },
    {
        "content": "\u6807\u7b7e:\u7f51\u7edc\u6d41.\n\n\u679a\u4e3e\u6bcf\u4e2a\u961f\u4f0d, \u5224\u65ad\u8fd9\u4e2a\u961f\u4f0d\u662f\u5426\u53ef\u4ee5\u6210\u4e3a\u51a0\u519b.\n\n\u8d2a\u5fc3\u5730\u8ba9\u8fd9\u4e2a\u961f\u4f0d\u8d62\u5f97\u6240\u6709\u4e4b\u540e\u53c2\u52a0\u7684\u6bd4\u8d5b, \u8bb0\u8d62\u5f97\u4e4b\u540e\u7684\u6bd4\u8d5b\u7684\u83b7\u80dc\u603b\u573a\u6570\u4e3a $x$ , \u5219\u6211\u4eec\u5e0c\u671b\u6784\u9020\u4e00\u4e2a\u65b9\u6848, \u4f7f\u5f97\u5176\u4ed6\u961f\u4f0d\u7684\u80dc\u573a\u6700\u5927\u503c\u4e0d\u5927\u4e8e $x$ .\n\n\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u5f88\u7b80\u5355\u7684\u901a\u8fc7\u7f51\u7edc\u6d41\u6765\u89e3\u51b3: \u56e0\u4e3a\u5176\u4ed6\u961f\u4f0d\u7684\u80dc\u573a\u6700\u5927\u4e0d\u5927\u4e8e $x$ , \u5219\u5176\u4e4b\u540e\u80fd\u8d62\u7684\u573a\u6570\u4e0d\u5927\u4e8e $y_i=x-w_i$ \u573a, \u7531\u4e8e\u6bcf\u4e00\u573a\u6bd4\u8d5b\u4f1a\u4f7f\u53c2\u8d5b\u7684\u53cc\u65b9\u4e2d\u7684\u6070\u597d\u4e00\u652f\u961f\u4f0d\u80dc\u573a $+1$ , \u90a3\u4e48\u5b9e\u9645\u4e0a\u6211\u4eec\u9700\u8981\u6784\u9020\u7684\u662f\u4e00\u4e2a\u6bd4\u8d5b\u4e0e\u961f\u4f0d\u7684\u5e26\u6743\u4e8c\u5206\u56fe\u5339\u914d(\u5b9e\u9645\u4e0a\u4f3c\u4e4e\u53ef\u4ee5\u4f7f\u7528\u5308\u7259\u5229\u7b97\u6cd5\u89e3\u51b3), \u5224\u65ad\u6bd4\u8d5b\u662f\u5426\u53ef\u4ee5\u5b8c\u5168\u88ab\u5339\u914d\u5373\u53ef.\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n^3)$ .\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint read();\n\nint n, s, t, vcnt;\nint w[51], a[51][51], id[51][51];\n\nint hd[3003], nx[6003], to[6003], c[6003], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid add_E(int f, int t, int cap) { add(f, t, cap), add(t, f, 0); }\n\nint dep[3003];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= vcnt; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i])\n            if (!dep[v = to[i]] && c[i]) dep[v] = dep[u] + 1, q.push(v);\n    }\n    return dep[t];\n}\nint iter[3003];\n\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        int d = dfs(v, min(dist, c[i]));\n        if (d) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\n\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= vcnt; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\nvoid solve(int p) {\n    cnt = 1;\n    for (int i = 1; i <= vcnt; ++i) hd[i] = 0;\n    int lim = w[p], rt = 0;\n    for (int i = 1; i <= n; ++i) lim += a[p][i];\n    for (int i = 1; i <= n; ++i) {\n        if (i == p) continue;\n        if (w[i] > lim) return;\n        add_E(i, t, lim - w[i]);\n        for (int j = 1; j < i; ++j)\n            if (j != p && a[i][j]) {\n                add_E(s, id[i][j], a[i][j]), rt += a[i][j];\n                add_E(id[i][j], i, a[i][j]), add_E(id[i][j], j, a[i][j]);\n            }\n    }\n    if (Dinic() == rt) printf(\"%d \", p);\n}\n\nint main() {\n    n = read(), s = n + 1, t = n + 2, vcnt = n + 2;\n    for (int i = 1; i <= n; ++i) w[i] = read(), read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) id[i][j] = ++vcnt;\n    for (int i = 1; i <= n; ++i) solve(i);\n    puts(\"\");\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n\n```\n",
        "postTime": 1578295532,
        "uid": 51237,
        "name": "Kinandra",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1264 \u3010K-\u8054\u8d5b\u3011"
    },
    {
        "content": "\u6bd4\u8f83\u597d\u7684\u7f51\u7edc\u6d41\u9898\u3002\n\n## Description\n\n\u7ed9\u51fa\u6bcf\u4e2a\u961f\u76ee\u524d\u7684\u80dc\u573a\uff0c\u5df2\u7ecf\u8fd8\u672a\u8fdb\u884c\u7684\u6bd4\u8d5b\u60c5\u51b5\uff0c\u95ee\u6709\u54ea\u4e9b\u961f\u4f0d\u53ef\u80fd\u4f1a\u6210\u4e3a\u5168\u573a\u80dc\u573a\u6700\u591a\u7684\u961f\u4f0d\u3002\n\n## Solution\n\n\u8fd9\u4e2a\u5efa\u56fe\u6709\u6700\u5c0f\u6743\u95ed\u5408\u5b50\u56fe\u7684\u611f\u89c9\u3002\n\n\u9996\u5148\uff0c\u8003\u8651\u4ec0\u4e48\u65f6\u5019\u53ef\u4ee5\u80dc\u573a\u6700\u591a\uff0c\u663e\u7136\u662f\u5982\u679c\u4e00\u4e2a\u961f\u4f0d\u5269\u4e0b\u7684\u6240\u6709\u6bd4\u8d5b\u90fd\u8d62\u4e86\uff0c\u7136\u540e\u83b7\u80dc\u7684\u573a\u6b21\u662f\u5168\u573a\u6700\u591a\u65f6\uff0c\u4ed6\u624d\u6709\u53ef\u80fd\u662f\u5168\u573a\u80dc\u573a\u6700\u591a\u7684\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u904d\u5386\u6bcf\u4e2a\u961f\u4f0d\uff0c\u4f9d\u6b21\u8ba9\u4ed6\u4eec\u53d6\u5f97\u6240\u6709\u7684\u80dc\u5229\uff0c\u7136\u540e\u5224\u65ad\u4e00\u4e0b\u4ed6\u4eec\u662f\u5426\u53ef\u4ee5\u6210\u4e3a\u80dc\u573a\u6700\u591a\u7684\u961f\u4f0d\u3002\n\n\u56e0\u4e3a\u6bcf\u4e24\u4e2a\u961f\u4f0d\u8fdb\u884c\u4e00\u573a\u6bd4\u8d5b\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u6bd4\u8d5b\u548c\u961f\u4f0d\u5206\u522b\u4f5c\u4e3a\u70b9\u6765\u5efa\u56fe\u3002\n\n\u5177\u4f53\u65b9\u6cd5\u5982\u4e0b\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u961f\u4f0d\uff1a\n\n- \u9996\u5148\u7edf\u8ba1\u5f53\u524d\u961f\u4f0d\u7684\u6700\u5927\u80dc\u573a\uff08\u5df2\u80dc\u548c\u53ef\u80fd\u80dc\u7684\uff09\uff1b\n\n- \u6e90\u70b9\u5411\u5bf9\u4e8e\u6bcf\u7ec4\u6bd4\u8d5b\u8fde\u5bb9\u91cf\u4e3a\u6bd4\u8d5b\u573a\u6b21\u7684\u8fb9\uff1b\n\n- \u6bcf\u7ec4\u6bd4\u8d5b\u5411\u53c2\u52a0\u7684\u4e24\u652f\u961f\u4f0d\u5206\u522b\u8fde\u5bb9\u91cf\u65e0\u7a77\u5927\u7684\u8fb9\uff1b\n\n- \u6bcf\u652f\u961f\u4f0d\u5411\u6c47\u70b9\u8fde\u5bb9\u91cf\u4e3a\u81ea\u5df1\u7684\u5f53\u524d\u80dc\u573a\u6570\u4e0e\u5f53\u524d\u7684\u6700\u5927\u80dc\u573a\u5dee\u503c\u7684\u8fb9\u3002\n\n\n\u7136\u540e\u8dd1\u51fa\u7684\u6bcf\u7ec4\u6700\u5927\u6d41\uff0c\u5982\u679c\u7b49\u4e8e\u5f53\u524d\u8fd8\u672a\u8fdb\u884c\u7684\u603b\u573a\u6b21\uff0c\u90a3\u4e48\u8bf4\u660e\u5f53\u524d\u8fd9\u652f\u961f\u4f0d\u53ef\u80fd\u6210\u4e3a\u5168\u573a\u80dc\u573a\u6700\u591a\u7684\u961f\u4f0d\u3002\n\n\u7136\u540e\u6709\u51e0\u4e2a\u5730\u65b9\uff1a\n\n1. \u5982\u679c\u7edf\u8ba1\u5b8c\u4e00\u4e2a\u961f\u4f0d\u7684\u80dc\u573a\u4e4b\u540e\u4ecd\u6bd4\u53e6\u4e00\u4e2a\u961f\u4f0d\u7684\u5df2\u80dc\u573a\u6b21\u5c11\uff0c\u90a3\u4e48\u5c31\u4e0d\u7528\u8dd1\u7f51\u7edc\u6d41\u4e86\uff1b\n\n1. \u5982\u679c\u5f53\u524d\u8fb9\u7684\u5bb9\u91cf\u662f 0 \u7684\u8bdd\u53ef\u4ee5\u4e0d\u7528\u5efa\u8fd9\u6761\u8fb9\uff0c\u5426\u5219\u4f1a\u51fa\u5947\u5947\u602a\u602a\u7684\u9519\u8bef\uff0c\u6bd4\u5982\u8d85\u65f6\u7b49\u7b49\uff1b\n\n1. \u603b\u573a\u6b21\u5982\u679c\u5728\u8f93\u5165\u4e2d\u5904\u7406\uff0c\u8bb0\u5f97\u9664\u4ee5\u4e8c\uff1b\n\n1. \u6bcf\u6b21\u5faa\u73af\u8bb0\u5f97\u521d\u59cb\u5316\u3002\n\n```cpp\n#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define rr register \n#define maxn 5010\n#define INF 0x3f3f3f3f\n//#define int long long\nusing namespace std;\n\nint n,tot=1,s,t,cnt,all;\nint a[maxn][maxn],id[maxn][maxn];\nint Dis[maxn],head[maxn],cur[maxn];\nstruct node{int win,defeat;}b[maxn];\nstruct edge{int fr,to,dis,nxt;}e[maxn*maxn];\n\ninline int read(){\n    rr int s=0,w=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n    return s*w;\n}\n\nvoid add(int fr,int to,int dis){\n    e[++tot]=(edge){fr,to,dis,head[fr]};head[fr]=tot;\n    e[++tot]=(edge){to,fr,0,head[to]};head[to]=tot;\n}\n\nbool bfs(){\n    memset(Dis,-1,sizeof Dis);\n    queue<int> q;q.push(s);\n    Dis[s]=0;cur[s]=head[s];\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=e[i].nxt){\n            int to=e[i].to;\n            if(e[i].dis&&Dis[to]==-1){\n                q.push(to);\n                Dis[to]=Dis[u]+1;\n                cur[to]=head[to];\n                if(to==t) return true;\n            }\n        }\n    }\n    return false;\n}\n\nint dfs(int u,int limit){\n    if(u==t) return limit;int flow=0;\n    for(int i=cur[u];i&&flow<limit;i=e[i].nxt){\n        int to=e[i].to;cur[u]=i;\n        if(e[i].dis&&Dis[to]==Dis[u]+1){\n            int f=dfs(to,min(e[i].dis,limit-flow));\n            if(!f)Dis[to]=-1;e[i].dis-=f;e[i^1].dis+=f;\n            flow+=f;\n        }\n    }\n    return flow;\n}\n\nint dinic(){\n    int Maxflow=0,flow=0;\n    while(bfs())\n        while(flow=dfs(s,INF))\n            Maxflow+=flow;\n    return Maxflow;\n}\n\nvoid clear(){\n    tot=1;\n    memset(cur,0,sizeof cur);\n    memset(head,0,sizeof head);\n}\n\nint main(){\n    n=read();s=n*(n+3);t=s+1;\n    for(rr int i=1;i<=n;i++)\n        b[i].win=read(),b[i].defeat=read();\n    for(rr int i=1;i<=n;i++)for(rr int j=1;j<=n;j++)\n        all+=(a[i][j]=read()),id[i][j]=++cnt;\n    for(rr int i=1,tMxs;i<=n;i++){\n        tMxs=b[i].win;bool flag=0;\n        for(rr int j=1;j<=n;j++) tMxs+=a[i][j];\n        for(rr int j=1;j<=n;j++) if(tMxs<b[j].win){flag=1;break;}\n        if(flag) continue;\n        for(rr int j=1;j<=n;j++){\n            for(rr int k=j+1;k<=n;k++){\n                if(a[k][j]) add(s,id[j][k]+n,a[k][j]);\n                add(id[j][k]+n,j,INF),add(id[j][k]+n,k,INF);\n            }   \n            if(tMxs-b[j].win>=0) add(j,t,tMxs-b[j].win);\n        }\n        int ans=dinic();\n        if(ans==all/2) printf(\"%d \",i);clear();\n    }\n    return 0;\n}\n```\n",
        "postTime": 1621134772,
        "uid": 281497,
        "name": "KEBrantily",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P1264 \u3010K-\u8054\u8d5b\u3011"
    },
    {
        "content": "### \u9898\u76ee\u5927\u610f\n\n\u5df2\u77e5\u6bcf\u652f\u961f\u4f0d\u7684\u80dc\u573a\u548c\u5f85\u6bd4\u8d5b\u7684\u60c5\u51b5\uff0c\u6c42\u53ef\u80fd\u6210\u4e3a\u80dc\u573a\u6700\u591a\u7684\u961f\u4f0d\u4e2a\u6570\uff08\u5e76\u5217\u4e5f\u7b97\u6700\u591a\uff09\u3002\n\n### \u89e3\u9898\u601d\u8def\n\n\u8d2a\u5fc3\uff1a\u5bf9\u4e8e\u6bcf\u652f\u961f\u4f0d\uff0c\u8981\u60f3\u80dc\u573a\u6700\u591a\uff0c\u663e\u7136\u672a\u53c2\u4e0e\u7684\u6240\u6709\u6bd4\u8d5b\u90fd\u5e94\u83b7\u80dc\u3002\n\n\u5224\u65ad\uff1a\u679a\u4e3e\u6bcf\u652f\u961f\u4f0d\uff0c\u5224\u65ad\u5176\u4ed6\u961f\u4f0d\u7684\u80dc\u573a\u80fd\u5426\u4e0d\u8d85\u8fc7\u8be5\u961f\u4f0d\u3002\n\n### \u5efa\u56fe\n\n\u8003\u8651\u5bf9\u6bd4\u8d5b\u548c\u961f\u4f0d\u5206\u522b\u5efa\u70b9\u3002\n\n\u56e0\u4e3a\u8981\u4fdd\u8bc1\u6240\u6709\u5176\u4ed6\u961f\u4f0d\u7684\u80dc\u573a\u4e0d\u8d85\u8fc7\u5f53\u524d\u679a\u4e3e\u7684\u961f\u4f0d $i$\uff0c\u6240\u4ee5\u4ece\u5176\u4ed6\u961f\u4f0d\u5411\u6c47\u70b9\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a\u8be5\u961f\u4f0d\u8fd8\u80fd\u83b7\u80dc\u7684\u6700\u591a\u573a\u6b21\uff0c\u5373 $W_i-w_j$ \u7684\u8fb9\uff08\u5176\u4e2d $W_i$ \u4e3a\u961f\u4f0d $i$ \u8d62\u5f97\u6240\u6709\u6bd4\u8d5b\u83b7\u5f97\u7684\u80dc\u573a\u6570\uff0c\u9884\u5904\u7406\u51fa\u6765\uff09\u3002\n\n\u540c\u65f6\uff0c\u5bf9\u4e8e\u6bcf\u573a\u6bd4\u8d5b\uff0c\u5411\u53c2\u4e0e\u6bd4\u8d5b\u7684\u4e24\u652f\u961f\u4f0d\u5206\u522b\u8fde\u4e0a\u5bb9\u91cf\u4e3a\u6bd4\u8d5b\u573a\u6570\uff0c\u5373 $a_{ij}$ \u7684\u8fb9\uff0c\u518d\u4ece\u6e90\u70b9\u5411\u6bcf\u573a\u6bd4\u8d5b\u8fde\u4e0a\u76f8\u540c\u5bb9\u91cf\u7684\u8fb9\u3002\n\n\u6b64\u65f6\u7684\u7f51\u7edc\u6700\u5927\u6d41\u8868\u793a\u5728\u6240\u6709\u961f\u4f0d\u80dc\u573a\u4e0d\u8d85\u8fc7\u961f\u4f0d $i$ \u7684\u524d\u63d0\u4e0b\uff0c\u80fd\u5339\u914d\u7684\u6bd4\u8d5b\u573a\u6570\u3002\u56e0\u6b64\u5c06\u7f51\u7edc\u6700\u5927\u6d41\u4e0e\u961f\u4f0d $i$ **\u4e0d**\u53c2\u4e0e\u7684\u6bd4\u8d5b\u573a\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u82e5\u76f8\u7b49\u5219\u8bf4\u660e\u961f\u4f0d $i$ \u53ef\u80fd\u83b7\u80dc\uff0c\u8f93\u51fa\u5373\u53ef\u3002\n\n### \u5904\u7406\u7ec6\u8282\n\n+ \u5efa\u70b9\u8fde\u8fb9\u65f6\uff0c\u8981\u8df3\u8fc7\u5f53\u524d\u679a\u4e3e\u7684\u961f\u4f0d\u53ca\u5176\u53c2\u52a0\u7684\u6bd4\u8d5b\u3002\n\n+ \u8fde\u8fb9\u65f6\uff0c\u6bcf\u4e24\u4e2a\u961f\u4f0d\u95f4\u7684\u6bd4\u8d5b\u53ea\u8fde\u4e00\u6761\u8fb9\u3002\n\n+ \u5bf9\u4e8e\u4e00\u652f\u961f\u4f0d $i$\uff0c\u82e5\u5b58\u5728\u53e6\u4e00\u652f\u961f\u4f0d $j$ \u4f7f\u5f97 $w_j>W_i$\uff0c\u5219\u663e\u7136\u961f\u4f0d $i$ \u4e0d\u53ef\u80fd\u6210\u4e3a\u80dc\u573a\u6700\u591a\u7684\u961f\u4f0d\uff0c\u6b64\u65f6\u4e0d\u7528\u8dd1\u7f51\u7edc\u6d41\u3002\n\n+ \u82e5\u4e24\u652f\u961f\u4f0d\u4e4b\u95f4\u5df2\u7ecf\u6ca1\u6709\u6bd4\u8d5b\uff0c\u5219\u4e0d\u9700\u8981\u8fde\u8fb9\u3002\n\n+ \u6bcf\u6b21\u679a\u4e3e\u8981\u521d\u59cb\u5316\u3002\n\n### \u4e11\u964b\u7684\u4ee3\u7801\n\n```cpp\n\n#include <bits/stdc++.h>\nusing namespace std;\nint n,sh[30],fu[30],maxm[30],sai[30][30],cnt=1,lst[100005],s,t,sum,pre,mid,dep[100005],now[100005],inf=0x3f3f3f3f;\nstruct edge{\n\tint f,t,val,lst;\n\tedge(int f=0,int t=0,int val=0,int lst=0):\n\t\tf(f),t(t),val(val),lst(lst){};\n}e[100005];\nvoid add(int u,int v,int val){\n\te[++cnt]=edge(u,v,val,lst[u]);\n\tlst[u]=cnt;\n\te[++cnt]=edge(v,u,0,lst[v]);\n\tlst[v]=cnt;\n}\nbool bfs(){\n\tmemset(dep,-1,sizeof(dep));\n\tqueue<int> q;\n\tq.push(s),dep[s]=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();\n\t\tnow[u]=lst[u];\n\t\tq.pop();\n\t\tfor(int i=lst[u];i;i=e[i].lst){\n\t\t\tint v=e[i].t;\n\t\t\tif(e[i].val&&dep[v]==-1){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t]!=-1;\n}\nint dfs(int u,int in){\n\tif(u==t)return in;\n\tint out=0;\n\tfor(int i=now[u];i;i=e[i].lst){\n\t\tnow[u]=i;\n\t\tint v=e[i].t;\n\t\tif(e[i].val&&dep[v]==dep[u]+1){\n\t\t\tint go=dfs(v,min(in,e[i].val));\n\t\t\te[i].val-=go;\n\t\t\te[i^1].val+=go;\n\t\t\tin-=go,out+=go;\n\t\t\tif(go==0)dep[v]=-1;\n\t\t\tif(in==0)break;\n\t\t}\n\t}\n\tif(out==0)dep[u]=-1;\n\treturn out;\n}\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>sh[i]>>fu[i];\n\tfor(int i=1;i<=n;i++){\n\t\tmaxm[i]=sh[i];\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcin>>sai[i][j];\n\t\t\tmaxm[i]+=sai[i][j];\n\t\t\tsum+=sai[i][j];\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tbool fl=0;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i==j)continue;\n\t\t\tif(sh[j]>maxm[i]){\n\t\t\t\tfl=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fl)continue;\n\t\ts=0,t=(n-1)*(n-2)/2+n+1,mid=(n-1)*(n-2)/2;\n\t\tfor(int j=0;j<=cnt;j++)e[j].f=e[j].t=e[j].val=lst[j]=e[j].lst=0;\n\t\tcnt=1,pre=0;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(j==i)continue;\n\t\t\tadd(mid+j,t,maxm[i]-sh[j]);\n\t\t\tfor(int k=j+1;k<=n;k++){\n\t\t\t\tif(k==i)continue;\n\t\t\t\tadd(0,++pre,sai[j][k]);\n\t\t\t\tadd(pre,mid+j,inf);\n\t\t\t\tadd(pre,mid+k,inf);\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tans+=dfs(s,inf);\n\t\t}\n\t\tif(ans==sum/2-maxm[i]+sh[i])cout<<i<<' ';\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1657596911,
        "uid": 342873,
        "name": "\u6709\u8da3\u7684\u95ee\u9898",
        "ccfLevel": 0,
        "title": "P1264 K-\u8054\u8d5b \u9898\u89e3"
    },
    {
        "content": "# P1264 \u3010K-\u8054\u8d5b\u3011\n## Solution\n\u8003\u8651\u4e00\u4e2a\u4e8b\u60c5\uff1a\u6bcf\u4e00\u4e2a\u961f\u4f0d\u7684\u8f93\u5c40\u662f\u6ca1\u6709\u7528\u7684\n\n\u8d2a\u5fc3\u4e00\u4e0b\uff0c\u8ba9\u6bcf\u4e2a\u961f\u4f0d\u628a\u5269\u4e0b\u7684\u6bd4\u8d5b\u8d62\u4e0b\u6765\u7684\u65f6\u5019\uff0c\u6700\u6709\u53ef\u80fd\u593a\u51a0\n\n\u8bbe\u6700\u7ec8\u5f53\u524d\u961f\u8d62\u5f97\u7684\u573a\u6570\u7684 $maxx$ \n\n\u7136\u540e\u6211\u4eec\u5efa\u56fe\n\n\u6bcf\u4e00\u573a\u6bd4\u8d5b\u90fd\u4f1a\u8ba9\u80dc\u8005\u7684\u80dc\u5229\u573a\u6b21\u52a0$1$ ,\u628a \u6bd4\u8d5b\u7684\u573a\u6b21\u5f53\u6210\u4e00\u4e2a\u70b9\uff0c\u961f\u4f0d\u5f53\u6210\u4e00\u4e2a\u70b9\n\n\u6bcf\u573a\u6bd4\u8d5b\u5411\u961f\u4f0d\u5206\u522b\u8fde\u8fb9\uff0c\u8fb9\u6743\u4e3a $1$ \uff0c\u6e90\u70b9\u5411 \u6bd4\u8d5b\u573a\u6b21\u8fde\uff0c\u7136\u540e\u961f\u4f0d\u5411\u6c47\u70b9\u8fde\n\n\u8dd1\u7f51\u7edc\u6d41\u5c31\u884c\u4e86\n\n## $code$\n```\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define cl(x) memset(x, 0, sizeof(x))\nnamespace yspm {\ninline int read() {\n    int res = 0, f = 1;\n    char k;\n    while (!isdigit(k = getchar()))\n        if (k == '-')\n            f = -1;\n    while (isdigit(k)) res = res * 10 + k - '0', k = getchar();\n    return res * f;\n}\nint n, s, t, tot;\nconst int N = 1e4 + 10;\nint head[N], w[N], a[N][N], id[N][N], dep[N], cnt = 1;\nstruct node {\n    int nxt, to, lim;\n} e[N << 1];\ninline void add2(int u, int v, int w) {\n    e[++cnt].lim = w;\n    e[cnt].nxt = head[u];\n    e[cnt].to = v;\n    return head[u] = cnt, void();\n}\ninline void add1(int u, int v, int w) {\n    add2(u, v, w);\n    add2(v, u, 0);\n    return;\n}\nqueue<int> q;\ninline bool bfs() {\n    cl(dep);\n    dep[s] = 1;\n    q.push(s);\n    while (q.size()) {\n        int fr = q.front();\n        q.pop();\n        for (int i = head[fr]; i; i = e[i].nxt) {\n            int t = e[i].to;\n            if (!dep[t] && e[i].lim)\n                dep[t] = dep[fr] + 1, q.push(t);\n        }\n    }\n    return dep[t];\n}\ninline int dfs(int now, int in) {\n    if (now == t)\n        return in;\n    for (int i = head[now]; i && in; i = e[i].nxt) {\n        int t = e[i].to;\n        if (!e[i].lim || dep[t] != dep[now] + 1)\n            continue;\n        int res = dfs(t, min(e[i].lim, in));\n        e[i].lim -= res;\n        e[i ^ 1].lim += res;\n        if (res)\n            return res;\n    }\n    return 0;\n}\ninline void solve(int x) {\n    cl(head);\n    cnt = 1;\n    cl(e);\n    int maxx = w[x], tmp = 0;\n    for (int i = 1; i <= n; ++i) maxx += a[x][i];\n    for (int i = 1; i <= n; ++i) {\n        if (i == x)\n            continue;\n        if (w[i] > maxx)\n            return;\n        add1(i, t, maxx - w[i]);\n        for (int j = 1; j < i; ++j) {\n            if (j != x && a[i][j]) {\n                add1(s, id[i][j], a[i][j]), tmp += a[i][j];\n                add1(id[i][j], i, a[i][j]);\n                add1(id[i][j], j, a[i][j]);\n            }\n        }\n    }\n    int sum = 0, d;\n    while (bfs()) {\n        while (d = dfs(s, 1e15 + 10)) sum += d;\n    }\n    if (sum == tmp)\n        printf(\"%lld \", x);\n    return;\n}\nsigned main() {\n    n = read();\n    s = n + 1, t = n + 2, tot = n + 2;\n    for (int i = 1, k; i <= n; ++i) w[i] = read(), k = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j <= n; ++j) a[i][j] = read();\n    for (int i = 1; i <= n; ++i)\n        for (int j = 1; j < i; ++j) id[i][j] = ++tot;\n    for (int i = 1; i <= n; ++i) solve(i);\n    puts(\"\");\n    return 0;\n}\n}\n```\n\n\u8282\u9009\u81ea[https://www.cnblogs.com/yspm/p/12361174.html](https://www.cnblogs.com/yspm/p/12361174.html)\n\n",
        "postTime": 1608966820,
        "uid": 459656,
        "name": "\u95ed\u7535\u8111\u6c89\u601d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1264 \u3010K-\u8054\u8d5b\u3011"
    }
]