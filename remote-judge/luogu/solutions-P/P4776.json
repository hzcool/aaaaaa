[
    {
        "content": "\u72b6\u538bdp\uff0c\u9700\u8981\u4e00\u5b9a\u4ee3\u7801\u80fd\u529b\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6811\uff0c\u679a\u4e3e\u5176\u5de6\u8fb9k\u4e2a\u53f6\u5b50\u548c\u53f3\u8fb9k\u4e2a\u53f6\u5b50\u7684\u8054\u901a\u60c5\u51b5\uff0c\u5176\u4f59\u7684\u53f6\u5b50\u8282\u70b9\u4e0d\u662f\u8def\u5f84\u7aef\u70b9\u72b6\u6001\u3002\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u5171\u6709\u56db\u79cd\u60c5\u51b5\u3002\n1. \u4e0d\u662f\u8def\u5f84\u7684\u7aef\u70b9\u3002\uff08\u8bb0\u4e3a0\uff09\n1. \u662f\u5b50\u6811\u6839\u6240\u5728\u8def\u5f84\u7684\u7aef\u70b9\u3002\uff08\u8bb0\u4e3a1\uff0c\u5408\u6cd5\u72b6\u6001\u4e2d\u8be5\u8282\u70b9\u4e2a\u6570\u5c0f\u4e8e\u7b49\u4e8e2\uff09\n1. \u4e0d\u4e0e\u4efb\u4f55\u70b9\u76f8\u8fde\uff0c\u5355\u72ec\u7ec4\u6210\u4e00\u79cd\u8def\u5f84\u3002\uff08\u8bb0\u4e3a-1\uff09\n1. \u662f\u975e\u5b50\u6811\u6839\u6240\u5728\u8def\u5f84\u8def\u5f84\u7684\u7aef\u70b9\u3002\uff08\u6bcf\u6761\u8def\u5f84\u8bb0\u4e3a\u4e00\u79cd\u989c\u8272\uff09\n\n\u9884\u5904\u7406\u51fa\u72b6\u6001\u4e24\u4e24\u4e4b\u95f4\u7684\u8f6c\u79fb\u60c5\u51b5\u3002\u53ea\u8003\u8651\u5de6\u53f3\u5b50\u6811\u53f6\u5b50\u8282\u70b9\u4e4b\u95f4\u8fde\u8fb9\u60c5\u51b5\u5373\u53ef\u3002\u4e4b\u540e\u76f4\u63a5\u8fdb\u884c\u6811\u5f62dp\u5373\u53ef\u3002\u7edf\u8ba1\u7b54\u6848\u65f6\uff0c\u679a\u4e3e\u6700\u5de6k\u4e2a\u53f6\u5b50\u548c\u6700\u53f3k\u4e2a\u53f6\u5b50\u7684\u8fde\u8fb9\u60c5\u51b5\u5373\u53ef\u3002\uff08\u5f53\u53f6\u5b50\u603b\u6570\u5c0f\u4e8e\u7b49\u4e8e2k\u65f6\uff0c\u7531\u4e8e\u53f6\u5b50\u4e4b\u95f4\u8fde\u8fb9\u4f1a\u88ab\u91cd\u590d\u8ba1\u7b97\uff0c\u53ea\u80fd\u5c06\u94fe\u7f29\u4e3a\u4e00\u4e2a\u70b9\u540e\u76f4\u63a5\u66b4\u529b\uff09\u3002\u5177\u4f53\u8be6\u89c1\u4ee3\u7801\u3002\n\nk=3\uff0c\u5408\u6cd5\u72b6\u6001\u6570\u5171\u67092665\u79cd\u3002\u5de6\u53f3\u72b6\u6001\u53f6\u5b50\u4e2a\u6570\u5747\u5927\u4e8e\u7b49\u4e8e6\u65f6\uff0c\u8f6c\u79fb\u5171\u6709201536\u79cd\u3002\u53ef\u4ee5\u901a\u8fc7\u3002\n\n\n\n```\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<iostream>\n#include<map>\n#include<cstring>\n#define ll long long\n#define maxn 1005\n#define p 998244353 \n#define re(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ninline int read(){char c=getchar();int f=1;int ans = 0;while(c>'9'||c<'0'){if(c=='-')f=-f;c=getchar();}while(c<='9'&&c>='0'){ans =ans*10+c-'0';c=getchar();}return ans*f;}\n//_____________________________________________________________________________________________________\nint k,used[maxn],_n,n,m,_a[maxn][maxn],__a[maxn][maxn],leaf[maxn],_st[maxn];\nll ans;\ninline int dfs1(int x)//\u7f29\u94fe\n{\n    int cnt = 0,y;\n    re(i,1,_n)\n        if(_a[x][i])\n            cnt++;\n    if(cnt==1)\n    {\n        re(i,1,_n)\n            if(_a[x][i])\n                return dfs1(i);\n    }\n    used[x] = 1;\n    if(!cnt)\n    {\n        _st[++_st[0]] = ++n;\n        leaf[n]=1;\n        return n;\n    }\n    int _x = ++n;\n    re(i,1,_n)\n        if(_a[x][i])\n        {\n            int y = dfs1(i);\n            leaf[_x] += leaf[y] ;\n            if(used[i])\n                __a[_x][y] = 1;\n            else\n            {\n                leaf[++n] = leaf[y];\n                __a[_x][n] = __a[n][y] = 1;\n            }\n        }\n    return _x; \n}\ninline void build()\n{\n    re(i,1,_n)\n        if(_a[1][i])\n        {\n            int y = dfs1(i);\n            leaf[1] += leaf[y];\n            if(used[i])\n                __a[1][y] = 1;\n            else\n            {\n                leaf[++n]=leaf[y];\n                __a[1][n] = __a[n][y] = 1;\n            }\n        }\n}\nint __dp[1<<21][25];\ninline void solve1()//\u66b4\u529b\n{\n    ans = 0;\n    re(i,1,_st[0])\n        re(j,1,k)\n            __a[ _st[i] ][ _st[ i+j>_st[0] ? i+j-_st[0] : i+j ] ] = 1;\n    re(i,1,n)\n        re(j,1,n)\n            if(__a[i][j])\n                __a[j][i] = 1;\n    int S = (1<<n)-1;__dp[1][1] = 1;\n    for(int s=1;s<=S;s+=2)\n        re(x,1,n)\n            if(__dp[s][x]&&((s>>x-1)&1))\n                re(y,1,n)\n                    if(__a[x][y]&&(((s>>y-1)&1)==0))\n                        (__dp[ s|(1<<y-1) ][y] += __dp[s][x])%=p;\n    re(i,1,n)\n        if(__a[1][i])\n            (ans+=__dp[S][i])%=p;\n    printf(\"%d\\n\",ans*(p+1)/2%p);\n}\n//______________________________________________\nint match[40];\nstruct node\n{\n    int len,root;\n    int s[13];\n    inline void clear()\n    {\n        re(i,1,13)\n            s[i] = 0;\n        len = root = 0;\n    }\n    void pri()\n    {\n        printf(\"%d|\",root);\n        re(i,1,len)\n            printf(\"%d \",s[i]);\n        printf(\"\\n________________________\\n\");\n    };\n    inline bool operator <(node x)const\n    {\n        if(root!=x.root ) return root<x.root ;\n        if(len!=x.len) return len<x.len ;\n        re(i,1,len)\n            if(s[i]!=x.s [i])\n                return s[i] < x.s [i];\n        return false;\n    }\n    inline void sort(int sz)\n    {\n        int cnt = 1;\n        re(i,2,sz)\n            match[i] = 0;\n        re(i,1,len)\n            if( s[i]>1 )\n            {\n                if( match[s[i]] )\n                    s[i] = match[s[i]];\n                else\n                    s[i] = match[s[i]] = ++cnt;\n            }\n    }\n}node1,a[maxn*40];\nmap<node,int> mp;\nint tot;\nvoid dfs2(int i,int cnt)\n{\n    if(i==node1.len +1)\n    {\n        re(j,1,node1.len )\n            if(node1.s [j])\n            {\n                a[++tot] = node1;\n                mp[node1] = tot;\n                break;\n            }\n        return ;\n    }\n    dfs2(i+1,cnt);\n    if(!node1.s [i])\n    {\n        node1.s[i] = cnt+1;\n        re(j,i+1,node1.len )\n            if(!node1.s [j])\n            {\n                node1.s [j] = cnt+1;\n                dfs2(i+1,cnt+1);\n                node1.s [j] = 0;\n            }\n        node1.s [i] = 0; \n    }\n}\nstruct turn\n{\n    int x,y,to;\n    turn(int x=0,int y=0,int to=0)\n    :x(x),y(y),to(to){};\n}f[7][7][210000];\nint tot_f[7][7];\n#define pr pair<int,int> \nint st1[maxn*200],_st2;\npr st2[maxn*200];\ninline void check(node x,int cnt)\n{\n    re(i,k+1,x.len-k)\n        if(x.s [i])\n            return;\n    node1.clear(); \n    if(x.len>2*k)\n    {\n        node1.root = x.root ;\n        node1.len = 2*k;\n        re(i,1,k)\n            node1.s [i] = x.s[i];\n        re(i,x.len -k+1,x.len )\n            node1.s [i- x.len  + 2*k] = x.s[i] ;\n    }\n    else node1 = x; \n    node1.sort(cnt);\n    if( mp[node1]!=0 )\n        st1[++st1[0]] = mp[node1];\n}\nint vis[20];\ninline void dfs3(int i,int lim,node x,int cnt)\n{\n    if(i==lim+1)\n    {\n        check(x,cnt+1);\n        return ;\n    }\n    dfs3(i+1,lim,x,cnt+1);\n    if(x.s [i]>0)\n        re(j,lim+1,min(x.len ,i+k))\n        {\n            int n_col = x.s [j]==1 || x.s[i] == 1 ? 1 : cnt+1;\n            if(x.s [j]>0&&(x.s [j]!=x.s [i]||x.s[j]==1 ))\n            {\n                node1 = x;\n                re(t,1,x.len )\n                    if( x.s [t] == x.s [i] || x.s [t]==x.s [j] )\n                        node1.s[t] = n_col;\t\n                node1.s [i] = node1.s [j] = 0;\t\t\t\n                dfs3(i+1,lim,node1,cnt+1);\n            }\n            if(x.s [j]==-1)\n            {\n                node1 = x;\t\n                node1.s [j] = node1.s [i];\n                node1.s [i] = 0;\n                dfs3(i+1,lim,node1,cnt+1);\n            }\n        }\n    if(x.s [i]==-1)\n        re(j,lim+1,min(x.len,i+k))\n            if(x.s [j])\n            {\n                node1  = x;\n                if(x.s [j]==-1)\n                    node1.s [i] = node1.s [j] = cnt+1;\n                else \n                    node1.s [i] = node1.s [j],\n                    node1.s [j] = 0;\n                dfs3(i+1,lim,node1,cnt+1);\n                re(t,j+1,min(x.len,i+k))\n                    if(x.s[t]==-1 ||(x.s[t]>0&&(x.s[t]!=x.s[j] || x.s[t]==1)))  \n                    {\n                        node1 = x;\n                        node1.s [i] = 0;\n                        if( x.s[j]==-1 && x.s[t] ==-1 )\n                            node1.s [j] = node1.s [t] = cnt+1 ;\n                        if( x.s[j]==-1 && x.s[t]!=-1)\n                            node1.s [j] = node1.s [t] , node1.s [t] = 0;\n                        if( x.s [j]!=-1&& x.s[t]==-1)\n                            node1.s [t] = node1.s [j] , node1.s [j] = 0;\n                        if( x.s [j]!=-1&&x.s[t]!=-1)\n                        {\n                            int n_col = x.s [j]==1 || x.s[t] == 1 ? 1 : cnt+1;\n                            re(_t,1,x.len)\n                                if(x.s[_t]==x.s[j]|| x.s[_t] == x.s[t] )\n                                    node1.s [_t] = n_col ;\n                            node1.s [j] = node1.s [t] = 0;\n                        }\n                        dfs3(i+1,lim,node1,cnt+1);\t\n                    }\n            }\n}\ninline void Turn(node l,node r)\n{\n    if(l.root + r.root > 2)\n        return;\n    node1.clear();\n    re(i,1,l.len )\n        node1.s[i] = l.s [i];\n    re(i,1,r.len )\n        node1.s [ i+l.len ] = r.s [i] <=1 ? r.s [i] : r.s [i] + k ;\n    node1.root = l.root + r.root ;\n    node1.len = l.len + r.len ;\n    dfs3( max(1,l.len -k+1),l.len , node1 ,2*k+1 );\n}\ninline int _Turn(int x)\n{\n    if(a[x].root == 0)\n        return 0;\n    if(a[x].root == 1)\n        return x;\n    node1 = a[x];\n    node1.root = 0;\n    re(i,1,node1.len )\n        if(node1.s [i]==1)\n            node1.s [i] = k+2;\n    node1.sort(k+2);\n    return mp[node1];\n}\npr _f[maxn*40];int _tot_f,cnt_5;\nll dp[maxn][maxn*3],_dp[maxn*3];\ninline ll count(int i,node x,int col)\n{\n    if(x.len !=2*k || x.root !=2)\n        return 0;\n    if(i==k+1)\n    {\n        re(t,1,2*k)\n            if(x.s[t])\n                return 0;\n        return 1;\n    }\n    int cnt = 0;\n    if(!x.s[i])\n        cnt = count(i+1,x,col);\n    if(x.s[i]>0)\n        re(j,k+i,2*k)\n            if(x.s[j])\n            {\n                node1 = x;\n                if( x.s[j]>0 &&( x.s [j]==1 ||  x.s[i] !=x .s[j]))\n                {\n                    int n_col = x.s [i]==1 || x.s [j] ==1 ? 1 : col +1;\n                    re(t,1,2*k)\n                        if( x.s [t] == x.s[i] || x.s[t]== x.s[j] )\n                            node1.s [t] = n_col;\n                    node1.s [i] = node1.s [j] = 0;\n                    cnt += count(i+1,node1,col+1);\n                }\n                if( x.s[j]==-1 )\n                {\n                    node1.s [j] =  node1.s [i];\n                    node1.s [i] = 0;\n                    cnt += count(i+1,node1,col+1);\n                }\n            }\n    if(x.s[i]==-1)\n    {\n        re(j,k+i,2*k)\n            if(x.s[j])\n            {\n                re(t,j+1,2*k)\n                {\n                    node1  =x;\n                    if( x.s[t]==-1 ||(x.s[t]>0 && (x.s[t]==1|| x.s[t]!=x.s[j] )))\n                    {\n                        node1.s [i] = 0;\n                        if( x.s[j]==-1 && x.s[t] ==-1 )\n                            node1.s [j] = node1.s [t] = col+1;\n                        if( x.s[j]==-1 && x.s[t]!=-1)\n                            node1.s [j] = node1.s [t] , node1.s [t] = 0;\n                        if( x.s [j]!=-1&& x.s[t]==-1)\n                            node1.s [t] = node1.s [j] , node1.s [j] = 0;\n                        if( x.s [j]!=-1&&x.s[t]!=-1)\n                        {\n                            int n_col = x.s [j]==1 || x.s[t] == 1 ? 1 : cnt+1;\n                            re(_t,1,x.len)\n                                    if(x.s[_t]==x.s[j]||x.s[_t]==x.s[t])\n                                        node1.s [_t] = n_col ;\n                            node1.s [j] = node1.s [t] = 0;\n                        }\n                        cnt += count( i+1,node1,col+1 );\n                    }\n                }\n            }\n    }\n    return cnt;\t\n}\nvoid dfs4(int x)\n{\n    int bo = 0,cnt_leaf=0;\n    re(y,1,n)\n        if(__a[x][y])\n        {\n            dfs4(y);\n            if(!bo)\n            {\n                memcpy(dp[x],dp[y],sizeof(dp[x]));\n                bo = 1;\n                cnt_leaf = leaf[y];\n            }\n            else \n            {\n                memcpy(_dp,dp[x],sizeof(_dp));\n                memset(dp[x],0,sizeof(dp[x]));\n                re(t,1,tot_f[ cnt_leaf ][ leaf[y] ])\n                {\n                    turn _ = f[ cnt_leaf ][ leaf[y] ][t] ; \n                    ( dp[x][ _.to ] += _dp[ _.x ] * dp[y][ _.y ])%=p;\n                }\n                cnt_leaf = min( cnt_leaf + leaf[y] , 2*k); \n\t\t\t\n\t\t\n             }\n    \t}\n    if(!bo)\n    {\n        dp[x][1] = dp[x][2] = 1;\n        return ;\n    }\n    if(x!=1)\n    {\t\n       \n        memcpy(_dp,dp[x],sizeof(_dp));\n        memset(dp[x],0,sizeof(dp[x]));\n        re(t,1,_tot_f)\n            ( dp[x][ _f[t].second ] += _dp[ _f[t].first ] )%=p ;\n    }\n    else\n        re(t,1,tot)\n        {\n           ( ans += count(1,a[t],k+1) * dp[x][t] )%=p;\n       }\n}\nint main()\n{\n\t//freopen(\"0.in\",\"r\",stdin);\n    _n = read(),k=read();\n    re(i,2,_n)\n        _a[read()][i] = 1;\n    n = 1;\n    build();\n    re(i,1,n)\n    \tleaf[i] = min( leaf[i],2*k );\n    if(n<=21)\n    {\n     solve1();  \n\t return 0;\n    }\n    re(i,1,2*k)\n    {\n        node1.len = i;\n        re(s,0,(1<<i)-1)\n        {\n            re(w,1,i)\n                node1.s [w] = - ((s>>w-1)&1);\n            node1.root = 0;\n            dfs2(1,1);\n            re(j,1,i)\n                if(node1.s [j]!=-1)\n                {\n                    node1.root  = 1;\n                    node1.s [j] = 1;\n                    dfs2(1,1);\n                    node1.root = 2;\n                    re(k,j+1,i)\n                        if(node1.s [k]!=-1)\n                        {\n                            node1.s[k] = 1;\n                            dfs2(1,1);\n                            node1.s[k] = 0;\n                        }\n                    node1.s[j]=0;\n                }\t\n        }\n    }\t\t\t\n    node1.clear();\n    node1.root = 2;\n    node1.len = k*2;\n    a[++tot] = node1;\n    mp[node1] = tot;\n    re(i,1,tot)\n        re(j,1,tot)\n        {\n            st1[0] = 0;\n            Turn(a[i],a[j]);            \n            if(st1[0])\n      \t      re(t,1,st1[0])\n      \t          f[ a[i].len ][ a[j].len ][ ++tot_f[a[i].len ][a[j].len ]] = turn(i,j,st1[t]);\n       }\n    re(i,1,tot)\n    {\n        int to = _Turn(i);\n        if(to)\n\t    \t_f[++_tot_f] = make_pair( i,to );\n    }\n    dfs4(1);\n    printf(\"%lld\\n\",ans);\n    return  0;\n}\n\n```\n",
        "postTime": 1570794624,
        "uid": 118037,
        "name": "Yajnun",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4776 \u3010[NOI2018]\u591a\u8fb9\u5f62\u3011"
    }
]