[
    {
        "content": "\u51fa\u9898\u4eba\u7684\u5b98\u65b9\u9898\u89e3\n\n\u770b\u5230\u8fd9\u9053\u9898\u53ef\u80fd\u4f1a\u6709\u4e00\u4e9b\u9519\u8bef\u7684\u60f3\u6cd5\uff0c\u5178\u578b\u7684\u5c31\u662f\u6765\u56de\u90fd\u8d70\u6700\u77ed\u8def\uff0c\u4f46\u5b9e\u9645\u4e0a\u5230\u4e00\u4e2a\u70b9\u53bb\u65f6\u8d70\u6700\u77ed\u8def\uff0c\u56de\u6765\u5219\u4e0d\u4e00\u5b9a\u3002\u5982\u4e0b\u56fe\uff1a  \n![](https://cdn.luogu.com.cn/upload/image_hosting/5gsdemgy.png)\n\n1 \u53f7\u70b9\u662f\u8d77\u70b9\uff0c8 \u53f7\u70b9\u662f\u6bd2\u6c14\u70b9\uff0c\u53ef\u4ee5\u5230\u8fbe\u7684\u70b9\u4e3a 1~6\u3002\n\n---\n\u9996\u5148 BFS \u6c42\u51fa\u6bcf\u4e2a\u70b9\u5230\u8d77\u70b9\u548c\u6cc4\u9732\u70b9\u7684\u8ddd\u79bb\u3002\u7b80\u5355\u7684\u60f3\u6cd5\u662f\u66b4\u529b\u679a\u4e3e\u6bcf\u4e00\u4e2a\u70b9 BFS \u770b\u80fd\u5426\u56de\u5230\u8d77\u70b9\uff0c\u590d\u6742\u5ea6 $O(n^2)$\uff0c\u53ef\u4ee5\u62ff\u5230 30 \u5206\u3002\n\n\u6211\u4eec\u4ee4 $t_x$ \u8868\u793a\u80fd\u591f\u56de\u5230\u8d77\u70b9\u5230\u8fbe $x$ \u70b9\u7684\u6700\u665a\u65f6\u95f4\uff0c\u90a3\u4e48\u8d77\u70b9\u76f8\u90bb\u7684\u70b9\u90fd\u662f\u5b83\u4eec\u5230\u6bd2\u6c14\u70b9\u7684\u8ddd\u79bb\u3002\u5bf9\u4e8e\u5176\u4ed6\u7684\u70b9 $u$ \u6709 $t_u=\\max\\limits_{(u,v) \\in E}(t_v)-1$\u3002  \n\u628a\u6240\u6709\u8d77\u70b9\u76f8\u90bb\u7684\u70b9\u653e\u8fdb\u4e00\u4e2a\u5806\uff0c\u7528\u4e00\u4e2a\u4f18\u5148\u961f\u5217 BFS\uff0c\u6bcf\u4e2a\u70b9 $x$ \u7b2c\u4e00\u6b21\u88ab\u66f4\u65b0\u7684\u65f6\u5019\u5c31\u5f97\u5230\u4e86 $t_x$\uff0c\u590d\u6742\u5ea6 $O(n \\log n)$\uff0c\u53ef\u4ee5\u83b7\u5f97 70 \u5206\u3002  \n\u7136\u540e\u4f60\u4f1a\u53d1\u73b0 $t_x \\leq n$\uff0c\u5e76\u4e14\u5806\u4e2d $t$ \u7684\u6700\u5927\u503c\u5355\u8c03\u4e0d\u589e\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u4e00\u4e2a `std::vector` \u6765\u4ee3\u66ff\u8fd9\u4e2a\u5806\uff0c\u590d\u6742\u5ea6 $O(n+m)$\uff0c\u53ef\u4ee5\u901a\u8fc7\u6b64\u9898\u3002\n```cpp\n#include <algorithm>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <numeric>\n#include <vector>\nstruct Edge {\n  int to, nxt;\n} e[10000001];\nint n, m, E, head[5000001], s, t, dis[5000001], h[5000001];\nstd::vector<int> q2[5000001];\nbool vis[5000001];\nclass Queue {\n public:\n  Queue() { head_ = tail_ = 0; }\n  bool Empty() { return head_ == tail_; }\n  void Clear() { head_ = tail_ = 0; }\n  void Push(int x) { a_[tail_++] = x; }\n  int Front() { return a_[head_]; }\n  void Pop() { head_++; }\n  ~Queue() {}\n\n private:\n  int head_, tail_, a_[5000001];\n} q;\nchar gc() {\n  static char now[1 << 20], *S, *T;\n  if (T == S) {\n    T = (S = now) + std::fread(now, 1, 1 << 20, stdin);\n    if (T == S) return EOF;\n  }\n  return *S++;\n}\ntemplate <typename T>\nvoid Read(T &x) {\n  x = 0;\n  char c = gc();\n  while (c < '0' || c > '9') c = gc();\n  x = c - '0';\n  while ((c = gc()) >= '0' && c <= '9') x = x * 10 + c - '0';\n}\ntemplate <typename T, typename... Args>\nvoid Read(T &x, Args &... args) {\n  Read(x);\n  Read(args...);\n}\nvoid checkmax(int &x, int y) {\n  if (x < y) x = y;\n}\nvoid checkmin(int &x, int y) {\n  if (x > y) x = y;\n}\nvoid Add(int f, int t) {\n  e[E].to = t;\n  e[E].nxt = head[f];\n  head[f] = E++;\n}\nint main(int argc, char const *argv[]) {\n  std::memset(head, -1, sizeof(head));\n  Read(n, m);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    Read(u, v);\n    Add(u, v);\n    Add(v, u);\n  }\n  Read(s, t);\n  std::memset(dis, 0x3f, sizeof(dis));\n  dis[s] = 0;\n  q.Push(s);\n  vis[s] = true;\n  while (!q.Empty()) {\n    int u = q.Front();\n    q.Pop();\n    for (int i = head[u]; i != -1; i = e[i].nxt) {\n      int v = e[i].to;\n      if (vis[v]) continue;\n      dis[v] = dis[u] + 1;\n      q.Push(v);\n      vis[v] = true;\n    }\n  }\n  std::memset(h, 0x3f, sizeof(h));\n  std::memset(vis, false, sizeof(vis));\n  q.Clear();\n  q.Push(t);\n  h[t] = 0;\n  vis[t] = true;\n  while (!q.Empty()) {\n    int u = q.Front();\n    q.Pop();\n    for (int i = head[u]; i != -1; i = e[i].nxt) {\n      int v = e[i].to;\n      if (vis[v] || v == s) continue;\n      h[v] = h[u] + 1;\n      q.Push(v);\n      vis[v] = true;\n    }\n  }\n  std::memset(vis, false, sizeof(vis));\n  vis[s] = true;\n  int max = 0;\n  for (int i = head[s]; i != -1; i = e[i].nxt) {\n    int v = e[i].to;\n    if (h[v] > 5000000) continue;\n    q2[h[v]].emplace_back(v);\n    checkmax(max, h[v]);\n    vis[v] = true;\n  }\n  for (int i = max; i >= 1; i--)\n    for (auto &&u : q2[i])\n      for (int j = head[u]; j != -1; j = e[j].nxt) {\n        int v = e[j].to;\n        if (vis[v]) continue;\n        checkmin(h[v], h[u] - 1);\n        vis[v] = true;\n        q2[h[v]].emplace_back(v);\n      }\n  int ans = 0;\n  for (int i = 1; i <= n; i++)\n    ans += (vis[i] || h[i] == 0x3f3f3f3f) && (dis[i] < h[i]);\n  std::cout << ans - 1;\n  return 0;\n}\n```",
        "postTime": 1627190771,
        "uid": 68273,
        "name": "xyf007",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P7733 \u3010\u62a2\u6551\u5b9e\u9a8c\u6570\u636e\u3011"
    }
]