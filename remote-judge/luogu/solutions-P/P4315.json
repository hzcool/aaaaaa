[
    {
        "content": "\u8fd9\u9053\u9898\u76ee\uff0c\u5982\u679c\u628a\u8fb9\u6743\u6539\u4e3a\u70b9\u6743\u7684\u8bdd\uff0c\u90a3\u4e48\u5c31\u662f\u4e00\u4e2a\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u7684\u88f8\u9898\u4e86\uff0c\u5c31\u662f\u4e24\u904ddfs\u627e\u51fa\u91cd\u513f\u5b50\uff0c\u5bf9\u70b9\u8fdb\u884c\u91cd\u65b0\u7f16\u53f7\uff0c\u7136\u540e\u6811\u94fe\u5256\u5206\u5373\u53ef\u3002\n\n\u4f46\u662f\uff01\uff01\u2014\u2014\u8fd9\u9898\u662f\u8fb9\u6743\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u6211\u4eec\u53d1\u73b0\uff0c\u4e00\u4e2a\u70b9\u6700\u591a\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\u7ed3\u70b9\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8003\u8651\u628a\u8fd9\u4e2a\u70b9\u4e0e\u5176\u7236\u4eb2\u7ed3\u70b9\u4e4b\u95f4\u8fb9\u7684\u8fb9\u6743\u8f6c\u5316\u4e3a\u8fd9\u4e2a\u70b9\u7684\u70b9\u6743\uff01\u90a3\uff0c\u4e4b\u540e\uff0c\u5c31\u53d8\u6210\u4e86\u6211\u4eec\u4e00\u5f00\u59cb\u8bf4\u7684\u6811\u94fe\u5256\u5206\u88f8\u9898\u4e86\u5440\uff01\u8fd8\u6709\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u7ec6\u8282\u5c31\u662f\u6811\u94fe\u5256\u5206\u67e5\u8be2\u548c\u4fee\u6539\u8def\u5f84\u7684\u65f6\u5019\uff0c\u7236\u4eb2\u7ed3\u70b9\u662f\u4e0d\u5728\u8def\u5f84\u4e0a\u7684\uff01\u56e0\u4e3a\u7236\u4eb2\u7ed3\u70b9\u7684\u70b9\u6743\u4ee3\u8868\u7684\u662f\u5b83\u4e0e\u5b83\u7684\u7236\u4eb2\u4e4b\u95f4\u7684\u8fb9\u6743\uff0c\u56e0\u6b64\uff0c\u5728\u67e5\u8be2\u548c\u4fee\u6539\u7684\u65f6\u5019\uff0c\u6700\u540e\u5de6\u7aef\u70b9\u4e3a$id[x]$+$1$\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#define maxn 100007\n#define ll long long\n#define ls rt<<1\n#define rs rt<<1|1\nusing namespace std;\nint n,head[maxn],d[maxn],size[maxn],son[maxn],a[maxn],tag[maxn<<2];                             //tag\u662f\u628a\u533a\u95f4\u6539\u4e3a\u4e00\u4e2a\u6570\u65f6\u7684lazy\u6570\u7ec4\u3002\nint p[maxn],id[maxn],top[maxn],num,cnt,lazy[maxn<<2],fa[maxn],maxx[maxn<<2];              \nchar s[10];\ninline int qread() {\n  char c=getchar();int num=0,f=1;\n  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n  for(;isdigit(c);c=getchar()) num=num*10+c-'0';\n  return num*f;\n}\nstruct node {\n  int v,w,nxt;\n}e[maxn<<1];\ninline void ct(int u, int v, int w) {  \n  e[++num].v=v;\n  e[num].w=w;\n  e[num].nxt=head[u];\n  head[u]=num;\n}\ninline void pushup(int rt) {\n  maxx[rt]=max(maxx[ls],maxx[rs]);\n}\ninline void pushdown(int rt) {\n  if(tag[rt]>=0) {\n    lazy[ls]=lazy[rs]=0;\n    maxx[ls]=maxx[rs]=tag[ls]=tag[rs]=tag[rt];\n    tag[rt]=-1;\n  }\n  if(lazy[rt]) {\n    lazy[ls]+=lazy[rt];\n    lazy[rs]+=lazy[rt];\n    maxx[ls]+=lazy[rt];\n    maxx[rs]+=lazy[rt];\n    lazy[rt]=0;\n  }\n}\nvoid build(int rt, int l, int r) {\n  tag[rt]=-1;\n  if(l==r) {\n    maxx[rt]=a[l];\n    return;\n  }\n  int mid=(l+r)>>1;\n  build(ls,l,mid);\n  build(rs,mid+1,r);\n  pushup(rt);\n}\nvoid modify1(int rt, int l, int r, int L, int R, int val) {\n  if(L>r||R<l) return;\n  if(L<=l&&r<=R) {\n    lazy[rt]+=val;\n    maxx[rt]+=val;\n    return;\n  }\n  pushdown(rt);\n  int mid=(l+r)>>1;\n  if(L<=mid) modify1(ls,l,mid,L,R,val);\n  if(R>mid) modify1(rs,mid+1,r,L,R,val);\n  pushup(rt);\n}\nvoid modify2(int rt, int l, int r, int L, int R, int val) {\n  if(L>r||R<l) return;\n  if(L<=l&&r<=R) {\n    maxx[rt]=tag[rt]=val;\n    lazy[rt]=0;\n    return;\n  }\n  pushdown(rt);\n  int mid=(l+r)>>1;\n  modify2(ls,l,mid,L,R,val),modify2(rs,mid+1,r,L,R,val);\n  pushup(rt);\n}\nint cmax(int rt, int l, int r, int L, int R) {\n  if(L<=l&&r<=R) return maxx[rt];\n  int ans=0;\n  int mid=(l+r)>>1;\n  pushdown(rt);\n  if(L<=mid) ans=max(ans,cmax(ls,l,mid,L,R));\n  if(R>mid) ans=max(ans,cmax(rs,mid+1,r,L,R));\n  return ans;\n}\nvoid dfs1(int u, int f) {\n  size[u]=1;\n  for(int i=head[u];i;i=e[i].nxt) {\n    int v=e[i].v;\n    if(v!=f) {\n      d[v]=d[u]+1;\n      fa[v]=u;\n      p[v]=e[i].w;\n      dfs1(v,u);\n      size[u]+=size[v];\n      if(size[v]>size[son[u]]) son[u]=v;\n    }\n  }\n}\nvoid dfs2(int u, int t) {\n  id[u]=++cnt;\n  top[u]=t;\n  a[cnt]=p[u];\n  if(son[u]) dfs2(son[u],t);\n  for(int i=head[u];i;i=e[i].nxt) {\n    int v=e[i].v;\n    if(v!=fa[u]&&v!=son[u]) dfs2(v,v);\n  }\n}\nvoid cal1(int x, int y, int val) {\n  int fx=top[x],fy=top[y];\n  while(fx!=fy) {\n    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);\n    modify1(1,1,n,id[fx],id[x],val);\n    x=fa[fx],fx=top[x];\n  }\n  if(id[x]>id[y]) swap(x,y);\n  modify1(1,1,n,id[x]+1,id[y],val);\n}\nvoid cal2(int x, int y, int val) {\n  int fx=top[x],fy=top[y];\n  while(fx!=fy) {\n    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);\n    modify2(1,1,n,id[fx],id[x],val);\n    x=fa[fx],fx=top[x];\n  }\n  if(id[x]>id[y]) swap(x,y);\n  modify2(1,1,n,id[x]+1,id[y],val);\n}\nint query(int x, int y) {\n  int ans=0,fx=top[x],fy=top[y];\n  while(fx!=fy) {\n    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);\n    ans=max(ans,cmax(1,1,n,id[fx],id[x]));\n    x=fa[fx],fx=top[x];\n  }\n  if(id[x]>id[y]) swap(x,y);\n  ans=max(ans,cmax(1,1,n,id[x]+1,id[y]));\n  return ans;\n}\nint main() {\n  n=qread();\n  for(int i=1,u,v,w;i<n;++i) {\n    u=qread(),v=qread(),w=qread();\n    ct(u,v,w);ct(v,u,w);\n  }\n  dfs1(1,0),dfs2(1,1);build(1,1,n);\n  while(1) {\n    scanf(\"%s\",s);\n    if(s[0]=='S') break;\n    int x=qread(),y=qread();\n    if(s[1]=='h') {\n      x=d[e[x*2-1].v]<d[e[x<<1].v]?e[x<<1].v:e[x*2-1].v;\n      modify2(1,1,n,id[x],id[x],y);        //\u8fd9\u91cc\u5fc5\u987b\u8981\u52a0\u8fd9\u53e5\u8bdd\uff01\u56e0\u4e3a\u6211\u4eecdfs\u65f6\u6ca1\u6709\u8bb0\u5f55\u54ea\u4e2a\u8fb9\u5177\u4f53\u5bf9\u5e94\u54ea\u4e2a\u70b9\u3002\n    }\n    if(s[1]=='o') {\n      int zrj=qread();\n      cal2(x,y,zrj);\n    }\n    if(s[1]=='d') {\n      int zrj=qread();\n      cal1(x,y,zrj);\n    }\n    if(s[1]=='a') printf(\"%d\\n\",query(x,y)); \n  }\n  return 0;\n}\n```\n\n\u4ee3\u7801\u91cf\u6709\u70b9\u5927\uff0c\u8c03\u8d77\u6765\u4e5f\u633a\u96be\u7684\uff0c\u672c\u849f\u84bb\u8c03\u4e86\u4e00\u4e0b\u5348\u2026\u2026\u53ef\u80fd\u6211\u592a\u5f31\u4e86\uff0c\u795d\u5927\u5bb6\u4e00\u904dAC\u554a\uff01\uff01\uff01",
        "postTime": 1545994970,
        "uid": 68622,
        "name": "King\u4e28\u5e1d\u5fa1\u5a01",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u3002\u4fd7\u8bdd\u8bf4\u5f97\u597d\uff0c$\\text{OI}$ \u6bd2\u7624\u5343\u5343\u4e07\uff0c\u6811\u5256 $\\text{DP}$ \u5404\u4e00\u534a\u3002\uff08\u7eaf\u5c5e\u778e\u626f\uff0c\u5f88\u591a\u6570\u636e\u7ed3\u6784\u4e5f\u5f88\u6bd2\u7624\uff09\uff0c\u8fd9\u9053\u9898\u5f88\u660e\u663e\u7684\u662f\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u9898\uff0c\u4f46\u56e0\u4e3a\u64cd\u4f5c\u7684\u5bf9\u8c61\u662f**\u8fb9\u6743**\uff0c\u800c\u6811\u94fe\u5256\u5206\u9488\u5bf9\u7684\u5e94\u8be5\u662f**\u70b9\u6743**\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u5c06\u8fb9\u6743\u8f6c\u4e3a\u70b9\u6743\u6765\u505a\u3002\n\n\u6b64\u65f6\u5f88\u660e\u663e\uff0c\u6211\u4eec\u4f1a\u60f3\u5230**\u5c06\u4e00\u6761\u8fb9\u7684\u8fb9\u6743\u8f6c\u79fb\u5230\u5b83\u6df1\u5ea6\u66f4\u6df1\u7684\u7aef\u70b9**\u4e0a\uff0c\u7136\u540e\u8fdb\u884c\u5904\u7406\uff0c\u4f46\u6b64\u65f6\u4f1a\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u4e5f\u5c31\u662f\u5728\u67e5\u8be2\u8def\u5f84 $u-v$ \u65f6\uff0c$u$ \u548c $v$ \u7684 $lca$ \u7684\u6743\u503c\u662f\u5b83\u4e0a\u4e00\u6761\u8fb9\u7684\u6743\u503c\uff0c\u5e76\u4e0d\u5c5e\u4e8e $u-v$ \u8fd9\u6761\u8def\u5f84\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u9000\u51fa $top[u]\\not= top[v]$ \u8fd9\u5c42\u5faa\u73af\uff0c\u8fdb\u884c\u6700\u540e\u4e00\u6b21\u64cd\u4f5c\u65f6\u5e94\u5c06 $u$ \u7684 $\\text{DFS}$ \u5e8f\u52a0\u4e0a $1$ \uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5ffd\u7565 $lca$ \u8fd9\u4e2a\u70b9\u4e86\u3002\n\n\u5177\u4f53\u539f\u56e0\u8868\u8ff0\u53ef\u80fd\u4e0d\u592a\u6e05\u695a\uff1a\u5728\u9000\u51fa\u5faa\u73af\u4e4b\u540e\uff0c\u4e24\u4e2a\u70b9\u7684\u4f4d\u7f6e\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u663e\u7136\uff0c\u8fd9\u6761\u91cd\u94fe\u7684 $top$ \u5c31\u662f\u5b83\u4eec\u539f\u6765\u7684 $lca$\uff0c\u800c\u8981\u5ffd\u7565 $lca$ \uff0c\u5c31\u662f\u8981\u5230\u8fbe\u6bd4\u5b83\u6df1\u5ea6 $+1$ \u7684\u70b9\uff0c\u8fd9\u4e2a\u70b9\u7684 $\\text{DFS}$ \u5e8f\u4e5f\u663e\u7136\u662f\u6bd4 $lca$ \u7684 $\\text{DFS}$ \u5e8f\u591a $1$\u3002\n\n\u6700\u540e\u8bb2\u4e00\u4e0b\u7ebf\u6bb5\u6811\u7684\u6ce8\u610f\u4e8b\u9879\uff0c\u8fd9\u9898\u6709\u4e00\u4e2a\u6bd4\u8f83\u5c11\u89c1\u7684\u64cd\u4f5c\uff1a\u533a\u95f4\u8986\u76d6\uff0c\u6211\u4eec\u591a\u8bbe\u7f6e\u4e00\u4e2a $\\text{lazytag}$\uff0c\u547d\u540d\u4e3a $cov$\uff0c\u8bb0\u5f55\u533a\u95f4\u8986\u76d6\u60c5\u51b5\uff0c\u7136\u540e\u5728 $\\text{pushdown}$ \u65f6\u5148\u5904\u7406\u8fd9\u4e2a $cov$\uff0c\u5904\u7406\u5b8c\u540e\u4e0d\u80fd\u91cd\u65b0\u8d4b\u503c\u4e3a $0$ \uff0c\u800c\u662f\u8981\u8d4b\u503c\u4e3a $-1$\uff0c\u4e3a\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3a\u533a\u95f4\u8986\u76d6\u7684\u503c\u53ef\u80fd\u4e3a $0$\uff0c\u4f46\u4e0d\u53ef\u80fd\u4e3a\u8d1f\u6570\uff08\u6bd5\u7adf\u4e0d\u53ef\u80fd\u6709 $-1$ \u4e2a\u6bdb\u6bdb\u679c\uff09\uff0c\u521d\u503c\u4e5f\u8981\u8d4b\u6210 $-1$\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 100005\nusing namespace std;\nint cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1],w[MAXN<<1],fr[MAXN<<1];\nint n,a[MAXN],t[MAXN<<2],tag[MAXN<<2],cov[MAXN<<2];\nint siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],rk[MAXN],dep[MAXN],faz[MAXN];\nstring s;\nvoid AddEdge(int u,int v,int c)\n{\n\tto[++cnt]=v;\n\tnxt[cnt]=fst[u];\n\tfst[u]=cnt;\n\tw[cnt]=c;\n\tfr[cnt]=u;\n}\nvoid Dfs1(int u)\n{\n\tsiz[u]=1;\n\tson[u]=0;\n\tfor(int i=fst[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==faz[u]) continue;\n\t\tfaz[v]=u;\n\t\tdep[v]=dep[u]+1;\n\t\trk[v]=w[i];\n\t\tDfs1(v);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[son[u]]<siz[v]) son[u]=v;\n\t}\n}\nvoid Dfs2(int u,int rt)\n{\n\tdfn[u]=++Index;\n\ttop[u]=rt;\n\ta[Index]=rk[u];\n\tif(son[u]) Dfs2(son[u],rt);\n\tfor(int i=fst[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==faz[u] || v==son[u]) continue;\n\t\tDfs2(v,v);\n\t}\n}\nvoid PushUp(int rt)\n{\n\tt[rt]=max(t[rt<<1],t[rt<<1|1]);\n}\nvoid PushDown(int rt)\n{\n\tif(~cov[rt])\n\t{\n\t\tcov[rt<<1]=cov[rt<<1|1]=cov[rt];\n\t\tt[rt<<1]=t[rt<<1|1]=cov[rt];\n\t\ttag[rt<<1]=tag[rt<<1|1]=0;\n\t\tcov[rt]=-1;\n\t}\n\ttag[rt<<1]+=tag[rt];\n\ttag[rt<<1|1]+=tag[rt];\n\tt[rt<<1]+=tag[rt];\n\tt[rt<<1|1]+=tag[rt];\n\ttag[rt]=0;\n}\nvoid BuildSegmentTree(int rt,int l,int r)\n{\n\tcov[rt]=-1;\n\tif(l==r)\n\t{\n\t\tt[rt]=a[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tBuildSegmentTree(rt<<1,l,mid);\n\tBuildSegmentTree(rt<<1|1,mid+1,r);\n\tPushUp(rt);\n}\nvoid ModifyCover(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr)\n\t{\n\t\tt[rt]=cov[rt]=val;\n\t\ttag[rt]=0;\n\t\treturn;\n\t}\n\tPushDown(rt);\n\tint mid=l+r>>1;\n\tif(tl<=mid) ModifyCover(rt<<1,l,mid,tl,tr,val);\n\tif(tr>mid) ModifyCover(rt<<1|1,mid+1,r,tl,tr,val);\n\tPushUp(rt);\n}\nvoid ModifyAdd(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr)\n\t{\n\t\tt[rt]+=val;\n\t\ttag[rt]+=val;\n\t\treturn;\n\t}\n\tPushDown(rt);\n\tint mid=l+r>>1;\n\tif(tl<=mid) ModifyAdd(rt<<1,l,mid,tl,tr,val);\n\tif(tr>mid) ModifyAdd(rt<<1|1,mid+1,r,tl,tr,val);\n\tPushUp(rt);\n}\nint Query(int rt,int l,int r,int tl,int tr)\n{\n\tif(tl<=l && r<=tr) return t[rt];\n\tPushDown(rt);\n\tint mid=l+r>>1,res=0;\n\tif(tl<=mid) res=max(res,Query(rt<<1,l,mid,tl,tr));\n\tif(tr>mid) res=max(res,Query(rt<<1|1,mid+1,r,tl,tr));\n\treturn res;\n}\nvoid ModifyCoverOnTree(int u,int v,int val)\n{\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tModifyCover(1,1,n,dfn[top[u]],dfn[u],val);\n\t\tu=faz[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tModifyCover(1,1,n,dfn[u]+1,dfn[v],val);\n}\nvoid ModifyAddOnTree(int u,int v,int val)\n{\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tModifyAdd(1,1,n,dfn[top[u]],dfn[u],val);\n\t\tu=faz[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tModifyAdd(1,1,n,dfn[u]+1,dfn[v],val);\n}\nint QueryMaxnOnTree(int u,int v)\n{\n\tint res=0;\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tres=max(res,Query(1,1,n,dfn[top[u]],dfn[u]));\n\t\tu=faz[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tres=max(res,Query(1,1,n,dfn[u]+1,dfn[v]));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d %d %d\",&x,&y,&z);\n\t\tAddEdge(x,y,z);\n\t\tAddEdge(y,x,z);\n\t}\n\tDfs1(1);\n\tDfs2(1,1);\n\tBuildSegmentTree(1,1,n);\n\twhile(1)\n\t{\n\t\tint x,y,z;\n\t\tcin>>s;\n\t\tif(s==\"Stop\") break;\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tif(s==\"Change\")\n\t\t\t{\n\t\t\t\tx<<=1;\n\t\t\t\tint u=fr[x],v=to[x];\n\t\t\t\tif(dep[u]>dep[v]) swap(u,v);\n\t\t\t\tModifyCoverOnTree(u,v,y);\n\t\t\t}\n\t\t\telse if(s==\"Cover\")\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\tModifyCoverOnTree(x,y,z);\n\t\t\t}\n\t\t\telse if(s==\"Add\")\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&z);\n\t\t\t\tModifyAddOnTree(x,y,z);\n\t\t\t}\n\t\t\telse if(s==\"Max\") printf(\"%d\\n\",QueryMaxnOnTree(x,y));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546829939,
        "uid": 23243,
        "name": "VenusM1nT",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "## \u524d\u8a00\n\n\u8fd9\u9053\u9898\u5176\u5b9e\u5c31\u662f\u628a `\u5355\u70b9\u4fee\u6539` \u3001 `\u533a\u95f4\u67d3\u8272` \u3001 `\u533a\u95f4\u52a0` \u4ee5\u53ca `\u533a\u95f4\u6700\u5927\u503c` \u8fd9\u56db\u79cd\u57fa\u672c\u7684\u5e8f\u5217\u64cd\u4f5c\u51fa\u5230\u4e86\u6811\u4e0a\uff0c\u5f88\u660e\u663e\u662f\u7528 `\u6811\u94fe\u5256\u5206` + `\u7ebf\u6bb5\u6811` \u89e3\u51b3\uff0c\u4f46\u662f\u56e0\u4e3a\u6211\u592a\u84bb\u4e86\uff0c\u6811\u5256\u7801\u5230\u4e00\u534a\u7801\u4e0d\u4e0b\u53bb\u4e86\uff0c\u6240\u4ee5\u5c31\u5168\u5220\u4e86\u6539\u7801\u4e86\u4e2a `Link-Cut Tree` \uff0c\u987a\u4fbf **\u62ff\u4e86\u8fd9\u4e2a\u9898\u7684[RANK1](https://www.luogu.org/record/list?pid=P4315&orderBy=1&status=&page=1)** \u3002\n\n---\n## \u8fb9\u8f6c\u70b9\n\n\u6811\u5256\u7684\u8fb9\u8f6c\u70b9\u5927\u5bb6\u90fd\u77e5\u9053\u662f\u628a\u6bcf\u6761\u8fb9\u7684\u6743\u503c\u7ed9\u6df1\u5ea6\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u5728 `LCT` \u4e0a\u4e5f\u8fd9\u4e48\u505a\uff0c\u56e0\u4e3a\u6709 `makeroot` \u64cd\u4f5c\u7684\u5b58\u5728\uff0c `LCT` \u4e0a\u7ed3\u70b9\u7684\u7236\u5b50\u5173\u7cfb\u4e0d\u662f\u786e\u5b9a\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u91c7\u53d6\u5efa\u7acb `\u865a\u62df\u7ed3\u70b9` \u7684\u65b9\u5f0f\uff1a\n```cpp\n// \u7b2c i \u6761\u8fb9\u8fde\u63a5 u \u548c v \u8fd9\u4e24\u4e2a\u70b9\uff0c\u6743\u503c\u4e3a w\nval[n+i]=maxv[n+i]=w;\nlink(u,n+i);\nlink(n+i,v);\n```\n\u7528 $n$ + $i$ \u53f7\u7ed3\u70b9\u8868\u793a\u7b2c $i$ \u6761\u8fb9\uff0c\u518d\u7528\u5b83\u53bb\u5206\u522b\u8fde\u63a5\u539f\u5148\u7684\u8fb9\u8fde\u63a5\u7684\u7ed3\u70b9\u3002\n\n### \u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\n\n1. \u8fd9\u79cd\u5199\u6cd5\u4f1a\u4ea7\u751f $2n$ \u4e2a\u7ed3\u70b9\uff0c **\u7a7a\u95f4\u5343\u4e07\u8981\u5f00\u591f\uff01**\n2. \u6807\u8bb0\u4e0a\u4f20\u4e0b\u4f20\u7684\u65f6\u5019\u8981\u5206 **\u539f\u7ed3\u70b9** \u548c **\u865a\u62df\u7ed3\u70b9** \u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\uff01\n\n---\n## \u6807\u8bb0\n\n\u8fd9\u9053\u9898\u6211\u4eec\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a `\u533a\u95f4\u67d3\u8272` \u7684\u6807\u8bb0\u548c\u4e00\u4e2a `\u533a\u95f4\u52a0` \u7684\u6807\u8bb0\u5c31\u884c\uff0c\u6211\u591a\u7ef4\u62a4\u4e86\u4e00\u4e2a `siz` \u6570\u7ec4\u50a8\u5b58\u5b50\u6811\u5185 `\u865a\u62df\u7ed3\u70b9` \u7684\u6570\u91cf\uff0c\u4e0a\u4f20\u65f6\u5224\u65ad\u5f53\u524d\u7ed3\u70b9\u662f\u4e0d\u662f `\u865a\u62df\u7ed3\u70b9` \u5c31\u884c\u3002\n\n\u6807\u8bb0\u4e0b\u4f20\u7684\u65f6\u5019\u8981 **\u5148\u4e0b\u4f20\u533a\u95f4\u67d3\u8272\uff0c\u518d\u4e0b\u4f20\u533a\u95f4\u52a0** \uff0c\u82e5\u662f\u5148\u4e0b\u4f20\u4e86 `\u533a\u95f4\u52a0` \uff0c\u540e\u9762 `\u533a\u95f4\u67d3\u8272` \u7684\u65f6\u5019\u5c31\u4f1a **\u8986\u76d6\u6389** \n\n---\n## \u6700\u540e\n\n\u8fd9\u662f `LCT` 712ms[\u8bc4\u6d4b\u8bb0\u5f55](https://www.luogu.org/recordnew/show/17081420)\n\n\u6700\u540e\u9644\u4e0a\u6b64\u9898 $AC$ \u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n\n#define N 200010\n#define lc(x) ch[x][0]\n#define rc(x) ch[x][1]\n#define re register\n#define gc pa==pb&&(pb=(pa=buf)+fread(buf,1,100000,stdin),pa==pb)?EOF:*pa++\ninline int max(int a,int b){return b<a?a:b;}\ninline void swap(int&a,int&b){int tmp(a);a=b,b=tmp;}\nstatic char buf[100000],*pa(buf),*pb(buf);\nstatic char pbuf[3000000],*pp(pbuf),st[15];\ninline char gtc()\n{\n    re char c(gc);\n    while(c!='S'&&c!='h'&&c!='o'&&c!='d'&&c!='a')c=gc;\n    return c;\n}\ninline int read()\n{\n    re int x(0);re char c(gc);\n    while(c<'0'||c>'9')c=gc;\n    while(c>='0'&&c<='9')\n        x=x*10+c-48,c=gc;\n    return x;\n}\ninline void write(re int v)\n{\n    if(!v)\n        *pp++=48;\n    else\n    {\n        re char*tp(st);\n        while(v)\n            *++tp=v%10+48,v/=10;\n        while(tp!=st)\n            *pp++=*tp--;\n    }\n    *pp++='\\n';\n}\n\nint n,u,v,w;\nchar opt;\n\nint ch[N][2],fa[N],rev[N],val[N],maxv[N],ass[N],addv[N],siz[N];\ninline void assign(int x,int y){val[x]=x>n?y:0,maxv[x]=siz[x]>0?y:0,addv[x]=0,ass[x]=y;}\ninline void add(int x,int y){val[x]+=x>n?y:0,maxv[x]+=siz[x]>0?y:0,addv[x]+=siz[x]>0?y:0;}\ninline void up(int x){siz[x]=siz[lc(x)]+siz[rc(x)]+(x>n),maxv[x]=max(val[x],max(maxv[lc(x)],maxv[rc(x)]));}\ninline void down(int x)\n{\n    if(rev[x])rev[lc(x)]^=1,rev[rc(x)]^=1,rev[x]=0,swap(lc(x),rc(x));\n    if(ass[x])assign(lc(x),ass[x]),assign(rc(x),ass[x]),ass[x]=0;\n    if(addv[x])add(lc(x),addv[x]),add(rc(x),addv[x]),addv[x]=0;\n}\ninline int nrt(int x){return x==lc(fa[x])||x==rc(fa[x]);}\nvoid psa(int x){if(nrt(x))psa(fa[x]);down(x);}\ninline void rotate(int x)\n{\n    int y(fa[x]),z(fa[y]),k(x==rc(y));\n    ch[y][k]=ch[x][k^1],ch[x][k^1]=y;if(nrt(y))ch[z][y==rc(z)]=x;\n    if(ch[y][k])fa[ch[y][k]]=y;fa[y]=x,fa[x]=z,up(y);\n}\ninline void splay(int x)\n{\n    int y,z;\n    for(psa(x);nrt(x);rotate(x))\n    {y=fa[x],z=fa[y];if(nrt(y))rotate(x==rc(y)^y==rc(z)?x:y);}up(x);\n}\ninline void access(int x){for(int y(0);x;x=fa[y=x])splay(x),rc(x)=y,up(x);}\ninline void mrt(int x){access(x),splay(x),rev[x]^=1;}\ninline void split(int x,int y){mrt(x),access(y),splay(y);}\ninline void link(int x,int y){mrt(x),fa[x]=y;}\n\nint main()\n{\n    n=read();\n    for(re int i(1);i<n;++i)\n        siz[n+i]=1;\n    for(re int i(1);i<n;++i)\n        u=read(),v=read(),val[n+i]=maxv[n+i]=read(),link(u,n+i),link(n+i,v);\n    opt=gtc();\n    while(opt!='S')\n    {\n        u=read(),v=read();\n        switch(opt)\n        {\n            case'h':\n                access(n+u),splay(n+u),val[n+u]=v;\n                break;\n            case'o':\n                split(u,v),assign(v,read());\n                break;\n            case'd':\n                split(u,v),add(v,read());\n                break;\n            case'a':\n                split(u,v),write(maxv[v]);\n        }\n        opt=gtc();\n    }\n    fwrite(pbuf,1,pp-pbuf,stdout);\n    return 0;\n}\n```",
        "postTime": 1552207183,
        "uid": 126486,
        "name": "yurzhang",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "# \u6211\u6c38\u8fdc\u559c\u6b22\u73c2\u6735\u8389\uff01\uff01\n\n\u5206\u6790\u9898\u610f, \u8981\u6c42\u652f\u6301\u5bf9\u6811\u4e0a\u8fb9\u6743\u7684\uff1a\n1. \u533a\u95f4\u63a8\u5e73\n1. \u5355\u8fb9\u4fee\u6539\n1. \u533a\u95f4\u6700\u5927\u503c\u3002\n\n-  \u8fb9\u6743\u95ee\u9898\u6211\u4eec\u53ef\u4ee5\u8fb9\u6743\u4e0b\u653e\u70b9\u6743\u8f6c\u5316\u4e3a\u70b9\u6743\u95ee\u9898\u3002\n\n- \u6811\u4e0a\u7684\u70b9\u6743\u95ee\u9898\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6811\u5256\u8f6c\u5316\u4e3a\u5e8f\u5217\u95ee\u9898,\n- \u5e8f\u5217\u4e0a\u7684\u533a\u95f4\u63a8\u5e73\uff0c\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u6700\u5927\u503c\u6211\u4eec\u663e\u7136\u53ef\u4ee5\u5229\u7528\u73c2\u6735\u8389\u6811\u7ef4\u62a4\u3002\n\n**\u51e0\u4e2a\u5751\u70b9**\n\n\u95ee\u9898\u4e3b\u8981\u4e4b\u4e2d\u5728\u8fb9\u6743\u4e0b\u653e\u8fb9\u6743\u540e\u7684\u7ec6\u8282\u5904\u7406\n\n-   \u67e5\u8be2/\u4fee\u6539\u64cd\u4f5c\u65f6\uff0c\u5f53\u8282\u70b9x,y\u843d\u5230\u540c\u4e00\u6761\u94fe\u4e0a\u65f6\uff0c\u67e5\u8be2/\u4fee\u6539\u8303\u56f4\u5e94\u4e3a( dfn[x],dfn[y] ]\n\n _\u56e0\u4e3a\u8fb9\u6743\u4e0b\u653e\u70b9\u6743\u4e4b\u540e\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u67e5\u8be2[ dfn[x],dfn[y] ],\u6211\u4eec\u5c06\u591a\u5904\u7406\u8282\u70b9x\u6240\u5bf9\u5e94\u7684\u8fb9\u6743\uff0c\u4e0e\u9898\u610f\u70b9x~y\u4e4b\u95f4\u8fb9\u6743\u7684\u8981\u6c42\u4e0d\u7b26_\n \n \n \n \n \n- \u4e3a\u4e86\u6ee1\u8db3\u9898\u76ee\u8981\u6c42\u7684\u5355\u8fb9\u4fee\u6539\u64cd\u4f5c\uff0c\u6211\u4eec\u8981\u8bb0\u5f55\u6bcf\u6761\u8fb9\u7684id,\u5728dfs\u8fc7\u7a0b\u4e2d\uff0c\u8bb0\u5f55\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\uff0c\u6254\u5230\u4e24\u4e2a\u6570\u7ec4\u91cc\uff0cassign(id1[i],id2[i])\u5c31\u4ee3\u8868\u4fee\u6539\u8fb9i\u6743\u7684\u6743\u503c\n  \n## Code\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<set>\n#define IT set<Node>::iterator\nusing namespace std;\nconst int N=1e5+7;\nint n;\nint cnt,col;\nint fa[N],son[N],top[N],dep[N],siz[N],dis[N],dfn[N],id1[N],id2[N],val[N],head[N];\nstruct Node\n{\n  int l,r;\n  mutable int val;\n  Node(int L,int R=-1,int V=0):l(L),r(R),val(V){}\n  bool operator<(const Node &o)const\n  {\n      return l<o.l;\n  }\n};\nset<Node>s;\ninline IT split(int pos)\n{\n    IT it=s.lower_bound(Node(pos));\n    if(it!=s.end()&&it->l==pos)return it;\n    --it;\n    int L=it->l,R=it->r;\n    int V=it->val;\n    s.erase(it);\n    s.insert(Node(L,pos-1,V));\n    return s.insert(Node(pos,R,V)).first;\n}\ninline void basic_assign(int l,int r,int val)\n{\n    IT itr=split(r+1),itl=split(l);\n    s.erase(itl,itr);\n    s.insert(Node(l,r,val));\n}\ninline void basic_update(int l,int r,int val)\n{\n    IT itr=split(r+1),itl=split(l);\n    for(;itl!=itr;itl++)\n    {\n        itl->val+=val;\n    }\n}\ninline int basic_query(int l,int r)\n{\n    register int res=0;\n    IT itr=split(r+1),itl=split(l);\n    for(;itl!=itr;itl++)\n    {\n        res=max(res,itl->val);\n    }\n    return res;\n}\nstruct Edge\n{\n    int next,to,dis,id;\n}e[N<<1];\ninline void add(int u,int v,int w,int id)\n{\n    e[++cnt].next=head[u];\n    head[u]=cnt;\n    e[cnt].to=v;\n    e[cnt].dis=w;\n    e[cnt].id=id;\n}\ninline void dfs1(int x,int father,int deep)\n{\n    fa[x]=father;dep[x]=deep;siz[x]=1;\n    register int maxson=-1;\n    for(register int i=head[x];i;i=e[i].next)\n    {\n        int y=e[i].to;\n        if(y==father)continue;\n        id1[e[i].id]=y;\n        id2[e[i].id]=x;\n        val[y]=e[i].dis;\n        dfs1(y,x,deep+1);\n        siz[x]+=siz[y];\n        if(siz[y]>maxson)\n        {\n            maxson=siz[y];\n            son[x]=y;\n        }\n    }\n}\ninline void dfs2(int x,int topp)\n{\n    top[x]=topp;dfn[x]=++col;\n    s.insert(Node(col,col,val[x]));\n    if(!son[x])return;\n    dfs2(son[x],topp);\n    for(register int i=head[x];i;i=e[i].next)\n    {\n        int y=e[i].to;\n        if(y==fa[x]||y==son[x])continue;\n        dfs2(y,y);\n    }\n}\ninline void assign(int x,int y,int val)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        basic_assign(dfn[top[x]],dfn[x],val);\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])swap(x,y);\n    basic_assign(dfn[y]+1,dfn[x],val);\n}\ninline void update(int x,int y,int val)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        basic_update(dfn[top[x]],dfn[x],val);\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])swap(x,y);\n    basic_update(dfn[y]+1,dfn[x],val);\n}\ninline int query(int x,int y)\n{\n    register int res=0;\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        res=max(res,basic_query(dfn[top[x]],dfn[x]));\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])swap(x,y);\n    res=max(res,basic_query(dfn[y]+1,dfn[x]));\n    return res;\n}\ninline int read()\n{\n   int res=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){res=res*10+ch-'0';ch=getchar();}\n    return res*f;\n}\nstring ss;\nint main()\n{\n    n=read();\n    for(register int i=1;i<n;i++)\n    {\n        register int u=read(),v=read(),w=read();\n        add(u,v,w,i);\n        add(v,u,w,i);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n    while(true)\n    {\n        cin>>ss;\n        if(ss==\"Stop\")break;\n        register int u=read(),v=read();\n        if(ss==\"Max\")printf(\"%d\\n\",query(u,v));\n        if(ss==\"Add\")\n        {\n            register int w=read();\n            update(u,v,w);\n        }\n        if(ss==\"Cover\")\n        {\n            register int w=read();\n            assign(u,v,w);\n        }\n        if(ss==\"Change\")\n        {\n            assign(id2[u],id1[u],v);\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1562574758,
        "uid": 146794,
        "name": "tyg\u8fd9\u4e2alajixswl",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u8fd9\u9053~~\u6bd2\u7624~~\u9898\u672c\u4eba\u8bd5\u4e866\u904d\u624d\u8fc7\uff0c\u5199\u7bc7\u9898\u89e3\u7eaa\u5ff5\u4e00\u4e0b\n\n\u9996\u5148\uff0c\u5173\u4e8e\u6811\u94fe\u5256\u5206\u53ca\u91cd\u513f\u5b50\uff0c\u91cd\u94fe\u7684\u6982\u5ff5\uff0c\u5728\u6b64\u4e0d\u518d\u5e9f\u8bdd\uff0c\u8bf7\u81ea\u884c\u767e\u5ea6\n\n\u8fd9\u9898~~\u6bd2\u7624~~\u96be\u7684\u4e00\u70b9\u5c31\u662f\u70b9\u6743\u53d8\u6210\u8fb9\u6743\u4e86\n\n## \u90a3\u600e\u4e48\u529e\u5462\n\n# \u8fb9\u6743\u6362\u70b9\u6743\uff01\uff01\uff01\n\n\u5982\u4e0b\u56fe\u6240\u793a\uff0c\u628a\u6bcf\u8fb9\u6743\u503c\u8d4b\u7ed9\u5176\u4e0b\u7aef\u7684\u70b9\uff08\u6839\u8282\u70b9\u4e3a0\uff09\n\n![](https://cdn.luogu.com.cn/upload/pic/61502.png)\n\n\u7136\u540e\u5c31\u662f\u6a21\u677f\u7684\u95ee\u9898\u4e86\n\n\u4f46\u6709\u51e0\u4e2a\u7ec6\u8282\uff0c\u672c\u9898\u53c8\u52a0\u53c8\u8986\uff0c\u9700\u8981\u4e24\u4e2a\u61d2\u6807\u8bb0\uff0c\u8bb0\u5f97\u5904\u7406\u4ed6\u4eec\u7684\u5173\u7cfb\n\n\u8fd8\u6709\u4e00\u4ef6\u4e8b\uff0c\u5f53\u67e5\u8be2\u65f6\u8f6c\u5316\u4e3a\u4e00\u6761\u91cd\u94fe\u65f6\uff0c\u5982\u56fe\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/61504.png)\n\n\u6b64\u65f6\u6211\u4eec\u8981\u6c42u\uff0cv\u4e24\u70b9\u95f4\u7684\u6743\u503c\u6700\u5927\u503c\uff0c\u4f46\u662fu\u8282\u70b9\u5b58\u7684\u662f\u7ea2\u8fb9\u7684\u503c\uff0c\u8fd9\u4e0d\u662f\u6211\u4eec\u8981\u627e\u7684\u7b54\u6848\n\n\u800csun[u]\u5b58\u7684\u662f\u84dd\u8fb9\uff0c\u8fd9\u6b63\u662f\u6211\u4eec\u7684\u76ee\u6807\n\n\u6240\u4ee5\u6700\u540e\u8981\u67e5\u8be2\u7684\u533a\u95f4\u662fson[u]~v\u4e4b\u95f4\u7684\u6700\u5927\u503c\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#define lson id<<1,l,m\n#define rson id<<1|1,m+1,r\nusing namespace std;\nstruct node{\n\tint v;\n\tint next;\n}e[N<<1];\nint pos[N],tid[N],top[N],dep[N],son[N],siz[N],f[N],head[N];\nint d[N][5],sum[N<<2],col[N<<2],lzy[N<<2],n,m,k,ofo;\nvoid add(int u,int v)//\u52a0\u8fb9\u51fd\u6570\uff0c\u8bb0\u5f97\u52a0\u53cc\u5411\n{\n\te[++k].v=v;\n\te[k].next=head[u];\n\thead[u]=k;\n}\nvoid dfs1(int u,int fa)//\u4e24\u4e2adfs\u521d\u59cb\u5316\n{\n\tf[u]=fa;\n\tsiz[u]=1;\n\tson[u]=0;\n\tdep[u]=dep[fa]+1;\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa)\n\t\tcontinue;\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]])\n\t\tson[u]=v;\n\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp;\n\ttid[u]=++ofo;\n\tpos[ofo]=u;\n\tif(son[u])\n\tdfs2(son[u],tp);\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==f[u]||v==son[u])\n\t\tcontinue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid pushup(int id)\n{\n\tsum[id]=max(sum[id<<1],sum[id<<1|1]);\n}\nvoid pushdown(int id)//\u56e0\u4e3a\u8fd9\u4e2aWA\u4e86\u4e0d\u4e0b\u4e09\u904d\n{\n\tif(lzy[id]!=-1)//\u5148\u8986\u518d\u52a0\uff01\u5148\u8986\u518d\u52a0\uff01\u5148\u8986\u518d\u52a0\uff01\u91cd\u8981\u7684\u4e8b\u60c5\u8bf4\u4e09\u904d\n\t{\n\t\tcol[id<<1]=col[id<<1|1]=0;\n\t\tsum[id<<1]=sum[id<<1|1]=lzy[id];\n\t\tlzy[id<<1]=lzy[id<<1|1]=lzy[id];\n\t\tlzy[id]=-1;\n\t}\n\tif(col[id])\n\t{\n\t\tcol[id<<1]+=col[id];\n\t\tcol[id<<1|1]+=col[id];\n\t\tsum[id<<1]+=col[id];\n\t\tsum[id<<1|1]+=col[id];\n\t\tcol[id]=0;\n\t}\n}\nvoid build(int id,int l,int r)\n{\n\tlzy[id]=-1;\n\tif(l==r)\n\treturn;\n\tint m=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(id);\n}\nvoid update1(int id,int l,int r,int x,int y,int z)//\u533a\u95f4\u52a0\u6570\n{\n\tif(x<=l&&r<=y)\n\t{\n\t\tsum[id]+=z;\n\t\tcol[id]+=z;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tpushdown(id);\n\tif(x<=m)\n\tupdate1(lson,x,y,z);\n\tif(y>m)\n\tupdate1(rson,x,y,z);\n\tpushup(id);\n}\nvoid update2(int id,int l,int r,int x,int y,int z)//\u533a\u95f4\u8986\u76d6\n{\n\tif(x<=l&&r<=y)\n\t{\n\t\tsum[id]=z;\n\t\tlzy[id]=z;\n\t\tcol[id]=0;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tpushdown(id);\n\tif(x<=m)\n\tupdate2(lson,x,y,z);\n\tif(y>m)\n\tupdate2(rson,x,y,z);\n\tpushup(id);\n}\nint query(int id,int l,int r,int x,int y)//\u533a\u95f4\u67e5\u8be2\n{\n\tif(x<=l&&r<=y)\n\treturn sum[id];\n\tint m=(l+r)>>1,ans=-1e9;\n\tpushdown(id);\n\tif(x<=m)\n\tans=max(ans,query(lson,x,y));\n\tif(y>m)\n\tans=max(ans,query(rson,x,y));\n\treturn ans;\n}\nvoid Tupdate(int a,int b,int c,int flag)//\u6811\u5256\u533a\u95f4\u4fee\u6539\n{\n\twhile(top[a]!=top[b])\n\t{\n\t\tif(dep[top[a]]<dep[top[b]])\n\t\tswap(a,b);\n\t\tif(flag==1)\n\t\tupdate1(1,1,n,tid[top[a]],tid[a],c);\n\t\telse\n\t\tupdate2(1,1,n,tid[top[a]],tid[a],c);\n\t\ta=f[top[a]];\n\t}\n\tif(a==b)\n\treturn;\n\tif(dep[a]>dep[b])\n\tswap(a,b);\n\tif(flag==1)\n\tupdate1(1,1,n,tid[son[a]],tid[b],c);\n\telse\n\tupdate2(1,1,n,tid[son[a]],tid[b],c);\n}\nint Tquery(int a,int b)//\u6811\u5256\u533a\u95f4\u67e5\u8be2\n{\n\tint ans=-1e9;\n\twhile(top[a]!=top[b])\n\t{\n\t\tif(dep[top[a]]<dep[top[b]])\n\t\tswap(a,b);\n\t\tans=max(ans,query(1,1,n,tid[top[a]],tid[a]));\n\t\ta=f[top[a]];\n\t}\n\tif(a==b)\n\treturn ans;\n\tif(dep[a]>dep[b])\n\tswap(a,b);\n\tans=max(ans,query(1,1,n,tid[son[a]],tid[b]));\n\treturn ans;\n}\nint main()//\u6ce8\uff1a\u5728\u8fd9\u91cc\u6211\u7528\u4e86\u6570\u7ec4\u6765\u5b58\u8fb9\uff0c\u5c31\u4e0d\u7528\u4e58\u4ee5\u4e8c\u4e86\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&d[i][0],&d[i][1],&d[i][2]);\n\t\tadd(d[i][0],d[i][1]);\n\t\tadd(d[i][1],d[i][0]);\n\t}\n\tdfs1(1,1);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tif(dep[d[i][0]]>dep[d[i][1]])\n        swap(d[i][0],d[i][1]);\n\t\tupdate1(1,1,n,tid[d[i][1]],tid[d[i][1]],d[i][2]);\n\t}\n\tchar s[15]={'f'};\n\twhile(s[0]!='S')\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='A')\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\tTupdate(a,b,c,1);\n\t\t}\n\t\tif(s[0]=='C')\n\t\t{\n\t\t\tif(s[1]=='o')\n\t\t\t{\n\t\t\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\t\t\tTupdate(a,b,c,2);\n\t\t\t}\n\t\t\tif(s[1]=='h')\n\t\t\t{\n\t\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\t\tupdate2(1,1,n,tid[d[a][1]],tid[d[a][1]],b);\n\t\t\t}\n\t\t}\n\t\tif(s[0]=='M')\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tprintf(\"%d\\n\",Tquery(a,b));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1561624063,
        "uid": 103029,
        "name": "James_Brady",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "## \u4e00\u4e2a\u6811\u5256\u9898\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u7ef4\u62a4\u533a\u95f4\u8986\u76d6 \uff0c \u533a\u95f4\u52a0 \uff0c \u533a\u95f4\u6700\u5927\u503c\u3002\n\n\u6ce8\u610f\u5728\u6211\u4eec\u7684\u533a\u95f4\u52a0\u4e4b\u524d\uff0c\u4e00\u5b9a\u8981\u5148\u628a\u533a\u95f4\u8986\u76d6\uff08\u66f4\u65b0\u5b83\u7684\u503c\uff09 \n\n\u8fd9\u91cc\u91c7\u7528\u6570\u7ec4\u5199\u6cd5\uff0c\u6307\u9488\u5199\u6cd5\u8be6\u89c1[\u6211\u535a\u5ba2](https://www.luogu.org/blog/Treaker/#)\u5176\u4ed6\u6811\u5256\u9898\u3002\n\n\u987a\u4fbf\u63a8\u8350\u505a\u4e00\u4e0b\u6a21\u677f[\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384)  \n\n\u7801\u91cf\u6d77\u661f\uff01 \u7ec6\u5fc3\u4e00\u70b9\u5c31\u66f4\u52a0\u5b8c\u7f8e\u4e86\uff01\n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nconst int N = 100100;\nint ls(int x) {return x << 1;}\nint rs(int x) {return x << 1 | 1;}\nint n , cnt;\nint u[N] , v[N] , w[N] , dep[N] , size[N] , fa[N] , top[N] , hs[N] , a[N] , son[N] , head[N] , dfn[N] , id[N];\nint maxn[N << 2] , tag[N << 2] , lazy[N << 2];\nchar s[10];\nstruct Edge\n{\n\tint to , dis , nxt;\n}e[N << 1];\nvoid add(int from,int to,int dis)\n{\n\te[++cnt] = (Edge){to,dis,head[from]};\n\thead[from] = cnt;\n}\nvoid get_tree(int now)\n{\n\tsize[now] = 1;\n\tfor(int i = head[now];i;i = e[i].nxt)\n\t{\n\t\tint to = e[i].to;\n\t\tif(dep[to])\tcontinue;\n\t\ta[to] = e[i].dis;\n\t\tdep[to] = dep[now] + 1;\n\t\tfa[to] = now;\n\t\tget_tree(to);\n\t\tsize[now] += size[to];\n\t\tif(size[to] > size[hs[now]])\ths[now] = to;\n\t}\n}\nvoid dfs(int now,int topfa)\n{\n\tdfn[now] = ++cnt;\n\tid[cnt] = now;\n\ttop[now] = topfa;\n\tif(hs[now])\tdfs(hs[now],topfa);\n\tfor(int i = head[now];i;i = e[i].nxt)\n\t{\n\t\tint to = e[i].to;\n\t\tif(to == fa[now] || to == hs[now])\tcontinue;\n\t\tdfs(to,to);\n\t}\n}\nvoid build(int p,int l,int r)\n{\n\tif(l == r)\n\t{\n\t\tmaxn[p] = a[id[l]];\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(p),l,mid);\n\tbuild(rs(p),mid+1,r);\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nvoid push_down(int p,int l,int r)\n{\n\tif(lazy[p] >= 0)\n\t{\n\t\ttag[ls(p)] = tag[rs(p)] = 0;\n\t\tmaxn[ls(p)] = maxn[rs(p)] = lazy[ls(p)] = lazy[rs(p)] = lazy[p];\n\t\tlazy[p] = -1;\n\t}\n\tif(tag[p])\n\t{\n\t\ttag[ls(p)] += tag[p];\n\t\ttag[rs(p)] += tag[p];\n\t\tmaxn[ls(p)] += tag[p];\n\t\tmaxn[rs(p)] += tag[p];\n\t\ttag[p] = 0;\n\t}\n}\nint query_max(int p,int l,int r,int x,int y)\n{\n\tif(x <= l && r <= y)\treturn maxn[p];\n\tint mid = (l + r) >> 1 , res = 0;\n\tpush_down(p,l,r);\n\tif(x <= mid)\tres = max(res,query_max(ls(p),l,mid,x,y));\n\tif(y > mid)\t\tres = max(res,query_max(rs(p),mid+1,r,x,y));\n\treturn res;\n}\nint sec_max(int x,int y)\n{\n\tint res = 0;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tres = max(res , query_max(1,1,n,dfn[top[x]],dfn[x]));\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tif(dfn[y] < dfn[x])\tres = max(res,query_max(1,1,n,dfn[y]+1,dfn[x]));\n\treturn res;\n}\nvoid chenge_add(int p,int l,int r,int x,int y,int k)\n{\n\tif(x <= l && r <= y)\n\t{\n\t\ttag[p] += k;\n\t\tmaxn[p] += k;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tpush_down(p,l,r);\n\tif(x <= mid)\tchenge_add(ls(p),l,mid,x,y,k);\n\tif(y > mid)\t\tchenge_add(rs(p),mid+1,r,x,y,k);\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nvoid sec_add(int x,int y,int z)\n{\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tchenge_add(1,1,n,dfn[top[x]],dfn[x],z);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tif(dfn[y] < dfn[x])\tchenge_add(1,1,n,dfn[y]+1,dfn[x],z);\n}\nvoid chenge_cover(int p,int l,int r,int x,int y,int k)\n{\n\tif(x <= l && r <= y)\t\n\t{\n\t\tmaxn[p] = k;\n\t\ttag[p] = 0;\n\t\tlazy[p] = k;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tpush_down(p,l,r);\n\tif(x <= mid)\tchenge_cover(ls(p),l,mid,x,y,k);\n\tif(y > mid)\t\tchenge_cover(rs(p),mid+1,r,x,y,k);\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nvoid sec_cover(int x,int y,int z)\n{\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tchenge_cover(1,1,n,dfn[top[x]],dfn[x],z);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tif(dfn[y] < dfn[x])\tchenge_cover(1,1,n,dfn[y]+1,dfn[x],z);\n}\nvoid chenge_(int p,int l,int r,int x,int k)\n{\n\tif(l == r)\t\n\t{\n\t\tmaxn[p] = k;\n\t\ttag[p] = 0;\n\t\tlazy[p] = k;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tpush_down(p,l,r);\n\tif(x <= mid)\tchenge_(ls(p),l,mid,x,k);\n\telse\tchenge_(rs(p),mid+1,r,x,k);\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nint main()\n{\n\tmemset(lazy,-1,sizeof lazy);\n\tscanf(\"%d\",&n);\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tscanf(\"%d%d%d\",&u[i],&v[i],&w[i]);\n\t\tadd(u[i],v[i],w[i]); add(v[i],u[i],w[i]);\n\t}\n\tcnt = 0; dep[1] = 1;\n\tget_tree(1);\n\tdfs(1,1);\n\tbuild(1,1,n);\n\tfor(int i = 1;i < n;i ++)\n\t{\n\t\tif(fa[u[i]] == v[i])\tson[i] = u[i];\n\t\telse\tson[i] = v[i];\n\t}\n\twhile(1)\n\t{\n\t\tint x , y , z;\n\t\tscanf(\"%s\",s);\n\t\tif(s[0] == 'S')\tbreak;\n\t\tif(s[0] == 'M')\t\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%d\\n\",sec_max(x,y));\n\t\t}\n\t\telse\tif(s[0] == 'A')\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tsec_add(x,y,z);\n\t\t}\n\t\telse\tif(s[1] == 'o')\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tsec_cover(x,y,z);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tchenge_(1,1,n,dfn[son[x]],y);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1568810039,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u53c8\u662f\u4e00\u9053\u7ef4\u62a4\u8fb9\u6743\u7684\u9898\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u628a\u4ed6\u7684\u70b9\u6743\u8bbe\u4e3a\u4ed6\u8ddf\u4ed6\u7236\u4eb2\u4e4b\u95f4\u7684\u8fb9\u6743\uff0c\u8fd9\u6837\u5c31\u8f7b\u677e\u5730\u628a\u8fb9\u6743\u8f6c\u5316\u4e3a\u4e86\u70b9\u6743  \n\u4f46\u662f\uff0c\u8fd9\u9898\u7684\u91cd\u70b9\u5c31\u5728 \u540c\u65f6\u7ef4\u62a4\u533a\u95f4\u52a0\u548c\u533a\u95f4\u4fee\u6539\n\n\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4 $k$\uff0c\u6211\u4eec\u8bbe $maxv[k]$ \u4e3a\u533a\u95f4\u6700\u5927\u503c\uff0c$add[k],c[k]$ \u5206\u522b\u4e3a\u533a\u95f4\u52a0\u548c\u533a\u95f4\u4fee\u6539\u7684\u61d2\u6807\u8bb0  \n\u8ddf[P3373 \u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811 2](https://www.luogu.com.cn/problem/P3373)\u5f88\u50cf\u7684\u662f\uff0c\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u4e24\u4e2a\u4f18\u5148\u7ea7\u4e0d\u540c\u7684\u61d2\u6807\u8bb0\u3002  \n\u5728\u533a\u95f4\u4fee\u6539\u65f6\uff0c\u8ba9 $maxv[k]=c[k]=v$ \uff08v\u4e3a\u8981\u4fee\u6539\u7684\u503c\uff09\uff0c\u5e76\u4e14\u8986\u76d6\u6389\u4e4b\u524d\u6253\u8fc7\u7684 $add[k]$\uff08\u8d4b\u503c\u4e3a $0$\uff09  \n\u533a\u95f4\u52a0\u65f6\uff0c\u5c31\u76f4\u63a5\u66f4\u65b0 $maxv[k],add[k]$ \u5c31\u597d\u4e86\n\n\u5728\u4e0b\u653e\u6807\u8bb0\u65f6\uff0c\u5148\u653e $c[k]$\uff0c\u518d\u653e $add[k]$\u3002\u4e0b\u653e\u5b8c\u540e\u8bb0\u5f97\u5f52\u96f6\n\n\u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int Maxn=200000+10,Maxm=800000+10;\nstruct edge{\n\tint v,len;\n\tedge(int x,int y)\n\t{\n\t\tv=x,len=y;\n\t}\n};\nstruct Edge{\n\tint u,v;\n}g[Maxn];\nint maxv[Maxn],add[Maxn],c[Maxn];\nint top[Maxn],s[Maxn],id[Maxn];\nint f[Maxn],son[Maxn],d[Maxn];\nint a[Maxn],w[Maxn];\nint n,idcnt;\nvector <edge> e[Maxn];\ninline int read()\n{\n\tint s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();\n\treturn s*w;\n}\ninline void push_up(int k)\n{\n\tmaxv[k]=max(maxv[k<<1],maxv[k<<1|1]);\n}\ninline void upd_add(int k,int v)\n{\n\tadd[k]+=v;\n\tmaxv[k]+=v;\n}\ninline void upd_change(int k,int v)\n{\n\tadd[k]=0,maxv[k]=v;\n\tc[k]=v;\n}\ninline void push_down(int k)\n{\n\tif(c[k])\n\t{\n\t\tupd_change(k<<1,c[k]);\n\t\tupd_change(k<<1|1,c[k]);\n\t\tc[k]=0;\n\t}\n\tif(add[k])\n\t{\n\t\tupd_add(k<<1,add[k]);\n\t\tupd_add(k<<1|1,add[k]);\n\t\tadd[k]=0;\n\t}\n}\nvoid modify_add(int k,int l,int r,int x,int y,int v)\n{\n\tif(x<=l && r<=y)return upd_add(k,v);\n\tpush_down(k);\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify_add(k<<1,l,mid,x,y,v);\n\tif(mid<y)modify_add(k<<1|1,mid+1,r,x,y,v);\n\tpush_up(k);\n}\nvoid modify_change(int k,int l,int r,int x,int y,int v)\n{\n\tif(x<=l && r<=y)return upd_change(k,v);\n\tpush_down(k);\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify_change(k<<1,l,mid,x,y,v);\n\tif(mid<y)modify_change(k<<1|1,mid+1,r,x,y,v);\n\tpush_up(k);\n}\nint query(int k,int l,int r,int x,int y)\n{\n\tif(x<=l && r<=y)return maxv[k];\n\tpush_down(k);\n\tint mid=(l+r)>>1,ret=0;\n\tif(x<=mid)ret=max(ret,query(k<<1,l,mid,x,y));\n\tif(mid<y)ret=max(ret,query(k<<1|1,mid+1,r,x,y));\n\treturn ret;\n}\nvoid dfs1(int x,int fa,int len)\n{\n\ts[x]=1,f[x]=fa;\n\ta[x]=len,d[x]=d[fa]+1;\n\tfor(int i=0;i<e[x].size();++i)\n\t{\n\t\tint y=e[x][i].v;\n\t\tif(y==fa)continue;\n\t\tdfs1(y,x,e[x][i].len);\n\t\ts[x]+=s[y];\n\t\tif(s[y]>s[son[x]])son[x]=y;\n\t}\n}\nvoid dfs2(int x,int topp)\n{\n\ttop[x]=topp,id[x]=++idcnt;\n\tw[id[x]]=a[x];\n\tif(!son[x])return;\n\tdfs2(son[x],topp);\n\tfor(int i=0;i<e[x].size();++i)\n\t{\n\t\tint y=e[x][i].v;\n\t\tif(y==f[x] || y==son[x])continue;\n\t\tdfs2(y,y);\n\t}\n}\nvoid build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tmaxv[k]=w[l];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\tpush_up(k);\n}\nvoid seq_change(int x,int y,int v)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tmodify_change(1,1,n,id[top[x]],id[x],v);\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tif(x==y)return;\n\tmodify_change(1,1,n,id[x]+1,id[y],v);\n}\nvoid seq_add(int x,int y,int v)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tmodify_add(1,1,n,id[top[x]],id[x],v);\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tif(x==y)return;\n\tmodify_add(1,1,n,id[x]+1,id[y],v);\n}\nint query_seq(int x,int y)\n{\n\tint ret=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tret=max(ret,query(1,1,n,id[top[x]],id[x]));\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tif(x==y)return ret;\n\treturn max(ret,query(1,1,n,id[x]+1,id[y]));\n}\nint main()\n{\n//\tfreopen(\"in.txt\",\"r\",stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint x=read(),y=read(),c=read();\n\t\tg[i].u=x,g[i].v=y;\n\t\te[x].push_back(edge(y,c));\n\t\te[y].push_back(edge(x,c));\n\t}\n\t\n\tdfs1(1,0,0);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\twhile(1)\n\t{\n\t\tchar opt[20];\n\t\tscanf(\"%s\",opt);\n\t\tif(opt[0]=='S')break;\n\t\tif(opt[0]=='C' && opt[1]=='h')\n\t\t{\n\t\t\tint i=read(),v=read();\n\t\t\tseq_change(g[i].u,g[i].v,v);\n\t\t}\n\t\tif(opt[0]=='C' && opt[1]=='o')\n\t\t{\n\t\t\tint x=read(),y=read(),c=read();\n\t\t\tseq_change(x,y,c);\n\t\t}\n\t\tif(opt[0]=='A')\n\t\t{\n\t\t\tint x=read(),y=read(),c=read();\n\t\t\tseq_add(x,y,c);\n\t\t}\n\t\tif(opt[0]=='M')\n\t\t{\n\t\t\tint x=read(),y=read();\n\t\t\tprintf(\"%d\\n\",query_seq(x,y));\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```",
        "postTime": 1585541519,
        "uid": 120362,
        "name": "Priori_Incantatem",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "### \u603b\u7b97\u662fA\u6389\u8fd9\u9053\u9898\u4e86qwq\n\n\u771f\u662f\u628a\u5c0f\u849f\u84bb\u6211\u7ed9\u69a8\u5e72\u4e86qwq\n\nA\u6389\u8fd9\u9053\u9898\u7ecf\u8fc7\u4e86\u4e24\u5929\u591a\u7684\u52aa\u529b\u548c\u4e00\u4e9b\u795e\u5947\u7684\u7ecf\u5386\uff08\u6709\u5174\u8da3\u53ef\u4ee5\u81ea\u884c\u89c2\u770b\u8ba8\u8bba\n\n**\u54b3\u54b3\uff0c\u8fdb\u5165\u6b63\u9898**\n\n**\u8fd9\u9053\u9898\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u88f8\u7684\u8fb9\u6743\u6811\u5256\uff0c\u4e0d\u4f1a\u6811\u5256\u7684\u53ef\u4ee5\u53f3\u8f6cP3384\u6811\u5256\u6a21\u677f**\n\n\u5c0f\u849f\u84bb\u4e00\u5f00\u59cb\u5f88\u5feb\u60f3\u5230\u601d\u8def\u5c31\u6765\u505a\u8fd9\u9053\u9898\uff0c\u4f46\u505a\u5b8c\u4e86\u5c31\u53d1\u73b0\u5230\u5904\u90fd\u662f\u95ee\u9898\uff08\u679c\u7136\u8fd8\u662f\u6211\u592a\u83dc\u4e86qwq\uff09\uff0c\u5176\u5b9e\u8fd9\u9053\u9898\u7684\u7ec6\u8282\u90e8\u5206\u597d\u50cf\u4e5f\u4e0d\u662f\u5f88\u590d\u6742\uff0c\u7a0d\u5fae\u6ce8\u610f\u4e00\u4e0b\u5c31\u597d\u4e86qwq\n#### \u6709\u51e0\u70b9\u9700\u8981\u6ce8\u610f\uff1a\n\n1\uff1a\u6811\u5256\u7ef4\u62a4\u7684\u662f\u8fb9\u6743\uff0c\u53ef\u4ee5**\u628a\u8fb9\u6743\u8f6c\u5316\u5230\u70b9\u6743\u4e0a**\u3002\n\u600e\u4e48\u8f6c\u5316\u5462\uff1f\u56e0\u4e3a\u6bcf\u4e2a\u5b69\u5b50\u8282\u70b9\u901a\u5411\u7236\u8282\u70b9\u7684\u8fb9\u662f\u552f\u4e00\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u5c06\u6bcf\u4e2a\u8fb9\u7684\u8fb9\u6743\u8f6c\u5230\u8fb9\u6240\u8fde\u7684\u5b69\u5b50\u8282\u70b9\u4e0a\uff08\u53ef\u5728\u6811\u5256\u7684\u7b2c\u4e00\u4e2adfs\u4e2d\u5b8c\u6210\uff09\n\n2\uff1a\u4fee\u6539\u4e00\u6761\u94fe\u4e0a\u7684\u6743\u503c\u65f6\uff0c\u8981\u6ce8\u610f\u94fe\u4e24\u7aef\u7684\u70b9\u7684**lca\u4e0d\u80fd\u591f\u88ab\u4fee\u6539**\uff0c\u56e0\u4e3alca\u6240\u5bf9\u5e94\u7684\u8fb9\u6743\u4e0d\u5728\u8fd9\u4e00\u6761\u94fe\u4e0a\u3002\n\n3\uff1aChange \u64cd\u4f5c\u662f\u4fee\u6539**\u7b2ck\u6761**\u6811\u679d\uff0c**k\u4e3a\u8bfb\u5165\u7684\u987a\u5e8f**\uff0c\u800c\u6811\u7684\u5b58\u8fb9\u662f\u53cc\u5411\u7684\uff0c\u6240\u4ee5\u8981\u5c06\u8bfb\u5165\u7684k\u4e58\u4ee5\u4e8c\u5728\u8fdb\u884c\u540e\u9762\u7684\u64cd\u4f5c\u3002\n\n4\uff1a\u4e0b\u63a8\u6807\u8bb0\u7684\u65f6\u5019\u5982\u679c\u6709\u8986\u76d6\u6807\u8bb0\u4e0d\u8981\u5fd8\u4e86**\u6e05\u9664\u52a0\u7684\u6807\u8bb0**\u3002\n\n\u4e0a\u9762\u51e0\u70b9\u6709\u7684\u4e4b\u524d\u7684dalao\u5df2\u7ecf\u8bf4\u8fc7\u4e86\uff0c\u6743\u5f53\u662f\u518d\u505a\u4e00\u6b21\u603b\u7ed3\n\n\u6ce8\u610f\u4e86\u4ee5\u4e0a\u51e0\u70b9\uff0c\u7a0b\u5e8f\u81ea\u7136\u5c31\u4e0d\u5728\u8bdd\u4e0b\u4e86qwq\n\n\u611f\u8c22@rehtorbegnaro\u4ee5\u53ca\u5176\u4ed6dalao\u7684\u5e2e\u52a9\u548c\u652f\u6301\n\n**\u732e\u4e0a233\u884c\u4ee3\u7801**233\n```\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm> \n#define maxn 2000010\n#define ll long long\n#define re register\n#define FOR(i,l,r) for(re ll i=l;i<=r;i++)\nusing namespace std;\n\nll tag1[maxn<<2],tag2[maxn<<2],ans[maxn<<2],head[maxn<<1],a[maxn];//tag1\u4e3a\u8986\u76d6\uff0ctag2\u4e3a\u52a0 \nll top[maxn],son[maxn],depth[maxn],fa[maxn],siz[maxn],id[maxn],dd[maxn];\nll n,m,k,t,num,cnt,x,y,z,w,q;\nstring s;\n\nstruct hz{\n    ll next;\n    ll to;\n    ll dis;\n    ll from;\n}h[maxn<<1];\n\ninline void in(ll &x){  //\u5feb\u8bfb\u4f7f\u6211\u5feb\u4e50 \n    x=0;ll f=1;char c=getchar();\n    while(c<'0'||c>'9'){\n        if(c==-1) return;\n        if(c=='-')f=-1;\n        c=getchar();\n    }\n    while(c<='9'&&c>='0'){\n        x=(x<<1)+(x<<3)+(c^'0');\n        c=getchar();\n    }\n    x=x*f;\n}\n\ninline void out(ll a){\n    if(a<0){\n        a*=-1;\n        putchar('-');\n    } \n    if(a>=10)out(a/10);\n    putchar(a%10+'0');\n}\n\ninline void add(ll from,ll to,ll dis){ //\u90bb\u63a5\u8868\u5b58\u8fb9 \n    h[++num].next=head[from];\n    h[num].to=to;\n    h[num].from=from;\n    h[num].dis=dis;\n    head[from]=num;\n}\n//------------------------------\u4ee5\u4e0b\u4e3a\u7ebf\u6bb5\u6811\u90e8\u5206\ninline ll ls(ll k){\n    return k<<1;\n}\n\ninline ll rs(ll k){\n    return k<<1|1;\n}\n\ninline void push_up(ll k){\n    ans[k]=max(ans[ls(k)],ans[rs(k)]);\n}\n\ninline void push_down(ll p){ //\u4e0b\u63a8\u6807\u8bb0\n    if(tag1[p]!=-1){ //\u4e0b\u63a8\u8986\u76d6\u6807\u8bb0\u65f6\u8981\u6e05\u695a\u52a0\u6807\u8bb0\n        tag1[ls(p)]=tag1[rs(p)]=tag1[p];\n        ans[ls(p)]=ans[rs(p)]=tag1[p];\n        tag2[ls(p)]=tag2[rs(p)]=0;\n        tag1[p]=-1;\n    }\n    tag2[ls(p)]+=tag2[p];\n    tag2[rs(p)]+=tag2[p];\n    ans[ls(p)]+=tag2[p];\n    ans[rs(p)]+=tag2[p];\n    tag2[p]=0;\n}\n\nvoid update1(ll nl,ll nr,ll l,ll r,ll p,ll k){ //\u533a\u95f4\u8986\u76d6\n    if(nl<=l&&r<=nr){\n        ans[p]=k;\n        tag1[p]=k;\n        tag2[p]=0;\n        return;\n    }\n    ll mid=(l+r)>>1;\n    push_down(p);\n    if(nl<=mid) update1(nl,nr,l,mid,ls(p),k);\n    if(nr>mid) update1(nl,nr,mid+1,r,rs(p),k);\n    push_up(p);\n}\n\nvoid update2(ll nl,ll nr,ll l,ll r,ll p,ll k){ //\u533a\u95f4\u52a0\n    if(nl<=l&&r<=nr){\n        ans[p]+=k;\n        tag2[p]+=k;\n        return;\n    }\n    ll mid=(l+r)>>1;\n    push_down(p);\n    if(nl<=mid) update2(nl,nr,l,mid,ls(p),k);\n    if(nr>mid) update2(nl,nr,mid+1,r,rs(p),k);\n    push_up(p);\n}\n\nll query(ll q_x,ll q_y,ll l,ll r,ll p){ //\u533a\u95f4\u6c42Max\n    if(q_x<=l&&r<=q_y)\n      return ans[p];\n    ll res=0;\n    ll mid=(l+r)>>1;\n    push_down(p);\n    if(q_x<=mid) res=max(res,query(q_x,q_y,l,mid,ls(p)));\n    if(q_y>mid) res=max(res,query(q_x,q_y,mid+1,r,rs(p)));\n    return res;\n}\n\nvoid build(ll p,ll l,ll r){ //\u5efa\u6811\n    tag1[p]=-1;\n    tag2[p]=0;\n    if(l==r){\n        ans[p]=dd[l];\n        return;\n    }\n    ll mid=(l+r)>>1;\n    build(ls(p),l,mid);\n    build(rs(p),mid+1,r);\n    push_up(p);\n}\n//------------------------------\u4ee5\u4e0a\u4e3a\u7ebf\u6bb5\u6811\u90e8\u5206\nvoid dfs1(ll f,ll ff){\n    depth[f]=depth[ff]+1;\n    fa[f]=ff;\n    siz[f]=1;\n    ll maxson=-1;\n    for(re ll i=head[f];i!=0;i=h[i].next){\n        if(h[i].to==ff)\n          continue;\n        dfs1(h[i].to,f);\n        a[h[i].to]=h[i].dis;  //\u628a\u8fb9\u6743\u5316\u4e3a\u70b9\u6743\n        siz[f]+=siz[h[i].to];\n        if(siz[h[i].to]>maxson){\n            maxson=siz[h[i].to];\n            son[f]=h[i].to;\n        }\n    }\n}\n\nvoid dfs2(ll x,ll topf){\n    top[x]=topf;\n    id[x]=++cnt;\n    dd[cnt]=a[x];\n    if(!son[x])\n      return;\n    dfs2(son[x],topf);\n    for(re ll i=head[x];i!=0;i=h[i].next){\n        if(h[i].to==fa[x]||h[i].to==son[x])\n          continue;\n        dfs2(h[i].to,h[i].to);\n    }\n}\n\nvoid updrange1(ll x,ll y,ll k){ //Change\u548cCover\u64cd\u4f5c\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]])\n          swap(x,y);\n        update1(id[top[x]],id[x],1,n,1,k);\n        x=fa[top[x]];\n    }\n    if(depth[x]>depth[y])\n      swap(x,y);\n    update1(id[x]+1,id[y],1,n,1,k); //\u4e0d\u80fd\u66f4\u65b0lca\u6240\u4ee5\u662f(id[x]+1)\n}\n\nvoid updrange2(ll x,ll y,ll k){  //Add\u64cd\u4f5c\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]])\n          swap(x,y);\n        update2(id[top[x]],id[x],1,n,1,k);\n        x=fa[top[x]];\n    }\n    if(depth[x]>depth[y])\n      swap(x,y);\n    update2(id[x]+1,id[y],1,n,1,k); //\u540c\u4e0a\n}\n\nll qrange(ll x,ll y){  //Max\u64cd\u4f5c\n    ll anss=0;\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]])\n          swap(x,y);\n        anss=max(anss,query(id[top[x]],id[x],1,n,1));\n        x=fa[top[x]];\n    }\n    if(depth[x]>depth[y])\n      swap(x,y);\n    return max(anss,query(id[x]+1,id[y],1,n,1));//\u540c\u7406\n}\n\nint main(){\n    in(n);\n    FOR(i,1,n-1){\n        in(x),in(y),in(z);\n        add(x,y,z);\n        add(y,x,z); //\u53cc\u5411\u52a0\u8fb9\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,n);\n    while(s!=\"Stop\"){\n        if(s[1]=='h'){\n            in(x),in(k);\n            x*=2; //\u56e0\u4e3a\u8fb9\u6709\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u4e58\u4ee5\u4e8c\u4fdd\u8bc1\u662f\u7b2cK\u6761\u8fb9\n            x=depth[h[x].from]>depth[h[x].to]?h[x].from:h[x].to;//\u6df1\u5ea6\u5927\u7684\u70b9\uff08\u5b50\u8282\u70b9\uff09\u4fdd\u5b58\u6743\u503c\n            update1(id[x],id[x],1,n,1,k); //Change\u64cd\u4f5c\n        }\n        if(s[1]=='o'){\n            in(x),in(y),in(z);\n            updrange1(x,y,z); //Cover\u64cd\u4f5c\n        }\n        if(s[1]=='d'){\n            in(x),in(y),in(z);\n            updrange2(x,y,z); //Add\u64cd\u4f5c\n        }\n        if(s[1]=='a'){\n            in(x),in(y);\n            out(qrange(x,y));  //Max\u64cd\u4f5c\n            puts(\"\");\n        }\n        cin>>s;\n    }\n    return 0; //\u529f\u5fb7\u5706\u6ee1\n}\n```",
        "postTime": 1535539156,
        "uid": 66965,
        "name": "Juan_feng",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u6811\u4e0a\u7684\u94fe\u95ee\u9898\uff0c\u663e\u7136\u53ef\u4ee5\u6811\u94fe\u5256\u5206\n\n\u6bcf\u6761\u8fb9\u7684\u8fb9\u6743\u4e0b\u63a8\u5230\u6df1\u5ea6\u66f4\u6df1\u7684\u8282\u70b9\u4e0a\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u70b9\u6743\n\n\u6ce8\u610fLCA\u7684\u70b9\u6240\u7ef4\u62a4\u7684\u8fb9\u6743\u4e0d\u5c5e\u4e8e\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\uff0c\u5728\u4fee\u6539\u548c\u8ba1\u7b97\u65f6\u8981\u6392\u9664\n\n\u8981\u7528\u4e24\u79cd\u6807\u8bb0\uff0c\u6ce8\u610f\u4e24\u79cd\u6807\u8bb0\u7684\u4f18\u5148\u7ea7\n\n\u533a\u95f4\u8986\u76d6\u6807\u8bb0\u4e0b\u4f20\u65f6\u8981\u628a\u533a\u95f4\u52a0\u7684\u6807\u8bb0\u8986\u76d6\u6389\n\n\u5f53\u7136\u4e5f\u53ef\u4ee5\u5728\u4e00\u79cd\u6807\u8bb0\u6253\u4e0a\u4e4b\u524d\u5148\u4e0b\u4f20\u513f\u5b50\u7684\u6807\u8bb0\uff0c\u540c\u6837\u53ef\u4ee5\u4fdd\u8bc1\u6b63\u786e\u6027\uff0c\u4f46\u662f\u4f1a\u53d8\u5f97\u5f88\u6162\n\n```cpp\n#include<cstdio>\nusing namespace std;\nint n,opt,x,y,z,cnt,tot,out,tt,u[100010],v[100010],w[100010],a[100010],id[100010],at[100010],h[100010],dad[100010],top[100010],dep[100010],size[100010],son[100010];\nchar c;\nstruct Edge\n{\n\tint next,to;\n}e[200010];\nstruct SegT\n{\n\tint mx,l,tag;\n}t[400010];\nint read()\n{\n\tout=0,c=getchar();\n\twhile(c<48||c>57){c=getchar();}\n\twhile(c>=48&&c<=57){out=(out<<3)+(out<<1)+(c&15),c=getchar();}\n\treturn out;\n}\nvoid Add(int x,int y)\n{\n\te[++cnt].next=h[x],\n\te[cnt].to=y,\n\th[x]=cnt;\n}\nvoid DFS1(int x)\n{\n\tdep[x]=dep[dad[x]]+1,size[x]=1;\n\tfor(int i=h[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].to;\n\t\tif(dad[x]^y)\n\t\t{\n\t\t\tdad[y]=x;\n\t\t\tDFS1(y);\n\t\t\tsize[x]+=size[y];\n\t\t\tif(size[son[x]]<size[y]){son[x]=y;}\n\t\t}\n\t}\n}\nvoid DFS2(int x)\n{\n\tid[x]=++tot,at[tot]=a[x],\n\ttop[x]=x==son[dad[x]]?top[dad[x]]:x;\n\tif(!son[x]){return;}\n\tDFS2(son[x]);\n\tfor(int i=h[x];i;i=e[i].next)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y^dad[x]&&y^son[x]){DFS2(y);}\n\t}\n}\nvoid DFS(int x)\n{\n\tDFS1(x);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tif(dep[u[i]]>dep[v[i]]){a[u[i]]=w[i];}\n\t\telse{a[v[i]]=w[i];}\n\t}\n\tDFS2(x);\n}\nint max(int a,int b)\n{\n\treturn a>b?a:b;\n}\nvoid Pushup(int k)\n{\n\tt[k].mx=max(t[k<<1].mx,t[k<<1|1].mx);\n}\nvoid Pushdown(int k,int l,int r)\n{\n\tif(l==r){return;}\n\tif(t[k].tag==1)\n\t{\n\t\tt[k<<1].tag=1,t[k<<1|1].tag=1,\n\t\tt[k<<1].l=t[k].l,t[k<<1|1].l=t[k].l,\n\t\tt[k<<1].mx=t[k].l,t[k<<1|1].mx=t[k].l,\n\t\tt[k].tag=0,t[k].l=0;\n\t}\n\tif(t[k].tag==2)\n\t{\n\t\tint mid=l+r>>1;\n\t\tPushdown(k<<1,l,mid);Pushdown(k<<1|1,mid+1,r);\n\t\tt[k<<1].tag=2,t[k<<1|1].tag=2,\n\t\tt[k<<1].l=t[k].l,t[k<<1|1].l=t[k].l,\n\t\tt[k<<1].mx+=t[k].l,t[k<<1|1].mx+=t[k].l,\n\t\tt[k].tag=0,t[k].l=0;\n\t}\n}\nvoid Build(int k,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tt[k].mx=at[l];\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tBuild(k<<1,l,mid);\n\tBuild(k<<1|1,mid+1,r);\n\tPushup(k);\n}\nvoid Changes(int k,int l,int r,int ll,int rr,int x)\n{\n\tif(r<ll||rr<l){return;}\n\tif(ll<=l&&r<=rr)\n\t{\n\t\tPushdown(k,l,r);\n\t\tt[k].mx=x,t[k].tag=1,t[k].l=x;\n\t\treturn;\n\t}\n\tPushdown(k,l,r);\n\tint mid=l+r>>1;\n\tChanges(k<<1,l,mid,ll,rr,x);\n\tChanges(k<<1|1,mid+1,r,ll,rr,x);\n\tPushup(k);\n}\nvoid Changep(int k,int l,int r,int ll,int rr,int x)\n{\n\tif(r<ll||rr<l){return;}\n\tif(ll<=l&&r<=rr)\n\t{\n\t\tPushdown(k,l,r);\n\t\tt[k].mx+=x,t[k].tag=2,t[k].l=x;\n\t\treturn;\n\t}\n\tPushdown(k,l,r);\n\tint mid=l+r>>1;\n\tChangep(k<<1,l,mid,ll,rr,x);\n\tChangep(k<<1|1,mid+1,r,ll,rr,x);\n\tPushup(k);\n}\nint Query(int k,int l,int r,int ll,int rr)\n{\n\tif(r<ll||rr<l){return -19260817;}\n\tif(ll<=l&&r<=rr){return t[k].mx;}\n\tPushdown(k,l,r);\n\tint mid=l+r>>1;\n\treturn max(Query(k<<1,l,mid,ll,rr),Query(k<<1|1,mid+1,r,ll,rr));\n}\nvoid ChangesL(int x,int y,int z)\n{\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}\n\t\tChanges(1,1,n,id[top[x]],id[x],z);\n\t\tx=dad[top[x]];\n\t}\n\tif(dep[x]>dep[y]){x^=y,y^=x,x^=y;}\n\tChanges(1,1,n,id[x]+1,id[y],z);\n}\nvoid ChangepL(int x,int y,int z)\n{\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}\n\t\tChangep(1,1,n,id[top[x]],id[x],z);\n\t\tx=dad[top[x]];\n\t}\n\tif(dep[x]>dep[y]){x^=y,y^=x,x^=y;}\n\tChangep(1,1,n,id[x]+1,id[y],z);\n}\nint LCA(int x,int y)\n{\n\tint ans=-19260817;\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]]){x^=y,y^=x,x^=y;}\n\t\tans=max(ans,Query(1,1,n,id[top[x]],id[x])),\n\t\tx=dad[top[x]];\n\t}\n\tif(dep[x]>dep[y]){x^=y,y^=x,x^=y;}\n\tans=max(ans,Query(1,1,n,id[x]+1,id[y]));\n\treturn ans;\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tu[i]=read(),v[i]=read(),w[i]=read();\n\t\tAdd(u[i],v[i]);Add(v[i],u[i]);\n\t}\n\tDFS(1);\n\tBuild(1,1,n);\n\twhile(1)\n\t{\n\t\tc=getchar();\n\t\twhile(1)\n\t\t{\n\t\t\tif(c==83){return 0;}\n\t\t\tif(c==77){opt=4;break;}\n\t\t\tif(c==65){opt=3;break;}\n\t\t\tif(c==111){opt=2;break;}\n\t\t\tif(c==104){opt=1;break;}\n\t\t\tc=getchar();\n\t\t}\n\t\tif(opt==1)\n\t\t{\n\t\t\tx=read(),y=read();\n\t\t\tif(dep[u[x]]>dep[v[x]]){Changes(1,1,n,id[u[x]],id[u[x]],y);}\n\t\t\telse{Changes(1,1,n,id[v[x]],id[v[x]],y);}\n\t\t}\n\t\tif(opt==2)\n\t\t{\n\t\t\tx=read(),y=read(),z=read();\n\t\t\tChangesL(x,y,z);\n\t\t}\n\t\tif(opt==3)\n\t\t{\n\t\t\tx=read(),y=read(),z=read();\n\t\t\tChangepL(x,y,z);\n\t\t}\n\t\tif(opt==4)\n\t\t{\n\t\t\tx=read(),y=read();\n\t\t\tprintf(\"%d\\n\",LCA(x,y));\n\t\t}\n\t\t\n\t}\n}\n```",
        "postTime": 1571029573,
        "uid": 14378,
        "name": "doby",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u6700\u8fd1\u4e00\u76f4\u5728\u5237\u6811\u5256~~\u7ebf\u6bb5\u6811~~\u9898\n\n\u672c\u9898\u6c42\u7ef4\u62a4\u7684\u662f\u8fb9\u6743\uff0c\u56e0\u6b64\u6211\u4eec\u9700\u8981\u628a\u8fb9\u6743\u8f6c\u79fb\u5230\u70b9\u6743\u4e0a\uff0c\u624d\u53ef\u4ee5\u5957\u8def\u5730\u8fdb\u884c\u6811\u5256\uff0c\u5177\u4f53\u65b9\u6cd5\u8bf7\u89c1[P3038](https://www.luogu.org/problem/P3038)\uff0c\u662f\u6b64\u7c7b\u95ee\u9898\u7684\u88f8\u9898\u3002\uff08\u590d\u8bfb\u4e0a\u4e00\u7bc7\u535a\u5ba2\uff09\n\n\u672c\u9898\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\uff0c\u652f\u6301\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u52a0\u3002\n\n\u533a\u95f4\u4fee\u6539\u548c\u533a\u95f4\u52a0\u9700\u8981\u5206\u522b\u5f00lazy\u6570\u7ec4\uff0c\u6ce8\u610fpushdown\u7684\u987a\u5e8f\u5e94\u8be5\u662f\u5148\u66f4\u65b0\u533a\u95f4\u4fee\u6539\u518d\u66f4\u65b0\u533a\u95f4\u4ef7\uff0c\u5426\u5219\u533a\u95f4\u52a0\u7684\u4fee\u6539\u4f1a\u88ab\u8986\u76d6\u6389\n\n\u6ce8\u610f\u533a\u95f4\u4fee\u6539\u7684\u64cd\u4f5c\u4f1a\u5c06\u5f53\u524d\u533a\u95f4\u7684\u533a\u95f4\u52a0\u7684lazy\u6570\u7ec4\u53d8\u4e3a0\n\n\u6b64\u5916\uff0c\u8c08\u4e00\u8c08\u6211\u5728\u5b58\u50a8\u8fb9\u7684\u5e8f\u53f7\u65f6\u9047\u5230\u7684\u95ee\u9898\u3002\n\n\u539f\u6765\u7684\u4ee3\u7801\uff0c\u7528stetins\uff0cmp\u4e24\u4e2a\u6570\u7ec4\u6620\u5c04\uff0c\u50a8\u5b58\u8fb9\u7684\u5e8f\u53f7\u6620\u5c04\u5230\u7684\u70b9\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint head[100005],pnt[200005],nxt[200005],weight[200005],E=0;\nint dep[100005],son[100005],fa[100005],sz[100005];\nint top[100005],val[100005],id[100005],cnt=0;\nint tree[400005],lazy[400005],lazy2[400005];\nint n,steins[100005],mp[100005];\nchar ss[15];\nvoid pushup(int k)\n{\n\ttree[k]=max(tree[k<<1],tree[k<<1|1]);\n}\nvoid pushdown(int k)\n{\n\tif(lazy2[k]!=-1)\n\t{\n\t\ttree[k<<1]=lazy2[k];\n\t\ttree[k<<1|1]=lazy2[k];\n\t\tlazy2[k<<1]=lazy2[k];\n\t\tlazy2[k<<1|1]=lazy2[k];\n\t\tlazy[k<<1]=0;\n\t\tlazy[k<<1|1]=0;\n\t\tlazy2[k]=-1;\n\t}\n\ttree[k<<1]+=lazy[k];\n\ttree[k<<1|1]+=lazy[k];\n\tlazy[k<<1]+=lazy[k];\n\tlazy[k<<1|1]+=lazy[k];\n\tlazy[k]=0;\n}\nvoid build(int l,int r,int k)\n{\n\tif(l==r)\n\t{\n\t\ttree[k]=val[l];\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,k<<1);\n\tbuild(m+1,r,k<<1|1);\n\tpushup(k);\n}\nvoid modify(int L,int R,int l,int r,int k,int v,int opt)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tif(opt==1)\n\t\t{\n\t\t\ttree[k]=v;\n\t\t\tlazy2[k]=v;\n\t\t\tlazy[k]=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[k]+=v;\n\t\t\tlazy[k]+=v;\n\t\t}\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint m=(l+r)>>1;\n\tif(L<=m)modify(L,R,l,m,k<<1,v,opt);\n\tif(R>m)modify(L,R,m+1,r,k<<1|1,v,opt);\n\tpushup(k);\n}\nint query(int L,int R,int l,int r,int k)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\treturn tree[k];\n\t}\n\tpushdown(k);\n\tint m=(l+r)>>1,tmp=0;\n\tif(L<=m)tmp=max(tmp,query(L,R,l,m,k<<1));\n\tif(R>m)tmp=max(tmp,query(L,R,m+1,r,k<<1|1));\n\treturn tmp;\n}\nvoid add_edge(int a,int b,int c,int d)\n{\n\tpnt[E]=b;\n\tnxt[E]=head[a];\n\tweight[E]=c;\n\tsteins[d]=E;\n\thead[a]=E++;\n}\nvoid dfs1(int u,int dpth)\n{\n\tdep[u]=dpth;\n\tsz[u]=1;\n\tint maxson=0;\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u])continue;\n\t\tfa[v]=u;\n\t\tdfs1(v,dpth+1);\n\t\tsz[u]+=sz[v];\n\t\tif(maxson<sz[v])\n\t\t{\n\t\t\tmaxson=sz[v];\n\t\t\tson[u]=v;\n\t\t}\n\t}\n}\nvoid dfs2(int u,int tops)\n{\n\ttop[u]=tops;\n\tid[u]=++cnt;\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u])\n\t\t{\n\t\t\tval[cnt]=weight[i];\n\t\t\tmp[i]=cnt;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!son[u])return;\n\tdfs2(son[u],tops);\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u]||v==son[u])continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid modifychain(int x,int y,int z,int opt)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tmodify(id[top[x]],id[x],1,cnt,1,z,opt);\n\t\tx=fa[top[x]];\n\t}\n\tif(x!=y)\n\t{\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tmodify(id[x]+1,id[y],1,cnt,1,z,opt);\n\t}\n}\nint querychain(int x,int y)\n{\n\tint ans=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=max(ans,query(id[top[x]],id[x],1,cnt,1));\n\t\tx=fa[top[x]];\n\t}\n\tif(x!=y)\n\t{\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tans=max(ans,query(id[x]+1,id[y],1,cnt,1));\n\t}\n\treturn ans;\n}\nint main()\n{\n\tmemset(lazy2,-1,sizeof(lazy2));\n\tmemset(head,-1,sizeof(head));\n\tmemset(mp,-1,sizeof(mp));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tadd_edge(u,v,w,i);\n\t\tadd_edge(v,u,w,i);\n\t}\n\tdfs1(1,1);\n\tdfs2(1,1);\n\tbuild(1,cnt,1);\n\twhile(1)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tif(ss[1]=='h')\n\t\t{\n\t\t\tint x,v;\n\t\t\tscanf(\"%d%d\",&x,&v);\n\t\t\tmodify(max(mp[steins[x]],mp[steins[x]^1]),max(mp[steins[x]],mp[steins[x]^1]),1,cnt,1,v,1);\n\t\t}\n\t\tif(ss[1]=='o')\n\t\t{\n\t\t\tint x,y,w;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tmodifychain(x,y,w,1);\n\t\t}\n\t\tif(ss[1]=='d')\n\t\t{\n\t\t\tint x,y,w;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tmodifychain(x,y,w,2);\n\t\t}\n\t\tif(ss[1]=='a')\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%d\\n\",querychain(x,y));\n\t\t}\n\t\tif(ss[1]=='t')break;\n\t}\n\treturn 0;\n}\n```\n\n\u4fee\u6539\u540e\u5728\u8bfb\u5165\u8fb9\u65f6\u50a8\u5b58\u4e86\u8fb9\u7684\u8d77\u70b9\u3001\u7ec8\u70b9\uff0c\u5219\u8be5\u8fb9\u76f4\u63a5\u6620\u5c04\u5230\u8d77\u70b9\u3001\u7ec8\u70b9\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e00\u4e2a\u70b9\u4e0a\n\n\u53ea\u5728\u52a0\u8fb9\u3001dfs1\u3001dfs2\u3001change\u64cd\u4f5c\u4e0a\u7565\u6709\u4e0d\u540c\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint head[100005],pnt[200005],nxt[200005],weight[200005],w[200005],E=0;\nint dep[100005],son[100005],fa[100005],sz[100005];\nint top[100005],val[100005],id[100005],cnt=0;\nint tree[400005],lazy[400005],lazy2[400005];\nint from[100005],to[100005];\nint n;\nchar ss[15];\nvoid pushup(int k)\n{\n\ttree[k]=max(tree[k<<1],tree[k<<1|1]);\n}\nvoid pushdown(int k)\n{\n\tif(lazy2[k]!=-1)\n\t{\n\t\ttree[k<<1]=lazy2[k];\n\t\ttree[k<<1|1]=lazy2[k];\n\t\tlazy2[k<<1]=lazy2[k];\n\t\tlazy2[k<<1|1]=lazy2[k];\n\t\tlazy[k<<1]=0;\n\t\tlazy[k<<1|1]=0;\n\t\tlazy2[k]=-1;\n\t}\n\ttree[k<<1]+=lazy[k];\n\ttree[k<<1|1]+=lazy[k];\n\tlazy[k<<1]+=lazy[k];\n\tlazy[k<<1|1]+=lazy[k];\n\tlazy[k]=0;\n}\nvoid build(int l,int r,int k)\n{\n\tif(l==r)\n\t{\n\t\ttree[k]=val[l];\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(l,m,k<<1);\n\tbuild(m+1,r,k<<1|1);\n\tpushup(k);\n}\nvoid modify(int L,int R,int l,int r,int k,int v,int opt)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tif(opt==1)\n\t\t{\n\t\t\ttree[k]=v;\n\t\t\tlazy2[k]=v;\n\t\t\tlazy[k]=0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[k]+=v;\n\t\t\tlazy[k]+=v;\n\t\t}\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint m=(l+r)>>1;\n\tif(L<=m)modify(L,R,l,m,k<<1,v,opt);\n\tif(R>m)modify(L,R,m+1,r,k<<1|1,v,opt);\n\tpushup(k);\n}\nint query(int L,int R,int l,int r,int k)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\treturn tree[k];\n\t}\n\tpushdown(k);\n\tint m=(l+r)>>1,tmp=0;\n\tif(L<=m)tmp=max(tmp,query(L,R,l,m,k<<1));\n\tif(R>m)tmp=max(tmp,query(L,R,m+1,r,k<<1|1));\n\treturn tmp;\n}\nvoid add_edge(int a,int b,int c)\n{\n\tpnt[E]=b;\n\tnxt[E]=head[a];\n\tweight[E]=c;\n\thead[a]=E++;\n}\nvoid dfs1(int u,int dpth)\n{\n\tdep[u]=dpth;\n\tsz[u]=1;\n\tint maxson=0;\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u])continue;\n\t\tfa[v]=u;\n\t\tw[v]=weight[i];\n\t\tdfs1(v,dpth+1);\n\t\tsz[u]+=sz[v];\n\t\tif(maxson<sz[v])\n\t\t{\n\t\t\tmaxson=sz[v];\n\t\t\tson[u]=v;\n\t\t}\n\t}\n}\nvoid dfs2(int u,int tops)\n{\n\ttop[u]=tops;\n\tid[u]=++cnt;\n\tval[cnt]=w[u];\n\tif(!son[u])return;\n\tdfs2(son[u],tops);\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u]||v==son[u])continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid modifychain(int x,int y,int z,int opt)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tmodify(id[top[x]],id[x],1,cnt,1,z,opt);\n\t\tx=fa[top[x]];\n\t}\n\tif(x!=y)\n\t{\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tmodify(id[x]+1,id[y],1,cnt,1,z,opt);\n\t}\n}\nint querychain(int x,int y)\n{\n\tint ans=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=max(ans,query(id[top[x]],id[x],1,cnt,1));\n\t\tx=fa[top[x]];\n\t}\n\tif(x!=y)\n\t{\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tans=max(ans,query(id[x]+1,id[y],1,cnt,1));\n\t}\n\treturn ans;\n}\nint main()\n{\n\tmemset(lazy2,-1,sizeof(lazy2));\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tfrom[i]=u;\n\t\tto[i]=v;\n\t\tadd_edge(u,v,w);\n\t\tadd_edge(v,u,w);\n\t}\n\tdfs1(1,1);\n\tdfs2(1,1);\n\tbuild(1,cnt,1);\n\twhile(1)\n\t{\n\t\tscanf(\"%s\",ss);\n\t\tif(ss[1]=='h')\n\t\t{\n\t\t\tint x,v;\n\t\t\tscanf(\"%d%d\",&x,&v);\n\t\t\tint u=from[x],vv=to[x];\n\t\t\tif(dep[u]>dep[vv])swap(u,vv);\n\t\t\tmodify(id[vv],id[vv],1,cnt,1,v,1);\n\t\t}\n\t\tif(ss[1]=='o')\n\t\t{\n\t\t\tint x,y,w;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tmodifychain(x,y,w,1);\n\t\t}\n\t\tif(ss[1]=='d')\n\t\t{\n\t\t\tint x,y,w;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tmodifychain(x,y,w,2);\n\t\t}\n\t\tif(ss[1]=='a')\n\t\t{\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%d\\n\",querychain(x,y));\n\t\t}\n\t\tif(ss[1]=='t')break;\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1569330064,
        "uid": 34217,
        "name": "Katsura_Hinagiku",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u8fd9\u9898\u672c\u849f\u84bb\u5199\u6811\u5256\u8c03\u4e8640+\u5206\u949f\uff0c\u7136\u540e\u6109\u5feb\u7684\u7206\u96f6\u4e86\u3002\n\n\u7136\u540e\u6254\u6389\u6012\u5199\u4e00\u53d1$LCT$\u7adf\u7136$1A$\u4e86\uff1f\uff1f\uff1f\n\n$LCT$\u543c\u554a\uff0c\u597d\u5199\u53c8\u597d\u8c03\uff0c\u8fd8\u77ed\u3002\n\n\u6ce8\u610f\u51e0\u4e2a\u8fb9\u754c\u6761\u4ef6\uff0c\u6bd4\u5982\u521d\u59cb\u5316\u65f6\u6240\u6709\u8282\u70b9\u7684\u503c\u548c\u6700\u5927\u503c\u90fd\u8981\u521d\u59cb\u5316\u4e3a$-inf$\n\n\u7136\u540e\u8fb9\u62c6\u70b9\uff0c\u8fb9\u6743\u8f6c\u70b9\u6743\uff0c\u6ce8\u610f\u4fee\u6539\u6807\u8bb0\u53ef\u4ee5\u8986\u76d6\u6389\u52a0\u6cd5\u6807\u8bb0\u3002\n\n\u7136\u540e\u8fd9\u9898\u5c31\u6ca1\u4e86\n\n\u8d85\u77ed\u4ee3\u7801\uff08\u5c31100\u884c\uff09\uff1a\n\n```cpp\n#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define inl inline\n#define re register int\n#define ll long long\n#define fa(x) t[x].fa\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define lowbit(x) ((x) & (-x))\nconst int inf = 0x7fffffff;\nusing namespace std;\ntemplate < class Read >\ninl Read read(void) {\n\tRead x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\n#pragma endregion\nstruct node {\n\tint fa, child[2], w, ma, add, modify;//ma \u6700\u5927\u503c add \u52a0\u6cd5\u6807\u8bb0 modify \u4fee\u6539\u6807\u8bb0\n\tbool filp;\n\tnode() :w(-inf), ma(-inf) {}//\u521d\u59cb\u5316\n}t[1000001];\nint n;\ninl void maintain(int x) { t[x].ma = max(max(t[ls(x)].ma, t[rs(x)].ma), t[x].w); }\ninl bool poi(int x) { return rs(fa(x)) == x; }\ninl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }\ninl void rotate(int x) {\n\tre f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];\n\tif (nroot(f))t[gf].child[gfs] = x;\n\tt[f].child[fs] = s, t[x].child[fs ^ 1] = f;\n\tif (s)fa(s) = f;\n\tfa(f) = x, fa(x) = gf;\n\tmaintain(f);\n}\ninl void change(int x, int w) { if (x > n)t[x].w = w; t[x].ma = w, t[x].add = 0, t[x].modify = w; }\ninl void sum(int x, int w) { if (x > n)t[x].w += w; t[x].ma += w, t[x].add += w; }\ninl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }\ninl void pushdown(int x) {\n\tif (t[x].modify) {\n\t\tif (ls(x))change(ls(x), t[x].modify);\n\t\tif (rs(x))change(rs(x), t[x].modify);\n\t\tt[x].modify = 0;\n\t}\n\tif (t[x].add) {\n\t\tif (ls(x))sum(ls(x), t[x].add);\n\t\tif (rs(x))sum(rs(x), t[x].add);\n\t\tt[x].add = 0;\n\t}\n\tif (t[x].filp) {\n\t\tif (ls(x))reverse(ls(x));\n\t\tif (rs(x))reverse(rs(x));\n\t\tt[x].filp = 0;\n\t}\n}\ninl void push(int x) { if (nroot(x))push(fa(x)); pushdown(x); }\ninl void splay(int x) { push(x); while (nroot(x)) { if (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x); rotate(x); }maintain(x); }\ninl void access(int x) { for (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, maintain(x); }\ninl void makeroot(int x) { access(x), splay(x), reverse(x); }\ninl void split(int x, int y) { makeroot(y), access(x), splay(x); }\ninl void link(int x, int y) { split(x, y); fa(y) = x; }\ninl short spread() {\n\tregister char c = getchar();\n\twhile (c != 'C'&&c != 'A'&&c != 'M'&&c != 'S')c = getchar();\n\tif (c == 'S')exit(0);\n\tif (c != 'C')return c == 'A';\n\telse c = getchar();\n\treturn c == 'o' ? 2 : 3;\n}\nsigned main() {\n\tn = read<int>();\n\tre x, y, op;\n\tfor (re i = 1; i < n; i++) { x = read<int>(), y = read<int>(), t[i + n].w = read<int>(), link(x, i + n), link(y, i + n); }\n\twhile (1) {\n\t\top = spread(), x = read<int>(), y = read<int>();\n\t\tif (!op) split(x, y), printf(\"%d\\n\", t[x].ma);\n\t\telse if (op == 1) split(x, y), sum(x, read<int>());\n\t\telse if (op == 2) split(x, y), change(x, read<int>());\n\t\telse access(x + n), splay(x + n), t[x + n].w = y;\n\t}\n}\n```\n\n",
        "postTime": 1554115805,
        "uid": 110271,
        "name": "Genius_Z",
        "ccfLevel": 0,
        "title": "P4315 \u6708\u4e0b\u6bdb\u666f\u6811 LCT"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u6ca1\u7684\u8bf4\u3002\u3002\u3002\n\n\u7136\u800c\u8c03\u4e86\u6211\u4e00\u8282\u8bfe+20min\u3002\u3002\u3002\n\n\u7ebf\u6bb5\u6811\u6211\u7528\u4e86\u5b8f\u5b9a\u4e49\uff0c\u8fd9\u662f\u4e00\u4e2a\u597d\u4e1c\u897f\u554a\uff01\u4e3a\u4ec0\u4e48\u6ca1\u6709\u591a\u5c11\u4eba\u7528\uff1f\uff1f\uff1f\n\n\u6ce8\u610f\uff1a\n\n1. pushdown \u65f6\u5148\u4e0b\u4f20\u533a\u95f4\u4fee\u6539\u6807\u8bb0\uff0c\u5e76\u628a\u5de6\u53f3\u513f\u5b50\u7684\u533a\u95f4\u52a0\u6807\u8bb0\u6539\u4e3a0\uff0c\u5728\u4e0b\u4f20\u533a\u95f4\u52a0\u6807\u8bb0\u3002\n\n2. \u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\u65f6\u8bb0\u5f97\u628a\u533a\u95f4\u52a0\u6807\u8bb0\u6e050\uff08\u5751\u70b9\uff09\uff01\n\n3. \u8fb9\u6743\u8f6c\u6210\u70b9\u6743\u3002\u5c06\u5417\uff0c\u6bcf\u6761\u8fb9\u7684\u6743\u503c\u653e\u5230\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9\u4e0a\u3002\n\n4. \u6700\u540e\u8df3\u94fe\u8df3\u5b8c\uff0c\u5de6\u533a\u95f4\u8981\u52a01\uff01\n\n\u9644\u4ee3\u7801\uff1a\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define LSON rt<<1//\u4ee5\u4e0b\u4e3a\u5b8f\u5b9a\u4e49\n#define RSON rt<<1|1\n#define DATA(x) b[x].data\n#define SIGN1(x) b[x].c\n#define SIGN2(x) b[x].d\n#define LSIDE(x) b[x].l\n#define RSIDE(x) b[x].r\n#define MAXN 100010\nusing namespace std;\nint n,c=1,d=1;\nint head[MAXN],deep[MAXN],size[MAXN],son[MAXN],fa[MAXN],top[MAXN],id[MAXN];\nstruct node1{/\u524d\u5411\u661f\n    int next,to,w;\n}a[MAXN<<1];\nstruct node2{//\u7ebf\u6bb5\u6811\n    int data,c,d,l,r;\n}b[MAXN<<2];\nstruct node3{//\u8fb9\n    int u,v,w;\n}g[MAXN];\ninline int read(){//\u8bfb\u4f18\n    int date=0,w=1;char c=0;\n    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}\n    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}\n    return date*w;\n}\ninline int max(const int &x,const int &y){return x>y?x:y;}//STL\u4e0d\u9760\u8c31\uff0c\u4e8e\u662f\u624b\u5199\ninline void add(int u,int v,int w){//\u52a0\u8fb9\n    a[c].to=v,a[c].w=w;a[c].next=head[u];head[u]=c++;\n    a[c].to=u;a[c].w=w;a[c].next=head[v];head[v]=c++;\n}\nvoid dfs1(int rt){//\u6811\u5256\u4e24\u4e2a dfs\n    son[rt]=0;size[rt]=1;\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(!deep[will]){\n            deep[will]=deep[rt]+1;\n            fa[will]=rt;\n            dfs1(will);\n            size[rt]+=size[will];\n            if(size[son[rt]]<size[will])son[rt]=will;\n        }\n    }\n}\nvoid dfs2(int rt,int f){\n    id[rt]=d++;top[rt]=f;\n    if(son[rt])dfs2(son[rt],f);\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(will!=fa[rt]&&will!=son[rt])\n        dfs2(will,will);\n    }\n}\ninline void pushup(int rt){//\u4e0a\u4f20\n    DATA(rt)=max(DATA(LSON),DATA(RSON));\n}\ninline void pushdown(int rt){//\u6807\u8bb0\u4e0b\u4f20\n    if(LSIDE(rt)==RSIDE(rt))return;\n    if(SIGN1(rt)!=-1){\n    \tSIGN1(LSON)=DATA(LSON)=SIGN1(rt);\n    \tSIGN1(RSON)=DATA(RSON)=SIGN1(rt);\n    \tSIGN1(rt)=-1;\n\t\tSIGN2(LSON)=SIGN2(RSON)=0;//\u8bb0\u5f97\u8d4b0\uff01\n    }\n    if(SIGN2(rt)){\n    \tSIGN2(LSON)+=SIGN2(rt);DATA(LSON)+=SIGN2(rt);\n    \tSIGN2(RSON)+=SIGN2(rt);DATA(RSON)+=SIGN2(rt);\n    \tSIGN2(rt)=0;\n    }\n}\nvoid buildtree(int l,int r,int rt){//\u5efa\u6811\n    int mid;\n    LSIDE(rt)=l;\n    RSIDE(rt)=r;\n    SIGN1(rt)=-1;//\u521d\u59cb\u503c\u4e3a-1\n    if(l==r){\n        DATA(rt)=0;\n        return;\n    }\n    mid=l+r>>1;\n    buildtree(l,mid,LSON);\n    buildtree(mid+1,r,RSON);\n    pushup(rt);\n}\nvoid update_one(int l,int r,int c,int rt){//\u533a\u95f4\u4fee\u6539\n    int mid;\n    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){\n        SIGN1(rt)=DATA(rt)=c;\n        SIGN2(rt)=0;//\u533a\u95f4\u52a0\u6807\u8bb0\u6e050\n        return;\n    }\n    pushdown(rt);\n    mid=LSIDE(rt)+RSIDE(rt)>>1;\n    if(l<=mid)update_one(l,r,c,LSON);\n    if(mid<r)update_one(l,r,c,RSON);\n    pushup(rt);\n}\nvoid update_two(int l,int r,int c,int rt){//\u533a\u95f4\u52a0\n    int mid;\n    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){\n        SIGN2(rt)+=c;DATA(rt)+=c;//\u76f4\u63a5\u4fee\u6539\u6807\u8bb0\n        return;\n    }\n    pushdown(rt);\n    mid=LSIDE(rt)+RSIDE(rt)>>1;\n    if(l<=mid)update_two(l,r,c,LSON);\n    if(mid<r)update_two(l,r,c,RSON);\n    pushup(rt);\n}\nint query(int l,int r,int rt){//\u6c42\u6700\u5927\u503c\n\tint mid,ans=0;\n\tif(l<=LSIDE(rt)&&RSIDE(rt)<=r)return DATA(rt);\n\tpushdown(rt);\n\tmid=LSIDE(rt)+RSIDE(rt)>>1;\n\tif(l<=mid)ans=max(ans,query(l,r,LSON));\n\tif(mid<r)ans=max(ans,query(l,r,RSON));\n\treturn ans;\n}\nvoid work1(int x,int y,int k){//\u6811\u4e0a\u533a\u95f4\u4fee\u6539\n\twhile(top[x]!=top[y]){\n\t\tif(deep[top[x]]<deep[top[y]])swap(x,y);\n\t\tupdate_one(id[top[x]],id[x],k,1);\n\t\tx=fa[top[x]];\n\t}\n\tif(deep[x]>deep[y])swap(x,y);\n\tif(x!=y)update_one(id[x]+1,id[y],k,1);//\u5de6\u533a\u95f4+1\uff01\n\treturn;\n}\nvoid work2(int x,int y,int k){//\u6811\u4e0a\u533a\u95f4\u52a0\n\twhile(top[x]!=top[y]){\n\t\tif(deep[top[x]]<deep[top[y]])swap(x,y);\n\t\tupdate_two(id[top[x]],id[x],k,1);\n\t\tx=fa[top[x]];\n\t}\n\tif(deep[x]>deep[y])swap(x,y);\n\tif(x!=y)update_two(id[x]+1,id[y],k,1);\n\treturn;\n}\nvoid work3(int x,int y){//\u6811\u4e0a\u6700\u503c\n\tint s=0;\n\twhile(top[x]!=top[y]){\n\t\tif(deep[top[x]]<deep[top[y]])swap(x,y);\n\t\ts=max(s,query(id[top[x]],id[x],1));\n\t\tx=fa[top[x]];\n\t}\n\tif(deep[x]>deep[y])swap(x,y);\n\tif(x!=y)s=max(s,query(id[x]+1,id[y],1));\n\tprintf(\"%d\\n\",s);\n\treturn;\n}\nvoid work(){\n\tchar ch[10];\n\tint x,y,k;\n\twhile(1){//\u76f4\u63a5\u5faa\u73af\n\t\tscanf(\"%s\",ch);\n\t\tif(ch[0]=='S')break;\n\t\tx=read();y=read();\n\t\tswitch(ch[0]){//\u5206\u7c7b\n\t\t\tcase 'C':{\n\t\t\t\tif(ch[1]=='h'){\n\t\t\t\t\tg[x].w=y;\n\t\t\t\t\tupdate_one(id[g[x].v],id[g[x].v],y,1);\n\t\t\t\t}\n\t\t\t\tif(ch[1]=='o'){\n\t\t\t\t\tk=read();\n\t\t\t\t\twork1(x,y,k);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'A':{\n\t\t\t\tk=read();\n\t\t\t\twork2(x,y,k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'M':{\n\t\t\t\twork3(x,y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid init(){//\u8bfb\u5165+\u9884\u5904\u7406\n    n=read();\n    for(int i=1;i<n;i++){\n        g[i].u=read();g[i].v=read();g[i].w=read();\n        add(g[i].u,g[i].v,g[i].w);\n    }\n    deep[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    buildtree(1,n,1);\n    for(int i=1;i<n;i++){//\u8fb9\u6743\u8f6c\u70b9\u6743\n        if(deep[g[i].u]>deep[g[i].v])swap(g[i].u,g[i].v);\n        update_one(id[g[i].v],id[g[i].v],g[i].w,1);\n    }\n}\nint main(){//\u4e3b\u51fd\u6570\n    init();\n    work();\n    return 0;\n}\n\n```",
        "postTime": 1521708140,
        "uid": 49998,
        "name": "\u65af\u5fb7\u54e5\u5c14\u6469",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u6811\u5256\u7ef4\u62a4\u8fb9\u6743\u88f8\u9898\u3002\n\n\u7ebf\u6bb5\u6811\u4e2d\u7ef4\u62a4\u533a\u95f4\u8986\u76d6\u3001\u533a\u95f4\u4fee\u6539\u4ee5\u53ca\u533a\u95f4\u6700\u5927\u503c\u5373\u53ef\u3002\n\n\u4ee3\u7801\n```cpp\n#include<bits/stdc++.h>\n#define N 100005\n#define M N*2\nusing namespace std;\nint head[N],to[M],Next[M],len[M],e,n;\nvoid buid(int u,int v,int l)\n{\n\tNext[++e]=head[u];head[u]=e;to[e]=v;len[e]=l;\n}\nint eid[N],val[N];\nint siz[N],dep[N],wson[N],fa[N];\nvoid dfs(int now)\n{\n\tdep[now]=dep[fa[now]]+1;\n\tsiz[now]=1;\n\tfor(int i=head[now];i;i=Next[i])\n\t{\n\t\tint j=to[i];if(j==fa[now]) continue;\n\t\tfa[j]=now;eid[(i+1)/2]=j;val[j]=len[i];\n\t\tdfs(j);\n\t\tsiz[now]+=siz[j];\n\t\tif(siz[j]>siz[wson[now]]) wson[now]=j;\n\t}\n}\nint id[N],who[N],knt,top[N];\nvoid dfs(int now,int fl)\n{\n\ttop[now]=fl;\n\tid[now]=++knt;who[knt]=now;\n\tif(!wson[now]) return;\n\tdfs(wson[now],fl);\n\tfor(int i=head[now];i;i=Next[i])\n\t{\n\t\tint j=to[i];if(j==fa[now]||j==wson[now]) continue;\n\t\tdfs(j,j);\n\t}\n}\nstruct node\n{\n\tint big;\n\tint co,la;\n\tvoid clear()\n\t{\n\t\tco=-1;la=0;\n\t}\n}tre[N*4];\nvoid push(int x,int y)\n{\n\tif(tre[x].co!=-1) tre[y].la=0,tre[y].co=tre[y].big=tre[x].co;\n\tif(tre[x].la) tre[y].la+=tre[x].la,tre[y].big+=tre[x].la;\n}\nvoid down(int now,int lson,int rson)\n{\n\tpush(now,lson);\n\tpush(now,rson);tre[now].clear();\n}\nvoid update(int now,int lson,int rson)\n{\n\ttre[now].big=max(tre[lson].big,tre[rson].big);\n}\nvoid change(int u,int v,int l,int r,int now)\n{\n\tif(u>v) return;\n\tif(u<=l&&v>=r) return push(0,now);\n\tint mid=(l+r)>>1,lson=now<<1,rson=lson|1;\n\tdown(now,lson,rson);\n\tif(v<=mid) change(u,v,l,mid,lson);\n\telse if(u>mid) change(u,v,mid+1,r,rson);\n\telse change(u,mid,l,mid,lson),change(mid+1,v,mid+1,r,rson);\n\tupdate(now,lson,rson);\n}\nint ask(int u,int v,int l,int r,int now)\n{\n\tif(u>v) return -(1<<30);\n\tif(u<=l&&v>=r) \treturn tre[now].big;\n\tint mid=(l+r)>>1,lson=now<<1,rson=lson|1;\n\tdown(now,lson,rson);\n\tif(v<=mid) return ask(u,v,l,mid,lson);\n\telse if(u>mid) return ask(u,v,mid+1,r,rson);\n\telse return max(ask(u,mid,l,mid,lson),ask(mid+1,v,mid+1,r,rson));\n}\nvoid buid_t(int l,int r,int now)\n{\n\tif(l==r)\n\t{\n\t\ttre[now].big=val[who[l]];tre[now].clear();\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1,lson=now<<1,rson=lson|1;\n\tbuid_t(l,mid,lson);mid++;buid_t(mid,r,rson);\n\tupdate(now,lson,rson);tre[now].clear();\n}\nvoid Add()\n{\n\tint u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n\ttre[0].clear();tre[0].la=w;\n\tint tu=top[u],tv=top[v];\n\twhile(tu!=tv)\n\t{\n\t\tif(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);\n\t\tchange(id[tu],id[u],1,n,1);\n\t\tu=fa[tu],tu=top[u];\n\t}\n\tif(dep[u]<dep[v]) swap(u,v);\n\tchange(id[v]+1,id[u],1,n,1);\n}\nvoid Max()\n{\n\tint u,v;scanf(\"%d%d\",&u,&v);\n\tint ans=-(1<<30),tu=top[u],tv=top[v];\n\twhile(tu!=tv)\n\t{\n\t\tif(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);\n\t\tans=max(ans,ask(id[tu],id[u],1,n,1));\n\t\tu=fa[tu],tu=top[u];\n\t}\n\tif(dep[u]<dep[v]) swap(u,v);\n\tans=max(ans,ask(id[v]+1,id[u],1,n,1));\n\tprintf(\"%d\\n\",ans);\n}\nvoid Change()\n{\n\tint k,w;scanf(\"%d%d\",&k,&w);\n\ttre[0].clear();tre[0].co=w;\n\tchange(id[eid[k]],id[eid[k]],1,n,1);\n}\nvoid Cover()\n{\n\tint u,v,w;scanf(\"%d%d%d\",&u,&v,&w);\n\ttre[0].clear();tre[0].co=w;\n\tint tu=top[u],tv=top[v];\n\twhile(tu!=tv)\n\t{\n\t\tif(dep[tu]<dep[tv]) swap(tu,tv),swap(u,v);\n\t\tchange(id[tu],id[u],1,n,1);\n\t\tu=fa[tu],tu=top[u];\n\t}\n\tif(dep[u]<dep[v]) swap(u,v);\n\tchange(id[v]+1,id[u],1,n,1);\n}\nchar fl[10];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint u,v,l;scanf(\"%d%d%d\",&u,&v,&l);\n\t\tbuid(u,v,l);buid(v,u,l);\n\t}\n\tdfs(1);dfs(1,1);\n\tbuid_t(1,n,1);\t\n\twhile(\"MloVtry is Handsome!\")\n\t{\n\t\tscanf(\"%s\",fl);\n\t\tif(fl[0]=='S') return 0;\n\t\tif(fl[0]=='A') Add();\n\t\telse if(fl[0]=='M') Max();\n\t\telse if(fl[1]=='h') Change();\n\t\telse Cover();\n\t}\n}\n```",
        "postTime": 1520814967,
        "uid": 35718,
        "name": "MloVtry",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u88f8\u9898\uff08\u540c\u65f6\u4e5f\u662f\u4e00\u9053\u953b\u70bc\u7801\u529b\u7684\u597d\u9898\uff09\u6211\u6253\u4e86184\u884c\u2026\u2026\uff08\u6ca1\u52a0\u6ce8\u91ca\uff09\n\n\u53ea\u9700\u5c06\u6bcf\u6761\u53d8\u7684\u8fb9\u6743\u653e\u5230\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u5f53\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u5373\u53ef\uff0c\u4f46\u662f\u90a3\u4e48\u5728\u8def\u5f84\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u6700\u540e\u8981\u628a\u5de6\u7aef\u70b9+1\uff0c\u56e0\u4e3a\u7236\u4eb2\u8282\u70b9\u5b58\u7684\u662f\u5b83\u548c\u5b83\u7236\u4eb2\u8fb9\u7684\u8fb9\u6743\n\n\u7136\u540e\u5c31\u662f\u7ebf\u6bb5\u6811\u4e24\u4e2a\u6807\u8bb0\uff1a\u52a0\u548c\u6539\uff0c\u5176\u4ed6\u7684\u5c31\u662f\u6811\u94fe\u5256\u5206\u6a21\u7248\u64cd\u4f5c\u5566\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define countt(x) (tree[x].r-tree[x].l+1)\n#define LL long long\nusing namespace std;\nconst int MAXX=100005,INF=0x3f3f3f3f;\nint read()\n{\n   int s=0,bj=0;\n   char ch=getchar();\n   while(ch<'0'||ch>'9')bj|=(ch=='-'),ch=getchar();\n   while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n   return bj?-s:s;\n}\nvoid printnum(int x)\n{\n\tif(x>9)printnum(x/10);\n\tputchar(x%10^48);\n}\nvoid print(int x,char ch)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tprintnum(x);putchar(ch);\n}\nint n,m; \nint dep[MAXX],size[MAXX],prt[MAXX],son[MAXX],top[MAXX],cnt,tid[MAXX],v[MAXX];\nint rk[MAXX];\nstruct edge{int nx,to;}w[MAXX<<1];int h[MAXX],edge_cnt;\nvoid AddEdge(int x,int y){w[++edge_cnt].to=y;w[edge_cnt].nx=h[x];h[x]=edge_cnt;}\n//\u7ebf\u6bb5\u6811 \nstruct node{int l,r,maxx,add,bj;}tree[MAXX<<2];\nvoid pushup(int k){tree[k].maxx=max(tree[k<<1].maxx,tree[k<<1|1].maxx);}\nvoid pushdown(int k)\n{\n\tif(tree[k].bj!=-1)\n\t{\n\t\ttree[k<<1].add=tree[k<<1|1].add=0;//\u4fee\u6539\u540e\u52a0\u7684\u5ef6\u8fdf\u6807\u8bb0\u8981\u6e05\u96f6 \n\t\ttree[k<<1].bj=tree[k<<1|1].bj=tree[k<<1].maxx=tree[k<<1|1].maxx=tree[k].bj;\n\t\ttree[k].bj=-1;\n\t}\n\tif(tree[k].add)\n\t{\n\t\ttree[k<<1].add+=tree[k].add;tree[k<<1|1].add+=tree[k].add;\n\t\ttree[k<<1].maxx+=tree[k].add;tree[k<<1|1].maxx+=tree[k].add;\n\t\ttree[k].add=0;\n\t}\n}\nvoid Build(int k,int l,int r)//\u5efa\u6811 \n{\n\ttree[k].l=l;tree[k].r=r;tree[k].bj=-1;\n\tif(l==r){tree[k].maxx=v[rk[l]];return;}\n\tint mid=(l+r)>>1;\n\tBuild(k<<1,l,mid);Build(k<<1|1,mid+1,r);pushup(k);\n}\nvoid Add(int k,int l,int r,int d)//\u52a0 \n{\n\tif(l>tree[k].r||r<tree[k].l)return;\n\tif(l<=tree[k].l&&r>=tree[k].r)\n\t{\n\t\ttree[k].add+=d;\n\t\ttree[k].maxx+=d;\n\t\treturn;\n\t}\n\tpushdown(k);\n\tAdd(k<<1,l,r,d);Add(k<<1|1,l,r,d);\n\tpushup(k);\n}\nvoid Cover(int k,int l,int r,int d)//\u4fee\u6539 \n{\n\tif(l>tree[k].r||r<tree[k].l)return;\n\tif(l<=tree[k].l&&r>=tree[k].r)\n\t{\n\t\ttree[k].bj=tree[k].maxx=d;\n\t\ttree[k].add=0;//\u6ce8\u610f\u4fee\u6539\u64cd\u4f5c\u4f18\u5148\u7ea7\u6bd4\u52a0\u9ad8\uff0c\u6240\u4ee5\u6e05\u96f6\u52a0\u7684\u5ef6\u8fdf\u6807\u8bb0 \n\t\treturn;\n\t}\n\tpushdown(k);\n\tCover(k<<1,l,r,d);Cover(k<<1|1,l,r,d);\n\tpushup(k);\n}\nint Ask(int k,int l,int r)//\u6700\u5927\u503c \n{\n\tif(l>tree[k].r||r<tree[k].l)return -INF;\n\tif(l<=tree[k].l&&r>=tree[k].r)return tree[k].maxx;\n\tpushdown(k);\n\treturn max(Ask(k<<1,l,r),Ask(k<<1|1,l,r));\n}\n//end\n//\u6811\u94fe\u5256\u5206\u6a21\u7248\nvoid DFS1(int x,int fa,int depth) \n{\n\tdep[x]=depth;prt[x]=fa;size[x]=1;\n\tfor(int i=h[x];i;i=w[i].nx)\n\t{\n\t\tint y=w[i].to;\n\t\tif(y^fa)\n\t\t{\n\t\t\tDFS1(y,x,depth+1);\n\t\t\tsize[x]+=size[y];\n\t\t\tif(size[son[x]]<size[y])son[x]=y;\n\t\t}\n\t}\n}\nvoid DFS2(int x,int topp)\n{\n\ttop[x]=topp;tid[x]=++cnt;\n\trk[cnt]=x;\n\tif(!son[x])return;\n\tDFS2(son[x],topp);\n\tfor(int i=h[x];i;i=w[i].nx)\n\t{\n\t\tint y=w[i].to;\n\t\tif((y^son[x])&&(y^prt[x]))DFS2(y,y);\n\t} \n}\n//end\nvoid Add_Edge(int x,int y,int z)//\u52a0\u8def\u5f84 \n{\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tAdd(1,tid[top[x]],tid[x],z);\n\t\tx=prt[top[x]];\n\t}\n\tif(x==y)return;\n\tif(dep[x]>dep[y])swap(x,y);\n\tAdd(1,tid[x]+1,tid[y],z);\n}\nvoid Cover_Edge(int x,int y,int z)//\u6539\u8def\u5f84 \n{\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tCover(1,tid[top[x]],tid[x],z);\n\t\tx=prt[top[x]];\n\t}\n\tif(x==y)return;\n\tif(dep[x]>dep[y])swap(x,y);\n\tCover(1,tid[x]+1,tid[y],z);\n}\nint Ask_Edge(int x,int y)//\u67e5\u8be2\u8def\u5f84\u6700\u5927\u503c \n{\n\tint ans=-INF;\n\twhile(top[x]^top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=max(ans,Ask(1,tid[top[x]],tid[x]));\n\t\tx=prt[top[x]];\n\t}\n\tif(x==y)return ans;\n\tif(dep[x]>dep[y])swap(x,y);\n\treturn max(ans,Ask(1,tid[x]+1,tid[y]));\n}\nint a[MAXX],b[MAXX],c[MAXX];\nint x,y,z;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\ta[i]=read();b[i]=read();c[i]=read();\n\t\tAddEdge(a[i],b[i]);AddEdge(b[i],a[i]);\n\t}\n\tDFS1(1,0,1);\n\tDFS2(1,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(dep[a[i]]>dep[b[i]])swap(a[i],b[i]);//\u5c06\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\u653e\u5728b\u6570\u7ec4\u91cc\u9762\u5c06\n\t\tv[b[i]]=c[i];//\u8fb9\u6743\u5b58\u5728\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\u91cc\u9762 \n\t}\n\tBuild(1,1,n);\n\twhile(1) //\u6839\u636e\u9898\u610f\u64cd\u4f5c\u5373\u53ef \n\t{\n\t\tchar ch[10];\n\t\tscanf(\"%s\",ch);\n\t\tif(ch[0]=='S')break;\n\t\tx=read();y=read();\n\t\tif(ch[0]=='M')print(Ask_Edge(x,y),'\\n');\n\t\telse if(ch[1]=='o'){z=read();Cover_Edge(x,y,z);}\n\t\telse if(ch[0]=='A'){z=read();Add_Edge(x,y,z);}\n\t\telse Cover(1,tid[b[x]],tid[b[x]],y);//\u56e0\u4e3a\u4e4b\u524d\u5b58\u4e86\u6bcf\u6761\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\uff0c\u76f4\u63a5\u6539\u5373\u53ef\uff08\u61d2\u5f97\u6253\u5355\u4fee\u4e86\u2026\u2026\uff09 \n\t}\n\treturn 0;\n}\n```\n\u795d\u5927\u5bb6\u4e00\u904dA\u4e86\u5b83\uff0c~~\u62115\u904d\u2026\u2026~~\n",
        "postTime": 1568537989,
        "uid": 42019,
        "name": "wubaiting2020",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "[$$\\color{#0e90d2}\\huge{\\texttt{my blog}}$$](https://wxwoo.github.io/2019/09/09/solution-p4315)\n\n******\n\n[\u539f\u9898\u76ee\u94fe\u63a5](https://www.luogu.org/problem/P4315)\n\n\u9996\u5148\u6811\u5256\u8fb9\u6743\u8f6c\u70b9\u6743\uff0c\u628a\u6bcf\u4e00\u6761\u8fb9\u7684\u6743\u503c\u4e0b\u653e\u5230\u5b50\u8282\u70b9\u4e0a\n\n\u5728\u4fee\u6539\u7684\u65f6\u5019\u6ce8\u610f\u6700\u540e\u8981\u907f\u5f00\u4e24\u4e2a\u70b9\u7684LCA\uff0c\u56e0\u4e3aLCA\u7684\u70b9\u6743\u6240\u4ee3\u8868\u7684\u8fb9\u6743\u4e0d\u5728\u4e24\u4e2a\u70b9\u7684\u8def\u5f84\u4e0a\n\n\u7136\u540e\u770b\u89c1\u533a\u95f4\u63a8\u5e73\u5c31\u60f3\u5230\u4e86ODT\n\nODT\u6bd4\u7ebf\u6bb5\u6811\u77ed\uff0c\u597d\u5199\uff0c\u7ec6\u8282\u8fd8\u6bd4\u7ebf\u6bb5\u6811\u5c11\n\n\u4f46\u662f\u4e0d\u4fdd\u8bc1\u6570\u636e\u968f\u673a\uff0cODT\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6ca1\u6709\u4fdd\u8bc1\n\n~~\u6700\u540e\u5199\u51fa\u6765\u8dd1\u4e866s\uff0c\u88abLCT\u548c\u6811\u5256+\u7ebf\u6bb5\u6811\u540a\u6253~~\n\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<set>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntemplate<typename T>\ninline void read(T &x)\n{\n\tint ch=getchar();\n\tT f=1;\n\tx=0;\n\twhile(!('0'<=ch&&ch<='9'))\n\t{\n\t\tif(ch=='-')\n\t\t\tf=-1;\n\t\tch=getchar();\n\t}\n\twhile('0'<=ch&&ch<='9')\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-48;\n\t\tch=getchar();\n\t}\n\tx*=f;\n}\n#define setit set<node>::iterator\nconst int N=100010;\nstruct node\n{\n\tint l,r;\n\tmutable int val;\n\tnode(int L,int R=-1,int V=0):l(L),r(R),val(V){}\n\tfriend inline bool operator<(const node &a,const node &b)\n\t{\n\t\treturn a.l<b.l;\n\t}\n};\nset<node>s;\nint n;\nint u[N],v[N],head[N],nxt[N<<1],to[N<<1],val[N<<1],e;\ninline void addedge(const int &u,const int &v,const int &w)\n{\n\tto[++e]=v;\n\tval[e]=w;\n\tnxt[e]=head[u];\n\thead[u]=e;\n}\nint fa[N],son[N],dep[N],sz[N],w[N],top[N],id[N],seq[N],cnt;\nchar str[10];\ninline setit split(const int &x)\n{\n\tsetit it=s.lower_bound(node(x));\n\tif(it!=s.end()&&it->l==x)\n\t\treturn it;\n\t--it;\n\tint l=it->l,r=it->r,val=it->val;\n\ts.erase(it);\n\ts.insert(node(l,x-1,val));\n\treturn s.insert(node(x,r,val)).first;\n}\ninline void assign(const int &l,const int &r,const int &k)\n{\n\tsetit itr=split(r+1),itl=split(l);\n\ts.erase(itl,itr);\n\ts.insert(node(l,r,k));\n}\ninline void add(const int &l,const int &r,const int &k)\n{\n\tsetit itr=split(r+1),itl=split(l);\n\tfor(;itl!=itr;++itl)\n\t\titl->val+=k;\n}\ninline int query(const int &l,const int &r)\n{\n\tint ans=0;\n\tsetit itr=split(r+1),itl=split(l);\n\tfor(;itl!=itr;++itl)\n\t\tans=max(ans,itl->val);\n\treturn ans;\n}\nvoid dfs1(const int &x,const int &f,const int &d)\n{\n\tfa[x]=f;\n\tdep[x]=d;\n\tsz[x]=1;\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(y==f)\n\t\t\tcontinue;\n\t\tdfs1(y,x,d+1);\n\t\tw[y]=val[i];\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>sz[son[x]])\n\t\t\tson[x]=y;\n\t}\n}\nvoid dfs2(const int &x,const int &t)\n{\n\ttop[x]=t;\n\tid[x]=++cnt;\n\tseq[cnt]=x;\n\tif(!son[x])\n\t\treturn;\n\tdfs2(son[x],t);\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(y==son[x]||y==fa[x])\n\t\t\tcontinue;\n\t\tdfs2(y,y);\n\t}\n}\ninline void addchain(int x,int y,const int &k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tadd(id[top[x]],id[x],k);\n\t\tx=fa[top[x]];\n\t}\n\tif(x==y)\n\t\treturn;\n\tif(dep[x]>dep[y])\n\t\tswap(x,y);\n\tadd(id[x]+1,id[y],k);\n}\ninline void covchain(int x,int y,const int &k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tassign(id[top[x]],id[x],k);\n\t\tx=fa[top[x]];\n\t}\n\tif(x==y)\n\t\treturn;\n\tif(dep[x]>dep[y])\n\t\tswap(x,y);\n\tassign(id[x]+1,id[y],k);\n}\ninline int maxchain(int x,int y)\n{\n\tint res=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tres=max(res,query(id[top[x]],id[x]));\n\t\tx=fa[top[x]];\n\t}\n\tif(x==y)\n\t\treturn res;\n\tif(dep[x]>dep[y])\n\t\tswap(x,y);\n\treturn max(res,query(id[x]+1,id[y]));\n}\ninline void updedge(int u,int v,const int &k)\n{\n\tif(fa[v]==u)\n\t\tswap(u,v);\n\tassign(id[u],id[u],k);\n}\nint main()\n{\n\tread(n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint w;\n\t\tread(u[i]);\n\t\tread(v[i]);\n\t\tread(w);\n\t\taddedge(u[i],v[i],w);\n\t\taddedge(v[i],u[i],w);\n\t}\n\tdfs1(1,1,1);\n\tdfs2(1,1);\n\tfor(int i=2;i<=n;++i)\n\t\ts.insert(node(i,i,w[seq[i]]));\n\tint l,r,k;\n\twhile(1)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tif(str[1]=='t')\n\t\t\tbreak;\n\t\tread(l);\n\t\tread(r);\n\t\tif(str[1]=='a')\n\t\t\tprintf(\"%d\\n\",maxchain(l,r));\n\t\telse if(str[1]=='h')\n\t\t\tupdedge(u[l],v[l],r);\n\t\telse\n\t\t{\n\t\t\tread(k);\n\t\t\tif(str[1]=='o')\n\t\t\t\tcovchain(l,r,k);\n\t\t\telse\n\t\t\t\taddchain(l,r,k);\n\t\t}\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1568033337,
        "uid": 116659,
        "name": "wxwoo",
        "ccfLevel": 6,
        "title": "P4315 \u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d \u9898\u89e3"
    },
    {
        "content": "## **\u9898\u76ee**\n\n[click it!!](https://www.luogu.org/problemnew/show/P4315)\n\n[\u66f4\u597dor\u66f4\u5dee\u7684\u4f53\u9a8c](https://dunko666.github.io/2019/01/26/%E6%9C%88%E4%B8%8B%E2%80%9C%E6%AF%9B%E6%99%AF%E6%A0%91%E2%80%9D/)\n\n## **\u601d\u8def**\n\n\u770b\u5b8c\u9898\u76ee\u4e4b\u540e\uff0c\u5f88\u660e\u663e\u8fd9\u662f\u4e00\u9053\u6811\u5256\u9898\u3002\u4e3a\u4ec0\u4e48\u8fd9\u4e48\u8bf4\u5462\uff1f\n\n1. \u4ed6\u4f1a\u6539\u53d8\u6811\u4e0a\u4e24\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u3002\n2. \u4ed6\u8981\u67e5\u8be2\u6811\u4e0a\u4e24\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u6700\u5927\u8fb9\u3002\n3. \u4ed6\u8981\u6539\u53d8\u67d0\u6761\u8fb9\u7684\u8fb9\u6743\n\n\u4ece\u8fd9\u51e0\u70b9\u6765\u770b\u5c31\u662f\u8bf4\u6211\u4eec\u8981\u5728\u6811\u4e0a\u505a**\u533a\u95f4\u64cd\u4f5c**\uff01\uff01\uff01\n\n\u8fd9\u91cc\u6709\u597d\u591a\u96be\u70b9\uff1a\n\n1. \u8fb9\u6743\u662f\u5f88\u96be\u4f7f\u7528\u7684\uff0c\u4e0d\u5982\u5c06\u5176\u6539\u4e3a**\u70b9\u6743**\n2. \u5982\u4f55\u7528\u6811\u5256\u51fa\u7684\u51e0\u6761\u94fe\u7ec4\u6210\u7684\u5e8f\u5217\u6765\u8fdb\u884c\u5404\u79cd\u64cd\u4f5c\n\n\u8fd9\u91cc\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u6765\u8fdb\u884c\u533a\u95f4\u64cd\u4f5c\uff0c\u5c06\u8fb9\u6743\u6539\u4e3a\u201c\u8fd9\u6761\u8fb9\u7684\u4e00\u4e2a\u7aef\u70b9\u5230\u53e6\u4e00\u4e2a\u7aef\u70b9\u7684\u6240\u82b1\u8d39\u7684\u503c\u201d\uff08\u4e24\u4e2a\u7aef\u70b9\u4e3a\u7236\u5b50\u8282\u70b9\u7684\u5173\u7cfb\uff09\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06\u8fb9\u6743\u5316\u4e3a\u70b9\u6743\u3002\n\n\u6bd4\u5982\uff1a$u \\to v$\u8fd9\u6761\u8fb9\u7684\u503c\u4e3a3\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5b83\u53d8\u4e3ap[v]=3;(\u610f\u601d\u662fv\u5230u\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u4e3a3)\u3002\n\n## **\u4ee3\u7801**\n\n\u5047\u8bbe\u6811\u5256\u4e4b\u540e\u6211\u4eec\u7528in[x]\u8868\u793ax\u8fd9\u4e2a\u70b9\u7684dfs\u5e8f\uff0cid[x]\u8868\u793ax\u8fd9\u4e2a\u7f16\u53f7\u5bf9\u5e94\u7684\u70b9\uff08~~\u672c\u4eba\u82f1\u8bed\u4e0d\u597d\uff0c\u6570\u7ec4\u540d\u778e\u53d6\u7684~~\uff09\n\n\u4e4b\u540e\u6211\u5c31\u76f4\u63a5\u7ed9\u51fa\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\u4ee3\u7801:(~~\u522b\u8bf4\u4f60\u8fde\u7ebf\u6bb5\u6811\u90fd\u4e0d\u61c2\u5c31\u6765\u5b66\u6811\u5256)~~\n\n#### **\u5efa\u6811**\n\n```cpp\nvoid build(int c,int l,int r){\n    lazy[c]=-1;//\u5f53\u7136\u8981\u61d2\u6807\u8bb0\u554a\uff0c\u8fd9\u662f\u521d\u59cb\u5316\n    if(l==r){\n        t[c]=a[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(c<<1,l,mid);\n    build(c<<1|1,mid+1,r);\n    t[c]=max(t[c<<1],t[c<<1|1]);//\u770b\u4e0a\u53bb\u662f\u4e0d\u662f\u597d\u7b80\u5355\u554a\uff0c\u6211\u5c31\u4e0d\u8bf4\u4e86\n}\n```\n\n#### **\u4e0b\u653e\u61d2\u6807\u8bb0**\n\n(\u6ce8\u610f\uff1a\u8fd9\u91cc\u672c\u4eba\u7528\u4e86\u4e24\u4e2a\u61d2\u6807\u8bb0\uff0c\u4e00\u4e2a\u662f\u8986\u76d6\uff08lazy\uff09\uff0c\u4e00\u4e2a\u662f\u52a0\uff08add\uff09)\n\n```cpp\nvoid spread(int c){\n    int ls=c<<1,rs=c<<1|1;//ls\u662f\u5de6\u513f\u5b50\uff0crs\u662f\u53f3\u513f\u5b50\n    if(lazy[c]>=0){//\u5982\u679c\u6709\u8986\u76d6\u6807\u8bb0\uff08\u8986\u76d6\u4f18\u5148\uff09\n        add[ls]=add[rs]=0;//\u4e4b\u524d\u7684add\u5c31\u4e3a0\u4e86\uff0c\u88ab\u8986\u76d6\u4e86\n        t[ls]=t[rs]=lazy[ls]=lazy[rs]=lazy[c];//\u4e0b\u653elazy\uff0c\u5e76\u4fee\u6539\u5b50\u533a\u95f4\u7684\u503c\n        lazy[c]=-1;//\u6e05\u9664\u6807\u8bb0\n    }\n    if(add[c]){//\u8fd9\u592a\u719f\u6089\u4e86\uff0c\u4e0d\u8bf4\u4e86\n        add[ls]+=add[c],add[rs]+=add[c];\n        t[ls]+=add[c],t[rs]+=add[c];\n        add[c]=0;\n    }\n}\n```\n\n#### **\u533a\u95f4\u52a0\u64cd\u4f5c**\n\n```cpp\nvoid change1(int c,int l,int r,int x,int y,int k){\n    if(x<=l&&r<=y){\n        add[c]+=k; t[c]+=k;\n        return;\n    }\n    spread(c);\n    int mid=(l+r)>>1;\n    if(mid>=x) change1(c<<1,l,mid,x,y,k);\n    if(mid<y) change1(c<<1|1,mid+1,r,x,y,k);\n    t[c]=max(t[c<<1],t[c<<1|1]);\n}//\u7b80\u5355\u6613\u61c2\uff0c\u7ebf\u6bb5\u6811\u57fa\u672c\u64cd\u4f5c\n```\n\n#### **\u533a\u95f4\u8986\u76d6**\n\n```cpp\nvoid change2(int c,int l,int r,int x,int y,int k){\n    if(x<=l&&r<=y){\n        t[c]=lazy[c]=k;\n        add[c]=0;\n        return;\n    }\n    spread(c);\n    int mid=(l+r)>>1;\n    if(mid>=x) change2(c<<1,l,mid,x,y,k);\n    if(mid<y) change2(c<<1|1,mid+1,r,x,y,k);\n    t[c]=max(t[c<<1],t[c<<1|1]);\n}//\u4e0d\u8bf4\u4e86...\n```\n\n#### **\u533a\u95f4\u67e5\u8be2\u6700\u503c**\n\n```cpp\nint query(int c,int l,int r,int x,int y){\n    if(x<=l&&r<=y) return t[c];\n    spread(c);\n    int mid=(l+r)>>1,maxx=0;\n    if(mid>=x) maxx=query(c<<1,l,mid,x,y);\n    if(mid<y) maxx=max(maxx,query(c<<1|1,mid+1,r,x,y));\n    return maxx;\n}\n```\n\n#### **\u6811\u4e0a\u67e5\u8be2**\n\n\uff08\u8fd9\u662f\u5728\u6811\u4e0a\u67e5\u8be2\uff0c\u6811\u5256\u7684\u5927\u4f5c\u7528\u5c31\u662f\u8fd9\u4e2a\uff0c**\u4f1a\u8be6\u89e3**\uff09\n\n```cpp\nint ask(int x,int y){\n    int maxx=0;\n    while(top[x]!=top[y]){//\u4e24\u4e2a\u70b9\u5f53\u524d\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u65f6\uff0c\u4e00\u6761\u4e00\u6761\u7684\u8df3\u5230\u540c\u4e00\u91cd\u94fe\u4e3a\u6b62\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);//\u6df1\u5ea6\u6df1\u7684\u5148\u5f80\u4e0a\u8df3\uff08\u6709\u4e00\u70b9LCA\u7684\u610f\u601d\uff09\n        maxx=max(maxx,query(1,1,n,in[top[x]],in[x]));//\u8fd9\u91cc\u8981\u5c06x\u6240\u5728\u8fd9\u6761\u94fe\u4e0a\u7684\u503c\u90fd\u67e5\u8be2\u597d\n        //\u518d\u5c06\u5b83\u4e0e\u6700\u7ec8\u7b54\u6848\u8fdb\u884c\u5bf9\u6bd4\uff0c\u8bb0\u5f55\u7b54\u6848\n        //\u4e3a\u4ec0\u4e48\u7528\u7ebf\u6bb5\u6811\u662f\u653e\u5165\u7684\u662fin[top[x]]\u548cin[x]\u5462\uff1f\u8bf7\u5927\u5bb6\u60f3\u4e00\u60f3\n        //\u5176\u5b9e\u5c31\u662f\u4e4b\u524d\u6211\u4eec\u7528\u6811\u5256\u5c06\u6811\u5316\u4e3a\u4e86\u4e00\u6761\u5e8f\u5217\uff08dfs\u5e8f\uff09\uff0c\u5e8f\u5217\u4e2d\u7684in[top[x]]\u5230in[x]\u5c31\u662f\u6811\n        //\u4e2d\u7684top[x]\u5230x.\n        x=fa[top[x]];//\u8fd9\u4e00\u6761\u94fe\u5df2\u7ecf\u64cd\u4f5c\u5b8c\u4e86\uff0c\u5c31\u8df3\u5230\u4e0a\u4e00\u5c42\u94fe\u4e0a\n    }\n    if(dep[x]>dep[y]) swap(x,y);//\u6700\u540e\u5728\u540c\u4e00\u6761\u94fe\u65f6\u5c06x\u53d8\u4e3a\u6df1\u5ea6\u8f83\u6df1\u7684\u70b9\n    //\u5982\u679c\u5927\u5bb6\u4e0d\u61c2\uff0c\u81ea\u5df1\u53ef\u4ee5\u6a21\u62df\u4e00\u4e0bdfs\u5e8f\u4e2d\u7684x\uff0cy\u70b9\u7684\u7f16\u53f7\n    maxx=max(maxx,query(1,1,n,in[x]+1,in[y]));//\u4e3a\u4ec0\u4e48in[x]\u8981\u52a01\u5462\uff1f\n   // \u56e0\u4e3a\u6211\u4eec\u662f\u8fb9\u6743\u5316\u70b9\u6743\uff0c\u6700\u540e\u4e00\u70b9\u662f\u6211\u4eec\u627e\u5230\u7684\u7236\u8282\u70b9\uff0c\u4f46\u6211\u4eec\u4e00\u76f4\u64cd\u4f5c\u7684\u662f\u5b50\u8282\u70b9\n    //\u82e5\u4e0d\u61c2\uff0c\u8bf7\u5927\u5bb6\u6a21\u62df\u7406\u89e3\u4e00\u4e0b\uff08\u6a21\u62df\u5927\u6cd5\u597d\u554a\uff01\uff01\uff01\uff09\n    return maxx;\n}\n```\n\n#### **\u8fd8\u6709\u4e24\u4e2a\u6811\u4e0a\u4fee\u6539**\n\n\u5927\u5bb6\u7ed3\u5408\u4e0a\u9762\u7684\u4fee\u6539\u770b\u770b\u5427\uff08~~\u8fd9\u4e0d\u662f\u6211\u5077\u61d2\uff01\uff01~~\uff09\n\n```cpp\nvoid DO1(int x,int y,int k){//\u6811\u4e0a\u52a0\u8fb9\u6743\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        change1(1,1,n,in[top[x]],in[x],k);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    change1(1,1,n,in[x]+1,in[y],k);\n}\nvoid DO2(int x,int y,int k){//\u6811\u4e0a\u8986\u76d6\u8fb9\u6743\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        change2(1,1,n,in[top[x]],in[x],k);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    change2(1,1,n,in[x]+1,in[y],k);\n}\n```\n\n\u5c31\u662f\u4ee5\u4e0a\u7684\u51e0\u79cd\u64cd\u4f5c\uff0c\u662f\u4e0d\u662f~~\u597d\u7b80\u5355~~\u5462\uff01\uff01\n\n\u5f53\u7136\uff0c\u4e3a\u4ec0\u4e48\u6211\u6ca1\u5199\u6811\u5256\u8981\u7684\u90a3\u4e24\u4e2aDFS\u5462\uff0c\u56e0\u4e3a\u4e4b\u524d\u6709\u5199\u8fc7\u4e86\n\n[\u8fd9\u662f\u94fe\u63a5](https://dunko666.github.io/2019/01/24/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%88%9D%E8%AF%86/)\n\n**\u8c22\u8c22\u5927\u5bb6\u7684\u9605\u8bfb\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01**\n\n\u4e0b\u9762\u7ed9\u51fa\u5b8c\u6574\u4ee3\u7801\uff1a\n\n#### **\u5b8c\u6574\u4ee3\u7801**\n\n\uff08\u7801\u98ce\u5c31\u4e0d\u8981\u5728\u610f\u4e86\uff09\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nint n,a[maxn],root,head[maxn],cnt,p[maxn];\nint dep[maxn],fa[maxn],siz[maxn],son[maxn];\nint top[maxn],tot,in[maxn];\nint t[maxn<<2],add[maxn<<2],lazy[maxn<<2];\nstruct node{\n    int nxt,to,w;\n}edge[maxn<<2];\nvoid add_edge(int x,int y,int z){\n    edge[++cnt]=(node){head[x],y,z};\n    head[x]=cnt;\n}\nvoid dfs1(int x,int ffa){\n    fa[x]=ffa,siz[x]=1;\n    for(int i=head[x];i;i=edge[i].nxt){\n        int y=edge[i].to;\n        if(y!=ffa){\n            dep[y]=dep[x]+1; p[y]=edge[i].w;\n            dfs1(y,x); siz[x]+=siz[y];\n            if(siz[y]>siz[son[x]]) son[x]=y;\n        }\n    }\n}\nvoid dfs2(int x,int tp){\n    top[x]=tp,in[x]=++tot,a[tot]=p[x];\n    if(son[x]!=0) dfs2(son[x],tp);\n    for(int i=head[x];i;i=edge[i].nxt){\n        int y=edge[i].to;\n        if(y!=fa[x]&&y!=son[x]) dfs2(y,y);\n    }\n}\nvoid build(int c,int l,int r){\n    lazy[c]=-1;\n    if(l==r){\n        t[c]=a[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(c<<1,l,mid);\n    build(c<<1|1,mid+1,r);\n    t[c]=max(t[c<<1],t[c<<1|1]);\n}\nvoid spread(int c){\n    int ls=c<<1,rs=c<<1|1;\n    if(lazy[c]>=0){\n        add[ls]=add[rs]=0;\n        t[ls]=t[rs]=lazy[ls]=lazy[rs]=lazy[c];\n        lazy[c]=-1;\n    }\n    if(add[c]){\n        add[ls]+=add[c],add[rs]+=add[c];\n        t[ls]+=add[c],t[rs]+=add[c];\n        add[c]=0;\n    }\n}\nvoid change1(int c,int l,int r,int x,int y,int k){\n    if(x<=l&&r<=y){\n        add[c]+=k; t[c]+=k;\n        return;\n    }\n    spread(c);\n    int mid=(l+r)>>1;\n    if(mid>=x) change1(c<<1,l,mid,x,y,k);\n    if(mid<y) change1(c<<1|1,mid+1,r,x,y,k);\n    t[c]=max(t[c<<1],t[c<<1|1]);\n}\nvoid change2(int c,int l,int r,int x,int y,int k){\n    if(x<=l&&r<=y){\n        t[c]=lazy[c]=k;\n        add[c]=0;\n        return;\n    }\n    spread(c);\n    int mid=(l+r)>>1;\n    if(mid>=x) change2(c<<1,l,mid,x,y,k);\n    if(mid<y) change2(c<<1|1,mid+1,r,x,y,k);\n    t[c]=max(t[c<<1],t[c<<1|1]);\n}\nint query(int c,int l,int r,int x,int y){\n    if(x<=l&&r<=y) return t[c];\n    spread(c);\n    int mid=(l+r)>>1,maxx=0;\n    if(mid>=x) maxx=query(c<<1,l,mid,x,y);\n    if(mid<y) maxx=max(maxx,query(c<<1|1,mid+1,r,x,y));\n    return maxx;\n}\nint ask(int x,int y){\n    int maxx=0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        maxx=max(maxx,query(1,1,n,in[top[x]],in[x]));\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    maxx=max(maxx,query(1,1,n,in[x]+1,in[y]));\n    return maxx;\n}\nvoid DO1(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        change1(1,1,n,in[top[x]],in[x],k);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    change1(1,1,n,in[x]+1,in[y],k);\n}\nvoid DO2(int x,int y,int k){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        change2(1,1,n,in[top[x]],in[x],k);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    change2(1,1,n,in[x]+1,in[y],k);\n}\nint main(){\n    scanf(\"%d\",&n);\n    int x,y,z;\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d%d\",&x,&y,&z);\n        add_edge(x,y,z),add_edge(y,x,z);\n    }\n    dep[1]=1; dfs1(1,0);\n    dfs2(1,1); build(1,1,n);\n    string s;\n    while(1){\n        cin>>s;\n        if(s==\"Stop\") break;\n        if(s==\"Max\"){\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%d\\n\",ask(x,y));\n        }\n        if(s==\"Add\"){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            DO1(x,y,z);\n        }\n        if(s==\"Change\"){\n            scanf(\"%d%d\",&x,&z);\n            if(dep[edge[x*2-1].to]<dep[edge[x*2].to]) x=edge[x*2].to;\n            else x=edge[x*2-1].to;\n            change2(1,1,n,in[x],in[x],z);\n        }\n        if(s==\"Cover\"){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            DO2(x,y,z);\n        }\n    }\n    return 0;\n}\n```\n\n\n\n## **\u5c0f\u7ed3**\n\n\u8fd9\u4e00\u9898\u4e0d\u96be\uff0c\u5c31\u662f\u4e00\u9053\u6811\u5256\u6a21\u677f\u3002",
        "postTime": 1548472232,
        "uid": 47757,
        "name": "dunko",
        "ccfLevel": 6,
        "title": "\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d"
    },
    {
        "content": "### \u5728\u4e24\u5929\u7684\u8c03\u8bd5\u540e\uff0c\u6211\u7ec8\u4e8ea\u4e86\u8fd9\u9053\u9898\uff0c\u679c\u7136\u8fd8\u662f\u6ca1\u6709\u5b66\u4f1a\u653e\u4e0b\uff0c\u4e0d\u77e5\u9053\u5199\u7684\u4ec0\u4e48\u795e\u4ed9push_down\n#### \u9996\u5148\u5148\u628a\u8fb9\u6743\u8f6c\u6362\u6210\u5b50\u8282\u70b9\u7684\u70b9\u6743\uff0c\u8fd9\u4e2a\u5728\u7b2c\u4e00\u6b21dfs\u4e2d\u5c31\u53ef\u4ee5\u5b9e\u73b0\u4e86\uff0c\u8fd9\u9053\u9898\u8981\u7ef4\u62a4\u7684\u51e0\u4e2a\u64cd\u4f5c\u5927\u6982\u5982\u4e0b\uff1a1\u3001\u5355\u70b9\u4fee\u6539 2\u3001\u533a\u95f4\u8986\u76d6 3\u3001\u533a\u95f4\u52a0 4\u3001\u533a\u95f4\u67e5\u8be2\u6700\u5927\u503c\u3002\u90fd\u6ca1\u6709\u4ec0\u4e48\u4eae\u70b9\uff0c\u5e38\u89c4\u64cd\u4f5c\u5427\u3002\u63a5\u4e0b\u6765\u5c31\u770b\u4ee3\u7801\u628a\uff085k\u4ee3\u7801\u8b66\u544a\uff09\n```cpp\n#include<bits/stdc++.h>\n#define int long long//\u597d\u4e60\u60ef\uff0c\u4e0d\u5f00long long\u89c1\u7956\u5b97\n#define INF 0x3f3f3f3f\nusing namespace std;\ninline int read(){\n    int w=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){\n        if(ch=='-') f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        w=(w<<3)+(w<<1)+ch-48;\n        ch=getchar();\n    }\n    return w*f;\n} //\u54b8\u9c7c\u5feb\u8bfb\nint ans,n,m,R,Mod,cnt,head[1000010],depth[1000010],son[1000010],f[1000010],top[1000010],tot,id[1000010],a[1000010],val[1000010],size[1000010];\nbool debug;\nstruct Edge{\n    int from,to,next,dis;\n}edge[1000010];\ninline void addedge(int u,int v,int w){\n    cnt++;\n    edge[cnt].from=u;\n    edge[cnt].to=v;\n    edge[cnt].dis=w;\n    edge[cnt].next=head[u];\n    head[u]=cnt;\n}\ninline void dfs1(int u,int fa){\n    f[u]=fa;depth[u]=depth[fa]+1;\n    size[u]=1;int v,i,j,k;\n    int maxson=-1;\n    for(i=head[u];i;i=edge[i].next){\n        v=edge[i].to;if(v==fa) continue;\n        a[v]=edge[i].dis;//\u8fb9\u6743\u8f6c\u6362\u6210\u70b9\u6743\n        dfs1(v,u);size[u]+=size[v];\n        if(size[v]>maxson){\n            maxson=size[v];son[u]=v;\n        }\n    }\n    return;\n}\ninline void dfs2(int u,int top_fa){\n    tot++;id[u]=tot;top[u]=top_fa;\n    val[tot]=a[u];int i,j,k,v;\n    if(!son[u]) return;\n    dfs2(son[u],top_fa);\n    for(i=head[u];i;i=edge[i].next){\n        v=edge[i].to;if(id[v]) continue;\n        dfs2(v,v);\n    }\n    return;\n}//\u90fd\u662f\u5e38\u89c4\u64cd\u4f5c\uff0c\u6beb\u65e0\u4eae\u70b9\nstruct Node{\n    int l,r,maxx,cov_tag,add_tag;\n}st[1000010];//\u7ebf\u6bb5\u6811\u90e8\u5206\n\ninline int ls(int p){\n    return p<<1;\n}//\u5de6\u513f\u5b50\n\ninline int rs(int p){\n    return p<<1|1;\n}//\u53f3\u513f\u5b50\n\ninline void push_up(int p){\n    st[p].maxx=max(st[ls(p)].maxx,st[rs(p)].maxx);return;\n}//\u4e0a\u63a8\uff0c\u53ea\u8981\u4e0a\u63a8\u4e00\u4e2a\u6700\u5927\u503c\u5c31\u884c\uff0c\u5e76\u4e0d\u9ebb\u70e6\n\ninline void build(int p,int l,int r){\n    st[p].l=l;st[p].r=r;st[p].cov_tag=-1;st[p].add_tag=0;\n    if(l==r){\n        st[p].maxx=val[l];return;\n    }\n    int mid=(l+r)>>1;\n    build(ls(p),l,mid);build(rs(p),mid+1,r);push_up(p);return;\n}//\u5e38\u89c4\u5efa\u6811\uff0c\u6beb\u65e0\u4eae\u70b9\n\ninline void push_down(int p){\n    if(st[p].cov_tag!=-1){\n        st[ls(p)].cov_tag=st[rs(p)].cov_tag=st[p].cov_tag;//\u4e0b\u79fb\u8986\u76d6\u6807\u8bb0 \n        st[ls(p)].maxx=st[rs(p)].maxx=st[p].cov_tag;//\u56e0\u4e3a\u8986\u76d6\u6240\u4ee5\u5f53\u524d\u533a\u95f4\u7684\u6700\u5927\u503c\u4e5f\u88ab\u8986\u76d6\u4e86 \n        st[ls(p)].add_tag=st[rs(p)].add_tag=0;//\u6e05\u7a7a\u5b50\u8282\u70b9\u7684\u52a0\u6807\u8bb0 \n    }//\u6b64\u5904\u6ce8\u610f\uff0c\u5148\u8fdb\u884c\u8986\u76d6\u6807\u8bb0\u4e0b\u63a8\uff0c\u518d\u8fdb\u884c\u533a\u95f4\u52a0\u6807\u8bb0\u4e0b\u79fb\n    st[ls(p)].add_tag+=st[p].add_tag;//\u54e6\u6211\u4e00\u5f00\u59cb\u4ee5\u4e3a\u4e0b\u79fb\u8986\u76d6\u5c31\u4e0d\u7528\u4e0b\u79fb\u533a\u95f4\u52a0\uff0cWA\u6210\u50bb\u5b50\n    st[rs(p)].add_tag+=st[p].add_tag;\n    st[ls(p)].maxx+=st[p].add_tag;\n    st[rs(p)].maxx+=st[p].add_tag;\n    st[p].add_tag=0;st[p].cov_tag=-1;return;//\u8bb0\u5f97\u6e05\u7a7a\n}\n\ninline void interval_add(int p,int l,int r,int val){\n    if(st[p].l>=l&&st[p].r<=r){\n        st[p].maxx+=val;\n        st[p].add_tag+=val;return;\n    }\n    push_down(p);\n    int mid=(st[p].l+st[p].r)>>1;\n    if(l<=mid) interval_add(ls(p),l,r,val);\n    if(r>mid) interval_add(rs(p),l,r,val);\n    push_up(p);return; \n}//\u5e38\u89c4\u533a\u95f4\u52a0\n\ninline void interval_cover(int p,int l,int r,int val){\n    if(st[p].l>=l&&st[p].r<=r){\n        st[p].add_tag=0;st[p].cov_tag=val;\n        st[p].maxx=val;return;\n    }\n    push_down(p);\n    int mid=(st[p].l+st[p].r)>>1;\n    if(l<=mid) interval_cover(ls(p),l,r,val);\n    if(r>mid) interval_cover(rs(p),l,r,val);\n    push_up(p);return;\n}//\u5e38\u89c4\u533a\u95f4\u8986\u76d6\n\ninline void tree_cover(int x,int y,int z){\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]]) swap(x,y);\n        interval_cover(1,id[top[x]],id[x],z);\n        x=f[top[x]];\n    }\n    if(depth[x]>depth[y]) swap(x,y);\n    interval_cover(1,id[x]+1,id[y],z);return;\n}//\u5e38\u89c4\u8df3\u94fe\n\ninline void tree_add(int x,int y,int z){\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]]) swap(x,y);\n        interval_add(1,id[top[x]],id[x],z);\n        x=f[top[x]];\n    }\n    if(depth[x]>depth[y]) swap(x,y);\n    interval_add(1,id[x]+1,id[y],z);return;\n}//\u5e38\u89c4\u8df3\u94fe\n\ninline int interval_query(int p,int l,int r){\n    if(st[p].l>=l&&st[p].r<=r){\n        return st[p].maxx;\n    }\n    push_down(p);\n    int mid=(st[p].l+st[p].r)>>1;int sum=-INF;\n    if(l<=mid) sum=max(sum,interval_query(ls(p),l,r));\n    if(r>mid) sum=max(sum,interval_query(rs(p),l,r));\n    return sum;\n}//\u5e38\u89c4\u533a\u95f4\u6700\u5927\u503c\n\ninline int tree_query(int x,int y){\n    int sum=-INF;\n    while(top[x]!=top[y]){\n        if(depth[top[x]]<depth[top[y]]) swap(x,y);\n        sum=max(sum,interval_query(1,id[top[x]],id[x]));\n \t\tx=f[top[x]];\n    }\n    if(depth[x]>depth[y]) swap(x,y);\n    sum=max(sum,interval_query(1,id[x]+1,id[y]));return sum; \n}//\u5e38\u89c4\u8df3\u94fe\n\nsigned main(){\n    n=read();int i,j,k;\n    for(i=1;i<n;i++){\n        int x,y,z;\n        x=read();y=read();z=read();\n        addedge(x,y,z);addedge(y,x,z);\n    }\n    dfs1(1,0);dfs2(1,1);build(1,1,n);\n    //debug=true;\n    while(true){\n    \tstring s;cin>>s;int x,y,z;\n    \tif(s[1]=='t') break;\n    \tif(s[1]=='h'){//change \n    \t\tx=read();y=read();\n    \t\tint u=edge[x*2].from,v=edge[x*2].to;\n    \t\tif(depth[u]>depth[v]){//\u5355\u70b9\u4fee\u6539\u6ce8\u610f\u4e24\u4e2a\u5730\u65b9\uff0c\u9996\u5148\u56e0\u4e3a\u6df1\u5ea6\u66f4\u5927\u7684\u662f\u513f\u5b50\uff0c\u6240\u4ee5\u4fee\u6539\u6df1\u5ea6\u5927\u7684\uff0c\u5176\u6b21\u4fee\u6539\u7684\u662fid[]\n    \t\t    interval_cover(1,id[u],id[u],y);\n            }\n            else{\n                interval_cover(1,id[v],id[v],y);\n            }\n        }\n        if(s[1]=='o'){//cover\n            x=read();y=read();z=read();\n            tree_cover(x,y,z);\n        }\n        if(s[1]=='d'){//add\n            x=read();y=read();z=read();\n            tree_add(x,y,z);\n        }\n        if(s[1]=='a'){//max\n            x=read();y=read();ans=tree_query(x,y);\n            printf(\"%d\\n\",ans);\n        }//\u5e38\u89c4\u64cd\u4f5c\u7a33\u4f4f\n    }\n    return 0;\n}\n```\n### \u55ef\u6574\u4efd\u4ee3\u7801\u5927\u6982\u5c31\u662f\u8fd9\u6837\uff0c\u601d\u8def\u4e0d\u96be\uff0c\u53cd\u6b63\u6211\u662f\u5230\u5904\u5199\u6302\uff0c~~\u83dc\u662f\u539f\u7f6a~~\u5e0c\u671b\u5927\u5bb6\u4e00\u904d\u8f7b\u677eAC",
        "postTime": 1542887359,
        "uid": 106035,
        "name": "\u6e29\u8bcd",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "## [\u4f20](https://www.luogu.org/problemnew/show/P4315)[\u9001\u95e8](https://www.luogu.org/blog/LovToLZX/)\n\n\u8fd9\u662f\u4e00\u9053\u6811\u5256\u7684\u88f8\u9898\n\n\u4f46\u662f\u8981\u6ce8\u610f\u4e0b\u8fd9\u51e0\u4e2a\u7ec6\u8282:\n\n![\u6709\u90a3\u4e2a\u674e](https://i.loli.net/2018/10/03/5bb4a07129536.png)\n\n1.\u7531\u4e8e\u662f\u5bf9\u8fb9\u7684\u4fee\u6539\u4ee5\u53ca\u67e5\u8be2\u64cd\u4f5c \u6240\u4ee5\u5c31\u628a\u8fb9\u4e0b\u653e\u5230\u70b9\u4e0a\n\n![\u725b\u903c](https://i.loli.net/2018/10/03/5bb4a10af0223.png)\n\n2.\u6211\u4eec\u53ef\u4ee5\u5341\u5206\u660e\u663e\u5730\u53d1\u73b0 \u6811\u4e0a\u8def\u5f84\u662f\u7ecf\u8fc7LCA(u,v)\u7684\n\n\u4f46\u662f \u5728\u67e5\u8be2\u8fb9\u7684\u8303\u7574\u91cc \u8fd9\u662f\u5341\u5206\u4e0d\u5408\u6cd5\u7684\n\n\u6240\u4ee5\n\n\u4fee\u6539\u65f6 \u5c06LCA\u539f\u503c\u4fdd\u7559 \u7136\u540e\u518d\u76f4\u63a5\u4fee\u6539 \u7136\u540e\u518d\u6539\u56de\n\n\u67e5\u8be2\u65f6 \u5c06LCA\u539f\u503c\u4fdd\u7559\u518d\u8d4b\u4e3a\u6781\u5c0f\u503c \u7136\u540e\u76f4\u63a5\u67e5\u8be2 \n\n\u7136\u540e\u518d\u6539\u56de\n\n3.\u5b9a\u4e49\u533a\u95f4\u8986\u76d6\u7684\u4f18\u5148\u7ea7 \u9ad8\u4e8e \u533a\u95f4\u52a0\u6cd5\n\n4.\u7531\u4e8e\u662f\u5efa\u7684\u53cc\u5411\u8fb9 \u6240\u4ee5\n\n\u5bf9\u4e8edep[to[x \u00d7 2 - 1]] \u4ee5\u53ca dep[to[x \u00d7 2]]\n\n\u8f83\u5927\u7684\u5bf9\u5e94\u7684\u70b9\u5c31\u662f\u6211\u4eec\u8981\u7684\u8fb9\u6743\u4e0b\u653e\u7684\u70b9\n\n\u5269\u4e0b\u7684\u5c31\u662f\u6811\u5256\u677f\u5b50\u7684\u4e8b\u4e86\n\n# CODE:\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<cstdlib>\n#include<algorithm>\n#define IL inline\n#define R register \n#define N 200008\n#define eps 1e-8\n#define inf 0x7fffff\n#define D double\nusing namespace std;\ntemplate<typename T>IL void read(T &A)\n{\n    T x=0,f=1;char ch=getchar();\n    while(!isdigit(ch))\n    {\n        if(ch=='-') f=0;ch=getchar();\n    }\n    while(isdigit(ch))\n    {\n        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();\n    }\n    A=f ? x:-x;\n}\nint n,tot,cnt;\nint fa[N][30],siz[N],dep[N],son[N],top[N],id[N],num[N],wt[N];\nstruct Node{\n    int to,nex,w;\n}e[N];\nint head[N];\nstruct Tree{\n    int val,tag1,tag2;\n}tre[N<<1];\nIL void add(int ai,int bi,int ci)\n{\n    e[++tot].nex=head[ai];head[ai]=tot;\n    e[tot].to=bi;e[tot].w=ci;\n}\nIL void dfs1(int now,int fat,int det)\n{\n//    printf(\"now is %d and father is %d and dept is %d\\n\",now,fat,det);\n    dep[now]=det;fa[now][0]=fat;\n    siz[now]=1;int maxson=-1;\n    for(R int j=1;j<=25;++j)\n     fa[now][j]=fa[fa[now][j-1]][j-1];\n    for(R int i=head[now];i;i=e[i].nex)\n    {\n        int v=e[i].to;\n        if(v==fat) continue;\n        num[v]=e[i].w;\n        dfs1(v,now,det+1);\n        siz[now]+=siz[v];\n        if(siz[v]>maxson) {son[now]=v;maxson=siz[v];}\n    } \n}\nIL void dfs2(int now,int topf)\n{\n//    printf(\"now is %d and top is %d\\n\",now,topf);\n    top[now]=topf;id[now]=++cnt;wt[cnt]=now;\n    if(!son[now]) return;\n    dfs2(son[now],topf);\n    for(R int i=head[now];i;i=e[i].nex)\n    {\n        int v=e[i].to;\n        if(v==fa[now][0]||v==son[now]) continue;\n        dfs2(v,v);\n    }\n}\n/*--------------------------------*/\nIL void down(int si,int le,int ri)\n{\n//\u7531\u4e8e\u76f4\u63a5\u8986\u76d6\u4e4b\u540e \u5c31\u662f\u4e00\u4e2a\u5b9a\u503c\n//\u6240\u4ee5\u533a\u95f4\u8986\u76d6\u7684tag\u53ef\u4ee5\u6d88\u706d\u533a\u95f4\u52a0\u6cd5\u7684tag\n    if(tre[si].tag1)\n    {\n        tre[si<<1].val=tre[si].tag1;\n        tre[si<<1|1].val=tre[si].tag1;\n        tre[si<<1].tag1=tre[si].tag1;\n        tre[si<<1|1].tag1=tre[si].tag1;\n        tre[si].tag1=0;tre[si<<1|1].tag2=tre[si<<1].tag2=0;\n    }\n    tre[si<<1].val+=tre[si].tag2;\n    tre[si<<1|1].val+=tre[si].tag2;\n    tre[si<<1].tag2+=tre[si].tag2;\n    tre[si<<1|1].tag2+=tre[si].tag2;\n    tre[si].tag2=0;\n}\nIL void build(int si,int le,int ri)\n{\n    if(le==ri) {tre[si].val=num[wt[le]];return;}\n    int mid=(le+ri)>>1;\n    build(si<<1,le,mid);\n    build(si<<1|1,mid+1,ri);\n    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);\n}\nIL void update(int si,int lenow,int rinow,int le,int ri,int ak)\n{//\u533a\u95f4\u52a0\u6cd5\n    if(le<=lenow&&rinow<=ri)\n    {\n        tre[si].val+=ak;\n        tre[si].tag2+=ak;\n        return;\n    }\n    down(si,lenow,rinow);\n    int mid=(lenow+rinow)>>1;\n    if(le<=mid) update(si<<1,lenow,mid,le,ri,ak);\n    if(mid<ri) update(si<<1|1,mid+1,rinow,le,ri,ak);\n    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);\n}\nIL void cover(int si,int lenow,int rinow,int le,int ri,int ak)\n{//\u533a\u95f4\u8986\u76d6\n    if(le<=lenow&&rinow<=ri)\n    {\n        tre[si].val=ak;\n        tre[si].tag1=ak;tre[si].tag2=0;return;\n    }\n    down(si,lenow,rinow);\n    int mid=(lenow+rinow)>>1;\n    if(le<=mid) cover(si<<1,lenow,mid,le,ri,ak);\n    if(mid<ri) cover(si<<1|1,mid+1,rinow,le,ri,ak);\n    tre[si].val=max(tre[si<<1].val,tre[si<<1|1].val);\n} \nIL int qury(int si,int lenow,int rinow,int le,int ri)\n{\n//    printf(\"quryint djshf  le is %d but ri is %d\\n\",lenow,rinow);\n    if(le<=lenow&&rinow<=ri)\n    {\n        return tre[si].val;\n    }\n    down(si,lenow,rinow);\n    int ans=-1;\n    int mid=(lenow+rinow)>>1;\n    if(le<=mid) ans=max(ans,qury(si<<1,lenow,mid,le,ri));\n    if(mid<ri) ans=max(ans,qury(si<<1|1,mid+1,rinow,le,ri));\n    return ans;\n}\n/*--------------------------------*/\nIL int LCA(int nowx,int nowy)\n{\n//\u5176\u5b9e\u6811\u5256\u5c31\u53ef\u4ee5\u6c42LCA \u4f46\u662f\u672c\u849f\u84bb\u53ea\u4f1a\u500d\u589e\n    if(dep[nowy]>dep[nowx]) swap(nowx,nowy);\n    for(R int j=25;j>=0;--j)\n     if(dep[fa[nowx][j]]>=dep[nowy]) nowx=fa[nowx][j];\n    if(nowx==nowy) return nowx;\n    for(R int j=25;j>=0;--j)\n     if(fa[nowx][j]!=fa[nowy][j])\n      nowx=fa[nowx][j],nowy=fa[nowy][j];\n    return fa[nowx][0];      \n}\nIL int QuryRange(int nowx,int nowy)\n{\n    int ans=-1;\n    while(top[nowx]!=top[nowy])\n    {\n        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);\n        ans=max(ans,qury(1,1,n,id[top[nowx]],id[nowx]));\n        nowx=fa[top[nowx]][0];\n    }\n    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);\n    ans=max(ans,qury(1,1,n,id[nowx],id[nowy]));\n    return ans;\n}\nIL void CoRange(int nowx,int nowy,int ak)\n{\n    while(top[nowx]!=top[nowy])\n    {\n        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);\n        cover(1,1,n,id[top[nowx]],id[nowx],ak);\n        nowx=fa[top[nowx]][0];\n    }\n    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);\n    cover(1,1,n,id[nowx],id[nowy],ak);\n    return;\n}\nIL void UpdRange(int nowx,int nowy,int ak)\n{\n    while(top[nowx]!=top[nowy])\n    {\n        if(dep[top[nowx]]<dep[top[nowy]]) swap(nowx,nowy);\n        update(1,1,n,id[top[nowx]],id[nowx],ak);\n        nowx=fa[top[nowx]][0];\n    }\n    if(dep[nowx]>dep[nowy]) swap(nowx,nowy);\n    update(1,1,n,id[nowx],id[nowy],ak);\n    return;\n}\nsigned main()\n{\n    read(n);\n    for(R int i=1;i<n;++i)\n    {\n        int x,y,z;read(x);read(y);read(z);\n        add(x,y,z);add(y,x,z);\n    }\n    dfs1(1,0,1);dfs2(1,1);build(1,1,n);\n    while(1)\n    {\n        string key;cin>>key;\n        if(key[1]=='h')\n        {\n            int x,y,now;read(x);read(y);\n            now=(dep[e[(x<<1)].to]>dep[e[(x<<1)-1].to] ? e[(x<<1)].to : e[(x<<1)-1].to);\n            cover(1,1,n,id[now],id[now],y);\n        }\n        else if(key[1]=='a')\n        {\n            int x,y,tmp,akj;read(x);read(y);tmp=LCA(x,y);\n            akj=qury(1,1,n,id[tmp],id[tmp]);\n            cover(1,1,n,id[tmp],id[tmp],-inf);\n            printf(\"%d\\n\",QuryRange(x,y));\n            cover(1,1,n,id[tmp],id[tmp],akj);\n        }\n        else if(key[1]=='o')\n        {\n            int x,y,z,tmp,akj;read(x);read(y);read(z);tmp=LCA(x,y);\n            akj=qury(1,1,n,id[tmp],id[tmp]);\n            CoRange(x,y,z);\n            cover(1,1,n,id[tmp],id[tmp],akj);\n        }\n        else if(key[1]=='d')\n        {\n            int x,y,z,tmp,akj;read(x);read(y);read(z);tmp=LCA(x,y);\n            akj=qury(1,1,n,id[tmp],id[tmp]);\n            UpdRange(x,y,z);\n            cover(1,1,n,id[tmp],id[tmp],akj);\n        }\n        else break;\n    }\n    return 0;\n}\n```\n\n# _NOIP 2018 RP++_",
        "postTime": 1538565082,
        "uid": 87931,
        "name": "tcswuzb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u89e3\u9898\u601d\u8def\uff1a\u8fb9\u6743\u5316\u70b9\u6743\uff0c\u5c06\u8fb9\u6743\u653e\u5230\u6df1\u5ea6\u8f83\u6df1\u7684\u70b9\u4e0a\u9762   \n\u5bf9\u4e8e\u64cd\u4f5c\uff1a  \nChange k w\uff1a\u5c06\u7b2ck\u6761\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u6539\u53d8\u4e3aw\u4e2a\u3002  \n=>\u76f4\u63a5\u627e\u5bf9\u5e94\u7684\u70b9\uff0c\u7ebf\u6bb5\u6811\u4e0a\u5355\u70b9\u4fee\u6539  \nCover u v w\uff1a\u5c06\u8282\u70b9u\u4e0e\u8282\u70b9v\u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u6539\u53d8\u4e3aw\u4e2a\u3002  \n=>\u6ce8\u610f\uff1au\u548cv\u7684lca\u662f\u4e0d\u5e94\u8be5\u88ab\u4fee\u6539\u7684  \n\u4e3a\u4e86\u65b9\u4fbf\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4fee\u6539\uff0c\u518d\u628alca\u6539\u56de\u53bb  \nAdd u v w\uff1a\u5c06\u8282\u70b9u\u4e0e\u8282\u70b9v\u4e4b\u95f4\u7684\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u7684\u4e2a\u6570\u90fd\u589e\u52a0w\u4e2a\u3002  \n=>\u6ce8\u610f\uff1au\u548cv\u7684lca\u662f\u4e0d\u5e94\u8be5\u88ab\u52a0\u7684  \n\u4e3a\u4e86\u65b9\u4fbf\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4fee\u6539\uff0c\u518d\u628alca\u51cf\u56de\u53bb  \nMax u v\uff1a\u8be2\u95ee\u8282\u70b9u\u4e0e\u8282\u70b9v\u4e4b\u95f4\u6811\u679d\u4e0a\u6bdb\u6bdb\u679c\u4e2a\u6570\u6700\u591a\u6709\u591a\u5c11\u4e2a\u3002  \n=>\u6ce8\u610f\uff1au\u548cv\u7684lca\u662f\u4e0d\u5e94\u8be5\u88ab\u7b97\u8fdb\u53bb\u7684  \n\u6211\u4eec\u53ef\u4ee5\u5148\u5c06lca\u8d4b\u6210\u6781\u5c0f\u503c  \n\u5f97\u5230\u7b54\u6848\u540e\u5728\u5c06\u539f\u503c\u8d4b\u56de\u53bb  \n\u503c\u5f97\u6ce8\u610f\u7684\u5730\u65b9\u662f\u7ebf\u6bb5\u6811\u7684\u6807\u8bb0\u4e0b\u653e \uff1a  \n\u5148\u4fee\u6539\u64cd\u4f5c\uff0c\u540e\u52a0\u64cd\u4f5c\uff0c\u4fdd\u8bc1\u6b63\u786e\u6027  \n\n\n[\u4ee3\u7801\u94fe\u63a5\uff08\u7565\u4e11\uff09](http://www.cnblogs.com/adelalove/p/8709620.html)",
        "postTime": 1522746254,
        "uid": 83546,
        "name": "\u4f9d\u4f9d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u4e00\u9053~~\u6bd2\u7624~~\u6811\u94fe\u5256\u5206\n\n\u4e3b\u8981\u601d\u60f3\u5c31\u662f\u628a\u8fb9\u6743\u5316\u4e3a\u70b9\u6743\n\n\u4e0eP1505 \u65c5\u6e38\u6709\u4e9b\u7c7b\u4f3c\n\n\u5148\u8fdb\u884cdfs,\u4e4b\u540e\u679a\u4e3e\u7f16\u53f7\u4e3a\u5947\u6570\u7684\u8fb9\n\n\u4f7f\u5947\u6570\u8fb9\u7684to\u6bd4from\u7684\u6df1\u5ea6\u5927\n\n\u7136\u540e\u628a\u8fb9\u6743\u5b58\u4e3ato\u7684\u70b9\u6743\u5373\u53ef\n\n\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u52a0\u6cd5\u6807\u8bb0\u548c\u4e00\u4e2a\u533a\u95f4\u8986\u76d6\u6807\u8bb0\n\n\u63a5\u4e0b\u6765\u5c31\u662f\u666e\u901a\u7ebf\u6bb5\u6811\u64cd\u4f5c\u4e86\n\n~~\u6211\u624d\u4e0d\u4f1a\u8bf4\u6211\u5c11\u6253\u4e00\u4e2apushdown\u8c03\u4e86\u4e24\u4e2a\u5c0f\u65f6~~\n\n\u611f\u8c22@da32s1da \u5927\u4f6c\u7684\u5e2e\u52a9\uff01\n\n\u4e11\u964b\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define reg register\nusing namespace std;\nconst int N=1e5+5;\nstruct edge\n{\n\tint from,to,nxt,dis;\n}edge[N<<1];\nint n,num,head[N],fa[N],son[N],tot[N],tag[N<<2];\nint cnt,idx[N],top[N],dep[N],w[N],maxn[N<<2],lazy[N<<2];\ninline int read()\n{\n\tint x=0,w=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)&&c!='-') c=getchar();\n\tif (c=='-') c=getchar(),w=-1;\n\twhile (isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*w;\n}\ninline void add_edge(int from,int to,int dis)\n{\n\tedge[++num].nxt=head[from];\n\tedge[num].from=from;\n\tedge[num].to=to;\n\tedge[num].dis=dis;\n\thead[from]=num;\n}\nvoid dfs(int k,int father,int deep)\n{\n\tint bigson=0;\n\tfa[k]=father; dep[k]=deep; tot[k]=1;\n\tfor (reg int i=head[k];i;i=edge[i].nxt)\n\t{\n\t\tint v=edge[i].to;\n\t\tif (v==father) continue;\n\t\tdfs(v,k,deep+1); tot[k]+=tot[v];\n\t\tif (bigson<tot[v])\n\t\t{\n\t\t\tbigson=tot[v]; son[k]=v;\n\t\t}\n\t}\n}\nvoid dfs(int k,int tp)\n{\n\tidx[k]=++cnt; top[k]=tp;\n\tif (!son[k]) return; dfs(son[k],tp);\n\tfor (reg int i=head[k];i;i=edge[i].nxt)\n\t{\n\t\tint v=edge[i].to;\n\t\tif (!idx[v]) dfs(v,v);\n\t}\n}\ninline void pushup(int now)\n{\n\tmaxn[now]=max(maxn[now<<1],maxn[now<<1|1]);\n}\ninline void pushdown(int now)\n{\n\tif (tag[now]!=-1)\n\t{\n\t\tmaxn[now<<1]=maxn[now<<1|1]=tag[now];\n        tag[now<<1]=tag[now<<1|1]=tag[now];\n        lazy[now<<1]=lazy[now<<1|1]=0;\n\t\ttag[now]=-1;\n\t}\n\tif (lazy[now])\n\t{\n\t\tlazy[now<<1]+=lazy[now];\n\t\tlazy[now<<1|1]+=lazy[now];\n\t\tmaxn[now<<1]+=lazy[now];\n\t\tmaxn[now<<1|1]+=lazy[now];\n\t\tlazy[now]=0;\n\t}\n}\nvoid build(int l,int r,int now)\n{\n\tlazy[now]=0; tag[now]=-1;\n\tif (l==r)\n\t{\n\t\tmaxn[now]=w[l]; return;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,now<<1);\n\tbuild(mid+1,r,now<<1|1);\n\tpushup(now);\n}\nvoid outchange(int p,int l,int r,int now,int c)\n{\n\tif (l==r)\n\t{\n\t\tmaxn[now]=c; return;\n\t}\n\tint mid=(l+r)>>1; pushdown(now);\n\tif (p<=mid) outchange(p,l,mid,now<<1,c);\n\telse outchange(p,mid+1,r,now<<1|1,c);\n\tpushup(now);\n}\nvoid inchange(int L,int R,int l,int r,int now,int c)//\u90fd\u4fee\u6539\u4e3a\u4e00\u4e2a\u6570  \n{\n\tif (l>R||r<L) return;\n\tif (l>=L&&r<=R)\n\t{\n\t\tmaxn[now]=c; tag[now]=c;\n\t\tlazy[now]=0; return;\n\t}\n\tint mid=(l+r)>>1; pushdown(now);\n\tif (mid>=R) inchange(L,R,l,mid,now<<1,c);\n\telse if (mid<L) inchange(L,R,mid+1,r,now<<1|1,c);\n\telse\n\t{\n\t\tinchange(L,mid,l,mid,now<<1,c);\n\t\tinchange(mid+1,R,mid+1,r,now<<1|1,c);\n\t}\n\tpushup(now);\n} \nvoid inchanges(int L,int R,int l,int r,int now,int c)//\u90fd\u52a0\u4e0a\u4e00\u4e2a\u6570\n{\n\tif (l>R||r<L) return;\n\tif (l>=L&&r<=R)\n\t{\n\t\tmaxn[now]+=c; lazy[now]+=c; return;\n\t}\n\tint mid=(l+r)>>1; pushdown(now);\n\tif (mid>=R) inchanges(L,R,l,mid,now<<1,c);\n\telse if (mid<L) inchanges(L,R,mid+1,r,now<<1|1,c);\n\telse\n\t{\n\t\tinchanges(L,mid,l,mid,now<<1,c);\n\t\tinchanges(mid+1,R,mid+1,r,now<<1|1,c);\n\t}\n\tpushup(now);\n} \nint getmax(int L,int R,int l,int r,int now)\n{\n\tif (l>R||r<L) return -1e9;\n\tif (l>=L&&r<=R) return maxn[now];\n\tint mid=(l+r)>>1; pushdown(now);\n\tif (mid>=R) return getmax(L,R,l,mid,now<<1);\n\tif (mid<L) return getmax(L,R,mid+1,r,now<<1|1);\n\treturn max(getmax(L,mid,l,mid,now<<1),getmax(mid+1,R,mid+1,r,now<<1|1));\n}\ninline void treechange(int x,int y,int val)//\u90fd\u4fee\u6539\u4e3a\u4e00\u4e2a\u6570\n{\n\twhile (top[x]!=top[y])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tinchange(idx[top[x]],idx[x],1,n,1,val);\n\t\tx=fa[top[x]];\n\t}\n    if (dep[x]>dep[y]) swap(x,y);\n    inchange(idx[x]+1,idx[y],1,n,1,val);\n}\ninline void treechanges(int x,int y,int val)//\u90fd\u52a0\u4e0a\u4e00\u4e2a\u6570 \n{\n\twhile (top[x]!=top[y])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tinchanges(idx[top[x]],idx[x],1,n,1,val);\n\t\tx=fa[top[x]];\n\t}\n\tif (dep[x]>dep[y]) swap(x,y);\n\tinchanges(idx[x]+1,idx[y],1,n,1,val);\n}\ninline int treemax(int x,int y)\n{\n\tint ans=-1e9;\n\twhile (top[x]!=top[y])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tans=max(ans,getmax(idx[top[x]],idx[x],1,n,1));\n\t\tx=fa[top[x]];\n\t}\n\tif (dep[x]>dep[y]) swap(x,y);\n\treturn max(ans,getmax(idx[x]+1,idx[y],1,n,1));\n}\nint main()\n{\n\tn=read();\n\tfor (reg int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read(),z=read();\n\t\tadd_edge(x,y,z);\n\t\tadd_edge(y,x,z);\n\t}\n\tdfs(1,0,1); dfs(1,1);\n\tfor (reg int i=1;i<=num;i+=2)\n\t{\n\t\tint &u=edge[i].from,&v=edge[i].to;\n\t\tif (dep[u]>dep[v]) swap(u,v);\n\t\tw[idx[v]]=edge[i].dis;\n\t}\n\tbuild(1,n,1);\n\twhile (1)\n\t{\n\t\tchar opt[10]; scanf(\"%s\",opt);\n\t\tif (opt[0]=='S') break;\n\t\tint x=read(),y=read();\n\t\tif (opt[0]=='C')\n\t\t  if (opt[1]=='h') outchange(idx[edge[(x<<1)-1].to],1,n,1,y);\n\t\t  else treechange(x,y,read());\n\t\tif (opt[0]=='A') treechanges(x,y,read());\n\t\tif (opt[0]=='M') printf(\"%d\\n\",treemax(x,y));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1522245349,
        "uid": 43471,
        "name": "Captain_Paul",
        "ccfLevel": 0,
        "title": "P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    },
    {
        "content": "\u63d0\u4f9b\u6307\u9488\u7ebf\u6bb5\u6811\u505a\u6cd5\n\n\u8fd9\u9898\u7684\u5751\u70b9\u5c31\u662f\u5de8**\u96be\u8c03\n\n~~\u6211**\u8c03\u4e86\u597d\u51e0\u5929\u7ed3\u679c\u662f\u5355\u70b9\u4fee\u6539\u6ca1\u52a0pushdown~~\n\n\u5904\u7406\u8986\u76d6\u65f6\u9700\u8981\u628a\u52a0\u6807\u8bb0\u6e05\u96f6\n\n\u5148\u8986\u76d6\u540e\u52a0\n\n\u5355\u70b9\u4fee\u6539\u6539\u7b2cx\u6761\u8fb9\u7684\u503c\n\n\u6709\u597d\u51e0\u79cd\u5904\u7406\u65b9\u6cd5\n\n\u53ef\u4ee5\u5f00\u4e2a\u6570\u7ec4dot[x]=p \u8868\u793a\u7b2cx\u6761\u8fb9\u6307\u5411\u7684\u4e0b\u9762\u7684\u70b9\u662fp\n\n\u6216\u8005\u662f\u6bd4\u8f83\u53cc\u5411\u8fb9\u7684\u4e24\u6761\u8fb9\u6240\u6307\u5411\u7684\u70b9\u7684\u6df1\u5ea6\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=1e5+10;\nnamespace Edge\n{\n\tint cnt,head[N],dot[N];\n\tstruct edge{int to,w,next;}e[N*2];\n\tinline void add(int a,int b,int c)\n\t{\n\t\te[++cnt].next=head[a];\n\t\thead[a]=cnt;\n\t\te[cnt].to=b;\n\t\te[cnt].w=c;\n\t}\n}using namespace Edge;\nnamespace Segment_Tree\n{\n\tint num[N],value[N]; //num[x]\u8868\u793adfs\u5e8f\u4e3ax\u7684\u70b9\u7684\u7f16\u53f7\n\tstruct tree\n\t{\n\t\ttree *son[2]; //son[0]\u8868\u793a\u5de6\u513f\u5b50 son[1]\u8868\u793a\u53f3\u513f\u5b50\n\t\tint l,r,mx,cov,add;\n\t\tinline tree(int L,int R)\n\t\t{\n\t\t\tcov=-1; //\u4e00\u5f00\u59cb\u9700\u8981\u8d4b\u6210-1 \n\t\t\tadd=mx=0;\n\t\t\tl=L;r=R;\n\t\t\tson[0]=son[1]=NULL;\n\t\t}\n\t\tinline void pushup()\n\t\t{\n\t\t\tmx=max(son[0]->mx,son[1]->mx);\n\t\t}\n\t\tinline void cover(int w)\n\t\t{\n\t\t\tcov=mx=w;add=0; //\u8bb0\u5f97\u6e05\u96f6\u52a0\u6807\u8bb0\n\t\t}\n\t\tinline void plus(int w)\n\t\t{\n\t\t\tadd+=w;mx+=w;\n\t\t}\n\t\tinline void pushdown()\n\t\t{\n\t\t\tif (cov!=-1)\n\t\t\t\tson[0]->cover(cov),\n\t\t\t\tson[1]->cover(cov),\n\t\t\t\tcov=-1;\n\t\t\tif (add)\n\t\t\t\tson[0]->plus(add),\n\t\t\t\tson[1]->plus(add),\n\t\t\t\tadd=0;\n\t\t}\n\t\tvoid update1(int pos,int key)\n\t\t{\n\t\t\tif (l==r){cover(key);return;}\n\t\t\tpushdown(); //\u6ce8\u610f\u4e0d\u8981\u6f0f\u6389\u4efb\u4f55\u4e00\u4e2apushdown \u5426\u5219\u5168WA..\n\t\t\tson[pos>(l+r>>1)]->update1(pos,key);\n\t\t\tpushup();\n\t\t}\n\t\tvoid update2(int L,int R,int w)\n\t\t{\n\t\t\tif (l>R||r<L)return;\n\t\t\tif (l>=L&&r<=R){cover(w);return;}\n\t\t\tpushdown();\n\t\t\tson[0]->update2(L,R,w);\n\t\t\tson[1]->update2(L,R,w);\n\t\t\tpushup();\n\t\t}\n\t\tvoid update3(int L,int R,int w)\n\t\t{\n\t\t\tif (l>R||r<L)return;\n\t\t\tif (l>=L&&r<=R){plus(w);return;}\n\t\t\tpushdown();\n\t\t\tson[0]->update3(L,R,w);\n\t\t\tson[1]->update3(L,R,w);\n\t\t\tpushup();\n\t\t}\n\t\tint query(int L,int R)\n\t\t{\n\t\t\tif (l>R||r<L)return 0;\n\t\t\tif (l>=L&&r<=R)return mx;\n\t\t\tpushdown();\n\t\t\treturn max(son[0]->query(L,R),son[1]->query(L,R));\n\t\t}\n\t}*root;\n\tvoid build(tree *&p,int l,int r)\n\t{\n\t\tp=new tree(l,r);\n\t\tif (l==r){p->mx=value[num[l]];return;}\n\t\tint mid=l+r>>1;\n\t\tbuild(p->son[0],l,mid);\n\t\tbuild(p->son[1],mid+1,r);\n\t\tp->pushup();\n\t}\n}using namespace Segment_Tree;\nnamespace Heavylight_Decomposition\n{\n\tint dfn[N],size[N],top[N],wson[N],dep[N]={0,1},fa[N],cnt;\n\tvoid dfs1(int p)\n\t{\n\t\tsize[p]=1;\n\t\tfor (int i=head[p];i;i=e[i].next)\n\t\t{\n\t\t\tint son=e[i].to;\n\t\t\tif (son==fa[p])continue;\n\t\t\tfa[son]=p;dep[son]=dep[p]+1;\n\t\t\tvalue[son]=e[i].w;dot[i+1>>1]=son; //\u7f16\u53f7\u4e3ai\u7684\u8fb9 \u56e0\u4e3a\u662f\u53cc\u5411\u5efa\u8fb9 \u6240\u4ee5\u5b9e\u9645\u4e0a\u8f93\u5165\u7684\u7b2ci\u6761\u8fb9\u662f\u8fd9\u91cc\u7684(i+1)/2\n\t\t\tdfs1(son);size[p]+=size[son];\n\t\t\tif (size[son]>size[wson[p]])wson[p]=son;\n\t\t}\n\t}\n\tvoid dfs2(int p,int tp)\n\t{\n\t\ttop[p]=tp;dfn[p]=++cnt;num[cnt]=p;\n\t\tif (wson[p])dfs2(wson[p],tp);\n\t\tfor (int son,i=head[p];i;i=e[i].next)\n\t\t\tif ((son=e[i].to)!=fa[p]&&son!=wson[p])\n\t\t\t\tdfs2(son,son);\n\t}\n\tinline void Cover(int a,int b,int c)\n\t{\n\t\twhile (top[a]!=top[b])\n\t\t{\n\t\t\tif (dep[top[a]]<dep[top[b]])swap(a,b);\n\t\t\troot->update2(dfn[top[a]],dfn[a],c);\n\t\t\ta=fa[top[a]];\n\t\t}\n\t\tif (dep[a]>dep[b])swap(a,b);\n\t\troot->update2(dfn[a]+1,dfn[b],c); //\u8bb0\u5f97dfn[a]\u8981+1(lca\u4e0d\u8ba1\n\t}\n\tinline void Add(int a,int b,int c)\n\t{\n\t\twhile (top[a]!=top[b])\n\t\t{\n\t\t\tif (dep[top[a]]<dep[top[b]])swap(a,b);\n\t\t\troot->update3(dfn[top[a]],dfn[a],c);\n\t\t\ta=fa[top[a]];\n\t\t}\n\t\tif (dep[a]>dep[b])swap(a,b);\n\t\troot->update3(dfn[a]+1,dfn[b],c);\n\t}\n\tinline int Max(int a,int b)\n\t{\n\t\tint ans=0;\n\t\twhile (top[a]!=top[b])\n\t\t{\n\t\t\tif (dep[top[a]]<dep[top[b]])swap(a,b);\n\t\t\tans=max(root->query(dfn[top[a]],dfn[a]),ans);\n\t\t\ta=fa[top[a]];\n\t\t}\n\t\tif (dep[a]>dep[b])swap(a,b);\n\t\treturn max(ans,root->query(dfn[a]+1,dfn[b]));\n\t}\n}using namespace Heavylight_Decomposition;\nint n;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1,a,b,c;i<n;i++)\n\t\tscanf(\"%d%d%d\",&a,&b,&c),\n\t\tadd(a,b,c),add(b,a,c);\n\tdfs1(1);dfs2(1,1);\n\tbuild(root,1,n);\n\tchar opt[10];\n\twhile (scanf(\"%s\",opt),opt[0]!='S')\n\t{\n\t\tint a,b,c;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tswitch (opt[1])\n\t\t{\n\t\t\tcase 'h':{root->update1(dfn[dot[a]],b);break;}\n\t\t\tcase 'a':{printf(\"%d\\n\",Max(a,b));break;}\n\t\t\tcase 'o':{int c;scanf(\"%d\",&c);Cover(a,b,c);break;}\n\t\t\tcase 'd':{int c;scanf(\"%d\",&c);Add(a,b,c);break;}\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1535986372,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4315 \u3010\u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d\u3011"
    }
]