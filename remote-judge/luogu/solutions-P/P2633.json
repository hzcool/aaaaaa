[
    {
        "content": "[\u66f4\u4f73\u9605\u8bfb\u4f53\u9a8c](https://tth37.cn/2019/05/20/solution-luogu-p2633/)\n\n> \u8fd9\u9898\u4e0d\u96be\u5440\uff0c\u600e\u4e48\u8c03\u4e86\u8fd9\u4e48\u4e45\uff1f         \u2014\u2014Mr. G\n\n\u524d\u7f6e\u77e5\u8bc6\u662f\u4e3b\u5e2d\u6811\u3002\u5728\u5229\u7528\u4e3b\u5e2d\u6811\u6c42\u89e3\u533a\u95f4\u7b2cK\u5c0f\u6570\u65f6\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e3b\u5e2d\u6811\u662f\u4e00\u79cd\u7c7b\u4f3c\u524d\u7f00\u548c\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5177\u6709\u548c\u524d\u7f00\u548c\u7c7b\u4f3c\u7684\u533a\u95f4\u52a0\u51cf\u53ca\u5dee\u5206\u7b49\u4f18\u79c0\u6027\u8d28\u3002\u5728\u6c42\u89e3\u7ebf\u6027\u533a\u95f4\u7684\u7b2cK\u5c0f\u6570\u65f6\uff0c\u6211\u4eec\u9700\u8981\u5c06\u8be5\u533a\u95f4\u5185\u7684\u6240\u6709\u6570\u503c\u4fe1\u606f\u6254\u5230\u4e00\u68f5\u4e3b\u5e2d\u6811\u4e2d\uff0c\u5e76\u5728\u8fd9\u68f5\u4e3b\u5e2d\u6811\u4e0a\u5de6\u53f3\u9012\u5f52\uff0c\u4ee5\u627e\u5230\u7b2cK\u5c0f\u6570\uff1b\u540c\u6837\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u7c7b\u6bd4\u6811\u4e0a\u524d\u7f00\u548c\u7684\u64cd\u4f5c\uff0c\u5b9a\u4e49$s[u]$\u4e3a\u4ece\u6839\u8282\u70b9\u5230\u7b2c$u$\u53f7\u8282\u70b9\u7684\u201c\u524d\u7f00\u4e3b\u5e2d\u6811\u201d\uff08\u611f\u6027\u7406\u89e3\u8c22\u8c22\uff09\u3002\u90a3\u4e48\uff0c\u5305\u542b$u$\u5230$v$\u4e0a\u6240\u6709\u6570\u503c\u4fe1\u606f\u7684\u4e3b\u5e2d\u6811\u5c31\u5e94\u8be5\u662f\uff1a\n$$\ns[u]+s[v]-s[lca(u,v)]-s[fa[lca(u,v)]]\n$$\n\u7406\u89e3\u4e0a\u5f0f\u540e\uff0c\u95ee\u9898\u57fa\u672c\u53ef\u4ee5\u89e3\u51b3\u4e86\u3002\u53e6\u5916\u6ce8\u610f\u79bb\u6563\u5316\u548c\u4e3b\u5e2d\u6811\u7684\u4ee3\u7801\u7ec6\u8282\u3002\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n// \u79bb\u6563\u5316\u64cd\u4f5c\n#define id(x) (lower_bound(b+1,b+L+1,a[x])-b)\n#define rid(x) (b[x])\n\nconst int MAXN = 100005;\n\nstruct Node {\n    int l, r, sum;\n}node[10000005];\nint head[MAXN],cnt;\n\nvector<int> G[MAXN];\n\nint N, M, L, lastans;\nint a[MAXN], b[MAXN];\nint f[MAXN][19], dep[MAXN];\n\ninline void build(Node &u, int l, int r) {\n    u.sum = 0;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    build(node[u.l = ++cnt], l, mid);\n    build(node[u.r = ++cnt], mid + 1, r);\n}\n\ninline void insert(Node c, Node &u, int l, int r, int p) {\n    u.sum = c.sum + 1;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    if(p <= mid)\n        insert(node[c.l], node[u.l = ++cnt], l, mid, p), u.r = c.r;\n    else\n        insert(node[c.r], node[u.r = ++cnt], mid+1, r, p), u.l = c.l;\n}\n\ninline void dfs(int u, int fa) {\n    insert(node[head[fa]], node[head[u] = ++cnt], 1, L, id(u));\n    f[u][0] = fa;\n    dep[u] = dep[fa] + 1;\n    for (register int i = 1; i <= 18; ++i)\n        f[u][i] = f[f[u][i-1]][i-1];\n    for (vector<int>::iterator it = G[u].begin(); it != G[u].end(); it++) {\n        int v = *it;\n        if (v == fa) continue;\n        dfs(v, u);\n    }\n}\n\ninline int Lca(int u, int v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    for (register int i = 18; i >= 0; --i) {\n        if (dep[f[u][i]] >= dep[v]) u = f[u][i];\n    }\n    if (u == v) return u;\n    for (register int i = 18; i >= 0; --i) {\n        if (f[u][i] != f[v][i])\n            u = f[u][i], v = f[v][i];\n    }\n    return f[u][0];\n}\n\ninline int query(Node x, Node y, Node z, Node w, int l, int r, int k) {\n    if (l == r) return l;\n    int sum = node[x.l].sum + node[y.l].sum - node[z.l].sum - node[w.l].sum;\n    int mid = (l + r) >> 1;\n    if(sum >= k) return query(node[x.l], node[y.l], node[z.l], node[w.l], l, mid, k);\n    return query(node[x.r], node[y.r], node[z.r], node[w.r], mid+1, r, k - sum);\n}\n\ninline int querypath(int u, int v, int k) {\n    int lca = Lca(u, v);\n    return rid(query(node[head[u]], node[head[v]], node[head[lca]], node[head[f[lca][0]]], 1, L, k));\n}\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    for (register int i = 1; i <= N; ++i)\n        scanf(\"%d\", &a[i]), b[i] = a[i];\n    for (register int i = 1; i < N; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    sort(b + 1, b + N + 1);\n    L = unique(b + 1, b + N + 1) - (b + 1);\n    build(node[head[0] = ++cnt], 1, L);\n    dfs(1, 0);\n    for (register int i = 1; i <= M; ++i) {\n        int u, v, k;\n        scanf(\"%d%d%d\", &u, &v, &k);\n        int nowans = querypath(u^lastans, v, k);\n        printf(\"%d\\n\", nowans);\n        lastans = nowans;\n    }\n}\n```",
        "postTime": 1558351280,
        "uid": 116851,
        "name": "_\u98ce\u4f11\u4f4f",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u4e3b\u5e2d\u6811\u677f\u5b50\u9898\u554a\u3002\u3002\u3002\n\n\u53ea\u662f\u628a\u5e8f\u5217\u7684\u64cd\u4f5c\u6539\u6210\u4e86\u6811\u4e0a\u3002\u3002\u3002\n\n\u5e8f\u5217\u7684\u4e3b\u5e2d\u6811\u7ef4\u62a4\u7684\u662f[1-i]\u8fd9\u91cc\u7ef4\u62a4\u4ece1\u5230i\u7684\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u7ed3\u70b9\u7684\u503c\u3002\n\n\u67e5\u8be2\u5c31\u5957\u4e2a\u6811\u4e0a\u5dee\u5206\uff1av[ql]+v[qr]-v[lca]-v[lca\\_fa]\u3002\n\nlca\u7684\u8bdd\u518d\u5957\u4e2a\u6811\u5256lca\u5c31\u884c\u4e86\u3002\n\n\u662f\u4e0d\u662f\u5f88\u7b80\u5355\u3002\u3002\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#define For(i,x,y) for (int i=x;i<=y;i++)\n#define cross(i,k) for (int i=first[k];i;i=last[i])\n#define N 100010\n#define il inline\n#define vd void\nusing namespace std;\nstruct node{\n    int num,v;\n}a[N];\nint rt[N],v[N*20],lson[N*20],rson[N*20],to[N<<1],last[N<<1],first[N],b[N],rk[N];\nint n,m,x,y,k,tot,cnt,lastans,lca;\nil int read(){\n    int x=0;int ch=getchar(),f=1;\n    while (!isdigit(ch)&&(ch!='-')&&(ch!=EOF)) ch=getchar();\n    if (ch=='-'){f=-1;ch=getchar();}\n    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}\n    return x*f;\n}\nil bool cmp(node x,node y){return x.v<y.v;}\nil vd add(int x,int y){to[++tot]=y,last[tot]=first[x],first[x]=tot;}\nil vd insert(int &u,int last,int l,int r,int k){\n    u=++cnt,v[u]=v[last]+1;\n    if (l==r) return;\n    lson[u]=lson[last],rson[u]=rson[last];\n    int mid=l+r >> 1;\n    if (k<=mid) insert(lson[u],lson[u],l,mid,k);\n        else insert(rson[u],rson[u],mid+1,r,k);\n```\n}//\u63d2\u5165\n```cpp\nint size[N],son[N],fa[N],dep[N];\nil vd dfs(int k){\n    size[k]=1,dep[k]=dep[fa[k]]+1;\n    insert(rt[k],rt[fa[k]],1,n,b[k]);\n    cross(i,k){\n        int v=to[i];\n        if (v==fa[k]) continue;\n        fa[v]=k,dfs(v);\n        size[k]+=size[v];\n        if (!son[k]||size[v]>size[son[k]]) son[k]=v;\n    }\n}\nint top[N];\nil vd dfs(int k,int tp){\n    top[k]=tp;\n    if (!son[k]) return;\n    dfs(son[k],tp);\n    cross(i,k){\n        int v=to[i];\n        if (v==son[k]||v==fa[k]) continue;\n        dfs(v,v);\n    }\n}\nil int Lca(int x,int y){\n    while (top[x]!=top[y])\n        if (dep[top[x]]>=dep[top[y]]) x=fa[top[x]];\n            else y=fa[top[y]];\n    if (dep[x]>=dep[y]) return y;\n        else return x; \n```\n}//\u6811\u5256lca\nil int query(int ql,int qr,int lca,int lca\\_fa,int l,int r,int k){\n\n```cpp\n    if (l==r) return l;\n    int mid=l+r >> 1,t=v[lson[ql]]+v[lson[qr]]-v[lson[lca]]-v[lson[lca_fa]];\n    if (t>=k) return query(lson[ql],lson[qr],lson[lca],lson[lca_fa],l,mid,k);\n        else return query(rson[ql],rson[qr],rson[lca],rson[lca_fa],mid+1,r,k-t);\n```\n}//\u67e5\u8be2\n```cpp\nint main(){\n    n=read(),m=read();\n    For(i,1,n){\n        b[i]=read();\n        a[i].num=i,a[i].v=b[i];\n    }\n    sort(a+1,a+1+n,cmp),a[0].v=-233333333;\n    For(i,1,n)\n        if (a[i].v!=a[i-1].v) rk[++x]=b[a[i].num],b[a[i].num]=x;\n            else b[a[i].num]=x;//\u79bb\u6563\n    For(i,1,n-1){\n        x=read(),y=read();\n        add(x,y),add(y,x);\n    }\n    dfs(1);\n    dfs(1,1);\n    For(i,1,m){\n        x=read(),y=read(),k=read();\n        x^=lastans,lca=Lca(x,y);\n        lastans=rk[query(rt[x],rt[y],rt[lca],rt[fa[lca]],1,n,k)];\n        printf(\"%d\\n\",lastans);\n    }\n    return 0;\n}\n```",
        "postTime": 1515069258,
        "uid": 25355,
        "name": "\u590f\u8272\u796d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "P2633 Count on a tree\n\n---\n\u9898\u76ee\u63cf\u8ff0\n\n\u7ed9\u5b9a\u4e00\u68f5N\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u5bf9\u4e8eM\u4e2a\u8be2\u95ee(u,v,k)\uff0c\u4f60\u9700\u8981\u56de\u7b54u xor lastans\u548cv\u8fd9\u4e24\u4e2a\u8282\u70b9\u95f4\u7b2cK\u5c0f\u7684\u70b9\u6743\u3002\u5176\u4e2dlastans\u662f\u4e0a\u4e00\u4e2a\u8be2\u95ee\u7684\u7b54\u6848\uff0c\u521d\u59cb\u4e3a0\uff0c\u5373\u7b2c\u4e00\u4e2a\u8be2\u95ee\u7684u\u662f\u660e\u6587\u3002\n\n\u8f93\u5165\u683c\u5f0f\uff1a\n\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570N,M\u3002\n\u7b2c\u4e8c\u884c\u6709N\u4e2a\u6574\u6570\uff0c\u5176\u4e2d\u7b2ci\u4e2a\u6574\u6570\u8868\u793a\u70b9i\u7684\u6743\u503c\u3002\n\u540e\u9762N-1\u884c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570(x,y)\uff0c\u8868\u793a\u70b9x\u5230\u70b9y\u6709\u4e00\u6761\u8fb9\u3002\n\u6700\u540eM\u884c\u6bcf\u884c\u4e24\u4e2a\u6574\u6570(u,v,k)\uff0c\u8868\u793a\u4e00\u7ec4\u8be2\u95ee\u3002\n\n\u8f93\u51fa\u683c\u5f0f\uff1a\nM\u884c\uff0c\u8868\u793a\u6bcf\u4e2a\u8be2\u95ee\u7684\u7b54\u6848\u3002\n\n\u8f93\u5165\u6837\u4f8b\uff1a\n8 5\n105 2 9 3 8 5 7 7\n1 2\n1 3\n1 4\n3 5\n3 6\n3 7\n4 8\n2 5 1\n0 5 2\n10 5 3\n11 5 4\n110 8 2\n\n\u8f93\u51fa\u6837\u4f8b\uff1a\n2\n8\n9\n105\n7\n\u8bf4\u660e\nN,M<=100000\n\n---\n\u4e00\u9053\u4e0d\u9519(~~\u6bd2\u7624~~)\u7684\u4e3b\u5e2d\u6811\u7ec3\u4e60\u9898\uff0c\u56e0\u4e3a\u4e3b\u5e2d\u6811\u4fdd\u5b58\u7684\u662f\u524d\u7f00\u548c\uff0c\u8fd9\u9053\u9898\u7684\u9898\u76ee\u6846\u67b6\u662f\u6811\u5f62\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u628a\u4e00\u822c\u7684\u7ebf\u6027\u5173\u7cfb\u7684\u4e3b\u5e2d\u6811\u53d8\u6210\u6811\u5f62\u5173\u7cfb\uff0c\u518d\u8fdb\u884c\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u6301\u4e45\u5316\u5c31\u53ef\u4ee5\u4e86\u3002\u53c8\u56e0\u4e3a\u5bf9\u4e8e\u4e24\u4e2a\u8282\u70b9$(u,v)$\uff0cu\u5230v\u8def\u5f84\u4e0a\u7684\u6570\u5b57\u4e2a\u6570\u53ef\u4ee5\u8868\u793a\u6210$siz[u]+siz[v]-siz[lca(u,v)]-siz[fa[lca(u,v)]]$\uff0c\u6839\u636e\u8fd9\u4e2a\u6027\u8d28\u6211\u4eec\u5c31\u53ef\u4ee5\u8fdb\u884c\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u7684\u4e8c\u5206\u4e86\uff0c\u6ce8\u610f\u4e66\u5199\u7ec6\u8282\u5373\u53ef(~~\u6570\u7ec4\u5f00\u5c0f\u4e86~~)\u3002\n\n```\n/*dream_maker*/\n#include<bits/stdc++.h>\nusing namespace std;\n#define N 100010\n#define M 2000010\nint read(){\n\tint ans=0,w=1;char c=getchar();\n\twhile(c!='-'&&!isdigit(c))c=getchar();\n\tif(c=='-')w=-1,c=getchar();\n\twhile(isdigit(c))ans=ans*10+c-'0',c=getchar();\n\treturn ans*w;\n}\nint n,m,s,lastans=0,u,v,tot,cnt;\nstruct Edge{int v,next;}E[N<<1];\nint head[N],a[N],b[N],fa[N][32],dep[N];\nint rt[M]={0},ls[M]={0},rs[M]={0},siz[M]={0};\nvoid add(int u,int v){\n\tE[++tot]=(Edge){v,head[u]};\n\thead[u]=tot;\n}\nvoid modify(int &rt,int lastrt,int l,int r,int val){\n\tif(!rt)rt=++cnt;\n\tif(l==r){siz[rt]++;return;}\n\tint mid=(l+r)>>1;\n\tif(mid>=val)modify(ls[rt],ls[lastrt],l,mid,val),rs[rt]=rs[lastrt];\n\telse modify(rs[rt],rs[lastrt],mid+1,r,val),ls[rt]=ls[lastrt];\n\tsiz[rt]=siz[ls[rt]]+siz[rs[rt]];\n}\nint query(int rt1,int rt2,int rt3,int rt4,int l,int r,int k){\n\tif(l==r)return l;\n\tint mid=(l+r)>>1;\n\tint tmp=siz[ls[rt1]]+siz[ls[rt2]]-siz[ls[rt3]]-siz[ls[rt4]];\n\tif(tmp>=k)return query(ls[rt1],ls[rt2],ls[rt3],ls[rt4],l,mid,k);\n\telse return query(rs[rt1],rs[rt2],rs[rt3],rs[rt4],mid+1,r,k-tmp);\n}\nvoid dfs(int u,int f){\n\tdep[u]=dep[f]+1;\n\tfor(int i=head[u];i;i=E[i].next){\n\t\tint v=E[i].v;\n\t\tif(v==fa[u][0])continue;\n\t\tfa[v][0]=u;\n\t\tmodify(rt[v],rt[u],1,s,a[v]);\n\t\tdfs(v,u);\n\t}\n}\nint Lca(int x,int y){\n\tif(dep[x]<dep[y])swap(x,y);\n\tint t=dep[x]-dep[y];\n\tfor(int i=0;(1<<i)<=t;i++)\n\t\tif((1<<i)&t)x=fa[x][i];\n\tfor(int i=19;i>=0;i--)\n\t\tif(fa[x][i]!=fa[y][i])\n\t\t\tx=fa[x][i],y=fa[y][i];\n\tif(x==y)return x;\n\treturn fa[x][0];\n}\nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=n;i++)b[i]=a[i]=read();\n\tsort(b+1,b+n+1);\n\ts=unique(b+1,b+n+1)-b;\n\tfor(int i=1;i<n;i++){\n\t\tu=read();v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\tfor(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+s+1,a[i])-b;\n\tmodify(rt[1],rt[0],1,s,a[1]);\n\tdfs(1,0);\n\tint up=log2(n);\n\tfor(int k=1;k<=up;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfa[i][k]=fa[fa[i][k-1]][k-1];\n\tfor(int i=1;i<=m;i++){\n\t\tu=read();v=read();int k=read();\n\t\tu^=lastans;\n\t\tint lca=Lca(u,v);\n\t\tint ans=b[query(rt[u],rt[v],rt[lca],rt[fa[lca][0]],1,s,k)];\n\t\tprintf(\"%d\\n\",ans);\n\t\tlastans=ans;\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1526191142,
        "uid": 32083,
        "name": "dream_maker",
        "ccfLevel": 9,
        "title": "P2633 Count on a tree"
    },
    {
        "content": "\u7b2c\u4e00\u6b65\uff1a\u79bb\u6563\u5316\n\n\u5373\uff1a\u628a\u8282\u70b9\u7684\u70b9\u6743\u6362\u6210\u5b83\u5728\u6240\u6709\u70b9\u6743\u4e2d\u7684\u6392\u540d\uff08\u5b83\u662f\u7b2c\u51e0\u5c0f\u7684\uff09\n\n\u5c06\u5b58\u50a8\u70b9\u6743\u7684\u6570\u7ec4\u590d\u5236\u4e00\u4efd\u4e4b\u540e\u6392\u5e8f\uff0c\u53bb\u91cd\uff0c\u7136\u540e\u5c06\u539f\u5148\u7684\u6bcf\u4e2a\u70b9\u6743\u5728\u53bb\u91cd\u540e\u7684\u6570\u7ec4\u91cc\u8fdb\u884c\u4e8c\u5206\u67e5\u627e\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u5b83\u7684\u6392\u540d\u3002\n\n\n\u7b2c\u4e8c\u6b65\uff1a\u5efa\u4e3b\u5e2d\u6811\n\n\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u5b83\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u6240\u4ee5\u6bcf\u4e2a\u8282\u70b9\u53ef\u4ee5\u5229\u7528\u5b83\u7684\u7236\u8282\u70b9\u66f4\u65b0\uff0c\u6240\u4ee5\u5c06\u6574\u68f5\u6811dfs\u4e00\u904d\uff0c\u5728\u6b64\u8fc7\u7a0b\u4e2d\u5efa\u6811\u3002\n\n\n\u7b2c\u4e09\u6b65\uff1a\u6c42\u89e3\n\n\u7528u\u70b9\u7684\u4e3b\u5e2d\u6811+v\u70b9\u7684\u4e3b\u5e2d\u6811-lca(u,v)\u7684\u4e3b\u5e2d\u6811-lca(u,v)\u7236\u8282\u70b9\u7684\u4e3b\u5e2d\u6811\uff0c\u5728\u8fd9\u6837\u4ea7\u751f\u7684\u4e3b\u5e2d\u6811\u4e0a\u67e5\u627e\u7b2ck\u5c0f\u7684\u6392\u540d\uff0c\u6700\u540e\u8f93\u51fa\u5b83\u539f\u6765\u7684\u70b9\u6743\u3002\n\n\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\nusing namespace std;\nconst int e=1e5+5;\nstruct point\n{\n    int l,r,w;\n}c[e*30];\nint fa[e][21],a[e],h[e],tot,num,deep[e],n,m,rt[e],xxx,val[e];\nint next[e<<1],head[e],go[e<<1];\ninline int read()\n{\n    char ch;\n    int res=0;\n    bool f=false;\n    while(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n    if(ch=='-')f=true;\n    else res=ch-48;\n    while(ch=getchar(),ch>='0'&&ch<='9')\n    res=(res<<3)+(res<<1)+ch-48;\n    return f? -res:res;\n}\ninline void insert(int y,int &x,int l,int r,int p)\n{\n    c[x=++num]=c[y];\n    c[x].w++;\n    if(l==r)return;\n    int mid=l+r>>1;\n    if(p<=mid)insert(c[y].l,c[x].l,l,mid,p);\n    else insert(c[y].r,c[x].r,mid+1,r,p);\n    c[x].w=c[c[x].l].w+c[c[x].r].w;\n}\ninline int query(int x,int y,int z,int d,int l,int r,int k)\n{\n    if(l==r)return l;\n    int ret=c[c[x].l].w+c[c[y].l].w-c[c[z].l].w-c[c[d].l].w;\n    int mid=l+r>>1;\n    if(k<=ret)\n    return query(c[x].l,c[y].l,c[z].l,c[d].l,l,mid,k);\n    else return query(c[x].r,c[y].r,c[z].r,c[d].r,mid+1,r,k-ret);\n}\ninline void add(int x,int y)\n{\n    next[++tot]=head[x];\n    head[x]=tot;\n    go[tot]=y;\n    next[++tot]=head[y];\n    head[y]=tot;\n    go[tot]=x;\n}\ninline void dfs2(int u)\n{\n    insert(rt[fa[u][0]],rt[u],1,n,val[u]);\n    for(int i=head[u];i;i=next[i])\n    {\n        int v=go[i];\n        if(v==fa[u][0])continue;\n        dfs2(v);\n    }\n}\ninline void dfs(int u,int father)\n{\n    deep[u]=deep[father]+1;\n    for(int i=0;i<=19;i++)\n    fa[u][i+1]=fa[fa[u][i]][i];\n    for(int i=head[u];i;i=next[i])\n    {\n        int v=go[i];\n        if(v==father)continue;\n        fa[v][0]=u;\n        dfs(v,u);\n    }\n}\ninline int lca(int x,int y)\n{\n    if(deep[x]<deep[y])swap(x,y);\n    for(int i=19;i>=0;i--)\n    {\n        if(deep[fa[x][i]]>=deep[y])\n        x=fa[x][i];\n        if(x==y)return x;\n    }\n    for(int i=19;i>=0;i--)\n    {\n        if(fa[x][i]!=fa[y][i])\n        {\n            x=fa[x][i];\n            y=fa[y][i];\n        }\n    }\n    return fa[x][0];\n}\ninline int find(int x)\n{\n    int l=1,r=xxx,mid;\n    while(l<=r)\n    {\n        mid=l+r>>1;\n        if(x>h[mid])\n        l=mid+1;\n        else r=mid-1;\n    }\n    return l;\n}\nint main()\n{\n    int i,j,u,v,k;\n    n=read();\n    m=read();\n    for(i=1;i<=n;i++)\n    {\n        val[i]=read();\n        a[i]=val[i];\n    }\n    for(i=1;i<n;i++)\n    {\n        u=read();\n        v=read();\n        add(u,v);\n    }\n    sort(a+1,a+n+1);\n    h[1]=a[1];\n    xxx=1;\n    for(i=2;i<=n;i++)\n    if(a[i]!=a[i-1])h[++xxx]=a[i];\n    for(i=1;i<=n;i++)\n    val[i]=find(val[i]);\n    dfs(1,0);\n    int ans=0;\n    dfs2(1);\n    for(i=1;i<=m;i++)\n    {\n        u=read();\n        v=read();\n        k=read();\n        u^=ans;\n        int z=lca(u,v);\n        int last=query(rt[u],rt[v],rt[z],rt[fa[z][0]],1,n,k);\n        ans=h[last];\n        printf(\"%d\",ans);\n        if(i!=m)putchar('\\n');\n    }\n    return 0;\n}\n```",
        "postTime": 1495374727,
        "uid": 15268,
        "name": "\u82b1\u6dc7\u6dcb",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u7b2c K \u5927\uff1f\u4e3b\u5e2d\u6811\uff01\n\n\u8003\u8651\u6811\u4e0a\u9759\u6001\u6c42\u8def\u5f84\u4fe1\u606f\uff08\u5177\u6709\u533a\u95f4\u51cf\u6cd5\u6027\u8d28\uff09\uff1a  \n$s_x + s_y - s_{lca} - s_{fa_{lca}}$\uff0c\u5176\u4e2d $s_x$ \u8868\u793a\u7ed3\u70b9 $x$ \u5230\u6839\u7684\u4fe1\u606f\u3002\n\n\u90a3\u4e48\u6269\u5c55\u5230\u4e3b\u5e2d\u6811\u5373\u53ef\u3002\n\n\u6ce8\u610f\u79bb\u6563\u5316\uff01\n\n\u6ce8\u610f\u91cd\u590d\u5143\u7d20\uff01\u6211\u5c31\u662f\u56e0\u4e3a\u8fd9\u4e00\u70b9\u5728 BZOJ RE\uff0cSPOJ \u539f\u9898 WA \u7684\uff0c\u4e0d\u8fc7\u6d1b\u8c37\u6570\u636e\u6ca1\u6709\u91cd\u590d\u7684\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int BUFF_SIZE = 1 << 20;\nchar BUFF[BUFF_SIZE],*BB,*BE;\n#define gc() (BB == BE ? (BE = (BB = BUFF) + fread(BUFF,1,BUFF_SIZE,stdin),BB == BE ? EOF : *BB++) : *BB++)\ntemplate<class T>\ninline void read(T &x)\n{\n    x = 0;\n    char ch = 0,w = 0;\n    while(ch < '0' | ch > '9')\n        w |= ch == '-',ch = gc();\n    while(ch >= '0' && ch <= '9')\n        x = (x << 3) + (x << 1) + (ch ^ '0'),ch = gc();\n    w ? x = -x : x;\n}\n     \n#define ls(p) seg[p].lson\n#define rs(p) seg[p].rson\n#define cnt(p) seg[p].cnt\nconst int N = 1e5;\nlong long lastans;\nint n,m,rt[N + 10],len;\nlong long a[N + 10],ind[N + 10];\nint to[(N << 1) + 10],pre[(N << 1) + 10],first[N + 10];\ninline void add(int u,int v)\n{\n    static int tot = 0;\n    to[++tot] = v;\n    pre[tot] = first[u];\n    first[u] = tot;\n}\nstruct segnode\n{\n    int cnt,lson,rson;\n} seg[(N << 5) + 10];\nint insert(int x,int tl,int tr,int p)\n{\n    static int tot = 0;\n    int cur = ++tot;\n    seg[cur] = seg[p];\n    if(tl == tr)\n    {\n        ++cnt(cur);\n        return cur;\n    }\n\tint mid = tl + tr >> 1;\n    if(x <= mid)\n        ls(cur) = insert(x,tl,mid,ls(cur));\n    else\n        rs(cur) = insert(x,mid + 1,tr,rs(cur));\n    cnt(cur) = cnt(ls(cur)) + cnt(rs(cur));\n    return cur;\n}\nint query(int k,int tl,int tr,int x,int y,int lca,int fa_lca)\n{\n    if(tl == tr)\n        return tl;\n    int mid = tl + tr >> 1;\n    int cnt = cnt(ls(x)) + cnt(ls(y)) - cnt(ls(lca)) - cnt(ls(fa_lca));\n    if(k <= cnt)\n        return query(k,tl,mid,ls(x),ls(y),ls(lca),ls(fa_lca));\n    else\n        return query(k - cnt,mid + 1,tr,rs(x),rs(y),rs(lca),rs(fa_lca));\n}\nint fa[N + 10],dep[N + 10],sz[N + 10],son[N + 10],top[N + 10];\nint q[N + 10],head,tail;\ninline int getlca(int x,int y)\n{\n    while(top[x] ^ top[y])\n        dep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]];\n    return dep[x] < dep[y] ? x : y;\n}\nint main()\n{\n    read(n),read(m);\n    for(register int i = 1;i <= n;++i)\n        read(a[i]),ind[i] = a[i];\n    sort(ind + 1,ind + n + 1);\n    len = unique(ind + 1,ind + n + 1) - ind - 1;\n    for(register int i = 1;i <= n;++i)\n        a[i] = lower_bound(ind + 1,ind + len + 1,a[i]) - ind;\n    int u,v;\n    for(register int i = 1;i < n;++i)\n        read(u),read(v),add(u,v),add(v,u);\n    rt[1] = insert(a[1],1,n,0);\n    q[++tail] = dep[1] = 1;\n    while(head < tail)\n    {\n        int p = q[++head];\n        for(register int i = first[p];i;i = pre[i])\n            if(to[i] ^ fa[p])\n            {\n                fa[to[i]] = p;\n                dep[to[i]] = dep[p] + 1;\n                rt[to[i]] = insert(a[to[i]],1,n,rt[p]);\n                q[++tail] = to[i];\n            }\n    }\n    for(register int i = n;i;--i)\n    {\n        sz[fa[q[i]]] += sz[q[i]];\n        if(!son[fa[q[i]]] || sz[q[i]] > sz[son[fa[q[i]]]])\n            son[fa[q[i]]] = q[i];\n    }\n    for(register int i = 1;i <= n;++i)\n        top[q[i]] = son[fa[q[i]]] == q[i] ? top[fa[q[i]]] : q[i];\n    int x,y,k,lca;\n    while(m--)\n    {\n        read(x),read(y),read(k);\n        x ^= lastans;\n        lca = getlca(x,y);\n        printf(\"%lld\\n\",lastans = ind[query(k,1,n,rt[x],rt[y],rt[lca],rt[fa[lca]])]);\n    }\n    return 0;\n}\n```",
        "postTime": 1542085767,
        "uid": 75840,
        "name": "deserter",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "**\u503c\u57df\u4e3b\u5e2d\u6811\u80fd\u505a\u7684\u4e8b\u60c5\uff0c\u53ef\u6301\u4e45\u5316Trie\u90fd\u80fd\u505a\u5230**\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u53ef\u6301\u4e45\u5316Trie\u6765\u505a\u8fd9\u9053\u9898\n\n## \u89e3\u9898\u601d\u8def\n\n- \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u6811\u4e0a\u7684\u70b9\uff0c\u5efa\u4e00\u4e2a\u7248\u672c\u7684Trie\uff0c\u6765\u5b58\u50a8\u4ece\u6839\u5230\u8be5\u70b9\u8def\u5f84\u4e0a\u7684\u6240\u6709\u6570\u3002\u53ef\u89c1\uff0c\u5728\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0a\uff0c\u6211\u4eec\u9700\u8981\u4ee5\u7236\u8282\u70b9\u7684Trie\u4f5c\u4e3a\u539f\u7248\u672c\u6765\u6dfb\u52a0\n\n- \u4e3a\u4e86\u5f97\u5230$a$\u3001$b$\u8def\u5f84\u4e0a\u7684\u6240\u6709\u6570\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u7528$a+b-lca-lcafa$\u6765\u6c42\u51fa\u3002\u76f4\u63a5\u5728\u8fd9\u51e0\u4e2aTrie\u4e0a\u4e00\u8d77\u5f80\u4e0b\u8d70\u8def\uff0c\u5bf9$size$\u505a\u548c\u5dee\u5373\u53ef\uff0c\u57fa\u672c\u6846\u67b6\u548cTrie\u6c42\u5168\u5c40\u7b2c$k$\u5c0f\u4e00\u6837\uff0c\u5173\u4e8eTrie\u6c42\u533a\u95f4\u7b2c$k$\u5c0f\u53ef\u4ee5\u770b[\u8fd9\u7bc7\u9898\u89e3](https://www.luogu.org/blog/126376/solution-p3834)\n\n## \u7a0b\u5e8f\u5b9e\u73b0\n\n\u6811\u5256+Trie\n\n```cpp\n// luogu-judger-enable-o2\n#include <iostream>\n\nusing std :: cin;\nusing std :: cout;\nusing std :: swap;\nusing std :: cerr;\ntypedef unsigned int U;\n\nconst int MAXN = 1e5 + 5;\n\nstruct Edge{\n    int to;\n    Edge *nxt;\n\n    Edge() {}\n\n    Edge(int to, Edge *nxt) : to(to), nxt(nxt) {}\n}epool[MAXN << 1];\n\nEdge *head[MAXN];\n\nEdge *NewEdge(int to, Edge *nxt) {\n    static int cnt = 0;\n    epool[cnt] = Edge(to, nxt);\n    return &epool[cnt++];\n}\n\nvoid AddEdge(int u, int v) {\n    head[u] = new Edge(v, head[u]);\n}\n\nint n, m;\nint a[MAXN];\nint fa[MAXN], dep[MAXN], son[MAXN], siz[MAXN], top[MAXN], idx[MAXN];\nint idcnt;\n\nvoid Dfs1(int u, int las, int depth) {\n    fa[u] = las;\n    dep[u] = depth;\n    siz[u] = 1;\n    for (Edge *e = head[u]; e; e = e->nxt) {\n        int v = e->to;\n        if (v == fa[u]) continue;\n        Dfs1(v, u, depth + 1);\n        siz[u] += siz[v];\n        if (siz[v] > siz[son[u]]) son[u] = v;\n    }\n}\n\nvoid Dfs2(int u, int topf) {\n    top[u] = topf;\n    idx[u] = ++idcnt;\n    if (!son[u]) return;\n    Dfs2(son[u], topf);\n    for (Edge *e = head[u]; e; e = e->nxt) {\n        int v = e->to;\n        if (v == fa[u] || v == son[u]) continue;\n        Dfs2(v, v);\n    }\n}\n\nint Lca(int x, int y) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] > dep[top[y]]) swap(x, y);\n        y = fa[top[y]];\n    }\n    if (dep[x] > dep[y]) swap(x, y);\n    return x;\n}\n\nstruct Node{\n    int siz;\n    Node *ch[2];\n}npool[10000000];\n\nvoid Update(Node *now) {\n    now->siz = (now->ch[0] ? now->ch[0]->siz : 0) + (now->ch[1] ? now->ch[1]->siz : 0);\n}\n\nNode *NewNode() {\n    static int cnt = 0;\n    npool[cnt].siz = 0;\n    npool[cnt].ch[0] = NULL;\n    npool[cnt].ch[1] = NULL;\n    return &npool[cnt++];\n}\n\nNode *Copy(Node *now) {\n    Node *ret = NewNode();\n    *ret = *now;\n    return ret;\n}\n\nNode *rt[MAXN];\n\nvoid Insert(Node *&now, U num, int base) {\n    if (!now) now = NewNode();\n    else now = Copy(now);\n    if (base == 0) {\n        now->siz++;\n        return;\n    }\n    int f = (num & (1U << base - 1)) ? 1 : 0;\n    Insert(now->ch[f], num, base - 1);\n    Update(now);\n}\n\nU QueryKth(Node *now1, Node *now2, Node *now3, Node *now4, int base, int k, U res) {\n    if (base == 0) return res;\n    int ls1 = (now1 && now1->ch[0]) ? now1->ch[0]->siz : 0;\n    int ls2 = (now2 && now2->ch[0]) ? now2->ch[0]->siz : 0;\n    int ls3 = (now3 && now3->ch[0]) ? now3->ch[0]->siz : 0;\n    int ls4 = (now4 && now4->ch[0]) ? now4->ch[0]->siz : 0;\n    int ls = ls1 + ls2 - ls3 - ls4;\n    if (k <= ls) return QueryKth(now1 ? now1->ch[0] : NULL, now2 ? now2->ch[0] : NULL, now3 ? now3->ch[0] : NULL, now4 ? now4->ch[0] : NULL, base - 1, k, res);\n    else return QueryKth(now1 ? now1->ch[1] : NULL, now2 ? now2->ch[1] : NULL, now3 ? now3->ch[1] : NULL, now4 ? now4->ch[1] : NULL, base - 1, k - ls, res + (1U << base - 1));\n}\n\nvoid Print(Node *now, int base, U res) {\n    if (!now) return;\n    if (base == 0) cerr << res << \" \";\n    Print(now->ch[0], base - 1, res);\n    Print(now->ch[1], base - 1, res | (1U << base - 1));\n}\n\nvoid Dfs3(int u) {\n    rt[u] = rt[fa[u]];\n    Insert(rt[u], a[u], 31);\n    for (Edge *e = head[u]; e; e = e->nxt) {\n        int v = e->to;\n        if (v == fa[u]) continue;\n        Dfs3(v);\n    }\n}\n\nvoid Init() {\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    for (int i = 1; i <= n - 1; i++) {\n        int x, y;\n        cin >> x >> y;\n        AddEdge(x, y);\n        AddEdge(y, x);\n    }\n    Dfs1(1, 0, 1);\n    Dfs2(1, 1);\n    rt[0] = NewNode();\n    Dfs3(1);\n    // for (int i = 0; i <= n; i++) {\n    //     cerr << i << \" :\\n\";\n    //     Print(rt[i], 31, 0);\n    //     cerr << \"\\n\";\n    // }\n    // cerr << \"*\";\n}\n\nvoid Work() {\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n        int x, y, k;\n        cin >> x >> y >> k;\n        x ^= ans;\n        int lca = Lca(x, y);\n        ans = QueryKth(rt[x], rt[y], rt[lca], rt[fa[lca]], 31, k, 0);\n        cout << ans << \"\\n\";\n    }\n}\n\nint main() {\n    Init();\n    Work();\n    return 0;\n}\n```",
        "postTime": 1567236707,
        "uid": 126376,
        "name": "Irelia\u10e6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u5b89\u5229\u4e00\u53d1\u6211\u7684[blog](https://www.cnblogs.com/bztMinamoto/p/9392425.html)\n\n\u5176\u5b9e\u5c31\u662f\u4e2a\u5f88\u7b80\u5355\u7684\u4e3b\u5e2d\u6811\uff0c\u53ea\u8981\u628a\u5728\u5e8f\u5217\u4e0a\u7684\u5efa\u6811\u6539\u6210\u5728\u6811\u4e0a\u5efa\u5c31\u53ef\u4ee5\u4e86\n\u867d\u7136\u6211\u4e5f\u662f\u4eca\u5929\u770b\u5230\u8fd9\u9053\u9898\u770b\u5b8c\u9898\u89e3\u624d\u77e5\u9053\u600e\u4e48\u5728\u6811\u4e0a\u5efa\u4e3b\u5e2d\u6811\n\n\u5173\u4e8e\u8def\u5f84\uff0c\u53ef\u4ee5\u5728\u6811\u4e0a\u5dee\u5206\u4e00\u4e0b\u7528$sum[l]+sum[r]-sum[lca]-sum[lca_fa]$\n\n\u7136\u540e\u56e0\u4e3a\u8981\u6c42lca\uff0c\u6240\u4ee5\u5728\u6811\u5256dfs\u7684\u65f6\u5019\u987a\u4fbf\u5efa\u4e00\u4e0b\u4e3b\u5e2d\u6811\u5c31\u597d\u4e86\n\n\u5177\u4f53\u5b9e\u73b0\u8bf7\u53c2\u8003\u4ee3\u7801\n```\n//minamoto\n#include<bits/stdc++.h>\n#define N 100005\n#define M 2000005\nusing namespace std;\n#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline int read(){\n    #define num ch-'0'\n    char ch;bool flag=0;int res;\n    while(!isdigit(ch=getc()))\n    (ch=='-')&&(flag=true);\n    for(res=num;isdigit(ch=getc());res=res*10+num);\n    (flag)&&(res=-res);\n    #undef num\n    return res;\n}\nint sum[M],L[M],R[M];\nint a[N],b[N],rt[N];\nint fa[N],sz[N],d[N],ver[N<<1],Next[N<<1],head[N],son[N],top[N];\nint n,q,m,cnt=0,tot=0,ans=0;\nvoid update(int last,int &now,int l,int r,int x){\n    sum[now=++cnt]=sum[last]+1;\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    if(x<=mid) R[now]=R[last],update(L[last],L[now],l,mid,x);\n    else L[now]=L[last],update(R[last],R[now],mid+1,r,x);\n}\ninline void add(int u,int v){\n    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;\n    ver[++tot]=u,Next[tot]=head[v],head[v]=tot;\n}\nvoid dfs(int u){\n    sz[u]=1,d[u]=d[fa[u]]+1;\n    update(rt[fa[u]],rt[u],1,m,a[u]);\n    for(int i=head[u];i;i=Next[i]){\n        int v=ver[i];\n        if(v==fa[u]) continue;\n        fa[v]=u,dfs(v);\n        sz[u]+=sz[v];\n        if(!son[u]||sz[v]>sz[son[u]]) son[u]=v;\n    }\n}\nvoid dfs(int u,int tp){\n    top[u]=tp;\n    if(!son[u]) return;\n    dfs(son[u],tp);\n    for(int i=head[u];i;i=Next[i]){\n        int v=ver[i];\n        if(v==son[u]||v==fa[u]) continue;\n        dfs(v,v);\n    }\n}\nint LCA(int x,int y){\n    while(top[x]!=top[y])\n    d[top[x]]>=d[top[y]]?x=fa[top[x]]:y=fa[top[y]];\n    return d[x]>=d[y]?y:x;\n}\nint query(int ql,int qr,int lca,int lca_fa,int l,int r,int k){\n    if(l>=r) return l;\n    int x=sum[L[ql]]+sum[L[qr]]-sum[L[lca]]-sum[L[lca_fa]];\n    int mid=(l+r)>>1;\n    if(x>=k) return query(L[ql],L[qr],L[lca],L[lca_fa],l,mid,k);\n    else return query(R[ql],R[qr],R[lca],R[lca_fa],mid+1,r,k-x);\n}\nint main(){\n    //freopen(\"testdata.in\",\"r\",stdin);\n    n=read(),q=read();\n    for(int i=1;i<=n;++i)\n    b[i]=a[i]=read();\n    sort(b+1,b+1+n);\n    m=unique(b+1,b+1+n)-b-1;\n    for(int i=1;i<=n;++i)\n    a[i]=lower_bound(b+1,b+1+m,a[i])-b;\n    for(int i=1;i<n;++i){\n        int u=read(),v=read();\n        add(u,v);\n    }\n    dfs(1),dfs(1,1);\n    while(q--){\n        int x,y,z,lca;\n        x=read(),y=read(),z=read();\n        x^=ans,lca=LCA(x,y);\n        ans=b[query(rt[x],rt[y],rt[lca],rt[fa[lca]],1,m,z)];\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n```",
        "postTime": 1532951734,
        "uid": 41781,
        "name": "bztMinamoto",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "## \u9898\u76ee\u5927\u610f\n\n\u5728\u6811\u4e0a\u4e24\u70b9\u95f4\u627e\u70b9\u6743\u7b2ck\u5c0f\uff0c \u5f3a\u5236\u5728\u7ebf\n\n## \u601d\u8def\n\n\u7b2ck\u5c0f\u662f\u4e3b\u5e2d\u6811\u57fa\u672c\u64cd\u4f5c\n\n\u800c\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u5f88\u5bb9\u6613\u60f3\u5230\u6811\u4e0a\u5dee\u5206\n\n\u56e0\u6b64\uff0c\u53ea\u9700\u8981\u6211\u4eec\u5728\u6811\u4e0a\u5efa\u4e00\u4e2a\u4e3b\u5e2d\u6811\u5c31\u89e3\u51b3\u4e86\u8fd9\u9053\u9898\n\n\u5177\u4f53\u600e\u4e48\u64cd\u4f5c\u5462\uff1f\n\n\u6211\u4eec~~\u770b\u770b\u9898\u89e3~~\u8ba4\u771f\u601d\u8003\u53d1\u73b0\n\n\u6811\u7684\u7236\u8282\u70b9\u548c\u5b50\u8282\u70b9\u7ef4\u62a4\u7684\u4fe1\u606f\u5176\u5b9e\u5dee\u4e0d\u591a\n\n\n\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u4ece\u6839\u8282\u70b9\u5f00\u59cb\uff0c \u7531\u5b50\u8282\u70b9\u7ee7\u627f\u7236\u8282\u70b9\u7684\u4fe1\u606f\u5f00\u59cb\u5728\u6811\u4e0a\u5efa\u4e3b\u5e2d\u6811\uff0c \u8fd9\u9053\u9898\u5c31\u89e3\u51b3\u4e86\n\n\u6211\u89c9\u5f97\u81ea\u5df1\u7684\u4ee3\u7801\u53ef\u8bfb\u6027\u8fd8\u662f\u5f88\u5f3a\u7684\n\n````cpp\n\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define id(u) (lower_bound(b + 1, b + 1 + tot, a[u]) - b)\n\nconst int maxn = 1e6 + 1;\n\ninline int read()\n{\n\tregister int x = 0, ch = getchar(), f = 1;\n\twhile(!isdigit(ch)) {if(ch == '-') f = -1; ch = getchar();}\n\twhile(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n\treturn x * f;\n}\n\nint n, tot, m;\n\nint a[maxn], b[maxn];\n\nstruct tree{\n\tint l, r;\n\tint sum;\n}t[maxn];\n\nstruct node{\n\tint ne;\n\tint to;\n}e[maxn << 1];\n\nint cnt, head[maxn];\n\nint dep[maxn], fa[maxn][21], rt[maxn];\n\nvoid add(int x, int y)\n{\n\te[++  cnt].to = y;\n\te[cnt].ne = head[x];\n\thead[x] = cnt;\n}\n\nvoid dfs(int u, int d)\n{\n\tdep[u] = d;\n\tfor(int i = 1; i <= 19; i ++)\n\t{\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\t}\n\tfor(int i = head[u]; i; i = e[i].ne)\n\t{\n\t\tint v = e[i].to;\n\t\tif(v == fa[u][0]) continue;\n\t\tfa[v][0] = u;\n\t\tdfs(v, d + 1);\n\t}\n}\n\nint add(int pre, int l, int r, int x)\n{\n\tint p = ++ cnt;\n\tt[p] = t[pre];\n\tt[p].sum ++;\n\tint mid = l + r >> 1;\n\tif(l < r)\n\t{\n\t\tif(x <= mid) t[p].l = add(t[pre].l, l, mid, x);\n\t\telse t[p].r = add(t[pre].r , mid + 1, r, x);\n\t}\n\treturn p;\n}\n\nvoid dfs2(int u)\n{\n\trt[u] = add(rt[fa[u][0]], 1, tot, id(u));\n\tfor(int i = head[u]; i; i = e[i].ne)\n\t{\n\t\tint v = e[i].to;\n\t\tif(v == fa[u][0]) continue;\n\t\tdfs2(v);\n\t}\n}\n\nint LCA(int u, int v)\n{\n\tif(dep[u] > dep[v]) std:: swap(u, v);\n\tfor(int d = dep[v] - dep[u], i = 0; d; d >>= 1, i ++)\n\t{\n\t\tif(d & 1) v = fa[v][i];\n\t}\n\tif(u == v) return u;\n\tfor(int i = 19; i >= 0; i --)\n\t{\n\t\tif(fa[u][i] != fa[v][i])\n\t\t{\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\nint query(int x, int y, int z, int w, int l, int r, int k)\n{\n\tif(l == r) return l;\n\tint sum = t[t[x].l].sum + t[t[y].l].sum - t[t[z].l].sum - t[t[w].l].sum;\n\tint mid = l + r >> 1;\n\tif(sum >= k ) return query(t[x].l, t[y].l, t[z].l, t[w].l, l, mid, k);\n\telse return query(t[x].r, t[y].r, t[z].r, t[w].r, mid + 1, r, k - sum);\n}\n\nint main()\n{\n\tn = read();\n\tm = read();\n\tfor(int i = 1; i <= n; i ++) a[i] = read(), b[i] = a[i];\n\tfor(int i = 1; i < n; i ++)\n\t{\n\t\tint x = read(), y = read();\n\t\tadd(x, y), add(y, x);\n\t}\n\tstd:: sort(b + 1, b + 1 + n);\n\ttot = unique(b + 1, b + 1 + n) - b - 1;\n\tdfs(1, 0);\n\tdfs2(1);\n\tint lastans = 0;\n\twhile(m --)\n\t{\n\t\tint x = read() ^ lastans;\n\t\tint y = read();\n\t\tint k = read();\n\t\tint z = LCA(x, y);\n\t\tlastans = b[query(rt[x], rt[y], rt[z], rt[fa[z][0]], 1, tot, k)];\n\t\tprintf(\"%d\\n\", lastans);\n\t}\n}\n\n\n`````\n",
        "postTime": 1565751255,
        "uid": 142510,
        "name": "_October_",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "~~emmmLCA\u6c42\u9519\u4e86\u7136\u540edebug\u4e861h\u7684\u4e22\u4eba\u4e8b\u8ff9\u6211\u662f\u4e0d\u4f1a\u8bf4\u7684~~\n\n\u4e00\u5f00\u59cb\u770b\u5230\u8fd9\u4e2a\u9898\u4ee5\u4e3a\u662f\u70b9\u5206\uff0c\u540e\u6765\u53d1\u73b0\u6ca1\u6cd5\u505a\u3002\n\n\u73b0\u5728\u505a\u4e3b\u5e2d\u6811\u7684\u65f6\u5019\u505a\u5230\u8fd9\u4e2a\u9898\u4e86 \n\n\u5c31\u60f3\u5728DFS\u5e8f\u4e0a\u641e\u4e8b\u60c5\u2026\u2026\u5c31\u50cf\u94fe\u5256\u4e00\u6837\u2026\u2026\u7136\u540eGG\u4e86\n\n\u5077\u770b\u4e86\u4e00\u773c\u9898\u89e3\u7684\u7b2c\u4e00\u884c(\u5212\u6389)\u53d1\u73b0\u7528Root[i]\u8868\u793a\u8def\u5f84[1,i]\u60c5\u51b5\n\n\u7136\u540e\u5c31\u6ca1\u4ec0\u4e48\u601d\u7ef4\u96be\u5ea6\u4e86\u2026\u2026\n\n\u5bf9\u4e8e\u8def\u5f84[u,v]\u7684\u79bb\u6563\u5316\u540e\u7684\u503c\u57df\u60c5\u51b5\n\u6211\u4eec\u53ef\u4ee5\u7528segt[v]+segt[u]-segt[lca]-segt[father[lca]]\u6765\u8ba1\u7b97\n\n\u7136\u540e\u5c31\u662f\u6c42\u7b2ck\u5927\u7684\u6a21\u677f\u4e86\n\n\u5efa\u6811\u7684\u65f6\u5019\u6709\u70b9\u5c0f\u6280\u5de7(\u89c1[\u4ee3\u7801](http://www.cnblogs.com/refun/p/8685692.html)) ",
        "postTime": 1522677314,
        "uid": 41890,
        "name": "Refun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u5f3a\u5236\u5728\u7ebf\u7684\u8bdd\u5c31\u53ea\u80fd\u4e3b\u5e2d\u6811\u4e86\u3002\n\n\n\u5b66\u7684\u4e3b\u5e2d\u6811\u53ea\u80fd\u5904\u7406\u5e8f\u5217\uff0c \u600e\u4e48\u529e\u5462\uff1f\n\n\n\u5176\u5b9edfs\u5e8f\u4e5f\u662f\u4e2a\u5e8f\u52172333\uff0c \u4e8e\u662f\u6211\u4eec\u5c31\u53ef\u4ee5\u5bf9dfs\u5e8f\u5efa\u4e3b\u5e2d\u6811\u4e86\n\n\n\u53ea\u4e0d\u8fc7root[i] \u4e0d\u662f\u6307\u5411 root[i-1]\uff0c \u800c\u662f\u6307\u5411\u4e86dfn[fa[re[i]]], i \u662f\u5f53\u524d\u70b9\u7684dfs\u5e8f\uff0cre[i]\u662f\u5f53\u524d\u70b9\uff0c \u524d\u7f00\u548c\u4e5f\u4e0d\u662f\u5e8f\u5217\u524d\u7f00\u548c\u4e86\uff0c \u662f\u6811\u4e0a\u524d\u7f00\u548c\n\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#define lson l, m, lch[now]\n#define rson m+1, r, rch[now]\n#define N 100005\nusing namespace std;\nstruct node{\n    int a, b, c, n;\n}d[N * 2];\nint lch[N * 20], rch[N * 20], rt[N * 20], sum[N * 20], dfn[N], h[N], re[N];\nint siz[N], top[N], son[N], fa[N], dep[N], w[N], tot, cnt, z, p, sz;\nint pai[N], v[N];\nvoid cr(int a, int b){\n    d[++z].a = a; d[z].b = b; d[z].n = h[a]; h[a] = z;\n}\nvoid dfs1(int a){\n    int i, b;\n    siz[a] = 1;\n    dfn[a] = ++cnt;\n    re[cnt] = a;\n    for(i = h[a]; i; i = d[i].n){\n        b = d[i].b;\n        if(b != fa[a]){\n            dep[b] = dep[a] + 1;\n            fa[b] = a;\n            dfs1(b);\n            if(siz[b] >= siz[son[a]]) son[a] = b;\n            siz[a] += siz[b];\n        }\n    }\n}\nvoid dfs2(int a, int tp){\n    int i, b;\n    top[a] = tp;\n    if(son[a]) dfs2(son[a], tp);\n    for(i = h[a]; i; i = d[i].n){\n        b = d[i].b;\n        if(b != fa[a] && son[a] != b) dfs2(b, b);\n    }\n}\nvoid update(int l, int r, int &now, int las, int pos){\n    now = ++p;\n    sum[now] = sum[las] + 1;\n    if(l == r) return;\n    lch[now] = lch[las];\n    rch[now] = rch[las];\n    int m = l+r>>1;\n    if(pos <= m) update(lson, lch[las], pos);\n    else update(rson, rch[las], pos);\n}\nint getlca(int a, int b){\n    int f1 = top[a], f2 = top[b];\n    while(f1 != f2){\n        if(dep[f1] < dep[f2]) swap(f1, f2), swap(a, b);\n        a = fa[f1], f1 = top[a];\n    }\n    return dep[a] < dep[b] ? a : b;\n}\nint query(int l, int r, int k){\n    int a = l, b = r, c = getlca(a, b), d = fa[c], mid, cntt;\n    a = rt[dfn[a]], b = rt[dfn[b]], c = rt[dfn[c]], d = rt[dfn[d]];\n    l = 1, r = sz;\n    while(l < r){\n        mid = l+r>>1;\n        cntt = sum[lch[a]] + sum[lch[b]] - sum[lch[c]] - sum[lch[d]];\n        if(cntt >= k) r = mid, a = lch[a], b = lch[b], c = lch[c], d = lch[d];\n        else l = mid+1, a = rch[a], b = rch[b], c = rch[c], d = rch[d], k -= cntt;\n    }\n    return v[l];\n}\nint main(){\n    int i, j, n, m, lastans = 0, k, t, a, b, c;\n    scanf(\"%d%d\", &n, &m);\n    for(i = 1; i <= n; i++) scanf(\"%d\", &w[i]);\n    for(i = 1; i < n; i++){\n        scanf(\"%d%d\", &a, &b);\n        cr(a, b); cr(b, a);\n    }\n    dfs1(1); \n    dfs2(1, 1);\n    for(i = 1; i <= n; i++) v[i] = pai[i] = w[i];\n    sort(v + 1, v + i);\n    sz = unique(v + 1, v + 1 + n) - (v + 1);\n    for(i = 1; i <= n; i++) pai[i] = lower_bound(v + 1, v + 1 + sz, w[i]) - v;\n    for(i = 1; i <= n; i++){\n        t = re[i];\n        update(1, sz, rt[i], rt[dfn[fa[t]]], pai[t]);\n    }\n    while(m--){\n        scanf(\"%d%d%d\", &a, &b, &k);\n        a ^= lastans;\n        lastans = query(a, b, k);\n        if(m >= 1) printf(\"%d\\n\", lastans);\n        else printf(\"%d\", lastans);\n    }\n    return 0;\n}\n```",
        "postTime": 1510141420,
        "uid": 31619,
        "name": "Hzxleo4",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u6b64\u9898\u6211\u4ea4\u4e8620\u6b21\uff0c\u4e00\u5171A\u4e863\u6b21\uff0c\u7b2c\u4e00\u6b21\u662f\u7528\u522b\u4eba\u4ee3\u7801\u5237\u6389\u7684\uff0c\u7b2c\u4e8c\u6b21\u662f\u81ea\u5df1\u628a\u81ea\u5df1RE\u4e86\u5341\u51e0\u6b21\u7684\u7a0b\u5e8f\u786c\u662f\u4ece11:40\u8c03\u523015:20\uff0c\u996d\u90fd\u6ca1\u5403\uff0c\u7ec8\u4e8e\u7ed9debug\u51fa\u6765\u4e86\uff0c\u5c31\u662f\u79bb\u6563\u5316\u6253\u7684\u4e0d\u5bf9= =\uff0c\u53ef\u662f\u90a3\u79cd\u79bb\u6563\u5316\u6253\u53d1\u6211\u6253\u4e86\u597d\u51e0\u5e74\uff0c\u90fd\u6ca1\u9519\u8fc7\uff0c\u53c8\u6ca1\u6570\u636e\uff0c\u5934\u75bc\u3002\u7b2c\u4e09\u6b21A\u662f\u52a0\u4e86\u8f93\u51fa\u4f18\u5316\uff0c\u7ed3\u679c\u8fd8\u6162\u4e864ms\uff0c(\u2565\u256f^\u2570\u2565)\n\n\n\u63a8\u4e00\u6ce2\u5e7f\u544a\uff1ahttp://blog.csdn.net/no1\\_terminator/article/details/77601599\n\n\n\u6211\u7684\u535a\u5ba2\u5199\u7684\u662f\u5165\u95e8\u6559\u7a0b\uff0c\u8fd9\u91cc\u5c31\u7b80\u6d01\u7684\u8bb2\u4e00\u4e0b\u5427\uff1a\n\n\n\u8003\u8651\u4e00\u4e2a\u6811\u4e0a\u5dee\u5206\uff0c\u6211\u4eec\u9700\u8981\u8ba1\u7b97u\u5230v\u7684\u8def\u5f84\u4e0a\u7684\u7b2ck\uff0c\u800c\u6211\u4eec\u6784\u5efa\u7684\u4e3b\u5e2d\u6811\u90fd\u662f\u7ef4\u62a4u\u5230\u6839\uff0cv\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\uff0c\u6839\u636e\u5bb9\u65a5\u539f\u7406\u7684\u4e00\u5c0f\u90e8\u5206\uff0c\u8fd9\u91cc\u6211\u4eec\u628asum[u]+sum[v]-sum[lca[u]]-sum[father[lca[u,v]]]\u5c31\u662f\u6211\u4eec\u9700\u8981\u7684\u6570\u5b57\u7684\u4e2a\u6570\uff0c\u4e0ek\u6bd4\u8f83\u4e00\u4e0b\u5927\u5c0f\uff0c\u9012\u5f52\u5230\u5de6\u53f3\u513f\u5b50\u91cc\u641e\u4e00\u641e\u5c31\u884c\u4e86\u3002\n\n\n\u53c2\u8003\u4ee3\u7801\uff08\u63d0\u4ea4\u4ee3\u7801\u65f6\u52a1\u5fc5\u624b\u52a8\u5c06\u8bed\u8a00\u8c03\u6210C++\uff0c\u800cC++11\u4f1a\u7f16\u8bd1\u9519\u8bef\uff09\uff1a\n\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\nusing namespace std;\nconst int Logn=20;\nconst int N=201000;\nconst int INF=0x3f3f3f3f;\nconst int M=4100000;\nstruct Array{\n    int x,idx;\n    bool operator < (const Array &rhs) const{\n        return x<rhs.x;\n    }\n}a[N];\nstruct TreeNode{\n    int L,R,sum;\n}T[M];\nstruct Edge{\n    int to,next;\n}e[N*2];\nint b[N],head[N],root[N],fa[N][Logn+5],rank[N],dep[N];\nint tn,n,m,EdgeCnt=0,T_cnt=1;\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    return x*f;\n}\nvoid write(int x){\n    if (x<0)x=-x;\n    if (x>=10)write(x/10);\n    putchar(x%10+48);\n}\nvoid addedge(int u,int v){\n    int p=++EdgeCnt;\n    e[p].to=v;e[p].next=head[u];\n    head[u]=p;\n}\nvoid insert(int &now,int val,int l=1,int r=tn){\n    T[T_cnt++]=T[now];now=T_cnt-1;\n    T[now].sum++;\n    if (l==r)return;\n    int mid=(l+r)>>1;\n    if (val<=mid)insert(T[now].L,val,l,mid);\n        else insert(T[now].R,val,mid+1,r);\n}\nint query(int a,int b,int c,int d,int k,int l=1,int r=tn){\n    if (l==r)return l;\n    int t=T[T[a].L].sum+T[T[b].L].sum-T[T[c].L].sum-T[T[d].L].sum;\n    int mid=(l+r)>>1;\n    if (k<=t)return query(T[a].L,T[b].L,T[c].L,T[d].L,k,l,mid);\n        else return query(T[a].R,T[b].R,T[c].R,T[d].R,k-t,mid+1,r);\n}\nvoid dfs(int u){\n    root[u]=root[fa[u][0]];\n    insert(root[u],rank[u]);\n    for (int p=head[u];p;p=e[p].next){\n        int v=e[p].to;\n        if (v!=fa[u][0]){\n            fa[v][0]=u;\n            dep[v]=dep[u]+1;\n            dfs(v);\n        }\n    }\n}\nint LCA(int u,int v){\n    if (dep[u]<dep[v])swap(u,v);\n    for (int k=Logn-1;k>=0;k--)\n        if (dep[fa[u][k]]>=dep[v])u=fa[u][k];\n    if (u==v)return u;\n    for (int k=Logn-1;k>=0;k--)\n        if (fa[u][k]!=fa[v][k]){u=fa[u][k],v=fa[v][k];}\n    return fa[u][0];\n}\nint main(){\n    n=read(),m=read();\n    for (int i=1;i<=n;i++){\n        a[i].x=read(),a[i].idx=i;\n    }\n    sort(a+1,a+n+1);\n    a[0].x=-INF;\n    for (int i=1;i<=n;i++){\n        rank[a[i].idx]=rank[a[i-1].idx]+(a[i].x!=a[i-1].x);\n        b[rank[a[i].idx]]=a[i].x;\n    }\n    tn=rank[a[n].idx];\n    for (int i=1;i<n;i++){\n        int u=read(),v=read();\n        addedge(u,v);addedge(v,u);\n    }\n    fa[1][0]=0;root[0]=0;dep[1]=1;dfs(1);\n    for (int i=1;i<Logn;i++)\n        for (int j=1;j<=n;j++)\n            fa[j][i]=fa[fa[j][i-1]][i-1];\n    int ans=0;\n    for (int i=1;i<=m;i++){\n        int u=read(),v=read(),k=read();\n        u^=ans;\n        int tt=LCA(u,v);\n        int tmp=query(root[u],root[v],root[tt],root[fa[tt][0]],k);\n        ans=b[tmp];\n        write(ans);puts(\"\");\n    }\n    return 0;\n}\n```",
        "postTime": 1503819632,
        "uid": 54916,
        "name": "I_AM_HelloWord",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "### \u3010\u9898\u76ee\u5927\u610f\u3011\n\u5728\u7ebf\u6c42\u4e24\u70b9\u95f4\u7684k\u5c0f\u503c\n\n\n------------\n\n### \u3010\u5206\u6790\u3011\n\u663e\u7136\u53ef\u4ee5**\u4e8c\u5206**\u679a\u4e3ek\u5c0f\u503c\uff0c\u7136\u540e\u501f\u52a9\u67d0\u79cd\u6570\u636e\u7ed3\u6784\u5224\u65ad\u94fe\u4e0a\u6709\u591a\u5c11\u4e2a\u5c0f\u4e8e\u7b49\u4e8e\u6b64\u503c\u7684\u6570\n\n\n------------\n\n### \u3010\u89e3\u6cd5\u3011\n\n#### \u3010\u89e3\u6cd51\u3011\n\n\u65e2\u7136\u548c\u94fe\u6709\u5173\uff0c\u5f88\u5bb9\u6613\u60f3\u5230**\u6811\u5256**\n\n\u5e73\u5e38\u6811\u5256\u53ef\u4ee5\u5957\u4e2a**\u7ebf\u6bb5\u6811**\uff0c\u7136\u540e\u4e8c\u5206\n\n\u4e8c\u5206 * \u6811\u5256 * \u7ebf\u6bb5\u6811 * n\n\nlog  * log * log * n\n\n\u590d\u6742\u5ea6O\uff08n*log2\uff08n\uff09^3\uff09\n\n#### \u3010\u89e3\u6cd52\u3011\n\n\u65e2\u7136\u60f3\u5230\u4e8c\u5206+\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u53c8\u662f\u533a\u95f4k\u5c0f\u503c\n\n\u8fd9\u4e24\u4e2a\u5408\u8d77\u6765\u5c31\u662f**\u4e3b\u5e2d\u6811**\n\n\u53ef\u4ee5\u6811\u5256\u5957\u4e3b\u5e2d\u6811\uff0c\u4e3b\u5e2d\u6811\u4e0a\u4e8c\u5206\n\n\u6811\u5256 * \u4e3b\u5e2d\u6811 * n\n\nlog * log * n\n\n\u590d\u6742\u5ea6O\uff08n*log2\uff08n\uff09^2\uff09\n\n#### \u3010\u89e3\u6cd53\u3011\n\n\u6811\u5256\u662f\u5728\u7ebf\u6570\u636e\u7ed3\u6784\uff0c\u4f46\u6b64\u9898\u5e76\u4e0d\u8981\u6c42\u4fee\u6539\n\n\u53ef\u4ee5\u8003\u8651\u7528\u79bb\u7ebf\u7684\u65b9\u6cd5\u628a\u6811\u5256\u7684\u8fd9\u5c42\u590d\u6742\u5ea6\u524a\u51cf\u4e0b\u6765\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/9chrgvkt.png)\n\n\u4ed4\u7ec6\u89c2\u5bdf\uff0c\u53ef\u4ee5\u53d1\u73b0x\uff0cy\u4e4b\u95f4\u7684\u4fe1\u606f\u53ef\u4ee5\u63cf\u8ff0\u6210\n\nx+y\u2212lca(x,y)\u2212fa[lca(u,v)]\n\n\n\u4e8e\u662f\u6211\u4eec\u5229\u7528\u4e86**\u6811\u4e0a\u5dee\u5206**\u7684\u601d\u60f3\uff0c\u8fd9\u4fbf\u662f**LCA**\n\nLCA\u53ef\u4ee5\u63d0\u524d\u6784\u9020\n\n\uff08 LCA + \u4e3b\u5e2d\u6811 \uff09* n\n\n( log + log ) * n\n\n\u590d\u6742\u5ea6O\uff08n*log2\uff08n\uff09\uff09\n\n\n------------\n\n\n### \u3010\u4ee3\u7801\u3011\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+5,maxe=maxn<<1,maxt=maxn<<5;\nint n,m;\nint num[maxn],b[maxn],cnt;\nint f[maxn][20],dep[maxn];\nint tote,lnk[maxn];\nint tot,rot[maxn];\nint ans;\nstruct why{\n\tint x,id;\n}a[maxn];\nbool cmp1(why x,why y){\n\treturn x.x<y.x;\n}\nbool cmp2(why x,why y){\n\treturn x.id<y.id;\n}\nstruct edge{\n\tint to,nxt;\n}e[maxe];\nstruct ct{\n\tint l,r,s;\n}t[maxt];\nint read(){\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') ret=ret*10+ch-'0',ch=getchar();\n\treturn ret*f;\n}\nvoid add_e(int x,int y){\n\te[++tote]=(edge){y,lnk[x]};\n\tlnk[x]=tote;\n}\n/*\u4ee5\u4e0b\u4e3aLCA*/\nint LCA(int x,int y){\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=19;i>=0;i--){\n\t\tif(dep[f[x][i]]>=dep[y]) x=f[x][i];\n\t\tif(x==y) return x;\n\t}\n\tfor(int i=19;i>=0;i--)\n\tif(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n\treturn f[x][0];\n}\n/*\u4ee5\u4e0b\u4e3a\u4e3b\u5e2d\u6811*/\nint build(int l,int r){\n\tint now=++tot,mid=l+r>>1;\n\tif(l<r){\n\t\tt[now].l=build(l,mid);\n\t\tt[now].r=build(mid+1,r);\n\t}\n\treturn now;\n}\nint update(int pre,int L,int R,int x,int v){\n\tint now=++tot,mid=L+R>>1;\n\tt[now]=t[pre];\n\tt[now].s+=v;\n\tif(L<R){\n\t\tif(x<=mid) t[now].l=update(t[pre].l,L,mid,x,v);\n\t\telse t[now].r=update(t[pre].r,mid+1,R,x,v);\n\t}\n\treturn now;\n}\nint query(int x,int y,int a,int b,int L,int R,int k){\n\tif(L==R){\n\t\treturn L;\n\t}\n\tint mid=L+R>>1,sum=t[t[x].l].s+t[t[y].l].s-t[t[a].l].s-t[t[b].l].s;\n\tif(k<=sum) return query(t[x].l,t[y].l,t[a].l,t[b].l,L,mid,k);\n\telse return query(t[x].r,t[y].r,t[a].r,t[b].r,mid+1,R,k-sum);\n}\n/*\u4ee5\u4e0b\u4e3a\u9884\u5904\u7406*/\nvoid DFS(int x,int fa){\n\trot[x]=update(rot[fa],1,cnt,b[x],1);\n\tdep[x]=dep[fa]+1;\n\tfor(int i=1;i<20;i++) f[x][i]=f[f[x][i-1]][i-1];\n\tfor(int j=lnk[x];j;j=e[j].nxt){\n\t\tint y=e[j].to;\n\t\tif(y!=fa){\n\t\t\tf[y][0]=x;\n\t\t\tDFS(y,x);\n\t\t}\n\t}\n}\nint main(){\n\tfreopen(\"P2633.in\",\"r\",stdin);\n\tfreopen(\"P2633.out\",\"w\",stdout);\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i].x=read(),a[i].id=i;\n\tsort(a+1,a+1+n,cmp1);\n\tnum[++cnt]=a[1].x;\n\tb[a[1].id]=cnt;\n\tfor(int i=2;i<=n;i++){\n\t\tif(a[i].x!=a[i-1].x) ++cnt;\n\t\tnum[cnt]=a[i].x;\n\t\tb[a[i].id]=cnt;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadd_e(x,y),add_e(y,x);\n\t}\n\trot[0]=build(1,cnt);\n\tsort(a+1,a+1+n,cmp2);\n\tDFS(1,0);\n\twhile(m--){\n\t\tint x=read()^ans,y=read(),k=read();\n\t\tint lca=LCA(x,y);\n\t\tprintf(\"%d\\n\",ans=num[query(rot[x],rot[y],rot[lca],rot[f[lca][0]],1,cnt,k)]);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1577461773,
        "uid": 116251,
        "name": "\u7834\u5fc6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u770b\u5230\u67e5\u8be2$k$\u5c0f\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u4e3b\u5e2d\u6811\n\n\u4e3b\u5e2d\u6811\u7684\u4e3b\u8981\u601d\u60f3\u5c31\u662f\u901a\u8fc7\u7ef4\u62a4\u4e00\u4e2a\u524d\u7f00\u548c\u5185\u7684\u4fe1\u606f\u6765\u652f\u6301\u533a\u95f4\u67e5\u8be2\u5e76\u4e14\u8282\u7ea6\u7a7a\u95f4\u5f00\u9500\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u7ef4\u62a4\u4e00\u4e2a\u6811\u4e0a\u524d\u7f00\u548c\uff0c\u67e5\u8be2\u65f6\u5c31\u5904\u7406\u7aef\u70b9\u4ee5\u53ca $lca$ \u5904\u7684\u4fe1\u606f\u5c31\u597d\u4e86\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct node{\n    int ls,rs,sum;\n}node;\n\ntypedef struct edge{\n    int next,to;\n}edge;\n\nedge e[200010];\nnode t[8000010];\nint n,m,v[100010],siz,dep[100010],fa[18][100010],et,tot,head[100010],root[100010],a[100010],lasans;\n\ninline int read(){\n    int num=0,k=1; char c=getchar();\n    while(c>'9' || c<'0') k=(c=='-')?0:k,c=getchar();\n    while(c>='0' && c<='9') num=num*10+c-'0',c=getchar();\n    return k?num:-num;\n}\n\ninline int readopt(){\n    char c=getchar();\n    while(c!='Q' && c!='L') c=getchar();\n    return c=='Q';\n}\n\nvoid addegde(int u,int v){\n    e[++et].to=v; e[et].next=head[u]; head[u]=et;\n    e[++et].to=u; e[et].next=head[v]; head[v]=et;\n}\n\nvoid update(int x) {t[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;}\n\nint build(int l,int r){\n    if(l==r) return ++tot;\n    int cur=++tot,mid=(l+r)>>1;\n    t[cur].ls=build(l,mid); t[cur].rs=build(mid+1,r);\n    update(cur);\n    return cur;\n}\n\nint modify(int o,int l,int r,int q){\n    if(l==r) {t[++tot].sum=t[o].sum+1; return tot;}\n    int mid=(l+r)>>1,cur=++tot;\n    if(q<=mid) t[cur].ls=modify(t[o].ls,l,mid,q),t[cur].rs=t[o].rs;\n    else t[cur].ls=t[o].ls,t[cur].rs=modify(t[o].rs,mid+1,r,q);\n    update(cur);\n    return cur;\n}\n\nint find(int x){\n    int l=0,r=siz+1,mid;\n    while(l+1<r){\n        mid=(l+r)>>1;\n        if(v[mid]<x) l=mid;\n        else r=mid;\n    }\n    return r;\n}\n\nint lca(int x,int y){\n    if(dep[x]<dep[y]) swap(x,y);\n    int dp=dep[x]-dep[y];\n    for(int i=17;i>=0;i--) if(dp>=(1<<i)) x=fa[i][x],dp-=(1<<i);\n    if(x==y) return x;\n    for(int i=17;i>=0;i--){\n        if(!fa[i][x] || fa[i][x]==fa[i][y]) continue;\n        x=fa[i][x]; y=fa[i][y];\n    }\n    return fa[0][x];\n}\n\nvoid dfs(int x,int f){\n    dep[x]=dep[f]+1; fa[0][x]=f; root[x]=modify(root[f],1,siz,find(a[x]));\n    for(int i=1;i<=17;i++) fa[i][x]=fa[i-1][fa[i-1][x]];\n    for(int i=head[x];i;i=e[i].next) if(e[i].to!=f) dfs(e[i].to,x);\n}\n\nint query(int x,int y,int k,int l,int r){\n    int cur[4],ll=lca(x,y),lw,mid;\n    cur[0]=root[x]; cur[1]=root[y]; cur[2]=root[ll]; cur[3]=root[fa[0][ll]];\n    while(l!=r){\n        mid=(l+r)>>1;\n        lw=t[t[cur[0]].ls].sum+t[t[cur[1]].ls].sum-t[t[cur[2]].ls].sum-t[t[cur[3]].ls].sum;\n        if(k<=lw){\n            r=mid;\n            for(int i=0;i<4;i++) cur[i]=t[cur[i]].ls;\n        }\n        else{\n            l=mid+1; k-=lw;\n            for(int i=0;i<4;i++) cur[i]=t[cur[i]].rs;\n        }\n    }\n    return v[l];\n}\n\nint main(){\n    n=read(); m=read();\n    for(int i=1;i<=n;i++) v[++siz]=a[i]=read();\n    sort(v+1,v+1+siz);\n    siz=unique(v+1,v+1+siz)-1-v;\n    for(int i=1;i<n;i++) addegde(read(),read());\n    root[0]=build(1,siz); dfs(1,0);\n    while(m--){\n        int u=read()^lasans,v=read(),k=read();\n        printf(\"%d\\n\",lasans=query(u,v,k,1,siz));\n    }\n}\n\n```",
        "postTime": 1554132510,
        "uid": 100037,
        "name": "kkxhh",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "### \u9898\u610f\uff1a\n\n\u6c42\u9759\u6001\u6811\u4e0a\u7b2ck\u5c0f\uff0c\u5f3a\u5236\u5728\u7ebf\u3002\n\n### \u505a\u6cd5\uff1a\n\n\u521a\u5b66\u4e86\u4e3b\u5e2d\u6811\u5f00\u59cb\u505a\u8fd9\u9898\uff0c\u4e00\u5f00\u59cb\u4ee5\u4e3a\u662f\u6811\u5256\u8fd8\u5728\u60f3\u96f6\u96f6\u788e\u788e\u7684\u533a\u95f4\u600e\u4e48\u5408\u5e76\uff0c\u4f46\u5b9e\u9645\u4e0a\u7528\u6811\u4e0a\u5dee\u5206\u5c31\u597d\u4e86\u3002\n\n\u5728\u6811\u4e0a\u5efa\u4e3b\u5e2d\u6811\uff0c\u628aa\u7ed3\u70b9\u57fa\u4e8efa[a]\u7ed3\u70b9\u5efa\u6811\u3002\n\n\u67e5\u8be2\u7684\u65f6\u5019\u7528$sum[x]+sum[y]-sum[lca]-sum[fa[lca]]$\u5224\u65ad\n\n```c++\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define maxn 100001\nusing namespace std;\nstruct node{\n\tint h,z;\n}a[maxn];\nstruct edge{\n\tint next,to;\n}w[maxn<<1];\nint head[maxn*25],edg,cnt,top[100010*25],sum[maxn*25];\nint c[maxn],hs[maxn],size[maxn],ls[maxn*25],n,m;\nint b[maxn],deep[maxn],fa[maxn],rs[maxn*25],bs[maxn];\ninline bool cmp(node c,node d){\n\treturn c.z<d.z;\n}\ninline void add(int x,int y){\n\tw[++edg].next=head[x];\n\tw[edg].to=y; head[x]=edg;\n}\nvoid built(int &rt,int l,int r){\n\trt=++cnt;\n\tif (l==r) return;\n\tint mid=(l+r)>>1;\n\tbuilt(ls[rt],l,mid);\n\tbuilt(rs[rt],mid+1,r);\n}\nint build(int rt,int l,int r,int p){\n\tint t=++cnt;\n\tls[t]=ls[rt],rs[t]=rs[rt],sum[t]=sum[rt]+1;\n\tif (l==r) return t;  int mid=(l+r)>>1;\n\tif (p<=mid) ls[t]=build(ls[rt],l,mid,p);\n\telse rs[t]=build(rs[rt],mid+1,r,p);\n\treturn t;\n}\n//void build(int rt,int &now,int l,int r,int p){\n//\tnow=++cnt; sum[now]=sum[rt]+1;\n//\tif (l==r) return;\n//\tint mid=(l+r)>>1;\n//\tif (p<=mid) rs[now]=rs[rt],build(ls[rt],ls[now],l,mid,p);\n//\telse ls[now]=ls[rt],build(rs[rt],rs[now],mid+1,r,p);\n//}\nvoid dfs1(int x,int da){\n\tfa[x]=da; size[x]=1;\n\tbs[x]=build(bs[da],1,b[a[n].h],b[x]);\n\tfor (int i=head[x]; i; i=w[i].next){\n\t\tif (w[i].to!=da){\n\t\t\tdeep[w[i].to]=deep[x]+1;\n\t\t\tdfs1(w[i].to,x);\n\t\t\tsize[x]+=size[w[i].to];\n\t\t\tif (size[w[i].to]>size[hs[x]]) hs[x]=w[i].to;\n\t\t}\n\t}\n}\nvoid dfs2(int x,int tp){\n\ttop[x]=tp;\n\tif (hs[x]) dfs2(hs[x],tp);\n\tfor (int i=head[x]; i; i=w[i].next)\n\t\tif (w[i].to!=fa[x]&&w[i].to!=hs[x])\n\t\t\tdfs2(w[i].to,w[i].to);\n}\ninline int lca(int x,int y){\n\twhile (top[x]!=top[y]){\n\t\tif (deep[top[x]]<deep[top[y]]) swap(x,y);\n\t\tx=fa[top[x]];\n\t}\n\tif (deep[x]<deep[y]) swap(x,y);\n\treturn y;\n}\nint query(int x,int y,int da,int gr,int l,int r,int k){\n\tif (l>=r) return l; int mid=(l+r)>>1;\n\tint num=sum[ls[x]]+sum[ls[y]]-sum[ls[da]]-sum[ls[gr]];\n\tif (num>=k) return query(ls[x],ls[y],ls[da],ls[gr],l,mid,k);\n\telse return query(rs[x],rs[y],rs[da],rs[gr],mid+1,r,k-num);\n}\nint main(){\n\tint last=0,x,y,z;\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%d\",&a[i].z);\n\t\ta[i].h=i;\n\t}\n\tsort(a+1,a+n+1,cmp); a[0].z=-1;\n\tfor (int i=1; i<=n; i++){\n\t\tb[a[i].h]=b[a[i-1].h];\n\t\tif (a[i].z!=a[i-1].z) b[a[i].h]++;\n\t\tc[b[a[i].h]]=a[i].z;\n\t}\n\tfor (int i=1; i<=n-1; i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y); add(y,x);\n\t}\n//\tbuilt(bs[0],1,b[a[n].h]);\n\tdeep[1]=1; dfs1(1,0); dfs2(1,1);\n\twhile (m--){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tx^=last; int lc=lca(x,y);\n\t\tlast=c[query(bs[x],bs[y],bs[lc],bs[fa[lc]],1,b[a[n].h],z)];\n\t\tprintf(\"%d\\n\",last);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546759522,
        "uid": 63661,
        "name": "Taduro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "\u600e\u4e48\u8fd8\u662f\u6ca1\u6709\u7528$vector$\u7684\u5462\uff0c$sort+unique$\u53bb\u91cd\u591a\u65b9\u4fbf\n\n\u8001\u4e45\u5c31\u5b66\u4e86\u4e3b\u5e2d\u6811\uff0c\u7adf\u7136\u6f0f\u4e86\u5b83\uff0c\u65e2\u7136\u667a\u63a8\u5230\u5c31\u505a\u4e86\n\n\u5b83\u628a\u4e3b\u5e2d\u6811\u7684\u533a\u95f4\u7b2c$k$\u5927\u653e\u5230\u4e86\u6811\u4e0a\n\n\u8fd9\u6837\u5c31\u4e0d\u80fd\u5355\u7eaf\u7684\u6309\u7167\u5e8f\u5217\u6765\u66f4\u65b0\uff08\u5efa\u6811\uff09\u4e86\n\n\u6240\u4ee5\u6309\u7167$dfs$\u7684\u987a\u5e8f\u66f4\u65b0$root$\uff0c\u4f20\u53c2\u4f20\u4e0a\u4e00\u4e2a\u8282\u70b9\uff0c\u56e0\u4e3a\u8981\u6cbf\u7528\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u6811\n\n\u8be2\u95ee\u7684\u65f6\u5019\u5c31\u662f\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u516c\u5f0f\u7684\u5c0f\u53d8\u5f62\n\n\u6c42$lca$\u7528\u7684\u662f\u597d\u5199\u7684\u6811\u5256\n\n\u521a\u5f00\u59cb\u75af\u72c2$RE$\uff0c\u7136\u540e\u5c31\u5f00\u5230\u4e86\u4e5d\u5343\u4e07\u7684\u6570\u7ec4\n\n\u6700\u540e\u53ea\u662f\u4e2a$zz$\u9519\u8bef\u800c\u5df2\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <complex>\n#include <algorithm>\n#include <climits>\n#include <queue>\n#include <map>\n#include <set>\n#include <vector>\n#include <iomanip>\n#define A 500010\n#define B 2010\n\nusing namespace std;\ntypedef long long ll;\nstruct node {\n    int next, to;\n}edge[A];\nstruct OO {\n    int l, r, w;\n}tree[A << 4]; //\u6211\u7684\u539f\u5219\u662f\u5f80\u5927\u4e86\u5f00\uff0c\u8fd9\u91cc\u6d6a\u8d39\u4e86\u4e0d\u5c11\nint head[A], num_edge; //\u53ef\u81ea\u884c\u5c1d\u8bd5\nvoid add_edge(int from, int to) {\n    edge[++num_edge].next = head[from];\n    edge[num_edge].to = to;\n    head[from] = num_edge;\n}\nvector<int> v;\nint n, m, a[A], b[A], x, y, z, cnt, tot, k;\nint siz[A], dep[A], fa[A], son[A], top[A], tp, dfn[A], pre[A], root[A << 4];\n/******************************************************/\n/**********************\u6811\u5256\u6c42lca***********************/\n/******************************************************/\nvoid prepare(int fr) {\n    siz[fr] = 1;\n    for (int i = head[fr]; i; i = edge[i].next) {\n        int ca = edge[i].to;\n        if (ca == fa[fr]) continue;\n        fa[ca] = fr;\n        dep[ca] = dep[fr] + 1;\n        prepare(ca);\n        siz[fr] += siz[ca];\n        if (siz[ca] > siz[son[fr]]) son[fr] = ca;\n    }\n}\nvoid dfs(int fr, int tp) {\n    dfn[fr] = ++cnt, pre[cnt] = fr, top[fr] = tp;\n    if (!son[fr]) return;\n    dfs(son[fr], tp);\n    for (int i = head[fr]; i; i = edge[i].next) {\n        int ca = edge[i].to;\n        if (ca == fa[fr] or ca == son[fr]) continue;\n        dfs(ca, ca);\n    }\n}\nint lca(int x, int y) {\n    while (top[x] != top[y])\n        if (dep[top[x]] >= dep[top[y]])\n            x = fa[top[x]];\n        else y = fa[top[y]];\n    return dep[x] < dep[y] ? x : y;\n}\n/******************************************************/\n/******************************************************/\n/******************************************************/\nvoid build(int &k, int l, int r) {\n    k = ++tot;\n    tree[k].w = 0;\n    if (l == r) return;\n    int m = (l + r) >> 1;\n    build(tree[k].l, l, m);\n    build(tree[k].r, m + 1, r);\n}\nvoid change(int l, int r, int &x, int &y, int k) {\n    tree[++tot] = tree[y];\n    tree[tot].w++;\n    x = tot;\n    if (l == r) return;\n    int m = (l + r) >> 1;\n    if (k <= m) change(l, m, tree[x].l, tree[y].l, k);\n    else change(m + 1, r, tree[x].r, tree[y].r, k);\n}\nint query(int t1, int t2, int t3, int t4, int l, int r, int k) {\n    if (l == r) return l;\n    int m = (l + r) >> 1; //\u770b\u8981\u5f80\u54ea\u8fb9\u8d70\n    int xx = tree[tree[t2].l].w + tree[tree[t1].l].w - tree[tree[t3].l].w - tree[tree[t4].l].w;\n    if (k <= xx) return query(tree[t1].l, tree[t2].l, tree[t3].l, tree[t4].l, l, m, k);\n    else return query(tree[t1].r, tree[t2].r, tree[t3].r, tree[t4].r, m + 1, r, k - xx);\n}\nvoid open(int fr, int faa) { //\u6cbf\u7528faa\u5efa\u81ea\u5df1\n    change(1, v.size(), root[fr], root[faa], a[fr]);\n    for (int i = head[fr]; i; i = edge[i].next) {\n        int ca = edge[i].to;\n        if (ca == fa[fr]) continue;\n        open(ca, fr);\n    }\n}\n\nint main(int argc, char const *argv[]) {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        v.push_back(a[i]);\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    build(root[0], 1, v.size());\n    for (int i = 1; i <= n; i++) a[i] = lower_bound(v.begin(), v.end(), a[i]) - v.begin() + 1;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d%d\", &x, &y);\n        add_edge(x, y);\n        add_edge(y, x);\n    }\n    dep[1] = 1; prepare(1); dfs(1, 1);\n    open(1, 0);\n    int ans = 0;\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d%d%d\", &x, &y, &k); x ^= ans;\n        int ll = lca(x, y);\n        int xx = v[query(root[x], root[y], root[ll], root[fa[ll]], 1, v.size(), k) - 1];\n        printf(\"%d\\n\", xx);\n        ans = xx;\n    }\n}\n```",
        "postTime": 1546005024,
        "uid": 78064,
        "name": "\u826f\u6708\u6faa\u4e8c",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    },
    {
        "content": "## \u4f60\u5168\u90e8RE\u4e86\u5417\uff1f\n\n\u5f88\u6b63\u5e38\uff0c\u56e0\u4e3a\u6211\u4e5f\u8fde\u7eed\u5168RE\u4e866\u6b21\n\n\u90a3re\u7684\u539f\u56e0\u5462\uff1f\u6709\u5f88\u591a\uff0c\u4f46\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5e76\u4e0d\u53ea\u6709\u6570\u7ec4\u5f00\u5c0f\u8fd9\u4e00\u79cd\u53ef\u80fd\uff01\u7531\u4e8eu\u8981\u2026\u2026\u4e0alastans,\u6240\u4ee5\u5f88\u53ef\u80fd\u662f\u4f60\u4e0a\u6b21\u7b97\u9519\uff0c\u7b97\u51fa\u7684u\u5c31\u6570\u7ec4\u8d8a\u754c\u4e86\u3002\n\n\u56e0\u6b64\u5bf9\u4e8e\u8fd9\u9053\u9898\u76ee$ WA\\subset RE$\n\n\u8bf4\u56de\u8fd9\u9053\u9898\u76ee\uff0c\u4ee5\u5f80\u5728\u505a\u4e3b\u5e2d\u6811\u7684\u9898\u65f6\uff0c\u4e00\u822c\u4e0e\u201c\u533a\u95f4\u7b2ck\u5c0f\u201d\u6709\u5173\u3002\u5728\u9762\u5bf9\u8fd9\u7c7b\u95ee\u9898\u65f6\uff0c\u6211\u4eec\u5e38\u4f1a\u8f6c\u5316\u4e3a$[1,l-1]$,$[1,r]$\u4e2d\u5206\u522b\u6709\u591a\u5c11\u5c0f\u4e8ex\u7684\u6570\uff08\u5373\u5bf9\u5e94\u7ebf\u6bb5\u6811\u4e2d\u7b2cmid\u5927\u7684\u6570\uff09\uff0c\u4fbf\u53ef\u8003\u5bdf$[l,r]$\u4e2d\u6709\u591a\u5c11\u5c0f\u4e8ex\u7684\u6570\uff0c\u4ece\u800c\u786e\u5b9a\u7b2ck\u5c0f\u7684\u8303\u56f4\u3002\n\n\u628a\u95ee\u9898\u8f6c\u79fb\u5230\u6811\u4e0a\uff0c\u81ea\u7136\u60f3\u5230\u94feroot~u\u5c31\u662f\u6211\u4eec\u8981\u7684\u201c\u524d\u7f00\u201d\uff0c\u8fd9\u6837\u5728\u94fe\u4e0a\u5c0f\u4e8ex\u7684\u6570\u5b57\u4e2a\u6570\u4fbf\u662f\n\n$ sum=su[ls[u]]+su[ls[v]]-su[ls[lca(u,v)]]-su[ls[fa[lca(u,v)]]]; $\n\n\u8003\u5bdfsum\u662f\u5426\u5927\u4e8ek\u5c31\u80fd\u5224\u5b9a\u5206\u6cbb\u7684\u65b9\u5411\u3002\n\n```\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#define lson ls[u],l,md\n#define rson rs[u],md+1,r\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP(u) for(int i=hd[u],v=e[i].v;i;i=e[i].n,v=e[i].v)\nusing namespace std;\nconst int N=1001000,LG=30,M=LG*N;\nstruct edge{int n,v;}e[N<<1];\nint n,T,u,v,k,fl,totv,cnt,tot,u1,u2,u3,u4,pre,ls[M],rs[M],su[M],rt[N];\nint b[N],hd[N],va[N],d[N],fa[N],wes[N],top[N],sz[N];\nvoid add(int u,int v){e[++fl]=(edge){hd[u],v};hd[u]=fl;}\nvoid DEBUG(){\n\tcout<<\"--------------\"<<endl;\n\tcout<<\"rt:\";FOR(i,0,n) cout<<setw(3)<<rt[i]<<' ';cout<<endl;\n\tcout<<\"id:\";FOR(i,1,cnt) cout<<setw(3)<<i<<' ';cout<<endl;\n\tcout<<\"ls:\";FOR(i,1,cnt) cout<<setw(3)<<ls[i]<<' ';cout<<endl;\n\tcout<<\"rs:\";FOR(i,1,cnt) cout<<setw(3)<<rs[i]<<' ';cout<<endl;\n\tcout<<\"su:\";FOR(i,1,cnt) cout<<setw(3)<<su[i]<<' ';cout<<endl;\n\tcout<<\"--------------\"<<endl;\n}\nvoid bld(int &u,int l,int r){\n\tu=++cnt;\n\tif(l==r) return;\n\tint md=l+r>>1;\n\tbld(lson),bld(rson);\n}\nvoid cha(int &u,int l,int r,int v,int p,int x){\n    u=++cnt;ls[u]=ls[v],rs[u]=rs[v];su[u]=su[v]+1;\n\tif(l==r) return;\n\tint md=l+r>>1;\n\tp<=md?cha(lson,ls[v],p,x):cha(rson,rs[v],p,x);\t\n}\nint ask(int l,int r,int k){\n\tif(l==r) return l;\n\tint md=l+r>>1,sum;\n\tsum=su[ls[u1]]+su[ls[u2]]-su[ls[u3]]-su[ls[u4]];\n\tif(k<=sum){\n\t\tu1=ls[u1],u2=ls[u2],u3=ls[u3],u4=ls[u4];\n\t\treturn ask(l,md,k);\n\t}\n\telse{\n\t\tu1=rs[u1],u2=rs[u2],u3=rs[u3],u4=rs[u4];\n\t\treturn ask(md+1,r,k-sum);\n\t}\n}\nvoid dfs1(int u){\n\tsz[u]=1;\n\tint pp=lower_bound(b+1,b+totv+1,va[u])-b;\n\tcha(rt[u],1,totv,rt[fa[u]],pp,1);\n\tREP(u)if(v!=fa[u]){\n\t\td[v]=d[u]+1,fa[v]=u;\n\t\tdfs1(v);sz[u]+=sz[v];\n\t\tif(sz[v]>sz[wes[u]]) wes[u]=v;\n\t}\n}\nvoid dfs2(int u,int TP){\n\ttop[u]=TP;\n\tif(wes[u]) dfs2(wes[u],TP);\n\tREP(u)if(v!=wes[u] && v!=fa[u]) dfs2(v,v);\n}\nint asklca(int u,int v){\n\tfor(;top[u]!=top[v];u=fa[top[u]])\n\t\tif(d[top[u]]<d[top[v]]) swap(u,v);\n\tif(d[u]<d[v]) swap(u,v);\n\treturn v;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&T);\n\tFOR(i,1,n) scanf(\"%d\",&va[i]),b[i]=va[i];\n\tFOR(i,1,n-1) scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tsort(b+1,b+n+1);\n\ttotv=unique(b+1,b+n+1)-b-1;\n\tbld(rt[0],1,totv);\n\tdfs1(1);dfs2(1,1);\n\twhile(T--){\n\t\tscanf(\"%d%d%d\",&u1,&u2,&k);\n\t\tu1^=pre,u3=asklca(u1,u2),u4=fa[u3];\n\t    u1=rt[u1],u2=rt[u2],u3=rt[u3],u4=rt[u4];\n\t    printf(\"%d\\n\",pre=b[ask(1,totv,k)]);\n\t}\n}\n```",
        "postTime": 1532764101,
        "uid": 62267,
        "name": "BJpers2",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2633 \u3010Count on a tree\u3011"
    }
]