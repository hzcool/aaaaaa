[
    {
        "content": "\u82f1\u6587\u9898\u89e3\uff08\u6700\u4e0b\u6709\uff09\u592a\u957f\u770b\u4e0d\u4e0b\u53bb\u5c31\u53bb\u8bf7\u6559\u4e86\u4e00\u4e0b\u5927\u795e\uff0c\u7136\u540e\u4f18\u5316\u4e86\u4e00\u4e0bO\uff08N\u00b2\uff09\u7684\u7b97\u6cd5\u5c31\u6c34\u8fc7\u4e86\u3002\n\n\u72b6\u6001f[i][j]\u8868\u793a\uff0c\u4ee5i\u4e3a\u6839\u7684\u5b50\u6811\uff0c\u552f\u4e00\u4e00\u6839\u63a5\u5230i\u5e76\u4e14\u4f1a\u5728\u540e\u9762\u7ee7\u7eed\u5f80\u4e0a\u63a5\u7684\u7535\u7ebf\u7684\u5f53\u524d\u957f\u5ea6\u4e3aj\u7684\u60c5\u51b5\u4e0b\u7684\u6700\u5c0f\u4ee3\u4ef7\n\n\u8f6c\u79fb\u6709\u4e09\u79cd\uff08\u84dd\u8272\u4e3a\u5f53\u524d\u52a0\u5165\u8fb9\uff09\n\n1.\u84dd\u8272\u7535\u7ebf\u622a\u65ad\u5728i\n\n2.\u84dd\u8272\u7535\u7ebf\u53d6\u4ee3\u4e4b\u524d\u7684\u7535\u7ebf\u63a5\u5230\u5b50\u6811\u5916\uff0c\u7ea2\u8272\u7535\u7ebf\u622a\u65ad\u5728i\n\n3.\u84dd\u8272\u7535\u7ebf\u622a\u65ad\u5728i\uff0c\u5e76\u4e0e\u7ea2\u8272\u7535\u7ebf\u5408\u5e76\u6210\u4e00\u6761\u7535\u7ebf\uff0c\u53e6\u5916\u7eff\u8272\u7535\u7ebf\u4e0d\u4e00\u5b9a\u5982\u56fe\u8fde\u5230\u5b50\u6811\u5916\n\n\u3010\u4f18\u5316\u3011\n\n\u7528\u961f\u5217\u7ef4\u62a4f\uff08\u5efa\u8bae\u7528vector\uff09\uff0c\u7ef4\u62a4\u4fe1\u606fj\u548cf[i][j]\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6df1\u5ea6\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a\u961f\u5217\uff0c\u6bcf\u5f53\u4e00\u4e2a\u5b69\u5b50\u5b50\u6811\u4fe1\u606f\u66f4\u65b0\u4e86\u961f\u5217\u4fe1\u606f\u540e\uff0c\u5220\u53bb\u961f\u5217\u5185\u7684\u4e24\u79cd\u65e0\u6548\u70b9\uff0c\u4e00\u662f\u5bf9\u4e8e\u76f8\u540c\u7684j\u53ea\u7559\u4e0b\u4e00\u4e2a\u6700\u4f18\u70b9\uff0c\u4e8c\u662f\u5bf9\u4e8ejx>jy\u5e76\u4e14fx[i][j]>fy[i][j],\u628ax\u5220\u9664\u3002PS:\u6b63\u89e3\u662f\u627e\u5230\u67d0\u4e9b\u6027\u8d28\u7136\u540e\u7528\u51f8\u5305\u4f18\u5316\u6811\u4e0adp\n\n\u3010\u5446\u9a6c\u3011\n\n\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<iostream>\n#include<vector>\n#define ll long long\nusing namespace std;\nconst int N=50001;\nstruct st\n{\n    int l; ll co;\n    st(){}\n    st(int x,ll y){l=x; co=y;}\n    ll cal(){return co+l*l;}\n    bool operator <(const st x) const{return l<x.l || (l==x.l && co<x.co);}\n};\nvector <st> f[N],g;\nvector <int> l[N];\nint n,i,x,y;\nbool vis[N];\nvoid dp(int x,int d)\n{\n    vis[x]=1;\n    f[d].clear();\n    bool leaf=1;\n    int m1=l[x].size(),m2,m3;\n    for (int k=0;k<m1;k++)\n        if (!vis[l[x][k]])\n        {\n            leaf=0;\n            dp(l[x][k],d+1);\n            m3=f[d+1].size();\n            for (int i=0;i<m3;i++) f[d+1][i].l++;\n            if (!f[d].size()){f[d]=f[d+1]; continue;}\n            g.clear();\n            m2=f[d].size();\n            for (int i=0;i<m2;i++)\n                for (int j=0;j<m3;j++)\n                    if (!f[d][i].l) g.push_back(st(0,f[d][i].co+f[d+1][j].cal()));\n                    else\n                    {\n                        g.push_back(st(f[d][i].l,f[d][i].co+f[d+1][j].cal()));\n                        g.push_back(st(f[d+1][j].l,f[d+1][j].co+f[d][i].cal()));\n                        g.push_back(st(0,f[d][i].cal()+f[d+1][j].cal()+((f[d][i].l*f[d+1][j].l)<<1)));\n                    }\n            sort(g.begin(),g.end());\n            int num=0;\n            m2=g.size();\n            for (int i=1;i<m2;i++)\n                if (g[i].cal()<g[num].cal()) g[++num]=g[i];\n            g.resize(num+1);\n            f[d]=g;\n        }\n    if (leaf) f[d].push_back(st(0,0));\n}\nint main()\n{\n        scanf(\"%d\\n\",&n);\n        for (i=1;i<n;i++)\n        {\n            scanf(\"%d%d\\n\",&x,&y);\n            l[x].push_back(y);\n            l[y].push_back(x);\n        }\n        dp(1,0);\n        printf(\"%lld\",f[0][0].cal());\n}\n\n```",
        "postTime": 1509458471,
        "uid": 35946,
        "name": "\u795e\u7287\u7684\u849f\u84bb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3023 \u3010[USACO11OPEN]\u710a\u63a5Soldering\u3011"
    }
]