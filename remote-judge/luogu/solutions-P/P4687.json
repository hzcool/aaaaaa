[
    {
        "content": "#### \u9996\u5148\u8003\u8651B=0\u7684\u60c5\u51b5\n#### B=0\u65f6\u6570\u636e\u8981\u6c42\u4e00\u4e2anlogn\u7684\u7b97\u6cd5\uff0c\u7528\u626b\u63cf\u7ebf\u7ef4\u62a4\u7b2ci\u5217\u5230\u7b2cj\u5217\u7684\u6700\u5927\u7a7a\u51fa\u7684\u8ddd\u79bb\uff0c\u82e5\u5927\u4e8ej-i+1\uff0c\u90a3\u4e48\u8bf4\u660e\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u53f3\u79fbj\u3002\u5f53\u6211\u4eec\u6539\u53d8i\u65f6\uff0c\u53c8\u53ef\u4ee5\u53d1\u73b0\u5982\u679ci\u5230j\u662f\u6ee1\u8db3\u8981\u6c42\u7684\uff0c\u90a3\u4e48i+1\u5230j\u4e5f\u662f\u6ee1\u8db3\u8981\u6c42\u7684\u3002\u4e8e\u662f\u5c3a\u53d6\u6cd5+\u7ebf\u6bb5\u6811\u6210\u529f\u5f97\u523065\u5206\n```\nnamespace Subtask1\n{\n  vector<pi > st[N],ed[N];\n  namespace T\n  {\n#define ls (now<<1)\n#define rs (now<<1|1)\n    struct papa\n    {\n      int maxn,lmax,rmax,tag,len;\n      papa():tag(0) {};\n    } tr[N<<2];\n    inline void pushup(res now)\n    {\n      if(tr[now].tag)\n      {\n        tr[now].lmax=tr[now].rmax=tr[now].maxn=0;\n        return;\n      }\n      if(tr[now].len==1)\n      {\n        tr[now].lmax=tr[now].rmax=tr[now].maxn=1;\n        return;\n      }\n      if(tr[ls].lmax==tr[ls].len)\n        tr[now].lmax=tr[ls].lmax+tr[rs].lmax;\n      else\n        tr[now].lmax=tr[ls].lmax;\n      if(tr[rs].rmax==tr[rs].len)\n        tr[now].rmax=tr[rs].rmax+tr[ls].rmax;\n      else\n        tr[now].rmax=tr[rs].rmax;\n      tr[now].maxn=max(tr[ls].rmax+tr[rs].lmax,max(tr[ls].maxn,tr[rs].maxn));\n    }\n    void build_up(res now,res l,res r)\n    {\n      tr[now].maxn=tr[now].lmax=tr[now].rmax=tr[now].len=r-l+1;\n      if(l==r)\n        return;\n      res mid=l+r>>1;\n      build_up(ls,l,mid);\n      build_up(rs,mid+1,r);\n    }\n    void update(res now,res l,res r,res ql,res qr,res c)\n    {\n      if(ql<=l&&r<=qr)\n      {\n        tr[now].tag+=c;\n        pushup(now);\n        return;\n      }\n      res mid=l+r>>1;\n      if(mid>=ql) update(ls,l,mid,ql,qr,c);\n      if(mid<qr) update(rs,mid+1,r,ql,qr,c);\n      pushup(now);\n    }\n  }\n  inline void MAIN()\n  {\n    for(res i=1; i<=p; i++)\n    {\n      res A=read(),B=read(),C=read(),D=read(),k=read();\n      st[A].push_back(make_pair(B,D));\n      ed[C].push_back(make_pair(B,D));\n    }\n    T::build_up(1,1,m);\n    res j=0;\n    for(res i=1; i<=n; i++)\n    {\n      for(; T::tr[1].maxn>=j-i+1&&j<=n;)\n      {\n        j++;\n        for(res k=0; k<st[j].size(); k++)\n          T::update(1,1,m,st[j][k].fi,st[j][k].se,1);\n      }\n      for(res j=0; j<ed[i].size(); j++)\n        T::update(1,1,m,ed[i][j].fi,ed[i][j].se,-1);\n      ans=max(ans,j-i);\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n```\n#### \u73b0\u5728\u8003\u8651B>0\u7684\u60c5\u51b5\uff0c\u4e8c\u5206\u7b54\u6848\u662f\u663e\u7136\u7684\u3002\n#### \u4e4b\u540e\u6211\u4eec\u53ef\u4ee5\u518d\u6b21\u4f7f\u7528\u626b\u63cf\u7ebf\uff0c\u679a\u4e3e\u6bcf\u4e00\u5217\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u4e00\u884c\u4f5c\u4e3a\u5de6\u4e0a\u89d2\u7684\u6700\u5c0f\u4ee3\u4ef7\uff0c\u5219\u7b2c\u4e00\u4e2a\u8282\u70b9\u5c31\u53ef\u4ee5\u8868\u793a\u8fd9\u4e00\u5217\u7684\u6700\u5c0f\u4ee3\u4ef7\u3002\u6bcf\u6b21\u4e00\u4e2a\u77e9\u5f62\u7684\u8986\u76d6\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u6210\u4e24\u6b21\u533a\u95f4\u8986\u76d6\uff0c{(x1,y1),(x2,y2)}\u5f71\u54cd\u7684\u8303\u56f4\u662f{\uff08x1-l+1,x2\uff09,(y1-l+1),y2}(l\u4e3a\u4e8c\u5206\u7684\u957f\u5ea6)\n```\nnamespace Subtask2\n{\n  int ans;\n  struct papa1\n  {\n    int A,B,C,D,k;\n  } a[N];\n  struct papa\n  {\n    int l,r,w;\n    papa():w(0) {};\n    papa(int l0,int r0,int w0):l(l0),r(r0),w(w0) {};\n  };\n  vector<papa> st[N],ed[N];\n  namespace T\n  {\n#define lson (now<<1)\n#define rson (now<<1|1)\n    int tr[N<<2],tag[N<<2];\n    inline void build_up(res now,res l,res r)\n    {\n      tag[now]=tr[now]=0;\n      if(l==r) return;\n      res mid=l+r>>1;\n      build_up(lson,l,mid);\n      build_up(rson,mid+1,r);\n    }\n    inline void pushdown(res now)\n    {\n      if(!tag[now]) return;\n      tag[lson]+=tag[now];\n      tag[rson]+=tag[now];\n      tr[lson]+=tag[now];\n      tr[rson]+=tag[now];\n      tag[now]=0;\n    }\n    inline void pushup(res now)\n    {\n      tr[now]=min(tr[lson],tr[rson]);\n    }\n    inline void update(res now,res l,res r,res ql,res qr,res c)\n    {\n      if(ql<=l&&r<=qr)\n      {\n        tag[now]+=c;\n        tr[now]+=c;\n        return;\n      }\n      pushdown(now);\n      res mid=l+r>>1;\n      if(mid>=ql) update(lson,l,mid,ql,qr,c);\n      if(mid<qr) update(rson,mid+1,r,ql,qr,c);\n      pushup(now);\n    }\n  }\n  inline bool check(res l)\n  {\n    for(res i=1; i<=n-l+1; i++)\n      st[i].clear(),ed[i].clear();\n    T::build_up(1,1,m-l+1);\n    for(res i=1; i<=p; i++)\n    {\n      res A=a[i].A-l+1,B=a[i].B-l+1,C=a[i].C,D=a[i].D,k=a[i].k;\n      A=max(A,1),B=max(B,1);\n      C=min(C,n-l+1),D=min(D,m-l+1);\n      if(A>C||B>D) continue;\n      st[A].push_back(papa(B,D,k));\n      ed[C].push_back(papa(B,D,-k));\n    }\n    for(res i=1; i<=n-l+1; i++)\n    {\n      for(res j=0; j<st[i].size(); j++)\n        T::update(1,1,m-l+1,st[i][j].l,st[i][j].r,st[i][j].w);\n      if(T::tr[1]<=b)\n      {\n        //printf(\"%d %d\\n\",i,l);\n        return 1;\n      }\n      for(res j=0; j<ed[i].size(); j++)\n        T::update(1,1,m-l+1,ed[i][j].l,ed[i][j].r,ed[i][j].w);\n    }\n    return 0;\n  }\n  inline void MAIN()\n  {\n    for(res i=1; i<=p; i++)\n      a[i].A=read(),a[i].B=read(),a[i].C=read(),a[i].D=read(),a[i].k=read();\n    res l=1,r=min(n,m);\n    while(l<=r)\n    {\n      res mid=l+r>>1;\n      if(check(mid)) ans=mid,l=mid+1;\n      else r=mid-1;\n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n```",
        "postTime": 1543049076,
        "uid": 26848,
        "name": "miaokehao",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4687 \u3010[IOI2008] Pyramid Base \u91d1\u5b57\u5854\u57fa\u3011"
    },
    {
        "content": "\u7ecf \u5178 \u4e8c \u5408 \u4e00\n\n------------\n\n\u9996\u5148\uff0c\u6211\u4eec\u770b\u5230\u4e09\u6863\u90e8\u5206\u5206\uff1a$B=0$ \u65f6\uff0c\u6700\u591a\u969c\u788d\u6570\u662f $4\\times10^5$\uff1b\u800c $B\\neq0$ \u65f6\uff0c\u6700\u591a\u969c\u788d\u6570\u4ec5\u6709 $3\\times10^4$\u3002\n\n\u8fd9\u542f\u793a\u6211\u4eec\u5bf9\u4e8e\u8981\u5bf9\u4e8e\u4e24\u79cd\u60c5\u5f62\u5206\u5f00\u5199\u4e00\u4e2a\u7b97\u6cd5\u3002\n\n# $B=0$\n\n\u6b64\u79cd\u60c5\u5f62\u610f\u5473\u7740\u65e0\u6cd5\u6d88\u9664\u4efb\u4f55\u969c\u788d\u3002\u82e5\u6211\u4eec\u628a\u969c\u788d\u770b\u4f5c\u662f\u77e9\u5f62\u8d4b $1$ \u7684\u8bdd\uff0c\u95ee\u9898\u5c31\u8f6c\u6362\u4e3a\u6700\u5927\u5168\u96f6\u6b63\u65b9\u5f62\u3002\n\n\u540c\u7528\u5355\u8c03\u6808\u89e3\u51b3\u7684\u6700\u5927\u5168\u96f6\u77e9\u5f62\u4e0d\u540c\uff0c\u6700\u5927\u5168\u96f6\u6b63\u65b9\u5f62\u53ef\u4ee5\u4f7f\u7528two-pointers+\u626b\u63cf\u7ebf+\u7ebf\u6bb5\u6811\u89e3\u51b3\u3002\n\n\u5177\u4f53\u800c\u8a00\uff0c\u6211\u4eec\u8003\u8651\u56fa\u5b9a\u4e00\u4e2a\u6307\u9488 $i$\uff0c\u518d\u8bbe\u53e6\u4e00\u4e2a\u6307\u9488 $j<i$\u3002\u5219\uff0c\u6211\u4eec\u60f3\u77e5\u9053\u6240\u6709\u4ee5 $i,j$ \u4e3a\u4e24\u8fb9\u7684\u77e9\u5f62\u4e2d\uff0c\u53e6\u4e00\u7ef4\u6700\u957f\u7684\u90a3\u4e00\u4e2a\u3002\u56e0\u4e3a\u968f\u7740 $j$ \u7684\u589e\u52a0\uff0c$i-j$ \u8fd9\u4e00\u7ef4\u7684\u957f\u5ea6\u4f1a\u4e0d\u65ad\u51cf\u5c0f\uff0c\u800c\u53e6\u4e00\u7ef4\u7684\u957f\u5ea6\u4f1a\u4e0d\u65ad\u589e\u52a0\uff0c\u6240\u4ee5\u5f53\u6b63\u65b9\u5f62\u8fb9\u957f\u6700\u5927\u65f6\uff0c\u4e00\u5b9a\u6709\u4e24\u7ef4\u5dee\u6700\u5c0f\u3002\u4e8e\u662f\u6211\u4eec\u4e0d\u65ad\u589e\u52a0 $j$\uff0c\u76f4\u5230\u53e6\u4e00\u7ef4\u7684\u957f\u5ea6\u5927\u4e8e $i-j$ \u8fd9\u4e00\u7ef4\u3002\n\n\u73b0\u5728\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u4ec5\u9700\u7ef4\u62a4 $i,j$ \u95f4\u6ca1\u6709\u4efb\u4f55\u969c\u788d\u7269\u7684\u6700\u5927\u5b50\u6bb5\u3002\u56e0\u4e3a\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5\u628a\u4e00\u5768\u969c\u788d\u7269\u770b\u4f5c\u662f\u533a\u95f4\u52a0\u4e00\uff0c\u6240\u4ee5\u95ee\u9898\u53d8\u4e3a\u533a\u95f4\u52a0\u3001\u5168\u5c40\u6700\u5927\u5168\u96f6\u5b50\u6bb5\u3002\u5b50\u6bb5\u95ee\u9898\u53ea\u9700\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u5de6\u7aef\u70b9\u3001\u53f3\u7aef\u70b9\u3001\u5168\u5c40\u7b49\u4e00\u5927\u5768\u73a9\u610f\u7136\u540e\u5408\u5e76\u5373\u53ef\uff0c\u4e0d\u518d\u8d58\u8ff0\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log n)$\u3002\n\n# $B\\neq 0$\n\n\u6b64\u79cd\u60c5\u5f62\u610f\u5473\u7740\u53ef\u4ee5\u6d88\u9664\u969c\u788d\u3002\u4f46\u662f\uff0c\u56e0\u4e3a\u6570\u636e\u8303\u56f4\u660e\u663e\u51cf\u5c11\uff0c\u6211\u4eec\u53ef\u4ee5\u601d\u8003\u590d\u6742\u5ea6\u66f4\u9ad8\u7684\u7b97\u6cd5\u3002\n\n\u660e\u663e\u91d1\u5b57\u5854\u8fb9\u957f\u5177\u6709\u53ef\u4e8c\u5206\u6027\u3002\u4e8e\u662f\u6211\u4eec\u4e8c\u5206\u8fb9\u957f\u3002\u4e8c\u5206\u8fb9\u957f\u4ee5\u540e\uff0c\u6211\u4eec\u8003\u8651\u5728\u91d1\u5b57\u5854\u7684\u53f3\u4e0a\u89d2\u4f4d\u7f6e\u50a8\u5b58\u8be5\u91d1\u5b57\u5854\u9700\u8981\u6d88\u9664\u7684\u969c\u788d\u7684\u4ee3\u4ef7\u548c\u3002\u8003\u8651\u4e00\u4e2a\u969c\u788d\uff0c\u5219\u5176\u4f1a\u5bf9\u5176\u5185\u90e8\uff0c\u4ee5\u53ca\u5176\u53f3\u65b9\u4e0a\u65b9\u4e00\u5b9a\u8ddd\u79bb\uff08\u51c6\u786e\u8bf4\uff0c\u4e8c\u5206\u7684\u8fb9\u957f\u518d\u51cf\u4e00\uff09\u7684\u4f4d\u7f6e\u7684\u91d1\u5b57\u5854\u9020\u6210\u5f71\u54cd\u3002\u4e8e\u662f\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u6700\u5c0f\u77e9\u5f62\u8986\u76d6\u95ee\u9898\u3002\u76f4\u63a5\u4e0a\u626b\u63cf\u7ebf\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2n)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define y1 __17680321\nint n,m,c,q,xx,yy;\nvector<int>X,Y;\nstruct edge{\n\tint y1,y2,val;\n\tedge(int a,int b,int c){y1=a,y2=b,val=c;}\n};\nvector<edge>v[800100];\nstruct rect{\n\tint x1,y1,x2,y2,cost;\n\tvoid input(){scanf(\"%d%d%d%d%d\",&x1,&y1,&x2,&y2,&cost),x1--,y1--;}\n\tvoid isput(){X.push_back(x1),X.push_back(x2),Y.push_back(y1),Y.push_back(y2);}\n\tvoid reput(){\n\t\tx1=lower_bound(X.begin(),X.end(),x1)-X.begin();\n\t\tx2=lower_bound(X.begin(),X.end(),x2)-X.begin();\n\t\ty1=lower_bound(Y.begin(),Y.end(),y1)-Y.begin();\n\t\ty2=lower_bound(Y.begin(),Y.end(),y2)-Y.begin();\n\t}\n}r[400100],t[30100];\nvoid discrete(vector<int>&v,int&vv){sort(v.begin(),v.end()),v.resize(vv=unique(v.begin(),v.end())-v.begin()-1);}\n#define lson x<<1\n#define rson x<<1|1\n#define mid ((l+r)>>1)\nnamespace S1{\n\tstruct SegTree{int tag,mn,len,lval,lln,rval,rln;}seg[3200100];\n\tvoid ADD(int x,int y){seg[x].tag+=y,seg[x].mn+=y,seg[x].lval+=y,seg[x].rval+=y;}\n\tvoid pushdown(int x){ADD(lson,seg[x].tag),ADD(rson,seg[x].tag),seg[x].tag=0;}\n\tvoid pushup(int x,int l,int r){\n\t\tseg[x].lval=seg[lson].lval,seg[x].rval=seg[rson].rval;\n\t\tif(seg[lson].lln==Y[mid]-Y[l]&&seg[lson].rval==seg[rson].lval)seg[x].lln=seg[lson].lln+seg[rson].lln;\n\t\telse seg[x].lln=seg[lson].lln;\n\t\tif(seg[rson].rln==Y[r]-Y[mid]&&seg[lson].rval==seg[rson].lval)seg[x].rln=seg[rson].rln+seg[lson].rln;\n\t\telse seg[x].rln=seg[rson].rln;\n\t\tseg[x].mn=min(seg[lson].mn,seg[rson].mn),seg[x].len=0;\n\t\tif(seg[x].mn==seg[lson].mn)seg[x].len=max(seg[x].len,seg[lson].len);\n\t\tif(seg[x].mn==seg[rson].mn)seg[x].len=max(seg[x].len,seg[rson].len);\n\t\tif(seg[lson].rval==seg[x].mn&&seg[rson].lval==seg[x].mn)seg[x].len=max(seg[x].len,seg[lson].rln+seg[rson].lln);\n\t}\n\tvoid build(int x,int l,int r){\n\t\tif(l+1==r){seg[x].lln=seg[x].rln=seg[x].len=Y[r]-Y[l];return;}\n\t\tbuild(lson,l,mid),build(rson,mid,r),pushup(x,l,r);\n\t}\n\tvoid modify(int x,int l,int r,int L,int R,int val){\n//\t\tprintf(\"%d %d %d %d %d %d\\n\",x,l,r,L,R,val);\n\t\tif(l>=R||r<=L)return;\n\t\tif(L<=l&&r<=R){ADD(x,val);return;}\n\t\tpushdown(x),modify(lson,l,mid,L,R,val),modify(rson,mid,r,L,R,val),pushup(x,l,r);\n\t}\n//\tvoid iterate(int x,int l,int r){\n//\t\tprintf(\"%d(%d,%d]:MN:%d LN:%d LV:%d LL:%d RV:%d RL:%d\\n\",x,l,r,seg[x].mn,seg[x].len,seg[x].lval,seg[x].lln,seg[x].rval,seg[x].rln);\n//\t\tif(l+1!=r)pushdown(x),iterate(lson,l,mid),iterate(rson,mid,r),pushup(x,l,r);\n//\t}\n\tint calc(){\n\t\tX.push_back(0),X.push_back(n),Y.push_back(0),Y.push_back(m);\n\t\tfor(int i=1;i<=q;i++)r[i].isput();\n\t\tdiscrete(X,xx),discrete(Y,yy);\n\t\tfor(int i=1;i<=q;i++)r[i].reput();\n\t\tfor(int i=1;i<=q;i++)v[r[i].x1].push_back(edge(r[i].y1,r[i].y2,1)),v[r[i].x2].push_back(edge(r[i].y1,r[i].y2,-1));\n\t\tbuild(1,0,yy);\n\t\tint res=0;\n\t\tfor(int i=0,j=0;i<=xx;i++){\n//\t\t\tprintf(\"%d:%d\\n\",i,j);\n//\t\t\titerate(1,0,yy);\n//\t\t\tfor(auto k:v[i])printf(\"(%d,%d,%d)\",k.y1,k.y2,k.val);puts(\"\");\n\t\t\tif(!seg[1].mn)res=max(res,min(X[i]-X[j],seg[1].len));\n//\t\t\tprintf(\"SQR:%d %d\\n\",X[i]-X[j],seg[1].len);\n\t\t\twhile(j<i&&(seg[1].mn||seg[1].len<=X[i]-X[j])){\n\t\t\t\tj++;\n\t\t\t\tfor(auto k:v[j])if(k.val<0)modify(1,0,yy,k.y1,k.y2,k.val);\n\t\t\t\tres=max(res,min(X[i]-X[j],seg[1].len));\n\t\t\t}\n//\t\t\tputs(\"IN\");\n\t\t\tfor(auto k:v[i])if(k.val>0)modify(1,0,yy,k.y1,k.y2,k.val);\n\t\t}\n\t\treturn res;\n\t}\n}\nnamespace S2{\n\tstruct SegTree{int tag,mn;}seg[240100];\n\tvoid ADD(int x,int y){seg[x].tag+=y,seg[x].mn+=y;}\n\tvoid pushdown(int x){ADD(lson,seg[x].tag),ADD(rson,seg[x].tag),seg[x].tag=0;}\n\tvoid pushup(int x){seg[x].mn=min(seg[lson].mn,seg[rson].mn);}\n\tvoid modify(int x,int l,int r,int L,int R,int val){\n\t\tif(l>=R||r<=L)return;\n\t\tif(L<=l&&r<=R){ADD(x,val);return;}\n\t\tpushdown(x),modify(lson,l,mid,L,R,val),modify(rson,mid,r,L,R,val),pushup(x);\n\t}\n\tbool che(int ip){\n\t\tX.push_back(0),X.push_back(n),Y.push_back(0),Y.push_back(m);\n\t\tfor(int i=1;i<=q;i++)t[i]=r[i],t[i].x2=min(n,t[i].x2+ip-1),t[i].y2=min(m,t[i].y2+ip-1),t[i].isput();\n\t\tdiscrete(X,xx),discrete(Y,yy);\n\t\tfor(int i=1;i<=q;i++)t[i].reput();\n\t\tfor(int i=1;i<=q;i++)v[t[i].x1].push_back(edge(t[i].y1,t[i].y2,t[i].cost)),v[t[i].x2].push_back(edge(t[i].y1,t[i].y2,-t[i].cost));\n\t\tint lim=lower_bound(Y.begin(),Y.end(),ip)-Y.begin()-1;\n\t\tint mn=0x7f7f7f7f;\n\t\tmemset(seg,0,sizeof(seg));\n\t\tfor(int i=0;i<=xx;i++){\n\t\t\tif(X[i]>=ip)mn=min(mn,seg[1].mn);\n\t\t\tfor(auto j:v[i])modify(1,lim,yy,j.y1,j.y2,j.val);\n\t\t}\n\t\tX.clear(),Y.clear();for(int i=0;i<=xx;i++)v[i].clear();\n\t\treturn mn<=c;\n\t}\n\tint calc(){\n\t\tint l=0,r=min(n,m);\n\t\twhile(l<r){\n\t\t\tint md=(l+r+1)>>1;\n\t\t\tif(che(md))l=md;\n\t\t\telse r=md-1;\n\t\t}\n\t\treturn l;\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&c,&q);\n\tfor(int i=1;i<=q;i++)r[i].input();\n//\tfor(int i=0;i<=xx;i++)printf(\"%d \",X[i]);puts(\"\");\n//\tfor(int i=0;i<=yy;i++)printf(\"%d \",Y[i]);puts(\"\");\n//\tfor(int i=1;i<=q;i++)printf(\"%d %d %d %d\\n\",r[i].x1,r[i].x2,r[i].y1,r[i].y2);\n\tif(!c)printf(\"%d\\n\",S1::calc());\n\telse printf(\"%d\\n\",S2::calc());\n\treturn 0;\n}\n```\n\n",
        "postTime": 1612434386,
        "uid": 123369,
        "name": "xtx1092515503",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4687 \u3010[IOI2008] Pyramid Base \u91d1\u5b57\u5854\u57fa\u3011"
    }
]