[
    {
        "content": "[\u5148\u653e\u535a\u5ba2](http://blog-wayne.com/2018/05/02/329/)\uff0c~~\u7136\u540e\u76f4\u63a5\u8dd1Bellman-Ford\u3002~~\n\n\u6362\u4e2a\u89d2\u5ea6\uff0c\u8003\u8651\u6bcf\u4e00\u4e2a\u4fee\u8def\u7684\u70b9\u80fd\u66f4\u65b0\u5230\u54ea\u4e00\u4e9b\u70b9\uff0c\u663e\u7136\u8fd9\u662f\u4e00\u4e2a\u5305\u542b\u81ea\u5df1\u7684\u8fde\u7eed\u533a\u95f4\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u4fee\u8def\u7684\u70b9$X$\uff0c\u5206\u522b\u4e8c\u5206\u5de6\u53f3\u4e24\u4e2a\u7aef\u70b9$L,R$\uff0c\u4ee5$L$\u4e3a\u4f8b\uff0c\u4ee4$l=X-L$\uff0c\u5982\u679c$[L-l,L+l]$\u8fd9\u4e2a\u533a\u95f4\u5185\u4e0d\u5b58\u5728\u70b9\u4f7f\u5f97\u4ece\u8fd9\u91cc\u51fa\u53d1\u5230$L$\u5c0f\u4e8e\u4ece$X$\u51fa\u53d1\u5230$L$\uff0c\u90a3\u4e48\u8fd9\u4e2a$L$\u5c31\u662f\u53ef\u884c\u7684\u3002\n\n\u7b54\u6848\u5c31\u662f\u6c42$\\sum\\limits_{i=1}^{K}(R_i-L_i+1)$\n\n\u8fd8\u8981\u8003\u8651\u8fb9\u754c\u95ee\u9898\u9632\u6b62\u91cd\u590d\u8ba1\u7b97\uff0c\u6bd4\u5982\u76f8\u540c\u8ddd\u79bb\u7f16\u53f7\u76f8\u8fd1\u7684\u66f4\u4f18\u5148\uff0c\u76f8\u540c\u8ddd\u79bb\u7f16\u53f7\u5dee\u7684\u7edd\u5bf9\u503c\u4e5f\u76f8\u540c\u5c31\u5de6\u8fb9\u4f18\u5148\u3002\n\nrmq\u7684\u5b9e\u73b0\u65b9\u6cd5\u4e5f\u5f88\u91cd\u8981\uff0c\u7ebf\u6bb5\u6811\u5f88\u6162\uff08\u6ca1\u5361\u8fc7\u53bb\uff09\uff0c\u6211\u5199\u7684\u662f\u7528\u79bb\u6563\u5316\u540e\u7684st\u8868\u3002\u867d\u7136\u4e24\u4e2a\u590d\u6742\u5ea6\u90fd\u662f$nlog^2n$\u7684\u3002\u8fd8\u6709\u4e8c\u5206\u67e5\u627e\u7528\u4e0d\u8981\u7528\u5e93\u51fd\u6570\uff0c\u65f6\u95f4\u6709\u624b\u5199\u7684\u4e24\u500d\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint read() {\n    int x = 0, f = 1; char ch = getchar();\n    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }\n    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n#define ll long long\n\nconst ll Max = 200033;\nconst ll inf = 9999999999999999ll;\nll n, m, now, K;\nll dis[Max], pos[Max], len[Max], Ans;\nint bin[20], Log[Max];\n\nstruct Data {\n    ll mn, id;\n    Data() {}\n    Data(ll a, ll b) {\n        mn = a, id = b;\n    }\n};\n\nvoid init() {\n    bin[0] = 1;\n    for (int i = 1; i <= 18; i++) {\n        bin[i] = bin[i - 1] << 1;\n        Log[bin[i]] = i;\n    }\n    for (int i = 1; i < Max; i++)\n        if (!Log[i]) Log[i] = Log[i - 1];\n}\n\nstruct ST {\n    ll d[Max][18];\n    void init() {\n    \tfor (int j = 1; j <= Log[K]; j++)\n    \t\tfor (int i = 1; i <= K; i++)\n    \t\t\td[i][j] = min(d[i][j - 1], d[i + bin[j - 1]][j - 1]);\n    }\n    ll query(int L, int R) {\n    \tint len = R - L + 1;\n    \treturn min(d[L][Log[len]], d[R - bin[Log[len]] + 1][Log[len]]);\n    }\n} st[2];\n\nint tmp[Max], t[Max];\n\nint lower(int V) {\n    int L = 1, R = K, re = K + 1;\n    while (R >= L) {\n        int mid = (L + R) >> 1;\n        if (tmp[mid] < V) L = mid + 1;\n        else R = mid - 1, re = mid;\n    }\n    return re;\n}\n\nint upper(int V) {\n    int L = 1, R = K, re = K + 1;\n    while (R >= L) {\n        int mid = (L + R) >> 1;\n        if (tmp[mid] <= V) L = mid + 1;\n        else R = mid - 1, re = mid;\n    }\n    return re;\n}\n\nvoid solve() {\n    for (int i = 1; i <= K; i++)\n        tmp[i] = pos[i];\n    sort(tmp + 1, tmp + K + 1);\n    for (int i = 1; i <= K; i++)\n        t[tmp[i]] = i;\n    for (int i = 1; i <= K; i++) {\n    \tst[0].d[t[pos[i]]][0] = len[i] - dis[pos[i]];\n    \tst[1].d[t[pos[i]]][0] = len[i] + dis[pos[i]];\n    }\n    st[0].init(), st[1].init();\n    Ans = 0;\n    for (int i = 1; i <= K; i++) {\n        int ql = 1, qr = pos[i] - 1, L = pos[i], R = L;\n        while (qr >= ql) {\n            bool flag = 1;\n            int mid = (ql + qr) >> 1;\n            ll nowdis = len[i] + dis[pos[i]] - dis[mid], idx = pos[i] - mid;\n            ll dl = inf, dr = dl;\n            \n            int qql = lower(max(1ll, mid - idx));\n            int qqr = upper(mid) - 1;\n            if (qql <= qqr) dl = st[0].query(qql, qqr);\n            \n        \tqql = lower(mid);\n            qqr = upper(pos[i] - 1) - 1;\n            if (qql <= qqr) dr = st[1].query(qql, qqr);\n            \n            if (dl + dis[mid] <= nowdis) flag = 0;\n            if (dr - dis[mid] <= nowdis) flag = 0;\n            if (flag) qr = mid - 1, L = mid;\n            else ql = mid + 1;\n        }\n        \n        ql = pos[i] + 1, qr = n;\n        while (qr >= ql) {\n            bool flag = 1;\n            int mid = (ql + qr) >> 1;\n            ll nowdis = len[i] + dis[mid] - dis[pos[i]], idx = mid - pos[i];\n            ll dl = inf, dr = dl;\n            \n            int qql = lower(mid);\n            int qqr = upper(min(mid + idx - 1, n)) - 1;\n            if (qql <= qqr) dr = st[1].query(qql, qqr);\n            //cout << \"fuck: \" << mid << ' ' << dl << ' ' << dr << endl;\n            \n            qql = lower(pos[i] + 1);\n            qqr = upper(mid) - 1;\n            if (qql <= qqr) dl = st[0].query(qql, qqr);\n            \n            if (dl + dis[mid] <= nowdis) flag = 0;\n            if (dr - dis[mid] <= nowdis) flag = 0;\n            if (mid + idx <= n) {\n            \tqqr = upper(min(mid + idx, n)) - 1;\n            \tif (tmp[qqr] == mid + idx)\n            \t\tif (st[1].d[qqr][0] - dis[mid] < nowdis)\n            \t\t\tflag = 0;\n        \t}\n            if (flag) ql = mid + 1, R = mid;\n            else qr = mid - 1;\n        }\n        Ans += (R - L + 1);\n    }\n    printf(\"%lld\\n\", Ans);\n}\n\nsigned main() {\n    init();\n    n = read(), m = read();\n    for (int i = 2; i <= n; i++)\n        dis[i] = dis[i - 1] + read();\n    for (int i = 1; i <= m; i++) {\n        K = read();\n        for (int j = 1; j <= K; j++)\n            pos[j] = read(), len[j] = read();\n        solve();\n    }\n}\n```",
        "postTime": 1525250821,
        "uid": 37070,
        "name": "Ameyax",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4501 \u3010[ZJOI2018]\u80d6\u3011"
    },
    {
        "content": "[Blog](http://labelray.top/2018/10/05/zjoi2018%e8%83%96/)\n\n\u5728\u9898\u76ee\u4e2d\u7684\u56fe\u4e0a\u8dd1Bellman-Ford\u7684\u65f6\u5019\uff0c\u6709\u4e00\u4e2a\u5f88\u6709\u8da3\u7684\u6027\u8d28\uff0c\u624b\u73a9\u4e00\u4e0b\u5c31\u53ef\u4ee5\u77e5\u9053\uff0c\u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u70b9$m$\uff0c\u5982\u679c$d=|a_{i}-m|$\uff0c$[m-d, m+d]$\u4e2d\u6ca1\u6709\u6bd4\u4ece\u70b9$0$\u7ecf\u8fc7\u70b9$a_{i}$\u5230\u8fbe\u70b9$m$\u66f4\u4f18\u7684\u70b9\uff0c\u90a3\u4e48\u70b9$m$\u5fc5\u5b9a\u4f1a\u88ab\u4ece$0$\u5f00\u59cb\u7ecf\u8fc7\u70b9$a_{i}$\u66f4\u65b0\u3002\u3001\n\n\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u70b9$a_{i}$\uff0c\u53ef\u4ee5\u91c7\u7528\u4e8c\u5206\u67e5\u627e\u7684\u65b9\u6cd5\u5f88\u5bb9\u6613\u7684\u627e\u5230\u88ab\u4ed6\u66f4\u65b0\u8fc7\u7684\u533a\u95f4$[l, r]$\u3002\n\n\u5176\u4e2d\u8003\u8651\u70b9$0$\u7ecf\u8fc7\u70b9$a_{i}$\u5230\u70b9$x$\u7684\u8ddd\u79bb\u600e\u4e48\u6c42\uff0c\u8bbe$dis_{i}$\u4e3a\u70b9$1$\u5230\u70b9$i$\u7684\u8ddd\u79bb\uff0c\u5982\u679c$a_{i}$\u5728$x$\u7684\u5de6\u8fb9\uff0c\u90a3\u4e48\u5c31\u662f$dis_{x}+(l_{i}-dis_{a_{i}})$\uff0c\u5982\u679c$a_{i}$\u5728$x$\u7684\u53f3\u8fb9\uff0c\u90a3\u4e48\u5c31\u662f$-dis_{x}+(l_{i}+dis_{a_{i}})$\u3002\n\n\u6240\u4ee5\u5f00\u4e24\u4e2aST\u8868\u5206\u522b\u7ef4\u62a4$l_{i}+dis_{a_{i}}$\uff0c$l_{i}-dis_{a_{i}}$\u5c31\u597d\u5566\n\n\u8fd9\u6837\u7684\u8bdd\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f$O(n\\log^{2}n)$\n\nST\u8868\u4e2d\u8bb0\u5f97\u662f\u6309$a_{i}$\u7684$i$\u5b58\u50a8\u800c\u4e0d\u662f\u6309\u6bcf\u4e2a\u4f4d\u7f6e$i$\u5b58\u50a8\uff0c\u4e5f\u5c31\u662f\u8bf4ST\u8868\u7684\u5927\u5c0f\u662f$K$\u800c\u4e0d\u662f$n$\uff0c\u5426\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u4f1a\u662f$O(n\\cdot m\\log^{2} n)$\u4e86\n\n```\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n \nstruct Data{\n    int p;\n    long long l;\n    bool operator <(const Data &_)const{\n        return p<_.p;\n    }\n}a[200010];\nint n, m, K;\nlong long dis[200010];\n \nnamespace ST{\n    long long st1[200010][18], st2[200010][18];\n \n    void init(){\n        std::sort(a+1, a+K+1);\n        for(int i=1; i<=K; i++){\n            st1[i][0]=a[i].l-dis[a[i].p];\n            st2[i][0]=a[i].l+dis[a[i].p];\n        }\n        for(int j=1; j<=17; j++)\n            for(int i=1; i<=K-(1<<j)+1; i++){\n                st1[i][j]=std::min(st1[i][j-1], st1[i+(1<<(j-1))][j-1]);\n                st2[i][j]=std::min(st2[i][j-1], st2[i+(1<<(j-1))][j-1]);\n            }\n    }\n     \n    int findl(int x){\n        Data _; _.p=x;\n        return std::lower_bound(a+1, a+K+1, _)-a;\n    }\n     \n    int findr(int x){\n        Data _; _.p=x;\n        return std::upper_bound(a+1, a+K+1, _)-a-1;\n    }    \n    long long query1(int l, int r){\n        if(l>r) std::swap(l, r);\n        l=std::max(1, l), r=std::min(r, n);\n        l=findl(l), r=findr(r);\n        if(l>r)  return 0x3f3f3f3f3f3f3f3f;\n        int lim=log2(r-l+1);\n        return std::min(st1[l][lim], st1[r-(1<<lim)+1][lim]);\n    }\n \n    long long query2(int l, int r){\n        if(l>r) std::swap(l, r);\n        l=std::max(1, l), r=std::min(r, n);\n        l=findl(l), r=findr(r);\n        if(l>r)  return 0x3f3f3f3f3f3f3f3f;\n        int lim=log2(r-l+1);\n        return std::min(st2[l][lim], st2[r-(1<<lim)+1][lim]);\n    }\n}\n \nbool check1(int p, int x){\n    if(x==p)    return true;\n    long long qwq1=ST::query1(2*x-p+1, x)+dis[x];\n    long long qwq2=ST::query2(x, p-1)-dis[x];\n    long long mst=ST::query2(p, p)-dis[x];\n    if(qwq1<=mst || qwq2<=mst)  return false;\n    if(2*x-p>=1) return ST::query1(2*x-p, 2*x-p)+dis[x]>mst;\n    return true;\n}\n \nbool check2(int p, int x){\n    if(x==p)    return true;\n    long long qwq1=ST::query1(p+1, x)+dis[x];\n    long long qwq2=ST::query2(x, 2*x-p-1)-dis[x];\n    long long mst=ST::query1(p, p)+dis[x];\n    if(qwq1<=mst || qwq2<=mst)  return false;\n    if(2*x-p<=n) return ST::query2(2*x-p, 2*x-p)-dis[x]>=mst;\n    return true;\n}\n \nint solve1(int p){\n    int l=1, r=p, ans=p;\n    while(l<=r){\n        int mid=(l+r)/2;\n        if(check1(p, mid))  r=mid-1, ans=mid;\n        else                l=mid+1;\n    }\n    return ans;\n}\n \nint solve2(int p){\n    int l=p, r=n, ans=p;\n    while(l<=r){\n        int mid=(l+r)/2;\n        if(check2(p, mid))  l=mid+1, ans=mid;\n        else                r=mid-1;\n    }\n    return ans;\n}\n \nint main(){\n    scanf(\"%d%d\", &n, &m);\n    for(int i=2; i<=n; i++){\n        scanf(\"%lld\", &dis[i]);\n        dis[i]+=dis[i-1];\n    }\n    while(m--){\n        scanf(\"%d\", &K);\n        for(int i=1; i<=K; i++)\n            scanf(\"%d%lld\", &a[i].p, &a[i].l);\n        ST::init();\n        long long ans=0;\n        for(int i=1; i<=K; i++){\n            ans+=1LL*(solve2(a[i].p)-solve1(a[i].p)+1);\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\n```",
        "postTime": 1538746413,
        "uid": 52211,
        "name": "Labelray",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4501 \u3010[ZJOI2018]\u80d6\u3011"
    },
    {
        "content": "\u819c\u62dc[$\\color{black} \\text{z} \\color{red} \\text{houchenyuan}$](https://www.luogu.com.cn/user/87416)\u79d2\u6740\u8fd9\u9053\u9898\u3002\n\n### \u7ebf\u6bb5\u6811\n\n\u6211\u4eec\u53ef\u4ee5\u89c2\u5bdf\u4e00\u4e0bBellman-Ford\u7b97\u6cd5\u5728\u8fd9\u5f20\u56fe\u4e0a\u662f\u5982\u4f55\u8fdb\u884c\u677e\u5f1b\u7684\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u62e5\u6709\u4ece$0$\u53f7\u70b9\u6765\u7684\u8fb9\u7684\u77ad\u671b\u5854$a_i$\u6765\u8bf4\uff0c\u5b83\u5728\u7b2c\u4e00\u6b65\u4e00\u5b9a\u4f1a\u88ab\u8fb9$0-u$\u677e\u5f1b\uff0c\u968f\u540e\u5411\u4e24\u8fb9\u6269\u5f20\uff0c\u76f4\u5230\u9047\u5230\u963b\u788d\u540e\u505c\u6b62\uff0c\u5f62\u6210\u4e00\u6bb5$a_i$\u677e\u5f1b\u8fc7\u7684\u533a\u95f4\uff0c\u8fd9\u4e2a\u533a\u95f4\u7684\u8fb9\u754c\u4e4b\u540e\u53ef\u80fd\u88ab\u4e24\u8fb9\u7684\u77ad\u671b\u5854\u91cd\u65b0\u677e\u5f1b\u3002\n\n\u6211\u4eec\u53d1\u73b0\uff0c\u5982\u679c\u6211\u4eec\u80fd\u591f\u5bf9\u4e8e\u6bcf\u4e00\u4e2a$a_i$\uff0c\u627e\u5230\u5bf9\u5e94\u7684\u4e00\u6bb5\u533a\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u628a\u6bcf\u4e2a\u77ad\u671b\u5854\u7684\u8d21\u732e\u5168\u90e8\u8ba1\u7b97\u51fa\u6765\uff0c\u4ece\u800c\u5f97\u5230\u7b54\u6848\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u4e8c\u5206\u7b54\u6848\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5408\u6cd5\uff0c\u5bf9\u4e8e\u4e00\u4e2a$a_i$\uff0c\u6211\u4eec\u901a\u8fc7\u4e8c\u5206\u6c42\u51fa\u5176\u5de6\u53f3\u8fb9\u754c\uff0c\u5148\u770b\u5982\u4f55\u5904\u7406\u5de6\u8fb9\u754c\uff1a\n\n\u5047\u8bbe\u6211\u4eec\u4e8c\u5206\u5230\u7684\u533a\u95f4\u4e3a$[g,a_i]$\uff0c\u6211\u4eec\u9700\u8981\u4fdd\u8bc1\u4e24\u4e2a\u6761\u4ef6\uff1a\n\n$1.$$a_i$\u4e0d\u80fd\u88ab\u533a\u95f4$[g,a_i)$\u4e2d\u7684\u77ad\u671b\u5854\u62e6\u622a\u3002\n\n$2.$$a_i$\u5230\u8fbe$g$\u70b9\u7684\u8def\u7a0b\u5c0f\u4e8e**\u5728\u5b83\u4e4b\u524d**\u4ece$g$\u5de6\u4fa7\u77ad\u671b\u5854\u5230\u8fbe$g$\u70b9\u7684\u8def\u7a0b\u3002\n\n\u76f4\u63a5\u5904\u7406\u7b2c\u4e00\u4e2a\u6761\u4ef6\u5e76\u4e0d\u5bb9\u6613\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u5229\u7528\u7b2c\u4e00\u4e2a\u6761\u4ef6\u8ba1\u7b97\u51fa\u4e8c\u5206\u8fb9\u754c\uff0c\u5c31\u53ef\u4ee5\u4e22\u6389\u8fd9\u4e2a\u9650\u5236\u3002\n\n\u4ee4$s_k=\\sum_{i=1}^{k-1} w_i$\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528$s_i-s_j$\u8868\u793a$i,j$\u4e4b\u95f4\u7684\u8ddd\u79bb\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a\u77ad\u671b\u5854$a_j$\uff0c\u5982\u679c$j$\u4e0d\u4f1a\u62e6\u622a$i$\uff0c\u90a3\u4e48\u5c31\u6ee1\u8db3\uff1a\n\n$$\nl_i+s_i-s_j<l_j\n$$\n$$\nl_i+s_i<l_j+s_j\n$$\n\n\u6211\u4eec\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4$l_i+s_i$\u7684\u6700\u5c0f\u503c\uff08\u65e0\u77ad\u671b\u5854\u5904\u8bbe\u4e3a$+\\infty$\uff09\uff0c\u7136\u540e\u5229\u7528\u500d\u589e\u8ba1\u7b97\u51fa\u4e8c\u5206\u8fb9\u754c\u3002\n\n\u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u4e8c\u5206\u4e86\uff0c\u540c\u65f6\u5224\u65ad\u7b2c\u4e8c\u4e2a\u6761\u4ef6\u662f\u5426\u6210\u7acb\u3002\u9996\u5148\uff0c\u8981\u60f3\u62a2\u593a$a_i$\u5bf9$g$\u7684\u63a7\u5236\uff0c\u5c31\u5fc5\u987b\u6bd4$a_i$\u5148\u5230\u8fbe$g$\uff0c\u90a3\u4e48\u5bf9\u4e8e$g$\u6709\u5f71\u54cd\u7684\u533a\u95f4\u5c31\u662f$[\\max(1,g-(u-g)),g]$\uff0c\u5bf9\u4e8e\u77ad\u671b\u5854$a_j$\uff0c\u6ee1\u8db3\uff1a\n\n$$\nl_i+s_i-s_g<l_j+s_g-s_j\n$$\n$$\nl_i+s_i-2s_g<l_j-s_j\n$$\n\n\u518d\u5229\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4$l_i-s_i$\u6700\u5c0f\u503c\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u53f3\u8fb9\u754c\u4e5f\u662f\u540c\u7406\u7684\u3002\n\n\u8fd8\u6709\u4e00\u4e2a\u5173\u952e\u70b9\uff0c\u5c31\u662f\u5982\u679c\u5b58\u5728\u4e00\u4e2a\u70b9$j$\u6ee1\u8db3$l_i+dis(i,g)=l_j+dis(j,g)$\uff0c\u90a3\u4e48\u6211\u4eec\u9700\u8981\u6ce8\u610f\u4e00\u4e0b\uff0c\u5982\u679c$j$\u6bd4$i$\u5148\u5230\u8fbe$g$\uff0c\u6211\u4eec\u4e0d\u5fc5\u5728$i$\u5904\u8ba1\u7b97\u7b54\u6848\uff0c\u56e0\u4e3a\u5728$j$\u5904\u4e00\u5b9a\u4f1a\u8ba1\u7b97\u5230\u3002\u4f46\u662f\u5982\u679c$i,j$\u540c\u65f6\u5230\u8fbe$g$\uff0c\u4e14\u6ca1\u6709\u5176\u4ed6\u70b9\u4f1a\u5148\u62a2\u593a\u5230$g$\uff0c\u6211\u4eec\u5c31\u4f1a\u6f0f\u89e3\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5728\u679a\u4e3e\u5de6\u8fb9\u754c\u65f6\u5bf9\u8fd9\u79cd\u60c5\u51b5\u8fdb\u884c\u7279\u5224\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n \\log^2 n)$\u3002\n\n$Code:$\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define N 200005\n#define ll long long\nusing namespace std;\nconst ll INF=1919191919191919;\nint n,m,k,w[N],a[N],len[N];\nll ans,s[N],vl[N],gl[N];\nstruct sgt\n{\n    ll tr[N << 2];\n    void build(int p,int l,int r)\n    {\n        tr[p]=INF;\n        if (l==r)\n            return;\n        int mid(l+r >> 1);\n        build(p << 1,l,mid);\n        build(p << 1 | 1,mid+1,r);\n    }\n    void modify(int p,int l,int r,int x,ll y)\n    {\n        if (l==r)\n        {\n            tr[p]=y;\n            return;\n        }\n        int mid(l+r >> 1);\n        if (x<=mid)\n            modify(p << 1,l,mid,x,y); else\n            modify(p << 1 | 1,mid+1,r,x,y);\n        tr[p]=min(tr[p << 1],tr[p << 1 | 1]);\n    }\n    void modify(int x,ll y)\n    {\n        modify(1,1,n,x,y);\n    }\n    ll calc(int p,int l,int r,int x,int y)\n    {\n        if (l==x && r==y)\n            return tr[p];\n        int mid(l+r >> 1);\n        if (y<=mid)\n            return calc(p << 1,l,mid,x,y); else\n        if (x>mid)\n            return calc(p << 1 | 1,mid+1,r,x,y); else\n            return min(calc(p << 1,l,mid,x,mid),calc(p << 1 | 1,mid+1,r,mid+1,y));\n    }\n    ll calc(int x,int y)\n    {\n        return calc(1,1,n,x,y);\n    }\n}s1,s2;\nint calcL(ll s,int I)\n{\n    if (!I)\n        return 1;\n    for (int i=20;i>=0;--i)\n        if (I-(1 << i)+1>0 && s1.calc(I-(1 <<i)+1,I)>s)\n            I-=(1 << i);\n    if (!I || vl[I]<=s)\n        ++I;\n    return I;\n}\nint calcR(ll s,int I)\n{\n    if (I>n)\n        return n;\n    for (int i=20;i>=0;--i)\n        if (I+(1 << i)-1<=n && s2.calc(I,I+(1 << i)-1)>s)\n            I+=(1 << i);\n    if (I>n || gl[I]<=s)\n        --I;\n    return I;\n}\nll calc1(int l,int r)\n{\n    return s2.calc(l,r);\n}\nll calc2(int l,int r)\n{\n    return s1.calc(l,r);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<n;++i)\n        scanf(\"%d\",&w[i]),s[i+1]=s[i]+w[i];\n    s1.build(1,1,n),s2.build(1,1,n);\n    for (int i=1;i<=n;++i)\n        vl[i]=gl[i]=INF;\n    while (m--)\n    {\n        scanf(\"%d\",&k);\n        for (int i=1;i<=k;++i)\n        {\n            scanf(\"%d%d\",&a[i],&len[i]);\n            vl[a[i]]=s[a[i]]+len[i];\n            gl[a[i]]=-s[a[i]]+len[i];\n            s1.modify(a[i],vl[a[i]]);\n            s2.modify(a[i],gl[a[i]]);\n        }\n        ans=0;\n        for (int i=1;i<=k;++i)\n        {\n            int u(a[i]);\n            int lim(calcL(vl[u],u-1));\n            int l(lim),r(u),g(u);\n            while (l<=r)\n            {\n                int mid(l+r >> 1);\n                ll L(s[u]-s[mid]+len[i]-s[mid]);\n                int pt(max(1,mid-(u-mid)));\n                if (calc1(pt,mid)>L)\n                    g=mid,r=mid-1; else\n                    l=mid+1;\n            }\n            ans+=u-g+1;\n            if (g!=1)\n            {\n                --g;\n                ll L(s[u]-s[g]+len[i]-s[g]);\n                int pt(max(1,g-(u-g)));\n                if (g-(u-g)>0 && calc1(pt+1,g)>L && gl[pt]==L)\n                    ++ans;\n            }\n        }\n        for (int i=1;i<=k;++i)\n        {\n            int u(a[i]);\n            int lim(calcR(gl[u],u+1));\n            if (lim==u)\n                continue;\n            int l(u+1),r(lim),g(-1);\n            while (l<=r)\n            {\n                int mid(l+r >> 1);\n                ll L(-s[u]+s[mid]+len[i]+s[mid]);\n                int pt(min(n,mid+(mid-u)));\n                if (calc2(mid,pt)>L)\n                    g=mid,l=mid+1; else\n                    r=mid-1;\n            }\n            if (g==-1)  \n                continue;\n            ans+=g-u;\n        }\n        printf(\"%lld\\n\",ans);\n        for (int i=1;i<=k;++i)\n        {\n            vl[a[i]]=gl[a[i]]=INF;\n            s1.modify(a[i],INF);\n            s2.modify(a[i],INF);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1617262284,
        "uid": 10341,
        "name": "GK0328",
        "ccfLevel": 0,
        "title": "P4501 [ZJOI2018]\u80d6 \u9898\u89e3"
    },
    {
        "content": "\u672c\u9898\u89e3\u6240\u63d0\u4f9b\u7684\u529e\u6cd5\uff0c\u9700\u8981\u591a\u6b21\u63d0\u4ea4\u5728\u6d1b\u8c37\u4e0a\u65b9\u53ef$AC$\u6b64\u9898\u3002\u4f46\u662f\u5b9e\u9645\u8003\u573a\u4e0a\uff0c\u7528\u8fd9\u4e2a\u529e\u6cd5\u7684\u53f6\u5353\u777f\u5927\u4f6c\u5f53\u573a\u901a\u8fc7\u4e86\u6b64\u9898\u3002\n\n\u8bf4\u53e5\u9898\u5916\u8bdd\uff0c$ZJOI2018D1D2$\u6700\u53ef\u505a\u7684\u90fd\u662f$T2$\uff0c[\u5386\u53f2](https://www.luogu.com.cn/problem/P4338)\u90a3\u4e2a\u9898\u6211\u611f\u89c9\u8fd8\u662f\u9700\u8981\u60f3\u4e00\u6bb5\u65f6\u95f4\u624d\u80fd\u60f3\u5230\u6b63\u89e3\uff0c\u4f46\u662f\u8fd9\u4e2a\u9898\u7684\u8fd9\u4e2a\u529e\u6cd5\u5374\u975e\u5e38\u597d\u60f3\uff0c\u53ef\u4ee5\u8bf4\u662f\u4e24\u5929\u6700\u53ef\u505a\u7684\u9898\u4e86\u3002\n\n\u7b97\u6cd5\u4e00\uff1a\u7528SPFA\u7b97\u6cd5\u76f4\u63a5\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u590d\u6742\u5ea6$O(n\\sum k)$\uff0c\u671f\u671b\u5f97\u5206$0 - 20$\u5206\u3002\n\n\u7b97\u6cd5\u4e8c\uff1a\u6211\u4eec\u5229\u7528\u4eba\u7c7b\u667a\u6167\uff0c\u6a21\u62df\u8fd9\u4e2a\u677e\u5f1b\u8fc7\u7a0b\u3002\u4e0d\u96be\u53d1\u73b0\u5176\u5b9e\u6bcf\u6b21\u7b54\u6848\u5c31\u548c\u8fd9\u9009\u5b9a\u7684k\u4e2a\u70b9\u6709\u5173\uff0c\u5373\u5c31\u662f\u7528\u8fd9k\u4e2a\u70b9\u5411\u5de6\u5411\u53f3\u53bb\u66f4\u65b0\u5176\u4ed6\u70b9\uff0c\u5206\u522b\u7edf\u8ba1\u8fd9$k$\u4e2a\u70b9\u80fd\u66f4\u65b0\u5230\u591a\u5c11\u4e2a\u70b9\u5373\u53ef\u3002\n\n\u6211\u4eec\u5f00\u59cb\u7684\u65f6\u5019\u9884\u5904\u7406\u6bcf\u4e2a\u70b9\u5230$1$\u53f7\u70b9\u7684\u8ddd\u79bb\u4e3a$dep[]$\uff0c\u9009\u5b9a\u7684k\u4e2a\u70b9\u5230\u5bab\u6bbf\u7684\u8ddd\u79bb\u4e3a$dis[]$\u3002\u4e0d\u96be\u53d1\u73b0\u6b64\u65f6$i, j(i < j)$\u4e24\u4e2a\u70b9\u7684\u8ddd\u79bb\u4e3a$dep[j] - dep[i]$\u3002\n\n\u5982\u679c$ki$\u53ef\u4ee5\u5411\u53f3\u66f4\u65b0\u5230$j$\u8fd9\u4e2a\u70b9\uff0c\u4ed6\u4eec\u7684\u8ddd\u79bb\u4e3a$d$\u3002\n\n\u90a3\u4e48$ki$\u4e0e$j$\u4e4b\u95f4\u7684\u70b9$l$\u90fd\u8981\u6ee1\u8db3\n $dis[ki] + dep[l] - dep[i] < dep[l]$\uff0c\n\n$j$\u5230$j + d$\u7684\u70b9$p$\u90fd\u8981\u6ee1\u8db3$dis[ki] + dep[j] - dep[ki] < dis[p] + dep[p] - dep[j]$\u3002\n\n\u5411\u5de6\u66f4\u65b0\u4e5f\u662f\u7c7b\u4f3c\u7684\u8fc7\u7a0b\uff0c\u66b4\u529b\u7ef4\u62a4\u590d\u6742\u5ea6$O(nmk)$\u3002\n\n\u7b97\u6cd5\u4e09\uff1a\u4e0a\u9762\u90a3\u4e9b\u5f0f\u5b50\u5217\u51fa\u6765\uff0c\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a$d$\u53ef\u4ee5\u4e8c\u5206\uff0c\u7136\u540e\u7528[\u7ebf\u6bb5\u6811](https://www.luogu.com.cn/problem/P1083)\u7ef4\u62a4\u533a\u95f4\u6700\u503c\u5373\u53ef\uff0c\u4e0d\u4f1a\u53ef\u4ee5\u70b9\u51fb\u94fe\u63a5\u5b66\u4e00\u4e0b\u5982\u4f55\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6700\u503c\uff0c\u590d\u6742\u5ea6$O(n\\log ^ 2n)$\u3002\n\n\u6709\u4e00\u4e2a\u7ec6\u8282\uff0c$i$\u5230$j$\u7684\u8ddd\u79bb\u7b49\u4e8e$j$\u5230$k$\u7684\u8ddd\u79bb\u4e00\u6837($i < j < k$)\uff0c\u8fd9\u4e2a$i$\u548c$k$\u603b\u5171\u4f1a\u66f4\u65b0$j$\u4e00\u6b21\uff0c\u4f46\u662f\u4e0a\u9762\u6ca1\u6709\u7edf\u8ba1\uff0c\u4f60\u53ef\u4ee5\u5f3a\u5236\u5411\u53f3\u66f4\u65b0\u7684\u65f6\u5019\u7edf\u8ba1\u3002\n\n\u4ee3\u7801\u6709\u70b9\u8fa3\u773c\u775b\uff0c\u8bf7\u505a\u597d\u5fc3\u7406\u51c6\u5907\u7136\u540e\u518d\u770b\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 200005\n#define maxt 800005\n#define ll long long\n#define inf 2003518617518617ll\n#define For(i, j, n) for(register int i = j ; i <= n ; ++i)\nint k, n, m, v, w, dis[maxn], stk[maxn];\nll ans, c[maxt], t[maxt], dep[maxn];\n\n#define ls x << 1\n#define rs x << 1 | 1\n#define mid (l + r >> 1)\ninline void Cpushup(int x){ c[x] = min(c[ls], c[rs]); }\ninline ll Cquery(int x, int l, int r, int ql, int qr){\n\tif(ql <= l && r <= qr) return c[x];\n\tll sum = inf;\n\tif(ql <= mid) sum = min(sum, Cquery(ls, l, mid, ql, qr));\n\tif(qr > mid) sum = min(sum, Cquery(rs, mid + 1, r, ql, qr));\n\treturn sum;\n}\ninline void Crevise(int x, int l, int r, int ql, ll y){\n\tif(l == r) return c[x] = y, void(); \n\tql <= mid ? Crevise(ls, l, mid, ql, y) : Crevise(rs, mid + 1, r, ql, y);\n\tCpushup(x);\n}\ninline void Tpushup(int x){ t[x] = min(t[ls], t[rs]); }\ninline ll Tquery(int x, int l, int r, int ql, int qr){\n\tif(ql <= l && r <= qr) return t[x];\n\tll sum = inf;\n\tif(ql <= mid) sum = min(sum, Tquery(ls, l, mid, ql, qr));\n\tif(qr > mid) sum = min(sum, Tquery(rs, mid + 1, r, ql, qr));\n\treturn sum;\n}\ninline void Trevise(int x, int l, int r, int ql, ll y){\n\tif(l == r) return t[x] = y, void(); \n\tql <= mid ? Trevise(ls, l, mid, ql, y) : Trevise(rs, mid + 1, r, ql, y);\n\tTpushup(x);\n}\ninline void build(int x, int l, int r){\n\tif(l == r) return c[x] = t[x] = inf, void();\n\tbuild(ls, l, mid), build(rs, mid + 1, r);\n\tCpushup(x), Tpushup(x); \n}\n\ninline int Queryl(int x){\n\tint d = 0, l = 1, r = x - 1;\n\twhile(l <= r){\n\t\tif(Tquery(1, 1, n, x - mid, x - 1) > dis[x] + dep[x] && Cquery(1, 1, n, max(1, x - mid * 2), x - mid) > dis[x] + dep[x] - dep[x - mid] * 2) \n\t\t\t\td = mid, l = mid + 1; \n\t\telse r = mid - 1;\n\t}\n\treturn d;\n}\ninline int Queryr(int x){\n\tint d = 0, l = 1, r = n - x;\n\twhile(l <= r){\n\t\tif(Cquery(1, 1, n, x + 1, x + mid) > dis[x] - dep[x] && Tquery(1, 1, n, x + mid, min(x + mid * 2 - 1, n)) > dis[x] - dep[x] + dep[x + mid] * 2 && (x + mid * 2 > n || Tquery(1, 1, n, x + mid * 2, x + mid * 2) >= dis[x] - dep[x] + dep[x + mid] * 2))\n\t\t\td = mid, l = mid + 1;\n\t\telse r = mid - 1;\n\t}\n\treturn d;\n} \n\nint main(){\n\tscanf(\"%d %d\", &n, &m), build(1, 1, n);\n\tFor(i, 2, n) scanf(\"%d\", &w), dep[i] = dep[i - 1] + w;\n\tFor(i, 1, m){\n\t\tscanf(\"%d\", &k), ans = 0;\n\t\tFor(i, 1, k) scanf(\"%d %d\", &v, &w), stk[i] = v, dis[v] = w, Crevise(1, 1, n, v, w - dep[v]), Trevise(1, 1, n, v, w + dep[v]); \n\t\tFor(i, 1, k) ans += Queryl(stk[i]) + Queryr(stk[i]) + 1;\n\t\tFor(i, 1, k) Crevise(1, 1, n, stk[i], inf), Trevise(1, 1, n, stk[i], inf);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1587367939,
        "uid": 163980,
        "name": "\u884c\u541f\u5578\u4e5d\u5dde",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4501 \u3010[ZJOI2018]\u80d6\u3011"
    },
    {
        "content": "\u4ece $0$ \u53f7\u70b9\u5230\u8fbe\u67d0\u4e00\u4e2a\u70b9\u540e\uff0c\u53ef\u4ee5\u88ab\u66f4\u65b0\u7684\u77ad\u671b\u5854\u663e\u7136\u662f\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5206\u522b\u5bf9\u505a\u53f3\u7aef\u70b9\u8fdb\u884c\u4e8c\u5206\u3002\n\n\u8bbe\u8981\u4ece $p$ \u66f4\u65b0\uff0c\u8fd9\u6761\u8def\u7684\u8ddd\u79bb\u4e3a $l$\uff0c\u5230\u8fbe\u7b2c $x$ \u4e2a\u70b9\uff0c\u90a3\u4e48\u4ee4 $d=|l-x|$\uff0c\u5728 $[x-d,x+d]$ \u5f53\u4e2d\u4e0d\u5e94\u8be5\u5b58\u5728\u8ddd\u79bb\u5c0f\u4e8e $p$ \u65f6\u8ddd\u79bb\u7684\u70b9\u3002\u9884\u5904\u7406\u51fa\u56fe\u4e0a\u8ddd\u79bb\u7684\u524d\u7f00\u548c $dis$\uff0c\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\u8981\u5206\u5728 $x$ \u7684\u5de6\u53f3\u8ba8\u8bba\uff0c\u5728 $x$ \u5de6\u8fb9\u65f6\u662f $dis_x+(l-dis_p)$\uff0c\u53f3\u8fb9\u65f6\u662f $-dis_x+(l+dis_p)$\uff0c\u8be2\u95ee\u524d ST \u8868\u9884\u5904\u7406\u4e24\u4e2a\u4fe1\u606f\u5373\u53ef\u6c42\u51fa\u8ddd\u79bb\u7684\u6700\u5c0f\u503c\uff08\u5efa\u7acb\u5927\u5c0f\u4e3a $K$ \u7684 ST \u8868\uff0c\u8be2\u95ee\u7684\u65f6\u5019\u76f4\u63a5\u4e8c\u5206\u51fa\u5de6\u53f3\u7aef\u70b9\u7684\u4f4d\u7f6e\uff09\u3002\n\n\u6ce8\u610f\u8ddd\u79bb\u76f8\u7b49\u65f6\u66f4\u65b0\u987a\u5e8f\u7684\u95ee\u9898\uff0c\u4e8c\u5206\u53f3\u7aef\u70b9\u65f6\u8981\u5bf9 $x+d$ \u7684\u4f4d\u7f6e\u505a\u4e00\u4e2a\u5355\u72ec\u7684\u8ba8\u8bba\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long i64; \nconst i64 INF = 2e18; \n\nint n, m, K; \nstruct Node {\n    int p, d; \n    bool operator< (const Node &a) const {\n        return p < a.p; \n    }\n} a[200005];\ni64 dis[200005]; \n\nnamespace ST {\n    int lg[200005]; i64 f[18][200005], g[18][200005]; \n    i64 query(int op, int l, int r) {\n        l = max(1, l); r = min(r, n); \n        Node tmp = {l, 0}; l = lower_bound(a + 1, a + K + 1, tmp) - a; \n        tmp = {r, 0}; r = upper_bound(a + 1, a + K + 1, tmp) - (a + 1);  \n        if (l > r) return INF; \n        int k = lg[r - l + 1]; \n        if (op == 1) return min(f[k][l], f[k][r - (1 << k) + 1]); \n        return min(g[k][l], g[k][r - (1 << k) + 1]); \n    }\n    void init(void) {\n        for (int i = 2; i <= K; ++i) lg[i] = lg[i >> 1] + 1; \n        for (int i = 1; i <= K; ++i) \n            f[0][i] = a[i].d - dis[a[i].p], \n            g[0][i] = a[i].d + dis[a[i].p]; \n        for (int i = 1; i <= lg[K]; ++i)\n            for (int j = 1; j + (1 << i) - 1 <= K; ++j)\n                f[i][j] = min(f[i - 1][j], f[i - 1][j + (1 << i - 1)]), \n                g[i][j] = min(g[i - 1][j], g[i - 1][j + (1 << i - 1)]); \n    }\n}\nusing namespace ST; \n\nbool checkl(int p, int x) { // p \u66f4\u65b0\u5230 x\uff0cx < p\n    if (p == x) return 1; int d = abs(p - x); \n    i64 t1 = query(1, x - d, x) + dis[x];\n    i64 t2 = query(2, x, x + d - 1) - dis[x]; \n    i64 now = query(2, p, p) - dis[x]; \n    return t1 > now && t2 > now; \n}\nint calcl(int p) {\n    int L = 0, R = p + 1;\n    while (L + 1 != R) {\n        int mid = L + R >> 1; \n        if (checkl(p, mid)) R = mid; \n        else L = mid; \n    }\n    return R; \n}\n\nbool checkr(int p, int x) { // \u4ece p \u80fd\u5426\u66f4\u65b0\u5230 x\uff0cx > p\n    if (p == x) return 1; int d = abs(p - x); \n    i64 t1 = query(1, x - d + 1, x) + dis[x]; \n    i64 t2 = query(2, x, x + d - 1) - dis[x]; \n    i64 now = query(1, p, p) + dis[x]; \n    if (t1 <= now || t2 <= now) return 0; \n    if (x + d <= n) return query(2, x + d, x + d) - dis[x] >= now; // p \u5728 x \u5de6\u8fb9\uff0c\u76f8\u7b49\u65f6\u4f1a\u5148\u66f4\u65b0\n    return 1; \n}\nint calcr(int p) {\n    int L = p - 1, R = n + 1; \n    while (L + 1 != R) {\n        int mid = L + R >> 1; \n        if (checkr(p, mid)) L = mid; \n        else R = mid; \n    }\n    return L; \n}\n\nint main(void) {\n    scanf(\"%d%d\", &n, &m); \n    for (int i = 2; i <= n; ++i) scanf(\"%lld\", dis + i), dis[i] += dis[i - 1]; \n    while (m--) {\n        scanf(\"%d\", &K); \n        for (int i = 1; i <= K; ++i) scanf(\"%d%d\", &a[i].p, &a[i].d); \n        sort(a + 1, a + K + 1); ST::init(); \n        \n        i64 ans = 0; \n        for (int i = 1; i <= K; ++i) ans += (calcr(a[i].p) - calcl(a[i].p) + 1); \n        printf(\"%lld\\n\", ans); \n    }\n    return 0; \n}\n```",
        "postTime": 1682187217,
        "uid": 187051,
        "name": "james1BadCreeper",
        "ccfLevel": 6,
        "title": "P4501"
    }
]