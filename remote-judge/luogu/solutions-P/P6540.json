[
    {
        "content": "\u9996\u5148\uff0c\u5bf9\u4e8e\u957f\u5e8f\u5217\u53f7\uff0c\u5efa\u51fa\u5b83\u7684 SAM\u3002  \n\n\u5148\u8003\u8651\u4e0d\u80fd\u591f\u5b8c\u5168\u5339\u914d\u7684\u60c5\u51b5\u3002  \n\u6211\u4eec\u628a\u77ed\u5e8f\u5217\u53f7\u5728\u957f\u5e8f\u5217\u53f7\u7684 SAM \u4e0a\u5339\u914d\uff0c\u524d $i$ \u4e2a\u5b57\u7b26\u5339\u914d\u5230\u7684 SAM \u4e0a\u7684\u8282\u70b9 $x$\uff0c\u6839\u636e SAM \u7684\u6027\u8d28\uff0c\u8fd9\u524d $i$ \u4e2a\u5b57\u7b26\u7ec4\u6210\u7684\u524d\u7f00\u4e32\u5e94\u4e3a $x$ \u5728 parent \u6811\u4e0a\u7684\u5b50\u6811\u4e2d\u4efb\u4e00\uff08\u6240\u6709\uff09\u8282\u70b9\u5bf9\u5e94\u4e32\u7684\u540e\u7f00\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u77ed\u4e32\u81f3\u5c11\u4f1a\u5728\u957f\u4e32\u4e2d $x$ \u5bf9\u5e94\u5b50\u6811\u4e2d\u6240\u6709\u70b9\u7684 pos \u96c6\u5408\u7684\u5e76\u4e2d\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u5339\u914d\u4e00\u6b21\u3002   \n\u53e6\u5916\uff0c\u5bf9\u4e8e\u5339\u914d\u4e0d\u4e0a\u7684\u60c5\u51b5\uff0c\u51fa\u73b0\u4e86 $n$ \u6b21\u3002  \n\n\u7136\u540e\u662f\u80fd\u591f\u5b8c\u5168\u5339\u914d\u7684\u60c5\u51b5\u3002  \n\u5927\u4f53\u540c\u4e0a\uff0c\u4e0d\u8fc7\u6709\u4e00\u70b9\uff0c\u5339\u914d\u4e0a\u4e86\u4ee5\u540e\u4f1a\u505c\u6b62\u5339\u914d\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u8bbe\u505c\u6b62\u4f4d\u7f6e\u4e3a $p$\uff0c\u524d $i$ \u4e2a\u5b57\u7b26\u7684\u524d\u7f00\u53ea\u5728\u524d\u8ff0\u96c6\u5408\u4e2d\u5728 $[1,p-(m-i)]$ \u4e2d\u7684\u4f4d\u7f6e\u5339\u914d\u4e0a\u8fc7\u3002  \n\u53e6\u5916\uff0c\u5bf9\u4e8e\u5339\u914d\u4e0d\u4e0a\u7684\u60c5\u51b5\uff0c\u51fa\u73b0\u4e86 $p-m$ \u6b21\u3002   \n\n\u6240\u4ee5\u95ee\u9898\u8f6c\u5316\u4e3a\u8be2\u95ee\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u4e2d\u6743\u503c\u5c0f\u4e8e\u7b49\u4e8e\u4e00\u4e2a\u6570\u7684\u6743\u503c\u7684\u4e2a\u6570\u3002\u4e8e\u662f\u6211\u4eec\u76f4\u63a5 dsu on tree \u7ef4\u62a4\u8be2\u95ee\u5373\u53ef\u3002  \n\n```cpp\n#include<cstdio>\n#include<vector>\n#include<cstring>\nconst int N=2e5+10,M=10,Q=3e6+10;\nint n,m,fa[N],to[N][M],len[N],pos[N],siz[N],son[N],cnt=1,las=1,a[Q],c[N];\nbool vis[N];\nlong long ans[N];\nstd::vector<int>g[N];\nstd::vector<std::pair<int,int> >q[N];\ninline void update(int x,int a){for(;x<=n;x+=x&-x)c[x]+=a;}\ninline int query(int x){int a=0;for(;x;x-=x&-x)a+=c[x];return a;}\nvoid insert(int c,int i)\n{\n\tint p=las,q=++cnt;las=q;\n\tlen[q]=len[p]+1;pos[q]=i;\n\twhile(p&&!to[p][c])to[p][c]=q,p=fa[p];\n\tif(!p)fa[q]=1;\n\telse\n\t{\n\t\tint x=to[p][c];\n\t\tif(len[x]==len[p]+1)fa[q]=x;\n\t\telse\n\t\t{\n\t\t\tint y=++cnt;memcpy(to[y],to[x],sizeof(to[x]));\n\t\t\tfa[y]=fa[x];fa[x]=fa[q]=y;len[y]=len[p]+1;pos[y]=pos[x];\n\t\t\twhile(p&&to[p][c]==x)to[p][c]=y,p=fa[p];\n\t\t}\n\t}\n}\ninline int min(int a,int b){return a<b?a:b;}\nvoid dfs0(int u)\n{\n\tsiz[u]=1;\n\tfor(int i=0,l=g[u].size();i<l;i++)\n\t{\n\t\tdfs0(g[u][i]);\n\t\tsiz[u]+=siz[g[u][i]];\n\t\tpos[u]=min(pos[u],pos[g[u][i]]);\n\t\tif(siz[son[u]]<siz[g[u][i]])\n\t\tson[u]=g[u][i];\n\t}\n}\nint qwq,flg;\nvoid dfs1(int u)\n{\n\tif(pos[u]&&flg==1&&!vis[pos[u]])update(pos[u],1),vis[pos[u]]=true;\n\tif(pos[u]&&flg==-1&&vis[pos[u]])update(pos[u],-1),vis[pos[u]]=false;\n\tfor(int i=0,l=g[u].size();i<l;i++)\n\tif(g[u][i]!=qwq)dfs1(g[u][i]);\n}\nvoid dfs(int u)\n{\n\tfor(int i=0,l=g[u].size();i<l;i++)\n\tif(g[u][i]!=son[u])dfs(g[u][i]);\n\tif(son[u])dfs(son[u]);\n\tqwq=son[u],flg=1;dfs1(u);\n\tfor(int i=0,l=q[u].size();i<l;i++)\n\tans[q[u][i].second]+=query(q[u][i].first);\n\tif(son[fa[u]]!=u)qwq=flg=-1,dfs1(u);\n}\nint main()\n{\n\tint i,j,x,y;scanf(\"%d\",&n);char ch;\n\tfor(i=1;i<=n;i++)scanf(\"%1d\",&x),insert(x,i);\n\tfor(i=2;i<=cnt;i++)g[fa[i]].push_back(i);\n\tdfs0(1);scanf(\"%d\",&m);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tdo ch=getchar(); while(ch<=32);a[0]=0;\n\t\tdo a[++a[0]]=ch-'0',ch=getchar(); while(ch>='0'&&ch<='9');\n\t\tfor(x=j=1;j<=a[0];j++)if(!to[x][a[j]])break;else x=to[x][a[j]];\n\t\tif(j<=a[0])y=n+a[0];else y=pos[x];ans[i]=y-a[0];\n\t\tfor(x=j=1;j<=a[0];j++)if(!to[x][a[j]])break;else x=to[x][a[j]],q[x].push_back(std::make_pair(min(y-(a[0]-j),n),i));\n\t}\n\tdfs(1);\n\tfor(i=1;i<=m;i++)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1617872628,
        "uid": 35137,
        "name": "a___",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6540 [COCI2013-2014#1] SLASTI\u010cAR"
    },
    {
        "content": "\u6d1b\u8c37\u535a\u5ba2\u7684\u683c\u5f0f\u597d\u50cf\u4e0d\u592a\u5bf9\uff0c[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://missingroom.github.io/_posts/2021-04-02-P6540/)\u3002\n\nUPD:\u7ed9\u51fa\u4e86 $O(n\\log n)$ \u7684\u5b9e\u73b0\uff0c\u6682\u65f6\u62ff\u5230\u4e86\u6700\u4f18\u89e3\u3002\n\n\u89c2\u5bdf\u9898\u610f\uff0c\u9898\u76ee\u6c42\u7684\u662f\u8be2\u95ee\u4e32\u4e0e\u7f16\u53f7\u4ece $1$ \u5230 $i$ \u7684\u540e\u7f00\u7684 $\\text{LCP}$ \u4e4b\u548c\u52a0 $i-1$\uff0c\u5176\u4e2d $i$ \u4e3a\u8be2\u95ee\u4e32\u7b2c\u4e00\u6b21\u5339\u914d\u7684\u4f4d\u7f6e\uff1b\u82e5\u65e0\u5339\u914d\u4f4d\u7f6e\u5219\u6c42\u5f97\u4e1c\u897f\u4e3a\u8be2\u95ee\u4e32\u548c\u6240\u6709\u540e\u7f00\u7684 $\\text{LCP}$ \u4e4b\u548c\u52a0 $n$\u3002\n\n\u8003\u8651\u5bf9\u957f\u5e8f\u5217\u53f7\u5efa\u540e\u7f00\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u5b50\u6811\u5185\u7f16\u53f7\u6700\u5c0f\u7684\u540e\u7f00\u7684\u7f16\u53f7\uff0c\u5c06\u8be2\u95ee\u4e32\u653e\u4e0a\u53bb\u5339\u914d\uff0c\u6211\u4eec\u5c06\u5931\u914d\u7684\u4f4d\u7f6e\u6216\u8005\u5339\u914d\u5230\u7684\u4f4d\u7f6e\u5b58\u4e0b\u6765\uff0c\u5982\u679c\u5728\u8fb9\u4e0a\uff0c\u5c31\u628a\u8fd9\u4e2a\u70b9\u5206\u88c2\u51fa\u6765\u3002\u8bbe\u6bcf\u6761\u8fb9\u8fb9\u6743\u4e3a $w_i$\uff0c\u521d\u59cb\u5168\u4e3a $0$\uff0c\u628a\u8be2\u95ee\u79bb\u7ebf\u4e0b\u6765\uff0c\u6309 $i$ \u6392\u5e8f\uff0c\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u628a\u4e00\u4e2a\u540e\u7f00\u5bf9\u5e94\u7684\u8282\u70b9\u5230\u6839\u7684\u6240\u6709\u8fb9\u7684 $w_i$ \u52a0 $1$\uff0c\u67e5\u8be2\u4e00\u4e2a\u8282\u70b9\u5230\u6839\u7684 $\\sum w_ilen_i$\uff0c\u6811\u5256\u52a0\u7ebf\u6bb5\u6811\u6216\u8005\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u5747\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$ \u6216 $O(n\\log n)$\u3002\n\n\u5177\u4f53\u7684\u7ec6\u8282\u53ef\u4ee5\u770b\u4ee3\u7801\uff1a\n\n$O(n\\log^2n)$\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nint n,m;\nchar s[100010],t[100010];\nstruct suffixTree{\n\tstatic const int inf=100000000;\n    int link[200010],len[300010],start[300010],s[200010],n,tail,now,rem,ch[300010][11];\n    suffixTree():link(),len(),start(),s(),n(0),tail(1),now(1),rem(0),ch(){len[0]=inf;}\n    int newnode(int st,int le){\n        link[++tail]=1;start[tail]=st;len[tail]=le;return tail;\n    }\n    void extend(int x){\n        s[++n]=x,rem++;\n        for(int last=1;rem;){\n            while(rem>len[ch[now][s[n-rem+1]]]) rem-=len[now=ch[now][s[n-rem+1]]];\n            int &v=ch[now][s[n-rem+1]];\n\t\t\tint c=s[start[v]+rem-1];\n            if(!v||x==c){\n                link[last]=now;last=now;\n                if(!v) v=newnode(n,inf);\n                else break;\n            }else{\n                int u=newnode(start[v],rem-1);\n                ch[u][c]=v;ch[u][x]=newnode(n,inf);\n                start[v]+=rem-1;len[v]-=rem-1; \n                link[last]=v=u;last=u;\n            }\n\t\t\tif(now==1) rem--;\n\t\t\telse now=link[now];\n        }\n    }\n}T;\nint dep[300010],p[300010],pos[100010];\nvoid dfs(int x){\n\tif(T.start[x]+T.len[x]-1>n){dep[x]-=T.len[x],dep[x]+=n-T.start[x]+1,pos[p[x]=n-dep[x]+1]=x;return;}\n\tp[x]=n+1;\n\tfor(int i=0;i<11;i++)if(T.ch[x][i]){\n\t\tdep[T.ch[x][i]]=dep[x]+T.len[T.ch[x][i]];\n\t\tdfs(T.ch[x][i]);\n\t\tp[x]=std::min(p[x],p[T.ch[x][i]]);\n\t}\n}\nint qcnt;\nlong long ans[100010];\nstruct que{\n\tint pos,qq,id;\n\tbool operator <(que const &x)const{\n\t\treturn qq<x.qq;\n\t}\n}q[100010];\nvoid insert(int x,const char *c){\n\tif(*c==0){\n\t\tq[qcnt].pos=x,q[qcnt].qq=p[x];\n\t\tans[qcnt]=p[x]-1;\n\t\treturn;\n\t}\n\tif(T.ch[x][*c-'0']){\n\t\tint s=T.ch[x][*c-'0'];\n\t\tint k=*c-'0';\n\t\tfor(int i=0;i<T.len[s];i++){\n\t\t\tif(*c==0){\n\t\t\t\tint cnt=++T.tail;\n\t\t\t\tT.start[cnt]=T.start[s];\n\t\t\t\tT.len[cnt]=i;\n\t\t\t\tT.start[s]+=i;\n\t\t\t\tT.len[s]-=i;\n\t\t\t\tT.ch[x][k]=cnt;\n\t\t\t\tT.ch[cnt][T.s[T.start[s]]]=s;\n\t\t\t\tp[cnt]=p[s];\n\t\t\t\tq[qcnt].pos=cnt,q[qcnt].qq=p[s];\n\t\t\t\tans[qcnt]=p[s]-1;\n\t\t\t\treturn;\n\t\t\t}else if(*c!=::s[T.start[s]+i]){\n\t\t\t\tint cnt=++T.tail;\n\t\t\t\tT.start[cnt]=T.start[s];\n\t\t\t\tT.len[cnt]=i;\n\t\t\t\tT.start[s]+=i;\n\t\t\t\tT.len[s]-=i;\n\t\t\t\tT.ch[x][k]=cnt;\n\t\t\t\tT.ch[cnt][T.s[T.start[s]]]=s;\n\t\t\t\tp[cnt]=p[s];\n\t\t\t\tq[qcnt].pos=cnt,q[qcnt].qq=n;\n\t\t\t\tans[qcnt]=n;\n\t\t\t\treturn;\n\t\t\t}else ++c;\n\t\t}\n\t\tinsert(s,c);\n\t}else{\n\t\tq[qcnt].pos=x,q[qcnt].qq=n;\n\t\tans[qcnt]=n;\n\t}\n}\nint dfn[300010],rk[300010],sz[300010],top[300010],f[300010],son[300010];\nvoid dfs1(int x,int fa){\n\tsz[x]=1,f[x]=fa;\n\tfor(int i=0;i<11;i++)if(T.ch[x][i]){\n\t\tdfs1(T.ch[x][i],x);\n\t\tsz[x]+=sz[T.ch[x][i]];\n\t\tif(sz[T.ch[x][i]]>sz[son[x]])son[x]=T.ch[x][i];\n\t}\n}\nint ct;\nvoid dfs2(int x,int tp){\n\tdfn[x]=++ct,rk[ct]=x,top[x]=tp;\n\tif(son[x])dfs2(son[x],tp);else return;\n\tfor(int i=0;i<11;i++)if(T.ch[x][i]&&T.ch[x][i]!=son[x]) dfs2(T.ch[x][i],T.ch[x][i]);\n}\nstruct node{\n\tlong long sum,p,tag;\n}tr[1200010];\nvoid build(int x=1,int l=1,int r=T.tail){\n\tif(l==r) return tr[x].sum=T.len[rk[l]],void();\n\tint mid=(l+r)>>1,ls=x<<1,rs=x<<1|1;\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n\ttr[x].sum=tr[ls].sum+tr[rs].sum;\n}\nvoid addtag(int x,int t){\n\ttr[x].tag+=t;\n\ttr[x].p+=t*tr[x].sum;\n}\nvoid pushdown(int x,int ls,int rs){\n\tif(tr[x].tag)addtag(ls,tr[x].tag),addtag(rs,tr[x].tag),tr[x].tag=0;\n}\nvoid update(int pl,int pr,int x=1,int l=1,int r=T.tail){\n\tif(l==pl&&r==pr) return addtag(x,1);\n\tint mid=(l+r)>>1,ls=x<<1,rs=x<<1|1;\n\tpushdown(x,ls,rs);\n\tif(pr<=mid) update(pl,pr,ls,l,mid);\n\telse if(pl>mid) update(pl,pr,rs,mid+1,r);\n\telse update(pl,mid,ls,l,mid),update(mid+1,pr,rs,mid+1,r);\n\ttr[x].p=tr[ls].p+tr[rs].p;\n}\nlong long query(int pl,int pr,int x=1,int l=1,int r=T.tail){\n\tif(l==pl&&r==pr) return tr[x].p;\n\tint mid=(l+r)>>1,ls=x<<1,rs=x<<1|1;\n\tpushdown(x,ls,rs);\n\tif(pr<=mid) return query(pl,pr,ls,l,mid);\n\telse if(pl>mid) return query(pl,pr,rs,mid+1,r);\n\telse return query(pl,mid,ls,l,mid)+query(mid+1,pr,rs,mid+1,r);\n}\nvoid update(int x){while(x)update(dfn[top[x]],dfn[x]),x=f[top[x]];}\nlong long query(int x){long long ans=0;while(x)ans+=query(dfn[top[x]],dfn[x]),x=f[top[x]];return ans;}\nint main(){\n\tscanf(\"%d%s\",&n,s+1);\n\tfor(int i=1;i<=n;i++)T.extend(s[i]-'0');\n\ts[n+1]='$';\n\tT.extend(10);\n\tT.ch[1][10]=0;\n\tdfs(1);\n\tscanf(\"%d\",&m);\n\tfor(qcnt=1;qcnt<=m;qcnt++){\n\t\tscanf(\"%s\",t+1);\n\t\tq[qcnt].id=qcnt;\n\t\tinsert(1,t+1);\n\t}\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tbuild();\n\tstd::sort(q+1,q+m+1);\n\tfor(int i=1,j=1;i<=m;i++){\n\t\tfor(;j<=q[i].qq;j++)update(pos[j]);\n\t\tans[q[i].id]+=query(q[i].pos);\n\t}\n\tfor(int i=1;i<=m;i++)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```\n\u8fd9\u4e2a\u662f $O(n\\log n)$\n\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<vector>\nint n,m;\nchar ch[100010],t[100010];\nstruct suffixTree{\n\tstatic const int inf=100000000;\n    int link[200010],len[300010],start[300010],s[200010],n,tail,now,rem,ch[300010][11];\n    suffixTree():link(),len(),start(),s(),n(0),tail(1),now(1),rem(0),ch(){len[0]=inf;}\n    int newnode(int st,int le){\n        link[++tail]=1;start[tail]=st;len[tail]=le;return tail;\n    }\n    void extend(int x){\n        s[++n]=x,rem++;\n        for(int last=1;rem;){\n            while(rem>len[ch[now][s[n-rem+1]]]) rem-=len[now=ch[now][s[n-rem+1]]];\n            int &v=ch[now][s[n-rem+1]];\n\t\t\tint c=s[start[v]+rem-1];\n            if(!v||x==c){\n                link[last]=now;last=now;\n                if(!v) v=newnode(n,inf);\n                else break;\n            }else{\n                int u=newnode(start[v],rem-1);\n                ch[u][c]=v;ch[u][x]=newnode(n,inf);\n                start[v]+=rem-1;len[v]-=rem-1; \n                link[last]=v=u;last=u;\n            }\n\t\t\tif(now==1) rem--;\n\t\t\telse now=link[now];\n        }\n    }\n}T;\nint dep[300010],p[300010],pos[100010];\nstd::vector<int> g[300010];\nvoid dfs(int x){\n\tif(T.start[x]+T.len[x]-1>n){dep[x]-=T.len[x],dep[x]+=T.n-T.start[x]+1,pos[p[x]=T.n-dep[x]+1]=x;return;}\n\tp[x]=n+1;\n\tfor(int i=0;i<11;i++)if(T.ch[x][i]){\n\t\tdep[T.ch[x][i]]=dep[x]+T.len[T.ch[x][i]];\n\t\tdfs(T.ch[x][i]);\n\t\tp[x]=std::min(p[x],p[T.ch[x][i]]);\n//\t\tprintf(\"%d %d \",x,T.ch[x][i]);\n//\t\tfor(int j=T.start[T.ch[x][i]];j<std::min(T.n+1,T.start[T.ch[x][i]]+T.len[T.ch[x][i]]);j++)putchar(T.s[j]+'0');\n//\t\tputs(\"\");\n\t}\n}\nint qcnt;\nlong long ans[100010];\nstruct que{\n\tint pos,qq,id;\n\tbool operator <(que const &x)const{\n\t\treturn qq<x.qq;\n\t}\n}q[100010];\nvoid insert(int x,const char *c){\n\tif(*c==0){\n\t\tq[qcnt].pos=x,q[qcnt].qq=p[x];\n\t\tans[qcnt]=p[x]-1;\n\t\treturn;\n\t}\n\tif(T.ch[x][*c-'0']){\n\t\tint s=T.ch[x][*c-'0'];\n\t\tint k=*c-'0';\n\t\tfor(int i=0;i<T.len[s];i++){\n\t\t\tif(*c==0){\n\t\t\t\tint cnt=++T.tail;\n\t\t\t\tT.start[cnt]=T.start[s];\n\t\t\t\tT.len[cnt]=i;\n\t\t\t\tdep[cnt]=dep[x]+i;\n\t\t\t\tT.start[s]+=i;\n\t\t\t\tT.len[s]-=i;\n\t\t\t\tT.ch[x][k]=cnt;\n\t\t\t\tT.ch[cnt][T.s[T.start[s]]]=s;\n\t\t\t\tp[cnt]=p[s];\n\t\t\t\tq[qcnt].pos=cnt,q[qcnt].qq=p[s];\n\t\t\t\tans[qcnt]=p[s]-1;\n\t\t\t\treturn;\n\t\t\t}else if(*c!=::ch[T.start[s]+i]){\n\t\t\t\tint cnt=++T.tail;\n\t\t\t\tT.start[cnt]=T.start[s];\n\t\t\t\tT.len[cnt]=i;\n\t\t\t\tdep[cnt]=dep[x]+i;\n\t\t\t\tT.start[s]+=i;\n\t\t\t\tT.len[s]-=i;\n\t\t\t\tT.ch[x][k]=cnt;\n\t\t\t\tT.ch[cnt][T.s[T.start[s]]]=s;\n\t\t\t\tp[cnt]=p[s];\n\t\t\t\tq[qcnt].pos=cnt,q[qcnt].qq=n;\n\t\t\t\tans[qcnt]=n;\n\t\t\t\treturn;\n\t\t\t}else ++c;\n\t\t}\n\t\tinsert(s,c);\n\t}else{\n\t\tq[qcnt].pos=x,q[qcnt].qq=n;\n\t\tans[qcnt]=n;\n\t}\n}\nint sz[300010],son[300010],f[300010],k,s[300010][2];\nlong long val[300010];\nvoid dfs1(int x){\n\tsz[x]=1;\n\tfor(int i=0,to;i<11;i++)if(T.ch[x][i]){\n\t\tg[x].push_back(to=T.ch[x][i]);\n\t\tval[to]=dep[to]-dep[x];\n\t\tdfs1(to);\n\t\tsz[x]+=sz[to];\n\t\tif(sz[to]>sz[son[x]])son[x]=to;\n\t}\n}\nint b[300010],bs[300010];\nlong long ss[300010];\nint cbuild(int l,int r){\n\tint x=l,y=r,m=r;\n\twhile(x<=y){\n\t\tint mid=(x+y)>>1;\n\t\tif(bs[mid-1]-bs[l-1]<=bs[r]-bs[mid-1])m=mid,x=mid+1;\n\t\telse y=mid-1;\n\t}\n\tx=b[m];\n\tif(m!=l) f[s[x][0]=cbuild(l,m-1)]=x;\n\tif(m!=r) f[s[x][1]=cbuild(m+1,r)]=x;\n\tss[x]=val[x]+ss[s[x][0]]+ss[s[x][1]];\n\treturn x;\n}\nint build(int x){\n\tint y=x;\n\tdo\n\t\tfor(int to:g[y])\n\t\t\tif(to!=son[y])\n\t\t\t\tf[build(to)]=y;\n\twhile((y=son[y]));\n\tdo\n\t\tb[++y]=x,bs[y]=bs[y-1]+sz[x]-sz[son[x]];\n\twhile((x=son[x]));\n\treturn cbuild(1,y);\n}\nlong long lz[300010],v[300010];\ninline void update(int x){\n\tlong long p=0;\n\tint t=1;\n\twhile(x){\n\t\tv[x]=v[x]+p;\n\t\tif(t){\n\t\t\t++lz[x];\n\t\t\tif(s[x][1])--lz[s[x][1]];\n\t\t\tp=p+val[x]+ss[s[x][0]];\n\t\t\tv[x]=v[x]-ss[s[x][1]];\n\t\t}\n\t\tt=(x!=s[f[x]][0]?1:0);\n\t\tif(t&&x!=s[f[x]][1])p=0;\n\t\tx=f[x];\n\t}\n}\ninline int query(int x){\n\tlong long p=0,ret=0;\n\tint t=1;\n\twhile(x){\n\t\tif(t){\n\t\t\tret=ret+v[x]-v[s[x][1]];\n\t\t\tret=ret-ss[s[x][1]]*lz[s[x][1]];\n\t\t\tp=p+val[x]+ss[s[x][0]];\n\t\t}\n\t\tret=ret+p*lz[x];\n\t\tt=(x!=s[f[x]][0]?1:0);\n\t\tif(t&&x!=s[f[x]][1])p=0;\n\t\tx=f[x];\n\t}\n\treturn ret;\n}\nint main(){\n\tscanf(\"%d%s\",&n,ch+1);\n\tfor(int i=1;i<=n;i++)T.extend(ch[i]-'0');\n\tch[n+1]='$';\n\tT.extend(10);\n\tT.ch[1][10]=0;\n\tdfs(1);\n\tscanf(\"%d\",&m);\n\tfor(qcnt=1;qcnt<=m;qcnt++){\n\t\tscanf(\"%s\",t+1);\n\t\tq[qcnt].id=qcnt;\n\t\tinsert(1,t+1);\n\t}\n\tdfs1(1);\n\tbuild(1);\n\tstd::sort(q+1,q+m+1);\n\tfor(int i=1,j=1;i<=m;i++){\n\t\tfor(;j<=q[i].qq;j++)update(pos[j]);\n\t\tans[q[i].id]+=query(q[i].pos);\n\t}\n\tfor(int i=1;i<=m;i++)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1617408669,
        "uid": 55707,
        "name": "gxy001",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6540 [COCI2013-2014#1] SLASTI\u010cAR"
    }
]