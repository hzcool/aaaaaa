[
    {
        "content": "\u4ee5\u4e0b\u5185\u5bb9p\u5747\u6307\u6a21\u6570998244353\n\n\u524d\u7f6e\u829d\u58eb\uff1a\u4e8c\u6b21\u5269\u4f59\uff08\u6a21\u5947\u7d20\u6570\u610f\u4e49\u4e0b\uff09\n\n\u4e8c\u6b21\u5269\u4f59\uff1a\u6c42y\u4f7f\u5f97$y^2=x(mod\\ p)$\n\n\u4eca\u5e74WC\u7684zzt\u5927\u4f6c\u8bb2\u8bfe\u8bfe\u4ef6\u4e2d\u63d0\u5230\u51e0\u79cd\u6c42\u4e8c\u6b21\u5269\u4f59\u7684\u7b97\u6cd5\uff0c\u8fd9\u9898\u5e94\u8be5\u90fd\u80fd\u7528\n\n## \u6cd5\u4e00\uff1a\u66b4\u529b\n\n\u6c42\u51fa\u6a21p\u610f\u4e49\u4e0b\u7684\u4e00\u4e2a\u539f\u6839(\u5176\u4e2d\u4e00\u4e2a\u662f3)\uff0cbsgs\u6c42\u51fax\u7684\u6307\u6807\uff08\u5373\u6c42\u51faa\u4f7f\u5f97$3^a=x(mod\\ p)$\uff09\uff0c\u7136\u540e\u76f4\u63a5\u6307\u6807\u9664\u4ee5\u4e8c\u5373\u53ef\uff0c\u590d\u6742\u5ea6$O(\\sqrt{p})$\n\n## \u6cd5\u4e8c\uff1aCipolla\u7b97\u6cd5\n\n\u627e\u5230\u4e00\u4e2ab\uff0c\u4f7f\u5f97$(b^2-x)$\u4e3a\u6a21\u610f\u4e49\u4e0b\u7684**\u4e8c\u6b21\u975e\u5269\u4f59**\uff0c\u8bbe$(b^2-x)$\u4e3aw\u5219$y=(b+\\sqrt{w})^\\frac{p+1}{2}$\uff0c\u8fd9\u91cc\u7684$\\sqrt{w}$\u4e0d\u80fd\u5177\u4f53\u6c42\u51fa\uff08\u5b9e\u9645\u4e0a\u4e5f\u6ca1\u6709\uff09\uff0c\u8ba1\u7b97\u65f6\u5b83\u7c7b\u4f3c\u4e8e\u590d\u6570\u91cc\u7684i\uff0c\u6574\u4e2a\u6570\u5b57\u9700\u8981\u5212\u5206\u5b9e\u90e8\u865a\u90e8\u5e76\u91cd\u8f7d\u4e58\u6cd5\u8fd0\u7b97\u3002\n\nb\u7684\u6c42\u6cd5\uff1f\u76f4\u63a5rand\u51e0\u4e2ab\uff0c\u7531\u4e8e\u6070\u597d\u6709\u4e00\u534a\u6570\u5b57\u662f\u53ef\u4ee5\u5f53\u6210b\u7684\uff0c\u53e6\u4e00\u534a\u4e0d\u80fd\uff0c\u6240\u4ee5\u671f\u671b\u6b21\u65702\u6b21\uff0c\u603b\u590d\u6742\u5ea6$O(log_2p)$\n\nupd:\u8bc1\u660e\u5982\u4e0b\uff1a\u6839\u636e\u4e8c\u9879\u5f0f\u5b9a\u7406\uff0c$y^2=b^{p+1}+\\sqrt{w^{p+1}}$(\u5176\u4f59\u9879\u90fd\u542b\u6709p\uff0c\u53ef\u4ee5\u76f4\u63a5\u6d88\u53bb)\uff0c\u6839\u636e\u6b27\u62c9\u5224\u5b9a\u53ef\u77e5$\\sqrt{w^{p+1}}=w^{\\frac{p+\t1}{2}}=-w$\uff0c\u6839\u636e\u6b27\u62c9\u5b9a\u7406\u53ef\u77e5$b^{p+1}=b^2$\uff0c\u6240\u4ee5$y^2=b^2-w=x$\n\n\u4e3a\u4ec0\u4e48\u4e0d\u8bb2WC\u7684\u7b2c\u4e09\u79cd\u505a\u6cd5Tonelli-Shanks \u7b97\u6cd5\uff1f~~\u6211\u4e0d\u4f1a~~\n\n\u4ee5\u4e0b\u662f\u672c\u9898\u6b63\u7247\n## \u89e3\u6cd5\u4e00\uff1a\u66b4\u529b\u6c42$A^{\\frac{1}{2}}$\n\n\u524d\u7f6e\u829d\u58eb\uff1a[\u591a\u9879\u5f0f\u5e42\u51fd\u6570\uff08\u52a0\u5f3a\u7248\uff09](https://www.luogu.org/problemnew/show/P5273)\n\n\u628a\u4ee3\u7801\u7c98\u8fc7\u6765\uff0c\u6ce8\u610f\u5904\u7406\u5f53\u524d\u51e0\u4f4d\u4e3a0\u65f6\u539f\u6765\u7684\u505a\u6cd5\u4f1a\u628a\u5168\u90e8\u503c\u90fd\u8d4b\u503c\u62100\uff08\u56e0\u4e3a\u6b21\u6570\u592a\u9ad8\u4e86\uff0c\u539f\u672c\u7684\u505a\u6cd5\u6700\u540e\u662f\u628a\u6570\u7ec4**\u53f3\u79fb**\uff09\uff0c\u8fd9\u91cc\u8003\u8651\u672c\u8eab\u9700\u8981\u662f\u5f00\u6839\u53f7\uff0c\u5982\u679c\u540e\u51e0\u4f4d\u6709k\u4e2a0\u53ea\u8981\u505a\u5b8c\u5e42\u51fd\u6570\u4e4b\u540e\u91cd\u65b0**\u5de6\u79fb**k/2\u4f4d\u5c31\u53ef\u4ee5\u4e86\n\n\u53e6\u4e00\u4e2a\u7ec6\u8282\uff1a\u5bf9\u4e8e\u6570\u5b57x\u6765\u8bf4\uff0c$x^{p-1}=1(mod\\ p)$\uff0c\u7136\u800c\u5bf9\u4e8e\u591a\u9879\u5f0ff(x)\u6765\u8bf4$f^p(x)=1(mod\\ p)(mod\\ x^n)$\uff0c\u6240\u4ee5\u5b9e\u9645\u4e0a\u505a\u7684\u662ff(x)\u7684$2^{p-2}$\u6b21\u65b9\uff0c\u4f46\u63d0\u53d6\u7b2c\u4e00\u4e2a\u975e0\u65f6\u5e94\u8be5\u7167\u5e38\u6c42\u5176\u4e8c\u6b21\u5269\u4f59\uff0c\u4e0d\u80fd\u4e5f\u63d0\u53d6${a_0}^{(2^{p-2})}$\u51fa\u6765\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff0c\u5efa\u8bae\u5438\u6c27\u4f7f\u7528\u6b64\u65b9\u6cd5\n```cpp\n// luogu-judger-enable-o2\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\nconst int N=2.7e5,p=998244353,I=86583718,II=911660635;\nint r[N],ig[N],yg[N],invf[N],sqrtf[N],sqrtg[N],cdqf[N],cdqg[N],lnf[N],expf[N],expg[N];\nint ksmf[N],inv[N],f[N],g[N],sinf[N],sing[N],cosf[N],cosg[N],tanf[N],tang[N],cotf[N];\nint cotg[N];\nint n,m,i,j,l,limit,biglimit,c,w;\npa ys,yys;\ninline int sj()\n{\n    return rand()<<15|rand();\n}\npa operator *(pa x,pa y)\n{\n    ys.first=((ll)x.first*y.first+(ll)x.second*y.second%p*w)%p;\n    ys.second=((ll)x.first*y.second+(ll)x.second*y.first)%p;\n    return ys;\n}\ninline void dbug(int *a,int n)\n{\n    for (int i=0;i<n;i++) printf(\"%d \",a[i]);puts(\"\");\n}\ninline void read(int &x)\n{\n    c=getchar();\n    while ((c<48)||(c>57)) c=getchar();\n    x=c^48;c=getchar();\n    while ((c>=48)&&(c<=57))\n    {\n        x=x*10+(c^48);\n        c=getchar();\n    }\n}\ninline int ksm(int x,int y)\n{\n    int r=1;\n    while (y)\n    {\n        if (y&1) r=(ll)r*x%p;\n        x=(ll)x*x%p;\n        y>>=1;\n    }\n    return r;\n}\ninline pa ksm(pa x,int y)\n{\n    yys.first=1;yys.second=0;\n    while (y)\n    {\n        if (y&1) yys=yys*x;\n        x=x*x;\n        y>>=1;\n    }\n    return yys;\n}\ninline int mosqrt(int x)\n{\n    pa a;\n    int y=rand()%p;\n    while (ksm(w=((ll)y*y%p-x+p)%p,p-1>>1)<=1) y=rand()%p;\n    if (w<0) w+=p;\n    a.first=y;a.second=1;\n    a=ksm(a,p+1>>1);\n    return min(a.first,p-a.first);\n}\ninline void ycl(int l,int limit)\n{\n    for (int i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;\n}\ninline void gg(int limit)\n{\n    int i;\n    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);\n    for (i=limit>>1;i;i>>=1)\n    {\n        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;\n        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;\n    }\n    inv[1]=1;\n    for (i=2;i<limit;i++) inv[i]=p-(ll)p/i*inv[p%i]%p;\n}\ninline void reverse(int limit,int *f)\n{\n    int lim=limit>>1;\n    for (i=0;i<lim;i++) swap(f[i],f[limit-i-1]);\n}\ninline void dao(int *a,int n)\n{\n    for (i=1;i<n;i++) a[i-1]=(ll)a[i]*i%p;a[n-1]=0;\n}\ninline void ji(int *a,int n)\n{\n    for (i=n-1;~i;i--) a[i+1]=(ll)a[i]*inv[i+1]%p;\n    a[0]=0;\n}\nvoid dft(int *a,int xs,int limit)\n{\n    register int i,j,k,l,w,wn,b,c;\n    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);\n    for (i=1;i<limit;i=l)\n    {\n        l=i<<1;\n        if (xs) wn=ig[l]; else wn=yg[l];\n        for (j=0;j<limit;j+=l)\n        {\n            w=1;\n            for (k=0;k<i;k++,w=(ll)w*wn%p)\n            {\n                b=a[j|k];c=(ll)w*a[j|k|i]%p;\n                a[j|k]=(b+c)%p;\n                a[j|k|i]=(b-c+p)%p;\n            }\n        }\n    }\n    if (xs)\n    {\n        limit=ksm(limit,p-2);\n        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;\n    }\n}\nvoid polymultiply(int *f,int *g,int limit)\n{\n    int i;\n    dft(f,0,limit<<1);dft(g,0,limit<<1); \n    for (i=0;i<limit<<1;i++) f[i]=(ll)f[i]*g[i]%p;\n    dft(f,limit,limit<<1);\n}\nvoid polyinv(int *f,int *g,int biglim)\n{\n    int i,j,l=1,limit;\n    memset(g,0,biglim<<3);\n    memset(invf,0,biglim<<3);\n    g[0]=ksm(f[0],p-2);\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        memcpy(invf,f,limit<<1);\n        for (j=1;j<limit;j++) r[j]=r[j>>1]>>1|(j&1)<<l;\n        dft(invf,0,limit);dft(g,0,limit);\n        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(p+2-(ll)g[j]*invf[j]%p)%p;\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\nvoid polysqrt(int *f,int *g,int biglim)//\u4e0d\u52a8f\n{\n    memset(sqrtf,0,biglim<<3);\n    memset(sqrtg,0,biglim<<3);\n    memset(g,0,biglim<<3);\n    int i,j,l=1,limit;\n    g[0]=mosqrt(f[0]);\n    if ((ll)g[0]*g[0]%p!=f[0]) while (1);\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        polyinv(g,sqrtg,i);\n        memcpy(sqrtf,f,limit<<1);\n        dft(sqrtf,0,limit);dft(sqrtg,0,limit);dft(g,0,limit);\n        for (j=0;j<limit;j++)\n        {\n            g[j]=(ll)sqrtg[j]*((ll)g[j]*g[j]%p+sqrtf[j])%p;\n            if (g[j]&1) g[j]=g[j]+p>>1; else g[j]>>=1;\n        }\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\n/*void polycdq(int l,int r,int *f,int *g)\n{\n    if (l==r) return;\n    int mid=l+r>>1;\n    polycdq(l,mid,f,g);\n    int i,limit,li,siz=r-l;\n    limit=1;li=-1;\n    while (limit<=siz)\n    {\n        limit<<=1;++li;\n    }\n    for (i=l;i<=mid;i++) cdqf[i-l]=f[i];\n    for (i=mid-l+1;i<lim;i++) cdqf[i]=0;\n    for (i=1;i<=r-l;i++) cdqg[i]=g[i];G[0]=0;\n    for (i=r-l+1;i<lim;i++) cdqg[i]=0;\n    polymultiply(cdqf,cdqg,li,limit);\n    for (i=mid+1;i<=r;i++)\n    {\n        f[i]+=cdqf[i-l];\n        if (f[i]>=p) f[i]-=p;\n    }\n    polycdq(mid+1,r,f,g);\n}*/\nvoid polydivide(int *f,int *g,int *q,int *r,int limit)\n{\n\n}\nvoid polyln(int *f,int *g,int biglim)\n{\n    int i,limit=biglim<<1;\n    memcpy(lnf,f,biglim<<2);\n    memset(lnf+biglim,0,biglim<<2);\n    polyinv(f,g,biglim);\n    dao(lnf,biglim);\n    dft(lnf,0,limit);dft(g,0,limit);\n    for (i=0;i<limit;i++) g[i]=(ll)g[i]*lnf[i]%p;\n    dft(g,biglim,limit);\n    memset(g+biglim,0,biglim<<2);\n    ji(g,biglim);\n}\nvoid polyexp(int *f,int *g,int biglim)\n{\n    memset(g,0,biglim<<3);\n    memset(expf,0,biglim<<3);\n    memset(expg,0,biglim<<3);\n    g[0]=1;\n    int i,j,l=1,limit;\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        memcpy(expf,f,limit<<1);\n        polyln(g,expg,i);\n        dft(expf,0,limit);dft(g,0,limit);dft(expg,0,limit);\n        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(1+expf[j]-expg[j]+p)%p;\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\nvoid polyksm1(int *f,int *g,int biglim,int cs)\n{\n    if (cs==0)\n    {\n        g[0]=1;\n        return;\n    }\n    int i,j,k=1,wy=0;\n    if (f[0]==0)\n    {\n        for (i=1;i<biglim;i++) if (f[i]) break;\n        for (j=0;j<biglim-i;j++) f[j]=f[j+i];\n        memset(f+biglim-i,0,i<<2);\n        wy=cs>>1;\n    }\n    if (f[0]>1)\n    {\n        k=ksm(f[0],p-2);\n        for (i=1;i<biglim;i++) f[i]=(ll)f[i]*k%p;\n        k=mosqrt(f[0]);f[0]=1;//printf(\"%d\\n\",k);\n    }\n    polyln(f,ksmf,biglim);\n    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;\n    polyexp(ksmf,g,biglim);\n    if (k!=1)\n    {\n        for (i=0;i<biglim;i++) g[i]=(ll)g[i]*k%p;\n    }\n    if (wy)\n    {\n        for (i=wy;i<biglim;i++) g[i-wy]=g[i],g[i]=0;\n    }\n}\nvoid polyksm2(int *f,int *g,int biglim,int cs)\n{\n    int limit=1,i,l=-1;\n    while (limit<=biglim)\n    {\n        limit<<=1;++l;\n    }\n    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;g[0]=1;\n    while (cs)\n    {\n        if (cs&1)\n        {\n            memcpy(ksmf,f,biglim<<2);\n            memset(ksmf+biglim,0,biglim<<2);\n            polymultiply(g,ksmf,biglim);\n            memset(g+biglim,0,biglim<<2);\n        }\n        dft(f,0,limit);\n        for (i=0;i<limit;i++) f[i]=(ll)f[i]*f[i]%p;\n        dft(f,biglim,limit);\n        memset(f+biglim,0,biglim<<2);\n        cs>>=1;\n    }\n}\nvoid polyksm3(int *f,int *g,int biglim,int cs)\n{\n    int i;\n    memset(ksmf,0,biglim<<3);\n    memset(g,0,biglim<<3);\n    polyln(f,ksmf,biglim);\n    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;\n    polyexp(ksmf,g,biglim);\n}\nvoid polysin(int *f,int *g,int biglim)\n{\n    int i;\n    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;\n    polyexp(g,sinf,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;\n    polyexp(g,sing,biglim);\n    for (i=0;i<biglim;i++) g[i]=(ll)(sinf[i]-sing[i]+p)*II%p;\n    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;\n}\nvoid polycos(int *f,int *g,int biglim)\n{\n    int i;\n    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;\n    polyexp(g,cosf,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;\n    polyexp(g,cosg,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=cosf[i]+cosg[i])>=p) g[i]-=p;\n    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;\n}\nvoid polytan(int *f,int *g,int biglim)\n{\n    polysin(f,tanf,biglim);\n    polycos(f,tang,biglim);\n    polyinv(tang,g,biglim);\n    polymultiply(g,tanf,biglim);\n}\nvoid polycot(int *f,int *g,int biglim)\n{\n    polysin(f,cotf,biglim);\n    polycos(f,cotg,biglim);\n    polyinv(cotf,g,biglim);\n    polymultiply(g,cotg,biglim);\n}\nint main()\n{\n    read(n);\n    limit=1;\n    while (limit<n) limit<<=1;\n    for (i=0;i<n;i++) read(f[i]);gg(limit<<1);\n    polyksm1(f,g,limit,ksm(2,p-2));\n    for (i=0;i<n;i++) printf(\"%d \",g[i]);\n}\n```\n## \u89e3\u6cd5\u4e8c\uff1a\u63a8\u67ff\u5b50\n\u524d\u7f6e\u829d\u58eb\uff1a[\u591a\u9879\u5f0f\u6c42\u9006](https://www.luogu.org/problemnew/show/P4238)\u3001\u5957\u8def\u500d\u589e\uff08\u5f53\u7136\u76f4\u63a5\u725b\u987f\u8fed\u4ee3\u4e5f\u4e0d\u662f\u4e0d\u884c\uff09\n\n\u8bbe$F^2(x)=A(x)(mod\\ x^n),G^2(x)=A(x)(mod\\ x^{2n})$(\u4ee5\u4e0b\u76f4\u63a5\u7528A\u3001F\u548cG\u4ee3\u8868\u591a\u9879\u5f0f)\n\n\u5219$(F-G)^2=0(mod\\ x^{2n})$\n\n\u62c6\u5f00\u53d1\u73b0$F^2+G^2=2FG(mod\\ x^{2n})$\n\n$G^2=A(mod\\ x^{2n})$\u6240\u4ee5$G=\\frac{F^2+A}{2F}$\n\n\u7136\u540e\u76f4\u63a5\u500d\u589e\u5373\u53ef\uff0c\u8fb9\u754c\u6761\u4ef6\u6c42\u4e00\u6b21\u4e8c\u6b21\u5269\u4f59\n\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\nconst int N=2.7e5,p=998244353,I=86583718,II=911660635;\nint r[N],ig[N],yg[N],invf[N],sqrtf[N],sqrtg[N],cdqf[N],cdqg[N],lnf[N],expf[N],expg[N];\nint ksmf[N],inv[N],f[N],g[N],sinf[N],sing[N],cosf[N],cosg[N],tanf[N],tang[N],cotf[N];\nint cotg[N];\nint n,m,i,j,l,limit,biglimit,c,w;\npa ys,yys;\ninline int sj()\n{\n    return rand()<<15|rand();\n}\npa operator *(pa x,pa y)\n{\n    ys.first=((ll)x.first*y.first+(ll)x.second*y.second%p*w)%p;\n    ys.second=((ll)x.first*y.second+(ll)x.second*y.first)%p;\n    return ys;\n}\ninline void dbug(int *a,int n)\n{\n    for (int i=0;i<n;i++) printf(\"%d \",a[i]);puts(\"\");\n}\ninline void read(int &x)\n{\n    c=getchar();\n    while ((c<48)||(c>57)) c=getchar();\n    x=c^48;c=getchar();\n    while ((c>=48)&&(c<=57))\n    {\n        x=x*10+(c^48);\n        c=getchar();\n    }\n}\ninline int ksm(int x,int y)\n{\n    int r=1;\n    while (y)\n    {\n        if (y&1) r=(ll)r*x%p;\n        x=(ll)x*x%p;\n        y>>=1;\n    }\n    return r;\n}\ninline pa ksm(pa x,int y)\n{\n    yys.first=1;yys.second=0;\n    while (y)\n    {\n        if (y&1) yys=yys*x;\n        x=x*x;\n        y>>=1;\n    }\n    return yys;\n}\ninline int mosqrt(int x)\n{\n    pa a;\n    int y=rand()%p;\n    while (ksm(w=((ll)y*y%p-x+p)%p,p-1>>1)<=1) y=rand()%p;\n    if (w<0) w+=p;\n    a.first=y;a.second=1;\n    a=ksm(a,p+1>>1);\n    return min(a.first,p-a.first);\n}\ninline void ycl(int l,int limit)\n{\n    for (int i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;\n}\ninline void gg(int limit)\n{\n    int i;\n    ig[limit]=ksm(yg[limit]=ksm(3,(p-1)/limit),p-2);\n    for (i=limit>>1;i;i>>=1)\n    {\n        yg[i]=(ll)yg[i<<1]*yg[i<<1]%p;\n        ig[i]=(ll)ig[i<<1]*ig[i<<1]%p;\n    }\n    inv[1]=1;\n    for (i=2;i<limit;i++) inv[i]=p-(ll)p/i*inv[p%i]%p;\n}\ninline void reverse(int limit,int *f)\n{\n    int lim=limit>>1;\n    for (i=0;i<lim;i++) swap(f[i],f[limit-i-1]);\n}\ninline void dao(int *a,int n)\n{\n    for (i=1;i<n;i++) a[i-1]=(ll)a[i]*i%p;a[n-1]=0;\n}\ninline void ji(int *a,int n)\n{\n    for (i=n-1;~i;i--) a[i+1]=(ll)a[i]*inv[i+1]%p;\n    a[0]=0;\n}\nvoid dft(int *a,int xs,int limit)\n{\n    register int i,j,k,l,w,wn,b,c;\n    for (i=1;i<limit;i++) if (i<r[i]) swap(a[i],a[r[i]]);\n    for (i=1;i<limit;i=l)\n    {\n        l=i<<1;\n        if (xs) wn=ig[l]; else wn=yg[l];\n        for (j=0;j<limit;j+=l)\n        {\n            w=1;\n            for (k=0;k<i;k++,w=(ll)w*wn%p)\n            {\n                b=a[j|k];c=(ll)w*a[j|k|i]%p;\n                a[j|k]=(b+c)%p;\n                a[j|k|i]=(b-c+p)%p;\n            }\n        }\n    }\n    if (xs)\n    {\n        limit=ksm(limit,p-2);\n        for (i=0;i<xs;i++) a[i]=(ll)a[i]*limit%p;\n    }\n}\nvoid polymultiply(int *f,int *g,int limit)\n{\n    int i;\n    dft(f,0,limit<<1);dft(g,0,limit<<1); \n    for (i=0;i<limit<<1;i++) f[i]=(ll)f[i]*g[i]%p;\n    dft(f,limit,limit<<1);\n}\nvoid polyinv(int *f,int *g,int biglim)\n{\n    int i,j,l=1,limit;\n    memset(g,0,biglim<<3);\n    memset(invf,0,biglim<<3);\n    g[0]=ksm(f[0],p-2);\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        memcpy(invf,f,limit<<1);\n        for (j=1;j<limit;j++) r[j]=r[j>>1]>>1|(j&1)<<l;\n        dft(invf,0,limit);dft(g,0,limit);\n        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(p+2-(ll)g[j]*invf[j]%p)%p;\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\nvoid polysqrt(int *f,int *g,int biglim)//\u4e0d\u52a8f\n{\n    memset(sqrtf,0,biglim<<3);\n    memset(sqrtg,0,biglim<<3);\n    memset(g,0,biglim<<3);\n    int i,j,l=1,limit;\n    g[0]=mosqrt(f[0]);\n    if ((ll)g[0]*g[0]%p!=f[0]) while (1);\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        polyinv(g,sqrtg,i);\n        memcpy(sqrtf,f,limit<<1);\n        dft(sqrtf,0,limit);dft(sqrtg,0,limit);dft(g,0,limit);\n        for (j=0;j<limit;j++)\n        {\n            g[j]=(ll)sqrtg[j]*((ll)g[j]*g[j]%p+sqrtf[j])%p;\n            if (g[j]&1) g[j]=g[j]+p>>1; else g[j]>>=1;\n        }\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\n/*void polycdq(int l,int r,int *f,int *g)\n{\n    if (l==r) return;\n    int mid=l+r>>1;\n    polycdq(l,mid,f,g);\n    int i,limit,li,siz=r-l;\n    limit=1;li=-1;\n    while (limit<=siz)\n    {\n        limit<<=1;++li;\n    }\n    for (i=l;i<=mid;i++) cdqf[i-l]=f[i];\n    for (i=mid-l+1;i<lim;i++) cdqf[i]=0;\n    for (i=1;i<=r-l;i++) cdqg[i]=g[i];G[0]=0;\n    for (i=r-l+1;i<lim;i++) cdqg[i]=0;\n    polymultiply(cdqf,cdqg,li,limit);\n    for (i=mid+1;i<=r;i++)\n    {\n        f[i]+=cdqf[i-l];\n        if (f[i]>=p) f[i]-=p;\n    }\n    polycdq(mid+1,r,f,g);\n}*/\nvoid polydivide(int *f,int *g,int *q,int *r,int limit)\n{\n\n}\nvoid polyln(int *f,int *g,int biglim)\n{\n    int i,limit=biglim<<1;\n    memcpy(lnf,f,biglim<<2);\n    memset(lnf+biglim,0,biglim<<2);\n    polyinv(f,g,biglim);\n    dao(lnf,biglim);\n    dft(lnf,0,limit);dft(g,0,limit);\n    for (i=0;i<limit;i++) g[i]=(ll)g[i]*lnf[i]%p;\n    dft(g,biglim,limit);\n    memset(g+biglim,0,biglim<<2);\n    ji(g,biglim);\n}\nvoid polyexp(int *f,int *g,int biglim)\n{\n    memset(g,0,biglim<<3);\n    memset(expf,0,biglim<<3);\n    memset(expg,0,biglim<<3);\n    g[0]=1;\n    int i,j,l=1,limit;\n    for (i=2;i<=biglim;i=limit,l++)\n    {\n        limit=i<<1;\n        memcpy(expf,f,limit<<1);\n        polyln(g,expg,i);\n        dft(expf,0,limit);dft(g,0,limit);dft(expg,0,limit);\n        for (j=0;j<limit;j++) g[j]=(ll)g[j]*(1+expf[j]-expg[j]+p)%p;\n        dft(g,i,limit);\n        memset(g+i,0,limit<<1);\n    }\n}\nvoid polyksm1(int *f,int *g,int biglim,int cs)\n{\n    if (cs==0)\n    {\n        g[0]=1;\n        return;\n    }\n    int i,j,k=1,wy=0;\n    if (f[0]==0)\n    {\n        for (i=1;i<biglim;i++) if (f[i]) break;\n        for (j=0;j<biglim-i;j++) f[j]=f[j+i];\n        memset(f+biglim-i,0,i<<2);\n        if ((ll)i*cs>=biglim) return;\n        wy=i*cs;\n    }\n    if (f[0]>1)\n    {\n        k=ksm(f[0],p-2);\n        for (i=1;i<biglim;i++) f[i]=(ll)f[i]*k%p;\n        k=ksm(f[0],cs);f[0]=1;\n    }\n    polyln(f,ksmf,biglim);\n    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;\n    polyexp(ksmf,g,biglim);\n    if (k!=1)\n    {\n        for (i=0;i<biglim;i++) g[i]=(ll)g[i]*k%p;\n    }\n    if (wy)\n    {\n        for (i=biglim-1;i>=wy;i--) g[i]=g[i-wy];\n        memset(g,0,wy<<2);  \n    }\n}\nvoid polyksm2(int *f,int *g,int biglim,int cs)\n{\n    int limit=1,i,l=-1;\n    while (limit<=biglim)\n    {\n        limit<<=1;++l;\n    }\n    for (i=1;i<limit;i++) r[i]=r[i>>1]>>1|(i&1)<<l;g[0]=1;\n    while (cs)\n    {\n        if (cs&1)\n        {\n            memcpy(ksmf,f,biglim<<2);\n            memset(ksmf+biglim,0,biglim<<2);\n            polymultiply(g,ksmf,biglim);\n            memset(g+biglim,0,biglim<<2);\n        }\n        dft(f,0,limit);\n        for (i=0;i<limit;i++) f[i]=(ll)f[i]*f[i]%p;\n        dft(f,biglim,limit);\n        memset(f+biglim,0,biglim<<2);\n        cs>>=1;\n    }\n}\nvoid polyksm3(int *f,int *g,int biglim,int cs)\n{\n    int i;\n    memset(ksmf,0,biglim<<3);\n    memset(g,0,biglim<<3);\n    polyln(f,ksmf,biglim);\n    for (i=0;i<biglim;i++) ksmf[i]=(ll)ksmf[i]*cs%p;\n    polyexp(ksmf,g,biglim);\n}\nvoid polysin(int *f,int *g,int biglim)\n{\n    int i;\n    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;\n    polyexp(g,sinf,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;\n    polyexp(g,sing,biglim);\n    for (i=0;i<biglim;i++) g[i]=(ll)(sinf[i]-sing[i]+p)*II%p;\n    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;\n}\nvoid polycos(int *f,int *g,int biglim)\n{\n    int i;\n    for (i=0;i<biglim;i++) g[i]=(ll)f[i]*I%p;\n    polyexp(g,cosf,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=p-(ll)f[i]*I%p)==p) g[i]-=p;\n    polyexp(g,cosg,biglim);\n    for (i=0;i<biglim;i++) if ((g[i]=cosf[i]+cosg[i])>=p) g[i]-=p;\n    for (i=0;i<biglim;i++) if (g[i]&1) g[i]=g[i]+p>>1; else g[i]>>=1;\n}\nvoid polytan(int *f,int *g,int biglim)\n{\n    polysin(f,tanf,biglim);\n    polycos(f,tang,biglim);\n    polyinv(tang,g,biglim);\n    polymultiply(g,tanf,biglim);\n}\nvoid polycot(int *f,int *g,int biglim)\n{\n    polysin(f,cotf,biglim);\n    polycos(f,cotg,biglim);\n    polyinv(cotf,g,biglim);\n    polymultiply(g,cotg,biglim);\n}\nint main()\n{\n    read(n);\n    limit=1;\n    while (limit<n) limit<<=1;\n    for (i=0;i<n;i++) read(f[i]);gg(limit<<1);\n    polysqrt(f,g,limit);\n    for (i=0;i<n;i++) printf(\"%d \",g[i]);\n}\n```\n",
        "postTime": 1553914970,
        "uid": 29826,
        "name": "SSerxhs",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P5277 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "\u7ed9\u4e00\u4e2a\u65b9\u6cd5\uff0c\u5f00\u591a\u5c11\u6b21\u65b9\u90fd\u53ef\u4ee5\u3002\u5f53\u7136\u5bf9\u4e8e\u8fd9\u9053\u9898\u53ea\u8981\u5199\u4e00\u4e2a\u5f00\u65b9\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6839\u636e\u521d\u4e2d\u6570\u5b66\u53ea\u662f\u53ef\u4ee5\u77e5\u9053:\n\n$$\\sqrt[k] a=a^{\\frac{1}{k}}$$\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u9700\u8981\u6c42\u7684\u662f $\\frac{1}{k}$ \u6b21\u65b9\u6839\u3002\n\n\u800c\u5728\u819c\u610f\u4e49\u4e0b\uff0c\u8fd9\u4e2a\u6570\u5b57\u7b49\u4ef7\u4e8e $a^{k^{-1}}$ \u3002\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u5c31\u53ea\u9700\u8981\u6c42\u4e00\u4e2a $k^{-1}$ \u6b21\u65b9\u6839\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u5982\u679c\u7528\u5206\u6cbb\u4e58\u6cd5\u7684\u8bdd\uff0c $k$ \u53ef\u80fd\u4e0d\u4e0e $mod-1$ \u4e92\u8d28\uff0c $k^{-1}$ \u53ef\u80fd\u4e0d\u5b58\u5728\u3002\u4f46\u662f\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c $k$ \u4e0e $mod$ \u662f\u4e92\u8d28\u7684\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u8981\u5957\u7528 $\\ln$ \u548c $\\exp$ \u5b9e\u73b0\u7684\u5feb\u901f\u5e42\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6\u4e3a $O(n\\log n)$ \u3002\n\n\u8fd9\u91cc\u7ed9\u4e00\u4e2a\u6c42 $k$ \u6b21\u5269\u4f59\u7684\u65b9\u6cd5\u3002\n\n\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u5e73\u5e38\u7528\u7684\u819c\u6570\u90fd\u662f $998244353$ \u4e4b\u7c7b\u7684\u819c\u6570\uff0c\u56e0\u6b64\u539f\u6839\u4e00\u822c\u662f\u6709\u5b8c\u6574\u5b9a\u4e49\u7684\u3002\n\n\u90a3\u4e48\uff0c\u8bbe $a_0=3^t$ \uff0c\u6211\u4eec\u9700\u8981\u7684\u5176\u5b9e\u662f $3^{\\frac{t}{k}}$ \u3002\n\n\u5982\u679c $\\frac{t}{k}$ \u5728\u819c $mod-1$ \u610f\u4e49\u4e0b\u4e0d\u5b58\u5728\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6570\u5b57\u4e0d\u5b58\u5728 $k$ \u6b21\u5269\u4f59\u3002\n\n\u5426\u5219\u6211\u4eec\u76f4\u63a5\u7528 $exgcd$ \u7b97\u51fa\u7ed3\u679c\u5c31\u53ef\u4ee5\u4e86\u3002\u5229\u7528 $BSGS$ \u5b9e\u73b0\u6c42 $t$ \uff0c\u590d\u6742\u5ea6\u4e3a $O(\\sqrt{mod})$ \u3002\n\n\u6838\u5fc3\u4ee3\u7801:\n\n```cpp\nint dir=0,fst;\n\nmap<int,int>G;\n\nconst int iv2=(mod+1)/2;\n\ninline int gettwo(int x)//\u7528BSGS\u6c42\u4e8c\u6b21\u5269\u4f59\n{\n\tconst int blk=sqrt(mod);\n\tregister int z=1,t=1;\n\trep(i,0,blk)G[z]=i,z=z*3ll%mod;\n\tz=power(z,mod-2);\n\tfor(register int i=0;;++i)\n\t{\n\t\tif(G[(ll)x*t%mod])\n\t\t{\n\t\t\tint mz=i*blk+G[(ll)x*t%mod];\n\t\t\treturn power(3,mz/2);\n        }//\u53ea\u8981\u4e8c\u6b21\u65b9\u6839\uff0c\u4e0d\u9700\u8981exgcd\u3002\n\t\tt=(ll)t*z%mod;\n\t}\n\treturn x;\n}\n\nint main()\n{\n\tif(!F[0])\n\t{\n\t\tdir=-1;\n\t\tRep(i,1,n)if(F[i]){dir=i;break;}\n\t\tif(dir==-1){Rep(i,1,n)write(0,' ');flush();exit(0);}\n\t\tRep(i,dir,n)F[i-dir]=F[i],F[i]=0;\n\t}\n\tfst=F[0];\n\tregister int iv=power(fst,mod-2);\n\tRep(i,0,n)F[i]=(ll)F[i]*iv%mod;\n\tLn(F,F,n);\n\tRep(i,0,n)F[i]=(ll)F[i]*iv2%mod;//\u76f4\u63a5\u4e0a ln \u548c exp\n\tExp(F,F,n);\n\tfst=gettwo(fst);\n\tif(fst>(mod+1)/2)fst=mod-fst;\n\tRep(i,1,dir/2)write(0,' ');\n\tRep(i,0,n-dir/2)write((ll)fst*F[i]%mod,' ');\n\treturn 0;\n}\n\n```",
        "postTime": 1553927072,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5277 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "## ~~\u5e7f\u544a:[\u3010\u591a\u9879\u5f0f\u7684\u64cd\u4f5c\u5927\u8d4f\u3011](https://blog.csdn.net/weixin_43973966/article/details/87864851)~~\n\n\n$\\ \\ \\ \\ \\ \\ \\ $\u8fd9\u9053\u9898\u7684\u8bdd\uff0c\u5468\u9053\u6765\u63d0\u4f9b\u4e00\u79cd\u4e0d\u540c\u7684\u601d\u8def\u5427\uff0c\u7406\u8bba\u4e0a\u9762\u53ef\u4ee5\u89e3 **\u5f00\u4efb\u610f\u6b21\u65b9** \u7684\u591a\u9879\u5f0f\u95ee\u9898\u3002\n\n$\\ \\ \\ \\ \\ \\ \\ $\u5bf9\u4e8e\u6c42$B=\\sqrt[k]A$\uff0c\u663e\u7136\u6709\uff1a\n\n$$B=exp\\left(\\frac{ln(A)}{k}\\right)$$\n\n$\\ \\ \\ \\ \\ \\ \\ $\u5728\u6211\u8fd9\u7bc7\u9898\u89e3\u91cc\u9762\uff1a[\u9898\u89e3 P5273 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5e42\u51fd\u6570 (\u52a0\u5f3a\u7248)\u3011](https://www.luogu.org/blog/Althen-Way-Satan/solution-p5273)\uff0c\u6709\u63d0\u5230\u8fc7\uff0c\u5bf9\u4e8e\u6c42\u5e38\u6570\u9879\u4e0d\u662f $0$ \u7684\u591a\u9879\u5f0f\u7684 $exp$\uff0c\u6211\u4eec\u53ef\u4ee5\u5355\u72ec\u6c42\u51fa $exp$ \u7684\u5e38\u6570\u9879\uff0c\u95ee\u9898\u4fbf\u53ef\u4ee5\u8fce\u5203\u800c\u89e3\uff1a\n\n$\\ \\ \\ \\ \\ \\ \\ $\u90a3\u4e48\u5e38\u6570\u9879\u663e\u7136\u662f\uff1a\n\n$$\\sqrt[k]{A_0}\\ \\ \\ (\\%998244353)$$\n\n$\\ \\ \\ \\ \\ \\ \\ $\u73b0\u5728$k=2$ \u561b\uff0c\u5c31\u662f\u6c42$A_0$\u5728$(\\%998244353)$\u610f\u4e49\u4e0b\u7684\u4e8c\u6b21\u5269\u4f59\u5566\u3002\n\n$\\ \\ \\ \\ \\ \\ \\ $\u53ef\u662f\u5468\u9053\u592a\u83dc\u4e86\uff0c\u4e0d\u4f1a\u4e8c\u6b21\u5269\u4f59\u2026\u2026QAQ\n\n$\\ \\ \\ \\ \\ \\ \\ $\u6ca1\u5173\u7cfb\uff0c\u6211\u4eec\u53ef\u4ee5$BSGS$\u4e71\u641e\uff1a\n\n$\\ \\ \\ \\ \\ \\ \\ $\u5df2\u77e5$998244353$\u7684\u539f\u6839\u662f$3$\uff0c\u65e2\u6240\u6709\u7684\u6570\u5728$(\\%998244353)$\u610f\u4e49\u4e0b\u90fd\u53ef\u4ee5\u88ab $3^x$ \u8868\u8fbe\u3002\n\n$\\ \\ \\ \\ \\ \\ \\ $\u90a3\u4e48\u6211\u4eec\u4ee4\uff1a\n\n$$3^x\\equiv\\sqrt[k]{A_0}\\ \\ \\ (\\%998244353)$$\n\n$\\ \\ \\ \\ \\ \\ \\ $\u65e2\uff1a\n\n$$3^{xk}\\equiv A_0\\ \\ \\ (\\%998244353)$$\n\n$\\ \\ \\ \\ \\ \\ \\ $\u901a\u8fc7$BSGS$\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f88\u8f7b\u677e\u7b97\u51fa $xk$ \u7684\u53d6\u503c\u5566\uff0c\u4ee4$p=xk$\uff0c\u7136\u540e\u4ed6\u662f\u4fdd\u8bc1\u6709\u89e3\u7684\uff0c\u6240\u4ee5 $k$ \u4e00\u5b9a\u6574\u9664 $p$ \uff0c\u5c31\u53ef\u4ee5\u7b97\u51fa\u6765\uff1a\n\n$$\\sqrt[k]{A_0}\\equiv 3^{\\frac{p}{k}}\\ \\ \\ (\\%998244353)$$\n\n$\\ \\ \\ \\ \\ \\ \\ $\u4ee3\u7801\u662f\u8fd9\u6837\u5b50\u7684\uff0c\u7406\u8bba\u8fd8\u53ef\u4ee5\u5f00\u9ad8\u6b21\u6839\u7684\u8bf4 ~~\uff08\u5c31\u6ca1\u6709\u8bd5\u8fc7\u4e86\uff09~~ \uff1a\n\n```cpp\nint BSGS(int a,int b){\n  unordered_map<int,int>hash;hash.clear();b%=mod;\n  int t=(int)sqrt(mod)+1;\n  for(register int j=0;j<t;j++){\n    int val=(int)(1ll*b*power(a,j)%mod);\n    hash[val]=j;\n  }\n  a=power(a,t);\n  if(a==0){\n    if(b==0)return 1;\n    else return -1;\n  }\n  for(register int i=0;i<=t;++i){\n    int val=power(a,i);\n    int j=hash.find(val)==hash.end()?-1:hash[val];\n    if(j>=0&&i*t-j>=0)return i*t-j;\n  }\n  return -1;\n}\nint solve(int a,int K){\n  int p=BSGS(mod_g,a);\n  int ret=power(mod_g,p/K);\n  return ret;\n}\n```\n\n$\\ \\ \\ \\ \\ \\ \\ $\u7136\u540e\u5957\u677f\u5b50\u7136\u540e\u4e00\u4ea4\uff0c\u600e\u4e48\u8fde $WA$ \u5e26 $TLE$ ???\n\n$\\ \\ \\ \\ \\ \\ \\ $\u4e8e\u662f\u6211\u95ee\u4e86\u4e00\u4e0b\uff1a[\u591a\u7ec4\u89e3\uff1f](https://www.luogu.org/discuss/show/107417)\n\n$\\ \\ \\ \\ \\ \\ \\ $\u5c31\u53d8\u6210\u4e86\uff1a\n\n```cpp\nint solve(int a,int K){\n  int p=BSGS(mod_g,a);\n  int ret=power(mod_g,p/K);\n  return min(ret,mod-ret);\n}\n```\n\n$\\ \\ \\ \\ \\ \\ \\ $\u7136\u540e\u5bf9\u662f\u5bf9\u4e86\uff0c\u5c31\u662f\u5361\u4e86\u5f88\u4e45\u5e38\u6570\uff0c\u5176\u5b9e\u4e5f\u633a\u597d\u7684\uff0c\u4f18\u5316\u4e86\u81ea\u5df1\u7684\u6a21\u677f\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<queue>\n#include<unordered_map>\n#include<set>\n#include<stack>\n#include<cmath>\n#include<cctype>\nusing namespace std;\nconst int inf=0x7fffffff;\nconst double eps=1e-10;\nconst double pi=acos(-1.0);\n//char buf[1<<15],*S=buf,*T=buf;\n//char getch(){return S==T&&(T=(S=buf)+fread(buf,1,1<<15,stdin),S==T)?0:*S++;}\ninline int read(){\n  int x=0,f=1;char ch;ch=getchar();\n  while(ch<'0'||ch>'9'){if(ch=='-') f=0;ch=getchar();}\n  while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch&15);ch=getchar();}\n  if(f)return x;else return -x;\n}\nconst int N=13e5+10;\nconst int mod=998244353,mod_g=3;\nint K;\nint R[N];\nint power(int a,int b){\n  int ans=1;\n  for(;b;b>>=1,a=1ll*a*a%mod)if(b&1)ans=1ll*ans*a%mod;\n  return ans;\n}\n#define Inv(x) power(x,mod-2)\nint Polynomial_init(int n){\n  int len;for(len=1;len<n;len<<=1);\n  return len;\n}\nint g[22],inv[N];\nvoid Get_Inv(int n){\n  inv[1]=1;\n  for(int i=2;i<=n;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n}\ninline int add(int a,int b){return (a+=b)>=mod?a-mod:a;}\nvoid NTT(int a[],int f,int Len){\n  for(int i=1;i<Len;i++)if(i<R[i])swap(a[i],a[R[i]]);\n  static int i,j,k,kk,w,t,wn,r;\n  for(k=2,kk=1,r=1;k<=Len;k<<=1,kk<<=1,++r){\n    wn=g[r];\n    for(i=0;i<Len;i+=k)\n    for(j=0,w=1;j<kk;++j,w=1ll*w*wn%mod){\n      t=1ll*w*a[i+j+kk]%mod;\n      a[i+j+kk]=add(a[i+j],mod-t);\n      a[i+j]=add(a[i+j],t);\n    }\n  }\n  if(f==-1){\n    reverse(a+1,a+Len);\n    for(int i=0;i<Len;++i)a[i]=1ll*a[i]*inv[Len]%mod;\n  }\n}\nvoid Convolution(int *a,int *b,int la,int lb){\n  int n=la,m=lb;\n  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;\n  for(register int i=0;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));\n  NTT(a,1,n);NTT(b,1,n);\n  for(register int i=0;i<=n;++i)a[i]=1ll*a[i]*b[i]%mod;\n  NTT(a,-1,n);\n}\nint I[N],J[N];\nvoid Multiplication(int *a,int *b,int *c,int la,int lb){\n  int n=la,m=lb;\n  int L=0;for(m+=n,n=1;n<=m;n<<=1)L++;\n  for(register int i=0;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));\n  for(register int i=0;i<=la;++i) I[i]=a[i];\n  for(register int i=0;i<=lb;++i) J[i]=b[i];\n  NTT(I,1,n);NTT(J,1,n);\n  for(register int i=0;i<=n;++i)c[i]=1ll*I[i]*J[i]%mod,I[i]=J[i]=0;\n  NTT(c,-1,n);\n}\nint C[N];\nvoid Inverse(int *a,int *b,int len){\n  if(len==1){b[0]=Inv(a[0]);return;}\n  Inverse(a,b,(len+1)>>1);\n  int L=0,n=1;\n  for(;n<(len<<1);n<<=1)L++;\n  for(register int i=1;i<n;++i)R[i]=(R[i>>1]>>1)|((i&1)<<(L-1));\n  for(register int i=0;i<len;++i)C[i]=a[i];\n  for(register int i=len;i<n;++i)C[i]=0;\n  NTT(C,1,n);NTT(b,1,n);\n  for(register int i=0;i<=n;++i)b[i]=1ll*add(2ll,mod-1ll*C[i]*b[i]%mod)*b[i]%mod;\n  NTT(b,-1,n);\n  for(register int i=len;i<n;++i)b[i]=0;\n}\nint H[N];\nvoid Derivation(int *a,int *b,int n){\n  for(register int i=1;i<n;++i)\n  b[i-1]=1ll*i*a[i]%mod;\n  b[n-1]=0;\n}\nvoid Integral(int *a,int *b,int n){\n  for(register int i=1;i<n;++i)\n  b[i]=1ll*inv[i]*a[i-1]%mod;\n  b[0]=0;\n}\nint ln_a[N],ln_b[N];\nvoid Logarithmic(int *a,int *b,int n){\n  memset(ln_a,0,sizeof(ln_a));\n  memset(ln_b,0,sizeof(ln_b));\n  Derivation(a,ln_a,n);\n  memset(C,0,sizeof(C));\n  Inverse(a,ln_b,n);\n  Convolution(ln_a,ln_b,n,n);\n  Integral(ln_a,b,n);\n}\nint D[N];\nvoid Exponential(int *a,int *b,int len){\n  if(len==1){return;}\n  Exponential(a,b,len>>1),Logarithmic(b,D,len);\n  D[0]=add(a[0],mod+1ll-D[0]);\n  for(register int i=1;i<len;++i) D[i]=add(a[i],mod-D[i]);\n  Convolution(b,D,len,len);\n  for(register int i=len;i<(len<<1);++i) b[i]=D[i]=0;\n}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint BSGS(int a,int b){\n  unordered_map<int,int>hash;hash.clear();b%=mod;\n  int t=(int)sqrt(mod)+1;\n  for(register int j=0;j<t;j++){\n    int val=(int)(1ll*b*power(a,j)%mod);\n    hash[val]=j;\n  }\n  a=power(a,t);\n  if(a==0){\n    if(b==0)return 1;\n    else return -1;\n  }\n  for(register int i=0;i<=t;++i){\n    int val=power(a,i);\n    int j=hash.find(val)==hash.end()?-1:hash[val];\n    if(j>=0&&i*t-j>=0)return i*t-j;\n  }\n  return -1;\n}\nint solve(int a,int K){\n  int p=BSGS(mod_g,a);\n  int ret=power(mod_g,p/K);\n  return min(ret,mod-ret);\n}\nint s_a[N];\nvoid Kth_root(int *a,int *b,int len,int K){\n  Logarithmic(a,s_a,len);\n  int Kr=Inv(K);\n  for(register int i=1;i<=len;++i)s_a[i]=1ll*s_a[i]*Kr%mod;\n  b[0]=solve(a[0],K);\n  Exponential(s_a,b,len);\n}\nint n,F[N],G[N],low;\nint main()\n{\n  Get_Inv(N-10);\n  for(register int i=1,j=2;i<=19;++i,j<<=1)g[i]=power(mod_g,(mod-1)/j);\n  n=read();K=2;\n  for(register int i=0;i<n;++i)F[i]=read();\n  Kth_root(F,G,Polynomial_init(n),K);\n  for(register int i=0;i<n;++i)cout<<G[i]<<\" \";\n  return 0;\n}\n\n```",
        "postTime": 1553950981,
        "uid": 62758,
        "name": "\u5468\u9053_Althen",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P5277 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "[_\u4f20\u9001\u95e8_](https://www.luogu.com.cn/problem/P5277)\n\n\u677f\u5b50\u9898\u3002\n## \u9898\u610f\n\u7ed9\u5b9a $n-1$ \u6b21\u591a\u9879\u5f0f $F(x)$\uff0c\u6c42 $G^2(x)\\equiv F(x)(\\bmod x^n)$\u3002\n## \u601d\u8def\n\u6211\u4eec\u53d1\u73b0 $\\sqrt{k}=k^{\\frac 1 2}$\uff0c\u4e8e\u662f\u53ef\u4ee5\u66b4\u529b\u6c42 $G(x)\\equiv F^{\\frac 1 2}(x)\\equiv F^{499122177}(x)(\\bmod x^n)$.\n\n\u6ce8\u610f\u5230 $f_0\\ne1$\uff0c\u4e8e\u662f\u4e0d\u80fd\u76f4\u63a5 $\\ln$\uff0c\u8fd8\u5f97\u628a\u6bcf\u9879\u7cfb\u6570\u9664\u6389 $f_0$\uff0c\u518d\u53d6 $g_0\\equiv \\sqrt{f_0}(\\bmod 998244353)$\uff0c\u6a21\u610f\u4e49\u5f00\u6839\u89c1[\u4e8c\u6b21\u5269\u4f59](https://www.luogu.com.cn/problem/P5491)\u3002\n\n\u6700\u540e\u5982\u679c $f_0\\ne 1$\uff0c\u5219\u8fd8\u9700\u5c06\u6240\u6709\u6570\u4e58\u4e0a $\\sqrt{f_0}$\u3002\n\n\u7ed9\u51fa Code:\n```cpp\n#define ll long long\nconst int mod=998244353,N=6e5+10;\ninline void print(int *a){\n\tfor(int i=0;a[i]||a[i+1]||a[i+2]||a[i+3]||a[i+4]||a[i+5];i++){\n\t\tprintf(\"%d \",a[i]);\n\t}\n\tputs(\"\");\n}\nnamespace rad{\n\tmt19937_64 R(time(0));\n\tinline int Rand(ll l,ll r){\n\t\tuniform_int_distribution<ll> distribution(l,r);\n\t    return distribution(R);\n\t}\n}using namespace rad;\nnamespace quad_residue{\n\tll i_;\n\tstruct complex{\n\t\tll x,y;\n\t\tcomplex(ll X=0,ll Y=0){x=X,y=Y;}\n\t\tinline friend complex operator *(const complex &a,const complex &b){\n\t\t\treturn complex((a.x*b.x%mod+a.y*b.y%mod*i_%mod)%mod,(a.x*b.y%mod+a.y*b.x%mod)%mod);\n\t\t}\n\t};\n\tinline ll qpow(ll a,ll b){\n\t\ta%=mod;\n\t\tll res=1;\n\t\twhile(b){\n\t\t\tif(b&1) res=res*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline ll qpow(complex a,ll b){\n\t\tcomplex res(1,0);\n\t\twhile(b){\n\t\t\tif(b&1) res=res*a;\n\t\t\ta=a*a;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn res.x%mod;\n\t}\n\tinline ll solve(ll n){\n\t\tn%=mod;\n\t\tif(qpow(n,mod-1>>1)==mod-1) return -1;\n\t\tll ans;\n\t\twhile(true){\n\t\t\tans=Rand(0,mod-1);\n\t\t\ti_=(ans*ans%mod+mod-n)%mod;\n\t\t\tif(qpow(i_,mod-1>>1)==mod-1) break;\n\t\t}\n\t\tint x=qpow(complex(ans,1),mod+1>>1);\n\t\treturn min(x,mod-x);\n\t}\n}\n#define QR quad_residue\nstruct ntt{\n\tint n,a[N],b[N],c[N],qqqq[N],s[N],ss[N],d[N],e[N],rev[N],f[N],g[N],inv[N],lim;\n\tchar m[N];\n\tinline void init(int n,int mode=1){\n\t\tif(mode){\n\t\t\tint l=0;\n\t\t\tfor(lim=1;lim<=n;lim<<=1)l++;\n\t\t\tfor(int i=1;i<lim;i++){\n\t\t\t\trev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));\n\t\t\t}\n\t\t}else{\n\t\t\tfor(lim=1;lim<=n;lim<<=1);\n\t\t}\n\t}\n\tinline int qpow(int x,int y){\n\t\tint res=1;\n\t\twhile(y){\n\t\t\tif(y&1) res=1ll*res*x%mod;\n\t\t\tx=1ll*x*x%mod;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void Prefix(int n){\n\t\tinv[1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tinv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\t\t}\n\t}\n\tinline void NTT(int *a,bool t){\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tif(i<rev[i]){\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<lim;i<<=1){\n\t\t\tint gl=qpow(3,(mod-1)/(i<<1));\n\t\t\tfor(int j=0;j<lim;j+=(i<<1)){\n\t\t\t\tint t1,t2,now=1;\n\t\t\t\tfor(int k=0;k<i;k++,now=1ll*now*gl%mod){\n\t\t\t\t\tt1=a[j+k];\n\t\t\t\t\tt2=1ll*now*a[i+j+k]%mod;\n\t\t\t\t\ta[j+k]=(t1+t2)%mod;\n\t\t\t\t\ta[i+j+k]=(t1-t2+mod)%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!t) return ;\n\t\tint Inv=qpow(lim,mod-2);\n\t\treverse(a+1,a+lim);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\ta[i]=1ll*a[i]*Inv%mod;\n\t\t}\n\t}\n\tinline void Inv(int dg,int *a,int *b){\n\t\tif(dg==1){\n\t\t\tb[0]=qpow(a[0],mod-2);\n\t\t\treturn ;\n\t\t}\n\t\tInv(dg+1>>1,a,b);\n\t\tinit((dg<<1)-1);\n\t\tfor(int i=0;i<dg;i++){\n\t\t\tc[i]=a[i];\n\t\t}\n\t\tfor(int i=dg;i<lim;i++){\n\t\t\tc[i]=0;\n\t\t}\n\t\tNTT(c,0);\n\t\tNTT(b,0);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tb[i]=1ll*(2-1ll*c[i]*b[i]%mod+mod)%mod*b[i]%mod;\n\t\t}\n\t\tNTT(b,1);\n\t\tfor(int i=dg;i<lim;i++){\n\t\t\tb[i]=0;\n\t\t}\n\t}\n\tinline void Mul(int *a,int *b,int n){\n\t\tinit(n);\n\t\tmemset(c,0,lim<<2);\n\t\tmemcpy(c,b,n<<2);\n\t\tNTT(a,0);\n\t\tNTT(c,0);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\ta[i]=1ll*a[i]*c[i]%mod;\n\t\t}\n\t\tNTT(a,1);\n\t}\n\tinline void Der(int *a,int *b,int n){\n\t\tfor(int i=1;i<n;i++){\n\t\t\tb[i-1]=1ll*i*a[i]%mod;\n\t\t}\n\t\tb[n-1]=0;\n\t}\n\tinline void Invder(int *a,int *b,int n){\n\t\tfor(int i=1;i<n;i++){\n\t\t\tb[i]=1ll*a[i-1]*inv[i]%mod;\n\t\t}\n\t\tb[0]=0;\n\t}\n\tinline void polyln(int *a,int *b,int n){\n\t\tfor(int i=0;i<(n<<2);i++){\n\t\t\tqqqq[i]=d[i]=b[i]=0;\n\t\t}\n\t\tDer(a,qqqq,n);\n\t\tInv(n,a,d);\n\t\tMul(qqqq,d,n);\n\t\tInvder(qqqq,b,n);\n\t}\n\tinline void Log(int n,int *f,int *g){\n\t\tinit(n);\n\t\tpolyln(f,g,lim);\n\t\tfor(int i=n;i<lim;i++){\n\t\t\tg[i]=0;\n\t\t}\n\t}\n\tinline void polyexp(int n,int *a,int *b){\n\t\tif(n==1){\n\t\t\tb[0]=1;\n\t\t\treturn ;\n\t\t}\n\t\tExp(n+1>>1,a,b);\n\t\tinit(n<<1);\n\t\tLog(n,b,s);\n\t\tfor(int i=0;i<n;i++){\n\t\t\ts[i]=a[i]>=s[i]?a[i]-s[i]:a[i]+mod-s[i];\n\t\t}\n\t\tfor(int i=n;i<lim;i++){\n\t\t\tb[i]=s[i]=0;\n\t\t}\n\t\ts[0]++;\n\t\tNTT(s,0);\n\t\tNTT(b,0);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tb[i]=1ll*b[i]*s[i]%mod;\n\t\t}\n\t\tNTT(b,1);\n\t\tfor(int i=n;i<lim;i++){\n\t\t\tb[i]=0;\n\t\t}\n\t}\n\tinline void Exp(int n,int *a,int *b){\n\t\tpolyexp(n,a,b);\n\t}\n\tinline void polypow(int n,int m,int *a,int *b){\n\t\tint k1=1;\n\t\tif(a[0]!=1){\n\t\t\tk1=qpow(a[0],mod-2);\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\ta[i]=1ll*k1*a[i]%mod;\n\t\t\t}\n\t\t\tk1=QR::solve(a[0]);\n\t\t\ta[0]=1;\n\t\t}\n\t\tLog(n,a,ss);\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i]=1ll*ss[i]*m%mod;\n\t\t}\n\t\tExp(n,a,b);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tb[i]=1ll*b[i]*k1%mod;\n\t\t}\n\t}\n\tinline void Pow(int n,int m,int *f,int *g){\n\t\tinit(n<<1|1);\n\t\tpolypow(n,m,f,g);\n\t}\n\tinline void MAIN(){\n\t\tn=read();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tf[i]=read();\n\t\t}\n\t\tinit(n,0);\n\t\tPrefix(n);\n\t\tPow(n,499122177,f,g);\n\t\tfor(int i=0;i<n;i++){\n\t\t\twrite(g[i]);\n\t\t\tout[len++]=' ';\n\t\t}\n\t}\n}w;\n```\n",
        "postTime": 1614848242,
        "uid": 365127,
        "name": "cyffff",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5277\u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "\u56e0P5205\u9898\u89e3\u5df2\u5173\uff0c\u4e00\u5e76\u63d0\u4ea4\u4e8eP5277\u3002\u4e8b\u5b9e\u4e0a\u662f\u4e24\u9898\u7684\u9898\u89e3\u3002\n\n### P5205\n\n\u8003\u8651\u591a\u9879\u5f0fexp\u7684\u505a\u6cd5\uff0c\u725b\u987f\u8fed\u4ee3\u3002\n\n\u5219\u6613\u6709\n\n$$F(G(x))=G^2(x)-A(x)\\equiv 0\\pmod{x^n}$$\n\n\u5df2\u77e5\n\n$$F(G_0(x))\\equiv 0\\pmod{x^{\\lceil \\frac n2\\rceil}}$$\n\n\u6709\n\n$$\\begin{aligned}\nG(x)&\\equiv G_0(x)-\\frac{F(G(x))}{F'(G_0(x))} \\\\\n&\\equiv G_0(x)-\\frac{G_0^2(x)-A(x)}{2G_0(x)} \\\\\n&\\equiv G_0(x)-\\frac 12G_0(x)+\\frac{A(x)}{2G_0(x)} \\\\\n&\\equiv \\frac 12(G_0(x)+\\frac{A(x)}{G_0(x)})\\pmod{x^n}\n\\end{aligned}$$\n\n\u9012\u5f52\u4e2d\u6c42\u4e00\u4e2a\u9006\u5c31\u884c\u4e86\u3002\n\n\u8fb9\u754c\u81ea\u7136\uff0c\u5bf9\u4e8e $a_0 = 1$\uff0c$b_0=\\sqrt 1=1$\u3002\n\n\u8fd9\u5c31\u662fP5205\u7684\u505a\u6cd5\u3002\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n\ntypedef long long ll;\nconst int p = 998244353;\nconst int inv2 = 499122177;\nconst int MAXN = 4000001;\n\ninline ll read() {\n    ll x = 0,f = 1; char ch = getchar();\n    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }\n    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');\n    return (x * f % p + p) % p;\n}\n\nint n,r[MAXN];\nll a[MAXN],b[MAXN],a1[MAXN],b1[MAXN];\n\nll fastpow(ll a,int b) {\n    ll res = 1; a %= p;\n    while(b) {\n        if(b & 1) res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid NTT(ll *a,int N) {\n    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);\n    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {\n        ll g1 = fastpow(3,(p - 1) / n);\n        for(int l = 0;l < N;l += n) {\n            ll g = 1,t1,t2;\n            for(int i = l;i < l + m;i++) {\n                t1 = a[i], t2 = g * a[i + m] % p;\n                a[i] = (t1 + t2) % p;\n                a[i + m] = (t1 - t2 + p) % p;\n                g = g * g1 % p;\n            }\n        }\n    }\n    return;\n}\n\nvoid INTT(ll *a,int N) {\n    NTT(a,N);\n    std::reverse(a + 1,a + N);\n    int invN = fastpow(N,p - 2);\n    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;\n}\n\nvoid Inv(ll *a,ll *b,int n) {\n    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));\n    Inv(a,b,(n + 1) >> 1);\n    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;\n    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);\n    for(int i = 0;i < n;i++) a1[i] = a[i];\n    for(int i = n;i < N;i++) a1[i] = 0;\n    NTT(a1,N); NTT(b,N);\n    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;\n    INTT(b,N);\n    for(int i = n;i < N;i++) b[i] = 0;\n    return;\n}\n\nvoid Sqrt(ll *a,ll *b,int n) {\n    if(n == 1) return void(b[0] = 1);\n    Sqrt(a,b,(n + 1) >> 1);\n    memset(b1,0,sizeof(b1));\n    Inv(b,b1,n);\n    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;\n    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);\n    for(int i = 0;i < n;i++) a1[i] = a[i];\n    for(int i = n;i < N;i++) a1[i] = 0;\n    NTT(a1,N); NTT(b,N); NTT(b1,N);\n    for(int i = 0;i < N;i++) b[i] = (b[i] + a1[i] * b1[i] % p) % p * inv2 % p;\n    INTT(b,N);\n    for(int i = n;i < N;i++) b[i] = 0;\n    return;\n}\n\nint main() {\n    n = read();\n    for(int i = 0;i < n;i++) a[i] = read();\n    Sqrt(a,b,n);\n    for(int i = 0;i < n;i++) std::printf(\"%lld \",b[i]);\n    return 0;\n}\n```\n\n\u90a3\u5bf9\u4e8eP5277\u5462\uff1f\u6b64\u9898\u4e0d\u4fdd\u8bc1 $a_0=1$\u3002\n\n### P5277\n\n\u8fd9\u9898\u5b9e\u9645\u4e0a\u5c31\u662f\u5e26\u4e0a\u4e86\u7ed9\u5e38\u6570\u5f00\u6839\u7684P5205\u4e86\u3002\u3002\n\n\u8fd9\u91cc\u4ec5\u5bf9Cipolla\u7b97\u6cd5\u4f5c\u4e00\u70b9\u6700\u57fa\u672c\u7684\u8bf4\u660e\u3002\n\n\u6a21\u610f\u4e49\u4e0b\u5f00\u6839\uff0c\u5373\u5bf9\u4e8e $a$ \u53ca\u6a21\u6570 $p$\uff0c\u6c42 $x$\uff0c\n\n$$x^2\\equiv a\\pmod p$$\n\n\u82e5\u65b9\u7a0b\u6709\u89e3\uff0c\u5219 $a$ \u4e3a\u6a21 $p$ \u4e0b\u7684\u4e8c\u6b21\u5269\u4f59\uff0c\u5426\u5219\u79f0\u4e3a\u4e8c\u6b21\u975e\u5269\u4f59\u3002\u5219\u672c\u9898\u4fdd\u8bc1\u6709\u89e3\u3002\n\n\u4e0b\u6587\u8ba8\u8bba\u4e2d $p$ \u4e3a\u5947\u6570\u7d20\u6570\uff0c\u5426\u5219 $\\frac{p-1}2$ \u4e0d\u4f1a\u662f\u6574\u6570\u3002\n\n#### \u4e2a\u6570\u7ed3\u8bba\n\n\u9996\u5148\uff0c$[1,p)$ \u4e2d\uff0c\u6a21 $p$ \u4e0b\u7684\u4e8c\u6b21\u975e\u5269\u4f59\u6709 $\\frac{p-1}2$ \u4e2a\u3002\n\n\u8bc1\u660e\uff1a\u8003\u8651\u4e24\u4e2a\u6570 $x,y\\in[1,p)$, $x^2\\equiv y^2\\pmod p$\uff0c\u5176\u4ee3\u8868\u540c\u4e00\u4e2a\u4e8c\u6b21\u5269\u4f59\u3002\n\n\u6709 $p|(x^2-y^2)$,\u5373 $p|(x-y)(x+y)$\u3002\n\n\u7531\u4e8e $p\\not|(x-y)$\uff0c\u5219 $p|(x+y)$\uff0c$x\\equiv p-y\\pmod p$\uff0c\u5373 $x=p-y$\u3002\n\n\u53cd\u4e4b\u4e5f\u5bb9\u6613\u5c55\u5f00\u5f97\u5230 $x^2\\equiv (p-x)^2\\pmod p$\u3002\n\n\u5219\u6709\u5f53\u4e14\u4ec5\u5f53 $x=p-y$ \u65f6\u5176\u6a21 $p$ \u4e0b\u7684\u5e73\u65b9\u76f8\u7b49\uff1b\u5176\u4e2d\u4fbf\u6709 $\\frac{p-1}2$ \u4e2a\u4e8c\u6b21\u5269\u4f59\u3002\n\n\u5bf9\u4e8e $[1,p)$ \u4ee5\u5916\u7684 $x,y$\uff0c\u6709 $x^2\\equiv (x\\mod p)^2$\uff0c\u4e0d\u4f5c\u8003\u8651\u4e86\u3002\n\n#### \u52d2\u8ba9\u5fb7\u7b26\u53f7\u4e0e\u6b27\u62c9\u5224\u522b\n\n\u5b9a\u4e49\u52d2\u8ba9\u5fb7\u7b26\u53f7\n\n$$\\binom{\\underline n}{p}$$\n\n\uff08latex\u5199\u5f97\u4e0d\u5bf9\u4e0d\u8981\u5728\u610f\uff09\n\n\u6709\u5982\u4e0b\u53d6\u503c\uff1a\n\n$1$,\u6b64\u65f6 $n$ \u662f\u6a21 $p$ \u4e0b\u7684\u4e8c\u6b21\u5269\u4f59\uff1b\n\n$-1$,\u6b64\u65f6 $n$ \u662f\u6a21 $p$ \u4e0b\u7684\u4e8c\u6b21\u975e\u5269\u4f59\uff1b\n\n$0$\uff0c\u6b64\u65f6 $p|n$\u3002\n\n\u6211\u4eec\u6709\u6b27\u62c9\u5224\u522b\u5f0f\uff1a\n\n$$\\binom{\\underline n}p\\equiv n^{\\frac{p-1}2}\\pmod p$$\n\n\u8bc1\u660e\u53ef\u4ee5\u7b80\u5355\u5730\u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\u3002\n\n\u53d6 $1$ \u65f6\uff0c\u53d6\u65b9\u7a0b $x^2\\equiv n\\pmod p$ \u7684\u4e00\u4e2a\u89e3 $x$\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c$x^{p-1}\\equiv 1\\pmod p$\uff0c\u6362 $n$ \u4ee3\u5165\u5219\u6709\n\n$$x^{p-1}\\equiv{(x^2)^{\\frac{p-1}2}}\\equiv n^{\\frac{p-1}2}\\equiv 1\\pmod p$$\n\n\u53d6 $-1$ \u65f6\uff0c\u4e0a\u8ff0\u65b9\u7a0b\u65e0\u89e3\u3002\u8003\u8651 $a\\in[1,p)$ \u53ca\u65b9\u7a0b\n\n$$ax\\equiv n\\pmod p$$\n\n$$ax+py=n$$\n\n\u65b9\u7a0b\u6709\u89e3\uff0c\u4e14\u5bf9\u4e8e\u4e00\u4e2a\u89e3 $x_0$\uff0c\u6709\u901a\u89e3\n\n$$x=x_0+k\\frac p{\\gcd(p,a)}=x_0+kp$$\n\n\u5219\u5728 $[1,p)$ \u8303\u56f4\u5185\u89e3\u552f\u4e00\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a $a\\in[1,p)$ \u6709\u552f\u4e00\u7684 $x\\in[1,p)$ \u4f7f\u5176\u76f8\u4e58\u4e3a $n\\pmod p$\u3002\u4e8e\u662f $(p-1)!\\equiv n^{\\frac{p-1}2}\\equiv -1\\pmod p$\u3002\n\n\u90a3\u4e3a\u4f55 $n$ \u4e0d\u80fd\u4e3a $p$ \u7684\u4e8c\u6b21\u5269\u4f59\u5462\uff1f\u56e0\u4e3a\u6b64\u65f6\u5bf9\u4e8e $x^2\\equiv n\\pmod p$ \u7684\u89e3\u5176\u5bf9\u5e94\u7684\u56e0\u5b50\u662f\u672c\u8eab\uff0c\u53d6\u4e0d\u5230 $(p-1)!$ \u4e86\u3002\n\n\u7531 $n^{\\frac{p-1}2}\\equiv -1\\pmod p$ \u63a8\u51fa $n$ \u4e3a\u4e8c\u6b21\u975e\u5269\u4f59\u7684\u8fc7\u7a0b\u4e0e\u4e0a\u8ff0\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u7565\u3002\n\n\u53d6 $0$ \u65f6\u663e\u7136\u3002\n\n#### \u7b97\u6cd5\u6d41\u7a0b\n\n\u9996\u5148\uff0c\u5982\u679c $n$ \u662f\u4e8c\u6b21\u975e\u5269\u4f59\uff0c\u8fd4\u56de\u65e0\u89e3\uff0c\u5f53\u7136\u8fd9\u9898\u4e0d\u9700\u8981\u3002\n\n\u6839\u636e\u4e0a\u8ff0\u7684\u4e2a\u6570\u7ed3\u8bba\uff0c\u6211\u4eec\u53ef\u4ee5\u968f\u673a\u4e00\u4e2a $a$\uff0c\u4f7f $a^2-n$ \u4e3a\u975e\u5269\u4f59\uff0c\u7528\u6b27\u62c9\u5f0f $O(\\log p)$ \u5feb\u901f\u5e42\u5224\u522b\u3002\u8fd9\u4e2a\u6b65\u9aa4\u671f\u671b\u53ea\u8981\u4e24\u6b21\u3002\n\n\u5f97\u5230\u4e00\u4e2a $a$ \u540e\uff0c\u6c42\u51fa $w=\\sqrt{a^2-n}$\u3002\u8fd9\u91cc\u5176\u5b9e\u662f\u6c42\u4e0d\u51fa\u6765\u7684\uff0c\u4e5f\u4e0d\u9700\u8981\u8868\u793a\u6210\u6574\u6570\uff1b\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u501f\u590d\u6570\u8fdb\u884c\u8fd0\u7b97\uff0c\u5c06\u5176\u4f5c\u4e3a\u590d\u6570\u5355\u4f4d $i$\u3002\n\n\u4f7f\u5176\u975e\u5269\u4f59\u7684\u610f\u4e49\u5728\u8fd9\uff1a$w^p\\equiv -w\\pmod p$\uff0c\u8bc1\u660e\uff1a\n\n$$w^p\\equiv ww^{p-1}\\equiv w(a^2-n)^{\\frac{p-1}2}\\equiv-w\\pmod p$$\n\n\u6709\u7ed3\u8bba $x$ \u5373\u4e3a $(a+w)^{\\frac{p+1}2}$\u3002\n\n\u8bc1\u660e\uff1a\n\n$$\\begin{aligned}\nx^2&\\equiv (a+w)^{p+1} \\\\\n&\\equiv (a+w)(a+w)^p\n\\end{aligned}$$\n\n\u8fd9\u91cc\u6709\u4e00\u4e2a\u5c0f\u7ed3\u8bba\uff1a $a^p+b^p\\equiv(a+b)^p\\pmod p$\n\n\u53f3\u8fb9\u5c55\u5f00\u5f97\n\n$$\\sum_{i=0}^p\\binom pia^ib^{p-i}$$\n\n\u7ec4\u5408\u6570\u76f4\u63a5\u5c55\u5f00\u53d1\u73b0 $i\\not=0$ \u4e14 $i\\not=p$ \u65f6 $\\binom pi\\equiv0\\pmod p$\u3002\n\n$$\\begin{aligned}\nx^2&\\equiv (a+w)(a^p+w^p) \\\\\n&\\equiv(a+w)(aa^{p-1}+(-w)) \\\\\n&\\equiv(a+w)(a-w) \\\\\n&\\equiv a^2-w^2\\equiv a^2-a^2+n\\equiv n\\pmod p\n\\end{aligned}$$\n\n\u4e8e\u662f\u5c31\u8fd9\u6837\u4e86\u3002\n\n\u5b9e\u73b0\u4e0a\u4eff\u9020\u590d\u6570\uff0c\u53ea\u9700\u5b9a\u4e49\u590d\u6570\u7684\u4e58\u6cd5\uff0c\u5e76\u4f5c\u5feb\u901f\u5e42\u3002\u6839\u636e\u7ed3\u8bba\uff0c\u6700\u540e\u8fd0\u7b97\u7ed3\u679c\u4e2d\u53ea\u6709 \u201c\u5b9e\u90e8\u201d\uff0c\u8fd4\u56de\u5176\u4f5c\u4e3a\u7b54\u6848\u5373\u53ef\u3002\n\n\u8fd8\u6709\u4e00\u70b9\uff1a\u6839\u636e $y^2\\equiv(p-y)^2\\pmod p$\uff0c\u5bf9\u7b54\u6848 $y$ \u4e5f\u6709\u7b54\u6848 $p-y$\u3002\u4e24\u8005\u53d6 $\\min$\u3002~~\u8fd9\u70b9\u672c\u9898\u597d\u50cf\u6ca1\u8bf4\u6e05\u695a\u554a\uff0c\u4f46\u662f\u6837\u4f8b\u4e2d\u53ef\u4ee5\u53d1\u73b0\u7684\u3002~~\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n\ntypedef long long ll;\nconst int p = 998244353;\nconst int inv2 = 499122177;\nconst int MAXN = 4000001;\n\nll read() {\n    ll x = 0,f = 1; char ch = getchar();\n    while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }\n    do x = (x * 10 + ch - 48) % p, ch = getchar(); while(ch >= '0' && ch <= '9');\n    return (x * f % p + p) % p;\n}\n\nint n,r[MAXN];\nll a[MAXN],b[MAXN],a1[MAXN],b1[MAXN];\n\nll fastpow(ll a,int b) {\n    ll res = 1; a %= p;\n    while(b) {\n        if(b & 1) res = res * a % p;\n        a = a * a % p;\n        b >>= 1;\n    }\n    return res;\n}\n\nvoid NTT(ll *a,int N) {\n    for(int i = 0;i < N;i++) if(i < r[i]) std::swap(a[i],a[r[i]]);\n    for(int n = 2,m = 1;n <= N;m = n, n <<= 1) {\n        ll g1 = fastpow(3,(p - 1) / n);\n        for(int l = 0;l < N;l += n) {\n            ll g = 1,t1,t2;\n            for(int i = l;i < l + m;i++) {\n                t1 = a[i], t2 = g * a[i + m] % p;\n                a[i] = (t1 + t2) % p;\n                a[i + m] = (t1 - t2 + p) % p;\n                g = g * g1 % p;\n            }\n        }\n    }\n    return;\n}\n\nvoid INTT(ll *a,int N) {\n    NTT(a,N);\n    std::reverse(a + 1,a + N);\n    int invN = fastpow(N,p - 2);\n    for(int i = 0;i < N;i++) a[i] = a[i] * invN % p;\n}\n\nll w;\n\nstruct Complex\n{\n    ll x, y;\n    Complex(ll _x = 0, ll _y = 0) : x(_x), y(_y) {}\n    friend Complex operator *(const Complex a,const Complex b) {\n        return Complex((a.x * b.x % p + w * a.y % p * b.y % p) % p,(a.x * b.y % p + a.y * b.x % p) % p);\n    }\n};\n\nll fastpow(Complex a,ll b) {\n    Complex ans(1,0);\n    while(b) {\n        if(b & 1) ans = ans * a;\n        a = a * a;\n        b >>= 1;\n    }\n    return ans.x;\n}\n\nll Cipolla(ll x) {\n    srand(time(0));\n    if (fastpow(x,(p - 1) >> 1) == p - 1) return -1;\n    while(true) {\n        ll a = (1ll * rand() << 15 | rand()) % p;\n        w = (a * a % p + p - x) % p;\n        if(fastpow(w,(p - 1) >> 1) == p - 1) {\n            ll res = fastpow(Complex(a,1),(p + 1) >> 1);\n            return std::min(res,p - res);\n        }\n    }\n}\n\nvoid Inv(ll *a,ll *b,int n) {\n    if(n == 1) return void(b[0] = fastpow(a[0],p - 2));\n    Inv(a,b,(n + 1) >> 1);\n    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;\n    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);\n    for(int i = 0;i < n;i++) a1[i] = a[i];\n    for(int i = n;i < N;i++) a1[i] = 0;\n    NTT(a1,N); NTT(b,N);\n    for(int i = 0;i < N;i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;\n    INTT(b,N);\n    for(int i = n;i < N;i++) b[i] = 0;\n    return;\n}\n\nvoid Sqrt(ll *a,ll *b,int n) {\n    if(n == 1) return void(b[0] = Cipolla(a[0]));\n    Sqrt(a,b,(n + 1) >> 1);\n    memset(b1,0,sizeof(b1));\n    Inv(b,b1,n);\n    int N = 1, l = -1; while(N <= n << 1) N <<= 1, l++;\n    for(int i = 1;i < N;i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);\n    for(int i = 0;i < n;i++) a1[i] = a[i];\n    for(int i = n;i < N;i++) a1[i] = 0;\n    NTT(a1,N); NTT(b,N); NTT(b1,N);\n    for(int i = 0;i < N;i++) b[i] = (b[i] + a1[i] * b1[i] % p) % p * inv2 % p;\n    INTT(b,N);\n    for(int i = n;i < N;i++) b[i] = 0;\n    return;\n}\n\nint main() {\n    n = read();\n    for(int i = 0;i < n;i++) a[i] = read();\n    Sqrt(a,b,n);\n    for(int i = 0;i < n;i++) std::printf(\"%lld \",b[i]);\n    return 0;\n}\n\n```\n\n\u6700\u540e\u3002\u968f\u673a\u6570\u5982\u679c `rand()` \u76f8\u4e58~~\u4e14\u8138\u9ed1~~\u4f1aT\u4e00\u4e24\u4e2a\u70b9\uff0c\u56e0\u4e3a\u4e00\u4e9b\u539f\u56e0\u5b83\u7684\u968f\u673a\u6027\u5f88\u5dee\u3002",
        "postTime": 1594093942,
        "uid": 219595,
        "name": "Vocalise",
        "ccfLevel": 9,
        "title": "\u591a\u9879\u5f0f\u5f00\u6839--\u9898\u89e3P5205/P5277[\u52a0\u5f3a\u7248]"
    },
    {
        "content": "**Update**\n\n\u4e24\u5904\u516c\u5f0f\u6302\u4e86\u6362\u6210\u4e86\u56fe\u7247\u3002\n\n---\n## \u524d\u7f6e\u77e5\u8bc6\n\n- \u591a\u9879\u5f0f\u5f00\u6839\n- Cipolla\u7b97\u6cd5\n\n### \u591a\u9879\u5f0f\u5f00\u6839\n\n\u6a21\u677f\u5728[P5205 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839](https://www.luogu.org/problemnew/show/P5277) \u3002\n\n\u8fd9\u91cc\u4e0d\u591a\u505a\u8ba8\u8bba\u3002\n\n### Cipolla\u7b97\u6cd5\n\n\u6c42\u89e3$x^2\\equiv n \\pmod p$\u7684\u7b97\u6cd5\uff0c\u7531\u4e8e`ntt`\u7684\u6a21\u662f\u5947\u7d20\u6570\u6240\u4ee5\u8fd9\u91cc\u53ea\u8ba8\u8bba$p$\u4e3a\u5947\u7d20\u6570\u7684\u60c5\u51b5\u3002\n\n\u5f53\u65b9\u7a0b\u6709\u89e3\u65f6\u79f0$n$\u5728\u6a21$p$\u610f\u4e49\u4e0b\u662f\u4e8c\u6b21\u5269\u4f59\uff0c\u5426\u5219\u79f0$n$\u5728\u6a21$p$\u610f\u4e49\u4e0b\u662f\u975e\u4e8c\u6b21\u5269\u4f59\u3002\n\n\u6211\u4eec\u5b9a\u4e49**\u52d2\u8ba9\u5fb7\u7b26\u53f7**\uff1a\n\n![\u52d2\u8ba9\u5fb7\u7b26\u53f7](https://i.loli.net/2019/03/30/5c9f2e12389c9.png)\n\n\u6709\u4e00\u4e2a**\u6b27\u62c9\u5224\u522b\u51c6\u5219**\uff1a\n\n$$\n(\\frac{n}{p})\\equiv n^{\\frac{p-1}{2}}\\pmod p\n$$\n\n~~\u53e3\u80e1~~\u8bc1\u660e\uff1a\n\n1. \u5f53$p|n$\u65f6\uff0c\u663e\u7136\u6709$0\\equiv n^{\\frac{p-1}{2}}\\pmod p$\n2. \u5047\u8bbe$x^2\\equiv n \\pmod p$\uff0c\u82e5$x^{p-1}\\equiv 1\\pmod p$\u65f6\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c\u5047\u8bbe\u6210\u7acb\uff0c$n$\u5728\u6a21$p$\u610f\u4e49\u4e0b\u662f\u4e8c\u6b21\u5269\u4f59\u3002\n\u82e5$x^{p-1}\\equiv -1\\pmod p$\u65f6\uff0c\u6839\u636e\u8d39\u9a6c\u5c0f\u5b9a\u7406\uff0c\u5047\u8bbe\u4e0d\u6210\u7acb\uff0c$n$\u5728\u6a21$p$\u610f\u4e49\u4e0b\u662f\u4e8c\u6b21\u975e\u5269\u4f59\u3002\n\n\u63a5\u4e0b\u6765\u8ba9\u6211\u4eec\u8bc1\u660e\u4e09\u4e2a\u7ed3\u8bba\u3002\n\n**\u7ed3\u8bba\u4e00\uff1a$n^2 \\equiv (p-n)^2 \\pmod p$**\n\n\u8bc1\u660e\u5c55\u5f00\u5f0f\u5b50\u4e2d\u7684$(p-n)^2$\u5373\u53ef\u3002\n\n**\u7ed3\u8bba\u4e8c\uff1a\u6709$\\frac{p-1}{2}$\u4e2a\u6570\u662f\u6a21$p$\u610f\u4e49\u4e0b\u7684\u4e8c\u6b21\u975e\u5269\u4f59\u3002**\n\n\u6839\u636e\u7ed3\u8bba\u4e00\uff0c\u53ef\u4ee5\u5f97\u51fa$0$\u5230$p-1$\u7684\u5e73\u65b9\u4e2d\u6709$\\frac{p+1}{2}$\u4e2a\u4e0d\u540c\u7684\u6570\uff0c\u5269\u4e0b\u7684\u6570\u5373\u4e3a\u6a21$p$\u610f\u4e49\u4e0b\u7684\u4e8c\u6b21\u975e\u5269\u4f59\u3002\n\n**\u7ed3\u8bba\u4e09\uff1a$(a+b)^p\\equiv a^p+b^p \\pmod p$**\n\n\u4e8c\u9879\u5f0f\u5b9a\u7406\u5c55\u5f00\uff0c\u7531\u4e8e$p$\u662f\u7d20\u6570\uff0c\u6240\u4ee5\u9664\u4e86\u9996\u5c3e\u4e24\u9879\u5176\u4ed6\u9879\u4e2d\u7684\u7ec4\u5408\u6570\u4e2d\u90fd\u6709\u8d28\u56e0\u5b50$p$\uff0c\u6545\u540c\u4f59\u5f0f\u6210\u7acb\u3002\n\n#### Cipolla\u7b97\u6cd5\u6d41\u7a0b\n\n\u7b2c\u4e00\u6b65\uff0c\u5224\u65ad\u539f\u65b9\u7a0b\u662f\u5426\u6709\u89e3\uff08\u5229\u7528\u6b27\u62c9\u5224\u522b\u51c6\u5219\uff09\u3002\n\n\u7b2c\u4e8c\u6b65\uff0c\u968f\u673a\u627e\u5230\u4e00\u4e2a$a$\u4f7f\u5f97$\\omega\\equiv(a^2-n)\\pmod p$\u5728\u6a21$p$\u610f\u4e49\u4e0b\u662f\u4e8c\u6b21\u975e\u5269\u4f59\u3002(\u6839\u636e\u7ed3\u8bba\u4e8c\uff0c\u671f\u671b\u968f\u673a\u6b21\u6570\u4e3a$2$)\n\n\u7b2c\u4e09\u6b65\uff0c\u627e\u5230\u4e00\u4e2a\u89e3$x\\equiv(a+\\sqrt{\\omega})^{\\frac{p+1}{2}} \\pmod p$\u3002\u4f46\u662f$\\sqrt{\\omega}$\u663e\u7136\u4e0d\u5b58\u5728\uff0c\u6211\u4eec\u53ef\u4ee5\u628a$\\sqrt{\\omega}$\u5f53\u505a\u865a\u6570$i$\u6765\u770b\uff0c\u5c31\u628a\u95ee\u9898\u89e3\u51b3\u4e86\u3002\n\n\u8bc1\u660e\uff1a\n\n![Cipolla\u8bc1\u660e](https://i.loli.net/2019/03/30/5c9f2e1259b12.png)\n\n## Code\n\n``` cpp\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <algorithm>\nconst int maxn = 400010;\nconst int mod = 998244353;\nconst int g = 3;\nconst int invg = 332748118;\nconst int inv2 = 499122177;\n\nint inline pls(int a, int b) { int m = a + b; return m < mod ? m : m - mod; }\nint inline dec(int a, int b) { int m = a - b; return m + ((m >> 31) & mod); }\nint inline mul(int a, int b) { return 1ll * a * b % mod; }\nint inline pow(int a, int b) {\n  int ans = 1;\n  while (b) {\n    if (b & 1) ans = mul(ans, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return ans;\n}\n\nstruct cp {\n  int r, i;\n  cp(int x = 0, int y = 0) : r(x), i(y) {}\n};\n\ncp inline mul(cp a, cp b, int w) {\n  return cp(pls(mul(a.r, b.r), mul(w, mul(a.i, b.i))), pls(mul(a.r, b.i), mul(a.i, b.r)));\n}\n\nint inline pow(cp a, int b, int w) {\n  cp ans(1, 0);\n  while (b) {\n    if (b & 1) ans = mul(ans, a, w);\n    a = mul(a, a, w);\n    b >>= 1;\n  }\n  return ans.r;\n}\n\nint inline cipolla(int x) {\n  srand(time(0));\n  if (pow(x, (mod - 1) >> 1) == mod - 1) return -1;\n  while (true) {\n    int a = mul(rand(), rand());\n    int w = dec(mul(a, a), x);\n    if (pow(w, (mod - 1) >> 1) == mod - 1) {\n      return pow(cp(a, 1), (mod + 1) >> 1, w);\n    }\n  }\n}\n\nint a[maxn], b[maxn], r[maxn];\n\nvoid inline ntt(int *a, int n, int f) {\n  for (int i = 0; i < n; ++i) if (i < r[i]) std::swap(a[i], a[r[i]]);\n  for (int i = 1; i < n; i <<= 1) {\n    int wn = pow(f ? g : invg, (mod - 1) / (i << 1));\n    for (int *j = a; j < a + n; j += i << 1) {\n      int w = 1;\n      for (int k = 0; k < i; ++k, w = mul(w, wn)) {\n        int x = *(j + k), y = mul(w, *(i + j + k));\n        *(j + k) = pls(x, y), *(i + j + k) = dec(x, y);\n      }\n    }\n  }\n  if (!f) {\n    int rv = pow(n, mod - 2);\n    for (int *i = a; i < a + n; ++i) *i = mul(*i, rv);\n  }\n}\n\nvoid inline inv(int *a, int *b, int n) {\n  b[0] = pow(a[0], mod - 2);\n  static int A[maxn], B[maxn], len, lim;\n  for (len = 1; len < n << 1; len <<= 1) {\n    lim = len << 1;\n    memcpy(A, a, len << 2); memcpy(B, b, len << 2);\n    for (int i = 1; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len : 0);\n    ntt(A, lim, 1); ntt(B, lim, 1);\n    for (int i = 0; i < lim; ++i) b[i] = dec((B[i] << 1) % mod, mul(A[i], mul(B[i], B[i])));\n    ntt(b, lim, 0);\n    memset(b + len, 0, len << 2);\n  }\n  memset(A, 0, len << 2); memset(B, 0, len << 2);\n  memset(b + n, 0, (len - n) << 2);\n}\n\nvoid inline sqrt(int *a, int *b, int n) {\n  int sr = cipolla(a[0]);\n  b[0] = std::min(sr, mod - sr);\n  static int A[maxn], B[maxn], len, lim;\n  for (len = 1; len < n << 1; len <<= 1) {\n    lim = len << 1;\n    memcpy(A, a, len << 2);\n    inv(b, B, len);\n    for (int i = 1; i < lim; ++i) r[i] = (r[i >> 1] >> 1) | ((i & 1) ? len : 0);\n    ntt(A, lim, 1); ntt(B, lim, 1);\n    for (int i = 0; i < lim; ++i) A[i] = mul(A[i], B[i]);\n    ntt(A, lim, 0);\n    for (int i = 0; i < len; ++i) b[i] = mul(inv2, pls(A[i], b[i]));\n    memset(b + len, 0, len << 2);\n  }\n  memset(A, 0, len << 2); memset(B, 0, len << 2);\n  memset(b + n, 0, (len - n) << 2);\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int *i = a; i < a + n; ++i) scanf(\"%d\", i);\n  sqrt(a, b, n);\n  for (int *i = b; i < b + n; ++i) printf(\"%d%c\", *i, \" \\n\"[i == b + n - 1]);\n  return 0;\n}\n```\n\n~~\u6284\u6211\u7684\u4ee3\u7801\u4f1aTLE233~~",
        "postTime": 1553935411,
        "uid": 47055,
        "name": "ikka",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5277 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u5f00\u6839\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "## $\\texttt{Description}$\n\n\u7ed9 $\\deg = n-1$ \u7684\u591a\u9879\u5f0f $f$\uff0c\u6c42\u591a\u9879\u5f0f $g$ \u6ee1\u8db3\n$$\n        g \\equiv \\sqrt f \\pmod {x^n}\n$$\n\n## $\\texttt{Solution}$\n\n\u8003\u8651\u725b\u987f\u8fed\u4ee3\uff1a\u6709 $h(g(x)) = g(x)^2 - f(x) \\equiv 0 \\pmod {x^n}$\n\n$$\n    g(x) \\equiv \\dfrac {g_0(x) - g_0^2(x) - f(x)} {2g_0(x)} \\pmod {x^n}\n$$ \n\n$$\n    g(x) \\equiv \\dfrac {g_0^2(x)+f(x)} {2g_0(x)} \\pmod {x^n}\n$$\n\n\u5176\u4e2d $g_0(x)$ \u662f\u5728\u6a21 $x^{ \\lceil \\frac {n} 2 \\rceil}$ \u65f6\u7684\u7b54\u6848\u3002\n\n\u5728 $n=1$ \u65f6\u7528 cipolla \u7b97\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002\n\n## $\\texttt{Code}$\n\n```cpp\ninline auto Sqrt(vector<int> a) {\n    if (a.size() == 1) return vector<int> (1,quad::cipolla(a[0])) ;\n    const int len = a.size() ;\n    auto ta = a;\n    ta.resize((len + 1) >> 1) ;\n    auto tb = Sqrt(ta);\n    tb.resize(len) ;\n    auto tc = tb * tb;\n    tc.resize(len) ;\n    for (auto &it : tb) it = 2ll * it % mod ;\n    for (int i = 0; i < len; ++i) tc[i] = (tc[i] + a[i]) % mod ;\n    return tc = tc * Inv(tb),tc.resize(len),tc ;\n}\n```",
        "postTime": 1629196740,
        "uid": 413147,
        "name": "_Alejandro_",
        "ccfLevel": 0,
        "title": "P5277 \u9898\u89e3"
    }
]