[
    {
        "content": "\u8fd9\u9053\u9898\u5bf9 `EK+spfa` \u7b97\u6cd5\u4e0d\u592a\u53cb\u597d\uff0c\u9700\u8981\u5361\u5e38\u624d\u80fd\u901a\u8fc7\u3002\n\n\uff08\u4f46\u662f\u597d\u6b79\u5361\u8fc7\u53bb\u4e86\uff09\n\n\u5b66\u4e60\u8d39\u7528\u6d41\uff08\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff09\u9996\u5148\u8981\u5b66\u4e60\u7f51\u7edc\u6d41\uff0c\u53ef\u4ee5\u770b\u6211\u7684[\u9898\u89e3](https://www.luogu.com.cn/blog/I-do-not-want-TLE/solution-b3606)\uff0c\u5f53\u7136\u53ef\u4ee5\u53c2\u8003[\u7ecf\u5178\u65e5\u62a5](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)\u3002\n\n\u8d39\u7528\u6d41\u548c\u7f51\u7edc\u6d41\u7684\u5f62\u6001\u5f88\u7c7b\u4f3c\uff0c\u4e3b\u4f53\u8fd8\u662f\u6839\u636e\u7f51\u7edc\u6d41\u3002\u4e0b\u9762\u4e3e\u4e00\u4e2a\u4f8b\u5b50\uff08\u53c8\u662f\u501f\u9274\u65e5\u62a5\uff09\u3002\n\n\u5047\u8bbe `s` \u57ce\u6709 `inf`\u4e2a\uff08\u7a77\uff09\u4eba\u60f3\u53bb `t` \u57ce\uff0c\u4f46\u662f\u4ece `s`\u5230`t` \u8981\u7ecf\u8fc7\u4e00\u4e9b\u57ce\u5e02\u624d\u80fd\u5230\u8fbe\uff0c\u6bcf\u6761\u8def\u6709\u6700\u5927\u6d41\u91cf\u548c\u6743\u503c\uff08\u6d41\u91cf\u901a\u8fc7 `1` \u6240\u82b1\u8d39\u7684\u4ee3\u4ef7\uff09\uff0c\u95ee\u6700\u7ec8\u6700\u591a\u80fd\u6709\u591a\u5c11\u4eba\u80fd\u5230\u8fbe `t` \u57ce\u3002\uff08\u7531\u4e8e\u662f\u7a77\u4eba\uff09\u4ed6\u4eec\u5e0c\u671b\u80fd\u5728\u6700\u591a\u4eba\u5230\u8fbe `t` \u57ce\u7684\u540c\u65f6\u82b1\u6700\u5c11\u7684\u94b1\uff0c\u95ee\u6700\u5c11\u7684\u94b1\u662f\u591a\u5c11\u3002\n\n\u8d39\u7528\u6d41\u5c31\u662f\u5728\u6d41\u91cf\u6700\u5927\u7684\u60c5\u51b5\u4e0b\u6240\u82b1\u8d39\u7684\u6700\u5c0f\u8d39\u7528\u3002\n\n\u76f8\u8f83\u4e8e\u7f51\u7edc\u6d41\uff0c\u8d39\u7528\u6d41\u53ea\u662f\u589e\u52a0\u4e86\u6743\u503c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u89e3\u51b3\u6743\u503c\u95ee\u9898\u5373\u53ef\u3002\n\n\u8fd9\u4f60\u60f3\u5230\u4e86\u4ec0\u4e48\uff1f\u4ee3\u4ef7\u6700\u5c0f\uff1f\u90a3\u5c31\u6700\u77ed\u8def\uff01\n\n\u56e0\u4e3a\u6709\u8d1f\u6743\u8fb9\uff0c\u6240\u4ee5 `spfa` \u662f\u6700\u65b9\u4fbf\u7684\uff01\u800c\u4e14\u9700\u8981\u8fdb\u884c\u591a\u6b21 `spfa` \u6240\u4ee5\u57fa\u672c\u4e0a\u4e0d\u4f1a\u5168\u90fd\u5361\u6210 $n^2$ \u3002\n\n\u5173\u4e8e `spfa` \u5b83\u8bc8\u5c38\u4e86\uff01\uff08\u5927\u96fe\uff09\n\n\u518d\u8be6\u7ec6\u4e00\u70b9\uff0c\u5c31\u662f\u628a `bfs` \u6539\u6210 `spfa` ,\u518d\u677e\u5f1b\u8fc7\u7a0b\u4e2d\u8bb0\u5f55\u8def\u5f84\u5373\u53ef\u3002\n\n\u8fd9\u9053\u677f\u5b50\u9898\u4f1a\u5361\u4e00\u4e0b `EK+SPFA`\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u884c\u5361\u5e38\u3002\n\n\u4e0b\u9762\u662f\u4ee3\u7801\uff1a\n\n```\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nnamespace in{\n    #ifdef faster\n    char buf[1<<21],*p1=buf,*p2=buf;\n    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\n    #else\n    inline int getc(){return getchar();}\n    #endif\n    template <typename T>inline void read(T& t){\n        t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}\n        while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;\n    }\n    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}\n}\nnamespace out{\n    char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;\n    inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}\n    inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}\n    template <typename T>void write(T x) {\n        static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}\n        while (len>=0)putc(buf[len]),--len;\n    }\n}\nconst int inf=2147483647;\nint maxn,cost;\nint top=1,head[5001];\nint dis[5001];\nint n,m,s,t,book[5001];\nint min(int a,int b){\n\treturn a>b?b:a;\n}\nstruct point{\n    int v,w,val,next;\n}a[100001];\nstruct b{\n    int fa;\n    int v;\n}b[5001];\ninline void add(int u,int v,int val,int w){\n    a[++top].v=v;\n    a[top].val=val;\n    a[top].w=w;\n    a[top].next=head[u];\n    head[u]=top;\n}\nqueue<int> q;\ninline bool spfa(){\n    for(register int i=1;i<=n;i++)\n    \tdis[i]=inf,b[i].fa=b[i].v=book[i]=0;\n    dis[s]=0;\n    q.push(s);\n    book[s]=1;\n    while(!q.empty()){\n        int u=q.front();\n        book[u]=0;\n        q.pop();\n        for(register int i=head[u];i;i=a[i].next){\n            int v=a[i].v,w=a[i].w;\n            if(a[i].val>0&&dis[v]>dis[u]+w){\n                dis[v]=dis[u]+w;\n                b[v].fa=u,b[v].v=i;\n                if(book[v]==0){\n                    q.push(v);\n                    book[v]=1;\n                }\n            }\n        }\n    }\n    return dis[t]!=inf;\n}\nvoid EK(){\n    while(spfa()){\n        int minn=inf;\n        for(register int i=t;i!=s;i=b[i].fa)\n\t\t\tminn=min(minn,a[b[i].v].val);\n        for(register int i=t;i!=s;i=b[i].fa){\n            a[b[i].v].val-=minn;\n            a[b[i].v^1].val+=minn;\n        }\n        maxn+=minn;\n        cost+=minn*dis[t];\n    }\n    return;\n}\nint main()\n{\n    in::read(n,m);\n    s=1,t=n;\n    int u,v,val,w;\n    for(register int i=1;i<=m;i++){\n        in::read(u,v,val,w);\n        add(u,v,val,w);\n        add(v,u,0,-w);\n    }\n    EK();\n    printf(\"%d %d\",maxn,cost);\n    return 0;\n}\n```",
        "postTime": 1627643603,
        "uid": 253738,
        "name": "\u542c\u53d6MLE\u58f0\u4e00\u7247",
        "ccfLevel": 7,
        "title": "B3608\u9898\u89e3"
    },
    {
        "content": "\u672c\u9898\u5c5e\u4e8e\u6a21\u677f\u9898\uff0c\u53ef\u4ee5\u7528 dinic \u8d39\u7528\u6d41\u8dd1\u6389\u3002\n\ndinic \u662f\u4e00\u79cd\u6bd4\u8f83\u9ad8\u6548\u7684\u7b97\u6cd5\uff0c\u662f\u5bf9 EK \u7b97\u6cd5\u7684\u6539\u8fdb\uff0c\u5176\u7b97\u6cd5\u6d41\u7a0b\u4e3a\uff1a\n\n1 \u3001\u6839\u636e\u6b8b\u91cf\u7f51\u7edc\u5efa\u7acb\u5206\u5c42\u56fe\uff08\u6309\u5230\u6e90\u70b9\u7684\u6700\u77ed\u8ddd\u79bb\u5206\u5c42\uff0c\u53ea\u6709\u76f8\u90bb\u7684\u5c42\u4e4b\u95f4\u6709\u8fb9\uff09\u3002\n\n2 \u3001\u5728\u5206\u5c42\u56fe\u4e2d\u4f7f\u7528 DFS \u8fdb\u884c\u589e\u5e7f\u76f4\u5230\u4e0d\u5b58\u5728\u589e\u5e7f\u8def\u3002 \n\n3 \u3001\u91cd\u590d\u4ee5\u4e0a\u6b65\u9aa4\u76f4\u5230\u65e0\u6cd5\u7ee7\u7eed\u589e\u5e7f\u3002\n\ndinic \u4e2d\u9700\u8981\u7528\u5230\u53cd\u6094\u64cd\u4f5c\uff0c\u53cd\u6094\u64cd\u4f5c\u662f\u5c06\u5df2\u7ecf\u6d41\u51fa\u7684\u6d41\u91cf\u6d41\u56de\u53bb\uff0c\u5177\u4f53\u65b9\u6cd5\u4e3a\uff1a\u5bf9\u4e8e \u8fb9 $i$ \uff0c\u6dfb\u52a0\u4e00\u6761\u6d41\u91cf\u4e3a $0$ \u7684\u53cd\u5411\u8fb9 $i'$ \uff0c\u6bcf\u6b21\u4ece $i$ \u6d41\u51fa $c$ \u4e2a\u5355\u4f4d\u6d41\u91cf\u540e\uff0c\u5219\u5728 $i'$ \u52a0\u4e0a $c$ \u4e2a\u5355\u4f4d\u7684\u6d41\u91cf\u3002\n\ndinic \u7f51\u7edc\u6d41\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n#define int long long\ninline int read() {\n\tint x = 0, ch = getchar();\n\twhile(ch < '0' || ch > '9') ch = getchar();\n\twhile(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\treturn x;\n}\nconst int N = 505, M = 10005;\ninline int min(int x, int y) {\n\treturn x < y ? x : y;\n}\nint n, m, s, t, f, r, maxf, q[N], dep[N], to[M], fir[N], cur[N], nxt[M], flow[M], cnt = 1;//\u8fb9\u4ece1\u5f00\u59cb\uff0c\u8fd9\u6837 i ^ 1 \u5bf9\u5e94\u7684\u5c31\u662f\u53cd\u5411\u8fb9\ninline void add(int u, int v, int f) {\n\tto[++cnt] = v;\n\tflow[cnt] = f;\n\tnxt[cnt] = fir[u];\n\tfir[u] = cnt;\n}\ninline bool bfs() {\n\tq[f = r = 1] = s;\n\tmemset(dep, 0, sizeof dep);\n\tdep[s] = 1;\n\twhile(f <= r) {\n\t\tint u = q[f++];\n\t\tfor(int i = fir[u]; i; i = nxt[i]) {\n\t\t\tif(!dep[to[i]] && flow[i]) {\n\t\t\t\tq[++r] = to[i];\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] != 0; //\u6c47\u70b9\u975e0\u5219\u6709\u589e\u5e7f\u8def\n}\ninline int dfs(int u, int in) {\n\tif(u == t) return in;\n\tint res, out = 0;\n\tfor(int i = cur[u]; i; i = nxt[i]) {\n\t\tcur[u] = i; //\u5f53\u524d\u5f27\u4f18\u5316\uff0c\u5df2\u7ecf\u8d70\u8fc7\u7684\u8fb9\u4e0d\u518d\u8d70\n\t\tif(flow[i] && dep[to[i]] == dep[u] + 1) { //\u8be5\u6761\u8fb9\u662f\u589e\u5e7f\u8def\u4e2d\u7684\u8fb9\u3002\n\t\t\tres = dfs(to[i], min(flow[i], in)); //\u53d7\u589e\u5e7f\u8def\u4e0a\u6700\u5c0f\u6d41\u91cf\u7684\u9650\u5236\n\t\t\tin -= res, out += res, flow[i] -= res, flow[i ^ 1] += res;\n\t\t}\n\t}\n\tif(out == 0) dep[u] = 0; //\u8fd9\u4e2a\u70b9\u6ca1\u7528\n\treturn out;\n}\ninline void dinic() {\n\twhile(bfs()) {\n\t\tmemcpy(cur, fir, sizeof cur); \n\t\tmaxf += dfs(s, 0x7fffffff); //\u6e90\u70b9\u62e5\u6709\u65e0\u9650\u7684\u6d41\u91cf\n\t}\n}\nsigned main() {\n\tn = read(), m = read(), s = read(), t = read();\n\tfor(int i = 1, u, v, f; i <= m; i++) {\n\t\tu = read(), v = read(), f = read();\n\t\tadd(u, v, f);\n\t\tadd(v, u, 0);\n\t}\n\tdinic();\n\tprintf(\"%lld\", maxf);\n\treturn 0;\n}\n```\n\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u6b21\u8fdb\u884c BFS \u5206\u5c42\u65f6\uff0c\u5c42\u6570\u662f\u4e25\u683c\u9012\u589e\u7684\uff0c\u6700\u591a\u4e3a $n$ \u5c42\uff0c\u6240\u4ee5 BFS \u6700\u591a\u8fdb\u884c $n$ \u6b21\uff1b\u6bcf\u6761\u589e\u5e7f\u8def\u4e4b\u95f4\u7684\u5173\u952e\u8fb9\uff08\u5373\u8be5\u6761\u589e\u5e7f\u8def\u4e0a\u6d41\u91cf\u6700\u5c0f\u7684\u8fb9\uff09\u662f\u4e92\u4e0d\u76f8\u540c\u7684\uff0c\u53ef\u5f97\u589e\u5e7f\u8def\u6700\u5927\u4e3a $m$ \u6761\uff0c\u5bf9\u4e00\u6761\u589e\u5e7f\u8def DFS \u7684\u590d\u6742\u5ea6\u4e3a $O(n)$ \u3002\u6839\u636e\u4e0a\u8ff0\u63a8\u8bba\u53ef\u5f97 dinic \u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u4e0a\u754c\u4e3a $O(n^2 m)$ ,\u5b9e\u9645\u8fd0\u7528\u4e2d\u4e0d\u4f1a\u8fbe\u5230\u8be5\u4e0a\u754c\uff0c\u53e6\u5916\uff0c dinic \u5728\u4e8c\u5206\u56fe\u4e2d\u7684\u590d\u6742\u5ea6\u7ea6\u4e3a $O(m\\sqrt n )$  \u3002\n\n\u7f51\u7edc\u6d41\u5176\u5b9e\u53ef\u4ee5\u770b\u4f5c\u662f\u4e00\u79cd\u6240\u6709\u8fb9\u7684\u8d39\u7528\u90fd\u4e3a $1$ \u7684\u8d39\u7528\u6d41\uff0c\u90a3\u4e48\u5728\u8d39\u7528\u6d41\u4e2d\u4e5f\u662f\u7c7b\u4f3c\u7684\u64cd\u4f5c\uff0c\u53ea\u4e0d\u8fc7\u5728\u6c42\u6700\u5927\u6d41\u7684\u540c\u65f6\uff0c\u8d70\u7684\u90fd\u662f\u8d39\u7528\u6700\u5c0f\u7684\u589e\u5e7f\u8def\uff0c\u5c06\u5efa\u7acb\u5206\u5c42\u56fe\u7684 BFS \u51fd\u6570\u6539\u6210\u6c42\u6700\u77ed\u8def\u51fd\u6570\uff0c \u5c06\u5224\u65ad\u4e2d\u7684 `dep[to[i]] == dep[u] + 1` \u6539\u6210 ` dep[to[i]] == dep[u] + cost[i]` \u5373\u53ef\u3002\n\n\u53e6\u5916\uff0c\u5efa\u8fb9\u65f6\u6dfb\u52a0\u7684\u53cd\u5411\u8fb9\uff0c\u8d39\u7528\u5e94\u4e3a\u8d1f\uff08\u6d41\u56de\u53bb\u7684\u6d41\u91cf\u76f8\u5f53\u4e8e\u6ca1\u6d41\uff0c\u8981\u628a\u5df2\u7ecf\u6d41\u8fc7\u7684\u94b1\u7ed9\u6263\u56de\u6765\uff09\uff0c\u56e0\u4e3a\u8d39\u7528\u5b58\u5728\u8d1f\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f7f\u7528\u53ef\u4ee5\u5904\u7406\u8d1f\u6743\u6700\u77ed\u8def\u7684 spfa \u6700\u77ed\u8def\u7b97\u6cd5\uff0c\u5f53\u7136\u7528\u52bf\u51fd\u6570\u5904\u7406\u8fc7\u7684 dijkstra \u4e5f\u662f\u53ef\u4ee5\u7684\u3002\n\n\u81f3\u4e8e\u65f6\u95f4\u590d\u6742\u5ea6\u5462\uff0c\u8fd8\u662f\u4e0d\u53d8\u7684 $O(n^2 m)$ \uff0c \u53ea\u662f\u5e38\u6570\u4f1a\u7a0d\u5927\u4e00\u4e9b\u3002\n\n```cpp\n#include <cstdio>\n#include <cstring>\nusing namespace std;\ninline int read() {\n\tint x = 0, ch = getchar();\n\twhile(ch < '0' || ch > '9') ch = getchar();\n\twhile(ch >= '0' && ch <= '9') x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n\treturn x;\n}\ninline int min(int a, int b) {\n\treturn a < b ? a : b;\n}\nconst int N = 405, M = 15005, INF = 2147483647;\nint n, m, s, t, cnt = 1, fir[N], cur[N], nxt[M << 1], flow[M << 1], cost[M << 1], to[M << 1], dis[N], minc, maxf, q[N * M], f, r;\nbool inq[N];\ninline bool spfa() {//spfa\u6700\u77ed\u8def\u7b97\u6cd5 \n\tmemset(inq, 0, sizeof inq);\n\tmemset(dis, 0x3f, sizeof dis);\n\tq[f = r = 1] = s;\n\tdis[s] = 0;\n\tinq[s] = true;\n\tint u;\n\twhile(f <= r) {\n\t\tu = q[f++], inq[u] = false;\n\t\tfor(int i = fir[u]; i; i = nxt[i]) {\n\t\t\tif(flow[i] && dis[to[i]] > dis[u] + cost[i]) {\n\t\t\t\tdis[to[i]] = dis[u] + cost[i];\n\t\t\t\tif(!inq[to[i]]) {\n\t\t\t\t\tq[++r] = to[i];\n\t\t\t\t\tinq[to[i]]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != 0x3f3f3f3f;//\u6c47\u70b9\u53ef\u5230\u8fbe \n}\ninline int dfs(int u, int in) {\n\tif(u == t) return in;\n\tint out = 0, res;\n\tinq[u] = true;//\u662f\u5426\u5728\u641c\u7d22\u8fdb\u7a0b\u4e2d \n\tfor(int i = cur[u]; i && in; i = nxt[i]) {\n\t\tcur[u] = i;//\u5f53\u524d\u5f27\u4f18\u5316\uff0c\u5df2\u7ecf\u8d70\u8fc7\u7684\u8fb9\u4e0d\u518d\u8d70 \n\t\tif(!inq[to[i]] && flow[i] && dis[to[i]] == dis[u] + cost[i]) {\n\t\t\tres = dfs(to[i], min(in, flow[i])); //\u6d41\u91cf\u53d7\u4e00\u8def\u4e0a\u6d41\u91cf\u6700\u5c0f\u8fb9\u7684\u9650\u5236\n\t\t\t//\u6b63\u8fb9\u6d41\u91cf\u6d41\u51fa\uff0c\u53cd\u5411\u8fb9\u52a0\u4e0a\u76f8\u5e94\u7684\u6d41\u91cf\uff0c\u65b9\u4fbf\u6d41\u56de \n\t\t\tin -= res, out += res, flow[i] -= res, flow[i ^ 1] +=res, minc += cost[i] * res;//\u7531\u4e8e\u6bcf\u6b21\u8d70\u7684\u90fd\u662f\u8d39\u7528\u6700\u5c0f\u7684\u589e\u5e7f\u8def\uff0c\u6240\u4ee5\u5728\u627e\u51fa\u6700\u5927\u6d41\u7684\u524d\u63d0\u4e0b\uff0c\u8d39\u7528\u4e5f\u662f\u6700\u5c0f\u7684 \n\t\t}\n\t}\n\tif(!out)dis[u] = 0x3f3f3f3f;//\u65e0\u6cd5\u63d0\u4f9b\u6d41\u91cf\uff0c\u5219\u4e0d\u518d\u4f7f\u7528\u6b64\u70b9 \n\tinq[u] = false;\n\treturn out;\n}\ninline void zkw_dinic() {\n\twhile(spfa()) {\n\t\tmemcpy(cur, fir, sizeof fir); \n\t\tmaxf += dfs(s, INF);\n\t}\n}\ninline void add(int u, int v, int f, int c) {//\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe \n\tto[++cnt] = v;//\u53bb\u7684\u70b9 \n\tflow[cnt] = f;//\u6d41\u91cf \n\tcost[cnt] = c;//\u5355\u4f4d\u82b1\u8d39 \n\tnxt[cnt] = fir[u];\n\tfir[u] = cnt;\n}\nint main() {\n\tn = read(), m = read(), s = 1, t = n;\n\tfor(int i = 1, u, v, f, c; i <= m; i++) {\n\t\tu = read(), v = read(), f = read(), c = read();\n\t\tadd(u, v, f, c);//\u6b63\u8fb9 \n\t\tadd(v, u, 0, -c);//\u53cd\u5411\u8fb9\u7684\u6d41\u91cf\u662f 0 \uff0c\u8d39\u7528\u4e3a\u8d1f\uff0c\u65b9\u4fbf\u6d41\u56de \n\t}\n\tzkw_dinic();\n\tprintf(\"%d %d\\n\", maxf, minc);\n\treturn 0;\n}\n```\n",
        "postTime": 1640672951,
        "uid": 434929,
        "name": "Usada_Pekora",
        "ccfLevel": 7,
        "title": "B3608 \u8d39\u7528\u6d41\u6a21\u677f"
    },
    {
        "content": "\u9898\u89e3\u6570\u548c\u901a\u8fc7\u7387\u90fd\u5c11\u7684\u53ef\u601c\u7684\u5165\u95e8\u4e0e\u9762\u8bd5\u9898\uff0c\u53ef\u89c1\u5176\u6bd2\u7624\u7684\u5361\u5e38\u7a0b\u5ea6\u3002\n\n\uff08\u9898\u89e3\u597d\u5c11\uff0c\u8d76\u7d27\u6c34\u4e00\u53d1\uff0c\u672c\u6587\u4e3b\u8981\u6559\u5361\u5e38\uff09\u3002\n\n## \u9898\u76ee\u5927\u610f\n\n\u7ed9\u5b9a\u4e00\u4e2a\u56fe\uff0c\u6c42\u6700\u5927\u6d41\u548c\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n$1\\leq n \\leq 400,1\\leq m \\leq 15000$\uff0c\u4fdd\u8bc1\u7b54\u6848\u5728 int \u8303\u56f4\u5185\u3002\n\n## \u9898\u76ee\u5206\u6790\n\n\u65e2\u7136\u662f\u6a21\u677f\u9898\uff0c\u5c31\u4e0d\u4e0d\u5206\u6790\u4e86\uff0c\u6211\u4eec\u8003\u8651\u53ea\u6c42\u6700\u5927\u6d41\u65f6\u6211\u4eec\u662f\u600e\u4e48\u505a\u7684\uff1f\u4f7f\u7528 dinic \u7b49\u7b97\u6cd5\uff0c\u6c42\u6700\u5c0f\u8d39\u7528\u4e5f\u5dee\u4e0d\u591a\uff0c\u6211\u4eec\u8003\u8651\u5c06\u5206\u5c42\u56fe\u6539\u4e00\u4e0b\uff0c\u8bbe $dis_i$ \u4e3a\u5206\u5c42\u56fe\u7684\u6743\u503c\uff0c\u90a3\u4e48\u76f4\u63a5\u8dd1 spfa \u6c42\u51fa\u6765\u6700\u77ed\u8def\u5373\u53ef\uff08\u6309\u8fb9\u6743\u4e3a\u8d39\u7528\u8dd1\uff09\uff0c\u6ce8\u610f\u5728\u7f51\u7edc\u6d41\u4e2d spfa \u6ca1\u6b7b\uff08\u8bc1\u660e\u6211\u4e0d\u4f1a\uff09\u3002\n\n\u5177\u4f53\u505a\u6cd5\u8fd8\u662f\u5efa\u8bae\u770b\u770b\u5176\u4ed6\u4eba\u7684\u5b66\u4e60\u7b14\u8bb0\u3001\u9898\u89e3\u3002\u56de\u5230\u5f00\u5934\u90a3\u53e5\u8bdd\uff0c\u672c\u6587\u8bb2\u8fd9\u9053\u9898\u600e\u4e48\u5361\u5e38\u3002\n\n- \u5feb\u8bfb\u5feb\u8f93\n- \u7528\u5faa\u73af\u8d4b\u503c\uff0c\u4e0d\u7528 memset\n- \u6e90\u70b9\u6c47\u70b9\u76f4\u63a5\u8bbe\u4e3a $1,n$\n- c++98\n- \u7f51\u7edc\u6d41\u53cc\u7aef\u961f\u5217\u4f18\u5316\n\n\uff08\u4e3a\u4ec0\u4e48\u4e0d\u52a0\u5f53\u524d\u5f27\u4f18\u5316\uff1f\u56e0\u4e3a\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u6211\u7684\u4ee3\u7801\u52a0\u4e0a\u662f\u8d1f\u4f18\u5316\uff09\n\n\u52a0\u4e0a\u8fd9\u4e9b\u4f18\u5316\u6211\u624d\u8279\u8fc7\u53bb\u8fd9\u9053\u9898\uff0c\u53ef\u89c1\u6b64\u9898\u6709\u591a\u6bd2\u7624\u3002\n\n## Code\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nstruct FastIO\n{\n    static const int S=1048576;char buf[S],*L,*R;int stk[20],Top;~FastIO(){clear();}\n    inline char nc(){return L==R&&(R=(L=buf)+fread(buf,1,S,stdin),L==R)?EOF:*L++;}inline void clear(){fwrite(buf,1,Top,stdout);Top=0;}\n    inline void pc(char ch){Top==S&&(clear(),0);buf[Top++]=ch;}inline void endl(){pc('\\n');}\n    FastIO& operator >> (char&ch){while(ch=nc(),ch==' '||ch=='\\n');return *this;}\n    template<typename T>FastIO& operator >> (T&ret)\n    {\n        ret=0;int f=1;char ch=nc();while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=nc();}\n        while(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=nc();}ret*=f;return *this;\n    }\n    FastIO& operator >> (char* s){int Len=0;char ch=nc();while(ch!='\\n'){*(s+Len)=ch;Len++;ch=nc();}}\n    template<typename T>FastIO& operator << (T x)\n    {\n        if(x<0){pc('-');x=-x;}do{stk[++stk[0]]=x%10;x/=10;}while(x);\n        while(stk[0]) pc('0'+stk[stk[0]--]);return *this;\n    }\n    FastIO& operator << (char ch){pc(ch);return *this;}\n    FastIO& operator << (string str){int Len=str.size()-1;for(stk[0]=0;Len>=0;Len--) stk[++stk[0]]=str[Len];while(stk[0]) pc(stk[stk[0]--]);return *this;}\n}fin,fout;\nconst int N = 405;\nconst int M = 35005;\nstruct aa{\n\tint nxt,to,val,cost;\n}edge[M];\nint tot=1,head[N];\nvoid add(int u,int v,int w,int x){\n\tedge[++tot].nxt = head[u];edge[tot].to = v;edge[tot].val = w;edge[tot].cost = x;head[u] = tot;\n\tedge[++tot].nxt = head[v];edge[tot].to = u;edge[tot].val = 0;edge[tot].cost =-x;head[v] = tot;\n} \nint n,m,inf = 2147483647;\nint ans,flow,S,T;\nint dis[N];\ndeque<int>q;\nbool vis[N];\nbool spfa(){\n\tfor(int i=S;i<=T;i++){\n\t\tdis[i] = inf;\n\t\tvis[i] = 0;\n\t}\n\tdis[S] = 0;\n\tq.push_back(S);\n\tvis[S] = 1;\n\twhile(!q.empty()){\n\t\tif(q.size()>1&&(dis[q.front()]>dis[q.back()])){\n\t\t\tswap(q.front(),q.back());\n\t\t}\n\t\tint p = q.front();\n\t\tq.pop_front();\n\t\tvis[p] = 0;\n\t\tfor(int i=head[p];i;i=edge[i].nxt){\n\t\t\tint now = edge[i].to;\n\t\t\tif(dis[now]>dis[p]+edge[i].cost&&edge[i].val){\n\t\t\t\tdis[now] = dis[p]+edge[i].cost;\n\t\t\t\tif(!vis[now]){\n\t\t\t\t\tif(!q.empty()&&dis[now]<dis[q.front()]){\n\t\t\t\t\t\tq.push_front(now);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tq.push_back(now);\n\t\t\t\t\t}\n\t\t\t\t\tvis[now] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T]<inf;\n}\nint dfs(int u,int f){\n\tif(u==T){\n\t\treturn f;\n\t}\n\tvis[u] = 1;\n\tint used = 0;\n\tfor(int i=head[u];i&&f;i=edge[i].nxt){\n\t\tint now = edge[i].to;\n\t\tif(!vis[now]&&dis[now]==dis[u]+edge[i].cost&&edge[i].val){\n\t\t\tint w = dfs(now,min(f,edge[i].val));\n\t\t\tans+=w*edge[i].cost;\n\t\t\tedge[i].val-=w;edge[i^1].val+=w;\n\t\t\tused+=w;f-=w;\n\t\t}\n\t}\n\tvis[u] = 0;\n\tif(!used){\n\t\tdis[u] = inf;\n\t}\n\treturn used;\n}\nvoid mcmf(){\n\twhile(spfa()){\n\t\tfor(int i=S;i<=T;i++){\n\t\t\tvis[i] = 0;\n\t\t}\n\t\tflow+=dfs(S,inf);\n\t}\n}\nint main(){\n\tfin>>n>>m;\n\tS = 1;T = n;\n\tint u,v,w,x;\n\tfor(int i=1;i<=m;i++){\n\t\tfin>>u>>v>>w>>x;\n\t\tadd(u,v,w,x);\n\t}\n\tmcmf();\n\tfout<<flow;fout<<' ';fout<<ans;\n\treturn 0;\n}\n```\n\n\u5c5e\u5b9e\u6ca1\u60f3\u5230\u6a21\u677f\u9898\u4eba\u8fd9\u4e48\u5c11\u3002",
        "postTime": 1668344589,
        "uid": 369399,
        "name": "yizhiming",
        "ccfLevel": 0,
        "title": "\u9898\u89e3\u3010B3608 [\u56fe\u8bba\u4e0e\u4ee3\u6570\u7ed3\u6784 601] \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u4f3c\u4e4e\u5bf9\u4e8e\u589e\u5e7f\u8def\u7b97\u6cd5\u90fd\u4e0d\u592a\u53cb\u597d\uff0c\u7136\u9e45 lz \u592a\u83dc\u4e86\u53ea\u4f1a EK+SPFA \u7684\u5355\u8def\u589e\u5e7f\uff0c\u6b7b\u6d3b\u5361\u4e0d\u8fdb\u53bb\uff0c\u4e8e\u662f\u5c31\u5b66\u4e60\u4e86\u591a\u8def\u589e\u5e7f\u8d39\u7528\u6d41\u8fd9\u4e2a\u542c\u8d77\u6765\u4f3c\u4e4e\u5f88\u9ad8\u7ea7\u7684\u4e1c\u897f\u3002\n\n\u666e\u901a\u7684\u5355\u8def\u589e\u5e7f\u8d39\u7528\u6d41\u6bcf\u6b21\u90fd\u53ea\u80fd\u589e\u5e7f\u4e00\u6761\u8def\u5f84\uff0c\u589e\u5e7f\u4e4b\u540e\u90fd\u8981\u7528 SPFA \u91cd\u65b0\u6c42\u6700\u77ed\u8def\uff0c\u6bcf\u6b21 SPFA \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u9ad8\u90fd\u662f $O(nm)$ \u7684\uff0c\u5f88\u663e\u7136\u6bcf\u6b21\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u74f6\u9888\u5c31\u5728\u8fd9\u4e2a $O(nm)$ \u7684 SPFA \u4e0a\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u8bbe\u60f3\uff0c\u5982\u679c\u6709\u4e00\u79cd\u7b97\u6cd5\uff0c\u80fd\u591f\u5927\u91cf\u51cf\u5c11 SPFA \u7684\u6b21\u6570\uff0c\u54ea\u6015\u6bcf\u6b21\u589e\u5e7f\u90fd\u8981\u591a\u505a\u4e00\u70b9\u5de5\u4f5c\uff0c\u90a3\u4e5f\u662f\u7a33\u8d5a\u4e0d\u4e8f\u7684\u3002\n\n\u5982\u4f55\u51cf\u5c11 SPFA \u7684\u6b21\u6570\uff1f\u4f7f\u7528\u7384\u5b66\u7684 Dinic \u7b97\u6cd5\u3002\n\n\u5982\u679c\u8bf4\u5355\u8def\u589e\u5e7f\u8d39\u7528\u6d41\u662f ```EK+SPFA```\uff0c\u90a3\u4e48\u591a\u8def\u589e\u5e7f\u8d39\u7528\u6d41\u5c31\u662f ```Dinic+SPFA```\u3002\n\n\u5177\u4f53\u8981\u600e\u4e48\u505a\uff1f\n\n**\u628a BFS \u6362\u6210 SPFA\uff0c\u6bcf\u6b21\u589e\u5e7f\u65f6\u53ea\u8d70 $dep[v] + w_{ij}= dep[u]$ \u7684\u8def\u5f84\u3002**\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\n\n\u6bcf\u6b21 SPFA \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f $O(nm)$ \u7684\uff0c\u800c DFS \u5bfb\u627e\u589e\u5e7f\u8def\u662f\u4e25\u683c $\\Theta(n+m)$\n\u7684\uff0c\u6bcf\u6b21\u6700\u5c11\u589e\u5e7f\u4e00\u6761\u8def\u5f84\uff0c\u6700\u5c11\u589e\u5e7f\u4e00\u4e2a\u5355\u4f4d\u7684\u6d41\u91cf\uff0c\u6545\u663e\u7136\u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(nmf)$ \u7684\uff0c\u867d\u7136\u662f\u4f2a\u591a\u9879\u5f0f\uff0c\u4f46\u662f\u5b9e\u8df5\u4e2d\u8dd1\u7684\u5f88\u5feb\uff0c\u63a5\u8fd1 $O(n^2m)$\u3002\n\n\u63a5\u4e0b\u6765\u662f\u4ee3\u7801\uff1a\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define inf 2147483647\n#define V 405\n#define E 30005\n#pragma optimize(1)\n#pragma optimize(2)\n#pragma optimize(3,\"Ofast\",\"inline\")\ntypedef long long int ll;\nstruct edge { int to, next, capa, cost; };\nint cnt = 0, head[V], n, m; edge node[E];\ninline void add(register int fir, register int nxt, register int w, register int c) {\n    node[cnt].to = nxt,\n        node[cnt].capa = w,\n        node[cnt].cost = c,\n        node[cnt].next = head[fir],\n        head[fir] = cnt++;\n}\nint s, t, cur[V]; deque<int>que; ll dep[V], sum = 0, cost = 0, num = 0;\nbool vis[V];\ninline bool spfa() {\n    for (register int i = 1; i <= n; ++i)dep[i] = inf;\n    dep[s] = 0; que.push_back(s); register int u, v;\n    while (!que.empty()) {\n        v = que.front();\n        while (dep[v] * que.size() > num)que.pop_front(), que.push_back(v), v = que.front();//SPFA \u7684 LLL\u4f18\u5316\n        que.pop_front();\n        for (register int i = head[v]; i != -1; i = node[i].next) {\n            u = node[i].to;\n            if (node[i].capa && dep[v] + node[i].cost < dep[u]) {\n                dep[u] = dep[v] + node[i].cost,num += dep[u];\n                if (!que.empty() && dep[u] < dep[que.front()])que.push_front(u);\n                else que.push_back(u);\n                //SLF \u4f18\u5316\n            }\n        }\n    }\n    return !(dep[t] == inf);\n}\nll dfs(register int v, register int flow) {\n    if (!flow || v == t)return flow; register int used = 0, wei = 0; vis[v] = true;//\u53ca\u5176\u7384\u5b66\uff0c\u8fd9\u91cc\u5427\u5224\u65ad\u6761\u4ef6\u8c03\u6362\u987a\u5e8f\u5c31\u4f1a TLE\n    for (register int i = cur[v]; i != -1; i = node[i].next) {\n        cur[v] = i;//\u5f53\u524d\u5f27\u4f18\u5316\n        if (!vis[node[i].to] && dep[node[i].to] == dep[v] + node[i].cost && node[i].capa) {\n            wei = dfs(node[i].to, min(flow - used, node[i].capa));\n            if(wei)node[i].capa -= wei,node[i ^ 1].capa += wei,used += wei,cost += node[i].cost * wei;\n        }\n        if (used == flow)break;\n    }\n    vis[v] = false;\n    return used;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(); cout.tie();\n    memset(head, -1, V * sizeof(int));\n    cin>>n>>m; s = 1, t = n;\n    int f, l, w, c;\n    for (register int i = 0; i < m; ++i) {\n        cin>>f>>l>>w>>c;\n        add(f, l, w, c);\n        add(l, f, 0, -c);\n    }\n    while (spfa()) {\n        memcpy(cur, head, (n + 1) * sizeof(int));\n        sum += dfs(s, inf);\n    }\n    cout << sum << \" \" << cost;\n    return 0;\n}\n```\n\n\u4ee3\u7801\u7ecf\u8fc7\u4e86\u4e00\u5b9a\u5361\u5e38\uff0c~~\u6709\u53ef\u80fd\u5728\u8bc4\u6d4b\u673a\u4e0d\u7a33\u5b9a\u7684\u60c5\u51b5\u4e0b TLE~~\u3002\n",
        "postTime": 1648472229,
        "uid": 551861,
        "name": "wql_cai",
        "ccfLevel": 4,
        "title": "B3608\u9898\u89e3"
    },
    {
        "content": "\u7ecf\u5178\u6a21\u677f\u9898\u3002\u5199\u7bc7\u8be6\u7ec6\u4e00\u4e9b\u7684\u9898\u89e3\u9020\u798f\u793e\u4f1a\u3002\n\n\u6240\u8c13\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u4e0e\u6700\u5927\u6d41\u7684\u4e0d\u540c\u70b9\u5728\u4e8e\uff0c\u5373\u5728\u540c\u4e00\u4e2a\u7f51\u7edc\u4e2d\uff0c\u53ef\u80fd\u5b58\u5728\u591a\u4e2a\u603b\u6d41\u91cf\u76f8\u540c\u7684\u6700\u5927\u6d41 $f$ \uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8ba1\u786e\u4fdd\u6d41\u91cf\u6700\u5927\u7684\u524d\u63d0\u4e0b\u603b\u8d39\u7528\u6700\u5c0f\uff0c\u8fd9\u6837\u7684\u6700\u5927\u6d41\u88ab\u79f0\u4e3a **\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41**\u3002\n\n\u5bf9\u4e8e\u8d39\u7528\u6d41\u4e2d\u7684\u53cd\u5411\u5f27\uff0c\u5e94\u5c06\u5269\u4f59\u5bb9\u91cf\u521d\u59cb\u5316\u4e3a $0$\uff0c\u8d39\u7528\u8bbe\u7f6e\u4e3a\u6b63\u5411\u5f27\u7684\u76f8\u53cd\u6570\u3002\n\n\u4e00\u79cd\u601d\u8def\u5927\u81f4\u4e3a\u5148\u7f6e\u7f51\u7edc\u521d\u59cb\u6d41\u91cf\u4e3a $0$\uff0c\u4e4b\u540e\u4e0d\u65ad\u4ee5\u6bcf\u6761\u5f27\u7684\u5355\u4f4d\u6d41\u91cf\u8d39\u7528\u4e3a\u8fb9\u6743\u5728\u5f53\u524d\u7684\u5269\u4f59\u7f51\u7edc\u4e0a\u6c42\u51fa\u4ece $S$ \u5230 $T$ \u7684\u6700\u77ed\u589e\u5e7f\u8def\u3002\u5982\u679c\u4e0d\u5b58\u5728\u5219\u7b97\u6cd5\u7ed3\u675f\uff0c\u5426\u5219\u4fee\u6539\u589e\u5e7f\u8def\u4e0a\u5f27\u7684\u6d41\u91cf\u5e76\u7ee7\u7eed\u589e\u5e7f\u3002\n\n\u589e\u5e7f\u4f7f\u7528 `SPFA` \u8dd1\u6700\u77ed\u8def\u5373\u53ef\u3002\u56e0\u4e3a\u8dd1\u7684\u6b21\u6570\u591a\uff0c\u6240\u4ee5 `SPFA` \u5f88\u96be\u5168\u90e8\u9000\u5316\u4e3a $O(n^2)$\uff0c\u52a0\u4e4b\u8fb9\u5b58\u5728\u8d1f\u6743\uff0c`SPFA` \u65e0\u7591\u6700\u4f73\u9009\u62e9\u3002\n\n\u5199\u7684\u6bd4\u8f83\u7b80\u7565\uff0c\u8be6\u7ec6\u53ef\u53c2\u8003[\u8fd9\u7bc7\u65e5\u62a5](https://www.luogu.com.cn/blog/ONE-PIECE/wang-lao-liu-di-zong-jie)\uff0c\u8bb2\u7684\u6bd4\u6211\u597d\u5f88\u591a\uff0c\u63a8\u8350\u4e00\u8bfb\u3002\n\n---\n\n\u8bf4\u56de\u6b64\u9898\u3002\n\n\u8fd9\u9053\u9898\u5bf9\u65f6\u95f4\u8981\u6c42\u5f88\u7d27\uff0c\u6240\u4ee5\u9700\u8981\u5361\u5e38\u3002\n\n\u63d0\u4f9b\u51e0\u79cd\u5361\u5e38\u65b9\u5f0f\u3002\n\n1. \u628a\u8f93\u5165\u8f93\u51fa\u6362\u4e3a\u5feb\u8bfb\u5feb\u8f93\u3002\n2. \u51fd\u6570\u524d\u52a0\u4e0a `inline`\uff0c\u53d8\u91cf\u524d\u52a0\u4e0a `register`\u3002\n3. \u5c1d\u8bd5\u628a `memset` \u6362\u4e3a\u5faa\u73af\u521d\u59cb\u5316\u3002\n\n---\n\n\u4e22\u4e2a\u4e00\u5e74\u524d\u7684\u4e22\u4eba\u4ee3\u7801\u3002\n\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX_N = 10005;\nconst int MAX_M = 100005;\nconst int inf = 0x7f;\nnamespace in{\n    #ifdef faster\n    char buf[1<<21],*p1=buf,*p2=buf;\n    inline int getc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\n    #else\n    inline int getc(){return getchar();}\n    #endif\n    template <typename T>inline void read(T& t){\n        t=0;int f=0;char ch=getc();while (!isdigit(ch)){if(ch=='-')f = 1;ch=getc();}\n        while(isdigit(ch)){t=t*10+ch-48;ch = getc();}if(f)t=-t;\n    }\n    template <typename T,typename... Args> inline void read(T& t, Args&... args){read(t);read(args...);}\n}\nnamespace out{\n    char buffer[1<<21];int p1=-1;const int p2 = (1<<21)-1;\n    inline void flush(){fwrite(buffer,1,p1+1,stdout),p1=-1;}\n    inline void putc(const char &x) {if(p1==p2)flush();buffer[++p1]=x;}\n    template <typename T>void write(T x) {\n        static char buf[15];static int len=-1;if(x>=0){do{buf[++len]=x%10+48,x/=10;}while (x);}else{putc('-');do {buf[++len]=-(x%10)+48,x/=10;}while(x);}\n        while (len>=0)putc(buf[len]),--len;\n    }\n}\nstruct edge {\n    int v, c, w, next;\n} e[MAX_M];\nint p[MAX_N], s, t, eid;\ninline void init() {\n    memset(p, -1, sizeof(p));\n    eid = 0;\n}\ninline void insert(int u, int v, int c, int w) {\n    e[eid].v = v;\n    e[eid].c = c;\n    e[eid].w = w;\n    e[eid].next = p[u];\n    p[u] = eid++;\n}\ninline void addedge(int u, int v, int c, int w) {\n    insert(u, v, c, w);\n    insert(v, u, 0, -w);\n}\nbool vis[MAX_N];\nint d[MAX_N];\nint pre[MAX_N];\nint pre2[MAX_N];\nint cf[MAX_N];\nint n;\nqueue<int> q;\ninline bool spfa() {\n    for (int i = 0; i <= n; i++) vis[i] = 0, cf[i] = inf, pre2[i] = -1, d[i] = 1000000005;\n    d[s] = 0;\n    vis[s] = true;\n    q.push(s);\n    while (!q.empty()) {\n        register int u = q.front();\n        q.pop();\n        vis[u] = false;\n        for (register int i = p[u]; i != -1; i = e[i].next) {\n            if(e[i].c) {\n                register int v = e[i].v;\n                if (d[u] + e[i].w < d[v]) {\n                    d[v] = d[u] + e[i].w;\n                    pre[v] = i;\n                    pre2[v] = u;\n                    cf[v] = min(cf[u], e[i].c);\n                    if (!vis[v]) {\n                        q.push(v);\n                        vis[v] = true;\n                    }\n                }\n            }\n        }\n    }\n    return (pre2[t] != -1);\n}\nint ret2 = 0, ret;\ninline void costflow() {\n    while (spfa()) {\n        int flow = cf[t];\n        ret += flow * d[t];\n        ret2 += flow;\n        for (register int i = t; i != s; i = e[pre[i] ^ 1].v) {\n            e[pre[i]].c -= flow;\n            e[pre[i] ^ 1].c += flow;\n        }\n    }\n}\nsigned main() {\n    int m;\n    init();\n    in::read(n, m); s = 1, t = n;\n    for (register int i = 0; i < m; ++i) {\n        register int u, v, c, w;\n        in::read(u, v, c, w);\n        addedge(u, v, c, w);\n    }\n    costflow();\n    printf(\"%d %d\\n\", ret2, ret);\n    return 0;\n}\n```\n",
        "postTime": 1648296320,
        "uid": 305379,
        "name": "SolitaryJailbird",
        "ccfLevel": 6,
        "title": "B3608 [\u56fe\u8bba\u4e0e\u4ee3\u6570\u7ed3\u6784 601] \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 \u9898\u89e3"
    },
    {
        "content": "### \u524d\u8a00\n\n\u672c\u9898\u8003\u5bdf\u7b97\u6cd5\uff1a\n\n- \u6700\u77ed\u8def\n- \u5206\u5c42\u56fe\u601d\u60f3\n- \u7f51\u7edc\u6d41\n\n\u8fd9\u662f\u8d39\u7528\u6d41\u7684\u677f\u5b50\u9898\uff0c\u552f\u4e00\u96be\u70b9\u662f\u672c\u9898\u5361\u5e38\uff0c\u5176\u4ed6\u90fd\u4e0d\u96be\u3002\n\n------------\n\n### Solution\n\n\u7f51\u7edc\u6700\u5927\u6d41\u76f8\u4fe1\u5927\u5bb6\u90fd\u4f1a\u4e86\uff0c\u8d39\u7528\u6d41\u4fbf\u662f\u5efa\u7acb\u5728\u6b64\u4e4b\u4e0a\u7684\u4e00\u4e2a\u7b97\u6cd5\u3002\n\n\u4e0e\u7f51\u7edc\u6d41\u4e0d\u540c\u7684\u6709\u4e24\u70b9\uff1a\n\n1. \u8ba1\u7b97\u5206\u5c42\u56fe\u65f6\uff0c\u8981\u5c06\u641c\u7d22\u6362\u6210 `SPFA`\uff0c\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u505a\uff1f\u56e0\u4e3a\u6211\u4eec\u6700\u540e\u662f\u9700\u8981\u4e00\u4e2a\u6700\u5c0f\u8d39\u7528\uff0c\u6240\u4ee5\u8981\u8dd1\u4e00\u904d\u6700\u77ed\u8def\uff0c\u56e0\u4e3a\u6709\u8d1f\u6743\u8fb9\uff0c\u6240\u4ee5\u9009\u62e9 `SPFA`\u3002\n\n2. \u5728\u8ba1\u7b97\u6700\u5927\u6d41\u65f6\uff0c\u904d\u5386\u8fc7\u7684\u70b9\u4e0d\u7528\u518d\u904d\u5386\uff0c\u518d\u6b21\u904d\u5386\u4f1a\u51fa\u9519\uff08\u8d39\u7528\u4f1a\u7b97\u91cd\uff09\u3002\n\n\u6ce8\u610f\uff1a\u5efa\u53cd\u5411\u8fb9\u65f6\uff0c\u5355\u4f4d\u8d39\u7528\u9700\u8981\u7528\u8d1f\u7684\u3002\n\n\u5176\u4f59\u7684\u5957\u4e0a\u6700\u5927\u6d41\u677f\u5b50\u5c31\u53ef\u4ee5\u4e86\u3002\n\n### Code\n```cpp\n#include<bits/stdc++.h>\n#define x first\n#define y second\n#pragma optimize(1)\n#pragma optimize(2)\n#pragma optimize(3,\"Ofast\",\"inline\")\nusing namespace std;\ntypedef pair<int,int> pii;\nconst int N=410,M=15005,INF=INT_MAX;\nint n,m;\nint s,t;\nint PKU=0;\nbool st[N];\nint h[N],idx=0,num;\nint dis[N],now[N];\nstruct Node {\n\tint w,c;\n\tint to,ne;\n} tr[M<<1];\ninline void add(int u,int v,int w,int c) {\n\ttr[idx].w=w,tr[idx].c=c,tr[idx].to=v,tr[idx].ne=h[u],h[u]=idx++;\n}\ninline bool SPFA() {\n\tdeque<int> q;\n\tq.push_back(s);\n\tmemset(st,false,sizeof st);\n\tst[s]=true;\n\tfor(register int i=1; i<=n; i++) dis[i]=INF,now[i]=h[i];\n\tdis[s]=0;\n\twhile(!q.empty()) {\n\t\tint u=q.front();\n\t\tq.pop_front();\n\t\tst[u]=false;\n\t\twhile(dis[u]*q.size()>num) {\n\t\t\tq.pop_front();\n\t\t\tq.push_back(u);\n\t\t\tu=q.front();\n\t\t}\n\t\tfor(register int i=h[u]; i!=-1; i=tr[i].ne) {\n\t\t\tint to=tr[i].to;\n\t\t\tif(!tr[i].w) continue;\n\t\t\tif(dis[to]>dis[u]+tr[i].c) {\n\t\t\t\tdis[to]=dis[u]+tr[i].c;\n\t\t\t\tif(!st[to]) st[to]=true,q.push_back(to);\n\t\t\t\tnum+=dis[to];\n\t\t\t}\n\t\t}\n\t}\n\treturn (dis[t]!=INF);\n}\ninline bool ss(){\n\tqueue<int> q; q.push(s); \n\tmemset(st,false,sizeof st); st[s]=true;\n\tfor(register int i=1;i<=n;i++) dis[i]=INF,now[i]=h[i]; dis[s]=0;\n\twhile(!q.empty()){\n\t\tint u=q.front(); q.pop(); st[u]=false;\n\t\tfor(register int i=h[u];i!=-1;i=tr[i].ne){\n\t\t\tint to=tr[i].to;\n\t\t\tif(!tr[i].w) continue;\n\t\t\tif(dis[to]>dis[u]+tr[i].c){\n\t\t\t\tdis[to]=dis[u]+tr[i].c;\n\t\t\t\tif(!st[to]) st[to]=true,q.push(to);\n\t\t\t}\n\t\t}\n\t} return (dis[t]!=INF);\n}\ninline int Dinic(int u,int sum) {\n\tif(u==t||sum==0) return sum;\n\tint ans=0;\n\tst[u]=true;\n\tfor(register int i=now[u]; i!=-1; i=tr[i].ne) {\n\t\tint to=tr[i].to;\n\t\tnow[u]=i;\n\t\tif(!tr[i].w) continue;\n\t\tif(!st[to]&&dis[to]==dis[u]+tr[i].c) {\n\t\t\tint x=Dinic(to,min(sum,tr[i].w));\n\t\t\tif(x==0) dis[to]=INF;\n\t\t\ttr[i].w-=x,tr[i^1].w+=x;\n\t\t\tans+=x,sum-=x,PKU+=x*tr[i].c;\n\t\t}\n\t\tif(!sum) break;\n\t}\n\treturn ans;\n}\ninline int dd(int u,int sum){\n\tint ans=0; \n\tif(u==t) return sum; st[u]=true;\n\tfor(register int i=now[u];i!=-1;i=tr[i].ne){\n\t\tint to=tr[i].to; now[u]=i;\n\t\tif(!tr[i].w) continue;\n\t\tif(!st[to]&&dis[to]==dis[u]+tr[i].c){\n\t\t\tint x=Dinic(to,min(sum,tr[i].w));\n\t\t\tif(x==0) dis[to]=INF;\n\t\t\ttr[i].w-=x,tr[i^1].w+=x;\n\t\t\tans+=x,sum-=x,PKU+=x*tr[i].c;\n\t\t\tif(!sum) break;\n\t\t}\n\t} return ans;\n}\nint main() {\n\tmemset(h,-1,sizeof h);\n\tscanf(\"%d%d\",&n,&m);\n\ts=1,t=n;\n\tif(n>=300) {\n\t\twhile(m--) {\n\t\t\tint u,v,w,c;\n\t\t\tscanf(\"%d%d%d%d\",&u,&v,&w,&c);\n\t\t\tadd(u,v,w,c),add(v,u,0,-c);\n\t\t}\n\t\tint ans=0;\n\t\twhile(SPFA()) memset(st,false,sizeof st),ans+=Dinic(s,INF);\n\t\tprintf(\"%d %d\\n\",ans,PKU);\n\t} else {\n\t\twhile(m--) {\n\t\t\tint u,v,w,c;\n\t\t\tscanf(\"%d%d%d%d\",&u,&v,&w,&c);\n\t\t\tadd(u,v,w,c),add(v,u,0,-c);\n\t\t}\n\t\tint ans=0;\n\t\twhile(ss()) memset(st,false,sizeof st),ans+=dd(s,INF);\n\t\tprintf(\"%d %d\\n\",ans,PKU);\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1684222461,
        "uid": 706523,
        "name": "zhengdongwen",
        "ccfLevel": 0,
        "title": "B3608 \u9898\u89e3"
    },
    {
        "content": "## \u7b97\u6cd5\u8bb2\u89e3\n\n\u8fd9\u9053\u9898**\u7565\u5fae\u5361\u5e38**\uff0c\u8bf7\u4f7f\u7528\u5feb\u8bfb\uff0cO2 \u4f18\u5316\u3002\n\n------------\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a\u6700\u5927\u6d41\u7b97\u6cd5\n\n\u666e\u901a\u7684\u6700\u5927\u6d41\u95ee\u9898\u5176\u5b9e\u4e5f\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u8d39\u7528\u6d41\u95ee\u9898\uff0c\u6bcf\u6761\u8fb9\u7684\u8d39\u7528\u4e3a $1$\u3002\u6211\u4eec\u77e5\u9053 Dinic \u7b97\u6cd5\u662f\u6839\u636e BFS \u5206\u5c42\u56fe\u591a\u8def\u589e\u5e7f\u7684\uff0c\u90a3\u4e48\u8d39\u7528\u6709\u4e86\u8fb9\u6743\u540e\uff0c\u5f88\u81ea\u7136\u7684\u6211\u4eec\u5c31\u4f1a\u60f3\u5230\u6700\u77ed\u8def + \u589e\u5e7f\u8def\u3002\n\n\u53ef\u4ee5\u8bc1\u660e\uff0c\u6211\u4eec\u6bcf\u6b21\u5c31\u8d2a\u5fc3\u7684\u627e\u5230\u8def\u5f84\u6700\u77ed\u7684\u8def\u5f84\u8fdb\u884c\u589e\u5e7f\uff0c\u76f4\u5230\u56fe\u4e0d\u8fde\u901a\uff0c\u5c31\u80fd\u627e\u5230\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n\u7531\u4e8e\u53cd\u6094\u8fb9\u7684\u5b58\u5728\uff0c\u5982\u679c\u5bf9\u8fb9\u6743\u4e0d\u8fdb\u884c\u8f6c\u5316\uff0c\u5c31\u4f1a\u51fa\u73b0\u8d1f\u6743\u8fb9\uff0c\u6240\u4ee5\u6211\u4eec\u65e0\u6cd5\u4f7f\u7528 Dijkstra \u7b97\u6cd5\uff0c\u53ea\u80fd\u9000\u800c\u4f7f\u7528 SPFA \u7b97\u6cd5\u3002\n\n- \u5efa\u56fe\u7ec6\u8282\uff1a\u53cd\u6094\u8fb9\u7684\u8d39\u7528\u662f\u6b63\u5411\u8fb9\u7684\u76f8\u53cd\u6570\u3002\n\n## \u4ee3\u7801\u6f14\u793a\n- EK \u7248\u672c\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++) \nconst int mxn = 5010, mxm = 50010;\nint n, m, S, T, ecnt = 1, Maxflow, Mincost;\nint head[mxn], pre[mxn], dis[mxn], lst[mxn], mflow[mxn];\nstruct edge\n{\n\tint t, nxt, f, cost;\n}e[mxm << 1];\ninline int read()\n{\n    char c=getchar(); int x=0;\n    while(c<'0'||c>'9') {c=getchar();}\n    while(c>='0'&&c<= '9') { x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n    return x;\n}\nvoid add(int f, int t, int fl, int cost)\n{\n\te[++ecnt] = (edge){t, head[f], fl, cost};\n\thead[f] = ecnt;\n}\nvoid addedge(int f, int t, int fl, int cost)\n{\n\tadd(f, t, fl, cost);\n\tadd(t, f, 0, -cost);\t\n}\nbool inq[mxn];\nbool spfa()\n{\n\tqueue <int> q;\n\twhile (!q.empty()) q.pop();\n\tmemset(mflow, 0x3f, sizeof(mflow));\n\tmemset(dis, 0x3f, sizeof(dis));\n\tq.push(S); dis[S] = 0; pre[T] = -1;\n\twhile (!q.empty())\n\t{\n\t\tint node = q.front(); q.pop();\n\t\tinq[node] = 0;\n\t\tfor (int i = head[node]; i; i = e[i].nxt)\n\t\t{\n\t\t\tint to = e[i].t;\n\t\t\tif (e[i].f > 0 && dis[to] > dis[node] + e[i].cost)\n\t\t\t{\n\t\t\t\tdis[to] = dis[node] + e[i].cost;\n\t\t\t\tpre[to] = node;\n\t\t\t\tlst[to] = i;\n\t\t\t\tmflow[to] = min(mflow[node], e[i].f);\n\t\t\t\tif (!inq[to])\n\t\t\t\t{\n\t\t\t\t\tinq[to] = 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[T] != -1;\n}\nvoid Flow()\n{\n\twhile (spfa())\n\t{\n\t\tint node = T;\n\t\tMaxflow += mflow[T];\n\t\tMincost += mflow[T] * dis[T];\n\t\twhile (node != S)\n\t\t{\n\t\t\te[lst[node]].f -= mflow[T];\n\t\t\te[lst[node] ^ 1].f += mflow[T];\n\t\t\tnode = pre[node]; \n\t\t}\n\t}\n}\nint main()\n{\n\tn = read(); m = read();\n\tS = 1; T = n;\n\tfor (int i = 1, u, v, w, c; i <= m; ++i)\n\t{\n\t\tu = read(); v = read(); w = read(); c = read();\n\t\taddedge(u, v, w, c);\n\t}\n\tFlow();\n\tprintf(\"%d %d\", Maxflow, Mincost);\n\treturn 0;\n}\n```\n- Dinic \u7248\u672c\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst int mxn = 5010, mxm = 50010;\nint n, m, S, T, ecnt = 1, Maxflow, Mincost;\nint head[mxn], dis[mxn], lst[mxn];\nstruct edge\n{\n\tint t, nxt, f, cost;\n}e[mxm << 1];\ninline int read()\n{\n    char c=getchar(); int x=0;\n    while(c<'0'||c>'9') {c=getchar();}\n    while(c>='0'&&c<= '9') { x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n    return x;\n}\nvoid add(int f, int t, int fl, int cost)\n{\n\te[++ecnt] = (edge){t, head[f], fl, cost};\n\thead[f] = ecnt;\n}\nvoid addedge(int f, int t, int fl, int cost)\n{\n\tadd(f, t, fl, cost);\n\tadd(t, f, 0, -cost);\t\n}\nbool inq[mxn];\nbool spfa()\n{\n\tqueue <int> q;\n\twhile (!q.empty()) q.pop();\n\tmemset(dis, 0x3f, sizeof(dis));\n\tmemset(inq, 0, sizeof(inq));\n\tq.push(S); dis[S] = 0;\n\twhile (!q.empty())\n\t{\n\t\tint node = q.front(); q.pop();\n\t\tinq[node] = 0;\n\t\tlst[node] = head[node]; \n\t\tfor (int i = head[node]; i; i = e[i].nxt)\n\t\t{\n\t\t\tint to = e[i].t;\n\t\t\tif (e[i].f > 0 && dis[to] > dis[node] + e[i].cost)\n\t\t\t{\n\t\t\t\tdis[to] = dis[node] + e[i].cost;\n\t\t\t\tif (!inq[to])\n\t\t\t\t{\n\t\t\t\t\tinq[to] = 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T] != 0x3f3f3f3f;\n}\nint Dinic(int node, int Limit)\n{\n\tif (node == T) return Limit;\n\tint tmp = Limit;\n\tinq[node] = 1;\n\tfor (int &i = lst[node]; i; i = e[i].nxt)\n\t{\n\t\tint to = e[i].t;\n\t\tif (dis[node] + e[i].cost == dis[to] && e[i].f && inq[to] == 0)\n\t\t{\n\t\t\tint a = Dinic(to, min(tmp, e[i].f));\n\t\t\te[i].f -= a;\n\t\t\te[i ^ 1].f += a;\n\t\t\ttmp -= a;\n\t\t\tMincost += a * e[i].cost;\n\t\t\tif (tmp == 0) return Limit;\n\t\t}\n\t}\n\tinq[node] = 0;\n\treturn Limit - tmp;\n}\nvoid Flow()\n{\n\twhile (spfa()) Maxflow += Dinic(S, 1e9);\n}\nint main()\n{\n\tn = read(); m = read();// S = read(); T = read();\n\tS = 1; T = n;\n\tfor (int i = 1, u, v, w, c; i <= m; ++i)\n\t{\n\t\tu = read(); v = read(); w = read(); c = read();\n\t\taddedge(u, v, w, c);\n\t}\n\tFlow();\n\tprintf(\"%d %d\", Maxflow, Mincost);\n\treturn 0;\n}\n```\n",
        "postTime": 1671257548,
        "uid": 425694,
        "name": "\u90d1\u671d\u66e6zzx",
        "ccfLevel": 6,
        "title": "\u3010\u6a21\u677f\u3011\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u9898\u89e3 B3608"
    }
]