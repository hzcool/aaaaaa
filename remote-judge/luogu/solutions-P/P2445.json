[
    {
        "content": "\u4e0d\u5f97\u4e0d\u8bf4\u6d1b\u8c37\u7684\u7ba1\u7406\u6548\u7387\u5b9e\u5728\u662f\u9ad8\uff0c\u4e00\u5929\u5c31\u628aspj\u52a0\u4e0a\u4e86\uff0c\u5148\u8d5e\u4e00\u4e2a\u3002\n\n\u8fd9\u9053\u9898\u76ee\u5927\u610f\u662f\u7ed9\u51fa\u52a8\u7269\u7684\u901f\u5ea6\u548c\u67d0\u4e2a\u65f6\u523b\u7684\u4f4d\u7f6e\uff0c\u628a\u52a8\u7269\u548c\u7b3c\u5b50\u914d\u5bf9\u3002\n\n\u9996\u5148\u53ef\u4ee5\u770b\u51fa\u6240\u7ed9\u51fa\u7684\u67d0\u4e2a\u65f6\u523b\u67d0\u52a8\u7269\u5728\u4f55\u5904\u7684\u4fe1\u606f\u4e2d\u6709\u4e00\u4e9b\u662f\u591a\u4f59\u7684\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u52a8\u7269\u6765\u8bf4\uff0c\u53ea\u9700\u8981\u4fdd\u7559\u5b83\u88ab\u770b\u5230\u7684\u65f6\u95f4\u6700\u65e9\u7684\u4fe1\u606f\u5373\u53ef\uff0c\u56e0\u4e3a\u5982\u679c\u6211\u4eec\u77e5\u9053\u67d0\u52a8\u7269\u5728T1\u65f6\u523b\u5728(x1,y1),\u5728T2\u65f6\u523b\u5728(x2,y2)(T1<T2),\u4e14\u8fd9\u4e24\u4e2a\u4fe1\u606f\u90fd\u5408\u6cd5\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u8981\u77e5\u9053\u4e86\u7b2c\u4e00\u6761\u4fe1\u606f\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u51fa\u5728T2\u65f6\u523b\u52a8\u7269\u53ef\u80fd\u5728(x2,y2)\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u52a8\u7269\u6240\u4fdd\u7559\u4e0b\u6765\u7684\u4fe1\u606f\u8fdb\u884c\u4e00\u6b21\u641c\u7d22\uff0c\u786e\u5b9a\u8fd9\u4e2a\u52a8\u7269\u53ef\u80fd\u662f\u4ece\u54ea\u4e2a\u7b3c\u5b50\u91cc\u51fa\u6765\u7684\uff0c\u5177\u4f53\u65b9\u5f0f\u662f\u4ece\u8fd9\u4e2a\u70b9\u5f00\u59cb\u5f80\u5916\u8fdb\u884cfloodfill\uff0c\u5982\u679c\u5230\u8fbe\u7b3c\u5b50\u7684\u683c\u5b50\u6570<=\u52a8\u7269\u7684\u901f\u5ea6\\*\u65f6\u95f4\uff0c\u5c31\u8ba4\u4e3a\u8fd9\u4e2a\u52a8\u7269\u53ef\u80fd\u662f\u4ece\u8fd9\u4e2a\u7b3c\u5b50\u91cc\u51fa\u6765\u7684\u3002\n\n\u5982\u679c\u4e00\u4e2a\u52a8\u7269\u6ca1\u6709\u88ab\u89c2\u6d4b\u5230\uff0c\u90a3\u4e48\u8ba4\u4e3a\u5b83\u6709\u53ef\u80fd\u662f\u4ece\u4efb\u4f55\u4e00\u4e2a\u7b3c\u5b50\u91cc\u51fa\u6765\u7684\u3002\n\n\u7136\u540e\u5c31\u53d8\u6210\u4e86\u6bcf\u4e2a\u52a8\u7269\u6709\u4e00\u4e2a\u5bf9\u5e94\u7684\u7b3c\u5b50\u96c6\u5408\uff0c\u7136\u540e\u8fdb\u884c\u4e00\u6b21\u6700\u5927\u5339\u914d\u3002\n\n\u6700\u5927\u5339\u914d\u7684\u7b97\u6cd5\u53ef\u4ee5\u91c7\u7528\u6700\u5927\u6d41\u6216\u8005\u5308\u7259\u5229\u7b97\u6cd5\u3002\n\n\u9898\u76ee\u4fdd\u8bc1\u6709\u89e3\uff0c\u6240\u4ee5\u5728\u5339\u914d\u5b8c\u6210\u540e\u8f93\u51fa\u5bf9\u5e94\u65b9\u6848\u5373\u53ef\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nstruct st{\n    int t,x,y;\n}animal[205];\nconst int inf=1e9+7;\n#define min(a,b) (a<b?a:b)\nint maps[10001],cage[10001],p,n,qu,ways[10001],v[205];\nchar ch[102];\nint num[10001],exist[205],nums,cagenum[1001];\nint head[505],nxt[80005],point[80005],remain[80005],sum;\nint nowedge[505],deep[505];\nint a,b,c,d;\nqueue<int>q;\nvoid dfsmap(int x,int y,int d)\n{\n    if(x>n||x<1||y>n||y<1) return;\n    if(maps[x*n-n+y]==-1) return;\n    if(ways[x*n-n+y]<=d) return;\n    ways[x*n-n+y]=d;\n    dfsmap(x+1,y,d+1);\n    dfsmap(x-1,y,d+1);\n    dfsmap(x,y+1,d+1);\n    dfsmap(x,y-1,d+1);\n}\nvoid divide()\n{\n    sum=-1;\n    memset(head,-1,sizeof(head));\n    memset(nxt,-1,sizeof(nxt));\n    nums=p;\n    for(int i=1;i<=n*n;i++)\n    if(cage[i])\n    num[i]=++nums,cagenum[nums]=i;\n}\nvoid add(int x,int y,int flow)\n{\n    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;\n    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;\n}\nvoid addall(int ani)\n{\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n    {\n        int now=i*n-n+j;\n        if(cage[now]) add(ani,num[now],1);\n    }\n} \nvoid search(int times,int x,int y,int ani)\n{\n    memset(ways,127,sizeof(ways));\n    dfsmap(x,y,0);\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n    {\n        int now=i*n-n+j;\n        if(cage[now]&&ways[now]<times)\n        add(ani,num[now],1);\n    }\n}\nvoid setup()\n{\n    for(int i=1;i<=p;i++)\n    add(0,i,1);\n    for(int i=p+1;i<=nums;i++)\n    add(i,nums+1,cage[cagenum[i]]);\n}\nbool bfs(int s,int t)\n{\n    for(int i=0;i<=nums;i++)\n    nowedge[i]=head[i];\n    memset(deep,127,sizeof(deep));\n    deep[s]=0;\n    q.push(s);\n    while(!q.empty())\n    {\n        int now=q.front();q.pop();\n        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])\n        {\n            int u=point[tmp];\n            if(remain[tmp]&&deep[u]>inf)\n            {\n                deep[u]=deep[now]+1;\n                q.push(u);\n            }\n        }\n    }\n    return deep[t]<inf;\n}\nint dfs(int x,int t,int limit)\n{\n    if(x==t||!limit) return limit;\n    int flow=0,f;\n    for(int tmp=nowedge[x];tmp!=-1;tmp=nxt[tmp])\n    {\n        nowedge[x]=tmp;\n        if((deep[point[tmp]]==deep[x]+1)&&(f=dfs(point[tmp],t,min(limit,remain[tmp]))))\n        {\n            flow+=f;\n            limit-=f;\n            remain[tmp]-=f;\n            remain[tmp^1]+=f;\n        }\n    }\n    return flow;\n}\nvoid dinic(int s,int t)\n{\n    while(bfs(s,t))\n    dfs(s,t,inf);\n}\nvoid getans()\n{\n    dinic(0,nums+1);\n    for(int i=1;i<=p;i++)\n    {\n        printf(\"%d \",i);\n        for(int tmp=head[i];tmp!=-1;tmp=nxt[tmp])\n        {\n            if(point[tmp]&&(remain[tmp]==0))\n            {\n                int now=cagenum[point[tmp]],nowx,nowy;\n                nowx=now/n;\n                if(now%n==0) nowy=n;\n                else nowx++,nowy=now%n;\n                printf(\"%d %d\\n\",nowx,nowy);\n                break;\n            }\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%s\",ch);\n        for(int j=0;j<n;j++)\n        if(ch[j]=='*') maps[i*n-n+j+1]=-1;    \n    }\n    scanf(\"%d\",&p);\n    for(int i=1;i<=p;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        cage[a*n-n+b]++;\n    }\n    divide();\n    for(int i=1;i<=p;i++)\n    scanf(\"%d\",&v[i]);\n    memset(animal,127,sizeof(animal));\n    scanf(\"%d\",&qu);\n    for(int i=1;i<=qu;i++)\n    {\n        scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n        if(a>=animal[d].t) continue;\n        animal[d]=(st){a,b,c};\n        exist[d]=1;\n    }\n    for(int i=1;i<=p;i++)\n    if(exist[i]) \n    search(animal[i].t*v[i],animal[i].x,animal[i].y,i);\n    else\n    addall(i);\n    setup();\n    getans(); \n}\n```",
        "postTime": 1495634302,
        "uid": 17828,
        "name": "revenger",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2445 \u3010[SDOI2005]\u52a8\u7269\u56ed\u3011"
    },
    {
        "content": "\u7b2c\u4e00\u773c\u770b\u5230\u8fd9\u9898\u7684\u601d\u8def\u662f$bfs+dfs$\n\n$bfs$\u5efa\u7acb\u52a8\u7269\u4e0e\u7b3c\u5b50\u7684\u5173\u7cfb\n\n$dfs$\u8fdb\u884c\u4e00\u4e00\u5339\u914d\n\n\u7528$well$\u4fdd\u5b58\u8fd9\u4e2a\u70b9\u7684\u72b6\u6001\uff08\u662f\u5426\u53ef\u8d70\uff0c\u662f\u5426\u6709\u7b3c\u5b50\uff0c\u6709\u51e0\u4e2a\u7b3c\u5b50\uff09\n\n\u6ce8\u610f\u7b3c\u5b50\u53ef\u4ee5\u5728\u540c\u4e00\u5730\u70b9\n\n\u5982\u679c\u4e00\u4e2a\u52a8\u7269\u6ca1\u6709\u88ab\u89c2\u6d4b\u5230\uff0c\u90a3\u4e48\u5b83\u53ef\u80fd\u662f\u4ece\u4efb\u4f55\u4e00\u4e2a\u7b3c\u5b50\u91cc\u51fa\u6765\u7684\n\n\u6bcf\u4e2a\u52a8\u7269\u90fd$bfs$\u904d\u5386\u4e00\u904d\n\n\u7528f\u6570\u7ec4\u4fdd\u5b58\u5b83\u662f\u5426\u53ef\u4ee5\u5230\u8fbe\u8fd9\u4e2a\u70b9\u4e0a\u7684\u7b3c\u5b50\n\n\u9650\u5236\u8ddd\u79bb\u4e3a\u89c2\u6d4b\u65f6\u95f4$\\times$\u901f\u5ea6\n\n\u5efa\u7acb\u597d\u5173\u7cfb\u540e\uff0c\u5c31\u53ef\u4ee5\u641c\u7d22\u4e86\n\n\u641c\u5230\u4e00\u7ec4\u89e3\u5c31\u8f93\u51fa\u5e76\u7ed3\u675f\u7a0b\u5e8f\n\n```cpp\n# include<iostream>\n# include<cstdio>\n# include<cstdlib>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fo1(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nstruct q{\n    int row,col;\n}cage[101];\nstruct u{\n    int t,rr,cc,j;\n}see[101];\nint n,p,r,num;\nint animal[101],ans[101];\nint mv1[4]={1,-1,0,0},mv2[4]={0,0,1,-1};\nint nu[101][101];\nint well[101][101][2][3],room[100001][4];\nbool use[101],ff[101];\nbool f[101][101];\nbool vis[101][101][101];\nint read()\n{\n    char c=getchar();\n    int x=0;\n    while(c<'0'||c>'9') c=getchar();\n    while(c>='0'&&c<='9') \n    {\n        x=x*10+c-'0';\n        c=getchar();\n    }\n    return x;\n}\nvoid init()\n{\n    n=read();\n    fo(i,1,n)\n      {\n          string ch;\n          cin>>ch;\n          fo(j,1,n)\n          well[i][j][0][0]=(ch[j-1]=='*')?1:0;\n      }\n    p=read();\n    fo(i,1,p)\n      {\n          cage[i].row=read();\n        cage[i].col=read();\n          well[cage[i].row][cage[i].col][1][++nu[cage[i].row][cage[i].col]]=i,well[cage[i].row][cage[i].col][0][0]=2;\n        }\n    fo(i,1,p)\n     animal[i]=read();\n    r=read();\n    fo(i,1,r)\n      {\n          num++;\n          see[num].t=read();\n        see[num].rr=read();\n        see[num].cc=read();\n        see[num].j=read();\n          if(ff[see[num].j]) num--;\n          else ff[see[num].j]=1;\n      }\n}\nvoid coutt()\n{\n    fo(i,1,p)\n      printf(\"%d %d %d\\n\",i,cage[ans[i]].row,cage[ans[i]].col);\n}\nvoid find_home(int x)\n{\n    if(x>p)\n    {\n        coutt();\n        exit(0);\n    }\n    fo1(j,p,1)\n      if(f[x][j]&&!use[j])\n      {\n          ans[x]=j;\n          use[j]=1;\n          find_home(x+1);\n          use[j]=0;\n      }  \n}\nvoid bfs()\n{\n    fo(i,1,p)\n      if(!ff[i])\n      {\n          for(int j=1;j<=p;j++)\n            f[i][j]=1;\n      }\n    fo(i,1,num)\n      {\n          room[1][1]=see[i].rr;\n          room[1][2]=see[i].cc;\n          int l=0,rr=1,houhou=animal[see[i].j]*see[i].t;\n          while(l<rr)\n          {\n              l++;\n              if(room[l][3]>=houhou)\n              continue;\n              fo(j,0,3)\n                {\n                    int x=room[l][1]+mv1[j],y=room[l][2]+mv2[j];\n                    if(x>=1&&x<=n&&y>=1&&y<=n&&!vis[see[i].j][x][y]&&well[x][y][0][0]!=1)\n                    {\n                        vis[see[i].j][x][y]=1;\n                        room[++rr][1]=x;\n                        room[rr][2]=y;\n                        room[rr][3]=room[l][3]+1;\n                        if(well[x][y][0][0]==2)\n                        fo(kk,1,nu[x][y])\n                          f[see[i].j][well[x][y][1][kk]]=1;\n                }\n              }\n        }\n      }\n    find_home(1);\n}\nint main()\n{\n    init();\n    bfs();\n    return 0;\n}\n```",
        "postTime": 1509360942,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2445 \u3010[SDOI2005]\u52a8\u7269\u56ed\u3011"
    }
]