[
    {
        "content": "\u4e2a\u4eba\u8ba4\u4e3a\u6bd4\u5176\u4ed6\u9898\u89e3\u5199\u7684\u90fd\u66f4\u8be6\u7ec6\u66f4\u660e\u767d/kel\n\n\u8003\u8651\u5b57\u7b26\u4e32 $s$ \u51fa\u73b0\u7684\u6b21\u6570\uff0c\u5728SAM\u4e2d\uff0c\u4e00\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u67d0\u4e2a\u5b50\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u5c31\u662f\u5b83\u7684\u5b50\u6811\u7684\u51fa\u73b0\u6b21\u6570\u548c\uff0c\u56e0\u4e3a\u957f\u7684\u540e\u7f00\u4e0e\u77ed\u7684\u540e\u7f00\u4e4b\u95f4\u4fe1\u606f\u4e0d\u5171\u4eab\uff0c\u6240\u4ee5\u4fee\u6539\u64cd\u4f5c\u672c\u8d28\u4e0a\u662f\u5728\u8fdb\u884c $parent$ \u6811\u4e0a\u7684\u94fe\u52a0\u3002\n\n\u8003\u8651\u4e00\u79cd\u795e\u5947\u7684\u5199\u6cd5\u3002\u6bcf\u6b21\u5bf9\u4e8e\u65b0\u5efa\u7684\u8282\u70b9 $np$ \uff0c\u4ed6\u7684\u8d21\u732e\u5e94\u8be5\u662f $parent$ \u6811\u4e0a $1\\sim np$ \u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u3002\u4e8e\u662f\u8003\u8651\u5148 `merge(1, np)` \uff0c\u628a $np$ \u7ed9 `splay` \u4e0a\u53bb\u4e4b\u540e\u5185\u90e8\u5c31\u53d8\u6210\u4e86\u4e00\u68f5\u4ee5 $np$ \u4e3a\u6839\u7684\u4e00\u6761\u94fe\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4e0d\u7528\u8003\u8651\u94fe\u52a0\uff0c\u76f4\u63a5\u5728 $np$ \u5904\u6253\u6807\u8bb0\u5373\u53ef\u3002\n\n\u4f3c\u4e4e\u67e5\u8be2\u64cd\u4f5c\u66f4\u4e3a\u795e\u5947\u3002\u56e0\u4e3a\u67e5\u8be2\u7684\u65f6\u5019\u53ea\u9700\u8981\u5bf9\u4e8e\u8d70\u5230\u7684\u4e00\u4e2a\u70b9 $x$ \uff0c\u76f4\u63a5\u628a\u4ed6 `splay` \u6389\u5c31\u53ef\u4ee5\u7ef4\u62a4\u4fe1\u606f\u3002\u770b\u4e0a\u53bb\u4f3c\u4e4e\u4e0d\u662f\u5f88\u5bf9\uff0c\u56e0\u4e3a\u5bf9 $x$ \u4ea7\u751f\u8d21\u732e\u7684\u662f\u4e00\u9897\u5b50\u6811\u800c\u4e0d\u662f\u4e00\u6761\u94fe\u3002\u4f46\u8fd9\u6837\u505a\u5176\u5b9e\u6709\u4ed6\u72ec\u7279\u7684\u6b63\u786e\u6027\u4fdd\u8bc1\uff0c\u5373\u6bcf\u4e2a\u70b9\u90fd\u5b58\u5728\u4e14\u4ec5\u5b58\u5728\u4e8e\u4e00\u68f5 `splay` \uff0c\u6362 `splay` \u7684\u65f6\u5019\u52bf\u5fc5\u8981 `access`\uff0c\u800c `access` \u65f6\u672c\u8d28\u4e0a\u5c31\u5df2\u7ecf\u628a\u539f\u6765\u7684\u6807\u8bb0\u7ed9\u4e0b\u653e\u5e72\u51c0\u4e86\uff0c\u6240\u4ee5\u6bcf\u6b21\u53ea\u6709\u53ef\u80fd\u662f\u5f53\u524d\u7684 `splay` \u8fd8\u6709\u4fe1\u606f\u6ca1\u6709\u7ef4\u62a4\u6e05\u695a\u3002\u4e5f\u5c31\u662f\u6bcf\u6b21\u53ea\u9700\u8981\u7ba1\u4e00\u6761\u94fe\uff0c\u5269\u4e0b\u7684\u94fe\u7684\u6807\u8bb0\u5df2\u7ecf\u6e05\u5b8c\u4e86\u3002\u8fd9\u6837\u5c31\u53ea\u9700\u8981 `splay` \u4e00\u4e0b\u5373\u53ef\u3002\n\n\u5199\u7684\u65f6\u5019\uff0c\u4e3a\u4e86\u5361\u5e38\u53d1\u73b0\u4e86\u4e2a\u66f4\u795e\u5947\u7684\u5730\u65b9\uff0c\u5c31\u662f\u5728SAM\u91cc\u9762\u62a0\u70b9\u63d2\u5b50\u6811/\u63d2\u70b9\u8fd9\u4e24\u4e2a\u64cd\u4f5c\uff0c\u7531\u4e8e\u90fd\u4fdd\u8bc1\u4e86\u7236\u4eb2\u4e0d\u5b58\u5728\uff0c\u6240\u4ee5 `Link` \u8fd9\u4e2a\u64cd\u4f5c\uff0c\u672c\u8d28\u4e0a\u662f\u4e0d\u9700\u8981 `make_root` \u7684\uff0c\u5b9e\u6d4b\u8fd9\u6837\u5c31\u4f1a\u5feb\u5f88\u591a\u5f88\u591a\u3002\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n\n#define il inline\n#define fa(x) t[x].fa\n#define rv(x) t[x].rev\n#define vl(x) t[x].val\n#define tg(x) t[x].tag\n#define lc(x) t[x].son[0]\n#define rc(x) t[x].son[1]\n\nusing namespace std ;\n\nconst int N = 1000010 ;\nconst int M = 1500010 ;\n\nstruct LCT{\n    int fa ;\n    int rev ;\n    int val ;\n    int tag ;\n    int son[2] ;\n}t[M] ;\nint n ;\nint m ;\nint tp ;\nint len ;\nint ans ;\nint res ;\nchar s[N] ;\nchar o[N] ;\nint stk[M] ;\n\nbool nroot(int x){\n    return ((lc(fa(x)) == x) || (rc(fa(x)) == x)) ;\n}\nvoid reverse(int x){\n    rv(x) ^= 1 ; swap(lc(x), rc(x)) ;\n}\nvoid _down(int x){\n    if (rv(x)){\n        rv(x) = 0 ;\n        if (lc(x)) reverse(lc(x)) ;\n        if (rc(x)) reverse(rc(x)) ;\n    }\n    if (tg(x)){\n        if (lc(x)) vl(lc(x)) += tg(x), tg(lc(x)) += tg(x) ;\n        if (rc(x)) vl(rc(x)) += tg(x), tg(rc(x)) += tg(x) ;\n        tg(x) = 0 ;\n    }\n}\nvoid rotate(int x){\n    bool w = x == rc(fa(x)) ;\n    int f1 = fa(x), f2 = fa(f1) ;\n    if (nroot(f1))\n        t[f2].son[f1 == rc(f2)] = x ;\n    t[f1].son[w] = t[x].son[w ^ 1] ;\n    fa( t[x].son[w ^ 1] ) = f1 ;\n    fa(x) = f2 ; fa(f1) = x ;\n    t[x].son[w ^ 1] = f1 ;\n}\nvoid splay(int x){\n    int y = x ;\n    stk[++ tp] = y ;\n    while (nroot(y))\n        stk[++ tp] = (y = fa(y)) ;\n    while (tp) _down(stk[tp --]) ;\n    while (nroot(x)){\n        int f1 = fa(x) ;\n        int f2 = fa(f1) ;\n        if (nroot(f1)){\n            if ((rc(f1) == x) == (rc(f2) == f1))\n                rotate(f1) ; else rotate(x) ;\n        }\n        rotate(x) ;\n    }\n}\nil void access(int x){\n    int y = 0 ;\n    for ( ; x ; x = fa(y = x))\n        splay(x), rc(x) = y ;\n}\nil void make_root(int x){\n    access(x) ;\n    splay(x) ; reverse(x) ;\n}\nil int find_root(int x){\n    access(x) ; splay(x) ;\n    while(lc(x)) x = lc(x) ;\n    return x ;\n}\nil void merge(int x, int y){\n    make_root(x) ;\n    access(y) ; splay(y) ;\n}\nil void link(int x, int y){\n    fa(x) = y ;\n}\nil void cut(int x, int y){\n    merge(x, y) ;\n    fa(x) = t[y].son[0] = 0 ;\n}\nil void Input(int mk) {\n    len = strlen(s) ;\n    for (int j = 0 ; j < len ; ++ j)\n        mk = (mk * 131 + j) % len, swap(s[j], s[mk]) ;\n}\nstruct SAM{\n    int size ;\n    int last ;\n    int len[M] ;\n    int fal[M] ;\n    int trans[M][2] ;\n    void Init(){\n        last = ++ size ;\n    }\n    void Ins(int x){\n        int np = ++ size ;\n        int q, nq, p = last ;\n        len[last = np] = len[p] + 1 ;\n        while (p && !trans[p][x])\n            trans[p][x] = np, p = fal[p] ;\n        if (!p){\n            fal[np] = 1 ;\n            link(np, 1), merge(1, np) ;\n            vl(np) ++, tg(np) ++ ; return ;\n        }\n        q = trans[p][x] ;\n        if (len[q] == len[p] + 1){\n            fal[np] = q ;\n            link(np, q), merge(1, np) ;\n            vl(np) ++, tg(np) ++ ; return ;\n        }\n        nq = ++ size ;\n        cut(fal[q], q) ;\n        fal[nq] = fal[q] ;\n        link (q, nq) ;\n        link (np, nq) ;\n        link (nq, fal[q]) ;\n        len[nq] = len[p] + 1 ;\n        fal[q] = fal[np] = nq ;\n        splay(q) ; vl(nq) = vl(q) ;\n        memcpy(trans[nq], trans[q], 8) ;\n        while (p && trans[p][x] == q)\n            trans[p][x] = nq, p = fal[p] ;\n        merge(1, np), vl(np) ++, tg(np) ++ ;\n    }\n}S ;\nint main(){\n    cin >> m ;\n    scanf(\"%s\", s + 1) ;\n    len = strlen(s + 1) ; S.Init() ;\n    for (int i = 1 ; i <= len ; ++ i) S.Ins(s[i] - 'A') ;\n    while (m --){\n        scanf(\"%s\", o + 1) ;\n        scanf(\"%s\", s), Input(ans) ;\n        if (o[1] == 'A'){\n            for (int i = 0 ; i < len ; ++ i)\n                S.Ins(s[i] - 'A') ; //, cout << i << endl ;\n        }\n        else{\n            int rt = 1 ;\n            for (int i = 0 ; i < len ; ++ i){\n                rt = S.trans[rt][s[i] - 'A'] ;\n                if (!rt) break ;\n            }\n            if (!rt) res = 0 ;\n            else splay(rt), res = vl(rt) ;\n            printf(\"%d\\n\", res) ; ans = ans ^ res ;\n        }\n    }\n    return 0 ;\n}\n```\n\n\n",
        "postTime": 1582249325,
        "uid": 28313,
        "name": "\u768e\u6708\u534a\u6d12\u82b1",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "##  \u3010SAM & LCT\u3011\u3010P5212\u3011 SubString\n\n### Description\n\n\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 $s$\uff0c\u8981\u6c42\u652f\u6301\u52a8\u6001\u5728 $s$ \u540e\u589e\u52a0\u5b57\u7b26\u548c\u67e5\u8be2\u67d0\u4e32 $t$ \u7684\u51fa\u73b0\u6b21\u6570\uff0c\u5f3a\u5236\u5728\u7ebf\u3002\n\n$s$ \u6700\u7ec8\u957f\u5ea6\u4e0d\u8d85\u8fc7 $6 \\times 10^5$\u3002\u8be2\u95ee\u4e32\u957f\u5ea6\u4e4b\u548c\u4e0d\u8d85\u8fc7 $6 \\times 10^3$\u3002\n\n### Analysis\n\n\u8003\u8651\u5bf9 $s$ \u5efa\u51fa SAM\uff0c\u5219\u67e5\u8be2\u65f6\u628a\u67e5\u8be2\u4e32\u653e\u5728 SAM \u4e0a\u8dd1\uff0c\u6c42\u7ec8\u6b62\u8282\u70b9\u7684\u5728 parent \u6811\u4e0a\u7684 right \u96c6\u5408\u5927\u5c0f\u3002\n\n\u5f53\u52a8\u6001\u589e\u52a0\u5b57\u7b26\u65f6\uff0c\u9700\u8981\u5728 parent \u6811\u4e0a\u52a0\u8fb9\u3001\u5220\u8fb9\uff0c\u67e5\u8be2\u65f6\u9700\u8981\u67e5\u8be2\u5b50\u6811\u548c\uff0c\u53ef\u4ee5\u7528 LCT \u7ef4\u62a4\u4e0a\u8ff0\u64cd\u4f5c\u3002\n\n\u5176\u4ed6\u9898\u89e3\u90fd\u662f\u5728\u52a0\u5165\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u5bf9\u5176\u5230\u6839\u7684\u94fe\u8fdb\u884c\u94fe\u52a0\uff0c\u4f46\u4e8b\u5b9e\u4e0a LCT \u662f\u53ef\u4ee5\u76f4\u63a5\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\u7684\u3002\u5177\u4f53\u7684\uff0c\u5bf9\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u5176\u865a\u5b50\u6811\u7684\u4fe1\u606f\u548c $si$\uff0c\u4ee5\u53ca\u5176\u5728 splay \u4e0a\u7684\u5b50\u6811\u4e2d\u7684\u8282\u70b9\u4ee5\u53ca\u5176\u865a\u5b50\u6811\u4fe1\u606f\u548c $sr$\u3002\u8bbe \u4e00\u4e2a\u8282\u70b9\u81ea\u8eab\u7684\u6743\u503c\u4e3a $k$\uff0c$si + sr + k= ss$\uff0c\u5219\u4e0a\u8ff0\u5173\u7cfb\u53ef\u4ee5\u8868\u793a\u4e3a\n\n$$si_u = \\sum\\limits_{v \\not \\in \\operatorname{children}(u)}^{\\operatorname{fa}(v) = u} ss_v$$\n\n$$sr_u = \\sum\\limits_{v \\in \\operatorname{subtree(u)}} si_v + k_v = \\sum\\limits_{v \\in \\operatorname{children(u)}} ss_v$$\n\n\u5176\u4e2d $\\operatorname{children}(u)$ \u8868\u793a $u$ \u5728 splay \u4e0a\u7684\u76f4\u63a5\u5b69\u5b50\uff0c$\\operatorname{fa}(v)$ \u8868\u793a $v$ \u7684\u7236\u8282\u70b9\uff0c$\\operatorname{subtree}(u)$ \u8868\u793a $u$ \u5728 splay \u4e0a\u7684\u5b50\u6811\u3002\n\n\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\uff0c\u5f53\u9700\u8981\u67e5\u8be2 $u$ \u5728 parent \u6811\u4e0a\u7684\u5b50\u6811\u4fe1\u606f\u65f6\uff0c\u53ea\u9700\u8981\u5728 LCT \u4e2d\u63d0\u53d6 $u$ \u5230\u6839\u7684\u8def\u5f84 `access(u)`\uff08\u8fd9\u91cc\u662f\u4e3a\u4e86\u4fdd\u8bc1 $u$ \u5728 parent \u6811\u4e0a\u7684\u5b50\u8282\u70b9\u5168\u90e8\u6210\u4e3a\u865a\u5b50\u6811\uff09\uff0c\u7136\u540e\u628a $u$ \u8f6c\u5230\u6839\uff0c\u6c42\u5176\u865a\u5b50\u6811\u4fe1\u606f\u548c+\u81ea\u8eab\u4fe1\u606f\u5373\u53ef\u3002\n\n\u5f53\u7136\uff0c\u5728\u8fd9\u91cc\u9700\u8981\u6ce8\u610f\u7684\u662f access \u64cd\u4f5c\u65f6\uff0c\u56e0\u4e3a\u4fee\u6539\u4e86\u5176\u865a\u5b9e\u5b50\u6811\uff0c\u6240\u4ee5\u8981\u4fee\u6539\u4e00\u4e0b\u5bf9\u5e94\u8282\u70b9\u7684 $si$ \u548c $sr$ \u503c\u3002\u540c\u6837\u5728\u52a0\u8fb9\u5220\u8fb9\u65f6\uff0c\u4e5f\u8981\u6ce8\u610f\u4fee\u6539\u7236\u8282\u70b9\u7684\u5bf9\u5e94\u865a\u5b50\u6811\u4fe1\u606f\u548c\u3002\n\n### Code\n\n\u7531\u4e8e\u8fd9\u662f\u4e00\u68f5\u6709\u6839\u6811\uff0c\u6211\u4eec\u63d2\u5165\u7684\u65f6\u5019\u4e0d\u9700\u8981 makeroot \u5c31\u80fd\u4fdd\u8bc1\u4e0d\u4f1a\u5b58\u5728\u73af\uff0c\u6240\u4ee5\u4e0d\u9700\u8981 makeroot \u64cd\u4f5c\uff0c\u5f53\u7136\u4e5f\u5c31\u4e0d\u9700\u8981 pushdown \u64cd\u4f5c\uff0c\u7801\u91cf\u76f8\u5bf9\u4e8e\u5176\u4ed6 LCT \u9898\u76ee\u8981\u5c0f\u4e0d\u5c11\u3002\n\n```cpp\nnamespace Fusu {\n\nconst int maxt = 2;\nconst int maxn = 1200005;\n\nvoid Init();\nvoid Solve();\n\nvoid Main() {\n  Init();\n  Solve();\n}\n\nstruct Node {\n  int len, si, sr, ss, sz;\n  Node *fail, *fa;\n  Node *trans[2], *ch[2];\n\n  void pushup() {\n    sr = 0;\n    for (auto u : ch) if (u != nullptr) {\n      sr += u->ss;\n    }\n    ss = si + sr + sz;\n  }\n  \n  inline int GetSon() { return fa->ch[1] == this; }\n  inline bool IsRot() { return (fa == nullptr) || (fa->ch[GetSon()] != this); }\n\n  void rotate(const int x) {\n    auto nt = ch[x];\n    ch[x] = nt->ch[x ^ 1];\n    nt->ch[x ^ 1] = this;\n    if (ch[x]) ch[x]->fa = this;\n    if (!IsRot()) fa->ch[GetSon()] = nt;\n    nt->fa = fa; fa = nt;\n    pushup(); nt->pushup();\n  }\n\n  void splay() {\n    while (!IsRot()) {\n      if (fa->IsRot()) {\n        fa->rotate(GetSon());\n      } else {\n        int k1 = GetSon(), k2 = fa->GetSon();\n        if (k1 == k2) {\n          fa->fa->rotate(k2);\n          fa->rotate(k1);\n        } else {\n          fa->rotate(k1);\n          fa->rotate(k2);\n        }\n      }\n    }\n  }\n};\nNode Mem[maxn], *pool = Mem + 1, *rot = Mem;\ninline Node* New(const int x) {\n  pool->len = x;\n  return pool++;\n}\n\nvoid access(Node *u) {\n  for (Node *v = nullptr; u; u = (v = u)->fa) {\n    u->splay();\n    if (u->ch[1]) u->si += u->ch[1]->ss;\n    if (v) u->si -= v->ss; \n    u->ch[1] = v;\n    u->pushup();\n  }\n}\n\n\nvoid link(Node *const u, Node *const v) {\n  access(u);\n  u->splay();\n  v->fa = u;\n  u->si += v->ss;\n  u->pushup();\n}\n\nvoid cut(Node *const u, Node *const v) {\n  access(v);\n  v->splay();\n  v->ch[0]->fa = nullptr;\n  v->ch[0] = nullptr;\n  v->pushup();\n}\n\nvoid extend(const int x) {\n  static Node *lst = rot;\n  auto p = lst, np = New(lst->len + 1);\n  np->sz = np->ss = 1; lst = np;\n  while (p && (p->trans[x] == nullptr)) {\n    p->trans[x] = np;\n    p = p->fail;\n  }\n  if (p == nullptr) {\n    link(np->fail = rot, np);\n  } else {\n    auto q = p->trans[x];\n    if (q->len == (p->len + 1)) {\n      link(np->fail = q, np);\n    } else {\n      auto nq = New(p->len + 1);\n      for (int i = 0; i < maxt; ++i) nq->trans[i] = q->trans[i];\n      link(nq->fail = q->fail, nq);\n      cut(q->fail, q);\n      link(q->fail = nq, q);\n      link(np->fail = nq, np);\n      while (p && p->trans[x] == q) {\n        p->trans[x] = nq;\n        p = p->fail;\n      }\n    }\n  }\n}\n\nint q;\nchar s[maxn];\nvoid Init() {\n  qr(q);\n  int n = qrs(s + 1);\n  for (int i = 1; i <= n; ++i) {\n    extend(s[i] - 'A');\n  }\n}\n\nvoid missyzy(const int n, int mk) {\n  for (int i = 0; i < n; ++i) {\n    mk = (mk * 131 + i) % n;\n    std::swap(s[i], s[mk]);\n  }\n}\n\nvoid Solve() {\n  static int mk;\n  static char tp[50];\n  while (q--) {\n    qrs(tp); int n = qrs(s);\n    missyzy(n, mk);\n    if (tp[0] == 'A') {\n      for (int i = 0; i < n; ++i) {\n        extend(s[i] - 'A');\n      }\n    } else {\n      auto u = rot;\n      int ret = -1;\n      for (int i = 0, x = s[i] - 'A'; i < n; x = s[++i] - 'A') {\n        if (u->trans[x] == nullptr) {\n          ret = 0;\n          break;\n        }\n        u = u->trans[x];\n      }\n      if (ret == 0) {\n        puts(\"0\");\n      } else {\n        access(u);\n        u->splay();\n        int ret = u->si + u->sz;\n        qw(ret, '\\n');\n        mk ^= ret;\n      }\n    }\n  }\n}\n\n} // namespace Fusu\n```\n\n",
        "postTime": 1587982569,
        "uid": 65363,
        "name": "\u4e00\u6276\u82cf\u4e00",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "\u5b66\u4e60\u540e\u7f00\u81ea\u52a8\u673a\u4e4b\u540e\u505a\u7684\u7b2c\u4e00\u4e2a\u975e\u6a21\u677f\u9898\u3002\n\n\u9996\u5148\u5148\u5410\u69fd\u4e00\u4e0b\u8fd9\u4e2a\u5f88\u795e\u5947\u7684\u5f3a\u5236\u5728\u7ebf\u65b9\u5f0f\u2026\u2026\u6211\u56e0\u4e3a**\u6284\u9519\u4e86**WA\u4e86\u597d\u51e0\u904d\u3002\n\n\u9898\u76ee\u5176\u5b9e\u672c\u8eab\u4e0d\u662f\u5f88\u96be\uff0c\u8fd9\u4e2a\u6240\u8c13\u7684\u201c\u51fa\u73b0\u6b21\u6570\u201d\u7528\u767d\u8bdd\u8bb2\u5c31\u662f\u540e\u7f00\u6811\u6bcf\u4e2a\u7ed3\u70b9\u7684\u5b50\u6811\u7684\u540e\u7f00\u7ed3\u675f\u7ed3\u70b9\u4e2a\u6570\u3002\u6211\u4eec\u9700\u8981\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u4e00\u4e0bparent\u6811\uff0c\u8981\u6c42\u80fd\u591f\u52a8\u6001\u52a0\u8fb9\u5e76\u4e14\u8def\u5f84\u4e0a\u4fee\u6539\uff0c\u5355\u70b9\u67e5\u8be2\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5f88\u8f7b\u6613\u5730\u60f3\u5230\u7528link-cut-tree\u5b8c\u6210\u8fd9\u4e2a\u64cd\u4f5c\u3002\n\n\u56e0\u6b64\u8fd9\u4e2a\u9898\u76ee\u5c31\u662f\u4e00\u4e2aSAM\u5957LCT\uff0c\u6109\u5feb\u5730\u7801\u4ee3\u7801\u5427\uff08\n\n\u4e0d\u8fc7\u2026\u2026\u7a0d\u7b49\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u5f88\u5c0f\u7684\u533a\u522b\uff1a\u8fd9\u91cc\u662f\u4e00\u68f5\u6709\u5411\u6811\uff0c\u56e0\u6b64\u5c31\u4e0d\u7528\u6362\u6839\u4e86\uff0c\u540c\u65f6\u4e5f\u8981\u6ce8\u610flink\u548ccut\u7684\u65f6\u5019\u5bf9\u4e4b\u524d\u7684\u5f71\u54cd\uff0c\u901a\u8fc7\u6807\u8bb0\u53ef\u4ee5\u5b8c\u6210\u8fd9\u4e9b\u64cd\u4f5c\u3002\n\n\u63a5\u7740\u5c31\u662f\u5de8\u957f\u65e0\u6bd4\u7684\u4ee3\u7801\u3002\u6211\u628aSAM\u548cLCT\u90fd\u5c01\u88c5\u4e86\u4e00\u4e0b\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n \nusing namespace std;\n \nint read()\n{\n    int x=0,f=1;char ch=getchar();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n    while (isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\n \nchar s[3000050];\n \nstring chars;\n \nint Q;\n \nint mask;\n \nvoid decodeWithMask(int mask)\n{\n    scanf(\"%s\",s);\n    chars=s;\n    for (int j=0;j<chars.length();j++)\n    {\n        mask=(mask*131+j)%chars.length();\n        char t=chars[j];\n        chars[j]=chars[mask];\n        chars[mask]=t;\n    }\n}\n \nstruct Link_Cut_Tree\n{\n    int w[1200050],tag[1200050],son[1200050][2],fa[1200050],st[1200050];\n     \n    void Add(int x,int y)\n    {\n        if (x)\n        {\n            w[x]+=y;\n            tag[x]+=y;\n        }\n    }\n     \n    void Push_Down(int x)\n    {\n        int ls=son[x][0],rs=son[x][1];\n        if (tag[x])\n        {\n            Add(ls,tag[x]);\n            Add(rs,tag[x]);\n            tag[x]=0;\n        }\n    }\n     \n    bool Isroot(int x)\n    {\n        return son[fa[x]][0]!=x && son[fa[x]][1]!=x;\n    }\n     \n    void Rotate(int x)\n    {\n        int y=fa[x],z=fa[y];\n        int l,r;\n        if (son[y][0]==x) \n            l=0;\n        else l=1;\n        r=l^1;\n        if (!Isroot(y))\n        {\n            if (son[z][0]==y)\n                son[z][0]=x;\n            else son[z][1]=x;\n        }\n        fa[x]=z;\n        fa[y]=x;\n        fa[son[x][r]]=y;\n        son[y][l]=son[x][r];\n        son[x][r]=y;\n    }\n     \n    void Splay(int x)\n    {\n        int cnt=0;\n        st[++cnt]=x;\n        for (int i=x;!Isroot(i);i=fa[i])\n            st[++cnt]=fa[i];\n        while (cnt)\n            Push_Down(st[cnt--]);\n        while (!Isroot(x))\n        {\n            int y=fa[x],z=fa[y];\n            if (!Isroot(y))\n                Rotate((son[y][0]==x)^(son[z][0]==y)?x:y);\n            Rotate(x);\n        }\n    }\n     \n    void Access(int x)\n    {\n        for (int y=0;x;x=fa[x])\n        {\n            Splay(x);\n            son[x][1]=y;\n            y=x;\n        }\n    }\n     \n    void Link(int x,int y)\n    {\n        fa[x]=y;\n        Access(y);\n        Splay(y);\n        Add(y,w[x]);\n    }\n     \n    void Cut(int x)\n    {\n        Access(x);\n        Splay(x);\n        Add(son[x][0],-w[x]);\n        fa[son[x][0]]=0;\n        son[x][0]=0;\n    }\n     \n}t;\n \nstruct SuffixAutomaton\n{\n    int cnt,last;\n     \n    int fa[1200050],len[1200050],trans[1200050][26];\n     \n    void Insert(int c)\n    {\n        int p=last,np=++cnt;\n        last=np;\n        len[np]=len[p]+1;\n        t.w[np]=1;\n        for (;p && !trans[p][c];p=fa[p])\n            trans[p][c]=np;\n        if (!p)\n        {\n            fa[np]=1;\n            t.Link(np,1);\n        }\n        else\n        {\n            int q=trans[p][c];\n            if (len[p]+1==len[q])\n            {\n                fa[np]=q;\n                t.Link(np,q);\n            }\n            else\n            {\n                int nq=++cnt;\n                len[nq]=len[p]+1;\n                memcpy(trans[nq],trans[q],sizeof(trans[q]));\n                fa[nq]=fa[q];\n                t.Link(nq,fa[q]);\n                fa[q]=fa[np]=nq;\n                t.Cut(q);\n                t.Link(q,nq);\n                t.Link(np,nq);\n                for (;trans[p][c]==q;p=fa[p])\n                    trans[p][c]=nq;\n            }\n        }\n    }\n     \n    void Build()\n    {\n        cnt=last=1;\n        scanf(\"%s\",s);\n        int len=strlen(s);\n        for (int i=0;i<len;i++)\n            Insert(s[i]-'A');\n    }\n     \n    void Add()\n    {\n        decodeWithMask(mask);\n        int len=chars.length();\n        for (int i=0;i<len;i++)\n            Insert(chars[i]-'A');\n    }\n     \n    int Query()\n    {\n        decodeWithMask(mask);\n        int p=1,len=chars.length();\n        for (int i=0;i<len;i++)\n            if (!(p=trans[p][chars[i]-'A']))\n                return 0;\n        t.Splay(p);\n        return t.w[p];\n    }\n     \n}SAM;\n \nint main()\n{\n    Q=read();\n    SAM.Build();\n    while (Q--)\n    {\n        char str[10];\n        scanf(\"%s\",str);\n        if (str[0]=='A')\n            SAM.Add();\n        else\n        {\n            int ans=SAM.Query();\n            printf(\"%d\\n\",ans);\n            mask^=ans;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1534579310,
        "uid": 8457,
        "name": "chen_zhe",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 \u6d1b\u8c37P5212 SubString"
    },
    {
        "content": "### \u524d\u7f6e\u6280\u80fd\n\n0.\u91cd\u91cf\u5e73\u8861\u6811\uff08\u66ff\u7f6a\u7f8a\u6811\uff09,\u540e\u7f00\u6570\u7ec4\n\n1.\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u6bd4\u8f83\u4e24\u4e2a\u5143\u7d20\u7684\u5148\u540e\n\n**\u6392\u540d\u6bd4\u8f83** $O(1)$\n\n2.\u4e00\u4e2a**\u5e26\u63d2\u5165**\u7684\u5e8f\u5217\uff0c\u6bd4\u8f83\u4e24\u4e2a\u5143\u7d20\u7684\u5148\u540e\n\n**\u987a\u5e8f\u67e5\u627e\uff1f** $O(n)$\n\n**\u6bd4\u8f83\u6392\u540d\uff1f**\n\n\u63d2\u5165\u65f6\u4ee5\u524d\u9a71\u548c\u540e\u7ee7\u7684\u6392\u540d\u7684\u5e73\u5747\u6570\u4f5c\u4e3a\u81ea\u5df1\u7684\u6392\u540d\n\n\u6dfb\u52a00\u548c\u6b63\u65e0\u7a77\u4e24\u4e2a\u865a\u62df\u8282\u70b9\n\n**\u6392\u540d\u6bd4\u8f83** $O(1)$\n\n3.\u7ed9\u5b9a\u4e00\u4e2a\u540e\u7f00\u6570\u7ec4\uff0c\u6bd4\u8f83\u4e24\u4e2a\u540e\u7f00\u7684\u5148\u540e\n\n\u7528SA\u6570\u7ec4\u6c42\u51fa\u6bcf\u4e2a\u540e\u7f00\u7684\u6392\u540d\uff0c $O(1)$\n\n4.\u7ed9\u5b9a\u4e00\u4e2a**\u5e26\u63d2\u5165\uff08\u52a8\u6001\uff09**\u7684\u540e\u7f00\u6570\u7ec4\uff0c\u6bd4\u8f83\u4e24\u4e2a\u540e\u7f00\u7684\u5148\u540e\n\n\u76f8\u5f53\u4e8e\u5728SA\u6570\u7ec4\u4e2d\u52a8\u6001\u63d2\u5165\u4e00\u4e2a\u540e\u7f00\uff0c\u6392\u540d\u7531\u524d\u9a71\u540e\u7ee7\u7684\u6392\u540d\u8ba1\u7b97\uff0c\u540c2. $O(1)$\n\n### \u6982\u5ff5\n\n\u540e\u7f00\u5e73\u8861\u6811\u662f**\u52a8\u6001\u7684\u540e\u7f00\u6570\u7ec4**\n\n\u652f\u6301\u7684\u64cd\u4f5c\uff1a\n\n1.\u5728\u5b57\u7b26\u4e32\u524d\u63d2\u5165\u5b57\u7b26c\uff08\u76f8\u5f53\u4e8e\u52a0\u5165\u4e00\u4e2a\u540e\u7f00\uff09\n\n2.\u5728\u5b57\u7b26\u4e32\u524d\u5220\u9664\u5b57\u7b26c\uff08\u76f8\u5f53\u4e8e\u5220\u9664\u4e00\u4e2a\u540e\u7f00\uff09\n\n3.\u8be2\u95ee\u4e00\u4e2a\u540e\u7f00\u5728\u5e73\u8861\u6811\u4e2d\u7684\u6392\u540d\n\n4.\u8be2\u95ee\u4e00\u4e2a\u5b57\u7b26\u4e32\u5728\u5e73\u8861\u6811\u4e2d\u7684\u6392\u540d\n\n### \u64cd\u4f5c1\n\n\u6211\u4eec\u7528$S_i$ \u4ee3\u8868\u539f\u4e32$S$\u4ece\u7b2c$i$\u4e2a\u5b57\u7b26\u5f00\u59cb\u7684\u540e\u7f00\n\n\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u6709\u4e86\u4e32$S$\u7684\u540e\u7f00\u5e73\u8861\u6811 \n\n\u63d2\u5165\u4e00\u4e2a\u5b57\u6bcd $c$ \n\n\u5219\u540e\u7f00 $cS$ \u4e0e\u4efb\u610f\u4e00\u4e2a\u540e\u7f00 $S_i$ \u7684\u5927\u5c0f\u5173\u7cfb\u53ef\u4ee5\u7528 $c$ \u4e0e $S_i$ \u7684\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u7684\u5927\u5c0f\u5173\u7cfb\u4ee5\u53ca\u540e\u7f00 $S_1$ \u4e0e\u540e\u7f00 $S_{i+1}$ \u7684\u5927\u5c0f\u5173\u7cfb\u6765\u8868\u793a \n\n\u524d\u9762\u662f\u4e24\u4e2a\u5b57\u7b26\u7684\u6bd4\u8f83 $O(1)$ \n\n\u540e\u9762\u539f\u4e32\u540e\u7f00\u7684\u5927\u5c0f\u5173\u7cfb\u53ef\u4ee5\u5728\u5e73\u8861\u6811\u4e0a\u7ef4\u62a4\u6392\u540d $O(1)$ \u6bd4\u8f83\n\ntips\uff1a\u63d2\u5165\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u524d\u9a71\u540e\u7ee7\u7684\u6392\u540d\n\n### \u64cd\u4f5c2\n\n\u5e73\u8861\u6811\u5220\u9664 $O(qlogn)$\n\n### \u64cd\u4f5c3\n\n\u5e73\u8861\u6811\u57fa\u672c\u64cd\u4f5c $O(qlogn)$\n\n### \u64cd\u4f5c4\n\n\u5e73\u8861\u6811\u57fa\u672c\u64cd\u4f5c\uff0c\u6bd4\u8f83\u6539\u4e3a\u5b57\u5178\u5e8f\u6bd4\u8f83 $O(\\sum |Q|logn)$\n\n### \u5173\u4e8e\u8fd9\u9898\n\n\u540e\u7f00\u5e73\u8861\u6811\u88f8\u9898~~\u5c31\u662f\u4e0d\u7ed9\u7528SAM~~\n\n\u524d\u7f00\u8f6c\u540e\u7f00\n\n\u51fa\u73b0\u6b21\u6570\u5c31\u662f$rank(Q'inf')-rank(Q'\\0')$\n\n### \u4ee3\u7801 \n~~\u8c8c\u4f3c\u633a\u5feb\u7684\u4e5f\u5c31rnk1~~\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\ninline ll read()\n{\n    int ch=getchar(),f=1;\n    ll ans=0;\n    for(;ch<'0'||ch>'9';ch=getchar())\n        if(ch=='-')f=0;\n    for(;ch>='0'&&ch<='9';ch=getchar())\n        ans=(((ans<<2)+ans)<<1)+(ch^'0');\n    return f?ans:-ans;\n}\nint mask;\nconst int maxn=600005;\nconst ll inf=0x4000000000000000;\nchar q[maxn*5];\nvoid decode(char *s,int msk=mask)\n{\n    int len=strlen(s);\n    for(int j=0;j<len;++j)\n    {\n        msk=(msk*131+j)%len;\n        char t=s[j];\n        s[j]=s[msk];\n        s[msk]=t;\n    }\n}\nchar s[maxn];\nint len;\nll val[maxn];//\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u503c\uff0c\u7528\u4e8eO(1)\u6bd4\u8f83\u4e24\u4e2a\u540e\u7f00\u7684\u5148\u540e\nint cnt,c[maxn][2],siz[maxn],st[maxn],top,rt;\ninline void push_up(int x)\n{\n    siz[x]=c[x][0][siz]+c[x][1][siz]+1;\n}\n\n/****\u66ff\u7f6a\u7f8a\u5220\u9664****/\nint uni(int x,int y)\n{\n    return (!x||!y)?(x+y):siz[x]>siz[y]?(c[x][1]=uni(c[x][1],y),push_up(x),x):(c[y][0]=uni(x,c[y][0]),push_up(y),y);\n}\nvoid del(int &x,int y)\n{\n    x^y?siz[x]--,del(c[x][val[y]>val[x]],y),0:x=uni(c[x][0],c[x][1]);\n}\nvoid dfs(int &x)\n{\n    if(x)dfs(c[x][0]),st[++top]=x,dfs(c[x][1]),x=0;\n}\n/****\u66ff\u7f6a\u7f8a\u91cd\u5efa****/\nint reb(int l,int r,ll L,ll R)\n{\n    int mid=l+r>>1;\n    int x=st[mid];\n    siz[x]=r-l+1;\n    val[x]=L+R>>1;\n    if(l<mid)c[x][0]=reb(l,mid-1,L,val[x]);\n    if(mid<r)c[x][1]=reb(mid+1,r,val[x],R);\n    return x;\n}\n\n/****\u66ff\u7f6a\u7f8a\u63d2\u5165****/\nvoid ins(int &x,int y,ll L=0,ll R=inf,bool d=1)\n{\n    if(!x)\n        x=y,c[x][0]=c[x][1]=0,siz[x]=1,val[x]=L+R>>1;\n    else\n    {\n        siz[x]++;\n        bool w=s[x]<s[y]||s[x]==s[y]&&val[x-1]<val[y-1];\n        bool bad=d&&siz[c[x][w]]>siz[x]*0.7+5;\n        ins(c[x][w],y,w?val[x]:L,w?R:val[x],d&&!bad);\n        if(bad)top=0,dfs(x),x=reb(1,top,L,R);\n    }\n}\nint rnk(char *q,int len)\n{\n    int ans=0;\n    for(int x=rt;x;)\n    {\n        bool w=0;\n        for(int i=0;i<len;++i)\n            if(q[i]^s[x-i])\n        {\n            w=q[i]>s[x-i];\n            break;\n        }\n        if(w)ans+=c[x][0][siz]+1;\n        x=c[x][w];\n    }\n    return ans;\n}\nint main()\n{\n    int Q=read();\n    scanf(\"%s\",s+1);\n    len=strlen(s+1);\n    for(int i=1;i<=len;++i)\n        ins(rt,i);\n    while(Q--)\n    {\n        char opt[9];\n        scanf(\"%s\",opt);\n        if(*opt=='A')\n        {\n            scanf(\"%s\",q+1);\n            decode(q+1);\n            int l=strlen(q+1);\n            for(int i=1;i<=l;++i)\n            {\n                s[len+i]=q[i];\n                ins(rt,len+i);\n            }\n            len+=l;\n        }\n        else if(*opt=='D')\n        {\n            int l=read();\n            for(int i=1;i<=l;++i)\n            {\n                s[len]=0;\n                del(rt,len);\n                --len;\n            }\n        }\n        else\n        {\n            scanf(\"%s\",q+1);\n            decode(q+1);\n            int l=strlen(q+1);\n            for(int i=1,j=l;i<j;++i,--j)\n                swap(q[i],q[j]);\n            int ans=-rnk(q+1,l+1);\n            q[l+1]='Z'+1;\n            ans+=rnk(q+1,l+1);\n            printf(\"%d\\n\",ans);\n            mask^=ans;\n        }\n        //printf(\"%s\\n\",s+1);\n    }\n    //cout << \"Hello world!\" << endl;\n    return 0;\n}\n\n```\n\n#### \u53c2\u8003\u8d44\u6599:\n\n[\u540e\u7f00\u5e73\u8861\u6811\u5b66\u4e60\u7b14\u8bb0](https://blog.csdn.net/liutian429073576/article/details/53056038)",
        "postTime": 1553090727,
        "uid": 35143,
        "name": "PM250",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "\u9898\u9762\uff1ahttps://www.lydsy.com/JudgeOnline/problem.php?id=2555\n\n\u9898\u89e3\uff1a\n\n\u5982\u679c\u6ca1\u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u8fd9\u5c31\u662f\u4e00\u9053SAM\u6a21\u677f\u9898\u3002\n\n\u6709\u4e86\u4fee\u6539\u64cd\u4f5c\u540e\uff0c\u53d1\u73b0fail\u6811\u53ef\u80fd\u4f1a\u6709\u65ad\u8fb9\u7684\u8fc7\u7a0b\uff0c\n\n\u4e0d\u96be\u60f3\u5230\u4f7f\u7528LCT\u7ef4\u62a4fail\u6811\u3002\n\n\u6bcf\u6b21\u52a0\u8fb9\u65f6\uff0c\u9700\u8981\u5c06\u8d21\u732e\u4e5f\u4e00\u5e76\u52a0\u5165LCT\u7684\u8282\u70b9\u4e2d\uff0c\n\n\u67e5\u8be2\u65f6\uff0c\u627e\u5230\u5bf9\u5e94\u8282\u70b9\uff0c\u5c06\u5176splay\u5230\u6839\uff0c\u6b64\u65f6\u7684val\u5c31\u662f\u7b54\u6848\u3002\n\n\u6ce8\u610f\uff1a\n\n1.splay\u65f6\u8bb0\u5f97\u8981pushdown;\n\n2.\u662f\u5927\u5199\u5b57\u6bcd\uff1b\n\n3.\u6570\u7ec4\u8981\u5f00\u5230$1.2e6$\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n+Qlogn)$\n\n\u4ee3\u7801\uff1a\n```\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define C(x,y) memset(x,y,sizeof(x))\n#define STS system(\"pause\")\ntemplate<class D>I read(D &res){\n\tres=0;register D g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nchar c[3030000];\nint n,m,Q;\nnamespace LCT{\n\tint fa[1202000],ch[1202000][2],laz[1202000],w[1202000];\n\tint st[1202000];\n\tIN nroot(int x){\n\t\treturn (ch[fa[x]][0]==x)||(ch[fa[x]][1]==x);\n\t}\n\tIN get(int x){\n\t\treturn ch[fa[x]][1]==x;\n\t}\n\tI add(int x,int val){\n\t\tif(!x)return;laz[x]+=val;w[x]+=val;\n\t}\n\tI push_down(int x){\n\t\tadd(ch[x][0],laz[x]);add(ch[x][1],laz[x]);\n\t\tlaz[x]=0;\n\t}\n\tI rotate(int x){\n\t\tre y=fa[x],z=fa[y],dir=get(x);\n\t\tif(nroot(y))ch[z][get(y)]=x;fa[x]=z;\n\t\tch[y][dir]=ch[x][dir^1];fa[ch[x][dir^1]]=y;\n\t\tch[x][dir^1]=y;fa[y]=x;\n\t}\n\tI splay(int x){\n\t\tre y=x,z=0;st[++z]=y;\n\t\twhile(y)st[++z]=y=fa[y];\n\t\twhile(z)push_down(st[z--]);\n\t\twhile(nroot(x)){\n\t\t\ty=fa[x],z=fa[y];\n\t\t\tif(nroot(y))rotate((get(x)^get(y))?x:y);\n\t\t\trotate(x);\n\t\t}\n\t}\n\tI access(int x){\n\t\tfor(re y=0;x;x=fa[y=x])splay(x),ch[x][1]=y;\n\t}\n\tI link(int x,int y){\n\t\tfa[x]=y;access(y);splay(y);add(y,w[x]);\n\t}\n\tI cut(int x,int y){\n\t\taccess(x);splay(x);add(ch[x][0],-w[x]);\n\t\tfa[ch[x][0]]=0;ch[x][0]=0;\n\t}\n};\nnamespace SAM{\n\tint len[1202000],ch[1202000][27],link[1202000],tot,las,p,q,cle,cur;\n\tI init(){tot=las=1;}\n\tI add(int x){\n\t\tcur=++tot;len[cur]=len[las]+1;p=las;las=cur;LCT::w[cur]=1;\n\t\twhile(p&&!ch[p][x])ch[p][x]=cur,p=link[p];\n\t\tif(!p){link[cur]=1;LCT::link(cur,1);return;}\n\t\tq=ch[p][x];\n\t\tif(len[p]+1==len[q]){link[cur]=q;LCT::link(cur,q);return;}\n\t\tcle=++tot;len[cle]=len[p]+1,link[cle]=link[q];LCT::link(cle,link[cle]);\n\t\tmemcpy(ch[cle],ch[q],sizeof(ch[q]));\n\t\tLCT::cut(q,link[q]);link[q]=cle;LCT::link(q,link[q]);link[cur]=cle;LCT::link(cur,cle);\n\t\twhile(p&&ch[p][x]==q)ch[p][x]=cle,p=link[p];\n\t}\n\tI insert(){F(i,0,n-1)add(c[i]-'A'+1);}\n\tI ques(){\n\t\tp=1;\n\t\tF(i,0,n-1){\n\t\t\tif(!ch[p][c[i]-'A'+1]){\n\t\t\t\tprintf(\"0\\n\");return;\n\t\t\t}\n\t\t\tp=ch[p][c[i]-'A'+1];\n\t\t}\n\t\tLCT::splay(p);\n\t\tprintf(\"%d\\n\",LCT::w[p]);m^=LCT::w[p];\n\t} \n};\nI getit(int x){\n\tscanf(\"%s\",c);n=strlen(c);\n\tF(i,0,n-1){\n\t\tx=(x*131+i)%n;\n\t\tswap(c[i],c[x]);\n\t}\n}\nint main(){\n\tread(Q);m=0;\n\tscanf(\"%s\",c);\n\tn=strlen(c);\n\tSAM::init();\n\tSAM::insert();\n\twhile(Q--){\n\t\tscanf(\"%s\",c+1);\n\t\tif(c[1]=='A'){\n\t\t\tgetit(m);SAM::insert();\n\t\t}\n\t\telse{\n\t\t\tgetit(m);SAM::ques();\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\uff1ahttps://www.cnblogs.com/Purple-wzy/",
        "postTime": 1578532922,
        "uid": 93453,
        "name": "Purple_wzy",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "[\u9898\u76ee](https://www.luogu.org/problemnew/show/P5212)\n\n\u771f\u662f\u4e00\u9053\u975e\u5e38\u597d\u7684\u7801\u519c\u9898\uff0c$SAM+LCT$\n\n\u770b\u5230\u67e5\u8be2\u5b50\u4e32\u51fa\u73b0\u6b21\u6570\u6211\u4eec\u5c31\u80fd\u60f3\u5230\u8fd9\u662f\u4e00\u4e2a$SAM$\n\n\u770b\u5230\u52a8\u6001\u5f80\u540e\u52a0\u5165\u5b57\u7b26\u4e32\u6211\u4eec\u5c31\u53ef\u4ee5\u60f3\u5230\u9700\u8981$LCT$\u6765\u7ef4\u62a4\u5b50\u6811\u548c\n\n\u7531\u4e8e$LCT$\u5e76\u4e0d\u662f\u5f88\u65b9\u4fbf\u7ef4\u62a4\u5b50\u6811\uff0c\u6240\u4ee5\u6bcf\u6b21\u52a0\u5165\u4e00\u4e2a\u70b9\u7684\u65f6\u5019\u53ea\u9700\u8981\u628a\u6839\u5230\u8fd9\u4e2a\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u52a0\u4e00\u5c31\u597d\u4e86\n\n\u67e5\u8be2\u5728$SAM$\u4e0a\u5339\u914d\u51fa\u4f4d\u7f6e\uff0c\u5dee\u4e00\u4e2a\u5355\u70b9\u6743\u503c\u5c31\u53ef\u4ee5\u4e86\n\n\u522b\u5fd8\u4e86\u52a0\u5165$clone$\u8282\u70b9\u7684\u65f6\u5019\u8981\u7ee7\u627f\u513f\u5b50\u7684\u70b9\u6743\n\n\u4ee3\u7801\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<string>\n#define maxn 1200005\n#define re register\n#define LL long long\nchar S[3000005],opt[10];\nstd::string chars;\nint Q,mask,ans,lst=1,cnt=1;\nint tag[maxn],rev[maxn],fa[maxn],ch[maxn][2],s[maxn],st[maxn];\ninline int nroot(int x) {return ch[fa[x]][1]==x||ch[fa[x]][0]==x;}\nvoid Gets(int mask) {\n    scanf(\"%s\",S);\n    chars=S;\n    for (int j=0;j<chars.length();j++) {\n        mask=(mask*131+j)%chars.length();\n        char t=chars[j];\n        chars[j]=chars[mask];\n        chars[mask]=t;\n    }\n}\ninline void pushdown(int x) {\n\tif(rev[x]) {\n\t\tif(ch[x][0]) rev[ch[x][0]]^=1,std::swap(ch[ch[x][0]][0],ch[ch[x][0]][1]);\n\t\tif(ch[x][1]) rev[ch[x][1]]^=1,std::swap(ch[ch[x][1]][0],ch[ch[x][1]][1]);\n\t\trev[x]=0;\n\t}\n\tif(tag[x]) {\n\t\tif(ch[x][0]) s[ch[x][0]]+=tag[x],tag[ch[x][0]]+=tag[x];\n\t\tif(ch[x][1]) s[ch[x][1]]+=tag[x],tag[ch[x][1]]+=tag[x];\n\t\ttag[x]=0;\n\t}\n}\ninline void rotate(int x) {\n\tint y=fa[x],z=fa[y],k=ch[y][1]==x,w=ch[x][k^1];\n\tif(nroot(y)) ch[z][ch[z][1]==y]=x;\n\tch[x][k^1]=y,ch[y][k]=w;\n\tfa[w]=y,fa[y]=x,fa[x]=z;\n}\ninline void splay(int x) {\n\tint y=x,top=0;\n\tst[++top]=x;\n\twhile(nroot(y)) st[++top]=fa[y],y=fa[y];\n\twhile(top) pushdown(st[top--]);\n\twhile(nroot(x)) {\n\t\tint y=fa[x];\n\t\tif(nroot(y)) rotate((ch[fa[y]][1]==y)^(ch[y][1]==x)?x:y);\n\t\trotate(x);\n\t}\n}\ninline void access(int x) {\n\tfor(re int y=0;x;y=x,x=fa[x])\n\t\tsplay(x),ch[x][1]=y;\n}\ninline void makeroot(int x) {\n\taccess(x);splay(x),rev[x]^=1;std::swap(ch[x][0],ch[x][1]);\n}\ninline void split(int x,int y) {\n\tmakeroot(x);access(y);splay(y);\n}\ninline void link(int x,int y) {\n\tfa[x]=y;\n}\ninline void cut(int x,int y) {\n\tsplit(x,y);ch[y][0]=fa[x]=0;\n}\nstruct Suffix_Automata {\n\tint len[maxn],fa[maxn],son[maxn][26];\n\tinline void ins(int c) {\n\t\tint p=++cnt,f=lst; lst=p;\n\t\tlen[p]=len[f]+1;\n\t\twhile(f&&!son[f][c]) son[f][c]=p,f=fa[f];\n\t\tif(!f) {fa[p]=1;link(p,fa[p]);split(1,p);tag[p]++;s[p]++;return;}\n\t\tint x=son[f][c];\n\t\tif(len[f]+1==len[x]) {fa[p]=x;link(p,fa[p]);split(1,p);tag[p]++;s[p]++;return;}\n\t\tint y=++cnt;\n\t\tlen[y]=len[f]+1,fa[y]=fa[x],cut(fa[x],x),fa[x]=fa[p]=y;\n\t\tlink(x,fa[x]),link(p,fa[p]),link(y,fa[y]);\n\t\tsplay(x);s[y]=s[x];\n\t\tfor(re int i=0;i<26;i++) son[y][i]=son[x][i];\n\t\twhile(f&&son[f][c]==x) son[f][c]=y,f=fa[f];\n\t\tsplit(1,p);tag[p]++;s[p]++;\n\t}\n\tinline void add() {\n\t\tGets(mask);\n\t\tint len=chars.length();\n\t\tfor(re int i=0;i<len;i++) ins(chars[i]-'A');\n\t}\n\tinline int check() {\n\t\tGets(mask);\n\t\tint len=chars.length();\n\t\tint now=1;\n\t\tfor(re int i=0;i<len;i++) {\n\t\t\tnow=son[now][chars[i]-'A'];\n\t\t\tif(!now) break;\n\t\t}\n\t\tif(!now) return 0;\n\t\tsplay(now);return s[now];\n\t}\n}SAM;\nint main()\n{\n\tscanf(\"%d\",&Q);\n\tscanf(\"%s\",S+1);\n\tint len=strlen(S+1);\n\tfor(re int i=1;i<=len;i++) SAM.ins(S[i]-'A');\n\twhile(Q--) {\n\t\tscanf(\"%s\",opt);\n\t\tif(opt[0]=='A') SAM.add();\n\t\telse {\n\t\t\tans=SAM.check();\n\t\t\tmask^=ans;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1550053342,
        "uid": 35178,
        "name": "asuldb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "#### \u524d\u8a00\n\n\u8f9b\u9178\u7684\u8c03\u9898\u8fc7\u7a0b\uff1a\n\n\u524d\u591c\n20:30 -> 82pts \uff0c        21:50 -> 0pts   \n\u5f53\u65e5\n14:31 -> 27pts \uff0c        14:52 -> 91pts \uff0c       15:28 -> 100pts\n\n#### \u9898\u610f\n\n\u7ed9\u4f60\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8981\u6c42\u652f\u6301\u4ee5\u4e0b\u4e24\u4e2a\u64cd\u4f5c\n\n1. \u5728\u5f53\u524d\u5b57\u7b26\u4e32\u540e\u9762\u63d2\u5165\u4e00\u4e2a\u5b57\u7b26\u4e32 S\n2. \u67e5\u8be2\u5b57\u7b26\u4e32 S \u5728\u5f53\u524d\u5b57\u7b26\u4e32\u4e2d\u51fa\u73b0\u4e86\u51e0\u6b21\n\n\u5f3a\u5236\u5728\u7ebf\uff0c$|S|\\le6\\times10^5,\\quad Q\\le10^4$\n\n#### \u9898\u89e3\n\n\u5982\u679c\u6ca1\u6709\u5f3a\u5236\u5728\u7ebf\uff0c\u53ef\u4ee5\u5c06\u6240\u6709\u63d2\u5165\u5b57\u7b26\u4e32\u6309\u987a\u5e8f\u52a0\u5165\u540e\uff0c\u8dd1\u4e00\u904d $SAM/SA$ ,\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u5212\u5b9a\u533a\u95f4\u67e5\u8be2\u5373\u53ef\n\n\u4f46\u5982\u679c\u5f3a\u5236\u5728\u7ebf\u5462\uff1f\u8fd8\u662f\u8003\u8651 $SAM$ \uff0c\u5bf9\u4e8e\u7528 $SAM $\u5efa\u6210\u7684$parent$ \u6811\u6765\u8bf4\uff0c\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u548c\u5373\u4e3a\u5176\u7b54\u6848\n\n\u4e00\u822c\u6765\u8bf4\uff0c$parent$ \u6811\u90fd\u662f\u5728\u6211\u4eec\u8dd1\u5b8c $SAM$ \u4e4b\u540e\u6784\u5efa\uff0c\u6211\u4eec\u8003\u8651\u5728 $SAM$ \u63d2\u5165\u5b57\u7b26\u7684\u8fc7\u7a0b\u4e2d\u8fdb\u884c\u6784\u5efa\uff0c\u5f88\u663e\u7136\u6211\u4eec\u53ea\u9700\u8981\u652f\u6301\u5220\u8fb9\u548c\u52a0\u8fb9\u7684\u64cd\u4f5c\uff0c\u53ef\u4ee5\u7528 $lct$ \u7b80\u5355\u7ef4\u62a4\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u7684\u5b50\u6811\u548c\uff0c\u4e0d\u96be\u770b\u51fa\u8fd9\u5176\u5b9e\u662f\u4e00\u4e2a\u94fe\u52a0\u7684\u8fc7\u7a0b  \n\u5373\u5c06 $x$ \u8fde\u4e3a $y$ \u7684\u5b50\u6811\uff0c\u76f4\u63a5\u5c06 $y->root(y)$ \u5168\u90e8\u52a0\u4e0a $si(x)$  \n\u5220\u8fb9\u64cd\u4f5c\u4e5f\u662f\u540c\u7406\n$$\n\\large\\color{grey}{\\text{Talk is cheap , show you the code}}\n$$\n\n\n#### \u4ee3\u7801\n\n```cpp\n#include<stdio.h>\n#include<iostream>\n#include<cstring>\n#include<math.h>\n#include<stdlib.h>\n#include<time.h>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int maxn=1200005;\nconst int inf=0x3f3f3f3f;\nint m,mask;\nchar s[maxn];\n\nstruct link_cut_tree\n{\n\tint st[maxn];\n\tstruct node\n\t{\n\t\tint ch[2],fa;\n\t\tint si,tag;\n\t}tr[maxn];\n\tinline bool pd(int x){return tr[tr[x].fa].ch[0]==x||tr[tr[x].fa].ch[1]==x;}\n\tinline void add(int x,int val){if(!x)return;tr[x].si+=val,tr[x].tag+=val;}\n\tinline void pushdown(int x){if(tr[x].tag){add(tr[x].ch[0],tr[x].tag),add(tr[x].ch[1],tr[x].tag),tr[x].tag=0;}}\n\tinline void rotate(int x)\n\t{\n\t\tint y=tr[x].fa,z=tr[y].fa,k=tr[y].ch[1]==x;\n\t\tif(pd(y))tr[z].ch[tr[z].ch[1]==y]=x;tr[y].ch[k]=tr[x].ch[k^1];tr[x].fa=z;\n\t\tif(tr[x].ch[k^1])tr[tr[x].ch[k^1]].fa=y;tr[x].ch[k^1]=y;tr[y].fa=x;\n\t}\n\tinline void splay(int x)\n\t{\n\t\tint y=x,z=0;while(y)st[++z]=y,y=tr[y].fa;while(z)pushdown(st[z--]);\n\t\twhile(pd(x)){y=tr[x].fa,z=tr[y].fa;if(pd(y))rotate((tr[z].ch[1]==y)^(tr[y].ch[1]==x)?x:y);rotate(x);}\n\t}\n\tinline void access(int x){for(register int y=0;x;x=tr[y=x].fa)splay(x),tr[x].ch[1]=y;}\n\tinline void link(int x,int y){splay(x),tr[x].fa=y;access(y),splay(y),add(y,tr[x].si);}\n\tinline void cut(int x){access(x),splay(x),add(tr[x].ch[0],-tr[x].si),tr[tr[x].ch[0]].fa=0,tr[x].ch[0]=0;}\n}supccz;\n\nstruct suffix_automaton\n{\n\tint la=1,tot=1;\n\tstruct node\n\t{\n\t\tint fa,len,ch[2];\n\t}tr[maxn];\n\tinline void insert(int x)\n\t{\n\t\tint p=la,u=++tot;supccz.tr[u].si=1;\n\t\ttr[u].len=tr[p].len+1;\n\t\twhile(p&&!tr[p].ch[x])tr[p].ch[x]=u,p=tr[p].fa;\n\t\tif(!p)tr[u].fa=p|1,supccz.link(u,1);\n\t\telse\n\t\t{\n\t\t\tint q=tr[p].ch[x];\n\t\t\tif(tr[q].len==tr[p].len+1)tr[u].fa=q,supccz.link(u,q);\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nu=++tot;tr[nu]=tr[q];\n\t\t\t\tsupccz.cut(q),supccz.link(nu,tr[q].fa),supccz.link(u,nu),supccz.link(q,nu);\t\n\t\t\t\ttr[nu].len=tr[p].len+1,tr[u].fa=tr[q].fa=nu;\n\t\t\t\twhile(p&&tr[p].ch[x]==q)tr[p].ch[x]=nu,p=tr[p].fa;\n\t\t\t}\n\t\t}\n\t\tla=u;\n\t}\n}ccz;\ninline void decode(char *s,int mk,int len){for(register int i=0;i<len;++i){mk=(mk*131+i)%len,swap(s[i],s[mk]);}}\nsigned main(void)\n{\n\tfreopen(\"P5212.in\",\"r\",stdin);\n\tcin>>m;\n\tscanf(\"%s\",s);\n\tint len=strlen(s);\n\tfor(register int i=0;i<len;++i)ccz.insert(s[i]-'A');\n\tfor(register int t,i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='A')\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tint len=strlen(s);decode(s,mask,len);\n\t\t\tfor(register int i=0;i<len;++i)ccz.insert(s[i]-'A');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%s\",s);\n\t\t\tint len=strlen(s),u=1;decode(s,mask,len);\n\t\t\tfor(register int j=0;j<len;++j)\n\t\t\t{\n\t\t\t\tu=ccz.tr[u].ch[s[j]-'A'];\n\t\t\t\tif(!u)break;\n\t\t\t}\n\t\t\tif(u)supccz.splay(u);\n\t\t\tt=supccz.tr[u].si;\n\t\t\tmask^=t;\n\t\t\tprintf(\"%d\\n\",t);\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n",
        "postTime": 1602490242,
        "uid": 224229,
        "name": "Caicz",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "[$\\Large\\color{#FFBBFF}\\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)\n\n------------\n\n# Description\n\n[\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P5212)\n\n------------\n\n# Solution\n\n\u52a8\u6001\u52a0\u5165\u5b57\u7b26\u5c31\u7528$SAM$\uff0c\u53d1\u73b0\u7b54\u6848\u5c31\u662f\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u7684$siz$\u4e4b\u548c\uff0c\u6240\u4ee5\u9700\u8981\u52a8\u6001\u7ef4\u62a4\u5b50\u6811\u548c\uff0c\u4e0a$LCT$\u3002\n\n$lCT$\u4e0a\u6bcf\u4e2a\u8282\u70b9\uff0c$siz$\u8868\u793a$Splay$\u4e0a\u5927\u5c0f\uff0c$lsiz$\u8868\u793a\u865a\u5b50\u6811\u5927\u5c0f\uff0c\u4fee\u6539$Update$\u3001$Access$\u3001$Link$\u51fd\u6570\u8fdb\u884c\u4fee\u6539\u5373\u53ef\u3002\n\n\u6700\u540e\u7b54\u6848\u5c31\u662f$Splay$\u4e0a\u6df1\u5ea6\u6bd4\u5b83\u5927\u7684\u8282\u70b9\u7684$siz$\u4e4b\u548c\u52a0\u4e0a\u5b83\u7684\u865a\u5b50\u6811\u5927\u5c0f\uff0c\u5982\u679c\u5b83\u662f\u5b57\u7b26\u4e32\u7684\u524d\u7f00\uff0c\u518d\u52a0\u4e00\u3002\n\n------------\n\n# Code\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 1200050;\nconst int INF = 999999999;\n\nint fa[N], son[N][26], last = 1, cnt = 1, len[N], rev[N], n, mask, ans;\n\nchar s[3000050];\n\nstruct LCT\n{\n\tint son[2], siz, lsiz, fa, v;\n} tr[N + 50];\n\nbool Is(int x)\n{\n\treturn tr[tr[x].fa].son[1] != x && tr[tr[x].fa].son[0] != x;\n}\n\nint Get(int x)\n{\n\treturn tr[tr[x].fa].son[1] == x;\n}\n\nvoid Rv(int x)\n{\n\trev[x] ^= 1;\n\tswap(tr[x].son[0], tr[x].son[1]);\n\treturn;\n}\n\nvoid Pushdown(int x)\n{\n\tif (rev[x])\n\t{\n\t\tif (tr[x].son[0]) Rv(tr[x].son[0]);\n\t\tif (tr[x].son[1]) Rv(tr[x].son[1]);\n\t\trev[x] = 0;\n\t\treturn;\n\t}\n}\nvoid Update(int x)\n{\n\ttr[x].siz = tr[tr[x].son[0]].siz + tr[tr[x].son[1]].siz + tr[x].lsiz + tr[x].v;\n\treturn;\n}\n\nvoid Rotate(int x)\n{\n\tint f = tr[x].fa, p = tr[f].fa, d = Get(x);\n\tif (!Is(f)) tr[p].son[Get(f)] = x;\n\ttr[x].fa = p;\n\ttr[f].son[d] = tr[x].son[d ^ 1];\n\tif (tr[f].son[d]) tr[tr[f].son[d]].fa = f;\n\ttr[x].son[d ^ 1] = f;\n\ttr[f].fa = x;\n\tUpdate(f); \n\tUpdate(x);\n\treturn;\n}//\u65cb\u8f6c\uff0c\u8bb0\u5f97\u5224\u65ad\u7236\u4eb2\u662f\u4e0d\u662fsplay\u7684\u6839 \n\nvoid Calc(int x)\n{\n\tif (!Is(x)) Calc(tr[x].fa);\n\tPushdown(x);\n\treturn;\n}//\u9012\u5f52\u5904\u7406\u6807\u8bb0 \n\nvoid Splay(int x)\n{\n\tCalc(x);\n\twhile (!Is(x))\n\t{\n\t\tint f = tr[x].fa;\n\t\tif (!Is(f))\n\t\t\tGet(f) ^ Get(x) ? Rotate(x) : Rotate(f);\n\t\tRotate(x);\n\t}\n\treturn;\n}\n\nvoid Access(int x)\n{\n\tint p = 0;\n\twhile (x)\n\t{\n\t\tSplay(x);\n\t\ttr[x].lsiz += tr[tr[x].son[1]].siz - tr[p].siz;\n\t\ttr[x].son[1] = p;\n\t\tUpdate(x);\n\t\tp = x;\n\t\tx = tr[x].fa;\n\t}\n\treturn;\n}\n\nvoid Makeroot(int x)\n{\n\tAccess(x);\n\tSplay(x);\n\tRv(x); \n\treturn;\n}\n\nint Findroot(int x)\n{\n\tAccess(x);\n\tSplay(x);\n\twhile (tr[x].son[0]) Pushdown(x), x = tr[x].son[0];\n\tSplay(x);\n\treturn x;\n}\n\nvoid Link(int u, int v)\n{\n\tMakeroot(u);\n\tif (Findroot(v) == u) return;\n\ttr[u].fa = v; tr[v].lsiz += tr[u].siz;\n\tUpdate(v);\n\treturn;\n}\n\nvoid Cut(int u, int v)\n{\n\tMakeroot(u);\n\tif (Findroot(v) != u || tr[v].fa != u || tr[v].son[0]) return;\n\ttr[u].son[1] = tr[v].fa = 0;\n\tUpdate(u);\n\treturn;\n}\n\nint Askk(int x)\n{\n\tMakeroot(1); Access(x); Splay(x);\n\treturn tr[x].lsiz + tr[x].v + tr[tr[x].son[1]].siz;\n}\n\nvoid Init(int x)\n{\n\ttr[x].siz = tr[x].v = 1;\n\treturn;\n}\n\nvoid Change(int x, int y)\n{\n\tif (fa[x]) Cut(x, fa[x]);\n\tLink(x, fa[x] = y);\n\treturn;\n}\n\nvoid Insert(int c)\n{\n\tint p = last, ne = last = ++cnt;\n\tlen[ne] = len[p] + 1; Init(ne);\n\twhile (p && !son[p][c]) son[p][c] = ne, p = fa[p];\n\tif (!p) { Change(ne, 1); return; }\n\tint q = son[p][c];\n\tif (len[q] == len[p] + 1) { Change(ne, q); return; }\n\tint sp = ++cnt;\n\tfor (int i = 0; i < 26; i++) son[sp][i] = son[q][i];\n\tlen[sp] = len[p] + 1;\n\tChange(sp, fa[q]);\n\tChange(q, sp); Change(ne, sp);\n\twhile (p && son[p][c] == q) son[p][c] = sp, p = fa[p];\n\treturn;\n}\n\nvoid Work()\n{\n\tscanf(\"%s\", s); n = strlen(s);\n//\treturn;\n\tint rec = mask;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\trec = (rec * 131 + i) % n;\n\t\tswap(s[rec], s[i]);\n\t}\n\treturn;\n}\n\nvoid Ask()\n{\n\tint now = 1, ans = 0;\n\tWork();\n\tfor (int i = 0; i < n && now; i++) now = son[now][s[i] - 'A'];\n\tif (!now) puts(\"0\");\n\telse printf(\"%d\\n\", ans = Askk(now));\n\tmask ^= ans;\n\treturn;\n}\n\nvoid Add()\n{\n\tWork();\n\tfor (int i = 0; i < n; i++) Insert(s[i] - 'A');\n\treturn;\n}\n\nint main()\n{\n\tint t;\n\tchar st[10];\n\tscanf(\"%d\", &t);\n\tscanf(\"%s\", s + 1);\n\tn = strlen(s + 1);\n\tfor (int i = 1; i <= n; i++) Insert(s[i] - 'A');\n\twhile (t--)\n\t{\n\t\tscanf(\"%s\", st + 1);\n\t\tif (st[1] == 'Q') Ask();\n\t\telse Add();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1592263348,
        "uid": 73983,
        "name": "Infiltrator",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "\u4e3a\u4e86\u53ef\u80fd\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\uff0c\u5efa\u8bae\u5728 luogu \u535a\u5ba2\u6216\u8005 [\u8fd9\u91cc](https://www.yijan.co/p5212-substring/) \u67e5\u770b\u3002\n\n\u8003\u8651\u5982\u679c\u4e0d\u5f3a\u5236\u5728\u7ebf\uff0c\u6211\u4eec\u53ef\u4ee5\u5efa SAM \uff0c\u4e8e\u662f SAM \u4e00\u4e2a\u70b9\u51fa\u73b0\u6b21\u6570\u5c31\u662f\u524d\u7f00\u6811\u5b50\u6811\u548c\u3002\n\n\u5982\u679c\u5f3a\u5236\u5728\u7ebf\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u5f97\u52a8\u6001\u7ef4\u62a4\u524d\u7f00\u6811\uff0c\u4e00\u4e2a\u7b80\u5355\u60f3\u6cd5\u5c31\u662f\u62ff LCT \u6765\u7ef4\u62a4\u524d\u7f00\u6811\u3002\n\n\u4e8e\u662f\u6211\u4eec\u9700\u8981\u5199\u4e00\u4e2a LCT \uff0c\u4f46\u662f\u663e\u7136\u662f\u4e0d\u9700\u8981\u652f\u6301 `makeroot` \u7684\u3002\n\n\u540c\u65f6\u6211\u4eec\u8fd8\u9700\u8981\u6c42\u5b50\u6811\u548c\u3002\u53ef\u4ee5\u5728 LCT \u4e0a\u7ef4\u62a4\u5b50\u6811\u548c\uff0c\u5177\u4f53\u505a\u6cd5\u5c31\u662f\u63d2\u5165\u4e00\u4e2a\u70b9\u540e\u76f4\u63a5\u7ed9\u8fd9\u4e2a\u70b9\u5230\u6839\u7684\u94fe\u5168\u90e8 `+c` \u3002\u8fd9\u4e2a\u4e1c\u897f\u662f**\u4e0d\u9700\u8981 `pushup` \u7684**\uff0c\u5220\u9664\u4e00\u4e2a\u70b9\u5c31\u662f\u4e00\u4e2a\u70b9 `access` \u540e\u5de6\u5b50\u6811\u5185\u7684\u70b9\u5168\u90e8 `-c`\uff08\u4e5f\u5c31\u662f\u5b83\u5230\u6839\u7684\u8def\u5f84 `-c`\uff09\u5373\u53ef\u3002\u7ef4\u62a4\u8fd9\u4e9b\u64cd\u4f5c\u53ea\u9700\u8981\u4e00\u4e2a `+` tag\u5373\u53ef\u3002\n\n```cpp\n#include \"iostream\"\n#include \"algorithm\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"cmath\"\n#include \"vector\"\n#include \"map\"\n#include \"set\"\n#include \"queue\"\nusing namespace std;\n#define MAXN 1300006\n//#define int long long\n#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)\n#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define all(x) (x).begin() , (x).end()\n#define mem( a ) memset( a , 0 , sizeof a )\ntypedef long long ll;\nint n , m;\nchar ch[MAXN];\n\nnamespace LCT {\n\tint ch[MAXN][2] , fa[MAXN] , S[MAXN] , lz[MAXN];\n\tinline bool notroot( int x ) {\n\t\treturn ch[fa[x]][0] == x || ch[fa[x]][1] == x;\n\t}\n\tinline void add( int x , int c ) {\n\t\tif( x )\n\t\t\tlz[x] += c , S[x] += c;\n\t}\n\tinline void pd( int x ) {\n\t\tif( lz[x] ) {\n\t\t\tif( ch[x][0] ) add( ch[x][0] , lz[x] );\n\t\t\tif( ch[x][1] ) add( ch[x][1] , lz[x] );\n\t\t\tlz[x] = 0;\n\t\t}\n\t}\n\tinline void rotate( int x ) {\n\t\tint f = fa[x] , g = fa[f] , w = ch[fa[x]][1] == x;\n\t\tint wf = ch[g][1]==f , k = ch[x][w^1];\n\t\tif( notroot(f) ) ch[g][wf] = x; ch[f][w] = k , ch[x][w^1] = f;\n\t\tfa[f] = x , fa[k] = f , fa[x] = g;\n\t}\n\tvoid update( int x ) {\n\t\tif( notroot( x ) ) update( fa[x] );\n\t\tpd( x );\n\t}\n\tvoid splay( int x ) {\n\t\tupdate( x );\n\t\tint f , g;\n\t\twhile( notroot( x ) ) {\n\t\t\tf = fa[x] , g = fa[f];\n\t\t\tif( notroot( f ) ) \n\t\t\t\trotate( (ch[f][0]==x)^(ch[g][0]==f) ? x : f );\n\t\t\trotate( x );\n\t\t}\n\t}\n\tvoid ac( int x ) {\n\t\tfor( int p = 0 ; x ; ( p = x , x = fa[x] ) ) \n\t\t\tsplay( x ) , ch[x][1] = p;\n\t}\n\tvoid link( int u , int v ) {\n\t\tfa[u] = v;\n\t\tac( v ) , splay( v );\n\t\tadd( v , S[u] );\n\t}\n\tvoid cut( int u ) { // cut the edge from u to par u\n\t\tac( u ) , splay( u );\n\t\tadd( ch[u][0] , -S[u] );\n\t\tfa[ch[u][0]] = 0;\n\t\tch[u][0] = 0;\n\t}\n}\n\nstruct SAM {\n    int son[MAXN][26] , par[MAXN] , len[MAXN];\n    int head[MAXN] , to[MAXN] , nex[MAXN] , ecn;\n    int num[MAXN];\n    int lst , cnt;\n    void init( ) {\n        // initialize\n        lst = cnt = 1 , ecn = 0;\n    }\n    void ade( int u , int v ) {\n        to[++ ecn] = v , nex[ecn] = head[u] , head[u] = ecn;\n    }\n    void addall( ) {\n        for( int i = 1 ; i <= cnt ; ++ i ) ade( par[i] , i );\n    }\n    void ins( int x ) {\n        using namespace LCT;\n        int cur = ++ cnt;\n        len[cur] = len[lst] + 1 , num[cur] = 1;\n        S[cur] = 1;\n        int p = lst;\n        while( p && !son[p][x] ) son[p][x] = cur , p = par[p];\n        if( !p ) par[cur] = 1 , link( cur , 1 );\n        else {\n            int q = son[p][x];\n            if( len[q] == len[p] + 1 ) par[cur] = q , link( cur , q );\n            else {\n                int ct = ++ cnt;\n                len[ct] = len[p] + 1 , par[ct] = par[q] , link( ct , par[q] );\n                cut( q );\n                memcpy( son[ct] , son[q] , sizeof son[q] );\n                par[q] = par[cur] = ct , link( q , ct ) , link( cur , ct );\n                for( ; son[p][x] == q ; p = par[p] ) son[p][x] = ct;\n            }\n        }\n        lst = cur;\n    }\n    int wkr( char* ch , int u ) {\n    \tif( !u ) return 0;\n    \tif( ch[0] != 0 ) return wkr( ch + 1 , son[u][ch[0] - 'A'] );\n    \telse {\n    \t\tusing namespace LCT;\n    \t\tsplay( u );\n    \t\treturn S[u];\n\t\t}\n\t}\n} S ;\n\nvoid decodeWithMask(char* s, int len , int mask) {\n\tfor (int j = 0; j < len; j++ ) {\n\t\tmask = (mask * 131 + j) % len;\n\t\tchar t = s[j];\n\t\ts[j] = s[mask];\n\t\ts[mask] = t;\n\t}\n}\n\nvoid solve() {\n\tcin >> m;\n\tscanf(\"%s\",ch + 1);\n\tn = strlen( ch + 1 );\n\tS.init();\n\trep( i , 1 , n ) \n\t\tS.ins( ch[i] - 'A' );\n\tchar op[10];\n\tint mask = 0 , ans = 0;\n\twhile( m-- ) {\n\t\tscanf(\"%s\",op);\n\t\tif( op[0] == 'A' ) {\n\t\t\tscanf(\"%s\",ch + 1);\n\t\t\tn = strlen( ch + 1 );\n\t\t\tdecodeWithMask( ch + 1 , n , mask );\n\t\t\trep( i , 1 , n ) S.ins( ch[i] - 'A' );\n\t\t} else {\n\t\t\t\n\t\t\tscanf(\"%s\",ch + 1);\n\t\t\tn = strlen( ch + 1 );\n\t\t\tdecodeWithMask( ch + 1 , n , mask );\n\t\t\tprintf(\"%d\\n\",ans = S.wkr( ch + 1 , 1 ) );\n\t\t\tmask ^= ans;\n\t\t}\n\t}\n}\n\nsigned main() {\n//    int T;cin >> T;while( T-- ) solve();\n    solve();\n}\n\n\n```\n\n",
        "postTime": 1588208316,
        "uid": 63398,
        "name": "yijan",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u6233\u8fd9\u91cc\u54e6~~](https://blog.csdn.net/qq_42886072/article/details/105185379)\n# \u524d\u8a00\n\u592a\u4e45\u672a\u6253LCT\u4e86,\u6837\u4f8b\u53c8\u592a\u83dc\u4e86,\u8ba9\u6211\u8c03\u8bd5\u5f97\u5feb\u53bb\u4e16\u4e86.\n# \u6b63\u9898\n\u9996\u5148,\u9ed8\u8ba4\u4f60\u4f1a\u4e0d\u5f3a\u5236\u5728\u7ebf\u4e14\u6ca1\u6709ADD\u7684\u60c5\u51b5.~~(\u4e0d\u4f1a\u4f60\u6765\u505a\u8fd9\u9898\u5e72\u561b)~~\n\n\u505a\u9898\u7684\u65f6\u5019,\u7b2c\u4e00\u773c\u5c45\u7136\u60f3\u5230\u6811\u5256.\n\u7136\u9e45,\u6811\u5256\u53ea\u80fd\u5904\u7406\u9759\u6001\u95ee\u9898.\n\n\u90a3\u80fd\u5904\u7406\u5728\u7ebf\u95ee\u9898\u7684\u4e14\u53ef\u80fd\u5b9e\u73b0\u6811\u4e0a\u8def\u5f84\u52a0\u7684\u662f\u5565\u5462?\n\n\u6ca1\u9519,\u5c31\u662fLCT.\n\n\u5148\u5b89\u5229\u4e00\u4e2a[\u6a21\u677f](https://blog.csdn.net/qq_42886072/article/details/105181973).\n\n\u7136\u540eLCT\u7ef4\u62a4\u7684\u4e1c\u897f\u4e5f\u975e\u5e38\u7b80\u5355,\u5c31\u662f\u4e00\u4e2a\u5b50\u6811\u52a0\u548c\u81ea\u8eab\u70b9\u503c.\n\n\u4e3b\u8981\u770b\u4ee3\u7801\u5427~~~:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define gc getchar()\nusing namespace std;\nconst int N=2e6+10;\n\ntemplate<class o> void qr(o &x) {\n\tchar c=gc; x=0; int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=gc;}\n\twhile(isdigit(c)) x=x*10+c-'0',c=gc;\n\tx*=f;\n}\ntemplate<class o> void qw(o x) {\n\tif(x/10) qw(x/10);\n\tputchar(x%10+'0');\n}\ntemplate<class o> void pr1(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); putchar(' ');\n}\ntemplate<class o> void pr2(o x) {\n\tif(x<0)x=-x,putchar('-');\n\tqw(x); puts(\"\");\n}\n\nnamespace LCT {\n\t#define lc ch[0][x]\n\t#define rc ch[1][x]\n\tint ch[2][N],fa[N],ad[N],f[N];\n\tint sta[N],top;\n\tbool son(int x) {return x==ch[1][fa[x]];}\n\tbool isroot(int x) {return x!=ch[son(x)][fa[x]];}\n\tvoid pushdown(int x) {\n\t\tif(ad[x]) {\n\t\t\tint y=ad[x];\n\t\t\tad[lc]+=y;\n\t\t\tf[lc]+=y;\n\t\t\tad[rc]+=y;\n\t\t\tf[rc]+=y;\n\t\t\tad[x]=0;\n\t\t}\n\t}\n\tvoid rotate(int x) {\n\t\tint y=fa[x],z=fa[y],c=son(x);\n\t\tch[c][y]=ch[c^1][x]; if(ch[c][y]) fa[ch[c][y]]=y;\n\t\tfa[x]=z; if(!isroot(y)) ch[son(y)][z]=x;\n\t\tch[c^1][x]=y; fa[y]=x;\n\t}\n\tvoid splay(int x) {\n\t\tsta[top=1]=x;\n\t\tfor(int i=x;!isroot(i);i=fa[i]) sta[++top]=fa[i];\n\t\twhile(top) pushdown(sta[top--]);\n\t\tfor(int y=fa[x];!isroot(x);rotate(x),y=fa[x])\n\t\t\tif(!isroot(y)) son(x)^son(y)?rotate(x):rotate(y);\n\t}\n\tvoid access(int x) {\n\t\tfor(int y=0;x;x=fa[y=x])\n\t\t\tsplay(x),rc=y;\n\t}\n\tvoid cut(int x) {\n\t\taccess(x); splay(x);\n\t\tf[lc]-=f[x]; ad[lc]-=f[x]; \n\t\tfa[lc]=0; lc=0;\n\t}\n\tvoid link(int x,int y) {\n\t\taccess(y); splay(y); access(x);\n\t\tch[1][y]=x; fa[x]=y;\n\t\tad[y]+=f[x]; f[y]+=f[x]; f[x]=0;\n\t}\n\tint calc(int x) {access(x); splay(x); return f[x];}\n}\n\nnamespace SAM {\n\tint last=1,tot=1;\n\tstruct node{int fa,len,v[2];}tr[N];\n\tvoid add(int c) {\n\t\tint p=last,x=last=++tot; tr[x].len=tr[p].len+1;\n\t\tfor(\t;p&&!tr[p].v[c];p=tr[p].fa) tr[p].v[c]=x;\n\t\tif(!p) tr[x].fa=1;\n\t\telse {\n\t\t\tint q=tr[p].v[c],y;\n\t\t\tif(tr[p].len+1==tr[q].len) tr[x].fa=q;\n\t\t\telse {\n\t\t\t\ttr[y=++tot]=tr[q];\n\t\t\t\ttr[y].len=tr[p].len+1;\n//\t\t\t\tLCT::f[y]=LCT::calc(q);\u8fd9\u53e5\u8bdd\u662f\u9519\u8bef\u7684,\u53ef\u662f\u52a0\u4e86\u5c45\u7136\u8fd8\u670981\u5206. \n\t\t\t\tLCT::link(y,tr[y].fa);\n\t\t\t\tLCT::cut(q);//\u9694\u65adq\u4e0e\u5176\u7236\u4eb2\u7684\u8054\u7cfb \n\t\t\t\ttr[q].fa=tr[x].fa=y;\n\t\t\t\tLCT::link(q,y);\n\t\t\t\tfor(\t;p&&tr[p].v[c]==q;p=tr[p].fa) tr[p].v[c]=y;\n\t\t\t}\n\t\t}\n\t\tLCT::f[x]=1;\n\t\tLCT::link(x,tr[x].fa);\n\t}\n}\n\nchar op[10],s[N];\nint m,n,ans;\n\nvoid decodeWithMask(int mask) {\n\tscanf(\"%s\",s);\n\tm=strlen(s);\n\tfor (int j = 0; j < m; j++) {\n\t\tmask = (mask * 131 + j) % m;\n\t\tswap(s[mask],s[j]);\n\t}\n}\nint mask;\n\n\nint main() {\n\tqr(n); scanf(\"%s\",s);\n\tfor(int i=0;s[i];i++) SAM::add(s[i]-'A');\n\twhile(n--) {\n\t\tscanf(\"%s\",op);\n\t\tdecodeWithMask(mask);\n\t\tif(op[0]=='A') \n\t\t\tfor(int i=0;s[i];i++) \n\t\t\t\tSAM::add(s[i]-'A');\n\t\telse {\n\t\t\tint p=1;\n\t\t\tfor(int i=0;s[i]&&p;i++) p=SAM::tr[p].v[s[i]-'A'];\n\t\t\tif(p)ans=LCT::calc(p);\n\t\t\telse ans=0;\n\t\t\tmask^=ans;\n\t\t\tpr2(ans);\n\t\t}\n\t}\n\treturn 0;\n\n```\n",
        "postTime": 1585484843,
        "uid": 118826,
        "name": "2018LZY",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5212 \u3010SubString\u3011"
    }
]