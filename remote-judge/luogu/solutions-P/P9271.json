[
    {
        "content": "\u7531\u4e8e\u505c\u8f66\u56fe\u662f**\u9012\u5f52\u5b9a\u4e49**\u7684\uff0c\u56e0\u6b64\u6709\u5fc5\u8981\u4e3a\u95ee\u9898\u627e\u5230**\u9012\u5f52\u516c\u5f0f**\u3002\u8003\u8651\u4e32\u8054\u548c\u5e76\u8054\u7ec4\u5408\u540e\uff0c\u9700\u8981\u8c03\u7528\u5176\u4ed6\u9700\u8981\u8ba1\u7b97\u7684\u51fd\u6570\u3002\u5bf9\u4e8e\u7ed9\u5b9a\u505c\u8f66\u56fe\u7684\u6240\u6709\u5b50\u56fe $G$\uff0c\u8ba1\u7b97\u5bf9\u5e94\u7684\u4e0b\u9762\u56db\u4e2a\u51fd\u6570\u503c\uff0c\u6bcf\u4e2a\u51fd\u6570\u90fd**\u4ee3\u8868\u7684\u662f\u53ef\u4ee5\u505c\u653e\u5728\u56fe $G$ \u4e2d\u7684\u6c7d\u8f66\u603b\u6570**\uff08\u5305\u62ec\u5df2\u7ecf\u505c\u5728\u90a3\u91cc\u7684\u6c7d\u8f66\uff09\uff0c\u4f7f\u6bcf\u8f86\u505c\u653e\u7684\u6c7d\u8f66\u90fd\u80fd\u4ee5\u67d0\u79cd\u65b9\u5f0f\u4ece $G$ \u4e2d\u51fa\u53bb\u3002\u8fd9\u4e9b\u51fd\u6570\u4e4b\u95f4\u7684\u533a\u522b\u4e3b\u8981\u5728\u4e8e\u6c7d\u8f66\u5982\u4f55\u7cbe\u786e\u5730\u4ece $G$ \u4e2d\u51fa\u53bb\uff1a\n- $\\texttt{FORWARD[G]}$: \u6bcf\u8f86\u505c\u653e\u7684\u6c7d\u8f66\u90fd\u80fd\u901a\u8fc7 $G$ \u7684\u6e90\u8282\u70b9\u79bb\u5f00\u3002\n- $\\texttt{BACKWARD[G]}$: \u6bcf\u8f86\u505c\u653e\u7684\u6c7d\u8f66\u90fd\u80fd\u901a\u8fc7 $G$ \u7684\u7ec8\u7aef\u8282\u70b9\u79bb\u5f00\u3002\n- $\\texttt{BOTH[G]}$: \u6bcf\u8f86\u505c\u653e\u7684\u6c7d\u8f66\u53ef\u4ee5\u901a\u8fc7 $G$ \u7684\u6e90\u8282\u70b9\u6216\u7ec8\u7aef\u8282\u70b9\u79bb\u5f00\u3002\n- $\\texttt{THROUGH[G]}$: \u4e0e\u524d\u4e00\u79cd\u60c5\u51b5\u76f8\u540c\uff0c\u4f46\u662f\u53e6\u5916\u8fd8\u53ef\u4ee5\u4ece $G$ \u7684\u6e90\u5230\u7ec8\u7aef\uff0c\u5373\u5b58\u5728\u7531\u7a7a\u505c\u8f66\u4f4d\u7ec4\u6210\u7684\u8def\u5f84\u8fde\u63a5 $s$ \u548c $t$\u3002\n\n\u5728\u4e0a\u8ff0\u6240\u6709\u51fd\u6570\u4e2d\uff0c\u53ef\u4ee5\u4f7f\u7528\u7279\u6b8a\u7b26\u53f7\u6216\u6570\u5b57\uff08\u4f8b\u5982 $-\\infty$\uff09\u6765\u8868\u793a\u5bf9\u4e8e\u5df2\u7ecf\u505c\u653e\u5728 $G$ \u4e2d\u7684\u8f66\u8f86\uff0c\u600e\u4e48\u6837\u90fd\u65e0\u6cd5\u5230\u8fbe\u8fd9\u79cd\u60c5\u51b5\u3002\n\n\u6b64\u5916\uff0c\u4e3a\u4e86\u4f7f\u516c\u5f0f\u66f4\u7b80\u5355\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u5bf9\u4e8e\u5b50\u56fe $G$ \u7684\u51fd\u6570\uff1a\n- $\\texttt{NONE[G]}$: \u5982\u679c $G$ \u4e3a\u7a7a\uff0c\u5219\u4e3a $0$\uff0c\u5426\u5219\u4e3a $-\\infty$\u3002\n\n\u73b0\u5728\uff0c\u9700\u8981\u4e3a\u4e0a\u8ff0\u6bcf\u4e2a\u51fd\u6570\u627e\u5230\u9012\u5f52\u516c\u5f0f\u3002\u8fd9\u91cc\u8be6\u7ec6\u89e3\u91ca\u4e86\u51fd\u6570 $\\texttt{FORWARD}$ \u7684\u9012\u5f52\u516c\u5f0f\uff0c\u5e76\u5217\u51fa\u4e86\u5176\u4ed6\u51fd\u6570\u7684\u516c\u5f0f\u3002\u5927\u5bb6\u53ef\u4ee5\u81ea\u884c\u9a8c\u8bc1\u5176\u4ed6\u516c\u5f0f\u3002\u6b64\u5916\uff0c\u4f1a\u7528\u5230 $\\texttt{THROUGH}\\le\\texttt{FORWARD},\\texttt{BACKWARD}\\le\\texttt{BOTH}$ \u8fd9\u4e2a\u5f88\u5bb9\u6613\u63a8\u51fa\u7684\u5f0f\u5b50\uff0c\u6765\u51cf\u5c11\u9700\u8981\u8003\u8651\u7684\u60c5\u51b5\u6570\u91cf\u3002\u8fd9\u91cc\u91cd\u7533\u4e00\u904d\uff0c\u6bcf\u4e2a\u51fd\u6570\u90fd**\u4ee3\u8868\u7684\u662f\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u53ef\u4ee5\u505c\u653e\u5728\u56fe $G$ \u4e2d\u7684\u6c7d\u8f66\u603b\u6570**\u3002\u5728\u4e0b\u6587\u4e2d\uff0c\u4e94\u4e2a\u51fd\u6570\u5206\u522b\u7b80\u79f0\u4e3a $\\texttt{F,B,A,T,N}$\u3002\n\n1. \u5982\u679c\u8be5\u56fe\u53ea\u5305\u542b\u4e00\u4e2a\u8282\u70b9\uff0c\u5219 $\\texttt{F,B,A}$ \u7684\u503c\u59cb\u7ec8\u4e3a $1$\uff0c\u800c $\\texttt{T,N}$ \u7684\u503c\u8981\u4e48\u4e3a $0$\uff08\u5982\u679c\u8fd9\u4e2a\u8282\u70b9\u6ca1\u6709\u8f66\uff09\uff0c\u8981\u4e48\u4e3a $-\\infty$\uff08\u8fd9\u4e2a\u8282\u70b9\u505c\u4e86\u8f66\uff09\u3002\n2. \u5047\u8bbe\u6211\u4eec\u4e32\u8054 $G_1,G_2$ \u5f97\u5230 $G$\uff0c\u5e76\u60f3\u8981\u8ba1\u7b97\u5b83\u7684 $\\texttt{F}$ \u51fd\u6570\u503c\u3002\u6709\u4e24\u79cd\u53ef\u80fd\u6027\uff1a\u81f3\u5c11\u6709\u4e00\u8f86\u6c7d\u8f66\u505c\u5728 $G_2$ \u4e2d\uff0c\u6216\u8005 $G_2$ \u4e3a\u7a7a\u3002\u5728\u7b2c\u4e00\u79cd\u60c5\u51b5\u4e0b\uff0c\u5fc5\u987b\u8981\u6709\u4e00\u6761\u8def\u5f84\u8ba9 $G_1$ \u4e2d\u7684\u6c7d\u8f66\u5168\u90e8\u5728\u6e90\u70b9\u9000\u51fa\uff0c\u56e0\u6b64\uff0c\u5728\u6b64\u60c5\u51b5\u4e0b\u6700\u591a\u53ef\u4ee5\u505c\u653e\u7684\u6c7d\u8f66\u6570\u91cf\u4e3a $\\texttt{T(}G_1\\texttt{)+F(}G_2\\texttt{)}$\u3002\u5728\u7b2c\u4e8c\u79cd\u60c5\u51b5\u4e0b\uff0c\u6700\u591a\u53ef\u4ee5\u505c\u653e\u7684\u6c7d\u8f66\u6570\u91cf\u662f $\\texttt{F(}G_1\\texttt{)+N(}G_2\\texttt{)}$\uff0c\u56e0\u4e3a $G_2$ \u5fc5\u987b\u4e3a\u7a7a\uff0c\u5e76\u4e14 $\\texttt{F(}G_1\\texttt{)}$ \u7ed9\u51fa\u4e86\u8be5\u60c5\u51b5\u4e0b\u6700\u4f73\u7684\u5b89\u6392\u3002\n3. \u73b0\u5728\uff0c\u5047\u8bbe $G$ \u662f\u5e76\u8054\u7ec4\u5408\u7684\u7ed3\u679c\uff0c\u5e76\u4e14\u6211\u4eec\u8981\u8ba1\u7b97\u51fd\u6570 $\\texttt{F}$ \u7684\u503c\u3002\u5e76\u8054\u7ec4\u5408\u66f4\u4e3a\u590d\u6742\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd8\u9700\u8981\u8003\u8651\u65b0\u6dfb\u52a0\u7684\u6e90\u548c\u7ec8\u7aef\u662f\u600e\u4e48\u6837\u7684\u3002\u6839\u636e\u6e90\u548c\u7ec8\u7aef\u662f\u5426\u505c\u4e86\u8f66\uff0c\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff1a\n   1. \u6e90\u88ab\u5360\u7528\uff0c\u7ec8\u70b9\u7a7a\u95f2\uff0c\u6b64\u65f6\uff0c$G_1$ \u548c $G_2$ \u90fd\u5fc5\u987b\u4e3a\u7a7a\u3002$\\texttt{F(G)}$ \u7684\u503c\u4e3a $1+\\texttt{N(}G_1\\texttt{)}+\\texttt{N(}G_2\\texttt{)}$\u3002\n   2. \u6e90\u548c\u7ec8\u70b9\u90fd\u662f\u7a7a\u95f2\u7684\uff1a\u73b0\u5728\uff0c\u6765\u81ea $G_1$ \u548c $G_2$ \u7684\u6c7d\u8f66\u53ef\u4ee5\u76f4\u63a5\u5411\u524d\u9000\u51fa\uff0c\u6216\u8005\u5b83\u4eec\u53ef\u4ee5\u4ece\u5176\u4e2d\u4e00\u4e2a\u7684\u4e24\u4fa7\u9000\u51fa\uff0c\u800c\u53e6\u4e00\u4e2a\u5219\u5177\u6709\u4ece\u7ec8\u7aef\u5230\u6c47\u70b9\u7684\u8def\u5f84\u3002\u56e0\u6b64\uff0c$\\texttt{F(G)}$ \u7684\u503c\u662f $\\texttt{F(}G_1\\texttt{)}+\\texttt{F(}G_2\\texttt{)},\\texttt{B(}G_1\\texttt{)}+\\texttt{T(}G_2\\texttt{)},\\texttt{T(}G_1\\texttt{)}+\\texttt{B(}G_2\\texttt{)}$ \u4e2d\u6700\u5927\u7684\u4e00\u4e2a\u3002\n   3. \u6e90\u7a7a\u95f2\uff0c\u7ec8\u70b9\u88ab\u5360\u7528\uff1a\u5176\u4e2d\u4e00\u4e2a\u5b50\u56fe\u5fc5\u987b\u8981\u4fdd\u8bc1\u505c\u5728\u7ec8\u70b9\u7684\u8f66\u8f86\u53ef\u4ee5\u9000\u51fa\u5230\u6e90\uff0c\u800c\u53e6\u4e00\u4e2a\u5b50\u56fe\u7684\u6240\u6709\u6c7d\u8f66\u90fd\u9700\u8981\u5411\u524d\u9000\u51fa\u3002\u56e0\u6b64\uff0c$\\texttt{F(G)}$ \u7684\u503c\u4e3a $1+\\texttt{T(}G_1\\texttt{)}+\\texttt{F(}G_2\\texttt{)},1+\\texttt{F(}G_1\\texttt{)}+\\texttt{T(}G_2\\texttt{)}$ \u4e2d\u66f4\u5927\u7684\u4e00\u4e2a\u3002\n\n\u5373\u4f7f\u627e\u5230\u4e86\u9012\u5f52\u8ba1\u7b97\u51fd\u6570\u7684\u6240\u6709\u53ef\u80fd\u89c4\u5219\uff0c\u7531\u4e8e\u9700\u8981\u8003\u8651\u7684\u60c5\u51b5\u6570\u91cf\u5de8\u5927\uff0c\u5b9e\u73b0\uff08\u7279\u522b\u662f\u91cd\u6784\u6700\u4f18\u6392\u5217\u65f6\uff09\u4ecd\u7136\u5bb9\u6613\u51fa\u9519\u3002\u4e00\u4e2a\u5bc4\u5de7\u53ef\u4ee5\u6781\u5927\u5730\u7b80\u5316\u5b83\u7684\u5b9e\u73b0\uff0c\u90a3\u5c31\u662f\u4f7f\u7528\u5e38\u91cf\u6765\u5b9a\u4e49\u4e0a\u8ff0\u9012\u5f52\u89c4\u5219\uff0c\u89c1\u4e0b\u56fe\u3002\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/d0tcpyxn.png)\n\n\u4e0a\u8ff0\u8868\u683c\u5c06\u9012\u5f52\u8ba1\u7b97\u51fd\u6570\u7684\u89c4\u5219\u7f16\u7801\u4e3a\u5728 C++ \u4e2d\u7684\u7b80\u5355\u6574\u6570\u6570\u7ec4\u3002\u4f8b\u5982\uff0c\u7b2c\u4e8c\u5217\u4e2d\u7684 `{FORWARD\uff0c0\uff0c1\uff0cTHROUGH\uff0cFORWARD}` \u8868\u793a\u5f53 $G$ \u662f $G_1$ \u548c $G_2$ \u7684\u5e76\u884c\u7ec4\u5408\uff0c\u5e76\u4e14\u6b63\u5728\u8ba1\u7b97 $\\texttt{F}$ \u51fd\u6570\u65f6\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u7ec8\u70b9\u662f\u5426\u4e3a\u7a7a\uff0c\u7ec8\u7aef\u662f\u5426\u88ab\u5360\u7528\uff0c$G_1$ \u7684 $\\texttt{T}$ \u503c\u662f\u591a\u5c11\uff0c\u4ee5\u53ca $G_2$ \u7684 $\\texttt{F}$ \u503c\u662f\u51e0\u3002\n\n\u901a\u8fc7\u4e0a\u8ff0\u5b9a\u4e49\u7684\u5e38\u91cf\uff0c\u89e3\u51b3\u65b9\u6848\u53d8\u5f97\u7b80\u5355\u4f46\u4ecd\u7136\u5f88\u957f\uff08\u4e0d\u8fc7\u8fd8\u662f\u597d\u591a\u4e86\uff09\uff0c\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a\u89e3\u6790\u5668\u6765\u5c06\u7f16\u7801\u8f6c\u6362\u4e3a\u7c7b\u4f3c\u6811\u5f62\u7ed3\u6784\u7684\u5f62\u5f0f\uff0c\u7136\u540e\u9700\u8981\u9012\u5f52\u904d\u5386\u8be5\u6811\u6765\u8ba1\u7b97\u6bcf\u4e2a\u51fd\u6570\u3002\u4e3a\u4e86\u91cd\u6784\u6700\u4f18\u6392\u5217\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u4f4f\u7528\u4e8e\u83b7\u5f97\u76f8\u5e94\u51fd\u6570\u6700\u5927\u503c\u7684\u89c4\u5219\u7d22\u5f15\u3002\n\n\u4e0b\u9762\u662f\u5b98\u65b9\u9898\u89e3\u4ee3\u7801\uff1a\n\n```cpp\n// CEOI 2013 - Task: Splot - Solution\n// Author: Ante Derek\n\n#include <cstdio>\n#include <cassert>\n\nusing namespace std;\n\nconst int MAX = 1000000;\nconst int NEGINF = -(1<<28);\nconst int CFF_0102 = 542457;\n\nenum FunctionType {FORWARD=0, BACKWARD=1, BOTH=2, THROUGH=3, NONE=4};\n\nstatic const int S_RULE[][3] = {\n  {FORWARD, FORWARD, NONE},\n  {FORWARD, THROUGH, FORWARD},\n  {BACKWARD, NONE, BACKWARD},\n  {BACKWARD, BACKWARD, THROUGH},\n  {BOTH, FORWARD, BACKWARD}, \n  {BOTH, BOTH, THROUGH},\n  {BOTH, THROUGH, BOTH},\n  {THROUGH, THROUGH, THROUGH},\n  {NONE, NONE, NONE},\n  {-1, -1, -1}\n};\n\nstatic const int P_RULE[][5] = {\n  {FORWARD, 1, 0, NONE, NONE},\n  {FORWARD, 0, 0, FORWARD, FORWARD},\n  {FORWARD, 0, 0, THROUGH, BOTH},\n  {FORWARD, 0, 0, BOTH, THROUGH},\n  {FORWARD, 0, 1, THROUGH, FORWARD},\n  {FORWARD, 0, 1, FORWARD, THROUGH},\n  {BACKWARD, 0, 1, NONE, NONE},\n  {BACKWARD, 0, 0, BACKWARD, BACKWARD},\n  {BACKWARD, 0, 0, THROUGH, BOTH},\n  {BACKWARD, 0, 0, BOTH, THROUGH},\n  {BACKWARD, 1, 0, THROUGH, BACKWARD},\n  {BACKWARD, 1, 0, BACKWARD, THROUGH},\n  {BOTH, 1, 1, NONE, NONE},\n  {BOTH, 1, 0, BACKWARD, BACKWARD},\n  {BOTH, 0, 1, FORWARD, FORWARD},\n  {BOTH, 0, 0, BOTH, BOTH},\n  {THROUGH, 0, 0, THROUGH, BOTH},\n  {THROUGH, 0, 0, BOTH, THROUGH},\n  {NONE, 0, 0, NONE, NONE},\n  {-1, -1, -1, -1}\n};\n\nclass Splot {\n  enum SplotType {NODE, SERIES, PARALLEL} type;\n  int source;\n  int sink;\n  Splot *first;\n  Splot *second;\n  int result[5];\n  int how[5];\n  Splot(SplotType _type, \n        int _source=0, \n        int _sink=0,\n        Splot* a = NULL,\n        Splot* b = NULL):\n    type(_type),\n    source(_source),\n    sink(_sink),\n    first(a),\n    second(b) {\n    for (int i=0; i<5; i++)\n      how[i] = result[i] = -1;    \n  }\npublic:\n  ~Splot() {\n    if (first)\n      delete first;\n    if (second)\n      delete second;\n  }\n  static Splot* new_node(char c) {\n    return new Splot(NODE, c=='x', c=='x');\n  }\n  static Splot* new_series(Splot* a, Splot *b) {\n    return new Splot(SERIES, 0, 0, a, b);\n  }\n  static Splot* new_parallel(char s, char t, Splot* a, Splot* b) {\n    return new Splot(PARALLEL, s=='x', t=='x', a, b);\n  }\n  int node_result(int f) {\n    if (f == FORWARD || f == BACKWARD || f == BOTH)\n      return result[f] = 1;\n    return result[f] = source?NEGINF:0;\n  }\n  Splot* rec_node(int f) const {\n    if (f == FORWARD || f == BACKWARD || f == BOTH)\n      return new_node('x');\n    else\n      return new_node('o');\n  }\n  int series_result(int f) {\n    int &what = result[f];\n    what = NEGINF;\n    for (int l=0; S_RULE[l][0]!=-1; l++) {\n      if (S_RULE[l][0] != f)\n        continue ;\n      int left = first->get_result(S_RULE[l][1]);\n      int right = second->get_result(S_RULE[l][2]);\n      if (left != NEGINF && right != NEGINF && left+right > what) {\n        how[f] = l;\n        what = left+right;\n      }\n    }\n    return what;\n  }\n  Splot *rec_series(int f) const {\n    int l = how[f];\n    return new_series(first->reconstruct(S_RULE[l][1]), \n                      second->reconstruct(S_RULE[l][2]));\n  }\n  int parallel_result(int f) {\n    int &what = result[f];\n    what = NEGINF;\n    for (int l=0; P_RULE[l][0]!=-1; l++) {\n      if (P_RULE[l][0] != f)\n        continue ;\n      int news = P_RULE[l][1];\n      int newt = P_RULE[l][2];\n      if ((source && !news) || (sink && !newt))\n        continue ;      \n      int left = first->get_result(P_RULE[l][3]);\n      int right = second->get_result(P_RULE[l][4]);\n      if (left != NEGINF && right != NEGINF && left+right+news+newt > what) {\n        how[f] = l;\n        what = left+right+news+newt;\n      }\n    }\n    return what;\n  }\n  Splot *rec_parallel(int f) const {\n    int l = how[f];\n    return new_parallel(P_RULE[l][1]?'x':'o',\n                        P_RULE[l][2]?'x':'o',\n                        first->reconstruct(P_RULE[l][3]), \n                        second->reconstruct(P_RULE[l][4]));\n  }\n  int get_result(int f) {\n    if (result[f] != -1)\n      return result[f];\n    if (type == NODE) \n      return node_result(f);\n    else if (type == SERIES)\n      return series_result(f);\n    else\n      return parallel_result(f);\n  }\n  Splot* reconstruct(int f) const {\n    if (type == NODE) \n      return rec_node(f);\n    else if (type == SERIES)\n      return rec_series(f);\n    else\n      return rec_parallel(f);\n  }\n  void print() const {\n    if (type == NODE)\n      printf(\"%c\", source?'x':'o');\n    else if (type == SERIES) {\n      printf(\"S\");\n      first->print();\n      second->print();\n      printf(\"#\");\n    } else {\n      printf(\"P%c|\", source?'x':'o');\n      first->print();\n      second->print();\n      printf(\"|%c#\", sink?'x':'o');\n    }\n  }\n};\n\nclass Parser {\n  const char *s;\n  int p;\n  Splot* do_parse() {\n    if (s[p] == 'o' || s[p] == 'x')\n      return Splot::new_node(s[p++]);\n    if (s[p] == 'S') {\n      p++;\n      Splot *first = do_parse();\n      Splot *second = do_parse();\n      p++;\n      return Splot::new_series(first, second);\n    }\n    assert(s[p] == 'P');\n    char sc = s[p+1];\n    p += 3;\n    Splot *first = do_parse();\n    Splot *second = do_parse();\n    char tc = s[p+1]; \n    p += 3;\n    return Splot::new_parallel(sc, tc, first, second);\n  }\n public:\n  Parser(const char *_s):\n    s(_s), p(0) {\n  }\n  Splot* parse() {\n    assert(p == 0);\n    Splot *r = do_parse();\n    assert(s[p] == 0 || s[p] == '\\n');\n    return r;\n  }\n};\n\nint main() {\n  static char s[MAX+1];\n  scanf(\"%s\", s);\n  Splot* splot = Parser(s).parse();\n  int best = splot->get_result(FORWARD);\n  printf(\"%d\\n\", best);\n  Splot *filled = splot->reconstruct(FORWARD);\n  filled->print();\n  printf(\"\\n\");\n  delete splot;\n  delete filled;\n  return 0;\n}\n```\n\n\n\u6700\u540e\u9644\u4e00\u4efd\u5b98\u65b9\u51fa\u9898\u7ec4\u7684\u51fa\u9898\u80cc\u666f\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/sw9lc3r9.png)",
        "postTime": 1682610954,
        "uid": 542457,
        "name": "cff_0102",
        "ccfLevel": 4,
        "title": "P9271 [CEOI2013] Splot \u9898\u89e3"
    }
]