[
    {
        "content": "~~\u4e00\u9053\u5e73\u8861\u6811\u7684\u597d\u9898~~\n\n\u5728\u666e\u901a\u5e73\u8861\u6811\u7684\u57fa\u7840\u4e0a\uff0c\u4fdd\u5b58\u4e86\u5176\u4ed6\u7684\u4e00\u4e9b\u4fe1\u606f\uff1a\u76ee\u524d\u6700\u5927\u7684\u9e1f\u6570\uff0c\u66fe\u7ecf\u6700\u5927\u7684\u9e1f\u6570\uff08\u6b21\u5927\u503c\uff09 \u76ee\u524d\u6700\u5927\u7684\u5a01\u6b66\u503c\uff0c\u66fe\u7ecf\u6700\u5927\u7684\u5a01\u6b66\u503c\uff08\u6b21\u5927\u503c\uff09\u3002\n\n\u9488\u5bf9\u6bcf\u4e2a\u5750\u6807\uff0c\u6211\u4eec\u8fdb\u884c\u79bb\u6563\u5316\uff08\u6570\u5b57\u592a\u5927\u4e86\uff09\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u5750\u6807\uff0c\u6211\u4eec\u5efa\u7acb\u4e00\u9897\u5e73\u8861\u6811\u8fdb\u884c\u7ef4\u62a4\u3002\u6bcf\u6b21\u52a0\u5165\u65b0\u9e1f\u7684\u65f6\u5019\u8bb0\u5f97\u66f4\u65b0\u6b21\u5927\u503c\u548c\u6700\u5927\u503c\uff08\u6709\u70b9\u7ebf\u6bb5\u6811\u90a3\u5473\u4e86\uff09\n\nAC\u3000Code\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define lc ch[now][0]\n#define rc ch[now][1]\nconst int maxn=3e4+100,maxt=3e5+1000;\nint cnt,n,m,sub[maxn];\nstruct bbb{\n    int w,x,y;\n    void Insert()\n    {\n        scanf(\"%d%d%d\",&w,&x,&y);\n    }\n}a[maxn],q[maxt];\nstruct aaa{\n    int x,y;\n    friend bool operator<(aaa a,aaa b)\n    {\n        return a.x!=b.x?a.x<b.x:a.y<b.y;\n    }\n    friend bool operator==(aaa a,aaa b)\n    {\n        return a.x==b.x&&a.y==b.y;\n    }\n}p[maxt+maxn];\nstruct Treap{\n    int rt[maxt+maxn],ch[maxn][2],fix[maxn],w[maxn],Size[maxn],mx[maxn],mx_Size[maxn],mx_w[maxn],add_w[maxn],add_Size[maxn];\n    int New(int np,int v)\n    {\n        w[np]=mx[np]=v,Size[np]=1;\n        fix[np]=rand();\n        return np;\n    }\n    void pushup(int now)\n    {\n        Size[now]=1;\n        if(lc)Size[now]+=Size[lc];\n        if(rc)Size[now]+=Size[rc];\n\n        mx[now]=w[now];\n        if(lc)mx[now]=max(mx[now],mx[lc]);\n        if(rc)mx[now]=max(mx[now],mx[rc]);\n    }\n    void pushdown(int now)\n    {\n        mx_Size[lc]=max(mx_Size[lc],add_Size[now]);\n        mx_Size[rc]=max(mx_Size[rc],add_Size[now]);\n        add_Size[lc]=max(add_Size[lc],add_Size[now]);\n        add_Size[rc]=max(add_Size[rc],add_Size[now]);\n        add_Size[now]=0;\n        mx_w[lc]=max(mx_w[lc],add_w[now]);\n        mx_w[rc]=max(mx_w[rc],add_w[now]);\n        add_w[lc]=max(add_w[lc],add_w[now]);\n        add_w[rc]=max(add_w[rc],add_w[now]);\n        add_w[now]=0;\n    }\n    int merge(int A,int B)\n    {\n        pushdown(A);pushdown(B);\n        if(A*B==0)return A+B;\n        if(fix[A]<fix[B])\n        {\n            ch[A][1]=merge(ch[A][1],B);\n            pushup(A);\n            return A;\n        }\n        else\n        {\n            ch[B][0]=merge(A,ch[B][0]);\n            pushup(B);\n            return B;\n        }\n    }\n    void split(int now,int v,int &A,int &B)\n    {\n        pushdown(now);\n        if(!now)\n        {\n            A=B=0;\n            return;\n        }\n        if(v<now)\n        {\n            B=now;\n            split(lc,v,A,lc);\n        }\n        else\n        {\n            A=now;\n            split(rc,v,rc,B);\n        }\n        pushup(now);\n    }\n    int find(int now,int v)\n    {\n        while(now)\n        {\n            pushdown(now);\n            if(now==v)break;\n            now=ch[now][v>now];\n        }\n        return now;\n    }\n    void outs()\n    {\n        for(int i=1;i<=2;i++)\n        {\n        \tprintf(\"%d %d\\n\",i,Size[i]);\n        }\n        printf(\"\\n\");\n    }\n}tp;\nvoid add1(int i,int t)\n{\n    int A,B,C;\n    C=tp.New(i,a[i].w);\n    if(tp.rt[t])\n    {\n        tp.mx_w[tp.rt[t]]=max(tp.mx_w[tp.rt[t]] , a[i].w);\n        tp.add_w[tp.rt[t]]=max(tp.add_w[tp.rt[t]], a[i].w);\n        tp.mx_Size[tp.rt[t]]=max(tp.mx_Size[tp.rt[t]] , tp.Size[tp.rt[t]]);\n        tp.add_Size[tp.rt[t]]=max(tp.add_Size[tp.rt[t]], tp.Size[tp.rt[t]]);\n        tp.mx_w[i]=max(tp.mx_w[i] , tp.mx[tp.rt[t]]);\n        tp.mx_Size[i]=max(tp.mx_Size[i] , tp.Size[tp.rt[t]]);\n    }\n    tp.split(tp.rt[t],i,A,B);\n    tp.rt[t]=tp.merge(tp.merge(A,C),B);\n    sub[i]=t;\n}\nvoid add2(int i,int t)\n{\n    int A,B,C;\n    tp.split(tp.rt[sub[i]],i-1,A,B);\n    tp.split(B,i,C,B);\n    tp.rt[sub[i]]=tp.merge(A,B);\n    if(tp.rt[t])\n    {\n        tp.mx_w[tp.rt[t]]=max(tp.mx_w[tp.rt[t]] , a[i].w);\n        tp.add_w[tp.rt[t]]=max(tp.add_w[tp.rt[t]], a[i].w);\n        tp.mx_Size[tp.rt[t]]=max(tp.mx_Size[tp.rt[t]] , tp.Size[tp.rt[t]]);\n        tp.add_Size[tp.rt[t]]=max(tp.add_Size[tp.rt[t]], tp.Size[tp.rt[t]]);\n        tp.mx_w[i]=max(tp.mx_w[i] , tp.mx[tp.rt[t]]);\n        tp.mx_Size[i]=max(tp.mx_Size[i] , tp.Size[tp.rt[t]]);\n    }\n    tp.split(tp.rt[t],i,A,B);\n    tp.rt[t]=tp.merge(tp.merge(A,i),B);\n    sub[i]=t;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n\t    a[i].Insert(),p[i].x=a[i].x,p[i].y=a[i].y;\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n\t    q[i].Insert(),p[i+n].x=q[i].x,p[i+n].y=q[i].y;\n    cnt=n+m;\n    sort(p+1,p+cnt+1);\n    cnt=unique(p+1,p+cnt+1)-p-1;\n    int t;\n    for(int i=1;i<=n;i++)\n    {\n        t=lower_bound(p+1,p+cnt+1,(aaa){a[i].x,a[i].y})-p;\n        add1(i,t);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        t=lower_bound(p+1,p+cnt+1,(aaa){q[i].x,q[i].y})-p;\n        add2(q[i].w,t);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        tp.find(tp.rt[sub[i]],i);\n        printf(\"%lld\\n\",1ll*tp.mx_w[i]*tp.mx_Size[i]);\n    }\n    return 0;\n}\n```\n",
        "postTime": 1625364602,
        "uid": 229919,
        "name": "\u4e00E\u5b64\u884c",
        "ccfLevel": 6,
        "title": "P4200 \u5343\u5c71\u9e1f\u98de\u7edd\u9898\u89e3"
    },
    {
        "content": "### \u7b80\u8981\u9898\u610f\n\u4e00\u4e2a\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u4e2d\u6709\u4e00\u4e9b\u503c\uff0c\u7ef4\u62a4\u5728\u540c\u4e00\u4e2a\u5750\u6807\u7684\u503c\u7684\u6700\u5927\u503c\u548c\u4e2a\u6570\u6700\u5927\u503c\u3002\n### \u5206\u6790\n\u8fd9\u9053\u9898\u6709\u63d2\u5165\u3001\u5220\u9664\u3001\u67e5\u627e\uff0c\u6240\u4ee5\u662f\u663e\u7136\u7684\u5e73\u8861\u6811\u3002\n\n\u56e0\u4e3a\u6bcf\u4e2a\u5750\u6807\u7684\u9e1f\u90fd\u8981\u7ef4\u62a4\uff0c\u6240\u4ee5\u80af\u5b9a\u662f\u4e8c\u7ef4\u6570\u7ec4\u5957\u5e73\u8861\u6811\uff08\u6570\u7ec4\u7684\u503c\u5b58\u6bcf\u4e2a\u5e73\u8861\u6811\u7684\u6839\uff09\uff0c\u6ce8\u610f\u5230\u6570\u636e\u8303\u56f4\u592a\u5927\u4e86\uff0c\u6240\u4ee5\u5f97\u7528 map \u5b58\u3002\n\n\u4e00\u53ea\u9e1f\u53ea\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a\u79bb\u5f00\u8fd9\u4e2a\u4f4d\u7f6e\uff0c\u52a0\u5165\u5230\u53e6\u4e00\u4e2a\u4f4d\u7f6e\u3002\u9898\u76ee\u8981\u6c42\u5a01\u6b66\u503c\u7684\u6700\u5927\u503c\u548c\u5904\u5728\u540c\u4e00\u4f4d\u7f6e\u7684\u9e1f\u7684\u53ea\u6570\u7684\u6700\u5927\u503c\uff0c\u6ce8\u610f\u5230\u628a\u4e00\u53ea\u9e1f\u4ece\u8fd9\u4e2a\u4f4d\u7f6e\u5220\u9664\u5e76\u4e0d\u4f1a\u5f71\u54cd\u6700\u5927\u503c\uff0c\u53ea\u6709\u52a0\u5165\u4f1a\u5f71\u54cd\u6700\u5927\u503c\uff0c\u6240\u4ee5\u53ea\u9700\u5728\u52a0\u5165\u7684\u65f6\u5019\u6253\u4e2a\u61d2\u6807\u8bb0\u5c31\u884c\u4e86\u3002\n\n\u6700\u540e\u8f93\u51fa\u4e00\u4e0b\u4e00\u4e0b\u6700\u5927\u503c\u4e0e\u56e2\u7ed3\u503c\u7684\u6700\u5927\u503c\u7684\u4e58\u79ef\u3002\n\n### \u4ee3\u7801\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<random>\n#include<map>\n#define ls(x) treap[x].lson\n#define rs(x) treap[x].rson\nusing namespace std;\nnamespace AKIOI{\n\tconst int N = 1e6, inf = 2e9;\n\tstruct node{\n\t\tint id, max_w, size, pri, lson, rson, laze_m, laze_u;\n\t} treap[N + 10];\n\tstruct bird{\n\t\tint x, y, w, max_m, max_u;\n\t} b[N + 10];\n\tint n, m;\n\tint cnt;\n\tmap<pair<int, int> , int> Root;\n\trandom_device R;\n\tmt19937 G(R());\n\tint rd(int l, int r){\n\t\treturn uniform_int_distribution<int>(l, r)(G);\n\t}\n\tvoid newnode(int &u, int id){\n\t\tu = ++cnt;\n\t\ttreap[u].id = id;\n\t\ttreap[u].max_w = b[id].w;\n\t\ttreap[u].size = 1;\n\t\ttreap[u].pri = rd(-inf, inf);\n\t}\n\tvoid push_down(int u){\n\t\tif(treap[u].laze_m){\n\t\t\ttreap[ls(u)].laze_m = max(treap[ls(u)].laze_m, treap[u].laze_m);\n\t\t\tb[treap[ls(u)].id].max_m = max(b[treap[ls(u)].id].max_m, treap[u].laze_m);\n\t\t\ttreap[rs(u)].laze_m = max(treap[rs(u)].laze_m, treap[u].laze_m);\n\t\t\tb[treap[rs(u)].id].max_m = max(b[treap[rs(u)].id].max_m, treap[u].laze_m);\n\t\t\ttreap[u].laze_m = 0;\n\t\t}\n\t\tif(treap[u].laze_u){\n\t\t\ttreap[ls(u)].laze_u = max(treap[ls(u)].laze_u, treap[u].laze_u);\n\t\t\tb[treap[ls(u)].id].max_u = max(b[treap[ls(u)].id].max_u, treap[u].laze_u);\n\t\t\ttreap[rs(u)].laze_u = max(treap[rs(u)].laze_u, treap[u].laze_u);\n\t\t\tb[treap[rs(u)].id].max_u = max(b[treap[rs(u)].id].max_u, treap[u].laze_u);\n\t\t\ttreap[u].laze_u = 0;\n\t\t}\n\t}\n\tvoid push_up(int u){\n\t\ttreap[u].size = treap[ls(u)].size + treap[rs(u)].size + 1;\n\t\ttreap[u].max_w = max(max(treap[ls(u)].max_w, treap[rs(u)].max_w), b[treap[u].id].w);\n\t}\n\tvoid merge(int &u, int root_l, int root_r){\n\t\tif(!root_l || !root_r)\n\t\t\treturn void(u = root_l | root_r);\n\t\tif(treap[root_l].pri >= treap[root_r].pri){\n\t\t\tu = root_l;\n\t\t\tpush_down(u);\n\t\t\tmerge(rs(root_l), rs(root_l), root_r);\n\t\t}\n\t\telse{\n\t\t\tu = root_r;\n\t\t\tpush_down(u);\n\t\t\tmerge(ls(root_r), root_l, ls(root_r));\n\t\t}\n\t\tpush_up(u);\n\t}\n\tvoid split_w(int u, int &root_l, int &root_r, int cri){\n\t\tif(!u)\n\t\t\treturn void(root_l = root_r = 0);\n\t\tpush_down(u);\n\t\tif(b[treap[u].id].w <= cri){\n\t\t\troot_l = u;\n\t\t\tsplit_w(rs(root_l), rs(root_l), root_r, cri);\n\t\t}\n\t\telse{\n\t\t\troot_r = u;\n\t\t\tsplit_w(ls(root_r), root_l, ls(root_r), cri);\n\t\t}\n\t\tpush_up(u);\n\t}\n\tvoid split_id(int u, int &root_l, int &root_r, int cri){\n\t\tif(!u)\n\t\t\treturn void(root_l = root_r = 0);\n\t\tpush_down(u);\n\t\tif(treap[u].id <= cri){\n\t\t\troot_l = u;\n\t\t\tsplit_id(rs(root_l), rs(root_l), root_r, cri);\n\t\t}\n\t\telse{\n\t\t\troot_r = u;\n\t\t\tsplit_id(ls(root_r), root_l, ls(root_r), cri);\n\t\t}\n\t\tpush_up(u);\n\t}\n\tvoid ins(int i){\n\t\tint rt = Root[make_pair(b[i].x, b[i].y)], w_root_l, w_root_r, w_root_l_l, w_root_l_r, son;\n\t\tnewnode(son, i);\n\t\tb[i].max_m = max(b[i].max_m, treap[rt].max_w);\n\t\ttreap[rt].laze_m = max(treap[rt].laze_m, b[i].w);\n\t\tb[treap[rt].id].max_m = max(b[treap[rt].id].max_m, b[i].w);\n\t\tsplit_w(rt, w_root_l, w_root_r, b[i].w);\n\t\tsplit_w(w_root_l, w_root_l_l, w_root_l_r, b[i].w - 1);\n\t\tint id_root_l, id_root_r;\n\t\tsplit_id(w_root_l_r, id_root_l, id_root_r, i - 1);\n\t\tmerge(id_root_r, son, id_root_r);\n\t\tmerge(w_root_l_r, id_root_l, id_root_r);\n\t\tmerge(w_root_l, w_root_l_l, w_root_l_r);\n\t\tmerge(rt, w_root_l, w_root_r);\n\t\ttreap[rt].laze_u = max(treap[rt].laze_u, treap[rt].size - 1);\n\t\tb[treap[rt].id].max_u = max(b[treap[rt].id].max_u, treap[rt].size - 1);\n\t\tRoot[make_pair(b[i].x, b[i].y)] = rt;\n\t}\n\tvoid dlt(int i){\n\t\tint rt = Root[make_pair(b[i].x, b[i].y)], w_root_l, w_root_r, w_root_l_l, w_root_l_r;\n\t\tsplit_w(rt, w_root_l, w_root_r, b[i].w);\n\t\tsplit_w(w_root_l, w_root_l_l, w_root_l_r, b[i].w - 1);\n\t\tint id_root_l, id_root_r, id_root_l_l, id_root_l_r;\n\t\tsplit_id(w_root_l_r, id_root_l, id_root_r, i);\n\t\tsplit_id(id_root_l, id_root_l_l, id_root_l_r, i - 1);\n\t\tmerge(w_root_l_r, id_root_l_l, id_root_r);\n\t\tmerge(w_root_l, w_root_l_l, w_root_l_r);\n\t\tmerge(rt, w_root_l, w_root_r);\n\t\tRoot[make_pair(b[i].x, b[i].y)] = rt;\n\t}\n\tvoid laze(int u){\n\t\tif(!u)\n\t\t\treturn;\n\t\tpush_down(u);\n\t\tlaze(ls(u));\n\t\tlaze(rs(u));\n\t}\n\tpair<int, int> ans[N << 2];\n\tint main(){\n\t\tscanf(\"%d\", &n);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint w, x, y;\n\t\t\tscanf(\"%d%d%d\", &w, &x, &y);\n\t\t\tb[i] = (bird){x, y, w};\n\t\t\tins(i);\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\twhile(m--){\n\t\t\tint v, x, y;\n\t\t\tscanf(\"%d%d%d\", &v, &x, &y);\n\t\t\tdlt(v);\n\t\t\tb[v].x = x, b[v].y = y;\n\t\t\tins(v);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tans[i] = make_pair(b[i].x, b[i].y);\n\t\tsort(ans + 1, ans + n + 1);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(i == 1 || ans[i] != ans[i - 1])\n\t\t\t\tlaze(Root[ans[i]]);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tprintf(\"%lld\\n\", 1LL * b[i].max_m * b[i].max_u);\n\t\treturn 0;\n\t}\n}\nint main(){\n\treturn AKIOI::main();\n}\n```\n",
        "postTime": 1682603772,
        "uid": 654992,
        "name": "tangyigeng",
        "ccfLevel": 0,
        "title": "P4200 \u5343\u5c71\u9e1f\u98de\u7edd \u9898\u89e3"
    },
    {
        "content": "[\u5728\u535a\u5ba2\u98df\u7528\u66f4\u4f73](https://blog.csdn.net/weixin_50624971/article/details/121027071)\n\n\u9898\u76ee\u5341\u5206\u9634\u95f4\u2026\u2026\n\n\u662f\u4e00\u9053\u7ec3\u4e60\u5e73\u8861\u6811\u7684\u597d\u9898\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u9898\u76ee\u63cf\u8ff0\u5f97\u5929\u82b1\u4e71\u5760\uff0c\u5176\u5b9e\u53ea\u9700\u8981\u5bf9\u4e8e\u6bcf\u53ea\u9e1f\u6240\u5728\u7684\u5750\u6807\u7ef4\u62a4\u4e00\u9897 `splay` \u5c31\u597d\u4e86\u3002\n\n\u6ce8\u610f\u662f\u5bf9\u6bcf\u53ea\u9e1f\u6240\u5728\u7684\u5750\u6807\uff0c\u4e0d\u662f\u6bcf\u4e2a\u5750\u6807\u3002\n\n\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u7684\u4fe1\u606f\u662f\u6700\u5927\u56e2\u7ed3\u503c\u548c $siz$ \u548c\u6700\u5927\u5a01\u6b66\u503c\u548c $val$\u3002\n\n\u4e3a\u6b64\u9700\u8981\u7ef4\u62a4\u4e24\u4e2a\u61d2\u6807\u8bb0\uff0c\u4e00\u4e2a\u8bb0\u5f55 $siz$\uff0c\u4e00\u4e2a\u8bb0\u5f55 $val$\u3002\n\n\u7136\u540e\u5728 `splay` \u7684\u8fc7\u7a0b\u4e2d\u4e0b\u4f20\u6807\u8bb0\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u6570\u636e\u8303\u56f4\u8fc7\u5927\uff0c\u6240\u4ee5\u9700\u8981\u7528 `map` \u6765\u5b58\u5750\u6807\u3002\n\n\u8fd8\u6709\u4e00\u5904\u5c0f\u7ec6\u8282\uff0c\u5c31\u662f `rotate` \u7684\u65f6\u5019\u6700\u540e\u66f4\u65b0 $x$,$y$ \u8282\u70b9\u4fe1\u606f\u7684\u65f6\u5019\u4e00\u5b9a\u8981\u5148\u66f4\u65b0 $y$ \uff01\uff01\uff01\n\n\u56e0\u4e3a\u6b64\u65f6 $y$ \u5df2\u7ecf\u53d8\u6210 $x$ \u7684\u513f\u5b50\uff0c\u663e\u7136\u8981\u5148\u66f4\u65b0\u513f\u5b50\u2026\u2026\n\n~~\u6211\u4e4b\u524d\u4e00\u76f4\u5148\u66f4\u65b0\u7684 $x$\u2026\u2026~~\n\n~~\u53ef\u80fd\u662f\u666e\u901a\u5e73\u8861\u6811\u6a21\u677f\u6570\u636e\u6c34\u4e86\u5427~~  \n\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define pii pair<int,int>\n#define mp make_pair\nusing namespace std;\nconst int maxn=3e5+5;\nint siz[maxn],f[maxn],son[maxn][2],val[maxn],tot_size,root[maxn],a[maxn];\nint laz1[maxn],laz2[maxn],ans1[maxn],ans2[maxn],q[maxn],num,w[maxn];\nmap<pii,int>vis;\ninline ll read()\n{\n\tll ret=0;char son=' ',c=getchar();\n\twhile(!(c<='9'&&c>='0')) son=c,c=getchar();\n\twhile(c<='9'&&c>='0') ret=(ret<<1)+(ret<<3)+c-'0',c=getchar();\n\treturn son=='-'?-ret:ret;\n}\nint get(int x) {return x==son[f[x]][1];}\nvoid clear(int x) {son[x][1]=son[x][0]=siz[x]=f[x]=val[x]=laz1[x]=laz2[x]=0;}\nvoid update(int x)\n{\n\tsiz[x]=siz[son[x][1]]+siz[son[x][0]]+1;\n\tval[x]=max(max(val[son[x][1]],val[son[x][0]]),w[x]);\n}\nvoid rotate(int x)\n{\n\tint y=f[x],z=f[y],type=get(x);\n\tson[y][type]=son[x][type^1];\n\tf[son[x][type^1]]=y;\n\tson[x][type^1]=y;\n\tf[y]=x,f[x]=z;\n\tif(z) son[z][y==son[z][1]]=x;\n\tupdate(y);update(x);\n}\nvoid pushdown(int x)\n{\n\tint k1=laz1[x],k2=laz2[x];\n\tfor(int i=0;i<=1;i++)\n\t{\n\t\tif(son[x][i])\n\t\t{\n\t\t\tint j=son[x][i];\n\t\t\tans1[j]=max(ans1[j],k1);\n            ans2[j]=max(ans2[j],k2);\n            laz1[j]=max(laz1[j],k1);\n            laz2[j]=max(laz2[j],k2);\n\t\t}\n\t}\n\tlaz1[x]=laz2[x]=0;\n}\nvoid splay(int x,int &rt)\n{\n\tint top=0;\n\tfor(int fa=x;fa;fa=f[fa]) q[++top]=fa;\n    while(top) pushdown(q[top--]);\n\tfor(int fa;fa=f[x];rotate(x)) if(f[fa]) rotate(get(fa)==get(x)?fa:x);\n\trt=x;\n}\nint find_pre(int p)\n{\n\tint now=son[root[p]][0];\n    while(son[now][1]) now=son[now][1];\n    return now;\n}\nvoid del(int p,int x)\n{\n\tsplay(x,root[p]);\n    int now=root[p];\n    if(!son[now][0]&&!son[now][1])\n    {\n        clear(now);\n        root[p]=0;\n        return;\n    }\n    for(int i=0;i<=1;i++)\n    {\n    \tif(!son[now][i])\n    \t{\n\t        root[p]=son[now][i^1];\n\t        f[root[p]]=0;\n\t        clear(now);\n\t        return;\n    \t}\n    }\n    x=find_pre(p);\n    splay(x,root[p]);\n    f[son[now][1]]=x;\n    son[x][1]=son[now][1];\n    clear(now);\n    update(root[p]);\n}\nvoid insert(int &p,int x,int fa)\n{\n    if(!p)\n    {\n        p=x,f[p]=fa,val[p]=w[p],siz[p]=1;\n        return;\n    }\n    pushdown(p);\n    if(!son[p][0]) insert(son[p][0],x,p);\n    else insert(son[p][1],x,p);\n}\nint main()\n{\n\tint n=read();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tw[i]=read();\n\t\tint x=read(),y=read();\n\t\tif(!vis.count(mp(x,y))) vis[mp(x,y)]=++num;\n        int k=vis[mp(x,y)];\n        a[i]=k;\n        ans1[i]=max(ans1[i],val[root[k]]);\n        ans2[i]=max(ans2[i],siz[root[k]]);\n        insert(root[k],i,0);\n        splay(i,root[k]);\n        laz1[root[k]]=max(laz1[root[k]],w[i]);\n        laz2[root[k]]=max(laz2[root[k]],siz[root[k]]-1);\n\t}\n\tint t=read();\n\twhile(t--)\n\t{\n\t\tint i=read(),x=read(),y=read();\n\t\tif(!vis.count(mp(x,y))) vis[mp(x,y)]=++num;\n        int k=vis[mp(x,y)],pre=a[i];\n        a[i]=k;\n        del(pre,i);\n        ans1[i]=max(ans1[i],val[root[k]]);\n        ans2[i]=max(ans2[i],siz[root[k]]);\n        insert(root[k],i,0);\n        splay(i,root[k]);\n        laz1[root[k]]=max(laz1[root[k]],w[i]);\n        laz2[root[k]]=max(laz2[root[k]],siz[root[k]]-1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsplay(i,root[a[i]]);\n\t\tprintf(\"%lld\\n\",1ll*ans1[i]*ans2[i]);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1635465320,
        "uid": 392608,
        "name": "Melancholy_",
        "ccfLevel": 4,
        "title": "\u6d1b\u8c37 P4200 \u5343\u5c71\u9e1f\u98de\u7edd&&\u5e73\u8861\u6811"
    },
    {
        "content": "[\u4e5f\u8bb8\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://rainlycoris.github.io/#/post/23)\n\n## \u5206\u6790\n\n\u9996\u5148\u5bf9\u4e8e\u6bcf\u4e2a\u5750\u6807\u5f00\u4e00\u9897\u5e73\u8861\u6811\uff0c\u8981\u7ef4\u62a4\u7684\u4e1c\u897f\u9700\u8981\u5168\u5c40\u53d6 max\uff0c\u4f46\u662f\u81ea\u5df1\u4e0d\u80fd\u53d6\u3002\n\n\u58eb\u6c14\u503c\u548c\u56e2\u7ed3\u503c\u5728\u4e00\u4e2a\u70b9\u6ca1\u52a0\u8fdb\u53bb\u4e4b\u524d\u662f\u597d\u7b97\u7684\uff0c\u76f4\u63a5\u662f\u5750\u6807\u5185\u90e8\u7684\u70b9\u5a01\u6b66\u503c\u7684\u6700\u5927\u503c\u548c\u70b9\u7684\u4e2a\u6570\u3002\n\n\u7136\u540e\u5c31\u662f\u8981\u66f4\u65b0\u5750\u6807\u4e0a\u7684\u6240\u6709\u70b9\uff0c\u5148\u7ed9\u5e73\u8861\u6811\u7684\u6839\u8282\u70b9\u6253\u4e0a\u6807\u8bb0\uff0c\u6253\u5b8c\u4e4b\u540e\u518d\u628a\u70b9\u52a0\u8fdb\u53bb\u3002\n\n\u73b0\u5728\u8fd9\u4e2a\u70b9\u7684\u6807\u8bb0\u5c31\u4e0d\u4f1a\u6253\u5728\u81ea\u5df1\u8eab\u4e0a\u4e86\u3002\n\n## \u4ee3\u7801\n\n```cpp\nconst int N = 30005,M = 330005;\n__gnu_pbds::gp_hash_table<ull,int> ha;\nint anss[N],anst[N];\nmultiset<int> st[M];\nint w[N],p[N];\nint n;\n\nnamespace FHQtreap{\n    mt19937 myrand(233);\n    class fhqtreap{\n        private:\n            class tree{\n                public:\n                    int val,l,r;\n                    unsigned int pri;\n                    int tags,tagt;\n            }tr[N];\n\n            vector<int> pool;\n            int idx;\n            int create(int val_){\n                int u = -1;\n                if(pool.empty())\n                    u = ++idx;\n                else{\n                    u = pool.back();\n                    pool.pop_back();\n                }\n                tr[u] = {val_,0,0,(unsigned int)myrand(),0,0};\n                return u;\n            }\n            void recycle(const int &u){pool.push_back(u);}\n\n            void pushdown(int u){\n                anss[tr[tr[u].l].val] = max(anss[tr[tr[u].l].val],tr[u].tags);\n                anst[tr[tr[u].l].val] = max(anst[tr[tr[u].l].val],tr[u].tagt);\n                anss[tr[tr[u].r].val] = max(anss[tr[tr[u].r].val],tr[u].tags);\n                anst[tr[tr[u].r].val] = max(anst[tr[tr[u].r].val],tr[u].tagt);\n                tr[tr[u].l].tags = max(tr[tr[u].l].tags,tr[u].tags);\n                tr[tr[u].l].tagt = max(tr[tr[u].l].tagt,tr[u].tagt);\n                tr[tr[u].r].tags = max(tr[tr[u].r].tags,tr[u].tags);\n                tr[tr[u].r].tagt = max(tr[tr[u].r].tagt,tr[u].tagt);\n                tr[u].tags = tr[u].tagt = 0;\n            }\n            int root[M];\n        public:\n            int& operator [] (const int &x){return root[x];}\n            void split(int u,int c,int &x,int &y){\n                if(!u){\n                    x = y = 0;\n                    return;\n                }\n                pushdown(u);\n                if(tr[u].val<=c){\n                    x = u;\n                    split(tr[u].r,c,tr[u].r,y);\n                }\n                else{\n                    y = u;\n                    split(tr[u].l,c,x,tr[u].l);\n                }\n            }\n            int merge(int x,int y){\n                if(!x||!y)\n                    return x|y;\n                if(tr[x].pri>tr[y].pri){\n                    pushdown(x);\n                    tr[x].r = merge(tr[x].r,y);\n                    return x;\n                }\n                pushdown(y);\n                tr[y].l = merge(x,tr[y].l);\n                return y;\n            }\n            void insert(int r,int c){\n                int x,y;\n                split(root[r],c,x,y);\n                root[r] = merge(merge(x,create(c)),y);\n            }\n            void erase(int r,int c){\n                int x,y,z;\n                split(root[r],c-1,x,y);\n                split(y,c,y,z);\n                if(y){\n                    recycle(y);\n                    y = merge(tr[y].l,tr[y].r);\n                }\n                root[r] = merge(merge(x,y),z);\n            }\n            void tag(int x,int s,int t){\n                if(!x)\n                    return;\n                pushdown(x);\n                anss[tr[x].val] = max(anss[tr[x].val],s);\n                anst[tr[x].val] = max(anst[tr[x].val],t);\n                tr[x].tags = max(tr[x].tags,s);\n                tr[x].tagt = max(tr[x].tagt,t);\n            }\n            void down(int x){\n                if(!x)\n                    return;\n                pushdown(x);\n                down(tr[x].l);\n                down(tr[x].r);\n            }\n    };\n}\nFHQtreap::fhqtreap tr;\n\nint h(int x,int y){\n    ull w = (((1ull<<31)+x)<<32)+((1ull<<31)+y);\n    if(!ha[w])\n        ha[w] = ha.size();\n    return ha[w];\n}\n\nvoid insert(int x){\n    if(!st[p[x]].empty())\n        anss[x] = max(anss[x],*prev(st[p[x]].end()));\n    anst[x] = max({anst[x],(int)st[p[x]].size()});\n    tr.tag(tr[p[x]],w[x],(int)st[p[x]].size());\n    tr.insert(p[x],x);\n    st[p[x]].insert(w[x]);\n}\n\nvoid move(int x,int np){\n    tr.erase(p[x],x);\n    st[p[x]].erase(st[p[x]].find(w[x]));\n    p[x] = np;\n    insert(x);\n}\n\nsigned main(){\n    n = in();\n    for(int k=1;k<=n;k++){\n        w[k] = in();\n        int x = in(),y = in();\n        p[k] = h(x,y);\n        insert(k);\n    }\n    int t = in();\n    while(t--){\n        int v = in(),x = in(),y = in();\n        move(v,h(x,y));\n    }\n    for(int k=ha.size();k;k--)\n        tr.down(tr[k]);\n    for(int k=1;k<=n;k++)\n        out(1ll*anss[k]*anst[k],'\\n');\n    return 0;\n}\n```\n\n## \u540e\u8bdd\n\n\u81f3\u5c11 2023.04.17 \u6211\u8fd8\u662f\u6700\u4f18\u89e3\u3002",
        "postTime": 1681689767,
        "uid": 407214,
        "name": "liudonglin",
        "ccfLevel": 7,
        "title": "P4200 \u9898\u89e3"
    },
    {
        "content": "## \u4e00\u3001\u9898\u610f\n\n\u7ed9\u5b9a\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684 $n$ \u4e2a\u5e26\u6743\u70b9\uff0c\u6bcf\u4e00\u65f6\u523b\u6539\u53d8\u4e00\u4e2a\u70b9\u7684\u5750\u6807\uff0c\u6700\u540e\u95ee\u5bf9\u4e8e**\u6bcf\u4e00\u4e2a**\u70b9\uff0c\u5728**\u6bcf\u4e00\u65f6\u523b\u5185**\u4e0e\u5176\u5750\u6807\u76f8\u540c\u7684**\u5176\u4ed6**\u70b9\u7684**\u4e2a\u6570\u7684\u6700\u5927\u503c** $a$ \u548c**\u6743\u503c\u6700\u5927\u503c\u7684\u6700\u5927\u503c** $b$ \u4e4b**\u79ef**\u3002\n\n## \u4e8c\u3001\u601d\u8def\n\n\u8bfb\u9898\u53ef\u4ee5\u53d1\u73b0\u6709\u70b9\u7684**\u5750\u6807**\u4e2a\u6570\u662f $\\mathrm O(n)$ \u7684\uff0c\u8003\u8651\u5bf9\u6bcf\u4e2a\u6709\u70b9\u7684\u5750\u6807\u5efa\u4e00\u68f5\u5e73\u8861\u6811\u7ef4\u62a4\u6b64\u5750\u6807\u4e0a\u70b9\u7684**\u7f16\u53f7**\u4e0e**\u6743\u503c**\u53ca\u6bcf\u4e2a\u70b9**\u5728\u6b64\u5750\u6807\u4e0a**\u7684 $a$ \u4e0e $b$\uff0c\u7528 map \u5b58\u50a8\u5750\u6807\u4e0e\u5e73\u8861\u6811\u7f16\u53f7\u4e4b\u95f4\u7684\u6620\u5c04\u3002\u90a3\u4e48\u6539\u53d8\u70b9\u7684\u5750\u6807\u53ef\u4ee5\u62c6\u5206\u4e3a\u4e00\u6b21\u5220\u9664\u52a0\u4e00\u6b21\u63d2\u5165\u3002\n\n\u7ef4\u62a4\u4e00\u4e2a\u70b9\u7684 $a$\uff0c\u5373\u7ef4\u62a4\u81ea**\u63d2\u5165\u6b64\u70b9\u4ee5\u6765**\u5e73\u8861\u6811**\u5927\u5c0f**\u7684\u6700\u5927\u503c**\u51cf\u4e00**\uff1b\u7ef4\u62a4 $b$\uff0c\u5373\u7ef4\u62a4\u81ea**\u63d2\u5165\u6b64\u70b9\u4ee5\u6765**\u5e73\u8861\u6811\u4e0a\u9664\u6b64\u70b9\u5916\u6743\u503c\u7684\u6700\u5927\u503c\u3002\u7531\u4e8e\u4e00\u4e2a\u70b9\u53ef\u80fd\u6210\u4e3a\u4e00\u68f5\u5e73\u8861\u6811\u5185**\u6743\u503c\u6700\u5927**\u7684\u70b9\uff0c\u56e0\u6b64\u6211\u4eec\u7ef4\u62a4\u81ea**\u63d2\u5165\u6b64\u70b9\u4ee5\u6765**\u5e73\u8861\u6811\u6700\u5927\u503c\u7684\u6700\u5927\u503c\u3001\u6700\u5927\u503c\u7684\u4e2a\u6570\u4e0e\u4e25\u683c\u6b21\u5927\u503c\u7684\u6700\u5927\u503c\u3002\n\n\u63d2\u5165\u4e00\u4e2a\u70b9\u65f6\uff0c\u4e3a\u4e86\u4e0d\u8ba9\u63d2\u5165\u6b64\u70b9**\u4e4b\u524d**\u7684\u6700\u4f18\u72b6\u6001\u5f71\u54cd\u6b64\u8282\u70b9\u53ca\u4e4b\u540e\u7684\u7b54\u6848\uff0c\u6211\u4eec\u6c42\u51fa\u5e73\u8861\u6811\u5f53\u524d\u7684\u6700\u5927\u503c\u53ca\u5176\u4e2a\u6570\u3001\u6b21\u5927\u503c\u4e0e\u5927\u5c0f\uff0c\u5bf9\u6574\u68f5\u5e73\u8861\u6811\u6253\u4e0a\u61d2\u6807\u8bb0\uff0c\u76f8\u5f53\u4e8e\u6574\u4f53\u66f4\u65b0**\u6b64\u5750\u6807**\u6240\u6709\u70b9\u7684\u7b54\u6848\uff1b\u5728\u5220\u9664\u4e00\u4e2a\u8282\u70b9\u524d\uff0c\u6211\u4eec\u67e5\u8be2\u6b64\u8282\u70b9**\u5728\u6b64\u5750\u6807**\u7684\u7b54\u6848\uff0c\u5e76\u66f4\u65b0\u6b64\u70b9\u6700\u7ec8\u7684\u7b54\u6848\u3002\n\n\u6ce8\u610f\u6700\u540e\u9700\u8981\u518d\u67e5\u8be2\u4e00\u904d\u6bcf\u4e2a\u8282\u70b9\u5728**\u5bf9\u5e94\u5750\u6807**\u7684\u7b54\u6848\u3002\n\n### AC code\n\n```cpp\n//written_by_FTL\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<map>\n#define ll long long\n#define LD long double\n#define i7 __int128\n#define re return\n#define con continue\nusing namespace std;\nconst int N=30005;\nint rd(){\n\tint ans=0,f=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')f^=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9')ans=(ans<<3)+(ans<<1)+(ch^48),ch=getchar();\n\tre f?-ans:ans;\n}\nint n,m,a[N],u,x,y,num;\nll maxn[N][2],INF=0x3f3f3f3f3f3f3f3f;\nstruct xxs{//\u5750\u6807\n\tint x,y;\n\tbool operator <(const xxs &a)const{\n\t\tif(x==a.x)re y<a.y;\n\t\tre x<a.x;\n\t}\n}p[30005];\nmap<xxs,int>mp;\nstruct node{\n\tint mx,ms,sc,s;\n}ans,zz={0,0,0,0};\nnode mg(node a,node b){\n\tnode c;\n\tif(a.mx>b.mx)c.mx=a.mx,c.ms=a.ms;\n\telse if(a.mx<b.mx)c.mx=b.mx,c.ms=b.ms;\n\telse c.mx=a.mx,c.ms=a.ms>b.ms?a.ms:b.ms;\n\tc.sc=a.sc>b.sc?a.sc:b.sc;\n\tc.s=a.s>b.s?a.s:b.s;\n\tre c;\n}\nstruct bird{//\u70b9\u7684\u503c\u4e0e\u7f16\u53f7\n\tll w;int n;\n\tbool operator <(const bird &x)const{\n\t\tif(w==x.w)re n<x.n;\n\t\tre w<x.w;\n\t}\n};\nnamespace SPT{\n\t#define t d[v]\n\t#define tx d[vx]\n\t#define vf t.f\n\t#define vl t.c[b]\n\t#define vr t.c[b^1]\n\t#define tf d[vf]\n\t#define tl d[vl]\n\t#define tr d[vr]\n\t#define z lz[v]\n\t#define zl lz[vl]\n\t#define zr lz[vr]\n\t#define rt d[i-1].c[1]\n\tint num=330000,x[2],b=0;\n\tstruct data{\n\t\tint c[2]={0},s=0,f;bird w;node al=zz;\n\t}d[1330000];\n\tstruct lazy{\n\t\tnode m=zz;\n\t}lz[1330000];\n\tint nw(bird k){\n\t\tint v=++num;\n\t\tt.s=1,t.w=k,t.al={0,0,0,0};re v;\n\t}\n\tint gt(int v){re v==tf.c[1];}\n\tvoid pu(int v){t.s=tl.s+tr.s+1;}\n\tvoid cn(int v,int vx,int b){vl=vx,tx.f=v;}\n\tvoid ro(int v){\n\t\tint b=gt(v),f=vf;\n\t\tcn(f,vr,b),cn(tf.f,v,gt(f)),cn(v,f,b^1);\n\t\tpu(f);\n\t}\n\tvoid pd(int v){\n\t\tif(z.m.mx||z.m.ms||z.m.sc||z.m.s){\n\t\t\tzl.m=mg(z.m,zl.m),zr.m=mg(z.m,zr.m);\n\t\t\tt.al=mg(z.m,t.al),z.m=zz;\n\t\t}\n\t}\n\tvoid sp(int v,int p){\n\t\twhile(vf!=p){\n\t\t\tif(tf.f!=p)ro(gt(vf)==gt(v)?vf:v);\n\t\t\tro(v);\n\t\t}pu(v);\n\t}\n\tbool sk(bird k,int i){//\u67e5\u8be2\u975e\u4e25\u683c\u524d\u9a71\u548c\u4e25\u683c\u540e\u7ee7\n\t\tx[0]=x[1]=0;\n\t\tint v=rt,b;\n\t\twhile(v)pd(v),b=k<t.w,x[b]=v,v=vr;\n\t\tre d[x[0]].c[1];\n\t}\n\tbird kth(int k,int i){\n\t\tint v=rt;\n\t\twhile(k!=tl.s){\n\t\t\tif(k<tl.s)v=vl;\n\t\t\telse k-=tl.s+1,v=vr;\n\t\t}\n\t\tre t.w;\n\t}\n\tint rk(bird k,int i){\n\t\tint v=rt,ans=0;\n\t\twhile(v&&(k.w!=t.w.w||k.n!=t.w.n)){\n\t\t\tif(k<t.w)v=vl;\n\t\t\telse ans+=tl.s+1,v=vr;\n\t\t}\n\t\tre ans+tl.s;\n\t}\n\tvoid ins(int i,bird k){\n\t\tint b=sk(k,i),v=nw(k);\n\t\tcn(x[b],v,b^1),sp(v,i-1);\n\t\tnode tmp;\n\t\ttmp.s=d[rt].s-3;\n\t\ttmp.mx=kth(tmp.s+1,i).w;\n\t\ttmp.ms=tmp.s+1-(rk({tmp.mx,0},i)-1);\n\t\ttmp.sc=kth(tmp.s+1-tmp.ms,i).w;\n\t\tlz[rt].m=mg(lz[rt].m,tmp);\n\t}\n\tvoid del(int i,bird k){\t\n\t\tint b=sk(k,i),v=x[b];\n\t\tif(b)d[x[0]].w=d[x[1]].w,d[x[0]].al=d[x[1]].al;\n\t\tcn(vf,vl,gt(v));sp(vf,i-1);\n\t}\n\tnode qry(int i,bird k){\n\t\tsk(k,i);\n\t\tre d[x[0]].al;\n\t}\n\tvoid init(int i){\n\t\trt=nw({-1,0});\n\t\tint v=rt;\n\t\tvf=i-1;\n\t\tcn(v,nw({INF,0}),1);\n\t}\n\t#undef t\n}\nint main(){\n\tn=rd();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=rd(),x=rd(),y=rd();\n\t\tp[i]={x,y};\n\t\tif(mp.find(p[i])==mp.end())mp[p[i]]=++num,SPT::init(num);\n\t\tSPT::ins(mp[p[i]],{a[i],i});\n\t}\n\tm=rd();\n\tfor(int i=1;i<=m;i++){\n\t\tu=rd(),x=rd(),y=rd();\n\t\tint tmp=mp[p[u]];\n\t\tans=SPT::qry(tmp,{a[u],u}); \n\t\tmaxn[u][0]=max(maxn[u][0],(ll)ans.s);\n\t\tif(a[u]==ans.mx&&ans.ms==1)maxn[u][1]=max(maxn[u][1],(ll)ans.sc);\n\t\telse maxn[u][1]=max(maxn[u][1],(ll)ans.mx);\n\t\tSPT::del(tmp,{a[u],u});\n\t\tp[u]={x,y};\n\t\tif(mp.find(p[u])==mp.end())mp[p[u]]=++num,SPT::init(num);\n\t\tSPT::ins(mp[p[u]],{a[u],u});\n\t} \n\tfor(int i=1;i<=n;i++){\n\t\tans=SPT::qry(mp[p[i]],{a[i],i});\n\t\tmaxn[i][0]=max(maxn[i][0],(ll)ans.s);\n\t\tif(a[i]==ans.mx&&ans.ms==1)maxn[i][1]=max(maxn[i][1],(ll)ans.sc);\n\t\telse maxn[i][1]=max(maxn[i][1],(ll)ans.mx);\n\t\tprintf(\"%lld\\n\",maxn[i][0]*maxn[i][1]);\n\t}\n\tre 0;\n}\n```\n\n### $\\text{The End.}$",
        "postTime": 1651911694,
        "uid": 346440,
        "name": "FreeTimeLove",
        "ccfLevel": 7,
        "title": "P4200\u3010\u5343\u5c71\u9e1f\u98de\u7edd\u3011"
    }
]