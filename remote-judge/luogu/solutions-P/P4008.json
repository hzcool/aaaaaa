[
    {
        "content": "\u6c42\u7ba1\u7406\u5458\u8ba9\u8fc7\n\n\u5148\u63a8\u5e7f\u4e00\u4e0b \n\n# [MY BLOG](https://www.cnblogs.com/HenryHuang-Never-Settle/p/10803406.html)\n\n\n---\n\n\u6211\u4eec\u8003\u8651\u8fd9\u6837\u7684\u4e00\u4e2a\u95ee\u9898\n\n\u7ed9\u4f60\u4e00\u4e2a\u5e8f\u5217\uff0c\u8981\u6c42\u4f60\u652f\u6301\u63d2\u5165\uff0c\u5220\u9664\uff0c\u67e5\u8be2\u5355\u70b9\u503c\n\n\u5982\u679c\u7528\u6570\u7ec4\uff0c\u67e5\u8be2O(1),\u63d2\u5165\u5220\u9664\u6700\u574fO(n)\n\n\u5982\u679c\u7528\u94fe\u8868\uff0c\u63d2\u5165\u5220\u9664O(1),\u67e5\u8be2\u6700\u574fO(n)\n\n\u5982\u679c\u7528\u5e73\u8861\u6811\u2026\u2026\n\n~~\u4e0d\u8981\u8ddf\u6211\u8bf4\u5e73\u8861\u6811~~\n\n\u90a3\u4e48\u6211\u4eec\u662f\u5426\u53ef\u4ee5\u8003\u8651:\u5c06\u4e00\u4e2a\u4e00\u4e2a\u7684\u6570\u7ec4\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u4e32\u8d77\u6765,\u8fd9\u6837\u662f\u5426\u4f1a\u63d0\u9ad8\u64cd\u4f5c\u7684\u6548\u7387\uff0c\u53c8\u662f\u5426\u4f1a\u964d\u4f4e\u4e00\u4e9b\u64cd\u4f5c\u7684\u6548\u7387\u5462\uff1f\n\n![](https://i.loli.net/2019/05/02/5ccaea7489faa.png)\n\n\u53ef\u4ee5\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\u5404\u79cd\u64cd\u4f5c\n\n\u5757\u72b6\u94fe\u8868\u5c31\u662f\u8fd9\u6837\u4e00\u4e2a\u7565\u663e\u66b4\u529b\u7684\u7b97\u6cd5\n\n\u4f46\u5176\u590d\u6742\u5ea6\u8f83\u4e3a\u4f18\u79c0\uff0c\u6240\u4ee5\u5728\u5f88\u591a\u5730\u65b9\u7684\u5e94\u7528\u90fd\u975e\u5e38\u5e7f\n\n\u7528\u4e00\u53e5\u8bdd\u8bf4\u53eb\u201c\u5f31\u5f31\u8054\u5408\u201d\n\n\u7801\u91cf~~\u7a0d~~\u5927\uff0c\u4f46\u6781\u6613\u7406\u89e3\uff0c\u6253\u7740\u6253\u7740\u5c31\u6253\u51fa\u4e24\u767e~~K~~\u884c\n\n\u5148\u4ecb\u7ecd\u4e00\u4e0b\u6bd4\u8f83\u57fa\u672c\u7684\u64cd\u4f5c\u5427\n\n### Spilt\n\u5f53\u4e00\u4e2a\u5757\u7684\u957f\u5ea6\u8fc7\u5927\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u8003\u8651\u5c06\u5176\u5206\u88c2\u6210\u4e24\u4e2a\u8f83\u5c0f\u7684\u5757\u3002\n\n\u5728\u5904\u7406\u7c7b\u4f3c\u4e8e\u63d2\u5165\u6216\u8005\u5220\u9664\u8fd9\u7c7b\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4ece\u5f53\u524d\u4f4d\u7f6e\u5c06\u5176\u5206\u88c2\u6210\u4e24\u4e2a\u5757\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5341\u5206\u65b9\u4fbf\u7684\u8fdb\u884c\u64cd\u4f5c\u4e86\u3002\n\n![](https://i.loli.net/2019/05/02/5ccaeb4da07e5.png)\n\n### Merge\n\n\u540c\u7406,\u5c31\u662f$Split$\u7684\u9006\u8fd0\u7b97\u3002\n\n### \u90e8\u5206Maintain\n\n\u770b\u5230\u5f88\u591a\u4ee3\u7801\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u64cd\u4f5c\u90fd\u904d\u5386\u4e00\u904d\u6574\u4e2a\u94fe\u8868\uff0c\u5176\u5b9e\u5927\u53ef\u4e0d\u5fc5\u3002\n\n\u59d1\u4e14\u79f0\u5176\u4e3a\u90e8\u5206maintain\u5427\uff0c\u6211\u4e5f\u4e0d\u77e5\u9053\u53eb\u4ec0\u4e48\u3002\n\n\u5728\u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u4f7f\u5f97\u4e00\u4e9b\u5757\u8fc7\u5927\uff0c\u4e00\u4e9b\u5757\u8fc7\u5c0f\u3002\n\n\u6240\u4ee5\u6211\u4eec\u9700\u8981\u901a\u8fc7$Spilt$\u6216\u8005$Merge$\u6765\u8c03\u6574\u3002\n\n\u6211\u4eec\u53d1\u73b0\uff0c\u5728\u8fdb\u884c\u64cd\u4f5c\u65f6\u6240\u9700\u8981\u8003\u8651\u7684\u9700\u8981\u7ef4\u62a4\u7684\u5757:\u533a\u95f4\u524d\u7684\u90a3\u4e00\u5757\u4e0e\u533a\u95f4\u5f00\u5934\u5757\uff1b\u533a\u95f4\u672b\u5c3e\u5757\u4e0e\u533a\u95f4\u540e\u7684\u90a3\u4e00\u5757\u3002\n\n\u8fd9\u6837\u505a**\u53ef\u80fd**\u4f1a\u4f7f\u5f97\u5757\u72b6\u94fe\u8868\u6ca1\u6709\u5728\u7ecf\u8fc7\u5b8c\u6574maintain\u64cd\u4f5c\u65f6\u5e73\u8861\uff0c\u4f46\u4f1a**\u5927\u5927\u51cf\u5c11**\u7ef4\u62a4\u65f6\u7684\u5e38\u6570\uff0c\u800c\u5e73\u8861\u7a0b\u5ea6\u4e5f\u53ef\u4ee5\u63a5\u53d7\u3002\n\n\u4e00\u822c\u91c7\u7528\u7684\u7ef4\u62a4\u65b9\u6cd5\uff1a\u4fdd\u8bc1\u76f8\u90bb\u4e24\u5757\u5927\u5c0f\u52a0\u8d77\u6765\u5927\u4e8e$\\sqrt{n}$,\u4f46\u6bcf\u5757\u5927\u5c0f\u4e0d\u8d85\u8fc7$\\sqrt{n}$\uff0c\u8fd9\u6837\u53ef\u4ee5\u8f83\u597d\u7684\u7ef4\u62a4\u5e73\u8861\uff0c\u540c\u65f6\u4e0d\u7528\u8003\u8651\u5f53\u5757\u8f83\u5927\u65f6\u7684$Split$\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u5757\u7684\u6570\u91cf\u63a7\u5236\u5728$[\\sqrt{n},\\sqrt{2n}]$\n\n\u8fd9\u662f\u4f5c\u8005\u7ecf\u8fc7\u6743\u8861\u540e\u5f97\u51fa\u7684\u505a\u6cd5\uff0c\u5b9e\u6d4b\u590d\u6742\u5ea6\u4f18\u79c0\uff0c\u590d\u6742\u5ea6\u4e3a$O(1)$\u3002\n\n---\n\n\u7136\u540e\uff0c\u6211\u4eec\u5207\u5165\u6b63\u9898\u3002\n\n### Insert\n\n\u67e5\u627e\u5149\u6807\u5757\u5185\u7684\u4f4d\u7f6e\uff0c\u5728\u6b64\u4f4d\u7f6e\u5c06\u5757\u5206\u88c2\uff0c\u7136\u540e\u5c06\u5b57\u7b26\u4e32**\u4e00\u5757\u4e00\u5757**\u5730\u63d2\u5165\n\n### Delete\n\n\u540c\u7406\n\n### Get\n\n\u4e0d\u8bb8\u8981\u5206\u88c2\uff0c\u76f4\u63a5\u5229\u7528$memcpy$\u51fd\u6570\uff0c\u5bf9\u5176\u8fdb\u884c\u590d\u5236\u7c98\u8d34\u5373\u53ef\n\n\u4ee3\u7801\u4e2d\u6709\u8f83\u8be6\u7ec6\u6ce8\u91ca\uff0c\u8d34\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nchar xch,xB[1<<15],*xS=xB,*xTT=xB;\n#define getc() (xS==xTT&&(xTT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xTT)?0:*xS++)\ninline int read()\n{\n    int x=0,f=1;char ch=getc();\n    while(ch<'0'|ch>'9'){if(ch=='-')f=-1;ch=getc();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getc();}\n    return x*f;\n}//\u4e3a\u4e86\u4f7f\u7a0b\u5e8f\u8dd1\u5f97\u66f4\u5feb\u6240\u4f7f\u7528\u7684\u8bfb\u5165\u4f18\u5316 \nconst int maxn=2e3+10;\nstruct node{\n    int nex,siz;//\u6bcf\u4e00\u5757\u6570\u7ec4\u7684\u540e\u7ee7\u4ee5\u53ca\u5927\u5c0f \n    char a[maxn<<1];\n}b[maxn<<2];\nint pool[maxn<<2],cnt,curpos;//\u5185\u5b58\u6c60\u3001\u6307\u9488\u4ee5\u53ca\u5f53\u524d\u5149\u6807\u4f4d\u7f6e \ninline int modi(){return pool[cnt++];}//\u5185\u5b58\u5206\u914d \ninline void dele(int x){pool[--cnt]=x;}//\u5185\u5b58\u56de\u6536 \ninline void init()\n{\n    for(int i=1;i<(maxn<<2);++i) pool[i]=i;//\u7ef4\u62a4\u5185\u5b58\u6c60\uff0c\u52a8\u6001\u5206\u914d\u56de\u6536\u5185\u5b58 \n    cnt=1;\n    b[0].siz=0,b[0].nex=-1;//\u65b0\u5efa\u4e00\u4e2a0\u53f7\u8282\u70b9\uff0c\u65b9\u4fbf\u64cd\u4f5c \n}\ninline void add(int x,int y,int num,char c[])//\u5728\u7b2cx\u5757\u540e\u6dfb\u52a0\u4e00\u4e2a\u7f16\u53f7\u4e3ay\u7684\u5757\uff0c\u957f\u5ea6\u4e3anum \n{\n    if(y!=-1)\n    {\n        b[y].nex=b[x].nex,b[y].siz=num;\n        memcpy(b[y].a,c,num);\n    }\n    b[x].nex=y;\n}\ninline void merge(int x,int y)//\u5c06\u7b2cx\u5757\u548c\u7b2cy\u5757\u5408\u5e76 \n{\n    memcpy(b[x].a+b[x].siz,b[y].a,b[y].siz);\n    b[x].siz+=b[y].siz,b[x].nex=b[y].nex;\n    dele(y);\n}\ninline void split(int cur,int pos)//\u5c06\u7b2ccur\u5757\u4ecepos\u5904\u5206\u5272 \n{\n    if(cur==-1||pos==b[cur].siz) return ;\n    add(cur,modi(),b[cur].siz-pos,b[cur].a+pos);\n    b[cur].siz=pos;\n}\ninline int pos(int &x)//\u5bfb\u627e\u5f53\u524d\u5149\u6807\u6240\u5728\u7684\u5757\u548c\u5757\u5185\u4f4d\u7f6e \n{\n    int now=0;\n    while(now!=-1&&x>b[now].siz) x-=b[now].siz,now=b[now].nex;\n    return now;\n}\ninline void insert(int p,int num,char c[])//\u5728p\u4f4d\u7f6e\u4e4b\u540e\u63d2\u5165\u957f\u5ea6\u4e3anum\u7684\u5b57\u7b26\u4e32 \n{\n    int now=pos(p);\n    split(now,p);\n    int tot=0,nb,st=now;\n    while(tot+maxn<=num)//\u7ef4\u62a4\u5757\u72b6\u94fe\u8868\u5e73\u8861 \n    {\n        nb=modi();\n        add(now,nb,maxn,c+tot);\n        tot+=maxn;\n        now=nb;\n    }\n    if(num-tot)\n        nb=modi(),add(now,nb,num-tot,c+tot);\n    if(b[now].siz+b[nb].siz<maxn&&nb!=-1)//\u4e0d\u7528\u5bf9\u6574\u4e2a\u94fe\u8868\u8fdb\u884c\u5224\u65ad\uff0c\u90e8\u5206maintain \n    \tmerge(now,nb),nb=b[now].nex;\n    if(b[st].siz+b[b[st].nex].siz<maxn&&b[st].nex!=-1)//\u540c\u7406 \n    \tmerge(st,b[st].nex);\n//    maintain();\n}\ninline void erase(int p,int num)//\u5728p\u4f4d\u7f6e\u4e4b\u540e\u5220\u9664\u957f\u5ea6\u4e3anum\u7684\u5b57\u7b26\u4e32\n{\n    int now=pos(p);\n    split(now,p);\n    int nex=b[now].nex;\n    while(nex!=-1&&num>b[nex].siz)\n        num-=b[nex].siz,nex=b[nex].nex;\n    split(nex,num);\n    nex=b[nex].nex;\n    for(int i=b[now].nex;i!=nex;i=b[now].nex)\n        b[now].nex=b[i].nex,dele(i);\n    while(b[now].siz+b[nex].siz<maxn&&nex!=-1)//\u4e0d\u7528\u5bf9\u6574\u4e2a\u94fe\u8868\u8fdb\u884c\u5224\u65ad\uff0c\u90e8\u5206maintain \n    \tmerge(now,nex),nex=b[now].nex;\n//    maintain();\n}\nchar ans[20000000];\ninline void get(int p,int num)//\u8f93\u51fap\u4f4d\u7f6e\u540e\u957f\u5ea6\u4e3anum\u7684\u5b57\u7b26\u4e32\n{\n    int cur=pos(p);\n    int tot=b[cur].siz-p;\n    if(num<tot) tot=num;\n    memcpy(ans,b[cur].a+p,tot);\n    int now=b[cur].nex;\n    while(now!=-1&&num>=tot+b[now].siz)\n    {\n        memcpy(ans+tot,b[now].a,b[now].siz);\n        tot+=b[now].siz,now=b[now].nex;\n    }\n    if(num-tot>0&&now!=-1)\n        memcpy(ans+tot,b[now].a,num-tot);\n    ans[num]='\\0';//\u4e3a\u4e86\u4e0d\u6e05\u7a7a\uff0c\u7528\\0\u7ed3\u675f \n    printf(\"%s\\n\",ans);\n}\ninline char opt()\n{\n\tchar c=getc();\n\twhile(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=getc();\n\treturn c;\n}//\u4e3a\u4e86\u4e0d\u4e0e\u8bfb\u5165\u4f18\u5316\u51b2\u7a81 \nint main()\n{\n//\tfreopen(\"3.in\",\"r\",stdin);\n//\tfreopen(\"3.ans\",\"w\",stdout);\n    init();\n    int m;\n\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;++i)\n    {\n        switch(opt())\n        {\n            case 'M':curpos=read();break;\n            case 'I':\n                int tmp;\n                tmp=read();\n                for(int i=0;i<tmp;++i)\n                {\n                    ans[i]=getc();\n                    if(ans[i]<32||ans[i]>126) --i;\n                }\n                insert(curpos,tmp,ans);\n                    break;\n            case 'D':\n                tmp=read();\n                erase(curpos,tmp);\n                break;\n            case 'G':\n                tmp=read();\n                get(curpos,tmp);\n                break;\n            case 'P':--curpos;break;\n            case 'N':++curpos;break;\n        }\n    }\n    return 0;\n}\n```\n\n\n\n\n\n\n",
        "postTime": 1556803104,
        "uid": 43957,
        "name": "HenryHuang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4008 [NOI2003]\u6587\u672c\u7f16\u8f91\u5668"
    },
    {
        "content": "# S~~p~~lay\u5927\u6cd5\u543c\u554a\n\n\u5c31\u50cf\u697c\u4e0a\u5927\u4f6c\u8bf4\u7684\uff0cSplay\u662f\u5e8f\u5217\u4e4b\u738b\uff0c\u6240\u4ee5\u89e3\u51b3\u8fd9\u79cd\u95ee\u9898\u7b80\u76f4\u662f\u6beb\u65e0\u95ee\u9898\u554a\u3002\n\n\u9996\u5148\uff0c\u5982\u679c\u4f60\u505a\u8fc7[**P2042** [NOI2005]\u7ef4\u62a4\u6570\u5217](https://www.luogu.org/problemnew/show/P2042)\u90a3\u4e48\u8fd9\u9053\u9898\u7b80\u76f4\u662f\u5c0f\u83dc\u4e00\u789f\uff0c\u5982\u679c\u6ca1\u6709\u505a\u8fc7\u4e5f\u4e0d\u8981\u7d27\uff0c\u770b\u8fd9\u91cc[\u533a\u95f4\u6811Splay\u2014\u2014[NOI2005]\u7ef4\u62a4\u6570\u5217](https://www.cnblogs.com/hyfhaha/p/10749519.html)\uff0c\u597d\u5427\uff0c\u5982\u679c\u4f60\u5b9e\u5728\u662f\u4e0d\u60f3\u505a\u90a3\u9053\u6bd2\u7624\u9898\uff0c\u4e5f\u4e0d\u8981\u7d27\uff0c\u6211\u4e00\u6837\u4f1a\u5728\u8fd9\u91cc\u8be6\u7ec6\u5730\u8bb2\u6e05\u695a\u6b65\u9aa4\u7684QwQ\u3002\n\n\u9996\u5148\u662f\u5bf9\u533a\u95f4\u6811Splay\u7684\u4e00\u4e2a\u4ecb\u7ecd\uff0c\u76f4\u63a5\u5f15\u7528\u4e86\u81ea\u5df1\u7684blog\n\n# \u533a\u95f4\u6811Splay\u4ecb\u7ecd\n\n\u505a\u8fc7\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u7684\u90fd\u77e5\u9053\uff0c\u5728\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u91cc\uff0cSplay\u662f\u6309\u7167\u6743\u503c\u6765\u6392\u5e8f\u7684\uff0c\u6240\u4ee5\u80fd\u7ef4\u62a4\u6570\u7684\u5173\u7cfb\u3002\u90a3\u4e48\u73b0\u5728\u5230\u4e86\u7ef4\u62a4\u533a\u95f4\u4e0a\u7684\u64cd\u4f5c\u4e86\uff0c\u4e5f\u5c31\u4e0d\u80fd\u6309\u6743\u503c\u6765\u6392\u5e8f\u4e86\u3002\n\n\u533a\u95f4\u6811\uff0c\u6211\u4eec\u6309\u7167\u7684\u662f\u5e8f\u5217\u4e2d\u7684**\u7f16\u53f7**\u6765\u6392\u5e8f\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5e8f\u5217\u4e2d\u7684\u7b2c**k**\u4e2a\u70b9\uff0c\u5728Splay\u4e2d\u4e5f\u662f\u7b2c**k**\u5927\u7684\u3002\uff08\u6309\u7f16\u53f7\u6392\u5e8f\u561b\n\n\u6240\u4ee5\u6211\u4eec\u60f3\u8981\u67e5\u627e\u5e8f\u5217\u4e2d\u7b2c**k**\u4e2a\u4f4d\u7f6e\uff0c\u5c31\u76f4\u63a5\u627e**Splay**\u4e2d\u7684\u7b2c**k**\u5927\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6240\u4ee5\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u91cc\u7684**Splay**\u64cd\u4f5c\uff0c**rotate**\u64cd\u4f5c\u548c**kth**\u64cd\u4f5c\u90fd\u662f\u53ef\u4ee5\u76f4\u63a5\u7167\u642c\u7684\uff08\u4e00\u6837\u7684\uff0c\u53ea\u662f\u7ef4\u62a4\u7f16\u53f7\u800c\u5df2\n\n\u90a3\u4e48\u6211\u4eec\u600e\u4e48\u5728Splay\u4e2d\u627e\u5230\u4e00\u4e2a\u533a\u95f4[x,y]\u5462\uff1f\n\n\u6211\u4eec\u53ef\u4ee5\u8003\u8651Splay\u7684\u6027\u8d28\uff0c\u5c06 **x** Splay\u4e0a\u6839\uff0c\u518d\u5c06 **y** Splay\u4e0a\u5230x\u7684\u53f3\u8282\u70b9\uff0c\u90a3\u4e48\u6211\u4eec\u5f97\u51fa\u7684 **y** \u7684\u5de6\u5b50\u6811\u5c31\u662f\u6211\u4eec\u8981\u7684[x,y]\u533a\u95f4\u3002\n\n\u4e4b\u540e\u6211\u4eec\u60f3\u5bf9\u8fd9\u4e2a\u533a\u95f4\u505a\u4ec0\u4e48\u5c31\u53ef\u4ee5\u76f4\u63a5\u5bf9\u90a3\u9897\u5b50\u6811\u505a\u4e86\u3002 \n\n\u4e0a\u9762\u5c31\u662f\u533a\u95f4\u6811Splay\u7684\u4e00\u4e9b\u4ecb\u7ecd\n\n### \u4ee3\u7801\u4e2d\u7684\u4e00\u4e9b\u5b8f\u5b9a\u4e49\n\n```cpp\n#define L(node) (tree[node].ch[0])\t\t//\u66ff\u5de6\u513f\u5b50\n#define R(node) (tree[node].ch[1])\t\t//\u66ff\u53f3\u513f\u5b50\n#define F(node) (tree[node].fa)\t\t\t//\u66ff\u7236\u4eb2\n#define V(node) (tree[node].val)\t\t//\u66ff\u6743\u503c\n#define S(node) (tree[node].size)\t\t//\u66ff\u5b50\u6811\u5927\u5c0f\n```\n\n## \u5b9a\u4e49\n\n```cpp\nstruct kkk{\n\tint ch[2],size,fa;\t//\u57fa\u672c\u4fe1\u606f\uff0c\u5de6\u53f3\u513f\u5b50\uff0c\u5b50\u6811\u5927\u5c0f\u548c\u7236\u4eb2\n\tchar val;\t\t\t\t\t\t//\u5f53\u524d\u7684\u4fe1\u606f\n\tvoid clear(){ch[0]=ch[1]=fa=0;}\t//\u6e05\u7a7a\n}tree[maxn];\n```\n\n\n\n# \u64cd\u4f5c\u5256\u6790\n\n\u8fd9\u91cc\u8ba9\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a\u5149\u6807\uff0c\u5176\u5b9e\u5c31\u662f\u7ef4\u62a4\u6211\u4eec\u8981\u5728\u5e8f\u5217\u4e2d\u64cd\u4f5c\u7684\u4f4d\u7f6e\u3002\u81f3\u4e8e\u600e\u4e48\u7ef4\u62a4\uff0c\u5f00\u4e2a\u53d8\u91cf\u5c31\u53ef\u4ee5\u5566\uff0c\u53ef\u4ee5\u8bf4\u662f\u6ca1\u6709\u4ec0\u4e48\u8111\u5b50\u4e86\u3002\u4ee3\u7801\u4e2d\u7684GB\u5c31\u662f\u5149\u6807\u5566QvQ\uff01\n\n\u7136\u540e\u6211\u4eec\u6765\u5904\u7406\u4e00\u4e0b\u8fb9\u754c\uff0c\u8981\u77e5\u9053\u533a\u95f4\u6811Splay\u7684\u8fb9\u754c\u662f\u5fc5\u8981\u7684\uff0c\u6240\u4ee5\u600e\u4e48\u52a0\u8fd9\u4e2a\u8fb9\u754c\u4e5f\u662f\u4e00\u4e2a\u95ee\u9898\uff0c\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8fd0\u7528\u201c\u7ef4\u62a4\u6570\u5217\u201d\u90a3\u9053\u9898\u7684\u65b9\u6cd5\uff0c\u53ea\u4e0d\u8fc7\u521a\u5f00\u59cb\u4e0d\u7528\u518d\u8f93\u5165\u6570\u800c\u5df2\u3002\n\n\u7136\u540e\u63d2\u5165\u64cd\u4f5c\u5199\u5728insert\u51fd\u6570\u91cc\u4e86\n\n\u5220\u9664\u64cd\u4f5c\u5199\u5728eraser\u91cc\u4e86\n\n\u67e5\u8be2\u64cd\u4f5c\u5199\u5728query\u91cc\u4e86\n\n\u8fd9\u91cc\u5148\u653e\u4e00\u4e0b\u4e3b\u51fd\u6570\uff1a\n\n```cpp\nint main(){\n\tscanf(\"%d\",&m);n=0;\n\ta[1]=a[n+2]=-inf;\n\tfor(int i=1;i<=n+2;i++)id[i]=i;\t//\u8fb9\u754c,n=0\u6240\u4ee5\u5176\u5b9e\u5c31\u662f1\u548c2\u4e24\u4e2a\u8fb9\u754c\u800c\u5df2\n\tbuild(1,n+2,0);\t//\u4e00\u6837\u53ea\u67091\u548c2\u4e24\u4e2a\u8fb9\u754c\n\tcnt=n+2;root=(n+3)>>1;\t//\u4e00\u6837\u53d1\u73b0cnt\u5c31\u662f2\uff0croot\u5c31\u662f1\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%s\",mode);\n\t\tif(mode[0]=='P'){GB--;continue;}\t//\u7ef4\u62a4\u5149\u6807\u5de6\u79fb\n\t\tif(mode[0]=='N'){GB++;continue;}\t//\u7ef4\u62a4\u5149\u6807\u53f3\u79fb\n\t\tscanf(\"%d\",&len);\n\t\tif(mode[0]=='M')GB=len;\t\t\t\t//\u7ef4\u62a4\u5149\u6807\u79fb\u52a8\n\t\tif(mode[0]=='I')insert(GB,len);\t\t//\u63d2\u5165\uff0c\u5df2\u7ecf\u81ea\u52a8\u9ed8\u8ba4\u662fGB\u540e\u9762\u4e86\uff0c\u6240\u4ee5\u4e0d\u7528+1\n\t\tif(mode[0]=='D')eraser(GB+1,len);\t//\u5220\u9664\uff0cGB+1\u662fGB\u7684\u540e\u9762\n\t\tif(mode[0]=='G')query(GB+1,len);\t//\u67e5\u8be2\uff0c\u4e00\u6837\u8981+1\n\t\t//printf(\"PRINT:\"); print(root);printf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n## 1.\u57fa\u672c\u64cd\u4f5c Splay,rotate,kth\n\n\u8fd9\u4e2a\u5c31\u4e0d\u7528\u600e\u4e48\u8bf4\u4e86\u5427\uff0c\u5927\u5bb6\u5728\u505a\u5e73\u8861\u6811Splay\u90fd\u5199\u8fc7\u7684\u5566\uff01\u4e00\u6837\u7684\uff01\n\n## 2.\u5c06\u6307\u5b9a\u533a\u95f4\u627e\u51fa\u6765 split\u64cd\u4f5c\n\n\u548c\u4e0a\u9762\u8bb2\u7684\u533a\u95f4\u6811\u4e00\u6837\uff0c\u5148\u627e\u5230\u533a\u95f4[l,r]\u7684kth\uff0c\u8ba1**l**\u7684kth\u4e3a**x**\uff0c**r**\u7684kth\u4e3a**y**\u3002\n\n\u7136\u540eSplay(x,0);Splay(y,x); \uff08\u76f4\u63a5\u4e0a\u4ee3\u7801\u89e3\u91ca\uff09\n\n\u6700\u540e\u8fd4\u56de**y**\u7684**\u5de6\u513f\u5b50**\u5c31\u662f\u6307\u5b9a\u533a\u95f4\n\n\u4ee3\u7801\uff1a\n\n```cpp\nint split(int k,int len){\t//\u627e\u5230\u90a3\u4e2a\u533a\u95f4\u7684\u4f4d\u7f6e\n\tint x=kth(k),y=kth(k+len+1);\n\tSplay(x,0);Splay(y,x);\n\treturn L(y);\t\t\t\t\t\t//\u8fd4\u56de\u7684\u5373\u662f\u533a\u95f4\u5728Splay\u6811\u4e0a\u7684\u4f4d\u7f6e\n}\n```\n\n## 3.\u5efa\u4e00\u9897\u5e73\u8861\u7684Splay\uff0cbuild\u64cd\u4f5c\n\n\u4e00\u5f00\u59cb\u6211\u4eec\u8981\u6784\u9020\u4e00\u9897\u6709\u521d\u59cb\u4fe1\u606f\u7684Splay\uff0c\u4e00\u4e2a\u4e00\u4e2ainsert\u663e\u7136\u5f88\u6162\uff0c\u6240\u4ee5\u6211\u4eec\u5199\u4e00\u4e2abuild\uff0c\u53ef\u4ee5\u5c06\u4e00\u6bb5\u5e8f\u5217\u5efa\u6210\u4e00\u9897\u5e73\u8861\u7684Splay\u7684\u64cd\u4f5c\u3002\n\n\u5176\u5b9e\u5199\u8d77\u6765\u548c**\u7ebf\u6bb5\u6811**\u5dee\u4e0d\u591a\uff0c\u6ce8\u610f\u662f\u4ee5**\u7f16\u53f7**\u6392\u5e8f\u6765\u5efa\u6811\u3002\n\n```cpp\nvoid build(int begin,int end,int pre){\n\tint mid=(begin+end)>>1;int node=id[mid],fa=id[pre];\n\tif(begin==end){tree[node].size=1;tree[node].val=a[begin];}\t//\u4e00\u6837\u7684\u8d4b\u503c\u4fe1\u606f\n\tif(begin<mid)build(begin,mid-1,mid);\t\t//\u5de6\u513f\u5b50\u5efa\u6811\n\tif(end>mid)build(mid+1,end,mid);\t\t\t\t//\u53f3\u513f\u5b50\u5efa\u6811\n\ttree[node].val=a[mid];tree[node].fa=fa;\t\t//\u8d4b\u503c\u4fe1\u606f\n\tpushup(node);\t\t\t\t//\u66f4\u65b0\u4e00\u4e0bsize\n\ttree[fa].ch[mid>=pre]=node;\n}\n```\n\n## 4.\u63d2\u5165insert\u64cd\u4f5c\n\n\u8fd9\u73a9\u610f\u7684\u8f93\u5165\u8981\u6ce8\u610f\u4e00\u4e0b\u5566\uff01\n\n\u8fd9\u91cc\u9898\u76ee\u8981\u6c42\u7684\u662f\u5728GB\u4f4d\u7f6e\u540e\u63d2\u5165\u4e00\u6bb5\u957f\u4e3alen\u7684\u5e8f\u5217\n\n\u5982\u679c\u6211\u4eec\u8fd8\u662f\u4e00\u4e2a\u4e00\u4e2a\u63d2\u5165\uff0c\u4ecd\u7136\u5f88\u6162\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u628a\u63d2\u5165\u7684\u5e8f\u5217build\u6210\u4e00\u9897\u5e73\u8861\u7684\u5b50\u6811\uff0c\u6700\u540e\u76f4\u63a5\u5728GB\u540e\u63d2\u5165\u5efa\u6210\u7684\u5b50\u6811\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```cpp\nvoid insert(int k,int len){\n\tfor(int i=1;i<=len;i++){\n\t\ta[i]=getchar();\t\t\t//\u8bfb\u5165\u6ce8\u610f\u4e00\u4e0b\n\t\tif(a[i]=='\\n'||a[i]=='\\r')--i;\n\t}\n\tfor(int i=1;i<=len;i++)id[i]=rublish();\t//\u4ece\u5783\u573e\u6876\u91cc\u62ff\u7f16\u53f7\uff0c\u51cf\u5c11\u7a7a\u95f4\n\tbuild(1,len,0);\t\t\t\t//build\u6210\u4e00\u9897\u5b8c\u5168\u4e8c\u53c9\u6811\n\tint z=id[(len+1)>>1];\n\tint x=kth(k+1),y=kth(k+2);\n\tSplay(x,0);Splay(y,x);\n\ttree[z].fa=y; tree[y].ch[0]=z;\t//\u5c06\u6811\u63d2\u5230\u539f\u6811\u4e0a\n\tpushup(y); pushup(x);\t//\u66f4\u65b0\n}\n```\n\n## 5.\u5220\u9664\u64cd\u4f5c eraser\n\n\u8fd9\u4e2a\u5c31\u66f4\u7b80\u5355\u4e86\uff0c\u76f4\u63a5\u627e\u5230\u90a3\u4e2a\u533a\u95f4\uff0c\u7136\u540e\u8ba9\u90a3\u4e2a\u5b50\u6811\u7684\u7236\u4eb2\u5c06\u5de6\u513f\u5b50\u6e05\u4e3a0\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4f46\u662f\uff0c\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u6211\u4eec\u52a0\u5165\u4e86\u4e00\u4e2a\u5783\u573e\u56de\u6536\u7684\u64cd\u4f5c\uff0c\u5c31\u662f\u5c06\u5220\u9664\u7684\u8282\u70b9\u91cd\u65b0\u5229\u7528\u8d77\u6765\uff0c\u4ee5\u8282\u7701\u7a7a\u95f4\n\n\u6240\u4ee5\u6211\u4eec\u8fd8\u8981\u904d\u5386\u4e00\u904d\u5b50\u6811\u5c06\u90a3\u9897\u5b50\u6811\u7684\u8282\u70b9\u6254\u8fdb\u5783\u573e\u6876\u91cc\n\n```cpp\nint rublish(){\t\t\t\t//\u5783\u573e\u56de\u6536\n\tif(top==0)return ++cnt;\n\tint node=rub[top--];\n\treturn node;\n}\nvoid remove(int node){\t\t//\u5c06\u4e00\u4e2a\u5b50\u6811\u6e05\u7a7a\n\tif(L(node))remove(L(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u5de6\u5b50\u6811\n\tif(R(node))remove(R(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u53f3\u5b50\u6811\n\trub[++top]=node; tree[node].clear();\t//\u6e05\u7a7a\u5e76\u4ecd\u8fdb\u5783\u573e\u6876\uff0c\u5b9a\u4e49\u91cc\u6709\n}\nvoid eraser(int x,int len){\t\t\t//\u5220\u9664\u533a\u95f4\n\tint node=split(x,len),y=F(node);//\u627e\u5230\u8be5\u533a\u95f4\n\tremove(node);tree[y].ch[0]=0;\t//\u5220\u9664\u8be5\u533a\u95f4\uff0c\u5b50\u6811\u6e05\u7a7a\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\n```\n\n## 6.\u67e5\u8be2 query\n\n\u627e\u5230\u90a3\u4e2a\u533a\u95f4\uff0c\u7136\u540e\u904d\u5386\u6574\u4e2a\u6811\uff0c\u8f93\u51fa\u7b54\u6848\u3002\n\n```cpp\nvoid print(int node){\n\tif(L(node))print(L(node));\t//\u5f80\u5de6\u513f\u5b50\u8d70\n\tprintf(\"%c\",tree[node].val);//\u8f93\u51fa\u5f53\u524d\u7684\u4fe1\u606f\n\tif(R(node))print(R(node));\t//\u5f80\u53f3\u513f\u5b50\u8d70\n}\nvoid query(int x,int len){\n\tint node=split(x,len);\t\t\t//\u627e\u5230\u8be5\u533a\u95f4\n\tprint(node);printf(\"\\n\");\t\t//\u4e2d\u5e8f\u904d\u5386\u8f93\u51fa\n}\n```\n\n## 7.\u66f4\u65b0pushup\n\n\u66f4\u65b0size\u5c31\u597d\u4e86\uff0c\u8fd9\u91cc\u5927\u5bb6\u603b\u77e5\u9053\u600e\u4e48\u66f4\u65b0\u5427\n\n# \u603b\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n#define maxn 700001\n#define inf 0\n#define L(node) (tree[node].ch[0])\n#define R(node) (tree[node].ch[1])\n#define F(node) (tree[node].fa)\n#define S(node) (tree[node].size)\n#define V(node) (tree[node].val)\nusing namespace std;\nstruct kkk{\n\tint ch[2],size,fa;\n\tchar val;\n\tvoid clear(){ch[0]=ch[1]=fa=0;}\n}tree[maxn];\nint id[maxn],rub[maxn],n,m,x,len,y,top,cnt,root,GB;\nchar mode[21],a[maxn];\nint rublish(){\n\tif(top)return rub[top--];\n\treturn ++cnt;\n}\nvoid pushup(int node){tree[node].size=tree[L(node)].size+tree[R(node)].size+1;}\nvoid rotate(int node){\n\tint fa=F(node);\n\tint gfa=F(fa);\n\tint z=tree[fa].ch[1]==node;\n\ttree[gfa].ch[tree[gfa].ch[1]==fa]=node; tree[node].fa=gfa;\n\ttree[fa].ch[z]=tree[node].ch[z^1]; tree[tree[node].ch[z^1]].fa=fa;\n\ttree[node].ch[z^1]=fa; tree[fa].fa=node;\n\tpushup(fa); pushup(node);\n}\nvoid Splay(int node,int goal){\n\twhile(tree[node].fa!=goal){\n\t\tint fa=F(node);\n\t\tint gfa=F(fa);\n\t\tif(gfa!=goal)\n\t\t((tree[gfa].ch[1]==fa)==(tree[fa].ch[1]==node))?rotate(fa):rotate(node);\n\t \trotate(node);\n\t}\n\tif(!goal)root=node;\n}\nint kth(int x){\n\tint node=root;\n\twhile(1){\n\t\tif(tree[L(node)].size>=x)node=L(node);\n\t\telse{x-=tree[L(node)].size;\n\t\t\tif(x==1) return node;\n\t\t\tx--;node=R(node); \n\t\t}\n\t}\n}\nvoid build(int begin,int end,int pre){\n\tint mid=(begin+end)>>1;int node=id[mid],fa=id[pre];\n\tif(begin==end){tree[node].size=1;tree[node].val=a[begin];}\n\tif(begin<mid)build(begin,mid-1,mid);\n\tif(end>mid)build(mid+1,end,mid);\n\ttree[node].val=a[mid];tree[node].fa=fa;\n\tpushup(node);\n\ttree[fa].ch[mid>=pre]=node;\n}\nint split(int k,int len){\n\tint x=kth(k),y=kth(k+len+1);\n\tSplay(x,0);Splay(y,x);\n\treturn L(y);\n}\nvoid insert(int k,int len){\n\tfor(int i=1;i<=len;i++){\n\t\ta[i]=getchar();\n\t\tif(a[i]=='\\n'||a[i]=='\\r')--i;\n\t}\n\tfor(int i=1;i<=len;i++)id[i]=rublish();\n\tbuild(1,len,0);\n\tint z=id[(len+1)>>1];\n\tint x=kth(k+1),y=kth(k+2);\n\tSplay(x,0);Splay(y,x);\n\ttree[z].fa=y; tree[y].ch[0]=z;\n\tpushup(y); pushup(x);\n}\nvoid remove(int node){\n    if(L(node))remove(L(node));\n    if(R(node))remove(R(node));\n    rub[++top]=node; tree[node].clear();\n}\nvoid eraser(int x,int len){\n\tint node=split(x,len),fa=F(node);\n\ttree[fa].ch[0]=0;remove(node);\n\tpushup(fa); pushup(F(fa));\n}\nvoid print(int node){\n\tif(L(node))print(L(node));\n\tprintf(\"%c\",tree[node].val);\n\tif(R(node))print(R(node));\n}\nvoid query(int x,int len){\n\tint node=split(x,len);\n\tprint(node);printf(\"\\n\");\n}\nint main(){\n\tscanf(\"%d\",&m);\n\ta[1]=a[n+2]=-inf;\n\tfor(int i=1;i<=n+2;i++)id[i]=i;\n\tbuild(1,n+2,0);\n\tcnt=n+2;root=(n+3)>>1;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%s\",mode);\n\t\tif(mode[0]=='P'){GB--;continue;}\n\t\tif(mode[0]=='N'){GB++;continue;}\n\t\tscanf(\"%d\",&len);\n\t\tif(mode[0]=='M')GB=len;\n\t\tif(mode[0]=='I')insert(GB,len);\n\t\tif(mode[0]=='D')eraser(GB+1,len);\n\t\tif(mode[0]=='G')query(GB+1,len);\n\t\t//printf(\"PRINT:\"); print(root);printf(\"\\n\");\n\t}\n\treturn 0;\n}\n```\n\n# \u540e\u8bb0\n\n\u8fd8\u662f\u63a8\u8350\u5927\u5bb6\u53bb\u505a\u4e00\u4e0b\u201c\u7ef4\u62a4\u6570\u5217\u201d\u90a3\u9053\u9898\uff0c\u6bd4\u8fd9\u9053\u9898\u4e0d\u77e5\u9053\u9ad8\u660e\u5230\u54ea\u91cc\u53bb\u4e86\u3002\n\n~~\u6211\u548c\u5b83\u8c08\u7b11\u98ce\u751f~~",
        "postTime": 1556024525,
        "uid": 58711,
        "name": "hyfhaha",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "\u4e24\u79cd\u505a\u6cd5\u90fd\u4ecb\u7ecd\u4e00\u4e0b\u3002\n\n# \u5757\u72b6\u94fe\u8868\n\n\u4f18\u70b9\u662f\u4ee3\u7801\u5199\u8d77\u6765\u6bd4\u5199splay\u723d\u4e00\u4e9b\uff0c\u800c\u4e14\u66f4\u4e3a\u76f4\u89c2\uff08\u672c\u849f\u84bb\u7684\u4ee3\u7801\u53ea\u670990\u5206\uff09\n\n\u5757\u72b6\u94fe\u8868\u662f\u4e00\u4e2a\u4e2a\u6570\u7ec4\u5757\uff0c\u7528\u94fe\u8868\u7a7f\u8d77\u6765\u5f97\u5230\u7684\u7ed3\u679c\uff0c\u89e3\u51b3\u4e86\u666e\u901a\u6570\u7ec4\u63d2\u5165\u7684\u56f0\u96be\u548c\u666e\u901a\u94fe\u8868\u67e5\u8be2\u7684\u56f0\u96be\uff0c\u4e00\u79cd\u6839\u53f7\u590d\u6742\u5ea6\u7684\u6570\u636e\u7ed3\u6784\u3002\n\n\u63d2\u5165\u7684\u65f6\u5019\u8981\u8bb0\u5f97\u5f53\u5bfc\u81f4\u5757\u8fc7\u5927\u7684\u65f6\u5019\u5c31\u8981\u5206\u88c2\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u8981\u8bb0\u5f97\u53bb\u9664\u5927\u5c0f\u4e3a0\u7684\u5757\uff0c\u4ee5\u53ca\u6bcf\u6b21\u79fb\u52a8\u5149\u6807\u7684\u65f6\u5019\u53bb\u79fb\u52a8\u8bb0\u5f55\u5149\u6807\u5728\u5757\u72b6\u94fe\u8868\u4f4d\u7f6e\u7684\u4e24\u4e2a\u6307\u9488\u4f1a\u66f4\u5feb\u4e00\u4e9b\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define ksz 2000\nint T,b1=1,b2,cn=1,gb,len;\nstruct node{char a[2300];int sz,pre,nxt;} p[7005];\nvoid move() {//\u79fb\u52a8\u5149\u6807\uff0c\u5373\u67e5\u8be2\u64cd\u4f5c\uff0c\u66b4\u529b\u627e\u5757\u5927\u5c0f\u5373\u53ef\n    int pos;scanf(\"%d\",&pos);\n    b1=p[0].nxt;int tot=0;\n    while(tot+p[b1].sz<pos) tot+=p[b1].sz,b1=p[b1].nxt;\n    b2=pos-tot;\n}\nvoid ins() {//\u63d2\u5165\u64cd\u4f5c\n    char ch;int d1=b1,d2=b2;\n    while(len--) {\n        ch=getchar();while(ch<32||ch>126) ch=getchar();\n        if(p[d1].sz==ksz) {//\u6ce8\u610f\u4e0d\u8981\u8ba9\u5757\u53d8\u5f97\u592a\u5927\u4e86\n            ++cn,p[cn].pre=d1,p[cn].nxt=p[d1].nxt;\n            p[p[d1].nxt].pre=cn,p[d1].nxt=cn;\n            for(int i=d2+1;i<=p[d1].sz;++i) p[cn].a[++p[cn].sz]=p[d1].a[i];\n            p[d1].sz=d2,d1=cn,d2=0;\n        }\n        for(int i=p[d1].sz;i>d2;--i) p[d1].a[i+1]=p[d1].a[i];\n        ++p[d1].sz,p[d1].a[++d2]=ch;\n    }\n}\nvoid del() {//\u5220\u9664\u64cd\u4f5c\n    int d1=b1,d2=b2;\n    while(len) {//\u5207\u8bb0\u4e0d\u8981\u4e00\u4e2a\u4e00\u4e2a\u7684\u5220\uff0c\u592a\u6162\u4e86\uff01\n        int kl=p[d1].sz-d2;\n        if(len>kl) len-=kl,p[d1].sz=d2,d1=p[d1].nxt,d2=0;\n        else {\n            for(int i=d2+len+1;i<=p[d1].sz;++i) p[d1].a[i-len]=p[d1].a[i];\n            p[d1].sz-=len,len=0;\n        }\n    }\n}\n//\u53bb\u9664\u4e3a0\u7684\u5757\u662f\u975e\u5e38\u975e\u5e38\u91cd\u8981\u7684\nvoid query() {//\u67e5\u8be2\u64cd\u4f5c\n    int d1=b1,d2=b2;\n    while(len) {//\u4e5f\u4e0d\u8981\u4e00\u4e2a\u4e00\u4e2a\u5730\u8f93\u51fa\n        while(!p[d1].sz)\n        p[p[d1].pre].nxt=p[d1].nxt,p[p[d1].nxt].pre=p[d1].pre,d1=p[d1].nxt;\n        int kl=p[d1].sz-d2;\n        if(len>kl) {\n            for(int i=d2+1;i<=p[d1].sz;++i) putchar(p[d1].a[i]);\n            len-=kl,d1=p[d1].nxt,d2=0;\n        }\n        else {\n            for(int i=1;i<=len;++i) putchar(p[d1].a[i+d2]);\n            len=0;\n        }\n    }\n    puts(\"\");\n}\nvoid move_front() {\n    if(b2) --b2;\n    else {\n        b1=p[b1].pre;\n        while(!p[b1].sz)\n        p[p[b1].pre].nxt=p[b1].nxt,p[p[b1].nxt].pre=p[b1].pre,b1=p[b1].nxt;\n        b2=p[b1].sz-1;//!!!\n    }\n}\nvoid move_next() {\n    if(b2<p[b1].sz) ++b2;\n    else {\n        b1=p[b1].nxt,b2=1;\n        while(!p[b1].sz)\n        p[p[b1].pre].nxt=p[b1].nxt,p[p[b1].nxt].pre=p[b1].pre,b1=p[b1].nxt;\n    }\n}\nint main()\n{\n    char ch[10];\n    scanf(\"%d\",&T),p[0].nxt=1;\n    while(T--) {\n        scanf(\"%s\",ch);\n        if(ch[0]=='M') move();\n        else if(ch[0]=='I') scanf(\"%d\",&len),ins();\n        else if(ch[0]=='D') scanf(\"%d\",&len),del();\n        else if(ch[0]=='G') scanf(\"%d\",&len),query();\n        else if(ch[0]=='P') move_front();\n        else move_next();\n    }\n    return 0;\n}\n```\n# splay\n\n\u4f18\u70b9\u662f\u5feb\uff0c\u4e07\u80fd\u3002\u7f3a\u70b9\u5c31\u662f\u4ee3\u7801\u6253\u5f97\u6d51\u8eab\u96be\u53d7\u3002\n\n\u8eab\u4e3a\u5e8f\u5217\u4e4b\u738b\u7684splay\uff0c\u4e0d\u4f1a\u88ab\u8fd9\u79cd\u9898\u76ee\u96be\u5012\u3002\u5982\u679c\u4f60\u662f\u9996\u6b21\u63a5\u89e6splay\uff0c[\u5356\u4e2a\u5b89\u5229](http://blog.csdn.net/litble/article/details/74612868 )\n\n\u90a3\u4e48\u6b64\u9898\u6d89\u53ca\u7684splay\u64cd\u4f5c\u5c31\u662f\u67e5\u8be2\u7b2ck\u4e2a\u6570\uff0c\u63d2\u5165\uff0c\u5220\u9664\uff0c\u548c\u8f93\u51fa\u3002\u5bf9\u4e8e\u719f\u7ec3splay\u7684\u4eba\u5e94\u8be5\u4e0d\u96be\uff0c\u53ef\u4ee5\u770b\u4ee3\u7801\u7684\u6ce8\u91ca\u3002\n\n\u603b\u4e4b\uff0c\u5982\u679c\u8981\u5bf9\u4e00\u4e2a\u533a\u95f4\u8fdb\u884c\u64cd\u4f5c\uff0c\u5c31\u628a\u533a\u95f4\u5de6\u7aef\u70b9\u7684\u5de6\u8fb9\u90a3\u4e2a\u70b9splay\u5230\u6839\uff0c\u53f3\u7aef\u70b9\u53f3\u8fb9\u90a3\u4e2a\u70b9splay\u5230\u6839\u7684\u53f3\u513f\u5b50\uff0c\u7136\u540e\u5bf9\u6839\u7684\u53f3\u513f\u5b50\u7684\u5de6\u5b50\u6811\u8fdb\u884c\u64cd\u4f5c\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2100000;\nint T,GB,len,rot,trs,sss;\nint son[N][2],f[N],siz[N];char c[N],s[N];\nvoid up(int x) {siz[x]=siz[son[x][0]]+siz[son[x][1]]+1;}\nint is(int x) {return son[f[x]][1]==x;}\nvoid spin(int x,int &mb) {//\u65cb\u8f6c\u64cd\u4f5c\n    int fa=f[x],g=f[fa],t=is(x);\n    if(fa==mb) mb=x;\n    else son[g][is(fa)]=x;\n    f[fa]=x,f[x]=g,f[son[x][t^1]]=fa;\n    son[fa][t]=son[x][t^1],son[x][t^1]=fa;\n    up(fa),up(x);\n}\nvoid splay(int x,int &mb) {//splay\u64cd\u4f5c\n    while(x!=mb) {\n        if(f[x]!=mb) {\n            if(is(x)^is(f[x])) spin(x,mb);\n            else spin(f[x],mb);\n        }\n        spin(x,mb);\n    }\n}\nint find(int x,int kth) {//\u67e5\u627e\u7b2ck\u4e2a\u6570\n    if(siz[son[x][0]]+1==kth) return x;\n    if(siz[son[x][0]]>=kth) return find(son[x][0],kth);\n    return find(son[x][1],kth-siz[son[x][0]]-1);\n}\nvoid build(int l,int r,int fa,int fnum,char *s) {//\u5efa\u6811\n    if(l>r) return;\n    int mid=(l+r)>>1,t;\n    ++sss,t=sss;\n    if(l!=r) build(l,mid-1,t,0,s),build(mid+1,r,t,1,s);\n    c[t]=s[mid],f[t]=fa,son[fa][fnum]=t,up(t);\n}\nvoid print(int x) {//\u6309\u7167\u5de6\u6839\u53f3\u7684\u987a\u5e8f\u8fdb\u884c\u8f93\u51fa\n    if(son[x][0]) print(son[x][0]);\n    putchar(c[x]);\n    if(son[x][1]) print(son[x][1]);\n}\nint main()\n{\n    char ch[20];int x,y,l,r;\n    scanf(\"%d\",&T);\n    ch[0]=ch[1]=ch[2]=c[0]=' ',rot=1,build(1,2,0,0,ch);\n    while(T--) {\n        scanf(\"%s\",ch);\n        if(ch[0]=='M') scanf(\"%d\",&GB);//GB:\u5149\u6807\u4f4d\u7f6e\n        else if(ch[0]=='I') {\n            scanf(\"%d\",&len),trs+=len,s[0]=' ';\n            for(int i=1;i<=len;++i) {\n                s[i]=getchar();\n                if(s[i]=='\\n'||s[i]=='\\r') --i;\n            }\n            x=find(rot,GB+1),y=find(rot,GB+2);\n            splay(x,rot),splay(y,son[x][1]),build(1,len,y,0,s);//\u5148\u5efa\u7acb\u4e00\u68f5\u5b50\u6811\u540e\u518d\u63d2\u5165\uff0c\u4fdd\u8bc1\u5e73\u8861\n        }\n        else if(ch[0]=='D') {\n            scanf(\"%d\",&len),len=min(len,trs-GB),trs-=len;\n            x=find(rot,GB+1),y=find(rot,GB+len+2);\n            splay(x,rot),splay(y,son[x][1]),son[y][0]=0;//\u5220\u9664\u533a\u95f4\uff0c\u4e0d\u7528\u5783\u573e\u56de\u6536\n        }\n        else if(ch[0]=='G') {\n            scanf(\"%d\",&len),len=min(len,trs-GB);\n            x=find(rot,GB+1),y=find(rot,GB+len+2);\n            splay(x,rot),splay(y,son[x][1]),print(son[y][0]),puts(\"\");//\u8f93\u51fa\n        }\n        else if(ch[0]=='P') --GB;\n        else if(ch[0]=='N') ++GB;\n    }\n    return 0;\n}\n```",
        "postTime": 1514207964,
        "uid": 20604,
        "name": "litble",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]editor\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "# \u975e\u65cbTreap\u505a\u6cd5\n\u9a5a\u4e86\uff0c\u5c45\u7136\u6c92\u4eba\u7528Treap\u505a  \n\u6211\u8d95\u7dca\u6c34\u4e0a\u4e00\u7bc7\u975e\u65cbTreap\u505a\u6cd5  i\n\u672c\u4eba\u624b\u8ce4\uff0c\u7528\u4e0b\u9762\u7684Splay\u7684\u984c\u89e3\u6bd4\u4e86\u4e00\u4e0b\u901f\u5ea6\uff0cSplay780ms,Treap1680ms  \n\u4f46\u662f\u7531\u65bcTreap\u4e0d\u6d88\u8017\u8166\u7d30\u80de\u800c\u4e14\u597d\u5beb\u5f88\u591a\uff0c\u4e26\u4e14\u4e26\u4e0d\u803d\u8aa4AC  \n\u6240\u4ee5\u9084\u662f\u5b78\u4e00\u5b78\u6bd4\u8f03\u597d  \n\u975e\u65cbTreap\u57fa\u672c\u64cd\u4f5c\u53ca\u6982\u5ff5\u8a73\u898b\u6211\u7684\u535a\u5ba2  \n\u7dad\u8b77\u524d\u9a45\u5f8c\u7e7c\u7b49\u7684\u505a\u6cd5\uff1a[\u975e\u65cbTreap\u7dad\u8b77\u666e\u901a\u5e73\u8861\u6a39\u7684\u57fa\u672c\u64cd\u4f5c](http://blog.csdn.net/assass_cannotin/article/details/79309828)\n\u5340\u9593\u7ffb\u8f49\uff1a[ \u975e\u65cbTreap\u7684\u5340\u9593\u7ffb\u8f49\uff08\u6587\u85dd\u5e73\u8861\u6a39\uff09](http://blog.csdn.net/assass_cannotin/article/details/79311113)  \n\u7dad\u4fee\u6578\u5217\uff1a[Treap\u6c38\u4e0d\u65cb\u8f49\uff01\uff01\uff01[\u7dad\u4fee\u6578\u5217]](http://blog.csdn.net/assass_cannotin/article/details/79313901)  \n\u9019\u9053\u984c\u5f88\u7c21\u55ae\uff0c\u53ea\u8981\u638c\u63e1\u5230\u5340\u9593\u5efa\u6a39\u7684$O(n)$\u505a\u6cd5\u5c31\u53ef\u4ee5\u89e3\u6c7a\u4e86 \n\u5efa\u6a39\u65b9\u6cd5\u5728\u7b2c\u4e09\u7bc7\u6587\u7ae0  \nAC\u4ee3\u78bc  \n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntemplate<class a,class b>class Pair\n{\npublic:\n  a first;\n  b second;\n  Pair(){}\n  Pair(a x,b y){first=x,second=y;}\n};\ninline void read(int &x)\n{\n  int s=0,w=1;\n  char c=getchar();\n  while(c<'0'||c>'9')c=getchar();\n  while(c>='0'&&c<='9')\n  {\n    s=(s<<3)+(s<<1)+c-'0';\n    c=getchar();\n  }\n  x=s*w;\n}\nint seed=2333;\ninline int Random(){return seed=seed*seed+seed+1;}\nstruct node\n{\n  int val,size,key;\n  node *son[2];\n  node(int k);\n  ~node();\n  inline void push_up()\n  {\n    size=son[0]->size+son[1]->size+1;\n  }\n}*nil=new node(0),*Root,*stack[1024*1024+5];\nnode::node(int k)\n{\n  val=k,key=Random(),size=1,son[0]=son[1]=nil;\n}\nnode::~node()\n{\n  if(son[0]!=nil)delete son[0];\n  if(son[1]!=nil)delete son[1];\n}\nnode *merge(node *a,node *b)\n{\n  if(a==nil)return b;\n  if(b==nil)return a;\n  if(a->key<b->key)\n  {\n    a->son[1]=merge(a->son[1],b);\n    a->push_up();\n    return a;\n  }\n  else\n  {\n    b->son[0]=merge(a,b->son[0]);\n    b->push_up();\n    return b;\n  }\n}\nPair<node*,node*>split(node *root,int k)\n{\n  if(root==nil)return Pair<node*,node*>(nil,nil);\n  Pair<node*,node*>p;\n  if(root->son[0]->size>=k)\n  {\n    p=split(root->son[0],k);\n    root->son[0]=p.second;\n    root->push_up();\n    p.second=root;\n    return p;\n  }\n  else\n  {\n    p=split(root->son[1],k-root->son[0]->size-1);\n    root->son[1]=p.first;\n    root->push_up();\n    p.first=root;\n    return p;\n  }\n}\nnode *build(int n)\n{\n  int top=0;\n  for(int i=1;i<=n;i++)\n  {\n    char c=getchar();\n    while(c<32||c>126||c=='\\r'||c=='\\n')c=getchar();\n    node *temp=new node(int(c)),*last=nil;\n    while(top&&temp->key<stack[top]->key)\n    stack[top]->push_up(),last=stack[top],stack[top--]=nil;\n    if(top)stack[top]->son[1]=temp;\n    temp->son[0]=last,stack[++top]=temp;\n  }\n  while(top)stack[top--]->push_up();\n  return stack[1];\n}\nvoid print(node *root)\n{\n  if(root==nil)return ;\n  print(root->son[0]),putchar(char(root->val)),print(root->son[1]);\n}\nint pos,t,sum;\nchar opt[10];\nint main()\n{\n  nil->size=0,Root=nil;\n  read(t);\n  while(t--)\n  {\n    scanf(\"%s\",opt);\n    if(opt[0]=='M')read(sum),pos=sum;\n    else if(opt[0]=='I')\n    {\n      read(sum);\n      Pair<node*,node*>a=split(Root,pos);\n      Root=merge(merge(a.first,build(sum)),a.second);\n    }\n    else if(opt[0]=='D')\n    {\n      read(sum);\n      Pair<node*,node*>a=split(Root,pos),b=split(a.second,sum);\n      Root=merge(a.first,b.second);\n      delete b.first;\n    }\n    else if(opt[0]=='G')\n    {\n      read(sum);\n      Pair<node*,node*>a=split(Root,pos),b=split(a.second,sum);\n      print(b.first),putchar(10);\n      Root=merge(a.first,merge(b.first,b.second));\n    }\n    else if(opt[0]=='P')pos--;\n    else pos++;\n  }\n}\n\n```\n\u53ef\u80fd\u662f\u6211\u5beb\u919c\u4e86  \n\u5b8c\u7d50  \n\u6ce8\uff1a\u672c\u6587\u7ae0\u4f5c\u8005\u662f\u500b\u5730\u5730\u9053\u9053\u7684\u5927\u9678\u4eba\uff0c\u6f22\u5b57\u4f7f\u7528\u59ff\u52e2\u4e0d\u5c0d\u8acb\u5c0d\u6b64\u6709\u7814\u7a76\u7684\u540c\u80de\u6307\u6b63",
        "postTime": 1518445500,
        "uid": 60462,
        "name": "sherlock55341",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]editor\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "[\u65e5\u5e38\u63a8\u5e7f\u535a\u5ba2](https://endsah.cf)\n\n# \u524d\u8a00\n\n\u672c\u7bc7\u9898\u89e3\u63d0\u4f9b\u4e24\u79cd\u89e3\u6cd5\uff1a**\u66b4\u529b**\u548c**\u5757\u72b6\u94fe\u8868**\u3002\n\n\u91cd\u70b9\u4e0d\u5728\u8fd9\u91cc\uff0c\u800c\u5728\u4e8e\uff1a\n\n**\u5168\u90e8\u7528 $\\text{STL}$ \u5b9e\u73b0**\u3002\n\n\u53e6\u9644\u4e0a\u4e00\u4e2a\u7f51\u7ad9\uff1a[cppreference.com](https://zh.cppreference.com)\uff0c\u5728\u5bf9\u4e8e\u8bed\u8a00\u548c $\\text{STL}$ \u7684\u64cd\u4f5c\u6709\u7591\u95ee\u6216\u8005\u5fd8\u8bb0\u4e86\uff0c\u53ef\u4ee5\u53bb\u8fd9\u91cc\u67e5\u3002\n\n\u4f17\u6240\u5468\u77e5\uff0c\u867d\u7136 $\\text{STL}$ \u5728\u4e0d\u5f00 $O_2$ \u7684\u60c5\u51b5\u4e0b\u6548\u7387\u6b20\u4f73\uff0c\u4f46\u662f\u5c01\u88c5\u597d\u7684\u5404\u7c7b\u64cd\u4f5c\u4f7f\u5f97\u5176**\u4ee3\u7801\u590d\u6742\u5ea6\u6781\u4f4e\uff0c\u6613\u4e8e\u8c03\u8bd5**\u3002\n\n# \u9898\u89e3\n\n## \u66b4\u529b\n\n\u9996\u5148\uff0c\u8981\u5bf9`std::vector`\u5404\u9879\u57fa\u672c\u64cd\u4f5c\u6709\u6240\u4e86\u89e3\u3002\n\n\u9898\u76ee\u4e2d\u6240\u7ed9\u7684 6 \u4e2a\u64cd\u4f5c\uff0c\u90fd\u53ef\u4ee5\u76f4\u89c2\u7684\u7528`std::vector`\u5b9e\u73b0\u3002\n\n`std::vector`\u6709\u4e24\u4e2a\u6210\u5458\u51fd\u6570\uff1a`erase`\u548c`insert`\u3002\n\n[std::vector.insert()](https://zh.cppreference.com/w/cpp/container/vector/insert)\n\n[std::vector.erase()](https://zh.cppreference.com/w/cpp/container/vector/erase)\n\n\u770b\u5230\u91cc\u9762\u7684\u63d2\u5165\u533a\u95f4\u548c\u533a\u95f4\u5220\u9664\u6ca1\uff1f\n\n\u5b9e\u9645\u4e0a\uff0c\u63d2\u5165\u548c\u5220\u9664\u7684\u6700\u574f\u590d\u6742\u5ea6\u662f $O(n)$ \u7684\uff08\u4e00\u76f4\u5728\u5934\u90e8\u63d2\u5220\uff09\uff0c\u8fd9\u4e5f\u5c31\u662f\u8bf4\u5b83\u66b4\u529b\u7684\u539f\u56e0\u3002\n\n\u5177\u4f53\u7ec6\u8282\uff08\u8fb9\u754c\u95ee\u9898\u7b49\uff09\uff0c\u8be6\u89c1[\u66b4\u529b\u4ee3\u7801](https://www.luogu.org/paste/liu5d12e)\u3002\n\n## \u5757\u72b6\u94fe\u8868\n\n\u5c31\u662f\u5757\u5185\u662f\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5757\u4e4b\u95f4\u7528\u94fe\u8868\u8fde\u63a5\u7684\u6570\u636e\u7ed3\u6784\u3002\n\n\u94fe\u8868\u63d2\u5165 $O(1)$\uff0c\u8bbf\u95ee $O(n)$\uff1b\u6570\u7ec4\u63d2\u5165 $O(n)$\uff0c\u8bbf\u95ee $O(1)$\u3002\n\n\u5757\u72b6\u94fe\u8868\uff0c\u6b63\u662f\u4e00\u4e2a\u4e2d\u95f4\u4ea7\u7269\uff0c\u90fd\u662f $O(\\sqrt n)$\u3002\n\n\u8fd9\u91cc\u53ea\u662f\u5c0f\u5c0f\u7684\u4ecb\u7ecd\u4e00\u4e0b\u6982\u5ff5\uff0c\u5177\u4f53\u7684\u5e94\u8be5\u6709 $\\text{dalao}$ \u7684\u9898\u89e3\u5199\u5f97\u6bd4\u6211\u66f4\u597d\uff0c\u4e0d\u518d\u732e\u4e11\u3002\n\n\u94fe\u8868\u5957\u6570\u7ec4\uff1f\u8fd8\u8981\u52a8\u6001\uff1f\n\n`std::list`\u5957`std::vector`\u554a\uff01\n\n\u4ec0\u4e48\u9ebb\u70e6\u7684\u56de\u6536\u5185\u5b58\uff0c\u6574\u6bb5\u540e\u79fb\u6570\u7ec4\u64cd\u4f5c\uff0c\u6709\u4e86\u5c01\u88c5\u597d\u7684\u51fd\u6570\uff0c\u8fd8\u6015\u4ec0\u4e48\uff1f\n\n\u5728\u8fd9\u91cc\uff0c~~\u9b3c\u8ff7\u5fc3\u7a8d\u7684~~\u6211~~\u83ab\u540d\u5947\u5999\u5730~~\u9009\u62e9\u4e86`std::forward_list`\u4f5c\u4e3a`std::list`\u7684\u66ff\u4ee3\u54c1\uff0c\u56e0\u4e3a`std::forward_list`\u662f\u5355\u5411\u94fe\u8868\u800c`std::list`\u662f\u53cc\u5411\uff0c\u4e5f\u8bb8\u4f1a\u5feb\u4e00\u4e9bemmm\uff08\u4e5f\u8bb8....\n\n\uff08\u987a\u5e26\u8b66\u544a\uff1a\u4e0d\u662f $\\text{C++11}$ \u4f1a $\\text{CE}$\uff09\n\n\u653e\u4e0a\u51e0\u4e2a\u8981\u7528\u7684`std::forward_list`\u7684\u6210\u5458\u51fd\u6570\uff0c\u81ea\u5df1\u53bb cppreference \u770b\u53bb\uff1a\n\n`insert_after(), erase_after(), before_begin()`\n\n\u5176\u4ed6\u7ec6\u8282\u548c\u8fb9\u754c\u5904\u7406\u5176\u5b9e\u4e5f\u633a\u591a\u7684\uff0c\u5177\u4f53\u770b[\u5757\u72b6\u94fe\u8868\u4ee3\u7801](https://www.luogu.org/paste/ivmvw8f1)\u3002\n\n\u5982\u679c\u4f60\u4e0d\u60f3\u7528`std::forward_list`\u800c\u60f3\u7528`std::list`\uff0c\u8fd9\u91cc\u6709[\u53e6\u4e00\u4efd\u4ee3\u7801](https://www.luogu.org/paste/qfzhwyip)\u3002\n\n# \u603b\u7ed3\n\n\u5173\u4e8e $\\text{STL}$\uff0c\u4e00\u5b9a\u8981\u8bb0\u4f4f\uff1a\n\n**\u5de6\u95ed\u53f3\u5f00**\uff01\uff01\uff01**\u5de6\u95ed\u53f3\u5f00**\uff01\uff01\uff01**\u5de6\u95ed\u53f3\u5f00**\uff01\uff01\uff01\n\n\u5176\u5b9e\u4f60\u8981\u662f\u8ba4\u771f\u7684\u5199\u4e86\u4ee3\u7801\u5e76\u63a8\u4e86\u8fb9\u754c\u6761\u4ef6\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0**\u5de6\u95ed\u53f3\u5f00\uff0c\u4e0b\u6807\u4ece $0$ \u5f00\u59cb**\u662f\u4e00\u4e2a\u591a\u4e48\u53cb\u597d\u7684\u4e1c\u897f\u3002\n\n\u6211\u7684\u4ee3\u7801\u91cc**\u6839\u672c\u5c31\u6ca1\u6709**\u4ec0\u4e48`+1-1`\uff0c\u8fb9\u754c\u6761\u4ef6\u9700\u8981\u60f3\u60f3\uff0c\u4f46\u662f\u5b9e\u9645\u4e0a\u4f60\u53ef\u4ee5\u6309\u76f4\u89c9\u4e00\u904d\u6253\u8fc7\u53bb\uff0c\u57fa\u672c\u4e0d\u4f1a\u9519\u3002\u8fd9\u4e5f\u662f $\\text{STL}$ \u7684\u4f18\u8d8a\u4e4b\u5904\u3002\n\n\u987a\u4fbf\u8bf4\u4e00\u53e5\uff0c\u9694\u58c1\u52a0\u5f3a\u7248\uff08\u5e26\u7ffb\u8f6c\u64cd\u4f5c\uff09[[AHOI2006]\u6587\u672c\u7f16\u8f91\u5668](https://www.luogu.org/problemnew/show/P4567)\u7528`std::vector`\u5b9e\u73b0\u7684\u66b4\u529b\u662f\u6700\u4f18\u89e32333333\uff08\u7ffb\u8f6c\u76f4\u63a5`std::reverse`\uff09\n\n\u5927\u6982\u5c31\u8bb2\u5230\u8fd9\u91cc\u5427- -\n\n$\\huge\\text{Thanks for your consideration!}$",
        "postTime": 1550154410,
        "uid": 91252,
        "name": "EndSaH",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "## splay\u88f8\u9898\u3002\n\u770b\u5230\u533a\u95f4\u63d2\u5165\u5220\u9664\uff0c\u60f3\u5230splay\u3002\n\n\u4f46\u662f\u5728\u8bf4splay\u4e4b\u524d\u5148\u8bf4\u51e0\u4e2a\u522b\u7684\u5751\u70b9\u3002\n\n\uff08\u53e6\u5916\u6211\u7684splay\u662f\u8ddf[rtldalao](https://www.luogu.org/blog/user19027/solution-p3369)\u5b66\u7684\uff0c\u4ee3\u7801\u53ef\u80fd\u6709\u70b9\u5f02\u6837\u4f46\u5927\u5bb6\u5e94\u8be5\u770b\u5f97\u61c2\u7684\uff09\n\n---\n### 1.insert\u7684\u8f93\u5165\n\u6211\u7684\u8f93\u5165\u65b9\u6cd5\u662f\u8fd9\u6837\u7684\uff1a\u4e00\u5f00\u59cb\u8f93\u5165\u4e86\u4e00\u4e2a\u957f\u5ea6\uff0c\u63a5\u4e0b\u6765\u4e00\u76f4\u8bfb\u5165\u5b57\u7b26\uff0c\u5982\u679c\u662f\u5408\u6cd5\u5b57\u7b26\u5c31\u63a5\u5230\u4e34\u65f6\u5b57\u7b26\u4e32\u672b\u5c3e\uff0c\u5982\u679c\u8f93\u5165\u7684\u5408\u6cd5\u5b57\u7b26\u5df2\u7ecf\u591f\u4e86\uff0c\u90a3\u4e48\u76f4\u63a5\u9000\u51fa\u3002\n\n\u81f3\u4e8e\u6bd2\u7624\u7684\u7a7a\u683c\u548c\u6362\u884c\u7b26\u7684\u95ee\u9898\uff0c\u4e0d\u7528\u7ba1\uff0c\u9898\u9762\u91cc\u8bf4\u4e86\uff0c\u5408\u6cd5 $\\text{ASCII}$ \u503c\u5728 $[32,126]$\u3002\u53ea\u8981\u5224\u65ad $\\text{ASCII}$ \u5373\u53ef\u3002\n```cpp\nstrcpy(ins,\"\");\nflag=false;\t//\u521d\u59cb\u5316\nscanf(\"%d\",&x);\t//\u957f\u5ea6\nfor(int i=0;i<x;i++){\n\tchar ch=getchar();\t//\u4e00\u76f4\u8bfb\u5165\n\tif(ch>=32 && ch<=126) flag=true;\t//\u5982\u679c\u8bfb\u5230\u5408\u6cd5\u5b57\u7b26\uff0c\u90a3\u540e\u9762\u7684\u7a7a\u683c\u90fd\u662f\u5408\u6cd5\u7684\uff0c\u5426\u5219\u53ef\u80fd\u662f\u975e\u6cd5\u7684\uff08flag\uff09\n\tif(!flag || ch<32 || ch>126){\t//\u5982\u679c\u4e0d\u5408\u6cd5\n\t\ti--;continue;\t//\u8bfb\u5230\u7684\u5b57\u7b26\u6570--\n\t}\n    ins[i]=ch;\t//\u653e\u5230\u672b\u5c3e\n}\n```\n### 2.\u5149\u6807\u7684\u8bbe\u7f6e\n\u5149\u6807\u53ef\u4ee5\u5f3a\u884c $O(1)$ \u6a21\u62df\uff0c\u4e5f\u4e0d\u4f1a\u5bf9splay\u7684\u540e\u7eed\u64cd\u4f5c\u53d1\u751f\u5f71\u54cd\u3002\u81f3\u4e8e\u4ece0\u8fd8\u662f\u4ece1\u5f00\u59cb\u6211\u4eec\u5f85\u4f1a\u4f1a\u8bb2\u3002\n### 3.\u5185\u5b58\u7684\u8bbe\u7f6e\n\u7531\u4e8e\u603b\u5171\u53ea\u4f1a\u63d2\u51652097152\u4e2a\u5b57\u7b26\uff0c\u6240\u4ee5splay\u7684\u8282\u70b9\u4e2a\u6570\u548c\u4e34\u65f6\u5b57\u7b26\u4e32\u5927\u5c0f\u53ea\u9700\u8981\u5f00\u8fd9\u4e48\u5927\u3002\uff08\u6216\u8bb8\u662f\u6570\u636e\u6c34\u5427\uff0c\u6211\u5f002000200\u5c31\u8fc7\u4e86\uff09\n\n\u63a5\u4e0b\u6765\u5f00\u59cb\u91cd\u5934\u620f\u3002\n\n---\n### 1.insert\u64cd\u4f5c\n\u5047\u8bbe\u5149\u6807\u5728 $x$ \u5904\uff0c\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a $len$\u3002\n\n\u90a3\u4e48\u4eff\u7167\u6a21\u677f\uff08\u5176\u5b9e\u5927\u591a\u6570\u9898\u76ee\u90fd\u662f\u8fd9\u6837\uff09\uff0c\u5c06\u6392\u540d\u4e3a $x-1$ \u7684\u70b9splay\u5230\u6839\uff0c$x$ \u7684\u70b9splay\u5230\u6839\u7684\u53f3\u513f\u5b50\uff0c\u7136\u540e\u5728\u6839\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50build\u4e00\u9897\u5b8c\u7f8e\u7684splay\u3002\u53ef\u4ee5\u518d\u628a\u8fd9\u4e2a\u5b50\u6811splay\u5230\u6839\u4e0a\u4ee5\u786e\u5b9a\u968f\u673a\u6027\uff0c\u4f46\u662f\u9876\u591a\u4e5f\u5c31\u591a2\u7684\u9ad8\u5ea6\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0dsplay\u3002\n\n\u597d\u7684\uff0c\u5047\u8bbe $x=0$ \u600e\u4e48\u529e\uff1f\n\n\u4e00\u822c\u6765\u8bf4\u89e3\u51b3\u65b9\u6cd5\u90fd\u662f\u5934\u5c3e\u52a0\u54e8\u5175\u5143\u7d20\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u907f\u514d\u67e5\u8be2\u6392\u540d\u4e3a\u975e\u6b63\u6570\u7684\u70b9\u4e86\u3002\u5728\u8fd9\u91cc\u6211\u4eec\u52a0\u5165\u54e8\u5175\u5143\u7d20\u540e\uff0csplay\u7684\u5e94\u8be5\u662f\u6392\u540d\u4e3a $x$ \u548c $x+1$ \u7684\u70b9\u3002\u5149\u6807\u4f4d\u7f6e\u4e00\u5f00\u59cb\u8bbe\u62101\u800c\u4e0d\u662f0\u3002\n\n\uff08\u4ece\u524d\u6211\u8bd5\u7740\u5077\u61d2\uff0c\u4e0dsplay\u4e0a\u53bb\u5c31\u5728\u4e0b\u9762\u64cd\u4f5c\uff0c\u7136\u540e\u53d1\u73b0\u7279\u522b\u96be\u5b9e\u73b0\uff0c\u597d\u4e0d\u5bb9\u6613\u5199\u51fa\u6765\u7684\u53c8wa\u4e86\u2026\u2026\u5927\u5bb6\u5343\u4e07\u4e0d\u8981\u8fd9\u6837\uff0c\u6709\u533a\u95f4\u64cd\u4f5c\u6700\u597d\u5c31splay\u4e0a\u53bb\u518d\u5f04\uff09\n```cpp\nSplay():cnt(0),pos(1){\t//\u521d\u59cb\u5316\u4ee5\u53ca\u4e24\u4e2a\u54e8\u5175\u5143\u7d20\uff08'\\n'\uff09\n    memset(e,0,sizeof(e));\n    root=addnode('\\n',0);\n    e[root].son[1]=addnode('\\n',root);\n}\nint build(char *str,int fa,int l,int r){\t//\u5b8c\u7f8esplay\n    int mid=l+r>>1;\n    char ch=str[mid-1];\n    int x=addnode(ch,fa);\t//\u81ea\u5df1\n    if(l<mid) e[x].son[0]=build(str,x,l,mid-1);\n    if(mid<r) e[x].son[1]=build(str,x,mid+1,r);\t//\u9012\u5f52\n    pushup(x);\n    return x;\n}\nvoid insert(int len,char *str){\n    int l=kth(pos),r=kth(pos+1);\n    splay(l,0);\n    splay(r,l);\t//\u5bfb\u627e\u8282\u70b9\u7136\u540esplay\n    e[e[root].son[1]].son[0]=build(str,e[root].son[1],1,len);\t//\u5efa\u9020\u5b8c\u7f8esplay\n    pushup(e[root].son[1]);pushup(root);\n}\n```\n### 2.move,prev,next\u64cd\u4f5c\n\u4e5f\u5c31move\u6ce8\u610f\u4e00\u4e0b\uff0c\u5149\u6807\u6539\u6210 $x+1$ \u800c\u4e0d\u662f $x$\u3002\u5176\u4ed6\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\u3002\n```cpp\ninline void move(int x){pos=x+1;}\ninline void prv(){pos--;}\ninline void nxt(){pos++;}\n```\n### 3.delete\u64cd\u4f5c\n\u540c\u6837\u7684\u9053\u7406\uff0c\u628a $x$ splay\u5230\u6839\uff0c $(x+len-1)+2=x+len+1$ splay\u5230\u6839\u7684\u53f3\u513f\u5b50\uff0c\u628a\u6839\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u76f4\u63a5\u65ad\u6389\u5173\u7cfb\u3002\n```cpp\nvoid remove(int len){\n    int l=kth(pos),r=kth(pos+len+1);\n    splay(l,0);\n    splay(r,l);\t//\u5bfb\u627e\u8282\u70b9\u7136\u540esplay\n    e[e[root].son[1]].son[0]=0;\t//\u65ad\u6389\u5173\u7cfb\n    pushup(e[root].son[1]);pushup(root);\n}\n```\n### 4.get\u64cd\u4f5c\n\u628a $x$ splay\u5230\u6839\uff0c $(x+len-1)+2=x+len+1$ splay\u5230\u6839\u7684\u53f3\u513f\u5b50\uff0c\u7136\u540e\u8f93\u51fa\u6839\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u7684\u4e2d\u5e8f\u904d\u5386\u3002\n```cpp\nvoid output(int x){\t//\u4e2d\u5e8f\u904d\u5386\n    if(e[x].son[0]) output(e[x].son[0]);\t//\u5de6\u513f\u5b50\n    if(e[x].val!='\\n') putchar(e[x].val);\t//\u81ea\u5df1\n    if(e[x].son[1]) output(e[x].son[1]);\t//\u53f3\u513f\u5b50\n}\nvoid get(int len){\n    int l=kth(pos),r=kth(pos+len+1);\n    splay(l,0);\n    splay(r,l);\t//\u5bfb\u627e\u8282\u70b9\u7136\u540esplay\n    output(e[e[root].son[1]].son[0]);\t//\u4e2d\u5e8f\u904d\u5386\u8f93\u51fa\n    putchar(10);\n}\n```\n---\n\u5927\u81f4\u5c31\u8fd9\u4e9b\u5566\uff0c\u90a3\u4e48\u5c31\u4e0a\u4ee3\u7801\uff0c\u521a\u521a\u6ca1\u6709\u8be6\u89e3\u8fc7\u7684\u5730\u65b9\u90fd\u52a0\u4e86\u6ce8\u91ca\u3002\u5f00O2\u603b\u7528\u65f6756ms\uff0c\u7a7a\u95f442.08MB\uff0c\u4e0d\u5f00O2\u603b\u7528\u65f61164ms\u3002\u867d\u8bf4\u4e0d\u662f\u5f88\u4f18\u79c0\uff0c~~\u4f46\u662f\u770b\u7740\u9898\u89e3\u6ca1\u6709\u8fd9\u4e48\u8be6\u7ec6\u7684\uff0c\u4e8e\u662f\u5c31~~\u5199\u4e00\u7bc7\u9898\u89e3\u5e2e\u5e2e\u5927\u5bb6\u3002\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct Splay{\n    #define root e[0].son[1]\n    struct node{\t//\u8282\u70b9\n        char val;\n        int size,fa,son[2];\n    }e[2100000];\n    int cnt,pos;\n    inline void pushup(int x){\t//\u4e0a\u4f20\u8282\u70b9\u4fe1\u606f\n        e[x].size=e[e[x].son[0]].size+e[e[x].son[1]].size+1;\n    }\n    inline int atson(int x){\t//\u662f\u5de6\u513f\u5b50\u8fd8\u662f\u53f3\u513f\u5b50\n        return e[e[x].fa].son[1]==x;\n    }\n    inline void connect(int x,int fa,int type){\t//\u5efa\u7acb\u5173\u7cfb\uff08\u6ce8\uff1a\u5e76\u4e0d\u65ad\u5f00\u77db\u76fe\u7684\u5173\u7cfb\uff09\n        e[x].fa=fa;\n        e[fa].son[type]=x;\n    }\n    inline int addnode(char val,int fa){\t//\u6dfb\u52a0\u8282\u70b9\n        e[++cnt].val=val;\n        e[cnt].size=1;\n        e[cnt].fa=fa;\n        return cnt;\n    }\n    void rotate(int x){\t//\u65cb\u8f6c\n        int fa=e[x].fa,ffa=e[fa].fa;\n        int type=atson(x),ttype=atson(fa);\n        int B=e[x].son[type^1];\n        connect(B,fa,type);connect(fa,x,type^1);connect(x,ffa,ttype);\n        pushup(fa);pushup(x);\n    }\n    void splay(int at,int to){\n        if(!to) root=at;\n        while(e[at].fa!=to){\n            int fa=e[at].fa;\n            if(e[fa].fa!=to) rotate(atson(at)^atson(fa)?at:fa);\n            rotate(at);\n        }\n    }\n    Splay():cnt(0),pos(1){\n        memset(e,0,sizeof(e));\n        root=addnode('\\n',0);\n        e[root].son[1]=addnode('\\n',root);\n    }\n    inline void move(int x){pos=x+1;}\n    int build(char *str,int fa,int l,int r){\n        int mid=l+r>>1;\n        char ch=str[mid-1];\n        int x=addnode(ch,fa);\n        if(l<mid) e[x].son[0]=build(str,x,l,mid-1);\n        if(mid<r) e[x].son[1]=build(str,x,mid+1,r);\n        pushup(x);\n        return x;\n    }\n    int kth(int x){\n        int now=root;\n        while(now){\n            int sum=e[e[now].son[0]].size+1;\n            if(x==sum) return now;\n            if(x<sum) now=e[now].son[0];\n            else{\n                x-=sum;\n                now=e[now].son[1];\n            }\n        }\n    }\n    void insert(int len,char *str){\n        int l=kth(pos),r=kth(pos+1);\n        splay(l,0);\n        splay(r,l);\n        e[e[root].son[1]].son[0]=build(str,e[root].son[1],1,len);\n        pushup(e[root].son[1]);pushup(root);\n    }\n    void remove(int len){\n        int l=kth(pos),r=kth(pos+len+1);\n        splay(l,0);\n        splay(r,l);\n        e[e[root].son[1]].son[0]=0;\n        pushup(e[root].son[1]);pushup(root);\n    }\n    void output(int x){\n        if(e[x].son[0]) output(e[x].son[0]);\n        if(e[x].val!='\\n') putchar(e[x].val);\n        if(e[x].son[1]) output(e[x].son[1]);\n    }\n    void get(int len){\n        int l=kth(pos),r=kth(pos+len+1);\n        splay(l,0);\n        splay(r,l);\n        output(e[e[root].son[1]].son[0]);\n        putchar(10);\n    }\n    inline void prv(){pos--;}\n    inline void nxt(){pos++;}\n}sp;\nint t;\nchar op[7],ins[2100000];\nint main(){\n    scanf(\"%d\",&t);\n    while(t--){\n        strcpy(ins,\"\");\n        int x;\n        bool flag=false;\n        scanf(\"%s\",op);\n        switch(op[0]){\t//\u54ea\u4e2a\u64cd\u4f5c\n            case 'M':\t//move\n                scanf(\"%d\",&x);sp.move(x);break;\n            case 'I':\t//insert\n                scanf(\"%d\",&x);\n                for(int i=0;i<x;i++){\n                    char ch=getchar();\n                    if(ch>=32 && ch<=126) flag=true;\n                    if(!flag || ch<32 || ch>126){\n                        i--;continue;\n                    }\n                    ins[i]=ch;\n                }\n                sp.insert(x,ins);break;\n            case 'D':\t//delete\n                scanf(\"%d\",&x);sp.remove(x);break;\n            case 'G':\t//get\n                scanf(\"%d\",&x);sp.get(x);break;\n            case 'P':\t//prev\n                sp.prv();break;\n            case 'N':\t//next\n                sp.nxt();break;\n        }\n    }\n}\n```",
        "postTime": 1529078231,
        "uid": 72118,
        "name": "AThousandSuns",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "\u770b\u4e86\u9898\u89e3\u533a\u7684\u4f17\u591a\u5927\u795e\u90fd\u6ca1\u6709\u7528\u9ed1\u79d1\u6280\uff0c\u4e8e\u662f\u81ea\u5df1\u5c31\u6765\u6c34\u4e00\u53d1 STL \u7684\u89e3\u6cd5\u3002\r\n\r\n\r\n[~~\\ STL \u5927\u6cd5\u597d/~~](https://www.luogu.com.cn/problem/P4008)\r\n\r\n------------\r\n![\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0](https://img-blog.csdnimg.cn/e6e0428301214b43ac067c70c9dd9f7b.png)\r\n\r\n\u6b63\u89c4\u89e3\u6cd5\u5757\u72b6\u94fe\u8868\uff0c\u8fd9\u91cc\u91c7\u53d6\u7684\u662f\u9ed1\u79d1\u6280\u89e3\u6cd5\u3002\r\n\r\nrope \u662f\u6269\u5c55 STL \u5e93\u4e2d\u7684\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u2014\u2014\u53ef\u6301\u4e45\u5316\u5e73\u8861\u6811\uff0c\u76f8\u6bd4\u8f83 set\uff0c\u5b83\u66f4\u9002\u5408\u533a\u95f4\u63d2\u5165\u548c\u5220\u9664\u3002\u8fd9\u91cc\u7528\u6765\u89e3\u6b64\u9898\uff0c\u5c31\u663e\u5f97\u5341\u5206~~\u50bb\u74dc~~\u5bb9\u6613\u4e86\u3002\r\n\r\n\u5934\u6587\u4ef6\uff1a ```#include <ext/rope>```\r\n\r\n\u547d\u540d\u7a7a\u95f4\uff1a ```using namespace __gnu_cxx;```\r\n\r\n\u57fa\u672c\u64cd\u4f5c\uff1a\r\n\r\n```insert(pos, s)``` \u5c06\u5b57\u7b26\u4e32 s \u63d2\u5165 pos \u4f4d\u7f6e\r\n\r\n```erase(pos, num)``` \u4ece pos \u5f00\u59cb\u5220\u9664 num \u4e2a\u5b57\u7b26\r\n\r\n```copy(pos, len, s)``` \u4ece pos \u5f00\u59cb len \u4e2a\u5b57\u7b26\u7528 s \u4ee3\u66ff\r\n\r\n```substr(pos, len)``` \u63d0\u53d6 pos \u5f00\u59cb\u7684 len \u4e2a\u5b57\u7b26\r\n\r\n```at(x)``` \u8bbf\u95ee\u7b2c x \u4e2a\u5143\u7d20\r\n\r\n\u51e0\u4e4e\u8ddf\u9898\u76ee\u4e00\u6a21\u4e00\u6837\uff01\r\n\r\n\u66f4\u5f00\u5fc3\u7684\u662f\uff0c rope \u5728 NOI \u4e2d\u662f\u5141\u8bb8\u4f7f\u7528\u7684\uff08 hooray \uff09\uff01\r\n\r\n\u4e8e\u662f\u4ee3\u7801\u5c31\u5341\u5206\u7b80\u5355\u4e86\uff1a\r\n\r\n```cpp\r\n#include <bits/stdc++.h>\r\n#include <ext/rope>\r\n\r\nusing namespace __gnu_cxx;\r\nusing namespace std;\r\n\r\nrope <char> editor;\r\n\r\nchar ch;\r\nstring oper;\r\nint pos, n, rela;\r\n\r\nint main()\r\n{\r\n\tcin.tie(0);\r\n\tcout.tie(0);\r\n\t\r\n\tscanf(\"%d\", &n);\r\n\t\r\n\twhile(n--)\r\n\t{\r\n\t    cin >> oper;\r\n\t    scanf(\"%d\", &rela);\r\n\t    \r\n\t\tif(oper ==\"Insert\"){\r\n\t\t    int pos1 = pos;\r\n\t\t\twhile(rela)\r\n\t\t\t{\r\n\t\t\t\tch = getchar();\r\n\t\t\t\tif((int)ch >= 32 && (int)ch <= 126){\r\n\t\t\t\t    editor.insert(pos1, ch);\r\n\t\t\t\t    rela--;\r\n\t\t\t\t    pos1++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n        \r\n        else if(oper ==\"Move\"){\r\n        \tpos = rela;\r\n        }\r\n        \r\n        else if(oper ==\"Next\"){\r\n            pos++;\r\n        }\r\n        \r\n        else if(oper ==\"Prev\"){\r\n        \tpos--;\r\n        }\r\n        \r\n        else if(oper ==\"Get\"){\r\n        \tcout << editor.substr(pos, rela) << endl;\r\n        }\r\n        \r\n        else if(oper ==\"Delete\"){\r\n        \teditor.erase(pos, rela);\r\n        }\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\nrope \u7684\u53ef\u6301\u4e45\u5316\r\n\r\n\u4e00\u822c\uff0c\u6211\u4eec\u53ef\u4ee5\u5229\u7528 rope \u5e95\u5c42\u53ef\u6301\u4e45\u5316\u7684\u673a\u5236\uff0c\u8fdb\u884c $O(1)$ \u56de\u9000\u3002\u4e5f\u5c31\u662f\u6211\u4eec\u53ea\u9700\u8981\u56de\u9000\u6839\u8282\u70b9\u7684\u7248\u672c\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f88\u987a\u5229\u5730\u8bbf\u95ee\u5f53\u65f6\u7684\u6240\u6709\u8282\u70b9\u4e86\u3002\u6545\u56de\u9000\u590d\u6742\u5ea6\u4e3a $O(1)$\u3002\r\n\r\n\u53ef\u6301\u4e45\u5316 rope \u7684\u521d\u59cb\u5316\uff1a\r\n\r\n```cpp\r\nrope<char>*ver[100];\r\nver[0]=new rope<char>();\r\n```\r\n\r\n\u53ef\u6301\u4e45\u5316 rope \u5efa\u7acb\u65b0\u7248\u672c\u548c\u56de\u9000\u65e7\u7248\u672c\uff1a\r\n```cpp\r\nver[i]=new rope<char>(*ver[i-1]); //\u4ece\u7248\u672c i-1 \u5efa\u7acb\u65b0\u7248\u672c i\r\nver[i]=ver[i-1] //\u7248\u672c i \u56de\u9000\u4e3a\u7248\u672c i-1\r\n```\r\n\u53cc\u500d\u7ecf\u9a8c  [P4567 \u3010AHOI2006\u3011 \u6587\u672c\u7f16\u8f91\u5668](https://www.luogu.com.cn/problem/P4567)\u3002\r\n\r\n\u6b64\u9898\u662f\u4e0a\u9898\u7684\u5347\u7ea7\u7248\uff0c\u56e0\u4e3a\u8981\u5b9e\u73b0 rotate \u64cd\u4f5c\uff0c\u6240\u4ee5\u5b58\u50a8\u4e24\u4e2a rope\uff0c\u4e00\u6b63\u4e00\u53cd\u3002\r\n\r\n\u4ee3\u7801\u57fa\u672c\u76f8\u540c\uff0c\u7565\u3002",
        "postTime": 1673060166,
        "uid": 504597,
        "name": "sunrzily",
        "ccfLevel": 0,
        "title": "NOI2003 \u6587\u672c\u7f16\u8f91\u5668 \u9898\u89e3"
    },
    {
        "content": "\u8fd9\u91cc\u540c\u6837\u4e5f\u662f\u975e\u65cbTreap\u7684\u505a\u6cd5  \n\u53ea\u4e0d\u8fc7\u4f7f\u7528\u4e86\u6570\u7ec4\u800c\u975e\u6307\u9488  \n~~\u6307\u9488\u867d\u7136\u8dd1\u5f97\u5feb.\u4f46\u662f\u5bb9\u6613\u5199\u6302~~  \n\u975e\u65cbTreap\u771f\u7684\u5f88\u597d\u5199,\u601d\u7ef4\u91cf\u548c\u4ee3\u7801\u91cf\u90fd\u4e0d\u7b97\u5927  \n\u6211\u7b2c\u4e00\u6b21\u7528Insert\u66b4\u529b\u63d2\u5165\u5b57\u7b26\u4e32.\u6210\u529f\u7684T\u6389\u4e86\u4e24\u4e2a\u70b9  \n\u7136\u540e\u6211\u7684\u7b2c\u4e8c\u7684\u60f3\u6cd5\u5c31\u662f\u628a\u8981\u63d2\u5165\u7684\u5b57\u7b26\u4e32\u5148\u751f\u6210\u4e00\u68f5\u6811,\u4f46\u4ecd\u7136\u662fInsert\u66b4\u529b  \n\u7136\u540e\u5728\u5408\u5e76..\u6240\u4ee5\u8fd8\u662fT\u6389\u4e86,\u590d\u6742\u5ea6\u4e0d\u6b63\u786e,\u5361\u5e38\u6570\u4f5c\u7528\u6709\u9650  \n\u6b63\u786e\u7684\u65b9\u6cd5\u5e94\u8be5\u662fO(N)\u4e2d\u5e8f\u5efa\u6811,O(logN)\u63d2\u5165  \n\u5efa\u6811\u65b9\u6cd5\u7c7b\u4f3c\u4e8e\u7b1b\u5361\u5c14\u5efa\u6811.\u76f4\u63a5\u5c31\u662f\u4e00\u9897\u6ee1\u8db3\u6761\u4ef6\u7684Treap  \n\u7136\u540e\u5c31\u662f\u4e00\u4e9b\u7ec6\u8282\u95ee\u9898,\u6bd4\u5982\u8f93\u5165\u5b57\u7b26\u4e32\u5ffd\u7565\u6362\u884c,\u8fd9\u91cc\u6211\u5361\u4e86\u90a3\u4e48\u4e00\u4e0b  \n\u6700\u540e\u8fd8\u662f\u7528getchar\u6765\u626b\u63cf,,\u76f4\u5230\u8f93\u5165\u4e86\u7b26\u5408\u6761\u4ef6\u7684\u5b57\u7b26\u4e32\u9000\u51fa  \n\u64cd\u4f5c\u90fd\u6bd4\u8f83\u5e38\u89c4,\u548c\u6b63\u5e38\u7684\u975e\u65cbTreap\u9664\u4e86\u591a\u4e86\u4e2aBuild\u5916\u6ca1\u4ec0\u4e48\u533a\u522b  \n\u53ea\u8981\u628aMerge\u548cSplit\u5199\u6b63\u786e,\u5176\u4ed6\u64cd\u4f5c\u662f~~\u65e0\u8111split\u548cmerge\u5c31\u884c~~\u5f88\u5bb9\u6613\u60f3\u51fa\u6765\u7684\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#define MAXN 1200*1200*3\nusing namespace std;\nstruct node{int val,key,size,l,r;}t[MAXN];\nint root,tot,n,cursor,N,stk[MAXN];\nchar s[MAXN];\ninline void update(int now){t[now].size=t[t[now].l].size+t[t[now].r].size+1;}\ninline int NEW(int val){t[++tot]=(node){val,rand(),1,0,0};return tot;}\ninline void getstring_immutable(char*s,int maxlen) \n{\n\tchar ch=getchar();\n\tint len=0;\n\twhile(len<maxlen)\n\t{\n\t\tif(ch>=32&&ch<=128)s[len++]=ch;\n\t\tch=getchar();\n\t}\n}\ninline void split(int now,int&x,int&y,int rank)          \n{\n\tif(!now){x=y=0;return;}\n\tif(t[t[now].l].size>=rank)y=now,split(t[now].l,x,t[y].l,rank);\n\telse x=now,split(t[now].r,t[x].r,y,rank-t[t[now].l].size-1);\n\tupdate(now);\n}\ninline void merge(int&now,int x,int y)\n{\n\tif(!x||!y){now=x+y;return;}\n\tif(t[x].key<t[y].key)now=x,merge(t[now].r,t[x].r,y);\n\telse now=y,merge(t[now].l,x,t[y].l);\n\tupdate(now);\n}\ninline int build(char *a,int k)\n{\n    int tp=0;\n    for(int i=0;i<k;i++) \n\t{\n        NEW(a[i]);int lst=0;\n        while(tp&&t[stk[tp]].key>t[tot].key)update(stk[tp]),lst=stk[tp--];\n        if(tp)t[stk[tp]].r=tot;\n        t[tot].l=lst;\n        stk[++tp]=tot;\n    }\n    while(tp)update(stk[tp--]);\n    return stk[1]; \n}\ninline void Delete(int l_pos,int r_pos)\n{\n\tr_pos+=l_pos;\n\tint x=0,y=0,z=0;              \n\tsplit(root,x,y,r_pos);\n\tsplit(x,x,z,l_pos);\n\tmerge(root,x,y);\n}\ninline void print_tree(int now)\n{\n\tif(t[now].l)print_tree(t[now].l);\n\tprintf(\"%c\",t[now].val);\n\tif(t[now].r)print_tree(t[now].r);\n}\nvoid print(int l_pos,int r_pos)\n{\n\tr_pos+=l_pos;\n\tint x=0,y=0,z=0;              \n\tsplit(root,x,y,r_pos);\n\tsplit(x,x,z,l_pos);\n\tprint_tree(z);\n\tmerge(x,x,z);\n\tmerge(root,x,y);\n}\nvoid magic()\n{ \n\tstring Input; //\u521a\u5f00\u59cb\u6211\u7528\u4e86char Input[]...\n\tcin>>Input;\n\tif(Input==\"Move\")cin>>cursor;\n\tif(Input==\"Insert\")\n\t{\n\t\tint len;\n\t\tcin>>len;\n\t\tgetstring_immutable(s,len);\n\t\tint x=0,y=0,z=build(s,len);\n\t\tsplit(root,x,y,cursor);\n\t\tmerge(x,x,z);\n\t\tmerge(root,x,y);\n\t}\n\tif(Input==\"Delete\")\n\t{\n\t\tint lenth;cin>>lenth;\n\t\tDelete(cursor,lenth);\n\t}\n\tif(Input==\"Get\")\n\t{\n\t\tint num;cin>>num;\n\t\tprint(cursor,num);\n\t\tputchar('\\n');\n\t}\n\tif(Input==\"Prev\")\n\t{\n\t\tcursor--;\n\t\tif(cursor<0)cursor=0;\n\t}\n\tif(Input==\"Next\")\n\t{\n\t\tcursor++;\n\t\tif(cursor>t[root].size)cursor=t[root].size;\n\t}\n}\nint main()\n{\n\tNEW(2147483647);\n\tt[root].size=0;\n\tcin>>N;\n\tfor(int i=1;i<=N;i++)magic();\n}\n```",
        "postTime": 1541175556,
        "uid": 36507,
        "name": "shijunfeng00",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "splay\u662f\u597d\u6587\u660e\u3010\u96fe\n\n\n\u5982\u679c\u4f60\u8fd8\u6ca1\u6709\u63a5\u89e6\u8fc7splay\uff0c\u6216\u8005\u5bf9splay\u7684\u533a\u95f4\u64cd\u4f5c\u4e0d\u719f\u6089\u7684\uff0c[\u5b89\u5229\u4e00\u6ce2\u81ea\u5df1\u7684blog](http://www.cnblogs.com/dedicatus545/p/8227459.html)\n\n\n### \u3010\u5e7f\u544a\u3011\u672c\u9898\u9898\u89e3\uff1a[Dedicatus545](http://www.cnblogs.com/dedicatus545/p/8377866.html)\n\n\n\u8a00\u5f52\u6b63\u4f20\uff0c\u8fd9\u9053\u9898\u5728\u770b\u660e\u767d\u9898\u610f\u4ee5\u540e\u5c31\u662f\u88f8\u7684\uff0c\u56e0\u6b64\u8fd9\u91cc\u4e0d\u8bb2\u5177\u4f53\u7684\u505a\u6cd5\u4e86\uff08\u53ef\u4ee5\u5728\u6ce8\u91ca\u91cc\u770b\uff09\n\n\n\u8fd9\u7bc7\u9898\u89e3\u4e3b\u8981\u8bb2\u51e0\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u70b9\n\n\n### \u5b57\u7b26\u8bfb\u5165\u7684\u95ee\u9898\n\n\u8fd9\u662f\u4e00\u4e2a\u5927\u5751\u70b9\u3002\n\n\n\u672c\u9898\u7684\u6570\u636e\uff0c\u7ecf\u8fc7\u672c\u849f\u84bb24h\u542b\u6cea\u8c03\u8bd5\uff0c\u786e\u5b9a\u4e3a\u662f\u5728Windows\u4e0b\u751f\u6210\uff0cLinux\u4e0b\u8bc4\u6d4b\u7684\n\n\n\u8fd9\u5c31\u610f\u5473\u7740\u6362\u884c\uff0c\u7531\\r\\n\u5b8c\u6210\uff0c\u800c\u4e0d\u662f\\n\n\n\n\u5982\u679c\u4f60\u662f\u7528getchar\u8bfb\u5165\u6570\u636e\u7684\uff0c\u90a3\u4e48\u4f60\u8981\u6ce8\u610f\u4e86\uff0c\u4e0d\u4ec5\u662fASCII\u7801\u503c\u4e3a10\u7684\\n\u9700\u8981\u5ffd\u7565\uff0c\u503c\u4e3a13\u7684\\r\u4e5f\u8981\u5ffd\u7565\n\n\n\uff08\u5176\u5b9e\\r\u8fd9\u4e1c\u897f\u5230\u5e95\u5e72\u561b\u7528\u7684\uff1f\uff1f\uff09\n\n\n### \u6570\u636e\u8303\u56f4\u7684\u5751\u70b9\n\n\u8fd9\u9898\u4e00\u4e2a\u660e\u663e\u7684\u7279\u5f81\u5c31\u662f\u6570\u636e\u8303\u56f4\u7684\u63cf\u8ff0\u66a7\u6627\u4e0d\u6e05\n\n\n\u4e00\u770b\u5c31\u662f\u9648\u5e74\u8001\u989823333\n\n\n\u9700\u8981\u6ce8\u610f\uff1a\u867d\u7136\u8f93\u51fa\u53ef\u80fd\u4e0d\u591a\uff0c\u4f46\u662f\u4e00\u6b21\u6027\u63d2\u5165\u7684\u5b57\u7b26\u6570\u91cf\u53ef\u4ee5\u9ad8\u8fbe2000000\u4e2a\n\n\n\u6ca1\u9519\uff0c6\u4e2a0\n\n\n\u56e0\u6b64\u4e00\u5b9a\u8981\u5f00\u591f\u4e34\u65f6\u6570\u7ec4\u548csplay\u6570\u7ec4\u7684\u5927\u5c0f......\n\n\n### \u4e00\u4e2a\u5c0f\u6280\u5de7\n\n\u63d2\u5165\u4e00\u4e2a\u4e32\u7684\u65f6\u5019\uff0c\u5148\u9012\u5f52\u628a\u8fd9\u4e2a\u4e32\u6784\u5efa\u6210\u4e00\u68f5\u5e73\u8861\u6811\uff0c\u518d\u201c\u63a5\u201d\u5230splay\u597d\u7684\u6839\u8282\u70b9\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u90a3\u91cc\n\n\n\u6548\u7387++\n\n\nCode:\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read(){\n    int re=0,flag=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){\n        if(ch=='-') flag=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n    return re*flag;\n}\nint n,cnt=0,root=0,mouse=0;//mouse\u5c31\u662f\u5f53\u524d\u5149\u6807\u7684\u4f4d\u7f6e\nint fa[3000010]={0},ch[3000010][2]={0},siz[3000010]={0};\nchar w[3000010]={0};\n//\u88ab\u6570\u636e\u8303\u56f4\u5413\u6015\u4e86\uff0c\u5f00\u4e861.5\u500d......\nvoid update(int x){siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;}\nint get(int x){return ch[fa[x]][1]==x;}\nvoid rotate(int x){\n    int f=fa[x],ff=fa[f],son=get(x);\n    ch[f][son]=ch[x][son^1];\n    if(ch[f][son]) fa[ch[f][son]]=f;\n    fa[f]=x;ch[x][son^1]=f;\n    fa[x]=ff;\n    if(ff) ch[ff][ch[ff][1]==f]=x;\n    update(f);update(x);\n}\nvoid splay(int x,int to){\n//    cout<<\"splay \"<<x<<ends<<\" \"<<endl;\n    if(x==to||fa[x]==to) return;\n    if(to==0) root=x;\n    for(int f;(f=fa[x])&&(f!=to);rotate(x)){\n        if(fa[f]!=to)\n            rotate(get(x)==get(f)?f:x);\n    }\n    update(x);\n}\nint rank(int x,int pos){//\u6c42\u6392\u540d\u4e3ax\u7684\u70b9\n//    cout<<\"rank \"<<x<<ends<<siz[pos]<<ends<<siz[ch[pos][0]]<<ends<<pos<<endl;\n//    if(pos==0) system(\"pause\");\n    if(siz[ch[pos][0]]+1==x){\n        splay(pos,0);return pos;\n    }\n    if(siz[ch[pos][0]]>=x) return rank(x,ch[pos][0]);\n    else return rank(x-siz[ch[pos][0]]-1,ch[pos][1]);\n}\nchar s[2000010]={0};\nint build(int l,int r,int f){//\u628a\u4e00\u4e2a\u7ed9\u5b9a\u533a\u95f4\u5efa\u6210\u5e73\u8861\u6811\n    if(l>r) return 0;\n//    cout<<\"build \"<<l<<ends<<r<<ends<<f<<endl; \n    int mid=(l+r)>>1,cur=++cnt;\n    fa[cur]=f;w[cur]=s[mid];\n    ch[cur][0]=build(l,mid-1,cur);\n    ch[cur][1]=build(mid+1,r,cur);\n    update(cur);return cur;\n}\nvoid insert(int l,int len){//\u63d2\u5165\u4e00\u6bb5\u533a\u95f4\n    int x=rank(l,root),y=rank(l+1,root);\n    splay(x,0);splay(y,root);\n    ch[y][0]=build(1,len,y);\n    update(y);update(x);\n}\nvoid del(int l,int r){//\u5220\u9664\u533a\u95f4\n    int x=rank(l,root),y=rank(r+2,root);\n    splay(x,0);splay(y,root);\n    ch[y][0]=0;update(y);update(x);\n}\nvoid dfs(int x){//\u4e2d\u5e8f\u904d\u5386\n    if(!x) return;\n    dfs(ch[x][0]);\n    printf(\"%c\",w[x]);\n    dfs(ch[x][1]);\n}\nvoid print(int l,int len){//\u8f93\u51fa\n    int x=rank(l,root),y=rank(l+len+1,root);\n    splay(x,0);splay(y,root);\n    dfs(ch[y][0]);puts(\"\");\n}\nint main(){\n    int i,j,t1;char op[10];char c;\n    n=read();\n    root=++cnt;w[cnt]=0;siz[cnt]=2;\n    ch[cnt][1]=cnt+1;cnt++;fa[cnt]=cnt-1;w[cnt]=0;siz[cnt]=1;\n    mouse=1;\n    //\u672c\u9898\u4e2d\u9700\u8981\u5728\u5e8f\u5217\u4e24\u8fb9\u63d2\u5165\u4e24\u4e2a\u201c\u54e8\u5175\u201d\uff0c\u9632\u6b62splay\u8d8a\u754c\uff0c\u6545mouse\u4e5f\u662f\u8003\u8651\u4e86\u54e8\u5175\u4ee5\u540e\u7684\u503c\uff08\u4ece\u4e00\u5f00\u59cb\uff09\n    for(i=1;i<=n;i++){\n        scanf(\"%s\",op);\n        if(op[0]=='I'){\n            t1=read();\n            for(j=1;j<=t1;j++){\n                c=getchar();\n                while(c=='\\n'||c=='\\r') c=getchar();//\u8d85\u7ea7\u5927\u5751\n                s[j]=c;\n            }\n            insert(mouse,t1);\n        }\n        if(op[0]=='D'){\n            t1=read();\n            del(mouse,mouse+t1-1);\n        }\n        if(op[0]=='G'){\n            t1=read();\n            print(mouse,t1);\n        }\n        if(op[0]=='M'){\n            t1=read();\n            mouse=t1+1;\n        }\n        if(op[0]=='N') mouse++;\n        if(op[0]=='P') mouse--;\n    }\n}\n```",
        "postTime": 1517383698,
        "uid": 27753,
        "name": "Orion545",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]editor\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "[Welcome to my Blog](https://zcdhj.org)\n\nSplay \u7ef4\u62a4\u5e8f\u5217\u3002\n\n\u5bf9\u4e8e\u6bcf\u79cd\u64cd\u4f5c\uff0c\u5c06\u5bf9\u5e94\u7684\u533a\u95f4\u63d0\u53d6\u51fa\u6765\uff0c\u7136\u540e\u64cd\u4f5c\u5373\u53ef\u3002\n\n\u8981\u6ce8\u610f\u6570\u636e\u662f\u5728 Windows \u4e0b\u751f\u6210\u7684\uff0c\u6240\u4ee5\u5728\u8bfb\u5b57\u7b26\u4e32\u7684\u65f6\u5019\u9664\u4e86 `\\n` \u8fd8\u8981\u5224\u65ad`\\r`\u3002\n\n\u5e0c\u671b\u8fd9\u91cc\u7684\u4ee3\u7801\u80fd\u5bf9\u6307\u9488\u515a\u6709\u5e2e\u52a9 qwq\n\n```cpp\n#include <iostream>\n#include <iostream>\n#include <cstdio>\n\nconst int MAXN = 2100000;\n\nint n, nowCursor, Len;\nchar Str[MAXN | 1];\n\nnamespace Splay {\n    struct Tree {\n        struct Splay {\n            char val;\n            int size;\n            Splay *ch[2], *father;\n            Splay() {}\n            Splay(char _val, Splay *_father) : val(_val), size(1), father(_father) { ch[0] = ch[1] = NULL; }\n        } *root;\n        inline int size(Splay *o) { return o ? o -> size : 0; }\n        inline void pushup(Splay *o) { o -> size = 1 + size(o -> ch[0]) + size(o -> ch[1]); }\n        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }\n        inline void connect(Splay *x, Splay *y, int relation) {\n            if(x) x -> father = y;\n            if(y) y -> ch[relation] = x;\n        }\n        inline void rotate(Splay *o) {\n            Splay *p = o -> father, *q = p -> father;\n            int wson = relation(o);\n            connect(o, q, relation(p));\n            connect(o -> ch[wson ^ 1], p, wson);\n            connect(p, o, wson ^ 1);\n            pushup(p);\n            pushup(o);\n        }\n        inline void splay(Splay *o, Splay *goal) {\n            if(!o) return;\n            while(o -> father != goal) {\n                Splay *p = o -> father;\n                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);\n                rotate(o);\n            }\n            if(!goal) root = o;\n        }\n        inline Splay *kth(int k) {\n            Splay *o = root;\n            while(1) {\n                if(size(o -> ch[0]) + 1 == k) return o;\n                else if(size(o -> ch[0]) >= k) o = o -> ch[0];\n                else {\n                    k -= size(o -> ch[0]) + 1;\n                    o = o -> ch[1];\n                }\n            }\n            return NULL;\n        }\n        inline void build(Splay *&o, Splay *fa = NULL, int l = 1, int r = Len) {\n            if(l > r) return;\n            int mid = (l + r) >> 1;\n            o = new Splay(Str[mid], fa);\n            build(o -> ch[0], o, l, mid - 1);\n            build(o -> ch[1], o, mid + 1, r);\n            pushup(o);\n        }\n        inline void out(Splay *o) {\n            if(!o) return;\n            out(o -> ch[0]);\n            if(o -> val != '\\n') putchar(o -> val);\n            out(o -> ch[1]);\n        }\n        inline void remove(Splay *&o) {\n            if(!o) return;\n            remove(o -> ch[0]);\n            remove(o -> ch[1]);\n            delete o;\n            o = NULL;\n        }\n        inline void Insert() {\n            scanf(\"%d\", &Len);\n            for(int i = 1; i <= Len; ++i) {\n                char ch = getchar();\n                while(ch == '\\n' || ch == '\\r') ch = getchar();\n                Str[i] = ch;\n            }\n            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            Splay *ptr;\n            build(ptr);\n            connect(ptr, root -> ch[1], 0);\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void Delete() {\n            scanf(\"%d\", &Len);\n            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + Len + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            remove(root -> ch[1] -> ch[0]);\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void Get() {\n            scanf(\"%d\", &Len);\n            Splay *o1 = kth(nowCursor), *o2 = kth(nowCursor + Len + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            out(root -> ch[1] -> ch[0]);\n            printf(\"\\n\");\n        }\n    } tree;\n}\n\nusing namespace Splay;\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    Str[1] = Str[2] = '\\n';\n    tree.build(tree.root, NULL, 1, 2);\n    nowCursor = 1;\n    while(t--) {\n        char opt[10];\n        scanf(\"%s\", opt);\n        if(*opt == 'M') scanf(\"%d\", &nowCursor), ++nowCursor;\n        else if(*opt == 'I') tree.Insert();\n        else if(*opt == 'D') tree.Delete();\n        else if(*opt == 'G') tree.Get();\n        else if(*opt == 'P') --nowCursor;\n        else ++nowCursor;\n    }\n    return 0;\n}\n```",
        "postTime": 1544186322,
        "uid": 24878,
        "name": "iodwad",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "\u63d0\u4f9b\u6307\u9488Splay\n\n\u7528Splay\u7ef4\u62a4\u5e8f\u5217 \u652f\u6301\u533a\u95f4\u64cd\u4f5c\u7684\u6587\u827a\u5e73\u8861\u6811\n\n\u5206\u6790\u4e00\u4e0b\u51e0\u4e2a\u64cd\u4f5c\n\n\u8bb0\u5f55\u5149\u6807\u4f4d\u7f6e:cursor\n\n1.Move(pos)\u628a\u5149\u6807\u79fb\u52a8\u5230\u7b2cpos\u4e2a\u5b57\u7b26\u540e\uff1acursor=pos\n\n2.Insert(len,str) \u5728\u5149\u6807\u540e\u6dfb\u52a0\u4e00\u4e32\u957f\u4e3alen\u7684\u5b57\u7b26\u4e32str\n\n\u5229\u7528build\u51fd\u6570 \u5c06\u4e32str\u5efa\u6210\u4e00\u68f5Splay\n\n\u627e\u5230\u5149\u6807cursor\u6240\u6307\u7684\u5b57\u7b26 splay\u81f3\u6839\n\n\u627e\u5230cursor+1\u6240\u6307\u7684\u5b57\u7b26 splay\u81f3cursor\u7684\u53f3\u513f\u5b50\u5904\n\n\u6b64\u65f6cursor+1\u7684\u5de6\u513f\u5b50\u6307\u5411\u65b0Splay\u7684\u6839\n\n\u6ce8\u610f\u6dfb\u52a0\u8fb9\u754c\u8282\u70b9\n\n3.Delete(tot)\u5728\u5149\u6807\u540e\u5220\u9664tot\u4e2a\u5b57\u7b26\n\n\u5229\u7528split\u51fd\u6570 \u7528\u4e0eInsert\u7c7b\u4f3c\u7684\u5904\u7406\n\n\u627e\u5230\u8981\u5904\u7406\u7684\u533a\u95f4[cursor+1,cursor+tot]\n\n4.Get(tot)\u8f93\u51fa\u5149\u6807\u540etot\u4e2a\u5b57\u7b26\n\n\u540c\u7406\u627e\u5230\u8981\u67e5\u770b\u7684\u533a\u95f4\n\n\u5199\u4e2a\u4e2d\u5e8f\u904d\u5386\u51fd\u6570\u904d\u5386\u4e00\u904d\u5373\u53ef\n\n5.Prev() \u5149\u6807\u5de6\u79fb\uff1acursor--\n\n5.Next() \u5149\u6807\u53f3\u79fb\uff1acursor++\n```cpp\n#include<queue>\n#include<cstdio>\nusing namespace std;\nnamespace Splay\n{\n\tstruct tree\n\t{\n\t\tint size;\n\t\tchar value;\n\t\ttree *son[2],*fa;\n\t\tinline tree(char ch)\n\t\t{\n\t\t\tsize=1;\n\t\t\tvalue=ch;\n\t\t\tfa=son[0]=son[1]=NULL;\n\t\t}\n\t\tinline void pushup()\n\t\t{\n\t\t\tsize=1;\n\t\t\tif (son[0])size+=son[0]->size;\n\t\t\tif (son[1])size+=son[1]->size;\n\t\t}\n\t}*root;\n\tinline bool relation(tree *p)\n\t{\n\t\tif (p&&p->fa)return p->fa->son[1]==p;\n\t}\n\tinline void connect(tree *&p,tree *&fa,bool which)\n\t{\n\t\tif (p)p->fa=fa;\n\t\tif (fa)fa->son[which]=p;\n\t}\n\tinline void rotate(tree *&p)\n\t{\n\t\ttree *fa=p->fa;\n\t\tbool lr=relation(p);\n\t\tconnect(p,fa->fa,relation(fa));\n\t\tconnect(p->son[lr^1],fa,lr);\n\t\tconnect(fa,p,lr^1);\n\t\tfa->pushup();p->pushup();\n\t}\n\tinline void splay(tree *&p,tree *goal)\n\t{\n\t\tfor (tree *fa;(fa=p->fa)!=goal;rotate(p))\n\t\t\tif (fa->fa!=goal)\n\t\t\t\trotate(relation(fa)==relation(p)?fa:p);\n\t\tif (goal==NULL)root=p;\n\t}\n\ttree *build(tree *fa,char *data,int l,int r) //\u5efa\u7acb\u4e00\u68f5\u8868\u793a\u4e32data\u7684Splay\n\t{\n\t\tint mid=(l+r)>>1;\n\t\ttree *p=new tree(data[mid]);\n\t\tp->fa=fa;\n\t\tif (l<mid)p->son[0]=build(p,data,l,mid-1);\n\t\tif (r>mid)p->son[1]=build(p,data,mid+1,r);\n\t\tp->pushup();\n\t\treturn p;\n\t}\n\tinline tree *find_rank(int ranking) //\u627e\u5230\u6392\u540d\u4e3aranking\u7684\u5b57\u7b26\n\t{\n\t\tranking++; //\u56e0\u4e3a\u52a0\u4e86\u8fb9\u754c\n\t\ttree *p=root;\n\t\twhile (1)\n\t\t\tif (p->son[0]&&ranking<=p->son[0]->size)\n\t\t\t\tp=p->son[0];\n\t\t\telse\n\t\t\t{\n\t\t\t\tranking-=(p->son[0]?p->son[0]->size:0)+1;\n\t\t\t\tif (!ranking)return p;\n\t\t\t\tp=p->son[1];\n\t\t\t}\n\t}\n\tinline tree *split(int l,int r) //\u627e\u51fa\u8981\u5904\u7406\u7684\u533a\u95f4[l,r]\n\t{\n\t\ttree *pre=find_rank(l-1),*nxt=find_rank(r+1);\n\t\tsplay(pre,NULL);splay(nxt,pre);\n\t\treturn nxt->son[0];\n\t}\n\tvoid check(tree *p)  //\u4e2d\u5e8f\u904d\u5386\n\t{\n\t\tif (p->son[0])check(p->son[0]);\n\t\tprintf(\"%c\",p->value);\n\t\tif (p->son[1])check(p->son[1]);\n\t}\n}using namespace Splay;\nint cursor,n; //cursor:\u5149\u6807\ninline void Move(int pos)\n{\n\tcursor=pos;\n}\ninline void Insert(int pos,int tot,char *insertion)\n{\n\ttree *x=find_rank(pos),*y=find_rank(pos+1);\n\tsplay(x,NULL);splay(y,x);\n\ttree *inserted_root=build(NULL,insertion,1,tot); //\u4ee5\u5f85\u63d2\u5165\u5b57\u7b26\u4e32\u5efa\u7acb\u65b0Splay\uff0c\u6839\u4e3ainserted_root\n\tconnect(inserted_root,root->son[1],0); //\u8fde\u63a5\u4e0a\u53bb\n\troot->son[1]->pushup();root->pushup();\n}\ninline void Delete(int pos,int tot)\n{\n\ttree *p=split(pos+1,pos+tot);\n\troot->son[1]->son[0]=NULL;\n\tqueue<tree*>del;del.push(p); //\u9632\u6b62\u6307\u9488MLE \u628a\u533a\u95f4\u5185\u6240\u6709\u7684\u6307\u9488\u90fd\u7ed9delete\u6389\n\twhile (del.size())\n\t{\n\t\ttree *cut=del.front();del.pop();\n\t\tif (cut->son[0])del.push(cut->son[0]);\n\t\tif (cut->son[1])del.push(cut->son[1]);\n\t\tdelete cut;\n\t}\n\troot->son[1]->pushup();\n\troot->pushup();\n}\ninline void Get(int pos,int tot)\n{\n\ttree *p=split(pos+1,pos+tot);\n\tcheck(p);\n\tputs(\"\");\n}\ninline void Prev()\n{\n\tcursor--;\n}\ninline void Next()\n{\n\tcursor++;\n}\nint main()\n{\n\tchar SET[2];SET[0]=31;SET[1]=127;\n\troot=build(NULL,SET,0,1); //\u6dfb\u52a0\u8fb9\u754c\n\tscanf(\"%d\",&n);\n\twhile (n--)\n\t{\n\t\tchar opt[6];scanf(\"%s\",opt);\n\t\tswitch(opt[0])\n\t\t{\n\t\t\tcase 'M':\n\t\t\t{\n\t\t\t\tint pos;\n\t\t\t\tscanf(\"%d\",&pos);\n\t\t\t\tMove(pos);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'I':\n\t\t\t{\n\t\t\t\tint tot;scanf(\"%d\",&tot);\n\t\t\t\tchar insertion[tot+1];\n\t\t\t\tfor (int i=1;i<=tot;i++)\n\t\t\t\t{\n\t\t\t\t\tchar ch=getchar();\n\t\t\t\t\twhile (ch=='\\n'||ch=='\\r')ch=getchar();\n\t\t\t\t\tinsertion[i]=ch;\n\t\t\t\t}\n\t\t\t\tInsert(cursor,tot,insertion);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'D':\n\t\t\t{\n\t\t\t\tint tot;\n\t\t\t\tscanf(\"%d\",&tot);\n\t\t\t\tDelete(cursor,tot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'G':\n\t\t\t{\n\t\t\t\tint tot;\n\t\t\t\tscanf(\"%d\",&tot);\n\t\t\t\tGet(cursor,tot);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'P':Prev();break;\n\t\t\tcase 'N':Next();break;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1533550797,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "\u4f5c\u4e3a\u9898\u76ee\u63d0\u4f9b\u8005\uff0c\u5148\u6765\u6c34\u4e00\u53d1\u9898\u89e3\n\n\u672c\u9898\u53ef\u4ee5\u8bf4\u662f\u5e73\u8861\u6811\u7684\u88f8\u9898\uff0c\u968f\u4fbf\u6253\u6253\u6807\u8bb0\u5c31\u80fd\u8fc7\u4e86\n\n\u4e0d\u8fc7\u5728\u6b64\u63d0\u4f9b\u4e00\u79cd\u5757\u72b6\u94fe\u8868\u7684\u505a\u6cd5\n\n\u5757\u72b6\u94fe\u8868\uff0c\u5c31\u662f\u6570\u7ec4\u548c\u94fe\u8868\u7684\u7ed3\u5408\u4f53\n\n\u4ed6\u7684\u601d\u60f3\u662f\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u94fe\u8868\u4e2d\u7684\u8282\u70b9\uff0c\u90fd\u4fdd\u5b58\u4e00\u4e2a\u6570\u7ec4\n\n\u5269\u4e0b\u7684\u5c31\u662f\u66b4\u529b\u54af\n\n\u65f6\u95f4\u590d\u6742\u5ea6:$\\sqrt{n}$\n\n        \n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2000000+10;\nconst int BlockSize=3000 + 100,BlockNum=3000 + 10;\nint Cur=0,head,tot;\nchar str[MAXN];\nstruct Block\n{\n    int size,nxt;\n    bool rev;\n    char a[BlockSize];\n    void Clear()\n    {\n        size=0;nxt=-1,rev=0;\n    }\n}B[BlockNum];\nqueue<int>q;//\u9422\u3124\u7af4\u6d93?\u69e6\u9352\u6941\u6f75\u7f01\u5b58\u59e2\u8930\u64b3\u58a0\u93c8\u590a\u6462\u6d5c\u6d98\u6f61\nint NewNode()\n{\n    int t=q.front();q.pop();\n    B[t].Clear();\n    return t;\n}\ninline void Pre()\n{\n    while(q.size()!=0)    q.pop();\n    for(int i=0;i<BlockNum;i++) q.push(i);\n    head = NewNode();\n}\nvoid Find(int &idx,int &cur)\n{\n    while(idx!=-1&&cur>B[idx].size) cur-=B[idx].size,idx=B[idx].nxt;\n}\nvoid Pushdown(int idx)\n{\n    if(B[idx].rev) \n    {\n    //    for(int i=0;i<B[idx].size;i++)\n    //        cout<<B[idx].a[i];cout<<endl;\n        reverse(B[idx].a,B[idx].a+B[idx].size);\n    //    for(int i=0;i<B[idx].size;i++)\n    //        cout<<B[idx].a[i];cout<<endl;\n        B[idx].rev=0;\n    }\n}\ninline void Split(int idx,int cur)\n{\n    if(idx==-1||cur==B[idx].size)    return ;\n    Pushdown(idx);\n    int tot=NewNode();\n    memcpy(B[tot].a,B[idx].a+cur,sizeof(char) * (B[idx].size-cur) );\n    B[tot].size=B[idx].size-cur;\n    B[idx].size=cur;\n    B[tot].nxt=B[idx].nxt;\n    B[idx].nxt=tot;\n}\nvoid Delet(int idx)\n{\n    q.push(idx);\n}\nvoid Merge(int idx)\n{\n    for(int i=idx;i!=-1;i=B[i].nxt)\n        for(int j=B[i].nxt;j!=-1;j=B[j].nxt)\n        {\n            if(B[i].size+B[j].size<=BlockSize)\n            {\n                Pushdown(i);\n                Pushdown(j);\n                memcpy(B[i].a+B[i].size,B[j].a,sizeof(char) * B[j].size);\n                B[i].size+=B[j].size;B[i].nxt=B[j].nxt;\n                Delet(j);\n            }\n            else break;\n        }\n}\ninline void Insert(int cur,int x,char *str)\n{\n    int idx=head;\n    Find(idx,cur);\n    Split(idx,cur);\n    int i=0;//\u5bb8\u832c\u7ca1\u9354\u72b2\u53c6\u9428\u52ea\u91dc\u93c1?\n    while(i<x)\n    {\n        int Limit=min(BlockSize,x-i);\n        int tot=NewNode();\n        memcpy(B[tot].a,str+i,sizeof(char) * Limit);\n        B[tot].size=Limit;\n        B[tot].nxt=B[idx].nxt;\n        B[idx].nxt=tot;\n        idx=B[idx].nxt;\n        i+=Limit;\n    }\n    Merge(head);\n}\nvoid Print(int k, int n, char *str)\n{\n    int idx = head;\n    Find(idx, k);\n    int len = 0;\n    for(int i = idx; i != -1 && n > 0; i = B[i].nxt)\n    {\n        Pushdown(i);\n        int Limit = min(n, B[i].size - k);\n        memcpy(str + len, B[i].a + k, sizeof(char) * Limit);\n        len += Limit, n -= Limit;\n        k = 0;\n    }\n    str[len] = '\\0';\n    puts(str);\n}\nvoid Rever(int l,int r)\n{\n    int idx=head;\n    Find(idx,l);\n    Split(idx,l);\n    int Start=idx,StartNxt=B[idx].nxt;\n    idx=head;\n    Find(idx,r);\n    Split(idx,r);\n    int EndNxt=B[idx].nxt;\n    int Tmp[BlockNum],cnt=0;\n    for(int i=StartNxt;i!=EndNxt;i=B[i].nxt)\n        B[i].rev^=1,Tmp[++cnt]=i;\n    Tmp[++cnt]=Start;Tmp[0]=EndNxt;\n    for(int i=cnt;i>=1;i--)\n        B[Tmp[i]].nxt=Tmp[i-1];\n    Merge(head);\n}\nvoid Dele(int l,int r)\n{\n    int idx=head;\n    Find(idx,l);\n    Split(idx,l);\n    int Start=idx,StartNxt=B[idx].nxt;\n    idx=head;\n    Find(idx,r);\n    Split(idx,r);\n    int EndNxt=B[idx].nxt;\n    for(int i=StartNxt;i!=EndNxt;i=B[i].nxt)    Delet(i);\n    B[Start].nxt=EndNxt;\n    Merge(head);\n}\nint main()  \n{\n    #ifdef WIN32\n    freopen(\"a.in\",\"r\",stdin);\n    #else\n    #endif\n    int N;scanf(\"%d\",&N);\n    char opt[20];\n    Pre();\n    while(N--)\n    {\n        scanf(\"%s\",opt);\n        if(opt[0]=='M') \n            scanf(\"%d\",&Cur);\n        else if(opt[0]=='I')\n        {\n            int len;\n            scanf(\"%d\", &len);\n            int i = 0;\n            while(i < len) {char ch = getchar();if(ch >= 32 && ch <= 126) str[i++] = ch;}\n            str[i++]='\\0';\n            Insert(Cur,len,str);\n        }\n        else if(opt[0]=='D')\n        {\n            int x;\n            scanf(\"%d\",&x);\n            Dele(Cur,Cur+x);\n        }\n        else if(opt[0]=='R')\n        {\n            int x;\n            scanf(\"%d\",&x);\n            Rever(Cur,x+Cur);\n        }\n        else if(opt[0]=='G')    \n        {\n            int x;\n            scanf(\"%d\",&x);\n            Print(Cur,x,str);\n        }\n        else if(opt[0]=='P')    Cur--;\n        else if(opt[0]=='N')    Cur++;\n    }\n    return 0;\n}\n```",
        "postTime": 1513505233,
        "uid": 36984,
        "name": "attack",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]editor\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "~~\u6700\u8fd1\u597d\u4e45\u4e0d\u53d1blog\u4e86\uff0c\u611f\u89c9\u6709\u70b9\u9893\u5e9f\uff0c\u4e00\u76f4\u5728\u6253[$Slay One$](https://slay.one)\u3002\u3002\u3002~~\n\n### [\u539f\u9898\u63cf\u8ff0](https://www.luogu.org/problemnew/show/P4008)\n\n#### \u8fd9\u9898\u5f88\u5bb9\u6613\u5730\u73c2\u4ee5\u60f3\u5230\u76f4\u63a5\u6a21\u62df\u80af\u5b9a\u8fc7\u4e0d\u53bb\uff08\u6bd5\u7adf\u662f\u4e00\u4e2a\u7d2b\u9898\u4e48\u3002\u3002\u3002\uff09\n\n### $\\color{red}\\text{\u4e8e\u662f\uff0c\u6211\u4eec\u73c2\u4ee5\u7528\u5e73\u8861\u6811\u7ef4\u62a4\uff08}$~~\u6ed1\u7a3d\uff0c\u770b\u795e\u4ed9\u4eec\u7684\u9898\u89e3\u7684~~$\\color{red}\\text{\uff09}$\n\n~~**\u795e\u4ed9\u4eec\u90fd\u7528$splay$\uff0c\u800c\u6211\u8fd9\u53ea\u849f\u84bb\u53ea\u4f1a\u975e\u65cb$treap$\u3002**~~\n\n**\u8003\u8651\u5230\u975e\u65cb$treap$\u7684\u666e\u901a$split$\u64cd\u4f5c\u7684\u4f9d\u636e\u662f\u5927\u5c0f\u5173\u7cfb\uff0c\u800c\u6211\u4eec\u73b0\u5728\u662f\u8981\u7ef4\u62a4\u5e8f\u5217\uff0c\u5728\u4f4d\u7f6e\u4e0a\u64cd\u4f5c\uff0c\u6240\u4ee5$split$\u64cd\u4f5c\u7684\u4f9d\u636e\u8981\u6539\u4e3a\u4f4d\u7f6e**\n\n##### \uff08\u539f\u5148\u7684$split$\uff09\uff1a\n```cpp\nvoid split(treap_node *now, value_type k, \n/*value*/   treap_node *&a, treap_node *&b) {\n  if (now == null) a = b = null;\n  else { // it isn't a null node\n    if (now -> val <= k) // in value\n      a = now, split(a -> ch[1], k, a -> ch[1], b);\n    else // split the right son of the left son of the node\n      b = now, split(b -> ch[0], k, a, b -> ch[0]);\n    // split the left son of the right son of the node\n    now -> pushup(); // pushup the node\n  } // split with value\n} // fhq treap split value\n```\n\n##### \uff08\u73b0\u5728\u7684$split$\uff09\uff1a\n```cpp\nvoid split(treap_node *now, int k, \n/*location*/treap_node *&a, treap_node *&b) {\n  if (now == null) a = b = null;\n  else { // it isn't a null node\n    if (now -> ch[0] -> size >= k) // in location\n      b = now, split(b -> ch[0], k, a, b -> ch[0]);\n    else // split the left son of the right son of the node\n      a = now, split(a -> ch[1], k - now -> ch[0] -> size - 1, a -> ch[1], b);\n    // split the right son of the left son of the node\n    now -> pushup(); // pushup the node\n  } // split with location\n} // fhq treap split location\n```\n\n###### ~~\u522b\u95ee\u6211\u90a3\u91cc\u6765\u7684\u8fd9\u4e48\u591a\u6ce8\u91ca\uff0c\u6211\u53ea\u662f\u6572\u4e60\u60ef\u4e86\u800c\u5df2\uff01\uff01~~\n\n**\u63a5\u7740\uff0c\u8fd8\u8981\u518d\u8003\u8651$Insert$\u65f6\u5019\u5982\u4f55\u4f5c\u3002**\n\n#### **\u73c2\u4ee5\u7528\u4e00\u4e2a\u6808\u7ef4\u62a4\u3002\u5982\u679c\u5f53\u524d\u63d2\u5165\u7684\u8282\u70b9\u7684\u4fee\u6b63\u503c\u5c0f\u4e8e\u6808\u9876\u7aef\u7684\u8282\u70b9\u7684\u4fee\u6b63\u503c\u7684\u8bdd\uff0c\u5c31\u5f39\u51fa\u6808\u9876\u7aef\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u8fdb\u884c\u4e0a\u63a8\u3002**\n\n**\u628a\u5f53\u524d\u8282\u70b9\u63d2\u5165\u8fdb\u53bb\u4e4b\u540e\uff0c\u6700\u540e\u4ece\u6808\u7684\u9876\u7aef\u5230\u6808\u5c3e\u4e00\u76f4\u4e0a\u63a8\uff0c\u6700\u540e\u7684\u4e00\u4e2a\u8282\u70b9\u4ee3\u8868\u8fd9\u4e2a\u533a\u95f4\u7684\u5b50\u6811\uff0c\u6700\u540e\u5728\u63d2\u5165\u5230\u975e\u65cb$treap$\u5185\u90e8\u3002**\n\n###### ~~\u81f3\u6b64\uff0c\u8fd9\u9053\u9898\u5927\u529f\u544a\u6210\uff01\uff01~~\n\n#### \u6700\u540e\u653e\u4e00\u4e0b\u6211\u7684~~\u53c8\u4e11\u53c8\u957f~~\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define Maxn 3 << 20 | 5\n\n#ifdef ONLINE_JUDGE\nstatic char _in_buf[100000], *_in_p1 = _in_buf, *_in_p2 = _in_buf;\n#define getchar() (_in_p1 == _in_p2 && (_in_p2 = (_in_p1 = _in_buf) + fread(_in_buf, 1, 100000, stdin), _in_p1 == _in_p2) ? EOF : *_in_p1 ++)\n#endif\ninline int read() {\n  int now = 0, f = 0; register char c = getchar();\n  while ((c < 48 || c > 57) && ~c && c != '-') c = getchar();\n  if (!~c) throw ~0; (c == '-') && ((f = 1), c = getchar());\n  for (; c > 47 && c < 58; now = (now << 3) + (now << 1) + c - '0', c = getchar());\n  return f ? -now : now;\n} // fast reader\n\ntypedef char value_type;\nstruct treap_node {\n  treap_node *ch[2];\n  int size, fix;\n  value_type val;\n  ~treap_node();\n  treap_node(value_type v);\n  inline void pushup() {\n    size = ch[0] -> size + ch[1] -> size + 1;\n  } // push from down to up\n} *null = new treap_node(0), *root;\ntreap_node :: treap_node(value_type k = 0) {\n  val = k, fix = rand();\n  size = 1, ch[0] = ch[1] = null;\n} // construct function\ntreap_node :: ~treap_node() {\n  if (ch[0] != null) delete ch[0];\n  if (ch[1] != null) delete ch[1];\n  if (this != null) delete this;\n} // explict function\nstruct __INIT_ROOT__ {\n  __INIT_ROOT__() {\n    srand(time(NULL));\n    null -> size = 0, root = null;\n  } // init the treap\n} __init_root__;\ntreap_node *merge(treap_node *a, treap_node *b) {\n  if (a == null) return b;\n  if (b == null) return a;\n  if (a -> fix < b -> fix) {\n    a -> ch[1] = merge(a -> ch[1], b);\n    a -> pushup(); return a;\n  } else { // random merge\n    b -> ch[0] = merge(a, b -> ch[0]);\n    b -> pushup(); return b;\n  } // merge with random value\n} // fhq treap merge\nvoid split(treap_node *now, int k, \n/*location*/treap_node *&a, treap_node *&b) {\n  if (now == null) a = b = null;\n  else { // it isn't a null node\n    if (now -> ch[0] -> size >= k) // in location\n      b = now, split(b -> ch[0], k, a, b -> ch[0]);\n    else // split the left son of the right son of the node\n      a = now, split(a -> ch[1], k - now -> ch[0] -> size - 1, a -> ch[1], b);\n    // split the right son of the left son of the node\n    now -> pushup(); // pushup the node\n  } // split with location\n} // fhq treap split location\nvoid print_treap(treap_node *p) {\n  if (p == null) return;\n  print_treap(p -> ch[0]); // print left son\n  putchar(p -> val); // print now value\n  print_treap(p -> ch[1]); // print right son\n} // print the sequence\n\ntreap_node *stk[Maxn]; // stack we used in insert\nint top, pos = 0; // stack top and position\nint main() {\n  for (int q = read(), x; q --; ) {\n    register char ch, op;\n    while ((ch = getchar()) <= 32 || ch > 126);\n    for (op = ch; (ch = getchar()) > 32 && ch < 127; );\n    if (op == 'I') { // Insert operation\n      for (x = read(), top = 0; x --; ) {\n        while ((ch = getchar()) < 32 || ch > 126);\n        treap_node *tmp = new treap_node(ch), *last = null;\n        while (top && tmp -> fix < stk[top] -> fix) // find the node to have the greater fix value\n          stk[top] -> pushup(), last = stk[top], stk[top --] = null;\n        if (top) stk[top] -> ch[1] = tmp; // if it isn't empty\n        tmp -> ch[0] = last, stk[++ top] = tmp; // prev link and next link\n      } while (top) stk[top --] -> pushup(); // pushup operation\n      treap_node *a, *b; split(root, pos, a, b); // split in pos-th\n      root = merge(merge(a, stk[1]), b); // insert and merge\n    } else if (op == 'M') pos = read();\n    else if (op == 'P') -- pos;\n    else if (op == 'N') ++ pos;\n    else if (op == 'D') { // Delete operation\n      treap_node *a, *b, *c;\n      split(root, pos, a, b); // split the pos-th \n      split(b, read(), b, c); // split the next k-th\n      root = merge(a, c); // delete and merge\n    } else if (op == 'G') {\n      treap_node *a, *b, *c;\n      split(root, pos, a, b); // split in pos-th\n      split(b, read(), b, c); // split in k-th\n      print_treap(b), putchar('\\n'); // print in recursion\n      root = merge(merge(a, b), c); // merge originally\n    } else throw \"Bad operation!!\"; // Debug\n  }\n  return 0;\n}\n```\n\n\n**\u5982\u679c\u795e\u4ed9\u4eec\u8fd8\u89c9\u5f97\u8fd9\u9898\u592a\u6c34\u4e86\uff0c\u73c2\u4ee5\u53bb\u5c1d\u8bd5[\u8fd9\u9898](https://www.luogu.org/problemnew/show/P4567)**",
        "postTime": 1554297924,
        "uid": 114495,
        "name": "libra9z",
        "ccfLevel": 0,
        "title": "LuoguP4008"
    },
    {
        "content": "\u8fd9\u9898\u6bd4[P4567 [AHOI2006]\u6587\u672c\u7f16\u8f91\u5668](https://www.luogu.org/problemnew/show/P4567)\u5c11\u4e86\u4e00\u4e2a\u53cd\u8f6c\uff0c\u4e0d\u8fc7\u8f93\u5165\u683c\u5f0f\u6b63\u5e38\u4e86\u4e00\u4e9b\u3002\n\n\u65e2\u7136\u6ca1\u4eba\u7ed9fhq\u7684\u9898\u89e3\u6211\u5c31\u6765\u5199\u4e00\u7bc7\u5427\u3002\n\n\u7ecf\u5178\u7684fhq\u533a\u95f4\u64cd\u4f5c\uff0c\u611f\u89c9\u5e38\u6570\u5f88\u5927QwQ\u3002\n\n\u9664\u6389\u4e00\u5768\u5feb\u8bfb\uff0c\u6211\u7684\u7801\u98ce\u5e94\u8be5\u8fd8\u7b97\u53ef\u4ee5\u7684QwQ\n\n\u6b22\u8fce\u6765\u6211\u7684\u535a\u5ba2\u5b66fhq treap\n\n[fhq treap\u6559\u7a0b](https://3088482189.github.io/2018/12/29/1/)\n```cpp\n#include<bits/stdc++.h>\nnamespace ZDY{\n    #pragma GCC optimize(3)\n    #define il __inline__ __attribute__ ((always_inline))\n    #define rg register\n    #define ll long long\n    #define db double\n    #define sht short\n    #define MB template <class T>\n    #define Fur(i,x,y) for(int i=x;i<=y;i++)\n    #define Fdr(i,x,y) for(int i=x;i>=y;i--)\n    #define fl(i,x) for(int i=head[x],to;to=e[i].to,i;i=e[i].nxt)\n    #define clr(x,y) memset(x,y,sizeof(x))\n    #define cpy(x,y) memcpy(x,y,sizeof(x))\n    #define fin(s) freopen(s\".in\",\"r\",stdin)\n    #define fout(s) freopen(s\".out\",\"w\",stdout)\n    #define fcin ios::sync_with_stdio(false)\n    #define l2(n) (int(log2(n)))\n    #define inf 0x3f3f3f3f\n    MB T ABS(T x){return x>0?x:-x;}\n    MB T MAX(T x,T y){return x>y?x:y;}\n    MB T MIN(T x,T y){return x<y?x:y;}\n    MB T GCD(T x,T y){return y?GCD(y,x%y):x;}\n    MB void SWAP(T &x,T &y){T t=x;x=y;y=t;}\n}using namespace ZDY;using namespace std;\nnamespace IO{const char* ln=\"\\n\";const int str=1<<20;struct IN{char buf[str],*s,*t;bool _;IN():s(buf),t(buf),_(0){}il char gc(){return s==t&&((t=(s=buf)+fread(buf,1,str,stdin))==s)?EOF:(*s++);}IN&operator>>(char&ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)_=1;else ch=c;return *this;}IN& operator>>(char* ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;*ch=c;ch++;while((c=gc())!=EOF&&!isspace(c))*ch=c,ch++;if(c==EOF)_=1;return *this;}IN& operator>>(string& ch){if(_)return *this;char c;while((c=gc())!=EOF&&isspace(c));if(c==EOF)return _=1,*this;ch+=c;while((c=gc())!=EOF&&!isspace(c))ch+=c;if(c==EOF)_=1;return *this;}template<typename T>IN&operator>>(T&x){if(_)return *this;char c=gc();bool ff=0;while(c!=EOF&&(c<'0'||c>'9'))ff^=(c=='-'),c=gc();if(c==EOF){_=1;return *this;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=(x<<3)+(x<<1)+c-48,c=gc();if(c==EOF)_=1;if(ff)x=-x;return *this;}}in;struct OUT{char buf[str],*s,*t;OUT():s(buf),t(buf+str){}~OUT(){fwrite(buf,1,s-buf,stdout);}void pt(char c){(s==t)?(fwrite(s=buf,1,str,stdout),*s++=c):(*s++=c);}OUT&operator<<(const char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(char*s){while(*s)pt(*s++);return *this;}OUT&operator<<(string s){for(int i=0;s[i];i++)pt(s[i]);return *this;}template<typename T>OUT&operator<<(T x){if(!x)return pt('0'),*this;if(x<0)pt('-'),x=-x;char a[30],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');return *this;}}out;}using namespace IO;\n#define N 2100000\nint n,m;\n#define ls c[rt][0]\n#define rs c[rt][1]\nint sz[N],rnd[N],rev[N],c[N][2],RT,cnt,POS=0;\nchar val[N];\nint ra(){static int seed=233;return seed=(int)seed*482711LL%2147483647;}\nil void pu(int rt){sz[rt]=sz[ls]+sz[rs]+1;}\nil void pd(int rt){\n    if(rev[rt]){\n        SWAP(ls,rs);\n        rev[ls]^=1;rev[rs]^=1;\n        rev[rt]=0;\n    }\n}\nint ne(char v){\n    val[++cnt]=v;\n    sz[cnt]=1;rnd[cnt]=ra();\n    return cnt;\n}\nvoid sl(int rt,int k,int &x,int &y){\n    if(!rt){x=y=0;return;}\n    pd(rt);\n    if(sz[ls]>=k)y=rt,sl(ls,k,x,ls);\n    else x=rt,sl(rs,k-sz[ls]-1,rs,y);\n    pu(rt);\n}\nint mg(int x,int y){\n    if(!x||!y)return x+y;\n    pd(x);pd(y);\n    if(rnd[x]<rnd[y]){\n        c[x][1]=mg(c[x][1],y);\n        pu(x);\n        return x;\n    }\n    else{\n        c[y][0]=mg(x,c[y][0]);\n        pu(y);\n        return y;\n    }\n}\nvoid dfs(int rt){\n    if(!rt)return;\n    pd(rt);\n    dfs(ls);out.pt(val[rt]);dfs(rs);\n}\nint main(){\n    in>>n;\n    char opt[10];\n    int len,x,y,z;\n    while(n--){\n        in>>opt;\n        if(opt[0]=='M')in>>POS;\n        if(opt[0]=='I'){\n            in>>len;\n            sl(RT,POS,x,y);\n            Fur(i,1,len){\n                char ch=in.gc();\n                while(ch<32||ch>126)ch=in.gc();\n                x=mg(x,ne(ch));\n            }\n            RT=mg(x,y);\n        }\n        if(opt[0]=='R'){\n            in>>len;\n            sl(RT,POS+len,x,z);sl(x,POS,x,y);\n            rev[y]^=1;\n            RT=mg(x,mg(y,z));\n        }\n        if(opt[0]=='D'){\n            in>>len;\n            sl(RT,POS+len,x,z);sl(x,POS,x,y);\n            RT=mg(x,z);\n        }\n        if(opt[0]=='G'){\n            in>>len;\n            sl(RT,POS+len,x,z);sl(x,POS,x,y);\n            dfs(y);out<<ln;\n            RT=mg(x,mg(y,z));\n        }\n        if(opt[0]=='P')POS--;\n        if(opt[0]=='N')POS++;\n    }\n}\n\n```\n",
        "postTime": 1554899757,
        "uid": 36532,
        "name": "localhost",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "\u7528\u5757\u72b6\u94fe\u8868\u5373\u53ef\u3002\n```cpp\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n//#define gc() getchar()\n#define MAXIN 100000\n#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)\nconst int N=1024*1024*2+5;\nconst int MaxSize=/*1700*/4500,MaxNum=/*1700*2*/N*2/MaxSize+100;\n\nint num,nxt[MaxNum],sz[MaxNum],pool[MaxNum];\nchar data[MaxNum][MaxSize],str[N],IN[MAXIN],*SS=IN,*TT=IN;\n\ninline int read() {\n\tint now=0,f=1;\n\tregister char c=gc();\n\tfor(; !isdigit(c); c=gc()) if(c=='-') f=-1;\n\tfor(; isdigit(c); now=now*10+c-'0',c=gc());\n\treturn now*f;\n}\n\ninline int New_Block() {\n\treturn pool[++num];\n}\ninline void Del_Block(int v) {\n\tpool[num--]=v;\n}\nvoid Init() {\n\tfor(int i=1; i<MaxNum; ++i) pool[i]=i;\n\tsz[0]=0, nxt[0]=-1;//\u65b0\u5efa\u4e00\u4e2a0\u8282\u70b9\uff0c\u65b9\u4fbf \u8868\u5934\u5c31\u662f0\n}\nvoid Merge(int cur,int Nxt) {\n\tmemcpy(data[cur]+sz[cur],data[Nxt],sz[Nxt]);\n\tnxt[cur]=nxt[Nxt], sz[cur]+=sz[Nxt];\n\tDel_Block(Nxt);\n}\nvoid Maintain() {\n\tfor(int cur=0,Nxt=nxt[0]; ~cur; cur=nxt[cur],Nxt=nxt[cur])\n\t\twhile((~Nxt) && sz[cur]+sz[Nxt]<=MaxSize)\n\t\t\tMerge(cur,Nxt), Nxt=nxt[cur];//\u6700\u597d\u4e0d\u7528nxt[Nxt]\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5408\u5e76\u3001\u5220\u6389\u4e86\uff0c\u867d\u7136\u4e0d\u5f71\u54cd\u7b54\u6848\uff0c\u4f46\u8fd8\u662f\u4e0d\u8be5\u5199\n}\nint Get_Index(int &pos) { //\u627e\u5230pos\u6240\u5728\u7684\u5757\uff0c\u5e76\u5c06pos\u5b9a\u4f4d\u4e3a\u5757\u5185\u4f4d\u7f6e\n\tint cur=0;\n\twhile((~cur) && pos>sz[cur])//\u628acur\u5b9a\u4f4d\u5230\u67d0\u4e00\u5757\u7684\u672b\u5c3e\uff0c\u4e0d\u7528\u4e0b\u4e00\u5757\u5f00\u5934\u4e86(pos>=sz)\n\t\tpos-=sz[cur], cur=nxt[cur];\n\treturn cur;\n}\nvoid Update(int cur,int Nxt,int len,char *s) { //\u7ed9\u65b0\u7684\u5757Nxt\u8bbe\u7f6e\u6570\u636e\u53ca\u6307\u9488\n\tnxt[Nxt]=nxt[cur], nxt[cur]=Nxt, sz[Nxt]=len;\n\tmemcpy(data[Nxt],s,len);\n}\nvoid Split(int cur,int pos) {\n\tif(cur==-1||pos==sz[cur]) return;//\u4e0d\u80fd\u5224!pos\uff01\u56e0\u4e3a\u540e\u8fb9\u4f1a\u76f4\u63a5\u7528nxt[cur]\uff0c\u4e0d\u5206\u88c2\u4f1a\u8df3\u8fc7\u8be5\u5757\uff1b\u800c\u5728=sz\u65f6\u4e0d\u5206\u662f\u6ca1\u95ee\u9898\u7684\n\tint Nxt=New_Block();\n\tUpdate(cur,Nxt,sz[cur]-pos,data[cur]+pos);\n\tsz[cur]=pos;\n}\nvoid Insert(int pos,int len) {\n\tint cur=Get_Index(pos),sum=0,Nxt;\n\tSplit(cur,pos);\n\twhile(sum+MaxSize<=len) {\n\t\tNxt=New_Block();\n\t\tUpdate(cur,Nxt,MaxSize,str+sum);//\u5148\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u6574\u5757\n\t\tsum+=MaxSize, cur=Nxt;\n\t}\n\tif(len-sum)//\u5269\u4f59\u7684\u5355\u72ec\u653e\u5230\u4e00\u5757\n\t\tNxt=New_Block(), Update(cur,Nxt,len-sum,str+sum);\n\tMaintain();\n}\nvoid Erase(int pos,int len) {\n\tint cur=Get_Index(pos),Nxt;\n\tSplit(cur,pos);\n\tNxt=nxt[cur];//because of here\n\twhile((~Nxt) && len>sz[Nxt])\n\t\tlen-=sz[Nxt], Del_Block(Nxt), Nxt=nxt[Nxt];\n\tSplit(Nxt,len);\n\tDel_Block(Nxt), nxt[cur]=nxt[Nxt];\n\tMaintain();\n}\nvoid Get_Data(int pos,int len) {\n\tint cur=Get_Index(pos),sum=sz[cur]-pos;\n\tif(len<sum) sum=len;\n\tmemcpy(str,data[cur]+pos,sum);\n\tcur=nxt[cur];\n\twhile((~cur) && sum+sz[cur]<=len)\n\t\tmemcpy(str+sum,data[cur],sz[cur]), sum+=sz[cur] ,cur=nxt[cur];\n\tif((~cur) && len-sum)\n\t\tmemcpy(str+sum,data[cur],len-sum);\n\tstr[len]='\\0';\n\tprintf(\"%s\\n\",str);\n}\ninline char Get_opt() {\n\tregister char c=gc();\n\twhile(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=gc();\n\treturn c;\n}\n\nint main() {\n\tInit();\n\tint t=read(),pos=0,len;\n\tchar s[10];\n\twhile(t--) {\n\t\tswitch(Get_opt()) {\n\t\t\tcase 'M':\n\t\t\t\tpos=read();\n\t\t\t\tbreak;\n\t\t\tcase 'I':\n\t\t\t\tlen=read();\n\t\t\t\tfor(int i=0; i<len; ++i) {\n\t\t\t\t\tstr[i]=gc();\n\t\t\t\t\tif(str[i]<32||str[i]>126) --i;\n\t\t\t\t}\n\t\t\t\tInsert(pos,len);\n\t\t\t\tbreak;\n\t\t\tcase 'D':\n\t\t\t\tlen=read(),Erase(pos,len);\n\t\t\t\tbreak;\n\t\t\tcase 'G':\n\t\t\t\tlen=read(),Get_Data(pos,len);\n\t\t\t\tbreak;\n\t\t\tcase 'P':\n\t\t\t\t--pos;\n\t\t\t\tbreak;\n\t\t\tcase 'N':\n\t\t\t\t++pos;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n",
        "postTime": 1555144885,
        "uid": 193541,
        "name": "\u7f9a\u7f8aWANG",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    },
    {
        "content": "# \u5757\u72b6\u94fe\u8868\u53ca\u5176\u5e94\u7528\n\n\u601d\u8def\u697c\u4e0a\u5df2\u7ecf\u8bf4\u7684\u5f88\u6e05\u695a\u4e86\n\n\u770b\u4ee3\u7801\u6ce8\u91ca\n\n\u4ee3\u7801\u5f88\u4e11\n\n```\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n//#define gc() getchar()\n#define MAXIN 100000\n#define gc() (SS==TT&&(TT=(SS=IN)+fread(IN,1,MAXIN,stdin),SS==TT)?EOF:*SS++)\nconst int N=1024*1024*2+5;\nconst int MaxSize=/*1700*/4500,MaxNum=/*1700*2*/N*2/MaxSize+100;\n\nint num,nxt[MaxNum],sz[MaxNum],pool[MaxNum];\nchar data[MaxNum][MaxSize],str[N],IN[MAXIN],*SS=IN,*TT=IN;\n\ninline int read() {\n    int now=0,f=1;\n    register char c=gc();\n    for(; !isdigit(c); c=gc()) if(c=='-') f=-1;\n    for(; isdigit(c); now=now*10+c-'0',c=gc());\n    return now*f;\n}\n\ninline int New_Block() {\n    return pool[++num];\n}\ninline void Del_Block(int v) {\n    pool[num--]=v;\n}\nvoid Init() {\n    for(int i=1; i<MaxNum; ++i) pool[i]=i;\n    sz[0]=0, nxt[0]=-1;//\u65b0\u5efa\u4e00\u4e2a0\u8282\u70b9\uff0c\u65b9\u4fbf \u8868\u5934\u5c31\u662f0\n}\nvoid Merge(int cur,int Nxt) {\n    memcpy(data[cur]+sz[cur],data[Nxt],sz[Nxt]);\n    nxt[cur]=nxt[Nxt], sz[cur]+=sz[Nxt];\n    Del_Block(Nxt);\n}\nvoid Maintain() {\n    for(int cur=0,Nxt=nxt[0]; ~cur; cur=nxt[cur],Nxt=nxt[cur])\n        while((~Nxt) && sz[cur]+sz[Nxt]<=MaxSize)\n            Merge(cur,Nxt), Nxt=nxt[cur];//\u6700\u597d\u4e0d\u7528nxt[Nxt]\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5408\u5e76\u3001\u5220\u6389\u4e86\uff0c\u867d\u7136\u4e0d\u5f71\u54cd\u7b54\u6848\uff0c\u4f46\u8fd8\u662f\u4e0d\u8be5\u5199\n}\nint Get_Index(int &pos) { //\u627e\u5230pos\u6240\u5728\u7684\u5757\uff0c\u5e76\u5c06pos\u5b9a\u4f4d\u4e3a\u5757\u5185\u4f4d\u7f6e\n    int cur=0;\n    while((~cur) && pos>sz[cur])//\u628acur\u5b9a\u4f4d\u5230\u67d0\u4e00\u5757\u7684\u672b\u5c3e\uff0c\u4e0d\u7528\u4e0b\u4e00\u5757\u5f00\u5934\u4e86(pos>=sz)\n        pos-=sz[cur], cur=nxt[cur];\n    return cur;\n}\nvoid Update(int cur,int Nxt,int len,char *s) { //\u7ed9\u65b0\u7684\u5757Nxt\u8bbe\u7f6e\u6570\u636e\u53ca\u6307\u9488\n    nxt[Nxt]=nxt[cur], nxt[cur]=Nxt, sz[Nxt]=len;\n    memcpy(data[Nxt],s,len);\n}\nvoid Split(int cur,int pos) {\n    if(cur==-1||pos==sz[cur]) return;//\u4e0d\u80fd\u5224!pos\uff01\u56e0\u4e3a\u540e\u8fb9\u4f1a\u76f4\u63a5\u7528nxt[cur]\uff0c\u4e0d\u5206\u88c2\u4f1a\u8df3\u8fc7\u8be5\u5757\uff1b\u800c\u5728=sz\u65f6\u4e0d\u5206\u662f\u6ca1\u95ee\u9898\u7684\n    int Nxt=New_Block();\n    Update(cur,Nxt,sz[cur]-pos,data[cur]+pos);\n    sz[cur]=pos;\n}\nvoid Insert(int pos,int len) {\n    int cur=Get_Index(pos),sum=0,Nxt;\n    Split(cur,pos);\n    while(sum+MaxSize<=len) {\n        Nxt=New_Block();\n        Update(cur,Nxt,MaxSize,str+sum);//\u5148\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u6574\u5757\n        sum+=MaxSize, cur=Nxt;\n    }\n    if(len-sum)//\u5269\u4f59\u7684\u5355\u72ec\u653e\u5230\u4e00\u5757\n        Nxt=New_Block(), Update(cur,Nxt,len-sum,str+sum);\n    Maintain();\n}\nvoid Erase(int pos,int len) {\n    int cur=Get_Index(pos),Nxt;\n    Split(cur,pos);\n    Nxt=nxt[cur];//because of here\n    while((~Nxt) && len>sz[Nxt])\n        len-=sz[Nxt], Del_Block(Nxt), Nxt=nxt[Nxt];\n    Split(Nxt,len);\n    Del_Block(Nxt), nxt[cur]=nxt[Nxt];\n    Maintain();\n}\nvoid Get_Data(int pos,int len) {\n    int cur=Get_Index(pos),sum=sz[cur]-pos;\n    if(len<sum) sum=len;\n    memcpy(str,data[cur]+pos,sum);\n    cur=nxt[cur];\n    while((~cur) && sum+sz[cur]<=len)\n        memcpy(str+sum,data[cur],sz[cur]), sum+=sz[cur] ,cur=nxt[cur];\n    if((~cur) && len-sum)\n        memcpy(str+sum,data[cur],len-sum);\n    str[len]='\\0';\n    printf(\"%s\\n\",str);\n}\ninline char Get_opt() {\n    register char c=gc();\n    while(c!='M'&&c!='I'&&c!='D'&&c!='G'&&c!='P'&&c!='N') c=gc();\n    return c;\n}\n\nint main() {\n    Init();\n    int t=read(),pos=0,len;\n    char s[10];\n    while(t--) {\n        switch(Get_opt()) {\n            case 'M':\n                pos=read();\n                break;\n            case 'I':\n                len=read();\n                for(int i=0; i<len; ++i) {\n                    str[i]=gc();\n                    if(str[i]<32||str[i]>126) --i;\n                }\n                Insert(pos,len);\n                break;\n            case 'D':\n                len=read(),Erase(pos,len);\n                break;\n            case 'G':\n                len=read(),Get_Data(pos,len);\n                break;\n            case 'P':\n                --pos;\n                break;\n            case 'N':\n                ++pos;\n                break;\n        }\n    }\n    return 0;\n}\n```\n[\u53ef\u4ee5\u770b\u770b\u8fd9\u9053\u9898](https://wenku.baidu.com/view/217f2d66ddccda38376baf67.html)",
        "postTime": 1555239321,
        "uid": 113900,
        "name": "jbc392",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4008 \u3010[NOI2003]\u6587\u672c\u7f16\u8f91\u5668\u3011"
    }
]