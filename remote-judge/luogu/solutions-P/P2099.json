[
    {
        "content": "\u7b80\u8981\u65b9\u6cd5\uff1a\u722c\u5c71+\u7f51\u7edc\u6d41\n\n\u9996\u5148\uff0c\u5982\u679c\u6240\u6709\u58eb\u5175\u4e0d\u52a8\uff0c\u6574\u4e2a\u56fe\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\uff0c\u5bf9\u5b83\u505a\u6700\u5c0f\u5272\u6c42\u51fa\u54ea\u4e9b\u4f4d\u7f6e\u9700\u8981\u62e6\u4f4f\uff0c\u7136\u540e\u518d\u4ee5\u58eb\u5175\u4e3a\u5de6\u4fa7\u70b9\u3001\u9700\u8981\u62e6\u4f4f\u7684\u4f4d\u7f6e\u4e3a\u53f3\u4fa7\u70b9\u8dd1\u8d39\u7528\u6d41\uff0c\u5373\u53ef\u6c42\u51fa\u4e00\u4e2a\u5c40\u90e8\u6700\u4f18\u89e3\u3002\n\n\u4f46\u662f\u8fd9\u4e2a\u89e3\u5e76\u4e0d\u4e00\u5b9a\u662f\u6700\u4f18\u7684\uff0c\u56e0\u4e3a\u6700\u5c0f\u5272\u5e76\u4e0d\u4e00\u5b9a\u662f\u6700\u4f18\u89e3\uff08\u8d39\u7528\u6d41\u8dd1\u51fa\u6765\u7684\u4e00\u5b9a\u662f\u6700\u4f18\u89e3\uff09\uff0c\u6240\u4ee5\u8003\u8651\u5982\u4f55\u6c42\u9700\u8981\u62e6\u4f4f\u7684\u4f4d\u7f6e\u624d\u80fd\u4f7f\u5f97\u7b54\u6848\u66f4\u4f18\u3002\n\n\u6ce8\u610f\u5230\u524d\u9762\u6211\u4eec\u662f\u9ed8\u8ba4\u6240\u6709\u58eb\u5175\u5728\u7684\u683c\u5b50\u5df2\u7ecf\u88ab\u62e6\u4f4f\u540e\u8dd1\u7684\u6700\u5c0f\u5272\uff0c\u4e3a\u4e86\u627e\u51fa\u5176\u5b83\u65b9\u6848\uff0c\u6211\u4eec\u9009\u62e9\u4e00\u4e9b\u58eb\u5175\uff0c\u7136\u540e\u5728\u8dd1\u6700\u5c0f\u5272\u65f6\u5ffd\u7565\u8fd9\u4e9b\u58eb\u5175\uff08\u5373\u9ed8\u8ba4\u4ed6\u4eec\u6240\u5728\u7684\u683c\u5b50\u662f\u7a7a\u5730\uff09\u3002\n\n\u9009\u58eb\u5175\u7684\u65b9\u6848\u5e76\u6ca1\u6709\u660e\u786e\u7684\u6700\u4f18\u89e3\uff0c\u56e0\u6b64\u6211\u4eec\u7528\u722c\u5c71\u6765\u89e3\u51b3\u3002\n\n\u8fd9\u79cd\u65b9\u6cd5\u80fd\u901a\u8fc7 1\u30012\u30016\u30017\u300110 \u53f7\u70b9\uff0c\u5bf9\u4e8e 3\u30014\u30015\u30019 \u53f7\u70b9\uff0c\u5ffd\u7565\u6240\u6709\u58eb\u5175\u7528\u4e0a\u8ff0\u65b9\u6cd5\u5c31\u80fd\u901a\u8fc7\uff0c\u5bf9\u4e8e 8 \u53f7\u70b9\uff0c\u6211\u4eec\u624b\u73a9\u4e00\u4e0b\uff0c\u627e\u51fa\u54ea\u4e9b\u7a7a\u683c\u4e0d\u80fd\u9009\u5373\u53ef\u3002\n\n\u4ee3\u7801\u57fa\u672c\u76f8\u540c\uff1a\n\n1\u30012\u30016\u30017\u300110\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int N=105,N2=105,P=3*N*N2+5,M=1e7+5,inf=1e9;\nchar s[N][N2],ss[N][N2],tt[N][N2];\nint n,m;\nint fst[P],cur[P],nxt[M],u[M],v[M],flow[M],w[M],tot=1;\nint que[P],dis[P],h,t,S=P-1,T=P-2;\nint bk[P],vis[P];\nint ch[N][N2];\nint inq[P],a[P],pre[P];\nqueue<int> q;\nint pp,qq;\nbool dl[N][N2],Dl[N][N2];\nvoid add(int lu,int lv,int lf,int lw=0)\n{\n\tu[++tot]=lu,v[tot]=lv,flow[tot]=lf,w[tot]=lw,nxt[tot]=fst[lu],fst[lu]=tot;\n\tu[++tot]=lv,v[tot]=lu,flow[tot]=0,w[tot]=-lw,nxt[tot]=fst[lv],fst[lv]=tot;\n}\nint d(int r,int c,int id) {return (r-1)*m+c+n*m*id;}\nbool bfs()\n{\n\tmemset(dis,0x3f,sizeof(dis)),dis[S]=0,que[h=t=1]=S;\n\twhile(h<=t)\n\t\tfor(int i=que[h++],j=fst[i];j;j=nxt[j])\n\t\t\tif(flow[j]&&dis[v[j]]>dis[i]+1) dis[v[j]]=dis[i]+1,que[++t]=v[j];\n\treturn dis[T]<inf;\n}\nint dfs(int x,int lw,int tt=T)\n{\n\tif(x==tt) return lw;\n\tint res=0,zl;\n\tfor(int &i=cur[x];i;i=nxt[i])\n\t\tif(flow[i]&&dis[v[i]]==dis[x]+1&&(zl=dfs(v[i],min(lw,flow[i]),tt)))\n\t\t{\n\t\t\tlw-=zl,flow[i]-=zl,res+=zl,flow[i^1]+=zl;\n\t\t\tif(!lw) return res;\n\t\t}\n\treturn res;\n}\nint dinic() {int res=0; while(bfs()) memcpy(cur,fst,sizeof(cur)),res+=dfs(S,inf); return res;}\nvoid bfs(int x)\n{\n\tbk[x]=1;\n\tfor(int i=fst[x];i;i=nxt[i])\n\t\tif(!bk[v[i]]&&flow[i]) bfs(v[i]);\n}\nbool ade()\n{\n\tint i,j;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tif(s[i][j]!='#'||dl[i][j]) add(d(i,j,0),d(i,j,1),s[i][j]!='O'? 1:inf);\n\t\t\ti<n&&(add(d(i,j,1),d(i+1,j,0),inf),add(d(i+1,j,1),d(i,j,0),inf),0),\n\t\t\tj<m&&(add(d(i,j,1),d(i,j+1,0),inf),add(d(i,j+1,1),d(i,j,0),inf),0),\n\t\t\ts[i][j]=='O'&&(add(S,d(i,j,0),inf),0);\n\t\t}\n\tfor(i=1;i<=n;i++) add(d(i,1,1),T,inf),add(d(i,m,1),T,inf);\n\tfor(i=2;i<m;i++) add(d(1,i,1),T,inf),add(d(n,i,1),T,inf);\n\tint R=dinic();\n\tif(R>=inf) return memset(fst,0,sizeof(fst)),tot=1,0;\n\tmemset(bk,0,sizeof(bk)),bfs(S);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t\tif(bk[d(i,j,0)]&&!bk[d(i,j,1)]) ch[i][j]=1;\n\t\t\telse ch[i][j]=0;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\treturn 1;\n}\nint vs[N][N];\nvoid adeg(int r,int c,int sr,int sc)\n{\n\tvs[r][c]=d(sr,sc,0);\n\tif(ch[r][c]) add(d(sr,sc,0),d(r,c,1),1,abs(sr-r)+abs(sc-c));\n\tif(abs(r-sr)+abs(c-sc)>10) return;\n\tif(c<m&&vs[r][c+1]!=d(sr,sc,0)) adeg(r,c+1,sr,sc);\n\tif(c>1&&vs[r][c-1]!=d(sr,sc,0)) adeg(r,c-1,sr,sc);\n\tif(r<n&&vs[r+1][c]!=d(sr,sc,0)) adeg(r+1,c,sr,sc);\n\tif(r>1&&vs[r-1][c]!=d(sr,sc,0)) adeg(r-1,c,sr,sc);\n}\nint res,ans=inf;\nbool spfa()\n{\n\tmemset(dis,0x3f,sizeof(dis)),memset(inq,0,sizeof(inq)),q.push(S),dis[S]=0,inq[S]=1,a[S]=inf;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop(),inq[x]=0;\n\t\tfor(int i=fst[x];i;i=nxt[i])\n\t\t\tif(flow[i]&&dis[v[i]]>dis[x]+w[i])\n\t\t\t\tdis[v[i]]=dis[x]+w[i],pre[v[i]]=i,a[v[i]]=min(a[x],flow[i]),!inq[v[i]]&&(q.push(v[i]),inq[v[i]]=1);\n\t}\n\tif(dis[T]>inf) return 0;\n\tres+=dis[T]*a[T],pp+=a[T];\n\tfor(int i=T;i!=S;i=u[pre[i]]) flow[pre[i]]-=a[T],flow[pre[i]^1]+=a[T];\n\treturn 1;\n}\nint Cl;\nstruct aa\n{\n\tint x1,y1,x2,y2;\n}as[P];\nstack<aa> st;\n#define XX if(ss[x2][y2]=='#') while(!st.empty()) as[++Cl]=st.top(),st.pop();\nvoid walk(int x1,int y1,int x2,int y2)\n{\n\tif(x1==x2&&y1==y2) return;\n\tss[x2][y2]='#';\n\twhile(y2>y1) {st.push(aa{x2,y2-1,x2,y2}),y2--;XX}\n\twhile(x2>x1) {st.push(aa{x2-1,y2,x2,y2}),x2--;XX}\n\twhile(y2<y1) {st.push(aa{x2,y2+1,x2,y2}),y2++;XX}\n\twhile(x2<x1) {st.push(aa{x2+1,y2,x2,y2}),x2++;XX}\n\tss[x1][y1]='.';\n}\nvoid cal()\n{\n\tint i,j,li;\n\tif(ade())\n\t{\n\t\tpp=qq=0;\n\t\tmemset(vs,0,sizeof(vs));\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tif(s[i][j]=='#'&&!ch[i][j]) adeg(i,j,i,j),add(S,d(i,j,0),1,0);\n\t\tfor(i=1;i<=n;i++)\n\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\tif(ch[i][j]&&s[i][j]!='#') add(d(i,j,1),T,1,0),qq++;\n\t\tres=0;\n\t\twhile(spfa());\n\t\tif(res<ans&&qq==pp)\n\t\t{\n\t\t\tans=res,Cl=0;\n\t\t\tmemcpy(ss,s,sizeof(ss));\n\t\t\twhile(!st.empty()) st.pop();\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tif(ss[i][j]=='#')\n\t\t\t\t\t\tfor(li=fst[d(i,j,0)];li;li=nxt[li])\n\t\t\t\t\t\t\tif(!flow[li]&&v[li]!=S) walk(i,j,(v[li]-n*m-1)/m+1,(v[li]-n*m-1)%m+1);\n\t\t\tmemcpy(tt,ss,sizeof(tt));\n\t\t}\n\t}\n}\nvoid gt()\n{\n\tmemset(dl,0,sizeof(dl)),cal();\n\tcerr<<ans<<'\\n';\n\tfor(int t=1000;t>1;t*=0.99)\n\t{\n\t\tmemcpy(Dl,dl,sizeof(Dl));\n\t\tfor(int i=1;i<=t;i++)\n\t\t{\n\t\t\tint la=rand()%n+1,lb=rand()%m+1;\n\t\t\tdl[la][lb]^=1;\n\t\t}\n\t\tint lp=ans;\n\t\tif(cal(),lp==ans) memcpy(dl,Dl,sizeof(dl));\n\t\telse cerr<<ans<<'\\n';\n\t}\n}\nsigned main()\n{\n\tfreopen(\"surround10.in\",\"r\",stdin);\n\tfreopen(\"surround0.out\",\"w\",stdout);\n\tint i,j,li,lj;\n\tcin>>n>>m,srand(time(0));\n\tfor(i=1;i<=n;i++) scanf(\"%s\",s[i]+1);\n\tgt();\n//\tfor(i=1,cout<<'\\n';i<=n;i++,cout<<'\\n')\n//\t\tfor(j=1;j<=m;j++) cout<<tt[i][j];\n\tcout<<ans<<'\\n';\n\tfor(i=1;i<=Cl;i++) cout<<as[i].x1<<' '<<as[i].y1<<' '<<as[i].x2<<' '<<as[i].y2<<'\\n';\n\treturn 0;\n}\n```\n\n3\u30014\u30015\u30019\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int N=3005,N2=65,P=3*N*N2+5,M=1e7+5,inf=1e9;\nchar s[N][N2],ss[N][N2],tt[N][N2];\nint n,m;\nint fst[P],cur[P],nxt[M],u[M],v[M],flow[M],w[M],tot=1;\nint que[P],dis[P],h,t,S=P-1,T=P-2;\nint bk[P],vis[P];\nint ch[N][N2];\nint inq[P],a[P],pre[P];\nqueue<int> q;\nint pp,qq;\nvoid add(int lu,int lv,int lf,int lw=0)\n{\n\tu[++tot]=lu,v[tot]=lv,flow[tot]=lf,w[tot]=lw,nxt[tot]=fst[lu],fst[lu]=tot;\n\tu[++tot]=lv,v[tot]=lu,flow[tot]=0,w[tot]=-lw,nxt[tot]=fst[lv],fst[lv]=tot;\n}\nint d(int r,int c,int id) {return (r-1)*m+c+n*m*id;}\nbool bfs()\n{\n\tmemset(dis,0x3f,sizeof(dis)),dis[S]=0,que[h=t=1]=S;\n\twhile(h<=t)\n\t\tfor(int i=que[h++],j=fst[i];j;j=nxt[j])\n\t\t\tif(flow[j]&&dis[v[j]]>dis[i]+1) dis[v[j]]=dis[i]+1,que[++t]=v[j];\n\treturn dis[T]<inf;\n}\nint dfs(int x,int lw,int tt=T)\n{\n\tif(x==tt) return lw;\n\tint res=0,zl;\n\tfor(int &i=cur[x];i;i=nxt[i])\n\t\tif(flow[i]&&dis[v[i]]==dis[x]+1&&(zl=dfs(v[i],min(lw,flow[i]),tt)))\n\t\t{\n\t\t\tlw-=zl,flow[i]-=zl,res+=zl,flow[i^1]+=zl;\n\t\t\tif(!lw) return res;\n\t\t}\n\treturn res;\n}\nint dinic() {int res=0; while(bfs()) memcpy(cur,fst,sizeof(cur)),res+=dfs(S,inf); return res;}\nvoid bfs(int x)\n{\n\tbk[x]=1;\n\tfor(int i=fst[x];i;i=nxt[i])\n\t\tif(!bk[v[i]]&&flow[i]) bfs(v[i]);\n}\nbool ade()\n{\n\tint i,j;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tadd(d(i,j,0),d(i,j,1),s[i][j]!='O'? 1:inf);\n\t\t\ti<n&&(add(d(i,j,1),d(i+1,j,0),inf),add(d(i+1,j,1),d(i,j,0),inf),0),\n\t\t\tj<m&&(add(d(i,j,1),d(i,j+1,0),inf),add(d(i,j+1,1),d(i,j,0),inf),0),\n\t\t\ts[i][j]=='O'&&(add(S,d(i,j,0),inf),0);\n\t\t}\n\tfor(i=1;i<=n;i++) add(d(i,1,1),T,inf),add(d(i,m,1),T,inf);\n\tfor(i=2;i<m;i++) add(d(1,i,1),T,inf),add(d(n,i,1),T,inf);\n\tint R=dinic();\n\tif(R>=inf) return memset(fst,0,sizeof(fst)),tot=1,0;\n\tmemset(bk,0,sizeof(bk)),bfs(S);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t\tif(bk[d(i,j,0)]&&!bk[d(i,j,1)]) ch[i][j]=1;\n\t\t\telse ch[i][j]=0;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\treturn 1;\n}\nint vs[N][N];\nvoid adeg(int r,int c,int sr,int sc)\n{\n\tvs[r][c]=d(sr,sc,0);\n\tif(ch[r][c]) add(d(sr,sc,0),d(r,c,1),1,abs(sr-r)+abs(sc-c));\n\tif(abs(r-sr)+abs(c-sc)>10) return;\n\tif(c<m&&vs[r][c+1]!=d(sr,sc,0)) adeg(r,c+1,sr,sc);\n\tif(c>1&&vs[r][c-1]!=d(sr,sc,0)) adeg(r,c-1,sr,sc);\n\tif(r<n&&vs[r+1][c]!=d(sr,sc,0)) adeg(r+1,c,sr,sc);\n\tif(r>1&&vs[r-1][c]!=d(sr,sc,0)) adeg(r-1,c,sr,sc);\n}\nint res,ans=inf;\nbool spfa()\n{\n\tmemset(dis,0x3f,sizeof(dis)),memset(inq,0,sizeof(inq)),q.push(S),dis[S]=0,inq[S]=1,a[S]=inf;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop(),inq[x]=0;\n\t\tfor(int i=fst[x];i;i=nxt[i])\n\t\t\tif(flow[i]&&dis[v[i]]>dis[x]+w[i])\n\t\t\t\tdis[v[i]]=dis[x]+w[i],pre[v[i]]=i,a[v[i]]=min(a[x],flow[i]),!inq[v[i]]&&(q.push(v[i]),inq[v[i]]=1);\n\t}\n\tif(dis[T]>inf) return 0;\n\tres+=dis[T]*a[T],pp+=a[T];\n\tfor(int i=T;i!=S;i=u[pre[i]]) flow[pre[i]]-=a[T],flow[pre[i]^1]+=a[T];\n\treturn 1;\n}\nint Cl;\nstruct aa\n{\n\tint x1,y1,x2,y2;\n}as[P];\nstack<aa> st;\n#define XX if(ss[x2][y2]=='#') while(!st.empty()) as[++Cl]=st.top(),st.pop();\nvoid walk(int x1,int y1,int x2,int y2)\n{\n\tif(x1==x2&&y1==y2) return;\n\tss[x2][y2]='#';\n\twhile(y2>y1) {st.push(aa{x2,y2-1,x2,y2}),y2--;XX}\n\twhile(x2>x1) {st.push(aa{x2-1,y2,x2,y2}),x2--;XX}\n\twhile(y2<y1) {st.push(aa{x2,y2+1,x2,y2}),y2++;XX}\n\twhile(x2<x1) {st.push(aa{x2+1,y2,x2,y2}),x2++;XX}\n\tss[x1][y1]='.';\n}\nsigned main()\n{\n\tfreopen(\"surround5.in\",\"r\",stdin);\n\tfreopen(\"surround0.out\",\"w\",stdout);\n\tint i,j,li,lj;\n\tcin>>n>>m,srand(time(0));\n\tfor(i=1;i<=n;i++) scanf(\"%s\",s[i]+1);\n\tfor(int t=1;t;t--)\n\t\tif(ade())\n\t\t{\n\t\t\tpp=qq=0;\n\t\t\tmemset(vs,0,sizeof(vs));\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tif(s[i][j]=='#'&&!ch[i][j]) adeg(i,j,i,j),add(S,d(i,j,0),1,0);\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tif(ch[i][j]&&s[i][j]!='#') add(d(i,j,1),T,1,0),qq++;\n\t\t\tres=0;\n\t\t\twhile(spfa());\n\t\t\tif(res<ans&&qq==pp)\n\t\t\t{\n\t\t\t\tans=res,Cl=0;\n\t\t\t\tmemcpy(ss,s,sizeof(ss));\n\t\t\t\twhile(!st.empty()) st.pop();\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\t\tif(ss[i][j]=='#')\n\t\t\t\t\t\t\tfor(li=fst[d(i,j,0)];li;li=nxt[li])\n\t\t\t\t\t\t\t\tif(!flow[li]&&v[li]!=S) walk(i,j,(v[li]-n*m-1)/m+1,(v[li]-n*m-1)%m+1);\n\t\t\t\tmemcpy(tt,ss,sizeof(tt));\n\t\t\t}\n\t\t\tcerr<<res<<'\\n';\n\t\t}\n\tcout<<ans<<'\\n';\n\tfor(i=1;i<=Cl;i++) cout<<as[i].x1<<' '<<as[i].y1<<' '<<as[i].x2<<' '<<as[i].y2<<'\\n';\n\treturn 0;\n}\n```\n\n8\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define int ll\nusing namespace std;\ntypedef long long ll;\nconst int N=335,N2=105,P=3*N*N2+5,M=1e7+5,inf=1e9;\nchar s[N][N2],ss[N][N2],tt[N][N2];\nint n,m;\nint fst[P],cur[P],nxt[M],u[M],v[M],flow[M],w[M],tot=1;\nint que[P],dis[P],h,t,S=P-1,T=P-2;\nint bk[P],vis[P];\nint ch[N][N2];\nint inq[P],a[P],pre[P];\nqueue<int> q;\nint pp,qq;\nvoid add(int lu,int lv,int lf,int lw=0)\n{\n\tu[++tot]=lu,v[tot]=lv,flow[tot]=lf,w[tot]=lw,nxt[tot]=fst[lu],fst[lu]=tot;\n\tu[++tot]=lv,v[tot]=lu,flow[tot]=0,w[tot]=-lw,nxt[tot]=fst[lv],fst[lv]=tot;\n}\nint d(int r,int c,int id) {return (r-1)*m+c+n*m*id;}\nbool bfs()\n{\n\tmemset(dis,0x3f,sizeof(dis)),dis[S]=0,que[h=t=1]=S;\n\twhile(h<=t)\n\t\tfor(int i=que[h++],j=fst[i];j;j=nxt[j])\n\t\t\tif(flow[j]&&dis[v[j]]>dis[i]+1) dis[v[j]]=dis[i]+1,que[++t]=v[j];\n\treturn dis[T]<inf;\n}\nint dfs(int x,int lw,int tt=T)\n{\n\tif(x==tt) return lw;\n\tint res=0,zl;\n\tfor(int &i=cur[x];i;i=nxt[i])\n\t\tif(flow[i]&&dis[v[i]]==dis[x]+1&&(zl=dfs(v[i],min(lw,flow[i]),tt)))\n\t\t{\n\t\t\tlw-=zl,flow[i]-=zl,res+=zl,flow[i^1]+=zl;\n\t\t\tif(!lw) return res;\n\t\t}\n\treturn res;\n}\nint dinic() {int res=0; while(bfs()) memcpy(cur,fst,sizeof(cur)),res+=dfs(S,inf); return res;}\nvoid bfs(int x)\n{\n\tbk[x]=1;\n\tfor(int i=fst[x];i;i=nxt[i])\n\t\tif(!bk[v[i]]&&flow[i]) bfs(v[i]);\n}\nint ck(int r,int c) {return r>0&&r<=n&&c>0&&c<=m? s[r][c]=='O':0;}\nbool ade()\n{\n\tint i,j;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t{\n\t\t\tint la=ck(i-1,j-1)+ck(i-1,j)+ck(i-1,j+1)+ck(i,j-1)+ck(i,j+1)+ck(i+1,j-1)+ck(i+1,j)+ck(i+1,j+1),\n\t\t\t\tlb=ck(i-2,j-2)+ck(i-2,j-1)+ck(i-2,j)+ck(i-2,j+1)+ck(i-2,j+2)+ck(i-1,j-2)+ck(i-1,j+2)+ck(i,j-2)+\n\t\t\t\tck(i,j+2)+ck(i+1,j-2)+ck(i+1,j+2)+ck(i+2,j-2)+ck(i+2,j-1)+ck(i+2,j)+ck(i+2,j+1)+ck(i+2,j+2);\n\t\t\tadd(d(i,j,0),d(i,j,1),s[i][j]!='O'&&la!=3&&lb!=5? 1:inf);\n\t\t\ti<n&&(add(d(i,j,1),d(i+1,j,0),inf),add(d(i+1,j,1),d(i,j,0),inf),0),\n\t\t\tj<m&&(add(d(i,j,1),d(i,j+1,0),inf),add(d(i,j+1,1),d(i,j,0),inf),0),\n\t\t\ts[i][j]=='O'&&(add(S,d(i,j,0),inf),0);\n\t\t}\n\tfor(i=1;i<=n;i++) add(d(i,1,1),T,inf),add(d(i,m,1),T,inf);\n\tfor(i=2;i<m;i++) add(d(1,i,1),T,inf),add(d(n,i,1),T,inf);\n\tint R=dinic();\n\tif(R>=inf) return memset(fst,0,sizeof(fst)),tot=1,0;\n\tmemset(bk,0,sizeof(bk)),bfs(S);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=m;j++)\n\t\t\tif(bk[d(i,j,0)]&&!bk[d(i,j,1)]) ch[i][j]=1;\n\t\t\telse ch[i][j]=0;\n\tmemset(fst,0,sizeof(fst)),tot=1;\n\treturn 1;\n}\nint vs[N][N];\nvoid adeg(int r,int c,int sr,int sc)\n{\n\tvs[r][c]=d(sr,sc,0);\n\tif(ch[r][c]) add(d(sr,sc,0),d(r,c,1),1,abs(sr-r)+abs(sc-c));\n\tif(abs(r-sr)+abs(c-sc)>10) return;\n\tif(c<m&&vs[r][c+1]!=d(sr,sc,0)) adeg(r,c+1,sr,sc);\n\tif(c>1&&vs[r][c-1]!=d(sr,sc,0)) adeg(r,c-1,sr,sc);\n\tif(r<n&&vs[r+1][c]!=d(sr,sc,0)) adeg(r+1,c,sr,sc);\n\tif(r>1&&vs[r-1][c]!=d(sr,sc,0)) adeg(r-1,c,sr,sc);\n}\nint res,ans=inf;\nbool spfa()\n{\n\tmemset(dis,0x3f,sizeof(dis)),memset(inq,0,sizeof(inq)),q.push(S),dis[S]=0,inq[S]=1,a[S]=inf;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front(); q.pop(),inq[x]=0;\n\t\tfor(int i=fst[x];i;i=nxt[i])\n\t\t\tif(flow[i]&&dis[v[i]]>dis[x]+w[i])\n\t\t\t\tdis[v[i]]=dis[x]+w[i],pre[v[i]]=i,a[v[i]]=min(a[x],flow[i]),!inq[v[i]]&&(q.push(v[i]),inq[v[i]]=1);\n\t}\n\tif(dis[T]>inf) return 0;\n\tres+=dis[T]*a[T],pp+=a[T];\n\tfor(int i=T;i!=S;i=u[pre[i]]) flow[pre[i]]-=a[T],flow[pre[i]^1]+=a[T];\n\treturn 1;\n}\nint Cl;\nstruct aa\n{\n\tint x1,y1,x2,y2;\n}as[P];\nstack<aa> st;\n#define XX if(ss[x2][y2]=='#') while(!st.empty()) as[++Cl]=st.top(),st.pop();\nvoid walk(int x1,int y1,int x2,int y2)\n{\n\tif(x1==x2&&y1==y2) return;\n\tss[x2][y2]='#';\n\twhile(y2>y1) {st.push(aa{x2,y2-1,x2,y2}),y2--;XX}\n\twhile(x2>x1) {st.push(aa{x2-1,y2,x2,y2}),x2--;XX}\n\twhile(y2<y1) {st.push(aa{x2,y2+1,x2,y2}),y2++;XX}\n\twhile(x2<x1) {st.push(aa{x2+1,y2,x2,y2}),x2++;XX}\n\tss[x1][y1]='.';\n}\nsigned main()\n{\n\tfreopen(\"surround8.in\",\"r\",stdin);\n\tfreopen(\"surround0.out\",\"w\",stdout);\n\tint i,j,li,lj;\n\tcin>>n>>m,srand(time(0));\n\tfor(i=1;i<=n;i++) scanf(\"%s\",s[i]+1);\n\tfor(int t=1;t;t--)\n\t\tif(ade())\n\t\t{\n\t\t\tpp=qq=0;\n\t\t\tmemset(vs,0,sizeof(vs));\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tif(s[i][j]=='#'&&!ch[i][j]) adeg(i,j,i,j),add(S,d(i,j,0),1,0);\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\tif(ch[i][j]&&s[i][j]!='#') add(d(i,j,1),T,1,0),qq++;\n\t\t\tres=0;\n\t\t\twhile(spfa());\n\t\t\tif(res<ans&&qq==pp)\n\t\t\t{\n\t\t\t\tans=res,Cl=0;\n\t\t\t\tmemcpy(ss,s,sizeof(ss));\n\t\t\t\twhile(!st.empty()) st.pop();\n\t\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\t\tfor(j=1;j<=m;j++)\n\t\t\t\t\t\tif(ss[i][j]=='#')\n\t\t\t\t\t\t\tfor(li=fst[d(i,j,0)];li;li=nxt[li])\n\t\t\t\t\t\t\t\tif(!flow[li]&&v[li]!=S) walk(i,j,(v[li]-n*m-1)/m+1,(v[li]-n*m-1)%m+1);\n\t\t\t\tmemcpy(tt,ss,sizeof(tt));\n\t\t\t}\n\t\t\tcerr<<res<<'\\n';\n\t\t}\n\tcout<<ans<<'\\n';\n\tfor(i=1;i<=Cl;i++) cout<<as[i].x1<<' '<<as[i].y1<<' '<<as[i].x2<<' '<<as[i].y2<<'\\n';\n\treturn 0;\n}\n```\n",
        "postTime": 1621390386,
        "uid": 223768,
        "name": "Yukikaze_",
        "ccfLevel": 9,
        "title": "\u3010NOI2007\u3011 \u8c03\u5175\u9063\u5c06solution"
    }
]