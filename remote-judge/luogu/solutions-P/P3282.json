[
    {
        "content": "\u8fd9\u9053\u9898\u5c31\u662f\u4e00\u9053\u8fd0\u7528\u8ba1\u7b97\u51e0\u4f55\u77e5\u8bc6\u7684\u9898\uff0c\u9700\u8981\u5e76\u67e5\u96c6\u7ef4\u62a4\uff0c\u601d\u8003\u5e76\u4e0d\u56f0\u96be\uff0c\u4e0d\u8fc7\u56e0\u4e3a\u4ee3\u7801\u91cf\u5f88\u5927\uff0c\u800c\u4e14\u4e00\u4e9b\u7cbe\u5ea6\u95ee\u9898\uff0c\u5e76\u4e0d\u597d\u8c03\u8bd5\u3002\n\n\u5bf9\u4e8e\u4e00\u5f00\u59cb\u7684\u9884\u5904\u7406\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u78b0\u5728\u4e00\u8d77\u4e14\u989c\u8272\u4e00\u6837\u7684\u5706\uff0c\u5982\u679c\u66b4\u529b$n^2$\u8fdb\u884c\u679a\u4e3e\u5408\u5e76\uff0c\u5bf9\u4e8e$n$\u5c0f\u4e8e\u7b49\u4e8e$10^5$\u7684\u6570\u636e\u80af\u5b9a\u662f\u8fc7\u4e0d\u4e86\u7684\uff0c\u5f53\u7136\u6211\u4eec\u53ef\u4ee5\u5b66\u7f51\u4e0a\u4ee3\u7801\u7528\u626b\u63cf\u7ebf\u7ef4\u62a4\u4e0e\u5f53\u524d\u5706\u6a2a\u5750\u6807\u4e4b\u5dee\u4e0d\u8d85\u8fc7$2$\u7684\u5706\u7684\u7eb5\u5750\u6807\uff0c\u518d\u4e8c\u5206\u5224\u65ad\uff0c\u80fd\u505a\u5230\u6700\u574f$O(nlogn)$\u7684\u9884\u5904\u7406\u3002\u4e0d\u8fc7\u8fd8\u6709\u53e6\u4e00\u4e2a\u529e\u6cd5\uff0c\u5e38\u6570\u5e94\u8be5\u8981\u4f4e\u4e00\u4e9b\u3002 \u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u533a\u57df\u8fb9\u754c\u7684\u5750\u6807\u5f88\u5c0f\uff0c\u6211\u4eec\u53ef\u4ee5\u5c1d\u8bd5\u5bf9\u5e73\u9762\u8fdb\u884c\u5212\u5206\uff0c\u53ef\u4ee5\u5c06\u5e73\u9762\u533a\u57df\u5206\u5272\u6210\u7f51\u683c\uff0c\u6bcf\u4e2a\u683c\u5b50\u8fb9\u957f\u4e3a\u5706\u76f4\u5f84\u7684\u957f\u5ea6\u3002\u8fd9\u6837\u53ea\u9700\u8981\u679a\u4e3e\u5f53\u524d\u5706\u6240\u5904\u683c\u5b50\u7684\u5468\u56f4\u516b\u4e2a\u683c\u5b50\u91cc\u7684\u5706\u8fdb\u884c\u5408\u5e76(\u679a\u4e3e\u91cf\u5e94\u8be5\u4e0d\u4f1a\u8d85\u8fc7$16$\u4e2a)\uff0c\u8fd9\u6837\u5c31\u80fd\u5f88\u5feb\u7684\u8fdb\u884c\u9884\u5904\u7406\u4e86\u3002\n\n\u89e3\u51b3\u5b8c\u9884\u5904\u7406\u7684\u95ee\u9898\uff0c\u73b0\u5728\u9700\u8981\u89e3\u51b3\u53d1\u5c04\u64cd\u4f5c\u3002\u6211\u4eec\u53d1\u73b0\u6570\u636e\u8303\u56f4\u662f\u652f\u6301$n\u00d7q$\u7684\u590d\u6742\u5ea6\u7684\uff0c\u6bcf\u4e00\u6b21\u53d1\u5c04\u64cd\u4f5c\u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u5706\u6c42\u51fa\u53d1\u5c04\u7684\u5706\u649e\u5230\u5b83\u505c\u4e0b\u6765\u540e\u5706\u5fc3\u6240\u5904\u7684\u5750\u6807\uff0c\u8fdb\u884c\u6bd4\u8f83\u540e\uff0c\u5c31\u80fd\u6c42\u51fa\u6ca1\u6709\u5899\u65f6\u4f1a\u505c\u4e0b\u7684\u4f4d\u7f6e\u3002\u5982\u679c\u4e0d\u4f1a\u4e0e\u5176\u5b83\u5706\u76f8\u649e\uff0c\u5219\u4f1a\u76f4\u63a5\u649e\u5230\u5899\u4e0a\uff0c\u5426\u5219\u518d\u6c42\u51fa\u649e\u5230\u5899\u4f1a\u505c\u4e0b\u6765\u7684\u5750\u6807\uff0c\u5c06\u5176\u548c\u4e4b\u524d\u6c42\u51fa\u7684\u649e\u5230\u5706\u505c\u4e0b\u6765\u7684\u5750\u6807\u8fdb\u884c\u6bd4\u8f83\uff0c\u4fbf\u53ef\u4ee5\u77e5\u9053\u5b9e\u9645\u662f\u505c\u5728\u54ea\u4e2a\u4f4d\u7f6e\u7684\uff0c\u7136\u540e\u53c8\u53ef\u4ee5\u50cf\u5f00\u59cb\u9884\u5904\u7406\u90a3\u6837\u679a\u4e3e\u5468\u56f4\u516b\u4e2a\u683c\u5b50\u8fdb\u884c\u5408\u5e76\uff0c\u518d\u5224\u65ad\u5b83\u6240\u5904\u7684\u5e76\u67e5\u96c6\u91cc\u662f\u5426\u6709\u8d85\u8fc7$2$\u4e2a\u5706\uff0c\u5982\u679c\u8d85\u8fc7\u4e86\u5c31\u7d2f\u8ba1\u7b54\u6848\uff0c\u5c06\u8fd9\u4e9b\u5706\u6253\u4e0a\u6807\u8bb0\uff0c\u5e76\u628a\u5b83\u4eec\u6240\u5904\u7684\u65b9\u683c\u91cc\u5c06\u5b83\u4eec\u81ea\u5df1\u5220\u9664(\u8fd9\u91cc\u7684\u590d\u6742\u5ea6\u7a0d\u7a0d\u9ad8\u4e86\u4e00\u70b9)\uff0c\u4e0b\u6b21\u679a\u4e3e\u5c31\u4e0d\u4f1a\u8003\u8651\u8fd9\u4e9b\u5706\u4e86\u3002\n\n\u5927\u81f4\u601d\u8def\u5c31\u662f\u8fd9\u6837\uff0c\u4e00\u4e9b\u5c0f\u6280\u5de7\u53ef\u4ee5\u770b\u4ee3\u7801\uff0c\u5176\u5b9e\u4ee3\u7801\u91cc\u6709\u8bb8\u591a\u5730\u65b9\u53ef\u4ee5\u4f18\u5316\uff0c\u4e0d\u8fc7\u672c\u4eba\u592a\u61d2\uff0c\u4e5f\u5c31\u4e0d\u60f3\u6539\u4e86\u3002\n\n\u590d\u6742\u5ea6\u5927\u6982\u662f$O(nlogn+nq)$\u5de6\u53f3\u3002\n```cpp\n#include<cmath>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define vector point\nusing namespace std;\nconst int N=100010,P=1010;\nconst double eps=1e-7,pi=acos(-1),inf=999999999;\ndouble w,h,du,l,r;\nlong long ans,size[N+P];\nint n,m,co,flag,fa[N+P],out[N+P],dy[9]={1,1,0,-1,-1,-1,0,1,0},dx[9]={0,1,1,1,0,-1,-1,-1,0};\nstruct point\n{\n    double x,y;\n    point(double x=0,double y=0):x(x),y(y){}\n};\nstruct area\n{\n    int num,have[10];\n}are[510][1010];\nstruct circle\n{\n    point o;int color,x,y;\n}cir[N+P];\nstruct line\n{\n    point p;vector v;\n}sh,up,lef,righ;\nvector operator +(vector a,vector b)\n{return vector(a.x+b.x,a.y+b.y);}\nvector operator -(point a,point b)\n{return vector(a.x-b.x,a.y-b.y);}\nvector operator *(vector a,double b)\n{return vector(a.x*b,a.y*b);}\nvector operator /(vector a,double b)\n{return vector(a.x/b,a.y/b);}\ndouble cross(vector a,vector b)\n{return a.x*b.y-a.y*b.x;}\nvector rotate(vector v,double ang)\n{return vector(v.x*cos(ang)-v.y*sin(ang),v.x*sin(ang)+v.y*cos(ang));}\ndouble dis(point a,point b)\n{return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}\nint cmp(double b)\n{\n    if(fabs(b)<eps)return 0;\n    return b<0?-1:1;\n}\nbool check(point a,point b)\n{\n    double pd=(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y);\n    if(cmp(pd-4.0)==0)return 1;return 0;\n}\nint find(int a)\n{\n    if(fa[a]==a)return a;\n    return fa[a]=find(fa[a]);\n}\npoint GLP(line a,line b)\n{\n    vector u=a.p-b.p;\n    double t=cross(b.v,u)/cross(a.v,b.v);\n    return a.p+a.v*t;\n}\nvoid putin(int a)\n{\n    //\u5176\u5b9e\u8fd9\u4e2a\u5730\u65b9\u53ef\u4ee5\u4e0d\u7528\u4e8c\u5206\uff0c\u76f4\u63a5\u9664\u4ee52\u53d6\u6574\u5c31\u884c\uff0c\u8981\u6ce8\u610f\u8d1f\u6570\n    int l=1,r=500,x,y;\n    while(l<r)\n    {\n        int mid=l+r>>1;\n        if(cmp(cir[a].o.y-2.0*mid)<=0)r=mid;\n        else l=mid+1;\n    }\n    x=l;l=-500;r=500;\n    while(l<r)\n    {\n        int mid=l+r>>1;\n        if(cmp(cir[a].o.x-2.0*mid)<=0)r=mid;\n        else l=mid+1;\n    }\n    y=l+500;are[x][y].have[++are[x][y].num]=a;\n    cir[a].x=x;cir[a].y=y;\n}\npoint findpoi(line sh,int now)\n{\n    line zh;zh.v=rotate(sh.v,pi/2);\n    point ans=point(0,0);double minf=inf,len;\n    for(int i=1;i<=now;i++)\n     if(!out[i])\n     {\n     \tzh.p=cir[i].o;\n     \tpoint poi=GLP(sh,zh);\n        len=dis(poi,cir[i].o);\n     \tint pd=cmp(len-2);\n     \tif(pd>0)continue;\n        else if(pd<0)\n        {\n        \tif(cmp(len)==0)\n        \t{\n        \t\tvector v=rotate(sh.v,pi);\n        \t\tpoi=cir[i].o+v*2;\n        \t\tlen=dis(poi,point(0,0));\n        \t}\n        \telse\n        \t{\n                double cha=acos(len/2.0);\n                line l1,l2;l1.p=l2.p=zh.p;\n                l1.v=rotate(zh.v,cha);\n                l2.v=rotate(zh.v,-cha);\n                point poi1=GLP(sh,l1),poi2=GLP(sh,l2);\n                double len1=dis(poi1,point(0,0)),\n                len2=dis(poi2,point(0,0));\n                if(len1<len2)poi=poi1,len=len1;\n                else poi=poi2,len=len2;\n            }\n        }\n        else len=dis(poi,point(0,0));\n        if(len<minf)minf=len,ans=poi;\n     }\n    if(minf==inf)flag=0;\n    else flag=1;return ans;\n}\nint main()\n{\n    scanf(\"%lf%lf\",&w,&h);\n    //\u628a\u8fb9\u754c\u5411\u5185\u79fb\u52a8\u4e00\u4e2a\u5355\u4f4d\uff0c\u53ef\u4ee5\u66f4\u65b9\u4fbf\u7684\u6c42\u51fa\u649e\u5230\u8fb9\u754c\u540e\u7684\u5706\u5fc3\u5750\u6807\n    lef.p=point(-w+1,0);righ.p=point(w-1,0);\n    lef.v=righ.v=vector(0,1);\n    up.p=point(-w,h-1);up.v=vector(1,0);\n    l=atan2(h-1,w-1);r=pi-l;\n    //\u6c42\u51fa\u89d2\u5ea6\uff0c\u65b9\u4fbf\u540e\u9762\u5224\u65ad\u662f\u649e\u5230\u54ea\u4e00\u9762\u5899\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lf%lf%d\",&cir[i].o.x,&cir[i].o.y,&cir[i].color);\n        putin(i);fa[i]=i,size[i]=1;\n    }\n    //\u9884\u5904\u7406\n    for(int i=1;i<=n;i++)\n     for(int j=0;j<9;j++)\n      if(are[cir[i].x+dx[j]][cir[i].y+dy[j]].num)\n      {\n      \tint kx=cir[i].x+dx[j],ky=cir[i].y+dy[j];\n      \tfor(int k=1;k<=are[kx][ky].num;k++)\n      \t{\n      \t\tint ci=are[kx][ky].have[k];\n      \t    if(check(cir[i].o,cir[ci].o)&&cir[i].color==cir[ci].color)\n      \t    {\n      \t    \tint f1=find(i),f2=find(ci);\n      \t    \tif(f1==f2)continue;\n      \t    \tfa[f1]=f2;size[f2]+=size[f1];size[f1]=0;\n            }\n        }\n      }\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%lf%d\",&du,&co);\n        du=(du*pi)/180.0;\n        vector v=vector(1,0);\n        sh.v=rotate(v,du);\n        point poi1,poi2;\n        if(du<=l)poi1=GLP(sh,righ);\n        else if(du>l&&du<=r)poi1=GLP(sh,up);\n        else poi1=GLP(sh,lef);\n        poi2=findpoi(sh,n+i-1);\n        //\u6211\u7684\u67e5\u627e\u548c\u5224\u65ad\u5199\u7684\u6bd4\u8f83\u9ebb\u70e6\uff0c\u6700\u597d\u81ea\u5df1\u601d\u8003\n        if(!flag)\n        {\n \t\t\tcir[n+i].o=poi1;\n            cir[n+i].color=co;\n            fa[n+i]=n+i;size[n+i]=1;\n            putin(n+i);\n            continue;\n        }\n        double l1=dis(point(0,0),poi1),\n        l2=dis(point(0,0),poi2);\n        if(cmp(l1-l2)<0)\n        {\n            cir[n+i].o=poi1;\n            cir[n+i].color=co;\n            fa[n+i]=n+i;size[n+i]=1;\n            putin(n+i);\n            continue;\n        }\n        else\n        {\n            cir[n+i].o=poi2;\n            cir[n+i].color=co;\n            fa[n+i]=n+i;size[n+i]=1;putin(n+i);\n            for(int k=0;k<9;k++)\n             if(are[cir[n+i].x+dx[k]][cir[n+i].y+dy[k]].num)\n             {\n      \t        int kx=cir[n+i].x+dx[k],ky=cir[n+i].y+dy[k];\n      \t        for(int q=1;q<=are[kx][ky].num;q++)\n      \t        {\n      \t\t      int ci=are[kx][ky].have[q];\n      \t          if(check(cir[n+i].o,cir[ci].o)&&cir[n+i].color==cir[ci].color)\n      \t          {\n      \t    \t    int f1=find(n+i),f2=find(ci);\n      \t    \t    if(f1==f2)continue;\n      \t    \t    fa[f1]=f2;size[f2]+=size[f1];size[f1]=0;\n                  }\n                }\n             }\n            int need=find(n+i);\n            if(size[need]<3)continue;\n            ans+=size[need]*size[need];size[need]=0;\n            for(int k=1;k<=n+i;k++)\n             if(find(k)==need)\n             {\n             \tint xx=cir[k].x,yy=cir[k].y;\n             \tfor(int q=1;q<=are[xx][yy].num;q++)\n             \t if(are[xx][yy].have[q]==k)\n             \t {\n             \t \tfor(int p=q;p<are[xx][yy].num;p++)\n             \t \t are[xx][yy].have[p]=are[xx][yy].have[p+1];\n             \t \tare[xx][yy].have[are[xx][yy].num]=0;are[xx][yy].num--;\n             \t }\n                out[k]=1;\n             }\n            \n        }\n    }\n    printf(\"%lld\\n\",ans);\n    fclose(stdout);\n    return 0;\n}\n```",
        "postTime": 1521284333,
        "uid": 61423,
        "name": "hdxrie",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3282 \u3010[SCOI2013]\u6ce1\u6ce1\u9c7c \u3011"
    }
]