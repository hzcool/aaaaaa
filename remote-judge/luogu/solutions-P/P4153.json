[
    {
        "content": "\n## WC2015 T1 k\u5c0f\u5272\n\n- \u5410\u69fd\n\n\u5199\u4e86 $2$ \u4e2a\u5c0f\u65f6\uff0c $7.5KB$ \u3002\u3002\u3002\n\n\u8fd9\u9898\u5728 uoj \u4e0a\u88ab\u53c9\u7684\u5410\u8840\u3002\u3002\u3002\u6700\u7ec8\u7ec8\u4e8e\u901a\u8fc7\u4e86\u3002\u5b98\u65b9\u6570\u636e\u662f\u771f\u7684\u6c34\u3002\n\n- \u9898\u89e3\n\n\u9996\u5148\u8fd9\u9898\u662f\u4e09\u5408\u4e00\u3002\n\n- $1\\le n\\le 10,1\\le m\\le 20,1\\le k\\le 10^6$ \n\n\u54c7 $K$ \u597d\u5927\uff0c\u600e\u4e48\u529e\uff1f\n\n\u6ce8\u610f\u5230\u8fb9\u53ea\u6709 $20$ \u6761\uff0c\u66b4\u529b\u679a\u4e3e\u5272\u4e0d\u5272\uff0c\u7136\u540e\u5224\u65ad $S$ \u548c $T$ \u7684\u8fde\u901a\u6027\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(2^m\\times n)$ \n\n- $1\\le n\\le 150000,m=2n-4$ \u4e14\u4fdd\u8bc1\u8fb9\u662f $(1,i)$ \u6216 $(i,T)$\n\n\u753b\u51fa\u6765\u53d1\u73b0\u662f\u4e00\u4e2a $S$ \u8fde\u5411 $n-2$ \u4e2a\u70b9\u518d\u8fde\u5411 $T$ \u7684\u4e09\u5206\u56fe\uff0c\u5bf9\u4e8e\u7b2c\u4e8c\u5c42\u7684\u70b9 $i$ \uff0c\u8bb0 $S$ \u8fde\u5411\u5b83\u7684\u6743\u503c\u4e3a $x$ \uff0c\u5b83\u8fde\u5411 $T$ \u7684\u6743\u503c\u4e3a $y$ \u3002\n\n\u4e0d\u5931\u4e00\u822c\u6027\uff0c\u4ee4 $x\\le y$ \uff0c\u5219\u8fd9\u4e2a\u70b9\u7684\u53d6\u6cd5\u6709\u4e09\u4e2a\u9636\u6bb5\uff1a\u53d6 $x$ \uff1b\u53d6 $y$ \uff1b\u53d6 $x+y$ \u3002\u6211\u4eec\u53ef\u5c06\u5176\u89c6\u4e3a\u4f9d\u6b21\u52a0 $x$ , $y-x$ , $x$ \uff0c\u8bb0\u4e3a\u4e09\u5143\u7ec4 $a_i=(a_{i,0},a_{i,1},a_{i,2})$ \n\n\u6bcf\u4e2a\u70b9\u521d\u59cb\u7684\u8d21\u732e\u662f $x$ \uff0c\u6309\u7167\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\u3002\u7528 $pq$ \u7ef4\u62a4\u5b83\u4eec\uff0c\u6709\u4e09\u79cd\u8f6c\u79fb\u72b6\u6001\uff1a\n\n- \u5f53\u524d\u70b9\u201c\u5347\u7ea7\u201d\uff1a\u4ece $a_{i,1}$ \u8fc7\u6e21\u5230 $a_{i,2}$ \uff1b\n\n- \u5f53\u524d\u70b9\u201c\u964d\u7ea7\u201d\uff0c\u5e76\u524d\u5f80\u4e0b\u4e00\u4e2a\u70b9\uff1a\u4ece $a_{i,2}$ \u5230 $a_{i,1}$ \uff0c\u5e76\u65b0\u52a0\u5165 $a_{i+1,1}$ \uff1b\n\n- \u76f4\u63a5\u524d\u5f80\u4e0b\u4e00\u4e2a\u70b9\uff1a\u65b0\u52a0\u5165 $a_{i+1,1}$\n\n\u53ef\u4ee5\u53d1\u73b0\u8fd9\u6837 $pq$ \u5185\u7684\u72b6\u6001\u6570\u662f $O(n)$ \u7684\u3002\n\n\u6545\u65f6\u95f4\u590d\u6742\u5ea6 $O(nlogn)$ \u3002\n\n- $1\\le n\\le 50,1\\le m\\le 1500,1\\le k\\le 100$\n\n\u4e0d\u59a8\u5148\u8003\u8651\u5982\u4f55\u6c42\u6b21\u5c0f\u5272\u3002\n\n\u5148\u8dd1\u51fa\u6700\u5927\u6d41\uff0c\u5e76\u62a0\u51fa\u5272\u8fb9\uff0c\u5219\u6b21\u5c0f\u5272\u6709\u4e24\u79cd\u53ef\u80fd\uff1a\n\n- \u5c06\u67d0\u4e00\u6761\u5272\u8fb9\u6539\u6210\u6b21\u5c0f\u7684\u5272\u8fb9\uff1b\n\n- \u65b0\u52a0\u5165\u4e00\u6761\u8fb9\uff1b\n\n\u524d\u8005\u53ef\u4ee5\u901a\u8fc7\u5c06\u5272\u8fb9\u7684\u4e24\u7aef\u70b9\u5728\u6b8b\u4f59\u7f51\u7edc\u4e0a\u91cd\u65b0\u8dd1\u6700\u5c0f\u5272\u5f97\u5230\uff0c\u540e\u8005\u76f4\u63a5\u679a\u4e3e\u975e\u5272\u8fb9\u91cc\u7684\u6700\u5c0f\u6d41\u91cf\u7684\u8fb9\u5373\u53ef\u3002\n\n\u56e0\u6b64\u6c42\u6b21\u5c0f\u5272\u7684\u590d\u6742\u5ea6\u4e5f\u662f $O(m\\times flow)$ \u7684\u3002\n\n\u7c7b\u4f3c\u5730\uff0c\u5f15\u5165 $must[i],stop[i]$ \u8868\u793a\u8fd9\u6761\u8fb9**\u5fc5\u987b\u9009/\u7981\u6b62\u9009**\uff0c\u90a3\u5c31\u53ef\u4ee5\u5c06\u4e0a\u9762\u6c42\u6b21\u5c0f\u5272\u7684\u8fc7\u7a0b\u63a8\u5e7f\u5230 $k$ \u5c0f\u5272\uff0c\u7528 $pq$ \u7ef4\u62a4\u6574\u4e2a\u8fc7\u7a0b\u5373\u53ef\u3002\n\n\u5b9e\u73b0\u8d77\u6765\u96be\u5ea6\u6781\u5927\u3002\u3002\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(m\\times flow\\times klogk)$ \uff0c\u6700\u574f\u60c5\u51b5 $O(nm^2klogk)$ \uff0c\u4f46\u7f51\u7edc\u6d41\u90e8\u5206\u8dd1\u4e0d\u6ee1\u3002\n\n\u5efa\u8bae\u5199\u5b8c\u4ee5\u540e\u5230 UOJ \u4e0a\u6d4b\u4e00\u6d4b\uff0c hack \u6570\u636e\u7279\u522b\u591a\u3002\u3002\u3002\n\n```cpp\n// Author: wlzhouzhuan\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int, int>\n#define pb push_back\n#define fir first\n#define sec second\n#define rep(i, l, r) for (int i = l; i <= r; i++)\n#define per(i, l, r) for (int i = l; i >= r; i--)\n#define mset(s, t) memset(s, t, sizeof(s))\n#define mcpy(s, t) memcpy(s, t, sizeof(t))\ntemplate<typename T1, typename T2> void ckmin(T1 &a, T2 b) { a > b && a = b; }\ntemplate<typename T1, typename T2> void ckmax(T1 &a, T2 b) { a < b && a = b; }\nint read() {\n  int x = 0, f = 0; char ch = getchar();\n  while (!isdigit(ch)) f |= ch == '-', ch = getchar();\n  while (isdigit(ch)) x = 10 * x + ch - '0', ch = getchar();\n  return f ? -x : x;\n}\ntemplate<typename T> void print(T x) {\n  if (x < 0) putchar('-'), x = -x;\n  if (x >= 10) print(x / 10);\n  putchar(x % 10 + '0');\n}\ntemplate<typename T> void print(T x, char let) {\n  print(x), putchar(let);\n}\n\nconst int N = 300005;\nconst int inf = 5e8;\nint n, m, S, T, K;\nint _U[N], _V[N], _W[N];\n\nnamespace BRUTE {\nstruct E {\n  int u, v, w;\n} e[N];\nvector<int> adj[N];\nint vis[N];\nvoid dfs(int u) {\n  vis[u] = 1;\n  for (auto v: adj[u]) {\n    if (!vis[v]) dfs(v);\n  }\n}\nint f[N];\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\nvoid MAIN() {\n  for (int i = 1; i <= m; i++) {\n    e[i].u = _U[i], e[i].v = _V[i], e[i].w = _W[i];\n  }\n  vector<ll> ans;\n  for (int st = 0; st < 1 << m; st++) {\n    for (int i = 1; i <= n; i++) vis[i] = 0, adj[i].clear();\n    ll coef = 0;\n    for (int i = 1; i <= m; i++) {\n      if (st >> (i - 1) & 1) {\n        coef += e[i].w;\n      } else {\n        adj[e[i].u].pb(e[i].v);\n      }\n    }\n    dfs(S);\n    if (!vis[T]) ans.pb(coef);\n  }\n  sort(ans.begin(), ans.end());\n  for (int i = 0; i < min(int(ans.size()), K); i++) {\n    printf(\"%lld\\n\", ans[i]);\n  }\n  if (K > ans.size()) puts(\"-1\");\n}\n}\n\nnamespace SP {\nstruct node {\n  int x, y;\n  friend bool operator < (const node &x, const node &y) {\n    if (x.x ^ y.x) return x.x < y.x;\n    else return x.y < y.y;\n  }\n} a[N];\nint cnt = 0;\nstruct PQ {\n  ll ans;\n  int pos, opt;\n  friend bool operator < (const PQ &x, const PQ &y) {\n    return x.ans > y.ans;\n  }\n};\npriority_queue<PQ> pq; \nvoid MAIN() {\n  for (int i = 1; i <= m; i++) {\n    int u = _U[i], v = _V[i], w = _W[i];\n    if (v == S) swap(u, v);\n    if (v == T) swap(u, v);\n    if (u == S) a[v].x = w;\n    else a[v].y = w;\n  }\n  ll ans = 0;\n  for (int i = 1; i <= n; i++) {\n    if (i == S || i == T) continue;\n    a[++cnt] = a[i];\n    if (a[cnt].x > a[cnt].y) swap(a[cnt].x, a[cnt].y);\n    ans += a[cnt].x;\n    int tmp = a[cnt].x;\n    a[cnt].x = a[cnt].y - a[cnt].x, a[cnt].y = tmp;\n  }\n  sort(a + 1, a + cnt + 1);\n  printf(\"%lld\\n\", ans), K--;\n  pq.push({ans + a[1].x, 1, 1});\n  while (K-- && !pq.empty()) {\n    PQ u = pq.top(), v; pq.pop();\n    printf(\"%lld\\n\", u.ans);\n    if (u.opt == 1) { // \u5347\u7ea7\n      v.pos = u.pos, v.opt = 2, v.ans = u.ans + a[v.pos].y;\n      pq.push(v); \n    }\n    if (u.opt == 1 && u.pos < n) { // \u9000\u7ea7\uff0c\u5f80\u524d\u4e00\u683c \n      v.pos = u.pos + 1, v.opt = 1, v.ans = u.ans - a[u.pos].x + a[v.pos].x;\n      pq.push(v);\n    }\n    if (u.pos < n) { // \u76f4\u63a5\u5f80\u524d\u4e00\u683c \n      v.pos = u.pos + 1, v.opt = 1, v.ans = u.ans + a[v.pos].x;\n      pq.push(v);\n    }\n  }\n  if (K > 0) puts(\"-1\");\n}\n}\n\nnamespace FLOW {\nstruct Graph {\n  struct Edge {\n    int to, nxt, cap;\n  } edge[3005];\n  int head[55], h[55], tot = 1;\n  void add(int u, int v, int cap) {\n    edge[++tot] = {v, head[u], cap};\n    head[u] = tot;  \n  }\n  void addedge(int u, int v, int cap) {\n    add(u, v, cap), add(v, u, 0);\n  }\n  int dep[55];\n  bool bfs(int S, int T) {\n    queue<int> q;\n    for (int i = 1; i <= n; i++) dep[i] = -1, h[i] = head[i];\n    dep[S] = 0, q.push(S);\n    while (!q.empty()) {\n      int u = q.front(); q.pop();\n      for (int i = head[u]; i; i = edge[i].nxt) {\n        int v = edge[i].to, cap = edge[i].cap;\n        if (dep[v] == -1 && cap) {\n          dep[v] = dep[u] + 1;\n          if (v == T) return 1;\n          q.push(v);\n        }\n      }\n    }\n    return dep[T] != -1;\n  }\n  int dfs(int u, int T, int ans) {\n    if (u == T) return ans;\n    int over = 0;\n    for (int &i = h[u]; i; i = edge[i].nxt) {\n      int v = edge[i].to, cap = edge[i].cap;\n      if (dep[v] == dep[u] + 1 && cap) {\n        int res = dfs(v, T, min(ans, cap));\n        ans -= res, over += res;\n        edge[i].cap -= res, edge[i ^ 1].cap += res;\n        if (!res) dep[v] = -1;\n        if (!ans) break;\n      }\n    }\n    return over;\n  }\n  int ans;\n  int Dinic(int S, int T) {\n    ans = 0;\n    while (bfs(S, T)) {\n      ans += dfs(S, T, inf);\n      if (ans >= inf) break;\n    }\n    return ans;\n  }\n  int vis[55], in[1505];\n  void DFS(int u) {\n    vis[u] = 1;\n    for (int i = head[u]; i; i = edge[i].nxt) {\n      int v = edge[i].to, cap = edge[i].cap;\n      if (!vis[v] && cap) DFS(v);\n    }\n  }\n  void get_cut() {\n    for (int i = 1; i <= n; i++) vis[i] = in[i] = 0;\n    DFS(S);\n    for (int i = 1; i <= m; i++) {\n      if (vis[_U[i]] && !vis[_V[i]]) {\n        in[i] = 1;\n      }\n    }\n  }\n} G, G1, G2;\n\nstruct node {\n  int visx[55], visy[55];\n  int must[1505], stop[1505];\n  int ans, id;\n  friend bool operator < (const node &x, const node &y) {\n    return x.ans > y.ans;\n  }\n  void run() {\n    G1 = G, ans = id = 0;\n    for (int i = 1; i <= m; i++) {\n      if (must[i]) ans += G1.edge[i << 1].cap, G1.edge[i << 1].cap = G1.edge[i << 1 | 1].cap = 0;\n      if (stop[i]) G1.edge[i << 1].cap = inf, G1.edge[i << 1 | 1].cap = 0; \n    }\n    ans += G1.Dinic(S, T);\n//    printf(\"current ans = %d\\n\", ans);\n    G1.get_cut();\n    int ext = inf;\n    for (int i = 1; i <= n; i++) visx[i] = visy[i] = 0;\n    for (int i = 1; i <= m; i++) {\n      if (must[i] || stop[i]) continue;\n      if (G1.in[i]) { // \u5272\u8fb9 \n        if (!visx[_U[i]]) {\n          visx[_U[i]] = 1;\n          G2 = G1;\n          int ext_flow = G2.Dinic(S, _U[i]);\n          if (ext_flow < ext) ext = ext_flow, id = i;\n        }\n        if (!visy[_V[i]]) {\n          visy[_V[i]] = 1;\n          G2 = G1;\n          int ext_flow = G2.Dinic(_V[i], T);\n          if (ext_flow < ext) ext = ext_flow, id = i; \n        }\n      } else if (_W[i] < ext) {\n        ext = _W[i], id = i;\n      } \n    }\n    ans += ext;\n  }\n} a, b;\npriority_queue<node> pq;\n\nvoid MAIN() {\n  for (int i = 1; i <= m; i++) {\n    G.addedge(_U[i], _V[i], _W[i]);\n  }\n  G1 = G;\n  G1.Dinic(S, T), K--;\n  printf(\"%d\\n\", G1.ans);\n  a.run();\n  if (a.ans < inf) pq.push(a);\n  while (K-- && !pq.empty()) {\n    node u = pq.top(); pq.pop();\n    printf(\"%d\\n\", u.ans);\n//    printf(\"now u = (%d, %d)\\n\", u.ans, u.id);\n    a = u, a.must[a.id] = 1, a.run();\n//    printf(\"u -> a = (%d, %d)\\n\", a.ans, a.id);\n    if (a.ans < inf) pq.push(a);\n    b = u, b.stop[b.id] = 1, b.run();\n//    printf(\"u -> b = (%d, %d)\\n\", b.ans, b.id);\n    if (b.ans < inf) pq.push(b);\n  }\n  if (K > 0) puts(\"-1\");\n}\n}\n\nint main() {\n  n = read(), m = read(), S = read(), T = read(), K = read();\n  int ok = 0;\n  set<int> s;\n  for (int i = 1; i <= m; i++) {\n    _U[i] = read(), _V[i] = read(), _W[i] = read();\n    if (_U[i] == S && _V[i] != T) ok++, s.insert(2 * _V[i]);\n    else if (_V[i] == S && _U[i] != T) ok++, s.insert(2 * _U[i]);\n    else if (_U[i] == T && _V[i] != S) ok++, s.insert(2 * _V[i] + 1);\n    else if (_V[i] == T && _U[i] != S) ok++, s.insert(2 * _U[i] + 1);\n  }\n  if (m <= 24) BRUTE::MAIN(), exit(0);\n  if (ok == m && s.size() == 2 * n - 4) SP::MAIN(), exit(0);\n  FLOW::MAIN(), exit(0);\n  return 0;\n}\n```",
        "postTime": 1609298179,
        "uid": 112381,
        "name": "wlzhouzhuan",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4153 \u3010[WC2015]k\u5c0f\u5272\u3011"
    }
]