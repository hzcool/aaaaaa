[
    {
        "content": "\u4e24\u5f20\u5361\u7247\u5206\u7ed9\u4e24\u4e2a\u5c0f\u670b\u53cb\uff0c\u53ef\u4ee5\u5206\u6210 $(2, 0)$\uff0c$(1, 1)$ \u548c $(0, 2)$\uff0c\u4e5f\u5c31\u662f\u6bcf\u79cd\u5206\u6cd5\u90fd\u53ef\u4ee5\uff0c\u6ca1\u6709\u9650\u5236\u3002\n\n\u5c31\u5f88\u9002\u5408\u7f51\u7edc\u6d41\u3002\n\n\u4ee4 $u_i, v_i$ \u8868\u793a\u7b2c $i$ \u6b21\u8bb0\u5f55\u4e2d\u7684\u4e24\u4f4d\u5c0f\u670b\u53cb\uff0c$a_j$ \u8868\u793a\u7b2c $j$ \u4f4d\u5c0f\u670b\u53cb\u624b\u4e0a\u5361\u7247\u7684\u6570\u91cf\u3002\n\n\u4ece\u8d85\u7ea7\u6e90 $S$ \u5411\u6bcf\u6b21\u8bb0\u5f55 $i$ \u8fde\u5bb9\u91cf\u4e3a $2$ \u7684\u8fb9\u3002\n\n\u6bcf\u6b21\u8bb0\u5f55 $i$ \u5411\u5bf9\u5e94\u7684\u4e24\u4f4d\u5c0f\u670b\u53cb $u_i, v_i$ \u5404\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $+ \\infty$ \u7684\u8fb9\u3002\n\n\u6bcf\u4f4d\u5c0f\u670b\u53cb $j$ \u5411\u8d85\u7ea7\u6c47 $T$ \u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $a_j$ \u7684\u8fb9\u3002\n\n\u8dd1\u4e00\u904d\u6700\u5927\u6d41\uff0c\u6211\u4eec\u5c31\u6c42\u51fa\u4e86\u4e00\u79cd\u6ee1\u8db3\u6761\u4ef6\u7684\u5206\u914d\u65b9\u6848\u3002\n\n\u6700\u540e\u8fd8\u6709\u82e5\u5e72\u6b21\u88ab\u9057\u5fd8\u7684\u8bb0\u5f55\uff0c\u8bb0\u7b2c $j$ \u4f4d\u5c0f\u670b\u53cb\u5269\u4f59\u5361\u7247\u6570\u4e3a $b_j$\u3002\u663e\u7136 $b_j$ \u5747\u4e3a\u81ea\u7136\u6570\u3002\n\n\u82e5 $b_j$ \u4e3a\u5076\u6570\uff0c\u5219\u53ef\u4ee5\u4e0d\u65ad\u6293\u4e00\u540d\u5c0f\u670b\u53cb\u548c\u4ed6\u4e00\u8d77\u4e70\u7136\u540e\u8d62\u8fc7\u5bf9\u65b9\u62ff\u5230 $2$ \u5f20\uff0c\u76f4\u5230\u5230\u8fbe\u6570\u91cf\u4e3a\u6b62\u3002\n\n\u82e5 $b_j$ \u4e3a\u5947\u6570\uff0c\u53ef\u4ee5\u5148\u548c\u53e6\u4e00\u4f4d $b$ \u4e5f\u4e3a\u5947\u6570\u7684\u5c0f\u670b\u53cb\u5404\u62ff $1$ \u5f20\u53d8\u6210\u5076\u6570\uff0c\u7136\u540e\u6309\u7167\u4e0a\u8ff0\u65b9\u6cd5\u5904\u7406\u3002\n\n\u4e8e\u662f\u7b54\u6848\u5c31\u6784\u9020\u5b8c\u6bd5\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}((n + m) ^ 2)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nconst int MaxN = 100, MaxM = 1000;\nconst int MaxV = 1102;\nconst int INF = 0x7F7F7F7F;\n\nstruct edge_t {\n  int to, cap, rev;\n  edge_t(int _to = 0, int _cap = 0, int _rev = 0) { to = _to, cap = _cap, rev = _rev; }\n};\n\nint N, M, K;\nint A[MaxN + 5];\nint U[MaxM + 5], V[MaxM + 5], W[MaxM + 5];\nstd::vector<edge_t> Gr[MaxV + 5];\n\nvoid init() {\n  scanf(\"%d %d\", &N, &M);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n  for (int i = 1; i <= M; ++i) scanf(\"%d %d\", &U[i], &V[i]);\n}\n\ninline void addEdge(int from, int to, int cap) {\n  Gr[from].push_back(edge_t(to, cap, (int) Gr[to].size()));\n  Gr[to].push_back(edge_t(from, 0, (int) Gr[from].size() - 1));\n}\n\nnamespace Dinic {\n\nint Level[MaxV + 5], Iter[MaxV + 5];\n\nvoid bfs(int s) {\n  static int que[MaxV + 5];\n  int head = 1, tail = 0;\n  memset(Level, -1, sizeof Level);\n  que[++tail] = s;\n  Level[s] = 0;\n  while (head <= tail) {\n    int u = que[head++];\n    for (int i = 0; i < (int) Gr[u].size(); ++i) {\n      edge_t e = Gr[u][i];\n      if (e.cap > 0 && Level[e.to] < 0) {\n        Level[e.to] = Level[u] + 1;\n        que[++tail] = e.to;\n      }\n    }\n  }\n}\n\nint dfs(int u, int t, int f) {\n  if (u == t) return f;\n  for (int &i = Iter[u]; i < (int) Gr[u].size(); ++i) {\n    edge_t &e = Gr[u][i];\n    if (e.cap > 0 && Level[e.to] > Level[u]) {\n      int d = dfs(e.to, t, std::min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        Gr[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t) {\n  int flow = 0;\n  for (;;) {\n    bfs(s);\n    if (Level[t] < 0) break;\n    memset(Iter, 0, sizeof Iter);\n    for (;;) {\n      int f = dfs(s, t, INF);\n      if (f == 0) break;\n      flow += f;\n    }\n  }\n  return flow;\n}\n\n}\n\nvoid solve() {\n  int Source = N + M + 1, Target = N + M + 2;\n  for (int i = 1; i <= M; ++i) {\n    addEdge(Source, i, 2);\n    addEdge(i, U[i] + M, 2);\n    addEdge(i, V[i] + M, 2);\n  }\n  for (int i = 1; i <= N; ++i)\n    addEdge(i + M, Target, A[i]);\n  Dinic::maxFlow(Source, Target);\n  for (int i = 1; i <= M; ++i)\n    for (int j = 0; j < (int) Gr[i].size(); ++j) {\n      edge_t e = Gr[i][j];\n      if (e.to == U[i] + M) W[i] = Gr[e.to][e.rev].cap;\n    }\n  static int b[MaxN + 5];\n  for (int i = 1; i <= N; ++i)\n    for (int j = 0; j < (int) Gr[i + M].size(); ++j) {\n      edge_t e = Gr[i + M][j];\n      if (e.to == Target) b[i] = e.cap;\n    }\n  K = M;\n  for (int i = 1; i <= N; ++i) {\n    while (b[i] > 1) {\n      K++;\n      U[K] = i, V[K] = 1 + (i == 1), W[K] = 2;\n      b[i] -= 2;\n    }\n  }\n  int lst1 = 0;\n  for (int i = 1; i <= N; ++i) {\n    if (b[i] == 0) continue;\n    if (lst1 == 0) lst1 = i;\n    else {\n      K++;\n      U[K] = lst1, V[K] = i, W[K] = 1;\n      lst1 = 0;\n    }\n  }\n  printf(\"%d\\n\", K);\n  for (int i = 1; i <= K; ++i)\n    printf(\"%d %d %d\\n\", U[i], V[i], W[i]);\n}\n\nint main() {\n  init();\n  solve();\n  return 0;\n}\n```",
        "postTime": 1588424717,
        "uid": 48843,
        "name": "Tweetuzki",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6472 \u3010[COCI2008-2009#6]SLICICE\u3011"
    }
]