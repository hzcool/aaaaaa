[
    {
        "content": "# **\u5173\u952e\u8bcd:LCT**\n\n\u5982\u679c\u6211\u4eec\u628a\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u8fb9\u6240\u7ec4\u6210\u7684\u56fe\u5355\u72ec\u62ff\u51fa\u6765\u770b\u7684\u8bdd:\n\n**\u4fdd\u8bc1\u6ca1\u6709\u540c\u8272\u7684\u73af\n\n\u4fdd\u8bc1\u4efb\u610f\u8282\u70b9\u8fde\u51fa\u53bb\u76f8\u540c\u989c\u8272\u7684\u8fb9\u4e0d\u8d85\u8fc7\u4e24\u6761**\n\n\u5f88\u660e\u663e\u5c31\u662f\u51e0\u6761\u94fe\u5427\n\n\u518d\u770b\u770b\u6211\u4eec\u9700\u8981\u652f\u6301\u7684\u64cd\u4f5c:\n\n**\u6539\u53d8\u8fb9\u7684\u989c\u8272(\u76f8\u5f53\u4e8e\u65ad\u4e00\u6b21\u8fb9,\u8fde\u4e00\u6b21\u8fb9)\n\n\u4fee\u6539\u6743\u503c\n\n\u67e5\u8be2\u8def\u5f84**\n\n\u5f88\u660e\u663e\u5c31\u662fLCT\u5427\n\n\u5404\u4f4d\u5982\u679c\u4e0d\u4f1aLCT\u7684\u8bf7\u53f3\u8f6c>https://www.luogu.org/problemnew/show/P3690\n\n\u6700\u540e\u770b\u4e00\u770b\u6570\u636e:\n\nN \u2264 10000,M \u2264 100000,C \u2264 10,K \u2264 100000\u3002\n\nO(NlogNC)\u76f4\u63a5**\u66b4\u529b\u627e\u989c\u8272**\u5c31\u597d\u5566\n\n**\u64cd\u4f5c0:**\n\n\u548c\u666e\u901a\u7684LCT\u5176\u5b9e\u5f88\u76f8\u4f3c.\u90a3\u4e48\u5982\u4f55\u540c\u65f6\u4fee\u6539\u591a\u4e2aLCT\u5462\uff08\u2299\uff4f\u2299\uff09\uff1f\n\n\u628a\u6240\u6709\u989c\u8272\u4e2dLCT\u7684\u4f4d\u7f6e\u90fd\u8f6c\u79fb\u5230LCT->\u4fee\u6539->\u5728\u6240\u6709\u989c\u8272\u7684LCT\u4e0aupdate\n\n**\u64cd\u4f5c1:**\n\n1.\u5bf9\u4e8e\u5982\u4f55\u5224\u65adu,v\u4e24\u4e2a\u70b9\u662f\u5426\u76f4\u63a5\u76f8\u8fde,\u8fd9\u91cc\u63a8\u8350\u53e6\u5916\u4e24\u79cd\u53ef\u884c\u7684\u529e\u6cd5:\n\n(1)maktroot(u),access(v),splay(v)\n\n\u8fd9\u6837\u5982\u679cu,v\u76f4\u63a5\u6709\u8fb9\u76f8\u8fde\u7684\u8bdd,v(\u5f53\u524dsplay\u7684\u6839\u8282\u70b9)\u7684\u513f\u5b50\u4e00\u5b9a\u662fu\u4e14u\u6ca1\u6709\u53f3\u513f\u5b50(\u5c31\u662fu,v\u5728splay\u91cc\u4e2d\u95f4\u6ca1\u6709\u5939\u5176\u4ed6\u7684\u70b9==\u6df1\u5ea6\u76f8\u90bb)\n\n(2)\u4e00\u5f00\u59cb\u5b58\u8fb9\u7684\u65f6\u5019\u76f4\u63a5\u5b58\u90bb\u63a5\u8868,\u7531\u4e8e\u6bcf\u4e2a\u70b9\u8fde\u8fb9\u7684\u603b\u6570\u4e0d\u8d85\u8fc72\\*C<=20,**\u5e38\u6570**\u4e0d\u5927\u5bf9\u5427......\n\n2.Error 1:\u8bb0\u5f55\u8fde\u8fb9\u6570\u7ec4d[c][x]\u8868\u793a\u70b9x\u5728\u989c\u8272c\u4e0a\u8fde\u8fb9\u7684\u6761\u6570,\u5e76\u5224\u65ad\n\n3.Error 2:\u5224\u65ad\u662f\u5426\u8054\u901a,\u5224\u65adfindroot(u)==findroot(v)\u5373\u53ef\n\n4.\u5728\u5f53\u524d\u989c\u8272\u7684LCT\u4e2d\u5220\u9664\u8fd9\u6761\u8fb9\u5e76\u4e14\u5728\u9700\u6c42\u989c\u8272\u7684LCT\u4e2d\u6dfb\u52a0\u8fd9\u6761\u8fb9\n\n5.\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9:\u65b0\u8fb9\u7684\u989c\u8272\u6709\u53ef\u80fd\u548c\u65e7\u8fb9\u7684\u989c\u8272\u76f8\u7b49!!!\u8bb0\u5f97\u52a0\u7279\u5224!!!\n\n**\u64cd\u4f5c2:**\n\n\u6a21\u677f\u4f3c\u7684\u67e5\u8be2...\u8bf7\u770b\u4ee3\u7801\n\n\n\u5c31\u662f\u8fd9\u6837\u4e86\n\n```cpp\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define RG register\nusing namespace std;\ninline int read(){\n    RG int data=0,w=1;RG char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n    if(ch=='-')w=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')data=data*10+ch-48,ch=getchar();\n    return data*w;\n}\nconst int N=10010;\nconst int M=100010;\nconst int C=10;\nint val[N],maxn[C][N],rv[C][N],s[2][C][N],fa[C][N],f[C][N];\nint cal[N],top;\nint d[C][N];\n\ninline void update(int c,int i){\n    maxn[c][i]=max(maxn[c][s[0][c][i]],max(maxn[c][s[1][c][i]],val[i]));\n}\ninline void pushdown(int c,int i){\n    if(!rv[c][i])return;rv[c][i]^=1;rv[c][s[0][c][i]]^=1;rv[c][s[1][c][i]]^=1;swap(s[0][c][i],s[1][c][i]);\n}\ninline bool isroot(int c,int i){\n    return s[0][c][fa[c][i]]!=i&&s[1][c][fa[c][i]]!=i;}\n\ninline bool isr(int c,int i){return s[1][c][fa[c][i]]==i;}\ninline void rot(int c,int i){\n    RG int j=fa[c][i],k=fa[c][j];\n    RG bool b=isr(c,i);\n    if(!isroot(c,j))\n        s[isr(c,j)][c][k]=i;\n    fa[c][i]=k;\n    s[b][c][j]=s[!b][c][i];\n    if(s[!b][c][i])fa[c][s[!b][c][i]]=j;\n    fa[c][j]=i;s[!b][c][i]=j;\n    update(c,j);\n}\n\ninline void splay(int c,int i){\n    cal[++top]=i;\n    for(RG int x=i;!isroot(c,x);x=fa[c][x])\n        cal[++top]=fa[c][x];\n    while(top)pushdown(c,cal[top--]);\n    for(RG int j=fa[c][i];!isroot(c,i);rot(c,i),j=fa[c][i])\n        if(!isroot(c,j))isr(c,i)^isr(c,j)?rot(c,i):rot(c,j);\n    update(c,i);\n}\n\ninline void access(int c,int x){for(RG int y=0;x;y=x,x=fa[c][x])splay(c,x),s[1][c][x]=y,update(c,x);}\ninline void makeroot(int c,int x){access(c,x);splay(c,x);rv[c][x]^=1;}\ninline int findroot(int c,int x){access(c,x);splay(c,x);while(s[0][c][x])x=s[0][c][x];return x;}\ninline void split(int c,int x,int y){makeroot(c,x);access(c,y);splay(c,y);}\ninline void cut(int c,int x,int y){\n    d[c][x]--;d[c][y]--;\n    split(c,x,y);fa[c][x]=s[0][c][y]=0;\n}\ninline void link(int c,int x,int y){\n    d[c][x]++;d[c][y]++;\n    makeroot(c,x);fa[c][x]=y;\n}\n//\u4ee5\u4e0a,\u4e00\u4e2a\u6b63\u5e38\u7684LCT\ninline void modify_val(int c){//\u64cd\u4f5c1\n    RG int x=read(),y=read();\n    for(RG int i=0;i<c;i++)access(i,x),splay(i,x);\n    val[x]=y;\n    for(RG int i=0;i<c;i++)update(i,x);\n    return;\n}\n\ninline void modify_line(int c){//\u64cd\u4f5c2\n    RG int u=read(),v=read(),w=read();\n    for(RG int i=0;i<c;i++)\n        if(findroot(i,u)==findroot(i,v))\n        {\n            split(i,u,v);\n            if(s[0][i][v]!=u||s[1][i][u])continue;\n            if(i==w){//\u6ce8\u610f\u6b64\u5904!!!\n                puts(\"Success.\");return;\n            }\n            if((d[w][u]==2)||(d[w][v]==2)){\n                puts(\"Error 1.\");return;\n            }\n            else if(findroot(w,u)==findroot(w,v)){\n                puts(\"Error 2.\");return;\n            }\n            else{\n                cut(i,u,v);link(w,u,v);\n                puts(\"Success.\");return;\n            }\n        }\n    puts(\"No such edge.\");\n}\n\ninline void query(){//\u64cd\u4f5c3\n    RG int c=read(),u=read(),v=read();\n    if(findroot(c,u)!=findroot(c,v)){puts(\"-1\");return;}\n    split(c,u,v);printf(\"%d\\n\",maxn[c][v]);\n}\n\ninline void print(int c,int i){\n    if(s[0][c][i])print(c,s[0][c][i]);\n    printf(\"(%d:%d)\\n\",i,c);\n    if(s[1][c][i])print(c,s[1][c][i]);\n}\n\nint main()\n{\n    RG int n,m,c,k,u,v,w,opt;\n    n=read();m=read();c=read();k=read();\n    for(RG int i=1;i<=n;i++)val[i]=read();\n    while(m--){\n        u=read();v=read();w=read();\n        link(w,u,v);\n    }\n    while(k--){\n        opt=read();\n        if(!opt)modify_val(c);\n        if(opt==1)modify_line(c);\n        if(opt==2)query();\n    }\n    return 0;\n}\n/*\n    \u98df\u7528LCT\n    \u64cd\u4f5c0:modify:access->splay->val->update\n    \u64cd\u4f5c1:cut\u6240\u5728\u989c\u8272\u7684\u8fb9->link\u4fee\u6539\u989c\u8272\u7684\u8fb9\n    \u627e\u5230\u989c\u8272:\u66b4\u529bO(C) \u627e\u4e0d\u5230->No such edge.\n    \u4fee\u6539:\u67e5\u8be2\u5ea6->if(d==2)->Error 1.\n    \u67e5\u8be2\u8054\u901a->if(findroot==findroot)->Error 2.\n    \u6210\u529f->Success.\n    \u64cd\u4f5c2:query:split->maxn\n*/\n\n```",
        "postTime": 1514607038,
        "uid": 47641,
        "name": "fdfdf",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u4e00\u9053\u6bd4\u8f83\u88f8\u7684LCT\uff0c\u53ef\u4ee5\u5229\u7528STL\u5077\u5077\u61d2\u7ef4\u62a4\u8fb9\u7684\u8bbf\u95ee\u60c5\u51b5~\n\n\u8fd9\u9898\u5982\u679c\u5355\u770b\u6bcf\u79cd\u989c\u8272\uff0c\u6211\u4eec\u53ea\u8981\u5efa\u4e00\u4e2aLCT\u5c31\u80fd\u8f7b\u677e\u6c34\u8fc7\u53bb\uff0c\u65e0\u975e\u662f\u8981\u52a0\u4e2acnt\n\n\u4f46\u662f\u989c\u8272\u591a\u600e\u4e48\u529e\uff1f\u8003\u8651\u989c\u8272\u79cd\u7c7b\u5f88\u5c0f\uff0c\u6211\u4eec\u591a\u5efa\u51e0\u4e2aLCT\u4e0d\u5c31\u884c\u4e86\u4e48\uff1f\n\n```cpp\n#include<bits/stdc++.h>\n#define N 10005\n#define M 100005\nusing namespace std;\nint n, m, c, k, u, v, w, op, x,val[N];\nstruct Link_Cut_Tree{\n    int c[N][2],fa[N],rev[N],maxv[N],cnt[N],q[N];\n    inline void pushup(int x){\n        maxv[x]=val[x];int l=c[x][0],r=c[x][1];\n        if(l)maxv[x]=max(maxv[x],maxv[l]);\n        if(r)maxv[x]=max(maxv[x],maxv[r]);\n    }\n    inline void pushdown(int x){\n        int l=c[x][0],r=c[x][1];\n        if(rev[x]){\n            rev[l]^=1;rev[r]^=1;rev[x]^=1;\n            swap(c[x][0],c[x][1]);\n        }\n    }\n    bool isroot(int x){return c[fa[x]][0]!=x&&c[fa[x]][1]!=x;}\n    void rotate(int x){\n        int y=fa[x],z=fa[y],l,r;\n        l=(c[y][1])==x;r=l^1;\n        if(!isroot(y))c[z][c[z][1]==y]=x;\n        fa[c[x][r]]=y;fa[y]=x;fa[x]=z;\n        c[y][l]=c[x][r];c[x][r]=y;\n        pushup(y);pushup(x);\n    }\n    void splay(int x){\n        int top=0;q[++top]=x;\n        for(int i=x;!isroot(i);i=fa[i])q[++top]=fa[i];\n        while(top)pushdown(q[top--]);\n        while(!isroot(x)){\n            int y=fa[x],z=fa[y];\n            if(!isroot(y)){\n            if(c[y][0]==x^c[z][0]==y)rotate(x);else rotate(y);\n            }\n        rotate(x);\n        }\n    }\n    void access(int x){for(int t=0;x;t=x,x=fa[x])splay(x),c[x][1]=t,pushup(x);}\n    void makeroot(int x){access(x);splay(x);rev[x]^=1;}\n    void link(int x,int y){cnt[x]++;cnt[y]++;makeroot(x);fa[x]=y;splay(x);}\n    void split(int x,int y){makeroot(x);access(y);splay(y);}\n    void cut(int x,int y){split(x,y);cnt[x]--;cnt[y]--;c[y][0]=fa[x]=0;pushup(y);}\n    int find(int x){access(x);splay(x);int y=x;while(c[y][0])y=c[y][0];return y;}\n    int querymax(int x,int y){split(x,y);return maxv[y];}    \n}lct[15];\ninline int read(){\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='0')f=-1;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\nstruct Edge{\n    int u,v;\n    bool operator<(const Edge &x)const{if(u!=x.u)return u<x.u;\n    else return v<x.v;}\n};\nmap<Edge,int> mp;\nint main(){\n    n=read();m=read();c=read();k=read();\n    for(int i=1;i<=n;i++)val[i]=read();\n    for(int i=1;i<=m;i++){\n        int u=read(),v=read(),w=read();\n        w++;\n        Edge e1=(Edge){u,v},e2=(Edge){v,u};\n        mp[e1]=mp[e2]=w;\n        lct[w].link(u,v);\n    }\n    while(k--){\n        int opt=read();\n        if(opt==0){\n            int x=read(),w=read();\n            val[x]=w;\n            for(int i=1;i<=c;i++)lct[i].splay(x);\n        }\n        else if(opt==1){\n            int u=read(),v=read(),w=read();\n            w++;\n            Edge a=(Edge){u,v},b=(Edge){v,u};\n            if(!mp.count(a)){\n                puts(\"No such edge.\");continue;\n            }\n            int xxx=mp[a];\n            if(xxx==w){\n                puts(\"Success.\");continue;\n            }\n            if(lct[w].cnt[u]>=2||lct[w].cnt[v]>=2){\n                puts(\"Error 1.\");continue;\n            }\n            if(lct[w].find(u)==lct[w].find(v)){\n                puts(\"Error 2.\");continue;\n            }\n            puts(\"Success.\");\n            lct[xxx].cut(u,v);lct[w].link(u,v);\n            mp[a]=mp[b]=w;\n        }else{\n            int w=read(),u=read(),v=read();\n            w++;\n            if(lct[w].find(u)!=lct[w].find(v)){\n                puts(\"-1\");continue;\n            }\n            printf(\"%d\\n\",lct[w].querymax(u,v));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1493460323,
        "uid": 2978,
        "name": "zcysky",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "LCT \u633a\u677f\u5b50\u7684\u4e00\u9053\u9898\u5427\u3002\n\n\u6211\u4eec\u8003\u8651 $c\\le10$ \u5f88\u5bb9\u6613\u53ef\u4ee5\u60f3\u5230\u66b4\u529b\u628a 10 \u68f5 LCT \u5efa\u7acb\u51fa\u6765\uff0c\u7136\u540e\u5728\u4ed6\u4eec\u4e0a\u9762\u64cd\u4f5c\u3002\n\n\u5148\u8003\u8651\u4fee\u6539\u6743\u503c\u7684\u64cd\u4f5c\u3002\u672c\u8d28\u4e0a\u5c31\u662f\u628a val \u503c\u6539\u6389\uff0c\u7136\u540e\u6bcf\u4e00\u68f5 LCT \u90fd\u53bb splay \u4e00\u904d\u4f20\u9012\u4fe1\u606f\u3002\n\n\u7136\u540e\u8003\u8651\u4fee\u6539\u989c\u8272\u3002\u5224\u662f\u5426\u5b58\u5728\u53ef\u4ee5\u7528\u4e00\u4e2a map \u5b58\u50a8\u8bb0\u5f55\u3002\u8fb9\u6570\u4e5f\u53ef\u4ee5\u5728 link cut \u7684\u65f6\u5019\u987a\u4fbf\u8bb0\u5f55\u4e00\u4e0b\u3002\u5224\u73af\u5c31\u4e0d\u7528\u8bf4\u4e86\u5427\uff0c\u76f4\u63a5\u5224\u65ad\u4e24\u4e2a\u70b9\u7684 findroot \u662f\u5426\u76f8\u7b49\u5c31\u53ef\u4ee5\u4e86\uff0c\u7136\u540e\u6ce8\u610f\u5220/\u8fde\u8fb9\u7684\u65f6\u5019\u8981\u987a\u4fbf\u628a map \u4e5f\u66f4\u65b0\u4e00\u4e0b\u3002\n\n\u67e5\u8be2\u64cd\u4f5c\u9700\u8981\u5148\u5224\u65ad\u662f\u5426\u8fde\u901a\uff0c\u5982\u679c\u8fde\u901a\u5c31\u628a\u4e24\u4e2a\u70b9 split \u51fa\u6765\uff0c\u5728 LCT \u91cc\uff08pushup \u7684\u65f6\u5019\uff09\u7ef4\u62a4\u4e00\u4e2a max \u503c\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(nclogn)$\uff0c\u6ce8\u610f\u8fde\u8fb9\u7684\u65f6\u5019\u53ea\u8fde\u4e00\u68f5\u6811\u7684\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n, m, cc, k;\nconst int maxn = 1e4 + 10, maxc = 11;\nint val[maxn], w[maxn];\nstruct link_cut_tree\n{\n    int fa[maxn], sum[maxn], tag[maxn], sta[maxn], ch[maxn][2], cnt[maxn];\n    int get(int x)\n    {\n        return ch[fa[x]][0] == x || ch[fa[x]][1] == x;\n    }\n    void pushup(int x)\n    {\n        sum[x] = max(val[x], max(sum[ch[x][0]], sum[ch[x][1]]));\n    }\n    void flip(int x)\n    {\n        swap(ch[x][0], ch[x][1]);\n        tag[x] ^= 1;\n    }\n    void pushdown(int x)\n    {\n        if (!tag[x])\n            return;\n        if (ch[x][0])\n            flip(ch[x][0]);\n        if (ch[x][1])\n            flip(ch[x][1]);\n        tag[x] = 0;\n        return;\n    }\n    void rotate(int x)\n    {\n        int y = fa[x], z = fa[y];\n        int k1 = (ch[y][1] == x);\n        int v = ch[x][!k1];\n        if (get(y))\n        {\n            ch[z][ch[z][1] == y] = x;\n        }\n        ch[x][!k1] = y;\n        ch[y][k1] = v;\n        if (v)\n        {\n            fa[v] = y;\n        }\n        fa[y] = x;\n        fa[x] = z;\n        pushup(y);\n        pushup(x);\n    }\n    void splay(int x)\n    {\n        int top = 0;\n        int y = x, z;\n        sta[++top] = y;\n        while (get(y))\n            sta[++top] = y = fa[y];\n        while (top)\n            pushdown(sta[top--]);\n        while (get(x))\n        {\n            y = fa[x], z = fa[y];\n            if (get(y))\n            {\n                rotate((ch[y][0] == x) ^ (ch[z][0] == y) ? x : y);\n            }\n            rotate(x);\n        }\n        pushup(x);\n        return;\n    }\n    void access(int x)\n    {\n        for (int y = 0; x; x = fa[y = x])\n        {\n            splay(x);\n            ch[x][1] = y;\n            pushup(x);\n        }\n    }\n    int findroot(int x)\n    {\n        access(x);\n        splay(x);\n        while (ch[x][0])\n        {\n            pushdown(x);\n            x = ch[x][0];\n        }\n        return x;\n    }\n    void makeroot(int x)\n    {\n        access(x);\n        splay(x);\n        flip(x);\n    }\n    void split(int x, int y)\n    {\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n    void link(int x, int y)\n    {\n\n        makeroot(x);\n        ++cnt[x], ++cnt[y];\n        fa[x] = y;\n    }\n    void cut(int x, int y)\n    {\n        split(x, y);\n        --cnt[x], --cnt[y];\n        fa[x] = ch[y][0] = 0;\n        pushup(y);\n    }\n} Tree[11];\nstruct node\n{\n    int u, v;\n    bool operator<(const node &x) const\n    {\n        if (u != x.u)\n            return u < x.u;\n        else\n            return v < x.v;\n    }\n};\nmap<node, int> mp;\nint main()\n{\n    scanf(\"%d%d%d%d\", &n, &m, &cc, &k);\n    for (int i = 1; i <= n; ++i)\n    {\n        scanf(\"%d\", &val[i]);\n    }\n    for (int i = 1; i <= m; ++i)\n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        ++c;\n        Tree[c].link(a, b);\n        node X = (node){a, b}, Y = (node){b, a};\n        mp[X] = mp[Y] = c;\n    }\n    for (int i = 1; i <= k; ++i)\n    {\n        int opt, x, y, z;\n        scanf(\"%d%d%d\", &opt, &x, &y);\n        if (opt == 0)\n        {\n            val[x] = y;\n            for (int j = 1; j <= cc; ++j)\n            {\n                Tree[j].splay(x);\n            }\n        }\n        if (opt == 1)\n        {\n            scanf(\"%d\", &z);\n            ++z;\n            node X = (node){x, y}, Y = (node){y, x};\n            if (mp.count(X) == 0)\n            {\n                puts(\"No such edge.\");\n                continue;\n            }\n            int Col = mp[X];\n            if (Col == z)\n            {\n                puts(\"Success.\");\n                continue;\n            }\n            if (Tree[z].cnt[x] >= 2 || Tree[z].cnt[y] >= 2)\n            {\n                puts(\"Error 1.\");\n                continue;\n            }\n            if (Tree[z].findroot(x) == Tree[z].findroot(y))\n            {\n                puts(\"Error 2.\");\n                continue;\n            }\n            puts(\"Success.\");\n            Tree[Col].cut(x, y);\n            Tree[z].link(x, y);\n            mp[X] = mp[Y] = z;\n        }\n        if (opt == 2)\n        {\n            scanf(\"%d\", &z);\n            ++x;\n            if (Tree[x].findroot(y) != Tree[x].findroot(z))\n            {\n                puts(\"-1\");\n                continue;\n            }\n            Tree[x].split(y, z);\n            printf(\"%d\\n\", Tree[x].sum[z]);\n        }\n    }\n}\n```\n",
        "postTime": 1609834618,
        "uid": 150190,
        "name": "Antarctican",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "### \u7b80\u4ecb\uff1a\n\n~~\uff08\u8fd9\u9898\u6709\u4e2a\u5751\u70b9\uff1a\u8fb9\u8981\u4fee\u6539\u6210\u7684\u989c\u8272\u53ef\u80fd\u8ddf\u539f\u6765\u7684\u989c\u8272\u4e00\u6837\u3002)~~\n\n### \u5206\u6790\uff1a\n\u6839\u636e\u9898\u76ee\u63cf\u8ff0\u548c\u6761\u4ef62\u53ef\u77e5\uff0c\u7531\u76f8\u540c\u989c\u8272\u7684\u8fb9\u6240\u7ec4\u6210\u7684\u96c6\u5408\u5c31\u662f\u4e00\u68f5\u6811\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u4f7f\u7528 LCT \u6765\u7ef4\u62a4\u64cd\u4f5c\u4e86\u3002\n\n- ####  \u4e3a\u4e86\u4fbf\u4e8e\u8ba8\u8bba\uff0c\u5c06\u4ee5\u4e0b\u91cf\u6362\u6210\u4ee3\u7801\u4e2d\u5b9a\u4e49\u7684\u53d8\u91cf\uff1a\n1. \u7531\u989c\u8272\u7f16\u53f7\u4e3a i \u7684\u8fb9\u7ec4\u6210\u7684\u6811\u4e3a lct[i]\u3002\n1. \u7531\u4e00\u6761\u8fb9\u6240\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u5206\u522b\u4e3a p1,p2\u3002\n1. \u4e00\u6761\u8fb9\u539f\u6765\u7684\u989c\u8272\u4e3a lc\u3002\n1. \u4e00\u6761\u8fb9\u8981\u4fee\u6539\u6210\u7684\u989c\u8272\u4e3a nc\u3002\n1. \u7531\u4e00\u70b9 p \u6240\u8fde\u63a5\u51fa\u989c\u8272\u4e3a i \u7684\u8fb9\u7684\u6570\u91cf\u4e3a tot[p][i]\u3002\n\n- #### \u5bf9\u4e8e\u64cd\u4f5c0\uff1a\n\n\u867d\u7136\u4f7f\u7528 LCT \u5c31\u9700\u8981\u628a\u4e00\u4e2a\u70b9\u653e\u5728\u591a\u68f5\u6811\u4e2d\uff0c\u4f46\u662f C \u7684\u8303\u56f4\u5e76\u4e0d\u5927\uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u4f7f\u7528 LCT \u66b4\u529b\u4fee\u6539\u8be5\u70b9\u5728\u6240\u6709\u6811\u4e2d\u7684\u7684\u6743\u503c\u3002\n\n- #### \u5bf9\u4e8e\u64cd\u4f5c1\uff1a\n\n\u4f7f\u7528 LCT \u66b4\u529b\u67e5\u627e lc\uff08\u539f\u56e0\u540c\u64cd\u4f5c0\uff09\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u8be5\u8fb9\u5c31\u76f4\u63a5\u8f93\u51fa \"No such edge.\" \u3002\u7136\u540e\u5224\u65ad lc \u662f\u5426\u7b49\u4e8e nc \uff1a\u5982\u679c lc \u7b49\u4e8e nc \uff0c\u5c31\u76f4\u63a5\u8f93\u51fa \"Success.\" \u3002\u5426\u5219\uff0c\u5224\u65ad tot[p1][nc] \u548c tot[p2][nc] \u662f\u5426\u5927\u4e8e1\uff0c\u5982\u679c\u5927\u4e8e1\uff0c\u5c31\u8f93\u51fa \"Error 1.\" \u3002\u6700\u540e\u5224\u65ad\u4e00\u4e0b p1 \u548c p2 \u5728 lct[nc] \u7684\u8fde\u901a\u60c5\u51b5\uff1a\u5982\u679c\u5b83\u4eec\u5df2\u7ecf\u8fde\u901a\uff0c\u8bf4\u660e\u5728 lct[nc] \u4e2d\u8fde\u63a5\u4e86\u8fd9\u6761\u8fb9\u540e, lct[nc] \u4e2d\u5c31\u51fa\u73b0\u4e86\u4e00\u6761\u73af\uff0c\u6240\u4ee5\u6839\u636e\u9898\u610f\u8f93\u51fa \"Error 2.\" \u3002\u5426\u5219\uff0c\u64cd\u4f5c\u6210\u529f\uff0c\u8f93\u51fa \"Success.\" \u3002\n\n- #### \u5bf9\u4e8e\u64cd\u4f5c2\uff1a\n\n~~LCT\u6a21\u677f\u3002~~\n\n### Code\n```c\n#include<bits/stdc++.h>\n#define N (int)(1e4+1)\n#define M 5001\n#define R register\n#define INFI 0x7fffffff\n#define INFL 0x7fffffffffffffff\n#define F(i,start,end) for(R int (i)=(start);(i)<=(end);i++)\nusing namespace std;\ntemplate<typename T> void read(T &x)\n{\n\tint f=1;\n\tx=0;\n\tchar c=getchar();\n\twhile(!isdigit(c))\n\t{\n\t\tif(c=='-')\n\t\t\tf=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\n\t{\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\tx=x*f;\n}\nvoid write(int x)\n{\n\tif(x<0)\n\t\tx=~x+1,putchar('-');\n\tif(x>9)\n\t\twrite(x/10);\n\tputchar(x%10+'0');\n}\nstruct link_cut_tree\n{\n\t#define ls tree[p].son[0]\n\t#define rs tree[p].son[1]\n\t#define fa tree[p].f\n\t#define anc tree[fa].f \n\tstack<int> s;\n\tstruct node\n\t{\n\t\tint f,son[2],mx,val;\n\t\tbool tip;\n\t}tree[N];\n\tint merge(int p1,int p2)//\u5408\u5e76\u5de6\u53f3\u5b50\u8282\u70b9\u4fe1\u606f\n\t{\n\t\treturn max(tree[p1].mx,tree[p2].mx);\n\t}\n\tvoid pushup(int p)//\u66f4\u65b0\u5f53\u524d\u8282\u70b9\u7684\u4fe1\u606f\n\t{\n\t\ttree[p].mx=max(merge(ls,rs),tree[p].val);\n\t\treturn;\n\t}\n\tvoid pushdown(int p)//\u91ca\u653e\u8be5\u70b9\u7684\u65cb\u8f6c\u61d2\u6807\u8bb0\n\t{\n\t\tif(tree[p].tip)\n\t\t{\n\t\t\ttree[ls].tip^=1;\n\t\t\ttree[rs].tip^=1;\n\t\t\ttree[p].tip^=1;\n\t\t\tswap(ls,rs);\n\t\t}\n\t\treturn;\n\t}\n\tvoid connect(int p,int f,bool k)//\u8fde\u8fb9\n\t{\n\t\ttree[p].f=f;\n\t\ttree[f].son[k]=p;\n\t\treturn;\n\t}\n\tbool identify(int p)//\u8bc6\u522b\u7236\u5b50\u8282\u70b9\u5173\u7cfb\n\t{\n\t\treturn tree[fa].son[1]==p;\n\t}\n\tbool check(int p)//\u8bc6\u522b\u8be5\u8282\u70b9\u662f\u5426\u4e3a\u5176\u6240\u5728splay\u4e2d\u7684\u6839\n\t{\n\t\treturn tree[fa].son[0]!=p&&tree[fa].son[1]!=p;\n\t}\n\tvoid rotate(int p)//\u65cb\u8f6c\n\t{\n\t\tint f=fa,a=anc;\n\t\tbool fs=identify(p),as=identify(f);\n\t\tif(!check(f))\n\t\t\ttree[a].son[as]=p;\n\t\ttree[p].f=a;\n\t\tconnect(tree[p].son[fs^1],f,fs);\n\t\tconnect(f,p,fs^1);\n\t\tpushup(f);\n\t\tpushup(p);\n\t\treturn;\n\t}\n\tvoid splay(int p)//\u65cb\u8f6c\u8be5\u8282\u70b9\u6240\u5728\u7684\u6574\u4e2asplay\n\t{\n\t\tint temp=p;\n\t\twhile(!check(p))\n\t\t{\n\t\t\ts.push(p);\n\t\t\tp=fa;\n\t\t}\n\t\ts.push(p);\n\t\tp=temp;\n\t\twhile(s.size())\n\t\t{\n\t\t\tpushdown(s.top());\n\t\t\ts.pop();\n\t\t}\n\t\twhile(!check(p))\n\t\t\tif(check(fa))\n\t\t\t\trotate(p);\n\t\t\telse\n\t\t\t\tif(identify(p)==identify(fa))\n\t\t\t\t\trotate(fa),rotate(p);\n\t\t\t\telse\n\t\t\t\t\trotate(p),rotate(p);\n\t\treturn;\n\t}\n\tvoid access(int p)//\u7ed9\u8be5\u8282\u70b9\u62c9\u4e00\u6761\u5230\u6839\u7684\u8def\u5f84\n\t{\n\t\tint f=0;\n\t\twhile(p)\n\t\t{\n\t\t\tsplay(p);\n\t\t\trs=f;\n\t\t\tpushup(p);\n\t\t\tf=p;\n\t\t\tp=fa;\n\t\t}\n\t\treturn;\n\t}\n\tvoid modify(int p)//\u6362\u6839\n\t{\n\t\taccess(p);\n\t\tsplay(p);\n\t\ttree[p].tip^=1;\n\t\treturn;\n\t}\n\tint find(int p)//\u67e5\u627e\u8be5\u70b9\u6240\u5728splay\n\t{\n\t\taccess(p);\n\t\tsplay(p);\n\t\twhile(ls)\n\t\t\tp=ls;\n\t\treturn p;\n\t}\n\tvoid split(int p1,int p2)\n\t{\n\t\tmodify(p1);\n\t\taccess(p2);\n\t\tsplay(p2);\n\t\treturn;\n\t}\n\tbool link(int p1,int p2)//\u8fde\u8fb9\n\t{\n\t\tint f1=find(p1),f2=find(p2);\n\t\tif(f1==f2)\n\t\t\treturn 0;\n\t\tmodify(p1);\n\t\ttree[p1].f=p2;\n\t\treturn 1;\n\t}\n\tvoid cut(int p1,int p2)//\u5220\u8fb9\n\t{\n\t\tsplit(p1,p2);\n\t\ttree[p2].son[0]=0;\n\t\ttree[p1].f=0;\n\t\treturn;\n\t}\n\tbool judge(int p1,int p2,bool k)//k\u4e3a0\uff0c\u5224\u65ad\u7684\u662fp1\u3001p2\u4e4b\u95f4\u6709\u65e0\u8def\u5f84\uff1bk\u4e3a1\uff0c\u5224\u65ad\u7684\u662fp1\u3001p2\u4e4b\u95f4\u6709\u65e0\u8fb9\n\t{\n\t\tint f1=find(p1),f2=find(p2);\n\t\tif(f1!=f2)\n\t\t\treturn 0;\n\t\tif(!k)\n\t\t\treturn 1;\n\t\tsplit(p1,p2);\n\t\tif(tree[p2].son[0]==p1&&!tree[p1].son[1])\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\tvoid change(int p,int val)//\u66f4\u65b0\u7ed3\u70b9\u6743\u503c\n\t{\n\t\taccess(p);\n\t\tsplay(p);\n\t\ttree[p].val=val;\n\t\tpushup(p);\n\t\treturn;\n\t}\n\t#undef ls\n\t#undef rs\n\t#undef fa\n\t#undef anc\n}lct[10];\nint n,m,c,k,tot[N][10],opt;\nint main()\n{\n\tread(n),read(m),read(c),read(k);\n\tF(i,1,n)\n\t{\n\t\tint num;\n\t\tread(num);\n\t\tF(j,0,c-1)//\u521d\u59cb\u5316\n\t\t{\n\t\t\tlct[j].tree[i].val=num;\n\t\t\tlct[j].tree[i].mx=num;\n\t\t}\n\t}\n\tF(i,1,m)\n\t{\n\t\tint p1,p2,nc;\n\t\tread(p1),read(p2),read(nc);\n\t\tlct[nc].link(p1,p2);//\u8fde\u8fb9\n\t\ttot[p1][nc]++;\n\t\ttot[p2][nc]++;\n\t}\n\tF(i,1,k)\n\t{\n\t\tread(opt);\n\t\tif(!opt)//\u540c\u5206\u67900\n\t\t{\n\t\t\tint x,y;\n\t\t\tread(x),read(y);\n\t\t\tF(i,0,c-1)\n\t\t\t\tlct[i].change(x,y);\n\t\t}\n\t\tif(opt==1)//\u540c\u5206\u67901\n\t\t{\n\t\t\tint p1,p2,nc,lc=-1;\n\t\t\tread(p1),read(p2),read(nc);\n\t\t\tF(i,0,c-1)\n\t\t\t\tif(lct[i].judge(p1,p2,1))\n\t\t\t\t{\n\t\t\t\t\tlc=i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(lc==-1)\n\t\t\t{\n\t\t\t\tputs(\"No such edge.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(nc==lc)\n\t\t\t{\n\t\t\t\tputs(\"Success.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(tot[p1][nc]>1||tot[p2][nc]>1)\n\t\t\t{\n\t\t\t\tputs(\"Error 1.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(!lct[nc].link(p1,p2))\n\t\t\t{\n\t\t\t\tputs(\"Error 2.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlct[lc].cut(p1,p2);\n\t\t\ttot[p1][lc]--;\n\t\t\ttot[p2][lc]--;\n\t\t\ttot[p1][nc]++;\n\t\t\ttot[p2][nc]++;\n\t\t\tputs(\"Success.\");\n\t\t}\n\t\tif(opt==2)//\u6a21\u677f\uff0c\u4e0d\u591a\u505a\u89e3\u91ca\n\t\t{\n\t\t\tint lc,p1,p2;\n\t\t\tread(lc),read(p1),read(p2);\n\t\t\tif(!lct[lc].judge(p1,p2,0))\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlct[lc].split(p1,p2);\n\t\t\twrite(lct[lc].tree[p2].mx);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n \treturn 0;\n}\n```\n\n\n\n",
        "postTime": 1609495311,
        "uid": 219402,
        "name": "FANTASTlC",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u64cd\u4f5c\u6709\u4e09\u79cd\uff1a\n1. \u6539\u70b9\u7684\u6743\u503c\n2. \u6539\u8fb9\u7684\u6743\u503c\n3. \u8def\u5f84\u6700\u5927\u503c\n\n\u770b\u4e0a\u53bb\u6beb\u65e0\u601d\u8def\uff0c\u62c9\u5230\u6700\u540e\u9762\u6570\u636e\u8303\u56f4\uff1a$1 \\leq C \\leq 10$\uff0c\u663e\u7136\u8fd9\u91cc\u662f\u7a81\u7834\u53e3\u3002\n\n\u8003\u8651\u5728\u989c\u8272\u7684\u95ee\u9898\u4e0a\uff0c\u6211\u4eec\u5b8c\u5168\u53ef\u4ee5\u91c7\u7528\u66b4\u529b\uff0c\u628a\u76f8\u540c\u989c\u8272\u7684\u7528\u4e00\u9897\u52a8\u6001\u6811\u7ef4\u62a4\u3002\n\n\u90a3\u4e48\u73b0\u5728\u5c31\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n1. \u6539\u70b9\u7684\u6743\u503c\n2. \u5220\u6389\u4e00\u6761\u8fb9\u7136\u540e\u91cd\u5efa\n3. \u8def\u5f84\u6700\u5927\u503c\n\n\u76f4\u63a5\u5bf9\u6bcf\u4e00\u79cd\u989c\u8272\u5efa\u52a8\u6001\u6811\u5373\u53ef\u3002\n\n\u6ce8\u610f\uff1a\n\n1. STL\u7684stack\u5e38\u6570\u5f88\u5927\uff0c\u4e0d\u8981\u7528\uff0c\u4f1a\u88ab\u5361\u5230\u98de\u8d77\n2. \u4fee\u6539\u65f6\u76f4\u63a5\u5bf9\u6240\u6709\u8fb9\u66b4\u529b\u4fee\u6539\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(nclog_2 n)$\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\ninline ll read(){\n    ll x=0,tmp=1;\n    char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-') tmp=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch)){\n        x=(x<<3)+(x<<1)+(ch^48);\n        ch=getchar();\n    }\n    return tmp*x;\n}\n\nconst ll N=10010,M=15;\nll n,m,c,K,cnt[N][M],st[N];\nstruct {\n    struct Link_Cut_tree{\n        ll son[2],val,size,Max,father,lazy;\n    }tree[N];\n    \n    inline bool isroot(ll p){\n        return tree[tree[p].father].son[0]!=p&&tree[tree[p].father].son[1]!=p;\n    }\n    \n    inline void pushup(ll p){\n        tree[p].size=tree[tree[p].son[0]].size+tree[tree[p].son[1]].size+1;\n        tree[p].Max=max(tree[p].val,max(tree[tree[p].son[0]].Max,tree[tree[p].son[1]].Max));\n    }\n    \n    inline void reverse(ll p){\n        tree[p].lazy^=1;\n        swap(tree[p].son[0],tree[p].son[1]);\n    }\n\n    inline void pushdown(ll p){\n        if(tree[p].lazy){\n            reverse(tree[p].son[0]);\n            reverse(tree[p].son[1]);\n            tree[p].lazy=0;\n        }\n    }\n    \n    inline bool which(ll p){\n        return tree[tree[p].father].son[1]==p;\n    }\n    \n    inline void rotate(ll p){\n        ll fa=tree[p].father,fafa=tree[fa].father;\n        bool w=which(p);\n        if(!isroot(fa)) tree[fafa].son[which(fa)]=p;\n        tree[fa].son[w]=tree[p].son[w^1];\n        tree[tree[p].son[w^1]].father=fa;\n        tree[p].son[w^1]=fa;\n        tree[fa].father=p;\n        tree[p].father=fafa;\n        pushup(fa); pushup(p);\n    }\n\n    inline void splay(ll p){\n        ll top=0;\n        st[++top]=p;\n        for(ll i=p; !isroot(i); i=tree[i].father) st[++top]=tree[i].father;\n        while(top){\n            pushdown(st[top]);\n            st[top--]=0;\n        }\n        for(ll i=tree[p].father; !isroot(p); rotate(p),i=tree[p].father){\n            if(!isroot(i)){\n                if(which(i)==which(p)) rotate(i);\n                else rotate(p);\n            }\n        }\n        pushup(p);\n    }\n\n    inline void access(ll p){\n        for(ll y=0; p; p=tree[y=p].father){\n            splay(p);\n            tree[p].son[1]=y;\n            pushup(p);\n        }\n    }\n\n    inline ll getroot(ll p){\n        access(p);\n        splay(p);\n        while(tree[p].son[0]){\n            pushdown(p);\n            p=tree[p].son[0];\n        }\n        return p;\n    }\n\n    inline ll makeroot(ll p){\n        access(p);\n        splay(p);\n        reverse(p);\n    }\n\n    inline ll link(ll x,ll y,ll w){\n        if(cnt[x][w]==2||cnt[y][w]==2) return 2;\n        if(getroot(x)==getroot(y)) return 1;\n        cnt[x][w]++; cnt[y][w]++;\n        makeroot(x);\n        tree[x].father=y;\n        return 0;\n    }\n\n    inline void split(ll x,ll y){\n        makeroot(y);\n        access(x);\n        splay(x);\n    }\n\n    inline ll cut(ll x,ll y,ll w){\n        split(x,y);\n        if(y!=tree[x].son[0]||tree[y].father!=x||tree[y].son[1]) return 1;\n        tree[x].son[0]=tree[y].father=0;\n        pushup(x);\n        cnt[x][w]--; cnt[y][w]--;\n        return 0;\n    }\n\n    inline void update(ll x,ll val){\n        split(x,x);\n        tree[x].val=tree[x].Max=val;\n    }\n\n    inline ll query(ll x,ll y){\n        split(x,y);\n        if(getroot(x)!=y) return -1;\n        return tree[x].Max;\n    }\n}lct[M];\n\ninline void update(ll x,ll val){\n    for(ll i=0; i<c; i++) lct[i].update(x,val);\n}\n\ninline ll cut_and_link(ll x,ll y,ll w){\n    ll cnt=3;\n    for(ll i=0; i<c; i++){\n        if(lct[i].cut(x,y,i)==0){\n            cnt=lct[w].link(x,y,w);\n            if(cnt) lct[i].link(x,y,i);\n            break;\n        }\n    }\n    return cnt;\n}\n\ninline ll query(ll x,ll y,ll w){\n    return lct[w].query(x,y);\n}\n\nint main(){\n    n=read(); m=read(); c=read(); K=read();\n    for(ll i=1; i<=n; i++) update(i,read());\n    while(m--){\n        ll x=read(),y=read(),w=read();\n        lct[w].link(x,y,w);\n    }\n    while(K--){\n        ll op=read();\n        switch(op){\n            case 0:{\n                ll x=read(),val=read();\n                update(x,val);\n                break;\n            }\n            case 1:{\n                ll x=read(),y=read(),w=read();\n                ll t=cut_and_link(x,y,w);\n                switch(t){\n                    case 0:{\n                        printf(\"Success.\\n\");\n                        break;\n                    }\n                    case 1:{\n                        printf(\"Error 2.\\n\");\n                        break;\n                    }\n                    case 2:{\n                        printf(\"Error 1.\\n\");\n                        break;\n                    }\n                    case 3:{\n                        printf(\"No such edge.\\n\");\n                        break;\n                    }\n                    default:{\n                        cout<<\"FUCK t \"<<t<<endl;\n                    }\n                }\n                break;\n            }\n            case 2:{\n                ll w=read(),x=read(),y=read();\n                printf(\"%lld\\n\",query(x,y,w));\n                break;\n            }\n            default:{\n                cout<<\"FUCK op \"<<op<<endl;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1579254103,
        "uid": 27924,
        "name": "xukuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "[\u4f20\u9001\u95e8](https://www.luogu.org/problem/P2173?contestId=36)\n\n\u8fd9\u662f\u4e00\u9053\u51fd\u6570\u5f88\u6742\u7684LCT\u9898\u3002\uff08\u6709\u70b9\u7c7b\u4f3cQtree6\uff0cQtree7\u3002\u4f46\u7565\u96be\u3002\uff09\n# \u601d\u8def\uff1a\nc\u90a3\u4e48\u5c0f\uff0c\u76f4\u63a5\u5efac\u68f5\u6811\u3002\n\n\u5904\u7406\u65b9\u5f0f\uff1a\n\n 0.  \u66f4\u6539\u6bcf\u68f5\u6811\u4e0a\u8be5\u70b9\u7684\u503c\u3002\n 1. \u6700\u96be\u70b9\u3002\u5148\u627e\u5230\u8fb9\u7684\u989c\u8272\uff08\u4e00\u9897\u4e00\u9897\u627e\uff09\uff0c\u5982\u679c\u627e\u4e0d\u5230\uff0c\u8f93\u51fa\u201cNo such edge.\u201d\u3002\n \u5982\u679c\u8fb9\u7684\u989c\u8272\u4e0e\u66f4\u6539\u540e\u7684\u76f8\u540c\uff0c\u8f93\u51fa\u201cSuccess.\u201d\u3002\u7528$cnt[x][y]$\u8868\u793a\u4e0ex\u76f8\u8fde\u7684\u989c\u8272\u4e3ay\u7684\u8fb9\u7684\u8fb9\u6570,\u5c31\u53ef\u4ee5\u65b9\u4fbf\u5730\u5224\u201cError 1.\u201d\u8bbe\u53d8\u5316\u540e\u7684\u989c\u8272\u4e3aw\uff0c\u82e5\u5728\u5bf9\u5e94\u7684\u6811\u4e0a\u4e24\u4e2a\u70b9\u5df2\u7ecf\u8054\u901a\uff0c\u5219\u8f93\u51fa\u201cError 2.\u201d\u6700\u540e\uff0c\u5220\u8fb9\u5efa\u8fb9\uff0c\u8f93\u51fa\u201cSuccess.\"\u5c31\u884c\u3002\n 2.  splay\u8282\u70b9\u52a0\u4e00\u4e2amx\u53c2\u6570\u5373\u53ef\u3002\n \n # \u4ee3\u7801\uff1a\n \n\n```cpp\n#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<algorithm>\n#define g g()\n#define lc tr[x].son[0]\n#define rc tr[x].son[1]\nusing namespace std;\nconst int N=1e4+10,inf=0x7fffffff,size=1<<25;\nint d[N];struct node{int f,son[2],mx;bool v;};\nint n,m,c,k;char cnt[N][12];\nstruct Link_Cut_Tree{\n\tnode tr[N];\n\tvoid update(int x){tr[x].mx=max(d[x],max(tr[lc].mx,tr[rc].mx));}\n\tvoid fz(int x){//\u7ffb\u8f6c \n\t\ttr[x].v=0;swap(lc,rc);\n\t\ttr[lc].v^=1;tr[rc].v^=1;\n\t}\n\tbool rt(int x){return tr[tr[x].f].son[0]!=x&&tr[tr[x].f].son[1]!=x;}//\u662f\u5426\u4e3a\u6839 \n\tvoid dfs(int x){//\u9012\u5f52\u7ef4\u62a4 \n\t\tif(!rt(x))dfs(tr[x].f);\n\t\tif(tr[x].v)fz(x);\n\t}\n\tvoid rotate(int x,int w){//\u65cb\u8f6c \n\t\tint f=tr[x].f,ff=tr[f].f,r,R;\n\t\tr=tr[x].son[w];R=f;tr[R].son[1-w]=r;if(r)tr[r].f=R;\n\t\tr=x;R=ff;if(tr[R].son[0]==f)tr[R].son[0]=r;else if(tr[R].son[1]==f)tr[R].son[1]=r; tr[r].f=R;\n\t\tr=f;R=x;tr[R].son[w]=r;tr[r].f=R;update(f);update(x);\n\t}\n\tvoid splay(int x){\n\t\tdfs(x);\n\t\twhile(!rt(x)){\n\t\t\tint f=tr[x].f;\n\t\t\tif(rt(f))rotate(x,tr[f].son[0]==x);\n\t\t\telse{\n\t\t\t\tint ff=tr[f].f,a=(tr[f].son[0]==x),b=(tr[ff].son[0]==f);\n\t\t\t\tif(a^b)rotate(x,a),rotate(x,b);\n\t\t\t\telse rotate(f,a),rotate(x,a);\n\t\t\t}\n\t\t}\n\t}\n\tvoid access(int x){for(int y=0;x;x=tr[y=x].f)splay(x),rc=y,update(x);}\n\tvoid makeroot(int x){access(x);splay(x);tr[x].v^=1;}\n\tint find_root(int x){access(x);splay(x);while(lc)x=lc;return x;}\n\tvoid split(int x,int y){makeroot(y);access(x);splay(x);}\n\tbool connect(int x,int y){split(x,y);return lc==y&&(!tr[y].son[1]);}//x,y\u662f\u5426\u6709\u8fb9\u8fde\u63a5 \n\tbool unicom(int x,int y){split(x,y);while(lc)x=lc;return x==y;}//\u5224\u8054\u901a \n\tvoid link(int x,int y){makeroot(x);tr[x].f=y;access(x);}\n\tvoid cut(int x,int y){split(x,y);lc=0;tr[y].f=0;update(x);}\n\tint query(int x,int y){return unicom(x,y)?tr[x].mx:-1;}\n}lct[12];\n//0\nvoid change(int x,int w){\n\td[x]=w;\n\tfor(int i=0;i<c;i++)lct[i].access(x),lct[i].splay(x),lct[i].update(x);\n}\n//1\nvoid color(int x,int y,int w){\n\tint z=-1;\n\tfor(int i=0;i<c;i++)if(lct[i].connect(x,y)){z=i;break;}//\u6709\u4e86splay\uff0c\u7528\u4ec0\u4e48map\u67e5\u8fb9\uff08\u5e38\u6570\u90a3\u4e48\u5927\uff09 \n\tif(z==w){puts(\"Success.\");return;}//\u5751\u70b9 \n\tif(z<0){puts(\"No such edge.\");return;}\n\tif((cnt[x][w]>=2||cnt[y][w]>=2)){puts(\"Error 1.\");return;}//\n\tif(lct[w].unicom(x,y)){puts(\"Error 2.\");return;}\n\tlct[z].cut(x,y); cnt[x][z]--;cnt[y][z]--;\n\tlct[w].link(x,y);cnt[x][w]++;cnt[y][w]++;\n\tputs(\"Success.\");\n}\n//2\nint ask(int w,int x,int y){return lct[w].query(x,y);}\n\nchar buf[size],*p1=buf,*p2=buf;\nchar g{return p1==p2&&(p2=(p1=buf)+fread(buf,1,size,stdin),p1==p2)?EOF:*p1++;}\nvoid qr(int &x){\n\tchar c=g;bool v=x=0;\n\twhile(!(isdigit(c)||c=='-'))c=g;\n\tif(c=='-')v=1,c=g;\n\twhile(isdigit(c))x=x*10+c-'0',c=g;\n\tif(v)x=-x;\n}\nvoid write(int x){\n\tif(x/10)write(x/10);\n\tputchar(x%10+'0');\n}\nvoid pri(int x){\n\tif(x<0)putchar('-'),x=-x;\n\twrite(x);puts(\"\");\n}\n\nint main(){\n\tqr(n);qr(m);qr(c);qr(k);\n\tfor(int j=0;j<c;j++)lct[j].tr[0].mx=-inf;//\u521d\u59cb\u5316 \n\tfor(int i=1;i<=n;i++){\n\t\tqr(d[i]);\n\t\tfor(int j=0;j<c;j++)lct[j].tr[i].mx=d[i];//\u521d\u59cb\u5316 \n\t}\n\tint op,x,y,w;\n\twhile(m--)qr(x),qr(y),qr(w),lct[w].link(x,y),cnt[x][w]++,cnt[y][w]++;\n\twhile(k--){\n\t\tqr(op);\n\t\tswitch(op){\n\t\t\tcase 0:qr(x);qr(y);change(x,y);break;\n\t\t\tcase 1:qr(x);qr(y);qr(w);color(x,y,w);break;\n\t\t\tcase 2:qr(w);qr(x);qr(y);pri(ask(w,x,y));break;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1564794678,
        "uid": 118826,
        "name": "2018LZY",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "[\u6233\u6211\u83b7\u5f97\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8cqwq](https://www.goldenpotato.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/luogu-p2173-zjoi2012%E7%BD%91%E7%BB%9C/)\n\n---\n# Solution\n\u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u989c\u8272\u603b\u6570\u7279\u522b\u7684\u5c11\uff0c\u518d\u8003\u8651\u5230\u6709\u6539\u53d8\u8fb9\u7684\u989c\u8272\u7684\u64cd\u4f5c\uff0c\u53ef\u4ee5\u8003\u8651\u7528LCT\u6765\u89e3\u51b3\u3002\n\n.\n\n\u6211\u4eec\u5efa$c$\u9897LCT\uff0c\u6bcf\u9897LCT\u5b58\u6bcf\u4e2a\u989c\u8272\u5bf9\u5e94\u7684\u8fb9\uff0csplay\u8bb0\u5f55\u6bcf\u9897splay\u7684MAX_w\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u6743\u503c\uff0c\u8003\u8651\u76f4\u63a5\u66b4\u529b\u4fee\u6539\u6bcf\u4e2a\u989c\u8272\u7684LCT\u91cc\u5bf9\u5e94\u7684\u70b9\u7684\u6743\u503c\n\n\u5bf9\u4e8e\u4fee\u6539\u989c\u8272\uff0c\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u5728\u6bcf\u4e00\u9897LCT\u91cc\u9762\u679a\u4e3e\u6765\u627e\u4e00\u4e0b\u6709\u6ca1\u6709\u8fd9\u6761\u8fb9\uff0c\u6709\u7684\u8bdd\u5c31\u65ad\u6389\uff0c\u7136\u540e\u5728\u5bf9\u5e94\u7684LCT\u91cc\u9762\u8fde\u4e0a\u3002\n\n\u5bf9\u4e8e\u67e5\u8be2\uff0c\u6211\u4eec\u53ea\u9700\u8981\u628a\u5bf9\u5e94\u7684LCT\u4e2d\u5bf9\u5e94\u7684\u94fesplit\u51fa\u6765\uff0c\u7136\u540e\u76f4\u63a5\u8f93\u51faMAX\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u540c\u8272\u8fde\u8fb9\u4e0d\u8d85\u8fc72\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u6bcf\u79cd\u989c\u8272\u8fde\u4e86\u591a\u5c11\u6761\u8fb9\uff0c\u5728link\u548ccut\u4e2d\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002\n\n.\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(c\\cdot n \\cdot logm)$\n\n\u5c31\u9171\uff0c\u8fd9\u9898\u6211\u4eec\u5c31\u5207\u6389\u5566\u0669(\u0e51>\u25e1<\u0e51)\u06f6 \n\n---\n# Code\n```cpp\n//Luogu P2173 [ZJOI2012]\u7f51\u7edc\n//Mar,11th,2019\n//LCT\u66b4\u529b\u9898\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long read()\n{\n\tlong long x=0,f=1;char c=getchar();\n\twhile(!isdigit(c)){if(c=='-') f=-1;c=getchar();}\n\twhile(isdigit(c)){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\nconst int N=10000+100;\nconst int M=10+2;\nint cnt[N][M];//\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u8fde\u51fa\u53bb\u7684\u8fb9\u7684\u989c\u8272\u6570\nstruct LCT\n{\n\tint son[N][2],fa[N],lazy[N],MAX[N],w[N];\n\tinline void update(int x)\n\t{\n\t\tMAX[x]=max(MAX[son[x][0]],MAX[son[x][1]]);\n\t\tMAX[x]=max(MAX[x],w[x]);\n\t}\n\tinline void mirror(int x)\n\t{\n\t\tlazy[x]=!lazy[x];\n\t\tswap(son[x][0],son[x][1]);\n\t}\n\tinline void pushdown(int x)\n\t{\n\t\tif(lazy[x]==true)\n\t\t{\n\t\t\tmirror(son[x][0]);\n\t\t\tmirror(son[x][1]);\n\t\t\tlazy[x]=false;\n\t\t}\n\t}\n\tinline bool isRoot(int x)\n\t{\n\t\treturn (x!=son[fa[x]][0] and x!=son[fa[x]][1]);\n\t}\n\tinline void rotate(int x,int type)\n\t{\n\t\tint y=fa[x],z=fa[y];\n\t\tfa[x]=z;\n\t\tif(isRoot(y)==false)\n\t\t\tson[z][y==son[z][1]]=x;\n\t\tfa[son[x][type]]=y,son[y][!type]=son[x][type];\n\t\tfa[y]=x,son[x][type]=y;\n\t\tupdate(y),update(x);\n\t}\n\tint mstack[N],top;\n\tvoid splay(int x)\n\t{\n\t\tmstack[top=1]=x;\n\t\tfor(int i=x;isRoot(i)==false;i=fa[i])\n\t\t\tmstack[++top]=fa[i];\n\t\tfor(int i=top;i>=1;i--)\n\t\t\tpushdown(mstack[i]);\n\t\twhile(isRoot(x)==false)\n\t\t{\n\t\t\tif(isRoot(fa[x])==false and x==son[fa[x]][fa[x]==son[fa[fa[x]]][1]])\n\t\t\t\trotate(fa[x],x==son[fa[x]][0]);\n\t\t\trotate(x,x==son[fa[x]][0]);\n\t\t}\n\t}\n\tvoid Access(int x)\n\t{\n\t\tfor(int t=0;x!=0;t=x,x=fa[x])\n\t\t\tsplay(x),son[x][1]=t,fa[t]=x,update(x);\n\t}\n\tint GetRoot(int x)\n\t{\n\t\tAccess(x),splay(x);\n\t\twhile(son[x][0]!=0) x=son[x][0];\n\t\treturn x;\n\t}\n\tvoid MakeRoot(int x)\n\t{\n\t\tAccess(x),splay(x);\n\t\tmirror(x);\n\t}\n\tint Link(int x,int y,int c)\n\t{\n\t\tif(cnt[x][c]==2 or cnt[y][c]==2) return 2;\n\t\tif(GetRoot(x)==GetRoot(y)) return 1;\n\t\tcnt[x][c]++,cnt[y][c]++;\n\t\tMakeRoot(x);\n\t\tfa[x]=y;\n\t\treturn 0;\n\t}\n\tvoid split(int x,int y)//y\u505a\u539f\u6839\uff0cx\u4f5c\u4e3aLCT\u6839\n\t{\n\t\tMakeRoot(y);\n\t\tAccess(x);\n\t\tsplay(x);\n\t}\n\tint Cut(int x,int y,int w)\n\t{\n\t\tsplit(x,y);\n\t\tif(y!=son[x][0] or fa[y]!=x or son[y][1]!=0) return 1;\n\t\tson[x][0]=fa[y]=0;\n\t\tupdate(x);\n\t\tcnt[x][w]--,cnt[y][w]--;\n\t\treturn 0;\n\t}\n\tvoid Change(int x,int num)\n\t{\n\t\tsplit(x,x);\n\t\tw[x]=MAX[x]=num;\n\t}\n\tint Query(int x,int y)\n\t{\n\t\tsplit(x,y);\n\t\tif(GetRoot(x)!=y) return -1;\n\t\treturn MAX[x];\n\t}\n}lct[M]; \nint n,m,c,K;\nvoid Change1(int x,int num)\n{\n\tfor(int i=0;i<c;i++)\n\t\tlct[i].Change(x,num);\n}\nint Change2(int x,int y,int w)\n{\n\tint statu=3;\n\tfor(int i=0;i<c;i++)\n\t\tif(lct[i].Cut(x,y,i)==0)\n\t\t{\n\t\t\tstatu=lct[w].Link(x,y,w);\n\t\t\tif(statu!=0)\n\t\t\t\tlct[i].Link(x,y,i);\n\t\t\tbreak;\n\t\t}\n\treturn statu;\n}\nint Query(int x,int y,int w)\n{\n\treturn lct[w].Query(x,y);\n}\nint main()\n{\n\t//freopen(\"2173.in\",\"r\",stdin);\n\t//freopen(\"2173.out\",\"w\",stdout);\n\t\n\tn=read(),m=read(),c=read(),K=read();\n\tfor(int i=1;i<=n;i++)\n\t\tChange1(i,read());\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read(),w=read();\n\t\tlct[w].Link(x,y,w);\n\t}\n\t\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tint op=read();\n\t\tif(op==0)\n\t\t{\n\t\t\tint x=read(),num=read();\n\t\t\tChange1(x,num);\n\t\t}\n\t\telse if(op==1)\n\t\t{\n\t\t\tint x=read(),y=read(),w=read(),t=Change2(x,y,w);\n\t\t\tif(t==0)\n\t\t\t\tprintf(\"Success.\\n\");\n\t\t\telse if(t==1)\n\t\t\t\tprintf(\"Error 2.\\n\");\n\t\t\telse if(t==2)\n\t\t\t\tprintf(\"Error 1.\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"No such edge.\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint w=read(),x=read(),y=read();\n\t\t\tprintf(\"%d\\n\",Query(x,y,w));\n\t\t}\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1552302048,
        "uid": 52563,
        "name": "GoldenPotato137",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u9898\u76ee\u597d\u957f\u3002\u3002\u3002\n\n\u5982\u679c\u4f60\u505a\u8fc7[\u8fd9\u9053\u9898](https://www.luogu.org/problemnew/show/P3313)\u5c31\u4f1a\u53d1\u73b0\u601d\u8def\u5176\u5b9e\u5dee\u4e0d\u591a\n\n\u5c31\u662f\u5bf9\u6bcf\u79cd\u989c\u8272\u5efaLCT\uff0c\u5148\u628a\u70b9\u52a0\u5165\u6bcf\u4e2aLCT\u4e2d\uff0c\u8fb9\u52a0\u5165\u5bf9\u5e94\u7684LCT\u4e2d\n\n\u6211\u4eec\u770b\u770b\u6bcf\u4e2a\u64cd\u4f5c\uff1a\n\n0.\u5c31\u662f\u4fee\u6539\u70b9\u6743\uff0c\u679a\u4e3e\u989c\u8272\u4fee\u6539\u5c31\u884c\u4e86\n\n1.\u8fd8\u662f\u679a\u4e3e\u6bcf\u79cd\u989c\u8272\u7684LCT\uff0c\u5982\u679c\u8fd9\u4e2aLCT\u4e2dx\u548cy\u76f8\u8fde\n\n\u5148split(x,y)\u4e00\u4e0b\n\n\u5982\u679c\u6b64\u989c\u8272=\u4fee\u6539\u989c\u8272dis\uff0c\u5c31\u4e0d\u7528\u4fee\u6539\u76f4\u63a5\u8f93\u51fa\"Success.\"\n\n\u5bf9\u4e8e\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u6761\u4ef61\uff0c\u6211\u4eec\u7528\u4e00\u4e2a\u6570\u7ec4d\u8bb0\u5f55x\u8fde\u51fa\u53bb\u989c\u8272i\u7684\u8fb9\u6709\u51e0\u6761\uff0c\u5373d[x][i]\n\n\u8fd9\u6837\u968f\u65f6\u66f4\u65b0d\uff0c\u5982\u679cd[x][dis]>1\u6216d[y][dis]>1\uff0c\u5c31\u4e0d\u6ee1\u8db3\uff0c\u8f93\u51fa\"Error 1.\"\n\n\u5bf9\u4e8e\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u6761\u4ef62\uff0c\u6211\u4eec\u76f4\u63a5\u5224\u65ad\u989c\u8272\u7f16\u53f7\u4e3adis\u7684LCT\u4e2dx\u548cy\u662f\u5426\u8fde\u901a\n\n\u5982\u679c\u8fde\u901a\uff0c\u518d\u52a0\u4e00\u6761\u8fb9\u80af\u5b9a\u6210\u540c\u989c\u8272\u73af\uff0c\u5c31\u8f93\u51fa\"Error 2.\"\n\n\u6700\u540e\u627e\u4e0d\u5230\u5c31\u8f93\u51fa\"No such edge.\"\n\n2.\u8fd9\u4e2a\u5c31\u662f\u7b80\u5355\u7684\u8f93\u51fa\u4e86\u3002\u3002\u3002\u5982\u679c\u5728\u989c\u8272\u7f16\u53f7\u4e3adis\u7684LCT\u4e2d\u4e0d\u8fde\u901a\u8bb0\u5f97\u8f93\u51fa-1\n\n\u4ee3\u7801\uff1a\n```\n# include<iostream>\n# include<cstring>\n# include<cstdio>\n# include<cstdlib>\nusing namespace std;\nconst int MAX=1e4+1;\nint n,m,c,k;\nint a[MAX];\nint d[MAX][11];\nstruct Link_Cut_Tree{\n\tint w[MAX],fa[MAX];\n\tint son[MAX][2];\n\tbool fl[MAX];\n\tvoid pus(int x)\n\t{\n\t\tw[x]=max(max(w[son[x][0]],w[son[x][1]]),a[x]);\n\t}\n\tvoid down(int x)\n\t{\n\t\tif(fl[x]&&x)\n\t\t{\n\t\t\tif(son[x][1]) fl[son[x][1]]^=1;\n\t\t\tif(son[x][0]) fl[son[x][0]]^=1;\n\t\t\tswap(son[x][0],son[x][1]);\n\t\t\tfl[x]=0;\n\t\t}\n\t}\n\tbool is_root(int x)\n\t{\n\t\treturn son[fa[x]][1]!=x&&son[fa[x]][0]!=x;\n\t}\n\tbool id(int x)\n\t{\n\t\treturn son[fa[x]][0]==x?0:1;\n\t}\n\tvoid rot(int x)\n\t{\n\t\tint y=fa[x],z=fa[y],k=id(x);\n\t\tif(!is_root(y)) son[z][id(y)]=x;\n\t\tson[y][k]=son[x][k^1],fa[son[y][k]]=y;\n\t\tson[x][k^1]=y,fa[y]=x;\n\t\tfa[x]=z;\n\t\tpus(y),pus(x);\n\t}\n\tvoid PUS(int x)\n\t{\n\t\tif(!is_root(x)) PUS(fa[x]);\n\t\tdown(x);\n\t}\n\tvoid splay(int x)\n\t{\n\t\tPUS(x);\n\t\tfor(int y;!is_root(x);rot(x))\n\t\t  if(!is_root(y=fa[x]))\n\t\t  rot(id(x)==id(y)?y:x);\n\t}\n\tvoid access(int x)\n\t{\n\t\tfor(int y=0;x;y=x,x=fa[x])\n\t\t  splay(x),son[x][1]=y,pus(x);\n\t}\n\tint find_root(int x)\n\t{\n\t\taccess(x),splay(x);\n\t\twhile(son[x][0]) x=son[x][0];\n\t\treturn x;\n\t}\n\tvoid make_root(int x)\n\t{\n\t\taccess(x),splay(x);\n\t\tfl[x]^=1;\n\t}\n\tvoid split(int x,int y)\n\t{\n\t\tmake_root(x),access(y),splay(y);\n\t}\n\tvoid cut(int x,int y)\n\t{\n\t\tsplit(x,y);\n\t\tif(son[y][0]==x)\n\t\tson[y][0]=0,fa[x]=0;\n\t}\n\tvoid link(int x,int y)\n\t{\n\t\tmake_root(x);\n\t\tfa[x]=y;\n\t}\n\tvoid change(int x,int dis)\n\t{\n\t\taccess(x),splay(x);\n\t\ta[x]=dis;\n\t\tpus(x);\n\t}\n}Tree[11];\nvoid CHANGE(int x,int y,int dis)\n{\n\tfor(int i=1;i<=c;i++)\n\t  if(Tree[i].find_root(x)==Tree[i].find_root(y))\n\t  {\n\t  \tTree[i].split(x,y);\n\t  \tif(Tree[i].son[y][0]!=x||Tree[i].son[x][1]) continue;\n\t  \tif(i==dis)\n\t  \t{\n\t  \t\tprintf(\"Success.\\n\");\n\t  \t\treturn;\n\t\t}\n\t\tif(d[x][dis]>1||d[y][dis]>1)\n\t\t{\n\t\t\tprintf(\"Error 1.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif(Tree[dis].find_root(x)==Tree[dis].find_root(y))\n\t\t{\n\t\t\tprintf(\"Error 2.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tTree[i].cut(x,y),Tree[dis].link(x,y);\n\t\td[x][i]--,d[y][i]--;\n\t\td[x][dis]++,d[y][dis]++;\n\t\tprintf(\"Success.\\n\");\n\t\treturn;\n\t  }\n\tprintf(\"No such edge.\\n\");\n}\nint read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\tfor(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());\n\tfor(;isdigit(ch);x=x*10+ch-48,ch=getchar());\n\treturn x*f;\n}\nint main()\n{\n\tn=read(),m=read(),c=read(),k=read();\n\tfor(int i=1;i<=n;i++)\n\t  {\n\t  \ta[i]=read();\n\t  \tfor(int j=1;j<=c;j++)\n\t  \t  Tree[j].w[i]=a[i];\n\t  }\n\tfor(int i=1;i<=m;i++)\n\t  {\n\t  \tint x=read(),y=read(),dis=read()+1;\n\t  \td[x][dis]++,d[y][dis]++;\n\t  \tTree[dis].link(x,y);\n\t  }\n\tfor(int i=1;i<=k;i++)\n\t  {\n\t  \tint op=read(),x,y,dis;\n\t  \tif(!op)\n\t  \t{\n\t  \t\tx=read(),y=read();\n\t\t\tfor(int j=1;j<=c;j++)\n\t  \t\t  Tree[j].change(x,y);\n\t\t}\n\t\telse if(op==1)\n\t\t{\n\t\t\tx=read(),y=read(),dis=read()+1;\n\t\t\tCHANGE(x,y,dis);\n\t\t}\n\t\telse if(op==2)\n\t\t{\n\t\t\tdis=read()+1,x=read(),y=read();\n\t\t\tif(Tree[dis].find_root(x)!=Tree[dis].find_root(y))\n\t\t\tprintf(\"-1\\n\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tTree[dis].split(x,y);\n\t\t\t\tprintf(\"%d\\n\",Tree[dis].w[y]);\n\t\t\t}\n\t\t}\n\t  }\n\treturn 0;\n}\n```",
        "postTime": 1521681516,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u601d\u8def\n===\n\u663e\u7136\uff0c\u8fd9\u662f\u4e00\u9053lct\u88f8\u9898\u3002\u56e0\u4e3a\u989c\u8272\u4e0d\u591a\uff0c\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u8fb9\u6211\u4eec\u90fd\u5efa\u4e00\u4e2alct\u5373\u53ef\u3002(\u6211\u8fd9\u91cc\u662f\u7528 \uff08\u989c\u8272\u00d7n+\u70b9\u7684\u6807\u53f7\uff09 \u8868\u793a\u6bcf\u4e00\u79cd\u989c\u8272lct)\n\n\u6211\u7684\u65b9\u6cd5\u8ddf\u4e0b\u9762\u5927\u4f6c\u4eec\u90fd\u5dee\u4e0d\u591a\uff0c\u4f46\u662f\u7528\u4e86\u4e00\u4e9b\u5c0f\u6280\u5de7,~~\u5b9e\u73b0\u8d77\u6765\u7b80\u5355\u5f88\u591a~~\n### \u64cd\u4f5c0 \n\u56e0\u4e3a\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u8fb9\u90fd\u5efa\u4e86\u4e00\u4e2alct\u6240\u4ee5\uff0c\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u8fb9\u90fdupdate\u4e00\u6b21\u3002(~~\u867d\u7136\u5f88\u66b4\u529b\uff0c\u4f46\u8dd1\u5f97\u8fc7~~)\n### \u64cd\u4f5c1\n1.\u5176\u5b9e\u5bf9\u4e8e\u5224\u65ad\u8fb9\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u4e34\u63a5\u77e9\u9635\u6765\u5b58\uff0c\u5f00\u4e00\u4e2abool\u6570\u7ec410000*10000 128M\u8fd8\u662f\u5f00\u5f97\u4e0b\u7684\u3002\u8fd9\u6837\u8282\u7ea6\u4e86\u5f88\u591a\u65f6\u95f4(~~\u5176\u5b9e\u662f\u6211\u61d2\u5f97\u60f3\u5176\u5b83\u65b9\u6cd5\u5224\u65ad~~)\u3002\n\n2.\u9519\u8bef1,\u5f00\u4e00\u4e2adegree\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u8fb9\u7684\u5ea6\u5373\u53ef\u3002\n\n3.\u9519\u8bef2,\u5224\u65ad\u4e00\u4e0b\u4e24\u70b9\u5728\u8fd9\u4e2a\u989c\u8272\u7684lct\u662f\u5426\u8054\u901a\uff0c\u82e5\u8054\u901a\u5373\u4e3a\u4e0d\u5408\u6cd5\u7684\u60c5\u51b5\uff0c\u81f3\u4e8e\u600e\u4e48\u5224\u65ad\uff0clct\u6a21\u677f\u3002\n\n4.\u5bf9\u4e8e\u53ef\u4ee5\u4fee\u6539\u989c\u8272\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u5c31\u628a\u539f\u6765\u989c\u8272\u7684\u8fb9cut\u6389\uff0c\u518dlink\u65b0\u7684\u989c\u8272\u5c31\u53ef\u4ee5\u4e86\u3002\u770b\u4e0b\u9762\u5927\u4f6c\u90fd\u662f\u7528\u4e34\u63a5\u8868\u5b58\u8fb9\u627e\u989c\u8272\uff0c\u6211\u8fd9\u91cc\u6559\u4f60\u4eec\u4e00\u62db(~~\u61d2\u4eba\u4e13\u7528\u7684\u5947\u6deb\u6280\u5de7~~)\u628abool\u6570\u7ec4\u5f00\u6210char\u6570\u7ec4\u8fd9\u6837\u65e2\u53ef\u4ee5\u5224\u65ad\u8fb9\u7684\u5b58\u5728\u6027\uff0c\u53c8\u53ef\u4ee5\u5224\u65ad\u8fb9\u7684\u989c\u8272\uff0c\u6bd4\u90a3\u4e9b\u4e34\u63a5\u8868\u65b9\u4fbf\u4e86\u8bb8\u591a\uff0c\u8fd8\u8282\u7ea6\u4e86\u65f6\u95f4\u3002(~~\u5176\u5b9e\u5bf9\u4e8e\u4e00\u4e9b\u7a7a\u95f4\u4e0d\u591f\u7684\u9898\uff0c\u53ef\u4ee5\u7528short\u6216\u8005char\u4e4b\u7c7b\u7684\u6570\u7ec4\u6765\u5b58\u4e1c\u897f\uff0c\u4e5f\u8bb8\u8fd9\u6837\u5c31\u591f\u4e86~~)\n### \u64cd\u4f5c2\n\u6ca1\u6709\u4ec0\u4e48\u7279\u6b8a\u7684\u5730\u65b9\u548c\u5176\u5b83lct\u9898\u7684\u67e5\u8be2\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\u3002\n# \u603b\u7ed3\n\u8fd9\u9898lct\u7684\u90e8\u5206\u8ddf\u5176\u5b83\u9898\u76ee\u6ca1\u6709\u533a\u522b\uff0c\u76f4\u63a5\u590d\u5236\u7c98\u8d34\u90fd\u53ef\u4ee5\uff0c\u53ea\u662f\u8981\u60f3\u5230\u80fd\u5f00\u591a\u4e2alct\u5e76\u4e14\u8fd9\u4e9blct\u4e4b\u95f4\u4e92\u4e0d\u5f71\u54cd\uff0c\u5b9e\u73b0\u8d77\u6765\u8fd8\u662f\u975e\u5e38\u7b80\u5355\u7684\n#  \u4ee3\u7801\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5;\nint fa[N],ch[N][2],lazy[N],w[N],ans[N],degree[N],n,m,c;\nchar pd[10001][10001];\nint isroot(int x){return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x;}\nint get(int x){return ch[fa[x]][1]==x;}\nvoid pushup(int x){ans[x]=max(w[x],max(ans[ch[x][0]],ans[ch[x][1]]));}\nvoid pushdown(int x){\n    if(!lazy[x])return;\n    swap(ch[x][0],ch[x][1]);\n    lazy[ch[x][0]]^=1;\n    lazy[ch[x][1]]^=1;\n    lazy[x]^=1;\n}\nvoid rotate(int x){\n    int y=fa[x],z=fa[y],k=get(x);\n    fa[x]=z;if(!isroot(y))ch[z][ch[z][1]==y]=x;\n    ch[y][k]=ch[x][k^1];fa[ch[y][k]]=y;\n    ch[x][k^1]=y;fa[y]=x;\n    pushup(y);pushup(x);\n}\nvoid push(int x){if(!isroot(x))push(fa[x]);pushdown(x);}\nvoid splay(int x){\n    push(x);\n    while(!isroot(x)){\n        int y=fa[x];\n        if(!isroot(y))\n            if(get(x)==get(y))rotate(y);\n            else rotate(x);\n        rotate(x);\n    }\n}\nvoid access(int x){for(int y=0;x;y=x,x=fa[x])splay(x),ch[x][1]=y,pushup(x);}\nvoid makeroot(int x){access(x);splay(x);lazy[x]^=1;}\nvoid split(int x,int y){makeroot(x);access(y);splay(y);}\nvoid link(int x,int y){makeroot(x);fa[x]=y;}\nvoid cut(int x,int y){split(x,y);fa[x]=ch[y][0]=0;pushup(y);}\nint getroot(int x){\n    access(x);splay(x);\n    while(ch[x][0])x=ch[x][0];\n    return x;\n}\nint query(int x,int y){\n    if(getroot(x)!=getroot(y))return -1;\n    split(x,y);\n    return ans[y];\n}\nvoid update(int x,int y){\n    makeroot(x);\n    w[x]=y;\n    pushup(x);\n}\nvoid work(int x,int y,int z){\n    if(pd[x][y]==0){printf(\"No such edge.\\n\");return;}\n    int u=x+z*n,v=y+z*n,lu=x+pd[x][y]*n,lv=y+pd[x][y]*n;\n    if(pd[x][y]==z){printf(\"Success.\\n\");return;}\n    if(degree[u]==2||degree[v]==2){printf(\"Error 1.\\n\");return;}\n    if(getroot(u)==getroot(v)){printf(\"Error 2.\\n\");return;}\n    degree[lu]--;degree[lv]--;\n    degree[u]++;degree[v]++;\n    cut(lu,lv);\n    link(u,v);\n    printf(\"Success.\\n\");\n    pd[x][y]=z;\n    pd[y][x]=z;\n}\nint main(){\n    int k;\n    cin>>n>>m>>c>>k;\n    for(int i=1;i<=n;++i){\n        scanf(\"%d\",&w[i]);ans[i]=w[i];\n        for(int j=1;j<=c;++j)\n            ans[i+j*n]=w[i+j*n]=w[i];\n    }\n    for(int i=1;i<=m;++i){\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        w++;\n        int x=u+w*n,y=v+w*n;\n        link(x,y);\n        degree[x]++;\n        degree[y]++;\n        pd[u][v]=w;\n        pd[v][u]=w;\n    }\n    while(k--){\n        int op;\n        scanf(\"%d\",&op);\n        if(op==0){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            for(int i=1;i<=c;++i)\n                update(x+i*n,y);\n        }\n        if(op==1){\n            int x,y,z;\n            scanf(\"%d%d%d\",&x,&y,&z);z++;\n            work(x,y,z);\n        }\n        if(op==2){\n            int x,y,z;\n            scanf(\"%d%d%d\",&z,&x,&y);z++;\n            printf(\"%d\\n\",query(x+z*n,y+z*n));\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1519733812,
        "uid": 63348,
        "name": "Cqdnse",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u5982\u679c\u5bf9$LCT$($Link-Cut$ $Tree$)\u4e0d\u4e86\u89e3\uff0c\u53ef\u4ee5\u53c2\u8003\u6b64\u94fe\u63a5\uff1a<http://www.cnblogs.com/BLADEVIL/p/3510997.html>\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u989c\u8272\uff0c\u7ef4\u62a4\u4e00\u4e2a$LCT$\uff08\u56e0\u4e3a\u6ca1\u6709\u540c\u8272\u7684\u73af\uff0c\u4e14$C<=10$\uff09\u3002\u6bcf\u79cd\u989c\u8272\u5bf9\u5e94\u7684$LCT$\u4e2d\u5305\u542b\u6240\u6709\u7684\u70b9\uff0c\u4f46\u53ea\u5305\u542b\u5bf9\u5e94\u989c\u8272\u7684\u8fb9\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c$0$\uff0c\u5c31\u662f\u4fee\u6539\u70b9\u6743\uff0c\u4e5f\u5c31\u662f$Splay$\u4e0a\u7684\u64cd\u4f5c\uff0c\u5c31\u4e0d\u591a\u8bf4\u4e86\uff08\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u6bcf\u4e00\u79cd\u989c\u8272\u5bf9\u5e94\u7684$LCT$\u4e0a\u7684\u8282\u70b9$x$\u90fd\u8981\u4fee\u6539\uff09\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c$2$\uff0c\u5c31\u662f\u627e\u51fa\u5bf9\u5e94\u989c\u8272\u7684$LCT$\uff0c\u63d0\u53d6\u8def\u5f84\u5e76\u8be2\u95ee\u8def\u5f84\u6700\u5927\u503c\uff0c\u8fd9\u4e5f\u4e0d\u591a\u8bf4\u4e86\u3002\n\n\u800c\u91cd\u70b9\u5c31\u662f\u64cd\u4f5c$1$\u3002\n\n\u5bf9\u4e8e\u5224\u65ad\u4e00\u6761\u8fb9\u662f\u5426\u5b58\u5728\uff0c\u53ef\u4ee5\u4f7f\u7528$map$\u6765\u5224\u5b9a\uff0c\u5f53\u7136\u66b4\u529b\u679a\u4e3e\u4e5f\u53ef\u4ee5\uff08\u56e0\u4e3a\u7531\u9650\u5236\u6761\u4ef6$1$\u53ef\u5f97\uff0c\u4e0e\u4e00\u4e2a\u70b9\u76f8\u8fde\u7684\u8fb9\u6570\u4e0d\u8d85\u8fc7$2*C$\uff09\u3002\n\n\u5728\u8fd9\u91cc\u6211\u4e0d\u77e5\u9053\u6570\u636e\u4e2d\u4f1a\u4e0d\u4f1a\u51fa\u73b0\u300c\u4e00\u6761\u8fb9\u4fee\u6539\u6210\u8fd9\u6761\u8fb9\u5f53\u524d\u7684\u989c\u8272\u300d\u7684\u60c5\u51b5\uff0c\u6240\u4ee5\u6211\u5224\u5b9a\u4e86\u4e00\u4e0b\uff0c\u5982\u679c\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\u5c31\u76f4\u63a5\u5224\u5b9a\u4e3a\u540c\u65f6\u6ee1\u8db3\u9650\u5236\u6761\u4ef6$1$\u548c$2$\u5e76$continue$\u3002\n\n\u5bf9\u4e8e\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u9650\u5236\u6761\u4ef6$1$\uff0c\u53ef\u4ee5\u4f7f\u7528\u7edf\u8ba1\u7684\u65b9\u6cd5\uff0c\u5373\u7edf\u8ba1\u4e0e\u6bcf\u4e2a\u70b9\u76f8\u8fde\u7684\u6bcf\u79cd\u989c\u8272\u7684\u8fb9\u6709\u51e0\u6761\uff0c\u5982\u679c\u8282\u70b9$u$\u548c$v$\u4e2d\u81f3\u5c11\u6709\u4e00\u4e2a\u70b9\u76f8\u8fde\u7684\u989c\u8272\u4e3a$w$\u7684\u8fb9\u6570\u7b49\u4e8e$2$\uff0c\u90a3\u4e48\u9650\u5236\u6761\u4ef6$1$\u4e0d\u6ee1\u8db3\u3002\n\n\u5bf9\u4e8e\u9650\u5236\u6761\u4ef6$2$\uff0c\u76f4\u63a5\u5224\u65ad\u5728\u989c\u8272$w$\u5bf9\u5e94\u7684$LCT$\u4e2d\uff0c\u662f\u5426$FindRoot(u)==FindRoot(v)$\uff0c\u5982\u679c\u662f\u5219\u9650\u5236\u6761\u4ef6$2$\u4e0d\u6ee1\u8db3\u3002\n\n\u5982\u679c\u540c\u65f6\u6ee1\u8db3\u9650\u5236\u6761\u4ef6$1$\u548c$2$\uff0c\u5219\u7ef4\u62a4\u4e00\u4e0b\u7edf\u8ba1\u6570\u7ec4\uff0c\u7136\u540e\u5728\u8fd9\u6761\u8fb9\u539f\u6765\u7684\u989c\u8272\u5bf9\u5e94\u7684$LCT$\u4e2d\uff0c\u6267\u884c$Cut(u,v)$\uff0c\u518d\u5728\u989c\u8272$w$\u5bf9\u5e94\u7684$LCT$\u4e2d\uff0c\u6267\u884c$Link(u,v)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ninline int read() {\n    int res = 0; bool bo = 0; char c;\n    while (((c = getchar()) < '0' || c > '9') && c != '-');\n    if (c == '-') bo = 1; else res = c - 48;\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = (res << 3) + (res << 1) + (c - 48);\n    return bo ? ~res + 1 : res;\n}\nconst int N = 1e4 + 5, M = 1e5 + 5;\nint n, m, fa[M], lc[M], rc[M], rev[M], len, que[M], c, Q,\nval[M], V[M], cnt[N][13], ecnt = 1, nxt[M << 1], adj[M], go[M << 1],\ncol[M << 1];\nvoid add_edge(int u, int v, int w) {\n    nxt[++ecnt] = adj[u]; adj[u] = ecnt;\n    go[ecnt] = v; col[ecnt] = w;\n}\nint tran(int x, int y) {return (x - 1) * c + y;}\nint which(int x) {return rc[fa[x]] == x;}\nbool is_root(int x) {\n    return !fa[x] || (lc[fa[x]] != x && rc[fa[x]] != x);\n}\nvoid down(int x) {\n    if (rev[x]) {\n        swap(lc[x], rc[x]);\n        if (lc[x]) rev[lc[x]] ^= 1;\n        if (rc[x]) rev[rc[x]] ^= 1;\n        rev[x] = 0;\n    }\n}\nvoid upt(int x) {\n    val[x] = V[x];\n    if (lc[x]) val[x] = max(val[x], val[lc[x]]);\n    if (rc[x]) val[x] = max(val[x], val[rc[x]]);\n}\nvoid rotate(int x) {\n    int y = fa[x], z = fa[y], b = lc[y] == x ? rc[x] : lc[x];\n    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;\n    fa[x] = z; fa[y] = x; b ? fa[b] = y : 0;\n    if (lc[y] == x) rc[x] = y, lc[y] = b;\n    else lc[x] = y, rc[y] = b; upt(y); upt(x);\n}\nvoid splay(int x) {\n    int i, y; que[len = 1] = x;\n    for (y = x; !is_root(y); y = fa[y]) que[++len] = fa[y];\n    for (i = len; i >= 1; i--) down(que[i]);\n    while (!is_root(x)) {\n        if (!is_root(fa[x])) {\n            if (which(x) == which(fa[x])) rotate(fa[x]);\n            else rotate(x);\n        }\n        rotate(x);\n    }\n    upt(x);\n}\nvoid Access(int x) {\n    int y;\n    for (y = 0; x; y = x, x = fa[x]) {\n        splay(x); rc[x] = y;\n        if (y) fa[y] = x; upt(x);\n    }\n}\nint Find_Root(int x) {\n    Access(x); splay(x);\n    while (down(x), lc[x]) x = lc[x];\n    splay(x); return x;\n}\nvoid Make_Root(int x) {\n    Access(x); splay(x);\n    rev[x] ^= 1;\n}\nvoid Link(int x, int y) {\n    Make_Root(x); fa[x] = y;\n}\nvoid Cut(int x, int y) {\n    Make_Root(x); Access(y); splay(y);\n    lc[y] = 0; fa[x] = 0; upt(y);\n}\nint Select(int x, int y) {\n    Make_Root(x); Access(y); splay(y);\n    return val[y];\n}\nint main() {\n    int i, j, op, x, y, z;\n    n = read(); m = read(); c = read(); Q = read();\n    for (i = 1; i <= n; i++) {\n        x = read(); for (j = 1; j <= c; j++) {\n            int p = tran(i, j);\n            V[p] = val[p] = x;\n        }\n    }\n    while (m--) {\n        x = read(); y = read(); z = read() + 1;\n        cnt[x][z]++; cnt[y][z]++;\n        Link(tran(x, z), tran(y, z));\n        add_edge(x, y, z); add_edge(y, x, z);\n    }\n    while (Q--) {\n        op = read(); x = read(); y = read();\n        if (op == 0) for (i = 1; i <= c; i++)\n            z = tran(x, i), splay(z), V[z] = y, upt(z);\n        else if (op == 1) {\n            z = read() + 1; bool flag = 0; int co, ex;\n            for (int e = adj[x]; e; e = nxt[e])\n                if (go[e] == y)\n                    {ex = e; co = col[e]; flag = 1; break;}\n            if (!flag) {printf(\"No such edge.\\n\"); continue;}\n            if (co == z) {printf(\"Success.\\n\"); continue;}\n            if (cnt[x][z] == 2 || cnt[y][z] == 2)\n                {printf(\"Error 1.\\n\"); continue;}\n            if (Find_Root(tran(x, z)) == Find_Root(tran(y, z)))\n                {printf(\"Error 2.\\n\"); continue;}\n            printf(\"Success.\\n\"); Cut(tran(x, co), tran(y, co));\n            Link(tran(x, z), tran(y, z));\n            col[ex] = col[ex ^ 1] = z; cnt[x][co]--; cnt[y][co]--;\n            cnt[x][z]++; cnt[y][z]++;\n        }\n        else {\n            x++; z = read();\n            if (Find_Root(tran(y, x)) != Find_Root(tran(z, x)))\n                {printf(\"-1\\n\"); continue;}\n            else printf(\"%d\\n\", Select(tran(y, x), tran(z, x)));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1502894372,
        "uid": 29936,
        "name": "xyz32768",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u4e00\u9053\u6bd4\u8f83\u88f8\u7684\uff2c\uff23\uff34\uff0c\u5c31\u662f\u6a21\u677f\u9898\u5427\uff08\u4f46\u662f\u6211\u5199\u4e86\uff14.\uff15\u4e2a\u5c0f\u65f6\uff09\uff0c\n\n\u6bcf\u4e00\u4e2a\u989c\u8272\u5c31\u662f\u4e00\u5768\uff2c\uff23\uff34\u68ee\u6797\uff0c\u76f4\u63a5\u52a0\u8fb9\u7ef4\u62a4\u5373\u53ef\u3002\n\n\n**\u6ce8\u610f\uff1a\u5343\u4e07\u522b\u5199stack\uff0c\u7528int,\u4e0d\u7136\u4f1a\uff34\u6389**\n\n\n\n\n\n\n\n\n\n    \n\n\n\n\n        \n\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n        \n\n\n\n            \n\n\n\n            \n\n    \n\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<map>\nusing namespace std;\n#define LL long long\n#define pb push_back\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)\n#define MAXN (10000+5)\n#define MAXM (100000+5)\n#define MAXC (10+5)\nvoid read(int &x){\n    char ch = getchar();\n    while(ch < '0' || ch > '9') ch = getchar();\n    x = 0;\n    while(ch >= '0' && ch <= '9'){\n        x = x*10 + ch -'0';\n        ch = getchar();\n    }\n}\nint val[MAXN], st[MAXN], top;\nstruct LCT{\n    int ch[MAXN][2], fa[MAXN];\n    int maxv[MAXN], rev[MAXN], du[MAXN];\n    inline void maintain(int now){\n        maxv[now] = val[now];\n        if(ch[now][0]) maxv[now] = max(maxv[now], maxv[ch[now][0]]);\n        if(ch[now][1]) maxv[now] = max(maxv[now], maxv[ch[now][1]]);\n    }\n    inline void push_down(int o){\n        if(!rev[o]) return;\n        int &lc = ch[o][0], &rc = ch[o][1];\n        rev[lc] ^= 1; rev[rc] ^= 1; rev[o] ^= 1;\n        swap(lc, rc);\n    }\n    inline bool isroot(int o){\n        return (o != ch[fa[o]][0] && o != ch[fa[o]][1]);\n    }\n    inline void rotate(int o){\n        int f = fa[o], g = fa[f];\n        int c = (o == ch[f][1]);\n        if(!isroot(f)){\n            if(ch[g][0] == f) ch[g][0] = o;\n            else ch[g][1] = o;\n        }\n        fa[f] = o; fa[o] = g;\n        fa[ch[o][c^1]] = f;\n        ch[f][c] = ch[o][c^1]; ch[o][c^1] = f;\n        maintain(f);\n    }\n    inline void splay(int x){\n        top = 0;\n        st[++top] = x;\n        for(int i = x; !isroot(i); i = fa[i]) st[++top] = fa[i];\n        while(top){\n            push_down(st[top]); top--;\n        }\n        int o = x;\n        while(!isroot(o)){\n            int f = fa[o], g = fa[f];\n            if(isroot(f)){\n                rotate(o);\n                break;\n            }\n            if(!isroot(g)) rotate(f);\n            rotate(o);\n        }\n        maintain(o);\n    }\n    inline void access(int x){\n        int y = 0;\n        while(x){\n            splay(x);\n            ch[x][1] = y;\n            maintain(x);\n            y = x;\n            x = fa[x];\n        }\n    }\n    inline void rever(int x){\n        access(x); splay(x); rev[x] ^= 1;\n    }\n    inline void link(int x, int y){\n        du[x]++; du[y]++;\n        rever(x); fa[x] = y;\n        access(y);\n    }\n    inline void cut(int x, int y){\n        du[x]--; du[y]--;\n        rever(x); access(y); splay(y);\n        ch[y][0] = fa[x] = 0;\n        maintain(y);\n    }\n    inline int find(int x){\n        access(x); splay(x);\n        int ret = x;\n        while(ch[ret][0]) ret = ch[ret][0];\n        return ret;\n    }\n    inline int query(int x, int y){\n        rever(x); access(y); splay(y);\n        return maxv[y];\n    }\n};\nstruct UV{\n    int u, v;\n    bool operator <(const UV &rhs)const{\n        if(u != rhs.u) return u < rhs.u;\n        return v < rhs.v;\n    }\n};\nLCT lcts[MAXC];\nmap<UV, int> ms;\nint main(){\n    int n, m, c, k, u, v, w, op, x;\n    read(n); read(m); read(c); read(k);\n    For(i, 1, n) read(val[i]);\n    For(i, 1, m){\n        read(u); read(v); read(w);\n        w++;\n        UV t1 = (UV){u, v}, t2 = (UV){v, u};\n        ms[t1] = ms[t2] = w;\n        lcts[w].link(u, v);\n    }\n    For(ca, 1, k){\n        read(op);\n    //    printf(\"op = %d\\n\", op);\n        if(op == 0){\n            read(x); read(w);\n            val[x] = w;\n            For(i, 1, c) lcts[i].splay(x);\n        }else if(op == 1){\n            read(u); read(v); read(w);\n            w++;\n            UV tmp = (UV){u, v}, t2 = (UV){v, u};\n            if(!ms.count(tmp)){\n                printf(\"No such edge.\\n\");\n                continue;\n            }\n            int bef = ms[tmp];\n            if(bef == w){\n                printf(\"Success.\\n\");\n                continue;\n            }\n            if(lcts[w].du[u] >= 2 || lcts[w].du[v] >= 2){\n                printf(\"Error 1.\\n\");\n                continue;\n            }\n            if(lcts[w].find(u) == lcts[w].find(v)){\n                printf(\"Error 2.\\n\");\n                continue;\n            }\n            printf(\"Success.\\n\");\n            lcts[bef].cut(u, v); lcts[w].link(u, v);\n            ms[tmp] = ms[t2] = w;\n        }else{\n            read(w); read(u); read(v);\n            w++;\n            if(lcts[w].find(u) != lcts[w].find(v)){\n                 printf(\"-1\\n\");\n                continue;\n            }\n            printf(\"%d\\n\", lcts[w].query(u, v));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1480737399,
        "uid": 8925,
        "name": "miaowey",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2173 \u3010[ZJOI2012]\u7f51\u7edc\u3011"
    }
]