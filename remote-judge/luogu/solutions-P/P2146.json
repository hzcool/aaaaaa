[
    {
        "content": "###\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u9898###\n\n\n- \u6bcf\u6b21\u5b89\u88c5\u8f6f\u4ef6\uff0c\u5c31\u628a\u6839\u8282\u70b9\u5230x\u8f6f\u4ef6\u8def\u5f84\u4e0a\u7684\u503c\u5168\u90e8\u53d8\u4e3a1\n\n\n- \u540c\u7406\uff0c\u6bcf\u6b21\u5378\u8f7d\u8f6f\u4ef6\uff0c\u5c31\u628ax\u4ee5\u53ca\u5b83\u7684\u5b50\u6811\u7684\u503c\u53d8\u4e3a0\n\n\n\u6545\u6211\u4eec\u53ef\u4ee5\u7528\u533a\u95f4\u548c\u7684\u601d\u60f3\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e4b\u524d\u8bb0\u5f55\u4e00\u4e0btree[root].sum\u7684\u503c\uff0c\u66f4\u65b0\u4e4b\u540e\u518d\u67e5\u8be2\u4e00\u904dtree[root].sum\u7684\u503c\uff0c\u4e24\u8005\u4e4b\u5dee\u7684\u7edd\u5bf9\u503c\u5219\u4e3a\u7b54\u6848\u3002\n\n\n\u6211\u7684\u4ee3\u7801\u91cc\u628aroot\u7684\u503c\u8bbe\u4e3a1\uff0c\u6bcf\u4e2a\u70b9\u7684\u7f16\u53f7\u90fd\u52a0\u4e0a\u4e861\uff08\u4e2a\u4eba\u4e60\u60ef\uff09\n\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nconst int maxn=200005;\nint n,k=0,x,head[maxn],q,deep[maxn],father[maxn],size[maxn];\nint tid[maxn],top[maxn],son[maxn],tidnum=0,pos[maxn];char s[15];\nstruct node\n{\n    int to,next;\n} edge[maxn<<1];\nstruct Node\n{\n    int left,right,flag,sum;\n} tree[maxn<<2];\nvoid add(int u,int v)\n{\n    edge[++k].to=v;\n    edge[k].next=head[u];\n    head[u]=k;\n}\nint read()\n{\n    int x=0;char ch=getchar();\n    while(ch<48||ch>57) ch=getchar();\n    while(ch>=48&&ch<=57) x=x*10+ch-48,ch=getchar();\n    return x;\n}\nvoid dfs1(int x,int fa,int depth)\n{\n    size[x]=1;father[x]=fa;deep[x]=depth;\n    for(int i=head[x];i;i=edge[i].next)\n    {\n        if(edge[i].to==fa) continue;\n        dfs1(edge[i].to,x,depth+1);\n        size[x]+=size[edge[i].to];\n        if(!son[x]||size[edge[i].to]>size[son[x]]) son[x]=edge[i].to;\n    }\n}\nvoid dfs2(int x,int tp)\n{\n    tid[x]=++tidnum;pos[tid[x]]=x;top[x]=tp;\n    if(!son[x]) return;dfs2(son[x],tp);\n    for(int i=head[x];i;i=edge[i].next)\n    {\n        if(edge[i].to!=son[x]&&edge[i].to!=father[x])\n            dfs2(edge[i].to,edge[i].to);\n    }\n}\nvoid build(int id,int l,int r)\n{\n    tree[id].left=l;tree[id].right=r;\n    tree[id].sum=0;tree[id].flag=-1;\n    if(l==r) return;\n    int mid=(l+r)>>1;\n    build(id<<1,l,mid);build(id<<1|1,mid+1,r);\n    return;\n}\nvoid downdata(int id)\n{\n    tree[id<<1].sum=(tree[id<<1].right-tree[id<<1].left+1)*tree[id].flag;\n    tree[id<<1|1].sum=(tree[id<<1|1].right-tree[id<<1|1].left+1)*tree[id].flag;\n    tree[id<<1].flag=tree[id<<1|1].flag=tree[id].flag;\n    tree[id].flag=-1;\n}\nint get(int id,int l,int r)\n{\n    if(tree[id].right<l||tree[id].left>r) return 0;\n    if(tree[id].right<=r&&tree[id].left>=l) return tree[id].sum;\n    if(tree[id].flag!=-1) downdata(id);\n    return get(id<<1,l,r)+get(id<<1|1,l,r);\n}\nvoid update(int id,int l,int r,int val)\n{\n    if(tree[id].right<l||tree[id].left>r) return;\n    if(tree[id].right<=r&&tree[id].left>=l)\n    {\n        tree[id].sum=(tree[id].right-tree[id].left+1)*val;\n        tree[id].flag=val;\n        return;\n    }\n    if(tree[id].flag!=-1) downdata(id);\n    update(id<<1,l,r,val);update(id<<1|1,l,r,val);\n    tree[id].sum=tree[id<<1].sum+tree[id<<1|1].sum;\n    return;\n}\nvoid change(int u,int v,int val)\n{\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]<deep[top[v]]) std::swap(u,v);\n        update(1,tid[top[u]],tid[u],val);\n        u=father[top[u]];\n    }\n    if(deep[u]>deep[v]) std::swap(u,v);\n    update(1,tid[u],tid[v],val);\n    return;\n}\nint main()\n{\n    n=read();\n    for(int i=2;i<=n;i++)\n    {\n        x=read();x++;\n        add(x,i);\n    }\n    dfs1(1,1,1);dfs2(1,1);\n    q=read();build(1,1,tidnum);\n    for(int i=1;i<=q;i++)\n    {\n        scanf(\"%s\",s);\n        x=read();x++;\n        int t1=tree[1].sum;\n        if(s[0]=='i')\n        {\n            change(1,x,1);\n            int t2=tree[1].sum;\n            printf(\"%d\\n\",abs(t2-t1));\n            \n        }\n        if(s[0]=='u')\n        {\n            update(1,tid[x],tid[x]+size[x]-1,0);\n            int t2=tree[1].sum;\n            printf(\"%d\\n\",abs(t1-t2));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1503664520,
        "uid": 26229,
        "name": "lemonaaaaa",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "### \u73c2\u6735\u8389\u662f\u4e16\u754c\u4e0a\u6700\u5e78\u798f\u7684\u5973\u5b69\uff0c\u4e0d\u63a5\u53d7\u4efb\u4f55\u53cd\u9a73\n\n![](https://i.loli.net/2018/04/09/5aca3ca156185.jpg)\n\n### \u56db\u5904\u89c2\u671b\u4e86\u4e00\u4e0b\u53d1\u73b0\u6ca1\u6709\u73c2\u6735\u8389\u6811\u7684\u9898\u89e3\uff0c\u90a3\u5c31\u7531\u6211\u6765\u6c34\u4e00\u53d1\u5427qwq\n\n\u7b2c\u4e00\u6b65\uff1a\u6811\u5256\u6253\u51fadfs\u5e8f\uff08\u8fd9\u4e2a\u4e0d\u8981\u600e\u4e48\u8bf4\u4e86\uff0c\u5e38\u89c4\u505a\u6cd5\u5373\u53ef\uff09\n\n#### \u7b2c\u4e8c\u6b65\uff1a\n\n\u89c2\u5bdf\u9898\u76ee\uff0c\u75281\u4ee3\u8868\u5df2\u5b89\u88c5\u30010\u4ee3\u8868\u672a\u5b89\u88c5\uff0c\u53d1\u73b0\u4e24\u4e2a\u64cd\u4f5c\u90fd\u662f\u533a\u95f4\u8d4b\u503c\uff0c\u5728\u8d4b\u503c\u524d\u540e\u67e5\u8be2\uff0c\u53d6\u51fa\u7b54\u6848\u3002\u533a\u95f4\u8d4b\u503c\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u8d4b\u503c\u524d\u7edf\u8ba11\u7684\u4e2a\u6570\uff0c\u8d4b\u503c\u540e\u53d6\u5dee\u503c\u5373\u53ef\u3002\uff08\u8fd9\u662f\u672c\u9898\u6b63\u89e3\uff09\n\n\u4f46\u662f\u6211\u4eec\u4e5f\u4e0d\u96be\u60f3\u5230\u533a\u95f4\u8d4b\u503c\u5229\u5668\u2014\u2014\u73c2\u6735\u8389\u6811\u3002\u5b66\u8fc7\u73c2\u6735\u8389\u6811\u7684\u540c\u5b66\u90fd\u77e5\u9053\u73c2\u6735\u8389\u6811\u7684\u5747\u644a\u590d\u6742\u5ea6\u662f\u7531`Assign`\u64cd\u4f5c\u4fdd\u8bc1\u7684\uff0c\u7136\u540e\u8fd9\u91cc\u9664\u4e86\u67e5\u8be2\u5168\u662f`Assign`\uff0c\u590d\u6742\u5ea6\u7406\u8bba\u4e0a\u4e0d\u4f1a\u5f88\u52a3\uff08\u5373\u4f7f\u6570\u636e\u4e0d\u968f\u673a\uff09\u3002\u6240\u4ee5\u73c2\u6735\u8389\u6811\u5438\u53e3\u6c27\u4e5f\u662f\u80fd\u8dd1\u8fc7\u7684\u3002\n\n#### \u5177\u4f53\u600e\u4e48\u505a\uff1a\n\u5b89\u88c5\u7684\u65f6\u5019\u8df3\u91cd\u94fe\uff0c\u76f4\u5230\u8df3\u5230\u6839\u8282\u70b9\uff0c\u8fb9\u8d70\u8fb9\u7edf\u8ba1\uff0c\u7edf\u8ba1\u540e`Assign`\uff0c\u53d6\u5dee\u503c\u4e3a\u7b54\u6848\u3002\u5378\u8f7d\u65f6\u76f4\u63a5\u7edf\u8ba1+\u4fee\u6539\u5b50\u6811\uff08\u548c\u7ebf\u6bb5\u6811\u505a\u6cd5\u51e0\u4e4e\u4e00\u6837\uff09\n\n\u6ce8\u610f\uff0c\u8fd9\u91cc\u6240\u6709\u8282\u70b9\u7f16\u53f7\u6700\u597d\u90fd+1\uff0c\u4e0d\u7136\u91cd\u513f\u5b50\u4e0d\u597d\u5904\u7406\u3002\n\n### \u6700\u540e\u8d34\u4e0a\u4ee3\u7801\uff08\u5438\u6c27\uff09\uff1a\n```cpp\n// luogu-judger-enable-o2\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <set> \n#include <vector>\nusing namespace std;\nstruct node {\n    int l, r;\n    mutable int val;\n    int operator < (const node &a) const {\n        return l < a.l;\n    }\n    node(int L, int R = -1, int Val = 0) : l(L), r(R), val(Val) {} \n};\nset<node> s;\n#define maxn 200100\n#define isdigit(x) ((x) >= '0' && (x) <= '9')\n\n#define sit set<node>::iterator\nsit Split(int pos) {\n    sit it = s.lower_bound(node(pos));\n    if (it != s.end() && it->l == pos) return it;\n    --it;\n    int l = it->l, r = it->r, val = it->val;\n    s.erase(it);\n    s.insert(node(l, pos - 1, val));\n    return s.insert(node(pos, r, val)).first;\n}\nint Assign(int l, int r, int val) {\n    sit it2 = Split(r + 1), it1 = Split(l);\n    int sum = 0, sum2 = val * (r - l + 1);\n    for (sit it = it1; it != it2; ++it) sum += it->val * (it->r - it->l + 1);\n    s.erase(it1, it2);\n    s.insert(node(l, r, val));\n    return abs(sum2 - sum);\n}\nstruct edge {\n    int to, next;\n} e[maxn << 1];\nint son[maxn], fa[maxn], top[maxn], size[maxn], depth[maxn], head[maxn];\nint ecnt, ncnt, rt = 1;\nint pos[maxn];\nvoid adde(int u, int v) {\n    e[++ecnt] = (edge) {v, head[u]};\n    head[u] = ecnt;\t\t\n}\nvoid dfs1(int x) {\n    size[x] = 1;\n    for (int i = head[x]; i; i = e[i].next) {\n        int to = e[i].to;\n        if (to == fa[x]) continue;\n        depth[to] = depth[x] + 1;\n        fa[to] = x;\n        dfs1(to);\n        size[x] += size[to];\n        if (size[son[x]] < size[to]) son[x] = to;\n    }\n}\nvoid dfs2(int x, int t) {\n    pos[x] = ++ncnt;\n    top[x] = t;\n    if (!son[x]) return;\n    dfs2(son[x], t);\n    for (int i = head[x]; i; i = e[i].next) {\n        int to = e[i].to;\n        if (to != fa[x] && to != son[x]) dfs2(to, to);\n    }\n}\nint install(int x, int y) {\n    int res = 0;\n    while (top[x] != top[y]) {\n        if (depth[top[x]] < depth[top[y]]) swap(x, y);\n        res += Assign(pos[top[x]], pos[x], 1);\n        x = fa[top[x]];\n    }\n    if (pos[x] > pos[y]) swap(x, y);\n    res += Assign(pos[x], pos[y], 1);\n    return res;\n}\nint uninstall(int x) {\n    return Assign(pos[x], pos[x] + size[x] - 1, 0);\n}\ninline int read() {\n    int res = 0;\n    char c = getchar();\n    while (!isdigit(c)) c = getchar();\n    while (isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();\n    return res;\n}\nint n, m;\nchar inp[100];\nint main() {\n    n = read();\n    s.insert(node(1, n + 1, 0));\n    for (int i = 2; i <= n; ++i) {\n        int f = read();\n        adde(f + 1, i);\n    }\n    dfs1(rt);\n    dfs2(rt, rt);\n    m = read();\n    while (m--) {\n        scanf(\"%s\", inp);\n        int x = read();\n        if (inp[0] ^ 'u') {\n            printf(\"%d\\n\", install(x + 1, rt));\n        } else {\n            printf(\"%d\\n\", uninstall(x + 1));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1545748903,
        "uid": 73574,
        "name": "WAMonster",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "~~\u9898\u76ee\u597d\u957f\u8bfb\u7684\u597d\u7d2f~~\n\n\u5bf9\u6bcf\u4e2a\u8f6f\u4ef6\n\u4ed6**\u8981\u4f9d\u8d56\u7684\u8f6f\u4ef6\u4f5c\u4e3a\u4ed6\u7684\u7236\u4eb2\u8fde\u8fb9**\u5c31\u5f97\u5230\u4e00\u68f5\u6811\n\n\u5bf9\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\n**\u6743\u503c\u4e3a1\u8868\u793a\u5df2\u5b89\u88c5\uff0c0\u8868\u793a\u672a\u5b89\u88c5**\n\n\u5b89\u88c5\u8f6f\u4ef6\u5305\n\n\u8f6c\u5316\u4e3a\u67e5\u8be2**\u4ece\u8be5\u8282\u70b9\u5230\u6839\u6709\u591a\u5c11\u4e2a\u7ed3\u70b9\u6743\u503c\u4e3a0**\n\n\u90a3\u4e48\u6211\u4eec\u5c31**\u67e5\u8be2\u8be5\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u548c**\n\u7528**\u8be5\u8282\u70b9\u6df1\u5ea6-\u8def\u5f84\u548c**\u5f97\u5230\u7b54\u6848\n\u7136\u540e\u518d**\u66f4\u65b0\u8be5\u8def\u5f84\u5168\u90e8\u7f6e\u4e3a1**\n\n\u5378\u8f7d\u8f6f\u4ef6\u5305\n\n\u67e5\u8be2**\u8be5\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u603b\u6743\u503c\u548c**\n**\u66f4\u65b0\u5b50\u6811\u5168\u90e8\u7f6e\u4e3a0**\n\n\u4e00\u4e2a\u4f18\u5316\n\u53ef\u4ee5\u53d1\u73b0\u6bcf\u6b21**\u67e5\u8be2\u4e0e\u4fee\u6539\u90fd\u662f\u540c\u4e00\u4e2a\u533a\u95f4**\n\u90a3\u4e48\u6211\u4eec**\u4e0d\u7528\u5206\u4e24\u4e2a\u51fd\u6570\u67e5\u8be2\u66f4\u65b0**\n\u76f4\u63a5**\u540c\u65f6\u8fdb\u884c**\u5c31\u597d\uff0c\u5177\u4f53\u89c1\u4ee3\u7801\n\n\u8fd8\u8981\u6ce8\u610f\n\u6bcf\u4e2a\u7ed3\u70b9\u7f16\u53f7\u90fd\u8981**\u540e\u79fb\u4e00\u4f4d**\n**\u4e0d\u80fd\u8ba9\u7f16\u53f7\u5b58\u57280**\n***************************\n\n```\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<cstdio>\nusing namespace std;\n\nint read()\n{\n    int f=1,x=0;\n    char ss=getchar();\n    while(ss<'0'||ss>'9'){if(ss=='-')f=-1;ss=getchar();}\n    while(ss>='0'&&ss<='9'){x=x*10+ss-'0';ss=getchar();}\n    return f*x;\n}\n\nvoid print(int x)\n{\n    if(x<0){putchar('-');x=-x;}\n    if(x>9)print(x/10);\n    putchar(x%10+'0');\n}\n\nint n,k;\nint tot,cnt;\nstruct node{int v,nxt;}E[200010];\nint head[100010];\nint dep[100010],size[100010],fa[100010],top[100010];\nint son[100010],num[100010];\nint sum[500010],set[500010],orsum[500010];\nchar ss[20];\n\nvoid add(int u,int v)\n{\n    E[++tot].nxt=head[u];\n    E[tot].v=v;\n    head[u]=tot;\n}\n\nvoid dfs1(int u,int pa)\n{\n    size[u]=1;\n    for(int i=head[u];i;i=E[i].nxt)\n    {\n        int v=E[i].v;\n        dep[v]=dep[u]+1;\n        dfs1(v,u);\n        size[u]+=size[v];\n        if(size[v]>size[son[u]]) son[u]=v;\n    }\n}\n\nvoid dfs2(int u,int tp)\n{\n    top[u]=tp; num[u]=++cnt;\n    if(son[u]) dfs2(son[u],tp);\n    for(int i=head[u];i;i=E[i].nxt)\n    {\n        int v=E[i].v;\n        if(v==fa[u]||v==son[u]) continue;\n        dfs2(v,v);\n    }\n}\n\nvoid push(int mid,int s,int t,int p)\n{\n    set[p<<1]=set[p<<1|1]=set[p];\n    if(set[p]==0)sum[p<<1]=sum[p<<1|1]=0;\n    else sum[p<<1]=mid-s+1,sum[p<<1|1]=t-mid;\n    set[p]=-1;\n}\n\nint getsum(int ll,int rr,int s,int t,int p,int w)\n{\n    if(ll<=s&&t<=rr){int ans=sum[p]; set[p]=w; sum[p]=(t-s+1)*w; return ans;}//\u5148\u8bb0\u5f55\u7b54\u6848\uff0c\u5728\u66f4\u65b0\uff0c\u653e\u6807\u8bb0\uff0c\u8fd4\u56de\n    int mid=s+t>>1;\n    if(set[p]>=0)push(mid,s,t,p);\n    int ans=0;\n    if(ll<=mid) ans+=getsum(ll,rr,s,mid,p<<1,w);\n    if(rr>mid) ans+=getsum(ll,rr,mid+1,t,p<<1|1,w);\n    sum[p]=sum[p<<1]+sum[p<<1|1];\n    return ans;\n}\n\nint qsum(int u,int v)\n{\n    int ans=0;\n    while(top[u]!=top[v])\n    {\n        if(dep[top[u]]<dep[top[v]]) swap(u,v);\n        ans+=getsum(num[top[u]],num[u],1,n,1,1);\n        u=fa[top[u]];\n    }\n    if(dep[u]>dep[v]) swap(u,v);\n    ans+=getsum(num[u],num[v],1,n,1,1);\n    return ans;\n}\n\nint main()\n{\n    n=read();\n    for(int i=1;i<n;i++)\n    {\n        int u=read()+1;\n        fa[i+1]=u; add(u,i+1);\n    }\n\n    dep[1]=1;\n    dfs1(1,-1); dfs2(1,1);\n\n    memset(set,-1,sizeof(set));\n    int q=read();\n    while(q--)\n    {\n        scanf(\"%s\",&ss);int u=read()+1,ans;\n        \n        if(ss[0]=='i')\n        {\n            ans=qsum(u,1);\n            ans=dep[u]-ans;\n        }\n\n        else if(ss[0]=='u')\n        ans=getsum(num[u],num[u]+size[u]-1,1,n,1,0);\n\n        print(ans);printf(\"\\n\");\n    }\n    return 0;\n}\n```",
        "postTime": 1523098926,
        "uid": 60885,
        "name": "niiick",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "### \u3000\u5176\u5b9e\u8fd9\u9053\u9898\u5404\u4f4ddalao\u7684\u89e3\u6cd5\u90fd\u6bd4\u6211\u4f18\u79c0\uff0c\u6211\u53ea\u662f\u5199\u4e00\u4e9b\u5173\u4e8e\u6811\u5256\u7684\u7406\u89e3\u3002\n\n\n\u3000\u3000\u8fd9\u9053\u9898\u9898\u9762\u5f88\u957f\uff0c\u4f46\u5f52\u6839\u7ed3\u5e95\uff0c\u5176\u5b9e\u5c31\u662f\u9053\u677f\u5b50\u9898\uff1a\u6211\u4eec\u8bbe\u201c1\u201d\u8868\u793a\u8be5\u8f6f\u4ef6\n  \n  \u6ca1\u6709\u88ab\u5b89\u88c5\uff0c\u201c0\u201d\u4ee3\u8868\u5df2\u7ecf\u5b89\u88c5\u3002\u90a3\u4e48install\u64cd\u4f5c\u5c31\u662f\u5148\u6c42\u51fa\u4ece\u8be5\u8282\u70b9\u5230\u6839\u8282\u70b9\n  \n  \u6700\u77ed\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u6743\u4e4b\u548c\uff0c\u518d\u5c06\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u6743\u5168\u90e8\n  \n  \u4fee\u6539\u4e3a\u201c0\u201d\uff0cuninstall\u4e0e\u4e4b\u76f8\u53cd\uff0c\u5e76\u4e14\u64cd\u4f5c\u533a\u95f4\u4e3a\u8be5\u70b9\u5bf9\u5e94\u7684\u5b50\u6811\u3002\n  \n  \u3000\u3000\u7ebf\u6bb5\u6811\u533a\u95f4\u8986\u76d6\u5176\u5b9e\u7279\u522b\u7b80\u5355\uff0c\u53ea\u4e0d\u8fc7\u5c06\u4f20\u7edf\u7ebf\u6bb5\u6811\u4e2d\u7684\u533a\u95f4\u4fee\u6539\uff0c\u4e0b\u4f20\n    \n    \u6807\u8bb0\u4e2d\u6240\u6709\u7684\u201c+=\u201d\u6539\u4e3a\u201c=\u201d\uff0c\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u533a\u95f4\u8986\u76d6\u3002\n    \n# \u4ee3\u7801(\u542b\u6ce8\u610f\u4e8b\u9879)\uff1a\n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<string.h>\nusing namespace std;\n#define half (l+r)>>1;\nconst int maxn=200006;\nint head[maxn],cur,son[maxn],tot[maxn],fa[maxn],top[maxn],id[maxn],val[maxn],bval[maxn],d[maxn],n,m;\n\nstruct hzw \n{\n   int to;\n   int next;\t\n}e[maxn];\n\nstruct ljm\n{\n   \tint tag;\n   \tint w;\n   \tint lc;\n   \tint rc;\n}t[maxn];\n\ninline void add(int a,int b){\n\te[cur].to=b;\n\te[cur].next=head[a];\n\thead[a]=cur++;\n}\n//**************************\nint num=1;\n\ninline void build (int s,int l,int r)\n{  \n   t[s].tag=-1;//\u6807\u8bb0\u521d\u59cb\u503c\u4e3a-1\uff0c\u56e0\u4e3a\u672c\u9898\u8981\u7528\u5230 0 \uff1b \n   if (l==r)\n   {\n      t[s].w=1;\n\t  return;\t\n   }\t\n   int mid=half;\n   t[s].lc=++num;\n   build(t[s].lc,l,mid);\n   t[s].rc=++num;\n   build (t[s].rc,mid+1,r);\n   t[s].w=t[t[s].rc].w+t[t[s].lc].w;\n}\n\ninline void pushdown(int s,int l,int r)\n{\n\tint le=t[s].lc,ri=t[s].rc,mid=half;//\u6240\u6709\u7684 += \u6539\u4e3a =\uff1b \n\tt[le].w=t[s].tag*(mid-l+1);\n\tt[le].tag=t[s].tag;\n\tt[ri].w=t[s].tag* (r-mid);\n\tt[ri].tag=t[s].tag;\n\tt[s].tag=-1;\n}\n\ninline void update(int s,int l,int r,int ll,int rr,int v)\n{\n\tif (l==ll&&r==rr)\n\t{\n\t   t[s].w=v*(r-l+1);//\u628a += \u6539\u4e3a =\uff1b \n\t   t[s].tag=v;\n\t   return;\n\t}\n\tif (t[s].tag!=-1) pushdown(s,l,r);\n\tint mid=half;\n\tif (rr<=mid) update(t[s].lc,l,mid,ll,rr,v);\n\telse if (ll>mid) update(t[s].rc,mid+1,r,ll,rr,v);\n\telse\n\t{\n\t   update(t[s].lc,l,mid,ll,mid,v);\n\t   update(t[s].rc,mid+1,r,mid+1,rr,v);\n\t}\n\tt[s].w=t[t[s].lc].w+t[t[s].rc].w;/*\u4efb\u4f55\u7ebf\u6bb5\u6811\u90fd\u4e0d\u662f\n    t[s].w+=t[t[s].lc].w+t[t[s].rc].w; */\n}\n\ninline int  query(int s,int l,int r,int ll,int rr)\n{\n\tint ans=0;\n    if (l==ll&&r==rr)\n\t{  \n\t    return t[s].w;\n\t}\n\tif (t[s].tag!=-1) pushdown(s,l,r);\n\tint mid=half;\n\tif (rr<=mid) ans+=query(t[s].lc,l,mid,ll,rr);\n\telse if (ll>mid) ans+=query(t[s].rc,mid+1,r,ll,rr);\n\telse\n\t{\n\t   ans+=query(t[s].lc,l,mid,ll,mid);\n\t   ans+=query(t[s].rc,mid+1,r,mid+1,rr);\t\n\t}\n\treturn ans; \n}\n\nbool vis[maxn];\n//*************************\ninline int dfs1(int s,int f,int l)\n{\n\td[s]=l;\n\tfa[s]=f;\n\ttot[s]=1;\n\tint maxs=-23333;//\u8981\u7528\u5c40\u90e8\u53d8\u91cf\uff0c\u4e0d\u8981\u7528\u5168\u5c40\u53d8\u91cf\uff01\uff01\uff01 \n\tfor (int i=head[s];i!=-1;i=e[i].next){\n\t\ttot[s]+=dfs1(e[i].to,s,l+1);\n\t\tif (tot[e[i].to]>maxs){\n\t\t\tmaxs=tot[e[i].to];\n\t\t\tson[s]=e[i].to;\n\t\t}\n\t}\n\treturn tot[s];\n}\n\nint cnt=0;\n\ninline void dfs2(int s,int firs)\n{\n    id[s]=++cnt;\n    top[s]=firs;\n    if (!son[s]) return;\n    dfs2(son[s],firs);//\u5148\u641c\u91cd\u513f\u5b50 \n    for (int i=head[s];i!=-1;i=e[i].next){\n    \tif (id[e[i].to]) continue;\n    \tdfs2(e[i].to,e[i].to);\n\t}\n}\n\ninline void chang(int x,int y,int v)\n{    \n\twhile (top[x]!=top[y])\n\t{  \n\t   \n\t   if (d[top[x]]<d[top[y]]) std::swap(x,y);\n\t   update(1,1,n,id[top[x]],id[x],v);\n\t   x=fa[top[x]];\t\n\t}\n\t\n\tif (d[x]>d[y]) std::swap(x,y);\n\tupdate(1,1,n,id[x],id[y],v);\n}\n\ninline int sum_(int x,int y)\n{\n\tint ans=0;\n\twhile (top[x]!=top[y])\n \t{   \n\t\tif (d[top[x]]<d[top[y]]) std::swap(x,y);\n\t\tans+=query(1,1,n,id[top[x]],id[x]);\n\t\tx=fa[top[x]];\n\t}\n\tif (d[x]>d[y]) std::swap(x,y);\n\tans+=query(1,1,n,id[x],id[y]);\n\treturn ans;\n}\n\ninline void tchang(int x,int v)\n{\n\tupdate(1,1,n,id[x],id[x]+tot[x]-1,v);\n}\n\ninline int tsum(int x)\n{\n    return tot[x]-query(1,1,n,id[x],id[x]+tot[x]-1); \t\n}\n\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n    std::cin>>n;\n    for (int i=2,a;i<=n;++i)\n\t{\n    \tscanf(\"%d\",&a);\n    \ta++;//\u4e60\u60ef\u4ece 1 \u5f00\u59cb\u5efa\u6811\n    \tadd(a,i);\n\t}\n\tdfs1(1,1,1);\n\tdfs2(1,1);\n\tbuild (1,1,n);\n\tstd::cin>>m;\n\tstd::string q;\n\tint p;\n\tfor (int i=1;i<=m;++i)\n\t{\n\t\tstd::cin>>q;\n\t\tscanf(\"%d\",&p);\n\t\tp++;//\u4e60\u60ef\u4ece 1 \u5f00\u59cb\u5efa\u6811 \n\t\tif (q==\"install\")\n\t\t{   \n\t\t\tprintf(\"%d\\n\",sum_(p,1));\n\t\t    chang(p,1,0);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tprintf(\"%d\\n\",tsum(p));\n\t\t\ttchang(p,1);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1526009845,
        "uid": 54926,
        "name": "Apricot",
        "ccfLevel": 0,
        "title": "\u6811\u5256+\u7ebf\u6bb5\u6811\u533a\u95f4\u8986\u76d6"
    },
    {
        "content": "\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\n\n[CTime_Pup_314\u7684\u535a\u5ba2](https://ctp314.github.io/)\n\n\u770b\u9898\u7b2c\u4e00\u611f\u89c9\uff0c\u5b8c\u4e86\u8981\u5361\u8bfb\u9898\n\n\u4ed4\u7ec6\u770b\u540e\u89c9\u5f97\uff0c\u5b8c\u4e86\u597d\u50cf\u7ef4\u62a4\u7684\u662f\u79cd\u7c7b\u4e2a\u6570\u4e0d\u5177\u6709O(1)\u66f4\u65b0\u7684\u4fe1\u606f\n\n~~\u6811\u94fe\u7528\u5206\u5757\u7ef4\u62a4\uff1f~~\n\n\u518d\u4ed4\u7ec6\u770b\u5176\u5b9e\u53d1\u73b0\u6b64\u9898\u53ef\u505a\n\n\u9996\u5148\u89c4\u5b9a1\u4ee3\u8868\u5b89\u88c5\uff0c0\u4ee3\u8868\u4e0d\u5b89\u88c5\n\n\u5bf9\u4e8e\u6bcf\u6b21\u5b89\u88c5\uff0c\u5148\u67e5\u8be2\u5230\u6839\u7684\u8def\u5f84\u4e0a0\u7684\u4e2a\u6570\uff0c\u518d\u75281\u8986\u76d6\n\n\u5bf9\u4e8e\u6bcf\u6b21\u5220\u9664\uff0c\u5148\u67e5\u8be2\u5b50\u68111\u7684\u4e2a\u6570\uff0c\u518d\u75280\u8986\u76d6\n\n\u6240\u4ee5\u5c31\u627e\u5230\u4e00\u4e2a\u53ef\u4ee5\u5904\u7406\u8986\u76d6\u7684\u6570\u636e\u7ed3\u6784\u5373\u53ef\n\n\u7ebf\u6bb5\u6811\u53ef\u4ee5\u7ef4\u62a4\n\n\u8be6\u7ec6\u89c1\u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\nusing namespace std;\nconst int N = 200000+5;\ninline int read()\n{\n    int f = 1, x = 0; char ch;\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) {x = x*10+ch-'0'; ch = getchar();}\n    return f*x;\n}\n\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N<<1];\n\nint head[N], tot;\n\ninline void _add(int x, int y) {edge[++tot] = Edge(head[x], y); head[x] = tot;}\n\ninline void add(int x, int y) { _add(x, y); _add(y, x);}\n\nint n, m;\nint neww[N], w[N];\nint id[N], son[N], deep[N], size[N], cnt, top[N], fa[N];\n\ninline void dfs1(int x, int f)\n{\n    fa[x] = f; size[x] = 1; \n    for(int i = head[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to;\n        if(y == f) continue;\n        deep[y] = deep[x]+1;\n        dfs1(y, x);\n        size[x] += size[y];\n        if(size[y] > size[son[x]]) son[x] = y;\n    }\n}\n\ninline void dfs2(int x, int topf)\n{\n    top[x] = topf; id[x] = ++cnt; neww[id[x]] = w[x];\n    if(!son[x]) return;\n    dfs2(son[x], topf);\n    for(int i = head[x]; i; i = edge[i].next)\n    {\n        int y = edge[i].to;\n        if(y == fa[x]||y == son[x]) continue;\n        dfs2(y, y);\n    }\n}\n\n/*\n\t\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u4e2d1\u7684\u4e2a\u6570\n\t\u6807\u7b7e\u7ef4\u62a4\u533a\u95f4\u8986\u76d6 \n\ttag\u4e3a0\u5219\u65e0\u6807\u8bb0\uff0c1\u5219\u75280\u8986\u76d6\u533a\u95f4\uff0c2\u5219\u75281\u8986\u76d6\u533a\u95f4 \n*/ \nint tag[N<<2], sum[N<<2];\n\ninline void pushup(int x) { sum[x] = sum[x<<1]+sum[x<<1|1]; } //\u5411\u4e0a\u4f20\u9012\u76f4\u63a5\u76f8\u52a0\u5c31\u597d\u4e86\uff0c\u4fe1\u606f\u5177\u6709\u533a\u95f4\u53ef\u52a0\u6027 \ninline void pushdown(int x, int l, int r, int mid)\n{\n    tag[x<<1] = tag[x]; tag[x<<1|1] = tag[x]; // \u8986\u76d6\u6807\u8bb0\u76f4\u63a5\u4e0b\u4f20 \n    if(tag[x] == 1) sum[x<<1] = sum[x<<1|1] = 0; // \u82e5\u75280\u8986\u76d6\u5219\u4e24\u4e2a\u5b50\u533a\u95f41\u7684\u4e2a\u6570\u90fd\u4e3a0 \n    else if(tag[x] == 2) sum[x<<1] = mid-l+1, sum[x<<1|1] = r-mid; // \u53cd\u4e4b\u5219\u4e3a\u533a\u95f4\u7684\u957f\u5ea6 \n\ttag[x] = 0;\n}\n\ninline int ask(int x, int l, int r, int ql, int qr)\n{\n    if(ql <= l&&r <= qr) return sum[x];\n    int mid = l+r>>1; int ret = 0;\n    if(tag[x]) pushdown(x, l, r, mid);\n    if(ql <= mid) ret += ask(x<<1, l, mid, ql, qr);\n    if(qr > mid) ret += ask(x<<1|1, mid+1, r, ql, qr);\n    return ret;\n}\n\ninline void change(int x, int l, int r, int ql, int qr, int d)\n{\n    if(ql <= l&&r <= qr)\n    {\n    \t//\u4fee\u6539\u65f6\u5c31\u6253\u4e0a\u6807\u8bb0\uff0c\u91cd\u7f6esum\u5c31\u597d\u4e86 \n    \ttag[x] = d; \n    \tif(d == 1) sum[x] = 0;\n    \telse if(d == 2) sum[x] = r-l+1;\n    \treturn;\n    }\n    int mid = l+r>>1;\n    if(tag[x]) pushdown(x, l, r, mid);\n    if(ql <= mid) change(x<<1, l, mid, ql, qr, d);\n    if(qr > mid) change(x<<1|1, mid+1, r, ql, qr, d);\n    pushup(x);\n}\n\n// \u67e5\u8be2\u94fe\u4e0a\u76840\u7684\u4e2a\u6570 \ninline int qRange(int x, int y)\n{\n\tint ret = 0;\n    while(top[x] != top[y])\n    {\n        if(deep[top[x]] < deep[top[y]]) swap(x, y);\n        ret += id[x] - id[top[x]] + 1 - ask(1, 1, n, id[top[x]], id[x]); //\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f1\u7684\u4e2a\u6570\uff0c\u7528\u533a\u95f4\u957f\u5ea6\u53bb\u51cf\u5373\u53ef \n        x = fa[top[x]];\n    }\n    if(deep[x] < deep[y]) swap(x, y);\n    ret += id[x] - id[y] + 1 - ask(1, 1, n, id[y], id[x]);\n    return ret;\n}\n\n// \u75281\u8986\u76d6\u6811\u94fe \ninline void cRange(int x, int y, int d)\n{\n    while(top[x] != top[y])\n    {\n        if(deep[top[x]] < deep[top[y]]) swap(x, y);\n        change(1, 1, n, id[top[x]], id[x], d);\n        x = fa[top[x]];\n    }\n    if(deep[x] < deep[y]) swap(x, y);\n    change(1, 1, n, id[y], id[x], d);\n}\n\n// \u67e5\u8be2\u5b50\u6811\u4e3a1\u7684\u4e2a\u6570 \ninline int qSon(int x) { return ask(1, 1, n, id[x], id[x]+size[x]-1); }\n\n// \u8986\u76d6\u5b50\u6811 \ninline void cSon(int x, int d) {change(1, 1, n, id[x], id[x]+size[x]-1, d); }\n\nint main()\n{\n    n = read(); \n    for(int x = 2; x <= n; x++)\n    {\n        int y = read()+1; // \u8282\u70b9\u4ece0\u7f16\u53f7\u7684\u5f02\u7aef \n        add(y, x);\n    }\n\tm = read();\n    dfs1(1, 0); dfs2(1, 1);\n    while(m--)\n    {\n        char op[20]; scanf(\"%s\", op);\n        int x = read()+1;\n        if(op[0] == 'i')\n        {\n        \t// \u5bf9\u4e8e\u4e0b\u8f7d\u64cd\u4f5c\u5206\u89e3\u4e3a\u4e24\u4e2a \n        \tprintf(\"%d\\n\", qRange(1, x)); // \u67e5\u8be2\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a0\u7684\u4e2a\u6570 \n        \tcRange(1, x, 2); // \u75281\u8986\u76d6\u8fd9\u6761\u8def\u5f84 \n        }\n        else \n        {\n        \t// \u4e0e\u5220\u9664\u540c\u7406 \n        \tprintf(\"%d\\n\", qSon(x)); // \u67e5\u8be2\u5b50\u6811\u4e2d1\u7684\u4e2a\u6570 \n        \tcSon(x, 1); // \u75280\u8986\u76d6\u5b50\u6811 \n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1545295487,
        "uid": 123514,
        "name": "CTime_Pup_314",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P2146 [NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668"
    },
    {
        "content": "### \u7b80\u5316\u9898\u610f\n\u7ed9\u4f60\u4e00\u68f5\u6811\uff0c\u6700\u521d\u5168\u90fd\u662f$0$\uff0c\u7ed3\u70b9\u4ece$0$\u5230$n-1$\uff0c$0$\u662f\u6839\u7ed3\u70b9\n\n\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n> $1.$\u5c06\u4ece\u6839\u5230$x$\u7ed3\u70b9\u7684\u552f\u4e00\u8def\u5f84\u6709\u591a\u5c11\u4e2a$0$\u6c42\u51fa\u6765\uff0c\u5e76\u5c06\u8fd9\u4e2a\u552f\u4e00\u8def\u5f84\u5168\u90e8\u8d4b\u503c\u4e3a$1$\n\n> $2.$\u5c06\u4ee5$x$\u7ed3\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u6709\u591a\u5c11\u4e2a$1$\u6c42\u51fa\u6765\uff0c\u5e76\u5c06\u8fd9\u4e2a\u5b50\u6811\u5168\u90e8\u8d4b\u503c\u4e3a$0$\n\n### \u9898\u76ee\u5206\u6790\n\u55ef.\u5e26\u4fee\u6539\u7684\u6811\u4e0a\u64cd\u4f5c\uff0c\u7edf\u8ba1\u8def\u5f84\u6216\u5b50\u6811\u7684\u548c\uff0c\u90a3\u4e48\u5c31\u662f[$\\color{red}\\text{\u6811\u94fe\u5256\u5206\u677f\u5b50\u9898}$](https://www.luogu.org/problemnew/show/P3384)\n\n**\u64cd\u4f5c1**:$x$\u53f7\u7ed3\u70b9\u7684\u6df1\u5ea6\u51cf\u6389\u8def\u5f84\u4e0a$1$\u7684\u4e2a\u6570\u5f97\u5230\u7b54\u6848\uff0c\u63a5\u7740\u66f4\u65b0\u4e3a$1$\n\n**\u64cd\u4f5c2**:\u8003\u8651$DFS$\u5e8f\uff0c\u540c\u4e00\u68f5\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u7f16\u53f7\u4e00\u5b9a\u662f\u8fde\u7eed\u7684\uff0c\u76f4\u63a5\u6c42\u548c\uff0c\u7136\u540e\u66f4\u65b0\u4e3a$0$\n### \u6ce8\u610f\n\u4e0d\u8981\u7528$0$\u8868\u793a$lazytag$\u4e0d\u66f4\u65b0\uff0c\u56e0\u4e3a\u66f4\u65b0\u7684\u65f6\u5019\u4f1a\u6709$0$\n\n\u4ee3\u7801\u4e2d\u4e3a\u4e86\u65b9\u4fbf\u5904\u7406\uff0c\u5c06\u4e0b\u6807\u5f04\u6210\u4e86\u4ece$1$\u5f00\u59cb\n### $code:$\n\u4ee3\u7801\u81ea\u5df1\u770b\uff0c\u4e0d\u4f1a\u6811\u94fe\u5256\u5206\u7684\u76f4\u63a5\u770b\u6a21\u677f\u7684\u9898\u89e3\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvector<int> e[100001];\nint n,m,u,ans,d[100001],sz[100001],fa[100001],son[100001],top[100001],seg[100001],tree[400001],add[400001];\nstring opt;\n#define pushup(pos) tree[pos]=tree[pos<<1]+tree[pos<<1|1]\nint read(){\n    char ch=getchar();int res=0,w=1;\n    while(ch<'0'||ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9') {res=res*10+ch-'0';ch=getchar();}\n    return res*w;\n}\nvoid pushdown(int pos,int ls,int rs){\n    if(add[pos]!=-1)\n    {\n    \tadd[pos<<1]=add[pos<<1|1]=add[pos];\n        tree[pos<<1]=add[pos]*ls;tree[pos<<1|1]=add[pos]*rs;\n        add[pos]=-1;\n    }\n}\nvoid dfs1(int x){\n    sz[x]=1;d[x]=d[fa[x]]+1;\n    for(register int i=0;i<e[x].size();i++)\n    {\n    \tdfs1(e[x][i]);\n        sz[x]+=sz[e[x][i]];\n        if(sz[e[x][i]]>sz[son[x]]) son[x]=e[x][i];\n    }\n}\nvoid dfs2(int x){\n    if(son[x])\n    {\n        top[son[x]]=top[x];\n        seg[son[x]]=++seg[0];\n        dfs2(son[x]);\n    }\n    for(register int i=0;i<e[x].size();i++)\n        if(!top[e[x][i]])\n        {\n            top[e[x][i]]=e[x][i];\n            seg[e[x][i]]=++seg[0];\n            dfs2(e[x][i]);\n        }\n}\nvoid update(int l,int r,int pos,int L,int R,int x){\n    if(L<=l&&r<=R) {tree[pos]=(r-l+1)*x;add[pos]=x;return;}\n    int mid=(l+r)>>1;\n    pushdown(pos,mid-l+1,r-mid);\n    if(mid>=L) update(l,mid,pos<<1,L,R,x);\n    if(R>mid) update(mid+1,r,pos<<1|1,L,R,x);\n    pushup(pos);\n}\nint query(int l,int r,int pos,int L,int R){\n    if(L<=l&&r<=R) return tree[pos];\n    int mid=(l+r)>>1,res=0;\n    pushdown(pos,mid-l+1,r-mid);\n    if(mid>=L) res+=query(l,mid,pos<<1,L,R);\n    if(R>mid) res+=query(mid+1,r,pos<<1|1,L,R);\n    return res;\n}\nsigned main(){\n    n=read();\n\tmemset(add,-1,sizeof(add));\n    for(register int i=2;i<=n;i++) e[fa[i]=read()+1].push_back(i);\n    dfs1(1);\n    seg[0]=seg[1]=top[1]=1;\n    dfs2(1);\n\tm=read();\n    while(m--)\n    {\n        cin>>opt;u=read()+1;ans=0;\n        if(opt==\"install\")\n        {\n            while(top[u]!=1) {ans+=d[u]-d[top[u]]+1-query(1,seg[0],1,seg[top[u]],seg[u]);update(1,seg[0],1,seg[top[u]],seg[u],1);u=fa[top[u]];}\n            ans+=d[u]-query(1,seg[0],1,1,seg[u]);update(1,seg[0],1,1,seg[u],1);\n        }\n        else if(opt==\"uninstall\") {ans=query(1,seg[0],1,seg[u],seg[u]+sz[u]-1);update(1,seg[0],1,seg[u],seg[u]+sz[u]-1,0);}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1554647280,
        "uid": 80679,
        "name": "Register",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u4e2a\u672c\u9898\u7684\u4e00\u53ealog\u505a\u6cd5~~\u867d\u7136\u5b9e\u9645\u8dd1\u5f97\u6bd4\u4e24\u4e2alog\u8fd8\u6162~~\n\n\u9898\u610f\uff1a\u5230\u6839\u8def\u5f84\u8986\u76d61 \u5b50\u6811\u8986\u76d60 \u5168\u6811\u6c42\u548c\n\n\u663e\u7136\u53ef\u4ee5dfs\u5e8f\u7ed3\u5408\u6811\u5256\u7ebf\u6bb5\u6811$O(n \\log ^2 n)$\u7ef4\u62a4\n\n\u8fd9\u4e2a\u4e1c\u897f\u7684\u74f6\u9888\u5728\u4e8e\u5230\u6839\u8def\u5f84\u8981\u53bb\u6811\u5256\n\n\u867d\u7136\u8fd9\u4e2a\u73a9\u610f\u5e38\u6570\u5f88\u5c0f\uff0c\u4f46\u662f\u7406\u8bba\u5c31\u662f\u4e24\u4e2alog\n\n\u5f15\u5165\u4e00\u4e2a~~\u7b80\u5355~~\u6570\u636e\u7ed3\u6784:**Self-adjusting Top Trees**\n\n\u5b66\u4e60\u89c1[negiizhao\u7684\u535a\u5ba2](http://negiizhao.blog.uoj.ac/blog/4912)\n\n\u5bf9\u4e8e\u6b64\u9898\uff0c\u6bcf\u4e2a\u7c07\u7ef4\u62a4\uff0c\u7c07\u8def\u5f84\u6743\u503c\u548c/\u6807\u8bb0\uff0c\u9664\u7c07\u8def\u5f84\u4ee5\u5916\u7684\u5185\u70b9\u6743\u503c\u548c/\u6807\u8bb0\n\n\u8fd9\u4e2a\u4e1c\u897f\u7406\u8bba\u65f6\u95f4\u590d\u6742\u5ea6\u662f$O(n \\log  n)$\u7684\n\n\u7531\u4e8e\u4e0d\u77e5\u9053\u4ec0\u4e48\u539f\u56e0\uff0c\u672c\u4eba\u4e0d\u5c06satt\u4ee3\u7801\u516c\u5f00\n\n~~\u5199\u4e86210\u884c\u7ed3\u679c\u8fd8\u8dd1\u5f97\u6bd4\u522b\u4eba\u6162~~\n\n```cpp\n#include<cstdio>\n#include<cstddef>\ntemplate<class type>inline const void read(type &in)\n{\n\tin=0;char ch(getchar());bool f(0);\n\twhile (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}\n\twhile (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();\n\tif (f)in=-in;\n}\ntemplate<class type>inline const type abs(const type &x)\n{\n\treturn x<0?-x:x;\n}\ntemplate<class type>inline const void swap(type &a,type &b)\n{\n\tconst type c(a);a=b;b=c;\n}\nconst int N(1e5+10);\nnamespace Self_Adjusting_Top_Trees\n{\n}using namespace Self_Adjusting_Top_Trees;\nint n,m;\nint main()\n{\n\tread(n);\n\tnode0=new tree[n+1];\n\tfor (int fa,i(2);i<=n;i++)read(fa),link(node(fa+1),node(i));\n\tread(m);char opt[10];\n\tfor (int p,now,pre(0);m--;printf(\"%d\\n\",abs(pre-(now=subtree_sum(node(1))))),pre=now)\n\t\tif (scanf(\"%s\",opt),read(p),p++,opt[0]=='i')path_cover(node(p),1);\n\t\telse subtree_cover(node(p),0);\n\treturn 0;\n}\n```",
        "postTime": 1577544657,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": ">> \u6d1b\u8c37\u9898\u76ee\u94fe\u63a5\uff1a[[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://www.luogu.org/problem/P2146)\n\n>> LOJ\u9898\u76ee\u94fe\u63a5\uff1a[[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://loj.ac/problem/2130)\n\n\u9898\u89e3\u539f\u53d1\u4e8e[\u6211\u7684blog](https://wangjunrui.netlify.com/2019/10/24/%E6%B4%9B%E8%B0%B7-p2146-noi2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/)\n\n\u9996\u5148\uff0c\u5f88\u660e\u663e\u8fd9\u662f\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u9898\u3002\n\n\u6ce8\u610f\u5230\u4e00\u4e2a\u8f6f\u4ef6\u53ea\u4f1a\u4ee5\u6765\u4e00\u4e2a\u8f6f\u4ef6\uff0c\u5e76\u4e14\u4e0d\u4f1a\u51fa\u73b0\u73af\uff0c\u6240\u4ee5\u6bcf\u6b21\u90fd\u53ef\u4ee5\u8fde\u4e00\u6761$(x\\ ,\\ i)$\u7684\u8fb9\u3002\n\n\n\n\u5f53\u5b89\u88c5\u4e00\u4e2a\u8f6f\u4ef6\u65f6\uff0c\u5c31\u628a$(1\\ ,\\ x)$\u7684\u8def\u5f84\u4e0a\u6240\u6709\u7684\u70b9\u7684\u8f6c\u6001\u53d8\u4e3a$1$\n\n\u4f46\u5378\u8f7d\u4e00\u4e2a\u8f6f\u4ef6\u65f6\uff0c\u5c31\u628a$x$\u53ca\u5b83\u7684\u6240\u6709\u7684\u5b50\u6811\u53d8\u4e3a$0$\n\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\n\n\u63a8\u8350\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u597d\u9898[\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.org/problem/P3384)\n\n\u505a\u5b8c\u8fd9\u9053\u9898\u5c31\u53ef\u4ee5\u5dee\u4e0d\u591a\u5b66\u5b8c\u6240\u6709\u5173\u4e8e\u6811\u94fe\u5256\u5206\u7684\u829d\u58eb\n\n\u6700\u540e\u8d34\u4e0a\u4ee3\u7801~~\u77e5\u9053\u4f60\u4eec\u53ea\u770b\u8fd9\u4e2a~~\uff1a\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntemplate <typename T>\ninline void read(T &x)\n{\n\tx = 0;\n\tchar s = getchar();\n\tbool f = false;\n\twhile (!(s >= '0' && s <= '9'))\n\t{\n\t\tif (s == '-')\n\t\t\tf = true;\n\t\ts = getchar();\n\t}\n\twhile (s >= '0' && s <= '9')\n\t{\n\t\tx = (x << 1) + (x << 3) + s - '0';\n\t\ts = getchar();\n\t}\n\tif (f)\n\t\tx = (~x) + 1;\n}\n#define re register\n#define ls (k << 1)\n#define rs (k << 1 | 1)\nconst int N = 1e5 + 10, M = 2e5 + 10, T = 4e5 + 10;\nstruct Edge\n{\n\tint next, to;\n} edge[M];\nint num_edge, head[N];\nstruct Tree\n{\n\tint l, r, size, sum, flag;\n} tree[T];\nchar s[110];\nint n, q, cnt;\nint idx[N], rk[N], dep[N], fa[N], top[N], size[N], son[N];\t\t//rk[i]\u5176\u5b9e\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\u8fd9\u53ea\u662f\u6211\u7684\u4e60\u60ef \ninline void add_edge(int from, int to)\n{\n\tedge[++num_edge].next = head[from];\n\tedge[num_edge].to = to;\n\thead[from] = num_edge;\n}\ninline void dfs1(int u, int f)\n{\n\tfa[u] = f;\n\tdep[u] = dep[f] + 1;\n\tsize[u] = 1;\n\tfor (re int i = head[u]; i; i = edge[i].next)\n\t{\n\t\tint &v = edge[i].to;\n\t\tif (v == f)\n\t\t\tcontinue;\n\t\tdfs1(v, u);\n\t\tsize[u] += size[v];\n\t\tif (size[son[u]] < size[v])\n\t\t\tson[u] = v;\n\t}\n}\ninline void dfs2(int u, int tp)\n{\n\tidx[u] = ++cnt;\n\trk[cnt] = u;\n\ttop[u] = tp;\n\tif (!son[u])\n\t\treturn;\n\tdfs2(son[u], tp);\n\tfor (re int i = head[u]; i; i = edge[i].next)\n\t{\n\t\tint &v = edge[i].to;\n\t\tif (idx[v])\n\t\t\tcontinue;\n\t\tdfs2(v, v);\n\t}\n}\ninline void pushdown(int k)\n{\n\tif (~tree[k].flag)//\u76f8\u5f53\u4e8etree[k].flag!=-1 \n\t{\n\t\ttree[ls].sum = tree[ls].size * tree[k].flag;\n\t\ttree[rs].sum = tree[rs].size * tree[k].flag;\n\t\ttree[ls].flag = tree[rs].flag = tree[k].flag;\n\t\ttree[k].flag = -1;\n\t}\n}\ninline void build(int k, int l, int r)\n{\n\ttree[k].l = l;\n\ttree[k].r = r;\n\ttree[k].size = r - l + 1;\n\tif (l == r)\n\t{\n\t\ttree[k].flag = -1;\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(ls, l, mid);\n\tbuild(rs, mid + 1, r);\n}\ninline void update1(int k, int l, int r, int val)\n{\n\tif (l <= tree[k].l && tree[k].r <= r)\n\t{\n\t\ttree[k].sum = tree[k].size * val;\n\t\ttree[k].flag = val;\n\t\treturn;\n\t}\n\tint mid = (tree[k].l + tree[k].r) >> 1;\n\tpushdown(k);\n\tif (l <= mid)\n\t\tupdate1(ls, l, r, val);\n\tif (mid < r)\n\t\tupdate1(rs, l, r, val);\n\ttree[k].sum = tree[ls].sum + tree[rs].sum;\n}\ninline void update2(int x, int y)\n{\n\twhile (top[x] != top[y])\n\t{\n\t\tif (dep[top[x]] < dep[top[y]])\n\t\t\tswap(x, y);\n\t\tupdate1(1, idx[top[x]], idx[x], 1);\n\t\tx = fa[top[x]];\n\t}\n\tif (dep[x] > dep[y])\n\t\tswap(x, y);\n\tupdate1(1, idx[x], idx[y], 1);\n}\nint main()\n{\n\tread(n);\n\tfor (re int i = 2, x; i <= n; ++i)\n\t{\n\t\tread(x);\n\t\tadd_edge(x + 1, i);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\tbuild(1, 1, n);\n\tread(q);\n\tfor (re int i = 1, before, x; i <= q; ++i)\n\t{\n\t\tscanf(\"%s\", s);\n\t\tread(x);\n\t\t++x;\n\t\tbefore = tree[1].sum;\n\t\tif (s[0] == 'i')\n\t\t{\n\t\t\tupdate2(1, x);\n\t\t\tprintf(\"%d\\n\", tree[1].sum - before);\n\t\t}\n\t\telse if (s[0] == 'u')\n\t\t{\n\t\t\tupdate1(1, idx[x], idx[x] + size[x] - 1, 0);\n\t\t\tprintf(\"%d\\n\", before - tree[1].sum);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n~~\u9a6c\u8702\u5dee\u8bc4~~\n\n",
        "postTime": 1571922993,
        "uid": 133322,
        "name": "QwQ\u849f\u84bbwjr",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u540c\u6b65\u53d1\u8868\u4e8e[$\\tt{Blog}$](https://stevebraveman.github.io/2018/12/20/52/)\n\n\u5982\u679c\u75281\u8868\u793a\u5df2\u5b89\u88c5\uff0c0\u8868\u793a\u672a\u5b89\u88c5\uff0c\u90a3\u4e48\u5148\u5c06\u8fd9\u9053\u9898\u8f6c\u6362\u6210\u4eba\u8bdd\uff1a\n\n\u64cd\u4f5cinstall\uff1a\u7edf\u8ba1x\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u4e3a0\u7684\u8282\u70b9\u4e2a\u6570\u5e76\u8f93\u51fa\uff0c\u5e76\u628a\u8fd9\u4e00\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u90fd\u8d4b\u503c\u4e3a1\n\n\u64cd\u4f5cuninstall\uff1a\u7edf\u8ba1\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u4e3a1\u7684\u4e2a\u6570\uff0c\u5e76\u628a\u8fd9\u4e2a\u5b50\u6811\u4e0a\u7684\u8282\u70b9\u90fd\u8d4b\u503c\u4e3a0\n\n\u7136\u540e\u8fd9\u9053\u9898\u5c31\u5f88\u597d\u7406\u89e3\u4e86\u3002\n\n\u5982\u4f55\u89e3\u51b3\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u5462\uff0c\u5f88\u7b80\u5355\uff0c\u5148\u7edf\u8ba1\u51fa\u8282\u70b9\u4e3a1\u7684\u4e2a\u6570\uff0c\u518d\u7528x\u7684\u6df1\u5ea6-\u8282\u70b9\u4e3a1\u7684\u4e2a\u6570\uff0c\u7136\u540e\u518d\u7528\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u8986\u76d6\u5c31\u53ef\u4ee5\u4e86\n\n\u4e3a\u4ec0\u4e48\u8981\u7528x\u7684\u6df1\u5ea6\uff0c\u56e0\u4e3ax\u7684\u6df1\u5ea6\u5c31\u662f\u4ece\u6839\u8282\u70b9\u5230x\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u4e2a\u6570\n\n\u90a3\u4e48\u7b2c\u4e8c\u4e2a\u64cd\u4f5c\u5462\uff0c\u4e5f\u5f88\u7b80\u5355\uff0c\u76f4\u63a5\u7edf\u8ba1\u5b50\u6811\u4e0a1\u7684\u4e2a\u6570\uff0c\u7136\u540e\u518d\u8986\u76d6\u3002\n\n\u4e0b\u9762\u662f~~\u6109\u5feb\u7684~~\u4ee3\u7801\u65f6\u95f4\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ls(x) ((x) << 1)\n#define rs(x) ((x) << 1 | 1)\n#define INF 0x7fffffff\n#define MAXN 5000000\n#define abs(x) ((x) < 0 ? (-x) : (x))\nint max(int a, int b) {\n\tif (a > b) return a;\n\telse return b;\n}\nvoid swap(int &x, int &y) {\n\tint t = x;\n\tx = y;\n\ty = t;\n}\nstruct Edge {\n\tint v, nx;\n}e[MAXN];\nint head[MAXN], ecnt, n, m, x, y, dep[MAXN], si[MAXN], wt[MAXN], w[MAXN], fat[MAXN];\nint fa[MAXN], top[MAXN], son[MAXN], cnt, r = 1, id[MAXN], f[MAXN];\nvoid add(int f, int t) {\n\te[++ecnt] = (Edge) {t, head[f]};\n\thead[f] = ecnt;\n}\nstruct Segtree {\n\tint a[MAXN], b[MAXN << 2], lazy[MAXN << 2];\n\tvoid pd(int p) {\n\t\tb[p] = b[ls(p)] + b[rs(p)];\n\t}\n\tvoid build(int l, int r, int p) {\n\t\tlazy[p] = -1;\n\t\tif (l == r) {\n\t\t\tb[p] = a[l];\n\t\t\treturn;\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tbuild(l, m, ls(p));\n\t\tbuild(m + 1, r, rs(p));\n\t\tpd(p);\n\t}\n\tvoid f(int p, int l, int r, int k) {\n\t\tlazy[p] = k;\n\t\tb[p] = k * (r - l + 1);\n\t\treturn;\n\t}\n\tvoid pushd(int p, int l, int r) {\n\t\tif (lazy[p] != -1) {\n\t\t\tint m = (l + r) >> 1;\n\t\t\tf(ls(p), l, m, lazy[p]);\n\t\t\tf(rs(p), m + 1, r, lazy[p]);\n\t\t\tlazy[p] = -1;\n\t\t}\n\t}\n\tvoid updater(int x, int y, int l, int r, int p, int k) {\n\t\tif (x <= l && y >= r) {\n\t\t\tlazy[p] = k;\n\t\t\tb[p] = k * (r - l + 1);\n\t\t\treturn;\n\t\t}\n\t\tpushd(p, l, r);\n\t\tint m = (l + r) >> 1;\n\t\tif (x <= m) updater(x, y, l, m, ls(p), k);\n\t\tif (y > m) updater(x, y, m + 1, r, rs(p), k);\n\t\tpd(p);\n\t}\n\tint qsum(int x, int y, int l, int r, int p) {\n\t\tint s = 0;\n\t\tif (x <= l && y >= r) {\n\t\t\treturn b[p];\n\t\t}\n\t\tint m = (l + r) >> 1;\n\t\tpushd(p, l, r);\n\t\tif (x <= m) s += qsum(x, y, l, m, ls(p));\n\t\tif (y > m) s += qsum(x, y, m + 1, r, rs(p));\n\t\treturn s;\n\t}\n}tree;\nvoid dfs1(int u, int f, int deep) {\n\tdep[u] = deep;\n\tfa[u] = f;\n\tsi[u] = 1;\n\tfor (int i = head[u]; i; i = e[i].nx) {\n\t\tint to = e[i].v;\n\t\tif (to == f) continue;\n\t\tdfs1(to, u, deep + 1);\n\t\tsi[u] += si[to];\n\t\tif (si[to] > si[son[u]]) son[u] = to;\n\t}\n}\nvoid dfs2(int u, int topf) {\n\tid[u] = ++cnt;\n\twt[cnt] = w[u];\n\ttop[u] = topf;\n\tif (!son[u]) return;\n\tdfs2(son[u], topf);\n\tfor (int i = head[u]; i; i = e[i].nx) {\n\t\tint to = e[i].v;\n\t\tif (fa[u] == to || to == son[u]) continue;\n\t\tdfs2(to, to);\n\t}\n}\ninline void upr(int x, int y, int k) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\ttree.updater(id[top[x]], id[x], 1, n, 1, k);\n\t\tx = fa[top[x]];\n\t}\n\tif (dep[x] > dep[y]) swap(x, y);\n\ttree.updater(id[x], id[y], 1, n, 1, k);\n}\ninline int tq(int x, int y) {\n\tint ans = 0;\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\tans += tree.qsum(id[top[x]], id[x], 1, n, 1);\n\t\tx = fa[top[x]];\n\t}\n\tif (dep[x] > dep[y]) swap(x, y);\n\tans += tree.qsum(id[x], id[y], 1, n, 1);\n\treturn ans;\n}\ninline void ups(int x, int k) {\n\ttree.updater(id[x], id[x] + si[x] - 1, 1, n, 1, k);\n}\ninline int qs(int x) {\n\treturn tree.qsum(id[x], id[x] + si[x] - 1, 1, n, 1);\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 2; i <= n; i++) {\n\t\tscanf(\"%d\", &x);\n\t\tx++;\n\t\tfat[i]++;\n\t\tadd(i, x);\n\t\tadd(x, i);\n\t}\n\tdfs1(r, -1, 1);\n\tdfs2(r, r);\n\ttree.build(1, n, 1);\n\tscanf(\"%d\", &m);\n\twhile (m--) {\n\t\tchar op[20];\n\t\tscanf(\"%s\", op);\n\t\tif (op[0] == 'i') {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tx++;\n\t\t\tprintf(\"%d\\n\", dep[x] - tq(x, r));\n\t\t\tupr(x, r, 1);\n\t\t}\n\t\tif (op[0] == 'u') {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tx++;\n\t\t\tprintf(\"%d\\n\", qs(x));\n\t\t\tups(x, 0);\n\t\t}\n\t}\n}\n```",
        "postTime": 1545312267,
        "uid": 96570,
        "name": "RiverFun",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "### \u6811\u94fe\u5256\u5206\uff08~~\u8fd8\u662f\u88f8\u7684~~\uff09\n\n\u7136\u800c\u5373\u4f7f\u662f\u88f8\u9898\u4e5f\u6ca1\u6709\u90a3\u4e48\u7b80\u5355\uff0c\u6709\u5f88\u591a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\u3002\n\n---\n\n\u5148\u4ece\u9898\u9762\u4e2d\u627e\u5230\u5173\u952e\u4fe1\u606f\uff1a\n\n>  _\u9664 `00` \u53f7\u8f6f\u4ef6\u5305\u4ee5\u5916\uff0c\u5728\u4f60\u7684\u7ba1\u7406\u5668\u5f53\u4e2d\u7684\u8f6f\u4ef6\u5305\u90fd\u4f1a\u4f9d\u8d56\u4e00\u4e2a\u4e14\u4ec5\u4e00\u4e2a\u8f6f\u4ef6\u5305\uff0c\u800c `00` \u53f7\u8f6f\u4ef6\u5305\u4e0d\u4f9d\u8d56\u4efb\u4f55\u4e00\u4e2a\u8f6f\u4ef6\u5305\u3002\u4e14\u4f9d\u8d56\u5173\u7cfb\u4e0d\u5b58\u5728\u73af\u3002_\n \n \u53ef\u4ee5\u5224\u65ad\u8f6f\u4ef6\u5305\u7684\u4f9d\u8d56\u5173\u7cfb\u662f\u4e00\u4e2a\u6811\u5f62\u7ed3\u6784\uff0c\u4e8e\u662f\u5c31\u80fd\u505a\u6811\u4e0a\u64cd\u4f5c\u4e86\u3002\n \n---\n\n### \u64cd\u4f5c\n\n+ `install` \u64cd\u4f5c\n\n\u4e0d\u96be\u53d1\u73b0\uff0c\u5982\u679c\u8981\u5b89\u88c5\u7f16\u53f7\u4e3a `a` \u7684\u8f6f\u4ef6\uff0c\u5219\u5fc5\u987b\u5148\u5b89\u88c5 `fa[a]` \uff0c\u5373 `a` \u6240\u4f9d\u8d56\u7684\u8f6f\u4ef6\u3002\u8fd9\u79cd\u5173\u7cfb\u5c42\u5c42\u5411\u4e0a\u4f20\u9012\uff0c\u53ef\u4ee5\u53d1\u73b0\uff1a\n\n\u5b89\u88c5 `a` \u9700\u8981\u5b89\u88c5 **`a~root`\u94fe\u4e0a\u7684\u5168\u90e8\u8f6f\u4ef6**\u3002\n\n+ `uninstall` \u64cd\u4f5c\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u5378\u8f7d\u7f16\u53f7\u4e3a `a` \u7684\u8f6f\u4ef6\uff0c\u987b\u5c06\u4f9d\u8d56\u5b83\u7684\u6240\u6709\u8f6f\u4ef6\u90fd\u5378\u8f7d\uff0c\u5373\uff1a\n\n\u5378\u8f7d `a` \u9700\u8981\u5378\u8f7d **\u4ee5 `a` \u4e3a\u6839\u7684\u5b50\u6811\u4e0a\u7684\u6240\u6709\u8f6f\u4ef6**\n\n---\n\n\u53c8\u662f\u94fe\u53c8\u662f\u5b50\u6811\uff0c\u4e8e\u662f\u6211\u4eec\u5c31\u60f3\u5230\u4e86**\u6811\u94fe\u5256\u5206**\u3002\n\n~~\u5176\u5b9e\u662f\u53ea\u4f1a\u6811\u94fe\u5256\u5206~~\n\n\u7528 `1` \u8868\u793a\u5df2\u5b89\u88c5\uff0c`0` \u8868\u793a\u672a\u5b89\u88c5\u3002\u7528\u6811\u94fe\u5256\u5206\u5256\u51fa\u6765\u540e\uff0c\u518d\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6811\u4e0a\u4fe1\u606f\u5373\u53ef\u3002\n\n\u5176\u4e2d\u7528\u4e00\u4e2a\u6807\u8bb0\u6807\u8bb0\u6b64\u533a\u95f4\u72b6\u6001\u662f\u5426\u76f8\u540c\uff0c\u82e5\u76f8\u540c\u5219\u53ef\u76f4\u63a5\u8f6c\u79fb\uff0c\u53ef\u4ee5\u52a0\u901f\u3002\n\n---\n\n#### \u6ce8\u610f\u51e0\u70b9\n\n1. \u4e3a\u4e86\u5b89\u5168\uff0c\u907f\u514d\u51fa\u73b0 `0`\uff0c\u5efa\u8bae\u5c06\u6240\u6709\u70b9\u7684\u7f16\u53f7\u7edf\u4e00 `+1`\u3002\n\n1. \u521d\u59cb\u7f16\u53f7\u4e3a `0` \u7684\u8f6f\u4ef6\u5df2\u5b89\u88c5\uff0c\u8bb0\u5f97\u521d\u59cb\u5316\u4e3a `1`\u3002\n\n1. \u7ebf\u6bb5\u6811\u7684 `tag` \u5728 `build()` \u548c `change()` \u51fd\u6570\u4e2d\u90fd\u9700\u8981\u5411\u4e0a\u4f20\u9012\uff0c\u56e0\u4e3a\u5b50\u8282\u70b9\u7684\u72b6\u6001\u5df2\u7ecf\u53d8\u5316\u4e86\u3002\n\n1. \u8f93\u5165\u5b57\u7b26\u7684\u65f6\u5019\u4e00\u5b9a\u8981\u7559\u610f\uff0c\u9632\u6b62\u8bfb\u5165\u7a7a\u767d\u5b57\u7b26\u3002\n\n---\n\n**`Code`**\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#define maxn 100005\n#define ls (p<<1)\n#define rs (p<<1|1)\nusing namespace std;\n\nint n,q,a[maxn];\nint fa[maxn],dfn[maxn],top[maxn];\nint son[maxn],size[maxn],deep[maxn];\nint dfs_cnt;\n\nstruct edge\n{\n\tint v,next;\n}e[maxn<<1|1];\n\nint head[maxn],k;\n\ninline void add(int u,int v)\n{\n\te[k]=(edge){v,head[u]};\n\thead[u]=k++;\n}\n\nvoid dfs1(int u)\n{\n\tdeep[u]=deep[fa[u]]+1;\n\tson[u]=-1;\n\tsize[u]=1;\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tdfs1(e[i].v);\n\t\tsize[u]+=size[e[i].v];\n\t\tif(son[u]==-1||size[son[u]]<size[e[i].v]) son[u]=e[i].v;\n\t}\n}\n\nvoid dfs2(int u,int t)\n{\n\ttop[u]=t;\n\tdfn[u]=++dfs_cnt;\n\tif(son[u]==-1) return;\n\tdfs2(son[u],t);\n\tfor(int i=head[u];~i;i=e[i].next)\n\t\tif(e[i].v!=son[u])\n\t\t\tdfs2(e[i].v,e[i].v);\n}\n\nstruct node\n{\n\tint l,r,tag,lazy;//tag\u4e3a\u6b64\u533a\u95f4\u7684\u72b6\u6001\uff0c\u5982\u72b6\u6001\u4e0d\u4e00\u5219\u4e3a-1\n}tree[maxn<<2|1];\n\nvoid build(int p,int l,int r)\n{\n\ttree[p].l=l;tree[p].r=r;\n\tif(l==r)\n\t{\n\t\ttree[p].tag= (l==1)?1:0;//\u662f\u5426\u5df2\u5b89\u88c5\n\t\ttree[p].lazy=-1;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(ls,l,mid);\n\tbuild(rs,mid+1,r);\n\tif(tree[ls].tag!=tree[rs].tag||tree[ls].tag==-1) tree[p].tag=-1;\n\telse tree[p].tag=tree[ls].tag;//tag\u66f4\u65b0\n}\n\ninline void push_down(int p)\n{\n\tif(tree[p].lazy==-1) return;\n\ttree[ls].tag=tree[ls].lazy=tree[rs].tag=tree[rs].lazy=tree[p].lazy;\n\ttree[p].lazy=-1;\n}\n\nvoid change(int p,int l,int r,int d)\n{\n\tif(l<=tree[p].l&&r>=tree[p].r)\n\t{\n\t\ttree[p].tag=d;\n\t\ttree[p].lazy=d;\n\t\treturn;\n\t}\n\tpush_down(p);\n\tint mid=(tree[p].l+tree[p].r)>>1;\n\tif(l<=mid) change(ls,l,r,d);\n\tif(r>mid) change(rs,l,r,d);\n\tif(tree[ls].tag!=tree[rs].tag||tree[ls].tag==-1) tree[p].tag=-1;\n\telse tree[p].tag=tree[ls].tag;//tag\u66f4\u65b0\n}\n\nint query(int p,int l,int r,int aim)\n{\n\tif(tree[p].tag!=-1&&l<=tree[p].l&&r>=tree[p].r)\n\t\treturn tree[p].tag==aim?(tree[p].r-tree[p].l+1):0;\n\tpush_down(p);\n\tint mid=(tree[p].l+tree[p].r)>>1,ans=0;\n\tif(l<=mid) ans+=query(ls,l,r,aim);\n\tif(r>mid) ans+=query(rs,l,r,aim);\n\treturn ans;\n}\n\ninline int querypath(int x)\n{\n\tint ans=0;\n\twhile(top[x]!=1)\n\t{\n\t\tans+=query(1,dfn[top[x]],dfn[x],0);\n\t\tchange(1,dfn[top[x]],dfn[x],1);\n\t\tx=fa[top[x]];\n\t}\n\tans+=query(1,dfn[top[x]],dfn[x],0);\n\tchange(1,dfn[top[x]],dfn[x],1);\n\treturn ans;\n}\n\ninline int querytree(int x)\n{\n\tint ans=query(1,dfn[x],dfn[x]+size[x]-1,1);\n\tchange(1,dfn[x],dfn[x]+size[x]-1,0);\n\treturn ans;\n}\n\nint main()\n{\n\tfreopen(\"P2146.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tmemset(head,-1,sizeof(head));\n\ta[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&fa[i]);\n\t\tfa[i]++;\n\t\tadd(fa[i],i);\n\t}\n\tdfs1(1);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&q);\n\tchar opt[20];int x;\n\twhile(q--)\n\t{\n\t\tscanf(\"\\n%s%d\",opt,&x);\n\t\tx++;\n\t\tif(opt[0]=='i') printf(\"%d\\n\",querypath(x));\n\t\telse printf(\"%d\\n\",querytree(x));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1581867746,
        "uid": 224236,
        "name": "GoPoux4",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u6811\u5256\u6c34\u9898\u3002\u3002\u3002\n\n\u76f8\u4fe1\u5927\u5bb6\u90fd\u4f1a\u6811\u5256\u5427\uff0c\u5982\u679c\u4e0d\u4f1a\u7684\u8bdd\u5c31\u6b63\u597d\u542c\u6211\u8bb2\u4e00\u4e0b\u3002\n\n\u4f17\u6240\u5468\u77e5\u6709\u4e2a\u53eb\u505adfs\u5e8f\u7684\u4e1c\u897f\uff0c\u5c31\u662fdfs\u904d\u5386\u8fd9\u68f5\u6811\u7684\u987a\u5e8f\u3002\u4ed6\u6709\u4e2a\u663e\u7136\u7684\u6027\u8d28\u662f\u4e00\u6bb5\u5b50\u6811\u5728dfs\u5e8f\u4e0a\u662f\u8fde\u7eed\u7684\u3002\n\n\u4ee5u\u4e3a\u6839\u7684\u5b50\u6811\u5e26dfs\u5e8f\u4e0a\u5bf9\u5e94\u7684\u533a\u95f4\u4e3a\uff1a\n\n$$[pos_u,pos_u+siz_u-1]$$\n\n\u5176\u4e2d$pos_u$\u4ee3\u8868u\u5728dfs\u5e8f\u4e2d\u7684\u4f4d\u7f6e\uff0c$siz_u$\u4ee3\u8868\u4ee5u\u4e3a\u6839\u5b50\u6811\u7684\u5927\u5c0f\u3002\n\n\u76f8\u4fe1\u8fd9\u4e2a\u4e1c\u897f\u5e94\u8be5\u662f\u5f88\u597d\u7406\u89e3\u7684\u3002\n\n\u5982\u679c\u53ea\u6709\u5b50\u6811\u7684\u4fee\u6539\u53ef\u4ee5\u76f4\u63a5\u628a\u6811\u4e0a\u95ee\u9898\u8f6c\u5316\u6210dfs\u5e8f\u4e0a\u7684\u5e8f\u5217\u95ee\u9898\u641e\u3002\u4f46\u662f\u8fd9\u9898\u6709\u5230\u6839\u4fee\u6539\u7684\u64cd\u4f5c\u3002\n\n\u6734\u7d20\u7684\u66b4\u529b\u662f\u66b4\u529b\u6539\u6bcf\u4e2a\u70b9\u3002\u90a3\u4e48\u80fd\u4e0d\u80fd\u60f3\u4e2a\u529e\u6cd5\u628a\u8fd9\u4e9b\u533a\u95f4\u62c6\u5206\u6210log\u6761\u533a\u95f4\u518d\u6539\u5462\uff1f\n\n\u6211\u4eec\u6210\u6bcf\u4e2a\u70b9\u5b50\u6811\u6700\u5927\u7684\u5b50\u8282\u70b9\u4e3a\u4ed6\u7684\u91cd\u513f\u5b50\uff0c\u91cd\u513f\u5b50\u8fde\u5411\u5b83\u7684\u90a3\u6761\u8fb9\u4e3a\u91cd\u94fe\u3002dfs\u7684\u65f6\u5019\u5982\u679c\u4f18\u5148dfs\u91cd\u513f\u5b50\u5c31\u4f1a\u4f7f\u91cd\u94fe\u4e0a\u7684\u70b9\u3002\n\n\u663e\u7136\u4e00\u6761\u5b8c\u6574\u91cd\u94fe\u4e0a\u7684\u70b9\u662f\u5728\u8fd9\u6837dfs\u5e8f\u4e0a\u8fde\u7eed\u7684\u3002\n\n\u6211\u4eec\u628a\u8be2\u95ee/\u4fee\u6539\u7684\u94fe\u62c6\u6210\u5f88\u591a\u6761\u91cd\u94fe\uff0c\u518d\u4f5c\u533a\u95f4\u4fee\u6539\uff0c\u5c31\u597d\u4e86\u3002\n\n\u590d\u6742\u5ea6$\\Theta(n\\log^2n)$\n\n\u8fd9\u9053\u9898\u8bbe\u8f6f\u4ef6\u5305\u5b89\u88c5\u4e3a1\uff0c\u5378\u8f7d\u4e3a0\n\n\u663e\u7136\u4fee\u6539\u64cd\u4f5c\u662f\u628a\u5b50\u6811\u5168\u90e8\u8d4b\u503c\u62100\u6216\u628a\u5230\u6839\u8def\u5f84\u4e0a\u5f97\u70b9\u8d4b\u503c\u62101\n\n\u8fd9\u6837\u6620\u5c04\u5230dfs\u5e8f\u4e0a\u5c31\u662f\u533a\u95f4\u63a8\u5e73\u95ee\u9898\u3002\n\n\u4e8e\u662f\u7528\u6811\u5256\u6c34\u5c31\u597d\u4e86\u3002\u7531\u4e8e\u64cd\u4f5c\u662f\u533a\u95f4\u63a8\u5e73\uff0c\u6211\u5c31\u5077\u61d2\u628a\u7ef4\u62a4\u7684\u6570\u636e\u7ed3\u6784\u6539\u6210\u73c2\u6735\u8389\u6811\uff0c\u53cd\u6b63\u6811\u5256\u91cd\u70b9\u4e5f\u4e0d\u5728\u8fd9\u513f~~\u4e0d\u8fc7\u5c31\u53ea\u80fd\u5438\u6c27\u624d\u80fdA~~\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\ninline int readi() {\n    int s = 0, f = 1;\n    char ch = getchar();\n    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }\n    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch & 15), ch = getchar();\n    return s * f;\n}\n\ninline int abs_(int n) {\n\treturn n < 0 ? -n : n;\n}\n\nstruct NNode {\n    int fa, zson, dep, top, siz, pos;\n    vector<int> nxt;\n    NNode() { fa = 0; zson = 0; dep = 0; top = 0; siz = 1; }\n}nd[500005];\n\nstatic int tp = 1;\n\ninline void dfs1(int now, int fa) {\n    nd[now].fa = fa; nd[now].dep = nd[fa].dep + 1;\n    int mx = 0, s = 0;\n    for (vector<int> :: iterator it = nd[now].nxt.begin(); it != nd[now].nxt.end(); ++it) {\n        if ((*it) == fa) continue;\n        dfs1((*it), now);\n        nd[now].siz += nd[(*it)].siz;\n        if (mx < nd[(*it)].siz) { mx = nd[(*it)].siz; s = (*it); }\n    } nd[now].zson = s;\n}\n\ninline void dfs2(int now, int fa, int top) {\n    nd[now].pos = tp; ++tp; nd[now].top = top;\n    if (nd[now].zson != 0) dfs2(nd[now].zson, now, top);\n    for (vector<int> :: iterator it = nd[now].nxt.begin(); it != nd[now].nxt.end(); ++it) {\n        if ((*it) == fa) continue;\n        if ((*it) == nd[now].zson) continue;\n        dfs2((*it), now, (*it));\n    }\n}\n\n#define IT set<node>::iterator\n\nstruct node {\n    int l, r;\n    mutable int val;\n    node(int L, int R = -1, int V = 0) : l(L), r(R), val(V) {}\n    inline bool operator < (const node& a) const {\n        return l < a.l;\n    }\n};\n\nset<node> st;\n\ninline IT split(int now) {\n    IT it = st.lower_bound(node(now));\n    if (it != st.end() && it -> l == now) return it;\n    --it;\n    int l = it -> l, r = it -> r, val = it -> val;\n    st.erase(it);\n    st.insert(node(l, now - 1, val));\n    return st.insert(node(now, r, val)).first;\n}\n\ninline int assign(int l, int r, int val) {\n    IT itr = split(r + 1), itl = split(l);\n    int pre = 0, nw = val * (r - l + 1);\n    for (IT it = split(l); it != split(r + 1); ++it) pre += (it -> r - it -> l + 1) * it -> val;\n    st.erase(itl, itr);\n    st.insert(node(l, r, val));\n    return abs_(nw - pre);\n}\n\ninline int get(int l) {\n    return split(l) -> val;\n}\n\nint n, u, v, q, x;\nstring opt;\n\nint main() {\n    n = readi();\n    for (int i = 1; i < n; ++i) {\n        u = readi();\n        nd[u + 1].nxt.push_back(i + 1);\n    \tnd[i + 1].nxt.push_back(u + 1);\n    } dfs1(1, 0); dfs2(1, 0, 1);\n    q = readi(); st.insert(node(1, n, 0));\n    while (q--) {\n        cin >> opt >> x; ++x;\n        if (opt == \"uninstall\") printf(\"%d\\n\", assign(nd[x].pos, nd[x].pos + nd[x].siz - 1, 0));\n        else if (opt == \"install\") {\n        \tint sm = 0;\n            while (x != 0) {\n                sm += assign(nd[nd[x].top].pos, nd[x].pos, 1);\n                x = nd[nd[x].top].fa;\n            } printf(\"%d\\n\", sm);\n\t\t}\n    } return 0;\n}\n```\n",
        "postTime": 1576242963,
        "uid": 98096,
        "name": "Smallbasic",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "$\\text{\u611f\u8c22 @\u72f8\u72f8\u517b\u7684\u654f\u654f \u9762\u5bf9\u9762\u6559\u6211ODT \u5e2e\u4ed6\u5ba3\u4f20\u4e00\u6ce2\uff08\u5212\u6389\uff09}$\n\n[$\\text{here}$](https://www.luogu.org/blog/Letusaccepted/odt-ke-duo-li-shu-xue-xi-bi-ji)\n\n$\\text{\u5982\u679c\u4f60\u4e0d\u4f1a\u6811\u94fe\u5256\u5206 \u8bf7\u53bb\u6a21\u677f\u9898\u3002}$\n\n$\\text{ODT , Old Driver Tree \uff0c \u5c31\u662f\u4e00\u79cd\u6570\u636e\u7ed3\u6784 \u4f60\u4fee\u6539\u8d8a\u591a \u8fd9\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u8d8a\u4f4e\u3002}$\n\n$\\text{\u64cd\u4f5c\u5927\u6982\u662f\u8fd9\u4e2a\u6837\u5b50\u7684 \uff1a \u7528set \u7ef4\u62a4 n \u4e2a\u5757(n\u6307\u7684\u662f\u5e8f\u5217\u957f\u5ea6)}$\n\n~~~\nstruct node {\n\tint l ; int r ;\n\tmutable int val ;\n\tbool operator < (const node & x) const {\n\t\treturn l < x.l ;\n\t}\n};\nset < node > s ;\n\n#define slt set < node > :: iterator\n...\nn = read() ;\ns.insert({1 , n + 1 , 0}) ;\n\n~~~\n\n\n$\\text{\u53cd\u6b63\u4e0d\u7ba1 \u4f60\u533a\u95f4\u4fee\u6539\u7684\u65f6\u5019\u5c31\u628a\u5757\u5408\u5e76\u8d77\u6765\u3002\u3002}$\n\n$\\text{\u6240\u4ee5\u6309\u7167\u8fd9\u4e2a\u601d\u8def \u6211\u4eec\u53ef\u4ee5\u5148\u5efa\u4e00\u4e2a\u5927\u5757\u3002\u3002\u56e0\u4e3a\u521d\u59cb\u662f1-n \u90fd\u662f0}$\n\n$\\text{\u7136\u540e\u4f60\u5728\u4fee\u6539\u4e4b\u524d\u67e5\u8be2\u4e00\u4e0b\u533a\u95f4\u7684\u503c\u3002\u3002\u4fee\u6539\u4e4b\u540e\u5c31\u662f (r - l + 1) * val}$\n$\\text{\u8fd4\u56de\u7edd\u5bf9\u503c\u5373\u53ef\u3002\u3002}$\n\n\n$\\mathcal{Code}$\n\n```cpp\n//Isaunoya\n#include<bits/stdc++.h>\nusing namespace std ;\ninline int read() { register int x = 0 ; register int f = 1 ; register char c = getchar() ;\n\tfor( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;\n\tfor( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;\n\treturn x * f ;\n} int st[105] ;\ntemplate < typename T > inline void write(T x , char c = '\\n') { int tp = 0 ;\n\tif(x == 0) return (void) puts(\"0\") ;\n\tif(x < 0) putchar('-') , x = -x ;\n\tfor( ; x ; x /= 10) st[++ tp] = x % 10 ;\n\tfor( ; tp ; tp --) putchar(st[tp] + '0') ;\n\tputchar(c) ;\n}\n//#define Online_Judge\n\nstruct node {\n\tint l ; int r ;\n\tmutable int val ;\n\tbool operator < (const node & x) const {\n\t\treturn l < x.l ;\n\t}\n};\nset < node > s ;\n\n#define slt set < node > :: iterator\ninline slt Split(int pos) {\n\tslt it = s.lower_bound((node) {pos}) ;\n\tif(it != s.end() && it -> l == pos) return it ;\n\t-- it ;\n\tint l = it -> l ;\n\tint r = it -> r ;\n\tint val = it -> val ;\n\ts.erase(it) ;\n\ts.insert({l , pos - 1 , val}) ;\n\treturn s.insert({pos , r , val}).first ;\n}\ninline int Assign(int l , int r , int val) {\n\tslt it2 = Split(r + 1) ;\n\tslt it1 = Split(l) ;\n\tint sum = 0 ;\n\tint sum2 = (r - l + 1) * val  ;\n\tfor(slt it = it1 ; it != it2 ; it ++) sum += (it -> r - it -> l + 1) * it -> val ;\n\ts.erase(it1 , it2) ;\n\ts.insert({l , r , val}) ;\n\treturn abs(sum - sum2) ;\n}\nint n ;\nstruct Node {\n\tint v ;\n\tint nxt ;\n};\nconst int N = 1e5 + 10 ;\nNode e[N << 1] ;\nint cnt = 0 ;\nint head[N] ;\ninline void Add(int u , int v) {\n\te[++ cnt].v = v ;\n\te[cnt].nxt = head[u] ;\n\thead[u] = cnt ;\n\treturn ;\n}\nint top[N] ;\nint id[N] ; int size[N] ;\nint d[N] ; int idx = 0 ;\nint fa[N] ; int son[N] ;\ninline void Dfs1(int u) {\n\tsize[u] = 1 ;\n\tfor(register int i = head[u] ; i ; i = e[i].nxt ) {\n\t\tint v = e[i].v ;\n\t\tif(v == fa[u]) continue ;\n\t\td[v] = d[u] + 1 ;\n\t\tfa[v] = u ;\n\t\tDfs1(v) ;\n\t\tsize[u] += size[v] ;\n\t\tif(size[v] > size[son[u]]) son[u] = v ;\n\t}\n\treturn ;\n}\ninline void Dfs2(int u , int t) {\n\tid[u] = ++ idx ;\n\ttop[u] = t ;\n\tif(! son[u]) return ;\n\tDfs2(son[u] , t) ;\n\tfor(register int i = head[u] ; i ; i = e[i].nxt) {\n\t\tint v = e[i].v ;\n\t\tif((v ^ fa[u]) && (v ^ son[u])) Dfs2(v , v) ;\n\t}\n}\ninline int getopt() { string s = \"\" ;\n\tregister char c = getchar() ;\n\twhile(isspace(c)) c = getchar() ;\n\twhile(! isspace(c)) {\n\t\ts += c ;\n\t\tc = getchar() ;\n\t}\n\tif(s == \"install\") return 1 ;\n\tif(s == \"uninstall\") return 0 ;\n}\ninline int Change_Range(int x , int y) {\n\tint fx = top[x] ;\n\tint fy = top[y] ;\n\tint ans = 0 ;\n\twhile(fx ^ fy) {\n\t\tif(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n\t\tans += Assign(id[fx] , id[x] , 1) ;\n\t\tx = fa[fx] ;\n\t\tfx = top[x] ;\n\t}\n\tif(id[x] > id[y]) swap(x , y) ;\n\tans += Assign(id[x] , id[y] , 1) ;\n\treturn ans ;\n}\ninline int Uninstall(int x) {\n\treturn Assign(id[x] , id[x] + size[x] - 1 , 0) ;\n}\nsigned main() {\n#ifdef Online_Judge\n\tfreopen(\"testdata.in\" , \"r\" , stdin) ;\n\tfreopen(\"testdata2.out\" , \"w\" , stdout) ;\n#endif\n\tn = read() ;\n\ts.insert({1 , n + 1 , 0}) ;\n\tfor(register int i = 2 ; i <= n ; i ++) {\n\t\tint u = read() ; u ++ ;\n\t\tAdd(u , i) ;\n\t\tAdd(i , u) ;\n\t}\n\tDfs1(1) ;\n\tDfs2(1 , 1) ;\n\tfor(register int t = read() ; t -- ; ) {\n\t\tint opt = getopt() ;\n\t\tif(opt == 1) {\n\t\t\tint x = read() ; x ++ ;\n\t\t\twrite(Change_Range(x , 1)) ;\n\t\t}\n\t\tif(opt == 0) {\n\t\t\tint x = read() ; x ++ ;\n\t\t\twrite(Uninstall(x)) ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n\n```",
        "postTime": 1567672449,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u5c31\u662f\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\uff0c\u8be6\u7ec6\u89e3\u91ca\u89c1\u7a0b\u5e8f\u3002\n\n\u5b66\u5b8c\u6811\u7684dfs\u5e8f\uff0clca\uff0c\u7ebf\u6bb5\u6811\u98df\u7528\u66f4\u4f73\u3002\n\n~~\u4e0d\u4f1a\u8fd9\u4e9b\u5b66\u4ec0\u4e48\u6811\u5256\uff08\u9003~~~\n```cpp\n#include <bits/stdc++.h> //\u4e07\u80fd\u5934\u6587\u4ef6\nusing namespace std;\nint n,q,tot;\nint fa[100005],size[100005],dep[100005],son[100005];\nint lo[100005],top[100005];\nint sum[800005],tag[800005];\t\nvector <int> allson[100005];\n//\u7ebf\u6bb5\u6811\nvoid pushup(int x)//\u66f4\u65b0\n{\n\tsum[x]=sum[x<<1]+sum[(x<<1)+1];\n}\nvoid pushdown(int x,int l,int r)//\u6e05\u9664\u61d2\u6807\u8bb0\n{\n\tif(tag[x]!=-1)\n\t{\n\t\tint m=(l+r)>>1;\n\t\tint ls=x<<1;\n\t\tint rs=ls+1;\n\t\ttag[ls]=tag[rs]=tag[x];\n\t\tsum[ls]=(m-l+1)*tag[x];\n\t\tsum[rs]=(r-m)*tag[x];\n\t\ttag[x]=-1; \n\t}\n}\nvoid update(int x,int l,int r,int L,int R,int v)//\u4fee\u6539\n{\n\tif(R<l||r<L)\n\t\treturn;\n\tif(L<=l&&r<=R)\n\t{\n\t\tsum[x]=(r-l+1)*v;\n\t\ttag[x]=v;\n\t\treturn;\n\t}\n\tpushdown(x,l,r);\n\tint m=(l+r)>>1;\n\tupdate(x<<1,l,m,L,R,v);\n\tupdate((x<<1)+1,m+1,r,L,R,v);\n\tpushup(x);\n}\n//\u6811\u94fe\u5256\u5206\nvoid change(int x,int y,int v)//\u7c7b\u4f3clca\n{\n\tint fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])\n\t\t\tswap(x,y),swap(fx,fy);\n        update(1,1,tot,lo[fx],lo[x],v);\n        x=fa[fx],fx=top[x];\n    }\n    if(lo[x]>lo[y])\n\t\tswap(x,y);\n    update(1,1,tot,lo[x],lo[y],v);\n}\nvoid dfs1(int x)\n{\n\tsize[x]=1;\n\tfor(int i=0;i<allson[x].size();++i)\n\t{\n\t\tint v=allson[x][i];\n\t\tdep[v]=dep[x]+1;//\u6df1\u5ea6\n\t\tdfs1(v);\n\t\tsize[x]+=size[v];//\u5b50\u6811\u5927\u5c0f\n\t\tif(size[v]>size[son[x]])\n\t\t\tson[x]=v;//\u91cd\u513f\u5b50\n\t}\n}\nvoid dfs2(int x,int t)\n{\n\tlo[x]=++tot;\t\n\ttop[x]=t;//\u91cd\u94fe\u7236\u4eb2\n\tif(son[x])\n\t\tdfs2(son[x],t);\n\tfor(int i=0;i<allson[x].size();++i)\n\t{\n\t\tint v=allson[x][i];\n\t\tif(v!=son[x])\n\t\t\tdfs2(v,v);\n\t}\n} \nint main()\n{\n\tmemset(tag,-1,sizeof(tag)); //lazy_tag\u4e3a-1\u8868\u793a\u6ca1\u6709\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfa[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tfa[i]=x+1;\n\t\tallson[x+1].push_back(i);\n\t}\n    //\u9884\u5904\u7406\n\tdfs1(1);\n\tdfs2(1,1);\n\tcin>>q;\n\twhile(q--)\n\t{\n\t\tstring s;\n\t\tint x;\n\t\tcin>>s>>x;\n\t\tx++;\n\t\tint before=sum[1];//\u6539\u4e4b\u524d\n\t\tif(s==\"install\")\n\t\t{\n\t\t\tchange(1,x,1);//1\u5230x\u8def\u4e0a\u5168\u6539\u62101\n\t\t\tint after=sum[1];//\u6539\u540e\n\t\t\tcout<<fabs(before-after)<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(1,1,n,lo[x],lo[x]+size[x]-1,0);//\u628ax\u7684\u5b50\u6811\u6539\u62100\n\t\t\tint after=sum[1];//\u6539\u540e\n\t\t\tcout<<fabs(before-after)<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1533094047,
        "uid": 37881,
        "name": "yzhang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u8bf7\u79fb\u6b65[\u6211\u7684blog](https://www.cnblogs.com/bztMinamoto/p/9328728.html)\n\n\u55ef\u2026\u2026\u6811\u94fe\u5256\u5206\u7684\u9898\u76ee\u2026\u2026\n\n\u6709\u70b9\u61f5\u903c\u2026\u2026\u770b\u4e86\u770b\u5927\u4f6c\u4eec\u7684\u9898\u89e3\u624d\u77e5\u9053\u6811\u5256\u8fd8\u6709\u8fd9\u4e48\u591a\u8bb2\u7a76\u2026\u2026\n\n\u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6240\u6709\u7684\u8f6f\u4ef6\u770b\u4f5c\u4e00\u68f5\u6811\uff0c\u521d\u59cb\u65f6\u90fd\u662f-1\n\n\u5bf9\u4e8e\u5b89\u88c5\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u5c06\u5b83\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u5168\u90fd\u53d8\u4e3a1\n\n\u5bf9\u4e8e\u5378\u8f7d\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u5c06\u5b83\u7684\u5b50\u6811\u5168\u90fd\u53d8\u4e3a0\n\n\u7136\u540e\u53ea\u8981\u8f93\u51fa\u6bcf\u6b21\u64cd\u4f5c\u524d\u540e\u6574\u68f5\u6811\u6743\u503c\u7684\u53d8\u5316\u91cf\u5373\u53ef\n\n\u5378\u8f7d\u64cd\u4f5c\u7684\u8bdd\u2026\u2026\u76f4\u63a5\u5728dfs\u5e8f\u540e\u7684\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u8986\u76d6\n\n\u5b89\u88c5\u64cd\u4f5c\u7684\u8bdd\u2026\u2026\u5728\u6811\u5256\u6811\u4e0a\u5411\u4e0a\u8d70\uff0c\u7136\u540e\u4e0d\u65ad\u66f4\u65b0\u8def\u5f84\u5373\u53ef\n\n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int N=200005;\nstruct SegmentTree{\n    int l,r;\n    LL sum,add;\n    #define l(x) tree[x].l\n    #define r(x) tree[x].r\n    #define sum(x) tree[x].sum\n    #define add(x) tree[x].add\n} tree[N*4];\nint n,m,a[N],top_,num;\nint size[N],son[N],fa[N],dep[N],top[N],cnt[N],rnk[N];\nint ver[N*2],Next[N*2],head[N];char s[20];\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    for (; !isdigit(ch); ch=getchar()) if(ch=='-') f=-1;\n    for (; isdigit(ch); ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\nvoid add_(int x,int y){\n    ver[++top_]=y,Next[top_]=head[x],head[x]=top_;\n}\nvoid dfs(int x){\n    size[x]=1,dep[x]=dep[fa[x]]+1;\n    for(int i=head[x];i;i=Next[i]){\n        int y=ver[i];\n        if(y!=fa[x]){\n            fa[y]=x;\n            dfs(y);\n            size[x]+=size[y];\n            if(!son[x]||size[y]>size[son[x]]){\n                son[x]=y;\n            }\n        }\n    }\n}\nvoid dfs_(int x){\n    if(!top[x]) top[x]=x;\n    cnt[x]=++num,rnk[num]=x;\n    if(son[x]) top[son[x]]=top[x],dfs_(son[x]);\n    for(int i=head[x];i;i=Next[i]){\n        int y=ver[i];\n        if(y!=fa[x]&&y!=son[x]){\n            dfs_(y);\n        }\n    }\n}\nvoid build(int p,int l,int r)\n{\n    l(p)=l,r(p)=r;\n    if(l==r) {sum(p)=0,add(p)=-1;return;}\n    int mid=(l+r)>>1;\n    build(p<<1,l,mid);\n    build((p<<1)|1,mid+1,r);\n}\nvoid spread(int p)\n{\n    if(~add(p))\n    {\n        int lc=p<<1,rc=(p<<1)+1;\n        sum(lc)=add(p)*(r(lc)-l(lc)+1),sum(lc);\n        sum(rc)=add(p)*(r(rc)-l(rc)+1),sum(rc);\n        add(lc)=add(p);\n        add(rc)=add(p);\n        add(p)=-1;\n    }\n}\nvoid update(int p,int l,int r,int d)\n{\n    if(l<=l(p)&&r>=r(p))\n    {\n        sum(p)=1ll*d*(r(p)-l(p)+1);\n        add(p)=d;\n        return;\n    }\n    spread(p);\n    int mid=(l(p)+r(p))>>1;\n    if(l<=mid) update(p<<1,l,r,d);\n    if(r>mid) update((p<<1)+1,l,r,d);\n    sum(p)=sum(p<<1)+sum((p<<1)+1);\n}\nvoid change(int u,int v,int val){\n    while(top[u]!=top[v]){\n        if(dep[top[u]]<dep[top[v]]) swap(u,v);\n        update(1,cnt[top[u]],cnt[u],val);\n        u=fa[top[u]];\n    }\n    if(dep[u]>dep[v]) swap(u,v);\n    update(1,cnt[u],cnt[v],val);\n    return;\n}\nint main()\n{\n    //freopen(\"testdata.in\",\"r\",stdin);\n    n=read();\n    for(int i=2;i<=n;++i){\n        int x=read();++x;\n        add_(x,i);\n    }\n    m=read();\n    dfs(1),dfs_(1);build(1,1,n);\n    while(m--){\n        scanf(\"%s\",s);\n        int x=read();++x;\n        int t1=sum(1);\n        if(s[0]=='i'){\n            change(1,x,1);\n            int t2=sum(1);\n            printf(\"%d\\n\",abs(t1-t2));\n        }\n        else{\n            update(1,cnt[x],cnt[x]+size[x]-1,0);\n            int t2=sum(1);\n            printf(\"%d\\n\",abs(t1-t2));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1531892729,
        "uid": 41781,
        "name": "bztMinamoto",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u534a\u5c0f\u65f6\u6253\u4e2a\u6811\u5256,\u7136\u540e\u5148\u6302\u6389\u4e86.  \n\u53d1\u73b0\u7ebf\u6bb5\u6811\u4fee\u6539\u7684\u65f6\u5019\u5f53\u505a\u533a\u95f4\u8986\u76d6\u4e86.  \n\u7136\u540e\u6539\u5bf9\u4e86,T\u4e86.\n\u6211\u7a81\u7136\u60f3\u8d77\u6765\u4ec0\u4e48.\n```\n/*\n\u672c\u9898\u4e2d\u7684\u6839\u8282\u70b9\u662f0,\u6211\u5728\u5904\u7406son\u6570\u7ec4\u7684\u65f6\u5019\u5c06\u5b83\u7684\u521d\u503c\u8d4b\u4e3a0,\u63a5\u4e0b\u6765\u5c31\u70b8\u4e86.\n\u9898\u76ee\u975e\u5e38\u590d\u6742,\u4f46\u5176\u5b9e\u5c31\u662f\u4fee\u6539\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6216\u8005\u5b50\u6811,\u5e76\u4e14\u8be2\u95ee.\n\u8fd9\u6837\u7ebf\u6bb5\u6811\u5904\u7406\u533a\u95f4\u8986\u76d6\u548c\u533a\u95f4\u548c\u5c31\u53ef\u4ee5\u4e86.\n\u5f53\u7136\u5904\u7406\u7684\u65f6\u5019\u628a\u6240\u6709\u70b9\u7f16\u53f7+1\u4e5f\u662f\u53ef\u4ee5\u7684.\n\u6811\u94fe\u5256\u5206\u88f8\u9898\u5e94\u8be5\u4e0d\u7528\u591a\u8bb2\u4e86.\n*/\n#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  re0 x=0,f=1;rec c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  return f?x:-x;\n  }\ninline void read(rel &x){\n  x=0;re0 f=1;rec c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=(x<<3)+(x<<1)+(c^'0');\n  x=f?x:-x;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x){\n  if (!x) return pc(48);\n  if (x<0) x=-x,pc('-');\n  re0 bit[20],i,p=0;\n  for (;x;x/=10) bit[++p]=x%10;\n  for (i=p;i;--i) pc(bit[i]+48);\n  }\ninline char fuhao(){\n  rec c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=1e5;\ntypedef int fuko[yuzu|10];\nvector<int> lj[yuzu|10];\nint n,q;\n\nnamespace shu_lian_pou_fen{\nfuko sz,dep,fa,son,top,dfn,ord;int cnt;\n\nvoid dfs1(int u){\n  dep[u]=dep[fa[u]]+1,sz[u]=1;\n  for (re0 i=0;i<lj[u].size();++i){\n    int v=lj[u][i];\n    dfs1(v),sz[u]+=sz[v];\n    if (!~son[u]||sz[v]>sz[son[u]]) son[u]=v;  \n    }\n  }\n\nvoid dfs2(int u,int _top){\n  top[u]=_top,dfn[u]=++cnt,ord[cnt]=u;\n  if (~son[u]) dfs2(son[u],_top);\n  for (re0 i=0;i<lj[u].size();++i){\n    int v=lj[u][i];\n    if (v^son[u]) dfs2(v,v);\n    }\n  }\n\ntypedef int karen[yuzu<<2|13];\nstruct segtree{\n#define le rt<<1\n#define ri le|1\n#define ls le,l,mid\n#define rs ri,mid+1,r\nkaren val,lazy;\nvoid build(int rt=1,int l=1,int r=n){\n  lazy[rt]=-1;\n  if (l==r) val[rt]=0;\n  else{\n    int mid=l+r>>1;\n    build(ls),build(rs);\n    val[rt]=0;\n    }\n  }\nvoid push_down(int rt,int l,int r){\n  if (~lazy[rt]){\n    int mid=l+r>>1;\n    lazy[le]=lazy[ri]=lazy[rt];\n    val[le]=(mid-l+1)*lazy[rt];\n    val[ri]=(r-mid)*lazy[rt];\n    lazy[rt]=-1;\n    }\n  }\nvoid update(int ql,int qr,int v,int rt=1,int l=1,int r=n){\n  if (ql>r||qr<l) return;\n  if (ql<=l&&qr>=r){\n    val[rt]=(r-l+1)*v;\n    lazy[rt]=v;\n    }else{\n    int mid=l+r>>1;\n    push_down(rt,l,r);\n    update(ql,qr,v,ls),update(ql,qr,v,rs);\n    val[rt]=val[le]+val[ri];\n\t}\n  }\nint query(int ql,int qr,int rt=1,int l=1,int r=n){\n  if (ql>r||qr<l) return 0;\n  if (ql<=l&&qr>=r) return val[rt];\n  int mid=l+r>>1;\n  push_down(rt,l,r);\n  return query(ql,qr,ls)+query(ql,qr,rs);\n  }\n}my_;\n\n#define all(u) dfn[u],dfn[u]+sz[u]-1\nvoid update(int u,int v,int w){\n  for (;top[u]^top[v];u=fa[top[u]]){\n    if (dep[top[u]]<dep[top[v]]) swap(u,v);\n    my_.update(dfn[top[u]],dfn[u],w);\n    }\n  if (dep[u]>dep[v]) swap(u,v);\n  my_.update(dfn[u],dfn[v],w);\n  }\n/*\n\u8fd9\u91cc\u5176\u5b9e\u6211\u81ea\u5df1\u662f\u8fd9\u4e48\u5199\u7684.\nint query(int u,int v){//\u4e24\u70b9\u95f4\u8be2\u95ee\n  int ans=0;\n  for (;top[u]^top[v];u=fa[top[u]]){\n    if (dep[top[u]]<dep[top[v]]) swap(u,v);\n    ans+=my_.query(dfn[top[u]],dfn[u]);\n    } \n  if (dep[u]>dep[v]) swap(u,v);\n  return ans+my_.query(dfn[u],dfn[v]);\n  }\n\nint install(int u){\n  \u5982\u679c\u4e0b\u9762\u8fd9\u4e2a\u8be2\u95ee\u7ed3\u679c\u4e3a1,\u8868\u793a\u5b83\u5df2\u7ecf\u4e0b\u8f7d\u8fc7\u4e86,\u5c31\u8fd4\u56de0.\n  \u4e0b\u9762\u4e5f\u662f\u4e00\u6837\u7684,\u5220\u9664\u6ca1\u6709\u4e0b\u8f7d\u8fc7\u7684\u8f6f\u4ef6\u4e5f\u8fd4\u56de0.\n  if (my_.query(dfn[u],dfn[u])) return 0;\n  int cnt=query(0,u);//\u5148\u7b97\u51fa\u8fd9\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u503c.\n  update(0,u,1);//\u4fee\u6539\n  return abs(query(0,u)-cnt);//\u73b0\u5728\u51cf\u53bb\u539f\u6765\u5c31\u662f\u7b54\u6848.\n  }\n\u8fd9\u4e2a\u662f\u4e00\u6837\u7684,\u91cd\u65b0\u8be2\u95ee\u5b50\u6811.\nint uninstall(int u){\n  if (!my_.query(dfn[u],dfn[u])) return 0;\n  int cnt=my_.query(all(u));\n  my_.update(all(u),0);\n  return abs(my_.query(all(u))-cnt);\n  }\n\u53ea\u4e0d\u8fc7\u4e0b\u9762\u8fd9\u4e2a\u76f4\u63a5\u7528val[1]\u6765\u8ba1\u7b97\u66f4\u7b80\u6d01.\n*/\nint install(int u){\n  int cnt=my_.val[1];\n  update(0,u,1);\n  return abs(my_.val[1]-cnt);\n  }\n\nint uninstall(int u){\n  int cnt=my_.val[1];\n  my_.update(all(u),0);\n  return abs(my_.val[1]-cnt);\n  }\n\nint main(){\n  re0 i;\n  n=read();\n  memset(son,-1,sizeof son);//\u5982\u679c\u4e0d\u7ed9\u6240\u6709\u70b9\u90fd+1,son\u5fc5\u987b\u8981\u6e05\u4e3a-1.\u8840\u7684\u6559\u8bad.\n  for (i=1;i<n;++i){\n    fa[i]=read();\n    lj[fa[i]].push_back(i);\n    }\n  dfs1(0),dfs2(0,0);\n  my_.build();\n  for (int q=read();q--;){\n    char op=fuhao();\n\tint u=read();\n    if (op=='i'){\n      write(install(u)),pl;\n\t  }\n\telse{\n\t  write(uninstall(u)),pl;\n\t  }\n    }\n  }\n}\n\nint main(){\nshu_lian_pou_fen::main();\n}\n```",
        "postTime": 1524451869,
        "uid": 49371,
        "name": "Fuko_Ibuki",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206+\u533a\u95f4\u8bbe\u7f6e\u7684\u7ebf\u6bb5\u6811\n\n\u4fee\u6539\u7684\u5730\u65b9\u7b80\u5355\u7ef4\u62a4\u5373\u53ef\n",
        "postTime": 1437265888,
        "uid": 8072,
        "name": "immortalCO",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u9898\u89e3\uff1a\u672c\u9898\u4e3b\u8981\u8003\u67e5\u6811\u94fe\u5256\u5206\uff0c\u5199\u4e86\u597d\u4e45\uff01\n- \u7b80\u8981\u9898\u610f\uff1a\u6811\u4e0a\u4e24\u4e2a\u64cd\u4f5c\uff0c\n- 1\uff1a\u67e5\u8be2\u4ece\u8be5\u8282\u70b9\u5230\u6839\u6709\u591a\u5c11\u4e2a\u7ed3\u70b9\u6743\u503c\u4e3a0\uff0c\u5e76\u628a0\u2212x\u4e0a\u7684\u6240\u6709\u8282\u70b9\u90fd\u8d4b\u4e3a1\u3002\n- 2\uff1a\u67e5\u8be2\u8be5\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u603b\u6743\u503c\u548c\uff0c\u5e76\u66f4\u65b0\u5b50\u6811\u5168\u90e8\u4e3a0\u3002\n- 1.\u6811\u94fe\u5256\u5206\uff1a\u5176\u5b9e\u672c\u9898\u4e3b\u8981\u96be\u70b9\u662f\u7406\u89e3\u9898\u610f\uff0c\u600e\u4e48\u628a\u9898\u76ee\u7684\u4fe1\u606f\u8f6c\u5316\u4e3a\u4e0a\u9762\u7684\u9898\u610f\u3002\u5c31\u4f1a\u53d1\u73b0\u5176\u5b9e\u662f\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u6539\u52a8\u4e00\u70b9\uff0c\u7ebf\u6bb5\u6811\u4e3a\u533a\u95f4\u8986\u76d6\uff0c\u5728\u533a\u95f4\u66f4\u65b0\u548c\u61d2\u6807\u8bb0\u4e0a\u8be5\u4e00\u4e0b\u5373\u53ef\u3002\u7801\u91cf\u5927\u7684\u9898\u4e00\u5b9a\u8981\u7ec6\u5fc3\uff01\n- \u8fd9\u91cc\u7684\u603b\u548c\u5c31\u4e3a\uff1aans=abs(\u64cd\u4f5c\u524d\u7684\u603b\u548c-\u64cd\u4f5c\u540e\u7684\u603b\u548c)\u3002\n- \u4ee3\u7801\u5982\u4e0b\uff1a\n```\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct N\n{\n\tint ans,lazy;\n}t[800005];\nstruct E\n{\n\tint start,to;\n}e[800005];\nint siz[200005],d[200005],son[200005],h[200005];\nint top[200005],rk[200005],f[200005],id[200005];\nint n,m,P,num,sum;\nvoid pushup(int p)\n{\n\tt[p].ans=t[p*2].ans+t[p*2+1].ans; \n}\nvoid build(int p,int l,int r)\n{\n\tt[p].lazy=-1;t[p].ans=0;\n\tif(l==r)return ;\n\tint mid=l+r>>1;\n\tbuild(p*2,l,mid);\n\tbuild(p*2+1,mid+1,r);\n\tpushup(p);\n\treturn ;\n}\nvoid lai(int p,int l,int r)\n{\n\tint mid=l+r>>1; //\u8fd9\u91cc\u548c\u6a21\u677f\u6709\u4e9b\u4e0d\u540c\n\tif(t[p].lazy!=-1)\n\t{\n\t\tt[p*2].lazy=t[p*2+1].lazy=t[p].lazy;\n      \n\t\tt[p*2].ans=t[p].lazy*(mid-l+1);\n\t\tt[p*2+1].ans=t[p].lazy*(r-mid);\n\t\tt[p].lazy=-1;\n\t}\n\treturn ;\n}\nvoid change(int p,int l,int r,int x,int y,int z)\n{\n\tif(x>r||y<l)return ;\n\tif(x<=l&&y>=r)\n\t{\n\t\tt[p].ans=z*(r-l+1);//\u8fd9\u91cc\u548c\u6a21\u677f\u6709\u4e9b\u4e0d\u540c\n\t\tt[p].lazy=z;\n\t\treturn ;\n\t}\n\tlai(p,l,r);\n\tint mid=l+r>>1;\n\tif(x<=mid)change(p*2,l,mid,x,y,z);\n\tif(y>mid)change(p*2+1,mid+1,r,x,y,z);\n\tpushup(p);\n\treturn ;\n}\nvoid add(int start,int to)\n{\n\te[++P].to=to;\n\te[P].start=h[start];\n\th[start]=P;\n}\nvoid dfs1(int p,int fa,int deep)\n{\n\td[p]=deep;f[p]=fa;siz[p]=1;\n\tfor(int i=h[p];i;i=e[i].start)\n\t{\n\t\tint k=e[i].to;\n\t\tif(k==fa)continue;\n\t\tdfs1(k,p,deep+1);\n\t\tsiz[p]+=siz[k];\n\t\tif(!son[p]||siz[k]>siz[son[p]])son[p]=k;\n\t}\n}\nvoid dfs2(int p,int tp)\n{\n\tid[p]=++num;rk[num]=p;top[p]=tp;\n\tif(!son[p])return ;\n\tdfs2(son[p],tp);\n\tfor(int i=h[p];i;i=e[i].start)\n\t{\n\t\tint k=e[i].to;\n\t\tif(k!=son[p]&&k!=f[p])\n\t\tdfs2(k,k);\n\t}\n}\nvoid update(int x,int y,int v)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tchange(1,1,n,id[top[x]],id[x],v);\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tchange(1,1,n,id[x],id[y],v);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;x++;\n\t\tadd(x,i);add(i,x);\n\t}\n\tdfs1(1,1,1);dfs2(1,1);\n\tbuild(1,1,n);\n\tcin>>m;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tchar a[129193];int x;\n\t\tcin>>a;cin>>x;x++;\n\t\tsum=t[1].ans;\n\t\tif(a[0]=='i')\n\t\t{\n\t\t\tupdate(1,x,1);\n\t\t\tcout<<t[1].ans-sum<<endl;\n\t\t}\n\t\telse if(a[0]=='u')\n\t\t{\n\t\t\tchange(1,1,n,id[x],id[x]+siz[x]-1,0);\n\t\t\tcout<<sum-t[1].ans<<endl;\n\t\t}\n\t}\n\treturn 0;\n} \n```\n",
        "postTime": 1573120224,
        "uid": 120734,
        "name": "wshl",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# \u771f \u88f8\u6811\u5256\n\u8fd9\u4e2a\u9898\u4f60\u53ea\u9700\u8981\u7ef4\u62a4\u4e24\u4e2a\u4e1c\u897f\uff1a\n\n$\\alpha$:$install$\n\n\u4fee\u6539\u8be5\u8f6f\u4ef6\u52300\u53f7\u8f6f\u4ef6\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u4e3a1\uff0c\u65e0\u8111\u533a\u95f4\u4fee\u6539\u5c31\u662f\u4e86\uff1b\n\n$\\beta$:$uninstall$\n\n\u4fee\u6539\u8be5\u8f6f\u4ef6\u5b50\u6811\u4e0a\u7684\u6240\u6709\u70b9\u4e3a0\uff0c\u4e5f\u662f\u65e0\u8111\u7684\u533a\u95f4\u4fee\u6539\u3002\n\n$\\gamma$:$query$\n\n\u5176\u4ed6\u9898\u89e3\u8bb2\u7684\u5f88\u6e05\u695a\u4e86\uff0c\u5c31\u662f\u6c42\u4fee\u6539\u524d\u540e\u7684\u5dee\u7684\u7edd\u5bf9\u503c\uff0c\u6211\u5728\u8fd9\u91cc\u5c06\u5176\u8f6c\u6362\u4e3a\u4e86$deep-ans$\uff0c\u56e0\u4e3a\u6211\u628a\u4fee\u6539\u548c\u67e5\u8be2\u5408\u5728\u4e86\u4e00\u4e2a\u51fd\u6570\u91cc\uff0c\u4fee\u6539\u5df2\u7ecf\u5f71\u54cd\u4e86\u7b54\u6848\u3002\n\n# \u6811\u94fe\u5256\u5206\uff1a\n\n\u5c31\u662f\u901a\u8fc7\u5256\u89e3\u6811\u4e0a\u91cd\u94fe\u7684\u65b9\u5f0f\u3002\u5c06\u6811\u4e0a\u95ee\u9898\u8f6c\u5316\u4e3a\u533a\u95f4\u95ee\u9898\u3002\n\n\u5728\u8fd9\u91cc\u5c31\u4e0d\u7ec6\u8bb2\u4e86\uff0c\u8be6\u60c5\u8bf7\u770b[\u6a21\u677f \u6811\u94fe\u5256\u5206](https://www.luogu.org/problem/P3384)\n\n_______\n## Code:\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<iostream>\n#define N 1001000\nusing namespace std;\nint fa[N],tr[N<<2],n,a,pt[N<<2],head[N],dep[N],top[N],ms[N],sz[N],num[N],tn[N];\nint tag[N<<2];\nint res;\nint cnt,q,timer;\nstring Q;\nstruct edg\n{\n\tint u,v,nxt;\n}e[N<<1];\nvoid add(int u,int v)\n{\n\te[++cnt].nxt=head[u];\n\te[cnt].u=u;\n\te[cnt].v=v;\n\thead[u]=cnt;\n}\nvoid dfs1(int x,int f,int deep)\n{\n\tdep[x]=deep;\n\tfa[x]=f;\n\tsz[x]=1;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa[x])continue;\n\t\tdfs1(v,x,deep+1);\n\t\tsz[x]+=sz[v];\n\t\tif(!ms[x]||sz[v]>sz[ms[x]])ms[x]=v;\n\t}\n}\nvoid dfs2(int x,int topf)\n{\n\ttop[x]=topf;\n\t++timer;\n\tnum[x]=timer;\n\tif(ms[x])dfs2(ms[x],topf);\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa[x]||v==ms[x])continue;\n\t\tdfs2(v,v);\n\t}\n}\nint ls(int p){return p<<1;}\nint rs(int p){return p<<1|1;}\nvoid pushdown(int p,int l,int r)\n{\n\tint md=(l+r)>>1;\n\ttag[ls(p)]=tag[rs(p)]=tag[p];\n\tif(tag[p]==0)tr[ls(p)]=tr[rs(p)]=tag[p];\n\telse tr[ls(p)]=md-l+1,tr[rs(p)]=r-md;\n\ttag[p]=-1;\n}\nvoid pushup(int p)\n{\n\ttr[p]=tr[ls(p)]+tr[rs(p)];\n}\nint chsum(int p,int l,int r,int gl,int gr,int k)\n{\n\tint res=0;\n\tif(gl<=l&&gr>=r)\n\t{\n\t\tint res1=tr[p];\n\t\ttag[p]=k;\n\t\ttr[p]=(r-l+1)*k;\n\t\treturn res1;\n\t}\n\tif(tag[p]!=-1)pushdown(p,l,r);\n\tint md=(l+r)>>1;\n\tif(gl<=md)res+=chsum(ls(p),l,md,gl,gr,k);\n\tif(gr>md)res+=chsum(rs(p),md+1,r,gl,gr,k);\n\tpushup(p);\n\treturn res;\n}\nint qofw(int s,int t)\n{\n\tint res=0;\n\twhile(top[s]!=top[t])\n\t{\n\t\tif(dep[top[s]]<dep[top[t]])swap(s,t);\n\t\tres+=chsum(1,1,n,num[top[s]],num[s],1);\n\t\ts=fa[top[s]];\n\t}\n\tif(dep[s]>dep[t])swap(s,t);\n\tres+=chsum(1,1,n,num[s],num[t],1);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint v;\n\t\tscanf(\"%d\",&v);\n\t//\tadd(i,v);\n\t\tadd(v,i);\n\t}\n\tdfs1(0,-1,0);\n\tdfs2(0,0);\n\tmemset(tag,-1,sizeof(tag));\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>Q;\n\t\tint s;\n\t\tif(Q==\"install\")\n\t\t{\n\t\t\tscanf(\"%d\",&s);\t\t\t\n\t\t\tres=qofw(s,0);\n\t\t\tres=dep[s]-res+1;\n\t\t}\n\t\tif(Q==\"uninstall\")\n\t\t{\n\t\t\tscanf(\"%d\",&s);\n\t\t\tres=chsum(1,1,n,num[s],num[s]+sz[s]-1,0);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n   return ~~(0-0);\n}\n```\n",
        "postTime": 1572342400,
        "uid": 93292,
        "name": "\u79bb\u5b50\u952eIonic_Bond",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "[P2146 [NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://www.luogu.org/problem/P2146)\n\n~~\u611f\u89c9\u4ee3\u7801\u6bd4\u5176\u4ed6\u9898\u89e3\u66f4\u7b80\u6d01qwq~~\n\n\u6811\u94fe\u5256\u5206\u6a21\u677f\u9898\n\n- install x\uff1a\u5c061~x\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u5168\u90e8\u53d8\u62101\uff08\u5b89\u88c5x\u9700\u8981\u5148\u5b89\u88c51~x\uff09\n\n- uninstall x\uff1a\u5c06x\u5b50\u6811\u8282\u70b9\u5168\u90e8\u53d8\u62100\uff08\u5378\u8f7dx\u540ex\u5b50\u6811\u8282\u70b9\u90fd\u4f1a\u88ab\u5378\u8f7d\uff09\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include<cstring>\nusing namespace std;\n#define N 200005\n\ninline int in() {\n    char ch = getchar();\n    int x = 0;\n    while (ch < '0' || ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n    return x;\n}\n\nchar st[15];\nint n, m, cnt, h[N], w[N], a[N << 2], laz[N << 2];\nint f[N], son[N], d[N], top[N], seg[N], s[N];\nstruct edge {\n    int v, h;\n} e[N << 1];\n\ninline void add(int u, int v) { e[++cnt] = (edge){ v, h[u] }, h[u] = cnt; }\n\nvoid dfs1(int u, int fa) {\n    f[u] = fa, d[u] = d[fa] + 1, s[u] = 1; //s\uff1asize \u5b50\u6811\u5927\u5c0f\n    for (int i = h[u], v; i; i = e[i].h)\n        if ((v = e[i].v) ^ fa) {\n            dfs1(v, u), s[u] += s[v];\n            if (s[v] > s[son[u]])\n                son[u] = v; //son\uff1a\u91cd\u513f\u5b50\n        }\n}\n\nvoid dfs2(int u, int TOP) {\n    seg[u] = ++cnt, top[u] = TOP;\n    if (!son[u])\n        return;\n    dfs2(son[u], TOP);\n    for (int i = h[u], v; i; i = e[i].h)\n        if ((v = e[i].v) ^ son[u] && v ^ f[u])\n            dfs2(v, v);\n}\n\ninline void pushdown(int o, int len) {\n    laz[o << 1] = laz[o], laz[o << 1 | 1] = laz[o];\n    a[o << 1] = laz[o] * (len - (len >> 1)), a[o << 1 | 1] = laz[o] * (len >> 1); //\u5b9e\u9645\u4e0a\u5c31\u662f\u628a\u201c+=\u201d\u6539\u4e3a\u201c=\u201d\n    laz[o] = -1;\n}\n\nvoid treeupd(int o, int l, int r, int L, int R, int k) { //k=1\u8868\u5b89\u88c5\uff0ck=0\u8868\u5378\u8f7d\uff0c\u8fd9\u6837\u4e00\u6765\u65b9\u4fbf\u66f4\u65b0a\u6570\u7ec4\n    if (r < L || l > R)\n        return;\n    if (L <= l && R >= r) {\n        laz[o] = k;\n        a[o] = k * (r - l + 1); //a\u5c31\u76f8\u5f53\u4e8esum\n        return;\n    }\n    if (laz[o] != -1)\n        pushdown(o, r - l + 1);\n    int mid = (l + r) >> 1;\n    treeupd(o << 1, l, mid, L, R, k);\n    treeupd(o << 1 | 1, mid + 1, r, L, R, k);\n    a[o] = a[o << 1] + a[o << 1 | 1];\n}\n\ninline void upd(int u, int v) {\n    while (top[u] ^ top[v]) {\n        if (d[top[u]] < d[top[v]])\n            swap(u, v);\n        treeupd(1, 1, n, seg[top[u]], seg[u], 1);\n        u = f[top[u]];\n    }\n    if (d[u] > d[v])\n        swap(u, v);\n    treeupd(1, 1, n, seg[u], seg[v], 1);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    memset(laz,-1,sizeof(laz));\n    for (int i = 2, x; i <= n; i++) x = in() + 1, add(x, i); //\u8282\u70b9\u7f16\u53f7\u7edf\u4e00\u52a01\uff0c\u7531\u4e8ei\u4f9d\u8d56x\uff0c\u6240\u4ee5\u5efa\u5355\u5411\u8fb9\u5373\u53ef\n    dfs1(1, 1), cnt = 0, dfs2(1, 1);\n    scanf(\"%d\", &m);\n    for (int k, x, num; m; m--) {\n        scanf(\"%s\", st), x = in() + 1, num = a[1]; //num\u5b58\u539f\u5df2\u5b89\u88c5\u8282\u70b9\u6570\n        if (st[0] == 'i')\n            upd(1, x), printf(\"%d\\n\", a[1] - num); //upd\uff1a\u4fee\u65391~x\u8def\u5f84\u4e0a\u7684\u8282\u70b9\n        else\n            treeupd(1, 1, n, seg[x], seg[x] + s[x] - 1, 0), printf(\"%d\\n\", num - a[1]); //\u4fee\u6539x\u5b50\u6811\n    }\n}\n```\n",
        "postTime": 1569669515,
        "uid": 68706,
        "name": "Randolph\u3001",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u9898\u7684\u5404\u79cd\u64cd\u4f5c\uff1a\n- \u628a\u4e00\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u53d8\u62101\n- \u628a\u4e00\u4e2a\u70b9\u548c\u5b83\u7684\u6240\u6709\u5b50\u8282\u70b9\u53d8\u62100\n\n\u75281\u8868\u793a\u88ab\u5b89\u88c5\u4e86\uff0c0\u8868\u793a\u6ca1\u6709\u5b89\u88c5\n\n\u53c8\u662f\u5b50\u6811\u53c8\u662f\u8def\u5f84\u7684\u96c6\u4f53\u64cd\u4f5c\uff0c\u5f88\u5bb9\u6613\u60f3\u5230**\u6811\u5256**\n\n\u90a3\u4e48\u5bf9\u4e8e\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u8bb0\u5f55\u4ec0\u4e48\uff1f\n- \u70b9\u4fe1\u606f\uff1a\u6bcf\u4e2a\u70b9\u7684\u503c\n- \u533a\u95f4\u4fe1\u606f\uff1a\u4ee5\u5f53\u524d\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u503c\u7684\u548c\uff08\u6709\u70b9\u7ed5\uff0c\u6362\u4e00\u79cd\u65b9\u5f0f\u7406\u89e3\u5c31\u662f\uff1a\u5f53p\u4e3a\u6839\u65f6\uff0c\u503c\u662f$\\sum_{i=p}^{p+size_p-1} value_i$\uff0c\u5176\u4e2d$size_p$\u8868\u793a\u4ee5$p$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u5927\u5c0f\uff0c$value_i$\u8868\u793a\u70b9$i$\u7684\u503c\uff09\n- \u76ee\u6807\u4fe1\u606f\uff1a\u6240\u6709\u70b9\u7684\u503c\u7684\u548c\n\n\u6211\u4eec\u8f93\u51fa\u65f6\uff0c\u8f93\u51fa\u64cd\u4f5c\u524d\u540e\u4e24\u6b21\u76ee\u6807\u4fe1\u606f\u4e4b\u5dee\u5373\u53ef\u3002\u56e0\u4e3a\u6bcf\u4e00\u6b21\u6539\u53d8\u53ea\u4f1a\u628a1\u6539\u62100\u6216\u628a0\u6539\u62101\uff0c\u90a3\u6837\u5b50\u53d8\u5316\u7684\u503c\u7684\u7edd\u5bf9\u503c\u521a\u597d\u5c31\u662f\u53d8\u5316\u6570\u91cf\n\nPS\uff1a\u4ee3\u7801\u98ce\u683c\uff0c\u53d8\u91cf\u540d\u7b49\u504f\u5411\u300a\u7b97\u6cd5\u7ade\u8d5b\u8fdb\u9636\u6307\u5357\u300b\uff08\u674e\u715c\u4e1c \u8457\uff09\uff0c\u4e60\u60ef\u90a3\u672c\u4e66\u98ce\u683c\u7684\u53ef\u4ee5\u770b\u6211\u7684\u4ee3\u7801\n\n\u4ee3\u7801\uff1a\n```cpp\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst ll N=100010;\nll ver[N<<1],Next[N<<1],head[N],tot;//\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u8fb9\nll n,m,cnt,d[N],father[N],size[N],son[N],id[N],top[N];\n//size[x]\u8868\u793a\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u7684\u5927\u5c0f\n//son[x]\u8868\u793ax\u7684\u91cd\u513f\u5b50\u7684\u7f16\u53f7\nstruct SegmentTree{\n\tll l,r,sum,lazy;\n\t//lazy\u8868\u793a\u61d2\u6807\u8bb0\n\t//lazy=-1\u8868\u793a\u6807\u8bb0\u4e3a\u7a7a\n\t//lazy=0\u8868\u793a\u70b9\u7684\u503c\u53d8\u62100\n\t//lazy=1\u8868\u793a\u70b9\u7684\u503c\u53d8\u62101\n}tree[N<<2];\n\ninline ll read(){\n\tll x=0,tmp=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') tmp=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn tmp*x;\n}\n\ninline void write(ll x){\n\tif(x<0){\n\t\tx=-x;\n\t\tputchar('-');\n\t}\n\tll y=10,len=1;\n\twhile(y<=x){\n\t\ty=(y<<3)+(y<<1);\n\t\tlen++;\n\t}\n\twhile(len--){\n\t\ty/=10;\n\t\tputchar(x/y+48);\n\t\tx%=y;\n\t}\n}\n\ninline void addEdge(ll x,ll y){\n\tver[++tot]=y;\n\tNext[tot]=head[x];\n\thead[x]=tot;\n}\n\nvoid dfs1(ll x,ll before){\n\tsize[x]=1; father[x]=before; d[x]=d[before]+1;\n\tfor(ll i=head[x]; i; i=Next[i]){\n\t\tll y=ver[i];\n\t\tif(y==before) continue;\n\t\tdfs1(y,x);\n\t\tsize[x]+=size[y];\n\t\tif(size[y]>size[son[x]]) son[x]=y;\n\t}\n}\n\nvoid dfs2(ll x,ll topf){\n\tid[x]=++cnt; top[x]=topf;\n\tif(!son[x]) return;\n\tdfs2(son[x],topf);\n\tfor(ll i=head[x]; i; i=Next[i]){\n\t\tll y=ver[i];\n\t\tif(y==father[x]||y==son[x]) continue;\n\t\tdfs2(y,y);\n\t}\n}\n\nvoid build(ll p,ll l,ll r){\n\ttree[p].l=l; tree[p].r=r;\n\ttree[p].sum=0; tree[p].lazy=-1;\n\tif(l==r) return;\n\tll mid=(l+r)>>1;\n\tbuild(p<<1,l,mid);\n\tbuild(p<<1|1,mid+1,r);\n}\n\ninline void pushup(ll p){\n\ttree[p].sum=tree[p<<1].sum+tree[p<<1|1].sum;\n}\n\ninline void pushdown(ll p){\n\tif(tree[p].lazy!=-1){\n\t\ttree[p<<1].sum=(tree[p<<1].r-tree[p<<1].l+1)*tree[p].lazy;\n\t\ttree[p<<1|1].sum=(tree[p<<1|1].r-tree[p<<1|1].l+1)*tree[p].lazy;\n\t\ttree[p<<1].lazy=tree[p<<1|1].lazy=tree[p].lazy;\n\t\ttree[p].lazy=-1;\t\n\t}\n}\n\nvoid update(ll p,ll l,ll r,ll val){\n\tif(l<=tree[p].l&&tree[p].r<=r){\n\t\ttree[p].sum=(tree[p].r-tree[p].l+1)*val;\n\t\ttree[p].lazy=val;\n\t\treturn;\n\t}\n\tpushdown(p);\n\tll mid=(tree[p].l+tree[p].r)>>1;\n\tif(l<=mid) update(p<<1,l,r,val);\n\tif(r>mid) update(p<<1|1,l,r,val);\n\tpushup(p);\n}\n\ninline void Update(ll x,ll y,ll val){\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]]) swap(x,y);\n\t\tupdate(1,id[top[x]],id[x],val);\n\t\tx=father[top[x]];\n\t}\n\tif(d[x]>d[y]) swap(x,y);\n\tupdate(1,id[x],id[y],val);\n}\n\nint main(){\n\tn=read();\n\tfor(ll i=2; i<=n; i++){\n\t\tll x=read()+1;\n\t\taddEdge(x,i);\n\t\taddEdge(i,x);\n\t}\n\tdfs1(1,0); dfs2(1,1);\n\tbuild(1,1,n);\n\tm=read();\n\twhile(m--){\n\t\tchar s[100]; scanf(\"%s\",s);\n\t\tll x=read()+1,sum=tree[1].sum;\n\t\tif(s[0]=='i'){\n\t\t\tUpdate(1,x,1);\n\t\t\twrite(tree[1].sum-sum); putchar('\\n');\n\t\t}\n\t\telse if(s[0]=='u'){\n\t\t\tupdate(1,id[x],id[x]+size[x]-1,0);\n\t\t\twrite(sum-tree[1].sum); putchar('\\n');\n\t\t}\n\t\telse printf(\"WTF??? %lld\\n\",m);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1569138833,
        "uid": 27924,
        "name": "xukuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# P2146 \u9898\u89e3\n[\u5173\u4e8e\u6811\u94fe\u5256\u5206\u7684\u6559\u7a0b](https://listening-post-1379.blog.luogu.org/post-suan-fa-bi-ji-shu-lian-pou-fen)\n\n## \u601d\u8def\n\u8fd9\u9898\u5c31\u662f\u4e00\u9053**\u6811\u94fe\u5256\u5206**\u7684\u6a21\u677f\u9898\uff0c\u75280\u548c1\u5206\u522b\u4ee3\u8868\u6bcf\u4e2a\u8f6f\u4ef6\u7684\u5b58\u5728\u4e0e\u5426\uff0c\u90a3\u4e48\u201c\u5b89\u88c5$k$\u201d\u64cd\u4f5c\u5c31\u662f\u628a\u4ece$1$\u5230$k$\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u90fd\u7f6e\u4e3a$1$\uff0c\u800c\u201c\u5378\u8f7d$k$\u201d\u5219\u662f\u5c06$k$\u7684\u5b50\u6811\u90fd\u7f6e\u4e3a$0$\uff0c\u7528\u6811\u94fe\u5256\u5206\u5c31\u53ef\u4ee5\u5341\u5206\u65b9\u4fbf\u5730\u7ef4\u62a4\u8fd9\u4e24\u79cd\u64cd\u4f5c\u3002\n\n\u7136\u540e\u5bf9\u6839\u8282\u70b9\u6c42\u533a\u95f4\u548c\u5c31\u53ef\u4ee5\u6c42\u51fa\u4e00\u5171\u6709\u591a\u5c11\u4e2a\u72b6\u6001\u503c\u4e3a$1$\uff08\u5373\u5b89\u88c5\u4e86\uff09\u7684\u8f6f\u4ef6\uff0c\u7528\u8fd9\u4e2a\u6570\u51cf\u53bb\u4e0a\u4e00\u6b21\u64cd\u4f5c\u65f6\u7684\u5b89\u88c5\u8f6f\u4ef6\u6570\u5373\u4e3a\u6539\u53d8\u7684\u6570\u76ee\u3002\n\n---\n\n## Tips\uff1a\n-  \u201c\u8d4b\u503c\u201d\u8fd0\u7b97\u4e0d\u80fd\u8fdb\u884c\u53e0\u52a0\uff0c\u6253\u5ef6\u8fdf\u6807\u8bb0\u65f6\u8981\u6ce8\u610f**\u5148\u5c06\u539f\u6709\u7684\u5ef6\u8fdf\u6807\u8bb0\u4e0b\u4f20**\n-  \u6570\u636e\u8303\u56f4\u8fd9\u4e48\u5927\u4e00\u5b9a\u8981\u5199**\u5feb\u8bfb**\n\n---\n\n##\u4ee3\u7801\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <cmath>\nusing namespace std;\nconst int maxn=100005;\nint n,m,last;\nvector<int> e[maxn];\nint father[maxn],dep[maxn],size[maxn],hson[maxn],top[maxn],seg[maxn],rev[maxn<<2],num[maxn],tot;\nstruct segmenttree{ //\u7ebf\u6bb5\u6811\n    int l,r,sum,add=-1;\n    #define l(x) tree[x].l\n    #define r(x) tree[x].r\n    #define sum(x) tree[x].sum\n    #define add(x) tree[x].add\n};\nsegmenttree tree[maxn<<2];\ninline int readint() { //\u5feb\u8bfb\n   int x=0;char ch=getchar();\n    while(ch<48||ch>57) ch=getchar();\n    while(ch>=48&&ch<=57) x=x*10+ch-48,ch=getchar();\n    return x;\n}\ninline void readchar(char * input) { //\u5feb\u8bfb\n  int len=0;\n  char ch=getchar();\n  while(ch!=' ' && ch!='\\r' && ch !='\\n')\n  {\n    input[len++]=ch;\n    ch=getchar();\n  }\n}\nvoid addedge(int x,int y) //vector\u5b58\u56fe\n{\n    e[x].push_back(y);\n    e[y].push_back(x);\n}\nvoid dfs1(int u,int f) //\u6811\u5256\u9884\u5904\u7406\n{\n    size[u]=1;\n    father[u]=f;\n    dep[u]=dep[f]+1;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(v!=f)\n        {\n            dfs1(v,u);\n            size[u]+=size[v];\n            if(size[v]>size[hson[u]]) hson[u]=v;\n        }\n    }\n}\nvoid dfs2(int u,int f) //\u6811\u5256\u9884\u5904\u7406\n{\n    if(hson[u])\n    {\n        seg[hson[u]]=++tot;\n        top[hson[u]]=top[u];\n        rev[tot]=hson[u];\n        dfs2(hson[u],u);\n    }\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!top[v])\n        {\n            seg[v]=++tot;\n            rev[tot]=v;\n            top[v]=v;\n            dfs2(v,u);\n        }\n    }\n}\nvoid build(int p,int l,int r) //\u7ebf\u6bb5\u6811\u5efa\u6811\n{\n    int mid=(l+r)>>1;\n    l(p)=l;r(p)=r;\n    if(l==r){\n        sum(p)=num[rev[l]];\n        return;\n    }\n    build(p<<1,l,mid);\n    build(p<<1|1,mid+1,r);\n    sum(p)=(sum(p<<1)+sum(p<<1|1));\n    return;\n}\nvoid spread(int p) //\u4e0b\u4f20\u5ef6\u8fdf\u6807\u8bb0\n{\n\tif(add(p)>=0)\n\t{\n\t\tsum(p<<1)=add(p)*(r(p<<1)-l(p<<1)+1);\n\t\tsum(p<<1|1)=add(p)*(r(p<<1|1)-l(p<<1|1)+1);\n\t\tadd(p<<1)=add(p);\n\t\tadd(p<<1|1)=add(p);\n\t\tadd(p)=-1;\n\t}\n}\nint query(int p,int l,int r) //\u533a\u95f4\u67e5\u8be2\n{\n  if(l>r) swap(l,r);\n  if(l<=l(p) && r>=r(p)) return sum(p);\n  spread(p);\n  int mid=((l(p)+r(p))>>1);\n  int ans=0;\n  if(l<=mid) ans=(ans+query(p<<1,l,r));\n  if(r>mid) ans=(ans+query(p<<1|1,l,r));\n  return ans;\n}\nvoid update(int p,int l,int r,int c) { //\u533a\u95f4\u66f4\u65b0\n  if(l>r) swap(l,r);\n  spread(p); //\u5148\u5c06\u539f\u6709\u7684\u5ef6\u8fdf\u6807\u8bb0\u4e0b\u4f20\n  if(l<=l(p) && r>=r(p)) {\n\t\tsum(p)=c*(r(p)-l(p)+1);\n\t\tadd(p)=c;\n\t\treturn;\n\t}\n\tint mid=((l(p)+r(p))>>1);\n\tif(l<=mid) update(p<<1,l,r,c);\n\tif(r>mid) update(p<<1|1,l,r,c);\n\tsum(p)=(sum(p<<1)+sum(p<<1|1));\n}\nvoid crange(int x,int y,int k) //\u8def\u5f84\u4fee\u6539\n{\n  while(top[x]!=top[y]) {\n    if(dep[top[x]]<dep[top[y]]) swap(x,y);\n    update(1,seg[top[x]],seg[x],k);\n    x=father[top[x]];\n  }\n  if(dep[x]>dep[y]) swap(x,y);\n  update(1,seg[x],seg[y],k);\n}\nvoid cson(int x,int k) //\u5b50\u6811\u4fee\u6539\n{\n  update(1,seg[x],seg[x]+size[x]-1,k);\n}\nint main()\n{\n  n=readint();\n  for(int i=2,a;i<=n;i++){\n    a=readint();\n    addedge(i,a+1);\n  }\n  m=readint();\n  dfs1(1,0);\n  tot=seg[1]=1; //\u6811\u5256\u521d\u59cb\u5316\n  top[1]=rev[1]=1;\n  dfs2(1,0);\n  build(1,1,n+1);\n  int last=query(1,1,n); //\u5b58\u597d\u4e0a\u4e00\u6b21\u7684\u8f6f\u4ef6\u6570\n  for(int i=1,x;i<=m;i++)\n  {\n    char op[20];\n    scanf(\"%s\\n\",op);\n    if (op[0]=='i') { //\u5b89\u88c5\n      x=readint();\n      crange(x+1,1,1);\n      int cur=query(1,1,n);\n      printf(\"%d\\n\",abs(last-cur)); //\u66f4\u65b0\u7b54\u6848\n      last=query(1,1,n); //\u5b58\u597d\u4e0a\u4e00\u6b21\u7684\u8f6f\u4ef6\u6570\n    }\n    else if (op[0]=='u') { //\u5b89\u88c5\n      x=readint();\n      cson(x+1,0);\n      int cur=query(1,1,n);\n      printf(\"%d\\n\",abs(last-cur)); //\u66f4\u65b0\u7b54\u6848\n      last=cur; //\u5b58\u597d\u4e0a\u4e00\u6b21\u7684\u8f6f\u4ef6\u6570\n    }\n  }\n  return 0;\n}\n```\n",
        "postTime": 1568903208,
        "uid": 155907,
        "name": "1379\u53f7\u76d1\u542c\u5458",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# [***\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u6233\u6211***](https://www.cnblogs.com/zhenglw/p/10356806.html)\n\n\u3000\u3000 _**\u53c8\u662f\u5728\u6811\u4e0a\u778e\u641e\u6ef4\u9898\u76ee....**_ \n\n\u3000\u3000\u6211\u4eec\u5982\u679c\u4ee5\u5b89\u88c5\u7684\u8f6f\u4ef6\u4e3a1\uff0c\u672a\u5b89\u88c5\u7684\u8f6f\u4ef6\u4e3a0\uff0c\u90a3\u4e48\u8f6f\u4ef6\u6539\u53d8\u7684\u6570\u91cf\u5373\u6811\u4e0a\u6743\u503c\u603b\u548c\u7684\u6570\u91cf\uff0c\u6d89\u53ca\u5230\u533a\u95f4\u4fee\u6539\uff0c\u533a\u95f4\u67e5\u8be2\uff0c\u8003\u8651 _**\u6811\u5256**_ \n\n\u3000\u3000\u5206\u6790\u5b8c\u6bd5\uff0c\u4f3c\u4e4e\u6ca1\u5565\u597d\u8bf4\u7684\u4e86\u3002\u3002\u3002\u6811\u5256\u6a21\u677f\u9898\uff08\u7136\u9e45\u6211\u662f\u4e0d\u4f1a\u544a\u8bc9\u4f60\u4eec\u6211\u56e0\u4e3a\u628aint\u6253\u6210char\u67e5\u4e86\u597d\u4e45\u597d\u4e45\u4ee3\u7801\u6ef4...\uff09\u3000\u3000\u3000\n\n\u3000\u3000\u7ec6\u8282\u95ee\u9898\uff1a\u4e3a\u4e86\u4fbf\u4e8e\u5904\u7406\u628a\u6bcf\u4e2a\u8282\u70b9\u7f16\u53f7\u90fd\u52a0\u4e0a1\uff0c\u907f\u514d\u4e00\u4e9b\u4e0d\u5fc5\u8981\u7684\u9519\u8bef\n  \t\u7136\u540e\u6ce8\u610f\u4e00\u4e0bpush_down\uff08\u6807\u8bb0\u4e0b\u4f20\uff09\u7684\u64cd\u4f5c\uff0clz\u662flazy_tag,0\u4ee3\u8868\u4e0d\u66f4\u65b0\uff0c-1\u4ee3\u8868\u5220\u9664\uff08\u53d8\u62100\uff09\uff0c1\u4ee3\u8868\u5b89\u88c5\uff08\u53d8\u62101\uff09\n\n\u3000\u3000P.S.\u6253\u5b8c\u624d\u53d1\u73b0\u597d\u50cf\u4e0d\u7528\u533a\u95f4\u67e5\u8be2\n\n\u3000\u3000\u4ee3\u7801\uff08\u538b\u4e86\u4e00\u4e22\u4e22\u884c\uff0c\u8868\u4ecb\u610f\u5566\uff09\uff1a\n  ```\n#include<cstdio>\n#include<cctype>\n#include<iostream>\nusing namespace std;\ninline int read(){\n\tint ans=0,f=1;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')f=-1;chr=getchar();}\n\twhile(isdigit(chr)) {ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}\n\treturn ans*f;\n}const int M=200005;int n,m;\ninline int abs(int x) {if(x<0) return -x;return x;}\nint head[M],ver[M],nxt[M],tot,fa[M],dep[M],son[M],top[M],idx[M],sz[M],t,sum[M<<2],lz[M<<2];\t\ninline void add(int x,int y){ver[++tot]=y;nxt[tot]=head[x];head[x]=tot;}\nvoid dfs1(int x){\n\tdep[x]=dep[fa[x]]+1;sz[x]=1;\n\tfor(int i=head[x];i;i=nxt[i]){\n\t\tif(ver[i]==fa[x]) continue;\n\t\tfa[ver[i]]=x,dfs1(ver[i]);sz[x]+=sz[ver[i]];\n\t\tif(sz[ver[i]]>sz[son[x]]) son[x]=ver[i];\n\t}\n}void dfs2(int x,int topf){\n\tidx[x]=++t;top[x]=topf;\n\tif(!son[x]) return;dfs2(son[x],topf);\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(!idx[ver[i]]) dfs2(ver[i],ver[i]);\n}inline void Push_Up(int i){sum[i]=sum[i<<1]+sum[i<<1|1];}\n inline void Push_Down(int i,int l,int r){\n \tif(lz[i]==0) return;int mid=l+r>>1;\n \tif(lz[i]==-1) sum[i<<1]=sum[i<<1|1]=0,lz[i<<1]=lz[i<<1|1]=-1;\n \telse sum[i<<1]=mid-l+1,sum[i<<1|1]=r-mid,lz[i<<1]=lz[i<<1|1]=1;\n \tlz[i]=0;return;\n}void Update(int i,int l,int r,int ql,int qr,int x){\n\tif(ql<=l&&r<=qr){\n\t\tif(!x)lz[i]=-1,sum[i]=0;//lz==-1-->Update->0  lz==1 --> Update->1\n\t\telse lz[i]=1,sum[i]=r-l+1;\n\t\treturn;\n\t}int mid=l+r>>1;Push_Down(i,l,r);\n\tif(mid>=ql) Update(i<<1,l,mid,ql,qr,x);\n\tif(mid<qr)  Update(i<<1|1,mid+1,r,ql,qr,x);\n\tPush_Up(i);\n}void Change(int v,int x,int y){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tUpdate(1,1,n,idx[top[x]],idx[x],v);\n\t\tx=fa[top[x]];\n\t}if(dep[x]>dep[y]) swap(x,y);Update(1,1,n,idx[x],idx[y],v);\n}\nint main(){\n//\tfreopen(\"rjb.in\",\"r\",stdin);\n\tn=read();\n\tfor(int i=2;i<=n;i++){int x=read();++x;add(x,i);add(i,x);}\n\tdfs1(1),dfs2(1,1);\n\tm=read();char opt[20];int x,bf;\n\twhile(m--){scanf(\"%s\",opt);x=read();bf=sum[1];++x; \n\t\tif(opt[0]=='i'){\n\t\t\tChange(1,x,1);\n\t\t\tprintf(\"%d\\n\",abs(sum[1]-bf));\n\t\t}else{\n\t\t\tUpdate(1,1,n,idx[x],idx[x]+sz[x]-1,0);\n\t\t\tprintf(\"%d\\n\",abs(sum[1]-bf));\n\t\t}\n\t}\n\treturn 0;\n}\n  ```",
        "postTime": 1549633809,
        "uid": 9287,
        "name": "LevenKoko",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "## [\u6302\u4e2a\u5916\u94fe\uff0c\uff08\u9a97\u4e0b\u8bbf\u95ee\u91cf\uff1f\uff09](https://www.cnblogs.com/henry-1202/p/9152374.html)\n\n\u5927\u6982\u7b97\u662f\u4e00\u9053\u6a21\u677f\u9898\u5427\uff1f\n\n\u5c31\u662f\u7ec6\u8282\u6709\u70b9\u591a\n\n\u7f57\u5217\u4e00\u4e0b\uff1a\n***\n1. \u5982\u679c\u4e60\u60ef\u4ece1\u5f00\u59cb\u641e\u6811\u7684\u7f16\u53f7\u7684\u8bdd\uff0c\u5904\u7406\u8f93\u5165\u8fdb\u6765\u7684\u90a3\u4e2a\u4f9d\u8d56\u5173\u7cfb\u5728\u52a0\u8fb9\u7684\u65f6\u5019\u4e24\u4e2a\u90fd\u8981+1\uff0c\u4f53\u73b0\u5728\u4ee3\u7801\u5c31\u662fi\u8981\u4ece2\u679a\u4e3e\u5230n\uff0c\u7136\u540e\u8f93\u5165\u8fdb\u6765\u7684\u90a3\u4e2a\u6570\u8981+1\n1. \u8fd9\u9053\u9898\u7684\u7ebf\u6bb5\u6811\u7684\u6253\u6cd5\u4e5f\u6709\u6240\u4e0d\u540c\uff0c\u56e0\u4e3a\u53ea\u6709\u4e24\u79cd\u72b6\u6001\uff0c\u4e5f\u5c31\u662f\u5df2\u5b89\u88c5\u548c\u672a\u5b89\u88c5\uff0c\u6211\u8fd9\u91cc\u662f\u75281\u548c0\u6765\u8868\u793a\u7684\uff0c\u6240\u4ee5lazy\u6807\u8bb0\u5c31\u4e0d\u80fd\u6253\u62100\u4e86\uff0c\u6211\u7684\u4ee3\u7801\u4e2d\u662f\u7528-1\u6765\u8868\u793a\u7684\uff0c\u6ce8\u610f\u8981\u5224\u8fd9\u4e2a\u4e1c\u897f\uff08\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u75281\u548c2\u8868\u793a\u8fd9\u4e24\u79cd\u72b6\u6001\uff09\n1. \u7ebf\u6bb5\u6811\u7684\u4fee\u6539\u4e5f\u8981\u6539\u4e00\u4e0b\uff0c+=\u5f97\u6539\u6210=\uff08\u663e\u7136\uff1f\uff09\n***\n\u5269\u4e0b\u5c31\u662f\u6811\u5256\u6a21\u677f\u4e86\u5427..\n```cpp\n#include <cstdio>\n#include <cstring>\n#define ll int\n#define inf 1<<30\n#define il inline \nil ll max(ll x,ll y){return x>y?x:y;}\nil ll min(ll x,ll y){return x<y?x:y;}\nil ll abs(ll x){return x>0?x:-x;}\nil void swap(ll &x,ll &y){ll t=x;x=y;y=t;}\nil void read(ll &x){\n    x=0;ll f=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')f=-f;c=getchar();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    x*=f;\n}\nil void print(ll x){if(x<0)putchar('-');x=abs(x);if(x>9)print(x/10);putchar(x%10+'0');}\nil void writeln(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar('\\n');}\nil void write(ll x){if(x<0)putchar('-');x=abs(x);print(x);putchar(' ');}\nusing namespace std;\n/*===================Header Template=====================*/\n#define N 100010\nstruct edge{ll to,next;}e[N<<2];\nstruct tree{ll l,r,sum,lazy;}t[N<<2];\nll cnt,head[N],sz,n,m,a[N];\nll pos[N],fa[N],dep[N],siz[N],top[N];\nvoid insert(ll u,ll v){\n    e[++cnt].next=head[u];e[cnt].to=v;head[u]=cnt;\n    e[++cnt].next=head[v];e[cnt].to=u;head[v]=cnt;\n}\nvoid dfs1(ll x){\n    siz[x]=1;\n    for(ll i=head[x];i;i=e[i].next){\n        if(fa[x]==e[i].to)continue;\n        dep[e[i].to]=dep[x]+1;\n        fa[e[i].to]=x;\n        dfs1(e[i].to);\n        siz[x]+=siz[e[i].to];\n    }\n}\nvoid dfs2(ll x,ll topf){\n    ll k=0;\n    pos[x]=++sz;\n    top[x]=topf;\n    for(ll i=head[x];i;i=e[i].next){\n        if(dep[e[i].to]>dep[x]&&siz[e[i].to]>siz[k])\n            k=e[i].to;\n    }\n    if(k==0)return;\n    dfs2(k,topf);\n    for(ll i=head[x];i;i=e[i].next){\n        if(dep[e[i].to]>dep[x]&&k!=e[i].to){\n            dfs2(e[i].to,e[i].to);\n        }\n    }\n}\nvoid pushdown(ll ln,ll rn,ll rt){\n    if(t[rt].lazy!=-1){\n        ll &x=t[rt].lazy;\n        t[rt<<1].sum=ln*x;\n        t[rt<<1|1].sum=rn*x;\n        t[rt<<1].lazy=x;\n        t[rt<<1|1].lazy=x;\n        x=-1;\n    }\n}\nvoid build(ll l,ll r,ll rt){\n    t[rt].l=l;t[rt].r=r;t[rt].lazy=-1;\n    if(l==r)return;\n    ll mid=(l+r)>>1;\n    build(l,mid,rt<<1);\n    build(mid+1,r,rt<<1|1);\n}\nvoid upd(ll L,ll R,ll c,ll rt){\n    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1;\n    if(L<=l&&r<=R){t[rt].sum=(r-l+1)*c;t[rt].lazy=c;return;}\n    pushdown(mid-l+1,r-mid,rt);\n    if(L<=mid)upd(L,R,c,rt<<1);\n    if(R>mid)upd(L,R,c,rt<<1|1);\n    t[rt].sum=t[rt<<1].sum+t[rt<<1|1].sum;\n}\nll query(ll L,ll R,ll rt){\n    ll l=t[rt].l,r=t[rt].r,mid=(l+r)>>1,ans=0;\n    if(L<=l&&r<=R)return t[rt].sum;\n    pushdown(mid-l+1,r-mid,rt);\n    if(L<=mid)ans+=query(L,R,rt<<1);\n    if(R>mid)ans+=query(L,R,rt<<1|1);\n    return ans;\n}\nvoid A(ll x,ll y){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        upd(pos[top[x]],pos[x],0,1);\n        x=fa[top[x]];\n    }\n    if(pos[x]>pos[y])swap(x,y);\n    upd(pos[x],pos[y],0,1);\n}\nll Q(ll x,ll y){\n    ll sum=0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        sum+=query(pos[top[x]],pos[x],1);\n        x=fa[top[x]];\n    }\n    if(pos[x]>pos[y])swap(x,y);\n    sum+=query(pos[x],pos[y],1);\n    return sum;\n}\nint main(){\n    read(n);\n    for(ll i=2;i<=n;i++){\n        ll x;read(x);x++;\n        insert(i,x);\n    }\n    dfs1(1);dfs2(1,1);\n    build(1,n,1);\n    upd(1,n,1,1);\n    read(m);\n    while(m--){\n        char ch[10];ll x;\n        scanf(\"%s%d\",ch,&x);x++;\n        if(ch[0]=='i'){writeln(Q(x,1));A(x,1);}\n        if(ch[0]=='u'){\n            writeln(siz[x]-query(pos[x],pos[x]+siz[x]-1,1));\n            upd(pos[x],pos[x]+siz[x]-1,1,1);\n        }\n    }\n    return 0;\n}\n```\n~~\u98df\u7528\u8bf7\u8c28\u614e\uff0c\u672c\u4eba\u4eba\u4e11\u5e38\u6570\u5927~~",
        "postTime": 1528369506,
        "uid": 36526,
        "name": "henry_y",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u601d\u8def\u591a\u7ed5\u4e86\u51e0\u4e2a\u5f2f\uff0c\u4f46\u662f\u4e0d\u5f71\u54cda\u4e86\u8fd9\u9898\n\n\u5bb9\u6613\u53d1\u73b0\u5b89\u88c5\u64cd\u4f5c\u5c31\u662f\u7edf\u8ba1root\u5230x\u7684\u8def\u5f84\u4e0a0\u7684\u6570\u91cf\uff0c\u663e\u7136\u4e3a0\u7684\u4e00\u5b9a\u662f\u4ecex\u5411\u4e0a\u7684\u8fde\u7eed\u4e00\u6574\u6bb5\uff0c\u90a3\u4e48\u53ef\u4ee5\u4e8c\u5206\u8fd9\u4e2a\u8282\u70b9\n\n\u5378\u8f7d\u64cd\u4f5c\u5c31\u662f\u7edf\u8ba1\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u4e2d1\u7684\u6570\u91cf\uff0c\u7136\u540e\u6e05\u7a7a\n\n\u8fd9\u4e2a\u65b9\u6cd5\u8dd1\u5f97\u5de8\u6162\uff0c\u4e3b\u8981\u662f\u8981\u4e8c\u5206\u8fd8\u8981\u500d\u589e\u5411\u4e0a\u8df3\uff0c\u7406\u8bba\u4e0a\u8bb2\u662f\u4e09\u4e2alog\u7684\u3002\u3002\n\n\u4e0d\u8fc7\u6ca1\u5173\u7cfb\uff0c\u6d1b\u8c37\u73b0\u5728\u4e5f\u6709o2\u4e86\n\n```cpp\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#define rep(i,st,ed) for (int i=st;i<=ed;++i)\n#define drp(i,st,ed) for (int i=st;i>=ed;--i)\n#define fill(x,t) memset(x,t,sizeof(x))\nusing std:: swap;\nconst int N=400005;\nconst int E=1600005;\nstruct edge{int x,y,next;}e[E];\nint size[N],pos[N],dep[N],fa[N][21],bl[N],a[N];\nint sum[N<<2],num[N<<2],lazy[N<<2];\nint ls[N],edCnt,n,m;\nint read() {\n    int x=0,v=1; char ch=getchar();\n    for (;ch<'0'||ch>'9';v=(ch=='-')?(-1):(v),ch=getchar());\n    for (;ch<='9'&&ch>='0';x=x*10+ch-'0',ch=getchar());\n    return x*v;\n}\nvoid addEdge(int x,int y) {\n    e[++edCnt]=(edge){x,y,ls[x]}; ls[x]=edCnt;\n    e[++edCnt]=(edge){y,x,ls[y]}; ls[y]=edCnt;\n}\nvoid dfs1(int now) {\n    rep(i,1,20) fa[now][i]=fa[fa[now][i-1]][i-1];\n    size[now]=1;\n    for (int i=ls[now];i;i=e[i].next) {\n        if (e[i].y==fa[now][0]) continue;\n        dep[e[i].y]=dep[now]+1;\n        fa[e[i].y][0]=now;\n        dfs1(e[i].y);\n        size[now]+=size[e[i].y];\n    }\n}\nvoid dfs2(int now,int up) {\n    pos[now]=++pos[0]; bl[now]=up;\n    int mx=0;\n    for (int i=ls[now];i;i=e[i].next) {\n        if (e[i].y==fa[now][0]||size[e[i].y]<=size[mx]) continue;\n        mx=e[i].y;\n    }\n    if (!mx) return ;\n    dfs2(mx,up);\n    for (int i=ls[now];i;i=e[i].next) {\n        if (e[i].y==fa[now][0]||e[i].y==mx) continue;\n        dfs2(e[i].y,e[i].y);\n    }\n}\nvoid push_down(int now,int tl,int tr) {\n    if (lazy[now]==-1) return ;\n    int mid=(tl+tr)>>1;\n    lazy[now<<1]=lazy[now];\n    lazy[now<<1|1]=lazy[now];\n    num[now<<1]=lazy[now];\n    num[now<<1|1]=lazy[now];\n    sum[now<<1]=(mid-tl+1)*lazy[now];\n    sum[now<<1|1]=(tr-mid)*lazy[now];\n    lazy[now]=-1;\n}\nint query(int now,int tl,int tr,int l,int r) {\n    if (tl==l&&tr==r) return sum[now];\n    push_down(now,tl,tr);\n    int mid=(tl+tr)>>1;\n    if (r<=mid) return query(now<<1,tl,mid,l,r);\n    else if (l>mid) return query(now<<1|1,mid+1,tr,l,r);\n    else return query(now<<1,tl,mid,l,mid)+query(now<<1|1,mid+1,tr,mid+1,r);\n}\nvoid modify(int now,int tl,int tr,int l,int r,int v) {\n    if (tl==l&&tr==r) {\n        num[now]=v;\n        sum[now]=(tr-tl+1)*v;\n        lazy[now]=v;\n        return ;\n    }\n    push_down(now,tl,tr);\n    int mid=(tl+tr)>>1;\n    if (r<=mid) modify(now<<1,tl,mid,l,r,v);\n    else if (l>mid) modify(now<<1|1,mid+1,tr,l,r,v);\n    else {\n        modify(now<<1,tl,mid,l,mid,v);\n        modify(now<<1|1,mid+1,tr,mid+1,r,v);\n    }\n    sum[now]=sum[now<<1]+sum[now<<1|1];\n    if (num[now<<1]==num[now<<1|1]) num[now]=num[now<<1];\n    else num[now]=-1;\n}\nvoid change(int x,int y,int v) {\n    while (bl[x]!=bl[y]) {\n        if (dep[bl[x]]<dep[bl[y]]) swap(x,y);\n        modify(1,1,n,pos[bl[x]],pos[x],v);\n        x=fa[bl[x]][0];\n    }\n    if (pos[x]>pos[y]) swap(x,y);\n    modify(1,1,n,pos[x],pos[y],v);\n}\nint get_sum(int x,int y) {\n    int ret=0;\n    while (bl[x]!=bl[y]) {\n        if (dep[bl[x]]<dep[bl[y]]) swap(x,y);\n        ret+=query(1,1,n,pos[bl[x]],pos[x]);\n        x=fa[bl[x]][0];\n    }\n    if (pos[x]>pos[y]) swap(x,y);\n    ret+=query(1,1,n,pos[x],pos[y]);\n    return ret;\n}\nint UP(int x,int dep) {\n    drp(i,20,0) if ((1<<i)<=dep&&fa[x][i]) x=fa[x][i],dep-=(1<<i);\n    return x;\n}\nvoid solve(int x) {\n    int l=0,r=dep[x]-1,prt=-1;\n    while (l<=r) {\n        int mid=(l+r)>>1;\n        int up=UP(x,mid);\n        int S=get_sum(x,up);\n        if (S==0) {\n            prt=mid;\n            l=mid+1;\n        } else r=mid-1;\n    }\n    change(1,x,1);\n    printf(\"%d\\n\", prt+1);\n}\nint main(void) {\n    fill(lazy,-1);\n    scanf(\"%d\",&n);\n    rep(i,2,n) {\n        int x; scanf(\"%d\",&x); x++;\n        addEdge(i,x);\n    }\n    dep[1]=1; dfs1(1); dfs2(1,1);\n    scanf(\"%d\",&m);\n    while (m--) {\n        char opt[10]; scanf(\"%s\",opt);\n        int x; scanf(\"%d\",&x); x++;\n        if (opt[0]=='i') {\n            solve(x);\n        } else if (opt[0]=='u') {\n            printf(\"%d\\n\", query(1,1,n,pos[x],pos[x]+size[x]-1));\n            modify(1,1,n,pos[x],pos[x]+size[x]-1,0);\n        }\n    }\n}\n\n```",
        "postTime": 1515832976,
        "uid": 18867,
        "name": "jpwang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "## \u849f\u84bb\u7684\u9898\u89e3\n\u8fd9\u662f\u4e00\u9053\u5178\u578b\u7684\u6811\u94fe\u5256\u5206\u9898\n\n~~\u63d0\u4ea4\u4e00\u904d\u8fc7\uff0c\u672c\u5730\u8c03\u8bd5\u4e00\u4e07\u5e74\uff01~~\n\n\u5931\u8bef\u4e00\uff1a\n\n\u8f6f\u4ef6\u5305\u4ece0\u5f00\u59cb\u7f16\u53f7\uff0c\u5047\u5982\u5f3a\u5236\u4ece1\u5f00\u59cb\u5256\u5206\uff0c\u7136\u540e\u8981\u5bf9\u6240\u6709\u7684\u8f93\u5165\u90fd\u52a0\u4e00\uff0c\n\u4ee5\u53ca\u8be2\u95ee\uff0c\u7136\u540edfs1\u548cdfs2\u5c31\u53ef\u4ee5\u4ece1\u5f00\u59cb\u4e86\u3002\n\n\u5931\u8bef\u4e8c\uff1a\n\nlazy\u6807\u8bb0\u7684\u521d\u59cb\u5316\uff0c\u4e60\u60ef\u4e0a\u521d\u59cb\u5316\u4e860\uff0c\u7136\u540e\u5c31\u548c\u9898\u8bbe\u51b2\u7a81\u4e86\uff0cmemset\uff08\uff0c-1\uff0c\uff09\u5c31\u597d\u4e86\uff0c\u5f88\u8822\u7684\u9519\u8bef\u3002\n\n\u5931\u8bef\u4e09\uff1a\n\n\u8ba1\u7b97\u9519\u4e86\u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\u7684\u957f\u5ea6\uff0c\u5047\u5982\u8282\u70b9\u7684\u957f\u5ea6\u4e3alen\uff0c\u5219\u5de6\u513f\u5b50\u7684\u957f\u5ea6\u4e3alen-\uff08len>>1),\u53f3\u513f\u5b50\u957f\u5ea6\u4e3alen>>1,\u5176\u5b9e\u7528mid\u4f1a\u597d\u70b9\u3002\n\n\u5931\u8bef\u56db\uff1a\n\u8bb0\u5f55\u7a76\u7adf\u6539\u53d8\u4e86\u591a\u5c11\uff0c\u5176\u5b9e\u53ea\u8981\u770b\u4e00\u4e0b\u7ebf\u6bb5\u6811\u6839\u8282\u70b9\u7684\u5dee\u503c\u5c31\u597d\u4e86\uff0c\u6ca1\u6709\u5fc5\u8981\u5728\u9012\u5f52\u7684\u65f6\u5019\u8ba1\u7b97\u3002\n\n\u5931\u8bef\u4e94\uff1a\nid[top[u]]\u6c38\u8fdc<=id[u],\u7136\u540e\u4e00\u4e2a\u6811\u548c\u5b83\u7684\u513f\u5b50\u662fid[u]\u2014id[u]+size[u]-1;\n\n\u5931\u8bef\u516d\uff1a\n\ndfs2\u8fd9\u6837\u5199\u4f1a\u597d\u4e9b\uff0c\u56e0\u4e3a\u4e0d\u7528\u521d\u59cb\u5316\u6839\u8282\u70b9\n```cpp\nvoid dfs2(int u,int topf){\n\tid[u]=++cnt_d;\n\ttop[u]=topf;\n\tif(!son[u])return;\n\tdfs2(son[u],topf);\n\tint ee,v;\n\tfor(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)\n\t\tif(v!=fa[u]&&v!=son[u])\n\t\t\tdfs2(v,v);\n}\n```\n\u5931\u8bef7\uff1a\u7531\u4e8e\u9898\u76ee\u7684\u7279\u6b8a\u6027\uff0c\u66f4\u6539\u548c\u8be2\u95ee\u53ef\u4ee5\u4e00\u8d77\u8fdb\u884c\uff0c\u6765\u81ea\u540c\u673a\u623f\u5927\u4f6c\u7684\u64cd\u4f5c\u3002\n```\ninline void cqfa(int u){\n\tres=a[1];\n\twhile(top[u]!=1){\n\t\tchange(1,1,n,id[top[u]],id[u],1);\n\t\tu=fa[top[u]];\n\t}\n\tchange(1,1,n,id[top[u]],id[u],1);\n\tprintf(\"%d\\n\",abs(res-a[1]));\n}\ninline void cqson(int u){\n\tres=a[1];\n\tchange(1,1,n,id[u],id[u]+siz[u]-1,0);\n\tprintf(\"%d\\n\",abs(res-a[1]));\n}\nvoid pushdown(int o,int len){\n\tif(lazy[o]==1){\n\t\tlazy[lson]=1,a[lson]=len-(len>>1);\n\t\tlazy[rson]=1,a[rson]=len>>1;\n\t}else if(lazy[o]==0){\n\t\tlazy[lson]=0,a[lson]=0;\n\t\tlazy[rson]=0,a[rson]=0;\n\t}\n\tlazy[o]=-1;\n}\nvoid change(int o,int l,int r,int L,int R,int k){\n\tif(L<=l&&r<=R){\n\t\tlazy[o]=k;\n\t\ta[o]=k*(r-l+1);\n\t\treturn;\n\t}\n\tif(lazy[o]!=-1)\n\tpushdown(o,r-l+1);\n\tif(L<=mid)change(lson,l,mid,L,R,k);\n\tif(R>mid)change(rson,mid+1,r,L,R,k);\n\tpushup(o);\n}\n```\n\n------------\n\u4ee5\u4e0b\u90fd\u662f\u626f\u6de1\u3002\n\n~~\u5931\u8bef\u516b\uff1a\u53cc\u5411\u52a0\u8fb9\u4e0d\u8981\u5fd8\u4e86\uff0c\u5624\u5624\u5624\u3002~~\n\n~~\u5931\u8bef\u4e5d\uff1a\u5176\u5b9e\u4e0d\u7528build\u53bb\u5efa\u6811\uff0c\u56e0\u4e3a\u521d\u59cb\u90fd\u662f0\uff08\u6ed1\u7a3d\uff09~~\n\n\n------------\n\u968f\u7f18AC\u3002\n```cpp\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cmath>\n#define mid ((l+r)>>1)\n#define lson (o<<1)\n#define rson (o<<1|1)\n#define maxn 100100\nusing namespace std;\ninline int read(){\n\tregister int x=0,y=0;register char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')y=1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<3)+(x<<1)+(ch^48);\n\treturn y?-x:x;\n}\nstruct edge{\n\tint n,v;\t\n}e[maxn<<1];\nint first[maxn],cnt_e=0;\ninline void add_edge(int x,int y){\n\te[++cnt_e].n=first[x],first[x]=cnt_e,e[cnt_e].v=y;\n}\nstring k;\nint n,q,x;\nint son[maxn],fa[maxn],siz[maxn],dep[maxn];\nint id[maxn],top[maxn];\nint a[maxn<<2],lazy[maxn<<2];\nint res,cnt_d=0;\ninline voivoid pushdown(int o,int len){\n\tif(lazy[o]==1){\n\t\tlazy[lson]=1,a[lson]=len-(len>>1);\n\t\tlazy[rson]=1,a[rson]=len>>1;\n\t}else if(lazy[o]==0){\n\t\tlazy[lson]=0,a[lson]=0;\n\t\tlazy[rson]=0,a[rson]=0;\n\t}\n\tlazy[o]=-1;\n}\nvoid change(int o,int l,int r,int L,int R,int k){\n\tif(L<=l&&r<=R){\n\t\tlazy[o]=k;\n\t\ta[o]=k*(r-l+1);\n\t\treturn;\n\t}\n\tif(lazy[o]!=-1)\n\tpushdown(o,r-l+1);\n\tif(L<=mid)change(lson,l,mid,L,R,k);\n\tif(R>mid)change(rson,mid+1,r,L,R,k);\n\tpushup(o);\n}d pushup(int o){\n\ta[o]=a[lson]+a[rson];\n}\n\nvoid dfs1(int u,int f){\n\tfa[u]=f,dep[u]=dep[f]+1,siz[u]=1;\n\tint v,ee;\n\tfor(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)\n\t\tif(v!=f){\n\t\t\tdfs1(v,u);\n\t\t\tsiz[u]+=siz[v];\n\t\t\tif(siz[son[u]]<siz[v])\n\t\t\t\tson[u]=v;\n\t\t}\n}\ninline void cqfa(int u){\n\tres=a[1];\n\twhile(top[u]!=1){\n\t\tchange(1,1,n,id[top[u]],id[u],1);\n\t\tu=fa[top[u]];\n\t}\n\tchange(1,1,n,id[top[u]],id[u],1);\n\tprintf(\"%d\\n\",abs(res-a[1]));\n}\ninline void cqson(int u){\n\tres=a[1];\n\tchange(1,1,n,id[u],id[u]+siz[u]-1,0);\n\tprintf(\"%d\\n\",abs(res-a[1]));\n}\nvoid dfs2(int u,int topf){\n\tid[u]=++cnt_d;\n\ttop[u]=topf;\n\tif(!son[u])return;\n\tdfs2(son[u],topf);\n\tint ee,v;\n\tfor(ee=first[u];v=e[ee].v,ee;ee=e[ee].n)\n\t\tif(v!=fa[u]&&v!=son[u])\n\t\t\tdfs2(v,v);\n}\nsigned main(){\n\t\tn=read();\n\t\tfor(register int i=2;i<=n;++i)x=read(),++x,add_edge(x,i),add_edge(i,x);\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tmemset(lazy,-1,sizeof(lazy));\n\tq=read();\n\t\tfor(register int i=1;i<=q;++i){\n\t\t\tcin>>k;x=read();\n\t\t\tif(k==\"install\"){\n\t\t\t\tcqfa(x+1);\n\t\t\t}else if(k==\"uninstall\"){\n\t\t\t\tcqson(x+1);\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1573220529,
        "uid": 158869,
        "name": "\u76e7\u92c5",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# \u9898\u76ee\n\n[\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://www.luogu.org/problem/P2146)\n\n# \u9898\u89e3\n\n\u4e00\u9053`\u6811\u94fe\u5256\u5206`\u7684\u6a21\u677f\u9898\n\n\u521d\u59cb\u5316\u6240\u6709\u70b9\u7684\u6743\u503c\u4e3a$0$\n\n1.\u5b89\u88c5\u64cd\u4f5c\uff1a\u5c06\u5f53\u524d\u70b9\u5230\u6839\u8282\u70b9\u7684\u6240\u6709\u8282\u70b9\u6743\u503c\u7f6e\u4e3a$1$\n\n2.\u5378\u8f7d\u64cd\u4f5c\uff1a\u5c06\u4ee5\u5f53\u524d\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e0a\u7684\u6240\u6709\u8282\u70b9\u6743\u503c\u7f6e\u4e3a$0$\n\n\u5bf9\u4e8e\u6bcf\u6b21\u64cd\u4f5c\u540e\u7684\u67e5\u8be2\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5bf9\u64cd\u4f5c\u540e\u7684\u5b89\u88c5\u6570\u91cf\u548c\u64cd\u4f5c\u524d\u7684\u5b89\u88c5\u6570\u91cf\u6c42\u4e00\u4e2a\u5dee\u503c\u5373\u53ef\n\n# \u4ee3\u7801\n\n```cpp\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntemplate <typename T>\nT Max(T x, T y) {return x > y ? x : y;}\n\ntemplate <typename T>\nT Min(T x, T y) {return x < y ? x : y;}\n\ntemplate <typename T>\nT Fabs(T x) {return x < 0 ? -x : x;}\n\n#define LL long long\n\n#define lson x << 1\n#define rson x << 1 | 1\n\nconst int N = 100005;\n\nint n, x, q, cnt;\nint s[N], f[N], d[N], id[N], rk[N], son[N], top[N];\nchar a[10];\n\nstruct TREE {\n    int l, r, sum, lazy;\n};\nTREE tre[N << 2];\n\nvector <int> G[N];\n\nvoid build(int x, int l, int r) {\n    if(l == r) {\n        tre[x].l = l, tre[x].r = r, tre[x].lazy = -1;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    build(lson, l, mid);\n    build(rson, mid + 1, r);\n    tre[x].l = tre[lson].l, tre[x].r = tre[rson].r, tre[x].lazy = -1;\n}\n\nvoid putDown(int x) {\n    tre[lson].sum = (tre[lson].r - tre[lson].l + 1) * tre[x].lazy;\n    tre[rson].sum = (tre[rson].r - tre[rson].l + 1) * tre[x].lazy;\n    tre[lson].lazy =  tre[rson].lazy = tre[x].lazy;\n    tre[x].lazy = -1;\n}\n\nvoid update(int x, int l, int r, int y) {\n    if(tre[x].r < l || tre[x].l > r) return ;\n    if(tre[x].l >= l && tre[x].r <= r) {\n        tre[x].lazy = y;\n        tre[x].sum = (tre[x].r - tre[x].l + 1) * y;\n        return ;\n    }\n    if(tre[x].lazy != -1) putDown(x);\n    update(lson, l, r, y);\n    update(rson, l, r, y);\n    tre[x].sum = tre[lson].sum + tre[rson].sum;\n}\n\nvoid dfs1(int x, int fa) {\n    int siz = G[x].size();\n    for(int i = 0; i <= siz - 1; i ++) {\n        if(G[x][i] == fa) continue;\n        d[G[x][i]] = d[x] + 1;\n        f[G[x][i]] = x;\n        dfs1(G[x][i], x);\n        s[x] += s[G[x][i]];\n        if(s[G[x][i]] > s[son[x]]) son[x] = G[x][i];\n    }\n    s[x] ++;\n}\n\nvoid dfs2(int x, int fa, int _top) {\n    int siz = G[x].size();\n    top[x] = _top;\n    id[x] = ++ cnt;\n    rk[cnt] = x;\n    if(son[x] == 0) return ;\n    dfs2(son[x], x, _top);\n    for(int i = 0; i <= siz - 1; i ++) {\n        if(G[x][i] == fa || G[x][i] == son[x]) continue;\n        dfs2(G[x][i], x, G[x][i]);\n    }\n}\n\nvoid upEdge(int x, int y, int z) {\n    while(top[x] != top[y]) {\n        if(d[top[x]] > d[top[y]]) {\n            update(1, id[top[x]], id[x], z);\n            x = f[top[x]];\n        }\n        else {\n            update(1, id[top[y]], id[y], z);\n            y = f[top[y]];\n        }\n    }\n    if(d[x] > d[y])\n        update(1, id[y], id[x], z);\n    else\n        update(1, id[x], id[y], z);\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for(int i = 2; i <= n; i ++) {\n        scanf(\"%d\", &x);\n        G[x + 1].push_back(i);\n        G[i].push_back(x + 1);\n    }\n    scanf(\"%d\", &q);\n    d[1] = 1;\n    dfs1(1, -1);\n    dfs2(1, -1, 1);\n    build(1, 1, n);\n    while(q --) {\n        scanf(\"\\n%s%d\", a, &x);\n        x ++;\n        int last = tre[1].sum;\n        if(a[0] == 'i')\n            upEdge(1, x, 1);\n        else\n            update(1, id[x], id[x] + s[x] - 1, 0);\n        printf(\"%d\\n\", Fabs(tre[1].sum - last));\n    }\n    return 0;\n}\n```",
        "postTime": 1568872148,
        "uid": 105150,
        "name": "PI_AC",
        "ccfLevel": 0,
        "title": "[\u6811\u94fe\u5256\u5206] \u8f6f\u4ef6\u5305\u7ba1\u7406\u5668"
    },
    {
        "content": "## \u9898\u89e3\uff1a\n\n\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u9898\u3002\n\n\u5173\u4e8e\u6811\u94fe\u5256\u5206\u7684\u8bb2\u89e3\u8bf7\u6233\u8fd9\u91cc\uff1a\n\n[\u6d45\u8c08\u6811\u94fe\u5256\u5206](https://www.cnblogs.com/fusiwei/p/11519470.html)\n\n\u8fd9\u9053\u9898**\u96be\u70b9\u6709\u4e8c**\uff1a\n\n\u7b2c\u4e00\u4e2a\u662f\u8bfb\u9898\uff0c\u6211\u4eec\u5fc5\u987b\u5728\u8bfb\u9898\u4e4b\u540e\u660e\u767d\u8fd9\u662f\u4e00\u68f5\u6811\uff0c\u5e76\u4e14\u77e5\u9053\uff1a\u5b89\u88c5\u4e00\u4e2a\u8f6f\u4ef6\u5c31\u76f8\u5f53\u4e8e\u5b89\u88c5\u8fd9\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u6240\u6709\u672a\u88ab\u5b89\u88c5\u7684\u8f6f\u4ef6\u3002\u5378\u8f7d\u4e00\u4e2a\u8f6f\u4ef6\u5c31\u662f\u5378\u8f7d\u4ee5\u8fd9\u4e2a\u8f6f\u4ef6\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u7684\u6240\u6709\u8f6f\u4ef6\u3002\n\n\u7b2c\u4e8c\u4e2a\u662f\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\uff1a\u6211\u4eec\u77e5\u9053\u7ebf\u6bb5\u6811\u662f\u7528\u4e8e\u533a\u95f4\u64cd\u4f5c\u7684\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u90a3\u4e48\u8fd9\u9053\u9898\u7684\u533a\u95f4\u4fee\u6539\uff0c\u5728\u7ebf\u6bb5\u6811\u7684\u76f8\u5173\u9898\u578b\u4e2d\uff0c\u53c8\u6709\u4e00\u4e2a\u540d\u5b57\uff1a**\u533a\u95f4\u8d4b\u503c**\u3002\u9488\u5bf9\u4e8e\u8fd9\u79cd\u533a\u95f4\u8d4b\u503c\u7684\u7ebf\u6bb5\u6811\u7684\u9898\u76ee\uff0c\u6211\u4eec\u9700\u8981\u6ce8\u610f\u5efa\u6811\u548c\u6253lazy\u6807\u8bb0\u65f6\u7684\u76f8\u5173\u4fe1\u606f\u7684\u7ef4\u62a4\u3002\u6bd4\u5982\uff0c\u5efa\u6811\u7684\u65f6\u5019lazy\u6807\u8bb0\u8981\u7f6e\u6210-1\u3002\uff08\u8fd9\u4e2a\u65f6\u5019\u7684lazy\u6570\u7ec4\u5c5e\u4e8e\u6807\u8bb0\u6570\u7ec4\uff0c\u4f60\u613f\u610f\u7684\u8bdd\u53ea\u8981\u4e0d\u8bbe\u7f6e\u62101\u8bbe\u7f6e\u5565\u90fd\u884c\uff09pushdown\u7684\u65f6\u5019\u4e00\u5b9a\u8981\u5224\u4e00\u4e0b\u5f53\u524d\u7684lazy\u662f\u5426\u4e3a-1\uff01\uff08\u5982\u679c\u662f\u5c31\u4e0d\u80fd\u4e0b\u4f20\uff0c\u8981\u4e0d\u7136\u4f1a\u5bfc\u81f4\u4e0b\u4f20\u7684\u4e24\u4e2a\u5b50\u8282\u70b9\u7684lazy\u503c\u9519\u8bef\uff09\u3002\n\n\u5269\u4e0b\u7684\u5c31\u968f\u4fbf\u6572\u6572\u6a21\u677f\u5c31\u6210\u4e86\u3002\n\n\u4e0a\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define lson pos<<1\n#define rson pos<<1|1\nusing namespace std;\nconst int maxn=1e5+1;\nint n,q,tot,cnt;\nint head[maxn],nxt[maxn<<1],to[maxn<<1];\nint deep[maxn],fa[maxn],size[maxn],son[maxn];\nint id[maxn],top[maxn];\nint tree[maxn<<2],lazy[maxn<<2];\nchar s[100];\nvoid add(int x,int y)\n{\n    to[++tot]=y;\n    nxt[tot]=head[x];\n    head[x]=tot;\n}\nvoid dfs1(int x,int f)\n{\n    deep[x]=deep[f]+1;\n    fa[x]=f;\n    size[x]=1;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y==f)\n            continue;\n        dfs1(y,x);\n        size[x]+=size[y];\n        if(!son[x]||size[y]>size[son[x]])\n            son[x]=y;\n    }\n}\nvoid dfs2(int x,int t)\n{\n    top[x]=t;\n    id[x]=++cnt;\n    if(!son[x])\n        return;\n    dfs2(son[x],t);\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y==fa[x]||y==son[x])\n            continue;\n        dfs2(y,y);\n    }\n}\nvoid build(int pos,int l,int r)\n{\n    lazy[pos]=-1;\n    int mid=(l+r)>>1;\n    if(l==r)\n        return;\n    build(lson,l,mid);\n    build(rson,mid+1,r);\n}\nvoid mark(int pos,int l,int r,int k)\n{\n    tree[pos]=(r-l+1)*k;\n    lazy[pos]=k;\n}\nvoid pushdown(int pos,int l,int r)\n{\n    int mid=(l+r)>>1;\n    if(lazy[pos]==-1) return;  \n    mark(lson,l,mid,lazy[pos]);\n    mark(rson,mid+1,r,lazy[pos]);\n    lazy[pos]=-1;\n}\nvoid update(int pos,int l,int r,int x,int y,int k)\n{\n    int mid=(l+r)>>1;\n    if(x<=l && r<=y)\n    {\n        mark(pos,l,r,k);\n        return;\n    }\n    pushdown(pos,l,r);\n    if(x<=mid)\n        update(lson,l,mid,x,y,k);\n    if(y>mid)\n        update(rson,mid+1,r,x,y,k);\n    tree[pos]=tree[lson]+tree[rson];\n}\nvoid upd_chain(int x,int y,int k)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]])\n            swap(x,y);\n        update(1,1,n,id[top[x]],id[x],k);\n        x=fa[top[x]];\n    }\n    if(deep[x]<deep[y])\n        swap(x,y);\n    update(1,1,n,id[y],id[x],k);\n}\nvoid upd_subtree(int x,int k)\n{\n    update(1,1,n,id[x],id[x]+size[x]-1,k);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=2;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);x++;\n        add(x,i);\n        add(i,x);\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,n);\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        int x;\n        int t=tree[1];\n        scanf(\"%s\",s+1);\n        scanf(\"%d\",&x);x++;\n        if(s[1]=='i')\n        {\n            upd_chain(1,x,1);\n            printf(\"%d\\n\",abs(t-tree[1]));\n        }\n        else\n        {\n            upd_subtree(x,0);\n            printf(\"%d\\n\",abs(t-tree[1]));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1568722445,
        "uid": 175131,
        "name": "\u5085\u601d\u7ef4666",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\n\u8fd9\u5176\u5b9e\u662f\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u677f\u9898\uff0c\u96be\u5728\u8bfb\u9898...\n\n\u501f\u4e00\u4e0b\u6d1b\u8c37\u7684\u56fe\uff1a\uff08\u5c06\u8fb9\u770b\u6210\u65e0\u5411\u7684\uff09\n\n![](https://cdn.luogu.com.cn/upload/pic/1504.png)\n\n\u5982\u679c\u7406\u89e3\u4e86\u9898\u76ee\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\uff1a\n\n1.\u5b89\u88c5\u4e00\u4e2a\u8f6f\u4ef6$u$\u9700\u8981\u5c06$u$\u53f7\u8f6f\u4ef6\u5230$0$\u53f7\u8f6f\u4ef6\u7684\u8def\u5f84\u4e0a\u6240\u6709\u672a\u5b89\u88c5\u7684\u8f6f\u4ef6\u5b89\u88c5\u3002\n\n2.\u5220\u9664\u4e00\u4e2a\u8f6f\u4ef6$u$\u9700\u8981\u5c06\u4ee5$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e0a\u6240\u6709\u5b89\u88c5\u7684\u8f6f\u4ef6\u5220\u9664\u3002\n\n\u5176\u5b9e\u5b83\u4eec\u5206\u522b\u662f\u8def\u5f84\u4fee\u6539\u548c\u5b50\u6811\u4fee\u6539\uff0c\u6811\u94fe\u5256\u5206\u540e\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u5b89\u88c5\u7684\u8f6f\u4ef6\u4e2a\u6570\u5c31\u597d\u4e86\u3002\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <iostream>\nusing namespace std;\n#define ls x << 1\n#define rs x << 1 | 1\n#define INF 0x3f3f3f3f\n\nconst int MAXN = 100000;\nint n , q , cnt;\nint Fa[ MAXN + 5 ] , Size[ MAXN + 5 ] , Depth[ MAXN + 5 ] , Heaviest_son[ MAXN + 5 ];\nint Dfn[ MAXN + 5 ] , Top[ MAXN + 5 ] , Rank[ MAXN + 5 ];\nvector< int > Graph[ MAXN + 5 ];\n\nstruct Point{\n\tint l , r , num , Lazy;\n};\nstruct Segment_Tree{\n\tPoint Tree[ 4 * MAXN + 5 ];\n\tvoid Build( int x , int l , int r ) {\n\t\tTree[ x ].l = l , Tree[ x ].r = r , Tree[ x ].Lazy = -1 , Tree[ x ].num = 0;\n\t\tif( l == r )\n\t\t\treturn;\n\t\tint Mid = ( l + r ) / 2;\n\t\tBuild( ls , l , Mid );\n\t\tBuild( rs , Mid + 1 , r );\n\t}\n\tvoid Pushdown( int x ) {\n\t\tif( Tree[ x ].Lazy == 0 ) {\n\t\t\tTree[ ls ].num = Tree[ rs ].num = 0;\n\t\t\tTree[ ls ].Lazy = Tree[ rs ].Lazy = 0;\n\t\t\tTree[ x ].Lazy = -1;\n\t\t}\n\t\tif( Tree[ x ].Lazy == 1 ) {\n\t\t\tTree[ ls ].num = ( Tree[ ls ].r - Tree[ ls ].l + 1 );\n\t\t\tTree[ rs ].num = ( Tree[ rs ].r - Tree[ rs ].l + 1 );\n\t\t\tTree[ ls ].Lazy = Tree[ rs ].Lazy = 1;\n\t\t\tTree[ x ].Lazy = -1;\n\t\t}\n\t}\n\tvoid Insert( int x , int l , int r , int k ) {\n\t\tif( r < Tree[ x ].l || Tree[ x ].r < l ) \n\t\t\treturn;\n\t\tif( l <= Tree[ x ].l && Tree[ x ].r <= r ) {\n\t\t\tTree[ x ].num = k ? ( Tree[ x ].r - Tree[ x ].l + 1 ) : 0;\n\t\t\tTree[ x ].Lazy = k; \n\t\t\treturn;\n\t\t}\n\t\tPushdown( x );\n\t\tInsert( ls , l , r , k );\n\t\tInsert( rs , l , r , k );\n\t\tTree[ x ].num = ( Tree[ ls ].num + Tree[ rs ].num );\n\t}\n\tint Find( int x , int l , int r ) {\n\t\tif( r < Tree[ x ].l || Tree[ x ].r < l ) \n\t\t\treturn 0;\n\t\tif( l <= Tree[ x ].l && Tree[ x ].r <= r )\n\t\t\treturn Tree[ x ].num;\n\t\tPushdown( x );\n\t\treturn Find( ls , l , r ) + Find( rs , l , r );\n\t}\n\t\n\tint Query_ins( int u , int v ) {\n\t\tint Ans = 0;\n\t\twhile( Top[ u ] != Top[ v ] ) {\n\t\t\tif( Depth[ Top[ u ] ] < Depth[ Top[ v ] ] )\n\t\t\t\tswap( u , v );\n\t\t\tAns += ( Depth[ u ] - Depth[ Top[ u ] ] + 1 ) - Find( 1 , Dfn[ Top[ u ] ] , Dfn[ u ] );\n\t\t\tInsert( 1 , Dfn[ Top[ u ] ] , Dfn[ u ] , 1 );\n\t\t\t\n\t\t\tu = Fa[ Top[ u ] ];\n\t\t}\n\t\tif( Depth[ u ] > Depth[ v ] )\n\t\t\tswap( u , v );\n\t\tAns += ( Depth[ v ] - Depth[ u ] + 1 ) - Find( 1 , Dfn[ u ] , Dfn[ v ] );\n\t\tInsert( 1 , Dfn[ u ] , Dfn[ v ] , 1 );\n\t\treturn Ans;\n\t}\n\tint Query_uni( int u ) {\n\t\tint Ans = Find( 1 , Dfn[ u ] , Dfn[ u ] + Size[ u ] - 1 );\n\t\tInsert( 1 , Dfn[ u ] , Dfn[ u ] + Size[ u ] - 1 , 0 );\n\t\treturn Ans;\n\t}\n}Tree;\n\nvoid dfs1( int u , int fa ) {\n\tFa[ u ] = fa , Depth[ u ] = Depth[ fa ] + 1 , Size[ u ] = 1;\n\t\n\tfor( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {\n\t\tint v = Graph[ u ][ i ];\n\t\tif( v == fa ) continue;\n\t\tdfs1( v , u );\n\t\tSize[ u ] += Size[ v ];\n\t\tif( Size[ Heaviest_son[ u ] ] < Size[ v ] )\n\t\t\tHeaviest_son[ u ] = v;\n\t}\n}\nvoid dfs2( int u , int top ) {\n\tTop[ u ] = top , Dfn[ u ] = ++ cnt , Rank[ cnt ] = u;\n\t\n\tif( !Heaviest_son[ u ] ) return;\n\tdfs2( Heaviest_son[ u ] , top );\n\tfor( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {\n\t\tint v = Graph[ u ][ i ];\n\t\tif( !Dfn[ v ] ) dfs2( v , v );\n\t}\n}\n\nint u , v;\nchar op[ 20 ];\nint main( ) {\n\tscanf(\"%d\",&n);\n\tfor( int i = 2 ; i <= n ; i ++ ) {\n\t\tscanf(\"%d\",&v);v ++;\n\t\tGraph[ i ].push_back( v );\n\t\tGraph[ v ].push_back( i );\n\t}\n\tdfs1( 1 , 0 );\n\tdfs2( 1 , 1 );\n\t\n\tTree.Build( 1 , 1 , n );\n\tscanf(\"%d\",&q);\n\tfor( int i = 1 ; i <= q ; i ++ ) {\n\t\tscanf(\"%s %d\",op,&u);u ++;\n\t\tif( op[ 0 ] == 'i' )\n\t\t\tprintf(\"%d\\n\", Tree.Query_ins( 1 , u ) );\n\t\tif( op[ 0 ] == 'u' )\n\t\t\tprintf(\"%d\\n\", Tree.Query_uni( u ) );\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1568539528,
        "uid": 123802,
        "name": "chihik",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# \u7a76\u6781\u6811\u5256 \u6bc1\u6211\u9752\u6625\u4e4b\u65c5\u884c\n\n\n------------\n\u770b\u5230\u9898\u76ee\uff0c\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u6309\u7167\u4fe1\u4ef0\u6765\u5efa\u6811\uff0c\u6bcf\u4e00\u4e2a\u4fe1\u4ef0\u5efa\u4e00\u68f5\u6811\uff0c\u5f53\u7136\u80af\u5b9a\u4e0d\u80fd\u7b80\u7b80\u5355\u5355\u7684\u5efa\u6811\u3002\u8fd9\u91cc\u6211\u4eec\u8981\u7528\u5230**\u4e3b\u5e2d\u6811**\u7684\u6982\u5ff5\uff0cPS\uff1a\u8fd9\u91cc\u4e0d\u4f1a\u4e3b\u5e2d\u6811\u7684\u540c\u5b66\u53ef\u4ee5\u95ee\u4e0b\u5ea6\u5a18\u3002\n\u4f46\u662f\u4e3a\u4ec0\u4e48\u8bf4\u5b83\u662f\u4f2a\u4e3b\u5e2d\u6811\u5462\uff1f\u8fd9\u662f\u56e0\u4e3a\u4e3b\u5e2d\u6811\u6bcf\u6b21\u64cd\u4f5c\u90fd\u4f1a\u7ed9\u5f53\u524d\u64cd\u4f5c\u8fc7\u540e\u5efa\u4e00\u4e2a\u65b0\u6811\uff0c\u800c\u8fd9\u91cc\u4e0d\u4e00\u6837\uff0c\u6bd4\u5982\u6211\u4eec\u5c06x\u57ce\u5e02\u7684\u5c45\u6c11\u7684\u4fe1\u4ef0\u6539\u4e3ay\uff0c**\u6211\u4eec\u53ea\u9700\u8981\u5728x\u57ce\u5e02\u539f\u6765\u6240\u5728\u7684\u6811\u5185\uff0c\u51cf\u53bb\u5b83\u7684\u8bc4\u7ea7w**\uff0c\u7136\u540e\u5728\u4fe1\u4ef0y\u8fd9\u68f5\u6811\u5185\uff0c\u5c06x\u57ce\u5e02\u6dfb\u52a0\u8fdb\u53bb\u5373\u53ef\u3002\n\u6240\u4ee5\u8fd9\u4e2a\u5f88\u5bb9\u6613\u8ddf\u4e3b\u5e2d\u6811\u6df7\u6dc6\uff01\uff01\uff01\uff01\uff01\uff01\n\n------------\n\u5269\u4e0b\u7684\u67e5\u8be2\u5c31\u5f88\u7b80\u5355\u5566\uff0c\u76f4\u63a5\u7528lca\u7684\u65b9\u5f0f\u8fdb\u884c\u67e5\u8be2\u5c31OK\u4e86\u3002\n\u4e0b\u9762\u8d34\u4ee3\u7801\uff08\u56e0\u4e3a\u5b66\u6821oj\u7684\u95ee\u9898\u6211\u628aDFS\u5199\u6210\u4e86\u975e\u9012\u5f52\u7684\u5f62\u5f0f\uff0c\u5982\u679c\u4f60\u7528\u9012\u5f52\u7684DFS\u5728\u6d1b\u8c37\u662f\u53ef\u4ee5\u8fc7\u7684\uff01\uff01\uff01)\n\n\n\n------------\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <stack>\n#define N 200005\nusing namespace std;\n \nint n,m,w[N],c[N],head[N];\nstruct edge\n{\n\tint y,next;\n}s[N];\n\nint root[N],fa[N],seg[N],rev[N],dep[N],size[N],son[N],top[N],vis[N],sk[N];\nint mmax[N * 10],ls[N * 10],rs[N * 10],sum[N * 10];\nint tx,ty,ans,op,x,y,d,v,len = 0,cnt;\n\nvoid ins(int x,int y)\n{\n\tlen++;\n\ts[len].y = y; s[len].next = head[x]; head[x] = len;\n}\n \nint read()\n{\n\tchar c; int res,f = 1;\n\twhile ((c = getchar()) > '9' || c < '0') if (c == '-') f = -1;\n\tres = c - 48;\n\twhile ((c = getchar()) >= '0' && c <= '9') res = res * 10 + c - 48;\n\treturn res * f;\n}\n\nvoid BFS()\n{\n\tstack <int> f;\n\tf.push(1); vis[1] = 1; dep[1] = 1; fa[1] = 0;\n\tfor (int i = 1; i <= n; i++) size[i] = 1;\n\twhile (!f.empty())\n\t{\n\t\tint x = f.top(); sk[++cnt] = x; f.pop();\n\t\tfor(int i = head[x]; i != 0; i = s[i].next)\n\t\t{\n\t\t\tint y = s[i].y;\n\t\t\tif (!vis[y])\n\t\t\t{\n\t\t\t\tdep[y] = dep[x] + 1;\n\t\t\t\tvis[y] = 1;\n\t\t\t\tfa[y] = x;\n\t\t\t\tf.push(y);\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (cnt)\n\t{\n\t\tint x = sk[cnt]; cnt--;\n\t\tfor(int i = head[x]; i != 0; i = s[i].next)\n\t\tif (fa[x] != s[i].y)\n\t\t{\n\t\t\tsize[x] += size[s[i].y];\n\t\t\tif (size[son[x]] < size[s[i].y]) son[x] = s[i].y;\n\t\t}\n\t}\n}\n\nvoid bfs()\n{\n\tstack <int> q,f;\n\tq.push(1); f.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint x = q.top(),y = f.top(); f.pop(); q.pop();\n\t\tseg[x] = ++seg[0]; top[x] = y;\n\t\n\t\tfor(int i = head[x]; i != 0; i = s[i].next)\n\t\t\tif (!top[s[i].y] && son[x] != s[i].y)\n\t\t\t\tq.push(s[i].y),f.push(s[i].y);\n\t\t\n\t\tif (son[x])\n\t\t\tq.push(son[x]),f.push(y);\n\t}\n}\n\nvoid change(int &now,int l,int r)\n{\n\tif(!now) now = ++len;\n\tsum[now] += d;\n\tif(l==r) \n\t{\n\t\tif(d > 0) mmax[now] = d;\n\t\telse mmax[now] = 0;\n\t\treturn ;\n\t}\n\tint mid = l + r >> 1;\n\tif(v <= mid) change(ls[now],l,mid);\n\telse change(rs[now],mid + 1,r);\n\tmmax[now] = max(mmax[ls[now]],mmax[rs[now]]);\n}\n \nvoid change_c()\n{\n\tx = read(); y = read();\n\tv = seg[x]; d = -w[x];\n\tchange(root[c[x]],1,n);\n\tc[x] = y; d = w[x];\n\tchange(root[c[x]],1,n);\n}\n \nvoid change_w()\n{\n\tx = read(); y = read();\n\tv = seg[x]; d = -w[x];\n\tchange(root[c[x]],1,n);\n\tw[x] = y; d = w[x];\n\tchange(root[c[x]],1,n);\n}\n \nint query_sum(int now,int l,int r,int x,int y)\n{\n\tif(x == l && y == r) return sum[now];\n\tint mid = x + y >> 1;\n\tif(r <= mid) return query_sum(ls[now],l,r,x,mid);\n\telse if(mid < l) return query_sum(rs[now],l,r,mid + 1,y);\n\telse return query_sum(ls[now],l,mid,x,mid)+query_sum(rs[now],mid + 1,r,mid + 1,y);\n}\n \nint lca_sum()\n{\n\tx = read(); y = read();\n\top = x;\n\ttx = top[x]; ty = top[y];\n\tans = 0;\n\twhile(tx != ty)\n\t{\n\t\tif(dep[tx] > dep[ty])\n\t\t{\n\t\t\tswap(x,y);swap(tx,ty);\n\t\t}\n\t\tans += query_sum(root[c[op]],seg[ty],seg[y],1,n);\n\t\ty = fa[ty]; ty = top[y];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\tans += query_sum(root[c[op]],seg[x],seg[y],1,n);\n\treturn ans;\n}\n \nint query_max(int now,int l,int r,int x,int y)\n{\n\tif(x == l && y == r) return mmax[now];\n\tint mid = x + y >> 1;\n\tif(r <= mid) return query_max(ls[now],l,r,x,mid);\n\tif(mid < l) return query_max(rs[now],l,r,mid + 1,y);\n\treturn max(query_max(ls[now],l,mid,x,mid),query_max(rs[now],mid + 1,r,mid + 1,y));\n}\n \nint lca_max()\n{\n\tx = read(); y = read();\n\top = x;\n\ttx = top[x]; ty = top[y];\n\tans = 0;\n\twhile(tx != ty)\n\t{\n\t\tif(dep[tx] > dep[ty])\n\t\t{\n\t\t\tswap(x,y);swap(tx,ty);\n\t\t}\n\t\tans = max(ans,query_max(root[c[op]],seg[ty],seg[y],1,n));\n\t\ty = fa[ty]; ty = top[y];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\tans = max(ans,query_max(root[c[op]],seg[x],seg[y],1,n));\n\treturn ans;\n}\n \nint main()\n{\n\tn = read(); m = read();\n\tfor(int i = 1; i <= n; i++) w[i] = read(),c[i] = read();\n\tfor(int i = 1; i <= n - 1; i++)\n\t{\n\t\tx = read(); y = read();\n\t\tins(x,y);\n\t\tins(y,x);\n\t}\n\tBFS();\n\tlen = 0;\n\tbfs();\n\tlen = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tv = seg[i]; d = w[i];\n\t\tchange(root[c[i]],1,n);\n\t}\n\tchar ch[10];\n\twhile(m--)\n\t{\n\t\tscanf(\"%s\",ch);\n\t\tif(ch[1] == 'C') change_c();\n\t\telse if(ch[1] == 'W') change_w();\n\t\telse if(ch[1] == 'S') printf(\"%d\\n\",lca_sum());\n\t\telse if(ch[1] == 'M') printf(\"%d\\n\",lca_max());\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1565666362,
        "uid": 45056,
        "name": "Komes",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://zgjjj.github.io/2019/07/17/Luogu-P2146-NOI2015-%E8%BD%AF%E4%BB%B6%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8-%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/)\n\n\n![](https://i.loli.net/2019/07/17/5d2f025c5513d85813.png)\n\n\u8fd9\u662f$\\color{black} \\mathbf {w} \\color{red} \\mathbf {jyyy} $\u55e6\u7684$\\uparrow$\n\n\n\n# \u9898\u76ee\u94fe\u63a5\n\n[**P2146** [NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://www.luogu.org/problemnew/show/P2146) \n\n# \u9898\u610f\u7b80\u8ff0\n\n\u7ed9\u4f60\u4e00\u68f5\u6811\uff0c\u6709\u70b9\u6743\u3002\u5c06\u70b9\u6743\u8d4b\u503c\u4e3a1\u9700\u8981\u5c06\u6839\u5230\u8be5\u70b9\u8def\u5f84\u4e0a\u6240\u6709\u70b9\u8d4b\u503c\u4e3a\uff0c\u5c06\u70b9\u6743\u8d4b\u503c\u4e3a0\u4f1a\u4f7f\u4ee5\u8be5\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e0a\u7684\u6240\u6709\u70b9\u70b9\u6743\u53d8\u4e3a0\u3002\u521d\u59cb\u65f6\u6240\u6709\u70b9\u70b9\u6743\u4e3a0\uff0c\u7ed9\u4f60m\u4e2a\u8d4b\u503c\u64cd\u4f5c\uff0c\u8f93\u51fa\u6bcf\u4e2a\u64cd\u4f5c\u4f1a\u6539\u53d8\u591a\u5c11\u4e2a\u70b9\u7684\u72b6\u6001\u3002\n\n# \u89e3\u9898\u601d\u60f3\n\n\u53d1\u73b0\u6811\u7684\u5f62\u6001\u6ca1\u6709\u6539\u53d8\uff0c\u6211\u4eec\u8003\u8651\u6811\u5256\u3002\u7136\u540e\u6c42\u51fa\u6839\u5230\u67d0\u4e2a\u70b9\u7684\u94fe\u7684\u957f\u5ea6\u548c\u67d0\u4e2a\u70b9\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u4f46\u662f\u6211\u4eec\u53d1\u73b0\u8fd9\u91cc\u9762\u662f\u533a\u95f4\u8d4b\u503c\u64cd\u4f5c\uff0c\u800c\u4e0d\u662f\u533a\u95f4\u589e\u52a0\u64cd\u4f5c\uff0c\u5982\u679c\u5355\u4e2a\u70b9\u505a\u6548\u7387\u6781\u4f4e\uff0c\u6211\u4eec\u8003\u8651\u4e00\u79cd\u65b0\u7684\u7ebf\u6bb5\u6811\uff1a\n\n## \u533a\u95f4\u8986\u76d6\u7ebf\u6bb5\u6811\n\n\u6211\u4eec\u8003\u8651\u5728\u533a\u95f4\u589e\u7ebf\u6bb5\u6811\u7684\u57fa\u7840\u4e0a\u5c06**\u589e\u52a0**\u6539\u6210**\u8d4b\u503c**\u3002\n\n\u4e8e\u662f\u6211\u4eec\u5c06`tag[]`\u7ef4\u62a4\u7684\u4fe1\u606f\u7531\u589e\u91cf\u6539\u4e3a\u8d4b\u503c\u6570\uff0c\u53d1\u73b0\u6839\u636e\u65f6\u95f4\u7684\u5148\u540e\uff0c\u8fd9\u4e2a\u4fe1\u606f\u4f1a\u88ab\u9010\u6b65**\u66ff\u4ee3**\uff0c\u4e8e\u662f\u5c31\u53ef\u4ee5\u5728\u4e0b\u653e\u7684\u65f6\u5019**\u76f4\u63a5\u7528\u7236\u8282\u70b9\u6807\u8bb0\u76d6\u4f4f\u5b50\u8282\u70b9\u6807\u8bb0**\uff0c\u5373\u628a`+=`\u6539\u4e3a`=`\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5**\u6574\u4e2a\u533a\u95f4**\u8d4b\u503c\u4e3a**\u540c\u4e00\u4e2a\u6570**\u3002\n\n\u6ce8\u610f\u4e00\u4e0b\u9898\u76ee\u4e2d\u6709\u8d4b\u503c\u4e3a`0`\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5`tag[]`\u7684\u521d\u503c**\u4e0d\u80fd**\u4e3a0\uff0c\u5426\u5219\u5c31\u4f1a\u51fa\u9505\u3002\uff08\u5361\u4e86\u6211\u4e00\u4e0b\u5348\n\n# \u53c2\u8003\u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n\nnamespace FastIO {\n    inline int read() {\n        char ch = getchar(); int r = 0, w = 1;\n        while(!isdigit(ch)) {if(ch == '-') w = -1; ch = getchar();}\n        while(isdigit(ch)) {r = r * 10 + ch - '0', ch = getchar();}\n        return r * w;\n    }\n    void _write(int x) {\n        if(x < 0) putchar('-'), x = -x;\n        if(x > 9) _write(x / 10);\n        putchar(x % 10 + '0');\n    }\n    inline void write(int x) {\n        _write(x);\n        puts(\"\");\n    }\n}\n\nusing namespace FastIO;\n\nconst int N = 100010;\nconst int M = N << 1;\n\ntemplate <typename T> inline void swap(T &x, T &y) {T tmp = x; x = y, y = tmp;}\ntemplate <typename T> inline T min(T a, T b) {return a < b ? a : b;}\ntemplate <typename T> inline T max(T a, T b) {return a > b ? a : b;}\n\nint n, q, w[N];\nint head[N], nxt[M], ver[M], cnt, idx;\nint d[N], sz[N], fa[N], tp[N], son[N];\nint dfn[N], ptn[N];\nint val[N << 2], tag[N << 2];\n\n#define ls (o << 1)\n#define rs (o << 1 | 1)\n#define mid ((l + r) >> 1)\n\ninline void upd(int o) {\n    val[o] = val[ls] + val[rs];\n}\n\ninline void pushdown(int o, int l, int r) {\n    if(tag[o] != -1) {\n        tag[ls] = tag[o];\n        tag[rs] = tag[o];\n        val[ls] = tag[o] * (mid - l + 1);\n        val[rs] = tag[o] * (r - mid);\n    }\n    tag[o] = -1;\n}\n\nvoid build(int o, int l, int r) {\n    if(l == r) {val[o] = w[ptn[l]]; return;}\n    build(ls, l, mid);\n    build(rs, mid + 1, r);\n    upd(o);\n}\n\nvoid modify(int o, int l, int r, int ll, int rr, int k) {\n    if(l >= ll && r <= rr) {\n        val[o] = k * (r - l + 1);\n        tag[o] = k;\n        return;\n    }\n    pushdown(o, l, r);\n    if(ll <= mid) modify(ls, l, mid, ll, rr, k);\n    if(rr > mid) modify(rs, mid + 1, r, ll, rr, k);\n    upd(o);\n}\n\nint query(int o, int l, int r, int ll, int rr) {\n    if(l >= ll && r <= rr) return val[o];\n    pushdown(o, l, r);\n    int res = 0;\n    if(ll <= mid) res += query(ls, l, mid, ll, rr);\n    if(rr > mid) res += query(rs, mid + 1, r, ll, rr);\n    return res;\n}\n\nvoid add(int x, int y) {\n    ver[++cnt] = y, nxt[cnt] = head[x], head[x] = cnt;\n    ver[++cnt] = x, nxt[cnt] = head[y], head[y] = cnt;\n}\n\nvoid dfs1(int x) {\n    sz[x] = 1;\n    for(register int i = head[x]; i; i = nxt[i]) {\n        int y = ver[i];\n        if(y == fa[x]) continue;\n        fa[y] = x;\n        d[y] = d[x] + 1;\n        dfs1(y);\n        sz[x] += sz[y];\n        if(sz[y] > sz[son[x]]) son[x] = y;\n    }\n}\n\nvoid dfs2(int x, int top) {\n    tp[x] = top;\n    dfn[x] = ++idx;\n    ptn[idx] = x;\n    if(son[x]) dfs2(son[x], top);\n    for(register int i = head[x]; i; i = nxt[i]) {\n        int y = ver[i];\n        if(y == fa[x] || y == son[x]) continue;\n        dfs2(y, y);\n    }\n}\n\ninline void changeline(int x, int y, int z) {\n    while(tp[x] != tp[y]) {\n        if(d[tp[x]] > d[tp[y]]) swap(x, y);\n        modify(1, 1, n, dfn[tp[y]], dfn[y], z);\n        y = fa[tp[y]];\n    }\n    if(d[x] > d[y]) swap(x, y);\n    modify(1, 1, n, dfn[x], dfn[y], z);\n}\n\ninline int queryline(int x, int y) {\n    int res = 0;\n    while(tp[x] != tp[y]) {\n        if(d[tp[x]] > d[tp[y]]) swap(x, y);\n        res += query(1, 1, n, dfn[tp[y]], dfn[y]);\n        y = fa[tp[y]];\n    }\n    if(d[x] > d[y]) swap(x, y);\n    res += query(1, 1, n, dfn[x], dfn[y]);\n    return res;\n}\n\ninline void changetree(int x, int z) {\n    modify(1, 1, n, dfn[x], dfn[x] + sz[x] - 1, z);\n}\n\ninline int querytree(int x) {\n    return query(1, 1, n, dfn[x], dfn[x] + sz[x] - 1);\n}\n\nchar s[10];\n\nint main() {\n    memset(tag, -1, sizeof(tag));\n    n = read();\n    for(register int i = 2; i <= n; i++) {\n        add(read() + 1, i);\n    }\n    dfs1(1);\n    dfs2(1, 1);\n    build(1, 1, n);\n    q = read();\n    for(register int i = 1; i <= q; i++) {\n        scanf(\"%s\", s);\n        register int x = read() + 1;\n        int num = val[1];\n        if(s[0] == 'i') {\n            changeline(1, x, 1);\n            write(val[1] - num);\n        }\n        else {\n            changetree(x, 0);\n            write(num - val[1]);\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1563363074,
        "uid": 104841,
        "name": "Minakami_Yuki",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 [NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668"
    },
    {
        "content": "### \u9898\u76ee\u63cf\u8ff0  \n\u9898\u9762\u6bd4\u8f83\u5570\u5506\uff0c\u6211\u5148\u628a\u5927\u4f53\u610f\u601d\u8bb2\u4e00\u4e0b:  \n\n\u9996\u5148\uff0c\u6709\u7f16\u53f7\u4ece$0$\u5230$N-1$\u7684$N$\u4e2a\u8282\u70b9\uff0c\u6839\u8282\u70b9\u4e00\u5b9a\u662f$0$\u53f7\u8282\u70b9(\u65e0\u524d\u9a71)  \n(\u6211\u628a\u4e0b\u6807\u90fd\u52a0\u4e0a\u4e86\u4e00\uff0c\u8f6c\u5316\u4e3a\u4ee5$1$\u4e3a\u8d77\u59cb\u4e0b\u6807\u7684\u70b9\u96c6\uff0c\u90a3\u4e48\u6839\u8282\u70b9\u7f16\u53f7\u4e3a$1$\uff0c\u6ce8\u610f\u4e00\u4e0b)  \n\u8f93\u5165\u4f1a\u7ed9\u5b9a\u6839\u8282\u70b9\u4ee5\u5916\u7684\u8282\u70b9\u7684\u524d\u9a71\uff0c\u5373\u7236\u8282\u70b9\u7f16\u53f7\u3002  \n\n\u8fd8\u6709$M$\u6b21\u64cd\u4f5c\uff1a  \n\n+  $install:$ \u6839\u636e\u9898\u610f\u4e5f\u5c31\u662f**\u5c06\u7ed9\u5b9a\u7684\u8282\u70b9$x$\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u6743\u503c\u8d4b\u503c\u4e3a$1$**\n+  $uninstall:$ \u6839\u636e\u9898\u610f\u4e5f\u5c31\u662f**\u5c06\u4ee5\u7ed9\u5b9a\u7684\u8282\u70b9$x$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u6743\u503c\u8d4b\u503c\u4e3a$0$**  \n\n\u770b\u5230\u8fd9\u91cc\u5c31\u5f88\u663e\u7136\uff0c\u8fd9\u662f\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u9898\u3002  \n\n----\n\n### \u57fa\u672c\u601d\u8def  (\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811)\n\u65e2\u7136\u662f\u6a21\u677f\u9898\uff0c\u601d\u8def\u5c31\u5f88\u7b80\u5355\u4e86\uff0c\u6811\u5256\u4e4b\u540e\u52a0\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002(\u4e0d\u8fc7\u8fd8\u662f\u6709\u70b9\u5751\u70b9\u7684...)\n\n----\n\n### \u7ec6\u8282\u6ce8\u610f\u4e8b\u9879\n\u63a5\u4e0b\u6765\u5c31\u662f\u5173\u4e8e\u8fd9\u9053\u9898\u7684\u51e0\u4e2a\u5751\u70b9\u3002   \n#### \u5751\u70b9\u4e00\uff1a\u70b9\u4e0b\u6807\u51fa\u9505  \n\u8fd9\u91cc\u6211\u4e4b\u524d\u4e5f\u6709\u63d0\u5230\uff0c\u5c24\u5176\u662f\u5728\u8f93\u5165\u65f6\uff0c\u4e0b\u9762\u6211\u628a\u4e24\u79cd\u8f93\u5165\u65b9\u5f0f\u7684\u6b63\u786e\u5199\u6cd5\u90fd\u8bf4\u4e00\u4e0b\uff1a  \n\n\u4ee5$0$\u4e3a\u4e0b\u6807\uff0c\u8fd9\u610f\u5473\u7740\u4f60\u7684\u8f93\u5165\u662f\u4ece\u4e0b\u6807$1$\u5230$N-1$\u7684\uff0c\u6240\u4ee5\u8981\u8fd9\u6837\u5199\uff1a  \n```cpp\n    for(rg int x,i=1;i<=n-1;i++) x=read();//\u8fd9\u91cc\u4e3b\u8981\u53ea\u8bf4\u4e0b\u6807\u5904\u7406\uff0c\u8fde\u8fb9\u4ec0\u4e48\u7684\u89c1\u8be6\u7ec6\u4ee3\u7801\n```\n\u4ee5$1$\u4e3a\u4e0b\u6807\u5219\u662f\uff1a\n```cpp\n    for(rg int x,i=2;i<=n;i++) x=read();\n```\n\u8fd9\u91cc\u6211\u6709\u4e00\u70b9\u68c0\u9a8c\u65b9\u6cd5\uff0c\u8fd8\u662f\u6bd4\u8f83\u5b9e\u7528\u7684\uff0c\u6bd5\u7adf\u4e0b\u6807\u7684\u5904\u7406\u662f\u5f88\u57fa\u672c\u800c\u53c8\u91cd\u8981\u7684\uff1a  \n\n1.  \u8bd5\u7740\u901a\u8fc7\u4f60\u7684for\u5faa\u73af\u7b97\u4e00\u4e0b\u4f60\u7684\u5faa\u73af\u6b21\u6570\n1.  \u786e\u4fdd\u4f60\u7684\u5faa\u73af\u53d8\u91cf$i$(\u6216\u5176\u4ed6\u53d8\u91cf\u540d)\u7684\u5faa\u73af\u8d77\u70b9  \n\n\u8fd9\u6837\u7684\u8bdd\u6709\u53ef\u4ee5\u9002\u5f53\u907f\u514d\u4e0b\u6807\u51fa\u9505\u95ee\u9898(\u6211\u5c31\u662f\u56e0\u4e3a\u4e0b\u6807\u95ee\u9898\u5361\u4e86\u5341\u591a\u5206\u949f\uff0c\u6cea\u7684\u6559\u8bad\u554a$qwq$)  \n\n#### \u5751\u70b9\u4e8c\uff1a\u7ebf\u6bb5\u6811\u4fee\u6539\u5b50\u8282\u70b9\u4fe1\u606f(\u6807\u8bb0\u4e0b\u4f20)\u51fa\u9505  \n\u5728\u6b64\u7bc7\u9898\u89e3\u7684\u5f00\u59cb\u6211\u4fbf\u7528\u7c97\u4f53\u5f3a\u8c03\u4e86\uff0c\u8fd9\u91cc\u518d\u8bf4\u4e00\u6b21\uff1a  \n**\u6bcf\u6b21\u64cd\u4f5c\u662f\u5728\u8d4b\u503c\uff0c\u4e5f\u5c31\u662f\u8986\u76d6\u4e4b\u524d\u7684\u4fe1\u606f(\u8fd9\u4e5f\u6b63\u662f\u9009\u62e9\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u800c\u4e0d\u662f\u5206\u5757\u7b49\u6570\u636e\u7ed3\u6784\u7684\u7406\u7531)**  \n\u5177\u4f53\u4ee3\u7801\u5b9e\u73b0\u53ef\u4ee5\u770b\u4e00\u4e0b\u6211\u5199\u7684\uff1a  \n```cpp\n    inline void f(int rt,int l,int r,int v){\n    //rt\u4e3a\u5f53\u524d\u63a5\u53d7\u4fe1\u606f\u7684\u7ebf\u6bb5\u6811\u8282\u70b9\u7f16\u53f7\n    //l\u4e3a\u8be5\u8282\u70b9\u5305\u542b\u533a\u95f4\u7684\u5de6\u7aef\u70b9\uff0cr\u4e3a\u53f3\u7aef\u70b9\n    //v\u4e3a\u7236\u8282\u70b9\u7684lazy tag\u503c\n        tag[rt]=v,sum[rt]=v*(r-l+1);//\u8be5\u9898\u6b63\u786e\u5199\u6cd5\n        /*tag[rt]+=v,sum[rt]+=v*(r-l+1)*/\n        //\u4e00\u822c\u5199\u6cd5\uff0c\u533a\u522b\u5c31\u5728\u4e8e+=\u548c=\uff0c\u5c0f\u5c0f\u7684=\u5c31\u5e2e\u6211\u4eec\u5b9e\u73b0\u4e86\u8986\u76d6\u64cd\u4f5c\n    }\n    inline void pushdown(int rt,int l,int r,int mid){\n    \t//\u7531\u4e8e\u6d89\u53ca\u5230\u8d4b\u4e3a0\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u7528\u4e86-1\u8868\u793alazy tag\u4e3a\u7a7a\u7684\u72b6\u6001\n    \tif(tag[rt]!=-1){\n            f(lc(rt),l,mid,tag[rt);\n            f(rc(rt),mid+1,r,tag[rt]);\n            tag[rt]=-1;\n        }\n    }\n```\n#### \u5751\u70b9\u4e09\uff1a\u8f93\u51fa\u51fa\u9505  \n\u5176\u5b9e\u8fd9\u4e00\u70b9\u8fd8\u662f\u6bd4\u8f83\u597d\u5904\u7406\u7684\uff0c\u4e0d\u8fc7\u6211\u7b2c\u4e00\u6b21\u8fd8\u662f\u6ca1\u6709\u76f4\u63a5\u5199\u5bf9(\u8fd8\u662f\u6d89\u53ca\u5230\u8bfb\u9898\u7684\u95ee\u9898)  \n\u9898\u76ee\u662f\u8fd9\u6837\u8bf4\u7684\uff1a  \n>\n\u8f93\u51fa\u6587\u4ef6\u7684\u7b2c$i$\u884c\u8f93\u51fa$1$\u4e2a\u6574\u6570\uff0c\u4e3a\u7b2c$i$\u6b65\u64cd\u4f5c\u4e2d**\u6539\u53d8\u5b89\u88c5\u72b6\u6001**\u7684\u8f6f\u4ef6\u5305\u6570\u3002  \n\n\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u6bcf\u6b21\u8f93\u51fa\u7684\u662f\u53d8\u5316\u91cf\u800c\u5e76\u975e\u64cd\u4f5c\u540e\u7684\u603b\u6570\uff0c\u5177\u4f53\u5b9e\u73b0\u7684\u8bdd\u53ea\u9700\u8981\u5728\u6bcf\u6b21\u64cd\u4f5c\u524d\u4e8b\u5148\u8bb0\u5f55\u4e00\u4e0b\u603b\u91cf$t_1$\uff0c\u518d\u8bb0\u5f55\u4e00\u4e0b\u6bcf\u6b21\u64cd\u4f5c\u5b8c\u540e\u7684\u65b0\u7684\u603b\u91cf$t_2$\uff0c\u8f93\u51fa$\\vert t_1-t_2 \\vert$\u5373\u53ef(\u6ce8\u610f\u6362\u884c...)  \n\n#### \u53c2\u8003\u4ee3\u7801\n\u4e0b\u9762\u8d34\u4e0a\u849f\u84bb\u7684\u4ee3\u7801\u3002\u3002\u3002  \n```cpp\n#include<cstdio>\n#include<algorithm>\n#define rg register\nconst int MAXN=100010;\nusing namespace std;\ninline int read(){\n    int s=0;bool f=false;char c=getchar();\n    while(c<'0'||c>'9')f|=(c=='-'),c=getchar();\n    while(c>='0'&&c<='9')s=(s<<3)+(s<<1)+(c^48),c=getchar();\n    return (f)?(-s):(s);\n}\nint n,m;\nint tot,head[MAXN],nxt[MAXN],ver[MAXN];\ninline void Add_edge(int u,int v){\n    nxt[++tot]=head[u],head[u]=tot,ver[tot]=v;\n}\nint sum[MAXN<<2],tag[MAXN<<2];\ninline int lc(int rt){return rt<<1;}\ninline int rc(int rt){return rt<<1|1;}\ninline void pushup(int rt){\n    sum[rt]=sum[lc(rt)]+sum[rc(rt)];\n}\ninline void f(int rt,int l,int r,int v){\n    tag[rt]=v,sum[rt]=v*(r-l+1);\n}\ninline void pushdown(int rt,int l,int r,int mid){\n    if(tag[rt]!=-1){\n        f(lc(rt),l,mid,tag[rt]);\n        f(rc(rt),mid+1,r,tag[rt]);\n        tag[rt]=-1;\n    }\n}\ninline void update(int rt,int l,int r,int x,int y,int v){\n    if(l>y||r<x) return;\n    if(x<=l&&r<=y) return f(rt,l,r,v);\n    int mid=(l+r)>>1;\n    pushdown(rt,l,r,mid);\n    update(lc(rt),l,mid,x,y,v);\n    update(rc(rt),mid+1,r,x,y,v);\n    pushup(rt);\n}\ninline int query(int rt,int l,int r,int x,int y){\n    if(l>y||r<x) return 0;\n    if(x<=l&&r<=y) return sum[rt];\n    int mid=(l+r)>>1;\n    pushdown(rt,l,r,mid);\n    return query(lc(rt),l,mid,x,y)+query(rc(rt),mid+1,r,x,y);\n}\nint top[MAXN],seg[MAXN];\nint dep[MAXN],siz[MAXN],son[MAXN],father[MAXN];\ninline void dfs1(int u,int fa){\n    siz[u]=1;\n    father[u]=fa;\n    dep[u]=dep[fa]+1;\n    for(rg int v,i=head[u];i;i=nxt[i])\n        if(!dep[v=ver[i]]){\n            dfs1(v,u),siz[u]+=siz[v];\n            if(siz[v]>siz[son[u]]) son[u]=v;\n        }\n}\ninline void dfs2(int u,int topf){\n    top[u]=topf;\n    seg[u]=++seg[0];\n    if(!son[u]) return;\n    dfs2(son[u],topf);\n    for(rg int v,i=head[u];i;i=nxt[i])\n        if(!top[v=ver[i]]) dfs2(v,v);\n}\ninline void uptRange(int x,int y,int v){\n    int fx=top[x],fy=top[y];\n    while(fx!=fy){\n        if(dep[fx]>dep[fy]){\n            update(1,1,n,seg[fx],seg[x],v);\n            x=father[fx],fx=top[x];\n        }\n        else{\n            update(1,1,n,seg[fy],seg[y],v);\n            y=father[fy],fy=top[y];\n        }\n    }\n    if(dep[x]<dep[y])\n        update(1,1,n,seg[x],seg[y],v);\n    else\n        update(1,1,n,seg[y],seg[x],v);\n}\ninline void uptSon(int x,int v){\n    update(1,1,n,seg[x],seg[x]+siz[x]-1,v);\n}\nint main(){\n    n=read();\n    for(rg int fa,i=2;i<=n;i++)\n        fa=read()+1,Add_edge(fa,i);\n    fill(sum+1,sum+n+1,0);\n    fill(tag+1,tag+n+1,-1);\n    //fill \u8fd9\u4e2a\u51fd\u6570\u662falgorithm\u5e93\u91cc\u7684\u4e00\u4e2a\u51fd\u6570\uff0c\u7528\u6cd5\u4e0esort\u7c7b\u4f3c\uff0c\u7528\u4e8e\u5b9e\u73b0\u6570\u7ec4\u7684\u521d\u59cb\u5316\n    //\u4e4b\u6240\u4ee5\u6ca1\u5199memset\u662f\u56e0\u4e3a\u4e00\u5f00\u59cb\u4ee5\u4e3a\u4e0d\u80fd\u7528memset\u521d\u59cb\u5316\u8d1f\u6570\uff0c\u4e0d\u8fc7\u597d\u50cf\u53ef\u4ee5\uff1f\n    dfs1(1,0);\n    dfs2(1,1);\n    m=read();\n    char s[20];\n    for(rg int i=1;i<=m;i++){\n        scanf(\"%s\",s);\n        int x=read()+1;\n        int t1=sum[1];\n        if(s[0]=='i'){\n            uptRange(x,1,1);\n            printf(\"%d\\n\",abs(t1-sum[1]));\n        }\n        else{\n            uptSon(x,0);\n            printf(\"%d\\n\",abs(t1-sum[1]));\n        }\n    }\n    return 0;\n}\n```\n\u5b8c\u7ed3\u6492\u82b1$qwq$",
        "postTime": 1560256931,
        "uid": 87839,
        "name": "Sangber",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\n\u53ef\u4ee5\u7b97\u4f5c\u6811\u5256\u7684\u6a21\u7248\u9898\uff0c\u4ee3\u7801\u5f88\u597d\u6253\uff0c\u4f46\u5751\u70b9\u6709\u4e8c\n\n1. \u6700\u597d\u4ece\u4e00\u5f00\u59cb\u6807\u53f7\uff0c\u4ece0\u5f00\u59cb\u4f1a\u6709\u4e00\u4e9b\u4e0d\u4fbf\uff08bug\uff09\n1. \u4e0d\u8981\u75280\u8868\u793a\u61d2\u6807\u8bb0\u4e0d\u5b58\u5728\uff0c\u5982\u679c\u61d2\u6807\u8bb0\u4e3a0\u6211\u4eec\u8fd8\u662f\u8981\u4e0b\u4f20\u7684\uff0c\u61d2\u6807\u8bb0\u7684\u521d\u503c\u8981\u4e3a-1\n\n\n------------\n\n```c\n//\u9047\u5230\u8fd9\u79cd\u9898\u6700\u597d\u4ece1\u5f00\u59cb\u6807\u53f7\u6bd4\u8f83\u65b9\u4fbf \n#include<bits/stdc++.h>\nusing namespace std;\n#define go(i,a,b) for(int i=(a);i<=(b);++(i))\n#define com(i,a,b) for(int i=(a);i>=(b);--(i))\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define inf 0x3f3f3f3f\n#define fin freopen(\"input.txt\",\"r\",stdin)\n#define fout freopen(\"output.txt\",\"w\",stdout)\n#define lson rt<<1\n#define rson rt<<1|1\nconst int maxn=100005;\nvector<int>g[maxn];\nchar s[15];\ntypedef int aray[maxn];\naray dep,son,siz,f,dfn,top;\nint cnt=0;\nstruct tree{\n\tint sum,laz,l,r;\n}t[maxn<<2];\n//-1\u8868\u793a\u4e0d\u5b58\u5728\u61d2\u6807\u8bb0\uff0c0\u8868\u793a\u5b58\u5728\u5220\u9664\u6807\u8bb0\uff0c1\u8868\u793a\u5b58\u5728\u5b89\u88c5\u6807\u8bb0 \n\nvoid read(int &x){\n    int f=1;char s=getchar();x=0;\n    while(!isdigit(s)){\n    \tif(s=='-') f=-1;s=getchar();\n    }\n    while(isdigit(s)){\n   \t\tx=(x<<3)+(x<<1)+s-'0';s=getchar();\n    }\n    x*=f;\n}//\u8bfb\u5165\u4f18\u5316\n\nvoid dfs(int u,int fa){\n\tdep[u]=dep[fa]+1,f[u]=fa,siz[u]=1;\n\tint n=g[u].size()-1;\n\tgo(i,0,n){\n\t\tint v=g[u][i];\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]]) son[u]=v;\n\t\t//\u56e0\u4e3ason\u7684\u521d\u503c\u4e3a0\uff0c\u6240\u4ee5size\u662f\u6709\u521d\u503c\u7684\uff0c\u5751\u4e86\u6211\u597d\u4e45 \n\t}\n}\n\nvoid dfs2(int u,int t){\n\tdfn[u]=++cnt;top[u]=t;\n\tif(!son[u]) return;\n\tdfs2(son[u],t);\n\tint n=g[u].size()-1;\n\tgo(i,0,n){\n\t\tint v=g[u][i];\n\t\tif(v==f[u]||v==son[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\n\nvoid pushdown(int rt){\n\tif(t[rt].laz+1){\n\tt[lson].laz=t[rson].laz=t[rt].laz;\n\tt[lson].sum=(t[lson].r-t[lson].l+1)*t[rt].laz;\n\tt[rson].sum=(t[rson].r-t[rson].l+1)*t[rt].laz;\n\tt[rt].laz=-1;\n\t}\n}\n\nvoid pushup(int rt){\n\tt[rt].sum=t[lson].sum+t[rson].sum;\n}\n\nvoid update(int rt,int x,int y,int val){\n\tif(t[rt].l>=x&&t[rt].r<=y){\n\t\tt[rt].sum=(t[rt].r-t[rt].l+1)*val;\n\t\tt[rt].laz=val;\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tint mid=(t[rt].l+t[rt].r)>>1;\n\tif(x<=mid) update(lson,x,y,val);\n\tif(y>mid) update(rson,x,y,val);\n\tpushup(rt);\n}\n\nvoid add(int x,int val){\n\tif(val){\n\twhile(top[x]!=top[1]){\n\t\tupdate(1,dfn[top[x]],dfn[x],val);\n\t\tx=f[top[x]];\n\t}\n\tupdate(1,dfn[1],dfn[x],val);\n\t}\n\telse{\n\t\tupdate(1,dfn[x],dfn[x]+siz[x]-1,val);\n\t}\n}\n\nvoid build(int rt,int l,int r){\n\tt[rt]=(tree){0,-1,l,r};\n\tif(l==r) return;\n\tint mid=(t[rt].l+t[rt].r)>>1;\n\tbuild(lson,l,mid);\n\tbuild(rson,mid+1,r);\n}\n\nint main()\n{\n    //fin;fout;\n    int n;read(n);\n    int u;\n    go(i,2,n){\n    \tread(u);u++;\n\t\tg[u].push_back(i);g[i].push_back(u);\n\t}\n\tdfs(1,0);dfs2(1,1);\t\n\tbuild(1,1,cnt);\n\tint q;\n\tread(q);int x;\n\tint ans;\n\tgo(i,1,q){\n\t\tscanf(\"%s\",s);read(x);x++;\n\t\tans=t[1].sum;\n\t\tif(s[0]=='i'){\n\t\t\tadd(x,1);\n\t\t\tprintf(\"%d\\n\",abs(ans-t[1].sum));\n\t\t}\n\t\telse if(s[0]=='u'){\n\t\t\tadd(x,0);\n\t\t\tprintf(\"%d\\n\",abs(ans-t[1].sum));\n\t\t}\n\t}\n    return 0;\n}\n```\n",
        "postTime": 1554519556,
        "uid": 109434,
        "name": "\u98ce\u968f\u9010\u5f71",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u8fd9\u4e2a\u9898\u5462\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a**\u88f8\u7684\u6811\u5256**\uff0c\u53ea\u662f\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\u6709\u90a3\u4e48\u4e00\u70b9\u70b9\u4e0d\u540c\u800c\u5df2\n\n\u5982\u679c\u6ca1\u6709\u88ab\u5361\u8bfb\u9898\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\uff1a\n\n1\u3001\u5b89\u88c5\u4e00\u4e2a\u8f6f\u4ef6\u5305\u662f\u6307\u628a\u6839\u5230\u8be5\u8f6f\u4ef6\u5305\u7ed3\u70b9\u5168\u90e8\u5237\u62101\uff08\u5f53\u7136\u61d2\u6807\u8bb0\u662f\u8981\u7528\u7684\uff09\n\n2\u3001\u5378\u8f7d\u4e00\u4e2a\u8f6f\u4ef6\u5305\u662f\u6307\u628a\u4ee5\u8fd9\u4e2a\u8f6f\u4ef6\u5305\u7ed3\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u5168\u90e8\u5237\u62100\uff08\u61d2\u6807\u8bb0\u63a5\u7740\uff09\n\n\u4f46\u662f\u8fd8\u6ca1\u5b8c\uff0c\u56e0\u4e3a\u6709\u4e00\u4e9b\u91cd\u8981\u7684\u4e8b\u8981\u8bf4\u2014\u2014\u56e0\u4e3a\u662f\u5237\u6807\u8bb0\uff0c**\u6240\u4ee5\u4e0d\u662f\u7b80\u5355\u7684\u6c42\u548c**\uff1b\u540c\u65f6**\u61d2\u6807\u8bb0\u65e0\u8bba\u662f0\u8fd8\u662f1\u90fd\u662f\u6709\u610f\u4e49\u7684**\u6240\u4ee5\u8981\u9009\u53e6\u4e00\u4e2a\u57fa\u51c6\uff08\u6bd4\u5982\u6211\u7528\u7684\u6781\u5927\u503c\uff09\u6765\u8868\u793a\u61d2\u6807\u8bb0\u6ca1\u6709\u610f\u4e49\n\n\u597d\u4e86\u5c31\u8fd9\u4e48\u591a\uff0c\u76f8\u4fe1\u5927\u4f6c\u4eec\u6ce8\u610f\u4e00\u4e0b\u7ec6\u8282\u4fbf\u80fd\u5149\u901fAK\n\n```cpp\n#include<bits/stdc++.h>\n#define indx seg[0]\nusing namespace std;\n\nint n,q;\nint head[200005],siz;\nint dep[100005],fa[100005],top[100005],size[100005],son[100005],seg[100005],pos[100005];\nint sum[100005<<2],lazy[100005<<2];\nstruct node{\n\tint nxt,to;\n}edge[200005];\n\nvoid adde(int from,int to){\n\tsiz++;\n\tedge[siz].nxt=head[from];\n\tedge[siz].to=to;\n\thead[from]=siz;\n}\n\nvoid prepare(int cur,int pa){\n\tdep[cur]=dep[pa]+1;fa[cur]=pa;size[cur]=1;\n\tfor(int i=head[cur];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;if(v==pa)continue;\n\t\tprepare(v,cur);size[cur]+=size[v];\n\t\tif(size[v]>size[son[cur]])son[cur]=v;\n\t}\n}\n\nvoid has(int cur,int pa){\n\tif(son[pa]==cur)top[cur]=top[pa];\n\telse top[cur]=cur;seg[cur]=++indx;\n\tpos[indx]=cur;if(son[cur])has(son[cur],cur);\n\tfor(int i=head[cur];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;if(v==pa||v==son[cur])continue;\n\t\thas(v,cur);\n\t}\n}\n\nvoid push(int l,int r,int id){\n\tint m=(l+r)>>1;\n\tlazy[id<<1]=lazy[id<<1|1]=lazy[id];\n\tsum[id<<1]=(m-l+1)*lazy[id];sum[id<<1|1]=(r-m)*lazy[id];\n\tlazy[id]=INT_MAX;\n}\n\nint getsum(int x,int y,int l,int r,int id){\n\tif(x<=l&&r<=y)return sum[id];\n\tif(lazy[id]==1||lazy[id]==0)push(l,r,id);\n\tint m=(l+r)>>1,ans=0;\n\tif(x<=m)ans+=getsum(x,y,l,m,id<<1);\n\tif(y>m)ans+=getsum(x,y,m+1,r,id<<1|1);\n\treturn ans;\n}\n\nint query(int u,int v){\n\tint ans=0;\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]])swap(u,v);\n\t\tans+=getsum(seg[top[u]],seg[u],1,indx,1);\n\t\tu=fa[top[u]];\n\t}\n    if(dep[u]<dep[v])swap(u,v);\n\treturn ans+getsum(seg[v],seg[u],1,indx,1);\n}\n\nvoid adde(int x,int y,int l,int r,int id,int k){\n\tif(x<=l&&r<=y){\n\t\tlazy[id]=k;\n\t\tsum[id]=(r-l+1)*k;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(lazy[id]==1||lazy[id]==0)push(l,r,id);\n\tif(x<=m)adde(x,y,l,m,id<<1,k);\n\tif(y>m)adde(x,y,m+1,r,id<<1|1,k);\n\tsum[id]=sum[id<<1]+sum[id<<1|1];\n}\n\nvoid change(int u,int v,int k){\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]])swap(u,v);\n\t\tadde(seg[top[u]],seg[u],1,indx,1,k);\n\t\tu=fa[top[u]];\n\t}\n    if(dep[u]<dep[v])swap(u,v);\n\tadde(seg[v],seg[u],1,indx,1,k);\n}\n\nint main(){\n\t//freopen(\"in.txt\",\"r\",stdin);\n\tmemset(lazy,0x7f,sizeof(lazy));\n\tscanf(\"%d\",&n);\n\tfor(int i=2,x;i<=n;i++){//\u624b\u52a8\u6539\u7f16\u53f7 \n\t\tscanf(\"%d\",&x);\n\t\tadde(i,x+1);\n\t\tadde(x+1,i);\n\t}\n\tprepare(1,0);\n\thas(1,0);\n\tscanf(\"%d\",&q);\n\tfor(int i=1,x;i<=q;i++){\n\t\tchar s[20];scanf(\"%s %d\\n\",s,&x);\n\t\tif(s[0]=='i'){\n\t\t\tint cur=query(1,x+1);\n\t\t\tchange(1,x+1,1);\n\t\t\tprintf(\"%d\\n\",query(1,x+1)-cur);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",getsum(seg[x+1],seg[x+1]+size[x+1]-1,1,indx,1));\n\t\t\tadde(seg[x+1],seg[x+1]+size[x+1]-1,1,indx,1,0);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1552010821,
        "uid": 109396,
        "name": "Uniecho1",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u4e2d\uff0c\u5982\u679c\u628a\u4f9d\u8d56\u5173\u7cfb\u5efa\u6210\u4e00\u68f5\u6811\uff0c\u5c31\u4f1a\u53d1\u73b0\uff1a\n\n1. \u5bf9\u4e8e\u5b89\u88c5\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u628ax\u5230\u6839\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u8986\u76d6\u4e3a1\uff1b\n\n2. \u5bf9\u4e8e\u5378\u8f7d\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u628ax\u7684\u5b50\u6811\u4e2d\u6240\u6709\u70b9\u8986\u76d6\u4e3a0\uff1b\n\n3. \u5e76\u4e14\uff0c\u56e0\u4e3a\u9898\u4e2d\u76f4\u63a5\u7ed9\u4e86\u5404\u4e2a\u70b9\u7684\u7236\u5b50\u5173\u7cfb\uff0c\u5efa\u6811\u65f6\u76f4\u63a5\u5efa\u5355\u5411\u8fb9\u5373\u53ef\uff0c\u4e3a\u4e86\u65b9\u4fbfdfs\uff0c\u6211\u9009\u62e9\u4ece\u7236\u4eb2\u5230\u513f\u5b50\u5efa\u8fb9\u3002\n\n\n\u53d1\u73b0\u8fd9\u70b9\u4e4b\u540e\uff0c\u5c31\u8ba9\u6211\u6765BeO\u4e00\u53d1\u5427.\n\n\u65e2\u7136\u540c\u65f6\u7528\u5230\u8def\u5f84\u4fee\u6539\u548c\u5b50\u6811\u4fee\u6539\uff0c\u53ef\u89c1\u8fd9\u662f\u6811\u5256\u7b97\u6cd5\u3002\n\n\u56e0\u4e3a\u8981\u7528\u5230\u533a\u95f4\u4fee\u6539\uff0c\u7ebf\u6bb5\u6811\u4e2d\u9700\u8981\u5ef6\u8fdf\u6807\u8bb0\u3002\u6211\u7684\u6807\u8bb0\u89c4\u5219\u5982\u4e0b\uff1a\n\n- la=0\uff1a\u65e0\u6807\u8bb0\uff1b\n\n- la=1\uff1a\u533a\u95f4\u8986\u76d6\u4e3a1\uff1b\n\n- la=-1\uff1a\u533a\u95f4\u8986\u76d6\u4e3a0\n\n### \u6ce8\u610f\u4f4e\u7ea7\u5931\u8bef\uff1a\n\n\u6211\u7684\u7b97\u6cd5\u4e2d\uff0c\u7ebf\u6bb5\u6811\u533a\u95f4\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u6811\u5256\u5f97\u5230\u7684idx\u6570\u7ec4\u503c\u4e5f\u8981\u4ece0\u5f00\u59cb\uff08**\u6211\u5c31\u56e0\u4e3a\u8fd9\u4e2aWA\u6389\u4e8616\u4e2a\u70b9**\uff0c\u4e4b\u540e\u5bf9\u62cd\u624d\u77e5\u9053\uff1a\u7ebf\u6bb5\u6811\u533a\u95f4\u8d8a\u754c\u4e86\u3002\u8fd9\u4e5f\u5370\u8bc1\u4e86\u4e00\u70b9\uff1a\u8c03\u8bd5\u4ee3\u7801\u7684\u65f6\u95f4\u901a\u5e38\u548c\u6240\u72af\u9519\u8bef\u7684\u611a\u8822\u7a0b\u5ea6\u6210\u6b63\u6bd4\uff09\n\nAC\u4ee3\u7801\uff1a\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define maxn 8192000\nint n;\nstruct node //\u94fe\u661f\u5b58\u8fb9 \n{\n    int to;\n    int nxt;\n}nd[maxn];\nint head[maxn],cnt;\nint idx[maxn],fa[maxn],dep[maxn],siz[maxn],son[maxn],top[maxn],cut;\n/*\n\u6811\u5256\uff1a\nidx\uff1a\u91cd\u65b0\u7f16\u53f7\u540e\u7684\u70b9\u7f16\u53f7\nfa\uff1ax\u7684\u7236\u4eb2\ndep\uff1ax\u7684\u6df1\u5ea6\uff08\u6839\u7684\u6df1\u5ea6\u4e3a0\uff09\nsiz\uff1ax\u7684\u5b50\u6811\u5927\u5c0f\nson\uff1ax\u7684\u91cd\u513f\u5b50\ntop\uff1ax\u6240\u5728\u91cd\u94fe\u9876\u7aef\u70b9\u7f16\u53f7 \n*/\nstruct point\n{\n    int val;\n    int la;\n}tr[4*maxn];\n/*\n\u7ebf\u6bb5\u6811\uff1a\nval\uff1a\u533a\u95f4\u6c42\u548c\nla\uff1a\u533a\u95f4\u8986\u76d6\u6807\u8bb0 \n*/\nint q;\nchar str[32];\nint x;\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    cnt=1;\n    return;\n}\nvoid add(int x,int y)\n{\n    nd[cnt].to=y;\n    nd[cnt].nxt=head[x];\n    head[x]=cnt++;\n    return;\n}\nint dfs1(int x,int rt)//\u6811\u5256\u7b2c\u4e00\u6b21dfs \n{\n    fa[x]=rt;\n    siz[x]=1;\n    int mxs=-1;\n    for(int i=head[x];i!=-1;i=nd[i].nxt)\n    {\n        int t=nd[i].to;\n        dep[t]=dep[x]+1;\n        siz[x]+=dfs1(t,x);\n        if(siz[t]>mxs)\n        {\n            mxs=siz[t];\n            son[x]=t;\n        }\n    }\n    return siz[x];\n}\nvoid dfs2(int x,int tp)//\u6811\u5256\u7b2c\u4e8c\u6b21dfs \n{\n    idx[x]=cut++;\n    top[x]=tp;\n    if(son[x]==-1)\n    {\n        return;\n    }\n    dfs2(son[x],tp);\n    for(int i=head[x];i!=-1;i=nd[i].nxt)\n    {\n        int t=nd[i].to;\n        if(!idx[t])\n        {\n            dfs2(t,t);\n        }\n    }\n    return;\n}\nvoid addt(int L,int R,int l,int r,int rt,int m)//\u533a\u95f4\u8986\u76d6\u4e3a1 \n{\n    if(L<=l&&R>=r)\n    {\n        tr[rt].la=1;\n        tr[rt].val=r-l+1;\n        return;\n    }else\n    {\n        int mid=(l+r)/2;\n        if(tr[rt].la==1)\n        {\n            tr[rt<<1].la=1;\n            tr[rt<<1|1].la=1;\n            tr[rt<<1].val=(m-(m>>1));\n            tr[rt<<1|1].val=(m>>1);\n            tr[rt].la=0;\n        }else if(tr[rt].la==-1)\n        {\n            tr[rt<<1].la=-1;\n            tr[rt<<1|1].la=-1;\n            tr[rt<<1].val=0;\n            tr[rt<<1|1].val=0;\n            tr[rt].la=0;\n        }\n        if(L<=mid)\n        {\n            addt(L,R,l,mid,rt<<1,m-(m>>1));\n        }\n        if(R>mid)\n        {\n            addt(L,R,mid+1,r,rt<<1|1,m>>1);\n        }\n        tr[rt].val=tr[rt<<1].val+tr[rt<<1|1].val;\n    }\n    return;\n}\nvoid del(int L,int R,int l,int r,int rt,int m)//\u533a\u95f4\u8986\u76d6\u4e3a0 \n{\n    if(L<=l&&R>=r)\n    {\n        tr[rt].la=-1;\n        tr[rt].val=0;\n        return;\n    }else\n    {\n        int mid=(l+r)/2;\n        if(tr[rt].la==1)\n        {\n            tr[rt<<1].la=1;\n            tr[rt<<1|1].la=1;\n            tr[rt<<1].val=(m-(m>>1));\n            tr[rt<<1|1].val=(m>>1);\n            tr[rt].la=0;\n        }else if(tr[rt].la==-1)\n        {\n            tr[rt<<1].la=-1;\n            tr[rt<<1|1].la=-1;\n            tr[rt<<1].val=0;\n            tr[rt<<1|1].val=0;\n            tr[rt].la=0;\n        }\n        if(L<=mid)\n        {\n            del(L,R,l,mid,rt<<1,m-(m>>1));\n        }\n        if(R>mid)\n        {\n            del(L,R,mid+1,r,rt<<1|1,m>>1);\n        }\n        tr[rt].val=tr[rt<<1].val+tr[rt<<1|1].val;\n    }\n    return;\n}\nvoid addc(int x,int y)//\u8def\u5f84\u8986\u76d6\u4e3a1 \n{\n    while(top[x]!=top[y]&&x!=-1&&y!=-1)\n    {\n        if(dep[top[x]]<dep[top[y]])\n        {\n            swap(x,y);\n        }\n        addt(idx[top[x]],idx[x],0,n-1,1,n);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])\n    {\n        swap(x,y);\n    }\n    addt(idx[x],idx[y],0,n-1,1,n);\n    return;\n}\nint main()\n{\n    init();\n    memset(son,-1,sizeof(son));\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        int a;\n        scanf(\"%d\",&a);\n        add(a,i);\n    }\n    dfs1(0,-1);\n    dfs2(0,0);\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        scanf(\"%s%d\",str,&x);\n        if(str[0]=='i')\n        {\n            int ans=tr[1].val;\n            addc(0,x);\n            printf(\"%d\\n\",tr[1].val-ans);\n        }else\n        {\n            int ans=tr[1].val;\n            del(idx[x],idx[x]+siz[x]-1,0,n-1,1,n);\n            printf(\"%d\\n\",ans-tr[1].val);\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1549511211,
        "uid": 158849,
        "name": "renhr2002",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u6765\u53d1\u9898\u89e3\n\n\u6c34\u7684\u4e0d\u80fd\u5728\u6c34\u4e86\uff0c\u7b80\u76f4\u5c31\u662f\u6811\u94fe\u5256\u5206\u88f8\u9898\n\n\u9898\u76ee\u8981\u6c42\uff1a\u5199\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u67e5\u8be2\u5f53\u524d\u8282\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u4e3a0\u7684\u70b9\u5e76\u628a\u4ed6\u4eec\u6539\u62101\uff0c\u4ee5\u53ca\u5c06\u5f53\u524d\u8282\u70b9\u7684\u5b50\u6811\uff08\u5305\u62ec\u5f53\u524d\u8282\u70b9\uff09\u7684\u6743\u503c\u6539\u62100\u3002\n\n\u5341\u5206\u719f\u6089\u6709\u6ca1\u6709\uff0c\u5c31\u662f\u6d1b\u8c37\u4e0a\u7684\u94fe\u5256\u677f\u5b50\u9898\u554a\n\n\u4f20\u9001\uff1ahttps://www.luogu.org/problem/show?pid=3384\n\n\u5269\u4e0b\u7684\u5c31\u7b80\u5355\u4e86\u5427\uff0c\u5bf9\u4e8e\u64cd\u4f5c1\uff0c\u6709\u4e00\u4e2a\u7b80\u5355\u7684\u64cd\u4f5c\u65b9\u6cd5\u5c31\u662f\u5f53\u524d\u8282\u70b9\u7684deep+1-\u66f4\u6539\u4e4b\u524d\u7684\u5f53\u524d\u8282\u70b9\u5230\u6839\u8282\u70b9\u6743\u503c\u4e3a1\u7684\u8282\u70b9\u7684\u4e2a\u6570\uff0c\u5f88\u5bb9\u6613\u5c31\u5b9e\u73b0\u4e86\u5427\u3002\n",
        "postTime": 1491360512,
        "uid": 19912,
        "name": "\u5c0f\u5f3a",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u7ecf\u5178\u6811\u5256\uff0c\u672c\u4eba\u4ee3\u7801\u7565\u957f\u4f46\u663e\u7136\u5de5\u6574\u4e00\u4e9b\u3002\u4f7f\u7528struct\u548cdefine\u6765\u4f7f\u4ee3\u7801\u7b80\u5316\u3002\u76f8\u4fe1\u5927\u5bb6\u90fd\u80fd\u770b\u61c2\u7b80\u5355\u7684\u53d8\u91cf\u540d\u3002\n\n\u64cd\u4f5c\u5c31\u662f\u6811\u5256\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5b89\u88c5\u4e86\u5c31\u662f1\uff0c\u672a\u5b89\u88c5\u5c31\u662f0\u3002\n\ninstall\u64cd\u4f5c\u662f\u5c06\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u5168\u90e8\u7f6e1\uff0cunstall\u64cd\u4f5c\u662f\u5c06\u8be5\u70b9\u5b50\u6811\u5168\u90e8\u7f6e0\u3002\n\n\u7531\u4e8e\u5256\u5206\u5e8f\u672c\u8eab\u662fDFS\u5e8f\u7684\u4e00\u90e8\u5206\uff0c\u6240\u4ee5\u5b50\u6811\u4e5f\u662f\u8fde\u7eed\u7684\u4e00\u90e8\u5206\uff0c\u76f4\u63a5\u7ebf\u6bb5\u6811\u533a\u95f4\u64cd\u4f5c\u3002\n\n\u64cd\u4f5c\u524d\u540e\u67e5\u8be2\u4e00\u4e0b\u6c42\u5dee\uff0c\u4e09\u6b21\u67e5\u8be2\u53ef\u80fd\u5e38\u6570\u7565\u5927\uff0c\u4f46\u6bd4\u8f83\u6e05\u695a\u7b80\u5355\u3002\n\n\n\n\n\n\n\n\n    \n    \n    \n        \n    \n        \n\n\n\n\n\n    \n\n\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define MAXN 1000000\n#define lc(x) (x<<1)\n#define rc(x) ((x<<1)|1)\n#define mx(x) t[x].mx\n#define lz(x) t[x].lz\n#define mid ((lef+rig)>>1)\nstruct Node\n{\n    int mx,lz;\n};\nstruct Segment_Tree\n{\n    Node t[MAXN+5];\n    int dat[MAXN+5];\n    void Push(int cur)\n    {\n        mx(cur) = mx(lc(cur)) + mx(rc(cur));\n        return;\n    }\n    void Lazy(int cur, int lef, int rig)\n    {\n        if(lz(cur))\n        {\n            mx(lc(cur)) = (lz(cur)-1)*(mid-lef+1);\n            mx(rc(cur)) = (lz(cur)-1)*( rig-mid );\n            lz(lc(cur)) = lz(cur);\n            lz(rc(cur)) = lz(cur);\n            lz(cur) = 0;\n        }\n        return;\n    }\n    void Build(int cur, int lef, int rig)\n    {\n        if(lef == rig)\n        {\n            mx(cur) = dat[lef], lz(cur) = 0;\n            return;\n        }\n        Build(lc(cur),lef,mid);\n        Build(rc(cur),mid+1,rig);\n        Push(cur);\n        return; \n    }\n    int Query(int cur, int lef, int rig, int L, int R)\n    {\n        Lazy(cur,lef,rig);\n        if(L == lef && R == rig)\n            return mx(cur);\n        if(R <= mid)\n            return Query(lc(cur),lef,mid,L,R);\n        if(L >  mid)\n            return Query(rc(cur),mid+1,rig,L,R);\n        return Query(lc(cur),lef,mid,L,mid)+Query(rc(cur),mid+1,rig,mid+1,R);\n    }\n    void Edit(int cur, int lef, int rig, int L, int R, int x)\n    {\n        Lazy(cur,lef,rig);\n        if(L == lef && R == rig)\n        {\n            mx(cur) = x*(rig-lef+1);\n            lz(cur) = x+1;\n            return;\n        }\n        if(R <= mid)\n            Edit(lc(cur),lef,mid,L,R,x);\n        else if(L >  mid)\n            Edit(rc(cur),mid+1,rig,L,R,x);\n        else\n            Edit(lc(cur),lef,mid,L,mid,x),Edit(rc(cur),mid+1,rig,mid+1,R,x);\n        Push(cur);\n        return;\n    }\n};\nstruct Edge\n{\n    int to,nex;\n    Edge(){}\n    Edge(int _to, int _nex):to(_to),nex(_nex){}\n};\nEdge e[MAXN+5];\nint first[MAXN+5],tot;\nvoid Add(int a, int b)\n{\n    e[tot] = Edge(b,first[a]);\n    first[a] = tot++;\n    return;\n}\nint pos[MAXN+5],dep[MAXN+5],fa[MAXN+5],top[MAXN+5],sz[MAXN+5],heavy[MAXN+5],bound[MAXN+5],n,m,dfn;\nchar s[20];\nvoid DFS1(int p, int father)\n{\n    sz[p] = 1;\n    for(int u = first[p]; u != -1; u = e[u].nex)\n        if(e[u].to != father)\n        {\n            fa[e[u].to] = p, dep[e[u].to] = dep[p]+1, DFS1(e[u].to,p), sz[p] += sz[e[u].to];\n            if(!heavy[p] || sz[e[u].to] > sz[heavy[p]])\n                heavy[p] = e[u].to;\n        }\n    return;\n}\nvoid DFS2(int p)\n{\n    bound[p] = pos[p];\n    if(heavy[p])\n        pos[heavy[p]] = dfn++, top[heavy[p]] = top[p], DFS2(heavy[p]), bound[p] = max(bound[p],bound[heavy[p]]);\n    for(int u = first[p]; u != -1; u = e[u].nex)\n        if(e[u].to != heavy[p] && e[u].to != fa[p])\n            pos[e[u].to] = dfn++, top[e[u].to] = e[u].to, DFS2(e[u].to), bound[p] = max(bound[p],bound[e[u].to]);\n    return;\n}\nSegment_Tree T;\nint Qroot(int p)\n{\n    int ans = 0;\n    while(p)\n        ans += T.Query(1,1,n,pos[top[p]],pos[p]), p = fa[top[p]];\n    return ans;\n}\nvoid Eroot(int p)\n{\n    while(p)\n        T.Edit(1,1,n,pos[top[p]],pos[p],1), p = fa[top[p]];\n    return;\n}\nint main()\n{\n    scanf(\"%d\",&n), memset(first,-1,sizeof(first));\n    for(int i = 2, a; i <= n; i++)\n        scanf(\"%d\",&a), Add(a+1,i);\n    fa[1] = 0, dep[1] = 1, top[1] = 1, pos[1] = 1, dfn = 2, DFS1(1,0), DFS2(1), T.Build(1,1,n);\n    scanf(\"%d\",&m);\n    for(int i = 1, x, a, b; i <= m; i++)\n    {\n        scanf(\"%s\",s), scanf(\"%d\",&x), x++;\n         if(s[0] == 'i')\n             a = Qroot(x), Eroot(x), b = Qroot(x);\n        else\n            b = T.Query(1,1,n,pos[x],bound[x]), T.Edit(1,1,n,pos[x],bound[x],0), a = T.Query(1,1,n,pos[x],bound[x]);\n        printf(\"%d\\n\",b-a);\n    }\n    return 0;\n}\n```",
        "postTime": 1483187917,
        "uid": 16528,
        "name": "magolor",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u96be\u70b9\u5728\u4e8e\u5bf9\u4e8e\u64cd\u4f5c\u7684\u5904\u7406\uff08\u4e00\u5f00\u59cb\u64cd\u4f5c\u4e00\u76f4\u63a5\u66b4\u529b\u6ca1\u60f3\u5230T\u4e86...\uff09\n\n\u64cd\u4f5c1\uff1a\u6539\u53d80\u5230\u76ee\u6807\u8282\u70b9\u7684\u503c\u4e3a1\uff0c\u540c\u65f6\u8bb0\u5f55\u4fee\u6539\u524d\u503c\u4e3a0\u7684\u8282\u70b9\u6570\u3002\n\n\u64cd\u4f5c2\uff1a\u6539\u53d8\u76ee\u6807\u8282\u70b9\u5b50\u6811\u7684\u503c\u4e3a0\uff0c\u540c\u65f6\u8bb0\u5f55\u4fee\u6539\u524d\u503c\u4e3a1\u7684\u8282\u70b9\u6570\u3002\n\n\u64cd\u4f5c2\u5f88\u597d\u5904\u7406\u5229\u7528\uff0c\u5148\u67e5\u8be2\u540e\u5904\u7406\uff0cdfs\u5e8f\u5c31\u884c\u4e86\n\n\u64cd\u4f5c1\u5f04\u4e86\u534a\u5929\uff0c\u53d1\u73b0\u53ea\u9700\u8981\u8bb0\u5f55\u8fd9\u6761\u94fe\u4e0a\u503c\u4e3a1\u7684\u8282\u70b9\u6570\u76ee\uff0c\u518d\u7528 \u6df1\u5ea6\u5dee+1-\u503c\u4e3a1\u7684\u8282\u70b9\u6570\u76ee \u5c31\u53ef\u4ee5\u4e86\n\n\u64cd\u4f5c1\u7684\u590d\u6742\u5ea6\u662fO(log\u00b2n)\uff0c\u64cd\u4f5c2\u7684\u590d\u6742\u5ea6\u662fO(logn)\n\np\u515a\u4ee3\u7801\u5982\u4e0b\n\n\n```cpp\nuses math;\nconst maxn=100010;\ntype node=record\n       left,right,lch,rch,data,op:longint;\n     end;\nvar i,j,k,l,m,n,q,tot,ans:longint;\n    top,w,son,size,depth,fa,head,last,first,next:array[0..maxn]of longint;\n    a:array[0..maxn*4]of node;\nprocedure adds(x,y:longint);\nbegin\n    inc(tot);\n    next[tot]:=head[x];\n    head[x]:=tot;\n    last[tot]:=y;\nend;\nprocedure dfs1(i,d:longint);\nvar j,k,p:longint;\nbegin\n    depth[i]:=d;size[i]:=1;\n    j:=head[i];p:=0;\n    while j<>0 do\n    begin\n      k:=last[j];\n      fa[k]:=i;\n      dfs1(k,d+1);\n      if size[k]>p then\n      begin\n        son[i]:=k;\n        p:=size[k];\n      end;\n      inc(size[i],size[k]);\n      j:=next[j];\n    end;\nend;\nprocedure dfs2(i:longint);\nvar j,k:longint;\nbegin\n    inc(tot);w[i]:=tot;\n    if son[fa[i]]=i then top[i]:=top[fa[i]]\n    else top[i]:=i;\n    j:=head[i];\n    if son[i]<>0 then dfs2(son[i]);\n    while j<>0 do\n    begin\n      k:=last[j];\n      if son[i]<>k then dfs2(k);\n      j:=next[j];\n    end;\nend;\nprocedure built(i,le,ri:longint);\nvar mid:longint;\nbegin\n    if(le=ri)then\n    begin\n      a[i].lch:=le;a[i].rch:=ri;\n      a[i].data:=0;a[i].op:=-1;\n      exit;\n    end;\n    a[i].op:=-1;\n    mid:=(le+ri)shr 1;\n    a[i].lch:=le;\n    a[i].rch:=ri;\n    inc(tot);a[i].left:=tot;\n    inc(tot);a[i].right:=tot;\n    built(a[i].left,le,mid);\n    built(a[i].right,mid+1,ri);\nend;\nprocedure down(i:longint);\nvar l,r:longint;\nbegin\n    l:=a[i].left;r:=a[i].right;\n    if a[i].op<>-1 then\n    begin\n      a[l].op:=a[i].op;\n      a[r].op:=a[i].op;\n      a[l].data:=a[i].op*(a[l].rch-a[l].lch+1);\n      a[r].data:=a[i].op*(a[r].rch-a[r].lch+1);\n      a[i].op:=-1;\n    end;\nend;\nprocedure query(i,le,ri:longint);\nvar mid:longint;\nbegin\n    if(a[i].lch>=le)and(a[i].rch<=ri)then\n    begin\n      inc(ans,a[i].data);\n      exit;\n    end;\n    down(i);\n    mid:=(a[i].lch+a[i].rch)shr 1;\n    if(le<=mid)then query(a[i].left,le,ri);\n    if(ri>mid)then query(a[i].right,le,ri);\nend;\nprocedure change(i,le,ri,num:longint);\nvar mid:longint;\nbegin\n    if(a[i].lch>=le)and(a[i].rch<=ri)then\n    begin\n      a[i].data:=num*(a[i].rch-a[i].lch+1);\n      a[i].op:=num;\n      exit;\n    end;\n    down(i);\n    mid:=(a[i].lch+a[i].rch)shr 1;\n    if(le<=mid)then change(a[i].left,le,ri,num);\n    if(ri>mid)then change(a[i].right,le,ri,num);\n    a[i].data:=a[a[i].left].data+a[a[i].right].data;\nend;\nprocedure init;\nvar i,x,y:longint;\nbegin\n    readln(n);\n    for i:=1 to n-1 do\n    begin\n      read(y);\n      adds(y,i);\n    end;\n    readln(q);\nend;\nprocedure updata(i:longint);\nvar j,k,x,y,ansp:longint;\nbegin\n    x:=i;y:=0;ansp:=0;\n    while top[x]<>top[y] do\n    begin\n      j:=top[x];ans:=0;\n      query(0,w[top[x]],w[x]);\n      inc(ansp,depth[x]-depth[top[x]]+1-ans);\n      change(0,w[top[x]],w[x],1);\n      x:=fa[top[x]];\n    end;\n    ans:=0;\n    query(0,w[y],w[x]);\n    inc(ansp,depth[x]-depth[top[x]]+1-ans);\n    change(0,w[y],w[x],1);\n    writeln(ansp);\nend;\nprocedure delete(i:longint);\nvar j,k:longint;\nbegin\n    ans:=0;\n    query(0,w[i],w[i]+size[i]-1);\n    writeln(ans);\n    change(0,w[i],w[i]+size[i]-1,0);\nend;\nprocedure work;\nvar i,j,k:longint;\n    ch:char;\nbegin\n    for i:=1 to q do\n    begin\n      read(ch);\n      if ch='i' then\n      begin\n        for j:=1 to 6 do read(ch);\n        readln(k);updata(k);\n      end;\n      if ch='u' then\n      begin\n        for j:=1 to 8 do read(ch);\n        readln(k);delete(k);\n      end;\n    end;\nend;\nbegin\n    init;\n    tot:=0;\n    dfs1(0,1);\n    dfs2(0);\n    tot:=0;\n    fa[0]:=-1;\n    built(0,1,n);\n    work;\nend.\n```",
        "postTime": 1479053972,
        "uid": 20390,
        "name": "lwhllw",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u603b\u4e4b\u5c31\u662f\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6811\u94fe\u5256\u5206+dfs\u5e8f\uff1b\n\n\n\u8be6\u7ec6\u9898\u89e3\u548c\u4ee3\u7801\u89c1\u94fe\u63a5\u54af\uff1a\n\nhttp://blog.csdn.net/ww140142/article/details/46957597\n",
        "postTime": 1437356701,
        "uid": 8087,
        "name": "ww140142",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "little_sun\u4f1a\u5199\u6811\u5256\u5566\uff01\n\n\u672c\u9898\u4e3a\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u9898\n\n\u5bf9\u4e8e\"install x\"\u64cd\u4f5c, \u5c06$x$\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u6240\u6709\u70b9\u7684\u70b9\u6743\u5168\u90e8\u8d4b\u503c\u4e3a$1$\n\n\u5bf9\u4e8e\"uninstall x\"\u64cd\u4f5c, \u5c06$x$\u53ca$x$\u7684\u5b50\u6811\u70b9\u6743\u5168\u90e8\u8d4b\u503c\u4e3a$0$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MaxN = 150010;\n\nstruct edge\n{\n    int to, next;\n};\n\nstruct node\n{\n    int l, r;\n    int sum, tag;\n};\n\nstruct SegmentTree\n{\n    node t[MaxN << 1];\n    inline void pushup(int id) { t[id].sum = t[id << 1].sum + t[id << 1 | 1].sum; }\n    void build(int id, int l, int r)\n    {\n        t[id].l = l, t[id].r = r, t[id].tag = -1;\n        if (l == r)\n            return;\n        int mid = (l + r) >> 1;\n        build(id << 1, l, mid);\n        build(id << 1 | 1, mid + 1, r);\n    }\n    inline void pushdown(int id)\n    {\n        if (t[id].tag != -1)\n        {\n            t[id << 1].sum = t[id].tag * (t[id << 1].r - t[id << 1].l + 1);\n            t[id << 1 | 1].sum = t[id].tag * (t[id << 1 | 1].r - t[id << 1 | 1].l + 1);\n\n            t[id << 1].tag = t[id].tag;\n            t[id << 1 | 1].tag = t[id].tag;\n\n            t[id].tag = -1;\n        }\n    }\n    inline void modify(int id, int l, int r, int delta)\n    {\n        if (l > t[id].r || t[id].l > r)\n            return;\n        if (l <= t[id].l && t[id].r <= r)\n        {\n            t[id].sum = delta * (t[id].r - t[id].l + 1);\n            t[id].tag = delta;\n            return;\n        }\n        if (t[id].l == t[id].r)\n            return;\n        pushdown(id);\n        modify(id << 1, l, r, delta);\n        modify(id << 1 | 1, l, r, delta);\n        pushup(id);\n        return;\n    }\n    inline int query(int id, int l, int r)\n    {\n        if (l > t[id].r || t[id].l > r)\n            return 0;\n        if (l <= t[id].l && t[id].r <= r)\n            return t[id].sum;\n        if (t[id].l == t[id].r)\n            return 0;\n        pushdown(id);\n        return query(id << 1, l, r) + query(id << 1 | 1, l, r);\n    }\n} T;\n\nedge e[MaxN << 1];\nint n, m, cnt, dfsnum, size[MaxN], hson[MaxN];\nint head[MaxN], top[MaxN], dfn[MaxN], fa[MaxN], dep[MaxN];\n\ninline void add_edge(int u, int v)\n{\n    ++cnt;\n    e[cnt].to = v;\n    e[cnt].next = head[u];\n    head[u] = cnt;\n}\n\ninline void dfs1(int u, int f)\n{\n    size[u] = 1;\n    for (int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if (v == f)\n            continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v, u);\n        size[u] += size[v];\n        if (size[v] > size[hson[u]])\n            hson[u] = v;\n    }\n}\n\ninline void dfs2(int u, int Top)\n{\n    ++dfsnum;\n    dfn[u] = dfsnum;\n    top[u] = Top;\n    if (hson[u])\n        dfs2(hson[u], Top);\n    for (int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if (v == hson[u] || v == fa[u])\n            continue;\n        dfs2(v, v);\n    }\n}\n\ninline int read()\n{\n    int x = 0;\n    char ch = getchar();\n    while (ch > '9' || ch < '0')\n        ch = getchar();\n    while (ch <= '9' && ch >= '0')\n        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n    return x;\n}\n\ninline void update_tree(int u)\n{\n    T.modify(1, dfn[u], dfn[u] + size[u] - 1, 0);\n}\n\ninline void update_chain(int u, int v, int delta)\n{\n    while (top[u] != top[v])\n    {\n        if (dep[top[u]] < dep[top[v]])\n            swap(u, v);\n        T.modify(1, dfn[top[u]], dfn[u], delta);\n        u = fa[top[u]];\n    }\n    if (dep[u] < dep[v])\n        swap(u, v);\n    T.modify(1, dfn[v], dfn[u], delta);\n}\n\nsigned main()\n{\n    n = read();\n    for (int i = 2; i <= n; ++i)\n    {\n        int u = read() + 1;\n        add_edge(i, u);\n        add_edge(u, i);\n    }\n    dep[1] = 1, fa[1] = 0;\n    dfs1(1, 0), dfs2(1, 1);\n    T.build(1, 1, n);\n    m = read();\n    for (int i = 1; i <= m; i++)\n    {\n        string op;\n        cin >> op;\n        int before = T.t[1].sum;\n        if (op == \"install\")\n        {\n            int u = read() + 1;\n            update_chain(u, 1, 1);\n            int after = T.t[1].sum;\n            printf(\"%d\\n\", after - before);\n        }\n        else\n        {\n            int u = read() + 1;\n            update_tree(u);\n            int after = T.t[1].sum;\n            printf(\"%d\\n\", before - after);\n        }\n    }\n    return 0;\n}\n\n```\n\n",
        "postTime": 1550836395,
        "uid": 61966,
        "name": "little_sun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2146 \u3010[NOI2015]\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    },
    {
        "content": "\u88f8\u7684\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\uff0c\u6211\u7528\u7684\u975e\u9012\u5f52\u521d\u59cb\u5316\uff0c\u53ea\u8981\u4e00\u4e2abfs\uff0c\u4e0d\u4ec5\u5feb\uff0c\u8fd8\u6bd4dfs\u4ee3\u7801\u77ed\u3002\n\n\u7ebf\u6bb5\u6811\u6807\u8bb0d=1\u8868\u793a\u533a\u95f4\u5168\u65391\uff0cd=0\u8868\u793a\u533a\u95f4\u5168\u65390\uff0cd=-1\u8868\u793a\u533a\u95f4\u6ca1\u6709\u6807\u8bb0\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\nprogram rrr(input,output);\ntype\n  etype=record\n     t,next:longint;\n   end;\n   treetype=record\n     l,r,s,d:longint;\n   end;\nvar\n  e:array[0..200020]of etype;\n  head,father,dep,top,siz,son,sson,oot,idx,q:array[-3..100010]of longint;\n  a:array[0..400040]of treetype;\n  n,qq,i,j,cnt,ans,h,t,x:longint;\n  s:string;\nprocedure add(x,y:longint);\nbegin\n   inc(cnt);e[cnt].t:=y;e[cnt].next:=head[x];head[x]:=cnt;\nend;\nprocedure prepare;\nbegin\n   h:=0;t:=1;q[1]:=0;dep[0]:=1;\n   while h<t do\n      begin\n         inc(h);\n         i:=head[q[h]];\n         while i<>0 do\n            begin\n               dep[e[i].t]:=dep[q[h]]+1;\n               inc(t);q[t]:=e[i].t;\n               i:=e[i].next;\n            end;\n      end;\n   for i:=0 to n-1 do siz[i]:=1;\n   fillchar(sson,sizeof(sson),0);\n   for i:=0 to n-1 do son[i]:=-1;\n   for i:=n downto 2 do\n      begin\n         inc(siz[father[q[i]]],siz[q[i]]);\n         if siz[q[i]]>sson[father[q[i]]] then begin son[father[q[i]]]:=q[i];sson[father[q[i]]]:=siz[q[i]]; end;\n      end;\n   fillchar(idx,sizeof(idx),0);father[0]:=-1;oot[-1]:=0;\n   for i:=1 to n do\n      if idx[q[i]]=0 then\n         begin\n            cnt:=oot[father[q[i]]];j:=q[i];\n            while j<>-1 do\n               begin\n                  top[j]:=q[i];\n                  inc(cnt);idx[j]:=cnt;oot[j]:=cnt;\n                  inc(oot[father[j]],siz[j]);\n                  j:=son[j];\n               end;\n         end;\nend;\nprocedure build(k,l,r:longint);\nvar\n  mid:longint;\nbegin\n   a[k].l:=l;a[k].r:=r;a[k].d:=-1;a[k].s:=0;\n   if l=r then exit;\n   mid:=(l+r)>>1;\n   build(k+k,l,mid);\n   build(k+k+1,mid+1,r);\nend;\nprocedure pushdown(k:longint);\nvar\n  i:longint;\nbegin\n   if a[k].l=a[k].r then begin a[k].d:=-1;exit; end;\n   i:=k+k;\n   if a[k].d=0 then begin a[i].s:=0;a[i].d:=0;a[i+1].s:=0;a[i+1].d:=0; end\n   else begin a[i].s:=a[i].r-a[i].l+1;a[i].d:=1;a[i+1].s:=a[i+1].r-a[i+1].l+1;a[i+1].d:=1; end;\n   a[k].d:=-1;\nend;\nfunction ask(k,x,y:longint):longint;\nvar\n  mid,ans:longint;\nbegin\n   if a[k].d<>-1 then pushdown(k);\n   if (x<=a[k].l) and (a[k].r<=y) then exit(a[k].s);\n   ans:=0;mid:=(a[k].l+a[k].r)>>1;\n   if x<=mid then ans:=ask(k+k,x,y);\n   if mid<y then ans:=ans+ask(k+k+1,x,y);\n   exit(ans);\nend;\nprocedure change0(k,x,y:longint);\nvar\n  mid,i:longint;\nbegin\n   if a[k].d<>-1 then pushdown(k);\n   if (x<=a[k].l) and (a[k].r<=y) then begin a[k].s:=0;a[k].d:=0;exit;end;\n   mid:=(a[k].l+a[k].r)>>1;i:=k+k;\n   if x<=mid then change0(i,x,y);\n   if mid<y then change0(i+1,x,y);\n   a[k].s:=a[i].s+a[i+1].s;\nend;\nprocedure change1(k,x,y:longint);\nvar\n  mid,i:longint;\nbegin\n   if a[k].d<>-1 then pushdown(k);\n   if (x<=a[k].l) and (a[k].r<=y) then begin a[k].s:=a[k].r-a[k].l+1;a[k].d:=1;exit;end;\n   mid:=(a[k].l+a[k].r)>>1;i:=k+k;\n   if x<=mid then change1(i,x,y);\n   if mid<y then change1(i+1,x,y);\n   a[k].s:=a[i].s+a[i+1].s;\nend;\nprocedure install;\nbegin\n   ans:=dep[x];\n   while x<>-1 do begin ans:=ans-ask(1,idx[top[x]],idx[x]);change1(1,idx[top[x]],idx[x]);x:=father[top[x]]; end;\n   writeln(ans);\nend;\nprocedure uninstall;\nbegin\n   writeln(ask(1,idx[x],idx[x]+siz[x]-1));\n   change0(1,idx[x],idx[x]+siz[x]-1);\nend;\nbegin\n   //assign(input,'manager.in');assign(output,'manager.out');reset(input);rewrite(output);\n   readln(n);\n   fillchar(head,sizeof(head),0);cnt:=0;\n   for i:=1 to n-1 do begin read(father[i]);add(father[i],i); end;\n   prepare;\n   build(1,1,n);\n   readln(qq);\n   for i:=1 to qq do\n      begin\n         readln(s);\n         if s[1]='i' then begin delete(s,1,8);val(s,x);install; end\n         else begin delete(s,1,10);val(s,x);uninstall; end;\n      end;\n   //close(input);close(output);\nend.\n```",
        "postTime": 1489218557,
        "uid": 28023,
        "name": "McGrady",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2146 \u3010\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668\u3011"
    }
]