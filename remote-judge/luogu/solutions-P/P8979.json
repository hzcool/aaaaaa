[
    {
        "content": "\u5076\u7136\u770b\u5230\u8fd9\u9898\uff0c\u5c31\u7a0d\u5fae\u56de\u5e94\u4e00\u4e0b\u9898\u76ee\u63d0\u4f9b\u8005\uff0c\u867d\u7136\u5177\u4f53\u505a\u6cd5\u7b97\u662f\u6bd4\u8f83\u7ecf\u5178\u4e86\u3002\u4e3a\u65b9\u4fbf\u8868\u8ff0\uff0c\u672c\u6587\u4e2d\u8bb0 $F(1,0)=r_0$\uff0c$F(1,1)=r_1$\u3002\n\n\u9996\u5148\u6211\u4eec\u5bb9\u6613\u5bf9 $F(1,n)$ \u5efa\u7acb\u5173\u4e8e $n$ \u7684\u751f\u6210\u51fd\u6570\uff1a\n$$F_1(x)=\\frac{r_0+(r_1-r_0a)x}{1-ax-bx^2}$$\n\u628a\u9012\u63a8\u5f0f\u7528\u751f\u6210\u51fd\u6570\u8868\u8fbe\uff1a\n$$F_k(x)=t_k x F_k(x)+ F_{k-1}(sx)$$\n$$F_k(x) =  \\frac{F_{k-1}(sx)}{1-t_kx}$$\n\u9012\u63a8\u7684\u65f6\u5019\u628a $x$ \u66ff\u6362\u4e3a $sx$ \u7684\u64cd\u4f5c\u5176\u5b9e\u5f88\u597d\u5904\u7406\uff1a\n$$F_k(x)=  \\frac{r_0+(r_1-r_0a)s^{k-1}x}{1-as^{k-1}x-bs^{2k-2}x^2}\\prod_{i=2}^k \\frac{1}{1-t_is^{k-i}x}$$\n\u5927\u529b\u5206\u6cbb\u4e58\u7136\u540e\u505a\u7ebf\u6027\u9012\u63a8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $\\Theta(k \\log^2 k+k \\log k \\log n)$ \u53ef\u4ee5\u901a\u8fc7\u672c\u9898\uff0c\u4f46\u662f\u8fd8\u4e0d\u591f\u4f18\u79c0\u3002\u7ee7\u7eed\u4f18\u5316\u53ef\u4ee5\u505a\u5230 $\\mathcal O(k \\log^2 k+k \\log n)$\uff0c\u4e0d\u8fc7\u5199\u8d77\u6765\u6bd4\u8f83\u590d\u6742\uff0c\u770b\u770b\u5c31\u597d\u3002\n\nEI \u8bb2\u8fc7\uff0c\u8fd9\u79cd\u5f62\u5f0f\u53ef\u4ee5\u505a\u5206\u5f0f\u5206\u89e3\u3002\u9996\u5148\uff0c\u6211\u4eec\u628a\u5206\u6bcd\u4e2d\u7684\u90a3\u4e2a\u4e8c\u6b21\u591a\u9879\u5f0f\u505a\u56e0\u5f0f\u5206\u89e3\uff08\u53ef\u80fd\u9700\u8981\u6269\u57df\uff09\uff0c\u6211\u4eec\u7684\u76ee\u6807\u5c31\u662f\u5c06\u8fd9\u6837\u4e00\u4e2a\u5f62\u5f0f\u7684\u5206\u5f0f\uff08\u6ce8\u610f\u4e00\u70b9\uff0c\u867d\u7136\u4e4d\u4e00\u770b\u5206\u89e3\u540e\u6709 $k+1$ \u9879\uff0c\u4f46\u662f\u53ef\u80fd\u6709\u91cd\u590d\uff0c\u8981\u8bb0\u4e3a\u91cd\u6839\uff09\uff1a\n$$\\frac{1}{Q(x)}=\\prod_{i=1}^m \\frac{1}{(1-q_ix)^{d_i}}$$\n\u6539\u5199\u4e3a\n$$\\sum_{i=1}^m \\frac{P_i(x)}{(1-q_ix)^{d_i}}$$\n\u8fd9\u6837\u4e00\u4e2a\u5f62\u5f0f\u5c31\u5f88\u5bb9\u6613\u63d0\u53d6\u4e00\u9879\u7cfb\u6570\u4e86\u3002\n\n\u901a\u5206\u540e\u53ef\u4ee5\u5f97\u5230\u8fd9\u6837\u4e00\u4e2a\u7ed3\u679c\uff08\u5bf9\u4e8e\u5404 $i \\in [1,m]$\uff09\uff1a\n$$\\frac{P_i(x)Q(x)}{(1-q_ix)^{d_i}}\\equiv 1 \\pmod{(1-q_ix)^{d_i}}$$\n\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6c42\u51fa\u5404 $\\dfrac{Q(x)}{(1-q_ix)^{d_i}} \\bmod (1-q_ix)^{d_i}$ \u4e4b\u540e\uff0c\u518d\u5206\u522b\u6c42\u51fa\u5b83\u4eec**\u5728\u6a21 $(1-q_ix)^{d_i}$ \u610f\u4e49\u4e0b\u7684\u9006**\u5f97\u5230\u7684\u4fbf\u662f $P_i(x)$\u3002\n\n\u5bf9\u4e8e\u524d\u8005\uff0c\u53ef\u4ee5\u5206\u6cbb\u5904\u7406\uff1a\u4e0d\u8981\u628a\u5b83\u770b\u4f5c\u5206\u5f0f\uff0c\u5b83\u672c\u8eab\u5c31\u662f\u8bb8\u591a\u4e00\u6b21\u5f0f\u7684\u4e58\u79ef\uff0c\u5229\u7528 $F(x) \\equiv (F(x) \\bmod A(x)B(x)) \\pmod {A(x)}$ \u8fd9\u4e00\u6027\u8d28\u5373\u53ef\u3002\n\n\u540e\u8005\u4e5f\u6bd4\u8f83\u7b80\u5355\uff0c\u6211[\u53e6\u4e00\u7bc7\u9898\u89e3](https://www.luogu.com.cn/blog/NaCly-Fish-blog/solution-at-s8pc-3-g)\u4e2d\u4e5f\u6709\u63d0\u5230\uff0c\u5c31\u4e0d\u590d\u8bfb\u4e86\uff08\n\n\u6240\u4ee5\u4e3a\u4ec0\u4e48\u53c2\u6570\u7684\u6570\u636e\u8303\u56f4\u8fd8\u8981\u5f00\u5230\u8d1f\u6570\u5462\uff1f",
        "postTime": 1675278661,
        "uid": 115864,
        "name": "NaCly_Fish",
        "ccfLevel": 6,
        "title": "P8979 \u300cDTOI-4\u300d\u767d\u7684 Fibonacci \u53e3\u80e1"
    },
    {
        "content": "\u53ef\u80fd\u6709\u66f4\u7b80\u5355\u7684\u63a8\u6cd5\u548c\u66f4\u4f18\u7684\u590d\u6742\u5ea6\uff0c\u672c\u9898\u89e3\u53ea\u4f5c\u629b\u7816\u5f15\u7389\u3002\n\n\u7ecf\u8fc7\u4e00\u4e9b\u624b\u819c\uff0c\u6211\u4eec\u63a8\u65ad $F(k,n)$ \u53ef\u4ee5\u4f7f\u7528 $k+1$ \u9636\u5e38\u9f50\u6b21\u7ebf\u6027\u9012\u63a8\u8868\u51fa\u3002\n\n\u8bbe\n$$F(k,n) = \\sum_{i = 1}^{k+1} f_{k,i} \\times F(k, n-i) $$\n\u81ea\u7136\u5730\uff0c$f_{1,1} = a, f_{1,2} = b$\u3002\n\n\u73b0\u5728\u8ba8\u8bba\u5982\u4f55\u4f7f\u7528 $f_{k-1}$ \u63a8\u51fa $f_{k}$ \u3002\u4ee5\u4e0b\u8ba8\u8bba\u4e2d $k > 1$\u3002\n\n$$\\begin{aligned}\n& F(k,n) = t_k \\times F(k, n-1) + s^n \\times F(k-1, n)\n\\\\  = \\ & t_k \\times F(k, n-1) + s^n \\times \\sum_{i = 1}^{k} f_{k-1,i} \\times F(k-1, n-i) \\qquad \\text{(\u4f7f\u7528\u9012\u63a8\u5f0f\u8868\u51fa)}\n\\\\  = \\ & t_k \\times F(k, n-1) + \\sum_{i = 1}^{k} f_{k-1,i} \\times s^{i} \\times s^{n-i} \\times F(k-1, n-i) \\qquad (\u5c06s^n\u62c6\u5206\uff0c\u51d1\u51fa\u7cfb\u6570)\n\\\\  = \\ & t_k \\times F(k, n-1) + \\sum_{i = 1}^{k} f_{k-1,i} \\times s^{i} \\times (F(k, n-i) - t_k \\times F(k, n - i - 1))\\qquad  (\u9012\u63a8\u5f0f\u79fb\u9879\u5e26\u5165)\n\\\\  = \\ & t_k \\times F(k, n-1) + \\sum_{i = 1}^{k} f_{k-1,i} \\times s^{i} \\times F(k, n-i) - \\sum_{i = 2}^{k+1} f_{k-1,i-1} \\times s^{i-1} \\times t_k \\times F(k, n - i) \\qquad  (\u62c6\u5206\u548c\u5f0f)\n\\\\  = \\ & \\sum_{i=1}^{k+1} ( f_{k-1,i} \\times s^i - f_{k-1,i-1} \\times s^{i-1} \\times t_k + t_k[i = 1] ) \\times F(k, n-i) \\qquad  (\u8868\u51fa\u7cfb\u6570)\n\\end{aligned}$$\n\n\u4e3a\u65b9\u4fbf\uff0c\u8bbe $\\forall k > 1,i > k+1, \\ f_{k,0} = f_{k,i} = 0$\u3002\u4e8e\u662f $f_k$ \u53ef\u4ee5\u88ab $f_{k-1}$ \u8868\u4e3a\u5982\u4e0b\u5f62\u5f0f\uff1a\n$$ f_{k,i} = f_{k-1,i} \\times s^i - f_{k-1,i-1} \\times s^{i-1} \\times t_k + t_k[i = 1]  $$\n\n\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5 $O(k^2)$  \u5730\u63a8\u51fa $F(k,n)$ \u7684\u9012\u63a8\u7cfb\u6570\u4e0e\u524d $k+1$ \u9879\u503c\u3002\u968f\u540e $O(k \\log k \\log n)$ \u5730\u9012\u63a8\u5373\u53ef\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(k ^ 2 + k \\log k \\log n)$\u3002\n\nBonus: \u80fd\u5426 $O(k\\log^2 k + k\\log k \\log n)$\uff1f \n\n\n```cpp\n#include <bits/stdc++.h>\n#define rep(i,a,b) for (register int(i) = (a); (i) <= (b); ++(i))\n#define pre(i,a,b) for (register int(i) = (a); (i) >= (b); --(i))\nusing namespace std;\ntypedef unsigned long long ll;\nconst int N = 5000 + 10;\nconst int mod = 998244353, g = 3;\nint k, st0, st1, a, b, s, ans;\nint t[N], f[N], st[N];\nll n;\n\n#ifdef ONLINE_JUDGE\n    char buf[1<<21], *p1 = buf, *p2 = buf;  inline char getc() { return (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1<<21, stdin), p1 == p2) ? EOF : *p1++); }\n    #define getchar getc\n#endif\ntemplate <typename T> inline void get(T & x){\n\tx = 0; char ch = getchar(); bool f = false;\n\twhile (ch < '0' or ch > '9') f = f or ch == '-',  ch = getchar();\n\twhile (ch >= '0' and ch <= '9') x = (x<<1) + (x<<3) + (ch^48), ch = getchar(); f && (x = -x);\n} template <typename T, typename ... Args> inline void get(T & x, Args & ... _Args) { get(x); get(_Args...); }\n\nstruct Light {\n    int p, mx, sq, dsq[100], usq[100];\n    void init(int _p, int _mx) {\n        p = _p, mx = _mx; sq = sqrt(mx) + 1;\n        dsq[0] = usq[0] = 1;\n        rep(i,1,sq - 1) dsq[i] = 1ll * dsq[i-1] * p % mod;\n        usq[1] = 1ll * dsq[sq - 1] * p % mod;\n        rep(i,2,sq) usq[i] = 1ll * usq[i-1] * usq[1] % mod;\n    } int qp(int k) {\n        return 1ll * dsq[k % sq] * usq[k / sq] % mod;\n    }\n} pw;\n\nint btrs[N << 5]; // butterfly_transform\ninline int initrs(int k) {\n    int limit = 1;\n    while (limit < k) limit <<= 1;\n    for (register int i = 0  ; i < limit; i ++) \n        btrs[i] = ((btrs[i >> 1] >> 1) | ((i & 1) ? limit >> 1 : 0));\n    return limit;\n}\n\ninline ll qp(ll a, ll b) {\n    ll ret = 1;\n    while (b) {\n        if (b & 1) ret = ret * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    } return ret;\n} inline ll inv(ll a) { return qp(a, mod-2); }\n\nint L, w[2][1<<19];\ninline int __INITILIZE__UNIT__ROOT__() {\n    L = 1<<19;\n    w[0][0] = w[1][0] = 1;\n    int wn = qp(g, (mod-1) / L);\n    for (register int i = 1; i < L; i++) w[0][L - i] = w[1][i] = 1ll * w[1][i - 1] * wn % mod;\n    return 1;\n} int __INITIALIZER__ = __INITILIZE__UNIT__ROOT__();\n\nstruct poly {\n    vector <ll> f; \n    ll operator [] (const int & pos) const { return f[pos]; }\n    ll & operator [] (const int & pos) { return f[pos]; }\n    int deg() {return f.size(); }\n    int deg() const  {return f.size(); }\n    void Set(int n) { f.resize(n); }\n    void Adjust() { while (f.size() > 1 and f.back() == 0) f.pop_back(); }\n    void Reverse() { reverse(f.begin(), f.end()); }\n    inline void NTT (const int lim, const int type) {\n        Set(lim);\n        for (register int i = 0; i < lim; i++) if (i < btrs[i]) swap(f[i], f[btrs[i]]);\n        for (register int mid = 1; mid < lim; mid <<= 1) {\n            for (register int i = L / (mid<<1), j = 0; j < lim; j += (mid << 1)) {\n                for (register int k = 0; k < mid; k++) {\n                    int x = f[j + k], y = w[type][i * k] * f[j + k + mid] % mod;\n                    f[j + k] = (x + y) % mod;\n                    f[j + k + mid] = (x - y + mod) % mod;\n                }\n            }\n        } if (type == 1) return;\n        ll inv = qp(lim, mod - 2);\n        for (register int i = 0; i < lim; i++) f[i] = f[i] * inv % mod;\n    } \n    friend poly operator - (const poly & x, const poly & y) {\n        poly ret; ret.Set(max(x.deg(), y.deg()));\n        for (register int i = 0; i < x.deg(); ++i) ret[i] = x[i];\n        for (register int i = 0; i < y.deg(); ++i) ret[i] = (ret[i] - y[i] + mod) % mod;\n        return ret;\n    } void operator -= (const poly & x) {\n        Set(max(deg(), x.deg()));\n        for (register int i = 0; i < x.deg(); ++i) f[i] = (f[i] - x[i] + mod) % mod;\n    } \n    friend poly operator * (const poly & x, const poly & y) {\n        poly ret, A = x, B = y;\n        int limit = initrs(A.deg() + B.deg() - 1);\n        A.NTT(limit, 1), B.NTT(limit, 1); ret.Set(limit);\n        for (register int i = 0; i < limit; i++) ret[i] = 1ll * A[i] * B[i] % mod;\n        ret.NTT(limit, 0); ret.Adjust();\n        return ret;\n    } void operator *= (const poly & x) {\n        poly A = x;\n        int limit = initrs(deg() + A.deg() - 1);\n        A.NTT(limit, 1); NTT(limit, 1);\n        for (register int i = 0; i < limit; i++) f[i] = 1ll * A[i] * f[i] % mod;\n        NTT(limit, 0); Adjust();\n    }\n    friend poly operator % (const poly & x, const poly & y) {\n        poly A = x, B = y;\n        A.Reverse(), B.Reverse(); B.Set(x.deg() - y.deg() + 1);\n        B = B.Inv(); B *= A;\n        B.Set(x.deg() - y.deg() + 1); B.Reverse();\n        poly R = x - B * y; R.Set(y.deg() - 1);\n        return R;\n    }\n    poly Inv() {\n        poly ret; ret.Set(1);\n        if (f.empty()) return ret;\n        ret[0] = inv(f[0]); poly A, B;\n        for (register int len = 2, limit; len < (deg() << 1); len <<= 1) {\n            A.f.assign((*this).f.begin(), (*this).f.begin() + min(len, deg()));\n            B = ret; B.Set(min(len, deg()));\n            limit = initrs(A.deg() + B.deg() - 1);\n            A.NTT(limit, 1); B.NTT(limit, 1);\n            ret.Set(limit);\n            for (register int i = 0; i < limit; i++) ret[i] = (2 - A[i] * B[i] % mod + mod) * B[i] % mod;\n            ret.NTT(limit, 0);\n            ret.Set(len);\n        } ret.Set(deg()); return ret;\n    }\n} F, I;\n\ninline void mul(poly & a, poly b, poly m) {\n    a *= b;\n    if (a.deg() >= m.deg()) a = a % m;\n}\n\npoly qp(poly a, ll b, poly m) {\n    poly ret; ret.Set(1), ret[0] = 1;\n    while (b) {\n        if (b & 1) mul(ret, a, m);\n        mul(a, a, m);\n        b >>= 1;\n    } return ret;\n}\n\nsigned main() {\n    get(k, n); \n    get(st[0], st[1], a, b, s);\n    st[0] = (mod + st[0]) % mod; st[1] = (mod + st[1]) % mod; a = (mod + a) % mod; b = (mod + b) % mod; s = (mod + s) % mod;\n    pw.init(s, k + 2);\n    rep(i,2,k) get(t[i]), t[i] = (mod + t[i]) % mod;\n    \n    rep(i,2,k) st[i] = (1ll * a * st[i-1] + 1ll * b * st[i-2]) % mod; \n    rep(i,2,k) rep(j,1,k) \n        st[j] = (1ll * t[i] * st[j-1] + 1ll * pw.qp(j) * st[j]) % mod;\n    if (n <= k) printf(\"%d\\n\", st[n]), exit(0);\n\n    f[1] = a, f[2] = b;\n    rep(i,2,k) pre(j,i+1,1) \n        f[j] = (1ll * pw.qp(j) * f[j] - 1ll * t[i] * pw.qp(j-1) % mod * f[j-1] % mod + (j == 1 ? t[i] : 0) + mod) % mod;\n\n    F.Set(k+2); rep(i,1,k+1) F[k + 1 - i] = (mod - f[i]) % mod; \n    F[k+1] = 1;\n    I.Set(2); I[0] = 0, I[1] = 1; \n    poly Ans = qp(I, n, F);\n    rep(i,0,k) ans = (ans + 1ll * st[i] * Ans[i]) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```",
        "postTime": 1674552323,
        "uid": 631791,
        "name": "joke3579",
        "ccfLevel": 0,
        "title": "\u300cDTOI-4\u300d\u767d\u7684 Fibonacci \u9898\u89e3"
    }
]