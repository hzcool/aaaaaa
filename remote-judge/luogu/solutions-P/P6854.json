[
    {
        "content": "\u6ee1\u8db3\u7b2c\u4e8c\u4e2a\u6761\u4ef6\u7684\u533a\u95f4\u4e0d\u4f1a\u5f88\u591a,\u800c\u5224\u65ad\u8fd9\u6837\u7684\u4e00\u4e2a\u533a\u95f4\u662f\u5426\u6ee1\u8db3\u7b2c\u4e00\u4e2a\u6761\u4ef6\u53ea\u8981\u67e5\u8be2\u6700\u503c,\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u627e\u51fa\u6240\u6709\u6ee1\u8db3\u7b2c\u4e8c\u4e2a\u6761\u4ef6\u7684\u533a\u95f4,\u8fd9\u53ef\u4ee5\u679a\u4e3e\u5de6\u7aef\u70b9,\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5408\u6cd5\u7684\u53f3\u7aef\u70b9\u96c6\u5408,\u590d\u6742\u5ea6$O(Ans\\times logn)$.\n\n\u6211\u4eec\u73b0\u5728\u9700\u8981\u4f30\u8ba1\u6ee1\u8db3\u7b2c\u4e8c\u4e2a\u6761\u4ef6\u7684\u533a\u95f4\u5230\u5e95\u6709\u591a\u5c11\u4e2a,\u4e00\u4e2a\u663e\u7136\u7684\u4e0a\u754c\u662f$O(n\\sqrt{n})$,\u4f46\u8fd9\u4e2a\u754c\u5f88\u677e.\n\n\u8003\u8651\u628a\u5e8f\u5217\u4e2d\u6240\u6709\u6570\u6309\u7167\u6743\u503c\u4ece\u5c0f\u5230\u5927\u52a0\u5165.\u5047\u8bbe\u6211\u4eec\u73b0\u5728\u52a0\u5165\u7684\u662f\u6743\u503c\u4e3a$x$\u7684\u6240\u6709\u6570,\u4e00\u5171$k$\u4e2a,\u5728\u52a0\u5165\u4e4b\u524d\u5e8f\u5217\u4e2d\u5408\u6cd5\u5b50\u533a\u95f4\u7684\u6570\u91cf\u662f$Cnt$.\u73b0\u5728\u6211\u4eec\u8003\u8651\u52a0\u5165\u7684\u6570\u5bf9\u7b54\u6848\u7684\u5f71\u54cd,\u628a\u6240\u6709\u533a\u95f4\u5206\u6210\u4e0b\u9762\u51e0\u7c7b.\n\n>\u539f\u672c\u7684\u5408\u6cd5\u533a\u95f4,\u6ca1\u6709\u88ab\u52a0\u5165\u4efb\u4f55\u6570.\n>\n>\u539f\u672c\u7684\u5408\u6cd5\u533a\u95f4,\u4e2d\u95f4\u6070\u597d\u88ab\u52a0\u5165\u4e86$x$\u4e2a$x$.\n\n\u4ee5\u4e0a\u8fd9\u4e9b\u533a\u95f4\u4e0d\u4ee5$x$\u5f00\u5934\u4e5f\u4e0d\u4ee5$x$\u7ed3\u5c3e,\u81f3\u591a$Cnt$\u4e2a.\n\n>   \u539f\u672c\u7684\u5408\u6cd5\u533a\u95f4,\u5728\u5f00\u5934\u52a0\u4e0a\u4e86$x$\u4e2a$x$\n>\n>   \u539f\u672c\u7684\u5408\u6cd5\u533a\u95f4,\u5728\u672b\u5c3e\u52a0\u4e0a\u4e86$x$\u4e2a$x$\n>\n>   \u4ee5$x$\u5f00\u5934\u7ed3\u5c3e\u7684\u5408\u6cd5\u533a\u95f4.\n\n\u7b2c\u4e09\u7c7b\u533a\u95f4\u7684\u6570\u91cf\u81f3\u591a\u662f$k-x+1$.\n\n\u5c06\u8fde\u7eed\u7684$x$\u4e2a$x$\u79f0\u4e3a\u4e00\u5757,\u8003\u8651\u76f8\u90bb\u7684\u4e24\u4e2a\u5757,\u5982\u679c\u5b83\u4eec\u4e4b\u95f4\u7684\u8ddd\u79bb\u662f$d$,\u90a3\u4e48\u5b83\u4eec\u81f3\u591a\u4f1a\u5bf9\u533a\u95f4\u4e2a\u6570\u4ea7\u751f$2\\times min(d,x-1)$\u7684\u8d21\u732e.\u6240\u4ee5\u7b2c\u4e00\u4e8c\u7c7b\u533a\u95f4\u7684\u6570\u91cf\u81f3\u591a\u662f$(\\frac{k}{x}+1)\\times 2\\times (x-1)$.\n\n\u5bb9\u6613\u770b\u51fa\u6700\u7ec8\u5408\u6cd5\u533a\u95f4\u7684\u4e2a\u6570\u662f$O(n)$\u7ea7\u522b\u7684.\n\n\u7ebf\u6bb5\u6811\uff0c$O(nlog{n}).$\n\nPS\uff1a\u8fd9\u9898\u5b9e\u73b0\u7684\u65f6\u5019\u9700\u8981\u6ce8\u610f\u4e00\u4e0b\u5e38\u6570\u95ee\u9898\uff0c\u4e0d\u6070\u5f53\u7684\u5b9e\u73b0\u65b9\u5f0f\u53ef\u80fd\u4f1a\u5bfc\u81f42\u52303\u500d~~\uff08\u751a\u81f330\u500d\uff09~~\u7684\u5e38\u6570\u3002\u800c\u53e6\u5916\u4e00\u4e9blog\u505a\u6cd5\u7684\u5e38\u6570\u4f3c\u4e4e\u4e5f\u8981\u8fd9\u4e2a\u7ea7\u522b......\n\nbonus:\u627e\u5230\u7ebf\u6027\u505a\u6cd5\u3002\n\n\u4ee5\u4e0b\u4ee3\u7801\u6765\u81eaEndSaH\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nusing LL = long long;\n\nconst int maxN = 1e6 + 5;\n\nint n, m, ans, rig;\nvector<int> pos[maxN];\nint a[maxN];\n\ntemplate<typename _Tp>\ninline bool Chkmin(_Tp& x, const _Tp& y)\n{ return x > y ? x = y, true : false; }\n\ntemplate<typename _Tp>\ninline bool Chkmax(_Tp& x, const _Tp& y)\n{ return x < y ? x = y, true : false; }\n\nint read()\n{\n    int x = 0;\n    char ch;\n    while (!isdigit(ch = getchar()));\n    while (x = x * 10 + (ch & 15), isdigit(ch = getchar()));\n    return x;\n}\n\nnamespace RMQ\n{\n    int lg2[maxN];\n    int mini[22][maxN], maxi[22][maxN];\n\n    void Init()\n    {\n        for (int i = 2; i <= n; ++i)\n            lg2[i] = lg2[i >> 1] + 1;\n\n        for (int i = 1; i <= n; ++i)\n            mini[0][i] = maxi[0][i] = a[i];\n        for (int i = 1; i < 21; ++i)\n            for (int j = 1; j + (1 << i) - 1 <= n; ++j)\n            {\n                mini[i][j] = min(mini[i - 1][j], mini[i - 1][j + (1 << (i - 1))]);\n                maxi[i][j] = max(maxi[i - 1][j], maxi[i - 1][j + (1 << (i - 1))]);\n            }\n    }\n\n    int Query_min(int l, int r)\n    {\n        int t = lg2[r - l + 1];\n        return min(mini[t][l], mini[t][r - (1 << t) + 1]);\n    }\n\n    int Query_max(int l, int r)\n    {\n        int t = lg2[r - l + 1];\n        return max(maxi[t][l], maxi[t][r - (1 << t) + 1]);\n    }\n\n    bool Check(int l, int r)\n    {\n        //cout << l << ' ' << r << endl;\n        int a = Query_min(l, r), b = Query_max(l, r);\n        return LL(a + b) * (b - a + 1) / 2 == r - l + 1;\n    }\n}\n\nnamespace SEG\n{\n    int maxi[maxN * 4], tag[maxN * 4];\n\n    inline void add(int x, int addv)\n    { maxi[x] += addv, tag[x] += addv; }\n\n    inline void Pushdown(int x)\n    {\n        if (tag[x])\n        {\n            add(x << 1, tag[x]), add(x << 1 | 1, tag[x]);\n            tag[x] = 0;\n        }\n    }\n\n    inline void Pushup(int x)\n    { maxi[x] = max(maxi[x << 1], maxi[x << 1 | 1]); }\n\n    void Add(int ql, int qr, int addv, int l = 1, int r = n, int x = 1)\n    {\n        if (ql <= l and r <= qr)\n        {\n            add(x, addv);\n            return;\n        }\n\n        int mid = (l + r) >> 1;\n        Pushdown(x);\n        if (ql <= mid)\n            Add(ql, qr, addv, l, mid, x << 1);\n        if (mid < qr)\n            Add(ql, qr, addv, mid + 1, r, x << 1 | 1);\n        Pushup(x);\n    }\n\n    void Find(int l = 1, int r = n, int x = 1)\n    {\n        if (maxi[x] != m)\n            return;\n        if (l == r)\n        {\n            ans += RMQ::Check(l, rig);\n            return;\n        }\n        int mid = (l + r) >> 1;\n        Pushdown(x);\n        Find(l, mid, x << 1);\n        Find(mid + 1, r, x << 1 | 1);\n    }\n}\n\nint main()\n{\n   // freopen(\"tram.in\", \"r\", stdin);\n   // freopen(\"tram.out\", \"w\", stdout);\n    ios::sync_with_stdio(false);\n    n = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read(), m = max(m, a[i]);\n    RMQ::Init();\n\n    for (int i = 1; i <= m; ++i)\n        pos[i].push_back(0);\n\n    for (int i = 1; i <= n; ++i)\n    {\n        rig = i;\n        int t = a[i];\n        SEG::Add(i, i, m);\n        SEG::Add(pos[t].back() + 1, i, -1);\n        pos[t].push_back(i);\n\n        if ((int)pos[t].size() >= t + 1)\n        {\n            int a = pos[t].size() - t - 1;\n            SEG::Add(pos[t][a] + 1, pos[t][a + 1], 1);\n            if (a > 0)\n                SEG::Add(pos[t][a - 1] + 1, pos[t][a], -1);\n        }\n        SEG::Find();\n    }\n    cout << ans << endl;\n\n    return 0;\n}",
        "postTime": 1603254085,
        "uid": 8601,
        "name": "disposrestfully",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6854 \u3010Tram\u3011"
    },
    {
        "content": "### \u9898\u610f\n\n- \u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u5b9a\u4e49\u4e00\u4e2a\u597d\u7684\u533a\u95f4\uff1a\n  1. \u5bf9\u4e8e\u533a\u95f4\u91cc\u51fa\u73b0\u7684\u6570$a_i$\u6070\u597d\u51fa\u73b0$a_i$\u6b21\n  2. \u533a\u95f4\u91cc\u7684\u6570\u7684\u503c\u57df\u8fde\u7eed\n\n- \u6c42\u597d\u7684\u533a\u95f4\u6570\u91cf\n\n\u8003\u8651\u4ee5\u67d0\u4e2a\u70b9$i$\u7ed3\u675f\u7684\u597d\u7684\u533a\u95f4\u7684\u6700\u540e\u8d77\u59cb\u4f4d\u7f6e\uff0c\u7136\u540e\u5411\u524d\u62d3\u5c55\uff0c\u53d1\u73b0\u6700\u591a\u62d3\u5c55$n$\u6b21\uff0c\u5e76\u4e14\u6bcf\u6b21\u62d3\u5c55\u4e00\u5b9a\u4f1a\u5c06\u503c\u57df\u5411\u5c0f/\u5927\u62d3\u5c55\u81f3\u5c111\uff0c\u8003\u8651\u5230\u4ece$1$\u4e00\u76f4\u52a0\u5230$\\sqrt n$\u5c31\u4f1a\u5927\u4e8e$n$\uff0c\u6240\u4ee5\u8bf4\u597d\u7684\u533a\u95f4\u4e0d\u4f1a\u8d85\u8fc7$n\\sqrt n$\u7ea7\u522b\n\n\u90a3\u4e48\u53ea\u9700\u8981$o(1)$\u6216\u8005$o(\\log n)$\u7684\u590d\u6742\u5ea6\u5185\u627e\u5230\u4e00\u4e2a\u53ef\u884c\u4f4d\u7f6e\u518d\u52a0\u8fdb\u7b54\u6848\u5c31\u884c\n\n\u4e8e\u662f\u4ece\u5de6\u5f80\u53f3\uff0c\u6bcf\u6b21\u5bf9\u5f53\u524d\u6570\u7ef4\u62a4\u53ef\u884c\u7684\u533a\u95f4\u5c31\u597d\n\n\u5177\u4f53\u7684\u64cd\u4f5c\u662f\uff0c\u5047\u8bbe\u5f53\u524d\u6570\u4e3a$x$\u90a3\u4e48\u627e\u5230\u524d$x$\u4e2a\u7684\u4f4d\u7f6e\uff0c\u8fd9\u4e2d\u95f4\u662f\u4e0d\u80fd\u9009\u7684\uff0c\u4ee5\u53ca\u524d$x+1$\u4e2a$x$\u4e4b\u524d\u7684\u4f4d\u7f6e\u4e5f\u662f\u4e0d\u80fd\u9009\u7684\n\n\u6240\u4ee5\u5c31\u53ef\u4ee5\u7ebf\u6bb5\u6811\uff0c\u6bcf\u6b21\u5c06\u4e0d\u80fd\u9009\u7684\u4f4d\u7f6e$+1$\uff0c\u7ef4\u62a4\u533a\u95f4\u6700\u5c0f\u503c\uff0c\u7136\u540e\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5373\u53ef\n\n```cpp\n#include<bits/stdc++.h>\n#define For(i, a, b) for(int i = (a), en = (b); i <= en; ++i)\n#define Rof(i, a, b) for(int i = (a), en = (b); i >= en; --i)\n#define Tra(u, i) for(int i = hd[u]; ~i; i = e[i].net)\n#define cst const\n#define LL long long\n#define DD double\n#define LD long double\n#define pb push_back\n#define mp make_pair\n#define fir first\n#define sec second\n#define inf 0x3f3f3f3f\n#define Inf 0x3f3f3f3f3f3f3f3f\n#define eps 1e-12\n#define maxn 1000000\nusing namespace std;\n\nint n, a[maxn + 5], as = 0, pre[maxn + 5], net[maxn + 5], to[maxn + 5], cnt[maxn + 5];\nmap<int, int> ma;\nvoid chkmn(int &x, int y){if(x > y) x = y;}\nvoid chkmx(int &x, int y){if(x < y) x = y;}\nint tr[2][maxn + 5];\nvoid ins(int ty, int x, int y){\n\tx = maxn - x + 1;\n\twhile(x <= maxn) ty ? chkmx(tr[ty][x], y) : chkmn(tr[ty][x], y), x += x & -x;\n}\nint que(int ty, int x){\n\tx = maxn - x + 1; int asi = ty ? 0 : inf;\n\twhile(x) ty ? chkmx(asi, tr[ty][x]) : chkmn(asi, tr[ty][x]), x -= x & -x;\n\treturn asi;\n}\nstruct Node{int mn, lpr;} poi[4 * maxn + 5];\nstruct Tree{\n\t#define ls rt << 1\n\t#define rs rt << 1 | 1\n\t#define mn(rt) poi[rt].mn\n\t#define lpr(rt) poi[rt].lpr\n\tvoid upd(int rt){mn(rt) = min(mn(ls), mn(rs));}\n\tvoid mson(int rt, int x){\n\t\tmn(rt) += x;\n\t\tlpr(rt) += x;\n\t}\n\tvoid spr(int rt){\n\t\tif(!lpr(rt)) return;\n\t\tmson(ls, lpr(rt));\n\t\tmson(rs, lpr(rt));\n\t\tlpr(rt) = 0;\n\t}\n\tvoid mdy(int rt, int nl, int nr, int ql, int qr, int x){\n\t\tif(ql > qr) return;\n\t\tif(ql <= nl && qr >= nr) return mson(rt, x);\n\t\tspr(rt);\n\t\tint mid = nl + nr >> 1;\n\t\tif(ql <= mid) mdy(ls, nl, mid, ql, qr, x);\n\t\tif(qr > mid) mdy(rs, mid + 1, nr, ql, qr, x);\n\t\tupd(rt);\n\t}\n\tvoid sol(int rt, int nl, int nr, int ql, int qr){\n\t\tif(mn(rt)) return;\n\t\tif(nl == nr){\n\t\t\tint mn = que(0, nl), mx = que(1, nl);\n\t\t\tif((mn + mx) * (mx - mn + 1) / 2 == qr - nl + 1) as++;\n\t\t\treturn;\n\t\t}\n\t\tspr(rt);\n\t\tint mid = nl + nr >> 1;\n\t\tif(ql <= mid) sol(ls, nl, mid, ql, qr);\n\t\tif(qr > mid) sol(rs, mid + 1, nr, ql, qr);\n\t}\n\tvoid quee(int rt, int nl, int nr){\n\t\tif(nl == nr) return (void)(cout << mn(rt) << \" \");\n\t\tspr(rt);\n\t\tint mid = nl + nr >> 1;\n\t\tquee(ls, nl, mid); quee(rs, mid + 1, nr);\n\t}\n} tr1;\n\ntemplate <class T>\nvoid read(T &x){\n\tchar ch;\n\tbool ok;\n\tfor(ok = 0, ch = getchar(); !isdigit(ch); ch = getchar()) if(ch == '-') ok = 1;\n\tfor(x = 0; isdigit(ch); x = x * 10 + ch - '0', ch = getchar());\n\tif(ok) x = -x;\n}\n\nvoid mdy(int x, int y){\n\tif(!x) return;\n\tif(cnt[x] > a[x]) tr1.mdy(1, 1, n, to[x] + 1, x, y), tr1.mdy(1, 1, n, 1, pre[to[x]], y);\n\telse if(cnt[x] == a[x]) tr1.mdy(1, 1, n, to[x] + 1, x, y);\n\telse tr1.mdy(1, 1, n, 1, x, y);\n\tins(0, x, a[x]);\n\tins(1, x, a[x]);\n\t//if(x == 2) cout << que(0, x) << endl;\n}\n\nint main(){\n\t//freopen(\"in\", \"r\", stdin);\n\tmemset(tr[0], inf, sizeof tr[0]);\n\tread(n);\n\tFor(i, 1, n){\n\t\tread(a[i]);\n\t\tnet[pre[i] = ma[a[i]]] = i;\n\t\tma[a[i]] = i;\n\t\tcnt[i] = cnt[pre[i]] + 1;\n\t\tif(a[i] == 1) to[i] = i;\n\t\telse if(cnt[i] > a[i]) to[i] = net[to[pre[i]]];\n\t\telse if(cnt[i] == a[i]) to[i] = to[pre[i]];\n\t\telse if(cnt[i] == 1) to[i] = i;\n\t\telse to[i] = to[pre[i]];\n\t\tmdy(pre[i], -1);\n\t\tmdy(i, 1);\n\t\ttr1.sol(1, 1, n, 1, i);\n\t\t/*tr1.quee(1, 1, n);\n\t\tputs(\"\");*/\n\t}\n\tprintf(\"%d\\n\", as);\n\treturn 0;\n}\n```",
        "postTime": 1603459587,
        "uid": 114164,
        "name": "lprdsb",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P6854 \u3010Tram\u3011"
    },
    {
        "content": "\u6211\u4eec\u4ece\u9898\u76ee\u7684\u7279\u6b8a\u6027\u5165\u624b\u3002\u53d1\u73b0\u9898\u76ee\u63d0\u9192\u4f60\u7b54\u6848\u53ef\u80fd\u4f1a\u8d85\u8fc7 int\u3002\u51b7\u9759\u5206\u6790\u4e00\u6ce2\u53d1\u73b0\u7b54\u6848\u4e0a\u754c\u662f $O(n\\sqrt{n})$ \u7ea7\u522b\u7684\uff0c\u4e14\u5927\u591a\u6570\u60c5\u51b5\u662f $O(n)$ \u7684\u3002\n\n\u6211\u4eec\u518d\u53d1\u73b0\u53bb\u6389\u503c\u57df\u8fde\u7eed\u7684\u6027\u8d28\u4e4b\u540e\u7b54\u6848\u4e0a\u754c\u662f\u4e0d\u4f1a\u53d8\u7684\u3002\n\n\u4e8e\u662f\u62ff\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u4e2a\u6570\u53ef\u4ee5\u53d6\u7684\u533a\u95f4\uff0c\u66b4\u529b\u628a\u6240\u6709\u53ef\u80fd\u7684\u4f4d\u7f6e\u90fd\u62ff\u51fa\u6765\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u590d\u6742\u5ea6 $O(n\\sqrt{n}\\log n)$\uff0c\u4e14\u591a\u6570\u60c5\u51b5\u662f $O(n\\log n)$\u3002\n\n```cpp\nconst int MAXN = 1e6 + 5;\nint smn[MAXN][20], smx[MAXN][20], n, a[MAXN], lg2[MAXN], rk[MAXN];\nvector < int > pos[MAXN];\ninline int check(int l, int r) {\n\tint d = lg2[r - l + 1], mn = min(smn[l][d], smn[r - (1 << d) + 1][d]), mx = max(smx[l][d], smx[r - (1 << d) + 1][d]);\n\treturn 1ll * (mx + mn) * (mx - mn + 1) == 2 * (r - l + 1);\n}\nstruct SMT {\n\tstatic const int N = MAXN << 2;\n\t#define ls (k << 1)\n\t#define rs (k << 1 | 1)\n\t#define mid ((l + r) >> 1)\n\tint mn[N], tag[N];\n\tinline void pushr(int k, int v) {\n\t\tmn[k] += v, tag[k] += v;\n\t}\n\tinline void pushdown(int k) {\n\t\tif(tag[k])\n\t\t\tpushr(ls, tag[k]), pushr(rs, tag[k]), tag[k] = 0;\n\t}\n\tvoid update(int k, int l, int r, int ql, int qr, int val) {\n\t\tif(l == ql && r == qr) return pushr(k, val);\n\t\tpushdown(k);\n\t\tif(qr <= mid) update(ls, l, mid, ql, qr, val);\n\t\telse if(mid < ql) update(rs, mid+1, r, ql, qr, val);\n\t\telse update(ls, l, mid, ql, mid, val), update(rs, mid+1, r, mid+1, qr, val);\n\t\tmn[k] = min(mn[ls], mn[rs]);\n\t}\n\tint query(int k, int l, int r, int ql, int qr) { \n\t\tif(mn[k]) return 0;\n\t\tif(l == r) return check(l, qr);\n\t\tpushdown(k);\n\t\tint res = 0;\n\t\tif(mid >= ql) res += query(ls, l, mid, ql, qr);\n\t\tif(mid < qr) res += query(rs, mid+1, r, ql, qr); \n\t\treturn res;\n\t}\n}tr;\nsigned main()\n{\n\t#ifndef ONLINE_JUDGE \n    \tfile(\"pro\");\n    #endif\n    n = read();\n    For(i, 1, 1000000) pos[i].pb(0);\n    For(i, 1, n) smn[i][0] = smx[i][0] = a[i] = read(), pos[a[i]].pb(i), rk[i] = pos[a[i]].size() - 1;\n    lg2[1] = 0; For(i, 2, n) lg2[i] = lg2[i >> 1] + 1;\n    For(j, 1, 19) {\n\t\tFor(i, 1, (n - (1 << (j - 1)))) {\n\t\t\tsmn[i][j] = min(smn[i][j - 1], smn[i + (1 << (j - 1))][j - 1]);\n\t\t\tsmx[i][j] = max(smx[i][j - 1], smx[i + (1 << (j - 1))][j - 1]);\n\t\t}\n\t}\n\tint ans = 0;\n\tFor(i, 1, n) {\n\t\ttr.update(1, 1, n, pos[a[i]][rk[i]-1] + 1, i, 1);\n\t\tif(rk[i] < a[i]) continue;\n\t\ttr.update(1, 1, n, pos[a[i]][rk[i] - a[i]] + 1, pos[a[i]][rk[i] - a[i] + 1], -1);\n\t\tif(rk[i] != a[i]) tr.update(1, 1, n, pos[a[i]][rk[i] - a[i] - 1] + 1, pos[a[i]][rk[i] - a[i]], 1);\n\t\tans += tr.query(1, 1, n, 1, i);\n\t}\n\tcout << ans << endl;\n    return FastIO::Fflush(), 0;\n}\n/*\n\n*/\n\n\n```",
        "postTime": 1603160486,
        "uid": 55078,
        "name": "YLWang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6854 \u3010Tram\u3011"
    }
]