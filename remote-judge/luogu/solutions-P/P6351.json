[
    {
        "content": "\u663e\u7136\u7528 LCT \u52a8\u6001\u7ef4\u62a4\u8fb9\u53cc\u8054\u901a\u5206\u91cf\u53ef\u4ee5\u901a\u8fc7\u672c\u9898\uff0c\u4f46\u7801\u91cf\u592a\u5927\uff0c\u4e8e\u662f\u6211\u6362\u4e86\u79cd~~\u7801\u91cf\u66f4\u5927\u7684~~\u5199\u6cd5\u901a\u8fc7\u4e86\u672c\u9898\u3002\n\n\u5220\u8fb9\u4e0d\u597d\u5904\u7406\uff0c\u6b63\u96be\u5219\u53cd\uff0c\u8003\u8651\u5c06\u8be2\u95ee\u79bb\u7ebf\uff0c\u5c06\u5220\u8fb9\u53d8\u4e3a\u52a0\u8fb9\uff0c\u663e\u7136\u5148\u52a0\u5165\u7684\u8fb9\u4e0d\u4f1a\u5bf9\u540e\u52a0\u5165\u7684\u8fb9\u9020\u6210\u5f71\u54cd\uff0c\u4e8e\u662f\u6c42\u51fa\u539f\u56fe\u4ee5\u52a0\u5165\u65f6\u95f4\u4e3a\u5173\u952e\u5b57\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u7136\u540e\u6811\u94fe\u5256\u5206\uff0c\u52a0\u8fb9\u64cd\u4f5c\u5c31\u662f\u5c06\u6811\u4e0a\u4e24\u70b9\u95f4\u8def\u5f84\u7684\u8fb9\u6743\u5168\u90e8\u52a0\u4e00\uff0c\u8be2\u95ee\u64cd\u4f5c\u5c31\u662f\u67e5\u8be2\u6811\u4e0a\u4e24\u70b9\u95f4\u8def\u5f84\u7684\u8fb9\u6743\u7684\u6700\u5c0f\u503c\u662f\u5426\u5927\u4e8e\u6216\u7b49\u4e8e\u4e8c\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u5751\u70b9\uff1a\n\n- \u7531\u4e8e\u662f\u8fb9\u6743\u8f6c\u70b9\u6743\uff0c\u52a0\u8fb9\u64cd\u4f5c\u65f6\u4e0d\u8981\u7ed9 LCA \u5bf9\u5e94\u7684\u8fb9\u52a0\u4e00\u3002\n\n- \u539f\u56fe\u53ef\u80fd\u4e0d\u8fde\u901a\uff0ckruskal\u6c42\u51fa\u7684\u53ef\u80fd\u662f\u4e00\u4e2a\u68ee\u6797\uff0c\u8981\u5bf9\u6bcf\u68f5\u6811\u8dd1\u4e00\u904d\u6811\u94fe\u5256\u5206\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nconst int maxn=1e5+10;\nint m,n,ql;\nnamespace tree{\n\tstruct edge{\n\t\tint to,nxt;\n\t}e[maxn<<1];\n\tint hd[maxn],len;\n\tinline void addedge(int fr,int to){\n\t\te[++len]={to,hd[fr]};\n\t\thd[fr]=len;\n\t}\n\tint cnt,dep[maxn],fa[maxn],rev[maxn],seg[maxn],siz[maxn],son[maxn],top[maxn];\n\tvoid dfs1(int p,int f){\n\t\tdep[p]=dep[f]+1;\n\t\tfa[p]=f;\n\t\tsiz[p]=1;\n\t\tfor(ri i=hd[p];i;i=e[i].nxt)\n\t\t\tif(e[i].to!=f){\n\t\t\t\tdfs1(e[i].to,p);\n\t\t\t\tsiz[p]+=siz[e[i].to];\n\t\t\t\tif(siz[e[i].to]>siz[son[p]])son[p]=e[i].to;\n\t\t\t}\n\t}\n\tvoid dfs2(int p,int k){\n\t\tseg[p]=++cnt;\n\t\trev[cnt]=p;\n\t\ttop[p]=k;\n\t\tif(son[p]){\n\t\t\tdfs2(son[p],k);\n\t\t\tfor(ri i=hd[p];i;i=e[i].nxt)\n\t\t\t\tif(!top[e[i].to])\n\t\t\t\t\tdfs2(e[i].to,e[i].to);\n\t\t}\n\t}\n\tstruct segment_tree{\n\t\tint l,r,v,tag;\n\t}t[maxn<<2];\n\t#define ls(p) (p<<1)\n\t#define rs(p) (p<<1|1)\n\tinline void push_up(int p){\n\t\tt[p].v=min(t[ls(p)].v,t[rs(p)].v);\n\t}\n\tinline void push_down(int p){\n\t\tif(!t[p].tag)return;\n\t\tt[ls(p)].v+=t[p].tag,t[ls(p)].tag+=t[p].tag;\n\t\tt[rs(p)].v+=t[p].tag,t[rs(p)].tag+=t[p].tag;\n\t\tt[p].tag=0;\n\t}\n\tvoid build(int p,int l,int r){\n\t\tt[p].l=l,t[p].r=r;\n\t\tif(l==r)return;\n\t\tint mid=l+r>>1;\n\t\tbuild(ls(p),l,mid);\n\t\tbuild(rs(p),mid+1,r);\n\t}\n\tvoid modify(int p,int l,int r){\n\t\tif(t[p].l>r||l>t[p].r)return;\n\t\tif(l<=t[p].l&&t[p].r<=r){\n\t\t\t++t[p].v,++t[p].tag;\n\t\t\treturn;\n\t\t}\n\t\tpush_down(p);\n\t\tmodify(ls(p),l,r);\n\t\tmodify(rs(p),l,r);\n\t\tpush_up(p);\n\t}\n\tinline void modify_chain(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\t\tmodify(1,seg[top[x]],seg[x]);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(x==y)return;\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tmodify(1,seg[x]+1,seg[y]);\n\t}\n\tint query(int p,int l,int r){\n\t\tif(t[p].l>r||l>t[p].r)return INT_MAX;\n\t\tif(l<=t[p].l&&t[p].r<=r)return t[p].v;\n\t\tpush_down(p);\n\t\treturn min(query(ls(p),l,r),query(rs(p),l,r));\n\t}\n\tinline int query_chain(int x,int y){\n\t\tri ret=INT_MAX;\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\t\tret=min(ret,query(1,seg[top[x]],seg[x]));\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(x==y)return ret;\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\treturn min(ret,query(1,seg[x]+1,seg[y]));\n\t}\n}\nnamespace MST{\n\tstruct edge{\n\t\tint fr,to,tim;\n\t\tbool mst;\n\t\tinline bool operator<(const edge &k)const{\n\t\t\treturn tim<k.tim;\n\t\t}\n\t};\n\tvector<edge>e;\n\tstruct dsu{\n\t\tint fa[maxn];\n\t\tinline void init(int siz){for(ri i=1;i<=siz;++i)fa[i]=i;}\n\t\tint find(int k){return k==fa[k]?k:fa[k]=find(fa[k]);}\n\t}d;\n\tinline void kruskal(){\n\t\td.init(n);\n\t\tsort(e.begin(),e.end());\n\t\tri tot=1;\n\t\tfor(ri i=0;i<e.size();++i){\n\t\t\tri x=d.find(e[i].fr),y=d.find(e[i].to);\n\t\t\tif(x!=y){\n\t\t\t\td.fa[x]=y;\n\t\t\t\ttree::addedge(e[i].fr,e[i].to);\n\t\t\t\ttree::addedge(e[i].to,e[i].fr);\n\t\t\t\te[i].mst=true;\n\t\t\t\tif(++tot==n)return;\n\t\t\t}\n\t\t}\n\t}\n}\ntypedef pair<int,int> pii;\nmap<pii,int>id;\nstruct qry{\n\tchar op[5];\n\tint x,y;\n}q[maxn];\nvector<bool>ans;\nint main(){\n\tscanf(\"%d%d%d\",&n,&m,&ql);\n\tfor(ri i=0;i<m;++i){\n\t\tri x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tid[pii(x,y)]=id[pii(y,x)]=MST::e.size();\n\t\tMST::e.push_back({x,y});\n\t}\n\tfor(ri i=1;i<=ql;++i)scanf(\"%s%d%d\",q[i].op,&q[i].x,&q[i].y);\n\tfor(ri i=ql,j=1;i;--i)\n\t\tif(*q[i].op=='P')++j;\n\t\telse MST::e[id[pii(q[i].x,q[i].y)]].tim=j;\n\tMST::kruskal();\n\tfor(ri i=1;i<=n;++i)\n\t\tif(!tree::top[i]){\n\t\t\ttree::dfs1(i,0);\n\t\t\ttree::dfs2(i,i);\n\t\t}\n\ttree::build(1,1,tree::cnt);\n\tMST::d.init(n);\n\tfor(ri i=0;i<m;++i)\n\t\tif(!MST::e[i].tim){\n\t\t\tri x=MST::d.find(MST::e[i].fr),y=MST::d.find(MST::e[i].to);\n\t\t\tif(x!=y)MST::d.fa[x]=y;\n\t\t\ttree::modify_chain(MST::e[i].fr,MST::e[i].to);\n\t\t}\n\tfor(ri i=ql;i;--i)\n\t\tif(*q[i].op=='P'){\n\t\t\tif(MST::d.find(q[i].x)!=MST::d.find(q[i].y))ans.push_back(false);\n\t\t\telse ans.push_back(tree::query_chain(q[i].x,q[i].y)>1);\n\t\t}\n\t\telse{\n\t\t\tri x=MST::d.find(q[i].x),y=MST::d.find(q[i].y);\n\t\t\tif(x!=y)MST::d.fa[x]=y;\n\t\t\ttree::modify_chain(q[i].x,q[i].y);\n\t\t}\n\tfor(ri i=ans.size()-1;~i;--i)puts(ans[i]?\"TAK\":\"NIE\");\n\treturn 0;\n}\n```\n",
        "postTime": 1618846755,
        "uid": 67942,
        "name": "meyi",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P6351 [PA2011]Hard Choice"
    },
    {
        "content": "\u5220\u8fb9\u64cd\u4f5c\u4e0d\u597d\u5904\u7406\uff0c\u6240\u4ee5\u5148\u5c06\u64cd\u4f5c\u5012\u5e8f\uff0c\u5c06\u5220\u8fb9\u8f6c\u5316\u4e3a\u52a0\u8fb9\u3002\n\n\u8003\u8651\u5bf9\u4e8e\u4e24\u4e2a\u70b9\u7684\u8be2\u95ee\uff0c\u82e5\u8fd9\u4e24\u70b9\u4e0d\u8fde\u901a\u6216\u8fd9\u4e24\u4e2a\u70b9\u5206\u522b\u5904\u4e8e\u4e24\u4e2a\u4e0d\u540c\u7684\u8fb9\u53cc\u8fde\u901a\u5206\u91cf\u4e2d\uff08\u4e24\u70b9\u95f4\u5b58\u5728\u6865\uff09\u65f6\uff0c\u662f\u4e0d\u6ee1\u8db3\u9898\u76ee\u8981\u6c42\u7684\u3002\n\n\u53ef\u4ee5\u7528$LCT$\u6765\u7ef4\u62a4\u539f\u56fe\u7684\u4e00\u4e2a\u751f\u6210\u6811\uff0c\u539f\u5148\u6bcf\u6761\u8fb9\u5e26\u6709\u8fb9\u6743\uff0c\u82e5\u5728\u539f\u56fe\u4e2d\u6216\u52a0\u8fb9\u8fc7\u7a0b\u4e2d\u51fa\u73b0\u4e86\u73af\uff0c\u5219\u5728\u6811\u4e0a\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8fb9\u5168\u90e8\u8fb9\u6743\u6e05\u96f6\u3002\n\n\u6b64\u65f6\u5982\u679c\u5bf9\u4e24\u70b9\u4e4b\u95f4\u6c42\u8def\u5f84\u6743\u503c\u548c\uff0c\u82e5\u5728\u539f\u56fe\u4e2d\u8fd9\u4e24\u70b9\u5904\u5728\u4e00\u4e2a\u73af\u4e0a\uff0c\u90a3\u4e48\u6743\u503c\u548c\u80af\u5b9a\u4e3a$0$\uff0c\u540c\u65f6\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u8fde\u901a\u6027\uff0c\u5c31\u53ef\u4ee5\u5bf9\u8be2\u95ee\u8fdb\u884c\u56de\u7b54\u4e86\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\u5427\u3002\n\n$code:$\n\n```cpp\n#include<bits/stdc++.h>\n#define maxn 300010\n#define mk make_pair\nusing namespace std;\ntemplate<typename T> inline void read(T &x)\n{\n    x=0;char c=getchar();bool flag=false;\n    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\n    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    if(flag)x=-x;\n}\nint n,m,qu,tot;\nint f[maxn],ans[maxn];\nint fa[maxn],ch[maxn][2],rev[maxn],val[maxn],sum[maxn],tag[maxn];\nchar opt[maxn][2];\nmap<pair<int,int>,int> mp;\nstruct edge\n{\n    int x,y;\n}e[maxn],q[maxn];\nint find(int x)\n{\n    return f[x]==x?x:f[x]=find(f[x]);\n}\nbool check(int x)\n{\n    return ch[fa[x]][1]==x;\n}\nvoid pushup(int x)\n{\n    sum[x]=val[x]+sum[ch[x][0]]+sum[ch[x][1]];\n}\nvoid pushrev(int x)\n{\n    rev[x]^=1,swap(ch[x][0],ch[x][1]);\n}\nvoid pushtag(int x)\n{\n    tag[x]=1,sum[x]=val[x]=0;\n}\nvoid pushdown(int x)\n{\n    int ls=ch[x][0],rs=ch[x][1];\n    if(rev[x]) pushrev(ls),pushrev(rs),rev[x]=0;\n    if(tag[x]) pushtag(ls),pushtag(rs),tag[x]=0;\n}\nbool notroot(int x)\n{\n    return ch[fa[x]][0]==x||ch[fa[x]][1]==x;\n}\nvoid rotate(int x)\n{\n    int y=fa[x],z=fa[y],k=check(x),w=ch[x][k^1];\n    if(notroot(y)) ch[z][check(y)]=x;\n    ch[x][k^1]=y,ch[y][k]=w;\n    if(w) fa[w]=y;\n    fa[x]=z,fa[y]=x;\n    pushup(y),pushup(x);\n}\nvoid all(int x)\n{\n    if(notroot(x)) all(fa[x]);\n    pushdown(x);\n}\nvoid splay(int x)\n{\n    all(x);\n    for(int y;notroot(x);rotate(x))\n        if(notroot(y=fa[x]))\n            rotate(check(x)^check(y)?x:y);\n    pushup(x);\n}\nvoid access(int x)\n{\n    for(int y=0;x;y=x,x=fa[x])\n        splay(x),ch[x][1]=y,pushup(x);\n}\nvoid makeroot(int x)\n{\n    access(x),splay(x),pushrev(x);\n}\nvoid split(int x,int y)\n{\n    makeroot(x),access(y),splay(y);\n}\nvoid link(int x,int y)\n{\n\tmakeroot(x),fa[x]=y;\n}\nvoid Link(int x,int y)\n{\n    f[find(x)]=find(y),val[++tot]=1;\n    link(x,tot),link(tot,y);\n}\nint query(int x,int y)\n{\n    split(x,y);\n    return sum[y];\n}\nint main()\n{\n    read(n),read(m),read(qu),tot=n;\n    for(int i=1;i<=n;++i) f[i]=i;\n    for(int i=1;i<=m;++i)\n    {\n        read(e[i].x),read(e[i].y);\n        if(e[i].x>e[i].y) swap(e[i].x,e[i].y);\n    }\n    for(int i=1;i<=qu;++i)\n    {\n        scanf(\"%s\",opt[i]),read(q[i].x),read(q[i].y);\n        if(q[i].x>q[i].y) swap(q[i].x,q[i].y);\n        if(opt[i][0]=='Z') mp[mk(q[i].x,q[i].y)]=1;\n    }\n    for(int i=1;i<=m;++i)\n    {\n        int x=e[i].x,y=e[i].y;\n        if(mp.count(mk(x,y))||find(x)==find(y)) continue;\n        mp[mk(x,y)]=1,Link(x,y);\n    }\n    for(int i=1;i<=m;++i)\n    {\n        int x=e[i].x,y=e[i].y;\n        if(mp.count(mk(x,y))) continue;\n        split(x,y),pushtag(y);\n    }\n    for(int i=qu;i;--i)\n    {\n        int x=q[i].x,y=q[i].y;\n        if(opt[i][0]=='Z')\n        {\n            if(find(x)==find(y)) split(x,y),pushtag(y);\n            else Link(x,y);\n        }\n        else\n        {\n            ans[i]=query(x,y);\n            if(find(x)!=find(y)) ans[i]=1;\n        }\n    }\n    for(int i=1;i<=qu;++i)\n    {\n        if(opt[i][0]=='P')\n        {\n            if(ans[i]) puts(\"NIE\");\n            else puts(\"TAK\");\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1586708849,
        "uid": 172489,
        "name": "lhm_",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P6351 \u3010[PA2011]Hard Choice\u3011"
    }
]