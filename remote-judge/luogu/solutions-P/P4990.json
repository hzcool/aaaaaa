[
    {
        "content": "# \u4e3a\u4e86\u8ba9\u5927\u5bb6\u770b\u8d77\u6765\u65b9\u4fbf\uff0c\u4e8e\u662f\u9a8c\u9898\u4eba\u5c31\u628a\u9898\u89e3\u653e\u8fdb\u6765\u4e86\uff0c\u76f8\u5173\u9898\u76ee\u8bf7\u70b9\u51fb[\u8fd9\u91cc](https://blog.csdn.net/kkkksc03/article/details/83239164)\n\n## T4\n\n\u9898\u610f\u8f83\u4e3a\u590d\u6742\uff0c\u8be6\u89c1\u9898\u9762\u3002\n\n\u672c\u9898\u64cd\u4f5c\u8f83\u591a\uff0c\u524d\u9762\u7684\u6d4b\u8bd5\u70b9\u57fa\u672c\u4e0a\u90fd\u5206\u522b\u5bf9\u5e94\u4e00\u4e2a\u64cd\u4f5c\uff0c\u56e0\u6b64\u6211\u4eec\u9010\u4e2a\u6d4b\u8bd5\u70b9\u5206\u6790\u3002\n\n$1$\uff1a\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\u2026\u2026\n\n$2$\uff1a\u6700\u66b4\u529b\u7684\u65b9\u6cd5\u4e5f\u80fd\u8fc7\uff0c\u4e5f\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\u3002\n\n$4$\uff1a\u8fd9\u4e2a\u4e5f\u5f88\u7b80\u5355\uff0c\u76f4\u63a5\u8dd1\u4e00\u904d\u6700\u957f\u8def\u5373\u53ef\uff0c\u5f53\u7136\u88f8$dijkstra$\u662f\u8fc7\u4e0d\u4e86\u7684\uff0c\u9700\u8981\u52a0\u5806\u4f18\u5316\uff1b\n\n\u7531\u4e8e\u51fa\u9898\u4eba\u7684\u6570\u636e\u751f\u6210\u5668\u6bd4\u8f83\u6c34\uff0c\u751f\u6210\u4e2a\u6570\u636e\u90fd\u8981\u51e0\u5206\u949f\uff0c\u6240\u4ee5\u5f88\u826f\u5fc3\u5730\u6ca1\u6709\u5361$spfa$\u3002\n\n$3$\uff1a\u8fd9\u4e00\u6d4b\u8bd5\u70b9\u8fb9\u6743\u4e3a0\uff0c\u90a3\u5c31\u7701\u53bb\u4e86\u6700\u957f\u8def\u4e86\uff1b\n\n\u5982\u4f55\u5224\u65ad\u56fe\u7684\u8fde\u901a\u6027\uff1f\u987a\u7740\u53bb\u679a\u4e3e\u5e76\u6bcf\u6b21\u5224\u65ad\u8fde\u901a\u6027\uff0c\u663e\u7136\u4f1a\u8d85\u65f6\uff1b\n\n\u8fd9\u91cc\u6807\u7a0b\u7528\u4e86\u7b28\u529e\u6cd5\uff1a\u5206\u5757\u4e8c\u5206\uff1b\u7531\u4e8e\u5220\u9664\u7684\u8fb9\u4e0d\u8d85\u8fc71000\u6761\uff0c\u6700\u591a\u53ea\u4f1a\u628a\u64cd\u4f5c\u5206\u62101000\u4e2a\u90e8\u5206\uff0c\u6bcf\u4e00\u90e8\u5206\u64cd\u4f5c\u90fd\u662f\u6dfb\u52a0\u8fb9\uff0c\u663e\u7136\u6709\u5355\u8c03\u6027\uff01\n\n\u987a\u7740\u679a\u4e3e\u6bcf\u4e00\u90e8\u5206\u7684\u64cd\u4f5c\uff0c\u5728\u5904\u7406\u6bcf\u4e2a\u90e8\u5206\u65f6\u4e8c\u5206\u5224\u65ad\u8fde\u901a\u6027\uff0c\u53ef\u4ee5\u51cf\u5c11\u5224\u65ad\u7684\u6b21\u6570\uff0c\u4f18\u5316\u64cd\u4f5c\u65f6\u95f4\u3002\n\n\u81f3\u4e8e\u5220\u9664\u64cd\u4f5c\uff0c\u6211\u7528\u4e86\u6811\u72b6\u6570\u7ec4+\u4e8c\u5206\uff0c\u6811\u72b6\u6570\u7ec4\u5b58\u524d\u7f00\u548c\uff0c\u5373\u5b83\u662f\u7b2c\u51e0\u6761\u8fb9\uff0c\u7136\u540e\u4e8c\u5206\u5b83\u5728\u539f\u6570\u7ec4\u7684\u6807\u53f7\u5373\u53ef\u3002\n\n$5-6$\uff1a\u7ecf\u8fc7\u4e0a\u9762\u4e00\u756a\u5206\u6790\u5927\u5bb6\u5927\u6982\u4e5f\u6709\u6574\u4f53\u601d\u8def\u4e86\uff1a\u5148\u5206\u5757\u4e8c\u5206\u5224\u8fde\u901a\u6027\uff0c\u518d\u6c42\u6700\u957f\u8def\u3002\n\n\u8fd9\u91cc\u65e0\u6d88\u5931\u7684\u8fb9\uff0c\u90a3\u4e48\u7701\u53bb\u4e86\u5206\u5757\u4e0e\u5220\u9664\u64cd\u4f5c\uff0c\u5176\u5b83\u4e0e\u4e0a\u9762\u65b9\u6cd5\u4e00\u6837\u3002\n\n$7-8$\uff1a\u8fd9\u91cc\u4e5f\u662f\u975e\u5e38\u7b80\u5355\u7684\uff0c\u7531\u4e8e\u5220\u9664\u8fb9\u5bf9\u751f\u6210\u8fde\u901a\u56fe\u6ca1\u6709\u8d21\u732e\uff0c\u6240\u4ee5\u64cd\u4f5c\u540c$4$\u3002\n\n$9-10$\uff1a\u5176\u5b9e\u5c31\u662f\u6d4b\u8bd5\u70b9$3$+\u6d4b\u8bd5\u70b9$4$\uff0c\u7528$3$\u7684\u65b9\u6cd5\u5224\u65ad\u8fde\u901a\u6027\u540e\u6c42\u4e2a\u6700\u957f\u8def\u5373\u53ef\u3002\n\n\u53ef\u89c1\uff0c\u672c\u9898\u4e2d\u5176\u5b9e\u5927\u90e8\u5206\u5206\u90fd\u53ef\u4ee5\u6c34\u7684\uff0c\u800c\u8981AC\uff0c\u89e3\u51b3\u6d4b\u8bd5\u70b9$3$\u662f\u5173\u952e\u3002\n\n```\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n    struct newdata\n    {\n        int tm,type,u,v,w,k;\n    };\n    struct forward_star \n    {\n        int next,to,w;\n    };\n    int n,m,t,cnt,tot;\n    forward_star edge[1100001];\n    newdata work[100001];\n    int head[100001];\n    int heap[100001];\n    int que[100001];\n    int ref[100001];\n    int tree[1100001];\n    int dist[100001];\n    bool usable[1100001];\n    bool vis[100001];\nvoid add(int u,int v,int w)\n{\n    cnt++;\n    edge[cnt].to=v;\n    edge[cnt].w=w;\n    edge[cnt].next=head[u];\n    head[u]=cnt;\n}\nvoid adjust_up(int now)\n{\n    if (now>1&&dist[heap[now]]>dist[heap[now/2]])\n    {\n        ref[heap[now]]=now/2;\n        ref[heap[now/2]]=now;\n        swap(heap[now],heap[now/2]);\n        adjust_up(now/2);\n    }\n}\nvoid adjust_down(int now)\n{\n    if (now*2+1<=tot)\n    {\n        int k;\n        if (dist[heap[now*2+1]]>dist[heap[now*2]]) k=now*2+1; else k=now*2;\n        if (dist[heap[k]]>dist[heap[now]])\n        {\n            ref[heap[k]]=now;\n            ref[heap[now]]=k;\n            swap(heap[k],heap[now]);\n            adjust_down(k);\n        }\n    }\n    else if (now*2<=tot)\n    {\n        if (dist[heap[now*2]]>dist[heap[now]])\n        {\n            ref[heap[now]]=now*2;\n            ref[heap[now*2]]=now;\n            swap(heap[now],heap[now*2]);\n            adjust_down(now*2);\n        }\n    }\n}\nvoid addheap(int now)\n{\n    heap[++tot]=now;\n    ref[now]=tot;\n    adjust_up(tot);\n}\nvoid pushheap()\n{\n    heap[1]=heap[tot];\n    ref[heap[1]]=1;\n    tot--;\n    adjust_down(1);\n}\nvoid dijkstra_heap(int u)\n{\n    memset(vis,false,sizeof(vis));\n    memset(dist,255,sizeof(dist));\n    dist[u]=0;\n    vis[u]=true;\n    addheap(u);\n    while (tot!=0)\n    {\n        int now=heap[1];\n        pushheap();\n        int i=head[now];\n        while (i!=0)\n        {\n            if (usable[i]&&i<=cnt)\n                if (dist[now]+edge[i].w>dist[edge[i].to])\n                {\n                    dist[edge[i].to]=dist[now]+edge[i].w;\n                    if (!vis[edge[i].to])\n                    {\n                        vis[edge[i].to]=true;\n                        addheap(edge[i].to);\n                    } else adjust_up(ref[edge[i].to]);\n                }\n            i=edge[i].next;\n        }\n    }\n}\nbool cmp(newdata i,newdata j)\n{\n    return i.tm<j.tm;\n}\nbool check(int u,int v)\n{\n    memset(vis,false,sizeof(vis));\n    int top=1;\n    que[top]=u;\n    vis[u]=true; \n    while (top>0)\n    {\n        int now=que[top];\n        top--;\n        int i=head[now];\n        while (i!=0)\n        {\n            if (i<=cnt&&usable[i])\n                if (!vis[edge[i].to])\n                {\n                    if (edge[i].to==v) return true;\n                    vis[edge[i].to]=true;\n                    que[++top]=edge[i].to;\n                }\n            i=edge[i].next;\n        }\n    }\n    return false;\n}\nvoid adjust(int now)\n{\n    int i=now;\n    while (i>0)\n    {\n        i-=i&i;\n        tree[now]+=tree[i];\n    }\n    tree[now]++;\n}\nint sum(int now)\n{\n    int tot=0;\n    int i=now;\n    while (i>0)\n    {\n        tot+=tree[i];\n        i-=i&i;\n    }\n    return tot;\n}\nint solve(int now)\n{\n    int l=1;\n    int r=cnt;\n    while (l<r)\n    {\n        int mid=(l+r)>>1;\n        if (sum(mid)<now)\n            l=mid+1;\n        else r=mid-1;\n    }\n    tree[l]--;\n    return l;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=m;i++)\n    {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        add(u,v,w);\n        adjust(i);\n    }\n    memset(usable,true,sizeof(usable));\n    scanf(\"%d\",&t);\n    if (t==0)\n    {\n        dijkstra_heap(1);\n        if (dist[n]==-1)\n            printf(\"Continue from the last checkpoint\");\n        else\n        {\n            printf(\"0\\n\");\n            printf(\"%d\",dist[n]);\n        }\n        return 0;\n    }\n    else\n    {\n        bool occur=false;\n        bool disappear=false;\n        for (int i=1;i<=t;i++)\n        {\n            scanf(\"%d%d\",&work[i].tm,&work[i].type);\n            if (work[i].type==0)\n            { \n                scanf(\"%d%d%d\",&work[i].u,&work[i].v,&work[i].w);\n                occur=true;\n            }\n            else \n            {\n                scanf(\"%d\",&work[i].k);\n                disappear=true;\n            }\n        }\n        if (disappear&&!occur)\n        {\n            dijkstra_heap(1);\n            if (dist[n]==-1)\n                printf(\"Continue from the last checkpoint\");\n            else\n            {\n                printf(\"0\\n\");\n                printf(\"%d\",dist[n]);\n            }\n            return 0;\n        }\n        sort(work+1,work+t+1,cmp);\n        if (check(1,n))\n        {\n            printf(\"0\\n\");\n            dijkstra_heap(1);\n            printf(\"%d\",dist[n]);\n            return 0;\n        }\n        int l=1;\n        for (int i=1;i<=t;i++)\n            if (work[i].type==1)\n            {\n                int r=i-1;\n                if (l>=r)\n                {\n                    usable[solve(work[i].k)]=false;\n                    l=i+1;\n                    continue;\n                }\n                int cnt_first=cnt;\n                int l_first=l;\n                for (int j=l;j<=r;j++)\n                {\n                    add(work[j].u,work[j].v,work[j].w);\n                    adjust(cnt);\n                }\n                while (l<r-1)\n                {\n                    int mid=(l+r)>>1;\n                    cnt=cnt_first+mid-l_first+1;\n                    if (check(1,n))\n                        r=mid;\n                    else l=mid;\n                }\n                cnt=cnt_first+l-l_first+1;\n                if (check(1,n))\n                {\n                    printf(\"%d\\n\",work[l].tm);\n                    dijkstra_heap(1);\n                    printf(\"%d\",dist[n]);\n                    return 0;\n                }\n                cnt=cnt_first+r-l_first+1;\n                if (check(1,n))\n                {\n                    printf(\"%d\\n\",work[r].tm);\n                    dijkstra_heap(1);\n                    printf(\"%d\",dist[n]);\n                    return 0;\n                }\n                cnt=cnt_first+i-l_first+1;\n                usable[solve(work[i].k)]=false;\n                l=i+1;\n            }\n        int r=t;\n        int cnt_first=cnt;\n        int l_first=l;\n        for (int j=l;j<=r;j++)\n        {\n            add(work[j].u,work[j].v,work[j].w);\n            adjust(cnt);\n        }\n        while (l<r-1)\n        {\n            int mid=(l+r)>>1;\n            cnt=cnt_first+mid-l_first+1;\n            if (check(1,n))\n                r=mid;\n            else l=mid;\n        }\n        cnt=cnt_first+l-l_first+1;\n        if (check(1,n))\n        {\n            printf(\"%d\\n\",work[l].tm);\n            dijkstra_heap(1);\n            printf(\"%d\",dist[n]);\n            return 0;\n        }\n        cnt=cnt_first+r-l_first+1;\n        if (check(1,n))\n        {\n            printf(\"%d\\n\",work[r].tm);\n            dijkstra_heap(1);\n            printf(\"%d\",dist[n]);\n            return 0;\n        }\n        printf(\"Continue from the last checkpoint\");\n        return 0;\n    }\n    return 0;\n}\n```\n",
        "postTime": 1542415643,
        "uid": 45475,
        "name": "ShineEternal",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4990 \u3010\u5c0f\u57cb\u4e0e\u523a\u5ba2\u4f20\u5947\u3011"
    }
]