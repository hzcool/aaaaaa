[
    {
        "content": "\u4e0d\u77e5\u5230\u5927\u5bb6\u77e5\u4e0d\u77e5\u9053\u4e00\u4e2a\u59ff\u52bf\u53eb\u201c\u865a\u6811\u201d\n### \u865a\u6811\u7684\u6784\u5efa\n _\uff08\u8fd9\u91cc\u7684\u6784\u5efa\u865a\u6811\u6cd5\u8f83\u4e4b\u7f51\u4e0a\u7684\u66f4\u4e3a\u7b80\u5355\u7c97\u66b4\uff0c\u5982\u679c\u60f3\u770b\u4f18\u96c5\u4e00\u70b9\u7684\uff0c\u81ea\u884c\u767e\u5ea6\u597d\u4e86\uff09_\n \n \u5148\u8bf4\u5565\u53eb\u865a\u6811\uff0c\u865a\u6811\uff0c\u5e76\u4e0d\u662f\u4e0d\u5b58\u5728\u7684\u6811\uff0c\u76f8\u53cd\uff0c\u4ed6\u662f\u4e00\u4e2a\u5927\u6811\u7684\u4e00\u90e8\u5206\uff0c\u51ed\u501f\u4e00\u4e2a\u865a\u6811\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\u6574\u4f53\u7684\u90e8\u5206\u4fe1\u606f\u3002\u5982\u679c\u7c7b\u6bd4\u4e8e\u5e8f\u5217\uff0c\u865a\u6811\u548c\u5927\u6811\u76f8\u5f53\u4e8e\uff0c\u5b50\u5e8f\u5217\u548c\u5e8f\u5217\uff0c\u800c\u5b50\u6811\u548c\u5927\u6811\u76f8\u5f53\u4e8e\u5b50\u533a\u95f4\u548c\u533a\u95f4\u3002\n \n \u597d\u4e86\u8fd8\u662f\u8bb2\u8fd9\u9053\u9898\u5427\uff0c\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u6709\u8da3\u7684\u4e8b\u5b9esigma k\u662fO(n)\u7684\n \u5982\u679c\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u8be2\u95ee\u505a\u4e00\u4e2a\u6811\u5f62dp\uff0c\u590d\u6742\u5ea6\u8fc7\u9ad8\u800c\u65e0\u6cd5\u627f\u53d7\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u60f3\u4e00\u4e2a\u529e\u6cd5\uff0c\u628a\u6bcf\u4e00\u6b21\u6811\u5f62dp\u7684\u590d\u6742\u5ea6\u964d\u5230O(k)\u7ea7\u522b\uff0c\u8fd9\u6837\u603b\u590d\u6742\u5ea6\u964d\u81f3O(n)\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u8981\u4ece\u539f\u6765\u7684\u6811\u4e0a\u201c\u62bd\u53d6\u201d\u4e00\u53ea\u6811\uff0c\u5728\u8fd9\u4e2a\u6811\u4e0a\u9762\u8dd1\u6811\u5f62dp\u3002\n \n \u7136\u540e\u8fd9\u91cc\u5c31\u6709\u4e00\u4e2a\u865a\u6811\u7684\u6784\u5efa\u65b9\u6cd5\u4e86\uff0c\u6211\u4eec\u628a\u8be2\u95ee\u70b9\u6309\u7167\u5927\u6811\u4e0a\u7684dfs\u5e8f\u6392\u5e8f\n \uff0c\u4e4b\u540e\u6bcf\u4e2a\u76f8\u90bb\u70b9\u6c42\u4e00\u904dlca\uff0c\u5bf9\u4e8e\u8fd9\u4e9blca\u548c\u8be2\u95ee\u70b9\u6784\u6210\u7684\u70b9\u96c6\uff0c\u5982\u679c\u6211\u4eec\u628a\u6811\u4e0a\u8def\u5f84\u770b\u4f5c\u8fb9\uff0c\u8def\u5f84\u957f\u5ea6\u770b\u4f5c\u8fb9\u6743\uff0c\u90a3\u4e48\u8fd9\u4e9b\u70b9\u4e8b\u5b9e\u4e0a\u6784\u6210\u4e86\u4e00\u68f5\u6811\uff0c\u800c\u4e14\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u6811\u4e0a\u8fd8\u53ef\u4ee5\u8dd1\u6811\u5f62dp\uff0c\u800c\u5bf9\u4e8e\u8fd9\u9053\u9898\uff0c\u7ef4\u62a4\u7684\u4fe1\u606f\u5728\u5e26\u6743\u6811\u4e0a\u90fd\u662f\u53ef\u4ee5\u5b9e\u73b0\u7684\u3002\n \n \u4e0b\u9762\u662fdp\u505a\u6cd5\uff0c\n \n \u6211\u4eec\u8bbesum\\[i]\u8868\u793a\u4ee5i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u6240\u6709\u8be2\u95ee\u70b9\u5230i\u7684\u8def\u5f84\u957f\u5ea6\u4e4b\u548c\n \n \u8bbesiz\\[i]\u8868\u793a\u4ee5i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8be2\u95ee\u70b9\u7684\u4e2a\u6570\u3002\n \n min\\[i]\u8868\u793a\u4ee5i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8be2\u95ee\u70b9\u5230i\u7684\u6700\u77ed\u8def\u5f84\n \n max\\[i]\u8868\u793a\u4ee5i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8be2\u95ee\u70b9\u5230i\u7684\u6700\u957f\u8def\u5f84\n \n \u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u662f\u53ef\u4ee5\u5411\u4e0a\u9012\u63a8\u7684\uff0c\u6211\u4eec\u5728\u8fd9\u53ea**\u865a\u6811\u4e0adfs**\uff0c\u904d\u5386\u70b9u\u7684\u6240\u6709\u51fa\u8fb9\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8981\u8003\u8651u\u7684\u6240\u6709\u513f\u5b50\u5f62\u6210\u7684\u7c7b\u4f3c\u4e8ev1-u-v2\u7684\u8def\u5f84\uff0c\u6362\u8a00\u4e4b\uff0c\u6211\u4eecdp\u51fa\u6765\u7684\u662f\u6811\u4e0a\u8def\u5f84\u7684\u4e00\u534a\uff0c\u7136\u540e\u901a\u8fc7dfs\u679a\u4e3elca\u628adp\u51fa\u6765\u7684\u8def\u5f84\u63a5\u8d77\u6765\n \n \u5148\u8bf4min\u548cmax\u5427\n \n \u6211\u4eec\u53d1\u73b0\uff0c\u904d\u5386u\u7684\u51fa\u8fb9\u65f6\uff0c\u5982\u679c\u66f4\u65b0u\u7684dp\u503c\u66f4\u65b0\u5230\u4e00\u534a\uff0c\u5047\u8bbe\u8981\u66f4\u65b0vi\u8fd9\u4e2a\u513f\u5b50\u90a3\u4e48\u6b64\u65f6min\\[u]\u7684\u503c\u662fmin\\[v1]\\~min\\[vi-1]\u7684\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528min\\[vi]+min\\[u]\u66f4\u65b0\u4e00\u53d1\u7b54\u6848\uff0c\u6700\u5927\u503c\u540c\u7406\u7684\u53ef\u4ee5\u5982\u6b64\u66f4\u65b0\n \n \u7136\u540e\u8bf4\u6bd4\u8f83\u8fa3\u624b\u7684sum\n \n \u53ef\u80fd\u9700\u8981\u4e00\u70b9\u6570\u5b66\u8bc1\u660e\n \n \u5047\u8bbe\u70b9v1,v2\u7684\u7236\u4eb2\u90fd\u662fu\n \u6709\u4e00\u4e2a\u4ee5v1\u4e3a\u6839\u7684\u5b50\u6811\uff0c\u91cc\u8fb9\u8be2\u95ee\u70b9q1,q2,\u2026\u2026qi\u5230u\u7684\u8def\u5f84\u957f\u5ea6\u8bb0\u4e3a\n a1,a2\u2026\u2026ai\uff0c\u53c8\u6709\u4e00\u4e2a\u4ee5v2\u4e3a\u6839\u7684\u5b50\u6811\uff0c\u91cc\u8fb9\u8be2\u95ee\u70b9p1,p2\u2026\u2026pi\u5230u\u7684\u8def\u5f84\u957f\u5ea6\u8bb0\u4e3ab1,b2\u2026\u2026bi\uff0c\n \u90a3\u4e48v1\u4e2d\u7684\u8be2\u95ee\u70b9\u5230v2\u4e2d\u8be2\u95ee\u70b9\u7684\u8def\u5f84\u957f\u5ea6\u4e4b\u548c\u5c31\u662f\n \n sigma(sigma(ai+bj) \\[j\u22081~siz\\[v2]] ) \\[i\u22081~siz\\[v1]]\n \n =(sum\\[v1]+dis(v1,u))\\*siz\\[v2]+(sum\\[v2]+dis(v2,u))\\*siz\\[v1]\n \n \u5c31\u662fv1\u91cc\u7684\u6bcf\u4e00\u6761\u8def\u5f84\u88ab\u7edf\u8ba1\u4e86siz\\[v2]\u6b21\uff0cv2\u4e2d\u7684\u6bcf\u4e00\u6761\u8def\u5f84\u88ab\u7edf\u8ba1\u4e86siz\\[v1]\u6b21\n \n\u90a3\u4e48\u6211\u4eec\u73b0\u5728\u6709\u4e86\u4e00\u4e2a\u5408\u5e76sum\\[v1]\uff0csum\\[v2]\u7684\u516c\u5f0f\uff0c\u73b0\u5728\u6211\u4eec\u8981\u5408\u5e76u\u7684\u6240\u6709\u513f\u5b50v1,v2,\u2026\u2026vi\n\n\u6211\u4eec\u8fd8\u662f\u8003\u8651dp\u5230\u4e86\u4e00\u534a\u7684\u65f6\u5019\uff0c\u6211\u4eec\u73b0\u5728\u8981\u66f4\u65b0vi\u8fd9\u4e2a\u513f\u5b50\uff0c\u90a3\u4e48sum\\[u]\u5176\u5b9e\u662fsum\\[v1]~sum\\[vi-1]\u7684\u548c\uff0csiz\\[u]\u5176\u5b9e\u662fsiz\\[v1]~siz\\[vi-1]\u7684\u548c\uff0c\u90a3\u4e48\u6211\u4eec\u7684v1\u8981\u548c\u524d\u9762\u7684\u6bcf\u4e00\u4e2a\u5b69\u5b50\u5408\u5e76\u4e00\u6b21\uff0c\u5229\u7528\u4e58\u6cd5\u5206\u914d\u7387\u53ef\u5f97\uff1a\n\n\u7b54\u6848+=siz\\[u]\\*(sum\\[vi]+dis(vi,u))+siz\\[vi]\\*sum\\[u]\n\n\u597d\u4e86\u73b0\u5728sum\u4e5f\u53ef\u4ee5\u66f4\u65b0\u4e86\n\n\u73b0\u5728\u662f\u6700\u540e\u7684\u95ee\u9898\uff0c\u5982\u4f55\u5728\u865a\u6811\u4e0adfs\uff1f,\u603b\u4e0d\u80fdn^2\u679a\u4e3e\u6bcf\u4e2a\u70b9\u8fde\u8fb9\u5427\uff0c\u53e6\u5916\u7a7a\u95f4\u5b58\u50a8\u4e5f\u4f1a\u5f88\u70e6\uff0c\u5982\u679c\u4f60\u53bb\u7f51\u4e0a\u641c\u7d22\u7684\u8bdd\uff0c\u4f60\u4f1a\u53d1\u73b0\u4ed6\u4eec\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4ec0\u4e48\u6700\u53f3\u94fe\uff0c\u50cf\u626b\u63cf\u7ebf\u4e00\u6837\u628a\u6574\u53ea\u865a\u6811\u626b\u4e86\u4e00\u904d\uff0c\u8d77\u5230\u4e86dfs\u7684\u6548\u679c(\u849f\u84bb\u8868\u793a\u4e0d\u4f1aQAQ)\n\n\u6240\u4ee5\u8fd9\u91cc\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u4e2a\u66b4\u529b\u7684\u65b9\u6cd5\uff1a\u56de\u60f3\u4e00\u4e0bdfs\u7684\u65f6\u5019\uff0c\u8ba1\u7b97\u673a\u5230\u5e95\u5e72\u4e86\u4ec0\u4e48\uff0c\u5176\u5b9e\u662f\u5f00\u4e86\u4e00\u4e2a\u6808\uff0c\u6309\u7167\u7ed9\u5b9a\u7684\u6307\u4ee4\u4e0d\u505cpushpop\u5bf9\u5427\uff0c\u90a3\u4e48\u5982\u679c\u6211\u4eec\u4e0d\u77e5\u9053\u6811\u7684\u7ed3\u6784\uff0c\u4f46\u662f\u5374\u77e5\u9053dfs\u7684\u65f6\u5019\u4ec0\u4e48\u65f6\u5019push\u548cpop\u4ec0\u4e48\u70b9\uff0c\u518d\u7ed9\u6211\u4eec\u4e00\u4e2a\u6808\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5728\u4e0d\u77e5\u9053\u6811\u7684\u771f\u5b9e\u7ed3\u6784\u7684\u60c5\u51b5\u4e0bdfs\u3002\n\n\u8fd9\u91cc\u5b89\u5229\u4e00\u4e2a\u53eb\u6b27\u62c9\u5e8f\u7684\u597d\u4e1c\u897f\uff0c\u666e\u901a\u7684dfs\u5e8f\u53ea\u8bb0\u5f55\u5165\u6808\u65f6\u95f4\uff0c\u4f46\u662f\u6b27\u62c9\u5e8f\u540c\u65f6\u8bb0\u5f55\u5165\u6808\u548c\u51fa\u6808\u65f6\u95f4\uff0c\u5165\u6808\u4e3a+\uff0c\u51fa\u6808\u4e3a-\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u6211\u4eec\u53ea\u8981\u624b\u91cc\u6709\u6b27\u62c9\u5e8f\u5c31\u53ef\u4ee5dfs\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u865a\u6811\u548c\u539f\u6811\u7684dfs\u76f8\u5bf9\u6b21\u5e8f\u662f\u5b8c\u5168\u4e00\u6837\u7684\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u5148\u628a\u8be2\u95ee\u70b9dfs\u5e8f\u6392\u5e8f\u4e00\u904d\uff0c\u4e4b\u540e\u6c42\u51falca\uff0c\u6700\u540e\u628a\u6574\u4e2a\u70b9\u96c6\u6309\u7167\u6b27\u62c9\u5e8f\u6392\u5e8f(\u8bb0\u5f97\u4e00\u4e2a\u70b9\u52a0\u4e24\u6b21)\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u865a\u6811\u7684\u6b27\u62c9\u5e8f\uff0c\u5f00\u4e2a\u6808\u66b4\u529bdfs\u4e00\u4e00\u8fb9\u5373\u53ef\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u865a\u6811\u7684\u672c\u8d28\uff0c\u5c31\u662f\u6bcf\u6b21\u5728\u539f\u6811\u4e0a\u8fdb\u884c\u90e8\u5206\u7684dfs\n\n(\u590d\u6742\u5ea6NlogN\uff1f\u7b2c\u4e00\u5982\u679c\u4f60\u4e0d\u5acc\u9ebb\u70e6\u53ef\u4ee5\u57fa\u6570\u6392\u5e8f+TARJAN\u79bb\u7ebflca\uff0c\u7b2c\u4e8c\u5982\u679c\u4f60\u7528\u7684\u662f\u5feb\u6392+\u500d\u589elca\u7684\u8bdd\u4e00\u5806nlogn\u52a0\u8d77\u6765\u6bd4\u603b\u5171\u7684nlogn\u4f1a\u5c0f\u5f88\u591a\uff0c\u7b2c\u4e09\u5c31\u7b97\u5361\u4f604s\u7684\u65f6\u9650\u4e5f\u662f\u968f\u4fbf\u8fc7)\n\n\u4e0a\u4ee3\u7801~\n\n```C\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<stack>\nusing namespace std;\ntypedef long long ll;\nconst int N=1000010;\nint n;int m;\nstruct data{int v;int nxt;}edge[2*N];\nint alist[N];int cnt;\ninline void add(int u,int v){edge[++cnt].v=v;edge[cnt].nxt=alist[u];alist[u]=cnt;}\nint dfin[N];int dfou[N];int dfu;int fa[22][N];bool book[N];ll dep[N];\nvoid dfs(int x)\n{\n    for(int i=0;fa[i][x];i++){fa[i+1][x]=fa[i][fa[i][x]];}//\u500d\u589e\u9884\u5904\u7406 \n    dfin[x]=++dfu;book[x]=true;int nxt=alist[x];//\u8bb0\u5f55\u5165\u6808\u987a\u5e8f \n    while(nxt)\n    {\n        int v=edge[nxt].v;\n        if(!book[v]){dep[v]=dep[x]+1;fa[0][v]=x;dfs(v);}\n        nxt=edge[nxt].nxt;\n    }dfou[x]=++dfu;return;//\u8bb0\u5f55\u51fa\u6808\u987a\u5e8f \n}\ninline int lca(int x,int y)//\u500d\u589e\u6c42lca \n{\n    if(dep[x]<dep[y])swap(x,y);int del=dep[x]-dep[y];\n    for(int i=0;del;del>>=1,i++){if(del&1)x=fa[i][x];}if(x==y){return x;}\n    for(int i=21;i>=0;i--){if(fa[i][x]!=fa[i][y]){x=fa[i][x],y=fa[i][y];}}\n    return fa[0][x];\n}\ninline bool cmp(int x,int y)//\u6309\u6b27\u62c9\u5e8f\u6392\u5e8f\u7684\u6bd4\u8f83\u51fd\u6570 \n{\n    int key1=(x>0)?dfin[x]:dfou[-x];\n    int key2=(y>0)?dfin[y]:dfou[-y];\n    return key1<key2;\n}\nint tp[4*N];ll sum[N];ll siz[N];ll mi[N];ll ma[N];bool vis[N];\nll tot[N];stack <int> s;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++){int u;int v;scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);}\n    dfs(1);//\u5148\u9884\u5904\u7406 \n    scanf(\"%d\",&m);\n    for(int i=1;i<=n;i++){mi[i]=0x7f7f7f7f7f;}\n    for(int i=1;i<=m;i++)\n    {\n        ll ans1=0;ll ans2=0x7f7f7f7f7f;ll ans3=0;\n        int k;scanf(\"%d\",&k);int cnt=k;\n        for(int i=1;i<=k;i++)\n        {scanf(\"%d\",&tp[i]);mi[tp[i]]=0;siz[tp[i]]=1;vis[tp[i]]=true;}//\u5904\u7406dp\u7684\u8fb9\u754c\u6761\u4ef6 \n        sort(tp+1,tp+k+1,cmp);tp[++cnt]=-tp[1];//\u8fd9\u91cc\u5148\u6309dfs\u5e8f\u6392\u4e00\u6ce2 \n        for(int i=2;i<=k;i++)\n        {\n            int lc=lca(tp[i],tp[i-1]);tp[++cnt]=-tp[i];//\u8ba1\u7b97lca\uff0c\u6bcf\u4e00\u4e2a\u70b9\u6b63\u8d1f\u5404\u63d2\u4e00\u904d \n            if(!vis[lc]){tp[++cnt]=lc;tp[++cnt]=-lc;vis[lc]=true;}\n        }\n        sort(tp+1,tp+cnt+1,cmp);//\u5f3a\u884c\u6c42\u51fa\u6b27\u62c9\u5e8f \n        for(int i=1;i<=cnt;i++)\n        {\n            if(tp[i]>0){s.push(tp[i]);continue;}//\u65e0\u8111\u5165\u6808 \n            if(tp[i]<0)\n            {\n                int now=s.top();s.pop();//\u51fa\u6808\u7684\u8bdd\uff0c\u8fd9\u4e2a\u70b9\u548c\u5f53\u524d\u6808\u9876\u80af\u5b9a\u662f\u7236\u5b50\u5173\u7cfb\uff0c\u5f00\u59cbdp \n                if(!s.empty())//\u7279\u5224\u4e0bpop\u6839\u7684\u60c5\u51b5 \n                {\n                    int to=s.top();ll dis=(dep[now]-dep[to]);//\u8ba1\u7b97dis \n                    sum[now]+=siz[now]*dis;//\u6240\u6709\u8def\u5f84\u62d4\u9ad8 \n                    ans1+=siz[to]*sum[now]+siz[now]*sum[to];//\u66f4\u65b0\u7b54\u6848 \n                    siz[to]+=siz[now];sum[to]+=sum[now];//\u66f4\u65b0sum \n                    mi[now]+=dis;ans2=min(ans2,mi[to]+mi[now]);mi[to]=min(mi[to],mi[now]);//\u66f4\u65b0min \n                    ma[now]+=dis;ans3=max(ans3,ma[to]+ma[now]);ma[to]=max(ma[to],ma[now]);//\u66f4\u65b0max \n                }\n                siz[now]=0;sum[now]=0;mi[now]=0x7f7f7f7f7f;ma[now]=0;vis[now]=false;//\u51fa\u6808\u7684\u65f6\u5019\u8bb0\u5f97\u6e05\u7a7a\u4fe1\u606f \n            }\n        }\n        printf(\"%lld %lld %lld\\n\",ans1,ans2,ans3);//\u8f93\u51fa\u7b54\u6848 \n    }return 0;//\u62dc\u62dc\u7a0b\u5e8f~ \n}\n```\n\n\n\n\n\n \n \n",
        "postTime": 1518015122,
        "uid": 56384,
        "name": "shadowice1984",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u5e7f\u544a\uff1a\u98df\u7528[$blog$](https://www.cnblogs.com/heyujun/p/10360235.html)\u4f53\u9a8c\u66f4\u4f73\n\n\u5148\u5efa\u865a\u6811\uff0c\u4e0b\u9762\u6240\u6709\u8ba8\u8bba\u5747\u662f\u5728\u865a\u6811\u4e0a\u7684\u3002\n\n\u5bf9\u4e8e\u7b2c\u4e00\u95ee\uff1a\u76f4\u63a5\u7edf\u8ba1\u6240\u6709\u6811\u8fb9\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u7b2c$2,3$\u95ee\uff1a\u8bb0$f[x]$\u8868\u793a\u5728$x$\u7684\u5b50\u6811\u5185\u79bb$x$\u8ddd\u79bb\u6700\u8fdc\u7684\u5173\u952e\u70b9\u7684\u8ddd\u79bb\uff0c$g[x]$\u8868\u793a\u5728$x$\u7684\u5b50\u6811\u5185\u79bb$x$\u8ddd\u79bb\u6700\u8fd1\u7684\u5173\u952e\u70b9\u7684\u8ddd\u79bb\u3002\n\n\u5177\u4f53\u66f4\u65b0\u4ee5$f[x]$\u4e3a\u4f8b\uff1a\n\n\u8bbf\u95ee\u5230$v\\in son_x$\uff0c\n\n\u5982\u679c\u4ee5\u524d\u8bbf\u95ee\u8fc7\u7684\u70b9\u4e2d\u6709\u5173\u952e\u70b9\uff0c\u5219\u6709$f[x]=max(f[x],f[v]+dis(u,v)+f[x])$\uff0c\n\n\u6bcf\u6b21\u8fd8\u8981\u5411\u4e0a\u4f20\u9012\uff0c\u5373$f[x]=max(f[x],f[v]+dis(u,v))$\u3002\n\n\u4ee3\u7801\n\n```cpp\n#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e6 + 5; \nstruct Graph { int to, next; } e[MAX_N << 2];\nint fir1[MAX_N], fir2[MAX_N], e_cnt;\nvoid clearGraph() {\n\tmemset(fir1, -1, sizeof(fir1)); \n\tmemset(fir2, -1, sizeof(fir2)); \n} \nvoid Add_Edge(int *fir, int u, int v) { \n\te[e_cnt] = (Graph){v, fir[u]}; \n\tfir[u] = e_cnt++; \n}\nnamespace Tree { \n\tint fa[MAX_N], dep[MAX_N], size[MAX_N], top[MAX_N], son[MAX_N], dfn[MAX_N], tim; \n\tvoid dfs1(int x) {\n\t\tdfn[x] = ++tim; \n\t    size[x] = 1, dep[x] = dep[fa[x]] + 1; \n\t\tfor (int i = fir1[x]; ~i; i = e[i].next) {\n\t\t\tint v = e[i].to; if (v == fa[x]) continue; \n\t\t\tfa[v] = x; dfs1(v); size[x] += size[v]; \n\t\t\tif (size[v] > size[son[x]]) son[x] = v; \n\t\t} \n\t} \n\tvoid dfs2(int x, int tp) {\n\t\ttop[x] = tp; \n\t    if (son[x]) dfs2(son[x], tp); \n\t\tfor (int i = fir1[x]; ~i; i = e[i].next) {\n\t\t\tint v = e[i].to; if (v == fa[x] || v == son[x]) continue; \n\t\t\tdfs2(v, v); \n\t\t} \n\t} \n\tint LCA(int x, int y) { \n\t\twhile (top[x] != top[y]) { \n\t\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\t\tx = fa[top[x]]; \n\t\t} \n\t\treturn dep[x] < dep[y] ? x : y; \n\t} \n} \nusing Tree::LCA; using Tree::dfn; using Tree::dep; \nint N, M, K, a[MAX_N];\nbool key[MAX_N];\nint f[MAX_N], g[MAX_N], s[MAX_N]; \nbool cmp(int i, int j) { return dfn[i] < dfn[j]; } \nvoid build() { \n\tstatic int stk[MAX_N], top; \n\tsort(&a[1], &a[K + 1], cmp); \n\tstk[top = 1] = 1; fir2[1] = -1;\n\te_cnt = 0; \n\tfor (int i = 1; i <= K; i++) {\n\t\tkey[a[i]] = 1; \n\t\tif (a[i] == 1) continue; \n\t\tint lca = LCA(stk[top], a[i]); \n\t\tif (lca != stk[top]) { \n\t\t\twhile (dfn[lca] < dfn[stk[top - 1]]) { \n\t\t\t\tint u = stk[top], v = stk[top - 1]; \n\t\t\t\tAdd_Edge(fir2, u, v), Add_Edge(fir2, v, u); \n\t\t\t\t--top; \n\t\t\t} \n\t\t\tif (dfn[lca] > dfn[stk[top - 1]]) { \n\t\t\t\tfir2[lca] = -1; int u = stk[top], v = lca; \n\t\t\t\tAdd_Edge(fir2, u, v), Add_Edge(fir2, v, u); \n\t\t\t\tstk[top] = lca; \n\t\t\t}\n\t\t\telse { \n\t\t\t\tint u = lca, v = stk[top--]; \n\t\t\t\tAdd_Edge(fir2, u, v), Add_Edge(fir2, v, u); \n\t\t\t} \n\t\t}\n\t\tfir2[a[i]] = -1, stk[++top] = a[i]; \n\t} \n\tfor (int i = 1; i < top; i++) {\n\t\tint u = stk[i], v = stk[i + 1]; \n\t\tAdd_Edge(fir2, u, v), Add_Edge(fir2, v, u); \n\t} \n} \nlong long ans1;\nint ans2, ans3; \nvoid Dp(int x, int fa) { \n\ts[x] = key[x], f[x] = 0, g[x] = (key[x] ? 0 : 1e9); \n\tfor (int i = fir2[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; if (v == fa) continue; \n\t\tDp(v, x); \n\t} \n\tfor (int i = fir2[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to, w = dep[v] - dep[x]; \n\t\tif (v == fa) continue; \n\t\tans1 += 1ll * (K - s[v]) * s[v] * w; \n\t\tif (s[x] > 0) { \n\t\t\tans2 = min(ans2, g[x] + w + g[v]); \n\t\t\tans3 = max(ans3, f[x] + w + f[v]); \n\t\t} \n\t\tg[x] = min(g[x], g[v] + w); \n\t    f[x] = max(f[x], f[v] + w);\n\t\ts[x] += s[v]; \n\t} \n\tkey[x] = 0; \n} \nint main () {\n#ifndef ONLINE_JUDGE \n    freopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tclearGraph(); \n\tN = gi(); \n\tfor (int i = 1; i < N; i++) { \n\t\tint u = gi(), v = gi(); \n\t\tAdd_Edge(fir1, u, v), Add_Edge(fir1, v, u); \n\t}\n\tTree::dfs1(1), Tree::dfs2(1, 1); \n\tM = gi(); \n\twhile (M--) { \n\t\tans1 = 0, ans2 = 1e9, ans3 = 0; \n\t\tK = gi(); for (int i = 1; i <= K; i++) a[i] = gi(); \n\t\tbuild(); \n\t\tDp(1, 0); \n\t\tprintf(\"%lld %d %d\\n\", ans1, ans2, ans3); \n\t} \n\treturn 0; \n} \n```",
        "postTime": 1550386500,
        "uid": 42506,
        "name": "\u4f55\u4fde\u5747",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u79cd\u5168\u65b0\u7684\u865a\u6811\u6784\u9020\u65b9\u6cd5\u3002\r\n\r\n\u4ee5\u5f80\u7684\u865a\u6811\u6784\u5efa\u90fd\u662f\u4f7f\u7528\u8fd9\u6837\u7684\u65b9\u6cd5\uff1a\r\n\r\n+ \u628a\u6240\u6709\u5173\u952e\u70b9\u6309\u7167 dfs \u5e8f\u6392\u5e8f\uff0c\u5e76\u4e14\u5bf9\u76f8\u90bb\u7684\u4e24\u4e2a\u70b9\u6c42\u51fa LCA\uff1b\r\n+ \u7136\u540e\u52a8\u6001\u52a0\u5165\u8282\u70b9\uff0c\u7ef4\u62a4\u4e00\u6761\u52a8\u6001\u7684\u94fe\u3002\r\n+ \u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u4f7f\u7528\u5355\u8c03\u6808\u7ef4\u62a4\u4ece\u6839\u8282\u70b9\u5230\u5b83\u7684\u94fe\u3002\r\n\r\n\u4f46\u662f\uff0c\u8fd8\u4e0d\u591f\u7b80\u6d01\uff0c\u4e5f\u4e0d\u591f\u76f4\u89c2\u3002\r\n\r\n\u5148\u524d\u7684\u505a\u6cd5\u5df2\u7ecf\u5229\u7528\u4e86\u4e00\u4e2a\u6027\u8d28\uff1a\r\n\r\n+ \u6309\u7167 dfs \u5e8f\uff0c\u6392\u5e8f\u4e4b\u540e\uff0c\u76f8\u90bb\u7684\u4e24\u4e2a\u5173\u952e\u70b9\u7684 LCA \u4e00\u5b9a\u4e0d\u91cd\u4e0d\u6f0f\u5730\u8986\u76d6\u4e86\u865a\u6811\u4e0a\u9762\u7684\u6240\u6709\u70b9\u3002\r\n\r\n\u90a3\u4e48\u4e0d\u59a8\u628a**\u865a\u6811\u4e0a\u7684\u6240\u6709\u70b9**\u6c42\u51fa\u6765\uff0c\u518d\u6309\u7167 dfs \u5e8f\u6392\u5e8f\u3002\r\n\r\n\u6b64\u65f6\u6211\u4eec\u4f1a\u53d1\u73b0\u5982\u679c\u6309\u7167 dfs \u5e8f\uff0c\u4ece\u5c0f\u5230\u5927\u5730\u679a\u4e3e**\u865a\u6811\u4e0a\u7684\u70b9**\uff0c\u53ef\u4ee5\u53d1\u73b0\u5f53\u524d\u70b9\uff08\u8bbe\u4e4b\u4e3a $x$\uff09\u548c\u540e\u9762\u7684\u70b9\uff08\u8bbe\u4e4b\u4e3a $y$\uff09\u7684\u8def\u5f84\u4e0a\uff0c\u7ecf\u8fc7\u7684\u8282\u70b9\u7684 dfs \u5e8f\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\r\n\r\n+ \u5982\u679c $y$ \u662f $x$ \u7684\u540e\u4ee3\uff0c\u90a3\u4e48\u8d70\u8fc7\u8282\u70b9\u7684 dfs \u5e8f\u4f1a\u6beb\u65e0\u4f8b\u5916\u5730\u9012\u589e\u3002\u56e0\u4e3a\u8fd9\u662f\u4e00\u6bb5\u5f80\u4e0b\u8d70\u7684\u65c5\u7a0b\u3002\r\n\r\n+ \u5982\u679c $y$ \u4e0d\u662f $x$ \u7684\u540e\u4ee3\uff0c\u90a3\u4e48\u5fc5\u7136\u5b58\u5728\u4e00\u6bb5\u5f80\u4e0a\u8d70\u3001\u518d\u5f80\u4e0b\u8d70\u7684\u65c5\u7a0b\uff0c\u8bbe\u4ed6\u4eec\u7684 LCA \u4e3a $z$\uff0c\u90a3\u4e48\u4ece $x$ \u5230 $z$ \u7684\u8fc7\u7a0b\u4e2d\uff0cdfs \u5e8f\u9012\u51cf\uff1b\u800c\u4ece $z$ \u5230 $y$ \u7684\u8fc7\u7a0b\u4e4b\u4e2d\uff0cdfs \u5e8f\u9012\u589e\u3002\r\n\r\n\u901a\u8fc7\u5206\u6790\u8fd9\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u627e\u5230\u4e86\u4e00\u79cd\u865a\u6811\u7684\u6784\u9020\u65b9\u6cd5\uff1a\r\n\r\n+ \u5bf9\u6240\u6709\u5173\u952e\u70b9 dfs \u5e8f\u6392\u5e8f\uff0c\u5e76\u4e14\u76f8\u90bb\u6c42\u51fa LCA\uff0c\u5c06 LCA \u548c\u5173\u952e\u70b9\u90fd\u5b58\u50a8\u5728\u4e00\u4e2a\u6570\u7ec4\u91cc\uff1b\r\n+ \u5c06\u8fd9\u4e2a\u6570\u7ec4\u6392\u5e8f\u5e76\u4e14\u53bb\u91cd\uff0c\u76ee\u7684\u662f\u4e3a\u4e86\u6c42\u51fa\u865a\u6811\u4e0a\u4e0d\u91cd\u590d\u7684\u70b9\u6309\u7167 dfs \u5e8f\u6392\u5e8f\u7684\u60c5\u51b5\uff1b\r\n+ \u5728\u865a\u6811\u70b9\u6570\u7ec4\u91cc\u5bf9\u76f8\u90bb\u7684\u4e24\u4e2a\u70b9\uff08\u8bbe dfs \u5e8f\u8f83\u5c0f\u7684\u8282\u70b9\u6807\u53f7\u4e3a $x$\uff0c\u8f83\u5927\u7684\u8282\u70b9\u7f16\u53f7\u4e3a $y$ \uff09\u90a3\u4e48\u8fde\u63a5 LCA \u548c\u70b9 $y$ \u3002\r\n+ \u7136\u540e\u865a\u6811\u7684\u6784\u9020\u8fc7\u7a0b\u5c31\u7ed3\u675f\u4e86\uff01\u65f6\u95f4\u590d\u6742\u5ea6 $O(m\\log m)$ \uff0c\u5176\u4e2d $m$ \u4e3a\u865a\u6811\u70b9\u6570\u3002\r\n\r\n\u90a3\u4e48\u8bc1\u660e\u4e3a\u4ec0\u4e48 dfs \u5e8f\u76f8\u90bb\u7684\u8282\u70b9\u4e24\u4e24\u679a\u4e3e\uff0c\u6c42\u5f97 LCA \uff0c\u5c31\u80fd\u6784\u5efa\u865a\u6811\u4e86\u5462\uff1f\r\n\r\n\u9996\u5148\u53d1\u73b0\u4e00\u4e2a\u6027\u8d28\uff0c$y$ \u662f $x$ \u5f80\u540e\u7b2c\u4e00\u4e2a dfn \u5e8f\u7684\u8282\u70b9\uff0c\u6839\u636e\u4e0a\u6587\u6240\u63d0\u5230\u7684\u6027\u8d28\uff0cdfn \u5e8f\u81ea LCA \u4ee5\u6765\u9012\u589e\u3002\r\n\r\n\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u4ece LCA \u8282\u70b9\u5230 $y$ \u7684\u8fc7\u7a0b\u4e4b\u4e2d\uff0c\u70b9\u7684 dfs \u5e8f\u5728\u4e0d\u65ad\u589e\u5927\u3002\r\n\r\n\u5982\u679c LCA \u548c $y$ \u4e4b\u95f4\u6709\u8282\u70b9 $p$ \u7684\u8bdd\uff0c\u90a3\u4e48 $p$ \u7684 dfs \u5e8f\u5fc5\u7136\u5c0f\u4e8e $y$ \u7684 dfs \u5e8f\uff0c\u800c\u8fd9\u663e\u7136\u662f\u4e0d\u7b26\u5408\u6392\u5e8f\u987a\u5e8f\u7684\u3002\r\n\r\n\u6240\u4ee5\uff0c$y$ \u548c LCA \u4e4b\u95f4\u6ca1\u6709\u91cd\u590d\u7684\u8282\u70b9\u3002\r\n\r\n\u4f1a\u4e0d\u4f1a\u6709\u9057\u6f0f\u5462\uff1f\u6211\u4eec\u53d1\u73b0\u6309\u7167\u8fd9\u4e2a\u6784\u9020\u6d41\u7a0b\uff0c\u9664\u4e86 dfs \u5e8f\u5904\u4e8e\u7b2c\u4e00\u4e2a\u7684\u8282\u70b9\uff0c\u5176\u4ed6\u90fd\u6709\u8fde\u5411\u5b83\u7684\u8fb9\uff0c\u6240\u4ee5\u6b63\u597d\u6784\u9020\u4e00\u68f5\u865a\u6811\u3002\r\n\r\n\u865a\u6811\u6784\u5efa\u90e8\u5206\uff0c\u5177\u4f53\u7684\u4ee3\u7801\u5b9e\u73b0\uff1a\uff08\u6765\u81ea OI-wiki \uff0c\u53e6\u5916 OI-wiki \u90a3\u90e8\u5206\u4e5f\u662f\u6211\u8865\u5145\u7684\uff09\r\n\r\n```cpp\r\nint dfn[maxn];\r\nbool valid[maxn];\r\nint h[maxn], m, a[maxn], len;  // \u5b58\u50a8\u5173\u952e\u70b9\r\nbool cmp(int x, int y) {\r\n  return dfn[x] < dfn[y];  // \u6309\u7167 dfn \u5e8f\u6392\u5e8f\r\n}\r\nvoid build_virtual_tree() {\r\n  sort(h + 1, h + m + 1, cmp);  // \u628a\u5173\u952e\u70b9\u6309\u7167 dfn \u5e8f\u6392\u5e8f\r\n  for (int i = 1; i < m; ++i) {\r\n    a[++len] = h[i];\r\n    a[++len] = lca(h[i], h[i + 1]);  // \u63d2\u5165 lca\r\n  }\r\n  a[++len] = h[m];\r\n  sort(a + 1, a + len + 1, cmp);  // \u628a\u6240\u6709\u865a\u6811\u4e0a\u7684\u70b9\u6309\u7167 dfn \u5e8f\u6392\u5e8f\r\n  len = unique(a + 1, a + len + 1) - a - 1;  // \u53bb\u91cd\r\n  for (int i = 1, lc; i < len; ++i) {\r\n    lc = lca(a[i], a[i + 1]);\r\n    conn(lc, a[i + 1]);  // \u8fde\u8fb9\uff0c\u5982\u6709\u8fb9\u6743 \u5c31\u662f distance(lc,a[i+1])\r\n  }\r\n}\r\n```\r\n\r\n---\r\n\r\n\u6211\u4e4b\u524d\u53ea\u77e5\u9053\u865a\u6811\u80fd\u591f\u89e3\u51b3\u600e\u6837\u7684\u95ee\u9898\uff0c\u4f46\u662f\u6ca1\u6709\u63a5\u89e6\u8fc7\u865a\u6811\u7684\u6784\u9020\u65b9\u6cd5\uff0c\u51ed\u501f dfn \u5e8f\u7684\u6027\u8d28\u548c\u753b\u56fe\u5206\u6790\uff0c\u60f3\u51fa\u6765\u4e86\u8fd9\u79cd\u795e\u5947\u7684\u65b9\u6cd5\u3002\r\n\r\n\u4e00\u5f00\u59cb\u6211\u4e5f\u4e0d\u6562\u76f8\u4fe1\u8fd9\u662f\u5bf9\u7684\uff0c\u4e8e\u662f\u5728\u5b9e\u9a8c\u4e86\u6570\u9898\u4e4b\u540e\uff0c\u5f97\u51fa\u4e86\u7ed3\u8bba\uff1b\u7ecf\u8fc7\u4e0d\u65ad\u5730\u601d\u8003\uff0c\u6700\u540e\u63a8\u5bfc\u51fa\u6765\u4e86\u5b83\u7684\u6b63\u786e\u6027\u8bc1\u660e\u3002\r\n\r\n\u5e0c\u671b\u540c\u5b66\u4eec\u80fd\u591f\u5927\u80c6\u731c\u60f3\uff0c\u5c0f\u5fc3\u8bc1\u660e\uff01\r\n",
        "postTime": 1673530406,
        "uid": 121995,
        "name": "SmallTualatin",
        "ccfLevel": 0,
        "title": "P4103 [HEOI2014] \u5927\u5de5\u7a0b \u9898\u89e3"
    },
    {
        "content": "\u9996\u5148\u5c06\u865a\u6811\u5efa\u51fa\u6765\uff0c\u7136\u540e\u6211\u4eec\u5206\u522b\u8003\u8651\u4e09\u4e2a\u95ee\u9898\u3002\n\n\u6c42\u548c\uff1a\n\n\u6211\u4eec\u5b9a\u4e49$g[u]$\u8868\u793a\u4ee5$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u6240\u6709\u5173\u952e\u70b9\u5230$u$\u7684\u8ddd\u79bb\u548c\u3002\n\n\u6211\u4eec\u6309\u7167\u987a\u5e8f\u8003\u8651$u$\u7684\u6bcf\u4e00\u9897\u5b50\u6811\uff0c\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u7edf\u8ba1\u4e0d\u540c\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u8d21\u732e\u5373\u53ef\uff0c\u4e0d\u96be\u5f97\u5230\uff1a\n\n$$tot+=(g[u]+siz[u]\\times l)\\times siz[v]+g[v]\\times siz[u]$$\n\n$siz[u]$\u8868\u793a\u4ee5$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u4e2a\u6570\u3002\n\n\u6700\u5927\u503c&\u6700\u5c0f\u503c\uff1a\n\n\u5b9a\u4e49$mx[u]/mn[u]$\u8868\u793a\u4ee5$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5230$u$\u6700\u8fdc/\u6700\u8fd1\u7684\u5173\u952e\u70b9\u7684\u8ddd\u79bb\uff0c\u6309\u7167\u4e0a\u9762\u7c7b\u4f3c\u7684\u65b9\u6cd5\u66f4\u65b0\u7b54\u6848\u5373\u53ef\u3002\n\n```cpp\nconst int N=1e6+5;\n\nint n,m,k,cnt,id,top;\nint dep[N],f[N][21],dfn[N],head[N],siz[N],h[N],stk[N];\nll g[N],mn[N],mx[N];\nll tot,mnans,mxans;\nbool tag[N];\nstruct edge\n{\n\tint to,nxt;\n};\nedge e[N<<1];\n\nvoid add(int x,int y)\n{\n\te[++cnt].to=y;\n\te[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nvoid link(int x,int y)\n{\n\tadd(x,y),add(y,x);\n}\nvoid dfs(int x,int fa,int d)\n{\n\tdep[x]=d,f[x][0]=fa,dfn[x]=++id;\n\tfor(int i=1;i<=20;++i) f[x][i]=f[f[x][i-1]][i-1];\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,x,d+1);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y]) swap(x,y);\n\tfor(int i=20;i>=0;--i) if(dep[f[x][i]]>=dep[y]) x=f[x][i];\n\tif(x==y) return x;\n\tfor(int i=20;i>=0;--i) if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n\treturn f[x][0];\n}\nvoid dp(int x)\n{\n\tsiz[x]=tag[x],g[x]=0;\n\tif(tag[x]) mx[x]=mn[x]=0;\n\telse mn[x]=INF,mx[x]=-INF;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tdp(v);\n\t\tll l=dep[v]-dep[x];\n\t\ttot+=(g[x]+siz[x]*l)*siz[v]+g[v]*siz[x];\n\t\tsiz[x]+=siz[v],g[x]+=g[v]+l*siz[v];\n\t\tmnans=min(mnans,mn[x]+mn[v]+l),mxans=max(mxans,mx[x]+mx[v]+l);\n\t\tmn[x]=min(mn[x],mn[v]+l),mx[x]=max(mx[x],mx[v]+l);\n\t}\n}\nint main()\n{\n\tfio();\n\tgi(n);\n\tfor(int i=1,x,y;i<=n-1;++i) gi(x,y),link(x,y);\n\tdfs(1,0,1);\n\tgi(m);\n\twhile(m--)\n\t{\n\t\tgi(k);\n\t\tfor(int i=1;i<=k;++i) gi(h[i]),tag[h[i]]=true;\n\t\tsort(h+1,h+k+1,[](int x,int y){\n\t\t\treturn dfn[x]<dfn[y];\n\t\t});\n\t\tstk[top=1]=1,cnt=0,head[1]=0;\n\t\tfor(int i=1;i<=k;++i)\n\t\t{\n\t\t\tif(h[i]!=1)\n\t\t\t{\n\t\t\t\tint l=lca(h[i],stk[top]);\n\t\t\t\tif(l!=stk[top])\n\t\t\t\t{\n\t\t\t\t\twhile(dfn[l]<dfn[stk[top-1]]) add(stk[top-1],stk[top]),--top;\n\t\t\t\t\tif(dfn[l]!=dfn[stk[top-1]]) head[l]=0,add(l,stk[top]),stk[top]=l;\n\t\t\t\t\telse add(l,stk[top--]);\n\t\t\t\t}\n\t\t\t\thead[h[i]]=0,stk[++top]=h[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<top;++i) add(stk[i],stk[i+1]);\n\t\ttot=0,mnans=INF,mxans=-INF;\n\t\tdp(1);\n\t\tprint(tot),pc(' '),print(mnans),pc(' '),print(mxans),pc(10);\n\t\tfor(int i=1;i<=k;++i) tag[h[i]]=false;\n\t}\n\tend();\n}\n```",
        "postTime": 1584605793,
        "uid": 208081,
        "name": "MikukuOvO",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u5148\u6765\u8003\u8651\u666e\u901a\u7684**\u6811\u578bdp**\u600e\u4e48\u505a\n\n\u8bbe$SZ_x$\u8868\u793a$x$\u7684\u5b50\u6811\u4e2d\u6709\u591a\u5c11\u4e2a\u67e5\u8be2\u70b9,$d_x$\u8868\u793a$x$\u7684\u6df1\u5ea6\n\n1. \u8fd9\u4e9b\u65b0\u901a\u9053\u7684\u4ee3\u4ef7\u548c\n\n    \u8003\u8651\u6bcf\u6761\u8fb9\u8981\u88ab\u7edf\u8ba1\u591a\u5c11\u6b21: \n\n    \u5047\u8bbe$y$\u662f$x$\u7684\u67d0\u4e2a\u5b50\u8282\u70b9,$x\\leftrightarrow y$\u4f1a\u88ab\u7edf\u8ba1$(k-SZ_y)\\times SZ_y$\u6b21,\n\n    (\u8d77\u70b9\u53ef\u4ee5\u662f$y$\u7684\u5b50\u6811\u4e2d\u4efb\u4e00\u67e5\u8be2\u70b9,\u7ec8\u70b9\u53ef\u4ee5\u662f$y$\u5b50\u6811\u5916\u7684\u4efb\u4e00\u67e5\u8be2\u70b9,\u8fd9\u6837\u7684\u8bdd\u8def\u5f84\u5fc5\u7136\u7ecf\u8fc7$x\\leftrightarrow y$)\n\n    \u90a3\u4e48\u8d21\u732e\u662f$(d_y-d_x)\\times (k-SZ_y)\\times SZ_y$\n\n2. \u8fd9\u4e9b\u65b0\u901a\u9053\u4e2d\u4ee3\u4ef7\u6700\u5c0f/\u5927\u7684\u662f\u591a\u5c11\n\n    \u6709\u70b9\u7c7b\u4f3c\u6811\u578bdp\u6c42\u6811\u7684\u76f4\u5f84\n\n    $x$\u7684\u5b50\u6811\u4e2d\u6700\u957f\u7684\u8def\u5f84\u662f: \u5b50\u6811\u4e2d\u6df1\u5ea6\u6700\u5927\u7684\u67e5\u8be2\u70b9\u7684\u6df1\u5ea6+\u5b50\u6811\u4e2d\u6df1\u5ea6\u6b21\u5927\u7684\u67e5\u8be2\u70b9\u7684\u6df1\u5ea6(\u82e5$x$\u662f\u67e5\u8be2\u70b9\u5219\u5305\u62ec$x\\leftrightarrow x$,\u6df1\u5ea6\u4e3a$0$)\n\n    \u6700\u77ed\u8def\u5f84\u548c\u4e0a\u9762\u7684\u6c42\u6cd5\u7c7b\u4f3c\n   \n\u5957\u4e0a**\u865a\u6811**\u5c31\u53ef\u4ee5\u89e3\u51b3\u8fd9\u9053\u9898\u4e86\n\n\u5982\u679c\u4e0d\u61c2\u7684\u8bdd\u5c31\u770b\u4ee3\u7801\u54af\n\n```cpp\n#include<bits/stdc++.h>\n#pragma GCC optimize(3)\n#define il __inline__ __attribute__ ((always_inline))\ntypedef long long ll;\n#define ll long long\n#define rg register\n#define For(i,x,y) for(int i(x);i<=y;++i)\n#define fl(i,x) for(int i(head[x]),to;to=e[i].to,i;i=e[i].nxt)\nil int MAX(int x,int y){return x>y?x:y;}\nil int MIN(int x,int y){return x<y?x:y;}\nnamespace IO{const int str=1<<20;static char in_buf[str],*in_s,*in_t;bool __=0;il char gc(){return (in_s==in_t)&&(in_t=(in_s=in_buf)+fread(in_buf,1,str,stdin)),in_s==in_t?__=1,EOF:*in_s++;}template<typename T>il void in(T &x){if(__)return;rg char c=gc();bool f=0;while(c!=EOF&&(c<'0'||c>'9'))f^=(c=='-'),c=gc();if(c==EOF){__=1;return;}x=0;while(c!=EOF&&'0'<=c&&c<='9')x=x*10+c-48,c=gc();if(c==EOF)__=1;if(f)x=-x;}static char out_buf[str],*out_s=out_buf,*out_t=out_buf+str;il void flush(){fwrite(out_buf,1,out_s-out_buf,stdout);out_s=out_buf;}il void pt(char c){(out_s==out_t)?(fwrite(out_s=out_buf,1,str,stdout),*out_s++=c):(*out_s++=c);}template<typename T>il void out(T x){if(!x){pt('0');return;}if(x<0)pt('-'),x=-x;char a[50],t=0;while(x)a[t++]=x%10,x/=10;while(t--)pt(a[t]+'0');}}using namespace IO;\nconst int N=1000011,inf=1000000007;\nint n,k,cnt=0,head[N];\nstruct edge{int to,nxt;}e[N<<1];\nil void add(int x,int y){e[++cnt].to=y;e[cnt].nxt=head[x];head[x]=cnt;}\nint siz[N],top[N],f[N],d[N],dfn[N],sz=0;\nvoid dfs(int x){\n    siz[x]=1;dfn[x]=++sz;\n    fl(i,x)if(to!=f[x]){\n        f[to]=x;\n        d[to]=d[x]+1;\n        dfs(to);\n        siz[x]+=siz[to];\n    }\n}\nvoid bt(int x,int tp){\n    top[x]=tp;int k=0;\n    fl(i,x)if(to!=f[x]&&siz[to]>siz[k])k=to;\n    if(k)bt(k,tp);\n    fl(i,x)if(!top[to])bt(to,to);\n}\nil int lca(int x,int y){\n    while(top[x]!=top[y])\n        d[top[x]]>d[top[y]]?x=f[top[x]]:y=f[top[y]];\n    return d[x]<d[y]?x:y;\n}\nint a[N],st[N],tp,SZ[N],mx_d[N],mi_d[N],a1,a2;\nll ans;\nbool v[N];\nil bool cmp(int x,int y){return dfn[x]<dfn[y];}\nvoid dp(int x){\n    if(v[x])SZ[x]=1,mx_d[x]=d[x],mi_d[x]=d[x];\n    else    SZ[x]=0,mx_d[x]=-inf,mi_d[x]=inf;\n    int p1=-inf,p2=-inf,q1=inf,q2=inf;\n    fl(i,x){\n        dp(to);\n\n        mx_d[x]=MAX(mx_d[x],mx_d[to]);\n        if(mx_d[to]>=p1)p2=p1,p1=mx_d[to];\n        else p2=MAX(p2,mx_d[to]);\n\n        mi_d[x]=MIN(mi_d[x],mi_d[to]);\n        if(mi_d[to]<=q1)q2=q1,q1=mi_d[to];\n        else q2=MIN(q2,mi_d[to]);\n\n        ans+=1ll*(k-SZ[to])*SZ[to]*(d[to]-d[x]);\n        SZ[x]+=SZ[to];\n    }\n    a1=MIN(a1,q1+q2-2*d[x]);\n    if(v[x])a1=MIN(a1,q1-d[x]);\n\n    a2=MAX(a2,p1+p2-2*d[x]);\n    if(v[x])a2=MAX(a2,p1-d[x]);\n    head[x]=0;\n}\nint main(){\n    in(n);\n    int q,x,y,t;\n    For(i,1,n-1)in(x),in(y),add(x,y),add(y,x);\n    d[1]=1;dfs(1);bt(1,1);\n    cnt=0;memset(head,0,sizeof head);\n    in(q);\n    while(q--){\n        in(k);\n        For(i,1,k)in(a[i]),v[a[i]]=1;\n        std::sort(a+1,a+k+1,cmp);\n        cnt=0;st[tp=1]=1;\n        For(i,1,k){//\u6784\u5efa\u865a\u6811\n            x=a[i];t=lca(x,st[tp]);\n            while(d[t]<d[st[tp]]){\n                if(d[t]>=d[st[tp-1]]){\n                    add(t,st[tp--]);\n                    if(t!=st[tp])st[++tp]=t;\n                    break;\n                }\n                add(st[tp-1],st[tp]),--tp;\n            }\n            if(st[tp]!=x)st[++tp]=x;\n        }\n        while(tp>1)add(st[tp-1],st[tp]),--tp;\n        ans=0;a1=inf,a2=0;\n        dp(1);\n        out(ans),pt(' '),out(a1),pt(' '),out(a2),pt('\\n');\n        For(i,1,k)v[a[i]]=0;\n    }\n    flush();\n}\n```",
        "postTime": 1580311918,
        "uid": 36532,
        "name": "localhost",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u672c\u9898\u7528\u5230\u4e86\u4e00\u4e9b\u70b9\u5206\u6cbb\u7684\u601d\u60f3\u3002\n\n\u8003\u8651 $q=1$ \u7684\u60c5\u51b5\u3002\u4e00\u79cd\u6734\u7d20\u7684\u505a\u6cd5\u662f\uff1a\u679a\u4e3e\u5f53\u524d\u8282\u70b9\u7684\u6240\u6709\u5b50\u8282\u70b9\uff0c\u5e76\u8ba1\u7b97\u5b50\u6811\u95f4\u5173\u952e\u70b9\u5f62\u6210\u7684\u8def\u5f84\u3001\u66f4\u65b0\u7b54\u6848\u3002\u4f46\u662f\u672c\u9898\u4e0e\u4e00\u822c\u70b9\u5206\u6cbb\u9898\u76ee\u7565\u6709\u4e0d\u540c\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u9884\u5904\u7406\u5b50\u6811\u4fe1\u606f\u6765\u4f18\u5316\u70b9\u5206\u6cbb\u8fc7\u7a0b\u3002\n\n\u7a0d\u52a0\u89c2\u5bdf\u53ef\u4ee5\u53d1\u73b0\uff0c\u53ea\u9700\u9884\u5904\u7406\u6bcf\u4e2a\u5b50\u6811\u4e2d\u6811\u6839\u5230\u5173\u952e\u70b9\u7684\u6700\u5c0f\u8ddd\u79bb\u3001\u6700\u5927\u8ddd\u79bb\uff0c\u4ee5\u53ca\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u4e2a\u6570\u3001\u6240\u6709\u5173\u952e\u70b9\u5230\u6811\u6839\u7684\u8ddd\u79bb\u603b\u548c\u5373\u53ef\u5b8c\u6210\u70b9\u5206\u6cbb\u5168\u90e8\u8fc7\u7a0b\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n)$ \u3002\n\n\u5bf9\u4e8e $q\\not=1$  \u7684\u60c5\u51b5\uff0c\u89c2\u5bdf\u5230 $\\Sigma{k}$ \u4e0e $n$ \u540c\u9636\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u6b21\u67e5\u8be2\u5efa\u7acb\u4e00\u68f5\u865a\u6811\uff0c\u5728\u865a\u6811\u4e0a\u70b9\u5206\u6cbb\u5373\u53ef\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1000005;\ntypedef long long ll;\nstruct Edge {int v, w; Edge(int a, int b) {v = a, w = b;}};\nstruct Key {int u, dfn;}keys[MAXN];\nbool cmp(Key a, Key b) {return a.dfn < b.dfn;}\nvector<Edge> G[MAXN], VT[MAXN];\nint N, Q, K;\nint f[MAXN][21], dep[MAXN], dfn[MAXN], dfn_idx;\nint lg[MAXN];\nbool h[MAXN];\nll g[MAXN];\nint m[MAXN], n[MAXN];\nint c[MAXN];\nll ans1;\nint ans2, ans3;\n\ninline void dfs0(int u, int fa) {\n    dfn[u] = ++dfn_idx;\n    dep[u] = dep[fa] + 1;\n    f[u][0] = fa;\n    for (int i = 1; i <= lg[dep[u]]; ++i)\n        f[u][i] = f[f[u][i - 1]][i - 1];\n    for (vector<Edge>::iterator it = G[u].begin(); it != G[u].end(); it++) {\n        int v = it -> v;\n        if (v == fa) continue;\n        dfs0(v, u);\n    }\n}\n\nvoid dfs1(int u) {\n    g[u] = 0;\n    c[u] = h[u];\n    m[u] = 0x3f3f3f3f;\n    n[u] = -0x3f3f3f3f;\n    if (h[u]) m[u] = n[u] = 0;\n    for (vector<Edge>::iterator it = VT[u].begin(); it != VT[u].end(); it++) {\n        int v = it -> v, w = it -> w;\n        dfs1(v);\n        c[u] += c[v];\n        g[u] += g[v] + 1ll * w * c[v];\n        m[u] = min(m[u], w + m[v]);\n        n[u] = max(n[u], w + n[v]);\n    }\n}\n\nvoid dfs2(int u) {\n    ll sum = 0;\n    int cnt = h[u];\n    int minn = 0x3f3f3f3f, maxx = -0x3f3f3f3f;\n    if (h[u]) minn = maxx = 0;\n    for (vector<Edge>::iterator it = VT[u].begin(); it != VT[u].end(); it++) {\n        int v = it -> v, w = it -> w;\n        ans1 += 1ll * sum * c[v] + 1ll * w * cnt * c[v] + 1ll * g[v] * cnt;\n        ans2 = min(ans2, minn + w + m[v]);\n        ans3 = max(ans3, maxx + w + n[v]);\n        sum += g[v] + 1ll * c[v] * w;\n        cnt += c[v];\n        minn = min(minn, w + m[v]);\n        maxx = max(maxx, w + n[v]);\n        dfs2(v);\n    }\n    h[u] = 0;\n    VT[u].clear();\n}\n\ninline int Lca(int u, int v) {\n    if (dep[u] < dep[v]) swap(u, v);\n    while (dep[u] > dep[v]) u = f[u][lg[dep[u] - dep[v]]];\n    if (u == v) return u;\n    for (int i = lg[dep[u]]; i >= 0; --i) {\n        if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];\n    }\n    return f[u][0];\n}\n\nint main() {\n    for (register int i = 2; i <= 1000000; ++i)\n        lg[i] = lg[i >> 1] + 1;\n    scanf(\"%d\", &N);\n    for (register int i = 1; i < N; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        G[u].push_back(Edge(v, 1));\n        G[v].push_back(Edge(u, 1));\n    }\n    dfs0(1, 0);\n    scanf(\"%d\", &Q);\n    while (Q--) {\n        scanf(\"%d\", &K);\n        for (register int i = 1; i <= K; ++i) {\n            int u;\n            scanf(\"%d\", &u);\n            h[u] = 1;\n            keys[i].u = u, keys[i].dfn = dfn[u];\n        }\n        sort(keys + 1, keys + K + 1, cmp);\n        stack<int> s;\n        s.push(1);\n        for (register int i = 1; i <= K; ++i) {\n            int u = keys[i].u;\n            if (u == 1) continue;\n            int lca = Lca(u, s.top());\n            while (s.top() != lca) {\n                int tmp = s.top(); s.pop();\n                if (dfn[s.top()] < lca) s.push(lca);\n                VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));\n            }\n            s.push(u);\n        }\n        while (s.top() != 1) {\n            int tmp = s.top(); s.pop();\n            VT[s.top()].push_back(Edge(tmp, dep[tmp] - dep[s.top()]));\n        }\n        dfs1(1);\n        ans1 = ans3 = 0;\n        ans2 = 0x3f3f3f3f;\n        dfs2(1);\n        printf(\"%lld %d %d\\n\", ans1, ans2, ans3);\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1567170665,
        "uid": 116851,
        "name": "_\u98ce\u4f11\u4f4f",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u7531\u4e8e\u7b14\u8005\u6bd4\u8f83\u8822\u60f3\u4e0d\u5230 $\\text{DFS}$ \u4e24\u6b21\uff0c\u56e0\u6b64\u7528\u4e86\u4e00\u4e2a\u5f88\u66b4\u529b\u7684\u505a\u6cd5\u2026\u2026\n\n\u5148\u6784\u5efa\u51fa\u865a\u6811\uff0c\u7136\u540e\u5c31\u76f8\u5f53\u4e8e\u95ee\u6811\u4e0a\u6240\u6709\u9ed1\u70b9\u4e4b\u95f4\u8def\u5f84\u6743\u503c\u548c\n\n\u70b9\u5bf9\u95ee\u9898\u8003\u8651\u70b9\u5206\u6cbb\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u505a\u4e86\n\n\u6bcf\u6b21\u66b4\u529b\u7ef4\u62a4\u5f53\u524d\u548c\uff0c\u7ed3\u70b9\u6570\uff0c$\\min/\\max$ \u5373\u53ef\n\n\u590d\u6742\u5ea6\u4e5f\u662f $\\mathrm O(n\\log n)$\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <utility>\n#define N 1000020\n#define M 20\nusing namespace std;\n\nextern int l[N];\nextern int k, a[N];\nextern bool b[N], u[N];\n\nextern int GetLCA(int, int);\nextern int Distance(int, int);\n\nnamespace Virtual\n{\n    vector<pair<int, int> > e[N];\n    vector<int> c, s;\n\n    bool Compare(int a, int b)\n    {\n        return l[a] < l[b];\n    }\n\n    void AddEdge(int u, int v)\n    {\n        int w;\n\n        w = Distance(u, v);\n        e[u].push_back(make_pair(v, w));\n        e[v].push_back(make_pair(u, w));\n        c.push_back(u);\n        c.push_back(v);\n        // printf(\"%d <-> %d : %d\\n\", u + 1, v + 1, w);\n\n        return;\n    }\n\n    void InitVirtual(void)\n    {\n        int i, t, p, q;\n\n        for(i = 0; i < (signed)c.size(); i ++)\n        {\n            u[c.at(i)] = false;\n            e[c.at(i)].clear();\n        }\n        c.clear();\n\n        sort(a, a + k, Compare);\n        for(i = 0; i < k; i ++)\n        {\n            if(!s.empty())\n            {\n                t = GetLCA(a[i], s.back());\n                if(t != s.back())\n                    while(s.size() > 1)\n                    {\n                        p = s.back();\n                        s.pop_back();\n                        q = s.back();\n\n                        if(l[q] < l[t])\n                        {\n                            AddEdge(p, t);\n                            s.push_back(t);\n                            break;\n                        }\n                        AddEdge(p, q);\n\n                        if(l[q] == l[t])\n                            break;\n                    }\n            }\n            s.push_back(a[i]);\n        }\n\n        while(!s.empty())\n        {\n            p = s.back();\n            s.pop_back();\n            if(!s.empty())\n                AddEdge(p, s.back());\n        }\n\n        return;\n    }\n}\n\nnamespace G\n{\n    using Virtual::e;\n\n    int f[N], g[N];\n    vector<int> v;\n\n    void DFS(int x, int p, bool *u)\n    {\n        int i;\n\n        // printf(\"VIS %d\\n\", x+1);\n        v.push_back(x);\n        for(i = g[x] = 0, f[x] = 1; i < (signed)e[x].size(); i ++)\n            if(e[x].at(i).first != p && !u[e[x].at(i).first])\n            {\n                DFS(e[x].at(i).first, x, u);\n                f[x] += f[e[x].at(i).first];\n                g[x] = max(g[x], f[e[x].at(i).first]);\n            }\n\n        return;\n    }\n\n    int G(int x, bool *u)\n    {\n        int i, o;\n\n        v.clear();\n        DFS(x, x, u);\n        for(i = 1, o = v.at(0); i < (signed)v.size(); i ++)\n            if(max(g[o], (signed)v.size() - f[o]) > max(g[v.at(i)], (signed)v.size() - f[v.at(i)]))\n                o = v.at(i);\n\n        return o;\n    }\n}\n\nnamespace Divide\n{\n    using Virtual::e;\n\n    long long o[3], v[3];\n    int c;\n\n    void Query(int x, int p, int d)\n    {\n        int i;\n\n        if(b[x])\n        {\n            o[0] += (long long)d * c + v[0];\n            o[1] = min(o[1], d + v[1]);\n            o[2] = max(o[2], d + v[2]);\n        }\n\n        for(i = 0; i < (signed)e[x].size(); i ++)\n            if(!u[e[x].at(i).first] && e[x].at(i).first != p)\n                Query(e[x].at(i).first, x, d + e[x].at(i).second);\n\n        return;\n    }\n\n    void Update(int x, int p, int d)\n    {\n        int i;\n\n        if(b[x])\n        {\n            v[0] += d;\n            c ++;\n            v[1] = min(v[1], (long long)d);\n            v[2] = max(v[2], (long long)d);\n        }\n\n        for(i = 0; i < (signed)e[x].size(); i ++)\n            if(!u[e[x].at(i).first] && e[x].at(i).first != p)\n                Update(e[x].at(i).first, x, d + e[x].at(i).second);\n\n        return;\n    }\n\n    void DFS(int x)\n    {\n        int i;\n\n        x = G::G(x, u);\n        u[x] = true;\n        // printf(\"G %d\\n\", x+1);\n\n        v[0] = c = 0;\n        v[1] = INT_MAX;\n        v[2] = INT_MIN;\n        if(b[x])\n        {\n            c = 1;\n            v[1] = v[2] = 0;\n        }\n\n        for(i = 0; i < (signed)e[x].size(); i ++)\n            if(!u[e[x].at(i).first])\n            {\n                Query (e[x].at(i).first, x, e[x].at(i).second);\n                Update(e[x].at(i).first, x, e[x].at(i).second);\n            }\n\n        for(i = 0; i < (signed)e[x].size(); i ++)\n            if(!u[e[x].at(i).first])\n                DFS(e[x].at(i).first);\n\n        return;\n    }\n}\n\nvector<int> e[N];\nint f[M][N], d[N], l[N];\nint k, a[N];\nbool b[N], u[N];\n\nint Scan(void)\n{\n    int c, s;\n\n    for(s = 0; (c = getchar()) < '0' || c > '9'; )\n        ;\n    do\n        s = s * 10 + c - 48;\n    while((c = getchar()) >= '0' && c <= '9');\n\n    return s;\n}\n\nvoid InitLCA(int x, int p)\n{\n    static int k;\n    int i;\n\n    l[x] = k ++;\n    for(i = 1, f[0][x] = p; i < M; i ++)\n        f[i][x] = f[i - 1][f[i - 1][x]];\n\n    for(i = 0; i < (signed)e[x].size(); i ++)\n        if(e[x].at(i) != p)\n        {\n            d[e[x].at(i)] = d[x] + 1;\n            InitLCA(e[x].at(i), x);\n        }\n\n    return;\n}\n\nint GetLCA(int u, int v)\n{\n    int i, t;\n\n    if(d[u] < d[v])\n        swap(u, v);\n    t = d[u] - d[v];\n\n    for(i = 0; i < M; i ++)\n        if(t & (1 << i))\n            u = f[i][u];\n    if(u == v)\n        return u;\n\n    for(i = M - 1; i > -1; i --)\n        if(f[i][u] != f[i][v])\n        {\n            u = f[i][u];\n            v = f[i][v];\n        }\n\n    return f[0][u];\n}\n\ninline int Distance(int u, int v)\n{\n    return d[u] + d[v] - d[GetLCA(u, v)] * 2;\n}\n\nint main(void)\n{\n    int n, m, u, v;\n    int i;\n\n    n = Scan();\n    for(i = 1; i < n; i ++)\n    {\n        u = Scan() - 1;\n        v = Scan() - 1;\n        e[u].push_back(v);\n        e[v].push_back(u);\n    }\n    InitLCA(0, 0);\n    // while(1){cin>>u>>v;cout<<GetLCA(u-1,v-1)+1<<' '<<Distance(u-1,v-1)<<endl;}\n\n    m = Scan();\n    while(m --)\n    {\n        k = Scan();\n        for(i = 0; i < k; i ++)\n            b[a[i] = Scan() - 1] = true;\n        if(!b[0])\n            a[k ++] = 0;\n\n        Virtual::InitVirtual();\n        // puts(\"OK\");\n        // for(i=0;i<Virtual::c.size();i++)cout<<Virtual::c[i]+1<<' ';cout<<endl;\n        Divide::o[0] = 0;\n        Divide::o[1] = INT_MAX;\n        Divide::o[2] = INT_MIN;\n        Divide::DFS(Virtual::c.at(0));\n\n        printf(\"%lld %lld %lld\\n\", Divide::o[0], Divide::o[1], Divide::o[2]);\n        for(i = 0; i < k; i ++)\n            b[a[i]] = false;\n    }\n\n    return 0;\n}\n\n```",
        "postTime": 1553175649,
        "uid": 34354,
        "name": "gorokokoro",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "[\u865a\u6811\u5165\u95e8](https://www.luogu.com.cn/blog/SSerxhs/qian-tan-xu-shu)\n\n\u4e3a\u4ec0\u4e48\u653e\u8fd9\u4f4d\u795e\u4ed9\u7684\u65e5\u62a5\u5462\uff1f\n\n~~\u56e0\u4e3a\u6211\u662f\u770b\u4ed6\u7684\u65e5\u62a5\u5b66\u7684~~\n\n\n------------\n\n\n\u865a\u6811\u7684\u6838\u5fc3~~\u4f3c\u4e4e~~\u5c31\u662f\u5efa\u51fa\u4e00\u4e2a**\u6bcf\u4e2a\u70b9\u90fd\u6709\u7528\u7684**\uff08\u865a\uff09\u6811\uff0c\u5e76\u5728\u4e0a\u9762\u8fdb\u884c\u5904\u7406\u3002\n\n\u8fd9\u91cc\u8bf4\u7684\u201c\u6709\u7528\u201d\u5206\u4e3a\u4e24\u79cd\uff0c\u4e00\u79cd\u662f\u9898\u76ee\u4e2d\u94a6\u5b9a\u7684\u70b9\uff0c\u53e6\u4e00\u79cd\u662f\u4e3a\u4e86\u9632\u6b62\u6211\u4eec\u7684\u94a6\u5b9a\u70b9\u53d8\u4e3a\u201c\u6563\u5175\u6e38\u52c7\u201d\u800c\u589e\u52a0\u7684\u5fc5\u8981\u7684\u8054\u7ed3\u70b9\u3002\n\n![\u4e00\u5f20\u56fe](https://cdn.luogu.com.cn/upload/image_hosting/1njajbod.png)\n\n\u8fd9\u5f20~~\u5de6\u53f3\u4e24\u8fb9\u4e0d\u592a\u534f\u8c03\u7684~~\u56fe\u4e2d\uff0c\u5e95\u5c42\u7684\u6807\u8bb0\u70b9\u662f\u6211\u4eec\u7684\u94a6\u5b9a\u70b9\uff0c\u800c\u4e0a\u5c42\u7684\u6807\u8bb0\u70b9\u5c31\u662f\u5bf9\u5e94\u7684\u8054\u7ed3\u70b9\u3002\n\n\u8fd9\u6837\u6211\u4eec\u5efa\u6210\u7684\u865a\u6811\u5c31\u957f\u8fd9\u6837\uff1a\n![\u6211\u8c14\u8c14](https://cdn.luogu.com.cn/upload/image_hosting/m2rmrgoa.png)\n\n~~\u4f8b\u5b50\u662f\u4e0d\u662f\u592a\u7b80\u5355\u4e86~~\n\n\n------------\n\n\u6784\u5efa\u865a\u6811\u65f6\uff0c\u6211\u4eec\u5f00\u4e00\u4e2a$stack$\u7ef4\u62a4\u6839\u8282\u70b9\u5230\u6808\u9876\u7684\u865a\u6811\u4e0a\u7684\u8def\u5f84\uff0c\u5f53\u52a0\u5165\u7684\u70b9\u662f\u6808\u9876\u7684\u5b50\u6811\u5185\u7684\u70b9\u65f6\u538b\u6808\uff0c\u4ee4$anc$\u4e3a\u8981\u52a0\u5165\u7684\u70b9\u4e0e\u6b64\u65f6\u7684\u6808\u9876\u7684$lca$\uff0c\u5426\u5219\u4e0d\u65ad\u5f39\u6808\u5e76\u8fde\u8fb9\uff0c\u76f4\u5230\u6808\u9876\u4e3a$anc$\u6216\u53ef\u4ee5\u52a0\u5165$anc$,\u5373$anc$\u5728\u6808\u9876\u7684\u5b50\u6811\u5185\u3002\n\n\u7136\u540e\u8dd1$dp$\u5c31\u597d\u4e86\u3002\n\n------------\n\n\u5bf9\u4e8e\u6c42\u548c\uff0c\u6211\u4eec\u5728$dp$\u5b8c\u4e00\u4e2a\u5b50\u6811\u540e\uff0c\u5904\u7406\u5176\u4e0e$fa$\u7684\u5176\u5b83\u5b50\u6811\u5185\u8282\u70b9\u80fd\u5f62\u6210\u591a\u5c11\u8def\u5f84\u5e76\u8ba1\u7b97\u5373\u53ef\uff0c\u7136\u540e\u5c06\u8be5\u5b50\u6811\u6240\u6709\u94a6\u5b9a\u70b9\u5230\u6839\u8282\u70b9\u8ddd\u79bb\u7d2f\u52a0\u5230$fa$\u7684\u548c\u6570\u7ec4\u91cc\u3002\n\n\u6c42\u6700\u5c0f\u503c\uff0c\u5982\u679c\u5f53\u524d\u70b9\u662f\u94a6\u5b9a\u70b9\uff0c\u4e0d\u65ad\u5bfb\u627e\u5b50\u6811\u4e2d$dep$\u6700\u9ad8\u7684\u70b9\u5373\u53ef\uff0c\u5426\u5219\u6bcf$dp$\u5b8c\u4e00\u4e2a\u5b50\u6811\uff0c\u53d6\u51fa\u8be5\u5b50\u6811\u4e2d\u6700\u9ad8\u7684\u94a6\u5b9a\u70b9\u4e0e$fa$\u7684\u5176\u5b83\u5b50\u6811\u4e2d\u6700\u9ad8\u7684\u94a6\u5b9a\u70b9\u66f4\u65b0\u7b54\u6848\u3002\n\n\u6700\u5927\u503c\u5c31\u76f4\u63a5\u7528\u6700\u5c0f\u503c\u7684\u65b9\u6cd5\uff0c\u53ea\u4e0d\u8fc7\u7ef4\u62a4$dep$\u6700\u6df1\u7684\u70b9\u5373\u53ef\u3002\n\n~~\u7136\u800c\u6211\u5c45\u7136\u56e0\u4e3a\u6570\u7ec4\u8d8a\u754c\u8c03\u4e86\u4e24\u5929\u6ca1\u770b\u51fa\u6765?~~\n\n\n------------\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define reg register\n#define chk_digit(c) (c>='0'&&c<='9')\ninline int read() {\n\treg int x=0,f=1;reg char c=getchar();\n\twhile(!chk_digit(c)) { if(c=='-') f=-1;c=getchar(); }\n\twhile(chk_digit(c)) x=x*10+c-'0',c=getchar();\n\treturn x*f;\n} \n#define inf (1ll<<60)\n#define mymax(x,y) (x>=y?x:y)\n#define mymin(x,y) (x>=y?y:x)\n#define maxsize 2000010\nint a[maxsize],dep[maxsize],num[maxsize],stop,stac[maxsize],dis[maxsize],vist,dfn[maxsize],h[maxsize],cnt,top[maxsize],siz[maxsize],son[maxsize],fa[maxsize],st[maxsize],n,m,q,f[maxsize][4],ans,ans1,ans2=inf;\nstruct node{ int y,next; }edg[maxsize<<1];\ninline bool cmp(int x,int y) { return dfn[x]<dfn[y]; }\ninline void add(int x,int y) { edg[++cnt].next=h[x],edg[cnt].y=y,h[x]=cnt; }\ninline void dfs1(int x,int fat) {\n\tsiz[x]=1;\n\tfor(reg int i=h[x];i;i=edg[i].next) {\n\t\tint y=edg[i].y;if(y==fat) continue;\n\t\tdis[y]=dis[x]+1,dep[y]=dep[fa[y]=x]+1,dfs1(y,x),siz[x]+=siz[y];\n\t\tif(siz[son[x]]<siz[y]) son[x]=y;\n\t} \n} \ninline void dfs2(int x) {\n\tdfn[x]=++vist;\n\tif(!son[x]) return;\n\ttop[son[x]]=top[x],dfs2(son[x]);\n\tfor(reg int i=h[x];i;i=edg[i].next) {\n\t\tint y=edg[i].y;if(y==fa[x]||y==son[x]) continue;\n\t\tdfs2(top[y]=y);\n\t}\n}\ninline int lca(int x,int y) {\n\twhile(top[x]^top[y]) {\n\t\tif(dep[top[x]]>dep[top[y]]) x=fa[top[x]];\n\t\telse y=fa[top[y]];\n\t}\n\tif(dep[x]<dep[y]) return x;return y;\n}\ninline void ins(int x) {\n\tif(!stop) { stac[stop=1]=x;return; }\n\tint anc=lca(stac[stop],x);\n\twhile(stop&&dep[anc]<dep[stac[stop-1]]) add(stac[stop-1],stac[stop]),--stop;//\u5f39\u6808\u8fde\u8fb9 \n\tif(dep[anc]<dep[stac[stop]]) add(anc,stac[stop]),--stop;//\u5f39\u6808\u8fde\u8fb9 \n\tif(!stop||stac[stop]!=anc) stac[++stop]=anc;\n\tstac[++stop]=x;\n}\n//\u4ee5\u4e0a\u4e3a\u865a\u6811\u5efa\u7acb\u677f\u5b50\ninline void dp(int x) {\n\tf[x][0]/*\u6700\u8fdc*/=0,f[x][1]/*\u6700\u8fd1*/=inf,f[x][2]=0/*sum*/,num[x]=0;\n\tint maxn=0,tmp=0,tmp1=inf;\n\tif(siz[x]) num[x]=1,maxn=dis[x],f[x][2]=dis[x];\n\tfor(reg int i=h[x];i;i=edg[i].next) {\n\t\tint y=edg[i].y;if(y==fa[x]) continue;\n\t\tdp(y),ans+=(f[x][2]*num[y]-dis[x]*num[y]*num[x]*2+f[y][2]*num[x])/*\u6ce8\u610f\u8fd9\u4e2a\u67ff\u5b50\u7684\u5199\uff08chi\uff09\u6cd5*/;\n\t\tif(maxn||siz[x]) tmp=mymax(maxn+f[y][0]-2*dis[x],tmp);\n\t\tmaxn=mymax(maxn,f[y][0]),f[x][0]=mymax(f[x][0],f[y][0]),f[x][2]+=f[y][2],num[x]+=num[y],f[x][1]=mymin(f[x][1],f[y][1]);\n\t\tans2=mymin(tmp1+f[y][1]-2*dis[x],ans2),tmp1=mymin(tmp1,f[y][1]); \n\t}\n\tif(siz[x]) ans2=mymin(f[x][1]-dis[x],ans2),f[x][0]=mymax(f[x][0],dis[x]),f[x][1]=mymin(f[x][1],dis[x]);\n\tans1=mymax(ans1,tmp),h[x]=siz[x]=0/*\u6e05\u7a7a\u6570\u7ec4*/;\n}\nsigned main() {\n\tn=read();\n\tfor(reg int i=1;i<n;++i) {\n\t\tint x=read(),y=read();\n\t\tadd(x,y),add(y,x);\n\t}\n\tdfs1(dep[1]=1,dis[1]=0),dfs2(top[1]=1),memset(h,0,sizeof(h)),memset(siz,0,sizeof(siz)),q=read();\n\tfor(reg int i=1;i<=q;++i) {\n\t\tint x=1;m=read();\n\t\tfor(reg int i=1;i<=m;++i) a[i]=read(),siz[a[i]]=1;\n\t\tif(!x) { while(m) siz[a[m]]=0,--m;continue; }\n\t\tans=0,sort(a+1,a+m+1,cmp);\n\t\tif(a[1]!=1) stac[stop=1]=1;\n\t\tfor(reg int i=1;i<=m;++i) ins(a[i]);\n\t\tif(stop) while(--stop) add(stac[stop],stac[stop+1]);\n\t\tdp(1),siz[1]=vist=0,printf(\"%lld %lld %lld\\n\",ans,ans2,ans1),ans=ans1=0,ans2=inf; \n\t}\n}\n```\n",
        "postTime": 1583573619,
        "uid": 134640,
        "name": "zsaskk",
        "ccfLevel": 0,
        "title": "[HEOI2014]\u5927\u5de5\u7a0b"
    },
    {
        "content": " _\u865a\u6811\u677f\u9898\u4e00\u9053\u3002\u3002\u3002_ \n\n _\u4e2a\u4eba\u89c9\u5f97\u8fd9\u9898\u6bd4 \u201c\u6d88\u8017\u6218\u201d\u66f4\u9002\u5408\u7ec3\u677f\u5b50\uff08\u6811\u5f62dp\u66f4\u4e3a\u7b80\u5355\uff09_ \n \n \n\u8bf4\u6b63\u89e3\u3002\n\n\u6ce8\u610f\u5230$\\sum |p|\\le2e6$\uff0c\u8fd9\u63d0\u793a\u6211\u4eec\u5efa\u4e00\u9897\u865a\u6811\u3002\n\n\u5efa\u597d\u540e\uff0c2\u548c3\u95ee\u5c31\u662f\u6c42\u4e00\u4e2a\u6811\u4e0a\u6700\u77ed\u8def\uff0c\u6700\u957f\u8def\uff0c\u4e0d\u518d\u8d58\u8ff0\u3002\n\n\u7b80\u5355\u8bf4\u4e00\u4e0b1\uff0c\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u7edf\u8ba1\u6709\u591a\u5c11\u70b9\u5bf9\u7ecf\u8fc7\u5b83\u3002\n\u5177\u4f53\u7684\uff0c\u6811\u5f62dp\u7684\u65f6\u5019\u7b97\u51fa\uff0c\u5373\u4e3a$siz[son]*(tot-siz[son)$\u3002\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define sf scanf\n#define ri register int\n#define in red()\n#define gc getchar()\n#define ll long long\n#define cs const\ninline int red(){\n\tint num=0,f=1;char c=gc;\n\tfor(;!isdigit(c);c=gc)if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc)num=(num<<1)+(num<<3)+(c^48);\n\treturn num*f;\n}\ncs int N=1e6+10;\ncs ll inf=1e14;\nint head[N],to[N<<1],nxt[N<<1],cnt=0,dep[N],n,m,dfn[N],tot;\ninline void adde(int u,int v){\n\tnxt[++cnt]=head[u];head[u]=cnt;to[cnt]=v;\n\tnxt[++cnt]=head[v];head[v]=cnt;to[cnt]=u;\n}\nnamespace SP{\n\tint siz[N],fa[N],top[N],son[N];\n\tinline void dfs1(int u){\n\t\tdep[u]=dep[fa[u]]+1;\n\t\tdfn[u]=++tot;\n\t\tsiz[u]=1;\n\t\tfor(ri i=head[u];i;i=nxt[i]){\n\t\t\tint v=to[i];\n\t\t\tif(v^fa[u]){\n\t\t\t\tfa[v]=u;\n\t\t\t\tdfs1(v);\n\t\t\t\tsiz[u]+=siz[v];\n\t\t\t\tif(siz[v]>siz[son[u]])son[u]=v;\n\t\t\t}\n\t\t}\n\t}\n\tinline void ddfs1(int u,int f){\n\t\ttop[u]=f;\n\t\tif(son[u])ddfs1(son[u],f);\n\t\tfor(ri i=head[u];i;i=nxt[i]){\n\t\t\tint v=to[i];\n\t\t\tif(v^fa[u]&&v^son[u])ddfs1(v,v);\n\t\t}\n\t}\n\tinline int lca(int x,int y){\n\t\twhile(top[x]^top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn dep[x]<dep[y] ? x : y;\n\t}\n\tinline void init(){\n\t\tdfs1(1);ddfs1(1,1);\n\t}\n}\nusing SP::lca;\nusing SP::init;\ninline bool cmp(cs int &a,cs int &b){return dfn[a]<dfn[b];}\ntypedef pair<int,int> pi;\n#define fi first\n#define se second\nvector<pi> g[N];\ninline void link(int x,int y){g[x].push_back(pi(y,dep[y]-dep[x]));}\nll maxn,siz[N],mx[N],mn[N],ans1,ans2,ans3;\nbool vis[N];\n//vis\u6807\u8bb0\u6253\u4e0a\uff0c\u6e05\u6389 \nvoid dfs2(int u,int fa){\n\tif(vis[u])mx[u]=mn[u]=0,siz[u]=1;\n\telse mx[u]=-inf,mn[u]=inf,siz[u]=0;\n\tfor(ri i=g[u].size()-1;i>=0;--i){\n\t\tint v=g[u][i].fi;\n\t\tif(v==fa)continue;\n\t\tdfs2(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tans1+=siz[v]*(maxn-siz[v])*g[u][i].se;\n\t\tans2=min(ans2,mn[u]+g[u][i].se+mn[v]);\n\t\tmn[u]=min(mn[u],g[u][i].se+mn[v]);\n\t\tans3=max(ans3,mx[u]+g[u][i].se+mx[v]);\n\t\tmx[u]=max(mx[u],g[u][i].se+mx[v]);\n\t}\n\tg[u].clear();\n}\ninline void work(vector<int> &f){\n\tvector<int> stk;stk.clear();\n\tsort(f.begin(),f.end(),cmp);\n\tfor(ri i=0,up=f.size();i<up;++i){\n\t\tif(!stk.size()){stk.push_back(f[i]);continue;}\n\t\tint L=lca(*stk.rbegin(),f[i]);\n\t\twhile(stk.size()>1&&dfn[*(--(--stk.end()))]>=dfn[L])link(*(--(--stk.end())),*stk.rbegin()),stk.pop_back();\n\t\tif((*stk.rbegin())^L)link(L,*stk.rbegin()),stk.pop_back(),stk.push_back(L);\n\t\tstk.push_back(f[i]);\n\t}\t\n\twhile(stk.size()>1)link(*(--(--stk.end())),*stk.rbegin()),stk.pop_back();\n\tmaxn=f.size();\n\tans1=0;ans2=inf;ans3=-inf;\n\tdfs2(*stk.begin(),0);\n\tcout<<ans1<<' '<<ans2<<' '<<ans3<<'\\n';\n\t\n}\nvector<int> cot;\nsigned main(){\n//\tfreopen(\"data.in\",\"r\",stdin);\n\tn=in;\n\tfor(ri i=1;i<n;++i)adde(in,in);\n\tinit();\n\tm=in;\n\twhile(m--){\n\t\tcot.clear();\n\t\tint k=in;\n\t\tfor(ri i=1;i<=k;++i)cot.push_back(in),vis[cot[i-1]]=1;\n\t\twork(cot);\n\t\tfor(ri i=1;i<=k;++i)vis[cot[i-1]]=0;\n\t}\n\n\treturn 0;\n}\n\n```\n\n\n",
        "postTime": 1571839048,
        "uid": 117357,
        "name": "rhjoi",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "[\u5b89\u5229$blog$](https://ctz45562.github.io/2019/08/03/\u6d1b\u8c37-P4103-HEOI2014-\u5927\u5de5\u7a0b)\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problem/P4103)\n\n\u5148\u628a\u865a\u6811\u9020\u51fa\u6765\u3002\u7edf\u8ba1\u6240\u6709\u8def\u5f84\u7684\u6700\u503c\u548c\u6743\u503c\u548c\u3002\u3002\u3002\u70b9\u5206\u6cbb\uff01\n\n\u6210\u529f\u88ab\u6570\u636e\u8303\u56f4\u62e6\u4e86\u4e0b\u6765\u3002\u3002\u3002~~\uff08\u521a\u5b66\u70b9\u5206\u6cbb\u548c\u865a\u6811\u7684\u6211\u8868\u793a\u4e24\u6837\u80fd\u4e00\u5757\u7ec3\u591a\u597d\uff09~~\n\n\u8003\u8651$DP$\uff0c\u6700\u5927\u503c\u7c7b\u4f3c\u4e8e\u6811\u7684\u76f4\u5f84\uff0c\u53ea\u4e0d\u8fc7\u4e24\u7aef\u70b9\u5fc5\u987b\u4e3a\u5173\u952e\u70b9\u3002\n\n\u8bbe$ma(i)$\u4e3a\u4ee5\u70b9$i$\u5230\u5176\u5b50\u6811\u4e2d\u7684\u5173\u952e\u70b9\u7684\u6700\u957f\u8def\u5f84\u957f\u5ea6\u3002\u82e5$i$\u4e3a\u5173\u952e\u70b9\uff0c$ma(i)$\u521d\u503c\u4e3a$0$\uff0c\u5426\u5219\u4e3a$-inf$\uff0c\u7136\u540e\u548c\u6811\u7684\u76f4\u5f84\u4e00\u6837$DP$\u5373\u53ef\u3002\u6700\u5c0f\u503c\u7c7b\u4f3c\u3002\n\n\u5bf9\u4e8e\u6743\u503c\u548c\uff0c\u8bb0$siz(i)$\u4e3a\u70b9$i$\u7684\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u4e2a\u6570\uff08\u5305\u62ec$i$\uff09\uff0c$len(i)$\u4e3a\u70b9$i$\u5230\u5176\u5b50\u6811\u4e2d\u6240\u6709\u5173\u952e\u70b9\u7684\u8def\u5f84\u6743\u503c\u4e4b\u548c\u3002\n\n\u663e\u7136\uff0c$siz(i)=\\sum\\limits_{edge(i,j)}siz(j)$\uff0c$len(i)=\\sum\\limits_{edge(i,j)}len(j)+siz(j)*length(edge(i,j))$\u3002\n\n\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5373$\\sum\\limits_{edge(i,j)}siz(i)*[len(j)+siz(j)*length(edge(i,j))]+siz(j)*len(i)$\uff0c\u6ce8\u610f\u6b64\u5904\u7684$siz(i)$\u548c$len(i)$\u662f\u7edf\u8ba1\u5230$j$\u65f6\u7684\u503c\u3002\n\n\u5176\u5b9e\u8fd8\u6709\u66f4\u7b80\u5355\u7684\u65b9\u6cd5\uff0c\u76f4\u63a5\u7edf\u8ba1\u6bcf\u6761\u8fb9\u88ab\u7ecf\u8fc7\u7684\u6b21\u6570\u4e58\u4e0a\u8fb9\u957f\uff0c\u5373$length(edge(i,j))*siz(j)*(k-siz(j))$\n\n\u590d\u6742\u5ea6$O(\\sum k\\log n+\\sum k)$\uff0c$\\log n$\u662f\u5c0f\u5e38\u6570\u6811\u5256$lca$\u3002\n\n\u4ee3\u7801\uff1a\n\n``` cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n\n#define maxn 1000005\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nstruct edge{\n\tint pre,to,l;\n};\nnamespace origin{\n\tint h[maxn],seg[maxn],top[maxn],son[maxn],fa[maxn],deep[maxn],siz[maxn],num,all;\n\tedge e[maxn<<1];\n\tinline void add(int from,int to){\n\t\te[++num].pre=h[from],h[from]=num,e[num].to=to;\n\t}\n\tvoid dfs1(int node=1){\n\t\tsiz[node]=1;\n\t\tint x;\n\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\tx=e[i].to;\n\t\t\tif(!siz[x]){\n\t\t\t\tfa[x]=node,deep[x]=deep[node]+1;\n\t\t\t\tdfs1(x),siz[node]+=siz[x];\n\t\t\t\tif(siz[x]>siz[son[node]])son[node]=x;\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs2(int node=1){\n\t\tseg[node]=++all;\n\t\tif(son[node]){\n\t\t\ttop[son[node]]=top[node],dfs2(son[node]);\n\t\t\tint x;\n\t\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\t\tx=e[i].to;\n\t\t\t\tif(!seg[x])top[x]=x,dfs2(x);\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int x,int y){\n\t\twhile(top[x]!=top[y])deep[top[x]]<deep[top[y]]?y=fa[top[y]]:x=fa[top[x]];\n\t\treturn deep[x]<deep[y]?x:y;\n\t}\n}\nnamespace virt{\n\tint ma[maxn],mi[maxn],h[maxn],siz[maxn],num,ans2,ans3;\n\tlong long len[maxn],ans1;\n\tbool vis[maxn];\n\tvector<int>p;\n\tedge e[maxn<<1];\n\tinline void add(int from,int to){\n\t\tint l=abs(origin::deep[from]-origin::deep[to]);\n\t\te[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l;\n\t\te[++num].pre=h[to],h[to]=num,e[num].to=from,e[num].l=l;\n\t}\n\tstruct Monostack{\n\t\tint sta[maxn],top;\n\t\tvoid clear(){\n\t\t\tfor(register int i=2;i<=top;++i)add(sta[i],sta[i-1]);\n\t\t\ttop=0;\n\t\t}\n\t\tvoid push(int x){\n\t\t\tsta[++top]=x;\n\t\t}\n\t\tvoid check(int x){\n\t\t\tif(x==1)return;\n\t\t\tint l=origin::lca(x,sta[top]);\n\t\t\th[x]=0;\n\t\t\tif(l!=sta[top]){\n\t\t\t\twhile(origin::seg[l]<origin::seg[sta[top-1]])add(sta[top],sta[top-1]),--top;\n\t\t\t\t--top;\n\t\t\t\tif(l!=sta[top])h[l]=0,add(sta[top+1],l),push(l);\n\t\t\t\telse add(sta[top+1],l);\n\t\t\t}\n\t\t\tpush(x);\n\t\t}\n\t}s;\n\tinline bool cmp(int x,int y){\n\t\treturn origin::seg[x]<origin::seg[y];\n\t}\n\tvoid build(){\n\t\th[1]=0,s.push(1);\n\t\tfor(vector<int>::iterator iter=p.begin();iter!=p.end();++iter)s.check(*iter);\n\t\ts.clear();\n\t}\n\tvoid dfs(int node=1,int f=0){\n\t\tsiz[node]=vis[node],len[node]=0,mi[node]=vis[node]?0:inf,ma[node]=vis[node]?0:-inf;\n\t\tint x;\n\t\tlong long l;\n\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\tx=e[i].to;\n\t\t\tif(x==f)continue;\n\t\t\tdfs(x,node);\n\t\t\tl=len[x]+1ll*e[i].l*siz[x];\n\t\t\tans1+=siz[node]*l+siz[x]*len[node];\n\t\t\tsiz[node]+=siz[x],len[node]+=l;\n\t\t\tans2=min(ans2,mi[node]+mi[x]+e[i].l);\n\t\t\tans3=max(ans3,ma[node]+ma[x]+e[i].l);\n\t\t\tmi[node]=min(mi[node],mi[x]+e[i].l);\n\t\t\tma[node]=max(ma[node],ma[x]+e[i].l);\n\t\t}\t\n\t}\n\tvoid solve(){\n\t\tp.clear(),num=ans1=ans3=0,ans2=inf;\n\t\tint n=read(),x;\n\t\tfor(register int i=1;i<=n;++i)p.push_back(x=read()),vis[x]=1;\n\t\tsort(p.begin(),p.end(),cmp);\n\t\tbuild(),dfs();\n\t\tprintf(\"%lld %d %d\\n\",ans1,ans2,ans3);\n\t\tfor(vector<int>::iterator iter=p.begin();iter!=p.end();++iter)vis[*iter]=0;\n\t}\n}\nint main(){\n\tint n=read(),x,y;\n\tfor(register int i=1;i<n;++i)x=read(),y=read(),origin::add(x,y),origin::add(y,x);\n\torigin::dfs1(),origin::dfs2();\n\tn=read();\n\twhile(n--)virt::solve();\n}\n\n```\n\n",
        "postTime": 1564837821,
        "uid": 111762,
        "name": "_ctz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\n> \u4e00\u53e5\u8bdd\u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u68f5\u5355\u4f4d\u8fb9\u6743\u7684\u6811\u548c\u82e5\u5e72\u5173\u952e\u70b9\uff0c\u6c42\u51fa\u6bcf\u4e24\u4e2a\u5173\u952e\u70b9\u95f4\u7684\u8ddd\u79bb\u4e4b\u548c\u4ee5\u53ca\u8ddd\u79bb\u6700\u5927\u3001\u6700\u5c0f\u503c\u3002\n\n\n\u865a\u6811\u6a21\u677f\u9898\u4e2d\u7684\u4e00\u5458\uff0c\u6709\u7740\u8d64\u88f8\u88f8\u7684\u63d0\u793a\u2014\u2014\u5173\u952e\u70b9\u6570\u91cf\u4e4b\u548c\u4e0d\u8d85\u8fc7 XXX\u3002\n\n\u539f\u6811\u4e0a\u7684\u8fb9\u6743\u90fd\u4e3a 1\uff0c\u5efa\u865a\u6811\u7684\u65f6\u5019\u53ef\u4ee5\u5229\u7528\u6df1\u5ea6\u5dee\u6765\u7b97\u51fa\u865a\u6811\u4e0a\u7684\u8fb9\u6743\uff0c\u4e0b\u9762\u8fc7\u7a0b\u8003\u8651\u518d\u865a\u6811\u4e0a\u5982\u4f55\u8fdb\u884c\u3002\n\n\u6bcf\u4e24\u4e2a\u5173\u952e\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e4b\u548c\u8003\u8651\u5206\u522b\u8ba1\u7b97\u6bcf\u4e00\u6761\u8fb9\u7684\u8d21\u732e\uff0c\u4e00\u6761\u8fb9\u4f1a\u88ab\u7ecf\u8fc7\u7684\u6b21\u6570\uff0c\u6839\u636e\u4e58\u6cd5\u539f\u7406\uff0c\u4f1a\u7b49\u4e8e\u4e00\u7aef\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u4e2a\u6570\u4e58\u4e0a\u53e6\u4e00\u7aef\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u4e2a\u6570\u3002\u8bb0\u5f97\u5f00 long long\u3002\n\n\u6700\u5927\u503c\u4e5f\u5f88\u597d\u7b97\uff0c\u6211\u4e00\u5f00\u59cb\u7528\u7684\u662f\u7c7b\u4f3c\u4e8e\u6811\u7684\u76f4\u5f84\u7684\u65b9\u6cd5\uff0c\u641c\u4e00\u904d\u627e\u5230\u6700\u8fdc\u7684\u70b9\uff0c\u518d\u4ece\u6700\u8fdc\u7684\u70b9\u641c\u4e00\u904d\u627e\u5230\u6700\u957f\u7684\u8fb9\uff0c\u4f46\u5176\u5b9e\u662f\u53ef\u4ee5 DP \u53bb\u505a\u7684\uff0c\u8fd9\u4e2a\u540e\u9762\u8bf4\u3002\n\n\u6700\u5c0f\u503c\u5012\u662f\u56f0\u6270\u4e86\u4e00\u4e0b\u5b50\uff0c\u53d1\u73b0\u6ca1\u6709\u529e\u6cd5\u50cf\u6c42\u6700\u5927\u503c\u4e00\u6837\u641c\u4e24\u904d\u4e4b\u7c7b\u7684\u8003\u8651\u5230\u6240\u6709\u8fb9\u3002\u53d1\u73b0\u5176\u5b9e\u6700\u5c0f\u503c\u80af\u5b9a\u662f\u76f8\u90bb\u4e24\u4e2a\u5173\u952e\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\uff0c\u6ca1\u6709\u5fc5\u8981\u7ecf\u8fc7\u4e00\u4e2a\u70b9\uff0c\u90a3\u4e48\u5176\u5b9e\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u5982\u679c\u8fd9\u4e2a\u70b9\u662f\u5173\u952e\u70b9\uff0c\u5c31\u7528\u5230\u5b50\u6811\u4e2d\u6700\u8fd1\u7684\u4e00\u4e2a\u5173\u952e\u70b9\u7684\u8ddd\u79bb\u66f4\u65b0\u7b54\u6848\uff1b\u5982\u679c\u8fd9\u4e2a\u70b9\u4e0d\u662f\u5173\u952e\u70b9\uff0c\u8003\u8651\u7528\u8fd9\u4e2a\u70b9\u4e2d\u8f6c\uff0c\u7528\u5230\u6700\u8fd1\u548c\u6b21\u8fd1\u7684\u4e24\u4e2a\u5173\u952e\u70b9\u6765\u66f4\u65b0\u7b54\u6848\u5373\u53ef\u3002\n\n\u53cd\u8fc7\u6765\u60f3\u4e00\u60f3\uff0c\u6700\u5927\u503c\u5176\u5b9e\u4e5f\u53ef\u4ee5\u8fd9\u6837\u505a\uff0c\u7528\u6700\u5927\u503c\u548c\u6b21\u5927\u503c\u66f4\u65b0\u5373\u53ef\u3002\n\n\u8dd1\u5f97\u633a\u6162\u7684\uff0c\u770b\u522b\u4eba\u90fd\u662f\u4e00\u4e2a DFS \u6c42\u51fa\u4e86\u6240\u6709\u7684\u4e1c\u897f\uff0c\u4ee3\u7801\u7b80\u6d01\u5e38\u719f\u5c0f\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0c\u6211\u7684\u8fd9\u79cd\u505a\u6cd5\u5c31\u663e\u5f97\u4e0d\u90a3\u4e48\u4f18\u96c5\u4e86\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long var;\n\nconst int N = 1100006;\nconst int INF = 0x3f3f3f3f;\n\nint n, k, a[N];\nint top, fi[N], ne[N << 1], to[N << 1];\nvar co[N << 1];\nint T, dfn[N], fa[N], deep[N], maxson[N], linetop[N];\nvar size[N];\nint cnt, sta[N];\nbool mark[N];\nint dist[N];\n\nvar read();\nvoid add(int u, int v, int w);\nvoid getInfo(int t);\nvoid getLink(int t);\nint lca(int x, int y);\nvoid solve();\nvoid build();\nvoid dpinit(int t, int f);\nvar dpsum(int t, int f);\nvar dpmin(int t, int f);\nvoid dpmin(int t, int f, int s, int &x, int &ms);\nvar dpmax();\nvoid dpmax(int t, int f, int s, int &x, int &ms);\nvoid dpclean(int t, int f);\n\nint main() {\n  n = read();\n  for (int i = 2; i <= n; ++i) add(read(), read(), 0);\n  getInfo(1), getLink(1);\n  for (int i = 1; i <= n; ++i) fi[i] = 0;\n  int q = read();\n  while (q--) solve();\n  return 0;\n}\n\nvar read() {\n  var a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n\nvoid add(int u, int v, int w) {\n  ne[++top] = fi[u], fi[u] = top, to[top] = v, co[top] = w;\n  ne[++top] = fi[v], fi[v] = top, to[top] = u, co[top] = w;\n}\n\nvoid getInfo(int t) {\n  dfn[t] = ++T;\n  size[t] = 1;\n  deep[t] = deep[fa[t]] + 1;\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == fa[t]) continue;\n    fa[to[i]] = t;\n    getInfo(to[i]);\n    size[t] += size[to[i]];\n    if (size[to[i]] > size[maxson[t]]) maxson[t] = to[i];\n  }\n}\n\nvoid getLink(int t) {\n  if (t == maxson[fa[t]])\n    linetop[t] = linetop[fa[t]];\n  else\n    linetop[t] = t;\n  if (maxson[t]) getLink(maxson[t]);\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == fa[t] || to[i] == maxson[t]) continue;\n    getLink(to[i]);\n  }\n}\n\nint lca(int x, int y) {\n  while (linetop[x] != linetop[y]) {\n    if (deep[linetop[x]] < deep[linetop[y]]) swap(x, y);\n    x = fa[linetop[x]];\n  }\n  if (deep[x] > deep[y]) swap(x, y);\n  return x;\n}\n\nvoid solve() {\n  k = read();\n  for (int i = 1; i <= k; ++i) a[i] = read();\n  for (int i = 1; i <= k; ++i) mark[a[i]] = true;\n  build();\n  dpinit(1, 1);\n  printf(\"%lld %lld %lld\\n\", dpsum(1, 1), dpmin(1, 1), dpmax());\n  dpclean(1, 1);\n  for (int i = 1; i <= k; ++i) mark[a[i]] = false;\n}\n\nvoid build() {\n  sort(a + 1, a + k + 1, [=](int x, int y) { return dfn[x] < dfn[y]; });\n  top = 0;\n  sta[cnt = 1] = 1;\n  for (int i = 1; i <= k; ++i) {\n    int x = a[i], p = lca(sta[cnt], x);\n    while (deep[p] < deep[sta[cnt]]) {\n      if (deep[p] >= deep[sta[cnt - 1]]) {\n        add(p, sta[cnt], deep[sta[cnt]] - deep[p]);\n        if (sta[--cnt] != p) sta[++cnt] = p;\n        break;\n      }\n      add(sta[cnt], sta[cnt - 1], deep[sta[cnt]] - deep[sta[cnt - 1]]), cnt--;\n    }\n    if (sta[cnt] != x) sta[++cnt] = x;\n  }\n  while (cnt - 1) {\n    add(sta[cnt], sta[cnt - 1], deep[sta[cnt]] - deep[sta[cnt - 1]]), cnt--;\n  }\n}\n\nvoid dpinit(int t, int f) {\n  size[t] = mark[t];\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    dpinit(to[i], t);\n    size[t] += size[to[i]];\n  }\n}\n\nvar dpsum(int t, int f) {\n  var sum = 0;\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    sum += size[to[i]] * (size[1] - size[to[i]]) * co[i] + dpsum(to[i], t);\n  }\n  return sum;\n}\n\nvar dpmin(int t, int f) {\n  var res = INF, vmin = INF, vmjn = INF;\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    res = min(res, dpmin(to[i], t));\n    if (dist[to[i]] + co[i] < vmin) vmjn = vmin, vmin = dist[to[i]] + co[i];\n    else if (dist[to[i]] + co[i] < vmjn) vmjn = dist[to[i]] + co[i];\n  }\n  if (mark[t]) {\n    dist[t] = 0;\n    return min(res, vmin);\n  }\n  dist[t] = vmin;\n  return min(res, vmin + vmjn);\n}\n\nvar dpmax() {\n  int x = 0, ms = 0;\n  dpmax(1, 1, 0, x, ms);\n  ms = 0;\n  dpmax(x, x, 0, x, ms);\n  return ms;\n}\n\nvoid dpmax(int t, int f, int s, int &x, int &ms) {\n  if (mark[t] && s > ms) ms = s, x = t;\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    dpmax(to[i], t, s + co[i], x, ms);\n  }\n}\n\nvoid dpclean(int t, int f) {\n  for (int i = fi[t]; i; i = ne[i]) {\n    if (to[i] == f) continue;\n    dpclean(to[i], t);\n  }\n  fi[t] = 0;\n}\n```",
        "postTime": 1570533373,
        "uid": 20522,
        "name": "ccviolett",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u7a81\u7136\u53d1\u73b0\u6211\u4e09\u4e2a\u5b50\u4efb\u52a1\u7684\u505a\u6cd5\u548c\u5927\u4f6c\u4eec\u90fd\u4e0d\u4e00\u6837\uff0c\u4e8e\u662f\u53d1\u4e2a\u9898\u89e3\u3002  \n\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u9996\u5148\u5efa\u7acb\u865a\u6811\uff0c\u8fb9\u6743\u4e3a\u4e24\u4e2a\u7ed3\u70b9\u5728\u539f\u6811\u4e0a\u7684\u8ddd\u79bb\u3002  \n\u5bf9\u4e8e\u8be2\u95ee\u6700\u8fdc\u8ddd\u79bb\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u6027\u8d28\uff0c\u865a\u6811\u4e0a\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u4e00\u5b9a\u90fd\u662f\u5173\u952e\u7ed3\u70b9\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\u5bf9\u5df2\u7ecf\u52a0\u5165\u7684\u5173\u952e\u7ed3\u70b9\u6570\u8fdb\u884c\u5f52\u7eb3\uff0c\u4ece\u800c\u8bc1\u660e\u3002\u4e8e\u662f\u76f4\u63a5\u627e\u51fa\u76f4\u5f84\u5c31\u597d\u4e86\u3002  \n\u5bf9\u4e8e\u6700\u8fd1\u8ddd\u79bb\uff0c\u6211\u4eec\u901a\u8fc7\u4e24\u904ddp\uff0c\u627e\u51fa\u8ddd\u79bb\u865a\u6811\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u6700\u8fd1\u548c\u6b21\u8fd1\u7684\u5173\u952e\u7ed3\u70b9\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u5173\u952e\u7ed3\u70b9\uff0c\u8ddd\u79bb\u5b83\u6700\u8fd1\u7684\u975e\u672c\u8eab\u5173\u952e\u7ed3\u70b9\u663e\u7136\u5c31\u662f\u8ddd\u79bb\u5b83\u6b21\u8fd1\u7684\u5173\u952e\u7ed3\u70b9\u3002\u6211\u4eec\u9700\u8981\u8fdb\u884c\u4e24\u6b21dp\uff0c\u4e00\u6b21\u7edf\u8ba1\u5b50\u6811\u4e2d\u7684\u7ed3\u70b9\u3002\u53e6\u4e00\u6b21\u8003\u8651\u7236\u7ed3\u70b9\u7684\u5f71\u54cd\u3002  \n\u5bf9\u4e8e\u603b\u8ddd\u79bb\uff0c\u6211\u4eec\u5bf9\u6bcf\u4e00\u6761\u8fb9\u7684\u8d21\u732e\u5206\u522b\u8ba8\u8bba\u3002\u8bbe\u8be5\u8fb9\u4e00\u4fa7\u5171\u6709k\u4e2a\u5173\u952e\u7ed3\u70b9\uff0c\u603b\u5171\u6709tot\u4e2a\u5173\u952e\u7ed3\u70b9\uff0c\u5219\u8be5\u8fb9\u4e00\u5171\u88ab\u7ecf\u8fc7\u4e86\n$k(tot-k)$\u6b21\u3002dfs\u65f6\u5f00\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\u8bb0\u5f55\u5373\u53ef\u3002 \n\u4e0b\u9762\u662f\u4ee3\u7801\uff1a\n```\n#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <cstring>\n#include <math.h>\n#include <algorithm>\n\nconst long long INF = 1000000005;\nconst long long MAXN = 1000005;\nconst long long MAXM = 1000005;\n\nlong long max(long long x, long long y)\n{\n    return x > y ? x : y;\n}\nlong long min(long long x, long long y)\n{\n    return x < y ? x : y;\n}\n\nstruct node {\n    long long to;\n    long long w;\n    node *next;\n};\nvoid addnode(node *&head, long long to, long long w)\n{\n    node *p = new node;\n    p->to = to;\n    p->w = w;\n    p->next = head;\n    head = p;\n}\nvoid del(node *&head)\n{\n    while (head)\n    {\n        node *p = head;\n        head = p->next;\n        delete p;\n    }\n}\n\nlong long N, M;\nnode *edge[MAXN];\nlong long size[MAXN], son[MAXN], fa[MAXN], deep[MAXN];\nlong long top[MAXN], rank[MAXN], id[MAXN];\n\nvoid dfs1(long long v)\n{\n    size[v] = 1;\n    deep[v] = deep[fa[v]] + 1;\n    for (node *p = edge[v]; p; p = p->next)\n    {\n        if (p->to == fa[v])\n            continue;\n        fa[p->to] = v;\n        dfs1(p->to);\n        size[v] += size[p->to];\n        if (size[p->to] > size[son[v]])\n            son[v] = p->to;\n    }\n}\n\nlong long dfs_clock;\nvoid dfs2(long long v, long long t)\n{\n    dfs_clock++;\n    rank[v] = dfs_clock;\n    id[dfs_clock] = v;\n    top[v] = t;\n\n    if (son[v])\n        dfs2(son[v], t);\n    for (node *p = edge[v]; p; p = p->next)\n        if (p->to != fa[v] && p->to != son[v])\n            dfs2(p->to, p->to);\n}\n\nlong long LCA(long long x, long long y)\n{\n    if (top[x] == top[y])\n        return deep[x] < deep[y] ? x : y;\n    if (deep[top[x]] > deep[top[y]])\n        return LCA(fa[top[x]], y);\n    return LCA(x, fa[top[y]]);\n}\n\nlong long query(long long x, long long anc)\n{\n    if (top[x] == top[anc])\n        return deep[x] - deep[anc] + 1;\n    return deep[x] - deep[top[x]] + 1 + query(fa[top[x]], anc);\n}\nlong long dis(long long x, long long y)//x \u5230 y \u7684\u7ed3\u70b9\u6570\u91cf \n{\n    long long lca = LCA(x, y);\n    return query(x, lca) + query(y, lca) - 1;\n}\n\nlong long key[MAXN], cnt;\nbool mark[MAXN];\nlong long S[MAXN], t, tmp[MAXN], tt;\nnode *e[MAXN];\n\nlong long SUM, num[MAXN], near[MAXN][2];\n\nvoid pushup(long long v, long long to)\n{\n    if (near[to][0] != near[v][0] && near[to][0] != near[v][1] && near[to][0])\n    {\n        if (!near[v][0] || dis(near[to][0], v) < dis(near[v][0], v))\n        {\n            near[v][1] = near[v][0];\n            near[v][0] = near[to][0];\n        }\n        else if (!near[v][1] || dis(near[to][0], v) < dis(near[v][1], v))\n            near[v][1] = near[to][0];\n    }\n    if (near[to][1] != near[v][0] && near[to][1] != near[v][1] && near[to][1])\n        if (!near[v][1] || dis(near[to][1], v) < dis(near[v][1], v))\n            near[v][1] = near[to][1];\n}\n\nvoid dfs3(long long v, long long fa)\n{\n    num[v] = mark[v];\n    near[v][0] = near[v][1] = 0;\n    if (mark[v])\n        near[v][0] = v;\n    for (node *p = e[v]; p; p = p->next)\n    {\n        if (p->to == fa)\n            continue;\n        dfs3(p->to, v);\n        num[v] += num[p->to];\n        pushup(v, p->to);\n        SUM += p->w*num[p->to] * (cnt - num[p->to]);\n    }\n}\n\nvoid dfs4(long long v, long long fa)\n{\n    if (fa)\n        pushup(v, fa);\n    for (node *p = e[v]; p; p = p->next)\n        if (p->to != fa)\n            dfs4(p->to, v);\n}\n\nlong long mxd, mxid, dep[MAXN];\nvoid dfs5(long long v, long long fa)\n{\n    for (node *p = e[v]; p; p = p->next)\n    {\n        if (p->to == fa)\n            continue;\n        dep[p->to] = dep[v] + p->w;\n        dfs5(p->to, v);\n    }\n    if (dep[v] > mxd)\n    {\n        mxd = dep[v];\n        mxid = v;\n    }\n}\nlong long getd(long long root)\n{\n    mxd = dep[root] = 0;\n    dfs5(root, 0);\n    mxd = dep[mxid] = 0;\n    dfs5(mxid, 0);\n    return mxd;\n}\n\nvoid solve()\n{\n    SUM = 0;\n    dfs3(S[0], 0);\n    dfs4(S[0], 0);\n    long long mx = getd(S[0]), mn = INF;\n    for (long long i = 1; i <= cnt; i++)\n        mn = min(mn, dis(key[i], near[key[i]][1]) - 1);\n    printf(\"%lld %lld %lld\\n\", SUM, mn, mx);\n}\n\nbool cmp(const long long a, const long long b)\n{\n    return rank[a] < rank[b];\n}\n\nvoid add_edge(long long x, long long y, long long w)\n{\n    addnode(e[x], y, w);\n    addnode(e[y], x, w);\n}\n\nvoid build()\n{\n    std::sort(key + 1, key + cnt + 1, cmp);\n\n    t = tt = 0;\n    S[t++] = key[1];\n    for (long long i = 2; i <= cnt; i++)\n    {\n        long long x = key[i];\n        long long lca = LCA(x, S[t - 1]);\n        tmp[tt++] = lca;\n        if (S[t - 1] == lca)\n            S[t++] = x;\n        else\n        {\n            while (t >= 2 && deep[S[t - 2]] >= deep[lca])\n            {\n                add_edge(S[t - 1], S[t - 2], dis(S[t - 1], S[t - 2]) - 1);\n                t--;\n            }\n            if (S[t - 1] != lca)\n            {\n                add_edge(S[t - 1], lca, dis(S[t - 1], lca) - 1);\n                S[t - 1] = lca;\n            }\n            S[t++] = x;\n        }\n    }\n    while (t >= 2)\n    {\n        add_edge(S[t - 1], S[t - 2], dis(S[t - 1], S[t - 2]) - 1);\n        t--;\n    }\n\n    for (long long i = 1; i <= cnt; i++)\n        mark[key[i]] = true;\n}\n\nvoid clear()\n{\n    for (long long i = 1; i <= cnt; i++)\n    {\n        mark[key[i]] = false;\n        del(e[key[i]]);\n    }\n    for (long long i = 0; i < tt; i++)\n        del(e[tmp[i]]);\n}\n\nvoid init()\n{\n    long long i, u, v;\n    \n    scanf(\"%lld\", &N);\n    for (i = 1; i < N; i++)\n    {\n        scanf(\"%lld %lld\", &u, &v);\n        addnode(edge[u], v, 1);\n        addnode(edge[v], u, 1);\n    }\n    scanf(\"%lld\", &M);\n\n    dfs1(1);\n    dfs2(1, 1);\n}\n\nint main()\n{\n    long long i, j;\n    \n    init();\n\n    for (i = 1; i <= M; i++)\n    {\n        scanf(\"%lld\", &cnt);\n        for (j = 1; j <= cnt; j++)\n            scanf(\"%lld\", &key[j]);\n        build();\n        solve();\n        clear();\n    }\n\n    //system(\"pause\");\n    return 0;\n}\n```",
        "postTime": 1542511662,
        "uid": 64366,
        "name": "ddwqwq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    },
    {
        "content": "\u865a\u6811dp\n\n\u5bf9\u6bcf\u6b21\u8be2\u95ee\u9996\u5148\u80af\u5b9a\u662f\u5efa\u865a\u6811\u7136\u540edp\u3002\u5efa\u865a\u6811\u7684\u8fc7\u7a0b\u53ef\u4ee5\u53c2\u8003\u7f51\u4e0a\u7684\u6559\u7a0b\u548c\u8fd9\u91cc\u7684\u6a21\u677f\uff08\u56e0\u4e3a\u6211\u611f\u89c9\u6211\u8fd8\u6ca1\u6cd5\u89e3\u91ca\u5f97\u592a\u6e05\u695a\uff0c\u6240\u4ee5\u6700\u597d\u8fd8\u662f\u4e0d\u8981\u778e\u8bb2\uff09\n\n\u4e3a\u4e86\u4e4b\u540e\u7684dp\u65b9\u4fbf\uff0c\u5efa\u865a\u6811\u7684\u65f6\u5019\u53ef\u4ee5\u5f3a\u884c\u628a1\u53f7\u70b9\u52a0\u8fdb\u53bb\uff0c\u4f46\u662f\u5982\u679c\u7ed9\u51fa\u7684\u5173\u952e\u70b9\u91cc\u5df2\u7ecf\u67091\u53f7\u70b9\u5c31\u4e0d\u80fd\u91cd\u590d\u52a0\uff0c\u4e0d\u7136\u4f1a\u6709\u91cd\u8fb9\uff0c\u672c\u9898\u91cd\u8fb9\u4f1a\u5bf9dp\u9020\u6210\u5f71\u54cd\u3002\n\n\u865a\u6811\u7684\u6811\u8fb9\u6743\u503c\u4e3a\u539f\u6811\u4e2d\u4e24\u70b9\u8ddd\u79bb\uff0c\u4e0d\u80fd\u5f531\u505a\n\n\u7136\u540e\u662fdp\u3002\u8fd9\u9898\u662f\u6bd4\u8f83\u663e\u7136\u7684\u5b50\u6811dp\n\n$d[x]$\u8868\u793a\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u5404\u5173\u952e\u70b9\u5230$x$\u7684\u8ddd\u79bb\u4e4b\u548c\n\n$size[x]$\u8868\u793a\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u6570\u91cf\n\n$f[x]$\u8868\u793a\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u5230$x$\u7684\u8ddd\u79bb\u6700\u5c0f\u503c\uff0c$g[x]$\u8868\u793a\u6700\u5927\u503c\n\n\u53e6\u5916$ans_1, ans_2, ans_3$\u4f9d\u6b21\u8868\u793a\u7b54\u6848\uff08\u8ddd\u79bb\u548c\uff0c\u6700\u5c0f\u503c\uff0c\u6700\u5927\u503c\uff09\n\n\u8003\u8651\u6211\u4eec\u6811\u5f62dp\u5728dfs\u7684\u65f6\u5019\u5176\u5b9e\u662f\u4e00\u4e2a\u4e0d\u65ad\u9047\u5230\u65b0\u7684\u5b50\u6811\u7684\u8fc7\u7a0b\uff0c\u6362\u53e5\u8bdd\u8bf4\u662f\u4e00\u4e2a\u4e0d\u65ad\u5408\u5e76\u4e24\u68f5\u5b50\u6811\u7684\u8fc7\u7a0b\u3002\u4e8e\u662f\u53ef\u4ee5\u628a\u56fe\u753b\u6210\u8fd9\u6837\n\n![](https://cdn.luogu.com.cn/upload/pic/37353.png)\n\n\u53ef\u4ee5\u5148\u7528\u4e24\u68f5\u6811\u7684\u60c5\u51b5\u66f4\u65b0\u7b54\u6848\uff0c\u7136\u540e\u518d\u5c06$v$\u5b50\u6811\u7684\u4fe1\u606f\u5408\u5e76\u5230$x$\u4e0a\u53bb\uff1a\n\n```cpp\nif (size[x] > 0) {\n    ans1 += size[x] * size[v] * w + size[v] * d[x] + size[x] * d[v];\n    chkMin(ans2, f[x] + w + f[v]);\n    chkMax(ans3, g[x] + w + g[v]);\n}\nd[x] += d[v] + size[v] * w;\nchkMin(f[x], w + f[v]);\nchkMax(g[x], w + g[v]);\nsize[x] += size[v];\n```\n\n\u6ce8\u610f$size[x] > 0$\u8fd9\u4e2a\u6761\u4ef6\u3002\u5982\u679c\u5f53\u524d$x$\u4fa7\u8fd8\u6ca1\u6709\u4efb\u4f55\u5173\u952e\u70b9\uff0c\u5c31\u8bf4\u660e\u6b64\u65f6\u7684$f[x],g[x]$\u662f\u6ca1\u6709\u610f\u4e49\u7684\u503c\uff0c\u7528\u5b83\u4eec\u66f4\u65b0\u7b54\u6848\u53ef\u80fd\u4f1a\u51fa\u9519\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u4e2a\u4eba\u7684\u4ee3\u7801\u5b9e\u73b0\u3002\n\n\u6700\u540e\uff0c\u5728\u865a\u6811dp\u7684dfs\u8fc7\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u8981\u987a\u624b\u628ahead\u6e05\u96f6\uff0c\u5982\u679c\u6bcf\u6b21$O(n)$\u5730\u6e05\u7a7ahead\u6570\u7ec4\u5c31\u767d\u5fd9\u6d3b\u4e86\u3002\n\n```cpp\n#include <cctype>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\ntemplate <typename T> inline void read(T& t) {\n    int f = 0, c = getchar(); t = 0;\n    while (!isdigit(c)) f |= c == '-', c = getchar();\n    while (isdigit(c)) t = t * 10 + c - 48, c = getchar();\n    if (f) t = -t;\n}\ntemplate <typename T> inline bool chkMin(T& x, const T& y) { return y < x ? (x = y, true) : false; }\ntemplate <typename T> inline bool chkMax(T& x, const T& y) { return x < y ? (x = y, true) : false; }\n#ifdef WIN32\n#define LLIO \"%I64d\"\n#else\n#define LLIO \"%lld\"\n#endif\t// WIN32 long long\n#define rep(I, A, B) for (int I = (A); I <= (B); ++I)\n#define rrep(I, A, B) for (int I = (A); I >= (B); --I)\n#define erep(I, X) for (int I = head[X]; I; I = next[I])\n\nconst int maxn = 1e6 + 207;\nconst long long inf = 1e14;\nstruct Graph {\n    int v[maxn << 1], w[maxn << 1], head[maxn], next[maxn << 1];\n    int tot;\n    void ae(int x, int y, int z = 0) {\n        v[++tot] = y; w[tot] = z; next[tot] = head[x]; head[x] = tot;\n        v[++tot] = x; w[tot] = z; next[tot] = head[y]; head[y] = tot;\n    }\n};\nGraph T, V;\nint dep[maxn], anc[30][maxn], dfn[maxn];\nlong long d[maxn], size[maxn], f[maxn], g[maxn], ans1, ans2, ans3;\nint n, m, xys;\n\ninline bool cmp(int x, int y) { return dfn[x] < dfn[y]; }\nvoid dfs1(int x) {\n    dep[x] = dep[anc[0][x]] + 1; dfn[x] = ++xys;\n    rep(i, 1, 22) anc[i][x] = anc[i - 1][anc[i - 1][x]];\n    for (int i = T.head[x]; i; i = T.next[i])\n        if (T.v[i] != anc[0][x]) {\n            anc[0][T.v[i]] = x;\n            dfs1(T.v[i]);\n        }\n}\ninline int getlca(int x, int y) {\n    if (x == y) return x;\n    if (dep[x] < dep[y]) std::swap(x, y);\n    rrep(i, 22, 0) if (dep[anc[i][x]] >= dep[y]) x = anc[i][x];\n    if (x == y) return x;\n    rrep(i, 22, 0) if (anc[i][x] != anc[i][y]) x = anc[i][x], y = anc[i][y];\n    return anc[0][x];\n}\ninline int getDist(int x, int y) {\n    return dep[x] < dep[y] ? dep[y] - dep[x] : dep[x] - dep[y];\n}\nint st[maxn], top;\nbool key[maxn];\ninline void insert(int x) {\n    if (!top) { st[++top] = x; return; }\n    int lca = getlca(st[top], x);\n    while (dep[st[top - 1]] > dep[lca] && top > 1) {\n        V.ae(st[top - 1], st[top], getDist(st[top - 1], st[top]));\n        --top;\n    }\n    if (dep[lca] < dep[st[top]]) {\n        V.ae(lca, st[top], getDist(lca, st[top]));\n        --top;\n    }\n    if (!top || dep[st[top]] < dep[lca]) st[++top] = lca;\n    st[++top] = x;\n}\ninline void buildVirtual(int *S, int k) {\n    std::sort(S + 1, S + k + 1, cmp);\n    V.tot = 0;\n    if (S[1] != 1) st[top = 1] = 1;\n    else st[top = 0] = 0;\n    rep(i, 1, k) insert(S[i]), key[S[i]] = 1;\n    while (top > 1) V.ae(st[top], st[top - 1], getDist(st[top], st[top - 1])), --top;\n}\nvoid dfs2(int x, int fa) {\n    size[x] = key[x]; d[x] = g[x] = 0; f[x] = key[x] ? 0 : inf;\n    for (int i = V.head[x]; i; i = V.next[i]) {\n        int v = V.v[i], w = V.w[i];\n        if (v != fa) {\n            dfs2(v, x);\n            if (size[x] > 0) {\n                ans1 += size[x] * size[v] * w + size[v] * d[x] + size[x] * d[v];\n                chkMin(ans2, f[x] + w + f[v]);\n                chkMax(ans3, g[x] + w + g[v]);\n            }\n            d[x] += d[v] + size[v] * w;\n            chkMin(f[x], w + f[v]);\n            chkMax(g[x], w + g[v]);\n            size[x] += size[v];\n        }\n    }\n    V.head[x] = key[x] = 0;\n}\n\nint main() {\n    read(n);\n    T.tot = V.tot = 0;\n    rep(i, 1, n) T.head[i] = V.head[i] = 0;\n    rep(i, 1, n - 1) {\n        int x, y; read(x); read(y); T.ae(x, y);\n    }\n    dfs1(1);\n    read(m);\n    rep(i, 1, m) {\n        int k; read(k);\n        int *S = new int[k + 10];\n        rep(j, 1, k) read(S[j]);\n        buildVirtual(S, k);\n        ans1 = 0; ans2 = inf; ans3 = 0;\n        dfs2(1, 0);\n        printf(LLIO \" \" LLIO \" \" LLIO \"\\n\", ans1, ans2, ans3);\n        delete[] S;\n    }\n    return 0;\n}\n```",
        "postTime": 1539272450,
        "uid": 72071,
        "name": "GKxx",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4103 \u3010[HEOI2014]\u5927\u5de5\u7a0b \u3011"
    }
]