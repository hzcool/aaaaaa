[
    {
        "content": "\u4e22\u4e2a[\u535a\u5ba2](https://www.zgz233.xyz/2017/12/12/bzoj-5121-2017%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F%E6%B5%8B%E8%AF%95hello-world/ \"\u535a\u5ba2\")\u94fe\u63a5\u3002\u3002\n\n\u8fd9\u9898\u6253 LOJ \u7684 VP \u7684\u65f6\u5019\u5199\u66b4\u529b+\u5361\u5e38\u62ff\u4e86 83\u5206...\n\n\u5176\u5b9e YY \u51fa\u505a\u6cd5\u662f\u4e0d\u56f0\u96be\u7684\uff0c\u8003\u8651\u7ef4\u62a4\u6df1\u5ea6\u6a21 $K$ \u610f\u4e49\u4e0b\u76f8\u540c\u7684\u8282\u70b9\uff0c\u5efa $K$ \u9897\u6811\u5373\u53ef\u3002\n\n$k$ \u8f83\u5927\u7684\u65f6\u5019\u66b4\u529b\u8df3\uff0c\u5426\u5219 $dfs$ \u5e8f+\u6811\u72b6\u6570\u7ec4\u7edf\u8ba1\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u7528\u5e76\u67e5\u96c6\u5c06\u90fd\u662f $1$ \u7684\u4e32\u8d77\u6765\u5373\u53ef\uff0c\u5f00\u65b9 $log$ \u6b21\u5c31\u53d8\u6210 $1$ \u4e86\uff0c\u548c\u82b1\u795e\u6e38\u5386\u5404\u56fd\u90a3\u9898\u662f\u4e00\u6837\u7684\u3002\n\n\u7136\u540e\u5c31\u6ca1\u4e86...\n\n\u7ed3\u679c\u5de8\u4e0d\u597d\u5199...\n\n\u4e0d\u8981\u95ee\u6211\u590d\u6742\u5ea6\u5206\u6790\u548c\u5757\u5927\u5c0f\u591a\u5927\u6bd4\u8f83\u4f18...\u8be6\u7ec6\u4e00\u70b9\u7684\u53ef\u4ee5\u770b\u5b98\u65b9\u9898\u89e3\uff0c\u8d34\u4e2a\u4ee3\u7801\uff08\u9003\n\n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n     \n```cpp\n    #include <cmath>\n    #include <queue>\n    #include <cstdio>\n    #include <iomanip>\n    #include <cstdlib>\n    #include <cstring>\n    #include <iostream>\n    #include <algorithm>\n    #define N 50010\n    #define MX 500000\n    #define ll long long\n    using namespace std;\n    #define fstc __attribute__((optimize(\"-O3\")))\n    #define IL __inline__ __attribute__((always_inline))\n    char xB[1<<15],*xS=xB,*xT=xB;\n    #define getchar() (xS==xT&&(xT=(xS=xB)+fread(xB,1,1<<15,stdin),xS==xT)?0:*xS++)\n    fstc IL ll read()\n    {\n        ll x=0,f=1;char ch=getchar();\n        while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n        while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n        return x*f;\n    }\n    #define OUT 2000000\n    char Out[OUT],*ou=Out;\n    int Outn[30],Outcnt;\n    fstc IL void write(ll x)\n    {\n        if(!x)*ou++=48;\n        else\n        {\n            for(Outcnt=0;x;x/=10)Outn[++Outcnt]=x%10+48;\n            while(Outcnt)*ou++=Outn[Outcnt--];\n        }\n    }\n    #define K 20\n    int n,Q;\n    int path[N],path_top;\n    ll a[N];\n    int sqr[MX+10];\n    struct graph\n    {\n        struct zgz\n        {\n            int next,to;\n        }edge[N<<1];\n        int head[N],cnt;\n        fstc void init(){cnt=1;}\n        fstc void add(int from,int to)\n        {\n            edge[cnt].to=to;\n            edge[cnt].next=head[from];\n            head[from]=cnt++;\n        }\n        fstc void ins(int from,int to)\n        {add(from,to),add(to,from);}\n    };\n    struct Bit\n    {\n        int n;\n        ll c[N<<1];\n        fstc void add(int x,ll v)\n        {\n            for(;x<=n;x+=x&(-x))\n            c[x]+=v;\n        }\n        fstc ll ask(int x)\n        {\n            ll ret=0;\n            for(;x;x-=x&(-x))\n            ret+=c[x];\n            return ret;\n        }\n    };\n    struct Unionset\n    {\n        int n;\n        int fa[N];\n        fstc void init(int x)\n        {\n            n=x;\n            for(int i=1;i<=n;i++)fa[i]=i;\n        }\n        fstc int find(int x)\n        {return fa[x]==x?x:fa[x]=find(fa[x]);}\n        fstc void Union(int x,int y)\n        {if(find(x)!=find(y))fa[fa[x]]=y;}\n    };\n    struct block\n    {\n        graph G;\n        Unionset S;\n        Bit B;\n        int fa[N],deep[N];\n        fstc void set_fa(int x,int f)\n        {fa[x]=f,G.add(f,x);}\n        int tim_in[N],tim_out[N],dfn;\n        fstc void dfs(int x)\n        {\n            tim_in[x]=++dfn;\n            B.add(dfn,a[x]);\n            for(int i=G.head[x];i;i=G.edge[i].next)\n            {\n                int to=G.edge[i].to;\n                deep[to]=deep[x]+1;\n                dfs(to);\n            }\n            tim_out[x]=++dfn;\n            B.add(dfn,-a[x]);\n        }\n        fstc void init()\n        {\n            S.init(n);\n            for(int i=1;i<=n;i++)\n            if(a[i]==1) S.Union(i,fa[i]);\n            B.n=n<<1;\n            for(int i=1;i<=n;i++)\n            if(!fa[i])deep[i]=1,dfs(i);\n        }\n        fstc void modify(int x,ll v)\n        {\n            B.add(tim_in[x],v-a[x]),B.add(tim_out[x],a[x]-v);\n            if(v==1)S.Union(x,fa[x]);\n        }\n        fstc void get_path(int x,int pos)\n        {\n            while(deep[x]>=deep[pos])\n            {\n                path[++path_top]=x;\n                x=S.find(fa[x]);\n            }\n        }\n        fstc ll ask(int x,int top)\n        {return B.ask(tim_in[x])-B.ask(tim_in[fa[top]]);}\n    }T[K+5];\n    graph G;\n    int fa[N],deep[N];\n    int stk[N],top;\n    int anc[N][17];\n    fstc void dfs(int x)\n    {\n        stk[++top]=x;\n        for(int i=1;i<=K&&i<top;i++)\n        T[i].set_fa(x,stk[top-i]);\n        for(int i=G.head[x];i;i=G.edge[i].next)\n        {\n            int to=G.edge[i].to;\n            if(to==fa[x])continue ;\n            fa[to]=x,deep[to]=deep[x]+1;\n            dfs(to);\n        }\n        top--;\n    }\n    fstc void init()\n    {\n        for(int i=1;i<=K;i++)T[i].G.init();\n        for(int i=1;i<=n-1;i++)\n        {\n            int x=read(),y=read();\n            G.ins(x,y);\n        }\n        deep[1]=1;\n        dfs(1);\n        for(int i=1;i<=K;i++) T[i].init();\n        for(int i=1;i<=n;i++) anc[i][0]=fa[i];\n        for(int j=1;j<=16;j++)\n        for(int i=1;i<=n;i++) anc[i][j]=anc[anc[i][j-1]][j-1];\n    }\n    fstc int jump(int x,int step)\n    {\n        for(int i=0;i<=16;i++)if((step&(1<<i))>0)x=anc[x][i];\n        return x;\n    }\n    fstc void modify(int x)\n    {\n        if(a[x]==1) return ;\n        ll pos;\n        if(a[x]<=MX) pos=sqr[a[x]];\n        else pos=sqrt(a[x]);\n        for(int i=1;i<=K;i++)T[i].modify(x,pos);\n        a[x]=pos;\n    }\n    fstc ll ask(int x,int pos,int step)\n    {\n        ll ret=0;\n        while(deep[x]>deep[pos])\n            ret+=a[x],x=jump(x,step);\n        return ret;\n    }\n    fstc void get_path(int x,int pos,int step)\n    {\n        while(x!=pos)\n        {\n            if(a[x]>1)path[++path_top]=x;\n            x=jump(x,step);\n        }\n        if(a[pos]>1)path[++path_top]=pos;\n    }\n    fstc int get_lca(int x,int y)\n    {\n        if(deep[x]<deep[y])swap(x,y);\n        for(int i=16;i>=0;i--)\n        if(deep[anc[x][i]]>=deep[y])x=anc[x][i];\n        if(x==y)return x;\n        for(int i=16;i>=0;i--)\n        if(anc[x][i]!=anc[y][i])x=anc[x][i],y=anc[y][i];\n        return anc[x][0];\n    }\n    fstc int main()\n    {\n        G.init();\n        register int i,j;\n        for(i=1;i<=MX;++i)\n        sqr[i]=sqr[i-1]+((sqr[i-1]+1)*(sqr[i-1]+1)==i);\n        n=read();\n        for(i=1;i<=n;++i)a[i]=read();\n        init();\n        Q=read();\n        while(Q--)\n        {\n            int opt=read(),s=read(),t=read(),k=read();\n            int lca=get_lca(s,t),len=deep[s]+deep[t]-2*deep[lca];\n            if(opt==0)\n            {\n                if(len%k!=0)modify(t),t=jump(t,len%k);\n                if(deep[lca]%k==deep[s]%k)modify(lca);\n                for(j=1;j<=2;++j)\n                {\n                    path_top=0;\n                    swap(s,t);\n                    int tmp=deep[s]-deep[lca]-1;\n                    if(tmp<0)continue ;\n                    int pos=jump(s,tmp/k*k);\n                    if(k<=K) T[k].get_path(s,pos);\n                    else get_path(s,pos,k);\n                    for(int i=1;i<=path_top;i++)\n                    modify(path[i]);\n                }\n            }\n            else\n            {\n                ll ret=0;\n                if(len%k>0)ret+=a[t],t=jump(t,len%k);\n                if(deep[lca]%k==deep[s]%k)ret+=a[lca];\n                if(k<=K)\n                for(j=1;j<=2;++j)\n                {\n                    swap(s,t);\n                    int tmp=deep[s]-deep[lca]-1;\n                    if(tmp<0)continue ;\n                    int pos=jump(s,tmp/k*k);\n                    ret+=T[k].ask(s,pos);\n                }\n                else ret+=ask(s,lca,k),swap(s,t),ret+=ask(s,lca,k);\n                write(ret),*ou++='\\n';\n            }\n        }\n        fwrite(Out,1,ou-Out,stdout);\n        return 0;\n}\n```",
        "postTime": 1515765418,
        "uid": 30459,
        "name": "\u6d88\u5931\u7684\u6d77\u5cb8\u7ebf",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4004 \u3010Hello world!\uff08helloworld\uff09\u3011"
    },
    {
        "content": "[\u6d1b\u8c37\u9898\u9762\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P4004)\n\n\u7b80\u5355\u5206\u5757\u9898\uff0c\u53ef\u60dc\u5361\u4e86\u4e00\u5e74\u7684\u5e38\uff08\n\n\u9053\u7406\u5f88\u660e\u663e\uff0c\u78b0\u5230\u8fd9\u79cd\u4e0d\u53ef polylog \u7ef4\u62a4\u7684\u9898\u80af\u5b9a\u9700\u8981\u5206\u5757\uff0c\u5f31\u5316\u7248\u53ef\u89c1 [P3591 POI2015 ODW](https://www.luogu.com.cn/problem/P3591)\u3002\u800c\u6b64\u9898\u53c8\u6d89\u53ca\u5f00\u6839\u53f7\uff0c\u90a3\u53c8\u4e00\u4e2a\u4e00\u773c\u7684\u5957\u8def\uff1asegment beats\uff0c\u8fd9\u6837\u505a\u6cd5\u5c31\u51fa\u6765\u4e86\uff1a\u8bbe\u9608\u503c $B$\uff0c\u7136\u540e\u3002\n\n- \u5bf9\u4e8e $k>B$\uff0c\u67e5\u8be2\u4fee\u6539\u90fd\u66b4\u529b\u3002\n- \u5bf9\u4e8e $k\\le B$\uff0c\u6211\u4eec\u5148\u5bf9\u4e8e\u6240\u6709 $k_0\\in[1,B]$ \u5efa\u4e00\u68f5\u7c7b\u4f3c\u4e8e\u68ee\u6797\u51fa\u6765\u7684\u4e1c\u897f\uff0c\u5373\u6bcf\u4e2a\u70b9\u5411\u5176 $k_0$ \u7ea7\u7956\u5148\u8fde\u8fb9\uff0c\u8fd9\u6837\u8fde\u51fa\u6765\u80af\u5b9a\u662f\u4e00\u9897\u68ee\u6797\uff0c\u8fd9\u6837\u67e5\u8be2\u5c31\u53ef\u4ee5\u8f6c\u5316\u4e3a\u4e24\u6761\u94fe\u7684\u6c42\u548c\uff0c\u53ef\u4ee5\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u3002\u800c\u4fee\u6539\u7b49\u4ef7\u4e8e\u627e\u94fe\u4e0a\u7b2c\u4e00\u4e2a $\\ne 1$ \u7684\u4f4d\u7f6e\uff0c\u66b4\u529b\u94fe\u4e0a\u4e8c\u5206\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u5927\u6982\u662f $\\dfrac{Qn}{B}\u00b7\\log n+Q\\log n+n\\log^2n\u00b7B$\uff0c\u5b9e\u6d4b $B=100$ \u6700\u4f18\u3002\n\n\u611f\u89c9\u6b64\u9898\u6700\u96be\u7684\u5730\u65b9\u5728\u4e8e\u5199\u4ee3\u7801\u3002\n\n```cpp\nconst int MAXN = 5e4;\nconst int SQRT = 100;\nconst int LOG_N = 16;\nint n, qu, ord[MAXN + 5], lg[MAXN * 2 + 5]; ll a[MAXN + 5];\nint hd[MAXN + 5], to[MAXN * 2 + 5], nxt[MAXN * 2 + 5], ec = 0;\nvoid adde(int u, int v) {to[++ec] = v; nxt[ec] = hd[u]; hd[u] = ec;}\nint fa[MAXN + 5][LOG_N + 2], dep[MAXN + 5];\npii st[LOG_N + 2][MAXN * 2 + 5]; int dfn_eu[MAXN + 5], tim_eu;\nvoid dfs0(int x, int f) {\n\tfa[x][0] = f; st[0][dfn_eu[x] = ++tim_eu] = mp(dep[x], x);\n\tfor (int e = hd[x]; e; e = nxt[e]) {\n\t\tint y = to[e]; if (y == f) continue;\n\t\tdep[y] = dep[x] + 1; dfs0(y, x);\n\t\tst[0][dfn_eu[x] = ++tim_eu] = mp(dep[x], x);\n\t}\n}\npii query_st(int l, int r) {\n\tint k = lg[r - l + 1];\n\treturn min(st[k][l], st[k][r - (1 << k) + 1]);\n}\nint getlca(int x, int y) {\n\tif (dfn_eu[x] > dfn_eu[y]) swap(x, y);\n\treturn query_st(dfn_eu[x], dfn_eu[y]).se;\n}\nint get_kanc(int u, int k) {while (k) u = fa[u][lg[k & (-k)]], k &= (k - 1); return u;}\nint getnxt(int u, int v, int k) {\n\tint lc = getlca(u, v);\n\tif (dep[u] - dep[lc] >= k) return get_kanc(u, k);\n\telse if (dep[u] + dep[v] - dep[lc] * 2 <= k) return v;\n\telse return get_kanc(v, dep[v] - dep[lc] - (k - (dep[u] - dep[lc])));\n}\nint blk, vis[MAXN + 5], bgt[SQRT + 5][MAXN + 5], edt[SQRT + 5][MAXN + 5], tim; vector<int> g[MAXN + 5];\nvoid dfsdfn(int x, int k) {bgt[k][x] = ++tim; vis[x] = 1; for (int y : g[x]) dfsdfn(y, k); edt[k][x] = tim;}\nstruct fenwick {\n\tll t[MAXN + 5];\n\tvoid add(int x, ll v) {for (int i = x; i <= n; i += (i & (-i))) t[i] += v;}\n\tll query(int x) {ll ret = 0; for (int i = x; i; i &= (i - 1)) ret += t[i]; return ret;}\n} T[SQRT + 5];\nll ask(int x, int k) {return T[k].query(bgt[k][x]);}\nvoid upd(int x) {\n\tif (a[x] <= 1) return; ll nw = (ll)sqrt(a[x]);\n\tfor (int i = 1; i <= blk; i++) T[i].add(bgt[i][x], -a[x] + nw), T[i].add(edt[i][x] + 1, a[x] - nw);\n\ta[x] = nw;\n}\nint main() {\n\tfor (int i = 2; i <= MAXN * 2; i++) lg[i] = lg[i >> 1] + 1;\n\tscanf(\"%d\", &n); blk = 100;\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n\tfor (int i = 1, u, v; i < n; i++) scanf(\"%d%d\", &u, &v), adde(u, v), adde(v, u);\n\tdfs0(1, 0);\n\tfor (int i = 1; i <= LOG_N; i++) {\n\t\tfor (int j = 1; j <= n; j++) fa[j][i] = fa[fa[j][i - 1]][i - 1];\n\t\tfor (int j = 1; j + (1 << i) - 1 <= n * 2; j++) st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << i - 1)]);\n\t}\n\tfor (int i = 1; i <= n; i++) ord[i] = i;\n\tsort(ord + 1, ord + n + 1, [&](int x, int y) {return dep[x] < dep[y];});\n\tfor (int i = 1; i <= blk; i++) {\n\t\tfor (int j = 1; j <= n; j++) g[j].clear(), vis[j] = 0; tim = 0;\n\t\tfor (int j = 1; j <= n; j++) {int anc = get_kanc(j, i); if (anc) g[anc].pb(j);}\n\t\tfor (int j = 1; j <= n; j++) if (!vis[ord[j]]) dfsdfn(ord[j], i);\n\t\tfor (int j = 1; j <= n; j++) T[i].add(bgt[i][j], a[j]), T[i].add(edt[i][j] + 1, -a[j]);\n\t}\n\tscanf(\"%d\", &qu);\n\twhile (qu--) {\n\t\tint opt, u, v, k; scanf(\"%d%d%d%d\", &opt, &u, &v, &k);\n\t\tif (k > blk) {\n\t\t\tif (opt == 0) {\n\t\t\t\tfor (int i = u; i != v; i = getnxt(i, v, k)) upd(i);\n\t\t\t\tupd(v);\n\t\t\t} else {\n\t\t\t\tll res = 0;\n\t\t\t\tfor (int i = u; i != v; i = getnxt(i, v, k)) res += a[i];\n\t\t\t\tres += a[v]; printf(\"%lld\\n\", res);\n\t\t\t}\n\t\t} else {\n\t\t\tif (opt == 1) {\n\t\t\t\tint lc = getlca(u, v); ll res = 0; res = ask(u, k);\n\t\t\t\tint anc = get_kanc(u, (dep[u] - dep[lc]) / k * k + k);\n\t\t\t\tres -= ask(anc, k);\n\t\t\t\tint L = k - (dep[u] - dep[lc]) % k;\n\t\t\t\tint R = dep[v] - dep[lc];\n\t\t\t\tif (L <= R) {\n\t\t\t\t\tR = L + (R - L) / k * k;\n\t\t\t\t\tres += ask(get_kanc(v, (dep[v] - dep[lc]) - R), k);\n\t\t\t\t\tanc = get_kanc(v, (dep[v] - dep[lc]) - L + k);\n\t\t\t\t\tres -= ask(anc, k);\n\t\t\t\t}\n\t\t\t\tif ((dep[u] + dep[v] - dep[lc] * 2) % k) res += a[v];\n\t\t\t\tprintf(\"%lld\\n\", res);\n\t\t\t} else {\n\t\t\t\tint cur = u, lc = getlca(u, v);\n\t\t\t\twhile (cur && dep[cur] >= dep[lc]) {\n\t\t\t\t\tint l = 0, r = (dep[cur] - dep[lc]) / k, p = -1;\n\t\t\t\t\tll ss = ask(cur, k);\n\t\t\t\t\tif (ss - ask(get_kanc(cur, (r + 1) * k), k) == r + 1) break;\n\t\t\t\t\twhile (l <= r) {\n\t\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\t\tll sum = ss - ask(get_kanc(cur, (mid + 1) * k), k);\n\t\t\t\t\t\tif (sum == mid + 1) l = mid + 1; else r = mid - 1, p = mid;\n\t\t\t\t\t}\n\t\t\t\t\tcur = get_kanc(cur, p * k); assert(a[cur] > 1); upd(cur);\n\t\t\t\t\tcur = get_kanc(cur, k);\n\t\t\t\t}\n\t\t\t\tcur = k - (dep[u] - dep[lc]) % k;\n\t\t\t\twhile (cur <= dep[v] - dep[lc]) {\n\t\t\t\t\tint l = 0, r = (dep[v] - dep[lc] - cur) / k, p = -1;\n\t\t\t\t\tll ss = ask(get_kanc(v, dep[v] - dep[lc] - cur + k), k);\n\t\t\t\t\tif (ask(get_kanc(v, dep[v] - dep[lc] - (cur + r * k)), k) - ss == r + 1) break;\n\t\t\t\t\twhile (l <= r) {\n\t\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\t\tll sum = ask(get_kanc(v, dep[v] - dep[lc] - (cur + mid * k)), k) - ss;\n\t\t\t\t\t\tif (sum == mid + 1) l = mid + 1;\n\t\t\t\t\t\telse p = mid, r = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t\tcur += p * k;\n\t\t\t\t\tassert(a[get_kanc(v, dep[v] - dep[lc] - cur)] > 1);\n\t\t\t\t\tupd(get_kanc(v, dep[v] - dep[lc] - cur));\n\t\t\t\t\tcur += k;\n\t\t\t\t}\n\t\t\t\tif ((dep[u] + dep[v] - dep[lc] * 2) % k) upd(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1657461247,
        "uid": 115194,
        "name": "lTgMFePRoeZ",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4004 Hello world!"
    },
    {
        "content": "\u8fd9\u9898\u521d\u4e00\u770b\u6ca1\u6709\u4ec0\u4e48\u601d\u8def\uff0c\u540e\u6765\u4ed4\u7ec6\u601d\u8003\u4e86\u4e00\u4e0b\uff0c\u53d1\u73b0\u53ef\u4ee5\u4e71\u641e\uff01\n\n\u5c31\u662f\u5728lca\u4e0a\u4e71\u641e\uff01\u8003\u8651\u4e00\u79cd\u5206\u5757\uff01\u6211\u4eec\u65e2k\u4e3a\u8df3\u7684\u6b65\u6570\uff0c\u6309k\u7684\u4f59\u6570\u5206\u60c5\u51b5\u8003\u8651\n\n\u7136\u540e\u5747\u644a\u4e00\u4e0b\u5373\u53ef\uff01~~\u6211\u4e5f\u4e0d\u9020\u6570\u636e\u4e3a\u4ec0\u4e48\u8fd9\u4e48\u5f3a~~\n```cpp\nint solve(int x, int k) {\n\tif (k > m) return up(x, k);\n\tint y = find(fa(x));\n\treturn up(y, (k - (depth[x] - depth[y]) % k) % k);\n}\nint solve2(int x, int y, int f, int k) {\n\tif (depth[y] - depth[f] >= k) return up(y, k);\n\treturn up(x, depth[x] + depth[y] - (depth[f] << 1) - k);\n}\n```\n\u8fd9\u91cc\u662f\u91cd\u70b9\uff01\u5982\u679c\u5927\u4e8ek\u526a\u679d\uff01\n\n\u7136\u540e\u5206\u5757\u5904\u7406\u8be2\u95ee\uff01\n```cpp\nvoid update(int x, int y, int k) {\n\tint f = lca(x, y), len = depth[x] + depth[y] - (depth[f] << 1);\n\tif (len % k) upd(y), y = solve2(x, y, f, len % k), f = lca(x, y);\n\twhile (depth[x] >= depth[f]) upd(x), x = solve(x, k);\n\twhile (depth[y] > depth[f]) upd(y), y = solve(y, k);\n}\nll query(int x, int y, int k) {\n\tint f = lca(x, y), len = depth[x] + depth[y] - (depth[f] << 1);\n\tll res = 0;\n\tif (len % k) res += a[y], y = solve2(x, y, f, len % k), f = lca(x, y);\n\tres += (depth[x] + depth[y] - (depth[f] << 1)) / k + 1;\n\twhile (depth[x] >= depth[f]) res += a[x] - 1, x = solve(x, k);\n\twhile (depth[y] > depth[f]) res += a[y] - 1, y = solve(y, k);\n\treturn res; \n}\n```\n\u8fd9\u6837\u8fd8\u662f\u53ef\u4ee5\u5747\u644a\uff01\n\n\u53ea\u662f\u4e00\u4e2a\u6309k\u5747\u644a\uff0c\u4e00\u4e2a\u6309sqrt\uff08n\uff09\u5747\u644a\uff01\n\n\u7136\u540e\u6211\u4eec\u53ea\u9700\u6c42\u4e0blca\n\n\u540c\u662f\u8981\u56de\u7528\u4e8c\u5206\u601d\u60f3\u6c42up\uff08x\uff0ck\uff09\n\n\u5c31\u5207\u4e86\uff0c~~\u8fd9\u4e48\u7b80\u5355\u5427\uff01~~\n\u4ee3\u7801\uff1a\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 50005, M = (N << 1), K = 255;\nll rd() {\n\tchar c = getchar(); ll x = 0ll, f = 1ll;\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -1;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\treturn x * f;\n}\nint n, m, q, ecnt = 0, fir[N], to[M], nxt[M], fa[N][16], nx[N][K], depth[N], f[N];\nll a[N];\n#define fa(x) fa[x][0]\nvoid ae(int u, int v) {to[++ecnt] = v; nxt[ecnt] = fir[u]; fir[u] = ecnt;}\nvoid dfs(int u, int f) {\n\tint i; nx[u][0] = u, fa[u][0] = nx[u][1] = f, depth[u] = depth[f] + 1;\n\tfor (i = 1; i <= 15; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];\n\tfor (i = 2; i <= m; ++i) nx[u][i] = nx[f][i - 1];\n\tfor (i = fir[u]; i; i = nxt[i]) {\n\t\tint v = to[i];\n\t\tif (v != f) dfs(v, u);\n\t}\n}\nint up(int x, int k) {\n\tint i; if (k <= m) return nx[x][k];\n\tfor (i = 15; ~i; --i) if (k >= (1 << i)) x = fa[x][i], k -= 1 << i;\n\treturn x;\n}\nint lca(int u, int v) {\n\tint i; if (depth[u] < depth[v]) swap(u, v);\n\tfor (i = 15; ~i; --i) if (depth[fa[u][i]] >= depth[v]) u = fa[u][i];\n\tif (u == v) return u;\n\tfor (i = 15; ~i; --i) if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n\treturn fa[u][0];\n}\nint find(int u) {return f[u] = f[u] == u ? u : find(f[u]);}\nvoid upd(int x) {\n\tif (a[x] == 1) return;\n\ta[x] = sqrt(a[x]);\n\tif (a[x] == 1) f[x] = find(fa(x));\n} \nint solve(int x, int k) {\n\tif (k > m) return up(x, k);\n\tint y = find(fa(x));\n\treturn up(y, (k - (depth[x] - depth[y]) % k) % k);\n}\nint solve2(int x, int y, int f, int k) {\n\tif (depth[y] - depth[f] >= k) return up(y, k);\n\treturn up(x, depth[x] + depth[y] - (depth[f] << 1) - k);\n}\nvoid update(int x, int y, int k) {\n\tint f = lca(x, y), len = depth[x] + depth[y] - (depth[f] << 1);\n\tif (len % k) upd(y), y = solve2(x, y, f, len % k), f = lca(x, y);\n\twhile (depth[x] >= depth[f]) upd(x), x = solve(x, k);\n\twhile (depth[y] > depth[f]) upd(y), y = solve(y, k);\n}\nll query(int x, int y, int k) {\n\tint f = lca(x, y), len = depth[x] + depth[y] - (depth[f] << 1);\n\tll res = 0;\n\tif (len % k) res += a[y], y = solve2(x, y, f, len % k), f = lca(x, y);\n\tres += (depth[x] + depth[y] - (depth[f] << 1)) / k + 1;\n\twhile (depth[x] >= depth[f]) res += a[x] - 1, x = solve(x, k);\n\twhile (depth[y] > depth[f]) res += a[y] - 1, y = solve(y, k);\n\treturn res; \n}\nint main() {\n\tint i; n = rd(); m = sqrt(n);\n\tfor (i = 1; i <= n; ++i) a[i] = rd();\n\tfor (i = 1; i < n; ++i) {\n\t\tint u = rd(), v = rd();\n\t\tae(u, v); ae(v, u);\n\t}\n\tdfs(1, 0);\n\tfor (i = 1; i <= n; ++i) {\n\t\tf[i] = i;\n\t\tif (a[i] == 1) f[i] = fa(i);\n\t}\n\tq = rd();\n\twhile (q--) {\n\t\tint opt = rd(), x = rd(), y = rd(), k = rd();\n\t\tif (opt) printf(\"%lld\\n\", query(x, y, k));\n\t\telse update(x, y, k);\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1546821481,
        "uid": 30817,
        "name": "muller",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4004 \u3010Hello world!\u3011"
    }
]