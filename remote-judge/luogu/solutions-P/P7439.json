[
    {
        "content": "\u672c\u6587\u540c\u6b65\u53d1\u8868\u4e8e\u6211\u7684\u535a\u5ba2\uff1a<https://www.alpha1022.me/articles/lg-7439.htm>\u3002\n\n\u9996\u5148\u628a\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\u8f6c\u6210\u725b\u987f\u7ea7\u6570\uff0c\u5373\u8f6c\u5199\u6210\n$$\nF(x) = \\sum\\limits_{i=0}^{k-1} a_i \\binom xi\n$$\n\n\u7136\u540e\u5957\u8def\u7684\u62c6\u5f00\u9879\uff0c\u8003\u8651\u8ba1\u7b97\n$$\n\\sum\\limits_{\\pi} \\binom{{\\rm cyc}_{\\pi}}{k}\n$$\n\n\u8ba9\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u9519\u6392\uff0c\u663e\u7136\u5b83\u662f\u7531\u975e\u81ea\u73af\u7684\u5faa\u73af\u7f6e\u6362\u4e3a\u57fa\u672c\u5355\u4f4d\u6784\u6210\u7684\uff0c\u5373\n$$\n{\\rm e}^{-x-\\ln(1-x)}\n$$\n\n\u7136\u540e\u8003\u8651\u4ece\u4e2d\u9009 $k$ \u4e2a\u3002\u4e0d\u96be\u53d1\u73b0\u8fd9\u53ea\u9700\u8981\u5bf9\u4e00\u4e2a\u5faa\u73af\u7f6e\u6362\u9644\u52a0\u4e00\u4e2a\u56e0\u5b50 $(1+y)$ \u5373\u53ef\u505a\u5230\uff1a\n$$\n{\\rm e}^{(1+y)(-x-\\ln(1-x))}\n$$\n\n\u9996\u5148\u6c42\u8003\u8651\u6c42 $[x^n] {\\rm e}^{y(-x-\\ln(1-x))}$\uff0c\u7136\u540e\u4f7f\u7528\u4e8c\u9879\u5f0f\u5c55\u5f00\u5e76\u5377\u79ef\u5904\u7406\u3002\n\n\u8bbe $\\frac{f^2}2 = -x-\\ln(1-x)$\uff0c\u663e\u7136\u5176\u5b58\u5728\u590d\u5408\u9006\uff0c\u8bbe\u590d\u5408\u9006\u4e3a $g$\u3002  \n\u5219\n$$\n[x^n]{\\rm e}^{yf^2/2} = \\frac1n[x^{n-1}] \\frac{\\partial{\\rm e}^{yx^2/2}}{\\partial x} \\left(\\frac xg\\right)^n\n$$\n\n\u6211\u4eec\u77e5\u9053\n$$\n\\frac{\\partial{\\rm e}^{yx^2/2}}{\\partial x} = xy {\\rm e}^{yx^2/2} = \\sum\\limits_{i\\ge 0} \\frac{x^{2i+1}y^{i+1}}{2^ii!}\n$$\n\n\u56e0\u6b64\n$$\n\\frac1n[x^{n-1} y^k] \\frac{\\partial{\\rm e}^{yx^2/2}}{\\partial x} \\left(\\frac xg\\right)^n = \\frac1{n2^{k-1} (k-1)!} [x^{n-2k}] \\left(\\frac xg\\right)^n\n$$\n\n\u8003\u8651\u6c42 $g$\u3002\u6211\u4eec\u77e5\u9053\n$$\n\\frac{f^2}2 = -x-\\ln(1-x)\n$$\n\n\u6240\u4ee5\n$$\n\\frac{x^2}2 = -g-\\ln(1-g)\n$$\n\n\u4e0d\u5e78\u7684\u662f\u5982\u679c\u6211\u4eec\u76f4\u63a5\u5bf9\u8fd9\u4e2a\u5f0f\u5b50\u725b\u987f\u8fed\u4ee3\uff0c\u4f1a\u51fa\u73b0\u4e00\u4e9b\u610f\u6599\u4e4b\u5916\u7684\u95ee\u9898\u3002  \n\u6240\u4ee5\u4e0d\u59a8\u5c06\u5176\u6539\u5199\u6210\n$$\n\\sqrt{-2g-2\\ln(1-g)}-x=0\n$$\n\n\u7136\u540e\u5bf9\u5176\u725b\u987f\u8fed\u4ee3\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n \\log^2 n)$\uff08\u89c6 $n,k$ \u540c\u9636\uff09\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#define add(a,b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a,b) (a < b ? a - b + mod : a - b)\n#define ls (p << 1)\n#define rs (ls | 1)\nusing namespace std;\nconst int N = 1e5;\nconst int mod = 998244353;\nint n,k,m;\ninline int fpow(int a,int b)\n{\n    int ret = 1;\n    for(;b;b >>= 1)\n        (b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;\n    return ret;\n}\nnamespace Poly\n{\n    const int LG = 17;\n    const int N = 1 << LG + 1;\n    const int G = 3;\n    int lg2[N + 5];\n    int rev[N + 5],fac[N + 5],ifac[N + 5],inv[N + 5];\n    int rt[N + 5];\n    inline void init()\n    {\n        for(register int i = 2;i <= N;++i)\n            lg2[i] = lg2[i >> 1] + 1;\n        rt[0] = 1,rt[1 << LG] = fpow(G,(mod - 1) >> LG + 2);\n        for(register int i = LG;i;--i)\n            rt[1 << i - 1] = (long long)rt[1 << i] * rt[1 << i] % mod;\n        for(register int i = 1;i < N;++i)\n            rt[i] = (long long)rt[i & i - 1] * rt[i & -i] % mod;\n        fac[0] = 1;\n        for(register int i = 1;i <= N;++i)\n            fac[i] = (long long)fac[i - 1] * i % mod;\n        ifac[N] = fpow(fac[N],mod - 2);\n        for(register int i = N;i;--i)\n            ifac[i - 1] = (long long)ifac[i] * i % mod;\n        for(register int i = 1;i <= N;++i)\n            inv[i] = (long long)ifac[i] * fac[i - 1] % mod;\n    }\n    struct poly\n    {\n        vector<int> a;\n        inline poly(int x = 0)\n        {\n            x && (a.push_back(x),1);\n        }\n        inline poly(const vector<int> &o)\n        {\n            a = o,shrink();\n        }\n        inline poly(const poly &o)\n        {\n            a = o.a,shrink();\n        }\n        inline void shrink()\n        {\n            for(;!a.empty() && !a.back();a.pop_back());\n        }\n        inline int size() const\n        {\n            return a.size();\n        }\n        inline void resize(int x)\n        {\n            a.resize(x);\n        }\n        inline int operator[](int x) const\n        {\n            if(x < 0 || x >= size())\n                return 0;\n            return a[x];\n        }\n        inline void clear()\n        {\n            vector<int>().swap(a);\n        }\n        inline poly rever() const\n        {\n            return poly(vector<int>(a.rbegin(),a.rend()));\n        }\n\t\tinline void dif()\n\t\t{\n\t\t\tint n = size();\n            for(register int i = 0,len = n >> 1;len;++i,len >>= 1)\n                for(register int j = 0,*w = rt;j < n;j += len << 1,++w)\n                    for(register int k = j,R;k < j + len;++k)\n                        R = (long long)*w * a[k + len] % mod,\n                        a[k + len] = dec(a[k],R),\n                        a[k] = add(a[k],R);\n\t\t}\n        inline void dit()\n        {\n\t\t\tint n = size();\n            for(register int i = 0,len = 1;len < n;++i,len <<= 1)\n                for(register int j = 0,*w = rt;j < n;j += len << 1,++w)\n                    for(register int k = j,R;k < j + len;++k)\n                        R = add(a[k],a[k + len]),\n                        a[k + len] = (long long)(a[k] - a[k + len] + mod) * *w % mod,\n                        a[k] = R;\n            reverse(a.begin() + 1,a.end());\n            for(register int i = 0;i < n;++i)\n                a[i] = (long long)a[i] * inv[n] % mod;\n\t\t}\n        inline void ntt(int type = 1)\n        {\n            type == 1 ? dif() : dit();\n        }\n        friend inline poly operator+(const poly &a,const poly &b)\n        {\n            vector<int> ret(max(a.size(),b.size()));\n            for(register int i = 0;i < ret.size();++i)\n                ret[i] = add(a[i],b[i]);\n            return poly(ret);\n        }\n        friend inline poly operator-(const poly &a,const poly &b)\n        {\n            vector<int> ret(max(a.size(),b.size()));\n            for(register int i = 0;i < ret.size();++i)\n                ret[i] = dec(a[i],b[i]);\n            return poly(ret);\n        }\n        friend inline poly operator*(poly a,poly b)\n        {\n            if(a.a.empty() || b.a.empty())\n                return poly();\n            if(a.size() < 40 || b.size() < 40)\n            {\n                if(a.size() > b.size())\n                    swap(a,b);\n                poly ret;\n                ret.resize(a.size() + b.size() - 1);\n                for(register int i = 0;i < ret.size();++i)\n                    for(register int j = 0;j <= i && j < a.size();++j)\n                        ret.a[i] = (ret[i] + (long long)a[j] * b[i - j]) % mod;\n                ret.shrink();\n                return ret;\n            }\n            int lim = 1,tot = a.size() + b.size() - 1;\n            for(;lim < tot;lim <<= 1);\n            a.resize(lim),b.resize(lim);\n            a.ntt(),b.ntt();\n            for(register int i = 0;i < lim;++i)\n                a.a[i] = (long long)a[i] * b[i] % mod;\n            a.ntt(-1),a.shrink();\n            return a;\n        }\n        poly &operator+=(const poly &o)\n        {\n            resize(max(size(),o.size()));\n            for(register int i = 0;i < o.size();++i)\n                a[i] = add(a[i],o[i]);\n            return *this;\n        }\n        poly &operator-=(const poly &o)\n        {\n            resize(max(size(),o.size()));\n            for(register int i = 0;i < o.size();++i)\n                a[i] = dec(a[i],o[i]);\n            return *this;\n        }\n        poly &operator*=(poly o)\n        {\n            return (*this) = (*this) * o;\n        }\n        poly deriv() const\n        {\n            if(a.empty())\n                return poly();\n            vector<int> ret(size() - 1);\n            for(register int i = 0;i < size() - 1;++i)\n                ret[i] = (long long)(i + 1) * a[i + 1] % mod;\n            return poly(ret);\n        }\n        poly integ() const\n        {\n            if(a.empty())\n                return poly();\n            vector<int> ret(size() + 1);\n            for(register int i = 0;i < size();++i)\n                ret[i + 1] = (long long)a[i] * inv[i + 1] % mod;\n            return poly(ret);\n        }\n        inline poly modxn(int n) const\n        {\n            if(a.empty())\n                return poly();\n            n = min(n,size());\n            return poly(vector<int>(a.begin(),a.begin() + n));\n        }\n        inline poly inver(int m) const\n        {\n            poly ret(fpow(a[0],mod - 2)),f,g;\n            for(register int k = 1;k < m;)\n            {\n                k <<= 1,f.resize(k),g.resize(k);\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (*this)[i],g.a[i] = ret[i];\n                f.ntt(),g.ntt();\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (long long)f[i] * g[i] % mod;\n                f.ntt(-1);\n                for(register int i = 0;i < (k >> 1);++i)\n                    f.a[i] = 0;\n                f.ntt();\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (long long)f[i] * g[i] % mod;\n                f.ntt(-1);\n                ret.resize(k);\n                for(register int i = (k >> 1);i < k;++i)\n                    ret.a[i] = dec(0,f[i]);\n            }\n            return ret.modxn(m);\n        }\n        inline pair<poly,poly> div(poly o) const\n        {\n            if(size() < o.size())\n                return make_pair(poly(),*this);\n            poly f,g;\n            f = (rever().modxn(size() - o.size() + 1) * o.rever().inver(size() - o.size() + 1)).modxn(size() - o.size() + 1).rever();\n            g = (modxn(o.size() - 1) - o.modxn(o.size() - 1) * f.modxn(o.size() - 1)).modxn(o.size() - 1);\n            return make_pair(f,g);\n        }\n        inline poly log(int m) const\n        {\n            return (deriv() * inver(m)).integ().modxn(m);\n        }\n        inline poly exp(int m) const\n        {\n            poly ret(1),iv,it,d = deriv(),itd,itd0,t1;\n            if(m < 70)\n            {\n                ret.resize(m);\n                for(register int i = 1;i < m;++i)\n                {\n                    for(register int j = 1;j <= i;++j)\n                        ret.a[i] = (ret[i] + (long long)j * operator[](j) % mod * ret[i - j]) % mod;\n                    ret.a[i] = (long long)ret[i] * inv[i] % mod;\n                }\n                return ret;\n            }\n            for(register int k = 1;k < m;)\n            {\n                k <<= 1;\n                it.resize(k >> 1);\n                for(register int i = 0;i < (k >> 1);++i)\n                    it.a[i] = ret[i];\n                itd = it.deriv(),itd.resize(k >> 1);\n                iv = ret.inver(k >> 1),iv.resize(k >> 1);\n                it.ntt(),itd.ntt(),iv.ntt();\n                for(register int i = 0;i < (k >> 1);++i)\n                    it.a[i] = (long long)it[i] * iv[i] % mod,\n                    itd.a[i] = (long long)itd[i] * iv[i] % mod;\n                it.ntt(-1),itd.ntt(-1),it.a[0] = dec(it[0],1);\n                for(register int i = 0;i < k - 1;++i)\n                    itd.a[i % (k >> 1)] = dec(itd[i % (k >> 1)],d[i]);\n                itd0.resize((k >> 1) - 1);\n                for(register int i = 0;i < (k >> 1) - 1;++i)\n                    itd0.a[i] = d[i];\n                itd0 = (itd0 * it).modxn((k >> 1) - 1);\n                t1.resize(k - 1);\n                for(register int i = (k >> 1) - 1;i < k - 1;++i)\n                    t1.a[i] = itd[(i + (k >> 1)) % (k >> 1)];\n                for(register int i = k >> 1;i < k - 1;++i)\n                    t1.a[i] = dec(t1[i],itd0[i - (k >> 1)]);\n                t1 = t1.integ();\n                for(register int i = 0;i < (k >> 1);++i)\n                    t1.a[i] = t1[i + (k >> 1)];\n                for(register int i = (k >> 1);i < k;++i)\n                    t1.a[i] = 0;\n                t1.resize(k >> 1),t1 = (t1 * ret).modxn(k >> 1),t1.resize(k);\n                for(register int i = (k >> 1);i < k;++i)\n                    t1.a[i] = t1[i - (k >> 1)];\n                for(register int i = 0;i < (k >> 1);++i)\n                    t1.a[i] = 0;\n                ret -= t1;\n            }\n            return ret.modxn(m);\n        }\n        inline poly sqrt(int m) const\n        {\n            poly ret(1),f,g;\n            for(register int k = 1;k < m;)\n            {\n                k <<= 1;\n                f = ret,f.resize(k >> 1);\n                f.ntt();\n                for(register int i = 0;i < (k >> 1);++i)\n                    f.a[i] = (long long)f[i] * f[i] % mod;\n                f.ntt(-1);\n                for(register int i = 0;i < k;++i)\n                    f.a[i % (k >> 1)] = dec(f[i % (k >> 1)],(*this)[i]);\n                g = (2 * ret).inver(k >> 1),f = (f * g).modxn(k >> 1),f.resize(k);\n                for(register int i = (k >> 1);i < k;++i)\n                    f.a[i] = f[i - (k >> 1)];\n                for(register int i = 0;i < (k >> 1);++i)\n                    f.a[i] = 0;\n                ret -= f;\n            }\n            return ret.modxn(m);\n        }\n        inline poly pow(int m,int k1,int k2 = -1) const\n        {\n            if(a.empty())\n                return poly();\n            if(k2 == -1)\n                k2 = k1;\n            int t = 0;\n            for(;t < size() && !a[t];++t);\n            if((long long)t * k1 >= m)\n                return poly();\n            poly ret;\n            ret.resize(m);\n            int u = fpow(a[t],mod - 2),v = fpow(a[t],k2);\n            for(register int i = 0;i < m - t * k1;++i)\n                ret.a[i] = (long long)operator[](i + t) * u % mod;\n            ret = ret.log(m - t * k1);\n            for(register int i = 0;i < ret.size();++i)\n                ret.a[i] = (long long)ret[i] * k1 % mod;\n            ret = ret.exp(m - t * k1),t *= k1,ret.resize(m);\n            for(register int i = m - 1;i >= t;--i)\n                ret.a[i] = (long long)ret[i - t] * v % mod;\n            for(register int i = 0;i < t;++i)\n                ret.a[i] = 0;\n            return ret;\n        }\n    };\n}\nusing Poly::init;\nusing Poly::poly;\ninline int C(int n,int m)\n{\n    return n < m ? 0 : (long long)Poly::fac[n] * Poly::ifac[m] % mod * Poly::ifac[n - m] % mod;\n}\npoly f,seg[(N << 2) + 5],g;\npoly t1,t2;\ninline poly comp_xplusa(const poly &f,int a)\n{\n    int n = f.size();\n    poly t1,t2,ret;\n    t1.resize(n),t2.resize(n);\n    for(register int i = 0,pw = 1;i < n;++i,pw = (long long)pw * a % mod)\n        t1.a[n - 1 - i] = (long long)Poly::fac[i] * f[i] % mod,\n        t2.a[i] = (long long)Poly::ifac[i] * pw % mod;\n    t1 *= t2;\n    ret.resize(n);\n    for(register int i = 0;i < n;++i)\n        ret.a[i] = (long long)Poly::ifac[i] * t1[n - 1 - i] % mod;\n    return ret;\n}\nvoid build(int n,int p)\n{\n    if(n == 1)\n    {\n        seg[p].resize(2),seg[p].a[1] = 1;\n        return ;\n    }\n    int mid = n + 1 >> 1;\n    build(mid,ls),build(n - mid,rs);\n    seg[p] = seg[ls] * comp_xplusa(seg[rs],dec(0,mid));\n}\npoly solve(const poly &f,int n,int p)\n{\n    if(n == 1)\n        return f;\n    int mid = n + 1 >> 1;\n    poly ret;\n    ret.resize(n);\n    pair<poly,poly> res = f.div(seg[ls]);\n    poly t1 = solve(res.second,mid,ls);\n    poly t2 = solve(comp_xplusa(res.first,mid),n - mid,rs);\n    for(register int i = 0;i < mid;++i)\n        ret.a[i] = t1[i];\n    for(register int i = mid;i < n;++i)\n        ret.a[i] = t2[i - mid];\n    return ret;\n}\ninline poly calc(int m)\n{\n    poly ret,t,t1,t2,t3;\n    ret.resize(2),ret.a[1] = 1;\n    for(register int k = 2;k < m;)\n    {\n        k <<= 1;\n        t = 0 - 2 * ret - 2 * (1 - ret).log(k + 1),t.resize(k + 1);\n        for(register int i = 0;i < k - 1;++i)\n            t.a[i] = t[i + 2];\n        t.resize(k - 1),t = t.sqrt(k - 1),t.resize(k);\n        for(register int i = k - 1;i;--i)\n            t.a[i] = t[i - 1];\n        t.a[0] = 0,t1 = t,t1.resize(k),t1.a[1] = dec(t1[1],1);\n        for(register int i = 0;i < (k >> 1);++i)\n            t1.a[i] = t1[i + (k >> 1)];\n        for(register int i = (k >> 1);i < k;++i)\n            t1.a[i] = 0;\n        t2 = ((1 - ret) * t).modxn((k >> 1) + 1),t2.resize((k >> 1) + 1);\n        for(register int i = 0;i < (k >> 1);++i)\n            t2.a[i] = t2[i + 1];\n        t3.resize(k >> 1);\n        for(register int i = 0;i < (k >> 1);++i)\n            t3.a[i] = ret[i + 1];\n        t2.resize(k >> 1),t2 = (t2.inver(k >> 1) * t3).modxn(k >> 1);\n        t1 = (t1 * t2.inver(k >> 1)).modxn(k >> 1),t1.resize(k);\n        for(register int i = (k >> 1);i < k;++i)\n            t1.a[i] = t1[i - (k >> 1)];\n        for(register int i = 0;i < (k >> 1);++i)\n            t1.a[i] = 0;\n        ret -= t1;\n    }\n    return ret.modxn(m);\n}\nint ans;\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&k),f.resize(k);\n    for(register int i = 0;i < k;++i)\n        scanf(\"%d\",&f.a[i]);\n    build(k,1),f = solve(f,k,1);\n    for(register int i = 0;i < k;++i)\n        f.a[i] = (long long)f[i] * Poly::fac[i] % mod;\n    g = calc(n + 1),g.resize(n + 1);\n    for(register int i = 0;i < n;++i)\n        g.a[i] = g[i + 1];\n    g.resize(n),g = g.pow(n,mod - n,mod - n - 1);\n    m = (n >> 1) + 1,t1.resize(m),t2.resize(m);\n    for(register int i = 0,pw = 2;i < m;++i,pw = (long long)pw * Poly::inv[2] % mod)\n        i && (t1.a[m - i - 1] = (long long)Poly::fac[n - 1] * pw % mod * i % mod * g[n - 2 * i] % mod),\n        t2.a[i] = Poly::ifac[i];\n    t1 = t1 * t2;\n    for(register int i = 0;i < min(k,m);++i)\n        ans = (ans + (long long)f[i] * Poly::ifac[i] % mod * t1[m - 1 - i]) % mod;\n    printf(\"%d\\n\",ans);\n}\n```",
        "postTime": 1615807749,
        "uid": 75840,
        "name": "deserter",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P7439 \u3010\u5165\u95e8\u7ea7\u7684\u6392\u5217\u8ba1\u6570\u3011"
    },
    {
        "content": "![](https://ae01.alicdn.com/kf/Uc9663df5788f49c4a0e51723f78afa77D.jpg)\n\n\u8be5\u505a\u6cd5\u53ef\u4ee5\u6c42\u51fa\u6240\u6709\u7cfb\u6570\uff0c\u4ee5\u4e0b\u662f\u5bf9\u4e0a\u9762\u4e24\u53e5\u8bdd\u7684\u7ffb\u8bd1(\n\n\u957f\u5ea6\u975e $1$ \u7684\u5faa\u73af\u6392\u5217\u7684 EGF \u4e3a $\\sum_{i\\geq 2}\\frac{1}{i}x^i=-\\ln(1-x)-x$\uff0c\u4e8e\u662f\u6211\u4eec\u8981\u6c42\u7684\u5c31\u662f\n\n$$\n\\sum_{i\\geq 0}\\frac{(-\\ln(1-x)-x)^i}{i!}\\sum_{j}c_ji^j\n$$\n\n\u4e3a\u4e86\u7b80\u5316\u540e\u7eed\u7684\u8ba1\u7b97\uff0c\u6211\u4eec\u5148\u7528 $\\Theta(k\\log^2 k)$ \u7684\u65f6\u95f4\u628a\u591a\u9879\u5f0f\u8f6c\u4e3a\u725b\u987f\u7ea7\u6570\uff0c\u8fd9\u6837\u6211\u4eec\u8981\u6c42\u7684\u5c31\u5927\u6982\u662f\n\n$$\n\\sum_{i\\geq 0}\\frac{(-\\ln(1-x)-x)^i}{i!}\\sum_{j\\geq 0}c_j\\binom{i}{j}=\\sum_j c_j[y^j]e^{(1+y)(-\\ln(1-x)-x)}\n$$\n\n\u9996\u5148\u7ffb\u8bd1\u4e0a\u9762\u4e00\u53e5\u8bdd\uff0c\u8003\u8651\u5176\u8f6c\u7f6e\u7684\u8ba1\u7b97\uff0c\u4e5f\u5c31\u662f\n\n$$\n\\sum_j c_j[x^j]e^{(1+y)(-\\ln(1-x)-x)}\n$$\n\n\u6ce8\u610f\u8fd9\u65f6 BGF \u6709\u5f88\u597d\u7684\u6027\u8d28. \u8bbe $F=e^{(1+y)(-\\ln(1-x)-x)}$\uff0c\u5219\u6709\n\n$$\n\\frac{\\partial F}{\\partial x}=F(1+y)(\\frac{1}{1-x}-1)\n$$\n\n\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u6765\u7ffb\u8bd1\u4e0b\u9762\u4e00\u53e5\u8bdd\uff0c\u4ee4 $F_i(y)=[x^i]F$\uff0c\u90a3\u4e48\u6709\u9012\u63a8\u5f0f\n\n$$\niF_i=(i-1)F_{i-1}+(1+y)F_{i-2}\n$$\n\n\u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u5206\u6cbb\u8ba1\u7b97. \u5bf9\u4e8e\u533a\u95f4 $[l,r]$\uff0c\u6211\u4eec\u7b97\u51fa\n\n$$\n\\sum_{i=l}^rc_iF_i(y)\n$$\n\n\u5173\u4e8e $F_{l-1}$ \u548c $F_{l-2}$ \u7684\u8868\u793a. \u663e\u7136\u8fd9\u4e24\u4e2a\u7cfb\u6570\u591a\u9879\u5f0f\u6b21\u6570\u90fd\u662f $\\Theta(r-l)$ \u7684. \u6211\u4eec\u53ea\u9700\u8981\u518d\u5bf9\u6bcf\u4e2a\u533a\u95f4\u7b97\u51fa $F_{r},F_{r-1}$ \u5173\u4e8e $F_{l-1},F_{l-2}$ \u7684\u8868\u793a\u5c31\u53ef\u4ee5\u5408\u5e76\u533a\u95f4.\n\n\u6700\u540e\u628a\u8fd9\u4e2a\u8fc7\u7a0b\u8f6c\u7f6e\u5373\u53ef.\n\n\u653e\u51fa\u4e3b\u8981\u90e8\u5206\u4ee3\u7801\n\n```\nvoid solve(int rot,int lt,int rt)\n{\n\tif(lt==rt)\n\t{\n\t\ta[rot][1][0]=Poly(1);a[rot][1][1]=Poly(0);\n\t\tif(lt==0){a[rot][0][0]=Poly(1),a[rot][0][1]=Poly(0);}\n\t\telse if(lt==1){a[rot][0][0]=a[rot][0][1]=Poly(0);}\n\t\telse\n\t\t{\n\t\t\ta[rot][0][0]=Poly(Z(lt-1)*inv[lt]);a[rot][0][1]=Poly(inv[lt],inv[lt]);\n\t\t}\n\t\treturn;\n\t}\n\tint mid=(lt+rt)>>1;\n\tsolve(rot<<1,lt,mid),solve(rot<<1|1,mid+1,rt);\n\tfor(int i=0;i<2;i++)\n\t\tfor(int j=0;j<2;j++)\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t\ta[rot][i][j]+=a[rot<<1|1][i][k]*a[rot<<1][k][j];\n}\nvoid solve2(const Poly u[2],int rot,int lt,int rt)\n{\n\tif(lt==rt)\n\t{\n\t\tif(lt==0)ans[lt]=u[0][0];\n\t\telse if(lt==1)ans[lt]=0;\n\t\telse ans[lt]=(u[0][0]*Z(lt-1)+u[1][0]+u[1][1])*inv[lt];\n\t\treturn;\n\t}\n\tint mid=(lt+rt)>>1;\n\tPoly v[2];v[0]=u[0],v[1]=u[1];v[0].resize((mid-lt+1)/2+1),v[1].resize((mid-lt+1)/2+1);\n\tsolve2(v,rot<<1,lt,mid);\n\t\n\tv[0]=mulT(u[0],a[rot<<1][0][0])+mulT(u[1],a[rot<<1][0][1]);\n\tv[1]=mulT(u[0],a[rot<<1][1][0])+mulT(u[1],a[rot<<1][1][1]);\n\tsolve2(v,rot<<1|1,mid+1,rt);\n}\n```",
        "postTime": 1615940303,
        "uid": 22136,
        "name": "qwaszx",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P7439 \u3010\u5165\u95e8\u7ea7\u7684\u6392\u5217\u8ba1\u6570\u3011"
    }
]