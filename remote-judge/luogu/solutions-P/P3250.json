[
    {
        "content": "\u7528\u65f6\u95f4\u7ebf\u6bb5\u6811\u6216\u8005\u76f4\u63a5\u66b4\u529b\u7ef4\u62a4\u662f$O(n\\log^3n)$\u7684\uff0c\u867d\u7136\u5361\u5361\u5e38\u53ef\u4ee5\u8fc7\u4f46\u662f\u6709\u66f4\u597d\u7684\u505a\u6cd5\u3002\n\t\n\u8003\u8651\u4e8c\u5206\u7b54\u6848\uff0c\u5982\u679c\u67d0\u4e2a\u8be2\u95ee\u70b9\u88ab\u6240\u6709\u5927\u4e8e\u5f53\u524d\u7b54\u6848\u7684\u8def\u5f84\u6240\u7ecf\u8fc7\uff0c\u90a3\u4e48\u7b54\u6848\u5c0f\u4e8e\u7b49\u4e8e\u5f53\u524d\u7b54\u6848\uff0c\u5426\u5219\u5927\u4e8e\u7b49\u4e8e\u5f53\u524d\u7b54\u6848\u3002\u67e5\u8be2\u7ecf\u8fc7\u4e00\u4e2a\u70b9\u7684\u8def\u5f84\u6761\u6570\uff0c\u628a\u8def\u5f84\u4e24\u7aef\u70b9\u6743\u52a0\u4e00\uff0c\u7136\u540elca\u548clca\u7236\u4eb2\u7684\u70b9\u6743\u51cf\u4e00\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u4e00\u4e0b\u5b50\u6811\u6743\u503c\u548c\u5373\u53ef\u3002\n\t\n\u4f46\u662f\u6211\u4eec\u8fd8\u8981\u8003\u8651\u4e00\u6761\u8def\u5f84\u5728\u5f53\u524d\u65f6\u523b\u662f\u5426\u51fa\u73b0\uff0c\u4ee5\u53ca\u8ba1\u7b97\u51fa\u6bd4\u5f53\u524d\u7b54\u6848\u5927\u7684\u8def\u5f84\u6709\u591a\u5c11\u6761\u3002\n\t\n\u6240\u4ee5\u6211\u4eec\u8003\u8651\u6574\u4f53\u4e8c\u5206\u3002\u6574\u4f53\u4e8c\u5206\u4e2d\u5f53\u524d\u90e8\u5206\u7684\u5404\u4e2a\u64cd\u4f5c\u4f9d\u65e7\u662f\u6309\u7167\u65f6\u95f4\u987a\u5e8f\u8fdb\u884c\u7684\uff0c\u53ef\u4ee5\u540c\u65f6\u7ef4\u62a4\u5f53\u524d\u65f6\u523b\u8def\u5f84\u662f\u5426\u5b58\u5728\uff0c\u4ee5\u53ca\u8ba1\u7b97\u51fa\u6bd4\u5f53\u524d\u7b54\u6848\u5927\u7684\u8def\u5f84\u6709\u591a\u5c11\u6761\u3002\n\t\n\u5047\u8bbe\u5f53\u524d\u4e8c\u5206\u7684\u7b54\u6848\u662fmid\uff0c\u8981\u5904\u7406\u7684\u64cd\u4f5c\u961f\u5217\u4e3aq\u3002\u6211\u4eec\u53ea\u9700\u8981\u626b\u4e00\u904dq\uff0c\u5982\u679c\u662f\u8be2\u95ee\u90a3\u4e48\u5c31\u67e5\u8be2\u4e00\u4e0b\u7ecf\u8fc7\u5b83\u7684\u8def\u5f84\uff0c\u5224\u65ad\u5b83\u4e0b\u6b21\u4f1a\u88ab\u4e22\u5230\u5de6\u8fb9\u9012\u5f52\u8fd8\u662f\u4e22\u5230\u53f3\u8fb9\u9012\u5f52\uff1b\u5982\u679c\u662f\u4fee\u6539\uff0c\u90a3\u4e48\u5982\u679c\u8fd9\u6b21\u4fee\u6539\u5bf9\u5e94\u7684\u8def\u5f84\u6743\u503c\u5927\u4e8emid\uff0c\u5c31\u8fdb\u884c\u4fee\u6539\uff0c\u7136\u540e\u4e22\u5230\u53f3\u8fb9\u9012\u5f52\uff0c\u5426\u5219\u5bf9\u5f53\u524d\u60c5\u51b5\u4e0b\u5176\u4ed6\u7684\u8be2\u95ee\u6ca1\u6709\u5f71\u54cd\uff0c\u76f4\u63a5\u4e22\u5230\u5de6\u8fb9\u9012\u5f52\u5373\u53ef\u3002\n\t\n\u590d\u6742\u5ea6$O(n\\log^2n)$\uff0c\u4e0d\u9700\u8981\u4efb\u4f55\u4f18\u5316\u8dd1\u5f97\u98de\u5feb\u3002\n\n```\n#include<bits/stdc++.h>\nusing std::vector;\n\n#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)\n#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)\n\ntemplate<typename T>T Max(const T &x,const T &y){return x<y?y:x;}\ntemplate<typename T>T Min(const T &x,const T &y){return x<y?x:y;}\ntemplate<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}\ntemplate<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}\ntemplate<typename T>void read(T &x){\n\tT f=1;char ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n\tfor(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n\tx*=f;\n}\n\nconst int maxn=200010;\nstruct edge{\n\tint to,nxt;\n}e[maxn];\nstruct Query{\n\tint op,t,x,res;\n\tbool operator<(const Query &b)const{return t<b.t;}\n}q[maxn],ql[maxn],qr[maxn];\nint n,m,num,head[maxn],c[maxn];\nint fa[maxn],top[maxn],size[maxn],son[maxn],dep[maxn];\nint A[maxn],B[maxn],C[maxn],tL[maxn],tR[maxn],dfn,mx;\n\nvoid add(int,int);\nint qry(int);\nint qry(int,int);\nvoid addedge(int,int);\nvoid Dfs1(int,int);\nvoid Dfs2(int,int);\nint lca(int,int);\nvoid Solve(int,int,int,int);\nvoid modify(int,int,int);\n\nint main(){\n\tread(n);read(m);\n\tFor(i,1,n-1){\n\t\tint u,v;read(u);read(v);\n\t\taddedge(u,v);\n\t}\n\tDfs1(1,0);Dfs2(1,1);\n\tFor(i,1,m){\n\t\tread(q[i].op);\n\t\tq[i].t=i;\n\t\tif(!q[i].op){\n\t\t\tread(A[i]);read(B[i]);\n\t\t\tread(C[i]);\n\t\t\tq[i].x=i;\n\t\t\tchkmax(mx,C[i]);\n\t\t}\n\t\telse read(q[i].x);\n\t}\n\tSolve(-1,mx,1,m);\n\tstd::sort(q+1,q+m+1);\n\tFor(i,1,m) if(q[i].op==2) printf(\"%d\\n\",q[i].res);\n\treturn 0;\n}\n\nvoid Solve(int l,int r,int L,int R){\n\tif(l==r){\n\t\tFor(i,L,R) if(q[i].op==2) q[i].res=l;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1,path=0,cntl=0,cntr=0;\n\tFor(i,L,R){\n\t\tif(q[i].op==2){\n\t\t\tif(qry(tL[q[i].x],tR[q[i].x])==path) ql[++cntl]=q[i];\n\t\t\telse qr[++cntr]=q[i];\n\t\t}\n\t\telse{\n\t\t\tif(C[q[i].x]<=mid) ql[++cntl]=q[i];\n\t\t\telse{\n\t\t\t\tint v=q[i].op?-1:1;\n\t\t\t\tpath+=v;\n\t\t\t\tmodify(A[q[i].x],B[q[i].x],v);\n\t\t\t\tqr[++cntr]=q[i];\n\t\t\t}\n\t\t}\n\t}\n\tFor(i,1,cntr) if(qr[i].op!=2){\n\t\tint v=qr[i].op?1:-1;\n\t\tmodify(A[qr[i].x],B[qr[i].x],v);\n\t}\n\tFor(i,1,cntl) q[L+i-1]=ql[i];\n\tFor(i,1,cntr) q[L+cntl+i-1]=qr[i];\n\tif(cntl) Solve(l,mid,L,L+cntl-1);\n\tif(cntr) Solve(mid+1,r,L+cntl,R);\n}\nvoid modify(int x,int y,int v){\n\tint z=lca(x,y);\n\tadd(tL[x],v);add(tL[y],v);add(tL[z],-v);\n\tif(fa[z]) add(tL[fa[z]],-v);\n}\nvoid Dfs1(int x,int f){\n\tdep[x]=dep[fa[x]=f]+1;\n\tsize[x]=1;tL[x]=++dfn;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t\tif(e[i].to!=f){\n\t\t\tDfs1(e[i].to,x);\n\t\t\tsize[x]+=size[e[i].to];\n\t\t\tif(size[e[i].to]>size[son[x]]) son[x]=e[i].to;\n\t\t}\n\ttR[x]=dfn;\n}\nvoid Dfs2(int x,int tp){\n\ttop[x]=tp;\n\tif(son[x]) Dfs2(son[x],tp);\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t\tif(e[i].to!=fa[x]&&e[i].to!=son[x])\n\t\t\tDfs2(e[i].to,e[i].to);\n}\nint lca(int u,int v){\n\tint x=top[u],y=top[v];\n\twhile(x!=y){\n\t\tif(dep[x]>dep[y]) x=top[u=fa[x]];\n\t\telse y=top[v=fa[y]];\n\t}\n\treturn dep[u]<dep[v]?u:v;\n}\nvoid addedge(int u,int v){\n\te[++num].to=v;e[num].nxt=head[u];head[u]=num;\n\te[++num].to=u;e[num].nxt=head[v];head[v]=num;\n}\nvoid add(int x,int v){for(;x<=n;x+=x&-x) c[x]+=v;}\nint qry(int x){\n\tint res=0;\n\tfor(;x;x-=x&-x) res+=c[x];\n\treturn res;\n}\nint qry(int l,int r){return qry(r)-qry(l-1);}\n```",
        "postTime": 1522235862,
        "uid": 20176,
        "name": "Salamander",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u8fd9\u9898\u771f\u662f\u76f8\u5f53\u7684\u66b4\u529b\u3002\u3002\u3002\n\n\u6811\u94fe\u5256\u5206\u641e\u51faDFS\u5e8f\uff0c\u4ee5\u53ca\u7528\u6765\u6c42LCA\n\n\u65e2\u7136\u662f\u4e0d\u5728\u8fd9\u4e2a\u8282\u70b9\u4e0a\u7684\u6700\u5927\u503c\n\n\u90a3\u5c31\u628a\u9664\u4e86\u8fd9\u4e2a\u8def\u5f84\u4e0a\u7684\u70b9\u4e4b\u5916\u7684\u6240\u6709\u70b9\u5168\u90e8\u4e22\u5230\u4e00\u4e2a\u5806\u91cc\u9762\n\n\u5177\u4f53\u7684\u8bb2\uff1a\n\n\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\u5957\u4e00\u4e2a\u5806\uff1f\uff1f\uff1f\n\n\u5177\u4f53\u7684\u5b9e\u73b0\u8fd8\u662f\u770b\u4ee3\u7801\u628a\u3002\u3002\u3002\n\n[\u4f46\u662f\u6211\u5c31\u559c\u6b22\u5f3a\u884c\u628a\u535a\u5ba2\u63d2\u8fdb\u6765](http://www.cnblogs.com/cjyyb/p/7623995.html)\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<vector>\n#define MAX 110000\n#define lson (now<<1)\n#define rson (now<<1|1)\nusing namespace std;\ninline int read()\n{\n    int x=0,t=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return x*t;\n}\nstruct Line\n{\n    int v,next;\n}e[MAX*2];\nstruct Link\n{\n    int l,r;\n}li[MAX];\nstruct Record\n{\n    int u,v,w;\n}tt[MAX];\ninline bool operator <(Link a,Link b)\n{\n    if(a.l!=b.l)return a.l<b.l;\n    else return a.r<b.r;\n}\nint size[MAX],hson[MAX];\nint h[MAX],cnt=1,dep[MAX],top[MAX],ff[MAX];\ninline void Add(int u,int v)\n{\n    e[cnt]=(Line){v,h[u]};\n    h[u]=cnt++;\n}\nstruct PQ\n{\n    priority_queue<int> Q1;\n    priority_queue<int> Q2;\n    void push(int x)\n        {\n            Q1.push(x);\n        }\n    void del(int x)\n        {\n            Q2.push(x);\n        }\n    int top()\n        {\n            while(!Q2.empty()&&Q1.top()==Q2.top()){Q1.pop();Q2.pop();}\n            return Q1.empty()?-1:Q1.top();\n        }\n}t[MAX*5];\nint tim,N,M,dfn[MAX];\nvoid DFS1(int u,int f)\n{\n    size[u]=1;dep[u]=dep[f]+1;\n    for(int i=h[u];i;i=e[i].next)\n    {\n        int v=e[i].v;\n        if(v==f)continue;\n        ff[v]=u;\n        DFS1(v,u);\n        size[u]+=size[v];\n        if(size[v]>size[hson[u]])hson[u]=v;\n    }\n}\nvoid DFS2(int u,int tp)\n{\n    top[u]=tp;dfn[u]=++tim;\n    if(hson[u])DFS2(hson[u],tp);\n    for(int i=h[u];i;i=e[i].next)\n    {\n        int v=e[i].v;\n        if(v==ff[u]||v==hson[u])continue;\n        DFS2(v,v);\n    }\n}\nvoid Update(int now,int l,int r,int al,int ar,int k,int opt)\n{\n    if(al==l&&ar==r)\n    {\n        opt?t[now].del(k):t[now].push(k);\n        return;\n    }\n    int mid=(l+r)>>1;\n    if(ar<=mid)Update(lson,l,mid,al,ar,k,opt);\n    else if(al>mid)Update(rson,mid+1,r,al,ar,k,opt);\n    else{Update(lson,l,mid,al,mid,k,opt);Update(rson,mid+1,r,mid+1,ar,k,opt);}\n}\nint Query(int now,int l,int r,int x)\n{\n    if(l==r)return t[now].top();\n    int mid=(l+r)>>1;\n    int ans=t[now].top();\n    if(x<=mid)return max(ans,Query(lson,l,mid,x));\n    else return max(ans,Query(rson,mid+1,r,x));\n}\nvoid Happen(int u,int v,int opt,int xx)\n{\n    int qq=0;\n    while(top[u]!=top[v])\n    {\n        if(dep[top[u]]<dep[top[v]])swap(u,v);\n        li[++qq]=(Link){dfn[top[u]],dfn[u]};\n        u=ff[top[u]];\n    }\n    if(dep[u]<dep[v])swap(u,v);\n    li[++qq]=(Link){dfn[v],dfn[u]};\n    sort(&li[1],&li[qq+1]);\n    int Left=0;\n    for(int i=1;i<=qq;Left=max(Left,li[i++].r))\n        if(Left+1<li[i].l)Update(1,1,N,Left+1,li[i].l-1,xx,opt);\n    if(Left<N)Update(1,1,N,Left+1,N,xx,opt);\n}\nint main()\n{\n    freopen(\"4538.in\",\"r\",stdin);\n    N=read();M=read();\n    for(int i=1;i<N;++i)\n    {\n        int u=read(),v=read();\n        Add(u,v);Add(v,u);\n    }\n    DFS1(1,0);DFS2(1,1);\n    for(int i=1;i<=M;++i)\n    {\n        int opt=read();\n        if(opt==2)\n        {\n            int x=read();\n            printf(\"%d\\n\",Query(1,1,N,dfn[x]));\n        }\n        else if(opt==1)\n        {\n            int r=read();\n            Happen(tt[r].u,tt[r].v,opt,tt[r].w);\n        }\n        else\n        {\n            tt[i]=(Record){read(),read(),read()};\n            Happen(tt[i].u,tt[i].v,opt,tt[i].w);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1507103397,
        "uid": 21283,
        "name": "yybyyb",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u7531\u4e8e\u8fd9\u9053\u9898\u7684\u64cd\u4f5c\u53ea\u4e0e\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u6709\u5173\uff0c\u56e0\u6b64\u4ee5\u54ea\u4e2a\u8282\u70b9\u4e3a\u6839\u4e0d\u5f71\u54cd\u7ed3\u679c\u3002\n\n\u518d\u5206\u6790\u9898\u76ee\u5176\u5b9e\u5c31\u662f\u4e00\u68f5\u6811\u652f\u6301\u6dfb\u52a0\u548c\u5220\u9664\u8def\u5f84\u5e76\u652f\u6301\u5355\u70b9\u8be2\u95ee\uff0c\u8fd9\u5c31\u662f\u6811\u94fe\u5256\u5206\u4e86\u3002\n\n\u56e0\u6b64\u6211\u4eec\u968f\u4fbf\u4ee5\u4e00\u4e2a\u70b9\u4e3a\u6839\uff0c\u628a\u6811\u8fdb\u884c\u91cd\u94fe\u5256\u5206\u52a0\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u7531\u4e8e\u9898\u76ee\u8981\u95ee\u7684\u662f\u4e0d\u53d7\u67d0\u4e2a\u70b9\u5f71\u54cd\u7684\u6700\u5927\u91cd\u8981\u5ea6\uff0c\n\n\u56e0\u6b64\u6211\u4eec\u628a\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u7ed3\u70b9\u53d8\u6210\u4e00\u4e2a\u5806\uff0c\n\n\u7136\u540e\u6dfb\u52a0\u8def\u5f84\u7684\u65f6\u5019\u628a\u6240\u6709\u4e0d\u5728\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u70b9\u6240\u5728\u7684\u7ebf\u6bb5\u6811\u7ed3\u70b9\u7684\u5806\u4e2d\u52a0\u5165\u8fd9\u6761\u8def\u5f84\u7684\u91cd\u8981\u5ea6\uff0c\n\n\u56e0\u4e3a\u8fd9\u4e9b\u70b9\u80af\u5b9a\u4e0d\u4f1a\u5f71\u54cd\u8fd9\u6761\u8def\u5f84\u7684\u7545\u901a\u3002\n\n\u90a3\u4e48\u76f4\u63a5O(N)\u7684\u5bfb\u627e\u6240\u6709\u4e0d\u5728\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u70b9\u80af\u5b9a\u4f1aT\u90a3\u4e48\u6211\u4eec\u91c7\u53d6\u66f4\u9ad8\u6548\u7684\u529e\u6cd5\uff1a\n\n\u5728\u6cbf\u7740\u91cd\u94fe\u5411\u4e0a\u8df3\u7684\u8fc7\u7a0b\u4e2d\uff0c\u628a\u6240\u7ecf\u8fc7\u7684\u91cd\u94fe\u7684\u9996\u5c3e\u8bb0\u5f55\u4e0b\u6765\u6392\u5e8f\u4e4b\u540e\u628a\u4e0e\u4e4b\u4ea4\u9519\u7684\u533a\u95f4\u52a0\u5165\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u56e0\u4e3a\u540c\u4e00\u6761\u91cd\u94fe\u5728\u7ebf\u6bb5\u6811\u4e2d\u80af\u5b9a\u662f\u8fde\u7eed\u7684\u3002\n\n\u95ee\u9898\u5728\u4e8e\u9898\u76ee\u8fd8\u652f\u6301\u5220\u9664\u8def\u5f84\u64cd\u4f5c\uff0c\u90a3\u4e48\u600e\u4e48\u6ee1\u8db3\u5462\uff1f\n\n\u518d\u7ef4\u62a4\u4e00\u4e2a\u5806\uff0c\u5220\u9664\u65f6\u628a\u91cd\u8981\u5ea6\u52a0\u5165\u8fd9\u4e2a\u5806\uff0c\u6c42\u503c\u65f6\u5224\u65ad\u4e00\u4e0b\u4e24\u4e2a\u5806\u7684\u5806\u9876\u5143\u7d20\uff0c\n\n\u82e5\u76f8\u540c\u540c\u65f6pop\u6389\uff0c\u5426\u5219\u52a0\u5165\u5806\u7684\u5806\u9876\u5143\u7d20\u5c31\u662f\u8981\u6c42\u7684\u503c\u3002\uff08\u5e38\u89c4\u64cd\u4f5c\uff0c\u8bc1\u660e\u5f88\u7b80\u5355\u5c31\u7565\u53bb\u4e86\uff09\n\n\u5f53\u7136\u4ec5\u4ec5\u4f7f\u7528\u4ee5\u4e0a\u64cd\u4f5c\u4f60\u4e0d\u4f46\u4f1a\u88abT\u98de\u800c\u4e14\u4f1a\u88abM\u98de\u3002\n\n\u90a3\u4e48\u95ee\u9898\u51fa\u5728\u54ea\u5462\uff1f\n\n\u6211\u4eec\u5728\u7528\u7ebf\u6bb5\u6811\u6c42\u503c\u7684\u65f6\u5019\uff0c\u4e00\u65e6\u53d1\u73b0\u76ee\u6807\u533a\u95f4\u5305\u542b\u4e86\u5f53\u524d\u533a\u95f4\u90a3\u4e48\u5f53\u524d\u533a\u95f4\u6240\u6709\u503c\u80af\u5b9a\u4f1a\u5f71\u54cd\u76ee\u6807\u533a\u95f4\u3002\n\n\u6240\u4ee5\u7ef4\u62a4\u7ebf\u6bb5\u6811\u65f6\u662f\u4e0d\u7528\u4e0b\u4f20\u548c\u5408\u5e76\u7684\u3002\u8fd9\u6837\u5c31\u8282\u7ea6\u4e86\u5927\u91cf\u65f6\u95f4\u548c\u7a7a\u95f4\u3002\n\n\u7ecf\u8fc7\u5c42\u5c42\u4f18\u5316\u7ec8\u4e8e\u53ef\u4ee5AC\u4e86\u3002\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nstruct opq\n{\n    int ax;\n    int ay;\n}kk[200001];\nvector<int> a[200001];\npriority_queue<int> segmenttree1[500001],segmenttree2[500001];\nint n,m,size[200001],top[200001],position[200001];\nint deep[200001],son[200001],fa[200001],z=0;\nint u[200001],v[200001],importance[200001];\nbool cmp(opq a1,opq a2)\n{\n    return a1.ax<a2.ax;\n}\nvoid dfs1(int o,int p)\n{\n    size[o]=1;\n    fa[o]=p;\n    deep[o]=deep[p]+1;\n    if(a[o].empty()) return;\n    int maxx=0;\n    for(int i=0;i<a[o].size();i++)\n        if(a[o][i]!=fa[o])\n        {\n            if(!size[a[o][i]]) dfs1(a[o][i],o);\n            size[o]+=size[a[o][i]];\n            if(size[a[o][i]]>maxx)\n            {\n                maxx=size[a[o][i]];\n                son[o]=a[o][i];\n            }\n        }\n}\nvoid dfs2(int o,int p)\n{\n    z++;\n    position[o]=z;\n    top[o]=p;\n    if(son[o]!=0) \n        dfs2(son[o],top[o]);\n    for(int i=0;i<a[o].size();i++)\n        if((a[o][i]!=son[o])&&(a[o][i]!=fa[o]))\n            dfs2(a[o][i],a[o][i]);\n}\nvoid put1(int o,int p,int q,int r,int s,int t)//\u52a0\u5165\u5806\u7684\u64cd\u4f5c\n{\n    if(q>r) return;\n    if((q>=o)&&(r<=p)) \n    {\n        segmenttree1[s].push(t);\n        return;\n    }\n    int mid=(q+r)/2;\n    if(p<=mid) put1(o,p,q,mid,s*2,t);else\n    if(o>mid)put1(o,p,mid+1,r,s*2+1,t);else\n    {put1(o,mid,q,mid,s*2,t);put1(mid+1,p,mid+1,r,s*2+1,t);}\n}\nvoid puttree1(int o,int p,int q)//\u52a0\u5165\u5806\u7684\u64cd\u4f5c\n{\n    int yu=0;\n    while(top[o]!=top[p])\n    {\n        if(deep[top[o]]<deep[top[p]]){int t=o;o=p;p=t;}\n        kk[++yu].ay=position[o];\n        kk[yu].ax=position[top[o]];\n        o=fa[top[o]];\n    }\n    if(deep[o]>deep[p]){int t=o;o=p;p=t;}\n    kk[++yu].ax=position[o];\n    kk[yu].ay=position[p];\n    sort(kk+1,kk+yu+1,cmp);//\u628a\u6240\u7ecf\u8fc7\u7684\u91cd\u94fe\u7684\u9996\u5c3e\u8bb0\u5f55\u4e0b\u6765\u6392\u5e8f\n    kk[0].ay=0;\n    kk[++yu].ax=n+1;\n    for(int i=1;i<=yu;i++)\n        if(kk[i-1].ay+1<=kk[i].ax-1)\n            put1(kk[i-1].ay+1,kk[i].ax-1,1,n,1,q);//\u628a\u4e0e\u4e4b\u4ea4\u9519\u7684\u533a\u95f4\u52a0\u5165\u7ebf\u6bb5\u6811\u3002\n}\nvoid put2(int o,int p,int q,int r,int s,int t)//\u5220\u9664\u5806\u7684\u64cd\u4f5c\n{\n    if(q>r) return;\n    if((q>=o)&&(r<=p))\n    {\n        segmenttree2[s].push(t);\n        return;\n    }\n    int mid=(q+r)/2;\n    if(p<=mid) put2(o,p,q,mid,s*2,t);else\n    if(o>mid)put2(o,p,mid+1,r,s*2+1,t);else\n    {put2(o,mid,q,mid,s*2,t);put2(mid+1,p,mid+1,r,s*2+1,t);}\n}\nvoid puttree2(int o,int p,int q)//\u5220\u9664\u5806\u7684\u64cd\u4f5c\n{\n    int yu=0;\n    while(top[o]!=top[p])\n    {\n        if(deep[top[o]]<deep[top[p]]){int t=o;o=p;p=t;}\n        kk[++yu].ay=position[o];\n        kk[yu].ax=position[top[o]];\n        o=fa[top[o]];\n    }\n    if(deep[o]>deep[p]){int t=o;o=p;p=t;}\n    kk[++yu].ax=position[o];\n    kk[yu].ay=position[p];\n    sort(kk+1,kk+yu+1,cmp);\n    kk[0].ay=0;\n    kk[++yu].ax=n+1;\n    for(int i=1;i<=yu;i++)\n        if(kk[i-1].ay+1<=kk[i].ax-1)\n            put2(kk[i-1].ay+1,kk[i].ax-1,1,n,1,q);\n}\nint get(int o,int p,int q,int r,int s)//\u56de\u7b54\u8be2\u95ee\uff0c\u6c42\u503c\u3002\n{\n    int xxx=-1;\n    if((q<=o)&&(r>=p))\n    {\n        while((!segmenttree1[s].empty())&&(!segmenttree2[s].empty()))\n        {\n            if(segmenttree1[s].top()!=segmenttree2[s].top())break;\n            segmenttree1[s].pop();\n            segmenttree2[s].pop();\n        }\n        if(!segmenttree1[s].empty()) xxx=segmenttree1[s].top();\n    }\n    if(q==r) return xxx;\n    int mid=(q+r)/2;\n    if(p<=mid) return max(xxx,get(o,p,q,mid,s*2));else\n    if(o>mid)return max(xxx,get(o,p,mid+1,r,s*2+1));\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        a[x].push_back(y);\n        a[y].push_back(x);\n    }\n    memset(son,0,sizeof(son));\n    memset(size,0,sizeof(size));\n    dfs1(1,0);//\u91cd\u94fe\u5256\u5206\u7b2c\u4e00\u6b21dfs\uff0c\u6c42\u51fa\u6bcf\u4e2a\u7ed3\u70b9\u7684\u91cd\u513f\u5b50\u7236\u4eb2\u548c\u4ee5\u5176\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f\u3002\n    dfs2(1,1);//\u91cd\u94fe\u5256\u5206\u7b2c\u4e8c\u6b21dfs\uff0c\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\u548c\u6240\u5728\u91cd\u94fe\u7684\u5934\u3002\n    for(int i=1;i<=m;i++)\n    {\n        int yu;\n        cin>>yu;\n        if(yu==0){cin>>u[i]>>v[i]>>importance[i];puttree1(u[i],v[i],importance[i]);}\n        if(yu==1){cin>>u[i];puttree2(u[u[i]],v[u[i]],importance[u[i]]);}\n        if(yu==2){cin>>u[i];cout<<get(position[u[i]],position[u[i]],1,n,1)<<endl;}\n    }\n    return 0;\n}\n```",
        "postTime": 1514981130,
        "uid": 79044,
        "name": "\u7834\u58c1\u4eba",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u6253\u4e00\u6ce2\u5e7f\u544a\uff1ahttps://www.cnblogs.com/xzz_233/p/9884562.html\n\n\u663e\u7136\u53ef\u4ee5\u60f3\u5230\u4e8c\u5206\u7b54\u6848\u3002\u4e8c\u5206\u4e00\u4e2a\u7b54\u6848mid\uff0c\u5982\u679c\u6240\u6709\u957f\u5ea6$\\geq mid$\u7684\u8def\u5f84\u90fd\u8fc7x\uff0c\u90a3\u4e48\u7b54\u6848\u4e00\u5b9a$<mid$\uff0c\u5426\u5219\u7b54\u6848$\\geq mid$\u3002\n\n~~\u90a3\u4e48\u5c31\u53ef\u4ee5\u5199\u51fa\u4ee3\u7801\u4e86\uff0c\u6811\u72b6\u6570\u7ec4\u5957\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6$O(n(log_2n)^3)$~~\n\n\u7136\u540e\u56e0\u4e3a\u51fa\u9898\u4eba\u5361\u7a7a\u95f4\u5c31\u70b8\u4e86\u3002\u3002\u3002\u5982\u679c256M\u5c31\u80fd\u8fc7\u4e86\u3002\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define il inline\n#define vd void\ntypedef long long ll;\nil int gi(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-')f=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nint n,m,fir[100010],nxt[200010],dis[200010],id;\nil vd link(int a,int b){\n    nxt[++id]=fir[a],fir[a]=id,dis[id]=b;\n    nxt[++id]=fir[b],fir[b]=id,dis[id]=a;\n}\nint dfn[100010],dep[100010],fa[100010],siz[100010],son[100010];\nil vd dfs(int x){\n    siz[x]=1;\n    for(int i=fir[x];i;i=nxt[i]){\n        if(dep[dis[i]])continue;\n        dep[dis[i]]=dep[x]+1;\n        fa[dis[i]]=x;\n        dfs(dis[i]);\n        siz[x]+=siz[dis[i]];\n        if(siz[son[x]]<=siz[dis[i]])son[x]=dis[i];\n    }\n}\nint top[100010];\nil vd dfs2(int x,int tp){\n    top[x]=tp;dfn[x]=++dfn[0];\n    if(son[x])dfs2(son[x],tp);\n    for(int i=fir[x];i;i=nxt[i])if(fa[x]!=dis[i]&&son[x]!=dis[i])dfs2(dis[i],dis[i]);\n}\nint o[200010],u[200010],v[200010],w[200010];\nint uni_w[200010],uni_w_tot;\nint cnt,rt[200010],ls[15000001],rs[15000001],lz[15000001];\n#define mid ((l+r)>>1)\nil vd _update(int&x,int l,int r,const int&L,const int&R,const int&d){\n    if(!x)x=++cnt;\n    if(L<=l&&r<=R){lz[x]+=d;return;}\n    if(L<=mid)_update(ls[x],l,mid,L,R,d);\n    if(mid<R)_update(rs[x],mid+1,r,L,R,d);\n}\nil int _query(int&x,int l,int r,const int&p){\n    if(!x)return 0;\n    if(l==r)return lz[x];\n    if(p<=mid)return lz[x]+_query(ls[x],l,mid,p);\n    else return lz[x]+_query(rs[x],mid+1,r,p);\n}\n#undef mid\nil vd Update(const int&p,const int&l,const int&r,const int&d){\n    int x=p;\n    while(x<=uni_w_tot)_update(rt[x],1,n,l,r,d),x+=x&-x;\n}\nil int Query(const int&p,const int&l){\n    int x=p,ret=0;\n    while(x)ret+=_query(rt[x],1,n,l),x-=x&-x;\n    return ret;\n}\nint t[200010];\nil vd bit_update(int x,int d){while(x<=uni_w_tot)t[x]+=d,x+=x&-x;}\nil int bit_query(int x){int r=0;while(x)r+=t[x],x-=x&-x;return r;}\nint main(){\n    n=gi(),m=gi();\n    for(int i=1;i<n;++i)link(gi(),gi());\n    int RT=rand()%n+1;\n    dep[RT]=1,dfs(RT),dfs2(RT,RT);\n    for(int i=1;i<=m;++i){\n        o[i]=gi();\n        if(o[i]==0)u[i]=gi(),v[i]=gi(),w[i]=gi(),uni_w[++uni_w_tot]=-w[i];\n        else if(o[i]==1){\n            int t=gi();\n            u[i]=u[t],v[i]=v[t],w[i]=w[t];\n        }else if(o[i]==2)u[i]=gi();\n    }\n    std::sort(uni_w+1,uni_w+uni_w_tot+1);uni_w_tot=std::unique(uni_w+1,uni_w+uni_w_tot+1)-uni_w-1;\n    for(int i=1;i<=m;++i)if(o[i]!=2)w[i]=std::lower_bound(uni_w+1,uni_w+uni_w_tot+1,-w[i])-uni_w;\n    for(int i=1;i<=uni_w_tot;++i)uni_w[i]=-uni_w[i];\n    for(int i=1;i<=m;++i){\n        if(o[i]^2){\n            int x=u[i],y=v[i],d=o[i]==0?1:-1;\n            while(top[x]!=top[y])\n                if(dep[top[x]]>dep[top[y]])Update(w[i],dfn[top[x]],dfn[x],d),x=fa[top[x]];\n                else Update(w[i],dfn[top[y]],dfn[y],d),y=fa[top[y]];\n            if(dfn[x]>dfn[y])std::swap(x,y);\n            Update(w[i],dfn[x],dfn[y],d);\n            bit_update(w[i],d);\n        }else{\n            if(!bit_query(uni_w_tot)){puts(\"-1\");continue;}\n            int l=1,r=uni_w_tot+1,mid;\n            while(l<r){\n                mid=((l+r)>>1);\n                if(Query(mid,dfn[u[i]])==bit_query(mid))l=mid+1;\n                else r=mid;\n            }\n            if(l<=uni_w_tot)printf(\"%d\\n\",uni_w[l]);\n            else puts(\"-1\");\n        }\n    }\n    return 0;\n}\n```\n\n\u7136\u540e\u5b66\u4e86\u4e00\u53d1\u795e\u4ed9\u6574\u4f53\u4e8c\u5206\n\n\u5927\u6982\u5c31\u662f\u8bf4\u7b54\u6848\u8981\u7528\u4e8c\u5206\u6c42\uff0c\u53ef\u4ee5\u653e\u5728\u4e00\u8d77\u4e8c\u5206\n\n\u5927\u6982\u5c31\u662f`void solve(int l,int r,int L,int R)`\uff0c\u5c31\u662f$[L,R]$\u7684\u64cd\u4f5c/\u8be2\u95ee\uff0c\u64cd\u4f5c\u7684\u6743\u503c\u90fd$\\in[l,r]$\uff0c\u8fd9\u91cc\u9762\u7684\u67e5\u8be2\u90fd\u5df2\u7ecf\u786e\u5b9a\u4e86\u5728$[l,r]$\u8303\u56f4\u5185\u3002\n\n\u5982\u679c$l=r$\u76f4\u63a5\u66f4\u65b0\u7b54\u6848\u5c31\u597d\u4e86\uff0c\u5426\u5219\u8981\u786e\u5b9a\u8fd9\u91cc\u9762\u6240\u6709\u67e5\u8be2\u7684\n\n\u6309\u65f6\u95f4\u987a\u5e8f\u64cd\u4f5c\uff0c\u5982\u679c\u5f53\u524d\u662f\u4fee\u6539\u800c\u4e14\u6743\u503c$\\geq mid$\uff0c\u5c31\u52a0\u5165/\u5220\u9664\u4e00\u6761u-v\u7684\u8def\u5f84\uff1b\u5982\u679c\u662f\u8be2\u95ee\u5c31\u6240\u6709\u7684\u8def\u5f84\u662f\u5426\u90fd\u7ecf\u8fc7\u5f53\u524d\u70b9\u5373\u53ef\uff0c\u5c31\u80fd\u77e5\u9053\u8fd9\u4e2a\u8be2\u95ee\u7684\u7b54\u6848\u662f\u5426$\\geq mid$\u3002\u5177\u4f53\u5b9e\u73b0\u53ef\u4ee5\u7b80\u5355\u6811\u4e0a\u5dee\u5206\u3002\n\n\u7136\u540e\u9012\u5f52\u8c03\u7528\u4e0b\u53bb\u3002\n\n\u7136\u540e\u4ee3\u7801\u4e3a\u4e86\u5361\u5e38\u628a$\\geq$\u6539\u6210\u4e86$\\leq$\uff0c\u5177\u4f53\u89c1\u4ee3\u7801\u3002\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define il inline\n#define vd void\ntypedef long long ll;\nil int gi(){\n    int x=0;\n    char ch=getchar();\n    while(!isdigit(ch))ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint n,m,fir[100010],nxt[200010],dis[200010],id;\nil vd link(int a,int b){\n    nxt[++id]=fir[a],fir[a]=id,dis[id]=b;\n    nxt[++id]=fir[b],fir[b]=id,dis[id]=a;\n}\nint dfn[100010],dep[100010],fa[100010],siz[100010],son[100010];\nil vd dfs(int x){\n    siz[x]=1;\n    for(int i=fir[x];i;i=nxt[i]){\n        if(dep[dis[i]])continue;\n        dep[dis[i]]=dep[x]+1;\n        fa[dis[i]]=x;\n        dfs(dis[i]);\n        siz[x]+=siz[dis[i]];\n        if(siz[son[x]]<=siz[dis[i]])son[x]=dis[i];\n    }\n}\nint top[100010];\nil vd dfs2(int x,int tp){\n    top[x]=tp;dfn[x]=++dfn[0];\n    if(son[x])dfs2(son[x],tp);\n    for(int i=fir[x];i;i=nxt[i])if(fa[x]!=dis[i]&&son[x]!=dis[i])dfs2(dis[i],dis[i]);\n}\nstruct ques{int o,u,v,w,i,lca;bool y;}s[200010],a[200010],b[200010];\nint uni_w[200010],uni_w_tot,ans[200010];\nint t[200010];\nil vd update(int x,int d){while(x<=n)t[x]+=d,x+=x&-x;}\nil int query(int x){int r=0;while(x)r+=t[x],x-=x&-x;return r;}\nil vd solve(int l,int r,int L,int R){\n\tif(L>R)return;\n\tfor(int i=L;i<=R;++i)if(s[i].o==2)goto GG;\n\treturn;GG:;\n\tif(l==r){for(int i=L;i<=R;++i)if(s[i].i)ans[s[i].i]=l;return;}\n\tint mid=(l+r)>>1,tot=0,A=0,B=0;\n\tfor(int i=L;i<=R;++i)\n\t\tif(s[i].o==2){\n\t\t\tif(query(dfn[s[i].u]+siz[s[i].u]-1)-query(dfn[s[i].u]-1)==tot)b[++B]=s[i];\n\t\t\telse a[++A]=s[i];\n\t\t}else if(s[i].w<=mid){\n\t\t\tint d=s[i].o?-1:1;\n\t\t\ttot+=d;\n\t\t\tupdate(dfn[s[i].u],d);update(dfn[s[i].v],d);\n\t\t\tupdate(dfn[s[i].lca],-d);if(s[i].lca!=1)update(dfn[fa[s[i].lca]],-d);\n\t\t\ta[++A]=s[i];\n\t\t}else b[++B]=s[i];\n\tmemcpy(s+L,a+1,(sizeof(ques))*A);\n\tmemcpy(s+L+A,b+1,(sizeof(ques))*B);\n\tfor(int i=L;i<=R;++i)\n\t\tif(s[i].o!=2&&s[i].w<=mid&&s[i].y){\n\t\t\tint d=s[i].o?1:-1;\n\t\t\tupdate(dfn[s[i].u],d);update(dfn[s[i].v],d);\n\t\t\tupdate(dfn[s[i].lca],-d);if(s[i].lca!=1)update(dfn[fa[s[i].lca]],-d);\n\t\t}\n\tsolve(l,mid,L,L+A-1),solve(mid+1,r,L+A,R);\n}\nint main(){\n    n=gi(),m=gi();\n    for(int i=1;i<n;++i)link(gi(),gi());\n    dep[1]=1,dfs(1),dfs2(1,1);\n    for(int i=1;i<=m;++i){\n        s[i].o=gi();\n        if(s[i].o==0){\n\t\t\ts[i].u=gi(),s[i].v=gi(),s[i].w=gi(),uni_w[++uni_w_tot]=-s[i].w;s[i].y=1;\n\t\t\tint x=s[i].u,y=s[i].v;\n\t\t\twhile(top[x]!=top[y]){\n\t\t\t\tif(dep[top[x]]>dep[top[y]])x=fa[top[x]];\n\t\t\t\telse y=fa[top[y]];\n\t\t\t}\n\t\t\ts[i].lca=(dep[x]<dep[y])?x:y;\n        }else if(s[i].o==1){\n\t\t\tint x=gi();\n\t\t\ts[i]=s[x],s[i].o=1;\n\t\t\ts[i].y=s[x].y=0;\n\t\t}else s[i].u=gi(),s[i].i=++ans[0];\n\t}\n\tuni_w[++uni_w_tot]=1;\n\tstd::sort(uni_w+1,uni_w+uni_w_tot+1);uni_w_tot=std::unique(uni_w+1,uni_w+uni_w_tot+1)-uni_w-1;\n\tfor(int i=1;i<=m;++i)if(s[i].o!=2)s[i].w=std::lower_bound(uni_w+1,uni_w+uni_w_tot+1,-s[i].w)-uni_w;\n\tfor(int i=1;i<=uni_w_tot;++i)uni_w[i]=-uni_w[i];\n\tsolve(1,uni_w_tot,1,m);\n\tfor(int i=1;i<=ans[0];++i)printf(\"%d\\n\",uni_w[ans[i]]);\n\treturn 0;\n}\n```\n\n\u5361\u4e86\u4e00\u6ce2\u5e38\u6570\u5c31\u6d1b\u5495rk1\uff0cbzoj rk7\u4e86\u3002\u3002",
        "postTime": 1540979215,
        "uid": 23118,
        "name": "\u03bb\u1d09\u028d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u503c\u5f97\u4e00\u505a\u7684\u9898\u76ee  \n\n\u9996\u5148\u4ece\u67e5\u8be2\u64cd\u4f5c\u5165\u624b\uff0c\u8bbe\u6709\u4e00\u67e5\u8be2\u64cd\u4f5c\uff0c\u4e0d\u59a8\u8bbe\u67e5\u8be2\u8282\u70b9\u7f16\u53f7\u4e3a $u$ \u3002\u9996\u5148\u6211\u4eec\u9700\u8981\u8003\u8651\uff0c\u5982\u679c\u7b54\u6848**\u5927\u4e8e\u7b49\u4e8e** $x$ \uff0c\u90a3\u4e48\u5bf9\u4e8e $u$ \u6765\u8bf4\uff0c\u5b83\u9700\u8981\u6ee1\u8db3\u4ec0\u4e48\uff1f\u9700\u8981\u81f3\u5c11\u5b58\u5728\u4e00\u6761\u4ea4\u4e92\u8bf7\u6c42\u91cd\u8981\u5ea6**\u5927\u4e8e\u7b49\u4e8e** $x$ \u4e14\u4e0d\u7ecf\u8fc7 $u$ \u53f7\u8282\u70b9\u5373\u53ef\u3002\u4f46\u662f\u8fd9\u6761\u6027\u8d28\u5bf9\u4ee3\u7801\u5e76\u4e0d\u662f\u975e\u5e38\u7684\u53cb\u597d\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6362\u4e00\u79cd\u8bf4\u6cd5\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u5f97\u5230\u4e86 **\u6027\u8d281\uff1a**  \n\n**\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8e $x$ \u7684\u8bf7\u6c42\u6570 $>$ \u7ecf\u8fc7 $u$ \u4e14\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8e $x$ \u7684\u8bf7\u6c42\u6570**  \n\n\u56e0\u4e3a\u7b54\u6848\u6c42\u7684\u662f\u6700\u5927\u503c\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6700\u5927\u5316 $x$ \u3002  \n\u770b\u5230\u6700\u5927\uff0c\u4e00\u822c\u60f3\u5230\u6570\u636e\u7ed3\u6784\u6216\u8005\u5355\u8c03\u6027\u76f8\u5173\u7684\u95ee\u9898\u3002\u5728\u8fd9\u4e2a\u60c5\u666f\u4e2d\uff0c\u6570\u636e\u7ed3\u6784\u663e\u7136\u5e76\u4e0d\u600e\u4e48\u597d\u7528\u3002\u4e8e\u662f\u8003\u8651\u5355\u8c03\u6027\u3002\u5982\u679c\u771f\u7684\u5f80\u5355\u8c03\u6027\u60f3\u4e86\uff0c\u4f1a\u6bd4\u8f83\u5bb9\u6613\u5730\u53d1\u73b0\u4e00\u4e2a\u7b80\u5355\u53c8\u91cd\u8981\u7684\u6027\u8d28\uff1a  \n\n**\u8bbe\u7531\u6240\u6709 $x$ \u7ec4\u6210\u7684\u96c6\u5408\u4e3a $D$\uff0c\u90a3\u4e48\u82e5 $k \\in D$\uff0c\u90a3\u4e48 $\\forall m < k, m \\in Z_+$ \uff0c\u90a3\u4e48 $ m \\in D$**\n\n\u6240\u4ee5\uff0c$x$ \u7684\u5206\u5e03\u5177\u6709\u5355\u8c03\u6027\uff01  \n\n\u6839\u636e\u5355\u8c03\u6027\uff0c\u8003\u8651\u4e8c\u5206\u3002  \n\u4ecd\u7136\u662f\u4e0a\u9762\u7684\u60c5\u666f\uff0c\u67e5\u8be2 $u$ \u53f7\u8282\u70b9\uff0c\u8bbe\u5f53\u524d\u7b54\u6848\u5728 $[l,r]$ \u8303\u56f4\u5185\uff0c\u679a\u4e3e\u7b54\u6848\u4e3a $mid=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$\uff0c\u5982\u679c\u91cd\u8981\u5ea6**\u5927\u4e8e\uff08\u6ce8\u610f\u8fd9\u91cc\u6ca1\u6709\u7b49\u4e8e\uff0c\u4e0b\u6587\u540c\uff0c\u5168\u90e8\u7ecf\u8fc7\u4e86\u52a0\u7c97\u5904\u7406\uff09** $mid$ \u7684\u8bf7\u6c42\u6570 $=$ \u7ecf\u8fc7 $u$ \u7684\u91cd\u8981\u5ea6**\u5927\u4e8e** $mid$ \u7684\u8bf7\u6c42\u6570\uff0c\u6839\u636e\u5355\u8c03\u6027\uff0c\u8bf4\u660e $mid$ \u592a\u5927\uff0c$r=mid+1$\uff0c\u5426\u5219 $l=mid$\uff08\u4e3a\u4ec0\u4e48\u662f$mid$\u5462\uff1f\u56e0\u4e3a\u8fd9\u6761\u8bf7\u6c42\u7684\u7b54\u6848\u503c\u57df\u662f $[l,mid]$\uff0c\u6ce8\u610f\u52a0\u7c97\u90e8\u5206\uff09\u3002  \n\n\u5982\u4f55\u7ef4\u62a4\u4e00\u4e2a\u70b9\u88ab\u7ecf\u8fc7\u591a\u5c11\u6b21\uff1f\u8003\u8651\u6811\u4e0a\u5dee\u5206\uff0c\u5bf9\u4e8e\u8bf7\u6c42 $(u,v)$ \uff08\u4ece $u$ \u5230 $v$ \uff09\uff0c$ val[u]=val[u]+1, val[v]=val[v]+1, val[LCA(u, v)]=val[LCA(u, v)]-1 $ \uff08\u6ce8\u610f\u662f $-1$ \uff09 \uff0c\u6bcf\u4e2a\u70b9\u88ab\u7ecf\u8fc7\u591a\u5c11\u6b21\u5c31\u662f\u5b83\u7684\u5b50\u6811\u6743\u503c\u548c\uff08\u521d\u59cb\u503c $0$ \uff09\uff0c\u4f46\u662f\u4e3a\u4e86\u8ba9 $LCA(u, v)$ \u7684\u7956\u5148\u7b54\u6848\u4e0d\u53d7\u5f71\u54cd\uff0c\u6240\u4ee5 $val[father[LCA(u, v)]]=val[father[LCA(u, v)]]-1$\uff08\u6ce8\u610f\u662f $-1$ \uff09\u3002\u56e0\u4e3a\u8981\u7ef4\u62a4\u5b50\u6811\u548c\uff0c\u6709\u8981\u6c42 $LCA$\uff0c \u60f3\u5230\u6811\u94fe\u5256\u5206+\u6811\u72b6\u6570\u7ec4 ~~\uff08\u7ebf\u6bb5\u6811\u592a\u9ebb\u70e6\u4e86~~ \u3002  \n\n\u6b64\u65f6\uff0c\u56e0\u4e3a\u9700\u8981\u5b9e\u65f6\u7ef4\u62a4\u8fc7 $u$ \u7684\u6240\u6709\u6743\u503c\u5927\u4e8e\u7b49\u4e8e $mid$ \u7684\u8bf7\u6c42\u6570\uff0c\u590d\u6742\u5ea6\u504f\u9ad8\u3002    \n\u65e2\u7136\u4e00\u4e2a\u4e2a\u7ef4\u62a4\u7684\u65f6\u95f4\u592a\u591a\uff0c\u90a3\u4e48\u53ef\u4e0d\u53ef\u4ee5\u4e00\u8d77\u7ef4\u62a4\u5462\uff1f\u8003\u8651\u6574\u4f53\u4e8c\u5206\u3002  \n\u5bf9\u4e8e\u67d0\u4e00\u4e2a\u64cd\u4f5c\u5b50\u5e8f\u5217\uff0c\u503c\u57df $[l,r]$\uff0c\u679a\u4e3e\u7b54\u6848 $mid=\\left\\lfloor\\frac{l+r}{2}\\right\\rfloor$\u3002\u4ece\u524d\u5f80\u540e\u904d\u5386\u64cd\u4f5c\u5b50\u5e8f\u5217\uff0c\u5bf9\u4e8e\u67e5\u8be2\u64cd\u4f5c\uff0c\u5982\u679c\u91cd\u8981\u5ea6**\u5927\u4e8e** $mid$ \u7684\u8bf7\u6c42\u6570 $=$ \u7ecf\u8fc7 $u$ \u7684\u91cd\u8981\u5ea6**\u5927\u4e8e** $mid$ \u7684\u8bf7\u6c42\u6570\uff0c\u6839\u636e\u5355\u8c03\u6027\uff0c\u8bf4\u660e $mid$ \u592a\u5927\uff0c$r=mid+1$\uff08\u8fdb\u5165\u5de6\u4fa7\u9012\u5f52\uff09\uff0c\u5426\u5219 $l=mid$\uff08\u8fdb\u5165\u53f3\u4fa7\u9012\u5f52\uff09\u3002\u90a3\u4e48\u5982\u4f55\u5904\u7406\u4fee\u6539\u64cd\u4f5c\uff08\u8fdb\u5165\u5de6\u4fa7\u9012\u5f52\\\u53f3\u4fa7\u9012\u5f52\uff09\uff1f\u56e0\u4e3a\u6211\u4eec\u53ea\u5173\u5fc3\u91cd\u8981\u5ea6**\u5927\u4e8e** $mid$ \u7684\u8bf7\u6c42\uff0c\u6240\u4ee5\u5bf9\u4e8e\u91cd\u8981\u5ea6**\u5c0f\u4e8e\u7b49\u4e8e** $mid$ \u7684\u8bf7\u6c42\uff0c\u8fdb\u5165\u5de6\u4fa7\u9012\u5f52\u5373\u53ef\uff0c\u56e0\u4e3a\u53ea\u6709\u8ba9 $mid$ \u53d8\u5c0f\u624d\u53ef\u4ee5\u8ba9\u8fd9\u6761\u8bf7\u6c42\u6709\u53ef\u80fd\u53d1\u6325\u4f5c\u7528\u3002\u5982\u679c\u8fd9\u6761\u4fee\u6539\u64cd\u4f5c\u91cd\u8981\u5ea6**\u5927\u4e8e** $mid$ \uff0c\u90a3\u4e48\u6211\u4eec\u6309\u7167\u4e0a\u6587\u6240\u8bf4\u7684\uff0c\u8fdb\u884c\u8be5\u6709\u7684\u4fee\u6539\uff0c\u5e76\u8fdb\u5165\u53f3\u4fa7\u9012\u5f52\uff0c\u8ba9\u5b83\u5728 $mid$ \u66f4\u5927\u7684\u4f4d\u7f6e\u53d1\u6325\u4f5c\u7528\u3002\u8fd9\u79cd\u64cd\u4f5c\u6ca1\u6709\u5fc5\u8981\u8fdb\u5165\u5de6\u4fa7\u9012\u5f52\uff0c\u56e0\u4e3a\u5de6\u4fa7\u9012\u5f52\u7684\u503c\u57df\u4e3a\u5f53\u524d\u9012\u5f52\u7684 $[l,mid]$\uff08\u5982\u679c\u8fdb\u5165\u5de6\u533a\u95f4\u4fee\u6539\u7684\u65f6\u5019\u4e00\u5b9a\u4f1a\u88ab\u4fee\u6539\uff0c\u8fd8\u4e0d\u5982\u964d\u4f4e\u4e00\u4e0b\u590d\u6742\u5ea6\uff09\u3002  \n\u6700\u540e\u8003\u8651\uff0c\u5982\u4f55\u8f93\u51fa $-1$ \u7684\u60c5\u51b5\uff1f\u53ea\u9700\u8981\u5728\u4e00\u5f00\u59cb\u9012\u5f52\u7684\u65f6\u5019\uff0c\u5c06\u5de6\u8fb9\u754c\u8bbe\u6210 $-1$ \uff0c\u8fd9\u6837\u7b54\u6848\u662f $-1$ \u5c31\u4f1a\u4e0d\u65ad\u8fdb\u5165\u5de6\u533a\u95f4\uff0c\u76f4\u5230\u5230\u8fbe $-1$ \u3002  \n\n\u590d\u6742\u5ea6\uff1a\u4e8c\u5206 $\\log n$\uff0c \u7ef4\u62a4 $\\log n$ \uff0c\u5408\u8d77\u6765\u5c31\u662f $O(m \\times  \\log^2 n)$\u3002\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ninline int read () {\n\tint ans = 0; char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) ans = ans * 10 + ch - '0', ch = getchar();\n\treturn ans;\n}\n\nconst int N = 100005;\nconst int Q = 200005;\nconst int INF = 0x3f3f3f3f;\nint n, m;\nint num;\nint head[N];\nstruct edge {\n\tint to, nxt;\n} e[N << 1];\n\ninline void add (int u, int v) {\n\te[++ num].nxt = head[u];\n\te[num].to = v;\n\thead[u] = num;\n}\n\n//\u6811\u72b6\u6570\u7ec4\uff0c\u7ef4\u62a4\u5b50\u6811\u6743\u503c\u548c\nint sum[N];\ninline int lowbit (int x) { return x & (-x); }\nvoid update (int x, int k) { // \u5355\u70b9\u4fee\u6539\u7b2c x \u4e2a\u70b9\n\twhile(x <= n) {\n\t\tsum[x] += k;\n\t\tx += lowbit(x);\n\t}\n}\n\nint query (int x) { // \u67e5\u8be2 [1, x]\u548c\n\tint ret = 0;\n\twhile(x > 0) {\n\t\tret += sum[x];\n\t\tx -= lowbit(x);\n\t}\n\t\n\treturn ret;\n}\n\n// \u6811\u94fe\u5256\u5206\uff0c\u7ef4\u62a4\u5b50\u6811\u6743\u503c\u548c\u548cLCA\nint cnt;\nint fa[N], siz[N], son[N], depth[N];\nint top[N], id[N];\n\nvoid dfs1 (int u, int father) {\n\tfa[u] = father;\n\tdepth[u] = depth[fa[u]] + 1;\n\tsiz[u] = 1;\n\t\n\tfor(int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif(v == fa[u]) continue;\n\t\t\n\t\tdfs1(v, u);\n\t\tsiz[u] += siz[v];\n\t\tif(siz[v] > siz[son[u]]) son[u] = v;\n\t}\n}\n\nvoid dfs2 (int u, int tp) {\n\tid[u] = ++ cnt;\n\ttop[u] = tp;\n\t\n\tif(!son[u]) return;\n\tdfs2(son[u], tp);\n\t\n\tfor(int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif(v == fa[u] || v == son[u]) continue;\n\t\t\n\t\tdfs2(v, v);\n\t}\n}\n\nint LCA (int u, int v) { // \u6811\u5256\u6c42LCA\n\twhile(top[u] != top[v]) {\n\t\tif(depth[top[u]] < depth[top[v]]) swap(u, v);\n\t\tu = fa[top[u]];\n\t}\n\t\n\tif(depth[u] > depth[v]) return v; // \u6df1\u5ea6\u6d45\u7684\u624d\u662fLCA\n\treturn u;\n}\n\nstruct query_ { // \u79bb\u7ebf\u5904\u7406\n\tint op;\n\tint u, v, w;\n\tint x;\n\tint ans;\n} q[Q]; // q \u5b58\u7684\u662f\u8be2\u95ee\uff08\u6309\u8f93\u5165\u987a\u5e8f\uff09\n\ninline void updatecounter (int u, int v, int w) { // \u6811\u4e0a\u5dee\u5206\uff0c\u6587\u4e2d\u6240\u8bf4\u7684\u65b9\u6cd5\n\tint lca = LCA(u, v);\n\tupdate(id[u], w);\n\tupdate(id[v], w);\n\tupdate(id[lca], -w);\n\tif(fa[lca] != 0) update(id[fa[lca]], -w); // \u8fd9\u91cc\u4e00\u5b9a\u8981\u6ce8\u610ffa[lca] != 0 !!\n}\n\nint querytree (int u) {\n\treturn (query(id[u] + siz[u] - 1) - query(id[u] - 1)); // \u67e5\u8be2\u5b50\u6811\u6743\u503c\u548c\n}\n\nvoid split (int l, int r, vector <int> p) { // p\u662f\u64cd\u4f5c\u5e8f\u5217\uff0cp[0]\u4ee3\u8868\u8fd9\u5c42\u9012\u5f52\u6700\u5148\u6267\u884c\u7684\u64cd\u4f5c\u662f q[p[0]] \uff08\u53c2\u6570\u4f20\u7684\u662f\u6309\u8f93\u5165\u987a\u5e8f\u7684\u7f16\u53f7\uff09\n\tif(!p.size()) return;\n\tif(l == r) {\n\t\tfor(int i = 0; i < p.size(); ++ i) if(q[p[i]].op == 2) q[p[i]].ans = l;\n\t\treturn;\n\t}\n\t\n\tint mid = l + r >> 1;\n\tint cnt = 0; // \u76ee\u524d\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8e mid \u7684\u8bf7\u6c42\u6570\u91cf\uff08\u6211\u4eec\u53ea\u66f4\u65b0\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8emid\u7684\u8bf7\u6c42\uff09\n\tvector <int> lft, rgt; // \u63a5\u4e0b\u6765\u5de6\u9012\u5f52\u548c\u53f3\u9012\u5f52\u7684\u5b50\u5e8f\u5217\uff08\u7f16\u53f7\uff09\n\t// left right\u7684\u7f29\u5199\n\t\n\tfor(int i = 0; i < p.size(); ++ i) { // p\u5b58\u7684\u662f\u539f\u6765\u64cd\u4f5c\u7684\u4e0b\u8868\uff0c\u6240\u4ee5\u7b2ci\u4e2a\u64cd\u4f5c\u5e94\u8be5\u662fq[p[i]]\n\t\tif(q[p[i]].op == 2) { // \u67e5\u8be2\u64cd\u4f5c\n\t\t\tif(querytree(q[p[i]].x) == cnt) // \u6570\u91cf\u76f8\u540c\uff0c\u8fdb\u5165\u5de6\u4fa7\u9012\u5f52\uff08\u6b64\u5904\u7ef4\u62a4\u65b9\u6cd5\u5373\u4e3a\u6587\u4e2d\u6240\u8bf4\u7684\u6811\u4e0a\u5dee\u5206\n\t\t\t\tlft.push_back(p[i]);\n\t\t\telse rgt.push_back(p[i]); // \u8fdb\u5165\u53f3\u4fa7\u9012\u5f52\n\t\t}\n\t\telse { // \u4fee\u6539\u64cd\u4f5c\n\t\t\tif(q[p[i]].w > mid) { // \u53ea\u4fee\u6539\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8emid\u7684\u8bf7\u6c42\n\t\t\t\tint t;\n\t\t\t\tif(q[p[i]].op == 0) t = 1; else t = -1; // \u53d6\u6d88\u4e00\u6761\u8bf7\u6c42\u548c\u52a0\u5165\u4e00\u6761\u8bf7\u6c42\u6b63\u597d\u76f8\u53cd\n\t\t\t\tcnt += t; // \u591a\u4e86/\u5c11\u4e86\u4e00\u6761\u91cd\u8981\u5ea6\u5927\u4e8e\u7b49\u4e8emid\u7684\u8bf7\u6c42\n\t\t\t\tupdatecounter(q[p[i]].u, q[p[i]].v, t);\n\t\t\t\trgt.push_back(p[i]);\n\t\t\t}\n\t\t\telse lft.push_back(p[i]);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < p.size(); ++ i) { // \u65b9\u4fbf\u4e0b\u6b21\u4fee\u6539\uff08\u8ba9\u6811\u72b6\u6570\u7ec4\u6e05\u96f6\uff0c\u4e0e\u4e0a\u9762\u90a3\u6bb5\u4ee3\u7801\u6b63\u597d\u76f8\u53cd\uff09\n\t\tif(q[p[i]].op == 2) continue;\n\t\tif(q[p[i]].w > mid) {\n\t\t\tint t;\n\t\t\tif(q[p[i]].op == 0) t = -1; else t = 1;\n\t\t\tupdatecounter(q[p[i]].u, q[p[i]].v, t);\n\t\t}\n\t}\n\t\n\tsplit(l, mid, lft); // \u9012\u5f52 [l, mid]\n\tsplit(mid + 1, r, rgt); // \u9012\u5f52 [mid + 1, r]\n}\n\nint main () {\n\n\tn = read(); m = read();\n\tfor(int i = 1; i < n; ++ i) {\n\t\tint u, v;\n\t\tu = read(); v = read();\n\t\tadd(u, v); add(v, u);\n\t}\n\t\n\tdfs1(1, 0);\n\tdfs2(1, 1); // \u6811\u94fe\u5256\u5206\n\n\tfor(int i = 1; i <= m; ++ i) { // \u79bb\u7ebf\u5904\u7406\n\t\tint op = read();\n\t\tq[i].op = op;\n\t\tif(op == 0) {\n\t\t\tint u, v, w;\n\t\t\tu = read(), v = read(); w = read();\n\t\t\tq[i].u = u; q[i].v = v; q[i].w = w;\n\t\t}\n\t\telse if(op == 1) {\n\t\t\tint k = read();\n\t\t\tq[i].u = q[k].u; q[i].v = q[k].v; q[i].w = q[k].w; \n\t\t}\n\t\telse {\n\t\t\tint x;\n\t\t\tx = read();\n\t\t\tq[i].x = x;\n\t\t}\n\t}\n\t\n\tvector <int> f;\n\tfor(int i = 1; i <= m; ++ i) f.push_back(i); // \u5904\u7406 1 ~ m \u7684\u64cd\u4f5c \uff08\u7f16\u53f7\uff09\n\tsplit(-1, (int)(1e9), f); // \u5de6\u8fb9\u754c\u4e3a -1\n\t\n\tfor(int i = 1; i <= m; ++ i) if(q[i].op == 2) printf(\"%d\\n\", q[i].ans);\n\t\n\treturn 0;\n}\n```",
        "postTime": 1609948955,
        "uid": 358957,
        "name": "fhqTreap",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "# \u9898\u76ee\n\n&emsp;&emsp;[luogu](https://www.luogu.com.cn/problem/P3250).\n\n# \u9898\u89e3\n\n&emsp;&emsp;~~%%%yyb~~\n\n&emsp;&emsp;\u6811\u5256 + \u53cc\u5806 trick\u3002\n\n&emsp;&emsp;\u65e2\u7136\u201c\u4ea4\u4e92\u8bf7\u6c42\u201d\u51fa\u73b0\u5728\u8def\u5f84\u4e0a\uff0c\u8be2\u95ee\u53c8\u4f1a\u7834\u574f\u8def\u5f84\uff0c\u90a3\u4e48\u6211\u4eec\u53cd\u5176\u9053\u800c\u884c\u4e4b\uff1a\u628a\u4ea4\u4e92\u8bf7\u6c42\u6302\u5728**\u9664\u8def\u5f84\u4ee5\u5916\u7684\u6240\u6709\u7ed3\u70b9**\u4e0a\u3002\n\n&emsp;&emsp;\u518d\u56e0\u4e3a\u6d89\u53ca\u5230\u6c42\u6700\u5927\u503c\u4ee5\u53ca\u5220\u9664\u5143\u7d20\uff0c\u4e0d\u96be\u8054\u60f3\u5230\u4e00\u4e2a trick\uff1a\u7ef4\u62a4\u4e24\u4e2a\u5806\uff0c\u4e00\u4e2a\u5806\u6807\u8bb0\u73b0\u6709\u5143\u7d20\uff08\u5305\u62ec\u4e00\u4e9b\u88ab\u6807\u8bb0\u5220\u9664\u7684\u5143\u7d20\uff09\uff0c\u53e6\u4e00\u4e2a\u5806\u7ef4\u62a4\u5220\u9664\u6807\u8bb0\u3002\u5728\u6700\u5927\u503c\u65f6\uff0c\u5148\u540c\u6b65\u5f39\u51fa\u4e24\u4e2a\u5806\u7684\u5806\u9876\u5143\u7d20\u76f4\u5230\u4e24\u4e2a\u5806\u5806\u9876\u4e0d\u540c\uff0c\u6b64\u65f6\u7b2c\u4e00\u4e2a\u5806\u7684\u5806\u9876\u5c31\u662f\u672a\u88ab\u5220\u9664\u7684\u6700\u5927\u503c\u3002\n\n&emsp;&emsp;\u63a5\u7740\uff0c\u81ea\u7136\u5730\u6811\u5256\uff1a\u7ef4\u62a4\u4e00\u9897\u7ebf\u6bb5\u6811\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u662f\u5982\u4e0a\u6587\u7684\u4e00\u4e2a\u53cc\u5806\uff0c\u8868\u793a**\u5b8c\u5168\u8986\u76d6\u8be5\u533a\u95f4\u7684\u4ea4\u4e92\u4fe1\u606f**\u3002\u66f4\u65b0\u65f6\u5411\u6240\u6709 **$dfn$ \u672a\u88ab\u8986\u76d6\u7684\u70b9\u63d2\u5165\u4ea4\u4e92\u4fe1\u606f**\uff1b\u67e5\u8be2\u65f6\u5355\u70b9\u67e5\u8be2\u5373\u53ef\u3002\n## \u4ee3\u7801\n```cpp\n#include <queue>\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\ninline int rint () {\n\tint x = 0, f = 1; char s = getchar ();\n\tfor ( ; s < '0' || '9' < s; s = getchar () ) f = s == '-' ? -f : f;\n\tfor ( ; '0' <= s && s <= '9'; s = getchar () ) x = x * 10 + ( s ^ '0' );\n\treturn x * f;\n}\n\ntemplate<typename Tp>\ninline void wint ( Tp x ) {\n\tif ( x < 0 ) putchar ( '-' ), x = ~ x + 1;\n\tif ( 9 < x ) wint ( x / 10 );\n\tputchar ( x % 10 ^ '0' );\n}\n\nconst int MAXN = 1e5, MAXM = 2e5;\nint n, m, indx, ecnt, head[MAXN + 5];\nint dep[MAXN + 5], fa[MAXN + 5], siz[MAXN + 5], son[MAXN + 5];\nint dfn[MAXN + 5], top[MAXN + 5];\nstd :: pair<int, int> cover[MAXN + 5];\n\nstruct MultiPriorityQueue {\nprivate:\n\tstd :: priority_queue<int> ele, rem;\n\npublic:\n\tinline int top () {\n\t\tfor ( ; ! rem.empty () && ! ele.empty () && ele.top () == rem.top (); ele.pop (), rem.pop () );\n\t\treturn ele.empty () ? -1 : ele.top ();\n\t}\n\tinline void insert ( const int val ) { ele.push ( val ); }\n\tinline void erase ( const int val ) { rem.push ( val ); }\n};\n\nclass SegmentTree {\nprivate:\n\tMultiPriorityQueue mpq[MAXN << 2];\n\npublic:\n\tinline void update ( const int rt, const int ul, const int ur, const int l, const int r, const int val, const bool opt ) {\n\t\tif ( ul <= l && r <= ur ) return opt ? mpq[rt].insert ( val ) : mpq[rt].erase ( val );\n\t\tint mid = l + r >> 1;\n\t\tif ( ul <= mid ) update ( rt << 1, ul, ur, l, mid, val, opt );\n\t\tif ( mid < ur ) update ( rt << 1 | 1, ul, ur, mid + 1, r, val, opt );\n\t}\n\tinline int query ( const int rt, const int x, const int l, const int r ) {\n\t\tif ( l == r ) return mpq[rt].top ();\n\t\tint mid = l + r >> 1, tmp = mpq[rt].top ();\n\t\tif ( x <= mid ) return std :: max ( tmp, query ( rt << 1, x, l, mid ) );\n\t\telse return std :: max ( tmp, query ( rt << 1 | 1, x, mid + 1, r ) );\n\t}\n} st;\n\nstruct Edge { int to, nxt; } graph[MAXN * 2 + 5];\n\nstruct Task { int a, b, v; } task[MAXM + 5];\n\ninline void link ( const int s, const int t ) { graph[++ ecnt] = { t, head[s] }, head[s] = ecnt; }\n\ninline void DFS1 ( const int u, const int f ) {\n\tdep[u] = dep[fa[u] = f] + 1, siz[u] = 1;\n\tfor ( int i = head[u], v; i; i = graph[i].nxt ) {\n\t\tif ( ( v = graph[i].to ) ^ f ) {\n\t\t\tDFS1 ( v, u ), siz[u] += siz[v];\n\t\t\tif ( siz[son[u]] < siz[v] ) son[u] = v;\n\t\t}\n\t}\n}\n\ninline void DFS2 ( const int u, const int tp ) {\n\tdfn[u] = ++ indx, top[u] = tp;\n\tif ( son[u] ) DFS2 ( son[u], tp );\n\tfor ( int i = head[u], v; i; i = graph[i].nxt ) {\n\t\tif ( ( v = graph[i].to ) ^ fa[u] && v ^ son[u] ) {\n\t\t\tDFS2 ( v, v );\n\t\t}\n\t}\n}\n\ninline void update ( int x, int y, const int val, const int opt ) {\n\tint sec = 0;\n\twhile ( top[x] ^ top[y] ) {\n\t\tif ( dep[top[y]] > dep[top[x]] ) x ^= y ^= x ^= y;\n\t\tcover[++ sec] = { dfn[top[x]], dfn[x] };\n\t\tx = fa[top[x]];\n\t}\n\tif ( dep[y] > dep[x] ) x ^= y ^= x ^= y;\n\tcover[++ sec] = { dfn[y], dfn[x] };\n\tstd :: sort ( cover + 1, cover + sec + 1 );\n\tfor ( int i = 1, l = 0; i <= sec; l = cover[i ++].second ) {\n\t\tif ( l + 1 != cover[i].first ) {\n\t\t\tst.update ( 1, l + 1, cover[i].first - 1, 1, n, val, opt );\n\t\t}\n\t}\n\tif ( cover[sec].second ^ n ) st.update ( 1, cover[sec].second + 1, n, 1, n, val, opt );\n}\n\nint main () {\n\tn = rint (), m = rint ();\n\tfor ( int i = 1, u, v; i < n; ++ i ) {\n\t\tu = rint (), v = rint ();\n\t\tlink ( u, v ), link ( v, u );\n\t}\n\tDFS1 ( 1, 0 ), DFS2 ( 1, 1 );\n\tfor ( int i = 1, opt, a, b, v; i <= m; ++ i ) {\n\t\topt = rint (), a = rint ();\n\t\tif ( ! opt ) {\n\t\t\tb = rint (), v = rint ();\n\t\t\ttask[i] = { a, b, v };\n\t\t\tupdate ( a, b, v, true );\n\t\t}\n\t\telse if ( opt & 1 ) update ( task[a].a, task[a].b, task[a].v, false );\n\t\telse wint ( st.query ( 1, dfn[a], 1, n ) ), putchar ( '\\n' );\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1591160920,
        "uid": 123807,
        "name": "Rainybunny",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "### [\u5f00\u5934\u5c0f\u5e7f\u544a\uff1a\u81ea\u5df1\u505a\u7684\u4e00\u4e2a\u6a21\u677f\u5e93OwO](https://www.luogu.org/blog/29354/Templet)\n------------\n### \u601d\u8def:\n~~\u4e00\u773c\u8fc7\u53bb\u5c31\u662f\u4e00\u9053\u6811\u5256\u9898\u3002~~\n\n\u8bfb\u5b8c\u9898\u76ee\u6211\u4eec\u53d1\u73b0\u5176\u5b9e\u201c\u4ea4\u4e92\u8bf7\u6c42\u201d\u8d21\u732e\u7684\u5e76\u4e0d\u662f\u8bf7\u6c42\u8def\u7ebf\u4e0a\u7684\u70b9\uff0c\u800c\u662f\u4ed6\u7684\u8865\u96c6\u3002\u8fd9\u5f88\u5bb9\u6613\uff0c\u6211\u4eec\u5728\u8be2\u95ee\u7684\u65f6\u5019\u8bb0\u4e0b\u6811\u5256\u7684\u81f3\u591a$log$\u4e2a\u533a\u95f4\uff0c\u6309\u7167\u5de6\u53f3\u7aef\u70b9\u6392\u5e8f\u90fd\u53ef\u4ee5\uff08\u56e0\u4e3a\u8fd9\u4e9b\u533a\u95f4\u80af\u5b9a\u4e0d\u4f1a\u76f8\u4ea4\uff09\uff0c\u7136\u540e\u53d6\u8865\u96c6\u533a\u95f4\u5c31\u597d\u4e86\uff1a\n\n\u8bbe\u6211\u4eec\u7684\u533a\u95f4\u957f\u8fd9\u4e2a\u6837\u5b50\uff1a$[x_i,y_i]$\uff0c\u90a3\u4e48$[y_{i-1}+1,x_{i}-1]$\u5c31\u662f\u6211\u4eec\u7684\u8865\u96c6\u533a\u95f4\u3002\u7c7b\u4f3c\u7684\uff0c$[y_{i}+1,x_{i+1}-1]$\u5f53\u7136\u4e5f\u662f\u5566~\uff08\u6ce8\u610f1\u548cn\u7684\u5904\u7406\uff0c\u4e5f\u5c31\u662f\u8fb9\u754c\uff09\n\n\u90a3\u4e48\u73b0\u5728\u6211\u4eec\u5df2\u7ecf\u4f1a\u4fee\u6539\u4e86\uff0c\u5982\u679c\u4e0d\u9700\u8981\u6062\u590d\u4fee\u6539\u7684\u8bdd\uff0c\u90a3\u4e48\u4e0a\u4e2a\u6700\u5927\u503c\u7ebf\u6bb5\u662f\u5c31\u7b97\u7ed3\u675f\u4e86\uff0c\u4f46\u662f\u73b0\u5728\u8981\u6062\u590d\u4fee\u6539\u600e\u4e48\u529e\uff1f\u6211\u4eec\u80af\u5b9a\u4e0d\u80fd\u5728\u6700\u5927\u503c\u7ebf\u6bb5\u6811\u4e0a\u52a8\u624b\uff0c\u5426\u5219\u5f53\u524d\u7684\u6700\u5927\u503c\u88ab\u6062\u590d\u4e86\u4ee5\u540e\u5c31\u4e0d\u662f\u518d\u5c0f\u4e00\u70b9\u7684\u503c\u4e86\uff0c\u56e0\u4e3a\u5b83\u6ca1\u6709\u8bb0\u5f55\u529f\u80fd\u3002\n\n\u6211\u4eec\u8003\u8651\u80fd\u4e0d\u80fd\u7528\u7ebf\u6bb5\u6811\u5957\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u8bb0\u5f55\uff1a\u5e73\u8861\u6811\u662f\u6211\u7b2c\u4e00\u4e2a\u60f3\u5230\u7684\u3002\u7528\u5e73\u8861\u6811\u50a8\u5b58\u7ebf\u6bb5\u6811\u533a\u95f4\u5bf9\u5e94\u62e5\u6709\u7684\u503c\u3002\n\n\u8bbe\u6211\u4eec\u7684\u7ebf\u6bb5\u6811\u533a\u95f4\u957f\u8fd9\u4e2a\u6837\u5b50\uff1a$[x,y]$\uff0c\u90a3\u4e48\u5f53\u4fee\u6539\u533a\u95f4$[l,r]$\u5305\u542b\u5b83\u7684\u65f6\u5019\uff0c\u6309\u7167\u6211\u4eec\u505a\u5176\u4ed6\u533a\u95f4\u4fee\u6539\u7684\u7ebf\u6bb5\u6811\u7684\u60ef\u4f8b\uff0c\u662f\u5e94\u8be5\u4fee\u6539\u6743\u503c\u5e76\u6253\u6807\u8bb0\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u8981\u6253\u6807\u8bb0\u5c31\u8fd8\u5f97\u5f00\u6570\u636e\u7ed3\u6784\u5b58\u50a8\u6807\u8bb0\uff0c\u53c8\u8981\u4e0b\u653e\u975e\u5e38\u9ebb\u70e6\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u6807\u8bb0\u6c38\u4e45\u5316\u907f\u514d\u8fd9\u6837\u7684\u9ebb\u70e6\uff0c\u90a3\u4e48\u5e73\u8861\u6811\u4e5f\u5c31\u662f\u6211\u4eec\u7684\u6807\u8bb0\u6c60\u4e86\uff08\u59d1\u4e14\u8fd9\u4e48\u53eb\u5427\uff09\u4e86\u3002\u6dfb\u52a0\u5220\u9664\u90fd\u662f\u4e00\u6837\u7684\uff0c\u9047\u5230\u533a\u95f4\u5305\u542b\u5c31\u64cd\u4f5c\u5bf9\u5e94\u7684\u5e73\u8861\u6811\u3002\n\n\u8981\u67e5\u8be2\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u662f\u5355\u70b9\u7684\uff0c\u6211\u4eec\u76f4\u63a5\u4ece\u6811\u6839\u4e00\u8def\u8d70\u4e0b\u6765\uff0c\u9047\u5230\u4e00\u4e2a\u533a\u95f4\u5c31\u5728\u5e73\u8861\u6811\u4e0a\u67e5\u8be2\u4e00\u4e0b\u6700\u5927\u503c\uff08\u8bb0\u5f97\u8fd8\u6709-1\u8fd9\u56de\u4e8b\uff09\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(nlog^3n)$\uff0c\u5e94\u8be5\u662f\u53ef\u4ee5\u5361\u8fc7\u53bb\u7684\u5427\u3002\u3002\u3002\u3002\uff08to be continue\n\n## Code\n```cpp\n// luogu-judger-enable-o2\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1e6 + 5, MAXM = MAXN << 1, MAXT = 5e7 + 5;\n\nint l[MAXT], r[MAXT], heap[MAXT], val[MAXT], sz[MAXT], root[MAXT], tot;\nstruct FHQTreap\n{\n    inline void Update(int x)\n    {\n        sz[x] = sz[l[x]] + sz[r[x]] + 1;\n        return;\n    }\n\n    inline int Merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (heap[x] < heap[y])\n            return r[x] = Merge(r[x], y), Update(x), x;\n        return l[y] = Merge(x, l[y]), Update(y), y;\n    }\n\n    inline void Split(int x, int key, int &u, int &v)\n    {\n        if (!x)\n        {\n            u = v = 0;\n            return;\n        }\n\n        if (val[x] <= key)\n            u = x, Split(r[x], key, r[u], v);\n        else\n            v = x, Split(l[x], key, u, l[v]);\n        Update(x);\n\n        return;\n    }\n\n    inline int Create(int key)\n    {\n        heap[++tot] = rand(), val[tot] = key, sz[tot] = 1;\n        return tot;\n    }\n\n    int x, y, z;\n\n    inline void Insert(int &root, int key)\n    {\n        Split(root, key, x, y);\n        root = Merge(x, Merge(Create(key), y));\n        return;\n    }\n\n    inline void Delete(int &root, int key)\n    {\n        Split(root, key, x, z);\n        Split(x, key - 1, x, y);\n        y = Merge(l[y], r[y]);\n        root = Merge(x, Merge(y, z));\n        return;\n    }\n\n    inline int Top(int x)\n    {\n        while (r[x])\n            x = r[x];\n        return val[x];\n    }\n\n} FT;\n\n#define mid ((x + y) >> 1)\n#define lson (pos << 1)\n#define rson (pos << 1 | 1)\n\nstruct SegmentTree\n{\n    inline void Update(int x, int y, int pos, int l, int r, int key, int opt)\n    {\n        if (y < l || x > r)\n            return;\n        if (l <= x && y <= r)\n        {\n            if (opt)\n                FT.Insert(root[pos], key);\n            else\n                FT.Delete(root[pos], key);\n\n            return;\n        }\n\n        Update(x, mid, lson, l, r, key, opt), Update(mid + 1, y, rson, l, r, key, opt);\n        return;\n    }\n\n    inline int Query(int x, int y, int pos, int p)\n    {\n        register int ans = FT.Top(root[pos]);\n\n        if (x != y)\n        {\n            if (p <= mid)\n                return max(ans, Query(x, mid, lson, p));\n            else\n                return max(ans, Query(mid + 1, y, rson, p));\n        }\n\n        return ans;\n    }\n\n} ST;\n\nint head[MAXM], nxt[MAXM], v[MAXM], cnt;\n\nint dad[MAXN], son[MAXN], siz[MAXN], depth[MAXN], rt;\nint id[MAXN], rak[MAXN], top[MAXN], dfx;\n\nint tx[MAXN], ty[MAXN], tk[MAXN];\n\nint n, m;\n\ninline void Addline(int x, int y)\n{\n    v[cnt] = y;\n    nxt[cnt] = head[x], head[x] = cnt++;\n    return;\n}\n\ninline void Make(int x, int fa)\n{\n    dad[x] = fa, depth[x] = depth[fa] + 1, siz[x] = 1;\n\n    for (register int i = head[x]; ~i; i = nxt[i])\n        if (v[i] != fa)\n        {\n            Make(v[i], x);\n            siz[x] += siz[v[i]];\n\n            if (siz[son[x]] < siz[v[i]])\n                son[x] = v[i];\n        }\n\n    return;\n}\n\ninline void Mark(int x, int tp)\n{\n    top[x] = tp, id[x] = ++dfx, rak[id[x]] = x;\n\n    if (son[x])\n        Mark(son[x], tp);\n\n    for (register int i = head[x]; ~i; i = nxt[i])\n        if (v[i] != dad[x] && v[i] != son[x])\n            Mark(v[i], v[i]);\n\n    return;\n}\n\nstruct Interval\n{\n    int x, y;\n} ITV[MAXN];\n\ninline bool Compare(Interval a, Interval b)\n{\n    return a.x < b.x;\n}\n\ninline void Update(int x, int y, int key, int opt)\n{\n    register int tail = 0;\n    while (top[x] != top[y])\n    {\n        if (depth[top[x]] < depth[top[y]])\n            swap(x, y);\n\n        ITV[++tail].x = id[top[x]];\n        ITV[tail].y = id[x];\n        x = dad[top[x]];\n    }\n\n    if (id[x] > id[y])\n        swap(x, y);\n    ITV[++tail].x = id[x];\n    ITV[tail].y = id[y];\n\n    sort(ITV + 1, ITV + tail + 1, Compare);\n\n    register int pos = 1;\n    for (register int i = 1; i <= tail; i++)\n    {\n        if (pos <= ITV[i].x - 1)\n            ST.Update(1, n, 1, pos, ITV[i].x - 1, key, opt);\n        pos = ITV[i].y + 1;\n    }\n    if (pos <= n)\n        ST.Update(1, n, 1, pos, n, key, opt);\n\n    return;\n}\n\ninline int Read()\n{\n    register char c = getchar();\n    while (c < '0' || c > '9')\n        c = getchar();\n\n    register int x = 0;\n    while (c >= '0' && c <= '9')\n        x = (x << 3) + (x << 1) + c - '0', c = getchar();\n\n    return x;\n}\n\nsigned main(void)\n{\n    memset(head, -1, sizeof head);\n    val[0] = -1;\n\n    cin >> n >> m;\n    for (register int i = 1; i < n; i++)\n    {\n        register int x = Read(), y = Read();\n        Addline(x, y), Addline(y, x);\n    }\n\n    Make(rt = rand() % n + 1, 0), Mark(rt, rt);\n\n    for (register int i = 1, opt, x, y, k, t; i <= m; i++)\n    {\n        opt = Read();\n\n        if (opt == 0)\n        {\n            x = Read(), y = Read(), k = Read();\n            Update(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;\n        }\n\n        if (opt == 1)\n        {\n            t = Read();\n            Update(tx[t], ty[t], tk[t], 0);\n        }\n\n        if (opt == 2)\n        {\n            x = Read();\n            printf(\"%d\\n\", ST.Query(1, n, 1, id[x]));\n        }\n    }\n\n    return 0;\n}\n\n```\n\n\u7801\u4e86250+\u884c\u7684\u6811\u5256+\u6811\u5957\u6811\uff0c\u4e00\u4ea4\u7adf\u7136T\u4e86qwq\u3002\n\u5361\u4e86\u5361\u5e38\u4e5f\u8fc7\u4e0d\u53bbqwq\u3002\n\u7136\u540e\u610f\u8bc6\u5230FHQTreap\u6216\u8bb8\u5e38\u6570\u592a\u5927\u4e86\uff0c\u52a0\u4e0a\u672c\u8eab\u5c31\u662f3\u4e2a$log$\u3002\u3002\u3002\n\n~~\u6211\u4eec\u6253\u5f00\u4e86\u9898\u89e3~~\u53d1\u73b0\u5e76\u4e0d\u9700\u8981\u7528\u4e00\u9897\u5e73\u8861\u6811\u7ef4\u62a4\uff0c\u628a\u5e73\u8861\u6811\u6362\u6210\u4e24\u4e2a\u5927\u6839\u5806\uff0c\u4e00\u4e2a\u653e\u6dfb\u52a0\u7684\u503c\uff0c\u4e00\u4e2a\u653e\u5220\u9664\u7684\u503c\u3002\u67e5\u8be2\u7684\u65f6\u5019\u5148\u628a\u4e24\u4e2a\u5806\u7684\u5806\u9876\u5bf9\u6bd4\u4e00\u4e9b\uff0c\u5982\u679c\u76f8\u540c\u8bf4\u660e\u8fd9\u4e2a\u503c\u88ab\u5220\u6389\u4e86\uff0c\u90a3\u4e48\u4e24\u4e2a\u5806\u90fd\u5f39\u6389\u3002\u4e0d\u76f8\u7b49\u65f6\uff0c\u6dfb\u52a0\u7684\u90a3\u4e2a\u5806\u7684\u5806\u9876\u5c31\u662f\u6700\u5927\u503c\u4e86\uff08\u8981\u6ce8\u610f\u4e00\u4e0b\u5806\u7a7a\u7684\u95ee\u9898\uff09\u3002\n\n\u867d\u7136\u590d\u6742\u5ea6\u6ca1\u6709\u53d8\uff0c\u4f46\u662f\u5e38\u6570\u5c0f\u4e86\u5f88\u591a\uff0c\u4e00\u53d1\u4e0d\u5f00O2\uff08\u5b9e\u9645\u4e0a\u662f\u5fd8\u4e86XD\uff09\u5c31\u8dd1\u8fc7\u4e86\uff01\uff08\u6700\u5927\u70b91600ms\uff09\n\n\u8fd9\u544a\u8bc9\u6211\u4eecFHQTreap\u7684\u5e38\u6570\u662f\u6709\u591a\u5927qwq\n\n\u5f53\u7136\u7801\u7684\u5feb\u7684\u795e\u7287\u4eec\u53ef\u4ee5\u8bd5\u8bd5\u5957\u4e00\u4e9b\u5e38\u6570\u5c0f\u7684\u5e73\u8861\u6811qwq\n\n## Code\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5, MAXM = MAXN << 1;\n\n#define mid ((x + y) >> 1)\n#define lson (pos << 1)\n#define rson (pos << 1 | 1)\n\npriority_queue<int> I[MAXN << 2], D[MAXN << 2];\n\nstruct SegmentTree\n{\n    inline void Update(int x, int y, int pos, int l, int r, int key, int opt)\n    {\n        if (y < l || x > r)\n            return;\n        if (l <= x && y <= r)\n        {\n            if (opt)\n                I[pos].push(key);\n            else\n                D[pos].push(key);\n\n            return;\n        }\n\n        Update(x, mid, lson, l, r, key, opt), Update(mid + 1, y, rson, l, r, key, opt);\n        return;\n    }\n\n    inline int Query(int x, int y, int pos, int p)\n    {\n        while (!I[pos].empty() && !D[pos].empty() && I[pos].top() == D[pos].top())\n            I[pos].pop(), D[pos].pop();\n        int ans = I[pos].empty() ? -1 : I[pos].top();\n\n        if (x != y)\n        {\n            if (p <= mid)\n                return max(ans, Query(x, mid, lson, p));\n            else\n                return max(ans, Query(mid + 1, y, rson, p));\n        }\n\n        return ans;\n    }\n\n} ST;\n\nint head[MAXM], nxt[MAXM], v[MAXM], cnt;\n\nint dad[MAXN], son[MAXN], siz[MAXN], depth[MAXN], rt;\nint id[MAXN], rak[MAXN], top[MAXN], dfx;\n\nint tx[MAXN], ty[MAXN], tk[MAXN];\n\nint n, m;\n\ninline void Addline(int x, int y)\n{\n    v[cnt] = y;\n    nxt[cnt] = head[x], head[x] = cnt++;\n    return;\n}\n\ninline void Make(int x, int fa)\n{\n    dad[x] = fa, depth[x] = depth[fa] + 1, siz[x] = 1;\n\n    for (register int i = head[x]; ~i; i = nxt[i])\n        if (v[i] != fa)\n        {\n            Make(v[i], x);\n            siz[x] += siz[v[i]];\n\n            if (siz[son[x]] < siz[v[i]])\n                son[x] = v[i];\n        }\n\n    return;\n}\n\ninline void Mark(int x, int tp)\n{\n    top[x] = tp, id[x] = ++dfx, rak[id[x]] = x;\n\n    if (son[x])\n        Mark(son[x], tp);\n\n    for (register int i = head[x]; ~i; i = nxt[i])\n        if (v[i] != dad[x] && v[i] != son[x])\n            Mark(v[i], v[i]);\n\n    return;\n}\n\nstruct Interval\n{\n    int x, y;\n} ITV[MAXN];\n\ninline bool Compare(Interval a, Interval b)\n{\n    return a.x < b.x;\n}\n\ninline void Update(int x, int y, int key, int opt)\n{\n    register int tail = 0;\n    while (top[x] != top[y])\n    {\n        if (depth[top[x]] < depth[top[y]])\n            swap(x, y);\n\n        ITV[++tail].x = id[top[x]];\n        ITV[tail].y = id[x];\n        x = dad[top[x]];\n    }\n\n    if (id[x] > id[y])\n        swap(x, y);\n    ITV[++tail].x = id[x];\n    ITV[tail].y = id[y];\n\n    sort(ITV + 1, ITV + tail + 1, Compare);\n\n    register int pos = 1;\n    for (register int i = 1; i <= tail; i++)\n    {\n        if (pos <= ITV[i].x - 1)\n            ST.Update(1, n, 1, pos, ITV[i].x - 1, key, opt);\n        pos = ITV[i].y + 1;\n    }\n    if (pos <= n)\n        ST.Update(1, n, 1, pos, n, key, opt);\n\n    return;\n}\n\ninline int Read()\n{\n    register char c = getchar();\n    while (c < '0' || c > '9')\n        c = getchar();\n\n    register int x = 0;\n    while (c >= '0' && c <= '9')\n        x = (x << 3) + (x << 1) + c - '0', c = getchar();\n\n    return x;\n}\n\nsigned main(void)\n{\n    memset(head, -1, sizeof head);\n\n    cin >> n >> m;\n    for (register int i = 1; i < n; i++)\n    {\n        register int x = Read(), y = Read();\n        Addline(x, y), Addline(y, x);\n    }\n\n    Make(rt = rand() % n + 1, 0), Mark(rt, rt);\n\n    for (register int i = 1, opt, x, y, k, t; i <= m; i++)\n    {\n        opt = Read();\n\n        if (opt == 0)\n        {\n            x = Read(), y = Read(), k = Read();\n            Update(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;\n        }\n\n        if (opt == 1)\n        {\n            t = Read();\n            Update(tx[t], ty[t], tk[t], 0);\n        }\n\n        if (opt == 2)\n        {\n            x = Read();\n            printf(\"%d\\n\", ST.Query(1, n, 1, id[x]));\n        }\n    }\n\n    return 0;\n}\n\n```\n\n",
        "postTime": 1544701212,
        "uid": 29354,
        "name": "CodyTheWolf",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u5f88\u4e45\u6ca1\u6253\u6574\u4f53\u4e8c\u5206\uff0c\u53d1\u73b0\u81ea\u5df1\u5c45\u7136\u6ca1\u6709\u5fd8\u8bb0\u2026\u2026\n\n\u8fd9\u91cc\u63d0\u4f9b\u4e00\u4e2a\u8dd1\u7684\u6bd4\u5927\u591a\u6570\u9898\u89e3\u5feb\u7684$\\operatorname{O(N\\ log^3\\ N)}$\u505a\u6cd5\u3002\n\n\u9996\u5148\u6811\u94fe\u5256\u5206\uff0c\u5c06\u94fe\u4e0a\u64cd\u4f5c\u8f6c\u5316\u4e3a\u5e8f\u5217\u64cd\u4f5c\u3002\u7531\u4e8e\u662f\u533a\u95f4\u4fee\u6539\u5355\u70b9\u67e5\u8be2\uff0c\u6240\u4ee5\u6211\u4eec\u7528\u6811\u72b6\u6570\u7ec4\u4ee3\u66ff\u7ebf\u6bb5\u6811\u3002\n\n\u5bf9\u4e8e$m$\u4e2a\u64cd\u4f5c\u6211\u4eec\u7528\u6574\u4f53\u4e8c\u5206\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u5927\u4e8e$mid$\u7684\u8bf7\u6c42\uff0c\u6211\u4eec\u5c06\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u6743\u503c\u52a0$1$\u3002\u540c\u7406\uff0c\u64a4\u56de\u64cd\u4f5c\u5c31\u662f\u51cf\u4e00\u3002\u67e5\u8be2\u65f6\uff0c\u67e5\u8be2\u8be5\u70b9\u7684\u6743\u503c\uff0c\u5982\u679c\u6743\u503c\u5c0f\u4e8e\u5f53\u524d\u6240\u6709\u5b58\u5728\u7684\u8bf7\u6c42\u6570\uff0c\u8bf4\u660e\u6709\u5927\u4e8e$mid$\u7684\u8bf7\u6c42\u4e0d\u7ecf\u8fc7\u8be5\u70b9\uff0c\u5c06\u5b83\u585e\u5230\u53f3\u8fb9\u3002\u5426\u5219\u5c06\u5b83\u585e\u5230\u5de6\u8fb9\u3002\n\n\u81f3\u4e8e\u5176\u4ed6\u7684\uff0c\u76f4\u63a5\u5957\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206+\u3010\u6a21\u677f\u3011\u6811\u72b6\u6570\u7ec42+\u3010\u6a21\u677f\u3011\u6574\u4f53\u4e8c\u5206\u3002\n\n\n\u6700\u540e\u8d34\u4e0b\u4ee3\u7801\u3002\n\n\n\u6811\u72b6\u6570\u7ec4\u3001\u6811\u5256\u3001\u4e8c\u5206\u7684\u5e38\u6570\u90fd\u5f88\u5c0f\uff0c\u6240\u4ee5\u5b9e\u8df5\u8bc1\u660e\u6548\u7387\u975e\u5e38\u4f18\u79c0[\u8bb0\u5f55](https://www.luogu.com.cn/record/34428938)\n\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define N 100005\n#define M 200005\nusing namespace std;\nint n,m,h[N],tot;\nstruct edge{\n\tint to,nxt;\n}e[N<<1];\nvoid add(int x,int y){\n\te[++tot].nxt=h[x];h[x]=tot;e[tot].to=y;\n}\nint idx,dfn[N],sz[N],son[N],top[N],fa[N],d[N];\nvoid dfs1(int x,int f){\n\tsz[x]=1;fa[x]=f;d[x]=d[f]+1;\n\tfor(int i=h[x];i;i=e[i].nxt)if(e[i].to^f){\n\t\tdfs1(e[i].to,x),sz[x]+=sz[e[i].to];\n\t\tif(sz[e[i].to]>sz[son[x]])son[x]=e[i].to;\n\t}\n}\nvoid dfs2(int x,int tp){\n\tdfn[x]=++idx;top[x]=tp;\n\tif(!son[x])return;\n\tdfs2(son[x],tp);\n\tfor(int i=h[x];i;i=e[i].nxt)if(e[i].to^fa[x]&&e[i].to^son[x])dfs2(e[i].to,e[i].to);\n}\nint c[N];\ninline void addval(int x,int y){\n\tfor(;x<=n;x+=x&-x)c[x]+=y;\n}\ninline int ask(int x){\n\tint sum=0;\n\tfor(;x;x-=x&-x)sum+=c[x];\n\treturn sum;\n}\ninline void change(int l,int r,int val){\n\taddval(l,val);addval(r+1,-val);\n}\ninline void modify(int x,int y,int val){\n\twhile(top[x]^top[y]){\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tchange(dfn[top[x]],dfn[x],val),x=fa[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tchange(dfn[x],dfn[y],val);\n}\nstruct node{\n\tint op,x,y,val;\n}a[M],lt[M],rt[M];\nint b[M],o[M],t,T,cnt,ans[M];\nvoid solve(int ls,int rs,int l,int r){\n\tif(l==r){\n\t\trep(i,ls,rs)if(a[i].op>0)ans[a[i].op]=l;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1,ll=0,rr=0,s=0;\n\trep(i,ls,rs){\n\t\tif(a[i].op>0){\n\t\t\tint sum=ask(dfn[a[i].x]);\n\t\t\tif(sum^s)rt[++rr]=a[i];else lt[++ll]=a[i];\n\t\t}\n\t\telse if(a[i].op){\n\t\t\tif(a[i].val>mid)modify(a[i].x,a[i].y,-1),rt[++rr]=a[i],s--;\n\t\t\telse lt[++ll]=a[i];\n\t\t}\n\t\telse{\n\t\t\tif(a[i].val>mid)modify(a[i].x,a[i].y,1),rt[++rr]=a[i],s++;\n\t\t\telse lt[++ll]=a[i];\n\t\t}\n\t}\n\trep(i,1,rr)if(rt[i].op==0){\n\t\tif(rt[i].val>mid)modify(rt[i].x,rt[i].y,-1);\n\t}\n\telse if(rt[i].op==-1&&rt[i].val>mid)modify(rt[i].x,rt[i].y,1);\n\trep(i,1,ll)a[ls+i-1]=lt[i];rep(i,1,rr)a[ls+ll+i-1]=rt[i];\n\tsolve(ls,ls+ll-1,l,mid);solve(ls+ll,rs,mid+1,r);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint x,y;\n\trep(i,1,n-1)scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n\tdfs1(1,0);dfs2(1,1);\n\t\n\trep(i,1,m){\n\t\tscanf(\"%d%d\",&a[i].op,&a[i].x);\n\t\tif(a[i].op==0)scanf(\"%d%d\",&a[i].y,&a[i].val),o[++t]=a[i].val;\n\t}\n\tsort(o+1,o+t+1);\n\trep(i,1,t)if(i==1||o[i]^o[i-1])b[++T]=o[i];\n\trep(i,1,m){\n\t\tif(a[i].op==0)a[i].val=lower_bound(b+1,b+T+1,a[i].val)-b;\n\t\telse if(a[i].op==1)a[i]=a[a[i].x],a[i].op=-1;\n\t\telse a[i].op=++cnt;\n\t}\n\tsolve(1,m,0,T);\n\tb[0]=-1;\n\trep(i,1,cnt)printf(\"%d\\n\",b[ans[i]]);\n\treturn 0;\n} \n```",
        "postTime": 1592230415,
        "uid": 119261,
        "name": "7KByte",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "woc\u56fd\u5e86\u4f5c\u4e1aTMD\u7ec8\u4e8e\u5199\u5b8c\u4e86\uff0c\u7136\u800c\u660e\u5929\u6211\u4eec\u73ed\u5c31\u5f00\u5b66\u4e86233\n\n\u8fd9\u9898\u5176\u5b9e\u662f\u6628\u5929\u5199\u7684\uff0c\u7136\u540e\u6628\u5929\u665a\u4e0a\u88abAtcoder\u7684\u4e00\u9053\u9898\u5361\u4f4f\u4e86\u5f88\u4e45~~\uff08MD\u662fB\u9898\uff09~~\u6240\u4ee5\u5c31\u6ca1\u5199\u535a\u5ba2\n\n\u597d\u5427\u6211\u4eec\u6765\u770b\u8fd9\u9053\u9898\uff0c\u7406\u89e3\u9898\u610f\u4ee5\u540e\u76f8\u4fe1\u4f60\u4f1a\u4ee5\u4e3a\u6211\u53c8\u518d\u5199**\u7ebf\u6bb5\u6811\u5206\u6cbb**\u7136\u540e\u7801\u51fa\u4e00\u4e2a\u4e09\u4e2a$\\log$\u7684\u4e1c\u897f\n\n\u5927\u81f4\u8bb2\u4e00\u4e0b\u54c8\uff0c\u8fd8\u662f\u5957\u8def\u5730\u7ef4\u62a4\u6570\u636e\u4ea4\u4e92\u51fa\u73b0\u7684\u65f6\u95f4\u533a\u95f4\u5728\u7ebf\u6bb5\u6811\u4e0a\uff0c\u7136\u540e\u8003\u8651\u6811\u5256\u51fa\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u533a\u95f4\uff08$\\log n$\u4e2a\uff09\uff0c\u7136\u540e\u5b83\u4eec\u7684\u8865\u96c6\u5c31\u662f\u5408\u6cd5\u7684\u533a\u95f4\uff0c\u7136\u540e\u518d\u62ff\u4e00\u4e2a**\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811**\u7ef4\u62a4\u91cc\u9762\u7684\u6700\u503c\u5373\u53ef\uff0c\u590d\u6742\u5ea6$O(n\\log^3 n)$\uff0c\u4ee3\u7801\u6781\u5176\u96be\u5199\uff08\u6ca1\u5199\uff09\n\n\u90a3\u4e48\u6211\u4eec\u8003\u8651\u6709\u6ca1\u6709\u4ec0\u4e48\u597d\u4e00\u70b9\u7684\u5199\u6cd5\uff0c\u4ed4\u7ec6\u89c2\u5bdf\u53ef\u4ee5\u53d1\u73b0\u7b54\u6848\u5177\u6709**\u4e8c\u5206\u6027\u8d28**\n\n\u5373\u5bf9\u4e8e\u4e00\u4e2a\u8be2\u95ee\u7684\u4e8c\u5206\u7684\u503c$mid$\uff0c\u5982\u679c\u6240\u6709\u6743\u503c$\\ge mid$\u7684\u8def\u5f84\u90fd\u7ecf\u8fc7\u4e86\u8fd9\u4e2a\u70b9\uff0c\u90a3\u4e48$mid$\u5c31\u4e0d\u5408\u6cd5\uff0c\u5426\u5219\u5c31\u662f\u53ef\u884c\u7684\n\n\u7136\u540e\u6211\u4eec\u53c8\u6709\u4e86\u4e00\u4e2a\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u505a\u4e00\u6b21\u7684\u65b9\u6cd5\uff0c\u7ed3\u5408\u4e0a\u9762\u7684\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u53c8\u662f\u4e00\u4e2a$O(n\\log^3 n)$\u7684\u505a\u6cd5\uff08\u8fd8\u662f\u6ca1\u5199\uff09\n\n\u4f46\u662f\u6211\u4eec\u4ed4\u7ec6\u4e00\u60f3\u53d1\u73b0\u8fd9\u79cd\u53ef\u79bb\u7ebf\u7684\u9898\u76ee\u53ef\u4ee5\u76f4\u63a5\u4e0a**\u6574\u4f53\u4e8c\u5206**\uff0c\u8003\u8651\u6bcf\u6b21\u4e8c\u5206\u7684\u533a\u95f4\u503c$[l,r]$\uff0c\u6211\u4eec\u628a\u4fee\u6539\u503c\u5728\u8fd9\u4e2a\u533a\u95f4\u91cc\u7684\u4fee\u6539\u548c\u786e\u5b9a\u4e86\u7b54\u6848\u5728\u8fd9\u4e2a\u533a\u95f4\u91cc\u7684\u8be2\u95ee\u653e\u5728\u4e00\u8d77\uff0c\u7136\u540e\u6309\u65f6\u95f4\u987a\u5e8f\u64cd\u4f5c\u5373\u53ef\n\n\u6700\u540e\u5bf9\u4e8e\u6240\u6709\u8def\u5f84\u7ecf\u8fc7\u8fd9\u4e2a\u70b9\u6765\u8bf4\uff0c\u53ef\u4ee5\u5728\u52a0\u5165\u4e00\u6761\u8def\u5f84\u7684\u65f6\u5019\u628a\u8def\u5f84\u4e0a\u7684\u6743\u503c\u5168\u90e8$+1$\uff0c\u7136\u540e\u67e5\u8be2\u8fd9\u4e2a\u70b9\u7684\u70b9\u6743\u662f\u5426\u7b49\u4e8e\u8def\u5f84\u6761\u6570\u5373\u53ef\n\n\u76f4\u63a5\u4e0a\u6811\u5256\u662f\u4e09\u4e2a$\\log$\u7684~~TMD\u548c\u4e09\u4e2a$\\log$\u8fc7\u4e0d\u53bb~~\uff0c\u7136\u540e\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u53ef\u4ee5\u76f4\u63a5**\u6811\u4e0a\u5dee\u5206**\u4ee5\u540e\u518dDFS\u5e8f\u4e0a\u7528**\u6811\u72b6\u6570\u7ec4**\u7edf\u8ba1\uff0c\u7ec8\u4e8e\u5f97\u5230\u4e86\u73b0\u5728\u7684\u5c0f\u5e38\u6570$O(n\\log n)$\u505a\u6cd5\n\nPS\uff1a\u636e\u8bf4\u8fd8\u6709\u6211\u6ca1\u60f3\u5230\u7684\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u5957\u5806\u7684\u4e24\u4e2a$\\log$\u4ee5\u53ca\u53ea\u6709\u4e00\u4e2a$\\log$\u7684\u795e\u4ed9\u505a\u6cd5\uff0c\u6211\u8fd8\u662f\u592a\u5f31\u4e86\n\n```cpp\n#include<cstdio>\n#include<cctype>\n#include<iostream>\n#include<algorithm>\n#define RI register int\n#define CI const int&\n#define Tp template <typename T>\nusing namespace std;\nconst int N=200005;\n\t\tstatic const int P=18;\nstruct event\n{\n\tint opt,x,y,lca,v,id;\n\tfriend inline bool operator < (const event& A,const event& B)\n\t{\n\t\treturn A.id<B.id;\n\t}\n}et[N],tp1[N],tp2[N]; int n,m,x,y,rst[N],tot;\nstruct edge\n{\n\tint to,nxt;\n}e[N<<1]; int head[N],cnt,ans[N],fir[N],lst[N],anc[N][P];\nclass FileInputOutput\n{\n\tprivate:\n\t\tstatic const int S=1<<21;\n\t\t#define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)\n\t\t#define pc(ch) (Ftop!=Fend?*Ftop++=ch:(fwrite(Fout,1,S,stdout),*(Ftop=0)++=ch))\n\t\tchar Fin[S],Fout[S],*A,*B,*Ftop,*Fend; int pt[15];\n\tpublic:\n\t\tFileInputOutput(void) { Ftop=Fout; Fend=Fout+S; }\n\t\tTp inline void read(T& x)\n\t\t{\n\t\t\tx=0; char ch; while (!isdigit(ch=tc()));\n\t\t\twhile (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));\n\t\t}\n\t\tTp inline void write(T x)\n\t\t{\n\t\t\tif (x<0) pc('-'),x=-x; RI ptop=0; while (pt[++ptop]=x%10,x/=10);\n\t\t\twhile (ptop) pc(pt[ptop--]+48); pc('\\n');\n\t\t}\n\t\tinline void flush(void)\n\t\t{\n\t\t\tfwrite(Fout,1,Ftop-Fout,stdout);\n\t\t}\n\t\t#undef tc\n\t\t#undef pc\n}F;\ninline void addedge(CI x,CI y)\n{\n\te[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n\te[++cnt]=(edge){x,head[y]}; head[y]=cnt;\n}\nclass Double_Increased_On_Tree\n{\n\tprivate:\n\t\tint idx,dep[N];\n\t\tinline void reset(CI now)\n\t\t{\n\t\t\tfor (RI i=0;i<P-1;++i) if (anc[now][i])\n\t\t\tanc[now][i+1]=anc[anc[now][i]][i]; else break;\n\t\t}\n\tpublic:\n\t\t#define to e[i].to\n\t\tinline void DFS(CI now=1,CI fa=0)\n\t\t{\n\t\t\tfir[now]=++idx; dep[now]=dep[fa]+1; anc[now][0]=fa; reset(now);\n\t\t\tfor (RI i=head[now];i;i=e[i].nxt) if (to!=fa) DFS(to,now); lst[now]=idx;\n\t\t}\n\t\t#undef to\n\t\tinline int getlca(int x,int y)\n\t\t{\n\t\t\tRI i; if (dep[x]<dep[y]) swap(x,y); for (i=P-1;~i;--i)\n\t\t\tif (dep[anc[x][i]]>=dep[y]) x=anc[x][i]; if (x==y) return x;\n\t\t\tfor (i=P-1;~i;--i) if (anc[x][i]!=anc[y][i])\n\t\t\tx=anc[x][i],y=anc[y][i]; return anc[x][0];\n\t\t}\n}T;\nclass Tree_Array\n{\n\tprivate:\n\t\tint bit[N];\n\tpublic:\n\t\t#define lowbit(x) x&-x\n\t\tinline void add(RI x,CI y)\n\t\t{\n\t\t\tfor (;x<=n;x+=lowbit(x)) bit[x]+=y;\n\t\t}\n\t\tinline int get(RI x,int ret=0)\n\t\t{\n\t\t\tfor (;x;x-=lowbit(x)) ret+=bit[x]; return ret;\n\t\t}\n\t\t#undef lowbit\n}BIT;\ninline void expand(const event& p,CI d)\n{\n\tBIT.add(fir[p.x],d); BIT.add(fir[p.y],d); BIT.add(fir[p.lca],-d);\n\tif (anc[p.lca][0]) BIT.add(fir[anc[p.lca][0]],-d);\n}\ninline void solve(CI st=1,CI ed=m,CI l=0,CI r=tot)\n{\n\tRI i,ct1=0,ct2=0; int mid=l+r+1>>1,cur=0; if (l==r)\n\t{\n\t\tif (l) for (i=st;i<=ed;++i) if (et[i].opt==2)\n\t\tans[et[i].id]=rst[l]; return;\n\t}\n\tfor (i=st;i<=ed;++i) switch (et[i].opt)\n\t{\n\t\tcase 0:\n\t\t\tif (et[i].v<mid) tp1[++ct1]=et[i]; else tp2[++ct2]=et[i],expand(et[i],1),++cur; break;\n\t\tcase 1:\n\t\t\tif (et[i].v<mid) tp1[++ct1]=et[i]; else tp2[++ct2]=et[i],expand(et[i],-1),--cur; break;\n\t\tcase 2:\n\t\t\tif (BIT.get(lst[et[i].x])-BIT.get(fir[et[i].x]-1)==cur)\n\t\t\ttp1[++ct1]=et[i]; else tp2[++ct2]=et[i]; break;\n\t}\n\tfor (i=st;i<=ed;++i) if (et[i].opt!=2&&et[i].v>=mid) expand(et[i],et[i].opt?1:-1);\n\tfor (i=1;i<=ct1;++i) et[st+i-1]=tp1[i]; for (i=1;i<=ct2;++i) et[st+ct1+i-1]=tp2[i];\n\tsolve(st,st+ct1-1,l,mid-1); solve(st+ct1,ed,mid,r);\n}\nint main()\n{\n\t//freopen(\"CODE.in\",\"r\",stdin); freopen(\"CODE.out\",\"w\",stdout);\n\tRI i; for (F.read(n),F.read(m),i=1;i<n;++i)\n\tF.read(x),F.read(y),addedge(x,y);\n\tfor (T.DFS(),i=1;i<=m;++i)\n\t{\n\t\tF.read(et[i].opt); et[i].id=i;\n\t\tswitch (et[i].opt)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\tF.read(et[i].x); F.read(et[i].y); F.read(et[i].v);\n\t\t\t\tet[i].lca=T.getlca(et[i].x,et[i].y); rst[++tot]=et[i].v; break;\n\t\t\tcase 1:\n\t\t\t\tF.read(x); et[i]=et[x]; et[i].opt=1; et[i].id=i; break;\n\t\t\tcase 2:\n\t\t\t\tF.read(et[i].x); ans[i]=-1; break;\n\t\t}\n\t}\n\tsort(rst+1,rst+tot+1); tot=unique(rst+1,rst+tot+1)-rst-1;\n\tfor (i=1;i<=m;++i) if (et[i].opt!=2) et[i].v=lower_bound(rst+1,rst+tot+1,et[i].v)-rst;\n\tfor (solve(),sort(et+1,et+m+1),i=1;i<=m;++i) if (et[i].opt==2) F.write(ans[i]);\n\treturn F.flush(),0;\n}\n```",
        "postTime": 1570281622,
        "uid": 41698,
        "name": "hl666",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u8fd9\u662f\u4e00\u4e2a\u8981\u5f00O2\u7684TJ\n\n\u5f3a\u884c\u6811\u94fe\u5256\u5206\n\n\u5f3a\u884c\u5728\u6bcf\u4e2a\u70b9\u4e0a\u7ef4\u62a4\u4e24\u4e2a\u5927\u6839\u5806\n\n\u4e00\u4e2a\u8868\u793a\u8fdb\u5165\u7684\uff0c\u4e00\u4e2a\u8868\u793a\u5220\u9664\u7684\n\n\u5806\u9876\u76f8\u540c\u5219\u5220\u6389\n\n\u6bcf\u4e00\u6b21\u5220\u6389\u6216\u6dfb\u52a0\u4e00\u4e2a\u7f51\u7edc\u5c06\u6240\u6709\u4e0d\u518d\u8be5\u7f51\u7edc\u4e0a\u7684\u70b9\u7684\u5806\u4e2d\u6dfb\u52a0\u5f53\u524d\u7684\u7f51\u7edc\n\n\u7136\u540e\u5361\u8fc7\n\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\ntemplate <typename Type> inline void Read( Type &in ){\n    in=0;char ch=getchar();Type f=1;\n    for(;ch> '9'||ch< '0';ch=getchar())if(ch=='-')f=-1;\n    for(;ch>='0'&&ch<='9';ch=getchar())in=in*10+ch-'0';in*=f;\n}\n\nstatic const int MAXN = 1e5 +1;\nstatic const int MAXM = MAXN<<1;\n\nint n,m,Num,Ct,u,v,Opt,k,Ans;\nint Nt[MAXM],H[MAXN],To[MAXM];\nint Qu[MAXM],Qv[MAXM],Qw[MAXM];\nint Size[MAXN],Top[MAXN],Son[MAXN],Rank[MAXN],Fa[MAXN],Dep[MAXN];\n\ninline void Ins( int From,int _To ){\n    Nt[++Num] = H[From];\n    H[From] = Num;\n    To[Num] = _To;\n}\n\ninline void Dfs1( int A ){\n    Size[A] = 1;\n    for( int i=H[A];i;i=Nt[i] ){\n        int B = To[i];if( Fa[A]==B )continue;\n        Fa[B] = A;Dep[B] = Dep[A] +1;\n        Dfs1( B );\n        Size[A] += Size[B];\n        if( Size[B]>=Size[Son[A]] ) Son[A] = B;\n    }\n}\n\ninline void Dfs2( int A,int Chain ){\n    Rank[A] = ++Ct;\n    Top [A] = Chain;\n    if( Son[A] ) Dfs2( Son[A],Chain );\n    for( int i=H[A];i;i=Nt[i] )\n        if( To[i]!=Fa[A]&&To[i]!=Son[A] )\n            Dfs2( To[i],To[i] );\n}\n\nstruct Segment_Tree{\n    priority_queue< int > Ext[2];\n    inline int Get(){\n        for( ;!Ext[0].empty()&&!Ext[1].empty()&&Ext[0].top()==Ext[1].top();Ext[0].pop(),Ext[1].pop());\n        if( Ext[0].empty() ) return -1;\n        return Ext[0].top();\n    }\n}Max[MAXN<<2];\n\ninline void MF( int Nd,int l,int r,int s,int t,int w ){\n    if( l>=s&&r<=t ){\n        Max[Nd].Ext[Opt].push( w );\n        return;\n    }\n    int Mid = ( l+r )>>1;\n    if( Mid>=s )MF( Nd<<1,l,Mid,s,t,w );if( Mid<t )MF( Nd<<1|1,Mid+1,r,s,t,w );\n}\n\ninline void Query( int Nd,int l,int r,int s ){\n    Ans = max( Ans,Max[Nd].Get() );\n    if( l==r )return;\n    int Mid = ( l+r )>>1;\n    if( Mid>=s ) Query( Nd<<1,l,Mid,s );\n    else Query( Nd<<1|1,Mid+1,r,s );\n}\n\nstruct QUE{\n    int l,r;\n    inline bool operator < (QUE T)const{return l<T.l;}\n}Que[MAXN];\n\ninline void Solve( int A,int B,int C ){\n    int Cnt = 0;\n    while( Top[A]!=Top[B] ){\n        if( Dep[Top[A]]<Dep[Top[B]] )A^=B^=A^=B;\n        Que[++Cnt].l=Rank[Top[A]];Que[Cnt].r=Rank[A];\n        A = Fa[Top[A]];\n    }\n    if( Rank[A]>Rank[B] )A^=B^=A^=B;\n    Que[++Cnt].l=Rank[A];Que[Cnt].r=Rank[B];\n    sort( Que+1,Que+1+Cnt );\n    for( int i=1;i<=Cnt;i++ )if( Que[i-1].r+1<=Que[i].l-1 ) MF( 1,1,n,Que[i-1].r+1,Que[i].l-1,C );\n    if( Que[Cnt].r+1<=n ) MF( 1,1,n,Que[Cnt].r+1,n,C );\n}\n\nint main(){\n    \n    Read( n );Read( m );\n    for( int i=1;i< n;i++ )Read( u ),Read( v ),Ins( u,v ),Ins( v,u );\n    Dfs1( 1 );Dfs2( 1,0 );\n    for( int i=1;i<=m;i++ ){\n        Read( Opt );\n        switch( Opt ){\n            case 0:Read( Qu[i] );Read( Qv[i] );Read( Qw[i] );Solve( Qu[i],Qv[i],Qw[i] );break;\n            case 1:Read( u );Solve( Qu[u],Qv[u],Qw[u] );break;\n            case 2:Read( u );Ans=-1;Query( 1,1,n,Rank[u] );printf(\"%d\\n\",Ans);break;\n        }\n    }\n    return 0;\n}```",
        "postTime": 1489675335,
        "uid": 20116,
        "name": "never_see",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3250 \u3010[HNOI2016]\u7f51\u7edc\u3011"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u597d\u9898\u3002\u672c\u9898\u89e3\u601d\u8def\u5927\u81f4\u4e0e[\u5927\u4f6cFreopen](https://www.luogu.com.cn/user/30037)\u76f8\u540c\uff0c\u4f46\u4ee3\u7801\u5b9e\u73b0\u7565\u6709\u4e0d\u540c\uff0c\u5982\u679c\u6709\u4e0d\u592a\u4e60\u60ef zkw \u7ebf\u6bb5\u6811\u7684\u540c\u5b66\u53ef\u4ee5\u6765\u770b\u770b\u6211\u7684\u4ee3\u7801\uff0c\u56e0\u4e3a\u8fd9\u9053\u9898\u786e\u5b9e\u7ec6\u8282\u4e0d\u5c11\uff0c\u7279\u522b\u662f\u7ebf\u6bb5\u6811\u4e8c\u5206\u7684\u90e8\u5206\u3002\n\n\u9996\u5148\uff0c\u6211\u4eec\u6765\u8003\u8651\u4e00\u4e2a\u66b4\u529b\u7684\u601d\u8def\uff0c\u5bf9\u4e8e\u5168\u5c40\u7ef4\u62a4\u4e00\u4e2a\u5806\uff0c\u63d2\u5165\u5220\u9664\u64cd\u4f5c\u90fd\u80fd\u88ab\u5f88\u597d\u652f\u6301\uff0c\u552f\u72ec\u8be2\u95ee\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u53ea\u80fd\u4e0d\u65ad\u53d6\u51fa\u5806\u9876\uff0c\u5224\u65ad\u8be2\u95ee\u70b9\u5728\u5728\u4e0d\u5728\u8def\u5f84\u4e0a\u3002\u8fd9\u6837\u7684\u66b4\u529b\u5f88\u5bb9\u6613\u88ab\u5361\u6210 $O(n^2\\ \\log\\ n)$\u3002\n\n\u8fd9\u6837\u7684\u66b4\u529b\u601d\u8def\u7ed9\u4e86\u6211\u4eec\u4e00\u4e2a\u542f\u793a\uff0c\u6211\u4eec\u9700\u8981\u627e\u7684\u662f\u4e00\u4e2a\u6392\u597d\u5e8f\u7684\u5e8f\u5217\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u70b9\u3002\u90a3\u4e48\u6211\u4eec\u662f\u4e0d\u662f\u80fd\u8003\u8651\u8f6c\u6362\u6210\u4e8c\u5206\u7b54\u6848\u7684\u95ee\u9898\u5462\uff1f\n\n\u663e\u7136\u662f\u53ef\u4ee5\u7684\uff0c\u90a3\u4e48\u5269\u4e0b\u7684\u4efb\u52a1\u5c31\u662f\u5982\u4f55\u5224\u5b9a\u4e00\u4e2a\u70b9\u662f\u4e0d\u662f\u5728\u4e00\u4e9b\u70b9\u5bf9\u7684\u8def\u5f84\u5e76\u4e0a\u3002\u53e6\u5916\uff0c\u6211\u4eec\u8fd8\u8981\u652f\u6301\u52a8\u6001\u7684\u52a0\u5165\u548c\u5220\u9664\u8def\u5f84\u3002\n\n\u80fd\u591f\u52a8\u6001\u589e\u5220\u548c\u6392\u5e8f\u7684\uff0c\u53ea\u6709\u5806\uff0c\u5e73\u8861\u6811\u548c\u503c\u57df\u7ebf\u6bb5\u6811\u3002\u524d\u4e24\u8005\u4e0d\u597d\u7ef4\u62a4\u524d\u7f00\u4fe1\u606f\uff0c\u6211\u4eec\u9009\u62e9\u503c\u57df\u7ebf\u6bb5\u6811\u3002\n\n\u6211\u4eec\u5c06\u6240\u6709\u70b9\u5bf9\u7684\u6743\u503c\u79bb\u6563\u5316\uff0c\u76f8\u540c\u7684\u6743\u503c\u5c31\u66f4\u5177\u65f6\u95f4\u5148\u540e\u5206\u5f00\u3002\u90a3\u4e48\u6211\u4eec\u6700\u540e\u7684\u95ee\u9898\u5c31\u662f\u5982\u4f55\u5de6\u53f3\u6709\u4e24\u4e2a\u533a\u95f4\u7684\u8def\u5f84\u6c42\u5e76\u3002\n\n\u5047\u5982\u5f53\u524d\u6709 $(x,y)$ \u548c $(u,v)$ \u4e24\u6761\u6811\u4e0a\u8def\u5f84\u3002\u90a3\u4e48\u8fd9\u56db\u4e2a\u70b9\u4e24\u4e24\u7ec4\u5408\u56db\u79cd\u60c5\u51b5\u7684 lca \u4e2d\uff0c\u6700\u6df1\u7684\u4e24\u4e2a\u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5462\u4e48\u8fd9\u4e24\u4e2a\u70b9\u5c31\u662f\u8def\u5f84\u7684\u4ea4\uff0c\u5982\u679c\u76f8\u7b49\uff0c\u518d\u5224\u65ad\u662f\u4e0d\u662f\u5728\u8def\u5f84\u4e0a\u5373\u53ef\u3002\n\n$O(1)$ \u6c42 lca \u80fd\u591f\u5c06\u5408\u5e76\u4f18\u5316\u5230 $O(\\log\\ n)$\u3002\u4f46\u662f\u8fd9\u91cc\u4f1a\u6709\u4e00\u8fb9\u6ca1\u6709\u7684\u60c5\u51b5\uff0c\u9274\u4e8e\u6211\u4eec\u4e4b\u540e\u8981\u4f7f\u7528\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u6211\u4eec\u8bb0\u5f55\u4e00\u4e2a $tag_p$ ,\u8868\u793a\u7ebf\u6bb5\u6811\u4e0a\u8282\u70b9 $p$ \u6240\u5bf9\u5e94\u7684\u533a\u95f4\u6709\u6ca1\u6709\u70b9\u5bf9\u3002\u5408\u5e76\u65f6\uff0c\u5047\u5982\u4e24\u8fb9\u90fd\u4e3a\u7a7a\uff0c\u90a3\u4e48\u5f53\u524d\u8282\u70b9\u4e3a\u7a7a\uff0c\u5047\u5982\u4e24\u8fb9\u6709\u4e00\u8fb9\u4e3a\u7a7a\uff0c\u90a3\u4e48\u7ee7\u627f\u4e0d\u4e3a\u7a7a\u7684\u4e00\u6bb5\uff0c\u5047\u5982\u4e24\u8fb9\u90fd\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u8def\u5f84\u6ca1\u6709\u4ea4\uff0c\u90a3\u4e48\u7aef\u70b9\u8bb0\u4e3a $0$\u3002\n\n\u5224\u65ad\u7684\u65f6\u5019\uff0c\u53ea\u8981\u53f3\u8282\u70b9\u4e0d\u4e3a\u7a7a\u4e14\u53f3\u8282\u70b9\u7684\u4e24\u4e2a\u7aef\u70b9\u4e3a $0$ \u6216\u5f53\u524d\u70b9\u4e0d\u5728\u8def\u5f84\u5e76\u4e0a\uff0c\u90a3\u4e48\u5f80\u53f3\u8fb9\u8d70\uff0c\u5426\u5219\u5411\u5de6\u3002\n\n\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u4e00\u5b9a\u8981\u4fdd\u8bc1\u67e5\u627e\u7684\u533a\u95f4\u4e00\u5b9a\u6709\u89e3\uff0c\u624d\u5f80\u90a3\u8fb9\u9012\u5f52\u3002\n\n```\n#include<bits/stdc++.h>\n#define N 200005\nusing namespace std;\nint n,m,head[N],idx,dep[N],dfn[N*2],rev[N],cnt,fa[N];\nint st[N][30];\nstruct edge{\n\tint v,next;\n}e[2*N];\nvoid add(int u,int v){\n\te[++idx].v=v;\n\te[idx].next=head[u];\n\thead[u]=idx;\n}\nvoid dfs(int x,int f){\n\tfa[x]=f;\n\tdep[x]=dep[f]+1;\n\tdfn[++cnt]=x;\n\trev[x]=cnt;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint y=e[i].v;\n\t\tif(y==f) continue;\n\t\tdfs(y,x);\n\t\tdfn[++cnt]=x;\n\t}\n}\nvoid prework(){\n\tint t=log(cnt)/log(2);\n\tfor(int i=1;i<=cnt;i++) st[i][0]=dfn[i];\n\tfor(int j=1;j<=t;j++){\n\t\tfor(int i=1;i<=cnt-(1<<j)+1;i++){\n\t\t\tif(dep[st[i][j-1]]>dep[st[i+(1<<(j-1))][j-1]]) st[i][j]=st[i+(1<<(j-1))][j-1];\n\t\t\telse st[i][j]=st[i][j-1];\n\t\t}\n\t}\n}\nint LCA(int x,int y){\n\tint l=rev[x],r=rev[y];\n\tif(l>r) swap(l,r);\n\tint k=log(r-l+1)/log(2);\n\tint lca;\n\tif(dep[st[l][k]]<dep[st[r-(1<<k)+1][k]]) lca=st[l][k];\n \telse lca=st[r-(1<<k)+1][k];\n \treturn lca;\n}\nint num=0;\nstruct path{\n\tint x,y,z,id;\n}p[N];\nbool cmp(path x,path y){\n\tif(x.z!=y.z) return x.z<y.z;\n\treturn x.id<y.id;\n} \nstruct node{\n\tint op,x,y,z;\n}opt[N];\nint back[N];\nint tag[N<<2],s[N<<2],t[N<<2];\nbool cmp1(int x,int y){\n\treturn dep[x]>dep[y];\n}\nvoid push_up(int p){\n\tif(!tag[p<<1]&&!tag[p<<1|1]){\n\t\ttag[p]=0;\n\t\treturn ;\n\t}\n\ttag[p]=1;\n\tif(!tag[p<<1]){\n\t\ts[p]=s[p<<1|1];\n\t\tt[p]=t[p<<1|1];\n\t\treturn ;\n\t}\n\tif(!tag[p<<1|1]){\n\t\ts[p]=s[p<<1];\n\t\tt[p]=t[p<<1];\n\t\treturn ;\n\t}\n\tint w[5];\n\tw[1]=LCA(s[p<<1],s[p<<1|1]),w[2]=LCA(t[p<<1],t[p<<1|1]),w[3]=LCA(s[p<<1],t[p<<1|1]),w[4]=LCA(s[p<<1|1],t[p<<1]);\n\tsort(w+1,w+5,cmp1);\n\tif(w[1]!=w[2]) s[p]=w[1],t[p]=w[2];\n\telse if(w[1]==LCA(s[p<<1],t[p<<1])||w[1]==LCA(s[p<<1|1],t[p<<1|1])) s[p]=t[p]=w[1];\n\telse s[p]=t[p]=0;\n\treturn ;\n}\nvoid modify(int p,int l,int r,int x,int u,int v){\n\tif(l==r){\n\t\ttag[p]=1;\n\t\ts[p]=u;\n\t\tt[p]=v;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid) modify(p<<1,l,mid,x,u,v);\n\telse modify(p<<1|1,mid+1,r,x,u,v);\n\tpush_up(p); \n}\nvoid del(int p,int l,int r,int x){\n\tif(l==r){\n\t\ttag[p]=0;\n\t\ts[p]=0;\n\t\tt[p]=0;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(x<=mid) del(p<<1,l,mid,x);\n\telse del(p<<1|1,mid+1,r,x);\n\tpush_up(p);\n}\nbool check(int u,int v,int x){\n\tif(!u&&!v) return true;\n\tint lca=LCA(u,v);\n\tif(LCA(x,lca)!=lca) return true;\n\tif(LCA(u,x)!=x&&LCA(v,x)!=x) return true;\n\treturn false;\n}\nint query(int p,int l,int r,int x){\n\tif(!tag[p]) return -1;\n\twhile(l!=r){\n\t\tint mid=(l+r)>>1;\n\t\tif(tag[p<<1|1]&&check(s[p<<1|1],t[p<<1|1],x)){\n\t\t\tp=p*2+1;\n\t\t\tl=mid+1;\n\t\t}\n\t\telse{\n\t\t\tp<<=1;\n\t\t\tr=mid;\n\t\t}\n\t}\n\tif(!tag[p]||!check(s[p],t[p],x)) return -1;\n\treturn l;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v);\n\t\tadd(v,u);\n\t}\t\n\tdfs(1,0);\n\tprework();\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&opt[i].op,&opt[i].x);\n\t\tif(opt[i].op==0){\n\t\t\tscanf(\"%d%d\",&opt[i].y,&opt[i].z);\n\t\t\tp[++num].x=opt[i].x;\n\t\t\tp[num].y=opt[i].y;\n\t\t\tp[num].z=opt[i].z;\n\t\t\tp[num].id=i;\n\t\t}\n\t}\n\tsort(p+1,p+num+1,cmp);\n\tfor(int i=1;i<=num;i++){\n\t\tback[i]=p[i].z;\n\t\topt[p[i].id].z=i;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(opt[i].op==0) modify(1,1,num,opt[i].z,opt[i].x,opt[i].y);\n\t\tif(opt[i].op==1) del(1,1,num,opt[opt[i].x].z);\n\t\tif(opt[i].op==2){\n\t\t\tint ans=query(1,1,num,opt[i].x);\n\t\t\tif(ans==-1) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\",back[query(1,1,num,opt[i].x)]);\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n",
        "postTime": 1615706561,
        "uid": 128870,
        "name": "chen_qian",
        "ccfLevel": 7,
        "title": "P3250"
    }
]