[
    {
        "content": "## \u3010p4209\u3011\u5b66\u4e60\u5c0f\u7ec4\n\n- \u5171\u6709n\u4e2a\u5b66\u751f\uff0cm\u4e2a\u5b66\u4e60\u5c0f\u7ec4\uff0c\u89c4\u5b9a\u4e00\u4e2a\u5b66\u751f\u6700\u591a\u53c2\u52a0k\u4e2a\u5b66\u4e60\u5c0f\u7ec4\u3002\n\n- \u6bcf\u4e2a\u5b66\u751f\u53c2\u52a0\u5b66\u4e60\u5c0f\u7ec4\u8981\u4ea4\u4e00\u5b9a\u7684\u624b\u7eed\u8d39\n\n- \u5b66\u6821\u5bf9\u5b66\u4e60\u5c0f\u7ec4\u5956\u52b1 Ci *a(\u4eba\u6570)^2 \u5143\u3002\n\n- \u5728\u53c2\u4e0e\u5b66\u751f\u5c3d\u91cf\u591a\u7684\u60c5\u51b5\u4e0b\uff0c\u6c42\u6700\u5c11\u652f\u51fa\uff08\u82e5\u4e3a\u8d1f\u6570\uff0c\u5219\u8f93\u51fa\u8d1f\u6570\uff09\u3002\n\n\n------------\n\n\n**Q\uff1a\u5982\u4f55\u5904\u7406Ci*a^2\uff1f**\n\n**A\uff1a\u6bcf\u4e2a\u5b66\u4e60\u5c0f\u7ec4\u5411T\u8fde\u2014\u2014\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3aCi\u00d71\u3001Ci\u00d73\u3001Ci\u00d75\u3001Ci\u00d77\u3001...\u3001Ci\u00d7(2\u00d7n-1)\u7684\u4e00\u5806\u8fb9\uff0c\u5229\u7528\u5e73\u65b9\u5dee\u5173\u7cfb\u8868\u793aCi\u00d7a^2\u3002**\n\n------------\n\nS\u5411\u6bcf\u4e2a\u5b66\u751f\u8fde\u5bb9\u91cf\u4e3ak(\u6700\u591ak\u4e2a\u5c0f\u7ec4)\u3001\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\n\n\u5b66\u751f\u5411\u80fd\u53c2\u52a0\u7684\u5b66\u4e60\u5c0f\u7ec4\u8fde\u5bb9\u91cf\u4e3a1\u3001\u8d39\u7528\u4e3aFi\u7684\u8fb9\u3002\n\n\n    \u201c\u5728\u53c2\u4e0e\u5b66\u751f\uff08\u800c\u4e0d\u662f\u6bcf\u4e2a\u5b66\u4e60\u5c0f\u7ec4\u7684\u4eba\u6570\u603b\u548c\uff09\u5c3d\u91cf\u591a\u7684\u60c5\u51b5\u4e0b\u201d\n\n\u6307\u7684\u662f\u6240\u6709\u5b66\u751f\u5fc5\u987b\u6709\u6d41\u901a\u8fc7\uff0c\u4f46\u4e0d\u5fc5\u6ee1\u6d41\u3002\n\n\u6240\u4ee5\u8fd8\u8981\u4ece\u6bcf\u4e2a\u5b66\u751f\u5411T\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3ak-1\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u4fdd\u8bc1\u8d39\u7528\u6700\u5c0f\uff08\u53ea\u53c2\u52a01\u4e2a\u5c0f\u7ec4\uff09\u3002\n\n\n------------\n\n\n```cpp\n#include <cmath>\n#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <stack>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define R register\n\nvoid reads(int &x){ //\u8bfb\u5165\u4f18\u5316\uff08\u6b63\u8d1f\u6574\u6570\uff09\n    int fx=1;x=0;char ch_=getchar();\n    while(ch_<'0'||ch_>'9'){if(ch_=='-')fx=-1;ch_=getchar();}\n    while(ch_>='0'&&ch_<='9'){x=x*10+ch_-'0';ch_=getchar();}\n    x*=fx; //\u6b63\u8d1f\u53f7\n}\n\nconst int N=500019;\n\nstruct edge{ int ver,nextt,flow,cost; }e[2*N];\n\nint tot=-1,n,m,k,S,T,maxf=0,minc=0,f[N];\n\nint flow[N],head[N],dist[N],inq[N],pre[N],lastt[N];\n\nvoid add(int a,int b,int f,int c)\n{ e[++tot].nextt=head[a],head[a]=tot,\n  e[tot].ver=b,e[tot].flow=f,e[tot].cost=c; } \n\nbool spfa(int S,int T){\n    queue<int> q;\n    memset(inq,0,sizeof(inq));\n    memset(flow,0x7f,sizeof(flow));\n    memset(dist,0x7f,sizeof(dist));\n    q.push(S),dist[S]=0,pre[T]=-1,inq[S]=1;\n    while(!q.empty()){\n        int x=q.front(); q.pop(); inq[x]=0;\n        for(int i=head[x];i!=-1;i=e[i].nextt){\n            if(e[i].flow>0&&dist[e[i].ver]>dist[x]+e[i].cost){\n                dist[e[i].ver]=dist[x]+e[i].cost;\n                pre[e[i].ver]=x,lastt[e[i].ver]=i;\n                flow[e[i].ver]=min(flow[x],e[i].flow);\n                if(!inq[e[i].ver])\n                    q.push(e[i].ver),inq[e[i].ver]=1;\n            }\n        }\n    } return pre[T]!=-1;\n}\n\nvoid mcmf(){\n    while(spfa(S,T)){\n        int now=T; //\u2193\u2193\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\n        maxf+=flow[T],minc+=dist[T]*flow[T];\n        while(now!=S){ //\u2193\u2193\u6b63\u8fb9\u6d41\u91cf-\uff0c\u53cd\u8fb9\u6d41\u91cf+\n            e[lastt[now]].flow-=flow[T];\n            e[lastt[now]^1].flow+=flow[T]; \n            //\u2191\u2191\u5229\u7528xor1\u201c\u6210\u5bf9\u50a8\u5b58\u201d\u7684\u6027\u8d28\n            now=pre[now]; //\u7ef4\u62a4\u524d\u5411\u8fb9last\uff0c\u524d\u5411\u70b9pre\n        }\n    }\n}\n\nchar ss[N]; //\u6bcf\u4e2a\u5b66\u751f\u53ef\u4ee5\u52a0\u5165\u7684\u5c0f\u7ec4\n\nint main(){\n    reads(n),reads(m),reads(k); S=0,T=n+m+1; memset(head,-1,sizeof(head));\n    for(int i=1,x;i<=m;i++){ reads(x); //\u5c0f\u7ec4i(\u7f16\u53f7i+n)\u5411T\u8fde\u591a\u6761\u8d39\u7528\u4e0d\u540c\u7684\u8fb9\n        for(int j=1;j<=n;j++) add(i+n,T,1,x*(2*j-1)),add(T,i+n,0,-x*(2*j-1));\n    } for(int i=1;i<=m;i++) reads(f[i]); //\u53c2\u52a0\u5c0f\u7ec4i\u7684\u8d39\u7528\n    for(int i=1;i<=n;i++){ //\u2193\u2193\u4ece\u6bcf\u4e2a\u5b66\u751f\u5411T\u8fde\u8fb9\uff0c\u4fdd\u8bc1\u6bcf\u4eba\u90fd\u6709\u6d41\u7684\u60c5\u51b5\u4e0b\u8d39\u7528\u6700\u5c0f\n        add(S,i,k,0),add(i,S,0,0),add(i,T,k-1,0),add(T,i,0,0);\n        scanf(\"%s\",ss+1); for(int j=1;j<=m;j++) if(ss[j]=='1') //\u6bcf\u4eba\u80fd\u62a5\u7684\u5c0f\u7ec4\n            add(i,j+n,1,-f[j]),add(j+n,i,0,-(-f[j])); //\u6536\u5165\u7528'-'\u8868\u793a\n    } mcmf(),printf(\"%d\\n\",minc); //\u5728\u6709\u524d\u63d0\u6761\u4ef6\u306e\u5efa\u8fb9\u60c5\u51b5\u4e0b\u7684\u6700\u5c0f\u8d39\u7528\n}\n```\n",
        "postTime": 1551701204,
        "uid": 69404,
        "name": "flora715",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4209 \u3010\u5b66\u4e60\u5c0f\u7ec4\u3011"
    },
    {
        "content": "[\u539f\u9898](https://www.luogu.com.cn/problem/P4209)\n\n\u8fd9\u662f\u4e00\u9053\u6bd4\u8f83\u4f18\u79c0\u7684\u6280\u5de7\u7c7b\u9898\u76ee\u3002\n\n\u6211\u4eec\u901a\u8fc7\u89c2\u5bdf\u6570\u636e\u8303\u56f4\uff0c\u53d1\u73b0\u5f88\u5c0f\uff0c\u9996\u5148\u6392\u9664\u8d2a\u5fc3\u3002\n\n\u7531\u4e8e\u9898\u76ee\u9650\u5236\u591a\u800c\u590d\u6742\uff0c\u6211\u4eec\u8003\u8651\u4f7f\u7528\u7f51\u7edc\u6d41\u6765\u63cf\u8ff0\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\u8003\u8651\u5efa\u7acb\u4e00\u4e2a\u7f51\u7edc\u6d41\u6846\u67b6\uff0c\u5927\u6982\u662f\u6211\u4eec\u8981\u6c42\u6bcf\u4e2a\u80fd\u9009\u5c0f\u7ec4\u7684\u5b66\u751f\u90fd\u81f3\u5c11\u9009\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u53ef\u4ee5\u4f7f\u7528\u6700\u5927\u6d41\u63cf\u8ff0\uff0c\u4f46\u662f\u9898\u76ee\u6709\u8981\u6c42\u652f\u51fa\u6700\u5c11\uff0c\u56e0\u6b64\u8003\u8651\u4f7f\u7528\u8d39\u7528\u6d41\u8fdb\u4e00\u6b65\u63cf\u8ff0\u3002\n\n\u5148\u8003\u8651\u5982\u4f55\u63cf\u8ff0\u53c2\u52a0\u4e86\u4e00\u4e9b\u5b66\u751f\u7684\u5c0f\u7ec4\u7684\u652f\u51fa\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u7531\u4e8e\u652f\u51fa\u589e\u957f\u662f\u5e73\u65b9\u500d\u7ea7\u522b\u7684\uff0c\u56e0\u6b64\u65e0\u6cd5\u76f4\u63a5\u7528\u540c\u4e00\u7684\u8d39\u7528\u63cf\u8ff0\u3002\u6211\u4eec\u53d1\u73b0\u7531\u4e8e $C,F$ \u662f\u6b63\u6570\uff0c\u56e0\u6b64\u4e0d\u96be\u8bc1\u660e\u6709\u4ee5\u4e0b\u5f0f\u5b50\uff1a\n\n$$\nC_i \\times (a+1)^2 - F_i \\times (a+1) - C_i \\times a^2 + F_i \\times a > C_i \\times a^2 - F_i \\times a - C_i \\times (a-1)^2 + F_i \\times (a-1)\n$$\n\n\u5373\u76f8\u90bb\u53c2\u52a0\u4eba\u6570\u589e\u52a0\u6240\u5e26\u6765\u7684\u82b1\u8d39\u53d8\u5316\u91cf\u662f\u5355\u8c03\u9012\u589e\u7684\uff0c\u6211\u4eec\u8003\u8651\u628a\u4ed6\u7684\u82b1\u8d39\u8fdb\u884c\u5dee\u5206\uff0c\u62c6\u6210 $n$ \u6761\u8fb9\u4e0e\u6c47\u70b9\u76f8\u8fde\uff0c\u6839\u636e\u8d2a\u5fc3\u60f3\u6cd5\uff0c\u8dd1\u8d39\u7528\u6d41\u65f6\u4e00\u5b9a\u4f1a\u4f18\u5148\u9009\u8f83\u5c0f\u7684\u8fb9\uff0c\u56e0\u6b64\u6b63\u786e\u6027\u53ef\u4ee5\u4fdd\u8bc1\u3002\n\n\u53e6\u5916\uff0c\u8003\u8651\u5982\u4f55\u9650\u5236\u6bcf\u4e2a\u5b66\u751f\u81f3\u5c11\u9009\u62e9\u4e00\u4e2a\u3002\u6839\u636e\u8d2a\u5fc3\u60f3\u6cd5\uff0c\u7531\u4e8e\u8be2\u95ee\u6700\u5c11\u652f\u51fa\uff0c\u6211\u4eec\u8003\u8651\u5728\u4ec0\u4e48\u65f6\u5019\u5b66\u751f\u4f1a\u9009\u62e9\u4e0d\u6b62\u4e00\u4e2a\u5b66\u4e60\u5c0f\u7ec4\u3002\u663e\u7136\uff0c\u5f53\u4e14\u4ec5\u5f53\u591a\u9009\u62e9\u5c0f\u7ec4\u4f1a\u8ba9\u82b1\u8d39\u66f4\u5c0f\u65f6\u6211\u4eec\u624d\u4f1a\u591a\u9009\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u5b66\u751f\u81f3\u5c11\u9009\u4e00\u4e2a\u6211\u4eec\u8003\u8651\u4f7f\u7528\u6ee1\u6d41\u7684\u65b9\u5f0f\u9650\u5236\u3002\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4ece\u6bcf\u4e2a\u5b66\u751f\u5f80\u6c47\u70b9\u8fde\u63a5\u4e00\u6761\u5bb9\u91cf\u4e3a $k - 1$ \uff0c\u82b1\u8d39\u4e3a $0$ \u7684\u8fb9\uff0c\u5c31\u53ef\u4ee5\u9650\u5236\u8fd9\u4e2a\u5b66\u751f\u81f3\u5c11\u9009\u62e9\u4e00\u4e2a\u5c0f\u7ec4\uff0c\u540c\u65f6\u60f3\u8981\u591a\u9009\u5219\u82b1\u8d39\u5fc5\u987b\u6bd4 $0$ \u66f4\u5c0f\u3002\n\n\u81f3\u6b64\uff0c\u6211\u4eec\u7684\u5efa\u56fe\u6ee1\u8db3\u4e86\u9898\u76ee\u7684\u6240\u6709\u9650\u5236\u6761\u4ef6\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\ntemplate <typename T>\nvoid read(T &x) {\n\tT f=1;x=0;char s=getchar();\n\twhile(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s^'0');s=getchar();}\n\tx *= f;\n}\n\nconst int MAXN = 1e5 + 5;\nconst int MAXM = 1e5 + 5;\nconst LL inf = 1e15;\n\nint head[MAXN] , to[MAXM << 1] , nxt[MAXM << 1] , cnt = 1;\nLL edge[MAXM << 1] , val[MAXM << 1];\nvoid add(int u , int v , LL c , LL w) {\n\tnxt[++cnt] = head[u];head[u] = cnt;to[cnt] = v;edge[cnt] = c;val[cnt] = w;\n\tnxt[++cnt] = head[v];head[v] = cnt;to[cnt] = u;edge[cnt] = 0;val[cnt] = -w;\n}\n\nint las[MAXN] , pre[MAXN] , num , s , t , vis[MAXN];\nLL dis[MAXN] , flow[MAXN];\n\nstruct MinCostMaxFlow {\n\tLL MaxFlow , MinCost;\n\tbool bfs() {\n\t\tfor (int i = 1; i <= num; ++i) las[i] = 0 , dis[i] = inf , pre[i] = 0 , flow[i] = 0 , vis[i] = 0;\n\t\tflow[s] = inf , dis[s] = 0;\n\t\tqueue <int> q;q.push(s);\n\t\tint flag = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tvis[x] = 0;\n\t\t\tfor (int i = head[x]; i; i = nxt[i]) {\n\t\t\t\tif(!edge[i]) continue;\n\t\t\t\tint v = to[i];\n\t\t\t\tif(dis[v] > dis[x] + val[i]) {\n\t\t\t\t\tdis[v] = dis[x] + val[i];\n\t\t\t\t\tflow[v] = min(flow[x] , edge[i]);\n\t\t\t\t\tpre[v] = x;\n\t\t\t\t\tlas[v] = i;\n\t\t\t\t\tif(v == t) {\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!vis[v]) vis[v] = 1 , q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\treturn flag;\n\t}\n\tvoid MVMC() {\n\t\tMaxFlow = 0 , MinCost = 0;\n\t\twhile(bfs()) {\n\t\t\tint now = t;\n\t\t\tMaxFlow += flow[t];\n\t\t\tMinCost += dis[t] * flow[t];\n\t\t\twhile(now != s) {\n\t\t\t\tedge[las[now]] -= flow[t];\n\t\t\t\tedge[las[now] ^ 1] += flow[t];\n\t\t\t\tnow = pre[now];\n\t\t\t}\n\t\t}\n\t} \n}MIN;\n\nint n , m , k , id[MAXN] , C[MAXN];\nint per[MAXN];\n\nint main() {\n\tread(n),read(m),read(k);\n\ts = 1 , t = 2 , num = 2;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tread(C[i]);\n\t\tid[i] = ++num;\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint F;\n\t\tread(F);\n\t\tfor (int j = 1; j <= n; ++j) add(id[i] , t , 1 , C[i] * (2 * j - 1) - F);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tper[i] = ++num;\n\t\tchar s[105];\n\t\tscanf(\"%s\" , s + 1);\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tif(s[j] == '1') add(per[i] , id[j] , 1 , 0);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tadd(s , per[i] , k , 0);\n\t\tadd(per[i] , t , k - 1 , 0);\n\t}\n\tMIN.MVMC();\n\tprintf(\"%lld\" , MIN.MinCost);\n\treturn 0;\n}\n```",
        "postTime": 1609853671,
        "uid": 171554,
        "name": "Reanap",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4209 \u3010\u5b66\u4e60\u5c0f\u7ec4\u3011"
    }
]