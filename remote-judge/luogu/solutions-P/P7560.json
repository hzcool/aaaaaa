[
    {
        "content": "\u4e0d\u662f\u5f88\u61c2\u554a\uff0c\u4e3a\u4ec0\u4e48\u5199 ji segtree \u554a\u3002\n\n\u5177\u4f53\u505a\u6cd5\u697c\u4e0a\u8001\u54e5\u5df2\u7ecf\u5199\u4e86\uff0c\u6211\u53ea\u505a\u4e00\u4e2a\u8865\u5145\uff0c\u56e0\u4e3a\u662f\u5355\u70b9\u67e5\u8be2\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u5c06 segtree \u5199\u6210\u4e00\u68f5\u5b8c\u5168\u610f\u4e49\u7684 leafy tree \u5373\u53ef\uff08\u5c31\u662f\u4e0d\u7528\u5199 pushup \u7684\u610f\u601d\uff09\u3002\n\n\u5927\u6982\u610f\u601d\u5c31\u662f\uff0c\u8fd9\u4e2a segment tree beats\u3002\u9996\u5148\u8fd9\u91cc\u6ca1\u6709\u5fc5\u8981\u771f\u7684\u5199\u4e00\u4e2a\u51fa\u6765\uff0c\u56e0\u4e3a\u6ce8\u610f\u5230\u662f\u5355\u70b9\u8be2\u95ee\u3002\u4f46\u662f\u8fd9\u91cc\u7684\u7ebf\u6bb5\u6811\u6709\u4e00\u4e9b\u4e0d\u540c\u4e8e\u4f20\u7edf\u7684\u7ebf\u6bb5\u6811\uff0c\u5c3d\u7ba1\u4f20\u7edf\u7ebf\u6bb5\u6811\u4e5f\u662f\u4e00\u68f5 leafy tree\uff0c\u4f46\u662f\u8fd9\u91cc\u6811\u7684\u975e\u53f6\u7ed3\u70b9\u4e0a\u662f\u6ca1\u6709\u4fe1\u606f\u9700\u8981\u7ef4\u62a4\u7684\u3002\u53ef\u4ee5\u628a lazy propagation \u548c\u4f60\u7ef4\u62a4\u7684\u5e7a\u534a\u7fa4\u653e\u5230\u4e00\u4e2a\u6570\u7ec4\u6765\u5199\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\n\nconst i64 inf = 1e9;\nint N, M, Q, sz, h, ans[250100];\ni64 dat[250100];\nstruct rec {\n  i64 p, q;\n} lz[524388];\nstruct req {\n  i64 a, b, c, d;\n} q[250100];\nvoid add(int x, i64 v) {\n  for (; x <= N + 1; x += x & -x) dat[x] += v;\n}\nvoid add(int l, int r, i64 v) { add(l, v), add(r + 1, -v); }\ni64 sum(i64 x) {\n  i64 res = 0;\n  for (; x; x -= x & -x) res += dat[x];\n  return res;\n}\nrec composition(rec f, rec v) { return {v.p + f.p, max(v.q + f.p, f.q)}; }\nvoid propagate(int x, rec f) { lz[x] = composition(f, lz[x]); }\nvoid push(int x) {\n  propagate(x * 2, lz[x]), propagate(x * 2 + 1, lz[x]), lz[x] = {0, -inf};\n}\nvoid add(int l, int r, rec f) {\n  assert(0 <= l && l <= r && r <= N);\n  if (l == r) return;\n  l += sz, r += sz;\n  for (int i = h; i >= 1; --i) {\n    if (((l >> i) << i) != l) push(l >> i);\n    if (((r >> i) << i) != r) push((r - 1) >> i);\n  }\n  for (; l < r; l >>= 1, r >>= 1) {\n    if (l & 1) propagate(l++, f);\n    if (r & 1) propagate(--r, f);\n  }\n}\ni64 get(i64 x) {\n  assert(0 <= x && x < N);\n  for (i64 i = h; i >= 1; --i) push((x + sz) >> i);\n  return max(lz[x + sz].p, lz[x + sz].q);\n}\n\nvoid dac(int l, int r, const vector<int>& id) {\n  if (id.empty()) return;\n  if (l == r) {\n    for (auto&& it : id) ans[it] = l;\n    return;\n  }\n  int mid = (l + r) / 2;\n  for (int i = l; i <= mid; ++i)\n    if (q[i].c && q[i].d) add(q[i].a, q[i].b, q[i].d);\n  vector<int> ql, qr;\n  for (auto&& it : id) (sum(q[it].a) >= q[it].b ? ql : qr).emplace_back(it);\n  dac(mid + 1, r, qr);\n  for (int i = l; i <= mid; ++i)\n    if (q[i].c && q[i].d) add(q[i].a, q[i].b, -q[i].d);\n  dac(l, mid, ql);\n}\n\nsigned main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  cin >> N >> M >> Q;\n  h = ceil(log2(N)), sz = 1 << h;\n  for (int i = 0; i <= N; ++i) lz[i + sz] = {0, -inf};\n  vector<int> is;\n  for (i64 o, l, r, c, k, i = 1; i <= Q; ++i) {\n    cin >> o >> l >> r, c = k = 0;\n    if (o == 1)\n      cin >> c >> k, add(l, r, k), add(l - 1, r, {k, 0});\n    else if (o == 2)\n      cin >> k, add(l - 1, r, {-k, 0});\n    else\n      r += sum(l) - get(l - 1), is.emplace_back(i);\n    q[i] = {l, r, c, k};\n  }\n  memset(dat, 0, sizeof(dat)), dac(1, Q + 1, is);\n  for (int i = 1; i <= Q; ++i)\n    if (q[i].c == 0 && q[i].d == 0)\n      cout << q[ans[i] > i ? 0 : ans[i]].c << \"\\n\";\n  return 0;\n}\n```",
        "postTime": 1650069663,
        "uid": 161849,
        "name": "cirnovsky",
        "ccfLevel": 6,
        "title": "qwwwwq"
    },
    {
        "content": "## \u9898\u76ee\u5206\u6790\n\n\u4e00\u4e2a\u597d\u60f3\u597d\u5199\u4e14\u5e38\u6570\u4e0d\u5927\u7684\u5355 $\\log$ \u505a\u6cd5\u3002\n\n\u79bb\u5f00\u4e8b\u4ef6\u4e0d\u597d\u5904\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u5148\u628a\u6bcf\u4e2a\u767d\u5ad6\u4e8b\u4ef6\u524d\u79bb\u5f00\u7684\u4eba\u6570\u6c42\u51fa\u6765\uff0c\u8bb0\u4e3a $w$\uff0c\u7136\u540e\u628a\u767d\u5ad6\u4e8b\u4ef6\u53d8\u6210 $(A,B+w)$ \u5c31\u8f6c\u5316\u6210\u4e86\u6027\u8d28 $C$\u3002\u800c\u6211\u4eec\u53d1\u73b0\u79bb\u5f00\u4eba\u6570\u7b49\u4e8e\u52a0\u5165\u4eba\u6570\u51cf\u53bb\u5269\u4f59\u4eba\u6570\u3002\u524d\u8005\u662f\u533a\u95f4\u52a0\u5355\u70b9\u67e5\u677f\u5b50\uff0c\u7528\u7ebf\u6bb5\u6811\u5373\u53ef\uff1b\u540e\u8005\u662f\u533a\u95f4\u52a0\u533a\u95f4\u53d6 $\\max$ \u5355\u70b9\u67e5\u95ee\u9898\uff0c\u7ecf\u8fc7\u540c\u5b66\u63d0\u9192\u53d1\u73b0\u4e5f\u662f\u7ebf\u6bb5\u6811\u677f\u5b50\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u6211\u4eec\u7528\u6807\u8bb0 $(a,m)$ \u8868\u793a\u539f\u5148\u7684\u503c $x$ \u53d8\u6210\u4e86 $\\max (x+a,m)$\uff0c\u8003\u8651\u6807\u8bb0\u7684\u590d\u5408\uff0c\u628a $(a',m')$ \u5408\u5e76\u5230 $(a,m)$ \u4e0a\u4f1a\u4f7f\u5176\u53d8\u4e3a $(a+a',\\max(m+a',m'))$\uff0c\u4e8e\u662f\u76f4\u63a5\u7ef4\u62a4\uff0c\u8be2\u95ee\u65f6\u8fd4\u56de\u53f6\u8282\u70b9\u6807\u8bb0\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(q\\log n)$\u3002\n\n```cpp\nstruct tree\n{\n\tint tagadd,tagmx;\n}tree[1000005];\n\n#define tga(x) tree[x].tagadd\n#define tgm(x) tree[x].tagmx\n\nvoid cz(int ka,int km,int p) {tga(p)+=ka; tgm(p)=max(tgm(p)+ka,km);}\nvoid push_down(int p) {cz(tga(p),tgm(p),ls(p)); cz(tga(p),tgm(p),rs(p)); tga(p)=0; tgm(p)=-1e18;}\n```\n\u518d\u60f3\u6027\u8d28 $C$\uff0c\u6211\u76f4\u63a5\u79d2\u4f1a\u4e00\u4e2a\u4fe9 $\\log$ \u7684\u7ebf\u6bb5\u6811\u5206\u6cbb\u505a\u6cd5\uff0c\u4e0d\u8fc7\u5199\u5230\u4e00\u534a\u53d1\u73b0\u5b8c\u5168\u6ca1\u5fc5\u8981\u3002\n\n\u6211\u4eec\u5148\u8003\u8651\u53ea\u6709\u4e00\u5bb6\u5e97\u7684\u65f6\u5019\u600e\u4e48\u505a\uff0c\u53d1\u73b0\u5bf9\u4e8e\u767d\u5ad6\u4e8b\u4ef6 $(A,B)$\uff0c\u53ea\u9700\u8981\u627e\u5230\u7b2c\u4e00\u4e2a\u52a0\u5165\u4eba\u6570 $>B$ \u7684\u65f6\u523b\u3002\u800c\u4e00\u6b21\u52a0\u5165\u4e8b\u4ef6\u4f1a\u4f7f\u5f97 $[i,q]$ \u8fd9\u4e00\u65f6\u95f4\u8f74\u533a\u57df\u533a\u95f4\u52a0 $k$\uff0c\u90a3\u4e48\u968f\u4fbf\u7ef4\u62a4\u533a\u95f4\u52a0\u540e\u5728\u65f6\u95f4\u8f74\u4e0a\u4e8c\u5206\u5373\u53ef\u3002\n\n\u518d\u8003\u8651\u591a\u5bb6\u5e97\u7684\u60c5\u51b5\u3002\u53d1\u73b0\u4e00\u6b21\u5728\u65f6\u523b $i$ \u8fdb\u884c\u7684\u52a0\u5165\u4e8b\u4ef6 $(l,r,k)$ \u5bf9 $[l,r]$ \u5185\u98df\u54c1\u5e97\u7684\u65f6\u95f4\u8f74\u5f71\u54cd\u662f\u76f8\u540c\u7684\u3002\u6240\u4ee5\u7528\u5dee\u5206\u7684\u601d\u60f3\uff0c\u8be5\u4e8b\u4ef6\u8ba9\u7b2c $l$ \u4e2a\u65f6\u95f4\u8f74\u76f8\u6bd4\u7b2c $l-1$ \u4e2a\u65f6\u95f4\u8f74\u591a\u4e86\u4e00\u4e2a $[i,q]$ \u533a\u95f4\u52a0 $k$\uff0c\u540c\u65f6\u8ba9\u7b2c $r+1$ \u4e2a\u65f6\u95f4\u8f74\u76f8\u6bd4\u7b2c $r$ \u4e2a\u65f6\u95f4\u8f74\u5c11\u4e86\u4e00\u4e2a $[i,q]$ \u533a\u95f4\u52a0 $k$\u3002\u90a3\u4e48\u79bb\u7ebf\u4e0b\u6765\u4ece\u6309\u98df\u54c1\u5e97\u7f16\u53f7\u4ece\u5c0f\u5230\u5927\u8003\u8651\uff0c\u53ea\u9700\u652f\u6301\u533a\u95f4\u52a0\u4e0e\u6839\u636e\u533a\u95f4\u6700\u5927\u503c\u4e8c\u5206\uff0c\u53ef\u4ee5\u76f4\u63a5\u91cd\u590d\u5229\u7528\u524d\u9762\u6c42\u52a0\u5165\u4eba\u6570\u65f6\u4f7f\u7528\u7684\u7ebf\u6bb5\u6811\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n+q\\log q)$\u3002\n\n\u89c6 $n,q$ \u540c\u9636\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log  n)$\uff0c\u53ef\u4ee5\u901a\u8fc7\u672c\u9898\u3002\n\n## \u4ee3\u7801\n\n\u611f\u89c9\u5c31\u5199\u5f97\u633a\u77ed\u7684\u3002\n\n```cpp\n/*\n  author: PEKKA_l  \n */\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define int long long\n\nint n,m,q,flag,u,v,c[250005],k,ans[250005],zt[250005];\nvector <pair<int,int>> Q[250005],cz[250005];\n\nstruct tree1\n{\n\tint maxx,tagadd;\n}tree1[1000005];\n\n#define ls(x) (x<<1)\n#define rs(x) ((x<<1)|1)\n#define m(x) tree1[x].maxx\n#define tg(x) tree1[x].tagadd\n#define md(x,y) ((x+y)>>1)\n#define push_up(x) m(x)=max(m(ls(x)),m(rs(x)))\n\nvoid czadd1(int k,int p) {m(p)+=k; tg(p)+=k;}\nvoid push_down1(int p) {czadd1(tg(p),ls(p)); czadd1(tg(p),rs(p)); tg(p)=0;}\nvoid build1(int l,int r,int p)\n{\n\tm(p)=tg(p)=0; if(l==r) return; int mid=md(l,r); build1(l,mid,ls(p)); build1(mid+1,r,rs(p)); push_up(p);\n}\nvoid czadd1(int l,int r,int x,int y,int k,int p)\n{\n\tif(l>=x&&r<=y) {czadd1(k,p); return;} int mid=md(l,r); push_down1(p);\n\tif(mid>=x) czadd1(l,mid,x,y,k,ls(p)); if(mid<y) czadd1(mid+1,r,x,y,k,rs(p)); push_up(p);\n}\nint ask1(int l,int r,int x,int y,int p)\n{\n\tif(l>=x&&r<=y) return m(p); int mid=md(l,r),nans=0; push_down1(p);\n\tif(mid>=x) nans=max(nans,ask1(l,mid,x,y,ls(p))); if(mid<y) nans=max(nans,ask1(mid+1,r,x,y,rs(p))); return nans;\n}\nint askmn(int l,int r,int k,int p)\n{\n\tif(m(p)<k) return 0; if(l==r) return l; int mid=md(l,r); push_down1(p);\n\tif(m(ls(p))>=k) return askmn(l,mid,k,ls(p)); else return askmn(mid+1,r,k,rs(p));\n}\n\nstruct tree2\n{\n\tint tagadd,tagmx;\n}tree2[1000005];\n\n#define tga(x) tree2[x].tagadd\n#define tgm(x) tree2[x].tagmx\n\nvoid cz2(int ka,int km,int p) {tga(p)+=ka; tgm(p)=max(tgm(p)+ka,km);}\nvoid push_down2(int p) {cz2(tga(p),tgm(p),ls(p)); cz2(tga(p),tgm(p),rs(p)); tga(p)=0; tgm(p)=-1e18;}\nvoid build2(int l,int r,int p)\n{\n\ttgm(p)=-1e18; if(l==r) return; int mid=md(l,r); build2(l,mid,ls(p)); build2(mid+1,r,rs(p));\n}\nvoid cz2(int l,int r,int x,int y,int ka,int km,int p)\n{\n\tif(l>=x&&r<=y) {cz2(ka,km,p); return;} int mid=md(l,r); push_down2(p);\n\tif(mid>=x) cz2(l,mid,x,y,ka,km,ls(p)); if(mid<y) cz2(mid+1,r,x,y,ka,km,rs(p));\n}\nint ask2(int l,int r,int x,int p)\n{\n\tif(l==r) return max(tga(p),tgm(p)); int mid=md(l,r); push_down2(p);\n\tif(mid>=x) return ask2(l,mid,x,ls(p)); else return ask2(mid+1,r,x,rs(p));\n}\n\nsigned main()\n{\n\tcin>>n>>m>>q; build2(1,n,1); build1(1,n,1);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>flag;\n\t\tif(flag==1)\n\t\t{\n\t\t\tcin>>u>>v>>c[i]>>k; czadd1(1,n,u,v,k,1); cz2(1,n,u,v,k,-1e18,1);\n\t\t\tcz[u].push_back(make_pair(i,k)); cz[v+1].push_back(make_pair(i,-k));\n\t\t}\n\t\telse if(flag==2) {cin>>u>>v>>k; cz2(1,n,u,v,-k,0,1);}\n\t\telse {cin>>u>>v; Q[u].push_back(make_pair(i,v+ask1(1,n,u,u,1)-ask2(1,n,u,1))); zt[i]=1;}\n\t}\n\tbuild1(1,q,1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto j:cz[i]) czadd1(1,q,j.first,q,j.second,1);\n\t\tfor(auto j:Q[i]) ans[j.first]=askmn(1,q,j.second,1);\n\t}\n\tfor(int i=1;i<=q;i++) if(zt[i]) cout<<c[ans[i]>i?0:ans[i]]<<endl;\n}\n```\n",
        "postTime": 1681914868,
        "uid": 529697,
        "name": "PEKKA_l",
        "ccfLevel": 6,
        "title": "P7560 \u9898\u89e3"
    },
    {
        "content": "\u4ece C9 \u7237\u7684[\u6574\u4f53\u4e8c\u5206\u6559\u7a0b](https://www.luogu.com.cn/blog/78372/parallel-binsearch)\u6765\u7684\u3002\u5f3a\u70c8\u63a8\u8350\uff01\n\n---\n\n\u5ba3\u4f20\u4e00\u4e0b Cirno_9 \u5355 $\\log$ \u7684\u6574\u4f53\u4e8c\u5206\u3002\n\n\u524d\u9762[\u8fd9\u7bc7\u9898\u89e3](https://www.luogu.com.cn/blog/534654/solution-P7560)\u8bb2\u7684\u975e\u5e38\u6e05\u695a\u3002\u6211\u548c\u4ed6\u4e00\u6837\uff0c\u5148\u7b97\u51fa\u6bcf\u4e2a\u8be2\u95ee\u5bf9\u5e94\u961f\u5217\u7684\u79bb\u5f00\u4eba\u6570\u3002\n\n\u6574\u4f53\u4e8c\u5206\uff0c\u4e8c\u5206\u5230\u7b2c\u51e0\u4e2a\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u4f7f\u8be5\u961f\u5217 **\u52a0\u5165\u4eba\u6570`-`\u79bb\u5f00\u4eba\u6570** \u6709\u5927\u4e8e\u7b49\u4e8e $B$ \u4e2a\u4eba\u3002\u90a3\u6b21\u52a0\u5165\u64cd\u4f5c\u7684\u5bb6\u5ead\u5c31\u662f\u7b54\u6848\u3002\n\n\u4f46\u662f\u6574\u4f53\u4e8c\u5206\u65f6\u5019\uff0c\u6211\u4eec\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u533a\u95f4\u52a0\u7684\u90e8\u5206\u5176\u5b9e\u4e0d\u5fc5\u8981\u3002\n\n\u6bcf\u6b21\u533a\u95f4\u52a0\u53ea\u4f5c\u7528\u4e24\u4e2a\u70b9\u3002\u6bcf\u6b21\u8be2\u95ee\u4f4d\u7f6e $x$ \uff0c\u53ea\u6709 $[1,x]$ \u7684\u70b9\u4f1a\u5f71\u54cd\u4ed6\u3002\n\n\u90a3\u6211\u4eec\u628a\u8fd9\u4e9b\u4f5c\u7528\u70b9\u548c\u8be2\u95ee\u70b9\u5148\u6392\u597d\u5e8f\uff0c\u4e00\u8d77\u653e\u8fdb\u53bb\u4e8c\u5206\uff0c\u3002\u7136\u540e\u987a\u5e8f\u626b\u8fc7\u53bb\uff0c\u8be2\u95ee\u70b9\u4e4b\u524d\u7684\u4f5c\u7528\u7528\u4e00\u4e2a\u53d8\u91cf\uff08\u4ee3\u7801\u91cc\u7684`now`\uff09\u5b58\u8d77\u6765\u5c31\u597d\u4e86\u3002\u5206\u6cbb\u7684\u65f6\u5019\u4e5f\u81ea\u7136\u5730\u4fdd\u6301\u4e86\u6709\u5e8f\u3002\n\n\u51e0\u4e2a\u7ec6\u8282\uff1a\n\n- \u5728 $x$ \u4e0a\u7684\u4f5c\u7528\u70b9\u4f1a\u5f71\u54cd\u8be2\u95ee $x$\uff0c\u6392\u5e8f\u65f6\u5019\u8981\u6ce8\u610f\n\n- \u6ce8\u610f\u5224\u65ad\u4e66\u866b\u4f1a\u4e0d\u4f1a\u88ab\u5403\n\n- ~~\u7136\u540e\u5c31\u60f3\u4e0d\u5230\u7ec6\u8282\u4e86\uff0c\u90fd\u662f\u6bd4\u8f83\u5e73\u51e1\u7684\u7ef4\u62a4~~\n\n\u4eba\u50bb\u5e38\u6570\u5927\uff0c\u597d\u50cf\u548c\u53cc $\\log$ \u8001\u54e5\u4eec\u5dee\u4e0d\u591a /kk\u3002\u6559\u6559\u3002\n\n\u4e0d\u4f1a\u5c01\u88c5\uff0c\u51d1\u5408\u770b\u5427\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nll read()\n{\n\tchar c=getchar(); ll res=0, f=1;\n\twhile(!isdigit(c)) {if(c=='-') f=-1; c=getchar();}\n\twhile(isdigit(c)) {res=(res<<3)+(res<<1)+(c^48); c=getchar();}\n\treturn res*f;\n}\nvoid write(int x)\n{\n\tif(x<0) x=-x, putchar('-');\n\tif(x>9) write(x/10);\n\tputchar(x%10+'0');\n}\n\nconst int N=3e5;\nconst ll inf=1e18;\n\nint n,m,Q;\n\nstruct segtree {ll maxx,atag,btag;} t[N<<2];\n#define ls (pos<<1)\n#define rs (pos<<1|1)\n#define mid ((l+r)>>1)\nvoid pushup(int pos) {t[pos].maxx = max(t[ls].maxx, t[rs].maxx);}\nvoid build(int pos,int l,int r)\n{\n\tt[pos].btag=-inf;\n\tif(l==r) return;\n\tbuild(ls,l,mid); build(rs,mid+1,r);\n}\nvoid change(int pos,segtree x)\n{\n\tt[pos].maxx+=x.atag; t[pos].atag+=x.atag;\n\tif(t[pos].btag>-inf) t[pos].btag+=x.atag;\n\tt[pos].maxx=max(t[pos].maxx, x.btag);\n\tt[pos].btag=max(t[pos].btag, x.btag);\n}\nvoid spread(int pos)\n{\n\tchange(ls,t[pos]); change(rs,t[pos]);\n\tt[pos].atag=0, t[pos].btag=-inf;\n}\nint ql,qr; segtree Tag;\nvoid updata(int pos,int l,int r)\n{\n\tif(ql<=l && r<=qr) {change(pos,Tag); return;}\n\tspread(pos);\n\tif(ql<=mid) updata(ls,l,mid);\n\tif(qr>mid) updata(rs,mid+1,r);\n\tpushup(pos);\n}\nll ask(int pos,int l,int r)\n{\n\tif(l==r) return t[pos].maxx;\n\tspread(pos);\n\tif(ql<=mid) return ask(ls,l,mid);\n\telse return ask(rs,mid+1,r);\n}\n#undef ls\n#undef rs\n#undef mid\n\nll c[N];\nint lowbit(int x) {return x & -x;}\nvoid updata_c(int x,ll y) {for(;x<=n;x+=lowbit(x)) c[x]+=y;}\nll ask_c(int x) {ll res=0; for(;x;x-=lowbit(x)) res+=c[x]; return res;}\n\nstruct Que {int l; ll x; int id,tp;} lx[N<<1]; int q,answer[N];\nbool cmp(Que x, Que y) {return x.l==y.l ? x.tp<y.tp : x.l<y.l;}\n\nvoid solve(int ql,int qr,int vl,int vr)\n{\n\tvector<Que> Left; vector<Que> Right;\n//\tprintf(\"\\n%d %d %d %d: !\\n\",ql,qr,vl,vr);\n\tint mid=(vl+vr)>>1; ll now=0;\n\tfor(int i=ql;i<=qr;++i)\n\t{\n//\t\tprintf(\"%d %lld %d %d\\n\",lx[i].l,lx[i].x,lx[i].id,lx[i].tp);\n\t\tif(!lx[i].tp)\n\t\t{\n\t\t\tif(lx[i].id<=mid) now+=lx[i].x, Left.push_back(lx[i]);\n\t\t\telse Right.push_back(lx[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(now>=lx[i].x) answer[lx[i].id]=mid, Left.push_back(lx[i]);\n\t\t\telse lx[i].x-=now, Right.push_back(lx[i]);\n\t\t}\n\t}\n\tint i=ql;\n\tfor(Que x : Left) lx[i++]=x;\n\tfor(Que x : Right) lx[i++]=x;\n\tif(vl==vr) return;\n\tsolve(ql,ql+Left.size()-1,vl,mid);\n\tsolve(ql+Left.size(),qr,mid+1,vr);\n}\n\nint jt[N];\nint main()\n{\n\tn=read(), m=read(), Q=read();\n\tbuild(1,1,n);\n\tfor(int i=1,type;i<=Q;++i)\n\t{\n\t\ttype=read();\n\t\tint y; ll x;\n\t\tif(type==1)\n\t\t{\n\t\t\tql=read(), qr=read(), y=read(), x=read();\n\t\t\tlx[++q]=(Que){ql,x,i,0}; lx[++q]=(Que){qr+1,-x,i,0};\n\t\t\tupdata_c(ql,x); updata_c(qr+1,-x);\n\t\t\tjt[i]=y;\n\t\t\tTag=(segtree){0,x,-inf};\n\t\t\tupdata(1,1,n);\n\t\t}\n\t\tif(type==2)\n\t\t{\n\t\t\tql=read(), qr=read(), x=read();\n\t\t\tTag=(segtree){0,-x,0}; updata(1,1,n);\n\t\t}\n\t\tif(type==3)\n\t\t{\n\t\t\tql=read(), x=read();\n\t\t\tlx[++q]=(Que){ql, ask_c(ql)-ask(1,1,n)+x, i, 1};\n\t\t}\n\t}\n\tlx[++q]=(Que){1,inf,Q+1,0};\n\tsort(lx+1,lx+q+1,cmp);\n\tsolve(1,q,1,Q+1);\n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tif(answer[i])\n\t\t{\n\t\t\tif(answer[i]<i) write(jt[answer[i]]), putchar('\\n');\n\t\t\telse puts(\"0\");\n\t\t}\n\t}\n}\n```",
        "postTime": 1672035630,
        "uid": 83353,
        "name": "XLao",
        "ccfLevel": 6,
        "title": "P7560 [JOISC 2021 Day1] \u30d5\u30fc\u30c9\u30b3\u30fc\u30c8 \u9898\u89e3"
    },
    {
        "content": "### Solve\n\n\u300c\u79bb\u5f00\u4e8b\u4ef6\u300d\u53ef\u4ee5\u5ffd\u7565\u3002\u53ea\u9700\u8981\u7ef4\u62a4\u5f53\u524d\u79bb\u5f00\u4e86\u591a\u5c11\u4eba\u5c31\u53ef\u4ee5\u3002\u904d\u5386\u6240\u6709\u64cd\u4f5c\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u4e00\u5bb6\u5e97\u4e00\u5171\u8fd8\u5269\u591a\u5c11\u4eba\uff08\u533a\u95f4\u51cf\uff0c\u533a\u95f4\u5bf9 $0$ \u53d6 $\\max$\uff0c\u5355\u70b9\u67e5\u8be2\uff0c\u7c7b\u4f3c [P8024](https://www.luogu.com.cn/problem/P8024)\uff09\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u4e00\u5171\u6765\u8fc7\u591a\u5c11\u4eba\uff08\u533a\u95f4\u52a0\uff0c\u5355\u70b9\u67e5\u8be2\uff09\uff0c\u79bb\u5f00\u7684\u4eba\u6570 $\\red{\\bm{=}}$ \u4e00\u5171\u6765\u8fc7\u7684\u4eba\u6570 $\\red{\\bm{-}}$ \u8fd8\u5269\u7684\u4eba\u6570\u3002\n\n\u56e0\u4e3a\u767d\u5ad6\u5230\u7269\u54c1\u7684\u4eba\u4e00\u5b9a\u662f\u4e4b\u524d\u67d0\u4e2a\u300c\u52a0\u5165\u4e8b\u4ef6\u300d\u52a0\u5165\u7684\u4eba\uff0c\u79bb\u7ebf\u4e0b\u6765\u6240\u6709\u7684\u300c\u767d\u5ad6\u4e8b\u4ef6\u300d\uff0c\u5728\u300c\u52a0\u5165\u4e8b\u4ef6\u300d\u4e2d\u6574\u4f53\u4e8c\u5206\u5373\u53ef\u3002\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n, m, q, ans[250010];\nstruct Ques {\n\tint id, l, r, c, k, a, b, pre;\n} add[250010];\nstruct Bit {\n\tint w[250010];\n\tint lowbit(int x) { return x & (-x); }\n\tvoid clear() {\n\t\tmemset(w, 0, sizeof w);\n\t}\n\tvoid add(int p, int x) {\n\t\tfor (int i = p; i <= n; i += lowbit(i)) w[i] += x;\n\t}\n\tint query(int p) {\n\t\tint res = 0;\n\t\tfor (int i = p; i; i -= lowbit(i)) res += w[i];\n\t\treturn res;\n\t}\n} bit;\nstruct Seg {\n\tint sum[1000010], add[1000010], top[1000010];\n\tbool InRange(int l, int r, int L, int R) { return L <= l && R >= r; }\n\tbool OutoRange(int l, int r, int L, int R) { return r < L || R < l; }\n\t// add -> max\n\tvoid build(int u, int l, int r) {\n\t\ttop[u] = -1e18;\n\t\tif (l == r) return;\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);\n\t}\n\tvoid makeadd(int u, int l, int r, int x) {\n\t\tadd[u] += x; sum[u] += x;\n\t\tif (top[u] >= -1e18) top[u] += x;\n\t}\n\tvoid makemax(int u, int l, int r, int x) {\n\t\ttop[u] = max(top[u], x); sum[u] = max(sum[u], x);\n\t}\n\tvoid pushdown(int u, int l, int r) {\n\t\tint mid = (l + r) >> 1;\n\t\tmakeadd(u << 1, l, mid, add[u]), makeadd(u << 1 | 1, mid + 1, r, add[u]);\n\t\tmakemax(u << 1, l, mid, top[u]), makemax(u << 1 | 1, mid + 1, r, top[u]);\n\t\tadd[u] = 0, top[u] = -1e18;\n\t}\n\tvoid updadd(int u, int l, int r, int L, int R, int x) {\n\t\tif (InRange(l, r, L, R)) makeadd(u, l, r, x);\n\t\telse if (!OutoRange(l, r, L, R)) {\n\t\t\tpushdown(u, l, r);\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tupdadd(u << 1, l, mid, L, R, x), updadd(u << 1 | 1, mid + 1, r, L, R, x);\n\t\t}\n\t}\n\tvoid updmax(int u, int l, int r, int L, int R, int x) {\n\t\tif (InRange(l, r, L, R)) makemax(u, l, r, x);\n\t\telse if (!OutoRange(l, r, L, R)) {\n\t\t\tpushdown(u, l, r);\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tupdmax(u << 1, l, mid, L, R, x), updmax(u << 1 | 1, mid + 1, r, L, R, x);\n\t\t}\n\t}\n\tint query(int u, int l, int r, int p) {\n\t\tif (l == r) return sum[u];\n\t\tpushdown(u, l, r);\n\t\tint mid = (l + r) >> 1;\n\t\tif (p <= mid) return query(u << 1, l, mid, p); else return query(u << 1 | 1, mid + 1, r, p);\n\t}\n} seg;\nvoid solve(vector<Ques> q, int l, int r, int tql) {\n\tif (q.empty()) return;\n\tif (l == r) {\n\t\tif (l <= tql) bit.add(add[l].l, add[l].k), bit.add(add[l].r + 1, -add[l].k);\n\t\tfor (int i = 0; i < q.size(); i++) {\n\t\t\tint cnt = bit.query(q[i].a);\n\t\t\tif (q[i].pre != 0 && cnt >= q[i].b) ans[q[i].id] = l; else ans[q[i].id] = 0;\n\t\t}\n\t\tif (l <= tql) bit.add(add[l].l, -add[l].k), bit.add(add[l].r + 1, add[l].k);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tfor (int i = l; i <= min(mid, tql); i++) bit.add(add[i].l, add[i].k), bit.add(add[i].r + 1, -add[i].k);\n\tvector<Ques> ql, qr;\n\tfor (int i = 0; i < q.size(); i++) {\n\t\tif (q[i].pre <= mid) ql.push_back(q[i]);\n\t\telse {\n\t\t\tint cnt = bit.query(q[i].a);\n\t\t\tif (cnt >= q[i].b) {\n\t\t\t\tql.push_back(q[i]);\n\t\t\t} else {\n\t\t\t\tq[i].b -= cnt;\n\t\t\t\tqr.push_back(q[i]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = l; i <= min(mid, tql); i++) bit.add(add[i].l, -add[i].k), bit.add(add[i].r + 1, add[i].k);\n\tsolve(ql, l, mid, tql), solve(qr, mid + 1, r, tql);\n}\nsigned main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n >> m >> q;\n\tseg.build(1, 1, n);\n\tint cnt = 0;\n\tint tot = 0;\n\tvector<Ques> p;\n\twhile (q--) {\n\t\tint op;\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tQues a;\n\t\t\tcin >> a.l >> a.r >> a.c >> a.k;\n\t\t\tadd[++cnt] = a; bit.add(a.l, a.k), bit.add(a.r + 1, -a.k);\n\t\t\tseg.updadd(1, 1, n, a.l, a.r, a.k);\n\t\t} else if (op == 2) {\n\t\t\tint l, r, k;\n\t\t\tcin >> l >> r >> k;\n\t\t\tseg.updadd(1, 1, n, l, r, -k); seg.updmax(1, 1, n, l, r, 0);\n\t\t} else {\n\t\t\tQues a;\n\t\t\tcin >> a.a >> a.b;\n\t\t\ta.id = ++tot; a.pre = cnt;\n\t\t\ta.b += bit.query(a.a) - seg.query(1, 1, n, a.a); p.push_back(a);\n\t\t}\n\t}\n\tbit.clear();\n\tsolve(p, 1, cnt + 1, cnt);\n\tadd[0].c = add[cnt + 1].c = 0;\n\tfor (int i = 1; i <= tot; i++) cout << add[ans[i]].c << \"\\n\"; \n\treturn 0;\n} \n```\n",
        "postTime": 1670658523,
        "uid": 534654,
        "name": "Network_Error",
        "ccfLevel": 0,
        "title": "P7560 [JOISC 2021 Day1] \u30d5\u30fc\u30c9\u30b3\u30fc\u30c8 \u9898\u89e3"
    },
    {
        "content": "~~\u6a21\u62df\u8d5b\u524d\u5077\u8fc7\u8fd8\u4e0d\u4f1a\u505a\u7684\u5c51~~\u3002\n\n\u8f7b\u8f7b\u8f7b\u5de5\u4e1a\u8fd8\u975e\u5e38\u597d\u7406\u89e3\uff0c\u611f\u8c22 @houzhiyuan \u5de8\u4f6c\u3002\n\n## Problem\n\n$n$ \u5bb6\u5e97\uff0c$m$ \u4e2a\u56e2\u961f\uff0c$q$ \u6b21\u64cd\u4f5c\uff0c\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n\n`1 l r c k` \u8868\u793a $[l,r]$ \u5e97\u6765\u4e86 $k$ \u4e2a\u6765\u81ea $c$ \u56e2\u961f\u7684\u4eba\u6392\u961f\u3002\n\n`2 l r k` \u8868\u793a $[l,r]$ \u6709 $k$ \u4e2a\u4eba\u4ece\u524d\u9762\u6392\u5b8c\u79bb\u5f00\u3002\n\n`3 a b` \u8868\u793a\u8be2\u95ee\u7b2c $a$ \u5bb6\u5e97\u5f53\u524d\u961f\u4f0d\u7b2c $b$ \u4e2a\u4eba\u5c5e\u4e8e\u7684\u56e2\u961f\u3002\n\n$n,q\\le 2.5\\times10^5\\ ,k\\le 10^9\\ ,b\\le 10^{15}$\n### Algorithm 1\n$\\mathcal O(n^2)\\ $ \n\n\u76f4\u63a5\u5f00 $n$ \u4e2a `deque<pair<int,int>>` \u5bf9\u6bcf\u6b21\u8be2\u95ee\u76f4\u63a5\u505a\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u671f\u671b\u5f97\u5206 14pts\u3002\n### Algorithm 2\n\n$m=1$ \u76f8\u5f53\u4e8e\u8be2\u95ee\u5f53\u524d\u961f\u4f0d\u6709\u6ca1\u6709\u4eba\uff0cBIT \u7ef4\u62a4\u5373\u53ef\u3002\n\n\u671f\u671b\u5f97\u5206 21pts\u3002\n\n### Algorithm 3\n\u6ca1\u6709\u5220\u9664\u64cd\u4f5c\uff0c\u53ef\u4ee5\u8003\u8651\u6574\u4f53\u4e8c\u5206\uff1a\n\n\u73b0\u5728\u6211\u4eec\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u5bf9\u6bcf\u4e2a\u8be2\u95ee\u6c42\u5176\u5bf9\u5e94\u7684\u7b54\u6848\u5728\u54ea\u6b21\u64cd\u4f5c $1$\u3002\n\n\u5df2\u77e5\u96c6\u5408 $S$ \u7684\u7b54\u6848\u5168\u90e8\u4f4d\u4e8e\u533a\u95f4 $[l,r]$\uff0c\u8003\u8651\u6c42\u51fa $mid =\\dfrac{l+r}{2}$ \u65f6\u6bcf\u4e2a\u961f\u5217\u7684\u957f\u5ea6\uff0c\u7136\u540e\n\u5c06\u80fd\u786e\u5b9a\u7b54\u6848 $\\le mid$ \u7684\u8be2\u95ee\u548c $\\gt mid$ \u7684\u5206\u6210\u4e24\u534a\uff0c\u7136\u540e\u7ee7\u7eed\u9012\u5f52\u3002\n\n\u671f\u671b\u5f97\u5206 13pts\u3002\n\n\u8fd9\u65f6\u5019\u95ee\u9898\u663e\u73b0\u51fa\u6765\u4e86\uff0c\u5220\u9664\u64cd\u4f5c\u5bf9 $0$ \u53d6 $\\max$ \u5f88\u96be\u5904\u7406\u3002\n\n**Trick:** \u8f6c\u6362\u4e00\u4e0b\uff0c\u5047\u8bbe\u5220\u9664\u64cd\u4f5c\u7684\u6570\u6ca1\u6709\u5220\u9664\uff0c\u800c\u662f\u5728\u8be2\u95ee\u7684\u65f6\u5019\u52a0\u4e0a\u5220\u9664\u7684\u4eba\u3002\n\n$\\mathcal O(n\\log^2n)$\n\n\u73b0\u5728\u5c31\u53ef\u4ee5\u7528\u6574\u4f53\u4e8c\u5206\u6c42\u7b54\u6848\u4e86\u3002\n\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b `max(x+a,b)` \u5c31\u80fd\u6c42\u51fa\u5b9e\u9645\u8be2\u95ee\u7684\u70b9\u4e86\u3002\n\n$\\mathcal O(n\\log n)$\n\n\u628a\u6574\u4f53\u4e8c\u5206\u6362\u6210\u7ebf\u6bb5\u6811\u5206\u6cbb\u5c31\u80fd\u505a\u5230\u3002\n\n\u671f\u671b\u5f97\u5206 100pts\u3002\n### Algorithm 4\n**\u8f7b\u5de5\u4e1a\uff1a** \u628a\u65f6\u95f4\u8f74\u548c\u5e97\u53cd\u4e00\u4e0b\uff0c\u4ece\u7b2c $1$ \u5bb6\u5e97\u5230\u7b2c $n$ \u5bb6\u5e97\u505a\u4e00\u904d\u626b\u63cf\u7ebf\u3002\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u5b9e\u9645\u4e0a\u6bcf\u6b21\u5220\u9664\u64cd\u4f5c\u662f\u5bf9\u4e00\u6bb5\u540e\u7f00\u4ea7\u751f\u8d21\u732e\uff0c\u8fd9\u6837\u76f4\u63a5\u7528\u4e00\u9897\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6700\u5c0f\u503c\uff0c\u7136\u540e\u6bcf\u6b21\u8be2\u95ee\u6700\u5c0f\u503c\u5c31\u662f\u4e0a\u9762 Trick \u91cc\u5220\u9664\u7684\u4eba\u6570\u4e86\u3002\n\n\u7136\u540e\u76f4\u63a5\u5728\u53e6\u4e00\u9897\u8bb0\u5f55\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u51fa\u7b2c\u4e00\u4e2a\u5927\u4e8e\u7b49\u4e8e \u5220\u9664\u4eba\u6570+\u5f53\u70b9\u4eba\u6570 \u7684\u4eba\u7fa4\u7f16\u53f7\u5373\u53ef\u3002\n\n\u4e24\u9897\u7ebf\u6bb5\u6811\u90fd\u53ea\u8981\u7ef4\u62a4 $\\max$ \u6216 $\\min$\uff0c\u76f4\u63a5\u7528\u4e00\u4e2a\u7ed3\u6784\u4f53\u5c31\u884c\u4e86\u3002\n\n## Code\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define ri register\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\nusing namespace std;\ntemplate<typename T_>void operator+=(vector<T_>&x,const T_&y){x.push_back(y);}\nconst int N=2.5e5+7;\nconst ll inf=1e18;\nint n,m,q,id[N],ans[N];\nll B;\nstruct SegmentTree{\n\tll t[N<<2],mi[N<<2],mx[N<<2],lzy[N<<2];\n\tvoid push_up(int rt){\n\t\tmx[rt]=max(mx[rt<<1],mx[rt<<1|1]);\n\t\tmi[rt]=min(mi[rt<<1],mi[rt<<1|1]); \n\t}\n\tvoid f(int rt,ll k){mi[rt]+=k,t[rt]+=k,mx[rt]+=k,lzy[rt]+=k;}\n\tvoid push_down(int rt){\n\t\tif(!lzy[rt])return;\n\t\tf(rt<<1,lzy[rt]),f(rt<<1|1,lzy[rt]);\n\t\tlzy[rt]=0; \n\t}\n\tll query(int x,int l,int r,int rt){\n\t\tif(l==r)return t[rt];\n\t\tpush_down(rt);int mid=(l+r)>>1;\n\t\tif(x<=mid)return query(x,l,mid,rt<<1);\n\t\tif(x>mid) return query(x,mid+1,r,rt<<1|1);\n\t\treturn-1;\n\t}\n\tll qmi(int L,int R,int l,int r,int rt){\n\t\tif(L<=l&&r<=R)return mi[rt];\n\t\tpush_down(rt);int mid=(l+r)>>1;ll res=inf;\n\t\tif(L<=mid)res=min(res,qmi(L,R,l,mid,rt<<1));\n\t\tif(R>mid) res=min(res,qmi(L,R,mid+1,r,rt<<1|1));\n\t\treturn res;\n\t}\n\tint find(int L,int R,ll x,int l,int r,int rt){\n\t\tif(mx[rt]<x)return 0;\n\t\tif(l==r)return id[l];\n\t\tpush_down(rt);int mid=(l+r)>>1;\n\t\tif(L<=l&&r<=R){\n\t\t\tif(mx[rt<<1|1]>=x)return find(L,R,x,mid+1,r,rt<<1|1);\n\t\t\treturn find(L,R,x,l,mid,rt<<1);\n\t\t}else if(R>mid){\n\t\t\tint k=find(L,R,x,mid+1,r,rt<<1|1);\n\t\t\tif(k)return k;\n\t\t}\n\t\treturn find(L,R,x,l,mid,rt<<1);\n\t}\n\tvoid update(int L,int R,int k,int l,int r,int rt){\n\t\tif(L<=l&&r<=R)return f(rt,k);\n\t\tpush_down(rt);int mid=(l+r)>>1;\n\t\tif(L<=mid)update(L,R,k,l,mid,rt<<1);\n\t\tif(R>mid) update(L,R,k,mid+1,r,rt<<1|1);\n\t\tpush_up(rt);\n\t}\n}T1,T2;\nvector<pair<int,int>>ad[N],del[N];\nvector<pair<int,ll>>Q[N];\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\tcin>>n>>m>>q;\n\tfor(int i=1,op,l,r,c,k;i<=q;i++){\n\t\tcin>>op;\n\t\tswitch(op){\n\t\t\tcase 1:\n\t\t\t\tcin>>l>>r>>c>>k,id[i]=c;\n\t\t\t\tad[l]+={i,k},ad[r+1]+={i,-k};\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcin>>l>>r>>k;\n\t\t\t\tdel[l]+={i,-k},del[r+1]+={i,k};\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcin>>l>>B,Q[l]+={i,B};\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tmemset(ans,-1,sizeof(ans));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(auto j:ad[i])\n\t\t\tT1.update(j.fi,q,j.se,1,q,1),T2.update(1,j.fi,j.se,1,q,1);\n\t\tfor(auto j:del[i])T1.update(j.fi,q,j.se,1,q,1);\n\t\tfor(auto j:Q[i]){\n\t\t\tll x=T1.query(j.fi,1,q,1)-min(T1.qmi(1,j.fi,1,q,1),0ll),y=j.se;\n\t\t\tif(y>x)ans[j.fi]=0;\n\t\t\telse{\n\t\t\t\tx=x-y+1;\n\t\t\t\tans[j.fi]=T2.find(1,j.fi,x+T2.query(j.fi,1,q,1),1,q,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=q;i++)\n\t\tif(~ans[i])cout<<ans[i]<<'\\n';\n\treturn 0;\n}\n```",
        "postTime": 1666423801,
        "uid": 262322,
        "name": "panyanppyy",
        "ccfLevel": 5,
        "title": "P7560"
    },
    {
        "content": "\u5148\u819c\u62dc\u697c\u4e0a 7k \u4ee3\u7801\u7684\u795e\u4ed9\u3002\n\n\u8fd9\u91cc\u63d0\u4f9b\u4e00\u4e2a\u8f7b\u5de5\u4e1a\u7684\u505a\u6cd5\u3002\n\n\u9996\u5148\u8003\u8651\u6ca1\u6709\u79bb\u5f00\u64cd\u4f5c\uff0c\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u6211\u4eec\u53ea\u9700\u8981\u77e5\u9053\u6700\u65e9\u5728\u54ea\u4e00\u6b21\u64cd\u4f5c\u961f\u5217 $A$ \u7684\u5927\u5c0f $\\ge B$ \u3002\n\n\u8fd9\u53ef\u4ee5\u5bf9\u6240\u6709\u8be2\u95ee\u79bb\u7ebf\uff0c\u7136\u540e\u5c06\u6bcf\u4e2a\u8be2\u95ee\u6302\u5728\u5bf9\u5e94\u7684\u4f4d\u7f6e\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u4e2d\u8be2\u95ee\u7684\u6700\u5c0f\u503c\u3002\n\n\u8fd9\u65f6\u4e00\u4e2a\u52a0\u5165\u64cd\u4f5c\uff0c\u7b49\u4ef7\u4e8e\u533a\u95f4\u51cf\uff0c\u5f53\u67d0\u4e2a\u4f4d\u7f6e $\\le 0$ \u65f6\uff0c\u8be5\u4f4d\u7f6e\u5bf9\u5e94\u8be2\u95ee\u7684\u7b54\u6848\u5c31\u662f\u5f53\u524d\u64cd\u4f5c\u7684\u6807\u53f7 $C$ \u3002\u6ce8\u610f\u4e00\u4e2a\u4f4d\u7f6e\u53ef\u4ee5\u6302\u591a\u4e2a\u8be2\u95ee\uff0c\u5f00 ``vector`` \u8bb0\u5f55\u3002\n\n\u4e00\u4e2a\u8be2\u95ee\u6700\u591a\u53ea\u6709\u4e00\u6b21\u4ece $>0$ \u5230 $\\le 0$ \uff0c\u6240\u4ee5\u5747\u644a\u7ebf\u6bb5\u6811\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal{O}((N+Q)\\log N)$ \u3002\u79bb\u7ebf\u540e\u7ebf\u6bb5\u6811\u4e8c\u5206\u5e94\u8be5\u4e5f\u53ef\u4ee5\uff0c\u672c\u8d28\u4e0d\u53d8\u3002\n\n\u73b0\u5728\u8003\u8651\u5b58\u5728\u79bb\u5f00\u64cd\u4f5c\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5f53\u524d\u8be2\u95ee\u4e4b\u524d\u961f\u5217\u5220\u9664\u4e86\u591a\u5c11\u4e2a\u6570\uff0c\u5219\u53ef\u4ee5\u628a\u95ee\u9898\u8f6c\u6362\u4e3a\u6ca1\u6709\u79bb\u5f00\u64cd\u4f5c\u3002\u56e0\u4e3a\u5047\u5b9a\u5220\u9664\u4e86 $k$ \u4e2a\u6570\uff0c\u76f8\u5f53\u4e8e\u67e5\u8be2\u7b2c $B+k$ \u4e2a\u52a0\u5165\u961f\u5217\u7684\u6570 \u3002 \n\n\u7ee7\u7eed\u63a8\u5bfc\uff0c\u5982\u679c\u6211\u4eec\u77e5\u9053\u5f53\u524d\u961f\u5217\u7684\u5927\u5c0f\uff0c\u8fd8\u77e5\u9053\u6709\u591a\u5c11\u6570\u5165\u8fc7\u961f\uff0c\u5c31\u80fd\u5f97\u5230\u51fa\u961f\u7684\u6570\u7684\u4e2a\u6570\u3002\n\n\u540e\u8005\u53ef\u4ee5\u76f4\u63a5\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u533a\u95f4\u52a0\uff0c\u5355\u70b9\u67e5\u8be2\u3002\n\n\u524d\u8005\u9700\u8981\u652f\u6301\n- \u533a\u95f4\u52a0\n- \u533a\u95f4\u51cf\n- \u533a\u95f4\u5bf9 $0$ \u53d6 $\\max$\n\n\u76f4\u63a5\u5957\u533a\u95f4\u6700\u503c\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u5177\u4f53\u505a\u6cd5\u662f\u5bf9\u6bcf\u4e2a\u4f4d\u7f6e\u7ef4\u62a4\u4e8c\u5143\u6807\u8bb0 $(p,q)$\uff0c\u6ce8\u610f\u8fd9\u4e24\u4e2a\u5143\u7d20\u662f\u4e00\u8d77\u7684\uff0c\u8868\u793a\u533a\u95f4\u91cc\u7684\u6570 $+p$ \u540e\u5bf9 $q$ \u53d6 $\\max$\u3002\n\n\u5408\u5e76\u4e24\u4e2a\u6807\u8bb0 $(u,v),(p,q)$ \uff0c\u6ce8\u610f\u6709\u73b0\u540e\u987a\u5e8f\uff0c\u624b\u7b97\u4e00\u4e0b\u5f97\u5230\u6807\u8bb0 $(u+p,\\max\\{v+p,q\\})$ \u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}((N+Q)\\log N)$ \uff0c\u7565\u4f18\u4e8e\u7ebf\u6bb5\u6811\u4e8c\u5206\u7684 $\\mathcal{O}((N+Q)\\log (N+Q))$ \u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define pre(i,a,b) for(int i=a;i>=b;i--)\n#define N 250005\n#define inf 0x3f3f3f3f3f3f3f3fLL\n#define int long long\ntypedef long long ll;\nusing namespace std;\nint n,m,ans[N],idx,c[N];\ninline void add(int x,int val){for(;x<=n;x+=x&-x)c[x]+=val;}\ninline int ask(int x){int sum=0;for(;x;x-=x&-x)sum+=c[x];return sum;}\n#define L a[x].l\n#define R a[x].r\n#define ls (x<<1)\n#define rs (ls|1)\n#define T a[x].tag\nnamespace seg1{\n\tstruct node{\n\t\tint l,r;ll p,q;\n\t}a[N<<2];\n\tvoid build(int x,int l,int r){\n\t\tL=l;R=r;a[x].p=a[x].q=0;\n\t\tif(l==r)return;\n\t\tint mid=(l+r)>>1;\n\t\tbuild(ls,l,mid);build(rs,mid+1,r);\n\t}\n\tvoid pushup(int x,ll u,ll v){a[x].p+=u;a[x].q=max(v,a[x].q+u);}\n\tvoid down(int x){if(a[x].p||a[x].q)pushup(ls,a[x].p,a[x].q),pushup(rs,a[x].p,a[x].q),a[x].p=a[x].q=0;}\n\tvoid add(int x,int l,int r,int val){\n\t\tif(L>=l&&R<=r)pushup(x,val,0);\n\t\telse{\n\t\t\tdown(x);int mid=(L+R)>>1;\n\t\t\tif(mid>=l)add(ls,l,r,val);\n\t\t\tif(mid<r)add(rs,l,r,val);\n\t\t}\n\t}\n\tll ask(int x,int pos){\n\t\tif(L==R)return max(a[x].p,a[x].q);\n\t\telse{\n\t\t\tdown(x);int mid=(L+R)>>1;\n\t\t\tif(mid>=pos)return ask(ls,pos);\n\t\t\treturn ask(rs,pos);\n\t\t}\n\t}\n}\nnamespace seg2{\n\tstruct node{\n\t\tint l,r,mn,tag;\n\t}a[N<<2];\n\t#define S a[x].mn\n\tvector<pair<int,int> >u[N];int st[N];\n\tvoid build(int x,int l,int r){\n\t\tL=l,R=r,T=0;\n\t\tif(l==r){if(u[l].size())S=u[l][0].first;else S=inf;}\n\t\telse{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tbuild(ls,l,mid);\n\t\t\tbuild(rs,mid+1,r);\n\t\t\tS=min(a[ls].mn,a[rs].mn);\n\t\t}\n\t}\n\tvoid pushup(int x,int val){T+=val;S+=val;}\n\tvoid down(int x){if(T)pushup(ls,T),pushup(rs,T),T=0;}\n\tvoid add(int x,int l,int r,int val){\n\t\tif(L>=l&&R<=r)pushup(x,val);\n\t\telse{\n\t\t\tdown(x);int mid=(L+R)>>1;\n\t\t\tif(mid>=l)add(ls,l,r,val);\n\t\t\tif(mid<r)add(rs,l,r,val);\n\t\t\tS=min(a[ls].mn,a[rs].mn);\n\t\t}\n\t}\n\tvoid maintain(int x,int col){\n\t\tif(S>0)return;\n\t\tif(L==R){\n\t\t\twhile(st[L]<(int)u[L].size()&&S<=0){\n\t\t\t\tans[u[L][st[L]++].second]=col;\n\t\t\t\tif(st[L]==(int)u[L].size())S=inf;\n\t\t\t\telse S+=u[L][st[L]].first-u[L][st[L]-1].first;\n\t\t\t}\n\t\t}\n\t\telse down(x),maintain(ls,col),maintain(rs,col),S=min(a[ls].mn,a[rs].mn);\n\t}\n}\nstruct ope{int op,l,r,x,y;}q[N];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);scanf(\"%lld\",&m);\n\tseg1::build(1,1,n);puts(\"No Copy\");\n\trep(i,1,m){\n\t\tscanf(\"%lld%lld%lld\",&q[i].op,&q[i].l,&q[i].r);\n\t\tif(q[i].op==1){\n\t\t\tscanf(\"%lld%lld\",&q[i].x,&q[i].y);\n\t\t\tseg1::add(1,q[i].l,q[i].r,q[i].y);\n\t\t\tadd(q[i].l,q[i].y);add(q[i].r+1,-q[i].y);\n\t\t}\n\t\telse if(q[i].op==2){\n\t\t\tscanf(\"%lld\",&q[i].y);\n\t\t\tseg1::add(1,q[i].l,q[i].r,-q[i].y);\n\t\t}\n\t\telse{\n\t\t\t++idx;int now=seg1::ask(1,q[i].l);\n\t\t\tif(now>=q[i].r)seg2::u[q[i].l].push_back(make_pair(ask(q[i].l)-now+q[i].r,idx));\n\t\t}\n\t}\n\trep(i,1,n)sort(seg2::u[i].begin(),seg2::u[i].end());\n\tseg2::build(1,1,n);\n\trep(i,1,m)if(q[i].op==1){\n\t\tseg2::add(1,q[i].l,q[i].r,-q[i].y);\n\t\tseg2::maintain(1,q[i].x);\n\t}\n\trep(i,1,idx)printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1622350703,
        "uid": 119261,
        "name": "7KByte",
        "ccfLevel": 0,
        "title": "\u3010\u9898\u89e3\u3011[JOISC 2021 Day1] \u30d5\u30fc\u30c9\u30b3\u30fc\u30c8"
    },
    {
        "content": "\u91cd\u5de5\u4e1a\u505a\u6cd5\uff0c\u5e38\u6570\u5de8\u5927\uff0c\u968f\u624b$rank$\u5012\u6570\u7b2c\u4e00\u3002\n\n### \u5409\u8001\u5e08\u7ebf\u6bb5\u6811\u3001\u5e73\u8861\u6811\n\n\u663e\u7136\u6ca1\u6cd5\u76f4\u63a5\u7ef4\u62a4\uff0c\u53c2\u8003[\u3010ZJOI2016\u3011\u5927\u68ee\u6797](https://uoj.ac/problem/195)\u7684\u505a\u6cd5\uff0c\u628a\u8be2\u95ee\u79bb\u7ebf\u4e0b\u6765\uff0c\u5728\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u63d2\u5165\uff0c\u53f3\u7aef\u70b9\u540e\u4e00\u4e2a\u4f4d\u7f6e\u5220\u9664\u3002\n\n\u8fd9\u6837\u7ef4\u62a4\u5e8f\u5217\u53ea\u9700\u8981\u4e00\u68f5\u5e73\u8861\u6811\uff0c\u4f46\u662f\u5bf9\u4e8e\u4e00\u7ec4\u8be2\u95ee\uff0c\u6211\u4eec\u9700\u8981\u51c6\u786e\u5b9a\u4f4d\u5b83\u7684\u4f4d\u7f6e\u3002\u5bb9\u6613\u53d1\u73b0\uff0c\u64cd\u4f5c$2$\u5176\u5b9e\u4e0d\u9700\u8981\u771f\u6b63\u5220\u9664\uff0c\u53ea\u9700\u8981\u628a\u4e4b\u540e\u7684\u8be2\u95ee\u5411\u53f3\u5e73\u79fb\u5373\u53ef\u3002\u6211\u4eec\u5148\u5229\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e0d\u5220\u9664\u60c5\u51b5\u4e0b\u6bcf\u4e2a\u4f4d\u7f6e\u5e8f\u5217\u7684\u957f\u5ea6\uff0c\u518d\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5e26\u5220\u9664\u60c5\u51b5\u4e0b\u6bcf\u4e2a\u4f4d\u7f6e\u5e8f\u5217\u7684\u957f\u5ea6\uff0c\u7136\u540e\u5728\u7b2c\u4e8c\u68f5\u7ebf\u6bb5\u6811\u4e2d\u67e5\u8be2\u4f4d\u7f6e\uff0c\u6839\u636e\u67e5\u8be2\u5230\u7684\u4f4d\u7f6e\u4e0e\u961f\u5c3e\u7684\u76f8\u5bf9\u4f4d\u7f6e\u5173\u7cfb\uff0c\u5373\u53ef\u63a8\u51fa\u4e0d\u5220\u9664\u60c5\u51b5\u4e0b\u7684\u8be2\u95ee\u4f4d\u7f6e\u3002\u7531\u4e8e\u7b2c\u4e8c\u68f5\u7ebf\u6bb5\u6811\u9700\u8981\u6bcf\u4e2a\u4f4d\u7f6e\u968f\u65f6\u5bf9$0$\u53d6$\\max$\uff0c\u9700\u8981\u4f7f\u7528**\u5409\u8001\u5e08\u7ebf\u6bb5\u6811**\u3002\n\n$Code:$\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<vector>\n#define N 250005\n#define IT vector<ask> :: iterator\n#define ll long long\nusing namespace std;\nconst ll INF=191919191919191919;\nint n,m,q,rt,x,y,z,opt,l,r,c,k,cg,ans[N];\nll b;\n#define s(p) tr[p].S\n#define tag(p) tr[p].Tag\nstruct node1\n{\n    ll S,Tag;\n};\nstruct sgt1\n{\n    node1 tr[N << 2];\n    void push_tag(int p,ll y)\n    {\n        s(p)+=y,tag(p)+=y;\n    }\n    void push_down(int p)\n    {\n        push_tag(p << 1,tag(p));\n        push_tag(p << 1 | 1,tag(p));\n        tag(p)=0;\n    }\n    void modify(int p,int l,int r,int x,int y,ll z)\n    {\n        if (l==x && r==y)\n        {\n            push_tag(p,z);\n            return;\n        }\n        push_down(p);\n        int mid(l+r >> 1);\n        if (y<=mid)\n            modify(p << 1,l,mid,x,y,z); else\n        if (x>mid)\n            modify(p << 1 | 1,mid+1,r,x,y,z); else\n            {\n                modify(p << 1,l,mid,x,mid,z);\n                modify(p << 1 | 1,mid+1,r,mid+1,y,z);\n            }\n    }\n    ll calc(int p,int l,int r,int x)\n    {\n        if (l==r)\n            return s(p);\n        push_down(p);\n        int mid(l+r >> 1);\n        if (x<=mid)\n            return calc(p << 1,l,mid,x); else\n            return calc(p << 1 | 1,mid+1,r,x);\n    }\n}s1;\n#define mn(p) tr[p].Mn\n#define se(p) tr[p].Se\n#define tag1(p) tr[p].Tag1\n#define tag2(p) tr[p].Tag2\nstruct node2\n{\n    ll Mn,Se,Tag1,Tag2;\n};\nstruct sgt2\n{\n    node2 tr[N << 2];\n    void build(int p,int l,int r)\n    {\n        mn(p)=0,se(p)=INF;\n        if (l==r)\n            return;\n        int mid(l+r >> 1);\n        build(p << 1,l,mid);\n        build(p << 1 | 1,mid+1,r);\n    }\n    void push_tag(int p,ll t1,ll t2)\n    {\n        mn(p)+=t1,tag1(p)+=t1;\n        if (se(p)!=INF)\n            se(p)+=t2,tag2(p)+=t2;\n    }\n    void push_down(int p)\n    {\n        ll lt(mn(p << 1)),rt(mn(p << 1 | 1));\n        if (lt<=rt)\n            push_tag(p << 1,tag1(p),tag2(p)); else\n            push_tag(p << 1,tag2(p),tag2(p));\n        if (rt<=lt)\n            push_tag(p << 1 | 1,tag1(p),tag2(p)); else\n            push_tag(p << 1 | 1,tag2(p),tag2(p));\n        tag1(p)=tag2(p)=0;\n    }\n    void update(int p)\n    {\n        mn(p)=min(mn(p << 1),mn(p << 1 | 1));\n        if (mn(p << 1)==mn(p << 1 | 1))\n            se(p)=min(se(p << 1),se(p << 1 | 1));else\n        if (mn(p)==mn(p << 1))\n            se(p)=min(se(p << 1),mn(p << 1 | 1)); else\n            se(p)=min(mn(p << 1),se(p << 1 | 1));\n    }\n    void modify1(int p,int l,int r,int x,int y,ll z)\n    {\n        if (l==x && r==y)\n        {\n            push_tag(p,z,z);\n            return;\n        }\n        push_down(p);\n        int mid(l+r >> 1);\n        if (y<=mid)\n            modify1(p << 1,l,mid,x,y,z); else\n        if (x>mid)\n            modify1(p << 1 | 1,mid+1,r,x,y,z); else\n            {\n                modify1(p << 1,l,mid,x,mid,z);\n                modify1(p << 1 | 1,mid+1,r,mid+1,y,z);\n            }\n        update(p);\n    }\n    void modify2(int p,int l,int r,int x,int y,ll z)\n    {\n        if (l==x && r==y)\n        {\n            if (mn(p)>=z)\n                return;\n            if (l==r)\n            {\n                mn(p)=z;\n                se(p)=INF;\n                tag1(p)=tag2(p)=0;\n            } else\n            if (se(p)>z)\n                push_tag(p,z-mn(p),0); else\n                {\n                    push_down(p);\n                    int mid(l+r >> 1);\n                    modify2(p << 1,l,mid,x,mid,z);\n                    modify2(p << 1 | 1,mid+1,r,mid+1,y,z);\n                    update(p);\n                }\n            return;\n        }\n        push_down(p);\n        int mid(l+r >> 1);\n        if (y<=mid)\n            modify2(p << 1,l,mid,x,y,z); else\n        if (x>mid)\n            modify2(p << 1 | 1,mid+1,r,x,y,z); else\n            {\n                modify2(p << 1,l,mid,x,mid,z);\n                modify2(p << 1 | 1,mid+1,r,mid+1,y,z);\n            }\n        update(p);\n    }\n    ll calc(int p,int l,int r,int x)\n    {\n        if (l==r)\n            return mn(p);\n        push_down(p);\n        int mid(l+r >> 1);\n        if (x<=mid)\n            return calc(p << 1,l,mid,x); else\n            return calc(p << 1 | 1,mid+1,r,x);\n    }\n}s2;\nstruct ask\n{\n    int opt;\n    ll t;\n    int c,z;\n    ask () {}\n    ask (int o,ll T,int C,int Z=0):opt(o),t(T),c(C),z(Z) {}\n};\nvector<ask>e[N];\n#undef s\n#define ls(p) a[p].ch[0]\n#define rs(p) a[p].ch[1]\n#define rk(p) a[p].Rk\n#define tim(p) a[p].Tim\n#define val(p) a[p].Val\n#define id(p) a[p].Id\n#define s(p) a[p].S\nstruct node3\n{\n    int ch[2],Rk,Tim,Val,Id;\n    ll S;\n};\nint ct(0);\nstruct fhq_treap\n{\n    node3 a[N];\n    int newnode(int x,int y,int z)\n    {\n        ++ct;\n        ls(ct)=rs(ct)=0,rk(ct)=rand(),tim(ct)=x,val(ct)=y,id(ct)=z;\n        s(ct)=y;\n        return ct;\n    }\n    void update(int p)\n    {\n        s(p)=s(ls(p))+s(rs(p))+val(p);\n    }\n    void split(int &x,int &y,int rt,int k)\n    {\n        if (!rt)\n        {\n            x=y=0;\n            return;\n        }\n        if (tim(rt)<=k)\n        {\n            x=rt;\n            split(rs(rt),y,rs(rt),k);\n        } else\n        {\n            y=rt;\n            split(x,ls(rt),ls(rt),k);\n        }\n        update(rt);\n    }\n    int combine(int x,int y)\n    {\n        if (!x || !y)\n            return x|y;\n        if (rk(x)<rk(y))\n        {\n            rs(x)=combine(rs(x),y);\n            update(x);\n            return x;\n        } else\n        {\n            ls(y)=combine(x,ls(y));\n            update(y);\n            return y;\n        }\n    }\n}T;\nint main()\n{\n    srand(time(NULL));\n    scanf(\"%d%d%d\",&n,&m,&q);\n    s2.build(1,1,n);\n    for (int i=1;i<=q;++i)\n    {\n        scanf(\"%d\",&opt);\n        if (opt==1)\n        {\n            scanf(\"%d%d%d%d\",&l,&r,&c,&k);\n            e[l].push_back(ask(1,k,c,i));\n            e[r+1].push_back(ask(-1,k,c,i));\n            s1.modify(1,1,n,l,r,k);\n            s2.modify1(1,1,n,l,r,k);\n        } else\n        if (opt==2)\n        {\n            scanf(\"%d%d%d\",&l,&r,&k);\n            s2.modify1(1,1,n,l,r,-k);\n            s2.modify2(1,1,n,1,n,0);\n        } else\n        {\n            scanf(\"%d%lld\",&c,&b),++cg;\n            ll g(s2.calc(1,1,n,c));\n            if (g<b)\n                ans[cg]=0; else\n                e[c].push_back(ask(0,s1.calc(1,1,n,c)-(g-b),cg));\n        }\n    }\n    for (int i=1;i<=n;++i)\n    {\n        for (IT it=e[i].begin();it!=e[i].end();++it)\n        {\n            int opt(it->opt);\n            ll t(it->t);\n            int c(it->c),tz(it->z);\n            if (opt==0)\n            {\n                int g(rt);\n                for (;;)\n                {\n                    if (T.s(T.ls(g))>=t)\n                        g=T.ls(g); else\n                    if (T.s(T.ls(g))+T.val(g)>=t)\n                    {\n                        ans[c]=T.id(g);\n                        break;\n                    } else\n                        t-=T.s(T.ls(g))+T.val(g),g=T.rs(g);\n                }\n            } else\n            if (opt==1)\n            {\n                T.split(x,y,rt,tz);\n                rt=T.combine(T.combine(x,T.newnode(tz,t,c)),y);\n            } else\n            {\n                T.split(x,y,rt,tz);\n                T.split(x,z,x,tz-1);\n                rt=T.combine(x,y);\n            }\n        }\n    }\n    for (int i=1;i<=cg;++i)\n        printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n```",
        "postTime": 1619868024,
        "uid": 10341,
        "name": "GK0328",
        "ccfLevel": 0,
        "title": "P7560 [JOISC 2021 Day1] \u30d5\u30fc\u30c9\u30b3\u30fc\u30c8 \u9898\u89e3"
    },
    {
        "content": "# \u626b\u63cf\u7ebf \u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u65f6\u95f4\u7ef4\n\n\u7ecf\u5178\u9898\n\n\u5ba1\u9898\u53d1\u73b0\u9700\u8981\u7ef4\u62a4\u7684\u6709\u70b9\u591a\n\n\u4e3a\u4ec0\u4e48\u8981\u6570\u636e\u673a\u6784\u7ef4\u62a4\u65f6\u95f4\u7ef4\u5462 ~~\u56e0\u4e3a lxl \u8bf4\u7684~~ \u56e0\u4e3a\u5982\u679c\u6b63\u5e38\u7ef4\u62a4\u662f\u533a\u95f4\u4fee \u5355\u70b9\u67e5 \u5f88 dl \u4e0d\u5982\u53bb\u5355\u70b9\u6539 \u533a\u95f4\u67e5\n\n\u4e8c\u7ef4\u5e73\u9762\u7eb5\u8f74\u4ee3\u8868\u65f6\u95f4\u7ef4 \u6a2a\u8f74\u4ee3\u8868 store \u7684 $id$\n\n\u6bcf\u6b21\u8fdb\u5165 $x$ \u4e2a\u7f16\u53f7\u4e3a $ k $ \u4e2a\u7684\u4eba \u5c31\u662f\u4e00\u4e2a\u77e9\u5f62\u52a0\u95ee\u9898 \u5e76\u4e14\u77e9\u5f62\u7eb5\u5411\u7684\u8fb9\u957f\u4e3a\u5355\u70b9 \u53ef\u4ee5\u5e73\u51e1\u5730\u7ef4\u62a4\n\n\u7531\u4e8e\u7ef4\u62a4\u4eba\u6570\u7f16\u53f7\u4e8c\u5143\u7ec4\u96be\u4ee5\u5b9e\u73b0 \u6240\u4ee5\u8003\u8651\u626b\u63cf\u7ebf\u7ef4\u62a4\u4eba\u6570 \u628a\u540c\u4e00\u6b21\u52a0\u5165\u7684$x$\u4e2a\u4eba\u7f29\u6210\u4e00\u4e2a\u70b9 \u70b9\u6743\u4e3a\u4eba\u6570 \u6700\u540e\u7ebf\u6bb5\u6811\u533a\u95f4\u4e8c\u5206\u627e\u5230\u7eb5\u8f74\u7f16\u53f7\u53ef\u4ee5\u5e73\u51e1\u5730\u7ef4\u62a4\n\n\u4f46\u662f\u7531\u4e8e\u6bcf\u6b21\u5230 $0$ \u90fd\u5f97\u6e05\u7a7a\u5e8f\u5217 \u4e9b\u8bb8 dl \u8003\u8651\u5982\u4f55\u7ef4\u62a4\n\n\u6211\u4eec\u53d1\u73b0 **\u6700\u5927\u540e\u7f00\u548c** \u6ee1\u8db3\u6b64\u6027\u8d28 \u53ef\u4ee5\u5e73\u51e1\u5730\u8bc1\u660e \u5176\u5b9e\u4e0d\u662f\u5f88\u5e73\u51e1 \u4e3b\u8981\u4e0d\u5bb9\u6613\u60f3\u5230\n\n\u626b\u63cf\u7ebf\u7ebf\u6bb5\u6811\u5e73\u51e1\u5730\u7ef4\u62a4\u540e\u7f00\u548c \u548c\u540e\u7f00\u7684\u4f4d\u7f6e\n\n\u6bcf\u6b21\u67e5\u8be2\u627e\u5230\u5bf9\u5e94\u533a\u95f4\u7684\u540e\u7f00\u8d77\u59cb\u4f4d\u7f6e \u4ece\u8fd9\u4e2a\u4f4d\u7f6e\u5230 $r$ ( \u5373\u67e5\u8be2\u65f6\u95f4 \u8fd9\u4e00\u533a\u95f4\u7684\u7b2c $ k $ \u4e2a\u4f4d\u7f6e\u7684 \u901a\u8fc7\u7ebf\u6bb5\u6811\u533a\u95f4\u4e8c\u5206\u53ef\u4ee5\u5e73\u51e1\u5730\u5b9e\u73b0\n\n[\u7ebf\u6bb5\u6811\u533a\u95f4\u4e8c\u5206\u6a21\u677f](https://www.luogu.com.cn/problem/U197996)\n\n\u7136\u540e\u6ce8\u610f\u4e00\u4e0b\u5bf9\u5e94\u5bb6\u5ead\u6807\u53f7\u7684\u7ec6\u8282 \u6211\u6015\u4e00\u5806 $ 0 $ \u51fa\u9505 pop \u7684\u548c  push \u7684\u548c\u6211\u90fd\u5206\u522b\u79bb\u6563\u5316\u8fdb\u884c\u4e86\u7ef4\u62a4 \u7ec6\u8282\u8fd8\u662f\u6709\u4e9b\u7684 \u6ce8\u610f\u4e00\u4e0b\n\n\u54e6\u5bf9 \u8fd8\u6709\u4e00\u4e2a\u5de8\u5927\u7684\u5751\u70b9\n\n**\u6570\u636e\u70b9\u5b58\u5728\u7a7a\u95ee\u60c5\u51b5\uff01\uff01\uff01**\n\n\u8c03\u534a\u5929\u4e5f\u662f\u670d\u4e86\n\n\u867d\u7136\u662f lxlppt \u4e0a\u539f\u9898 \u4f46\u611f\u89c9\u6ca1\u591a\u5c11\u4eba\u4ea4\u8fd9\u9053\u9898 \u7f1d\u7f1d\u8865\u8865\u7684\u4ee3\u7801\u4e5f\u80fd\u6700\u4f18\u89e3\u6392\u7b2c\u4e09\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=250005;\nint cntl,cntq;\nint cntp,f[N],cntn,g[N];\nint tn;\nint qn;\ninline int read()\n{\n\tint x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')c=getchar();\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x;\n}\n\nstruct node\n{\n\tint opt,t,pos,k,ans,id;\n\tbool friend operator < (const node a,const node b)\n\t{\n\t\treturn a.pos<b.pos;\n\t}\n}line[N<<1],q[N];\nbool cmp(node a,node b)\n{\n\treturn a.id<b.id;\n}\n\nstruct seg\n{\n\tint pre_sum;\n\tint pre_pos;\n\tint sum_p;\n\tint sum_n;\n\tint sum;\n}t[N<<2];\n#define ls p<<1\n#define rs p<<1|1\ninline seg unify(seg l,seg r)\n{\n\tseg res;\n\tif(l.pre_sum+r.sum<=r.pre_sum)\n\tres={r.pre_sum,r.pre_pos,l.sum_p+r.sum_p,l.sum_n+r.sum_n,l.sum+r.sum};\n\telse\n\tres={l.pre_sum+r.sum,l.pre_pos,l.sum_p+r.sum_p,l.sum_n+r.sum_n,l.sum+r.sum};\n\treturn res;\n}\n\ninline void update(int p)\n{\n\tt[p]=unify(t[ls],t[rs]);\n}\n\nvoid modify(int l,int r,int x,int dx,int p,int type)\n{\n\tif(l==r)\n\t{\n\t\tt[p].pre_pos=l;\n\t\tif(type==1)t[p].sum_p+=dx;\n\t\telse\n\t\tt[p].sum_n+=dx;\n\t\tt[p].sum=t[p].pre_sum=t[p].sum_p-t[p].sum_n;\n\t\tif(t[p].pre_sum<0)t[p].pre_sum=0;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(x<=mid)modify(l,mid,x,dx,ls,type);\n\telse\n\tmodify(mid+1,r,x,dx,rs,type);\n\tupdate(p);\n}\n\nseg query(int l,int r,int ql,int qr,int p)\n{\n\tif(ql<=l&&r<=qr)\n\t{\n\t\treturn t[p];\n\t}\n\tint mid=l+r>>1;\n\tseg res={0,0,0,0,0};\n\tif(ql<=mid)res=query(l,mid,ql,qr,ls);\n\tif(qr>mid)\n\t{\n\t\tif(res.sum_p==0&&res.sum_n==0)res=query(mid+1,r,ql,qr,rs);\n\t\telse\n\t\tres=unify(res,query(mid+1,r,ql,qr,rs));\n\t}\n\treturn res;\n}\n\nint t2[N<<2],t3[N<<2];\ninline void update2(int p)\n{\n    t2[p]=t2[ls]+t2[rs];\n}\ninline void update3(int p)\n{\n    t3[p]=t3[ls]+t3[rs];\n}\nvoid add(int l,int r,int x,int dx,int p)\n{\n    if(l==r)\n    {\n        t3[p]+=dx;\n        return;\n    }\n    int mid=l+r>>1;\n    if(x<=mid)add(l,mid,x,dx,ls);\n    else\n    add(mid+1,r,x,dx,rs);\n    update3(p);\n}\n\nvoid insert(int l,int r,int x,int dx,int p)\n{\n    if(l==r)\n    {\n        t2[p]+=dx;\n        return;\n    }\n    int mid=l+r>>1;\n    if(x<=mid)insert(l,mid,x,dx,ls);\n    else\n    insert(mid+1,r,x,dx,rs);\n    update2(p);\n}\n\nint search(int l,int r,int ql,int qr,int p,int &k,int &type)\n{\n\t\n\tif(type==2)\n\t{\n        if(l==r)return l;\n\t\tint mid=l+r>>1;\n\t\tif(k>t2[ls])\n\t\t{\n\t\t\tk-=t2[ls];\n\t\t\treturn search(mid+1,r,ql,qr,rs,k,type);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn search(l,mid,ql,qr,ls,k,type); \n\t\t}\n\t}\n\telse\n\t{\n\t\tif(ql<=l&&r<=qr)\n\t\t{\n\t\t\tif(k>t2[p])\n\t\t\t{\n\t\t\t\tk-=t2[p];\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn search(l,r,ql,qr,p,k,type=2);\n\t\t\t}\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tint temp=0;\n\t\tif(ql<=mid)temp=search(l,mid,ql,qr,ls,k,type);\n\t\tif(type==2)return temp;\n\t\tif(qr>mid)temp=search(mid+1,r,ql,qr,rs,k,type);\n\t\treturn temp;\n\t}\n}\n\nint look(int l,int r,int ql,int qr,int p)\n{\n    if(ql<=l&&r<=qr)\n    {\n        return t3[p];\n    }\n    int mid=l+r>>1;\n    int res=0;\n    if(ql<=mid)res+=look(l,mid,ql,qr,ls);\n    if(qr>mid)res+=look(mid+1,r,ql,qr,rs);\n    return res;\n}\n\ninline int mid_q(int l,int r,int k)\n{\n\tseg pre=query(1,tn,l,r,1);\n\tif(pre.pre_sum<k)return 0;\n\tif(g[r]!=0)\n\tk=k+look(1,cntn,g[pre.pre_pos]+1,g[r],1);\n    int type=1;\n\treturn search(1,cntp,f[pre.pre_pos],f[r],1,k,type);\n}\nint w[N];\nsigned main()\n{\n\tint n=read(),m=read();\n\tqn=read();\n\tfor(int i=1;i<=qn;i++)\n\t{\n\t\tint opt=read();\n\t\tif(opt==1)\n\t\t{\n\t\t    tn++;\n\t\t    cntp++;\n\t\t\tint l=read(),r=read(),c=read(),k=read();\n\t\t\tline[++cntl]={opt,tn,l,k,c,i};\n\t\t\tline[++cntl]={opt,tn,r+1,-k,c,i};\n\t\t\tw[cntp]=c;\n\t\t\tf[tn]=cntp;\n\t\t\tg[tn]=cntn;\n\t\t}\n\t\telse\n\t\tif(opt==2)\n\t\t{\n\t\t    tn++;\n\t\t    cntn++;\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tline[++cntl]={opt,tn,l,k,0,i};\n\t\t\tline[++cntl]={opt,tn,r+1,-k,0,i};\n\t\t\tf[tn]=cntp;\n\t\t\tg[tn]=cntn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint a=read(),b=read();\n\t\t\tq[++cntq]={opt,tn,a,b,0,i};\n\t\t}\n\t}\n\tsort(line+1,line+cntl+1);\n\tsort(q+1,q+cntq+1);\n\tint cntq1=1,cntl1=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(line[cntl1].pos==i&&cntl1<=cntl)\n\t\t{\n\t\t\tmodify(1,tn,line[cntl1].t,line[cntl1].k,1,line[cntl1].opt);\n\t\t\tif(line[cntl1].opt==1)insert(1,cntp,f[line[cntl1].t],line[cntl1].k,1);\n\t\t\tif(line[cntl1].opt==2)\n\t\t\tadd(1,cntn,g[line[cntl1].t],line[cntl1].k,1);\n\t\t\tcntl1++;\n\t\t}\n\t\twhile(q[cntq1].pos==i&&cntq1<=cntq)\n\t\t{\n\t\t    if(q[cntq1].t==0)q[cntq1].ans=0;\n\t\t\telse\n            q[cntq1].ans=mid_q(1,q[cntq1].t,q[cntq1].k);\n\t\t\tcntq1++;\n\t\t}\n\t}\n\tsort(q+1,q+cntq+1,cmp);\n\tfor(int i=1;i<=cntq;i++)printf(\"%lld\\n\",w[q[i].ans]);\n\treturn 0;\n}\n```\n",
        "postTime": 1642242042,
        "uid": 223560,
        "name": "_HL_",
        "ccfLevel": 0,
        "title": "P7560 [JOISC 2021 Day1] \u30d5\u30fc\u30c9\u30b3\u30fc\u30c8\u9898\u89e3"
    }
]