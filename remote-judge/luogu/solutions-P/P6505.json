[
    {
        "content": "# P6505 Run Away\n\n\u9898\u89e3\u533a\u7ed9\u51fa\u7684\u90fd\u662f Voronoi \u56fe\u7684\u795e\u4ed9\u505a\u6cd5\uff0c\u4f46\u8fd9\u91cc\u5c06\u4ecb\u7ecd\u4e00\u79cd\u5f88\u7384\u5b66\u4f46\u5f88\u597d\u5199\u53c8\u5f88\u5feb\u7684\u505a\u6cd5\n\n\u9996\u5148\u770b\u5230\u6700\u8fdc\u8ddd\u79bb\uff0c\u5148\u8fdb\u884c\u4e8c\u5206\u8fd9\u4e2a\u8ddd\u79bb\uff0c\u8fd9\u662f\u6240\u6709\u7684\u70b9\u6269\u6563\u6210\u4e00\u4e2a\u4e2a\u5706\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u8fd9\u4e9b\u5706\u662f\u5426\u5b8c\u5168\u586b\u6ee1\u4e86\u8fd9\u4e2a\u77e9\u5f62\uff0c\u90a3\u4e48\u5982\u4f55\u5224\u65ad\u5462\n\n\u90a3\u4e48\u5f88\u7384\u5b66\u7684\u5c31\u6765\u4e86\uff0c\u6211\u4eec\u91c7\u7528\u5206\u6cbb\u7684\u601d\u60f3\uff0c\u9996\u5148\u4e00\u4e2a\u77e9\u5f62\uff0c\u5148\u5224\u65ad\u5b83\u662f\u5426\u53ef\u4ee5\u53ea\u88ab\u4e00\u4e2a\u5706\u8986\u76d6\uff0c\u7136\u540e\u5224\u65ad\u56db\u4e2a\u89d2\u53ea\u8981\u6709\u4e00\u4e2a\u89d2\u6ca1\u88ab\u8986\u76d6\u5c31\u4e0d\u884c\uff0c\u5982\u679c\u90fd\u88ab\u8986\u76d6\u4e86\uff0c\u90a3\u4e48\u9012\u5f52\u4e0b\u53bb\uff0c\u5c06\u5927\u77e9\u5f62\u6a2a\u7ad6\u5207\u4e24\u5200\u5206\u6210\u56db\u4e2a\u5c0f\u77e9\u5f62\u7ee7\u7eed\u5224\u65ad\uff0c\u5f53\u77e9\u5f62\u7684\u957f\u5ea6\u5c0f\u4e8e\u7cbe\u5ea6\u8981\u6c42\u65f6\u8fd4\u56de false\n\n\u8fd9\u4e2a\u770b\u8d77\u6765\u5f88\u7384\u5b66\uff0c\u4f46\u5b9e\u9645\u8dd1\u8d77\u6765\u98de\u5feb\uff0c\u7f3a\u70b9\u662f\u901f\u5ea6\u548c\u7cbe\u5ea6\u6709\u5173\uff0c\u8bf7\u8c28\u614e\u4f7f\u7528\n\n\u4ee3\u7801\u90e8\u5206\u501f\u9274 Luitaryi\n\n```cpp\n#pragma GCC optimize(3, \"inline\")\n#include <iostream>\n#include <cstdio>\n#define R register int\nusing namespace std;\ninline int g() {\n    R x = 0, f = 1;\n    register char s;\n    while (!isdigit(s = getchar())) f = s == '-' ? -1 : f;\n    do\n        x = x * 10 + (s ^ 48);\n    while (isdigit(s = getchar()));\n    return x * f;\n}\nconst double E = 1e-7;\nconst int N = 50001;\nint n, L, W, a[N], b[N];\ndouble c, d[N];\ninline bool in(double x, double y, int i) {\n    return (x - a[i]) * (x - a[i]) + (y - b[i]) * (y - b[i]) <= c;\n}\ninline bool ck(double x, double y, double l, double w) {\n    if (l < E && w < E)\n        return false;\n    for (R i = 1; i <= n; ++i)\n        if (in(x, y, i) && in(x + l, y, i) && in(x, y + w, i) && in(x + l, y + w, i))\n            return true;\n    register double L = l / 2, W = w / 2;\n    return ck(x, y, L, W) && ck(x + L, y, L, W) && ck(x, y + W, L, W) && ck(x + L, y + W, L, W);\n}\n\nsigned main() {\n    L = g(), W = g(), n = g();\n    for (R i = 1; i <= n; ++i) a[i] = g(), b[i] = g();\n    register double l = 0, r = 20000, md;\n    while (r - l > 1e-6) {\n        md = (l + r) / 2; c = md * md;\n        if (ck(0, 0, L, W)) r = md;\n        else l = md;\n    }\n    printf(\"%.6f\\n\", l);\n    return 0;\n}\n```\n\n",
        "postTime": 1593960384,
        "uid": 122144,
        "name": "hs_black",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P6505 \u3010Run Away\u3011"
    },
    {
        "content": "\u6211\u4eec\u53d1\u73b0 Voronoi \u56fe\u7684\u5b9a\u4e49\u6b63\u4e0e\u6211\u4eec\u672c\u9898\u8981\u6c42\u7684\u4e1c\u897f\u7c7b\u4f3c\uff1a\u5e73\u9762\u4e0a\u6bcf\u4e2a\u70b9\u5f52\u5c5e\u4e8e\u5176\u6700\u8fd1\u5df2\u77e5\u70b9\u6240\u4ee3\u8868\u7684\u533a\u57df\u3002\n\n\u8003\u8651\u5230 Voronoi \u56fe\u7684\u5f62\u6001\u3002\n\n[\u56fe\u7247\u6765\u6e90](https://www.cnblogs.com/xzyxzy/p/10349399.html)\n\n![](https://i.loli.net/2020/04/12/CiKdzBtMZ3xU7Pa.gif)\n\n\u4e0a\u56fe\u4e2d\u53ef\u4ee5\u5f62\u8c61\u5730\u770b\u51fa\uff0cVoronoi \u56fe\u4e0a\u6700\u665a\u88ab\u6269\u5145\u5230\u7684\u70b9\u5c31\u662f\u6211\u4eec\u9700\u8981\u6c42\u7684\u7b54\u6848\u70b9\u3002\n\n\u6211\u4eec\u8003\u8651\u8fd9\u6837\u4e00\u4e2a\u601d\u8def\uff1a\u627e\u5230\u6240\u6709\u53ef\u80fd\u6210\u4e3a\u7b54\u6848\u7684\u70b9\uff0c\u7136\u540e\u4f9d\u6b21\u68c0\u67e5\u6bcf\u4e2a\u70b9\u5230\u6700\u8fd1\u70b9\u7684\u8ddd\u79bb\uff0c\u66f4\u65b0\u7b54\u6848\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\uff0c\u53ea\u6709\u8fd9\u6837\u7684\u70b9\u662f\u53ef\u80fd\u6700\u540e\u88ab\u6269\u5145\u5230\u7684\uff1a\n\n1. \u77e9\u5f62\u7684\u56db\u4e2a\u89d2\uff0c\u5373 $(0, 0)$\uff0c$(0, h)$\uff0c$(w, 0)$ \u548c $(w, h)$ \u56db\u4e2a\u70b9\u3002\n2. Voronoi \u56fe\u4e0a\u7684\u9876\u70b9\u3002\u65e2\u5305\u62ec\u4e00\u6761\u8fb9\u4e0e\u77e9\u5f62\u8fb9\u754c\u7684\u4ea4\u70b9\uff0c\u4e5f\u5305\u62ec\u540c\u65f6\u5f52\u5c5e\u4e8e\u4e09\u4e2a\uff08\u6216\u4ee5\u4e0a\uff09\u533a\u57df\u7684\u4ea4\u70b9\u3002\n\n\u7531\u4e8e Voronoi \u56fe\u662f Delaunay \u4e09\u89d2\u5256\u5206\u7684\u5bf9\u5076\u56fe\uff0c\u56e0\u6b64 Voronoi \u56fe\u4e0a\u6bcf\u4e2a\u9876\u70b9\u5c31\u662f Delaunay \u4e09\u89d2\u5256\u5206\u5256\u51fa\u7684\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u5916\u5fc3\uff0c\u6216\u662f\u5256\u5206\u51fa\u7684\u4e00\u6761\u8fb9\u7684\u5782\u76f4\u5e73\u5206\u7ebf\u4e0e\u77e9\u5f62\u8fb9\u754c\u7684\u4ea4\u70b9\u3002\n\n\u4e09\u89d2\u5256\u5206\u5256\u51fa\u7684\u4e09\u89d2\u5f62\u6570\u4e0d\u8d85\u8fc7 $3n$\uff0c\u5256\u5206\u51fa\u7684\u8fb9\u6570\u4e0d\u8d85\u8fc7 $2n$\uff0c\u56e0\u6b64\u9876\u70b9\u6570\u4e5f\u662f\u5728 $\\mathcal{O}(n)$ \u7ea7\u522b\u7684\u3002\n\n\u8fd9\u6837\u6211\u4eec\u627e\u5230\u4e86 $\\mathcal{O}(n)$ \u4e2a\u53ef\u80fd\u6210\u4e3a\u7b54\u6848\u7684\u70b9\uff0c\u5bf9\u6bcf\u4e00\u4e2a\u70b9\u90fd\u627e\u4e00\u904d\u6700\u8fd1\u70b9\u8ddd\u79bb\u66f4\u65b0\u7b54\u6848\u5373\u53ef\u3002\n\n\u6211\u7684\u7a0b\u5e8f\u5b9e\u73b0\u4e3a\u4e86\u66f4\u65b9\u4fbf\u5730\u627e\u51fa\u5256\u5206\u540e\u7684\u4e09\u89d2\u5f62\uff0c\u4f7f\u7528\u4e86 Bowyer-Watson \u7b97\u6cd5\uff0c\u590d\u6742\u5ea6\u662f $\\mathcal{O}(n ^ 2)$\u3002\n\n\u56e0\u6b64\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal{O}(n ^ 2)$\u3002\u5176\u5b9e\u53ef\u4ee5\u505a\u5230 $\\mathcal{O}(n \\log n)$\uff0c\u4f46\u4ee3\u7801\u957f\u5ea6\u5f97\u7ffb\u597d\u51e0\u500d\uff0c\u5c31\u6682\u65f6\u4f5c\u7f62\u4e86\u3002\n\n$\\mathcal{O}(n ^ 2)$ \u4ee3\u7801\uff1a\n\n```cpp\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <vector>\n\n#ifdef Tweetuzki\n#define debug(arg...) fprintf(stderr, arg)\n#else\n#define debug(arg...) void(0)\n#endif\n\nconst int MaxN = 1005, MaxF = 100000;\nconst double eps = 1e-9;\n\ntypedef struct vec_t {\n  double x, y;\n  vec_t(double _x = 0, double _y = 0) { x = _x, y = _y; }\n  inline friend vec_t operator+(const vec_t &a, const vec_t &b) { return vec_t(a.x + b.x, a.y + b.y); }\n  inline friend vec_t operator-(const vec_t &a, const vec_t &b) { return vec_t(a.x - b.x, a.y - b.y); }\n  inline friend vec_t operator*(const vec_t &a, double k) { return vec_t(a.x * k, a.y * k); }\n  inline friend double dot(const vec_t &a, const vec_t &b) { return a.x * b.x + a.y * b.y; }\n  inline friend double cross(const vec_t &a, const vec_t &b) { return a.x * b.y - a.y * b.x; }\n  inline friend double mod(const vec_t &a) { return sqrt(a.x * a.x + a.y * a.y); }\n\n  inline void shake() {\n    if (rand() % 2 == 0) x += 1.0 * rand() / RAND_MAX * eps;\n    else x -= 1.0 * rand() / RAND_MAX * eps;\n    if (rand() % 2 == 0) y += 1.0 * rand() / RAND_MAX * eps;\n    else y -= 1.0 * rand() / RAND_MAX * eps;\n  }\n} node_t;\n\nstruct line_t {\n  node_t a, b;\n  line_t(node_t _a = vec_t(), node_t _b = vec_t()) { a = _a, b = _b; }\n\n  inline friend line_t perp(const line_t &l) {\n    vec_t v = l.b - l.a;\n    node_t m = (l.a + l.b) * 0.5;\n    return line_t(m, m + vec_t(v.y, -v.x));\n  }\n\n  inline friend node_t intersect(const line_t &m, const line_t &n) {\n    double s1 = cross(n.b - m.a, n.a - m.a), s2 = cross(n.a - m.b, n.b - m.b);\n    return m.a + (m.b - m.a) * (s1 / (s1 + s2));\n  }\n};\n\ntypedef struct vec3_t {\n  double x, y, z;\n  vec3_t(double _x = 0, double _y = 0, double _z = 0) { x = _x, y = _y, z = _z; }\n  inline friend vec3_t operator+(const vec3_t &a, const vec3_t &b) { return vec3_t(a.x + b.x, a.y + b.y, a.z + b.z); }\n  inline friend vec3_t operator-(const vec3_t &a, const vec3_t &b) { return vec3_t(a.x - b.x, a.y - b.y, a.z - b.z); }\n  inline friend vec3_t operator*(const vec3_t &a, double k) { return vec3_t(a.x * k, a.y * k, a.z * k); }\n  inline friend vec3_t cross(const vec3_t &a, const vec3_t &b) { return vec3_t(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x); }\n  inline friend double dot(const vec3_t &a, const vec3_t &b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\n} node3_t;\n\nstruct triangle_t {\n  int a, b, c;\n  int la, lb, lc;\n\n  triangle_t(int _a = 0, int _b = 0, int _c = 0, int _la = 0, int _lb = 0, int _lc = 0) {\n    a = _a, b = _b, c = _c;\n    la = _la, lb = _lb, lc = _lc;\n  }\n};\n\nstruct edge_t {\n  int u, v;\n  double w;\n  edge_t(int _u = 0, int _v = 0, double _w = 0) { u = _u, v = _v, w = _w; }\n  inline friend bool operator<(const edge_t &a, const edge_t &b) { return a.w < b.w; }\n};\n\nint W, H, N, CntF;\nstd::map<int, bool> Mp[10005];\nnode_t A[MaxN + 5], MemoryA[MaxN + 5];\ntriangle_t F[MaxF + 5];\nbool Del[MaxF + 5];\n\ntemplate <typename Int>\ninline Int max(Int a, Int b) { return a > b ? a : b; }\n\ntemplate <typename Int>\ninline Int min(Int a, Int b) { return a < b ? a : b; }\n\ninline vec3_t mapping(const vec_t &a) { return vec3_t(a.x, a.y, a.x * a.x + a.y * a.y); }\n\ninline bool inCircumcircle(const node_t &a, const node_t &b, const node_t &c, const node_t &p) {\n  node3_t _a = mapping(a), _b = mapping(b), _c = mapping(c), _p = mapping(p);\n  if (cross(b - a, c - a) < 0) std::swap(_b, _c);\n  node3_t normal = cross(_b - _a, _c - _a);\n  if (dot(normal, _p - _a) > eps) return false;\n  else return true;\n}\n\ninline node_t center(const triangle_t &t) {\n  line_t a = perp(line_t(MemoryA[t.a], MemoryA[t.b])), b = perp(line_t(MemoryA[t.b], MemoryA[t.c]));\n  return intersect(a, b);\n}\n\ninline bool inCircumcircle(const triangle_t &t, const node_t &p) { return inCircumcircle(A[t.a], A[t.b], A[t.c], p); }\n\nvoid init() {\n  int _N;\n  scanf(\"%d %d %d\", &W, &H, &_N);\n  for (int i = 1; i <= _N; ++i) {\n    int x, y;\n    scanf(\"%d %d\", &x, &y);\n    if (Mp[x][y] == true) continue;\n    A[++N] = vec_t(1.0 * x, 1.0 * y);\n    Mp[x][y] = true;\n    MemoryA[N] = A[N];\n    A[N].shake();\n  }\n  A[N + 1] = node_t(-1, -1), A[N + 2] = node_t(-1, H + 1);\n  A[N + 3] = node_t(W + 1, -1), A[N + 4] = node_t(W + 1, H + 1);\n  F[++CntF] = triangle_t(N + 1, N + 3, N + 2, 2, 0, 0);\n  F[++CntF] = triangle_t(N + 4, N + 2, N + 3, 1, 0, 0);\n}\n\nstd::vector< std::pair<int, int> > Lk[MaxN + 5];\nint To[MaxN + 5], Tof[MaxN + 5];\nint NodeStk[MaxN + 5], NodeTp;\n\nvoid dfs(int u, int f, int beg) {\n  if (u == beg) {\n    if (f != 0) return;\n    NodeStk[NodeTp++] = u;\n    auto p = *(Lk[u].begin());\n    To[u] = p.first;\n    Tof[u] = p.second;\n    dfs(p.first, u, beg);\n  } else {\n    NodeStk[NodeTp++] = u;\n    for (auto p : Lk[u]) {\n      if (p.first == f) continue;\n      To[u] = p.first;\n      Tof[u] = p.second;\n      dfs(p.first, u, beg);\n    }\n  }\n}\n\ninline bool cmp(int a, int b, int c, int d) {\n  if (a == c && b == d) return true;\n  if (a == d && b == c) return true;\n  return false;\n}\n\ninline void insert(int insertNode) {\n  static int stk[MaxF + 5];\n  int tp = 0;\n  for (int i = 1; i <= CntF; ++i)\n    if (Del[i] == false && inCircumcircle(F[i], A[insertNode]) == true) {\n      stk[++tp] = i;\n      Del[i] = true;\n    }\n  static int e[MaxF + 5][3]; int cnte = 0;\n  for (int i = 1; i <= tp; ++i) {\n    int x = stk[i];\n    if (F[x].la == 0) {\n      cnte++;\n      e[cnte][0] = F[x].b, e[cnte][1] = F[x].c, e[cnte][2] = 0;\n    } else if (inCircumcircle(F[F[x].la], A[insertNode]) == false) {\n      int y = F[x].la;\n      cnte++;\n      if (F[y].la == x) {\n        F[y].la = -1;\n        e[cnte][0] = F[y].b, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else if (F[y].lb == x) {\n        F[y].lb = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else {\n        F[y].lc = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].b, e[cnte][2] = y;\n      }\n    }\n    if (F[x].lb == 0) {\n      cnte++;\n      e[cnte][0] = F[x].a, e[cnte][1] = F[x].c, e[cnte][2] = 0;\n    } else if (inCircumcircle(F[F[x].lb], A[insertNode]) == false) {\n      int y = F[x].lb;\n      cnte++;\n      if (F[y].la == x) {\n        F[y].la = -1;\n        e[cnte][0] = F[y].b, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else if (F[y].lb == x) {\n        F[y].lb = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else {\n        F[y].lc = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].b, e[cnte][2] = y;\n      }\n    }\n    if (F[x].lc == 0) {\n      cnte++;\n      e[cnte][0] = F[x].a, e[cnte][1] = F[x].b, e[cnte][2] = 0;\n    } else if (inCircumcircle(F[F[x].lc], A[insertNode]) == false) {\n      int y = F[x].lc;\n      cnte++;\n      if (F[y].la == x) {\n        F[y].la = -1;\n        e[cnte][0] = F[y].b, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else if (F[y].lb == x) {\n        F[y].lb = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].c, e[cnte][2] = y;\n      } else {\n        F[y].lc = -1;\n        e[cnte][0] = F[y].a, e[cnte][1] = F[y].b, e[cnte][2] = y;\n      }\n    }\n  }\n  for (int i = 1; i <= cnte; ++i) {\n    Lk[e[i][0]].emplace_back(e[i][1], e[i][2]);\n    Lk[e[i][1]].emplace_back(e[i][0], e[i][2]);\n  }\n  NodeTp = 0;\n  dfs(e[1][0], 0, e[1][0]);\n  for (int i = 0; i < NodeTp; ++i) {\n    int id = CntF + (i % NodeTp) + 1;\n    F[id] = triangle_t(insertNode, NodeStk[i], To[NodeStk[i]], Tof[NodeStk[i]], CntF + ((i + 1) % NodeTp) + 1, CntF + ((i - 1 + NodeTp) % NodeTp) + 1);\n    if (Tof[NodeStk[i]] != 0) {\n      int y = Tof[NodeStk[i]];\n      if (F[y].la == -1 && cmp(NodeStk[i], To[NodeStk[i]], F[y].b, F[y].c)) F[y].la = id;\n      if (F[y].lb == -1 && cmp(NodeStk[i], To[NodeStk[i]], F[y].a, F[y].c)) F[y].lb = id;\n      if (F[y].lc == -1 && cmp(NodeStk[i], To[NodeStk[i]], F[y].a, F[y].b)) F[y].lc = id;\n    }\n  }\n  CntF += NodeTp;\n  for (int i = 0; i < NodeTp; ++i) Lk[NodeStk[i]].clear();\n}\n\ninline bool inConvex(int id) { return F[id].a <= N && F[id].b <= N && F[id].c <= N; }\n\ninline double getMindis(const node_t &p) {\n  double mindis = W + H;\n  for (int i = 1; i <= N; ++i)\n    mindis = min(mindis, mod(p - MemoryA[i]));\n  debug(\"p = (%lf, %lf), mindis = %lf\\n\", p.x, p.y, mindis);\n  return mindis;\n}\n\ninline double maxdis(const line_t &l) {\n  line_t p = perp(l);\n  double m = 0;\n  auto inRange = [&](node_t a){ return -eps <= a.x && a.x <= W + eps && -eps <= a.y && a.y <= H + eps; };\n  if (inRange(intersect(p, line_t(node_t(0, 0), node_t(0, H))))) m = max(m, getMindis(intersect(p, line_t(node_t(0, 0), node_t(0, H)))));\n  if (inRange(intersect(p, line_t(node_t(0, 0), node_t(W, 0))))) m = max(m, getMindis(intersect(p, line_t(node_t(0, 0), node_t(W, 0)))));\n  if (inRange(intersect(p, line_t(node_t(W, 0), node_t(W, H))))) m = max(m, getMindis(intersect(p, line_t(node_t(W, 0), node_t(W, H)))));\n  if (inRange(intersect(p, line_t(node_t(0, H), node_t(W, H))))) m = max(m, getMindis(intersect(p, line_t(node_t(0, H), node_t(W, H)))));\n  return m;\n}\n\nvoid solve() {\n  for (int i = 1; i <= N; ++i) insert(i);\n  double ans = 0;\n  for (int _x = 0; _x <= 1; ++_x)\n    for (int _y = 0; _y <= 1; ++_y) {\n      node_t P = vec_t(_x * W, _y * H);\n      ans = max(ans, getMindis(P));\n    }\n  for (int i = 1; i <= CntF; ++i) {\n    if (Del[i] == true) continue;\n    if (inConvex(i) == false) continue;\n    debug(\"i = %d, (%lf, %lf), (%lf, %lf), (%lf, %lf)\\n\", i, MemoryA[F[i].a].x, MemoryA[F[i].a].y, MemoryA[F[i].b].x, MemoryA[F[i].b].y, MemoryA[F[i].c].x, MemoryA[F[i].c].y);\n    ans = max(ans, maxdis(line_t(MemoryA[F[i].b], MemoryA[F[i].c])));\n    ans = max(ans, maxdis(line_t(MemoryA[F[i].a], MemoryA[F[i].c])));\n    ans = max(ans, maxdis(line_t(MemoryA[F[i].a], MemoryA[F[i].b])));\n    node_t O = center(F[i]);\n    if (0 <= O.x && O.x <= W && 0 <= O.y && O.y <= H) {\n      debug(\"O = (%lf, %lf), r = %lf\\n\", O.x, O.y, mod(O - MemoryA[F[i].a]));\n      ans = max(ans, mod(O - MemoryA[F[i].a]));\n    }\n  }\n  printf(\"%lf\\n\", ans);\n}\n\nint main() {\n#ifdef Tweetuzki\n  freopen(\"input.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n  freopen(\"errorfile.txt\", \"w\", stderr);\n#endif\n  init();\n  solve();\n  return 0;\n}\n```",
        "postTime": 1588134256,
        "uid": 48843,
        "name": "Tweetuzki",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6505 \u3010Run Away\u3011"
    },
    {
        "content": "\u8bdd\u8bf4\u6211\u770b\u5230\u8fd9\u9053\u9898\u5c31\u60f3\u5230 [[SDOI2013]\u9003\u8003](https://www.luogu.com.cn/blog/105254/solution-p3297)\u3002\n\n## \u89e3\u6790\n\n\u9996\u5148\u6211\u4eec\u9700\u8981\u627e\u51fa\u6bcf\u4e2a\u70b9 \u201c\u652f\u914d\u201d \u7684\u533a\u57df\uff08\u4e5f\u5c31\u662f\u53ef\u4ee5\u4ea7\u751f\u8d21\u732e\uff08\u8ba1\u7b97\u8ddd\u79bb\uff09\u7684\u533a\u57df\uff09\u3002\n\n\u8003\u8651\u4e24\u4e2a\u70b9\u7684\u652f\u914d\u533a\u57df\u7684\u8fb9\u754c\uff0c\u53ef\u4ee5\u53d1\u73b0\u5c31\u662f\u5b83\u4eec\u7684\u4e2d\u5782\u7ebf\uff1b\u4e8e\u662f\u53ef\u4ee5\u8003\u8651\u5bf9\u4e00\u4e2a\u70b9\u76f4\u63a5\u66b4\u529b\u6c42\u51fa\u5176\u4ed6\u70b9\u548c\u5b83\u7684\u4e2d\u5782\u7ebf\u5e76\u62c9\u8fdb\u534a\u5e73\u9762\u4ea4\u8dd1\u4e00\u8dd1\u6c42\u51fa\u5b83\u7684\u652f\u914d\u8303\u56f4\u3002\n\n\u53ef\u4ee5\u60f3\u5230\u652f\u914d\u533a\u57df\u7684\u591a\u8fb9\u5f62\uff08\u5176\u5b9e\u4e00\u5b9a\u662f\u51f8\u5305\uff09\u7684\u9876\u70b9\u4e00\u5b9a\u662f\uff08\u6bd4\u8fb9\u4e0a\u6216\u591a\u8fb9\u5f62\u5185\u70b9\uff09\u66f4\u4f18\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u679a\u4e3e\u9876\u70b9\u5230\u652f\u914d\u70b9\u8ddd\u79bb\u53d6\u6700\u5927\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4e0a\u9762\u6c42\u7684\u662f\u4e00\u4e2a\uff08\u652f\u914d\uff09\u70b9\u6700\u5927\u7684\u8d21\u732e\uff0c\u6c42\u4e00\u6b21\u662f $O(n)$ \u7684\uff1b\u5bf9\u6240\u6709\u70b9\u6c42\u4e00\u6b21\u603b\u7684\u662f $O(n^2)$\uff0c\u8fc7\u8fd9\u9898\u8fd8\u662f\u5f88\u8f7b\u677e\u7684\u3002\n\n\uff08\u4f46\u53e6\u5916\u4e00\u7bc7\u9898\u89e3\u8c8c\u4f3c\u6700\u5feb\u53ef\u4ee5\u505a\u5230 $O(nlogn)$ \uff01~~\uff08\u6240\u4ee5\u6bd2\u7624\u52a0\u5f3a\u7248\u9884\u5b9a\uff1f\uff09~~\uff09\n\n## CODE\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\nusing std::sort;\nusing std::pair;\nusing std::min;\ntypedef pair<int, int> pad;\n\n/*------------------------------Computational geometry------------------------------*/\n\nconst double pi =acos(-1), eps =1e-7;\n\nstruct vect{\n\tdouble x, y;\n\tvect(){}\n\tvect(double xx, double yy):x(xx), y(yy){}\n\tvect operator + (vect v){ return vect(x+v.x, y+v.y); }\n\tvect operator - (vect v){ return vect(x-v.x, y-v.y); }\n\tvect operator * (double mu){ return vect(mu*x, mu*y); }\n\tdouble operator / (vect v){ return x*v.y-y*v.x; }/*\u53c9\u79ef*/\n};\n\nstruct line{\n\tvect u, v;\n\tdouble angle;\n\tline(){}\n\tline(vect uu, vect vv):u(uu), v(vv){ angle =atan2(vv.y-uu.y, vv.x-uu.x); }\n};\n\ninline short gtr(double a, double b){ return (a-b > eps); }\n\ninline bool eq(double a, double b){ return (a-b < eps && a-b > -eps); }\n\ninline bool onright(line f, vect w){ return (gtr((w-f.u)/(f.v-f.u), 0)); }\n\n/*\u6c42\u4ea4\u70b9*/\nvect getIntersection(line f, line g){\n\tdouble w =((g.u-f.u)/(f.u-f.v))/((f.u-f.v)/(g.u-g.v));\n\treturn g.u+(g.u-g.v)*w;\n}\n\nint cmp(line A, line B){\n\tif(eq(A.angle, B.angle)) return onright(B, A.u);/*\u6709\u5411\u76f4\u7ebf\u6700\u5de6\u7684\u5728\u6700\u540e\u9762\uff0c\u4f1a\u88ab\u4fdd\u7559*/\n\telse return (gtr(B.angle, A.angle));\n}\n\n/*\u6c42\u5de6\u4fa7\u4ea4*/\ninline pad getHPI(line ls[], int totl, line hull[]){\n\tsort(ls, ls+totl, cmp);\n\tint l =0, r =0;\n\tfor(int i =0; i < totl; ++i){\n\t\twhile(i < totl-1 && eq(ls[i].angle, ls[i+1].angle)) ++i;\n\t\twhile(r-l > 1 && onright(ls[i], getIntersection(hull[r-1], hull[r-2]))) --r;\n\t\tif(eq(ls[i].angle-hull[r-1].angle, pi)) return pad(0, 0);/*\u5224\u65b9\u5411\u76f8\u53cd\u7684\u5e73\u884c*/\n\t\thull[r++] =ls[i];\n\t}\n\twhile(r-l > 1){\n        if(onright(hull[r-1], getIntersection(hull[l], hull[l+1]))) ++l;\n        else if(onright(hull[l], getIntersection(hull[r-1], hull[r-2]))) --r;\n        else break;/*\u5df2\u7ecf\u6ca1\u6709\u66f4\u65b0\u4e86*/\n    }\n\tif(r-l < 3) return pad(0, 0);\n\telse return pad(l, r);\n}\n\ninline double dist(vect x, vect y){ return sqrt((y.x-x.x)*(y.x-x.x)+(y.y-x.y)*(y.y-x.y)); }\n\n/*\u4e2d\u5782\u7ebf\u5de6\u5305\u542b x*/\ninline line getmidline(vect x, vect y){\n\tvect mid =vect((x.x+y.x)/2, (x.y+y.y)/2), v2 =vect((y-x).y, -(y-x).x)/*\u987a\u65f6\u9488\u65b9\u5411\uff0c\u4e0e (y-x) \u5782\u76f4\u7684\u5411\u91cf*/;\n\tline ret(mid+v2, mid);\n\treturn ret;\n}\n\n/*------------------------------Main------------------------------*/\n\nconst int MAXN =1000100, MAXN2 =1100;\n\ninline void addbound(line ls[], int &totl, int w, int h){\n\tls[totl++] =line(vect(w, h), vect(0, h));\n\tls[totl++] =line(vect(0, h), vect(0, 0));\n\tls[totl++] =line(vect(0, 0), vect(w, 0));\n\tls[totl++] =line(vect(w, 0), vect(w, h));\n}\n\ninline double getFarthest(line hull[], int toth, vect p){\n\thull[toth++] =hull[0];\n\tdouble ret =0;\n\tfor(int i =0; i < toth-1; ++i){\n\t\tdouble res =dist(p, getIntersection(hull[i], hull[i+1]));\n\t\tif(gtr(res, ret)) ret =res;\n\t}\n\treturn ret;\n}\n\nline ls[MAXN], hull[MAXN];\n\ninline int read(){\n\tint x =0; bool f =0; char c =getchar();\n\twhile(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();\n\twhile(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();\n\treturn (f) ? -x : x;\n}\n\nvect point[MAXN2];\n\nint main(){\n\tint w =read(), h =read(), n =read();\n\tint totp =0;\n\tfor(int i =0; i < n; ++i){\n\t\tint x =read(), y =read();\n\t\t/*\u53cd\u6b63\u603b\u590d\u6742\u5ea6 n \u65b9\u8fd9\u91cc\u5c31\u66b4\u529b\u5224\u91cd\u4e86\uff08*/\n\t\tbool f =1;\n\t\tfor(int j =0; j < totp; ++j) if(point[j].x == x && point[j].y == y) f =0;\n\t\tif(f) point[totp++] =vect(x, y);\n\t}\n\tdouble ans =0;\n\tfor(int i =0; i < totp; ++i){\n\t\tint totl =0;\n\t\tfor(int j =0; j < totp; ++j){\n\t\t\tif(j == i) continue;\n\t\t\tls[totl++] =getmidline(point[i], point[j]);\n\t\t}\n\t\taddbound(ls, totl, w, h);\n\t\tpad H =getHPI(ls, totl, hull);\n\t\tdouble res =getFarthest(hull+H.first, H.second-H.first, point[i]);\n\t\tif(gtr(res, ans)) ans =res;\n\t}\n\tprintf(\"%.10lf\", ans);\n}\n```\n",
        "postTime": 1592738333,
        "uid": 105254,
        "name": "Piwry",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P6505 \u3010Run Away\u3011"
    }
]