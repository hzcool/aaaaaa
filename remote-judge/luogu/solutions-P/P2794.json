[
    {
        "content": "\u9996\u5148\u89c2\u5bdf\u516c\u5f0f\n\n$$cmp(i,j) =| ai - aj + bj - bi | + | ai - aj | $$\n\n\u770b\u5230\u4e24\u4e2a\u7edd\u5bf9\u503c\uff0c\u5de6\u8fb9\u4e00\u4e2a\u7edd\u5bf9\u503c\u52a0\u53f3\u8fb9\u4e00\u4e2a\u7edd\u5bf9\u503c\uff0c\u662f\u4e0d\u662f\u5f88\u50cf\u66fc\u54c8\u987f\u8ddd\u79bb\uff1f\n\n\u7531\u4e8e\u52a8\u6001\u52a0\u70b9\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9009\u62e9\u5f3a\u4e0aK-D Tree\n\n\u666e\u901a\u7684\u5e73\u9762\u6700\u8fd1\u66fc\u54c8\u987f\u70b9\u5bf9\u7684\u4f30\u4ef7\u51fd\u6570\u6211\u4eec\u662f\u8fd9\u6837\u5199\u7684\n\n$$max(minx-x,0)+max(x-maxx,0)+max(miny-y,0)+max(y-maxy,0)$$\n\n\u540c\u7406\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u5bf9cmp\u51fd\u6570\u8fdb\u884c\u6b63\u786e\u7684\u4f30\u4ef7\n\n\u4e00\u5f00\u59cb\u6211\u662f\u8fd9\u4e48\u60f3\u7684\uff1a\n\n\u7edd\u5bf9\u503c\u4e0d\u7b49\u5f0f\uff1a\n\n$$|x|+|y|>=|x-y|$$\n\n\u4ee4\n\n$$x=ai-aj+bj-bi,y=ai-aj$$\n\n\u4ee3\u5165\u5f97\n\n$$cmp(i,j)=|ai-aj+bj-bi|+|ai-aj|=|x|+|y|>=|x-y|$$\n\n\u5373\n\n$$cmp(i,j)>=|ai-aj+bj-bi-(ai-aj)|$$\n\n   $$cmp(i,j)>=|bj-bi|$$\n       \n\u7136\u540e\u4f30\u4ef7\u51fd\u6570\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a\n\n$$max(minb-b,0)+max(b-maxb,0)$$\n\n\u7136\u540e\u63d0\u4ea4\u4e00\u6ce2\n\n```cpp\n//50\u5206\u4ee3\u7801 \u8bf7\u52ff\u6a21\u4eff\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntemplate<class type>inline const void read(type &in)\n{\n\tin=0;char ch=getchar();bool fh=0;\n\twhile (ch<48||ch>57)fh=ch=='-'?1:fh,ch=getchar();\n\twhile (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();\n\tif (fh)in=-in;\n}\nconst int K=2,N=1e5+10,M=1e5+10,INF=2147483647;\nint n,m,f;\nstruct point\n{\n\tint d[K];\n\tinline const bool operator<(const point &p)const\n\t{\n\t\treturn d[f]<p.d[f];\n\t}\n\tinline const friend int cmp(const point &a,const point &b)\n\t{\n\t\treturn abs(a.d[0]-b.d[0]+b.d[1]-a.d[1])+abs(a.d[0]-b.d[0]);\n\t}\n}w[N+M];\ntemplate<int K>class KD_Tree\n{\n\tstatic const double alpha=0.75;\n\tprivate:\n\t\tstruct tree\n\t\t{\n\t\t\tint size;\n\t\t\ttree *son[2];\n\t\t\tpoint range,mx,mn;\n\t\t\tinline const void pushup()\n\t\t\t{\n\t\t\t\tsize=son[0]->size+1+son[1]->size;\n\t\t\t\tfor (int i=0;i<K;i++)\n\t\t\t\t\tmx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),\n\t\t\t\t\tmn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));\n\t\t\t}\n\t\t\tinline const bool unbalanced()\n\t\t\t{\n\t\t\t\treturn son[0]->size>size*alpha||son[1]->size>size*alpha;\n\t\t\t}\n\t\t\tinline const int evalue(const point &x)\n\t\t\t{\n\t\t\t\treturn max(mn.d[1]-x.d[1],0)+max(x.d[1]-mx.d[1],0);\n\t\t\t}\n\t\t}memory_pool[N+M],*recycle[N+M],*null,*tail,*root;\n\t\tint top,rnk,mn;\n\t\tinline const void init()\n\t\t{\n\t\t\ttail=memory_pool;\n\t\t\tnull=tail++;\n\t\t\troot=null->son[0]=null->son[1]=null;\n\t\t\tfor (int i=0;i<K;i++)\n\t\t\t\tnull->range.d[i]=0,\n\t\t\t\tnull->mx.d[i]=-INF,\n\t\t\t\tnull->mn.d[i]=INF;\n\t\t\tnull->size=top=0;\n\t\t}\n\t\tinline tree *spawn(const point &x)\n\t\t{\n\t\t\ttree *p=top?recycle[--top]:tail++;\n\t\t\tp->size=1;\n\t\t\tp->mn=p->mx=p->range=x;\n\t\t\tp->son[0]=p->son[1]=null;\n\t\t\treturn p;\n\t\t}\n\t\tinline const void travel(tree *p)\n\t\t{\n\t\t\tif (p==null)return;\n\t\t\ttravel(p->son[0]);\n\t\t\tw[++rnk]=p->range;\n\t\t\trecycle[top++]=p;\n\t\t\ttravel(p->son[1]);\n\t\t}\n\t\tinline tree *build(int l,int r,int d)\n\t\t{\n\t\t\tif (l>r)return null;\n\t\t\tint mid=l+r>>1;f=d;\n\t\t\tnth_element(w+l,w+mid,w+r+1);\n\t\t\ttree *p=spawn(w[mid]);\n\t\t\tif (l==r)return p;\n\t\t\tp->son[0]=build(l,mid-1,(d+1)%K);\n\t\t\tp->son[1]=build(mid+1,r,(d+1)%K);\n\t\t\tp->pushup();\n\t\t\treturn p;\n\t\t}\n\t\tinline const void rebuild(tree *&p)\n\t\t{\n\t\t\trnk=0;\n\t\t\ttravel(p);\n\t\t\tp=build(1,rnk,0);\n\t\t}\n\t\tinline tree **add(tree *&p,const point &x,int d)\n\t\t{\n\t\t\tif (p==null)return p=spawn(x),&null;\n\t\t\ttree **bad=add(p->son[p->range.d[d]<x.d[d]],x,(d+1)%K);\n\t\t\tp->pushup();\n\t\t\tif (p->unbalanced())bad=&p;\n\t\t\treturn bad;\n\t\t}\n\t\tinline const void query(tree *p,const point &x)\n\t\t{\n\t\t\tif (p==null)return;//printf(\"(%d,%d)\\n\",p->range.d[0],p->range.d[1]);\n\t\t\tmn=min(mn,cmp(p->range,x));\n\t\t\tint f[2]={INF,INF};\n\t\t\tif (p->son[0]!=null)f[0]=p->son[0]->evalue(x);\n\t\t\tif (p->son[1]!=null)f[1]=p->son[1]->evalue(x);//printf(\"%d %d %d\\n\",mn,f[0],f[1]);\n\t\t\tbool t=f[0]>=f[1];\n\t\t\tif (f[t]<mn)query(p->son[t],x);t^=1;\n\t\t\tif (f[t]<mn)query(p->son[t],x);\n\t\t}\n\tpublic:\n\t\tinline KD_Tree(){init();}\n\t\tinline const void insert(const point &x)\n\t\t{\n\t\t\ttree **bad=add(root,x,0);\n\t\t\tif (*bad!=null)rebuild(*bad);\n\t\t}\n\t\tinline const int query(const point &x)\n\t\t{\n\t\t\tmn=INF;\n\t\t\tquery(root,x);\n\t\t\treturn mn;\n\t\t}\n\t\tinline const void build()\n\t\t{\n\t\t\troot=build(1,n,0);\n\t\t}\n};\nKD_Tree<K>kdt;\nint main()\n{\n\tread(n);read(m);\n\tfor (int i=1;i<=n;i++)for (int j=0;j<K;j++)read(w[i].d[j]);\n\tkdt.build();\n\twhile (m--)\n\t{\n\t\tint opt;point c;\n\t\tread(opt);\n\t\tfor (int i=0;i<K;i++)read(c.d[i]);\n\t\tif (opt==1)kdt.insert(c);\n\t\telse printf(\"%d\\n\",kdt.query(c));\n\t}\n\treturn 0;\n}\n```\n\n\u5c31\u6109\u5feb\u7684tle\u62ff50\u5206\u4e86\n\n\u539f\u56e0\u5728\u4e8e\uff1a\u8fd9\u4e2a\u4f30\u4ef7\u51fd\u6570\u592alow\u4e86\uff0c\u6b63\u786e\u6027\u6709\u4fdd\u8bc1\u4f46\u662f\u65e0\u6cd5\u83b7\u5f97\u5408\u7406\u9ad8\u6548\u7684\u65f6\u6548\n\n\u7136\u540e\u6211\u4eec\u518d\u770b\u4e00\u773c\u5f0f\u5b50\n\n$$cmp(i,j) =| ai - aj + bj - bi | + | ai - aj | $$\n\n$$cmp(i,j)=|(bj-ai)-(bi-ai)|+|ai-aj|$$\n\n\u6211*\uff0c\u8fd9\u4e0d\u5c31\u662f\u88f8\u7684\u5e73\u9762\u6700\u8fd1\u70b9\u5bf9\u5417\n\n**\u628a(b-a)\u5f53\u505a\u7b2c\u4e00\u7ef4\uff0ca\u5f53\u505a\u7b2c\u4e8c\u7ef4,cmp(i,j)\u5c31\u662f\u70b9i,j\u7684\u66fc\u54c8\u987f\u8ddd\u79bb**\n\n\u4e8e\u662f\u6109\u5feb\u5730K-D Tree\u901a\u8fc7\u4e86\u6b64\u9898\n\n```cpp\n//100\u5206\u4ee3\u7801\n#include<cstdio>\n#include<algorithm>\nusing std::abs;\nusing std::max;\nusing std::min;\nusing std::nth_element;\ntemplate<class type>inline const void read(type &in)\n{\n\tin=0;char ch=getchar();bool f=0;\n\twhile (ch<48||ch>57){if (ch=='-')f=1;ch=getchar();}\n\twhile (ch>47&&ch<58)in=(in<<3)+(in<<1)+(ch&15),ch=getchar();\n\tif (f)in=-in;\n}\nconst int K=2,N=1e5+10,M=1e5+10,INF=2147483647;\nint n,m,f;\nstruct point\n{\n\tint d[K];\n\tinline point(int x=0,int y=0){d[0]=x;d[1]=y;}\n\tinline const bool operator<( const point &p)const\n\t{\n\t\treturn d[f]<p.d[f];\n\t}\n\tinline const friend int manhattan( const point &a, const point &b)\n\t{\n\t\tint dis=0;\n\t\tfor (int i=0;i<K;i++)dis+=abs(a.d[i]-b.d[i]);\n\t\treturn dis;\n\t}\n}w[N+M];\ntemplate<int K>class KD_Tree\n{\n\tstatic const double alpha=0.75;\n\tprivate:\n\t\tstruct tree\n\t\t{\n\t\t\tint size;\n\t\t\ttree *son[2];\n\t\t\tpoint range,mx,mn;\n\t\t\tinline const void pushup()\n\t\t\t{\n\t\t\t\tsize=son[0]->size+1+son[1]->size;\n\t\t\t\tfor (int i=0;i<K;i++)\n\t\t\t\t\tmx.d[i]=max(range.d[i],max(son[0]->mx.d[i],son[1]->mx.d[i])),\n\t\t\t\t\tmn.d[i]=min(range.d[i],min(son[0]->mn.d[i],son[1]->mn.d[i]));\n\t\t\t}\n\t\t\tinline const bool unbalanced()\n\t\t\t{\n\t\t\t\treturn son[0]->size>size*alpha||son[1]->size>size*alpha;\n\t\t\t}\n\t\t\tinline const int evalue(const point &x)\n\t\t\t{\n\t\t\t\tint f=0;\n\t\t\t\tfor (int i=0;i<K;i++)f+=max(mn.d[i]-x.d[i],0)+max(x.d[i]-mx.d[i],0);\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}memory_pool[N+M],*recycle[N+M],*null,*tail,*root;\n\t\tint top,rnk,flag,mn;\n\t\tinline const void init()\n\t\t{\n\t\t\ttail=memory_pool;\n\t\t\tnull=tail++;\n\t\t\troot=null->son[0]=null->son[1]=null;\n\t\t\tfor (int i=0;i<K;i++)null->mx.d[i]=-INF,null->mn.d[i]=INF;\n\t\t}\n\t\tinline tree *spawn(const point &x)\n\t\t{\n\t\t\ttree *p=top?recycle[--top]:tail++;\n\t\t\tp->size=1;\n\t\t\tp->mn=p->mx=p->range=x;\n\t\t\tp->son[0]=p->son[1]=null;\n\t\t\treturn p;\n\t\t}\n\t\tinline const void travel(tree *p)\n\t\t{\n\t\t\tif (p==null)return;\n\t\t\ttravel(p->son[0]);\n\t\t\tw[++rnk]=p->range;\n\t\t\trecycle[top++]=p;\n\t\t\ttravel(p->son[1]);\n\t\t}\n\t\tinline tree *build(int l,int r,int d)\n\t\t{\n\t\t\tif (l>r)return null;\n\t\t\tint mid=l+r>>1;f=d;\n\t\t\tnth_element(w+l,w+mid,w+r+1);\n\t\t\ttree *p=spawn(w[mid]);\n\t\t\tif (l==r)return p;\n\t\t\tp->son[0]=build(l,mid-1,d^1);\n\t\t\tp->son[1]=build(mid+1,r,d^1);\n\t\t\tp->pushup();\n\t\t\treturn p;\n\t\t}\n\t\tinline const void rebuild(tree *&p,int d)\n\t\t{\n\t\t\trnk=0;\n\t\t\ttravel(p);\n\t\t\tp=build(1,rnk,d);\n\t\t}\n\t\tinline tree **insert(tree *&p,const point &x,int d)\n\t\t{\n\t\t\tif (p==null)return p=spawn(x),&null;\n\t\t\ttree **bad=insert(p->son[p->range.d[d]<x.d[d]],x,d^1);\n\t\t\tp->pushup();\n\t\t\tif (p->unbalanced())bad=&p,flag=d;\n\t\t\treturn bad;\n\t\t}\n\t\tinline const void query(tree *p,const point &x)\n\t\t{\n\t\t\tmn=min(mn,manhattan(p->range,x));\n\t\t\tint f[2]={INF,INF};\n\t\t\tif (p->son[0]!=null)f[0]=p->son[0]->evalue(x);\n\t\t\tif (p->son[1]!=null)f[1]=p->son[1]->evalue(x);\n\t\t\tbool t=f[0]>=f[1];\n\t\t\tif (f[t]<mn)query(p->son[t],x);t^=1;\n\t\t\tif (f[t]<mn)query(p->son[t],x);\n\t\t}\n\tpublic:\n\t\tinline KD_Tree(){init();}\n\t\tinline const void insert(int x,int y)\n\t\t{\n\t\t\ttree **bad=insert(root,point(y-x,x),flag=0);\n\t\t\tif (*bad==null)return;\n\t\t\trebuild(*bad,flag);\n\t\t}\n\t\tinline const int query(int x,int y)\n\t\t{\n\t\t\tmn=INF;\n\t\t\tquery(root,point(y-x,x));\n\t\t\treturn mn;\n\t\t}\n};\nKD_Tree<K>kdt;\nint main()\n{\n\tread(n);read(m);\n\tfor (int x,y,i=1;i<=n;i++)read(x),read(y),kdt.insert(x,y);\n\tfor (int opt,x,y;m--;)\n\t\tif (read(opt),read(x),read(y),opt==1)kdt.insert(x,y);\n\t\telse printf(\"%d\\n\",kdt.query(x,y));\n\treturn 0;\n}\n```",
        "postTime": 1567238246,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2794 \u3010Facer\u548c\u6559\u5b98\u3011"
    }
]