[
    {
        "content": "## Solution\n\n### subtask 1\n\n\u76f4\u63a5 $2^n$ \u679a\u4e3e\u5b50\u96c6\uff0c\u7136\u540e\u5224\u65ad\u5373\u53ef\uff0c\u6ce8\u610f\u8981\u628a\u5408\u6cd5\u7684\u6700\u957f\u7684 IBvl \u5e8f\u5217\u5b58\u4e0b\u6765\uff0c\u6700\u540e\u6392\u4e2a\u5e8f\u5373\u53ef \n\n### subtask 3\n\n\u6c42\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\n\n\u8003\u8651\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u7684 $O(nlog)$ \u7684\u505a\u6cd5\n\n\u5b9e\u9645\u4e0a\u662f\u5f00\u4e86\u4e00\u4e2a\u6570\u7ec4\uff0c$d[i]$ \u8868\u793a\u957f\u5ea6\u4e3a i \u5b50\u5e8f\u5217\u6700\u540e\u4e00\u4f4d\u6700\u5c0f\u53ef\u4ee5\u662f\u591a\u5c11\uff0c\u6211\u4eec\u5728\u8bb0\u5f55 d \u6570\u7ec4\u7684\u540c\u65f6\u5c06\u6240\u6709\u957f\u5ea6\u4e3a i \u7684\u5b50\u5e8f\u5217\u7684\u6700\u540e\u4e00\u4f4d\u6240\u5728\u7684\u4f4d\u7f6e\u90fd\u5b58\u4e0b\u6765\u3002\n\n\u6700\u540e\u8d2a\u5fc3\u9009\u5373\u53ef\n\n\u6ce8\u610f\u8981\u5012\u7740\u6c42\n\n### subtask 4\n\n\u6c42\u5b57\u5178\u5e8f\u6700\u5c0f/\u6b21\u5c0f/\u7b2c\u4e09\u5c0f\u7684\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\n\n\u8fd9\u4e2a\u6211\u9664\u4e86\u6b63\u89e3\u4e0d\u4f1a\u522b\u7684\u505a\u6cd5\n\n~~\u4e71\u641eAC~~\n\n### subtask 2\n\n\u5176\u5b9e\u5982\u679c\u77e5\u9053\u4e86 $O(n^2)$ \u7684\u505a\u6cd5\u5c31\u79bb\u6b63\u89e3\u4e0d\u8fdc\u4e86\n\n\u4ee4 $f[i]$ \u8868\u793a i \u5411\u540e\u7684 IBvl \u7684\u6700\u957f\u957f\u5ea6\uff0c$g[i]$ \u8868\u793a\u65b9\u6848\u6570\n\n\u663e\u7136\u53ef\u4ee5 $O(n^2)$ \u6c42\u8fd9\u4e24\u4e2a\u6570\u7ec4\n\n\u90a3\u4e48\u6211\u4eec\u6709\u4e86\u8fd9\u4e24\u4e2a\u6570\u7ec4\u4e4b\u540e\uff0c\u5c31\u53ef\u4ee5\u6c42\u7b2c k \u5c0f\u4e86\n\n\u80af\u5b9a\u662f\u8981\u9010\u4f4d\u786e\u5b9a\n\n\u9996\u5148\u679a\u4e3e $f[i]==mx$ \u7684 i\n\n\u6309\u7167\u539f\u4e0b\u6807\u6392\u5e8f\uff0c\u5982\u679c $g[i]<k$\uff0c\u5219\u8bf4\u660e\u8fd9\u4e00\u4f4d\u4e0d\u80fd\u9009 $i$\uff0c\u5e76\u4e14\u5c06 k - g[i]\u3002\u91cd\u590d\u77e5\u9053 $g[i]\\ge k$\uff0c\u8bf4\u660e\u8fd9\u4e00\u4f4d\u4e00\u5b9a\u662f i\u3002\n\n\u90a3\u4e48\u5c31\u53ef\u4ee5\u9010\u6b65\u786e\u5b9a\uff0c\u5177\u4f53\u7684\u505a\u6cd5\u662f\u5148\u6309\u7167 $f[i]$ \u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u5bf9\u4e8e $f[i]$ \u76f8\u540c\u7684\uff0c\u6309\u7167\u539f\u4e0b\u6807\u6392\u5e8f\n\n### subtask 5\n\n\u6211\u4eec\u53d1\u73b0 subtask 2 \u7684\u74f6\u9888\u5728\u4e8e\u6c42 f \u548c g \u6570\u7ec4\u3002\n\n\u5bf9\u4e8e f \u7684\u8f6c\u79fb $f[i]=max_{j=i+1}^n(f[j]+1)(a[j]+L< a[i]<a[j]+R)$\n\n\u53d1\u73b0\u53ef\u4ee5\u8f6c\u79fb\u7684\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u6240\u4ee5\u90a3\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5c31\u597d\u4e86\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cctype>\n#include<algorithm>\n#include<cstring>\n#define gc getchar\n#define maxn 500010\n#define cs const seg\n//#define ll __int128\n#define ll long long\n#define INF 1000000000\n#define pc putchar\nusing namespace std;\n\nll read(){\n    ll x = 0; bool f = 0; char c = gc();\n    while(!isdigit(c)){if(c == '-') f = 1; c = gc();}\n    while(isdigit(c)){x = x * 10 + c - '0'; c = gc();}\n    return f ? -x : x;\n}\n\nint st[maxn], top;\nvoid write(ll x){\n    if(!x) pc('0'); top = 0;\n    while(x){st[++top] = x % 10; x /= 10;}\n    while(top) putchar(st[top--] + '0'); puts(\"\");\n}\n\nint n, L, R; ll K;\n\nint a[maxn], b[maxn * 3], c1, cnt;\nvoid init_hash(){ c1 = n; a[0] = INF;\n    for(int i = 1; i <= n; ++i) b[i] = a[i] = read();\n    for(int i = 1; i <= n; ++i) b[++c1] = a[i] + L, b[++c1] = a[i] + R;\n    sort(b + 1, b + c1 + 1); cnt = unique(b + 1, b + c1 + 1) - b - 1;\n}\n\ninline int get_pos(int v){return lower_bound(b + 1, b + cnt + 1, v) - b;}\n\ninline bool check(int x, int y){\n    if(x == INF) return 1;\n    return y - x > L && y - x < R;\n}\n\n#define lc i << 1\n#define rc i << 1 | 1\nstruct seg{\n    int v, id; ll s;\n    seg(int _v = 0, ll _s = 0){v = _v; s = _s;}\n}T[maxn * 12], A[maxn];\ninline void maintain(seg &o, seg ls, seg rs){\n    o.v = max(ls.v, rs.v); o.s = 0;\n    if(ls.v >= rs.v && ls.v) o.s += ls.s;\n    if(ls.v <= rs.v && rs.v) o.s += rs.s;\n    o.s = max((ll)1, o.s); o.s = min(o.s, K + 1);\n}\n\nvoid update(int i, int l, int r, int k, cs &o){\n    if(l == r){\n        if(o.v > T[i].v) T[i] = o;\n        else if(o.v == T[i].v) T[i].s += o.s;\n        T[i].s = min(T[i].s, K + 1);\n        return ;\n    } int m = l + r >> 1;\n    if(k <= m) update(lc, l, m, k, o);\n    else update(rc, m + 1, r, k, o);\n    maintain(T[i], T[lc], T[rc]);\n}\n\nseg query(int i, int l, int r, int L, int R){\n    if(l > R || r < L) return seg(0, 0);\n    if(L <= l && r <= R) return T[i];\n    int m = l + r >> 1;\n    seg t, t1 = query(lc, l, m, L, R), t2 = query(rc, m + 1, r, L, R);\n    maintain(t, t1, t2); return t;\n}\n\ninline bool cmp(cs &u, cs &v){\n    if(u.v == v.v) return u.id < v.id;\n    return u.v > v.v;\n}\nint ans[maxn], c2;\nint main(){\n    n = read(); K = read(); L = read(); R = read();\n    init_hash();\n    for(int i = n; i; --i){\n        A[i] = query(1, 1, cnt, get_pos(a[i] + L) + 1, get_pos(a[i] + R) - 1); \n        A[i].id = i; ++A[i].v;\n        update(1, 1, cnt, get_pos(a[i]), A[i]);\n    }\n    //    for(int i = 1; i <= n; ++i) cerr << A[i].v << \" \" << A[i].s << endl;\n    sort(A + 1, A + n + 1, cmp); int p = 0, la = 0;\n    ll tot = 0;\n    for(int i = 1; i <= n; ++i) if(A[i].v == A[1].v) tot += A[i].s;\n    //write(tot);\n    for(int i = 1; i <= n; i = p){\n        p = i;\n        while(A[p].v == A[i].v) ++p;\n        for(int j = i; j < p; ++j){\n            if(A[j].id < la || !check(a[la], a[A[j].id])) continue;\n            if(A[j].s >= K){\n                ans[++c2] = A[j].id; la = A[j].id;\n                break;\n            }\n            K -= A[j].s;\n        }\n    }\n    cout << A[1].v << endl;\n    for(int i = 1; i <= c2; ++i) printf(\"%d \", ans[i]);\n    return 0;\n}\n```\n\nrqy \u7684\u4ee3\u7801\n\n```cpp\n#include <algorithm>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\ntypedef long long LL;\nconst int S = 10000000;\nstruct Read {\n  inline char gc() { static char buf[S], *p = buf, *end = buf; return p == end ? feof(stdin) ? (char)EOF : (end = buf + fread(p = buf, 1, S, stdin), *(p++)) : *(p++); }\n  template<typename T> Read &operator[](T &ans) { ans = 0; int c, f = 1; while (!isdigit(c = gc())) if (c == '-') f = -1; do ans = ans * 10 + c - '0'; while (isdigit(c = gc())); ans *= f; return *this; }\n} read;\nstruct Write {\n  char obuf[S], *op, *oend; Write() { op = obuf; oend = obuf + S; }\n  inline void flush() { fwrite(obuf, 1, op - obuf, stdout); op = obuf; } inline void putChar(char c) { if (op == obuf) flush(); *(op++) = c; }\n  template <typename T> Write &operator[](T ans) { static int c[20]; int p = 0; while (ans) c[p++] = ans % 10, ans /= 10; while (p--) putChar(c[p] + '0'); return *this; }\n  Write &operator[](char c) { putChar(c); return *this; }\n  ~Write() { flush(); }\n} write;\nconst int N = 500050;\nint n, m, L, R, A[N], NL[N], NR[N], B[N], f[N], hd[N], nxt[N], len; LL K, num[N];\nvoid Discretize() { for (int i = 0; i < n; ++i) B[i] = A[i];\n  std::sort(B, B + n); m = std::unique(B, B + n) - B;\n  for (int i = 0; i < n; ++i) A[i] = std::lower_bound(B, B + m, A[i]) - B;\n  for (int i = 0, j = 0; i < m; NL[i] = j, ++i) while (j < m && B[j] <= B[i] + L) ++j;\n  for (int i = 0, j = 0; i < m; NR[i] = j, ++i) while (j + 1 < m && B[j + 1] < B[i] + R) ++j; }\nstruct Msg { int maxv; LL numv; Msg(int x = 0, LL v = 0) : maxv(x), numv(v) {}\n  inline void operator+=(const Msg &rhs) { if (maxv < rhs.maxv) maxv = rhs.maxv, numv = rhs.numv; else if (maxv == rhs.maxv) numv = std::min(K, numv + rhs.numv); }\n} msgv[1200000];\nvoid Modify(int x, int f, LL v) { Msg adv = Msg(f, v); for (x += len + 1; x; x >>= 1) msgv[x] += adv; }\nMsg Query(int l, int r) { Msg ans = Msg(0, 1); if (l > r) return ans;\n  for (l += len, r += len + 2; l + 1 != r; l >>= 1, r >>= 1) { if (~l & 1) ans += msgv[l | 1]; if (r & 1) ans += msgv[r & ~1]; } return ans; }\nint main() { read[n][K][L][R]; for (int i = 0; i < n; ++i) read[A[i]];\n  Discretize(); len = 1; while (len < m + 2) len <<= 1;\n  memset(hd, -1, sizeof hd);\n  for (int i = n - 1; i >= 0; --i) { Msg ans = Query(NL[A[i]], NR[A[i]]); Modify(A[i], f[i] = ans.maxv + 1, num[i] = ans.numv); nxt[i] = hd[f[i]]; hd[f[i]] = i; }\n  int ans1 = 0; while (~hd[ans1 + 1]) ++ans1; write[ans1]['\\n'];\n  for (int i = ans1, last = -1, l = 0, r = m - 1; i; --i) for (int j = hd[i]; ~j; j = nxt[j]) if (j > last && A[j] >= l && A[j] <= r)\n    if (num[j] >= K) { write[(last = j) + 1][' ']; l = NL[A[j]]; r = NR[A[j]]; break; } else K -= num[j];\n}\n```\n\n",
        "postTime": 1541415521,
        "uid": 34531,
        "name": "DDOSvoid",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5010 \u3010HMR\u7684LIS \u2162\u3011"
    }
]