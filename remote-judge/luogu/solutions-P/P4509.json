[
    {
        "content": "\u5bf9\u4e8e\u5e73\u9762\u4e0a\u7684\u5224\u4ea4\u95ee\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5f97\u60f3\u5230\u5229\u7528KD-tree\u6765\u89e3\u51b3\u3002\u5982\u679c\u6211\u4eec\u6309\u7167\u987a\u5e8f\u6784\u51fa\u4e00\u9897\u5e73\u8861\u6811\uff0c\u5e76\u4e14\u540c\u65f6\u6bcf\u4e2a\u8282\u70b9\u5305\u542b\u4e86\u4e00\u4e2a\u77e9\u5f62\u3002\u4e4b\u540e\u6211\u4eec\u53d1\u73b0\uff0c\u5bf9\u4e8e\u6240\u6709\u7684\u7ebf\u6bb5\u70b9\u5bf9\u5c31\u662f\u4e00\u4e2a\u70b9\u548c\u4ed6\u7684\u524d\u9a71\u6240\u7ec4\u6210\u7684\u6240\u6709\u7ebf\u6bb5\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\u5bf9\u6bcf\u4e2a\u70b9\u90fd\u627e\u4e00\u6b21\u524d\u9a71\u4f1a\u76f8\u5f53\u7684\u590d\u6742\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u8fd9\u6837\u4e00\u4e2a\u70b9\u5bf9\uff0c\u5bf9\u4e8e\u6df1\u5ea6\u8f83\u6d45\u7684\u90a3\u4e2a\u70b9\u6765\u8bf4\u5c31\u662f\u8981\u4e48\u662f\u53f3\u513f\u5b50\u7684\u6700\u5de6\u70b9\u548c\u6216\u8005\u662f\u5de6\u513f\u5b50\u7684\u6700\u53f3\u70b9\uff0c\u5982\u679c\u5bf9\u6bcf\u4e2a\u70b9\u90fd\u8fd9\u6837\u8003\u8651\u4e4b\u540e\uff0c\u6211\u4eec\u53d1\u73b0\u4e0d\u91cd\u4e0d\u6f0f\u7684\u8003\u8651\u5b8c\u4e86\u6240\u6709\u7ebf\u6bb5\u5bf9\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u539f\u9898\u7684\u67e5\u8be2\uff0c\u4e00\u6761\u76f4\u7ebf\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u76f4\u7ebf\u662f\u5426\u4e0e\u70b9\u4ee3\u8868\u77e9\u5f62\u5224\u4ea4\uff0c\u4ee5\u53ca\u641c\u5230\u67d0\u4e2a\u70b9\u7684\u65f6\u5019\uff0c\u5224\u5b9a\u4e00\u4e0b\u4e0a\u9762\u6240\u8bf4\u7684\u4e24\u4e2a\u70b9\u5bf9\u4ee3\u8868\u7ebf\u6bb5\u4e0e\u76f4\u7ebf\u662f\u5426\u6709\u4ea4\uff0c\u800c\u5bf9\u4e8e\u63d2\u5165\u5c31\u662f\u7b80\u5355\u7684\u5e73\u8861\u6811\u63d2\u5165\uff0c\u800c\u53ef\u6301\u4e45\u5316\uff0c\u6211\u4eec\u5199\u4e00\u9897\u53ef\u6301\u4e45\u5316\u66ff\u7f6a\u7f8a\u6811\u5c31OK\u4e86\u3002\n\n\u7531\u4e8e\u7b54\u6848\u603b\u548c\u4e0d\u8d85\u8fc710^6\uff0c\u63d2\u5165\u64cd\u4f5c\u7684\u6b21\u6570\u4e0d\u4f1a\u8d85\u8fc75*10^4\uff0c\u6240\u4ee5\u4e0d\u4f1a\u88ab\u5361\u6389\u3002\n\n[\u6b22\u8fce\u6765newuser\u5c0f\u7ad9\u770b\u770bowo](http://www.newuser.top/2018/11/24/%E3%80%90ctsc2015%E8%91%B1%E3%80%91%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E7%BB%B4%E6%8A%A4kd-tree%E4%B9%B1%E6%90%9E/)\n\n```\n#include<stdio.h>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 100005;\nint n,m,type;\nstruct node{\n    node *ls,*rs,*lmax,*rmax; int siz;\n    int x,y; int sx[2],sy[2];int xds;\n}z[maxn*60],*nul,*tl,*rt[maxn],**RT;\nint ZX,ZY,FX,FY;\nll A,B,C;\nll calc(int x,int y) {\n    return 1ll*A*x + 1ll*B*y + C;\n}\nbool che(int ax,int ay,int bx,int by) {\n    ll f1 = calc(ax,ay) ,f2 = calc(bx,by);\n    if(f1>f2) swap(f1,f2);\n    return (f1<=0&&f2>=0);\n}\n\nstruct dd {\n    int x,y;\n}oo[maxn]; int top;\nnode* nwnode(dd &tt) {\n    node* p = ++tl;\n    p->ls = p->rs = nul; p->siz = 1;\n    p->x = p->sx[0] = p->sx[1] = tt.x;\n    p->y = p->sy[0] = p->sy[1] = tt.y;\n    p->lmax = p->rmax = p; p->xds = 0;\n    return p;\n}\nvoid upd(node *&p) {\n    p->siz = 1; p->xds = 0;\n    if(p->ls!=nul) {\n        p->sx[0] = min(p->sx[0],p->ls->sx[0]);\n        p->sx[1] = max(p->sx[1],p->ls->sx[1]);\n        p->sy[0] = min(p->sy[0],p->ls->sy[0]);\n        p->sy[1] = max(p->sy[1],p->ls->sy[1]);\n        p->lmax = p->ls->lmax;\n        p->xds += p->ls->xds + 1;\n        p->siz += p->ls->siz;\n    }\n    if(p->rs!=nul) {\n        p->sx[0] = min(p->sx[0],p->rs->sx[0]);\n        p->sx[1] = max(p->sx[1],p->rs->sx[1]);\n        p->sy[0] = min(p->sy[0],p->rs->sy[0]);\n        p->sy[1] = max(p->sy[1],p->rs->sy[1]);\n        p->rmax = p->rs->rmax;\n        p->xds += p->rs->xds + 1;\n        p->siz += p->rs->siz;\n    }\n}\nvoid makekd(node *&p,int l,int r) {\n    int mid = (l+r)>>1;\n    p = nwnode(oo[mid]);\n    if(l<mid) makekd(p->ls,l,mid-1);\n    if(mid<r) makekd(p->rs,mid+1,r);\n    upd(p);\n}\nbool isbad(node *&p) {\n   if(p->ls->siz*5 > p->siz*4 || p->rs->siz*5 > p->siz*4 ) return 1;\n    return 0;\n}\nvoid tra(node *&p) {\n    if(p==nul) return;\n    tra(p->ls);\n    oo[++top] = (dd) {p->x,p->y};\n    tra(p->rs);\n}\nvoid rebuild() {\n    if(*RT==nul) return;\n    top = 0;\n    tra(*RT);\n    if(top>0)makekd(*RT,1,top);\n    else *RT = nul;\n    RT = &nul;\n}\n\nvoid init() {\n    nul = tl = z;\n    nul->ls = nul->rs = nul;\n    for(int i=0;i<=m;i++) {\n        rt[i] = nul;\n    }\n    RT = &nul;\n}\nvoid ins(node *&p,node *&las,int orz,int X,int Y) {\n    if(las==nul){\n        dd owo = (dd){X,Y};\n        p = nwnode((owo));\n        return;\n    }\n    p = ++tl; *p = *las;\n    if(p->ls->siz>=orz) ins(p->ls,las->ls,orz,X,Y);\n    else {\n        orz -= p->ls->siz+1;\n        ins(p->rs,las->rs,orz,X,Y);\n    }\n    upd(p);\n    if(isbad(p)) RT = &p;\n}\nint query(node *&p) {\n    if(p==nul) return 0;\n    int sm = 0;\n    if(p->ls!=nul) \n        sm += che(p->x,p->y,p->ls->rmax->x,p->ls->rmax->y);\n    if(p->rs!=nul) \n        sm += che(p->x,p->y,p->rs->lmax->x,p->rs->lmax->y);\n    int f0 = calc(p->sx[0],p->sy[0]);\n    int f1 = calc(p->sx[0],p->sy[1]); \n    int f2 = calc(p->sx[1],p->sy[0]);\n    int f3 = calc(p->sx[1],p->sy[1]);\n    if( (f0<0&&f1<0&&f2<0&&f3<0)||(f0>0&&f1>0&&f2>0&&f3>0) )  return sm;\n    return query(p->ls) + query(p->rs) + sm;\n}\nmain() {\n    init();\n    scanf(\"%lld%lld%lld\",&n,&m,&type);\n    for(int i=1;i<=n;i++) {\n        scanf(\"%lld%lld\",&oo[i].x,&oo[i].y);\n    }\n    makekd(rt[0],1,n);\n    int lastans = 0;\n    char ss[2];\n    for(int i=1;i<=m;i++) {\n        scanf(\"%s\",&ss[0]);\n        if(ss[0]=='H') {\n            int T;\n            scanf(\"%lld%lld%lld%lld%lld\",&T,&ZX,&ZY,&FX,&FY);\n            if(type) {\n                ZX^=lastans; ZY^=lastans; \n                FX^=lastans; FY^=lastans;\n            }\n            A = -FY; B = FX;\n            C =  - 1ll*A*ZX - 1ll*ZY*B;\n            rt[i] = rt[T];\n            lastans = query(rt[i]);\n            printf(\"%lld\\n\",lastans);\n        } else {\n            int T,orz,X,Y;\n            scanf(\"%lld%lld%lld%lld\",&T,&orz,&X,&Y);\n            if(type)X^=lastans,Y^=lastans;\n            ins(rt[i],rt[T],orz,X,Y);\n            if(*RT!=nul) rebuild();\n        }\n    }\n}\n```\n",
        "postTime": 1543030702,
        "uid": 55343,
        "name": "Newuser",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4509 \u3010[CTSC2015]\u8471\u3011"
    }
]