[
    {
        "content": "\u600e\u4e48\u9898\u89e3\u5168\u662fLCT\uff0c\u6211\u6811\u5256\u4e0d\u670d\n\n\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u5c31\u662f\u6811\u94fe\u8986\u76d6\uff0c\u653e\u5230\u5e8f\u5217\u4e0a\u5c31\u662f\u533a\u95f4\u5408\u5e76\uff0c\u533a\u95f4\u5408\u5e76\u66b4\u529b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u5747\u644a $O(1)$ \u7684(\u4e0d\u8003\u8651\u5728\u5176\u4ed6\u6570\u636e\u7ed3\u6784\u4e0a\u7684\u65f6\u95f4\u6d88\u8017)\uff0c\u4e8e\u662f\u4e00\u4e2a\u663e\u7136\u7684\u601d\u8def\u5c31\u662f\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u66b4\u529b\u641e\uff0c\u6bcf\u6b21\u5728\u91cd\u94fe\u4e0a\u627e\u5230\u4e00\u6bb5\u76f8\u540c\u7684\u989c\u8272\uff0c\u66b4\u529b\u5728\u7ebf\u6bb5\u6811\u4e0a\u4fee\u6539\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u644a\u662f $O(\\log N)$ \u7684\n\n\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u4e00\u4e2a\u8282\u70b9\u5230\u6839\u8282\u70b9\u7684\u6743\u503c $v$\n\n\u90a3\u4e48\u7b2c\u4e8c\u4e2a\u64cd\u4f5c\u5c31\u662f $v_x+v_y-2v_{LCA(x, y)}+1$\n\n\u7b2c\u4e09\u4e2a\u64cd\u4f5c\u7ebf\u6bb5\u6811\u533a\u95f4\u6700\u503c\n\n\u6ca1\u4e86\n\n\u65f6\u95f4\u590d\u6742\u5ea6:$O(N\\log^2N)$\n\n```cpp\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\n#define DEBUG(args...) fprintf(stderr, args)\n\ntypedef long long LL;\n\n#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)\n#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)\n#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)\n#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)\n\ntemplate<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}\ntemplate<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}\ntemplate<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}\ntemplate<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}\n\nclass fast_input {\nprivate:\n\tstatic const int SIZE = 1 << 15 | 1;\n\tchar buf[SIZE], *front, *back;\n\n\tvoid Next(char &c) {\n\t    if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);\n\t\tc = front == back ? (char)EOF : *front++;\n\t}\n\npublic :\n\ttemplate<class T>void operator () (T &x) {\n\t\tchar c, f = 1;\n\t\tfor(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;\n\t\tfor(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';\n\t\tx *= f;\n\t}\n\tvoid operator () (char &c, char l = 'a', char r = 'z') {\n\t\tfor(Next(c); c > r || c < l; Next(c)) ;\n\t}\n}input;\n\nconst int SN = 100000 + 47;\nconst int ST = SN << 2 | 1;\nconst int SE = 200000 + 47;\nconst int SM = 200000 + 47;\n\nint head[SN], nxt[SE], to[SE];\nint col_top[SM], col_bot[SM], col_now;\nint size[SN], son[SN], fa[SN], deep[SN];\nint top[SN], f[SN], g[SN], h[SN], rank;\nint max[ST], tag[ST], col[ST];\nint n;\n\nvoid Add(int, int);\nvoid DFS(int);\nvoid DFS(int, int);\nvoid Build(int, int, int);\nvoid Update(int);\nvoid Modify(int, int, int, int, int, int);\nvoid PushAdd(int, int);\nvoid PushDown(int);\nint Ask(int, int, int, int, int);\nvoid ModifyCol(int, int, int, int, int, int);\nint AskCol(int, int, int, int);\nvoid Modify(int, int);\nint Ask0(int, int);\nint Ask1(int);\n\nint __lp, __lq;\nint LCA(int, int);\n\nint main() {\n\n#ifdef Cai\n\tfreopen(\"s.in\", \"r\", stdin);\n#endif\n\n\tint m, x, y, z;\n\t\n\tinput(n), input(m);\n\tFOR(i, 2, n) input(x), input(y), Add(x, y);\n\n\tcol_now = n;\n\tFOR(i, 1, n) col_top[i] = col_bot[i] = i;\n\n\tdeep[1] = 1, DFS(1), DFS(1, -1), Build(1, 1, n);\n\n\twhile(m--) {\n\t\t//DEBUG(\"[%d]\\n\", m);\n\t\tinput(x), input(y);\n\t\tif(x == 1) Modify(y, ++col_now);\n\t\telse if(x == 2) input(z), printf(\"%d\\n\", Ask0(y, z));\n\t\telse printf(\"%d\\n\", Ask1(y));\n\t}\n\n\treturn 0;\n\n}\n\nvoid Add(int x, int y) {\n\tstatic int _ = 0;\n\tnxt[++_] = head[x], head[x] = _, to[_] = y;\n\tnxt[++_] = head[y], head[y] = _, to[_] = x;\n}\n\nvoid DFS(int x) {\n\tsize[x] = 1;\n\tfor(int i = head[x]; i; i = nxt[i])\n\t\tif(to[i] != fa[x]) {\n\t\t\tfa[to[i]] = x, deep[to[i]] = deep[x] + 1;\n\t\t\tDFS(to[i]), size[x] += size[to[i]];\n\t\t\tif(size[to[i]] > size[son[x]]) son[x] = to[i];\n\t\t}\n}\n\nvoid DFS(int x, int y) {\n\ttop[x] = y, f[x] = ++rank, h[rank] = x;\n\tif(son[x]) DFS(son[x], y);\n\tfor(int i = head[x]; i; i = nxt[i])\n\t\tif(to[i] != fa[x] && to[i] != son[x])\n\t\t\tDFS(to[i], to[i]);\n\tg[x] = rank;\n}\n\nvoid Build(int rt, int l, int r) {\n\tif(l == r) {max[rt] = deep[h[l]], tag[rt] = 0, col[rt] = h[l]; return ;}\n\tint mid = l + r >> 1;\n\tBuild(rt << 1, l, mid), Build(rt << 1 | 1, mid + 1, r);\n\tUpdate(rt);\n}\n\nvoid Update(int rt) {\n\tmax[rt] = Max(max[rt << 1], max[rt << 1 | 1]);\n}\n\nvoid Modify(int rt, int l, int r, int s, int t, int k) {\n\tif(l == s && r == t) {PushAdd(rt, k); return ;}\n\tPushDown(rt);\n\tint mid = l + r >> 1;\n\tif(t <= mid)\n\t\tModify(rt << 1, l, mid, s, t, k);\n\telse if(s > mid)\n\t\tModify(rt << 1 | 1, mid + 1, r, s, t, k);\n\telse {\n\t\tModify(rt << 1, l, mid, s, mid, k);\n\t\tModify(rt << 1 | 1, mid + 1, r, mid + 1, t, k);\n\t}\n\tUpdate(rt);\n}\n\nvoid PushAdd(int rt, int x) {\n\ttag[rt] += x, max[rt] += x;\n}\n\nvoid PushDown(int rt) {\n\tif(tag[rt]) PushAdd(rt << 1, tag[rt]), PushAdd(rt << 1 | 1, tag[rt]);\n\ttag[rt] = 0;\n}\n\nint Ask(int rt, int l, int r, int s, int t) {\n\tif(l == s && r == t) return max[rt];\n\tPushDown(rt);\n\tint mid = l + r >> 1;\n\tif(t <= mid)\n\t\treturn Ask(rt << 1, l, mid, s, t);\n\telse if(s > mid)\n\t\treturn Ask(rt << 1 | 1, mid + 1, r, s, t);\n\telse\n\t\treturn Max(Ask(rt << 1, l, mid, s, mid),\n\t\t\t\t   Ask(rt << 1 | 1, mid + 1, r, mid + 1, t));\n}\n\nvoid ModifyCol(int rt, int l, int r, int s, int t, int k) {\n\tif(l == s && r == t) {col[rt] = k; return ;}\n\tint mid = l + r >> 1;\n\tif(t <= mid)\n\t\tModifyCol(rt << 1, l, mid, s, t, k);\n\telse if(s > mid)\n\t\tModifyCol(rt << 1 | 1, mid + 1, r, s, t, k);\n\telse {\n\t\tModifyCol(rt << 1, l, mid, s, mid, k);\n\t\tModifyCol(rt << 1 | 1, mid + 1, r, mid + 1, t, k);\n\t}\n}\n\nint AskCol(int rt, int l, int r, int p) {\n\tif(l == r) return col[rt];\n\tint mid = l + r >> 1;\n\tif(p <= mid) return Max(col[rt], AskCol(rt << 1, l, mid, p));\n\telse return Max(col[rt], AskCol(rt << 1 | 1, mid + 1, r, p));\n}\n\nvoid Modify(int x, int y) {\n\tcol_bot[y] = x, col_top[y] = 1;\n\tint p, q, r, c, nl = 0, nr = 0, toplastc, nextx;\n\twhile(x) {\n\t\tp = Ask(1, 1, n, f[x], f[x]);\n\t\tc = AskCol(1, 1, n, f[x]);\n\t\tr = col_top[c];\n\t\tif(f[r] < f[top[x]]) {\n\t\t\tModifyCol(1, 1, n, f[top[x]], f[x], y);\n\t\t\tModify(1, 1, n, f[top[x]], g[top[x]], 1 - p);\n\t\t\tif(nl) Modify(1, 1, n, nl, nr, p - 1);\n\t\t}\n\t\telse {\n\t\t\tModifyCol(1, 1, n, f[r], f[x], y);\n\t\t\tModify(1, 1, n, f[r], g[r], 1 - p);\n\t\t\tif(nl) Modify(1, 1, n, nl, nr, p - 1);\n\t\t}\n\t\tif(col_bot[c] != x) {\n\t\t\tLCA(col_bot[c], x); // __lp is a child of x, which col is c\n\t\t\tif(f[__lp] != nl) {\n\t\t\t\tModify(1, 1, n, f[__lp], g[__lp], 1);\n\t\t\t\ttoplastc = __lp;\n\t\t\t}\n\t\t}\n\t\tif(f[r] < f[top[x]]) \n\t\t\tnl = f[top[x]], nr = g[top[x]], x = fa[top[x]];\n\t\telse\n\t\t\tnl = f[r], nr = g[r], x = fa[r], col_top[c] = toplastc;\n\t}\n}\n\nint Ask0(int x, int y) {\n\tint lca = LCA(x, y);\n\tint ans = Ask(1, 1, n, f[x], f[x]) + Ask(1, 1, n, f[y], f[y]);\n\tans -= 2 * Ask(1, 1, n, f[lca], f[lca]);\n\treturn ans + 1;\n}\n\nint Ask1(int x) {\n\treturn Ask(1, 1, n, f[x], g[x]);\n}\n\nint LCA(int x, int y) {\n\twhile(top[x] != top[y]) \n\t\tif(deep[top[x]] > deep[top[y]]) __lp = top[x], x = fa[top[x]];\n\t\telse __lq = top[y], y = fa[top[y]];\n\tif(x == y) return x;\n\tif(deep[x] < deep[y]) return __lq = son[x], x;\n\treturn __lp = son[y], y;\n}\n\n/*\ng++ -o s s.cpp -O2; for((i = 1; i <= 10; ++i)) do cp paint$i.in s.in; ./s > s.out; diff paint$i.out s.out -w > s.res; echo $?; done\n*/\n\n```",
        "postTime": 1522202820,
        "uid": 21784,
        "name": "Caii",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u4e00\u9053\u975e\u5e38\u5999\u7684 $LCT$ \u9898 $QwQ$\uff0c\u611f\u89c9\u505a\u4e86\u4e4b\u540e\u4f1a\u5bf9 $access$ \u7684\u7406\u89e3\u6df1\u4e00\u4e9b $QwQ$\n\n~~\uff08\u6811\u5256\u5927\u4f6c\u522b\u6253\u6211 QAQ \uff09~~\n\n\u9996\u5148 **\u64cd\u4f5c$1$** \u5177\u6709\u4e00\u4e2a\u7279\u6027\uff0c\u67d3\u8272\u64cd\u4f5c\u5168\u90e8\u90fd\u662f\u76f4\u63a5\u67d3\u5230\u9876\u70b9\u3002\n\n\u8ba9\u4eba\u60f3\u5230 LCT \u7684 $access$ \u64cd\u4f5c\u3002\n\n\u53d1\u73b0\u6bcf\u6b21\u90fd\u662f\u5f00\u4e00\u4e2a\u65b0\u7684\u989c\u8272\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff1a\u4e00\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u6709\u591a\u5c11\u79cd\u989c\u8272\uff0c\u4f53\u73b0\u5728 LCT \u4e0a\u5373\uff1a\u4ece\u6b64\u70b9\u8d70\u5230\u6839\u8282\u70b9\u9700\u8981\u8d70\u7684\u865a\u94fe\u4e2a\u6570 $+ 1$\u3002\n\n\u521d\u59cb\u65f6\u6bcf\u4e2a\u70b9\u90fd\u662f\u4e00\u4e2a\u65b0\u989c\u8272\uff0c\u5373 LCT \u4e2d\u7684\u6240\u6709\u8fb9\u90fd\u662f\u865a\u8fb9\u3002\n\n\u8003\u8651\u8bb0$dis[x]$\u8868\u793a\u4ece\u6839\u8282\u70b9\u8d70\u5230\u6b64\u70b9\u9700\u8981\u7ecf\u8fc7\u591a\u5c11\u6761\u865a\u94fe$+1$\uff0c\u90a3\u4e48\u6700\u521d\u7684 $dis[x]$ \u4e3a $dep[x]$\n\n\u76f8\u5bf9\u800c\u8a00\u8f83\u4e3a\u597d\u5904\u7406\u7684\u662f $2$ \u64cd\u4f5c\uff0c\u8003\u8651\u6811\u4e0a\u5dee\u5206\uff0c\u500d\u589e\u6c42 $LCA$ \u4e0d\u96be\u53d1\u73b0\u7b54\u6848\u4e3a\uff1a$dis[x] + dis[y] - 2 * dis[lca] + 1$\n\n\u63a5\u4e0b\u6765\u8003\u8651\u64cd\u4f5c$3$ \u64cd\u4f5c$3$ \u9700\u8981\u7ef4\u62a4\u7684\u662f\u5b50\u6811\u4fe1\u606f\u3002\n\n\u6240\u4ee5\u9700\u8981\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4 $dis$\u6570\u7ec4 $->$ \u7ebf\u6bb5\u6811\u3002\n\n\u5982\u679c\u5bf9\u539f\u6811\u6309\u7167 $dfs$ \u8fdb\u884c\u904d\u5386\uff0c\u5728 $dfs$ \u5e8f\u4e2d\u6bcf\u68f5\u5b50\u6811\u5bf9\u5e94\u7684\u533a\u95f4\u90fd\u662f\u8fde\u7eed\u7684\u3002\n\n\u90a3\u4e48\u64cd\u4f5c$3$\u5c31\u53d8\u6210\u4e86\u5728\u7ebf\u6bb5\u6811\u4e2d\u8be2\u95ee\u533a\u95f4\u6700\u5927 $dis$ \u503c\u3002\n\n\u73b0\u5728\u6211\u4eec\u6765\u8003\u8651\u6700\u6076\u5fc3\u7684 **\u64cd\u4f5c$1$**\n\n\u8fd9\u662f\u4e00\u4e2a $access$\n\n\u6211\u4eec\u770b\u770b\u4e00\u822c\u7684$access$\u662f\u600e\u4e48\u5199\u7684\uff1a\n\n```cpp\nvoid access( int x ) {\n\tfor( int y = 0; x; y = x, x = t[y].fa )\n    \tSplay(x), t[x].son[1] = y, pushup(x);\n}\n```\n\n\u5982\u679c\u5c06\u8fd9\u6bb5\u4ee3\u7801\u5206\u5f97\u66f4\u7ec6\u4e00\u70b9\uff0c\u5176\u5b9e\u662f\uff1a\n\n$1.$\u5148\u5c06 $x$ \u65cb\u5230$Splay$\u6839\u3002\n\n$2.$\u5c06 $x$ \u7684\u53f3\u513f\u5b50\u53d8\u865a\n\n$3.$\u5c06 $x$ \u7684\u865a\u513f\u5b50$(y)$ \u53d8\u5b9e\u3002\n\n\u7136\u540e$pushup$\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u4e00\u8fc7\u7a0b\u4e2d\u5176\u5b9e\u53d1\u751f\u4e86\uff1a1.\u4e00\u6761\u865a\u94fe\u53d8\u6210\u4e86\u5b9e\u94fe\uff0c2.\u4e00\u6761\u5b9e\u94fe\u53d8\u6210\u4e86\u865a\u94fe\u3002\n\n\u8003\u8651\u5b83\u539f\u6765\u7684\u513f\u5b50\uff0c\u8fd9\u6761\u5b9e\u94fe\u53d8\u6210\u4e86\u865a\u94fe\uff0c\u90a3\u4e48\u5b83\u7684\u513f\u5b50\u53ca\u5176\u4e0b\u9762\u6240\u6709\u7684\u70b9\u5f80\u6839\u8282\u70b9\u8d70\u7684\u65f6\u5019\u90fd\u8981\u591a\u7ecf\u8fc7\u4e00\u6761\u865a\u94fe\uff0c\u6362\u800c\u8a00\u4e4b\uff1a\u6b64\u513f\u5b50\u6240\u7ba1\u8f96\u7684\u5b50\u6811\u533a\u95f4\u7684 $dis$ \u503c\u5168\u90e8 $+1$\n\n\u7136\u540e\u53e6\u4e00\u4e2a\u64cd\u4f5c\u4e3a\uff1a\u4e00\u4e2a\u865a\u513f\u5b50\u53d8\u6210\u4e86\u5b9e\u513f\u5b50\uff0c\u90a3\u4e48\u6b64\u513f\u5b50\u53d8\u6210\u4e86\u5b9e\u513f\u5b50\uff0c\u90a3\u4e48\u5176\u7684\u513f\u5b50\u8d70\u5230\u6839\u8282\u70b9\u7684\u8def\u4e0a\u90fd\u4f1a\u5c11\u8d70\u4e00\u6761\u865a\u94fe\uff0c\u7b49\u4ef7\u4e8e\uff1a\u6b64\u513f\u5b50\u6240\u7ba1\u8f96\u7684\u6240\u6709\u5b50\u6811\u533a\u95f4\u7684 $dis$ \u503c\u5168\u90e8 $-1$\n\n\u6ce8\u610f\u5751\u70b9\uff1a\u6bd4\u5982\u8fd9\u6837\u5199\u5c31\u662f\u9519\u7684\uff08\u4f2a\u4ee3\u7801\uff09\uff1a\n\n```cpp\nvoid access( int x ) {\n\t\n    for( int y = 0; x; y = x, x = t[y].fa ) {\n    \tSplay(x), update( rs(x), + 1 ); //\u66f4\u65b0\u53f3\u513f\u5b50\u3002\n        update( y, -1 ), t[x].son[1] = y;\n\t}\n}\n```\n\n\u9700\u8981\u6ce8\u610f\uff1a$1.LCT$ \u4e2d\u7684$Splay$\u4f5c\u4e3a\u8f85\u52a9\u6811\uff0c\u5176\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u4e2d\u5e8f\u904d\u5386\uff0c\u5e76\u4e0d\u662f\u771f\u5b9e\u6811\u4e2d\u7684\u4e00\u79cd\u7236\u5b50\u5173\u7cfb\uff0c\u7136\u800c\u6211\u4eec\u505a\u7684\u64cd\u4f5c\u662f\u5bf9\u5176\u771f\u5b9e\u7684\u513f\u5b50\u6240\u7ba1\u8f96\u7684\u533a\u95f4\u505a\u7684$+1/-1$ \u6240\u4ee5\u6211\u4eec\u8981\u627e\u5230\u5176\u539f\u672c\u7684\u513f\u5b50\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5bf9\u4e8e\u539f\u6811\uff0c\u6211\u4eec\u9700\u8981\u627e\u5230\u5176\u53f3\u5b50\u6811(\u6df1\u5ea6\u6bd4\u5176\u5927\u7684\u70b9)\u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u3002\n\n\u5bf9\u4e8e\u63a5\u4e0a\u53bb\u7684\u70b9\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u627e\u5230\u5176\u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u3002\n\n\u6545\u5176\u5b9e\u8fd8\u8981\u4e00\u4e2a $findroot$ \u51fd\u6570\uff08\u67d0\u4e00\u9897\u5b50\u6811\u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff09\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\u4e2d$access$\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint read() {\n\tchar cc = getchar(); int cn = 0, flus = 1;\n\twhile(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }\n\twhile(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();\n\treturn cn * flus;\n}\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define drep( i, t, s ) for( register int i = t; i >= s; -- i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\n#define Max( x, y ) ( ( (x) > (y) ) ? (x) : (y) )\nconst int N = 1e5 + 5;\nint L[N], R[N], rev[N], id[N], head[N], n, m, cnt, tot ;\nint fath[N][21], dep[N];\nstruct E {\n\tint to, next ;\n} e[N * 2];\nnamespace Tree {\n\t#define ls(x) ( x * 2 )\n\t#define rs(x) ( x * 2 + 1 )\n\tstruct Tr {\n\t\tint mark, mx;\n\t}tr[N * 4];\n\tvoid pushup( int x ) {\n\t\tif( tr[x].mark ) {\n\t\t\ttr[ls(x)].mark += tr[x].mark, tr[ls(x)].mx += tr[x].mark ;\n\t\t\ttr[rs(x)].mark += tr[x].mark, tr[rs(x)].mx += tr[x].mark ;\n\t\t\ttr[x].mark = 0;\n\t\t}\n\t}\n\tvoid build( int x, int l, int r ) {\n\t\tif( l == r ) { tr[x].mx = dep[rev[l]]; return ; }\n\t\tint mid = ( l + r ) >> 1;\n\t\tbuild( ls(x), l, mid ), build( rs(x), mid + 1, r );\n\t\ttr[x].mx = Max( tr[ls(x)].mx, tr[rs(x)].mx );\n\t}\n\tint query( int x, int l, int r, int ll, int rr ) {\n\t\tif( l > rr || r < ll ) return 0;\n\t\tif( l >= ll && r <= rr ) return tr[x].mx;\n\t\tpushup(x);\n\t\tint mid = ( l + r ) >> 1;\n\t\treturn max( query( ls(x), l, mid, ll, rr ), query( rs(x), mid + 1, r, ll, rr ) );\n\t}\n\tvoid update( int x, int l, int r, int ll, int rr, int add ) {\n\t\tif( l > rr || r < ll ) return ;\n\t\tif( l >= ll && r <= rr ) {\n\t\t\ttr[x].mark += add, tr[x].mx = tr[x].mx + add;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = ( l + r ) >> 1;\n\t\tpushup(x);\n\t\tupdate( ls(x), l, mid, ll, rr, add ), update( rs(x), mid + 1, r, ll, rr, add );\n\t\ttr[x].mx = max( tr[ls(x)].mx, tr[rs(x)].mx );\n\t}\n}\nnamespace LCT1 {\n\t#define ls(x) t[x].son[0]\n\t#define rs(x) t[x].son[1]\n\tstruct LCT {\n\t\tint son[2], fa, val;\n\t\tbool mark ;\n\t} t[N * 2];\n\tint isroot( int x ) {\n\t\treturn ( ls(t[x].fa) != x ) && ( rs(t[x].fa) != x ) ;\n\t}\n\tvoid pushmark( int x ) {\n\t\tif( t[x].mark ) {\n\t\t\tswap( ls(x), rs(x) ); \n\t\t\tt[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1;\n\t\t}\n\t}\n\tvoid rotate( int x ) {\n\t\tint f = t[x].fa, ff = t[f].fa, qwq = ( rs(t[x].fa) == x );\n\t\tt[x].fa = ff;\n\t\tif( !isroot(f) ) t[ff].son[rs(ff) == f] = x ;\n\t\tt[f].son[qwq] = t[x].son[qwq ^ 1], t[t[x].son[qwq ^ 1]].fa = f ;\n\t\tt[x].son[qwq ^ 1] = f, t[f].fa = x ;\n\t}\n\tint st[N];\n\tvoid Splay( int x ) {\n\t\tint top = 0, now = x; st[++ top] = now ;\n\t\twhile( !isroot(now) ) st[++ top] = ( now = t[now].fa );\n\t\twhile( top ) pushmark( st[top --] );\n\t\twhile( !isroot(x) ) {\n\t\t\tint f = t[x].fa, ff = t[f].fa;\n\t\t\tif( !isroot(f) ) ( ( rs(f) == x ) ^ ( rs(ff) == f ) ) ? rotate(x) : rotate(f) ;\n\t\t\trotate(x);\n\t\t}\n\t}\n\tint findrt( int x ) { //\u8981\u627e\u5230\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u3002 \n\t\twhile( ls(x) ) x = ls(x) ;\n\t\treturn x;\n\t}\n\tvoid access( int x ) { //access \n\t\tint son;\n\t\tfor( int y = 0; x; y = x, x = t[y].fa ) {\n\t\t\tSplay(x);\n\t\t\tif( rs(x) ) son = findrt(rs(x)), Tree :: update( 1, 1, n, L[son], R[son], 1 ); //\u5982\u679c\u513f\u5b50\u5b58\u5728\u624dupdate \n\t\t\tif( rs(x) = y ) son = findrt(y), Tree :: update( 1, 1, n, L[son], R[son], -1 );\n\t\t\tt[x].son[1] = y ; \n\t\t}\n\t}\n}\nvoid add( int x, int y ) {\n\te[++ cnt] = (E){ y, head[x] }, head[x] = cnt ;\n\te[++ cnt] = (E){ x, head[y] }, head[y] = cnt ; \n}\nvoid dfs( int x, int fa ) {\n\tL[x] = ++ tot, rev[tot] = x; // L[x],R[x]\u8868\u793ax\u7ba1\u8f96\u7684\u533a\u95f4\uff0crev\u8868\u793a\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\u5bf9\u5e94\u70b9 \n\tLCT1::t[x].fa = fath[x][0] = fa, dep[x] = dep[fa] + 1 ;\n\trep( i, 1, 19 ) fath[x][i] = fath[fath[x][i - 1]][i - 1]; //\u500d\u589e\u5904\u7406 \n\tNext( i, x ) {\n\t\tint v = e[i].to ;\n\t\tif( v == fa ) continue ;\n\t\tdfs( v, x );\n\t}\n\tR[x] = tot ;\n}\nint LCA( int x, int y ) { //LCA\n\tif( dep[x] < dep[y] ) swap( x, y );\n\tdrep( i, 19, 0 ) if( dep[fath[x][i]] >= dep[y] ) x = fath[x][i] ;\n\tdrep( i, 19, 0 ) if( fath[x][i] != fath[y][i] ) x = fath[x][i], y = fath[y][i] ;\n\treturn ( x == y ) ? x : fath[x][0] ;\n}\nsigned main()\n{\n\tn = read(), m = read() ;\n\tint x, y, opt, ans ;\n\trep( i, 1, n - 1 ) x = read(), y = read(), add( x, y );\n\tdfs( 1, 1 ); LCT1 :: t[1].fa = 0; \n\tTree :: build( 1, 1, n ); //\u521d\u59cb\u5efa\u6811 \n\t\n\trep( i, 1, m ) {\n\t\topt = read(), x = read();\n\t\tif( opt == 1 ) LCT1 :: access(x);\n\t\tif( opt == 2 ) {\n\t\t\ty = read();\n\t\t\tint lca = LCA( x, y );\n\t\t\tint ans1 = Tree :: query( 1, 1, n, L[x], L[x] ) ;\n\t\t\tint ans2 = Tree :: query( 1, 1, n, L[y], L[y] ) ;\n\t\t\tint ans3 = ( Tree :: query( 1, 1, n, L[lca], L[lca] ) );\n\t\t\tprintf(\"%d\\n\", ans1 + ans2 - 2 * ans3 + 1 );\n\t\t}\n\t\tif( opt == 3 ) {\n\t\t\tans = Tree :: query( 1, 1, n, L[x], R[x] );\n\t\t\tprintf(\"%d\\n\", ans );\n\t\t}\t\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1554280498,
        "uid": 30036,
        "name": "Soulist",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u8fd9\u7bc7\u9898\u89e3\u662f\u4e3a\u9ad8\u8d5e\u6811\u5256\u9898\u89e3\u505a\u6ce8\u89e3\u7684\uff0c\u56e0\u4e3a\u8bb8\u591a\u4eba\u770b\u4e0d\u61c2\u90a3\u7bc7\u5728\u8bf4\u4ec0\u4e48\uff08\u6211\u4e5f\u770b\u4e0d\u61c2\n\n\u9996\u5148\uff0c\u6211\u4eec\u5728\u6811\u5256\u65f6\u8981\u7ef4\u62a4\u4ec0\u4e48\uff1f\n\n\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u7684\u7b54\u6848\uff1b\u7ef4\u62a4\u533a\u95f4\u5185\u7b54\u6848\u6700\u5927\u503c\uff1b\u7ef4\u62a4\u8fd9\u4e2a\u70b9\u7684\u989c\u8272\u548c\u533a\u95f4\u8986\u76d6\u989c\u8272\u6807\u8bb0\u3002\u5176\u4e2d\uff0c\u989c\u8272\u548c\u53e6\u5916\u4e24\u4e2a\u662f\u5206\u5f00\u7ef4\u62a4\u7684\u3002\n\n\u7136\u540e\u600e\u4e48\u7ef4\u62a4\uff1f\n\n\u6bcf\u4e00\u6b21\u66b4\u529b\u627e\u5230\u76f8\u540c\u989c\u8272\u7ec4\u6210\u7684\u6bb5\uff0c\u4e00\u6bb5\u4e00\u6bb5\u5730\u4fee\u6539\u3002\u540c\u4e00\u6bb5\u5185\u7528\u6811\u5256\u7ef4\u62a4\u3002\n\n\u5177\u4f53\u5982\u4f55\u4fee\u6539\uff1f\u6211\u4eec\u8003\u8651\u73b0\u5728\u6b63\u5728 $x\\rightarrow top_x$ \u91cd\u94fe\u4e0a\u7684\u60c5\u51b5\uff0c\u8bbe $lst$ \u4e3a $x$ \u4e0b\u9762\u521a\u8f6c\u79fb\u8fc7\u6765\u7684\u8282\u70b9\u3002\n\n$lst$ \u7684\u5b50\u6811\u5185\u663e\u7136\u7ef4\u62a4\u5b8c\u6bd5\u3002\u6211\u4eec\u9700\u8981\u7ed9\u7ea2\u5708\u5185\u90e8\u5206\u6574\u4f53\u51cf\u53bb\u539f\u6765 $x$ \u5230\u6839\u7684\u6bb5\u6570\u3002\uff08\u7ea2\u5708\u88ab\u5403\u4e86\u3002\u3002\u3002\u5c31\u662f\u56fe\u4e0a\u9664\u4e86 $lst$ \u5b50\u6811\u4e4b\u5916\u7684\u90e8\u5206\uff09\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/1aztyl89.png)\n\n\u6211\u4eec\u5148\u7ed9 $top_x$ \u7684\u5b50\u6811\u5168\u51cf\u6389\uff0c\u518d\u5355\u72ec\u7ed9 $lst$ \u52a0\u56de\u6765\u5373\u53ef\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nvoid LineModify(int x,int y,int lst) {\n\twhile(top[x]!=top[y]) {\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tint gyh=Query(1,1,n,pos[x],pos[x]);\n\t\tAdd(1,1,n,pos[top[x]],pos[top[x]]+size[top[x]]-1,1-gyh);\n\t\tif(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);\n\t\tChangecol(1,1,n,pos[top[x]],pos[x],tot);\n\t\tlst=top[x],x=fa[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tint gyh=Query(1,1,n,pos[x],pos[x]);\n\tAdd(1,1,n,pos[x],pos[x]+size[x]-1,1-gyh);\n\tif(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);\n\tChangecol(1,1,n,pos[x],pos[y],tot);\n}\n```\n\n\u8fd8\u6709\u4e00\u4e2a\u8981\u6ce8\u610f\u7684\u70b9\u3002\n\n\u5047\u5982\u539f\u6765\u8fd9\u6bb5\u989c\u8272\u5e76\u6ca1\u6709\u88ab\u6b63\u5728\u4fee\u6539\u7684\u8def\u5f84\u5b8c\u5168\u8986\u76d6\uff0c\u5219\u9700\u8981\u5bf9\u8fd9\u6bb5\u989c\u8272\u6240\u5728\u7684\u5b50\u6811\u5355\u72ec\u52a0\u4e00\uff08\u8bf7\u81ea\u884c\u753b\u56fe\u7406\u89e3\uff09\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nvoid Change(int x) {\n\tfrom[++tot]=x,to[tot]=1;\n\tint lst=0;\n\twhile(x) {\n\t\tint tmp=Querycol(1,1,n,pos[x]),TO=to[tmp];\n\t\tif(from[tmp]==x)from[tmp]=to[tmp]=0;\n\t\telse to[tmp]=Climb(from[tmp],x),Add(1,1,n,pos[to[tmp]],pos[to[tmp]]+size[to[tmp]]-1,1);//\u5c31\u662f\u8fd9\u91cc\n\t\tLineModify(x,TO,lst);\n\t\tx=fa[TO],lst=TO;\n\t}\n}\n```\n\n\u603b\u4f53\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#define pos dfn\nusing namespace std;\nvector<int> g[100005];\nint top[100005],fa[100005],dfn[100005],n,q,size[100005],son[100005],id[100005],sign;\nint d[100005],tag[400005],mx[400005],from[200005],to[200005],tot,col[400005],p[100005][20];\nvoid DFS1(int x,int f) {\n\tsize[x]=1,fa[x]=p[x][0]=f,d[x]=d[f]+1,from[x]=to[x]=x;\n\tfor(int i=1;i<=16;i++)p[x][i]=p[p[x][i-1]][i-1];\n\tfor(int y:g[x]) {\n\t\tif(y==f)continue;\n\t\tDFS1(y,x);\n\t\tsize[x]+=size[y];\n\t\tif(size[son[x]]<size[y])son[x]=y;\n\t}\n}\nvoid DFS2(int x,int tp) {\n\ttop[x]=tp,dfn[x]=++sign,id[sign]=x;\n\tif(son[x])DFS2(son[x],tp);\n\tfor(int y:g[x]) {\n\t\tif(y==fa[x]||y==son[x])continue;\n\t\tDFS2(y,y);\n\t}\n}\nvoid Build(int p,int l,int r) {\n\tif(l==r) {\n\t\tmx[p]=d[id[l]],col[p]=id[l];\n\t\treturn ;\n\t}\n\tint mid=(l+r)/2;\n\tBuild(p*2,l,mid),Build(p*2+1,mid+1,r);\n\tmx[p]=max(mx[p*2],mx[p*2+1]);\n}\nvoid Pushdown(int p){\n\tif(tag[p]){\n\t\tmx[p*2]+=tag[p],mx[p*2+1]+=tag[p];\n\t\ttag[p*2]+=tag[p],tag[p*2+1]+=tag[p];\n\t\ttag[p]=0;\n\t}\n\tif(col[p]){\n\t\tcol[p*2]=col[p*2+1]=col[p];\n\t\tcol[p]=0;\n\t}\n}\nint Climb(int x,int y){\n\tfor(int i=16;i>=0;i--)if(d[p[x][i]]>d[y])x=p[x][i];\n\treturn x;\n}\nint Query(int p,int l,int r,int x,int y) {\n\t//cout<<l<<' '<<r<<' '<<mx[p]<<endl;\n\tif(x<=l&&r<=y)return mx[p];\n\tPushdown(p);\n\tint mid=(l+r)/2,ret=0;\n\tif(x<=mid)ret=max(ret,Query(p*2,l,mid,x,y));\n\tif(mid<y)ret=max(ret,Query(p*2+1,mid+1,r,x,y));\n\treturn ret;\n}\nint Querycol(int p,int l,int r,int x) {\n\tif(l==r)return col[p];\n\tPushdown(p);\n\tint mid=(l+r)/2;\n\tif(x<=mid)return Querycol(p*2,l,mid,x);\n\telse return Querycol(p*2+1,mid+1,r,x);\n}\nvoid Add(int p,int l,int r,int x,int y,int z) {\n\tif(x<=l&&r<=y){\n\t\ttag[p]+=z,mx[p]+=z;\n\t\treturn ;\n\t}\n\tPushdown(p);\n\tint mid=(l+r)/2,ret=0;\n\tif(x<=mid)Add(p*2,l,mid,x,y,z);\n\tif(mid<y)Add(p*2+1,mid+1,r,x,y,z);\n\tmx[p]=max(mx[p*2],mx[p*2+1]);\n}\nvoid Changecol(int p,int l,int r,int x,int y,int z) {\n\tif(x<=l&&r<=y){\n\t\tcol[p]=z;\n\t\treturn ;\n\t}\n\tPushdown(p);\n\tint mid=(l+r)/2,ret=0;\n\tif(x<=mid)Changecol(p*2,l,mid,x,y,z);\n\tif(mid<y)Changecol(p*2+1,mid+1,r,x,y,z);\n}\nvoid LineModify(int x,int y,int lst) {\n\t//cout<<\"Modifying:\"<<x<<' '<<y<<' '<<lst<<endl;\n\twhile(top[x]!=top[y]) {\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tint gyh=Query(1,1,n,pos[x],pos[x]);\n\t\tAdd(1,1,n,pos[top[x]],pos[top[x]]+size[top[x]]-1,1-gyh);\n\t\tif(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);\n\t\t//cout<<\"Add:\"<<top[x]<<' '<<1-gyh<<endl;\n\t\t//cout<<\"Add:\"<<lst<<' '<<gyh-1<<endl;\n\t\tChangecol(1,1,n,pos[top[x]],pos[x],tot);\n\t\tlst=top[x],x=fa[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\tint gyh=Query(1,1,n,pos[x],pos[x]);\n\t//cout<<\"Add:\"<<x<<' '<<1-gyh<<endl;\n\t//cout<<\"Add:\"<<lst<<' '<<gyh-1<<endl;\n\tAdd(1,1,n,pos[x],pos[x]+size[x]-1,1-gyh);\n\tif(lst)Add(1,1,n,pos[lst],pos[lst]+size[lst]-1,gyh-1);\n\tChangecol(1,1,n,pos[x],pos[y],tot);\n}\nvoid Change(int x) {\n\tfrom[++tot]=x,to[tot]=1;\n\tint lst=0;\n\twhile(x) {\n\t\tint tmp=Querycol(1,1,n,pos[x]),TO=to[tmp];\n\t\t//cout<<\"COL:\"<<x<<' '<<tmp<<' '<<TO<<endl;\n\t\tif(from[tmp]==x)from[tmp]=to[tmp]=0;\n\t\telse to[tmp]=Climb(from[tmp],x),Add(1,1,n,pos[to[tmp]],pos[to[tmp]]+size[to[tmp]]-1,1);\n\t\tLineModify(x,TO,lst);\n\t\tx=fa[TO],lst=TO;\n\t}\n}\nint LCA(int x,int y){\n\twhile(top[x]!=top[y]) {\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tx=fa[top[x]];\n\t}\n\tif(d[x]>d[y])swap(x,y);\n\treturn x;\n}\nint main() {\n\tscanf(\"%d%d\",&n,&q),tot=n;\n\tfor(int i=1,x,y; i<n; i++)scanf(\"%d%d\",&x,&y),g[x].push_back(y),g[y].push_back(x);\n\tDFS1(1,0);\n\tDFS2(1,1);\n\tBuild(1,1,n);\n\twhile(q--) {\n\t\tint opt,x,y;\n\t\tscanf(\"%d%d\",&opt,&x);\n\t\tif(opt==1)Change(x);\n\t\tif(opt==2) {\n\t\t\tscanf(\"%d\",&y);\n\t\t\tint lca=LCA(x,y);\n\t\t\tprintf(\"%d\\n\",Query(1,1,n,pos[x],pos[x])+Query(1,1,n,pos[y],pos[y])-2*Query(1,1,n,pos[lca],pos[lca])+1);\n\t\t}\n\t\tif(opt==3)printf(\"%d\\n\",Query(1,1,n,pos[x],pos[x]+size[x]-1));\n\t}\n\treturn 0;\n}\n/*\n5 7\n1 2\n2 3\n3 4\n3 5\n2 4 5\n3 3\n1 4\n2 4 5\n1 5\n2 4 5\n3 1\n*/\n```",
        "postTime": 1585654189,
        "uid": 42156,
        "name": "feecle6418",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u6211\u592a\u5f31\u4e86\u8fde\u6811\u5256\u90fd\u4e0d\u4f1a\n\n\u4e8e\u662f\u6765\u4e00\u6ce2\u6ca1\u6709\u6811\u5256\u7684\u9898\u89e3\n\n### \u95f2\u8bdd\n\n\u8fd9\u662f\u6240\u6709LCT\u9898\u76ee\u4e2d\u7684\u4e00\u4e2a\u5f02\u7c7b\u3002\n\n\u4e4b\u6240\u4ee5\u8ba4\u4e3a\u662fLCT\u9898\u76ee\uff0c\u662f\u56e0\u4e3a\u672c\u9898\u601d\u8def\u7684\u74f6\u9888\u5c31\u5728\u4e8e\u5982\u4f55\u53bb\u7ef4\u62a4\u540c\u989c\u8272\u7684\u70b9\u7684\u96c6\u5408\u3002\n\n\u53ea\u4e0d\u8fc7\u505a\u7740\u505a\u7740\uff0c\u611f\u89c9\u540e\u6765\u7684\u601d\u8def\uff08dfn\u5e8f\uff0c\u7ebf\u6bb5\u6811\uff0cLCA\uff09\u4f3c\u4e4e\u8981\u55a7\u5bbe\u593a\u4e3b\u4e86\u3002\u3002\u3002\uff08\u81f3\u5c11\u5728\u4ee3\u7801\u4e0a\u770b\u662f\u5982\u6b64\uff09\n\n## \u601d\u8def\u5206\u6790\n\n\u4e00\u4e2a\u4e00\u4e2a\u64cd\u4f5c\u6765\uff08\u778eBB\u4e2d\uff0c\u8fd9\u79cd\u601d\u8def\u6a21\u5f0f\u5e76\u4e0d\u5177\u6709\u666e\u904d\u6027\u3002\u3002\u3002\u3002\u3002\u3002\uff09\n\n### 1\u64cd\u4f5c\n\n~~\u8fd8\u597d\u6211\u6ca1\u5b66\u6811\u5256233333~~\u4ee5\u81f3\u4e8e~~\uff08\u76f4\u63a5\u60f3\u5230\uff09~~\u53ea\u597d\u7528LCT\u6765\u7ef4\u62a4\u989c\u8272\u3002\n\n\u9898\u76ee\u900f\u9732\u51fa\u7684\u795e\u5947\u7684\u6027\u8d28\u2014\u2014\u6bcf\u4e00\u79cd\u989c\u8272\uff0c\u65e0\u8bba\u5728\u4efb\u4f55\u65f6\u523b\uff0c\u80af\u5b9a\u662f\u4e00\u6761\u94fe\uff0c\u800c\u4e14\u70b9\u7684\u6df1\u5ea6\u4e25\u683c\u9012\u589e\uff01\n\n\u800c\u4e14\u8fd8\u7279\u610f\u6307\u5b9a\u6839\u8282\u70b9\uff011\u64cd\u4f5c\u7279\u610f\u4fee\u6539x\u5230\u6839\u8282\u70b9\u7684\u989c\u8272\uff01\n\n\u60f3\u5230\u4e86\u8fd9\u91cc\uff0c\u5c31\u4e0d\u96be\u60f3\u5230\u672c\u9898\u7684\u5173\u952e\u6a21\u578b\u2014\u2014LCT\u4e2d\u6bcf\u4e2aSplay\u8f85\u52a9\u6811\u7ef4\u62a4\u540c\u989c\u8272\u70b9\u7684\u96c6\u5408\n\n\u4e8e\u662f1\u64cd\u4f5c==access\u3002\u3002\u3002\u3002\u3002\u3002\n### 2\u64cd\u4f5c\nx\u5230y\u8def\u5f84\uff1fsplit\uff1f\uff01\n\n~~I'm too young too simple~~\n\nLCT\u7ef4\u62a4\u4e86\u96c6\u5408\uff0c\u5c31\u53ea\u80fd\u7ef4\u62a4\u96c6\u5408\u4e86\u3002\u968f\u4fbf\u518d\u4e71\u641e\u4e00\u4e0b\u96c6\u5408\u5c31\u88ab\u7834\u574f\u4e86\u3002\n\n\u4e8e\u662f\u5c31\u8981\u518d\u5916\u90e8\u7ef4\u62a4\u4e86\u3002\n\n\u81f3\u4e8e\u7ef4\u62a4\u4ec0\u4e48\uff0c\u73b0\u5728\u5176\u5b9e\u8fd8\u4e0d\u80fd\u4ea7\u751f\u5f88\u597d\u7684\u601d\u8def\u3002\u3002\u3002\u3002\u3002\n\n\u4f46\u6211\u4eec\u53ef\u4ee5\u5148\u60f3\u5230\u4e00\u70b9\uff1a\u6ca1\u6709\u4e86LCT\uff0c\u8fd8\u8981\u8d44\u78c1\u6811\u4e2d\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u7684\u8be2\u95ee\uff1f\n\n\u5e38\u89c1\u7684\u590d\u6742\u5ea6\u6b63\u786e\u7684\u65b9\u6cd5~~\uff08\u5957\u8def\uff09~~\u80fd\u60f3\u5230\u7684\u5c31\u53ea\u6709\u6811\u4e0a\u5dee\u5206\u4e86\u5427\uff08\u8bbeF\u4e3a\u72b6\u6001\uff0c\u90a3\u4e48\u5c31\u5f62\u5982F[x]+F[y]-F[lca]\uff09\n\n\u4e8e\u662f\u5c31\u53ef\u4ee5\u53ea\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u7684\u989c\u8272\u79cd\u6570\n\u8f6c\u5316\u4e00\u4e0b\uff0c\u5728LCT\u4e2d\u5c31\u7b49\u4ef7\u4e8e\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u6240\u8981\u7ecf\u8fc7\u7684\u8f7b\u8fb9\u603b\u6570\uff0c\u8fd9\u91cc\u53c8\u662f\u4e00\u4e2a\u5173\u952e\u70b9\n\u67e5\u8be2F[x]+F[y]-2F[lca]+1\uff08+1\u662f\u56e0\u4e3alca\u6240\u5728\u7684\u989c\u8272\u88ab\u51cf\u4e86\u4e24\u6b21\uff09\n\n\u4e0d\u4f1a\u6811\u5256\uff0c\u53ea\u597d\u5199\u500d\u589eLCA\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u8f6c\u800c\u601d\u8003\u5982\u4f55\u7ef4\u62a4\u8fd9\u4e2a\u72b6\u6001\u4e86\n\n\u9996\u5148\u521d\u59cb\u72b6\u6001\u5c31\u662f\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\uff0c\u7136\u540e\u5c31\u63a5\u7740\u8003\u8651\u4fee\u6539\u4e86\u3002\n\n\u56e0\u4e3a\u72b6\u6001\u53ea\u4e0e\u8f7b\u8fb9\u6709\u5173\uff0c\u6240\u4ee5\u5728access\u65f6\u66f4\u6539\u5c31\u53ef\u4ee5\u5566\n\n\u53ef\u4ee5\u7c7b\u6bd4\u4e00\u4e0bLCT\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\u548c\uff08\u53ef\u53c2\u8003\u4e00\u4e0b[Blog\u7684LCT\u603b\u7ed3](http://www.cnblogs.com/flashhu/p/8324551.html)\uff09\n\naccess\u4e2d\u6709\u66ff\u6362\u53f3\u513f\u5b50\u7684\u64cd\u4f5c\uff0c\u7b49\u4e8e\u628a\u539f\u6765\u4e00\u6761\u8fb9\u53d8\u8f7b\uff0c\u65b0\u7684\u4e00\u6761\u8fb9\u53d8\u91cd\n\n\u90a3\u4e48\u539f\u6765\u90a3\u6761\u8fb9\u6240\u6307\u7684\u5b50\u6811\u72b6\u6001\u5168\u90e8\u8981+1\uff08\u591a\u4e86\u4e00\u4e2a\u8f7b\u8fb9\uff09\uff0c\u65b0\u8fde\u4e0a\u7684\u8fb9\u6240\u6307\u7684\u5b50\u6811\u72b6\u6001\u5168\u90e8\u8981-1\n\n\u4e8e\u662f\u95ee\u9898\u53c8\u51fa\u73b0\u4e86\u3002\u3002\u3002\n\n\u4f17\u6240\u5468\u77e5\uff0cLCT\u53ef\u4ee5\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\uff0c\u4f46\u4e0d\u53ef\u4ee5\u4fee\u6539\u5b50\u6811\u4fe1\u606f\n\n\u6811\u5256\u5f88\u597d\u7ef4\u62a4\u5c31\u4e0d\u63d0\u4e86\uff0c\u7136\u540e\u6211\u53c8\u4e0d\u4f1a\u6811\u5256TOT\uff08\u6211\u592a\u5f31\u4e86\uff09\n\n\u5728\u8fd9\u7d27\u8981\u5173\u5934\uff0cdfn\u5e8f\u6551\u4e86\u6211\u3002\u3002\u3002\u3002\u3002\u3002\n\n\u4e00\u4e2a\u5b50\u6811\uff0c\u6240\u6709\u7684\u70b9\u7684dfn\u5e8f\u4e00\u5b9a\u662f\u8fde\u7eed\u7684\u533a\u95f4\n\u6240\u4ee5\u7ef4\u62a4\u7ebf\u6bb5\u6811\uff0c\u8868\u793adfn\u5e8f\u7684\u533a\u95f4\uff0c\u4fee\u6539\u7684\u65f6\u5019\u5728\u5bf9\u5e94\u7684\u533a\u95f4\u4fee\u6539\uff0c\u67e5\u8be2\u5c31\u5355\u70b9\u67e5\n\n### 3\u64cd\u4f5c\n\n\u6240\u6709\u7684\u601d\u8def\u96be\u70b9\uff0c\u5728\u64cd\u4f5c2\u5197\u957f\u7684\u601d\u8def\u5206\u6790\u4e2d\u90fd\u653b\u514b\u4e86\n\n\u8fd9\u91cc\u5c31\u5728\u7ebf\u6bb5\u6811\u91cc\u7ef4\u62a4\u72b6\u6001\u6700\u5927\u503c\uff08\u6811\u5256\u4e5f\u4e00\u6837\uff09\uff0c\u533a\u95f4\u67e5\u8be2\u5c31\u597d\u5566\n\n\u81f3\u4e8e\u5199\u6cd5\uff0c\u7ebf\u6bb5\u6811\u91cc\u7684\u533a\u95f4\u52a0\u51cf\u6cd5\u53ef\u4ee5\u5199\u61d2\u6807\u8bb0\uff0c\u4e5f\u53ef\u4ee5\u5b9e\u73b0\u6c38\u4e45\u5316\u6807\u8bb0\uff08YL\u5de8\u4f6c\u505a\u6cd5\uff0c\u5e38\u6570\u66b4\u8e29\u672c\u849f\u84bb\uff0c\u76ee\u524drank1\uff09\n\n\u53ea\u4e0d\u8fc7\u6211\u8bd5\u4e86\u4e00\u4e0b\uff0cdfn\u5e8f\u7ebf\u6bb5\u6811\u5199\u6c38\u4e45\u5316\u6807\u8bb0\u56e0\u4e3a\u67d0\u4e9b\u65e0\u6cd5\u63cf\u8ff0\u7684\u7384\u5b66\u95ee\u9898\u53d8\u5f97\u66f4\u6162\u4e86\u3002\u3002\u3002\u3002\u3002\u3002\n\n ---\n \n\u601d\u8def\u5c31\u8fd9\u6837\uff0c\u6709\u4e9b\u7ec6\u8282\u5728\u4ee3\u7801\u91cc\uff08Debug\u4e00\u665a\u4e0a\u5e26\u6765\u7684\u60e8\u75db\u7684\u7ecf\u9a8c\u3002\u3002\u3002\u3002\u3002\u3002\uff09\n\n\u7b97\u4e0ain\uff0cpup\uff0cpdn\u548cmain\uff0c\u6b64\u7a0b\u5e8f\u4e00\u5171\u670915\u4e2a\u51fd\u6570\u3002\u3002\u3002\u3002\u3002\u3002\n\n```cpp\n#include<cstdio>\n#include<iostream>\nusing namespace std;\n#define I inline\n#define R register int\n#define G ch=getchar()\n#define in(z) G;\\\n    while(ch<'-')G;\\\n    z=ch&15;G;\\\n    while(ch>'-')z*=10,z+=ch&15,G\n#define lc x<<1\n#define rc x<<1|1\n#define pup mx[x]=max(mx[lc],mx[rc])\n#define pdn if(lz[x])upd(lc,l[x],m[x],lz[x]),upd(rc,m[x]+1,r[x],lz[x]),lz[x]=0\n//\u90fd\u662f\u7ebf\u6bb5\u6811\u64cd\u4f5c\uff0c\u672c\u9898\u7684LCT\u5185\u90e8\u6ca1\u6709\u7ef4\u62a4\u4fe1\u606f\nconst int N=100009,M=N*20;\nint l[M],m[M],r[M],mx[M],lz[M],f[N],c[N][2],st[N][20],o[N];\nint p=1,he[N],ne[N<<1],to[N<<1],d[N],dfn[N],at[N],mr[N],now;\n//at\u662fdfn\u7684\u53cd\u8868\u793a\uff0cmr\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u5b50\u6811\u5728dfn\u5e8f\u533a\u95f4\u4e2d\u7684\u53f3\u7aef\u70b9\uff08\u5de6\u7aef\u70b9\u662f\u5b83\u81ea\u5df1\uff09\nI void dfs(R x,R fa){//\u5efa\u6811\u9884\u5904\u7406\n    d[now=at[dfn[x]=++p]=x]=d[st[x][0]=f[x]=fa]+1;//\u4e00\u5806\u4fe1\u606f\u7684\u9884\u5904\u7406\u538b\u8fdb\u4e86\u4e00\u884c\n    for(R&i=o[x];(st[x][i+1]=st[st[x][i]][i]);++i);//\u500d\u589eLCA\u9884\u5904\u7406\n    for(R i=he[x];i;i=ne[i])\n        if(fa!=to[i])dfs(to[i],x);\n    mr[x]=now;\n}\nI int lca(R x,R y){//\u6c42LCA\n    if(d[x]<d[y])swap(x,y);\n    for(R i=o[x];i>=0;--i)\n        if(d[st[x][i]]>=d[y])x=st[x][i];//Debug\u4e2d\u7684\u9519\u8bef1\uff1a>=\u5199\u6210\u4e86>\n    if(x==y)return x;\n    for(R i=o[x];i>=0;--i)\n        if(st[x][i]!=st[y][i])x=st[x][i],y=st[y][i];\n    return st[x][0];\n}\nI void build(R x,R s,R e){//\u5efa\u7ebf\u6bb5\u6811\n    l[x]=s;r[x]=e;m[x]=(s+e)>>1;\n    if(s==e){mx[x]=d[at[s]];return;}//\u5229\u7528\u53cd\u8868\u793a\u627e\u5230\u521d\u59cb\u72b6\u6001\n    build(lc,s,m[x]);build(rc,m[x]+1,e);pup;\n}\nI void upd(R x,R s,R e,R v){//\u533a\u95f4\u4fee\u6539\n    if(l[x]==s&&r[x]==e){mx[x]+=v;lz[x]+=v;return;}//\u6ce8\u610fmx\u4e5f\u8981\u53d8\n    pdn;\n    if(e<=m[x])upd(lc,s,e,v);\n    else if(s>m[x])upd(rc,s,e,v);\n    else upd(lc,s,m[x],v),upd(rc,m[x]+1,e,v);\n    pup;\n}\nI int get(R s){//\u5355\u70b9\u67e5\u503c\uff0c\u4e0e\u533a\u95f4\u67e5\u503c\u5206\u5f00\u4e86\uff0c\u4e3a\u4e86\u51cf\u5c0f\u5e38\u6570\n    R x=1;\n    while(l[x]!=r[x]){\n        pdn;x=(lc)+(s>m[x]);\n    }\n    return mx[x];\n}\nI int ask(R x,R s,R e){//\u533a\u95f4\u67e5\u503c\n    if(l[x]==s&&r[x]==e)return mx[x];\n    pdn;\n    if(e<=m[x])return ask(lc,s,e);\n    if(s>m[x])return ask(rc,s,e);\n    return max(ask(lc,s,m[x]),ask(rc,m[x]+1,e));\n}\nI bool nrt(R x){//LCT\u90e8\u5206\n    return c[f[x]][0]==x||c[f[x]][1]==x;\n}\nI void rot(R x){\n    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];\n    if(nrt(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;\n    f[w]=y;f[y]=x;f[x]=z;//Debug\u4e2d\u7684\u9519\u8bef2\uff1ay\u5199\u6210\u4e86x\n}\nI void splay(R x){\n    R y;\n    while(nrt(x)){\n        if(nrt(y=f[x]))rot((c[f[y]][0]==y)^(c[y][0]==x)?x:y);\n        rot(x);\n    }\n}\nI int frt(R x){//\u6709\u522b\u4e8e\u4f20\u7edf\u610f\u4e49\u4e0b\u7684findroot\n    while(c[x][0])x=c[x][0];\n    return x;\n}\nI void access(R x){\n    for(R w,y=0;x;x=f[y=x]){\n        splay(x);\n        if(c[x][1])w=frt(c[x][1]),upd(1,dfn[w],dfn[mr[w]],1);\n        if((c[x][1]=y))w=frt(y),upd(1,dfn[w],dfn[mr[w]],-1);\n//Debug\u4e2d\u7684\u9519\u8bef3\uff1a\u8fd9\u91cc\u66f4\u65b0\u8981\u627e\u539f\u5b50\u6811\u7684\u6839\uff08\u5373\u6df1\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9\uff09\n//\u800c\u4e0d\u80fd\u628a\u8f85\u52a9\u6811\u7684\u6839\u5f53\u539f\u5b50\u6811\u6839\u76f4\u63a5upd(1,dfn[c[x][1]],dfn[mr[c[x][1]]],1)\n    }\n}\nint main(){\n    register char ch;\n    R n,m,i,a,b,op,x,y;\n    in(n);in(m);\n    for(i=1;i<n;++i){\n        in(a);in(b);\n        to[++p]=b;ne[p]=he[a];he[a]=p;\n        to[++p]=a;ne[p]=he[b];he[b]=p;\n    }\n    p=0;dfs(1,0);build(1,1,n);\n    while(m--){\n        in(op);in(x);\n        if(op==1)access(x);\n        else if(op==2){\n            in(y);\n            printf(\"%d\\n\",get(dfn[x])+get(dfn[y])-get(dfn[lca(x,y)])*2+1);\n        }\n        else printf(\"%d\\n\",ask(1,dfn[x],dfn[mr[x]]));\n    }\n    return 0;\n}\n```",
        "postTime": 1520942210,
        "uid": 61325,
        "name": "FlashHu",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "[Caii\u795e\u4ed9\u7684\u9898\u89e3](https://www.luogu.com.cn/blog/Cai/solution-p3703)\u5199\u7684\u5f88\u7cbe\u5f69\uff0c\u4f46\u597d\u50cf\u4e0d\u662f\u5f88\u591a\u4eba\u80fd\u770b\u61c2\u3002\u3002\u3002\n\n\u90a3\u6211\u6765\u53d1\u4e00\u4e2a\u6709\u8f83\u4e3a\u8be6\u7ec6\u7684\u89e3\u91ca\u548c\u4e00\u4e2a\u6b63\u5e38\u7248\u7ebf\u6bb5\u6811\u7684\u4ee3\u7801\n\n```cpp\n/*\ncoder: Feliks a Hacker of IOI == GM-YB an AKer of IMO\nacknowledgement:\nhttps://www.luogu.com.cn/blog/Cai/solution-p3703\n\n\u7eaf\u6811\u5256\u7684\u89e3\u6cd5\uff0c\u601d\u8def\u5927\u6982\u662f\u8fd9\u6837:\n\u79f0\u8fde\u7eed\u4e00\u6bb5\u76f8\u540c\u989c\u8272\u70b9\u7ec4\u6210\u7684\u94fe\u53eb\u540c\u8272\u94fe \n\u5f00\u7ebf\u6bb5\u6811\uff0cmx\u8bb0\u5f55\u8be5\u533a\u57df\u5185\u70b9\u5230\u6839\u8def\u5f84\u4e2d\u6700\u5927\u6743\u503c \uff08\u6700\u5927\u70b9\u6743\uff09 \ncol\u8bb0\u5f55\u8be5\u533a\u57df\u6700\u65b0\u88ab\u8d4b\u8fc7\u7684\u989c\u8272\uff08\u989c\u8272\u7f16\u53f7\u5f00\u59cb\u4e3a1-n\uff0c\u540e\u4ecen+1\u5f00\u59cb\u9012\u589e\uff09 \n\u5219\u4e00\u4e2a\u70b9\u989c\u8272\u5b9e\u9645\u989c\u8272\u4e3a\u542b\u6709\u8be5\u70b9\u533a\u95f4\u4e2dcol\u503c\u6700\u5927\u7684\uff08\u7f16\u53f7\u8d8a\u5927\u989c\u8272\u8d8a\u65b0\uff09 \n\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u6613\u8bc1\u660e\u7b26\u5408\u53ef\u51cf\u6027\uff0c\u6545\u53ef\u4ee5\u7528\u6c42\u4e24\u70b9\u95f4\u8ddd\u79bb\u7684\u65b9\u6cd5\u6c42 \n\uff08ans(u,v)=dis[u]+dis[v]-2*dis[lca(u,v)]+1\uff09 \n\u5bf9\u4e8e\u64cd\u4f5c3\uff0c\u7ebf\u6bb5\u6811\u67e5\u8be2mx\u7684\u6700\u503c\n\u6700\u96be\u7684\u662f\u64cd\u4f5c1\uff1a\n\u4ecex\u5f00\u59cb\u5411\u4e0a\u8df3\uff0c\u6bcf\u6b21\u8df3\u8fc7\u4e00\u6761\u91cd\u94fe\u6216\u540c\u8272\u94fe\uff08\u54ea\u4e2a\u8d77\u70b9\u66f4\u6df1\u5c31\u8df3\u90a3\u4e2a\uff09\n\u8df3\u7684\u65f6\u5019\u533a\u95f4\u4fee\u6539\u989c\u8272\uff0c\u66f4\u65b0\u70b9\u6743 \n\uff08\u5229\u7528\u8df3\u7684\u8fd9\u4e00\u6bb5\u989c\u8272\u76f8\u540c\uff0c\u6ce8\u610f\u4e0d\u8981\u628a\u4e0a\u6b21\u8df3\u7684\u94fe\u4e5f\u66f4\u65b0\u4e86\uff09 \n\u8fd8\u8981\u6ce8\u610f\u66f4\u65b0\u539f\u6765\u7684\u540c\u8272\u94fe\u7684\u6700\u9876\u7aef \n\u590d\u6742\u5ea6 O(nlog^2n) \n*/\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5;\nint n,m;\ninline int read(){\n\tint x=0;char ch=getchar();\n\twhile(!isdigit(ch))ch=getchar();\n\twhile(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn x;\n}int v[N<<1],nex[N<<1],first[N],tot;\ninline void adde(int x,int y){\n\tv[++tot]=y;\n\tnex[tot]=first[x];\n\tfirst[x]=tot;\n}namespace LCA{\n\tqueue<int> q;\n\tint d[N],fa[21][N],T;\n\tinline void bfs(){\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint x=q.front();q.pop();\n\t\t\tfor(int i=first[x];i;i=nex[i]){\n\t\t\t\tint y=v[i];if(d[y])continue;\n\t\t\t\td[y]=d[x]+1;q.push(y);fa[0][y]=x;\n\t\t\t\tfor(int j=1;j<=T;j++)\n\t\t\t\t\tfa[j][y]=fa[j-1][fa[j-1][y]];\n\t\t\t}\n\t\t}\n\t}inline int lca(int x,int y){\n\t\tif(x==y)return x;\n\t\tif(d[x]<d[y])swap(x,y);\n\t\t//d[x] >= d[y]\n\t\tfor(int i=T;i>=0;i--)\n\t\t\tif(d[fa[i][x]]>=d[y])x=fa[i][x];\n\t\tif(x==y)return x;\n\t\tfor(int i=T;i>=0;i--)\n\t\t\tif(fa[i][x]!=fa[i][y])x=fa[i][x],y=fa[i][y];\n\t\treturn fa[0][x];\n\t}inline int spc(int x,int y){//spc(special): \u89c1\u4e0b\u6587 op1 \u51fd\u6570 \n\t\t//d[x]>d[y]\n\t\tfor(int i=T;i>=0;i--)\n\t\t\tif(d[fa[i][x]]>d[y])x=fa[i][x];\n\t\treturn x;\n\t}\n}using namespace LCA;\n//\u91cd\u94fe\u5256\u5206 \nint sz[N],gson[N];\nvoid dfs1(int x,int f){\n    int mx=0;sz[x]=1;\n    for(int i=first[x];i;i=nex[i]){\n        int y=v[i];if(y==f)continue;\n        dfs1(y,x);sz[x]+=sz[y];\n        if(sz[y]>mx){mx=sz[y],gson[x]=y;}\n    }\n}int id[N],w[N],top[N],cnt,num;//num \u8bb0\u5f55\u5f53\u524d\u989c\u8272\u79cd\u6570 \nvoid dfs2(int x,int topf){\n    id[x]=++cnt;top[x]=topf;w[cnt]=x;\n    if(!gson[x])return;\n    dfs2(gson[x],topf);\n    for(int i=first[x];i;i=nex[i]){\n        int y=v[i];\n        if(y==fa[0][x] || y==gson[x])continue;\n        dfs2(y,y);\n    }\n}int cbot[N<<1],ctop[N<<1];//\u540c\u8272\u94fe\u5e95\u7aef\u548c\u9876\u7aef \nnamespace SegmentTree{\n\tint mx[N<<2],col[N<<2],mk[N<<2];\n\t//\u70b9\u6743\u3001\u989c\u8272\u3001\u61d2\u6807\n\tinline int Max(int x,int y){\n\t\tif(x>y)return x;\n\t\treturn y;\n\t}inline void up(int x){\n\t\tmx[x]=Max(mx[x<<1],mx[x<<1|1]);\n\t}void build(int x,int l,int r){\n\t\tif(l==r){\n\t\t\tmx[x]=d[w[l]];\n\t\t\tcol[x]=w[l];\n\t\t\treturn;\n\t\t}int mid=l+r>>1;\n\t\tbuild(x<<1,l,mid);\n\t\tbuild(x<<1|1,mid+1,r);\n\t\tup(x);\n\t}void alter_col(int x,int l,int r,int ll,int rr,int c){//\u4fee\u6539\u989c\u8272 \n\t\tif(ll<=l && r<=rr){col[x]=c;return;}\n\t\tint mid=l+r>>1;\n\t\tif(ll<=mid)alter_col(x<<1,l,mid,ll,rr,c);\n\t\tif(rr>mid)alter_col(x<<1|1,mid+1,r,ll,rr,c);\n\t}int query_col(int x,int l,int r,int p){\n\t//\u5355\u70b9\u67e5\u8be2\u989c\u8272\uff0c\u6ce8\u610f\u53d6\u6240\u6709\u8986\u76d6\u8be5\u70b9\u7684\u533a\u95f4\u4e2d\u989c\u8272\u7684\u6700\u503c\n\t//\u56e0\u4e3a\u5728\u4fee\u6539\u989c\u8272\u65f6\uff0c\u6709\u5fc5\u8981\u53ea\u6539\u5728\u533a\u95f4\u4e0a\u4e0d\u6539\u5230\u6bcf\u4e2a\u70b9\uff08\u9632TLE\uff09 \n\t\tif(l==r)return col[x];\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid)return Max(col[x],query_col(x<<1,l,mid,p));\n\t\telse return Max(col[x],query_col(x<<1|1,mid+1,r,p));\n\t}inline void down(int x,int l,int r){\n\t\tif(!mk[x])return;\n\t\tint mid=l+r>>1,ls=x<<1,rs=x<<1|1,c=mk[x];\n\t\tmk[x]=0;\n\t\tmk[ls]+=c,mk[rs]+=c;\n\t\tmx[ls]+=c,mx[rs]+=c;\n\t}void alter(int x,int l,int r,int ll,int rr,int k){//\u4fee\u6539\u70b9\u6743 \n\t\tif(ll<=l && r<=rr){mx[x]+=k,mk[x]+=k;return;}\n\t\tdown(x,l,r);\n\t\tint mid=l+r>>1;\n\t\tif(ll<=mid)alter(x<<1,l,mid,ll,rr,k);\n\t\tif(rr>mid)alter(x<<1|1,mid+1,r,ll,rr,k);\n\t\tup(x);\n\t}int query(int x,int l,int r,int ll,int rr){//\u67e5\u8be2\u533a\u95f4\u70b9\u6743\u6700\u503c \n\t\tif(ll<=l && r<=rr)return mx[x];\n\t\tdown(x,l,r);\n\t\tint mid=l+r>>1,res=0;\n\t\tif(ll<=mid)res=Max(res,query(x<<1,l,mid,ll,rr));\n\t\tif(rr>mid)res=Max(res,query(x<<1|1,mid+1,r,ll,rr));\n\t\treturn res;\n\t} \n}using namespace SegmentTree;\nnamespace operations{\n\tinline void op1(int x,int k){//\u5927boss!!!\n\t\tcbot[k]=x,ctop[k]=1;\n\t\tint last=0,ct;//\u4e0a\u4e00\u6b21\u66f4\u65b0\u7684\u70b9\uff0c\u9632\u6b62\u4e00\u4e2a\u4f4d\u7f6e\u88ab\u91cd\u590d\u66f4\u65b0 \n\t\twhile(x){\n\t\t\tint p=query(1,1,n,id[x],id[x]);\n\t\t\tint c=query_col(1,1,n,id[x]),r=ctop[c],l=top[x];\n\t\t\t//\u540c\u8272\u94fe\u548c\u91cd\u94fe\uff0c\u8df3\u5230\u66f4\u6df1\u7684\u90a3\u4e2a \n\t\t\tif(d[l]<d[r]){\n\t\t\t\t//\u533a\u95f4\u4fee\u6539\u989c\u8272 \n\t\t\t\talter_col(1,1,n,id[r],id[x],k);\n\t\t\t\t//\u53ef\u63a8\u7b97\u8fd9\u4e00\u6bb5\u5728\u88ab\u8986\u76d6\u540e\u70b9\u6743\u51cf\u5c0f(p-1) \n\t\t\t\talter(1,1,n,id[r],id[r]+sz[r]-1,1-p);\n\t\t\t\t//\u9632\u6b62\u91cd\u590d\u66f4\u65b0 \n\t\t\t\tif(last)alter(1,1,n,id[last],id[last]+sz[last]-1,p-1);\n\t\t\t}else{\n\t\t\t\talter_col(1,1,n,id[l],id[x],k);\n\t\t\t\talter(1,1,n,id[l],id[l]+sz[l]-1,1-p);\n\t\t\t\tif(last)alter(1,1,n,id[last],id[last]+sz[last]-1,p-1);\t\t\t\t\n\t\t\t}//\u4fee\u6539\u88ab\u8986\u76d6\u7684\u539f\u6765\u540c\u8272\u94fe\u7684\u9876\u7aef\uff08\u6ce8\u610f\u7ec6\u8282\uff09 \n\t\t\tif(x!=cbot[c]){\n\t\t\t\tint y=spc(cbot[c],x);\n\t\t\t\t//y \u662f x \u7684\u4e00\u4e2a\u513f\u5b50\u4e14\u5728 x \u539f\u6765\u7684\u540c\u8272\u94fe\u4e0a \n\t\t\t\tif(y!=last){//\u5982\u679c y \u4e5f\u88ab\u8986\u76d6\u4e86\u5c31\u4e0d\u80fd\u7528\u5b83\u6765\u66f4\u65b0\u4e86 \n\t\t\t\t\talter(1,1,n,id[y],id[y]+sz[y]-1,1);//y \u7684\u70b9\u6743\uff1a1 -> 2 \n\t\t\t\t\tct=y;//\u6ce8\u610f\u4e0d\u8981\u6025\u7740\u66f4\u65b0\u94fe\u9876\n\t\t\t\t\t//\u5982\u679c\u8fd8\u6ca1\u628a\u539f\u540c\u8272\u94fe\u8df3\u5b8c\u5c31\u66f4\u65b0\u94fe\u9876\u663e\u7136\u4f1a\u6302\u6389 \n\t\t\t\t}\n\t\t\t}//\u5411\u4e0a\u8df3 \n\t\t\tif(d[r]<d[l])x=fa[0][l],last=l;\n\t\t\telse x=fa[0][r],last=r,ctop[c]=ct;//\u8df3\u5b8c\u539f\u94fe\u518d\u66f4\u65b0\u94fe\u9876 \n\t\t}\n\t}inline int op2(int x,int y){\n\t\tint z=lca(x,y),\n\t\t\tret1=query(1,1,n,id[x],id[x]),\n\t\t\tret2=query(1,1,n,id[y],id[y]),\n\t\t\tret3=query(1,1,n,id[z],id[z]);\n\t\treturn ret1+ret2-(ret3<<1)+1;\n\t\t//\u7c7b\u4f3c\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u516c\u5f0f\uff0c\u5728\u6b64\u53ef\u8bc1\u660e\u9002\u7528 \n\t}inline int op3(int x){\n\t\treturn query(1,1,n,id[x],id[x]+sz[x]-1);\n\t}\n}using namespace operations;\nint main(){\n\tn=read(),m=read();\n\tT=(int)(log(n)/log(2.0))+1;\n\tfor(int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tadde(x,y),adde(y,x);\n\t}d[1]=1;bfs();\n\tdfs1(1,0),dfs2(1,1);\n\t//\u521d\u59cb\u989c\u8272\u4e0e\u540c\u8272\u94fe \n\tfor(int i=1;i<=n;i++)cbot[i]=ctop[i]=i;\n\tbuild(1,1,n);num=n;\n\twhile(m--){\n\t\tint op=read();\n\t\tif(op==1)op1(read(),++num);\n\t\telse if(op==2){\n\t\t\tint x=read(),y=read();\n\t\t\tprintf(\"%d\\n\",op2(x,y));\n\t\t}else printf(\"%d\\n\",op3(read()));\n\t}\n\treturn 0;//\u5b8c\u7ed3\u6563\u82b1 \n}\n```\n\n\n",
        "postTime": 1582120756,
        "uid": 104292,
        "name": "YellowBean_Elsa",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u79cd\u66f4\u4e3a\u7b80\u6d01\u7684\u6811\u5256\u505a\u6cd5\u3002\r\n\r\n\u8003\u8651\u5bf9\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u7ef4\u62a4\u8fd9\u6837\u4e00\u6761\u4fe1\u606f\uff1a\r\n\r\n-   \u8be5\u70b9\u4e0e\u5b83\u7236\u4eb2\u7684\u989c\u8272\u662f\u5426\u76f8\u540c\u3002\r\n\r\n\u82e5\u80fd\u6210\u529f\u6c42\u51fa\u8fd9\u4e2a\u4fe1\u606f\u7684\u53d8\u5316\uff0c\u5219\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7b80\u5355\u5730\u7ef4\u62a4 2\u30013 \u64cd\u4f5c\u7684\u7b54\u6848\u3002\r\n\r\n\u8fd9\u4e2a\u4fe1\u606f\u7684\u53d8\u5316\u6b21\u6570\u662f\u591a\u5c11\u5462\uff1f\u5176\u5b9e\u5bf9\u4e8e\u5355\u6b21 1 \u64cd\u4f5c\uff0c\u53ea\u4f1a\u6709 $O(\\log n)$ \u4e2a\u8282\u70b9\u7684\u4fe1\u606f\u53d1\u751f\u53d8\u5316\u3002\u4e0b\u9762\u662f\u4e00\u4e2a\u7b80\u77ed\u7684\u8bc1\u660e\u3002\r\n\r\n\u5c06\u6240\u6709\u70b9\u5206\u4e3a\u4e24\u7c7b\uff1a\r\n\r\n1.  \u8be5\u70b9\u4e0e\u4ed6\u989c\u8272\u76f8\u540c\u7684\u513f\u5b50\u662f\u5b83\u7684\u91cd\u513f\u5b50\u3002\r\n2.  \u8be5\u70b9\u4e0e\u4ed6\u989c\u8272\u76f8\u540c\u7684\u513f\u5b50\u662f\u67d0\u4e2a\u8f7b\u513f\u5b50\uff0c\u6216\u5e76\u6ca1\u6709\u4e0e\u5b83\u989c\u8272\u76f8\u540c\u7684\u513f\u5b50\u3002\r\n\r\n\u8fd9\u6837\uff0c\u6bcf\u6b21 1 \u64cd\u4f5c\u4f1a\u4f7f\u5f97\u67d0\u4e9b 1 \u7c7b\u70b9\u53d8\u4e3a 2 \u7c7b\u70b9\uff0c\u6216\u4f7f 2 \u7c7b\u70b9\u540c\u8272\u513f\u5b50\u5207\u6362\uff0c\u53c8\u6216\u662f\u5c06 2 \u7c7b\u70b9\u53d8\u4e3a 1 \u7c7b\u70b9\u3002\u524d\u4e24\u4e2a\u60c5\u51b5\u7684\u603b\u548c\u662f $O(\\log n)$ \u7684\uff0c\u56e0\u4e3a\u53ea\u6709\u8df3\u8f7b\u8fb9\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u6709\u524d\u4e24\u4e2a\u60c5\u51b5\u53d1\u751f\u3002\u4ece\u800c\uff0c\u7b2c\u4e09\u4e2a\u60c5\u51b5\u5747\u644a\u4e0b\u6765\u4e5f\u662f $O(\\log n )$ \u7684\u3002\u56e0\u6b64\uff0c\u6211\u4eec\u8bf4\u660e\u4e86\u4e0a\u4fe1\u606f\u7684\u53d8\u5316\u6b21\u6570\u662f $O(\\log n)$ \u7684\u3002\u4ece\u800c\uff0c\u53ea\u9700\u8981\u6bcf\u6b21\u6c42\u51fa\u4fe1\u606f\u7684\u53d8\u5316\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd9\u9053\u9898\u4e86\u3002\r\n\r\n\u8003\u8651\u5982\u4f55\u7ef4\u62a4\uff0c\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u91cd\u94fe\u5f00\u4e24\u4e2a set\uff1a\r\n\r\n1.  \u50a8\u5b58\u4e86\u82e5\u5e72\u7ec4\u5bf9 $(x,y)$\uff0c\u8868\u793a\u6df1\u5ea6\u4e3a $x$ \u7684\u70b9 $k$ \u8f7b\u513f\u5b50 $y$ \u4e0e\u4ed6\u989c\u8272\u76f8\u540c\u3002\r\n2.  \u50a8\u5b58\u4e86\u82e5\u5e72\u4e2a $x$\uff0c\u8868\u793a\u6df1\u5ea6\u4e3a $x$ \u7684\u70b9 $k$ \u662f\u5b83\u7236\u4eb2\u7684\u91cd\u513f\u5b50\uff0c\u4e14 $k$ \u4e0e\u5176\u989c\u8272\u4e0d\u540c\u3002\r\n\r\n\u5177\u4f53\u7684\u5b9e\u73b0\u5efa\u8bae\u81ea\u5df1\u601d\u8003\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u53c2\u8003\u4ee3\u7801\u3002\r\n\r\n```cpp\r\n#include<bits/stdc++.h>\r\nconst int N=200050;\r\nusing namespace std;\r\n\r\nint n,m;\r\n\r\n#define _to e[i].to\r\n#define fore(k) for(int i=hd[k];i;i=e[i].nx)\r\nstruct edge{\r\n    int to,nx;\r\n}e[N];int hd[N],S;\r\nvoid add(int fr,int to){\r\n    e[++S]=(edge){to,hd[fr]},hd[fr]=S;\r\n}\r\n\r\nint fa[N],dp[N],sg[N],bc[N],sz[N],sn[N],tp[N],cnt;\r\nvoid dfs(int k,int f){\r\n    fa[k]=f,dp[k]=dp[f]+1,sz[k]=1;\r\n    fore(k)if(_to!=f)\r\n        dfs(_to,k),sz[k]+=sz[_to],sn[k]=sz[sn[k]]<sz[_to]?_to:sn[k];\r\n}\r\nbasic_string<int> a[N];\r\nmultiset<int> s1[N];\r\nmultiset<pair<int,int>> s[N];\r\nvoid df5(int k,int t){\r\n    tp[k]=t,sg[k]=++cnt,bc[cnt]=k;a[t]+=k;\r\n    if(sn[k])df5(sn[k],t),s1[t].insert(dp[k]-dp[t]+1);\r\n    fore(k)if(_to!=fa[k]&&_to!=sn[k])df5(_to,_to);\r\n}\r\n\r\nstruct sgt{\r\n\t#define ls k<<1\r\n\t#define rs k<<1|1\r\n\t#define mid ((l+r)>>1)\r\n\tint ad[N<<2],mx[N<<2];\r\n\tvoid pshad(int k,int p){\r\n\t\tad[k]+=p,mx[k]+=p;\r\n\t}\r\n\tvoid pshdn(int k){\r\n\t\tpshad(ls,ad[k]),pshad(rs,ad[k]);\r\n\t\tad[k]=0;\r\n\t}\r\n\tvoid pshup(int k){mx[k]=max(mx[ls],mx[rs]);}\r\n\tvoid build(int k,int l,int r){\r\n\t\tif(l^r)build(ls,l,mid),build(rs,mid+1,r),pshup(k);\r\n\t\telse pshad(k,dp[bc[l]]-1);\r\n\t}\r\n\tvoid add(int k,int l,int r,int x,int y,int p){\r\n\t\tif(r<x||l>y)return ;\r\n\t\tif(l>=x&&r<=y)return pshad(k,p);\r\n\t\tpshdn(k);\r\n\t\tadd(ls,l,mid,x,y,p),add(rs,mid+1,r,x,y,p);\r\n\t\tpshup(k);\r\n\t}\r\n\tint qmx(int k,int l,int r,int x,int y){\r\n\t\tif(r<x||l>y)return 0;\r\n\t\tif(l>=x&&r<=y)return mx[k];\r\n\t\tpshdn(k);\r\n\t\treturn max(qmx(ls,l,mid,x,y),qmx(rs,mid+1,r,x,y));\r\n\t} \r\n\tint qsm(int k,int l,int r,int x){\r\n\t\tif(l^r){\r\n\t\t\tpshdn(k);\r\n\t\t\tif(x<=mid)return qsm(ls,l,mid,x);\r\n\t\t\telse return qsm(rs,mid+1,r,x);\r\n\t\t}else return ad[k];\r\n\t}\r\n}T;\r\n\r\nint lca(int x,int y){\r\n\twhile(tp[x]!=tp[y]){\r\n\t\tif(dp[tp[x]]<dp[tp[y]])swap(x,y);\r\n\t\tx=fa[tp[x]];\r\n\t}\r\n\treturn dp[x]<dp[y]?x:y;\r\n}\r\n\r\nint getv(int k){\r\n\treturn T.qsm(1,1,n,sg[k]);\r\n}\r\n\r\n//for most of node\r\n// - his heavy son equal to him\r\n// - other sons not equal to him\r\n//s a unheavy son equal to him\r\n//s1 a heavy son not equal to him\r\n\r\nvoid clear(int x){\r\n\tint pr=0;\r\n\twhile(x){\r\n\t\tint t=tp[x],dl=dp[x]-dp[t],nw;\r\n\t\twhile(s[t].size()&&s[t].begin()->first<=dl){\r\n\t\t\tnw=s[t].begin()->second;\r\n\t\t\tT.add(1,1,n,sg[nw],sg[nw]+sz[nw]-1,1);\r\n\t\t\ts[t].erase(s[t].begin()); \r\n\t\t}\r\n\t\twhile(s1[t].size()&&*s1[t].begin()<=dl){\r\n\t\t\tnw=a[t][*s1[t].begin()];\r\n\t\t\tT.add(1,1,n,sg[nw],sg[nw]+sz[nw]-1,-1);\r\n\t\t\ts1[t].erase(s1[t].begin());\r\n\t\t}\r\n\t\tif(pr){\r\n\t\t\tT.add(1,1,n,sg[pr],sg[pr]+sz[pr]-1,-1);\r\n\t\t\ts[t].insert({dl,pr});\r\n\t\t\t// \u8f7b\u513f\u5b50 pr \u4e0e x \u989c\u8272\u76f8\u540c \r\n\t\t}\r\n\t\tif(sn[x]&&s1[t].find(dl+1)==s1[t].end()){\r\n\t\t\tT.add(1,1,n,sg[sn[x]],sg[sn[x]]+sz[sn[x]]-1,1);\r\n\t\t\ts1[t].insert(dl+1);\r\n\t\t\t//\u91cd\u513f\u5b50 sn[x] \u4e0e x \u989c\u8272\u4e0d\u540c \r\n\t\t}\r\n\t\tpr=t;\r\n\t\tx=fa[t];\r\n\t}\r\n} \r\n\r\nint getmx(int x){\r\n\treturn T.qmx(1,1,n,sg[x],sg[x]+sz[x]-1)+1;\r\n}\r\n\r\nvoid solve(){\r\n\tcin>>n>>m;\r\n\tfor(int i=1;i<n;i++){\r\n\t\tint x,y;cin>>x>>y;\r\n\t\tadd(x,y),add(y,x);\r\n\t}\r\n\tdfs(1,0);\r\n\tdf5(1,1);\r\n\tT.build(1,1,n);\r\n\tfor(int i=1;i<=m;i++){\r\n\t\tint x,y,z;cin>>x>>y;\r\n\t\tif(x==1)clear(y);\r\n\t\tif(x==2){\r\n\t\t\tcin>>z;\r\n\t\t\tcout<<getv(y)+getv(z)-getv(lca(y,z))*2+1<<'\\n';\r\n\t\t}\r\n\t\tif(x==3)cout<<getmx(y)<<'\\n';\r\n\t}\r\n}\r\n\r\nmain(){\r\n\tios::sync_with_stdio(false);\r\n\tsolve();\r\n}\r\n\r\n```\r\n\r\n",
        "postTime": 1650613513,
        "uid": 79067,
        "name": "dottle",
        "ccfLevel": 10,
        "title": "3703"
    },
    {
        "content": "LCT + \u6811\u5256 + \u7ebf\u6bb5\u6811\u3002       \n\u7531\u4e8e\u6bcf\u4e2a\u64cd\u4f5c\u90fd\u662f\u4ece\u4e00\u4e2a\u70b9\u67d3\u5230\u6839\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f88\u6e05\u695a\u7684\u77e5\u9053\uff1a\u989c\u8272\u79cd\u6570 = \u989c\u8272\u6bb5\u6570\u3002   \n\u63a5\u7740\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u4e24\u4e2a\u70b9$x,y$\u7684\u989c\u8272\u79cd\u6570\u5176\u5b9e\u5c31\u662f$x$\u5230\u6839\u7684\u989c\u8272\u79cd\u6570 + $y$\u5230\u6839\u7684\u989c\u8272\u79cd\u6570 - $2lca(x,y)$\u5230\u6839\u7684\u989c\u8272\u79cd\u6570 + 1\u3002                   \n\u5c06\u4e00\u4e2a\u70b9\u67d3\u8272\u65f6\uff0c\u540c\u65f6\u4f1a\u4e0d\u53ef\u907f\u514d\u7684\u65ad\u6389\u4e00\u4e9b\u989c\u8272\u6bb5\uff0c\u4f7f\u65ad\u6389\u7684\u90e8\u5206\u5b50\u6811\u7684\u7b54\u6848\u4f1a\u52a01\u3002  \n\u6211\u4eec\u7528$\\text{LCT}$\u6765\u7ef4\u62a4\u8fd9\u4e9b\u94fe\u3002    \n\u901a\u8fc7\u628a\u56fe\u753b\u51fa\u6765\u53ef\u4ee5\u77e5\u9053\uff1a   \n\u589e\u52a01\u7684\u5b50\u6811\u5176\u5b9e\u662faccess\u65f6\u539f\u6765\u7684\u53f3\u513f\u5b50\uff0c  \n\u800c\u51cf\u5c111\u5176\u5b9e\u662faccess\u65f6\u50cf\u73b0\u5728\u7684\u53f3\u513f\u5b50\u3002      \n\u4e4b\u540e\u5c31\u53ef\u4ee5\u505a\u4e86\u3002     \n```cpp\n#include <bits/stdc++.h>\n\n#define _swap(a,b) (a ^= b ^= a ^= b)\nconst int maxn = 1e5 + 10;\n\nclass FastIO {\n    private:\n        #define tn(x) (x << 1) + (x << 3)\n        #define D isdigit(c = getchar())\n        char c;  int T, S[10000];\n    public:\n        template<class Tp> inline void read(Tp& x) { x = 0;  while(!D);  while(x = tn(x) + (c & 15),D); }\n        template<class Tp> inline void write(Tp x) { while(S[++T] = x % 10 + 48,x /= 10);  while(T) putchar(S[T--]); }\n        template<class Tp,class... Ar> inline void read(Tp& x,Ar&... y) { read(x);  read(y...); }\n        template<class Tp> inline void writeln(const Tp& x) { write(x);  putchar('\\n'); }\n} I;\n\ninline void cmax(int& x,int y) { if(x < y) x = y; }\ninline int _max(int x,int y) { return x > y ? x : y; }\n\nint n, m, i, j, k, cnte, tot;\nint fa[maxn], id[maxn], dep[maxn], sz[maxn], dfn[maxn], top[maxn], hson[maxn];\n\nstruct edge {\n    int v;\n    edge* nxt;\n} pool[maxn << 1], *head[maxn], *cur = pool;\ninline void adde(int u,int v) {\n    edge* p = cur++;\n    p -> v = v;  p -> nxt = head[u];\n    head[u] = p;\n}\n\nvoid dfs1(int u,int pa) {\n    dep[u] = dep[pa] + 1;  fa[u] = pa;  sz[u] = 1;\n    for(edge* p = head[u];p;p = p -> nxt) {\n        int v = p -> v;\n        if(v == pa)\n            continue;\n        dfs1(v,u);\n        sz[u] += sz[v];\n        if(sz[v] > sz[ hson[u] ])\n            hson[u] = v;\n    }\n}\nvoid dfs2(int u,int up) {\n    top[u] = up;  dfn[u] = ++tot;  id[tot] = u;\n    if(hson[u])\n        dfs2(hson[u],up);\n    for(edge* p = head[u];p;p = p -> nxt) {\n        int v = p -> v;\n        if(v == fa[u] || v == hson[u])\n            continue;\n        dfs2(v,v);\n    }\n}\ninline int Glca(int u,int v) {\n    while(top[u] != top[v]) {\n        if(dep[ top[u] ] < dep[ top[v] ])\n            _swap(u,v);\n        u = fa[ top[u] ];\n    }\n    return dep[u] < dep[v] ? u : v;\n}\n\nclass Segment_Tree {\n    private:\n        int mx[maxn << 2], tag[maxn << 2];\n    public:\n        inline void push_up(int u) {\n            mx[u] = _max(mx[u << 1],mx[u << 1 | 1]);\n        }\n        inline void push_down(int u) {\n            if(!tag[u])\n                return;\n            mx[u << 1] += tag[u];  mx[u << 1 | 1] += tag[u];\n            tag[u << 1] += tag[u];  tag[u << 1 | 1] += tag[u];\n            tag[u] = 0;\n        }\n        void build(int l,int r,int u) {\n            if(l == r)\n                return mx[u] = dep[ id[l] ], void();\n            int mid = (l + r) >> 1;\n            build(l,mid,u << 1);\n            build(mid + 1,r,u << 1 | 1);\n            push_up(u);\n        }\n        int query(int ql,int qr,int l,int r,int u) {\n            //printf(\"%d %d %d %d %d %d\\n\",ql,qr,l,r,u,mx[u]);\n            if(ql <= l && r <= qr)\n                return mx[u];\n            push_down(u);\n            int res = 0, mid = (l + r) >> 1;\n            if(ql <= mid)\n                cmax(res,query(ql,qr,l,mid,u << 1));\n            if(mid < qr)\n                cmax(res,query(ql,qr,mid + 1,r,u << 1 | 1));\n            return res;\n        }\n        void modify(int ml,int mr,int l,int r,int u,int x) {\n            if(ml <= l && r <= mr)\n                return tag[u] += x, mx[u] += x, void();\n            push_down(u);\n            int mid = (l + r) >> 1;\n            if(ml <= mid)\n                modify(ml,mr,l,mid,u << 1,x);\n            if(mid < mr)\n                modify(ml,mr,mid + 1,r,u << 1 | 1,x);\n            push_up(u);\n            return;\n        }\n} segt;\n\nclass Link_Cut_Tree {\n    private:\n        int ch[maxn][2];\n    public:\n        int fa[maxn];\n        inline bool nroot(int u) {\n            return ch[ fa[u] ][0] == u || ch[ fa[u] ][1] == u;\n        }\n        inline int ident(int u) {\n            return ch[ fa[u] ][1] == u;\n        }\n        inline void rotate(int u) {\n            int oldf = fa[u], oldgf = fa[oldf], whi = ident(u);\n            if(nroot(oldf))\n                ch[oldgf][ident(oldf)] = u;\n            ch[oldf][whi] = ch[u][whi ^ 1];\n            fa[ ch[oldf][whi] ] = oldf;\n            ch[u][whi ^ 1] = oldf;\n            fa[oldf] = u;  fa[u] = oldgf;\n        }\n        inline void splay(int u) {\n            for(int p = fa[u];nroot(u);rotate(u),p = fa[u]) {\n                if(nroot(p))\n                    rotate(ident(p) == ident(u) ? p : u);\n            }\n        }\n        inline int find_root(int x) {\n            while(ch[x][0])\n                x = ch[x][0];\n            return x;\n        }\n        inline void access(int x) {\n            for(int y = 0, z;x;x = fa[y = x]) {\n                splay(x);\n                if(ch[x][1])\n                    z = find_root(ch[x][1]), segt.modify(dfn[z],dfn[z] + sz[z] - 1,1,n,1,1);\n                if(ch[x][1] = y)\n                    z = find_root(ch[x][1]), segt.modify(dfn[z],dfn[z] + sz[z] - 1,1,n,1,-1);\n            }\n        }\n} lct;\n\nint main() {\n    I.read(n,m);\n    for(int i = 1, u, v;i < n;i++) {\n        I.read(u,v);\n        adde(u,v);\n        adde(v,u);\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    for(int i = 1;i <= n;i++)\n        lct.fa[i] = fa[i];\n    segt.build(1,n,1);\n    for(int op, x, y;m;m--) {\n        I.read(op,x);\n        if(op == 1)\n            lct.access(x);\n        else if(op == 2) {\n            I.read(y);\n            int z = Glca(x,y);\n            printf(\"%d\\n\",segt.query(dfn[x],dfn[x],1,n,1) + segt.query(dfn[y],dfn[y],1,n,1) - 2 * segt.query(dfn[z],dfn[z],1,n,1) + 1);\n        } else\n            printf(\"%d\\n\",segt.query(dfn[x],dfn[x] + sz[x] - 1,1,n,1));\n    }\n    return 0;\n}\n```",
        "postTime": 1561537025,
        "uid": 114320,
        "name": "\u843d\u6c50",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c$QwQ$](https://ctz45562.github.io/2019/02/27/%E9%A2%98%E8%A7%A3-%E6%B4%9B%E8%B0%B7-P3703-%E3%80%90-SDOI2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2%E3%80%91/)\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problemnew/show/P3703)\n\n$LCT$\u7ef4\u62a4\u6811\u4e0a\u8054\u901a\u5757\u3002\n\n\u9996\u5148\u770b$1$\u64cd\u4f5c\uff0c\u8d77\u70b9\u4e3a\u6839\u7684\u94fe\u67d3\u8272\uff0c\u800c\u4e14\u662f~~chuan~~\u5168\u65b0\u7684\u989c\u8272\u3002\u53ef\u4ee5\u81ea\u5df1\u753b\u4e2a\u56fe\u770b\u770b\u3002\n\n\n\u662f\u4e0d\u662f\u6709\u79cd$LCT$\u91cc\u7684$access$\u7684\u611f\u89c9\uff1f\u90a3\u5c31\u53ef\u4ee5\u8003\u8651\u7528$LCT$\u7ef4\u62a4\u6811\u7684\u5f62\u6001\uff0c\u628a\u76f8\u540c\u989c\u8272\u7684\u70b9\u653e\u5728\u540c\u4e00\u68f5$splay$\u91cc\u3002\u56e0\u4e3a\u4e00\u5b9a\u662f\u4ece\u6839\u5f00\u59cb\u7684\u67d3\u8272\uff0c\u67d3\u7684\u662f\u4e0d\u540c\u7684\u989c\u8272\uff0c\u521d\u59cb\u989c\u8272\u53c8\u4e0d\u540c\uff0c\u5c31\u80fd\u4fdd\u8bc1\u4e00\u68f5$splay$\u4e00\u5b9a\u7ef4\u62a4\u4e00\u6761\u94fe\uff0c\u7b26\u5408$LCT$\u7684\u6027\u8d28\uff0c\u662f\u53ef\u884c\u7684\u3002\uff08\u4e8b\u5b9e\u4e0a\u8fd9\u4e5f\u662f$LCT$\u7ef4\u62a4\u6811\u4e0a\u8054\u901a\u5757\u7684\u5e38\u89c1\u59ff\u52bf\uff09\n\n\u4e8e\u662f\u5bf9\u4e8e\u64cd\u4f5c$1$\uff0c\u5c31\u662f$access$\u4e00\u4e0b\u3002\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u7684\u6743\u503c\u4e5f\u5c31\u662f\u4ece\u8be5\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4f1a\u7ecf\u8fc7\u51e0\u4e2a$splay$\u3002\u56e0\u4e3a\u5728$access$\u65f6\uff0c\u6bcf\u5411\u4e0a\u8df3\u4e00\u6b21\u865a\u8fb9\u5c31\u76f8\u5f53\u4e8e\u8de8\u8fc7\u4e86\u4e00\u4e2a$splay$\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u8fd9\u4e2a\u6027\u8d28\u6765\u7edf\u8ba1\u3002\n\n\u4f2a\u4ee3\u7801\uff1a\n\n```cpp\n\tint fake_access(int x){\n        int ans=0;\n\t\tfor(;x;x=fa[x],++ans)\n\t\t\tsplay(x);\n        //\u7edf\u8ba1\u7b54\u6848\u4e0d\u80fd\u771f\u7684access\u6539\u53d8\u6811\u7684\u5f62\u6001\uff0c\u6240\u4ee5\u4e0d\u8fde\u513f\u5b50\n        //\u8fd9\u4e5f\u662f\u4e3a\u5565\u53ebfAKe_access\u2014\u2014\u5b83\u6ca1\u6709\u771f\u7684access\n\t\treturn ans;\n\t}\n\n```\n\n\u4e8e\u662f\u64cd\u4f5c$2$\u5c31\u662f$fake\\_access(x)+fake\\_access(y)-2*fake\\_access(lca(x,y))+1$\n\n\uff08\u4e00\u5b9a\u8981$+1$\uff0c\u56e0\u4e3a\u51cf\u53bb\u4e86$2*fake\\_access(lca(x,y))$\u540e\uff0c$lca(x,y)$\u81ea\u5df1\u7684$splay$\u5c31\u88ab\u51cf\u6ca1\u4e86\uff09\n\n\u9ebb\u70e6\u7684\u662f\u64cd\u4f5c$3$\u3002\n\n\u6839\u636e\u4e0a\u9762\uff0c\u4e00\u4e2a\u70b9\u7684\u6743\u503c\uff0c\u4e5f\u5c31\u76f8\u5f53\u4e8e\u4e00\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a**\u6709\u51e0\u6761\u865a\u8fb9**\u3002\n\n\u90a3\u4e48\u6709\u4e00\u6761\u865a\u8fb9\u53d8\u91cd\u4e86\uff0c\u5b83\u5bf9\u5e94\u7684\u5b50\u6811\u6743\u503c\u5c31\u4f1a\u90fd$-1$\uff1b\u6709\u4e00\u6761\u5b9e\u8fb9\u53d8\u8f7b\u4e86\uff0c\u5b83\u5bf9\u5e94\u7684\u5b50\u6811\u6743\u503c\u90fd\u4f1a$+1$\u3002\n\n\u521d\u59cb\u6743\u503c\u597d\u6c42\uff0c\u5c31\u662f\u70b9\u7684\u6df1\u5ea6\u3002\u5b50\u6811\u52a0\u52a0\u51cf\u51cf\uff0c\u8fd8\u8981\u6c42\u5b50\u6811\u6743\u503c$max$\uff0c\u53ef\u4ee5\u7528$dfs$\u5e8f+\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u3002\n\n\u80fd\u6539\u53d8\u865a\u5b9e\u8fb9\u7684\u5c31\u662f$access$\u64cd\u4f5c\u4e86\u3002\u8fd9\u91cc\u8fd8\u8981\u5728$LCT$\u4e2d\u8981\u7ef4\u62a4\u4e00\u4e0b\u6bcf\u4e2a$splay$\u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff08\u8bb0\u4e3a$ma[x]$\uff0c\u539f\u56e0\u770b\u4e0b\u9762\u4f2a\u4ee3\u7801\u89e3\u91ca\uff09\u3002\n\n\u4f2a\u4ee3\u7801\uff1a\n\n```cpp\n//seg\u4e3adfs\u5e8f\uff0csiz\u4e3a\u5b50\u6811\u5927\u5c0f\nvoid access(int x){\n\tfor(int y=0;x;y=x,x=fa[x]){\n\t\tsplay(x);\t\t\n        if(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1);\n\t\t//son(x,1)\u53d8\u8f7b\uff0c\u5b50\u6811+1\n\t\t//\u53d8\u8f7b\u7684\u4e00\u5b9a\u662f\u8fd9\u68f5splay\u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff08\u6bd5\u7adf\u662f\u4e00\u6761\u94fe\uff09\uff0c\u4f46\u662f\u672c\u8eab\u5728splay\u4e2d\u53ef\u80fd\u4f1a\u51fa\u73b0\u5b83\u7684\u6839\u4e0d\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff0c\u6240\u4ee5\u8981\u7ef4\u62a4\u4e00\u4e0b\n        if(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1);\n        //y\u53d8\u91cd\uff0c\u5b50\u6811-1\n        //\u540c\u7406\uff0c\u53d8\u91cd\u7684\u4e5f\u662f\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\n\t\tson(x,1)=y;\n\t\tupdate(x);\n\t}\n}\n\n```\n\n\n\n\u8fd9\u6837\u5c31\u5b9e\u73b0\u4e86\u7528$LCT$\u7ef4\u62a4\u5f62\u6001\uff0c\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u4fe1\u606f\u3002\u5176\u5b9e\u8fd9\u6837\u64cd\u4f5c$2$\u4e5f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u67e5\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(nlog^2n)$\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <set>\n\n#define maxn 100005\n#define inf 0x3f3f3f\n#define pn putchar('\\n')\n#define px(x) putchar(x)\n#define ps putchar(' ')\n#define pd puts(\"======================\")\n#define pj puts(\"++++++++++++++++++++++\")\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ntemplate<typename T>\ninline T read(){\n\tT x=0;\n\tint y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\ninline int ran(){\n\tstatic int seed=45562;\n\treturn seed=(seed*48271LL%2147483647);\n}\nint h[maxn],num;\nstruct edge{\n\tint to,pre;\n}e[maxn<<1];\ninline void add(int from,int to){\n\te[++num].pre=h[from],h[from]=num,e[num].to=to;\n}\nint pos[maxn],seg[maxn],top[maxn],deep[maxn],fa[maxn],son[maxn],siz[maxn],cnt;\nstruct Segment_Tree{\n\tint ma[maxn<<2],tag[maxn<<2];\n#define ls(x) (x<<1)\n#define rs(x) (x<<1|1)\n\tinline void update(int node){\n\t\tma[node]=max(ma[ls(node)],ma[rs(node)]);\t\n\t}\n\tinline void datadown(int node,int d){\n\t\tma[node]+=d;\n\t\ttag[node]+=d;\n\t}\n\tinline void pushdown(int node){\n\t\tdatadown(ls(node),tag[node]);\n\t\tdatadown(rs(node),tag[node]);\n\t\ttag[node]=0;\n\t}\n\tvoid build(int l,int r,int node){\n\t\tif(l==r){\n\t\t\tma[node]=deep[pos[l]]+1;\n            //\u56e0\u4e3a\u6df1\u5ea6\u662f\u4ece0\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u8981+1\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(l,mid,ls(node));\n\t\tbuild(mid+1,r,rs(node));\n\t\tupdate(node);\n\t}\n\tvoid add(int L,int R,int l,int r,int node,int d){\n\t\tif(L<=l&&R>=r){\n\t\t\tdatadown(node,d);\n\t\t\treturn;\n\t\t}\n\t\tif(tag[node])pushdown(node);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid)add(L,R,l,mid,ls(node),d);\n\t\tif(R>mid)add(L,R,mid+1,r,rs(node),d);\n\t\tupdate(node);\n\t}\n\tint ask(int L,int R,int l,int r,int node){\n\t\tif(L<=l&&R>=r)return ma[node];\n\t\tif(tag[node])pushdown(node);\n\t\tint mid=l+r>>1,ans=0;\n\t\tif(L<=mid)ans=ask(L,R,l,mid,ls(node));\n\t\tif(R>mid)ans=max(ans,ask(L,R,mid+1,r,rs(node)));\n\t\treturn ans;\n\t}\n}st;//\u7ebf\u6bb5\u6811\nstruct Link_Cut_Tree{\n\tint son[maxn][2],fa[maxn],ma[maxn];\n#define son(x,y) son[x][y]\n#define whson(x) (son[fa[x]][1]==x)\n#define root(x) (son[fa[x]][0]!=x&&son[fa[x]][1]!=x)\n\tinline void update(int node){\n\t\tif(son(node,0))ma[node]=ma[son(node,0)];\n\t\telse ma[node]=node;\n\t}\n\tinline void addedge(int s,int f,int wh){\n\t\tson(f,wh)=s;\n\t\tif(s)fa[s]=f;\n\t}\n\tinline void zhuan(int x){\n\t\tint f=fa[x],gf=fa[f],wh=whson(x);\n\t\tfa[x]=gf;\n\t\tif(!root(f))son(gf,whson(f))=x;\n\t\taddedge(son(x,wh^1),f,wh);\n\t\taddedge(f,x,wh^1);\n\t\tupdate(f),update(x);\n\t}\n\tvoid splay(int x){\n\t\tint y=fa[x];\n\t\twhile(!root(x)){\n\t\t\tif(!root(y))\n\t\t\t\tzhuan(whson(x)^whson(y)?x:y);\n\t\t\tzhuan(x);\n\t\t\ty=fa[x];\n\t\t}\n\t}\n\tvoid access(int x){\n\t\tfor(int y=0;x;y=x,x=fa[x]){\n\t\t\tsplay(x);\n\t\t\tif(son(x,1))st.add(seg[ma[son(x,1)]],seg[ma[son(x,1)]]+siz[ma[son(x,1)]]-1,1,cnt,1,1);\n\t\t\tif(y)st.add(seg[ma[y]],seg[ma[y]]+siz[ma[y]]-1,1,cnt,1,-1);\n\t\t\tson(x,1)=y;\n\t\t\tupdate(x);\n\t\t}\n\t}\n\tint fake_access(int x){\n\t\tint ans=0;\n\t\tfor(;x;x=fa[x],++ans)\n\t\t\tsplay(x);\n\t\treturn ans;\n\t}\n}lct;//lct\nstruct Tree_Chain_Split{\n\tvoid dfs1(int node=1){\n\t\tsiz[node]=1;\n\t\tlct.ma[node]=node;\n\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\tint x=e[i].to;\n\t\t\tif(!siz[x]){\n\t\t\t\tlct.fa[x]=fa[x]=node;\n\t\t\t\tdeep[x]=deep[node]+1;\n\t\t\t\tdfs1(x);\n\t\t\t\tif(siz[x]>siz[son[node]])son[node]=x;\n\t\t\t\tsiz[node]+=siz[x];\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs2(int node=1){\n\t\tseg[node]=++cnt;\n\t\tpos[cnt]=node;\n\t\tif(son[node]){\n\t\t\ttop[son[node]]=top[node];\n\t\t\tdfs2(son[node]);\n\t\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\t\tint x=e[i].to;\n\t\t\t\tif(!seg[x])top[x]=x,dfs2(x);\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int x,int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(deep[top[x]]<deep[top[y]])swap(x,y);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn deep[x]<deep[y]?x:y;\n\t}//\u7528\u7684\u6811\u5256\u6c42lca\n}tcs;\nint main(){\n\tint n=read(),m=read();\n\tfor(register int i=1;i<n;++i){\n\t\tint a=read(),b=read();\n\t\tadd(a,b),add(b,a);\n\t}\n\ttcs.dfs1(),tcs.dfs2();\n\tst.build(1,cnt,1);\n\twhile(m--){\n\t\tint s=read(),x=read();\n\t\tif(s==1)lct.access(x);\n\t\telse if(s==2){\n\t\t\tint y=read();\n\t\t\tprintf(\"%d\\n\",lct.fake_access(x)+lct.fake_access(y)-(lct.fake_access(tcs.lca(x,y))<<1)+1);\n\t\t}\n\t\telse printf(\"%d\\n\",st.ask(seg[x],seg[x]+siz[x]-1,1,cnt,1));\n\t}\n}\n\n```\n\n",
        "postTime": 1551276002,
        "uid": 111762,
        "name": "_ctz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "# \u5e7f\u544a\n\n[\u849f\u84bb\u306eblog](https://www.cnblogs.com/dedicatus545/p/9406690.html)\n\n# \u601d\u8def\n\n### $LCT$\n\n\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u4e2a1\u64cd\u4f5c\uff0c\u597d\u50cf\u975e\u5e38\u50cf$LCT$\u91cc\u9762\u7684$Access$\u554a~\n\n\u90a3\u4e48\u6211\u4eec\u5c1d\u8bd5\u628a$Access$\u64cd\u4f5c\u9b54\u6539\u6210\u672c\u9898\u4e2d\u7684\u6d82\u8272\n\n\u6211\u4eec\u4ee4$LCT$\u4e2d\u7684\u6bcf\u4e00\u4e2a$splay$\u94fe\u4ee3\u8868\u540c\u4e00\u79cd\u989c\u8272\u7684\u4e00\u6761\u94fe\uff0c\u90a3\u4e48$Access(u)$\u5c31\u76f8\u5f53\u4e8e\u628a\u8fd9\u4e00\u6bb5\u53d8\u6210\u540c\u4e00\u79cd\u989c\u8272\n\n\u6ce8\u610f\u8fd9\u4e2a\u4e1c\u897f\u80fd\u6210\u7acb\uff0c\u662f\u56e0\u4e3a**\u6bcf\u6b21\u6d82\u4e0a\u7684\u90fd\u662f\u65b0\u7684\u4e00\u79cd\u989c\u8272**\uff08\u6240\u4ee5\u5982\u679c\u6709$m$\u79cd\u989c\u8272\uff0c\u6bcf\u6b21\u6d82\u5176\u4e2d\u4e00\u79cd\uff0c\u53ef\u80fd\u91cd\u590d\u7684\u4e4b\u7c7b\u7684\u5c31\u4e0d\u80fd\u8fd9\u4e48\u505a\u4e86\uff09\n\n### \u7ebf\u6bb5\u6811\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u89e3\u51b3\u8be2\u95ee\u7684\u95ee\u9898\uff1a\u4ec0\u4e48\u7ed3\u6784\u80fd\u7ef4\u62a4\u94fe\u4e0a\u4fe1\u606f\u548c\u5b50\u6811\u4fe1\u606f\uff08\u540c\u65f6\uff09\uff1f\u5f53\u7136\u662f\u7ebf\u6bb5\u6811\u4e86~\n\n\u6211\u4eec\u8003\u8651\u5f00\u4e00\u68f5\u4ee5$dfs$\u5e8f\u4e3a\u4e0b\u6807\u7684\u7ebf\u6bb5\u6811\uff0c\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u53f6\u8282\u70b9\u4fdd\u5b58\u8fd9\u4e2a\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u6743\u503c\uff0c\u5176\u4ed6\u8282\u70b9\u7ef4\u62a4\u5bf9\u5e94\u533a\u95f4\u7684\u6700\u5927\u503c\n\n\u8fd9\u6837\uff0c\u8be2\u95ee\u4e09\u5c31\u53d8\u6210\u4e86\u533a\u95f4\u6c42$max$\uff0c\u8be2\u95ee\u4e8c\u5219\u53ef\u4ee5\u5316\u6210$w[u]+w[v]-2*w[lca]+1$\u8fd9\u6837\u7684\u5f62\u5f0f\uff08$w[u]$\u8868\u793a$u$\u5230\u6839\u8def\u5f84\u4e0a\u7684\u6743\u503c\uff09\uff08\u8fd9\u4e2a\u4e1c\u897f\u4e0d\u7ba1\u989c\u8272\u600e\u4e48\u5206\u5e03\uff0c\u4e00\u5b9a\u662f\u5bf9\u7684\uff0c\u8bc1\u660e\u5f88\u5bb9\u6613\uff0c\u53ef\u4ee5\u81ea\u5df1\u60f3\u60f3\uff09\n\n\u4f46\u662f\u8fd9\u6837\u4e4b\u540e\uff0c\u6211\u4eec\u5728\u4fee\u6539\u4e00\u7684\u65f6\u5019\uff0c\u600e\u4e48\u4fee\u6539\u7ebf\u6bb5\u6811\u4e0a\u7684\u503c\u5462\uff1f\n\n### \u7ef4\u62a4\u7ebf\u6bb5\u6811\n\n\u6211\u4eec\u53d1\u73b0\uff0c\u5728\u4fee\u6539\u7684\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u4e00\u6b21\u6211\u4eec\u4ece\u5f53\u524d$splay$\u8fde\u5411\u4e0a\u9762\u7684$splay$\u65f6\uff0c\u4f1a\u628a\u4e00\u6761\u865a\u8fb9\u53d8\u6210\u91cd\u8fb9\u3001\u4e00\u6761\u91cd\u8fb9\u53d8\u6210\u865a\u8fb9\n\n\u90a3\u4e48\uff0c\u539f\u6765\u91cd\u8fb9\u4e0b\u7684\u8fd9\u68f5\u5b50\u6811\uff0c\u56e0\u4e3a\u5b83\u4e0a\u9762\u7684\u4e1c\u897f\u53d8\u6210\u4e86\u65b0\u7684\u989c\u8272\uff0c\u800c\u4e0a\u9762\u7684\u4e1c\u897f\u672c\u6765\u662f\u548c\u5b83\u4e00\u4e2a\u989c\u8272\u7684\uff0c\u6240\u4ee5\u91cd\u8fb9\u7684\u8fd9\u68f5\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u8981+1\n\n\u800c\u5bf9\u4e8e\u539f\u6765\u865a\u8fb9\u4e0b\u9762\u7684\u8fd9\u68f5\u5b50\u6811\u6765\u8bf4\uff0c\u5b83\u4e0a\u9762\u7684\u4e1c\u897f\u672c\u6765\u548c\u5b83\u4e0d\u662f\u4e00\u4e2a\u989c\u8272\u7684\uff0c\u73b0\u5728\u662f\u540c\u4e00\u4e2a\u989c\u8272\u4e86\uff0c\u6240\u4ee5\u865a\u8fb9\u7684\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u8981-1\n\n\u8fd9\u6837\uff0c\u6211\u4eec\u53ea\u8981\u5728$Access$\u7684\u65f6\u5019\uff0c\u540c\u65f6\u7ef4\u62a4\u7ebf\u6bb5\u6811\u7684\u6743\u503c\u5c31\u53ef\u4ee5\u4e86\n\n### \u603b\u7ed3\n\n\u672c\u9898\u4ece\u4e0e$Access$\u76f8\u4f3c\u7684\u4fee\u6539\u65b9\u5f0f\u5f00\u59cb\uff0c\u5207\u5165\u70b9\u662f$LCT$\uff0c\u7136\u540e\u52a0\u5165\u4e86\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5e76\u4e14\u786e\u5b9a\u4e86\u5728$Access$\u64cd\u4f5c\u7684\u540c\u65f6\u4fee\u6539\u7ebf\u6bb5\u6811\u7684\u503c\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u5747\u644a$O(nlog^2n)$\n\n\u4e00\u4e9b\u5b9e\u73b0\u7ec6\u8282\u53ef\u4ee5\u53c2\u8003\u4ee3\u7801\n\n# Code\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,Q,first[100010],cnte,dep[100010],st[100010][20],dfn[100010],lim[100010],back[100010],cntn;\nint fa[100010];\nstruct edge{\n\tint to,next;\n}e[200010];\ninline void add(int u,int v){\n\te[++cnte]=(edge){v,first[u]};first[u]=cnte;\n\te[++cnte]=(edge){u,first[v]};first[v]=cnte;\n}\nvoid dfs(int u,int f){\n\tint i,v;dep[u]=dep[f]+1;st[u][0]=f;fa[u]=f;//\u8fd9\u91cc\u628aLCT\u7684fa\u6570\u7ec4\u9884\u5904\u7406\u597d\uff08\u6b64\u65f6\u6ca1\u6709\u8fb9\uff0c\u90fd\u662f\u865a\u8fb9\uff09\n\tdfn[u]=++cntn;back[cntn]=u;\n\tfor(i=first[u];~i;i=e[i].next){\n\t\tv=e[i].to;if(v==f) continue;\n\t\tdfs(v,u);\n\t}\n\tlim[u]=cntn;\n}\nvoid ST(){\n\tfor(int j=1;j<=19;j++){\n\t\tfor(int i=1;i<=n;i++) \n        \tst[i][j]=st[st[i][j-1]][j-1];\n\t}\n}\nint lca(int l,int r){\n\tint i;\n\tif(dep[l]>dep[r]) swap(l,r);\n\tfor(i=19;i>=0;i--) if(dep[st[r][i]]>=dep[l]) r=st[r][i];\n\tif(l==r) return l;\n\tfor(i=19;i>=0;i--){\n\t\tif(st[r][i]!=st[l][i]){\n\t\t\tl=st[l][i];\n\t\t\tr=st[r][i];\n\t\t}\n\t}\n\treturn st[l][0];\n}\n//segment tree\nint a[400010],lazy[400010];\nvoid update(int num){\n\ta[num]=max(a[num<<1],a[num<<1|1]);\n}\nvoid push(int l,int r,int num){\n\tif(l==r||!lazy[num]) return;\n\ta[num<<1]+=lazy[num];a[num<<1|1]+=lazy[num];\n\tlazy[num<<1]+=lazy[num];lazy[num<<1|1]+=lazy[num];\n\tlazy[num]=0;\n}\nvoid build(int l,int r,int num){\n\tif(l==r){a[num]=dep[back[l]];return;}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,num<<1);build(mid+1,r,num<<1|1);\n\tupdate(num);\n}\nvoid change(int l,int r,int ql,int qr,int num,int ch){\n\tpush(l,r,num);\n\tif(l>=ql&&r<=qr){a[num]+=ch;lazy[num]+=ch;return;}\n\tint mid=(l+r)>>1;\n\tif(mid>=ql) change(l,mid,ql,qr,num<<1,ch);\n\tif(mid<qr) change(mid+1,r,ql,qr,num<<1|1,ch);\n\tupdate(num);\n}\nint query(int l,int r,int ql,int qr,int num){\n\tpush(l,r,num);\n\tif(l>=ql&&r<=qr) return a[num];\n\tint mid=(l+r)>>1,re=-1e9;\n\tif(mid>=ql) re=max(re,query(l,mid,ql,qr,num<<1));\n\tif(mid<qr) re=max(re,query(mid+1,r,ql,qr,num<<1|1));\n\treturn re;\n}\n//link cut tree\nint ch[100010][2]={0},rt[100010];//\u8fd9\u68f5splay\u5176\u5b9e\u4ec0\u4e48\u90fd\u4e0d\u7528\u7ef4\u62a4......\u53ea\u662f\u9700\u8981\u5b83\u7684\u7ed3\u6784\u7f62\u4e86\nint get(int pos){return ch[fa[pos]][1]==pos;}\nvoid rotate(int x){\n\tint f=fa[x],ff=fa[f],son=get(x);\n\tch[f][son]=ch[x][son^1];\n\tif(ch[f][son]) fa[ch[f][son]]=f;\n\tfa[f]=x;ch[x][son^1]=f;\n\tfa[x]=ff;\n\tif(rt[f]) rt[x]=1,rt[f]=0;\n\telse ch[ff][ch[ff][1]==f]=x;\n}\nvoid splay(int pos){\n\tif(rt[pos]) return;\n\tfor(int f;!rt[pos];rotate(pos)){\n\t\tif(!rt[f=fa[pos]])\n\t\t\trotate((get(f)==get(pos))?f:pos);\n\t}\n}\nint pre(int pos){\n\twhile(ch[pos][0]) pos=ch[pos][0];\n\treturn pos;\n}\nvoid access(int pos){\n\tfor(int tmp=0,tt;pos;tmp=pos,pos=fa[pos]){\n\t\tsplay(pos);\n\t\tif(ch[pos][1]){//\u91cd\u8fb9\u53d8\u865a\u8fb9\uff0c+1\n\t\t\ttt=pre(ch[pos][1]);\n\t\t\tchange(1,n,dfn[tt],lim[tt],1,1);\n\t\t}\n\t\trt[ch[pos][1]]=1;ch[pos][1]=tmp;rt[tmp]=0;\n\t\tif(tmp){//\u865a\u8fb9\u53d8\u91cd\u8fb9\uff0c-1\n\t\t\ttt=pre(tmp);\n\t\t\tchange(1,n,dfn[tt],lim[tt],1,-1);\n\t\t}\n\t}\n}\nint main(){\n\tmemset(first,-1,sizeof(first));\n\tn=read();Q=read();int i,t1,t2,t3,f;\n\tfor(i=1;i<n;i++){\n\t\tt1=read();t2=read();\n\t\tadd(t1,t2);\n\t}\n\tdfs(1,0);ST();build(1,n,1);\n\tfor(i=1;i<=n;i++) rt[i]=1;\n\twhile(Q--){\n\t\tt1=read();\n\t\tif(t1==1){\n\t\t\tt2=read();access(t2);\n\t\t}\n\t\tif(t1==2){\n\t\t\tt2=read();t3=read();\n\t\t\tf=lca(t2,t3);\n\t\t\tprintf(\"%d\\n\",query(1,n,dfn[t2],dfn[t2],1)+query(1,n,dfn[t3],dfn[t3],1)-2*query(1,n,dfn[f],dfn[f],1)+1);\n\t\t}\n\t\tif(t1==3){\n\t\t\tt2=read();\n\t\t\tprintf(\"%d\\n\",query(1,n,dfn[t2],lim[t2],1)); \n\t\t}\n\t}\n}\n```",
        "postTime": 1533188828,
        "uid": 27753,
        "name": "Orion545",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "//\u672c\u849f\u84bb\u535a\u5ba2\u7684\u540c\u6b65\u9605\u8bfb\uff1a[Newuser\u5c0f\u7ad9\uff01](http://www.newuser.top/2018/04/11/shudiantuse/)\n\n\u8fd9\u4e0d\u662f\u7eaf\u79cd\u7684LCT\uff0c\uff0c\uff0c\uff0c\u662fLCT+LCA+DFS\u5e8f\uff08\u6216\u8005\u91cd\u94fe\u5256\u5206\uff09+\u7ebf\u6bb5\u6811\uff0c\u6700\u8fd1\u5b66\u7684\u5168\u7528\u8fdb\u6765\u4e86\uff0c\uff0c\u5f88\u6709\u55a7\u5bbe\u593a\u4e3b\u7684\u610f\u5473\u3002\u3002\u3002\n\n\u9996\u5148\u4ed6\u662f\u6bcf\u4e00\u6b21\u90fd\u6d82\u4e00\u79cd\u4e0d\u540c\u7684\u989c\u8272\uff0c\u5c31\u4e0d\u7528\u5177\u4f53\u5b58\u50a8\u5177\u4f53\u7684\u989c\u8272\u3002 \u6211\u4eec\u770b\u5230\u7b2c1\u4e2a\u64cd\u4f5c\uff0c\u8fd9\u548cLCT\u7684ACCESE\u5f88\u6709\u76f8\u4f3c\u4e4b\u5904\u3002\u4e8e\u662f\u6211\u4eec\u5c31\u60f3\u5230\uff0c\u8bbe\u5b9a\u4e00\u4e2aSPLAY\u5c31\u662f\u4e00\u4e2a\u989c\u8272\u96c6\u5408\u7684\u8bdd\uff0c\u90a3\u4e48\u8fd9\u4e2a\u64cd\u4f5c1\u5c31\u662f\u4e00\u4e2a\u88f8\u7684ACCES\u64cd\u4f5c\u5c31\u597d\u4e86\n\n\u7b2c2\u4e2a\u64cd\u4f5c\u6c42AB\u4e24\u70b9\u95f4\u7684\u8def\u5f84\u4e0a\u7684\u6743\u503c\uff0c\u8f6c\u5316\u4e3a\u8282\u70b9\u5230\u6839\u7ecf\u8fc7\u4e86\u591a\u5c11\u4e2asplay\uff0cnum[x]\uff0cnum[a]+num[b]-num[lca(a,b)]*2+1 \u7b2c3\u4e2a\u64cd\u4f5c\u6c42\u5b50\u6811\u91cc\u9762\u7684\u6700\u5927num\uff0c\u53ef\u4ee5dfs\u5e8f+\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002 \u8bbe\u5b9anum[x]\u4e3a\u4ecex\u8282\u70b9\u5f00\u59cb\uff0c\u5f80\u4e0a\u8d70\u5230\u6839\u7ecf\u8fc7\u4e86\u591a\u5c11\u4e2asplay\uff0c\u5728\u5f00\u59cb\u7684\u65f6\u5019\u6240\u6709\u8282\u70b9\u90fd\u5404\u81ea\u4e3a\u4e00\u4e2asplay,\u6b64\u65f6\u7684num[x]\u5c31\u662f\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6dep\uff0c\u5728dfs\u7684\u65f6\u5019\u5c31\u53ef\u4ee5\u641e\u51fa\u6765\u3002 \u60f3\u5230\u8fd9\u4e2aLCT,\u6ca1\u6709link,\u6ca1\u6709cut\uff0c\u53ea\u6709\u865a\u5b9e\u8fb9\u7684\u8f6c\u5316\uff0c\u4e8e\u662f\u4e4e\u53ea\u6709Acces\u4f1a\u8c03\u6574\u4ed6\u7684num\u503c\uff08\u5207\u6362\u5de6\u53f3\u513f\u5b50\u7684\u65f6\u5019\uff09\u3002\u8003\u8651\u5230\u6bcf\u8fde\u4e0a\u53bb\u4e00\u6761\u8fb9\uff0c\u539f\u672c\u8fde\u5230\u7684\u90a3\u4e2a\u7ed3\u70b9\uff08\u5207\u6362\u70b9\u7684\u540e\u7ee7\uff09\u7684\u5b50\u6811\u4ece id[x]\u5230id[x]+siz[x]-1\u90fd\u4f1a\u52a0\u4e0a\u4e00\u4e2a1\uff08\u591a\u4e86\u4e00\u4e2a\u865a\u8fb9\u591a\u4e86\u4e00\u4e2a\u5230\u6839\u8282\u70b9\u7684splay\uff09,\u4e4b\u540e\u8fde\u5230\u7684\u90a3\u4e2a\u7ed3\u70b9\u7684id[x]+siz[x]-1\u90fd\u4f1a\u51cf\u53bb\u4e00\u4e2a1\u3002\n\n\u6211\u4eec\u8003\u8651\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5176\u533a\u95f4max\uff0c\u6bcf\u6b21ACCES\u52a0\u51cf\u5c31\u662fmax\u7684\u533a\u95f4\u4fee\u6539\uff0c\u800c\u7b2c\u4e09\u95ee\u5219\u76f4\u63a5\u8be2\u95ee\u5b50\u6811\u4e0a\u7684\u533a\u95f4Max\u3002\n\n\u6ce8\u610f\u6211\u4eecsplay\u7ef4\u62a4\u7684dfs\u5e8f\uff0c\u5728\u8003\u8651\u5207\u6362\u91cd\u8fb9\u7684\u65f6\u5019\u8981\u8003\u8651\u5230\u627e\u5230\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff08\u56e0\u4e3a\u8fd9\u4e2a\u5361\u4e86\u4e24\u4e2a\u5c0f\u65f6\u7684\u849f\u84bb\uff09\u3002\n\n\u8981\u627eLCA\uff0c\u7531\u4e8e\u8fd9\u5176\u5b9e\u662f\u4e00\u4e2a\u9759\u6001\u7684\u6811\uff0c\u6211\u4eec\u53ef\u4ee5LCA\u8f6cRMQ\uff0c\uff0c\u7531\u4e8e\u672c\u849f\u84bb\u5f88\u5f31\uff0c\u76f4\u63a5\u5199\u7684\u500d\u589e\u3002\u3002\u3002\n\n\u4e8e\u662f\u5c31\u641e\u5b9a\u5566\uff01\n\ncode:\n\n```cpp\n#include<stdio.h>\n#include<bits/stdc++.h>\n#define midd ((l+r)>>1)\n#define zig(x) zigzag(x,1)\n#define zag(x) zigzag(x,2)\nusing namespace std;\nint n,m;\nint owo,la[100005],nt[200005],en[200005];\nvoid addedge(int a,int b)\n{\n    en[++owo]=b; nt[owo]=la[a]; la[a]=owo;\n}\nint idcnt,id[100005],old[100005],maxr[100005],dep[100005];\nint fa[100005],ls[100005],rs[100005];\nstruct node\n{\n    int ll,rr,mx,lazy;\n}z[8*100005];\nvoid maketree(int p,int l,int r)\n{\n    z[p].ll=l; z[p].rr=r;\n    if(l==r) { z[p].mx=dep[old[l]]; return; } \n    maketree(p<<1,l,midd);\n    maketree(p<<1|1,midd+1,r);\n    z[p].mx=max(z[p<<1].mx,z[p<<1|1].mx);\n}\nvoid ppd(int p)\n{\n\tif(z[p].ll==z[p].rr||(!z[p].lazy)) return;\n    z[p<<1].lazy+=z[p].lazy;\n    z[p<<1|1].lazy+=z[p].lazy;\n    z[p<<1].mx+=z[p].lazy;\n    z[p<<1|1].mx+=z[p].lazy;\n    z[p].lazy=0;\n}\nbool isroot(int x) { return ((!fa[x])||(ls[fa[x]]!=x&&rs[fa[x]]!=x)); } \nvoid zigzag(int x,int knd) \n{ \n    int y=fa[x]; int z=fa[y]; \n    if(!isroot(y)) \n    { \n        if(ls[z]==y) ls[z]=x; \n        else rs[z]=x; \n    } \n    fa[x]=z; fa[y]=x; \n    if(knd==1) \n    { \n        ls[y]=rs[x]; \n        fa[ls[y]]=y; \n        rs[x]=y; \n    } \n    else \n    { \n        rs[y]=ls[x]; \n        fa[rs[y]]=y; \n        ls[x]=y; \n    } \n}\nvoid splay(int x) \n{ \n    int y,z; \n    while(!isroot(x)) \n    { \n        y=fa[x]; z=fa[y]; \n        if(isroot(y)) \n        { \n            if(ls[y]==x) zig(x); \n            else zag(x); \n        } \n        else \n        { \n            if(ls[z]==y) \n            { \n                if(ls[y]==x) { zig(y); zig(x); } \n                else { zag(x); zig(x); }  \n            } \n            else \n            { \n                if(rs[y]==x) { zag(y); zag(x); } \n                else { zig(x); zag(x); } \n            }  \n        } \n    } \n}\nvoid update(int p,int x,int y,int d)\n{\n    if(x<=z[p].ll&&z[p].rr<=y) { z[p].mx+=d; z[p].lazy+=d; return; }\n    if(z[p].lazy) ppd(p);\n    if(z[p<<1].rr>=x&&z[p<<1].ll<=y) update(p<<1,x,y,d);\n    if(z[p<<1|1].rr>=x&&z[p<<1|1].ll<=y) update(p<<1|1,x,y,d);\n    z[p].mx=max(z[p<<1|1].mx,z[p<<1].mx);\n}\nint mmm(int x)\n{\n\twhile(ls[x]) x=ls[x];\n\treturn x;\n}\nvoid acc(int x)\n{\n    for(int y=0;x;y=x,x=fa[x])\n    {\n        splay(x);\n        if(rs[x])\n        {\n        \tint z=mmm(rs[x]);\n            update(1,id[z],maxr[z],1);\n        }\n        rs[x]=y;\n        if(y)\n        {\n        \tint z=mmm(y);\n            update(1,id[z],maxr[z],-1);\n        }\n    }\n}\n\n\nint getmax(int p,int x,int y)\n{\n    if(x<=z[p].ll&&z[p].rr<=y) return z[p].mx;\n    if(z[p].lazy) ppd(p);\n    int lmax=-0x3f3f3f3f,rmax=-0x3f3f3f3f;\n    if(z[p<<1].rr>=x&&z[p<<1].ll<=y) lmax=getmax(p<<1,x,y);\n    if(z[p<<1|1].rr>=x&&z[p<<1|1].ll<=y) rmax=getmax(p<<1|1,x,y);\n    return max(lmax,rmax);\n}\nint pa[100005][30];\nint lcaa(int x,int y)\n{\n    if(dep[x]<dep[y]) swap(x,y);\n    for(int k=dep[x]-dep[y],i=0;k;i++,k>>=1)\n    {\n        if(k&1) x=pa[x][i];\n    }\n    if(x==y) return x;\n    for(int k=20;k>=0;k--)\n    {\n        if(pa[x][k]!=pa[y][k]) { x=pa[x][k]; y=pa[y][k]; }\n    }\n    return pa[x][0];\n}\n\nvoid dfs(int x,int ba)\n{\n    pa[x][0]=ba;\n    dep[x]=dep[ba]+1;\n    for(int k=20,i=1;i<=k;i++) pa[x][i]=pa[pa[x][i-1]][i-1];\n    fa[x]=ba;\n    id[x]=++idcnt;\n\told[idcnt]=x;\n\tfor(int it=la[x];it;it=nt[it])\n    {\n        if(en[it]!=ba)\n        {\n            dfs(en[it],x);\n        }\n    }\n    maxr[x]=idcnt;\n}\nint query(int p,int x)\n{\n    if(z[p].ll==z[p].rr) return z[p].mx;\n        if(z[p].lazy) ppd(p);\n    if(x<=z[p<<1].rr) return query(p<<1,x);\n    else return query(p<<1|1,x);\n}\nint main()\n{\n//\tfreopen(\"date.in\",\"r\",stdin);\n//\tfreopen(\"zhengjie.out\",\"w\",stdout);\n    int a,b;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&a,&b); addedge(a,b); addedge(b,a);\n    }\n    dfs(1,0);\n    maketree(1,1,n);\n    int kkk,x;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d\",&kkk);\n        if(kkk==1)\n        {\n            scanf(\"%d\",&x);\n            acc(x);\n        }\n        else if(kkk==2)\n        {\n            scanf(\"%d%d\",&a,&b);\n            int aha=lcaa(a,b);\n            int aaaa=query(1,id[a])+query(1,id[b])-query(1,id[aha])*2+1;\n            printf(\"%d\\n\",aaaa);\n        }\n        else\n        {\n            scanf(\"%d\",&a);\n            printf(\"%d\\n\",getmax(1,id[a],maxr[a]));\n        }\n    }\n} \n\n```\n\n",
        "postTime": 1523434534,
        "uid": 55343,
        "name": "Newuser",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](http://zrzring.cn/index.php/archives/190)\n\n1\u64cd\u4f5c\u5f88\u5bb9\u6613\u8054\u60f3\u5230LCT\u7684access\uff0c\u8003\u8651\u5bf9\u4e8e\u5269\u4e0b\u4fe9\u64cd\u4f5c\u7684\u7ef4\u62a4\uff0c\u4f46\u5176\u5b9e\u5bf9\u4e8e\u6811\u4e0a\u70b9\u5230\u6839\u7684\u8def\u5f84\u6743\u503c\u5177\u6709\u53ef\u51cf\u6027\uff0c\u4e8e\u662f\u7ef4\u62a4\u8fd9\u6837\u4e00\u4e2a\u8ddd\u79bb\uff0c\u7136\u540e\u7528\u6811\u4e0a\u5dee\u5206\u56de\u7b542\u8be2\u95ee\uff0c\u56e0\u4e3a\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u5728dfs\u5e8f\u4e0a\u662f\u8fde\u7eed\u7684\u4e00\u6bb5\uff0c\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6700\u5927\u503c\u56de\u7b543\u8be2\u95ee\n\n\u8fd9\u4e2a\u9898\u5c31\u6210\u4e863\u4e2a\u677f\u5b50\u7684\u5d4c\u5957+\u5de7\u5999\u7684LCT\uff0c\u7ebf\u6bb5\u6811\u548clca\u90fd\u662f\u57fa\u7840\u4e86\u4e0d\u5fc5\u518d\u8d58\u8ff0\n\n\u5de7\u5999\u7684LCT\u5728\u4e8e\u53ef\u4ee5\u7528\u8fd9\u4e2a\u9898\u52a0\u6df1\u5bf9access\u7684\u7406\u89e3\uff0c\u5355\u72ec\u62ff\u51faaccess\u6765\u8bf4\n\n```cpp\nvoid access(int x) {\n    for (int y = 0; x; y = x, x = fa[x]) {\n        splay(x); rs = y; //pushup(x);\n    }\n}\n\nvoid access(int x) {\n    int c;\n    for (int y = 0; x; y = x, x = fa[x]) {\n        splay(x);\n        if (rs) c = findrt(rs), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, 1);\n        if (rs = y) c = findrt(y), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, -1);\n    }\n}\n```\n\naccess\u5b9e\u8d28\u662f\u6211\u4eec\u8981\u5bf9\u4e8ex\u5230\u6839\u8def\u5f84\u5168\u90e8\u53d8\u6210\u5b9e\u8fb9\uff0c\u6211\u4eec\u8981\u7684\u662f\u5bf9\u4e8e\u7ef4\u62a4\u7684\u4fe1\u606f\u8fdb\u884c\u4fee\u6539\n\n\u8003\u8651\u6027\u8d28\uff0c\u865a\u8fb9\u6709\u8d21\u732e\uff0c\u800c\u5b9e\u8fb9\u6ca1\u6709\u8d21\u732e\uff0c\u5728\u5177\u4f53\u5b9e\u73b0\u8fc7\u7a0b\u4e2d\uff0c\u5bf9\u4e8e\u70b9x\uff0c\u9047\u5230\u5b83\u7684\u7236\u4eb2\u5230\u5b83\u4e3a\u865a\u8fb9\u5219\u53d8\u5b9e\uff0c\u7136\u540e\u6574\u4e2a\u5b50\u6811\u5230\u6839\u8282\u70b9\u7684\u8ddd\u79bb-1\uff0c\u7136\u540e\u628ax\u7684\u7236\u4eb2\u539f\u6765\u8fde\u7684\u5b9e\u8fb9\u7684\u90a3\u4e2a\u5b50\u6811\u8d21\u732e+1\uff0c\u5373\u53ef\u89e3\u51b31\u64cd\u4f5c\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define q(x, y) SEG::query(1, 1, n, x, y)\n#define inf 1e9\nusing namespace std;\nvoid file() {\n    freopen(\"read.in\", \"r\", stdin);\n    freopen(\"write.out\", \"w\", stdout);\n}\nconst int N = 1e6 + 10;\ninline int read() {\n    int sym = 0, res = 0; char ch = getchar();\n    while (!isdigit(ch)) sym |= (ch == '-'), ch = getchar();\n    while (isdigit(ch)) res = (res << 3) + (res << 1) + (ch ^ 48), ch = getchar();\n    return sym ? -res : res;\n}\nstruct EDGE {\n    int u, v, nxt;\n} edge[N];\nint n, m, head[N], cnt, dfn[N], siz[N], depth[N], rev[N];\nvoid add(int u, int v) {edge[++cnt] = (EDGE){u, v, head[u]}; head[u] = cnt;}\nnamespace SEG {\n    int tmax[N], tag[N];\n    #define ls x << 1\n    #define rs x << 1 | 1\n    void pushup(int x) {tmax[x] = max(tmax[ls], tmax[rs]);}\n    void update(int x, int t) {tmax[x] += t; tag[x] += t;}\n    void pushdown(int x, int l, int r, int mid) {\n        if (tag[x]) {\n            update(ls, tag[x]); update(rs, tag[x]); tag[x] = 0;\n        }\n    }\n    void build(int x, int l, int r) {\n        if (l == r) {tmax[x] = depth[rev[l]]; return;}\n        int mid = l + r >> 1;\n        build(ls, l, mid); build(rs, mid + 1, r);\n        pushup(x);\n    }\n    void change(int x, int l, int r, int ln, int rn, int t) {\n        if (ln <= l && r <= rn) {update(x, t); return;}\n        int mid = l + r >> 1; pushdown(x, l, r, mid);\n        if (mid >= ln) change(ls, l, mid, ln, rn, t);\n        if (mid + 1 <= rn) change(rs, mid + 1, r, ln, rn, t);\n        pushup(x);\n    }\n    int query(int x, int l, int r, int ln, int rn) {\n        if (ln <= l && r <= rn) return tmax[x];\n        int mid = l + r >> 1, res = 0; pushdown(x, l, r, mid);\n        if (mid >= ln) res = max(res, query(ls, l, mid, ln, rn));\n        if (mid + 1 <= rn) res = max(res, query(rs, mid + 1, r, ln, rn));\n        return res;\n    }\n}\nnamespace LCT {\n    int son[N][2], fa[N];\n    #define ls son[x][0]\n    #define rs son[x][1]\n    bool l_r(int x) {return x == son[fa[x]][1];}\n    bool isroot(int x) {return son[fa[x]][0] != x && son[fa[x]][1] != x;}\n    int findrt(int x) {while (ls) x = ls; return x;}\n    void rotate(int x) {\n        int y = fa[x], z = fa[y], kind = l_r(x);\n        if (!isroot(y)) son[z][l_r(y)] = x;\n        son[y][kind] = son[x][kind ^ 1]; fa[son[x][kind ^ 1]] = y;\n        son[x][kind ^ 1] = y; fa[y] = x; fa[x] = z;\n    }\n    void splay(int x) {\n        for (int y = fa[x]; !isroot(x); y = fa[x]) {\n            if (!isroot(y)) rotate(l_r(x) == l_r(y) ? y : x); rotate(x);\n        }\n    }\n    void access(int x) {\n        int c;\n        for (int y = 0; x; y = x, x = fa[x]) {\n            splay(x);\n            if (rs) c = findrt(rs), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, 1);\n            if (rs = y) c = findrt(y), SEG::change(1, 1, n, dfn[c], dfn[c] + siz[c] - 1, -1);\n        }\n    }\n}\nnamespace LCA {\n    int top[N], son[N], fa[N];\n    void dfs1(int u, int last) {\n        depth[u] = depth[last] + 1; siz[u] = 1; fa[u] = last;\n        for (int e = head[u]; e; e = edge[e].nxt) {\n            int v = edge[e].v; if (v == last) continue; dfs1(v, u);\n            siz[u] += siz[v]; if (siz[v] > siz[son[u]]) son[u] = v;\n        }\n    }\n    void dfs2(int u, int front) {\n        dfn[u] = ++cnt; rev[cnt] = u; top[u] = front; if (son[u]) dfs2(son[u], front);\n        for (int e = head[u]; e; e = edge[e].nxt) {\n            int v = edge[e].v; if (v == fa[u] || v == son[u]) continue; dfs2(v, v);\n        }\n    }\n    int lca(int x, int y) {\n        while (top[x] != top[y]) depth[top[x]] < depth[top[y]] ? y = fa[top[y]] : x = fa[top[x]];\n        return depth[x] < depth[y] ? x : y;\n    }\n}\nint main() {\n    n = read(); m = read();\n    for (int i = 1; i < n; i++) {\n        int u = read(), v = read(); add(u, v); add(v, u);\n    }\n    cnt = 0; LCA::dfs1(1, 0); LCA::dfs2(1, 1); cnt = 0; SEG::build(1, 1, n);\n    for (int i = 1; i <= n; i++) LCT::fa[i] = LCA::fa[i];\n    for (int i = 1; i <= m; i++) {\n        int opt = read(), x = read();\n        if (opt == 1) LCT::access(x);\n        if (opt == 2) {\n            int y = read(), lca = LCA::lca(x, y);\n            printf(\"%d\\n\", q(dfn[x], dfn[x]) + q(dfn[y], dfn[y]) - 2 * q(dfn[lca], dfn[lca]) + 1);\n        }\n        if (opt == 3) {\n            printf(\"%d\\n\", q(dfn[x], dfn[x] + siz[x] - 1));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1595595576,
        "uid": 28392,
        "name": "zrzring",
        "ccfLevel": 5,
        "title": "P3703 [SDOI2017]\u6811\u70b9\u6d82\u8272"
    },
    {
        "content": "\u6bd4\u8f83\u6709\u8da3\u7684\u7efc\u5408**\u6811\u4e0a\u95ee\u9898**\uff0c\u5237**LCT**\u9898\u5355\u65f6\u505a\u7684\u4f46\u662f\u53d1\u73b0\u540e\u9762LCT\u53ea\u662f\u8d77\u4e86\u8f85\u52a9\u4f5c\u7528233\n\n\u9996\u5148\u6211\u4eec\u5206\u6790\u6bcf\u4e00\u4e2a\u64cd\u4f5c\uff0c$1$\u7684\u5b9a\u4e49\u5c31\u8ba9\u6211\u4eec\u8054\u60f3\u5230\u4e86```access```\uff0c\u6211\u4eec\u56de\u5fc6\u4e00\u4e0bLCT\u7684\u6027\u8d28\uff1a\n\n> LCT\u4e2d\u6bcf\u4e00\u4e2asplay\u4fdd\u5b58\u7684\u90fd\u662f\u539f\u6811\u4e0a\u6df1\u5ea6\u8fde\u7eed\u7684\u4e00\u6761\u94fe\u3002\n\n\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u7531\u4e8e\u8fd9\u91cc\u7684\u67d3\u8272\u662f\u67d3\u4e0a**\u5168\u65b0**\u7684\u4e00\u79cd\u989c\u8272\uff0c\u6240\u4ee5\u6bcf\u4e00\u6b21```access```\u540e\u7684\u6bcf\u68f5splay\u7ef4\u62a4\u7684\u90fd\u662f**\u540c\u79cd\u989c\u8272**\u7684\u70b9\u94fe\uff0c\u662f\u540c\u65f6\u7b26\u5408\u6027\u8d28\u548c\u9898\u76ee\u8981\u6c42\u7684\n\n\u4e0d\u8fc7\u6ce8\u610f\u7531\u4e8e\u8fd9\u91cc\u662f\u67d3**\u65b0\u7684\u989c\u8272**\uff0c\u6240\u4ee5\u662f\u53ef\u4ee5\u7528```access```\u7684\uff0c\u5982\u679c\u662f\u67d3\u6210\u4e4b\u524d\u7684\u67d0\u79cd\u989c\u8272\u90a3\u4e48\u5c31\u4e0d\u80fd\u8fd9\u4e48\u505a\uff01\n\n\u597d\u4e86\u60f3\u5b8c\u4fee\u6539\u6211\u4eec\u6765\u8003\u8651\u8be2\u95ee\uff0c\u9996\u5148\u770b$2$\u64cd\u4f5c\uff0c\u8be2\u95ee\u8def\u5f84\u7684\u989c\u8272\u4e2a\u6570\uff1f\n\n\u7531\u4e8e\u8fd9\u662f\u4e00\u68f5**\u6709\u6839\u6811**\uff0c\u7ed3\u5408\u524d\u9762\u7684\u64cd\u4f5c\u6211\u4eec\u5bb9\u6613\u60f3\u5230\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u989c\u8272\u4e2a\u6570\u8bb0\u4e3a$col_i$\n\n\u5bb9\u6613\u53d1\u73b0\u8fd9\u91cc\u7684$col$\u5177\u6709**\u53ef\u51cf\u6027**\uff0c\u90a3\u4e48\u7ef4\u62a4\u8def\u5f84\u989c\u8272\u4e2a\u6570\u5c31\u53ef\u4ee5\u7528**\u6811\u4e0a\u5dee\u5206**\n\n\u5177\u4f53\u7684\uff0c\u8def\u5f84$x,y$\u4e4b\u95f4\u7684\u989c\u8272\u4e2a\u6570\u5c31\u662f$col_x+col_y-2\\cdot col_{\\operatorname{LCA}(x,y)}+1$\n\n\u8fd9\u4e2a\u548c\u6c42\u6811\u4e0a\u4e24\u70b9\u95f4\u8ddd\u79bb\u7c7b\u4f3c\uff0c\u4e0d\u8fc7\u5c31\u662f$\\operatorname{LCA}$\u7684\u989c\u8272\u4f1a\u88ab\u51cf\u4e24\u6b21\u6240\u4ee5\u8981\u52a0\u56de\u53bb\n\n\u7136\u540e\u5c31\u662f$3$\u64cd\u4f5c\uff0c\u6211\u4eec\u53d1\u73b0\u5f53\u6211\u4eec\u7ef4\u62a4\u4e86$col$\u4e4b\u540e\u5176\u5b9e\u5c31\u662f\u8be2\u95ee\u4e00\u4e2a\u5b50\u6811\u5185\u6700\u5927\u7684$col$\n\n\u5b50\u6811\u4fe1\u606f\u60f3\u5230\u4ec0\u4e48\uff0c**DFS\u5e8f**\u554a\uff01\u7ed3\u5408\u524d\u9762\u7684```access```\u65f6\u8fdb\u884c\u7684\u4e5f\u662f\u5b50\u6811\u4fee\u6539\uff0c\u6211\u4eec\u5bb9\u6613\u60f3\u5230\u7ef4\u62a4**\u533a\u95f4\u4fee\u6539\u533a\u95f4\u67e5\u6700\u5927\u503c**\u7684**\u7ebf\u6bb5\u6811**\uff0c\u8fd9\u6837\u7ed3\u5408```access```\u7684\u671f\u671b$\\log$\u590d\u6742\u5ea6\u662f$O(n\\log^2n)$\u7684\uff08\u590d\u6742\u5ea6\u5206\u6790\u7c7b\u4f3c\u4e8eLCT\u4e0a\u7684\u5e73\u8861\u6811\u64cd\u4f5c\uff09\n\n\u90a3\u4e48\u5c31\u4ee3\u7801\u5b9e\u73b0\u65b9\u9762\uff0cDFS\u5e8f\u90fd\u8981\u5199\u4e86\uff0c\u90a3\u4e48\u987a\u5e26\u5199\u4e00\u4e0b**\u6811\u5256**\u5427\uff0c\u4e00\u822c\u8df3\u7684\u6bd4\u500d\u589e\u5feb\u4e00\u4e9b\n\n\u7136\u540e\u5c31\u662f\u7801\u519c\u65f6\u523b\u4e86\uff0c\u5efa\u8bae\u628a\u4ee3\u7801\u5206\u5757\u4e00\u4e0b\u8981\u4e0d\u7136\u5f88\u5bb9\u6613\u8c03\u6b7b\u4e0d\u51fa\n\n\u5949\u4e0a\u8fd1$200$\u884c\u7684CODE\n\n```cpp\n#include<cstdio>\n#include<cctype>\n#define RI register int\n#define CI const int&\n#define Tp template <typename T>\nusing namespace std;\nconst int N=100005;\nstruct edge\n{\n    int to,nxt;\n}e[N<<1]; int n,m,head[N],cnt,opt,x,y,fa,id[N],dep[N],dfn[N],size[N];\nclass FileInputOutput\n{\n    private:\n        static const int S=1<<21;\n        #define tc() (A==B&&(B=(A=Fin)+fread(Fin,1,S,stdin),A==B)?EOF:*A++)\n        #define pc(ch) (Ftop<S?Fout[Ftop++]=ch:(fwrite(Fout,1,S,stdout),Fout[(Ftop=0)++]=ch))\n        char Fin[S],Fout[S],*A,*B; int pt[15],Ftop;\n    public:\n        Tp inline void read(T& x)\n        {\n            x=0; char ch; while (!isdigit(ch=tc()));\n            while (x=(x<<3)+(x<<1)+(ch&15),isdigit(ch=tc()));\n        }\n        Tp inline void write(T x)\n        {\n            if (!x) return (void)(pc('0'),pc('\\n')); RI ptop=0;\n            while (x) pt[++ptop]=x%10,x/=10; while (ptop) pc(pt[ptop--]+48); pc('\\n');\n        }\n        inline void Fend(void)\n        {\n            fwrite(Fout,1,Ftop,stdout);\n        }\n        #undef tc\n        #undef pc\n}F;\nclass Segment_Tree\n{\n    private:\n        struct Segment\n        {\n            int mx,tag;\n        }node[N<<2];\n        #define M(x) node[x].mx\n        #define T(x) node[x].tag\n        inline int max(CI a,CI b)\n        {\n            return a>b?a:b;\n        }\n        inline void add(CI now,CI mv)\n        {\n            M(now)+=mv; T(now)+=mv;\n        }\n        inline void pushup(CI now)\n        {\n            M(now)=max(M(now<<1),M(now<<1|1));\n        }\n        inline void pushdown(CI now)\n        {\n            if (T(now)) add(now<<1,T(now)),add(now<<1|1,T(now)),T(now)=0;\n        }\n    public:\n        #define TN CI now=1,CI l=1,CI r=n\n        inline void build(TN)\n        {\n            if (l==r) return (void)(M(now)=dep[id[l]]); int mid=l+r>>1;\n            build(now<<1,l,mid); build(now<<1|1,mid+1,r); pushup(now);\n        }\n        #define O beg,end\n        inline void modify(CI beg,CI end,CI mv,TN)\n        {\n            if (beg<=l&&r<=end) return add(now,mv); int mid=l+r>>1; pushdown(now);\n            if (beg<=mid) modify(O,mv,now<<1,l,mid); if (end>mid) modify(O,mv,now<<1|1,mid+1,r); pushup(now);\n        }\n        inline int query(CI beg,CI end,TN)\n        {\n            if (beg<=l&&r<=end) return M(now); int mid=l+r>>1,ret=0; pushdown(now);\n            if (beg<=mid) ret=max(ret,query(O,now<<1,l,mid)); if (end>mid) ret=max(ret,query(O,now<<1|1,mid+1,r)); return ret;\n        }\n        #undef TN\n        #undef O\n        #undef M\n        #undef T\n}T;\nclass Link_Cut_Tree\n{\n    private:\n        struct splay\n        {\n            int ch[2],fa;\n        }node[N];\n        #define lc(x) node[x].ch[0]\n        #define rc(x) node[x].ch[1]\n        #define fa(x) node[x].fa\n        inline void connect(CI x,CI y,CI d)\n        {\n            node[fa(x)=y].ch[d]=x;\n        }\n        inline int identify(CI now)\n        {\n            return rc(fa(now))==now;\n        }\n        inline bool isroot(CI now)\n        {\n            return lc(fa(now))!=now&&rc(fa(now))!=now;\n        }\n        inline void rotate(CI now)\n        {\n            int x=fa(now),y=fa(x),d=identify(now); if (!isroot(x)) node[y].ch[identify(x)]=now;\n            fa(now)=y; connect(node[now].ch[d^1],x,d); connect(x,now,d^1);\n        }\n        inline void splay(int now)\n        {\n            for (int t;!isroot(now);rotate(now))\n            t=fa(now),!isroot(t)&&(rotate(identify(now)!=identify(t)?now:t),0);\n        }\n        inline int findroot(int now)\n        {\n            while (lc(now)) now=lc(now); return now;\n        }\n    public:\n        inline void link(CI x,CI y)\n        {\n            fa(x)=y;\n        }\n        inline void access(int x)\n        {\n            for (int y=0,t;x;x=fa(y=x))\n            {\n                splay(x); if (rc(x)) t=findroot(rc(x)),T.modify(dfn[t],dfn[t]+size[t]-1,1);\n                if (rc(x)=y) t=findroot(rc(x)),T.modify(dfn[t],dfn[t]+size[t]-1,-1);\n            }\n        }\n        #undef lc\n        #undef rc\n        #undef fa\n}LCT;\nclass Light_Heavy_Division\n{\n    private:\n        int idx,top[N],father[N],son[N];\n        inline void swap(int& x,int& y)\n        {\n            int t=x; x=y; y=t;\n        }\n    public:\n        #define to e[i].to\n        inline void DFS1(CI now,CI fa)\n        {\n            size[now]=1; dep[now]=dep[fa]+1; father[now]=fa;\n            for (RI i=head[now];i;i=e[i].nxt) if (to!=fa)\n            {\n                DFS1(to,now); size[now]+=size[to]; LCT.link(to,now);\n                if (size[to]>size[son[now]]) son[now]=to;\n            }\n        }\n        inline void DFS2(CI now,CI tf)\n        {\n            id[dfn[now]=++idx]=now; top[now]=tf;\n            if (son[now]) DFS2(son[now],tf);\n            for (RI i=head[now];i;i=e[i].nxt)\n            if (to!=father[now]&&to!=son[now]) DFS2(to,to);\n        }\n        inline int get_LCA(int x,int y)\n        {\n            while (top[x]!=top[y])\n            {\n                if (dep[top[x]]<dep[top[y]]) swap(x,y);\n                x=father[top[x]];\n            }\n            return dep[x]<dep[y]?x:y;\n        }\n        #undef to\n}L;\ninline void add(CI x,CI y)\n{\n    e[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n}\nint main()\n{\n    //freopen(\"CODE.in\",\"r\",stdin); freopen(\"CODE.out\",\"w\",stdout);\n    RI i; for (F.read(n),F.read(m),i=1;i<n;++i) F.read(x),F.read(y),add(x,y),add(y,x);\n    for (L.DFS1(1,0),L.DFS2(1,1),T.build(),i=1;i<=m;++i)\n    {\n        F.read(opt); F.read(x); switch (opt)\n        {\n            case 1:\n                LCT.access(x); break;\n            case 2:\n                F.read(y); fa=L.get_LCA(x,y);\n                F.write(T.query(dfn[x],dfn[x])+T.query(dfn[y],dfn[y])-\n                (T.query(dfn[fa],dfn[fa])<<1)+1); break;\n            case 3:\n                F.write(T.query(dfn[x],dfn[x]+size[x]-1)); break;\n        }\n    }\n    return F.Fend(),0;\n}\n```\n\n",
        "postTime": 1550891395,
        "uid": 41698,
        "name": "hl666",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u5e7f\u544a\uff1a\u98df\u7528[$blog$](https://www.cnblogs.com/heyujun/p/10360047.html )\u4f53\u9a8c\u66f4\u4f73\n\n> \u4e00\u6b21\u53ea\u80fd\u67d3\u6839\u5230$x$\uff0c\u4e14\u67d3\u7684\u989c\u8272\u672a\u51fa\u73b0\u8fc7\n\n\u8fd9\u53e5\u8bdd\u662f\u6211\u4eec\u89e3\u9898\u7684\u5173\u952e\u3002\n\n\u8bbe$x$\u5230\u6839\u7684\u989c\u8272\u6570\u4e3a$f(x)$\uff0c\u5219$u$\u5230$v$\u7684\u989c\u8272\u6570\uff1a$f(u)+f(v)-f(lca_{u,v})+1$\n\n~~\u60f3\u4e00\u60f3\uff0c\u4e3a\u4ec0\u4e48\uff1f~~\n\n\u5f88\u663e\u7136\uff0c\u5982\u679c\u6ca1\u6709$1$\u64cd\u4f5c\uff0c\u6211\u4eec\u76f4\u63a5\u6811\u5256\u7ef4\u62a4\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4f46\u662f\u73b0\u5728\u6709\u4e86$1$\u64cd\u4f5c\u3002\u3002\u3002\n\n\u8fd9\u4e2a$1$\u64cd\u4f5c\uff0c\u5176\u5b9e\u662f\u62c9\u4e00\u6761\u4ece$x$\u5230\u6839\u7684\u94fe\uff0c\u67d3\u6210\u4e00\u79cd\u989c\u8272\n\n\u8fd9\u662f\u4e0d\u662f\u5f88\u50cf$LCT$\u7684$access$\u5462\uff1f\n\n\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u5c31\u641e\u4e00\u9897$LCT$\uff0c$access$\u65f6\uff0c\n\n\u56e0\u4e3a\u6bcf\u65ad\u4e00\u9897\u5b50\u6811\uff0c\u90a3\u68f5\u5b50\u6811\u5185\u5fc5\u7136\u8981\u591a\u52a0\u4e00\u4e2a\u989c\u8272\u6bb5\u5c31\u662f\u4e00\u4e2a\u5b50\u6811\u52a0\uff0c\n\n\u6bcf\u8fde\u4e0a\u4e00\u9897\u5b50\u6811\uff0c\u90a3\u68f5\u5b50\u6811\u5185\u5fc5\u7136\u91cd\u590d\u4e00\u4e2a\u989c\u8272\u6bb5\u5c31\u662f\u4e00\u4e2a\u5b50\u6811\u51cf\u3002\n\n\u90a3\u4e48\u6211\u4eec\u7528\u6811\u5256\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u7684$f(x)$\n\n\u5e76\u9b54\u6539\u4e00\u4e0b$access$\u5373\u53ef\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 1e5 + 5; \nstruct Graph { int to, next; } e[MAX_N << 1]; int fir[MAX_N], e_cnt; \nvoid clearGraph() { memset(fir, -1, sizeof(fir)); e_cnt = 0; } \nvoid Add_Edge(int u, int v) { e[e_cnt] = (Graph){v, fir[u]}, fir[u] = e_cnt++; } \nint N, M; \nint dfn[MAX_N], L[MAX_N], R[MAX_N], top[MAX_N]; \nint dep[MAX_N], fa[MAX_N], son[MAX_N], size[MAX_N], tim; \nvoid dfs1(int x) { \n\tdep[x] = dep[fa[x]] + 1, size[x] = 1; \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; if (v == fa[x]) continue; \n\t\tfa[v] = x; dfs1(v); size[x] += size[v]; \n\t\tif (size[son[x]] < size[v]) son[x] = v; \n\t} \n} \nvoid dfs2(int x, int tp) { \n\ttop[x] = tp, L[x] = ++tim, dfn[tim] = x; \n\tif (son[x]) dfs2(son[x], tp); \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; if (v == fa[x] || v == son[x]) continue; \n\t\tdfs2(v, v); \n\t} \n\tR[x] = tim; \n}\nint LCA(int x, int y) {\n\twhile (top[x] != top[y]) { \n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\tx = fa[top[x]]; \n\t} \n\treturn dep[x] < dep[y] ? x : y; \n} \n#define lson (o << 1) \n#define rson (o << 1 | 1) \nint val[MAX_N << 2], tag[MAX_N << 2];\nvoid pushup(int o) { val[o] = max(val[lson], val[rson]); } \nvoid puttag(int o, int v) { tag[o] += v; val[o] += v; } \nvoid pushdown(int o, int l, int r) {\n\tif (l == r || !tag[o]) return ; \n\tputtag(lson, tag[o]); \n\tputtag(rson, tag[o]); \n\ttag[o] = 0; \n} \nvoid build(int o, int l, int r) { \n\tif (l == r) return (void)(val[o] = dep[dfn[l]]); \n\tint mid = (l + r) >> 1; \n\tbuild(lson, l, mid), build(rson, mid + 1, r); \n\tpushup(o); \n} \nvoid modify(int o, int l, int r, int ql, int qr, int v) {  \n\tif (ql <= l && r <= qr) return (void)(puttag(o, v)); \n\tpushdown(o, l, r); \n\tint mid = (l + r) >> 1; \n\tif (ql <= mid) modify(lson, l, mid, ql, qr, v);\n\tif (qr > mid) modify(rson, mid + 1, r, ql, qr, v); \n\tpushup(o); \n} \nint query(int o, int l, int r, int ql, int qr) { \n\tpushdown(o, l, r); \n\tif (ql <= l && r <= qr) return val[o]; \n\tint mid = (l + r) >> 1, res = 0; \n\tif (ql <= mid) res = max(res, query(lson, l, mid, ql, qr)); \n\tif (qr > mid) res = max(res, query(rson, mid + 1, r, ql, qr));\n\treturn res; \n} \n\nstruct Node { int ch[2], fa; bool rev; } t[MAX_N]; \nbool get(int x) { return t[t[x].fa].ch[1] == x; } \nbool nroot(int x) { return t[t[x].fa].ch[0] == x || t[t[x].fa].ch[1] == x; } \nvoid rotate(int x) { \n\tint y = t[x].fa, z = t[y].fa, k = get(x); \n\tif (nroot(y)) t[z].ch[get(y)] = x; \n\tt[x].fa = z; \n\tt[t[x].ch[k ^ 1]].fa = y, t[y].ch[k] = t[x].ch[k ^ 1]; \n\tt[y].fa = x, t[x].ch[k ^ 1] = y; \n} \nvoid splay(int x) { \n\twhile (nroot(x)) { \n\t\tint y = t[x].fa; \n\t\tif (nroot(y)) get(x) ^ get(y) ? rotate(x) : rotate(y);\n\t\trotate(x); \n\t} \n} \nint findroot(int x) { while (t[x].ch[0]) x = t[x].ch[0]; return x; } \nvoid access(int x) { \n\tfor (int y = 0; x; y = x, x = t[x].fa) { \n\t\tsplay(x); \n\t\tif (t[x].ch[1]) {\n\t\t\tint rt = findroot(t[x].ch[1]);\n\t\t\tmodify(1, 1, N, L[rt], R[rt], 1); \n\t\t}\n\t\tt[x].ch[1] = y; \n\t\tif (t[x].ch[1]) {\n\t\t\tint rt = findroot(t[x].ch[1]); \n\t\t\tmodify(1, 1, N, L[rt], R[rt], -1); \n\t\t} \n\t} \n} \n\nint main () { \n\tclearGraph(); \n\tN = gi(), M = gi(); \n\tfor (int i = 1; i < N; i++) {\n\t\tint u = gi(), v = gi(); \n\t\tAdd_Edge(u, v); \n\t\tAdd_Edge(v, u); \n\t} \n\tdfs1(1), dfs2(1, 1); \n\tfor (int x = 2; x <= N; x++) t[x].fa = fa[x]; \n\tbuild(1, 1, N);\n\t\n\twhile (M--) { \n\t\tint op = gi(); \n\t\tif (op == 1) access(gi()); \n\t\tif (op == 2) {\n\t\t\tint u = gi(), v = gi(), lca = LCA(u, v); \n\t\t\tprintf(\"%d\\n\", query(1, 1, N, L[u], L[u]) + query(1, 1, N, L[v], L[v]) \n\t\t\t\t- 2 * query(1, 1, N, L[lca], L[lca]) + 1); \n\t\t} \n\t\tif (op == 3) {\n\t\t\tint x = gi(); \n\t\t\tprintf(\"%d\\n\", query(1, 1, N, L[x], R[x])); \n\t\t} \n\t} \n\treturn 0; \n} \n```",
        "postTime": 1550385967,
        "uid": 42506,
        "name": "\u4f55\u4fde\u5747",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u5176\u5b9e\u4e25\u683c\u6765\u8bb2\u8fd9\u9053\u9898\u5e76\u4e0d\u662flct?\n\n(\u4f46\u662f\u601d\u8def\u4e0a\u8fd8\u662flct\u7684\u601d\u8def\u5c31\u5bf9\u4e86\uff0c\u53cd\u6b63\u6700\u540e\u5b9e\u73b0\u7684\u65f6\u5019\u4e00\u4e2asplay\u5c31\u591f\u4e86)\n\n\u719f\u7ec3\u538b\u884c\u7684\u8bdd\u767e\u884c\u4ee5\u5185\u53ef\u4ee5\u5199\u5b8c\uff1f\n\n(\u98df\u7528\u672c\u9898\u89e3\u65f6\u8bf7\u786e\u4fdd\u60a8\u7406\u89e3lct\u91cc\u7684\u8f7b\u91cd\u8fb9\u6982\u5ff5\uff0c\u4f46\u662f\u5e76\u4e0d\u9700\u8981\u719f\u7ec3\u638c\u63e1lct)\n\n~~(\u4ec0\u4e48\u4f60\u4e0d\u77e5\u9053\u4ec0\u4e48\u662f\u8f7b\u91cd\u8fb9\uff1f\u51fa\u95e8\u5de6\u8f6c\u4f60\u7ad9\u819c\u677f\u533a\uff0c\u5305\u6559\u5305\u4f1a)~~\n\n# \u672c\u9898\u9898\u89e3\n\n\u663e\u7136\u8fd9\u662f\u4e00\u9053\u6570\u636e\u7ed3\u6784\u9898\uff0c\u6240\u4ee5\u8ba9\u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0b\u8d44\u74f7\u4ec0\u4e48\u64cd\u4f5c\n\n1.\u6811\u4e0a\u67d3\u8272\n\n2.\u6811\u4e0a\u8be2\u95ee\u989c\u8272\u6570\u91cf\n\n3.\u5b50\u6811\u8be2\u95ee\u5185\u989c\u8272\u6700\u5927\u503c(\u663e\u7136\u5b50\u6811\u5185\u7684\u6240\u6709\u70b9\u5728\u5b50\u6811\u8fc7\u4e86\u5b50\u6811\u6839\u4e4b\u540e\u8def\u5f84\u5b8c\u5168\u4e00\u6837\uff0c\u6240\u4ee5\u53ef\u4ee5\u53ea\u8003\u8651\u5230\u6839\u7684\u989c\u8272\u4e2a\u6570)\n\n\u90a3\u4e48\u6211\u4eec\u4f1a\u53d1\u73b0\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u6027\u8d28\uff0c\u56e0\u4e3a\u662f\u5230\u6839\u8282\u70b9\u8def\u5f84\u67d3\u8272\uff0c\u6240\u4ee5\u76f8\u540c\u989c\u8272\u7684\u70b9\u5fc5\u5b9a\u5728\u540c\u4e00\u4e2a\u8054\u901a\u5757\u5185\uff0c(\u4e5f\u5c31\u662f\u8bf4\u4e0d\u4f1a\u6709\u4e24\u6bb5\u5206\u5f00\u7684\u989c\u8272)\n\n\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8f6c\u5316\u4e00\u4e0b\u95ee\u9898\uff0c\u8def\u5f84\u4e0a\u7684\u989c\u8272\u6570\u76ee=\u8def\u5f84\u4e0a\u7684\u5206\u5272\u8fb9\u6570+1\n\n(\u8fd9\u91cc\u6307\u7684\u5206\u5272\u8fb9\u662f\u6307\u8fd9\u4e2a\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u989c\u8272\u4e0d\u540c)\n\n\u90a3\u4e48\u6211\u4eec\u4f1a\u53d1\u73b0\u5176\u5b9e\u5982\u679c\u628a1\u64cd\u4f5c\u770b\u6210lct\u7684access\u64cd\u4f5c\uff0c\u90a3\u4e48\u6211\u4eec\u7684\u201c\u5206\u5272\u8fb9\u201d\u5176\u5b9e\u5c31\u662flct\u4e2d\u7684\u8f7b\u8fb9\n\n\u6240\u4ee5\u6211\u4eec\u73b0\u5728\u8981\u8d44\u74f7\u7684\u64cd\u4f5c\u5c31\u662f\u8be2\u95ee\u8f7b\u8fb9\u6570\u91cf\uff1f\n\n\u90a3\u4e48\u770b\u4e00\u4e0b\u8f6c\u6362\u540e\u7684\u64cd\u4f5c\n\n1.access\n\n2.\u8be2\u95ee\u8def\u5f84\u4e0a\u8f7b\u8fb9\u6570\u91cf\n\n3.\u8be2\u95ee\u5230\u6839\u8282\u70b9\u8f7b\u8fb9\u6570\u91cf\u6700\u5927\n\n\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u73b0\u5728\u7ef4\u62a4\u7684\u4e1c\u897f\u662f\u8fb9\u800c\u4e0d\u662f\u70b9\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u662f\u70b9\u7684\u8bdd\u5728\u8be2\u95ee\nu\u5230v\u7684\u8def\u5f84\u4fe1\u606f\u65f6\u91c7\u7528$ u+v-2lca(u,v)$\u7684\u65b9\u5f0f\u662f\u4f1a\u6f0f\u7b97lca\u8fd9\u4e2a\u70b9\u7684\uff0c\u4f46\u662f\u5982\u679c\u662f\u8fb9\u7684\u8bdd\u5c31\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528$u+v-2lca(u,v)$\u8fd9\u4e2a\u5f0f\u5b50\u4e86\uff0c\u56e0\u4e3a\u5404\u4e2a\u8def\u5f84\u7684\u8fb9\u662f\u4e0d\u76f8\n\u4ea4\u7684\n\n\u6240\u4ee5\u8bf4\u6211\u4eec\u60f3\u77e5\u9053x\u5230y\u7684\u8def\u5f84\u4e0a\u6709\u591a\u5c11\u6761\u8f7b\u8fb9,\u53ea\u9700\u8981\u77e5\u9053x\u52301\u6709\u591a\u5c11\u6761\u8f7b\u8fb9\uff0cy\u52301\u6709\u591a\u5c11\u6761\u8f7b\u8fb9\uff0c\u548cx\uff0cy\u7684lca\u6709\u591a\u5c11\u6761\u8f7b\u8fb9\u7136\u540e$u+v-2lca(u,v)$\u5c31\u884c\u4e86\n\n(\u4e0b\u6587\u4e2d\u7684\u201d\u8f7b\u8fb9\u6570\u91cf\u201c\u4ee3\u6307\u67d0\u4e2a\u70b9\u52301\u8def\u5f84\u4e0a\u7684\u8f7b\u8fb9\u6570\u91cf)\n\n\u4e00\u5f00\u59cb\u8fd9\u4e2a\u6811\u5168\u90e8\u662f\u8f7b\u8fb9\uff0c\u6240\u4ee5\u6bcf\u4e2a\u70b9\u7684\u8f7b\u8fb9\u6570\u91cf\u5c31\u7b49\u4e8e\u8fd9\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\n\n\u6211\u4eec\u53d1\u73b0\u5f53\u4e00\u4e2a\u8f7b\u8fb9\u53d8\u6210\u91cd\u8fb9\u7684\u65f6\u5019\uff0c\u4ee5\u8f7b\u8fb9\u5e95\u90e8\u7684\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u8f7b\u8fb9\u6570\u91cf-1\n\n\u5f53\u4e00\u4e2a\u91cd\u8fb9\u53d8\u6210\u8f7b\u8fb9\u7684\u65f6\u5019\uff0c\u4ee5\u91cd\u8fb9\u5e95\u90e8\u7684\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u8f7b\u8fb9\u6570\u91cf+1\n\n\u552f\u4e00\u7684\u95ee\u9898\u53d8\u6210\u4e86\u5982\u4f55\u5728\u6811\u4e0a\u627e\u5230\u6240\u6709\u7684\u8f7b\u8fb9(\u54a6\u8fd9\u8bdd\u6211\u597d\u50cf\u5728\u54ea\u91cc\u89c1\u8fc7)\n\n\u7136\u540e\u6211\u4eec\u662f\u53ef\u4ee5lct\u66b4\u529b\u7ef4\u62a4\u8f7b\u8fb9\u7684\uff0c\u6839\u636elct\u7684\u590d\u6742\u5ea6\u8bc1\u660e\uff0c\u6211\u4eec\u6700\u591a\u4fee\u6539nlogn\u6761\u8f7b\u8fb9\uff0c\u6240\u4ee5\u6bcf\u6b21\u78b0\u5230\u4e00\u6b21\u8f7b\u91cd\u5207\u6362\u5c31\u5728\u7ebf\u6bb5\u6811\u4e0a\u66b4\u529b\u4fee\u6539\u5373\u53ef\uff0c(\u5b50\u6811\u95ee\u9898\u53ef\u4ee5\u901a\u8fc7dfs\u62cd\u5e73\u8f6c\u6362\u4e3a\u5e8f\u5217\u95ee\u9898)\n\n(\u6216\u8005\u94fe\u5256\u4e4b\u540e\u7ebf\u6bb5\u6811/\u6811\u72b6\u6570\u7ec4\u4e0a\u4e8c\u5206\u6ca1\u51c6\u4e5f\u53ef\u4ee5\uff1f)\n\n\u7531\u4e8e\u6211\u4eec\u53ea\u4f1a\u8fdb\u884cnlogn\u6b21\u4fee\u6539\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6\u662f$O(nlog^2n)$\u7684\n\n\u5bf9\u4e8e\u64cd\u4f5c3\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u533a\u95f4\u6700\u5927\u503c\u95ee\u9898(\u56e0\u4e3a\u6211\u4eec\u7ef4\u62a4\u7684\u5c31\u662f\u5230\u6839\u8282\u70b9\u7684\u8f7b\u8fb9\u6570\u91cf)\n\n\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5199\u4e00\u4e2a\u8d44\u74f7\u533a\u95f4\u52a0\u548c\u67e5\u533a\u95f4\u6700\u5927\u503c\u7684\u7ebf\u6bb5\u6811(\u5355\u70b9\u67e5\u503c\u5c31\u662f\u533a\u95f4\u6700\u5927\u503c233)\u548c\u4e00\u4e2a\u500d\u589e\u627elca\n\n\u7136\u540e\u4e0b\u9762\u7b80\u5355\u4ecb\u7ecd\u4e00\u4e0b\u5982\u4f55\u5feb\u901f\u627e\u5230\u6240\u6709\u7684\u8f7b\u8fb9\n\n\u663e\u7136\u6211\u4eec\u5728\u6267\u884caccess\u64cd\u4f5c\u7684\u65f6\u5019\u53ea\u4f1a\u628a\u94fe\u4e0a\u7684\u8fb9\u53d8\u6210\u91cd\u8fb9\n\n\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u628a\u5728\u540c\u4e00\u4e2a\u91cd\u94fe\u91cc\u7684\u70b9\u770b\u6210\u4e00\u4e2a\u96c6\u5408\uff0c\u5728\u96c6\u5408\u91cc\u6309\u6df1\u5ea6\u6392\u5e8f\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e0d\u505c\u7684\u96c6\u5408\u7684\u6700\u5c0f\u503c\uff0c\u7136\u540e\u8fd9\u4e2a\u6700\u5c0f\u503c\u548c\u6700\u5c0f\u503c\u7684father\u5c31\u4f1a\u6784\u4e00\u4e2a\u8f7b\u8fb9\u4e86\uff0c\u5f53\u7136\u6211\u4eec\u8fd8\u9700\u8981\u8fdb\u884c\u4e00\u4e9b\u65ad\u5f00\u548c\u5408\u5e76\u96c6\u5408\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u8f7b\u8fb9\u91cd\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff0c\u91cd\u53d8\u8f7b\u5c06\u4e00\u4e2a\u96c6\u5408\u5206\u88c2\u4e3a\u4e24\u4e2a\u96c6\u5408\n\n\u56e0\u6b64\u8fd9\u9700\u8981\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a**\u53ef\u5206\u88c2\u5408\u5e76\u5806**\uff0cemm\u2026\u2026\u4e5f\u5c31\u662fsplay,(\u6216\u8005\u53ef\u4ee5\u5c1d\u8bd5\u4e0bsplit-merge-treap\uff1f)\u7136\u540e\u5c31\u53ef\u4ee5\u4e00\u8def\u66b4\u529b\u8df3\u8f7b\u8fb9\u67e5\u627e\u4e86\n\n\u4ee3\u7801\u7684\u8bdd\u8111\u5b50\u6e05\u695a\u8fd8\u662f\u5f88\u597d\u5199\u7684\uff0c\u4f46\u662f\u5982\u679c\u903b\u8f91\u6df7\u4e71\u7684\u8bdd\u5c31\u975e\u5e38\u4e0d\u597d\u5199\u4e86\n\n\u5177\u4f53\u53ef\u4ee5\u770b\u6ce8\u91ca\u52a0\u6df1\u7406\u89e3\n\n\u4e0a\u4ee3\u7801~\n\n```C\n#include<cstdio>\n#include<algorithm>\nusing namespace std;const int N=1e5+10;\nint n;int m;int dfn[N];int nfd[N];int siz[N];int df;int f[N][22];\nint v[2*N];int x[2*N];int al[N];int ct;int dep[N];int h[N];\nstruct splaytree//\u538b\u884c\u540e\u7684splay \n{\n\tint s[N][2];int fa[N];\n\tinline int gc(int x){return s[fa[x]][1]==x;}//\u68c0\u67e5\u5de6\u53f3\u513f\u5b50 \n\tinline void rt(int x)//\u4e8c\u5408\u4e00\u65cb\u8f6c \n\t{\n\t\tint d=fa[x];int t=gc(x);s[d][t]=s[x][t^1];fa[s[x][t^1]]=d;\n\t\ts[fa[d]][gc(d)]=x;fa[x]=fa[d];s[x][t^1]=d;fa[d]=x;\n\t}\n\tinline void rtup(int x){rt((gc(x)^gc(fa[x]))?x:fa[x]);rt(x);}//\u53cc\u65cb \n\tinline void splay(int x){for(;fa[fa[x]]&&fa[x];rtup(x));if(fa[x])rt(x);}//splay \n\tinline int mi(int x){for(;s[x][0];x=s[x][0]);return x;}//\u6700\u5c0f\u503c \n\tinline int getmi(int x){splay(x);return mi(x);}//\u67e5\u627e\u6700\u5c0f\u503c \n\tinline void split(int x){splay(x);fa[s[x][1]]=0;s[x][1]=0;}//\u5206\u88c2 \n\tinline void merge(int x,int y){splay(y);s[x][0]=y;fa[y]=x;}//\u5408\u5e76 \n}spt;\nstruct linetree//\u7ebf\u6bb5\u6811 \n{\n\tint add[4*N];int ma[4*N];\n\tinline void pushdown(int p)//pushdown \n\t{add[p<<1]+=add[p];add[p<<1|1]+=add[p];ma[p<<1]+=add[p];ma[p<<1|1]+=add[p];add[p]=0;}\n\tinline void setadd(int p,int l,int r,int dl,int dr,int plus)//\u533a\u95f4\u52a0 \n\t{\n\t\tif(dl==l&&dr==r){add[p]+=plus;ma[p]+=plus;return;}\n\t\tint mid=(l+r)/2;pushdown(p);\n\t\tif(dl<mid){setadd(p<<1,l,mid,dl,min(dr,mid),plus);}\n\t\tif(mid<dr){setadd(p<<1|1,mid,r,max(dl,mid),dr,plus);}\n\t\tma[p]=max(ma[p<<1],ma[p<<1|1]);\n\t}\n\tinline int gmax(int p,int l,int r,int dl,int dr)//\u67e5\u6700\u5927\u503c \n\t{\n\t\tif(dl==l&&dr==r){return ma[p];}\n\t\tint mid=(l+r)/2;pushdown(p);int res=-0x3f3f3f3f;\n\t\tif(dl<mid){res=max(res,gmax(p<<1,l,mid,dl,min(dr,mid)));}\n\t\tif(mid<dr){res=max(res,gmax(p<<1|1,mid,r,max(dl,mid),dr));}\n\t\treturn res;\n\t}\n\tinline void build(int p,int l,int r)//\u5efa\u6811 \n\t{\n\t\tif(r-l==1){ma[p]=dep[dfn[r]];return;}int mid=(l+r)/2;\n\t\tbuild(p<<1,l,mid);build(p<<1|1,mid,r);ma[p]=max(ma[p<<1],ma[p<<1|1]);\n\t}\n}lt;\ninline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}//\u52a0\u8fb9 \ninline void dfs(int u)//dfs\u5904\u7406\u500d\u589elca\u548cdfs\u5e8f \n{\n\tsiz[u]=1;dfn[++df]=u;nfd[u]=df;//\u500d\u589e \n\tfor(int i=0;f[u][i];i++){f[u][i+1]=f[f[u][i]][i];}\n\tfor(int i=al[u];i;i=x[i]) \n\t{\t\n\t\tif(siz[v[i]]){continue;}\n\t\tf[v[i]][0]=u;dep[v[i]]=dep[u]+1;dfs(v[i]);siz[u]+=siz[v[i]];\n\t}\t\n}\ninline int lca(int u,int v)//\u67e5lca \n{\n\tif(dep[u]<dep[v]){swap(u,v);}int d=dep[u]-dep[v];\n\tfor(int i=0;d;d>>=1,i++){if(d&1){u=f[u][i];}}if(u==v){return v;}\n\tfor(int i=20;i>=0;i--){if(f[u][i]!=f[v][i]){u=f[u][i];v=f[v][i];}}\n\treturn f[u][0];\n}\ninline void modify(int u)//\u4fee\u6539 \n{\n\tif(h[u]){lt.setadd(1,0,n,nfd[h[u]]-1,nfd[h[u]]+siz[h[u]]-1,1);spt.split(u);h[u]=0;}\n\tfor(u=spt.getmi(u);u!=1;u=spt.mi(f[u][0]))//\u6ce8\u610f\u5148\u5206\u88c2\u5f85\u4fee\u6539\u70b9 \n\t{\n\t\tint& d=f[u][0];//\u7136\u540e\u5148\u65ad\u5f00\u91cd\u513f\u5b50\u518d\u5408\u5e76\u65b0\u7684\u91cd\u513f\u5b50\uff0c\u540c\u65f6\u5728\u7ebf\u6bb5\u6811\u4e0a\u4fee\u6539 \n\t\tif(h[d]){lt.setadd(1,0,n,nfd[h[d]]-1,nfd[h[d]]+siz[h[d]]-1,1);spt.split(d);}\n\t\tlt.setadd(1,0,n,nfd[u]-1,nfd[u]+siz[u]-1,-1);spt.merge(u,d);h[d]=u;\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);int tp;int u;int v;\n\tfor(int i=1;i<n;i++){scanf(\"%d%d\",&u,&v);add(u,v);add(v,u);}\n\tdfs(1);lt.build(1,0,n);//\u9884\u5904\u7406 \n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&tp,&u);if(tp==1){modify(u);}//\u4fee\u6539 \n\t\telse if(tp==2)//\u67e5\u627e\u70b9\u503c\u7136\u540e\u51cf\u53bb \n\t\t{\n\t\t\tscanf(\"%d\",&v);int l=lca(u,v);\n\t\t\tint du=lt.gmax(1,0,n,nfd[u]-1,nfd[u]);\n\t\t\tint dv=lt.gmax(1,0,n,nfd[v]-1,nfd[v]);\n\t\t\tint dl=lt.gmax(1,0,n,nfd[l]-1,nfd[l]);\n\t\t\tprintf(\"%d\\n\",du+dv-2*dl+1);\n\t\t}else {printf(\"%d\\n\",lt.gmax(1,0,n,nfd[u]-1,nfd[u]+siz[u]-1)+1);}//\u533a\u95f4\u6700\u5927\u503c \n\t}return 0;//\u62dc\u62dc\u7a0b\u5e8f~ \n}\n```",
        "postTime": 1522476542,
        "uid": 56384,
        "name": "shadowice1984",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u6076\u5fc3\u9898~~\u4e3a\u4ec0\u4e48SD\u5149\u51fa\u8fd9\u79cd\u9898~~\u3002\u3002\u3002\n\n\u603b\u7684\u6765\u8bf4\u5c31\u662fLCT+\u6811\u94fe\u5256\u5206+\u6811\u4e0a\u5dee\u5206\n\n\u5148\u4e0d\u7ba1\u64cd\u4f5c1\n\n\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u8003\u8651\u6811\u4e0a\u5dee\u5206\uff0c\u8bbes[i]\u4e3ai\u70b9\u5230\u6839\u7684\u6743\u503c\u548c\uff0c\u5219\u7b54\u6848\u5c31\u662fs[x]+s[y]-s[lca(x,y)]*2+1\uff08\u591a\u51cf\u4e861\u4e2alca\u6240\u4ee5+1\uff09\n\n\u90a3\u4e48\u6bcf\u4e2a\u70b9\u7684\u521d\u59cb\u503c\u5c31\u662fta\u7684\u6df1\u5ea6\uff08\u56e0\u4e3a\u5f00\u59cb\u6bcf\u4e2a\u70b9\u989c\u8272\u90fd\u4e0d\u4e00\u6837\uff09\n\n\u53d1\u73b0\u4e0a\u9762\u7684\u5173\u7cfb\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206\u6765\u89e3\u51b3\n\n\u6c42\u51falca\u540e\u5355\u70b9\u67e5\u8be2x\uff0cy\uff0clca\u7684\u6743\u503c\u5c31\u53ef\u4ee5\u89e3\u51b3\u64cd\u4f5c2\n\n\u64cd\u4f5c3\u6c42\u5b50\u6811\u6700\u5927\u503c\u4e5f\u662f\u6811\u94fe\u5256\u5206\u7684\u57fa\u672c\u64cd\u4f5c\n\n\u4e3b\u8981\u95ee\u9898\u662f\u64cd\u4f5c1\n\n\u64cd\u4f5c1\u5c31\u5f88\u5999\u4e86\uff0c\u5229\u7528\u4e86\u4e00\u4e2a\u6027\u8d28\uff1a\uff08\u4ee5\u4e0b\u6ce8\u610f\u94fe\u548c\u8fb9\u7684\u533a\u5206\uff09\n\n**LCT\u4e2d\u5b9e\u94fe\u6570\u91cf\uff08\u5373splay\u7684\u6570\u91cf\uff09=\u865a\u8fb9\u6570\u91cf+1**\n\n\u6211\u4eec\u628a\u540c\u4e00\u989c\u8272\u7684\u70b9\u653e\u57281\u4e2asplay\u91cc\n\n\u7531\u64cd\u4f5c\u53ef\u5f97\uff0cLCT\u4e2d\u70b9i\u5230\u6839\u8282\u70b9\u6709\u591a\u5c11\u5b9e\u94fes[i]\u5c31\u662f\u591a\u5c11\n\n\u6240\u4ee5access\u5c06\u51e0\u4e2asplay\u8fde\u62101\u4e2asplay\uff0c\u6b63\u597d\u5bf9\u5e94\u7740\u7528\u540c\u4e00\u79cd\u989c\u8272\u8986\u76d6\u8def\u5f84\n\n\u7136\u540eaccess\u7684\u65f6\u5019\u5982\u679c\u4e00\u6761\u8fb9\u7531\u865a\u53d8\u5b9e\uff08\u5373\u865a\u8fb9\u51cf\u5c11\uff09\uff0c\u8fd9\u6761\u8fb9\u8fde\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\u7684\u5b50\u6811\u6bcf\u4e2a\u70b9\u7684s-1\n\n\u5982\u679c\u4e00\u6761\u8fb9\u7531\u5b9e\u53d8\u865a\uff08\u5373\u865a\u8fb9\u589e\u52a0\uff09\uff0c\u8fd9\u6761\u8fb9\u8fde\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\u7684\u5b50\u6811\u6bcf\u4e2a\u70b9\u7684s+1\n\n\u5982\u56fe\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/15866.png)\n\n\u8bbe6\u53f7\u70b9\u4e3a\u6839\uff0c\u56fe\u4e2d\u7ea2\u8272\u865a\u8fb9\u8981\u53d8\u6210\u5b9e\u8fb9\uff0c\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9\u662f5\uff084\u53f7\u7ea2\u8fb9\u600e\u4e48\u53d8\u8ddfta\u6ca1\u5173\u7cfb\uff09\n\n5\u70b9\u7684\u76f8\u8fde\u7684**\u5b9e\u94fe**\u5408\u5e76\u4e86\uff0c\u4f46\u5230\u6839\u8282\u70b9\u7684\u5b9e\u94fe\u603b\u6570\u6ca1\u53d8\uff0c\u6240\u4ee5\u5bf9\u5e94\u7684s\u4e0d\u53d8\n\n1\u30012\u30013\u70b9\u5230\u6839\u7684\u5b9e\u94fe\u5408\u5e76\u4e86\uff0c\u5230\u6839\u8282\u70b9\u7684\u5b9e\u94fe\u603b\u6570-1\uff0c\u6240\u4ee5\u5bf9\u5e94\u7684s-1\n\n\u5b9e\u53d8\u865a\u540c\u7406~~\u81ea\u5df1yy\u5373\u53ef~~\n\n\u6240\u4ee5access\u65f6\u8981\u52a0\u4e0a\u6811\u94fe\u5256\u5206\u7684\u533a\u95f4\u4fee\u6539\u64cd\u4f5c\n\n\u8fd8\u6709LCT\u4e2d\u8981\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u5728\u6811\u4e2d\u6700\u5de6\u513f\u5b50\u7684\u7f16\u53f7\u7528\u4ee5\u4fee\u6539\u533a\u95f4\uff08\u5373\u4ee3\u7801\u4e2dLCT\u7684w[i]\uff09\n\n\u4e8e\u662f\u8fd9\u9053~~\u6bd2\u7624+\u7801\u519c~~\u9898\u5c31\u89e3\u51b3\u4e86\n```\n# include<iostream>\n# include<cstring>\n# include<cstdio>\n# include<cstdlib>\n# define mid (l+r>>1)\n# define tl (k<<1)\n# define tr (k<<1|1)\nusing namespace std;\nconst int MAX=1e5+1;\nstruct p{\n    int x,y;\n}c[MAX<<1];\nint n,m,num,cnt,tot,rt;\nint h[MAX],ID[MAX],top[MAX],d[MAX],fa[MAX],son[MAX],siz[MAX];\nstruct Segment_Tree{\n    struct q{\n        int x,lazy;\n    }s[MAX<<2];\n    void pus(int k)\n    {\n        s[k].x=max(s[tl].x,s[tr].x);\n    }\n    void down(int k)\n    {\n        int f=s[k].lazy;\n        s[k].lazy=0;\n        if(!f) return;\n        s[tl].lazy+=f,s[tr].lazy+=f;\n        s[tl].x+=f,s[tr].x+=f;\n    }\n    void change(int l,int r,int k,int L,int R,int dis)\n    {\n        if(l==L&&r==R)\n        {\n            s[k].x+=dis,s[k].lazy+=dis;\n            return;\n        }\n        down(k);\n        if(R<=mid) change(l,mid,tl,L,R,dis);\n        else if(L>mid) change(mid+1,r,tr,L,R,dis);\n        else\n        {\n            change(l,mid,tl,L,mid,dis);\n            change(mid+1,r,tr,mid+1,R,dis);\n        }\n        pus(k);\n    }\n    void change1(int l,int r,int k,int x,int dis)\n    {\n        if(l==r)\n        {\n            s[k].x+=dis;\n            return;\n        }\n        down(k);\n        if(x<=mid) change1(l,mid,tl,x,dis);\n        else change1(mid+1,r,tr,x,dis);\n        pus(k);\n    }\n    int ask(int l,int r,int k,int L,int R)\n    {\n        if(l==L&&r==R)\n        return s[k].x;\n        down(k);\n        if(R<=mid) return ask(l,mid,tl,L,R);\n        else if(L>mid) return ask(mid+1,r,tr,L,R);\n        else return max(ask(l,mid,tl,L,mid),ask(mid+1,r,tr,mid+1,R));\n    }\n    int ask1(int l,int r,int k,int x)\n    {\n        if(l==r) return s[k].x;\n        down(k);\n        if(x<=mid) return ask1(l,mid,tl,x);\n        else return ask1(mid+1,r,tr,x);\n    }\n}Tree1;\nstruct Link_Cut_Tree{\n    int fa[MAX],w[MAX];\n    int son[MAX][2];\n    bool fl[MAX];\n    bool is_root(int x)\n    {\n        return son[fa[x]][1]!=x&&son[fa[x]][0]!=x;\n    }\n    bool id(int x)\n    {\n        return son[fa[x]][0]==x?0:1;\n    }\n    void pus(int x)\n    {\n        if(son[x][0]) w[x]=w[son[x][0]]; \n        else w[x]=x;\n    }\n    void down(int x)\n    {\n        if(x&&fl[x])\n        {\n            if(son[x][1]) fl[son[x][1]]^=1;\n            if(son[x][0]) fl[son[x][0]]^=1;\n            swap(son[x][1],son[x][0]);\n            fl[x]=0;\n        }\n    }\n    void rot(int x)\n    {\n        int y=fa[x],z=fa[y],k=id(x);\n        if(!is_root(y)) son[z][id(y)]=x;\n        son[y][k]=son[x][k^1],fa[son[y][k]]=y;\n        son[x][k^1]=y,fa[y]=x;\n        fa[x]=z;\n        pus(y),pus(x);\n    }\n    void PUS(int x)\n    {\n        if(!is_root(x)) PUS(fa[x]);\n        down(x);\n    }\n    void splay(int x)\n    {\n        PUS(x);\n        for(int y;!is_root(x);rot(x))\n          if(!is_root(y=fa[x]))\n          rot(id(x)==id(y)?y:x);\n    }\n    void access(int x)\n    {\n        for(int y=0;x;y=x,x=fa[x])\n          {\n          \tsplay(x);\n          \tint hh=w[son[x][1]];\n          \tif(son[x][1]) Tree1.change(1,n,1,ID[hh],ID[hh]+siz[hh]-1,1);\n          \thh=w[y];\n            if(y) Tree1.change(1,n,1,ID[hh],ID[hh]+siz[hh]-1,-1);\n            son[x][1]=y;\n            if(y) fa[y]=x;\n          }\n    }\n}Tree2;\nvoid add(int x,int y)\n{\n    c[++num]=(p){h[x],y};h[x]=num;\n    c[++num]=(p){h[y],x},h[y]=num;\n}\nvoid dfs(int x,int f)\n{\n    fa[x]=f,d[x]=d[f]+1,siz[x]=1;\n    for(int i=h[x];i;i=c[i].x)\n      {\n      \tint y=c[i].y;\n      \tif(y==f) continue;\n      \tdfs(y,x);\n      \tsiz[x]+=siz[y];\n        if(siz[y]>siz[son[x]]) son[x]=y;\n      }\n}\nvoid dfs1(int x,int tp)\n{\n    top[x]=tp,ID[x]=++cnt;\n    if(son[x]) dfs1(son[x],tp);\n    else return;\n    for(int i=h[x];i;i=c[i].x)\n      {\n      \tint y=c[i].y;\n      \tif(y==fa[x]||y==son[x]) continue;\n      \tdfs1(y,y);\n      }\n}\nint LCA(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(d[top[x]]<d[top[y]]) swap(x,y);\n        x=fa[top[x]];\n    }\n    if(d[x]>d[y]) swap(x,y);\n    return x;\n}\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    for(;!isdigit(ch);f=(ch=='-')?-1:1,ch=getchar());\n    for(;isdigit(ch);x=x*10+ch-48,ch=getchar());\n    return x*f;\n}\nint main()\n{\n    n=read(),m=read();\n    for(int i=1;i<n;i++)\n      {\n      \tint x=read(),y=read();\n      \tadd(x,y);\n      }\n    dfs(1,0);\n    dfs1(1,1);\n    for(int i=1;i<=n;i++)\n      {\n      \tTree1.change1(1,n,1,ID[i],d[i]);\n      \tTree2.w[i]=i,Tree2.fa[i]=fa[i];\n      }\n    for(int i=1;i<=m;i++)\n      {\n      \tint op=read(),x,y;\n      \tif(op==1)\n        Tree2.access(read());\n        else if(op==2)\n        {\n            x=read(),y=read();\n            int lca=LCA(x,y);\n            int s1=Tree1.ask1(1,n,1,ID[x]),s2=Tree1.ask1(1,n,1,ID[y]),s3=Tree1.ask1(1,n,1,ID[lca]);\n            printf(\"%d\\n\",s1+s2-s3*2+1);\n        }\n        else if(op==3)\n        {\n            x=read();\n            printf(\"%d\\n\",Tree1.ask(1,n,1,ID[x],ID[x]+siz[x]-1));\n        }\n      }\n    return 0;\n}\n```\n\u6700\u540e\u5b89\u5229\u4e00\u4e0b[\u535a\u5ba2](https://a-failure.github.io/2018/03/19/SDOI2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2/)",
        "postTime": 1521454478,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u6211\u4e00\u773c\u4ee5\u4e3a\u662f\u88f8\u6811\u5256\uff0c\u4f46\u662f\u770b\u5b8c\u95ee\u9898\u5c31\u77e5\u9053\u4e0d\u662f\u90a3\u4e48\u5bb9\u6613\u4e86\u3002\u56e0\u4e3a\u53ea\u7528\u6811\u5256\u4e0d\u80fd\u5f88\u597d\u5730\u7ef4\u62a4\u64cd\u4f5c$3$\u7684\u7ed3\u679c\u3002\n\n\u9996\u5148\uff0c\u6309\u7167\u539f\u6811\uff0c\u6784\u5efa\u51fa\u4e00\u4e2a\u5168\u90e8\u90fd\u662f\u865a\u8fb9\u7684$LCT$\uff0c\u5e76\u7528\u6811\u5256\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c$val$\u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c\u5c31\u662f\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u5b9e\u94fe\u7684\u4e2a\u6570\u3002\n\n\u6211\u4eec\u53d1\u73b0\uff0c\u64cd\u4f5c$1$\u5b9e\u9645\u4e0a\u5c31\u662f$LCT$\u4e2d$Access$\u7684\u64cd\u4f5c\u3002\u5728$Access$\u7684\u64cd\u4f5c\u4e2d\uff0c\u5982\u679c\u4e00\u6761\u5b9e\u8fb9\u53d8\u6210\u865a\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fde\u63a5\u8fd9\u6761\u8fb9\u7684**\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9**\u7684\u5b50\u6811\u91cc\u6240\u6709\u70b9\u7684$val$\u52a0 $1$\uff08\u56e0\u4e3a\u5b9e\u94fe\u6570\u91cf\u5c31\u7b49\u4e8e\u865a\u8fb9\u6570\u91cf$+1$\uff09\uff0c\u5982\u679c\u4e00\u6761\u865a\u8fb9\u53d8\u6210\u5b9e\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fde\u63a5\u8fd9\u6761\u8fb9\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9\u7684\u5b50\u6811\u91cc\u6240\u6709\u70b9\u7684$val$\u51cf$1$\u3002\n\n\u8fd9\u6837\uff0c\u8be2\u95ee$2$\u5176\u5b9e\u5c31\u662f\u6c42$val[x]+val[y]-val[lca(x,y)]*2+1$\u7684\u503c\uff0c\u8be2\u95ee$3$\u5c31\u662f\u6c42$x$\u7684\u5b50\u6811\u6700\u5927\u503c\u3002\u5728\u4ee5\u4e0a\uff0c\u7531\u4e8e\u540c\u4e00\u4e2a\u5b50\u6811\u91cc\u7684\u8282\u70b9$DFS$\u5e8f\u662f\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\uff0c\u6240\u4ee5\u5bf9\u4e8e\u5b50\u6811\u7684\u4fee\u6539\u8be2\u95ee\uff0c\u76f4\u63a5\u63d0\u53d6\u5bf9\u5e94\u7684$DFS$\u5e8f\u533a\u95f4\u5373\u53ef\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define p2 p << 1\n#define p3 p << 1 | 1\nusing namespace std;\ninline int read() {\n    int res = 0; bool bo = 0; char c;\n    while (((c = getchar()) < '0' || c > '9') && c != '-');\n    if (c == '-') bo = 1; else res = c - 48;\n    while ((c = getchar()) >= '0' && c <= '9')\n        res = (res << 3) + (res << 1) + (c - 48);\n    return bo ? ~res + 1 : res;\n}\nconst int N = 1e5 + 5, LogN = 24;\nint n, m, ecnt, nxt[N << 1], adj[N], go[N << 1], fa_s[N], lc[N], rc[N],\nQAQ, fa[N][LogN], dep[N], sze[N], son[N], top[N], pos[N], idx[N], T[N << 2],\nadd[N << 2], ml[N];\nvoid add_edge(int u, int v) {\n    nxt[++ecnt] = adj[u]; adj[u] = ecnt; go[ecnt] = v;\n}\nint which(int x) {return rc[fa_s[x]] == x;}\nbool is_root(int x) {\n    return !fa_s[x] || (lc[fa_s[x]] != x && rc[fa_s[x]] != x);\n}\nvoid upd(int x) {\n    ml[x] = lc[x] ? ml[lc[x]] : x;\n}\nvoid rotate(int x) {\n    int y = fa_s[x], z = fa_s[y], b = lc[y] == x ? rc[x] : lc[x];\n    if (z && !is_root(y)) (lc[z] == y ? lc[z] : rc[z]) = x;\n    fa_s[x] = z; fa_s[y] = x; if (b) fa_s[b] = y;\n    if (lc[y] == x) rc[x] = y, lc[y] = b;\n    else lc[x] = y, rc[y] = b; upd(y); upd(x);\n}\nvoid splay(int x) {\n    while (!is_root(x)) {\n        if (!is_root(fa_s[x])) {\n            if (which(x) == which(fa_s[x])) rotate(fa_s[x]);\n            else rotate(x);\n        }\n        rotate(x);\n    }\n    upd(x);\n}\nvoid dfs1(int u, int fu) {\n    int i; fa[u][0] = fu; dep[u] = dep[fu] + 1; sze[u] = 1;\n    for (i = 0; i <= 19; i++) fa[u][i + 1] = fa[fa[u][i]][i];\n    for (int e = adj[u], v; e; e = nxt[e]) {\n        if ((v = go[e]) == fu) continue;\n        dfs1(v, u); sze[u] += sze[v];\n        if (sze[v] > sze[son[u]]) son[u] = v;\n    }\n}\nvoid dfs2(int u, int fu) {\n    if (son[u]) {\n        top[son[u]] = top[u];\n        idx[pos[son[u]] = ++QAQ] = son[u];\n        dfs2(son[u], u);\n    }\n    for (int e = adj[u], v; e; e = nxt[e]) {\n        if ((v = go[e]) == fu || v == son[u]) continue;\n        top[v] = v; idx[pos[v] = ++QAQ] = v; dfs2(v, u);\n    }\n}\nvoid build(int l, int r, int p) {\n    if (l == r) return (void) (T[p] = dep[idx[l]]);\n    int mid = l + r >> 1;\n    build(l, mid, p2); build(mid + 1, r, p3);\n    T[p] = max(T[p2], T[p3]);\n}\nvoid down(int p) {\n    add[p2] += add[p]; add[p3] += add[p]; add[p] = 0;\n}\nvoid upt(int p) {\n    T[p] = max(T[p2] + add[p2], T[p3] + add[p3]);\n}\nvoid change(int l, int r, int s, int e, int v, int p) {\n    if (l == s && r == e) return (void) (add[p] += v);\n    int mid = l + r >> 1; down(p);\n    if (e <= mid) change(l, mid, s, e, v, p2);\n    else if (s >= mid + 1) change(mid + 1, r, s, e, v, p3);\n    else change(l, mid, s, mid, v, p2),\n        change(mid + 1, r, mid + 1, e, v, p3);\n    upt(p);\n}\nint query(int l, int r, int s, int e, int p) {\n    if (l == s && r == e) return T[p] + add[p];\n    int mid = l + r >> 1, res = 0; down(p);\n    if (e <= mid) res = query(l, mid, s, e, p2);\n    else if (s >= mid + 1) res = query(mid + 1, r, s, e, p3);\n    else res = max(query(l, mid, s, mid, p2),\n        query(mid + 1, r, mid + 1, e, p3));\n    upt(p); return res;\n}\nvoid init() {\n    int i; QAQ = top[1] = pos[1] = idx[1] = 1;\n    dfs1(1, 0); dfs2(1, 0); build(1, n, 1);\n    for (i = 1; i <= n; i++) fa_s[i] = fa[i][0], ml[i] = i;\n}\nvoid Access(int x) {\n    int y;\n    for (y = 0; x; y = x, x = fa_s[x]) {\n        splay(x);\n        if (rc[x]) change(1, n, pos[ml[rc[x]]], pos[ml[rc[x]]] +\n            sze[ml[rc[x]]]- 1, 1, 1);\n        if (y) change(1, n, pos[ml[y]], pos[ml[y]] + sze[ml[y]] - 1, -1, 1);\n        rc[x] = y; if (y) fa_s[y] = x;\n    }\n}\nint lca(int u, int v) {\n    int i; if (dep[u] < dep[v]) swap(u, v);\n    for (i = 20; i >= 0; i--) {\n        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];\n        if (u == v) return u;\n    }\n    for (i = 20; i >= 0; i--) if (fa[u][i] != fa[v][i])\n        u = fa[u][i], v = fa[v][i];\n    return fa[u][0];\n}\nint path_query(int u, int v) {\n    int w = lca(u, v), res;\n    res = query(1, n, pos[u], pos[u], 1) +\n        query(1, n, pos[v], pos[v], 1);\n    return res - (query(1, n, pos[w], pos[w], 1) << 1) + 1;\n}\nint main() {\n    int i, op, x, y; n = read(); m = read();\n    for (i = 1; i < n; i++) {\n        x = read(); y = read();\n        add_edge(x, y); add_edge(y, x);\n    }\n    init(); while (m--) {\n        op = read(); x = read();\n        if (op == 1) Access(x);\n        else if (op == 2) y = read(), printf(\"%d\\n\", path_query(x, y));\n        else printf(\"%d\\n\", query(1, n, pos[x], pos[x] + sze[x] - 1, 1));\n    }\n    return 0;\n}\n```",
        "postTime": 1503837847,
        "uid": 29936,
        "name": "xyz32768",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u7701\u9009Day1T3\uff0c\u5f53\u65f6\u6211\u7684\u60f3\u6cd5\u662f\u7528\u6811\u5256\u505a\uff0c\u5374\u53ea\u5f97\u4e8630\u5206\u3002\u597d\u50cf\u5c31\u7b97\u6700\u4f18\u7f8e\u7684\u6811\u5256\u7b97\u6cd5\u5728\u65f6\u95f4\u590d\u6742\u5ea6\u4e0a\u4e5f\u4f1a\u6bd4LCT\u7684\u591a\u4e00\u4e2alog\u3002\n\n\u6b63\u89e3\u662fLCT\u3002\n\n\u64cd\u4f5c1\u660e\u663e\u5c31\u662fLCT\u7684ACCESS\u64cd\u4f5c\u55bd\u3002\n\n\u6211\u4eec\u5c06\u540c\u4e00\u989c\u8272\u7684\u70b9\u653e\u5230\u4e00\u9897Splay\u91cc\u3002\n\n\u6211\u4eec\u8bbeF[i],\u8868\u793a\u8be5\u70b9i\u5230\u6839\u8def\u5f84\u4e0a\u4e0d\u540c\u989c\u8272\u7684\u6570\u91cf\u3002\u90a3\u4e48F[i]\u5c31\u7b49\u4e8e\u5230\u6839\u4e2d\u6240\u6709\u7684\u865a\u8fb9\u6570\u91cf+1\u3002\n\n\u90a3\u4e48\u663e\u7136\u7b2c\u4e8c\u4e2a\u7ed3\u679c\u4e3a F[x]+F[y]-2\\*F[lca(x,y)]+1\n\n\u6211\u4eec\u7528\u6811\u94fe\u5256\u5206\u627f\u5305LCA\u548cF[i]\u7684\u7ef4\u62a4\uff0c\u90a3\u4e48\u7b2c\u4e09\u4e2a\u7ed3\u679c\u5c31\u662f\u5728X\u7684\u5b50\u6811\u533a\u95f4\u53d6max\uff08\u5373\u7ebf\u6bb5\u6811\u7684\u533a\u95f4max\uff09\u3002\n\n\u73b0\u5728\u96be\u9898\u5728\u4e8e\u7b2c\u4e00\u4e2a\u64cd\u4f5c\u65f6\u6211\u4eec\u8be5\u5982\u4f55\u7ef4\u62a4F[i]\u503c\uff1f\n\n\u8003\u8651\u5230\u9898\u76ee\u53ea\u4f1a\u4f7f\u7528\u4e00\u79cd\u65b0\u7684\u989c\u8272\uff0c\u6240\u4ee5\u6211\u4eec\u5728ACCESS\u7684\u65f6\u5019\uff0c\u5982\u679c\u5f53\u524d\u70b9\u6709\u540e\u7ee7\uff0c\u5219\u540e\u7ee7+1\uff1b\u5982\u679c\u6709\u524d\u9a71\uff0c\u5219\u524d\u9a71-1\u3002\u8fd9\u4e9b\u64cd\u4f5c\u5728\u7ebf\u6bb5\u6811\u4e0a\u8fdb\u884c\u5373\u53ef\u3002\n\n\u90a3\u4e48\u8fd9\u4e2a\u9898\u5c31\u89e3\u51b3\u4e86\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 100005\n#define M 200005\nusing namespace std;\nstruct node{\n    int pos; \n    node *ch[2],*pre,*maxlson;\n    bool judge();\n    void setson(node *child,int lr);\n    void update();\n    bool isroot();\n}pool[N],*null;\nint n,m,cnt,tot,ui,vi,type;\nint in[N],out[N],head[N],nxt[M],point[M],fatson[N],father[N],size[N],anc[N],rem[N],tree[N*4],delta[N*4],deep[N];\nvoid PUSHDOWN(int now){\n    if(!delta[now])return;\n    int lson=now<<1,rson=lson+1;\n    tree[lson]+=delta[now]; tree[rson]+=delta[now];\n    delta[lson]+=delta[now]; delta[rson]+=delta[now];\n    delta[now]=0;\n}\nvoid UPDATE(int now){\n    tree[now]=max(tree[now<<1],tree[(now<<1)+1]);\n}\nvoid build(int now,int l,int r){\n    if(l==r){\n        tree[now]=deep[rem[l]]+1;\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(now<<1,l,mid);\n    build((now<<1)+1,mid+1,r);\n    UPDATE(now);\n}\nvoid secchange(int now,int l,int r,int left,int right,int value){\n    if(left<=l&&r<=right){\n        tree[now]+=value;\n        delta[now]+=value;\n        return;\n    }\n    int mid=(l+r)>>1;\n    PUSHDOWN(now);\n    if(left<=mid) secchange(now<<1,l,mid,left,right,value);\n    if(mid<right) secchange((now<<1)+1,mid+1,r,left,right,value);\n    UPDATE(now);\n}\nint secquery(int now,int l,int r,int left,int right){\n    if(left<=l&&r<=right){\n        return tree[now];\n    }\n    int mid=(l+r)>>1,ans=-1e5;\n    PUSHDOWN(now);\n    if(left<=mid) ans=max(secquery(now<<1,l,mid,left,right),ans);\n    if(mid<right) ans=max(secquery((now<<1)+1,mid+1,r,left,right),ans);\n    return ans;\n}\nbool node::judge(){return pre->ch[1]==this;}\nvoid node::update(){\n    if(ch[0]==null) maxlson=this;\n    else maxlson=ch[0]->maxlson;\n}\nbool node::isroot(){\n    if(pre==null)return true;\n    return (!(pre->ch[1]==this||pre->ch[0]==this)); \n}\nvoid node::setson(node *child,int lr){\n    ch[lr]=child;\n    if(child!=null) child->pre=this;\n    update();\n}\nnode *getnew(int pos){\n    node *now=pool+pos;\n    now->pos=pos;\n    now->ch[1]=now->ch[0]=now->pre=null;\n    now->maxlson=now;\n    return now;\n}\nvoid rotate(node *now){\n    node *father=now->pre,*grandfa=now->pre->pre;\n    int lr=now->judge();\n    father->setson(now->ch[lr^1],lr);\n    if(father->isroot()) now->pre=grandfa;\n    else grandfa->setson(now,father->judge());\n    now->setson(father,lr^1);\n}\nvoid splay(node *now){\n    if(now->isroot())return;\n    for(;!now->isroot();rotate(now))\n    if(!now->pre->isroot()) now->judge()==now->pre->judge()? rotate(now->pre):rotate(now);\n}\nnode *access(node *now){\n    node *last=null;\n    for(;now!=null;last=now,now=now->pre){\n        splay(now);\n        if(now->ch[1]!=null) secchange(1,1,cnt,in[now->ch[1]->maxlson->pos],out[now->ch[1]->maxlson->pos],1);\n        if(last!=null) secchange(1,1,cnt,in[last->maxlson->pos],out[last->maxlson->pos],-1);\n        now->setson(last,1);\n    }\n    return last;\n}\nvoid addedge(int x,int y){\n    tot++;nxt[tot]=head[x];head[x]=tot;point[tot]=y;\n    tot++;nxt[tot]=head[y];head[y]=tot;point[tot]=x;\n}\nvoid dfs(int now,int dad){\n    father[now]=dad;\n    size[now]=1;\n    node *fa=pool+dad,*me=pool+now; me->pre=fa;\n    for(int tmp=head[now];tmp;tmp=nxt[tmp]){\n        int v=point[tmp];\n        if(!size[v]){\n            deep[v]=deep[now]+1;\n            dfs(v,now);\n            size[now]+=size[v];\n            if(size[fatson[now]]<size[v]) fatson[now]=v;\n        }\n    }\n}\nvoid sign(int now,int ancestor){\n    anc[now]=ancestor;\n    in[now]=++cnt;\n    rem[cnt]=now;\n    if(fatson[now]) sign(fatson[now],ancestor);\n    for(int tmp=head[now];tmp;tmp=nxt[tmp]){\n        int v=point[tmp];\n        if(!in[v]) sign(v,v);\n    }\n    out[now]=cnt;\n}\nint LCA(int x,int y){\n    while(anc[x]!=anc[y]){\n        if(deep[anc[x]]<deep[anc[y]]) swap(x,y);\n        x=father[anc[x]];\n    }\n    if(deep[x]>deep[y]) swap(x,y);\n    return x;\n}\nint work(int x){\n    node *now=pool+x; int ans=0;\n    while(now!=null){\n        splay(now); now=now->pre;\n        ans++;\n    }\n    return ans;\n}\nint TWO(int x,int y){return work(x)+work(y)-2*work(LCA(x,y))+1;}\nint Three(int x){return secquery(1,1,cnt,in[x],out[x]);}\nint main(){\n    null=pool;\n    null->pos=0;null->pre=null->ch[0]=null->ch[1]=null->maxlson=null;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++) getnew(i);\n    for(int i=1;i<n;i++){\n        scanf(\"%d%d\",&ui,&vi);\n        addedge(ui,vi);\n    }\n    dfs(1,0);sign(1,1);build(1,1,cnt);\n    for(int i=1;i<=m;i++){\n        scanf(\"%d\",&type);\n        if(type==1){\n            scanf(\"%d\",&ui);\n            node *now=pool+ui;\n            access(now);\n            continue;\n        }\n        if(type==2){\n            scanf(\"%d%d\",&ui,&vi);\n            printf(\"%d\\n\",TWO(ui,vi));\n            continue;\n        }\n        if(type==3){\n            scanf(\"%d\",&ui);\n            printf(\"%d\\n\",Three(ui));\n            continue;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1498736141,
        "uid": 24559,
        "name": "Treeloveswater",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    },
    {
        "content": "\u6ca1\u6709\u4eba\u7528\u5b8f\u5b9a\u4e49+namespace\u5c01\u88c5\u5417\uff1f\u6765\u4e00\u53d1\u3002\u3002\u3002\n\n\u770b\u5230\u9898\u76ee\u7b2c\u4e00\u60f3\u6cd5\uff1a\u6811\u5256\u3002\n\n\u4f46\u662f1\u64cd\u4f5c\u8981\u6539\u4e00\u9897\u5b50\u6811\uff0c\u8fd8\u8981\u5206 \u5728\u94fe\u4e0a \u4e0e \u4e0d\u5728\u94fe\u4e0a \u4e24\u79cd\uff0c\u53ef\u80fd\u8fd8\u6709\u6811\u4e0a\u5206\u6cbb\u4ec0\u4e48\u4e71\u4e03\u516b\u7cdf\u7684\u73a9\u610f\uff0c\u65f6\u95f4+\u7a7a\u95f4+\u601d\u8003+\u4ee3\u7801 \u590d\u6742\u5ea6\u5747\u4e0d\u80fd\u63a5\u53d7\u3002\u3002\u3002\n\n\u6b63\u89e3\uff1aLink-Cut-Tree\u3002\u3002\u3002\n\n\u5148\u6784\u51fa\u539f\u6811\u7684\u865a\u6811LCT\uff0c\u5e76\u7528\u6811\u5256\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6743\u503cdata\uff0c\u90a3\u4e48\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c data \u5c31\u662f\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e0a \u5b9e\u94fe \u7684\u4e2a\u6570\u3002\n\n\u4e8e\u662f1\u64cd\u4f5c\u5c31\u53d8\u6210\u4e86access\uff1a\n\n\u5982\u679c\u4e00\u6761\u5b9e\u8fb9\u53d8\u6210\u865a\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fde\u63a5\u8fd9\u6761\u8fb9\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9\u7684\u5b50\u6811\u91cc\u6240\u6709\u70b9\u7684 data \u52a0 1 \uff08\u56e0\u4e3a\u5b9e\u94fe\u6570\u91cf\u5c31\u7b49\u4e8e\u865a\u8fb9\u6570\u91cf+1 \uff09;\n\n\u5982\u679c\u4e00\u6761\u865a\u8fb9\u53d8\u6210\u5b9e\u8fb9\uff0c\u90a3\u4e48\u5c06\u8fde\u63a5\u8fd9\u6761\u8fb9\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u8282\u70b9\u7684\u5b50\u6811\u91cc\u6240\u6709\u70b9\u7684 data \u51cf1 \u3002\n\n\u56e0\u4e3a\u6ca1\u6709\u52a0\u5220\u8fb9\uff0c\u65452\u30013\u64cd\u4f5c\u8fd8\u662f\u7528 \u6811\u5256+\u7ebf\u6bb5\u6811 \u7ef4\u62a4\u3002\n\n2\u64cd\u4f5c\uff1aans=data[ x ] + data[ y ] - data[ LCA(x,y) ] * 2 + 1\n\n3\u64cd\u4f5c\uff1aquery_max( id[x] , id[x] + size[x] - 1 )\n\n\u4ee3\u7801\u4e2d\u4e3a\u4e86\u9632\u6b62 \u7ebf\u6bb5\u6811 \u4e0e LCT \u6df7\u6dc6\uff0c\u7528\u4e86 namespace \u5c01\u88c5\u3002\n\n\u9644\u4e0a\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define MAXN 100010\nusing namespace std;\nint n,m,c=1,d=1;\nint head[MAXN],deep[MAXN],son[MAXN],size[MAXN],fa[MAXN],id[MAXN],top[MAXN];\nstruct node1{//\u524d\u5411\u661f\u6ca1\u8bdd\u8bf4\n    int next,to;\n}a[MAXN<<1];\nnamespace ST{\n    #define LSON rt<<1//\u4e2a\u4eba\u4e60\u60ef\u7ebf\u6bb5\u6811\u4e2d\u7528\u5b8f\u5b9a\u4e49\uff0c\u7a0b\u5e8f\u6e05\u6670\u3002\u3002\u3002\n    #define RSON rt<<1|1\n    #define DATA(x) a[x].data\n    #define SIGN(x) a[x].c\n    #define LSIDE(x) a[x].l\n    #define RSIDE(x) a[x].r\n    struct Sg_Tree{//\u7ebf\u6bb5\u6811\u6ca1\u8bdd\u8bf4\n        int data,c,l,r;\n    }a[MAXN<<2];\n    inline void pushup(int rt){//\u4e0a\u4f20\n        DATA(rt)=max(DATA(LSON),DATA(RSON));\n    }\n    inline void pushdown(int rt){//\u6807\u8bb0\u4e0b\u4f20\n        if(!SIGN(rt)||LSIDE(rt)==RSIDE(rt))return;\n        SIGN(LSON)+=SIGN(rt);DATA(LSON)+=SIGN(rt);\n        SIGN(RSON)+=SIGN(rt);DATA(RSON)+=SIGN(rt);\n        SIGN(rt)=0;\n    }\n    void buildtree(int l,int r,int rt){//\u5efa\u6811\n        int mid;\n        LSIDE(rt)=l;\n        RSIDE(rt)=r;\n        if(l==r){\n            DATA(rt)=0;//\u8bb0\u5f97\u8d4b0\n            return;\n        }\n        mid=l+r>>1;\n        buildtree(l,mid,LSON);\n        buildtree(mid+1,r,RSON);\n        pushup(rt);\n    }\n    void update(int l,int r,int c,int rt){//\u4fee\u6539\n        int mid;\n        if(l<=LSIDE(rt)&&RSIDE(rt)<=r){\n            SIGN(rt)+=c;DATA(rt)+=c;\n            return;\n        }\n        pushdown(rt);\n        mid=LSIDE(rt)+RSIDE(rt)>>1;\n        if(l<=mid)update(l,r,c,LSON);\n        if(mid<r)update(l,r,c,RSON);\n        pushup(rt);\n    }\n    int query(int l,int r,int rt){//\u6c42\u6700\u5927\u503c\n        int mid,ans=0;\n        if(l<=LSIDE(rt)&&RSIDE(rt)<=r)return DATA(rt);\n        pushdown(rt);\n        mid=LSIDE(rt)+RSIDE(rt)>>1;\n        if(l<=mid)ans=max(ans,query(l,r,LSON));\n        if(mid<r)ans=max(ans,query(l,r,RSON));\n        return ans;\n    }\n}\nnamespace LCT{\n    int stack[MAXN];\n    struct Link_Cut_Tree{//LCT\u6ca1\u8bdd\u8bf4\n        int son[2];\n        int f,s,flag;\n    }a[MAXN];\n    inline bool isroot(int rt){//\u5224\u6839\n        return a[a[rt].f].son[0]!=rt&&a[a[rt].f].son[1]!=rt;\n    }\n    inline void pushup(int rt){//\u4e0a\u4f20\n        if(!rt)return;\n        if(a[rt].son[0])a[rt].s=a[a[rt].son[0]].s;\n        else a[rt].s=rt;\n    }\n    inline void pushdown(int rt){//\u4e0b\u4f20\n        if(!rt||!a[rt].flag)return;\n        a[a[rt].son[0]].flag^=1;a[a[rt].son[1]].flag^=1;a[rt].flag^=1;\n        swap(a[rt].son[0],a[rt].son[1]);\n    }\n    inline void turn(int rt){//\u65cb\u8f6c\n        int x=a[rt].f,y=a[x].f,k=a[x].son[0]==rt?1:0;\n        if(!isroot(x)){\n            if(a[y].son[0]==x)a[y].son[0]=rt;\n            else a[y].son[1]=rt;\n        }\n        a[rt].f=y;a[x].f=rt;a[a[rt].son[k]].f=x;\n        a[x].son[k^1]=a[rt].son[k];a[rt].son[k]=x;\n        pushup(x);pushup(rt);\n    }\n    void splay(int rt){//\u4f38\u5c55\n        int top=0;\n        stack[++top]=rt;\n        for(int i=rt;!isroot(i);i=a[i].f)stack[++top]=a[i].f;\n        while(top)pushdown(stack[top--]);\n        while(!isroot(rt)){\n            int x=a[rt].f,y=a[x].f;\n            if(!isroot(x)){\n                if((a[y].son[0]==x)^(a[x].son[0]==rt))turn(rt);\n                else turn(x);\n            }\n            turn(rt);\n        }\n    }\n    void access(int x){//\u64cd\u4f5c1\n        for(int i=0;x;i=x,x=a[x].f){\n            splay(x);\n            if(a[x].son[1])ST::update(id[a[a[x].son[1]].s],id[a[a[x].son[1]].s]+size[a[a[x].son[1]].s]-1,1,1);\n            if(i)ST::update(id[a[i].s],id[a[i].s]+size[a[i].s]-1,-1,1);\n            a[x].son[1]=i;\n            if(i)a[i].f=x;\n        }\n    }\n}\ninline int read(){//\u8bfb\u4f18\n\tint date=0,w=1;char c=0;\n\twhile(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}\n\treturn date*w;\n}\ninline void add(int x,int y){//\u52a0\u8fb9\n    a[c].to=y;a[c].next=head[x];head[x]=c++;\n    a[c].to=x;a[c].next=head[y];head[y]=c++;\n}\nvoid dfs1(int rt){//\u6811\u5256dfs1\n    son[rt]=0;size[rt]=1;\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(!deep[will]){\n            deep[will]=deep[rt]+1;\n            fa[will]=rt;\n            dfs1(will);\n            size[rt]+=size[will];\n            if(size[son[rt]]<size[will])son[rt]=will;\n        }\n    }\n}\nvoid dfs2(int rt,int f){//\u6811\u5256dfs2\n    id[rt]=d++;top[rt]=f;\n    if(son[rt])dfs2(son[rt],f);\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(will!=fa[rt]&&will!=son[rt])\n        dfs2(will,will);\n    }\n}\nint LCA(int x,int y){//\u6811\u5256\u6c42LCA\n    while(top[x]!=top[y]){\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        x=fa[top[x]];\n    }\n    if(deep[x]>deep[y])swap(x,y);\n    return x;\n}\nvoid work(){//\u5de5\u4f5c\n    int f,x,y;\n    while(m--){\n        f=read();x=read();\n        if(f==1)LCT::access(x);\n        if(f==2){\n            y=read();\n            int fa=LCA(x,y);\n            printf(\"%d\\n\",(ST::query(id[x],id[x],1)+ST::query(id[y],id[y],1)-ST::query(id[fa],id[fa],1)*2+1));\n        }\n        if(f==3)printf(\"%d\\n\",ST::query(id[x],id[x]+size[x]-1,1));\n    }\n}\nvoid init(){//\u8bfb\u5165+\u9884\u5904\u7406\n    int x,y;\n    n=read();m=read();\n    for(int i=1;i<n;i++){\n        x=read();y=read();\n        add(x,y);\n    }\n    deep[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    ST::buildtree(1,n,1);\n    for(int i=1;i<=n;i++){\n        ST::update(id[i],id[i],deep[i],1);\n        LCT::a[i].s=i;\n        LCT::a[i].f=fa[i];//\u8bb0\u5f97\u8fd9\u4e24\u53e5\uff1a\u5efa\u865a\u6811\n    }\n}\nint main(){//\u4e3b\u51fd\u6570So easy!\n    init();\n    work();\n\treturn 0;\n}\n\n```",
        "postTime": 1520858065,
        "uid": 49998,
        "name": "\u65af\u5fb7\u54e5\u5c14\u6469",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3703 \u3010[SDOI2017]\u6811\u70b9\u6d82\u8272\u3011"
    }
]