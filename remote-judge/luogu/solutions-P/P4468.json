[
    {
        "content": "\u6211\u662f\u771f\u7684\u83dc\u554a\n\n\u771f\u7684\u597d\u96be\u554a \n\n\u60f3\u4e86\u597d\u4e45\u597d\u4e45\n\n\u5927\u4f53\u601d\u8def\u5c31\u662f\uff1a\n\n\u56e0\u4e3a\u5bf9\u6298\u6b21\u6570\u662f\u6709\u4e0a\u9650\u7684\uff0c\u6240\u4ee5\u8fd9\u4e2a\u503c\u4e5f\u4e0d\u4f1a\u592a\u5927\uff0c\n\n\u90a3\u4e48\u6700\u540e\u63d0\u4f9b\u7b54\u6848\u7684\u6570\u636e\u70b9\u7684\u7ed3\u679c\u5e94\u8be5\u4e5f\u4e0d\u4f1a\u592a\u5927\uff0c\n\n\u5982\u679c\u4e0d\u653e\u5fc3\u7684\u8bdd\uff0c\u53ef\u4ee5\u5f00\u4e00\u4e2aunsigned long long\n\n\u6240\u4ee5\u5c31\u5bf9\u8f93\u5165\u7684\u6bcf\u4e2a\u70b9\uff0c\u628a\u4e00\u5f20\u6298\u53e0\u4e86\u7684\u7eb8\u518d\u6cbf\u7740\u6298\u75d5\u8fd4\u56de\u8fc7\u53bb\uff0c\n\n\u76f8\u5f53\u4e8e\u5728\u4e00\u4e2a\u5e73\u9762\u76f4\u89d2\u5750\u6807\u7cfb\u4e2d\u5bfb\u627e\u4e00\u4e2a\u5df2\u77e5\u70b9\u7684\u5bf9\u79f0\u70b9 \n\n~~\u6570\u5b66\u7684\u624b\u52a8\u6ed1\u7a3d~~\n\n\u8fb9\u8bfb\u8fb9\u626b\uff0c\u5728\u8f93\u5165\u8fc7\u7a0b\u4e2d\u6392\u9664\u4e2d\u9014\u4e0d\u7b26\u5408\u60c5\u51b5\u7684\u70b9\uff0c\n\n\u6700\u540e\u770b\u5728\u521d\u59cb\u7684\u56fe\u5f62\u4e0a\u6709\u591a\u5c11\u7684\u70b9\u5269\u4e0b\u6765\uff0c\u65e2\u7b26\u5408\u60c5\u51b5\u7684\u70b9\n\n\u8981\u6c42\u70b9\u5173\u4e8e\u76f4\u7ebf\u7684\u5bf9\u79f0\u70b9\u3002\n\n~~\u5bf9\u79f0\u70b9\u7684\u4e00\u79cd\u6c42\u6cd5\u662f\u659c\u7387\u4e4b\u79ef\u4e3a-1~~\n\n~~\u7136\u540e\u6c42\u89e3~~\n\n\u8fd9\u662f\u6211\u6253\u7684\u667a\u969c\u505a\u6cd5\u2026\u2026\n\n\u636e\u5927\u4f6c\u8bb2\u89e3\u53ef\u4ee5\u7528\u65cb\u8f6c\u5411\u91cf\u516c\u5f0f\n\nx1=x0*cosB-y0*sinB  \n\ny1=x0*sinB+y0*cosB    \n\nOrz\u4e00\u6ce2\u5927\u4f6c\n\n~~\u7f8e\u4e3d\u7684\u6298\u7eb8 \u6e9c\u4e86\u6e9c\u4e86~~\n\n![](http://pic7.nipic.com/20100430/218586_145346002992_2.jpg)\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std ; \n\nconst int MAXN = 10 ; \nconst int MAXM = 60 ; \nconst double eps = 1e-6 ; \nint N , M ;\n\nstruct Point {\n    double x , y ; \n    Point ( const double x , const double y ) :\n    x ( x ) , y ( y ) {} ;\n} ; \n\nstruct Vector {\n    double x , y ; \n    Vector ( const double x , const double y ) : \n    x ( x ) , y ( y ) {} ; \n} ; \n\nstruct Line {\n    Point From , To ; \n    Line ( const double x1 , const double y1 , \n           const double x2 , const double y2 ) :\n    From ( x1 , y1 ) , To ( x2 , y2 ) {} ;\n    Vector toVector () const ;\n} ;\n\nVector operator - ( const Point & First , const Point & Second ) {\n    return Vector ( First . x - Second . x , First . y - Second . y ) ; \n} \n\nPoint operator - ( const Point & First , const Vector & Second ) {\n    return Point ( First . x - Second . x , First . y - Second . y ) ; \n} \n\nVector operator * ( const double k , const Vector & Input ) {\n    return Vector ( k * Input . x , k * Input . y ) ; \n}\n\nPoint operator + ( const Point & First , const Vector & Second ) {\n    return Point ( First . x + Second . x , First . y + Second . y ) ; \n}\n\n\ndouble operator ^ ( const Vector & First , const Vector & Second ) {\n    return First . x * Second . y - First . y * Second . x ; \n}  \n\ndouble operator * ( const Vector & First , const Vector & Second ) {\n    return First . x * Second . x + First . y * Second . y ; \n}\n\ndouble abs ( const Vector & Input ) {\n    return sqrt ( Input . x * Input . x + Input . y * Input . y ) ; \n}\n\nVector Line :: toVector () const { return To - From ; }  \n\nvector < Line > Opts ; \n\nPoint reflect ( const Point o , const Line L ) {\n    const double dis = ( ( L . From - o ) ^ ( L . To - o ) ) / abs ( L . toVector () ) ; \n    const Vector Lp = 1.0 / abs ( L . toVector () ) * L . toVector () ; \n    return o + 2.0 * dis * Vector ( Lp . y , - Lp . x ) ;\n}\n\nint Query ( const Point o , const int T ) {\n    if ( T == -1 ) \n        return ( eps <= o . x && o . x <= 100.0 - eps ) && \n               ( eps <= o . y && o . y <= 100.0 - eps ) ; \n    const double CrossValue =   ( ( Opts [ T ] . From - o ) ^ ( Opts [ T ] . To - o ) ) ;\n    if ( CrossValue < - eps ) return 0 ;     \n    if ( - eps <= CrossValue && CrossValue <= eps ) return 0 ; \n    return Query ( o , T - 1 ) + \n           Query ( reflect ( o , Opts [ T ] ) , T - 1 ) ; \n}\n\nint main () {\n    scanf ( \"%d\" , & N ) ; \n    for ( int i = 0 ; i < N ; ++ i ) {\n        double x1 , y1 , x2 , y2 ; \n        scanf ( \"%lf%lf%lf%lf\" , & x1 , & y1 , & x2 , & y2 ) ; \n        Opts . push_back ( Line ( x1 , y1 , x2 , y2 ) ) ; \n    } \n    scanf ( \"%d\" , & M ) ; \n    while ( M -- ) {\n        double x , y ; \n        scanf ( \"%lf%lf\" , & x , & y ) ; \n        printf ( \"%d\\n\" , Query ( Point ( x , y ) , N - 1 ) ) ;\n    }\n    return 0 ;\n}\n```",
        "postTime": 1537079556,
        "uid": 99460,
        "name": "Hiraeth",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4468 \u3010[SCOI2007]\u6298\u7eb8\u3011"
    },
    {
        "content": "# **\u3010\u9898\u89e3\u3011\u6298\u7eb8 origami [SCOI2007] [P4468] [Bzoj1074]**\n\n[$\\mathcal{My}\\ \\mathcal{Blog}$](https://www.cnblogs.com/Xing-Ling/p/12120274.html)\n\n\u4f20\u9001\u95e8\uff1a[\u6298\u7eb8 $\\text{origami [SCOI2007] [P4468]}$](https://www.luogu.com.cn/problem/P4468) [$\\text{[Bzoj1074]}$](https://www.lydsy.com/JudgeOnline/problem.php?id=1074)\n\n## **\u3010\u9898\u76ee\u63cf\u8ff0\u3011**\n\n\u521d\u59cb\u6709\u4e00\u4e2a $100*100$ \u7684\u6b63\u65b9\u5f62\u7eb8\u7247\uff0c\u73b0\u7ed9\u51fa $n$ $(0 \\leqslant n \\leqslant 8)$ \u6761\u76f4\u7ebf\uff0c\u5c06\u8be5\u7eb8\u7247\u4f9d\u6b21\u6309\u7167\u76f4\u7ebf\u8fdb\u884c\u6298\u53e0\uff0c\u7ed3\u675f\u540e\u4f1a\u7ed9\u51fa $m$ \u4e2a\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u6c42\u67d0\u4e2a\u5750\u6807\u4e0a\u7684\u70b9\u7a7f\u8fc7\u4e86\u51e0\u5c42\u7eb8\u3002\n\n## **\u3010\u5206\u6790\u3011**\n\n[\u3010\u8ba1\u7b97\u51e0\u4f55\u5168\u5bb6\u6876\u3011](https://www.luogu.com.cn/blog/ChenXingLing/post-xue-xi-bi-ji-ji-suan-ji-he-quan-jia-tong)\n\n\u53c8\u662f\u4e00\u9053\u6bd2\u7624\u819c\u60a8\u9898\u3002\n\n\u7531\u4e8e\u6570\u636e\u8303\u56f4\u8f83\u5c0f\uff0c\u53ef\u4ee5\u76f4\u63a5\u4e0a\u66b4\u529b\u3002\n\n\u8003\u8651\u8bb0\u5f55\u5f53\u524d\u5df2\u6709\u7684\u591a\u8fb9\u5f62\uff08\u521d\u59cb\u4e3a\u4e00\u4e2a $100*100$ \u7684\u6b63\u65b9\u5f62\uff09\uff0c\u6bcf\u6298\u53e0\u4e00\u6b21\u5c31\u628a\u6298\u53e0\u7ebf\u6240\u7a7f\u8fc7\u7684\u6240\u6709\u591a\u8fb9\u5f62\u5206\u6210\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u7136\u540e\u5c06\u53f3\u8fb9\u90e8\u5206\u7684\u70b9\u5168\u90e8\u5173\u4e8e\u6298\u53e0\u7ebf\u5bf9\u79f0\uff0c\u5f97\u5230\u4e24\u4e2a\u65b0\u7684\u5c0f\u591a\u8fb9\u5f62\u3002\n\n\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u66b4\u529b\u679a\u4e3e\u7edf\u8ba1 \u5305\u542b\u8be2\u95ee\u70b9\u7684\u591a\u8fb9\u5f62 \u5373\u53ef\u3002\n\n\u6298\u53e0 $n$ \u6b21\u540e\u6700\u591a\u4f1a\u51fa\u73b0 $2^n$ \u4e2a\u591a\u8fb9\u5f62\uff0c\u6bcf\u4e2a\u591a\u8fb9\u5f62\u6700\u591a\u6709 $n^2$ \u4e2a\u70b9\uff0c\u5c04\u7ebf\u6cd5\u505a\u4e00\u6b21 $PIP$ \u4e3a $O(n^2)$\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\uff1a $O(m n^2 2^n)$ \u3002\n\n**\u6ce8\u610f\uff1a\u5982\u679c\u7528\u7684\u662f $double$ \u800c\u4e0d\u662f $long\\ double$\uff0c$eps$ \u5f00\u5f97\u8fc7\u4e8e\u5c0f\u4f1a\u5bfc\u81f4\u7b54\u6848\u51fa\u9505\u3002**\n\n## **\u3010Code\u3011**\n\n```cpp\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define LD double\n#define LL long long\n#define Re register int\n#define Vector Point\nusing namespace std;\nconst int N=8;\nconst LD eps=1e-8;\ninline int dcmp(LD a){return a<-eps?-1:(a>eps?1:0);}//\u5904\u7406\u7cbe\u5ea6\ninline LD Abs(LD a){return a*dcmp(a);}//\u53d6\u7edd\u5bf9\u503c\nstruct Point{\n    LD x,y;Point(LD X=0,LD Y=0){x=X,y=Y;}\n    inline void in(){scanf(\"%lf%lf\",&x,&y);}\n    inline void out(){printf(\"%.2lf %.2lf\\n\",x,y);}\n};\ninline LD Dot(Vector a,Vector b){return a.x*b.x+a.y*b.y;}//\u3010\u70b9\u79ef\u3011\ninline LD Cro(Vector a,Vector b){return a.x*b.y-a.y*b.x;}//\u3010\u53c9\u79ef\u3011\ninline LD Len(Vector a){return sqrt(Dot(a,a));}//\u3010\u6a21\u957f\u3011\ninline LD Angle(Vector a,Vector b){return acos(Dot(a,b)/Len(a)/Len(b));}//\u3010\u4e24\u5411\u91cf\u5939\u89d2\u3011\ninline Vector operator+(Vector a,Vector b){return Vector(a.x+b.x,a.y+b.y);}\ninline Vector operator-(Vector a,Vector b){return Vector(a.x-b.x,a.y-b.y);}\ninline Vector operator*(Vector a,LD b){return Vector(a.x*b,a.y*b);}\ninline bool operator==(Point a,Point b){return !dcmp(a.x-b.x)&&!dcmp(a.y-b.y);}//\u4e24\u70b9\u5750\u6807\u91cd\u5408\u5219\u76f8\u7b49\ninline int pan_PL(Point p,Point a,Point b){//\u3010\u5224\u65ad\u70b9P\u662f\u5426\u5728\u7ebf\u6bb5AB\u4e0a\u3011\n    return !dcmp(Cro(p-a,b-a))&&dcmp(min(a.x,b.x)-p.x)<=0&&dcmp(p.x-max(a.x,b.x))<=0&&dcmp(min(a.y,b.y)-p.y)<=0&&dcmp(p.y-max(a.y,b.y))<=0;\n    //PA,AB\u5171\u7ebf\u4e14P\u5728AB\u4e4b\u95f4\n}\ninline int pan_PL_(Point p,Point a,Point b){//\u3010\u5224\u65ad\u70b9P\u662f\u5426\u5728\u76f4\u7ebfAB\u4e0a\u3011\n    return !dcmp(Cro(p-a,b-a));//PA,AB\u5171\u7ebf\n}\ninline Point FootPoint(Point p,Point a,Point b){//\u3010\u70b9P\u5230\u76f4\u7ebfAB\u7684\u5782\u8db3\u3011\n    Vector x=p-a,y=p-b,z=b-a;\n    LD len1=Dot(x,z)/Len(z),len2=-1.0*Dot(y,z)/Len(z);//\u5206\u522b\u8ba1\u7b97AP,BP\u5728AB,BA\u4e0a\u7684\u6295\u5f71\n    return a+z*(len1/(len1+len2));//\u70b9A\u52a0\u4e0a\u5411\u91cfAF\n}\ninline Point Symmetry_PL(Point p,Point a,Point b){//\u3010\u70b9P\u5173\u4e8e\u76f4\u7ebfAB\u7684\u5bf9\u79f0\u70b9\u3011\n    return p+(FootPoint(p,a,b)-p)*2;//\u5c06PF\u5ef6\u957f\u4e00\u500d\u5373\u53ef\n}\ninline Point cross_LL(Point a,Point b,Point c,Point d){//\u3010\u4e24\u76f4\u7ebfAB,CD\u7684\u4ea4\u70b9\u3011\n    Vector x=b-a,y=d-c,z=a-c;\n    return a+x*(Cro(y,z)/Cro(x,y));//\u70b9A\u52a0\u4e0a\u5411\u91cfAF\n}\ninline int pan_cross_L_L(Point a,Point b,Point c,Point d){//\u3010\u5224\u65ad\u76f4\u7ebfAB\u4e0e\u7ebf\u6bb5CD\u662f\u5426\u76f8\u4ea4\u3011\n    return pan_PL(cross_LL(a,b,c,d),c,d);//\u76f4\u7ebfAB\u4e0e\u76f4\u7ebfCD\u7684\u4ea4\u70b9\u5728\u7ebf\u6bb5CD\u4e0a\n}\ninline int PIP(Point *P,Re n,Point a){//\u3010\u5c04\u7ebf\u6cd5\u3011\u5224\u65ad\u70b9A\u662f\u5426\u5728\u4efb\u610f\u591a\u8fb9\u5f62Poly\u4ee5\u5185\n    Re cnt=0;LD tmp;\n    for(Re i=1;i<=n;++i){\n        Re j=i<n?i+1:1;\n        if(pan_PL(a,P[i],P[j]))return 2;//\u70b9\u5728\u591a\u8fb9\u5f62\u4e0a\n        if(a.y>=min(P[i].y,P[j].y)&&a.y<max(P[i].y,P[j].y))//\u7eb5\u5750\u6807\u5728\u8be5\u7ebf\u6bb5\u4e24\u7aef\u70b9\u4e4b\u95f4\n            tmp=P[i].x+(a.y-P[i].y)/(P[j].y-P[i].y)*(P[j].x-P[i].x),cnt+=dcmp(tmp-a.x)>0;//\u4ea4\u70b9\u5728A\u53f3\u65b9\n    }\n    return cnt&1;//\u7a7f\u8fc7\u5947\u6570\u6b21\u5219\u5728\u591a\u8fb9\u5f62\u4ee5\u5185\n}\ninline int judge(Point a,Point L,Point R){//\u5224\u65adAL\u662f\u5426\u5728AR\u53f3\u8fb9\n    return dcmp(Cro(L-a,R-a))>0;\n}\nstruct Poly{int n;Point P[N*N+3];}Py[(1<<N)+3],Qy[(1<<N)+3];\nint n,t,tt,T;Point a,b;\ninline void sakura(Poly Po,Point a,Point b){\n    Poly L,R;L.n=R.n=0;\n    for(Re i=1;i<=Po.n;++i){\n        if(judge(a,Po.P[i],b))R.P[++R.n]=Symmetry_PL(Po.P[i],a,b);//\u70b9Po.P[i]\u5728\u76f4\u7ebfab\u53f3\u8fb9\n        else if(pan_PL_(Po.P[i],a,b))L.P[++L.n]=R.P[++R.n]=Po.P[i];//\u70b9Po.P[i]\u5728\u76f4\u7ebfab\u4e0a\n        else L.P[++L.n]=Po.P[i];//\u70b9Po.P[i]\u5728\u76f4\u7ebfab\u5de6\u8fb9\n        Re j=i<Po.n?i+1:1;\n        if(pan_cross_L_L(a,b,Po.P[i],Po.P[j]))L.P[++L.n]=R.P[++R.n]=cross_LL(a,b,Po.P[i],Po.P[j]);//\u5982\u679c\u76f4\u7ebfAB\u4e0e\u7ebf\u6bb5P[i]-P[i+1]\u6709\u4ea4\u70b9\uff0c\u5c06\u8fd9\u4e2a\u4ea4\u70b9\u5165\u961f\n        while(L.n>1&&L.P[L.n]==L.P[L.n-1])--L.n;//\u53ef\u80fd\u4f1a\u91cd\u590d\u5982\u5f52\uff0c\u8fd9\u91cc\u8fc5\u901f\u628a\u5b83\u53bb\u6389\n        while(R.n>1&&R.P[R.n]==R.P[R.n-1])--R.n;//\u540c\u4e0a\n    }\n    if(L.n>1&&L.P[1]==L.P[L.n])--L.n;//\u6ce8\u610f\u6700\u540e\u5224\u65ad\u9996\u5c3e\u4e24\u70b9\u662f\u5426\u91cd\u5408\n    if(R.n>1&&R.P[1]==R.P[R.n])--R.n;//\u540c\u4e0a\n    if(L.n)Qy[++tt]=L;//\u5982\u679c\u5c0f\u77e9\u5f62\u4e0d\u4e3a\u7a7a\u5c31\u8bb0\u5f55\u4e0b\u6765\n    if(R.n)Qy[++tt]=R;\n}\nint main(){\n//  freopen(\"123.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    Py[++t].n=4,Py[t].P[1]=Point(0,0),Py[t].P[2]=Point(0,100),Py[t].P[3]=Point(100,100),Py[t].P[4]=Point(100,0);\n    //\u521d\u59cb\u5316\u4e3a\u4e00\u4e2a\u6b63\u65b9\u5f62\n    while(n--){\n        a.in(),b.in(),tt=0;\n        for(Re i=1;i<=t;++i)sakura(Py[i],a,b);//\u5207\u5272\u76ee\u524d\u5df2\u6709\u7684\u591a\u8fb9\u5f62\n        t=tt;\n        for(Re i=1;i<=tt;++i)Py[i]=Qy[i];\n    }\n    scanf(\"%d\",&T);\n    while(T--){\n        a.in();Re ans=0;\n        for(Re i=1;i<=t;++i)if(PIP(Py[i].P,Py[i].n,a)==1)++ans;//\u4e25\u683c\u5728\u591a\u8fb9\u5f62\u5185\u624d\u7edf\u8ba1\u7b54\u6848\n        printf(\"%d\\n\",ans);\n    }\n}\n```\n",
        "postTime": 1577693705,
        "uid": 110985,
        "name": "\u8fb0\u661f\u51cc",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4468 \u3010[SCOI2007]\u6298\u7eb8\u3011"
    },
    {
        "content": "## 1. Description\n\n\u5e73\u9762\u5185\u6709\u4e00\u5f20\u6b63\u65b9\u5f62\u7eb8\u7247\uff0c\u7ed9\u5b9a $n$ \u6761\u6298\u7eb8\u547d\u4ee4\uff0c\u6bcf\u6b21\u7ed9\u5b9a\u4e00\u6761\u76f4\u7ebf\uff0c\u628a\u4f5c\u54c1\u5728\u76f4\u7ebf\u53f3\u8fb9\u7684\u90e8\u5206\u6298\u5411\u5de6\u8fb9\uff0c\u7ed9\u5b9a $m$ \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u4e00\u4e2a\u70b9\u88ab\u591a\u5c11\u5c42\u7eb8\u7247\u8986\u76d6\u3002\n\n$n\\le 8, 1\\le m\\le 50$\n\n## 2. Solution\n\n\u8003\u8651 $n,m$ \u5f88\u5c0f\u53ef\u4ee5\u76f4\u63a5\u6a21\u62df\u3002\n\n\u6bcf\u6b21\u7ffb\u6298\u540e\u76f8\u5f53\u4e8e\u5c06\u539f\u6765\u7684\u591a\u8fb9\u5f62\u5206\u6210\u4e24\u4e2a\u591a\u8fb9\u5f62\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u76f4\u63a5\u8be2\u95ee\u88ab\u591a\u5c11\u4e2a\u591a\u8fb9\u5f62\u8986\u76d6\uff0c\u8fd0\u7528\u4e00\u4e9b\u8ba1\u7b97\u51e0\u4f55\u5c0f\u6280\u5de7\u5c31\u80fd\u89e3\u51b3\u3002\n\n\u8bf4\u51e0\u4e2a corner case\uff1a\u8981\u6ce8\u610f\u76f4\u7ebf\u6070\u597d\u548c\u591a\u8fb9\u5f62\u7684\u4e00\u6761\u8fb9\u91cd\u5408\u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u5e94\u8be5\u76f4\u63a5\u7ffb\u8f6c\u800c\u4e0d\u662f\u62c6\u5206\uff0c\u81f3\u4e8e\u5982\u4f55\u5224\u65ad\u91cd\u5408\u7528\u659c\u7387\u4f1a\u51fa\u73b0\u4e00\u4e9b\u95ee\u9898\uff0c\u6bd4\u5982\u8bf4\u5206\u6bcd\u4e3a $0$ \u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u9700\u8981\u5316\u9664\u4e3a\u4e58\u6765\u89e3\u51b3\u3002\n\n\u7ec6\u8282\u6709\u70b9\u591a\uff0c\u5fc5\u8981\u7684\u65f6\u5019 assert \u4e00\u4e0b\u3002\n\n## 3. Code\n\n```cpp\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n\nconst int N = 110;\nconst double eps = 1e-6;\n\nstruct Point {\n  double x, y;\n  inline Point(double _x = 0, double _y = 0) : x(_x), y(_y) {}\n  inline Point operator+(Point b) { return Point(x + b.x, y + b.y); }\n  inline Point operator-(Point b) { return Point(x - b.x, y - b.y); }\n  inline Point operator*(double p) { return Point(x * p, y * p); }\n  inline double operator*(Point b) { return x * b.x + y * b.y; }\n  inline double operator^(Point b) { return x * b.y - y * b.x; }\n  inline bool operator==(Point b) {\n    return fabs(b.x - x) <= eps && fabs(b.y - y) <= eps;\n  }\n  inline bool operator<(Point b) {\n    return fabs(x - b.x) <= eps ? y - b.y < -eps : x - b.x < -eps;\n  }\n  inline double len() {\n    return sqrt(x * x + y * y);\n  }\n  inline Point rot(double p) {\n    return Point(x * cos(p) - y * sin(p), x * sin(p) + y * cos(p));\n  }\n};\n\ninline double ang(Point a, Point b) {\n  return acos((a * b) / a.len() / b.len());\n}\n\ninline bool onSeg(Point p, Point a, Point b) {\n  return fabs((p - a) ^ (p - b)) <= eps && ((p - a) * (p - b)) <= eps;\n}\n\ninline bool onLine(Point p, Point a, Point b) {\n  return fabs((p - a) ^ (p - b)) <= eps;\n}\n\ninline Point inter(Point a, Point b, Point c, Point d) {\n  Point x = b - a, y = d - c, z = a - c;\n  return a + (x * ((y ^ z) / (x ^ y)));\n}\n\ninline bool toRight(Point a, Point l, Point r) {\n  return ((l - a) ^ (r - a)) > eps;\n}\n\ninline int inPoly1(std::vector<Point> vec, Point p) {\n  int n = vec.size(), cnt = 0;\n  assert(n >= 3);\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    if (onSeg(p, vec[i], vec[j])) return 2;\n    if (fabs(vec[j].y - vec[i].y) <= eps) continue;\n    if (std::min(vec[i].y, vec[j].y) - p.y > eps) continue;\n    if (p.y - std::max(vec[i].y, vec[j].y) >= -eps) continue;\n    Point q = inter(p, Point(p.x + 1, p.y), vec[i], vec[j]);\n    if (q.x - p.x > eps) ++cnt;\n  }\n  return cnt & 1;\n}\n\nstd::vector<Point> hull(std::vector<Point> vec) {\n  int n = vec.size(), k = 0;\n  if (n <= 1) return vec;\n  std::sort(vec.begin(), vec.end());\n  std::vector<Point> res(n << 1);\n  for (int i = 0; i < n; res[k++] = vec[i++])\n    while (k > 1 && ((res[k - 1] - res[k - 2]) ^ (vec[i] - res[k - 1])) <= eps)\n      --k;\n  for (int i = n - 2, t = k; ~i; res[k++] = vec[i--])\n    while (k > t && ((res[k - 1] - res[k - 2]) ^ (vec[i] - res[k - 1])) <= eps)\n      --k;\n  res.resize(k - 1);\n  return res;\n}\n\nstd::vector<std::vector<Point>> Poly, nxt;\n\ninline void split(std::vector<Point> vec, Point p, Point q) {\n  int cnt = 0, n = vec.size(), fl = 0;\n  std::vector<Point> it;\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    if (fabs((q - p).x * (vec[j] - vec[i]).y - (q - p).y * (vec[j] - vec[i]).x)\n         <= eps) {\n      if (onLine(vec[i], p, q)) fl = 1;\n      continue;\n    }\n    Point a = inter(p, q, vec[i], vec[j]);\n    if (a == vec[j]) continue;\n    if (onSeg(a, vec[i], vec[j])) ++cnt, it.emplace_back(a);\n  }\n\n  if (cnt != 2 || fl) {\n    for (int i = 0; i < n; ++i) {\n      if (toRight(p, vec[i], q)) {\n        double x = ang(vec[i] - p, q - p);\n        vec[i] = (p + (vec[i] - p).rot(x * 2));\n      }\n    }\n    vec = hull(vec);\n    nxt.emplace_back(vec);\n    return;\n  }\n\n  std::vector<Point> tr;\n  tr.emplace_back(it[0]), tr.emplace_back(it[1]);\n  for (int i = 0; i < n; ++i) {\n    if (toRight(p, q, vec[i])) tr.emplace_back(vec[i]);\n  }\n  tr = hull(tr);\n  nxt.emplace_back(tr);\n\n  tr.clear();\n  tr.emplace_back(it[0]), tr.emplace_back(it[1]);\n  for (int i = 0; i < n; ++i) {\n    if (toRight(p, vec[i], q)) {\n      double x = ang(vec[i] - p, q - p);\n      tr.emplace_back(p + (vec[i] - p).rot(x * 2));\n    }\n  }\n  tr = hull(tr);\n  nxt.emplace_back(tr);\n}\n\ninline void work(Point p, Point q) {\n  nxt.clear();\n  for (auto &x : Poly) split(x, p, q);\n  Poly = nxt;\n}\n\nint main() {\n  std::vector<Point> a;\n  a.emplace_back(Point(0, 0));\n  a.emplace_back(Point(100, 0));\n  a.emplace_back(Point(100, 100));\n  a.emplace_back(Point(0, 100));\n  Poly.emplace_back(a);\n\n  int n, m;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) {\n    Point p, q;\n    scanf(\"%lf%lf%lf%lf\", &p.x, &p.y, &q.x, &q.y);\n    work(p, q);\n  }\n\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; ++i) {\n    int ans = 0;\n    Point p;\n    scanf(\"%lf%lf\", &p.x, &p.y);\n    for (auto &x : Poly) if (inPoly1(x, p) == 1) ++ans;\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n```\n",
        "postTime": 1669965728,
        "uid": 86576,
        "name": "zlxFTH",
        "ccfLevel": 7,
        "title": "P4468 \u3010SCOI2007\u3011\u6298\u7eb8"
    }
]