[
    {
        "content": "## \u9898\u76ee\u5927\u610f\n\n\u7ed9\u5b9a\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u7ed9\u51fa $m$ \u6761\u8def\u5f84\uff0c\u8bd5\u5224\u65ad\u4e0b\u9762\u7684\u547d\u9898\u662f\u5426\u6210\u7acb\uff1a\n\n$m$ \u6761\u8def\u5f84\u4e2d\uff0c\u4efb\u610f\u4e24\u6761\u8def\u5f84\u7684\u70b9\u96c6\u7684\u4ea4\u96c6\u4e3a\u7a7a\uff0c\u6216\u8005\u4e00\u4e2a\u662f\u53e6\u4e00\u4e2a\u7684\u5b50\u96c6\u3002\n\n$1 \\leq n,m \\leq 10^5$\n\n## \u5410\u69fd\n\n\u8fd9\u4e2a\u4f5c\u4e1a\u9898\u600e\u4e48\u53c8\u662f\u4e00\u4e2a\u6570\u636e\u8303\u56f4\u3001\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u65f6\u9650\u51d1\u4e00\u8d77\u8d8a\u770b\u8d8a\u79bb\u8c31\u7684\u9898\u554a\n\n\u5148\u6709\u4e00\u4e2a $10^6$ \u7684\u5c0f\u5e38\u6570\u7ebf\u6027\u590d\u6742\u5ea6\u9898\u5f00 `10s`\uff0c\u8fd9\u53c8\u6574\u4e00\u4e2a $O(n \\alpha(n))$ \u7684\u5e76\u67e5\u96c6\u9898\u53ea\u5f00 $10^5$ \u8fd8\u5f00 `3s` \u7684...\n\n## \u9898\u76ee\u89e3\u6cd5\n\n\u4e0d\u96be\u53d1\u73b0\uff0c\u5305\u542b\u5173\u7cfb\u53ea\u53ef\u80fd\u662f\u77ed\u7684\u8def\u5f84\u88ab\u957f\u7684\u8def\u5f84\u5305\u542b\u3002\n\n\u90a3\u4e48\u6211\u4eec\u8003\u8651\u6309\u7167\u8def\u5f84\u957f\u5ea6\u4ece\u5c0f\u5230\u5927\u4e00\u6761\u4e00\u6761\u8def\u5f84\u8fb9\u52a0\u5165\u8fb9\u5224\u65ad\u3002\n\n\u8003\u8651\u5148\u5c06\u6811\u4e0a\u7684\u6240\u6709\u8fb9\u65ad\u5f00\uff0c\u6bcf\u52a0\u5165\u4e00\u6761\u8def\u5f84\u7684\u65f6\u5019\u5c31\u5c06\u8fd9\u6761\u8def\u5f84\u4e0a\u5305\u542b\u7684\u8fb9\u52a0\u5165\uff0c\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u8fde\u901a\u5757\u7684\u70b9\u6570\u3002\u4e0d\u96be\u53d1\u73b0\uff0c\u5982\u679c\u52a0\u5165\u4e00\u6761\u8def\u5f84\u540e\uff0c\u8fd9\u6761\u8def\u5f84\u6240\u5728\u8fde\u901a\u5757\u7684\u70b9\u6570\u4e0e\u5f53\u524d\u52a0\u5165\u7684\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u70b9\u6570\u4e0d\u540c\u65f6\uff0c\u5c31\u5fc5\u7136\u5b58\u5728\u4e00\u6761\u8def\u5f84\uff0c\u4e0e\u5f53\u524d\u52a0\u5165\u7684\u8fd9\u6761\u8def\u5f84\u4e0d\u6ee1\u8db3\u9898\u76ee\u6240\u7ed9\u547d\u9898\uff0c\u6b64\u65f6\u53ef\u4ee5\u5224\u5b9a\u4e0d\u6210\u7acb\u4e86\u3002\u5982\u679c\u52a0\u5165\u540e\u70b9\u6570\u76f8\u7b26\u5408\uff0c\u90a3\u4e48\u5f53\u524d\u5c31\u6ca1\u6709\u95ee\u9898\u3002\n\n\u5982\u679c\u5c06\u6240\u6709\u8def\u5f84\u90fd\u52a0\u5165\u4e86\u8fd8\u6ca1\u51fa\u73b0\u95ee\u9898\uff0c\u90a3\u4e48\u8fd9\u4e2a\u547d\u9898\u5c31\u53ef\u4ee5\u786e\u5b9a\u4e3a\u6b63\u786e\u7684\u4e86\u3002\n\n`Code`\uff1a\n\n```cpp\nconst int MAXN = 100010;\n\nint tot;\nint fi[MAXN];\nint ne[MAXN << 1];\nint to[MAXN << 1];\n\ninline void Link(int u, int v) {\n\ttot++;\n\tto[tot] = v;\n\tne[tot] = fi[u];\n\tfi[u] = tot;\n}\n\nint fa[MAXN];\nint dep[MAXN];\nint up[MAXN][20];\n\ninline void dfs(int x, int la) {\n\tdep[x] = dep[la] + 1, up[x][0] = fa[x] = la;\n\tfor(int i = 1; i < 20; i++)\n\t\tup[x][i] = up[up[x][i - 1]][i - 1];\n\tfor(int i = fi[x]; i; i = ne[i]) {\n\t\tint u = to[i];\n\t\tif(u == la) continue;\n\t\tdfs(u, x);\n\t}\n}\n\ninline int LCA(int x, int y) {\n\tif(dep[x] < dep[y]) swap(x, y);\n\tint k = dep[x] - dep[y];\n\tfor(int i = 0; i < 20; i++)\n\t\tif(k & (1 << i)) x = up[x][i];\n\tif(x == y) return x;\n\tfor(int i = 19; ~i; --i)\n\t\tif(up[x][i] != up[y][i])\n\t\t\tx = up[x][i], y = up[y][i];\n\treturn up[x][0];\n}\n\nstruct Path {\n\tint u, v, lca, len, id;\n\n\tinline void init(int i) {\n\t\tid = i, u = ri, v = ri, lca = LCA(u, v);\n\t\tlen = dep[u] + dep[v] - dep[lca] * 2;\n\t}\n\n\tfriend bool operator < (Path a, Path b) { return a.len < b.len; }\n}a[MAXN];\n\nstruct UFS {\n\tint fa[MAXN];\n\tint sz[MAXN];\n\n\tinline void init(int n) { for(int i = 1; i <= n; i++) fa[i] = i, sz[i] = 1; }\n\tinline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\tinline void Merge(int u, int v) {\n\t\tu = find(u), v = find(v);\n\t\tif(u == v) return ;\n\t\tfa[u] = v, sz[v] += sz[u];\n\t}\n}ufs;\n\ninline void Solve(Path x) {\n\tint u, d = dep[x.lca];\n\tu = ufs.find(x.u); while(dep[u] > d) ufs.Merge(u, fa[u]), u = ufs.find(u);\n\tu = ufs.find(x.v); while(dep[u] > d) ufs.Merge(u, fa[u]), u = ufs.find(u);\n\tif(x.len != ufs.sz[ufs.find(x.lca)] - 1) puts(\"No\"), exit(0);\n}\n\nint main() {\n\tint n = ri, m = ri;\n\tfor(int i = 1; i < n; i++) {\n\t\tint u = ri, v = ri;\n\t\tLink(u, v), Link(v, u);\n\t} dfs(1, 0);\n\tfor(int i = 1; i <= m; i++) a[i].init(i);\n\tsort(a + 1, a + 1 + m), ufs.init(n);\n\tfor(int i = 1; i <= m; i++) Solve(a[i]);\n\tputs(\"Yes\");\n\treturn 0;\n}\n```",
        "postTime": 1603110846,
        "uid": 20782,
        "name": "CYJian",
        "ccfLevel": 10,
        "title": "GL: Laminar Family \u9898\u89e3"
    },
    {
        "content": "\u642c\u8fd0\u4e00\u4e0b @CE_WA_TLE \u5927\u4ed9\u7684\u505a\u6cd5\u3002\r\n\r\n\u9996\u5148\u53d1\u73b0\u53ef\u4ee5\u5148\u5224\u94fe\u7684\u5e76\u5728\u6811\u4e0a\u662f\u5426\u662f\u82e5\u5e72\u6761\u72ec\u7acb\u7684\u94fe\uff0c\u5426\u5219\u4e00\u5b9a\u4e0d\u5408\u6cd5\u3002\u8fd9\u4e2a\u53ef\u4ee5 $O(n)$ \u968f\u673a\u6743\u503c\u540e\u6811\u4e0a\u5f02\u6216\u5dee\u5206\uff0c\u7136\u540e\u5224\u65ad\u6bcf\u4e2a\u70b9\u662f\u5426\u6709\u5c0f\u4e8e\u7b49\u4e8e $2$ \u6761\u76f8\u8fde\u7684\u8fb9\u88ab\u8986\u76d6\u3002\r\n\r\n\u7136\u540e\u8003\u8651\u95ee\u9898\u5168\u53d8\u6210\u94fe\u4e0a\u7684\u4e86\uff0c\u63a5\u4e0b\u6765\u505a\u5230\u7ebf\u6027\u5c31\u5bb9\u6613\u4e86\u3002\u7528\u6876\u6392\u5bf9\u94fe\u957f\u4ece\u5c0f\u5f80\u5927\u6392\u5e8f\uff0c\u7136\u540e\u6bcf\u6b21\u628a\u4e00\u6761\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u7528\u5e76\u67e5\u96c6\u7f29\u8d77\u6765\u5224\u4e00\u4e0b\u7f29\u540e\u7684\u8fd9\u4e2a\u96c6\u5408\u7684 $\\text{siz}$ \u4e0e\u5f53\u524d\u94fe\u7684\u70b9\u6570\u662f\u5426\u76f8\u7b49\u5c31\u53ef\u4ee5\u4e86\u3002\u56e0\u4e3a\u662f\u94fe\u4e0a\u5e76\u67e5\u96c6\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n)$\u3002\r\n\r\n\u4e24\u90e8\u5206\u52a0\u8d77\u6765\uff0c\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6 $O(n)$\u3002",
        "postTime": 1677849705,
        "uid": 120911,
        "name": "Lynkcat",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P6963 [NEERC2017]Laminar Family"
    },
    {
        "content": "## \u601d\u8def\uff1a\u6811\u94fe\u5256\u5206 + \u54c8\u5e0c\n\n### \u9898\u610f\n\n\u7ed9\u5b9a\u4e00\u68f5\u6811\u4e0e\u82e5\u5e72\u6761\u94fe\uff0c\u5224\u65ad\u662f\u5426\u6240\u6709\u7684\u94fe\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\u4e4b\u4e00\uff1a\n1. \u4e0e\u5176\u4ed6\u94fe\u4ea4\u96c6\u4e3a\u7a7a\uff0c\n2. \u5b8c\u5168\u5305\u542b\u6216\u88ab\u5305\u542b\u5728\u5176\u4ed6\u94fe\u4e2d\n\n### \u601d\u8def\n\n\u63d0\u4f9b\u4e00\u79cd\u4e0d\u4e00\u6837\u7684\u601d\u8def\uff0c\u5bf9\u4e8e\u6240\u6709\u7684\u94fe\u6309\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u8003\u8651\uff0c\u56e0\u4e3a\u957f\u5ea6\u5c0f\u7684\u94fe\u53ea\u80fd\u88ab\u5305\u542b\u6216\u8005\u4e0e\u5176\u4ed6\u94fe\u76f8\u79bb\u3002\u8003\u8651\u6309\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u5c06\u94fe\u52a0\u5165\u5230\u6811\u4e0a\uff0c\u52a0\u5165\u65f6\u67e5\u8be2\u8be5\u94fe\u6240\u8986\u76d6\u533a\u95f4\u5185\u662f\u5426\u5b58\u5728\u76f8\u540c\u79cd\u7c7b\u53ca\u6570\u91cf\u7684\u5176\u4ed6\u94fe\u3002\u8fd9\u4e2a\u5730\u65b9\u8003\u8651\u4e3a\u6bcf\u4e00\u6761\u94fe\u968f\u673a\u4e00\u4e2a\u5927\u54c8\u5e0c\u503c\uff0c\u52a0\u5165\u94fe\u65f6\u76f8\u5f53\u4e8e\u7ed9\u94fe\u8986\u76d6\u7684\u6bcf\u4e00\u4e2a\u70b9\u5f02\u6216\u4e0a\u6539\u94fe\u7684\u54c8\u5e0c\u503c\uff0c\u67e5\u8be2\u65f6\u67e5\u8be2\u533a\u95f4\u5185\u6240\u6709\u70b9\u7684\u54c8\u5e0c\u503c\u662f\u5426\u90fd\u76f8\u7b49\uff0c\u82e5\u5b58\u5728\u4e0d\u76f8\u7b49\u5219\u8bf4\u660e\u8be5\u533a\u95f4\u5185\u5b58\u5728\u4e0d\u540c\u79cd\u7c7b\u6216\u6570\u91cf\u7684\u5176\u4ed6\u94fe\uff0c\u5219\u4e0d\u6ee1\u8db3\u6761\u4ef6\u3002\n\n\u5173\u4e8e\u54c8\u5e0c\u89e3\u6cd5\u7684\u6b63\u786e\u6027\u8bc1\u660e\u53ef\u4ee5\u53c2\u8003\uff1a[https://codeforces.com/blog/entry/85900](https://codeforces.com/blog/entry/85900)\n\n### \u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<bits/stdc++.h>\n#define size size_\nusing namespace std;\n\nusing ull=unsigned long long;\n\nconst int N=(int)1e5+5;\nint CNT=-1;\n\null Ra(){\n    return (ull)rand()*(ull)rand()*(ull)rand()*(ull)rand()*(ull)rand()*(ull)rand();\n}\n\nint n,m;\nint u[N*2],v[N*2],nex[N*2],first[N];\nint size[N],son[N],fa[N],dep[N];\nint top[N],tot,id[N],pos[N],last[N];\nstruct seg{\n    int x;\n    int y;\n    int len;\n    ull h;\n}a[N];\nstruct tree{\n    int l;\n    int r;\n    ull sum;\n    int equal;\n    ull lz;\n}t[N<<2];\n\nvoid add(int x,int y){\n    CNT++;\n    u[CNT]=x;\n    v[CNT]=y;\n    nex[CNT]=first[u[CNT]];\n    first[u[CNT]]=CNT;\n}\n\nvoid build(int i,int l,int r){\n    t[i].l=l;\n    t[i].r=r;\n    t[i].lz=0;\n    t[i].equal=1;\n    if(l==r){\n        t[i].sum=1;\n        return;\n    }\n    int mid=l+r>>1;\n    build(i<<1,l,mid);\n    build(i<<1|1,mid+1,r);\n    t[i].sum=t[i<<1].sum+t[i<<1|1].sum;\n    return;\n}\n\nvoid build1(int i,int l,int r){\n    t[i].l=l;\n    t[i].r=r;\n    t[i].lz=0;\n    t[i].equal=1;\n    if(l==r){\n        t[i].sum=1;\n        return;\n    }\n    int mid=l+r>>1;\n    build1(i<<1,l,mid);\n    build1(i<<1|1,mid+1,r);\n    t[i].sum=1;\n    return;\n}\n\nvoid pushdown(int i){\n    if(t[i].lz){\n        ull k=t[i].lz;\n        if(t[i<<1].equal) t[i<<1].sum^=k;\n        if(t[i<<1|1].equal) t[i<<1|1].sum^=k;\n        t[i<<1].lz^=k;\n        t[i<<1|1].lz^=k;\n        t[i].lz=0;\n    }\n    return;\n}\n\nvoid add(int i,int l,int r,ull k){\n    if(t[i].l>=l&&t[i].r<=r){\n        if(t[i].equal) t[i].sum^=k;\n        t[i].lz^=k;\n        return;\n    }\n    pushdown(i);\n    if(t[i<<1].r>=l) add(i<<1,l,r,k);\n    if(t[i<<1|1].l<=r) add(i<<1|1,l,r,k);\n    if(t[i<<1].equal&&t[i<<1|1].equal&&t[i<<1].sum==t[i<<1|1].sum){\n        t[i].equal=1;\n        t[i].sum=t[i<<1].sum;\n    }\n    else t[i].equal=false;\n    return;\n}\n\npair<int,ull> search(int i,int l,int r){\n    if(t[i].l>=l&&t[i].r<=r) return {t[i].equal,t[i].sum};\n    pushdown(i);\n    if(t[i<<1].r>=l&&t[i<<1|1].l<=r){\n        pair<int,ull> node1=search(i<<1,l,r);\n        pair<int,ull> node2=search(i<<1|1,l,r);\n        if(node1.first&&node2.first) return {node1.second==node2.second,node1.second};\n        else return {0,0};\n    }\n    else if(t[i<<1].r>=l) return search(i<<1,l,r);\n    else return search(i<<1|1,l,r);\n}\n\null searchdis(int i,int l,int r){\n    if(t[i].l>=l&&t[i].r<=r) return t[i].sum;\n    pushdown(i);\n    int sum=0;\n    if(t[i<<1].r>=l) sum+=searchdis(i<<1,l,r);\n    if(t[i<<1|1].l<=r) sum+=searchdis(i<<1|1,l,r);\n    return sum;\n}\n\nvoid getson(int t,int f){\n    size[t]++;\n    fa[t]=f;\n    int k=first[t];\n    while(k!=-1){\n        if(v[k]!=f){\n            dep[v[k]]=dep[t]+1;\n            getson(v[k],t);\n            size[t]+=size[v[k]];\n            if(size[v[k]]>size[son[t]]) son[t]=v[k];\n        }\n        k=nex[k];\n    }\n}\n\nvoid dfs(int t,int f,int tp){\n    top[t]=tp;\n    id[t]=++tot;\n    pos[tot]=t;\n    if(son[t]) dfs(son[t],t,tp);\n    int k=first[t];\n    while(k!=-1){\n        if(v[k]!=son[t]&&v[k]!=f) dfs(v[k],t,v[k]);\n        k=nex[k];\n    }\n    last[t]=tot;\n}\n\nvoid addxy(int x,int y,ull k){\n    while(top[x]!=top[y]){\n        if(dep[top[x]]>dep[top[y]]) swap(x,y);\n        add(1,id[top[y]],id[y],k);\n        y=fa[top[y]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    add(1,id[x],id[y],k);\n}\n\nint equal(int x,int y){\n    pair<int,ull> sum={-1,0};\n    while(top[x]!=top[y]){\n        if(dep[top[x]]>dep[top[y]]) swap(x,y);\n        pair<int,ull> node=search(1,id[top[y]],id[y]);\n        if(sum.first==-1) sum=node;\n        else{\n            if(sum.first&&node.first) sum={sum.second==node.second,sum.second};\n            else sum={0,0};\n        }\n        y=fa[top[y]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    pair<int,ull> node=search(1,id[x],id[y]);\n    if(sum.first==-1) sum=node;\n    else{\n        if(sum.first&&node.first) sum={sum.second==node.second,sum.second};\n        else sum={0,0};\n    }\n    return sum.first;\n}\n\null dis(int x,int y){\n    ull sum=0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]>dep[top[y]]) swap(x,y);\n        sum+=searchdis(1,id[top[y]],id[y]);\n        y=fa[top[y]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    sum+=searchdis(1,id[x],id[y]);\n    return sum;\n}\n\nint main(){\n    srand(time(0));\n    memset(first,-1,sizeof(first));\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1,x,y;i<n;i++){\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&a[i].x,&a[i].y);\n        a[i].h=Ra();//\u4ea7\u751f\u54c8\u5e0c\u503c\n    }\n    getson(1,0);//\u6811\u5256\n    dfs(1,0,1);//\u6811\u5256\n    build(1,1,n);//\u6811\u5256\n    for(int i=1;i<=m;i++) a[i].len=(int)dis(a[i].x,a[i].y);//\u67e5\u8be2\u8ddd\u79bb\n    sort(a+1,a+1+m,[](const seg& a,const seg& b){\n        return a.len>b.len;\n    });//\u6309\u957f\u5ea6\u6392\u5e8f\n    build1(1,1,n);\n    for(int i=1;i<=m;i++){\n        if(!equal(a[i].x,a[i].y)) return printf(\"No\"),0;//\u67e5\u8be2\u533a\u95f4\u5185\u54c8\u5e0c\u503c\u662f\u5426\u76f8\u7b49\n        addxy(a[i].x,a[i].y,a[i].h);//\u52a0\u5165\u94fe\n    }\n    printf(\"Yes\");\n    return 0;\n}\n```\n",
        "postTime": 1639360124,
        "uid": 96720,
        "name": "Cupids_Bow",
        "ccfLevel": 0,
        "title": "P6963 [NEERC2017]Laminar Family"
    },
    {
        "content": "CYJ \u7684\u505a\u6cd5\u975e\u5e38 nb\uff0c\u6211\u8fd9\u91cc\u7ed9\u4e00\u4e2a\u6bd4\u8f83\u65e0\u8111\u7684\u5934\u94c1\u505a\u6cd5\u3002\n\n\u8003\u8651\u4e24\u6761\u8def\u5f84 $S_1,S_2$\uff0c\u8bbe\u5b83\u4eec\u7684 LCA \u5206\u522b\u4e3a $L_1,L_2$\u3002\n\n\u9996\u5148\u6709\u4e2a\u663e\u7136\u7684\u547d\u9898\uff1a\u4e24\u6761\u8def\u5f84\u70b9\u76f8\u4ea4\uff0c\u5f53\u4e14\u4ec5\u5f53\u5176\u4e2d\u4e00\u4e2a\u7684 LCA \u5728\u53e6\u4e00\u6761\u8def\u5f84\u4e0a\u3002\n\n\u63a5\u4e0b\u6765\u5bf9 $L_1,L_2$ \u5206\u7c7b\uff1a\n\n---\n\n$L_1\\ne L_2$\uff1a\n\n\u90a3\u4e48\u6211\u4eec\u5bf9\u6bcf\u6761\u8def\u5f84 $i$ \u5206\u522b\u7edf\u8ba1 $f(i)$ \u8868\u793a LCA \u5728 $S_i$ \u4e0a\u4e14\u4e0d\u4e3a $L_i$ \u7684\u8def\u5f84\u6570\u91cf\uff0c\u4ee5\u53ca $g(i)$ \u8868\u793a LCA \u4e0d\u4e3a $L_i$ \u4e14\u88ab $S_i$ \u5305\u542b\u7684\u8def\u5f84\u6570\u91cf\uff0c\u53ea\u8981 $f(i)\\ne g(i)$\uff0c\u7b54\u6848\u5c31\u662f `No`\u3002\n\n$f(i)$ \u7684\u8ba1\u7b97\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u6811\u4e0a\u5dee\u5206\uff0c\u800c $g(i)$ \u53ef\u4ee5\u901a\u8fc7\u4e00\u4e2a\u7ebf\u6bb5\u6811\u5408\u5e76\u6c42\u51fa\uff0c\u56e0\u4e3a\u8fd9\u6837\u88ab\u5305\u542b\u7684\u8def\u5f84\u80af\u5b9a\u662f\u4e00\u6bb5\u7956\u5148\u94fe\u3002\n\n---\n\n$L_1=L_2$\uff1a\n\n\u663e\u7136\u53ea\u6709\u957f\u7684\u8def\u5f84\u80fd\u5305\u542b\u77ed\u7684\u8def\u5f84\uff0c\u6240\u4ee5\u5c06 LCA \u76f8\u540c\u7684\u8def\u5f84\u6309\u7167\u957f\u5ea6\u6392\u5e8f\uff0c\u4f9d\u6b21\u68c0\u67e5\u540e\u4e00\u4e2a\u662f\u5426\u5305\u542b\u524d\u4e00\u4e2a\u5373\u53ef\u3002\n\n---\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n\\log n)$\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=100010;\nstruct Path {\n\tint u,v,l,dis,id;\n}p[MAXN];\nint n,m,x,y,eg,cnt,tot,val[MAXN],hd[MAXN],ver[2*MAXN],nx[2*MAXN],dp[MAXN];\nint dep[MAXN],f[MAXN][20],dfn[MAXN],ed[MAXN],rt[MAXN],sum[MAXN*200],ch[MAXN*200][2];\nvector <Path> v[MAXN];\nbool cmp (Path a,Path b) {return a.dis<b.dis;}\nvoid add_edge (int x,int y) {\n\tver[++eg]=y;\n\tnx[eg]=hd[x];\n\thd[x]=eg;\n\treturn;\n}\nvoid modify (int &p,int l,int r,int xl,int xr,int v) {\n\tif (xr<l||r<xl) {return;}\n\tif (!p) {p=++tot;}\n\tif (xl<=l&&r<=xr) {\n\t\tsum[p]+=v;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tmodify(ch[p][0],l,mid,xl,xr,v);\n\tmodify(ch[p][1],mid+1,r,xl,xr,v);\n\treturn;\n}\nint query (int p,int l,int r,int pos) {\n\tif (l==r) {return sum[p];}\n\tint mid=(l+r)>>1;\n\tif (pos<=mid) {return sum[p]+query(ch[p][0],l,mid,pos);}\n\telse {return sum[p]+query(ch[p][1],mid+1,r,pos);}\n}\nint merge (int x,int y) {\n\tif (!x||!y) {return x+y;}\n\tch[x][0]=merge(ch[x][0],ch[y][0]);\n\tch[x][1]=merge(ch[x][1],ch[y][1]);\n\tsum[x]=sum[x]+sum[y];\n\treturn x;\n}\nvoid dfs1 (int x,int fa) {\n\tdep[x]=dep[fa]+1,f[x][0]=fa,dfn[x]=ed[x]=++cnt;\n\tfor (int i=1;i<=18;i++) {f[x][i]=f[f[x][i-1]][i-1];}\n\tfor (int i=hd[x];i;i=nx[i]) {\n\t\tif (ver[i]==fa) {continue;}\n\t\tdfs1(ver[i],x);\n\t\ted[x]=ed[ver[i]];\n\t}\n\treturn;\n}\nvoid dfs2 (int x,int fa) {\n\tdp[x]+=dp[fa];\n\tfor (int i=hd[x];i;i=nx[i]) {\n\t\tif (ver[i]==fa) {continue;}\n\t\tdfs2(ver[i],x);\n\t\trt[x]=merge(rt[x],rt[ver[i]]);\n\t}\n\tint len=v[x].size();\n\tfor (int i=0;i<len;i++) {\n\t\tPath tmp=v[x][i];\n\t\tval[tmp.id]-=query(rt[x],1,n,dfn[tmp.u])+query(rt[x],1,n,dfn[tmp.v]);\n\t}\n\tfor (int i=0;i<len;i++) {\n\t\tPath tmp=v[x][i];\n\t\tif (tmp.u==tmp.l) {modify(rt[x],1,n,dfn[tmp.v],ed[tmp.v],1);}\n\t}\n\treturn;\n}\nint query_lca (int x,int y) {\n\tif (dep[x]<dep[y]) {swap(x,y);}\n\tfor (int i=18;i>=0;i--) {\n\t\tif (dep[x]-(1<<i)>=dep[y]) {x=f[x][i];}\n\t}\n\tif (x==y) {return x;}\n\tfor (int i=18;i>=0;i--) {\n\t\tif (f[x][i]!=f[y][i]) {x=f[x][i],y=f[y][i];}\n\t}\n\treturn f[x][0];\n}\nint query_anc (int x,int y) {return (dfn[y]<=dfn[x]&&ed[x]<=ed[y]);}\nint main () {\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n-1;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd_edge(x,y),add_edge(y,x);\n\t}\n\tdfs1(1,0);\n\tfor (int i=1;i<=m;i++) {\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif (dep[x]>dep[y]) {swap(x,y);}\n\t\tp[i].u=x,p[i].v=y,p[i].l=query_lca(x,y);\n\t\tp[i].dis=dep[x]+dep[y]-2*dep[p[i].l],p[i].id=i;\n\t\tv[p[i].l].push_back(p[i]),dp[p[i].l]++;\n\t}\n\tdfs2(1,0);\n\tfor (int i=1;i<=m;i++) {\n\t\tval[i]+=dp[p[i].u]+dp[p[i].v]-2*dp[p[i].l];\n\t\tif (val[i]) {\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) {\n\t\tsort(v[i].begin(),v[i].end(),cmp);\n\t\tint len=v[i].size();\n\t\tfor (int j=1;j<len;j++) {\n\t\t\tif ((query_anc(v[i][j].u,v[i][j-1].u)&&query_anc(v[i][j].v,v[i][j-1].v))||\n\t\t\t\t(query_anc(v[i][j].u,v[i][j-1].v)&&query_anc(v[i][j].v,v[i][j-1].u))) {continue;}\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tprintf(\"Yes\\n\");\n\treturn 0;\n}\n```\n",
        "postTime": 1623912637,
        "uid": 113546,
        "name": "ix35",
        "ccfLevel": 10,
        "title": "[NEERC2017]Laminar Family \u9898\u89e3"
    },
    {
        "content": "\u6392\u5e8f + \u7ebf\u6bb5\u6811 + \u6811\u5256\n\n\u4e0d\u5f97\u4e0d\u8bf4\u8fd9\u9053\u9898\u6d89\u53ca\u5230\u7684\u64cd\u4f5c\u8fd8\u662f\u633a\u591a\u7684\uff0c\u6211\u8c03\u4e86\u4e00\u4e2a\u591a\u5c0f\u65f6\u545c\u545c\u3002\n\n## \u5206\u6790\n\n\u9996\u5148\u6211\u4eec\u6309\u7167\u5c06\u9898\u76ee\u6240\u7ed9\u7684\u8def\u5f84\u5b58\u5165 `q[]` \u4e2d\u5e76\u6309\u7167**\u957f\u5ea6**\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u7136\u540e\u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d `q[]`\uff0c\u5bf9\u4e8e\u5f53\u524d\u7684\u8def\u5f84\uff0c\u6211\u4eec\u53ea\u9700\u8981\u770b\u770b\u5b83\u662f\u5426\u88ab\u5176\u4ed6\u8def\u5f84\u5305\u542b\u5373\u53ef\u3002\n\n\u5177\u4f53\u6765\u8bf4\u6211\u4eec\u53ef\u4ee5\u5bf9\u8def\u5f84\u8fdb\u884c\u67d3\u8272\uff0c\u7136\u540e\u770b\u770b\u5f53\u524d\u8def\u5f84\u662f\u5426\u5177\u6709\u540c\u4e00\u79cd\u989c\u8272\uff0c\u8fd9\u4e2a\u64cd\u4f5c\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811 + \u6811\u5256\u6765\u89e3\u51b3\u3002\n\n```cpp\n// #pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define debug(x) cerr << #x << \": \" << x << endl\n\n#define set0(a) memset(a,0,sizeof(a))\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n\nusing pii = pair<int, int>;\n\n#define x first\n#define y second\n\ninline void read(int &x) {\n    int s=0;x=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') {if(ch=='-')x=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9') s=(s<<3)+(s<<1)+ch-'0',ch=getchar();\n    x*=s;\n}\n\nconst int N=1e5+5, M=N<<1;\n\nint n, m;\n\nstruct Edge{\n\tint to, next;\n}e[M];\n\nint h[N], tot;\n\nvoid add(int u, int v){\n\te[tot].to=v, e[tot].next=h[u], h[u]=tot++;\n}\n\nint son[N], fa[N], dep[N], sz[N];\nint top[N], id[N], idx;\n\nvoid dfs(int u, int father, int depth){\n\tfa[u]=father, dep[u]=depth, sz[u]=1;\n\tfor(int i=h[u]; ~i; i=e[i].next){\n\t\tint go=e[i].to;\n\t\tif(go==father) continue;\n\t\tdfs(go, u, depth+1);\n\t\tsz[u]+=sz[go];\n\t\tif(sz[go]>sz[son[u]]) son[u]=go;\n\t}\t\n}\n\nvoid dfs2(int u, int t){\n\tid[u]=++idx, top[u]=t;\n\tif(!son[u]) return;\n\tdfs2(son[u], t);\n\tfor(int i=h[u]; ~i; i=e[i].next){\n\t\tint go=e[i].to;\n\t\tif(go==fa[u] || go==son[u]) continue;\n\t\tdfs2(go, go);\n\t}\n}\n\nint lca(int u, int v){\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u, v);\n\t\tu=fa[top[u]];\n\t}\n\treturn dep[u]>dep[v]? v: u;\n}\n\nint dis(int u, int v){\n\treturn dep[u]+dep[v]-2*dep[lca(u, v)];\n}\n\nstruct Msg{\n\tint l, r;\n\tbool operator < (const Msg &o)const{\n\t\treturn dis(l, r)>dis(o.l, o.r);\n\t}\n}q[N];\n\n// ======================== segment tree op ==========================\n\nstruct Node{\n\tint l, r;\n\tint v, same;\n\tint tag;\n\t\n\t#define ls u<<1\n\t#define rs u<<1|1\n}tr[N<<2];\n\nvoid pushup(int u){\n\tif(!tr[ls].l) tr[u].same=tr[rs].same;\n\telse if(!tr[rs].l) tr[u].same=tr[ls].same;\n\telse{\n\t\tif(tr[ls].same && tr[rs].same && tr[ls].v==tr[rs].v) tr[u].same=1;\n\t\telse tr[u].same=0;\n\t}\n\ttr[u].v=max(tr[ls].v, tr[rs].v);\n}\n\nvoid pushdown(int u){\n\tif(tr[u].tag){\n\t\tauto &L=tr[ls], &R=tr[rs];\n\t\tL.same=1, L.v=tr[u].tag, L.tag=tr[u].tag;\n\t\tR.same=1, R.v=tr[u].tag, R.tag=tr[u].tag;\n\t\ttr[u].tag=0;\n\t}\n}\n\nvoid build(int u, int l, int r){\n\ttr[u]={l, r, 0, 1, 0};\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tbuild(ls, l, mid), build(rs, mid+1, r);\n}\n\nvoid upd(int u, int l, int r, int k){\n\tif(l<=tr[u].l && tr[u].r<=r){\n\t\ttr[u].tag=k;\n\t\ttr[u].v=k, tr[u].same=1;\n\t\treturn;\n\t}\n\tint mid=tr[u].l+tr[u].r>>1;\n\tpushdown(u);\n\tif(l<=mid) upd(ls, l, r, k);\n\tif(mid<r) upd(rs, l, r, k);\n\tpushup(u);\n}\n\npii query(int u, int l, int r){\n\tif(l<=tr[u].l && tr[u].r<=r) return {tr[u].same, tr[u].v};\n\tint mid=tr[u].l+tr[u].r>>1;\n\tint same=1, v=-1;\n\tpii L={-1, -1}, R={-1, -1};\n\tpushdown(u);\n\tif(l<=mid){\n\t\tL=query(ls, l, r);\n\t\tsame&=L.x;\n\t\tv=max(v, L.y);\n\t}\n\tif(mid<r){\n\t\tR=query(rs, l, r);\n\t\tsame&=R.x;\n\t\tv=max(v, R.y);\n\t}\n\tif(~L.y && ~R.y && L.y!=R.y) same=0;\n\treturn {same, v};\n}\n\n// ========================= end of seg tree =============================\n\nbool qsame(int u, int v){\n\tset<int> st;\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u, v);\n\t\tauto t=query(1, id[top[u]], id[u]);\n\t\tif(!t.x) return false;\n\t\tst.insert(t.y);\n\t\tu=fa[top[u]]; \n\t}\n\tif(dep[u]<dep[v]) swap(u, v);\n\tauto t=query(1, id[v], id[u]);\n\tif(!t.x) return false;\n\tst.insert(t.y);\n\t\n\treturn st.size()==1;\n}\n\nvoid assign(int u, int v, int col){\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u, v);\n\t\tupd(1, id[top[u]], id[u], col);\n\t\tu=fa[top[u]]; \n\t}\n\tif(dep[u]<dep[v]) swap(u, v);\n\tupd(1, id[v], id[u], col);\n}\n\nint main(){\n\tmemset(h, -1, sizeof h);\n\tread(n), read(m);\n\trep(i,1,n-1){\n\t\tint u, v; read(u), read(v);\n\t\tadd(u, v), add(v, u); // \u5efa\u6811\n\t}\n\t\n\tdfs(1, -1, 1), dfs2(1, 1); // \u6811\u5256\n\tbuild(1, 1, n); // \u5efa\u7ebf\u6bb5\u6811\n\t\n\trep(i,1,m){\n\t\tint u, v; read(u), read(v);\n\t\tq[i]={u, v}; // \u8bb0\u5f55\u6240\u6709\u8def\u5f84\n\t}\n\t\n\tsort(q+1, q+1+m); // \u6309\u7167\u8def\u5f84\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\n\n\tbool ok=true;\n\t\n\trep(i,1,m){\n\t\tint u=q[i].l, v=q[i].r;\n\t\tif(!qsame(u, v)){ // \u5982\u679c\u5f53\u524d\u8def\u5f84\u4e0d\u662f\u540c\u8272\u7684\uff0cok = false\n\t\t\tok=false;\n\t\t\tbreak;\n\t\t}\n\t\tassign(u, v, i); // \u5bf9\u8def\u5f84\u8fdb\u884c\u67d3\u8272\u4fee\u6539\n\t}\n\n\tputs(ok? \"Yes\": \"No\");\n\t\n\treturn 0;\n}\n```",
        "postTime": 1633345485,
        "uid": 138960,
        "name": "Tenshi",
        "ccfLevel": 0,
        "title": "[NEERC2017]Laminar Family"
    },
    {
        "content": "\u96be\u9053\u6811\u4e0a\u9898\u4e0d\u5e94\u8be5\u5148\u8003\u8651\u6811\u5256\u5417\uff1f\n\n\u663e\u7136\u5c0f\u7684\u533a\u95f4\u53ea\u80fd\u88ab\u6bd4\u5b83\u957f\u7684\u533a\u95f4\u5b8c\u5168\u8986\u76d6\u3002\n\n\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u5c06\u6bcf\u4e2a\u533a\u95f4\u6309\u957f\u5ea6\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u904d\u5386\u5230\u7684\u6bcf\u4e00\u4e2a\u533a\u95f4\uff0c\u8be2\u95ee\u8fd9\u4e2a\u533a\u95f4\u662f\u5426\u53ea\u6709\u4e00\u79cd\u989c\u8272\u3002\n\n\u5177\u4f53\u5c31\u662f\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5927\u503c\u548c\u6700\u5c0f\u503c\u662f\u5426\u76f8\u7b49\uff0c\u6811\u5256\u5373\u53ef\u3002\n\n\u7136\u540e\u5c31\u6ca1\u6709\u5176\u4ed6\u7684\u4e86\u3002\n\n\u4ee3\u7801\u5b9e\u73b0\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define NO return puts(\"No\"),0;\n#define YES return puts(\"Yes\"),0;\nusing namespace std;\nconst int MAXN=1e6+5;\nconst int INF=0x7f7f7f7f;\nstruct node\n{\n\tint to,nxt;\n}e[MAXN];\nint head[MAXN],cnt;\ninline void add(int x,int y)\n{\n\te[++cnt].to=y;\n\te[cnt].nxt=head[x];\n\thead[x]=cnt;\n}\nstruct period\n{\n\tint x,y;\n}q[MAXN];\nint n,f;\nint fa[MAXN],siz[MAXN],dep[MAXN],hson[MAXN];\ninline void dfs1(int x,int f)\n{\n\tfa[x]=f;\n\tdep[x]=dep[f]+1;\n\tsiz[x]=1;\n\tint maxson=-1;\n\tfor(register int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y==f)continue;\n\t\tdfs1(y,x);\n\t\tsiz[x]+=siz[y];\n\t\tif(siz[y]>maxson)\n\t\t{\n\t\t\tmaxson=siz[y];\n\t\t\thson[x]=y;\n\t\t}\n\t}\n}\nint top[MAXN],id[MAXN],tim;\ninline void dfs2(int x,int ltop)\n{\n\tid[x]=++tim;\n\ttop[x]=ltop;\n\tif(!hson[x])return;\n\tdfs2(hson[x],ltop);\n\tfor(register int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint y=e[i].to;\n\t\tif(y==hson[x]||y==fa[x])continue;\n\t\tdfs2(y,y);\n\t}\n}\nint maxn[MAXN],minn[MAXN],dat[MAXN];\ninline void pushup(int p)\n{\n\tmaxn[p]=max(maxn[p<<1],maxn[p<<1|1]);\n\tminn[p]=min(minn[p<<1],minn[p<<1|1]);\n}\ninline void addtag(int p,int k)\n{\n\tmaxn[p]=minn[p]=dat[p]=k;\n}\ninline void pushdown(int p)\n{\n\tif(dat[p])\n\t{\n\t\taddtag(p<<1,dat[p]);\n\t\taddtag(p<<1|1,dat[p]);\n\t\tdat[p]=0;\n\t}\n}\ninline void change(int p,int l,int r,int a,int b,int k)\n{\n\tif(r<a||l>b)return;\n\tif(l>=a&&r<=b)\n\t{\n\t\taddtag(p,k);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tpushdown(p);\n\tchange(p<<1,l,mid,a,b,k);\n\tchange(p<<1|1,mid+1,r,a,b,k);\n\tpushup(p);\n}\ninline int ask_max(int p,int l,int r,int a,int b)\n{\n\tif(r<a||l>b)return -INF;\n\tif(l>=a&&r<=b)return maxn[p];\n\tint mid=(l+r)>>1;\n\tpushdown(p);\n\treturn max(ask_max(p<<1,l,mid,a,b),ask_max(p<<1|1,mid+1,r,a,b));\n}\ninline int ask_min(int p,int l,int r,int a,int b)\n{\n\tif(r<a||l>b)return INF;\n\tif(l>=a&&r<=b)return minn[p];\n\tint mid=(l+r)>>1;\n\tpushdown(p);\n\treturn min(ask_min(p<<1,l,mid,a,b),ask_min(p<<1|1,mid+1,r,a,b));\n}\ninline void change_ran(int x,int y,int k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tchange(1,1,n,id[top[x]],id[x],k);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tchange(1,1,n,id[x],id[y],k);\n}\ninline int ask_ran_max(int x,int y)\n{\n\tint ans=-INF;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=max(ans,ask_max(1,1,n,id[top[x]],id[x]));\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tans=max(ans,ask_max(1,1,n,id[x],id[y]));\n\treturn ans;\n}\ninline int ask_ran_min(int x,int y)\n{\n\tint ans=INF;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=min(ans,ask_min(1,1,n,id[top[x]],id[x]));\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tans=min(ans,ask_min(1,1,n,id[x],id[y]));\n\treturn ans;\n}\ninline int lca(int x,int y)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\treturn x;\n}\ninline int dist(int x,int y)\n{\n\treturn dep[x]+dep[y]-2*dep[lca(x,y)];\n}\ninline bool cmp(period a,period b)\n{\n\treturn dist(a.x,a.y)>dist(b.x,b.y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&f);\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tfor(register int i=1;i<=f;i++)\n\t\tscanf(\"%d%d\",&q[i].x,&q[i].y);\n\tsort(q+1,q+1+f,cmp);\n\tfor(register int i=1;i<=f;i++)\n\t{\n\t\tint mx=ask_ran_max(q[i].x,q[i].y),mn=ask_ran_min(q[i].x,q[i].y);\n\t\tif(mx!=mn)NO\n\t\tchange_ran(q[i].x,q[i].y,++col);\n\t}\n\tYES\n}\n```",
        "postTime": 1658494970,
        "uid": 126871,
        "name": "yzh_Error404",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P6963 \u3010Laminar Family\u3011"
    },
    {
        "content": "### [\u539f\u9898\u94fe\u63a5](https://www.luogu.com.cn/problem/P6963)\n\n~~\u53c8\u662f\u5145\u5206\u53d1\u626c\u4eba\u7c7b\u667a\u6167~~\n\n## \u9898\u76ee\u5206\u6790\n\n\u770b\u5230\u9898\u53d1\u73b0\u4e0d\u4f1a\u505a\uff0c\u6240\u4ee5\u8003\u8651\u4e71\u641e\u3002\n\n\u60f3\u8c61\u4e00\u4e0b\uff1a\u5728\u4e00\u6761\u94fe\u4e0a\uff08\u5047\u8bbe\u5176\u957f\u5ea6\u4e3a $len$\uff09\uff0c\u7ed9\u7aef\u70b9\u52a0\u4e0a $-len+1$\uff0c\u7ed9\u5176\u5b83\u70b9\u52a0\u4e0a $1$\u3002\u90a3\u4e48\u6574\u6761\u94fe\u7684\u548c\u5c31\u662f $0$\u3002\u6211\u4eec\u79f0\u7ecf\u8fc7\u8fd9\u4e9b\u5904\u7406\u7684\u94fe\u4e3a\u5173\u952e\u94fe\u3002\n\n\u90a3\u4e48\uff0c\u5982\u679c\u67d0\u6761\u94fe\u5305\u542b\u4e86\u4e00\u6761\u5173\u952e\u94fe\uff0c\u6216\u8005\u4e0e\u5176\u4e0d\u76f8\u4ea4\uff0c\u90a3\u4e48\u8be5\u5173\u952e\u94fe\u5bf9\u8fd9\u6761\u94fe\u7684\u8d21\u732e\u5c31\u662f $0$\u3002\n\n\u7531\u4e8e\u76f8\u4e92\u5305\u542b\u4e0d\u592a\u597d\u5904\u7406\uff0c\u6240\u4ee5\u6211\u4eec\u5148\u5c06\u6240\u6709 $m$ \u6761\u94fe\u6309\u7167\u957f\u5ea6\u4ece\u5c0f\u5230\u5927\u5904\u7406\uff0c\u4f9d\u6b21\u5c06\u5176\u52a0\u5165\u5173\u952e\u94fe\u4e2d\u3002\u56e0\u4e3a\u53ea\u53ef\u80fd\u957f\u5ea6\u5927\u7684\u5305\u542b\u957f\u5ea6\u5c0f\u7684\uff0c\u6240\u4ee5\u73b0\u5728\u53ea\u7528\u8003\u8651\u5f53\u524d\u5904\u7406\u7684\u94fe\u5305\u542b\u5173\u952e\u94fe\u7684\u60c5\u51b5\u4e86\u3002\n\n\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u5bf9\u6240\u6709\u5904\u7406\u8fc7\u7684\u94fe\u8fdb\u884c\u4e86\u4e0a\u6587\u7684\u64cd\u4f5c\uff0c\u73b0\u5728\u67e5\u8be2\u5f53\u524d\u94fe\u7684\u70b9\u6743\u548c\u3002\u6211\u4eec\u53d1\u73b0\uff1a\n\n* \u5982\u679c\u5f53\u524d\u94fe\u4e0e\u5173\u952e\u94fe\u90fd\u4e0d\u76f8\u4ea4\u6216\u8005\u5305\u542b\uff0c\u90a3\u4e48\u7ed3\u679c**\u4e00\u5b9a**\u662f $0$\uff1b\n\n* \u5426\u5219\uff0c\u7ed3\u679c**\u4e0d\u4e00\u5b9a**\u662f $0$\u3002\n\n\u53d1\u73b0\u6240\u6709\u7ed3\u679c\u90fd\u662f $0$ \u662f\u9898\u76ee\u6240\u7ed9\u547d\u9898\u6210\u7acb\u7684\u5fc5\u8981\u6761\u4ef6\uff0c\u4f46\u4e0d\u5145\u5206\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528\u968f\u673a\u5316\u4ec0\u4e48\u7684\u4e71\u641e\u3002\n\n1. \u4e0d\u8981\u6bcf\u6761\u5173\u952e\u94fe\u53ea\u52a0 $1$\uff0c\u53ef\u4ee5\u52a0\u4e0a\u4e00\u4e2a\u968f\u673a\u6570 $rand$\uff0c\u8fd9\u6837\u53ef\u4ee5\u5927\u5927\u51cf\u5c0f\u9519\u8bef\u6982\u7387\uff1b\n\n2. \u53ef\u4ee5\u4f7f\u7528\u591a\u6b21\u54c8\u5e0c\uff0c\u51cf\u5c0f\u9519\u8bef\u6982\u7387\uff08\u4f46\u662f\u4e0d\u7528\u8c8c\u4f3c\u4e5f\u8fc7\u4e86\uff09\u3002\n\n\u7136\u540e\u52a8\u6001\u7684\u94fe\u4e0a\u52a0\u3001\u6c42\u548c\u90fd\u53ef\u4ee5\u7528\u6811\u5256\u505a\uff0c\u8fd9\u9898\u5c31\u2026\u2026\u6ca1\u4e86\u3002\n\n## \u4ee3\u7801\u5b9e\u73b0\n\n\u867d\u7136\u4ee3\u7801\u6bd4\u8f83\u957f\uff0c\u4f46\u662f\u5927\u90e8\u5206\u90fd\u662f\u6811\u5256\u677f\u5b50\uff0c\u6240\u4ee5\u4e5f\u4e0d\u7e41\u6742\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n/*\n\u7701\u7565100\u591a\u884c\u7684\u5feb\u8bfb\u5feb\u5199\u4ee3\u7801\n\u5373\u4e0b\u6587\u4e2d\u7684qin\u3001qout\n*/\n\ntypedef long long LL;\nint n,m;\nstruct Edge{ int to,nxt; }e[200005];\nint cnt,head[100005];\ninline void addEdge(int u,int v)\n\t{ e[++cnt]=(Edge){v,head[u]},head[u]=cnt; }\nint dfn,siz[100005],dep[100005],lb[100005],top[100005],son[100005],fa[100005];\nvoid dfs1(int u,int ffa=0)\n{\n\tsiz[u]=1,dep[u]=dep[ffa]+1,fa[u]=ffa;\n\tfor(int i=head[u],v;v=e[i].to;i=e[i].nxt)\n\t\tif(v!=ffa)\n\t\t{\n\t\t\tdfs1(v,u),siz[u]+=siz[v];\n\t\t\tif(siz[v]>siz[son[u]])\tson[u]=v;\n\t\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp,lb[u]=++dfn;\n\tif(son[u])\tdfs2(son[u],tp);\n\tfor(int i=head[u],v;v=e[i].to;i=e[i].nxt)\n\t\tif(v!=fa[u] && v!=son[u])\n\t\t\tdfs2(v,v);\n}\nint lca(int x,int y)\n{\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy)\n\t\tif(dep[fx]>=dep[fy])\n\t\t\tx=fa[fx],fx=top[x];\n\t\telse\n\t\t\ty=fa[fy],fy=top[y];\n\treturn dep[x]<dep[y]?x:y;\n}\nstruct F$$k\n{\n\tint u,v,len;\n\tinline bool operator <(const F$$k &b)const\n\t\t{ return len<b.len; }\n}a[100005];\nmt19937 mt_rnd(time(0));\n\nstruct TreeNode{ LL sum,tag;int lc,rc; }t[200005];\nint tot,rt;\n#define LC t[i].lc\n#define RC t[i].rc\ninline void addTag(int i,int x,int len)\n\t{ t[i].sum+=1ll*x*len,t[i].tag+=x; }\ninline void pushup(int i)\n\t{ t[i].sum=t[LC].sum+t[RC].sum; }\ninline void pushdown(int i,int l,int r)\n{\n\tif(!t[i].tag)\treturn;\n\tint mid=(l+r)>>1;\n\taddTag(LC,t[i].tag,mid-l+1);\n\taddTag(RC,t[i].tag,r-mid);\n\tt[i].tag=0;\n}\nvoid build(int l,int r,int &i=rt)\n{\n\ti=++tot;\n\tif(l!=r)\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,LC),build(mid+1,r,RC);\n\t}\n}\nvoid modify(int lq,int rq,int x,int i=rt,int l=1,int r=n)\n{\n\tif(l>=lq && r<=rq)\taddTag(i,x,r-l+1);\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tpushdown(i,l,r);\n\t\tif(mid>=lq)\tmodify(lq,rq,x,LC,l,mid);\n\t\tif(mid<rq)\tmodify(lq,rq,x,RC,mid+1,r);\n\t\tpushup(i);\n\t}\n}\nLL query(int lq,int rq,int i=rt,int l=1,int r=n)\n{\n\tif(l>=lq && r<=rq)\treturn t[i].sum;\n\telse\n\t{\n\t\tLL mid=(l+r)>>1,res=0;\n\t\tpushdown(i,l,r);\n\t\tif(mid>=lq)\tres+=query(lq,rq,LC,l,mid);\n\t\tif(mid<rq)\tres+=query(lq,rq,RC,mid+1,r);\n\t\treturn res;\n\t}\n}\ninline int treeQuery(int x,int y)\n{\n\tint fx=top[x],fy=top[y];\n\tLL res=0;\n\twhile(fx!=fy)\n\t\tif(dep[fx]>=dep[fy])\n\t\t\tres+=query(lb[fx],lb[x]),x=fa[fx],fx=top[x];\n\t\telse\n\t\t\tres+=query(lb[fy],lb[y]),y=fa[fy],fy=top[y];\n\tif(lb[x]<=lb[y])\n\t\tres+=query(lb[x],lb[y]);\n\telse\n\t\tres+=query(lb[y],lb[x]);\n\treturn res;\n}\ninline void treeModify(int x,int y,int v)\n{\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy)\n\t\tif(dep[fx]>=dep[fy])\n\t\t\tmodify(lb[fx],lb[x],v),x=fa[fx],fx=top[x];\n\t\telse\n\t\t\tmodify(lb[fy],lb[y],v),y=fa[fy],fy=top[y];\n\tif(lb[x]<=lb[y])\n\t\tmodify(lb[x],lb[y],v);\n\telse\n\t\tmodify(lb[y],lb[x],v);\n}\ninline void gao(const F$$k &zt)\n{\n\tint u=zt.u,v=zt.v;\n\tLL val=mt_rnd()%100+1;\n\ttreeModify(u,v,val);\n\tif(mt_rnd()&1)\tswap(u,v);\n\ttreeModify(u,u,-val*(zt.len+1));\n}\n\nint main()\n{\n\tint u,v;\n\tqin>>n>>m;\n\tfor(int i=1;i<n;i++)\tqin>>u>>v,addEdge(u,v),addEdge(v,u);\n\tdfs1(1),dfs2(1,1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tqin>>u>>v,a[i].u=u,a[i].v=v;\n\t\tint l=lca(u,v);\n\t\ta[i].len=dep[u]+dep[v]-2*dep[l];\n\t}\n\tsort(a+1,a+m+1);\n\tbuild(1,n);\n\tbool flag=true;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tu=a[i].u,v=a[i].v;\n\t\tint res1=treeQuery(u,v);\n\t\tif(res1)\t{ flag=false;break; }\n\t\tgao(a[i]);\n\t}\n\tqout<<(flag?\"Yes\":\"No\");\n//\treturn qout.flush(),0;\n}\n```\n",
        "postTime": 1644243514,
        "uid": 279800,
        "name": "ExplodingKonjac",
        "ccfLevel": 7,
        "title": "\u3010\u9898\u89e3\u3011P6963 [NEERC2017]Laminar Family"
    }
]