[
    {
        "content": "\u672c\u6765\u662f\u60f3\u7740\u597d\u50cf\u53ef\u4ee5\u5728\u865a\u6811\u4e0a\u70b9\u5206\u6cbb\u6765\u505a\u4e00\u4e9b\u4e0d\u662f\u5f88\u597d\u8ba1\u7b97\u7684\u4e1c\u897f\uff1f\n\n\u7136\u540e\u672c\u6765\u60f3\u51fa\u4e00\u9053\u5728\u865a\u6811\u4e0a\u70b9\u5206\u6cbb+FFT\u6765\u6c42\u4e00\u4e0b\u7279\u5b9a\u957f\u5ea6\u7684\u8def\u5f84\uff1f\u7ed3\u679c\u53d1\u73b0\u8fd9\u4e1c\u897f\u5957\u5728\u865a\u6811\u4e0a\u590d\u6742\u5ea6\u4e0d\u5bf9\u3002\n\n\u7136\u540e\u5c31\u51fa\u70b9\u6811\u5f62dp\u4e0d\u597d\u505a\u7684\u4e1c\u897f\u2026\u2026\u7136\u540e\u7531\u4e8e\u5957\u4e86\u865a\u6811\u6240\u4ee5\u53ef\u4ee5\u5e26\u4fee\u6539\u2026\u2026\u7136\u540e\u2026\u2026\n\n~~\u7136\u540e\u5c31\u53d8\u5f97\u975e\u5e38\u7801\u519c~~\n\n\u7136\u540e\u5c31\u6709\u4e86\u8fd9\u4e2a\u9898\uff1a\u6811\u4e0a\u591a\u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u7ed9\u5b9a\u4e00\u4e9b\u5173\u952e\u70b9\uff0c\u9700\u8981\u7edf\u8ba1\u51fa\u6bcf\u4e2a\u5173\u952e\u70b9\u5230\u5176\u4ed6\u5173\u952e\u70b9\u7684\u6240\u6709\u8def\u5f84\u4e0a\u7684\u989c\u8272\u6bb5\u6570\u4e4b\u548c\u3002\n\n\u9996\u5148\u662f\u8be2\u95ee\u7684\u603b\u70b9\u6570\u548c$n$\u540c\u9636\uff0c\u9a6c\u4e0a\u5c31\u80fd\u770b\u51fa\u662f\u865a\u6811\u3002\n\n\u7136\u540e\u5c31\u662f\u5728\u865a\u6811\u4e0a\u7edf\u8ba1\u7b54\u6848\uff0c\u4e0a\u70b9\u5206\u6cbb\u3002\n\n\u8003\u8651\u600e\u4e48\u7edf\u8ba1\u7ecf\u8fc7\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3\u7684\u8def\u5f84\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u3002\n\n\u5bf9\u4e8e\u5206\u6cbb\u4e2d\u5fc3\u7684\u4e00\u68f5\u5b50\u6811\uff0c\u6211\u4eec\u73b0\u5728\u53ea\u7edf\u8ba1\u7ecf\u8fc7\u4e2d\u5fc3\u7684\u8def\u5f84\u7684\u8d21\u732e\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6c42\u51fa\u4ece\u4e2d\u5fc3\u51fa\u53d1\u8fdb\u5165\u5176\u4ed6\u5b50\u6811\u7684\u8def\u5f84\u7684\u603b\u8d21\u732e\uff0c\u7136\u540e\u6211\u4eec$dfs$\u8fd9\u68f5\u5b50\u6811\uff0c\u67d0\u4e2a\u8282\u70b9\u7684\u7b54\u6848\u53ea\u9700\u8981\u628a\u4e2d\u5fc3\u90a3\u8fb9\u7684\u7b54\u6848\u63a5\u4e0a\u4e2d\u5fc3\u5230\u5f53\u524d\u70b9\u7684\u90a3\u4e00\u6bb5\u8def\u5f84\u7684\u8d21\u732e\u5373\u53ef\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u7edf\u8ba1\u51fa\u6240\u6709\u70b9\u7684\u7b54\u6848\u3002\u5bf9\u4e8e\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3\uff0c\u5b83\u81ea\u5df1\u7684\u7b54\u6848\u8981\u52a0\u4e0a\u4ece\u5b83\u51fa\u53d1\u5411\u5b83\u6240\u5728\u5206\u6cbb\u5757\u5185\u7684\u8def\u5f84\u7684\u8d21\u732e\u3002\n\n\u5728\u865a\u6811\u4e0a\u8fd8\u8981\u6ce8\u610f\uff0c\u53ea\u80fd\u7edf\u8ba1\u8be2\u95ee\u70b9\u7684\u7b54\u6848\uff0c\u6709\u4e00\u4e9b\u8be2\u95ee\u70b9\u7684lca\u4e5f\u5728\u865a\u6811\u4e0a\u4f46\u4e0d\u80fd\u7ed9\u5176\u4ed6\u8be2\u95ee\u70b9\u7b97\u8d21\u732e\u3002\u7136\u540e\u7531\u4e8e\u865a\u6811\u4e0a\u7684\u8fb9\u5e26\u8868\u539f\u6811\u4e0a\u7684\u4e00\u6761\u94fe\uff0c\u6240\u4ee5\u865a\u6811\u4e0a\u7684\u8fb9\u6743\u662f\u539f\u6811\u4e0a\u90a3\u6761\u94fe\u4e0a\u7684\u989c\u8272\u6bb5\u6570\u3002\n\n\u7136\u540e\u6211\u4eec\u518d\u5199\u4e2a\u6811\u94fe\u5256\u5206\u6765\u6c42lca\u3001\u94fe\u4fee\u6539\u3001\u94fe\u67e5\u8be2\u989c\u8272\u6bb5\u6570\u3002\n\n\u7136\u540e\u5c31\u6ca1\u6709\u7136\u540e\u4e86\uff0c~~\u7801\u5427~~\u3002\n\n\u590d\u6742\u5ea6$O((\\sum m)\\log^2n)$\u3002\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\n#define lc x<<1\n#define rc x<<1|1\n#define For(i,_beg,_end) for(int i=(_beg),i##end=(_end);i<=i##end;++i)\n#define Rep(i,_beg,_end) for(int i=(_beg),i##end=(_end);i>=i##end;--i)\n\ntemplate<typename T>T Max(const T &x,const T &y){return x<y?y:x;}\ntemplate<typename T>T Min(const T &x,const T &y){return x<y?x:y;}\ntemplate<typename T>int chkmax(T &x,const T &y){return x<y?(x=y,1):0;}\ntemplate<typename T>int chkmin(T &x,const T &y){return x>y?(x=y,1):0;}\ntemplate<typename T>void read(T &x){\n    T f=1;char ch=getchar();\n    for(;ch<'0'||ch>'9';ch=getchar())if(ch=='-')f=-1;\n    for(x=0;ch>='0'&&ch<='9';ch=getchar())x=x*10+ch-'0';\n    x*=f;\n}\n\ntypedef long long LL;\nconst int maxn=100010,inf=0x7fffffff;\nstruct edge{\n    int to,nxt,len;\n}e[maxn<<1];\nstruct Data{\n    int cl,cr,sum;\n    Data(){cl=cr=sum=0;}\n    Data(int l,int r,int s){cl=l;cr=r;sum=s;}\n    friend Data operator+(const Data &x,const Data &y){\n        if(!x.cl)return y;\n        if(!y.cl)return x;\n        return Data(x.cl,y.cr,x.sum+y.sum-(x.cr==y.cl));\n    }\n}T[maxn<<2];\nint n,m,q,num,head[maxn],sum,root,f[maxn],size[maxn];\nint c[maxn],dfn[maxn],cnt,tp[maxn];\nint anc[maxn],son[maxn],dep[maxn],rnk,pos[maxn],id[maxn];\nint sta[maxn],top,h[maxn],sq[maxn],tag[maxn<<2];\nLL ans[maxn],tot,all,path;\nbool vis[maxn],is[maxn];\n\nvoid addedge(int,int,int);\nvoid Dfs1(int,int);\nvoid Dfs2(int,int,int);\nint Lca(int,int);\nvoid Build(int,int,int);\nvoid pushsame(int,int);\nvoid pushdown(int);\nData Query(int,int,int,int,int);\nvoid Modify(int,int,int,int,int,int);\nint Query(int,int);\nvoid Change(int,int,int);\n\nbool comp(int,int);\nvoid Build(void);\n\nvoid get(int,int);\nvoid get_sum(int,int);\nvoid get_root(int,int);\nvoid Dfs(int,int,int);\nvoid Modify(int,int,int);\nvoid Calc(int);\nvoid Solve(int);\n\nint main(){\n    read(n);read(q);\n    For(i,1,n) read(c[i]);\n    For(i,1,n-1){\n        int u,v;\n        read(u);read(v);\n        addedge(u,v,0);\n    }\n    Dfs1(1,0);Dfs2(1,0,1);\n    Build(1,1,n);\n    int op,u,v,col;\n    while(q--){\n        read(op);\n        if(op==1){\n            read(u);read(v);read(col);\n            Change(u,v,col);\n        }\n        else{\n            read(m);\n            For(i,1,m){\n                read(h[i]);\n                is[h[i]]=true;\n                sq[i]=h[i];\n            }\n            Build();Solve(1);\n            For(i,1,m) is[sq[i]]=false;\n            For(i,1,m) printf(\"%lld \",ans[sq[i]]),ans[sq[i]]=0;\n            putchar(10);\n        }\n    }\n    return 0;\n}\n\nvoid Calc(int x){\n    get(x,0);path=size[x];\n    Dfs(x,tot=0,1);all=tot;\n    if(is[x]) ans[x]+=tot;\n    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){\n        tot=0;\n        Dfs(e[i].to,x,e[i].len+1);\n        all-=tot;path-=size[e[i].to];\n        Modify(e[i].to,x,e[i].len);\n        all+=tot;path+=size[e[i].to];\n    }\n    vis[x]=true;\n}\nvoid Solve(int x){\n    Calc(x);\n    for(int i=head[x];i;i=e[i].nxt) if(!vis[e[i].to]){\n        f[sum=root=0]=inf;\n        get_sum(e[i].to,0);\n        get_root(e[i].to,0);\n        Solve(root);\n    }\n    vis[x]=false;\n}\nvoid Modify(int x,int fa,int lst){\n    if(is[x]) ans[x]+=all+1LL*lst*path;\n    for(int i=head[x];i;i=e[i].nxt){\n        if(e[i].to==fa||vis[e[i].to]) continue;\n        Modify(e[i].to,x,lst+e[i].len);\n    }\n}\nvoid Dfs(int x,int fa,int lst){\n    if(is[x]) tot+=lst;\n    for(int i=head[x];i;i=e[i].nxt){\n        if(e[i].to==fa||vis[e[i].to]) continue;\n        Dfs(e[i].to,x,lst+e[i].len);\n    }\n}\nvoid get(int x,int fa){\n    size[x]=is[x];\n    for(int i=head[x];i;i=e[i].nxt){\n        if(e[i].to==fa||vis[e[i].to]) continue;\n        get(e[i].to,x);\n        size[x]+=size[e[i].to];\n    }\n}\nvoid get_sum(int x,int fa){\n    sum++;\n    for(int i=head[x];i;i=e[i].nxt){\n        if(e[i].to==fa||vis[e[i].to]) continue;\n        get_sum(e[i].to,x);\n    }\n}\nvoid get_root(int x,int fa){\n    f[x]=0;size[x]=1;\n    for(int i=head[x];i;i=e[i].nxt){\n        if(e[i].to==fa||vis[e[i].to]) continue;\n        get_root(e[i].to,x);\n        size[x]+=size[e[i].to];\n        chkmax(f[x],size[e[i].to]);\n    }\n    chkmax(f[x],sum-size[x]);\n    if(f[x]<f[root]) root=x;\n}\n\nvoid addedge(int u,int v,int w){\n    e[++num].to=v;e[num].len=w;e[num].nxt=head[u];head[u]=num;\n    e[++num].to=u;e[num].len=w;e[num].nxt=head[v];head[v]=num;\n}\nvoid Dfs1(int x,int fa){\n    size[x]=1;dep[x]=dep[fa]+1;\n    dfn[x]=++cnt;anc[x]=fa;\n    for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa){\n        Dfs1(e[i].to,x);\n        size[x]+=size[e[i].to];\n        if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;\n    }\n}\nvoid Dfs2(int x,int fa,int up){\n    tp[x]=up;id[++rnk]=x;pos[x]=rnk;\n    if(son[x]) Dfs2(son[x],x,up);\n    for(int i=head[x];i;i=e[i].nxt)\n        if(e[i].to!=fa&&e[i].to!=son[x])\n            Dfs2(e[i].to,x,e[i].to);\n}\nint Lca(int u,int v){\n    int fx=tp[u],fy=tp[v];\n    while(fx!=fy){\n        if(dep[fx]>dep[fy]) fx=tp[u=anc[fx]];\n        else fy=tp[v=anc[fy]];\n    }\n    return dep[u]<dep[v]?u:v;\n}\nvoid Build(int x,int l,int r){\n    if(l==r)return T[x]=Data(c[id[l]],c[id[l]],1),void();\n    int mid=(l+r)>>1;\n    Build(lc,l,mid);Build(rc,mid+1,r);\n    T[x]=T[lc]+T[rc];\n}\nvoid pushsame(int x,int col){\n    tag[x]=col;\n    T[x]=Data(col,col,1);\n}\nvoid pushdown(int x){\n    if(tag[x]){\n        pushsame(lc,tag[x]);\n        pushsame(rc,tag[x]);\n        tag[x]=0;\n    }\n}\nData Query(int x,int l,int r,int ql,int qr){\n    if(l>=ql&&r<=qr)return T[x];\n    int mid=(l+r)>>1;pushdown(x);\n    if(ql<=mid&&qr>mid)return Query(lc,l,mid,ql,qr)+Query(rc,mid+1,r,ql,qr);\n    else if(ql<=mid)return Query(lc,l,mid,ql,qr);\n    else return Query(rc,mid+1,r,ql,qr);\n}\nvoid Modify(int x,int l,int r,int ql,int qr,int col){\n    if(l>=ql&&r<=qr)return pushsame(x,col),void();\n    int mid=(l+r)>>1;pushdown(x);\n    if(ql<=mid) Modify(lc,l,mid,ql,qr,col);\n    if(qr>mid) Modify(rc,mid+1,r,ql,qr,col);\n    T[x]=T[lc]+T[rc];\n}\nint Query(int u,int v){\n    Data res;\n    int fx=tp[u],fy=tp[v];\n    while(fx!=fy){\n        res=Query(1,1,n,pos[fx],pos[u])+res;\n        fx=tp[u=anc[fx]];\n    }\n    res=Query(1,1,n,pos[v],pos[u])+res;\n    return res.sum-1;\n}\nvoid Change(int u,int v,int col){\n    int fx=tp[u],fy=tp[v];\n    while(fx!=fy){\n        if(dep[fx]>dep[fy]){\n            Modify(1,1,n,pos[fx],pos[u],col);\n            fx=tp[u=anc[fx]];\n        }\n        else{\n            Modify(1,1,n,pos[fy],pos[v],col);\n            fy=tp[v=anc[fy]];\n        }\n    }\n    if(dep[u]>dep[v]) swap(u,v);\n    Modify(1,1,n,pos[u],pos[v],col);\n}\n\nbool comp(int x,int y){return dfn[x]<dfn[y];}\nvoid Build(){\n    sort(h+1,h+m+1,comp);\n    num=head[sta[top=1]=1]=0;\n    For(i,h[1]==1?2:1,m){\n        int lca=Lca(h[i],sta[top]);\n        if(lca!=sta[top]){\n            while(dfn[sta[top-1]]>dfn[lca]){\n                addedge(sta[top],sta[top-1],Query(sta[top],sta[top-1]));\n                top--;\n            }\n            if(sta[top-1]!=lca){\n                head[lca]=0;\n                addedge(sta[top],lca,Query(sta[top],lca));\n                sta[top]=lca;\n            }\n            else addedge(sta[top],lca,Query(sta[top],lca)),top--;\n        }\n        head[h[i]]=0;\n        sta[++top]=h[i];\n    }\n    For(i,1,top-1) addedge(sta[i+1],sta[i],Query(sta[i+1],sta[i]));\n}\n```",
        "postTime": 1519193064,
        "uid": 20176,
        "name": "Salamander",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4242 \u3010\u6811\u4e0a\u7684\u6bd2\u7624\u3011"
    },
    {
        "content": "## \u9898\u76ee\u5927\u610f\n\n\u4e00\u9897 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u70b9\u90fd\u6709\u81ea\u5df1\u7684\u6743\u503c $c$ \u3002\u8fdb\u884c $q$ \u6b21\u64cd\u4f5c\uff0c\u64cd\u4f5c\u6709\u4e24\u79cd\u3002\n\n\u4e00\u79cd\u662f\u6539\u53d8\u4e24\u4e2a\u8282\u70b9\u8def\u5f84\u4e4b\u95f4\u8282\u70b9\u7684\u6743\u503c\u3002\n\n\u4e00\u79cd\u662f\u67e5\u8be2\u7ed9\u5b9a\u70b9\u96c6\u4e2d\uff0c\u6240\u6709\u70b9\u5230\u5176\u4ed6\u70b9\u7684\u989c\u8272\u6bb5\u6570\u548c\u3002\n\n$n , q \\leq 10^5 $ , $\\sum m \\leq 2\\times 10^5$\n\n\n## \u9898\u89e3\n\n[\u5728\u535a\u5ba2\u56ed\u83b7\u5f97\u66f4\u4f73\u9605\u8bfb\u4f53\u9a8c](https://www.cnblogs.com/orzpls/p/15170015.html)\n\n\u53c8\u662f\u8d85\u7ea7\u96be\u5199\u9898\u3002\n\n\u4e2a\u4eba\u8ba4\u4e3a\u8fd9\u9053\u9898\u7684\u601d\u8def\u5176\u5b9e\u662f\u5f88\u7b80\u5355\u7684\u3002\n\n\u9996\u5148\u4f60\u8981\u4f1a\u6c42\u989c\u8272\u6bb5\u6570\uff0c\u8fd9\u4e2a\u5f88\u7b80\u5355\u5bf9\u5427\uff0c\u5c31\u76f4\u63a5\u6811\u5256\u52a0\u4e0a\u7ebf\u6bb5\u6811\u5c31\u5b8c\u4e8b\u4e86\uff0c\u4e5f\u5c31\u662f [\u8fd9\u9053\u9898](https://www.luogu.com.cn/problem/P2486) \u3002\n\n\u7136\u540e\u4f1a\u4e86\u8fd9\u4e2a\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u6c42\u51fa\u6811\u4e0a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u7684\u989c\u8272\u6bb5\u6570\u3002\n\n\u9996\u5148\u8fd9\u9898\u8fd8\u662f\u8001\u5957\u8def\u7684\u865a\u6811\u6a21\u5f0f\uff0c\u76f4\u63a5\u5148\u5efa\u51fa\u865a\u6811\u6765\u3002\n\n\u8003\u8651\u600e\u4e48\u505a\u9898\uff0c\u6211\u4eec\u8003\u8651\u662f\u80af\u5b9a\u8981\u8bbe\u7acb\u4e00\u4e2a dp \u3002\n\n\u4f46\u662f\u73b0\u5728\u6ca1\u5565\u601d\u8def\uff0c\u6211\u4eec\u5c31\u53bb\u770b\u770b\u5efa\u51fa\u6765\u7684\u865a\u6811\u3002\n\n\u8fd9\u4e2a\u6811\u4f60\u80af\u5b9a\u8981\u7ed9\u4ed6\u8d4b\u4e00\u4e2a\u8fb9\u6743\u4f46\u662f\u8fb9\u6743\u600e\u4e48\u8d4b\u503c\uff1f\n\n\u4f60\u8003\u8651\u4e0b\u56fe\u3002\n\n\u6211\u4eec\u5e0c\u671b\u505a\u5230\u7684\u662f\u70b9 $1$ \u5230\u70b9 $2$ \u7684\u8fb9\u6743\u52a0\u4e0a\u70b9 $2$ \u5230\u70b9 $3$ \u7684\u8fb9\u6743\u4e4b\u95f4\u662f\u6709\u67d0\u79cd\u5173\u7cfb\u7684\uff0c\u6700\u597d\u662f\u80fd\u76f8\u7b49\u7684\u3002\n\n\u4f46\u662f\u56e0\u4e3a\u53ef\u80fd\u7236\u4eb2\u7684\u989c\u8272\u6bb5\u4e0e\u7236\u4eb2\u7684\u7236\u4eb2\u4ea7\u751f\u51b2\u7a81\uff0c\u8fd9\u4e2a\u662f\u4f1a\u6709\u5f71\u54cd\u7684\u3002\n\n\u90a3\u6211\u4eec\u76f4\u63a5\u4e0d\u7ba1\u7236\u4eb2\u7684\u989c\u8272\u6bb5\uff0c\u5c06\u8fb9\u6743\u8bbe\u4e3a\u4e24\u70b9\u989c\u8272\u6bb5\u6570\u51cf\u53bb $1$ \u3002\n\n\u6700\u540e\u9700\u8981\u7528\u7684\u65f6\u5019\u6211\u4eec\u5728\u52a0\u4e0a $1$ \u5c31\u597d\u4e86\u3002\n\n\u7136\u540e\u8fd9\u4e2a\u4e1c\u897f\u5c31\u5f88\u5bf9\u4e86\u3002\n\n\u90a3\u4e48\u4e00\u6761\u8def\u5f84\u7684\u6743\u503c\u5c31\u662f\u8fb9\u6743\u548c\u52a0\u4e0a $1$ \u3002\n\n\u7136\u540e\u4f60\u8fd9\u4e2a\u65f6\u5019\u5728\u7edf\u8ba1\u8def\u5f84\u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u7ecf\u5178\u7684\u6362\u6839 dp \u3002\n\n\u7136\u540e\u4f60\u8003\u8651\u4f60\u4e00\u4e2a\u70b9\u5411 $m$ \u4e2a\u70b9\u627e\u8def\u5f84\u90a3\u4f60\u5c31\u52a0\u4e0a $m$ \u5c31\u597d\u4e86\u3002\n\n\u7136\u540e\u5c31\u7528\u6811\u5256\u52a0\u4e0a\u6362\u6839 dp \u5199\u5b8c\u4e86\u8fd9\u9053\u9898\u3002\n\n![](https://z3.ax1x.com/2021/08/25/hZsmo4.png)\n\n```cpp\nconst int N = 3e5;\nint n, q, m, num, cnt, c[N], siz[N], dep[N], f[N], son[N], top[N];\nint dfn[N], col[N], dfn2[N], tot, aske[N], mark[N], id[N];\nvector<int> ver[N], p[N];\nvoid dfs1(int x, int fa) {\n  siz[x] = 1;\n  dfn2[x] = ++tot;\n  dep[x] = dep[fa] + 1;\n  f[x] = fa;\n  for (int i = 0; i < ver[x].size(); i++) {\n    int to = ver[x][i];\n    if (to == fa)\n      continue;\n    dfs1(to, x);\n    siz[x] += siz[to];\n    if (siz[to] > siz[son[x]])\n      son[x] = to;\n  }\n}\nvoid dfs2(int now, int x) {\n  top[now] = x;\n  dfn[now] = ++cnt;\n  col[cnt] = c[now];\n  if (son[now])\n    dfs2(son[now], x);\n  for (int i = 0; i < ver[now].size(); i++) {\n    int to = ver[now][i];\n    if (to == f[now] || to == son[now])\n      continue;\n    dfs2(to, to);\n  }\n}\nint LCA(int x, int y) {\n  while (top[x] != top[y]) {\n    if (dep[top[x]] <= dep[top[y]])\n      y = f[top[y]];\n    else\n      x = f[top[x]];\n  }\n  return dep[x] < dep[y] ? x : y;\n}\nint s[N], tag[N];\nint ls(int p) { return p << 1; }\nint rs(int p) { return p << 1 | 1; }\nvoid push_up(int p, int mid) {\n  s[p] = s[ls(p)] + s[rs(p)];\n  if (col[mid] == col[mid + 1])\n    s[p]--;\n}\nvoid pushdown(int p, int mid) {\n  tag[ls(p)] = tag[rs(p)] = tag[p];\n  col[mid] = col[mid + 1] = tag[p];\n  s[ls(p)] = 1, s[rs(p)] = 1;\n  tag[p] = 0;\n}\nvoid build(int p, int l, int r) {\n  if (l == r) {\n    s[p] = 1;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(ls(p), l, mid), build(rs(p), mid + 1, r);\n  push_up(p, mid);\n}\nvoid update(int p, int l, int r, int nx, int ny, int k) {\n  if (nx <= l and r <= ny) {\n    s[p] = 1;\n    col[l] = col[r] = tag[p] = k;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (tag[p])\n    pushdown(p, mid);\n  if (nx <= mid)\n    update(ls(p), l, mid, nx, ny, k);\n  if (ny > mid)\n    update(rs(p), mid + 1, r, nx, ny, k);\n  push_up(p, mid);\n}\nint ask(int p, int l, int r, int nx, int ny) {\n  if (nx <= l && r <= ny)\n    return s[p];\n  int mid = (l + r) >> 1, ans = 0;\n  if (tag[p])\n    pushdown(p, mid);\n  if (nx <= mid)\n    ans = ask(ls(p), l, mid, nx, ny);\n  if (ny > mid)\n    ans += ask(rs(p), mid + 1, r, nx, ny);\n  if (nx <= mid && ny > mid) {\n    if (col[mid] == col[mid + 1])\n      ans--;\n  }\n  return ans;\n}\nvoid addtree(int x, int y, int val) {\n  while (top[x] != top[y]) {\n    if (dep[top[x]] < dep[top[y]])\n      swap(x, y);\n    update(1, 1, n, dfn[top[x]], dfn[x], val);\n    x = f[top[x]];\n  }\n  if (dep[x] > dep[y])\n    swap(x, y);\n  update(1, 1, n, dfn[x], dfn[y], val);\n}\nint asktree(int x, int y) {\n  int ans = 0, u = x, v = y;\n  while (top[x] != top[y]) {\n    if (dep[top[x]] < dep[top[y]])\n      swap(x, y);\n    ans = (ans + ask(1, 1, n, dfn[top[x]], dfn[x]));\n    x = f[top[x]];\n  }\n  if (dep[x] > dep[y])\n    swap(x, y);\n  ans = (ans + ask(1, 1, n, dfn[x], dfn[y]));\n  while (top[u] != top[v]) {\n    if (dep[top[u]] < dep[top[v]])\n      swap(u, v);\n    if (col[dfn[top[u]]] == col[dfn[f[top[u]]]])\n      --ans;\n    u = f[top[u]];\n  }\n  return ans;\n}\nint cmp(int x, int y) { return dfn2[x] < dfn2[y]; }\nint dp[N], dp2[N], sz[N];\nvoid get1(int x) {\n  if (mark[x])\n    sz[x] = 1;\n  else\n    sz[x] = 0;\n  dp[x] = 0;\n  for (int i = 0; i < p[x].size(); i++) {\n    int to = p[x][i];\n    int val = asktree(to, x) - 1;\n    get1(to);\n    sz[x] += sz[to];\n    dp[x] += dp[to] + val * sz[to];\n  }\n}\nvoid get2(int x) {\n  for (int i = 0; i < p[x].size(); i++) {\n    int to = p[x][i];\n    int val = asktree(to, x) - 1;\n    dp2[to] = dp2[x] + (m - 2 * sz[to]) * val;\n    get2(to);\n  }\n}\nsigned main() {\n  n = read(), q = read();\n  for (int i = 1; i <= n; i++)\n    c[i] = read();\n  for (int i = 1; i < n; i++) {\n    int a = read(), b = read();\n    ver[a].push_back(b);\n    ver[b].push_back(a);\n  }\n  dfs1(1, 0);\n  dfs2(1, 1);\n  build(1, 1, n);\n  while (q--) {\n    int op = read();\n    if (op == 1) {\n      int u = read(), v = read(), y = read();\n      addtree(u, v, y);\n    } else {\n      m = read();\n      for (int i = 1; i <= m; i++)\n        aske[i] = read(), mark[aske[i]] = 1, id[i] = aske[i];\n      sort(aske + 1, aske + m + 1, cmp);\n      num = m;\n      for (int i = 2; i <= m; i++) {\n        int lca = LCA(aske[i], aske[i - 1]);\n        if (lca != aske[i] && lca != aske[i - 1])\n          aske[++num] = lca;\n      }\n      sort(aske + 1, aske + num + 1);\n      num = unique(aske + 1, aske + num + 1) - (aske + 1);\n      sort(aske + 1, aske + num + 1, cmp);\n      for (int i = 2; i <= num; i++) {\n        int lca = LCA(aske[i], aske[i - 1]);\n        p[lca].push_back(aske[i]);\n      }\n      get1(aske[1]);\n      dp2[aske[1]] = dp[aske[1]];\n      get2(aske[1]);\n      for (int i = 1; i <= m; i++)\n        write(dp2[id[i]] + m), putc(' ');\n      putc('\\n');\n      for (int i = 1; i <= num; i++)\n        p[aske[i]].clear(), mark[aske[i]] = 0, dp2[aske[i]] = 0,\n                            dp[aske[i]] = 0, sz[aske[i]] = 0, id[i] = 0;\n    }\n  }\n  flush();\n  return 0;\n}\n\n```\n",
        "postTime": 1629890007,
        "uid": 206021,
        "name": "Pitiless0514",
        "ccfLevel": 7,
        "title": "P4242\u6811\u4e0a\u7684\u6bd2\u7624"
    },
    {
        "content": "\u6811\u4e0a\u95ee\u9898\u5168\u5bb6\u6876\u3002\n\n\u4ee5\u7ed9\u51fa\u7684\u70b9\u96c6\u5efa\u51fa\u865a\u6811\uff0c\u7136\u540e\u95ee\u9898\u8f6c\u5316\u4e3a\u5bf9\u6bcf\u4e2a\u5173\u952e\u70b9\uff0c\u6c42\u5176\u5230\u5176\u4ed6\u5173\u952e\u70b9\u7684\u865a\u6811\u94fe\u4e0a\u989c\u8272\u6bb5\u6570\u4e4b\u548c\u3002\n\n\u6ce8\u610f\u865a\u6811\u7684\u4e00\u6761\u8fb9\u662f\u539f\u6811\u7684\u4e00\u6761\u94fe\uff0c\u6240\u4ee5\u865a\u6811\u67d0\u6761\u94fe\u4e0a\u7684\u989c\u8272\u6bb5\u6570\u5e76\u4e0d\u662f\u7b80\u5355\u7684\u865a\u6811\u4e0a\u8fd9\u4e9b\u70b9\u5f62\u6210\u7684\u989c\u8272\u6bb5\u6570\u3002\n\n\u6240\u4ee5\u4ee4\u865a\u6811\u7684\u8fb9\u6743\u4e3a\u5176\u5728\u539f\u6811\u4e0a\u5bf9\u5e94\u7684\u94fe\u4e0a\u7684\u989c\u8272\u6bb5\u6570 $-1$\uff0c\u5219\u6b64\u65f6\u865a\u6811\u67d0\u6761\u94fe\u4e0a\u7684\u989c\u8272\u6bb5\u6570\u4e3a\u5176\u8fb9\u6743\u548c $+1$\u3002\n\n\u9700\u8981\u7ef4\u62a4\u94fe\u63a8\u5e73\uff0c\u5efa\u865a\u6811\u65f6\u9700\u8981\u67e5\u8be2\u94fe\u4e0a\u989c\u8272\u6bb5\u6570 $-1$ \u4f5c\u4e3a\u8fb9\u6743\uff0c\u6811\u5256\u5957\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e4b\u3002\n\n\u7136\u540e\u95ee\u9898\u8f6c\u5316\u4e3a\u5bf9\u6bcf\u4e2a\u5173\u952e\u70b9\uff0c\u6c42\u5176\u5230\u5176\u4ed6\u5173\u952e\u70b9\u7684\u865a\u6811\u94fe\u8fb9\u6743\u548c $+1$ \u4e4b\u548c\uff0c\u865a\u6811\u4e0a\u70b9\u5206\u6cbb\u7ef4\u62a4\u4e4b\u3002\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nstruct H\n{\n    struct E\n    {\n        int v, w, t;\n    } e[200050];\n    int c, h[100050];\n    void A(int u, int v, int w)\n    {\n        e[++c] = {v, w, h[u]};\n        h[u] = c;\n    }\n} T, V;\nbool e[100050], E[100050];\nlong long A, G[100050];\nint n, m, p, o, r, l, w[100050], g[100050], h[100050], a[100050], z[100050], d[100050], f[100050],\n    s[100050], t[100050], b[100050], k[100050], S[100050], P[100050], Z[100050], W[100050];\nbool C(int x, int y) { return b[x] < b[y]; }\nvoid X(int u)\n{\n    s[u] = 1;\n    for (int i = T.h[u], v; i; i = T.e[i].t)\n        if (!d[v = T.e[i].v])\n        {\n            d[v] = d[f[v] = u] + 1;\n            X(v);\n            s[u] += s[v];\n            if (s[v] > s[z[u]])\n                z[u] = v;\n        }\n}\nvoid Y(int u, int g)\n{\n    t[k[b[u] = ++p] = u] = g;\n    if (z[u])\n        Y(z[u], g);\n    for (int i = T.h[u],\n             v;\n         i; i = T.e[i].t)\n        if ((v = T.e[i].v) != f[u] && v != z[u])\n            Y(v, v);\n}\nint L(int x, int y)\n{\n    while (t[x] != t[y])\n    {\n        if (d[t[x]] < d[t[y]])\n            swap(x, y);\n        x = f[t[x]];\n    }\n    return d[x] < d[y] ? x : y;\n}\nstruct N\n{\n    int p, q, v;\n};\nstruct O\n{\n    N v;\n    int z;\n} R[100050 << 2];\nN operator+(N a, N b) { return {a.p, b.q, a.v + b.v - (a.q == b.p)}; }\nvoid U(int p) { R[p].v = R[p << 1].v + R[p << 1 | 1].v; }\nvoid F(int p, int x)\n{\n    R[p].z = R[p].v.p = R[p].v.q = x;\n    R[p].v.v = 1;\n}\nvoid D(int p)\n{\n    if (~R[p].z)\n        F(p << 1, R[p].z), F(p << 1 | 1, R[p].z), R[p].z = -1;\n}\nvoid B(int s, int t, int p)\n{\n    R[p].z = -1;\n    if (s == t)\n        return (void)(R[p].v.p = R[p].v.q = a[k[s]], R[p].v.v = 1);\n    int m = s + t >> 1;\n    B(s, m, p << 1);\n    B(m + 1, t, p << 1 | 1);\n    U(p);\n}\nvoid M(int l, int r, int x, int s, int t, int p)\n{\n    if (l <= s && t <= r)\n        return F(p, x);\n    D(p);\n    int m = s + t >> 1;\n    if (l <= m)\n        M(l, r, x, s, m, p << 1);\n    if (r > m)\n        M(l, r, x, m + 1, t, p << 1 | 1);\n    U(p);\n}\nN Q(int l, int r, int s, int t, int p)\n{\n    if (l <= s && t <= r)\n        return R[p].v;\n    D(p);\n    int m = s + t >> 1;\n    if (l <= m && r > m)\n        return Q(l, r, s, m, p << 1) + Q(l, r, m + 1, t, p << 1 | 1);\n    if (l <= m)\n        return Q(l, r, s, m, p << 1);\n    if (r > m)\n        return Q(l, r, m + 1, t, p << 1 | 1);\n}\nvoid M(int u, int v, int x)\n{\n    while (t[u] != t[v])\n    {\n        if (d[t[u]] < d[t[v]])\n            swap(u, v);\n        M(b[t[u]], b[u], x, 1, n, 1);\n        u = f[t[u]];\n    }\n    if (d[u] > d[v])\n        swap(u, v);\n    M(b[u], b[v], x, 1, n, 1);\n}\nint Q(int u, int v)\n{\n    N p, q;\n    bool U = 0, V = 0;\n    while (t[u] != t[v])\n        if (d[t[u]] > d[t[v]])\n            p = U ? Q(b[t[u]], b[u], 1, n, 1) + p : (U = 1, Q(b[t[u]], b[u], 1, n, 1)), u = f[t[u]];\n        else\n            q = V ? Q(b[t[v]], b[v], 1, n, 1) + q : (V = 1, Q(b[t[v]], b[v], 1, n, 1)), v = f[t[v]];\n    if (d[u] > d[v])\n        p = U ? Q(b[v], b[u], 1, n, 1) + p : (U = 1, Q(b[v], b[u], 1, n, 1));\n    else\n        q = V ? Q(b[u], b[v], 1, n, 1) + q : (V = 1, Q(b[u], b[v], 1, n, 1));\n    if (!U)\n        return q.v;\n    if (!V)\n        return p.v;\n    swap(p.p, p.q);\n    return (p + q).v;\n}\nvoid X(int u, int k, int t)\n{\n    S[u] = 1;\n    P[u] = 0;\n    for (int i = V.h[u], v; i; i = V.e[i].t)\n        if (!E[v = V.e[i].v] && v != k)\n            X(v, u, t), S[u] += S[v], P[u] = max(P[u], S[v]);\n    if (P[r] > (P[u] = max(P[u], t - S[u])))\n        r = u;\n}\nvoid Y(int u, int k, int)\n{\n    if (e[u])\n        Z[l++] = u;\n    for (int i = V.h[u], v; i; i = V.e[i].t)\n        if (!E[v = V.e[i].v] && v != k)\n            W[v] = W[u] + V.e[i].w, Y(v, u, 0);\n}\nvoid Q(int u, int k, int)\n{\n    E[u] = 1;\n    o = e[u];\n    for (int i = V.h[u], v; i; i = V.e[i].t)\n        if (!E[v = V.e[i].v] && v != k)\n        {\n            W[v = V.e[i].v] = V.e[i].w;\n            Y(v, u, l = 0);\n            o += l;\n            for (int j = 0; j < l; ++j)\n                A += W[Z[j]];\n        }\n    if (e[u])\n        G[u] += A + o;\n    for (int i = V.h[u], v; i; i = V.e[i].t)\n        if (!E[v = V.e[i].v] && v != k)\n        {\n            W[v = V.e[i].v] = V.e[i].w;\n            Y(v, u, l = 0);\n            o -= l;\n            for (int j = 0; j < l; ++j)\n                A -= W[Z[j]];\n            for (int j = 0; j < l; ++j)\n                G[Z[j]] += A + o * (W[Z[j]] + 1ll);\n            o += l;\n            for (int j = 0; j < l; ++j)\n                A += W[Z[j]];\n        }\n    A = o = 0;\n    for (int i = V.h[u], v; i; i = V.e[i].t)\n        if (!E[v = V.e[i].v] && v != k)\n            r = 0, X(v, u, s[v]), Q(r, u, 0);\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d\", a + i);\n    for (int i = 1, u, v; i < n; ++i)\n        scanf(\"%d%d\", &u, &v), T.A(u, v, 1), T.A(v, u, 1);\n    X(d[1] = 1);\n    Y(1, 1);\n    B(1, n, 1);\n    for (int i = 0, o, k, c = 0, u, v, x; i < m; ++i)\n    {\n        scanf(\"%d\", &o);\n        if (o & 1)\n            scanf(\"%d%d%d\", &u, &v, &x), M(u, v, x);\n        else\n        {\n            scanf(\"%d\", &k);\n            for (int j = 0; j < c; ++j)\n                V.h[h[j]] = e[h[j]] = E[h[j]] = G[h[j]] = 0;\n            for (int j = V.c = c = 0; j < k; ++j)\n                scanf(\"%d\", g + j), e[w[j] = g[j]] = 1;\n            sort(g, g + k, C);\n            h[c++] = g[0];\n            for (int j = 1; j < k; ++j)\n                h[c++] = L(g[j], g[j - 1]), h[c++] = g[j];\n            sort(h, h + c, C);\n            c = unique(h, h + c) - h;\n            for (int j = 1, l; j < c; ++j)\n                l = L(h[j], h[j - 1]), V.A(l, h[j], Q(l, h[j]) - 1), V.A(h[j], l, Q(l, h[j]) - 1);\n            P[r = 0] = 1e9;\n            X(h[0], 0, c);\n            Q(r, 0, 0);\n            for (int j = 0; j < k; ++j)\n                printf(\"%lld \", G[w[j]]);\n            puts(\"\");\n        }\n    }\n    return 0;\n}\n```\n\n\n\u5199 + \u8c03\u5168\u7a0b\u82b1\u8d39 2h\u3002\n\n\u9898\u5982\u5176\u540d\uff0c\u7801\u91cf\u7ea6\u7b49\u4e8e\u534a\u4e2a\u732a\u56fd\u6740\u3002\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/fd9jgewy.png)\n\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/3ue86yzg.png)",
        "postTime": 1685176233,
        "uid": 388651,
        "name": "5k_sync_closer",
        "ccfLevel": 7,
        "title": "P4242 \u6811\u4e0a\u7684\u6bd2\u7624 \u9898\u89e3"
    },
    {
        "content": "## description\n\n\u7ed9\u4f60\u4e00\u68f5\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u989c\u8272\uff0c\u6709\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n1. \u6307\u5b9a\u5176\u4e2d $k$ \u4e2a\u8282\u70b9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\uff0c\u8ba1\u7b97\u5b83 **\u5230\u6bcf\u4e2a\u7ed9\u5b9a\u7684\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u989c\u8272\u7684\u6bb5\u6570** \u7684\u548c\u3002\n2. \u4fee\u6539\u4e00\u6761\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u989c\u8272\u3002\n\n## solution\n\n\u9996\u5148\u770b\u63cf\u8ff0\u5c31\u53ef\u4ee5\u8bc6\u7b97\u6cd5\u4e86\u3002\n\n\u770b\u5230 $\\sum k \\le 2\\times10^5$ \u663e\u7136\u662f\u5efa\u865a\u6811\u51fa\u6765\u3002\n\n\u770b\u5230\u4fee\u6539\u8def\u5f84\u4e0a\u7684\u989c\u8272\uff0c\u663e\u7136\u53ef\u4ee5\u7528\u6811\u5256\u7ef4\u62a4\u3002\n\n\u5efa\u865a\u6811\u65f6\uff0c\u521a\u597d\u53ef\u4ee5\u5229\u7528\u6811\u5256\u5f97\u5230\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6240\u6709\u989c\u8272\u3002\n\n\u7136\u540e\u95ee\u9898\u662f\u5efa\u865a\u6811\u51fa\u6765\u4e4b\u540e\u8003\u8651\u600e\u4e48\u505a\u3002\n\n\u9996\u5148\u770b\u5230**\u8def\u5f84\u4e0a**\u8fd9\u4e09\u4e2a\u5b57\uff0c\u53ef\u4ee5\u8003\u8651\u70b9\u5206\u6cbb\u3002\n\n### \u70b9\u5206\u6cbb\u505a\u6cd5\n\n\u63cf\u8ff0\u7ea6\u5b9a\uff1a\n\n1. \u5bf9\u4e8e\u9898\u76ee\u4e2d\u7ed9\u51fa\u7684 $k$ \u4e2a\u70b9\uff0c\u6211\u4eec\u53eb\u4ed6\u5173\u952e\u70b9\u3002\n2. \u5bf9\u4e8e\u865a\u6811\u4e0a\u7684\u70b9\uff0c\u53eb\u5b83\u865a\u6811\u70b9\u3002\uff08\u663e\u7136\u5173\u952e\u70b9\u90fd\u662f\u865a\u6811\u70b9\uff09\n\n\u7136\u540e\u70b9\u5206\u6cbb\u6b65\u9aa4\uff1a\n\n1. \u627e\u5230\u6811\u91cd\u5fc3\uff0c\u5c06\u5176\u4f5c\u4e3a\u6839\u8282\u70b9\n2. \u4f9d\u6b21\u904d\u5386\u6839\u8282\u70b9\u7684\u6bcf\u68f5\u5b50\u6811\uff0c\u8ba1\u7b97\u5b50\u6811\u4e2d\u6240\u6709\u5173\u952e\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u4e2d\u989c\u8272\u7684\u6bb5\u6570\uff0c\u5e76 `sum += ColorCount, nodeCount += 1`\u3002\n3. \u4f9d\u6b21\u904d\u5386\u6839\u8282\u70b9\u7684\u6bcf\u68f5\u5b50\u6811\n\t1. \u5220\u9664\u8fd9\u68f5\u5b50\u6811\u7684\u8d21\u732e\n    2. \u8ba1\u7b97\u6bcf\u4e2a\u5173\u952e\u70b9\u7684\u7b54\u6848\uff08\u6211\u4eec\u5c06\u7ecf\u8fc7\u6839\u8282\u70b9\u7684\u7b54\u6848\u62c6\u5206\u6210\u4e24\u6bb5\uff0c\u4e00\u6bb5\u4ece\u6839\u6839\u8282\u70b9\u5230\u5176\u5b83\u5173\u952e\u70b9\uff0c\u4e00\u6bb5\u4ece\u5f53\u524d\u70b9\u5230\u6839\u8282\u70b9\uff0c\u7b54\u6848\u663e\u7136\u5e94\u8be5\u662f\uff1a $\\text{\u5b50\u6811\u5916\u8282\u70b9\u6570} \\times \\text{\u5f53\u524d\u5173\u952e\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u989c\u8272\u7684\u6bb5\u6570} + \\text{sum}$\n    3. \u52a0\u56de\u5b50\u6811\u8d21\u732e\n4. \u4f9d\u6b21\u9012\u5f52\u6bcf\u68f5\u5b50\u6811\n\n\u9664\u4e86\u70b9\u5206\u6cbb\u4ee5\u5916\uff0c\u8fd8\u53ef\u4ee5\u8003\u8651**\u865a\u6811\u9898\u76ee\u7684\u5e38\u7528\u89e3\u6cd5**\uff1a\u6811\u5f62 dp\u3002\n\n### \u6811\u5f62 dp \u505a\u6cd5\n\n\u8003\u8651\u4e0b\u9762\u8fd9\u68f5\u6811\uff08\u6837\u4f8b\uff09\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/gukp1l53.png)\n\n\u9996\u5148\u8003\u8651\u6709\u6839\u6811\u7684\u505a\u6cd5\u3002\n\n\u4ee5\u8282\u70b9 $u$ \u4e3a\u6839\uff0c\u8003\u8651\u865a\u6811\u4e0a\u8fd9\u6837\u4e00\u6761\u8fb9 $(u, v)$\uff1a\n\n\u5bf9\u4e8e\u5b50\u6811 $v$ \u4e2d\u7684\u6bcf\u4e2a\u70b9\uff0c\u5230 $u$ \u7684\u8def\u5f84\u90fd\u5fc5\u987b\u7ecf\u8fc7 $v$\uff0c\u6240\u4ee5\u5b50\u6811 $v$ \u4e2d\u7684\u6bcf\u4e2a\u70b9\u5230 $u$ \u7684\u8d21\u732e\u90fd\u4f1a\u591a\u4e0a $\\operatorname{Count}(u, v) - 1$\uff0c\u5176\u4e2d $\\operatorname{Count}(u, v)$ \u8868\u793a $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\uff08\u5305\u542b $u,v$\uff09\u989c\u8272\u6bb5\u6570\u3002\n\n\u8bb0 $f_u$ \u4e3a\u4ee5 $u$ \u4e3a\u6839\u7684\u5b50\u6811\u7684\u7b54\u6848\uff0c$c_u$ \u4e3a\u4ee5 $u$ \u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5173\u952e\u70b9\u7684\u4e2a\u6570\uff0c\u5f97\u5230\u4e0b\u9762\u8fd9\u4e2a\u5f0f\u5b50\uff1a\n\n$$f_u=[\\text{u \u662f\u5173\u952e\u70b9}] + \\sum_{(u,v)\\in E}f_v + c_v\\times(\\operatorname{Count}(u,v)-1)$$\n\n\u5bf9\u4e8e\u4e4b\u540e\u7684\u6362\u6839\uff0c\u540c\u6837\u6309\u7167\u8fd9\u4e2a\u5f0f\u5b50\u518d\u51cf\u53bb\u5b50\u6811\u8d21\u732e\u5c31\u884c\uff08\u8bb0 $p$ \u4e3a\u8282\u70b9\u7236\u4eb2\uff09\uff1a\n\n$$f_u = f_p - c_u\\times(\\operatorname{Count}(p,u)-1)+(k-c_u)\\times(\\operatorname{Count}(p,u)-1)$$\n\n~~\u60f3\u5c55\u5f00\u5c31\u5c55\u5f00\u5427\uff0c\u603b\u4e4b\u6211\u61d2\u5f97\u5c55\u5f00~~ \u4e0d\u8fc7\u4e0d\u5c55\u5f00\u4e5f\u6709\u4e2a\u597d\u5904\uff0c\u5c31\u662f\u903b\u8f91\u66f4\u52a0\u6e05\u6670\u3002\n\n\u8fd9\u4e2a\u505a\u6cd5\u8d34\u4e2a Code\uff1a\n\n```cpp\n/*\n1. \u4fee\u6539\u4e00\u6761\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u989c\u8272\n2. \u8ba1\u7b97\u6240\u6709\u8282\u70b9\u5230\u5176\u4ed6\u8282\u70b9\u7684\u989c\u8272\u603b\u6570\n*/\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, s, e) for(int i=s;i<=e;++i)\n#define pb push_back\nconst int mxn = 1e5+10;\n\nint n, q, c[mxn], dfn[mxn], ed[mxn], map[mxn];\nvector <int> G[mxn];\n\nstruct node {\n\tint lC, rC, sum;\n\tinline node operator + (const node& rhs) const { \n\t\tif(!rhs.sum) return *this; if(!sum) return rhs;\n\t\treturn (node) {lC, rhs.rC, sum + rhs.sum - (rC == rhs.lC)};\n\t}\n\tinline node reverse() { swap(lC, rC); return *this; }\n};\nconst node E0 = {0, 0, 0};\n#define lc (o<<1)\n#define rc (o<<1|1)\n#define mid ((L+R)>>1)\nstruct Segtr {\n\tnode s[mxn<<2]; int tag[mxn<<2];\n\tinline void cover(int o, int tg) { s[o] = {tg, tg, 1}; tag[o] = tg; }\n\tinline void psdn(int o) { if(tag[o]) { cover(lc, tag[o]), cover(rc, tag[o]); tag[o] = 0; } }\n\tinline void psup(int o) { s[o] = s[lc] + s[rc]; }\n\tvoid build(int o=1, int L=1, int R=n) {\n\t\tif(L == R) return (void)(s[o] = {c[map[L]], c[map[L]], 1});\n\t\tbuild(lc, L, mid); build(rc, mid+1, R); psup(o);\n\t}\n\tnode query(int cl, int cr, int o=1, int L=1, int R=n) {\n\t\tif(cl <= L && R <= cr) return s[o]; psdn(o);\n\t\tnode res = (cl <= mid ? query(cl, cr, lc, L, mid) : E0) + (cr > mid ? query(cl, cr, rc, mid+1, R) : E0);\n\t\treturn res;\n\t}\n\tvoid set(int cl, int cr, int p, int o=1, int L=1, int R=n) {\n\t\tif(cl <= L && R <= cr) return cover(o, p); psdn(o);\n\t\tif(cl <= mid) set(cl, cr, p, lc, L, mid);\n\t\tif(cr > mid) set(cl, cr, p, rc, mid+1, R); psup(o);\n\t}\n};\n#undef lc\n#undef rc\n#undef mid\n\nstruct tr_cut {\n\tint sz[mxn], son[mxn], fa[mxn], dep[mxn], dfc, top[mxn];\n\tSegtr T;\n\tvoid dfs1(int u, int fat) {\n\t\tfa[u] = fat; dep[u] = dep[fat] + 1; sz[u] = 1;\n\t\tfor(auto v: G[u]) if(v != fat) {\n\t\t\tdfs1(v, u); sz[u] += sz[v]; if(sz[v] > sz[son[u]]) son[u] = v;\n\t\t}\n\t}\n\tvoid dfs2(int u) {\n\t\tdfn[u] = ++dfc; map[dfc] = u;\n\t\tif(son[u]) { top[son[u]] = top[u]; dfs2(son[u]); }\n\t\tfor(auto v: G[u]) if(v != fa[u] && v != son[u]) { top[v] = v; dfs2(v); }\n\t\ted[u] = dfc;\n\t}\n\tinline int lca(int u, int v) {\n\t\twhile(top[u] != top[v]) dep[top[u]] > dep[top[v]] ? u = fa[top[u]] : v = fa[top[v]];\n\t\treturn dep[u] > dep[v] ? v : u;\n\t}\n\tinline void modify(int u, int v, int p) {\n\t\twhile(top[u] != top[v]) {\n\t\t\tif(dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\t\tT.set(dfn[top[u]], dfn[u], p);\n\t\t\tu = fa[top[u]];\n\t\t}\n\t\tif(dep[u] > dep[v]) swap(u, v);\n\t\tT.set(dfn[u], dfn[v], p);\n\t}\n\tinline node query(int u, int v) {\n\t\t// \u4ece\u6d45\u5230\u6df1\n\t\tif(dep[u] > dep[v]) swap(u, v);\n\t\tnode res = E0;\n\t\twhile(top[v] != top[u]) {\n\t\t\tres = T.query(dfn[top[v]], dfn[v]) + res;\n\t\t\tv = fa[top[v]];\n\t\t}\n\t\tif(u != v) res = T.query(dfn[u]+1, dfn[v]) + res;\n\t\treturn res;\n\t}\n\tinline void init() { dfs1(1, 0); top[1] = 1; dfs2(1); T.build(); }\n} cut;\ninline bool cmp(int x, int y) { return dfn[x] < dfn[y]; }\nstruct fake_tree {\n\tint pt[mxn<<1], m, M, tot, key[mxn], stk[mxn], top, sz[mxn], f[mxn], fa[mxn], ask[mxn];\n\tstruct edge { int v; node w; };\n\tvector <edge> G[mxn]; node s[mxn];\n\tinline void init(int GETIN) {\n\t\tm = M = GETIN;\n\t\trep(i, 1, m) { int x; scanf(\"%d\", &x); pt[i] = ask[i] = x; key[x] = 2; }\n\t\tif(!key[1]) key[1] = 1, pt[++M] = 1;\n\t\tsort(pt + 1, pt + M + 1, cmp);\n\t\ttot = M;\n\t\trep(i, 2, M) {\n\t\t\tint C = cut.lca(pt[i], pt[i-1]);\n\t\t\tif(!key[C]) key[C] = 1, pt[++tot] = C;\n\t\t}\n\t\tsort(pt + 1, pt + tot + 1, cmp);\n\t\tstk[top = 1] = 1;\n\t\trep(i, 1, tot) c[pt[i]] = cut.T.query(dfn[pt[i]], dfn[pt[i]]).lC;\n\t\t#define T (stk[top]) \n\t\trep(i, 2, tot) {\n\t\t\tint cur = pt[i];\n\t\t\twhile(dfn[cur] > ed[T]) --top; node w = cut.query(T, cut.fa[cur]);\n\t\t\tG[T].pb({cur, w}); stk[++top] = pt[i];\n\t\t}\n\t\t#undef T\n\t}\n\tvoid dfs1(int u, int fat) {\n\t\ts[u] = {c[u], c[u], 1}; fa[u] = fat; f[u] = sz[u] = (key[u] == 2);\n\t\tfor(auto e: G[u]) {\n\t\t\tdfs1(e.v, u); sz[u] += sz[e.v];\n\t\t\tf[u] += f[e.v] + sz[e.v] * ( (s[u] + e.w + s[e.v]).sum - 1);\n\t\t}\n\t}\n\tvoid dfs2(int u, node from) {\n\t\tif(fa[u]) f[u] = f[fa[u]] - sz[u] * (from.sum - 1) + (m - sz[u]) * (from.sum - 1);\n\t\tfor(auto e: G[u]) dfs2(e.v, s[u] + e.w + s[e.v]);\n\t}\n\tinline void solve() {\n\t\tdfs1(1, 0); dfs2(1, E0);\n\t\trep(i, 1, m) printf(\"%d \", f[ask[i]]); puts(\"\");\n\t\trep(i, 1, tot) {\n\t\t\tint cur = pt[i]; G[cur].clear(); s[cur] = E0;\n\t\t\tkey[cur] = f[cur] = fa[cur] = sz[cur] = ask[i] = pt[i] = 0;\n\t\t}\n\t}\n} sol;\n\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\trep(i, 1, n) scanf(\"%d\", c+i);\n\trep(i, 2, n) {\n\t\tint u, v; scanf(\"%d%d\", &u, &v);\n\t\tG[u].pb(v); G[v].pb(u);\n\t}\n\tcut.init();\n\twhile(q--) {\n\t\tint op; scanf(\"%d\", &op);\n\t\tif(op&1) {\n\t\t\tint u, v, w; scanf(\"%d%d%d\", &u, &v, &w);\n\t\t\tcut.modify(u, v, w);\n\t\t} else {\n\t\t\tint m; scanf(\"%d\", &m); sol.init(m); sol.solve();\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1641118854,
        "uid": 280800,
        "name": "lingfunny",
        "ccfLevel": 7,
        "title": "[solution] P4242 \u6811\u4e0a\u7684\u6bd2\u7624"
    },
    {
        "content": "\u6811\u5256\u7ef4\u62a4\u4fee\u6539\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u865a\u6811\u3002\n\n\u5bf9\u4e8e\u865a\u6811\u4e0a\u7684\u8fb9\uff0c\u8fb9\u6743\u5b9a\u4e49\u4e3a\u53bb\u6389$dep$\u5c0f\u7684\u90a3\u4e2a\u70b9\u6240\u5728\u7684\u989c\u8272\u5757\u5269\u4f59\u7684\u5757\u7684\u6570\u91cf\u3002\n\n\u8fd9\u6837\u7684\u8bdd\uff0c\u4e00\u6761\u8def\u5f84\u7684\u6743\u503c\u5c31\u662f\u8fb9\u6743\u4e4b\u548c$+1$\u3002\n\n\u6240\u4ee5\uff0c\u5efa\u5b8c\u865a\u6811\u4e4b\u540e\uff0c\u76f4\u63a5\u4e8c\u6b21\u6362\u6839$dp$\u5c31\u597d\u4e86\u3002\n\n(\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u70b9\u5206\u6cbb\uff0c\u4f46\u662f\u90a3\u6837\u4ee3\u7801\u5927\u6982\u4f1a\u7834$300$\u884c\u3002)\n\n\u6240\u4ee5\u8fd9\u73a9\u610f\u5c31\u662f\u4e00\u6a21\u677f\u5927\u96c6\u5408\u3002\u771f\u4e00\u9053\u6bd2\u7624\u9898\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nvoid read(int &x) {\n\tx=0;\n\tint f=1;\n\tchar ch=getchar();\n\tfor(; !isdigit(ch); ch=getchar()) if(ch=='-') f=-f;\n\tfor(; isdigit(ch); ch=getchar()) x=x*10+ch-'0';\n\tx*=f;\n}\nvoid print(int x) {\n\tif(x<0) putchar('-'),x=-x;\n\tif(!x) return ;\n\tprint(x/10),putchar(x%10+48);\n}\nvoid write(int x) {\n\tif(!x) putchar('0');\n\telse print(x);\n\tputchar('\\n');\n}\nconst int maxn = 2e5+10;\nint n,col[maxn],m,sz[maxn],dfn[maxn],f[maxn],dep[maxn],re[maxn];\n#define ls p<<1\n#define rs p<<1|1\n#define mid ((l+r)>>1)\nstruct data {\n\tint lcol,rcol,sum;\n\tdata operator + (const data &rhs) const {\n\t\tif(!sum) return rhs;\n\t\tif(!rhs.sum) return *this;\n\t\treturn (data) {\n\t\t\tlcol,rhs.rcol,sum+rhs.sum-(rcol==rhs.lcol)\n\t\t};\n\t}\n};\nstruct Segment_Tree {\n\tint cov[maxn<<2];\n\tdata t[maxn<<2];\n\tvoid push_tag(int p,int x) {\n\t\tt[p].sum=1,t[p].lcol=t[p].rcol=x,cov[p]=x;\n\t}\n\tvoid pushdown(int p) {\n\t\tif(!cov[p]) return ;\n\t\tpush_tag(ls,cov[p]),push_tag(rs,cov[p]);\n\t\tcov[p]=0;\n\t}\n\tvoid modify(int p,int l,int r,int x,int y,int z) {\n\t\tif(x<=l&&r<=y) return push_tag(p,z),void();\n\t\tpushdown(p);\n\t\tif(x<=mid) modify(ls,l,mid,x,y,z);\n\t\tif(y>mid) modify(rs,mid+1,r,x,y,z);\n\t\tt[p]=t[ls]+t[rs];\n\t}\n\tdata query(int p,int l,int r,int x,int y) {\n\t\tif(x<=l&&r<=y) return t[p];\n\t\tpushdown(p);\n\t\tif(y<=mid) return query(ls,l,mid,x,y);\n\t\telse if(x>mid) return query(rs,mid+1,r,x,y);\n\t\telse return query(ls,l,mid,x,y)+query(rs,mid+1,r,x,y);\n\t}\n\tvoid build(int p,int l,int r) {\n\t\tif(l==r) return t[p].sum=1,t[p].lcol=t[p].rcol=col[re[l]],void();\n\t\tbuild(ls,l,mid),build(rs,mid+1,r),t[p]=t[ls]+t[rs];\n\t}\n} SGT;\nstruct Heavy_Light_Decomposation {\n\tint head[maxn],tot,hs[maxn],top[maxn],dfn_cnt;\n\tstruct edge {\n\t\tint to,nxt;\n\t} e[maxn<<1];\n\tvoid add(int u,int v) {\n\t\te[++tot]=(edge) {v,head[u]},head[u]=tot;\n\t}\n\tvoid ins(int u,int v) {\n\t\tadd(u,v),add(v,u);\n\t}\n\tvoid dfs(int x,int fa) {\n\t\tsz[x]=1,f[x]=fa,dep[x]=dep[fa]+1;\n\t\tfor(int i=head[x]; i; i=e[i].nxt)\n\t\t\tif(e[i].to!=fa) {\n\t\t\t\tdfs(e[i].to,x);\n\t\t\t\tsz[x]+=sz[e[i].to];\n\t\t\t\tif(sz[e[i].to]>sz[hs[x]]) hs[x]=e[i].to;\n\t\t\t}\n\t}\n\tvoid dfs2(int x) {\n\t\tif(hs[f[x]]==x) top[x]=top[f[x]];\n\t\telse top[x]=x;\n\t\tdfn[x]=++dfn_cnt;\n\t\tre[dfn_cnt]=x;\n\t\tif(hs[x]) dfs2(hs[x]);\n\t\tfor(int i=head[x]; i; i=e[i].nxt)\n\t\t\tif(e[i].to!=f[x]&&e[i].to!=hs[x]) dfs2(e[i].to);\n\t}\n\tint lca(int x,int y) {\n\t\twhile(top[x]!=top[y]) {\n\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\t\tx=f[top[x]];\n\t\t}\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\treturn x;\n\t}\n\tvoid modify(int x,int y,int z) {\n\t\twhile(top[x]!=top[y]) {\n\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\t\tSGT.modify(1,1,n,dfn[top[x]],dfn[x],z);\n\t\t\tx=f[top[x]];\n\t\t}\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\tSGT.modify(1,1,n,dfn[x],dfn[y],z);\n\t}\n\tvoid print(data x) {\n\t\tprintf(\"Print :: %d %d %d\\n\",x.sum,x.lcol,x.rcol);\n\t}\n\tint query(int x,int t) {\n\t\tdata ans;\n\t\tint bo=1;\n\t\twhile(top[x]!=top[t]) {\n\t\t\tdata res=SGT.query(1,1,n,dfn[top[x]],dfn[x]);\n\t\t\tif(bo) bo=0,ans=res;\n\t\t\telse ans=res+ans;\n\t\t\tx=f[top[x]];\n\t\t}\n\t\tdata res=SGT.query(1,1,n,dfn[t],dfn[x]);\n\t\tif(bo) bo=0,ans=res;\n\t\telse ans=res+ans;\n\t\treturn ans.sum;\n\t}\n\tvoid debug(int x,int fa) {\n\t\tfor(int i=head[x]; i; i=e[i].nxt)\n\t\t\tif(e[i].to!=fa) debug(e[i].to,x);\n\t}\n} HLD;\nint cmp(int x,int y) {\n\treturn dfn[x]<dfn[y];\n}\nint id[maxn];\nint cmp2(int x,int y) {\n\treturn id[x]<id[y];\n}\nstruct Virtual_Tree {\n\tint head[maxn],tot,c[maxn],f[maxn],g[maxn],vis[maxn];\n\tstruct edge {\n\t\tint to,nxt,w;\n\t} e[maxn<<1];\n\tvoid add(int u,int v,int w) {\n\t\te[++tot]=(edge) {v,head[u],w},head[u]=tot;\n\t}\n\tvoid ins(int u,int v,int w){\n\t\tadd(u,v,w),add(v,u,w);\n\t} \n\tint in[maxn],k,use[maxn],used,sta[maxn],top;\n\tvoid build() {\n\t\tsta[++top]=1,use[++used]=1;\n\t\tfor(int i=1; i<=k; i++) {\n\t\t\tif(in[i]==1) continue;\n\t\t\tint t=HLD.lca(in[i],sta[top]),pre=-1;\n\t\t\twhile(dfn[sta[top]]>dfn[t]&&dfn[sta[top]]<dfn[t]+sz[t]) {\n\t\t\t\tif(pre!=-1) ins(sta[top],pre,HLD.query(pre,sta[top])-1);\n\t\t\t\tpre=sta[top],use[++used]=sta[top],top--;\n\t\t\t}\n\t\t\tif(pre!=-1) ins(t,pre,HLD.query(pre,t)-1);\n\t\t\tif(sta[top]!=t) sta[++top]=t;\n\t\t\tsta[++top]=in[i];\n\t\t}\n\t\tint pre=-1;\n\t\twhile(top) {\n\t\t\tif(pre!=-1) ins(sta[top],pre,HLD.query(pre,sta[top])-1);\n\t\t\tpre=sta[top],use[++used]=sta[top],top--;\n\t\t}\n\t}\n\tvoid dfs(int x,int fa) {\n\t\tif(vis[x]) c[x]=1;\n\t\telse c[x]=0;\n\t\tfor(int i=head[x]; i; i=e[i].nxt)\n\t\t\tif(e[i].to!=fa) {\n\t\t\t\tdfs(e[i].to,x);\n\t\t\t\tc[x]+=c[e[i].to];\n\t\t\t\tf[x]+=e[i].w*c[e[i].to]+f[e[i].to];\n\t\t\t}\n\t}\n\tvoid clear() {\n\t\tfor(int i=1; i<=used; i++) {\n\t\t\tint t=use[i];\n\t\t\thead[t]=id[t]=vis[t]=f[t]=g[t]=c[t]=0;\n\t\t}\n\t\ttot=used=top=0;\n\t}\n\tvoid dfs2(int x,int fa) {\n\t\tfor(int i=head[x]; i; i=e[i].nxt)\n\t\t\tif(e[i].to!=fa) {\n\t\t\t\tint v=e[i].to;\n\t\t\t\tg[v]=g[x]-e[i].w*c[v]+e[i].w*(k-c[v]);\n\t\t\t\tdfs2(e[i].to,x);\n\t\t\t}\n\t}\n\tvoid solve() {\n\t\tread(k);\n\t\tfor(int i=1; i<=k; i++) read(in[i]),vis[in[i]]=1,id[in[i]]=i;\n\t\tsort(in+1,in+k+1,cmp);\n\t\tbuild();\n\t\tdfs(1,0);\n\t\tg[1]=f[1];\n\t\tdfs2(1,0);\n\t\tsort(in+1,in+k+1,cmp2);\n\t\tfor(int i=1; i<=k; i++) printf(\"%d \",g[in[i]]+k);\n\t\tputs(\"\");\n\t\tclear();\n\t}\n} VT;\nint main() {\n\tread(n),read(m);\n\tfor(int i=1; i<=n; i++) read(col[i]);\n\tfor(int i=1,x,y; i<n; i++) read(x),read(y),HLD.ins(x,y);\n\tHLD.dfs(1,0),HLD.dfs2(1),SGT.build(1,1,n);\n\tfor(int i=1; i<=m; i++) {\n\t\tint op,u,v,y;\n\t\tread(op);\n\t\tif(op==1) read(u),read(v),read(y),HLD.modify(u,v,y);\n\t\telse VT.solve();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1612258982,
        "uid": 306255,
        "name": "\u65e5\u5fa1\u8353\u7ff3",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P4242 \u3010\u6811\u4e0a\u7684\u6bd2\u7624\u3011"
    },
    {
        "content": "\u9996\u5148\u6211\u4eec\u8003\u8651\u5982\u4f55\u628a\u9898\u76ee\u6c42\u7684$T(i,j)$\u5206\u6bb5\u6c42\u51fa\uff0c\u5047\u5b9a\u5728\u8def\u5f84$<i,j>$\u4e0a\u627e\u5230\u4e00\u4e9b\u5173\u952e\u70b9$p_0,p_2,...p_k$\uff0c\u5176\u4e2d$p_0=i,p_k=j$\uff0c\u53ef\u4ee5\u53d1\u73b0$\\sum\\limits_{i=1}^kT(p_{i-1},p_i)-k+1=T(i,j)$\uff0c\u4e8e\u662f\u6211\u4eec\u628a\u865a\u6811\u5efa\u51fa\u6765\u4e4b\u540e\uff0c\u5bf9\u4e8e\u8fb9$<u,v>$\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528$T(u,v)-1$\u4f5c\u4e3a\u5176\u8fb9\u6743\uff0c\u7136\u540e\u5728\u865a\u6811\u4e0adp\uff0c\u8bb0$f[i]$\u8868\u793a\u5230\u5176\u5b50\u6811\u5185\u6240\u6709\u7279\u6b8a\u70b9\u7684\u8def\u5f84\u6743\u503c\u548c\uff08\u5728\u865a\u6811\u4e0a\uff09\uff0c\u7136\u540e\u5bf9\u4e8e$f[i]$\u8f93\u51fa$f[i]+cnt$\u5373\u53ef\uff08$cnt$\u4e3a\u7279\u6b8a\u70b9\u4e2a\u6570\uff09\n\n\u4e8c\u6b21\u6362\u6839\u5373\u53ef$O(n)$\u6c42\u51fa\u6240\u6709\u7279\u6b8a\u70b9\u7684$f[i]$\uff0c\u7136\u540e\u7531\u4e8e\u6709\u989c\u8272\u4fee\u6539\uff0c\u6211\u4eec\u4f7f\u7528\u6811\u94fe\u5256\u5206\u5373\u53ef\uff08\u8c8c\u4f3c\u8fd9\u4e2a\u5199\u6cd5\u8dd1\u5f97\u98de\u5feb\uff09\n\n~~\u7801\u91cf\u6709\u70b9\u5c0f\u5927~~\n\n```cpp\n/*program from Wolfycz*/\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define inf 0x7f7f7f7f\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ninline char gc(){\n\tstatic char buf[1000000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int frd(){\n\tint x=0,f=1; char ch=gc();\n\tfor (;ch<'0'||ch>'9';ch=gc())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=gc())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline int read(){\n\tint x=0,f=1; char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar())\tif (ch=='-')\tf=-1;\n\tfor (;ch>='0'&&ch<='9';ch=getchar())\tx=(x<<3)+(x<<1)+ch-'0';\n\treturn x*f;\n}\ninline void print(int x){\n\tif (x<0)\tputchar('-'),x=-x;\n\tif (x>9)\tprint(x/10);\n\tputchar(x%10+'0');\n}\nconst int N=1e5;\nint dfn[N+10],ID[N+10],V[N+10],n,q;\nbool cmp(int x,int y){return ID[x]<ID[y];}\nstruct S1{\n\t#define ls (p<<1)\n\t#define rs (p<<1|1)\n\tstruct node{\n\t\tint l,r,sum;\n\t\tnode(){l=r=sum=0;}\n\t\tnode(int _l,int _r,int _sum){l=_l,r=_r,sum=_sum;}\n\t\tvoid init(int v){l=r=v,sum=1;}\n\t}tree[(N<<2)+10];\n\tint cov[(N<<2)+10];\n\tfriend node operator +(const node &x,const node &y){\n\t\tif (!x.sum)\treturn y;\n\t\tif (!y.sum)\treturn x;\n\t\treturn node(x.l,y.r,x.sum+y.sum-(x.r==y.l));\n\t}\n\tvoid Add_cov(int p,int v){\n\t\ttree[p].init(v);\n\t\tcov[p]=v;\n\t}\n\tvoid pushdown(int p){\n\t\tif (!cov[p])\treturn;\n\t\tAdd_cov(ls,cov[p]);\n\t\tAdd_cov(rs,cov[p]);\n\t\tcov[p]=0;\n\t}\n\tvoid build(int p,int l,int r){\n\t\tif (l==r){\n\t\t\ttree[p].init(V[dfn[l]]);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(ls,l,mid);\n\t\tbuild(rs,mid+1,r);\n\t\ttree[p]=tree[ls]+tree[rs];\n\t}\n\tvoid Modify(int p,int l,int r,int x,int y,int v){\n\t\tif (x<=l&&r<=y){\n\t\t\tAdd_cov(p,v);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(p);\n\t\tint mid=(l+r)>>1;\n\t\tif (x<=mid)\tModify(ls,l,mid,x,y,v);\n\t\tif (y>mid)\tModify(rs,mid+1,r,x,y,v);\n\t\ttree[p]=tree[ls]+tree[rs];\n\t}\n\tnode Query(int p,int l,int r,int x,int y){\n\t\tif (x<=l&&r<=y)\treturn tree[p];\n\t\tpushdown(p);\n\t\tint mid=(l+r)>>1; node res;\n\t\tif (x<=mid)\tres=res+Query(ls,l,mid,x,y);\n\t\tif (y>mid)\tres=res+Query(rs,mid+1,r,x,y);\n\t\treturn res;\n\t}\n\t#undef ls\n\t#undef rs\n}ST;//Segment Tree\nstruct S2{\n\tint pre[(N<<1)+10],now[N+10],child[(N<<1)+10],tot,Time;\n\tint size[N+10],fa[N+10],deep[N+10],top[N+10],Rem[N+10];\n\tvoid join(int x,int y){pre[++tot]=now[x],now[x]=tot,child[tot]=y;}\n\tvoid insert(int x,int y){join(x,y),join(y,x);}\n\tvoid dfs(int x){\n\t\tdeep[x]=deep[fa[x]]+1,size[x]=1;\n\t\tfor (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){\n\t\t\tif (son==fa[x])\tcontinue;\n\t\t\tfa[son]=x,dfs(son);\n\t\t\tsize[x]+=size[son];\n\t\t\tif (size[Rem[x]]<size[son])\tRem[x]=son;\n\t\t}\n\t}\n\tvoid build(int x){\n\t\tif (!x)\treturn;\n\t\tdfn[ID[x]=++Time]=x;\n\t\ttop[x]=Rem[fa[x]]==x?top[fa[x]]:x;\n\t\tbuild(Rem[x]);\n\t\tfor (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){\n\t\t\tif (son==fa[x]||son==Rem[x])\tcontinue;\n\t\t\tbuild(son);\n\t\t}\n\t}\n\tint LCA(int x,int y){\n\t\twhile (top[x]!=top[y]){\n\t\t\tif (deep[top[x]]<deep[top[y]])\tswap(x,y);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn deep[x]<deep[y]?x:y;\n\t}\n\tvoid Modify(int x,int y,int v){\n\t\twhile (top[x]!=top[y]){\n\t\t\tif (deep[top[x]]<deep[top[y]])\tswap(x,y);\n\t\t\tST.Modify(1,1,n,ID[top[x]],ID[x],v);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif (deep[x]>deep[y])\tswap(x,y);\n\t\tST.Modify(1,1,n,ID[x],ID[y],v);\n\t}\n\tint Query(int x,int y){\n\t\tS1::node res;\n\t\twhile (top[x]!=top[y]){\n\t\t\tif (deep[top[x]]<deep[top[y]])\tswap(x,y);\n\t\t\tres=ST.Query(1,1,n,ID[top[x]],ID[x])+res;\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif (deep[x]>deep[y])\tswap(x,y);\n\t\tres=ST.Query(1,1,n,ID[x],ID[y])+res;\n\t\treturn res.sum;\n\t}\n}HLD;//Heavy Light Decomposition\nstruct S3{\n\tint pre[(N<<1)+10],now[N+10],child[(N<<1)+10],val[(N<<1)+10];\n\tint A[N+10],stack[N+10],size[N+10];\n\tint m,tot; ll f[N+10];\n\tbool mark[N+10];\n\tvoid join(int x,int y,int z){pre[++tot]=now[x],now[x]=tot,child[tot]=y,val[tot]=z;}\n\tvoid insert(int x,int y,int z=0){z=HLD.Query(x,y)-1,join(x,y,z),join(y,x,z);}\n\tvoid rebuild(){\n\t\tint top=0; tot=0;\n\t\tsort(A+1,A+1+m,cmp);\n\t\tstack[++top]=1;\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tint x=A[i],lca=HLD.LCA(x,stack[top]);\n\t\t\tif (x==1)\tcontinue;\n\t\t\tif (lca==stack[top]){\n\t\t\t\tstack[++top]=x;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\twhile (true){\n\t\t\t\tint y=stack[top-1];\n\t\t\t\tif (ID[y]>=ID[lca])\tinsert(y,stack[top--]);\n\t\t\t\telse{\n\t\t\t\t\tif (lca==stack[top])\tbreak;\n\t\t\t\t\tinsert(stack[top],lca);\n\t\t\t\t\tstack[top]=lca; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack[++top]=x;\n\t\t}\n\t\twhile (top>1){\n\t\t\tinsert(stack[top],stack[top-1]);\n\t\t\ttop--;\n\t\t}\n\t}\n\tvoid dfs1(int x,int fa){\n\t\tsize[x]=mark[x],f[x]=0;\n\t\tfor (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){\n\t\t\tif (son==fa)\tcontinue;\n\t\t\tdfs1(son,x),size[x]+=size[son];\n\t\t\tf[x]+=f[son]+1ll*val[p]*size[son];\n\t\t}\n\t}\n\tvoid dfs2(int x,int fa){//\u4e8c\u6b21\u6362\u6839\n\t\tfor (int p=now[x],son=child[p];p;p=pre[p],son=child[p]){\n\t\t\tif (son==fa)\tcontinue;\n\t\t\tf[son]=f[x]+1ll*val[p]*(m-2ll*size[son]);\n\t\t\tdfs2(son,x);\n\t\t}\n\t\tnow[x]=0;\n\t}\n\tvoid work(){\n\t\tstatic int list[N+10];\n\t\tm=read();\n\t\tfor (int i=1;i<=m;i++)\tmark[list[i]=A[i]=read()]=1;\n\t\trebuild(),dfs1(1,0),dfs2(1,0);\n\t\tfor (int i=1;i<=m;i++)\tprintf(\"%lld\",f[list[i]]+m),putchar(i==m?'\\n':' ');\n\t\tfor (int i=1;i<=m;i++)\tmark[A[i]]=0;\n\t}\n}VT;//Virtual Tree\nint main(){\n\tn=read(),q=read();\n\tfor (int i=1;i<=n;i++)\tV[i]=read();\n\tfor (int i=1;i<n;i++){\n\t\tint x=read(),y=read();\n\t\tHLD.insert(x,y);\n\t}\n\tHLD.dfs(1),HLD.build(1),ST.build(1,1,n);\n\tfor (int i=1;i<=q;i++){\n\t\tint type=read();\n\t\tif (type==1){\n\t\t\tint x=read(),y=read(),v=read();\n\t\t\tHLD.Modify(x,y,v);\n\t\t}\n\t\tif (type==2)\tVT.work();\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1547093815,
        "uid": 21633,
        "name": "Wolfycz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4242 \u3010\u6811\u4e0a\u7684\u6bd2\u7624\u3011"
    }
]