[
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](/problem/P5998)\n\n\u9898\u76ee\u5927\u610f\uff1a\u7ed9\u5b9a\u4e00\u4e9b\u77e9\u5f62\uff0c\u91cd\u53e0\u9762\u79ef\u5927\u4e8e $0$ \u7684\u4f1a\u5408\u5e76\u6210\u4e00\u4e2a\u5927\u77e9\u5f62\uff0c\u6c42\u6700\u540e\u5269\u4e0b\u77e9\u5f62\u7684\u6570\u76ee\u548c\u4f4d\u7f6e\u3002\n\n\u4f7f\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u77e9\u5f62\u7684\u5408\u5e76\u60c5\u51b5\u3002\u90a3\u4e48\u53ea\u8981\u5224\u65ad\u5bf9\u4e8e\u4e00\u4e2a\u77e9\u5f62\uff0c\u6709\u54ea\u4e9b\u548c\u5b83\u91cd\u53e0\u5373\u53ef\u3002\n\n\u53d1\u73b0\u503c\u57df\u53ef\u4ee5\u79bb\u6563\u5316\uff0c\u56e0\u6b64\u5e76\u4e0d\u5927\uff0c\u8003\u8651\u5728 $x$ \u8f74\u4e0a\u5efa\u7acb\u4e00\u9897\u7ebf\u6bb5\u6811\u3002\u7ebf\u6bb5\u6811\u4e2d\u7ef4\u62a4\u8fd9\u6bb5\u533a\u95f4\u88ab\u54ea\u4e9b\u5305\u542b\u548c\u5305\u542b\u54ea\u4e9b\u5373\u53ef\u3002\u5408\u5e76\u77e9\u5f62\u7684\u65f6\u5019\u904d\u5386\u6240\u6709\u88ab\u5305\u542b\u7684\uff0c\u4ee5\u53ca\u5305\u542b\u4e24\u4e2a\u7aef\u70b9\u7684\u533a\u95f4\u5c31\u884c\u3002\u6ce8\u610f\u5224\u65ad $y$ \u8f74\u7684\u91cd\u53e0\u3002\n\n\u6613\u5f97\u65f6\u7a7a\u590d\u6742\u5ea6\u90fd\u662f $O(n\\log n)$ \u7ea7\u522b\u7684\uff0c~~\u867d\u7136\u5e38\u6570\u5de8\u5927\uff0c\u4ee3\u7801\u5de8\u957f\uff0c\u4f46\u7adf\u7136\u80fd\u8fc7~~\u3002\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\nstruct QWQ\n{\n\tint x1, x2, y1, y2;\n\tinline void rd() { read(x1), read(x2), read(y1), read(y2); }\n\tinline void print() { printf(\"%d %d %d %d\\n\", x1, x2, y1, y2); }\n}\ta[100009], ans[100009];\nint n, x, y, cnt, id[100009], num[200009], N; vector < int > stk;\nnamespace BCJ\n{\n\tint fa[100009];\n\tinline void init(int x) { For(i, 1, x) fa[i] = i; }\n\tinline int fat(int x) { return x == fa[x] ? x : fa[x] = fat(fa[x]); }\n\tinline void unionn(int x, int y)\n\t{\n\t\tx = fat(x), y = fat(y);\n\t\tif ( x == y ) return;\n\t\ta[x].x1 = min(a[x].x1, a[y].x1), a[x].y1 = min(a[x].y1, a[y].y1),\n\t\ta[x].x2 = max(a[x].x2, a[y].x2), a[x].y2 = max(a[x].y2, a[y].y2),\n\t\tfa[y] = x;\n\t}\n}\tusing BCJ::fa, BCJ::fat;\nnamespace ST\n{\n\tstruct node\n\t{\n\t\tvector < int > p, q;\n\t}\tt[200009 << 2];\n\tinline int lc(int x) { return x << 1; }\n\tinline int rc(int x) { return lc(x) | 1; }\n\tinline int md(int x, int y) { return ( x + y ) >> 1; }\n\tinline void insert(int p, int l, int r, int lp, int rp)\n\t{\n\t\tif ( lp > r || rp < l ) return;\n\t\tif ( lp <= l && r <= rp ) { stk.push_back(p); return; }\n\t\tinsert(lc(p), l, md(l, r), lp, rp),\n\t\tinsert(rc(p), md(l, r) + 1, r, lp, rp);\n\t}\n\tinline void update(int p, int x)\n\t{\n\t\tfor ( int i = p ; i ; i >>= 1 ) t[i].p.push_back(x);\n\t}\n\tinline int getroot(int p, int l, int r, int pos)\n\t{\n\t\tif ( l == r ) return p;\n\t\treturn pos <= md(l, r) ? getroot(lc(p), l, md(l, r), pos)\n\t\t\t\t\t\t\t   : getroot(rc(p), md(l, r) + 1, r, pos);\n\t}\n}\tusing ST::t;\nint main()\n{\n\tread(n); For(i, 1, n) a[i].rd(), id[i] = i, a[i].x1++, a[i].y1++;\n\tFor(i, 1, n) num[i] = a[i].x1, num[i + n] = a[i].x2;\n\tsort(num + 1, num + 2 * n + 1),\n\tN = unique(num + 1, num + 2 * n + 1) - num - 1;\n\tFor(i, 1, n)\n\t\ta[i].x1 = lower_bound(num + 1, num + N + 1, a[i].x1) - num,\n\t\ta[i].x2 = lower_bound(num + 1, num + N + 1, a[i].x2) - num;\n\tsort(id + 1, id + n + 1, [](int x, int y) {\n\t\treturn a[x].y2 != a[y].y2 ? a[x].y2 < a[y].y2 : x < y;\n\t}), BCJ::init(n);\n\tFor(i, 1, n)\n\t{\n\t\tfor ( bool flag = true ; flag ; )\n\t\t{\n\t\t\tflag = false, stk.clear(),\n\t\t\tST::insert(1, 1, N, a[id[i]].x1, a[id[i]].x2);\n\t\t\tfor ( int j : stk ) Fol(k, t[j].p.size() - 1, 0)\n\t\t\t{\n\t\t\t\tx = t[j].p[k];\n\t\t\t\tif ( x != fa[x] || fat(x) == fat(id[i]) )\n\t\t\t\t{ t[j].p.pop_back(); continue; }\n\t\t\t\tif ( a[id[i]].y1 > a[x].y2 ) break;\n\t\t\t\tBCJ::unionn(id[i], x), flag = true, t[j].p.pop_back();\n\t\t\t}\n\t\t\tfor ( int j = ST::getroot(1, 1, N, a[id[i]].x1) ; j ; j >>= 1 )\n\t\t\t\tFol(k, t[j].q.size() - 1, 0)\n\t\t\t\t{\n\t\t\t\t\tx = t[j].q[k];\n\t\t\t\t\tif ( x != fa[x] || fat(x) == fat(id[i]) )\n\t\t\t\t\t{ t[j].q.pop_back(); continue; }\n\t\t\t\t\tif ( a[id[i]].y1 > a[x].y2 ) break;\n\t\t\t\t\tBCJ::unionn(id[i], x), flag = true, t[j].q.pop_back();\n\t\t\t\t}\n\t\t\tfor ( int j = ST::getroot(1, 1, N, a[id[i]].x2) ; j ; j >>= 1 )\n\t\t\t\tFol(k, t[j].q.size() - 1, 0)\n\t\t\t\t{\n\t\t\t\t\tx = t[j].q[k];\n\t\t\t\t\tif ( x != fa[x] || fat(x) == fat(id[i]) )\n\t\t\t\t\t{ t[j].q.pop_back(); continue; }\n\t\t\t\t\tif ( a[id[i]].y1 > a[x].y2 ) break;\n\t\t\t\t\tBCJ::unionn(id[i], x), flag = true, t[j].q.pop_back();\n\t\t\t\t}\n\t\t}\n\t\tST::update(ST::getroot(1, 1, N, a[id[i]].x1), id[i]);\n\t\tif ( a[id[i]].x1 != a[id[i]].x2 )\n\t\t\tST::update(ST::getroot(1, 1, N, a[id[i]].x2), id[i]);\n\t\tST::insert(1, 1, N, a[id[i]].x1, a[id[i]].x2);\n\t\tfor ( int j : stk ) t[j].q.push_back(id[i]);\n\t}\n\tFor(i, 1, n) if ( fa[i] == i ) ans[++cnt] = a[i];\n\tFor(i, 1, cnt)\n\t\tans[i].x1 = num[ans[i].x1] - 1, ans[i].x2 = num[ans[i].x2], ans[i].y1--;\n\tsort(ans + 1, ans + cnt + 1, [](const QWQ &x, const QWQ &y) {\n\t\treturn x.x1 != y.x1 ? x.x1 < y.x1 : x.x2 != y.x2 ? x.x2 < y.x2 :\n\t\t\t   x.y1 != y.y1 ? x.y1 < y.y1 : x.y2 < y.y2;\n\t}), printf(\"%d\\n\", cnt);\n\tFor(i, 1, cnt) ans[i].print();\n\treturn 0;\n}\n```",
        "postTime": 1665649741,
        "uid": 127949,
        "name": "cmk666",
        "ccfLevel": 7,
        "title": "P5998 \u9898\u89e3"
    },
    {
        "content": "# P5998 [PA2014]Plemiona \u9898\u89e3\n\n## Analysis\n\n\u5f88\u5de7\u5999\u7684\u4e1c\u897f\uff0c\u7ec8\u4e8e\u662f\u80e1\u51fa\u6765\u4e86\u3002\n\n\u9996\u5148\uff0c\u6211\u4eec\u5bf9\u77e9\u5f62\u6309\u7167\u64cd\u4f5c\u7684 $y$ \u503c\u53f3\u7aef\u70b9\u6392\u5e8f\u3002\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 $x$ \u8f74\u3002\n\n\u6211\u4eec\u53d1\u73b0\u4e24\u4e2a\u76f8\u4ea4\u7684\u7ebf\u6bb5\u6240\u8986\u76d6\u5230\u7684\u7ebf\u6bb5\u6811\u8282\u70b9\u4e0a\u4e00\u5b9a\u6709\u67d0\u4e00\u5bf9\u8282\u70b9\u5448\u7236\u5b50\u5173\u7cfb\uff0c\u539f\u56e0\u663e\u7136\u3002\n\n\u4f46\u662f\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u592a\u5927\u4e86\uff0c\u6211\u4eec\u8003\u8651\u7528\u5b69\u5b50\u6570\u7956\u5148\u3002\n\n\u6211\u4eec\u7ed9\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u5f00 $2$ \u4e2a `vector`\uff0c\u59d1\u4e14\u53eb\u5b83 `vec1` \u548c `vec2`\u3002\n\n\u6211\u4eec\u628a\u77e9\u5f62\u52a0\u5165\u7ebf\u6bb5\u6811\u65f6\u5c31\u52a0\u5165\u6240\u6709 **\u8bbf\u95ee\u8fc7** \u7684\u8282\u70b9\u7684 `vec2`\uff0c\u5e76\u4e14\u52a0\u5165\u5176\u5b8c\u5168\u8986\u76d6\u7684\u6700\u4e0a\u5c42\u8282\u70b9\uff08\u4e5f\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u64cd\u4f5c\u7684\u90a3\u4e9b\u8282\u70b9\uff09\u7684 `vec1`\u3002\n\n\u6211\u4eec\u5408\u5e76\u77e9\u5f62\u65f6\u65f6\u5c31\u8ba1\u7b97\u4e0e **\u8bbf\u95ee\u8fc7** \u7684\u8282\u70b9\u7684 `vec2` \u7684\u77e9\u5f62\u662f\u5426\u6709\u4ea4\uff0c\u5e76\u4e14\u8ba1\u7b97\u5176\u5b8c\u5168\u8986\u76d6\u7684\u6700\u4e0a\u5c42\u8282\u70b9\uff08\u4e5f\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u64cd\u4f5c\u7684\u90a3\u4e9b\u8282\u70b9\uff09\u7684 `vec1` \u662f\u5426\u6709\u4ea4\u3002\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a `vec1` \u548c `vec2` \u5728\u6392\u5e8f\u4e4b\u540e\u7b26\u5408\u5355\u8c03\u6027\uff0c\u5373\u4f60\u53ef\u4ee5\u4ece\u5176\u672b\u5c3e\u5f00\u59cb\u8bbf\u95ee\uff0c\u4f46\u6709\u4e00\u4e2a\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u65f6\u5019\u5c31 `break`\u3002\n\n\u8fd9\u4e2a\u505a\u6cd5\u7684\u6b63\u786e\u6027\u663e\u7136\uff0c\n\u5b9e\u9645\u4e0a\u8fd9\u4e2a\u505a\u6cd5\u7684\u5747\u644a\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(n \\log n)$ \u7684\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u4e5f\u4e00\u6837\uff0c\u663e\u7136\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002\n\n\u6700\u540e\u8d34\u4e00\u4e0b\u4ee3\u7801\u3002\n\n\n## Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 4e5 + 10;\nint tab[N << 2], len, n;\nstruct Square {\n    int lx, ly, rx, ry;\n    inline void read() {\n        scanf(\"%d %d %d %d\", &lx, &rx, &ly, &ry), ++lx, ++ly;\n        tab[++len] = lx, tab[++len] = rx;\n    }\n    inline void print() { printf(\"%d %d %d %d\\n\", tab[lx] - 1, tab[rx], ly - 1, ry); }\n    inline bool operator<(const Square &b) const { return ry < b.ry; }\n    inline Square operator+(const Square &b) const { return {min(lx, b.lx), min(ly, b.ly), max(rx, b.rx), max(ry, b.ry)}; }\n} a[N];\nbool vis[N];\ninline bool calc(int x, int y) { return !((a[x].ly > a[y].ry) || (a[y].ly > a[x].ry)); }\nstruct SegmentTree {\n    vector<int> vec[N << 2], vec2[N << 2];  // vec \u67d3\u8272\u5230\u77e9\u5f62\u6240\u6709\u5305\u542b\u7684\u7ebf\u6bb5\u4e0a\uff0cvec2\u67d3\u8272\u5230\u6240\u6709\u6709\u4ea4\u8be5\u77e9\u5f62\u7684\u7ebf\u6bb5\u4e0a\u3002\n    void update(int u, int L, int R, int l, int r, int v) {\n        if (L > r || R < l) return;\n        vec2[u].push_back(v);\n        if (L >= l && R <= r) {\n            vec[u].push_back(v);\n            return;\n        }\n        int M = L + R >> 1;\n        update(u << 1, L, M, l, r, v), update(u << 1 | 1, M + 1, R, l, r, v);\n    }\n    bool merge(int u, int L, int R, int l, int r, int v) {\n        if (L > r || R < l) return 0;\n        bool flag = 0;\n        for (int i = vec[u].size() - 1; ~i; i = vec[u].size() - 1) {\n            if (vis[vec[u][i]]) {\n                vec[u].pop_back();\n                continue;\n            }\n            if (!calc(vec[u][i], v)) break;\n            a[v] = a[v] + a[vec[u][i]], vis[vec[u][i]] = 1;\n            vec[u].pop_back();\n            flag = 1;\n        }\n        if (L >= l && R <= r) {\n            for (int i = vec2[u].size() - 1; ~i; i = vec2[u].size() - 1) {\n                if (vis[vec2[u][i]]) {\n                    vec2[u].pop_back();\n                    continue;\n                }\n                if (!calc(vec2[u][i], v)) break;\n                a[v] = a[v] + a[vec2[u][i]], vis[vec2[u][i]] = 1;\n                vec2[u].pop_back();\n                flag = 1;\n            }\n            return flag;\n        }\n        int M = L + R >> 1;\n        return flag | merge(u << 1, L, M, l, r, v) | merge(u << 1 | 1, M + 1, R, l, r, v);\n    }\n} seg;\ninline bool cmp(Square a, Square b) { return a.lx != b.lx ? a.lx < b.lx : (a.rx != b.rx ? a.rx < b.rx : (a.ly != b.ly ? a.ly < b.ly : a.ry < b.ry)); }\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) a[i].read();\n    sort(a + 1, a + n + 1), sort(tab + 1, tab + len + 1), len = unique(tab + 1, tab + len + 1) - tab - 1;\n    for (int i = 1; i <= n; i++) {\n        a[i].lx = lower_bound(tab + 1, tab + len + 1, a[i].lx) - tab;\n        a[i].rx = lower_bound(tab + 1, tab + len + 1, a[i].rx) - tab;\n    }\n    for (int i = 1; i <= n; i++) {\n        while (seg.merge(1, 1, len, a[i].lx, a[i].rx, i))\n            ;\n        seg.update(1, 1, len, a[i].lx, a[i].rx, i);\n    }\n    // for (int i = 1; i <= n; i++) --a[i].lx, --a[i].ly;\n    int cnt = 0;\n    for (int i = 1; i <= n; i++)\n        if (!vis[i]) a[++cnt] = a[i];\n    sort(a + 1, a + cnt + 1, cmp), cout << cnt << endl;\n    for (int i = 1; i <= cnt; i++) a[i].print();\n    return 0;\n}\n```",
        "postTime": 1668727592,
        "uid": 615348,
        "name": "zhouershan",
        "ccfLevel": 7,
        "title": "P5998 [PA2014]Plemiona \u9898\u89e3"
    },
    {
        "content": "\u5f88\u5999\u7684\u9898\u554a\uff01\n\n\u5c06\u6bcf\u4e2a\u77e9\u5f62\u7684 $x_1,y_1$ \u5206\u522b $+1$\uff0c\u8fd9\u6837\u4e24\u4e2a\u77e9\u5f62\u53ef\u5408\u5e76\u7b49\u4ef7\u4e8e\u4e24\u7ef4\u7684\u533a\u95f4 $[x_1,x_2],[y_1,y_2]$ \u5206\u522b\u6709\u4ea4\uff08\u7ebf\u6bb5\u4ea4\u7684\u957f\u5ea6 $>0$\uff09\u3002\n\n\u6211\u4eec\u5728 $O(\\log n)$ \u7684\u65f6\u95f4\u5185**\u627e\u5230**\u4e24\u4e2a\u53ef\u5408\u5e76\u7684\u77e9\u5f62\u518d**\u5408\u5e76**\uff0c\u7531\u4e8e\u6700\u591a\u5408\u5e76 $n-1$ \u6b21\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u662f $O(n\\log n)$ \u7684\u3002\n\n\u6211\u4eec\u6309 $x$ \u8f74\u5efa\u7ebf\u6bb5\u6811\uff0c\u4f9d\u6b21 $^{*}$ \u63d2\u5165\u77e9\u5f62\uff0c\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9 $[l,r]$ \u5b58\u4e24\u4e2a\u77e9\u5f62\u7f16\u53f7**\u6808** $A,B$\uff0c\u5206\u522b\u8868\u793a $[l',r']$ \u4e0e $[l,r]$ \u6709\u4ea4\u4f46\u4e0d\u5305\u542b $[l,r]$ \u7684\u77e9\u5f62\uff08\u6211\u4eec\u7528 $[l',r']$ \u8868\u793a\u77e9\u5f62\u7684 $x$ \u8f74\uff09\uff0c$[l,r]$ \u88ab $[l',r']$ \u5305\u542b\uff0c\u4f46\u662f $[l_0,r_0]$ \u4e0d\u88ab $[l',r']$ \u5305\u542b\u7684\u77e9\u5f62\uff08$[l_0,r_0]$ \u8868\u793a $[l,r]$ \u7ebf\u6bb5\u6811\u8282\u70b9\u7684\u7236\u8282\u70b9\u7684\u8303\u56f4\uff09\u3002\n\n\u4f46\u662f\u6211\u4eec\u5ffd\u7565\u4e86 $y$ \u8f74\u7684\u60c5\u51b5\uff0c\u53d1\u73b0\u6211\u4eec\u4e0a\u8ff0\u7684 $*$ \u201c\u4f9d\u6b21\u201d\u987a\u5e8f\u6539\u4e3a\u6309 $y_1$ \u975e\u9012\u51cf\u63d2\u5165\u5373\u53ef\u3002\n\n\u5982\u679c\u4e00\u4e2a\u77e9\u5f62\u88ab\u5408\u5e76\u5230\u4e86\u522b\u7684\u77e9\u5f62\u5185\u4e86\u6211\u4eec\u5c31\u6253\u4e00\u4e2a\u6b7b\u4ea1\u6807\u8bb0\uff0c\u4e0b\u6b21\u5728\u4efb\u4f55\u6808\u91cc\u53d1\u73b0\u4ed6\u90fd\u76f4\u63a5\u6254\u6389\u5373\u53ef\u3002\n\n\u8fd9\u91cc\u6808\u7528 vector \u5b9e\u73b0~~\u61d2\u5f97\u5199\u94fe\u8868~~\uff0c\u8dd1\u5f97\u5f88\u6162\u3002\n\n\u5176\u5b9e\u8fd9\u4e2a $O(n\\log n)$ \u4e0d\u592a\u597d\u8bc1\uff0c\u662f\u4e00\u5927\u5806\u5747\u644a\u3002\n\n```cpp\n/*\n* Author: ShaoJia\n* Last Modified time: 2022-10-14 15:19:26\n* Motto: We'll be counting stars.\n*/\n// #pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define debug(...) cerr<<\"#\"<<__LINE__<<\": \"<<__VA_ARGS__<<endl\n#define For(i,j,k) for(int i=(j),i##_=(k);i<=i##_;i++)\n#define Rof(i,j,k) for(int i=(j),i##_=(k);i>=i##_;i--)\n#define lob lower_bound\n#define upb upper_bound\n#define fir first\n#define sec second\n#define mkp make_pair\n#define mkt make_tuple\n#define siz(x) ((int)(x).size())\n#define pb emplace_back\n#define ckmx(a,b) a=max(a,b)\n#define ckmn(a,b) a=min(a,b)\n#define ll long long\n#define pi pair<int,int>\n#define N 100005\nstruct node{\n\tvector<int> bc,in;\n}t[N<<3];//(2*N)*4\nstruct rec{\n\tint x,xx,y,yy;\n\trec(){}\n\trec(int k1,int k2,int k3,int k4){ x=k1,xx=k2,y=k3,yy=k4; }\n\tfriend rec operator+(const rec& x,const rec& y){\n\t\treturn rec(min(x.x,y.x),max(x.xx,y.xx),min(x.y,y.y),max(x.yy,y.yy));\n\t}\n\tfriend void operator+=(rec& x,const rec& y){\n\t\tx=x+y;\n\t}\n\tfriend bool operator<(const rec& x,const rec& y){\n\t\tif(x.x!=y.x) return x.x<y.x;\n\t\tif(x.xx!=y.xx) return x.xx<y.xx;\n\t\tif(x.y!=y.y) return x.y<y.y;\n\t\treturn x.yy<y.yy;\n\t}\n}a[N];\nvector<rec> out;\nint b[N],n,so[N<<1],lim=0;\nbool kil[N];\nbool cmp(int x,int y){ return a[x].yy<a[y].yy; }\nvoid flush(vector<int>& v){ if(!v.empty() && kil[v.back()]) v.pop_back(); }\nint top(vector<int>& v){ flush(v); return v.back(); }\nbool empty(vector<int>& v){ flush(v); return v.empty(); }\n#define mid ((l+r)>>1)\n#define ls (rt<<1)\n#define rs (rt<<1|1)\nvoid add(int rt,int l,int r,int x,int y,int id){\n\tif(x<=l && r<=y){\n\t\t// cout<<l<<\"~\"<<r<<\" bc \"<<id<<endl;\n\t\treturn t[rt].bc.pb(id),void();\n\t}\n\tif(x<=mid) add(ls,l,mid,x,y,id);\n\tif(y>mid) add(rs,mid+1,r,x,y,id);\n}\nvoid Add(int rt,int l,int r,int x,int id){\n\tt[rt].in.pb(id);\n\t// cout<<l<<\"~\"<<r<<\" in \"<<id<<endl;\n\tif(l==r) return ;\n\tif(x<=mid) Add(ls,l,mid,x,id);\n\telse Add(rs,mid+1,r,x,id);\n}\nbool calc(int rt,int l,int r,int x,int id){\n\tif(!empty(t[rt].bc)){\n\t\tint s=top(t[rt].bc);\n\t\tif(a[s].yy>=a[id].y){\n\t\t\tkil[s]=true;\n\t\t\t// cout<<s<<\"->\"<<id<<endl;\n\t\t\ta[id]+=a[s];\n\t\t\treturn true;\n\t\t}\n\t}\n\tif(l==r) return false;\n\tif(x<=mid) return calc(ls,l,mid,x,id);\n\telse return calc(rs,mid+1,r,x,id);\n}\nbool que(int rt,int l,int r,int x,int y,int id){\n\tif(x<=l && r<=y){\n\t\tif(!empty(t[rt].in)){\n\t\t\tint s=top(t[rt].in);\n\t\t\tif(a[s].yy>=a[id].y){\n\t\t\t\tkil[s]=true;\n\t\t\t\t// cout<<s<<\"->\"<<id<<endl;\n\t\t\t\ta[id]+=a[s];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tif(x<=mid){\n\t\tif(que(ls,l,mid,x,y,id)) return true;\n\t}\n\tif(y>mid){\n\t\tif(que(rs,mid+1,r,x,y,id)) return true;\n\t}\n\treturn false;\n}\nbool work(int id){\n\tif(calc(1,1,lim,a[id].x,id)) return true;\n\tif(calc(1,1,lim,a[id].xx,id)) return true;\n\tif(a[id].x<a[id].xx-1 && que(1,1,lim,a[id].x+1,a[id].xx-1,id)) return true;\n\treturn false;\n}\nsigned main(){ios::sync_with_stdio(false),cin.tie(nullptr);\n\tcin>>n;\n\tFor(i,1,n) cin>>a[i].x>>a[i].xx>>a[i].y>>a[i].yy,a[i].x++,a[i].y++;\n\tFor(i,1,n) so[++lim]=a[i].x,so[++lim]=a[i].xx;\n\tsort(so+1,so+1+lim);\n\tlim=unique(so+1,so+1+lim)-so-1;\n\tFor(i,1,n)\n\t\ta[i].x=lob(so+1,so+1+lim,a[i].x)-so,\n\t\ta[i].xx=lob(so+1,so+1+lim,a[i].xx)-so;\n\t// For(i,1,n) cout<<a[i].x<<\"~~~\"<<a[i].xx<<endl;\n\t// For(i,1,lim) cout<<so[i]<<\"*\"; cout<<endl;\n\tiota(b+1,b+1+n,1);\n\tsort(b+1,b+1+n,cmp);\n\tint x;\n\tFor(i,1,n){\n\t\tx=b[i];\n\t\t// debug(x<<\">>>\");\n\t\twhile(work(x));\n\t\tadd(1,1,lim,a[x].x,a[x].xx,x);\n\t\tAdd(1,1,lim,a[x].x,x);\n\t\tAdd(1,1,lim,a[x].xx,x);\n\t}\n\tFor(i,1,n) if(!kil[i]) out.pb(a[i]);\n\tsort(out.begin(),out.end());\n\tcout<<siz(out)<<\"\\n\";\n\tfor(auto i:out) cout<<so[i.x]-1<<\" \"<<so[i.xx]<<\" \"<<i.y-1<<\" \"<<i.yy<<\"\\n\";\nreturn 0;}\n```",
        "postTime": 1665760040,
        "uid": 101868,
        "name": "I_am_Accepted",
        "ccfLevel": 0,
        "title": "P5998 [PA2014]Plemiona\uff08Hard \u7ebf\u6bb5\u6811+\u6808\uff09"
    }
]