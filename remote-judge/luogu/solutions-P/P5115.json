[
    {
        "content": "\u65f6\u4ee3...\u53d8\u4e86\u554a...\n\norz _rqy shadowice1984\n\n-----\n\n\u4e00\u5f00\u59cb\u80e1\u51fa\u6765\u4e00\u4e2a\u60f3\u60f3\u5c31\u5de8\u5927\u957f\u7684\u4fe9log\u7684dsu\u505a\u6cd5\uff0c\u770b\u770b\u9898\u89e3\u53d1\u73b0\u6709\u7cbe\u5de7\u505a\u6cd5\n\n\u5bf9\u4e8e $(i,j)$ \uff0c\u6211\u4eec\u53d1\u73b0 $S[i-lcs(i,j)+1,i+lcp(i,j)-1]$ \u548c $S[j-lcs(i,j)+1,j+lcp(i,j)-1]$ \u662f\u5b8c\u5168\u76f8\u540c\u7684\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u679a\u4e3e\u6240\u6709\u8fd9\u6837\u7684\u5b50\u4e32\u6765\u8ba1\u7b97\u8d21\u732e\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u5b50\u4e32 $T$\uff0c\u8003\u8651\u5b83\u7684\u4e24\u4e2a\u51fa\u73b0\u4f4d\u7f6e\uff0c\u5982\u679c\u8fd9\u4e24\u6b21\u51fa\u73b0\u90fd\u662f**\u6781\u957f**\u7684\uff08\u5373\u5411\u5de6\u5411\u53f3\u6269\u5c55\u90fd\u4f1a\u4f7f\u5f97\u8fd9\u4e24\u4e2a\u4e32\u4e0d\u540c\uff09\uff0c\u90a3\u4e48 $T$ \u4e2d\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u90fd\u4f1a\u9020\u6210\u8d21\u732e. \u5177\u4f53\u5730\uff0c\u8fd9\u4e2a\u8d21\u732e\u662f\n\n$$\n\\sum_{i=1}^{|T|}[i\\leq k2,|T|-i+1\\leq k1]i(|T|-i+1)\n$$\n\n\u5373\u679a\u4e3e $lcs$ \u7684\u957f\u5ea6 $i$. \u4e0a\u5f0f\u5bb9\u6613 $O(1)$ \u8ba1\u7b97. \u90a3\u4e48\u6211\u4eec\u8003\u8651\u5728SAM\u7684parent tree\u4e0a\u8ba1\u7b97\uff0c\u6bcf\u6b21\u5408\u5e76\u4e0a\u6765\u4e00\u4e2a\u5b50\u6811\u8ba1\u7b97\u7b54\u6848\uff0c\u663e\u7136\u6211\u4eec\u5e94\u8be5\u53ea\u8ba1\u7b97\u8be5\u8282\u70b9\u7684\u6700\u957f\u4e32\u7684\u8d21\u732e\uff0c\u5bb9\u6613\u77e5\u9053\u65b0\u5408\u5e76\u4e0a\u6765\u7684\u8282\u70b9\u7684\u5de6\u7aef\u4e00\u5b9a\u662f\u6781\u957f\u7684\uff0c\u53ea\u9700\u8981\u9650\u5236\u53f3\u8fb9\u6781\u957f\uff0c\u90a3\u4e48\u6211\u4eec\u7528\u603b\u7684\u51cf\u53bb\u53f3\u8fb9\u975e\u6781\u957f\u7684\uff0c\u8fd9\u4e2a\u53ea\u9700\u8981\u5bf9\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a $cnt[u][c]$ \u8868\u793a\u5176\u6240\u6709endpos\u4e2d\u4e0b\u4e00\u4f4d\u4e3a $c$ \u7684\u65b9\u6848\u6570\u5373\u53ef. \n\n\u590d\u6742\u5ea6 $O(26n)$\uff0c\u975e\u5e38\u597d\u5199.\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N=2e5+5000;\nstruct Node{int len,fa,ch[26];}a[N];\nunsigned long long f[N];\nint size[N],cnt[N][26],K1,K2,n,precnt[N],cur,node_cnt,id[N];\nchar st[N];\nunsigned long long calc1(int n){return 1ull*n*(n+1)>>1;}\nunsigned long long calc2(int n){return 1ull*n*(n-1)*(n+1)/3;}\nvoid prework()\n{\n    for(int i=1;i<=n;i++)//\u9884\u5904\u7406f[i]\u8868\u793a|T|=i\u7684\u8d21\u732e\n    {\n        int l=max(1,i-K2+1),r=min(i,K1);\n        if(l<=r)f[i]=i*(calc1(r)-calc1(l-1))-(calc2(r)-calc2(l-1));\n    }\n}\nvoid ins(int ch,int pos)\n{\n    int u=cur;cur=++node_cnt;a[cur].len=a[u].len+1;\n    size[cur]=1;if(pos!=n)cnt[cur][st[pos+1]-97]=1;\n    for(;u&&!a[u].ch[ch];u=a[u].fa)a[u].ch[ch]=cur;\n    if(!u){a[cur].fa=1;return;}\n    int v=a[u].ch[ch];if(a[v].len==a[u].len+1){a[cur].fa=v;return;}\n    int t=++node_cnt;a[t]=a[v];a[t].len=a[u].len+1;\n    a[cur].fa=a[v].fa=t;\n    for(;u&&a[u].ch[ch]==v;u=a[u].fa)a[u].ch[ch]=t;\n}\nvoid merge(int u,int v)\n{\n    size[u]+=size[v];\n    for(int i=0;i<26;i++)cnt[u][i]+=cnt[v][i];\n}\nunsigned long long calc(int u,int v)\n{\n    unsigned long long ans=1ull*size[u]*size[v];//\u603b\u7684\n    for(int i=0;i<26;i++)ans-=1ull*cnt[u][i]*cnt[v][i];//\u975e\u6781\u957f\u7684\n    return ans;\n}\nint main()\n{\n    scanf(\"%s\",st+1);n=strlen(st+1);node_cnt=cur=1;\n    for(int i=1;i<=n;i++)ins(st[i]-97,i);\n    scanf(\"%d%d\",&K1,&K2);\n    prework();\n    for(int i=1;i<=node_cnt;i++)precnt[a[i].len]++;\n    for(int i=1;i<=n;i++)precnt[i]+=precnt[i-1];\n    for(int i=1;i<=node_cnt;i++)id[precnt[a[i].len]--]=i;\n    unsigned long long ans=0;\n    for(int i=node_cnt;i>=2;i--)\n    {\n        int u=id[i],fa=a[u].fa;\n        ans+=f[a[fa].len]*calc(fa,u);merge(fa,u);//\u8d21\u732e\u7cfb\u6570\u76f8\u540c\uff0c\u53ea\u9700\u8981\u7b97\u65b9\u6848\u6570\n    }\n    cout<<ans<<endl;\n}\n```",
        "postTime": 1593674665,
        "uid": 22136,
        "name": "qwaszx",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P5115 \u3010Check,Check,Check one two!\u3011"
    },
    {
        "content": "[\u6b22\u8fce\u6765\u6211\u7684blog\u901b\u901b](https://blog.csdn.net/Dream_Lolita/article/details/85318555)\n\n\u8fd9\u4e2a\u505a\u6cd5\u662f\u5728\u95ee\u4e86rqy\u5de8\u4f6c\u4ee5\u540e\u624d\u4f1a\u7684\uff0c\u4e00\u65f6\u89c9\u5f97\u81ea\u5df1\u5341\u5206\u83dc\uff0crqy\u8d5b\u9ad8\uff01\n\n\u6211\u4eec\u8981\u6c42\u7684\u662f\u8fd9\u4e2a\u4e1c\u897f\uff1a\n$$\\sum_{1\\leq i<j\\leq n}lcp(i,j)lcs(i,j)[lcp(i,j)\\leq k_1][lcs(i,j)\\leq k_2]$$\n\u5176\u4e2d$lcp(i,j)$\u8868\u793a\u7b2c$i$\u4e2a\u540e\u7f00\u548c\u7b2c$j$\u4e2a\u540e\u7f00\u7684$lcp$\uff0c$lcs(i,j)$\u8868\u793a\u7b2c$i$\u4e2a\u524d\u7f00\u548c\u7b2c$j$\u4e2a\u524d\u7f00\u7684$lcs$\u3002\n\n\u7531\u4e8e\u9898\u76ee\u4e2d\u5b9a\u4e49\u7684$lcp$\u548c$lcs$\u662f\u4ee5\u4e00\u4e2a\u70b9\u4e3a\u4e2d\u5fc3\u5f80\u4e24\u8fb9\u8ba1\u7b97\u7684\uff0c\u6211\u4eec\u4e0d\u59a8\u5c06\u5b83\u4eec\u62fc\u5728\u4e00\u8d77\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u6211\u4eec\u77e5\u9053$lcp(i,j)$\u548c$lcs(i,j)$\uff0c\u90a3\u4e48\u6211\u4eec\u4e0d\u96be\u5f97\u5230\uff1a$$S[i-lcp(i,j)+1\\dots i+lcs(i,j)-1]=S[j-lcp(i,j)+1\\dots j+lcs(i,j)-1]$$\n\u4e14$$S[i-lcp(i,j)]\\neq S[j-lcp(i,j)],S[i+lcs(i,j)]\\neq S[j+lcs(i,j)]$$\n\n\u90a3\u4e48\u73b0\u5728\u6211\u4eec\u76f8\u5f53\u4e8e\u5f97\u5230\u4e00\u4e2a\u957f\u5ea6\u4e3a$len=lcp(i,j)+lcs(i,j)-1$\u7684\u4e32\uff0c\u8fd9\u4e2a\u4e32\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u53ef\u4ee5\u4f5c\u4e3a\u4e2d\u95f4\u70b9\u6765\u8ba1\u7b97\u8d21\u732e\u3002\u8fd9\u4e2a\u8d21\u732e\u6211\u4eec\u662f\u53ef\u4ee5\u5feb\u901f\u8ba1\u7b97\u51fa\u6765\u7684\uff0c\u5177\u4f53\u6765\u8bf4\u6211\u4eec\u6709\uff1a\n$$\\sum_{i=1}^{k_1}i(len-i+1)-\\sum_{i=1}^{len-k_2}(len-i+1)$$\n\u8fd9\u91cc\u7684\u4e0a\u4e0b\u6807\u53ef\u80fd\u9700\u8981\u53d6\u4e2a$\\text{max}$\u6216$\\text{min}$\uff0c\u5177\u4f53\u53ef\u4ee5\u770b\u4ee3\u7801\u6216\u8005\u624b\u63a8\u4e00\u6ce2\u3002\n\n\u4e8e\u662f\u6211\u4eec\u5bf9$S$\u5efa\u51fa\u540e\u7f00\u6570\u7ec4\uff0c\u90a3\u4e48\u6211\u4eec\u8981\u8003\u8651\u7684\u5c31\u662f\u6bcf\u4e24\u4e2a\u540e\u7f00\u4e4b\u95f4\u7684\u8d21\u732e\u3002\u663e\u7136\u4e24\u4e2a\u540e\u7f00$i,j$\u6709\u8d21\u732e\u5f53\u4e14\u4ec5\u5f53\u5b83\u4eec\u7684$lcp$\u4e0d\u4e3a$0$\u4e14$S[i-1]\\neq S[j-1]$\u3002\n\n\u8fd9\u6837\u505a\u6cd5\u5c31\u6bd4\u8f83\u663e\u7136\u4e86\uff1a\u6bcf\u4e2a\u540e\u7f00$i$\u8981\u8bb0\u5f55$S[i-1]$\u662f\u4ec0\u4e48\u5b57\u7b26\uff0c\u6309$\\text{height}$\u4ece\u5927\u5230\u5c0f\u62c6\u9694\u677f\u8fdb\u884c\u542f\u53d1\u5f0f\u5408\u5e76\uff0c\u8003\u8651\u6709\u591a\u5c11\u5bf9\u8d21\u732e\u7684\u65f6\u5019\u76f4\u63a5\u5bb9\u65a5\u4e00\u4e0b\uff0c\u7136\u540e\u4e58\u4e0a\u957f\u5ea6\u4e3a\u5f53\u524d$\\text{height}$\u7684\u8d21\u732e\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u662f$O(n\\log n)$\u7684\uff0c\u5199\u8d77\u6765\u7b80\u5355\u6613\u61c2\u3002\n\n\u7531\u4e8e\u4e00\u4e9b\u5947\u602a\u7684\u539f\u56e0\u6211\u7684\u540e\u7f00\u6570\u7ec4\u677f\u5b50\u5e76\u4e0d\u592a\u5bf9\uff0c\u5728\u5efa\u51fa\u6765\u4ee5\u540e\u9700\u8981\u4e00\u4e9b\u201c\u8c03\u6574\u201d\uff0c\u5927\u5bb6\u5927\u53ef\u4ee5\u5ffd\u7565\u4e0b\u9762\u7684\u4ee3\u7801\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define mkp make_pair\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int N=1e5+10;\nint n,k1,k2;\nint a[N],lp[N],rp[N],siz[N],bl[N],cnt[N][28];\nchar s[N];\npii h[N];\null ans,f[N];\n\nnamespace SA\n{\n\tint rk[N],hi[N];\n\tint wa[N],wb[N],wx[N],wy[N],sa[N];\n\tbool cmp(int *r,int a,int b,int l){return r[a]==r[b] && r[a+l]==r[b+l];}\n\tvoid getsa(int *r,int n,int m)\n\t{\n\t\tint *x=wa,*y=wb,*t,i,j,p;\n\t\tfor(i=0;i<m;++i) wx[i]=0;\n\t\tfor(i=0;i<n;++i) wx[x[i]=r[i]]++;\n\t\tfor(i=1;i<m;++i) wx[i]+=wx[i-1];\n\t\tfor(i=n-1;~i;--i) sa[--wx[x[i]]]=i;\n\t\tfor(j=1,p=0;p<n;j<<=1,m=p)\n\t\t{\n\t\t\tfor(p=0,i=n-j;i<n;++i) y[p++]=i;\n\t\t\tfor(i=0;i<n;++i) if(sa[i]>=j) y[p++]=sa[i]-j;\n\t\t\tfor(i=0;i<m;++i) wx[i]=0;\n\t\t\tfor(i=0;i<n;++i) wx[wy[i]=x[y[i]]]++;\n\t\t\tfor(i=1;i<m;++i) wx[i]+=wx[i-1];\n\t\t\tfor(i=n-1;~i;--i) sa[--wx[wy[i]]]=y[i];\n\t\t\tfor(t=x,x=y,y=t,p=1,x[sa[0]]=0,i=1;i<n;++i) \n\t\t\t\tx[sa[i]]=cmp(y,sa[i-1],sa[i],j)?p-1:p++;\n\t\t}\n\t}\n\tvoid getheight(int *r)\n\t{\n\t\tint i,j,k=0;\n\t\tfor(i=1;i<=n;++i) rk[sa[i]]=i;\n\t\tfor(i=0;i<n;hi[rk[i++]]=k)\n\t\t\tfor(k?k--:0,j=sa[rk[i]-1];r[i+k]==r[j+k];++k);\n\t}\n\tvoid adjust()\n\t{\n\t\tfor(int i=1;i<=n;++i) sa[i]++;\n\t\tfor(int i=n;i;--i) rk[i]=rk[i-1];\n\t\tsa[0]=rk[0]=0;\n\t}\n}\nusing namespace SA;\n\null sq(int x){return (ull)(x+1)*x/2;}\null sq2(int x){return (ull)x*(2*x+1)*(x+1)/6;}\null getf(int x)\n{\n\tif(x>=k1+k2)return 0;\n\tull s1=(ull)sq(min(x,k1))*(x+1)-sq2(min(x,k1));\n\tull s2=(ull)sq(max(0,x-k2))*(x+1)-sq2(max(0,x-k2));\n\treturn (ull)s1-s2;\n}\n\nvoid init()\n{\n\tscanf(\"%s%d%d\",s,&k1,&k2);n=strlen(s);\n\tk1=min(k1,n);k2=min(k2,n);\n\tfor(int i=1;i<=n;++i) f[i]=getf(i);\n\tfor(int i=0;i<n;++i) a[i]=s[i]-'a'+1;\n\tgetsa(a,n+1,30);getheight(a);adjust();\n\tfor(int i=n;i;--i) a[i]=a[i-1]; a[0]=0;\n\tfor(int i=1;i<=n;++i) lp[i]=rp[i]=bl[i]=i,siz[i]=1,cnt[i][a[sa[i]-1]]++;\n\tfor(int i=2;i<=n;++i) h[i-1]=mkp(-hi[i],i);\n\tsort(h+1,h+n);\n}\n\null calc(int x,int y)\n{\n\tull res=(ull)siz[x]*siz[y];\n\tfor(int i=1;i<=26;++i) res-=(ull)cnt[x][i]*cnt[y][i];\n\treturn res; \n}\n\nvoid merge(int x,int y)\n{\n\tfor(int i=1;i<=26;++i) cnt[y][i]+=cnt[x][i];\n\tfor(int i=lp[x];i<=rp[x];++i) bl[i]=y;\n\tlp[y]=min(lp[y],lp[x]);rp[y]=max(rp[y],rp[x]);siz[y]+=siz[x];\n}\n\nvoid solve()\n{\n\tfor(int i=1;i<n;++i) \n\t{\n\t\tint len=-h[i].fi,x=bl[h[i].se],y=bl[h[i].se-1];\n\t\tif(siz[x]>siz[y]) swap(x,y);\n\t\tans+=(ull)f[len]*calc(x,y);merge(x,y);\n\t}\n\tprintf(\"%llu\",ans);\n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"LGP5115.in\",\"r\",stdin);\n\tfreopen(\"LGP5115.out\",\"w\",stdout);\n#endif\n\tinit();solve();\n\treturn 0;\n}\n```\n\n\n",
        "postTime": 1545976009,
        "uid": 15438,
        "name": "Durant_Lee",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5115 \u3010Check,Check,Check one two!\u3011"
    },
    {
        "content": "\u9996\u5148\u6211\u4eec\u8003\u8651\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u5bf9$(i,j)$\u6765\u8bf4\uff0c\u8981\u627e\u5230\u524d\u9762\u6781\u957f\u7684\u5339\u914d$a$\uff0c\u540e\u9762\u6781\u957f\u7684\u5339\u914d$b$\uff0c\u8d21\u732e\u662f\u4e24\u8005\u957f\u5ea6\u7684\u4e58\u79ef$(a+1)*(b+1)$\uff0c\u6211\u4eec\u8003\u8651\u5728SAM\u4e0a$(i+p,j+p),p\\in[0,b]$\u4e24\u4e2a$endpos$\u5408\u5e76\u65f6\u7edf\u8ba1$(i,j)$\u7684\u8d21\u732e\u3002\n\n\u7531\u4e8e\u540e\u7f00\u81ea\u52a8\u673a\u4e0a\u4e24\u4e2a$endpos$\u7684$LCA$\u7684$maxlen$\u5c31\u662f\u5bf9\u5e94\u4e24\u4e2a\u524d\u7f00\u7684\u6700\u957f\u516c\u5171\u540e\u7f00\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u80af\u5b9a\u7684\u662f\uff0c\u5f53$(i+p,j+p)$\u5408\u5e76\u65f6\uff0c\u8bbe\u5bf9\u5e94\u70b9\u7684$maxlen$\u4e3a$c$\uff0c$(i+p-c+1,j+p-c+1)=(i-a,j-a)$\n\n$(i,j)$\u4f1a\u88ab$b+1$\u79cd\u70b9\u5bf9\u7edf\u8ba1\u5230\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5728\u6bcf\u4e00\u6b21\u88ab\u7edf\u8ba1\u5230\u65f6\u7ed9\u7b54\u6848\u52a0\u4e0a$a+1$\u5c31\u53ef\u4ee5\u4e86\u3002\u5728$SAM$\u8282\u70b9\u4e0a\uff0c\u8d21\u732e\u548c\u76f8\u5f53\u4e8e\u6bcf\u6b21\u52a0\u4e00\u4e2a\u7b49\u5dee\u6570\u5217\u3002\n\u8fd9\u65f6\u5019\u6ca1\u6709$k1,k2$\u9650\u5236\u7684\u7b54\u6848\u5df2\u7ecf\u51fa\u6765\u4e86\u3002\n\u8003\u8651\u4e0a$k2$\u7684\u9650\u5236\uff0c\u6211\u4eec\u53d1\u73b0\u53ea\u8981\u9650\u5236\u4e00\u4e0b\u6bcf\u6b21\u52a0\u7684\u7b49\u5dee\u6570\u5217\u7684\u672b\u9879\u4e0d\u5927\u4e8e$k2$\u5c31\u53ef\u4ee5\u4e86\u3002\n\n$k1$\u7684\u9650\u5236\u600e\u4e48\u529e\uff0c\u5bf9\u4e8e\u4e00\u4e2a$SAM$\u4e0a\u7684\u8282\u70b9\uff0c\u6211\u4eec\u770b\u662f\u5426\u5b58\u5728\u88ab**\u6070\u597d**\u8ba1\u7b97\u7b2c$k1+1$\u6b21\u7684\u8282\u70b9\uff0c\u5982\u679c\u5b58\u5728\uff0c\u90a3\u4e48\u51cf\u53bb\u5176\u4ea7\u751f\u7684\u6240\u6709\u8d21\u732e\u3002\u540c\u65f6\uff0c\u8fd9\u4e2a\u8fd8\u9650\u5236\u4e86\u7b49\u5dee\u6570\u5217\u7684\u9996\u9879\u4e0d\u5c0f\u4e8e$maxlen_i-k1+1$\u3002\u5177\u4f53\u53ef\u4ee5\u770b\u770b\u4ee3\u7801\u600e\u4e48\u5199\u3002\n\n\u597d\u50cf\u6211\u7684\u505a\u6cd5\u4e0e\u5176\u4ed6\u9898\u89e3\u4e0d\u5927\u76f8\u540c\uff0c\u540c\u65f6\u4e5f\u4ee5$90ms$\u7684\u8fd0\u884c\u65f6\u95f4\u6210\u4e3a\u4e86**\u9898\u89e3\u63d0\u4ea4\u65f6\u95f4\u4e3a\u6b62**\u7684\u6700\u4f18\u89e3\u3002\n\n\u4ee3\u7801\u5341\u5206\u7b80\u6d01\u660e\u4e86\uff0c\u4e2a\u4eba\u5728\u5904\u7406$SAM$\u4e0a$fail$\u6811\u5408\u5e76\u95ee\u9898\u65f6\u949f\u7231\u5bf9\u957f\u5ea6\u57fa\u6570\u6392\u5e8f\u3002\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nint fail[N],ch[N][26],mx[N],n,k1,k2,las,rig[N],sum[N],a[N],tot;\nunsigned long long op[N],ans;\nchar s[N];\n\nvoid insert(int c){\n\tint x=++tot,p=las;las=x;mx[x]=mx[p]+1;rig[x]=1;\n\tfor(;p!=-1 && !ch[p][c];p=fail[p]) ch[p][c]=x;\n\tif(p==-1) fail[x]=0;\n\telse if(mx[ch[p][c]]==mx[p]+1) fail[x]=ch[p][c];\n\telse{\n\t\tint q=++tot,tmp=ch[p][c];mx[q]=mx[p]+1;\n\t\tfail[q]=fail[tmp];fail[x]=fail[tmp]=q;\n\t\tfor(int i=0;i<26;i++) ch[q][i]=ch[tmp][i];\n\t\tfor(;p!=-1 && ch[p][c]==tmp;p=fail[p]) ch[p][c]=q;\n\t}\n}\n\nunsigned long long gs(int x,int y){\n\tif(x>y) return 0;\n\treturn 1ull*(x+y)*(y-x+1)/2;\n}\n\nint main(){\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d %d\",&k1,&k2);fail[0]=-1;\n\tfor(int i=1;i<=n;i++) insert(s[i]-'a');\n\tfor(int i=1;i<=tot;i++) sum[mx[i]]++;\n\tfor(int i=n;i>=1;i--) sum[i]+=sum[i+1];\n\tfor(int i=1;i<=tot;i++) a[sum[mx[i]]--]=i;\n\tfor(int i=1;i<=tot;i++){\n\t\tint x=a[i];\n\t\top[fail[x]]+=1ull*rig[x]*rig[fail[x]];\n\t\trig[fail[x]]+=rig[x];\n\t\tans+=op[x]*gs(max(1,mx[x]-k1+1),min(k2,mx[x]));\n\t\tif(mx[x]>k1 && mx[x]-k1<=k2) ans-=1ull*op[x]*(mx[x]-k1)*k1;\n\t}\n\tprintf(\"%llu\\n\",ans);\n}\n```\n",
        "postTime": 1611838519,
        "uid": 29093,
        "name": "Deep_Kevin",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P5115 \u3010Check,Check,Check one two!\u3011"
    },
    {
        "content": "[\u535a\u5ba2\u94fe\u63a5](https://blog.csdn.net/calabash_boy/article/details/102559568)\n# \u9898\u610f\n\u7ed9\u51fa\u4e32$S$\uff0c$K1,K2$\uff0c\u6c42\n$$\\sum_{1 \\le i < j \\le n}{LCP(i,j) \\cdot LCS(i,j) \\cdot [LCP(i,j) \\le K1] \\cdot [LCS(i,j) \\le K2]}$$\n\n# \u9898\u89e3\n\u4e0d\u662f\u5f88\u61c2\u8fb9\u5206\u6811\u600e\u4e48\u7ef4\u62a4\u4fe1\u606f\u7684\u3002\u3002\u3002\u53ea\u4f1a\u8fb9\u5206\u3002\n\u9996\u5148\u5bf9\u539f\u4e32$S$\u548c\u53cd\u4e32$S'$\u5efa\u7acbSAM\uff0c\u7136\u540e\u53d6\u51fa\u4e24\u68f5$parent$\u6811\uff0c\u7136\u540e\u5728$S$\u7684SAM\u4e2d\u627e\u5230\u6bcf\u4e2a\u524d\u7f00\u70b9\uff0c\u4ee5\u53ca$S'$\u7684SAM\u4e2d\u7684\u6bcf\u4e2a\u540e\u7f00\u70b9\uff0c\u5206\u522b\u6807\u53f7\u4e3a$1..i$\u3002\n\u5219\u6c42\u7684\u4e1c\u897f\u5c31\u662f\n$$\n\\sum_{1 \\le i < j \\le n}{len[LCA(i,j)] \\cdot len'[LCA'(i,j)] \\cdot [len[LCA(i,j)] \\le K2] \\cdot [len'[LCA'(i,j)]\\le K1]}\n$$\n\u76ee\u524d\u4e3a\u6b62\u770b\u8d77\u6765\u8fd8\u662f\u5f88\u70e6\uff0c\u6211\u4eec\u7ee7\u7eed\u5904\u7406\u4e00\u4e0b\uff0c\u5c06$parent$\u6811\u770b\u6210\u4e00\u4e2a\u6709\u6839\u6709\u8fb9\u6743\uff08\u53ef\u4ee5\u8d1f\uff09\u7684\u6811\uff0c\u5c06\u6bcf\u4e2a\u70b9\u7684$len$($len'$)\u89c6\u4f5c\u662f\u4ed6\u5230\u6839\u7684\u8ddd\u79bb\u3002\u7136\u540e\u5c06$S$\u7684$parent$\u6811\u4e2d$len > K2$\u70b9\u7684$len$\u7f6e\u4e3a0\uff0c\u540c\u7406\u5c06$S'$\u7684$parent$\u6811\u4e2d$len > K1$\u70b9\u7684$len'$\u7f6e\u4e3a0\u3002**\u4e4b\u540e\u4fbf\u53ef\u4ee5\u8ba4\u4e3a\u662f\u4e00\u68f5\u6709\u8fb9\u6743\u7684\u6811\uff0c\u6839\u636e$dep$\u6765\u786e\u5b9a\u6bcf\u6761\u8fb9\u7684\u957f\u5ea6**\u3002\n\n\u5219\u6c42\u7684\u5c31\u662f\u6240\u6709\u70b9\u5bf9 **\u5728\u4e24\u4e2a\u6570\u4e2d\u7684LCA\u7684\u6df1\u5ea6\u4e4b\u79ef** \u7684\u548c\u3002\u5373\n$$\n\\sum_{1 \\le i < j \\le n}{dep[LCA(i,j)]\\cdot dep'[LCA'(i,j)]}\n$$\n\n\u5230\u8fd9\u91cc\u5c31\u662f\u8fb9\u5206\u7684\u5957\u8def\u4e86\uff0c\u53ef\u4ee5$O(nlogn)$\u6216\u8005$O(nlog^2n)$\u6c42\u89e3\u3002\n\u5177\u4f53\u505a\u6cd5\u662f\uff1a\n\u5148\u5c06\u67d0\u4e00\u4e2aLCA\u5316\u7b80\u6389\uff0c\u8fd9\u91cc\u5316\u7b80\u6389\u7b2c\u4e00\u4e2aLCA\uff0c\u5373\u539f\u5f0f\u7b49\u4ef7\u4e8e\n$$\n\\sum_{1 \\le i < j \\le n}{\\frac{1}{2}\\cdot (dep[i] + dep[j] - dis(i,j)) \\cdot dep'[LCA'(i,j)]}\n$$\n\n\u5148\u5bf9\u7b2c\u4e00\u68f5\u6811\u52a0\u4e00\u4e9b\u70b9\u6539\u9020\uff08\u4e3a\u4e86\u4fdd\u8bc1\u8fb9\u5206\u6cbb\u7684\u6b63\u786e\u590d\u6742\u5ea6\uff09\uff0c\u8fdb\u884c\u8fb9\u5206\u6cbb\u3002\n\u5728\u5206\u6cbb\u5230\u67d0\u6761\u8fb9$<u,v>$\uff0c\u8fb9\u6743\u662fw\u65f6\uff0c\u6211\u4eec\u8981\u6c42\u5728\u7b2c\u4e00\u68f5\u6811\u4e2d\uff0c$dis$\u7ecf\u8fc7\u4e86$<u,v>$\u8fd9\u6761\u8fb9\u7684\u70b9\u5bf9$(i,j)$\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u3002\u8bbe$u$\u8fd9\u4e00\u4fa7\u7684\u70b9\u96c6\u662f$L$\uff0c$v$\u90a3\u4e00\u4fa7\u7684\u70b9\u96c6\u662f$R$\u3002\u5219\u539f\u5f0f\u7ee7\u7eed\u7b49\u4ef7\u4e8e\n$$\n\\frac{1}{2} \\cdot\\sum_{(i\\in L,j\\in R)}{(dep[i] + dep[j] - dis(i,u) - dis(j,v) - w) \\cdot dep'[LCA'(i,j)]}\n$$\n\n\u89c2\u5bdf\u5230$dep$,$dis$\u90fd\u662f\u5b9a\u503c\uff0c\u8bbe$A[i]=\\left\\{\\begin{array}{rcl}dep[i] - dis(i,u) & & {i \\in L}\\\\dep[i] - dis(i,v) & & {i\\in R}\\end{array} \\right.$\u5219\u5316\u7b80\u4e3a\n$$\n\\frac{1}{2} \\cdot \\sum_{i \\in L, j \\in R}{(A[i] + A[j] - w)\\cdot dep'[LCA'(i,j)]}\n$$\n\n\u5230\u8fd9\u91cc\u6210\u529f\u7684\u628a\u7b2c\u4e00\u68f5\u6811\u5f7b\u5e95\u6254\u6389\u4e86\uff0c\u4e8e\u662f\u8fd9\u4e2a\u4e1c\u897f\u5f88\u663e\u7136\u5728\u7b2c\u4e8c\u68f5\u6811\u641e\u4e2a\u865a\u6811\uff0c\u505a\u4e2a01DP\u5c31\u884c\u4e86\u3002\n\u7b2c\u4e8c\u68f5\u6811\u7684LCA\u7528RMQ\u53bb\u6c42,\u6392\u5e8f\u7528\u57fa\u6570\u6392\u5e8f\u5c31\u53ef\u4ee5\u505a\u5230\u6574\u4f53\u590d\u6742\u5ea6$O(nlogn)$\u3002\u5426\u5219\u590d\u6742\u5ea6$O(nlog^2n)$\u3002\n\n\u8fd9\u4ee3\u7801\u600e\u4e48\u8fd9\u4e48\u957f\u3002\u3002\u3002\n\n```cpp\n// Created by calabash_boy on 2019/10/15.\n// Luogu 5115.SAM + \u8fb9\u5206 + \u865a\u6811DP: Given S, calculate\n// \\sum_{i<j and LCP(i,j)<=K1 and LCS(i,j)<=K2}{LCS(i,j) * LCP(i,j)}\n// \u6700\u5927\u5ea6\u6570\u6709\u9650\u5236\uff08\u4f8b\u5982parent\u681127\u5ea6\uff09\uff0c\u5219\u4e0d\u9700\u8981\u4e09\u5ea6\u5316\u3002\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 100;\nchar s[maxn],t[maxn];int n,K1,K2;\nstruct Suffix_Automaton{\n    int nxt[maxn*2][26],fa[maxn*2],l[maxn*2];\n    int last,cnt;\n    Suffix_Automaton(){ clear(); }\n    void clear(){\n        last =cnt=1;fa[1]=l[1]=0;\n        memset(nxt[1],0,sizeof nxt[1]);\n    }\n    void init(char *s){\n        while (*s){add(*s-'a');s++;}\n    }\n    void add(int c){\n        int p = last, np = ++cnt;\n        memset(nxt[cnt],0,sizeof nxt[cnt]);\n        l[np] = l[p]+1;last = np;\n        while (p&&!nxt[p][c])nxt[p][c] = np,p = fa[p];\n        if (!p)fa[np]=1;\n        else{\n            int q = nxt[p][c];\n            if (l[q]==l[p]+1)fa[np] =q;\n            else{\n                int nq = ++ cnt;\n                l[nq] = l[p]+1;\n                memcpy(nxt[nq],nxt[q],sizeof (nxt[q]));\n                fa[nq] =fa[q];fa[np] = fa[q] =nq;\n                while (nxt[p][c]==q)nxt[p][c] =nq,p = fa[p];\n            }\n        }\n    }\n    void extract(vector<int> * E,char *s,int n,int *id,int *dep,int K){\n        int temp = 1;\n        for (int i=0;i<n;i++){\n            temp = nxt[temp][s[i] - 'a'];\n            id[temp] = i + 1;\n        }\n        for (int i=2;i<=cnt;i++)E[fa[i]].push_back(i);\n        for (int i=1;i<=cnt;i++){\n            if (l[i] <= K)dep[i] = l[i];\n            else dep[i] = 0;\n        }\n    }\n}sam1,sam2;\nvector<int> EE1[maxn * 2],E2[maxn*2];\nvector<tuple<int,int,int> > E1[maxn*4];\nint idd1[maxn * 2],id1[maxn*4];\nint depp1[maxn * 2],dep1[maxn*4];\nint id2[maxn* 2],dep2[maxn*2];\nbool can_use[maxn*4];\nint edge_cnt = 0;\nint cnt, st[maxn * 2][20], depth[maxn * 2];\nint pos2[maxn*2],pos1[maxn*4];\nint dfs_clock,l[maxn*2],r[maxn*2];\nvoid dfs2(int u,int fa){\n    l[u] = ++dfs_clock;\n    st[u][0] = fa;\n    depth[u] = depth[fa] + 1;\n    for (int i=1;i<20 && st[u][i-1];i++){\n        st[u][i] = st[st[u][i-1]][i-1];\n    }\n    for (auto v : E2[u]){\n        if (v == fa)continue;\n        dfs2(v,u);\n    }\n    r[u] = dfs_clock;\n}\nint get_lca(int u,int v){\n    if (depth[u] < depth[v])swap(u,v);\n    for (int i=19;i>=0;i--){\n        if (depth[st[u][i]] >= depth[v])u = st[u][i];\n    }\n    if (u == v)return u;\n    for (int i=19;i>=0;i--){\n        if (st[u][i] != st[v][i]){\n            u = st[u][i];v = st[v][i];\n        }\n    }\n    assert(st[u][0] == st[v][0]);\n    return st[u][0];\n}\n//\u4e09\u5ea6\u5316\nint dfs(int u,int fa){\n    int now = ++cnt;\n    id1[now] = idd1[u];dep1[now] = depp1[u];\n    pos1[id1[now]] = now;\n    int pre = now;\n    for (auto v : EE1[u]){\n        if (v == fa)continue;\n        int temp = ++cnt;\n        id1[temp] = 0;dep1[temp] = depp1[u];\n        edge_cnt ++;\n        E1[pre].push_back(make_tuple(temp,dep1[temp] - dep1[pre],edge_cnt));\n        E1[temp].push_back(make_tuple(pre,dep1[temp] - dep1[pre],edge_cnt));\n        int vid = dfs(v,u);\n        edge_cnt ++;\n        E1[temp].push_back(make_tuple(vid,dep1[vid] - dep1[temp],edge_cnt));\n        E1[vid].push_back(make_tuple(temp,dep1[vid] - dep1[temp],edge_cnt));\n        pre = temp;\n    }\n    return now;\n}\nlong long ans = 0;\nint sz[maxn*4];\nint dis[maxn* 4];\nvoid dfs_dis(int u,int fa,int len){\n    dis[u] = len;\n    for (auto e : E1[u]){\n        int v,lll,edge_id;tie(v,lll,edge_id) = e;\n        if (v == fa || !can_use[edge_id])continue;\n        dfs_dis(v,u,len + lll);\n    }\n}\nvoid dfs_sz(int u,int fa){\n    sz[u] = 1;\n    for (auto e : E1[u]){\n        int v,len,edge_id;tie(v,len,edge_id) = e;\n        if (v == fa || !can_use[edge_id])continue;\n        dfs_sz(v,u);\n        sz[u] += sz[v];\n    }\n}\nvoid dfs_edge(int u,int fa,int &e_id,int &uu,int &vv,int &ww,int &max_sz,int tot_node){\n    for (auto e : E1[u]){\n        int v,len,edge_id;tie(v,len,edge_id) = e;\n        if (v == fa || !can_use[edge_id])continue;\n        int max_sz_t = max(sz[v],tot_node - sz[v]);\n        if (max_sz_t < max_sz){\n            max_sz = max_sz_t;\n            uu = u;vv = v;ww = len;e_id = edge_id;\n        }\n        dfs_edge(v,u,e_id,uu,vv,ww,max_sz,tot_node);\n    }\n}\nvoid dfs_node(int u,int fa,vector<int> &nodes){\n    if (id1[u])nodes.push_back(id1[u]);\n    for (auto e : E1[u]){\n        int v,len,edge_id;tie(v,len,edge_id) = e;\n        if (v == fa || !can_use[edge_id])continue;\n        dfs_node(v,u,nodes);\n    }\n}\nint color[maxn * 2];\nint vis[maxn];\nlong long dp[maxn * 2];\nlong long dp_cnt[maxn*2][2];\nlong long dp_sum[maxn*2][2];\nint stk[maxn*2];\nint fa[maxn*2];\ninline void clear(int x,int type){\n    dp[x] = 0;vis[x] = type;\n    for (int c = 0; c < 2;c ++)dp_cnt[x][c] = dp_sum[x][c] = 0;\n}\nvoid DP(vector<int> & nodes_,int ww){\n    vector<int> nodes(0);\n    for (int x : nodes_){\n        nodes.push_back(pos2[x]);\n    }\n    for (int x : nodes)clear(x,1);\n    sort(nodes.begin(),nodes.end(),[](int x,int y){\n        return l[x] < l[y];\n    });\n    int SZ = nodes.size();\n    for (int i=1;i<SZ;i ++){\n        int temp = get_lca(nodes[i-1],nodes[i]);\n        if (!vis[temp]){\n            nodes.push_back(temp);\n            clear(temp,2);\n        }\n    }\n    if (!vis[1]){\n        nodes.push_back(1);\n        clear(1,2);\n    }\n    sort(nodes.begin(),nodes.end(),[](int x,int y){\n        return l[x] < l[y];\n    });\n    int top = 1;\n    stk[0] = nodes[0];\n    for (int i=1;i<nodes.size();i++){\n        while (l[nodes[i]] > r[stk[top-1]]) top --;\n        fa[nodes[i]] = stk[top-1];\n        stk[top++] = nodes[i];\n    }\n    long long anss = 0;\n    for (int i= nodes.size() - 1;i >=0 ;i --){\n        int u = nodes[i], c = vis[u] == 1? color[id2[u]] - 1: -1;\n        if (c != -1){\n            long long A = dep1[pos1[id2[u]]] - dis[pos1[id2[u]]];\n            dp[u] += A * dp_cnt[u][!c] + dp_sum[u][!c];\n            dp[u] -= dp_cnt[u][!c] * ww;\n            dp_cnt[u][c] ++;\n            dp_sum[u][c] += A;\n        }\n        long long temp_ans = dp[u] * dep2[u];\n        assert(temp_ans %2 == 0);\n        anss += temp_ans/2;\n        dp[fa[u]] += dp_cnt[fa[u]][0] * dp_sum[u][1] + dp_cnt[u][0] * dp_sum[fa[u]][1];\n        dp[fa[u]] += dp_cnt[fa[u]][1] * dp_sum[u][0] + dp_cnt[u][1] * dp_sum[fa[u]][0];\n        dp[fa[u]] -= (dp_cnt[fa[u]][1] * dp_cnt[u][0] + dp_cnt[fa[u]][0] * dp_cnt[u][1]) * ww;\n        for (int c = 0;c < 2;c ++){\n            dp_cnt[fa[u]][c] += dp_cnt[u][c];\n            dp_sum[fa[u]][c] += dp_sum[u][c];\n        }\n    }\n    ans += anss;\n    for (int x : nodes)vis[x] = 0;\n}\nvoid calc(int uu,int vv,int ww){\n    vector<int> L(0),R(0),nodes(0);\n    dfs_node(uu,0,L);dfs_node(vv,0,R);\n    for (int x : L){color[x] = 1;nodes.push_back(x);}\n    for (int x : R){color[x] = 2;nodes.push_back(x);}\n    DP(nodes,ww);\n}\nvoid dfs(int root){\n    dfs_sz(root,0);\n    int tot_node = sz[root];\n    if (tot_node == 1)return;\n    int edge_id,uu,vv,ww,max_sz = tot_node + 1;\n    dfs_edge(root,0,edge_id,uu,vv,ww,max_sz,tot_node);\n    can_use[edge_id] = false;\n    dfs_dis(uu,0,0);dfs_dis(vv,0,0);\n    calc(uu,vv,ww);dfs(uu);dfs(vv);\n}\nint main(){\n    scanf(\"%s%d%d\",s,&K1,&K2);\n    n = strlen(s);\n    memcpy(t,s,sizeof s);reverse(t,t + n);\n    sam1.init(s);sam2.init(t);\n    sam1.extract(EE1,s,n,idd1,depp1,K2);\n    sam2.extract(E2,t,n,id2,dep2,K1);\n    for (int i=1;i<= sam2.cnt; i ++){\n        if (id2[i]){\n            id2[i] = n + 1 - id2[i];\n            pos2[id2[i]] = i;\n        }\n    }\n    int root1 = dfs(1,0);int root2 = 1;\n    dfs2(root2,0);\n    memset(can_use,true,sizeof can_use);\n    dfs(root1);\n    cout<<ans<<endl;\n    return 0;\n}\n```\n",
        "postTime": 1571140199,
        "uid": 2266,
        "name": "\u51ef\u7279\u7433",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5115 \u3010Check,Check,Check one two!\u3011:SAM + \u8fb9\u5206\u6cbb + \u865a\u6811DP"
    },
    {
        "content": "\u6765\u4e2a\u5b57\u7b26\u4e32\u91cd\u5de5\u4e1a\u505a\u6cd5\u3002\n\n\u9996\u5148\u5bf9\u6b63\u4e32\u53cd\u4e32\u5206\u522b\u5efa SAM\uff0c\u7136\u540e\u4e24\u4e2a\u4e0b\u6807\u7684 LCP \u548c LCS \u957f\u5ea6\u5c31\u5bf9\u5e94\u7740\u5b83\u4eec\u5728\u4e24\u68f5\u6811\u4e0a\u5bf9\u5e94\u7ed3\u70b9\u7684 LCA \u4ee3\u8868\u7684\u4e32\u957f\u3002\n\n\u9996\u5148\u601d\u8003\u7b2c\u4e8c\u68f5\u6811\u3002\u5bf9\u4e8e\u8fd9\u79cd\u8d21\u732e\u4e3a $len_{LCA}[len_{LCA}\\le k_1]$ \u7684\u8ba1\u7b97\uff0c\u4e00\u79cd\u5e38\u89c1\u65b9\u5f0f\u5c31\u662f\u62c6\u5206\u4e24\u4e2a\u70b9\u7684\u4f5c\u7528\uff0c\u53d8\u6210\u94fe\u52a0\u548c\u94fe\u67e5\u3002\n\n\u6211\u4eec\u8bbe $val_i=len_i[len_i\\le k_1]-len_{fa_i}[len_{fa_i}\\le k_1]$\uff0c\u8fd9\u4e2a\u8d21\u732e\u7c7b\u4f3c\u4e8e\u5dee\u5206\uff0c\u4e24\u4e2a\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u94fe\u7684\u91cd\u5408\u90e8\u5206\u6743\u503c\u4e4b\u548c\u5c31\u662f\u7b54\u6848\u3002\n\n\u8fd9\u4e2a\u94fe\u52a0\u548c\u94fe\u67e5\u8ddf\u5e73\u5e38\u7684\u7ef4\u62a4\u4e0d\u592a\u4e00\u6837\uff0c\u4e00\u6b21\u52a0\u6cd5\u64cd\u4f5c\u76f8\u5f53\u4e8e\u8fd9\u4e2a\u7ed3\u70b9\u52a0\u4e0a\u5b83\u5bf9\u5e94\u7684\u6743\u503c\uff0c\u7528\u6811\u5256 + \u7ebf\u6bb5\u6811\u53ef\u4ee5\u65b9\u4fbf\u7ef4\u62a4\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651\u7b2c\u4e00\u68f5\u6811\u3002\u679a\u4e3e LCA\uff0c\u90a3\u4e48\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u5c31\u5728\u4e24\u68f5\u4e0d\u540c\u7684\u5b50\u6811\u5185\u3002\u8003\u8651\u7528 dsu on tree \u4f18\u5316\u5b83\uff0c\u5148\u5c06\u91cd\u513f\u5b50\u7684\u5b50\u6811\u63d0\u524d\u505a\u597d\u94fe\u52a0\uff0c\u5269\u4e0b\u7684\u5b50\u6811\u5c31\u53ef\u4ee5\u66b4\u529b\u505a\u94fe\u52a0\u94fe\u67e5\u64cd\u4f5c\u4e86\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^3 n)$\uff0c\u8fc7\u4e0d\u53bb\u3002\u8003\u8651\u4f18\u5316\uff0c\u53d1\u73b0\u6811\u5256 + \u7ebf\u6bb5\u6811\u8fd9\u4e2a\u64cd\u4f5c\u5c31\u6709\u4e24\u4e2a $\\log$\uff0c\u9700\u8981\u4e00\u4e2a\u66f4\u52a0\u4f18\u79c0\u7684\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4\u3002\n\n\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u5c31\u662f **\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811**\u3002\n\n\u5bf9\u4e8e\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u7684\u6bcf\u4e2a\u7ed3\u70b9\u7ef4\u62a4\u4e94\u4e2a\u503c $(a,s_a,b,s_b,tag)$\u3002$a,s_a$ \u76f8\u5f53\u4e8e\u7ed3\u70b9\u7684 $val$ \u548c\u5b50\u6811\u7684 $val$ \u4e4b\u548c\u3002$b,s_b$ \u76f8\u5f53\u4e8e\u8fd9\u4e2a\u7ed3\u70b9\u7684\u8d21\u732e\u548c\u6574\u4e2a\u5b50\u6811\u7684\u8d21\u732e\u4e4b\u548c\u3002$tag$ \u5219\u9700\u8981\u8bb0\u5f55\u8fd9\u4e2a\u7ed3\u70b9\u9700\u8981\u7684\u52a0\u6cd5\u64cd\u4f5c\u6b21\u6570\u3002\n\n\u6bcf\u6b21\u4fee\u6539\u65f6\uff0c\u5982\u679c\u4e0a\u4e00\u4e2a\u70b9\u4e3a\u5f53\u524d\u70b9\u7684\u53f3\u513f\u5b50 / \u8f7b\u513f\u5b50\uff0c\u6216\u8005\u6ca1\u6709\u4e0a\u4e00\u4e2a\u70b9\uff0c\u5c31\u4fee\u6539\u5f53\u524d\u70b9\u548c\u5b83\u7684\u53f3\u5b50\u6811\u3002\u67e5\u8be2\u65f6\u5148\u5c06\u7956\u5148\u94fe\u7684\u6240\u6709\u6807\u8bb0\u4e0b\u4f20\u518d\u8fdb\u884c\u6c42\u548c\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define For(i,a,b) for(int i=(a);i<=(b);++i)\n#define Rof(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int Maxn=2e5+5;\n\nint n,m,rt,k1,k2; ull ans; char str[Maxn+5];\n\nstruct SegTree\n{\n    ull t[Maxn+5],val[Maxn+5],sum[Maxn+5],num[Maxn+5]; int tag[Maxn+5];\n    int anc[Maxn+5],ch[Maxn+5][2],st[Maxn+5],top;\n    #define ls(x) ch[x][0]\n    #define rs(x) ch[x][1]\n    inline void push_up(int p) {t[p]=t[ls(p)]+val[p]+t[rs(p)];}\n    inline void f(int p,int k) {if(p) val[p]+=k*num[p],t[p]+=k*sum[p],tag[p]+=k;}\n    inline void push_down(int p) {if(ls(p)) f(ls(p),tag[p]); if(rs(p)) f(rs(p),tag[p]); tag[p]=0;}\n    inline int isRoot(int x) {return (x!=ls(anc[x]) && x!=rs(anc[x]));}\n    inline void Update(int x,int k)\n    {\n        top=0; for(int i=x;i;i=anc[i]) st[++top]=i;\n        Rof(i,top,1) push_down(st[i]);\n        for(int i=x,p=0;i;p=i,i=anc[i])\n        {\n            if(isRoot(p)) p=0;\n            if(!p || p==rs(i))\n            {\n                val[i]+=k*num[i],t[i]+=k*num[i];\n                if(ls(i)) f(ls(i),k);\n            }\n            push_up(i);\n        }\n    }\n    inline ull Count(int x)\n    {\n        ull res=0;\n        top=0; for(int i=x;i;i=anc[i]) st[++top]=i;\n        Rof(i,top,1) push_down(st[i]);\n        for(int i=x,p=0;i;p=i,i=anc[i])\n        {\n            if(isRoot(p)) p=0;\n            if(!p || p==rs(i)) res+=val[i]+t[ls(i)];\n        }\n        return res;\n    }\n} T;\n\ninline void Update(int x,int op);\ninline ull Query(int x);\n\nstruct SAM\n{\n    int lst,tot,k,fa[Maxn+5],pos[Maxn+5],idx[Maxn+5]; ull val[Maxn+5];\n    int len[Maxn+5],dep[Maxn+5],t[Maxn+5][26],chk[Maxn+5];\n    int siz[Maxn+5],son[Maxn+5],top[Maxn+5],st[Maxn+5],cur;\n    vector<int> v[Maxn+5];\n    inline SAM() {lst=tot=1;}\n    inline void Insert(int x,int id)\n    {\n        int p=lst,k=++tot;\n        len[k]=len[p]+1,pos[id]=k,idx[k]=id,lst=k;\n        while(p && !t[p][x]) t[p][x]=k,p=fa[p];\n        if(!p) fa[k]=1;\n        else\n        {\n            int q=t[p][x];\n            if(len[q]==len[p]+1) fa[k]=q;\n            else\n            {\n                fa[++tot]=fa[q],memcpy(t[tot],t[q],sizeof(t[q]));\n                len[tot]=len[p]+1,fa[k]=fa[q]=tot;\n                while(p && t[p][x]==q) t[p][x]=tot,p=fa[p];\n            }\n        }\n    }\n    inline void dfs(int x)\n    {\n        chk[x]=(len[x]<=k),dep[x]=dep[fa[x]]+1,siz[x]=1;\n        if(chk[x]) val[x]=len[x]-len[fa[x]];\n        else if(chk[fa[x]]) val[x]=0ull-len[fa[x]];\n        for(auto y:v[x])\n        {\n            dfs(y),siz[x]+=siz[y];\n            son[x]=(siz[y]>siz[son[x]]?y:son[x]);\n        }\n    }\n    inline void Count(int x,ull val)\n    {\n        if(!val) return;\n        if(idx[x]) ans+=val*Query(idx[x]);\n        for(auto y:v[x]) Count(y,val);\n    }\n    inline void Add(int x,int op)\n    {\n        if(idx[x]) Update(idx[x],op);\n        for(auto y:v[x]) Add(y,op);\n    }\n    inline void dfs1(int x,int op)\n    {\n        for(auto y:v[x]) if(y!=son[x]) dfs1(y,0);\n        if(son[x]) dfs1(son[x],1);\n        for(auto y:v[x]) if(y!=son[x]) Count(y,len[x]*chk[x]),Add(y,1);\n        if(idx[x])\n        {\n            if(chk[x]) ans+=1ull*Query(idx[x])*len[x];\n            Update(idx[x],1);\n        }\n        if(!op) Add(x,-1);\n    }\n    inline void dfs2(int x,int t)\n    {\n        top[x]=t;\n        if(son[x]) dfs2(son[x],t);\n        for(auto y:v[x]) if(y!=son[x]) dfs2(y,y);\n    }\n    inline int BuildChain(int l,int r)\n    {\n        if(l>r) return 0;\n        int sum=0,now=0;\n        For(i,l,r) sum+=(siz[st[i]]-siz[son[st[i]]]);\n        For(i,l,r)\n        {\n            now+=(siz[st[i]]-siz[son[st[i]]]);\n            if(now*2>=sum)\n            {\n                int x=st[i]; T.num[x]=val[x];\n                T.ch[x][0]=BuildChain(l,i-1),T.ch[x][1]=BuildChain(i+1,r);\n                T.anc[T.ch[x][0]]=T.anc[T.ch[x][1]]=x;\n                T.sum[x]=val[x]+T.sum[T.ch[x][0]]+T.sum[T.ch[x][1]];\n                T.push_up(x); return x;\n            }\n        }\n        return 0;\n    }\n    inline int BuildTree(int x)\n    {\n        for(int i=x;i;i=son[i]) for(auto y:v[i])\n            if(y!=fa[i] && y!=son[i]) T.anc[BuildTree(y)]=i;\n        cur=0; for(int i=x;i;i=son[i]) st[++cur]=i,top[i]=x;\n        return BuildChain(1,cur);\n    }\n    inline void Build()\n    {\n        For(i,2,tot) v[fa[i]].push_back(i);\n        dfs(1),dfs2(1,1);\n    }\n} S1,S2;\n\ninline void Update(int x,int op) {x=S2.pos[x]; T.Update(x,op);}\ninline ull Query(int x) {x=S2.pos[x]; return T.Count(x);}\n\nint main()\n{\n    scanf(\"%s%d%d\",str+1,&k2,&k1),n=strlen(str+1);\n    For(i,1,n) S1.Insert(str[i]-'a',i),S2.Insert(str[n-i+1]-'a',n-i+1);\n    S1.k=k1,S2.k=k2,S1.Build(),S2.Build();\n    rt=S2.BuildTree(1),S1.dfs1(1,0);\n    printf(\"%llu\\n\",ans);\n    return 0;\n}\n```",
        "postTime": 1677294768,
        "uid": 148913,
        "name": "Graphcity",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P5115\u3010Check,Check,Check one two!\u3011"
    }
]