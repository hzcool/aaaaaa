[
    {
        "content": "## \u95ee\u9898\u89e3\u6790\n\n### \u505a\u9898\u601d\u8def\u9884\u5907\n\n\u9996\u5148\uff0c\u8981\u6709\u4e00\u70b9splay\u7ef4\u62a4\u533a\u95f4\u64cd\u4f5c\u7684\u57fa\u7840\u3002\n\nsplay\u7ef4\u62a4\u533a\u95f4\u7684\u57fa\u672c\u539f\u7406\uff0c\u5c31\u662f\u5c06\u533a\u95f4[l,r]\u7684\u7aef\u70b9l-1,\u548cr+1\u4e0d\u65ad\u7684\u901a\u8fc7\u4f38\u5c55\u64cd\u4f5c\u5373splay\u5230\u6839\uff0c\u5c06l-1\u4f38\u5c55\u5230\u6839\uff0c\u5c06r+1\u4f38\u5c55\u5230\u6839\u7684\u53f3\u513f\u5b50\uff0c\u90a3\u4e48[l,r]\u8fd9\u6bb5\u533a\u95f4\u5c31\u5728\u6839\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u4e0a\u4e86\u3002\n\n\u7279\u522b\u8981\u6ce8\u610f\u7684\u662f\uff0c==**\u8fd9\u91cc\u7684l,r\u4e0d\u662f\u7ed9\u51fa\u7684\u533a\u95f4\u7aef\u70b9\u7684\u7f16\u53f7\uff0c\u800c\u662f\u6211\u4eec\u5728\u5e73\u8861\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e2d\u533a\u95f4\u7aef\u70b9\u7684\u7f16\u53f7\u3002\u5373\u5728\u5e73\u8861\u6811\u4e2d\u6392\u540d(rank)\u4e3al,r\u7684\u4e24\u4e2a\u8282\u70b9\u7684\u771f\u5b9e\u7f16\u53f7\uff0c\u800c\u5bf9\u4e8el=1\u6216r=n\u7684\u60c5\u51b5\u5c31\u975e\u5e38\u7279\u6b8a\u4e86\uff0c\u6211\u4eec\u6709\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\uff0c\u4e00\u79cd\u5c31\u662f\u5206\u7c7b\u8ba8\u8bba\uff0c\u5c06\u8fd94\u79cd\u60c5\u51b5\u679a\u4e3e\uff0c\u7136\u540e\u8fdb\u884c\u64cd\u4f5c\uff0c\u8fd9\u4e48\u505a\u56fa\u7136\u53ef\u884c\uff0c\u4f46\u662f\u5f53\u64cd\u4f5c\u53d8\u591a\u65f6\uff0c\u4f1a\u4f7f\u6574\u4e2a\u7a0b\u5e8f\u663e\u5f97\u7e41\u7410\uff0c\u5e76\u4e14\u96be\u4e8e\u8c03\u8bd5\u3002\u53e6\u4e00\u79cd\u89e3\u51b3\u65b9\u6848\u5c31\u662f\u5efa\u7acb\u865a\u62df\u8282\u70b9\uff0c\u6211\u4eec\u628a\u9700\u8981\u7ef4\u62a4\u7684\u533a\u95f4\u5168\u90e8\u53d8\u6210[l+1,r+1]\uff0c\u90a3\u4e48\u6211\u4eec\u865a\u62df\u51fa\u4e00\u4e2a1\u53f7\u8282\u70b9\u548c\u4e00\u4e2an+2\u53f7\u8282\u70b9\uff0c\u90a3\u4e48\u6574\u4e2a\u64cd\u4f5c\u5c31\u663e\u5f97\u5341\u5206\u81ea\u7136\u4e86**==\u3002\n\n\u90a3\u4e48\u95ee\u9898\u5c31\u660e\u663e\u662f\u4e00\u4e2asplay\u7684\u57fa\u672c\u6a21\u677f\u9898\u4e86\u3002\u800c\u7ef4\u62a4\u533a\u95f4\u7ffb\u8f6c\uff0c\u5728\u6d1b\u8c37\u7684P3391\u6587\u827a\u5e73\u8861\u6811\u4e2d\u6709\u66f4\u88f8\u7684\u9898\u76ee\u3002\n\n\u8fd9\u91cc\uff0c\u4e00\u4e2a\u64cd\u4f5c\u4e00\u4e2a\u64cd\u4f5c\u7684\u89e3\u51b3\u3002\n\n### \u521d\u59cb\u5316\n\n\u9996\u5148\uff0c\u5bf9\u4e8e\u539f\u5e8f\u5217\uff0c\u6211\u4eec\u4e0d\u5e94\u8be5\u4e00\u4e2a\u4e00\u4e2a\u8bfb\u5165\uff0c\u7136\u540e\u63d2\u5165\uff0c\u90a3\u4e48\u6548\u7387\u5c31\u662fO(nlogn),\u800csplay\u7684\u5e38\u6570\u672c\u8eab\u5c31\u5f88\u5927\uff0c\u6240\u4ee5\u8003\u8651\u4e00\u4e2a\u4f18\u5316\uff0c\u5c31\u662f\u628a\u539f\u5e8f\u5217\u4e00\u6b21\u6027\u8bfb\u5165\u540e\uff0c\u76f4\u63a5\u7c7b\u4f3c\u7ebf\u6bb5\u6811\u7684build\uff0c\u641e\u4e00\u4e2a\u6574\u4f53\u5efa\u6811\uff0c\u5373\u4e0d\u65ad\u7684\u5c06\u5f53\u524d\u70b9\u7ef4\u62a4\u7684\u533a\u95f4\u8fdb\u884c\u4e8c\u5206\uff0c\u5230\u8fbe\u5355\u5143\u7d20\u533a\u95f4\u540e\uff0c\u5c31\u628a\u5bf9\u5e94\u7684\u5e8f\u5217\u503c\u63d2\u5165\u8fdb\u53bb\uff0c\u8fd9\u6837\uff0c\u6211\u4eec\u4e00\u5f00\u59cb\u5efa\u7684\u6811\u5c31\u662f\u4e00\u4e2a\u975e\u5e38\u5e73\u8861\u7684\u6811\uff0c\u53ef\u4ee5\u4f7f\u540e\u7eed\u64cd\u4f5c\u7684\u5e38\u6570\u66f4\u5c0f\uff0c\u5e76\u4e14\u5efa\u6811\u6574\u4e2a\u590d\u6742\u5ea6\u53ea\u662fO(2n)\u7684\u3002\n\n### Insert\u64cd\u4f5c\n\n\u5176\u6b21\uff0c\u6211\u4eec\u6765\u8003\u8651\u4e00\u4e0b\u5982\u4f55\u7ef4\u62a4\u4e00\u4e2ainsert\u64cd\u4f5c\u3002\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u505a\uff0c\u9996\u5148\u5982\u4e0a\u5c06\u9700\u8981insert\u7684\u533a\u95f4\u53d8\u6210\u8282\u70b9\u6570\u76ee\u4e3atot\u7684\u5e73\u8861\u6811,\u7136\u540e\u628ak+1\uff08\u6ce8\u610f\u6211\u4eec\u5c06\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\u53f3\u79fb\u4e86\u4e00\u4e2a\u5355\u4f4d\uff0c\u6240\u4ee5\u9898\u76ee\u6240\u7ed9k\u5c31\u662f\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684k+1\uff09\u79fb\u5230\u6839\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c\u628a\u539f\u6811\u4e2d\u7684k+2\u79fb\u5230\u6839\u8282\u70b9\u7684\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\u3002\u7136\u540e\u628a\u9700\u8981insert\u7684\u533a\u95f4\uff0c\u5148build\u6210\u4e00\u4e2a\u5e73\u8861\u6811\uff0c\u628a\u9700\u8981insert\u7684\u6811\u7684\u6839\u76f4\u63a5\u6302\u5230\u539f\u6811\u4e2dk+1\u7684\u5de6\u513f\u5b50\u4e0a\u5c31\u884c\u4e86\u3002\n\n### Delete\u64cd\u4f5c\n\n\u518d\u7136\u540e\uff0c\u6211\u4eec\u6765\u8003\u8651\u4e00\u4e0bdelete\u64cd\u4f5c\uff0c\u6211\u4eec\u540c\u6837\u7684\uff0c\u628a\u9700\u8981delete\u7684\u533a\u95f4\u53d8\u6210[k+1,k+tot]\uff08\u6ce8\u610f\uff0c\u662f\u5220\u53bbk\u540e\u9762\u7684tot\u4e2a\u6570\uff0c\u90a3\u4e48\u53ef\u4ee5\u53d1\u73b0\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684\u539f\u533a\u95f4\u662f[k,k+tot-1]!\uff09\uff0c\u7136\u540e\u628ak\u53f7\u8282\u70b9\u79fb\u5230\u6839\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c\u628ak+tot+2\u79fb\u5230\u6839\u8282\u70b9\u7684\u53f3\u513f\u5b50\u4f4d\u7f6e\uff0c\u7136\u540e\u76f4\u63a5\u628ak+tot+2\u7684\u5de6\u513f\u5b50\u7684\u6307\u9488\u6e05\u4e3a0\uff0c\u5c31\u628a\u8fd9\u6bb5\u533a\u95f4\u5220\u6389\u4e86\u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u6bd4insert\u8fd8\u7b80\u5355\u4e00\u70b9\u3002\n\n### Reverse\u64cd\u4f5c\n\n\u63a5\u4e0b\u6765\uff0c\u8fd9\u9053\u9898\u7684\u91cd\u5934\u620f\u5c31\u8981\u5f00\u59cb\u4e86\u3002splay\u7684\u533a\u95f4\u64cd\u4f5c\u57fa\u672c\u539f\u7406\u8fd8\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u64cd\u4f5c\uff0c\u5373\u5ef6\u8fdf\u4fee\u6539\uff0c\u53c8\u79f0\u6253\u61d2\u6807\u8bb0\u3002\n\n\u5bf9\u4e8e\u7ffb\u8f6c\uff08reverse\uff09\u64cd\u4f5c\uff0c\u6211\u4eec\u4f9d\u65e7\u662f\u5c06\u64cd\u4f5c\u533a\u95f4\u53d8\u6210[k+1,k+tot]\uff0c\u7136\u540e\u628ak\u548ck+tot+1\u5206\u522b\u79fb\u5230\u5bf9\u5e94\u6839\u7684\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u5bf9\u8fd9\u4e2a\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u6253\u4e0a\u7ffb\u8f6c\u6807\u8bb0\u5373\u53ef\u3002\n\n### Make-Same\u64cd\u4f5c\n\n\u5bf9\u4e8eMake-Same\u64cd\u4f5c\uff0c\u6211\u4eec\u540c\u6837\u9700\u8981\u5148\u5c06\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\u53d8\u6210[k+1,k+tot]\uff0c\u7136\u540e\u628ak\u548ck+tot+1\u5206\u522b\u79fb\u5230\u6839\u548c\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u5bf9\u8fd9\u4e2a\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u6253\u4e0a\u4fee\u6539\u6807\u8bb0\u5373\u53ef\u3002\n\n### Get-Sum\u64cd\u4f5c\n\n\u5bf9\u4e8eGet-Sum\u64cd\u4f5c\uff0c\u6211\u4eec\u8fd8\u662f\u5c06\u64cd\u4f5c\u533a\u95f4\u53d8\u6210[k+1,k+tot],\u7136\u540e\u628ak\u548ck+tot+1\u5206\u522b\u79fb\u5230\u6839\u548c\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u76f4\u63a5\u8f93\u51fa\u8fd9\u4e2a\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u4e0a\u7684sum\u8bb0\u5f55\u7684\u548c\u3002\n\n### Max-Sum\u64cd\u4f5c\n\n\u5bf9\u4e8e\u8fd9\u4e2a\u6c42\u6700\u5927\u5b50\u5e8f\u5217\u7684\u64cd\u4f5c\uff0c\u5373Max-Sum\u64cd\u4f5c\uff0c\u6211\u4eec\u4e0d\u80fd\u5c40\u9650\u4e8e\u6700\u5f00\u59cb\u5b66\u6700\u5927\u5b50\u5e8f\u5217\u7684\u7ebf\u6027dp\u65b9\u6cd5\uff0c\u800c\u662f\u8981\u6ce8\u610f\u521a\u5f00\u59cb\uff0c\u57fa\u672c\u5f88\u591a\u4e66\u90fd\u4f1a\u4ecb\u7ecd\u4e00\u4e2a\u5206\u6cbb\u7684O(nlogn)\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u7531\u4e8e\u5b58\u5728O(n)\u7684\u65b9\u6cd5\uff0c\u5bfc\u81f4\u8fd9\u4e2a\u65b9\u6cd5\u5e76\u4e0d\u53d7\u91cd\u89c6\uff0c\u4f46\u662f\u8fd9\u4e2a\u65b9\u6cd5\u786e\u5b9e\u5f88\u5de7\u5999\uff0c\u5f53\u6570\u5217\u5b58\u5728\u4fee\u6539\u64cd\u4f5c\u65f6\uff0c\u7ebf\u6027\u7684\u7b97\u6cd5\u5c31\u4e0d\u518d\u9002\u7528\u4e86\u3002\n\n\u8fd9\u79cd\u5e26\u4fee\u6539\u7684\u6700\u5927\u5b50\u5e8f\u5217\u7684\u95ee\u9898\uff0c\u6700\u5f00\u59cb\u662f\u7531\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\uff0c\u5177\u4f53\u6765\u8bf4\u5c31\u662f\uff0c\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u4e0a\u7684\u6bcf\u4e2a\u8282\u70b9\u6240\u4ee3\u8868\u7684\u533a\u95f4\uff0c\u7ef4\u62a43\u4e2a\u91cf\uff1alx\u8868\u793a\u4ece\u533a\u95f4\u5de6\u7aef\u70b9l\u5f00\u59cb\u7684\u8fde\u7eed\u7684\u524d\u7f00\u6700\u5927\u5b50\u5e8f\u5217\u3002rx\u8868\u793a\u4ece\u533a\u95f4\u53f3\u7aef\u70b9r\u5f00\u59cb\u7684\u8fde\u7eed\u7684\u540e\u7f00\u6700\u5927\u5b50\u5e8f\u5217\u3002mx\u8868\u793a\u8fd9\u4e2a\u533a\u95f4\u4e2d\u7684\u6700\u5927\u5b50\u5e8f\u5217\u3002\n\n\u90a3\u4e48\u5728\u5408\u5e76[l,mid]\u548c[mid+1,r]\u65f6\uff0c\u5c31\u7c7b\u4f3c\u4e00\u4e2adp\u7684\u8fc7\u7a0b\u4e86\uff01\u5176\u4e2d\n\n$lx[l,r]=max(lx[l,mid],sum[l,mid]+lx[mid+1,r])$\n\n$rx[l,r]=max(rx[mid+1,r],sum[mid+1,r]+rx[l,mid])$\n\n$mx[l,r]=max(mx[l,mid],mx[mid+1,r],lx[mid+1,r]+rx[l,mid+1])$\n\n\u8fd9\u4e2a\u8fd8\u662f\u5f88\u597d\u7406\u89e3\u7684\u3002\u5c31\u662f\u9009\u4e0d\u9009mid\u7684\u4e24\u4e2a\u51b3\u7b56\u3002\u4f46\u662f\u5176\u5b9e\u5728\u5b9e\u73b0\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e76\u4e0d\u7528[l,r]\u7684\u4e8c\u7ef4\u65b9\u5f0f\u6765\u8bb0\u5f55\u8fd9\u4e09\u4e2a\u6807\u8bb0\uff0c\u800c\u662f\u7528\u5bf9\u5e94\u7684\u8282\u70b9\u7f16\u53f7\u6765\u8868\u793a\u533a\u95f4\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u770b\u7a0b\u5e8f\uff0c\u5176\u5b9e\u662f\u4e2a\u5f88\u7b80\u5355\u7684\u4e1c\u897f\u3002\n\n\u90a3\u4e48\u6700\u5927\u5b50\u5e8f\u5217\u8fd9\u4e2a\u8be2\u95ee\u64cd\u4f5c\u5c31\u53ef\u4ee5\u5f88\u7b80\u5355\u7684\u89e3\u51b3\u4e86\uff0c\u8fd8\u662f\u7c7b\u6bd4\u524d\u9762\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u628ak\u548ck+tot+1\u79fb\u5230\u5bf9\u5e94\u7684\u6839\u548c\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u76f4\u63a5\u8f93\u51fa\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u4e0a\u7684mx\u6807\u8bb0\u5373\u53ef\n\n### \u61d2\u6807\u8bb0\u7684\u5904\u7406\n\n\u6700\u540e\uff0c\u76f8\u4fe1\u8ba4\u771f\u770b\u4e86\u7684\u7ae5\u978b\u4f1a\u6709\u7591\u95ee\uff0c\u8fd9\u4e2a\u6807\u8bb0\u600e\u4e48\u4e0b\u4f20\u5462\uff1f\u9996\u5148\uff0c\u6211\u4eec\u5728\u6bcf\u6b21\u5c06k\u548ck+tot+1\u79fb\u5230\u5bf9\u5e94\u7684\u4f4d\u7f6e\u65f6\uff0c\u9700\u8981\u4e00\u4e2a\u7c7b\u4f3c\u67e5\u627ek\u5927\u503c\u7684find\u64cd\u4f5c\uff0c\u5373\u627e\u51fa\u5728\u5e73\u8861\u6811\u4e2d\uff0c\u5b9e\u9645\u7f16\u53f7\u4e3ak\u5728\u6811\u4e2d\u4e2d\u5e8f\u904d\u5386\u7684\u7f16\u53f7\uff0c\u8fd9\u4e2a\u624d\u662f\u6211\u4eec\u771f\u6b63\u9700\u8981\u5904\u7406\u7684\u533a\u95f4\u7aef\u70b9\u7f16\u53f7\uff0c\u90a3\u4e48\u5c31\u597d\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u5728\u67e5\u627e\u7684\u8fc7\u7a0b\u4e2d\u4e0b\u4f20\u6807\u8bb0\u5c31\u597d\u4e86\uff01\uff08\u5176\u5b9e\u7ebf\u6bb5\u6811\u4e2d\u4e5f\u662f\u8fd9\u4e48\u505a\u7684\uff09\uff0c\u56e0\u4e3a\u6211\u4eec\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u9700\u8981\u5148find\u4e00\u4e0b\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4fdd\u8bc1\u624d\u6bcf\u6b21\u64cd\u4f5c\u7684\u7ed3\u679c\u8ba1\u7b97\u51fa\u6765\u65f6\uff0c\u5bf9\u5e94\u7684\u8282\u70b9\u7684\u6807\u8bb0\u90fd\u5df2\u7ecf\u4f20\u597d\u4e86\u3002\u800c\u6211\u4eec\u5728\u4fee\u6539\u65f6\uff0c\u76f4\u63a5\u4fee\u6539\u5bf9\u5e94\u8282\u70b9\u7684\u8bb0\u5f55\u6807\u8bb0\u548c\u61d2\u6807\u8bb0\uff0c\u56e0\u4e3a\u6211\u4eec\u7684\u61d2\u6807\u8bb0\u8bb0\u5f55\u7684\u90fd\u662f\u5df2\u7ecf\u5bf9\u5f53\u524d\u8282\u70b9\u4ea7\u751f\u8d21\u732e\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5f53\u524d\u8282\u70b9\u7684\u5b50\u6811\u533a\u95f4\u4ea7\u751f\u8d21\u732e\uff01\u7136\u540e\u5c31\u662f\u6bcf\u5904\u6709\u4fee\u6539\u7684\u5730\u65b9\u90fd\u8981pushup\u4e00\u4e0b\u5c31\u597d\u4e86\u3002\n\n### \u4e00\u4e9b\u7ec6\u8282\n\n\u53e6\u5916\uff0c\u7531\u4e8e\u672c\u9898\u6570\u636e\u7a7a\u95f4\u5361\u7684\u975e\u5e38\u7d27\uff0c\u6211\u4eec\u5c31\u9700\u8981\u7528\u65f6\u95f4\u6362\u7a7a\u95f4\uff0c\u76f4\u63a5\u5f004000000\\*logm\u7684\u6570\u636e\u662f\u4e0d\u73b0\u5b9e\u7684\uff0c\u4f46\u662f\u7531\u4e8e\u9898\u76ee\u4fdd\u8bc1\u4e86\u540c\u4e00\u65f6\u95f4\u5728\u5e8f\u5217\u4e2d\u7684\u6570\u5b57\u7684\u4e2a\u6570\u6700\u591a\u662f500000\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u56de\u6536\u673a\u5236\uff0c\u628a\u7528\u8fc7\u4f46\u662f\u5df2\u7ecf\u5220\u6389\u7684\u8282\u70b9\u7f16\u53f7\u8bb0\u5f55\u5230\u4e00\u4e2a\u961f\u5217\u6216\u6808\u4e2d\uff0c\u5728\u65b0\u5efa\u8282\u70b9\u65f6\u76f4\u63a5\u628a\u961f\u5217\u4e2d\u7684\u5197\u4f59\u7f16\u53f7\u641e\u8fc7\u6765\u5c31\u597d\u4e86\u3002\n\n### \u540e\u8a00\n\n**\u5b9e\u73b0\u65f6\u8fd8\u6709\u8bf8\u591a\u7ec6\u8282\uff0c\u52a1\u5fc5\u8981\u7ec6\u770b\u4ee3\u7801\uff0c\u52a0\u6df1\u4e86\u89e3\u3002**\n\n\n## \u53c2\u8003\u4ee3\u7801\uff1a\n\n\n``` cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define rint register int\n#define For(i,a,b) for (rint i=a;i<=b;++i)\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int N=1e6+17;\nint n,m,rt,cnt;\nint a[N],id[N],fa[N],c[N][2];\nint sum[N],sz[N],v[N],mx[N],lx[N],rx[N];\nbool tag[N],rev[N];\n//tag\u8868\u793a\u662f\u5426\u6709\u7edf\u4e00\u4fee\u6539\u7684\u6807\u8bb0\uff0crev\u8868\u793a\u662f\u5426\u6709\u7edf\u4e00\u7ffb\u8f6c\u7684\u6807\u8bb0\n//sum\u8868\u793a\u8fd9\u4e2a\u70b9\u7684\u5b50\u6811\u4e2d\u7684\u6743\u503c\u548c\uff0cv\u8868\u793a\u8fd9\u4e2a\u70b9\u7684\u6743\u503c\nqueue<int> q;\ninline int read(){\n    rint x=0,f=1;char ch=getchar();\n    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n    while ('0'<=ch && ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return x*f;\n}\ninline void pushup(rint x){\n    rint l=c[x][0],r=c[x][1];\n    sum[x]=sum[l]+sum[r]+v[x];\n    sz[x]=sz[l]+sz[r]+1;\n    mx[x]=max(mx[l],max(mx[r],rx[l]+v[x]+lx[r]));\n    lx[x]=max(lx[l],sum[l]+v[x]+lx[r]);\n    rx[x]=max(rx[r],sum[r]+v[x]+rx[l]);\n}\n//\u4e0a\u4f20\u8bb0\u5f55\u6807\u8bb0\ninline void pushdown(rint x){\n    rint l=c[x][0],r=c[x][1];\n    if (tag[x]){\n        rev[x]=tag[x]=0;//\u6211\u4eec\u6709\u4e86\u4e00\u4e2a\u7edf\u4e00\u4fee\u6539\u7684\u6807\u8bb0\uff0c\u518d\u7ffb\u8f6c\u5c31\u6ca1\u6709\u4ec0\u4e48\u610f\u4e49\u4e86\n        if (l)tag[l]=1,v[l]=v[x],sum[l]=v[x]*sz[l];\n        if (r)tag[r]=1,v[r]=v[x],sum[r]=v[x]*sz[r];\n        if (v[x]>=0){\n            if (l)lx[l]=rx[l]=mx[l]=sum[l];\n            if (r)lx[r]=rx[r]=mx[r]=sum[r];\n        }else{\n            if (l)lx[l]=rx[l]=0,mx[l]=v[x];\n            if (r)lx[r]=rx[r]=0,mx[r]=v[x];\n        }\n    }\n    if (rev[x]){\n        rev[x]=0;rev[l]^=1;rev[r]^=1;\n        swap(lx[l],rx[l]);swap(lx[r],rx[r]);\n        //\u6ce8\u610f\uff0c\u5728\u7ffb\u8f6c\u64cd\u4f5c\u4e2d\uff0c\u524d\u540e\u7f00\u7684\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217\u90fd\u53cd\u8fc7\u6765\u4e86\uff0c\u5f88\u5bb9\u6613\u9519\n        swap(c[l][0],c[l][1]);swap(c[r][0],c[r][1]);\n    }\n}\n//\u4e0b\u4f20\u6807\u8bb0\ninline void rotate(rint x,rint &k){\n    rint y=fa[x],z=fa[y],l=(c[y][1]==x),r=l^1;\n    if (y==k)k=x;else c[z][c[z][1]==y]=x;\n    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;\n    c[y][l]=c[x][r];c[x][r]=y;\n    pushup(y);pushup(x);\n    //\u65cb\u8f6c\u64cd\u4f5c\uff0c\u4e00\u5b9a\u8981\u4e0a\u4f20\u8bb0\u5f55\u6807\u8bb0\n}\ninline void splay(rint x,rint &k){\n    while (x!=k){\n        int y=fa[x],z=fa[y];\n        if (y!=k){\n            if (c[z][0]==y ^ c[y][0]==x)rotate(x,k);\n                else rotate(y,k);\n        }\n        rotate(x,k);\n    }\n}\n//\u8fd9\u662f\u6574\u4e2a\u7a0b\u5e8f\u7684\u6838\u5fc3\u4e4b\u4e00\uff0c\u6bd5\u7adf\u662f\u4f38\u5c55\u64cd\u4f5c\u561b\ninline int find(rint x,rint rk){\n    pushdown(x);\n    //\u56e0\u4e3a\u6240\u6709\u7684\u64cd\u4f5c\u90fd\u9700\u8981find\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u5728\u8fd9\u91cc\u4e0b\u4f20\u6807\u8bb0\u5c31\u884c\u4e86\n    rint l=c[x][0],r=c[x][1];\n    if (sz[l]+1==rk)return x;\n    if (sz[l]>=rk)return find(l,rk);\n        else return find(r,rk-sz[l]-1);\n}\n//\u8fd9\u4e2afind\u662f\u6211\u4eec\u6574\u4e2a\u7a0b\u5e8f\u7684\u6838\u5fc3\u4e4b\u4e8c\n//\u56e0\u4e3a\u6211\u4eec\u7684\u533a\u95f4\u7ffb\u8f6c\u548c\u63d2\u5165\u53ca\u5220\u9664\u7684\u64cd\u4f5c\u7684\u5b58\u5728\n//\u6211\u4eec\u7ef4\u62a4\u7684\u533a\u95f4\u7684\u5b9e\u9645\u7f16\u53f7\u5e76\u4e0d\u662f\u8fde\u7eed\u7684\n//\u800c\uff0c\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\u53c8\u5bf9\u5e94\u7740\u5e73\u8861\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u4e2d\u7684\u90a3\u6bb5\u533a\u95f4\n//\u6240\u4ee5\u8fd9\u4e2afind\u5f88\u91cd\u8981\ninline void recycle(rint x){\n    rint &l=c[x][0],&r=c[x][1];\n    if (l)recycle(l);\n    if (r)recycle(r);\n    q.push(x);\n    fa[x]=l=r=tag[x]=rev[x]=0;\n}\n//\u8fd9\u5c31\u662f\u7528\u65f6\u95f4\u6362\u7a7a\u95f4\u7684\u56de\u6536\u5197\u4f59\u7f16\u53f7\u673a\u5236\uff0c\u5f88\u597d\u7406\u89e3\ninline int split(rint k,rint tot){\n    rint x=find(rt,k),y=find(rt,k+tot+1);\n    splay(x,rt);splay(y,c[x][1]);\n    return c[y][0];\n}\n//\u8fd9\u4e2asplit\u64cd\u4f5c\u662f\u6574\u4e2a\u7a0b\u5e8f\u7684\u6838\u5fc3\u4e4b\u4e09\n//\u6211\u4eec\u901a\u8fc7\u8fd9\u4e2asplit\u64cd\u4f5c\uff0c\u627e\u5230[k+1,k+tot]\uff0c\u5e76\u628ak,\u548ck+tot+1\u79fb\u5230\u6839\u548c\u53f3\u513f\u5b50\u7684\u4f4d\u7f6e\n//\u7136\u540e\u6211\u4eec\u8fd4\u56de\u4e86\u8fd9\u4e2a\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\ninline void query(rint k,rint tot){\n    rint x=split(k,tot);\n    printf(\"%d\\n\",sum[x]);\n}\ninline void modify(rint k,rint tot,rint val){\n    rint x=split(k,tot),y=fa[x];\n    v[x]=val;tag[x]=1;sum[x]=sz[x]*val;\n    if (val>=0)lx[x]=rx[x]=mx[x]=sum[x];\n        else lx[x]=rx[x]=0,mx[x]=val;\n    pushup(y);pushup(fa[y]);\n    //\u6bcf\u4e00\u6b65\u7684\u4fee\u6539\u64cd\u4f5c\uff0c\u7531\u4e8e\u7236\u5b50\u5173\u7cfb\u53d1\u751f\u6539\u53d8\n    //\u53ca\u8bb0\u5f55\u6807\u8bb0\u53d1\u751f\u6539\u53d8\uff0c\u6211\u4eec\u9700\u8981\u53ca\u65f6\u4e0a\u4f20\u8bb0\u5f55\u6807\u8bb0\n}\ninline void rever(rint k,rint tot){\n    rint x=split(k,tot),y=fa[x];\n    if (!tag[x]){\n        rev[x]^=1;\n        swap(c[x][0],c[x][1]);\n        swap(lx[x],rx[x]);\n        pushup(y);pushup(fa[y]);\n    }\n    //\u540c\u4e0a\n}\ninline void erase(rint k,rint tot){\n    rint x=split(k,tot),y=fa[x];\n    recycle(x);c[y][0]=0;\n    pushup(y);pushup(fa[y]);\n    //\u540c\u4e0a\n}\ninline void build(rint l,rint r,rint f){\n    rint mid=(l+r)>>1,now=id[mid],pre=id[f];\n    if (l==r){\n        mx[now]=sum[now]=a[l];\n        tag[now]=rev[now]=0;\n        //\u8fd9\u91cc\u8fd9\u4e2atag\u548crev\u7684\u6e050\u662f\u5fc5\u8981\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u7f16\u53f7\u53ef\u80fd\u662f\u4e4b\u524d\u5197\u4f59\u4e86\n        lx[now]=rx[now]=max(a[l],0);\n        sz[now]=1;\n    }\n    if (l<mid)build(l,mid-1,mid);\n    if (mid<r)build(mid+1,r,mid);\n    v[now]=a[mid]; fa[now]=pre;\n    pushup(now);\n    //\u4e0a\u4f20\u8bb0\u5f55\u6807\u8bb0\n    c[pre][mid>=f]=now;\n    //\u5f53mid>=f\u65f6\uff0cnow\u662f\u63d2\u5165\u5230\u53c8\u533a\u95f4\u53d6\u4e86\uff0c\u6240\u4ee5c[pre][1]=now\uff0c\u5f53mid<f\u65f6\u540c\u7406\n}\ninline void insert(rint k,rint tot){\n    For(i,1,tot)a[i]=read();\n    For(i,1,tot)\n        if (!q.empty())id[i]=q.front(),q.pop();\n        else id[i]=++cnt;//\u5229\u7528\u961f\u5217\u4e2d\u8bb0\u5f55\u7684\u5197\u4f59\u8282\u70b9\u7f16\u53f7\n    build(1,tot,0);//\u5c06\u8bfb\u5165\u7684tot\u4e2a\u6811\u5efa\u6210\u4e00\u4e2a\u5e73\u8861\u6811\n    rint z=id[(1+tot)>>1];//\u53d6\u4e2d\u70b9\u4e3a\u6839\n    rint x=find(rt,k+1),y=find(rt,k+2);\n    //\u9996\u5148\uff0c\u4f9d\u636e\u4e2d\u5e8f\u904d\u5386\uff0c\u627e\u5230\u6211\u4eec\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\u7684\u5b9e\u9645\u7f16\u53f7\n    splay(x,rt);splay(y,c[x][1]);\n    //\u628ak+1(\u6ce8\u610f\u6211\u4eec\u5df2\u7ecf\u53f3\u79fb\u4e86\u4e00\u4e2a\u5355\u4f4d\uff09\u548c(k+1)+1\u79fb\u5230\u6839\u548c\u53f3\u513f\u5b50\n    fa[z]=y;c[y][0]=z;\n    //\u76f4\u63a5\u628a\u9700\u8981\u63d2\u5165\u7684\u8fd9\u4e2a\u5e73\u8861\u6811\u6302\u5230\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u4e0a\u53bb\u5c31\u597d\u4e86\n    pushup(y);pushup(x);\n    //\u4e0a\u4f20\u8bb0\u5f55\u6807\u8bb0\n}\n//\u5bf9\u4e8e\u5177\u4f53\u5728\u54ea\u91cc\u4e0a\u4f20\u6807\u8bb0\u548c\u4e0b\u4f20\u6807\u8bb0\n//\u53ef\u4ee5\u8fd9\u4e48\u8bb0\uff0c\u53ea\u8981\u7528\u4e86split\u5c31\u8981\u91cd\u65b0\u4e0a\u4f20\u6807\u8bb0\n//\u53ea\u6709find\u4e2d\u9700\u8981\u4e0b\u4f20\u6807\u8bb0\n//\u4f46\u5176\u5b9e\uff0c\u4f60\u591a\u4f20\u51e0\u6b21\u662f\u6ca1\u6709\u5173\u7cfb\u7684\uff0c\u4f46\u662f\u5c11\u4f20\u4e86\u5c31\u4e0d\u884c\u4e86\nint main(){\n    n=read(),m=read();\n    mx[0]=a[1]=a[n+2]=-inf;\n    For(i,1,n)a[i+1]=read();\n    For(i,1,n+2)id[i]=i;//\u865a\u62df\u4e86\u4e24\u4e2a\u8282\u70b91\u548cn+2\uff0c\u7136\u540e\u628a\u9700\u8981\u64cd\u4f5c\u533a\u95f4\u6574\u4f53\u53f3\u79fb\u4e00\u4e2a\u5355\u4f4d\n    build(1,n+2,0);//\u5efa\u6811\n    rt=(n+3)>>1;cnt=n+2;//\u53d6\u6700\u4e2d\u95f4\u7684\u4e3a\u6839\n    rint k,tot,val;char ch[10];\n    while (m--){\n        scanf(\"%s\",ch);\n        if (ch[0]!='M' || ch[2]!='X') k=read(),tot=read();\n        if (ch[0]=='I')insert(k,tot);\n        if (ch[0]=='D')erase(k,tot);\n        if (ch[0]=='M'){\n            if (ch[2]=='X')printf(\"%d\\n\",mx[rt]);\n            else val=read(),modify(k,tot,val);\n        }\n        if (ch[0]=='R')rever(k,tot);\n        if (ch[0]=='G')query(k,tot);\n    }\n    return 0;\n}\n```",
        "postTime": 1508335310,
        "uid": 54916,
        "name": "I_AM_HelloWord",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\n\n\u533a\u95f4\u6811\u8fd9\u73a9\u610f\u771fTM\u7384\u5b66\u3002\u6211\u662f\u4e0d\u662f\u4e5f\u5e94\u8be5\u8bf4\u4e00\u58f0.\n\n# \u65e0\u6307\u9488\u8d85\u8be6\u7ec6Splay\u8bb2\u89e3\n\n## \u5b66\u8fd9\u4e1c\u897f\u4f60\u5fc5\u987b\u8981\u62e5\u6709\u7684\n\n1.\u901a\u8fc7[\u3010\u6a21\u677f\u3011\u6587\u827a\u5e73\u8861\u6811\uff08Splay\uff09](https://www.luogu.org/problemnew/show/P3391)\uff0c[\u3010\u6a21\u677f\u3011\u666e\u901a\u5e73\u8861\u6811](https://www.luogu.org/problemnew/show/P3369)\uff0c[GSS3 - Can you answer these queries III](https://www.luogu.org/problemnew/show/SP1716).\n\n2.\u5b66\u4f1aSplay\uff0c\u5b66\u4f1a\u6c42\u6700\u5927\u5b50\u6bb5\u548c\u5e76\u77e5\u9053\u600e\u4e48\u7ef4\u62a4\u4fe1\u606f\u548c\u4e0b\u4f20\u6807\u8bb0\uff0c\u53ca\u4f1a\u6709\u533a\u95f4\u4fee\u7684\u6700\u5927\u5b50\u6bb5\u548c.\n\n3.~~\u591a\u5e74\u7684\u7f16\u7a0b\u6280\u5de7~~\uff0c\u4ee5\u53ca\u4e00\u9897\u5199\u6570\u636e\u7ed3\u6784\u7684\u826f\u597d\u5fc3\u6001.\n\n4.\u6512\u591f~~\u4e24\u4e2a\u6708\u7684~~\u809d\uff0c\u8fd9\u5f88\u91cd\u8981\uff01\n\n## \u5982\u679c\u4f60\u4e0d\u4f1a\u4e0a\u9762\u4e1c\u897f\u7684\u89e3\u51b3\u65b9\u6cd5\n\n1.\u770b\u4ee5\u4e0b\u535a\u5ba2[Splay\u5165\u95e8\u89e3\u6790](https://www.cnblogs.com/cjyyb/p/7499020.html)\uff0c[\u6587\u827a\u5e73\u8861\u6811Splay\u9898\u89e3](https://www.luogu.org/blog/cjyyb/solution-p3391)\uff0c[GSS\u7cfb\u5217\u9898\u89e3\u2014\u2014\u6700\u5927\u5b50\u6bb5\u548c\u7cfb\u5217](https://www.luogu.org/blog/juruohyfhaha/gss-ji-lie-ti-xie-zui-tai-zi-duan-hu-ji-lie)\u3002\n\n2.\u770b\u4e0a\u9762.\n\n3.\u522b\u7ba1\uff0c\u778e\u903c\u7684.\n\n4.\u597d\u597d\u517b\u751f\uff0c\u5982\u679c\u4e0d\u591f\u809d\u7684\u8bdd\u5343\u4e07\u522b\u5199\u8fd9\u9053\u9898.\n\n# \u90a3\u4e48\u73b0\u5728\u5c31\u53ef\u4ee5\u5f00\u59cb\u4e86\n\n\u65e2\u7136\u4f60\u5df2\u7ecf\u4f1a\u4e86\u4e0a\u9762\u7684\u524d\u7f6e\u6280\u80fd\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb**\u5206\u6b65**\u89e3\u51b3\u8fd9\u9053\u9898\u4e86\u3002\n\n\u5148\u7ed9\u51fa\u6211\u4eec\u9700\u8981\u5b58\u7684\u5168\u90e8\u4fe1\u606f\uff1a\n\n```cpp\nstruct kkk{\n\tint ch[2];\t\t\t//\u5de6\u53f3\u513f\u5b50\n\tint size;\t\t\t//\u5b50\u6811\u5927\u5c0f\n\tint fa;\t\t\t\t//\u7236\u4eb2\n\tint tag;\t\t\t//\u8d4b\u503c\u6807\u8bb0\n\tint val;\t\t\t//\u6743\u503c\n\tint rev;\t\t\t//\u7ffb\u8f6c\u6807\u8bb0\t\t\t\n\tint sum;\t\t\t//\u533a\u95f4\u6743\u503c\u548c\n\tint left;\t\t\t//\u5de6\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u524d\u7f00\u548c\n\tint right;\t\t\t//\u53f3\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u540e\u7f00\u548c\n\tint middle;\t\t\t//\u4e2d\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\n\tvoid clear(){ch[0]=ch[1]=fa=rev=0;tag=TAGNONE;}\t//\u6e05\u7a7a\u8282\u70b9\u4fe1\u606f\n}tree[maxn];\n```\n\n\u5b58\u7684\u4e1c\u897f\u5f88\u591a\uff0c\u5927\u5bb6\u52a1\u5fc5\u8981\u7406\u89e3\u6e05\u695a\u6bcf\u4e00\u4e2a\u4fe1\u606f\u6240\u8868\u8fbe\u7684\u542b\u4e49\u3002\n\n# \u533a\u95f4\u6811Splay\u4ecb\u7ecd\n\n\u505a\u8fc7\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u7684\u90fd\u77e5\u9053\uff0c\u5728\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u91cc\uff0cSplay\u662f\u6309\u7167\u6743\u503c\u6765\u6392\u5e8f\u7684\uff0c\u6240\u4ee5\u80fd\u7ef4\u62a4\u6570\u7684\u5173\u7cfb\u3002\u90a3\u4e48\u73b0\u5728\u5230\u4e86\u7ef4\u62a4\u533a\u95f4\u4e0a\u7684\u64cd\u4f5c\u4e86\uff0c\u4e5f\u5c31\u4e0d\u80fd\u6309\u6743\u503c\u6765\u6392\u5e8f\u4e86\u3002\n\n\u533a\u95f4\u6811\uff0c\u6211\u4eec\u6309\u7167\u7684\u662f\u5e8f\u5217\u4e2d\u7684**\u7f16\u53f7**\u6765\u6392\u5e8f\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5e8f\u5217\u4e2d\u7684\u7b2c**k**\u4e2a\u70b9\uff0c\u5728Splay\u4e2d\u4e5f\u662f\u7b2c**k**\u5927\u7684\u3002\uff08\u6309\u7f16\u53f7\u6392\u5e8f\u561b.\n\n\u6240\u4ee5\u6211\u4eec\u60f3\u8981\u67e5\u627e\u5e8f\u5217\u4e2d\u7b2c**k**\u4e2a\u4f4d\u7f6e\uff0c\u5c31\u76f4\u63a5\u627e**Splay**\u4e2d\u7684\u7b2c**k**\u5927\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6240\u4ee5\u201c\u666e\u901a\u5e73\u8861\u6811\u201d\u91cc\u7684**Splay**\u64cd\u4f5c\uff0c**rotate**\u64cd\u4f5c\u548c**kth**\u64cd\u4f5c\u90fd\u662f\u53ef\u4ee5\u76f4\u63a5\u7167\u642c\u7684\uff08\u4e00\u6837\u7684\uff0c\u53ea\u662f\u7ef4\u62a4\u7f16\u53f7\u800c\u5df2.\n\n\u90a3\u4e48\u6211\u4eec\u600e\u4e48\u5728Splay\u4e2d\u627e\u5230\u4e00\u4e2a\u533a\u95f4[x,y]\u5462\uff1f\n\n\u6211\u4eec\u53ef\u4ee5\u8003\u8651Splay\u7684\u6027\u8d28\uff0c\u5c06 **x** Splay\u4e0a\u6839\uff0c\u518d\u5c06 **y** Splay\u4e0a\u5230x\u7684\u53f3\u8282\u70b9\uff0c\u90a3\u4e48\u6211\u4eec\u5f97\u51fa\u7684 **y** \u7684\u5de6\u5b50\u6811\u5c31\u662f\u6211\u4eec\u8981\u7684[x,y]\u533a\u95f4\u3002\n\n\u4e4b\u540e\u6211\u4eec\u60f3\u5bf9\u8fd9\u4e2a\u533a\u95f4\u505a\u4ec0\u4e48\u5c31\u53ef\u4ee5\u76f4\u63a5\u5bf9\u90a3\u9897\u5b50\u6811\u505a\u4e86\u3002 \n\n\u4e0a\u9762\u5c31\u662f\u533a\u95f4\u6811\u7684\u4e00\u4e9b\u4ecb\u7ecd.\n\n### \u4ee3\u7801\u4e2d\u7684\u4e00\u4e9b\u5b8f\u5b9a\u4e49\n\n```cpp\n#define TAGNONE 10000001\t\t\t\t//\u6ca1\u6709\u8d4b\u503ctag\u7684\u6807\u5fd7\n#define L(node) (tree[node].ch[0])\t\t//\u66ff\u5de6\u513f\u5b50\n#define R(node) (tree[node].ch[1])\t\t//\u66ff\u53f3\u513f\u5b50\n#define F(node) (tree[node].fa)\t\t\t//\u66ff\u7236\u4eb2\n#define V(node) (tree[node].val)\t\t//\u66ff\u6743\u503c\n#define S(node) (tree[node].size)\t\t//\u66ff\u5b50\u6811\u5927\u5c0f\n#define compare(node,x) (tree[node].val<x)\t//\u6bd4\u8f83node\u662f\u6743\u503cx\u7684\u5de6\u513f\u5b50\u8fd8\u662f\u53f3\u513f\u5b50\n```\n# \u64cd\u4f5c\u5256\u6790\n\n## 1.\u57fa\u672c\u64cd\u4f5c Splay,rotate,kth\n\n\u8fd9\u4e2a\u5c31\u4e0d\u7528\u600e\u4e48\u8bf4\u4e86\u5427\uff0c\u5927\u5bb6\u5728\u505a\u5e73\u8861\u6811Splay\u90fd\u5199\u8fc7\u7684\u5566\uff01\n\n## 2.\u5c06\u6307\u5b9a\u533a\u95f4\u627e\u51fa\u6765 split\u64cd\u4f5c\n\n\u548c\u4e0a\u9762\u8bb2\u7684\u533a\u95f4\u6811\u4e00\u6837\uff0c\u5148\u627e\u5230\u533a\u95f4[l,r]\u7684kth\uff0c\u8ba1**l**\u7684kth\u4e3a**x**\uff0c**r**\u7684kth\u4e3a**y**\u3002\n\n\u7136\u540eSplay(x,0);Splay(y,x); \uff08\u76f4\u63a5\u4e0a\u4ee3\u7801\u89e3\u91ca).\n\n\u6700\u540e\u8fd4\u56de**y**\u7684**\u5de6\u513f\u5b50**\u5c31\u662f\u6307\u5b9a\u533a\u95f4.\n\n\u4ee3\u7801\uff1a\n\n```cpp\nint split(int k,int len){\t//\u627e\u5230\u90a3\u4e2a\u533a\u95f4\u7684\u4f4d\u7f6e\n\tint x=kth(k),y=kth(k+len+1);\n\tSplay(x,0);Splay(y,x);\n\treturn L(y);\n}\n```\n\n## 3.\u5efa\u4e00\u9897\u5e73\u8861\u7684Splay\uff0cbuild\u64cd\u4f5c\n\n\u4e00\u5f00\u59cb\u6211\u4eec\u8981\u6784\u9020\u4e00\u9897\u6709\u521d\u59cb\u4fe1\u606f\u7684Splay\uff0c\u4e00\u4e2a\u4e00\u4e2ainsert\u663e\u7136\u5f88\u6162\uff0c\u6240\u4ee5\u6211\u4eec\u5199\u4e00\u4e2abuild\uff0c\u53ef\u4ee5\u5c06\u4e00\u6bb5\u5e8f\u5217\u5efa\u6210\u4e00\u9897\u5e73\u8861\u7684Splay\u7684\u64cd\u4f5c\u3002\n\n\u5176\u5b9e\u5199\u8d77\u6765\u548c\u7ebf\u6bb5\u6811\u5dee\u4e0d\u591a\uff0c\u6ce8\u610f\u662f\u4ee5**\u7f16\u53f7**\u6392\u5e8f\u6765\u5efa\u6811\u3002\n\n```cpp\nvoid New(int node,int x){                       //\u65b0\u5efa\u8282\u70b9\n\ttree[node].middle=tree[node].sum=x;         //\u8d4b\u503c\u4fe1\u606f\n\ttree[node].tag=TAGNONE;tree[node].rev=0;    //\u6807\u8bb0\u521d\u59cb\u5316\n\ttree[node].left=tree[node].right=max(x,0);  //\u533a\u95f4\u8d4b\u503c\n\ttree[node].size=1;          //\u5927\u5c0f\u8d4b\u503c\n}\nvoid build(int begin,int end,int fa){\t\t\t//\u5efa\u6811\n\tint mid=(begin+end)>>1;int node=id[mid],pre=id[fa];\n\tif(begin==end)\t\t\t//\u5230\u8fbe\u5e95\u90e8\n\t\tNew(node,a[begin]);\t//\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\n\tif(begin<mid)build(begin,mid-1,mid);\t//\u5efa\u5de6\u5b50\u6811\n\tif(mid<end)build(mid+1,end,mid);\t\t//\u5efa\u53f3\u5b50\u6811\n\ttree[node].val=a[mid];tree[node].fa=pre;tree[node].tag=TAGNONE;\t//\u57fa\u672c\u4fe1\u606f\u8d4b\u503c\n\tpushup(node);\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n\ttree[pre].ch[mid>=fa]=node;\n}\n```\n\n## 4.\u63d2\u5165\u64cd\u4f5c insert\n\n\u8fd9\u91cc\u9898\u76ee\u8981\u6c42\u7684\u662f\u5728x\u4f4d\u7f6e\u540e\u63d2\u5165\u4e00\u6bb5\u957f\u4e3alen\u7684\u5e8f\u5217.\n\n\u5982\u679c\u6211\u4eec\u8fd8\u662f\u4e00\u4e2a\u4e00\u4e2a\u63d2\u5165\uff0c\u4ecd\u7136\u5f88\u6162\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u628a\u63d2\u5165\u7684\u5e8f\u5217build\u6210\u4e00\u9897\u5e73\u8861\u7684\u5b50\u6811\uff0c\u6700\u540e\u76f4\u63a5\u5728x\u540e\u63d2\u5165\u5efa\u6210\u7684\u5b50\u6811\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```cpp\nvoid insert(int k,int len){\t\t\t//\u63d2\u5165\u533a\u95f4\n\tfor(int i=1;i<=len;i++)scanf(\"%d\",&a[i]);\t//\u8f93\u5165\u533a\u95f4\n\tfor(int i=1;i<=len;i++)\n\t\tid[i]=rublish();\t\t\t//\u4ece\u5783\u573e\u6876\u91cc\u627e\u4e00\u4e2a\u7f16\u53f7\n\tbuild(1,len,0);\t\t\t\t\t//\u5c06\u8f93\u5165\u7684\u533a\u95f4\u5efa\u6210\u4e00\u4e2a\u5b8c\u5168\u4e8c\u53c9\u6811\n\tint z=id[(1+len)>>1];\n\tint x=kth(k+1),y=kth(k+2);\t\t//\u627e\u5230\u8981\u63d2\u5165\u7684\u4f4d\u7f6e\n\tSplay(x,0);Splay(y,x);\n\ttree[z].fa=y; tree[y].ch[0]=z;\t//\u5c06\u65b0\u5efa\u7684\u5b50\u6811\u63d2\u5165\u6811\u4e2d\n\tpushup(y);pushup(x);\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\n```\n\n## 5.\u5220\u9664\u64cd\u4f5c eraser\n\n\u8fd9\u4e2a\u5c31\u66f4\u7b80\u5355\u4e86\uff0c\u76f4\u63a5\u627e\u5230\u90a3\u4e2a\u533a\u95f4\uff0c\u7136\u540e\u8ba9\u90a3\u4e2a\u5b50\u6811\u7684\u7236\u4eb2\u5c06\u5de6\u513f\u5b50\u6e05\u4e3a0\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4f46\u662f\uff0c\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4\uff0c\u6211\u4eec\u52a0\u5165\u4e86\u4e00\u4e2a\u5783\u573e\u56de\u6536\u7684\u64cd\u4f5c\uff0c\u5c31\u662f\u5c06\u5220\u9664\u7684\u8282\u70b9\u91cd\u65b0\u5229\u7528\u8d77\u6765\uff0c\u4ee5\u8282\u7701\u7a7a\u95f4.\n\n\u6240\u4ee5\u6211\u4eec\u8fd8\u8981\u904d\u5386\u4e00\u904d\u5b50\u6811\u5c06\u90a3\u9897\u5b50\u6811\u7684\u8282\u70b9\u6254\u8fdb\u5783\u573e\u6876\u91cc.\n\n```cpp\nint rublish(){\t\t\t\t//\u5783\u573e\u56de\u6536\n\tif(top==0)return ++cnt;\n\tint node=rub[top--];\n\treturn node;\n}\nvoid remove(int node){\t\t//\u5c06\u4e00\u4e2a\u5b50\u6811\u6e05\u7a7a\n\tif(L(node))remove(L(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u5de6\u5b50\u6811\n\tif(R(node))remove(R(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u53f3\u5b50\u6811\n\trub[++top]=node; tree[node].clear();\t//\u6e05\u7a7a\u5e76\u4ecd\u8fdb\u5783\u573e\u6876\uff0c\u5b9a\u4e49\u91cc\u6709\n}\nvoid eraser(int x,int len){\t\t\t//\u5220\u9664\u533a\u95f4\n\tint node=split(x,len),y=F(node);//\u627e\u5230\u8be5\u533a\u95f4\n\tremove(node);tree[y].ch[0]=0;\t//\u5220\u9664\u8be5\u533a\u95f4\uff0c\u5b50\u6811\u6e05\u7a7a\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\n```\n\n## 6.\u4fee\u6539\u64cd\u4f5c update\n\n\u4e00\u6837\u7684\uff0c\u5148\u627e\u5230\u6307\u5b9a\u533a\u95f4\u7684\u5b50\u6811\uff0c\u7136\u540e\u76f4\u63a5\u4fee\u6539\u4fe1\u606f\uff0c\u6253\u4e0a\u8d4b\u503c\u6807\u8bb0.\n\n```cpp\nvoid change_val(int node,int val){          //\u66f4\u65b0\u70b9\u503c\n\tif(!node)return ;   //\u7a7a\u8282\u70b9\u8fd4\u56de\n\ttree[node].tag=tree[node].val=val;      //\u6253\u8d4b\u503c\u6807\u8bb0\uff0c\u66f4\u65b0\u6743\u503c\n\ttree[node].sum=val*tree[node].size;     //\u66f4\u65b0\u533a\u95f4\u6743\u503c\u548c\n\ttree[node].left=tree[node].right=max(tree[node].sum,0); //\u5de6\u53f3\u533a\u95f4\u66f4\u65b0\n\ttree[node].middle=max(tree[node].sum,val);  //\u6700\u5927\u5b50\u6bb5\u548c\u66f4\u65b0\n}\nvoid update(int x,int len,int val){\t//\u66f4\u65b0\u533a\u95f4\u7684\u6307\n\tint node=split(x,len),y=F(node);\t//\u627e\u5230\u8be5\u533a\u95f4\n\tchange_val(node,val);\t\t\t//\u66f4\u65b0\u8be5\u533a\u95f4\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\n```\n\n## 7.\u7ffb\u8f6c\u64cd\u4f5c reverse\n\n\u4e00\u6837\u7684\uff0c\u5148\u627e\u5230\u6307\u5b9a\u7684\u533a\u95f4\u7684\u5b50\u6811\uff0c\u7136\u540e\u76f4\u63a5\u7ffb\u8f6c\uff0c\u6253\u4e0a\u7ffb\u8f6c\u6807\u8bb0.\n\n```cpp\nvoid change_rev(int node){                  //\u66f4\u65b0\u7ffb\u8f6c\n\tswap(tree[node].ch[0],tree[node].ch[1]);//\u4ea4\u6362\u5de6\u53f3\u513f\u5b50\n\tswap(tree[node].left,tree[node].right); //\u4ea4\u6362\u5de6\u53f3\u533a\u95f4\n\ttree[node].rev^=1;\t\t\t\t\t\t//\u6253\u7ffb\u8f6c\u6807\u8bb0\n}\nvoid reverse(int x,int len){\t\t\t//\u7ffb\u8f6c\u533a\u95f4\n\tint node=split(x,len),y=F(node);//\u627e\u5230\u8be5\u533a\u95f4\n\tif(tree[node].tag!=TAGNONE)return ;\t//\u5982\u679c\u5df2\u7ecf\u6709\u8d4b\u503c\u6807\u8bb0\u5c31\u4e0d\u7528\u7ba1\u4e86\n\tchange_rev(node);\t\t\t\t//\u7ffb\u8f6c\u8be5\u533a\u95f4\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\n```\n\n## 8.\u6c42\u548c\u64cd\u4f5c query\n\n\u8fd9\u5c31\u66f4\u7b80\u5355\u4e86\uff0c\u627e\u5230\u6307\u5b9a\u533a\u95f4\u7684\u5b50\u6811\uff0c\u7136\u540e\u76f4\u63a5\u8f93\u51fa\u90a3\u9897\u5b50\u6811\u7684sum\u5c31OK\u4e86.\n\n```cpp\nvoid query(int x,int len){\t//\u67e5\u8be2\u533a\u95f4\u6743\u503c\u548c\n\tint node=split(x,len);\t//\u627e\u5230\u8be5\u533a\u95f4\n\tprintf(\"%d\\n\",tree[node].sum);\t//\u8f93\u51fa\u7b54\u6848\n}\n```\n\n## 9.\u6c42\u6700\u5927\u5b50\u6bb5\u548c\n\n\u76f4\u63a5\u8f93\u51faroot\u7684middle\u6700\u5927\u5b50\u6bb5\u548c.\n\n```cpp\nprintf(\"%d\\n\",tree[root].middle);\n```\n\n# \u96be\u70b9\n\n## 10.\u7ef4\u62a4\u4fe1\u606f\u548c\u4e0b\u4f20\u6807\u8bb0\n\n\u8fd9\u73a9\u610f\u662f\u771f\u6bd2\u7624\uff0c\u4e0d\u8fc7\u4e3b\u8981\u8fd8\u662f\u96be\u5728\u6700\u5927\u5b50\u6bb5\u548c\u4e0a\u9762\uff0c\u53ea\u8981\u6211\u4eec\u80fd\u7406\u89e3\u201cGSS3\u201d\u4e2d\u7684\u6c42\u6cd5\uff0c\u5176\u5b9e\u4e5f\u5f88\u7b80\u5355\u3002\n\n\u7ef4\u62a4\u4fe1\u606f\uff0c\u6240\u4ee5\u9664\u4e86\u8fd9\u4e2a\u6700\u5927\u5b50\u6bb5\u548c\u4e4b\u5916\uff0c\u597d\u50cf\u8fd8\u633a\u7b80\u5355\u7684\u3002\u6700\u5927\u5b50\u6bb5\u548c\u90a3\u51e0\u4e2a\u66f4\u65b0\u65b9\u6cd5\u8fd9\u91cc\u5c31\u4e0d\u8bb2\u4e86\uff0c\u4e0d\u77e5\u9053\u53ef\u4ee5\u770b\u4e0a\u9762\u7684\u535a\u5ba2\u3002\n\n```cpp\nvoid pushup(int node){\t\t\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n\tkkk &x=tree[L(node)],&y=tree[R(node)];int val=tree[node].val;\t//\u5b9e\u8d28\u662f\u5c06\u5de6\u53f3\u513f\u5b50\u5408\u5e76\uff0cx\u4ee3\u66ff\u5de6\u513f\u5b50\uff0cy\u4ee3\u66ff\u53f3\u513f\u5b50\n\tkkk &res=tree[node];\t\t\t\t//res\u4ee3\u66fftree[node]\n\tres.sum=x.sum+y.sum+val; res.size=x.size+y.size+1;\t//\u6743\u503c\u548c\u66f4\u65b0\uff0c\u5b50\u6811\u5927\u5c0f\u66f4\u65b0\n\tres.middle=max(max(x.middle,y.middle),x.right+y.left+val);\t//\u6700\u5927\u5b50\u6bb5\u548c\u66f4\u65b0\n\tres.left=max(x.left,x.sum+y.left+val);\t\t\t//\u533a\u95f4\u6700\u5927\u524d\u7f00\u548c\u66f4\u65b0\n\tres.right=max(y.right,y.sum+x.right+val);\t\t//\u533a\u95f4\u6700\u5927\u540e\u7f00\u548c\u66f4\u65b0\n}\n```\n\n\u4e0b\u4f20\u6807\u8bb0\uff0c\u8fd9\u672c\u6765\u662f\u6bd4\u8f83\u5f97\u6bd2\u7624\uff0c\u6211\u4eec\u8981\u5148\u66f4\u65b0\u8d4b\u503c\u64cd\u4f5c\uff0c\u5de6\u53f3\u513f\u5b50\u6709\u5f88\u591a\u4fe1\u606f\u9700\u8981\u66f4\u65b0\uff0c\u5176\u4e2d\u5c31\u6709tag\uff0csum\uff0cleft\uff0cright\u548cmiddle\uff0c\u66f4\u65b0\u8d77\u6765\u5341\u5206\u7684\u7e41\u7410\u3002\u4f46\u662f\u5728\u4e4b\u524d\u7684\u8d4b\u503c\u64cd\u4f5cupdate\u4e2d\uff0c\u6211\u4eec\u5f15\u5165\u4e86\u4e00\u4e2a\u53ebchange_val\u7684\u51fd\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u90a3\u4e2a\u51fd\u6570\u3002\u4e8e\u662f\u4ee3\u7801\u5c31\u88ab\u51cf\u77ed\u4e86\u5f88\u591a\u3002\n\n\u6700\u540e\u5c06tag\u6807\u8bb0\u4e3aTAGNONE\u5c31OK\u4e86.\n\n\u7136\u540e\u8981\u66f4\u65b0\u7ffb\u8f6c\u64cd\u4f5c\uff0c\u4e00\u6837\u7684\uff0c\u5728\u4e4b\u524d\u7ffb\u8f6c\u64cd\u4f5crevrese\u4e2d\uff0c\u6211\u4eec\u5f15\u5165\u4e86\u4e00\u4e2a\u53ebchange_rev\u7684\u51fd\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\uff0c\u6211\u4eec\u8fd8\u662f\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u3002\u4e8e\u662f\u4ee3\u7801\u53c8\u88ab\u51cf\u4e86\u2026\u2026\n\n\u6700\u540e\u5c06rev\u6807\u8bb0\u4e3a0\u5c31OK\u4e86\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\nvoid pushdown(int node){\t\t\t\t//\u6807\u8bb0\u4e0b\u4f20\n\tif(tree[node].tag!=TAGNONE){\t\t//\u5224\u65ad\u6709\u6ca1\u6709\u8d4b\u503c\u6807\u8bb0\n\t\tchange_val(L(node),tree[node].tag);\t//\u66f4\u65b0\u5de6\u513f\u5b50\n\t\tchange_val(R(node),tree[node].tag);\t//\u66f4\u65b0\u53f3\u513f\u5b50\n\t\ttree[node].tag=TAGNONE;\t\t\t//\u9664\u53bb\u6807\u8bb0\n\t}\n\tif(tree[node].rev){\t\t\t\t\t//\u5224\u65ad\u6709\u6ca1\u6709\u7ffb\u8f6c\u6807\u8bb0\n\t\tchange_rev(L(node));\t\t\t//\u66f4\u65b0\u5de6\u513f\u5b50\n\t\tchange_rev(R(node));\t\t\t//\u66f4\u65b0\u53f3\u513f\u5b50\n\t\ttree[node].rev=0;\t\t\t\t//\u9664\u53bb\u6807\u8bb0\n\t}\n}\n```\n\n\u770b\uff0c\u591a\u7b80\u77ed!\n\n## 11.\u4e3b\u51fd\u6570\n\n\u6ce8\u610f\u8fb9\u754c\uff01\u6ce8\u610f\u8fb9\u754c\uff01\u6ce8\u610f\u8fb9\u754c\uff01 \u4e3b\u8981\u7684\u4e8b\u60c5\u8bf4\u4e09\u904d\uff01\n\n\u5176\u4ed6\u5c31\u6ca1\u4ec0\u4e48\u4e86\uff0c\u90fd\u662f\u8f93\u5165\u561b\u3002\n\n# \u603b\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n#define TAGNONE 10000001\n#define maxn 1000010\n#define inf 100000001\n#define L(node) (tree[node].ch[0])\t\t//\u66ff\u5de6\u513f\u5b50\n#define R(node) (tree[node].ch[1])\t\t//\u66ff\u53f3\u513f\u5b50\n#define F(node) (tree[node].fa)\t\t\t//\u66ff\u7236\u4eb2\n#define V(node) (tree[node].val)\t\t//\u66ff\u6743\u503c\n#define S(node) (tree[node].size)\t\t//\u66ff\u5b50\u6811\u5927\u5c0f\n#define compare(node,x) (tree[node].val<x)\t//\u6bd4\u8f83node\u662f\u6743\u503cx\u7684\u5de6\u513f\u5b50\u8fd8\u662f\u53f3\u513f\u5b50\nusing namespace std;\nint root,cnt,a[maxn],id[maxn],rub[maxn],top,n,m;\nstruct kkk{\n\tint ch[2];\t\t\t//\u5de6\u53f3\u513f\u5b50\n\tint size;\t\t\t//\u5b50\u6811\u5927\u5c0f\n\tint fa;\t\t\t\t//\u7236\u4eb2\n\tint tag;\t\t\t//\u8d4b\u503c\u6807\u8bb0\n\tint val;\t\t\t//\u6743\u503c\n\tint rev;\t\t\t//\u7ffb\u8f6c\u6807\u8bb0\t\t\t\n\tint sum;\t\t\t//\u533a\u95f4\u6743\u503c\u548c\n\tint left;\t\t\t//\u5de6\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u524d\u7f00\u548c\n\tint right;\t\t\t//\u53f3\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u540e\u7f00\u548c\n\tint middle;\t\t\t//\u4e2d\u533a\u95f4\uff0c\u6307\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\n\tvoid clear(){ch[0]=ch[1]=fa=rev=0;tag=TAGNONE;}\t//\u6e05\u7a7a\u8282\u70b9\u4fe1\u606f\n}tree[maxn];\nint rublish(){\t\t\t\t//\u5783\u573e\u56de\u6536\n\tif(top==0)return ++cnt;\n\tint node=rub[top--];\n\treturn node;\n}\nvoid change_val(int node,int val){          //\u66f4\u65b0\u70b9\u503c\n\tif(!node)return ;   //\u7a7a\u8282\u70b9\u8fd4\u56de\n\ttree[node].tag=tree[node].val=val;      //\u6253\u8d4b\u503c\u6807\u8bb0\uff0c\u66f4\u65b0\u6743\u503c\n\ttree[node].sum=val*tree[node].size;     //\u66f4\u65b0\u533a\u95f4\u6743\u503c\u548c\n\ttree[node].left=tree[node].right=max(tree[node].sum,0); //\u5de6\u53f3\u533a\u95f4\u66f4\u65b0\n\ttree[node].middle=max(tree[node].sum,val);  //\u6700\u5927\u5b50\u6bb5\u548c\u66f4\u65b0\n}\nvoid change_rev(int node){                  //\u66f4\u65b0\u7ffb\u8f6c\n\tswap(tree[node].ch[0],tree[node].ch[1]);//\u4ea4\u6362\u5de6\u53f3\u513f\u5b50\n\tswap(tree[node].left,tree[node].right); //\u4ea4\u6362\u5de6\u53f3\u533a\u95f4\n\ttree[node].rev^=1;\t\t\t\t\t\t//\u6253\u7ffb\u8f6c\u6807\u8bb0\n}\nvoid pushup(int node){\t\t\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n\tkkk &x=tree[L(node)],&y=tree[R(node)];int val=tree[node].val;\t//\u5b9e\u8d28\u662f\u5c06\u5de6\u53f3\u513f\u5b50\u5408\u5e76\uff0cx\u4ee3\u66ff\u5de6\u513f\u5b50\uff0cy\u4ee3\u66ff\u53f3\u513f\u5b50\n\tkkk &res=tree[node];\t\t\t\t//res\u4ee3\u66fftree[node]\n\tres.sum=x.sum+y.sum+val;res.size=x.size+y.size+1;\t//\u6743\u503c\u548c\u66f4\u65b0\uff0c\u5b50\u6811\u5927\u5c0f\u66f4\u65b0\n\tres.middle=max(max(x.middle,y.middle),x.right+y.left+val);\t//\u6700\u5927\u5b50\u6bb5\u548c\u66f4\u65b0\n\tres.left=max(x.left,x.sum+y.left+val);\t\t\t//\u533a\u95f4\u6700\u5927\u524d\u7f00\u548c\u66f4\u65b0\n\tres.right=max(y.right,y.sum+x.right+val);\t\t//\u533a\u95f4\u6700\u5927\u540e\u7f00\u548c\u66f4\u65b0\n}\nvoid pushdown(int node){\t\t\t\t//\u6807\u8bb0\u4e0b\u4f20\n\tif(tree[node].tag!=TAGNONE){\t\t//\u5224\u65ad\u6709\u6ca1\u6709\u8d4b\u503c\u6807\u8bb0\n\t\tchange_val(L(node),tree[node].tag);\t//\u66f4\u65b0\u5de6\u513f\u5b50\n\t\tchange_val(R(node),tree[node].tag);\t//\u66f4\u65b0\u53f3\u513f\u5b50\n\t\ttree[node].tag=TAGNONE;\t\t\t//\u9664\u53bb\u6807\u8bb0\n\t}\n\tif(tree[node].rev){\t\t\t\t\t//\u5224\u65ad\u6709\u6ca1\u6709\u7ffb\u8f6c\u6807\u8bb0\n\t\tchange_rev(L(node));\t\t\t//\u66f4\u65b0\u5de6\u513f\u5b50\n\t\tchange_rev(R(node));\t\t\t//\u66f4\u65b0\u53f3\u513f\u5b50\n\t\ttree[node].rev=0;\t\t\t\t//\u9664\u53bb\u6807\u8bb0\n\t}\n}\nvoid rotate(int node){                      //rotate \u6a21\u677f\n\tint fa=F(node);\n\tint gfa=F(fa);\n\tint z=tree[fa].ch[1]==node;\n\ttree[gfa].ch[tree[gfa].ch[1]==fa]=node; tree[node].fa=gfa;\n\ttree[fa].ch[z]=tree[node].ch[z^1];tree[tree[node].ch[z^1]].fa=fa;\n\ttree[node].ch[z^1]=fa;tree[fa].fa=node;\n\tpushup(fa); pushup(node);\n}\nvoid Splay(int node,int goal){              //Splay \u6a21\u677f\n\twhile(tree[node].fa!=goal){\n\t\tint fa=F(node);\n\t\tint gfa=F(fa);\n\t\tif(gfa!=goal)\n\t\t(compare(fa,tree[node].val))!=(compare(gfa,tree[fa].val))\n\t\t?rotate(node) : rotate(fa);\n\t\trotate(node);\n\t}\n\tif(!goal)root=node;\n}\nvoid New(int node,int x){                       //\u65b0\u5efa\u8282\u70b9\n\ttree[node].middle=tree[node].sum=x;         //\u8d4b\u503c\u4fe1\u606f\n\ttree[node].tag=TAGNONE;tree[node].rev=0;    //\u6807\u8bb0\u521d\u59cb\u5316\n\ttree[node].left=tree[node].right=max(x,0);  //\u533a\u95f4\u8d4b\u503c\n\ttree[node].size=1;          //\u5927\u5c0f\u8d4b\u503c\n}\nvoid build(int begin,int end,int fa){\t\t\t//\u5efa\u6811\n\tint mid=(begin+end)>>1;int node=id[mid],pre=id[fa];\n\tif(begin==end)\t\t\t//\u5230\u8fbe\u5e95\u90e8\n\t\tNew(node,a[begin]);\t//\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\n\tif(begin<mid)build(begin,mid-1,mid);\t//\u5efa\u5de6\u5b50\u6811\n\tif(mid<end)build(mid+1,end,mid);\t\t//\u5efa\u53f3\u5b50\u6811\n\ttree[node].val=a[mid];tree[node].fa=pre;tree[node].tag=TAGNONE;\t//\u57fa\u672c\u4fe1\u606f\u8d4b\u503c\n\tpushup(node);\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n\ttree[pre].ch[mid>=fa]=node;\n}\nint kth(int x){\t\t\t\t//kth\u6a21\u677f\n\tint node=root;\n\twhile(1){\n\t\tpushdown(node);\n\t\tif(tree[L(node)].size>=x)node=L(node);\n\t\telse\n\t\tif(tree[L(node)].size+1==x)return node;\n\t\telse x-=tree[L(node)].size+1,node=R(node);\n\t}\n}\nvoid remove(int node){\t\t//\u5c06\u4e00\u4e2a\u5b50\u6811\u6e05\u7a7a\n\tif(L(node))remove(L(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u5de6\u5b50\u6811\n\tif(R(node))remove(R(node));\t\t//\u7ee7\u7eed\u6e05\u7a7a\u53f3\u5b50\u6811\n\trub[++top]=node; tree[node].clear();\t//\u6e05\u7a7a\u5e76\u4ecd\u8fdb\u5783\u573e\u6876\n}\nint split(int k,int len){\t//\u627e\u5230\u90a3\u4e2a\u533a\u95f4\u7684\u4f4d\u7f6e\n\tint x=kth(k),y=kth(k+len+1);\n\tSplay(x,0);Splay(y,x);\n\treturn L(y);\n}\nvoid query(int x,int len){\t//\u67e5\u8be2\u533a\u95f4\u6743\u503c\u548c\n\tint node=split(x,len);\t//\u627e\u5230\u8be5\u533a\u95f4\n\tprintf(\"%d\\n\",tree[node].sum);\t//\u8f93\u51fa\u7b54\u6848\n}\nvoid update(int x,int len,int val){\t//\u66f4\u65b0\u533a\u95f4\u7684\u6307\n\tint node=split(x,len),y=F(node);\t//\u627e\u5230\u8be5\u533a\u95f4\n\tchange_val(node,val);\t\t\t//\u66f4\u65b0\u8be5\u533a\u95f4\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\nvoid rever(int x,int len){\t\t\t//\u7ffb\u8f6c\u533a\u95f4\n\tint node=split(x,len),y=F(node);//\u627e\u5230\u8be5\u533a\u95f4\n\tif(tree[node].tag!=TAGNONE)return ;\t//\u5982\u679c\u5df2\u7ecf\u6709\u8d4b\u503c\u6807\u8bb0\u5c31\u4e0d\u7528\u7ba1\u4e86\n\tchange_rev(node);\t\t\t\t//\u7ffb\u8f6c\u8be5\u533a\u95f4\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\nvoid eraser(int x,int len){\t\t\t//\u5220\u9664\u533a\u95f4\n\tint node=split(x,len),y=F(node);//\u627e\u5230\u8be5\u533a\u95f4\n\tremove(node);tree[y].ch[0]=0;\t//\u5220\u9664\u8be5\u533a\u95f4\uff0c\u5b50\u6811\u6e05\u7a7a\n\tpushup(y);pushup(F(y));\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\nvoid insert(int k,int len){\t\t\t//\u63d2\u5165\u533a\u95f4\n\tfor(int i=1;i<=len;i++)scanf(\"%d\",&a[i]);\t//\u8f93\u5165\u533a\u95f4\n\tfor(int i=1;i<=len;i++)\n\t\tid[i]=rublish();\n\tbuild(1,len,0);\t\t\t\t\t//\u5c06\u8f93\u5165\u7684\u533a\u95f4\u5efa\u6210\u4e00\u4e2a\u5b8c\u5168\u4e8c\u53c9\u6811\n\tint z=id[(1+len)>>1];\n\tint x=kth(k+1),y=kth(k+2);\t\t//\u627e\u5230\u8981\u63d2\u5165\u7684\u4f4d\u7f6e\n\tSplay(x,0);Splay(y,x);\n\ttree[z].fa=y; tree[y].ch[0]=z;\t//\u5c06\u65b0\u5efa\u7684\u5b50\u6811\u63d2\u5165\u6811\u4e2d\n\tpushup(y);pushup(x);\t\t\t//\u7ef4\u62a4\u4fe1\u606f\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\ttree[0].middle=a[1]=a[n+2]=-inf;\t//\u8fb9\u754c\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i+1]);\t//\u8f93\u5165\n\tfor(int i=1;i<=n+2;i++)id[i]=i;\n\tbuild(1,n+2,0);\t\t\t\t\t//\u5efa\u6210\u4e00\u9897Splay\n\troot=(n+3)>>1;cnt=n+2;\t\t\t//\u6307\u6839\uff0c\u66f4\u65b0\u70b9\u6570\n\tfor(int i=1;i<=m;i++){\n\t\tstring s; int x,len,y;  \n\t\tcin>>s;\n\t\tif(s!=\"MAX-SUM\")scanf(\"%d%d\",&x,&len);\n\t\telse printf(\"%d\\n\",tree[root].middle);\n\t\tif(s==\"INSERT\")insert(x,len);\n\t\tif(s==\"DELETE\")eraser(x,len);\n\t\tif(s==\"MAKE-SAME\")\n\t\t\tscanf(\"%d\",&y),update(x,len,y);\n\t\tif(s==\"REVERSE\")rever(x,len);\n\t\tif(s==\"GET-SUM\")query(x,len);\n\t}\n}\n```\n\n## \u540e\u8bb0\n\n\u5b66\u4e60\u65f6\u6709\u53c2\u8003[I_AM_HelloWord](https://www.luogu.org/space/show?uid=54916)\u5927\u4f6c\u7684\u9898\u89e3\u3002\u6240\u4ee5\u6709\u7684\u5730\u65b9\u548c\u4ed6\u7684\u4ee3\u7801\u5f88\u50cf\u3002\n\n\u5e0c\u671b\u5927\u5bb6\u90fd\u80fd\u638c\u63e1\u533a\u95f4\u6811QwQ\u3002\n\n# \u8c22\u8c22\u89c2\u8d4f",
        "postTime": 1555505422,
        "uid": 58711,
        "name": "hyfhaha",
        "ccfLevel": 6,
        "title": "\u533a\u95f4\u6811\u5b66\u4e60\u603b\u7ed3\u2014\u2014[NOI2005]\u7ef4\u62a4\u6570\u5217"
    },
    {
        "content": "\u4f17\u6240\u5468\u77e5\u8fd9\u662f\u4e00\u9053\u975e\u5e38\u6076\u5fc3\u7684\u9898\u76ee\u2026\u2026\u5751\u70b9\u5b9e\u5728\u592a\u591a\u2026\u2026\n\n\u672c\u4eba\u4f7f\u7528fhqtreap\u5b9e\u73b0\u3002150\u884c\u5de6\u53f3\uff0c\u4e5f\u53ea\u662f``Merge``\u548c``Split``\u91cc\u7a0d\u5fae\u538b\u4e86\u51e0\u884c\uff0c\u6bd4\u8d77\u4e00\u822c\u7684splay\u8fd8\u662f\u8981\u77ed\u4e0d\u5c11\u7684\u3002\n\n\u5148\u5206\u6790\u4e00\u4e0b\uff0c\u6b64\u9898\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u548c\u4ee5\u53ca\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u3002\u663e\u7136\u6309size\u5206\u88c2\u4e0d\u7528\u591a\u8bf4\u3002\u533a\u95f4\u548c\u975e\u5e38\u7b80\u5355\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u5219\u7a0d\u5fae\u6709\u70b9\u9ebb\u70e6\uff0c\u9700\u8981\u989d\u5916\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u524d\u7f00\uff0c\u533a\u95f4\u6700\u5927\u540e\u7f00\u3002``pushup``\u65f6\u5b9e\u73b0\u5982\u4e0b\uff1a\n\n```\nT[x].maxqz=max(max(T[T[x].l].maxqz,T[T[x].l].sum+T[x].val+T[T[x].r].maxqz),0);\nT[x].maxhz=max(max(T[T[x].r].maxhz,T[T[x].r].sum+T[x].val+T[T[x].l].maxhz),0);\nT[x].maxzd=max(T[x].val,T[x].val+T[T[x].l].maxhz+T[T[x].r].maxqz);\nif(T[x].l) T[x].maxzd=max(T[x].maxzd,T[T[x].l].maxzd);\nif(T[x].r) T[x].maxzd=max(T[x].maxzd,T[T[x].r].maxzd);\n```\n\n\u6ce8\u610f\u8fd9\u91cc\u548c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u7684\u4ee3\u7801\u6709\u7ec6\u5fae\u533a\u522b\uff1a\u6211\u4eec\u6709\u4e9b\u5730\u65b9\u8981\u52a0\u4e0a``T[x].val``\u3002\u539f\u56e0\u663e\u7136\uff0c\u7236\u8282\u70b9\u4e0d\u4ec5\u4ec5\u662f\u8be5\u533a\u95f4\u7684\u4ee3\u8868\uff0c\u4e5f\u5305\u62ec\u4e86\u5bf9\u5e94\u5355\u4e2a\u4f4d\u7f6e\u7684\u4fe1\u606f\uff0c\u533a\u95f4\u52a0\u6cd5\u5e94\u662f\uff1a\u5de6\u533a\u95f4+\u8be5\u8282\u70b9\u5bf9\u5e94\u4f4d\u7f6e+\u53f3\u533a\u95f4=\u6574\u4e2a\u533a\u95f4\u3002\n\n\u540c\u65f6\u6211\u4eec\u8fd8\u8981\u7ef4\u62a4\u4e24\u4e2alazytag\uff1a\u7ffb\u8f6c\u533a\u95f4\u548c\u533a\u95f4\u8d4b\u503c\u3002\n\n\u533a\u95f4\u8d4b\u503c\u5f88\u597d\u641e\uff08\u7136\u800c\u4e5f\u6709\u9700\u8981\u6ce8\u610f\u7684\u70b9\uff0c\u89c1\u4e0b\uff09\uff0c\u533a\u95f4\u7ffb\u8f6c\u7684\u5b9e\u73b0\u65b9\u5f0f\u5219\u662f\u4ea4\u6362\u4e00\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u513f\u5b50\u3002\u6574\u9897\u5b50\u6811\u7684\u5de6\u53f3\u513f\u5b50\u90fd\u4ea4\u6362\u4e86\u533a\u95f4\u5c31\u6210\u529f\u7ffb\u8f6c\u4e86\u3002\u5f53\u7136\u5b9e\u9645\u4e0a\u6211\u4eec\u8981\u4f7f\u7528lazytag\uff0c\u800c\u4e0d\u662f\u5728\u7ffb\u8f6c\u7684\u65f6\u5019\u76f4\u63a5\u641c\u8fdb\u5b50\u6811\u5168\u90e8\u4ea4\u6362\u6389\u3002\uff08\u5177\u4f53\u600e\u4e48\u64cd\u4f5c\uff0c\u89c1\u4e0b\uff09\n\n\u7136\u540e\u662f~~\u4e00\u4e9b~~\u5f88\u591a\u5b9e\u73b0\u4e0a\u7684\u5751\u70b9\u2026\u2026\n\n### \u5751\u70b9\u4e00\uff1a\u7a7a\u95f4\u95ee\u9898\n\n\u6570\u636e\u8303\u56f4\u91cc\u8bf4\u4e86\uff0c\u6700\u591a\u63d2\u5165``4*1e6``\u4e2a\u6570\uff0c\u4efb\u4f55\u65f6\u5019\u6570\u5217\u91cc\u6700\u591a``5*1e5``\u4e2a\u6570\u3002\u7136\u800c\u56e0\u4e3a\u6b64\u9898\u8981\u7ef4\u62a4\u7684tag\u5b9e\u5728\u592a\u591a\uff0c\u6211\u7ef4\u62a4\u4e869\u4e2a``int``\u7c7b\u578b\u548c2\u4e2a``bool``\u7c7b\u578b\uff0c\u5982\u679c\u76f4\u63a5\u5f00``4.5*1e6``\u4e2a\u8282\u70b9\u662f\u80af\u5b9a\u5f00\u4e0d\u4e0b\u7684\u3002\n\n\u6ce8\u610f\u5230\u5e8f\u5217\u91cc\u6700\u591a``5*1e5``\u4e2a\u6570\uff0c\u6240\u4ee5\u80af\u5b9a\u4f1a\u6709\u5f88\u591a\uff0c\u4f46\u4e0d\u4f1a\u592a\u591a\uff08\u6700\u591a``4.5*1e6``\uff09\u7684\u8282\u70b9\u88ab\u5220\u6389\uff0c\u6211\u4eec\u60f3\u5230\u53ef\u4ee5\u628a\u5e9f\u6389\u7684\u8282\u70b9\u91cd\u590d\u5229\u7528\u3002\u6240\u4ee5\u5f53\u6267\u884c\u533a\u95f4\u5220\u9664\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u8981\u904d\u5386\u88ab\u5220\u9664\u7684\u90a3\u68f5\u6811\u5e76\u628a\u6240\u6709\u8282\u70b9\u7684\u7f16\u53f7\u653e\u5165\u4e00\u4e2a\u201c\u5783\u573e\u573a\u201d\uff08\u6211\u4f7f\u7528\u4e86\u4e00\u4e2a\u6808\uff09\uff0c\u521b\u5efa\u65b0\u8282\u70b9\u7684\u65f6\u5019\u5230\u201c\u5783\u573e\u573a\u201d\u91cc\u53bb\u53d6\u53ef\u7528\u7684\u7f16\u53f7\u3002\u8fd9\u6837\u7a7a\u95f4\u5c31\u6bd4\u8f83\u5065\u5eb7\u4e86\u3002\n\n### \u5751\u70b9\u4e8c\uff1a\u5173\u4e8e\u533a\u95f4\u4fee\u6539\n\n\uff08\u5176\u5b9e\u8fd9\u4e2a\u5751\u70b9\u662f\u6211\u81ea\u5df1sb\u4e86\uff09\n\n\u533a\u95f4\u4fee\u6539\u4e0d\u80fd\u7528\u201c\u5220\u9664\u539f\u533a\u95f4\u518d\u63d2\u5165\u4e00\u5927\u6bb5\u76f8\u540c\u7684\u6570\u201d\u6765\u5b9e\u73b0\uff0c\u5426\u5219\u4f60\u7684\u7b2c9\u4e2a\u70b9\u4f1a\u8dd1\u5c06\u8fd1\u534a\u5206\u949f\u3002\u539f\u56e0\u662f\u663e\u7136\u7684\uff1a\u5982\u679c\u6709\u4e00\u5927\u5806\u8d4b\u503c\u64cd\u4f5c\uff0c\u4f60\u5c31\u4f1a\u5220\u9664\u4e00\u5927\u5806\u8282\u70b9\uff08\u53ef\u80fd\u8fdc\u8fdc\u8d85\u8fc7``4.5*1e6``\uff09\uff0c\u4e8e\u662f\u590d\u6742\u5ea6\u5c31\u5047\u4e86\u3002\n\n\u8fd8\u662f\u8001\u8001\u5b9e\u5b9e\u7528lazytag\u5427\u3002\n\n### \u5751\u70b9\u4e09\uff1a\u533a\u95f4\u7ffb\u8f6c\u4f1a\u5bfc\u81f4\u524d\u7f00\u53d8\u6210\u540e\u7f00\uff0c\u540e\u7f00\u53d8\u6210\u524d\u7f00\n\n\u5982\u9898\u3002\n\n### \u5751\u70b9\u56db\uff1a\u6b64\u9898\u4e2d\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u4e0d.\u80fd.\u4e3a.\u7a7a.\n\n\u662f\u6211\u505a\u9898\u592a\u5c11\u8fd8\u662f\u5176\u4ed6\u9898\u76ee\u771f\u7684\u90fd\u89c4\u5b9a\u53ef\u4ee5\u9009\u7a7a\u6bb5\u2026\u2026\n\n\u6240\u4ee5\uff1a\n\n- \u65b0\u5efa\u8282\u70b9\u7684\u65f6\u5019\u5f3a\u5236\u6700\u5927\u5b57\u6bb5\u548c\u4e3a\u8be5\u4f4d\u7f6e\u6743\u503c\n\n- \u8fdb\u884c\u533a\u95f4\u8d4b\u503c\u7684\u65f6\u5019\uff0c\u5982\u679c\u8d4b\u503c\u4e3a\u4e00\u4e2a\u8d1f\u6570\uff0c\u533a\u95f4\u6700\u5927\u5b57\u6bb5\u548c\u4e5f\u5fc5\u987b\u5f97\u9009**\u4e00\u4e2a**\u3002\n\n\u7136\u800c\u6700\u5927\u524d\u7f00\u540e\u7f00\u8fd8\u662f\u53ef\u4ee5\u53d6\u7a7a\u6bb5\u7684\u3002\u539f\u56e0\u5927\u7ea6\u53ef\u4ee5\u89e3\u91ca\u4e3a\u201c\u5de6\u513f\u5b50\u540e\u7f00+\u7236\u4eb2\u6743\u503c+\u53f3\u513f\u5b50\u524d\u7f00\u201d\u5408\u5e76\u6210\u533a\u95f4\u5b50\u6bb5\u7684\u65f6\u5019\uff0c\u663e\u7136\u5fc5\u9009\u4e00\u4e2a\u7236\u4eb2\u8282\u70b9\uff0c\u6240\u4ee5\u5c31\u7b97\u5de6\u513f\u5b50\u524d\u7f00\u3001\u53f3\u513f\u5b50\u540e\u7f00\u90fd\u4e3a\u7a7a\u4e5f\u4e0d\u4f1a\u9009\u5230\u7a7a\u6bb5\u3002\n\n### \u5751\u70b9\u4e94\uff1a\u591apush_down\uff0cpush_up\n\n\u867d\u7136\u6211\u7684\u5199\u6cd5\u5e76\u6ca1\u6709\u9047\u5230\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u662f\u6709\u4e9b\u5199\u6cd5\u53ef\u80fd\u4f1a\u9047\u5230\uff0c\u8fd8\u662f\u6ce8\u610f\u4e00\u4e0b\u5427\u3002\n\n### \u5751\u70b9\u516d\uff1a\u6253lazytag\u7684\u65f6\u5019\u5efa\u8bae\u8fd9\u4e48\u641e\n\n\u6bd4\u5982\u533a\u95f4\u7ffb\u8f6c\uff0c\u6211\u4eec\u8fd9\u6837\u641e\uff1a\n\n```cpp\nvoid Reverse(int x){\n\tif(!x) return;\n\tswap(T[x].l,T[x].r);\n\tswap(T[x].maxhz,T[x].maxqz);\n\tT[x].lzy^=1;\n}\n```\n\n\u5e76\u4e0d\u5728\u4e0b\u4f20lazytag\u7684\u65f6\u5019\u4ea4\u6362\u5de6\u53f3\u513f\u5b50\u800c\u662f\u73b0\u5728\u5c31\u4ea4\u6362\u3002``push_down``\u7684\u65f6\u5019\uff0c\u5219``Reverse``\u5de6\u513f\u5b50\uff0c\u53f3\u513f\u5b50\u3002\n\n\u533a\u95f4\u8d4b\u503c\u7c7b\u4f3c\u3002\n\n\u5b9e\u9645\u8c03\u8bd5\u7684\u65f6\u5019\u6bcf\u4e2a\u4eba\u8fd8\u4f1a\u9047\u5230\u4e00\u4e9b\u6bd4\u8f83\u4e2a\u4eba\u6027\u7684\u9519\u8bef\uff0c\u6b64\u5904\u6ca1\u6cd5\u5c55\u5f00\u8bb2\u4e86\u3002\u6211\u7684\u4ee3\u7801\u5982\u4e0b\u3002\n\n\u4e0d\u5f00O2\u7684\u8bdd3.41s\uff0c\u5f00O2\u7684\u8bdd1.08s\uff0c\u679c\u7136\u8fd8\u662f\u592a\u83dc\u4e86\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint stk[500005],len; \n\nint inline read(){\n\tint num=0;bool neg=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-') neg=1;c=getchar();}\n\twhile(c>='0'&&c<='9') num=num*10+c-'0',c=getchar();\n\treturn neg?-num:num; \n}\n\nstruct fhqtreap{\n\tint l,r,s,val,cov;bool lzy,cov_flg;\n\tint sum,maxqz,maxhz,maxzd;\n}T[500005];int idx,rt;\nint NewNode(int v){\n\tidx=stk[len--];T[idx].l=T[idx].r=T[idx].lzy=T[idx].cov=0;\n\tT[idx].s=1;\n\tT[idx].val=T[idx].sum=v;\n\tT[idx].maxqz=T[idx].maxhz=max(0,v);T[idx].maxzd=v;\n\treturn idx;\n}\nvoid push_up(int x){\n\tif(!x) return;\n\tT[x].s=T[T[x].l].s+T[T[x].r].s+1;\n\tT[x].sum=T[T[x].l].sum+T[T[x].r].sum+T[x].val;\n\tT[x].maxqz=max(max(T[T[x].l].maxqz,T[T[x].l].sum+T[x].val+T[T[x].r].maxqz),0);\n\tT[x].maxhz=max(max(T[T[x].r].maxhz,T[T[x].r].sum+T[x].val+T[T[x].l].maxhz),0);\n\tT[x].maxzd=max(T[x].val,T[x].val+T[T[x].l].maxhz+T[T[x].r].maxqz);\n\tif(T[x].l) T[x].maxzd=max(T[x].maxzd,T[T[x].l].maxzd);\n\tif(T[x].r) T[x].maxzd=max(T[x].maxzd,T[T[x].r].maxzd);\n}\nvoid Reverse(int x){\n\tif(!x) return;\n\tswap(T[x].l,T[x].r);\n\tswap(T[x].maxhz,T[x].maxqz);\n\tT[x].lzy^=1;\n}\nvoid Cover(int x,int ci){\n\tT[x].val=T[x].cov=ci;T[x].sum=T[x].s*ci;\n\tT[x].maxqz=T[x].maxhz=max(0,T[x].sum);\n\tT[x].maxzd=max(ci,T[x].sum);\n\tT[x].cov_flg=1;\n}\nvoid push_down(int x){\n\tif(!x) return;\n\tif(T[x].lzy){\n\t\tif(T[x].l) Reverse(T[x].l);\n\t\tif(T[x].r) Reverse(T[x].r);\n\t\tT[x].lzy=0;\n\t}\n\tif(T[x].cov_flg){\n\t\tif(T[x].l) Cover(T[x].l,T[x].cov);\n\t\tif(T[x].r) Cover(T[x].r,T[x].cov);\n\t\tT[x].cov=T[x].cov_flg=0;\n\t}\n}\nvoid Del(int x){\n\tif(!x) return;\n\tstk[++len]=x;\n\tif(T[x].l) Del(T[x].l);if(T[x].r) Del(T[x].r);\n}\nvoid Split(int x,int &L,int &R,int K){\n\tif(x) push_down(x);\n\tif(!x){L=R=0;return;}\n\tif(T[T[x].l].s+1<=K) L=x,Split(T[x].r,T[L].r,R,K-T[T[x].l].s-1);\n\telse\t\t\t\t R=x,Split(T[x].l,L,T[R].l,K);\n\tpush_up(x);\n}\nvoid Merge(int x,int y,int &M){\n\tif(!x||!y){M=x+y;return;}\n\tif(90000008%(T[x].s+T[y].s)<T[x].s)\n\t\t push_down(x),M=x,Merge(T[x].r,y,T[M].r),push_up(x);\n\telse push_down(y),M=y,Merge(x,T[y].l,T[M].l),push_up(y);\n}\n\nint N,M;\nint A[500005];\nint Build(int l,int r){\n\tif(l==r){\n\t\treturn NewNode(A[l]);\n\t}\n\tint x,mid=(l+r)>>1;\n\tMerge(Build(l,mid),Build(mid+1,r),x);\n\treturn x;\n}\n\nchar opt[10];\nint main(){\n\tN=read(),M=read();\n\tfor(int i=1;i<=500000;++i) stk[++len]=i;\n\tfor(int i=1;i<=N;++i) A[i]=read();\n\tMerge(rt,Build(1,N),rt);\n\twhile(M--){\n\t\tscanf(\"%s\",opt);\n\t\tif(opt[0]=='I'){\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y;\n\t\t\tSplit(rt,x,y,pos);\n\t\t\tfor(int i=1;i<=tot;++i) A[i]=read();\n\t\t\tMerge(x,Build(1,tot),x);\n\t\t\tMerge(x,y,rt);\n\t\t}\n\t\telse if(opt[0]=='D'){\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,x,y,pos-1);\n\t\t\tSplit(y,y,z,tot);\n\t\t\tDel(y);\n\t\t\tMerge(x,z,rt);\n\t\t}\n\t\telse if(opt[0]=='M'&&opt[2]=='K'){\n\t\t\tint pos=read(),tot=read(),ci=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,x,y,pos-1);\n\t\t\tSplit(y,y,z,tot);\n\t\t\tCover(y,ci);\n\t\t\tMerge(x,y,x);\n\t\t\tMerge(x,z,rt);\n\t\t}\n\t\telse if(opt[0]=='R'){\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,x,y,pos-1);\n\t\t\tSplit(y,y,z,tot);\n\t\t\tReverse(y);\n\t\t\tMerge(x,y,y);\n\t\t\tMerge(y,z,rt);\n\t\t}\n\t\telse if(opt[0]=='G'){\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,x,y,pos-1);\n\t\t\tSplit(y,y,z,tot);\n\t\t\tprintf(\"%d\\n\",T[y].sum);\n\t\t\tMerge(x,y,y);\n\t\t\tMerge(y,z,rt);\n\t\t}\n\t\telse if(opt[0]=='M'&&opt[2]=='X'){\n\t\t\tprintf(\"%d\\n\",T[rt].maxzd);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```\n",
        "postTime": 1564103069,
        "uid": 58567,
        "name": "x\u4e49x",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "## FHQ treap \u8be6\u7ec6\u505a\u6cd5\n\u5c3d\u7ba1\u9898\u89e3\u5de8\u591a\uff0c`FHQ treap`\u5374\u5e76\u6ca1\u6709\u591a\u5c11\u4eba\u7528\uff0c\u6240\u4ee5\u8fd8\u662f\u53ef\u4ee5\u5199\u9898\u89e3\u7684\u3002\n\n\u5728\u9605\u8bfb\u672c\u6587\u4e4b\u524d\uff0c\u4f60\u5e94\u8be5\u5b66\u8fc7`FHQ treap`\uff0c\u4f1a\u6253`split`\u548c`merge`\u51fd\u6570\n```cpp\n#define i0 a[i].L//\u5de6\u5b50\u6811\n#define i1 a[i].R//\u53f3\u5b50\u6811\nstruct Node\n{\n\tint L, R, se, z, f0, f, size;\n\tint sum, max, max0, max1;\n}a[MAX];\n\nvoid split(int i, int &x, int &y, int k)\n{\n\tif (!i)\n\t{\n\t\tx = y = 0;\n\t\treturn;\n\t}\n\tpushtag(i);\n\tif (a[i0].size < k)\n\t\tx = i, split(i1, i1, y, k-a[i0].size-1);\n\telse\n\t\ty = i, split(i0, x, i0, k);\n\tupdate(i);\n}\n\nint merge(int x, int y)\n{\n\tif (!x || !y) return x + y;\n\tif (a[x].se < a[y].se)\n\t{\n\t\tpushtag(x);\n\t\ta[x].R = merge(a[x].R, y);\n\t\treturn update(x), x;\n\t}\n\tpushtag(y);\n\ta[y].L = merge(x, a[y].L);\n\treturn update(y), y;\n}\n```\n\n### 1. \u5e73\u8861\u6811\u8fdb\u884c\u533a\u95f4\u64cd\u4f5c\u7684\u672c\u8d28\u3002\n\u5728\u505a\u5e73\u8861\u6811\u6a21\u677f\u65f6\uff0c\u53ea\u6d89\u53ca\u5230\u4e86\u201c\u63d2\u5165\u6570\u201d\u548c\u201c\u5220\u9664\u6570\u201d\uff0c\u5e76\u6ca1\u6709\u5177\u4f53\u7684\u5e8f\u5217\uff08\u9664\u975e\u4f60\u7528\u6570\u7ec4\u505a\uff09\u3002\n\n\u800c\u8fdb\u884c\u533a\u95f4\u64cd\u4f5c\u65f6\uff0c\u533a\u95f4\u7684\u4e0b\u6807\u6ee1\u8db3`BST`\u6027\u8d28\uff0c\u6574\u68f5\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u76f4\u63a5\u6784\u6210\u8fd9\u4e2a\u5e8f\u5217\uff0c\u5e8f\u5217\u7684\u6743\u503c\u5b58\u5728\u70b9\u91cc\uff0c\u800c\u8282\u70b9\u672c\u8eab\u7684\u7f16\u53f7\u4ec0\u4e48\u4e5f\u4e0d\u4ee3\u8868\u3002\n\n\u6240\u4ee5\u5bf9\u533a\u95f4`[pos, pos+len-1]`\u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u53ea\u9700\u8981`split`\u4e24\u6b21\uff0c\u5c06`treap`\u88c2\u4e3a\u4e09\u6bb5\uff0c\u5e76\u5bf9\u4e2d\u95f4\u4e00\u6bb5\u8fdb\u884c\u64cd\u4f5c\uff0c\u7136\u540e\u518d`merge`\u5373\u53ef\u3002\n```cpp\nsplit(root, x, y, pos);//\u5c06\u6574\u68f5\u6811\u7684\u524dpos\u7ed9x\nsplit(y, y, z, len-1)//\u5c06\u540e\u534a\u6bb5\u7684\u524dlen-1\u7ed9y\uff0c\u5269\u4e0b\u7684\u662fz\n//\u5bf9y\u8fdb\u884c\u64cd\u4f5c\nroot = merge(merge(x, y), z)//\u5c06\u4e09\u6bb5\u5408\u5e76\n```\n### 2. \u5185\u5b58\u95ee\u9898\n\u672c\u9898\u64cd\u4f5c\u6570\u4e3a4e6\uff0c\u5982\u679c\u5f00`4e6`\u7684\u6570\u7ec4\uff0c\u7531\u4e8e\u6bcf\u4e2a\u8282\u70b9\u4fe1\u606f\u5f88\u591a\uff0c\u4f1a`MLE`\u3002\n\n\u4f46\u662f\u5e8f\u5217\u91cc\u6700\u591a\u53ea\u6709`5e5`\u4e2a\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u5220\u9664\u65f6\u5c06\u5220\u6389\u7684\u8282\u70b9\u5b58\u50a8\u4e0b\u6765\uff08\u653e\u8fdb\u6808\u91cc\uff09\uff0c\u518d\u521b\u5efa\u65b0\u8282\u70b9\u65f6\uff0c\u5982\u679c\u6808\u4e2d\u6709\u6570\u5c31\u518d\u7528\u4e00\u6b21\u8fd9\u4e2a\u6570\uff0c\u53ef\u4ee5\u7701\u4e0b\u5185\u5b58\u3002\u6ce8\u610f\u5148\u5c06\u8282\u70b9\u6e05\u7a7a\u3002\n```cpp\nint top, S[MAX];\nint New(int z)\n{\n    int id = top ? S[top--] : ++nc;//\u53d6\u6808\u4e2d\u8282\u70b9\n    memset(a+id, 0, sizeof(Node));\n    a[id].sum = a[id].z = a[id].max = z;\n    a[id].max0 = a[id].max1 = max(0, z);//max\u53ef\u4ee5\u53c2\u89c1\u540e\u6587\n    a[id].size = 1, a[id].se = rand();\n    return id;\n    \n}\n```\n### 3. \u63d2\u5165\u6570\n\u9996\u5148\uff0c\u65e0\u8bba\u662f\u521d\u59cb\u5316\u8fd8\u662f\u4e2d\u9014\u7684`INSERT`\u90fd\u662f\u4e00\u6b21\u63d2\u5165\u591a\u4e2a\u6570\uff0c\u6211\u4eec\u77e5\u9053\u63d2\u5165\u4e00\u4e2a\u6570\u662f\u9700\u8981`split`\u4e00\u6b21\uff0c`merge`\u4e00\u6b21\u7684\uff0c\u5982\u679c\u4e00\u4e2a\u4e00\u4e2a\u63d2\u5165\u5c06\u4f1a\u5f88\u6d6a\u8d39\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5728`pos`\u5904\u76f4\u63a5\u65ad\u5f00\uff0c\u7136\u540e\u5728\u524d\u4e00\u534a\u6dfb\u52a0\u4e00\u4e2a\u5305\u542b\u6240\u6709\u5f85\u6dfb\u52a0\u6570\u7684\u65b0`treap`\uff0c\u518d\u628a\u4e24\u6bb5\u5408\u5e76\u3002\u8fd9\u6837\u5c31\u53ea\u7528`split`\u4e00\u6b21\u3002\n\n\u5982\u4f55\u7528\u6570\u5217\u6784\u9020\u65b0`treap`\u5462\uff1f\u53ef\u4ee5\u6298\u534a\u9012\u5f52\uff0c\u5206\u522b\u7533\u8bf7\u65b0\u8282\u70b9\uff0c\u518d\u5f80\u4e0a\u5408\u5e76\uff0c\u8fd9`merge`\u53ea\u7528\u6267\u884c`log`\u7ea7\u522b\u7684\u6b21\u6570\u3002\n```cpp\nint add(int L, int R)\n{\n    if (L != R)\n    {\n        int mid = (L + R) >> 1;\n        return merge(add(L,mid), add(mid+1,R));\n    }return New(t[L]);\n}\n\nfor (int i = 1; i <= N; i++)//Init\n    scanf(\"%d\", &t[i]);\nroot = merge(root, add(1, N));\n\nif (op[2] == 'S')//Insert\n{\n    split(root, x, y, pos);\n    for (int i = 1; i <= len; i++)\n        scanf(\"%d\", &t[i]);\n    root = merge(merge(x, add(1, len)), y);\n}\n```\n### 4. \u5220\u9664\u6570\n\u5f88\u7b80\u5355\uff0c\u6309\u7167**1**\u91cc\u7684\u4ee3\u7801\u5c06`treap`\u62c6\u89e3\u4e3a3\u6bb5\uff0c\u5c06\u4e2d\u95f4\u4e00\u6bb5\u5220\u9664\u5373\u53ef\u3002\n\n\u7531\u4e8e\u8981\u5c06\u5220\u6389\u7684\u6570\u4e0d\u53ef\u80fd\u518d\u7528\u5230\uff0c\u8981\u7acb\u5373\u5b58\u5165\u56de\u6536\u7ad9\u4ee5\u4f9b\u4f7f\u7528\uff0c\u6ca1\u6709\u5fc5\u8981\u4f7f\u7528\u61d2\u6807\u8bb0\uff0c\u76f4\u63a5\u9012\u5f52\u5220\u9664\u5373\u53ef\u3002\n```cpp\nvoid rmv(int i)\n{\n    S[++top] = i;\n    if (i0) rmv(i0);\n    if (i1) rmv(i1);\n}\nif (op[2] == 'L')//Delete\n{\n    split(root, x, y, pos-1), split(y, y, z, len);\n    rmv(y)\uff0c root = merge(x, z);\n}\n```\n### 5. \u533a\u95f4\u63a8\u5e73\n\n\u628a\u8981\u63a8\u5e73\u7684\u533a\u95f4\u62ff\u51fa\u6765\uff0c\u53d6\u7b2c\u4e00\u4e2a\u70b9\u6253\u4e0a\u61d2\u6807\u8bb0\u3002\u61d2\u6807\u8bb0\u4e0e\u7ebf\u6bb5\u6811\u7684\u76f8\u540c\uff08\u5373\u8981\u5148\u66f4\u65b0\u81ea\u5df1\uff0c\u518d\u6253\u6807\u8bb0\uff09\u3002\n```cpp\nvoid cover(int i, int c)\n{\n\ta[i].z =  c;//\u66f4\u65b0\u81ea\u5df1\u7684\u6743\u503c\n\ta[i].sum = a[i].size * c;//\u66f4\u65b0\u533a\u95f4\u548c\n\ta[i].max0 = a[i].max1 = max(0, a[i].sum);\n\ta[i].max = max(c, a[i].sum);//max\u53ef\u53c2\u89c1\u540e\u6587\n\ta[i].f0 = 1;//\u61d2\u6807\u8bb0\n}\nif (op[2] == 'K')//Make_Same\n{\n    scanf(\"%d\", &c);\n    split(root, x, y, pos-1), split(y, y, z, len);\n    cover(y, c);\n    root = merge(merge(x, y), z);\n}\n```\n### 6. \u7ffb\u8f6c\n\n\u540c\u4e0a\uff0c\u8981\u6253\u61d2\u6807\u8bb0\u3002\u4f46\u662f\u61d2\u6807\u8bb0\u53ef\u4ee5\u5199\u4f5c`f ^= 1`\u3002\u8fd9\u662f\u56e0\u4e3a\u7ffb\u8f6c\u4e24\u6b21\u5c31\u76f8\u5f53\u4e8e\u6ca1\u6709\u7ffb\u8f6c\uff0c\u6240\u4ee5`f = 1`\u65f6\u5728\u6253\u6807\u8bb0\u5c31\u662f0\u3002\n```cpp\nvoid reverse(int i)\n{\n\tswap(i0, i1), swap(a[i].max0, a[i].max1);//max\u53c2\u89c1\u540e\u6587\n\ta[i].f ^= 1;\n}\n\nif (op[2] == 'V')//Reverse\n{\n    split(root, x, y, pos-1), split(y, y, z, len);\n    reverse(y);\n    root = merge(merge(x, y), z);\n}\n```\n### 7. \u61d2\u6807\u8bb0\u4e0b\u63a8\n\u63a8\u5e73\u548c\u7ffb\u8f6c\u7684\u6807\u8bb0\u90fd\u8981\u63a8\uff0c\u5148\u540e\u987a\u5e8f\u6ca1\u5173\u7cfb\u3002\u6e05\u695a\u6807\u8bb0\uff0c\u5e76\u5c06\u5de6\u53f3\u8282\u70b9\u8c03\u7528`reverse/cover`\u5373\u53ef\uff0c\u5de6\u53f3\u5b50\u6811`cover`\u7684\u503c\u663e\u7136\u5e94\u8be5\u662f\u672c\u8282\u70b9\u7684\u6743\u503c\u3002\n```cpp\nvoid pushtag(int i)\n{\n    if (!i) return;\n    if (a[i].f)\n    {\n        if (i0) reverse(i0);\n        if (i1) reverse(i1);\n        a[i].f = 0;\n    }\n    if (a[i].f0)\n    {\n        if (i0) cover(i0, a[i].z);\n        if (i1) cover(i1, a[i].z);\n        a[i].f0 = 0;\n    }\n}\n```\n### 8. \u67e5\u8be2\u533a\u95f4\u548c\n\n\u4e2d\u7b49\u7b80\u5355\u3002`a[i].sum`\u4ee3\u8868\u81ea\u5df1\u548c\u81ea\u5df1\u5b50\u6811\u6784\u6210\u533a\u95f4\u7684\u6743\u503c\u603b\u548c\u3002\n\n\u6bcf\u4e2a\u70b9\u5728\u521b\u5efa\u65f6\u7684`sum`\u663e\u7136\u5e94\u8d4b\u503c\u4e3a\u81ea\u5df1\u7684\u6743\u503c\u3002\uff08\u53c2\u89c1\u524d\u6587`New()`\uff09\n\n\u800c`update`\u65f6\u663e\u7136\u6709`a[i].sum = a[i0].sum + a[i1].sum + a[i].z`\u3002\uff08\u53c2\u89c1\u540e\u6587\uff09\n\n\u5c06\u7ed9\u5b9a\u533a\u95f4\u62c6\u89e3\u8f93\u51fa\u5373\u53ef\u3002\n\n```cpp\nif (op[2] == 'T')//GET_SUM\n{\n    split(root, x, y, pos-1), split(y, y, z, len);\n    printf(\"%d\\n\", a[y].sum);\n    root = merge(merge(x, y), z);\n}\n```\n\n### 9. \u67e5\u8be2\u6700\u5927\u5b50\u6bb5\u548c\n\n\u6700\u96be\u6700\u9ebb\u70e6\u3002\u672c\u9898\u7684\u5b50\u6bb5\u548c\u81f3\u5c11\u9009\u4e00\u4e2a\u6570\u3002\n\n\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u53ca\u5176\u5b50\u6811\u6784\u6210\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c`max0`\uff0c\u6700\u5927\u540e\u7f00\u548c`max1`\u548c\u6700\u5927\u5b50\u6bb5\u548c`max`\u3002\n\n\u663e\u7136\u6bcf\u4e2a\u70b9\u5728\u521b\u5efa\u65f6\u8fd9\u4e9b\u90fd\u5e94\u8d4b\u503c\u4e3a\u81ea\u5df1\u7684\u6743\u503c\uff08\u53c2\u89c1\u524d\u6587`New()`\uff09\n\n`update`\u65f6\uff0c\u4e00\u6bb5`[L,R]`\u6700\u5927\u524d\u7f00\u548c\u53ef\u4ee5\u6709\u201c\u7ec8\u70b9\u5728`mid`\u5de6\u7aef\uff08`a[i0].max0`\uff09\u201d\u548c\u201c\u7ec8\u70b9\u5728`mid`\u53f3\uff08`a[i0].sum + a[i].z + a[i1].max0`\uff09`\u201d\u4e24\u79cd\u60c5\u51b5\uff0c\u53d6\u6700\u5927\u503c\u5373\u53ef\u3002\n\n\u6700\u5c0f\u540e\u7f00\u548c\u540c\u7406\uff0c\u6709`a[i].max1 = max(a[i1].max1, a[i1].sum + a[i].z + a[i0].max1`\n\n\u800c\u6700\u5927\u5b50\u6bb5\u548c`max`\u5c31\u662f\u5de6\u7aef\u548c\u6700\u5927\u540e\u7f00\u548c\u4e0e\u53f3\u7aef\u7684\u6700\u5927\u524d\u7f00\u548c\u4e4b\u548c\u3002\u6216\u8005\u4e0d\u7ecf\u8fc7`i`\u70b9\uff0c\u53d6\u4e24\u8fb9\u7684`max`\u503c\n```cpp\na[i].max = a[i0].max1 + a[i1].max0 + a[i].z;\na[i].max = max(a[i].max, max(a[i0].max, a[i1].max));\n```\n\n\u7ffb\u8f6c\u533a\u95f4\u65f6\uff0c\u663e\u7136\u540e\u7f00\u548c\uff0c\u524d\u7f00\u548c\u53cd\u4e86\uff0c\u6240\u4ee5\u8981`swap(a[i].max0, a[i].max1)`\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7531\u4e8e\u4e0d\u80fd\u6709\u7a7a\u6bb5\uff0c\u6240\u4ee5`max`\u8d4b\u503c\u65f6\u4e0d\u80fd\u4e0e0\u53d6\u6700\u5927\uff0c\u4f46\u662f\u5f53\u62fc\u63a5`a[i].max`\u65f6\uff0c\u6211\u4eec\u53d1\u73b0`i`\u81ea\u5df1\u7684\u6743\u503c\u662f\u5fc5\u9009\u7684\uff0c\u5373\u4f7f`max0`\uff0c`max1`\u4e3a\u7a7a\uff0c\u6574\u4e2a\u5e8f\u5217\u4e5f\u662f\u6709\u4e00\u4e2a`i`\u70b9\u7684\u3002\u56e0\u6b64\u53ef\u4ee5\u8ba9`max0`\uff0c`max1`\u8ba1\u7b97\u65f6\u4e0e0\u53d6\u6700\u5927\uff08\u5373\u4ec0\u4e48\u90fd\u4e0d\u9009\uff09\u3002\n\n\u6709\u4e86**8\uff0c9**\u4e24\u70b9\uff0c`update`\u51fd\u6570\u4e0d\u96be\u5199\u51fa\uff1a\n```cpp\nvoid update(int i)\n{\n\tif (!i) return;\n\ta[i].size = a[i0].size + a[i1].size + 1;\n\ta[i].sum = a[i0].sum + a[i1].sum + a[i].z;\n\ta[i].max0 = max(max(a[i0].max0, a[i0].sum + a[i].z + a[i1].max0), 0);\n\ta[i].max1 = max(max(a[i1].max1, a[i1].sum + a[i].z + a[i0].max1), 0);\n\ta[i].max = max(a[i0].max1 + a[i1].max0, 0) + a[i].z;\n\tif (i0) a[i].max = max(a[i].max, a[i0].max);\n\tif (i1) a[i].max = max(a[i].max, a[i1].max);\n}\n\nelse printf(\"%d\\n\", a[root].max);//MAX-SUM\n```\n\u81f3\u6b64\u95ee\u9898\u5df2\u7ecf\u5168\u90e8\u89e3\u51b3\u3002\n\n\u8c22\u8c22\u89c2\u770b\uff0c\u5b8c\u7ed3\u6492\u82b1\u3002",
        "postTime": 1570286289,
        "uid": 73489,
        "name": "NyaRu_Official",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u770b\u4e86\u4e00\u4e0b\u9898\u89e3\uff0c\u90fd\u662f\u6253\u4e24\u4e2atag\u7684\u3002\u7136\u800c\u7531\u4e8e\u6211\u592a\u83dc\u4e86\uff0c\u5b9e\u5728\u4e0d\u4f1a\uff0c\u6240\u4ee5\u6b64\u5904\u7ed9\u51fa\u4e00\u79cd\u53ea\u9700\u8981\u6253\u7ffb\u8f6c\u4e00\u4e2atag\u7684\u505a\u6cd5\u3002\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u4e0d\u7528tag\u600e\u4e48\u63a8\u5e73\u3002\u63a8\u5e73\u5b9e\u9645\u4e0a\u5c31\u662f\u628a\u4e00\u6bb5\u6570\u5220\u6389\u518d\u63d2\u5165\u4e00\u5927\u6bb5\u76f8\u540c\u7684\u6570\u3002\u7136\u800c\u6734\u7d20\u7684\u505a\u6cd5\u80af\u5b9a\u662f\u4f1aT\u98de\u7684\u3002\n\n\u5148\u6765\u770b\u5220\u9664\u3002\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u5783\u573e\u6876\uff0c\u6bcf\u6b21\u5220\u9664\u4e00\u4e2a\u5b50\u6811\uff0c\u5c31\u628a\u8fd9\u68f5\u5b50\u6811\u7684**\u6839\u8282\u70b9**\u653e\u5165\u5783\u573e\u6876\u3002\u9700\u8981\u65b0\u5efa\u8282\u70b9\u65f6\uff0c\u53d6\u51fa\u5783\u573e\u6876\u91cc\u7684\u4e00\u68f5\u5b50\u6811\u7684\u6839\u8282\u70b9\uff0c**\u7136\u540e\u628a\u8fd9\u4e2a\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u653e\u56de\u5783\u573e\u6876**\u3002\u8fd9\u6837\u6bcf\u6b21\u590d\u6742\u5ea6\u5c31\u53d8\u6210\u4e86O(1)\u7684\u3002\n\n\u518d\u770b\u63d2\u5165\u3002\u6211\u4eec\u91c7\u53d6\u4e00\u79cd\u7c7b\u4f3c\u4e8e\u73c2\u6735\u8389\u6811\u7684\u65b9\u6cd5\uff0c\u6bcf\u4e2a\u8282\u70b9\u5b58\u50a8\u4e00\u6bb5\u533a\u95f4\u3002\u7136\u540e\u8fd9\u6837\u5728Split\u7684\u65f6\u5019\u5c31\u8981\u6539\u4e00\u4e0b\uff1a\n\n```cpp\nIL void Split_(RG int root,RG int k,RG int &a,RG int &b){\n\tPushdown(root); a=Create(k,M[root].val); b=Create(M[root].len-k,M[root].val);\n\tM[a].ls=LS; M[b].rs=RS; LS=RS=0;\n\tDelete(root); Update(a); Update(b);\n}\nstatic void Split(RG int root,RG int k,RG int &a,RG int &b){\n\tif(!root) a=b=0;\n\telse{\n\t\tPushdown(root);\n\t\tif(M[LS].sz>=k) b=root, Split(M[root].ls,k,a,M[root].ls);\n\t\telse if(M[LS].sz+M[root].len>k) Split_(root,k-M[LS].sz,a,b);\n\t\telse a=root, Split(M[root].rs,k-M[LS].sz-M[root].len,M[root].rs,b);\n\t\tUpdate(a); Update(b);\n\t}\n}\n\n```\n\n\u5176\u4e2dSplit_\u662f\u628a\u4e00\u6bb5\u76f8\u540c\u7684\u533a\u95f4\u88c2\u6210\u4e24\u7aef\u3002\n\n\u5728Split\u4e2d\uff0c\u8981\u5224\u65ad\u5206\u88c2\u7684\u5730\u65b9\u5728\u5f53\u524d\u8282\u70b9\u7684\u5de6\u5b50\u6811\u3001\u53f3\u5b50\u6811**\u6216\u5b83\u81ea\u5df1\u7684\u533a\u95f4**\u91cc\u3002\n\n\u7136\u540e\u63a8\u5e73\u5c31\u505a\u5b8c\u4e86\u3002\u770b\u4e00\u4e0b\u4ee3\u7801\uff1a\n\n```cpp\npos=Read(), tot=Read(); int num=Read();\nSplit(root,pos-1,a,b), Split(b,tot,b,c);\nDelete(b); b=Create(tot,num);\nroot=Merge(a,Merge(b,c));\n```\n\n\u5176\u4f59\u7684\u5730\u65b9\uff0c\u5c31\u548c\u666e\u901a\u7684\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\u4e86\u3002\u4e00\u4e2a\u8282\u70b9\u7ef4\u62a4\u524d\u7f00\u3001\u540e\u7f00\u548c\u4e2d\u95f4\u7684\u6700\u5927\u503c\uff0c\u7ffb\u8f6c\u7684\u65f6\u5019Split\u5f00\u6253\u4e0atag\u5373\u53ef\u3002\n\n\u7136\u540e\uff0c\u5c31\u6ca1\u6709\u7136\u540e\u4e86\u3002\n\n\u4e0a\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define MAXN 4000001\n#define LS M[root].ls\n#define RS M[root].rs\n#define IL inline\n#define RG register\nIL int Read(){\n\tRG int ret=0,fl=1; RG char ch=getchar();\n\twhile(ch<'0' || ch>'9') fl=((ch=='-')?-1:fl), ch=getchar();\n\twhile(ch>='0' && ch<='9') ret=ret*10+ch-'0', ch=getchar();\n\treturn ret*fl;\n}\nstruct FHQ{ int ls,rs,sz,len,val,sum,mx,ml,mr; bool flag; };\nstatic FHQ M[MAXN];\nIL void Reverse(RG int root){ std::swap(LS,RS); std::swap(M[root].ml,M[root].mr); }\nIL void Pushdown(RG int root){\n\tif(M[root].flag){\n\t\tM[root].flag=false;\n\t\tif(LS) M[LS].flag^=true, Reverse(LS);\n\t\tif(RS) M[RS].flag^=true, Reverse(RS);\n\t}\n}\nIL void Update(RG int root){\n\tM[root].sz=M[LS].sz+M[RS].sz+M[root].len;\n\tRG int V=M[root].val*M[root].len;\n\tM[root].sum=M[LS].sum+M[RS].sum+V;\n\tM[root].ml=std::max(std::max(M[LS].ml,M[LS].sum+V+M[RS].ml),0);\n\tM[root].mr=std::max(std::max(M[RS].mr,M[RS].sum+V+M[LS].mr),0);\n\tM[root].mx=std::max(M[LS].mr+V+M[RS].ml,V);\n\tif(LS) M[root].mx=std::max(M[root].mx,M[LS].mx);\n\tif(RS) M[root].mx=std::max(M[root].mx,M[RS].mx);\n\tM[root].mx=std::max(M[root].mx,M[root].val);\n}\nstatic int stack[MAXN],top,cnt;\nIL int Create(RG int len,RG int val){\n\tRG int root;\n\tif(top){ root=stack[top--]; if(LS) stack[++top]=LS; if(RS) stack[++top]=RS; }\n\telse root=++cnt;\n\tLS=RS=0; M[root].flag=false;\n\tM[root].len=M[root].sz=len; M[root].val=M[root].mx=val; M[root].sum=val*len;\n\tM[root].ml=M[root].mr=0;\n\tUpdate(root);\n\treturn root;\n}\nIL void Delete(RG int root){ stack[++top]=root; }\nstatic int Merge(RG int a,RG int b){\n\tPushdown(a); Pushdown(b);\n\tif(!a || !b) return a|b;\n\tif((M[a].sum+M[b].sum)&1){ M[a].rs=Merge(M[a].rs,b); Update(a); return a; }\n\telse{ M[b].ls=Merge(a,M[b].ls); Update(b); return b; }\n}\nIL void Split_(RG int root,RG int k,RG int &a,RG int &b){\n\tPushdown(root); a=Create(k,M[root].val); b=Create(M[root].len-k,M[root].val);\n\tM[a].ls=LS; M[b].rs=RS; LS=RS=0;\n\tDelete(root); Update(a); Update(b);\n}\nstatic void Split(RG int root,RG int k,RG int &a,RG int &b){\n\tif(!root) a=b=0;\n\telse{\n\t\tPushdown(root);\n\t\tif(M[LS].sz>=k) b=root, Split(M[root].ls,k,a,M[root].ls);\n\t\telse if(M[LS].sz+M[root].len>k) Split_(root,k-M[LS].sz,a,b);\n\t\telse a=root, Split(M[root].rs,k-M[LS].sz-M[root].len,M[root].rs,b);\n\t\tUpdate(a); Update(b);\n\t}\n}\nstatic int Build(RG int l,RG int r,RG int *a){\n\tif(l>r) return 0;\n\tRG int m=l+r>>1, root=Create(1,a[m]);\n\tLS=Build(l,m-1,a); RS=Build(m+1,r,a);\n\tUpdate(root);\n\treturn root;\n}\nstatic int S[MAXN],root;\nint main(){\n\tint n=Read(),m=Read();\n\tfor(RG int i=1;i<=n;i++) S[i]=Read();\n\troot=Build(1,n,S);\n\tchar s[12];\n\twhile(m--){\n\t\tRG int pos,tot,a,b,c; scanf(\"%s\",s);\n\t\tif(s[0]=='I'){\n\t\t\tpos=Read(), tot=Read();\n\t\t\tfor(RG int i=1;i<=tot;i++) scanf(\"%d\",&S[i]);\n\t\t\tc=Build(1,tot,S);\n\t\t\tSplit(root,pos,a,b);\n\t\t\troot=Merge(a,Merge(c,b));\n\t\t}else if(s[0]=='D'){\n\t\t\tpos=Read(), tot=Read();\n\t\t\tSplit(root,pos-1,a,b), Split(b,tot,b,c);\n\t\t\troot=Merge(a,c), Delete(b);\n\t\t}else if(s[0]=='M' && s[3]=='E'){\n\t\t\tpos=Read(), tot=Read(); int num=Read();\n\t\t\tSplit(root,pos-1,a,b), Split(b,tot,b,c);\n\t\t\tDelete(b); b=Create(tot,num);\n\t\t\troot=Merge(a,Merge(b,c));\n\t\t}else if(s[0]=='M' && s[3]=='-'){\n\t\t\tprintf(\"%d\\n\",M[root].mx);\n\t\t}else if(s[0]=='R'){\n\t\t\tpos=Read(), tot=Read();\n\t\t\tSplit(root,pos-1,a,b), Split(b,tot,b,c);\n\t\t\tM[b].flag^=true; Reverse(b);\n\t\t\troot=Merge(a,Merge(b,c));\n\t\t}else if(s[0]=='G'){\n\t\t\tpos=Read(), tot=Read();\n\t\t\tSplit(root,pos-1,a,b), Split(b,tot,b,c);\n\t\t\tprintf(\"%d\\n\",M[b].sum); root=Merge(a,Merge(b,c));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1570185379,
        "uid": 52024,
        "name": "\u9648\u741b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.org/problemnew/show/P2042)\n\n## \u9898\u610f\n\n\u7ef4\u62a4\u4e00\u4e2a\u5e8f\u5217\uff0c\u652f\u6301\u63d2\u5165\u5e8f\u5217\u3001\u533a\u95f4\u5220\u9664\u3001\u533a\u95f4\u8986\u76d6\u3001\u533a\u95f4\u7ffb\u8f6c\u3001\u533a\u95f4\u6c42\u548c\u3001\u6c42\u5e8f\u5217\u6700\u5927\u5b50\u6bb5\u548c\uff08\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20\uff09\u3002\n\n\u63d2\u5165\u603b\u6570$\\le 4\\times 10^6$\uff0c\u4efb\u610f\u65f6\u523b\u5e8f\u5217\u957f\u5ea6$\\le 5\\times 10^5$\u3002\n\n## \u9898\u89e3\n\n$Splay$\u677f\u5b50\u9898\u3002\n\n\u4e0d\u4f1a$Splay$\u7684\u540c\u5b66\u51fa\u95e8\u5de6\u8f6c[\u6587\u827a\u5e73\u8861\u6811](https://www.luogu.org/problemnew/show/P3391)\u3002\n\n\u7531\u4e8e\u63d2\u5165\u6570\u91cf\u592a\u5927\uff0c\u76f4\u63a5\u5f004000000\u7684\u6570\u7ec4\u663e\u5f97\u4e0d\u663e\u793a\uff0c\u6211\u4eec\u8003\u8651\u5efa\u7acb\u56de\u6536\u6808\uff08\u96fe\uff09\uff0c\u5220\u9664\u65f6\u904d\u5386\u5b50\u6811\uff0c\u56de\u6536\u88ab\u5220\u9664\u7684\u8282\u70b9\uff0c\u65b0\u5efa\u8282\u70b9\u65f6\u4f18\u5148\u4ece\u56de\u6536\u6808\u91cc\u53d6\u70b9\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u5404\u4e2a\u6570\u7ec4\u90fd\u8981\u521d\u59cb\u5316\u3002\n\n\u603b\u4f53\u601d\u8def\u662f\uff0c\u5bf9\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\uff1a$val,sz,sum,la,ra,ma$\uff0c\u5206\u522b\u8868\u793a\u8fd9\u4e2a\u70b9\u672c\u8eab\u7684\u503c\u3001\u5b50\u6811\u5927\u5c0f\u3001\u5b50\u6811\u7684$val$\u4e4b\u548c\u3001\u8be5\u533a\u95f4\uff08\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u6240\u8868\u793a\u7684\u533a\u95f4\uff0c\u4e0b\u540c\uff09\u4e2d\u5305\u542b\u6700\u5de6\u8fb9\u5143\u7d20\u7684\u6700\u957f\u5b50\u6bb5\u548c\uff08**\u53ef\u4ee5\u4e0d\u5305\u542b\u5143\u7d20**\uff09\u3001\u5305\u542b\u6700\u53f3\u8fb9\u5143\u7d20\u7684\u6700\u957f\u5b50\u6bb5\u548c\uff08**\u53ef\u4ee5\u4e0d\u5305\u542b\u5143\u7d20**\uff09\u3001\u6574\u4e2a\u533a\u95f4\u7684\u6700\u5927\u5b50\u6bb5\u548c\uff08**\u81f3\u5c11\u5305\u542b\u4e00\u4e2a\u5143\u7d20**\uff0c\u5373\u7b54\u6848\uff09\uff1b\u61d2\u6807\u8bb0$cov=0/1,rev=0/1$\uff0c\u5206\u522b\u8868\u793a\u8be5\u533a\u95f4\u662f\u5426\u88ab\u8986\u76d6\u3001\u662f\u5426\u88ab\u7ffb\u8f6c\u3002\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u4ed4\u7ec6\u5206\u6790\u6bcf\u4e00\u6b65\u64cd\u4f5c\u3002\n\n### \u65b0\u5efa\u8282\u70b9\n\n\u5df2\u7ecf\u8bb2\u8fc7\uff0c\u82e5\u56de\u6536\u6808\u91cc\u6709\u70b9\uff0c\u5219\u4f18\u5148\u62ff\u6765\u7528\uff0c\u5426\u5219\u65b0\u5efa\u8282\u70b9\u3002\n\n```cpp\nint new_node(int _val){\n\tint x = top ? rb[top--] : ++cnt; // rb\u5373\u56de\u6536\u6808\n\tson[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1; // \u6ce8\u610f\u522b\u5fd8\u8bb0\u521d\u59cb\u5316\n\tval[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0); // la,ra\u53ef\u4ee5\u4e0d\u5305\u542b\u5143\u7d20\n\treturn x;\n}\n```\n\n### \u4e0a\u4f20\n\n\u4e3b\u8981\u662f$la,ra,ma$\u7684\u66f4\u65b0\u3002$la$\u548c$ra$\u540c\u7406\uff0c\u4ee5$la$\u4e3a\u4f8b\uff0c\u5f53\u524d\u8282\u70b9\u7684$la$\u503c\u5c31\u662f`max(\u5de6\u5b50\u6811\u7684la,\u5de6\u5b50\u6811\u7684sum+\u5f53\u524d\u8282\u70b9\u7684val+\u53f3\u5b50\u6811\u7684la)`\uff0c\u5206\u522b\u8868\u793a\u8de8\u8fc7\u5f53\u524d\u8282\u70b9\u548c\u4e0d\u8de8\u8fc7\u5f53\u524d\u8282\u70b9\u4e24\u79cd\u60c5\u51b5\u3002\u5bf9\u4e8e$ma$\uff0c\u4e5f\u5dee\u4e0d\u591a\uff0c\u4e0d\u8de8\u8fc7\u7684\u60c5\u51b5\u662f`max(\u5de6\u5b50\u6811\u7684ma,\u53f3\u5b50\u6811\u7684ma)`\uff0c\u8de8\u8fc7\u7684\u60c5\u51b5\u662f`\u5de6\u5b50\u6811\u7684ra+\u5f53\u524d\u8282\u70b9\u7684val+\u53f3\u5b50\u6811\u7684la`\uff0c\u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e2d\u518d\u53d6\u4e2a$max$\u5373\u53ef\u3002\n\n```cpp\nvoid up(int u){\n\tint ls = son[u][0], rs = son[u][1];\n\tsz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u];\n\tla[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]);\n\tra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]);\n\tma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);\n}\n```\n\n### \u4e0b\u4f20\u61d2\u6807\u8bb0\n\n\u6bd4\u8f83\u7b80\u5355\uff0c\u4e0d\u9700\u8981\u8003\u8651\u6807\u8bb0\u4e0b\u4f20\u7684\u987a\u5e8f\u3002\n\n\u5bf9\u4e8e$cov$\u6807\u8bb0\uff0c\u76f4\u63a5\u628a\u5de6\u53f3\u513f\u5b50\u7684$val$\u8bbe\u4e3a\u5f53\u524d\u8282\u70b9\u7684$val$\uff0c$sum$\u8bbe\u4e3a$val\\times sz$\u3002\u800c$la,ra,ma$\u5219\u9700\u8981\u5206\u7c7b\u8ba8\u8bba\uff0c\u82e5$val>0$\uff0c\u663e\u7136\u76f4\u63a5\u628a\u6574\u4e2a\u533a\u95f4\u9009\u4e0a\u66f4\u4f18\uff0c\u5426\u5219$la,ra$\u4e0d\u9009\uff0c$ma$\u53ea\u9009\u4e00\u4e2a\u70b9\u3002\n\n\u5bf9\u4e8e$rev$\u6807\u8bb0\uff0c\u76f4\u63a5\u4ea4\u6362**\u5de6\u53f3\u513f\u5b50**\u7684\u5de6\u53f3\u5b50\u6811\u3001**\u5de6\u53f3\u513f\u5b50**\u7684$la,ra$\uff08\u6ce8\u610f\u4e0d\u662f\u4ea4\u6362\u5f53\u524d\u8282\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u3001$la,ra$\uff0c\u8fd9\u79cd\u5199\u6cd5\u5728[\u6587\u827a\u5e73\u8861\u6811](https://www.luogu.org/problemnew/show/P3391)\u53ef\u4ee5\u8fc7\uff0c\u4f46\u662f\u5728\u672c\u9898\u4e2d\u4f1a\u51fa\u9519\uff09\u3002\n\n```cpp\nvoid down(int u){\n\tint ls = son[u][0], rs = son[u][1];\n\tif (cov[u]){\n\t\tif (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u];\n\t\tif (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u];\n\t\tif (val[u] > 0){ // \u5206\u7c7b\u8ba8\u8bba\n\t\t\tif (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];\n\t\t\tif (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];\n\t\t}\n\t\telse{\n\t\t\tif (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u];\n\t\t\tif (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u];\n\t\t}\n\t\tcov[u] = 0;\n\t}\n\tif (rev[u]){\n\t\tif (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]);\n\t\tif (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]);\n\t\t// \u4ea4\u6362\u5de6\u53f3\u513f\u5b50\u7684\u5de6\u53f3\u5b50\u6811\u548cla,ra\n\t\trev[u] = 0;\n\t}\n}\n```\n\n### \u5efa\u6811\n\n\u76f4\u63a5\u6309\u7167\u539f\u5e8f\u5217\u7684\u987a\u5e8f\u5efa\u6811\uff08\u6ce8\u610f\u4e0d\u662f\u6309\u6570\u7684\u5927\u5c0f\u5efa\u6811\uff09\u3002\n\n\u53ef\u662f\u76f4\u63a5\u63d2\u5165\u662f$\\mathcal O(n\\log n)$\u7684\uff0c\u4e14\u5e38\u6570\u8f83\u5927\u3002\u6211\u4eec\u76f4\u63a5\u53d6\u5e8f\u5217\u4e2d\u70b9\u4f5c\u4e3a\u6839\uff0c\u7136\u540e\u9012\u5f52\u8c03\u7528\u5de6\u8fb9\u548c\u53f3\u8fb9\uff0c\u5206\u522b\u4f5c\u4e3a\u6839\u7684\u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\u3002\n\n\u8fd9\u6837\u6211\u4eec\u53ef\u4ee5\u505a\u5230$\\mathcal O(n)$\u5efa\u6811\uff0c$n$\u662f\u5e8f\u5217\u957f\u5ea6\u3002\n\n```cpp\nint build(int l, int r, int *a){\n\tif (l > r) return 0;\n\tif (l == r) return new_node(a[l]);\n\tint mid = (l + r) >> 1, u = new_node(a[mid]);\n\t// \u4ee5mid\u4e3a\u8be5\u5b50\u6811\u7684\u6839\uff0c\u9012\u5f52\u5904\u7406\u5de6\u53f3\u4e24\u8fb9\n\tson[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a);\n\tfa[son[u][0]] = fa[son[u][1]] = u;\n\treturn up(u), u; // \u6ce8\u610f\u66f4\u65b0\n}\n```\n\n### Splay\u7684\u57fa\u672c\u64cd\u4f5c\uff1a$rotate(x)$\u548c$splay(x,g)$\n\n$rotate(x)$\u8868\u793a\u5c06$x$\u5411\u4e0a\u65cb\u8f6c\uff0c$splay(x,g)$\u8868\u793a\u5c06$x$\u65cb\u8f6c\u5230$g$\u7684\u513f\u5b50\u3002\n\n\u6ce8\u610f$rotate(x)$\u65f6\u9700\u8981\u4e0a\u4f20\u64cd\u4f5c\uff0c\u4e14\u8981\u6ce8\u610f\u64cd\u4f5c\u987a\u5e8f\u3002$splay(x,g)$\u9700\u8981\u53cc\u65cb\u3002\n\n```cpp\nint dir(int x){ return son[fa[x]][1] == x; } // \u8fd4\u56dex\u662f\u4ed6\u7236\u4eb2\u7684\u54ea\u4e2a\u513f\u5b50\nvoid set(int x, int k, int y){ son[x][k] = y, fa[y] = x; } // \u5c06x\u7684k\u513f\u5b50\u53d8\u6210y\nvoid rotate(int x){\n\tint y = fa[x], d = dir(x);\n\tset(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y);\n\tup(y), up(x); // \u6ce8\u610f\u4e0a\u4f20\u4ee5\u53ca\u4e0a\u4f20\u7684\u987a\u5e8f\n}\nvoid splay(int x, int g = 0){ // g=0\u76f8\u5f53\u4e8e\u65cb\u8f6c\u5230\u6839\u4e0a\n\twhile (fa[x] != g){\n\t\tint y = fa[x];\n\t\tif (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);\n\t\trotate(x); // \u53cc\u65cb\n\t}\n\tif (!g) rt = x; // \u66f4\u65b0rt\n}\n```\n\n### \u6c42\u5f53\u524d\u5e8f\u5217\u4e2d\u7b2c$k$\u4e2a\u4f4d\u7f6e\u5728Splay\u4e2d\u5bf9\u5e94\u7684\u8282\u70b9\n\n\u8fd9\u662f\u4e0b\u9762\u524d\u4e94\u4e2a\u64cd\u4f5c\u4e2d\u5fc5\u9700\u7684\u4e00\u4e2a\u64cd\u4f5c\uff0c\u5373\u628a\u5e8f\u5217\u4e2d\u7684\u4f4d\u7f6e\u8f6c\u5316\u4e3a\u6811\u4e0a\u7684\u8282\u70b9\u7f16\u53f7\u3002\n\n\u8fd9\u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u6c42\u7b2c$k$\u5c0f\u7684\u95ee\u9898\uff0c\u76f4\u63a5\u6309\u7167\u5de6\u5b50\u6811\u7684$sz$\u548c\u5f53\u524d\u7684$k$\u7684\u5927\u5c0f\u5173\u7cfb\u51b3\u5b9a\u5f80\u5de6\u3001\u5f80\u53f3\u8fd8\u662f\u76f4\u63a5\u8fd4\u56de\u5f53\u524d\u8282\u70b9\u3002\n\n\u6ce8\u610f\uff0c\u6b64\u65f6\u7531\u4e8e\u9700\u8981\u7528\u5230\u513f\u5b50\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u5fc5\u987b\u628a$u$\u7684\u6807\u8bb0\u4e0b\u4f20\u3002\n\n\u4e14\u56e0\u4e3a\u8fd9\u6837\u505a\u4f1a\u628a\u6839\u5230\u8981\u6c42\u7684\u90a3\u4e2a\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8282\u70b9\u90fd$down$\u4e00\u904d\uff0c\u6240\u4ee5\u5728\u5176\u4f59\u64cd\u4f5c\u4e2d\u4e0d\u9700\u8981\u518d\u8fdb\u884c$down$\u64cd\u4f5c\u3002\n\n```cpp\nint kth(int u, int k){\n\tdown(u); // \u4e0b\u4f20\u6807\u8bb0\n\tint ls = son[u][0], rs = son[u][1];\n\tif (k == sz[ls] + 1) return u; // \u76f4\u63a5\u8fd4\u56de\n\telse if (k <= sz[ls]) return kth(ls, k); // \u5411\u5de6\u8d70\n\telse return kth(rs, k - sz[ls] - 1); // \u5411\u53f3\u8d70\n}\n```\n\n### \u63d2\u5165\u64cd\u4f5c\n\n\u5bf9\u4e8e\u63d2\u5165\u64cd\u4f5c\uff0c\u6211\u4eec\u76f4\u63a5\u628a$pos$\u5bf9\u5e94\u7684\u8282\u70b9$splay$\u5230\u6839\u4e0a\uff08\u8bb0\u4e3a$u$\uff09\uff0c\u628a$pos+1$\u7684\u4f4d\u7f6e\u65cb\u8f6c\u5230\u6839\u4e0b\u9762\uff08\u8bb0\u4e3a$v$\uff0c\u5373\u6b64\u65f6$fa[v]=u$\uff09\u3002\u6b64\u65f6$v$\u7684\u5de6\u5b50\u6811\u4e00\u5b9a\u4e3a\u7a7a\uff08\u4e0d\u5b58\u5728\u4e00\u4e2a\u6574\u6570$x$\u6ee1\u8db3$pos<x<pos+1$\uff09\u3002\u90a3\u4e48\u76f4\u63a5\u628a\u9700\u8981\u63d2\u5165\u7684\u5e8f\u5217$\\mathcal O(n)$\u5efa\u6811\uff0c\u628a\u6839\u8282\u70b9\u8fde\u5230$v$\u4e0a\uff0c\u4f5c\u4e3a$v$\u7684\u5de6\u5b50\u6811\u5373\u53ef\u3002\n\n```cpp\nvoid insert(int x, int tot, int *a){\n\tint t = build(1, tot, a);\n\tint u = kth(rt, x); splay(u);\n\tint v = kth(rt, x + 1); splay(v, u);\n\tson[v][0] = t, fa[t] = v, up(v), up(u);\n\t// \u6ce8\u610f\u522b\u5fd8\u8bb0fa[t]=v\u548c\u4e0a\u4f20\u6807\u8bb0\uff0c\u4e0d\u8981\u4e60\u60ef\u6027\u6253\u6210up(u),up(v)\n}\n```\n\n### \u5220\u9664\u64cd\u4f5c\n\n\u5047\u8bbe\u6211\u4eec\u8981\u5220\u9664\u7684\u662f\u533a\u95f4$[l,r]$\uff0c\u90a3\u4e48\u540c\u7406\uff0c\u6211\u4eec\u628a$l-1$\u5bf9\u5e94\u7684\u8282\u70b9\u65cb\u8f6c\u5230\u6839\u4e0a\uff08\u8bb0\u4e3a$u$\uff09\uff0c\u628a$r+1$\u7684\u4f4d\u7f6e\u65cb\u8f6c\u5230\u6839\u4e0b\u9762\uff08\u8bb0\u4e3a$v$\uff0c\u5373\u6b64\u65f6$fa[v]=u$\uff09\u3002\n\n\u6b64\u65f6$v$\u7684\u5de6\u5b50\u6811\u6240\u8868\u793a\u7684\u533a\u95f4\u5373\u4e3a$[l,r]$\uff0c\u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u628a$v$\u7684\u5de6\u5b50\u6811\u5220\u9664\u5373\u53ef\u3002\n\n```cpp\nvoid recycle(int u){ // \u56de\u6536\u4ee5u\u4e3a\u6839\u7684\u5b50\u6811\n\tint ls = son[u][0], rs = son[u][1];\n\tif (ls) recycle(ls);\n\tif (rs) recycle(rs);\n\trb[++top] = u;\n}\nvoid erase(int l, int r){\n\tint u = kth(rt, l - 1); splay(u);\n\tint v = kth(rt, r + 1); splay(v, u); // \u63d0\u533a\u95f4\u64cd\u4f5c\n\trecycle(son[v][0]), son[v][0] = 0, up(v), up(u); // \u66f4\u65b0\n}\n```\n\n### \u8986\u76d6\u64cd\u4f5c\n\n\u4e0e\u5220\u9664\u540c\u7406\uff0c\u63d0\u53d6\u533a\u95f4$[l,r]$\uff0c\u6253\u4e0a$cov$\u6807\u8bb0\uff0c\u66f4\u65b0\u5373\u53ef\u3002\n\n```cpp\nvoid cover(int l, int r, int c){\n\tint u = kth(rt, l - 1); splay(u);\n\tint v = kth(rt, r + 1); splay(v, u);\n\tint t = son[v][0]; // \u63d0\u533a\u95f4\n\tval[t] = c, cov[t] = 1, sum[t] = sz[t] * c;\n\tif (c > 0) la[t] = ra[t] = ma[t] = sum[t];\n\telse la[t] = ra[t] = 0, ma[t] = c; // \u6253\u6807\u8bb0\uff0c\u4e0edown\u4e2d\u540c\u7406\n\tup(v), up(u); // \u66f4\u65b0\n}\n```\n\n### \u7ffb\u8f6c\u64cd\u4f5c\n\n\u540c\u7406\uff0c\u63d0\u53d6\u533a\u95f4\u540e\uff0c\u6253\u4e0a$rev$\u6807\u8bb0\u5e76\u66f4\u65b0\u3002\n\n```cpp\nvoid reverse(int l, int r){\n\tint u = kth(rt, l - 1); splay(u);\n\tint v = kth(rt, r + 1); splay(v, u);\n\tint t = son[v][0]; // \u63d0\u533a\u95f4\n\trev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]);\n\t// \u6253\u6807\u8bb0\uff0c\u4e0edown\u4e2d\u540c\u7406\n\tup(v), up(u); // \u66f4\u65b0\n}\n```\n\n### \u6c42\u548c\u64cd\u4f5c\n\n\u63d0\u53d6\u533a\u95f4\u540e\u76f4\u63a5\u8f93\u51fa$sum$\u503c\u5373\u53ef\uff0c\u4e0d\u9700\u8981\u66f4\u65b0\u3002\n\n```cpp\nvoid query_sum(int l, int r){\n\tint u = kth(rt, l - 1); splay(u);\n\tint v = kth(rt, r + 1); splay(v, u);\n\tprintf(\"%d\\n\", sum[son[v][0]]);\n}\n```\n\n### \u6700\u5927\u5b50\u6bb5\u548c\n\n\u76f4\u63a5\u8f93\u51fa$ma[rt]$\u5373\u53ef\u3002\n\n### \u4e00\u4e9b\u7ec6\u8282\n\n1. \u7531\u4e8e$pos,l-1$\u53ef\u80fd\u4f1a$<1$\uff0c$pos+1,r$\u53ef\u80fd\u4f1a$>n$\uff0c\u6240\u4ee5\u8981\u8003\u8651\u8fb9\u754c\u95ee\u9898\u3002\u6211\u7684\u4ee3\u7801\u4e2d\u662f\u76f4\u63a5\u628a\u6574\u4e2a\u6570\u7ec4\u5411\u53f3\u79fb\u52a8\u4e00\u4f4d\uff0c\u5e76\u4e14\u4f7f$a[1]=a[n+2]=-\\text{INF}$\u3002\u4e2a\u4eba\u89c9\u5f97\u8fd9\u4e2a\u65b9\u6cd5\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u8981\u5728\u4e3b\u7a0b\u5e8f\u4e2d\u505a\u4e00\u4e9b\u7b80\u5355\u7684\u5904\u7406\u5373\u53ef\u3002\n2. \u7531\u4e8e$up$\u4e2d\u6ca1\u6709\u5224\u65ad\u5de6\u513f\u5b50\u6216\u53f3\u513f\u5b50\u4e3a\u7a7a\u7684\u60c5\u51b5\uff08\u5224\u8d77\u6765\u4f1a\u53d8\u5f97\u5f88\u9b3c\u755c\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u4ee4$ma[0]=-\\text{INF}$\u3002\n\n## \u4ee3\u7801\u5b9e\u73b0\n\n\u603b\u7684\u518d\u53d1\u4e00\u6b21\u5427\u3002\u5438\u6c27\u540e~~\u6700\u5feb\u7684\u4e00\u6b21~~\u51711111ms\u3002[\u8bc4\u6d4b\u8bb0\u5f55](https://www.luogu.org/recordnew/show/15406481)\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nint read(){\n\tregister int x = 0, f = 1;\n\tregister char ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') f = !f;\n\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');\n\treturn f ? x : -x;\n}\n#define N 500005\n#define INF 500000000\nint n, m, a[N];\nchar opt[15];\nint k, x, tot, c[N];\nstruct Splay{\n\tint rt, cnt, son[N][2], fa[N], sz[N], val[N];\n\tint rev[N], cov[N], sum[N], la[N], ra[N], ma[N];\n\tint top, rb[5000005];\n\tSplay(){\n\t\trt = 0, cnt = 0, top = 0;\n\t\tfa[0] = son[0][0] = son[0][1] = sz[0] = rev[0] = cov[0] = 0;\n\t\tval[0] = sum[0] = la[0] = ra[0] = 0, ma[0] = -INF;\n\t}\n\tint new_node(int _val){\n\t\tint x = top ? rb[top--] : ++cnt;\n\t\tson[x][0] = son[x][1] = fa[x] = rev[x] = cov[x] = 0, sz[x] = 1;\n\t\tval[x] = ma[x] = sum[x] = _val, la[x] = ra[x] = std :: max(_val, 0);\n\t\treturn x;\n\t}\n\tvoid recycle(int u){\n\t\tint ls = son[u][0], rs = son[u][1];\n\t\tif (ls) recycle(ls);\n\t\tif (rs) recycle(rs);\n\t\trb[++top] = u;\n\t}\n\tvoid up(int u){\n\t\tint ls = son[u][0], rs = son[u][1];\n\t\tsz[u] = sz[ls] + sz[rs] + 1, sum[u] = sum[ls] + sum[rs] + val[u];\n\t\tla[u] = std :: max(la[ls], sum[ls] + val[u] + la[rs]);\n\t\tra[u] = std :: max(ra[rs], sum[rs] + val[u] + ra[ls]);\n\t\tma[u] = std :: max(std :: max(ma[ls], ma[rs]), ra[ls] + val[u] + la[rs]);\n\t}\n\tvoid down(int u){\n\t\tint ls = son[u][0], rs = son[u][1];\n\t\tif (cov[u]){\n\t\t\tif (ls) val[ls] = val[u], cov[ls] = 1, sum[ls] = sz[ls] * val[u];\n\t\t\tif (rs) val[rs] = val[u], cov[rs] = 1, sum[rs] = sz[rs] * val[u];\n\t\t\tif (val[u] > 0){\n\t\t\t\tif (ls) la[ls] = ra[ls] = ma[ls] = sum[ls];\n\t\t\t\tif (rs) la[rs] = ra[rs] = ma[rs] = sum[rs];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (ls) la[ls] = ra[ls] = 0, ma[ls] = val[u];\n\t\t\t\tif (rs) la[rs] = ra[rs] = 0, ma[rs] = val[u];\n\t\t\t}\n\t\t\tcov[u] = 0;\n\t\t}\n\t\tif (rev[u]){\n\t\t\tif (ls) rev[ls] ^= 1, std :: swap(son[ls][0], son[ls][1]), std :: swap(la[ls], ra[ls]);\n\t\t\tif (rs) rev[rs] ^= 1, std :: swap(son[rs][0], son[rs][1]), std :: swap(la[rs], ra[rs]);\n\t\t\trev[u] = 0;\n\t\t}\n\t}\n\tint dir(int x){ return son[fa[x]][1] == x; }\n\tvoid set(int x, int k, int y){ son[x][k] = y, fa[y] = x; }\n\tvoid rotate(int x){\n\t\tint y = fa[x], d = dir(x);\n\t\tset(fa[y], dir(y), x), set(y, d, son[x][!d]), set(x, !d, y);\n\t\tup(y), up(x);\n\t}\n\tvoid splay(int x, int g = 0){\n\t\twhile (fa[x] != g){\n\t\t\tint y = fa[x];\n\t\t\tif (fa[y] != g) dir(y) == dir(x) ? rotate(y) : rotate(x);\n\t\t\trotate(x);\n\t\t}\n\t\tif (!g) rt = x;\n\t}\n\tint build(int l, int r, int *a){\n\t\tif (l > r) return 0;\n\t\tif (l == r) return new_node(a[l]);\n\t\tint mid = (l + r) >> 1, u = new_node(a[mid]);\n\t\tson[u][0] = build(l, mid - 1, a), son[u][1] = build(mid + 1, r, a);\n\t\tfa[son[u][0]] = fa[son[u][1]] = u;\n\t\treturn up(u), u;\n\t}\n\tint kth(int u, int k){\n\t\tdown(u);\n\t\tint ls = son[u][0], rs = son[u][1];\n\t\tif (k == sz[ls] + 1) return u;\n\t\telse if (k <= sz[ls]) return kth(ls, k);\n\t\telse return kth(rs, k - sz[ls] - 1);\n\t}\n\tvoid insert(int x, int tot, int *a){\n\t\tint t = build(1, tot, a);\n\t\tint u = kth(rt, x); splay(u);\n\t\tint v = kth(rt, x + 1); splay(v, u);\n\t\tson[v][0] = t, fa[t] = v, up(v), up(u);\n\t}\n\tvoid erase(int l, int r){\n\t\tint u = kth(rt, l - 1); splay(u);\n\t\tint v = kth(rt, r + 1); splay(v, u);\n\t\trecycle(son[v][0]), son[v][0] = 0, up(v), up(u);\n\t}\n\tvoid cover(int l, int r, int c){\n\t\tint u = kth(rt, l - 1); splay(u);\n\t\tint v = kth(rt, r + 1); splay(v, u);\n\t\tint t = son[v][0];\n\t\tval[t] = c, cov[t] = 1, sum[t] = sz[t] * c;\n\t\tif (c > 0) la[t] = ra[t] = ma[t] = sum[t];\n\t\telse la[t] = ra[t] = 0, ma[t] = c;\n\t\tup(v), up(u);\n\t}\n\tvoid reverse(int l, int r){\n\t\tint u = kth(rt, l - 1); splay(u);\n\t\tint v = kth(rt, r + 1); splay(v, u);\n\t\tint t = son[v][0];\n\t\trev[t] ^= 1, std :: swap(son[t][0], son[t][1]), std :: swap(la[t], ra[t]);\n\t\tup(v), up(u);\n\t}\n\tvoid query_sum(int l, int r){\n\t\tint u = kth(rt, l - 1); splay(u);\n\t\tint v = kth(rt, r + 1); splay(v, u);\n\t\tprintf(\"%d\\n\", sum[son[v][0]]);\n\t}\n\tvoid query_max_sum(){ printf(\"%d\\n\", ma[rt]); }\n}T;\nint main(){\n\tn = read(), m = read(), n += 2, a[1] = a[n] = -INF;\n\tfor (register int i = 2; i < n; ++i) a[i] = read(); // \u6574\u4f53\u53f3\u79fb\n\tT.rt = T.build(1, n, a);\n\twhile (m--){\n\t\tscanf(\"%s\", opt);\n\t\tif (opt[0] == 'M' && opt[2] == 'X') T.query_max_sum();\n\t\telse x = read() + 1, tot = read(); // +1\u662f\u56e0\u4e3a\u6570\u7ec4\u6574\u4f53\u53f3\u79fb\n\t\tif (opt[0] == 'I'){\n\t\t\tfor (register int i = 1; i <= tot; ++i) c[i] = read();\n\t\t\tT.insert(x, tot, c);\n\t\t}\n\t\tif (opt[0] == 'D') T.erase(x, x + tot - 1);\n\t\tif (opt[0] == 'M' && opt[2] == 'K') T.cover(x, x + tot - 1, read());\n\t\tif (opt[0] == 'R') T.reverse(x, x + tot - 1);\n\t\tif (opt[0] == 'G') T.query_sum(x, x + tot - 1);\n\t}\n}\n```\n\n\u5982\u53d1\u73b0\u4ee3\u7801\u6709\u95ee\u9898\u8bf7\u5728\u8bc4\u8bba\u4e2d\u6307\u51fa\uff0c\u8c22\u8c22\u5566\uff01",
        "postTime": 1547554569,
        "uid": 20561,
        "name": "AutumnKite",
        "ccfLevel": 10,
        "title": "LuoguP2042 [NOI2005]\u7ef4\u62a4\u6570\u5217 (Splay)"
    },
    {
        "content": "# Splay \u6587\u827a\u5e73\u8861\u6811\n\n#### \u524d\u8a00\uff1a\n\n\u8fd9\u662f\u4e00\u9053\u597d\u677f\u5b50\uff0c\u53ef\u6211\u5374\u8c03\u4e862\u5929\u2026\u2026\n\n\u53c8\u89c9\u5f97\u5176\u4ed6\u9898\u89e3\u770b\u4e0d\u61c2\uff08\u6bd4\u5982\u6307\u9488\u515a\u7684\u4ee3\u7801\uff0c\u672c\u849f\u84bb\u5b9e\u5728\u4e0d\u4e60\u60ef\uff09\uff0c\u5c31\u6765\u6c34\u4e00\u53d1\u3002\n\n#### \u524d\u7f6e\u77e5\u8bc6\uff1a$Splay$\u3001$rotate$\uff08\u65cb\u8f6c\uff09\u3001$kth$\uff08\u6c42\u6811\u4e2d\u7684\u7b2c$k$\u540d\u7684\u64cd\u4f5c\uff09\u3002\n\n## \u5148\u8bb2\u4e00\u4e0b\u6587\u827a\u5e73\u8861\u6811\u7684\u57fa\u672c\u601d\u8def\u548c\u64cd\u4f5c\u5427\uff1a\n\n### \u5efa\u6811\uff1a\n\n\u666e\u901a\u5e73\u8861\u6811\u7684\u5efa\u6811\u65b9\u6cd5\u662f\u4e00\u4e2a\u4e00\u4e2a\u70b9\u5730$insert$\u8fdb\u6811\u91cc\u3002\n\n\u800c\u50cf\u8fd9\u79cd\u5f00\u59cb\u5c31\u7ed9\u4f60\u5e8f\u5217\u7684\u5c31\u53ef\u4ee5\u9012\u5f52\u5efa\u6811\uff08\u50cf**\u7ebf\u6bb5\u6811**\u4e00\u6837\uff09\n\n\u800c\u67d0\u4e2a\u8282\u70b9\u6240\u5bf9\u5e94\u7684\u6570\u5e94\u8be5\u4e3a$a[(l+r)/2]$\uff08\u4e5f\u5c31\u662f\u4e2d\u95f4\u7684\u6570\uff0c$a[]$\u4e3a\u8f93\u5165\u7684\u6570\u7ec4\uff09\n\n\u4ee3\u7801\u548c\u8be6\u7ec6\u6ce8\u91ca\u5982\u4e0b\uff1a\n\n```cpp\nint build(int l,int r,int fa)\n{\n\tif(l>r)return 0;//\u6ce8\u610f\u8fb9\u754c\n\tint mid=(l+r)>>1,now;//now\u4e3a\u8282\u70b9\u7f16\u53f7\n    if(tot2)now=s[tot2--];//\u8d44\u6e90\u56de\u6536\u6765\u5efa\u7acb\u8282\u70b9\u7f16\u53f7\uff08\u7b49\u4f1a\u4f1a\u8bb2\uff09\n\telse now=++tot;\n\tt[now].fa=fa;//\u8bb0\u5f55\u7c91\u7c91\n\tt[now].val=a[mid];//\u8bb0\u5f55\u8fd9\u4e2a\u70b9\u6240\u5bf9\u5e94\u7684\u503c\n\tt[now].tag=t[now].lazy=t[now].laz=0;//\u521d\u59cb\u5316\n\tt[now].ch[0]=build(l,mid-1,now);//\u8bb0\u5f55\u5de6\u513f\u5b50\n\tt[now].ch[1]=build(mid+1,r,now);//\u8bb0\u5f55\u53f3\u513f\u5b50\n\tup(now);\n\treturn now;//\u8fd4\u56de\u5f53\u524d\u8282\u70b9\u7f16\u53f7\n}\n```\n\n\u5177\u4f53\u7684$up()$\u64cd\u4f5c\u7b49\u4f1a\u518d\u8bf4\u3002\n\n### \u63d0\u51fa\u533a\u95f4\uff1a\n\n\u5047\u8bbe\u73b0\u5728\u8981\u6c42\u533a\u95f4$[l,r]$\uff0c\u6211\u4eec\u5f97\u600e\u4e48\u5904\u7406\u5462\uff1f\n\n**\u6211\u4eec\u53ef\u4ee5\u5148\u901a\u8fc7$Splay$\u628a\u7b2c$l-1$\u4f4d\u7684\u70b9$a$\u65cb\u8f6c\u5230\u6839\uff0c\u518d\u628a$r+1$\u4f4d\u7684\u70b9$b$\u65cb\u8f6c\u5230$a$\u4e0b\u65b9\u3002**\n\n**\u6b64\u65f6\u70b9$b$\u7684\u5de6\u5b50\u6811\u7684\u6bcf\u4e2a\u70b9$x$\u6ee1\u8db3\uff1a$l-1<x<r+1$\uff0c\u5982\u56fe\uff1a**\n\n![](https://cdn.luogu.com.cn/upload/pic/49296.png)\n\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5~~\u8f7b\u800c\u6613\u4e3e~~\u5730\u628a$[l,r]$\u8fd9\u6bb5\u533a\u95f4\u7ed9\u63d0\u51fa\u6765\u64cd\u4f5c\u4e86\u3002\uff08\u5c3d\u7ba1\u6c42$kth$\u3001$splay$\u548c$rotate$\u4ee3\u7801\u90fd\u5f88\u957f\uff09\n\n\u4f46\u662f\u5982\u679c\u9898\u76ee\u8981\u6c42$[1,n]$\uff0c\u90a3$l-1$\u548c$r+1$\u662f\u4ec0\u4e48\uff1f\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u8981\u624b\u52a8\u5728\u6574\u68f5\u6811\u7684\u6700\u524d\u9762\u52a0\u4e0a\u4e00\u4e2a\u503c\u4e3a$-INF$\u70b9\uff0c\u5728\u6700\u540e\u9762\u52a0\u4e0a\u4e00\u4e2a\u503c\u4e3a$INF$\u7684\u70b9\u3002\n\n\u8fd9\u6837\u6574\u68f5\u6811\u5c31\u6709$n+2$\u4e2a\u70b9\u3002\n\n\u56e0\u4e3a$a[1]$\u662f$-INF$\uff0c\u6240\u4ee5\u6574\u4e2a\u5e8f\u5217\u90fd\u5f80\u540e\u79fb\u4e86\u4e00\u4f4d\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u672c\u6765\u9898\u76ee\u7ed9\u51fa\u6570\u5217\u7684\u7b2c$k$\u4e2a\u6570\uff0c\u672c\u5e94\u662f\u6574\u68f5\u6811\u7684\u7b2c$k$\u4f4d\uff0c\u73b0\u5728\u53d8\u6210\u4e86\u7b2c$k+1$\u4f4d\u3002\n\n\u6240\u4ee5\u8f93\u5165\u8fd9\u4e2a\u5e8f\u5217\u65f6\u5e94\u8be5\uff1a\n\n```cpp\na[1]=-INF;\na[n+2]=INF;\nfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i+1]);\n```\n\n\u7136\u540e\u627e$[l,r]$\u7684\u8fc7\u7a0b\u5982\u4e0b\uff1a\n\n```cpp\nscanf(\"%d%d\",&l,&r);\nl++;r++;//\u6570\u5217\u6574\u4f53\u4f4d\u7f6e\u540e\u79fb\u4e00\u4f4d\uff0c\u6240\u6709\u7684\u4ee5\u540e\u90fd\u662f\u8fd9\u6837\nl=kth(l-1);r=kth(r+1);//\u627e\u5230l-1\u548cr+1\u7684\u4f4d\u7f6e\nsplay(l,0);splay(r,l);//\u628al\u65cb\u8f6c\u5230\u6839\uff0cr\u65cb\u8f6c\u5230l\u4e0b\u9762\n//\u73b0\u5728t[r].ch[0]\u5c31\u662f[l,r]\u7684\u6839\u4e86\n```\n\n## \u73b0\u5728\u8bf4\u4e00\u4e0b\u9898\u76ee\u7ed9\u7684\u6bcf\u4e2a\u64cd\u4f5c\u600e\u4e48\u5b9e\u73b0\n\n### \u7ed3\u6784\u4f53\u8bf4\u660e\uff1a\n\n```cpp\nstruct Splay\n{\n\tint fa;//\u7c91\u7c91\n    int ch[2]//\u513f\u5b50\n    int size;//\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u6811\u7684\u8282\u70b9\u603b\u6570\n    int tag;//\u9898\u76ee\u4e2d\u7ffb\u8f6c\u7528\u61d2\u6807\u8bb0\n\tlong long val;//\u8282\u70b9\u6240\u5bf9\u5e94\u7684\u503c\n    long long sum;//\u9898\u76ee\u8981\u6c42\u7684sum\n    long long maxn;//\u9898\u76ee\u8981\u6c42\u7684max_sum\n    long long lazy;//\u9898\u76ee\u4e2dmake_same\u7528\u61d2\u6807\u8bb0\n    long long ls;//\u4ee5\u5f53\u524d\u5e8f\u5217\u7684\u5de6\u7aef\u70b9\u4e3a\u5934\u7684max_sum\n    long long rs;//\u4ee5\u5f53\u524d\u5e8f\u5217\u7684\u53f3\u7aef\u70b9\u4e3a\u5934\u7684max_sum\n\tbool laz;//\u9898\u76ee\u4e2dmake_same\u7528\u7684\u61d2\u6807\u8bb0\u8bc6\u522b\u7801\n}t[N];\n```\n\n### \u4e00\u3001$insert$\u64cd\u4f5c\n\n\u9996\u5148\uff0c\u6211\u4eec\u5148\u628a$l$\u8bbe\u4e3a$pos$\uff0c$r$\u8bbe\u4e3a$pos+1$\uff0c\u5e76\u628a$[l,r]$\u63d0\u51fa\u6765\uff08\u63d0\u51fa\u540e$r$\u7684\u5de6\u5b50\u6811\u4e3a\u7a7a\uff09\n\n\u7136\u540e\u6211\u4eec\u5c06\u8f93\u5165\u7684\u6570\u636e\u9012\u5f52\u5efa\u6811\u3002\n\n\u6700\u540e\u8fde\u63a5$r$\u4e0e\u5efa\u7684\u6811\u7684\u6839\u3002\n\n\u5177\u4f53\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nvoid insert(int l,int x)\n{\n\tint r=l+1;\n\tl=kth(l+1);r=kth(r+1);\n\tsplay(l,0);splay(r,l);\n\tfor(int i=1;i<=x;i++)scanf(\"%lld\",&a[i]);\n\tt[r].ch[0]=build(1,x,r);//\u5efa\u6811\u5e76\u8fde\u63a5\u7236\u5b50\u5173\u7cfb\n\tn+=x;//\u5c06\u603b\u70b9\u6570\u52a0\u4e0ax\n\tup(r);up(l);\n}\n```\n\n### \u4e8c\u3001$delete$\u64cd\u4f5c\n\n\u540c\u6837\uff0c\u6211\u4eec\u5148\u5c06\u8981\u5220\u9664\u7684\u533a\u95f4\u63d0\u53d6\u51fa\u6765\u3002\n\n\u7136\u540e\u65ad\u7edd\u6574\u68f5\u6811\u4e0e\u533a\u95f4\u6240\u5bf9\u5e94\u7684\u6811\u7684\u7236\u5b50\u5173\u7cfb~~\u65ad\u5b50\u7edd\u5b59~~\u3002\n\n\u6ce8\u610f\uff1a\u7531\u4e8e\u7a7a\u95f4\u4e0d\u591f\uff0c\u6211\u4eec\u9700\u8981\u8fdb\u884c~~\u5783\u573e~~**\u201c\u8d44\u6e90\u56de\u6536\u201d**\uff0c\u4e5f\u5c31\u662f\u628a\u5220\u53bb\u7684\u8282\u70b9\u7684\u7f16\u53f7\u5b58\u8d77\u6765\uff0c\u4ee5\u4fbf$insert$\u7684\u65f6\u5019\u7528\u3002\n\n\u5177\u4f53\u53ef\u4ee5\u7528\u6570\u7ec4\u3001\u961f\u5217\u6216\u6808\u6765\u5b9e\u73b0\uff1a\n\n```cpp\nvoid erase(int k)\n{\n\tif(!k)return;\n\ts[++tot2]=k;//\u8bb0\u5f55\u7f16\u53f7\n\terase(t[k].ch[0]);\n\terase(t[k].ch[1]);\n}\n```\n\n\u5220\u9664\u64cd\u4f5c\u4ee3\u7801\uff1a\n\n```cpp\nvoid delet(int l,int r)//r\u8981\u63d0\u524d\u7b97\u51fa\u6765\n{\n\tn-=r-l+1;//\u4fee\u6539\u603b\u70b9\u6570\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\terase(t[r].ch[0]);//\u8d44\u6e90\u56de\u6536\n\tt[r].ch[0]=0;//\u65ad\u7edd\u7236\u5b50\u5173\u7cfb\n\tup(r);up(l);\n}\n```\n\n### \u4e09\u3001$make\\_same$\u64cd\u4f5c\n\n\u540c\u6837\uff0c\u6211\u4eec\u5148\u628a$[l,r]$\u63d0\u51fa\u6765\u3002\n\n\u8fd9\u65f6\uff0c\u6211\u4eec\u5c31\u8981\u7528\u5230\u7ebf\u6bb5\u6811\u7684\u4e00\u4e2a\u91cd\u8981\u64cd\u4f5c\u2014\u2014$lazy$\u61d2\u6807\u8bb0\u3002\n\n\u4f46\u662f\u6709\u4e00\u4e2a\u7ec6\u8282\u2014\u2014\u5c31\u662f$lazy$\u7684\u521d\u59cb\u5316\u3002\n\n\u5982\u679c\u5f53$lazy$\u4e3a0\u65f6\u5c31\u89c6\u4e3a\u6ca1\u6709\u61d2\u6807\u8bb0\uff0c\u90a3\u4e07\u4e00\u9898\u76ee\u771f\u7684\u8981\u628a\u67d0\u6bb5\u533a\u95f4\u5168\u6539\u4e3a0\u600e\u4e48\u529e\u3002\n\n\u6240\u4ee5\u6211\u5c31\u8bbe\u4e86\u53e6\u4e00\u4e2a$bool$\u7684$laz$\uff0c\u6765\u8bb0\u5f55\u662f\u5426\u9700\u8981\u4e0b\u4f20\u61d2\u6807\u8bb0\n\n\u90a3\u4e48\u4e0b\u4f20\u7684\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nint l=t[k].ch[0],r=t[k].ch[1];\nif(t[k].laz)//\u5982\u679c\u9700\u8981\u4e0b\u4f20\n{\n\tt[k].lazy=t[k].laz=0;\n\tif(l)\n\t{\n\t\tt[l].laz=true;\n\t\tt[l].val=t[k].val;\n\t\tt[l].sum=t[k].val*t[l].size;\n\t}\n\tif(r)\n\t{\n\t\tt[r].laz=true;\n\t\tt[r].val=t[k].val;\n\t\tt[r].sum=t[k].val*t[r].size;\n\t}\n\tif(t[k].val>=0)\n\t{\n\t\tif(l)t[l].ls=t[l].rs=t[l].maxn=t[l].sum;//\u56e0\u4e3a\u4fee\u6539\u540e\u7684\u5e8f\u5217\u6bcf\u4e00\u4e2a\u6570\u90fd\u4e00\u6837\uff0c\u6240\u4ee5\u5982\u679c\u8fd9\u4e2a\u6570\u5927\u4e8e0\uff0c\u90a3\u4e48max_sum\u5c31\u662f\u8fd9\u4e2a\u5e8f\u5217\u7684sum\n\t\tif(r)t[r].ls=t[r].rs=t[r].maxn=t[r].sum;\n\t}\n\telse \n\t{\n\t\tif(l)t[l].ls=t[l].rs=0,t[l].maxn=t[k].val;//\u56e0\u4e3a\u8fd9\u4e2a\u6570\u5c0f\u4e8e0\u4f46\u662f\u5b50\u5217\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5max_sum\u53ea\u80fd\u53bb\u8fd9\u4e2a\u6570\uff08\u4f46\u662fls\u548crs\u53ef\u4ee5\u53d60\uff0c\u4ed6\u4eec\u5e76\u4e0d\u4f1a\u5f71\u54cd\u5230\u4ed6\u4eec\u7c91\u7c91\uff0c\u8ba9\u4ed6\u4eec\u7684\u7c91\u7c91\u53d60\uff09\n\t\tif(r)t[r].ls=t[r].rs=0,t[r].maxn=t[k].val;\n\t}\n}\n```\n\n\u5177\u4f53\u7684\u4fee\u6539\u8fc7\u7a0b\u5982\u4e0b\uff1a\n\n```cpp\nvoid make_same(int l,int r,int x)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n    int k=t[r].ch[0];\n    t[k].val=x;\n\tt[k].sum=t[k].size*x;\n\tif(x<=0)t[k].ls=t[k].rs=0,t[k].maxn=x;\n\telse t[k].ls=t[k].rs=t[k].maxn=t[k].size*x;\n\tt[k].lazy=x;\n\tt[k].laz=true;\n\tup(r);up(l);\n}\n```\n\n### \u56db\u3001$reverse$\u7ffb\u8f6c\u64cd\u4f5c\n\n\u7ffb\u8f6c\u64cd\u4f5c\uff0c\u8bf4\u767d\u4e86\u5c31\u662f\u628a\u4e00\u68f5\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u513f\u5b50\u90fd$swap$\u4e00\u4e0b\n\n\u4f46\u6211\u4eec\u6ce8\u610f\u5230\uff1a\u540c\u4e00\u4e2a\u5e8f\u5217\uff0c\u5982\u679c\u7ffb\u8f6c2\u6b21\uff0c\u90a3\u4e48\u8fd8\u662f\u6ca1\u6709\u53d8\u52a8\u3002\n\n\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8bbe\u4e00\u4e2a\u50cf$lazy$\u4e00\u6837\u7684\u61d2\u6807\u8bb0$tag$\uff0c\u7528\u6765\u8bb0\u5f55\u4e00\u4e2a\u5e8f\u5217\u7684\u7ffb\u8f6c\u6b21\u6570\u3002\n\n\u4e0b\u4f20\u61d2\u6807\u8bb0\u7684\u8fc7\u7a0b\u5982\u4e0b:\n\n```cpp\nif(t[k].tag)\n{\n\tt[k].tag=0;t[l].tag^=1;t[r].tag^=1;\n\tswap(t[l].ls,t[l].rs);swap(t[r].ls,t[r].rs);//\u6ce8\u610f\uff0c\u5982\u679c\u4e00\u4e2a\u5e8f\u5217\u88ab\u7ffb\u8f6c\u4e86\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5e8f\u5217\u7684ls\u548crs\u4e5f\u8981\u7ffb\u8f6c\n\tswap(t[l].ch[0],t[l].ch[1]);swap(t[r].ch[0],t[r].ch[1]);//swap\u513f\u5b50\n}\n```\n\n\u6700\u540e\u4fee\u6539\u7684\u8fc7\u7a0b\u5728\u8fd9\u91cc\uff1a\n\n```cpp\nvoid reverse(int l,int r)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\tint k=t[r].ch[0];\n\tif(!t[k].laz)\n\t{\n\t\tt[k].tag^=1;//\u8bb0\u5f55\u61d2\u6807\u8bb0\uff080^1=1,1^1=0\uff09\n\t\tswap(t[k].ch[0],t[k].ch[1]);.//swap\u513f\u5b50\n\t\tswap(t[k].ls,t[k].rs);//swap ls\u3001rs\n\t\tup(r);up(l);\n\t}\n}\n```\n\n### \u4e94\u3001$get\\_sum$\u6c42\u548c\u64cd\u4f5c\n\n\u6bd4\u8f83\u7b80\u5355\uff0c\u6bcf\u4e2a\u8282\u70b9\u8bb0\u5f55\u4e00\u4e0b\u5c31\u597d\u4e86\uff08\u8bb0\u5f97$up$\uff09\uff1a\n\n```cpp\nlong long query_sum(int l,int r)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\treturn t[t[r].ch[0]].sum;\n}\n```\n\n### \u516d\u3001$max\\_sum$\u6c42\u548c\u6700\u5927\u5b50\u5217\u7684\u64cd\u4f5c\n\n\u6c42\u7b54\u6848\u7684\u51fd\u6570\uff1a\n\n```cpp\nlong long max_sum()\n{\n\tint l=kth(1),r=kth(n+2);//\u6ce8\u610f\uff0c\u9700\u8981\u628a[1,n]\u63d0\u51fa\u6765\n\tsplay(l,0);splay(r,l);\n\treturn t[t[r].ch[0]].maxn;\n}\n```\n\u600e\u4e48$up$\uff1f\n\n$up$\u7684\u4e09\u4e2a\u7c7b\u4f3c\u4e8e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u7684\u4e1c\u4e1c\uff1a\n\n$$t[k].ls=\\max(t[l].ls,t[l].sum+t[k].val+t[r].ls)$$\n\n$$t[k].rs=\\max(t[r].rs,t[r].sum+t[k].val+t[l].rs)$$\n\n$$t[k].maxn=\\max(t[l].maxn,t[r].maxn,t[l].rs+t[k].val+t[r].ls)$$\n\n\u8fd8\u662f\u5f88\u597d\u7406\u89e3\u7684\uff0c\u753b\u753b\u56fe\u5c31\u597d\u4e86\u3002\uff08\u5b9e\u5728\u60f3\u4e0d\u901a\u53ef\u4ee5\u770b\u4e00\u4e0b[\u548c\u8fd9\u79cd\u64cd\u4f5c\u5dee\u4e0d\u591a\u7684\u6211\u7684\u9898\u89e3\u7684\u89e3\u91ca](https://www.luogu.org/blog/lc-2018-Canton/solution-p4513)\uff09\n\n------------\n\n\u6700\u540e\u5b8c\u6574\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n\n#define N 500001\n#define INF 0x7fffffffffffffff\n\nusing namespace std;\n\nstruct Splay\n{\n\tint fa,ch[2],size;\n\tlong long val,sum,maxn,lazy,tag,ls,rs;\n\tbool laz;\n}t[N];\n\nlong long n,m,tot,root,tot2,a[N],s[N];\n\nvoid down(int k)\n{\n\tint l=t[k].ch[0],r=t[k].ch[1];\n\tif(t[k].laz)\n\t{\n\t\tt[k].lazy=t[k].laz=0;\n\t\tif(l)\n\t\t{\n\t\t\tt[l].laz=true;\n\t\t\tt[l].val=t[k].val;\n\t\t\tt[l].sum=t[k].val*t[l].size;\n\t\t}\n\t\tif(r)\n\t\t{\n\t\t\tt[r].laz=true;\n\t\t\tt[r].val=t[k].val;\n\t\t\tt[r].sum=t[k].val*t[r].size;\n\t\t}\n\t\tif(t[k].val>=0)\n\t\t{\n\t\t\tif(l)t[l].ls=t[l].rs=t[l].maxn=t[l].sum;\n\t\t\tif(r)t[r].ls=t[r].rs=t[r].maxn=t[r].sum;\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(l)t[l].ls=t[l].rs=0,t[l].maxn=t[k].val;\n\t\t\tif(r)t[r].ls=t[r].rs=0,t[r].maxn=t[k].val;\n\t\t}\n\t}\n\tif(t[k].tag)\n\t{\n\t\tt[k].tag=0;t[l].tag^=1;t[r].tag^=1;\n\t\tswap(t[l].ls,t[l].rs);swap(t[r].ls,t[r].rs);\n\t\tswap(t[l].ch[0],t[l].ch[1]);swap(t[r].ch[0],t[r].ch[1]);\n\t}\n}\n\nvoid up(int k)\n{\n\tint l=t[k].ch[0],r=t[k].ch[1];\n\tt[k].size=t[l].size+t[r].size+1;\n\tt[k].sum=t[l].sum+t[r].sum+t[k].val;\n\tt[k].maxn=max(max(t[l].maxn,t[r].maxn),t[l].rs+t[k].val+t[r].ls);\n\tt[k].ls=max(t[l].ls,t[l].sum+t[k].val+t[r].ls);\n\tt[k].rs=max(t[r].rs,t[r].sum+t[k].val+t[l].rs);\n}\n\nbool get(int k)\n{\n\treturn t[t[k].fa].ch[1]==k;\n}\n\nvoid rotate(int k)\n{\n\tint fa=t[k].fa,gfa=t[fa].fa;\n\tint d1=get(k),d2=get(fa);\n\tt[fa].ch[d1]=t[k].ch[d1^1];\n\tt[t[k].ch[d1^1]].fa=fa;\n\tt[fa].fa=k;\n\tt[k].ch[d1^1]=fa;\n\tt[k].fa=gfa;\n\tt[gfa].ch[d2]=k;\n\tup(fa);up(k);\n}\n\n\nvoid splay(int x,int y)\n{\n\twhile(t[x].fa!=y)\n\t{\n\t\tint fa=t[x].fa,gfa=t[fa].fa;\n\t\tint d1=get(x),d2=get(fa);\n\t\tif(gfa!=y)\n\t\t{\n\t\t\tif(d1==d2)rotate(fa);\n\t\t\telse rotate(x);\n\t\t}\n\t\trotate(x);\n\t}\n\tif(!y)root=x;\n}\n\nint kth(int k)\n{\n\tint now=root;\n\twhile(1)\n\t{\n\t\tdown(now);\n\t\tif(k<=t[t[now].ch[0]].size)now=t[now].ch[0];\n\t\telse if(k==t[t[now].ch[0]].size+1)return now;\n\t\telse \n\t\t{\n\t\t\tk-=t[t[now].ch[0]].size+1;\n\t\t\tnow=t[now].ch[1];\n\t\t}\n\t}\n}\n\nint build(int l,int r,int fa)\n{\n\tif(l>r)return 0;\n\tint mid=(l+r)>>1,now;\n\tif(tot2)now=s[tot2--];\n\telse now=++tot;\n\tt[now].fa=fa;\n\tt[now].val=a[mid];\n\tt[now].tag=t[now].lazy=t[now].laz=0;\n\tt[now].ch[0]=build(l,mid-1,now);\n\tt[now].ch[1]=build(mid+1,r,now);\n\tup(now);\n\treturn now;\n}\n\nvoid insert(int l,int x)\n{\n\tint r=l+1;\n\tl=kth(l+1);r=kth(r+1);\n\tsplay(l,0);splay(r,l);\n\tfor(int i=1;i<=x;i++)scanf(\"%lld\",&a[i]);\n\tt[r].ch[0]=build(1,x,r);\n\tn+=x;\n\tup(r);up(l);\n}\n\nvoid erase(int k)\n{\n\tif(!k)return;\n\ts[++tot2]=k;\n\terase(t[k].ch[0]);\n\terase(t[k].ch[1]);\n}\n\nvoid delet(int l,int r)\n{\n\tn-=r-l+1;\n\tl=kth(l);r=kth(r+2);//(l+1)-1=l,(r+1)+1=r+2\n\tsplay(l,0);splay(r,l);\n\terase(t[r].ch[0]);\n\tt[r].ch[0]=0;\n\tup(r);up(l);\n}\n\nvoid make_same(int l,int r,int x)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\tint k=t[r].ch[0];\n    t[k].val=x;\n\tt[k].sum=t[k].size*x;\n\tif(x<=0)t[k].ls=t[k].rs=0,t[k].maxn=x;\n\telse t[k].ls=t[k].rs=t[k].maxn=t[k].size*x;\n\tt[k].lazy=x;\n\tt[k].laz=true;\n\tup(r);up(l);\n}\n\nvoid reverse(int l,int r)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\tint k=t[r].ch[0];\n\tif(!t[k].laz)\n\t{\n\t\tt[k].tag^=1;\n\t\tswap(t[k].ch[0],t[k].ch[1]);\n\t\tswap(t[k].ls,t[k].rs);\n\t\tup(r);up(l);\n\t}\n}\n\nvoid write(int k)\n{\n\tif(k)\n\t{\n\t\tdown(k);\n\t\twrite(t[k].ch[0]);\n\t\tif(t[k].val!=-INF&&t[k].val!=INF)printf(\"%lld \",t[k].val);\n\t\twrite(t[k].ch[1]);\n\t}\n}\n\nlong long query_sum(int l,int r)\n{\n\tl=kth(l);r=kth(r+2);\n\tsplay(l,0);splay(r,l);\n\treturn t[t[r].ch[0]].sum;\n}\n\nlong long max_sum()\n{\n\tint l=kth(1),r=kth(n+2);\n\tsplay(l,0);splay(r,l);\n\treturn t[t[r].ch[0]].maxn;\n}\n\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tt[0].maxn=-INF;//\u6ce8\u610f\n\ta[1]=-INF;\n\ta[n+2]=INF;\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i+1]);\n\troot=build(1,n+2,0);\n\twhile(m--)\n\t{\n\t\tchar ch[9];\n\t\tint x,y,z;\n\t\tscanf(\"%s\",ch);\n\t\tif(ch[0]=='I')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tinsert(x,y);\n\t\t}\n\t\tif(ch[0]=='D')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tdelet(x,x+y-1);\n\t\t}\n\t\tif(ch[0]=='M'&&ch[2]=='K')\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tmake_same(x,x+y-1,z);\n\t\t}\n\t\tif(ch[0]=='R')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\treverse(x,x+y-1);\n\t\t}\n\t\tif(ch[0]=='G')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tprintf(\"%lld\\n\",query_sum(x,x+y-1));\n\t\t}\n\t\tif(ch[0]=='M'&&ch[2]=='X')\n\t\t{\n\t\t\tprintf(\"%lld\\n\",max_sum());\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n##### \u5171\u521b\u548c\u8c10\u6d1b\u8c37\uff0c\u62d2\u7eddcopy\n\n# \u6700\u540e\u795d\u5927\u5bb6$Splay$\u505a\u5f97\u987a\u5229\uff01",
        "postTime": 1548145345,
        "uid": 118318,
        "name": "ez_lcw",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u53d1\u4e00\u4e2afhq Treap\u7248\u7684\u4ee3\u7801\n\n\u60f3\u5b66\u4e60\u975e\u65cb\u8f6cTreap\u7684\u6b22\u8fce\u6765[\u535a\u5ba2](http://www.yhzq-blog.cc/fhq-treap\u603b\u7ed3/)\n\n\n\u524d\u51e0\u4e2a\u64cd\u4f5c\u90fd\u5f88\u597d\u641e\uff0c\u6700\u540e\u4e00\u4e2a\u7684\u8bdd\u6bcf\u4e00\u4e2a\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u548c\u4ece\u5de6\u53f3\u5b50\u6bb5\u6700\u5927\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6109\u5feb\u7684\u5408\u5e76\u4e86\u3002\n\n\u8981\u627e\u5230pos\u7684\u533a\u95f4\uff0c\u5148split(root,pos-1,x,y)\u518dsplit(x2,len,y1,y1)\u533a\u95f4\u5c31\u662fy1\n\n\n\u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <cstdlib>\n#define N 500010\n#define inf 0x3f3f3f3f\nusing namespace std;\nint ch[N][2],f[N],siz[N],val[N],tmx[N],lmx[N],rmx[N],rev[N],sum[N],cov[N],tar[N];\nint inline read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint max(int x,int y){if (x>y) return x;return y;}\nint min(int x,int y){if (x<y) return x;return y;}\nvoid swap(int &a,int &b){a^=b,b^=a,a^=b;}\nqueue<int>trashcan;\nint root,cnt;\nint new_node(int v)\n{\n    int x;\n    if (!trashcan.empty())\n        x=trashcan.front(),trashcan.pop();\n    else\n        x=++cnt;\n    ch[x][0]=ch[x][1]=f[x]=rev[x]=0;\n    cov[x]=inf,tar[x]=rand(),siz[x]=1;\n    val[x]=sum[x]=tmx[x]=v;\n    lmx[x]=rmx[x]=max(v,0);\n    return x;\n}\nvoid update(int x)\n{\n    if (ch[x][0] && ch[x][1])\n    {\n        siz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;\n        sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];\n        tmx[x]=max(tmx[ch[x][0]],tmx[ch[x][1]]);\n        tmx[x]=max(tmx[x],rmx[ch[x][0]]+val[x]+lmx[ch[x][1]]);\n        lmx[x]=max(lmx[ch[x][0]],sum[ch[x][0]]+val[x]+lmx[ch[x][1]]);\n        rmx[x]=max(rmx[ch[x][1]],sum[ch[x][1]]+val[x]+rmx[ch[x][0]]);\n    }\n    else\n    if (ch[x][0])\n    {\n        siz[x]=siz[ch[x][0]]+1;\n        sum[x]=sum[ch[x][0]]+val[x];\n        tmx[x]=max(tmx[ch[x][0]],rmx[ch[x][0]]+val[x]);\n        lmx[x]=max(lmx[ch[x][0]],sum[ch[x][0]]+val[x]);\n        lmx[x]=max(0,lmx[x]);\n        rmx[x]=max(0,val[x]+rmx[ch[x][0]]);\n    }\n    else\n    if (ch[x][1])\n    {\n        siz[x]=siz[ch[x][1]]+1;\n        sum[x]=sum[ch[x][1]]+val[x];\n        tmx[x]=max(tmx[ch[x][1]],lmx[ch[x][1]]+val[x]);\n        rmx[x]=max(rmx[ch[x][1]],sum[ch[x][1]]+val[x]);\n        rmx[x]=max(0,rmx[x]);\n        lmx[x]=max(0,lmx[ch[x][1]]+val[x]);\n    }\n    else\n    {\n        siz[x]=1,sum[x]=tmx[x]=val[x];\n        lmx[x]=rmx[x]=max(val[x],0);\n    }\n}\nvoid reverse(int x)\n{\n    swap(ch[x][0],ch[x][1]);\n    swap(lmx[x],rmx[x]);\n    rev[x]^=1;\n}\nvoid cover(int x,int v)\n{\n    val[x]=v,sum[x]=siz[x]*v;\n    lmx[x]=rmx[x]=max(sum[x],0);\n    tmx[x]=max(sum[x],val[x]);\n    cov[x]=v;\n}\nvoid pushdown(int x)\n{\n    if (rev[x])\n    {\n        if (ch[x][0]) reverse(ch[x][0]);\n        if (ch[x][1]) reverse(ch[x][1]);\n    }\n    if (cov[x]!=inf)\n    {\n        if (ch[x][0]) cover(ch[x][0],cov[x]);\n        if (ch[x][1]) cover(ch[x][1],cov[x]);\n    }\n    rev[x]=0;cov[x]=inf;\n}\nint build(int *data,int n)\n{\n    int x,last=0;static int sta[N],top;\n    for(int i=1;i<=n;i++)\n    {\n        x=new_node(data[i]),last=0;\n        while(top && tar[sta[top]]>tar[x])\n            update(sta[top]),last=sta[top],\n            sta[top--]=0;\n        if (top)\n            ch[sta[top]][1]=x;\n        ch[x][0]=last,sta[++top]=x;\n    }\n    while(top)\n        update(sta[top--]);\n    return sta[1];\n}\nvoid split(int now,int k,int &x,int &y)\n{\n    if (!now) x=y=0;\n    else\n    {\n        pushdown(now);\n        if (siz[ch[now][0]]>=k)\n            y=now,split(ch[now][0],k,x,ch[now][0]);\n        else\n            x=now,split(ch[now][1],k-siz[ch[now][0]]-1,ch[now][1],y);\n        update(now);\n    }\n}\nint merge(int x,int y)\n{\n    if (x) pushdown(x);\n    if (y) pushdown(y);\n    if (x*y==0) return x+y;\n    if (tar[x]<tar[y])\n    {\n        ch[x][1]=merge(ch[x][1],y);\n        update(x);return x;\n    }\n    else\n    {\n        ch[y][0]=merge(x,ch[y][0]);\n        update(y);return y;\n    }\n}\nvoid trash(int x)\n{\n    if (!x) return;\n    trashcan.push(x);\n    trash(ch[x][0]);\n    trash(ch[x][1]);\n}\nvoid insert()\n{\n    int pos=read(),len=read(),x,y;\n    static int datas[N];\n    for (int i=1;i<=len;i++)\n        datas[i]=read();\n    int rt=build(datas,len);\n    split(root,pos,x,y);\n    root=merge(merge(x,rt),y);\n}\nvoid delet()\n{\n    int pos=read(),len=read(),x1,x2,y1,y2;\n    split(root,pos-1,x1,x2);\n    split(x2,len,y1,y2);\n    root=merge(x1,y2);\n    trash(y1);\n}\nvoid covers()\n{\n    int pos=read(),len=read(),v=read(),x1,x2,y1,y2;\n    split(root,pos-1,x1,x2);\n    split(x2,len,y1,y2);\n    cover(y1,v);\n    root=merge(x1,merge(y1,y2));\n}\nvoid reverses()\n{\n    int pos=read(),len=read(),x1,x2,y1,y2;\n    split(root,pos-1,x1,x2);\n    split(x2,len,y1,y2);\n    reverse(y1);\n    root=merge(x1,merge(y1,y2));\n}\nvoid sums()\n{\n    int pos=read(),len=read(),x1,x2,y1,y2;\n    split(root,pos-1,x1,x2);\n    split(x2,len,y1,y2);\n    printf(\"%d\\n\",sum[y1]);\n    root=merge(x1,merge(y1,y2));\n}\nvoid maxs()\n{\n    printf(\"%d\\n\",tmx[root]);\n}\nint main() \n{ \n    srand(513);\n    static int n=read(),m=read(),a[N]; \n    for (int i=1;i<=n;i++) \n        a[i]=read();\n    root=build(a,n); \n    static char s[20]; \n    while (m--) \n    {\n        scanf(\"%s\",s); \n        if (s[0]=='I') insert();  \n        else if (s[0]=='D') delet(); \n        else if (s[0]=='M' && s[2] =='K') covers();\n        else if (s[0]=='R') reverses();\n        else if (s[0]=='G') sums();\n        else maxs(); \n    }     \n}\n```",
        "postTime": 1493192362,
        "uid": 17689,
        "name": "\u8fdc\u822a\u4e4b\u66f2",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u6765\u4e00\u7bc7fhq treap QwQ\n\n\u4e3a\u4e86\u8fd9\u9898\u8c03\u4e86\u4e00\u4e2a\u4e0a\u5348+\u4e00\u4e2a\u4e0b\u5348\uff0c\u4ea4\u4e8611\u6b21\uff0c~~\u4f4e\u4e8e\u4f60\u8c37\u5e73\u5747AC\u7387~~\uff08\u6211\u679c\u7136\u592a\u84bb\u4e86\u3002\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a\u8fd9\u91cc\u5047\u8bbe\u5404\u4f4d\u5df2\u7ecf\u719f\u7ec3\u638c\u63e1fhq treap\u7684\u57fa\u672c\u64cd\u4f5c\uff08\u4e3b\u8981\u662f`split`\u548c`merge`\uff09\uff0c\u4ee5\u53ca\u660e\u767d\u600e\u4e48\u7528\u5e73\u8861\u6811\u7ef4\u62a4\u5e8f\u5217\uff08\u5982\u679c\u4e0d\u660e\u767d\uff0c\u51fa\u95e8\u53f3\u8f6c[P3391 \u6587\u827a\u5e73\u8861\u6811](https://www.luogu.org/problemnew/show/P3391)\uff09\uff08\u5927\u81f4\u6982\u62ec\u5c31\u662f\u7528\u5e8f\u5217\u4e0b\u8868\u4f5c\u952e\u503c\uff0c\u5206\u88c2\u65f6\u6309\u5927\u5c0f\u5206\u88c2\uff09\n\n## 1.INSERT\n\nINSERT\u4e00\u4e2a\u6570\u7684\u65f6\u5019\uff0c\u5c06tot\u4e2a\u6570\u5168\u90e8\u8bfb\u5165\u4e00\u4e2a\u6570\u7ec4\uff0c\u7136\u540e\u76f4\u63a5$\\Theta(tot)$\u5efa\u5e73\u8861\u6811\uff0c\u4e0e\u539f\u6811\u5408\u5e76\u3002\n\n\u7531\u4e8e\u5728\u5408\u5e76\u7684\u65f6\u5019\u4f7f\u7528\u73b0\u573a\u751f\u6210\u968f\u673a\u503c\u800c\u975e\u8d4b\u4e88\u8282\u70b9\u968f\u673a\u6807\u8bb0\uff0c\u53ef\u4ee5\u66f4\u52a0\u7075\u6d3b\u5730\u4f7f\u7528treap\u3002\u5982\u679c\u91c7\u7528\u8d4b\u4e88\u968f\u673a\u6807\u8bb0\u7684\u65b9\u6cd5\u7684\u8bdd\uff0c\u9700\u8981\u8bbe\u8ba1\u63d2\u5165\u6811\u7684\u6807\u8bb0\u5927\u5c0f\uff0c\u5e73\u6dfb\u590d\u6742\u5ea6\uff08\u65f6\u7a7a\u4e0a\u548c\u7f16\u7a0b\u4e0a\uff09\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(logn+tot)$\n\n\u8be6\u89c1\u4ee3\u7801\u3002\n\n## 2.DELETE\n\nDELETE\u4e5f\u5f88\u7075\u6d3b\u3002\u53ea\u9700\u8981\u5c06\u539f\u6811\u5206\u5272\u51fa\u76f8\u5e94\u533a\u95f4\uff0c\u7136\u540e\u76f4\u63a5\u4e22\u6389\u3002\n\n~~\u58ee\u54c9\u6211\u5927fhq\uff01~~\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(logn)$\n\n## 3.MAKE-SAME\n\n\u53ea\u8981\u5206\u51fa\u76f8\u5e94\u533a\u95f4\uff0c\u7136\u540e\u6253\u4e2a\u6807\u8bb0\u518d\u5408\u56de\u53bb\u5c31\u597d\u5566\u3002\n\n$\\Theta(logn)$\n\n## 4.REVERSE\n\n\u672c\u8eab\u662f\u4e2a\u4eba\u755c\u65e0\u5bb3\u7684\u64cd\u4f5c\uff0c\u4f46\u662f\u52a0\u4e0a\u64cd\u4f5c6\u5c31\u6210\u4e86\u5e55\u540e\u5927BOSS\u2026\u2026\u54b3\u54b3\u3002\n\n\u89c2\u5bdf\u5230reverse\u524d\u540e\u7684\u533a\u95f4\u6700\u5927\u5b57\u6bb5\u548c\u4e0d\u53d8\uff0c\u4f46\u662f\u5982\u679creverse\u6807\u8bb0\u4e0b\u4f20\u7684\u8bdd\u5c31\u4f1a\u53d8\u6210\u4e00\u79cd\u201c\u534a\u7ffb\u8f6c\u201d\u7684\u72b6\u6001\uff0c\u8fd9\u65f6\u5019\u5982\u679c\u4e0d\u505a\u51fa\u4efb\u4f55\u6539\u53d8\u7684\u8bdd\u5c31\u5bb9\u6613WA\u3002\n\n\u9996\u5148\uff0c\u4e00\u4e0b\u5c06\u6807\u8bb0\u4e0b\u4f20\u5230\u5e95\u80af\u5b9a\u4e0d\u4e88\u8003\u8651\uff08\u5e9f\u8bdd\uff09\uff0c\u6240\u4ee5\u8003\u8651\u5728\u8282\u70b9\u6301\u6709\u6807\u8bb0\u7684\u65f6\u5019\uff0c\u4ea4\u6362\u524d\u7f00\u548c\u548c\u540e\u7f00\u548c\uff0c~~\u88c5\u4f5c\u5df2\u7ecf\u7ffb\u8f6c\u597d\u4e86\u7684\u6837\u5b50~~\u3002\n\n\u53ef\u4ee5\u9a8c\u8bc1\uff0c\u8fd9\u79cd\u505a\u6cd5\u5373\u4f7f\u4f20\u4e00\u534a\u3001\u4f20\u5f97\u53c2\u5dee\u4e0d\u9f50\u3001\u8fb9\u4f20\u8fb9\u75af\u72c2`pushup`\u90fd\u53ef\u4ee5\u4fdd\u8bc1\u7b54\u6848\u7684\u6b63\u786e\u6027\u3002\n\n\uff08\u5982\u679c\u6ca1\u6709\u770b\u61c2\u53ef\u4ee5\u8003\u8651\u5148\u770b\u5b8c\u64cd\u4f5c6\u518d\u770b\u672c\u8282\uff09\n\n## 5.GET-SUM\n\n\u76f4\u63a5\u7ef4\u62a4\u6bcf\u4e2a\u8282\u70b9\u7684\u76f8\u5e94\u548c\uff0c\u8bb0\u5f97`pushup`\u7684\u65f6\u5019\u987a\u624b\u66f4\u65b0\u5c31\u597d\u4e86\u3002\n\n## 6.MAX-SUM\n\n\u663e\u7136\u6211\u4eec\u4e0d\u80fd\u7528\u6bcf\u6b21$\\Theta(n)$\u626b\u4e00\u904d\u7684\u8d2a\u5fc3\u6765\u89e3\u51b3\u3002\n\n\u7531\u4e8e\u6811\u7ed3\u6784\u81ea\u5e26\u9012\u5f52\uff0c\u6240\u4ee5\u8003\u8651\u5982\u4f55\u7528\u5206\u6cbb\u6cd5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\u8fd9\u4e2a\u95ee\u9898\u5728\u300a\u7b97\u6cd5\u5bfc\u8bba\u300b\u91cc\u9762\u88ab\u7528\u4f5c\u5206\u6cbb\u6cd5\u7684\u4f8b\u9898\u4e4b\u4e00\u3002\u6d41\u7a0b\u662f\u8fd9\u6837\u7684\uff1a\n\n1. \u5206\u3002\n2. \u6cbb\uff0c\u6c42\u51fa\u5de6\u53f3\u5b57\u6bb5\u5185\u7684\u6700\u5927\u5b57\u6bb5\u548c\u3002\n3. \u5408\uff0c\u8de8\u4e2d\u95f4\u6c42\u548c\u3002\n\n\u5728\u8de8\u4e2d\u95f4\u6c42\u548c\u7684\u65f6\u5019\uff0c\u5b9e\u8d28\u4e0a\u662f\u5c06\u5de6\u5e8f\u5217\u7684\u6700\u5927\u540e\u7f00\u548c\u548c\u53f3\u5e8f\u5217\u6700\u5927\u524d\u7f00\u548c\u52a0\u5230\u4e00\u8d77\u3002\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u7ef4\u62a4\u6bcf\u4e2a\u533a\u95f4\u7684\u6700\u5927\u5b50\u6bb5\u548c`mms`\u3001\u6700\u5927\u524d\u7f00\u548c`mls`\u548c\u6700\u5927\u540e\u7f00\u548c`mrs`\u3002\n\n## \u5751\u70b9\n\n1. \u6682\u65f6\u6ca1\u6709\u6d4b\u8bd5\u8fc7\u5982\u679c\u628a0\u8282\u70b9pushup\u6216pushdown\u4e86\u4e4b\u540e\u7684\u540e\u679c\uff0c\u4f46\u662f\u4e0d\u77e5\u9053\u4f1a\u4e0d\u4f1aWA\u3002\n2. \u5fc5\u987b\u7528taged\\[\\]\u6570\u7ec4\u6765\u8bb0\u5f55\u8282\u70b9\u6709\u6ca1\u6709\u88ab\u66f4\u6539\u3002\u5982\u679c\u76f4\u63a5`if(tag[x])`\u7684\u8bdd\u4f1a\u5728\u4fee\u6539\u62100\u7684\u65f6\u5019\u51fa\u9519\uff08\u53ef\u80fd\u53ea\u6709\u6211\u624d\u4f1a\u72af\u8fd9\u79cd\u9519\u8bef\uff09\n3. \u6ce8\u610f\u5168\u8d1f\u7684\u60c5\u51b5\u3002\u8fd9\u91cc\u7528\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u5c06`mms`\u5f3a\u5236\u5b9a\u4e49\u6210\u5fc5\u987b\u9009\u4e00\u4e2a\uff0c\u800c`mls`\u548c`mrs`\u53ef\u4ee5\u4e3a0\u3002\n\n## AC\u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint max3(int a,int b,int c)\n{\n\treturn max(a,max(b,c));\n}\n\nint vi[4000005];\nint lt[4000005];\nint rt[4000005];\nint siz[4000005];\nint sum[4000005];\nint mls[4000005];\nint mrs[4000005];\nint mms[4000005];\nint rev[4000005];\nint tag[4000005];\nint taged[4000005];\nint top;\n\nint build(int x)\n{\n\t++top;\n\tsiz[top] = 1;\n\tsum[top] = vi[top] = x;\n\tmms[top] = x;\n\tmls[top] = mrs[top] = max(x,0);\n\treturn top;\n}\n\ninline void pushup(int x)\n{\n\tif(!x)\n\t{\n\t\treturn;\n\t}\n\tif(taged[x])\n\t{\n\t\tsiz[x] = siz[lt[x]]+siz[rt[x]]+1;\n\t\tsum[x] = tag[x]*siz[x];\n\t\t\n\t\tif(tag[x]>0)\n\t\t{\n\t\t\tmls[x] = mrs[x] = mms[x] = sum[x];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmms[x] = tag[x];\n\t\t\tmls[x] = mrs[x] = 0;\n\t\t}\n\t\t\n\t\treturn;\n\t}\n\t\n\tsum[x] = sum[lt[x]] + sum[rt[x]] + vi[x];\n\tsiz[x] = siz[lt[x]] + siz[rt[x]] + 1;\n\n\tmls[x] = max(sum[lt[x]]+vi[x]+mls[rt[x]], mls[lt[x]]);\n\tmrs[x] = max(sum[rt[x]]+vi[x]+mrs[lt[x]], mrs[rt[x]]);\n\tmms[x] = max3(mls[rt[x]]+vi[x]+mrs[lt[x]],mms[lt[x]],mms[rt[x]]);\n\t\n\tif(rev[x])\n\t{\n\t\tswap(mls[x],mrs[x]);\n\t}\n}\n\ninline void pushdown(int x)\n{\n\tif(x)\n\t{\n\t\tif(rev[x])\n\t\t{\n\t\t\tswap(lt[x],rt[x]);\n\t\t\trev[lt[x]] = !rev[lt[x]];\n\t\t\trev[rt[x]] = !rev[rt[x]];\n\t\t\tswap(mls[lt[x]],mrs[lt[x]]);\n\t\t\tswap(mls[rt[x]],mrs[rt[x]]);\n\t\t}\n\t\tif(taged[x])\n\t\t{\n\t\t\ttag[lt[x]] = tag[rt[x]] = tag[x];\n\t\t\ttaged[lt[x]] = taged[rt[x]] = 1;\n\t\t\tvi[x] = tag[x];\n\t\t\tpushup(lt[x]);\n\t\t\tpushup(rt[x]);\n\t\t}\n\t}\n\ttaged[x] = rev[x] = 0;\n}\n\nvoid split(int t,int x,int& l,int& r)\n{\n\tif(!t)\n\t{\n\t\tl = r = 0;\n\t\treturn;\n\t}\n\t\n\tpushdown(t);\n\t\n\tif(siz[lt[t]] >= x)\n\t{\n\t\tr = t;\n\t\tsplit(lt[t],x,l,lt[t]);\n\t\tpushup(r);\n\t}\n\telse\n\t{\n\t\tl = t;\n\t\tsplit(rt[t],x-siz[lt[t]]-1,rt[t],r);\n\t\tpushup(l);\n\t}\n}\n\nint merge(int l,int r)\n{\n\tif(!l || !r)\n\t{\n\t\tpushup(l);\n\t\tpushup(r);\n\t\treturn l+r;\n\t}\n\t\n\tpushdown(l);\n\tpushdown(r);\n\t\n\tif(rand()%(siz[l]+siz[r]) <= siz[l])\n\t{\n\t\trt[l] = merge(rt[l],r);\n\t\tpushup(l);\n\t\treturn l;\n\t}\n\telse\n\t{\n\t\tlt[r] = merge(l,lt[r]);\n\t\tpushup(r);\n\t\treturn r;\n\t}\n}\n\nint ai[500005];\n\nint buildarr(int l,int r)\n{\n\tif(l>r)\n\t{\n\t\treturn 0;\n\t}\n\tif(l==r)\n\t{\n\t\treturn build(ai[l]);\n\t}\n\tint mid = (l+r)>>1;\n\tint t = build(ai[mid]);\n\tlt[t] = buildarr(l,mid-1);\n\trt[t] = buildarr(mid+1,r);\n\tpushup(t);\n\treturn t;\n}\n\nchar cmd[25];\n\nint main()\n{\n\tsrand(20040703);\n\t\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tscanf(\"%d\",ai+i);\n\t}\n\t\n\tmms[0] = 0x80808080;\n\tint fhq = buildarr(1,n);\n\t\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\tscanf(\"%s\",cmd);\n\t\tif(!strcmp(cmd,\"INSERT\")) //strcmp\u5728\u76f8\u7b49\u65f6\u8fd4\u56de0\n\t\t{\n\t\t\tint l,tot;\n\t\t\tscanf(\"%d%d\",&l,&tot);\n\t\t\tfor(int i=1; i<=tot; ++i)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",ai+i);\n\t\t\t}\n\t\t\t\n\t\t\tint ll,rr;\n\t\t\tsplit(fhq,l,ll,rr);\n\t\t\t\n\t\t\tfhq = merge(ll,merge(buildarr(1,tot),rr));\n\t\t}\n\t\telse if(!strcmp(cmd,\"DELETE\"))\n\t\t{\n\t\t\tint l,tot;\n\t\t\tscanf(\"%d%d\",&l,&tot);\n\t\t\t\n\t\t\tint ll,ans,rr;\n\t\t\tsplit(fhq,l-1,ll,rr);\n\t\t\tsplit(rr,tot,ans,rr);\n\t\t\t\n\t\t\tfhq = merge(ll,rr);\n\t\t}\n\t\telse if(!strcmp(cmd,\"MAKE-SAME\"))\n\t\t{\n\t\t\tint l,tot,c;\n\t\t\tscanf(\"%d%d%d\",&l,&tot,&c);\n\t\t\t\n\t\t\tint ll,ans,rr;\n\t\t\tsplit(fhq,l-1,ll,rr);\n\t\t\tsplit(rr,tot,ans,rr);\n\t\t\t\n\t\t\ttag[ans] = c;\n\t\t\ttaged[ans] = 1;\n\t\t\tpushup(ans);\n\t\t\t\n\t\t\tfhq = merge(ll,merge(ans,rr));\n\t\t}\n\t\telse if(!strcmp(cmd,\"REVERSE\"))\n\t\t{\n\t\t\tint l,tot;\n\t\t\tscanf(\"%d%d\",&l,&tot);\n\t\t\t\n\t\t\tint ll,ans,rr;\n\t\t\tsplit(fhq,l-1,ll,rr);\n\t\t\tsplit(rr,tot,ans,rr);\n\t\t\t\n\t\t\trev[ans] = !rev[ans];\n\t\t\tswap(mls[ans],mrs[ans]);\n\t\t\t\n\t\t\tfhq = merge(ll,merge(ans,rr));\n\t\t}\n\t\telse if(!strcmp(cmd,\"GET-SUM\"))\n\t\t{\n\t\t\tint l,tot;\n\t\t\tscanf(\"%d%d\",&l,&tot);\n\t\t\t\n\t\t\tint ll,ans,rr;\n\t\t\tsplit(fhq,l-1,ll,rr);\n\t\t\tsplit(rr,tot,ans,rr);\n\t\t\t\n\t\t\tprintf(\"%d\\n\",sum[ans]);\n\t\t\t\n\t\t\tfhq = merge(ll,merge(ans,rr));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",mms[fhq]);\n\t\t}\n\t}\n}\n```",
        "postTime": 1563612170,
        "uid": 49458,
        "name": "\u6728\u6728\uff01",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u672c\u849f\u84bb\u5199\u7684\u7b2c\u4e00\u9053\u5e73\u8861\u6811\u5927\u9898\uff0c\u53d1\u4e2a\u9898\u89e3\u7eaa\u5ff5\u4e00\u4e0b\u3002    \n## \u524d\u8a00\uff1a\n\u672c\u849f\u84bb\u4f7f\u7528\u7684\u662ffhq_treap\uff0c\u76f8\u5bf9\u6765\u8bf4\u53ef\u80fd\u4f1a\u77ed\u4e00\u70b9(~~\u4f46\u662f\u7531\u4e8e\u6211\u592a\u83dc\u4e86\u6240\u4ee5\u770b\u8d77\u6765\u8fd8\u662f\u5f88\u957f~~\uff09  \n\u672c\u7bc7\u9898\u89e3\u5b9e\u73b0\u53c2\u8003\u4e86 @x\u4e49x \u5927\u4f6c\u7684\u4ee3\u7801\uff08~~\u7a9d\u592a\u83dc\u4e86\u81ea\u5df1\u5199\u4e0d\u51fa~~\uff09  \n## \u6b63\u9898:\n \u770b\u9898\uff1a\u60ca\u4eba\u7684\u65f6\u95f4\u9650\u5236\u2014\u20141s\uff0c\u4e8e\u662f\u53ef\u4ee5\u5148\u505a\u4e00\u624b\u5361\u5e38\u7684\u51c6\u5907\u4e86\u3002\u518d\u770b\u7a7a\u95f4\u4e0a\u7684\u9650\u5236\u548c\u672c\u9898\u76ee\u4e2d\u90a3\u4e00\u5806\u64cd\u4f5c\uff0c\u60f3\u90fd\u4e0d\u7528\u60f3\u5c31\u77e5\u9053\u80af\u5b9a\u8981\u7ef4\u62a4\u4e00\u5927\u5806\u4e1c\u897f\uff0c4e6\u7684\u6570\u636e\u8303\u56f4128MB\u5f00\u5f97\u4e0b\u6211\u89c9\u5f97\u6bd4\u8f83\u96be\uff0c\u9898\u76ee\u53c8\u4fdd\u8bc1\u4e86\u540c\u4e00\u65f6\u95f4\u5185\u8282\u70b9\u6570\u5c0f\u4e8e\u7b49\u4e8e5e5\uff0c\u6240\u4ee5\u8282\u70b9\u56de\u6536\u662f\u80af\u5b9a\u7684\u3002\u7136\u540e\u6211\u4eec\u5f00\u59cb\u4e00\u6b65\u6b65\u89e3\u51b3\u8fd9\u4e2a\u9898\u76ee\u3002\n\u5148\u628a\u8282\u70b9\u5b9a\u4e49\u653e\u51fa\u6765\uff1a\n```cpp\nstruct Node\n{\n\tint lson,rson,siz,val,cov,rnd;   //cov\u4e3a\u533a\u95f4\u8986\u76d6\u64cd\u4f5c\u6240\u8981\u4f7f\u7528\u7684\u503c\n\tint lazy_rev,lazy_cov;  //\u8fd9\u4e24\u4e2a\u6807\u8bb0\u5f88\u663e\u7136\u5427emmm...\n\tint sum,pre_mx,suc_mx,all_mx;  //\u524d\u7f00\u6700\u5927\u503c\uff0c\u540e\u7f00\u6700\u5927\u503c\uff0c\u603b\u6700\u5927\u503c\uff0c\u548c\n}t[MAXN];int rt;\n\n#define ls(x) t[x].lson //\u5b8f\u5b9a\u4e49\u2014\u2014\u5077\u61d2\u4e13\u7528\n#define rs(x) t[x].rson\n```\n\n### \u4e00\u3001\u5982\u4f55\u56de\u6536\u8282\u70b9\uff1f\n\u8003\u8651\u5f00\u4e00\u4e2a\u6808\u6765\u5b58\u6ca1\u6709\u7528\u7684\u8282\u70b9\uff0c\u5220\u9664\u8282\u70b9\u7684\u65f6\u5019\u5c31\u628a\u90a3\u4e9b\u88ab\u5220\u7684\u8282\u70b9\u5806\u8fdb\u53bb\u5c31\u884c\uff0c\u5728\u4ee3\u7801\u91cc\u6709\u6e05\u695a\u7684\u4f53\u73b0  \n\n### \u4e8c\u3001\u5982\u4f55\u7ef4\u62a4\u7b54\u6848\uff1f\n\u5bf9\u4e8e\u6700\u5927\u5b50\u6bb5\u548c\u7684\u7ef4\u62a4\u8003\u8651\u7ef4\u62a4\u4e00\u4e2a\u524d\u7f00\u6700\u5927\u548c\uff0c\u540e\u7f00\u6700\u5927\u548c \u548c \u81ea\u8eab\u8fd9\u68f5\u6811\u5185\u7684\u6700\u5927\u548c\uff0c\u5982\u4f55\u5408\u5e76\u5462\uff1f\n```cpp\ninline void Update(int x)\n{\n\tif(!x) return ;\n\tt[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;\n\tt[x].sum=t[ls(x)].sum+t[rs(x)].sum+t[x].val;\n\tt[x].pre_mx=max(t[ls(x)].pre_mx,t[ls(x)].sum+t[x].val+t[rs(x)].pre_mx,0);\n\tt[x].suc_mx=max(t[rs(x)].suc_mx,t[rs(x)].sum+t[x].val+t[ls(x)].suc_mx,0);\n\tt[x].all_mx=max(t[x].val,t[x].val+t[ls(x)].suc_mx+t[rs(x)].pre_mx);\n\tif(ls(x)) t[x].all_mx=max(t[x].all_mx,t[ls(x)].all_mx);\n\tif(rs(x)) t[x].all_mx=max(t[x].all_mx,t[rs(x)].all_mx);\n}\n```\n\u5c31\u8fd9\u4e2a\u6837\u5b50\u3002\u56e0\u4e3a\u524d\u7f00\u540e\u7f00\u90fd\u662f\u53ef\u4ee5\u4e0d\u53d6\u7684\u6240\u4ee5\u53ef\u4ee5\u4e3a0\uff0c\u4f46\u662f\u81ea\u8eab\u4e0d\u80fd\u53d60\uff0c\u56e0\u4e3a\u9898\u76ee\u5f3a\u5236\u5fc5\u987b\u53d6\u4e00\u4e2a(~~\u6709\u6bd2.....~~)\n\n### \u4e09\u3001\u5982\u4f55\u4e0b\u653e\u6807\u8bb0\uff1f\n\u662f\u4e0d\u662ffhq_treap\u7684\u9898\u76ee\u90fd\u53ea\u8981\u5728split\u7684\u65f6\u5019\u4e22\u6807\u8bb0\u554a......  \n(~~\u53cd\u6b63\u5b83\u8fc7\u4e86~~\uff09\n\n### \u56db\u3001\u8fd9\u4efd\u4ee3\u7801\u6709\u9505\u5417\uff0c\u53ef\u4ee5\u6284\u5417\n~~\u663e\u7136\u4f60\u662f\u53ef\u4ee5\u6284\u7684~~  \n\u4f46\u662f\u8fd9\u4e2a\u4ee3\u7801\u6709\u4e00\u4e2a\u5f88\u795e\u5947\u4e8b\u60c5\u5c31\u662f\u5f00\u4e0d\u4e86O2\uff0c\u4e00\u5f00O2\u5c31RE\uff0c\u6709\u6ca1\u6709\u54ea\u4f4d\u5927\u4f6c\u544a\u8bc9\u6211\u8fd9\u662f\u4e3a\u5565\u54405555.   \nOrz Orz Orz  \n\n### \u4e94\u3001\u5173\u4e8e\u4ee3\u7801\u91cc\u7684max\n\u6211\u6bd4\u8f83\u61d2\uff0c\u5c31\u91cd\u8f7d\u4e86\u4e00\u4e2a\u4e09\u4e2a\u53c2\u6570\u7684max\n\n### \u516d\u3001code  \n```cpp\n#include <cstdio>\n\n#define R register\nconst int MAXN=5e5+10;\nconst int RAND_1=1e9+7;\nconst int RAND_2=1e9+9;\n\ninline int read()\n{\n\tchar a=getchar();int x=0,f=1;\n\tfor(;a>'9'||a<'0';a=getchar()) if(a=='-') f=-1;\n\tfor(;a>='0'&&a<='9';a=getchar()) x=x*10+a-'0';\n\treturn x*f;\n}\n\nint Seed='L'+'C'+'N'+'B'+171098569;\ninline int swap(int &x,int &y) { x^=y;y^=x;x^=y; }\ninline int max(int x,int y) { return x>y?x:y;}\ninline int max(int x,int y,int z) { return max(x,max(y,z)); }\ninline int rand() { return Seed=(Seed*RAND_1+0x7f7f7f7f)*RAND_2*Seed; }\n\nint n,m;\nint stk[MAXN],cnt;\n\nstruct Node\n{\n\tint lson,rson,siz,val,cov,rnd;\n\tint lazy_rev,lazy_cov;\n\tint sum,pre_mx,suc_mx,all_mx;\n}t[MAXN];int rt;\n\n#define ls(x) t[x].lson\n#define rs(x) t[x].rson\n\ninline int New(int k)\n{\n\tint x=stk[cnt--];\n\tls(x)=rs(x)=t[x].cov=t[x].lazy_rev=t[x].lazy_cov=0;\n\tt[x].siz=1;\n\tt[x].val=t[x].sum=k;\n\tt[x].pre_mx=t[x].suc_mx=max(0,k);\n\tt[x].all_mx=k;\n\tt[x].rnd=rand();\n\treturn x;\n}\n\ninline void Update(int x)\n{\n\tif(!x) return ;\n\tt[x].siz=t[ls(x)].siz+t[rs(x)].siz+1;\n\tt[x].sum=t[ls(x)].sum+t[rs(x)].sum+t[x].val;\n\tt[x].pre_mx=max(t[ls(x)].pre_mx,t[ls(x)].sum+t[x].val+t[rs(x)].pre_mx,0);\n\tt[x].suc_mx=max(t[rs(x)].suc_mx,t[rs(x)].sum+t[x].val+t[ls(x)].suc_mx,0);\n\tt[x].all_mx=max(t[x].val,t[x].val+t[ls(x)].suc_mx+t[rs(x)].pre_mx);\n\tif(ls(x)) t[x].all_mx=max(t[x].all_mx,t[ls(x)].all_mx);\n\tif(rs(x)) t[x].all_mx=max(t[x].all_mx,t[rs(x)].all_mx);\n}\n\ninline void Reverse(int x)\n{\n\tif(!x) return ;\n\tswap(ls(x),rs(x));\n\tswap(t[x].pre_mx,t[x].suc_mx);\n\tt[x].lazy_rev^=1;\n}\n\ninline void Cover(int x,int col)\n{\n\tt[x].val=t[x].cov=col;\n\tt[x].sum=t[x].siz*col;\n\tt[x].pre_mx=t[x].suc_mx=max(0,t[x].sum);\n\tt[x].all_mx=max(col,t[x].sum);\n\tt[x].lazy_cov=1;\n}\n\ninline void Pushdown(int x)\n{\n\tif(!x) return ;\n\tif(t[x].lazy_rev)\n\t{\n\t\tif(ls(x)) Reverse(ls(x));\n\t\tif(rs(x)) Reverse(rs(x));\n\t\tt[x].lazy_rev=0;\n\t}\n\tif(t[x].lazy_cov)\n\t{\n\t\tif(ls(x)) Cover(ls(x),t[x].cov);\n\t\tif(rs(x)) Cover(rs(x),t[x].cov);\n\t\tt[x].lazy_cov=t[x].cov=0;\n\t}\n}\n\ninline void Delete(int x)\n{\n\tif(!x) return;\n\tstk[++cnt]=x;\n\tif(ls(x)) Delete(ls(x));\n\tif(rs(x)) Delete(rs(x));\n}\n\ninline void Split(int now,int k,int &x,int &y)\n{\n\tif(!now) { x = y = 0; return ; }\n\tPushdown(now);\n\tif(t[ls(now)].siz+1<=k)\n\t{\n\t\tx=now;\n\t\tSplit(rs(now),k-t[ls(now)].siz-1,rs(now),y);\n\t} \n\telse\n\t{\n\t\ty=now;\n\t\tSplit(ls(now),k,x,ls(now));\n\t}\n\tUpdate(now);\n}\n\ninline int Merge(int x,int y)\n{\n\tif(!x||!y) return x|y;\n\tif(t[x].rnd<t[y].rnd)\n\t{\n\t\tPushdown(x);\n\t\trs(x)=Merge(rs(x),y);\n\t\tUpdate(x); return x;\n\t}\n\telse\n\t{\n\t\tPushdown(y);\n\t\tls(y)=Merge(x,ls(y));\n\t\tUpdate(y); return y;\n\t}\n}\n\nint array[MAXN];\n\ninline int Build(int l,int r)\n{\n\tif(l==r) return New(array[l]);\n\tint mid=l+r;mid>>=1;\n\treturn Merge(Build(l,mid),Build(mid+1,r));\n}\n\nchar opt[10];\n\nint main()\n{\n\tn=read();m=read();\n\tfor(R int i=1;i<MAXN;i++) stk[++cnt]=i;\n\tfor(R int i=1;i<=n;i++) array[i]=read();\n\trt=Build(1,n);\n\twhile(m--)\n\t{\n\t\tscanf(\"%s\",opt);\n\t\tif(opt[0]=='I')\n\t\t{\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y;\n\t\t\tSplit(rt,pos,x,y);\n\t\t\tfor(R int i=1;i<=tot;i++) array[i]=read();\n\t\t\tx=Merge(x,Build(1,tot));\n\t\t\trt=Merge(x,y);\n\t\t}\n\t\tif(opt[0]=='D')\n\t\t{\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,pos-1,x,y);\n\t\t\tSplit(y,tot,y,z);\n\t\t\tDelete(y);\n\t\t\trt=Merge(x,z);\n\t\t}\n\t\tif(opt[2]=='K')\n\t\t{\n\t\t\tint pos=read(),tot=read(),col=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,pos-1,x,y);\n\t\t\tSplit(y,tot,y,z);\n\t\t\tCover(y,col);\n\t\t\trt=Merge(Merge(x,y),z);\n\t\t}\n\t\tif(opt[0]=='R')\n\t\t{\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,pos-1,x,y);\n\t\t\tSplit(y,tot,y,z);\n\t\t\tReverse(y);\n\t\t\trt=Merge(Merge(x,y),z);\n\t\t}\n\t\tif(opt[0]=='G')\n\t\t{\n\t\t\tint pos=read(),tot=read();\n\t\t\tint x,y,z;\n\t\t\tSplit(rt,pos-1,x,y);\n\t\t\tSplit(y,tot,y,z);\n\t\t\tprintf(\"%d\\n\",t[y].sum);\n\t\t\trt=Merge(Merge(x,y),z);\n\t\t}\n\t\tif(opt[2]=='X')\n\t\t{\n\t\t\tprintf(\"%d\\n\",t[rt].all_mx);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1581930671,
        "uid": 139012,
        "name": "______OvO______",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u7684\u89e3\u6cd5\u5176\u4ed6\u9898\u89e3\u8bf4\u7684\u5df2\u7ecf\u5f88\u6e05\u695a\u4e86\n\n\u5982\u679c\u5927\u5bb6\u4f1asplay/fhq-treap\u8fd9\u9053\u9898\u7684\u505a\u6cd5\u662f\u5f88\u663e\u7136\u7684\uff0c\u8fd9\u9053\u9898\u4e3b\u8981\u8003\u9a8c\u7684\u662f\u7801\u529b/debug\u80fd\u529b/\u809d\n\n\u4f46\u662f\u8fd9\u9053\u9898\u5361\u7a7a\u95f4\uff0c\u4e5f\u5c31\u662f\u9700\u8981\u5783\u573e\u56de\u6536\uff08delete\u6389\u7684\u70b9\u7684\u7a7a\u95f4\u9700\u8981\u518d\u5229\u7528\uff09   \n\u5f88\u591a\u4eba\u4f1a\u4e60\u60ef\u5f00\u4e00\u4e2a\u961f\u5217/\u6808\u6765\u8bb0\u5f55\u5783\u573e,\u4e4b\u540e\u4f18\u5148\u4ece\u961f\u5217/\u6808\u91cc\u53d6\u70b9\uff0c\u5982\u679c\u6ca1\u6709\u518d\u65b0\u5f00\u70b9,\u5176\u5b83\u9898\u89e3\u4e5f\u90fd\u662f\u8fd9\u4e48\u5199\u7684\n\n\u8fd9\u79cd\u505a\u6cd5\u6709\u4e24\u4e2a\u7f3a\u70b9\uff0c\u4e00\u662f\u90a3\u4e2a\u961f\u5217/\u6808\u672c\u8eab\u662f\u5360\u7a7a\u95f4\u7684\uff0c\u5982\u679c\u6709\u8d85\u6bd2\u7624\u7684\u4eba\u5361\u4f60\u5c31\u4f1agg,\u4e8c\u662f\u8981\u5199\u597d\u591a\u884c\u4ee3\u7801\n\n\u6240\u4ee5\u6211\u4f7f\u7528\u4e86\u53e6\u5916\u4e00\u79cd\u65b9\u6cd5\uff08\u53ea\u80fd\u5728\u6307\u9488\u7248\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e2d\u4f7f\u7528\uff09\n```cpp\n\n#include<new>\n\nnode* nw = new node;\ndelete nw;\n\n```\n\u5f88\u591a\u4eba\u89c9\u5f97\u6307\u9488\u7248\u7684\u4e1c\u897f\u4e0d\u597d,\u5bb9\u6613RE,\u4f46\u5199\u4e2a\u767e\u516b\u5341\u904d\u5c31\u5f88\u5bb9\u6613\u770b\u51fa\u6765\u662f\u54ea\u91cc\u9519\u4e86  \n\u800c\u4e14\uff0c\u6307\u9488\u7248\u7684\u8fd8\u53ef\u4ee5\u7528new(\u4e5f\u5c31\u662f\u8fd9\u91cc\u6211\u7528\u7684\u5783\u573e\u56de\u6536\u7684\u4e1c\u897f)\n\n\u8fd9\u79cd\u6280\u5de7\u662f\u53ef\u4ee5\u5728c++98\u4e2d\u4f7f\u7528\u7684\uff0c\u53ea\u8981\u5f15\u7528\u90a3\u4e2a\u5e93\u5c31\u884c\n\nnew\u662fc++\u81ea\u5e26\u7684\u4e00\u4e2a\u5185\u5b58\u5206\u914d\u7684\u4e1c\u897f,\u53ef\u4ee5\u66ff\u4ee3\u4f60\u4eec\u4e4b\u524d\u719f\u6089\u7684\n```cpp\nnode pool[maxn];\nint ps;\n\nnode* nw=pool+ps++;\n\n```\n\u800c\u5220\u9664\u5c31\u76f4\u63a5delete\u90a3\u4e2a\u6307\u9488\u5c31\u884c\u4e86\n\n\u4f46\u8fd9\u79cd\u505a\u6cd5\u7684\u7f3a\u70b9\u662f\u6162,\u5982\u679c\u4f60\u88ab\u5361\u65f6\u95f4\u800c\u4e0d\u662f\u7a7a\u95f4\u7684\u8bdd\u8fd8\u662f\u8981\u6362\u56de\u4f20\u7edf\u5199\u6cd5\n\n\u6240\u4ee5\uff0c\u5949\u4e0a\u6211\u7528\u4e86new/delete\u7684\u6307\u9488\u7248fhq-treap\u4ee3\u7801\uff0c\u5982\u679c\u8fd8\u4e0d\u660e\u767dnew/delete\u7684\u7528\u6cd5\u7684\u8bdd\u53ef\u4ee5\u770b\u4ee3\u7801\u4e2d\u7684\u5b9e\u73b0\n\n```cpp\n#include<iostream>\n#include<new>\n#include<cstring>\n#include<cstdlib>\n\nusing namespace std;\n\nconst int maxn=500005;\n\nstruct node{\n    int tgr,tgc;\n    int lm,rm,tm,sum;\n    int rnd,sze,val;\n    node* c[2];\n};\n\nnode* nwnode(int v){\n    node* nw=new node;\n    nw->tgr=0;nw->tgc=0x3fff3fff;nw->lm=nw->rm=nw->tm=nw->sum=nw->val=v;nw->rnd=rand();nw->sze=1;\n    return nw;\n}\n\nint gsz(node* rt){\n    return rt?rt->sze:0;\n}\nint gsm(node* rt){\n    return rt?rt->sum:0;\n}\nint glm(node* rt){\n    return rt?rt->lm:0xd0c0c0c0;\n}\nint grm(node* rt){\n    return rt?rt->rm:0xd0c0c0c0;\n}\nint gtm(node* rt){\n    return rt?rt->tm:0xd0c0c0c0;\n}\nvoid pu(node* rt){\n    if(!rt) return;\n    rt->sze=gsz(rt->c[0])+gsz(rt->c[1])+1;\n    rt->sum=gsm(rt->c[0])+rt->val+gsm(rt->c[1]);\n    rt->lm=max(glm(rt->c[0]),gsm(rt->c[0])+rt->val+max(0,glm(rt->c[1])));\n    rt->rm=max(grm(rt->c[1]),gsm(rt->c[1])+rt->val+max(0,grm(rt->c[0])));\n    rt->tm=max(max(gtm(rt->c[0]),gtm(rt->c[1])),rt->val+max(0,grm(rt->c[0]))+max(0,glm(rt->c[1])));\n}\nvoid pd(node* rt){\n    if(!rt) return;\n    if(rt->tgc!=0x3fff3fff){\n        rt->sum=rt->sze*rt->tgc;\n        rt->val=rt->tgc;\n        if(rt->tgc<0){\n            rt->lm=rt->rm=rt->tm=rt->tgc;\n        }else{\n            rt->lm=rt->rm=rt->tm=rt->tgc*rt->sze;\n        }\n        if(rt->c[0]) rt->c[0]->tgc=rt->tgc;\n        if(rt->c[1]) rt->c[1]->tgc=rt->tgc;\n        rt->tgc=0x3fff3fff;\n    }\n    if(rt->tgr){\n        swap(rt->c[0],rt->c[1]);\n        swap(rt->lm,rt->rm);\n        if(rt->c[0]) rt->c[0]->tgr^=1;\n        if(rt->c[1]) rt->c[1]->tgr^=1;\n        rt->tgr=0;\n    }\n}\nvoid del(node* rt){\n    if(!rt) return;\n    del(rt->c[0]);\n    del(rt->c[1]);\n    delete rt;\n}\n\nvoid spk(node* rt,int k,node*& a,node*& b){\n    if(!rt){\n        a=b=NULL;\n        return;\n    }\n    pd(rt);\n    if(k>gsz(rt->c[0])){\n        a=rt;\n        spk(rt->c[1],k-gsz(rt->c[0])-1,a->c[1],b);\n        pd(a->c[0]);pd(a->c[1]);pu(a);\n    }else{\n        b=rt;\n        spk(rt->c[0],k,a,b->c[0]);\n        pd(b->c[0]);pd(b->c[1]);pu(b);\n    }\n}\n\nnode* mrg(node* a,node* b){\n    if(!a){\n        pd(b);return b;\n    }\n    if(!b){\n        pd(a);return a;\n    }\n    pd(a);pd(b);\n    if(a->rnd>b->rnd){\n        a->c[1]=mrg(a->c[1],b);\n        pd(a->c[0]);pd(a->c[1]);pu(a);\n        return a;\n    }else{\n        b->c[0]=mrg(a,b->c[0]);\n        pd(b->c[0]);pd(b->c[1]);pu(b);\n        return b;\n    }\n}\n\nint a[maxn];\nint n,m;\n\nnode* bt(int l,int r){\n    if(r<l) return NULL;\n    int m=(l+r)/2;\n    node* rt=nwnode(a[m]);\n    rt->c[0]=bt(l,m-1);\n    rt->c[1]=bt(m+1,r);\n    pu(rt);\n    return rt;\n}\n\nvoid dfs(node* rt){\n    if(!rt) return;\n    pd(rt);\n    cout<<\"{\";\n    dfs(rt->c[0]);\n    cout<<'('<<rt->val<<','<<rt->sum<<','<<rt->tm<<')';\n    dfs(rt->c[1]);\n    cout<<\"}\";\n}\nint main(){\n    ios::sync_with_stdio(0);\n    srand(time(0));\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>a[i];\n    }\n    node* rt=bt(1,n);\n    while(m--){\n        char op[20];\n        int p;\n        cin>>op;\n        if(op[2]=='S'){\n            cin>>p>>n;\n            if(n==0) continue;\n            for(int i=1;i<=n;i++)cin>>a[i];\n            node* nw=bt(1,n);\n            node *a,*b;\n            spk(rt,p,a,b);\n            rt=mrg(mrg(a,nw),b);\n        }else if(op[2]=='L'){\n            cin>>p>>n;\n            if(n==0) continue;\n            node *a,*b,*c,*d;\n            spk(rt,p-1,a,b);\n            spk(b,n,c,d);\n            rt=mrg(a,d);\n            del(c);\n        }else if(op[2]=='K'){\n            int cl;cin>>p>>n>>cl;\n            if(n==0) continue;\n            node *a,*b,*c,*d;\n            spk(rt,p-1,a,b);\n            spk(b,n,c,d);\n            c->tgc=cl;\n            pd(c);\n            rt=mrg(a,mrg(c,d));\n        }else if(op[2]=='V'){\n            cin>>p>>n;\n            if(n==0) continue;\n            node *a,*b,*c,*d;\n            spk(rt,p-1,a,b);\n            spk(b,n,c,d);\n            c->tgr^=1;\n            pd(c);\n            rt=mrg(a,mrg(c,d));\n        }else if(op[2]=='T'){\n            cin>>p>>n;\n            if(n==0){\n                cout<<0<<'\\n';continue;\n            }\n            node *a,*b,*c,*d;\n            spk(rt,p-1,a,b);\n            spk(b,n,c,d);\n            cout<<c->sum<<'\\n';\n            rt=mrg(a,mrg(c,d));\n        }else if(op[2]=='X'){\n            cout<<rt->tm<<'\\n';\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1558855585,
        "uid": 62598,
        "name": "dengyaotriangle",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u8003\u8651\u7528fhqtreap\u6765\u5199\uff0c\u6700\u5927\u5b50\u6bb5\u548c\u7ef4\u62a4\u8d77\u6765\u6bd4\u7ebf\u6bb5\u6811\u8981\u65b9\u4fbf\uff0c\u5efa\u6811\u7684\u65f6\u5019\u5229\u7528\u7b1b\u5361\u5c14\u6811\u7684\u5efa\u6811\u65b9\u6cd5\u5c31\u884c\u4e86\u3002\u3002\u3002\n\n\u4ee5\u524d\u7684\u65f6\u5019\u6211\u5199\u7684\u662f\u66b4\u529b\u63d2\u5165\u5efa\u6811\u3002\u975e\u5e38\u4e4b\u8822\u3002\u3002\u3002\n\n\u6ce8\u610f\uff0c\u7b54\u6848\u5fc5\u987b\u81f3\u5c11\u9009\u4e00\u4e2a\u6570\u3002\n\n\u90a3\u4e48\u5728upd\u7684\u65f6\u5019\u5229\u7528uls.mx,urs.mx\u66f4\u65b0\u7684\u65f6\u5019\u6ce8\u610f\u662f\u5426\u6709\u5de6\u53f3\u513f\u5b50\u5c31\u884c\u4e86\u3002\n\n\u7136\u540e\u7684\u95ee\u9898\u5c31\u662f\u533a\u95f4\u4fee\u6539\uff0c\u5b9e\u9645\u4e0a\u548c\u7ebf\u6bb5\u6811\u7684\u6253\u6807\u8bb0\u4e00\u6837\uff0c\u6ce8\u610fmerge\u548csplit\u7684\u65f6\u5019\u8981\u5148pushdown\u3002\n\n\u5efa\u6811\u7684\u65f6\u5019\u4e0d\u8981\u5fd8\u4e86\u628a\u6808\u91cc\u7684\u6240\u6709\u5143\u7d20\u90fd\u6e05\u7a7aupd\u3002\n\n```cpp\n# include <bits/stdc++.h>\n\nusing namespace std;\n\n# define REP(i, a, b) for(int i = a; i <= b; ++ i)\n# define REPD(i, a, b) for(int i = a; i >= b; -- i)\n# define CLR(i, a) memset(i, a, sizeof(i))\n# define REPG(i, h, x) for(int i = h[x]; ~i; i = edge[i].next)\n# define QAQ puts(\"*\")\n\nconst int N = 5e5 + 3, INF = 0x7fffffff;\n\nint n, a[N];\nchar buf[20];\n\n# define gc getchar\ninline int rd() {\n\tchar ch = gc(); int ret = 0, sgn = 1;\n\twhile(ch < '0' || ch > '9') { if(ch == '-') sgn = -1; ch = gc(); }\n\twhile(ch >= '0' && ch <= '9') ret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n\nstruct Treap {\n\t# define u tr[x]\n\t# define o tr[y]\n\t# define uls tr[u.ls]\n\t# define urs tr[u.rs]\n\t\n\tstruct node {  \n\t\tint lmx, rmx, mx, sum, ls, rs, sz, co, val;\n\t\tbool re;\n\t\tint prio;\n\t\tnode() { lmx = rmx = mx = sum = re = prio = ls = rs = sz = val = 0, co = INF; }\n\t\tvoid init(int _l, int _r, int _m, int _s, int _sz, int _val) { \n\t\t\tlmx = _l, rmx = _r, mx = _m, sum = _s, prio = rand(), sz = _sz, val = _val;\n\t\t}\n\t\tvoid rev() { re ^= 1, swap(ls, rs), swap(lmx, rmx); }\n\t\tvoid cov(int c) {\n\t\t\tco = val = c;\n\t\t\tsum = co * sz;\n\t\t\tlmx = max(0, sum), rmx = max(0, sum);\n\t\t\tmx = max(sum, co);\n\t\t}\n\n\t} tr[N];\n\n\tint tot, mptp;\n\t# define pb push\n\tqueue<int> memp;\n\tvoid del(int x) {\n\t\tmemp.pb(x);\n\t\tif(u.ls) del(u.ls);\n\t\tif(u.rs) del(u.rs);\n\t}\n\n\tinline int malloc() { \n\t\tint x;\n\t\treturn (!memp.empty()) ? (tr[x = memp.front()] = node(), memp.pop(), x) : (tr[++ tot] = node(), tot); \n\t}\n\tint rt;\n\n\t# define pii pair<int, int>\n\t# define mp make_pair\n\t# define sec second\n\t# define fir first\n\n\tvoid pd(int x) {\n\t\tif(!x) return ;\n\t\tif(u.re) {\n\t\t\tif(u.ls) uls.rev();\n\t\t\tif(u.rs) urs.rev();\n\t\t\tu.re ^= 1;\n\t\t}\n\t\tif(u.co != INF) {\n\t\t\tif(u.ls) uls.cov(u.co);\n\t\t\tif(u.rs) urs.cov(u.co);\n\t\t\tu.co = INF;\n\t\t}\n\t}\n\n\tvoid upd(int x) {\n\t\tif(!x) return ;\n\t\tu.sz = uls.sz + 1 + urs.sz;\n\t\tu.sum = uls.sum + urs.sum + u.val;\n\t\tu.mx = max(uls.rmx + u.val + urs.lmx, u.val);\n\t\tif(u.ls) u.mx = max(u.mx, uls.mx);\n\t\tif(u.rs) u.mx = max(u.mx, urs.mx);\n\t\tu.lmx = max(max(uls.sum + u.val + urs.lmx, uls.lmx), 0);\n\t\tu.rmx = max(max(urs.sum + u.val + uls.rmx, urs.rmx), 0);\n\t}\n\n\tint merge(int x, int y) {\n\t\tif(x) pd(x); \n\t\tif(y) pd(y);\n\t\tif(x == 0 || y == 0) return (x ? x : y);\n\t\tif(u.prio < o.prio) return o.ls = merge(x, o.ls), upd(y), y;\n\t\telse return u.rs = merge(u.rs, y), upd(x), x;\n\t}\n\n\tpii split(int x, int k) {\n\t\tif(!k) return mp(0, x); // ---------\n\t\tpd(x); \n\t\tif(uls.sz + 1 <= k) {\n\t\t\tpii tmp = split(u.rs, k - uls.sz - 1);\n\t\t\tu.rs = tmp.fir, upd(x);\n\t\t\treturn mp(x, tmp.sec);\n\t\t}\n\t\telse {\n\t\t\tpii tmp = split(u.ls, k);\n\t\t\tu.ls = tmp.sec, upd(x);\n\t\t\treturn mp(tmp.fir, x);\n\t\t}\n\t}\n\n\tint stk[N], tp;\n\tint build(int *b, int l) {\t\n\t\ttp = 0;\n\t\tint tmp = malloc();\n\t\ttr[tmp].init(max(0, b[1]), max(0, b[1]), b[1], b[1], 1, b[1]);\n\t\tstk[++ tp] = tmp;\n\t\tREP(i, 2, l) {\n\t\t\tint x = malloc(), pre = 0;\n\t\t\tu.init(max(0, b[i]), max(0, b[i]), b[i], b[i], 1, b[i]);\n\t\t\twhile(tp && tr[stk[tp]].prio < u.prio) pre = stk[tp --], upd(pre);\n\t\t\tif(tp) tr[stk[tp]].rs = x;\n\t\t\tu.ls = pre, stk[++ tp] = x;\n\t\t\tif(tp == 1) tmp = x; // !!!!!!!!!!\n//\t\t\tprintf(\"%d %d %d %d\\n\", stk[tp], x, u.ls, pre);\n\t\t}\n\t\twhile(tp) upd(stk[tp --]);\n\t\treturn tmp;\n\t} \n\n\tvoid ins_seq() {\n\t\tint k = rd(), m = rd();\n    \t    \tREP(i, 1, m) a[i] = rd();\n    \t    \tint y = build(a, m);\n    \t    \tpii tmp = split(rt, k);\n    \t    \ty = merge(tmp.fir, y);\n    \t    \trt = merge(y, tmp.sec);\n\t}\n\n\tvoid del_seq() {\n\t\tint k = rd(), m = rd();\n    \t    \tpii pt1 = split(rt, k - 1);\n    \t    \tpii pt2 = split(pt1.sec, m);\n    \t    \tdel(pt2.fir);\n    \t    \trt = merge(pt1.fir, pt2.sec);\n\t}\n\n\tvoid cov_seq() {\n\t\tint k = rd(), m = rd(), c = rd();\n    \t    \tpii pt1 = split(rt, k - 1);\n    \t    \tpii pt2 = split(pt1.sec, m);\n    \t    \ttr[pt2.fir].cov(c);\n    \t    \trt = merge(merge(pt1.fir, pt2.fir), pt2.sec);\n\t}\n\n\tvoid rev_seq() {\n\t\tint k = rd(), m = rd();\n    \t    \tpii pt1 = split(rt, k - 1);\n    \t    \tpii pt2 = split(pt1.sec, m);\n    \t    \ttr[pt2.fir].rev();\n    \t    \trt = merge(merge(pt1.fir, pt2.fir), pt2.sec);\n\t}\n\n\tint get_sum() {\n\t\tint k = rd(), m = rd();\n    \t    \tpii pt1 = split(rt, k - 1);\n    \t    \tpii pt2 = split(pt1.sec, m);\n    \t    \tprintf(\"%d\\n\", tr[pt2.fir].sum);\n    \t    \trt = merge(merge(pt1.fir, pt2.fir), pt2.sec);\n\t}\n\tvoid print(int x) {\n\t\tif(u.ls) print(u.ls);\n\t\tprintf(\"[%d: %d]\\n\", x, u.val);\n\t\tif(u.rs) print(u.rs);\t\n\t\t\n\t}\n\n} t;\n\n\nint main() {\n\tsrand(233);\n\tn = rd();\n\tint q = rd(); \n\tREP(i, 1, n) a[i] = rd();\n\tt.rt = t.build(a, n);    \n\twhile(q --) {\n    \t    \tscanf(\"%s\", buf + 1); \n    \t    \tif(buf[1] == 'I') t.ins_seq();\n    \t    \telse if(buf[1] == 'D') t.del_seq();\n    \t    \telse if(buf[1] == 'M' && buf[3] == 'K') t.cov_seq();\n    \t    \telse if(buf[1] == 'R') t.rev_seq();\n    \t    \telse if(buf[1] == 'G') t.get_sum();\n    \t    \telse printf(\"%d\\n\", t.tr[t.rt].mx);\n    \t}   \n\treturn 0;\n}\n```",
        "postTime": 1519815049,
        "uid": 16749,
        "name": "shadyqwq",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u76f4\u63a5\u6284\u4e00\u6bb5\u521a\u521a\u5199\u7684\u535a\u5ba2\u597d\u4e86\u618b\u6253\u6211(\u9003\n\n\u9996\u5148\u7b80\u5355\u68b3\u7406\u4e00\u4e0b,\u9898\u76ee\u8981\u6c42\u652f\u6301\u7684\u64cd\u4f5c\u6709:Reverse/Set/Sum/MaxSum/Delete/Insert.\n\n\n\u5176\u4e2d\u9700\u8981\u4e0b\u4f20\u6807\u8bb0\u7684\u662fSet\u548cReverse,\u5206\u522b\u4f7f\u7528\u4e24\u4e2abool\u578b\u6807\u8bb0\u5373\u53ef.\u5176\u4e2dSet\u64cd\u4f5c\u6807\u8bb0\u7684\u5904\u7406\u4f18\u5148\u4e8eReverse\u56e0\u4e3aSet\u64cd\u4f5c\u4f1a\u5c06\u6574\u4e2a\u533a\u95f4\u8bbe\u7f6e\u4e3a\u540c\u4e00\u4e2a\u503c,\u7ffb\u8f6c\u4e0d\u7ffb\u8f6c\u90fd\u4e00\u6837233\n\n\n\u6211\u4eec\u6ce8\u610f\u5230\u6709MaxSum\u64cd\u4f5c,\u8fd9\u65f6\u6211\u4eec\u9700\u8981\u5206\u6790\u4e00\u4e0b.\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e09\u4e2a\u53d8\u91cf\u6765\u5b58\u50a8\u6709\u5173\u4fe1\u606f:lmax\u5b58\u50a8\u4ee5\u8be5\u533a\u95f4\u5de6\u7aef\u5f00\u59cb\u5411\u53f3\u7684\u6700\u5927\u548c,rmax\u5b58\u50a8\u4ee5\u8be5\u533a\u95f4\u53f3\u7aef\u4e3a\u7ed3\u5c3e\u5411\u5de6\u7684\u6700\u5927\u548c,maxSum\u5b58\u50a8\u8be5\u533a\u95f4\u5185\u7684\u6700\u5927\u8fde\u7eed\u548c\u7684\u503c.\u8fd9\u6837\u5c31\u53ef\u4ee5\u5c06maxSum\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5:\u5de6\u5b50\u6811\u7684maxSum;\u53f3\u5b50\u6811\u7684maxSum;\u5de6\u5b50\u6811rmax,\u53f3\u5b50\u6811lmax\u548c\u8be5\u8282\u70b9\u7684\u952e\u503c\u4e4b\u548c.\u5206\u522b\u4ee3\u8868\u5b8c\u5168\u4f4d\u4e8e\u5de6\u533a\u95f4/\u5b8c\u5168\u4f4d\u4e8e\u53f3\u533a\u95f4/\u8de8\u8d8a\u4e2d\u95f4\u7684\u6700\u5927\u8fde\u7eed\u548c(\u6b64\u90e8\u5206\u7684\u5206\u6cbb\u7b56\u7565\u53ef\u53c2\u89c1\u7b97\u6cd5\u5bfc\u8bba\u7b2c\u4e09\u7248\u4e2d\u6587\u7248\u76844.1\u8282).lmax\u548crmax\u5219\u5206\u522b\u5bf9\u5e94\u4e24\u79cd\u60c5\u51b5,\u4ee5lmax\u4e3a\u4f8b,\u5bf9\u5e94\u5de6\u5b50\u6811\u7684lmax\u503c\u4e0e\u5de6\u5b50\u6811\u7684sum\u503c,\u8be5\u7ed3\u70b9\u7684\u952e\u503c\u548c\u53f3\u5b50\u6811\u7684lmax\u503c\u4e4b\u548c\u7684\u6700\u5927\u503c.rmax\u540c\u7406.\n\n\n\u5bf9\u4e8e\u7a7a\u7ed3\u70b9\u8981\u6ce8\u610fmaxSum\u4e3a-INF,\u5176\u4ed6\u503c\u4e3a0.\n\n\n\u66f4\u65b0\u65f6\u5bf9\u4e8esum<0\u7684\u60c5\u51b5\u8981\u66f4\u65b0lmax\u4e0ermax\u4e3a0,maxSum\u4e3a\u952e\u503c.\n\n\n\u5bf9\u4e8e\u8c03\u8bd5\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u6211\u5728\u4e0b\u9762\u4ee3\u7801\u4e2d\u7684 class SplayTree \u91cc\u5199\u7684Print\u51fd\u6570,\u6309\u524d\u5e8f\u904d\u5386\u987a\u5e8f\u6253\u5370\u6574\u68f5\u6811\u5e76\u6309\u6df1\u5ea6\u7f29\u8fdb...\u8c03\u8bd5\u7684\u65f6\u5019\u5e2e\u4e86\u6211\u4e0d\u5c11\u5fd9\u6765\u7740w\n\n```cpp\n/**************************************\n      Judge Result: Accepted\n\n**************************************/\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\n#define lch chd[0]\n#define rch chd[1]\n#define kch chd[k]\n#define xch chd[k^1]\n\nconst int INF=0x2FFFFFFF;\n\nclass SplayTree{\nprivate:\n    struct Node{\n        int k;\n        int sz;\n        int sm;\n        int lm;\n        int rm;\n        int ms;\n        bool set;\n        bool rev;\n        Node* prt;\n        Node* chd[2];\n        Node(const int& key){\n            this->k=key;\n            this->sm=key;\n            this->ms=key;\n            this->lm=key>=0?key:0;\n            this->rm=key>=0?key:0;\n            this->sz=1;\n            this->prt=NULL;\n            this->lch=NULL;\n            this->rch=NULL;\n            this->rev=false;\n            this->set=false;\n        }\n        ~Node(){\n            if(this->lch!=NULL)\n                delete this->lch;\n            if(this->rch!=NULL)\n                delete this->rch;\n        }\n        inline void Maintain(){\n            if(this!=NULL){\n                this->sz=this->lch->size()+this->rch->size()+1;\n                this->sm=this->lch->sum()+this->rch->sum()+this->k;\n                this->lm=std::max(this->lch->lmax(),this->lch->sum()+this->k+this->rch->lmax());\n                this->rm=std::max(this->rch->rmax(),this->rch->sum()+this->k+this->lch->rmax());\n                this->ms=std::max(std::max(this->lch->maxSum(),this->rch->maxSum()),this->lch->rmax()+this->k+this->rch->lmax());\n            }\n        }\n        inline void Swap(){\n            if(this!=NULL){\n                this->rev=!this->rev;\n                std::swap(this->lm,this->rm);\n                std::swap(this->lch,this->rch);\n            }\n        }\n        inline void Set(const int& key){\n            if(this!=NULL){\n                this->set=true;\n                this->k=key;\n                this->sm=key*this->sz;\n                this->lm=std::max(this->sm,0);\n                this->rm=std::max(this->sm,0);\n                this->ms=std::max(this->sm,this->k);\n            }\n        }\n        inline void PushDown(){\n            if(this->set){\n                this->set=this->rev=false;\n                this->lch->Set(this->k);\n                this->rch->Set(this->k);\n            }\n            if(this->rev){\n                this->rev=false;\n                this->lch->Swap();\n                this->rch->Swap();\n            }\n        }\n        inline int sum(){\n            return this==NULL?0:this->sm;\n        }\n        inline int maxSum(){\n            return this==NULL?-INF:this->ms;\n        }\n        inline int key(){\n            return this==NULL?0:this->k;\n        }\n        inline int lmax(){\n            return this==NULL?0:this->lm;\n        }\n        inline int rmax(){\n            return this==NULL?0:this->rm;\n        }\n        inline int size(){\n            return this==NULL?0:this->sz;\n        }\n    }*root;\n    inline void Rotate(Node* root,int k){\n        Node* tmp=root->xch;\n        root->PushDown();\n        tmp->PushDown();\n        tmp->prt=root->prt;\n        if(root->prt==NULL)\n            this->root=tmp;\n        else if(root->prt->lch==root)\n            root->prt->lch=tmp;\n        else\n            root->prt->rch=tmp;\n        root->xch=tmp->kch;\n        if(tmp->kch!=NULL)\n            tmp->kch->prt=root;\n        tmp->kch=root;\n        root->prt=tmp;\n        root->Maintain();\n        tmp->Maintain();\n    }\n    void Splay(Node* root,Node* prt=NULL){\n        while(root->prt!=prt){\n            int k=root->prt->lch==root;\n            if(root->prt->prt==prt){\n                Rotate(root->prt,k);\n            }\n            else{\n                int d=root->prt->prt->lch==root->prt;\n                Rotate(k==d?root->prt->prt:root->prt,k);\n                Rotate(root->prt,d);\n            }\n        }\n    }\n    Node* Build(const std::vector<int>& v,int l,int r){\n        if(l>r)\n            return NULL;\n        int mid=(l+r)>>1;\n        Node* tmp=new Node(v[mid]);\n        tmp->lch=Build(v,l,mid-1);\n        tmp->rch=Build(v,mid+1,r);\n        if(tmp->lch!=NULL)\n            tmp->lch->prt=tmp;\n        if(tmp->rch!=NULL)\n            tmp->rch->prt=tmp;\n        tmp->Maintain();\n        return tmp;\n    }\n    void PrintTree(Node* root,int deep){\n        for(int i=0;i<deep;i++)\n            fputc(' ',stderr);\n        fprintf(stderr, \"(root=0x%X,key=%d,sum=%d,size=%d,lmax=%d,rmax=%d,maxSum=%d)\\n\", root,root->key(),root->sum(),root->size(),root->lmax(),root->rmax(),root->maxSum());\n        if(root==NULL)\n            return;\n        PrintTree(root->lch,deep+1);\n        PrintTree(root->rch,deep+1);\n    }\npublic:\n    SplayTree(){\n        this->root=new Node(-INF);\n        this->root->rch=new Node(-INF);\n        this->root->rch->prt=this->root;\n    }\n    SplayTree(const std::vector<int>& v){\n        this->root=Build(v,0,v.size()-1);\n    }\n    ~SplayTree(){\n        delete this->root;\n    }\n    Node* Kth(int pos){\n        ++pos;\n        Node* root=this->root;\n        while(root!=NULL){\n            root->PushDown();\n            int k=root->lch->size()+1;\n            if(pos<k)\n                root=root->lch;\n            else if(pos==k)\n                return root;\n            else{\n                pos-=k;\n                root=root->rch;\n            }\n        }\n        return NULL;\n    }\n    inline int Sum(const int& pos,const int& len){\n        this->Splay(this->Kth(pos-1));\n        this->Splay(this->Kth(pos+len),this->root);\n        return this->root->rch->lch->sum();\n    }\n    inline void Reverse(const int& pos,const int& len){\n        this->Splay(this->Kth(pos-1));\n        this->Splay(this->Kth(pos+len),this->root);\n        this->root->rch->lch->Swap();\n        this->root->rch->Maintain();\n        this->root->Maintain();\n    }\n    inline void Set(const int& pos,const int& len,const int& d){\n        this->Splay(this->Kth(pos-1));\n        this->Splay(this->Kth(pos+len),this->root);\n        this->root->rch->lch->Set(d);\n        this->root->rch->Maintain();\n        this->root->Maintain();\n    }\n    inline void Insert(const int& pos,SplayTree* data){\n        this->Splay(this->Kth(pos));\n        this->Splay(this->Kth(pos+1),this->root);\n        Node* tmp=data->root;\n        data->root=NULL;\n        this->root->rch->lch=tmp;\n        tmp->prt=this->root->rch;\n        this->root->rch->Maintain();\n        this->root->Maintain();\n    }\n    inline void Delete(const int& pos,const int& len){\n        this->Splay(this->Kth(pos-1));\n        this->Splay(this->Kth(pos+len),this->root);\n        delete this->root->rch->lch;\n        this->root->rch->lch=NULL;\n        this->root->rch->Maintain();\n        this->root->Maintain();\n    }\n    inline int MaxSum(){\n        return this->root->maxSum();\n    }\n    void Print(){\n        this->PrintTree(this->root,0);\n    }\n};\n\nint FastRead();\n\nint main(){\n    SplayTree* tree=new SplayTree();\n    std::vector<int> v;\n    int n=FastRead();\n    int m=FastRead();\n    int a,b;\n    char buf[20];\n    for(int i=0;i<n;i++){\n        v.push_back(FastRead());\n    }\n    tree->Insert(0,new SplayTree(v));\n    for(int i=0;i<m;i++){\n        scanf(\"%s\",buf);\n        if(*buf!='M'||buf[2]!='X'){\n            a=FastRead();\n            b=FastRead();\n        }\n        if(*buf=='G'){\n            printf(\"%d\\n\",tree->Sum(a,b));\n        }\n        else if(*buf=='D')\n            tree->Delete(a,b);\n        else if(*buf=='R')\n            tree->Reverse(a,b);\n        else if(*buf=='I'){\n            v.clear();\n            while(b--)\n                v.push_back(FastRead());\n            tree->Insert(a,new SplayTree(v));\n        }\n        else if(*buf=='M'){\n            if(buf[2]=='K')\n                tree->Set(a,b,FastRead());\n            else\n                printf(\"%d\\n\",tree->MaxSum());\n        }\n        // tree->Print();\n    }\n    return 0;\n}\n\nint FastRead(){\n    int ans=0;\n    bool neg=false;\n    register char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-')\n            neg=true;\n        ch=getchar();\n    }\n    while(isdigit(ch)){\n        ans=ans*10+ch-'0';\n        ch=getchar();\n    }\n    if(neg)\n        ans=-ans;\n    return ans;\n}\n```",
        "postTime": 1500870490,
        "uid": 50224,
        "name": "rvalue",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "## \u6ce8\u610f\u4e8b\u9879\n\n1. \u672c\u9898\u89e3\u6700\u5927\u7684\u4e00\u4e2a\u70b9\uff08\\#9\uff09\u8dd1\u4e86851ms\uff0c\u5728\u5b9e\u9645\u6bd4\u8d5b\u91cc\u662f\u65e0\u6cd5\u901a\u8fc7\u7684\uff08CCF\u8001\u7237\u673a2009\u5e74\u6b63\u5f0f\u6295\u5165\u4f7f\u7528\uff09\n\n2. \u672c\u9898fhqtreap\u7684\u4ee3\u7801\u98ce\u683c\uff1a\u65b0\u5efa\u8282\u70b9\u65f6\u8bb0\u5f55\u968f\u673a\u6743\u503c\u5728\u5408\u5e76\u65f6\u4f7f\u7528\n\n## \u9898\u76ee\u5206\u6790\n\n\u672c\u9898\u5171\u67096\u79cd\u64cd\u4f5c\uff1a\u533a\u95f4\u63d2\u5165\uff0c\u533a\u95f4\u5220\u9664\uff0c\u533a\u95f4\u63a8\u5e73\uff0c\u533a\u95f4\u7ffb\u8f6c\uff0c\u533a\u95f4\u6c42\u548c\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\n\n\u8003\u8651fhqtreap\u6216splay\u89e3\u6cd5\uff0c\u672c\u9898\u89e3\u4f7f\u7528fhqtreap\n\n### operation 1 \u533a\u95f4\u63d2\u5165\n\n\u4ee5pos\u4f4d\u7f6e\u4e3a\u754c\u5206\u88c2\u6210x,y\u4e24\u6bb5\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u9897\u6811\u5e76\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n\n```cpp\nsplit(root,pos,x,y)\ninit(a)\nroot=merge(x,merge(build(a),y)\n```\n\n### operation 2 \u533a\u95f4\u5220\u9664\n\n\u4ee5pos\u548cpos+tot\u4e3a\u754c\u5206\u88c2\u6210x,y,z\u4e09\u6bb5\uff0c\u7136\u540e\u628ax,z\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n\n```cpp\nsplit(root,pos-1,x,y)\nsplit(y,tot,y,z)\nroot=merge(x,z)\n```\n\n### operation 3 \u533a\u95f4\u63a8\u5e73\n\n\u4ee5pos\u548cpos+tot\u4e3a\u754c\u5206\u88c2\u6210x,y,z\u4e09\u6bb5\uff0c\u7ed9\u533a\u95f4y\u6253\u4e0a\u533a\u95f4\u63a8\u5e73\u6807\u8bb0\uff0c\u7136\u540e\u628ax,y,z\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n```cpp\nsplit(root,pos-1,x,y)\nsplit(y,tot,y,z)\ncover(y)\nroot=merge(x,merge(y,z))\n```\n\n### operation 4 \u533a\u95f4\u53cd\u8f6c\n\n\u4ee5pos\u548cpos+tot\u4e3a\u754c\u5206\u88c2\u6210x,y,z\u4e09\u6bb5\uff0c\u7ed9\u533a\u95f4y\u6253\u4e0a\u533a\u95f4\u53cd\u8f6c\u6807\u8bb0\uff0c\u7136\u540e\u628ax,y,z\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n```cpp\nsplit(root,pos-1,x,y)\nsplit(y,tot,y,z)\nreverse(y)\nroot=merge(x,merge(y,z))\n```\n\n### operatino 5 \u533a\u95f4\u6c42\u548c\n\n\u4ee5pos\u548cpos+tot\u4e3a\u754c\u5206\u88c2\u6210x,y,z\u4e09\u6bb5\uff0c\u7ed9\u533a\u95f4y\u7b97\u6c42\u548c\uff0c\u7136\u540e\u628ax,y,z\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n```cpp\nsplit(root,pos-1,x,y)\nsplit(y,tot,y,z)\nwrite(tree[y].sum)\nroot=merge(x,merge(y,z))\n```\n\n### operation 6 \u533a\u95f4\u6700\u5927\u5b50\u5e8f\u5217\n\n\u4ee5pos\u548cpos+tot\u4e3a\u754c\u5206\u88c2\u6210x,y,z\u4e09\u6bb5\uff0c\u7ed9\u533a\u95f4y\u7b97\u6700\u5927\u5b50\u5e8f\u5217\uff08\u4e0d\u4f1a\u7684\u53bb\u505aSPOJ GSS3\uff09\uff0c\u7136\u540e\u628ax,y,z\u5408\u5e76\u56de\u53bb\n\n\u4f2a\u4ee3\u7801\uff1a\n```cpp\nsplit(root,pos-1,x,y)\nsplit(y,tot,y,z)\nwrite(tree[y].sum)\nroot=merge(x,merge(y,z))\n```\n\n------------\n\n\n\u770bsplit\u548cmerge\u4e24\u4e2a\u64cd\u4f5c\uff0c\u6211\u4eec\u73b0\u5728\u8981\u5904\u7406pushup\u548cpushdown\uff0c\u53e6\u5916\u8fd8\u6709cover\u548creverse\u8981\u5904\u7406\n\n### \u5173\u4e8epushup\uff1a\n\npushup\u9700\u8981\u4f20\u8fd9\u51e0\u4e2a\u91cf\uff1a\n\n\u5b50\u6811\u5927\u5c0f\u548c\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u6240\u9700\u7684\u56db\u4e2a\u91cf\u3002\n\n### \u5173\u4e8epushdown\uff1a\n\n\u8fd9\u91cc\u6709cover\u548creverse\u4e24\u4e2a\u6807\u8bb0\u3002\n\n\u6211\u4eec\u53d1\u73b0\uff0c**\u6807\u8bb0\u4e0b\u4f20\u7684\u987a\u5e8f\u4e0d\u5f71\u54cd\u6700\u7ec8\u7ed3\u679c**\uff0c\u6362\u53e5\u8bdd\u8bf4\uff0c\u5148\u4f20cover\u548c\u5148\u4f20reverse\u90fd\u53ef\u4ee5\u3002\n\n\u53e6\u5916\u6ce8\u610freverse\u7684\u65f6\u5019\u4e0d\u80fd\u4ee5\u6807\u8bb0\u7684\u503c\u662f\u5426\u4e3a\u67d0\u4e2a\u6570\u6765\u5224\u65ad\u6709\u6ca1\u6709\u6570\u5b57\uff0c\u8981\u518d\u5f00\u4e00\u4e2a\u53d8\u91cftag\u6765\u8868\u793a\n\n### \u5173\u4e8e\u5efa\u6811\n\n\u4eff\u7167\u7ebf\u6bb5\u6811\u7684\u4e8c\u5206\u5efa\u6811\u5373\u53ef\n\n### \u5185\u5b58\u95ee\u9898\n\n\u66b4\u529b\u7684\u8bdd\uff0c\u8fd9\u9898\u7684\u5185\u5b58\u662f\u4e0d\u591f\u7528\u7684\u3002\n\n\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u5f88\u53cd\u5e38\u7684\u5730\u65b9\uff1a\n\n- $100%$\u7684\u6570\u636e\u4e2d\uff0c$M \\leq 20000$\uff0c\u63d2\u5165\u7684\u6570\u5b57\u603b\u6570\u4e0d\u8d85\u8fc7$4000000$\u3002\n- $100%$\u7684\u6570\u636e\u4e2d\uff0c\u4efb\u4f55\u65f6\u523b\u6570\u5217\u4e2d\u6700\u591a\u542b\u6709$500000$\u4e2a\u6570\u3002\n\n\u56e0\u6b64\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u5783\u573e\u56de\u6536\u7cfb\u7edf\u6765\u8282\u7701\u5185\u5b58\uff0c\u5177\u4f53\u5c31\u662f\u8bb0\u4e0b\u7528\u8fc7\u7684\u5750\u6807\uff0c\u7528\u7684\u65f6\u5019\u4ece\u672a\u7528\u8fc7\u7684\u91cc\u8fb9\u627e\u4e00\u4e2a\u4f5c\u4e3a\u5750\u6807\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4e86\n\n### \u4ee3\u7801\uff1a\n```cpp\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst ll N=500010;\nll n,m,root,cnt,a[N],top,st[N];\nstruct fhqtreap{\n    ll lson,rson,rev,cov,size,val,sum,Lmax,Rmax,Mmax,tag,rnd;\n}tree[N];\n\ninline ll read(){\n    ll x=0,tmp=1;\n    char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-') tmp=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch)){\n        x=(x<<3)+(x<<1)+(ch^48);\n        ch=getchar();\n    }\n    return tmp*x;\n}\n\ninline void write(ll x){\n    if(x<0){\n        putchar('-');\n        x=-x;\n    }\n    ll y=10,len=1;\n    while(y<=x){\n        y=(y<<3)+(y<<1);\n        len++;\n    }\n    while(len--){\n        y/=10;\n        putchar(x/y+48);\n        x%=y;\n    }\n}\n\ninline ll New(ll val){\n    ll p=st[top--];\n    tree[p].rnd=rand();\n    tree[p].lson=tree[p].rson=tree[p].rev=tree[p].cov=0;\n    tree[p].size=1;\n    tree[p].val=tree[p].sum=tree[p].Mmax=val;\n    tree[p].Lmax=tree[p].Rmax=max(0ll,val);\n    return p;\n}\n\ninline void pushup(ll p){\n    tree[p].size=tree[tree[p].lson].size+tree[tree[p].rson].size+1;\n    tree[p].sum=tree[tree[p].lson].sum+tree[tree[p].rson].sum+tree[p].val;\n    tree[p].Lmax=max(max(tree[tree[p].lson].Lmax,tree[tree[p].lson].sum+tree[p].val+tree[tree[p].rson].Lmax),0ll);\n    tree[p].Rmax=max(max(tree[tree[p].rson].Rmax,tree[tree[p].rson].sum+tree[p].val+tree[tree[p].lson].Rmax),0ll);\n    tree[p].Mmax=max(tree[p].val,tree[tree[p].lson].Rmax+tree[p].val+tree[tree[p].rson].Lmax);\n    if(tree[p].lson) tree[p].Mmax=max(tree[p].Mmax,tree[tree[p].lson].Mmax);\n    if(tree[p].rson) tree[p].Mmax=max(tree[p].Mmax,tree[tree[p].rson].Mmax);\n}\n\ninline void reverse(ll p){\n    swap(tree[p].lson,tree[p].rson);\n    swap(tree[p].Lmax,tree[p].Rmax);\n    tree[p].rev^=1;\n}\n\ninline void cover(ll p,ll val){\n    tree[p].val=tree[p].cov=val;\n    tree[p].sum=tree[p].size*val;\n    tree[p].Lmax=tree[p].Rmax=max(0ll,tree[p].sum);\n    tree[p].Mmax=max(val,tree[p].sum);\n    tree[p].tag=1;\n}\n\ninline void pushdown(ll p){\n    if(tree[p].rev){\n        if(tree[p].lson) reverse(tree[p].lson);\n        if(tree[p].rson) reverse(tree[p].rson);\n        tree[p].rev=0;\n    }\n    if(tree[p].tag){\n        if(tree[p].lson) cover(tree[p].lson,tree[p].cov);\n        if(tree[p].rson) cover(tree[p].rson,tree[p].cov);\n        tree[p].cov=tree[p].tag=0;\n    }\n}\n\nvoid split(ll p,ll k,ll &x,ll &y){\n    if(!p){\n        x=y=0;\n        return;\n    }\n    pushdown(p);\n    if(tree[tree[p].lson].size+1<=k){\n        x=p;\n        split(tree[p].rson,k-tree[tree[p].lson].size-1,tree[p].rson,y);\n    }\n    else{\n        y=p;\n        split(tree[p].lson,k,x,tree[p].lson);\n    }\n    pushup(p);\n}\n\nll merge(ll x,ll y){\n    if(!x||!y) return x|y;\n    if(tree[x].rnd<tree[y].rnd){\n        pushdown(x);\n        tree[x].rson=merge(tree[x].rson,y);\n        pushup(x);\n        return x;\n    }\n    else{\n        pushdown(y);\n        tree[y].lson=merge(x,tree[y].lson);\n        pushup(y);\n        return y;\n    }\n}\n\ninline ll build(ll l,ll r){\n    if(l==r) return New(a[l]);\n    ll mid=(l+r)>>1;\n    return merge(build(l,mid),build(mid+1,r));\n}\n\nvoid erase(ll p){\n    st[++top]=p;\n    if(tree[p].lson) erase(tree[p].lson);\n    if(tree[p].rson) erase(tree[p].rson);\n}\n\nint main(){\n    for(ll i=1; i<=N-10; i++) st[++top]=i;\n    srand(time(NULL));\n    n=read(); m=read();\n    for(ll i=1; i<=n; i++) a[i]=read();\n    root=build(1,n);\n    while(m--){\n        char op[10]; scanf(\"%s\",op);\n        ll x,y,z;\n        switch(op[0]){\n            case 'I':{\n                ll pos=read(),tot=read();\n                split(root,pos,x,y);\n                for(ll i=1; i<=tot; i++) a[i]=read();\n                root=merge(merge(x,build(1,tot)),y);\n                break;\n            }\n            case 'D':{\n                ll pos=read(),tot=read();\n                split(root,pos-1,x,y);\n                split(y,tot,y,z);\n                erase(y);\n                root=merge(x,z);\n                break;\n            }\n            case 'R':{\n                ll pos=read(),tot=read();\n                split(root,pos-1,x,y);\n                split(y,tot,y,z);\n                reverse(y);\n                root=merge(x,merge(y,z));\n                break;\n            }\n            case 'G':{\n                ll pos=read(),tot=read();\n                split(root,pos-1,x,y);\n                split(y,tot,y,z);\n                write(tree[y].sum); putchar('\\n');\n                root=merge(x,merge(y,z));\n                break;\n            }\n            case 'M':{\n                switch(op[2]){\n                    case 'K':{\n                        ll pos=read(),tot=read(),val=read();\n                        split(root,pos-1,x,y);\n                        split(y,tot,y,z);\n                        cover(y,val);\n                        root=merge(x,merge(y,z));\n                        break;\n                    }\n                    case 'X':{\n                        write(tree[root].Mmax);\n                        putchar('\\n');\n                        break;\n                    }\n                    default:{\n                        printf(\"FUCK %s\\n\",op);\n                        break;\n                    }\n                }\n                break;\n            }\n            default:{\n                printf(\"FUCK %s\\n\",op);\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1576744760,
        "uid": 27924,
        "name": "xukuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "## \u4e00\u3001\u9898\u76ee\n\n[\u70b9\u6b64\u770b\u9898](https://www.luogu.com.cn/problem/P2042)\n\n## \u4e8c\u3001\u89e3\u6cd5\n\n\u5199\u4e00\u53d1\u65e0\u65cb$\\text{treap}$\u7684\u9898\u89e3\u5427\uff0c\u6211\u91cd\u6784\u4e86\u8db3\u8db3\u4e09\u904d\uff0c\u8bb2\u4e00\u4e0b\u6240\u6709\u5751\u70b9\u3002\n\n\u5982\u679c\u4f60\u5bf9$\\text{treap}$\u4e0d\u662f\u5f88\u4e86\u89e3\uff0c\u53ef\u4ee5\u770b[\u8fd9\u4e2a](https://blog.csdn.net/C202044zxy/article/details/103244047)\u3002\n\n![\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0](https://img-blog.csdnimg.cn/20191130142557256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0MyMDIwNDR6eHk=,size_16,color_FFFFFF,t_70)\n\n**\u64cd\u4f5c1 insert**\n\n- \u8fd9\u9053\u9898\u4e0d\u80fd$O(n\\log n)$\u65e0\u8111\u63d2\u5165\uff0c\u8981\u8003\u8651$O(n)$\u5efa\u6811\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a$heap$\u9012\u589e\u7684\u5355\u8c03\u6808\uff0c\u6bcf\u6b21\u52a0\u5165\u4e00\u4e2a\u70b9\u5f39\u51fa\u6bd4\u5b83$heap$\u5927\u7684\uff0c\u6700\u540e\u4e00\u4e2a\u88ab\u5f39\u51fa\u7684\u70b9\u662f\u4ed6\u7684\u5de6\u513f\u5b50\uff0c\u4ed6\u662f\u5f39\u6808\u540e\u7684\u6808\u9876\u7684\u53f3\u513f\u5b50\uff0c\u4fee\u6539\u513f\u5b50\u540e\u518d\u8dd1\u4e00\u8fb9\u6574\u68f5\u6811\uff0c\u6211\u4eec\u6700\u5f00\u59cb\u662f\u5efa\u4e00\u4e2a$heap$\u6700\u5c0f\u7684\u8d85\u7ea7\u6839\uff0c\u771f\u6b63\u7684\u6839\u662f\u8d85\u7ea7\u6839\u7684\u53f3\u513f\u5b50\uff0c\u63d2\u5165\u7684\u8bdd\u6211\u4eec\u5c31\u628a\u5efa\u51fa\u6765\u7684\u6811\u4e0e\u539f\u6765\u7684\u6811\u5408\u5e76\u3002\n- \u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u7a7a\u95f4\u5f00\u4e0d\u4e0b\uff0c\u7531\u4e8e\u6570\u5217\u7684\u957f\u5ea6\u662f\u9650\u5b9a\u7684\uff0c\u53ef\u4ee5\u5199\u4e00\u4e2a\u5185\u5b58\u6c60\uff0c\u52a8\u6001\u62ff\u7a7a\u95f4\u3002\n\n**\u64cd\u4f5c2 delete**\n\n- \u628a\u5220\u9664\u7684\u533a\u95f4\u5206\u88c2\u51fa\u6765\uff0c\u7136\u540e\u5408\u5e76\u3002\n\n**\u64cd\u4f5c3 modify**\n\n- \u628a\u533a\u95f4\u62c6\u51fa\u6765\u6253\u61d2\u6807\u8bb0\uff0c\u6ce8\u610f\u4ed6\u6709\u53ef\u80fd\u8ba9\u4f60\u533a\u95f4\u8d4b$0$\uff0c\u6240\u4ee5\u8981\u7528$inf$\u5f53\u6ca1\u6709\u6807\u8bb0\u65f6\u8d4b\u7684\u503c\u3002\n\n**\u64cd\u4f5c4 reverse**\n\n- \u4ee5\u540e\u8981\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u6700\u5927\u5b57\u6bb5\u548c\uff0c\u7ffb\u8f6c\u65f6\u53ea\u6709\u5de6\u8fb9\u5f00\u59cb\u7684\u6700\u5927\u5b50\u6bb5\u548c\u53f3\u8fb9\u5f00\u59cb\u7684\u6700\u5927\u5b50\u6bb5\u4f1a\u53d7\u5f71\u54cd\uff0c\u5e94\u8be5\u4ea4\u6362\u5de6\u8fb9\u5f00\u59cb\u548c\u53f3\u8fb9\u5f00\u59cb\u3002\n\n**\u64cd\u4f5c5 get-sum**\n\n- \u628a\u8981\u6c42\u7684\u533a\u95f4\u62c6\u51fa\u6765\uff0c\u7136\u540e\u8f93\u51fa$\\text{sum}$\u5373\u53ef\u3002\n\n**\u64cd\u4f5c6 \u6700\u5927\u5b50\u6bb5\u548c**\n\n- \u7ef4\u62a4\u4e00\u4e2a\u5de6\u8d77\u6700\u5927\u5b50\u6bb5\uff0c\u53f3\u8d77\u6700\u5927\u5b50\u6bb5\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\uff0c\u8bb2\u4e00\u8bb2\u66f4\u65b0\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u5427\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u53ef\u4ee5\u4ece\u4e09\u4e2a\u5730\u65b9\u8f6c\u79fb\uff1a\u5de6\u513f\u5b50\u6700\u5927\u5b50\u6bb5\uff0c\u53f3\u513f\u5b50\u6700\u5927\u5b50\u6bb5\uff0c\u4e2d\u95f4\u503c+\u5de6\u513f\u5b50\u53f3\u8d77\u6700\u5927\u5b50\u6bb5+\u53f3\u513f\u5b50\u5de6\u8d77\u6700\u5927\u5b50\u6bb5\uff0c\u4ed4\u7ec6\u60f3\u60f3\u8fd9\u79cd\u66f4\u65b0\u65b9\u6cd5\u53ef\u4ee5\u6db5\u76d6\u6240\u6709\u60c5\u51b5\u3002\n- \u5b50\u6bb5\u4e0d\u80fd\u4e3a\u7a7a\uff0c\u6240\u4ee5\u6700\u5927\u5b50\u6bb5\u6709\u65f6\u9700\u8981\u4e3a\u8d1f\uff0c\u9700\u8981\u5224\u65ad\u4e3a\u8d1f\u662f\u9009\u4e0d\u9009\u3002\n\n\u90a3\u6211\u5c31\u653e\u4e2a\u4ee3\u7801\u5427\uff0c\u53ef\u4ee5\u770b\u770b\u52a0\u6df1\u7406\u89e3\u3002\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <ctime>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int MAXN = 500005;\nint read()\n{\n\tint x=0,flag=1;char c;\n\twhile((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;\n\twhile(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn x*flag;\n}\nint n,m,rt,top;char str[20];\nint ch[MAXN][2],siz[MAXN],hp[MAXN],fl[MAXN],q[MAXN];\nint sum[MAXN],val[MAXN],ml[MAXN],mr[MAXN],mx[MAXN],la[MAXN];\nstruct Memory_Pool\n{\n\tint top,p[MAXN];\n\tMemory_Pool()\n\t{\n\t\ttop=MAXN-1;\n\t\tfor(int i=1;i<=top;i++)\n\t\t\tp[i]=i;\n\t}\n\tint New() {return p[top--];}\n\tvoid Rec(int x) {p[++top]=x;} \n}M;//\u5185\u5b58\u6c60\nstruct node\n{\n\tint p[2];\n\tnode() {p[0]=p[1]=0;}\n}emp;//\u4e24\u4e2a\u6839\u7684\u7ed3\u6784\u4f53\nvoid up(int x)\n{\n\tsiz[x]=siz[ch[x][0]]+siz[ch[x][1]]+1;\n\tsum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];\n\tml[x]=max(ml[ch[x][0]],sum[ch[x][0]]+val[x]+max(0,ml[ch[x][1]]));\n\tmr[x]=max(mr[ch[x][1]],sum[ch[x][1]]+val[x]+max(0,mr[ch[x][0]]));\n\tmx[x]=max(max(mx[ch[x][0]],mx[ch[x][1]]),val[x]+max(0,mr[ch[x][0]])+max(0,ml[ch[x][1]]));\n}//push_up\nvoid modify(int x,int c)\n{\n\tval[x]=c;sum[x]=c*siz[x];\n\tif(c<0)\n\t\tml[x]=mr[x]=mx[x]=c;\n\telse\n\t\tml[x]=mr[x]=mx[x]=sum[x];\n}//\u533a\u95f4\u4fee\u6539\nvoid flip(int x)\n{\n\tswap(ch[x][0],ch[x][1]);\n\tswap(ml[x],mr[x]);\n}//\u533a\u95f4\u7ffb\u8f6c\nvoid down(int x)\n{\n\tif(fl[x])\n\t{\n\t\tfl[ch[x][0]]^=1;fl[ch[x][1]]^=1;\n\t\tflip(ch[x][0]);flip(ch[x][1]);\n\t\tfl[x]=0;\n\t}\n\tif(la[x]!=inf)\n\t{\n\t\tla[ch[x][0]]=la[ch[x][1]]=la[x];\n\t\tmodify(ch[x][0],la[x]);modify(ch[x][1],la[x]);\n\t\tla[x]=inf;\n\t}\n}//\u4e0b\u4f20\u6807\u8bb0\nnode split(int x,int s)\n{\n\tif(!x) return emp;\n\tdown(x);\n\tnode y;\n\tif(siz[ch[x][0]]>=s)\n\t{\n\t\ty=split(ch[x][0],s);\n\t\tch[x][0]=y.p[1];\n\t\ty.p[1]=x;\n\t}\n\telse\n\t{\n\t\ty=split(ch[x][1],s-siz[ch[x][0]]-1);\n\t\tch[x][1]=y.p[0];\n\t\ty.p[0]=x;\n\t}\n\tup(x);\n\treturn y;\n}//\u5206\u88c2\nint merge(int x,int y)\n{\n\tif(!x || !y) return x+y;\n\tif(hp[x]<hp[y])\n\t{\n\t\tdown(x);\n\t\tch[x][1]=merge(ch[x][1],y);\n\t\tup(x);\n\t\treturn x;\n\t}\n\tdown(y);\n\tch[y][0]=merge(x,ch[y][0]);\n\tup(y);\n\treturn y;\n}//\u5408\u5e76\nvoid reuse(int x)\n{\n\tif(!x) return ;\n\treuse(ch[x][0]);reuse(ch[x][1]);\n\tM.Rec(x);\n}//\u56de\u6536\u7a7a\u95f4\nvoid init(int x)\n{\n\tif(!x) return ;\n\tinit(ch[x][0]);init(ch[x][1]);\n\tup(x);\n}//\u8dd1\u4e00\u904d\u65b0\u5efa\u7684\u6811\nint build(int n)\n{\n\tq[top=1]=1;hp[1]=-inf;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=M.New(),t=0;\n\t\tch[x][0]=ch[x][1]=fl[x]=0;la[x]=inf;siz[x]=1;\n\t\thp[x]=rand();val[x]=sum[x]=ml[x]=mr[x]=mx[x]=read();\n\t\twhile(top && hp[q[top]]>=hp[x]) t=q[top--];\n\t\tch[q[top]][1]=x;ch[x][0]=t;\n\t\tq[++top]=x;\n\t}\n\tinit(1);\n\treturn ch[1][1];\n}//O(n)\u5efa\u6811\uff0c\u8fd4\u56de\u6839\nint main()\n{\n\tsrand(time(0));\n\tml[0]=mr[0]=mx[0]=val[0]=-inf;\n\tn=read();m=read();\n\trt=build(n);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",str);\n\t\tif(str[0]=='I')\n\t\t{\n\t\t\tint pos=read(),t=read();\n\t\t\tnode x=split(rt,pos);\n\t\t\trt=merge(merge(x.p[0],build(t)),x.p[1]);\n\t\t}\n\t\tif(str[0]=='D')\n\t\t{\n\t\t\tint pos=read(),t=read();\n\t\t\tnode x=split(rt,pos-1),y=split(x.p[1],t);\n\t\t\treuse(y.p[0]);\n\t\t\trt=merge(x.p[0],y.p[1]);\n\t\t}\n\t\tif(str[0]=='M' && str[2]=='K')\n\t\t{\n\t\t\tint pos=read(),t=read(),c=read();\n\t\t\tnode x=split(rt,pos-1),y=split(x.p[1],t);\n\t\t\tla[y.p[0]]=c;\n\t\t\tmodify(y.p[0],c);\n\t\t\trt=merge(x.p[0],merge(y.p[0],y.p[1]));\n\t\t}\n\t\tif(str[0]=='R')\n\t\t{\n\t\t\tint pos=read(),t=read();\n\t\t\tnode x=split(rt,pos-1),y=split(x.p[1],t);\n\t\t\tfl[y.p[0]]^=1;\n\t\t\tflip(y.p[0]);\n\t\t\trt=merge(x.p[0],merge(y.p[0],y.p[1]));\n\t\t}\n\t\tif(str[0]=='G')\n\t\t{\n\t\t\tint pos=read(),t=read();\n\t\t\tnode x=split(rt,pos-1),y=split(x.p[1],t);\n\t\t\tprintf(\"%d\\n\",sum[y.p[0]]);\n\t\t\trt=merge(x.p[0],merge(y.p[0],y.p[1]));\n\t\t}\n\t\tif(str[0]=='M' && str[2]=='X')\n\t\t{\n\t\t\tprintf(\"%d\\n\",mx[rt]);\n\t\t}\n\t}\n}\n```\n",
        "postTime": 1575098010,
        "uid": 128239,
        "name": "C20203030",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u672c\u6587\u540c\u6b65\u53d1\u8868\u4e8e [RainAir's Blog](https://blog.aor.sd.cn/archives/457)\n\n# \u5982\u4f55\u7ef4\u62a4\u533a\u95f4\n\u6211\u4eec\u90fd\u77e5\u9053\u5e73\u8861\u6811\u662f\u4e00\u79cd\u5f88\u795e\u5947\u7684\u4e1c\u897f\uff0c\u53ef\u4ee5\u7528\u4e8e\u7ef4\u62a4\u52a8\u6001\u7684\u5e8f\u5217\u603b\u4fe1\u606f\uff0c\u4f46\u662f\u5982\u679c\u60f3\u7ef4\u62a4\u5176\u4e2d\u7684\u67d0\u4e00\u4e2a\u533a\u95f4\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u8be5\u600e\u4e48\u505a\u597d\u5462\uff1f\n\n\u6211\u4eec\u8003\u8651\u6362\u4e00\u79cd\u7ef4\u62a4\u65b9\u5f0f\uff1a\u5e73\u8861\u6811\u7684\u7ed3\u6784\u4e0d\u662f\u6309\u7167\u8282\u70b9\u7684\u503c\u7684\u5927\u5c0f\u6765\u8fdb\u884c\u5efa\u6811\uff0c\u800c\u662f\u4ee5\u8fd9\u4e2a\u8282\u70b9\u5728\u5e8f\u5217\u4e2d\u7684\u4f4d\u7f6e\u4e3a\u5173\u952e\u5b57\u6765\u7ef4\u62a4\u3002\u4e5f\u5c31\u662f\u8bf4\u5bf9\u4e8e\u5e73\u8861\u6811\u4e2d\u4efb\u610f\u4e00\u4e2a\u8282\u70b9 $x$ \uff0c\u5de6\u5b50\u6811\u4e2d\u7684\u5143\u7d20\u6c38\u8fdc\u5728\u5b83\u524d\u9762\uff0c\u53f3\u5b50\u6811\u7684\u5143\u7d20\u6c38\u8fdc\u5728\u5b83\u540e\u9762\u3002\u663e\u7136\u4e00\u4e2a\u533a\u95f4\u53ef\u4ee5\u5bf9\u5e94\u4e00\u4e2a\u5b50\u6811\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u4f7f\u7528\u80fd\u63d0\u53d6\u5b50\u6811\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982 Splay \u548c \u975e\u65cb Treap\u3002\n\n\u6bd4\u5982\u6211\u4eec\u8003\u8651\u63d0\u53d6 $[l,r]$ \u7684\u533a\u95f4\u4fe1\u606f\uff1a\u6211\u4eec\u9996\u5148\u5c06 $l-1$ \u8282\u70b9\u65cb\u8f6c\u5230\u6839\uff0cSplay \u53d8\u6210\u4e86\u8fd9\u6837\uff1a\n\n![](https://i.loli.net/2019/02/03/5c55bef42cf75.png)\n\n\u7136\u540e\u6211\u4eec\u63a5\u7740\u628a $r+1$ \u65cb\u8f6c\u5230 $l-1$ \u7684\u4e0b\u65b9\uff0c\u4e5f\u5c31\u53d8\u6210\u4e86\u8fd9\u6837\uff1a\n\n\n![](https://i.loli.net/2019/02/03/5c55bef4bb11c.png)\n\n\u6211\u4eec\u53d1\u73b0 $R+1$ \u8282\u70b9\u7684\u5de6\u5b50\u6811\u5c31\u662f\u6211\u4eec\u8981\u7684\u533a\u95f4\uff01\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u5bf9\u8fd9\u4e2a\u5b50\u6811\u8fdb\u884c\u60f3\u8981\u7684\u64cd\u4f5c\u5373\u53ef\uff0c\u590d\u6742\u5ea6\u662f\u65cb\u8f6c\u7684\u590d\u6742\u5ea6\u5373**\u5747\u644a**$O(logn)$\u3002\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u6765\u770b\u4e00\u9053\u4f8b\u9898\u3002\n# \u300cNOI2005\u300d\u7ef4\u4fee\u6570\u5217\n\u9898\u76ee\u5927\u610f\uff1a\u8981\u6c42\u4f60\u7ef4\u62a4\u4e00\u4e2a\u6570\u5217\uff0c\u652f\u6301\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n![](https://i.loli.net/2019/02/03/5c55befe7d36e.png)\n\n\u4efb\u4f55\u65f6\u523b\u6570\u5217\u4e2d\u6700\u591a\u542b\u6709 $5\\times 10^5$ \u4e2a\u6570\uff0c\u6570\u5217\u4e2d\u4efb\u4f55\u4e00\u4e2a\u6570\u5b57\u5747\u5728 $[-10^3, 10^3]$ \u5185\u3002\n\n\u63d2\u5165\u7684\u6570\u5b57\u603b\u6570\u4e0d\u8d85\u8fc7 $4 \\times 10^6$\u4e2a\uff0c\u8f93\u5165\u6587\u4ef6\u5927\u5c0f\u4e0d\u8d85\u8fc7 $\\text{20M}$\u3002\n\n\u663e\u7136\u8fd9\u5c31\u662f\u7528 Splay \u7ef4\u62a4\u533a\u95f4\u4fe1\u606f\u7684\u88f8\u9898\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u64cd\u4f5c\u90fd\u5206\u6790\u4e00\u904d\u3002\n## Insert \u64cd\u4f5c\n\u770b\u8d77\u6765\u66b4\u529b\u63d2\u5165\u6240\u6709\u7684\u6570\u975e\u5e38\u4e0d\u53ef\u53d6\u3002\u3002\u3002\u968f\u4fbf\u5c31\u80fd\u5361\u6389\u7684\u6837\u3002\n\n\u6211\u4eec\u4e0d\u59a8\u8003\u8651\u4e00\u4e0b\u5982\u679c\u6211\u4eec\u6709\u4e86\u4e00\u4e2a\u5e8f\u5217\u91cc\u7684\u6240\u6709\u7684\u6811\uff0c\u60f3\u5f97\u5230\u8fd9\u4e2a\u5e8f\u5217\u5bf9\u5e94\u7684 Splay \u53ef\u4ee5\u6709\u4ec0\u4e48\u65b9\u4fbf\u7684\u65b9\u6cd5\u3002\u663e\u7136\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u66b4\u529b\u9012\u5f52\u5efa\u6811\uff0c\u8fd9\u6837\u4e0d\u4ec5\u5feb ($O(nlogn)$) \u5f97\u5230\u7684\u6811\u4e5f\u5341\u5206\u5e73\u8861\u3002\u5177\u4f53\u5efa\u6811\u8fc7\u7a0b\u5c31\u662f\u6bcf\u6b21\u9009\u62e9\u4e2d\u70b9\u4f5c\u4e3a\u5f53\u524d\u7684\u6839\uff0c\u7136\u540e\u9012\u5f52\u5904\u7406\u4e2d\u70b9\u5de6\u8fb9\u548c\u53f3\u8fb9\u3002\n\n\u6211\u4eec\u4e0d\u59a8\u628a\u8f93\u5165\u7684\u5e8f\u5217\u5148\u641e\u4e2a Splay \u51fa\u6765\uff0c\u7136\u540e\u6211\u4eec\u53d1\u73b0\u5728 $x$ \u540e\u63d2\u5165\uff0c\u5982\u679c\u6211\u4eec\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u63d0\u53d6\u51fa\u533a\u95f4 $[x,x+1]$\uff0c\u90a3\u4e48 $x+1$ \u7684\u5de6\u5b50\u6811\u4e0d\u4e45\u5e94\u8be5\u662f\u6211\u4eec\u65b0\u5efa\u51fa\u6765\u7684 Splay \u5417\u3002\u3002\u3002\u76f4\u63a5\u63a5\u4e0a\u53bb\u5c31\u53ef\u4ee5\u4e86\u3002\n\n## Delete \u64cd\u4f5c\n\u548c Insert \u64cd\u4f5c\u76f8\u540c\u7684\u601d\u8def\uff1a\u6211\u4eec\u76f4\u63a5\u628a\u8fd9\u6bb5\u533a\u95f4\u63d0\u53d6\u51fa\u6765\uff0c\u4e0d\u8fc7\u6211\u4eec\u53d1\u73b0\u73b0\u5728\u6211\u4eec\u662f\u8981\u5220\u9664\uff0c\u6240\u4ee5\u76f4\u63a5\u65ad\u5f00\u8fd9\u4e2a\u533a\u95f4\u4ee3\u8868\u7684\u5b50\u6811\u4e0e\u7236\u8282\u70b9\u7684\u8fde\u63a5\u5c31\u53ef\u4ee5\u4e86\u3002\u4f46\u662f\u5728\u8fd9\u9898\u4e2d\u4e3a\u4e86\u8282\u7701\u8fd0\u884c\u7a7a\u95f4\u5efa\u8bae\u5199\u4e00\u4e2a\u5185\u5b58\u56de\u6536\u6c60\u6765\u56de\u6536\u8fd9\u4e9b\u88ab\u5220\u9664\u7684\u8282\u70b9\uff0c\u8fd9\u4e2a\u64cd\u4f5c\u751a\u81f3\u6bd4\u63d2\u5165\u8fd8\u7b80\u5355\u3002\n\n## MAKE-SAME \u64cd\u4f5c\n\u8003\u8651\u628a\u8fd9\u4e00\u6bb5\u533a\u95f4\u4fee\u6539\u6210\u540c\u4e00\u4e2a\u6570\u3002\u5728\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u64cd\u4f5c\u6211\u4eec\u6709 lazy-tag \u53ef\u7528\uff0c\u5728\u5e73\u8861\u6811\u4e0a\u4e5f\u53ef\u4ee5\u3002\u6211\u4eec\u63d0\u53d6\u51fa\u8fd9\u4e2a\u533a\u95f4\uff0c\u7136\u540e\u5728\u6839\u8282\u70b9\u6253\u4e2a\u533a\u95f4\u8986\u76d6\u7684\u6807\u8bb0\u5c31\u884c\u4e86\u3002\u6ce8\u610f\u6bcf\u6b21\u8bbf\u95ee\u8fd9\u4e2a\u533a\u95f4\u524d\u6807\u8bb0**\u5fc5\u987b**\u8981\u4e0b\u653e\u3002\n## \u7ffb\u8f6c\n\u5b66\u8fc7 LCT \u7684\u90fd\u4f1a\uff0c\u6ca1\u5b66\u8fc7\u7684\u53c2\u8003\u4e00\u4e0b\u6587\u827a\u5e73\u8861\u6811\u7684\u505a\u6cd5\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6211\u4eec\u53d1\u73b0\u5efa\u51fa\u7684 Splay \u540c\u65f6\u4fdd\u7559\u4e86\u539f\u6765\u5e8f\u5217\u7684\u6027\u8d28\uff1a\u5982\u679c\u6211\u4eec\u4e2d\u5e8f\u904d\u5386\u8fd9\u68f5 Splay\uff0c\u90a3\u4e48\u5f97\u5230\u7684\u5e8f\u5217\u5c31\u662f\u539f\u5e8f\u5217\uff01\u6211\u4eec\u8003\u8651\u533a\u95f4\u7ffb\u8f6c\u610f\u5473\u7740\u4ec0\u4e48\uff1a\u662f\u4e0d\u662f\u5c31\u662f\u5bf9\u4e8e\u8fd9\u4e2a\u533a\u95f4\u91cc\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u5de6\u53f3\u513f\u5b50\u90fd\u4e92\u6362\u554a\uff08\u56e0\u4e3a\u4e92\u6362\u540e\u73b0\u5728\u5148\u904d\u5386\u7684\u662f\u539f\u6765\u540e\u904d\u5386\u7684\uff0c\u5e76\u4e14\u5b50\u6811\u4e5f\u90fd\u4ea4\u6362\u4e86\uff09\u3002\u6240\u4ee5\u6211\u4eec\u540c\u65f6\u7ef4\u62a4\u4e00\u4e0b\u7ffb\u8f6c\u6807\u8bb0\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6ce8\u610f\u5230\u4e0b\u653e\u6807\u8bb0\u7684\u65f6\u5019\u5982\u679c\u53c8\u6709\u533a\u95f4\u8986\u76d6\u7684\u6807\u8bb0\u53c8\u6709\u7ffb\u8f6c\u7684\u6807\u8bb0\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u5ffd\u7565\u7ffb\u8f6c\u6807\u8bb0\uff08\u56e0\u4e3a\u4f60\u90fd\u662f\u4e00\u4e2a\u6570\u4e86\u7ffb\u8f6c\u6ca1\u6709\u610f\u4e49\uff09\uff0c\u8fd9\u6837\u80fd\u4f18\u5316\u4e0d\u5c11\u5e38\u6570\u3002\n## \u6c42\u548c\n\u6211\u4eec\u5bf9\u4e8e Splay \u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u7ef4\u62a4\u5b83\u53ca\u5176\u5b83\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u4ee3\u8868\u7684\u539f\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\u7684\u548c\u3002\u67e5\u8be2\u7684\u65f6\u5019\u63d0\u53d6\u533a\u95f4\u76f4\u63a5\u8f93\u51fa\u5c31\u53ef\u4ee5\u4e86\u3002\n## \u6c42\u6700\u5927\u5b50\u5217\n\u6211\u4eec\u8003\u8651\u4e00\u79cd\u57fa\u4e8e\u5206\u6cbb\u7684\u6c42\u6700\u5927\u5b50\u5217\u65b9\u6cd5\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u533a\u95f4\u90fd\u7ef4\u62a4\u4ece\u5de6\u8fb9\u5f00\u59cb\u7684\u6700\u5927\u5b50\u5217\uff0c\u4ece\u53f3\u8fb9\u5f00\u59cb\u7684\u6700\u5927\u5b50\u5217\u548c\u8be5\u533a\u95f4\u7684\u6700\u5927\u5b50\u5217\uff0c\u5206\u522b\u8bb0\u4e3a $ls,rs,ans$\u3002\n\n\u5bf9\u4e8e ls \u7684\u7ef4\u62a4\uff1a\u6211\u4eec\u8003\u8651\u4ece\u5de6\u8fb9\u5f00\u59cb\u7684\u6700\u5927\u5b50\u5217\u662f\u5426\u8986\u76d6\u4e86\u6574\u4e2a\u5de6\u513f\u5b50\u4ee3\u8868\u7684\u533a\u95f4\uff0crs \u540c\u7406\u3002\n\n\u5bf9\u4e8e ans \u5c31\u6709\u591a\u79cd\u53ef\u80fd\u4e86\uff1a\u5168\u90fd\u5728\u5de6\u513f\u5b50\u533a\u95f4\u7684\uff0c\u5168\u90fd\u5728\u53f3\u513f\u5b50\u533a\u95f4\u7684\uff0c\u8de8\u8fc7\u4e2d\u95f4\u70b9\u7684\u3002\n\npushup \u7684\u65f6\u5019\u5206\u522b\u7ef4\u62a4\u5373\u53ef\uff0c\u53ef\u4ee5 $O(1)$ \u7ef4\u62a4\u3002\n\n\u4e8e\u662f\u8fd9\u9898\u7684\u4ee3\u7801\u4e5f\u5c31\u53ef\u4ee5\u8f7b\u677e\u5199\u51fa\u6765\u5566\uff1a\n```c++\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define fi first\n#define lc (ch[x][0])\n#define se second\n#define U unsigned\n#define rc (ch[x][1])\n#define Re register\n#define LL long long\n#define MP std::make_pair\n#define CLR(i,a) memset(i,a,sizeof(i))\n#define FOR(i,a,b) for(Re int i = a;i <= b;++i)\n#define ROF(i,a,b) for(Re int i = a;i >= b;--i)\n#define SFOR(i,a,b,c) for(Re int i = a;i <= b;i+=c)\n#define SROF(i,a,b,c) for(Re int i = a;i >= b;i-=c)\n#define DEBUG(x) std::cerr << #x << '=' << x << std::endl\n\nconst int MAXN = 500000+5;\n\nint f[MAXN],ch[MAXN][2],size[MAXN],val[MAXN],sum[MAXN],ls[MAXN],rs[MAXN],max[MAXN];\nint rev[MAXN],tag[MAXN];\n\nint a[MAXN],bin[MAXN],cnt,top,N,M;\n\ninline void pushup(int x){\n    size[x] = size[lc] + size[rc] + 1;\n    sum[x] = sum[lc] + sum[rc] + val[x];\n    max[x] = std::max(std::max(max[lc],max[rc]),rs[lc]+ls[rc]+val[x]);\n    ls[x] = std::max(ls[lc],sum[lc]+val[x]+ls[rc]);\n    rs[x] = std::max(rs[rc],sum[rc]+val[x]+rs[lc]);\n}\n\ninline void pushdown(int x){\n    if(tag[x]){\n        tag[x] = rev[x] = false;\n        if(lc){\n            tag[lc] = true;val[lc] = val[x];sum[lc] = val[x]*size[lc];\n        }\n        if(rc){\n            tag[rc] = true;val[rc] = val[x];sum[rc] = val[x]*size[rc];\n        }\n        if(val[x] >= 0){\n            if(lc) ls[lc] = rs[lc] = max[lc] = sum[lc];\n            if(rc) ls[rc] = rs[rc] = max[rc] = sum[rc];\n        }\n        else{\n            if(lc) ls[lc] = rs[lc] = 0,max[lc] = val[x];\n            if(rc) ls[rc] = rs[rc] = 0,max[rc] = val[x];\n        }\n    }\n    if(rev[x]){\n        rev[x] = 0;rev[lc] ^= 1;rev[rc] ^= 1;\n        std::swap(ls[lc],rs[lc]);std::swap(ls[rc],rs[rc]);\n        std::swap(ch[lc][0],ch[lc][1]);std::swap(ch[rc][0],ch[rc][1]);\n    }\n}\n\ninline void rotate(int x){\n    int y = f[x],z = f[y],k = ch[y][1] == x,w = ch[x][!k];\n    ch[z][ch[z][1] == y] = x;f[x] = z;\n    ch[x][!k] = y;f[y] = x;\n    ch[y][k] = w;f[w] = y;\n    pushup(y);pushup(x);\n}\nint root;\ninline void splay(int x,int v){\n    int y,z;\n    while((y = f[x]) != v){\n        if((z = f[y]) != v) rotate((ch[z][1] == y)^(ch[y][1] == x) ? x : y);\n        rotate(x);\n    }\n    if(!v) root = x;\n}\n\nint getkth(int rk){\n    int x = root;\n    while(233){\n        pushdown(x);\n        if(rk <= size[lc]) x = lc;\n        else if(rk == size[lc]+1) return x;\n        else rk -= size[lc]+1,x = rc;\n    }\n}\n\ninline int build(int l,int r,int fa){\n    if(l > r) return 0;\n    int mid = (l + r) >> 1,x;\n    x = top ? bin[top--] : ++cnt;\n    f[x] = fa;val[x] = a[mid];\n    rev[x] = tag[x] = 0;\n    lc = build(l,mid-1,x);rc = build(mid+1,r,x);\n    pushup(x);return x;\n}\n\ninline void insert(int l,int tot){\n    int r = l+1;\n    l = getkth(r);r = getkth(r+1);\n    splay(l,0);splay(r,l);\n    FOR(i,1,tot) scanf(\"%d\",a+i);\n    ch[r][0] = build(1,tot,r);\n    N += tot;pushup(r);pushup(l);\n}\n\ninline void erase(int x){\n    if(!x) return;\n    bin[++top] = x;\n    erase(lc);erase(rc);\n}\n\ninline void del(int l,int r){\n    N -= r-l+1;\n    l = getkth(l);r = getkth(r+2);\n    splay(l,0);splay(r,l);\n    erase(ch[r][0]);ch[r][0] = 0;\n    pushup(r);pushup(l);\n}\n\ninline void modify(int l,int r,int v){\n    l = getkth(l);r = getkth(r+2);\n    splay(l,0);splay(r,l);\n    int x = ch[r][0];\n    val[x] = v;sum[x] = v*size[x];\n    if(v <= 0) ls[x] = rs[x] = 0,max[x] = v;\n    else ls[x] = rs[x] = max[x] = sum[x];\n    tag[x] = 1;\n    pushup(r);pushup(l);\n}\n\ninline void reverse(int l,int r){\n    l = getkth(l);r = getkth(r+2);\n    splay(l,0);splay(r,l);\n    int x = ch[r][0];\n    if(!tag[x]){\n        rev[x] ^= 1;std::swap(lc,rc);std::swap(ls[x],rs[x]);\n        pushup(r);pushup(l);\n    }\n}\n\ninline int querysum(int l,int r){\n    l = getkth(l);r = getkth(r+2);\n    splay(l,0);splay(r,l);\n    return sum[ch[r][0]];\n}\n\ninline int calc(){\n    int l = getkth(1),r = getkth(N+2);\n    splay(l,0);splay(r,l);\n    return max[ch[r][0]];\n}\n\nint main(){\n    scanf(\"%d%d\",&N,&M);\n    max[0] = a[1] = a[N+2] = INT_MIN;\n    FOR(i,1,N) scanf(\"%d\",a+i+1);\n    root = build(1,N+2,0);\n    while(M--){\n        char opt[10];\n        int x,y,z;\n        scanf(\"%s\",opt);\n        if(opt[0] == 'I'){\n            scanf(\"%d%d\",&x,&y);\n            insert(x,y);\n        }\n        if(opt[0] == 'D'){\n            scanf(\"%d%d\",&x,&y);\n            del(x,x+y-1);\n        }\n        if(opt[0] == 'M' && opt[2] == 'K'){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            modify(x,x+y-1,z);\n        }\n        if(opt[0] == 'R'){\n            scanf(\"%d%d\",&x,&y);\n            reverse(x,x+y-1);\n        }\n        if(opt[0] == 'G'){\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%d\\n\",querysum(x,x+y-1));\n        }\n        if(opt[0] == 'M' && opt[2] == 'X'){\n            printf(\"%d\\n\",calc());\n        }\n    }\n    return 0;\n}\n```\n## \u5199\u5728\u6700\u540e\n\u81f3\u4e8e\u6211\u4e3a\u4ec0\u4e48\u4e0d\u5199\u542c\u8d77\u6765\u66f4\u7b80\u5355\u7684 fhq treap\uff0c\u56e0\u4e3a\u6211\u4eec\u673a\u623f\u91cc\u7684\u4eba\u5929\u5929\u5439\u5b83\uff0c\u4e8e\u662f\u6211\u5c31\u4e0d\u60f3\u5b66\u4e86\u3002\u3002\u3002\u53ef\u80fd\u4ee5\u540e\u63a5\u89e6\u5230\u53ef\u6301\u4e45\u5316\u7684\u65f6\u5019\u624d\u4f1a\u5b66QAQ",
        "postTime": 1549123466,
        "uid": 50075,
        "name": "RainAir",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "[Welcome to my Blog](https://zcdhj.org)\n\n\u4e00\u9053\u6bd2\u7624\u7684\u6570\u636e\u7ed3\u6784\u9898\u3002\u3002\u3002\n\n\u603b\u5171\u5199\u4e86\u6211\u4e00\u4e2a\u4e0b\u5348+\u4e00\u4e2a\u665a\u4e0a\n\n\u4e3b\u8981\u601d\u8def\u5c31\u662f\u7528 Splay \u7ef4\u62a4\u5e8f\u5217\n\n\u8fd9\u91cc\u6709\u51e0\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\n\n- \u6700\u5927\u5b50\u4e32\u662f\u4e0d\u80fd\u4e3a\u7a7a\u7684\n- \u5982\u679c\u6709\u4e86\u533a\u95f4 `set` \u64cd\u4f5c\u5c31\u4e0d\u7528\u518d\u8fdb\u884c `reverse` \u64cd\u4f5c\u4e86\n\n\u6211\u9635\u4ea1\u4e86\u3002\u3002\u3002\n\n\u5e0c\u671b\u8fd9\u91cc\u7684\u4ee3\u7801\u80fd\u5e2e\u52a9\u5230\u6307\u9488\u515a qwq\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nconst int MAXN = 500000;\nconst int INF = -1e5;\n\nint n, m;\nint a[MAXN + 3];\n\ninline int read() {\n    register int x = 0, v = 1;\n    register char ch = getchar();\n    while(!isdigit(ch)) {\n        if(ch == '-') v = -1;\n        ch = getchar();\n    }\n    while(isdigit(ch)) {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    return x * v;\n}\n\nnamespace Splay {\n    struct Tree {\n        struct Splay {\n            int val, sumv, lmax, rmax, ansv, setv, size;\n            bool rev;\n            Splay *ch[2], *father;\n            Splay() {}\n            Splay(int _val, Splay *_father) : val(_val), sumv(_val), lmax(std::max(0, _val)), rmax(std::max(0, _val)), ansv(_val), setv(1e9), size(1), rev(0), father(_father) { ch[0] = ch[1] = NULL; }\n        } *root;\n        inline int sumv(Splay *o) { return o ? o -> sumv : 0; }\n        inline int lmax(Splay *o) { return o ? o -> lmax : 0; }\n        inline int rmax(Splay *o) { return o ? o -> rmax : 0; }\n        inline int ansv(Splay *o) { return o ? o -> ansv : INF; }\n        inline int size(Splay *o) { return o ? o -> size : 0; }\n        inline void pushup(Splay *o) {\n            Splay *ls = o -> ch[0], *rs = o -> ch[1];\n            o -> sumv = sumv(ls) + o -> val + sumv(rs);\n            o -> lmax = std::max(lmax(ls), sumv(ls) + o -> val + lmax(rs));\n            o -> rmax = std::max(rmax(rs), sumv(rs) + o -> val + rmax(ls));\n            o -> ansv = std::max(std::max(ansv(ls), ansv(rs)), rmax(ls) + o -> val + lmax(rs));\n            o -> size = size(ls) + 1 + size(rs);        \n        }\n        inline void pushdown(Splay *o) {\n            Splay *ls = o -> ch[0], *rs = o -> ch[1];\n            if(o -> setv != 1e9) {\n                if(ls) {\n                    ls -> val = o -> setv;\n                    ls -> sumv = size(o -> ch[0]) * o -> setv;\n                    ls -> lmax = std::max(ls -> sumv, 0);\n                    ls -> rmax = std::max(ls -> sumv, 0);\n                    ls -> ansv = std::max(ls -> sumv, o -> setv);\n                    ls -> setv = o -> setv;\n                }\n                if(rs) {\n                    rs -> val = o -> setv;\n                    rs -> sumv = size(o -> ch[1]) * o -> setv;\n                    rs -> lmax = std::max(rs -> sumv, 0);\n                    rs -> rmax = std::max(rs -> sumv, 0);\n                    rs -> ansv = std::max(rs -> sumv, o -> setv);\n                    rs -> setv = o -> setv;\n                }\n                o -> setv = 1e9;\n                o -> rev = 0;\n            } else if(o -> rev) {\n                if(ls) {\n                    std::swap(ls -> lmax, ls -> rmax);\n                    ls -> rev ^= 1;\n                }\n                if(rs) {\n                    std::swap(rs -> lmax, rs -> rmax);\n                    rs -> rev ^= 1;\n                }\n                std::swap(o -> ch[0], o -> ch[1]);\n                o -> rev = 0;\n            }\n        }\n        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }\n        inline void connect(Splay *x, Splay *y, int relation) {\n            if(x) x -> father = y;\n            if(y) y -> ch[relation] = x;\n        }\n        inline void rotate(Splay *o) {\n            Splay *p = o -> father, *q = p -> father;\n            int wson = relation(o);\n            connect(o, q, relation(p));\n            connect(o -> ch[wson ^ 1], p, wson);\n            connect(p, o, wson ^ 1);\n            pushup(p);\n            pushup(o);\n        }\n        inline void splay(Splay *o, Splay *goal) {\n            if(!o) return;\n            while(o -> father != goal) {\n                Splay *p = o -> father;\n                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);\n                rotate(o);\n            }   \n            if(!goal) root = o;\n        }\n        inline Splay *kth(int k) {\n            Splay *o = root;\n            while(1) {\n                pushdown(o);\n                if(size(o -> ch[0]) + 1 == k) return o;\n                else if(size(o -> ch[0]) >= k) o = o -> ch[0];\n                else {\n                    k -= size(o -> ch[0]) + 1;\n                    o = o -> ch[1];\n                }\n            }\n            return NULL;\n        }\n        inline void build(Splay *&o, Splay *fa, int l, int r) {\n            if(l > r) return;\n            int mid = (l + r) >> 1;\n            o = new Splay(a[mid], fa);\n            build(o -> ch[0], o, l, mid - 1);\n            build(o -> ch[1], o, mid + 1, r);\n            pushup(o);\n        }\n        inline void remove(Splay *&o) {\n            if(!o) return;\n            remove(o -> ch[0]);\n            remove(o -> ch[1]);\n            delete o;\n            o = NULL;\n        }\n        inline void out(Splay *o) {\n            if(!o) return;\n            pushdown(o);\n            out(o -> ch[0]);\n            if(o -> val != INF) printf(\"%d \", o -> val);\n            out(o -> ch[1]);\n        }\n        inline void Insert() {\n            int pos = read() + 1, tot = read();\n            for(int i = 1; i <= tot; ++i) a[i] = read();    \n            Splay *o1 = kth(pos), *o2 = kth(pos + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            Splay *ptr;\n            build(ptr, NULL, 1, tot);\n            connect(ptr, root -> ch[1], 0);\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void Delete() {\n            int pos = read() + 1, tot = read();\n            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);\n            splay(o1, NULL);\n            splay(o2, o1);\n            remove(root -> ch[1] -> ch[0]);\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void makeSame() {\n            int pos = read() + 1, tot = read(), val = read();\n            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);\n            splay(o1, NULL);\n            splay(o2, o1);\n            Splay *o = root -> ch[1] -> ch[0];\n            o -> val = val;\n            o -> sumv = size(o) * val;\n            o -> lmax = std::max(o -> sumv, 0);\n            o -> rmax = std::max(o -> sumv, 0);\n            o -> ansv = std::max(o -> sumv, val);\n            o -> setv = val;\n            o -> rev = 0;\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void Reverse() {\n           // puts(\"Rese\");\n            int pos = read() + 1, tot = read();\n            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);\n            splay(o1, NULL);\n            splay(o2, o1);\n            root -> ch[1] -> ch[0] -> rev = 1;\n            pushdown(root -> ch[1] -> ch[0]);\n            pushup(root -> ch[1] -> ch[0]);\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void getSum() {\n            int pos = read() + 1, tot = read();\n            Splay *o1 = kth(pos - 1), *o2 = kth(pos + tot);\n            splay(o1, NULL);\n            splay(o2, o1);\n            printf(\"%d\\n\", sumv(root -> ch[1] -> ch[0]));\n        }\n        inline void maxSum() {\n            printf(\"%d\\n\", ansv(root));\n        }\n    } tree;\n}\n\nusing namespace Splay;\n\nint main() {\n    // freopen(\"in.in\", \"r\", stdin);\n    n = read();\n    m = read(); \n    a[1] = a[n + 2] = INF;\n    for(int i = 1; i <= n; ++i) a[i + 1] = read();\n    tree.build(tree.root, NULL, 1, n + 2);\n    while(m--) {\n        char opt[10];\n        scanf(\"%s\", opt);\n        if(*opt == 'I') tree.Insert();\n        else if(*opt == 'D') tree.Delete();\n        else if(*opt == 'M' && opt[2] == 'K') tree.makeSame();\n        else if(*opt == 'R') tree.Reverse();\n        else if(*opt == 'G') tree.getSum();\n        else if(*opt == 'O') tree.out(tree.root), putchar('\\n');\n        else tree.maxSum();\n    }   \n    return 0;\n}\n```\n\n",
        "postTime": 1544258079,
        "uid": 24878,
        "name": "iodwad",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u56e0\u4e3a$leafytree$\u652f\u6301\u5feb\u901f\u5408\u5e76\u5206\u88c2\uff0c\u56e0\u6b64\u53ef\u4ee5\u505a\u4e0e\u533a\u95f4\u76f8\u5173\u7684\u51e0\u4e4e\u6240\u6709\u5e73\u8861\u6811\u9898\u3002\n\n\u8fd9\u9053\u9898\u76ee\u57fa\u672c\u4e0a\u662f\u4e00\u4e2a\u5e73\u8861\u6811\u533a\u95f4\u64cd\u4f5c\u88f8\u9898\u4e86\u3002\u4f60\u53ea\u9700\u8981\u5199\u4e00\u4e2a\u63d0\u53d6\u533a\u95f4\u5373\u53ef\u5b8c\u6210\u9664\u6700\u540e\u4e00\u4e2a\u4ee5\u5916\u6240\u6709\u64cd\u4f5c\u3002\n\n\u81f3\u4e8e\u6700\u540e\u4e00\u4e2a\uff0c\u4f60\u53ef\u4ee5\u518d\u989d\u5916\u7ef4\u62a4\u524d\u7f00\u548c\u540e\u7f00\u6700\u5927\u8fde\u7eed\u548c\uff0c\u4ee5\u53ca\u533a\u95f4\u7b54\u6848\u3002\u7136\u540e\u5728$pushup$\u4e2d\u95f4\u4e0a\u4f20\u5373\u53ef\u3002\n\n\u5177\u4f53\u64cd\u4f5c:\n\n### 1.\u5185\u5b58\u7ba1\u7406:\n\u8fd9\u9053\u9898\u76ee\u7684\u603b\u70b9\u6570\u6781\u591a\uff0c\u4f46\u662f\u540c\u65f6\u5b58\u5728\u7684\u70b9\u6570\u4e0d\u591a\u3002\u56e0\u6b64\u4f60\u9700\u8981\u5199\u4e00\u4e2a\u5185\u5b58\u6c60\u7ba1\u7406\u5185\u5b58\u3002\u4f60\u53ea\u9700\u8981\u5199\u51e0\u4e2a\u7533\u8bf7\u5185\u5b58\u548c\u56de\u6536\u5185\u5b58\u7684\u51fd\u6570\u5373\u53ef\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\n\tinline int newnode()\n\t{\n\t\tlaz[sta[tp]]=1111;\n\t\treturn sta[tp--];\n\t}\n\n\tinline void del(int u)\n\t{\n    sz[u]=sm[u]=pr[u]=sf[u]=ans[u]=ls(u)=rs(u)=fa[u]=0;\n\t\trev[u]=laz[u]=0,sta[++tp]=u;\n\t}\n\n\tinline void dfdel(int h)//\u8fd9\u4e2a\u5728\u540e\u9762\u7684\u533a\u95f4\u5220\u9664\u8981\u7528\n\t{\n\t\tif(ls(h))dfdel(ls(h)),dfdel(rs(h));\n\t\tdel(h);\n\t}\n```\n\n### 2.\u5408\u5e76\u5206\u88c2\n\u8fd9\u4e2a\u4e0e$FHQ$\u7684\u5dee\u4e0d\u591a\uff0c\u4f46\u662f\u9700\u8981\u540c\u65f6\u7ef4\u62a4\u5e73\u8861\uff0c\u56e0\u6b64\u6709\u66f4\u591a\u5206\u7c7b\u8ba8\u8bba\u3002\n\n\u4f60\u53ef\u4ee5\u770b[\u8fd9\u7bc7](https://www.luogu.org/blog/user7035/solution-P3391-leafytree)\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tint merge(int u,int v)\n\t{\n\t\tif(!u||!v)return u|v;\n\t\tif(sz[u]>=sz[v]&&sz[v]>=mlim*sz[u]\n\t\t\t||sz[u]<=sz[v]&&sz[u]>=mlim*sz[v])\n\t\t{\n\t\t\tregister int cur=newnode();\n\t\t\tfa[ls(cur)=u]=fa[rs(cur)=v]=cur;\n\t\t\tpushup(cur);\n\t\t\treturn cur;\n\t\t}\n\t\tif(sz[u]>=sz[v])\n\t\t{\n\t\t\tpushdown(u);\n\t\t\tint Ls=ls(u),Rs=rs(u);\n\t\t\tdel(u);\n\t\t\tif(sz[Ls]>=alp*(sz[Ls]+sz[Rs]+sz[v]))\n\t\t\t\treturn merge(Ls,merge(Rs,v));\n\t\t\telse\n\t\t\t{\n\t\t\t\tpushdown(Rs);\n\t\t\t\tint LS=ls(Rs),RS=rs(Rs);\n\t\t\t\tdel(Rs);\n\t\t\t\treturn merge(merge(Ls,LS),merge(RS,v));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpushdown(v);\n\t\t\tint Ls=ls(v),Rs=rs(v);\n\t\t\tdel(v);\n\t\t\tif(sz[Rs]>=alp*(sz[Ls]+sz[Rs]+sz[u]))\n\t\t\t\treturn merge(merge(u,Ls),Rs);\n\t\t\telse\n\t\t\t{\n\t\t\t\tpushdown(Ls);\n\t\t\t\tint LS=ls(Ls),RS=rs(Ls);\n\t\t\t\tdel(Ls);\n\t\t\t\treturn merge(merge(u,LS),merge(RS,Rs));\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int,int>PII;\n#define fi first\n#define se second\n\n\tPII split(int h,int x)\n\t{\n\t\tif(!h||!x)return mp(0,h);\n\t\tif(x==sz[h])return mp(h,0);\n\t\tPII y;\n\t\tpushdown(h);\n\t\tint Ls=ls(h),Rs=rs(h);\n\t\tdel(h);\n\t\tif(x<=sz[Ls])\n\t\t{\n\t\t\ty=split(Ls,x);\n\t\t\treturn mp(y.fi,merge(y.se,Rs));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty=split(Rs,x-sz[Ls]);\n\t\t\treturn mp(merge(Ls,y.fi),y.se);\n\t\t}\n\t}\n```\n\n### 3.\u5efa\u6811\u4e0e\u63d2\u5165\n\n\u56e0\u4e3a$leafytree$\u7684\u5f62\u6001\u4e0e\u7ebf\u6bb5\u6811\u76f8\u540c\uff0c\u56e0\u6b64\u53ef\u4ee5\u76f4\u63a5\u6309\u7167\u7ebf\u6bb5\u6811\u5efa\u6811\u7684\u65b9\u6cd5\u76f4\u63a5\u5efa\u51fa\u4e00\u68f5\u5b8c\u5168\u5e73\u8861\u7684\u6811\u3002\n\n\u81f3\u4e8e\u63d2\u5165\uff0c\u76f4\u63a5\u5c06\u539f\u6811\u5206\u6210\u4e24\u90e8\u5206\uff0c\u518d\u5c06\u65b0\u5efa\u7684\u6811\u63d2\u5165\u5373\u53ef\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tvoid make_tree(int&h,int l,int r,int*a)//\u5229\u7528a[]\u4e2d\u7684\u5143\u7d20\u5efa\u6811\n\t{\n\t\th=newnode();\n\t\tif(l==r)\n\t\t{\n\t\t\tsz[h]=1;\n\t\t\tpr[h]=sf[h]=ans[h]=sm[h]=a[l];\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tmake_tree(son[h][0],l,mid,a);\n\t\tmake_tree(son[h][1],mid+1,r,a);\n\t\tpushup(h);\n\t}\n\n\tinline void ins(int ps,int RT)\n\t{\n\t\tregister PII y=split(rt,ps);\n\t\trt=merge(y.fi,merge(RT,y.se));\n\t}\n```\n\n### 4.\u63d0\u53d6\u533a\u95f4\n\n\u8fd9\u4e2a\u7b80\u5355\u3002\u76f4\u63a5\u5c06\u6574\u68f5\u6811\u5206\u88c2\u6210\u51e0\u90e8\u5206\u5c31\u53ef\u4ee5\u4e86\u3002\u4e3a\u4e86\u65b9\u4fbf\uff0c\u6211\u628a\u5b83\u5355\u72ec\u5199\u6210\u4e86\u4e00\u4e2a\u51fd\u6570\uff0c\u5206\u6210\u7684$3$\u68f5\u6811\u5b58\u5728$nd$\u5185\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tstatic int nd[3];\n\n\tinline void getseg(int l,int r)\n\t{\n\t\tregister PII y=split(rt,l-1),z=split(y.se,r-l+1);\n\t\tnd[0]=y.fi,nd[1]=z.fi,nd[2]=z.se;\n\t}\n```\n\n### 5.\u6240\u6709\u5176\u4f59\u533a\u95f4\u64cd\u4f5c\n\n\u5229\u7528\u4e0a\u9762\u7684\u63d0\u53d6\u533a\u95f4\u63d0\u53d6\u533a\u95f4\u540e\uff0c\u76f4\u63a5\u5bf9\u4e2d\u95f4\u7684\u6811\u6253\u4e0a\u6807\u8bb0\uff0c\u7136\u540e\u518d\u5408\u5e76\u3002\n\n\u533a\u95f4\u7ffb\u8f6c\u4e3a\u4e86\u4fdd\u8bc1\u6b63\u786e\u6027\uff0c\u5e94\u8be5\u5148\u7ffb\u8f6c\u4e00\u5c42\uff0c\u518d\u6253\u4e0a\u6807\u8bb0\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tinline void sakuzyo(int l,int len)//\u5220\u9664\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tdfdel(nd[1]);\n\t\trt=merge(nd[0],nd[2]);\n\t}\n\n\tinline void modify(int l,int len,int x)//\u533a\u95f4\u4fee\u6539\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tlaz[nd[1]]=x;\n\t\tpr[nd[1]]=sf[nd[1]]=ans[nd[1]]\n\t\t\t=max(sm[nd[1]]=sz[nd[1]]*laz[nd[1]],x);\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t}\n\n\tinline void reverse(int l,int len)//\u533a\u95f4\u7ffb\u8f6c\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tif(ls(nd[1]))\n\t\t{\n\t\t\tswap(pr[nd[1]],sf[nd[1]]);\n\t\t\tswap(ls(nd[1]),rs(nd[1]));\n\t\t\trev[nd[1]]^=1;\n\t\t}\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t}\n\n\tinline int getsm(int l,int len)//\u533a\u95f4\u6c42\u548c\n\t{\n\t\tstatic int as;\n\t\tgetseg(l,l+len-1);\n\t\tas=sm[nd[1]];\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t\treturn as;\n\t}\n```\n\n### 6.\u6700\u5927\u5b50\u6bb5\u548c\n\n\u5728\u7ef4\u62a4\u5927\u5c0f\u548c\u533a\u95f4\u548c\u4ee5\u5916\uff0c\u6211\u4eec\u518d\u989d\u5916\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u975e\u7a7a\u524d\u7f00\u548c\u533a\u95f4\u6700\u5927\u98de\u7a7a\u540e\u7f00\u4ee5\u53ca\u533a\u95f4\u6700\u5927\u975e\u7a7a\u5b50\u6bb5\u548c\u3002\u7136\u540e\u8fd9\u4e2a\u4e1c\u897f\u5c31\u53ef\u4ee5\u76f4\u63a5\u52a8\u6001\u5229\u7528\u5e73\u8861\u6811\u8fdb\u884c\u7ef4\u62a4\u4e86\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tinline void pushup(int h)\n\t{\n\t\tif(ls(h))\n\t\t{\n\t\t\tsz[h]=sz[ls(h)]+sz[rs(h)];\n\t\t\tsm[h]=sm[ls(h)]+sm[rs(h)];\n\t\t\tans[h]=max(max(ans[ls(h)],ans[rs(h)]),sf[ls(h)]+pr[rs(h)]);\n\t\t\tpr[h]=max(sm[ls(h)]+pr[rs(h)],pr[ls(h)]);\n\t\t\tsf[h]=max(sm[rs(h)]+sf[ls(h)],sf[rs(h)]);\n\t\t}\n\t}\n```\n\n### 7.\u5c0f\u7ec6\u8282\n\u8bb0\u5f97\u53ca\u65f6\u56de\u6536\u5185\u5b58\uff0c\u7136\u540e\u6807\u8bb0\u7ef4\u62a4\u65f6\u6ce8\u610f\u4e00\u4e9b\u7ec6\u8282\u3002\n\n\u4ee3\u7801\u90e8\u5206:\n```cpp\n\tinline void pushdown(int h)\n\t{\n\t\tif(ls(h))\n\t\t{\n\t\t\tif(laz[h]<=1000)\n\t\t\t{\n\t\t\t\tpr[ls(h)]=sf[ls(h)]=ans[ls(h)]\n\t\t\t\t\t=max(sm[ls(h)]=sz[ls(h)]*laz[h],laz[h]);\n\t\t\t\tpr[rs(h)]=sf[rs(h)]=ans[rs(h)]\n\t\t\t\t\t=max(sm[rs(h)]=sz[rs(h)]*laz[h],laz[h]);\n\t\t\t\tlaz[ls(h)]=laz[rs(h)]=laz[h];\n\t\t\t\tlaz[h]=1111;\n\t\t\t}\n\t\t\tif(rev[h])\n\t\t\t{\n\t\t\t\tif(ls(ls(h)))\n\t\t\t\t{\n\t\t\t\t\tswap(ls(ls(h)),rs(ls(h)));\n\t\t\t\t\tswap(pr[ls(h)],sf[ls(h)]);\n\t\t\t\t\trev[ls(h)]^=1;\n\t\t\t\t}\n\t\t\t\tif(ls(rs(h)))\n\t\t\t\t{\n\t\t\t\t\tswap(ls(rs(h)),rs(rs(h)));\n\t\t\t\t\tswap(pr[rs(h)],sf[rs(h)]);\n\t\t\t\t\trev[rs(h)]^=1;\n\t\t\t\t}\n\t\t\t\trev[h]=0;\n\t\t\t}\n\t\t}\n\t}\n```\n\n\u603b\u4ee3\u7801:\n```cpp\n#include<bits/stdc++.h>\n#include<bits/extc++.h>\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ef emplace_front\n#define ob pop_back\n#define of pop_front\n#define Chkmax(a,b) a=a>b?a:b\n#define Chkmin(a,b) a=a<b?a:b\ntypedef unsigned long long uint64;\ntypedef unsigned int uint32;\ntypedef long long ll;\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\nnamespace IO\n{\n    const uint32 Buffsize=1<<15,Output=1<<23;\n    static char Ch[Buffsize],*S=Ch,*T=Ch;\n    inline char getc()\n    {\n        return((S==T)&&(T=(S=Ch)+fread(Ch,1,Buffsize,stdin),S==T)?0:*S++);\n    }\n    static char Out[Output],*nowps=Out;\n    \n    inline void flush(){fwrite(Out,1,nowps-Out,stdout);nowps=Out;}\n\n    template<typename T>inline void read(T&x)\n    {\n        x=0;static char ch;T f=1;\n        for(ch=getc();!isdigit(ch);ch=getc())if(ch=='-')f=-1;\n        for(;isdigit(ch);ch=getc())x=x*10+(ch^48);\n        x*=f;\n    }\n\n    template<typename T>inline void write(T x,char ch='\\n')\n    {\n        if(!x)*nowps++='0';\n        if(x<0)*nowps++='-',x=-x;\n        static uint32 sta[111],tp;\n        for(tp=0;x;x/=10)sta[++tp]=x%10;\n        for(;tp;*nowps++=sta[tp--]^48);\n        *nowps++=ch;\n    }\n}\nusing namespace IO;\n\ninline void file()\n{\n#ifndef ONLINE_JUDGE\n    FILE*DSA=freopen(\"leafytree2.in\",\"r\",stdin);\n    FILE*SDU=freopen(\"leafytree2.out\",\"w\",stdout);\n#endif\n}\n\nconst int MAXN=1e6+7;\n\nnamespace BST\n{\n\tconst double alp=1-sqrt(2)/2,lim=(1-2*alp)/(1-alp),mlim=alp/(1-alp);\n\n\tstatic int rt,son[MAXN][2],fa[MAXN],sz[MAXN],sta[MAXN],tp;\n\tstatic int sm[MAXN],pr[MAXN],sf[MAXN],ans[MAXN],rev[MAXN],laz[MAXN];\n\n#define ls(u) son[u][0]\n#define rs(u) son[u][1]\n\n\tinline int newnode()\n\t{\n\t\tlaz[sta[tp]]=1111;\n\t\treturn sta[tp--];\n\t}\n\n\tinline void del(int u)\n\t{\n\t\tsz[u]=sm[u]=pr[u]=sf[u]=ans[u]=ls(u)=rs(u)=fa[u]=0;\n\t\trev[u]=laz[u]=0,sta[++tp]=u;\n\t}\n\n\tinline void pushup(int h)\n\t{\n\t\tif(ls(h))\n\t\t{\n\t\t\tsz[h]=sz[ls(h)]+sz[rs(h)];\n\t\t\tsm[h]=sm[ls(h)]+sm[rs(h)];\n\t\t\tans[h]=max(max(ans[ls(h)],ans[rs(h)]),sf[ls(h)]+pr[rs(h)]);\n\t\t\tpr[h]=max(sm[ls(h)]+pr[rs(h)],pr[ls(h)]);\n\t\t\tsf[h]=max(sm[rs(h)]+sf[ls(h)],sf[rs(h)]);\n\t\t}\n\t}\n\n\tinline void pushdown(int h)\n\t{\n\t\tif(ls(h))\n\t\t{\n\t\t\tif(laz[h]<=1000)\n\t\t\t{\n\t\t\t\tpr[ls(h)]=sf[ls(h)]=ans[ls(h)]\n\t\t\t\t\t=max(sm[ls(h)]=sz[ls(h)]*laz[h],laz[h]);\n\t\t\t\tpr[rs(h)]=sf[rs(h)]=ans[rs(h)]\n\t\t\t\t\t=max(sm[rs(h)]=sz[rs(h)]*laz[h],laz[h]);\n\t\t\t\tlaz[ls(h)]=laz[rs(h)]=laz[h];\n\t\t\t\tlaz[h]=1111;\n\t\t\t}\n\t\t\tif(rev[h])\n\t\t\t{\n\t\t\t\tif(ls(ls(h)))\n\t\t\t\t{\n\t\t\t\t\tswap(ls(ls(h)),rs(ls(h)));\n\t\t\t\t\tswap(pr[ls(h)],sf[ls(h)]);\n\t\t\t\t\trev[ls(h)]^=1;\n\t\t\t\t}\n\t\t\t\tif(ls(rs(h)))\n\t\t\t\t{\n\t\t\t\t\tswap(ls(rs(h)),rs(rs(h)));\n\t\t\t\t\tswap(pr[rs(h)],sf[rs(h)]);\n\t\t\t\t\trev[rs(h)]^=1;\n\t\t\t\t}\n\t\t\t\trev[h]=0;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid make_tree(int&h,int l,int r,int*a)\n\t{\n\t\th=newnode();\n\t\tif(l==r)\n\t\t{\n\t\t\tsz[h]=1;\n\t\t\tpr[h]=sf[h]=ans[h]=sm[h]=a[l];\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tmake_tree(son[h][0],l,mid,a);\n\t\tmake_tree(son[h][1],mid+1,r,a);\n\t\tpushup(h);\n\t}\n\n\tint merge(int u,int v)\n\t{\n\t\tif(!u||!v)return u|v;\n\t\tif(sz[u]>=sz[v]&&sz[v]>=mlim*sz[u]\n\t\t\t||sz[u]<=sz[v]&&sz[u]>=mlim*sz[v])\n\t\t{\n\t\t\tregister int cur=newnode();\n\t\t\tfa[ls(cur)=u]=fa[rs(cur)=v]=cur;\n\t\t\tpushup(cur);\n\t\t\treturn cur;\n\t\t}\n\t\tif(sz[u]>=sz[v])\n\t\t{\n\t\t\tpushdown(u);\n\t\t\tint Ls=ls(u),Rs=rs(u);\n\t\t\tdel(u);\n\t\t\tif(sz[Ls]>=alp*(sz[Ls]+sz[Rs]+sz[v]))\n\t\t\t\treturn merge(Ls,merge(Rs,v));\n\t\t\telse\n\t\t\t{\n\t\t\t\tpushdown(Rs);\n\t\t\t\tint LS=ls(Rs),RS=rs(Rs);\n\t\t\t\tdel(Rs);\n\t\t\t\treturn merge(merge(Ls,LS),merge(RS,v));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpushdown(v);\n\t\t\tint Ls=ls(v),Rs=rs(v);\n\t\t\tdel(v);\n\t\t\tif(sz[Rs]>=alp*(sz[Ls]+sz[Rs]+sz[u]))\n\t\t\t\treturn merge(merge(u,Ls),Rs);\n\t\t\telse\n\t\t\t{\n\t\t\t\tpushdown(Ls);\n\t\t\t\tint LS=ls(Ls),RS=rs(Ls);\n\t\t\t\tdel(Ls);\n\t\t\t\treturn merge(merge(u,LS),merge(RS,Rs));\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int,int>PII;\n#define fi first\n#define se second\n\n\tPII split(int h,int x)\n\t{\n\t\tif(!h||!x)return mp(0,h);\n\t\tif(x==sz[h])return mp(h,0);\n\t\tPII y;\n\t\tpushdown(h);\n\t\tint Ls=ls(h),Rs=rs(h);\n\t\tdel(h);\n\t\tif(x<=sz[Ls])\n\t\t{\n\t\t\ty=split(Ls,x);\n\t\t\treturn mp(y.fi,merge(y.se,Rs));\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty=split(Rs,x-sz[Ls]);\n\t\t\treturn mp(merge(Ls,y.fi),y.se);\n\t\t}\n\t}\n\n\tstatic int nd[3];\n\n\tinline void ins(int ps,int RT)\n\t{\n\t\tregister PII y=split(rt,ps);\n\t\trt=merge(y.fi,merge(RT,y.se));\n\t}\n\t\n\tinline void getseg(int l,int r)\n\t{\n\t\tregister PII y=split(rt,l-1),z=split(y.se,r-l+1);\n\t\tnd[0]=y.fi,nd[1]=z.fi,nd[2]=z.se;\n\t}\n\n\tinline void dfdel(int h)\n\t{\n\t\tif(ls(h))dfdel(ls(h)),dfdel(rs(h));\n\t\tdel(h);\n\t}\n\n\tinline void sakuzyo(int l,int len)\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tdfdel(nd[1]);\n\t\trt=merge(nd[0],nd[2]);\n\t}\n\n\tinline void modify(int l,int len,int x)\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tlaz[nd[1]]=x;\n\t\tpr[nd[1]]=sf[nd[1]]=ans[nd[1]]\n\t\t\t=max(sm[nd[1]]=sz[nd[1]]*laz[nd[1]],x);\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t}\n\n\tinline void reverse(int l,int len)\n\t{\n\t\tgetseg(l,l+len-1);\n\t\tif(ls(nd[1]))\n\t\t{\n\t\t\tswap(pr[nd[1]],sf[nd[1]]);\n\t\t\tswap(ls(nd[1]),rs(nd[1]));\n\t\t\trev[nd[1]]^=1;\n\t\t}\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t}\n\n\tinline int getsm(int l,int len)\n\t{\n\t\tstatic int as;\n\t\tgetseg(l,l+len-1);\n\t\tas=sm[nd[1]];\n\t\trt=merge(nd[0],merge(nd[1],nd[2]));\n\t\treturn as;\n\t}\n}\nusing namespace BST;\n\nstatic int n,m,a[MAXN];\n\ninline void getstr(char*q)\n{\n\tregister char ch;\n\tfor(ch=getc();!isgraph(ch);ch=getc());\n\tfor(;isgraph(ch);ch=getc())*q++=ch;\n\t*q='\\0';\n}\n\nconst int MXNODE=1e6;\n\nvoid init()\n{\n\tread(n),read(m);\n\tRep(i,1,MXNODE)sta[++tp]=MXNODE-i+1;\n\tRep(i,1,n)read(a[i]);\n\tmake_tree(rt,1,n,a);\n}\n\nstatic int RT;\n\nstatic char s[111];\n\ninline void solve()\n{\n\tstatic int tot,ps,x;\n\tRep(i,1,m)\n\t{\n\t\tgetstr(s+1);\n\t\tif(s[1]=='I')\n\t\t{\n\t\t\tread(ps),read(tot);\n\t\t\tRep(j,1,tot)read(a[j]);\n\t\t\tmake_tree(RT,1,tot,a);\n\t\t\tins(ps,RT);\n\t\t}\n\t\telse if(s[1]=='D')\n\t\t{\n\t\t\tread(ps),read(tot);\n\t\t\tsakuzyo(ps,tot);\n\t\t}\n\t\telse if(s[1]=='M')\n\t\t{\n\t\t\tif(s[3]=='K')\n\t\t\t{\n\t\t\t\tread(ps),read(tot),read(x);\n\t\t\t\tmodify(ps,tot,x);\n\t\t\t}\n\t\t\telse write(ans[rt]);\n\t\t}\n\t\telse if(s[1]=='R')\n\t\t{\n\t\t\tread(ps),read(tot);\n\t\t\treverse(ps,tot);\n\t\t}\n\t\telse if(s[1]=='G')\n\t\t{\n\t\t\tread(ps),read(tot);\n\t\t\twrite(getsm(ps,tot));\n\t\t}\n\t\tif(i%100000==0)flush();\n\t}flush();\n}\n\nint main()\n{\n\tfile();\n    init();\n    solve();\n    return 0;\n}\n```",
        "postTime": 1540784522,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u5206\u6790\n\n\u8fd9\u79cd\u5e26\u7ffb\u8f6c\u3001\u63d2\u5165\u3001\u5220\u9664\u64cd\u4f5c\u7684\u7ef4\u62a4\u5e8f\u5217\u7684\u95ee\u9898\uff0c\u5f88\u5bb9\u6613\u60f3\u5230splay\n\n\u7528splay\u7ef4\u62a4\u533a\u95f4[l,r]\u7684\u4ee5\u4e0b\u51e0\u4e2a\u6570\uff1a \nsum\uff08\u8868\u793a\u533a\u95f4\u548c\uff09 \nls\uff08\u8868\u793a\u4ee5l\u4e3a\u5de6\u7aef\u7684\u5b50\u5217\u7684\u548c\u7684\u6700\u5927\u503c\uff09 \nrs\uff08\u8868\u793a\u4ee5r\u4e3a\u53f3\u7aef\u7684\u5b50\u5217\u7684\u548c\u7684\u6700\u5927\u503c\uff09 \nms\uff08\u8868\u793a\u6b64\u533a\u95f4\u6240\u6709\u5b50\u5217\u7684\u548c\u7684\u6700\u5927\u503c\uff09\n\n\u7136\u540e\u770b\u6bcf\u4e2a\u64cd\u4f5c\uff1a\n\n\u63d2\u5165\u3001\u5220\u9664\u548c\u4e00\u822c\u6ca1\u4ec0\u4e48\u533a\u522b\uff0c\u5148\u9009\u53d6\u533a\u95f4\uff0c\u7136\u540e\u64cd\u4f5c\u3002\n\nmake_same\uff1a\u9009\u53d6\u533a\u95f4\uff0c\u7136\u540e\u6253\u4e2a\u6807\u8bb0\u3002\n\n\u7ffb\u8f6c\uff1a\u540c\u6837\u662f\u6253\u6807\u8bb0\u3002\u4e0b\u4f20\u65f6\uff0c\u628a\u5bf9\u5e94\u533a\u95f4\u7684ls\u548crs\u4ea4\u6362\uff0c\u5176\u5b83\u4e0d\u53d8\uff08\u56e0\u4e3a\u7ffb\u8f6c\u540e\uff0c\u7ef4\u62a4\u7684ls,rs,ms,sum\u5bf9\u5e94\u7684\u662f\u8be5\u533a\u95f4\u4ece\u53f3\u5230\u5de6\u904d\u5386\u51fa\u6765\u7684\u6570\u5217\uff0c\u5176\u4e2d\u603b\u548c\u3001ms\u662f\u4e0d\u4f1a\u53d8\u7684\uff0cls,rs\u4e5f\u53ea\u662f\u6362\u5230\u4e86\u53e6\u4e00\u8fb9\uff09\n\n\u6c42\u548c\uff1a\u4e5f\u662f\u548c\u4e00\u822c\u7684\u6ca1\u4ec0\u4e48\u533a\u522b\u3002\n\n\u6c42\u548c\u6700\u5927\u7684\u5b50\u5217\uff1a\u5f53\u5728splay\u65cb\u8f6c\u65f6\u8fdb\u884cupdate(x)\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u628a\u8282\u70b9son[x][0],x,son[x][1] \u5206\u522b\u770b\u6210\u4e00\u4e2a\u533a\u95f4\uff0c\u5148\u5408\u5e76son[x][0]\u548cx\uff0c\u518d\u4e0eson[x][1]\u5408\u5e76\u3002\u6ce8\u610f\uff1a\u8981\u628a\u533a\u95f4[1..n]\uff08n\u4e3a\u5f53\u524d\u5e8f\u5217\u6570\u7684\u4e2a\u6570\uff09\u9009\u53d6\u51fa\u6765\u518d\u8f93\u51fa\uff08\u6216\u8005\u628a\u7ef4\u62a4\u5e8f\u5217\u65f6\u524d\u540e\u52a0\u7684\u6570\u8d4b\u503c\u4e3a\u4e00\u4e2a\u5f88\u5c0f\u7684\u6570\uff09\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u7b54\u6848\u3002\n\n\u7a7a\u95f4\n\n\u5f004000000\u7684\u6570\u7ec4\u4f1a\u7206\u7a7a\u95f4\uff0c\u4f46\u662f\u9898\u76ee\u9650\u5236\u7684\u6bcf\u4e00\u65f6\u523b\u6570\u7684\u6570\u91cf\u6700\u591a\u4e3a500000\uff0c\u90a3\u4e48\u53ef\u4ee5\u56de\u6536\u5220\u9664\u64cd\u4f5c\u540e\u591a\u51fa\u7684\u7a7a\u95f4\u3002\u5177\u4f53\u662f\u7528\u4e00\u4e2a\u6808\u6765\u5b58\u5f53\u524d\u53ef\u7528\u7684\u7a7a\u95f4\uff0c\u63d2\u5165\u65f6\u4ece\u6808\u9876\u5f39\u51fa\uff0c\u5220\u9664\u65f6\u52a0\u5165\u6808\u3002\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn=500010,Null=500002;\nint m,n,root,top,son[maxn][2],fa[maxn],mask[maxn],sum[maxn],size[maxn],ls[maxn],rs[maxn],ms[maxn],a[maxn],st[maxn],A[maxn],data[maxn];\nbool flip[maxn],bz;\nchar c;\nint read()\n{\n    int x=bz=0;\n    for (c=getchar();(c<'0' || c>'9') && c!='-';c=getchar());\n    if (c=='-')\n    {\n        bz=1; c=getchar();\n    }\n    for (;c>='0' && c<='9';c=getchar()) x=x*10+c-48;\n    if (bz) x=-x;\n    return x;\n}\nvoid make_same(int x,int y)\n{\n    a[x]=mask[x]=y; sum[x]=y*size[x];\n    if (y>0) ls[x]=rs[x]=ms[x]=sum[x];//\u5b50\u5217\u4e0d\u80fd\u4e3a\u7a7a\n    else ls[x]=rs[x]=ms[x]=y;\n}\nvoid push_down(int x)//\u4e0b\u4f20\u6807\u8bb0\n{\n    if (flip[x])\n    {\n        son[x][0]^=son[x][1]^=son[x][0]^=son[x][1];\n        flip[son[x][0]]^=1; flip[son[x][1]]^=1;\n        ls[son[x][0]]^=rs[son[x][0]]^=ls[son[x][0]]^=rs[son[x][0]];\n        ls[son[x][1]]^=rs[son[x][1]]^=ls[son[x][1]]^=rs[son[x][1]];\n        flip[x]=0;\n    }\n    if (mask[x]!=Null)\n    {\n        if (son[x][0]!=Null) make_same(son[x][0],mask[x]);\n        if (son[x][1]!=Null) make_same(son[x][1],mask[x]);\n        mask[x]=Null;\n    }\n}\nvoid calc(int ll,int lr,int lm,int ls,int rl,int rr,int rm,int rs,int &l,int &r,int &m)\n{\n    l=max(ll,ls+rl);\n    r=max(rr,rs+lr);\n    m=max(max(lm,rm),lr+rl);\n}//\u5408\u5e76\u4e24\u4e2a\u533a\u95f4\u7684ls,rs,ms\nvoid update(int x)\n{\n    if (son[x][0]==Null)\n    {\n        if (son[x][1]==Null)\n        {\n            ls[x]=rs[x]=ms[x]=a[x];\n        }else calc(a[x],a[x],a[x],a[x],ls[son[x][1]],rs[son[x][1]],ms[son[x][1]],sum[son[x][1]],ls[x],rs[x],ms[x]);\n    }else\n    {\n        if (son[x][1]==Null)\n        calc(ls[son[x][0]],rs[son[x][0]],ms[son[x][0]],sum[son[x][0]],a[x],a[x],a[x],a[x],ls[x],rs[x],ms[x]);\n        else\n        {\n            calc(ls[son[x][0]],rs[son[x][0]],ms[son[x][0]],sum[son[x][0]],a[x],a[x],a[x],a[x],ls[x],rs[x],ms[x]);\n            calc(ls[x],rs[x],ms[x],sum[son[x][0]]+a[x],ls[son[x][1]],rs[son[x][1]],ms[son[x][1]],sum[son[x][1]],ls[x],rs[x],ms[x]);\n        }\n    }\n    sum[x]=sum[son[x][0]]+sum[son[x][1]]+a[x];\n    size[x]=size[son[x][0]]+size[son[x][1]]+1;\n}\nvoid Rotate(int x,int t)\n{\n    int y=fa[x];\n    if (y!=root)\n    {\n        if (son[fa[y]][0]==y) son[fa[y]][0]=x;else son[fa[y]][1]=x;\n    }else root=x;\n    fa[x]=fa[y]; fa[y]=x; son[y][t]=son[x][1-t]; son[x][1-t]=y; if (son[y][t]!=Null) fa[son[y][t]]=y;\n    update(y);\n}\nvoid splay(int x,int f)\n{\n    while (fa[x]!=f)\n    {\n        int y=fa[x];\n        if (fa[y]==f)\n        {\n            push_down(y); push_down(x);\n            if (son[y][0]==x) Rotate(x,0); else Rotate(x,1);\n        }else\n        {\n            int z=fa[y];\n            push_down(z); push_down(y); push_down(x);\n            if (son[y][0]==x)\n            {\n                if (son[z][0]==y)\n                {\n                    Rotate(y,0); Rotate(x,0);\n                }else\n                {\n                    Rotate(x,0); Rotate(x,1);\n                }\n            }else\n            {\n                if (son[z][0]==y)\n                {\n                    Rotate(x,1); Rotate(x,0);\n                }else\n                {\n                    Rotate(y,1); Rotate(x,1);\n                }\n            }\n        }\n    }\n    update(x);\n}\nvoid Select(int x,int f)\n{\n    int i=root;\n    while (size[son[i][0]]!=x)\n    {\n        if (size[son[i][0]]>x) i=son[i][0];\n        else\n        {\n            x-=size[son[i][0]]+1; i=son[i][1];\n        }\n        push_down(i);\n    }\n    splay(i,f);\n}\nvoid Delete(int x,int t)\n{\n    int tot=1; data[1]=son[x][t];\n    for (int i=1;i<=tot;i++)\n    {\n        st[++top]=data[i];//\u56de\u6536\n        if (son[data[i]][0]!=Null) data[++tot]=son[data[i]][0];\n        if (son[data[i]][1]!=Null) data[++tot]=son[data[i]][1];\n    }\n    son[x][t]=Null;\n    splay(x,Null);\n}\nvoid build(int l,int r,int &root)\n{\n    int mid=(l+r)/2;\n    a[root=st[top--]]=A[mid];//\u5728\u6808\u9876\u5f97\u5230\u5b83\u7684\u7f16\u53f7\n    if (l<mid)\n    {\n        build(l,mid-1,son[root][0]);\n        fa[son[root][0]]=root;\n    }else son[root][0]=Null;\n    if (mid<r)\n    {\n        build(mid+1,r,son[root][1]);\n        fa[son[root][1]]=root;\n    }else son[root][1]=Null;\n    update(root); mask[root]=Null; flip[root]=0;\n}\nint main()\n{\n    n=read(); m=read();\n    for (int i=Null-1;i>=0;i--) st[++top]=i;\n    for (int i=1;i<=n;i++) A[i]=read();\n    build(0,n+1,root); fa[root]=Null;\n    while (m--)\n    {\n        for (c=getchar();c<'A' || c>'R';c=getchar());\n        if (c=='G')\n        {\n            for (c=getchar();c!='-';c=getchar());\n            int l=read(),tot=read(),r=l+tot;\n            Select(l-1,Null); Select(r,root);\n            printf(\"%d\\n\",sum[son[son[root][1]][0]]);\n        }else if (c=='I')\n        {\n            int x=read(),tot=read(); n+=tot;\n            for (int i=1;i<=tot;i++) A[i]=read();\n            Select(x,Null); Select(x+1,root);\n            build(1,tot,son[son[root][1]][0]); fa[son[son[root][1]][0]]=son[root][1];\n            splay(son[son[root][1]][0],Null);\n        }else if (c=='D')\n        {\n            int l=read(),tot=read(),r=l+tot; n-=tot;\n            Select(l-1,Null); Select(r,root);\n            Delete(son[root][1],0);\n        }else if (c=='R')\n        {\n            int l=read(),tot=read(),r=l+tot;\n            Select(l-1,Null); Select(r,root);\n            int t=son[son[root][1]][0];\n            flip[t]^=1;\n            ls[t]^=rs[t]^=ls[t]^=rs[t];\n            splay(t,Null);\n        }else\n        {\n            c=getchar(); c=getchar();\n            if (c=='K')\n            {\n                for (c=getchar();c!='-';c=getchar());\n                int l=read(),tot=read(),r=l+tot,C=read();\n                Select(l-1,Null); Select(r,root);\n                make_same(son[son[root][1]][0],C);\n                splay(son[son[root][1]][0],Null);\n            }else\n            {\n                for (c=getchar();c!='-';c=getchar());\n                for (c=getchar();c>='A' && c<='Z';c=getchar());\n                Select(0,Null); Select(n+1,root);//\n                printf(\"%d\\n\",ms[son[son[root][1]][0]]);\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1528511849,
        "uid": 98954,
        "name": "\u4e0d\u5b58\u5728\u4e4b\u4eba",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "## Splay \u6a21\u677f\u9898\n\n\u7b80\u800c\u8a00\u4e4b\u5c31\u662f\u4e2a\u533a\u95f4\u64cd\u4f5c\u7684\u5168\u5bb6\u6876\uff0c\u4ee3\u7801\u91cc\u7684\u6ce8\u91ca\u5f88\u8be6\u7ec6\u4e86\n\n```\n#include<bits/stdc++.h>\n#pragma GCC optimize(3)\nusing namespace std;\n#define go(i,a,b) for(int i=(a);i<=(b);++(i))\n#define com(i,a,b) for(int i=(a);i>=(b);--(i))\n#define mem(a,b) memset((a),(b),sizeof(a))\n#define inf 0x3f3f3f3f\n#define fin freopen(\"input.txt\",\"r\",stdin)\n#define fout freopen(\"output.txt\",\"w\",stdout)\n#define debug printf(\"\u884c\u53f7\uff1a%d \u51fd\u6570\u540d\uff1a%s \\n\", __LINE__, __FUNCTION__)\ntypedef long long ll;\nconst int maxn=800005;\nint sz,root,n,l,r,m;\nint ch[maxn][2],d[maxn],v[maxn],f[maxn],size[maxn],sum[maxn],tot,mx[maxn],lx[maxn],rx[maxn],id[maxn],flag[maxn];\nbool used[maxn];\nvoid read(int &x){\n    int f=1;char c=getchar();x=0;\n    while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}\n    while(isdigit(c)){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n    x*=f;\n}//\u8bfb\u5165\u4f18\u5316\nqueue<int>s;\n\nvoid update(int x){\n\t//v\u8868\u793a\u8282\u70b9\u672c\u8eab\u7684\u503c \n\tint l=ch[x][0],r=ch[x][1];\n\tsize[x]=size[l]+size[r]+1;\n\tsum[x]=sum[l]+sum[r]+v[x];\n\tmx[x]=max(mx[l],mx[r]);\n\tmx[x]=max(mx[x],lx[r]+v[x]+rx[l]);\n\t//lx,rx\u5206\u522b\u8868\u793a\u533a\u95f4\u5185\u6700\u5927\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\uff0c\u4ed6\u4eec\u53ef\u4ee5\u4e3a0\uff08\u4e0d\u9009\uff09\n\t//\u4ece\u800c\u5e2e\u52a9\u8ba1\u7b97\u51fa\u533a\u95f4\u6700\u503c\n\tlx[x]=max(lx[l],sum[l]+v[x]+lx[r]);\n\trx[x]=max(rx[r],sum[r]+v[x]+rx[l]);\n\t//\u66f4\u65b0\u6700\u5927\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\n}\ninline bool get(int x){\n\treturn ch[f[x]][1]==x;\n}\nvoid pushdown(int now){\n\tint l=ch[now][0],r=ch[now][1];\n\tif(flag[now]){//\u8d4b\u503c\u6807\u8bb0 \n\t\tflag[now]=0;\n\t\tif(l) v[l]=v[now],flag[l]=1,sum[l]=size[l]*v[now];\n\t\tif(r) v[r]=v[now],flag[r]=1,sum[r]=size[r]*v[now];\n\t\tif(v[now]>=0){\n\t\t\tif(l)lx[l]=rx[l]=mx[l]=sum[l];\n\t\t\tif(r)lx[r]=rx[r]=mx[r]=sum[r];\n\t\t}\n\t\telse{\n\t\t\tif(l)lx[l]=rx[l]=0,mx[l]=v[now];\n\t\t\tif(r)lx[r]=rx[r]=0,mx[r]=v[now];\n\t\t}\n\t}\n\tif(used[now]){\n\t\tswap(lx[l],rx[l]);swap(lx[r],rx[r]);\n\t\tswap(ch[l][0],ch[l][1]);swap(ch[r][0],ch[r][1]);\n\t\tused[now]^=1;\n\t\tused[l]^=1,used[r]^=1;\n\t\t//\u61d2\u6807\u8bb0\u4e0b\u4f20 \n\t}\n}\nvoid move(int now,int &k){\n\tint fa=f[now],cnt=get(now),faa=f[fa];//cnt=1->lson,or->rson\n\tpushdown(fa);\n\tif(fa==k) k=now;//\u6211\u4eec\u8981\u628anow\u8f6c\u4e0a\u53bb\n\telse if(faa) ch[faa][get(fa)]=now;//\u6211\uff0c\u4ee3\u66ff\u7236\u4eb2\uff0c\u8fc7\u7ee7\u7ed9\u7237\u7237\n\tch[fa][cnt]=ch[now][cnt^1];//\u6211\u628a\u513f\u5b50\u8fc7\u7ee7\u7ed9\u7236\u4eb2\uff0c\u4ee3\u66ff\u6211\n\tf[ch[now][cnt^1]]=fa;\n\tch[now][cnt^1]=fa;//\u8ba4\u7236\u4f5c\u5b50\uff0c\u4ee3\u66ff\u6211\u88ab\u8fc7\u7ee7\u8d70\u7684\u7684\u513f\u5b50\n\tf[fa]=now;\n\tf[now]=faa;\n\tupdate(fa);update(now);//\u6ce8\u610f\u987a\u5e8f\u54e6 \n}\nvoid splay(int x,int &k){\n\tint y,z;\n\tpushdown(x);\n\twhile(x!=k){//\u4e00\u76f4\u8f6c \n\t\ty=f[x],z=f[y];//\u7236\u4eb2\u4e0e\u7237\u7237\n\t\tif(y!=k){\n\t\t\tif((ch[y][0]==ch[z][0])^(ch[y][1]==ch[z][1]))move(y,k);\n\t\t\t//\u82e5x\u4e0ey\u65b9\u5411\u76f8\u540c,\u5426\u5219\u8f6c\u81ea\u5df1 \n\t\t\t else move(x,k);\n\t\t}\n\t\tmove(x,k);\n\t}\n}\nvoid build(int l,int r,int fa){//fa\u8868\u793a\u5e73\u8861\u6811\u4e0a\u7684\u7236\u8282\u70b9 \n\tif(l>r) return;\n\tint mid=(l+r)>>1,now=id[mid],last=id[fa];//id\u8868\u793a\u4f4d\u7f6e\u4e3ai\u7684\u8282\u70b9\u7f16\u53f7\uff08\u4e0d\u662f\u539f\u56fe\u7684\u4f4d\u7f6e\uff09 \n\tif(l==r){\n\t\tsum[now]=d[l];size[now]=1;//\u66f4\u65b0sum\u548csize\n\t\tif(d[l]>=0) lx[now]=rx[now]=mx[now]=d[l];//\u7ef4\u62a4\u6700\u5927\u503c\u548c\u6700\u5927\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\uff0c\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\u53ef\u4ee5\u4e3a0 \n\t\telse lx[now]=rx[now]=0,mx[now]=d[l];\n\t}\n\telse build(l,mid-1,mid),build(mid+1,r,mid);//\u5efa\u51fa\u5de6\u53f3\u513f\u5b50 \n\tv[now]=d[mid];\n\tf[now]=last;update(now);\n\tch[last][mid>=fa]=now;//\u7ef4\u62a4\u7236\u5b50\u5173\u7cfb ,\u4e0b\u6807\u6bd4\u7236\u4eb2\u7684\u4e0b\u6807\u5c0f\u7684\u662f\u5de6\u513f\u5b50 \n}\nint find(int k,int x){//\u67e5\u8be2\u533a\u95f4\u5185\u4e0b\u6807\u4e3ax\u7684\u6839 \n\tpushdown(k);//\u61d2\u6807\u8bb0\u4e0b\u4f20\n\tif(x<=size[ch[k][0]]) return find(ch[k][0],x);\n\tif(x==size[ch[k][0]]+1) return k;\n\treturn find(ch[k][1],x-size[ch[k][0]]-1); \n}\nvoid ins(int k,int b){\n\tgo(i,1,b) read(d[i]);//d[i]\u4e0d\u8fc7\u662f\u4e2a\u4e34\u65f6\u6570\u7ec4\n\tgo(i,1,b)\n\t\tif(!s.empty())id[i]=s.front(),s.pop();\n\t\telse id[i]=++tot;//\u7528\u4e86\u56de\u6536\u7a7a\u95f4\u7684\u5199\u6cd5\n\tbuild(1,b,0);//\u5efa\u7acb\u4e00\u68f5\u65b0\u6811 \n\tint now=id[1+b>>1];//\u53d6\u4e2d\u70b9 \n\tint x=find(root,k+1),y=find(root,k+2);//\u51c6\u5907\u63d2\u5230x\uff0cy\u4e2d\u95f4\n\tsplay(x,root);splay(y,ch[root][1]);//y\u7684\u5de6\u513f\u5b50\u5fc5\u5b9a\u4e3a\u7a7a \n\tch[y][0]=now;f[now]=y;\n\tupdate(y),update(x);//\u6ce8\u610f\u987a\u5e8f \n}\nvoid change(int k,int b,int num){\n\tint x=find(root,k),y=find(root,b+1);\n\tsplay(x,root),splay(y,ch[root][1]);//\u8001\u5957\u8def\u4e86\n\tint g=ch[y][0];//\uff08x+1,y-1)\n\tflag[g]=1;//\u533a\u95f4\u8d4b\u503c\u61d2\u6807\u8bb0 \n\tsum[g]=num*size[g];v[g]=num;\n\tif(num>=0)lx[g]=rx[g]=mx[g]=sum[g];//\u524d\u63d0\u5f53\u7136\u662fnum>=0\u5566\uff0c\u4e0d\u7136\u4e0d\u5982\u4e0d\u9009\n\telse lx[g]=rx[g]=0,mx[g]=num;\n\tupdate(y),update(x); \n}\nvoid rec(int x){\n\tif(!x)return;\n\tint l=ch[x][0],r=ch[x][1];\n\trec(l);rec(r);s.push(x);//\u6254\u8fdb\u56de\u6536\u7ad9 \n\tf[x]=ch[x][0]=ch[x][1]=0;//\u5220\u53bb\u4e0e\u5979\u76f8\u8fde\u7684\u6240\u6709\u8fb9 \n\tflag[x]=used[x]=0;//\u9632\u6b62\u88ab\u8fd8\u539f\u540e\u51fa\u95ee\u9898 \n}\nvoid del(int l,int r){\n\tint x=find(root,l),y=find(root,r+1);\n\tsplay(x,root),splay(y,ch[root][1]);\n\trec(ch[y][0]);//\u5220\u53bbl+1,r \n\tch[y][0]=0;\n\tupdate(y),update(x);//\u6ce8\u610f\u987a\u5e8f \n}\nint main(){\n\tread(n),read(m);\n\td[1]=d[n+2]=mx[0]=-9999999;\n\t//\u5f00\u5934\u7ed3\u5c3e\u6709\u4e24\u4e2a\u8f85\u52a9\u8282\u70b9 \n\tgo(i,1,n) read(d[i+1]);//\u521d\u59cb\u6570\u5217 \n\tgo(i,1,n+2) id[i]=i;//\u4fdd\u5b58\u4f4d\u7f6e\n\tbuild(1,n+2,0);\n\tint k,x,a,b,c;tot=n+2;\n\troot=n+3>>1;//\u53d6\u4e00\u4e2a\u4e2d\u95f4\u6570\u4e3a\u6839\n\tchar p[13];\n\twhile(m--){//\u7ffb\u8f6c \n\t\tscanf(\"%s\",p+1);\n\t\tif(p[3]=='V'){\n\t\t\tread(a),read(b);b=b+a;\n\t\t\tint x=find(root,a),y=find(root,b+1);\n\t\t\tsplay(x,root);//\u6574\u68f5\u6811\u88ab\u5212\u5206\u4e3a1\u5230a-1,a,a+1\u5230n+2\n\t\t\tsplay(y,ch[root][1]);//\u53f3\u5b50\u6811\u88ab\u5212\u5206\u4e3aa+1\u5230b,b+1,b+2\u5230n+2\n\t\t\t//a\uff0cb\u5b9e\u9645\u4ee3\u8868a-1\u548cb-1 \n\t\t\tc=ch[y][0];//\u5f85\u4fee\u6539\u533a\u95f4 \n\t\t\tused[c]^=1;swap(lx[c],rx[c]);swap(ch[c][0],ch[c][1]);\n\t\t\tupdate(y),update(x);\n\t\t}\n\t\tif(p[3]=='S')\n\t\t\tread(a),read(b),ins(a,b);\n\t\tif(p[3]=='L'){\n\t\t\tread(a),read(b);b=a+b;\n\t\t\tdel(a,b);\n\t\t}\n\t\tif(p[3]=='K'){//\u533a\u95f4\u4fee\u6539 \n\t\t\tread(a),read(b),read(c);b=a+b;\n\t\t\tchange(a,b,c);\n\t\t}\n\t\tif(p[3]=='T'){\n\t\t\tread(a),read(b);b=a+b;\n\t\t\tsplay(find(root,a),root);\n\t\t\tsplay(find(root,b+1),ch[root][1]);//\u8001\u5957\u8def \n\t\t\tprintf(\"%d\\n\",sum[ch[ch[root][1]][0]]);\n\t\t}\n\t\tif(p[3]=='X'){\n\t\t\tprintf(\"%d\\n\",mx[root]);\n\t\t}\n\t} \n\treturn 0;\n}\n```\n",
        "postTime": 1564717297,
        "uid": 109434,
        "name": "\u98ce\u968f\u9010\u5f71",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "# \u5439\u4e00\u6ce2fhq\n[\u7ef4\u62a4\u6570\u5217](https://www.luogu.org/problemnew/show/P2042)\n\n\u8c8c\u4f3c\u6ca1\u4ec0\u4e48\u9898\u89e3\u662f\u7528fhq\u5199\u7684\uff0c\u5927\u591a\u662fsplay\uff0c\u8ba9\u849f\u84bb\u7684\u6211\u53d1\u4e00\u6ce2fhq\uff08\u8bdd\u8bf4\u660e\u660efhq\u8fd9\u4e48\u5f3a\u5927\uff0c\u4e3a\u4ec0\u4e48\u6ca1\u4ec0\u4e48\u4eba\u5199\u5462\uff1f\uff09\n\n\u5efa\u6811\u9700\u8981\u6a21\u4eff\u6590\u6ce2\u90a3\u5951\u5806\u6765\u505a\u5230\u7ebf\u6027\u5efa\u6811\uff0c\u4e0d\u7136\u4f1aT\u6389\u4e24\u9053\u4e09\u4e2a\u70b9\u3002\u55ef\uff0c\u8c8c\u4f3cfhq treap\u8fd9\u4e00\u70b9\u6709\u70b9\u9ebb\u70e6\uff0c\u9700\u8981\u7528\u5355\u8c03\u6808\u6765\u52a0\u5feb\u5efa\u6811\uff0c\u770b\u770b\u522b\u4ebasplay\u53ea\u9700\u8981\u9012\u5f52\u5efa\u6811\u5c31\u597d\u4e86\u3002\n\n\u7528\u4e00\u4e2a\u5355\u8c03\u7ef4\u62a4\u6700\u53f3\u94fe\uff0c\u4fdd\u8bc1rnd\u503c\u5355\u8c03\u9012\u589e\uff0c\u5982\u679c\u4e0d\u80fd\u7ee7\u7eed\u63d2\u5165\u5219\u5f39\u51fa\uff0c\u6ce8\u610f\u4e00\u8fb9\u5f39\u51fa\u4e00\u8fb9\u66f4\u65b0\uff0c\u518d\u5c06\u5f39\u51fa\u7684\u94fe\u63a5\u5728\u5373\u5c06\u63d2\u5165\u7684\u8282\u70b9\u7684\u5de6\u5b50\u8282\u70b9\u4e0a\u3002\n\n\u6700\u540e\u5904\u7406\u4e00\u4e0b\u6808\u5185\u5269\u4e0b\u5143\u7d20\uff0c\u6b64\u65f6\u6808\u5e95\u5143\u7d20\u5fc5\u4e3a\u8fd9\u9897\u65b0\u6811\u7684\u6839\u3002\n\n```cpp\n\nint build(int a[],int l,int r){\n    int top=0,p=0;\n    for(int i=l;i<=r;i++)\n        a[i]=New(a[i]);\n    for(int i=l;i<=r;i++){\n    \tp=0;\n    \twhile(top and c[s[top]].rnd>c[a[i]].rnd){\n    \t\tupdate(s[top]);\n    \t\tp=s[top];\n    \t\ttop--;\n        }\n        s[++top]=a[i];\n        c[a[i]].ls=p;\n        if(top>1)\n            c[s[top-1]].rs=s[top];\n    }\n    while(top)\n        update(s[top--]);\n    return s[1];\n}\n```\n\nupdate\u7684\u65f6\u5019\u8981\u6ce8\u610f\u4e00\u4e0b\u5de6\u53f3\u5b50\u8282\u70b9\u7684\u5b58\u5728\u6027\n\n\u6bcf\u6b21\u5bf9\u533a\u95f4\u64cd\u4f5c\u7684\u65f6\u5019\u5c31\u8981\u5c06\u8be5\u8282\u70b9\u9664\u4e86\u5de6\u53f3\u5b50\u8282\u70b9\u6307\u9488\u4e4b\u5916\u7684\u6240\u6709\u4fe1\u606f\u90fd\u7ed9\u66f4\u65b0\u597d\uff0c\u56e0\u4e3a\u5728\u7236\u8282\u70b9\u7684\u66f4\u65b0\u4e2d\u4f1a\u7528\u5230\u8fd9\u4e9b\u4fe1\u606f\uff0c\u6ca1\u6709\u66f4\u65b0\u7684\u8bdd\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u7384\u5b66\u9519\u8bef\n\n\u5176\u4ed6\u90fd\u662f\u6b63\u5e38\u64cd\u4f5c\u4e86\n\n### Talk is cheap,show you the code\n\n```cpp\n#include<bits/stdc++.h>\n#define Max(x,y,z) max(max(x,y),z)\n#define Merge(x,y,z) merge(merge(x,y),z)\nusing namespace std;\nint read(){\n    int c,nx,sign=1;\n    do{\n        c=getchar()-'0';\n        if(c=='-'-'0')\n            sign=-1;\n    }while(c<0 or c>9);\n    while(0<=(nx=getchar()-'0') and nx <= 9)\n        c=c*10+nx;\n    return sign*c;\n}\nconst int N=5e5+10;\nstruct fhq{\n    int dat,lm,rm,sm,val;\n    int ls,rs;\n    int size;\n    int rev,tag;\n    int rnd;\n}c[N];\nint root;\nqueue<int>rub;\ninline int New(int n){\n    static int now=0;\n    int s;\n    if(rub.size()){\n        s=rub.front();\n        rub.pop();\n    }else\n        s=++now;\n    c[s].rnd=((rand()<<15)|rand());\n    c[s].val=c[s].sm=c[s].dat=c[s].lm=c[s].rm=n;\n    c[s].ls=c[s].rs=0;\n    c[s].size=1;\n    c[s].rev=0;\n    c[s].tag=INT_MAX;\n    return s;\n}\nvoid Delete(int s){\n    if(c[s].ls)\n        Delete(c[s].ls);\n    if(c[s].rs)\n        Delete(c[s].rs);\n    rub.push(s);\n}\ninline void fs(int s,int rev,int tag){\n    int size=c[s].size;\n    if(tag!=INT_MAX){\n        c[s].val=tag;\n        c[s].dat=tag*size;\n        c[s].lm=c[s].rm=c[s].sm= tag>0 ? tag*size : tag;\n        c[s].tag=tag;\n        rev=0;\n    }\n    if(rev){\n        c[s].rev^=rev;\n        swap(c[s].lm,c[s].rm);\n    }\n}\ninline void down(int s){\n    int &rev=c[s].rev,&tag=c[s].tag;\n    if(!rev and tag==INT_MAX or !s)\n        return ;\n    if(c[s].ls)\n        fs(c[s].ls,rev,tag);\n    if(c[s].rs)\n        fs(c[s].rs,rev,tag);\n    if(rev)\n        swap(c[s].ls,c[s].rs);\n    rev=0;\n    tag=INT_MAX;\n}\ninline void update(int s){\n    if(!s)\n        return ;\n    c[s].dat=c[s].sm=c[s].lm=c[s].rm=c[s].val;\n    c[s].size=1;\n    if(c[s].ls){\n        int ls=c[s].ls;\n        c[s].sm=Max(c[ls].sm,c[s].sm,c[ls].rm+c[s].lm);\n        c[s].lm=max(c[ls].lm,c[ls].dat+c[s].lm);\n        c[s].rm=max(c[s].rm,c[s].dat+c[ls].rm);\n        c[s].dat+=c[ls].dat;\n        c[s].size+=c[ls].size;\n    }\n    if(c[s].rs){\n        int rs=c[s].rs;\n        c[s].sm=Max(c[s].sm , c[rs].sm , c[s].rm + c[rs].lm);\n        c[s].lm=max(c[s].lm , c[s].dat + c[rs].lm);\n        c[s].rm=max(c[rs].rm , c[rs].dat + c[s].rm);\n        c[s].dat+=c[rs].dat;\n        c[s].size+=c[rs].size;\n    }\n}\nint merge(int x,int y){\n    down(x),down(y);\n    if(!x or !y)\n        return x|y;\n    if(c[x].rnd<c[y].rnd){\n        c[x].rs=merge(c[x].rs,y);\n        update(x);\n        return x;\n    }else{\n        c[y].ls=merge(x,c[y].ls);\n        update(y);\n        return y;\n    }\n}\nvoid split(int s,int n,int &x,int &y){\n    down(s);\n    int ls=c[s].ls;\n    if(!s)\n        x=y=0;\n    else if(c[ls].size>=n){\n        y=s;\n        split(c[s].ls,n,x,c[y].ls);\n        update(y);\n    }else{\n        x=s;\n        split(c[s].rs,n-c[ls].size-1,c[x].rs,y);\n        update(x);\n    }\n}\nint s[N];\nint build(int a[],int l,int r){\n    int top=0,p=0;\n    for(int i=l;i<=r;i++)\n        a[i]=New(a[i]);\n    for(int i=l;i<=r;i++){\n    \tp=0;\n    \twhile(top and c[s[top]].rnd>c[a[i]].rnd){\n    \t\tupdate(s[top]);\n    \t\tp=s[top];\n    \t\ttop--;\n        }\n        s[++top]=a[i];\n        c[a[i]].ls=p;\n        if(top>1)\n            c[s[top-1]].rs=s[top];\n    }\n    while(top)\n        update(s[top--]);\n    return s[1];\n}\ninline void insert(int a[],int len,int pos){\n    int y=build(a,1,len);\n    int x,z;\n    split(root,pos,x,z);\n    root=Merge(x,y,z);\n}\ninline void del(int pos,int len){\n    int x,y,z;\n    split(root,pos-1,x,y);\n    split(y,len,y,z);\n    Delete(y);\n    root=merge(x,z);\n}\ninline void change(int f,int pos,int len){\n    int x,y,z;\n    split(root,pos-1,x,y);\n    split(y,len,y,z);\n    fs(y,0,f);\n    root=Merge(x,y,z);\n}\ninline void reverse(int pos,int len){\n    int x,y,z;\n    split(root,pos-1,x,y);\n    split(y,len,y,z);\n    fs(y,1,INT_MAX);\n    root=Merge(x,y,z);\n}\ninline int maxsum(){\n    return c[root].sm;\n}\ninline int getsum(int pos,int len){\n    int x,y,z;\n    split(root,pos-1,x,y);\n    split(y,len,y,z);\n    int ans=c[y].dat;\n    root=Merge(x,y,z);\n    return ans;\n}\nint a[N];\nint main(){\n    int n=read(),m=read();\n    for(int i=1;i<=n;i++)\n        a[i]=read();\n    root=build(a,1,n);\n    while(m--){\n        char ord[10];\n        scanf(\"%s\",ord);\n        int pos,len,x;\n        switch(ord[0]){\n            case 'I':\n                pos=read();\n                len=read();\n                for(int i=1;i<=len;i++)\n                    a[i]=read();\n                insert(a,len,pos);\n                break;\n            case 'D':\n                pos=read();\n                len=read();\n                del(pos,len);\n                break;\n            case 'M':\n                if(ord[2]=='X'){\n                    printf(\"%d\\n\",c[root].sm);\n                    break;\n                }\n                pos=read();\n                len=read();\n                x=read();\n                change(x,pos,len);\n                break;\n            case 'R':\n                pos=read();\n                len=read();\n                reverse(pos,len);\n                break;\n            case 'G':\n                pos=read();\n                len=read();\n                printf(\"%d\\n\",getsum(pos,len));\n                break;\n        }\n    }\n}\n```\n",
        "postTime": 1558433562,
        "uid": 144732,
        "name": "Alear",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u6ce8\u610f\u5f00\u5185\u5b58\u6c60\u5c31\u53ef\u4ee5\u4e86\uff0c\u6700\u5927\u5b50\u5e8f\u548c\u4e3amax{\u5de6\u5b50\u6811\u6700\u5927\u5b50\u5e8f\u548c\uff0c\u53f3\u5b50\u6811\u6700\u5927\u5b50\u5e8f\u548c\uff0cmax{\u5de6\u5b50\u6811\u53f3\u8fb9\u6700\u5927\u5b50\u5e8f\u548c,0}+\u6839\u8282\u70b9\u5143\u7d20+max{\u53f3\u5b50\u6811\u5de6\u8fb9\u6700\u5927\u5b50\u5e8f\u548c,0}}\u3002\n\n\n...cpp\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int Size = 500000+100;\nconst int inf = 0x3f3f3f3f;\nint ch[Size][2],pre[Size],size[Size],mx[Size],lx[Size],rx[Size];\nint sum[Size],rev[Size],same[Size],data[Size];\nint root;\nint Stack[Size],top;\nint a[Size];\nchar type[20];\nvoid Read(int &);\nvoid NewNode(int &,int,int);\nvoid Build(int &,int,int,int);\nvoid Splay(int,int);\nvoid Rotate(int,int);\nvoid Updata(int);\nint Order(int);\nvoid PushDown(int);\nvoid PushSame(int,int);\nvoid PushRev(int);\nvoid Insert(int,int);\nvoid Delete(int,int);\nvoid Rec(int);\nvoid MakeSame(int,int,int);\nvoid Reverse(int,int);\nint GetSum(int,int);\nint MaxSum();\nvoid Display(int);\nvoid Debug();\nint main(){\n    for(int i=Size-1;--i;) Stack[++top] = i;\n    NewNode(root,0,-inf);NewNode(ch[root][1],root,-inf);Updata(root);\n    int t,n,pos,tot,c;\n    Read(n);Read(t);\n    for(int i=0;i<n;++i) Read(a[i]);\n    Build(ch[ch[root][1]][0],0,n-1,ch[root][1]);\n    Updata(ch[root][1]);Updata(root);\n    while( t-- ){\n        scanf(\"%s\",type);\n        if(type[2]!='X') Read(pos),Read(tot);\n        if(type[2]=='S') Insert(pos,tot);\n        else if(type[2]=='L') Delete(pos,tot);\n        else if(type[2]=='K') Read(c),MakeSame(pos,tot,c);\n        else if(type[2]=='V') Reverse(pos,tot);\n        else if(type[2]=='T') printf(\"%d\\n\",GetSum(pos,tot));\n        else printf(\"%d\\n\",MaxSum());\n    }\n    return 0;\n}\nvoid Read(int &in){\n    char ch;int f=1;\n    for(ch=getchar();ch>'9'||ch<'0';ch=getchar()) if(ch=='-') f=-1;\n    for(in=0;ch>='0'&&ch<='9';ch=getchar()) in=in*10+ch-'0';\n    in *= f;\n}\nvoid NewNode(int &r,int father,int key){\n    pre[r=Stack[top--]] = father;\n    sum[r] = data[r] = lx[r] = mx[r] = rx[r] = key;\n    size[r] = 1;\n    ch[r][0] = ch[r][1] = same[r] = rev[r] = 0;\n}\nvoid Build(int &node,int l,int r,int father){\n    if(l > r) return ;\n    int mid = (l+r)>>1;\n    NewNode(node,father,a[mid]);\n    Build(ch[node][0],l,mid-1,node);\n    Build(ch[node][1],mid+1,r,node);\n    Updata(node);\n}\nvoid Splay(int r,int goal){\n    int x,y,kind;\n    while(pre[r] != goal)\n        if(pre[pre[r]]==goal) Rotate(r,ch[pre[r]][0]==r);\n        else{\n            x=pre[r];y=pre[x];kind=ch[y][1]==x;\n            if(ch[x][kind]==r) Rotate(x,!kind),Rotate(r,!kind);\n            else Rotate(r,kind),Rotate(r,!kind);\n        }\n    if(!goal) root=r;\n}\nvoid Rotate(int r,int way){\n    int t = pre[r];\n    pre[ch[t][!way]=ch[r][way]] = t;\n    if(pre[t]) ch[pre[t]][ch[pre[t]][1]==t] = r;\n    pre[r] = pre[t];\n    pre[ch[r][way]=t] = r;\n    Updata(t);Updata(r);Updata(pre[r]);\n}\nvoid Updata(int r){\n    if(!r) return ;\n    size[r] = size[ch[r][0]]+size[ch[r][1]]+1;\n    sum[r] = sum[ch[r][0]]+sum[ch[r][1]]+data[r];\n    lx[r] = sum[ch[r][0]]+data[r]+max(0,lx[ch[r][1]]);\n    if(ch[r][0]) lx[r] = max(lx[r],lx[ch[r][0]]);\n    rx[r] = sum[ch[r][1]]+data[r]+max(0,rx[ch[r][0]]);\n    if(ch[r][1]) rx[r] = max(rx[r],rx[ch[r][1]]);\n    mx[r] = max(0,rx[ch[r][0]])+data[r]+max(0,lx[ch[r][1]]);\n    if(ch[r][0]) mx[r] = max(mx[r],mx[ch[r][0]]);\n    if(ch[r][1]) mx[r] = max(mx[r],mx[ch[r][1]]);\n}\nint Order(int k){\n    int now = root;\n    while(true){\n        PushDown(now);\n        if(size[ch[now][0]]>=k) now=ch[now][0];\n        else if(size[ch[now][0]]+1==k) return now;\n        else k-=(size[ch[now][0]]+1),now=ch[now][1];\n    }\n}\nvoid PushDown(int r){\n    if(same[r]){\n        PushSame(ch[r][0],data[r]);\n        PushSame(ch[r][1],data[r]);\n        same[r] = 0;\n    }\n    if(rev[r]){\n        PushRev(ch[r][0]);\n        PushRev(ch[r][1]);\n        rev[r] = 0;\n    }\n}\nvoid PushSame(int r,int c){\n    if(!r) return ;\n    data[r] = c;\n    sum[r] = c*size[r];\n    lx[r] = mx[r] = rx[r] = max(sum[r],c);\n    same[r] = 1;\n}\nvoid PushRev(int r){\n    if(!r) return ;\n    swap(lx[r],rx[r]);\n    swap(ch[r][0],ch[r][1]);\n    rev[r] ^= 1;\n}\nvoid Insert(int pos,int tot){\n    for(int i=0;i<tot;++i) Read(a[i]);\n    Splay(Order(pos+1),0);\n    Splay(Order(pos+2),root);\n    Build(ch[ch[root][1]][0],0,tot-1,ch[root][1]);\n    Updata(ch[root][1]);Updata(root);\n}\nvoid Delete(int pos,int tot){\n    Splay(Order(pos),0);\n    Splay(Order(pos+tot+1),root);\n    Rec(ch[ch[root][1]][0]);\n    ch[ch[root][1]][0] = 0;\n    Updata(ch[root][1]);Updata(root);\n}\nvoid Rec(int r){\n    if(!r) return ;\n    Stack[++top] = r;\n    Rec(ch[r][0]);Rec(ch[r][1]);\n}\nvoid MakeSame(int pos,int tot,int c){\n    Splay(Order(pos),0);\n    Splay(Order(pos+tot+1),root);\n    PushSame(ch[ch[root][1]][0],c);\n    Updata(ch[root][1]);Updata(root);\n}\nvoid Reverse(int pos,int tot){\n    Splay(Order(pos),0);\n    Splay(Order(pos+tot+1),root);\n    PushRev(ch[ch[root][1]][0]);\n    Updata(ch[root][1]);Updata(root);\n}\nint GetSum(int pos,int tot){\n    Splay(Order(pos),0);\n    Splay(Order(pos+tot+1),root);\n    return sum[ch[ch[root][1]][0]];\n}\nint MaxSum(){\n    return mx[root];\n}\nvoid Display(int r){\n    if(!r) return ;\n    Display(ch[r][0]);\n    printf(\"%d \",data[r]);\n    Display(ch[r][1]);\n}\nvoid Debug(){\n    Display(root);\n    putchar(10);\n}\n...\n```",
        "postTime": 1481290957,
        "uid": 21673,
        "name": "Sor4",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u505a\u6cd5\u7684\u8bdd\uff0c\u522b\u7684\u9898\u89e3\u8bf4\u7684\u5f88\u6e05\u695a\u4e86\u3002\u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e0b\u6613\u9519\u70b9\u3002\n\n1. upt**\u4e0d\u80fd\u76f4\u63a5\u7528\u6765\u8868\u793a\u8981\u628a\u8fd9\u4e2a\u533a\u95f4\u6e05\u6210\u4ec0\u4e48**\uff0c\u800c\u662f\u8981\u8868\u793a\u8fd9\u4e2a\u533a\u95f4\u662f\u4e0d\u662f\u90fd\u88ab\u5237\u6210\u4e00\u4e2a\u503c\u4e86\uff08\u8fd9\u4e2a\u7834\u9898\u53ef\u4ee5\u628a\u4e00\u6bb5\u533a\u95f4\u5237\u62100\uff09\n2. \u533a\u95f4\u7ffb\u8f6c\u7684\u65f6\u5019\u4e00\u5b9a\u8981\u8bb0\u5f97\u628a\u5f53\u524d\u533a\u95f4\u5de6\u8fb9\u6700\u5927\u8fde\u7eed\u548c\u548c\u53f3\u8fb9\u6700\u5927\u8fde\u7eed\u548c\u4ea4\u6362\u4e86\uff08\u5426\u5219\u5c31\u662f\u53cd\u7684\uff09\n\n\u55ef\u5c31\u8fd9\u6837\u5427\uff1f\u8fb9\u754c\u5904\u7406\u597d\u5c31\u662f\u4e86\u3002",
        "postTime": 1565779585,
        "uid": 109396,
        "name": "Uniecho1",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "# \u6307\u9488\u7248\u975e\u65cbTreap\n\n\u672c\u6765\u5199\u7684\u597d\u597d\u7684\uff0c\u7136\u540e\u8c03\u6307\u9488\u8c03\u7684......\u5927\u6982\u662f\u6211\u592a\u5f31\u4e86\n\n\u7136\u540e\u5c31\u62ff\u4e86@\u66e6\u6708__OFN \u5927\u4f6c\u7684\u4ee3\u7801\u6765\u5bf9\u7740\u8c03\n\n\u7136\u540e\u4ee3\u7801\u5c31\u957f\u5f97\u6781\u5176\u76f8\u4f3c......\n\n\u4f3c\u4e4e\u697c\u4e0b\u9898\u89e3\u8fd8\u6709\u4e00\u7bc7\u5dee\u4e0d\u591a\u7684\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u5728\u610f\u8fd9\u4e9b\u7ec6\u8282\n\n\u6307\u9488\u7684\u597d\u5904:\n\n1. \u5199\u591a\u4e86\u5176\u5b9e\u5c31\u597d\u8c03\u4e86\n    \n1. ~~\u953b\u70bc\u4ee3\u7801\u80fd\u529b~~\n\n1. \u65b9\u4fbf\u9012\u5f52\n\n1. \u53ef\u4ee5\u56de\u6536\u5185\u5b58\n\n1. \u6709\u4e9b\u64cd\u4f5c\u65b9\u4fbf\n\n\u6307\u9488\u7684\u574f\u5904\uff1a\n\n1. \u540c\u4e00\u4e2a\u7a0b\u5e8f\u5728\u4e0d\u540c\u673a\u5b50\u4e0b\u7684\u8868\u73b0\u4e0d\u540c\uff08\u4f8b\u598232\u4f4d\u548c64\u4f4d\uff09\n\n1. \u849f\u84bb\u6740\u624b\uff0c\u4e0d\u65b9\u4fbf\u8c03\u8bd5\n\n1. \u5206\u914d\u5185\u5b58\u7565\u6162\uff08\u5f53\u7136\u53ef\u4ee5\u5f00\u5185\u5b58\u6c60\uff09\n\n1. \u83ab\u540dRE\n\n1. \u6709\u4e9b\u64cd\u4f5c\u4e0d\u65b9\u4fbf\n\n\u7136\u540e\u63a5\u4e0b\u6765\u662f\u4ee3\u7801\u90e8\u5206\uff0c\u6700\u540e\u4e00\u6bb5\u7684system\u662f\u7528\u6765\u68c0\u6d4b\u5185\u5b58\u5927\u5c0f\uff1a\n\n```\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\nusing namespace std;\n#define MAXN 500050\n#define INF 0x3f3f3f3f\n#define Finline __inline__ __attribute__ ((always_inline))\n\nconst int MODS = 5371321, PRI = 832211;\n\nFinline char get_char(){\n    static char buf[10000001], *p1 = buf, *p2 = buf;\n    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 10000000, stdin), p1 == p2) ? EOF : *p1 ++;\n}\ninline int read(){\n    int num = 0;\n    char c, sf = 1;\n    while (!isdigit(c = get_char()) && c != '-');\n    if(c == '-') c = get_char(), sf = -1;\n    while (num = num * 10 + c - 48, isdigit(c = get_char()));\n    return num * sf;\n}\ninline void swap(int &x, int &y){\n    int t = x;\n    x = y;\n    y = t;\n}\nFinline int max(int a, int b){\n    int c = (a - b) >> 31;\n    return (a & ~ c) | (b & c);\n}\nFinline int min(int a, int b){\n    int c = (a - b) >> 31;\n    return (a & c) | (b & ~ c);\n}\nFinline void upmin(int &a, const int &b){\n    if(a > b) a = b;\n}\nFinline void upmax(int &a, const int &b){\n    if(a < b) a = b;\n}\n\nstruct Node{\n    int size, val, wv, cov;\n    int sum, lm, rm, sm;\n    bool rev;\n    Node *lc, *rc;\n};\n\nint top, cnt;\nNode* root, *stack[MAXN];\n\ninline void swap(Node* &x, Node* &y){\n    Node* t = x;\n    x = y;\n    y = t;\n}\n\ninline Node* NewNode(int val){\n    Node *ret;\n    if((ret = (Node*)malloc(sizeof(Node))) == NULL) return NULL;\n    if(cnt) cnt--;\n    ret -> rev = false;\n    ret -> size = 1;\n    ret -> val = ret -> sum = ret -> sm = val;\n    ret -> wv = rand();\n    ret -> cov = INF;\n    ret -> lm = ret -> rm = max(val, 0);\n    ret -> lc = ret -> rc = NULL;\n    return ret;\n}\n\nint n, m;\n\ninline int rand(){\n    static int sed = 15;\n    return sed = 1ll * sed * PRI % MODS;\n}\n\ninline void Del(Node *node){\n    if(node == NULL) return ;\n    Del(node -> lc), Del(node -> rc);\n    free(node);\n    cnt++;\n}\n\ninline void Cover(Node *node, int val){\n    node -> val = val;\n    node -> sum = (node -> size) * val;\n    node -> lm = node -> rm = max(node -> sum, 0);\n    node -> sm = max(node -> sum, node -> val);\n    node -> cov = val;\n}\n\ninline void Reverse(Node* &node){\n    swap(node -> lc, node -> rc);\n    swap(node -> lm, node -> rm);\n    node -> rev ^= 1;  \n}\n\ninline void Push_Up(Node *node){\n    bool l = node -> lc == NULL, r = node -> rc == NULL;\n    node -> size = (l ? 0 : node -> lc -> size) + (r ? 0 : node -> rc -> size) + 1;\n    node -> sum = (l ? 0 : node -> lc -> sum) + (r ? 0 : node -> rc -> sum) + node -> val;\n    node -> sm = max(max((l ? -INF : node -> lc -> sm), (r ? -INF : node -> rc -> sm)), (l ? 0 : node -> lc -> rm) + (r ? 0 : node -> rc -> lm) + node -> val);\n    node -> lm = max((l ? 0 : node -> lc -> lm), (l ? 0 : node -> lc -> sum) + (r ? 0 : node -> rc -> lm) + node -> val);\n    node -> rm = max((r ? 0 : node -> rc -> rm), (r ? 0 : node -> rc -> sum) + (l ? 0 : node -> lc -> rm) + node -> val);\n}\n\ninline void Push_Down(Node *node){\n    if(node -> rev){\n        node -> rev = false;\n        if(node -> lc != NULL) Reverse(node -> lc);\n        if(node -> rc != NULL) Reverse(node -> rc);\n    }\n    if(node -> cov != INF){\n        if(node -> lc != NULL) Cover(node -> lc, node -> cov);\n        if(node -> rc != NULL) Cover(node -> rc, node -> cov);\n        node -> cov = INF;\n    }\n}\n\ninline Node* Merge(Node* x, Node* y){\n    if(x != NULL) Push_Down(x);\n    if(y != NULL) Push_Down(y);\n    if(x == NULL || y == NULL) return x == NULL ? y : x;\n    if(x -> wv < y -> wv){\n        x -> rc = Merge(x -> rc, y);\n        Push_Up(x);\n        return x;\n    } else {\n        y -> lc = Merge(x, y -> lc);\n        // if(y == y -> lc) printf(\"Dead in line %d of %d\\n\", __LINE__, y -> wv);\n        Push_Up(y);\n        return y;\n    }\n}\n\ninline void Split(Node* node, int k, Node* &x, Node* &y){\n    if(node == NULL){\n        x = y = NULL;\n        return;\n    }\n    Push_Down(node);\n    if((node -> lc == NULL ? 0 : node -> lc -> size) >= k){\n        y = node;\n        Split(node -> lc, k, x, node -> lc);\n    } else {\n        x = node;\n        Split(node -> rc, k - 1 - (node -> lc == NULL ? 0 : node -> lc -> size), node -> rc, y);\n    }\n    Push_Up(node);\n}\n\nint main(){\n    // freopen(\"in.in\", \"r\", stdin);\n    // freopen(\"out.out\", \"w\", stdout);\n    n = read(), m = read();\n    for(int i = 1; i <= n; i++){\n        int val = read();\n        Node *p = NewNode(val), *tmp = NULL;\n        if(top) stack[top] -> rc = p;\n        p -> lc = tmp, stack[++top] = p;\n    }\n    while(top) Push_Up(stack[top--]);\n    root = stack[1];\n    while(m--){\n        char cons;\n        while(!isalpha(cons = get_char()));\n        if(cons == 'I'){\n            int st = read(), tot = read();\n            for(int i = 1; i <= tot; i++){\n                int val = read();\n                Node *p = NewNode(val), *tmp = NULL;\n                while(cnt && stack[top] != NULL && stack[top] -> wv > p -> wv){\n                    Push_Up(stack[top]);\n                    tmp = stack[top];\n                    stack[top--] = NULL;\n                }\n                if(top) stack[top] -> rc = p;\n                p -> lc = tmp, stack[++top] = p;\n            }\n            Node *ls = NULL, *rs = NULL, *tmp;\n            while(top) Push_Up(stack[top--]);\n            tmp = stack[1];\n            Split(root, st, ls, rs);\n            root = Merge(Merge(ls, tmp), rs);\n        } else if(cons == 'D'){\n            int st = read(), k = read();\n            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;\n            Split(root, st - 1, ls, rs);\n            Split(rs, k, xs, ys);\n            root = Merge(ls, ys);\n            cnt += xs == NULL ? 0 : xs -> size;\n            Del(xs);\n        } else if(cons == 'R'){\n            int st = read(), k = read();\n            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;\n            Split(root, st - 1, ls, rs);\n            Split(rs, k, xs, ys);\n            Reverse(xs);\n            root = Merge(ls, Merge(xs, ys));\n        } else if(cons == 'G'){\n            while(!isspace(get_char()));\n            int st = read(), k = read();\n            Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;\n            Split(root, st - 1, ls, rs);\n            Split(rs, k, xs, ys);\n            if(xs == NULL) puts(\"0\");\n            else printf(\"%d\\n\", xs -> sum);\n            root = Merge(ls, Merge(xs, ys));\n        } else {\n            cons = get_char(), cons = get_char();\n            while(!isspace(get_char()));\n            if(cons == 'X') printf(\"%d\\n\", root -> sm);\n            else {\n                int st = read(), k = read(), val = read();\n                Node *ls = NULL, *rs = NULL, *xs = NULL, *ys = NULL;\n                Split(root, st - 1, ls, rs);\n                Split(rs, k, xs, ys);\n                Cover(xs, val);\n                root = Merge(ls, Merge(xs, ys));\n            }\n        }\n    }\n    // Debug Get Running Memery\n    // system(\"wmic process where name=\\\"a.exe\\\" get WorkingSetSize\");\n    return 0;\n}\n```\n    ",
        "postTime": 1517539463,
        "uid": 43464,
        "name": "Creeper_LKF",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2042 \u3010[NOI2005]\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "PS\uff1a\u67d0\u5927\u4f6c\u8bb2\uff0c\u5f53\u5fc3\u60c5\u7279\u522b\u597dor\u7279\u522b\u4e0d\u597d\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u6765\u653b\u7565\u8fd9\u4e2a\u9898\u3002\u3002\u3002\u679c\u7136\u840c\u65b0\u8db3\u8db3\u88ab\u8fd9\u9898\u6076\u5fc3\u4e86\u534a\u4e2a\u6708\u3002\u3002\u3002\n\n\u8fdb\u5165\u6b63\u9898\uff1a\n\n\u8fd9\u9053\u9898\u9898\u610f\u5982\u6b64\u4e4b\u88f8-Splay\u306e\u7a76\u6781\u8fdb\u5316\uff0c\u90a3\u4e48\u5c31\u6ca1\u6709\u4ec0\u4e48\u597d\u8bb2\u7684\uff0c\u76f4\u63a5\u8bf4\u641e\u6cd5\u597d\u4e86\u3002\u3002\u3002\n\n\u4e3a\u4e86\u4ee3\u7801\u5199\u8d77\u6765\u65b9\u4fbf\uff0c\u840c\u65b0\u5c01\u88c5\u5f97\u53ef\u80fd\u6709\u4e9b\u8fc7\uff0c\u82e5\u4e0d\u5408\u8bf8\u4f4d\u5927\u4f6c\u7684\u53e3\u5473\u8fd8\u8bf7\u89c1\u8c05~\n\n\n###\u8282\u70b9node\u7ed3\u6784\u4f53\u5b9a\u4e49\uff1a\n\nkey\uff1a\u8282\u70b9\u539f\u503c\uff1bsize\uff1a\u5b50\u6811\u5927\u5c0f\uff1bch[2]\uff1a\u5b50\u6811\u6307\u9488\uff1b\n\nset\\_pd\uff1a\u8bb0\u5f55\u662f\u5426\u6253\u4e86MAKE-SAME\u7684\u61d2\u6807\u8bb0\uff1bsetv\uff1aMAKE-SAME\u7684\u4fee\u6539\u503c\uff1bturn\uff1a\u8bb0\u5f55\u662f\u5426\u65cb\u8f6c\uff1b\n\nsum\uff1a\u5b50\u6811\u5143\u7d20\u603b\u548c\uff1blmax,rmax,zdh\uff1a\u5f53\u524d\u8282\u70b9\u6240\u63a7\u5236\u533a\u95f4\u7684\u6700\u5927\u524d\u7f00\u548c\u3001\u6700\u5927\u540e\u7f00\u548c\u3001\u6700\u5927\u5b50\u6bb5\u548c\u3002\n\n\u6210\u5458\u51fd\u6570\uff1a\n\n\n```cpp\nmaintain()\uff1a\u7ef4\u62a4\u8282\u70b9\u4fe1\u606f\uff1b\nupdate_same()\uff1a\u6253MAKE-SAME\u7684\u61d2\u6807\u8bb0\uff1b\nupdate_rev()\uff1a\u6253REVERSE\u7684\u61d2\u6807\u8bb0\uff1b\npushdown()\uff1a\u4e0b\u653e\u61d2\u6807\u8bb0\uff1b\ncmp(int x)\uff1a\u6c42\u5728\u5f53\u524d\u8282\u70b9\u6240\u63a7\u5236\u533a\u95f4\u4e2d\uff0c\u6392\u540d\u4e3ax\u7684\u5143\u7d20\u76f8\u5bf9\u4e8e\u5f53\u524d\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c0\u4e3a\u5de6\uff0c1\u4e3a\u53f3\uff0c-1\u4e3a\u5f53\u524d\u8282\u70b9\u81ea\u8eab\uff1b\nson_order(int x,bool d)\uff1a\u6c42\u5728\u5f53\u524d\u8282\u70b9\u6240\u63a7\u5236\u533a\u95f4\u4e2d\uff0c\u6392\u540d\u4e3ax\u7684\u5143\u7d20\u5728d\u6307\u5411\u7684\u5b50\u6811\u4e2d\u7684\u6392\u540d\u3002\n```\n\u4e3b\u7a0b\u5e8f\u51fd\u6570\uff1a\nrotate()\uff1a\u840c\u65b0\u91c7\u7528\u4e86\u5148\u4e0b\u653e\u518d\u8003\u8651\u5982\u4f55\u65cb\u8f6c\u7684\u5199\u6cd5\uff0c\u6240\u4ee5\u4e0d\u5fc5\u8003\u8651\u6539\u53d8\u65cb\u8f6c\u65b9\u5411\u4e4b\u7c7b\u7684\u4e1c\u897f\u3002\u3002\u3002\u6ce8\u610f\u4e0b\u653e\u3001\u7ef4\u62a4\u5c31\u597d\u4e86\uff1b\n\nsplay()\uff1a\u6b64\u51fd\u6570\uff0c\u840c\u65b0\u7684\u81ea\u884c\u7814\u5236\u5199\u6cd5\uff0c\u76f8\u5bf9\u5927\u4f6c\u4eec\u7684\u4ee3\u7801\uff0c\u770b\u4e0a\u53bb\u957f\u4e86\u8bb8\u591a\u3002\u3002\u3002\u4e0d\u8fc7\u4e5f\u53ef\u4ee5\u653e\u5fc3\u98df\u7528\u5566~\u65e0\u7236\u6307\u9488Splay\u8d5b\u9ad8~\n\nbuild()\uff1a\u5efa\u7acb\u5b8c\u5168\u5e73\u8861\u7684BST\uff0c\u6b64\u9898\u4e2d\u5e94\u7528\u8fd9\u79cd\u5efa\u6811\u65b9\u5f0f\uff0c\u53ef\u6781\u5927\u5730\u63d0\u9ad8\u4ee3\u7801\u901f\u5ea6\uff1b\n\nrecycle()\uff1a\u56de\u6536\u5220\u9664\u7684\u533a\u95f4\u6240\u5360\u7528\u7684\u7a7a\u95f4\uff0c\u5982\u679c\u6ca1\u6709\u8fd9\u4e2a\uff0c\u4f1a\u5bfc\u81f4\u4e2a\u522b\u70b9MLE\uff1b\n\n\nget\\_range()\uff1a\u8fd9\u4e2a\u51fd\u6570\u7684\u529f\u80fd\u662f\u62bd\u53d6\u533a\u95f4\u3002\u3002\u3002\n\n\u4e3a\u4ec0\u4e48\u8981\u5199\u8fd9\u4e2a\u5462\uff1f\u56e0\u4e3a\u840c\u65b0\u592a\u5f31\u4e86\u3002\u3002\u3002\n\n\u6211\u4eec\u77e5\u9053\uff0c\u5728\u62bd\u53d6\u533a\u95f4\u65f6\uff0c\u5bf9\u8fb9\u754c\u60c5\u51b5\uff0c\u76f4\u63a5Splay\u5c31\u89e3\u51b3\u4e0d\u4e86\u4e86\uff1b\n\n\u8fd9\u65f6\u4e00\u822c\u4f1a\u7528\u201c\u5728\u5934\u548c\u5c3e\u52a0\u865a\u62df\u8282\u70b9\u201d\u7684\u65b9\u6cd5\uff1b\n\n\u840c\u65b0\u66fe\u8bd5\u7740\u8fd9\u6837\u5199\u8fc7\u3002\u3002\u3002\u4f46\u6700\u7ec8\u6ca1\u80fd\u89e3\u51b3\u865a\u62df\u8282\u70b9\u7684\u4fe1\u606f\u7ef4\u62a4\u95ee\u9898\uff0c\u5c24\u5176\u662f\u6700\u5927\u5b50\u6bb5\u548c\u4ec0\u4e48\u7684\u3002\u3002\u3002\n\n\u4e8e\u662f\u653e\u5f03\uff0c\u91c7\u7528\u4e86\u7565\u4e3a\u7e41\u7410\u7684\u5206\u7c7b\u8ba8\u8bba\u5199\u6cd5\uff0c\u5177\u4f53\u5982\u4e0b\uff1a\n\n1.\u82e5\u533a\u95f4\u4e3a\u6574\u4e2a\u5e8f\u5217\uff0c\u5219\u4e0d\u4f5c\u4efb\u4f55\u64cd\u4f5c\uff0croot\u5373\u53ef\u4ee3\u8868\u6574\u4e2a\u5e8f\u5217\uff1b\n\n2.\u82e5\u533a\u95f4\u4e3a[1,x]\uff0c\u5176\u4e2dx<n\uff0c\u5219\u5c06x+1\u53f7\u5143\u7d20splay\u81f3root\uff0c\u5219root->ch[0]\u5373\u4e3a\u8be5\u533a\u95f4\uff1b\n\n3.\u82e5\u533a\u95f4\u4e3a[x,n]\uff0c\u5176\u4e2dx>1\uff0c\u5219\u91c7\u53d6\u7c7b\u4f3c\u4e0a\u9762\u7684\u64cd\u4f5c\uff1b\n\n4.\u82e5\u533a\u95f4\u4e3a[l,r]\uff0c\u5176\u4e2d1<l<=r<n\uff0c\u90a3\u4e48\u5c06l-1\u3001r+1\u5206\u522bsplay\u81f3root\u3001root->ch[1]\uff0c\u5219root->ch[1]->ch[0]\u5373\u4e3a\u8be5\u533a\u95f4\u3002\n\n\u64cd\u4f5c\u5b8c\u540e\uff0c\u8fd4\u56de\u4e00\u4e2a\u503c\uff0c\u7528\u4e8e\u5728\u540e\u7eed\u64cd\u4f5c\u4e2d\u8fdb\u884c\u5bf9\u4e0d\u540c\u60c5\u51b5\u7684\u8bc6\u522b\u3002\n\n\nwork()\uff1a\u4f9d\u636e\u4e0d\u540c\u7684\u533a\u95f4\u60c5\u51b5\u548c\u4e0d\u540c\u7684\u6307\u4ee4\uff0c\u8fdb\u884c\u76f8\u5e94\u64cd\u4f5c\u3002\n\nchange()\uff1a\u4f9d\u636e\u4e0d\u540c\u7684\u533a\u95f4\u60c5\u51b5\u8fdb\u884c\u5bf9\u76f8\u5173\u8282\u70b9\u7684\u4fe1\u606f\u7ef4\u62a4\u3002\n\n\n#\u5927\u5751\u8b66\u793a\uff01\uff01\uff01\u4e2a\u522b\u70b9\u4e2d\uff0c\u64cd\u4f5c\u7684\u533a\u95f4\u53ef\u80fd\u957f\u5ea6\u4e3a0\uff01\uff01\uff01\n\n\u840c\u65b0\u5c31\u662f\u56e0\u4e3a\u8fd9\u4e2a\u95ee\u9898\u800c\u83ab\u540dRE\u4e86\u597d\u4e45\u3002\u3002\u3002\u540e\u6765\u7ec8\u4e8e\u5bf9\u7167\u67d0\u5927\u4f6c\u7684\u4ee3\u7801\u624d\u53d1\u73b0\u4e86\u95ee\u9898\u3002\u3002\u3002\n\n\n###\u4ee3\u7801\u5982\u4e0b\uff1a\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n    \n        \n        \n    \n        \n        \n        \n    \n        \n    \n            \n            \n            \n    \n        \n    \n\n\n\n\n\n\n    \n    \n        \n                \n                \n                \n            \n                \n                \n            \n                \n                \n            \n                \n                \n            \n                \n                \n            \n                \n    \n\n    \n    \n    \n    \n\n    \n    \n    \n        \n        \n\n    \n    \n    \n\n    \n\n\n    \n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#define inf 2147483647\nusing namespace std;\nvoid read(int &x){\n    x=0;\n    char t=getchar();\n    bool f=0;\n    while(t<'0' || t>'9'){\n        if(t=='-')f=1;\n        t=getchar();\n    }\n    while(t>='0' && t<='9'){\n        x=(x<<3)+(x<<1)+t-'0';\n        t=getchar();\n    }\n    if(f)x=-x;\n}\nstruct node{\n    int key;\n    int size;\n    node *ch[2];\n    bool set_pd;\n    int setv;\n    bool turn;\n    int sum;\n    int lmax;\n    int rmax;\n    int zdh;\n    void maintain(){\n        size=1;\n        if(ch[0]!=NULL)size+=ch[0]->size;\n        if(ch[1]!=NULL)size+=ch[1]->size;\n        sum=key;\n        if(ch[0]!=NULL)sum+=ch[0]->sum;\n        if(ch[1]!=NULL)sum+=ch[1]->sum;\n        if(ch[0]==NULL && ch[1]==NULL){\n            lmax=rmax=max(0,key);\n            zdh=key;\n        }\n        else if(ch[1]==NULL){\n            lmax=max(ch[0]->lmax,ch[0]->sum+key);\n            rmax=max(0,key+ch[0]->rmax);\n            zdh=max(ch[0]->zdh,ch[0]->rmax+key);\n        }\n        else if(ch[0]==NULL){\n            lmax=max(0,key+ch[1]->lmax);\n            rmax=max(ch[1]->rmax,ch[1]->sum+key);\n            zdh=max(ch[1]->zdh,key+ch[1]->lmax);\n        }\n        else{\n            lmax=max(ch[0]->lmax,ch[0]->sum+key+ch[1]->lmax);\n            rmax=max(ch[1]->rmax,ch[1]->sum+key+ch[0]->rmax);\n            zdh=max(max(ch[0]->zdh,ch[1]->zdh),ch[0]->rmax+key+ch[1]->lmax);\n        }\n    }\n    void update_same(int fix){\n        set_pd=1;\n        key=setv=fix;\n        sum=fix*size;\n        lmax=rmax=max(0,sum);\n        zdh=max(sum,key);\n        turn=0;  //\u6253\u4e86MAKE-SAME\u4e4b\u540e\u5c31\u53ef\u4ee5\u65e0\u89c6\u65cb\u8f6c\u4e86\n    }\n    void update_rev(){\n        turn^=1;\n        lmax^=rmax;\n        rmax^=lmax;\n        lmax^=rmax;  //\u5728\u4e0a\u5c42\u8282\u70b9\u62bd\u53d6\u672c\u8282\u70b9\u4fe1\u606f\u65f6\uff0c\u8981\u6c42\u5fc5\u987b\u5728\u65cb\u8f6c\u65f6\u4ea4\u6362lmax\u548crmax\n    }\n    void pushdown(){\n        if(set_pd){\n            if(ch[0]!=NULL)ch[0]->update_same(setv);\n            if(ch[1]!=NULL)ch[1]->update_same(setv);\n            set_pd=0;\n            turn=0;\n        }\n        if(turn){\n            node *t=ch[0];\n            ch[0]=ch[1];\n            ch[1]=t;\n            if(ch[0]!=NULL)ch[0]->update_rev();\n            if(ch[1]!=NULL)ch[1]->update_rev();\n            turn=0;\n        }\n    }\n    int cmp(int x){\n        int s=0;\n        if(ch[0]!=NULL)s=ch[0]->size;\n        if(x<=s)return 0;\n        else if(x==s+1)return -1;\n        else return 1;\n    }\n    int son_order(int x,bool d){\n        if(d==0)return x;\n        else{\n            if(ch[0]==NULL)return x-1;\n            else return x-ch[0]->size-1;\n        }\n    }\n};\nvoid rotate(node* &,bool);  //\u6ca1\u6709\u81ea\u5e26\u5bf9\u5f53\u524d\u6839\u8282\u70b9\u7684\u61d2\u6807\u8bb0\u4e0b\u653e \nvoid splay(node* &,int);  //\u6309\u7167\u6392\u540d\u4f38\u5c55 \nvoid build(node* &,int,int,int);\nvoid recycle(node *);\nint get_range();\nvoid work(int);\nvoid change();\nnode *root=NULL;\nnode *temp;\nint longtao[500010];\nchar s[15];\nint n,m,i,j;\nint pos,tot,fix,kind;\nint main(){\n    read(n);read(m);\n    for(i=1;i<=n;i++)read(longtao[i]);\n    build(root,1,n,(1+n)>>1);\n    for(i=1;i<=m;i++){\n        scanf(\"%s\",s);\n        switch(s[2]){\n            case 'S':{\n                read(pos);read(tot);\n                if(tot==0)break;\n                for(j=1;j<=tot;j++)read(longtao[j]);\n                temp=NULL;\n                build(temp,1,tot,(1+tot)>>1);\n                if(pos==0){\n                    splay(root,1);\n                    root->ch[0]=temp;\n                    root->maintain();\n                }\n                else if(pos==root->size){\n                    splay(root,inf);\n                    root->ch[1]=temp;\n                    root->maintain();\n                }\n                else{\n                    splay(root,pos);\n                    splay(root->ch[1],1);\n                    root->ch[1]->ch[0]=temp;\n                    root->ch[1]->maintain();\n                    root->maintain();\n                }\n                break;\n            }\n            case 'L':{\n                read(pos);read(tot);\n                if(tot==0)break;\n                kind=get_range();\n                work(2);\n                change();\n                break;\n            }\n            case 'K':{\n                read(pos);read(tot);read(fix);\n                if(tot==0)break;\n                kind=get_range();\n                work(3);\n                change();\n                break;\n            }\n            case 'V':{\n                read(pos);read(tot);\n                if(tot==0)break;\n                kind=get_range();\n                work(4);\n                change();\n                break;\n            }\n            case 'T':{\n                read(pos);read(tot);\n                if(tot==0){\n                    printf(\"0\\n\");\n                    break;\n                }\n                kind=get_range();\n                work(5);\n                break;\n            }\n            case 'X':{\n                printf(\"%d\\n\",root->zdh);\n                break;\n            }\n        }\n    }\n    return 0;\n}\nvoid rotate(node* &p,bool f){\n    node *t=p->ch[f^1];\n    t->pushdown();\n    p->ch[f^1]=t->ch[f];\n    t->ch[f]=p;\n    p->maintain();\n    t->maintain();\n    p=t;\n}\nvoid splay(node* &p,int x){\n    p->pushdown();\n    int d1=p->cmp(x);\n    if(d1==-1 || p->ch[d1]==NULL)return;\n    p->ch[d1]->pushdown();\n    int x2=p->son_order(x,d1);\n    int d2=p->ch[d1]->cmp(x2);\n    if(d2==-1 || p->ch[d1]->ch[d2]==NULL){\n        rotate(p,d1^1);\n        return;\n    }\n    else{\n        int x3=p->ch[d1]->son_order(x2,d2);\n        splay(p->ch[d1]->ch[d2],x3);\n        if(d1==d2){\n            rotate(p,d1^1);\n            rotate(p,d2^1);\n        }\n        else{\n            rotate(p->ch[d1],d1);\n            rotate(p,d2);\n        }\n    }\n}\nvoid build(node* &p,int l,int r,int mid){\n    p=(node *)malloc(sizeof(node));\n    p->key=longtao[mid];\n    p->ch[0]=p->ch[1]=NULL;\n    p->set_pd=0;\n    p->turn=0;\n    if(mid-1>=l)build(p->ch[0],l,mid-1,(l+mid-1)>>1);\n    if(mid+1<=r)build(p->ch[1],mid+1,r,(mid+1+r)>>1);\n    p->maintain();\n}\nvoid recycle(node *p){\n    if(p->ch[0]!=NULL)recycle(p->ch[0]);\n    if(p->ch[1]!=NULL)recycle(p->ch[1]);\n    free(p);\n}\nint get_range(){\n    if(tot==root->size)return 1;\n    else if(pos==1){\n        splay(root,pos+tot);\n        return 2;\n    }\n    else if(pos+tot-1==root->size){\n        splay(root,pos-1);\n        return 3;\n    }\n    else{\n        splay(root,pos-1);\n        splay(root->ch[1],tot+1);\n        return 4;\n    }\n}\nvoid work(int f){\n    node **t;\n    if(kind==1)t=&root;\n    if(kind==2)t=&(root->ch[0]);\n    if(kind==3)t=&(root->ch[1]);\n    if(kind==4)t=&(root->ch[1]->ch[0]);\n    if(f==2){\n        recycle(*t);\n        (*t)=NULL;\n    }\n    else if(f==3)(*t)->update_same(fix);\n    else if(f==4)(*t)->update_rev();\n    else printf(\"%d\\n\",(*t)->sum);\n}\nvoid change(){\n    if(kind==2 || kind==3)root->maintain();\n    else if(kind==4){\n        root->ch[1]->maintain();\n        root->maintain();\n    }\n}\n```",
        "postTime": 1502544654,
        "uid": 22630,
        "name": "Running_Coder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    },
    {
        "content": "\u77edSplay\n\n\n\u5e8f\u5217\u7ffb\u8f6c\u5c31\u9012\u5f52\u4ea4\u6362\u5de6\u53f3\u5b50\u6811\u5373\u53ef\u3002\n\n\n\u8282\u70b9node\u7684\u4fe1\u606f\uff1a\n\n\n$\\large{data:\u6743\u503c}$\n\n\n$\\large{sum:\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6743\u503c\u548c}$\n\n\n$\\large{maxsum:\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6743\u503c\u7684\u6700\u5927\u5b50\u6bb5\u548c}$\n\n\n$\\large{lazr:\u5e8f\u5217\u7ffb\u8f6c\u61d2\u6807}$\n\n\n$\\large{lazs:\u5e8f\u5217\u8d4b\u503c\u61d2\u6807}$\n\n\n$\\large{lx\\&rx:\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u6240\u4ee3\u8868\u7684\u5e8f\u5217\u4ece\u53f3\uff08\u5de6\uff09\u5f80\u5de6\uff08\u53f3\uff09\u6570\u7684\u6700\u5927\u503c}$\n\n\n$\\large{siz:\u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u6570}$\n\n\n\u66f4\u65b0\u516c\u5f0f\uff1a\n\n\n$\\Large{a_{sum}=l_{sum}+a_{data}+r_{sum}}$\n\n\n$\\Large{a_{maxsum}=\\scriptstyle{max} \\textstyle\\left\\{ l_{maxsum},r_{maxsum},l_{rx}+a_{data}+r_{lx} \\right\\} }$\n\n\n$\\Large{a_{siz}=l_{siz}+1+r_{siz}}$\n\n\n$\\Large{a_{lx}=\\scriptstyle{\\max} \\textstyle\\left\\{ l_{lx},l_{sum}+a_{data}+r_{lx} \\right\\} }$\n\n\n$\\Large{a_{rx}=\\scriptstyle{\\max} \\textstyle\\left\\{ r_{rx},r_{sum}+a_{data}+l_{rx} \\right\\} }$\n\n\n\u53e6\u5916\uff0c\u5728\u65cb\u8f6c\u5de6\u53f3\u5b50\u6811\u65f6\uff0c\u540c\u65f6\u8981\u4ea4\u6362lx,rx;\n\n\n\u5728\u8fdb\u884c\u533a\u95f4\u8d4b\u503c\u65f6\uff0c\u8981\u66f4\u65b0lx,rx,maxsum;\n\n\n$\\LARGE{\u6ce8\u610f\uff1a\u5728\u8fd9\u79cd\u9898\u5f53\u4e2d\uff0c\u6ee1\u8db3\u4e8c\u53c9\u641c\u7d22\u6811\u7684\u662f\u5728\u5e8f\u5217\u4e2d\u7684\u4f4d\u7f6e\uff0c\u800c\u4e0d\u662f\u6743\u503c\uff01\uff01\uff01}$\n\n\n\u5176\u4ed6\u7ec6\u8282\u8be6\u89c1\u4ee3\u7801\u3002\n\n\n``` javascript\n#include<iostream>\n#include<cstdio>\n#define now root->ch[1]->ch[0]\nusing namespace std;\ninline int read(){\n    int x=0,f=1;\n    int ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint ans;\nbool flag;\nchar ch[11];\ntypedef int T;\nstruct node{\n    T data,sum,maxsum;\n    node *ch[2];\n    int siz,lazr,lazs,lx,rx;\n    node(T x,node *nu){data=sum=maxsum=x;ch[0]=ch[1]=nu;siz=1;lazr=lazs=0;lx=rx=(x>=0)?x:0;if(nu==NULL){siz=0;maxsum=-0x80000000;}}\n    inline void maintain(){\n        sum=ch[0]->sum+data+ch[1]->sum;\n        siz=ch[0]->siz+1+ch[1]->siz;\n        maxsum=max(ch[0]->maxsum,max(ch[1]->maxsum,ch[0]->rx+data+ch[1]->lx));\n        lx=max(ch[0]->lx,ch[0]->sum+data+ch[1]->lx);\n        rx=max(ch[1]->rx,ch[1]->sum+data+ch[0]->rx);\n    }\n    inline void pushdown(node *no){\n        if(lazs){\n            lazs=lazr=0;\n            if(ch[0]!=no){ch[0]->lazs=1;ch[0]->data=data;ch[0]->sum=data*ch[0]->siz;}\n            if(ch[1]!=no){ch[1]->lazs=1;ch[1]->data=data;ch[1]->sum=data*ch[1]->siz;}\n            if(data>=0){\n                if(ch[0]!=no)ch[0]->lx=ch[0]->rx=ch[0]->maxsum=ch[0]->sum;\n                if(ch[1]!=no)ch[1]->lx=ch[1]->rx=ch[1]->maxsum=ch[1]->sum;\n            }else{\n                if(ch[0]!=no){ch[0]->lx=ch[0]->rx=0;ch[0]->maxsum=data;}\n                if(ch[1]!=no){ch[1]->lx=ch[1]->rx=0;ch[1]->maxsum=data;}\n            }\n        }\n        if(lazr){\n            lazr=0;\n            if(ch[0]!=no){ch[0]->lazr^=1;swap(ch[0]->lx,ch[0]->rx);swap(ch[0]->ch[0],ch[0]->ch[1]);}\n            if(ch[1]!=no){ch[1]->lazr^=1;swap(ch[1]->lx,ch[1]->rx);swap(ch[1]->ch[0],ch[1]->ch[1]);}\n        }\n    }\n}null(0,NULL),*Null=&null,*root;\nclass Splay{\n    private:\n        inline void rotate(node *&bt,int d){\n            node *tmp=bt->ch[d^1];\n            if(bt->lazr)d^=1;\n            bt->pushdown(Null);\n            tmp->pushdown(Null);\n            bt->ch[d^1]=tmp->ch[d];\n            tmp->ch[d]=bt;\n            bt->maintain();\n            tmp->maintain();\n            bt=tmp;\n        }\n        bool splay(node *&to,int x,node *&bt=root,node *&fa=Null){\n            if(bt==Null){flag=false;return true;}\n            bt->pushdown(Null);\n            int d,s=bt->ch[0]->siz;\n            bool b;\n            if(x<=s)b=splay(to,x,bt->ch[d=0],bt);\n            else if(x>s+1)b=splay(to,x-s-1,bt->ch[d=1],bt);\n            else{if(bt==to)flag=false;return true;}\n            if(!flag)return true;\n            if(bt==to)flag=false;\n            if(!b)return true;\n            if(fa==Null||!flag)rotate(bt,d^1);\n            else if(fa->ch[d]==bt){rotate(fa,d^1);rotate(fa,d^1);}\n            else{rotate(bt,d^1);rotate(fa,d);}\n            return false;\n        }\n        void insert(T x,node *&bt){\n            if(bt==Null){bt=new node(x,Null);return;}\n            bt->pushdown(Null);\n            insert(x,bt->ch[1]);\n            bt->maintain();\n        }\n        inline void split(int k,node *&bt){flag=true;splay(bt,k);}\n        void removetree(node *&bt=now){\n            if(bt==Null)return;\n            removetree(bt->ch[0]);\n            removetree(bt->ch[1]);\n            delete bt;\n            bt=Null;\n        }\n        void build(node *&bt,int l,int r){\n            int mid=(l+r)>>1;\n            bt=new node(0,Null);\n            if(l!=mid)build(bt->ch[0],l,mid-1);\n            bt->data=read();\n            if(mid!=r)build(bt->ch[1],mid+1,r);\n            bt->maintain();\n        }\n    public:\n        inline void cut(int l,int n){split(l,root);split(l+n+1,root->ch[1]);}\n        inline void insert(int tot){build(now,1,tot);root->ch[1]->maintain();root->maintain();}\n        inline void remove(int l,int n){cut(l,n);removetree();root->ch[1]->maintain();root->maintain();}\n        inline void reverse(int l,int n){\n            cut(l,n);\n            if(now->lazs)return;\n            now->lazr^=1;\n            swap(now->lx,now->rx);\n            swap(now->ch[0],now->ch[1]);\n            root->ch[1]->maintain();\n            root->maintain();\n        }\n        inline void memset(int l,int n,int c){\n            cut(l,n);\n            now->lazs=1;\n            now->lazr=0;\n            now->data=c;\n            now->sum=now->siz*c;\n            if(c>=0){now->lx=now->rx=now->maxsum=now->sum;}\n            else{now->lx=now->rx=0;now->maxsum=c;}\n            root->ch[1]->maintain();\n            root->maintain();\n        }\n        inline T getsum(int l,int n){cut(l,n);return now->sum;}\n        inline T getmaxsum(){cut(1,root->siz-2);return now->maxsum;}\n        Splay(){root=new node(-0x80000000,Null);root->ch[1]=new node(0x7fffffff,Null);root->maintain();}\n}sp;\nint main(){\n    int n=read(),m=read();\n    sp.cut(1,0);\n    sp.insert(n);\n    for(int i=1;i<=m;i++){\n        int l,s,c;\n        scanf(\"%s\",ch);\n        if(ch[0]=='M'&&ch[2]=='X')printf(\"%d\\n\",sp.getmaxsum());\n        else{\n            l=read();\n            s=read();\n            if(!n){if(ch[0]=='G')printf(\"0\\n\");continue;}\n            if(ch[0]=='I'){\n                sp.cut(l+1,0);\n                sp.insert(s);\n            }else if(ch[0]=='D')sp.remove(l,s);\n            else if(ch[0]=='M'){\n                c=read();\n                sp.memset(l,s,c);\n            }else if(ch[0]=='R')sp.reverse(l,s);\n            else if(ch[0]=='G')printf(\"%d\\n\",sp.getsum(l,s));\n        }\n    }\n}\n```",
        "postTime": 1506314535,
        "uid": 52102,
        "name": "wycissilly",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2042 \u3010\u7ef4\u62a4\u6570\u5217\u3011"
    }
]