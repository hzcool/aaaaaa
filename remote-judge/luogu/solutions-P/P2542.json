[
    {
        "content": "\u9898\u89e3\u5728\u535a\u5ba2[\u98df\u7528](https://www.cnblogs.com/YoungNeal/p/9147556.html)\u6548\u679c\u66f4\u4f73\u54e6~\n\n\u697c\u4e0bdalao\u7684lct\u6211\u5e76\u4e0d\u4f1a\n\n\u53ea\u4f1a\u84bb\u84bb\u7684\u6811\u5256qwq\n\n## Hint\n\n\u6211\u4eec\u4fdd\u8bc1\u65e0\u8bba\u822a\u7ebf\u5982\u4f55\u88ab\u7834\u574f\uff0c\u4efb\u610f\u65f6\u523b\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u90fd\u80fd\u591f\u76f8\u4e92\u5230\u8fbe\u3002\u5728\u6574\u4e2a\u6570\u636e\u4e2d\uff0c\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u6700\u591a\u53ea\u53ef\u80fd\u5b58\u5728\u4e00\u6761\u76f4\u63a5\u7684\u822a\u7ebf\u3002\n\n## Solution\n\n\u9996\u5148\u8fd9\u9898\u79bb\u7ebf\u9006\u5e8f\u5904\u7406\u4e0d\u5fc5\u591a\u8bf4\u4e86\uff0c\u8fd9\u7c7b\u5220\u9664\u70b9/\u8fb9\u9898\u56fa\u5b9a\u5957\u8def\n\n\u521a\u770b\u5230\u8fd9\u9898\u7684\u60f3\u6cd5\u662f $Tarjan$ \u7f29\u70b9\u7136\u540e\u600e\u4e48\u62d3\u6251\u4e71\u641e\u6c42\u4e00\u4e0b\u8ddd\u79bb\n\n\u7136\u800c\u8fd9\u662f\u4e00\u4e2a\u65e0\u5411\u56fe\u5e76\u4e0d\u5b58\u5728\u62d3\u6251\u5e8f\n\n\u7136\u800c\u6211\u5e76\u4e0d\u4f1a\u6c42\u8ddd\u79bb\n\n\u6211\u4eec\u6ce8\u610f\u5230 $Hint$ \u91cc\u9762\u4fdd\u8bc1\u4e86\u8fd9\u4e48\u4e00\u53e5\u8bdd```\u5728\u6574\u4e2a\u6570\u636e\u4e2d\uff0c\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u6700\u591a\u53ea\u53ef\u80fd\u5b58\u5728\u4e00\u6761\u76f4\u63a5\u7684\u822a\u7ebf\u3002```\n\n\u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u91cd\u8fb9\uff0c\u800c\u4e14\u4e92\u76f8\u8fde\u901a\uff0c\u53c8\u662f\u65e0\u5411\u56fe...\u60f3\u5230\u4e86\u4ec0\u4e48\uff1f\u7f29\u5b8c\u70b9\u540e\u7684\u56fe\u662f\u4e00\u68f5\u6811\u554a\uff01\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u9700\u8981\u52a8\u6001\u7684\u7ef4\u62a4\u6811\u4e0a\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\n\n\u6811\u4e0a\u628a\u70b9\u8fde\u8d77\u6765\u7684\u662f\u4ec0\u4e48\uff1f\u8fb9\u554a\uff01\n\n\u90a3\u4e48\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u7684\u8fb9\u6743\u4e0d\u5c31\u884c\u4e86\uff01\n\n\u60f3\u5230\u4e86\u4ec0\u4e48\uff1f\u6811\u94fe\u5256\u5206\uff01\n\n\u5bf9\uff0c\u6211\u4eec\u53ef\u4ee5\u6811\u5256\u7ef4\u62a4\u6811\u4e0a\u7684\u8fb9\u6743\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u8f7b\u800c\u6613\u4e3e\u7684\u6c42\u51fa\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u4e86\u3002\n\n\u90a3...\u600e\u4e48\u52a8\u6001\u7f29\u70b9\u5462\uff1f\n\n\u505a\u8fd9\u9898\u65f6\uff0c\u6211\u4e3a\u8fd9\u4e8b\u7ea0\u7ed3\u4e86\u534a\u5929...\n\n\u7136\u540e\u624d\u53d1\u73b0\uff0c\u65e2\u7136\u80fd\u7ef4\u62a4\u6811\u4e0a\u4e24\u70b9\u95f4\u8ddd\u79bb\uff0c\u90a3\u8fd8\u7f29\u70b9\u5e72\u5565\u5462\uff1f\n\n\u76f4\u63a5\u5c06\u4e00\u4e2a\u73af\u5185\u7684\u70b9\u4e4b\u95f4\u7684\u8fb9\u6743\u8d4b\u4e3a0\u4e0d\u5c31\u884c\u4e86\uff01\n\n\u7b97\u6cd5\u6d41\u7a0b\u5982\u4e0b\uff1a\n\n0. \u8bfb\u5165\u8be2\u95ee\uff0c\u9006\u5e8f\u5904\u7406\n1. \u5148\u968f\u4fbf\u5728\u539f\u56fe\u4e2d\u6c42\u51fa\u4e00\u68f5\u751f\u6210\u6811\uff0c\u6211\u76f4\u63a5\u7528 $dfs$ \u5e8f\u5b9e\u73b0\u7684\n2. \u7136\u540e\u7528\u90a3\u4e9b\u6ca1\u88ab\u5220\u9664\u7684\u975e\u6811\u8fb9\u5148\u66f4\u65b0\u4e00\u904d\u5f53\u524d\u7684\u8fb9\u6743\n3. \u6811\u5256\u88f8\u9898\u3002\n\n\u56e0\u4e3a\u662f\u8fb9\u6743\u4e0b\u653e\u5230\u70b9\u6743\uff0c\u6ce8\u610f\u4fee\u6539\u7684\u65f6\u5019\u4e0d\u8981\u6539\u5b83\u4eec\u7684 $lca$ \uff01\n\n## Code\n\n```cpp\n#include<map>\n#include<cstdio>\n#include<cctype>\n#define N 30005\n#define Q 40005\n#define M 100005\n#define max(A,B) ((A)>(B)?(A):(B))\n#define min(A,B) ((A)<(B)?(A):(B))\n#define swap(A,B) ((A)^=(B)^=(A)^=(B))\n\nint n,m,d[N],ans[Q];\nstd::map<int,int> mp;\nint cnt,tot,son[N],pos;\nint val[N],head[N],fa[N];\nint dfn[N],top[N],ques[Q][5];\nint sze[N],sum[N<<2],lazy[N<<2];\n\nstruct Edge{\n\tint to,nxt,ok;\n}edge[M<<1];\n\nvoid add(int x,int y){\n\tedge[++cnt].to=y;\n\tedge[cnt].nxt=head[x];\n\thead[x]=cnt;\n\tmp[x*(n+1)+y]=cnt;;\n}\n\nint getint(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x*f;\n}\n\nvoid first_dfs(int now){\n\tsze[now]=1;\n\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;\n\t\tif(sze[to] or edge[i].ok)\n\t\t\tcontinue;\n\t\td[to]=d[now]+1;\n\t\tfa[to]=now;\n\t\tfirst_dfs(to);\n\t\tsze[now]+=sze[to];\n\t\tif(sze[to]>sze[son[now]])\n\t\t\tson[now]=to;\n\t}\n}\n\nvoid second_dfs(int now,int low){\n\tdfn[now]=++tot;\n\ttop[now]=low;\n\tif(son[now])\n\t\tsecond_dfs(son[now],low);\n\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;\n\t\tif(fa[to]!=now or to==son[now] or edge[i].ok)\n\t\t\tcontinue;\n\t\tsecond_dfs(to,to);\n\t}\n}\n\nvoid pushup(int cur){\n\tsum[cur]=sum[cur<<1]+sum[cur<<1|1];\n}\n\nvoid build(int cur,int l,int r){\n\tif(l==r){\n\t\tsum[cur]=1;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(cur<<1,l,mid);\n\tbuild(cur<<1|1,mid+1,r);\n\tpushup(cur);\n}\n\nvoid pushdown(int cur){\n\tif(!lazy[cur])\n\t\treturn;\n\tsum[cur<<1]=sum[cur<<1|1]=0;\n\tlazy[cur<<1]=lazy[cur<<1|1]=1;\n\tlazy[cur]=0;\n}\n\nvoid modify(int cur,int l,int r,int ql,int qr){\n\tif(ql<=l and r<=qr){\n\t\tsum[cur]=0;\n\t\tlazy[cur]=1;\n\t\treturn;\n\t}\n\tpushdown(cur);\n\tint mid=l+r>>1;\n\tif(ql<=mid)\n\t\tmodify(cur<<1,l,mid,ql,qr);\n\tif(mid<qr)\n\t\tmodify(cur<<1|1,mid+1,r,ql,qr);\n\tpushup(cur);\n}\n\nvoid change(int x,int y){\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])\n\t\t\tswap(x,y);\n\t\tmodify(1,1,n,dfn[top[x]],dfn[x]);\n\t\tx=fa[top[x]];\n\t}\n\tif(d[x]<d[y])\n\t\tswap(x,y);\n\tif(d[x]!=d[y])\n\t\tmodify(1,1,n,dfn[y]+1,dfn[x]);\n}\n\nvoid third_dfs(int now){\n\tfor(int i=head[now];i;i=edge[i].nxt){\n\t\tint to=edge[i].to;\n\t\tif(edge[i].ok)\n\t\t\tcontinue;\n\t\tif(fa[to]==now)\n\t\t\tthird_dfs(to);\n\t\tif(fa[now]!=to and d[to]<d[now])\n\t\t\tchange(to,now);\n\t}\n}\n\nint query(int cur,int l,int r,int ql,int qr){\n\tif(ql<=l and r<=qr)\n\t\treturn sum[cur];\n\tpushdown(cur);\n\tint mid=l+r>>1,now=0;\n\tif(ql<=mid)\n\t\tnow+=query(cur<<1,l,mid,ql,qr);\n\tif(mid<qr)\n\t\tnow+=query(cur<<1|1,mid+1,r,ql,qr);\n\treturn now;\n}\n\nint ask(int x,int y){\n\tint now=0;\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])\n\t\t\tswap(x,y);\n\t\tnow+=query(1,1,n,dfn[top[x]],dfn[x]);\n\t\tx=fa[top[x]];\n\t}\n\tif(d[x]<d[y])\n\t\tswap(x,y);\n\tnow+=query(1,1,n,dfn[y],dfn[x]);\n\tnow-=query(1,1,n,dfn[y],dfn[y]);\n\treturn now;\n}\n\nsigned main(){\n\tn=getint(),m=getint();\n\tfor(int i=1;i<=m;i++){\n\t\tint x=getint(),y=getint();\n\t\tadd(x,y); add(y,x);\n\t}\n\twhile(1){\n\t\tint a=getint();\n\t\tif(a==-1) break;\n\t\tint b=getint(),c=getint();\n\t\tques[++pos][1]=a;\n\t\tques[pos][2]=b;\n\t\tques[pos][3]=c;\n\t\tif(a==0)\n\t\t\tedge[mp[b*(n+1)+c]].ok=edge[mp[c*(n+1)+b]].ok=1;\n\t}\n\td[1]=1;\n\tfirst_dfs(1);\n\tsecond_dfs(1,1);\n\tbuild(1,1,n);\n\tthird_dfs(1);\n\tfor(int i=pos;i;i--){\n\t\tif(ques[i][1])\n\t\t\tans[i]=ask(ques[i][2],ques[i][3]);\n\t\telse\n\t\t\tchange(ques[i][2],ques[i][3]);\n\t}\n\tfor(int i=1;i<=pos;i++){\n\t\tif(ques[i][1]!=1) continue;\n\t\tprintf(\"%d\\n\",ans[i]);\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1528292946,
        "uid": 56778,
        "name": "YoungNeal",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u592a\u5f31\u4e86\u4e0d\u4f1a\u6811\u5256\uff0c\u89c9\u5f97LCT\u597d\u5199\u4e00\u4e9b\uff0c\u5c31\u4e0aLCT\u4e71\u641e\uff0c\u5f53LCT\u7ef4\u62a4\u53cc\u8fde\u901a\u5206\u91cf\u7684\u7ec3\u624b\u9898\u597d\u4e86\n\n\u6b63\u5e8f\u5220\u8fb9\u662f\u4e0d\u597d\u6765\u7ef4\u62a4\u8fde\u901a\u6027\u7684\uff0c\u4e8e\u662f\u5c31\u50cf\u6c34\u7ba1\u5c40\u957f\u90a3\u6837\u79bb\u7ebf\u5904\u7406\uff0c\u9006\u5e8f\u5b8c\u6210\u64cd\u4f5c\n\n\u663e\u7136\uff0c\u6bcf\u4e2a\u70b9\u53ef\u4ee5\u4ee3\u8868\u4e00\u4e2a\u53cc\u8fde\u901a\u5206\u91cf\uff0c\u67e5\u8be2\u5c31\u662f\u94fe\u7684\u957f\u5ea6-1\n\n\u8fde\u63a5\u4e00\u6761\u8fb9\uff0c\u5982\u679c\u5728LCT\u4e2d\u8fd8\u6ca1\u8fde\u901a\u5c31link\uff0c\u5982\u679c\u8fde\u901a\u4e86\uff0c\u663e\u7136\u8fd9\u91cc\u4f1a\u51fa\u73b0\u4e00\u4e2a\u73af\uff0c\u7136\u540e\u66b4\u529b\u7f29\u70b9\uff0c\u53ef\u4ee5\u628a\u5f53\u524d\u8f85\u52a9\u6811\u7684\u6839\u8282\u70b9\u5f53\u505a\u96c6\u5408\u7684\u6807\u5fd7\u8282\u70b9\uff0c\u7136\u540edfs\u6574\u4e2a\u8f85\u52a9\u6811\uff0c\u628a\u94fe\u4e0a\u7684\u5176\u5b83\u70b9\u7684\u5e76\u67e5\u96c6\u7956\u5148\u66b4\u529b\u6539\u6210\u8fd9\u4e2a\u6807\u5fd7\u8282\u70b9\uff0c\u6700\u540e\u518d\u65ad\u5f00\u6807\u5fd7\u8282\u70b9\u4e0e\u5b50\u6811\u7684\u8fde\u63a5\u3002\u603b\u7684\u66b4\u529b\u4fee\u6539\u6b21\u6570\u4e0d\u4f1a\u8d85\u8fc7$N\\log N$\u6b21\uff0c\u590d\u6742\u5ea6\u662f\u5bf9\u7684\n\n\u4f46\u662f\u70b9\u7f29\u5b8c\u4e86\uff0c\u90a3\u5b83\u4eec\u7684\u5b50\u6811\u4e0d\u4f1a\u6307\u7a7a\u5417\uff1f\u6240\u4ee5\uff0caccess\u7684\u65f6\u5019\uff0c\u8981\u66f4\u65b0$x$\u4e3a$geth(f[x])$\n\n\u81f3\u4e8e\u5e38\u6570\uff0cLCT\u4e5f\u5e76\u4e0d\u662f\u5f88\u6162\u554a\u3002\u53cd\u6b63~~\u6709\u4e86O2~~\u8fd8\u662f\u53ef\u4ee5\u505a\u5230\u5f88\u4f18\u79c0\u7684\n\n\u4ee3\u7801\u7ec6\u8282\u5f88\u591a\uff0c\u8c03\u8bd5\u771f\u5fc3\u7d2fTAT\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define RG register\n#define R RG short\n#define I inline void\n#define IB inline bool\n#define IS inline short\n#define G ch=getchar()\n#define lc c[x][0]\n#define rc c[x][1]\nconst int N=30009,M=100009;\nshort f[N],c[N][2],s[N],h[N],a[N],b[N],op[N],ans[M];\nbool r[N],vis[M];\nstruct EDGE{//\u5bf9\u8fb9\u6392\u5e8f\uff0c\u65b9\u4fbf\u67e5\u627e\u8be5\u8fb9\u662f\u5426\u88ab\u5220\u9664\n    short x,y;\n    IB operator<(const EDGE a)const{\n        return x<a.x||(x==a.x&&y<a.y);\n    }\n}e[M];\ntemplate<typename T>\nI in(RG T&z){\n    RG char G;\n    while(ch<'-')G;\n    z=ch&15;G;\n    while(ch>'-')z*=10,z+=ch&15,G;\n}\nIS geth(R x){\n    if(x==h[x])return x;\n    return h[x]=geth(h[x]);\n}\nIB nroot(R x){\n    return c[f[x]][0]==x||c[f[x]][1]==x;\n}\nI pushup(R x){\n    s[x]=s[lc]+s[rc]+1;\n}\nI pushdown(R x){\n    if(r[x]){\n        swap(lc,rc);\n        r[lc]^=1;r[rc]^=1;r[x]=0;\n    }\n}\nI pushall(R x){\n    if(nroot(x))pushall(f[x]);\n    pushdown(x);\n}\nI rotate(R x){\n    R y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];\n    if(nroot(y))c[z][c[z][1]==y]=x;f[x]=z;\n    c[x][!k]=y;f[y]=x;\n    c[y][k]=w;f[w]=y;\n    pushup(y);\n}\nI splay(R x){\n    pushall(x);\n    R y;\n    while(nroot(x)){\n        if(nroot(y=f[x]))\n            rotate((c[f[y]][0]==y)^(c[y][0]==x)?x:y);\n        rotate(x);\n    }\n    pushup(x);\n}\nI access(R x){\n    for(R y=0;x;y=x,x=f[y]=geth(f[x]))//\u6ce8\u610f\u66f4\u65b0\n        splay(x),rc=y,pushup(x);\n}\nI makeroot(R x){\n    access(x);splay(x);\n    r[x]^=1;\n}\nIS findroot(R x){\n    access(x);splay(x);\n    pushdown(x);\n    while(lc)pushdown(x=lc);\n    splay(x);\n    return x;\n}\nI split(R x,R y){\n    makeroot(y);\n    access(x);splay(x);\n}\nI del(R x,R y){//\u51fd\u6570\u9012\u5f52\u7f29\u70b9\n    if(x)h[x]=y,del(lc,y),del(rc,y);\n}\nI merge(R x,R y){\n    if(x==y)return;//\u5728\u4e00\u4e2a\u5206\u91cf\u91cc\u4ec0\u4e48\u90fd\u4e0d\u7528\u5e72\n    makeroot(x);\n    if(findroot(y)!=x){\n        f[x]=y;return;//\u7b49\u4e8elink\n    }\n    del(rc,x);\n    rc=0;pushup(x);//\u7f29\u70b9\uff0c\u5220\u70b9\n}\nint main(){\n    RG int n,m,i,j;\n    R x,y;\n    in(n);in(m);\n    for(i=1;i<=n;++i)s[i]=1,h[i]=i;\n    for(i=1;i<=m;++i){\n        in(x);in(y);\n        if(x>y)swap(x,y);//\u5f3a\u5236\u7f16\u53f7\uff0c\u65b9\u4fbf\u4ee5\u540e\u67e5\u627e\n        e[i]=(EDGE){x,y};\n    }\n    sort(e+1,e+m+1);\n    for(j=1;in(op[j]),op[j]!=131;++j){\n        in(x);in(y);\n        if(!op[j]){\n            if(x>y)swap(x,y);\n            vis[lower_bound(e+1,e+m+1,(EDGE){x,y})-e]=1;\n        }//\u91cd\u8f7d\u5b8c\u5c0f\u4e8e\u53f7\uff0c\u76f4\u63a5\u4e8c\u5206\u627e\u5230\uff0c\u518d\u6253\u4e0a\u5220\u9664\u8bb0\u53f7\n        a[j]=x;b[j]=y;\n    }\n    for(i=1;i<=m;++i)\n        if(!vis[i])merge(geth(e[i].x),geth(e[i].y));\n    for(i=0,--j;j;--j){\n        x=geth(a[j]);y=geth(b[j]);\n        if(op[j])split(x,y),ans[++i]=s[x]-1;\n        else merge(x,y);\n    }\n    while(i)printf(\"%hd\\n\",ans[i--]);\n    return 0;\n}\n```",
        "postTime": 1522065643,
        "uid": 61325,
        "name": "FlashHu",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u4e00\u53ea\u849f\u84bb\u4ecb\u7ecd\u4e00\u79cd\u53ef\u80fd\u4e0d\u592a\u96be\u60f3\u7684\u89e3\u6cd5\u3002\n\n~~\uff08\u90a3\u4e9b\u5927\u4f6c\u597d\u50cf\u90fd\u5199\u4e86\u4ec0\u4e48\u7f29\u70b9\u53cc\u8fd8\u662f\u4ec0\u4e48\u7684\uff0c\u849f\u84bb\u745f\u745f\u53d1\u6296\u554a$QAQ$\uff09~~\n\n\u4e0d\u96be\u60f3\u5230\u8981\u53cd\u5411\u5904\u7406\u3002\n\n\u7136\u540e\u9898\u76ee\u5c31\u53d8\u6210\u4e86\uff1a\u5148\u7ed9\u4e00\u4e9b\u8fb9\uff0c\u7136\u540e\u4e0d\u65ad\u52a0\u8fb9\uff0c\u6c42$x-y$\u5173\u952e\u8fb9\u6570\u91cf\u3002\n\n\u56e0\u4e3a\u53ea\u6709\u52a0\u8fb9\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b9e\u9645\u4e0a\u53ea\u6709\u5173\u952e\u8fb9\u53d8\u975e\u5173\u952e\u8fb9\uff0c\u800c\u4e0d\u5b58\u5728\u975e\u5173\u952e\u8fb9\u53d8\u6210\u5173\u952e\u8fb9\u3002\n\n\u4e0d\u96be\u53d1\u73b0\uff0c\u4e00\u6761\u8fb9\u5982\u679c\u4e3a\u5173\u952e\u8fb9\uff0c\u90a3\u4e48\u5176\u8054\u901a\u4e86\u4e24\u4e2a\u8054\u901a\u5757\uff0c\u4e14\u6ca1\u6709\u5176\u4ed6\u8fb9\u8054\u901a\u8fd9\u4e24\u4e2a\u8054\u901a\u5757\uff0c\u6240\u4ee5\u5bf9\u4e8e\u4e00\u6761\u5173\u952e\u8fb9\uff0c\u4ece\u5176\u8054\u901a\u7684\u4e24\u4e2a\u8054\u901a\u5757\u4e2d\u4efb\u610f\u4e24\u4e2a\u70b9\u5230\u5bf9\u65b9\u70b9\u7684\u8def\u5f84\u4e2d\u5176\u90fd\u4e3a\u5173\u952e\u8fb9\uff0c\u7b80\u5355\u6765\u8bb2\uff0c\u5c31\u662f **\u4e00\u6761\u5173\u952e\u8fb9\u5bf9\u4e8e\u4efb\u610f\u4e24\u4e2a\u8fc7\u5176\u7684\u70b9\u90fd\u662f\u5173\u952e\u8fb9**\n\n\u6545\u6211\u5bf9\u6bcf\u4e2a\u8fb9\u7ef4\u62a4\u4e00\u4e0b\u5176\u662f\u5426\u4e3a\u5173\u952e\u8fb9\uff0c\u5982\u679c\u662f\u5176\u8fb9\u6743\u4e3a$1$\uff0c\u5426\u5219\u5176\u8fb9\u6743\u4e3a$0$\n\n\u7531\u4e8e\u524d\u9762\u52a0\u7c97\u7684\u5b57\u4f53\u6240\u63cf\u8ff0\u7684\u4f18\u79c0\u6027\u8d28\uff0c\u6240\u4ee5\u6211\u4eec\u8be2\u95ee$x-y$\u7684\u8def\u5f84\u4e0a\u6709\u591a\u5c11\u5173\u952e\u8def\u5f84\uff0c\u5c31\u662f\u8be2\u95ee$x-y$\u7684\u8def\u5f84\u4e0a\u8fb9\u6743\u548c\n\n\u6709\u52a0\u8fb9\u64cd\u4f5c\uff0c\u6240\u4ee5\u8003\u8651\u4f7f\u7528$LCT$\uff0c\u7136\u540e\u8981\u628a\u8fb9\u62c6\u4e3a\u70b9\u3002\n\n\u73b0\u5728\u8003\u8651\u52a0\u8fb9\u600e\u4e48\u505a\uff1a\n\n\u5982\u679c\u4e00\u6761\u8fb9\u8fde\u63a5\u4e86\u4e24\u4e2a\u73b0\u5728\u672a\u8054\u901a\u7684\u70b9\uff0c\u90a3\u4e48\u76f4\u63a5\u52a0\u8fb9\uff0c\u4e14\u52a0\u5165\u7684\u8fd9\u6761\u8fb9\u663e\u7136\u662f\u4e00\u6761\u5173\u952e\u8fb9\uff0c\u5047\u8bbe\u5f53\u524d\u8fb9\u7684\u7f16\u53f7\u4e3a$Idnex$\uff0c\u90a3\u4e48$w[Idnex]=1$\u3002\n\n\u5982\u679c\u4e00\u6761\u8fde\u63a5\u4e86\u4e24\u4e2a\u5df2\u7ecf\u8054\u901a\u7684\u70b9\u5462\uff1f\n\n\u770b\u56fe\u7406\u89e3$QWQ$\n\n\u73b0\u5728\u7684\u56fe\u662f\u8fd9\u4e2a\u6837\u5b50\u7684\uff1a\n\n![](https://i.loli.net/2019/03/21/5c936c265921d.jpg)\n\n\u6211\u4eec\u52a0\u5165\u4e00\u6761\u8fd9\u6837\u7684\u8fb9\uff0c\u90a3\u4e48\u8fd9\u6761\u8fb9\u8fde\u63a5\u4e86\u4e24\u4e2a\u5df2\u7ecf\u8054\u901a\u7684\u70b9\uff0c\u5176\u663e\u7136\u662f\u4e00\u4e2a\u975e\u5173\u952e\u8fb9\u3002\n\n![](https://i.loli.net/2019/03/21/5c936c308793f.jpg)\n\n\u56fe\u4e2d\u7684\u7ea2\u8fb9\u662f\u4e00\u6761\u975e\u5173\u952e\u8fb9\u3002\n\n\u7136\u540e\u8003\u8651\u5176\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u3002\n\n\u5176\u4f1a\u5bfc\u81f4\u8fd9\u4e9b\u8fb9\u53d8\u6210\u975e\u5173\u952e\u8fb9\uff1a\n\n![](https://i.loli.net/2019/03/21/5c936c358cff7.jpg)\n\n\uff08\u56fe\u4e2d\u7eff\u8fb9\uff09\n\n\u90a3\u4e48\u6211\u4eec\u5982\u4f55\u628a\u8fd9\u4e9b\u8fb9\u6539\u6210\u975e\u5173\u952e\u8fb9\uff1f\u5c31\u662f\u8981\u5c06\u8fd9\u4e9b\u8fb9\u7684\u70b9\u6743\u6539\u4e3a0\n\n\u4e0d\u96be\u53d1\u73b0\u4e00\u6761\u8fd9\u6837\u7684\u7ea2\u8fb9\u5bf9\u7b54\u6848\u4ea7\u751f\u7684\u5f71\u54cd\u5c31\u662f\uff1a$x-y$\u7684\u8def\u5f84\u4e2d\u7684\u6240\u6709\u8fb9\u3002\n\n\u8fd9\u4e9b\u8fb9\u7684\u8fb9\u6743\u90fd\u8981\u88ab\u6539\u4e3a$0$\n\n\u6240\u4ee5\u5982\u679c\u4e00\u6761\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u8054\u901a\u5757\u5185\uff0c\u5c31\u628a\u8fd9\u4e00\u6761\u94fe\u62c9\u51fa\u6765\uff0c\u628a\u8fb9\u6743\u5168\u90e8\u8986\u76d6\u4e3a$0$\uff0c\u5c31\u64cd\u4f5c\u5982\u4e0b\uff1a\n\n\u5148$slipt(x,y)$\uff0c\u7136\u540e\u7ed9\u6253\u4e0a\u4e00\u4e2a\u8986\u76d6\u6807\u8bb0\u3002\n\n\u7ec6\u8282\u770b\u4ee3\u7801$QWQ$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint read() {\n\tchar cc = getchar(); int cn = 0, flus = 1;\n\twhile(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }\n\twhile(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();\n\treturn cn * flus;\n}\n#define ls(x) t[x].son[0]\n#define rs(x) t[x].son[1]\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define drep( i, t, s ) for( register int i = t; i >= s; -- i )\nconst int N = 200000 + 5;\nstruct LCT {\n\tint son[2], val, fa, cover;\n\tbool mark;\n}t[N];\nstruct E{\n\tint from, to, c;\n}e[N];\nmap< int, int > mc1; \nint n, m, Opt[N], From[N], To[N], tot, w[N], Idnum, ans[N], Id[N];\nvoid pushup( int x ) {\n\tt[x].val = t[ls(x)].val + t[rs(x)].val + w[x];\n}\nvoid push( int x ) { //cover\u8868\u793a\u8986\u76d6\u6807\u8bb0\uff0c\u5982\u679c\u6709\u8986\u76d6\u6807\u8bb0\uff0c\u5219\u6b64\u70b9\u7684w\u503c\u5e94\u6539\u4e3a0\uff0c\u4e14\u6574\u68f5\u5b50\u6811\u90fd\u8981\u88ab\u6539\u4e3a0 \n\t// \u6240\u4ee5\u8fd8\u8981\u4fee\u6539t[x].val = 0 \n\tw[x] = 0, t[x].cover = 1, t[x].val = 0;\n}\nvoid pushmark( int x ) {\n\tif( t[x].cover ) // \u4e0b\u4f20\u6807\u8bb0 \n\t\tt[x].cover = 0, push( ls(x) ), push( rs(x) ), t[x].val = 0;\n\tif( t[x].mark )\n\t\tt[x].mark = 0, t[ls(x)].mark ^= 1, t[rs(x)].mark ^= 1, swap( ls(x), rs(x) );\n}\nbool isroot( int x ) {\n\treturn ( rs(t[x].fa) != x ) && ( ls(t[x].fa) != x );\n}\nvoid rotate( int x ) {\n\tint f = t[x].fa, ff = t[f].fa, qwq = ( rs(f) == x );\n\tt[x].fa = ff;\n\tif( !isroot(f) ) t[ff].son[rs(ff) == f] = x;\n\tt[t[x].son[qwq ^ 1]].fa = f, t[f].son[qwq] = t[x].son[qwq ^ 1];\n\tt[x].son[qwq ^ 1] = f, t[f].fa = x;\n\tpushup(f), pushup(x);\n}\nint st[N];\nvoid Splay( int x ) {\n\tint top = 0, now = x; st[++top] = now;\n\twhile( !isroot(now) ) st[++top] = ( now = t[now].fa );\n\twhile( top ) pushmark( st[top--] );\n\twhile( !isroot(x) ) {\n\t\tint f = t[x].fa, ff = t[f].fa;\n\t\tif( !isroot(f) ) ( ( rs(ff) == f ) ^ ( rs(f) == x ) ) ? rotate(x) : rotate(f);\n\t\trotate(x);\n\t}\n}\nvoid access( int x ) {\n\tfor( int y = 0; x; y = x, x = t[y].fa ) \n\t\tSplay(x), t[x].son[1] = y, pushup(x);\n}\nvoid makeroot( int x ) {\n\taccess( x ), Splay( x ), t[x].mark ^= 1, pushmark( x );\n}\nint findroot( int x ) {\n\taccess( x ), Splay( x ), pushmark( x );\n\twhile( ls(x) ) pushmark( x = ls(x) );\n\treturn x;\n}\nvoid split( int x, int y ) {\n\tmakeroot(x), access(y), Splay(y);\n} \nvoid link( int x, int y ) {\n\tmakeroot( x );\n\tif( findroot(y) != x ) t[x].fa = y;\n}\nbool check( int x, int y ) {\n\tmakeroot( x );\n\treturn findroot(y) == x;\n}\nvoid input() {\n\tn = read(), m = read();\n\trep( i, 1, m ) {\n\t\te[i].from = read(), e[i].to = read();\n\t\tif( e[i].from > e[i].to ) swap( e[i].from, e[i].to ); //swap, \u65b9\u4fbf\u7edf\u8ba1 \n\t\tmc1[e[i].from * ( n + 1 ) + e[i].to] = i, w[i + n] = 1; //\u62c6\u8fb9\uff0c\u6bcf\u6761\u8fb9\u7684\u7f16\u53f7\u90fd\u662fi+n\uff0c\n\t\t//\u540c\u65f6\u5728map\u5185\u8bb0\u5f55\uff0c\u65b9\u4fbf\u67e5\u521d\u59cb\u6709\u90a3\u4e9b\u8fb9\u5b58\u5728 \n\t}\n\twhile( 1 ) {\n\t\tOpt[++ tot] = read(); //\u8868\u793a\u662f\u90a3\u79cd\u64cd\u4f5c \n\t\tif( Opt[tot] == -1 ) break;\n\t\tFrom[tot] = read(), To[tot] = read(); \n\t\tif( Opt[tot] == 0 ) {\n\t\t\tif( From[tot] > To[tot] ) swap( From[tot], To[tot] );\n\t\t\tId[tot] = mc1[From[tot] * ( n + 1 ) + To[tot]];\n\t\t\te[Id[tot]].c = 1; //\u6807\u8bb0\u8fd9\u6761\u8fb9\u88ab\u7528\u8fc7\u4e86 \n\t\t}\n\t}\n}\nsigned main()\n{\n\tinput(); //\u8bfb\u5165\u51fd\u6570 \n\trep( i, 1, m ) {\n\t\tif( !e[i].c ) { //\u82e5\u8fd9\u6761\u8fb9\u6ca1\u6709\u88ab\u7528\u8fc7 \n\t\t\tint u = e[i].from, v = e[i].to;\n\t\t\tif( check( u, v ) )  split( u, v ), push(v); //\u5982\u679cu\uff0cv \u5728\u4e00\u4e2a\u8054\u901a\u5757\u5185\uff0c\u5219\u62c9\u51fau\u5230v\u7684\u94fe\uff0c\u7136\u540e\u6253\u4e0a\u6807\u8bb0 \n\t\t\telse link( e[i].from, i + n ), link( i + n, e[i].to ); //\u5426\u5219\u76f4\u63a5\u8fde\u8fb9 \n\t\t}\n\t}\n\tdrep( i, tot - 1, 1 ) {\n\t\tif( Opt[i] == 0 ) { //\u5982\u679c\u662f0\uff0c\u5c31\u662f\u8fde\u8fb9\u64cd\u4f5c\uff0c\u4e0e\u524d\u9762\u7c7b\u4f3c \n\t\t\tint u = From[i], v = To[i];\n\t\t\tif( check( u, v ) )  split( From[i], To[i] ), push(To[i]);\n\t\t\telse link( From[i], Id[i] + n ), link( Id[i] + n, To[i] );\n\t\t}\n\t\tif( Opt[i] == 1 ) //\u5426\u5219\u5c31\u662f\u8be2\u95ee\uff0c\u76f4\u63a5split\u7136\u540e\u7edf\u8ba1\u7b54\u6848 \n\t\t\tsplit( From[i], To[i] ), ans[++Idnum] = t[To[i]].val;\n\t} \n\tdrep( i, Idnum, 1 ) printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1553168096,
        "uid": 30036,
        "name": "Soulist",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "# \u4e00\u4e2a\u4e0d\u7528\u6811\u94fe\u5256\u5206\u548cLCT\u7684\u9898\u89e3\n~~\u5176\u5b9e\u662f\u56e0\u4e3a\u672c\u849f\u84bb\u4e0d\u4f1a\u6811\u94fe\u5256\u5206\u548cLCT\u5624\u5624\u5624~~\n\n---\n\n* **\u524d\u534a\u90e8\u5206\u7684\u60f3\u6cd5\u548c\u6811\u94fe\u5256\u5206\u662f\u4e00\u6837\u7684**  \n\u5c06\u6240\u6709\u64cd\u4f5c\u6309\u65f6\u95f4\u53cd\u8f6c,\u5c06\u5220\u8fb9\u8f6c\u5316\u4e3a\u52a0\u8fb9\u3002  \n\u4ece\u6700\u5f00\u59cb\u7684\u56fe\u4e2d\u968f\u4fbf\u53d6\u51fa\u4e00\u68f5\u751f\u6210\u6811,\u5047\u8bbe\u6700\u5f00\u59cb\u6811\u4e0a\u6240\u6709\u8fb9\u90fd\u662f\u767d\u8fb9  \n\u6b64\u540e\u6bcf\u6dfb\u52a0\u4e00\u6761\u975e\u6811\u8fb9$(u,v)$,\u5c31\u5c06\u6811\u4e0a$u-v$\u7684\u8def\u5f84\u5168\u90e8\u67d3\u9ed1  \n\n* **\u7136\u540e\u4e0d\u96be\u53d1\u73b0,\u6bcf\u6b21\u8be2\u95ee$(u,v)$,\u5219$u-v$\u8def\u5f84\u4e0a\u7684\u767d\u8fb9\u5c31\u662f\u5173\u952e\u822a\u7ebf,$u-v$\u8def\u5f84\u4e0a\u7684\u7684\u767d\u8fb9\u6570\u91cf\u5c31\u662f\u7b54\u6848**  \n\u8def\u5f84\u67d3\u8272,\u67e5\u8be2\u8def\u5f84\u4e0a\u767d\u8fb9\u6570\u91cf,\u4e0d\u96be\u60f3\u5230\u7528\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4,\u65f6\u95f4\u590d\u6742\u5ea6$O(N\\cdot log^2N)$\n\n---\n\n* \u601d\u8003\u4e00\u4e0b\u5982\u4f55\u4e0d\u7528\u6811\u94fe\u5256\u5206  \n\u53d1\u73b0\u6bcf\u6761\u8fb9\u53ea\u7528\u88ab\u67d3\u8272\u4e00\u6b21~~\u9ed1\u7684\u67d3\u591a\u5c11\u6b21\u90fd\u662f\u9ed1\u7684~~  \n**\u4ee4\u767d\u8fb9\u7684\u8fb9\u6743\u4e3a1,\u9ed1\u8fb9\u7684\u8fb9\u6743\u4e3a0**  \n\u6bcf\u6b21\u6dfb\u52a0\u4e00\u6761\u975e\u6811\u8fb9$(u,v)$,\u5c31\u5c06$u-v$\u8def\u5f84\u4e0a\u6240\u6709\u672a\u67d3\u9ed1\u7684\u8fb9\u8fb9\u6743\u90fd-1,\u5e76\u5c06\u8fd9\u4e9b\u8fb9\u67d3\u9ed1   \n**\u8fd9\u6837\u6bcf\u6b21\u8be2\u95ee$(u,v)$\u7684\u65f6\u5019,\u7b54\u6848\u5c31\u662f$u-v$\u8def\u5f84\u7684\u8fb9\u6743\u548c**\n\n* ***\u5982\u4f55\u4fdd\u8bc1\u6bcf\u6761\u8fb9\u53ea\u88ab\u67d3\u9ed1\u4e00\u6b21\uff1f***  \n\u6bcf\u6b21\u67d3\u9ed1\u4e00\u6761\u8def\u5f84$u-v$\u7684\u65f6\u5019,\u7528\u5e76\u67e5\u96c6\u5c06\u8def\u5f84\u4e0a\u6240\u6709\u8fb9$(a,b)$\u7684$father$\u8bbe\u7f6e\u4e3a$u-v$\u7684$LCA(u-v)$\u7684$father$,\u8fd9\u6837\u4e0b\u6b21\u518d\u8bbf\u95ee\u5230$(a,b)$\u8fd9\u6761\u8fb9\u7684\u65f6\u5019,\u76f4\u63a5\u8df3\u8fc7\u8fd9\u6761\u8fb9,\u5230$LCA(u-v)$\u5904  \n**\u7531\u4e8e\u6bcf\u6761\u8fb9\u53ea\u4f1a\u88ab\u7f29\u4e00\u6b21\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u644a$O(N)$**\n* **\u6bcf\u6761\u8fb9\u7528\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\u6765\u8868\u793a**  \n\u4f8b\u5982,\u8fb9$(a,b)$\u4e2d,$a$\u4e3a$b$\u7684\u513f\u5b50  \n$(a,b)$\u7684$father$\u7528$a$\u7684$father$\u8868\u793a  \n$(a,b)$\u7684\u8fb9\u6743\u7528$a$\u7684\u70b9\u6743\u8868\u793a\n\n* **\u8fd9\u90e8\u5206\u6709\u70b9\u590d\u6742,\u8be6\u60c5\u53ef\u4ee5\u89c1\u4ee3\u7801**\n\n---\n* \u8fd8\u5269\u4e00\u4e2a\u5c0f\u95ee\u9898:\u5982\u4f55\u4e0d\u7528\u6811\u94fe\u5256\u5206\u7ef4\u62a4\u5355\u70b9\u52a0,\u8def\u5f84\u6c42\u548c  \n\u4ee4$L(u)$\u8868\u793a$u$\u5230\u6839\u7684\u8fb9\u6743\u548c  \n**$u-v$\u8def\u5f84\u7684\u8fb9\u6743\u548c\u5373\u4e3a$L(u)+L(v)-2L(LCA(u,v))$**\n\n* \u4e0d\u96be\u53d1\u73b0,\u6bcf\u6b21\u5c06\u70b9$u$\u7684\u70b9\u6743$+x$,\u5219\u5bf9\u4e8e$u$\u5b50\u6811\u4e2d\u6240\u6709\u70b9$v$,$L(v)$\u4f1a$+x$,\u5b50\u6811\u5916\u6240\u6709\u70b9$p$\u7684$L(p)$\u90fd\u4e0d\u53d8  \n\u53c8\u56e0\u4e3a,\u540c\u4e00\u68f5\u5b50\u6811\u4e2d\u7684\u70b9\u7684$DFS$\u5e8f\u662f\u8fde\u7eed\u7684  \n**\u95ee\u9898\u5c31\u8f6c\u5316\u4e3a\u4e86\u533a\u95f4\u52a0,\u5355\u70b9\u6c42\u503c**\n\n* \u5c06\u6b63\u5e38\u7684\u6811\u72b6\u6570\u7ec4\u8be2\u95ee,\u4fee\u6539\u65f6+,-\u7684\u65b9\u5411\u53cd\u8fc7\u6765,\u5c31\u5f97\u5230\u4e86  \n**\u8d44\u74f7\u533a\u95f4\u52a0,\u5355\u70b9\u6c42\u503c\u7684\u6811\u72b6\u6570\u7ec4**  \n(\u8be6\u60c5\u8bf7\u89c1\u4ee3\u7801)\n\n---\n\n**\u65f6\u95f4\u590d\u6742\u5ea6$O(N\\cdot logN)$,\u74f6\u9888\u5728\u6811\u72b6\u6570\u7ec4,\u500d\u589e$LCA$,`std::map`\u4e0a**\n\n## \u5b8c\u7ed3\u6492\u82b1~\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#define lb(x) (x&-x)//\u4e8c\u8fdb\u5236\u6700\u4f4e\u4f4d\n#define pii pair<int,int>\n#define fi first\n#define se second\nusing namespace std;\nint n,m,cnt,tme;//\u70b9\u6570,\u8fb9\u6570,\u64cd\u4f5c\u603b\u6570,DFS\u65f6\u95f4\u6233\nint hd[30009],eg[60009],nxt[60009],tot;//\u5b58\u56fe\nint dfn[30009],ed[30009],dep[30009];//\u4f9d\u6b21\u4e3a:DFS\u5e8f,\u5b50\u6811\u4e2dDFS\u5e8f\u6700\u5927\u503c,\u8282\u70b9\u6df1\u5ea6\nint c[30009];//\u6811\u72b6\u6570\u7ec4\nint fn[30009];//\u5e76\u67e5\u96c6\u6570\u7ec4\nint f[30009][16];//\u500d\u589e\u6570\u7ec4\npii e[100009],q[40009];//\u8fb9\u96c6,\u8be2\u95ee\nint del[100009],ont[100009];//\u8fb9\u662f\u5426\u88ab\u5220\u9664,\u662f\u5426\u4e3a\u751f\u6210\u6811\u4e0a\u7684\u8fb9\nint typ[40009],ans[40009];//\u8be2\u95ee\u7684\u79cd\u7c7b,\u7b54\u6848\nmap<pii,int> mp;//\u8bb0\u5f55\u8fb9\u7684\u7f16\u53f7\nvoid add(int x,int val)//\u6811\u72b6\u6570\u7ec4[1,x]\u533a\u95f4\u52a0val\n{\n    for(int i=x;i;i-=lb(i))\n        c[i]+=val;\n}\nint ask(int x)//x\u5355\u70b9\u6c42\u503c\n{\n    int ans=0;\n    for(int i=x;i<=n;i+=lb(i))\n        ans+=c[i];\n    return ans;\n}\nint fnd(int x)//\u5e76\u67e5\u96c6\n{\n    return x==fn[x]?x:fn[x]=fnd(fn[x]);\n}\nvoid ins(int a,int b)//\u52a0\u8fb9\n{\n    eg[++tot]=b;\n    nxt[tot]=hd[a];\n    hd[a]=tot;\n}\nvoid dfs(int x,int fa)\n{\n    dep[x]=dep[fa]+1;\n    ed[x]=dfn[x]=++tme;//\u6807\u8bb0DFS\u5e8f\n    f[x][0]=fa;//\u6807\u8bb0\u7236\u4eb2\n    for(int i=1;i<=15;i++)//\u9884\u5904\u7406\u500d\u589e\u6570\u7ec4\n        f[x][i]=f[f[x][i-1]][i-1];\n    for(int i=hd[x];i;i=nxt[i])\n        if(eg[i]!=fa)//\u9632\u6b62\u8fd4\u7956\u8bbf\u95ee\n        {\n            dfs(eg[i],x);\n            ed[x]=max(ed[x],ed[eg[i]]);//\u66f4\u65b0ed\n        }\n}\nint getlca(int x,int y)//\u500d\u589e\u6c42LCA\n{\n    if(dep[x]<dep[y])\n        swap(x,y);\n    int l=dep[x]-dep[y];\n    for(int i=0;i<=15;i++)\n        if(l&(1<<i))\n            x=f[x][i];\n    if(x==y)\n        return x;\n    for(int i=15;i>=0;i--)\n        if(f[x][i]!=f[y][i])\n            x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nvoid modify(int x,int y)//\u6838\u5fc3:\u5e76\u67e5\u96c6\u7f29\u70b9(\u5176\u5b9e\u548c\u6811\u94fe\u5256\u5206\u7684\u4fee\u6539\u64cd\u4f5c\u5f88\u50cf)\n{\n    int fx=fnd(x),fy=fnd(y),lca=getlca(x,y);\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])//\u4f18\u5148\u5c06\u6df1\u7684\u70b9\u5411\u4e0a\u8df3\n            swap(fx,fy);\n        if(fx!=lca)//\u5c06fx\u5230fx\u7236\u4eb2\u7684\u8fb9\u7684\u8fb9\u6743-1,\u82e5fx\u4e3aLCA\u5219\u4e0d\u7528\u4fee\u6539\n        {\n            add(ed[fx],-1);//\u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539\n            add(dfn[fx]-1,1);//\u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539\n        }\n        x=fnd(f[fx][0]);//fx\u7236\u4eb2\u6240\u5728\u96c6\u5408\u7684\u6839\n        fn[fx]=x;//\u5c06fx\u7684\u6839\u8bbe\u7f6e\u4e3afx\u7236\u4eb2\u6240\u5728\u96c6\u5408\u7684\u6839\n        fx=x;//\u7ee7\u7eed\u5411\u4e0a\u8df3\n    }\n}//\u8fd9\u91cc\u6bcf\u6761\u8fb9\u53ea\u4f1a\u88ab\u4fee\u6539\u4e00\u6b21,\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6\u5747\u644aO(N)\nint query(int x,int y)//\u8be2\u95eeu-v\u8def\u5f84\u7684\u8fb9\u6743\u548c\n{\n    return ask(dfn[x])+ask(dfn[y])-2*ask(dfn[getlca(x,y)]);\n}\nvoid init()\n{\n    for(int i=1;i<=n;i++)//\u521d\u59cb\u5316\u5e76\u67e5\u96c6\n        fn[i]=i;\n    for(int i=1;i<=m;i++)//\u5f97\u5230\u4e00\u68f5\u751f\u6210\u6811\n        if(!del[i])\n        {\n            int a=e[i].fi,b=e[i].se;\n            if(fnd(a)!=fnd(b))//\u82e5a,b\u4e0d\u8fde\u901a\n            {\n                ont[i]=1;//\u6807\u8bb0\u6811\u8fb9\n                fn[fnd(a)]=fnd(b);//\u5e76\u67e5\u96c6\u5408\u5e76\n                ins(a,b);//\u52a0\u8fb9\n                ins(b,a);//\u52a0\u8fb9\n            }\n        }\n    dfs(1,0);\n    for(int i=2;i<=n;i++)//\u5c06\u6240\u6709\u8fb9\u7684\u8fb9\u6743\u8bbe\u4e3a1\n    {\n        add(ed[i],1);//\u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539\n        add(dfn[i]-1,-1);//\u6811\u72b6\u6570\u7ec4\u533a\u95f4\u4fee\u6539\n    }\n    for(int i=1;i<=n;i++)//\u521d\u59cb\u5316\u5e76\u67e5\u96c6\n        fn[i]=i;\n    for(int i=1;i<=m;i++)//\u6dfb\u52a0\u672a\u88ab\u5220\u9664\u7684\u975e\u6811\u8fb9\n        if(!del[i]&&!ont[i])\n            modify(e[i].fi,e[i].se);\n}\nvoid solve()\n{\n    for(int i=cnt;i>=1;i--)//\u5012\u5e8f\u5904\u7406\u64cd\u4f5c\n    {\n        if(!typ[i])\n            modify(q[i].fi,q[i].se);//\u6dfb\u52a0\u975e\u6811\u8fb9\n        else\n            ans[i]=query(q[i].fi,q[i].se);//\u5904\u7406\u8be2\u95ee\n    }\n    for(int i=1;i<=cnt;i++)//\u6b63\u5e8f\u8f93\u51fa\n        if(typ[i])\n            printf(\"%d\\n\",ans[i]);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1,a,b;i<=m;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        if(a>b)\n            swap(a,b);\n        e[i]=pii(a,b);\n        mp[e[i]]=i;//\u7528map\u8bb0\u5f55\u8fb9\u7684\u7f16\u53f7\n    }\n    int c,a,b;\n    scanf(\"%d\",&c);\n    while(c!=-1)\n    {\n        scanf(\"%d%d\",&a,&b);\n        if(a>b)\n            swap(a,b);\n        q[++cnt]=pii(a,b);\n        typ[cnt]=c;//\u8bb0\u5f55\u64cd\u4f5c\u79cd\u7c7b\n        if(!c)\n            del[mp[q[cnt]]]=1;//\u8fd9\u6761\u8fb9\u5df2\u88ab\u5220\u9664\n        scanf(\"%d\",&c);\n    }\n    init();\n    solve();\n    return 0;\n}\n```",
        "postTime": 1549536248,
        "uid": 31988,
        "name": "cppascalinux",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u8fd9\u662f\u849f\u84bb\u56fd\u5e86\u96c6\u8bad\u65f6\u542c\u7684\u9898\uff0c\u8bb2\u8bfe\u7684\u5de8\u4f6c\u53ea\u7ed9\u4e86\u601d\u8def\uff0c\u5927\u81f4\u5982\u4e0b\uff1a\n\n1\u3001\u73af\u4e0a\u7684\u8fb9\u4e00\u5b9a\u4e0d\u662f\u5173\u952e\u8fb9\u3002\n\n2\u3001\u65f6\u95f4\u53cd\u6f14\uff0c\u9006\u5411\u5904\u7406\u64cd\u4f5c\uff0c\u53d8\u6210\u63d2\u5165\u8fb9\u548c\u8be2\u95ee\u3002\n\n3\u3001\u641e\u51fa\u6765\u4e00\u68f5\u6811\u3002\n\n4\u3001\u5904\u7406\u64cd\u4f5c\uff0c\u5982\u679c\u6211\u4eec\u5728v[i]\u548cu[i]\u4e4b\u95f4\u52a0\u5165\u4e86\u4e00\u6761\u8fb9\uff0c\u90a3\u4e48\u6811\u4e0av[i]\u5230u[i]\u4e4b\u95f4\u7684\u6240\u6709\u8fb9\u90fd\u6807\u8bb0\u4e3a\u4e0d\u662f\u5173\u952e\u8fb9\u3002\u8be2\u95ee\uff0c\u5c31\u662f\u770b\u6811\u4e0av[i]\u5230u[i]\u7684\u8def\u5f84\u4e0a\u6709\u591a\u5c11\u6761\u8fb9\u8fd8\u6ca1\u6709\u88ab\u6807\u8bb0\u3002\u7528\u6811\u5256\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u4ee5\u4e0a\uff0c\u548c\u5176\u4ed6\u53d1\u9898\u89e3\u7684\u5927\u4f6c\u7684\u601d\u8def\u90fd\u662f\u5dee\u4e0d\u591a\u7684\u3002\u849f\u84bb\u8fd9\u91cc\u4e3b\u8981\u662f\u8bf4\u4e00\u4e9b\u7ec6\u8282\uff0c\u81ea\u5df1\u9519\u8bef\u7684\u5730\u65b9\uff08\u81ea\u5df1\u6539\u5f97\u5feb\u8981\u5d29\u6e83\u7684\u65f6\u5019\u5c31\u5e0c\u671b\u6709\u8fd9\u6837\u7684\u63d0\u793a\u554a\uff09\n\n1\u3001\u6211\u7b2c\u4e00\u6b21\u63d0\u4ea4\u5c31MLE\u4e86\u3002MLE\u4e00\u822c\u5c31\u662f\u4e24\u79cd\uff1a\u6570\u7ec4\u8fc7\u5927\uff08\u8fd9\u9898\u663e\u7136\u4e0d\u662f\uff09\uff0c\u6b7b\u5faa\u73af/\u65e0\u9650\u9012\u5f52\u5bfc\u81f4\u7206\u6808\u3002\u6211\u81ea\u5df1\u7684\u60c5\u51b5\u662f\u51fa\u5728\u641e\u51fa\u4e00\u9897\u6811\uff0c\u4e5f\u5373\u6811\u5256\u7684\u7b2c\u4e00\u6b21dfs\u7684\u65f6\u5019\u3002\n\n\u5206\u6790\uff1a\u9898\u76ee\u4e2d\u7ed9\u4e86m\u6761\u8fb9\uff0c\u7136\u540e\u5220\u53bb\u4e86\u82e5\u5e72\u6761\u3002\u6211\u4eec\u8981\u65f6\u95f4\u53cd\u6f14\uff0c\u628a\u4ed6\u4eec\u90fd\u5220\u6389\uff0c\u518d\u52a0\u56de\u6765\u3002**\u90fd\u5220\u6389\u4ee5\u540e\uff0c\u5269\u4e0b\u7684\u8fb9\u80af\u5b9a\u662f\u591a\u4e8en-1\u6761\u7684\u3002\u4f46\u6211\u76f4\u63a5\u9ed8\u8ba4\u5269\u4e0b\u521a\u597d\u662f\u4e00\u9897\u6811\uff0c\u76f4\u63a5dfs\uff0c\u4e8e\u662f\u6b7b\u5faa\u73af\u3002**\uff08\u4e3a\u5565\u662fMLE\u800c\u4e0d\u662fTLE\u5462\uff1f\u6211\u4e5f\u4e0d\u77e5\u9053\uff09\n\n\u6539\u6b63\uff1a\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002\n\n2\u3001\u7136\u540e\u5c31WA\u4e86\u3002\u5b9e\u5728\u6539\u4e0d\u51fa\u6765\uff0c\u4e8e\u662f\u53c2\u8003\u9898\u89e3\uff0c\u624d\u53d1\u73b0\u548c\u4e0a\u4e00\u4e2a\u9519\u56e0\u4e00\u6a21\u4e00\u6837\u3002\n\n\u5206\u6790\uff1a\u6211\u8fd8\u662f\u9ed8\u8ba4\u5269\u4e0b\u662f\u4e00\u9897\u6811\uff08\u600e\u4e48\u4f1a\u6709\u8fd9\u4e48\u8822\u7684\u4eba\uff09\uff0c\u76f8\u5f53\u4e8e\u591a\u5220\u53bb\u4e86\u5f88\u591a\u8fb9\u3002\u8fd9\u4e9b**\u88ab\u6211\u8bef\u5220\u7684\u8fb9\uff0c\u5168\u90e8\u90fd\u8981\u52a0\u56de\u6765**\uff0c\u5373\u662fdfs3\u3002\n\n\u6539\u6b63\uff1a\u89c1\u4ee3\u7801\u6ce8\u91ca\u3002\n\n~~\u5176\u5b9eWA\u4e86\u5341\u591a\u904d\u8fd9\u79cd\u4e8b\u600e\u4e48\u53ef\u80fd\u544a\u8bc9\u522b\u4eba\u5462~~\uff0c\u5404\u79cd\u7a00\u5947\u53e4\u602a\u7684\u95ee\u9898\uff0c\u4e3b\u8981\u5728\u662f\u641e\u51fa\u4e00\u9897\u6811\u65f6\uff0c\u8fd9\u4e00\u70b9\u6211\u7684\u601d\u8def\u4e00\u5f00\u59cb\u5c31\u662f\u9519\u7684\n\nAC code\uff1a\n```\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rint register int\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\ntypedef long long ll;\nconst int N=40000+10,M=100000+10;\nint n,m,a,b,x,y,z,bnt,cnt,dnt,tot;\nint ans[N],head[N],siz[N],fa[N],dep[N],son[N],id[N],top[N],tr[N<<2],lazy[N<<2];\nstruct node\n{\n\tint op,a,b;\n}q[N];\nstruct mode\n{\n\tint v,next,des;\n}e[M<<1];\ninline void adde(int u,int v)\n{\n\te[++cnt]=(mode){v,head[u]};\n\thead[u]=cnt;\n}\ninline void read(int &x)\n{\n\tx=0;\n\tint f=1;\n\tchar s=getchar();\n\twhile(s<'0'||s>'9')\n\t{\n\t\tif(s=='-')\n\t\t\tf=-1;\n\t\ts=getchar();\n\t}\n\twhile(s>='0'&&s<='9')\n\t{\n\t\tx=(x<<1)+(x<<3)+s-'0';\n\t\ts=getchar();\n\t}\n\tx*=f;\n}\ninline void pushup(int rt)\n{\n\ttr[rt]=tr[rt<<1]+tr[rt<<1|1];\n}\ninline void pushdown(int rt)\n{\n\tlazy[rt<<1]=lazy[rt<<1|1]=1;\n\ttr[rt<<1]=tr[rt<<1|1]=lazy[rt]=0;\n}\nvoid build(int l,int r,int rt)\n{\n\tif(l==r)\n\t{\n\t\ttr[rt]=1;\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\nvoid update(int L,int R,int l,int r,int rt)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\ttr[rt]=0,lazy[rt]=1;\n\t\treturn;\n\t}\n\tif(lazy[rt])\n\t\tpushdown(rt);\n\tint m=(l+r)>>1;\n\tif(L<=m)\n\t\tupdate(L,R,lson);\n\tif(m<R)\n\t\tupdate(L,R,rson);\n\tpushup(rt);\n}\nint query(int L,int R,int l,int r,int rt)\n{\n\tif(L<=l&&r<=R)\n\t\treturn tr[rt];\n\tif(lazy[rt])\n\t\tpushdown(rt);\n\tint m=(l+r)>>1,sum=0;\n\tif(L<=m)\n\t\tsum+=query(L,R,lson);\n\tif(m<R)\n\t\tsum+=query(L,R,rson);\n\treturn sum;\n}\nvoid dfs1(int u,int va)\n{\n\tfa[u]=va;\n\tsiz[u]=1;\n\tdep[u]=dep[va]+1;\n\tfor(rint i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(siz[v]||e[i].des)//\u6539\u8fdb1\uff1a\u5982\u679csiz[v]\u4e0d\u4e3a0\uff0c\u5219v\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\u4e86\uff08\u76f8\u5f53\u4e8e\u4e00\u4e2avis\u6570\u7ec4\u7684\u529f\u80fd\uff09 \n\t\t\tcontinue;\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[son[u]]<siz[v])\n\t\t\tson[u]=v;\n\t}\n}\nvoid dfs2(int u,int anc)\n{\n\tid[u]=++bnt;\n\ttop[u]=anc;\n\tif(!son[u])\n\t\treturn;\n\tdfs2(son[u],anc);\n\tfor(rint i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(fa[v]!=u||v==son[u]||e[i].des)\n\t\t\tcontinue;\n\t\tdfs2(v,v);\n\t}\n}\ninline void mark(int a,int b)\n{\n\twhile(top[a]!=top[b])\n\t{\n\t\tif(dep[top[a]]<dep[top[b]])\n\t\t\tswap(a,b);\n\t\tupdate(id[top[a]],id[a],1,n,1);\n\t\ta=fa[top[a]];\n\t}\n\tif(dep[a]<dep[b])\n\t\tswap(a,b);\n\tupdate(id[b]+1,id[a],1,n,1);\n}\nvoid dfs3(int u)//\u6539\u8fdb2\uff1a\u88ab\u8bef\u5220\u7684\u8fb9\uff0c\u518d\u65f6\u95f4\u53cd\u6f14\u4e4b\u524d\u5168\u90e8\u8865\u56de\u6765 \n{\n\tfor(rint i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(e[i].des)\n\t\t\tcontinue;\n\t\tif(fa[v]==u)\n\t\t\tdfs3(v);\n\t\telse\n\t\t\tif(dep[u]<dep[v])\n\t\t\t\tmark(u,v);\n\t}\n}\nint main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tread(n),read(m);\n\tmemset(head,-1,sizeof head);\n\tfor(rint i=1;i<=m;++i)\n\t{\n\t\tread(a),read(b);\n\t\tadde(a,b),adde(b,a);\n\t}\n\tfor(;;)\n\t{\n\t\tread(x);\n\t\tif(x==-1)\n\t\t\tbreak;\n\t\tread(y),read(z);\n\t\tq[++dnt]=(node){x,y,z};\n\t\tif(x)\n\t\t\tcontinue;\n\t\tfor(rint i=head[y];~i;i=e[i].next)\n\t\t\tif(e[i].v==z)\n\t\t\t{\n\t\t\t\te[i].des=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(rint i=head[z];~i;i=e[i].next)\n\t\t\tif(e[i].v==y)\n\t\t\t{\n\t\t\t\te[i].des=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tbuild(1,n,1);\n\tdfs3(1);\n\tfor(rint i=dnt;i>=1;--i)\n\t{\n\t\ta=q[i].a,b=q[i].b;\n\t\tif(!q[i].op)\n\t\t\tmark(a,b),ans[i]=-1;\n\t\telse\n\t\t{\n\t\t\twhile(top[a]!=top[b])\n\t\t\t{\n\t\t\t\tif(dep[top[a]]<dep[top[b]])\n\t\t\t\t\tswap(a,b);\n\t\t\t\tans[i]+=query(id[top[a]],id[a],1,n,1);\n\t\t\t\ta=fa[top[a]];\n\t\t\t}\n\t\t\tif(dep[a]<dep[b])\n\t\t\t\tswap(a,b);\n\t\t\tans[i]+=query(id[b]+1,id[a],1,n,1); \n\t\t}\n\t}\n\tfor(rint i=1;i<=dnt;++i)\n\t\tif(ans[i]!=-1)\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```\n",
        "postTime": 1570197888,
        "uid": 115615,
        "name": "Haworthia",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206+\u79bb\u7ebf\u6811\u8f6c\u56fe\n\u89c2\u5bdf\u9898\u9762,\u6211\u4eec\u53d1\u73b0\u5173\u952e\u8fb9\u5c31\u662f\u6865,\u5982\u679c\u6ca1\u6709\u5220\u8fb9\u64cd\u4f5c,\u5c31\u662f\u4e00\u9053tarjan\u88f8\u9898\u4e86\u3002\u867d\u7136\u6211\u4eec\u53ef\u4ee5\u4e00\u8fb9\u5220\u8fb9\u4e00\u8fb9\u66f4\u65b0tarjan,\u4f46\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u8be5\u8fc7\u4e0d\u4e86\u3002\u6240\u4ee5\u6211\u4eec\u8981\u6362\u4e00\u79cd\u601d\u8def\u3002\n\n\u6211\u4eec\u6ce8\u610f\u5230\u9898\u4e2d\u4e00\u53e5\u8bdd:\"\u4fdd\u8bc1\u8054\u901a\"\u3002\u5982\u679c\u6211\u4eec\u4e0d\u65ad\u5220\u8fb9,\u53c8\u4fdd\u8bc1\u8054\u901a,\u90a3\u4e48\u6574\u5f20\u56fe\u6700\u540e\u4f1a\u53d8\u6210\u4ec0\u4e48\u6837\u5462?\u660e\u663e\u4f1a\u53d8\u6210\u4e00\u68f5\u6811\u3002\u6811\u5c31\u662f\u597d\u4e1c\u897f\u4e86,\u5f88\u591a\u6570\u636e\u7ed3\u6784\u90fd\u80fd\u5728\u6811\u4e0a\u7528\u3002\u800c\u4e14\u6211\u4eec\u53d1\u73b0\u6811\u4e0a\u7684\u8fb9\u90fd\u662f\u5173\u952e\u8fb9,,\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5148\u5efa\u4e00\u68f5\u6811,\u518d\u5728\u6811\u4e0a\u52a0\u8fb9\u5efa\u56fe\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u660e\u663e\u53d1\u73b0,\u53ea\u8981\u5728\u6811\u4e0a\u4efb\u610f\u4e24\u70b9\u4e4b\u95f4\u52a0\u4e86\u4e00\u6761\u8fb9\u5c31\u4f1a\u5f62\u6210\u4e00\u4e2a\u73af,\u800c\u5bf9\u4e8e\u73af\u4e0a\u7684\u8fb9\u663e\u7136\u90fd\u4e0d\u4f1a\u662f\u5173\u952e\u8fb9\u3002\u56e0\u4e3a\u6811\u4e0a\u4e24\u70b9\u95f4\u8def\u5f84\u786e\u5b9a,\u5f62\u6210\u73af\u540e\u8be5\u8def\u5f84\u4e0a\u6240\u6709\u8fb9\u5c31\u90fd\u4e0d\u4e3a\u5173\u952e\u8fb9\u4e86,\u6240\u4ee5\u81ea\u7136\u60f3\u5230\u5c06\u6574\u68f5\u6811\u7684\u8fb9\u6743\u7f6e\u4e3a1,\u6bcf\u6b21\u5bf9\u4e8e(u,v)\u52a0\u8fb9\u5c31\u5c06u\u5230v\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8fb9\u8fb9\u6743\u6539\u4e3a0\u3002\n\n\u8fb9\u6743\u8f6c\u70b9\u6743,\u6811\u94fe\u5256\u5206\u5b9e\u73b0\u3002\u67e5\u8be2\u5c31\u76f4\u63a5\u67e5\u8be2u\u5230v\u8def\u5f84\u4e0a\u8fd8\u6709\u591a\u5c11\u8fb9\u8fb9\u6743\u4e3a1\u5c31\u884c\u4e86\u3002\n\n\u7136\u540e\u5c31\u662f\u5220\u8fb9\u64cd\u4f5c,\u5220\u6389\u4e00\u6761\u8fb9\u53c8\u4fdd\u8bc1\u8054\u901a,\u663e\u7136\u53ea\u80fd\u5220\u73af\u4e0a\u7684\u8fb9,\u5373\u6bcf\u6b21\u5220\u8fb9\u540e\u5173\u952e\u8fb9\u6570\u91cf\u4e00\u5b9a\u4e0d\u51cf,(\u5047\u8bbe\u5220\u8fb9(u,v))\u82e5\u6211\u4eec\u6bcf\u6b21\u5728u\u5230v\u7684\u8def\u5f84\u4e0a\u52a01,\u663e\u7136\u65e0\u6cd5\u6700\u4f18,\u56e0\u4e3a\u5bf9\u4e8eu\u5230v\u8def\u5f84\u4e0a\u7684\u8fb9,\u4e0d\u4e00\u5b9a\u5220\u6389(u,v)\u8fd9\u6761\u8fb9\u5c31\u4e00\u5b9a\u4f1a\u8ba9\u5b83\u53d8\u6210\u5173\u952e\u8fb9,\u6709\u53ef\u80fd\u5b83\u8fd8\u5c5e\u4e8e\u522b\u7684\u73af\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u53cd\u5411\u8003\u8651,\u6240\u6709\u8981\u5220\u6389\u7684\u8fb9\u90fd\u5148\u4e0d\u52a0,\u76f8\u5f53\u4e8e\u9ed8\u8ba4\u5168\u90e8\u5220\u5b8c\u4e86,\u5012\u5e8f\u67e5\u8be2\u8be2\u95ee\u540e\u518d\u4e00\u6761\u4e00\u6761\u52a0\u56de\u53bb,\u8fd9\u6837\u5c31\u53ef\u4ee5\u907f\u514d\u5220\u8fb9\u64cd\u4f5c\u4e86\u3002\n\n\u79bb\u7ebf\u6240\u6709\u64cd\u4f5c\u518d\u5012\u5e8f\u5b9e\u73b0\u3002\n\n\u5f53\u7136\u5220\u8fb9\u5e76\u4e0d\u4e00\u5b9a\u4f1a\u65ad\u6389\u6240\u6709\u73af,\u8fd8\u6709\u7684\u8fb9\u8fde\u5728\u6811\u4e0a\u5f62\u6210\u73af\u3002\u6240\u4ee5\u5728\u5efa\u6811\u65f6\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u4fdd\u8bc1\u53ea\u5efa\u51fa\u4e00\u68f5\u6811,\u518d\u628a\u6ca1\u52a0\u4f46\u672a\u6765\u4e0d\u4f1a\u5220\u6389\u7684\u8fb9\u7528\u6210\u73af\u60c5\u51b5\u5904\u7406\u3002\n\n\u4ee3\u7801\u5b9e\u73b0\u7ec6\u8282\u89c1\u4ee3\u7801\u3002\n```cpp\n#include <map>\n#include <stack>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define ll long long\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar();\n\tint f=1,x=0;\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nstruct edge{\n\tint v,next;\n}e[60001];\nstruct node{\n\tint t,a,b;\n}dt[40001];//\u5b58\u67e5\u8be2,\u5220\u8fb9\u64cd\u4f5c\nint cnt,tot,head[30001],dep[30001],fa[30001],siz[30001],son[30001],top[30001],id[30001],dfn[30001],low[30001],x[100001],y[100001],add[120005],sum[120005];\nbool vis[100001];//\u8bb0\u5f55\u8fb9\u662f\u5426\u5728\u6811\u4e2d\nmap<pair<int,int>,bool> ma;//\u8bb0\u5f55u\u5230v\u7684\u8fb9\u4f1a\u4e0d\u4f1a\u5220\ninline void adde(int u,int v)\n{\n\te[++cnt]=(edge){v,head[u]};\n\thead[u]=cnt;\n}\ninline int findf(int x)\n{\n\treturn fa[x]==x?x:fa[x]=findf(fa[x]);\n}\ninline void find(int u)//\u6811\u5256\u6a21\u677f\u4e0d\u89e3\u91ca\n{\n\tsiz[u]=1;\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v!=fa[u])\n\t\t{\n\t\t\tfa[v]=u;\n\t\t\tdep[v]=dep[u]+1;\n\t\t\tfind(v);\n\t\t\tsiz[u]+=siz[v];\n\t\t\tif(siz[v]>siz[son[u]])son[u]=v;\n\t\t}\n\t}\n}\ninline void dfs(int u,int fat)\n{\n\ttop[u]=fat;\n\tid[dfn[u]=++tot]=u;\n\tif(son[u])dfs(son[u],fat);\n\tfor(int i=head[u];~i;i=e[i].next)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v!=son[u]&&v!=fa[u])dfs(v,v);\n\t}\n\tlow[u]=tot;\n}\ninline void pushup(int rt)\n{\n\tsum[rt]=sum[rt<<1]+sum[rt<<1|1];\n}\ninline void pushdown(int rt,int m)\n{\n\tif(~add[rt])\n\t{\n\t\tadd[rt<<1]=add[rt<<1|1]=add[rt];\n\t\tsum[rt<<1]=add[rt]*(m-(m>>1));\n\t\tsum[rt<<1|1]=add[rt]*(m>>1);\n\t\tadd[rt]=-1;\n\t}\n}\ninline void build(int l,int r,int rt)//\u7ebf\u6bb5\u6811\u521d\u59cb\u8d4b\u503c\u5168\u4e3a1\n{\n\tadd[rt]=-1;\n\tif(l==r)\n\t{\n\t\tsum[rt]=1;\n\t\treturn;\n\t}\n\tint m=l+r>>1;\n\tbuild(lson);\n\tbuild(rson);\n\tpushup(rt);\n}\ninline void update(int L,int R,int c,int l,int r,int rt)//\u7ebf\u6bb5\u6811\u8981\u5efa\u6210\u533a\u95f4\u8d4b\u503c\u7684\u7c7b\u578b\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\tadd[rt]=c;\n\t\tsum[rt]=c*(r-l+1);\n\t\treturn;\n\t}\n\tpushdown(rt,r-l+1);\n\tint m=l+r>>1;\n\tif(L<=m)update(L,R,c,lson);\n\tif(m<R)update(L,R,c,rson);\n\tpushup(rt);\n}\ninline int query(int L,int R,int l,int r,int rt)//\u7ebf\u6bb5\u6811\u67e5\u8be2\u4e0d\u89e3\u91ca\n{\n\tif(L<=l&&r<=R)return sum[rt];\n\tpushdown(rt,r-l+1);\n\tint m=l+r>>1,ret=0;\n\tif(L<=m)ret+=query(L,R,lson);\n\tif(m<R)ret+=query(L,R,rson);\n\treturn ret;\n}\nint main()\n{\n\tmemset(head,-1,sizeof head);\n\tint n=read(),m=read();\n\tfor(int i=1;i<=m;++i)//\u8bb0\u8fb9\n\t{\n\t\tx[i]=read();\n\t\ty[i]=read();\n\t}\n\tint tim=0;\n\twhile(1)//\u79bb\u7ebf \u5904\u7406\n\t{\n\t\tint t=read();\n\t\tif(!(~t))break;\n\t\tint a=read(),b=read();\n\t\tdt[++tim]=(node){t,a,b};\n\t\tif(!t)ma[make_pair(a,b)]=ma[make_pair(b,a)]=1;//\u8981\u5220\u6389\u7684\u8fb9\u5148\u4e0d\u5efa\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfa[i]=i;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint u=findf(x[i]),v=findf(y[i]);\n\t\tif(!ma[make_pair(x[i],y[i])]&&fa[u]!=v)//\u5efa\u6811,\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u662f\u5426\u6210\u6811\n\t\t{\n\t\t\tfa[u]=v;\n\t\t\tadde(x[i],y[i]);\n\t\t\tadde(y[i],x[i]);\n\t\t\tvis[i]=1;//\u8bb0\u5f55\u8fb9\u5df2\u52a0\u5165\n\t\t}//\u8fd9\u6837\u5efa\u6811\u5c31\u4f1a\u4fdd\u8bc1\u53ea\u751f\u6210\u4e00\u68f5\u6811,\u4e4b\u540e\u5c31\u53ef\u4ee5\u76f4\u63a5\u52a0\u8fb9\u6210\u73af,\u4e0d\u9700\u8981\u50cf\u5176\u4ed6\u7684\u505a\u6cd5\u4e00\u6837\u4fee\u6539\u6811\u5256\u7684dfs\u5904\u548cdfs3\u6b21\u3002\n\t}\n\tmemset(fa,0,sizeof fa);\n\tfind(1);\n\tdfs(1,1);\n\tbuild(1,n,1);\n\tfor(int i=1;i<=m;++i)\n\t\tif(!vis[i]&&!ma[make_pair(x[i],y[i])])//\u8fb9\u672a\u52a0\u5165\u6811\u4e2d\u4e14\u672a\u6765\u4e0d\u4f1a\u88ab\u5220\u52a0\u5165\u56fe\u4e2d\u6210\u73af\u5904\u7406\n\t\t{\n\t\t\tint a=x[i],b=y[i];\n\t\t\twhile(top[a]!=top[b])\n\t\t\t{\n\t\t\t\tif(dep[top[a]]>dep[top[b]])swap(a,b);\n\t\t\t\tupdate(dfn[top[b]],dfn[b],0,1,tot,1);\n\t\t\t\tb=fa[top[b]];\n\t\t\t}\n\t\t\tif(dep[a]>dep[b])swap(a,b);\n\t\t\tupdate(dfn[a]+1,dfn[b],0,1,tot,1);\n\t\t}\n\tstack<int> q;\n\tfor(int i=tim;i;--i)//\u5012\u5e8f\u5904\u7406\u64cd\u4f5c\n\t{\n\t\tint ans=0,t=dt[i].t,a=dt[i].a,b=dt[i].b;\n\t\twhile(top[a]!=top[b])\n\t\t{\n\t\t\tif(dep[top[a]]>dep[top[b]])swap(a,b);\n\t\t\tif(t)ans+=query(dfn[top[b]],dfn[b],1,tot,1);\n\t\t\telse update(dfn[top[b]],dfn[b],0,1,tot,1);\n\t\t\tb=fa[top[b]];\n\t\t}\n\t\tif(dep[a]>dep[b])swap(a,b);\n\t\tif(t)q.push(ans+query(dfn[a]+1,dfn[b],1,tot,1));\n\t\telse update(dfn[a]+1,dfn[b],0,1,tot,1);\n\t}\n\twhile(!q.empty())//\u56e0\u4e3a\u662f\u5012\u5e8f\u5904\u7406\u64cd\u4f5c,\u6240\u4ee5\u7b54\u6848\u8981\u5012\u5e8f\u8f93\u51fa\n\t{\n\t\tprintf(\"%d\\n\",q.top());\n\t\tq.pop();\n\t}\n    return 0;\n}\n```\n~~\u6211\u662f\u849f\u84bb~~",
        "postTime": 1570844732,
        "uid": 116113,
        "name": "Lucifer_Bartholomew",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "## \u3010LCT\u3011\u3010P2542\u3011 [AHOI2005] \u822a\u7ebf\u89c4\u5212\n\n### Analysis\n\n\u56fe\u8bba\u5f31\u9e21\u4e5f\u4e0d\u77e5\u9053\u5565\u53eb\u53cc\u8fde\u901a\u5206\u91cf\u2026\u2026\u5c31\u53ea\u80fd LCT \u4e71\u641e\u4e00\u4e0b\u5b50\u8fd9\u6837\u5b50\u3002\n\n\u9996\u5148\u6839\u636e\u5957\u8def\uff0c\u5220\u8fb9\u4e0d\u597d\u505a\uff0c\u90a3\u5c31\u53cd\u8fc7\u6765\u53d8\u6210\u52a0\u8fb9\u3002\n\n\u6ce8\u610f\u5230\u4e00\u4e2a\u6027\u8d28\uff0c\u5bf9\u4e8e\u4e00\u6761\u8fb9 $(u, v)$ \u548c\u4e00\u4e2a\u8be2\u95ee $(x, y)$ \u4ee5\u53ca\u5f53\u524d\u56fe\u4efb\u610f\u4e00\u4e2a\u751f\u6210\u6811\uff0c\u5982\u679c $(u, v)$ \u662f $(x, y)$ \u95f4\u7684\u5173\u952e\u8fb9\uff0c\u90a3\u4e48\u8fb9 $(u, v)$ \u4e00\u5b9a\u5728\u8fd9\u4e2a\u751f\u6210\u6811\u4e0a\u3002\u800c\u5f53\u56fe\u672c\u8eab\u662f\u4e00\u68f5\u6811\u65f6\uff0c\u6811\u4e0a\u6bcf\u6761\u8fb9\u90fd\u662f\u5173\u952e\u8fb9\u3002\n\n\u8003\u8651\u4ece\u56fe\u7684\u4efb\u610f\u4e00\u68f5\u751f\u6210\u6811\u5f00\u59cb\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u52a0\u8fb9\u7ef4\u62a4\u4e24\u70b9\u95f4\u6709\u591a\u5c11\u5173\u952e\u8fb9\u3002\u6ce8\u610f\u5230\u52a0\u5165\u4e00\u6761\u8fb9 $(u, v)$ \u4ee5\u540e\uff0c\u539f\u6765\u6811\u4e0a $(u, v)$ \u95f4\u7684\u8def\u5f84\u4e0e\u65b0\u8fb9\u4ea7\u751f\u4e86\u4e00\u4e2a\u73af\u3002\u90a3\u4e48\u8fd9\u4e2a\u73af\u4e0a\u7684\u6240\u6709\u8fb9\u90fd\u4e0d\u53ef\u80fd\u4f5c\u4e3a\u5173\u952e\u8fb9\u4e86\uff0c\u800c\u65b0\u52a0\u5165\u7684\u8fb9\u5bf9\u5176\u4ed6\u4e0d\u5728\u73af\u4e0a\u7684\u8fb9\u5747\u65e0\u5f71\u54cd\u3002\u56e0\u6b64\u6211\u4eec\u8003\u8651\u66b4\u529b\u7684\u628a\u8fd9\u4e2a\u73af\u5220\u6389\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\u4ee3\u8868\u8fd9\u4e2a\u5927\u73af\uff0c\u628a\u4ee5\u524d\u4e0e\u73af\u4e0a\u70b9\u76f8\u8fde\u7684\u8fb9\u90fd\u8fde\u63a5\u5230\u65b0\u8282\u70b9\u4e0a\uff0c\u6bcf\u4e2a\u8282\u70b9\u5c5e\u4e8e\u54ea\u4e2a\u73af\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u6211\u4eec\u7ef4\u62a4\u7684\u56fe\u4e00\u5b9a\u662f\u4e00\u68f5\u6811\uff0c\u800c\u4e14\u6811\u4e0a\u6709\u4e14\u4ec5\u6709\u5173\u952e\u8fb9\u3002\u5bf9\u4e8e\u4e00\u6b21\u67e5\u8be2 $(u, v)$\uff0c\u53ea\u9700\u8981\u67e5\u8be2 $u$ \u6240\u5c5e\u7684\u73af\u4e0e $v$ \u6240\u5c5e\u7684\u73af\u7684\u8def\u5f84\u4e0a\u6709\u591a\u6570\u5173\u952e\u8fb9\u5373\u53ef\u3002\n\n\u52a0\u8fb9\uff0c\u5220\u8fb9\uff0c\u7ef4\u62a4\u94fe\u4fe1\u606f\uff0c\u53ef\u4ee5\u7528 LCT \u6765\u5904\u7406\u3002\u8003\u8651\u5f53\u5220\u9664\u6811\u4e0a\u4e00\u6761\u94fe\u65f6\uff08\u88ab\u5220\u9664\u7684\u73af\u53bb\u6389\u65b0\u52a0\u7684\u8fb9\u5728\u6811\u4e0a\u662f\u4e00\u6761\u94fe\uff09\uff0c\u4f1a\u6709\u5f88\u591a\u8282\u70b9\u7684\u7236\u4eb2\u4f5c\u4e3a\u865a\u8fb9\u6307\u5411\u73af\u4e0a\u7684\u8282\u70b9\u3002\u6211\u4eec\u5bf9\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a lnk \u6307\u9488\uff0c\u5982\u679c\u8be5\u6307\u9488\u4e0d\u4e3a\u7a7a\uff0c\u5219\u8868\u793a\u5f53\u524d\u8282\u70b9\u5df2\u88ab\u5220\u9664\uff0c\u65b0\u5efa\u8282\u70b9\u4e3a lnk \u6307\u5411\u7684\u8282\u70b9\u3002\u5728\u5bf9\u4e00\u4e2a\u8282\u70b9\u8fdb\u884c\u4efb\u4f55\u64cd\u4f5c\u65f6\uff0c\u5148\u5c06\u8be5\u8282\u70b9\u7684\u7236\u4eb2\u901a\u8fc7\u4e0d\u65ad\u8df3 lnk \u7684\u65b9\u5f0f\u8df3\u5230\u771f\u6b63\u7684\u7236\u4eb2\u4e0a\u53bb\uff0c\u7136\u540e\u8fdb\u884c LCT \u7684\u64cd\u4f5c\u5373\u53ef\u3002\n\n\u8003\u8651\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u6bcf\u4e2a\u8282\u70b9\u53ea\u4f1a\u88ab\u5220\u9664\u4e00\u6b21\uff0c\u56e0\u6b64\u66b4\u529b\u5220\u9664\u662f\u5747\u644a $O(1)$ \u7684\uff1bLCT \u7684\u5404\u79cd\u64cd\u4f5c\u662f\u5747\u644a $O(\\log n)$ \u7684\uff0c\u8df3 lnk \u7684\u8fc7\u7a0b\u4e0e\u8fdb\u884c\u4e86\u8def\u5f84\u538b\u7f29\u7684\u5e76\u67e5\u96c6\u7684\u8fc7\u7a0b\u662f\u4e00\u81f4\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u540c\u6837\u7684\u65b9\u5f0f\u8bc1\u660e\u8fd9\u90e8\u5206\u7684\u590d\u6742\u5ea6\u4e5f\u662f\u5747\u644a $O(\\log n)$ \u7684\u3002\u56e0\u6b64\u5355\u6b21\u64cd\u4f5c\u7684\u5747\u644a\u590d\u6742\u5ea6\u662f $O(\\log n)$\u3002\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(c \\log n)$\uff0c\u5176\u4e2d $c$ \u662f\u64cd\u4f5c\u6b21\u6570\u3002\n\n\u5728\u5b9e\u73b0\u65f6\uff0c\u53ef\u4ee5\u53d1\u73b0\u5728\u5bf9\u4e8e\u4e00\u4e2a\u8282\u70b9\u505a\u4efb\u4f55\u64cd\u4f5c\u4e4b\u524d\u4e00\u5b9a\u4f1a\u5c06\u8be5\u8282\u70b9\u8f6c\u5230 splay \u7684\u6839\u3002\u56e0\u6b64\u53ea\u5728 splay \u7684 pushdown \u4e4b\u524d\u627e\u7236\u8282\u70b9\u7684\u8fc7\u7a0b\u4e2d\u8df3 lnk \u5373\u53ef\u3002\n\n### Code\n\n```cpp\nnamespace Fusu {\n\nconst int maxn = 30005;\nconst int maxm = 500005;\n\nvoid Init();\nvoid Solve();\n\nvoid Main() {\n  Init();\n  Solve();\n}\n\nstruct OP {\n  int op, u, v;\n};\nOP opt[maxm];\n\nint n, m, ocnt;\n\nstruct Node {\n  int sz = 1, id;\n  bool rev;\n  Node *ch[2], *fa, *lnk;\n\n  void updf() { while (fa && fa->lnk) fa = fa->lnk; }\n\n  void maketag() {\n    rev = !rev;\n    std::swap(ch[0], ch[1]);\n  }\n  void pushdown() {\n    if (rev) {\n      if (ch[0]) ch[0]->maketag();\n      if (ch[1]) ch[1]->maketag();\n      rev = false;\n    }\n  }\n  void pushup() {\n    sz = 1;\n    for (auto u : ch) if (u != nullptr) {\n      sz += u->sz;\n    }\n  }\n  \n  inline int GetSon() { return fa->ch[1] == this; }\n  inline bool IsRot() { return (fa == nullptr) || (fa->ch[GetSon()] != this); }\n\n  void rotate(const int x) {\n    auto nt = ch[x];\n    ch[x] = nt->ch[x ^ 1];\n    nt->ch[x ^ 1] = this;\n    if (ch[x]) ch[x]->fa = this;\n    if (!IsRot()) fa->ch[GetSon()] = nt;\n    nt->fa = fa; fa = nt;\n    pushup(); nt->pushup();\n  }\n\n  void splay() {\n    static Node *stk[maxm];\n    int top = 0;\n    auto u = this;\n    while (true) {\n      u->updf();  // \u5728\u8fd9\u91cc\u8df3 lnk \u5373\u53ef\u3002\n      stk[++top] = u;\n      if (u->IsRot()) break;\n      u = u->fa;\n    }\n    while (top) stk[top--]->pushdown();\n    while (!IsRot()) {\n      if (fa->IsRot()) {\n        fa->rotate(GetSon());\n      } else {\n        auto pa = fa->fa;\n        int k1 = GetSon(), k2 = fa->GetSon();\n        if (k1 == k2) {\n          pa->rotate(k2);\n          fa->rotate(k1);\n        } else {\n          fa->rotate(k1);\n          fa->rotate(k2);\n        }\n      }\n    }\n  }\n};\nNode Mem[maxm], *pool = Mem, *node[maxm];\ninline Node* New() { \n  pool->id = pool - Mem + 1;\n  return pool++; \n}\n\nvoid beginning() {\n  for (int i = 1; i <= n; ++i) {\n    node[i] = New();\n  }\n}\n\nstd::vector<int> e[maxn];\nvoid dfs(const int u, const int fa) {\n  node[u]->fa = node[fa];\n  for (auto v : e[u]) if (v != fa) {\n    dfs(v, u);\n  }\n}\n\nint ufs[maxm], rnk[maxm];\nint find(const int x) { return (ufs[x] == x) ? ufs[x] : ufs[x] = find(ufs[x]); }\n\nvoid unionn(int u, int v) {\n  if (rnk[u] > rnk[v]) std::swap(u, v);\n  ufs[u] = v;\n  rnk[v] += rnk[u] == rnk[v];\n}\n\nstd::vector<int> nct[maxn], cut[maxn];\n\nvoid Init() {\n  qr(n); qr(m);\n  for (int i = 1; i <= n; ++i) {\n    rnk[ufs[i] = i] = 1;\n  }\n  for (int u, v, x, y; m; --m) {\n    qr(u); qr(v);\n    if (u > v) std::swap(u, v);\n    nct[u].push_back(v);\n  }\n  m = ocnt;\n  int x, u, v;\n  for (qr(x); x != -1; qr(x)) {\n    qr(u); qr(v);\n    if (u > v) std::swap(u, v);\n    opt[++ocnt] = {x, u, v};\n    if (x == 0) {\n      cut[u].push_back(v);\n    }\n  }\n  for (int u = 1, i, j; u <= n; ++u) {\n    std::sort(nct[u].begin(), nct[u].end());\n    std::sort(cut[u].begin(), cut[u].end());\n    auto x = cut[u].begin();\n    for (auto v : nct[u]) {\n      while ((x != cut[u].end()) && (*x < v)) ++x;\n      if ((x != cut[u].end()) && (v == *x)) continue;\n      if ((i = find(u)) != (j = find(v))) {\n        e[u].push_back(v);\n        e[v].push_back(u);\n        unionn(i, j);\n      } else {\n        opt[++ocnt] = {0, u, v};\n      }\n    }\n  }\n  beginning();\n  dfs(1, 0);\n  std::reverse(opt + 1, opt + ocnt + 1);\n}\n\nvoid access(Node *u) {\n  for (Node *v = nullptr; u; u = (v = u)->fa) {\n    u->splay();\n    u->ch[1] = v;\n    u->pushup();\n  }\n}\n\nvoid makeroot(Node *u) {\n  access(u);\n  u->splay();\n  u->maketag();\n}\n\nNode *bel[maxm];\nvoid dfs(Node *const u, Node *const v) {\n  unionn(find(u->id), find(v->id));\n  u->pushdown();\n  for (auto p : u->ch) if (p != nullptr) {\n    dfs(p, v);\n  }\n  u->lnk = v;\n}\n\nint ncnt;\nstd::vector<int> ans;\nvoid Solve() {\n  ncnt = n;\n  for (int i = 1; i <= n; ++i) {\n    bel[i] = node[i];\n    rnk[ufs[i] = i] = 1;\n  }\n  for (int i = 1, x, y; i <= ocnt; ++i) if (opt[i].op == 0) {\n    if ((x = find(opt[i].u)) == (y = find(opt[i].v))) continue;\n    auto u = bel[x], v = bel[y];\n    makeroot(u); \n    access(v); v->splay();\n    node[++ncnt] = New();\n    rnk[ufs[ncnt] = ncnt] = 1;\n    dfs(v, node[ncnt]);\n    bel[find(ncnt)] = node[ncnt];\n    node[ncnt]->fa = v->fa;\n  } else {\n    x = opt[i].u, y = opt[i].v;\n    auto u = bel[find(x)], v = bel[find(y)];\n    makeroot(u); \n    access(v); \n    v->splay();\n    ans.push_back(v->sz - 1);\n  }\n  std::reverse(ans.begin(), ans.end());\n  for (auto u : ans) {\n    qw(u, '\\n');\n  }\n}\n\n} // namespace Fusu\n```\n\n",
        "postTime": 1587667609,
        "uid": 65363,
        "name": "\u4e00\u6276\u82cf\u4e00",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005] \u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "### Tarjan:e-dcc\u7f29\u70b9+ \u6811\u5256+\u7ebf\u6bb5\u6811/\u5e76\u67e5\u96c6\n\n### \u5148\u8bf4\u4e00\u4e2a\u6bd4\u8f83\u7b80\u5355\u7684\u7248\u672c[poj3694 Network](http://poj.org/problem?id=3694)\n\n\u9898\u610f\uff1a\u6bcf\u6b21**\u589e\u52a0\u4e00\u6761\u8fb9**\uff0c\u6c42\u56fe\u4e2d**\u6865\u7684\u6570\u91cf**\n\n\u9996\u5148\u8fdb\u884c\u4e00\u904dTarjan\u6c42\u51fa\u6240\u6709\u7684\u8fb9\u53cc\u8054\u901a\u5206\u91cf\uff0c\u7136\u540e**\u7f29\u70b9\u6210\u6811**\n\n\u5f97\u51fa\u521d\u59cb\u56fe\u7684\u6865\u7684\u6570\u91cf\u4e3a\u6811\u7684\u8fb9\u6570\u5373**tot(\u8fb9\u53cc\u6570\u91cf)-1**\u8bb0\u4f5cans0\n\n\u8003\u8651\u6dfb\u52a0\u4e00\u6761\u8fb9(x,y) (\u82e5\u7528dcc[i]\u8868\u793a\u7f16\u53f7\u4e3ai\u6240\u5728\u7684\u53cc\u8054\u901a\u5206\u91cf\u7684\u7f16\u53f7)\n\n#### 1.dcc[x]==dcc[y]\n\n\u4e24\u70b9\u540c\u5904\u4e8e\u4e00\u4e2a\u8fb9\u53cc\u4e2d\uff0c\u663e\u7136\u4e0d\u4f1a\u5bf9\u56fe\u7684\u6865\u6570\u6709\u5f71\u54cd\n\n#### 2.dcc[x]!=dcc[y]\n\n**dcc[x]\u4e0edcc[y]\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8fb9\u90fd\u4e0d\u4f1a\u518d\u662f\u6865**\n\n\u8003\u8651\u4e00\u79cd**\u66b4\u529b**\u7684\u505a\u6cd5\n\n\u5148\u6c42\u51fadcc[x]\u4e0edcc[y]\u7684lca\n\n\u7136\u540e\u66b4\u529b\u4ecedcc[x]\u66b4\u529b\u4e00\u4e2a\u4e2a\u8df3\u5230lca\uff0c\u8df3\u8fc7\u7684\u70b9(\u9664lca)\u82e5\u6ca1\u6709\u88ab\u6807\u8bb0\u5219\u6807\u8bb0vis[i]=1\n\n\u5728\u540c\u6837\u5730\u4ecedcc[y]\u5f80\u4e0a\u8df3\uff0c\u4e24\u6b21\u8fc7\u7a0b**\u6807\u8bb0\u5230\u7684\u70b9\u6570\u5219\u662f\u51cf\u5c11\u7684\u6865\u7684\u6570\u91cf(\u540c\u65f6\u4e5f\u662f\u5f53\u524d\u4e24\u70b9\u95f4\u6865\u7684\u6570\u91cf)**\u8bb0\u4f5c\u25b3ans\n\n\u6bcf\u6b21\u8f93\u51faans0=ans0-\u25b3ans\n\n~~\u4e0d\u8fc7\u8c8c\u4f3cpoj\u80fd\u7ed9\u8fc7~~\n\n**\u8003\u8651\u66f4\u52a0\u4f18\u79c0\u7684\u505a\u6cd5**\n\n\u6bcf\u6b21\u6709\u53ef\u80fd\u4f1a\u8df3\u8fc7\u5df2\u7ecf\u6807\u8bb0\u8fc7\u7684\u70b9\uff0c\u8003\u8651**\u5e76\u67e5\u96c6**\u628a\u5df2\u7ecf\u6807\u8bb0\u8fc7\u7684\u538b\u7f29\u8d77\u6765\uff0c\u6bcf\u6b21\u8df3\u7684\u65f6\u5019\u76f4\u63a5\u8df3\u5230\u96c6\u5408\u7684\u9876\u7aef\u5c31\u884c\u4e86\n\n\u53e6\u4e00\u79cd\u505a\u6cd5\u53ef\u4ee5\u5229\u7528**\u6811\u5256+\u7ebf\u6bb5\u6811**\uff0c\u521a\u5f00\u59cb\u6240\u6709\u6811\u8fb9\u6743\u90fd\u4e3a1\uff0c\u6bcf\u6b21\u5148\u8def\u5f84\u6c42\u548c\uff0c\u4e3a\u51cf\u5c11\u7684\u6865\u6570\uff0c\u7136\u540e\u628a\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8fb9\u6743\u90fd\u6539\u4e3a0\n\n### \u73b0\u5728\u56de\u5230\u8fd9\u9053\u9898\u76ee\n\n\u9898\u610f\uff1a\u6bcf\u6b21**\u65ad\u6389\u4e00\u6761\u8fb9**\uff0c\u6c42**\u4e24\u70b9\u95f4\u6865\u6570**\n\n\u540c\u6837\u7684\uff0c\u5982\u679c\u79bb\u7ebf\u64cd\u4f5c\uff0c\u628a\u6240\u6709\u7684\u64cd\u4f5c\u5148\u5b58\u4e0b\u6765\uff0c\u7136\u540e**\u5012\u5e8f**\uff0c**\u65ad\u6389\u4e00\u6761\u8fb9\u7684\u64cd\u4f5c\u5c31\u53d8\u6210\u4e86\u589e\u52a0\u4e00\u6761\u8fb9**\uff0c\u5c31\u8f6c\u5316\u6210\u4e86\u521a\u521a\u7684\u90a3\u9053\u9898\uff0c\u4e24\u70b9\u95f4\u7684\u6865\u6570\u4fbf\u662f\u25b3ans\n\n\u9996\u5148\u5148\u5efa\u4e00\u5e45**\u7531\u6ca1\u6709\u88ab\u65ad\u6389\u7684\u8fb9\u6784\u6210\u7684\u56fe**(\u56e0\u4e3a\u4fdd\u8bc1\u65e0\u8bba\u822a\u7ebf\u5982\u4f55\u88ab\u7834\u574f\uff0c\u4efb\u610f\u65f6\u523b\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u90fd\u80fd\u591f\u76f8\u4e92\u5230\u8fbe\uff0c\u6240\u4ee5\u5efa\u51fa\u7684\u56fe\u4e00\u5b9a\u8fde\u901a)\uff0c\u8fdb\u884c\u7f29\u70b9\u6210\u6811\n\n\u7136\u540e\u5012\u5e8f\u5904\u7406\u6bcf\u4e00\u4e2a\u64cd\u4f5c\uff0c\u8fd9\u91cc\u91c7\u7528\u7ebf\u6bb5\u6811\uff0c\u65ad\u8fb9\u5c31\u662f\u52a0\u8fb9\uff0c\u8def\u5f84\u8fb9\u6743\u8d4b0\uff0c\u8be2\u95ee\u5c31\u8f93\u51fa\u8def\u5f84\u548c\n\n\u53ef\u4ee5\u7528\u4e00\u4e2amap\u8868\u793a\u8fb9\u662f\u5426\u88ab\u65ad\u6389\uff0c\u7531\u4e8e\u6709\u91cd\u8fb9~~(\u6211\u4e00\u5f00\u59cb\u6ca1\u60f3\u91cd\u8fb9\u7684wa\u4e86n\u7f16)~~\uff0c\u5e94\u5b58\u8fb9(a,b)\u88ab\u5220\u53bb\u7684\u6b21\u6570\uff0c\u56e0\u4e3a\u53ef\u80fd\u6709\u591a\u6761(a,b)\uff0c\u5bf9\u4e8e\u539f\u56fe\u4e2d\u7684\u6bcf\u4e00\u6761\u8fb9(a,b)\uff0c\u82e5map[(a,b)]>0(\u4ee3\u8868\u8fd9\u6761\u8fb9\u4f1a\u88ab\u5220\u53bb)\u5c31\u628amap[(a,b)]--\uff0c\u5426\u5219\u8bf4\u660e\u8fd9\u6761\u8fb9\u4e0d\u4f1a\u88ab\u5220\u53bb\uff0c\u5c31\u8fde\u63a5(a,b)\n```cpp\n#include<map>\n#include<stack>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntemplate<class type>inline const void read(type &in)\n{\n    in=0;char ch=getchar();short fh=1;\n    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();\n    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();\n    in*=fh;\n}\nconst int N=3e4+10,M=1e5+10,Q=4e4+10;\nint n,m,a[M],b[M];\nstack<int>ans;\nmap<pair<int,int>,int>e;\nstruct question{int u,v,type;}q[Q]; //\u5b58\u50a8\u6bcf\u4e2a\u8be2\u95ee\u4fe1\u606f\nclass Edge\n{\n    private:\n        int cnt;\n    public:\n        int head[N],to[M<<1],next[M<<1];\n        inline const void addedge(int u,int v)\n        {\n            next[++cnt]=head[u];\n            head[u]=cnt;\n            to[cnt]=v;\n        }\n        inline const void connect(int u,int v)\n        {\n            addedge(u,v);\n            addedge(v,u);\n        }\n}g,t;\nclass Double_Connected_Component //\u8fb9\u53cc\u5904\u7406\n{\n    private:\n        stack<int>s;\n        int dfn[N],low[N],cnt;\n    public:\n    \tint dcc[N],tot;\n    protected:\n        inline const void tarjan(int u,int fa)\n        {\n            dfn[u]=low[u]=++cnt;s.push(u);int v;\n            for (int i=g.head[u];i;i=g.next[i])\n                if ((v=g.to[i])!=fa)\n                    if (!dfn[v])tarjan(v,u),low[u]=min(low[u],low[v]);\n                    else if (!dcc[v])low[u]=min(low[u],dfn[v]);\n            if (low[u]!=dfn[u])return;tot++;\n            do v=s.top(),s.pop(),dcc[v]=tot;while (u!=v);\n        }\n    public:\n        inline const void tarjan()\n        {\n            for (int i=1;i<=n;i++)\n                if (!dfn[i])\n                    tarjan(i,0);\n        }\n        inline const void rebuild() //\u7f29\u70b9\u6210\u6811\n        {\n            for (int i=1;i<=n;i++)\n                for (int u,v,j=g.head[i];j;j=g.next[j])\n                    if ((u=dcc[i])!=(v=dcc[g.to[j]]))\n                        t.addedge(u,v);\n        }\n}dcc;\nclass Segment_Tree  //\u7ebf\u6bb5\u6811(\u6307\u9488)\n{\n    private:\n        struct tree\n        {\n            int sum;\n            bool tag;\n            tree *lson,*rson;\n            inline const void pushup()\n            {\n                sum=lson->sum+rson->sum;\n            }\n            inline const void cover()\n            {\n                tag=1;sum=0;\n            }\n            inline const void pushdown()\n            {\n                if (!tag)return;\n                lson->cover();\n                rson->cover();\n                tag=0;\n            }\n            inline const void update(int l,int r,int L,int R)\n            {\n                if (l>R||r<L)return;\n                if (l>=L&&r<=R)return cover();\n                pushdown();\n                int mid=l+r>>1;\n                lson->update(l,mid,L,R);\n                rson->update(mid+1,r,L,R);\n                pushup();\n            }\n            inline const int query(int l,int r,int L,int R)\n            {\n                if (l>R||r<L)return 0;\n                if (l>=L&&r<=R)return sum;\n                pushdown();\n                int mid=l+r>>1;\n                return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);\n            }\n        }memory_pool[N<<2],*tail;\n        inline const void init()\n        {\n            tail=memory_pool;\n        }\n        inline tree *spawn()\n        {\n            tree *p=tail++;\n            p->tag=p->sum=0;\n            p->lson=p->rson=NULL;\n            return p;\n        }\n    public:\n        tree *root;\n        inline Segment_Tree(){init();}\n        inline const void build(tree *&p,int l,int r)\n        {\n            p=spawn();\n            if (l==r)return (void)(p->sum=(l!=1)); //\u8fb9\u6743\u8f6c\u70b9\u6743\uff0c1\u53f7\u70b9(\u6839\u8282\u70b9)\u4e0a\u9762\u6ca1\u6709\u8fb9\uff0c\u6743\u503c\u4e3a0\n            int mid=l+r>>1;\n            build(p->lson,l,mid);\n            build(p->rson,mid+1,r);\n            p->pushup();\n        }\n}sgt;\nclass Heavy_Light_Decomposition //\u6811\u5256\n{\n    private:\n        int size[N],top[N],fa[N],dep[N],dfn[N],wson[N],cnt;\n    public:\n        inline const void dfs(int p)\n        {\n            size[p]=1;\n            for (int i=t.head[p];i;i=t.next[i])\n            {\n                int son=t.to[i];\n                if (son==fa[p])continue;\n                fa[son]=p;dep[son]=dep[p]+1;\n                dfs(son);size[p]+=size[son];\n                if (size[son]>size[wson[p]])wson[p]=son;\n            }\t\n        }\n        inline const void dfs(int p,int tp)\n        {\n            top[p]=tp;dfn[p]=++cnt;\n            if (wson[p])dfs(wson[p],tp);\n            for (int son,i=t.head[p];i;i=t.next[i])\n                if (!dfn[son=t.to[i]])\n                    dfs(son,son);\n        }\n        inline const void update(int a,int b)\n        {\n            while (top[a]^top[b])\n            {\n                if (dep[top[a]]<dep[top[b]])swap(a,b);\n                sgt.root->update(1,dcc.tot,dfn[top[a]],dfn[a]);\n                a=fa[top[a]];\n            }\n            if (dep[a]>dep[b])swap(a,b);\n            sgt.root->update(1,dcc.tot,dfn[a]+1,dfn[b]);\n        }\n        inline const int query(int a,int b)\n        {\n            int ans=0;\n            while (top[a]^top[b])\n            {\n                if (dep[top[a]]<dep[top[b]])swap(a,b);\n                ans+=sgt.root->query(1,dcc.tot,dfn[top[a]],dfn[a]);\n                a=fa[top[a]];\n            }\n            if (dep[a]>dep[b])swap(a,b);\n            return ans+sgt.root->query(1,dcc.tot,dfn[a]+1,dfn[b]);\n        }\n}hld;\nint main()\n{\n    read(n);read(m);\n    for (int i=1;i<=m;i++)read(a[i]),read(b[i]);\n    int qtot;\n    for (qtot=1;read(q[qtot].type),~q[qtot].type;qtot++)\n    {\n        read(q[qtot].u);read(q[qtot].v);\n        if (q[qtot].type)continue;\n        e[make_pair(q[qtot].u,q[qtot].v)]++;\n\t\te[make_pair(q[qtot].v,q[qtot].u)]++; //\u65e0\u5411\u56fe\uff0c\u53cd\u8fc7\u6765\u7684\u4e5f\u8981\u66f4\u6539\n\t}\n    for (int i=1;i<=m;i++)\n        if (e.find(make_pair(a[i],b[i]))!=e.end()&&e[make_pair(a[i],b[i])])\n\t\t\te[make_pair(a[i],b[i])]--,e[make_pair(b[i],a[i])]--;\n\t\telse g.connect(a[i],b[i]);\n    dcc.tarjan();dcc.rebuild();\n    hld.dfs(1);hld.dfs(1,1);\n    sgt.build(sgt.root,1,dcc.tot);\n    for (int i=qtot-1;i;i--)\n        if (q[i].type)ans.push(hld.query(dcc.dcc[q[i].u],dcc.dcc[q[i].v])); //\u7531\u4e8e\u662f\u5012\u5e8f\u5904\u7406\uff0c\u6240\u4ee5\u8f93\u51fa\u4e5f\u8981\u5012\u8fc7\u6765\uff0c\u56e0\u4e3atarjan\u7f29\u70b9\u7684\u65f6\u5019\u4f1a\u7528\u5230\u6808\uff0c\u5e72\u8106\u4e5f\u7528\u6808\u6765\u5b9e\u73b0\u5012\u5e8f\u597d\u4e86\n        else hld.update(dcc.dcc[q[i].u],dcc.dcc[q[i].v]);\n    while (ans.size())printf(\"%d\\n\",ans.top()),ans.pop();\n    return 0;\n}\n```",
        "postTime": 1545495356,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u7531\u4e8e\u5220\u9664\u8fb9\u7684\u64cd\u4f5c\u6bd4\u8f83\u9ebb\u70e6\uff0c\u800c\u52a0\u8fb9\u7684\u64cd\u4f5c\u76f8\u5bf9\u597d\u505a\uff0c\u6211\u4eec\u8003\u8651\u79bb\u7ebf\u4e0b\u6765\uff0c\u5012\u7740\u5904\u7406\u3002\n\n\u663e\u7136\uff0c\u4e00\u9897\u6811\u4e0a\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u6240\u6709\u8def\u5f84\u90fd\u662f\u5173\u952e\u8def\u5f84\u3002\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/uiinuov8.png)\n\n\u6211\u4eec\u770b\u4e00\u4e0b\u8fde\u4e00\u6761\u8fb9\u4f1a\u53d1\u751f\u4ec0\u4e48\u3002\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/8mnbldxm.png)\n\n\u4f1a\u51fa\u73b0\u4e00\u4e2a\u73af\uff0c\u73af\u4e0a\u6240\u6709\u8fb9\u90fd\u53d8\u6210\u4e86\u975e\u5173\u952e\u8fb9\u3002\n\n\u9996\u5148\u6570\u636e\u4fdd\u8bc1\u4e86\u56fe\u662f\u8fde\u901a\u7684\uff0c\u6211\u4eec\u9996\u5148\u5728\u5220\u5b8c\u8fb9\u540e\u7684\u56fe\u4e0a\u968f\u4fbf\u641e\u51fa\u4e00\u4e2a\u751f\u6210\u6811\uff08\u4e5f\u53ef\u4ee5\u5148\u7528 Tarjan \u7f29\u70b9\uff09\uff0c\u7136\u540e\u628a\u975e\u6811\u8fb9\u8fde\u63a5\u7684\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u5168\u53d8\u4e3a\u975e\u5173\u952e\u8fb9\uff0c\u5012\u7740\u5904\u7406\u8be2\u95ee\uff0c\u52a0\u8fb9\u5c31\u662f\u628a\u8fb9\u8fde\u63a5\u4e24\u70b9\u95f4\u7684\u8def\u5f84\u5168\u90e8\u53d8\u6210\u975e\u5173\u952e\u8fb9\uff0c\u67e5\u8be2\u5c31\u662f\u67e5\u8be2\u4e24\u70b9\u95f4\u5173\u952e\u8fb9\u7684\u6570\u91cf\u3002\n\n\u600e\u4e48\u9ad8\u6548\u5b9e\u73b0\u5462\uff1f\u91cd\u94fe\u5256\u5206\u3002\n\n\u6ce8\u610f\u8981\u7ef4\u62a4\u7684\u662f\u8fb9\u6743\uff0c\u6240\u4ee5\u8f6c\u6362\u4e3a\u70b9\u6743\u7684\u65f6\u5019\u4e0d\u8981\u4fee\u6539/\u67e5\u8be2 LCA\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log n+m+q\\log^2n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1e5+5;\nint n,m,q,ans[maxn],ansc;\nstruct edge{\n    int u,v;\n}e[maxn];\nstruct query{\n    int op,u,v;\n}Q[maxn];\nll get(int u,int v){\n    if(u>v)swap(u,v);\n    return 1ll*(n+1)*u+v;\n}\nunordered_set<ll> S; // \u7528\u4e00\u4e2a unordered_set \u7ef4\u62a4\u6709\u6ca1\u6709\u5220\uff0c\u611f\u89c9\u600e\u4e48\u5199\u90fd\u4e0d\u592a\u4f18\u96c5\uff08\nvector<int> G[maxn],Gt[maxn];\nbitset<maxn> vis;\nint sz[maxn],dep[maxn],hs[maxn],fa[maxn];\nvoid dfs1(int u){ // \u83b7\u5f97 dfs \u751f\u6210\u6811\uff0c\u987a\u4fbf\u8fdb\u884c\u6811\u5256\u7684\u7b2c\u4e00\u6b21\u5904\u7406\n    vis[u]=1;\n    sz[u]=1;\n    for(auto v:G[u]){\n        if(vis[v])continue;\n        Gt[u].push_back(v); // \u5efa\u751f\u6210\u6811\n        dep[v]=dep[u]+1;\n        fa[v]=u;\n        dfs1(v);\n        sz[u]+=sz[v];\n        if(sz[v]>sz[hs[u]])hs[u]=v;\n    }\n}\nint tick,dfn[maxn],top[maxn];\nvoid dfs2(int u,int t){ // \u6811\u5256\u7684\u7b2c\u4e8c\u6b21 dfs\n    dfn[u]=++tick;\n    top[u]=t;\n    if(hs[u])dfs2(hs[u],t);\n    for(auto v:Gt[u])if(v!=hs[u])dfs2(v,v);\n}\n// \u7ebf\u6bb5\u6811\u90e8\u5206\nint w[maxn*4];\nbitset<maxn*4> lzy;\nbool in_range(int L,int R,int l,int r){\n    return (l<=L)&&(R<=r);\n}\nbool out_range(int L,int R,int l,int r){\n    return (r<L)||(R<l);\n}\nvoid pushup(int u){\n    w[u]=w[u*2]+w[u*2+1];\n}\nvoid maketag(int u){\n    w[u]=0;\n    lzy[u]=1;\n}\nvoid pushdown(int u){\n    if(!lzy[u])return;\n    maketag(u*2);\n    maketag(u*2+1);\n    lzy[u]=0;\n}\nvoid build(int u,int L,int R){\n    if(L==R){\n        w[u]=1;\n        return;\n    }\n    int M=(L+R)>>1;\n    build(u*2,L,M);\n    build(u*2+1,M+1,R);\n    pushup(u);\n}\nvoid modify(int u,int L,int R,int l,int r){\n    if(in_range(L,R,l,r)){\n        maketag(u);\n        return;\n    }\n    if(out_range(L,R,l,r))return;\n    int M=(L+R)>>1;\n    pushdown(u);\n    modify(u*2,L,M,l,r);\n    modify(u*2+1,M+1,R,l,r);\n    pushup(u);\n}\nint query(int u,int L,int R,int l,int r){\n    if(in_range(L,R,l,r))return w[u];\n    if(out_range(L,R,l,r))return 0;\n    int M=(L+R)>>1;\n    pushdown(u);\n    return query(u*2,L,M,l,r)+query(u*2+1,M+1,R,l,r);\n}\n// \u628a\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u5168\u8d4b\u4e3a 0\nvoid mod_path(int u,int v){\n    while(top[u]!=top[v]){\n        if(dep[top[u]]<dep[top[v]])swap(u,v);\n        modify(1,1,n,dfn[top[u]],dfn[u]);\n        u=fa[top[u]];\n    }\n    if(u==v)return;\n    if(dep[u]>dep[v])swap(u,v);\n    modify(1,1,n,dfn[u]+1,dfn[v]); // \u4e0d\u8981\u4fee\u6539 LCA\n}\nint qry_path(int u,int v){\n    int ret=0;\n    while(top[u]!=top[v]){\n        if(dep[top[u]]<dep[top[v]])swap(u,v);\n        ret+=query(1,1,n,dfn[top[u]],dfn[u]);\n        u=fa[top[u]];\n    }\n    if(u==v)return ret;\n    if(dep[u]>dep[v])swap(u,v);\n    ret+=query(1,1,n,dfn[u]+1,dfn[v]); // \u4e5f\u4e0d\u8981\u52a0\u4e0a LCA\n    return ret;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cin>>n>>m;\n    for(int i=1;i<=m;++i)cin>>e[i].u>>e[i].v;\n    while(1){\n        ++q;\n        cin>>Q[q].op;\n        if(Q[q].op==-1)break;\n        cin>>Q[q].u>>Q[q].v;\n        if(Q[q].op==0)S.insert(get(Q[q].u,Q[q].v));\n    }\n    --q;\n    for(int i=1;i<=m;++i){\n        if(S.count(get(e[i].u,e[i].v)))continue;\n        G[e[i].u].push_back(e[i].v);\n        G[e[i].v].push_back(e[i].u);\n    }\n    dep[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    build(1,1,n);\n    for(int i=1;i<=m;++i){\n        if(S.count(get(e[i].u,e[i].v)))continue;\n        if(fa[e[i].u]==e[i].v||fa[e[i].v]==e[i].u)continue;\n        mod_path(e[i].u,e[i].v);\n    }\n    for(int i=q;i;--i){\n        if(Q[i].op==1)ans[++ansc]=qry_path(Q[i].u,Q[i].v);\n        else mod_path(Q[i].u,Q[i].v);\n    }\n    for(int i=ansc;i;--i)cout<<ans[i]<<'\\n'; // \u6ce8\u610f\u5012\u7740\u8f93\u51fa\n}\n```\n",
        "postTime": 1683356114,
        "uid": 460457,
        "name": "KnownError_",
        "ccfLevel": 4,
        "title": "P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212 \u9898\u89e3"
    },
    {
        "content": "# \u9898\u76ee\u5927\u610f\n\n\u5bf9 $\\rm Samuel$ \u661f\u7403\u7684\u63a2\u9669\u5df2\u7ecf\u53d6\u5f97\u4e86\u975e\u5e38\u5de8\u5927\u7684\u6210\u5c31\uff0c\u4e8e\u662f\u79d1\u5b66\u5bb6\u4eec\u5c06\u76ee\u5149\u6295\u5411\u4e86 $\\rm Samuel$ \u661f\u7403\u6240\u5728\u7684\u661f\u7cfb\u2014\u2014\u4e00\u4e2a\u5de8\u5927\u7684\u7531\u5343\u767e\u4e07\u661f\u7403\u6784\u6210\u7684 $\\rm Samuel$ \u661f\u7cfb\u3002\n\n\u661f\u9645\u7a7a\u95f4\u7ad9\u7684 $\\rm Samuel$ II \u5de8\u578b\u8ba1\u7b97\u673a\u7ecf\u8fc7\u957f\u671f\u63a2\u6d4b\uff0c\u5df2\u7ecf\u9501\u5b9a\u4e86 $\\rm Samuel$ \u661f\u7cfb\u4e2d $n$ \u4e2a\u661f\u7403\u7684\u7a7a\u95f4\u5750\u6807\uff0c\u5e76\u5bf9\u8fd9\u4e9b\u661f\u7403\u4ee5 $1$ \u81f3 $n$ \u4f9d\u6b21\u7f16\u53f7\u3002\n\n\u4e00\u4e9b\u5148\u9063\u98de\u8239\u5df2\u7ecf\u51fa\u53d1\uff0c\u5728\u661f\u7403\u4e4b\u95f4\u5f00\u8f9f\u63a2\u9669\u822a\u7ebf\u3002\n\n\u63a2\u9669\u822a\u7ebf\u662f\u53cc\u5411\u7684\uff0c\u4f8b\u5982\u4ece $1$ \u53f7\u661f\u7403\u5230 $3$ \u53f7\u661f\u7403\u5f00\u8f9f\u63a2\u9669\u822a\u7ebf\uff0c\u90a3\u4e48\u4ece $3$ \u53f7\u661f\u7403\u5230 $1$ \u53f7\u661f\u7403\u4e5f\u53ef\u4ee5\u4f7f\u7528\u8fd9\u6761\u822a\u7ebf\u3002\n\n\u4f8b\u5982\u4e0b\u56fe\u6240\u793a\uff1a\n\n ![](https://cdn.luogu.com.cn/upload/pic/1644.png) \n\n\u5728 $5$ \u4e2a\u661f\u7403\u4e4b\u95f4\uff0c\u6709 $5$ \u6761\u63a2\u9669\u822a\u7ebf\u3002\n\n$A,B$ \u4e24\u661f\u7403\u4e4b\u95f4\uff0c\u5982\u679c\u67d0\u6761\u822a\u7ebf\u4e0d\u5b58\u5728\uff0c\u5c31\u65e0\u6cd5\u4ece $A$ \u661f\u7403\u62b5\u8fbe $B$ \u661f\u7403\uff0c\u6211\u4eec\u5219\u79f0\u8fd9\u6761\u822a\u7ebf\u4e3a\u5173\u952e\u822a\u7ebf\u3002\n\n\u663e\u7136\u4e0a\u56fe\u4e2d\uff0c$1$ \u53f7\u4e0e $5$ \u53f7\u661f\u7403\u4e4b\u95f4\u7684\u5173\u952e\u822a\u7ebf\u6709 $1$ \u6761\uff1a\u5373\u4e3a $4\\leftrightarrow5$ \u822a\u7ebf\u3002\n\n\u7136\u800c\uff0c\u5728\u5b87\u5b99\u4e2d\u4e00\u4e9b\u672a\u77e5\u7684\u78c1\u66b4\u548c\u884c\u661f\u7684\u51b2\u649e\uff0c\u4f7f\u5f97\u5df2\u6709\u7684\u67d0\u4e9b\u822a\u7ebf\u88ab\u7834\u574f\uff0c\u968f\u7740\u8d8a\u6765\u8d8a\u591a\u7684\u822a\u7ebf\u88ab\u7834\u574f\uff0c\u63a2\u9669\u98de\u8239\u53c8\u4e0d\u80fd\u53ca\u65f6\u6062\u590d\u8fd9\u4e9b\u822a\u7ebf\uff0c\u53ef\u89c1\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u7684\u5173\u952e\u822a\u7ebf\u4f1a\u8d8a\u6765\u8d8a\u591a\u3002\n\n\u5047\u8bbe\u5728\u4e0a\u56fe\u4e2d\uff0c\u822a\u7ebf $4\\leftrightarrow2$\uff08\u4ece $4$ \u53f7\u661f\u7403\u5230 $2$ \u53f7\u661f\u7403\uff09\u88ab\u7834\u574f\u3002\u6b64\u65f6\uff0c$1$ \u53f7\u4e0e $5$ \u53f7\u661f\u7403\u4e4b\u95f4\u7684\u5173\u952e\u822a\u7ebf\u5c31\u6709 $3$ \u6761\uff1a$1 \\leftrightarrow 3$\uff0c$3 \\leftrightarrow 4$\uff0c$4 \\leftrightarrow 5$\u3002\n\n\u5c0f\u8054\u7684\u4efb\u52a1\u662f\uff0c\u4e0d\u65ad\u5173\u6ce8\u822a\u7ebf\u88ab\u7834\u574f\u7684\u60c5\u51b5\uff0c\u5e76\u968f\u65f6\u7ed9\u51fa\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u7684\u5173\u952e\u822a\u7ebf\u6570\u76ee\u3002\u73b0\u5728\u8bf7\u4f60\u5e2e\u52a9\u5b8c\u6210\u3002\n\n# \u9898\u76ee\u5206\u6790\n\n\u5220\u8fb9\u4e0d\u662f\u5f88\u597d\u5199\uff0c\u4f46\u662f\u5982\u679c\u662f\u52a0\u8fb9\u5c31\u597d\u529e\u4e86\uff0c\u6240\u4ee5\u6211\u4eec\u628a\u6240\u6709\u64cd\u4f5c\u79bb\u7ebf\u4e0b\u6765\uff0c\u5012\u5e8f\u5904\u7406\u3002\u8fd9\u6837\u5982\u679c\u8981\u5220\u4e00\u6761\u8fb9\u5c31\u53d8\u6210\u4e86\u52a0\u4e00\u6761\u8fb9\uff0c\u6700\u540e\u52a0\u6210\u9898\u76ee\u7ed9\u51fa\u7684\u8fb9\uff0c\u6545\u6211\u4eec\u53ef\u4ee5\u6807\u8bb0\u90a3\u4e9b\u8fb9\u662f\u4f1a\u88ab\u5220\u9664\u7684\uff08\u4e5f\u5c31\u662f\u5f53\u524d\u7684\u56fe\u8fd8\u6ca1\u52a0\u4e0a\u53bb\u7684\u8fb9\uff09\u3002\n\n\u4e3a\u65b9\u4fbf\uff0c\u5f53\u524d\u4e00\u6b65\u4e00\u6b65\u8ddf\u7740\u64cd\u4f5c\u6b63\u5728\u53d8\u5316\u7684\u56fe\u53eb $G$\uff0c\u6700\u7ec8\u7684\u56fe\uff08\u9898\u76ee\u7ed9\u51fa\u7684\u56fe\uff09\u53eb $G'$\u3002**\u6ce8\u610f\u6211\u4eec\u7684 $G'$ \u4e0d\u4e00\u5b9a\u662f\u4e00\u68f5\u6811\uff0c\u6240\u4ee5\u6811\u94fe\u5256\u5206\u7684\u4e24\u4e2a $\\verb!dfs!$ \u9700\u8981\u6539\u6539\u3002**\n\n\u7136\u540e\u6211\u4eec\u53d1\u73b0\uff0c\u6c42\u4e24\u4e2a\u70b9\u4e4b\u524d\u7684\u5173\u952e\u8def\u7ebf\uff0c\u53ef\u4ee5\u8f6c\u5316\u4e3a\u7b80\u5355\u7684\u6811\u4e0a\u64cd\u4f5c\uff1a\u6811\u4e0a\u4e24\u70b9\u95f4\u7684\u6c42\u548c\u3002\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u8fd9\u4e48\u8f6c\u5316\uff1f\u9996\u5148 $G'$ \u4e2d\u7684\u6240\u6709\u73af\u5185\u7684\u8fb9\u957f\u5ea6\u4e3a $0$\uff0c\u5176\u4ed6\u8fb9\u957f\u5ea6\u4e3a $1$\u3002\u968f\u540e\u6211\u4eec\u76f4\u63a5\u6309\u7167 $\\verb!dfs!$ \u5e8f\u5728 $G'$ \u4e2d\u5efa**\u6811** $T$\u3002\n\n\u4e4b\u540e\uff0c\u6bcf\u52a0\u4e00\u6761\u8fb9\uff0c\u5c31\u628a\u4e24\u6761\u8fb9\u4e4b\u95f4\u7684\u6240\u6709\u70b9\u7684\u957f\u5ea6\u53d8\u4e3a $0$\u3002\u56e0\u4e3a\u9898\u76ee\u63d0\u5230\u201c\u65e0\u8bba\u822a\u7ebf\u5982\u4f55\u88ab\u7834\u574f\uff0c\u4efb\u610f\u65f6\u523b\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u90fd\u80fd\u591f\u76f8\u4e92\u5230\u8fbe\u3002\u5728\u6574\u4e2a\u6570\u636e\u4e2d\uff0c\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u6700\u591a\u53ea\u53ef\u80fd\u5b58\u5728\u4e00\u6761\u76f4\u63a5\u7684\u822a\u7ebf\u3002\u201d\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f97\u77e5\uff0c\u5982\u679c\u52a0\u4e86\u4e00\u6761\u8fb9 $(u,v)$\uff0c\u4e00\u5b9a\u4f1a\u5236\u9020\u4e00\u4e2a\u542b $u,v$ \u7684\u73af\u3002\u65e2\u7136\u5982\u6b64\uff0c\u800c\u6211\u4eec $T$ \u662f\u4e00\u68f5\u6811\uff0c\u6240\u4ee5\u4e4b\u524d $u,v$ \u662f\u76f8\u4e92\u901a\u8fbe\u7684\uff0c\u73b0\u5728\u53c8\u6765\u4e86\uff0c\u8bf4\u660e $G'$ \u4e2d $u\\to v$ \u4e0d\u518d\u53ea\u6709\u4e00\u6761\u8def\u4e86\u3002\u6240\u4ee5 $T$ \u4e2d $u,v$ \u4e4b\u95f4\u7684\u8def\u5f84\u957f\u5ea6\u53d8\u4e3a $0$\u3002\n\n\u800c\u8be2\u95ee\u64cd\u4f5c\u5c31\u662f\u5e73\u51e1\u7684\u6a21\u677f\u3002\n\n----------------------\n\n\u6613\u9519\u70b9\uff1a\n\n$\\#1$\n\n\u56e0\u4e3a $G'$ \u4e0d\u662f\u4e00\u5b9a\u4e00\u9897\u6811\uff0c\u6240\u4ee5\u5224\u65ad\u6761\u4ef6\u4e0d\u80fd\u5199\u6210 `v != fath`\uff0c\u56e0\u4e3a\u8fd9\u53ef\u80fd\u662f\u4e00\u4e2a\u73af\uff0c\u5982\u679c\u5199\u6210\u8fd9\u6837\u5c31\u4f1a\u7206\u6808\u5bfc\u81f4 $\\textsf{MLE}$\u3002\u5e94\u8be5\u5199\u6210 `siz[v] == 0`\u3002\n\n\u6b63\u786e\u7684 `dfs1` \u51fd\u6570\uff1a\n\n```cpp\ninline void dfs1(int now,int fath,int depth) {\n\tfa[now] = fath,dep[now] = depth,siz[now] = 1;\n\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\tint v = gra[i].v;\n\t\tif (siz[v] == 0 && gra[i].vis == false) {\n\t\t\tdfs1(v,now,depth + 1);\n\t\t\tsiz[now] += siz[v];\n\t\t\tif (siz[son[now]] < siz[v]) {\n\t\t\t\tson[now] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n$\\#2$\n\n\u540c\u7406\uff0c\u5728 `dfs2` \u4e2d\u4e5f\u4e0d\u80fd\u5199\u6210 `v != fa[now]`\uff0c\u53cd\u4f8b\u8fd8\u662f\u521a\u624d\u7684\u73af\u3002\u5e94\u8be5\u5199\u6210\u4ec0\u4e48\u5462\uff0c\u8ddf\u4e0a\u9762\u7c7b\u4f3c\uff0c\u5982\u679c\u771f\u7684\u8fd8\u6ca1\u6709\u8bbf\u95ee\u8fc7\uff0c\u90a3\u4e48 $top$ \u6570\u7ec4\u8fd8\u6ca1\u6709\u66f4\u65b0\u5427\u3002\u5373 `top[v] == 0`\u3002\n\n\u6b63\u786e\u7684 `dfs2` \u51fd\u6570\uff1a\n\n```cpp\ninline void dfs2(int now,int topf) {\n\ttop[now] = topf,dfn[now] = ++ num;\n\tif (son[now]) {\n\t\tdfs2(son[now],topf);\n\t\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\t\tint v = gra[i].v;\n\t\t\tif (top[v] == 0 && v != son[now] && gra[i].vis == false) {\n\t\t\t\tdfs2(v,v); \n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n$\\#3$\n\n\u7b97\u662f\u6bd4\u8f83\u5e38\u89c1\u7684\u5957\u8def\u4e86\uff0c\u8fd9\u91cc\u5199\u5199\u4ee5\u4fbf\u8bfb\u8005\u7406\u89e3\u3002\n\n\u8fb9\u6743\u600e\u4e48\u6811\u5256\uff1f\u53ef\u4ee5\u628a\u8fb9\u653e\u5230\u70b9\u4e0a\uff0c\u6240\u4ee5\u8981\u6ce8\u610f\u4e00\u4e0b\uff0c\u5982\u56fe\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/45367.png)\n\n\u6bd4\u5982\u4ece $5\\to 7$\uff0c\u6811\u4e0a\u8def\u5f84\u662f $5\\to 2\\to 7$\uff0c\u90a3\u4e48\u6734\u7d20\u6811\u5256\u4f1a\u76f4\u63a5\u7edf\u8ba1 $5\\to 2\\to 6\\to 7$ \u8def\u4e0a\u6240\u6709\u70b9\u7684\u548c\uff0c\u4f46\u662f\u6211\u4eec\u6ce8\u610f\u672c\u6765\u70b9 $5$ \u662f\u4e0d\u5728\u8def\u5f84\u4e0a\u7684\uff08\u70b9 $5$ \u5b58 $(5,8)$ \u8fd9\u6761\u8fb9\u7684\u6743\u503c\uff09\u3002\u6240\u4ee5\u6ce8\u610f\u4e0b\u8fb9\u754c\uff0c\u6811\u5256\u7684\u8be2\u95ee\u548c\u4fee\u6539\u90fd\u8981\u52a0\u4e00\u3002\n\n\u5177\u4f53\u8be6\u89c1\u4ee3\u7801\n\n$\\#4$\n\n\u7b2c\u4e09\u6b21 $\\verb!dfs!$\u3002\n\n\u4e3a\u4ec0\u4e48\u8fd8\u8981\u7b2c\u4e09\u6b21 $\\verb!dfs!$\uff1f\u666e\u901a\u6811\u5256\u4e0d\u7528\u662f\u56e0\u4e3a\u4fdd\u8bc1\u4e3a\u6811\uff0c\u800c\u8fd9\u91cc $G'$ \u53ef\u80fd\u4e0d\u662f\u6811\uff0c\u6240\u4ee5\u6211\u4eec\u5904\u7406\u51fa $T$ \u65f6\u4f1a\u5ffd\u7565\u6389\u5f88\u591a $G'$ \u91cc\u7684\u8fb9\uff08\u8fd8\u6ca1\u52a0\u8fb9\u65f6\uff09\u3002\u4e5f\u5c31\u662f\u5904\u7406\u6ca1\u6709\u52a0\u5165 $\\verb!dfs!$ \u6811\u91cc\u7684\u8fb9\u3002\n\n\u770b\u4e00\u4e0b\u4ee3\u7801\uff0c\u4e5f\u4f1a\u89e3\u91ca\u4e00\u4e0b\uff1a\n\n```cpp\ninline void dfs3(int now) {\n\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\tint v = gra[i].v;\n\t\tif (gra[i].vis == false) {\n\t\t\tif (fa[v] == now) {\n\t\t\t\tdfs3(v);\n\t\t\t}\n\t\t\t//\u6ca1\u6709\u52a0\u5165 dfs \u6811\u4e2d\u7684\u90a3\u4e9b\u8fb9\n\t\t\tif (fa[now] != v && dep[v] < dep[now]) {\n\t\t\t\tupdate(now,v,0);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\u5982\u679c `fa[v] == now`\uff0c\u8bf4\u660e $(now,v)$ \u5728 $T$ \u91cc\uff0c\u90a3\u4e48\u6211\u4eec\u8df3\u8fc7\u3002\u5982\u679c\u662f $v$ \u4e0d\u662f $now$ \u7684\u7236\u8282\u70b9\uff0c\u5e76\u4e14 $v$ \u5728 $T$ \u91cc\u7684\u6df1\u5ea6\u6bd4 $now$ \u5728 $T$ \u91cc\u7684\u6df1\u5ea6\u5c0f\uff0c\u8bf4\u660e\u8fd9\u6761\u8fb9\u6ca1\u6709\u52a0\u3002\u5426\u5219 $dep[v]\\gt dep[now]$\u3002\n\n\n# \u4ee3\u7801\n\n```cpp\n// Problem: P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/P2542\n// Memory Limit: 125 MB\n// Time Limit: 1000 ms\n// Date:2022-05-22 17:14\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include <iostream>\n#include <cstdio>\n#include <climits>//need \"INT_MAX\",\"INT_MIN\"\n#include <cstring>//need \"memset\"\n#include <numeric>\n#include <algorithm>\n#include <map>\n#include <utility>\n#define enter putchar(10)\n#define debug(c,que) std::cerr << #c << \" = \" << c << que\n#define cek(c) puts(c)\n#define blow(arr,st,ed,w) for(register int i = (st);i <= (ed); ++ i) std::cout << arr[i] << w;\n#define speed_up() std::ios::sync_with_stdio(false),std::cin.tie(0),std::cout.tie(0)\n#define mst(a,k) memset(a,k,sizeof(a))\n#define stop return(0)\nconst int mod = 1e9 + 7;\ninline int MOD(int x) {\n\tif(x < 0) x += mod;\n\treturn x % mod;\n}\nnamespace Newstd {\n\tinline int read() {\n\t\tint ret = 0,f = 0;char ch = getchar();\n\t\twhile (!isdigit(ch)) {\n\t\t\tif(ch == '-') f = 1;\n\t\t\tch = getchar();\n\t\t}\n\t\twhile (isdigit(ch)) {\n\t\t\tret = (ret << 3) + (ret << 1) + ch - 48;\n\t\t\tch = getchar();\n\t\t}\n\t\treturn f ? -ret : ret;\n\t}\n\tinline void write(int x) {\n\t\tif(x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tif(x > 9) write(x / 10);\n\t\tputchar(x % 10 + '0');\n\t}\n}\nusing namespace Newstd;\nusing PII = std::pair<int,int>;\n\nconst int N = 1e5 + 5;\nstruct Ask {\n\tint opt,x,y;\n} ask[N];\nstruct Graph {\n\tint v,nxt;\n\tbool vis;\n} gra[N << 1];\nint head[N],ans[N],dfn[N],siz[N],top[N],fa[N],dep[N],son[N];\nstd::map<PII,int>mp;\nint n,m,idx,num;\ninline void add(int u,int v) {\n\tgra[++ idx].v = v,gra[idx].nxt = head[u],gra[idx].vis = false,head[u] = idx;\n\tmp[std::make_pair(u,v)] = idx;\n}\nstruct Segment_Tree {\n\tstruct Node {\n\t\tint l,r;\n\t\tint tag,sum;\n\t} node[N << 2];\n\t#define lson (p << 1)\n\t#define rson (p << 1 | 1)\n\tinline void pushup(int p) {\n\t\tnode[p].sum = node[lson].sum + node[rson].sum;\n\t}\n\tinline void build(int p,int l,int r) {\n\t\tnode[p].l = l,node[p].r = r;\n\t\tif (l == r) {\n\t\t\tnode[p].sum = 1;\n\t\t\treturn;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tbuild(lson,l,mid),build(rson,mid + 1,r);\n\t\tpushup(p);\n\t}\n\tinline void pushdown(int p) {\n\t\tif (node[p].tag) {\n\t\t\tnode[lson].sum = node[rson].sum = 0;\n\t\t\tnode[lson].tag = node[rson].tag = node[p].tag;\n\t\t\tnode[p].tag = 0;\n\t\t}\n\t}\n\tinline void update(int x,int y,int p,int k) {\n\t\tif (x <= node[p].l && node[p].r <= y) {\n\t\t\tnode[p].sum = k,node[p].tag = 1;\n\t\t\treturn;\n\t\t}\n\t\tpushdown(p);\n\t\tint mid = node[p].l + node[p].r >> 1;\n\t\tif (x <= mid) update(x,y,lson,k);\n\t\tif (y > mid) update(x,y,rson,k);\n\t\tpushup(p);\n\t}\n\tinline int query(int x,int y,int p) {\n\t\tif (x <= node[p].l && node[p].r <= y) {\n\t\t\treturn node[p].sum;\n\t\t}\n\t\tpushdown(p);\n\t\tint mid = node[p].l + node[p].r >> 1,res = 0;\n\t\tif (x <= mid) res += query(x,y,lson); \n\t\tif (y > mid) res += query(x,y,rson);\n\t\treturn res;\n\t}\n\t#undef lson\n\t#undef rson\n} seg;\nstruct chain {\n\tinline void dfs1(int now,int fath,int depth) {\n\t\tfa[now] = fath,dep[now] = depth,siz[now] = 1;\n\t\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\t\tint v = gra[i].v;\n\t\t\tif (siz[v] == 0 && gra[i].vis == false) {\n\t\t\t\tdfs1(v,now,depth + 1);\n\t\t\t\tsiz[now] += siz[v];\n\t\t\t\tif (siz[son[now]] < siz[v]) {\n\t\t\t\t\tson[now] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline void dfs2(int now,int topf) {\n\t\ttop[now] = topf,dfn[now] = ++ num;\n\t\tif (son[now]) {\n\t\t\tdfs2(son[now],topf);\n\t\t\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\t\t\tint v = gra[i].v;\n\t\t\t\tif (top[v] == 0 && v != son[now] && gra[i].vis == false) {\n\t\t\t\t\tdfs2(v,v); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline void update(int x,int y,int k) {\n\t\twhile (top[x] != top[y]) {\n\t\t\tif (dep[top[x]] < dep[top[y]]) std::swap(x,y);\n\t\t\tseg.update(dfn[top[x]],dfn[x],1,k);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif (dep[x] > dep[y]) std::swap(x,y);\n\t\tif (dep[x] != dep[y]) {\n\t\t\tseg.update(dfn[x] + 1,dfn[y],1,k);\n\t\t}\n\t}\n\tinline void dfs3(int now) {\n\t\tfor (register int i = head[now];i;i = gra[i].nxt) {\n\t\t\tint v = gra[i].v;\n\t\t\tif (gra[i].vis == false) {\n\t\t\t\tif (fa[v] == now) {\n\t\t\t\t\tdfs3(v);\n\t\t\t\t}\n\t\t\t\t//\u6ca1\u6709\u52a0\u5165 dfs \u6811\u4e2d\u7684\u90a3\u4e9b\u8fb9\n\t\t\t\tif (fa[now] != v && dep[v] < dep[now]) {\n\t\t\t\t\tupdate(now,v,0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int query(int x,int y) {\n\t\tint res = 0;\n\t\twhile (top[x] != top[y]) {\n\t\t\tif (dep[top[x]] < dep[top[y]]) std::swap(x,y);\n\t\t\tres += seg.query(dfn[top[x]],dfn[x],1);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif (dep[x] > dep[y]) std::swap(x,y);\n\t\tif (dep[x] != dep[y]) {\n\t\t\tres += seg.query(dfn[x] + 1,dfn[y],1);\n\t\t}\n\t\treturn res;\n\t}\n} ch;\nint main(void) {\n\tn = read(),m = read();\n\tfor (register int i = 1;i <= m; ++ i) {\n\t\tint u = read(),v = read();\n\t\tadd(u,v),add(v,u);\n\t}\n\tint asks = 0;\n\twhile (true) {\n\t\tint opt = read();\n\t\tif (opt == -1) break;\n\t\tint x = read(),y = read();\n\t\task[++ asks] = (Ask){opt,x,y};\n\t\tif (opt == 0) {\n\t\t\tgra[mp[std::make_pair(x,y)]].vis = gra[mp[std::make_pair(y,x)]].vis = true;\n\t\t}\n\t}\n\tch.dfs1(1,0,1),ch.dfs2(1,1),seg.build(1,1,n),ch.dfs3(1);\n\tfor (register int i = asks;i >= 1; -- i) {\n\t\tint x = ask[i].x,y = ask[i].y;\n\t\tif (ask[i].opt == 0) {\n\t\t\tch.update(x,y,0);\n\t\t} else {\n\t\t\tans[i] = ch.query(x,y);\n\t\t}\n\t}\n\tfor (register int i = 1;i <= asks; ++ i) {\n\t\tif (ask[i].opt == 1) {\n\t\t\tprintf(\"%d\\n\",ans[i]);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```",
        "postTime": 1653235294,
        "uid": 430409,
        "name": "Coros_Trusds",
        "ccfLevel": 6,
        "title": "P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212"
    },
    {
        "content": "\u52a8\u6001\u6811\u7ef4\u62a4\u53cc\u8fde\u901a\u5206\u91cf\uff08\u6240\u4ee5\u6807\u7b7e\u4e2d\u7684 `\u5f3a\u8fde\u901a\u5206\u91cf` \u9519\u4e86\uff09\u3002\n\n## \u9898\u76ee\u5927\u610f\n\u7ed9\u51fa\u4e00\u5f20 $n$ \u4e2a\u8282\u70b9 $m$ \u6761\u8fb9\u7684\u65e0\u5411\u8fde\u901a\u56fe\uff0c\u7ed9\u51fa\u82e5\u5e72\u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e3a\u4e0b\u9762\u4e24\u79cd\u4e4b\u4e00\uff1a\n\n0. \u5c06 $(u, v)$ \u4e4b\u95f4\u7684\u8fde\u8fb9\u5207\u65ad\uff1b\n1. \u8be2\u95ee $u\\to v$ \u7684\u8def\u5f84\u4e0a\u6709\u591a\u5c11\u6761\u5fc5\u7ecf\u8fb9\uff08\u201c\u5173\u952e\u822a\u7ebf\u201d\uff0c\u5373\u6865\u8fb9\uff09\u3002\n\n## \u5927\u4f53\u601d\u8def\n\u53c2\u8003 [P1197 \u661f\u7403\u5927\u6218](https://www.luogu.com.cn/problem/P1197) \u53ef\u77e5\uff0c\u52a0\u8fb9\u7ef4\u62a4\u8fde\u901a\u6027\u663e\u7136\u6bd4\u5220\u8fb9\u66f4\u52a0\u5bb9\u6613\uff0c\u56e0\u6b64\u6211\u4eec\u5c06\u6240\u6709\u64cd\u4f5c\u79bb\u7ebf\uff0c\u5012\u5e8f\u5904\u7406\u3002\u6b64\u5916\uff0c\u672c\u9898\u9700\u8981\u6c42\u6865\u8fb9\u7684\u6570\u91cf\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u6309\u8fb9\u53cc\u8fde\u901a\u5206\u91cf\u7f29\u70b9\u4ee5\u540e\u5f62\u6210\u7684\u6570\u4e0a\u4e24\u70b9\u95f4\u7684\u8ddd\u79bb\u3002\u6211\u4eec\u8003\u8651\u5229\u7528 LCT \u7ef4\u62a4\u8fd9\u68f5\u7f29\u70b9\u540e\u5f62\u6210\u7684\u6811\u3002\n\n\u5bf9\u4e8e\u4e00\u6b21 $op=0$ \u7684\u64cd\u4f5c\uff0c\u5012\u5e8f\u5904\u7406\u540e\u53d8\u4e3a\u52a0\u8fb9\u64cd\u4f5c\u3002\u5982\u679c\u52a0\u8fb9\u524d $x, y$ \u4e0d\u8fde\u901a\uff0c\u5219\u8fd9\u662f\u4e00\u6b21 LCT \u4e2d\u5e38\u89c4\u7684 $\\operatorname{link}$ \u64cd\u4f5c\uff1b\u5426\u5219\uff0c\u8bf4\u660e\u94fe $x\\to y$ \u5f62\u6210\u4e86\u4e00\u4e2a\u73af\uff0c\u9700\u8981\u5c06\u73af\u7f29\u70b9\u3002\u5177\u4f53\u5730\uff0c\u6211\u4eec\u5e76\u67e5\u96c6\u7ef4\u62a4\u6bcf\u4e2a\u8282\u70b9\u6240\u5c5e\u7684\u53cc\u8fde\u901a\u5206\u91cf\u7684\u7f16\u53f7\uff0c\u521d\u59cb $fa_i=i$\u3002\u901a\u8fc7 $\\text{dfs}$ \u4fee\u6539 $fa$ \u5e76\u9012\u5f52\u7f29\u70b9\u5373\u53ef\u3002\u6700\u540e\uff0c\u9700\u8981\u5220\u9664\u88ab\u7f29\u6389\u7684\u70b9\u3002\u7531\u4e8e $\\text{link}$ \u64cd\u4f5c\u9996\u5148\u8981 $\\text{makeroot}(x)$\uff0c\u53ea\u9700\u5220\u53bb $x$ \u7684\u53f3\u5b50\u6811\u5e76\u66f4\u65b0\u5373\u53ef\u3002\n\n\u540c\u7406\uff0c\u6700\u521d\u8fde\u63a5\u6240\u6709\u672a\u88ab\u5220\u9664\u7684\u8fb9\u4e5f\u7528\u8fd9\u79cd\u65b9\u6cd5\u3002\n\n\u5bf9\u4e8e\u4e00\u6b21 $op=1$ \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u5206\u7406\u5904 $x, y$ \u6240\u5728\u7684\u53cc\u8fde\u901a\u5206\u91cf $x', y'$ \u5f62\u6210\u7684\u94fe\u6761\uff0c\u7b54\u6848\u4e3a\u94fe\u6761\u957f\u5ea6\uff0c\u5373\u8282\u70b9\u6570 $-1$\u3002\u6700\u540e\u5012\u5e8f\u5904\u7406\u7b54\u6848\u5373\u53ef\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u672c\u9898\u4e2d\u6240\u6709\u7684\u4f38\u5c55\u6811\u4e4b\u95f4\u8df3\u8dc3\u5747\u662f\u6307\u53cc\u8fde\u901a\u5206\u91cf\u7684\u7f16\u53f7\uff0c\u56e0\u6b64 $\\text{access}(x)$ \u7684\u64cd\u4f5c\u4e2d\u9700\u8981\u66f4\u65b0 $x, \\text{fa\\_tree}(x)\\leftarrow \\text{find}(fa_x)$\u3002\n\n\u7531\u4e8e\u6240\u6709\u70b9\u6700\u591a\u88ab\u5220\u9664\u4e00\u6b21\uff0c\u5220\u9664\u64cd\u4f5c\u5747\u644a $O(1)$\uff0c$\\text{access}$ \u4e0e\u5e76\u67e5\u96c6\u590d\u6742\u5ea6\u76f8\u5f53\uff0c\u4e5f\u662f $O(\\log n)$\uff0c\u56e0\u6b64\u603b\u590d\u6742\u5ea6 $O(q\\log n)$\u3002\n\n## \u5b8c\u6574\u4ee3\u7801\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(ii,aa,bb) for(re int ii = aa; ii <= bb; ii++)\n#define Rep(ii,aa,bb) for(re int ii = aa; ii >= bb; ii--)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef pair<int, int> PII;\nconst int maxn = 1e5 + 5;\nnamespace IO_ReadWrite {\n\t#define re register\n\t#define gg (p1 == p2 && (p2 = (p1 = _buf) + fread(_buf, 1, 1<<21, stdin), p1 == p2) ? EOF :*p1++)\n\tchar _buf[1<<21], *p1 = _buf, *p2 = _buf;\n\ttemplate <typename T>\n\tinline void read(T &x){\n\t\tx = 0; re T f=1; re char c = gg;\n\t\twhile(c > 57 || c < 48){if(c == '-') f = -1;c = gg;}\n\t\twhile(c >= 48 &&c <= 57){x = (x<<1) + (x<<3) + (c^48);c = gg;}\n\t\tx *= f;return;\n\t}\n\tinline void ReadChar(char &c){\n\t\tc = gg;\n\t\twhile(!isalpha(c)) c = gg;\n\t}\n\ttemplate <typename T>\n\tinline void write(T x){\n\t\tif(x < 0) putchar('-'), x = -x;\n\t\tif(x > 9) write(x/10);\n\t\tputchar('0' + x % 10);\n\t}\n\ttemplate <typename T>\n\tinline void writeln(T x){write(x); putchar('\\n');}\n}\nusing namespace IO_ReadWrite;\nint n, m, q;\nstruct node {\n\tint son[2], fa, rev, sz;\n\t#define son(u, c) tr[u].son[c]\n} tr[maxn];\nint fa[maxn], ans[maxn], op[maxn];\nbool del[maxn];\nPII e[maxn], p[maxn];\ninline int find(int k) {\n\treturn (k == fa[k] ? k : fa[k] = find(fa[k]));\n}\ninline bool isroot(int x) {\n\treturn (son(tr[x].fa, 0) != x) && (son(tr[x].fa, 1) != x);\n}\ninline void pushup(int x) {\n\ttr[x].sz = tr[son(x, 0)].sz + tr[son(x, 1)].sz + 1;\n}\ninline void push_rev(int x) {\n\tif(!x) return ;\n\tswap(son(x, 0), son(x, 1));\n\ttr[x].rev ^= 1;\n}\ninline void pushdown(int x) {\n\tif(tr[x].rev) {\n\t\tpush_rev(son(x, 0));\n\t\tpush_rev(son(x, 1));\n\t\ttr[x].rev = 0;\n\t}\n}\ninline void rotate(int x) {\n\tint y = tr[x].fa, z = tr[y].fa;\n\tint c = (son(y, 0) == x);\n\tson(y, c ^ 1) = son(x, c); tr[son(x, c)].fa = y;\n\ttr[x].fa = z;\n\tif(!isroot(y)) son(z, son(z, 1) == y) = x;\n\tson(x, c) = y, tr[y].fa = x;\n\tpushup(y); pushup(x);\n}\nint stk[maxn], top;\ninline void splay(int x) {\n\tint u = x;\n\tstk[top = 1] = u;\n\twhile(!isroot(u)) stk[++top] = u = tr[u].fa;\n\twhile(top) pushdown(stk[top --]);\n\twhile(!isroot(x)) {\n\t\tint y = tr[x].fa, z = tr[y].fa;\n\t\tif(!isroot(y))\n\t\t\tif((son(y, 0) == x) ^ (son(z, 0) == y)) rotate(x);\n\t\t\telse rotate(y);\n\t\trotate(x);\n\t}\n}\ninline void access(int x) {\n\tint X = x;\n\tfor(int y = 0; x; y = x, x = tr[x].fa = find(tr[x].fa)) {\n\t\tsplay(x);\n\t\tson(x, 1) = y;\n\t\tpushup(x);\n\t}\n\tsplay(X);\n}\ninline void makeroot(int x) {\n\taccess(x);\n\tpush_rev(x);\n}\ninline int findroot(int x) {\n\taccess(x); pushdown(x);\n\twhile(son(x, 0)) pushdown(x = son(x, 0));\n\tsplay(x);\n\treturn x;\n}\ninline void split(int x, int y) {\n\tmakeroot(x);\n\taccess(y);\n}\ninline void dfs(int x, int f) { // \u9012\u5f52\u7f29\u70b9\n\tif(!x) return ;\n\tfa[x] = f;\n\tdfs(son(x, 0), f), dfs(son(x, 1), f);\n}\ninline void link(int x, int y) {\n\tx = find(x), y = find(y);\n\tif(x == y) return ; // \u5df2\u7ecf\u7f29\u70b9\n\tmakeroot(x);\n\tif(findroot(y) != x) tr[x].fa = y; // link\n\telse { // \u66b4\u529b\u7f29\u70b9\n\t\tdfs(son(x, 1), x);\n\t\tson(x, 1) = 0; // \u5220\u9664\n\t\tpushup(x);\n\t}\n}\nint main () {\n\tread(n); read(m);\n\trep(i, 1, n) tr[i].sz = 1, fa[i] = i;\n\trep(i, 1, m) {\n\t\tint u, v;\n\t\tread(u); read(v);\n\t\tif(u > v) swap(u, v);\n\t\te[i] = {u, v};\n\t}\n\tsort(e + 1, e + m + 1);\n\tfor(int i = 1; 1; i ++) {\n\t\tread(op[i]);\n\t\tif(op[i] == -1) break;\n\t\tq ++;\n\t\tint x, y;\n\t\tread(x); read(y);\n\t\tif(op[i] == 0) {\n\t\t\tif(x > y) swap(x, y);\n\t\t\tint id = lower_bound(e + 1, e + m + 1, make_pair(x, y)) - e;\n\t\t\tdel[id] = 1;\n\t\t} \n\t\tp[i] = {x, y};\n\t}\n\trep(i, 1, m) \n\t\tif(!del[i]) link(e[i].first, e[i].second);\n\tRep(i, q, 1) {\n\t\tint x = find(p[i].first), y = find(p[i].second);\n\t\tif(op[i] == 0) link(x, y);\n\t\telse {\n\t\t\tsplit(x, y);\n\t\t\tans[++ans[0]] = tr[y].sz - 1;\n\t\t}\n\t}\n\tRep(i, ans[0], 1) writeln(ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1645179440,
        "uid": 279197,
        "name": "Mars_Dingdang",
        "ccfLevel": 6,
        "title": "P2542 \u822a\u7ebf\u89c4\u5212"
    },
    {
        "content": "# Luogu P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212 \u9898\u89e3\n\n\u9898\u9762\u4f20\u9001\u95e8\uff1a[P2542 \u822a\u7ebf\u89c4\u5212](https://www.luogu.com.cn/problem/P2542)\u3002\n\n\u5efa\u8bae\u5728 [\u535a\u5ba2](https://www.luogu.com.cn/blog/fy123333/LuoguP2542Solution) \u4e2d\u9605\u8bfb\u3002~~\u540c\u65f6\u4e5f\u987a\u4fbf\u770b\u770b\u6211\u4e4b\u524d\u5199\u7684\u535a\u5ba2~~\u3002\n\n## \u9898\u76ee\u5206\u6790 Hint\n\n\u8bf4\u660e\u4e2d\u63d0\u793a\u4e86\uff1a\u65e0\u8bba\u822a\u7ebf\u5982\u4f55\u88ab\u7834\u574f\uff0c\u4efb\u610f\u65f6\u523b\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u90fd\u80fd\u591f\u76f8\u4e92\u5230\u8fbe\u3002\u5728\u6574\u4e2a\u6570\u636e\u4e2d\uff0c\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u4e4b\u95f4\u6700\u591a\u53ea\u53ef\u80fd\u5b58\u5728\u4e00\u6761\u76f4\u63a5\u7684\u822a\u7ebf\u3002\u4e14\u8be2\u95ee\u6b21\u6570\u8f83\u5c11\u3002\u6240\u4ee5\u6211\u4eec\u7528\u4e00\u4e2a\u7ebf\u6bb5\u6811+\u6811\u94fe\u5256\u5206\u3002\n\n## \u601d\u8def Solution\n\n\u9898\u76ee\u4fdd\u8bc1\u4e0d\u5b58\u5728\u91cd\u8fb9\uff0c\u800c\u4e14\u4e92\u76f8\u8fde\u901a\uff0c\u53c8\u662f\u65e0\u5411\u56fe\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\u7f29\u70b9\u4e4b\u540e\u7684\u56fe\u5c31\u662f\u4e00\u68f5\u6811\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u52a8\u6001\u5730\u7ef4\u62a4\u6811\u4e0a\u7684\u8ddd\u79bb\u5c31\u53ef\u4ee5\u4e86\u3002\u56e0\u4e3a\u8981\u52a8\u6001\u5730\u7ef4\u62a4\uff0c\u6240\u4ee5\u4e5f\u53ef\u4ee5\u7528\u52a8\u6001\u6811\u89e3\u51b3\uff0c\u6240\u4ee5\u6709\u4e00\u4e9b\u5927\u4f6c\u7528 Link Cut Tree \u505a\uff0c\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u800c\u4e14\u6211\u81ea\u5df1\u5199\u7684 LCT \u7684\u4ee3\u7801\u5176\u5b9e\u6bd4\u8fd9\u4e2a\u7ebf\u6bb5\u6811+\u6811\u5256\u8981\u5c11\uff0c\u53ea\u662f LCT \u8fd9\u4e2a\u77e5\u8bc6\u6709\u70b9\u96be\u3002\u8bdd\u8bf4\u56de\u6765\uff0c\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u8fde\u8d77\u6765\u7684\u662f\u8fb9\uff0c\u6240\u4ee5\u662f\u8981\u7ef4\u62a4\u4e24\u70b9\u4e4b\u95f4\u7684\u8fb9\u6743\u3002\u90a3\u4e48\u5f88\u81ea\u7136\u5730\u60f3\u5230\u6811\u94fe\u5256\u5206\uff0c\u800c\u4e14\u4e0d\u7528\u52a8\u6001\u7f29\u70b9\u3002\n\n\u5148\u6765\u8bb2\u4e00\u4e2a\u91cd\u8981\u7684\u77e5\u8bc6\uff1a**\u6811\u94fe\u5256\u5206**\u3002\n\n\u5bf9\u4e8e\u6811\u4e0a\u4efb\u610f\u4e00\u4e2a\u8282\u70b9 $u$\uff0c\u8bbe $siz_u$ \u662f $u$ \u6240\u5728\u7684\u5b50\u6811\u7684\u5927\u5c0f\u3002\u5728 $u$ \u7684\u5b69\u5b50\u4e2d\uff0c\u8bbe $u$ \u5b50\u6811\u7684\u6700\u5927\u5b69\u5b50 $wc_u$ (weightChild)\uff0c\u79f0\u4e3a $u$ \u7684\u91cd\u513f\u5b50\u3002\u5047\u8bbe\u5148\u8bbf\u95ee\u91cd\u513f\u5b50\uff0c\u518d\u8bbf\u95ee\u8f7b\u513f\u5b50\uff0c\u4ece\u6839\u8282\u70b9\u8d77\u5f00\u59cb\u8fdb\u884c `dfs()`\uff0c\u8bb0\u5f55\u6b64\u65f6\u7684 dfs \u5e8f\u3002\u80fd\u53d1\u73b0 $u$ \u548c $wc_u$ \u5728 dfs \u5e8f\u4e0a\u662f\u8fde\u7eed\u7684\u3002\n\n\u5982\u679c\u4e00\u4e2a\u8282\u70b9\u662f\u5b83\u7236\u8282\u70b9\u7684\u91cd\u513f\u5b50\uff0c\u6211\u4eec\u5c31\u53eb\u5b83\u91cd\u8282\u70b9\uff0c\u5426\u5219\u5c31\u662f\u8f7b\u8282\u70b9\uff08\u6839\u662f\u8f7b\u8282\u70b9\uff09\u3002\u4ece\u4e00\u4e2a\u975e\u91cd\u8282\u70b9\u5f00\u59cb\uff0c\u5411\u4e0b\u8bbf\u95ee\u5b83\u7684\u91cd\u513f\u5b50\uff0c\u518d\u9012\u5f52\u4e0b\u53bb\uff0c\u4e00\u76f4\u5230\u53f6\u5b50\u8282\u70b9\uff0c\u6784\u6210\u4e00\u6761\u94fe\u3002\u8fd9\u6761\u94fe\u4e0a\u7684\u8282\u70b9\u5728 dfs \u5e8f\u4e0a\u662f\u8fde\u7eed\u7684\uff0c\u5e76\u9664\u4e86\u7b2c\u4e00\u4e2a\u8282\u70b9\u4e4b\u5916\u662f\u91cd\u8282\u70b9\uff0c\u90a3\u4e48\u8fd9\u6761\u94fe\u5c31\u662f\u6811\u7684\u91cd\u94fe\u3002\u5426\u5219\u5c31\u662f\u8f7b\u8fb9\u3002\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/2qxnltvw.png)\n\n\u5728\u4e0a\u56fe\u4e2d $1-2-6-9$ \u662f\u4e00\u6761\u91cd\u94fe\uff0c$5-8$ \u4e5f\u662f\u3002\u7ec6\u7ebf\u662f\u8f7b\u8fb9\u3002\u800c\u89c2\u5bdf\u8fd9\u5f20\u56fe\u80fd\u53d1\u73b0\uff0c\u4efb\u610f\u4e24\u4e2a\u91cd\u94fe\u4e2d\u95f4\u6709\u81f3\u5c11\u4e00\u6761\u8f7b\u8fb9\u8fde\u63a5\u3002\u4e8e\u662f\u5c31\u6709\u4efb\u610f\u4e00\u4e2a\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u91cd\u94fe\u6761\u6570\u4e0d\u4f1a\u8d85\u8fc7\u8def\u5f84\u4e0a\u8f7b\u8fb9\u6570\u51cf $1$\u3002\u90a3\u4e48\u5c31\u6709\u5b9a\u7406 1\uff1a\u5b83\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u91cd\u94fe\u6761\u6570\u4e0d\u4f1a\u8d85\u8fc7 $\\log n$\uff0c\u8f7b\u8fb9\u7684\u6570\u91cf\u4e5f\u4e0d\u4f1a\u8d85\u8fc7 $\\log n$\u3002\n\n\u90a3\u4e48\u5c31\u53ef\u4ee5\u4ece\u8fd9\u4e2a\u5b9a\u7406\u5f97\u51fa\uff1a\u5bf9\u4e8e\u4e00\u4e2a\u4ece $x$ \u5230 $y$ \u7684\u4fee\u6539\uff0c\u8bbe $w$ \u662f $x, y$ \u7684 LCA\uff0c\u628a\u4fee\u6539\u7684\u8def\u5f84\u62c6\u6210\u4e24\u6761\uff1a$x-w$ \u548c $w-y$\uff0c\u7136\u540e\u80fd\u770b\u51fa\u53ea\u8981\u505a\u51fa $O(\\log n)$ \u6b21\u7684\u533a\u95f4\u4fee\u6539\u5c31\u80fd\u5b8c\u6210\u4e86\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u8fc7\u7a0b\u5c31\u662f\u8bb0\u5f55\u6bcf\u4e00\u4e2a\u91cd\u94fe\u7684\u94fe\u5934 $top$\uff0c\u8bbe $dfn_u$ \u4e3a $u$ \u5728 dfs \u5e8f\u7684\u4e0b\u6807\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u4fee\u6539 $[dfn_x, dfn_{top_x}]$ \u7684\u70b9\u6743\uff0c\u7136\u540e\u4ee4 $x$ \u4e3a\u94fe\u5934\u7684\u7236\u8282\u70b9\u3002\u91cd\u590d\u64cd\u4f5c\u77e5\u9053 $w$ \u5728\u5f53\u524d\u7684\u94fe\u4e0a\uff0c\u90a3\u4e48\u53ea\u8981\u4fee\u6539 $w-x$ \u8fd9\u6bb5\u533a\u95f4 $[dfn_x, dfn_w]$ \u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6700\u540e\u6765\u68b3\u7406\u4e00\u4e0b\u8fc7\u7a0b\uff1a\n\n1. \u8f93\u5165\u6240\u6709\u64cd\u4f5c\u3002\n2. \u79bb\u7ebf\u9006\u5e8f\u5904\u7406\u3002\n3. \u968f\u4fbf\u5728\u56fe\u4e0a\u751f\u6210\u6811\uff0c\u6b63\u5e38\u6765\u8bf4\u7528\u7684\u662f dfs \u5e8f\uff08\u56e0\u4e3a\u8fd9\u4e2a\u4f1a\u8212\u670d\u4e00\u70b9\uff09\u3002\n4. \u66f4\u65b0\u8fb9\u6743\u3002\n5. \u7ecf\u5178\u6811\u94fe\u5256\u5206\u3002\n\n## \u6ce8\u610f\u4e8b\u9879 Notice\n\n\u8fd9\u91cc\u9762\u53ef\u80fd\u4f1a\u6709\u8bef\u5220\u7684\u8fb9\uff0c\u6240\u4ee5\u8981\u52a0\u7b2c\u4e09\u904d   `dfs3()`\uff0c\u628a\u8bef\u5220\u7684\u8fb9\u52a0\u56de\u6765\u3002\n\n## \u4ee3\u7801\u90e8\u5206 Code\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 4e4 + 10, maxm = 1e5 + 10;\nint n, m, a, b, x, y, z, cnt1, cnt2, cnt3, total;\nint res[maxn], head[maxn], siz[maxn], fa[maxn], depth[maxn], son[maxn], id[maxn], top[maxn], tree[maxn << 2], lazyTag[maxn << 2];\n// \u6b64\u5904\u7701\u7565\u5feb\u8bfb\u5feb\u5199\u7684\u5b9e\u73b0\nstruct SegmentTree {\n    int v, nxt, dist;\n}segTree[maxm << 1];\nstruct Node {\n    int oper, a, b;\n}q[maxn];\ninline void add(int u, int v) {\n    segTree[++cnt2] = (SegmentTree){v, head[u]};\n    head[u] = cnt2;\n}\ninline void pushUp(int root) {\n    tree[root] = tree[root << 1] + tree[root << 1 | 1];\n}\ninline void pushDown(int root) {\n    lazyTag[root << 1] = lazyTag[root << 1 | 1] = 1;\n    tree[root << 1] = tree[root << 1 | 1] = lazyTag[root] = 0;\n}\ninline void buildTree(int lft, int rgt, int root) {\n    if (lft == rgt){\n        tree[root] = 1;\n        return;\n    }\n    int mid = (lft + rgt) >> 1;\n    buildTree(lft, mid, root << 1);\n    buildTree(mid+1, rgt, root << 1 | 1);\n    pushUp(root);\n}\ninline void update(int lft, int rgt, int l, int r, int root) {\n    if (lft <= l && r <= rgt) {\n        tree[root] = 0, lazyTag[root] = 1;\n        return;\n    }\n    if (lazyTag[root]) pushDown(root);\n    int mid = (l + r) >> 1;\n    if (lft <= mid){\n        update(lft, rgt, l, mid, root << 1);\n    }\n    if (mid < rgt){\n        update(lft, rgt, mid+1, r, root << 1 | 1);\n    }\n    pushUp(root);\n}\ninline int query(int lft, int rgt, int l, int r, int root) {\n    if (lft <= l && r <= rgt) {\n        return tree[root];\n    }\n    if (lazyTag[root]) {\n        pushDown(root);\n    }\n    int mid = (l + r) >> 1, sum = 0;\n    if (lft <= mid) {\n        sum += query(lft, rgt, l, mid, root << 1);\n    }\n    if (mid < rgt) {\n        sum += query(lft, rgt, mid+1, r, root << 1 | 1);\n    }\n    return sum;\n}\n// \u4e0a\u9762\u771f\u7684\u5c31\u662f\u7ebf\u6bb5\u6811\u7684\u677f\u5b50\uff0c\u51e0\u4e4e\u4e00\u70b9\u4e0d\u5e26\u6539\u7684\ninline void dfs1(int u, int va) { // \u7b2c\u4e00\u904d DFS \u7528\u6765\u5efa\u6811\n    fa[u] = va;\n    siz[u] = 1;\n    depth[u] = depth[va]+1;\n    for (int i = head[u];~i;i = segTree[i].nxt) {\n        int v = segTree[i].v;\n        if (siz[v] || segTree[i].dist) continue;\n        dfs1(v, u);\n        siz[u] += siz[v];\n        if (siz[son[u]] < siz[v]) {\n            son[u] = v;\n        }\n    }\n}\ninline void dfs2(int u, int an) { // \u7b2c\u4e8c\u904d\u5219\u662f\u6811\u5256\n    id[u] = ++cnt1;\n    top[u] = an;\n    if (!son[u]) return;\n    dfs2(son[u], an);\n    for (int i = head[u];~i;i = segTree[i].nxt){\n        int v = segTree[i].v;\n        if (fa[v] != u || v == son[u] || segTree[i].dist) continue;\n        dfs2(v, v);\n    }\n}\ninline void dfs3(int u) { // \u8865\u56de\u4e4b\u524d\u8bef\u5220\u7684\u8fb9\n    for (int i = head[u];~i;i = segTree[i].nxt) {\n        int v = segTree[i].v;\n        if (segTree[i].dist) continue;\n        if (fa[v] == u) dfs3(v);\n        else {\n            if (depth[u] < depth[v]) {\n                mark(u, v);\n            }\n        }\n    }\n}\ninline void mark(int a, int b) {\n    while (top[a] != top[b]) {\n        if (depth[top[a]] < depth[top[b]]) {\n            swap(a, b);\n        }\n        update(id[top[a]], id[a], 1, n, 1);\n        a = fa[top[a]];\n    }\n    if(depth[a] < depth[b]){\n        swap(a, b);\n    }\n    update(id[b]+1, id[a], 1, n, 1);\n}\nint main() {\n    n = quickRead(), m = quickRead();\n    memset(head, -1, sizeof(head));\n    for (int i = 1;i <= m;++i){\n        a = quickRead(), b = quickRead();\n        addEdge(a, b), addEdge(b, a);\n    }\n    for (;;) {\n        x = quickRead();\n        if (x == -1) break;\n        y = quickRead(), z = quickRead();\n        q[++cnt3] = (Node){x, y, z};\n        if (x) continue;\n        for (int i = head[y];~i;i = segTree[i].nxt) {\n            if (segTree[i].v == z) {\n                segTree[i].dist = 1;\n                break;\n            }\n        }\n        for (int i = head[z];~i;i = segTree[i].nxt) {\n            if (segTree[i].v == y) {\n                segTree[i].dist = 1;\n                break;\n            }\n        }\n    }\n    dfs1(1, 0);\n    dfs2(1, 1);\n    buildTree(1, n, 1);\n    dfs3(1);\n    for (int i = cnt3;i >= 1;--i){\n        a = q[i].a, b = q[i].b;\n        if (!q[i].oper) {\n\t\t\tmark(a, b), res[i] = -1;\n        } else {\n\t\t\twhile (top[a] != top[b]) {\n\t\t\t\tif (depth[top[a]] < depth[top[b]]) swap(a, b);\n\t\t\t    res[i] += query(id[top[a]], id[a], 1, n, 1);\n\t\t\t\ta = fa[top[a]];\n\t\t\t}\n\t\t\tif (depth[a] < depth[b]) swap(a, b);\n\t\t\tres[i] += query(id[b]+1, id[a], 1, n, 1); \n\t\t}\n    }\n    for (int i = 1;i <= cnt3;++i) {\n        if (res[i] != -1) quickWrite(res[i], '\\n');\n    }\n    return 0;\n}\n```\n\n\u672c\u849f\u84bb\u7684\u7b2c\u4e00\u7bc7\u9898\u89e3\uff08\u559c\uff09\u3002\n",
        "postTime": 1683353560,
        "uid": 589977,
        "name": "fy123333",
        "ccfLevel": 0,
        "title": "Luogu P2542 \u9898\u89e3"
    },
    {
        "content": "\n\u9996\u5148\u5957\u8def\u79bb\u7ebf\u5220\u8fb9\u8f6c\u52a0\u8fb9\u3002\n\n\u6ce8\u610f\u5230\u6bcf\u4e24\u4e2a\u70b9\u4e4b\u95f4\u6700\u591a\u53ea\u6709\u4e00\u6761\u8def\u5f84\uff0c\u6240\u4ee5\u8fb9\u53cc\u7f29\u70b9\u4e4b\u540e\u4e00\u5b9a\u662f\u4e00\u68f5\u6811\uff0c\u63a5\u7740\u53ea\u8981\u7ef4\u62a4\u6811\u4e0a\u8ddd\u79bb\u5c31\u884c\u4e86\u3002\u6bcf\u6b21\u8be2\u95ee\u90fd\u8dd1\u4e00\u904d $\\mathrm{Tarjan}$ \u662f $\\mathcal O(nq)$ \u7684 \uff08 $q$ \u662f\u8be2\u95ee\u6b21\u6570 \uff09\uff0c\u4e0d\u80fd\u63a5\u53d7\u3002\n\n\u6ce8\u610f\u5230\u56fe\u53ef\u4ee5\u53d8\u4e3a\u4e00\u68f5\u6811 + \u82e5\u5e72\u4e2a\u73af\uff0c\u73af\u4e0a\u7684\u8d21\u732e\u663e\u7136\u4e3a $0$\u3002\u800c\u6bcf\u6b21\u52a0\u8fb9\u4e00\u5b9a\u53ea\u4f1a\u628a\u5173\u952e\u8fb9\u53d8\u4e3a\u975e\u5173\u952e\u8fb9\uff0c\u800c\u4e0d\u4f1a\u628a\u975e\u5173\u952e\u8fb9\u53d8\u4e3a\u5173\u952e\u8fb9\u3002\n\n\u6240\u4ee5\u53ef\u4ee5\u5148\u968f\u4fbf\u627e\u51fa\u4e00\u68f5\u751f\u6210\u6811\uff0c\u9006\u5e8f\u5904\u7406\u64cd\u4f5c\u8be2\u95ee\uff0c\u6bcf\u6b21\u52a0\u8fb9\u65f6\u628a\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u53d8\u4e3a $0$\uff0c\u7528\u6811\u94fe\u5256\u5206\u7ef4\u62a4\u8fb9\u6743\u548c\uff0c\u6700\u540e\u9006\u5e8f\u8f93\u51fa\u7b54\u6848\u5c31\u505a\u5b8c\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$\\mathcal{O}(q \\log^2 n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e4+5;\nconst int M = 1e5+5;\nmap<pair<int,int>,int> mp;\nstruct edge{\n\tint to,nxt;\n\tbool vis;\n} e[M<<1];\nint head[N],cnt;\ninline void add(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n\tmp[make_pair(u,v)]=cnt;\n}\nint n,m;\nint id[N],top[N],fa[N],son[N],siz[N],dep[N],idx;\nvoid dfs1(int u,int f)\n{\n\tfa[u]=f; dep[u]=dep[f]+1; siz[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tif(siz[v]||e[i].vis) continue;\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]]) son[u]=v;\n\t}\n}\nvoid dfs2(int u,int tp)\n{\n\ttop[u]=tp; id[u]=++idx;\n\tif(son[u]) dfs2(son[u],tp);\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tif(id[v]||e[i].vis||v==son[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\n\nint sum[N<<2],tag[N<<2];\nvoid push_up(int p){sum[p]=sum[p<<1]+sum[p<<1|1];}\nvoid build(int p,int l,int r)\n{\n\tif(l==r){sum[p]=1;return;}\n\tint mid=(l+r)>>1;\n\tbuild(p<<1,l,mid); build(p<<1|1,mid+1,r);\n\tpush_up(p);\n}\nvoid push_down(int p)\n{\n\tif(tag[p])\n\t{\n\t\ttag[p<<1]=tag[p<<1|1]=tag[p];\n\t\tsum[p<<1]=sum[p<<1|1]=0;\n\t\ttag[p]=0;\n\t}\n}\nvoid modify(int p,int l,int r,int L,int R)\n{\n\tif(L<=l&&r<=R){tag[p]=1;sum[p]=0;return;}\n\tint mid=(l+r)>>1; push_down(p);\n\tif(L<=mid) modify(p<<1,l,mid,L,R);\n\tif(R>mid) modify(p<<1|1,mid+1,r,L,R);\n\tpush_up(p);\n}\nint query(int p,int l,int r,int L,int R)\n{\n\tif(L<=l&&r<=R) return sum[p];\n\tint mid=(l+r)>>1,ret=0;\n\tpush_down(p);\n\tif(L<=mid) ret+=query(p<<1,l,mid,L,R);\n\tif(R>mid) ret+=query(p<<1|1,mid+1,r,L,R);\n\treturn ret;\n}\nvoid UpdRange(int u,int v)\n{\n\twhile(top[u]^top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tmodify(1,1,n,id[top[u]],id[u]);\n\t\tu=fa[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tif(dep[u]!=dep[v]) modify(1,1,n,id[u]+1,id[v]);\n}\nint QryRange(int u,int v)\n{\n\tint ret=0;\n\twhile(top[u]^top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tret+=query(1,1,n,id[top[u]],id[u]);\n\t\tu=fa[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tret+=query(1,1,n,id[u]+1,id[v]);\n\treturn ret;\n}\nvoid dfs3(int u)\n{\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tif(e[i].vis) continue;\n\t\tif(fa[v]==u) dfs3(v);\n\t\tif(fa[u]!=v&&dep[v]<dep[u]) UpdRange(v,u);\n\t}\n}\nstruct Query{\n\tint id,opt,u,v;\n} q[N]; int len,ans[N];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1,u,v;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v); add(v,u);\n\t}\n\twhile(1)\n\t{\n\t\tint opt,u,v;\n\t\tscanf(\"%d\",&opt);\n\t\tif(opt==-1) break;\n\t\tlen++; q[len].id=len;\n\t\tq[len].opt=opt;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tq[len].u=u; q[len].v=v;\n\t\tif(opt==0) e[mp[make_pair(u,v)]].vis=e[mp[make_pair(v,u)]].vis=1;\n\t}\n\tdfs1(1,0); dfs2(1,1);\n\tbuild(1,1,n);\n\tdfs3(1);\n\tfor(int i=len;i>=1;i--)\n\t\tif(q[i].opt==1) ans[i]=QryRange(q[i].u,q[i].v);\n\t\telse UpdRange(q[i].u,q[i].v);\n\tfor(int i=1;i<=len;i++) if(q[i].opt==1) printf(\"%d\\n\",ans[i]);\n}\n```",
        "postTime": 1664006203,
        "uid": 280473,
        "name": "404Not_Found",
        "ccfLevel": 5,
        "title": "P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212"
    },
    {
        "content": "**\u9898\u610f**\n\n\u7ed9\u5b9a\u4e00\u4e2a $n$ \u4e2a\u70b9 $m$ \u6761\u8fb9\u7684\u56fe\uff0c\u6709\u4e0d\u8d85\u8fc7 $40000$ \u6b21\u7684\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u6709\u4e09\u4e2a\u53c2\u6570 $op, u, v$\n\n\u82e5 $op =0$ \uff0c\u8868\u793a\u5220\u9664\u70b9 $u,v$ \u4e4b\u95f4\u7684\u8fb9\n\n\u82e5 $op = 1$\uff0c\u8868\u793a\u8be2\u95ee $u, v$ \u4e4b\u95f4\u6709\u591a\u5c11**\u5173\u952e\u8fb9**\n\n**\u5173\u952e\u8fb9\uff1a** $u, v$ \u8054\u901a\uff0c\u82e5\u5220\u9664\u8be5\u8fb9 $u, v$ \u4e0d\u8fde\u901a\uff0c\u5219\u4e3a\u5173\u952e\u8fb9\n\n**\u5206\u6790\uff1a**\n\n\u6700\u6734\u7d20\u7684\u60f3\u6cd5\u662f\u6bcf\u6b21\u5220\u5b8c\u8fb9\u4e4b\u540e $\\text{tarjan}$ \u7f29\u70b9\uff0c\u518d\u7ef4\u62a4\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\uff0c\u4f46\u8fd9\u6837\u663e\u7136\u4f1a\u8d85\u65f6\u3002\n\n\u6240\u4ee5\u8003\u8651\u9006\u5e8f\u79bb\u7ebf\u5904\u7406\u3002\n\n\u6211\u4eec\u53d1\u73b0\u5982\u679c\u662f\u4e00\u68f5\u6811\uff0c\u90a3\u4e48\u6240\u6709\u7684\u8fb9\u90fd\u662f\u5173\u952e\u8fb9\uff0c$u, v$ \u4e24\u70b9\u7684\u5173\u952e\u8fb9\u6570\u91cf\u5c31\u7b49\u4e8e $u, v$ \u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\u3002\u5e76\u4e14\u5728\u6811\u4e0a\u4efb\u610f\u4e24\u70b9\u52a0\u4e00\u6761\u8fb9\u90fd\u4f1a\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u73af\u5185\u6240\u6709\u7684\u8fb9\u90fd\u4e0d\u53ef\u80fd\u6210\u4e3a\u5173\u952e\u8fb9\uff0c\u6240\u4ee5\u6b64\u65f6\u53ea\u9700\u8981\u5c06\u8fd9\u4e24\u70b9\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u6761\u8fb9\u7684\u6743\u503c\u90fd\u53d8\u4e3a $0$ \uff0c\u8fd9\u4e2a\u64cd\u4f5c\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u5148\u5728\u56fe\u4e2d\u968f\u610f\u627e\u4e00\u9897\u751f\u6210\u6811\uff0c\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\uff0c\u628a\u8fd9\u4e9b\u6811\u8fb9\u6807\u8bb0\u4e00\u4e0b\uff0c\u90a3\u4e48\u5176\u4ed6\u672a\u6807\u8bb0\u7684\u8fb9\u5c31\u662f\u8981\u6210\u73af\u7684\u8fb9\uff0c\u4e5f\u5c31\u662f\u8981\u8fdb\u884c\u8def\u5f84\u4e0a\u8d4b\u503c\u4e3a $0$ \u7684\u70b9\u5bf9\u3002\n\n\u4e4b\u540e\u8bfb\u5165\u64cd\u4f5c\uff0c\u628a\u8981\u5220\u9664\u7684\u8fb9\u4ee5\u70b9\u5bf9\u7684\u5f62\u5f0f\u7528 $\\text{STL map}$ \u7ef4\u62a4\uff0c\u8fd9\u4e9b\u70b9\u5bf9\u76f8\u5f53\u4e8e**\u8986\u76d6**\u4e00\u5f00\u59cb\u8981\u8fdb\u884c\u8def\u5f84\u4e0a\u8d4b\u503c\u4e3a $0$ \u7684\u70b9\u5bf9\uff0c\u6700\u540e\u9006\u5e8f\u5730\u5904\u7406\u8be2\u95ee\uff0c\u9006\u5e8f\u8f93\u51fa\u7ed3\u679c\u5373\u53ef\u3002\n\n## \u4ee3\u7801\uff1a\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define x first\n#define y second\n#define PII pair<int, int>\nusing namespace std;\nconst int N = 1e5 + 5, M = N << 1;\nint n, m, u[N], v[N], op, cnt, h[N], e[M], ne[M], idx, Size[N], top[N], dep[N], fa[N], son[N], id[N], Cnt, p[N];\nbool st[N];\nmap<PII, int> mp;\nvector<int> ans;\nstruct Query {\n    int op, u, v;\n} q[N];\nstruct SegmentTree {\n    int l, r, add, sum;\n} tr[N << 2];\nint find(int x) {\n    return p[x] == x ? p[x] : p[x] = find(p[x]);\n}\nvoid add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;\n}\nvoid dfs1(int u, int father, int depth) {\n    dep[u] = depth, fa[u] = father, Size[u] = 1;\n    for (int i = h[u]; ~i; i = ne[i]) {\n        int j = e[i];\n        if (j == father) continue;\n        dfs1(j, u, depth + 1);\n        Size[u] += Size[j];\n        if (Size[son[u]] < Size[j]) son[u] = j;\n    }\n}\nvoid dfs2(int u, int t) {\n    id[u] = ++ Cnt, top[u] = t;\n    if (!son[u]) return ;\n    dfs2(son[u], t);\n    for (int i = h[u]; ~i; i = ne[i]) {\n        int j = e[i];\n        if (j == fa[u] || j == son[u]) continue;\n        dfs2(j, j);\n    }\n}\nvoid pushup(int u) {\n    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;\n}\nvoid pushdown(int u) {\n    if (tr[u].add != -1) {\n        tr[u << 1].add = tr[u << 1 | 1].add = tr[u].add;\n        tr[u << 1].sum = (tr[u << 1].r - tr[u << 1].l + 1) * tr[u].add;\n        tr[u << 1 | 1].sum = (tr[u << 1 | 1].r - tr[u << 1 | 1].l + 1) * tr[u].add;\n        tr[u].add = -1;\n    }\n}\nvoid build(int u, int l, int r) {\n    if (l == r) {\n        tr[u] = {l, r, -1, 1};\n    } else {\n        tr[u] = {l, r, -1};\n        int mid = l + r >> 1;\n        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);\n        pushup(u);\n    }\n}\nvoid modify(int u, int l, int r, int c) {\n    if (tr[u].l >= l && tr[u].r <= r) {\n        tr[u].add = c;\n        tr[u].sum = (tr[u].r - tr[u].l + 1) * c;\n        return ;\n    }\n    pushdown(u);\n    int mid = tr[u].l + tr[u].r >> 1;\n    if (l <= mid) modify(u << 1, l, r, c);\n    if (r > mid) modify(u << 1 | 1, l, r, c);\n    pushup(u);\n}\nint ask(int u, int l, int r) {\n    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;\n    pushdown(u);\n    int mid = tr[u].l + tr[u].r >> 1, res = 0;\n    if (l <= mid) res += ask(u << 1, l, r);\n    if (r > mid) res += ask(u << 1 | 1, l, r);\n    return res;\n}\nvoid modify_path(int u, int v, int k) {\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        modify(1, id[top[u]], id[u], k);\n        u = fa[top[u]];\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    modify(1, id[v] + 1, id[u], k);\n}\nint ask_path(int u, int v) {\n    int res = 0;\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        res += ask(1, id[top[u]], id[u]);\n        u = fa[top[u]];\n    }\n    if (dep[u] < dep[v]) swap(u, v);\n    res += ask(1, id[v] + 1, id[u]);\n    return res;\n}\nsigned main() {\n    memset(h, -1, sizeof h);\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) p[i] = i;\n    for (int i = 1; i <= m; i ++) cin >> u[i] >> v[i];\n    for (int i = 1; i <= m; i ++) {\n        int pu = find(u[i]), pv = find(v[i]);\n        if (pu != pv) {\n            p[pu] = pv;\n            add(u[i], v[i]), add(v[i], u[i]);\n            st[i] = 1;\n        }\n    }\n    dfs1(1, -1, 1), dfs2(1, 1);\n    build(1, 1, n);\n    while (1) {\n        cin >> op;\n        if (op == -1) break;\n        cnt ++;\n        q[cnt].op = op;\n        cin >> q[cnt].u >> q[cnt].v;\n    }\n    for (int i = 1; i <= cnt; i ++) {\n        if (!q[i].op) {\n            mp[{q[i].u, q[i].v}] = mp[{q[i].v, q[i].u}] = 1;\n        }\n    }\n    for (int i = 1; i <= m; i ++) {\n        if (!st[i] && !mp[{u[i], v[i]}]) {\n            modify_path(u[i], v[i], 0);\n        }\n    }\n    for (int i = cnt; i; i --) {\n        if (!q[i].op) {\n            modify_path(q[i].u, q[i].v, 0);\n        } else if (q[i].op == 1) {\n            ans.push_back(ask_path(q[i].u, q[i].v));\n        }\n    }\n    for (int i = ans.size() - 1; ~i; i --) cout << ans[i] << endl;\n}\n```",
        "postTime": 1640870973,
        "uid": 133351,
        "name": "Messywind",
        "ccfLevel": 0,
        "title": "[AHOI2015] \u822a\u7ebf\u89c4\u5212 (\u79bb\u7ebf \u6811\u94fe\u5256\u5206)"
    },
    {
        "content": "\u5220\u9664\u8fb9\u4e0d\u597d\u505a\uff0c\u8003\u8651\u5c06\u64cd\u4f5c\u79bb\u7ebf\u5012\u7740\u52a0\u8fb9\u3002\n\n\u8003\u8651\u8fde\u8fb9\u65f6\u7ef4\u62a4\u5272\u8fb9\u3002\n\n- $u,v$ \u4e0d\u8054\u901a\uff0c\u76f4\u63a5\u8fde\u4e0a\u5373\u53ef\uff0c\u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u6761\u8fb9\u662f\u5272\u8fb9\u3002\n\n- $u,v$ \u5df2\u7ecf\u8054\u901a\uff0c\u8bf4\u660e\u6784\u6210\u4e00\u4e2a\u73af\uff0c\u539f\u6765\u5728 $u \\to v$ \u8def\u5f84\u4e0a\u7684\u8fb9\u90fd\u4e0d\u518d\u662f\u5272\u8fb9\u3002\n\n\u5982\u679c\u628a\u5272\u8fb9\u7684\u503c\u8bbe\u4e3a $1$ \uff0c\u975e\u5272\u8fb9\u7684\u503c\u8bbe\u4e3a $0$ \uff0c\u90a3\u4e48\u53ea\u9700\u8981\u4fee\u6539\u548c\u7ef4\u62a4\u94fe\u7684\u548c\u5373\u53ef\u3002\n\n\u56e0\u4e3a\u6839\u4f1a\u53d8\uff0c\u6240\u4ee5\u8fb9\u7684\u4fe1\u606f\u9700\u8981\u65b0\u5efa\u70b9\u6765\u5b58\u50a8\u3002\n\n```cpp\n#include <map>\n#include <cstdio>\n#include <iostream>\nusing namespace std;\n\nconst int MAXN = 2e5;\nstruct node {\n    int ch[ 2 ] , fa;\n    int val , Sum;\n    bool rev , cov;\n};\nstruct LinkCutTree {\n    node Tree[ MAXN + 5 ];\n    #define ls( x ) Tree[ x ].ch[ 0 ]\n    #define rs( x ) Tree[ x ].ch[ 1 ]\n\n    void Pushup( int x ) {\n        Tree[ x ].Sum = Tree[ ls( x ) ].Sum + Tree[ x ].val + Tree[ rs( x ) ].Sum;\n    }\n    void Reverse( int x ) { swap( ls( x ) , rs( x ) ); Tree[ x ].rev ^= 1; }\n    void Cov( int x ) { Tree[ x ].Sum = Tree[ x ].val = 0; Tree[ x ].cov = 1; }\n    void Pushdown( int x ) {\n        if( Tree[ x ].rev ) {\n            if( ls( x ) ) Reverse( ls( x ) );\n            if( rs( x ) ) Reverse( rs( x ) );\n            Tree[ x ].rev = 0;\n        }\n        if( Tree[ x ].cov ) {\n            if( ls( x ) ) Cov( ls( x ) );\n            if( rs( x ) ) Cov( rs( x ) );\n            Tree[ x ].cov = 0;\n        }\n    }\n    \n    bool isrt( int x ) { //\u662f\u5426\u4e3a splay \u7684 rt\n        return ls( Tree[ x ].fa ) != x && rs( Tree[ x ].fa ) != x;\n    }\n    bool chk( int x ) { return rs( Tree[ x ].fa ) == x; }\n    void Rotate( int x ) {\n        int y = Tree[ x ].fa , z = Tree[ y ].fa , p = chk( x ) , a = Tree[ x ].ch[ !p ];\n        if( !isrt( y ) ) Tree[ z ].ch[ chk( y ) ] = x; Tree[ x ].fa = z;\n        Tree[ x ].ch[ !p ] = y; Tree[ y ].fa = x;\n        Tree[ y ].ch[ p ] = a; if( a ) Tree[ a ].fa = y;\n        Pushup( y ); \n    }\n    void Pushcn( int x ) { //pushdown \u6839\u5230x\n        if( !isrt( x ) ) Pushcn( Tree[ x ].fa );\n        Pushdown( x );\n    }\n    void Splay( int x ) {\n        Pushcn( x );\n        while( !isrt( x ) ) {\n            int y = Tree[ x ].fa , z = Tree[ y ].fa;\n            if( !isrt( y ) ) Rotate( chk( x ) == chk( y ) ? y : x );\n            Rotate( x );\n        }\n        Pushup( x );\n    }\n\n    void Access( int x ) {\n        for( int y = 0 ; x ; y = x , x = Tree[ x ].fa )\n            Splay( x ) , rs( x ) = y , Pushup( x );\n    }\n    void Makeroot( int x ) {\n        Access( x ); Splay( x );\n        Reverse( x );\n    }\n    int Findroot( int x ) {\n        Access( x ); Splay( x );\n        for( ; ls( x ) ; x = ls( x ) ) Pushdown( x );\n        Splay( x ); return x;\n    }\n    bool Connected( int u , int v ) {\n        Makeroot( u ); return Findroot( v ) == u;\n    }\n    bool Link( int u , int v ) {\n        if( Connected( u , v ) ) {\n            Split( u , v ); Cov( v );\n            return 0;\n        }\n        Tree[ u ].fa = v; return 1;\n    }\n    bool Cut( int u , int v ) {\n        if( !Connected( u , v ) ) return 0;\n        if( ls( v ) || Tree[ v ].fa != u ) return 0;\n        Tree[ v ].fa = 0; rs( u ) = 0;\n        return 1;\n    }\n    void Split( int u , int v ) {\n        Makeroot( u ); Access( v ); Splay( v );\n    }\n}LCT;\n\nstruct Query {\n    int op , u , v , Ans;\n}Qry[ MAXN + 5 ];\nmap< int , bool > Graph[ MAXN + 5 ];\nint n , m , q , cnt;\nint main( ) {\n    scanf(\"%d %d\",&n,&m);\n    for( int i = 1 , u , v ; i <= m ; i ++ ) {\n        scanf(\"%d %d\",&u,&v);\n        Graph[ u ][ v ] = Graph[ v ][ u ] = 1;\n        LCT.Tree[ n + i ].val = 1;\n    }\n    for( ; scanf(\"%d\",&Qry[ ++ q ].op) && Qry[ q ].op != -1 ; ) {\n        scanf(\"%d %d\",&Qry[ q ].u,&Qry[ q ].v);\n        if( Qry[ q ].op == 0 ) Graph[ Qry[ q ].u ][ Qry[ q ].v ] = Graph[ Qry[ q ].v ][ Qry[ q ].u ] = 0;\n    } q --;\n    for( int i = 1 ; i <= n ; i ++ )\n        for( auto v : Graph[ i ] )\n            if( v.second != 0 && v.first > i ) {\n                cnt ++;\n                LCT.Link( i , n + cnt ); \n                LCT.Link( n + cnt , v.first );\n                //printf(\"%d %d\\n\", i , v.first );\n            }\n    for( int i = q ; i >= 1 ; i -- ) {\n        if( Qry[ i ].op == 0 ) {\n            cnt ++;\n            LCT.Link( Qry[ i ].u , n + cnt );\n            LCT.Link( n + cnt , Qry[ i ].v );\n        }\n        if( Qry[ i ].op == 1 ) {\n            LCT.Split( Qry[ i ].u , Qry[ i ].v );\n            Qry[ i ].Ans = LCT.Tree[ Qry[ i ].v ].Sum;\n        }\n    }\n    for( int i = 1 ; i <= q ; i ++ )\n        if( Qry[ i ].op == 1 ) printf(\"%d\\n\", Qry[ i ].Ans );\n    return 0;\n}\n```",
        "postTime": 1614075139,
        "uid": 123802,
        "name": "chihik",
        "ccfLevel": 0,
        "title": "P2542 [AHOI2005] \u822a\u7ebf\u89c4\u5212"
    },
    {
        "content": "# [AHOI2005]\u822a\u7ebf\u89c4\u5212\n\n[\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/P2542)\n\n## \u9898\u610f\u6982\u62ec\n\n\u9996\u5148\u7ed9\u4f60\u4e00\u5f20\u56fe\uff0c\u7136\u540e\u4e0d\u65ad\u5220\u8fb9\uff0c\u6c42\u4e24\u70b9\u95f4\u7684\u5272\u8fb9\u7684\u6570\u91cf\u3002\n\n## \u89e3\u6cd51\n\n\u9996\u5148\u628a\u5220\u8fb9\u8f6c\u5316\u4e3a\u52a0\u8fb9\u3002\n\n\u7136\u540e\u53d1\u73b0\u4e00\u4e2a\u8fb9\u53ea\u53ef\u80fd\u4ece\u662f\u5272\u8fb9\u53d8\u4e3a\u4e0d\u662f\u5272\u8fb9\u3002\u7136\u540e\u5bf9\u4e8e\u4e00\u4e2a\u8fb9\u7ef4\u62a4\u4e00\u4e2a\u6743\u503c\uff0c\u8fd9\u4e2a\u6743\u503c\u4e3a$1$\u5219\u662f\u5272\u8fb9\uff0c\u5426\u5219\u4e0d\u662f\u3002\u5bf9\u4e8e\u4e00\u6b21\u52a0\u8fb9\u64cd\u4f5c\uff0c\u5982\u679c\u8fd9\u4e24\u4e2a\u70b9\u672c\u8eab\u4e0d\u8fde\u901a\uff0c\u90a3\u4e48\u5c31\u76f4\u63a5\u7ed9\u8fd9\u4e24\u4e2a\u70b9\u8fde\u4e0a\u8fb9\u3002\u5426\u5219\uff0c\u8fd9\u4e2a\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u5728\u539f\u6765\u6811\u4e0a\u7684\u8fb9\u4e00\u90fd\u4e0d\u662f\u5272\u8fb9\u4e86\u3002\u90a3\u4e48\u628a\u90a3\u4e9b\u8fb9\u7684\u6743\u503c\u90fd\u53d8\u4e3a0\u3002\n\n## \u89e3\u6cd52\n\n\u5176\u4ed6\u7684\u548c\u89e3\u6cd51\u4e00\u6837\uff0c\u4f46\u662f\u5bf9\u4e8e\u5728\u4e24\u4e2a\u70b9\u5df2\u7ecf\u8054\u901a\u7684\u52a0\u8fb9\u64cd\u4f5c\uff0c\u7136\u540e\u6bcf\u628a\u8fd9\u6b21\u7684\u8fd9\u4e2a\u8fb9\u53cc\u4e0a\u7684\u6240\u6709\u70b9\uff08\u4e00\u5b9a\u5728\u4e00\u6761\u94fe\u4e0a\uff09\uff0c\u7528\u4e00\u4e2a\u70b9\u4ee3\u66ff\uff08\u5177\u4f53\u53ef\u4ee5\u6bcf\u4e2a\u70b9\u5148\u7ef4\u62a4\u4e00\u4e2a\u5e76\u67e5\u96c6\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u7684\u5e76\u67e5\u96c6\u7956\u5148\u90fd\u66f4\u6539\u4e3a\u8fd9\u4e2a\u94fe\u7684\u8f85\u52a9\u6811\u6839\u8282\u70b9\uff09\u3002\u8fd9\u6837\u505a\u7684\u672c\u8d28\u5176\u5b9e\u5c31\u662f\u628a\u4e00\u4e2a\u56fe\u7684\u8fb9\u53cc\u7f29\u70b9\u540e\uff0c\u56fe\u5c31\u5f62\u6210\u4e86\u4e00\u68f5\u6811\u3002\n\n## \u77e5\u8bc6\u70b9\n\n+ ```LCT```\u7ef4\u62a4\u8fb9\u53cc\u6a21\u677f\u9898\u3002\n+ \u53ef\u4ee5\u53d1\u73b0\uff0c\u6240\u6709\u5e76\u67e5\u96c6\u4e2d\u7236\u4eb2\u4e0e\u81ea\u5df1\u5e76\u4e0d\u662f\u540c\u4e00\u4e2a\u70b9\u7684\u8bdd\uff0c\u90a3\u4e48\u8fd9\u4e2a\u70b9\u5c31\u4e0d\u518d\u6811\u4e0a\u3002\u56e0\u4e3a\u5728\u6dfb\u52a0\u4e86\u4e00\u6761\u8fde\u63a5\u4e24\u4e2a\u5df2\u7ecf\u8054\u901a\u7684\u70b9\u4e4b\u524d\uff0c\u5c31\u5df2\u7ecf\u628a\u90a3\u4e2a\u73af\u4e0a\u7684\u9664\u4e86\u5f53\u524d\u8fd9\u5757\u7684\u6839\u8282\u70b9\u7684\u6240\u6709\u5176\u4ed6\u70b9\u90fd\u4e0e\u6811\u65ad\u5f00\u94fe\u63a5\u4e86\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int maxNodeNum =3e4 + 10;\nconst int maxEdgeNum = 1e5 + 10;\nconst int maxActNum = 4e4 + 10;\nint nodeNum = 0, edgeNum = 0, actNum = 0;\nbool vis[maxEdgeNum] = {};\nstruct EDGE {\n\tint uNode, vNode;\n\tEDGE() : uNode(0), vNode(0) {}\n\tEDGE(int u, int v) : uNode(u), vNode(v) {}\n\tbool operator < (const EDGE &d) const {\n\t\treturn (uNode == d.uNode) ? (vNode < d.vNode) : (uNode < d.uNode);\n\t}\n} edge[maxEdgeNum] = {};\nstruct ACTI {\n\tint type, uNode, vNode, ans;\n\tACTI() : type(0), uNode(0), vNode(0) {}\n} act[maxActNum] = {};\nvoid swap(int &u, int &v) {\n\tint r = u;\n\tu = v;\n\tv = r;\n}\nint find(int uNode, int vNode) {\n\treturn lower_bound(edge + 1, edge + edgeNum + 1, EDGE(uNode, vNode)) - edge;\n}\nstruct LCT {\n\tint top;\n\tint fa[maxNodeNum], ch[maxNodeNum][2], size[maxNodeNum], dsu[maxNodeNum];\n\tint stk[maxNodeNum];\n\tbool rev[maxNodeNum];\n\tLCT() {\n\t\tmemset(fa, 0, sizeof(fa));\n\t\tmemset(ch, 0, sizeof(ch));\n\t\tmemset(rev, 0, sizeof(rev));\n\t\tmemset(size, 0, sizeof(size));\n\t}\n\tvoid out() {\n\t\tfor (int id = 1; id <= nodeNum; ++id)\n\t\t\tprintf(\"id : %d fa : %d left : %d right : %d\\n\", id, fa[id], ch[id][0], ch[id][1]);\n\t\tprintf(\"\\n\");\n\t}\n\tvoid init() {\n\t\tfor (int nodeId = 1; nodeId <= nodeNum; ++nodeId)\n\t\t\tdsu[nodeId] = nodeId;\n\t}\n\tint get(int now) {\n\t\tif (dsu[now] == now)\n\t\t\treturn now;\n\t\treturn dsu[now] = get(dsu[now]);\n\t}\n\tbool isNotR(int now) {\n\t\treturn ch[fa[now]][0] == now || ch[fa[now]][1] == now;\n\t}\n\tbool chk(int now) {\n\t\treturn ch[fa[now]][1] == now;\n\t}\n\tvoid update(int now) {\n\t\tsize[now] = size[ch[now][0]] + size[ch[now][1]] + 1;\n\t}\n\tvoid connect(int now, int futureFa, bool side) {\n\t\tfa[now] = futureFa;\n\t\tch[futureFa][side] = now;\n\t}\n\tvoid rotate(int now) {\n\t\tint par = fa[now], gra = fa[par];\n\t\tbool nowSide = chk(now);\n\t\tif (isNotR(par))\n\t\t\tch[gra][chk(par)] = now;\n\t\tfa[now] = gra;\n\t\tconnect(ch[now][nowSide ^ 1], par, nowSide);\n\t\tconnect(par, now, nowSide ^ 1);\n\t\tupdate(par);\n\t\tupdate(now);\n\t}\n\tvoid flip(int now) {\n\t\trev[now] ^= 1;\n\t\tswap(ch[now][0], ch[now][1]);\n\t}\n\tvoid spread(int now) {\n\t\tif (rev[now]) {\n\t\t\tif (ch[now][0])\n\t\t\t\tflip(ch[now][0]);\n\t\t\tif (ch[now][1])\n\t\t\t\tflip(ch[now][1]);\n\t\t\trev[now] = 0;\n\t\t}\n\t}\n\tvoid splay(int now) {\n\t\tint go = stk[top = 1] = now;\n\t\twhile (isNotR(go))\n\t\t\tgo = stk[++top] = fa[go];\n\t\twhile (top)\n\t\t\tspread(stk[top--]);\n\t\twhile (isNotR(now)) {\n\t\t\tint par = fa[now];\n\t\t\tif (isNotR(par))\n\t\t\t\trotate(chk(now) ^ chk(par) ? now : par);\n\t\t\trotate(now);\n\t\t}\n\t}\n\tvoid access(int now) {\n\t\t//\u66fe\u7ecf\u628arec\u521d\u59cb\u503c\u5199\u6210\u4e86now \n\t\tfor (int rec = 0; now; now = fa[rec = now] = get(fa[now])) {\n\t\t\tsplay(now); ch[now][1] = rec; update(now);\n\t\t}\n\t}\n\tvoid makeRoot(int now) {\n\t\taccess(now);\n\t\tsplay(now);\n\t\tflip(now);\n\t}\n\tvoid split(int uNode, int vNode) {\n\t\tmakeRoot(uNode);\n\t\taccess(vNode);\n\t\tsplay(vNode);\n\t}\n\tint findRoot(int now) {\n\t\taccess(now);\n\t\tsplay(now);\n\t\twhile (ch[now][0]) {\n\t\t\tspread(now);\n\t\t\tnow = ch[now][0];\n\t\t}\n\t\treturn splay(now), now;\n\t}\n\tvoid dfs(int now, int val) {\n\t\tdsu[now] = val;\n\t\tif (ch[now][0])\n\t\t\tdfs(ch[now][0], val);\n\t\tif (ch[now][1])\n\t\t\tdfs(ch[now][1], val);\n\t}\n\tvoid link(int uNode, int vNode) {\n\t\tif (uNode == vNode)\n\t\t\treturn ;\n\t\t//\u5728\u4e00\u5757\u8981\u5ffd\u7565 \n\t\tmakeRoot(uNode);\n\t\tif (findRoot(vNode) != uNode) {\n\t\t\tfa[uNode] = vNode;\n\t\t} else {\n\t\t\tsplit(uNode, vNode);\n\t\t\tdfs(vNode, vNode);\n\t\t\tch[vNode][0] = ch[vNode][1] = 0;\n\t\t\t//\u9700\u8981\u65ad\u5f00\u8fde\u63a5 \n\t\t}\n\t}\n\tint pathNodeNum(int uNode, int vNode) {\n\t\tsplit(uNode, vNode);\n\t\treturn size[vNode] - 1;\n\t}\n} T;\n\nint main() {\n\tscanf(\"%d%d\", &nodeNum, &edgeNum);\n\tfor (int edgeId = 1; edgeId <= edgeNum; ++edgeId) {\n\t\tscanf(\"%d%d\", &edge[edgeId].uNode, &edge[edgeId].vNode);\n\t\tif (edge[edgeId].uNode > edge[edgeId].vNode)\n\t\t\tswap(edge[edgeId].uNode, edge[edgeId].vNode);\n\t\tvis[edgeId] = 1;\n\t}\n\tT.init();\n\tsort(edge + 1, edge + edgeNum + 1);\n\tint nowType;\n\tscanf(\"%d\", &nowType);\n\twhile (nowType != -1) {\n\t\tact[++actNum].type = nowType;\n\t\tscanf(\"%d%d%d\", &act[actNum].uNode, &act[actNum].vNode, &nowType);\n\t\tif (act[actNum].uNode > act[actNum].vNode)\n\t\t\tswap(act[actNum].uNode, act[actNum].vNode);\n\t\tif (act[actNum].type == 0)\n\t\t\tvis[find(act[actNum].uNode, act[actNum].vNode)] = 0;\n\t}\n\tfor (int edgeId = 1; edgeId <= edgeNum; ++edgeId)\n\t\tif (vis[edgeId])\n\t\t\tT.link(T.get(edge[edgeId].uNode), T.get(edge[edgeId].vNode));\n\t\t\t//\u8fd9\u53e5\u8bdd\u5fc5\u987b\u5199 T.get()\n\t\t\t//\u56e0\u4e3a\u5728\u8fde\u8fb9\u7684\u8fc7\u7a0b\u4e2d\u5c31\u4f1a\u51fa\u73b0\u6709\u4e9b\u70b9\u8fde\u6210\u4e00\u56e2\u7684\u60c5\u51b5\u4e86\uff0c\u867d\u7136\u8fd9\u4e2a\u5faa\u73af\u4e4b\u524d\u6ca1\u6709 \n\tfor (int actI = actNum; actI >= 1; --actI) {\n\t\tact[actI].uNode = T.get(act[actI].uNode);\n\t\tact[actI].vNode = T.get(act[actI].vNode);\n\t\tif (act[actI].type == 0)\n\t\t\tT.link(act[actI].uNode, act[actI].vNode);\n\t\telse\n\t\t\tact[actI].ans = T.pathNodeNum(act[actI].uNode, act[actI].vNode);\n\t}\n\tfor (int actI = 1; actI <= actNum; ++actI)\n\t\tif (act[actI].type == 1)\n\t\t\tprintf(\"%d\\n\", act[actI].ans);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1579090373,
        "uid": 75715,
        "name": "KokiNiwa",
        "ccfLevel": 0,
        "title": "[AHOI2005]\u822a\u7ebf\u89c4\u5212"
    },
    {
        "content": "\u672c\u60f3\u5f53\u4f5c\u6811\u5256\u6a21\u677f\u7ec3\u7ec3\u624b\uff0c\u6ca1\u60f3\u5230\u8c03\u4e86\u6574\u6574\u4e00\u4e0a\u5348\u3002\u3002\u3002\n\n### \u89e3\u9898\u601d\u8def\n\u65f6\u95f4\u5012\u6d41\uff08\u81ea\u5df1\u8d77\u7684\u540d\u5b57\uff09+\u6811\u94fe\u5256\u5206\n\n> \n\u6211\u4eec\u4fdd\u8bc1\u65e0\u8bba\u822a\u7ebf\u5982\u4f55\u88ab\u7834\u574f\uff0c\u4efb\u610f\u65f6\u523b\u4efb\u610f\u4e24\u4e2a\u661f\u7403\u90fd\u80fd\u591f\u76f8\u4e92\u5230\u8fbe\u3002\n\n\u8fd9\u53e5\u8bdd\u52a0\u4e0a\u5220\u9664\u8fb9\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u5e94\u8be5\u5f88\u5bb9\u6613\u7684\u60f3\u5230\u65f6\u95f4\u5012\u6d41\u7684\u79bb\u7ebf\u5904\u7406\u65b9\u6cd5\uff0c\u8fd9\u4e2a\u6bd4\u8f83\u5957\u8def\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u52a0\u8fb9\u64cd\u4f5c\uff08\u5df2\u7ecf\u65f6\u95f4\u5012\u6d41\u4e86\uff09\uff0c\u6211\u4eec\u7b49\u540c\u4e8e\u6d88\u53bb\u4e86\u6811\u4e0a\u4e00\u6761\u8def\u5f84\u7684\u8d21\u732e\uff0c\u76f4\u63a5\u6811\u94fe\u5256\u5206\u8def\u5f84\u4fee\u6539\u5c31\u53ef\u4ee5\u505a\uff0c\u800c\u8be2\u95ee\u4e5f\u53ef\u4ee5\u8def\u5f84\u8be2\u95ee\u3002\n\n\u4e00\u5f00\u59cb\u4e3a\u4e86\u6811\u5256\u5199\u4e86\u7f29\u70b9\uff08\u7f29\u5b8c\u662f\u68f5\u6811\uff09\uff0c\u540e\u6765\u79cd\u79cd\u7ec6\u8282\u53ef\u80fd\u51fa\u4e86\u9505\uff0c\u4e00\u76f4\u6ca1\u6709\u8fc7\u6837\u4f8b\uff0c\u540e\u6765\u5374\u53d1\u73b0\u8fd9\u4e2a\u7f29\u70b9\u6ca1\u6709\u4efb\u4f55\u5fc5\u8981\uff0c\u6211\u4eec\u53ea\u9700\u5728\u56fe\u4e0a\u968f\u4fbf\u8dd1\u4e00\u9897\u6811\u51fa\u6765\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u51e0\u4e2a\u7ec6\u8282\uff1a\n1. \u8fb9\u6743\u4e0b\u843d\u5230\u70b9\u4e0a\uff0c\u53d8\u4e3a\u70b9\u6743\u3002\n2. \u5173\u4e8eLCA\u7684\u7ec6\u8282\u5904\u7406\u52a1\u5fc5\u8981\u5c0f\u5fc3\u3002\n3. \u8def\u5f84\u64cd\u4f5c\u65f6\uff0c\u6211\u4eec\u8981\u6bd4\u8f83$a$,$b$\u7684$dep[top[]]$\uff0c\u800c\u975e$dep[]$\uff0c\u8fd9\u4e2a\u9519\u8bef\u8c03\u4e86\u597d\u4e45\u3002\u3002\u3002\n\n### AC\u4ee3\u7801\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cctype>\n#include <map>\n\n#define ls u << 1\n#define rs u << 1 | 1\n\nusing namespace std;\n\nconst int N = 420200;\n\nint n, m, cnt, id;\nint a[N], b[N], c[N], nid[N], ed[N], top[N], w[N], add[N], out[N];\nint son[N], dep[N], faz[N], vis[N], used[N], old[N], el[N], er[N];\nint ec = -1, to[N], bg[N], nxt[N], f[N], siz[N];\n\nmap <long long, int> M;\n\ninline bool read(int &x)\n{\n\tint k = 1; x = 0;\n\tchar c = getchar();\n\twhile (!isdigit(c))\n\t\tif (c == '-') c = getchar(), k = -1;\n\t\telse c = getchar();\n\twhile (isdigit(c))\n\t\tx = (x << 1) + (x << 3) + (c ^ 48),\n\t\tc = getchar(); x *= k; \n\treturn true;\n}\n\ninline void Addedge(int a, int b)\n{\n\t++ec, to[ec] = b, bg[ec] = a, nxt[ec] = f[a], f[a] = ec;\n\t++ec, to[ec] = a, bg[ec] = b, nxt[ec] = f[b], f[b] = ec;\n}\n\nvoid DFS1(int u, int fa)\n{\n\tsiz[u] = 1, vis[u] = 1, faz[u] = fa;\n\tdep[u] = (u == 1 ? 1 : dep[fa] + 1);\n\tfor (int i = f[u]; i != -1; i = nxt[i])\n\t\tif (!vis[to[i]] && !used[i])\n\t\t{\n\t\t\tused[i ^ 1] = -1, used[i] = 1; ed[to[i]] = i;\n\t\t\tDFS1(to[i], u), siz[u] += siz[to[i]];\n\t\t\tif (!son[u] || siz[to[i]] > siz[son[u]]) \n\t\t\t\tson[u] = to[i];\n\t\t}\n}\n\nvoid DFS2(int u, int head)\n{\n\tnid[u] = ++id, top[u] = head, old[id] = u;\n\tif (!son[u]) return; DFS2(son[u], head);\n\tfor (int i = f[u]; i != -1; i = nxt[i])\n\t\tif (!nid[to[i]] && used[i] == 1)\n\t\t\tDFS2(to[i], to[i]);\n}\n\ninline void Pushup(int u)\n{\n\tw[u] = w[ls] + w[rs];\n}\n\ninline void Pushdown(int u, int l, int r)\n{\n\tif (add[u] == -1) return;\n\tadd[ls] = add[rs] = 0;\n\tw[ls] = w[rs] = 0;\n\tadd[u] = -1;\n}\t\n\nvoid Build(int u, int l, int r)\n{\n\tadd[u] = -1; if (l == r) { w[u] = ed[old[l]] != -1; return; }\n\tint mid = (l + r) >> 1; Build(ls, l, mid), Build(rs, mid + 1, r), Pushup(u);\n}\n\nvoid Add(int u, int l, int r, int ql, int qr)\n{\n\tif (ql <= l && r <= qr)\n\t{ add[u] = 0, w[u] = 0; return; }\n\tint mid = (l + r) >> 1; Pushdown(u, l, r);\n\tif (ql <= mid) Add(ls, l, mid, ql, qr);\n\tif (qr > mid) Add(rs, mid + 1, r, ql, qr);\n\tPushup(u);\n}\n\nint Query(int u, int l, int r, int ql, int qr)\n{\n\tif (ql <= l && r <= qr) return w[u];\n\tint mid = (l + r) >> 1, res = 0; Pushdown(u, l, r);\n\tif (ql <= mid) res += Query(ls, l, mid, ql, qr);\n\tif (qr > mid) res += Query(rs, mid + 1, r, ql, qr);\n\treturn res;\n}\n\ninline void Put(int a, int b)\n{\n\twhile (top[a] != top[b])\n\t{\n\t\tif (dep[top[a]] < dep[top[b]]) swap(a, b);\n\t\tAdd(1, 1, n, nid[top[a]], nid[a]);\n\t\ta = faz[top[a]];\n\t}\n\tif (dep[a] < dep[b]) swap(a, b);\n\tif (dep[a] ^ dep[b]) Add(1, 1, n, nid[b] + 1, nid[a]);\n}\n\ninline int Ret(int a, int b)\n{\n\tint ans = 0;\n\twhile (top[a] != top[b])\n\t{\n\t\tif (dep[top[a]] < dep[top[b]]) swap(a, b);\n\t\tans += Query(1, 1, n, nid[top[a]], nid[a]);\n\t\ta = faz[top[a]];\n\t}\n\tif (dep[a] < dep[b]) swap(a, b);\n\tans += Query(1, 1, n, nid[b], nid[a]);\n\tans -= Query(1, 1, n, nid[b], nid[b]);\n\treturn ans;\n}\n\ninline int ID(int x, int y)\n{\n\treturn x * 100000 + y;\n}\n\nsigned main()\n{\n\tread(n), read(m);\n\tmemset(f, -1, sizeof(f)); memset(ed, -1, sizeof(ed));\n\tfor (int i = 1; i <= m; ++i) read(el[i]), read(er[i]);\n\tfor (; read(c[++cnt]); )\n\t\tif (c[cnt] == -1) break;\n\t\telse if (c[cnt] == 0) read(a[cnt]), read(b[cnt]), M[ID(a[cnt], b[cnt])] = true; \n\t\telse read(a[cnt]), read(b[cnt]); --cnt;\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (!M[ID(el[i], er[i])] && !M[ID(er[i], el[i])])\n\t\t\tAddedge(el[i], er[i]);\n\tDFS1(1, 0), DFS2(1, 1), Build(1, 1, id);\n\tfor (int i = 0; i <= ec; ++i)\n\t\tif (!used[i]) used[i] = used[i ^ 1] = -1, Put(to[i], bg[i]);\n\tfor (int i = cnt; i >= 1; --i)\n\t\tif (!c[i]) Put(a[i], b[i]);\n\t\telse out[i] = Ret(a[i], b[i]);\n\tfor (int i = 1; i <= cnt; ++i) \n\t\tif (c[i]) printf(\"%d\\n\", out[i]);\n\treturn 0;\n}\n\n/*\n\u9898\u76ee\u6574\u4f53\u601d\u8def\uff1a\n\u65f6\u95f4\u5012\u6d41+\u6811\u94fe\u5256\u5206\n*/\n```",
        "postTime": 1553150799,
        "uid": 26512,
        "name": "Christopher_Yan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898 \u975e\u5e38\u7684\u597d\n\n\n\u5927\u6982\u5206\u4e3a\u8fd9\u51e0\u4e2a\u6b65\u9aa4\n\n\n1.\u8bfb\u5165\u6240\u6709\u7684\u95ee\u9898\n\n2.\u628a\u6240\u6709\u8981\u5220\u7684\u8fb9\u90fd\u5220\u6389\n\n3.\u628a\u56fe\u7f29\u6210\u4e00\u9897\u6811\n\n4.\u6811\u4e0a\u8dd1dfs\u8bb0\u4e0b\u70b9\u7684\u6b27\u62c9\u8ff9\uff0c\u5e76\u628a\u70b9\u7684\u6df1\u5ea6\u7ef4\u62a4\u4e00\u4e2a\u7ebf\u6bb5\u6811\n\n5.\u6b27\u62c9\u8ff9\u653e\u5230rmq\u4e2d\uff0c\u4fbf\u4e8e\u67e5\u8be2lca\n\n6.\u5bf9\u4e8e\u6bcf\u4e00\u6761\u589e\u52a0\u7684\u8fb9\uff0c\u5047\u5982\u5f62\u6210\u4e86\u73af\uff0c\u63a5\u7740\u7f29\u70b9\uff0c\u5e76\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u6df1\u5ea6\u53d8\u5316\uff08lca\u4e0d\u53d8\n\n7.\u67e5\u8be2\u6811\u4e0a\u4e24\u70b9\u8ddd\u79bb\uff0c\u8f93\u51fa\n\n\n\u8be6\u89c1\u4ee3\u7801\n\n\n```cpp\n#include<iostream>\n#include <cstdio>\n#include <cstring>\n#include<cmath>\nusing namespace std;\nconst int Limit=30010;\nconst int Limitedge=100010;\nconst int Limitquery=200010;\nconst int Limithash=1999997;\nconst int Limitlog=18;\nconst int Limittree=32767;\nstruct Tmap//\u8fb9\n{\n    int p1,p2;\n    int link;\n    bool vis;\n}map[Limitedge*2],tmp[Limitedge*2];\nstruct Query//\u95ee\u9898\n{\n    int kind;\n    int p1,p2;\n    int ans;\n}Que[Limitquery];\nstruct Point\n{\n    int p1,p2;\n};\nstruct THash//\u5904\u7406\u8fb9\n{\n    Point save;//hash\u503c\u4e3ahashnum\u7684\u8fb9\u8fde\u63a5\u7684\u70b9\n    int data;//hash\u503c\u4e3ahashnum\u7684\u8fb9\u662f\u54ea\u6761\n}Hash[Limithash];\nint rank[Limit];//\u57fa\u6570\u6392\u5e8f\nint tail[Limit];//i\u7684\u5b69\u5b50\u4eec\u662fi\u5230tail[i]\nint code[Limit];//\u91cd\u6807\u53f7\nbool visit[Limit];\nint tree_father[Limit];//dfs\u6811\u4e2d\u7684\u7236\u4eb2\nint tree[Limit*3];//\u7ebf\u6bb5\u6811\nint source[Limit*3];//dfs\u5e8f\nint RMQ_rank[Limit*3];//\u5728dfs\u5e8f\u4e2d\u7684\u54ea\u4e2a\u4f4d\u7f6e\nint ancestor[Limit*3][Limitlog];\nint father[Limit];//\u5e76\u67e5\u96c6\nint cnt;\nint RMQ_tot;//dfs\u5e8f\u7684\u4e2a\u6570\nint N,M,Q;\nvoid init()\n{\n    scanf(\"%d%d\",&N,&M);\n    for (int i=1;i<=M;i++)\n    {\n        scanf(\"%d%d\",&map[i].p1,&map[i].p2);\n        map[i+M].p1=map[i].p2;//\u8bb0\u5f55\u53cd\u5411\u8fb9\n        map[i+M].p2=map[i].p1;\n        map[i].link=i+M; map[i+M].link=i;\n    }\n    M*=2;\n    Q=0;\n    while (1==1)\n    {\n        Q++;\n        scanf(\"%d\",&Que[Q].kind);\n        if (Que[Q].kind==-1)\n        {\n            Q--;\n            break;\n        }\n        scanf(\"%d%d\",&Que[Q].p1,&Que[Q].p2);\n    }\n}\nvoid radixsort()\n{\n    for (int i=1;i<=M;i++) tmp[i]=map[i];\n    for (int i=1;i<=N;i++) rank[i]=0;\n    for (int i=1;i<=M;i++) rank[tmp[i].p1]++;\n    for (int i=2;i<=N;i++) rank[i]+=rank[i-1];\n    for (int i=M;i>=1;i--)\n    {\n        map[rank[tmp[i].p1]--]=tmp[i];\n        if (tmp[i].vis)\n            map[tmp[i].link].link=rank[tmp[i].p1]+1;\n        else\n        {\n            tmp[tmp[i].link].link=rank[tmp[i].p1]+1;\n            tmp[tmp[i].link].vis=1;\n        }\n    }\n    for (int i=1;i<=N;i++) rank[i]++;\n    for (int i=1;i<=M;i++) map[i].vis=0;\n}\nint Hash_calc(int p1,int p2)\n{\n    return (p1*12351+p2*9591)%Limithash;\n}\nbool compare(Point p,int p1,int p2)\n{\n    return (p.p1==p1 && p.p2==p2);\n}\nvoid Hash_add(int k)\n{\n    int hashnum=Hash_calc(map[k].p1,map[k].p2);\n    while (Hash[hashnum].data!=0 && !compare(Hash[hashnum].save,map[k].p1,map[k].p2))\n    {\n        hashnum++;\n        if (hashnum==Limithash)\n            hashnum=0;\n    }\n    Hash[hashnum].data=k;\n    Hash[hashnum].save.p1=map[k].p1; Hash[hashnum].save.p2=map[k].p2;\n}\nint Hash_find(int p1,int p2)\n{\n    int hashnum=Hash_calc(p1,p2);\n    while (!compare(Hash[hashnum].save,p1,p2))\n    {\n        hashnum++;\n        if (hashnum==Limithash) hashnum=0;\n    }\n    return Hash[hashnum].data;\n}\nvoid RMQ_add(int k)\n{\n    source[++RMQ_tot]=k;\n    RMQ_rank[k]=RMQ_tot;\n}\nvoid RMQ_make()\n{\n    for (int i=1;i<=RMQ_tot;i++) \n        ancestor[i][0]=source[i];\n    for (int j=1;(1<<j)<=RMQ_tot;j++)\n        for (int i=1;i+(1<<j)-1<=RMQ_tot;i++)\n            ancestor[i][j]=min(ancestor[i][j-1],ancestor[i+(1<<(j-1))][j-1]);\n}\nint RMQ_LCA(int p1,int p2)\n{\n    p1=RMQ_rank[p1]; p2=RMQ_rank[p2];\n    if (p2<p1) swap(p1,p2);\n    int len=floor(log((double)p2-p1+1)/log(2.0));\n    return min(ancestor[p1][len],ancestor[p2-(1<<len)+1][len]);\n}\nvoid dfs_build(int k)\n{\n    cnt++; visit[k]=1;\n    int now=cnt; code[k]=now;\n    int i=rank[k]; RMQ_add(now);\n    while (i<=M && map[i].p1==k)\n    {\n        if (!map[i].vis)\n            if (!visit[map[i].p2])\n            {\n                map[map[i].link].vis=1;\n                dfs_build(map[i].p2);\n                RMQ_add(now);\n                tree_father[code[map[i].p2]]=now;\n            }\n            else\n            {\n                map[map[i].link].vis=1;\n                Que[++Q].kind=0;\n                Que[Q].p1=map[i].p1; Que[Q].p2=map[i].p2;\n            }\n        i++;\n    }\n    tail[now]=cnt;\n}\nvoid tree_add(int l,int r,int val)\n{\n    l+=Limittree; r+=Limittree;\n    while (l<=r)\n    {\n        if (l%2==1) {tree[l]+=val; l++;}\n        if (r%2==0) {tree[r]+=val; r--;}\n        l/=2; r/=2;\n    }\n}\nint tree_query(int x)\n{\n    int ans=0;\n    x+=Limittree;\n    while (x!=0)\n    {\n        ans+=tree[x];\n        x/=2;\n    }\n    return ans;\n}\nint Merge_find(int x)\n{\n    if (x!=father[x])\n        father[x]=Merge_find(father[x]);\n    return father[x];\n}\nvoid Merge_dfs(int p,int root)\n{\n    if (p!=root)\n    {\n        Merge_dfs(Merge_find(tree_father[p]),root);\n        father[p]=root; tree_add(p,tail[p],-1);\n    }\n}\nvoid Merge(int p1,int p2)\n{\n    int LCA=Merge_find(RMQ_LCA(p1,p2));\n    Merge_dfs(p1,LCA);\n    Merge_dfs(p2,LCA);\n}\nvoid work()\n{\n    radixsort();//\u57fa\u6570\u6392\u5e8f\n    for (int i=1;i<=M;i++) Hash_add(i);//\u505a\u8bfb\u5165\u8fb9\u7684hash\n    for (int i=1;i<=Q;i++)\n        if (!Que[i].kind)//\u5fc5\u987b\u5220\u7684\u8fb9\u5148\u53bb\u6389\n        {\n            map[Hash_find(Que[i].p1,Que[i].p2)].vis=1;\n            map[Hash_find(Que[i].p2,Que[i].p1)].vis=1;\n        }\n    memset(visit,0,sizeof(visit));\n    dfs_build(1);//\u505adfs\u5e8f\n    RMQ_make();\n    for (int i=1;i<=N;i++) father[i]=i;//\u5e76\u67e5\u96c6\n    tree[1+Limittree]=1;\n    for (int i=2;i<=N;i++) tree[i+Limittree]=tree[tree_father[i]+Limittree]+1;//\u8d4b\u7ebf\u6bb5\u6811\u53f6\u5b50\u7ed3\u70b9\u7684\u503c\n    for (int i=Q;i>=1;i--)\n    {\n        int p1=Merge_find(code[Que[i].p1]);\n        int p2=Merge_find(code[Que[i].p2]);\n        if (!Que[i].kind)\n            Merge(p1,p2);//\u6dfb\u8fb9\n        else\n        {\n            int LCA=Merge_find(RMQ_LCA(p1,p2));\n            int deep1=tree_query(p1);\n            int deep2=tree_query(p2);\n            int deepLCA=tree_query(LCA);\n            Que[i].ans=deep1+deep2-deepLCA*2;\n        }\n    }\n}\nvoid out()\n{\n    for (int i=1;i<=Q;i++)\n        if (Que[i].kind)\n            printf(\"%d\\n\",Que[i].ans);\n}\nint main()\n{\n    init();\n    work();\n    out();\n}\n```",
        "postTime": 1479111203,
        "uid": 17689,
        "name": "\u8fdc\u822a\u4e4b\u66f2",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\u9996\u5148\u89c2\u5bdf\u5230\u9898\u76ee\u4e2d\u5e26\u6709\u5220\u8fb9\u64cd\u4f5c\u3002\n\n\u8003\u8651\u5230\u5220\u8fb9\u4e4b\u540e\u8fde\u901a\u6027\u6bd4\u8f83\u96be\u5224\u65ad\uff0c\u8003\u8651\u79bb\u7ebf\u540e\u5012\u5e8f\u64cd\u4f5c\uff0c\u5220\u8fb9\u5c31\u53d8\u4e3a\u4e86\u52a0\u8fb9\u3002\n\n\u6211\u4eec\u505a\u4ee5\u4e0b\u89c4\u5b9a\u65b9\u4fbf\u8bb2\u89e3\uff1a\n\n- \u5b9a\u4e49\u5012\u5e8f\u64cd\u4f5c\u540e\u7684\u5f00\u59cb\u56fe\u4e3a $ P_0 $\uff08\u5373\u6b63\u5e8f\u64cd\u4f5c\u7ed3\u675f\u72b6\u6001\uff09\u3002\n\n- $ P_0 $ \u4e3a\u4e00\u4e2a $ n $ \u70b9\u8fde\u901a\u7684\u65e0\u5411\u56fe\u3002\n\n- \u5b9a\u4e49 $ P_0 $ \u7684\u4e00\u68f5 dfs \u6811 $ T_0 $ \u4e3a\u4efb\u610f\u4e00\u68f5\u4ee5 $ 1 $ \u4e3a\u6839\u7684\u751f\u6210\u6811\u3002\n\n- \u5b9a\u4e49 $ T_0 $ \u4ee5\u5916\u7684\u8fb9\u4e3a\u989d\u5916\u8fb9\uff0c\u989d\u5916\u8fb9\u6784\u6210\u7684\u96c6\u5408\u4e3a $ E_0 $\u3002\n\n\u6211\u4eec\u8003\u8651\u5728\u5012\u5e8f\u64cd\u4f5c\u7684\u5f00\u5934\u63d2\u5165\u6240\u6709\u7684 $ E_0 $ \u4e2d\u7684\u8fb9\u3002\u90a3\u4e48 $ P_0 $ \u5c31\u53d8\u4e3a\u4e86\u4e00\u68f5\u6811\uff0c\u5219\u6709 $ P_0=T_0 $\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u64cd\u4f5c\uff0c\u5c31\u76f8\u5f53\u4e8e\u5728 $ T_0 $ \u4e0a\u65b0\u589e\u52a0\u4e86\u4e00\u6761\u989d\u5916\u8fb9\u3002\n\n\u663e\u7136\u989d\u5916\u8fb9\u4e0d\u662f\u5173\u952e\u8fb9\uff0c\u56e0\u4e3a\u5220\u6389\u5b83\u4e0d\u4f1a\u5f71\u54cd\u8fde\u901a\u6027\u3002\n\n\u800c\u989d\u5916\u8fb9 $ e=(u,v) $ \u4f7f\u5f97\u65b0\u589e\u52a0\u4e86\u4e00\u6761\u4ece $ u $ \u81f3 $ v $ \u7684\u9053\u8def\uff0c\u90a3\u4e48\u65ad\u5f00 $ u $ \u5230 $ v $ \u4e4b\u95f4\u7684\u4efb\u610f\u8fb9\u90fd\u4e0d\u4f1a\u5f71\u54cd\u8fde\u901a\u6027\u3002\u5373\u5728\u6b64\u4e4b\u540e\uff0c$ u $ \u5230 $ v $ \u7684\u6240\u6709\u8fb9\u90fd\u4e0d\u662f\u5173\u952e\u8fb9\u3002\u5982\u8fd9\u4e2a\u4f8b\u5b50\uff1a\n\n![](https://s1.ax1x.com/2022/11/05/xO3Wp8.png)\n\n![](https://s1.ax1x.com/2022/11/05/xO3qhV.png)\n\n![](https://s1.ax1x.com/2022/11/05/xO3X1U.png)\n\n\u90a3\u4e48\u6574\u9053\u9898\u53d8\u4e3a\u4e86\u6811\u4e0a\u7684\u8fb9\u6743\u8d4b\u503c\u95ee\u9898\uff1a\n\n- \u6700\u5f00\u59cb\u6bcf\u6761\u8fb9\u8fb9\u6743\u4e3a $ 1 $\u3002\uff08\u5747\u662f\u5173\u952e\u8fb9\uff09\n\n- \u6bcf\u6b21\u52a0\u4e0a\u4e00\u6761\u989d\u5916\u8fb9 $ e=(u,v) $\uff0c$ T_0 $ \u4e0a\u4ece $ u $ \u5230 $ v $ \u7684\u8fb9\u8fb9\u6743\u5168\u90e8\u6539\u4e3a $ 0 $\u3002\n\n- \u6bcf\u6b21\u8be2\u95ee $ Q=(x,y) $\uff0c\u7b54\u6848\u5373\u4e3a $ T_0 $ \u4e0a $ x $ \u5230 $ y $ \u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\u3002\n\n\u90a3\u4e48\u76f4\u63a5\u6811\u5256 + \u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=1000005;\nint n,m,op[N],x[N],y[N],tot;\nmap<pair<int,int>,int> mp;\nvector<int> Ans;\nvector< pair<int,int> > els;\nnamespace dsu{\n\tint f[N];\n\tvoid clear(int n){for(int i=1;i<=n;f[i]=i,i++);}\n\tint fa(int s){return f[s]==s?s:f[s]=fa(f[s]);}\n}\nusing namespace dsu;\nnamespace Chain{\n\tint h[N],cnt;\n\tstruct Edge{int next,to;}e[N<<1];\n\tvoid AddEdge(int c,int d){e[++cnt]=(Edge){h[c],d};h[c]=cnt;}\n}\nusing namespace Chain;\nint fp[N];\nnamespace seg{\n\tint v[N<<2],lz[N<<2];\n\t#define lc (p<<1)\n\t#define rc (lc|1)\n\tvoid pushup(int p){v[p]=v[lc]+v[rc];}\n\tvoid bd(int p,int x,int y)\n\t{\n\t\tif(x==y) return void(v[p]=(fp[x]!=1));\n\t\tint mid=x+y>>1;\n\t\tbd(lc,x,mid),bd(rc,mid+1,y);\n\t\tpushup(p);\n\t}\n\tvoid pushdown(int p)\n\t{\n\t\tif(!lz[p]) return;\n\t\tlz[lc]=lz[rc]=lz[p];\n\t\tv[lc]=v[rc]=0;\n\t\tlz[p]=0;\n\t}\n\tvoid update(int p,int x,int y,int l,int r)\n\t{\n\t\tif(x>r || y<l) return;\n\t\tif(l<=x && y<=r) return v[p]=0,lz[p]=1,void();\n\t\tpushdown(p);\n\t\tint mid=x+y>>1;\n\t\tif(l<=mid) update(lc,x,mid,l,r);\n\t\tif(mid+1<=r) update(rc,mid+1,y,l,r);\n\t\tpushup(p);\n\t}\n\tint getans(int p,int x,int y,int l,int r)\n\t{\n\t\tif(x>r || y<l) return 0;\n\t\tif(l<=x && y<=r) return v[p];\n\t\tpushdown(p);\n\t\tint mid=x+y>>1,rec=0;\n\t\tif(l<=mid) rec+=getans(lc,x,mid,l,r);\n\t\tif(mid+1<=r) rec+=getans(rc,mid+1,y,l,r);\n\t\treturn rec;\n\t}\n}\nusing namespace seg;\nnamespace ts{\n\tint top[N],son[N],sign;\n\tint prt[N],siz[N],dep[N],p[N];\n\tvoid dfs(int r,int fa,int d)\n\t{\n\t\tsiz[r]=1; prt[r]=fa; dep[r]=d;\n\t\tfor(int i=h[r];i;i=e[i].next)\n\t\t{\n\t\t\tint y=e[i].to;\n\t\t\tif(y==fa) continue;\n\t\t\tdfs(y,r,d+1);\n\t\t\tsiz[r]+=siz[y];\n\t\t\tif(!son[r] || siz[son[r]]<siz[y]) son[r]=y;\n\t\t}\n\t}\n\tvoid pre(int r,int _)\n\t{\n\t\ttop[r]=_;\n\t\tp[r]=++sign; fp[sign]=r;\n\t\tif(son[r]) pre(son[r],_);\n\t\tfor(int i=h[r];i;i=e[i].next)\n\t\t{\n\t\t\tint y=e[i].to;\n\t\t\tif(y==prt[r] || y==son[r]) continue;\n\t\t\tpre(y,y);\n\t\t}\n\t}\n\tvoid add(int x,int y)\n\t{\n\t\tint f1=top[x],f2=top[y];\n\t\twhile(f1!=f2)\n\t\t{\n\t\t\tif(dep[f1]<dep[f2]) swap(f1,f2),swap(x,y);\n\t\t\tupdate(1,1,n,p[f1],p[x]);\n\t\t\tx=prt[f1],f1=top[x];\n\t\t}\n\t\tif(x==y) return;\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\tupdate(1,1,n,p[son[x]],p[y]);\n\t}\n\tint ask(int x,int y)\n\t{\n\t\tint f1=top[x],f2=top[y],rec=0;\n\t\twhile(f1!=f2)\n\t\t{\n\t\t\tif(dep[f1]<dep[f2]) swap(f1,f2),swap(x,y);\n\t\t\trec+=getans(1,1,n,p[f1],p[x]);\n\t\t\tx=prt[f1],f1=top[x];\n\t\t}\n\t\tif(x==y) return rec;\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\treturn rec+getans(1,1,n,p[son[x]],p[y]);\n\t}\n\tvoid output()\n\t{\n\t\tfor(int i=1;i<=n;i++) printf(\"%d %d\\n\",i,getans(1,1,n,p[i],p[i]));puts(\"\");\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tclear(n);\n\tfor(int i=1,A,B;i<=m;i++) \n\t{\n\t\tscanf(\"%d %d\",&A,&B);\n\t\tmp[make_pair(A,B)]++;\n\t}\n\twhile(true)\n\t{\n\t\t++tot;\n\t\tscanf(\"%d\",&op[tot]);\n\t\tif(op[tot]==-1) break;\n\t\tscanf(\"%d %d\",x+tot,y+tot);\n\t\tif(op[tot]==0)\n\t\t\tif(mp.count(make_pair(x[tot],y[tot]))) mp[make_pair(x[tot],y[tot])]--;\n\t\t\telse mp[make_pair(y[tot],x[tot])]--;\n\t} --tot;\n\t\n\tfor(map<pair<int,int>,int>::iterator it=mp.begin();it!=mp.end();++it)\n\t{\n\t\tif(!it->second) continue;\n\t\tint x=it->first.first,y=it->first.second;\n\t\tif(fa(x)==fa(y)) els.push_back(it->first);// P_0 \u4e2d\u9664 T_0 \u4ee5\u5916\u7684\u8fb9 \n\t\telse\n\t\t{\n\t\t\tf[fa(x)]=fa(y);\n\t\t\tAddEdge(x,y),AddEdge(y,x);\n\t\t}\n\t}\n\tts::dfs(1,-1,0); ts::pre(1,1);\n\tbd(1,1,n);\n\tfor(int i=0;i!=els.size();++i) ts::add(els[i].first,els[i].second);\n\tfor(int i=tot;i>=1;i--)\n\t{\n\t\tif(op[i]==1) Ans.push_back(ts::ask(x[i],y[i]));\n\t\telse if(op[i]==0) ts::add(x[i],y[i]);\n\t}\n\treverse(Ans.begin(),Ans.end());\n\tfor(int i=0;i!=Ans.size();++i) printf(\"%d\\n\",Ans[i]);\n}\n```\n\n\n\n",
        "postTime": 1667558909,
        "uid": 432127,
        "name": "Avocadooo",
        "ccfLevel": 0,
        "title": "[AHOI2005]\u822a\u7ebf\u89c4\u5212-\u9898\u89e3"
    },
    {
        "content": "[\u9898](https://www.luogu.com.cn/problem/P2542)\n\n### \u9898\u76ee\u5927\u610f\uff1a\n\n\u5bf9\u4e8e\u4e00\u4e2a\u56fe\uff0c\u652f\u6301\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n- 1 u v\uff0c\u8be2\u95ee u,v \u8def\u5f84\u4e0a\u5fc5\u7ecf\u8fc7\u7684\u8def\u5f84\u7684\u4e2a\u6570\u3002\n\n- 0 u v\uff0c\u65ad\u5f00 u,v\u3002\n\n$1\\le n\\le 3\\times 10^4,1\u2264m\u226410^5,1\\le q\\le 4\\times 10^4$\u3002\n\n### \u601d\u8def\uff1a\n\n\u5fc5\u987b\u7ecf\u8fc7\u7684\u8fb9\uff0c\u4e5f\u5c31\u662f\u65ad\u4e86\u8fd9\u6761\u8fb9\u4e4b\u540e\u4e24\u70b9\u6ca1\u6709\u8def\u5f84\u3002\n\n\u8fd9\u662f\u4e0d\u662f\u5f88\u50cf\u201c\u6865\u201d\u7684\u5b9a\u4e49\uff1f\n\n\u76f4\u63a5 e-DCC\uff0c\u5904\u7406\u73af\u4e4b\u540e\uff0c\u7b54\u6848\u5c31\u662f\u4e24\u70b9\u8def\u5f84\u4e0a\u7684\u4e2a\u6570\u3002\n\n\u600e\u4e48\u7ef4\u62a4\u4e00\u4e2a e-DCC \u5462\uff1f\n\n\u65ad\u8fb9\u64cd\u4f5c\u6bd4\u8f83\u590d\u6742\uff08\u81f3\u5c11\u73b0\u5728\u6211\u662f\u4e0d\u77e5\u9053\u600e\u4e48\u505a\uff09\uff0c\u5904\u7406\u73af\u7684\u65f6\u5019\u5982\u679c\u52a0\u8fb9\u5c31\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u4e86\u3002\n\n\u8003\u8651\u79bb\u7ebf\u52a0\u8fb9\u64cd\u4f5c\u3002\u7528 LCT \u6765\u7ef4\u62a4\u8fd9\u4e2a siz\u3002\n\n\u5982\u679c\u4e00\u4e9b\u70b9\u5728\u4e00\u4e2a\u73af\u4e0a\uff0c\u90a3\u4e48\u8fd9\u7fa4\u4e2a\u70b9\u89c6\u4e3a\u4e00\u4e2a\u70b9\u3002\n\n\u6bcf\u6b21\u64cd\u4f5c\u4e4b\u524d\u5148 find(x) \u4e00\u4e0b\uff0c\u7136\u540e\u5bf9\u4e8e\u8fd9\u4e2a\u70b9\uff0c\u65ad\u5f00\u4e0e\u5176\u4e3a\u73af\u7684\u6240\u6709\u8fde\u8fb9\u3002\n\n\u8fd9\u6837\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u80fd\u4fdd\u8bc1\u4e86\u3002\n\n\u4e00\u4e9b\u8981\u6ce8\u610f\u7684\u7ec6\u8282\uff1a\n\n- \u54ea\u91cc\u90fd\u8981 find(p) \u4e00\u4e0b\u3002\n\n- \u4e00\u5f00\u59cb\u5224\u91cd\u662f\u53cc\u5411\u8fb9\uff0c\u6240\u4ee5\u8981\u53cc\u5411\u5224\u91cd\u3002\n\n### Code:\n\n```cpp\n// \u672a\u52a0\u9632\u4f5c\u5f0a\n#include <bits/stdc++.h>\n#define I inline\n#define RI register int\n#define CI const int\n#define ls ch[p][0]\n#define rs ch[p][1]\n#define N 30005\n#define M 100005\nusing namespace std;\n\nint top, t, n, m, u, v, op, x, y, tot, X[N], Y[N], OP[N], ans[N], st[N], f[N], sz[N], tag[N], fa[N], ch[N][2];\nmap<int, map<int, int> > mp;\n\nI int find(CI x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\nI void merge(CI x, CI y) {\n    RI fx = find(x), fy = find(y);\n    if (fx != fy)\n        fa[fx] = fy;\n}\nI bool get(CI p) { return ch[find(f[p])][1] == p; }\nI bool isroot(CI p) { return ch[find(f[p])][0] != p && ch[find(f[p])][1] != p; }\nI void down(CI p) {\n    if (!tag[p])\n        return;\n    swap(ls, rs), tag[ls] ^= 1, tag[rs] ^= !(tag[p] = 0);\n}\nI void up(CI p) {\n    down(ls), down(rs);\n    sz[p] = 1 + (ls ? sz[ls] : 0) + (rs ? sz[rs] : 0);\n}\nI void rotate(int x) {\n    x = find(x);\n    RI y = find(f[x]), z = find(f[y]), k = get(x);\n    if (!isroot(y))\n        ch[z][ch[z][1] == y] = x;\n    f[ch[y][k] = ch[x][!k]] = y;\n    f[ch[x][!k] = y] = x;\n    f[x] = z;\n    up(y), up(x);\n}\nI void splay(CI x) {\n    RI i = x, y;\n    st[top = 1] = find(i);\n    while (!isroot(i)) st[++top] = i = find(f[i]);\n    while (top) down(st[top--]);\n    for (i = find(x); y = find(f[i]), !isroot(i); rotate(i))\n        if (!isroot(y))\n            rotate(get(i) == get(y) ? y : i);\n}\nI void access(CI x) {\n    RI p = find(x), q;\n    for (q = 0; p; q = p, p = find(f[p])) splay(p), rs = q, up(p);\n}\nI void makeroot(int x) {\n    x = find(x);\n    access(x), splay(x), tag[x] ^= 1;\n}\nI int findroot(int x) {\n    RI p = (x = find(x));\n    access(x), splay(x);\n    while (ls) down(ls), p = ls;\n    return splay(p), p;\n}\nI void split(CI x, CI y) { makeroot(x), access(y), splay(y); }\nI void dfs(CI p, CI q) {\n    down(p);\n    if (ls)\n        merge(ls, q), dfs(ls, q);\n    if (rs)\n        merge(rs, q), dfs(rs, q), ls = rs = 0, up(p);\n}\n\nint main() {\n    RI i;\n    for (scanf(\"%d%d\", &n, &m), i = 1; i <= m; i++) scanf(\"%d%d\", &x, &y), mp[x][y] = mp[y][x] = 1;\n    for (i = 1; i <= n; i++) fa[i] = i;\n    while (scanf(\"%d\", &op) && op != -1) {\n        scanf(\"%d%d\", &x, &y), OP[++tot] = op, X[tot] = x, Y[tot] = y;\n        if (!op)\n            mp[x][y] = mp[y][x] = 0;\n    }\n    for (map<int, map<int, int> >::iterator it = mp.begin(); it != mp.end(); it++) {\n        for (map<int, int>::iterator it2 = mp[it->first].begin(); it2 != mp[it->first].end(); it2++) {\n            if (!(it2->second))\n                continue;\n            mp[it2->first][it->first] = 0;\n            x = find(it->first), y = find(it2->first);\n            if (x == y)\n                continue;\n            if (findroot(x) != findroot(y))\n                makeroot(x), f[x] = y;\n            else\n                split(x, y), dfs(y, y), up(y), 0;\n        }\n    }\n    for (i = tot; i; i--) {\n        x = find(X[i]), y = find(Y[i]);\n        if (!OP[i])\n            split(x, y), dfs(y, y), up(y);\n        else\n            split(x, y), ans[++ans[0]] = sz[y] - 1;\n    }\n    for (i = ans[0]; i; i--) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```",
        "postTime": 1604470182,
        "uid": 115857,
        "name": "resound_WANYI_13Ell",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005] \u822a\u7ebf\u89c4\u5212\u3011"
    },
    {
        "content": "\uff08\u6211\u505a\u8fd9\u9053\u9898\u662f\u4ee5\u5b66\u6821OJ\u4e0a\u7684\u9898\u9762\u4e3a\u51c6\u7684\uff0c\u90a3\u91cc\u662f\u5148\u8f93\u5165\u64cd\u4f5c\u6b21\u6570\u4e4b\u540e\u64cd\u4f5c\uff0c\u6700\u540e\u4e0d\u4f1a\u8f93\u51fa-1\u7684\uff09\n\n\n\n\u8003\u8bd5\u65f6\u8003\u8fd9\u9053\u9898\u5df2\u7ecf\u6ca1\u591a\u5c11\u65f6\u95f4\u4e86\uff0c\u4e8e\u662f\u4f7f\u7528\u4e86\u8d85\u7ea7\u9a97\u5206\u6cd5\uff1a\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,k,a1,b1,c1;\nint main(){\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=m;i++) scanf(\"%d%d\",&a1,&b1);\n\tfor(int i=1;i<=k;i++{\n\t\tscanf(\"%d%d%d\",&c1,&a1,&b1);\n\t\tif(c1){\n\t\t\tif(m==n-1) printf(\"%d\\n\",m);\n\t\t\telse printf(\"0\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\u5728luogu\u4e0a\u5f97\u4e8610\u5206\u4f46\u5728\u5b66\u6821OJ\u4e0a\u5f97\u4e8660\u5206\uff1f\uff1f\uff01\uff1f\uff1f\uff1f\uff1f\uff01\uff01\uff01\n\n\n\u8bdd\u4e0d\u591a\u8bf4\uff0c\u8fdb\u5165\u6b63\u9898\uff1a\n\n60\u5206\uff1a\n\n\u4e5f\u5c31\u662f\u6ca1\u6709\u5220\u8fb9\u7684\u60c5\u51b5\uff0c\u53ef\u4ee5\u5148\u4f7f\u7528tarjin\u7f29\u70b9\u53d8\u4e3a\u6811\uff08\u4efb\u610f\u4e00\u4e2a\u8fde\u901a\u5b50\u96c6\u4e0a\u7684\u8fb9\u5fc5\u4e3a\u4e0d\u53d6\uff09\uff0c\u4e4b\u540e\u4f7f\u7528lca\u5373\u53ef\u3002\n\n100\u5206\uff1a\n\n\u6211\u7684\u601d\u8def\u662f\u6811\u5256+\u5e76\u67e5\u96c6+BIT\uff08\u6811\u72b6\u6570\u7ec4\uff09+dfs\u5e8f\u3002\n\n1.\u5148\u4ee5\u90a3\u4e9b\u6ca1\u6709\u88ab\u5220\u6389\u7684\u8fb9\u53d6n-1\u4e2a\u6765\u5efa\u6811\u3002\u5728\u6811\u94fe\u5256\u5206\u7684\u9884\u5904\u7406\u4e0a\u5c31\u53ef\u4ee5\u505a\u5230\u4e86\u3002\u5e76\u4e14\u987a\u4fbf\u5b58\u4e00\u4e0bdfs\u5e8f\uff0c\u4ee5\u4fbf\u540e\u7eed\u4f7f\u7528BIT\u3002\u5728\u7b2c\u4e8c\u6b21dfs\u65f6\u6bcf\u641c\u5230\u4e00\u4e2a\u70b9\u4e14\u4e0d\u4e3a1\u5c31\u5728\u6811\u72b6\u6570\u7ec4\u4e0a\u7684\u8fd9\u4e2a\u70b9+1\uff08while(x<=n) c[x]+=1,x+=x&-x;\uff09\n\n2.\u6b64\u65f6\u5047\u5982\u53ea\u6709\u8fd9n-1\u6761\u8fb9\u5c31\u80fd\u4fdd\u8bc1\u4efb\u610f\u4e24\u70b9\u7684\u5173\u952e\u8fb9\u4e2a\u6570\u4e3a\u4e24\u70b9\u6811\u4e0a\u8def\u5f84\u8fb9\u7684\u4e2a\u6570\u3002\u90a3\u4e48\u6bcf\u8fde\u4e00\u6761\u8fb9\u90fd\u80fd\u4f7f\u8fd9\u4e24\u70b9\u7684\u8def\u5f84\u4e0a\u6240\u6709\u7684\u70b9\u90fd\u53d8\u4e3a\u4e0d\u53ef\u80fd\u88ab\u6210\u4e3a\u5173\u952e\u8fb9\u7684\u8fb9\uff08\u597d\u7ed5\uff09\u3002\u8fd9\u79cd\u60c5\u51b5\u4f7f\u7528\u6811\u94fe\u5256\u5206\u662f\u4e0d\u592a\u53ef\u80fd\u505a\u5230\u7684\uff0c\u5982\u679c\u66b4\u529b\u679a\u4e3e\u4e00\u904d\u590d\u6742\u5ea6\u4e3an*m\u4e5f\u70b8\u4e86\uff0c\u4f46\u662f\u6ce8\u610f\u5230\u6700\u591a\u53ea\u6709n-1\u6761\u8fb9\u4f1a\u88ab\u6539\u53d8\u56e0\u6b64\u53ef\u4ee5\u60f3\u529e\u6cd5\u53bb\u91cd\uff0c\u4e5f\u5c31\u662f\u4fdd\u8bc1\u5df2\u88ab\u6539\u53d8\u7684\u70b9\u4e0d\u4f1a\u518d\u6b21\u88ab\u66f4\u65b0\u5373\u53ef\u3002\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528\u5e76\u67e5\u96c6\u5b58\u6bcf\u4e2a\u70b9\u7684\u6700\u4f4e\u7684\u8fd8\u672a\u4fee\u6539\u8fc7\u7684\u7956\u5148\uff0c\u8fd9\u6837x\u5c31\u53ef\u4ee5\u6bcf\u6b21\u8df3\u5230find(x)\u4e0a\u5e76\u4e14\u5c06Fa[find(x)]=find(fa[x]).Fa\u4e3a\u5e76\u67e5\u96c6\u4e2d\u7684\u7236\u8282\u70b9\uff0cfa\u4e3a\u6811\u4e0a\u7684\u7236\u8282\u70b9\uff0c\u8fd9\u6837\u5c31\u80fd\u5c06\u65f6\u95f4\u590d\u6742\u5ea6\u7f29\u51cf\u5230O(n)\u7684\u7ea7\u522b\u3002\u6bcf\u641c\u5230\u4e00\u4e2a\u70b9\u8fd8\u8981\u5728\u6811\u72b6\u6570\u7ec4\u4e0a-1\u3002\n\n3.\u4e4b\u540e\u5012\u53d9\u64cd\u4f5c\u6bcf\u4e00\u6b65\u8be2\u95ee/\u4fee\u6539\uff0c\u8be2\u95ee\u4f7f\u7528\u6811\u94fe\u5256\u5206\u5373\u53ef\uff0c\u4fee\u6539\u540c2.\u3002\n\t\n\n\u56e0\u6b64\u5c31A\u4e86\u3002\n\u4ee3\u7801\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define M 100100\nusing namespace std;\n\n//\u5b9a\u4e49\u57fa\u672c\u53d8\u91cf=====\nint n,m,k,ans[M],sum;\nint st[M],en[M]/*\u8868\u793a\u8f93\u5165\u7684\u8fb9\u7684\u8d77\u70b9\u7ec8\u70b9*/;\nint st2[M],en2[M]/*\u8868\u793a\u67e5\u8be2\u7684\u8fb9\u7684\u8d77\u70b9\u7ec8\u70b9*/,pd[M];\nint sE[M]/*\u8bb0\u5f55\u6bcf\u4e00\u6761\u8fb9\u6240\u5bf9\u5e94\u7684\u662f\u7b2c\u51e0\u4e2a\u8be2\u95ee*/;\nmap<int,int>E[M]/*E[x][y]\u8868\u793ax\u5230y\u5bf9\u5e94\u7684\u662f\u7b2c\u51e0\u6761\u8fb9*/;\n//================= \n\n//\u90bb\u63a5\u8868=========== \n\nint cnt,to[M*2],id[M*2],nxt[M*2],first[M];\n\nvoid addedge(int x,int y,int z){\n\tcnt++;\n\tto[cnt]=y;\n\tid[cnt]=z;\n\tnxt[cnt]=first[x];\n\tfirst[x]=cnt;\n}\n\n//=================\n \n//bit==============\n\nint c[M];\n\nvoid addsum(int x,int w){\n\twhile(x<=n)c[x]+=w,x+=x&-x;\n}\n\nint ask(int x){\n\tint res=0;\n\twhile(x)res+=c[x],x-=x&-x;\n\treturn res;\n}\n\n//=================\n\n//\u6811\u94fe\u5256\u5206========= \n\nint gone[M]/*\u8868\u793a\u662f\u5426\u8d70\u8fc7\u6b64\u70b9*/;\nint in[M]/*\u8868\u793a\u6811\u4e2d\u662f\u5426\u6709\u6b64\u8fb9*/;\nint dep[M],sz[M],son[M],fa[M];\nint ID[M]/*\u8bb0\u5f55dfs\u5e8f*/,top[M],C/*dfs\u5e8f*/; \n\nvoid search(int x,int f){\n\tfa[x]=f,sz[x]=1,gone[x]=1,dep[x]=dep[f]+1;\n\tfor(int i=first[x];i;i=nxt[i]){\n\t\tint y=to[i];\n\t\tif(y==f||gone[y]||sE[id[i]]) continue;\n\t\tin[id[i]]=1,search(y,x);\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>sz[son[x]]) son[x]=y;\n\t}\n}\n\nvoid dfs(int x,int tp){\n\tID[x]=++C,top[x]=tp;\n\tif(son[x]) dfs(son[x],tp);\n\tif(x!=1) addsum(ID[x],1);\n\tfor(int i=first[x];i;i=nxt[i]){\n\t\tint y=to[i];\n\t\tif(y!=fa[x]&&y!=son[x]&&in[id[i]]) dfs(y,y);\n\t}\n}\n\nint query(int x,int y){\n\tint res=0;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tres+=ask(ID[x])-ask(ID[top[x]]-1);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]<dep[y]) swap(x,y);\n\tres+=ask(ID[x])-ask(ID[y]);\n\treturn res;\n}\n\n//=================\n\n//\u5e76\u67e5\u96c6\u5904\u7406===========\n\nint Fa[M],mark[M];\n\nint find(int x){\n\tif(Fa[x]!=x) Fa[x]=find(Fa[x]);\n\treturn Fa[x];\n}\n\nvoid jump(int x,int y){\n\tx=find(x),y=find(y);\n\tif(x!=y)Fa[x]=y;\n}\n\nvoid Add(int x,int y){\n\twhile(x!=y){\n\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\tjump(x,fa[x]);\n\t\tif(x!=1&&!mark[x]) mark[x]=1,addsum(ID[x],-1);\n\t\tx=find(x);\n\t}\n}\n\n//=================\n\n//\u4e3b\u7a0b\u5e8f===========\n\nint main(){\n\t\n\t//\u8f93\u5165=========ok\n\t\n\tcin>>n>>m>>k;\n\tfor(int i=1;i<=n;i++) Fa[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&st[i],&en[i]);\n\t\taddedge(st[i],en[i],i),addedge(en[i],st[i],i);\n\t\tE[st[i]][en[i]]=i;\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\tscanf(\"%d%d%d\",&pd[i],&st2[i],&en2[i]);\n\t\tif(!pd[i]) sE[E[st2[i]][en2[i]]]=i;\n\t}\n\t\n\t//cout<<\"\u8bfb\u5165\u5b8c\u6bd5\"<<endl;\n\t\n\t//\u9884\u5904\u7406\u6811\u5256===ok\n\t\n\tsearch(1,0),dfs(1,1);\n\t\n\t//cout<<\"\u6811\u5256\u9884\u5904\u7406\u5b8c\u6bd5\"<<endl;\n\t\n\t//\u5efa\u6811=========ok\n\t\n\tfor(int i=1;i<=m;i++)\n\t\tif(!in[i]&&!sE[i]){\n\t\t\tAdd(st[i],en[i]);\n\t\t}\n\t\t\n\t//cout<<\"\u5efa\u6811\u5b8c\u6bd5\"<<endl;\n\t\n\t//\u5904\u7406\u8be2\u95ee=====ok\n\t\n\tfor(int i=k;i>=1;i--){\n\t\tif(pd[i])ans[++sum]=query(st2[i],en2[i]);\n\t\telse if(E[st2[i]][en2[i]])Add(st2[i],en2[i]);\n\t}\n\t\n\t//cout<<\"\u5904\u7406\u8be2\u95ee\u5b8c\u6bd5\"<<endl;\n\t\n\t//\u8f93\u51fa=========ok\n\t\n\tfor(int i=sum;i>=1;i--) printf(\"%d\\n\",ans[i]);\n\t\n\t//cout<<\"\u8f93\u51fa\u5b8c\u6bd5\"<<endl;\n\t\n\t//over=========ok\n\t\n\treturn 0;\n\t\n\t//=============\n\t\n}\n\n//=================\n```\n\uff08\u5b57\u6570\u5f3a\u884c\u5361\u5230\u4e863000\u5b57\u6574\uff09\n",
        "postTime": 1566024885,
        "uid": 40262,
        "name": "EnochWenzhou",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2542 \u3010[AHOI2005]\u822a\u7ebf\u89c4\u5212\u3011"
    }
]