[
    {
        "content": "\u5b89\u5229\u4e2a\u4eba[](http://blog.csdn.net/A_Comme_Amour/article/details/79580875)\u535a\u5ba2\n\n\u9898\u76ee\n-\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problemnew/show/P2045)\n\u7ed9\u51fa\u4e00\u4e2an*n\u7684\u77e9\u9635,\u6bcf\u4e00\u683c\u6709\u4e00\u4e2a\u975e\u8d1f\u6574\u6570Aij,(Aij <= 1000)\u73b0\u5728\u4ece(1,1)\u51fa\u53d1,\u53ef\u4ee5\u5f80\u53f3\u6216\u8005\u5f80\u4e0b\u8d70,\u6700\u540e\u5230\u8fbe(n,n),\u6bcf\u8fbe\u5230\u4e00\u683c,\u628a\u8be5\u683c\u5b50\u7684\u6570\u53d6\u51fa\u6765,\u8be5\u683c\u5b50\u7684\u6570\u5c31\u53d8\u62100,\u8fd9\u6837\u4e00\u5171\u8d70K\u6b21,\u73b0\u5728\u8981\u6c42K\u6b21\u6240\u8fbe\u5230\u7684\u65b9\u683c\u7684\u6570\u7684\u548c\u6700\u5927\n\u9898\u89e3\n-\n\n\u505a\u4e86\u51e0\u9053\u7f51\u7edc\u6d41\u7684\u9898\u76ee\uff0c\u5bf9\u5efa\u56fe\u6709\u4e00\u4e9b\u7406\u89e3\u3002\n1. \u8d85\u7ea7\u6e90\u70b9\u548c\u8d85\u7ea7\u6c47\u70b9\u5206\u522b\u8fde\u5411\uff081,1\uff09\uff08n , n\uff09\uff0c\u5bb9\u91cf\u4e3ak\uff0c\u8d39\u7528\u4e3a0\uff0c\u4ec5\u8868\u793a\u4e00\u5171\u53ef\u4ee5\u8d70k\u6b21\uff1b\n2. \u5bf9\u4e8e\u65b9\u683c\u4e2d\u7684\u6bcf\u4e2a\u70b9\uff0c\u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u5206\u522b\u4e3a\u5165\u70b9\u548c\u51fa\u70b9\u3002\u5165\u70b9\u548c\u51fa\u70b9\u4e4b\u95f4\u8fde\u4e24\u6761\u8fb9\uff0c\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a\u70b9\u7684\u6743\u503c\uff0c\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u6570\u53ea\u53ef\u4ee5\u53d6\u4e00\u6b21\uff1b\u53e6\u4e00\u6761\u5bb9\u91cf\u4e3ainf\uff0c\u8d39\u7528\u4e3a0\uff0c\u4ec5\u8868\u793a\u53ef\u4ee5\u7ecf\u8fc7\u65e0\u6570\u6b21\uff1b\n3. \u5bf9\u4e8e\u5728\u5176\u4e0b\u65b9\u6216\u53f3\u8fb9\u70b9\u7684\u70b9\uff0c\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3ainf\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u8868\u793a\u4e14\u4ec5\u8868\u793a\u4e00\u79cd\u8054\u901a\u7684\u5173\u7cfb\n\n\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\uff0c\u5b9e\u73b0\u4e0a\u6709\u4e00\u4e2a\u5c0f\u6280\u5de7\uff0c\u5373\u628a\u8d39\u7528\u8bbe\u4e3a\u8d1f\u6570\uff0c\u518d\u53d6\u76f8\u53cd\u6570\u5373\u53ef\n\u4ee3\u7801\n-\n\n\n```\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<queue>\nusing namespace std;\nconst int maxn=100001;\nconst int inf=1e9;\n\nint n,m,S,T,k,maxflow,mincost,last[maxn],pre[maxn],dis[maxn],flow[maxn];\nbool vis[maxn];\nstruct Edge{\n\tint next,to,flow,dis;\n}edge[maxn<<1];\nint num_edge=-1,head[maxn];\nqueue <int> q;\nint id(int x,int y) {return n*(x-1)+y;}\n\nvoid add_edge(int from,int to,int flow,int dis)//flow\u6d41\u91cf dis\u8d39\u7528 \n{\n\tedge[++num_edge].next=head[from];\n\tedge[num_edge].flow=flow;\n\tedge[num_edge].dis=dis;\n\tedge[num_edge].to=to;\n\thead[from]=num_edge;\n}\nvoid add(int x,int y,int z,int f) {add_edge(x,y,z,f); add_edge(y,x,0,-f);}\n\nbool spfa(int s,int t)\n{\n\tmemset(dis,0x7f,sizeof(dis));\n\tmemset(flow,0x7f,sizeof(flow));\n\tmemset(vis,0,sizeof(vis));\n\twhile (!q.empty()) q.pop();\n\tdis[s]=0; pre[t]=-1; q.push(s); vis[s]=1;\n\tint tot=0;\n\twhile (!q.empty())\n\t{\n\t\tint now=q.front(); q.pop(); vis[now]=0;\n//\t\tprintf(\"%d \",now); if (++tot==200) return 0;\n\t\tfor (int i=head[now]; i!=-1; i=edge[i].next)\n\t\t{\n\t\t\tint to=edge[i].to;\n\t\t\tif  (edge[i].flow>0 && dis[to]>dis[now]+edge[i].dis)\n\t\t\t{\n\t\t\t\tdis[to]=edge[i].dis+dis[now];\n\t\t\t\tflow[to]=min(edge[i].flow,flow[now]);\n\t\t\t\tlast[to]=i;\n\t\t\t\tpre[to]=now;\n\t\t\t\tif (!vis[to])\n\t\t\t\t{\n\t\t\t\t\tq.push(to); vis[to]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[t]!=-1;\n}\n\nvoid MCMF(int s,int t)\n{\n\twhile (spfa(s,t))\n\t{\n\t\tint now=t;\n\t\tmaxflow+=flow[t];\n\t\tmincost+=flow[t]*dis[t];\n\t\twhile (now!=s)\n\t\t{\n\t\t\tedge[last[now]].flow-=flow[t];//dis . flow\n\t\t\tedge[last[now]^1].flow+=flow[t];\n\t\t\tnow=pre[now];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&k);\n\tS=0; T=2*n*n+1;\n\tadd(S,id(1,1),k,0); add(id(n,n)+n*n,T,k,0);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); x=-x;\n\t\t\tadd(id(i,j),id(i,j)+n*n,1,x);\n\t\t\tadd(id(i,j),id(i,j)+n*n,inf,0);\n\t\t\tif (i<n) add(id(i,j)+n*n,id(i+1,j),inf,0);\n\t\t\tif (j<n) add(id(i,j)+n*n,id(i,j+1),inf,0);\n\t\t}\n\tfor (int i=0; i<=num_edge; i++) \n//\tprintf(\"%d: %d %d %d %d\\n\",i,edge[i^1].to,edge[i].to,edge[i].dis,edge[i].flow);\n\tn=T;//\u70b9\u6570 \n\tMCMF(S,T);\n\tprintf(\"%d\",-mincost);\n\treturn 0;\n}\n```\n\n\u603b\u7ed3\n-\n\n\u9650\u5236\u8d70\u7684\u6b21\u6570\u4e00\u822c\u8f6c\u5316\u4e3a\u7f51\u7edc\u6d41\u4e2d\u8fb9\u6743\u7684\u95ee\u9898\uff1b\n\u62c6\u70b9\u8fde\u5bb9\u91cf\u4e3a1\u7684\u8fb9\u8868\u793a\u53ea\u80fd\u53d6\u4e00\u6b21\uff1b\u5bb9\u91cf\u4e3ainf\u7684\u8fb9\u8868\u793a\u53ef\u4ee5\u8d70\u7684\u5173\u7cfb\n\u53c8\u51fa\u9519\u4e86\uff1aid\uff08n\uff0cn\uff09\u5411T\u8fde\u8fb9\u800c\u4e0d\u662fid\uff08n\uff0cn\uff09\u3002\u53c8\u8c03\u4e86\u597d\u957f\u65f6\u95f4",
        "postTime": 1521182136,
        "uid": 48036,
        "name": "\u79cb\u65e5\u79c1\u8bed",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "\u9898\u76ee\u5730\u5740\uff1a[P2045 \u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248](https://www.luogu.org/problemnew/show/P2045)\n\n1. \u70b9\u8fb9\u8f6c\u5316\uff1a\u628a\u6bcf\u4e2a\u683c\u5b50 $(i,j)$ \u62c6\u6210\u4e00\u4e2a\u5165\u70b9\u4e00\u4e2a\u51fa\u70b9\u3002\n2. \u4ece\u6bcf\u4e2a\u5165\u70b9\u5411\u5bf9\u5e94\u7684\u51fa\u70b9\u8fde\u4e24\u6761\u6709\u5411\u8fb9\uff1a\u4e00\u6761\u5bb9\u91cf\u4e3a $1$ \uff0c\u8d39\u7528\u4e3a\u683c\u5b50 $(i,j)$ \u4e2d\u7684\u6570\uff1b\u53e6\u4e00\u6761\u5bb9\u91cf\u4e3a $k-1$ \uff0c\u8d39\u7528\u4e3a $0$ \u3002\n3. \u4ece $(i,j)$ \u7684\u51fa\u70b9\u5230 $(i,j+1)$ \u548c $(i+1,j)$ \u7684\u5165\u70b9\u8fde\u6709\u5411\u8fb9\uff0c\u5bb9\u91cf\u4e3a $k$ \uff0c\u8d39\u7528\u4e3a $0$ \u3002\n4. \u4ee5 $(1,1)$ \u7684\u5165\u70b9\u4e3a\u6e90\u70b9\uff0c $(n,n)$ \u7684\u51fa\u70b9\u4e3a\u6c47\u70b9\uff0c\u6c42\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 5e3 + 6, M = 2e5 + 6;\nconst int inf = 0x3f3f3f3f, _inf = 0xcfcfcfcf;\nint Head[N], Edge[M], Leng[M], Cost[M], Next[M], tot = 1;\nint d[N], f[N], p[N];\nbool v[N];\nint n, k, s = 1, t, ans;\n\ninline void add(int x, int y, int z, int c) {\n\tEdge[++tot] = y;\n\tLeng[tot] = z;\n\tCost[tot] = c;\n\tNext[tot] = Head[x];\n\tHead[x] = tot;\n\tEdge[++tot] = x;\n\tLeng[tot] = 0;\n\tCost[tot] = -c;\n\tNext[tot] = Head[y];\n\tHead[y] = tot;\n}\n\ninline int num(int i, int j, int k) {\n\treturn (i - 1) * n + j + k * n * n;\n}\n\ninline bool spfa() {\n\tqueue<int> q;\n\tmemset(d, 0xcf, sizeof(d));\n\tmemset(v, 0, sizeof(v));\n\tq.push(s);\n\td[s] = 0;\n\tv[s] = 1;\n\tf[s] = inf;\n\twhile (q.size()) {\n\t\tint x = q.front();\n\t\tv[x] = 0;\n\t\tq.pop();\n\t\tfor (int i = Head[x]; i; i = Next[i]) {\n\t\t\tif (!Leng[i]) continue;\n\t\t\tint y = Edge[i];\n\t\t\tif (d[y] < d[x] + Cost[i]) {\n\t\t\t\td[y] = d[x] + Cost[i];\n\t\t\t\tf[y] = min(f[x], Leng[i]);\n\t\t\t\tp[y] = i;\n\t\t\t\tif (!v[y]) {\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tv[y] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t] != _inf;\n}\n\nvoid upd() {\n\tint x = t;\n\twhile (x != s) {\n\t\tint i = p[x];\n\t\tLeng[i] -= f[t];\n\t\tLeng[i^1] += f[t];\n\t\tx = Edge[i^1];\n\t}\n\tans += d[t] * f[t];\n}\n\nint main() {\n\tcin >> n >> k;\n\tt = 2 * n * n;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), 1, c);\n\t\t\tadd(num(i, j, 0), num(i, j, 1), k - 1, 0);\n\t\t\tif (j < n) add(num(i, j, 1), num(i, j + 1, 0), k, 0);\n\t\t\tif (i < n) add(num(i, j, 1), num(i + 1, j, 0), k, 0);\n\t\t}\n\twhile (spfa()) upd();\n\tcout << ans << endl;\n\treturn 0;\n}\n```\n",
        "postTime": 1552324746,
        "uid": 100544,
        "name": "xht",
        "ccfLevel": 9,
        "title": "P2045 \u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248"
    },
    {
        "content": "\u9ad8\u7ea7\u7248\n\n\u300a\u4e00\u770b\u5c31\u662f\u7f51\u7edc\u6d41\uff0c\u601d\u60f3\u7b80\u5355\uff0cbug\u96be\u8c03\uff0c\u5199\u8fd9\u7bc7\u9898\u89e3\u4e3b\u8981\u662f\u7ed9\u5927\u5bb6\u63d0\u4e2a\u9192\uff0c\uff0c\uff08\u5916\u52a0\u9898\u89e3\u592a\u5c11\u3002\uff09\n\n\u697c\u4e0a\u601d\u8def\u6e05\u6670\uff0c\u90a3\u6211\u4e3b\u8981\u8bf4\u8bf4\u7a0b\u5e8f\n\nSPFA\u4f18\u5316\uff1a\u6ce8\u610f\u987a\u5e8f\n\n\u5efa\u8fb9\u65f6\uff0c\u56e0\u4e3a\u662f\u62c6\u70b9\uff0c\u6240\u4ee5\u5e94\u8bbe\u6d41\u91cf\u552f\u4e00\uff0c\u4f46\u8d70\u4e86\u4e00\u904d\u53ef\u4ee5\u7ee7\u7eed\u8d70\uff0c\u9ad8\u80fd\u9884\u8b66\uff01\uff01\u6b64\u65f6\u53ea\u80fd\u8d70k-1\u6b21\uff1b\n\n\u5176\u4f59\u7684\u8fb9\u53ef\u4ee5\u8d70k-1\u6b21\uff1b\u300b\n\n\u521d\u7ea7\u7248\n\n\u5982\u679c\u521a\u505a\u4e86\u65b9\u683c\u53d6\u6570\uff0c\u5bb9\u6613\u88ab\u8bef\u5bfc\u3002\u3002\n\n\u56e0\u4e3ak\u6b21\uff0c\u62d2\u7edd\u66b4\u529b\n\n\u5bb9\u6613\u60f3\u8d77\uff0c\u5bf9\u8fb9\u7684\u6b21\u6570\u6709\u9650\u5236\uff0c\u65b9\u5411\u660e\u786e\uff0c\u7f51\u7edc\u6d41\u554a\uff01\n\n\u4e0a\u4ee3\u7801\n\n    \n```cpp\n#include<cstdio>\n#include<algorithm>\n#define inf 0x7fffffff\n#define mini 0x7fffffff/2\n#define mew 5050000\nusing namespace std;\nint n,k,ks,js,ahavev,amoney,pos=1;\nint lata[mew],head[mew],qe[mew],used[mew];\nstruct s\n{\n    int last,now,canv,money;\n}data[mew];\nstruct ss\n{\n    int fromd,num,havev,cost;\n}vivo[mew];\nvoid add(int a,int b,int c,int d)\n{\n    data[++pos].last=head[a];\n    data[pos].now=b;\n    data[pos].canv=c;\n    data[pos].money=d;\n    head[a]=pos;\n}\nvoid change(int &a,int &b)\n{\n    int kk=a;a=b;b=kk;\n}\nint search()\n{\n    int p=0,q=0;\n    for(int i=1;i<=n;i++)\n    {\n        vivo[i].cost=mini;\n        vivo[i].fromd=0;\n        vivo[i].havev=0;\n        vivo[i].num=0;\n        used[i]=0;\n    }\n    vivo[ks].cost=0;//\u5199\u9519\u8fc7\n    vivo[ks].havev=mini;//\u5199\u9519\u8fc7\n    used[ks]=1;\n    qe[0]=ks;\n    for(;q<=p;q++)\n     {                                                //\u5199\u9519\u8fc7\n        for(int t=head[qe[q%n]];t;t=data[t].last)\n         if(data[t].canv&&vivo[data[t].now].cost>vivo[qe[q%n]].cost+data[t].money)\n           {\n                vivo[data[t].now].cost=vivo[qe[q%n]].cost+data[t].money;\n                vivo[data[t].now].fromd=t;\n                vivo[data[t].now].num=qe[q%n];\n                vivo[data[t].now].havev=min(vivo[qe[q%n]].havev,data[t].canv);//\u5199\u9519\u8fc7 \n                if(used[data[t].now]==0)\n                {\n                    used[data[t].now]=1;\n                    qe[++p%n]=data[t].now;\n                if(vivo[qe[p%n]].cost<vivo[qe[(q+1)%n]].cost) \n                change(qe[p%n],qe[(q+1)%n]);\n                }\n           }\n        used[qe[q%n]]=0;\n     }\n     if(vivo[js].cost!=mini) return 1;//\u5199\u9519\u8fc7*2\n     return 0;\n}\nvoid mimi()\n{\n    while(search())\n    {\n        ahavev+=vivo[js].havev;\n        amoney+=vivo[js].cost*vivo[js].havev;\n        int nn=js;\n        while(nn)\n        {\n            data[vivo[nn].fromd].canv-=vivo[js].havev;\n            data[vivo[nn].fromd^1].canv+=vivo[js].havev;\n            nn=vivo[nn].num;\n        }        \n    }\n    printf(\"%d\\n\",-amoney);\n}\nint main()\n{\n    freopen(\"f.in\",\"r\",stdin);\n    freopen(\"f.out\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&k);\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n        scanf(\"%d\",&lata[(i-1)*n+j]);\n    for(int i=1;i<=n*n;i++)\n    {\n        add(i*2-1,i*2,1,-lata[i]); \n        add(i*2,i*2-1,0,lata[i]);\n        add(i*2-1,i*2,k-1,0); \n        add(i*2,i*2-1,0,0);\n    }      \n    int zs=n*(n-1);\n    for(int i=1;i<n*n;i++)\n    {\n        if(i>zs) \n        {\n            add(i*2,i*2+1,k,0);\n            add(i*2+1,i*2,0,0); \n            continue;\n        }\n        if(i%n==0) \n        {\n            add(i*2,(i+n)*2-1,k,0);\n            add((i+n)*2-1,i*2,0,0);\n            continue;\n        }\n        add(i*2,i*2+1,k,0);\n        add(i*2+1,i*2,0,0); \n        add(i*2,(i+n)*2-1,k,0);\n        add((i+n)*2-1,i*2,0,0);\n    }\n    add(n*n-1,n*n,k,0);\n    add(n*n,n*n-1,0,0);\n    ks=1;\n    js=2*n*n;\n    n=js;\n    mimi();\n    return 0;\n}\n```",
        "postTime": 1509009968,
        "uid": 62762,
        "name": "\u829d\u9ebb\u7cca\u7cca",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "## \u7f51\u7edc\u7624\u5927\u6cd5\u597d\uff01\n\n\u6211\u4eec\u8003\u8651\u5c06\u6bcf\u4e00\u4e2a\u70b9\u62c6\u6210\u5165\u70b9\u548c\u51fa\u70b9\u4e24\u4e2a\u70b9\uff0c\u7136\u540e\u6309\u7167\u4ee5\u4e0b\u65b9\u5f0f\u5efa\u56fe\uff1a\n\n1. \u8fde\u4e00\u6761\u4ece\u8d85\u7ea7\u6e90\u70b9\u5230 $(1,1)$ \u7684\u5165\u70b9\uff0c\u6d41\u91cf\u4e3a $k$\uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\uff0c\u8868\u793a\u6700\u591a\u53ef\u4ee5\u8d70 $k$ \u6b21\n\n2. \u540c\u7406\uff0c\u8fde\u4e00\u6761\u4ece $(n,n)$ \u7684\u51fa\u70b9\u5230\u8d85\u7ea7\u6c47\u70b9\uff0c\u6d41\u91cf\u4e3a $k$\uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\u3002\n\n3. \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5728\u5165\u70b9\u548c\u51fa\u70b9\u4e4b\u95f4\u8fde\u4e24\u6761\u8fb9\uff0c\u4e00\u6761\u6d41\u91cf\u4e3a $1$\uff0c\u8d39\u7528\u4e3a $a_{i,j}$\uff0c\u8868\u793a\u53ea\u80fd\u53d6\u4e00\u6b21\uff0c\u53e6\u4e00\u6761\u6d41\u91cf\u4e3a $\\infty$ \uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\uff0c\u8868\u793a\u53d6\u5b8c\u4e4b\u540e\u5c31\u6ca1\u6709\u4e86\uff0c\n\n4. \u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5728\u8fd9\u4e2a\u70b9\u7684\u51fa\u70b9\u4e0e\u8fd9\u4e2a\u70b9\u53f3\u3001\u4e0b\u65b9\u7684\u70b9\u7684\u51fa\u70b9\u4e4b\u95f4\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $\\infty$\uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\u3002\n\n\u7136\u540e\u8dd1\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\u3002\n\n\u6ce8\u610f\u628a\u6240\u6709\u8fb9\u53d8\u4e3a\u8d1f\u6570\uff0c\u8f6c\u5316\u4e3a\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n```cpp\n/*\n\u6570\u636e\u4e0d\u6e05\u7a7a\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u591a\u6d4b\u4e0d\u8bfb\u5b8c\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u8fb9\u754c\u4e0d\u7279\u5224\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u8d2a\u5fc3\u4e0d\u8bc1\u660e\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\nD P \u987a\u5e8f\u9519\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u5927\u5c0f\u5c11\u7b49\u53f7\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u53d8\u91cf\u4e0d\u7edf\u4e00\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u8d8a\u754c\u4e0d\u5224\u65ad\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u8c03\u8bd5\u4e0d\u6ce8\u91ca\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n\u6ea2\u51fa\u4e0d l l\uff0c\u7206\u96f6\u4e24\u884c\u6cea\u3002\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi\t\t\tfirst\n#define se\t\t\tsecond\n#define fz(i,a,b)\tfor(int i=a;i<=b;i++)\n#define fd(i,a,b)\tfor(int i=a;i>=b;i--)\n#define put(x)\t\tputchar(x)\n#define eoln        put('\\n')\n#define space\t\tput(' ')\n//#define int long long\ninline int read(){\n\tint x=0,neg=1;char c=getchar();\n\twhile(!isdigit(c)){\n\t\tif(c=='-')\tneg=-1;\n\t\tc=getchar();\n\t}\n\twhile(isdigit(c))\tx=x*10+c-'0',c=getchar();\n\treturn x*neg;\n}\ninline void print(int x){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(abs(x));\n\t\treturn;\n\t}\n\tif(x<=9)\tputchar(x+'0');\n\telse{\n\t\tprint(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nint ecnt=1,head[100005];\nstruct edge{\n\tint to,nxt,cap,cost;\n} e[100005];\ninline void addedge(int u,int v,int f,int c){\n\te[++ecnt].to=v;e[ecnt].cap=f;e[ecnt].cost=c;e[ecnt].nxt=head[u];head[u]=ecnt;\n}\nbool vis[6010];\nint dist[6010],flow[6010],pre[6010],pos[6010];\ninline bool spfa(int s,int t){\n\tmemset(vis,1,sizeof(vis));\n\tmemset(dist,63,sizeof(dist));\n\tqueue<int> q;\n\tvis[s]=0;\n\tdist[s]=0;\n\tflow[s]=0x3f3f3f3f;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();\n//\t\tcout<<x<<endl;\n\t\tvis[x]=true;\n\t\tfor(int i=head[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n//\t\t\tcout<<y<<endl;\n\t\t\tif(e[i].cap>0&&dist[y]>dist[x]+e[i].cost){\n\t\t\t\tdist[y]=dist[x]+e[i].cost;pos[y]=x;pre[y]=i;\n\t\t\t\tflow[y]=min(flow[x],e[i].cap);\n//\t\t\t\tcout<<flow[y]<<endl;\n\t\t\t\tif(vis[y]){\n\t\t\t\t\tq.push(y);\n\t\t\t\t\tvis[y]=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t}\n//\tcout<<flow[t]<<endl;\n\treturn dist[t]<0x3f3f3f3f;\n}\ninline int Dinic(int s,int t){\n\tint sum=0;\n\twhile(spfa(s,t)){\n\t\tsum+=flow[t]*dist[t];\n\t\tfor(int i=t;i!=s;i=pos[i]){\n\t\t\te[pre[i]].cap-=flow[t];\n\t\t\te[pre[i]^1].cap+=flow[t];\n\t\t}\n\t}\n\treturn sum;\n}\nint n=read(),k=read();\ninline int id(int x,int y,int c){\n\treturn (n*(x-1)+y)*2-(c%2);\n}\nconst int dx[]={1,0};\nconst int dy[]={0,1};\nsigned main(){\n\tfz(i,1,n){\n\t\tfz(j,1,n){\n\t\t\tint v=read();\n\t\t\taddedge(id(i,j,1),id(i,j,2),1,-v);\n\t\t\taddedge(id(i,j,2),id(i,j,1),0,v);\n\t\t\taddedge(id(i,j,1),id(i,j,2),0x3f3f3f3f,0);\n\t\t\taddedge(id(i,j,2),id(i,j,1),0,0);\n\t\t\tfor(int l=0;l<2;l++){\n\t\t\t\tint x=i+dx[l],y=j+dy[l];\n\t\t\t\tif(x<1||x>n||y<1||y>n)\tcontinue;\n\t\t\t\taddedge(id(i,j,2),id(x,y,1),0x3f3f3f3f,0);\n\t\t\t\taddedge(id(x,y,1),id(i,j,2),0,0);\n\t\t\t}\n\t\t}\n\t}\n\taddedge(0,id(1,1,1),k,0);\n\taddedge(id(1,1,1),0,0,0);\n\taddedge(id(n,n,2),2*n*n+1,k,0);\n\taddedge(2*n*n+1,id(n,n,2),0,0);\n\tcout<<-Dinic(0,2*n*n+1)<<endl;\n\treturn 0;\n}\n```\n\n~~\u6700\u540e\uff0c\u795d\u5927\u5bb6\u65b0\u5e74\u5feb\u4e50\uff01~~",
        "postTime": 1579938271,
        "uid": 115194,
        "name": "lTgMFePRoeZ",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "# \u5514\u59c6\n\u611f\u89c9\u8fd9\u9898\u662f\u9053\u6bd4\u8f83\u597d\u7684\u8d39\u7528\u6d41\uff0c\u6240\u4ee5\u6765\u5199\u7bc7\u9898\u89e3qwq\n\n------------\n\n\u65e2\u7136\u8fd9\u662f\u52a0\u5f3a\u7248\uff0c\u90a3\u5148\u770b\u4e00\u4e0b\u539f\u7248[P1004 \u65b9\u683c\u53d6\u6570](https://www.luogu.org/problemnew/show/P1004)\n\n\u5f88\u660e\u663e\u539f\u7248\u4e00\u770b\u5c31\u662fdp\uff0c\u90a3\u6211\u4eec\u8fd9\u9898\u53ef\u4e0d\u53ef\u4ee5\u7528dp\u5462\uff1f\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u3002\u663e\u7136\u4e0d\u884c\u3002~~\u5927\u5bb6\u80af\u5b9a\u90fd\u662f\u770b\u4e86\u6807\u7b7e\u624d\u6765\u505a\u7684\u554a~~\n\n\u90a3\u6211\u4eec\u63a5\u7740\u770b\uff0c\u65e2\u7136\u8981\u53d6k\u6b21\uff0c\u5e76\u4e14\u6bcf\u4e2a\u6570\u53ea\u80fd\u53d6\u4e00\u6b21\uff0c\u6c42\u6700\u5927\u53d6\u503c\uff0c\u53c8\u9650\u5236\u6d41\u91cf\uff0c\u8fd8\u8981\u6c42\u4ef7\u503c\uff0c\u8fd9\u4e00\u773c\u5c31\u770b\u51fa\u6765\u662f\u4e2a\u8d39\u7528\u6d41\u3002\u786e\u5b9a\u4e86\u65b9\u6cd5\uff0c\u6211\u4eec\u6765\u60f3\u60f3\u600e\u4e48\u5efa\u56fe\u3002\n- \u9996\u5148\uff0c\u4e3a\u4e86\u9650\u5236\u6bcf\u4e2a\u6570\u5b57\u53ea\u80fd\u53d6\u4e00\u6b21\uff0c\u6211\u4eec\u628a\u6bcf\u4e2a\u683c\u5b50\u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u5728\u4ed6\u4eec\u4e4b\u95f4\u8fde\u4e0a\u4e00\u6761\u8d39\u7528\u4e3aA[i][j]\u6d41\u91cf\u4e3a1\u7684\u8fb9\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u6570\u53ea\u80fd\u53d6\u4e00\u6b21\n\n- \u63a5\u7740\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u4e00\u4e2a\u683c\u5b50\u7684\u6570\u88ab\u53d6\u8d70\u4e86\uff0c\u5e76\u4e0d\u4ee3\u8868\u8fd9\u4e2a\u683c\u5b50\u4e0d\u80fd\u8d70\u4e86\uff0c\u53ea\u662f\u4e0d\u80fd\u83b7\u5f97\u4ef7\u503c\u4e86\uff0c\u4e8e\u662f\u6211\u4eec\u5728\u88ab\u62c6\u5f00\u7684\u4e24\u70b9\u95f4\u518d\u8fde\u4e00\u6761\u8d39\u7528\u4e3a0\u6d41\u91cf\u4e3a**k-1**\u7684\u8fb9\uff0c\u7528\u4e8e\u9650\u5236\u8d70k\u6b21\n\n- \u7136\u540e\uff0c\u6211\u4eec\u53ea\u8981\u628a\u683c\u5b50\u548c\u683c\u5b50\u4e4b\u95f4\u51fa\u70b9\u548c\u5165\u70b9\u8fde\u8fb9\uff0c\u8d39\u7528\u4e3a0\u6d41\u91cf\u4e3ak\n\n\u6700\u540e\u76f4\u63a5\u8dd1\u4e2a\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5c31\u597d\u4e86QAQ\n\n~~\u7801\u98ce\u5de8\u6bd2\uff0c\u8bf7\u89c1\u8c05~~\n```cpp\n#include<queue>\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#define MAXM 100010\n#define MAXN 3000\nusing namespace std;\nint to[MAXM],next[MAXM],w[MAXM],cost[MAXM],head[MAXN*2];\nint n,k,S,T,ansl=0,ansc=0;\nint cnt=-1;\nint pre1[MAXN*2],pre2[MAXN*2],low[MAXN*2],dis[MAXN*2];\nvoid link(int a,int b,int c,int d){\n     cnt++;\n     next[cnt]=head[a];\n     w[cnt]=c;\n     cost[cnt]=d;\n     to[cnt]=b;\n     head[a]=cnt;\n     cnt++;\n     next[cnt]=head[b];\n     w[cnt]=0;\n     cost[cnt]=-d;\n     to[cnt]=a;\n     head[b]=cnt;\n}\nbool spfa(){\n     queue<int>q;\n     fill(dis,dis+MAXN*2-1,-1);\n     int vis[MAXN*2];\n     memset(vis,0,sizeof(vis));\n     q.push(S);\n     dis[S]=0;\n     vis[S]=1;\n     low[S]=66666666;\n     while(!q.empty()){\n                       int now=q.front();\n                       vis[now]=0;\n                       q.pop();\n                       for(int i=head[now];i!=-1;i=next[i]){\n                               if (w[i]>0&&cost[i]+dis[now]>dis[to[i]]){\n                                                                        dis[to[i]]=dis[now]+cost[i];\n                                                                        low[to[i]]=min(low[now],w[i]);\n                                                                        pre1[to[i]]=now;\n                                                                        pre2[to[i]]=i;\n                                                                        if (!vis[to[i]]){\n                                                                                         vis[to[i]]=1;\n                                                                                         q.push(to[i]);\n                                                                        }\n                               }\n                       }\n     }\n     return dis[T]!=-1;\n}\nvoid work(){\n     while(spfa()){\n                   int now=T;\n                   while(now!=S){\n                                 int y=pre2[now];\n                                 w[y]-=low[T];\n                                 w[y^1]+=low[T];\n                                 now=pre1[now];\n                   }\n                   ansl+=low[T];\n                   ansc+=low[T]*dis[T];\n     }\n}\nint num(int a,int b){\n    return (a-1)*n+b;\n}\nint tu[60][60];\nint main(){\n    memset(head,-1,sizeof(head));\n    cin>>n>>k;\n    S=num(1,1);T=num(n,n)+MAXN;\n    for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                    scanf(\"%d\",&tu[i][j]);\n            }\n    }\n    for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                    link(num(i,j),num(i,j)+MAXN,1,tu[i][j]);link(num(i,j),num(i,j)+MAXN,k-1,0);\n                    if (i+1<=n) link(num(i,j)+MAXN,num(i+1,j),k,0);\n                    if (j+1<=n) link(num(i,j)+MAXN,num(i,j+1),k,0);\n            }\n    }               \n    work();\n    cout<<ansc<<endl;\n    return 0;\n}\n\n```",
        "postTime": 1548930489,
        "uid": 118273,
        "name": "\u543e\u738b\u7f8e\u5982\u753b",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "\u628a\u4e00\u4e2a\u70b9\u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u4e00\u4e2a\u5165\u70b9\uff0c\u4e00\u4e2a\u51fa\u70b9\u3002\n\n\u5165\u70b9\u5230\u51fa\u70b9\u6709\u4e24\u6761\u8fb9\uff1a1.\u6d41\u91cf\u4e3a1\u8d39\u7528\u4e3a\u5f53\u524d\u683c\u7684\u8d1f\u6570\uff0c2.\u6d41\u91cf\u4e3a\u65e0\u7a77\u5927\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u53ef\u4ee5\u4fdd\u8bc1\u4e00\u4e2a\u6570\u53ea\u4f1a\u53d6\u4e00\u6b21\u3002\u7531\u4e8e\u683c\u5b50\u6570\u90fd\u662f\u6b63\u6570\uff0c\u6240\u4ee5\u4e0d\u4f1a\u53d1\u751f\u4f18\u5148\u8d700\u8d39\u7684\u8fb9\u7684\u60c5\u51b5\n\n\u4e0e\u6b64\u540c\u65f6\u628a(a,b)\u7684\u51fa\u70b9\u4e0e(a+1,b)\u4e0e(a,b+1)\u7684\u5165\u70b9\u8fde\u4e00\u6761\u65e0\u9650\u6d41\u91cf\u65e0\u8d39\u7528\u7684\u8fb9\u8868\u793a\u79fb\u52a8\n\n\u8d85\u7ea7\u6e90\u94fe\u63a5(1,1)\u7684\u5165\u70b9\uff0c\u6d41\u91cfK\u8d39\u75280\n\n(N,N)\u51fa\u70b9\u94fe\u63a5\u8d85\u7ea7\u6c47\uff0c\u6d41\u91cfK\u8d39\u75280\n\n\u8fd9\u6837\u5c31\u5b8c\u5168\u8f6c\u5316\u6210\u8d39\u7528\u6d41\u6a21\u677f\u4e86\n\n\u4e0d\u8fc7\u8fd9\u7b97\u6cd5\u5bf9\u8d1f\u6743\u683c\u5b50\u6ca1\u7528\uff0c\u7262\u8bb0\u7262\u8bb0\n\n\n\n\n\n\n\n\n\n```cpp\n#include <stdio.h>\n#include <string.h>\n#include <queue>\n#define MXE 600000\n#define INP(x,y) ((x)*50+(y))\n#define OUP(x,y) ((x)*50+(y)+3000)\n#define MXP 7000\n#define SP 0\n#define TP 6500\n#define INF 0x3FFFFFFF\n#define min(a,b) (a>b?b:a)\n#define max(a,b) (a>b?a:b)\nint N,K;\nint Rect[60][60];\ntypedef struct Edge\n{\n    int Fr,To;\n    int MF,NF;\n    int Cost;\n    Edge*Back;\n}EG,*LPEG;\nint EHead[MXP],ENext[MXE];\nEG EDat[MXE];\nint Elt;\nLPEG AddEdge(int Fr,int To,int MF,int C)\n{\n    ++Elt;\n    ENext[Elt]=EHead[Fr];\n    EDat[Elt].Fr=Fr;\n    EDat[Elt].To=To;\n    EDat[Elt].MF=MF;\n    EDat[Elt].NF=0;\n    EDat[Elt].Cost=C;\n    EHead[Fr]=Elt;\n    return EDat+Elt;\n}\nvoid AddPair(int Fr,int To,int MF,int Cs)\n{\n    LPEG G,B;\n    G=AddEdge(Fr,To,MF,Cs);\n    B=AddEdge(To,Fr,0,-Cs);\n    G->Back=B;\n    B->Back=G;\n}\n```\nclass MCMF\n```cpp\n{\n    int Vist[MXP];\n    int SVist[MXP];\n    int Dist[MXP];\n    std::queue<int> Qe;\n    LPEG Back[MXP];\n    void SPFA();\n    int Flow();\n```\npublic:\n\n\n\n\n\n\n```cpp\n    int MinCost();\n};\nvoid MCMF::SPFA()\n{\n    int wp,we;\n    LPEG bf;\n    memset(Vist,0,sizeof(Vist));\n    memset(SVist,0,sizeof(SVist));\n    Qe.push(SP);\n    Vist[SP]=1;\n    Dist[SP]=0;\n    SVist[SP]=1;\n    while(!Qe.empty())\n    {\n        wp=Qe.front();Qe.pop();\n        SVist[wp]=0;\n        for(we=EHead[wp];we;we=ENext[we])\n        {\n            bf=EDat+we;\n            if(bf->MF==bf->NF)continue;\n            if(Vist[bf->To]&&Dist[wp]+bf->Cost>=Dist[bf->To])\n                continue;\n            Dist[bf->To]=Dist[wp]+bf->Cost;\n            Back[bf->To]=bf;\n            Vist[bf->To]=1;\n            if(!SVist[bf->To])\n                Qe.push(bf->To);\n            SVist[bf->To]=1;\n        }\n    }\n}\nint MCMF::Flow()\n{\n    int wp,ret=0;\n    int wl=INF;\n    LPEG wf;\n    wp=TP;\n    while(wp-SP)\n    {\n        wf=Back[wp];\n        wp=wf->Fr;\n        wl=min(wl,wf->MF-wf->NF);\n    }\n    wp=TP;\n    while(wp-SP)\n    {\n        wf=Back[wp];\n        ret+=wf->Cost*wl;\n        wf->NF+=wl;\n        wf->Back->NF-=wl;\n        wp=wf->Fr;\n    }\n    return ret;\n}\nint MCMF::MinCost()\n{\n    int ret=0;\n    SPFA();\n    while(Vist[TP])\n    {\n        ret+=Flow();\n        SPFA();\n    }\n    return ret;\n}\nvoid Input()\n{\n    scanf(\"%d %d\",&N,&K);\n    int wia,wib;\n    for(wia=1;wia<=N;++wia)\n        for(wib=1;wib<=N;++wib)\n        {\n            scanf(\"%d\",Rect[wia]+wib);\n            AddPair(INP(wia,wib),OUP(wia,wib),1,-Rect[wia][wib]);\n            AddPair(INP(wia,wib),OUP(wia,wib),INF,0);\n        }\n    for(wia=1;wia<=N;++wia)\n        for(wib=1;wib<=N;++wib)\n        {\n            if(wia<N)\n                AddPair(OUP(wia,wib),INP(wia+1,wib),INF,0);\n            if(wib<N)\n                AddPair(OUP(wia,wib),INP(wia,wib+1),INF,0);\n        }\n    AddPair(SP,INP(1,1),K,0);\n    AddPair(OUP(N,N),TP,K,0);\n}\nMCMF Mc;\nvoid AC()\n{\n    int Res=Mc.MinCost();\n    printf(\"%d\\n\",-Res);\n}\nint main()\n{\n    Input();\n    AC();\n    return 0;\n}\n```",
        "postTime": 1492954876,
        "uid": 25508,
        "name": "Night_Aurora",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "###  \u9996\u5148\uff0c\u8fd9\u9053\u9898\u4e0d\u80fd\u7528DP\uff0c\u4f1a\u88ab\u5361\u6389\uff01\uff01\uff01\n#### \u5176\u6b21\uff0c\u8fd9\u9053\u9898\u662f\u7f51\u7edc\u6d41\u4e2d\u7684\u8d39\u7528\u6d41\n## \u7f51\u7edc\u6d41\uff0c~~Are you kidding me???~~\n##### \u65e2\u7136\u662f\u7f51\u7edc\u6d41\uff0c\u90a3\u4e48\u6211\u4eec\u9700\u8981\u77e5\u9053\u5982\u4f55\n# \u5efa\u8fb9\n##### \u6211\u4eec\u73b0\u5728\u77e5\u9053\u6743\u503c\u5728\u70b9\u4e0a\uff0c\u4f46\u8d39\u7528\u5728\u8fb9\u4e0a\n##### \u6211\u4eec\u9700\u8981\u628a\u4e00\u4e2a\u70b9\u62c6\u6210\u4e24\u4e2a\u70b9A,B\u5c31\u884c\u4e86\uff0c\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\uff0cA->B\u7684\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a\u8fd9\u4e2a\u70b9\u7684\u6743\u503c\uff0cB->A\u7684\u5bb9\u91cf\u4e3a0\uff0c\u8d39\u7528\u4e3a\u8fd9\u4e2a\u70b9\u7684\u6743\u503c\u7684\u76f8\u53cd\u6570\n## \u8bdd\u4e0d\u591a\u8bf4\uff0c\u4e0a\u4ee3\u7801\n    \n```cpp\n  #include<bits/stdc++.h>\n  using namespace std;\n  #define inf 0x3f3f3f3f\n  #define maxm 500005\n  #define maxn 6010\n  int T,m,n,v[maxm],r[maxm],cost[maxm],nex[maxm],head[maxn];\n  int dist[maxn],inc[maxn],pr[maxn],vis[maxn];\n  int tot,s,t,ans1,ans2,K;\n\n  void add(int x,int y,int z,int c){\n      v[++tot]=y,r[tot]=z,cost[tot]=c;\n      nex[tot]=head[x],head[x]=tot;//\u90bb\u63a5\u8868\u5b58\u6b63\u56fe\n      v[++tot]=x,r[tot]=0,cost[tot]=-c;\n      nex[tot]=head[y],head[y]=tot;//\u90bb\u63a5\u8868\u5b58\u53cd\u56fe\n  }\n  int num(int a,int b,int c){\n      int ans=(a-1)*n+b+c*n*n;\n      return ans;\n  }\n  int spfa(){\n      s=1,t=2*n*n;\n      queue<int> q;\n      q.push(s);\n      memset(dist,-1,sizeof(dist));\n      memset(vis,0,sizeof(vis));\n      vis[s]=1,dist[s]=0,inc[s]=inf;\n      while(!q.empty()){\n          int cur=q.front();\n          vis[cur]=0;\n          q.pop();\n          for(int i=head[cur];i;i=nex[i]){\n              if(!r[i]) continue;\n              int ne=v[i];\n              if(dist[ne]<dist[cur]+cost[i]){\n                  dist[ne]=dist[cur]+cost[i];\n                  inc[ne]=min(inc[cur],r[i]);\n                  pr[ne]=i;\n                  if(!vis[ne]) vis[ne]=1,q.push(ne);\n                  }\n              }\n          }\n      if(dist[t]==-1) return false;\n      return true;\n  }\n  void update(){\n      int tmp=t;\n      while(tmp!=s){\n          int tm=pr[tmp];\n          r[tm]-=inc[t];\n          r[tm^1]+=inc[t];\n          tmp=v[tm^1];\n      }\n      ans1+=inc[t];\n      ans2+=dist[t]*inc[t];\n  }\n  int main(){\n    ans1=ans2=0;\n    memset(v,0,sizeof(v));\n    memset(r,0,sizeof(r));\n    memset(cost,0,sizeof(cost));\n    memset(nex,0,sizeof(nex));\n    memset(head,0,sizeof(head));\n    memset(inc,0,sizeof(inc));\n    memset(pr,0,sizeof(pr));\n    scanf(\"%d%d\",&n,&K);\n    tot=1;\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++){\n        int c;\n        scanf(\"%d\",&c);\n        add(num(i,j,0),num(i,j,1),1,c);\n        add(num(i,j,0),num(i,j,1),K-1,0);\n        if(j!=n) add(num(i,j,1),num(i,j+1,0),K,0);\n        if(i!=n) add(num(i,j,1),num(i+1,j,0),K,0);\n    }\n    while(spfa()) update();\n    printf(\"%d\\n\",ans2);\n  }\n```",
        "postTime": 1563345040,
        "uid": 103336,
        "name": "zxxzdq",
        "ccfLevel": 5,
        "title": "P2045 \u9898\u89e3"
    },
    {
        "content": "[\u5b89\u5229\u4e00\u4e0b\u6211\u7684\u535a\u5ba2](https://www.luogu.org/blog/MaxDYF/)\n\n[\u8fd8\u6709\u6211\u7684\u77e5\u4e4e](https://www.zhihu.com/people/maxdyf)\n\n### \u4e00\u9053\u633a\u597d\u7684\u8d39\u7528\u6d41\u6a21\u677f\u3002\n\u5f53\u770b\u5230\u53ea\u80fd\u8d70K\u6b21\u65f6\uff0c\u6839\u636e\u76f4\u89c9~~\u76f2\u76ee\u731c\u6d4b~~\uff0c\u521d\u6b65\u5224\u65ad\u53ef\u4ee5\u8f6c\u6362\u4e3a**\u7f51\u7edc\u6d41\u7684\u8fb9\u6d41\u91cf\u9650\u5236**\uff0c\u5373\u9650\u5236\u6c47\u5165\u6c47\u70b9\u7684\u603b\u6d41\u91cf\u3002\n\n\u7136\u800c\u8fd9\u9898\u8fd8\u6709\u4e00\u4e2a\u201c\u65b9\u683c\u4e2d\u7684\u6570\u5b57\u201d\uff0c\u8981\u6c42\u6c42\u6700\u5927\uff0c\u4e8e\u662f\uff0c\u5c31\u6709\u4e86\u8d39\u7528\u6d41\u7684\u8d39\u7528\u9650\u5236\u3002\n\n\u4f46\u662f\uff0c\u8d39\u7528\u6d41\u7684\u5168\u79f0\u4e3a\u201c**\u6700\u5c0f\u8d39\u7528**\u6700\u5927\u6d41\u201d\uff0c\u4f46\u662f\u8fd9\u9898\u8981\u6c42\u6c42**\u6700\u5927\u201c\u8d39\u7528\u201d**\uff08\u5373\u6570\u5b57\u4e4b\u548c\uff09\uff0c\u6240\u4ee5\u8fd9\u9898\u5176\u5b9e\u662f\u201c\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u201d\uff1f\uff1f\uff1f\n\n\u601d\u8003\u5230\u8fd9\u91cc\uff0c\u6765\u60f3\u60f3\u600e\u4e48\u5efa\u56fe\u3002\n\n### First\n\u9996\u5148\uff0c\u65b9\u683c\u4e2d\u7684\u6570\u5b57\uff0c\u6211\u4eec\u53ea\u80fd\u591f**\u53d6\u4e00\u6b21**\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5bf9\u6bcf\u4e2a\u70b9$x$\u8fdb\u884c**\u62c6\u70b9**\uff0c\u62c6\u5206\u4e3a\u201c\u5165\u70b9\u201d\u4e0e\u201c\u51fa\u70b9\u201d\uff0c\u5206\u522b\u8bb0\u4e3a$x'$\u548c$x''$\uff0c\u7136\u540e\u8fde\u4e00\u6761\u8fb9\uff0c\u5373$x'\\xrightarrow{flow=1,cost=a_{i,j}} x''$\uff0c\u5176\u4e2d$a_{i,j}$\u8868\u793a\u6bcf\u4e2a\u70b9\u7684\u6570\u5b57\uff0c\u9650\u5236\u7ecf\u8fc7\u6bcf\u4e2a\u70b9\u83b7\u53d6\u7684\u6570\u5b57\u3002\n\n\u4f46\u662f\uff0c\u6bcf\u4e2a\u70b9\u88ab\u53d6\u8d70\u6570\u5b57\u540e\uff0c\u5e76\u4e0d\u662f\u4e0d\u80fd\u518d\u8d70\u4e86\uff0c\u800c\u53ea\u662f\u6570\u5b57\u53d8\u4e3a$0$\uff0c\u4e8e\u662f\u6211\u4eec\u518d\u5728$x\u2019$\u4e0e$x''$\u4e4b\u95f4\u5efa\u4e00\u6761\u8fb9$x'\\xrightarrow{flow=inf,cost=0}x''$\u3002\n\n### Second\n\u7136\u540e\u5462\uff0c\u6bcf\u4e2a\u70b9\u53ef\u4ee5\u8d70\u5230\u4e0b\u65b9\u7684\u70b9\u6216\u53f3\u65b9\u7684\u70b9\uff0c\u4e8e\u662f\u6211\u4eec\u5c06\u5176\u8fde\u63a5\uff1a\n\n\u8bbe$x_{i,j}$\u3001$x_{i,j+1}$\u4e0e$x_{i+1,j}$\n\n$x_{i,j}''\\xrightarrow{flow=inf,cost=0}x_{i,j+1}'$\u3002\n\n$x_{i,j}''\\xrightarrow{flow=inf,cost=0}x_{i+1,j}'$\u3002\n\n\u5373\u8868\u793a\u53ef\u4ee5\u8d70\u65e0\u6570\u6b21\uff0c\u4f46\u4e0d\u589e\u52a0\u5176$cost$\u3002\n\n### Third\n\n\u6b64\u65f6\u6211\u4eec\u8fd8\u6ca1\u6709\u8fde\u63a5\u6e90\u70b9\u4e0e\u6c47\u70b9\uff0c\u867d\u7136\u8fde\u63a5\u54ea\u91cc\u662f\u663e\u800c\u6613\u89c1\u7684\u4e86\u2026\u2026\n\n\u6211\u4eec\u8bbe\u6e90\u70b9\u4e3a$S$\uff0c\u6c47\u70b9\u4e3a$T$\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u80fd\u8d70$K$\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u628a\u6e90\u70b9\u6d41\u51fa\u7684\u6d41\u91cf\u4e0e\u6d41\u5165\u6c47\u70b9\u7684\u6d41\u91cf\u90fd\u8bbe\u7f6e\u4e3a$K$\uff0c$cost$\u8bbe\u4e3a$0$\uff0c\u5373\uff1a\n\n$S\\xrightarrow{cost=0,flow=K}x'_{1,1}$,\n$x'_{n,n}\\xrightarrow{cost=0,flow=K}T$\n\n\u4e8e\u662f\uff0c\u5efa\u8fb9\u90e8\u5206\u5c31\u5b8c\u6210\u4e86\uff01\n\n### Summary\n\n\u603b\u7684\u6765\u8bf4\u5efa\u8fb9\u7684\u8fc7\u7a0b\u8fd8\u662f\u5f88\u597d\u60f3\u7684\uff0c\u4e0b\u9762\u6765\u603b\u7ed3\u4e00\u4e0b\u3002\n\n1. $\\sum {x'_{i,j}},{x''_{i,j}},$\n\n\t$x'\\xrightarrow{flow=1,cost=a_{i,j}} x''$\n\n1. $\\sum {x_{i,j}},$\n\n\t$x_{i,j}''\\xrightarrow{flow=inf,cost=0}x_{i,j+1}'$,\n    \n\t$x_{i,j}''\\xrightarrow{flow=inf,cost=0}x_{i+1,j}'$\u3002\n\n1. \n\t$S\\xrightarrow{cost=0,flow=K}x'_{1,1}$,\n    \n\t$x'_{n,n}\\xrightarrow{cost=0,flow=K}T$\n\n\n\n### About Network Flow\n\u524d\u9762\u8bf4\u4e86\uff0c\u8fd9\u9898\u7684\u5b9e\u8d28\u662f\u201c\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u201d\uff0c\u6240\u4ee5\u76f4\u63a5\u7167\u7740\u677f\u5b50\u6253\u8d39\u7528\u6d41\u662f\u4e0d\u884c\u7684\u3002\u8fd9\u91cc\u63d0\u4f9b\u4e24\u79cd\u89e3\u51b3\u65b9\u6cd5\uff1a\n\n1\u3001\u8d4b\u503c\u8d39\u7528\u65f6\u8d4b\u503c\u4e3a\u76f8\u53cd\u6570\uff0c\u7136\u540e\u539f\u6765**\u6700\u5927\u7684**\u5c31\u53d8\u6210**\u6700\u5c0f\u7684**\u2026\u2026\u7136\u540e\u53d6$minflow$\u7684\u76f8\u53cd\u6570\u8f93\u51fa\u3002\n\n2\u3001\u5728SPFA\u90e8\u5206\u7684\u5224\u65ad\u6761\u4ef6\u90e8\u5206\u7684$cost[y]>cost[x]+edge[i].cost$\u6539\u4e3a$cost[y]<cost[x]+edge[i].cost$\uff0c\u7136\u540e$mincost$\u5c31\u53d8\u6210\u4e86$maxcost$\u8fa3\u3002\n\n\u5148\u8d34\u6211\u7684$EK$\u4ee3\u7801\u3002\n\n### CODE\uff1a\n```cpp\n//Luogu P2045\n//Solution: EK Network Flow, Minimum Cost Maximum Flow \n//Written by MaxDYF\n#include <bits/stdc++.h>\nusing namespace std;\nconst int NODE = 1000000;\nconst int EDGE = 1000000;\nconst int inf = 1e9;\n//Index of Edge\nstruct Edge{\n\tint to, nxt, flow, cost;\n}edge[EDGE << 1];\nint head[NODE], cnt = 1;\n\n//Indexs of EK Network Flow\nint flow[NODE];\nint cost[NODE];\nint pre[NODE]; //record the last NODE of the present NODE in the road.\nint last[NODE];//record the last EDGE of the present NODE.\n\n//The Start and End\nint S, T;\n\n//The Indexs to record result\nint maxflow, mincost;\n\n//Something for SPFA\nbool vis[NODE];\nqueue<int> que;\n\n//The functions\nvoid add(int, int, int, int);\nbool spfa();\nvoid work();\n\n//All the things above here are about the Network Flow.\n//And the things under here are about the Problem.\nint a[60][60];//record the map\n\n//They are for Spliting NODEs\nint start[60][60];\nint end[60][60];\n\n//main function\nint main()\n{\n\tint n, k, cnt = 1;\n\tcin >> n >> k;\n\t//set the Start and the End\n\tS = 0;\n\tT = 2 * n * n + 1;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\tcin >> a[i][j];\n\t\t\ta[i][j] = -a[i][j];\n\t\t\t//One of the MOST IMPORTANT things: split each NODE into 2 NODEs\n\t\t\tstart[i][j] = ++cnt;\n\t\t\tend[i][j] = ++cnt;\n\t\t}\n\t}\n\t//Tips:\n\t//In this problem, the \"cost\" is refer to the Price of the Node.\n\t//So we have to get the \"Max 'Cost'\" instead of \"Min 'Cost'\".\n\t//To achieve our goal, we can turn the \"cost\"\n\t//to its opposite number.\n\t//And get the opposite number of the answer.\n\t//:) \n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t{\n\t\t\t//Add edge for these two NODEs\n\t\t\tadd(start[i][j], end[i][j], 1, a[i][j]);\n\t\t\t//set the Flow of the Edge between them to 1\n\t\t\t//to make sure that the Number can only be taken once.\n\t\t\tadd(start[i][j], end[i][j], inf, 0);\n\t\t\t//to make sure that this Node can be walked many times.\n\t\t\tif(i < n)\n\t\t\t\tadd(end[i][j], start[i+1][j], inf, 0);\n\t\t\tif(j < n)\n\t\t\t\tadd(end[i][j], start[i][j+1], inf, 0);\n\t\t\t//just means they are connected, \n\t\t\t//and can't get any \"cost\"(or price) any more.\n\t\t}\n\t}\n\tadd(S, start[1][1], k, 0);\n\tadd(end[n][n], T, k, 0);\n\t//make sure there are only \"k\" roads being collected.\n\twork();\n\tcout << -mincost;\n}\n\n//functions\nbool spfa()\n{\n\t//init\n\tmemset(vis, 0, sizeof vis);\n\tmemset(flow, 0x3f, sizeof flow);\n\tmemset(cost, 0x3f, sizeof cost);\n\tcost[S] = 0;\n\tpre[T] = -1;\n\tque.push(S);\n\tvis[S] = 1;\n\t//main work of SPFA\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front();\n\t\tque.pop();\n\t\tvis[x] = 0;\n\t\tfor (int i = head[x]; i; i = edge[i].nxt)\n\t\t{\n\t\t\tint y = edge[i].to;\n\t\t\t//if the present node is not the CHEAPEST\n\t\t\tif((cost[y] > cost[x] + edge[i].cost) && (edge[i].flow > 0))\n\t\t\t{\n\t\t\t\t//update the node\n\t\t\t\t//and its \"pre\" and \"last\"\n\t\t\t\tcost[y] = cost[x] + edge[i].cost;\n\t\t\t\tflow[y] = min(flow[x], edge[i].flow);\n\t\t\t\tpre[y] = x;\n\t\t\t\tlast[y] = i;\n\t\t\t\tif(!vis[y])\n\t\t\t\t{\n\t\t\t\t\tvis[y] = 1;\n\t\t\t\t\tque.push(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[T] != -1; \n}\nvoid add(int x, int y, int flow, int cost)\n{\n\tedge[++cnt] = Edge{y, head[x], flow, cost};\n\thead[x] = cnt;\n\tedge[++cnt] = Edge{x, head[y], 0, -cost};\n\thead[y] = cnt;\n}\nvoid work()\n{\n\t//EK Network Flow Algorithm\n\t//Nothing worth saying.\n\t//Isn't it?\n\t//If you can't understand it,\n\t//you'd better learn The EK Algorithm first.\n\twhile(spfa())\n\t{\n\t\tmaxflow += flow[T];\n\t\tmincost += flow[T] * cost[T];\n\t\tint now = T;\n\t\twhile(now != S)\n\t\t{\n\t\t\tedge[last[now]].flow -= flow[T];\n\t\t\tedge[last[now] ^ 1].flow += flow[T];\n\t\t\tnow = pre[now];\n\t\t}\n\t}\n}\n```\n",
        "postTime": 1555077073,
        "uid": 84832,
        "name": "MaxDYF",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "### Description\n\n\u7ed9\u51fa\u4e00\u4e2a $n*n$ \u7684\u77e9\u9635,\u6bcf\u4e00\u683c\u6709\u4e00\u4e2a\u975e\u8d1f\u6574\u6570 $A_{i,j}$ ,($A_{i,j} <= 1000$)\u73b0\u5728\u4ece $(1,1)$ \u51fa\u53d1,\u53ef\u4ee5\u5f80\u53f3\u6216\u8005\u5f80\u4e0b\u8d70,\u6700\u540e\u5230\u8fbe $(n,n)$ ,\u6bcf\u8fbe\u5230\u4e00\u683c,\u628a\u8be5\u683c\u5b50\u7684\u6570\u53d6\u51fa\u6765,\u8be5\u683c\u5b50\u7684\u6570\u5c31\u53d8\u6210 $0$ ,\u8fd9\u6837\u4e00\u5171\u8d70 $K$ \u6b21,\u73b0\u5728\u8981\u6c42 $K$ \u6b21\u6240\u8fbe\u5230\u7684\u65b9\u683c\u7684\u6570\u7684\u548c\u6700\u5927\n\n### Solution\n\n\u4e00\u6761\u8fb9 $(a,b)$ \u8868\u793a\u5bb9\u91cf\u4e3a $a$ \uff0c\u8d39\u7528\u4e3a $b$ \u3002\n\n\u628a\u6bcf\u4e2a\u70b9\u62c6\u6210\u4e24\u4e2a\u70b9\uff0c\u5165\u70b9\u548c\u51fa\u70b9\u3002\u5165\u70b9\u7528\u6765\u63a5\u53d7\u8fb9\uff0c\u51fa\u70b9\u7528\u6765\u53d1\u51fa\u8fb9\n\n\u6e90\u70b9\u5411 $(1,1)$ \u8fde\u4e00\u6761\u8fb9 $(k,0)$ \uff0c$(n,n)$ \u5411\u6c47\u70b9\u8fde\u4e00\u6761 $(k,0)$ \uff0c\u8868\u793a\u53ef\u4ee5\u8d70 $k$ \u6b21\n\n\u6bcf\u4e2a\u70b9\u5f80\u4ed6\u7684\u53f3\u548c\u4e0b\u5206\u522b\u8fde\u4e00\u6761 $(\\infty, 0)$ \u8868\u793a\u8054\u901a\u5173\u7cfb\n\n\u6bcf\u4e2a\u70b9\u7684\u5165\u70b9\u4e0e\u51fa\u70b9\u4e4b\u95f4\u8fde\u4e24\u6761\u8fb9 $(1,x)$ \u548c $(\\infty, 0)$\u3002$x$ \u662f\u8be5\u70b9\u7684\u6743\u503c\u3002\n\n\u8fd9\u662f\u56e0\u4e3a\u6bcf\u4e2a\u70b9\u53ea\u80fd\u53d6\u4e00\u6b21\u3002\n\n\u7136\u540e\u8dd1\u4e00\u904d\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5c31\u5b8c\u4e8b\u5566\n\n\u5c0f\u6280\u5de7\uff1a\u628a\u8d39\u7528\u53d6\u8d1f\u7136\u540e\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\n\n\n### Code\n\n[\u770b\u4ee3\u7801\u6233\u8fd9\u91cc](https://www.cnblogs.com/acfunction/p/10105245.html)",
        "postTime": 1544534106,
        "uid": 54745,
        "name": "Gypsophila",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "\u8003\u8651\u5982\u4f55\u5efa\u56fe\u3002\u8fd8\u662f\u8001\u6837\u5b50\u5148\u62c6\u70b9\uff0c\u7136\u540e\u628a\u6bcf\u4e24\u4e2a\u70b9\u4e4b\u95f4\u8fde\u63a5\u4e24\u6761\u8fb9\uff0c\u4e00\u6761\u6d41\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a-\u70b9\u6743\uff0c\u5904\u7406\u662f\u5426\u8d70\u8fd9\u4e2a\u70b9\u3002\u4e00\u6761\u6d41\u91cf\u65e0\u9650\uff0c\u6ca1\u6709\u8d39\u7528\uff0c\u56e0\u4e3a\u54ea\u6015\u4e00\u4e2a\u70b9\u9009\u8fc7\u4e86\uff0c\u5b83\u7684\u5730\u65b9\u8fd8\u662f\u53ef\u4ee5\u91cd\u590d\u8d70\u8fc7\u53bb\u7684\u3002\n\u7136\u540e\u628a\u7ecf\u7531\u4e00\u4e2a\u70b9\u80fd\u5230\u8fbe\u7684\u53e6\u4e00\u4e2a\u70b9\u8fde\u8fb9\u3002\u56e0\u4e3a\u8981\u8d70k\u6b21\uff0c\u6240\u4ee5\u7531s\u54111\u53f7\u70b9\u5165\u70b9\u8fde\u8fb9\uff0cn\u53f7\u70b9\u51fa\u70b9\u5411t\u8fde\u8fb9\uff0c\u6d41\u91cf\u4e3ak\uff0c\u8d39\u7528\u4e3a0\u3002\u7136\u540e\u4e00\u8fb9\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u677f\u5b50\u5373\u53ef\u3002\n\u7136\u540e\u53d1\u73b0\u8fd9\u4e9b\u4e2a\u9898\u89e3\u91cc\u6ca1\u6709\u7528\u539f\u59cb\u5bf9\u5076\u6765\u5b9e\u73b0\u7684\uff0c\u6240\u4ee5\u5f31\u5f31\u7684\u62ff\u51fa\u81ea\u5df1\u4ee3\u7801\uff0c\u52c9\u5f3a\u8fd8\u662f\u80fd\u5728\u6700\u4f18\u89e3\u7b2c\u4e00\u9875\u91cc\u7684\uff0c\u819c\u62dc\u90a3\u4e9b50ms\u90fd\u4e0d\u5230\u5c31\u8dd1\u5b8c\u7684dalao\u4eec\u3002\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define ll long long\n#define rp (i-1)*n+j \n#define cp (i-1)*n+j+n*n \n#define inf 50000000\n#define re register\nusing namespace std;\nstruct po\n{\n\tint from,to,dis,nxt,w;\n}edge[250001];\nint head[250001],cur[1000001],dep[60001],n,m,s,t,u,num=-1,x,y,l,tot,sum,k;\nint dis[6001],b[6001],xb[20001],flow[20001],a[55][55];\ninline int read()\n{\n    int x=0,c=1;\n    char ch=' ';\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    while(ch=='-')c*=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n    return x*c;\n}\ninline void add_edge(int from,int to,int w,int dis)\n{\n\tedge[++num].nxt=head[from];\n\tedge[num].to=to;\n\tedge[num].w=w;\n\tedge[num].dis=dis;\n\thead[from]=num;\n}\ninline void add(int from,int to,int w,int dis)\n{\n\tadd_edge(from,to,w,dis);\n\tadd_edge(to,from,0,-dis);\n}\ninline bool spfa()\n{\n\tmemset(b,0,sizeof(b));\n\tmemset(dis,100,sizeof(dis));\n\tdeque<int> q;\n\twhile(!q.empty())\n\tq.pop_back();\n\tdis[t]=0;b[t]=1;\n\tq.push_back(t);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop_front();\n\t\tb[u]=0;\n\t\tfor(re int i=head[u];i!=-1;i=edge[i].nxt)\n\t\t{\n\t\t\tint v=edge[i].to;\n\t\t\tif(edge[i^1].w>0&&dis[v]>dis[u]-edge[i].dis)\n\t\t\t{\n\t\t\t\tdis[v]=dis[u]-edge[i].dis;\n\t\t\t\tif(!b[v])\n\t\t\t\t{\n\t\t\t\t\tb[v]=1;\n\t\t\t\t\tif(!q.empty()&&dis[v]<dis[q.front()])\n\t\t\t\t\tq.push_front(v);\n\t\t\t\t\telse\n\t\t\t\t\tq.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[s]<inf;\n}\ninline int dfs(int u,int low)\n{\n\tif(u==t)\n\t{\n\t\tb[t]=1;\n\t\treturn low;\n\t}\n\tint diss=0;\n\tb[u]=1;\n\tfor(re int i=head[u];i!=-1;i=edge[i].nxt)\n\t{\n\t\tint v=edge[i].to;\n\t\tif(!b[v]&&edge[i].w!=0&&dis[v]==dis[u]-edge[i].dis)\n\t\t{\n\t\t\tint check=dfs(v,min(low,edge[i].w));\n\t\t\tif(check>0)\n\t\t\t{\n\t\t\t\ttot+=check*edge[i].dis;\n\t\t\t\tlow-=check;\n\t\t\t\tdiss+=check;\n\t\t\t\tedge[i].w-=check;\n\t\t\t\tedge[i^1].w+=check;\n\t\t\t\tif(low==0) break;\n\t\t\t}\n\t\t}\n\t}\n\treturn diss;\n}\ninline void max_flow()\n{\n\tint ans=0;\n\twhile(spfa())\n\t{\n\t\tb[t]=1;\n\t\twhile(b[t]==1)\n\t\t{\n\t\t\tmemset(b,0,sizeof(b));\n\t\t\tans=dfs(s,inf);\n\t\t}\n\t}\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tn=read();k=read();\n\tfor(re int i=1;i<=n;i++)\n\t for(re int j=1;j<=n;j++)\n\t \ta[i][j]=read();\n\ts=0;t=n*n*2+1;\n\tadd(s,1,k,0);add(n*n*2,t,k,0);\n\tfor(re int i=1;i<=n;i++)\n\t for(re int j=1;j<=n;j++)\n\t {\n\t \tadd(rp,cp,1,-a[i][j]);\n\t \tadd(rp,cp,inf,0);\n\t \tif(i<n)\n\t \tadd(cp,rp+n,inf,0);\n\t \tif(j<n)\n\t \tadd(cp,rp+1,inf,0);\n\t }\n\tmax_flow();\n\tcout<<-tot;\n} \n```",
        "postTime": 1520123816,
        "uid": 49223,
        "name": "Victorique",
        "ccfLevel": 0,
        "title": "\u3010P2045\u3011\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248"
    },
    {
        "content": "\u4f5c\u4e3a\u4e00\u4e2a\u849f\u84bb\u7adf\u7136\u80fd\u4e0d\u770b\u9898\u89e3A\u6389\u8fd9\u9053\u9898\n\n\u5f53\u7136\u8981\u5199\u7247\u9898\u89e3\u6765\u5e86\u795d\u4e00\u4e0b\uff08^-^\uff09\n\n\u5176\u5b9e\u8fd9\u9898\u4f3c\u4e4e\u662f [\u6df1\u6d77\u673a\u5668\u4eba\u95ee\u9898](https://www.luogu.org/problemnew/show/4012 \"\u6df1\u6d77\u673a\u5668\u4eba\u95ee\u9898\") \u7684\u7b80\u5316\u7248\n\n\u90fd\u662f\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\uff08\u778e\u8d77\u540d\u5b57\uff09\n\n\u628a\u5750\u6807\u538b\u4e3a\u70b9\n\n\u5efa\u56fe\n\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\n\n\u5206\u4e3a\u5165\u70b9\u548c\u51fa\u70b9\n\n\u4e24\u70b9\u95f4\u8fde\u5bb9\u91cf\u4e3a1\uff08\u53ea\u80fd\u53d6\u4e00\u6b21\uff09\u8d39\u7528\u4e3a-\u70b9\u6743\uff08\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff09\u7684\u8fb9\n\n\u4f46\u53ea\u80fd\u53d6\u4e00\u6b21\u4e0d\u4ee3\u8868\u53ea\u80fd\u8fc7\u4e00\u6b21\n\n\u6240\u4ee5\u4e24\u70b9\u95f4\u518d\u8fde\u5bb9\u91cf\u4e3aINF\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u5bf9\u4e8e\u539f\u6765\u6bcf\u4e00\u4e2a\u70b9\n\n\u5982\u679c\u5b83\u4e0b\u9762\u8fd8\u6709\u70b9\n\n\u5c31\u5c06\u4e24\u70b9\u7684\u51fa\u70b9\u548c\u5165\u70b9\u8fde\u5bb9\u91cf\u4e3aINF\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u7136\u540e\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u884c\u4e86\n\n\u6ce8\u610f\u7b54\u6848\u4e3a\u8d1f\u6570\n\n\u8bb0\u5f97\u52a0\u8d1f\u53f7\n\n```cpp\n# include<iostream>\n# include<cstdio>\n# include<cstring>\n# include<queue>\n# define pu(x,y) (x-1)*n+y\nusing namespace std;\nconst int MAX=4000001,Max=10001,INF=1e8;\nstruct p{\n    int x,y,dis,cn;\n}c[MAX];\nint n,k,num,tot1,t;\nint h[Max],d[Max],pre[Max];\nbool use[Max];\nvoid add(int x,int y,int dis,int cn)\n{\n    c[num].x=h[y];c[num].y=x;c[num].dis=0;c[num].cn=-cn;h[y]=num++;\n    c[num].x=h[x];c[num].y=y;c[num].dis=dis;c[num].cn=cn;h[x]=num++;\n}\nvoid EK()\n{\n    while(k--)\n    {\n        queue<int> qu;\n        qu.push(1);\n        memset(d,1,sizeof(d));\n        d[1]=0;\n        while(!qu.empty())\n        {\n            int tt=qu.front();\n            qu.pop();\n            use[tt]=0;\n            for(int i=h[tt];i;i=c[i].x)\n              if(d[c[i].y]>d[tt]+c[i].cn&&c[i].dis)\n              {\n                  d[c[i].y]=d[tt]+c[i].cn;\n                  pre[c[i].y]=i;\n                  if(!use[c[i].y])\n                  {\n                      use[c[i].y]=1;\n                      qu.push(c[i].y);\n                }\n              }\n        }\n        if(d[t]>1e7) return;\n        int hh=t,sum=INF;\n        while(pre[hh])\n        {\n            int l=pre[hh];\n            sum=min(sum,c[l].dis);\n            hh=c[l^1].y;\n        }\n        hh=t;\n        while(pre[hh])\n        {\n            int l=pre[hh];\n            c[l].dis-=sum;\n            c[l^1].dis+=sum;\n            tot1+=sum*c[l].cn;\n            hh=c[l^1].y;\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&k);\n    int N=2500;\n    t=n*n+N;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++)\n        {\n            int x,hh;\n            scanf(\"%d\",&x);\n            hh=pu(i,j);\n            add(hh,hh+N,1,-x);\n            add(hh,hh+N,INF,0);\n            if(i!=n)\n            add(hh+N,pu(i+1,j),INF,0); \n            if(j!=n)\n            add(hh+N,pu(i,j+1),INF,0);\n        }\n    EK();\n    printf(\"%d\",-tot1);\n    return 0;\n}\n```",
        "postTime": 1514114248,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    },
    {
        "content": "\u8d39\u7528\u6d41 \u5efa\u56fe\u65b9\u5f0f\u5728\u6ce8\u91ca\u91cc\u5199\u4e86\n\n\u628a\u4e00\u4e2a\u70b9\u62c6\u5f00\u786e\u4fdd\u8d70\u7684\u6b21\u6570\u6b63\u786e\n\n\u7528\u8d39\u7528\u8868\u793a\u53d6\u6570\n\n\u6700\u540e\u6c42\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\n\n\n\u53e6\u5916\u8fd9\u4e2a\u9898\u7684\u6570\u636e\u8303\u56f4\u6211\u6000\u7591\u6709\u95ee\u9898\u2026\u2026\n\n\u6211\u6539\u4e86\u597d\u51e0\u6b21\u8fb9\u6570\n\n\u5f0050w\u8fb9WA\n\n\u6539100w\u8fb9\u5c31A\u4e86 \u83ab\u540d\u5176\u5999\u2026\u2026\n\n```cpp\n\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=51,E=1000000,S=0,T=30000,INF=1e9;\n\nint n=0,a[N][N],k=0;\nint edge=0,next[E],to[E],head[E],cap[E],cost[E],flow[E];\nint dis[E],prev[E],inq[E],q[E],pos[E],front=0,tail=0;\n\nvoid addEdge(int u,int v,int c,int w) {\n    cap[edge]=c,cost[edge]=w,to[edge]=v,next[edge]=head[u],head[u]=edge++;\n    cap[edge]=0,cost[edge]=-w,to[edge]=u,next[edge]=head[v],head[v]=edge++;\n    flow[edge-1]=flow[edge-2]=0;\n}\n\n//\u62c6\u70b9 \u8fde\u4e24\u6761\u8fb9 cap=1 cost=a[i][j]\u548ccap=k cost=0\n//\u62c6\u5f00\u7684\u7b2c\u4e00\u4e2a\u70b91~n^2 \u7b2c\u4e8c\u4e2a\u70b9n^2+1~2n^2 \n//S=0 T=30000\nvoid build() {\n    addEdge(S,1,k,0);\n    addEdge(2*n*n,T,k,0);\n    for (int i=1;i<=n;++i)\n        for (int j=i;j<=n;++j) {\n            addEdge(i+(j-1)*n,i+(j-1)*n+n*n,1,a[j][i]);\n            addEdge(i+(j-1)*n,i+(j-1)*n+n*n,k,0);\n            if (j!=n)\n                addEdge(i+(j-1)*n+n*n,i+j*n,k,0);\n            if (i!=n)\n                addEdge(i+(j-1)*n+n*n,i+1+(j-1)*n,k,0);\n            if (i!=j) {\n                addEdge(j+(i-1)*n,j+(i-1)*n+n*n,1,a[i][j]);\n                addEdge(j+(i-1)*n,j+(i-1)*n+n*n,k,0);\n                if (i!=n)\n                    addEdge(j+(i-1)*n+n*n,j+i*n,k,0);\n                if (j!=n)\n                    addEdge(j+(i-1)*n+n*n,j+1+(i-1)*n,k,0);\n            }\n        }\n}\n\nint spfa() {\n    for (int i=S;i<=2*n*n;++i)\n        dis[i]=-INF;\n    dis[T]=-INF;\n    prev[T]=-1;\n    q[tail++]=S;\n    inq[S]=1;\n    dis[S]=0;\n    while (front<tail) {\n        int x=q[front++];\n        inq[x]=0;\n        for (int i=head[x];i!=-1;i=next[i]) {\n            int v=to[i];\n            if (cost[i]+dis[x]>dis[v] && flow[i]<cap[i]) {\n                dis[v]=cost[i]+dis[x];\n                prev[v]=x;\n                pos[v]=i;\n                if (!inq[v]) {\n                    q[tail++]=v;\n                    inq[v]=1;\n                }\n            }\n\n        }\n    }\n    return prev[T]==-1?0:1;\n}\n\nlong long mcmf() {\n    long long cst=0;\n    int f=0;\n    while (spfa()) {\n        f=INF;\n        for (int i=T;i!=S;i=prev[i])\n            f=min(f,cap[pos[i]]-flow[pos[i]]);\n        cst+=f*dis[T];\n        for (int i=T;i!=S;i=prev[i]) {\n            flow[pos[i]]+=f;\n            flow[pos[i]^1]-=f;\n        }\n    }\n    return cst;\n}\n\nint main(void) {\n    for (int i=0;i<=E;++i)\n        head[i]=-1;\n    scanf(\"%d %d\",&n,&k);\n    for (int i=1;i<=n;++i)\n        for (int j=1;j<=n;++j)\n            scanf(\"%d\",&a[i][j]);\n    build();\n    printf(\"%lld\\n\",mcmf());\n    return 0;\n}\n\n```",
        "postTime": 1468832512,
        "uid": 13433,
        "name": "QwQ2000",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2045 \u3010\u65b9\u683c\u53d6\u6570\u52a0\u5f3a\u7248\u3011"
    }
]