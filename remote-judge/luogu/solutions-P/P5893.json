[
    {
        "content": "### \u9898\u76ee\u5927\u610f\n\n\u4e8c\u7ef4\u5355\u70b9\u4fee\u6539\u533a\u95f4\u6c42$\\gcd$\uff08~~\u9898\u76ee\u63cf\u8ff0\u5f97\u5df2\u7ecf\u5f88\u6e05\u695a\u4e86\u5427qwq~~\uff09\n\n### \u9898\u89e3\n\n\u8fd9\u79cd\u4e8c\u7ef4\u95ee\u9898\u5927\u6982\u4ec0\u4e48\u6811\u5957\u6811\u90fd\u80fd\u8fc7\uff0c\u6211\u8fd9\u91cc\u7528\u7684\u662f\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\uff0c\u4ee5\u4e0b\u662f\u4e00\u4e9b\u9700\u8981\u6ce8\u610f\u7684\u7ec6\u8282\uff1a\n\n- \u56e0\u4e3a$R,C\\leq10^9$\uff0c\u6240\u4ee5\u9700\u8981\u79bb\u6563\u5316\uff08\u610f\u5473\u7740\u4e0d\u80fd\u5f3a\u5236\u5728\u7ebf\uff09\uff1b\n\n- \u7531\u4e8e\u7a7a\u95f4\u9650\u5236\uff0c\u91cc\u5c42\u7ebf\u6bb5\u6811\u9700\u8981\u52a8\u6001\u5f00\u70b9\u4e14\u53ea\u80fd\u5f00\u5230$O(N_U)$\u5927\u5c0f\uff0c\u5916\u5c42\u53ef\u4ee5\u5f00\u5230$O(N_U+N_Q)$\uff1b\n\n- \u6ce8\u610f$\\gcd$\u53ea\u6ee1\u8db3\u533a\u95f4\u53ef\u52a0\uff0c\u4e8e\u662f\u6bcf\u4e00\u6b21\u4fee\u6539\u90fd\u5fc5\u987b\u4ece\u4e0b\u5f80\u4e0a\u4f9d\u6b21\u5408\u5e76\uff1b\n\n- \u672c\u9898\u7ea6\u5b9a$\\gcd(0,a)=\\gcd(a,0)=a$\n\n\u65f6\u7a7a\u6548\u7387$O(Nlog^2N)$\uff08\u8fd9\u91cc\u8ba4\u4e3a$N,N_U,N_Q$\u540c\u7ea7\uff09\n\n\u4ee5\u4e0b\u4ee3\u7801\uff1a\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define ll long long\n#define NU 22005\n#define NQ 250005\n\ninline void rd(int &x){\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t\tc=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\ninline void rdll(ll &x){\n\tx=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')\n\t\tc=getchar();\n\twhile(c>='0'&&c<='9'){\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n}\n\nint n;\nstruct query{\n\tint opt,x1,y1,x2,y2;\n\tll val;\n}qry[NU+NQ];\n\nint Valu[NU],_Valu,Valq[NU+(NQ<<1)],_Valq;\ninline void unq(){\n\tstd::sort(Valu+1,Valu+_Valu+1);\n\t_Valu=std::unique(Valu+1,Valu+_Valu+1)-Valu-1;\n\tstd::sort(Valq+1,Valq+_Valq+1);\n\t_Valq=std::unique(Valq+1,Valq+_Valq+1)-Valq-1;\n}\ninline int idu(int val){\n\treturn std::upper_bound(Valu+1,Valu+_Valu+1,val)-Valu-1;\n}\ninline int idq(int val){\n\treturn std::upper_bound(Valq+1,Valq+_Valq+1,val)-Valq-1;\n}\n\ninline ll gcd(ll x,ll y){\n\twhile(x&&y){\n\t\tll tmp=x%y;\n\t\tx=y;\n\t\ty=tmp;\n\t}\n\treturn x+y;\n}\n\nint _t;\nstruct node{\n\tint son[2];\n\tll val;\n}t[NU<<9];\n#define lson t[p].son[0],L,mid\n#define rson t[p].son[1],mid+1,R\ninline void ins(int &p,int L,int R,int pos,ll val){\n\tif(!p)\n\t\tp=++_t;\n\tif(L==R){\n\t\tt[p].val=val;\n\t\treturn;\n\t}\n\tint mid=(L+R)>>1;\n\tif(pos<=mid)\n\t\tins(lson,pos,val);\n\telse\n\t\tins(rson,pos,val);\n\tt[p].val=gcd(t[t[p].son[0]].val,t[t[p].son[1]].val);\n}\ninline void mrg(int &p,int L,int R,int q1,int q2,int pos){\n\tif(!p)\n\t\tp=++_t;\n\tif(L==R){\n\t\tt[p].val=gcd(t[q1].val,t[q2].val);\n\t\treturn;\n\t}\n\tint mid=(L+R)>>1;\n\tif(pos<=mid)\n\t\tmrg(lson,t[q1].son[0],t[q2].son[0],pos);\n\telse\n\t\tmrg(rson,t[q1].son[1],t[q2].son[1],pos);\n\tt[p].val=gcd(t[t[p].son[0]].val,t[t[p].son[1]].val);\n}\ninline ll Cal(int p,int L,int R,int l,int r){\n\tif(!p||Valu[L]>r||Valu[R]<l)\n\t\treturn 0;\n\tif(l<=Valu[L]&&Valu[R]<=r)\n\t\treturn t[p].val;\n\tint mid=(L+R)>>1;\n\treturn gcd(Cal(lson,l,r),Cal(rson,l,r));\n}\n#undef lson\n#undef rson\n\nint rt[(NU+(NQ<<1))<<2];\n#define lson p<<1,L,mid\n#define rson p<<1|1,mid+1,R\ninline void mdf(int p,int L,int R,int pos,int pos2,ll val){\n\tif(pos<L||pos>R)\n\t\treturn;\n\tif(L==R){\n\t\tins(rt[p],1,_Valu,pos2,val);\n\t\treturn;\n\t}\n\tint mid=(L+R)>>1;\n\tmdf(lson,pos,pos2,val);\n\tmdf(rson,pos,pos2,val);\n\tmrg(rt[p],1,_Valu,rt[p<<1],rt[p<<1|1],pos2);\n}\ninline ll cal(int p,int L,int R,int l,int r,int l2,int r2){\n\tif(L>r||R<l)\n\t\treturn 0;\n\tif(l<=L&&R<=r)\n\t\treturn Cal(rt[p],1,_Valu,l2,r2);\n\tint mid=(L+R)>>1;\n\treturn gcd(cal(lson,l,r,l2,r2),cal(rson,l,r,l2,r2));\n}\n#undef lson\n#undef rson\n\nint main(){\n\trd(n),rd(n),rd(n);\n\tfor(int i=1;i<=n;i++){\n\t\trd(qry[i].opt);\n\t\tif(qry[i].opt==1){\n\t\t\trd(qry[i].x1),rd(qry[i].y1),rdll(qry[i].val);\n\t\t\tValu[++_Valu]=qry[i].y1;\n\t\t\tValq[++_Valq]=qry[i].x1;\n\t\t}\n\t\telse{\n\t\t\trd(qry[i].x1),rd(qry[i].y1),rd(qry[i].x2),rd(qry[i].y2);\n\t\t\tValq[++_Valq]=qry[i].x1;\n\t\t\tValq[++_Valq]=qry[i].x2;\n\t\t}\n\t}\n\tunq();\n\tfor(int i=1;i<=n;i++)\n\t\tif(qry[i].opt==1)\n\t\t\tmdf(1,1,_Valq,idq(qry[i].x1),idu(qry[i].y1),qry[i].val);\n\t\telse\n\t\t\tprintf(\"%lld\\n\",cal(1,1,_Valq,idq(qry[i].x1),idq(qry[i].x2),qry[i].y1,qry[i].y2));\n  \n  #define w 0\n  return ~~('0')?(0^w^0):(0*w*0);\n}\n```\n",
        "postTime": 1583761489,
        "uid": 88652,
        "name": "Y25t",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P5893 \u3010[IOI2013]game \u6e38\u620f\u3011"
    },
    {
        "content": "\u4e8c\u7ef4\u6539\u70b9\uff0c\u8be2\u95ee $\\text{4-side}$ \u77e9\u5f62 $\\gcd$\u3002\n\n\u4f3c\u4e4e $\\text{IOI}$ \u8d5b\u65f6\u662f\u4ea4\u4e92\u9898\u6240\u4ee5\u662f\u5f3a\u5236\u5728\u7ebf\u7684\uff0c\u4f46\u662f\u8fd9\u91cc\u6ca1\u6709\u8fd9\u4e2a\u8981\u6c42\uff0c\u4e0d\u59a8\u76f4\u63a5\u628a\u4e8c\u7ef4\u5750\u6807\u79bb\u6563\u5316\u3002\n\n$\\gcd$ \u4e0d\u80fd\u5dee\u5206\u6240\u4ee5\u6ca1\u529e\u6cd5\u6109\u5feb\u626b\u63cf\u7ebf\uff0c\u4e8e\u662f\u66b4\u529b\u6811\u5957\u6811\u3002\n\n\u4e8b\u5b9e\u4e0a $O(n\\log^2n)$ \u7a7a\u95f4\u7684\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\u662f\u80fd\u8fc7\u7684\u3002\u5982\u679c\u5185\u5c42\u5957\u5e73\u8861\u6811\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u4f18\u5316\u5230 $O(n\\log n)$\u3002\n\n\u7b97\u4e0a $\\gcd$ \u7684\u590d\u6742\u5ea6\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^3n)$\u3002\n\n\u4ee5\u4e0b\u662f\u4e00\u4efd\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\u7684\u4ee3\u7801\u3002\u5916\u5c42 `Segment_Tree_1` \u7ef4\u62a4 $x$ \u8f74\uff0c\u5185\u5c42 `Segment_Tree_2` \u7ef4\u62a4 $y$ \u8f74\u3002\n\n```cpp\n# include <cstdio>\n# include <iostream>\n# include <algorithm>\n# include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll I(){\n\tll res = 0 , z = 1;\n\tchar c = getchar();\n\twhile( ! isdigit( c ) ){ if( c == '-' ) z = -1; c = getchar(); }\n\twhile( isdigit( c ) ) res = res * 10 + c - '0' , c = getchar();\n\treturn res * z; \n}\n\nconst int N = 1e6 + 225;\n\nstruct Operation{\n\tint op , x1 , y1 , x2 , y2;\n\tll k;\n}Q[ N ];\n\nint n , m , q , fX , fY;\n\nvector< int >X , Y;\n# define pb push_back\n# define lb lower_bound \n\nll GCD( ll x , ll y ){\n\treturn y ? GCD( y , x % y ) : x;\n}\n\nstruct Segment_Tree_1{\n\tint ls , rs , R;\n}T[ N << 2 ];\n\nstruct Segment_Tree_2{\n\tint ls , rs;\n\tll d;\n}D[ N << 5 ];\n\nint dT , dD , R;\n\nvoid Push_Up( int & u , int l , int r , int p , int x , int y ){\n\tif( ! u ) u = ++ dD;\n\tif( l == r ){\n\t\tD[ u ] . d = GCD( D[ x ] . d , D[ y ] . d );\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tif( p <= mid ) Push_Up( D[ u ] . ls , l , mid , p , D[ x ] . ls , D[ y ] . ls );\n\telse Push_Up( D[ u ] . rs , mid + 1 , r , p , D[ x ] . rs , D[ y ] . rs );\n\tD[ u ] . d = GCD( D[ D[ u ] . ls ] . d , D[ D[ u ] . rs ] . d );\n} \n\nvoid Modify_Y( int & u , int l , int r , int p , ll d ){\n\tif( ! u ) u = ++ dD; \n\tif( l == r ){ D[ u ] . d = d; return; }\n\tint mid = l + r >> 1;\n\tif( p <= mid ) Modify_Y( D[ u ] . ls , l , mid , p , d );\n\telse Modify_Y( D[ u ] . rs , mid + 1 , r , p , d );\n\tD[ u ] . d = GCD( D[ D[ u ] . ls ] . d , D[ D[ u ] . rs ] . d );\n}\n\nvoid Modify_X( int & u , int l , int r , int x , int y , ll d ){\n\tif( ! u ) u = ++ dT;\n\tif( l == r ){\n\t\tModify_Y( T[ u ] . R , 1 , fY , y , d );\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tif( x <= mid ) Modify_X( T[ u ] . ls , l , mid , x , y , d );\n\telse Modify_X( T[ u ] . rs , mid + 1 , r , x , y , d );\n\tPush_Up( T[ u ] . R , 1 , fY , y , T[ T[ u ] . ls ] . R , T[ T[ u ] . rs ] . R );\n}\n\nll Query_Y( int u , int l , int r , int y1 , int y2 ){\n\tif( ! u ) return 0;\n\tif( y1 <= l && r <= y2 ) return D[ u ] . d;\n\tint mid = l + r >> 1;\n\tif( y2 <= mid ) return Query_Y( D[ u ] . ls , l , mid , y1 , y2 );\n\tif( y1 > mid ) return Query_Y( D[ u ] . rs , mid + 1 , r , y1 , y2 );\n\treturn GCD( Query_Y( D[ u ] . ls , l , mid , y1 , y2 ) , Query_Y( D[ u ] . rs , mid + 1 , r , y1 , y2 ) );\n}\n\nll Query_X( int u , int l , int r , int x1 , int y1 , int x2 , int y2 ){\n\tif( ! u ) return 0;\n\tif( x1 <= l && r <= x2 ) return Query_Y( T[ u ] . R , 1 , fY , y1 , y2 );\n\tint mid = l + r >> 1;\n \tif( x2 <= mid ) return Query_X( T[ u ] . ls , l , mid , x1 , y1 , x2 , y2 );\n \tif( x1 > mid ) return Query_X( T[ u ] . rs , mid + 1 , r , x1 , y1 , x2 , y2 );\n\treturn GCD( Query_X( T[ u ] . ls , l , mid , x1 , y1 , x2 , y2 ) , Query_X( T[ u ] . rs , mid + 1 , r , x1 , y1 , x2 , y2 ) );\n}\n\nvoid Solve(){\n\tfor( int i = 1 ; i <= q ; i ++ ){\n\t\tint op = Q[ i ] . op , x1 = Q[ i ] . x1 , y1 = Q[ i ] . y1;\n\t\tif( op == 1 ){\n\t\t\tll k = Q[ i ] . k;\n\t\t\tModify_X( R , 1 , fX , x1 , y1 , k );\n\t\t}\n\t\telse{\n\t\t\tint x2 = Q[ i ] . x2 , y2 = Q[ i ] . y2;\n\t\t\tif( x1 > x2 ) swap( x1 , x2 );\n\t\t\tif( y1 > y2 ) swap( y1 , y2 );\n\t\t\tprintf( \"%lld\\n\" , Query_X( R , 1 , fX , x1 , y1 , x2 , y2 ) );\n\t\t}\n\t}\n}\n\nvoid Init(){\n\tsort( X . begin() , X . end() );\n\tX . erase( unique( X . begin() , X . end() ) , X . end() );\n\tsort( Y . begin() , Y . end() );\n\tY . erase( unique( Y . begin() , Y . end() ) , Y . end() );\n\tfX = X . size() + 1 , fY = Y . size() + 1;\n\tfor( int i = 1 ; i <= q ; i ++ ){\n\t\tQ[ i ] . x1 = lb( X . begin() , X . end() , Q[ i ] . x1 ) - X . begin();\n\t\tQ[ i ] . y1 = lb( Y . begin() , Y . end() , Q[ i ] . y1 ) - Y . begin();\n\t\tif( Q[ i ] . op == 2 ){\n\t\t\tQ[ i ] . x2 = lb( X . begin() , X . end() , Q[ i ] . x2 ) - X . begin();\n\t\t\tQ[ i ] . y2 = lb( Y . begin() , Y . end() , Q[ i ] . y2 ) - Y . begin(); \n\t\t}\n\t}\t\t\n}\n\nvoid Input(){\n\tX . pb( -1 ) , Y . pb( -1 );\n\tn = I() , m = I() , q = I();\n\tfor( int i = 1 ; i <= q ; i ++ ){\n\t\tint op = I() , x1 = I() + 1 , y1 = I() + 1;\n\t\tX . pb( x1 ) , Y . pb( y1 );\n\t\tif( op == 1 ){\n\t\t\tll k = I();\n\t\t\tQ[ i ] = { op , x1 , y1 , 0 , 0 , k };\n\t\t}\n\t\telse{\n\t\t\tint x2 = I() + 1 , y2 = I() + 1;\n\t\t\tQ[ i ] = { op , x1 , y1 , x2 , y2 , 0 };\n\t\t\tX . pb( x2 ) , Y . pb( y2 );\n\t\t}\n\t}\n}\n\nint main(){\n\tInput();\n\tInit();\n\tSolve();\n\treturn 0;\n}\n```\n",
        "postTime": 1659363841,
        "uid": 381996,
        "name": "yukari1735",
        "ccfLevel": 0,
        "title": "[IOI2013]game \u6e38\u620f"
    }
]