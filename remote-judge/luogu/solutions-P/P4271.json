[
    {
        "content": "\u8fd9\u4e2a\u505a\u6cd5\u4e0d\u4ec5\u80fd\u652f\u6301\u52a0\u8fb9\uff0c\u8fd8\u80fd\u652f\u6301\u5220\u8fb9\u3002\n\n\u8003\u8651\u76f4\u63a5\u5728LCT\u4e0a\u67e5\u8be2\u6700\u5927\u7684\u6df1\u5ea6\uff0c\u50cf\u6211\u4eec\u7ef4\u62a4\u5b50\u6811$size$\u90a3\u6837\u6211\u4eec\u5728\u6bcf\u4e2a\u70b9\u4e0a\u5f00\u4e2a\u53ef\u5220\u5806\u6216\u8005set\u7ef4\u62a4\u8f7b\u513f\u5b50\u7684\u5b50\u6811\u5185\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u7531\u4e8e\u8f7b\u8fb9\u5b9e\u9645\u4e0a\u662f\u7236\u4eb2\u4e0e\u8fd9\u68f5Splay\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u8fde\u7684\u8fb9\uff0c\u6211\u4eec\u8bbe$f[i]$\u4e3a\u4ecei\u8fd9\u68f5**Splay\u5b50\u6811**\u5185\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u5f80\u4e0b\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u5f53\u7136\uff0c\u7531\u4e8e\u6211\u4eec\u7684Splay\u9700\u8981\u652f\u6301\u7ffb\u8f6c\u64cd\u4f5c\uff0c\u6211\u4eec\u8fd8\u8981\u7ef4\u62a4\u4e00\u4e2a\u8f6c\u79fb\u987a\u5e8f\u548c$f[i]$\u5b8c\u5168\u76f8\u53cd\u7684$g[i]$\uff0c\u5373\u628a\u8fd9\u4e2aSplay\u5b8c\u5168\u7ffb\u8f6c\u8fc7\u6765\u4e4b\u540e\uff0c\u73b0\u5728\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u662f\u539f\u6765\u6df1\u5ea6\u6700\u5927\u7684\u70b9\uff0c\u4ece\u8fd9\u4e2a\u70b9\u201c\u5f80\u4e0b\u201d\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u90a3\u4e48\u7ffb\u8f6c\u7684\u65f6\u5019$swap$\u4e00\u4e0b$f$\u548c$g$\u5373\u53ef\u3002\n\n\u8003\u8651$f$\u7684\u8f6c\u79fb\uff0c\u9996\u5148\u663e\u7136\u6709$f[i]=max(f[i],f[ch[i][0]])$\uff0c\u8fd9\u4e2a\u53ef\u80fd\u5728\u6df1\u5ea6\u5c0f\u4e8e$i$\u7684\u90e8\u5206\u5c31\u8f6c\u5230\u4e86\u8f7b\u513f\u5b50\u4e0a\uff0c\u5f53\u7136\u8fd8\u53ef\u80fd\u628a$i$\u4e0a\u9762\u7684\u4e00\u90e8\u5206\u90fd\u53d6\u4e86\uff0c\u53ef\u4ee5\u8f6c\u5230$i$\u4e0b\u9762\u7684\u90e8\u5206\uff1a$f[i]=max(f[i],f[ch[i][1]]+size[ch[i][0]])$\uff0c\u8fd8\u53ef\u4ee5\u5728$i$\u8f6c\u5230\u8f7b\u513f\u5b50\u4e0a\uff1a$f[i]=max(f[i],size[ch[i][0]]+heap[i].top())$\uff0c\uff08$heap[i].top()$\u662f\u7ef4\u62a4\u8f7b\u513f\u5b50\u7684\u5806\u7684\u5806\u9876\uff09\u3002\u7136\u540eaccess\u548clink\u7684\u65f6\u5019\u6ce8\u610f\u7ef4\u62a4\u5806\u3002$O(n\\log^2n)$\u3002\n\n\u4e0a\u4ee3\u7801~\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#define N 100011\n#define opp(_o) (_o == ch[fa[_o]][1])\n#define isroot(_o) (_o != ch[fa[_o]][1] && _o != ch[fa[_o]][0])\nusing namespace std;\nnamespace ywy {\n\tinline int get() {\n\t    int n = 0;\n\t    char c;\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            break;\n\t        if (c == '-')\n\t            goto s;\n\t    }\n\t    n = c - '0';\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 + c - '0';\n\t        else\n\t            return (n);\n\t    }\n\ts:\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 - c + '0';\n\t        else\n\t            return (n);\n\t    }\n\t}\n\tint ch[N][2], fa[N], size[N], mxzheng[N], mxfan[N], stk[N];\n\tunsigned char bj[N];\n\ttypedef struct _heap {\n\t    priority_queue<int> me, del;\n\t    inline int top() {\n\t        while (!me.empty() && !del.empty() && me.top() == del.top()) me.pop(), del.pop();\n\t        if (me.empty())\n\t            return (0);\n\t        return (me.top());\n\t    }\n\t    inline int empty() {\n\t        while (!me.empty() && !del.empty() && me.top() == del.top()) me.pop(), del.pop();\n\t        return (me.empty());\n\t    }\n\t    inline void push(int x) {\n\t        me.push(x);\n\t    }\n\t    inline void erase(int x) {\n\t        del.push(x);\n\t    }\n\t} heap;\n\theap hp[N];\n\tinline void down(int tree) {\n\t    if (!bj[tree])\n\t        return;\n\t    swap(mxzheng[ch[tree][0]], mxfan[ch[tree][0]]);\n\t    bj[tree] = 0;\n\t    swap(mxzheng[ch[tree][1]], mxfan[ch[tree][1]]);\n\t    swap(ch[tree][0], ch[tree][1]);\n\t    bj[ch[tree][0]] ^= 1;\n\t    bj[ch[tree][1]] ^= 1;\n\t}\n\tinline void up(int tree) {\n\t    size[tree] = size[ch[tree][0]] + size[ch[tree][1]] + 1;\n\t    mxzheng[tree] = mxfan[tree] = hp[tree].top();\n\t    if (ch[tree][0]) {\n\t        mxzheng[tree] = max(mxzheng[tree], mxzheng[ch[tree][0]]);\n\t        mxfan[tree] = max(mxfan[tree], mxfan[ch[tree][0]] + 1 + size[ch[tree][1]]);\n\t        mxzheng[tree] = max(mxzheng[tree], size[ch[tree][0]]);\n\t        if (!hp[tree].empty()) {\n\t            mxzheng[tree] = max(mxzheng[tree], size[ch[tree][0]] + hp[tree].top());\n\t        }\n\t    }\n\t    if (ch[tree][1]) {\n\t        mxzheng[tree] = max(mxzheng[tree], mxzheng[ch[tree][1]] + 1 + size[ch[tree][0]]);\n\t        mxfan[tree] = max(mxfan[tree], mxfan[ch[tree][1]]);\n\t        mxfan[tree] = max(mxfan[tree], size[ch[tree][1]]);\n\t        if (!hp[tree].empty()) {\n\t            mxfan[tree] = max(mxfan[tree], size[ch[tree][1]] + hp[tree].top());\n\t        }\n\t    }\n\t    if (ch[tree][0] && ch[tree][1]) {\n\t        mxzheng[tree] = max(mxzheng[tree], size[ch[tree][0]] + 1 + mxzheng[ch[tree][1]]);\n\t        mxfan[tree] = max(mxfan[tree], size[ch[tree][1]] + 1 + mxfan[ch[tree][0]]);\n\t    }\n\t    if (!hp[tree].empty()) {\n\t        mxzheng[tree] = max(mxzheng[tree], hp[tree].top() + size[ch[tree][0]]);\n\t        mxfan[tree] = max(mxfan[tree], hp[tree].top() + size[ch[tree][1]]);\n\t    }\n\t}\n\tinline void xuan(int me) {\n\t    int tree = fa[me], cjr = fa[tree];\n\t    down(cjr);\n\t    down(tree);\n\t    down(me);\n\t    int op = opp(me), ls = ch[me][op ^ 1];\n\t    ch[tree][op] = ls;\n\t    fa[ls] = tree;\n\t    ch[me][op ^ 1] = tree;\n\t    if (!isroot(tree))\n\t        ch[cjr][opp(tree)] = me;\n\t    fa[tree] = me;\n\t    fa[me] = cjr;\n\t    up(tree);\n\t    up(me);\n\t}\n\tinline void splay(int tree) {\n\t    if (isroot(tree)) {\n\t        down(tree);\n\t        return;\n\t    }\n\t    int tmp = tree, sp = 0;\n\t    while (!isroot(tmp)) stk[sp] = tmp, sp++, tmp = fa[tmp];\n\t    down(tmp);\n\t    while (sp) sp--, down(stk[sp]);\n\t    while (!isroot(tree)) {\n\t        int cjr = fa[tree];\n\t        if (!isroot(cjr))\n\t            xuan((opp(cjr) == opp(tree)) ? cjr : tree);\n\t        xuan(tree);\n\t    }\n\t    up(tree);\n\t}\n\tinline void access(int tree) {\n\t    splay(tree);\n\t    down(tree);\n\t    if (ch[tree][1]) {\n\t        hp[tree].push(mxzheng[ch[tree][1]] + 1);\n\t        ch[tree][1] = 0;\n\t        up(tree);\n\t    }\n\t    while (fa[tree]) {\n\t        int cjr = fa[tree];\n\t        splay(cjr);\n\t        down(cjr);\n\t        if (ch[cjr][1]) {\n\t            hp[cjr].push(mxzheng[ch[cjr][1]] + 1);\n\t            ch[cjr][1] = 0;\n\t            up(cjr);\n\t        }\n\t        hp[cjr].erase(mxzheng[tree] + 1);\n\t        ch[cjr][1] = tree;\n\t        up(cjr);\n\t        splay(tree);\n\t    }\n\t    up(tree);\n\t}\n\tinline void makeroot(int tree) {\n\t    access(tree);\n\t\n\t    splay(tree);\n\t    bj[tree] ^= 1;\n\t    swap(mxzheng[tree], mxfan[tree]);\n\t}\n\tinline void link(int a, int b) {\n\t    makeroot(a);\n\t    makeroot(b);\n\t    hp[a].push(mxzheng[b] + 1);\n\t    fa[b] = a;\n\t    up(a);\n\t}\n\tinline char cget() {\n\t    char c;\n\t    while ((c = getchar()) || 23333)\n\t        if (c >= 'A' && c <= 'Z')\n\t            return (c);\n\t}\n\tvoid ywymain() {\n\t    mxzheng[0] = -1;\n\t    mxfan[0] = -1;\n\t    int q = get();\n\t    int gn = 1;\n\t    while (q) {\n\t        q--;\n\t        char c = cget();\n\t        if (c == 'B') {\n\t            int x = get(), me = gn;\n\t            gn++;\n\t            size[me] = 1;\n\t            if (x == -1)\n\t                continue;\n\t            link(me, x);\n\t        } else {\n\t            int x = get();\n\t            makeroot(x);\n\t            printf(\"%d\\n\", mxzheng[x]);\n\t        }\n\t    }\n\t}\n}\nint main() {\n    ywy::ywymain();\n    return (0);\n}\n```",
        "postTime": 1555240319,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4271 \u3010[USACO18FEB]New Barns\u3011"
    },
    {
        "content": "\u771f\u4e0d\u61c2\u8fd9\u9898\u4e3a\u5565\u8981 LCT\uff0c~~\u867d\u7136\u6211\u4e00\u5f00\u59cb\u60f3\u7684\u4e5f\u662f LCT......~~\n\n\u7ed3\u8bba\uff1a\u4e00\u4e2a\u70b9 $u$ \u5728\u6811\u5185\u7684\u6700\u8fdc\u70b9\uff08\u4e4b\u4e00\uff09\uff0c\u4e00\u5b9a\u662f**\u8fd9\u68f5\u6811\u7684\u76f4\u5f84\u7684\u4e00\u4e2a\u7aef\u70b9\u3002**\n\n\u53e6\u4e00\u4e2a\u7ed3\u8bba\uff1a**\u4e24\u68f5\u6811\u7528\u4e00\u6761\u8fb9\u8fde\u8d77\u6765\u7684\u65f6\u5019\uff0c\u65b0\u7684\u76f4\u5f84\u4e00\u5b9a\u662f\u4e24\u68f5\u6811\u5404\u81ea\u7684\u76f4\u5f84\u7684\u4e24\u4e24\u7ec4\u5408\u4e2d\uff0c\u6700\u957f\u7684\u90a3\u4e00\u6761\u3002**\n\n\u8003\u8651\u5148\u79bb\u7ebf\u5efa\u51fa\u6574\u68f5\u6811\uff0c\u500d\u589e\u7ef4\u62a4 LCA\uff0c\u7528\u516c\u5f0f $dist(u,v)=depth_u+depth_v-2 \\times depth_{lca(u,v)}$ \u8ba1\u7b97\u4e24\u70b9\u95f4\u8ddd\u79bb\u3002\n\n\u7136\u540e\u6309\u987a\u5e8f\u64cd\u4f5c\uff0c\u78b0\u5230 $\\texttt{B}$ \u52a0\u8fb9\u64cd\u4f5c\uff0c\u5408\u5e76\u4e24\u68f5\u6811\uff0c\u5e76\u4e14\u6211\u4eec\u53d1\u73b0\u5176\u4e2d\u4e00\u68f5\u53ea\u6709\u4e00\u4e2a\u70b9\uff0c\u90a3\u4e48\u4e0a\u9762\u8bf4\u7684\u56db\u4e2a\u70b9\u4e24\u4e24\u7ec4\u5408\uff0c\u53ef\u4ee5\u7b80\u5316\u4e3a $3$ \u79cd\u7ec4\u5408\u65b9\u5f0f\uff0c\u9009\u51fa\u8ddd\u79bb\u6700\u5927\u7684\u4e00\u79cd\u4f5c\u4e3a\u65b0\u7684\u76f4\u5f84\u5e76\u8bb0\u5f55\u3002\n\n\u78b0\u5230 $\\texttt{Q}$ \u67e5\u8be2\u64cd\u4f5c\uff0c\u76f4\u63a5\u627e\u5230 $k$ \u70b9\u6240\u5728\u7684\u6811\u7684\u76f4\u5f84\uff0c\u7136\u540e\u5206\u522b\u7b97\u51fa $k$ \u5230\u76f4\u5f84\u4e24\u4e2a\u7aef\u70b9\u8ddd\u79bb\uff0c\u53d6\u8f83\u5927\u503c\u5373\u53ef\u3002\n\n\u518d\u8003\u8651\u5982\u4f55\u8bb0\u5f55\u76f4\u5f84\uff0c\u6211\u4e00\u5f00\u59cb\u60f3\u7684\u662f\u7528\u5e76\u67e5\u96c6\uff0c\u628a\u4e00\u6761\u76f4\u5f84\u8bb0\u5f55\u5728\u5e76\u67e5\u96c6\u7684\u4ee3\u8868\u5143\u7684\u4f4d\u7f6e\u3002\u540e\u6765\u60f3\u60f3\u5e76\u67e5\u96c6\u90fd\u4e0d\u7528\u4e86\uff0c\u79bb\u7ebf\u5efa\u6811\u7684\u8fc7\u7a0b\u4e2d\uff0c\u76f4\u63a5\u6c42\u51fa\u6bcf\u4e2a\u70b9\u6240\u5728\u7684\u6811\u7684\u6839\uff0c\u628a\u76f4\u5f84\u8bb0\u5f55\u5728\u6839\u7684\u4f4d\u7f6e\u5c31\u884c\u4e86\uff0c\u8fd8\u7701\u6389\u4e86\u5e76\u67e5\u96c6\u7684\u5e38\u6570\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u5047\u8bbe\u64cd\u4f5c\u6570\u662f $q$\uff0c\u7ed3\u70b9\u6570\u662f $n$\uff0c\u5982\u679c\u500d\u589e\uff0c\u9884\u5904\u7406\u590d\u6742\u5ea6 $O(n \\log n)$\uff0c\u5355\u6b21\u6c42 $lca$ \u590d\u6742\u5ea6 $O(\\log n)$\uff0c\u603b\u590d\u6742\u5ea6\u7ea6\u4e3a $O((n+q)\\log n)$\uff1b\u7528\u6b27\u62c9\u5e8f\u5217 + ST \u8868\u6c42 $lca$ \u7684\u603b\u590d\u6742\u5ea6 $O(n \\log n + q)$\uff0c~~\u518d\u7528\u56db\u6bdb\u5b50\u4f18\u5316\u5c31\u53ef\u4ee5\u505a\u5230\u7ebf\u6027\u4e86\u3002~~\n\n\u5177\u4f53\u7ec6\u8282\u770b\u4ee3\u7801\u5427\uff1a\n\n```cpp\n#include <cstdio>\nusing namespace std;\nconst int N = 100010;\nconst int LOGN = 17;\nstruct Edge {\n\tint to, nxt;\n}edges[N];\nint point[N][2]; //\u8bb0\u5f55\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\nint fa[N][LOGN], depth[N];\nint opt[N], queryu[N], idx[N];\nint head[N], root[N], n, m, nedge; //root[u] \u8868\u793a u \u70b9\u6240\u5728\u7684\u6811\u7684\u6839\ninline int max(int x, int y) {return x > y ? x : y;}\ninline void swap(int &x, int &y) {x ^= y; y ^= x; x ^= y;}\ninline void addedge(int u, int v) {\n\tedges[++nedge].to = v;\n\tedges[nedge].nxt = head[u];\n\thead[u] = nedge;\n}\ninline void dfs(int u) {\n\tfor(register int i = 1; (1 << i) <= depth[u]; ++i)\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\tfor(register int i = head[u]; i; i = edges[i].nxt) {\n\t\tint v = edges[i].to;\n\t\tfa[v][0] = u; depth[v] = depth[u] + 1;\n\t\tif(u == 0) root[v] = v;\n\t\telse root[v] = root[u];\n\t\tdfs(v);\n\t}\n}\ninline int LCA(int u, int v) {\n\tif(depth[u] < depth[v]) swap(u, v);\n\tfor(register int i = LOGN - 1; i >= 0; --i)\n\t\tif((1 << i) <= depth[u] - depth[v]) u = fa[u][i];\n\tif(u == v) return u;\n\tfor(register int i = LOGN - 1; i >= 0; --i)\n\t\tif(fa[u][i] != fa[v][i]) {u = fa[u][i]; v = fa[v][i];}\n\treturn fa[u][0];\n}\ninline int dist(int u, int v) {\n\treturn depth[u] + depth[v] - 2 * depth[LCA(u, v)];\n}\nint main() {\n\tscanf(\"%d\", &m);\n\tfor(register int i = 1; i <= m; ++i) {\n\t\tchar op[5];\n\t\tscanf(\"%s %d\", op, &queryu[i]);\n\t\tif(op[0] == 'B') opt[i] = 1; else opt[i] = 2;\n\t\tif(opt[i] == 1) {idx[i] = ++n; addedge(queryu[i] > -1 ? queryu[i] : 0, n);} //idx[i] \u8bb0\u5f55\u7b2c i \u6b65\uff08\u5982\u679c\u662f B \u64cd\u4f5c\uff09\u65b0\u5efa\u7684\u70b9\u7684\u7f16\u53f7\n\t}\n\tdfs(0);\n\tfor(register int u = 1; u <= n; ++u) point[u][0] = point[u][1] = u;\n\tfor(register int i = 1; i <= m; ++i) {\n\t\tif(opt[i] == 1 && queryu[i] != -1) {\n\t\t\tint x = root[queryu[i]];\n\t\t\tint dist1 = dist(point[x][0], point[x][1]);\n\t\t\tint dist2 = dist(point[x][0], idx[i]), dist3 = dist(point[x][1], idx[i]);\n\t\t\tif(dist1 >= dist2 && dist1 >= dist3) {}\n\t\t\telse if(dist2 >= dist1 && dist2 >= dist3) point[x][1] = idx[i];\n\t\t\telse point[x][0] = idx[i]; //\u4e09\u4e2a\u8ddd\u79bb\u9009\u6700\u5927\u7684\u8bb0\u5f55\u4e0b\u6765\uff08\u6ce8\u610f\u4ee5\u4e0a\u7684 >= \u4e0d\u80fd\u5199\u6210 >\uff0c\u5177\u4f53\u539f\u56e0\u81ea\u884c\u601d\u8003\uff09\n\t\t}\n\t\tif(opt[i] == 2) {\n\t\t\tint x = root[queryu[i]];\n\t\t\tprintf(\"%d\\n\", max(dist(point[x][0], queryu[i]), dist(point[x][1], queryu[i])));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1645947726,
        "uid": 95625,
        "name": "\u66b4\u529b\u51fa\u5947\u8ff9",
        "ccfLevel": 0,
        "title": "P4271 [USACO18FEB]New Barns P \u9898\u89e3"
    },
    {
        "content": "\u8fd9\u9898\u53ef\u4ee5\u7b97\u662f$LCT$\u52a8\u6001\u7ef4\u62a4\u6811\u7684\u76f4\u5f84\u7684\u6a21\u677f\u9898\n\n\u8003\u8651\u8fd9\u6837\u4e24\u4e2a\u6027\u8d28\uff1a\n\n- **\u4e24\u68f5\u6811\u5408\u5e76\u540e\u7684\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u6765\u6e90\u4e8e\u4e24\u6761\u76f4\u5f84\u4e2d\u7684\u56db\u4e2a\u7aef\u70b9**\n- **\u4ece\u4e00\u70b9\u51fa\u53d1\u641c\u5230\u6700\u8fdc\u7684\u70b9\u4e00\u5b9a\u662f\u76f4\u5f84\u4e24\u7aef\u70b9\u4e4b\u4e00**\n\n\u8bc1\u660e\uff1a\uff08\u849f\u84bb\u6570\u5b66\u4e0d\u597d\uff0c\u8981\u662f\u5199\u9519\u4e86\u8bf7\u5404\u4f4d\u5927\u4f6c\u6307\u51fa\n\n\u8bbe\u76f4\u5f84\u4e3a$s-t$\n\n- \u5f53\u8be5\u70b9$u$\u4e3a\u76f4\u5f84\u4e0a\u7684\u70b9\u65f6\uff0c\u8bbe\u641c\u5230\u7684\u6700\u8fdc\u70b9\u4e3a$x$\uff0c\u5219$dis(u,x)>dis(u,t)$\u4e14$dis(u,x)>dis(u,s)$\uff0c\u82e5$x$\u4e0d\u4e3a$s$\u6216$t$\u4e2d\u4e00\u70b9\u5219\u76f4\u5f84\u5c31\u4e0d\u662f$s-t$\uff0c\u800c\u662f$u-x$\u3002\n- \u5f53\u8be5\u70b9$u$\u4e0d\u4e3a\u76f4\u5f84\u4e0a\u7684\u70b9\u65f6\uff1a\n  - \u82e5$u$\u8d70\u5230\u4e86$s-t$\u4e0a\u7684\u67d0\u70b9$x$\uff0c\u6700\u540e\u80af\u5b9a\u8d70\u5230\u67d0\u4e2a\u7aef\u70b9\uff0c\u5047\u8bbe\u662f$s$\uff1b\n  - \u82e5$u$\u5230\u6700\u8fdc\u70b9$v$\u7684\u8def\u5f84\u4e0e$s-t$\u65e0\u4ea4\u70b9\uff0c\u5219$dis(u,v)>dis(u,x)+dis(s,x)$\uff0c\u90a3\u4e48$dis(u,v)+dis(x,t)>dis(u,x)+dis(s,x)+dis(x,t)$\uff0c\u79fb\u9879\u53ef\u5f97$dis(u,v)+dis(x,t)-dis(u,x)>dis(s,t)$\n\n\u4e00\u5f20\u597d\u770b\u7684\u56fe\uff08\u96fe\n\n![](https://s2.ax1x.com/2019/03/27/AdNDN6.png)\n\ncode\uff1a\n\n```cpp\n#include <map>\n#include <set>\n#include <cmath>\n#include <queue>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <list>\n#define inl inline\n#define re register int\n#define ll long long\n#define fa(x) t[x].fa\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define lowbit(x) ((x) & (-x))\nconst int inf = 0x7fffffff;\nusing namespace std;\ntemplate < class Read >\ninl Read read() {\n\tRead x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\nstruct link_cut_tree {\n\tstruct node {\n\t\tint child[2], fa, w, size;\n\t\tbool filp;\n\t} t[1000001];\n\tinl void upd(int x) {\n\t\tt[x].size = t[ls(x)].size + t[rs(x)].size + 1;\n\t}\n\tinl void reverse(int x) {\n\t\tswap(ls(x), rs(x));\n\t\tt[x].filp ^= 1;\n\t}\n\tinl void pushdown(int x) {\n\t\tif (t[x].filp) {\n\t\t\tif (ls(x))reverse(ls(x));\n\t\t\tif (rs(x))reverse(rs(x));\n\t\t\tt[x].filp = 0;\n\t\t}\n\t}\n\tinl bool poi(int x) {\n\t\treturn rs(fa(x)) == x;\n\t}\n\tinl bool nroot(int x) {\n\t\treturn ls(fa(x)) == x || rs(fa(x)) == x;\n\t}\n\tinl void rotate(int x) {\n\t\tint f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];\n\t\tif (nroot(f))t[gf].child[gfs] = x;\n\t\tt[f].child[fs] = s, t[x].child[fs ^ 1] = f;\n\t\tfa(x) = gf, fa(f) = x;\n\t\tif (s)fa(s) = f;\n\t\tupd(f);\n\t}\n\tinl void push(int x) {\n\t\tif (nroot(x))push(fa(x));\n\t\tpushdown(x);\n\t}\n\tinl void splay(int x) {\n\t\tpush(x);\n\t\twhile (nroot(x)) {\n\t\t\tif (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);\n\t\t\trotate(x);\n\t\t}\n\t\tupd(x);\n\t}\n\tinl void access(int x) {\n\t\tfor (re i = 0; x; x = t[i = x].fa) {\n\t\t\tsplay(x), rs(x) = i, upd(x);\n\t\t}\n\t}\n\tinl void makeroot(int x) {\n\t\taccess(x), splay(x), reverse(x);\n\t}\n\tinl void split(int x, int y) {\n\t\tmakeroot(y), access(x), splay(x);\n\t}\n\tinl void link(int x, int y) {\n\t\tif (!x || !y || x == y)return;\n\t\tsplit(x, y);\n\t\tt[y].fa = x;\n\t}\n\tinl void cut(int x, int y) {\n\t\tif (!x || !y || x == y)return;\n\t\tsplit(x, y);\n\t\tif (t[x].size <= 2)ls(x) = fa(y) = 0;\n\t}\n\tstruct diameter {\n\t\tint x, y, w;\n\t}d[1000001];\n\tint fa[1000001];\n\tinl int find(int x) {\n\t\tif (fa[x] != x)return fa[x] = find(fa[x]);\n\t\treturn x;\n\t}\n\tinl int query(int x, int y) {\n\t\tsplit(x, y);\n\t\treturn t[x].size - 1;\n\t}\n\tinl void merge(int x, int y) {\n\t\tlink(x, y);\n\t\ty = find(y), fa[x] = y;\n\t\tre a = x, b = d[y].x, c = d[y].y, maxn = d[y].w, tmp = query(a, b);\n\t\tif (tmp > maxn)maxn = tmp, d[y].x = a, d[y].y = b;\n\t\ttmp = query(a, c);\n\t\tif (tmp > maxn)maxn = tmp, d[y].x = a, d[y].y = c;\n\t\ttmp = query(b, c);\n\t\tif (tmp > maxn)maxn = tmp, d[y].x = b, d[y].y = c;\n\t\td[y].w = maxn;\n\t}\n\tinl int spread() {\n\t\tchar c = getchar();\n\t\twhile (c != 'Q'&&c != 'B') c = getchar();\n\t\treturn c == 'Q' ? 0 : 1;\n\t}\n\tinl void work(void) {\n\t\tre m = read<int>(), n = 0, op, x, y;\n\t\twhile (m--) {\n\t\t\top = spread();\n\t\t\tif (op) {\n\t\t\t\tx = ++n, y = read<int>();\n\t\t\t\td[x].x = x, d[x].y = x, fa[x] = x;\n\t\t\t\tif (~y)merge(x, y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = read<int>(), y = find(x);\n\t\t\t\tprintf(\"%d\\n\", max(query(x, d[y].x), query(x, d[y].y)));\n\t\t\t}\n\t\t}\n\t}\n}lct;\nsigned main() {\n\tlct.work();\n\treturn 0;\n}\n```\n\n",
        "postTime": 1553695293,
        "uid": 110271,
        "name": "Genius_Z",
        "ccfLevel": 0,
        "title": "P4271 \u52a8\u6001\u7ef4\u62a4\u6811\u76f4\u5f84"
    },
    {
        "content": "\u5927\u6982\u9898\u610f\u5c31\u662f\u5408\u5e76\u4e24\u4e2a\u8fde\u901a\u5757\uff0c \u67e5\u8be2\u8fde\u901a\u5757\u5185\u70b9\u5230\u5176\u4ed6\u70b9\u7684\u6700\u5927\u8ddd\u79bb\u3002\n\n\u6ce8\u610f\u5230\u5bf9\u4e8e\u4e00\u4e2a\u70b9\uff0c \u5728\u5176\u8fde\u901a\u5757\u5185\u4e0e\u5176\u8ddd\u79bb\u6700\u5927\u7684\u70b9\u4e00\u5b9a\u4e3a\u76f4\u5f84\u6240\u5728\u4e24\u70b9\u7684\u4e00\u70b9\uff0c \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5728\u5408\u5e76\u8fde\u901a\u5757\u7684\u65f6\u5019\u987a\u5e26\u7ef4\u62a4\u76f4\u5f84\u6240\u5728\u7684\u4e24\u4e2a\u70b9\u3002 \u5f53\u7136\u8fd9\u4e24\u4e2a\u70b9\u4e5f\u4e00\u5b9a\u662f\u539f\u6765\u56db\u4e2a\u70b9\u4e2d\u7684\u4e24\u4e2a\uff0c \u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u6c42\u51fa\u4e24\u4e24\u4e4b\u95f4\u8ddd\u79bb\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u8fd9\u9053\u9898\u66f4\u7b80\u5355\uff0c \u56e0\u4e3a\u6bcf\u6b21\u53ea\u6709\u4e00\u4e2a\u70b9\u548c\u4e00\u4e2a\u8fde\u901a\u5757\u5408\u5e76\uff0c \u6240\u4ee5\u76f4\u63a5\u6c42\u4e24\u6b21\u8ddd\u79bb\u5373\u53ef\u3002\n\n\u600e\u4e48\u6c42\u8ddd\u79bb\uff1f\u53ef\u4ee5\u500d\u589eLCA\u52a8\u6001\u63d2\u5165\uff0c \u4f46\u662fLCT\u5927\u6cd5\u597d\uff01\uff01\n\n\u6bcf\u4e2a\u70b9\u7684\u6743\u503c\u8bbe\u4e3a1\uff0csplit\u540e\u4e0a\u9762\u90a3\u4e2a\u70b9\u7684sum-1\u5373\u4e3a\u8ddd\u79bb...\n\n\u603b\u590d\u6742\u5ea6O(Nlog(N))\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <algorithm>\n#define R register\n#define IN inline\n#define gc getchar()\n#define W while\n#define dad tree[now].fat\n#define ls tree[now].son[0]\n#define rs tree[now].son[1]\n#define MX 100050\nint q, top, arr;\nint bel[MX], sta[MX], dis[MX];\nstruct Bound\n{int a, b;}bd[MX];\nstruct Node\n{\n    int son[2], fat, sum;\n    bool rev;\n}tree[MX];\nnamespace DSU\n{\n    void reset()\n    {\n        for (R int i = 1; i <= q; ++i)\n        bel[i] = i, tree[i].sum = 1, bd[i] = {i, i};\n    }\n    int find(const int &now) {return now == bel[now] ? now : bel[now] = find(bel[now]);}\n}\nnamespace LCT\n{\n    IN bool get(const int &now) {return tree[dad].son[1] == now;}\n    IN bool nroot(const int &now) {return tree[dad].son[1] == now || tree[dad].son[0] == now;}\n    IN void pushup(const int &now) {tree[now].sum = tree[ls].sum + tree[rs].sum + 1;}\n    IN void pushrev(const int &now) {std::swap(ls, rs), tree[now].rev ^= 1;}\n    IN void pushdown(const int &now) {if(tree[now].rev) tree[now].rev = false, pushrev(ls), pushrev(rs);}\n    IN void rotate(const int &now)\n    {\n        R bool dir = get(now);\n        R int fa = dad, grand = tree[fa].fat;\n        tree[fa].son[dir] = tree[now].son[dir ^ 1];\n        tree[tree[now].son[dir ^ 1]].fat = fa;\n        if(nroot(fa)) tree[grand].son[get(fa)] = now;\n        tree[now].fat = grand;\n        tree[now].son[dir ^ 1] = fa;\n        tree[fa].fat = now;\n        pushup(fa);\n    }\n    IN void splay(R int now)\n    {\n        int tmp = now, fa;\n        sta[top = 1] = now;\n        W (nroot(now)) sta[++top] = now = dad;\n        W (top) pushdown(sta[top--]);\n        now = tmp;\n        W (nroot(now))\n        {\n            fa = dad;\n            if(nroot(fa)) rotate(get(now) == get(fa) ? fa : now);\n            rotate(now);\n        }\n        pushup(now);\n    }\n    IN void access(R int now)\n    {\n        for (R int x = 0; now; x = now, now = dad)\n        {splay(now); rs = x; pushup(now);}\n    }\n    IN void makeroot(const int &now)\n    {access(now), splay(now), pushrev(now);}\n    IN void link(const int &x, const int &y)\n    {makeroot(x); tree[x].fat = y;}\n    IN void split(const int &x, const int &y)\n    {makeroot(x); access(y); splay(y);}\n}\nint main(void)\n{\n    scanf(\"%d\", &q); DSU::reset();\n    char buf[3]; int a, tar, mx1, mx2;\n    W (q--)\n    {\n        scanf(\"%s%d\", buf, &a);\n        if(buf[0] == 'B')\n        {\n            ++arr;\n            if(a == -1) continue;\n            else\n            {\n                tar = DSU::find(a);\n                LCT::link(arr, a);\n                bel[arr] = tar;\n                LCT::split(arr, bd[tar].a);\n                mx1 = tree[bd[tar].a].sum - 1;\n                LCT::split(arr, bd[tar].b);\n                mx2 = tree[bd[tar].b].sum - 1;\n                if(mx1 > dis[tar]) dis[tar] = mx1, bd[tar] = {arr, bd[tar].a};\n                if(mx2 > dis[tar]) dis[tar] = mx2, bd[tar] = {arr, bd[tar].b};\n            }\n        }\n        else\n        {\n            tar = DSU::find(a);\n            LCT::split(a, bd[tar].a);\n            mx1 = tree[bd[tar].a].sum - 1;\n            LCT::split(a, bd[tar].b);\n            mx2 = tree[bd[tar].b].sum - 1;\n            printf(\"%d\\n\", std::max(mx1, mx2));\n        }\n    }\n}\n```",
        "postTime": 1532356188,
        "uid": 67492,
        "name": "LPA20020220",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4271 \u3010[USACO18FEB]New Barns\u3011"
    },
    {
        "content": "~~\u6c34\u8fc7~~~\n\n\u52a8\u6001\u70b9\u5206\u6cbb\uff1fLCT\uff1f~~\u90fd\u4e0d\u4f1a~~\n\n**\u89e3\u6cd5\uff1aLCA \u6811\u7684\u76f4\u5f84**\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\u7ef4\u62a4\u76f4\u5f84\u7684\u5de6\u53f3\u7aef\u70b9\n\n\u4e0b\u6b21\u8f93\u5165\u7684\u65f6\u5019\u53ea\u9700\u67e5\u770b\u8981\u4e0d\u8981\u66f4\u65b0\u7aef\u70b9\n\n```cpp\nint dis1=lca(top,tree[o].l),dis2=lca(tree[o].l,tree[o].r);\nif(dis1>dis2)   tree[o].r=top;\nint dis3=lca(top,tree[o].r);\nif(dis3>dis2)   tree[o].l=top;\n```\n\n\u4ee5\u4e0a\u4ee3\u7801~~\u5f88~~\u5bb9\u6613\u9519\n\n\u8981\u6ce8\u610fdis3 \u4e00\u5b9a\u8981\u653e\u5728\u8fd9\u91cc \u4e0d\u8981else\uff01\n\n\u5982\u679c\u8981\u786e\u5b9a\u6bcf\u4e00\u4e2a\u70b9\u5728\u90a3\u4e2a\u76f4\u5f84\u4e0a\uff08\u4e00\u68f5\u6811\u6709\u591a\u6761\u76f4\u5f84\n\n**\u4e0d\u8981\u7528\u7c7b\u4f3c\u5e76\u67e5\u96c6\u4f3c\u7684\u67e5\u627efather** ~~\u6216\u8bb8\u53ea\u6709\u6211\u8fd9\u4e48\u83dc\u624d\u8fd9\u6837\u5199\u5427~~\n\n\u4f1a\u88ab\u5361\u5e38 \u76f4\u63a5\u7528group\u6570\u7ec4\u8bb0\u5f55\u4e00\u4e0b\u5c31\u53ef\u4ee5\n\n\u8f93\u51fa\u76f4\u63a5\u6c42\u8fd9\u4e2a\u70b9\u5230\u4e24\u4e2a\u7aef\u70b9\u7684\u8ddd\u79bb\n\n**\u8ddd\u79bb\u7528LCA\u6c42 \u8981\u500d\u589e\u7684\u90a3\u79cd\uff01**\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<queue> \n#define MAXN 100005\n#define LL long long\n#define INF 2147483640\n#define MOD 100000007\n#define free(s) freopen(\"s.txt\",\"r\",stdin);\n#define lowbit(x) ((x&(-x))) \nusing namespace std;\nconst int L=1e5+5;\nstruct node{\n    int l,r;\n};\nnode tree[L];\nint n,top,deep[L],fa[L][17],group[L];\nint lca(int x,int y)\n{\n    int dis=0,k;\n    if(deep[x]>deep[y])\n        swap(x,y);\n    for(int i=deep[y]-deep[x],j=0;i>0;i>>=1,j++)\n    \tif(i&1)\n    \t{\n    \t\tdis+=pow(2,j);\n   \t \t\ty=fa[y][j];\n  \t  \t}\n    if(x==y)\n    \treturn dis;\n    for(k=0;(1<<k)<=deep[x];k++);\n    for(;k>=0;k--)\n    \tif((1<<k)<=deep[x]&&fa[x][k]!=fa[y][k])\n    \t{\n    \t\tdis+=pow(2,k+1);\n    \t\tx=fa[x][k];\n    \t\ty=fa[y][k];\n    \t}\n    return dis+2;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        int t;\n        char c;\n        cin>>c>>t;\n        if(c=='Q')\n        {\n            int a1=group[t],a2=lca(t,tree[a1].l),a3=lca(t,tree[a1].r);\n            printf(\"%d\\n\",max(a2,a3));\n        }\n        else\n        {\n            ++top;\n            if(t==-1)\n            {\n                group[top]=top;\n                deep[top]=0;\n                fa[top][0]=top;\n                tree[top].l=tree[top].r=top;\n                continue;\n            }\n            fa[top][0]=t;\n            deep[top]=deep[t]+1;\n            group[top]=group[t];\n    \t\tfor(int i=1;(1<<i)<=deep[top];i++)\n        \t\tfa[top][i]=fa[fa[top][i-1]][i-1];\n        \tint o=group[t];\n            int dis1=lca(top,tree[o].l),dis2=lca(tree[o].l,tree[o].r);\n            if(dis1>dis2)\n                tree[o].r=top;\n            int dis3=lca(top,tree[o].r);\n                if(dis3>dis2)\n                    tree[o].l=top;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1526519479,
        "uid": 37427,
        "name": "\u66f9\u8001\u5e08",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4271 \u3010[USACO18FEB]New Barns\u3011"
    },
    {
        "content": "### \u9898\u610f\n\n\u7ed9\u4e00\u4e2a\u4e00\u5f00\u59cb\u6ca1\u6709\u70b9\u7684\u56fe\uff0c\u6709 $q$ \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u4e3a\u52a0\u70b9\u8fde\u8fb9\u6216\u8005\u67e5\u8be2\u4e00\u4e2a\u70b9\u5230\u8fde\u901a\u5757\u5185\u6240\u6709\u70b9\u7684\u8ddd\u79bb\u6700\u5927\u503c\u3002\n\n$\\texttt{Data Range}:1\\leq q\\leq 10^5$\n\n### \u9898\u89e3\n\n[\u4e0d\u4e00\u5b9a\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://www.cnblogs.com/Karry5307/p/13812799.html)\n\n\u8ddf[\u300c\u96c5\u793c\u96c6\u8bad 2017 Day5\u300d\u8fdc\u884c](https://loj.ac/problem/6038)\u5f88\u50cf\u7684\u4e00\u4e2a\u9898\uff0c\u90fd\u662f LCT \u7ef4\u62a4\u76f4\u5f84\u3002\n\n\u6ce8\u610f\u5230\u6811\u4e0a\u4e00\u4e2a\u70b9\u5230\u5176\u4ed6\u70b9\u7684\u8ddd\u79bb\u6700\u5927\u503c\u53ea\u53ef\u80fd\u5728\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u5904\u53d6\u5230\uff0c\u800c\u4e14\u53c8\u5b58\u5728\u52a0\u8fb9\u64cd\u4f5c\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 LCT \u6765\u7ef4\u62a4\u3002\n\n\u5f53\u5408\u5e76\u4e24\u4e2a\u8fde\u901a\u5757\u7684\u65f6\u5019\u9700\u8981\u5728\u4e24\u4e2a\u8fde\u901a\u5757\u5404\u81ea\u7684\u76f4\u5f84\u7aef\u70b9\u4e2d\u9009\u4e24\u4e2a\u6210\u4e3a\u65b0\u7684\u76f4\u5f84\uff0c\u9700\u8981\u8ba8\u8bba $6$ \u79cd\u60c5\u51b5\uff0c\u8fd9\u4e2a\u66b4\u529b\u641e\u5c31\u884c\u4e86\u3002\n\n\u4f46\u662f\u8fd9\u4e2a\u9898\u4e0d\u7528\u8fd9\u4e48\u9ebb\u70e6\u3002\u56e0\u4e3a\u6bcf\u4e00\u6b21\u5408\u5e76\u7684\u4e00\u8fb9\u662f\u4e00\u4e2a\u70b9\uff0c\u6240\u4ee5\u53ea\u9700\u8981\u8ba8\u8bba\u4e24\u6b21\u5c31\u597d\u4e86\u3002\n\n\u540c\u65f6\uff0c\u7ef4\u62a4\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u548c\u76f4\u5f84\u7684\u8ddd\u79bb\u53ef\u4ee5\u4f7f\u7528\u5e76\u67e5\u96c6\u6765\u7ef4\u62a4\uff0c\u67e5\u8be2\u4e24\u70b9\u8ddd\u79bb\u7684\u8bdd\u5c31\u5148 `split` \u628a\u4e24\u4e2a\u70b9\u7684\u8def\u5f84\u62c9\u51fa\u6765\u653e\u5230\u540c\u4e00\u4e2a Splay \u4e0a\uff0c\u518d\u7528\u6839\u8282\u70b9\u7684\u5927\u5c0f\u51cf $1$ \u5373\u53ef\u3002\n\n### \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef long long int li;\nconst ll MAXN=3e5+51;\nll n,c,d,x,fx,fy,mx,lx,rx;\nchar op;\nll ffa[MAXN],l[MAXN],r[MAXN],dist[MAXN];\ninline ll read()\n{\n    register ll num=0,neg=1;\n    register char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')\n\t{\n\t    ch=getchar();\n\t}\n    if(ch=='-')\n\t{\n\t    neg=-1;\n\t    ch=getchar();\n\t}\n    while(isdigit(ch))\n\t{\n\t    num=(num<<3)+(num<<1)+(ch-'0');\n\t    ch=getchar();\n\t}\n    return num*neg;\n}\ninline ll find(ll x)\n{\n\treturn x==ffa[x]?x:ffa[x]=find(ffa[x]);\n}\nnamespace LCT{\n    struct Node{\n\t    ll fa,rv,sz;\n\t    ll ch[2];\n\t};\n    struct LinkCutTree{\n\t    Node nd[MAXN];\n\t\tll st[MAXN];\n\t\t#define ls nd[x].ch[0]\n\t\t#define rs nd[x].ch[1]\n\t\tinline bool nroot(ll x)\n\t\t{\n\t\t\treturn nd[nd[x].fa].ch[0]==x||nd[nd[x].fa].ch[1]==x;\n\t\t}\n\t\tinline void update(ll x)\n\t\t{\n\t\t\tnd[x].sz=nd[ls].sz+nd[rs].sz+1;\n\t\t}\n\t\tinline void reverse(ll x)\n\t\t{\n\t\t\tswap(ls,rs),nd[x].rv^=1;\n\t\t}\n\t\tinline void spread(ll x)\n\t\t{\n\t\t\tif(nd[x].rv)\n\t\t\t{\n\t\t\t\tls?reverse(ls):(void)1,rs?reverse(rs):(void)1;\n\t\t\t\tnd[x].rv=0;\n\t\t\t}\n\t\t}\n\t\tinline void rotate(ll x)\n\t\t{\n\t\t\tll fa=nd[x].fa,gfa=nd[fa].fa;\n\t\t\tll dir=nd[fa].ch[1]==x,son=nd[x].ch[!dir];\n\t\t\tif(nroot(fa))\n\t\t\t{\n\t\t\t\tnd[gfa].ch[nd[gfa].ch[1]==fa]=x;\n\t\t\t}\n\t\t\tnd[x].ch[!dir]=fa,nd[fa].ch[dir]=son;\n\t\t\tif(son)\n\t\t\t{\n\t\t\t\tnd[son].fa=fa;\n\t\t\t}\n\t\t\tnd[fa].fa=x,nd[x].fa=gfa,update(fa);\n\t\t}\n\t\tinline void splay(ll x)\n\t\t{\n\t\t\tll fa=x,gfa,cur=0;\n\t\t\tst[++cur]=fa;\n\t\t\twhile(nroot(fa))\n\t\t\t{\n\t\t\t\tst[++cur]=fa=nd[fa].fa;\n\t\t\t}\n\t\t\twhile(cur)\n\t\t\t{\n\t\t\t\tspread(st[cur--]);\n\t\t\t}\n\t\t\twhile(nroot(x))\n\t\t\t{\n\t\t\t\tfa=nd[x].fa,gfa=nd[fa].fa;\n\t\t\t\tif(nroot(fa))\n\t\t\t\t{\n\t\t\t\t\trotate((nd[fa].ch[0]==x)^(nd[gfa].ch[0]==fa)?x:fa);\n\t\t\t\t}\n\t\t\t\trotate(x);\n\t\t\t}\n\t\t\tupdate(x);\n\t\t}\n\t\tinline void access(ll x)\n\t\t{\n\t\t\tfor(register int i=0;x;x=nd[i=x].fa)\n\t\t\t{\n\t\t\t\tsplay(x),rs=i,update(x);\n\t\t\t}\n\t\t}\n\t\tinline void makeRoot(ll x)\n\t\t{\n\t\t\taccess(x),splay(x),reverse(x);\n\t\t}\n\t\tinline ll findRoot(ll x)\n\t\t{\n\t\t\taccess(x),splay(x);\n\t\t\twhile(ls)\n\t\t\t{\n\t\t\t\tspread(x),x=ls;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\tinline void split(ll x,ll y)\n\t\t{\n\t\t\tmakeRoot(x),access(y),splay(y);\n\t\t}\n\t\tinline void link(ll x,ll y)\n\t\t{\n\t\t\tmakeRoot(x);\n\t\t\tif(findRoot(y)!=x)\n\t\t\t{\n\t\t\t\tnd[x].fa=y;\n\t\t\t}\n\t\t}\n\t\t#undef ls\n\t\t#undef rs\n\t};\n}\nLCT::LinkCutTree lct;\ninline ll getDist(ll x,ll y)\n{\n\tlct.split(x,y);\n\treturn lct.nd[y].sz-1;\t\n}\nint main()\n{\n\tn=read();\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\tffa[i]=l[i]=r[i]=i,lct.nd[i].sz=1;\n\t}\n\tfor(register int i=0;i<n;i++)\n\t{\n\t\tcin>>op,x=read();\n\t\tif(op=='B')\n\t\t{\n\t\t\t++c;\n\t\t\tif(x==-1)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfx=c,fy=find(x),mx=dist[fx],lx=l[fx],rx=r[fx];\n\t\t\tif(mx<dist[fy])\n\t\t\t{\n\t\t\t\tlx=l[fy],rx=r[fy],mx=dist[fy];\n\t\t\t}\n\t\t\tlct.link(c,x);\n\t\t\tif((d=getDist(l[fx],l[fy]))>mx)\n\t\t\t{\n\t\t\t\tmx=d,lx=l[fx],rx=l[fy];\n\t\t\t}\n\t\t\tif((d=getDist(l[fx],r[fy]))>mx)\n\t\t\t{\n\t\t\t\tmx=d,lx=l[fx],rx=r[fy];\n\t\t\t}\n\t\t\tl[fx]=lx,r[fx]=rx,dist[fx]=mx,ffa[fy]=fx;\n\t\t}\n\t\tif(op=='Q')\n\t\t{\n\t\t\tfx=find(x);\n\t\t\tprintf(\"%d\\n\",max(getDist(x,l[fx]),getDist(x,r[fx])));\n\t\t}\n\t}\n}\n```",
        "postTime": 1602636618,
        "uid": 60990,
        "name": "Karry5307",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4271 \u3010[USACO18FEB]New Barns P\u3011"
    },
    {
        "content": "\u4e3a\u4e86\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\uff0c\u4f60\u53ef\u4ee5\u524d\u5f80[\u6211\u7684\u535a\u5ba2](http://zhylj.cc/index.php/archives/14/).\n\n## \u5206\u6790\n\n\u8fd9\u662f\u4e00\u4e2a\u79bb\u7ebf\u505a\u6cd5\uff0c\u6211\u4eec\u5148\u628a\u6700\u7ec8\u7684\u68ee\u6797\u7ed9\u5efa\u51fa\u6765\u3002\n\n\u6211\u4eec\u8003\u8651\u5bf9\u4e8e\u4e00\u4e2a\u5bf9\u70b9 $u$ \u7684\u8be2\u95ee\uff0c\u53ef\u80fd\u5bf9\u5b83\u4ea7\u751f\u8d21\u732e\u7684\u70b9\u5fc5\u7136\u8981\u6ee1\u8db3\uff1a\u5176\u5230 $u$ \u8fd9\u6761\u8def\u5f84\u4e0a\u6240\u6709\u8fb9\u51fa\u73b0\u65f6\u95f4\u7684\u6700\u5927\u503c\u4e0d\u8d85\u8fc7\u8fd9\u4e2a\u8be2\u95ee\u6240\u5728\u7684\u65f6\u95f4\u3002\n\n\u53ef\u4ee5\u53d1\u73b0\u8fd9\u662f\u4e2a\u7b80\u5355\u7684\u5173\u4e8e\u8def\u5f84\u7684\u504f\u5e8f\u95ee\u9898\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u70b9\u5206\u6cbb\uff0c\u6bcf\u6b21\u8ba1\u7b97\u6240\u6709\u7ecf\u8fc7\u6839\u7684\u8def\u5f84\uff0c\u5904\u7406 $\\operatorname {tmx}_i$ \u8868\u793a $i$ \u5230\u6839\u7684\u8def\u5f84\u4e0a\u51fa\u73b0\u65f6\u95f4\u6700\u665a\u7684\u8fb9\u4ee5\u53ca $d_i$ \u8868\u793a $i$ \u7684\u6df1\u5ea6\uff0c\u6b63\u53cd\u626b\u4e24\u8fb9\u6240\u6709\u5b50\u6811\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u4e00\u4e0b\uff08\u4e0b\u6807\u4e3a\u51fa\u73b0\u65f6\u95f4\u7684\uff09\u524d\u7f00\u6700\u5927\u503c\u5c31\u597d\u4e86\u3002\n\n\u6700\u540e\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal O(n\\log^2n)$ \u7684\u3002\n\n## \u4ee3\u7801\n\n```cpp\nconst int kN = 1e5 + 5, kInf = 0x3f3f3f3f;\n\nint n, q, t[kN], ans[kN];\nstd::vector <int> Q[kN], E[kN];\n\nvoid Add(int u, int v) {\n\tE[u].push_back(v);\n\tE[v].push_back(u);\n}\n\nint tr[kN];\nvoid Modify(int o, int v) {\n\tfor(; o <= q; o += o & -o)\n\t\ttr[o] = std::max(tr[o], v);\n}\nint Query(int o) {\n\tint ret = 0;\n\tfor(; o; o -= o & -o)\n\t\tret = std::max(ret, tr[o]);\n\treturn ret;\n}\nvoid Clear(int o) {\n\tfor(; o <= q; o += o & -o)\n\t\ttr[o] = 0;\n}\n\nint siz[kN]; bool vis[kN];\nvoid GetRoot(int u, int tot, int &rt, int &rt_mn_siz) {\n\tvis[u] = true;\n\tint mx_siz = 0; siz[u] = 1;\n\tfor(auto v : E[u]) if(!vis[v]) {\n\t\tvis[v] = true; GetRoot(v, tot, rt, rt_mn_siz);\n\t\tsiz[u] += siz[v]; mx_siz = std::max(mx_siz, siz[v]);\n\t}\n\tmx_siz = std::max(mx_siz, tot - siz[u]);\n\tif(mx_siz < rt_mn_siz) rt = u, rt_mn_siz = mx_siz;\n\tvis[u] = false;\n}\n\nint d[kN], t_mx[kN];\nvoid GetQuery(int u, int p) {\n\tvis[u] = true;\n\td[u] = d[p] + 1; siz[u] = 1;\n\tt_mx[u] = std::max(t[u], t_mx[p]);\n\tfor(auto x : Q[u]) {\n\t\tif(t_mx[u] <= x)\n\t\t\tans[x] = std::max(ans[x], d[u] + Query(x));\n\t}\n\tfor(auto v : E[u]) if(!vis[v]) {\n\t\tGetQuery(v, u);\n\t}\n\tvis[u] = false;\n}\nvoid GetDep(int u, int p) {\n\tvis[u] = true;\n\td[u] = d[p] + 1; siz[u] = 1;\n\tt_mx[u] = std::max(t[u], t_mx[p]);\n\tModify(t_mx[u], d[u]);\n\tfor(auto v : E[u]) if(!vis[v]) {\n\t\tGetDep(v, u);\n\t\tsiz[u] += siz[v];\n\t}\n\tvis[u] = false;\n}\nvoid Init(int u) {\n\tvis[u] = true; Clear(t_mx[u]);\n\tfor(auto v : E[u]) if(!vis[v])\n\t\tInit(v);\n\tvis[u] = false;\n}\nvoid Div(int u, int tot) {\n\tint rt = 0, rt_mn_siz = kInf;\n\tGetRoot(u, tot, rt, rt_mn_siz);\n\td[rt] = 0; t_mx[rt] = t[rt]; vis[rt] = true;\n\tfor(auto v : E[rt]) if(!vis[v]) {\n\t\tGetQuery(v, rt);\n\t\tGetDep(v, rt);\n\t}\n\tfor(auto x : Q[rt])\n\t\tans[x] = std::max(ans[x], Query(x));\n\tfor(auto v : E[rt]) if(!vis[v])\n\t\tInit(v);\n\tstd::reverse(E[rt].begin(), E[rt].end());\n\tfor(auto v : E[rt]) if(!vis[v]) {\n\t\tGetQuery(v, rt);\n\t\tGetDep(v, rt);\n\t}\n\tfor(auto v : E[rt]) if(!vis[v])\n\t\tInit(v);\n\tfor(auto v : E[rt]) if(!vis[v])\n\t\tDiv(v, siz[v]);\n}\n\nint dsu_fa[kN], dsu_siz[kN];\nint Find(int x) { return dsu_fa[x] == x ? x : dsu_fa[x] = Find(dsu_fa[x]); }\nvoid Merge(int x, int y) {\n\tint f_x = Find(x), f_y = Find(y);\n\tif(f_x == f_y) return;\n\tdsu_fa[f_x] = f_y; dsu_siz[f_y] += dsu_siz[f_x];\n}\n\nint main() { \n\tint T = 1; //rd(T);\n\twhile(T--) {\n\t\tmemset(ans, ~0x3f, sizeof(ans));\n\t\trd(q);\n\t\tfor(int i = 1; i <= q; ++i)\n\t\t\tdsu_fa[i] = i, dsu_siz[i] = 1;\n\t\tfor(int i = 1; i <= q; ++i)  {\n\t\t\tchar opt[5]; int x;\n\t\t\tscanf(\"%s\", opt + 1); rd(x);\n\t\t\tif(opt[1] == 'B') {\n\t\t\t\tt[++n] = i;\n\t\t\t\tif(~x) {\n\t\t\t\t\tAdd(n, x);\n\t\t\t\t\tMerge(n, x);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tQ[x].push_back(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; ++i) if(dsu_fa[i] == i) {\n\t\t\tDiv(i, dsu_siz[i]);\n\t\t}\n\t\tfor(int i = 1; i <= q; ++i) {\n\t\t\tif(ans[i] >= 0) printf(\"%d\\n\", ans[i]);\n\t\t}\n\t} return 0;\n}\n```\n",
        "postTime": 1612404021,
        "uid": 34238,
        "name": "zhylj",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4271 \u3010[USACO18FEB]New Barns P\u3011"
    },
    {
        "content": "## \u3010BZOJ5192\u3011\u3010\u6d1b\u8c37P4271\u3011New Barns\n\n[\u6d1b\u8c37\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P4271)\n\n### \u9898\u76ee\u5927\u610f\uff1a\u5df2\u7ecf\u6bd4BZOJ\u7684\u9898\u610f\u7b80\u5355\u5f88\u591a\u4e86....\n\n\n\n### \u9898\u89e3\n\n\u663e\u7136\u8fd9\u59cb\u7ec8\u662f\u4e00\u4e2a\u6811\u5f62\u7ed3\u6784\uff0c\u56e0\u4e3a\u6bcf\u4e2a\u70b9\u8981\u4e48\u6ca1\u6709Father\u8fb9\uff0c\u8981\u4e48\u6709\u4e00\u6761\u8fde\u5411\u7f16\u53f7\u5c0f\u4e8e\u81ea\u5df1\u7684\u8fb9\u3002\u4e0d\u96be\u60f3\u5230\uff0c\u7528\u6811\u94fe\u5256\u5206\u6216\u8005\u662f\u500d\u589e\u6570\u7ec4\u6765\u7ef4\u62a4\u6811\u4e0a\u4fe1\u606f\u3002\u9898\u76ee\u7684\u6240\u6c42\u662f\u591a\u6b21\u8be2\u95ee\u8ddd\u79bb\u67d0\u4e2a\u70b9\u6700\u8fdc\u7684\u70b9\u7684\u8ddd\u79bb\u3002\n\n#### \u7ed3\u8bba\u4e00 \uff1a \u8ddd\u79bb\u67d0\u4e2a\u70b9\u6700\u8fdc\u7684\u70b9\uff0c\u80af\u5b9a\u6709\u4e00\u4e2a\u662f\u6240\u5728\u6811\u7684\u76f4\u5f84\u7684\u7aef\u70b9\u3002\n\u6240\u4ee5\uff0c\u5982\u679c\u6211\u4eec\u80fd\u591f\u5b9e\u65f6\u7ef4\u62a4\u6811\u7684\u76f4\u5f84\uff0c\u5c31\u80fd\u591f\u5feb\u901f\u6c42\u89e3\u7b54\u6848\u3002\u90a3\u4e48\uff0c\u8fd9\u4e48\u4e00\u9897\u52a8\u6001\u7684\u6811\uff0c\u652f\u6301\u52a0\u5165\u8282\u70b9\u548c\u6811\u4e0a\u8ddd\u79bb\u67e5\u8be2\uff0c\u5c31\u662fLCT\u4e86\u3002\n\n#### \u7ed3\u8bba\u4e8c \uff1a \u5bf9\u4e8e\u4e24\u68f5\u6811\uff0c\u5982\u679c\u7b2c\u4e00\u68f5\u6811\u76f4\u5f84\u4e24\u7aef\u70b9\u4e3a(u,v)(u,v)\uff0c\u7b2c\u4e8c\u68f5\u6811\u76f4\u5f84\u4e24\u7aef\u70b9\u4e3a(x,y)(x,y)\uff0c\u7528\u4e00\u6761\u8fb9\u5c06\u4e24\u68f5\u6811\u8fde\u63a5\uff0c\u90a3\u4e48\u65b0\u6811\u7684\u76f4\u5f84\u4e00\u5b9a\u662fu ,v ,x ,y ,\u4e2d\u7684\u4e24\u4e2a\u70b9\n\n\u660e\u767d\u4e86\u8fd9\u4e2a\u7ed3\u8bba\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7ef4\u62a4\u5408\u5e76\u4e4b\u540e\u7684\u6811\u7684\u76f4\u5f84\u7aef\u70b9\u3002\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u6bcf\u4e2a\u8fde\u901a\u5757\u7684\u6807\u5fd7\u70b9\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u6807\u5fd7\u70b9\u6240\u5728\u8fde\u901a\u5757\u76f4\u5f84\u7684\u4e24\u7aef\u70b9\uff0c\u8fde\u8fb9\u65f6\u5bf9 u , v , x , y \u56db\u70b9\u4e24\u4e24\u6c42\u8ddd\u79bb\u66f4\u65b0\u76f4\u5f84\u4fe1\u606f\u3002\n\n```cpp\n#include<cstdio>\n#define lc(x) son[x][0]\n#define rc(x) son[x][1]\n\nconst int N = 1e5 + 100;\n\ninline int max(int x ,int y){return x < y ? y : x;}\ninline void swap(int &x,int &y){int t = x;x = y , y = t;}\ninline void read(int &x)\n{\n\tint f = x = 0;char c = getchar();\n\twhile(c > '9' || c < '0') (c == '-') && (f = 1) , c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0' , c = getchar();\n\t(f) && (x = -x);\n}\n\nint val[N] , key[N] , fa[N] , Fa[N] , son[N][2] , tipe[N] , r[N] , l[N] , Q , tot;\n\ninline int getfa(int x){return x == Fa[x] ? x : Fa[x] = getfa(Fa[x]);}\n\ninline void update(int x){val[x] = key[x] + val[lc(x)] + val[rc(x)];}\ninline int isrt(int x){return rc(fa[x]) != x && lc(fa[x]) != x;}\ninline int Rela(int x){return rc(fa[x]) == x;}\ninline void flip(int x){tipe[x] ^= 1 , swap(lc(x) , rc(x));}\ninline void down(int x){if(tipe[x]) tipe[x] = 0 , flip(lc(x)) , flip(rc(x));}\ninline void deal(int x){if(!isrt(x)) deal(fa[x]);down(x);}\ninline void Roll(int x)\n{\n\tint f = fa[x] , g = fa[f] , K = Rela(x);\n\tif(!isrt(f)) son[g][Rela(f)] = x;fa[x] = g;\n\tson[f][K] = son[x][K ^ 1] , fa[son[x][K ^ 1]] = f;\n\tson[x][K ^ 1] = f , fa[f] = x , update(f) , update(x);\n}\n\ninline void splay(int x)\n{\n\tfor(deal(x) ; !isrt(x) ; Roll(x))\n\t\tif(!isrt(fa[x])) Roll(Rela(fa[x]) == Rela(x) ? fa[x] : x);\n}\t\n\ninline void access(int x){for(int f = 0 ; x ; f = x , x = fa[x]) splay(x) , rc(x) = f , update(x);}\ninline void makert(int x){access(x) , splay(x) , flip(x);}\ninline void link(int x , int y)\n{\n\tmakert(x) , access(y) , splay(y);\n\tfa[x] = y;\t\n}\ninline int dist(int x , int y)\n{\n\tmakert(x) , access(y) , splay(y);\n\treturn val[y] - 1;\n}\n\nint main()\n{\n\tchar c;read(Q);\n\tfor(int v , len1 , len2 , len3 , t; Q -- ; )\n\t{\n\t\tscanf(\" %c\",&c) , read(v);\n\t\t\n\t\tif(c == 'B')\n\t\t{\n\t\t\t++ tot ,  key[tot] = val[tot] = 1;\n\t\t\tif(v == -1) Fa[tot] = l[tot] = r[tot] = tot;\n\t\t\telse\n\t\t\t{\n\t\t\t\tlink(tot , v) , v = getfa(v) , Fa[tot] = v;\n\t\t\t\tlen1 = dist(tot , l[v]) , len2 = dist(tot , r[v]) , len3 = dist(l[v] , r[v]);\n\t\t\t\tif(len1 >= len2 && len1 >= len3) r[v] = tot;\n\t\t\t\telse if(len2 >= len1 && len2 >= len3) l[v] = tot;  \n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tt = getfa(v) , printf(\"%d\\n\",max(dist(v , l[t]) , dist(v , r[t])));\n\t}\n\t\n\treturn 0;\n}\n```\n\n\n",
        "postTime": 1578403521,
        "uid": 77245,
        "name": "Reaper_gsm",
        "ccfLevel": 0,
        "title": "BZOJ5192"
    },
    {
        "content": "\u7ed9\u51fa\u4e00\u4e2a\u79bb\u7ebf\uff0c\u590d\u6742\u5ea6 $n \\log^2 n$ \u7684\u505a\u6cd5\u3002\n\n\u8003\u8651\u5efa\u51fa\u6240\u6709\u64cd\u4f5c\u7ed3\u675f\u540e\u7684\u68ee\u6797\uff0c\u5e76\u5bf9\u6bcf\u4e2a\u70b9\u6807\u8bb0\u64cd\u4f5c\u52a0\u5165\u7684\u65f6\u95f4\u3002\n\n\u5bf9\u4e8e\u67d0\u4e2a\u70b9\u7684\u67e5\u8be2\uff0c\u5047\u8bbe\u8fd9\u662f\u7b2c $lim$ \u6b21\u64cd\u4f5c\uff0c\u90a3\u4e48\u53ea\u6709\u8fd9\u4e2a\u70b9\u7684\u5b50\u6811\u4e2d\u52a0\u5165\u65f6\u95f4 $\\leq lim$ \u7684\u70b9\u7ec4\u6210\u7684\u8def\u5f84\u662f\u5408\u6cd5\u7684\u3002\n\n\u76f4\u63a5\u70b9\u5206\u6cbb\u5373\u53ef\uff0c\u5728\u6bcf\u4e2a\u5206\u6cbb\u91cd\u5fc3\u5904\u7ef4\u62a4\u4e0b\u8f96\u8303\u56f4\u7684\u6240\u6709\u70b9\u5230\u91cd\u5fc3\u7684\u8ddd\u79bb\u3002\uff08\u4ee5\u5230\u8fbe\u91cd\u5fc3\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6700\u665a\u52a0\u5165\u65f6\u95f4\u4e3a\u4e0b\u6807\uff0c\u7ef4\u62a4\u524d\u7f00\u6700\u5927\uff09\u3002\n\n\u9700\u8981\u8bb0\u5f55\u539f\u6811\u4e0a $x$ \u70b9\u5230\uff08\u70b9\u5206\u6811\u4e0a $x$ \u7684\u524d $k$ \u5c42\u7956\u5148\uff09\u7684\u8def\u5f84\u957f\u548c\u7ecf\u8fc7\u70b9\u7684\u52a0\u5165\u65f6\u95f4\u7684\u6700\u5927\u503c\uff08\u500d\u589e\u7ef4\u62a4\uff09\u3002\n\n\u6ce8\u610f\u53ef\u80fd\u6709\u5206\u6cbb\u91cd\u5fc3\u5904\u7684\u6700\u5927\u503c\u672c\u8eab\u5c31\u662f\u4ece\u9700\u8981\u67e5\u8be2\u7684\u5b50\u6811\uff0c\u6240\u4ee5\u9700\u8981\u8bb0\u5f55\u6700\u5927\u503c\u3001\u6700\u5927\u503c\u7684\u6765\u5411\u5b50\u6811\uff0c\u975e\u6700\u5927\u503c\u6765\u5411\u5b50\u6811\u8d21\u732e\u7684\u6700\u5927\u503c\uff0c\u548c\u524d\u8005\u7684\u6765\u5411\u3002\u5982\u679c\u51b2\u7a81\u5c31\u6362\u6210\u975e\u6700\u5927\u503c\u6765\u5411\u5b50\u6811\u8d21\u732e\u7684\u6700\u5927\u503c\u5373\u53ef\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ntemplate <class T> inline void read(T &x)\n{\n\tx = 0;\n\tint f = 0;\n\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9')\n\t{\n\t\tf |= ch == '-';\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9')\n\t{\n\t\tx = x * 10 + (ch - 48);\n\t\tch = getchar();\n\t}\n\tx = f ? -x : x;\n\treturn;\n}\n#define inf 0x3f3f3f3f\n#define N 100005\nint first[N], Next[N << 1], to[N << 1], tot;\ninline void add(int x, int y)\n{\n\tNext[++tot] = first[x];\n\tfirst[x] = tot;\n\tto[tot] = y;\n\treturn;\n}\nint n, m, ord[N];\nint bel[N], size[N];\nstruct LCA\n{\n\tint dep[N], fa[N][21], maxx[N][21];\n\tvoid dfs(int u, int pre, int col)\n\t{\n\t\tsize[u] = 1;\n\t\tbel[u] = col;\n\t\tfor(int i = first[u]; i; i = Next[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(v == pre)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tfa[v][0] = u;\n\t\t\tmaxx[v][0] = max(ord[u], ord[v]);\n\t\t\tdfs(v, u, col);\n\t\t\tsize[u] += size[v];\n\t\t}\n\t}\n\tinline void init()\n\t{\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\tif(!bel[i])\n\t\t\t{\n\t\t\t\tdep[i] = 1;\n\t\t\t\tdfs(i, 0, i);\n\t\t\t}\n\t\t}\n\t\tfor(int j = 1; j <= 20; j++)\n\t\t{\n\t\t\tfor(int i = 1; i <= n; i++)\n\t\t\t{\n\t\t\t\tfa[i][j] = fa[fa[i][j - 1]][j - 1];\n\t\t\t\tmaxx[i][j] = max(maxx[i][j - 1], maxx[fa[i][j - 1]][j - 1]);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tpair<int, int> lca(int x, int y)\n\t{\n\t\tint retsec = 0;\n\t\tif(dep[x] > dep[y])\n\t\t{\n\t\t\tswap(x, y);\n\t\t}\n\t\tfor(int i = 20; i >= 0; i--)\n\t\t{\n\t\t\tif(dep[fa[y][i]] >= dep[x])\n\t\t\t{\n\t\t\t\tretsec = max(retsec, maxx[y][i]);\n\t\t\t\ty = fa[y][i];\n\t\t\t}\n\t\t}\n\t\tif(x == y)\n\t\t{\n\t\t\treturn make_pair(x, retsec);\n\t\t}\n\t\tfor(int i = 20; i >= 0; i--)\n\t\t{\n\t\t\tif(fa[x][i] != fa[y][i])\n\t\t\t{\n\t\t\t\tretsec = max(retsec, max(maxx[x][i], maxx[y][i]));\n\t\t\t\tx = fa[x][i], y = fa[y][i];\n\t\t\t}\n\t\t}\n\t\tretsec = max(retsec, max(maxx[x][0], maxx[y][0]));\n\t\treturn make_pair(fa[x][0], retsec);\n\t}\n\tpair<int, int> query(int x, int y)\n\t{\n\t\tpair<int, int> lc = lca(x, y);\n\t\treturn make_pair(dep[x] + dep[y] - 2 * dep[lc.first], lc.second);\n\t}\n};\nLCA tree;\nstruct value\n{\n\tint val1, fr1, val2, fr2;\n\tinline void update(pair<int, int> x)\n\t{\n\t\tif(x.first > val1 || (x.first == val1 && x.second != fr1))\n\t\t{\n\t\t\tif(x.second != fr1)\n\t\t\t{\n\t\t\t\tval2 = val1, fr2 = fr1;\n\t\t\t}\n\t\t\tval1 = x.first, fr1 = x.second;\n\t\t}\n\t\telse if(x.first > val2 && x.second != fr1)\n\t\t{\n\t\t\tval2 = x.first, fr2 = x.second;\n\t\t}\n\t\treturn;\n\t}\n\tinline void update(value &x)\n\t{\n\t\tupdate(make_pair(x.val1, x.fr1)), update(make_pair(x.val2, x.fr2));\n\t\treturn;\n\t}\n};\nstruct node\n{\n\tint ord;\n\tvalue val;\n};\nbool operator < (const node &a, const node &b)\n{\n\treturn a.ord < b.ord;\n}\nvector<node> ch[N];\nvalue query(vector<node> &x, int lim)\n{\n\tint pos = upper_bound(x.begin(), x.end(), (node){lim, (value){0, 0, 0, 0}}) - x.begin() - 1;\n\treturn x[pos].val;\n}\nint vis[N], ban[N], sum, root;\nvoid getroot(int u, int pre)\n{\n\tsize[u] = 1, ban[u] = 0;\n\tfor(int i = first[u]; i; i = Next[i])\n\t{\n\t\tint v = to[i];\n\t\tif(v == pre || vis[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tgetroot(v, u);\n\t\tsize[u] += size[v];\n\t\tban[u] = max(ban[u], size[v]);\n\t}\n\tban[u] = max(ban[u], sum - size[u]);\n\tif(ban[u] < ban[root])\n\t{\n\t\troot = u;\n\t}\n\treturn;\n}\nvoid dfs(int u, int pre, int mxord, int dep, vector<node> &ch)\n{\n\tch.emplace_back((node){mxord, (value){dep, root, 0, 0}});\n\tfor(int i = first[u]; i; i = Next[i])\n\t{\n\t\tint v = to[i];\n\t\tif(v == pre || vis[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(v, u, max(mxord, ord[v]), dep + 1, ch);\n\t}\n\treturn;\n}\nint dep[N], fat[N];\nvoid solve(int u)\n{\n\tvis[u] = 1;\n\tch[u].resize(size[u]);\n\tch[u].emplace_back((node){ord[u], (value){0, u, 0, 0}});\n\tfor(int i = first[u]; i; i = Next[i])\n\t{\n\t\tint v = to[i];\n\t\tif(vis[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tsum = size[v];\n\t\tgetroot(v, root = 0);\n\t\tdfs(v, 0, ord[v], 1, ch[u]);\n\t\tfat[root] = u;\n\t\tdep[root] = dep[u] + 1;\n\t\tgetroot(root, 0);\n\t\tsolve(root);\n\t}\n\tsort(ch[u].begin(), ch[u].end());\n\tfor(int i = 1; i < (int)ch[u].size(); i++)\n\t{\n\t\tch[u][i].val.update(ch[u][i - 1].val);\n\t}\n\treturn;\n}\npair<int, int> d[N][21], ques[N];\nint qtot;\nsigned main()\n{\n\tint q;\n\tread(q);\n\tchar opt[2];\n\tint x;\n\tfor(int i = 1; i <= q; i++)\n\t{\n\t\tscanf(\"%s %d\", opt, &x);\n\t\tif(opt[0] == 'B')\n\t\t{\n\t\t\tord[++n] = i;\n\t\t\tif(x != -1)\n\t\t\t{\n\t\t\t\tadd(n, x), add(x, n);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tques[++qtot] = make_pair(x, i);\n\t\t}\n\t}\n\ttree.init();\n\tban[0] = inf;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tif(bel[i] == i)\n\t\t{\n\t\t\tsum = size[i];\n\t\t\tgetroot(i, root = 0);\n\t\t\tdep[root] = 1;\n\t\t\tgetroot(root, 0);\n\t\t\tsolve(root);\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = fat[i]; j; j = fat[j])\n\t\t{\n\t\t\td[i][dep[i] - dep[j]] = tree.query(i, j);\n\t\t}\n\t}\n\tfor(int task = 1; task <= qtot; task++)\n\t{\n\t\tint x = ques[task].first, lim = ques[task].second;\n\t\tvalue ans = query(ch[x], lim);\n\t\tfor(int i = x; fat[i]; i = fat[i])\n\t\t{\n\t\t\tvalue qfa = query(ch[fat[i]], lim);\n\t\t\tif(d[x][dep[x] - dep[fat[i]]].second <= lim)\n\t\t\t{\n\t\t\t\tif(qfa.fr1 == i)\n\t\t\t\t{\n\t\t\t\t\tans.update(make_pair(qfa.val2 + d[x][dep[x] - dep[fat[i]]].first, qfa.fr2));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tans.update(make_pair(qfa.val1 + d[x][dep[x] - dep[fat[i]]].first, qfa.fr1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans.val1);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1640704728,
        "uid": 90027,
        "name": "GG_jok_er",
        "ccfLevel": 0,
        "title": "P4271 [USACO18FEB]New Barns P \u9898\u89e3"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P4271)\n\n> \u6709\u4e00\u68f5\u6811\uff0c\u521d\u59cb\u6ca1\u6709\u8282\u70b9\u3002\u6709 $q$ \u6b21\u64cd\u4f5c\uff0c\u64cd\u4f5c\u5206\u4e24\u79cd\uff1a\n>\n> 1. \u65b0\u5efa\u4e00\u4e2a\u8282\u70b9\uff0c\u5c06\u5b83\u4e0e $p$ \u8282\u70b9\u8fde\u63a5\u3002\uff08\u82e5 $p=-1$\uff0c\u5219\u4e0d\u4e0e\u5176\u5b83\u8282\u70b9\u76f8\u8fde \uff09\n> 2. \u67e5\u8be2\u5728 $k$ \u8282\u70b9\u6240\u5728\u7684\u8fde\u901a\u5757\u4e2d\uff0c\u8ddd\u5b83\u6700\u8fdc\u7684\u70b9\u7684\u8ddd\u79bb\u3002\n>\n> $q \\le 10^5$\u3002\n>\n\n\u6811\u7684\u76f4\u5f84\u5165\u95e8\u9898\u76ee\u3002\n\n\u7ecf\u5178\u7ed3\u8bba\uff1a\u6811\u4e2d\u8ddd\u79bb\u4e00\u4e2a\u8282\u70b9\u6700\u8fdc\u7684\u70b9\u4e00\u5b9a\u662f\u76f4\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u4e4b\u4e00\u3002\u8bc1\u660e\u89c1 [OI Wiki](https://oi-wiki.org/graph/tree-diameter/#\u505a\u6cd5-1-\u4e24\u6b21-dfs)\u3002\n\n\u4e8e\u662f\u6211\u4eec\u53ea\u9700\u8981\u7ef4\u62a4\u6811\u7684\u76f4\u5f84\uff0c\u5148\u628a\u6240\u6709\u64cd\u4f5c\u79bb\u7ebf\u4e0b\u6765\uff0c\u5efa\u51fa\u6700\u7ec8\u7684\u6811\uff0c\u500d\u589e\u6c42 LCA\u3002\u65b0\u52a0\u8282\u70b9\u65f6\u7528\u4e24\u4e2a\u76f4\u5f84\u7aef\u70b9\u5230\u5b83\u7684\u8ddd\u79bb\u66f4\u65b0\u76f4\u5f84\u5373\u53ef\u3002\n\n## Code\n\n```cpp\nint q, n = 0, p[N], fa[N][20], dep[N];\nchar op[N];\nint dis(int x, int y) {\n\tif (dep[x] < dep[y]) swap(x, y);\n\tint X = x, Y = y;\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (fa[X][i] != -1 && dep[fa[X][i]] >= dep[Y]) {\n\t\t\tX = fa[X][i];\n\t\t}\n\t}\n\tif (X == Y) return dep[x] - dep[X];\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (fa[X][i] != -1 && fa[Y][i] != -1 && fa[X][i] != fa[Y][i]) {\n\t\t\tX = fa[X][i];\n\t\t\tY = fa[Y][i];\n\t\t}\n\t}\n\treturn dep[x] - dep[X] + dep[y] - dep[Y] + 2;\n}\nint rt[N], d[N][2], cnt = -1;\nvoid solve() {\n\tcin >> q;\n\trep(i, q) {\n\t\tcin >> op[i] >> p[i];\n\t\tif (p[i] != -1) p[i]--;\n\t\tif (op[i] == 'B') {\n\t\t\tif (p[i] != -1) dep[n] = dep[p[i]] + 1, rt[n] = rt[p[i]];\n\t\t\telse rt[n] = n;\n\t\t\tfa[n++][0] = p[i];\n\t\t}\n\t}\n\trepp(i, 19) {\n\t\trep(j, n) {\n\t\t\tif (fa[j][i - 1] == -1) fa[j][i] = -1;\n\t\t\telse fa[j][i] = fa[fa[j][i - 1]][i - 1];\n\t\t}\n\t}\n\trep(i, q) {\n\t\tif (op[i] == 'B') {\n\t\t\t++cnt;\n\t\t\tif (p[i] ==  -1) d[cnt][0] = d[cnt][1] = cnt;\n\t\t\telse {\n\t\t\t\tint x = d[rt[p[i]]][0], y = d[rt[p[i]]][1];\n\t\t\t\tif (dis(x, cnt) > dis(d[rt[p[i]]][0], d[rt[p[i]]][1])) {\n\t\t\t\t\td[rt[p[i]]][0] = x;\n\t\t\t\t\td[rt[p[i]]][1] = cnt;\n\t\t\t\t}\n\t\t\t\tif (dis(y, cnt) > dis(d[rt[p[i]]][0], d[rt[p[i]]][1])) {\n\t\t\t\t\td[rt[p[i]]][0] = y;\n\t\t\t\t\td[rt[p[i]]][1] = cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint x = d[rt[p[i]]][0], y = d[rt[p[i]]][1];\n\t\t\tcout << max(dis(x, p[i]), dis(y, p[i])) << endl;\n\t\t}\n\t}\n}\n```\n\n",
        "postTime": 1680006023,
        "uid": 407564,
        "name": "Rushroom",
        "ccfLevel": 7,
        "title": "[USACO18FEB]New Barns P"
    }
]