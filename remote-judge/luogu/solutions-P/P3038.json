[
    {
        "content": "Upd On 2020-03-18 \u65e2\u7136\u9898\u5355\u90fd\u51fa\u4e86\u90a3\u4e48\u5c31\u628a\u539f\u6765\u7684\u526a\u8d34\u677f\u6362\u6210\u9898\u5355\u5427qwq  \n\u6b64\u7bc7\u9898\u89e3\u610f\u5728\u63d0\u4f9b\u4e00\u5957\u6811\u94fe\u5256\u5206\u70b9\u6743\u8f6c\u8fb9\u6743\u7684\u677f\u5b50\u3002\n# A Solution For P3038\n\u9700\u8981\u7684\u524d\u7f6e\u829d\u58eb(\u6ca1\u5403\u8fc7\u7684\u8bf7\u52a0\u9910):  \n[\u7ebf\u6bb5\u6811](https://www.luogu.com.cn/problem/P3373)  [\u8f7b\u91cd\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384)  \n\u524d\u7f6e\u829d\u58eb\u6b21\u6389\u4ee5\u540e,\u4f60\u5e94\u8be5\u77e5\u9053\u4e86\u4f7f\u7528\u6811\u94fe\u5256\u5206\u548c\u7ebf\u6bb5\u6811\u7ed3\u5408\u6765\u5904\u7406\u4ee5\u4e0b\u51e0\u79cd\u57fa\u672c\u95ee\u9898:  \n- \u7ef4\u62a4\u6811\u4e0a\u4efb\u610f\u4e24\u70b9\u95f4\u7b80\u5355\u8def\u5f84\u5305\u542b\u7684\u70b9\u7684\u70b9\u6743 \u548c/\u6700\u5927\u503c\n- \u7ef4\u62a4\u6811\u4e0a\u4efb\u610f\u5355\u70b9\u7684\u70b9\u6743\u4fe1\u606f\n- \u7ef4\u62a4\u6811\u4e0a\u4efb\u610f\u4e00\u68f5\u5b50\u6811\u5185\u7684\u70b9\u6743 \u548c/\u6700\u5927\u503c  \n\n\u6838\u5fc3\u601d\u60f3\u662f\u901a\u8fc7\u5256\u5206\u5c06\u5176\u5212\u5206\u6210\u53ef\u7528\u7ebf\u6bb5\u6811\u64cd\u4f5c\u7684\u533a\u95f4,\u518d\u5229\u7528\u7ebf\u6bb5\u6811\u8fdb\u884c\u7ef4\u62a4  \n\u4f46\u662f\u5bf9\u4e8e\u8fd9\u4e00\u9053\u9898\u76ee,\u662f\u8981\u7ef4\u62a4\u6811\u4e0a\u8fb9\u6743\u7684\u76f8\u5173\u4fe1\u606f,\u600e\u4e48\u529e\u5462\uff1f\n\u6211\u4eec\u53ef\u4ee5\u5c06\u8fb9\u6743\u8f6c\u5316\u4e3a\u70b9\u6743\u3002\uff08\u8fd9\u4e2a\u4eba\u53c8\u5728\u8bf4\u5e9f\u8bdd\u4e86\uff09  \n\u4f46\u662f\u600e\u4e48\u8f6c\u5316\uff1f\uff1f  \n\u6211\u4eec\u7684\u8f6c\u5316\u80af\u5b9a\u662f\u8981\u5c06\u8fb9\u6620\u5c04\u5230\u70b9\u4e0a,\u5f88\u660e\u663e\u6211\u4eec\u4e0d\u53ef\u4ee5\u8ba9\u4e00\u4e2a\u70b9\u540c\u65f6\u5bf9\u5e94\u591a\u6761\u8fb9,\u4e5f\u4e0d\u53ef\u4ee5\u8ba9\u4e00\u6761\u8fb9\u5bf9\u5e94\u591a\u4e2a\u70b9,\u8fd9\u4e24\u79cd\u60c5\u51b5\u90fd\u662f\u65e0\u6cd5\u4f7f\u7528\u7ebf\u6bb5\u6811\u8fdb\u884c\u76f8\u5e94\u7ef4\u62a4\u7684  \n\u6240\u4ee5\u53ea\u80fd\u4e00\u5bf9\u4e00\u8fdb\u884c\u6620\u5c04  \n\u753b\u4e00\u68f5\u6811,\u89c2\u5bdf\u4e00\u4e0b,\u5f88\u5feb\u5c31\u53ef\u4ee5\u53d1\u73b0,\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u7684\u4e24\u7aef\u7684\u8282\u70b9,\u6211\u4eec\u53ea\u80fd\u9009\u4e00\u4e2a\u6620\u5c04,\u800c\u6211\u4eec\u4f1a\u9009\u62e9\u6df1\u5ea6\u8f83\u6df1\u7684\u70b9\u8fdb\u884c\u6620\u5c04,\u5426\u5219\u5982\u679c\u8fd9\u4e2a\u6df1\u5ea6\u8f83\u6d45\u7684\u8282\u70b9\u6709\u591a\u4e2a\u513f\u5b50,\u8fd9\u4e9b\u513f\u5b50\u90fd\u4f1a\u6620\u5c04\u5230\u8fd9\u4e2a\u8282\u70b9\u4e0a,GG\u3002  \n\n**\u4e0b\u9762\u7ed9\u51fa\u6811\u94fe\u5256\u5206\u8fb9\u6743\u8f6c\u70b9\u6743\u7684\u6a21\u677f,\u4ee3\u7801\u540e\u4f1a\u6709\u6838\u5fc3\u4ee3\u7801\u603b\u7ed3\u3002**  \n\n\u5305\u542b\u64cd\u4f5c  \n- \u8def\u5f84 \u8be2\u95ee/\u66f4\u65b0(\u8fb9\u6743\u548c)\n- \u5b50\u6811 \u8be2\u95ee/\u66f4\u65b0(\u8fb9\u6743\u548c)  \n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint N,Q; \ninline int max_(const int &x,const int &y)\n{\n\treturn x>y?x:y;\n}\nconst int maxn=2007;//\u603b\u7ed3\u70b9\u6570\nint TREE[maxn<<2];//\u56db\u500d\u7a7a\u95f4\u7ebf\u6bb5\u6811\nint lazy[maxn<<2];//\u61d2\u60f0\u6807\u8bb0\u6570\u7ec4,\u5927\u5c0f\u8981\u5f00\u6210\u4e0e\u7ebf\u6bb5\u6811\u4e00\u4e00\u5bf9\u5e94\nstruct E{\n\tint u,v,w;\n}e[maxn<<1];//\u6811\u4e0d\u5b9a\u5f62\u8981\u5b58\u53cc\u5411\u8fb9 \nint first[maxn],nt[maxn<<1],ES;//\u90bb\u63a5\u8868\ninline void addE(int u,int v,int w)//\u52a0\u8fb9\u51fd\u6570 \n{\n\te[++ES]=(E){u,v,w};\n\tnt[ES]=first[u];\n\tfirst[u]=ES;\n\treturn ;\n}\nint sz[maxn]/*\u6811\u5927\u5c0f*/,fa[maxn]/*\u76f4\u5c5e\u7236\u4eb2*/,top[maxn]/*\u94fe\u5934\u7ed3\u70b9*/;\nint son[maxn]/*\u91cd\u513f\u5b50*/,depth[maxn]/*\u6df1\u5ea6*/;\nint id[maxn]/*\u7ed3\u70b9->\u7ebf\u6bb5\u6811\u7f16\u53f7*/,anti[maxn]/*\u7ebf\u6bb5\u6811\u7f16\u53f7->\u7ed3\u70b9*/;\nint ix,A[maxn]/*\u5728\u505a\u70b9\u6743\u6811\u5256\u65f6\u7684\u70b9\u6743\u6570\u7ec4*/;\ninline void DFS(int u)\n{\n\tint v;sz[u]=1;//\u5927\u5c0f\u521d\u59cb\u5316 \n\tfor(int i=first[u];i;i=nt[i])\n\t{\n\t\tv=e[i].v;\n\t\tif(v!=fa[u])//\u4e0d\u80fd\u6b7b\u8f6c\u5708\n\t\t{\n\t\t\tdepth[v]=depth[u]+1;\n\t\t\tfa[v]=u;//v\u7684\u7236\u4eb2\u662fu\n\t\t\tA[v]=e[i].w;//\u8f6c\u5316\u5173\u952e\u4ee3\u78011,\u5c06\u8fde\u5411\u5b50\u8282\u70b9\u7684\u8fb9\u6743\u76f4\u63a5\u8d4b\u7ed9\u5b50\u8282\u70b9\n\t\t\tDFS(v);\n\t\t\tsz[u]+=sz[v];//\u7ef4\u62a4\u5927\u5c0f\n\t\t\tif(sz[son[u]]<sz[v]) son[u]=v;//\u91cd\u513f\u5b50 \n\t\t}\n\t}\n\treturn ; \n}\ninline void dfs(int u,int tp)\n{\n\tid[u]=++ix;anti[ix]=u;//\u5efa\u7acb\u6b63\u53cd\u6620\u5c04\n\ttop[u]=tp;//\u94fe\u5934\n\tif(son[u]) dfs(son[u],tp);//\u4f18\u5148\u904d\u5386\u91cd\u513f\u5b50\n\tint v;\n\tfor(int i=first[u];i;i=nt[i])\n\t{\n\t\tv=e[i].v;\n\t\tif(v==son[u]||v==fa[u]) continue;\n\t\tdfs(v,v);\n\t}\n\treturn ;\n}\n#define mid (L+R>>1)\n#define L(i) (i<<1)\n#define R(i) (i<<1|1)//\u6d89\u53ca\u5230\u4f18\u5148\u7ea7\u8f83\u4f4e\u7684\u4f4d\u8fd0\u7b97\u5efa\u8bae\u52a0\u62ec\u53f7 \ninline void Build(int L,int R,int i)\n{\n\tif(L==R)\n\t{\n\t\tTREE[i]=A[anti[L]];//\u4e4b\u524d\u5df2\u7ecf\u8fdb\u884c\u4e86\u8f6c\u5316\u53ef\u4ee5\u4e0d\u6539\u53d8\u8fd9\u91cc\n\t\treturn ; \n\t}\n\tBuild(L,mid,L(i));\n\tBuild(mid+1,R,R(i));\n\tTREE[i]=TREE[L(i)]+TREE[R(i)];\n\treturn ;\n}\ninline void LAZY(int L,int R,int i)\n{\n\tif(!lazy[i]) return ;\n\tlazy[L(i)]+=lazy[i];\n\tlazy[R(i)]+=lazy[i];\n\tTREE[L(i)]+=(mid-L+1)*lazy[i];\n\tTREE[R(i)]+=(R-mid)*lazy[i];\n\tlazy[i]=0;//\u9ad8\u9891\u9519\u70b9\uff01\uff01 \n\treturn ;\n}\ninline void Update(int L,int R,int l,int r,int i,int k)\n{\n\tif(l<=L&&R<=r)\n\t{\n\t\tTREE[i]+=k*(R-L+1);\n\t\tlazy[i]+=k;\n\t\treturn ;\n\t}\n\tLAZY(L,R,i);//\u4efb\u4f55\u65f6\u5019\u8bbf\u95ee\u5b50\u8282\u70b9\u90fd\u9700\u8981\u4e0b\u4f20\u6807\u8bb0 \n\tif(l<=mid) Update(L,mid,l,r,L(i),k);\n\tif(r>mid) Update(mid+1,R,l,r,R(i),k);\n\tTREE[i]=TREE[L(i)]+TREE[R(i)];\n\treturn ;\n}\ninline int Query(int L,int R,int l,int r,int i)\n{\n\tif(l<=L&&R<=r)\n\t\treturn TREE[i];\n\tLAZY(L,R,i);\n\tint ans=0;\n\tif(l<=mid) ans+=Query(L,mid,l,r,L(i));\n\tif(r>mid) ans+=Query(mid+1,R,l,r,R(i));\n\treturn ans; \n}\ninline void Update_Path(int x,int y,int k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(depth[top[x]]<depth[top[y]]) swap(x,y);\n\t\tUpdate(1,N,id[top[x]],id[x],1,k);\n\t\tx=fa[top[x]];\n\t}\n\tif(depth[x]>depth[y]) swap(x,y);\n\tUpdate(1,N,id[x],id[y],1,k);\n\tUpdate(1,N,id[x],id[x],1,-k);//\u6838\u5fc3\u4ee3\u78012 \n\treturn ;\n}\ninline int Query_Path(int x,int y)\n{\n\tint ans=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(depth[top[x]]<depth[top[y]]) swap(x,y);\n\t\tans+=Query(1,N,id[top[x]],id[x],1);\n\t\tx=fa[top[x]];\n\t}\n\tif(depth[x]>depth[y]) swap(x,y);\n\tans+=Query(1,N,id[x],id[y],1); \n\tans-=Query(1,N,id[x],id[x],1);//\u6838\u5fc3\u4ee3\u78013 \n\treturn ans;\n}\ninline int Re()\n{\n\tchar c;\n\tint re;\n\twhile((c=getchar())>'9'||c<'0');\n\tre=c-48;\n\twhile((c=getchar())>='0'&&c<='9')\n\tre=re*10+c-48;\n\treturn re;\n}\nint main()\n{\n\tN=Re();Q=Re();\n\tint u,v,w;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tu=Re();v=Re();w=Re();\n\t\taddE(u,v,w);addE(v,u,w);\n\t}\n\tDFS(1);dfs(1,1);\n\tBuild(1,N,1);\n\tint op;\n\tfor(int i=1;i<=Q;i++)\n\t{\n\t\top=Re();\n\t\tif(op==1)//\u8def\u5f84\u66f4\u65b0\n\t\t{\n\t\t\tu=Re();v=Re();w=Re();\n\t\t\tUpdate_Path(u,v,w);\n\t\t}\n\t\telse if(op==2)//\u5b50\u6811\u66f4\u65b0\n\t\t{\n\t\t\tu=Re();w=Re();\n\t\t\tUpdate(1,N,id[u],id[u]+sz[u]-1,1,w);\n\t\t}\n\t\telse if(op==3)//\u8def\u5f84\u8be2\u95ee\n\t\t{\n\t\t\tu=Re();v=Re();\n\t\t\tprintf(\"%d\\n\",Query_Path(u,v));\n\t\t}\n\t\telse//\u5b50\u6811\u8be2\u95ee\n\t\t{\n\t\t\tu=Re();\n\t\t\tprintf(\"%d\\n\",Query(1,N,id[u],id[u]+sz[u]-1,1));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u4e0a\u9762\u8fd9\u4efd\u677f\u5b50\u662f\u6211\u8ba4\u4e3a\u6700\u7b80\u5355\u7684\u8f6c\u5316\u65b9\u5f0f,\u4e0e\u70b9\u6743\u6811\u94fe\u5256\u5206\u76f8\u6bd4\u4ec5\u4ec5\u591a\u4e86 $3$ \u53e5\u8bdd  \n- \u5728\u8fdb\u884c $DFS$ \u904d\u5386\u65f6\u5373\u5c06\u8fdb\u5165\u5b50\u8282\u70b9\u65f6\u5c06\u8fb9\u6743\u8d4b\u7ed9\u5b50\u8282\u70b9  \n$A[v]=e[i].w$   \n\n- \u5728\u8fdb\u884c\u8def\u5f84\u66f4\u65b0\u7684\u65f6\u5019\u6700\u540e\u4e00\u6b65\u5728 $LCA$ \u4e0a\u51cf\u53bb $k$,\u56e0\u4e3a $LCA$ \u4ee3\u8868\u7684\u8fb9\u6743\u5e76\u4e0d\u5728\u6240\u66f4\u65b0\u8def\u5f84\u4e2d(\u81ea\u5df1\u753b\u56fe\u53ef\u4ee5\u611f\u53d7\u4e00\u4e0b,\u753b\u90a3\u79cd\u540c\u4e00\u4e2a\u7236\u4eb2\u4ece\u4e00\u4e2a\u5b50\u6811\u5230\u53e6\u5916\u4e00\u4e2a\u5b50\u6811\u7684\u8def\u5f84\u5c31\u4f1a\u53d1\u73b0\u7236\u8282\u70b9\u4ee3\u8868\u7684\u8fb9\u4e0d\u7b97),$Update(1,N,id[x],id[x],1,-k)$\n\n- \u5728\u8fdb\u884c\u8def\u5f84\u67e5\u8be2\u7684\u65f6\u5019\u6700\u540e\u4e5f\u4f1a\u628a\u591a\u67e5\u8be2\u7684 $LCA$ \u4ee3\u8868\u7684\u8fb9\u6743\u51cf\u6389   \n$ans-=Query(1,N,id[x],id[x],1)$    \n\n\n\u8fd9\u662f\u5229\u4e8e\u7406\u89e3\u7684\u7248\u672c\u54e6,\u5b9e\u9645\u4e0a\u6211\u4eec\u5728\u7528\u7684\u65f6\u5019\u7b2c\u4e8c\u6761\u548c\u7b2c\u4e09\u6761\u90fd\u6ca1\u6709,\u800c\u662f\u5c06\u539f\u6765\u7684  \n```cpp\nUpdate(1,N,id[x],id[y],1,k)  Query(1,N,id[x],id[y],1)\n```\n\u76f4\u63a5\u4fee\u6539\u4e3a  \n```\nUpdate(1,N,id[x]+1,id[y],1,k)  Query(1,N,id[x]+1,id[y],1)\n```\n\u800c\u4e3a\u4ec0\u4e48\u6211\u5728\u8fd9\u91cc\u6ca1\u6709\u5199\u5462\uff1f\n\u56e0\u4e3a\u6709\u65f6\u5019\u5f53 $x$ \u548c $y$ \u8df3\u5230\u540c\u4e00\u6761\u94fe\u4e0a\u65f6\u4e8c\u8005\u521a\u597d\u91cd\u5408,\u8fd9\u65f6\u5019\u52a0\u4e00\u4f1a\u8ba9\u8fdb\u5165\u7ebf\u6bb5\u6811\u65f6\u51fa\u73b0 $l>r$ \u8fd9\u662f\u4e0d\u7b26\u5408\u5b9a\u4e49\u7684,\u4e0d\u5229\u4e8e\u7406\u89e3\u3002  \n\u53ea\u4e0d\u8fc7\u7ebf\u6bb5\u6811\u7684 $feature$ \u521a\u597d\u8ba9\u8fd9\u79cd $l=r+1$ \u7684\u60c5\u51b5\u4ec0\u4e48\u90fd\u67e5\u4e0d\u5230\u5c31\u9000\u51fa\u4e86\u51fd\u6570,\u6240\u4ee5\u4fee\u6539\u540e\u56e0\u4e3a\u52a0\u8fc7\u4e00\u6b21 $1$ \u800c\u6b64\u65f6 $x$ \u548c $y$ \u6070\u597d\u5728\u4e00\u6761\u94fe\u4e0a,\u53ef\u4ee5\u521a\u597d\u5ffd\u7565\u70b9 $x$ \u7684\u6743\u503c\u8fbe\u5230\u6211\u4eec\u7684\u76ee\u7684\uff0c\u4fee\u6539\u4e00\u53e5\u8bdd\u5c31\u8fbe\u5230\u4e86\u4e24\u53e5\u8bdd\u7684\u6548\u679c\u3002  \n\n\u90a3\u4e48\u8fd9\u9053\u9898\u5728\u6ce5\u638c\u63e1\u4e0a\u9762\u7684\u6a21\u677f\u4e4b\u540e\u5c31\u53ef\u4ee5\u8f7b\u677e\u5207\u6389\u4e86\u3002  \n\n\u6811\u94fe\u5256\u5206\u662f\u50cf\u6211\u8fd9\u6837\u7684\u849f\u84bb\u7ecf\u5e38\u7a92\u606f\u7684\u4e00\u4e2a\u4e1c\u897f,\u6700\u6015\u7684\u5c31\u662f $\\text{Segment Fault}$ \u4f46\u662f\u603b\u662f\u6709\u4e00\u4e2a\u8fc7\u7a0b\u7684\u554a,[\u5982\u679c\u6ce5\u591a\u7ec3](https://www.luogu.com.cn/training/1654#information),\u6bcf\u6b21\u90fd\u76f4\u63a5\u91cd\u65b0\u6253,~~\u5728\u4f60\u5410\u4e4b\u524d~~\u4e00\u5b9a\u80fd\u591f**\u719f\u7ec3**\u638c\u63e1\u8fd9\u4e2a\u7b97\u6cd5\uff01\uff01  \n\u90a3\u4e9b\u5341\u51e0\u5206\u949f\u5207\u6811\u5256\u4e00\u6b21\u8fc7\u7684\u795e\u4ed9\u5e76\u4e0d\u662f\u521a\u5b66\u5c31\u8fd9\u6837,\u4e5f\u53ea\u6709\u4e00\u4e2a\u4fe1\u6761  \n**\u65e0\u4ed6,\u552f\u624b\u719f\u5c14**  \n$\\text{The End}$",
        "postTime": 1583208269,
        "uid": 215697,
        "name": "LeavingZ",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]Grass Planting G\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u76ee\u663e\u7136\u662f\u4e00\u4e2a\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u9898\uff0c\u4f46\u662f\u6211\u5c31\u6765\u4e00\u53d1\u500d\u589elca\u52a0\u4e0a\u6811\u72b6\u6570\u7ec4\u7684\u4ee3\u7801\u5427\u3002\n\n\u6211\u4eec\u5148dfs\u4e00\u53d1\u6c42\u51fa\u5148\u5e8f\u904d\u5386\uff0c\u7136\u540e\u518d\u8fdb\u884clca\u7684\u9884\u5904\u7406\u3002\n\n\u5bf9\u4e8e\u79cd\u8349\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e8el[u],l[v]\u662f\u8981\u52a01\u7684\uff0c\u5bf9\u4e8el[lca(u,v)]\u8981\u51cf\u53bb2\uff0c\u548c\u533a\u95f4\u8986\u76d6\u95ee\u9898\u7c7b\u4f3c\u3002\uff08\u8bf4\u767d\u4e86\u5c31\u662f\u4e00\u4e2a\u6811\u4e0a\u5dee\u5206\uff09\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u5e94\u8be5\u662f$O(n log n)$\uff0c\u8dd1\u8fd9\u4e2a\u6570\u636e\u662f\u53ef\u4ee5\u63a5\u53d7\u7684\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\nint n,m,f[100050],time=0;\n\nint depth[100050],r[100050],l[100050],fa[100050][21];\n\nvector <int> graph[100050];\n\nint Lowbit(int x)\n{\n    return x&-x;\n}\n\nvoid Change(int k,int num)\n{\n    while (k<=n)\n    {\n        f[k]+=num;\n        k+=Lowbit(k);\n    }\n}\n\nint Ask(int k)\n{\n    int ans=0;\n    while (k>0)\n    {\n        ans+=f[k];\n        k-=Lowbit(k);\n    }\n    return ans;\n}\n\nint lca(int u,int v)\n{\n    if (depth[u]<depth[v])\n        swap(u,v);\n    for (int k=20;k>=0;k--)\n        if (depth[u]-depth[v]>=1<<k)\n            u=fa[u][k];\n    if (u==v)\n        return u;\n    for (int k=20;k>=0;k--)\n        if (fa[u][k]!=fa[v][k])\n        {\n            u=fa[u][k];\n            v=fa[v][k];\n        }\n    return fa[u][0];\n}\n\nvoid dfs(int u,int p)\n{\n    depth[u]=depth[p]+1;\n    fa[u][0]=p;\n    time++;\n    l[u]=time;\n    for (int i=0;i<graph[u].size();i++)\n    {\n        int v=graph[u][i];\n        if (v!=p)\n            dfs(v,u);\n    }\n    r[u]=time;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<n;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    dfs(1,0);\n    for (int k=1;k<=20;k++)\n        for (int u=1;u<=n;u++)\n            fa[u][k]=fa[fa[u][k-1]][k-1];\n    for (int i=1;i<=m;i++)\n    {\n        char chr;\n        int u,v;\n        scanf(\"%s%d%d\",&chr,&u,&v);\n        //cout << v << \" \" << l[v] << endl;\n        if (chr=='P')\n        {\n            int p=lca(u,v);\n            Change(l[u],1);\n            Change(l[v],1);\n            Change(l[p],-2);\n        }\n        else\n        {\n            if (depth[u]<depth[v])\n                u=v;\n            printf(\"%d\\n\",Ask(r[u])-Ask(l[u]-1));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1500120191,
        "uid": 8457,
        "name": "chen_zhe",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u603b\u4f53\u601d\u8def\uff1a\u6811\u94fe\u5256\u5206\u4ee5\u53ca\u4e00\u4e2a\u652f\u6301\u533a\u95f4\u4fee\u6539\uff0c\u5355\u70b9\u67e5\u8be2\u7684\u7ebf\u6bb5\u6811\u3002\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a[P3384 \u3010\u6a21\u677f\u3011\u8f7b\u91cd\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384)\n\n\uff08\u8fd9\u9053\u6a21\u677f\u9898\u5305\u542b\u4e86\u4eca\u5929\u8981\u7528\u7684\u6240\u6709\u64cd\u4f5c\uff0c\u5982\u7ebf\u6bb5\u6811\uff0c\u6811\u94fe\u5256\u5206\uff09\n\n\u77e5\u9053\u4e86\u8fd9\u4e2a\u77e5\u8bc6\uff0c\u6211\u4eec\u89e3\u51b3\u8fd9\u9053\u9898\u5c31\u5f88\u5bb9\u6613\u4e86\u3002\n\n\u6ce8\u610f1\uff1a\n\n\u7ebf\u6bb5\u6811\u53ef\u4ee5\u4fee\u6539\u3001\u67e5\u8be2\u7684\u662f\u70b9\u6743\uff0c\u800c\u9898\u4e2d\u4fee\u6539\u3001\u67e5\u8be2\u7684\u662f\u8fb9\u6743\u3002\u6211\u4eec\u8be5\u600e\u4e48\u529e\u5462\uff1f\n\n\u53ef\u4ee5\u628a\u8fb9\u6743\u8f6c\u6362\u4e3a\u70b9\u6743\u3002\u6ce8\u610f\u5230\u6bcf\u4e2a\u70b9\u4e0e\u5b83\u7238\u7238\u53ea\u6709\u4e00\u6761\u8fb9\u76f8\u8fde\uff0c\u90a3\u4e48\u4e00\u4e2a\u70b9\u7684\u6743\u503c\u5c31\u7b49\u4e8e\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u3002\n\n\u5f53\u7136\uff0c\u5bf9\u4e8e\u6839\u8282\u70b9\u6765\u8bb2\u662f\u6839\u672c\u4e0d\u5b58\u5728\u7684\uff0c\u56e0\u4e3a\u5b83\u6ca1\u6709\u7238\u7238\u3002\n\n\u6ce8\u610f2\uff1a\n\n\u5bf9\u4e8e\u4e24\u70b9\u95f4\u7684\u8def\u5f84\u4e0a\u6240\u6709\u8fb9\u6743\u52a0\u4e00\u7684\u64cd\u4f5c\uff0c\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u5b83\u4fe9\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148\uff0c\u4e5f\u5c31\u662f LCA \u6240\u5bf9\u5e94\u7684\u8fb9\u662f\u4e0d\u505a\u64cd\u4f5c\u7684\u3002\n\n\u4e24\u70b9\u8df3\u5230\u540c\u4e00\u91cd\u94fe\u4e0a\u65f6\uff0c\u6df1\u5ea6\u5c0f\u7684\u90a3\u4e2a\u70b9\u5c31\u662f LCA\u3002\u90a3\u4e48\uff0c\u6211\u4eec\u6700\u540e\u53ea\u9700\u8981\u4fee\u6539 $[id[u]+1,id[v]]$ \u8fd9\u4e2a\u533a\u95f4\uff08\u6b64\u5904 $d[u]<d[v]$ \uff09\uff0c\u5c31\u5de7\u5999\u5730\u907f\u514d\u4e86 LCA \u88ab\u4fee\u6539\u7684\u60e8\u72b6\u3002\u56e0\u4e3a $id[u]$ \u8fd9\u4e2a\u70b9\u5728\u533a\u95f4\u5916\u3002\n\n\u60f3\u8981\u66f4\u8be6\u7ec6\u7684\u5185\u5bb9\uff0c\u5c31\u6765\u770b\u6211\u7684\u4ee3\u7801\u5427\uff01\uff08\u4e2a\u4eba\u559c\u6b22\u7528 vector \u4ee5\u53ca ~~\u9f9f\u901f~~ cin \u4e0e cout \uff09\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint fa[100001];//\u6bcf\u4e2a\u70b9\u7684\u7238\u7238 \nint d[100001];//\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\nint son[100001];//\u6bcf\u4e2a\u70b9\u7684\u91cd\u513f\u5b50\nint su[100001];//\u4e00\u4e2a\u70b9\u4e3a\u6839\u8282\u70b9\u65f6\u8be5\u5b50\u6811\u5185\u7684\u70b9\u6570 \nint top[100001];//\u6bcf\u4e2a\u70b9\u5728\u6811\u5256\u540e\u6240\u5728\u94fe\u7684\u9876\u7aef \nint id[100001];//\u6bcf\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u91cc\u6240\u5728\u7684\u4f4d\u7f6e \nvector<int>g[100001];//\u5927\u7231vector\u5b58\u56fe \nvoid dfs1(int x,int f,int deep)\n{\n\tfa[x]=f;d[x]=deep;su[x]=1;int maxs=0,i;\n\tfor(i=0;i<g[x].size();i++)\n\t{\n\t\tint v=g[x][i];\n\t\tif(v!=f)\n\t\t{\n\t\t\tdfs1(v,x,deep+1);\n\t\t\tsu[x]+=su[v];\n\t\t\tif(maxs<su[v])\n\t\t\t{\n\t\t\t\tson[x]=v;\n\t\t\t\tmaxs=su[v];\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int x,int fafa)\n{\n\ttop[x]=fafa;id[x]=++id[0];\n\tif(!son[x])return;\n\tdfs2(son[x],fafa);\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tint v=g[x][i];\n\t\tif(fa[x]==v||son[x]==v)continue;\n\t\tdfs2(v,v);\n\t}\n}//\u5f88\u7ecf\u5178\u7684\u4e24\u4e2adfs\u5b8c\u6210\u6811\u5256 \nstruct qq\n{\n\tint l,r,sum,add;\n}q[400001];\nvoid build(int p,int l,int r)\n{\n\tq[p].l=l;q[p].r=r;\n\tif(l==r)return;\n\tbuild(p*2,l,(l+r)/2);\n\tbuild(p*2+1,(l+r)/2+1,r);\n}\nvoid pd(int p)\n{\n\tq[p*2].add+=q[p].add;q[p*2+1].add+=q[p].add;\n\tq[p*2].sum+=(q[p*2].r-q[p*2].l+1)*q[p].add;\n\tq[p*2+1].sum+=(q[p*2+1].r-q[p*2+1].l+1)*q[p].add;\n\tq[p].add=0;\n}\nvoid change(int p,int x,int y)\n{\n\tif(q[p].r<x||q[p].l>y)return;\n\tif(q[p].l>=x&&q[p].r<=y)\n\t{\n\t\tq[p].sum+=q[p].r-q[p].l+1;\n\t\tq[p].add++;\n\t\treturn;\n\t}\n\tpd(p);\n\tchange(p*2,x,y);\n\tchange(p*2+1,x,y);\n\tq[p].sum=q[p*2].sum+q[p*2+1].sum;\n} \nint ask(int p,int x)\n{\n\tif(q[p].r<x||q[p].l>x)return 0;\n\tif(q[p].l==q[p].r)return q[p].sum;\n\tpd(p);\n\treturn ask(p*2,x)+ask(p*2+1,x);\n}//\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\nint main()\n{\n\tint x,y,i;\n\tchar c;\n\tcin>>n>>m;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);//\u5b58\u65e0\u5411\u8fb9 \n\t}\n\tdfs1(1,0,1);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\twhile(m--)\n\t{\n\t\tcin>>c>>x>>y;\n\t\tif(c=='P')\n\t\t{\n\t\t\twhile(top[x]!=top[y])\n\t\t\t{\n\t\t\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\t\t\tchange(1,id[top[x]],id[x]);\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t\tif(d[x]>d[y])swap(x,y);\n\t\t\tchange(1,id[x]+1,id[y]);//\u7528\u4e0a\u8ff0\u65b9\u6cd5\u907f\u5f00LCA \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(fa[x]==y)cout<<ask(1,id[x])<<endl;\n\t\t\telse cout<<ask(1,id[y])<<endl;//\u5224\u65ad\u8be5\u8fb9\u7684\u8fb9\u6743\u662f\u54ea\u4e2a\u70b9\u7684\u70b9\u6743 \n\t\t}\n\t}\n\treturn 0;\n}//\u7f8e\u6ecb\u6ecbAC\n```\n",
        "postTime": 1584095511,
        "uid": 223624,
        "name": "Apollo13",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]Grass Planting G\u3011"
    },
    {
        "content": "## \u65e2\u7136\u5404\u4f4ddalao\u90fd\u7528\u7684\u7ebf\u6bb5\u6811+\u6811\u5256\u6216\u8005LCA+\u6811\u72b6\u6570\u7ec4\uff0c\u90a3\u4e3a\u4ec0\u4e48\u4e0d\u7528\u4e00\u4e0b\u6811\u72b6\u6570\u7ec4+\u6811\u5256\u5462~\uff1f\uff08\u6ed1\u7a3d\n## \u76ee\u524d\u5f00O2\u540e\u662f\u672c\u9898\u7684RANK2\nAccepted  100 \n\u7528\u65f6: 172ms / \u5185\u5b58: 19480KB\n\n\n------------\n\n\n### \u524d\u7f6e\u77e5\u8bc6\uff1a\u6811\u94fe\u5256\u5206[P3384](https://www.luogu.org/problemnew/show/P3384)\u6811\u72b6\u6570\u7ec42\uff08\u533a\u95f4\u6dfb\u52a0\u5355\u70b9\u67e5\u8be2\uff0c\u5dee\u5206\uff09[P3368](https://www.luogu.org/problemnew/show/P3368)\n\n\n\n------------\n\n### \u5927\u81f4\u601d\u8def\uff1a\n\n1.\u8bfb\u5165\uff0c\u8fde\u8fb9\uff0c\u6811\u5256\u3002\n\n-\n\n2.\u5bf9\u4e8e'P'\u64cd\u4f5c\uff0c\u6211\u4eec\u53ea\u9700\u5728\u8fd9\u4e2a\u8def\u5f84\u4e0a\u7684\u9664\u4e86\u516c\u5171\u7956\u5148\u4ee5\u5916\u7684\u6240\u6709\u70b9\u6dfb\u52a01\u5373\u53ef\u3002\n\n\u53ef\u4ee5\u5728\u8349\u7a3f\u7eb8\u4e0a\u968f\u4fbf\u753b\u4e0a\u4e00\u9897\u6811\uff0c\u6bcf\u6b21**\u5728\u8fb9\u4e0a\u6dfb\u52a0**\u53ef\u4ee5\u8f6c\u5316\u4e3a**\u6dfb\u52a0\u67d0\u6761\u8fb9\u7684\u5e95\u7aef**\uff08\u5373\u6df1\u5ea6\u5927\u7684\u90a3\u4e2a\u70b9\uff09\uff0c\u663e\u800c\u6613\u89c1\uff0c\u8fd9\u6837\u505a\uff0c**\u4e00\u4e2a\u70b9\u662f\u5fc5\u5b9a\u5bf9\u5e94\u4e00\u6761\u8fb9\u7684\u3002**\n\n\u4f46LCA\u90a3\u4e2a\u70b9\u4e0d\u5c5e\u4e8e\u6211\u4eec\u8981\u67e5\u7684\u8def\u5f84\uff0c\u6240\u4ee5\u5f53\u4e24\u4e2a\u70b9\u8df3\u5230\u4e00\u6761\u94fe\u4e0a\u65f6\uff0c\u8bbex\u7684\u6df1\u5ea6\u5c0f\u4e8ey\u7684\u6df1\u5ea6\uff0cid[x]\u4e3ax\u5728\u6811\u72b6\u6570\u7ec4\u4e0a\u7684\u7f16\u53f7\uff0c\u90a3\u4e48id[x]\uff08\u5373LCA\uff09\u4e0d\u5728\u8fd9\u6761\u8def\u5f84\u4e0a\uff0c\u6dfb\u52a0\u65f6\u53ea\u6dfb\u52a0(id[x]+1,id[y])\u5373\u53ef~\uff01\n\n-\n\n3.\u5bf9\u4e8e'Q'\u64cd\u4f5c\uff0c\u56e0\u4e3a\u9898\u76ee\u8bf4\u5728\u67e5\u8be2\u7684\u65f6\u5019\u53ea\u9700\u8981\u67e5**\u201c\u4e00\u6761\u8fb9\u201d**\uff0c\u800c\u4e0d\u662f**\u201c\u4e00\u6bb5\u8def\u5f84\u201d**\u3002\u6240\u4ee5\u5728\u6811\u72b6\u6570\u7ec4\u4e0a\u5355\u70b9\u67e5\u5bfb\u4e24\u7aef\u70b9\u6df1\u7684\u90a3\u4e2a\u7aef\u70b9\u5373\u53ef\uff08\u6df1\u7684\u90a3\u4e2a\u4ee3\u8868\u4e86\u4e00\u6761\u8fb9\uff0c\u5982\u601d\u8def2\u6240\u8ff0\uff09\u3002\n\n## CODE\uff08\u9644\u6709\u7b80\u5355\u6ce8\u91ca\uff09\uff1a\n```cpp\n#pragma warning (disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define RG register\nusing namespace std;\nconst int maxn = 1e5 + 5, maxm = maxn << 1;\nint head[maxm], nxt[maxm], v[maxm]/*\u524d\u5411\u661f*/, dad[maxn]/*\u67d0\u70b9\u7236\u4eb2*/, son[maxn]/*\u91cd\u513f\u5b50*/,\nsz[maxn]/*\u5b50\u6811\u5927\u5c0f*/, depth[maxn]/*\u6df1\u5ea6*/, id[maxn]/*\u67d0\u70b9\u5728\u6811\u72b6\u6570\u7ec4\u4e0a\u7684\u5bf9\u5e94\u7f16\u53f7*/, top[maxn]/*\u91cd\u94fe\u5934*/;\n\nint n, m, cnt/*\u524d\u5411\u661f\u7528*/, root/*\u6811\u6839*/, num/*\u6811\u5256\u7528dfs\u5e8f*/;\n\nstruct Binary_Indexed_Tree//\u7ed3\u6784\u4f53\u5c01\u88c5\u6811\u72b6\u6570\u7ec4\uff01\n{\n\tint c[maxn];\n\tinline int lowbit(int k) { return k & (-k); }\n\tinline void add(int x, int k) { for (int i = x; i <= n; i += lowbit(i)) c[i] += k; }\n\tinline int sum(int x) { int ans = 0; for (int i = x; i; i -= lowbit(i))\tans += c[i]; return ans; }\n\tinline void update(int l, int r, int k) { add(l, k), add(r + 1, -k); }//\u533a\u95f4\u52a0\u6cd5\n}BIT;\n//\u4ee5\u4e0b\u662f\u524d\u5411\u661f\uff0c\u5feb\u8bfb\u5199\u548c\u6811\u5256\ninline void addline(int x, int y) { v[cnt] = y, nxt[cnt] = head[x], head[x] = cnt++; }\n\ninline int read()\n{\n\tRG char c = getchar(); RG int x = 0;\n\twhile (c<'0' || c>'9')\tc = getchar();\n\twhile (c >= '0'&&c <= '9')\tx = (x << 3) + (x << 1) + c - '0', c = getchar();\n\treturn x;\n}\n\ninline void write(int x)\n{\n\tif (x > 9)\twrite(x / 10);\n\tputchar(x % 10 + '0'); return;\n}\n\ninline void dfs1(int x, int f, int d)\n{\n\tdad[x] = f, depth[x] = d, sz[x] = 1;\n\tfor (RG int i = head[x]; i != -1; i = nxt[i])\n\t{\n\t\tif (v[i] == f)\tcontinue;\n\t\tdfs1(v[i], x, d + 1);\n\t\tsz[x] += sz[v[i]];\n\t\tif (sz[v[i]] > sz[son[x]])\tson[x] = v[i];\n\t}\n\treturn;\n}\n\ninline void dfs2(int x, int t)\n{\n\tid[x] = ++num, top[x] = t;\n\tif (!son[x])\treturn;\n\tdfs2(son[x], t);\n\tfor (RG int i = head[x]; i != -1; i = nxt[i])\n\t\tif (v[i] != dad[x] && v[i] != son[x])\tdfs2(v[i], v[i]);\n\treturn;\n}\n//\u6dfb\u52a0\u64cd\u4f5c\uff01\ninline void add(int x, int y, int k)\n{\n\tRG int tx = top[x], ty = top[y];\n\twhile (tx != ty)\n\t{\n\t\tif (depth[tx] >= depth[ty])\tBIT.update(id[tx], id[x], k), x = dad[tx], tx = top[x];\n\t\telse BIT.update(id[ty], id[y], k), y = dad[ty], ty = top[y];\n\t}\n\tif (x == y)\treturn;//\u5982\u679cx==y\u4e0d\u9000\u51fa\uff0c\u7ebf\u6bb5\u6811\u91cc\u4f1a\u51fa\u73b0\u67e5\u8be2\u533a\u95f4[l,r]\u51fa\u73b0l>r\u7684\u60c5\u51b5\n\tif (id[x] <= id[y]) BIT.update(id[x] + 1, id[y], k);//\u8bb0\u5f97+1\u907f\u514dLCA\u90a3\u4e2a\u70b9\n\telse BIT.update(id[y] + 1, id[x], k);\n\treturn;\n}\n\nint main()\n{\n\tmemset(head, -1, sizeof(head));\n\tn = read(), m = read();\n\tfor (RG int i = 1; i < n; i++) { int x = read(), y = read(); addline(x, y), addline(y, x); }\n\tsrand(19260817), root = rand() % n + 1, dfs1(root, 0, 1), dfs2(root, root);//\u968f\u673a\u9009\u6839\uff01\uff08\u7528\u4e86\u4e00\u4e2a\u5f88\u66b4\u529b\u7684\u6811\u5feb\u4e864ms \uff1f\uff1f\uff1f\n\twhile (m--)\n\t{\n\t\tRG char c = getchar(); RG int x, y;\n\t\twhile (c != 'P' && c != 'Q')\tc = getchar();\tx = read(), y = read();\n\t\tif (c == 'P')\tadd(x, y, 1);//\u76f4\u63a5\u8c03\u7528\n\t\tif (c == 'Q')\tdepth[x] > depth[y] ? write(BIT.sum(id[x])) : write(BIT.sum(id[y])), putchar('\\n');\n\t\t//\u770b\u4e0d\u61c2\u7684\u4e5f\u53ef\u4ee5\u7ffb\u8bd1\u6210\uff1a\n\t\t//if(depth[x]>depth[y])\twrite(BIT.sum(id[x]));\n\t\t//else\twrite(BIT.sum(id[y]));\n\t\t//putchar('\\n');\n\t\t//\u5373\u9009\u53d6\u6df1\u5ea6\u5927\u7684\u90a3\u4e2a\u70b9\u8fdb\u884c\u67e5\u8be2\n\t}\n\treturn 0;\n}\n```\n\n\n",
        "postTime": 1533785832,
        "uid": 29354,
        "name": "CodyTheWolf",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u9898\u89e3\u8fd9\u4e48\u5c11\uff0c\u8d85\u7ea7\u849f\u84bb\u8865\u4e00\u53d1\u3002\u5927\u4f6c\u4eec\u7528\u7684\u4e0d\u662f\u7ebf\u6bb5\u6811\uff08\u6211\u4e0d\u4f1a\uff09\uff0c\u5c31\u662f\u6811\u94fe\u5256\u5206\uff08\u6211\u8fd8\u662f\u4e0d\u4f1a\uff09\uff0c\u4e8e\u662f\u7528\u4e86\u6700\u50bb\u7684vector\u5b58\u56fe+\u500d\u589e\u6c42LCA+\u6811\u72b6\u6570\u7ec4\u7528\u5dee\u5206\u601d\u60f3\u7ef4\u62a4\u524d\u7f00\u548c\uff08\u8c8c\u4f3c\u8fd8\u6ca1\u8d85\u8fc7\u63d0\u9ad8\u7ec4\u7684\u8003\u7eb2\uff09\uff0c\u5e94\u8be5\u662f\u76ee\u524d\u6700\u6734\u7d20\uff08sha\uff09\u7684\u505a\u6cd5\u4e86\u3002\n\n\u7531\u4e8e\u849f\u84bb\u4e0d\u4f1a\u538b\u884c\u5927\u6cd5\uff0c\u56e0\u6b64\u7a0b\u5e8f\u5341\u5206\u5197\u957f\uff0c\u517194\u884c\uff0c\u8dd1\u5f97\u8fd8\u8d3c\u6162\uff0c\u52a0\u4e86O2\u3001\u5feb\u8bfb\u548c\u4e00\u5806inline\u3001register\u5f97\u4e86488ms\uff08\u5de8\u4f6c\uff1a\u53eb\u4f60\u4e0d\u5b66\u597d\u90bb\u63a5\u8868\uff0c\u8981\u7528vector\u5077\u61d2\uff0c\u8fd9\u4e48\u6162\u771f\u662f\u6ca1\u8c01\u4e86\uff09\n\n\u597d\u4e86\uff0c\u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u5f00\u770b\u4ee3\u7801\uff1a\n```cpp\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int N=1e5+10;\nvector<int> g[N]; //vector\u4ee3\u66ff\u90bb\u63a5\u8868\u5b58\u56fe\uff08\u4e0d\u8981\u5b66\u6211\uff09\nint n,m,time,fa[N][21],d[N],l[N],r[N],t[N]; \ninline int read() //\u6ee1\u5927\u8857\u7684\u5feb\u8bfb\n{\n  char c; int sign=1;\n  while((c=getchar())<'0'||c>'9')\n    if(c=='-') sign=-1;\n  int res=c-'0';\n  while((c=getchar())>='0'&&c<='9')\n    res=res*10+c-'0';\n  return res*sign;\n}\nvoid dfs(int u,int p) //\u500d\u589e\u9884\u5904\u7406\u4e4bdfs\uff0c\u4f5c\u7528\u6709\u4e8c\uff1a1.\u6807\u8bb0\u6bcf\u4e2a\u70b9\u5728\u6811\u4e2d\u7684\u6df1\u5ea6 2.\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2\uff082\u76840\u6b21\u65b9\u4ee3\u7956\u5148\uff09\n{\n  d[u]=d[p]+1;\n  fa[u][0]=p;\n  time++;\n  l[u]=time;\n  for(register int i=0; i<g[u].size(); i++)\n  {\n    int v=g[u][i];\n    if(v!=p) dfs(v,u);\n  }\n  r[u]=time;\n}\nint lca(int u,int v) //\u500d\u589e\u6c42LCA\n{\n  if(d[u]<d[v]) swap(u,v); //\u8ba9\u6df1\u5ea6\u5927\u7684\u5411\u4e0a\u8df3\uff0c\u76f4\u5230u\u3001v\u6df1\u5ea6\u76f8\u540c\n  for(register int k=20; k>=0; k--)\n    if(d[u]-d[v]>=(1<<k)) u=fa[u][k]; \n  if(u==v) return u; //\u5982\u679c\u5df2\u7ecf\u6c47\u6210\u4e00\u70b9\uff0c\u90a3\u4e48\u8fd9\u70b9\u5c31\u662fLCA\n  for(register int k=20; k>=0; k--)\n    if(fa[u][k]!=fa[v][k]) //\u5426\u5219u\u548cv\u4e00\u8d77\u5411\u4e0a\u8df3\uff0c\u76f4\u5230\u62e5\u6709\u76f8\u540c\u7236\u4eb2\n    {\n      u=fa[u][k];\n      v=fa[v][k];\n    }\n  return(fa[u][0]); //\u6c42\u5f97u\u548cv\u7684LCA\n}\ninline void add(int i,int d) //\u6811\u72b6\u6570\u7ec4\u5355\u70b9\u4fee\u6539\n{\n  while(i<=n)\n  {\n    t[i]+=d;\n    i+=i&-i; \n  }\n}\ninline int sum(int i) //\u6811\u72b6\u6570\u7ec4\u524d\u7f00\u548c\u7ef4\u62a4\n{\n  int s=0;\n  while(i>0)\n  {\n    s+=t[i];\n    i-=i&-i;\n  }\n  return s;\n}\nint main()\n{\n  n=read(); m=read();\n  for(register int i=1; i<=n-1; i++) \n  {\n    int u,v; \n    u=read(); v=read();\n    g[u].push_back(v); //\u5efa\u6811\uff0c\u53cc\u5411\u6709\u5411\u8fb9\n    g[v].push_back(u); \n  } \n  dfs(1,0);\n  for(register int k=1; k<=20; k++) //\u500d\u589e\u9884\u5904\u7406\u4e4bfa\u6570\u7ec4\uff08\u5176\u4e2dk\u53d6logn\u5de6\u53f3\u7684\u4e00\u4e2a\u6570\u5373\u53ef\uff0c\u53ef\u4ee5\u7a0d\u5fae\u53d6\u5927\u4e00\u4e9b\uff09\n    for(register int u=1; u<=n; u++)\n      fa[u][k]=fa[fa[u][k-1]][k-1]; //u\u76842\u7684k\u6b21\u65b9\u4ee3\u7956\u5148\u662fu\u76842\u7684k-1\u6b21\u65b9\u4ee3\u7956\u5148\u76842\u7684k-1\u6b21\u65b9\u4ee3\u7956\u5148\uff08\u597d\u7ed5\u554a\u3002\u3002\u3002\uff09\n  for(register int i=1; i<=m; i++) \n  {\n    char cmd; int u,v;\n    scanf(\"%s\",&cmd); u=read(); v=read();\n    if(cmd=='P')\n    {\n      int p=lca(u,v); //\u67e5\u8be2LCA\n      add(l[u],1);\n      add(l[v],1);\n      add(l[p],-2); //\u6811\u72b6\u6570\u7ec4\u5dee\u5206\u601d\u60f3\uff0c\u5148\u52a0\u5230\u4e24\u5904\uff0c\u518d\u5728\u4e00\u5904\u51cf\u56de\n    } \n    else\n    {\n      if(d[u]<d[v]) u=v; //\u4fdd\u8bc1\u6df1\u5ea6\u5927\u7684\u4e3au\uff0c\u5c0f\u7684\u4e3av\n      printf(\"%d\\n\",sum(r[u])-sum(l[u]-1)); \n    } //\u6811\u72b6\u6570\u7ec4\u67e5\u8be2r[u]\u548cl[u]\u4e4b\u95f4\u7684\u533a\u95f4\u548c\uff08\u524d\u7f00\u548c\u76f8\u51cf\uff09\n  }\n  return 0; \n} //\u7ed3\u675f\n```",
        "postTime": 1531442256,
        "uid": 9156,
        "name": "\u5fae\u96e8\u71d5\u53cc\u98de",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "## \u9898\u76ee\u5927\u610f\uff1a\n\n\u7ed9\u5b9a\u4e00\u4e2a\u6709N\u4e2a\u8282\u70b9\u7684\u6811\u53caM\u4e2a\u64cd\u4f5c\uff1aP\u64cd\u4f5c\u628a\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u52a0\u4e00\uff0cQ\u64cd\u4f5c\u8be2\u95ee\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u6743\u503c\u548c\u3002\n\n\n\n## \u9898\u89e3\uff1a\n\n\u4e00\u9053\u6811\u94fe\u5256\u5206\u7684\u9898\u3002\uff08\u677f\u5b50\u9898\u90fd\u662f\u7d2b\u9898\u4e86\u4e3a\u5565\u8fd9\u9898\u8fd8\u662f\u84dd\uff1f\uff09\n\n\u96be\u70b9\u6709\u4e8c\uff1a\n\n\u4e00\uff1a\u8fb9\u6743\u8f6c\u70b9\u6743\u3002\n\n\u4e8c\uff1a\u8def\u5f84\u548c\u7684\u67e5\u8be2\u3002\n\n\u5bf9\u4e8e\u5bf9\u6811\u94fe\u5256\u5206\u4e0d\u662f\u548c\u719f\u6089\u7684\u5c0f\u4f19\u4f34\uff0c\u63a8\u8350\u4e0b\u9762\u7684\u8fd9\u7bc7\u535a\u5ba2\uff0c\u91cc\u9762\u6709\u5bf9\u6811\u94fe\u5256\u5206\u7684\u8be6\u7ec6\u8bb2\u89e3\u3002\n\n[\u6d45\u8c08\u6811\u94fe\u5256\u5206](https://www.cnblogs.com/fusiwei/p/11519470.html)\n\n\u6211\u4eec\u4f1a\u53d1\u73b0\uff0c\u6811\u94fe\u5256\u5206\u662f\u4e00\u4e2a\u5bf9\u70b9\u6743\u8fdb\u884c\u64cd\u4f5c\u7684\u4e1c\u897f\u3002\n\n\u800c\u9898\u76ee\u8981\u6c42\u662f\u8fb9\u6743\u3002\n\n\u6240\u4ee5\u6211\u4eec\u8981\u628a\u8fb9\u6743\u8f6c\u70b9\u6743~~\uff08\u5e9f\u8bdd\uff09~~\u3002\n\n\u600e\u4e48\u8f6c\u5462\uff1f\n\n\u6211\u4eec\u4f1a\u53d1\u73b0\u4e00\u6761\u8fb9\u8fde\u7740\u4e24\u4e2a\u70b9\uff0c\u56e0\u4e3a\u9898\u76ee\u4fdd\u8bc1\u7ed9\u51fa\u7684\u662f\u4e00\u68f5\u6811\u3002\u6211\u4eec\u4f1a\u53d1\u73b0\uff1a\u4e00\u4e2a\u70b9\u53ef\u80fd\u4f1a\u6709\u5f88\u591a\u4e2a\u513f\u5b50\uff08\u4e5f\u5c31\u662f\u8bf4\u6709\u5f88\u591a\u8fde\u7740\u513f\u5b50\u7684\u8fb9\uff09\uff0c\u4f46\u662f\u6bcf\u4e2a\u513f\u5b50\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\u3002\u5bf9\u5e94\u5730\u4e00\u5c42\u4e00\u5c42\u7c7b\u6bd4\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u5230\u53f6\u5b50\u8282\u70b9\u7684\u65f6\u5019\uff0c\u5b83\u8fde\u513f\u5b50\u4e5f\u6ca1\u6709\u3002\n\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u8003\u8651\u628a\u8fb9\u6743\u53d8\u6210\u5176\u513f\u5b50\u8282\u70b9\u7684\u70b9\u6743\uff0c\u90a3\u4e48\u6839\u8282\u70b9\u7684\u70b9\u6743\u4e3a0\uff0c\u800c\u5176\u4ed6\u6240\u6709\u8fb9\u7684\u8fb9\u6743\u90fd\u88ab\u6620\u5c04\u5230\u4e86\u4e00\u4e2a\u70b9\u4e0a\u3002\n\n\u622a\u81f3\u8fd9\u91cc\uff0c\u6211\u4eec\u89e3\u51b3\u4e86\u7b2c\u4e00\u4e2a\u95ee\u9898\u3002\n\n\u5982\u679c\u6211\u4eec\u5230\u8fd9\u91cc\u5c31\u5b8c\u4e8b\u7684\u8bdd\uff0c\u6211\u4eec\u6700\u7ec8\u4f1a\u5168WA\u3002\n\n\u4e3a\u4ec0\u4e48\u5462\uff1f\n\n\u8fd8\u662f\u56e0\u4e3a\u9898\u76ee\u4e2d\u8be2\u95ee\u7684\u662f\u8fb9\u6743\u3002\u5982\u679c\u662f\u4e00\u4e2a\u8def\u5f84\u7684\u8bdd\uff0c\u6bd4\u5982\u9898\u76ee\u4e2d\u60f3\u6c42\u5f97\u4e24\u6761\u8fb9\u7684\u6743\u503c\uff0c\u4f46\u662f\u6211\u4eec\u6620\u5c04\u5b8c\u4e86\u4e4b\u540e\u4f1a\u6c42\u5f973\u4e2a\u70b9\u7684\u70b9\u6743\uff0c\u4e5f\u5c31\u610f\u5473\u7740\uff0c\u6211\u4eec\u591a\u641e\u4e86\u4e00\u4e2a\u7b54\u6848\u3002\u8fd9\u663e\u7136\u662f\u4e0d\u7b26\u5408\u6b63\u786e\u6027\u7684\u3002\n\n\u56e0\u4e3a\u6211\u4eec\u662f\u5411\u5b50\u8282\u70b9\u6620\u5c04\uff0c\u6240\u4ee5\u6211\u4eec\u591a\u52a0\u7684\u5176\u5b9e\u662f\u76ee\u6807\u70b9\u7684LCA\u90a3\u4e2a\u70b9\u7684\u70b9\u6743\u3002\n\n\u6240\u4ee5\u6211\u4eec\u8003\u8651\u628aLCA\u90a3\u4e2a\u70b9\u7684\u70b9\u6743\u51cf\u6389\u3002\n\n\u90a3\u4e48\u6211\u4eec\u56de\u987e\u4e00\u4e0b\u6811\u94fe\u5256\u5206\u6c42LCA\u7684\u8fc7\u7a0b\uff08\u5982\u6709\u4e0d\u61c2\u8fd8\u662f\u7ffb\u4e0a\u9762\u7684\u90a3\u7bc7\u535a\u5ba2\uff09\n\n\u6211\u4eec\u8df3\u6765\u8df3\u53bb\uff0c\u6700\u540e\u8df3\u7684\u90a3\u4e00\u6b21\u5c31\u80fd\u6c42\u5230LCA\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u4e3a\u4e86\u7ef4\u62a4\u67e5\u8be2\u7684\u6b63\u786e\u6027\uff0c\u9700\u8981\u628a\u6700\u540e\u4e00\u6b21\u8df3\u8dc3\u7684\u66f4\u6d45\u7684\u90a3\u4e2a\u8282\u70b9\u53d8\u6210\u5b83\u7684\u5b50\u8282\u70b9\u3002\u8fd9\u6837\u5c31\u80fd\u4fdd\u8bc1\uff0cLCA\u4e0d\u4f1a\u88ab\u52a0\u8fdb\u6765\u3002\n\n\u8fd9\u4e2a\u64cd\u4f5c\u7684\u6b63\u786e\u6027\u662f\u663e\u7136\u7684\u3002\u56e0\u4e3aLCA\u8df3\u5230\u6700\u540e\uff0c\u4e24\u4e2a\u8282\u70b9\u5fc5\u7136\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u3002\u800c\u6839\u636e\u6811\u94fe\u5256\u5206\u7684\u9884\u5904\u7406\u64cd\u4f5c\uff0c\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u8282\u70b9\u7f16\u53f7\u662f\u8fde\u7eed\u7684\uff0c\u90a3\u4e48\u6211\u4eec\u5bfb\u627eLCA\u8fdb\u884c\u8df3\u8dc3\u7684\u65f6\u5019\uff0cid[x]\u5c31\u662f\u6211\u4eec\u7684LCA\uff0c\u90a3\u4e48\u6211\u4eec\u628a\u5b83+1\uff0c\u5c31\u4f1a\u5f97\u5230\u5b83\u7684\u513f\u5b50\u8282\u70b9\uff0c\u8fd9\u6837\uff0cLCA\u5c31\u4e0d\u4f1a\u88ab\u52a0\u8fdb\u6765\u3002\n\n\u4ee3\u7801\u52a0\u6df1\u7406\u89e3\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#pragma GCC optimize(1)\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#define lson pos<<1\n#define rson pos<<1|1\nusing namespace std;\nconst int maxn=1e5+1;\nint n,m,tot,cnt;\nint a[maxn];\nint head[maxn],nxt[maxn<<1],to[maxn<<1];\nint deep[maxn],size[maxn],son[maxn],fa[maxn];\nint top[maxn],id[maxn],w[maxn];\nint tree[maxn<<2],lazy[maxn<<2];\nvoid add(int x,int y)\n{\n    to[++tot]=y;\n    nxt[tot]=head[x];\n    head[x]=tot;\n}\nvoid dfs1(int x,int f)\n{\n    deep[x]=deep[f]+1;\n    size[x]=1;\n    fa[x]=f;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y==f)\n            continue;\n        dfs1(y,x);\n        size[x]+=size[y];\n        if(!son[x]||size[y]>size[son[x]])\n            son[x]=y;\n    }\n}\nvoid dfs2(int x,int t)\n{\n    id[x]=++cnt;\n    w[cnt]=a[x];\n    top[x]=t;\n    if(!son[x])\n        return;\n    dfs2(son[x],t);\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y==fa[x]||y==son[x])\n            continue;\n        dfs2(y,y);\n    }\n}\nvoid build(int pos,int l,int r)\n{\n    int mid=(l+r)>>1;\n    if(l==r)\n    {\n        tree[pos]=w[l];\n        return;\n    }\n    build(lson,l,mid);\n    build(rson,mid+1,r);\n    tree[pos]=tree[lson]+tree[rson];\n}\nvoid mark(int pos,int l,int r,int k)\n{\n    tree[pos]+=(r-l+1)*k;\n    lazy[pos]+=k;\n}\nvoid pushdown(int pos,int l,int r)\n{\n    int mid=(l+r)>>1;\n    mark(lson,l,mid,lazy[pos]);\n    mark(rson,mid+1,r,lazy[pos]);\n    lazy[pos]=0;\n}\n\nvoid update(int pos,int l,int r,int x,int y,int k)\n{\n    int mid=(l+r)>>1;\n    if(x<=l && r<=y)\n    {\n        mark(pos,l,r,k);\n        return;\n    }\n    pushdown(pos,l,r);\n    if(x<=mid)\n        update(lson,l,mid,x,y,k);\n    if(y>mid)\n        update(rson,mid+1,r,x,y,k);\n    tree[pos]=tree[lson]+tree[rson];\n}\n\nvoid upd_chain(int x,int y,int k)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]])\n            swap(x,y);\n        update(1,1,n,id[top[x]],id[x],k);\n        x=fa[top[x]];\n    }\n    if(deep[x]<deep[y])\n        swap(x,y);\n    update(1,1,n,id[y]+1,id[x],k);\n}\nint query(int pos,int l,int r,int x,int y)\n{\n    int ret=0;\n    int mid=(l+r)>>1;\n    if(x<=l && r<=y)\n        return tree[pos];\n    pushdown(pos,l,r);\n    if(x<=mid)\n        ret+=query(lson,l,mid,x,y);\n    if(y>mid)\n        ret+=query(rson,mid+1,r,x,y);\n    return ret;\n}\nint q_chain(int x,int y)\n{\n    int ret=0;\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]])\n            swap(x,y);\n        ret+=query(1,1,n,id[top[x]],id[x]);\n        x=fa[top[x]];\n    }\n    if(deep[x]<deep[y])\n        swap(x,y);\n    ret+=query(1,1,n,id[y]+1,id[x]);\n    return ret;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    build(1,1,n);\n    while(m--)\n    {\n        char ch;\n        cin>>ch;\n        if(ch=='P')\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            upd_chain(x,y,1);\n        }\n        else\n        {\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%d\\n\",q_chain(x,y));\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1569243220,
        "uid": 175131,
        "name": "\u5085\u601d\u7ef4666",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "```\n//\u6811\u5256\u662f\u5728\u70b9\u4e0a\u64cd\u4f5c\u7684\uff0c\u8fd9\u9053\u9898\u662f\u8fb9\n//\u90a3\u4e48\u600e\u4e48\u628a\u8fb9\u6743\u8f6c\u6210\u70b9\u6743\u5462\uff1f\n//\u6839\u636e\u6811\u7684\u6027\u8d28\u53ef\u4ee5\u77e5\u9053\uff0c\u4e00\u4e2a\u70b9\u53ef\u4ee5\u6709\u591a\u4e2a\u513f\u5b50\uff0c\u4f46\u662f\u53ea\u4f1a\u6709\u4e00\u4e2a\u7238\u7238\uff0c\n//\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u628a\u8fd9\u4e2a\u70b9\u548c\u5b83\u7238\u7238\u4e4b\u95f4\u7684\u90a3\u6761\u8fb9\u7684\u8fb9\u6743\u8f6c\u79fb\u5230\u8fd9\u4e2a\u70b9\u4e0a\u6765\n//\u7528\u8fd9\u4e2a\u70b9\u7684\u70b9\u6743\u6765\u8868\u793a\u8fd9\u6761\u8fb9\u7684\u6743\u503c\n//\u56e0\u4e3a\u6839\u8282\u70b9\u6ca1\u6709\u7238\u7238\uff0c\u6240\u4ee5\u5b83\u4e0d\u8868\u793a\u4efb\u4f55\u8fb9\u6743\uff0c\u70b9\u6743\u4e3a0\n//\u4f46\u662f\u6211\u4eec\u600e\u4e48\u6837\u624d\u80fd\u4e0d\u628a\u4e24\u4e2a\u70b9\u7684\u516c\u5171\u7956\u5148\u7684\u6743\u503c\u7b97\u8fdb\u53bb\u554a\uff1f\n//node[fx].s+1? \u4e0d\u884c\uff0c\u8fd9\u662f\u5b83\u7684\u91cd\u513f\u5b50\u7684\u4f4d\u7f6e\n// \u8003\u8651\u4e00\u4e0b\uff0c\u6211\u4eec\u5728Query\u6216\u8005Modify\u7684\u65f6\u5019\uff0c\u90fd\u662f\u5f53x\u548cy\u540c\u65f6\u5904\u4e8e\u4e00\u6761\u94fe\u4e86\u4e4b\u540e\u5c31break\n//\u7136\u540e\u518d\u628a\u8fd9\u6761\u94fe\u52a0\u4e0a\uff0c\u6700\u8fd1\u516c\u5171\u7956\u5148\u4e0d\u5c31\u662f\u8fd9\u6761\u94fe\u7684top\u561b\uff01\n//\u6240\u4ee5\uff0c\u6211\u4eec\u5728while\u5faa\u73af\u5916\u8fb9\u5199node[x].s+1\u5c31\u53ef\u4ee5\u4e0d\u7b97\u4e0a\u516c\u5171\u7956\u5148\u4e86\u3002\n//\u4f46\u662f\u4e5f\u8981\u6ce8\u610f\uff0c\u5982\u679c\u6700\u540e\u662f\u6761\u8f7b\u8fb9\uff0c\u6211\u4eec\u5c31\u8981if\u7279\u5224\u4e00\u4e0b\uff0c\u4e0d\u80fd\u8ba9\u4ed6\u8fdb\u7ebf\u6bb5\u6811\u67e5\u8be2\u4e86\n//\u56e0\u4e3a\u5982\u679c\u662f\u8f7b\u8fb9\u7684\u8bdd\uff0c\u6700\u540e\u7684\u90a3\u6761\u94fe\u9000\u5316\u6210\u4e86\u6700\u8fd1\u516c\u5171\u7956\u5148\u8fd9\u4e00\u4e2a\u70b9\uff0c\u4e0d\u80fd\u8981\uff01 \n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5+5;\n\nint n,m;\nint w[N];\nint head[N],num_edge;\nstruct Edge\n{\n\tint v,nxt;\n}edge[N<<1];\nstruct Node\n{\n\tint fa,son;\n\tint dep,top;\n\tint size;\n\tint s,t;\n}node[N];\nstruct TREE\n{\n\tTREE *lson,*rson;\n\tint l,r,mid,len;\n\tint num,lazy;\n}tree[N<<2];\n\ntypedef TREE* Tree;\nTree Root,now_node=tree;\n\ninline int read()\n{\n\tchar c=getchar();int num=0;\n\tfor(;!isdigit(c);c=getchar())\n\t\tif(c=='P') return 1;\n\t\telse if(c=='Q')\treturn 2;\n\tfor(;isdigit(c);c=getchar())\n\t\tnum=num*10+c-'0';\n\treturn num;\n}\n\ninline void add_edge(int u,int v)\n{\n\tedge[++num_edge].v=v;\n\tedge[num_edge].nxt=head[u];\n\thead[u]=num_edge;\n}\n\nvoid dfs1(int u)\n{\n\tnode[u].size=1;\n\tfor(int i=head[u],v;i;i=edge[i].nxt)\n\t{\n\t\tv=edge[i].v;\n\t\tif(v==node[u].fa)\n\t\t\tcontinue;\n\t\tnode[v].fa=u;\n\t\tnode[v].dep=node[u].dep+1;\n\t\tdfs1(v);\n\t\tnode[u].size+=node[v].size;\n\t\tif(node[v].size>node[node[u].son].size)\n\t\t\tnode[u].son=v;\n\t}\n}\n\nint bound;\nvoid dfs2(int u,int top)\n{\n\tnode[u].top=top;\n\tnode[u].s=++bound;\n\tif(node[u].son)\n\t{\n\t\tdfs2(node[u].son,top);\n\t\tfor(int i=head[u],v;i;i=edge[i].nxt)\n\t\t{\n\t\t\tv=edge[i].v;\n\t\t\tif(v==node[u].son||v==node[u].fa)\n\t\t\t\tcontinue;\n\t\t\tdfs2(v,v);\n\t\t}\n\t}\n\tnode[u].t=bound;\n}\n\nvoid build(Tree &root,int l,int r)\n{\n\troot=++now_node;\n\troot->l=l,root->r=r,root->mid=l+r>>1,root->len=r-l+1;\n\tif(l==r)\n\t\treturn;\n\tbuild(root->lson,l,root->mid);\n\tbuild(root->rson,root->mid+1,r);\n}\n\ninline void pushdown(Tree root)\n{\n\tif(root->lazy)\n\t{\n\t\troot->lson->lazy+=root->lazy;\n\t\troot->rson->lazy+=root->lazy;\n\t\troot->lson->num+=root->lson->len*root->lazy;\n\t\troot->rson->num+=root->rson->len*root->lazy;\n\t\troot->lazy=0;\n\t}\n}\n\nvoid update(Tree root,int l,int r)\n{\n\tif(root->l==l&&r==root->r)\n\t{\n\t\troot->num+=root->len;\n\t\troot->lazy+=1;\n\t\treturn;\n\t}\n\tpushdown(root);\n\tif(r<=root->mid)\n\t\tupdate(root->lson,l,r);\n\telse if(l>root->mid)\n\t\tupdate(root->rson,l,r);\n\telse\n\t{\n\t\tupdate(root->lson,l,root->mid);\n\t\tupdate(root->rson,root->mid+1,r);\n\t}\n\troot->num=root->lson->num+root->rson->num;\n}\n\nint query(Tree root,int l,int r)\n{\n\tif(root->l==l&&root->r==r)\n\t\treturn root->num;\n\tpushdown(root);\n\tif(r<=root->mid)\n\t\treturn query(root->lson,l,r);\n\telse if(l>root->mid)\n\t\treturn query(root->rson,l,r);\n\telse\n\t\treturn query(root->lson,l,root->mid)+query(root->rson,root->mid+1,r);\n}\n\ninline void Modify(int x,int y)\n{\n\tint fx=node[x].top,fy=node[y].top;\n\twhile(fx!=fy)\n\t{\n\t\tif(node[fx].dep>node[fy].dep)\n\t\t{\n\t\t\tupdate(Root,node[fx].s,node[x].s);\n\t\t\tx=node[fx].fa;\n\t\t\tfx=node[x].top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(Root,node[fy].s,node[y].s);\n\t\t\ty=node[fy].fa;\n\t\t\tfy=node[y].top;\n\t\t}\n\t}\n\tif(x!=y)\n\t{\n\t\tif(node[x].dep>node[y].dep)\n\t\t\tupdate(Root,node[y].s+1,node[x].s);\n\t\telse\n\t\t\tupdate(Root,node[x].s+1,node[y].s);\n\t}\n}\n\ninline int Query(int x,int y)\n{\n\tint fx=node[x].top,fy=node[y].top;\n\tint ans=0;\n\twhile(fx!=fy)\n\t{\n\t\tif(node[fx].dep>node[fy].dep)\n\t\t{\n\t\t\tans+=query(Root,node[fx].s,node[x].s);\n\t\t\tx=node[fx].fa;\n\t\t\tfx=node[x].top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=query(Root,node[fy].s,node[y].s);\n\t\t\ty=node[fy].fa;\n\t\t\tfy=node[y].top;\n\t\t}\n\t}\n\tif(x!=y)\n\t{\n\t\tif(node[x].dep>node[y].dep)\n\t\t\treturn ans+query(Root,node[y].s+1,node[x].s);\n\t\telse\n\t\t\treturn ans+query(Root,node[x].s+1,node[y].s);\n\t}\n\treturn ans;\n}\n\nint opt,u,v;\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tu=read(),v=read();\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs1(1);\n\tdfs2(1,1);\n\tbuild(Root,1,n);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\topt=read(),u=read(),v=read();\n\t\tif(opt==1)\n\t\t\tModify(u,v);\n\t\telse\n\t\t\tprintf(\"%d\\n\",Query(u,v));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1520771895,
        "uid": 39886,
        "name": "Drifterming",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u660e\u663e\u7684\u4e00\u9053**\u6811\u94fe\u5256\u5206**\n\n\u9996\u5148\uff0c\u9898\u76ee\u5f3a\u8c03\u7684\u52a0\u6743**\u662f\u8fb9\u800c\u4e0d\u662f\u70b9**\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5c06\u4e3a\u8fb9\u52a0\u6743\u8f6c\u5316\u6210\u4e3a\u70b9\u52a0\u6743\u3002\n\n\u5bf9\u4e8e\u6bcf\u6761\u8fb9\uff0c\u6211\u4eec\u5c06\u5176\u6df1\u5ea6\u66f4\u5927\u7684\u7aef\u70b9\u52a0\u6743\uff0c\u5219\u533a\u95f4 [l, r] \u7684\u52a0\u6743\uff08\u6216\u8be2\u95ee\uff09\u5373\u4e3a\u53bb\u6389\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\uff0c\u7ed9\u5176\u4f59\u70b9\u52a0\u6743\uff08\u6216\u8be2\u95ee\uff09\u3002\n\n\u8fd9\u4e48\u4e00\u542c\u5904\u7406\u8d77\u6765\u4f3c\u4e4e\u5f88\u9ebb\u70e6\uff0c\u4f46\u6211\u4eec\u53ef\u4ee5\u601d\u8003\u4e0b\u6811\u5256\u67e5\u8be2\u7684\u8fc7\u7a0b\uff1a\n\n1\uff09\u6700\u540e\u4e00\u6b21\u6811\u5256\u67e5\u8be2\u65f6\uff0c\u5f53\u524d\u4e24\u70b9 x,y \u5fc5\u5b9a\u5728\u540c\u4e00\u91cd\u94fe\u4e0a\uff08y \u7684\u6df1\u5ea6\u5c0f\u4e8e x\uff09\uff1b\n\n2\uff09\u6839\u636e\u5904\u7406\u524d\u7684 dfs \u5e8f\uff0c\u6211\u4eec\u662f\u4f18\u5148\u904d\u5386\u91cd\u513f\u5b50\uff0c\u90a3\u4e48\u91cd\u513f\u5b50\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\u4e00\u5b9a\u7d27\u90bb\u5176\u7236\u8282\u70b9\uff08\u5373\u4e3a\u5176\u7236\u8282\u70b9\u7f16\u53f7 + 1\uff09\uff0c\u5219\u6211\u4eec\u8981\u5ffd\u7565\u6df1\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9 y \uff0c\u5373\u4e3a\u5904\u7406\u533a\u95f4 [ y \u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7 + 1\uff0c x \u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7]\uff08\u53e6\u5916\u8fd8\u8981\u6ce8\u610f\u7684\u662f\uff0cy = x \u65f6\u5728\u7ebf\u6bb5\u6811\u5185\u6267\u884c\u4f1a\u51fa\u9519\uff0c\u6211\u4eec\u8981\u7279\u5224\u8fd9\u79cd\u60c5\u51b5\uff09 \u3002\n\n\u4ee3\u7801\u697c\u4e0b\u5df2\u7ecf\u6709\u4e86\uff0c\u8fd9\u91cc\u732e\u4e11\u518d\u53d1\u4e00\u6ce2\uff0c\u4e5f\u7b97\u662f\u8f83\u4e3a\u7b26\u5408\u81ea\u5df1\u7684\u5206\u6790\uff1a\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define sL (s << 1)\n#define sR (s << 1 | 1) \nusing namespace std;\nconst int Maxn = 0x3f3f3f3f;\nconst int N = 1e5 + 5;\nint top[N], idx[N], pos[N], sze[N], son[N], fa[N], vis[N], dep[N], T;\nint lst[N], to[N << 1], nxt[N << 1], sum[N << 2], val[N << 2], n, m, E;\ntemplate <class T> inline void Swap(T &a, T &b) {a ^= b; b ^= a; a ^= b;}\ninline int get()\n{\n    char ch; bool f = false; int res = 0;\n    while (((ch = getchar()) < '0' || ch > '9') && ch != '-');\n    if (ch == '-') f = true;\n     else res = ch - '0';\n    while ((ch = getchar()) >='0' && ch <= '9')\n        res = (res << 3) + (res << 1) + ch - '0';\n    return f? ~res + 1 : res;\n}\ninline void put(int x)\n{\n    if (x < 0)\n      x = ~x + 1, putchar('-');\n    if (x > 9) put(x / 10);\n    putchar(x % 10 + 48);\n}\ninline void add(const int x, const int y)\n{\n    nxt[++E] = lst[x]; lst[x] = E; to[E] = y;\n    nxt[++E] = lst[y]; lst[y] = E; to[E] = x; \n}\ninline void dfs1(const int x, const int ls)\n{\n    sze[x] = 1; int y;\n    fa[x] = ls; dep[x] = dep[ls] + 1;\n    for (int i = lst[x]; i, y = to[i]; i = nxt[i])\n    {\n        if (y == ls) continue;\n        dfs1(y, x);\n        sze[x] += sze[y];\n        if (sze[y] > sze[son[x]]) son[x] = y;\n    }\n}\ninline void dfs2(const int x)\n{\n    if (son[x])\n    {\n        pos[son[x]] = ++T;\n        top[son[x]] = top[x];\n        idx[T] = son[x];\n        dfs2(son[x]);\n    }\n    int y;\n    for (int i = lst[x]; i, y = to[i]; i = nxt[i])\n    if (!top[y])\n    {\n        pos[y] = ++T;\n        idx[T] = y;\n        top[y] = y;\n        dfs2(y);\n    }\n}\ninline void Push(const int s)\n{\n    sum[s] = sum[sL] + sum[sR]; \n}\ninline void Add(const int s, const int k, const int z)\n{\n    val[s] += z;\n    sum[s] += (k * z);\n}\ninline void Down(const int s, const int l, const int r, const int mi)\n{\n    if (!val[s]) return;\n    Add(sL, mi - l + 1, val[s]);\n    Add(sR, r - mi, val[s]);\n    val[s] = 0;\n}\ninline void Und(const int s, const int l, const int r, const int x, const int y)\n{\n    if (l == x && r == y) return Add(s, r - l + 1, 1);\n    int mid = l + r >> 1;\n    Down(s, l, r, mid);\n    if (y <= mid) Und(sL, l, mid, x, y);\n    else if (x > mid) Und(sR, mid + 1, r, x, y);\n    else \n    {\n        Und(sL, l, mid, x, mid);\n        Und(sR, mid + 1, r, mid + 1, y);\n    }\n    Push(s);\n}\ninline void PaUnd(const int u, const int v)\n{\n    int x = u, y = v, res = 0;\n    while (top[x] != top[y])\n    {\n        if (dep[top[x]] < dep[top[y]]) Swap(x, y);\n        Und(1, 1, T, pos[top[x]], pos[x]);\n        x = fa[top[x]];\n    }\n    if (y == x) return ;\n    if (dep[x] < dep[y]) Swap(x, y);\n    Und(1, 1, T, pos[y] + 1, pos[x]);\n}\ninline int Que(const int s, const int l, const int r, const int x, const int y)\n{\n    if (l == x && r == y) return sum[s];\n    int mid = l + r >> 1;\n    Down(s, l, r, mid);\n    if (y <= mid) return Que(sL, l, mid, x, y);\n    else if (x > mid) return Que(sR, mid + 1, r, x, y);\n    else return Que(sL, l, mid, x, mid) +\n                Que(sR, mid + 1, r, mid + 1, y);\n}\ninline int PaQue(const int u, const int v)\n{\n    int x = u, y = v, res = 0;\n    while (top[x] != top[y])\n    {\n        if (dep[top[x]] < dep[top[y]]) Swap(x, y);\n        res += Que(1, 1, T, pos[top[x]], pos[x]);\n        x = fa[top[x]];\n    }\n    if (x == y) return res;\n    if (dep[x] < dep[y]) Swap(x, y);\n    return res + Que(1, 1, T, pos[y] + 1, pos[x]);\n}\ninline void Init()\n{\n    dfs1(1, 0);\n    idx[1] = pos[1] = top[1] = T = 1;\n    dfs2(1);\n} \nint main()\n{\n    n = get(); m = get(); char tp; int x, y;\n    while (--n) add(get(), get());\n    Init(); \n    while (m--)\n    {\n        while ((tp = getchar()) != 'P' && tp != 'Q');\n        x = get(); y = get();\n        if (tp == 'P') PaUnd(x, y);\n         else put(PaQue(x, y)), putchar('\\n');\n    } \n    return 0;\n}\n\n```",
        "postTime": 1495278882,
        "uid": 17952,
        "name": "Log_x",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "$$\\color{cornflowerblue}{\\mathcal{Treaker}}$$\n# \u6811\u94fe\u5256\u5206\n\u8fd9\u4e0d\u5c31\u662f\u4e2a**\u9898\u561b\u3002\n\n\u76f4\u63a5\u6811\u5256\u5207\u4e86\u3002\n\n\u6211\u4eec\u628a\u8fb9\u6743\u8f6c\u5316\u4e3a\u70b9\u6743\u3002\n\n\u5bf9\u4e8e\u6811\u5256\u6211\u4eec\u7ef4\u62a4\u4e00\u4e0b\u533a\u95f4\u548c \u548c \u6807\u8bb0\u5373\u53ef\u3002\n\n\u6307\u9488\u6811\u5256\u9898\u89e3\u5728\u6b64\u3002\u3002\u3002\n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int N = 1e5+5;\ninline int read()\n{\n\tint x = 0 , f = 1;\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint n , m , cnt;\nint size[N] , top[N] , dfn[N] , hs[N] , dep[N] , fa[N];\nchar s[5];\nstruct Tree_Div\n{\n\tstruct Edge\n\t{\n\t\tint to; Edge *nxt;\n\t\tEdge(int to,Edge *nxt) : to(to) , nxt(nxt) {}\n\t}*head[N];\n\tinline void add(int u,int v) {head[u] = new Edge(v,head[u]);}\n\t#define to (i -> to)\n\tvoid get_tree(int x)\n\t{\n\t\tsize[x] = 1;\n\t\tfor(Edge *i = head[x];i;i = i -> nxt)\n\t\t{\n\t\t\tif(dep[to]) continue;\n\t\t\tdep[to] = dep[x] + 1;\n\t\t\tfa[to] = x;\n\t\t\tget_tree(to);\n\t\t\tsize[x] += size[to];\n\t\t\tif(size[to] > size[hs[x]]) hs[x] = to;\n\t\t}\n\t}\n\tvoid dfs(int x,int topfa)\n\t{\n\t\ttop[x] = topfa;\n\t\tdfn[x] = ++cnt;\n\t\tif(hs[x]) dfs(hs[x],topfa);\n\t\tfor(Edge *i = head[x];i;i = i -> nxt)\n\t\t{\n\t\t\tif(to == fa[x] || to == hs[x]) continue;\n\t\t\tdfs(to,to);\n\t\t}\n\t}\n\tstruct node\n\t{\n\t\tnode *ls, *rs;\n\t\tint l , r , tag , sum;\n\t\tnode(int l,int r) : l(l) , r(r) {ls = rs = NULL; sum = tag = 0;}\n\t\tinline int len() {return r - l + 1;}\n\t\t#define mid ((p -> l + p -> r) >> 1)\n\t\t#define len len()\n\t\tinline void up() {sum = ls -> sum + rs -> sum;}\n\t\tinline void down()\n\t\t{\n\t\t\tif(!tag) return;\n\t\t\tls -> tag += tag; rs -> tag += tag;\n\t\t\tls -> sum += tag * ls -> len; rs -> sum += tag * rs -> len;\n\t\t\ttag = 0;\n\t\t}\n\t}*root;\n\tvoid build(node *&p,int l,int r)\n\t{\n\t\tp = new node(l,r);\n\t\tif(l == r) return;\n\t\tbuild(p -> ls,l,mid); build(p -> rs,mid+1,r);\n\t}\n\tvoid chenge(node *p,int x,int y)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return (void)(p -> tag ++ , p -> sum += p -> len); p -> down();\n\t\tif(x <= mid) chenge(p -> ls,x,y);\n\t\tif(y > mid) chenge(p -> rs,x,y);\n\t\tp -> up();\n\t}\n\tinline void chenge(int x,int y)\n\t{\n\t\twhile(top[x] != top[y])\n\t\t{\n\t\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\t\tchenge(root,dfn[top[x]],dfn[x]);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif(dep[x] < dep[y]) swap(x,y);\n\t\tif(dfn[y] < dfn[x]) chenge(root,dfn[y]+1,dfn[x]);\n\t}\n\tint query(node *p,int x,int y)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return p -> sum; p -> down();\n\t\treturn (x <= mid ? query(p -> ls,x,y) : 0) + (y > mid ? query(p -> rs,x,y) : 0);\n\t}\n\tinline int query(int x,int y)\n\t{\n\t\tint res = 0;\n\t\twhile(top[x] != top[y])\n\t\t{\n\t\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\t\tres += query(root,dfn[top[x]],dfn[x]);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif(dep[x] < dep[y]) swap(x,y);\n\t\tif(dfn[y] < dfn[x]) res += query(root,dfn[y]+1,dfn[x]);\n\t\treturn res;\n\t}\n\tinline void LOL()\n\t{\n\t\tn = read(); m = read();\n\t\tfor(int i = 1 , u , v;i < n;i ++)\n\t\t{\n\t\t\tu = read(); v = read();\n\t\t\tadd(u,v); add(v,u);\n\t\t} dep[1] = 1;\n\t\tget_tree(1); dfs(1,1);\n\t\tbuild(root,1,n);\n\t\tfor(int i = 1 , u , v;i <= m;i ++)\n\t\t{\n\t\t\tscanf(\"%s\",s); u = read(); v = read();\n\t\t\tif(s[0] == 'P') chenge(u,v);\n\t\t\telse printf(\"%d\\n\",query(u,v));\n\t\t}\n\t}\n}DNF;\nint main()\n{\n\tDNF.LOL();\n\treturn 0;\n}\n```",
        "postTime": 1571464200,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u6811\u4e0a\u8fb9\u6709\u8fb9\u6743\uff0c\u8003\u8651\u5230\u4e00\u4e2a\u8282\u70b9\u53ef\u80fd\u6709\u591a\u4e2a\u5b50\u8282\u70b9\uff0c\u4f46\u4e00\u5b9a\u53ea\u6709\u4e00\u4e2a\u7236\u8282\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u628a\u4e00\u6761\u8fb9\u4e0a\u7684\u8fb9\u6743\u8f6c\u5316\u6210\u4e3a\u8fd9\u6761\u8fb9\u8fde\u63a5\u7684\u6df1\u5ea6\u66f4\u5927\u7684\u70b9\u7684\u70b9\u6743\uff0c\u8fd9\u6837\u5bf9\u8def\u5f84\u4e0a\u8fb9\u6743\u7684\u64cd\u4f5c\u5c31\u53ef\u4ee5\u8f6c\u5316\u6210\u4e3a\u5bf9\u8def\u5f84\u4e0a\u70b9\u6743\u7684\u64cd\u4f5c\u3002\u7136\u800c\u8def\u5f84$(u,v)$\u7684\u9876\u7aef\u8282\u70b9$LCA(u,v)$\u7684\u6743\u503c\u662f\u4e0d\u7528\u52a0\u7684\u3002\u8054\u7cfb\u6811\u94fe\u5256\u5206\u539f\u7406\uff0c\u4fee\u6539\u8def\u5f84\u4e0a\u70b9\u6743\u7684\u65f6\u5019\uff0c\u6700\u540e\u662f\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u8fdb\u884c\u7684\uff0c\u6b64\u65f6\u6211\u4eec\u628a\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\u7f16\u53f7+1\uff0c\u5c31\u80fd\u907f\u5f00\u5bf9$LCA(u,v)$\u8fdb\u884c\u7684\u4fee\u6539\u3002\n\n\n\n\u67e5\u8be2\u4e00\u6761\u8fb9\u7684\u8fb9\u6743\u4e5f\u5f88\u597d\u505a\u4e86\u3002\u627e\u5230\u8fd9\u6761\u8fb9\u8fde\u63a5\u7684\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\uff0c\u8fd9\u4e2a\u70b9\u7684\u70b9\u6743\u5c31\u662f\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u3002\n\n\u7ec8\u4e8e\u8f6c\u5316\u6210\u4e86\u6811\u5256\u6a21\u677f\u3002\n\n\u8d34\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define rint register int\nconst int N = 300005;\n\ninline int fd() {\n    int x = 0, f = 1; char ch = getchar();\n    while(!isdigit(ch)) {if(ch == '-') f = -f; ch = getchar();}\n    while(isdigit(ch)) {x = x*10+ch-'0'; ch = getchar();}\n    return x*f;\n}\n\nint z[N << 2], col[N << 2];\nint id[N], siz[N], son[N], fa[N], top[N], dep[N];\nint n, m, cnt;\n\nint head[N], edcnt;\nstruct edge {int to, nxt;} ed[N << 1];\ninline void ADD(int x,int y) {\n    ed[++edcnt].nxt = head[x];\n    head[x] = edcnt;\n    ed[edcnt].to = y;\n}\n\n#define lson l, mid, rt<<1\n#define rson mid + 1, r, rt<<1|1\n#define root 1, n, 1\n\ninline int _max(int a,int b) {return a < b ? b : a;}\n\ninline void pushup(int rt) {z[rt] = z[rt << 1] + z[rt << 1 | 1];}\ninline void color(int l,int r,int rt,int v) {\n    z[rt] += (r - l + 1) * v;\n    col[rt] += v;\n}\ninline void pushdown(int l,int r,int rt) {\n    if (col[rt]) {\n        int mid = (l + r) >> 1;\n        color(lson, col[rt]);\n        color(rson, col[rt]);\n        col[rt] = 0;\n    }\n}\nvoid build(int l,int r,int rt) {\n    if(l == r) {\n        z[rt] = 0;\n        return;\n    }\n    int mid = (l+r)>>1;\n    build(lson);\n    build(rson);\n}\nint query(int l,int r,int rt,int k){\n    if(l == r) {\n        return z[rt];\n    }\n    int mid = (l+r)>>1;\n    pushdown(l, r, rt);\n    if(k <= mid) return query(lson,k);\n    else return query(rson,k);\n}\nvoid update(int l,int r,int rt,int L,int R,int v) {\n    if(L<=l && r<=R) {\n        color(l, r, rt, v);\n        return;\n    }\n    int mid = (l+r)>>1;\n    pushdown(l, r, rt);\n    if(L <= mid) update(lson,L,R,v);\n    if(R > mid) update(rson,L,R,v);\n    pushup(rt);\n}\n\nvoid dfs1(int x,int f,int deep) {\n    dep[x] = deep;\n    fa[x] = f;\n    siz[x] = 1;\n    int maxson = -1;\n    for (rint i = head[x]; i; i = ed[i].nxt) {\n        int y = ed[i].to;\n        if (y == f) continue;\n        dfs1(y, x, deep+1);\n        siz[x] += siz[y];\n        if (siz[y] > maxson) {\n            maxson = siz[y];\n            son[x] = y;\n        }\n    }\n}\nvoid dfs2(int x,int topf) {\n    top[x] = topf;\n    id[x] = ++cnt;\n    if (!son[x]) return;\n    dfs2(son[x], topf);\n    for (rint i = head[x]; i; i = ed[i].nxt) {\n        int y = ed[i].to;\n        if (y == fa[x] || y == son[x]) continue;\n        dfs2(y, y);\n    }\n}\ninline void updRange(int x,int y,int v) {\n    while (top[x] != top[y]) {\n        if (dep[top[x]] < dep[top[y]]) swap(x, y);\n        update(root, id[top[x]], id[x], v);\n        x = fa[top[x]];\n    }\n    if (dep[x] > dep[y]) swap(x, y);\n    update(root, id[x]+1, id[y], v);\n}\n\nint a[N], b[N], c[N], o, p, q;\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i < n; ++i) {\n        scanf(\"%d %d\\r\\n\", &o, &p);\n        ADD(o, p); ADD(p, o);\n    }\n    dfs1(1, 0, 1);\n    dfs2(1, 1);\n    build(root);\n    char fk;\n    for (int j = 1; j <= m; ++j) {\n        cin >> fk;\n        scanf(\"%d %d\", &o, &p);\n        switch (fk) {\n        \tcase 'Q' : if (dep[o] < dep[p]) swap(o, p); printf(\"%d\\n\", query(root, id[o])); break;\n        \tcase 'P' : updRange(o, p, 1); break;\n\t\t}\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1549261724,
        "uid": 91822,
        "name": "Qglin_",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u7ef4\u62a4\uff0c\u5957\u4e0a\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u64cd\u4f5c\u3002\u4f46\u662f\u6709\u4e00\u70b9\uff0c\u8fd9\u91cc\u7684create\\_tree\u53ef\u4ee5\u7701\u7565\uff08\u56e0\u4e3a\u521d\u59cb\u4e3a\u7a7a\uff09\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <ctime>\n\nusing namespace std ;\nconst int maxn = 300000 ;\ninline void Read ( int &x ) {\n    char c = getchar() ; bool f = 0 ; x = 0 ;\n    while ( !isdigit(c) ) {\n        if ( c == '-' ) f = 1 ;\n        c = getchar() ;\n    }\n    while ( isdigit(c) ) {\n        x = 10 * x + c - '0' ;\n        c = getchar() ;\n    } if (f) x = -x ;\n}\n\nint n, m, size[maxn], dep[maxn], fa[maxn], top[maxn], w[maxn], son[maxn], cnt ;\nint e, be[maxn], nxt[maxn<<1], to[maxn<<1], tree[maxn<<2], lzy[maxn<<2], a[maxn] ;\n\nvoid init() {\n    memset ( fa, -1, sizeof(fa) ) ;\n    memset ( son, -1, sizeof(son) ) ;\n}\n\nvoid add ( int x, int y ) {\n    to[++e] = y ;\n    nxt[e] = be[x] ;\n    be[x] = e ;\n}\n\nint dfs1 ( int x, int father, int deep ) {\n    fa[x] = father ;\n    dep[x] = deep ;\n    size[x] = 1 ;\n    int i, u ;\n    for ( i = be[x] ; i ; i = nxt[i] ) {\n        u = to[i] ;\n        if ( u == father ) continue ;\n        size[x] += dfs1 ( u, x, deep+1 ) ;\n        if ( son[x] == -1 || size[u] > size[son[x]] ) son[x] = u ;\n    }\n    return size[x] ;\n}\n\nvoid dfs2 ( int x, int Top ) {\n    top[x] = Top ;\n    w[x] = ++cnt ;\n    int i, u ;\n    if ( son[x] ) {\n        for ( i = be[x] ; i ; i = nxt[i] ) {\n            u = to[i] ;\n            if ( u == son[x] ) dfs2 ( u, Top ) ;\n        }\n    } else return ;\n    for ( i = be[x] ; i ; i = nxt[i] ) {\n        u = to[i] ;\n        if ( u == fa[x] || u == son[x] ) continue ;\n        dfs2 ( u, u ) ;\n    }\n}\n\nvoid push_up ( int h ) { tree[h] = tree[h<<1]+tree[h<<1|1] ; }\nvoid push_down ( int h, int len ) {\n    if ( lzy[h] ) {\n        lzy[h<<1] += lzy[h] ;\n        lzy[h<<1|1] += lzy[h] ;\n        tree[h<<1] += ( len-(len>>1) ) * lzy[h] ;\n        tree[h<<1|1] += (len>>1) * lzy[h] ;\n        lzy[h] = 0 ;\n    }\n}\n\nvoid update ( int h, int l, int r, int x, int y ) {\n    if ( x <= l && r <= y ) {\n        tree[h] += r-l+1 ;\n        lzy[h] ++ ;\n        return ; \n    }\n    push_down(h,r-l+1) ;\n    int mid = l+r >> 1 ;\n    if ( y <= mid ) update ( h<<1, l, mid, x, y ) ;\n    else if ( x > mid ) update ( h<<1|1, mid+1, r, x, y ) ;\n    else {\n        update ( h<<1, l, mid, x, mid ) ;\n        update ( h<<1|1, mid+1, r, mid+1, y ) ;\n    } push_up (h) ;\n}\n\nint query ( int h, int l, int r, int x, int y ) {\n    if ( x <= l && r <= y ) return tree[h] ;\n    push_down (h,r-l+1) ;\n    int mid = l+r >> 1 ;\n    if ( y <= mid ) return query ( h<<1, l, mid, x, y ) ;\n    else if ( x > mid ) return query ( h<<1|1, mid+1, r, x, y ) ;\n    else return\n        query ( h<<1, l, mid, x, mid ) +\n        query ( h<<1|1, mid+1, r, mid+1, y ) ;\n}\n\nchar cmd[5] ;\n\nvoid Update ( int u, int v ) {\n    while ( top[u] != top[v] ) {\n        if ( dep[top[u]] > dep[top[v]] ) swap ( u, v ) ;\n        update ( 1, 2, n, w[top[v]], w[v] ) ;\n        v = fa[top[v]] ;\n    }\n    if ( u == v ) return ;\n    if ( dep[u] > dep[v] ) swap ( u, v ) ;\n    update ( 1, 2, n, w[u]+1, w[v] ) ;\n}\n\nint Query ( int u, int v ) {\n    int rec = 0 ;\n    while ( top[u] != top[v] ) {\n        if ( dep[top[u]] > dep[top[v]] ) swap ( u, v ) ;\n        rec += query ( 1, 2, n, w[top[v]], w[v] ) ;\n        v = fa[top[v]] ;\n    }\n    if ( u == v ) return rec ;\n    if ( dep[u] > dep[v] ) swap ( u, v ) ;\n    rec += query ( 1, 2, n, w[u]+1, w[v] ) ;\n    return rec ;\n}\n\nint main() {\n    int i, j, k, u, v ;\n    Read(n) ; Read(m) ;\n    init() ;\n    for ( i = 1 ; i < n ; i ++ ) {\n        Read(u) ; Read(v) ;\n        add ( u, v ) ;\n        add ( v, u ) ;\n    }\n    dfs1 ( 1, 1, 1 ) ;\n    dfs2 ( 1, 1 ) ;\n    while (m--) {\n        scanf ( \"%s\", cmd ) ;\n        Read(u) ; Read(v) ;\n        if ( cmd[0] == 'P' ) Update ( u, v ) ;\n        else printf ( \"%d\\n\", Query ( u, v ) ) ;\n    }\n    return 0 ;\n}\n```",
        "postTime": 1484984217,
        "uid": 17941,
        "name": "Vasily",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u3002\u548c `P4315 \u6708\u4e0b\u201c\u6bdb\u666f\u6811\u201d` \u7684\u505a\u6cd5\u7c7b\u4f3c\uff0c\u5c06\u8fb9\u6743\u8f6c\u4e3a\u70b9\u6743\uff0c\u7136\u540e\u53ea\u8981\u5904\u7406\u4e24\u79cd\u64cd\u4f5c\uff1a\u533a\u95f4\u52a0\u548c\u533a\u95f4\u548c\u5373\u53ef\uff0c\u201c\u8fb9\u6743\u8f6c\u70b9\u6743\u201d\u7684\u505a\u6cd5\u53ef\u4ee5\u53c2\u8003\u6211 `P4315` \u7684\u9898\u89e3\uff1a[Here](https://www.luogu.org/blog/Venus/solution-p4315)\uff0c\u4e2d\u95f4\u4e24\u6bb5\u8bdd\u5c31\u662f\u4e86\u3002\n\n\u5176\u4ed6\u7684\u53ea\u662f\u6811\u94fe\u5256\u5206\u548c\u7ebf\u6bb5\u6811\u7684\u57fa\u672c\u64cd\u4f5c\uff0c\u65e0\u8111\u5957\u6a21\u677f\u5373\u53ef\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 100005\nusing namespace std;\nint cnt,fst[MAXN],nxt[MAXN<<1],to[MAXN<<1];\nint n,Q,t[MAXN<<2],tag[MAXN<<2];\nint siz[MAXN],son[MAXN],dfn[MAXN],Index,top[MAXN],dep[MAXN],faz[MAXN];\nstring s;\nvoid AddEdge(int u,int v)\n{\n\tto[++cnt]=v;\n\tnxt[cnt]=fst[u];\n\tfst[u]=cnt;\n}\nvoid Dfs1(int u)\n{\n\tsiz[u]=1;\n\tson[u]=0;\n\tfor(int i=fst[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==faz[u]) continue;\n\t\tfaz[v]=u;\n\t\tdep[v]=dep[u]+1;\n\t\tDfs1(v);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[son[u]]<siz[v]) son[u]=v;\n\t}\n}\nvoid Dfs2(int u,int rt)\n{\n\tdfn[u]=++Index;\n\ttop[u]=rt;\n\tif(son[u]) Dfs2(son[u],rt);\n\tfor(int i=fst[u];i;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==faz[u] || v==son[u]) continue;\n\t\tDfs2(v,v);\n\t}\n}\nvoid PushUp(int rt)\n{\n\tt[rt]=t[rt<<1]+t[rt<<1|1];\n}\nvoid PushDown(int rt)\n{\n\ttag[rt<<1]+=tag[rt];\n\ttag[rt<<1|1]+=tag[rt];\n\tt[rt<<1]+=tag[rt];\n\tt[rt<<1|1]+=tag[rt];\n\ttag[rt]=0;\n}\nvoid BuildSegmentTree(int rt,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\tt[rt]=0;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tBuildSegmentTree(rt<<1,l,mid);\n\tBuildSegmentTree(rt<<1|1,mid+1,r);\n\tPushUp(rt);\n}\nvoid Modify(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr)\n\t{\n\t\tt[rt]+=val;\n\t\ttag[rt]+=val;\n\t\treturn;\n\t}\n\tPushDown(rt);\n\tint mid=l+r>>1;\n\tif(tl<=mid) Modify(rt<<1,l,mid,tl,tr,val);\n\tif(tr>mid) Modify(rt<<1|1,mid+1,r,tl,tr,val);\n\tPushUp(rt);\n}\nint Query(int rt,int l,int r,int tl,int tr)\n{\n\tif(tl<=l && r<=tr) return t[rt];\n\tPushDown(rt);\n\tint mid=l+r>>1,res=0;\n\tif(tl<=mid) res+=Query(rt<<1,l,mid,tl,tr);\n\tif(tr>mid) res+=Query(rt<<1|1,mid+1,r,tl,tr);\n\treturn res;\n}\nvoid ModifyOnTree(int u,int v,int val)\n{\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tModify(1,1,n,dfn[top[u]],dfn[u],val);\n\t\tu=faz[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tModify(1,1,n,dfn[u]+1,dfn[v],val);\n}\nint QueryOnTree(int u,int v)\n{\n\tint res=0;\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tres=max(res,Query(1,1,n,dfn[top[u]],dfn[u]));\n\t\tu=faz[top[u]];\n\t}\n\tif(dep[u]>dep[v]) swap(u,v);\n\tres=max(res,Query(1,1,n,dfn[u]+1,dfn[v]));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&Q);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tAddEdge(x,y);\n\t\tAddEdge(y,x);\n\t}\n\tDfs1(1);\n\tDfs2(1,1);\n\tBuildSegmentTree(1,1,n);\n\twhile(Q--)\n\t{\n\t\tint x,y,z;\n\t\tcin>>s;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tif(s==\"P\") ModifyOnTree(x,y,1);\n\t\telse if(s==\"Q\") printf(\"%d\\n\",QueryOnTree(x,y));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546832008,
        "uid": 23243,
        "name": "VenusM1nT",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    },
    {
        "content": "\u9996\u5148\uff0c\u8fd9\u9053\u9898\u7684\u7ffb\u8bd1\u662f\u6709\u95ee\u9898\u7684(\u8d77\u7801\u73b0\u5728\u662f)\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u5e94\u8be5\u662f\u67e5\u8be2\u67d0\u4e00\u6761\u8def\u5f84\u7684\u6743\u503c\uff0c\u800c\u4e0d\u662f\u67d0\u6761\u8fb9(\u5751\u6b7b\u6211\u4e86)\u3002\n\n\u4e0e\u5e73\u5e38\u6811\u94fe\u5256\u5206\u9898\u76ee\u4e0d\u540c\u7684\u662f\uff0c\u8fd9\u9053\u9898\u76ee\u7ef4\u62a4\u7684\u662f\u8fb9\u6743\uff0c\u800c\u4e0d\u662f\u70b9\u6743\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u597d\u50cf\u6709\u70b9\u68d8\u624b\u8bf6\uff0c\u8fd9\u662f\u4e00\u79cd\u975e\u5e38\u7ecf\u5178\u7684\u9898\u578b\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u4e00\u4e2a\u70b9\u6700\u591a\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\uff01\uff01\uff01\u90a3\uff0c\u6211\u4eec\u663e\u7136\u5c31\u53ef\u4ee5\u7528\u8fd9\u4e2a\u70b9\u7684\u70b9\u6743\u53bb\u4ee3\u66ff\u5b83\u4e0e\u5b83\u7236\u4eb2\u4e4b\u95f4\u7684\u8fb9\u6743\uff01\uff01\uff01\u7136\u540e\u8fd9\u9053\u9898\u4e0d\u5c31\u6210\u4e86\u6811\u94fe\u5256\u5206\u6c34\u9898\u4e86\u561b\uff1f\u521a\u5f00\u59cb\u8fb9\u6743\u90fd\u662f$0$\uff0c\u90a3\u6211\u4eec\u5c31\u6839\u636e\u9898\u76ee\u7ed9\u7684\u8fb9\u5efa\u8fb9\u6743\u4e3a$0$\u7684\u8fb9\u3002\n\n$nonono$\uff0c\u8fd8\u6709\u4e00\u4e2a\u5751\u70b9\u5c31\u662f\u5728\u8def\u5f84\u67e5\u8be2\u548c\u4fee\u6539\u7684\u65f6\u5019\uff0c\u4e24\u70b9\u7684$LCA$\u7684\u70b9\u6743\u662f\u4e0d\u80fd\u7b97\u5728\u5176\u4e2d\u7684\uff0c\u56e0\u4e3a\u5b83\u7684\u70b9\u6743\u662f$LCA$\u4e0e$LCA$\u7236\u4eb2\u4e4b\u95f4\u8fb9\u7684\u8fb9\u6743\uff0c\u6ce8\u610f\u8fd9\u51e0\u4e2a\u95ee\u9898\uff0c\u90a3\u8fd9\u9898\u5c31\u771f\u7684\u662f\u6c34\u9898\u4e86\uff01\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#define maxn 100007\n#define ls rt<<1\n#define rs rt<<1|1\nusing namespace std;\nint n,m,head[maxn],d[maxn],son[maxn],siz[maxn],id[maxn],w[maxn];\nint num,cnt,sum[maxn<<2],lazy[maxn<<2],top[maxn],fa[maxn],a[maxn];\nchar s[3];\ninline int qread() {\n  char c=getchar();int num=0,f=1;\n  for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n  for(;isdigit(c);c=getchar()) num=num*10+c-'0';\n  return num*f;\n}\nstruct node {\n  int v,w,nxt;\n}e[maxn<<1];\ninline void ct(int u, int v, int w) {\n  e[++num].v=v;\n  e[num].w=w;\n  e[num].nxt=head[u];\n  head[u]=num;\n}\ninline void pushup(int rt) {\n  sum[rt]=sum[ls]+sum[rs];\n}\nvoid build(int rt, int l, int r) {\n  if(l==r) {\n    sum[rt]=a[l];\n    return;\n  }\n  int mid=(l+r)>>1;\n  build(ls,l,mid);\n  build(rs,mid+1,r);\n  pushup(rt);\n}\ninline void pushdown(int rt, int len) {\n  if(lazy[rt]) {\n    sum[ls]+=(len-(len>>1))*lazy[rt];\n    sum[rs]+=(len>>1)*lazy[rt];\n    lazy[ls]+=lazy[rt],lazy[rs]+=lazy[rt];\n    lazy[rt]=0;\n  }\n}\nvoid modify(int rt, int l, int r, int L, int R, int val) {\n  if(L>r||R<l) return;\n  if(L<=l&&r<=R) {\n    sum[rt]+=(r-l+1)*val;\n    lazy[rt]+=val;\n    return;\n  }\n  pushdown(rt,r-l+1);\n  int mid=(l+r)>>1;\n  modify(ls,l,mid,L,R,val),modify(rs,mid+1,r,L,R,val);\n  pushup(rt);\n}\nint csum(int rt, int l, int r, int L, int R) {\n  if(L>r||R<l) return 0;\n  if(L<=l&&r<=R) return sum[rt];\n  pushdown(rt,r-l+1);\n  int mid=(l+r)>>1;\n  return csum(ls,l,mid,L,R)+csum(rs,mid+1,r,L,R);\n}\nvoid dfs1(int u) {\n  siz[u]=1;\n  for(int i=head[u];i;i=e[i].nxt) {\n    int v=e[i].v;\n    if(v!=fa[u]) {\n      d[v]=d[u]+1;\n      fa[v]=u;\n      w[u]=e[i].w;                 //\u5316\u8fb9\u6743\u4e3a\u70b9\u6743\u3002\n      dfs1(v);\n      siz[u]+=siz[v];\n      if(siz[v]>siz[son[u]]) son[u]=v;\n    }\n  }\n}\nvoid dfs2(int u, int t) {\n  id[u]=++cnt;\n  top[u]=t;\n  a[cnt]=w[u];\n  if(son[u]) dfs2(son[u],t);\n  for(int i=head[u];i;i=e[i].nxt) {\n    int v=e[i].v;\n    if(v!=fa[u]&&v!=son[u]) dfs2(v,v);\n  }\n}\nvoid cal(int x, int y) {\n  int fx=top[x],fy=top[y];\n  while(fx!=fy) {\n    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);\n    modify(1,1,cnt,id[fx],id[x],1);\n    x=fa[fx],fx=top[x];\n  }\n  if(id[x]>id[y]) swap(x,y);\n  modify(1,1,cnt,id[x]+1,id[y],1);     //LCA\u7684\u70b9\u6743\u4e0d\u80fd\u7b97\u5728\u5176\u4e2d\uff01\uff01\n}\nint query(int x, int y) {\n  int fx=top[x],fy=top[y],ans=0;\n  while(fx!=fy) {\n    if(d[fx]<d[fy]) swap(x,y),swap(fx,fy);\n    ans+=csum(1,1,cnt,id[fx],id[x]);\n    x=fa[fx],fx=top[x];\n  }\n  if(id[x]>id[y]) swap(x,y);\n  ans+=csum(1,1,cnt,id[x]+1,id[y]);    //\u540c\u4e0a\u3002\n  return ans;\n}\nint main() {\n  n=qread(),m=qread();\n  for(int i=1,u,v;i<n;++i) {\n    u=qread(),v=qread();\n    ct(u,v,0);ct(v,u,0);\n  }\n  dfs1(1);dfs2(1,1);build(1,1,n);\n  for(int i=1,u,v;i<=m;++i) {\n    scanf(\"%s\",s);\n    u=qread(),v=qread();\n    if(s[0]=='P') cal(u,v);\n    else printf(\"%d\\n\",query(u,v));\n  }\n  return 0;\n}\n```\n\n\u5e0c\u671b\u8fd9\u7bc7\u9898\u89e3\u80fd\u8ba9\u5927\u5bb6\u5bf9\u8fd9\u79cd\u9898\u578b\u66f4\u52a0\u719f\u6089\uff01",
        "postTime": 1546153258,
        "uid": 68622,
        "name": "King\u4e28\u5e1d\u5fa1\u5a01",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3038 \u3010[USACO11DEC]\u7267\u8349\u79cd\u690dGrass Planting\u3011"
    }
]