[
    {
        "content": "\u53d1\u73b0 $k$ \u5f88\u5c0f\uff0c\u53ea\u6709 $20$\uff0c\u90a3\u4e48\u8fd9\u9898\u590d\u6742\u5ea6\u5927\u6982\u7387\u548c $2^k$ \u6709\u5173\n\n\u8003\u8651\u679a\u4e3e\u52a0\u5165\u65b0\u8fb9\u7684\u96c6\u5408\uff0c\u5982\u679c\u76f4\u63a5\u8dd1\u6700\u5c0f\u751f\u6210\u6811\u7684\u8bdd\u4f1a T\uff0c\u9700\u8981\u4f18\u5316\n\n\u5bb9\u6613\u53d1\u73b0\u6bcf\u6b21\u6700\u5c0f\u751f\u6210\u6811\u91cd\u590d\u52a0\u5165\u7684\u8fb9\u6570\u4f1a\u5f88\u591a\uff0c\u4e8e\u662f\u53ef\u4ee5\u8003\u8651\u54ea\u4e9b\u8fb9\u662f\u4e00\u5b9a\u4f1a\u52a0\u5165\n\n\u6211\u4eec\u5148\u628a $k$ \u6761\u8fb9\u5168\u90e8\u52a0\u5165\uff0c\u63a5\u4e0b\u6765\u8dd1\u4e00\u8fb9\u6700\u5c0f\u751f\u6210\u6811\uff0c\u539f\u56fe\u4e0a\u7684\u8fb9\u5982\u679c\u5728\u8fd9\u4e2a\u6700\u5c0f\u751f\u6210\u6811\u91cc\u90a3\u4e48\u5c31\u662f\u4e00\u5b9a\u4f1a\u52a0\u5165\u7684\u8fb9\uff0c\u8bbe\u8fd9\u4e2a\u8fb9\u96c6\u4e3a $\\mathcal S$\uff08\u7531\u4e8e\u9898\u76ee\u6761\u4ef6\u91cc\u6709\u8fb9\u6743\u4e92\u4e0d\u76f8\u540c\uff0c\u4e8e\u662f\u8fd9\u4e2a\u6700\u5c0f\u751f\u6210\u6811\u552f\u4e00\uff09\n\n\u63a5\u4e0b\u6765\u628a\u8fd9\u4e9b\u8fb9\u7ec4\u6210\u7684\u8fde\u901a\u5757\u7f29\u6210\u4e00\u4e2a\u70b9\uff0c\u6709 $k+1$ \u4e2a\u70b9\uff0c\u518d\u7528\u539f\u56fe\u8fb9\u8dd1\u4e00\u904d\u8fd9 $k+1$ \u4e2a\u70b9\u4e0a\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5f97\u5230\u7684\u8fb9\u96c6\uff08\u8bbe\u4e3a $\\mathcal T$\uff09\u5373\u4e3a\u53ef\u80fd\u51fa\u73b0\u5728\u4e4b\u540e\u7684\u6700\u5c0f\u751f\u6210\u6811\u91cc\u7684\u8fb9\n\n\u73b0\u5728\u5728\u679a\u4e3e\u8fb9\u96c6\u7684\u65f6\u5019\u8dd1\u7684\u6700\u5c0f\u751f\u6210\u6811\u53ea\u8981\u5728\u7f29\u70b9\u540e\u7684\u56fe\u4e0a\u628a\u679a\u4e3e\u7684\u8fb9\u96c6\u52a0\u5165\u518d\u7528\u521a\u624d\u5f97\u5230\u7684\u8fb9\u96c6\u8dd1\u6700\u5c0f\u751f\u6210\u6811\u5c31\u884c\u4e86\n\n\u63a5\u4e0b\u6765\u9700\u8981\u8ba1\u7b97\u6bcf\u4e2a\u65b0\u8fb9\u7684\u8fb9\u6743\u6700\u5927\u503c\n\n\u5bf9\u4e8e\u4e00\u68f5\u751f\u6210\u6811 $\\mathscr T$\uff0c\u548c\u4e00\u4e2a\u4e0d\u5728 $\\mathscr T$ \u4e0a\u7684\u8fb9 $e$\uff0c\u5982\u679c\u628a $e$ \u52a0\u5230 $\\mathscr T$ \u4e0a\uff0c\u90a3\u4e48\u4e00\u5b9a\u4f1a\u51fa\u73b0\u4e00\u4e2a\u73af\u3002\u5982\u679c\u73af\u4e0a\u5b58\u5728\u4e00\u6761\u8fb9\u7684\u8fb9\u6743\u6bd4 $e$ \u7684\u8fb9\u6743\u5927\uff0c\u5219 $\\mathscr T$ \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u751f\u6210\u6811\n\n\u6211\u4eec\u53ef\u4ee5\u7528\u8fd9\u4e2a\u6027\u8d28\u6765\u7ea6\u675f\u8fb9\u6743\n\n\u5bf9\u4e8e $\\mathcal T$ \u4e2d\u7684\u4e00\u6761\u8fb9 $e: u\\to v$\uff0c\u5b83\u53ef\u4ee5\u7ea6\u675f\u6811\u4e0a $u\\to v$ \u8def\u5f84\u4e0a\u6240\u6709\u7684\u8fb9\u7684\u8fb9\u6743\u90fd\u9700\u8981\u5c0f\u4e8e\u7b49\u4e8e\u5b83\u7684\u8fb9\u6743\n\n\u4e8e\u662f\u8fd9\u4e2a\u53ef\u4ee5\u7528\u4e00\u4e2a lca \u641e\u5b9a\uff0c\u5f53\u7136\u8fd9\u91cc\u53ea\u6709 $k+1$ \u4e2a\u70b9\uff0c\u6240\u4ee5\u66b4\u529b\u722c\u6811\u5c31\u884c\n\n\u6700\u540e\u8fd8\u8981\u8ba1\u7b97\u6bcf\u6761\u8fb9\u6709\u591a\u5c11\u4eba\u901a\u8fc7\uff0c\u8fd9\u4e2a\u7528\u4e00\u904d dfs \u6c42\u5b50\u6811\u5927\u5c0f\u5c31\u53ef\u4ee5\u6c42\u51fa\u6765\u4e86\n\n\u4ee3\u7801\u6bd4\u8f83\u70e6\uff0c\u4f46\u662f\u7ec6\u8282\u8fd8\u662f\u6bd4\u8f83\u5c11\u7684 ~~\uff08\u6240\u4ee5\u4e3a\u4ec0\u4e48\u6211\u4e00\u4e2a `;` \u5199\u6210 `,` \u8fd8\u80fd\u5f97 35pts \u554a\uff09~~\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(m\\log m+2^kk^2)$\n\ncode:\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 300010\n#define MAXK 30\n#define int long long\nusing namespace std;\nint n,m,K,tot,a[MAXN];\nstruct Node{int fr,to,val;}e[MAXN],ne[MAXN],que[MAXN];\nbool cmp(Node a,Node b){return a.val<b.val;}\nint f[MAXN],g[MAXN];\nint getf(int x){return f[x]==x?x:f[x]=getf(f[x]);}\nint getg(int x){return g[x]==x?x:g[x]=getg(g[x]);}\nint col[MAXN],cnt,val[MAXK];\nvoid kruskal(){\n\tfor(int i=1;i<=n;i++)f[i]=g[i]=i;\n\tsort(e+1,e+m+1,cmp);\n\tfor(int i=1;i<=K;i++){\n\t\tint u=ne[i].fr,v=ne[i].to;\n\t\tint a=getf(u),b=getf(v);\n\t\tif(a==b)continue;\n\t\tf[a]=b;\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u=e[i].fr,v=e[i].to;\n\t\tint a=getf(u),b=getf(v);\n\t\tif(a==b)continue;\n\t\tf[a]=b;\n\t\ta=getg(u),b=getg(v);\n\t\tif(a<b)swap(a,b);g[a]=b;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(getg(i)==i)col[i]=++cnt,val[cnt]=a[i];\n\t\telse col[i]=col[getg(i)],val[col[i]]+=a[i];\n\t}\n\tfor(int i=1;i<=K;i++){\n\t\tint u=ne[i].fr,v=ne[i].to;\n\t\tne[i]=(Node){col[u],col[v],0};\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u=e[i].fr,v=e[i].to,w=e[i].val;\n\t\tint a=getg(u),b=getg(v);\n\t\tif(a==b)continue;\n\t\tque[++tot]=(Node){col[u],col[v],w};\n\t\tif(a<b)swap(a,b);g[a]=b;\n\t}\n}\nstruct tnode{int to,nxt;}Edge[MAXK<<1];\nint cnt_Edge,Head[MAXK];\nvoid Add_Edge(int u,int v){\n\tEdge[++cnt_Edge]=(tnode){v,Head[u]};\n\tHead[u]=cnt_Edge;\n}\nint fa[MAXK],dep[MAXK],mn[MAXK],sz[MAXK];\nvoid dfs(int u,int fat){\n\tfa[u]=fat;dep[u]=dep[fat]+1;sz[u]=val[u];\n\tfor(int i=Head[u];i;i=Edge[i].nxt){\n\t\tint v=Edge[i].to;if(v==fat)continue;\n\t\tdfs(v,u);sz[u]+=sz[v];\n\t}\n}\nvoid update(int u,int v,int w){\n\twhile(u!=v){\n\t\tif(dep[u]>dep[v])swap(u,v);\n\t\tmn[v]=min(mn[v],w);v=fa[v];\n\t}\n}\nsigned main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&K);\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;scanf(\"%lld%lld%lld\",&u,&v,&w);\n\t\te[i]=(Node){u,v,w};\n\t}\n\tfor(int i=1;i<=K;i++){\n\t\tint u,v;scanf(\"%lld%lld\",&u,&v);\n\t\tne[i]=(Node){u,v,0};\n\t}\n\tfor(int i=1;i<=n;i++)scanf(\"%lld\",&a[i]);\n\tkruskal();int ans=0,rt=col[1];\n\tfor(int s=0;s<(1<<K);s++){\n\t\tmemset(Head,0,sizeof(Head));cnt_Edge=0;\n\t\tmemset(fa,0,sizeof(fa));memset(dep,0,sizeof(dep));\n\t\tmemset(mn,0x3f,sizeof(mn));memset(sz,0,sizeof(sz));\n\t\tfor(int i=1;i<=cnt;i++)f[i]=i;bool fl=false;\n\t\tfor(int i=1;i<=K;i++){\n\t\t\tif(!((s>>(i-1))&1))continue;\n\t\t\tint u=ne[i].fr,v=ne[i].to;\n\t\t\tint a=getf(u),b=getf(v);\n\t\t\tif(a==b){fl=true;break;}\n\t\t\tf[a]=b;Add_Edge(u,v);Add_Edge(v,u);\n\t\t}if(fl)continue;\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tint u=que[i].fr,v=que[i].to;\n\t\t\tint a=getf(u),b=getf(v);\n\t\t\tif(a==b)continue;\n\t\t\tf[a]=b;Add_Edge(u,v);Add_Edge(v,u);\n\t\t}dfs(rt,0);\n\t\tfor(int i=1;i<=tot;i++){\n\t\t\tint u=que[i].fr,v=que[i].to,w=que[i].val;\n\t\t\tupdate(u,v,w);\n\t\t}int res=0;\n\t\tfor(int i=1;i<=K;i++){\n\t\t\tif(!((s>>(i-1))&1))continue;\n\t\t\tint u=ne[i].fr,v=ne[i].to;\n\t\t\tif(dep[u]<dep[v])swap(u,v);\n\t\t\tres+=mn[u]*sz[u];\n\t\t}ans=max(ans,res);\n\t}printf(\"%lld\",ans);\n\treturn 0;\n}\n```",
        "postTime": 1619012138,
        "uid": 65681,
        "name": "UltiMadow",
        "ccfLevel": 7,
        "title": "[\u9898\u89e3] P3639 [APIO2013]\u9053\u8def\u8d39\u7528"
    },
    {
        "content": "\u8003\u8651\u5bf9\u4e8e\u65b0\u8fb9\u96c6\u6700\u540e\u5728\u751f\u6210\u6811\u4e0a\u7684\u7684\u8fb9\u96c6 $E$\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u8fd9 $|E|$ \u6761\u8fb9\u52a0\u5165\u751f\u6210\u6811 $T$ \u540e\u518d\u5bf9\u65e7\u8fb9\u505a Kruskal\uff0c\u6c42\u51fa\u8fd9\u79cd\u60c5\u51b5\u4e0b\u7684\u6700\u5c0f\u751f\u6210\u6811\u7684\u5176\u4ed6\u8fb9\u3002\u6211\u4eec\u5bf9\u4e8e\u4e0d\u5728\u751f\u6210\u6811\u4e0a\u7684\u8fb9 $e\\not\\in T$\uff0c\u4e00\u5b9a\u6709 $T$ \u4e0a\u7684\u8def\u5f84 $(u,v)$ \u4e0a\u6240\u6709\u8fb9\u7684\u8fb9\u6743\u90fd $\\le w_e$\u3002\u8fd9\u6837\u6211\u4eec\u5c31\u80fd\u786e\u5b9a\u6bcf\u4e00\u6761 $\\in E$ \u7684\u8fb9\u7684\u8fb9\u6743\u6700\u5927\u503c\u3002\u7136\u540e\u6811\u5f62 DP \u4e00\u4e0b\u6bcf\u6761\u8fb9\u4f1a\u88ab\u591a\u5c11\u4eba\u7ecf\u8fc7\u3002\u8fd9\u4e2a\u7b97\u6cd5\u662f $O(2^k nm)$ \u7684\u3002\n\n\u6211\u4eec\u53d1\u73b0\u5bf9\u4e8e\u4e0d\u540c\u7684 $E$\uff0c\u5176 $T$ \u5f88\u5927\u4e00\u90e8\u5206\u662f\u4e00\u6837\u7684\uff0c\u8fd8\u6709\u4e00\u4e9b\u65e7\u8fb9\u6839\u672c\u4e0d\u4f1a\u88ab\u7528\u5230\u3002\u6211\u4eec\u8003\u8651\u5728\u4e00\u5f00\u59cb\u7684\u65f6\u5019\uff08$E=$ \u6240\u6709\u65b0\u8fb9\u7684\u96c6\u5408\uff09\uff0c\u8ba1\u7b97\u51fa\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff08\u7528\u5c3d\u65b0\u8fb9\uff09\u54ea\u4e9b\u65e7\u8fb9\u662f\u5728 MST \u5185\u7684\u3002\u663e\u7136\u8fd9\u4e9b\u8fb9\u65e0\u8bba $E$ \u662f\u4ec0\u4e48\uff0c\u90fd\u4f1a\u5305\u62ec\u5728 MST \u5185\uff0c\u8bbe\u8fd9\u4e2a\u96c6\u5408\u4e3a $S_0$\u3002\u6211\u4eec\u5c06 $S_0$ \u4e2d\u7684\u8fb9\u8fdb\u884c\u7f29\u6210\u4e00\u4e2a\u70b9\u3002\u73b0\u5728\u603b\u5171\u6709 $k+1$ \u4e2a\u70b9\u3002\u6211\u4eec\u5728\u7f29\u70b9\u8fc7\u540e\u7684\u65e7\u8fb9\u505a\u4e00\u6b21 MST\uff0c\u4f1a\u5f97\u5230 $k$ \u6761\u8fb9\uff0c\u8bbe\u5176\u4e3a $S_1$\u3002\u5bb9\u6613\u8bc1\u660e\uff0c\u6240\u70b9\u8fc7\u540e\u7684\u56fe\u7684\u65e7\u8fb9\u4e2d\u53ea\u6709 $S_1$ \u4e2d\u7684\u8fb9\u624d\u53ef\u80fd\u6210\u4e3a MST \u4e0a\u7684\u8fb9\u3002\u6240\u4ee5\u6211\u4eec\u5c06\u8fb9\u6570\u7f29\u5230\u4e86 $O(k)$\u3002\u590d\u6742\u5ea6 $O(2^kk^2+m\\log m)$\u3002\n\n\u4ee3\u7801\u6bd4\u8f83\u70e6\u3002\u5c31\u4e0d\u5efa\u8bae\u770b\u6211\u7684\u4e11\u964b\u7684\u5927\u5e38\u6570\u7684\u4ee3\u7801\u4e86\uff08\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define upm(a,b) a=min(a,b)\n#define rep(i,a,b) for(register int i=(a);i<=(b);i++)\n#define per(i,a,b) for(register int i=(a);i>=(b);i--)\nusing namespace std;\nconst int N=900009;\n\ninline long long read() {\n    register long long x=0, f=1; register char c=getchar();\n    while(c<'0'||c>'9') {if(c=='-') f=-1; c=getchar();}\n    while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+c-48,c=getchar();}\n    return x*f;\n}\n\nint n,m,k,p[N],cnt,tcn,ans,tot,st;\nbool t[N];\n\nvector<int>pt,te[N];\nvoid add(int u,int v) {te[u].push_back(v), te[v].push_back(u);}\n\nstruct edge {int u,v,w;} e[N],et[N],eg[N];\nbool cmp(const edge &a,const edge &b) {return a.w<b.w;}\n\nint id[N];\nint find(int i) {return i==id[i]?i:id[i]=find(id[i]);}\nvoid merge(int u,int v) {id[find(u)]=find(v);}\n\nvoid kruskal() {\n\trep(i,1,m) t[i]=0;\n\tsort(e+1,e+m+1,cmp);\n\trep(i,1,m) {\n\t\tint u=find(e[i].u), v=find(e[i].v);\n\t\tt[i]=(u!=v), merge(u,v);\n\t}\n}\n\nint f[N],d[N],fa[N],sum[N],fae[N],mx[N];\nvoid dfs(int u,int faa) {\n\tsum[u]=p[u], fa[u]=faa, d[u]=d[faa]+1;\n\tfor(auto v:te[u]) if(v!=faa) {\n\t\tdfs(v,u);\n\t\tsum[u]+=sum[v];\n\t}\n}\nvoid upd(int u,int v,int w) {\n\tif(d[u]<d[v]) swap(u,v);\n\twhile(d[u]>d[v]) upm(mx[fae[u]],w), u=fa[u];\n\twhile(u!=v) upm(mx[fae[u]],w), upm(mx[fae[v]],w), u=fa[u], v=fa[v];\n}\n\nsigned main() {\n\tn=read(), m=read(), k=read();\n\trep(i,1,m) {\n\t\tint u=read(), v=read(), w=read();\n\t\te[i]=(edge){u,v,w};\n\t}\n\trep(i,1,k) e[m+i].u=read(), e[m+i].v=read();\n\trep(i,1,n) p[i]=read(), id[i]=i;\n\trep(i,m+1,m+k) merge(e[i].u,e[i].v);\n\tkruskal();\n\t\n\trep(i,1,n) id[i]=i;\n\trep(i,1,m) if(t[i]) merge(e[i].u,e[i].v);\n\trep(i,1,n) {\n\t\tif(find(i)==i) pt.push_back(i);\n\t\telse p[id[i]]+=p[i];\n\t}\n\tst=find(1);\n\trep(i,1,m+k) e[i].u=find(e[i].u), e[i].v=find(e[i].v);\n\tkruskal();\n\trep(i,1,m) if(t[i]) eg[++tot]=(edge){e[i].u,e[i].v,e[i].w};\n\trep(i,1,tot) e[i]=eg[i];\n\trep(i,1,k) e[i+tot]=e[i+m];\n\tm=tot;\n\t\n\trep(s,0,(1<<k)-1) {\n\t\tfor(auto i:pt) id[i]=i, te[i].clear();\n\t\trep(i,1,k) if((1<<i-1)&s) merge(e[i+m].u,e[i+m].v);\n\t\tkruskal();\n\t\trep(i,1,k) {\n\t\t\tif((1<<i-1)&s) add(e[i+m].u,e[i+m].v), t[i+m]=1;\n\t\t\telse t[i+m]=0;\n\t\t}\n\t\tint ecnt=0;\n\t\trep(i,1,m+k) ecnt+=t[i];\n\t\tif(ecnt>pt.size()-1) continue;\n\t\trep(i,1,m) if(t[i]) add(e[i].u,e[i].v);\n\t\tdfs(st,0);\n\t\trep(i,1,m+k) if(t[i]) {\n\t\t\tint u=e[i].u, v=e[i].v;\n\t\t\tif(fa[u]==v) fae[u]=i;\n\t\t\telse fae[v]=i;\n\t\t\tmx[i]=(i<=m?0:1000000000);\n\t\t}\n\t\tint res=0;\n\t\trep(i,1,m) if(!t[i]) upd(e[i].u,e[i].v,e[i].w);\n\t\trep(i,m+1,m+k) if(t[i]) res+=(sum[fa[e[i].u]==e[i].v?e[i].u:e[i].v])*mx[i];\n\t\tans=max(ans,res);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```",
        "postTime": 1619187789,
        "uid": 180652,
        "name": "_lgswdn",
        "ccfLevel": 0,
        "title": "P3639 [APIO2013]\u9053\u8def\u8d39\u7528"
    },
    {
        "content": "\u4e0d\u96be\u60f3\u5230\u53ef\u4ee5$2^k$\u53bb\u679a\u4e3e$k$\u6761\u65b0\u8fb9\u7684\u9009\u62e9\u65b9\u6848\uff0c\u7136\u540e\u52a0\u5165\u539f\u56fe\u4e2d\u7684\u8fb9\u6765\u4f7f\u56fe\u8fde\u901a\uff0c\u7528\u5f53\u524d\u65b9\u6848\u7684\u6536\u76ca\u53bb\u66f4\u65b0\u7b54\u6848\uff0c\u4f46\u662f\u8fd9\u6837\u590d\u6742\u5ea6\u8fc7\u4e0d\u53bb\u3002\n\n\u53ef\u4ee5\u5148\u628a$k$\u6761\u65b0\u8fb9\u90fd\u8fde\u4e0a\uff0c\u7136\u540e\u518d\u52a0\u5165\u8fb9\u6743\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u8fc7\u540e\u7684\u539f\u56fe\u7684\u8fb9\uff0c\u76f4\u5230\u56fe\u8fde\u901a\u3002\u540e\u52a0\u5165\u7684\u539f\u56fe\u7684\u8fb9\u5728\u4efb\u4f55\u4e00\u4e2a\u65b0\u8fb9\u7684\u9009\u62e9\u65b9\u6848\u90fd\u662f\u8981\u52a0\u5165\u7684\uff0c\u56e0\u4e3a\u627e\u8fd9\u4e9b\u8fb9\u65f6\u662f\u9009\u4e86\u6240\u6709$k$\u6761\u65b0\u8fb9\uff0c\u5176\u4ed6\u65b9\u6848\u53ea\u4f1a\u6bd4\u8fd9\u65f6\u9009\u62e9\u66f4\u5c11\u7684\u65b0\u8fb9\uff0c\u6240\u4ee5\u4e3a\u4fdd\u8bc1\u8fde\u901a\uff0c\u8fd9\u4e9b\u540e\u52a0\u5165\u7684\u8fb9\u80af\u5b9a\u662f\u8981\u9009\u62e9\u7684\uff0c\u53ef\u80fd\u8fd8\u8981\u52a0\u5165\u66f4\u591a\u7684\u539f\u56fe\u4e2d\u7684\u8fb9\uff0c\u540c\u65f6\u8fd9\u4e9b\u8fb9\u662f\u6309\u8fb9\u6743\u6392\u5e8f\u540e\u7684\uff0c\u6240\u4ee5\u4e5f\u80fd\u6ee1\u8db3\u9898\u76ee\u4e2d\u6700\u5c0f\u751f\u6210\u6811\u7684\u8981\u6c42\u3002\n\n\u6839\u636e\u539f\u56fe\u4e2d\u8fb9\u6743\u4e92\u4e0d\u76f8\u540c\uff0c\u6240\u4ee5\u8fd9\u4e9b\u540e\u52a0\u5165\u7684\u8fb9\u7684\u96c6\u5408\u662f\u552f\u4e00\u7684\u3002\u56e0\u4e3a\u8fd9\u4e9b\u540e\u52a0\u5165\u7684\u8fb9\u662f\u5fc5\u9009\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u628a\u53ea\u8003\u8651\u8fd9\u4e9b\u8fb9\u7684\u8fde\u901a\u5757\u7f29\u6210\u70b9\uff0c\u53d1\u73b0\u7f29\u70b9\u540e\u7684\u6570\u91cf\u6700\u591a\u4e3a$k+1$\u3002\n\n\u4e0a\u9762\u4e5f\u8bf4\u5230\uff0c\u53ef\u80fd\u5728\u4e00\u4e2a\u65b0\u8fb9\u7684\u9009\u62e9\u65b9\u6848\u4e2d\uff0c\u8fd8\u9700\u52a0\u5165\u66f4\u591a\u7684\u539f\u56fe\u4e2d\u7684\u8fb9\uff0c\u8fd9\u4e9b\u8fb9\u5c31\u662f\u4f7f\u8fd9$k+1$\u4e2a\u70b9\u8fde\u901a\u7684\u8fb9\uff0c\u628a\u8fd9$k$\u6761\u8fb9\u8bb0\u5f55\u4e0b\u6765\uff0c\u4f5c\u4e3a\u5904\u7406\u9009\u62e9\u65b9\u6848\u65f6\u7684\u5907\u9009\u8fb9\u3002\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u6309\u4e4b\u524d\u7684\u505a\u6cd5\u6765\u5904\u7406\u4e86\uff0c$2^k$\u53bb\u679a\u4e3e$k$\u6761\u65b0\u8fb9\u7684\u9009\u62e9\u65b9\u6848\uff0c\u7136\u540e\u52a0\u5165\u8fd9$k$\u6761\u5907\u9009\u8fb9\u6765\u4f7f\u56fe\u8fde\u901a\uff0c\u7136\u540e\u7528\u5f53\u524d\u65b9\u6848\u7684\u6536\u76ca\u53bb\u66f4\u65b0\u7b54\u6848\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u52a0\u8fb9\u5224\u65ad\u8fde\u901a\u6027\u548c\u7f29\u70b9\u65f6\u7528\u5e76\u67e5\u96c6\u6bd4\u8f83\u65b9\u4fbf\u3002\n\n\u603b\u590d\u6742\u5ea6\u4e3a$O(m \\log m + 2^k k^2)$\u3002\n\n$code:$\n\n```cpp\n#include<bits/stdc++.h>\n#define maxn 3000010\n#define inf 1000000000\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x)\n{\n    x=0;char c=getchar();bool flag=false;\n    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\n    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    if(flag)x=-x;\n}\nint n,m,k,root,cnt,tot;\nll ans,sum;\nint id[maxn],fa[maxn],de[maxn];\nll p[maxn],pe[maxn],siz[maxn],mi[maxn];\nbool flag;\nstruct edge\n{\n    int to,nxt;\n}e[maxn];\nint head[maxn],edge_cnt;\nvoid add(int from,int to)\n{\n    e[++edge_cnt]=(edge){to,head[from]};\n    head[from]=edge_cnt;\n}\nstruct Edge\n{\n    int x,y,v;\n}e1[maxn],e2[maxn],e3[maxn];\nbool cmp(const Edge &a,const Edge &b)\n{\n    return a.v<b.v;\n}\nstruct node\n{\n    int f[maxn];\n    int find(int x)\n    {\n        return f[x]==x?x:f[x]=find(f[x]);\n    }\n    void merge(int x,int y)\n    {\n        x=find(x),y=find(y);\n        if(x==y) return;\n        f[x]=y;\n    }\n}A,B;\nvoid dfs(int x,int fath)\n{\n    fa[x]=fath,de[x]=de[fath]+1,siz[x]=pe[x];\n    for(int i=head[x];i;i=e[i].nxt)\n    {\n        int y=e[i].to;\n        if(y==fath) continue;\n        dfs(y,x),siz[x]+=siz[y];\n    }\n}\nint main()\n{\n    read(n),read(m),read(k);\n    for(int i=1;i<=n;++i) A.f[i]=B.f[i]=i;\n    for(int i=1;i<=m;++i)\n        read(e1[i].x),read(e1[i].y),read(e1[i].v);\n    sort(e1+1,e1+m+1,cmp);\n    for(int i=1;i<=k;++i)\n        read(e2[i].x),read(e2[i].y);\n    for(int i=1;i<=n;++i) read(p[i]);\n    for(int i=1;i<=k;++i) A.merge(e2[i].x,e2[i].y);\n    for(int i=1;i<=m;++i)\n    {\n        int x=e1[i].x,y=e1[i].y;\n        if(A.find(x)==A.find(y)) continue;\n        A.merge(x,y),B.merge(x,y);\n    }\n    for(int i=1;i<=n;++i)\n        if(B.find(i)==i)\n            id[i]=++tot;\n    root=id[B.find(1)],A=B;\n    for(int i=1;i<=n;++i) pe[id[B.find(i)]]+=p[i];\n    for(int i=1;i<=m;++i)\n    {\n        int x=e1[i].x,y=e1[i].y;\n        if(B.find(x)==B.find(y)) continue;\n        B.merge(x,y),e3[++cnt]=e1[i];\n    }\n    for(int i=1;i<=k;++i) e2[i].x=id[A.find(e2[i].x)],e2[i].y=id[A.find(e2[i].y)];\n    for(int i=1;i<=cnt;++i) e3[i].x=id[A.find(e3[i].x)],e3[i].y=id[A.find(e3[i].y)];\n    for(int S=0;S<(1<<k);++S)\n    {\n        edge_cnt=sum=flag=0;\n        for(int i=1;i<=tot;++i) A.f[i]=i,head[i]=0,mi[i]=inf;\n        for(int i=1;i<=k;++i)\n        {\n            if(!(S&(1<<(i-1)))) continue;\n            int x=e2[i].x,y=e2[i].y;\n            if(A.find(x)==A.find(y))\n            {\n                flag=true;\n                break;\n            }\n            A.merge(x,y),add(x,y),add(y,x);\n        }\n        if(flag) continue;\n        for(int i=1;i<=cnt;++i)\n        {\n            int x=e3[i].x,y=e3[i].y;\n            if(A.find(x)==A.find(y)) continue;\n            A.merge(x,y),add(x,y),add(y,x);\n        }\n        dfs(root,0);\n        for(int i=1;i<=cnt;++i)\n        {\n            int x=e3[i].x,y=e3[i].y;\n            ll v=e3[i].v;\n            while(x!=y)\n            {\n                if(de[x]<de[y]) swap(x,y);\n                mi[x]=min(mi[x],v),x=fa[x];\n            }\n        }\n        for(int i=1;i<=k;++i)\n        {\n            if(!(S&(1<<(i-1)))) continue;\n            int x=e2[i].x,y=e2[i].y;\n            if(de[x]<de[y]) swap(x,y);\n            sum+=mi[x]*siz[x];\n        }\n        ans=max(ans,sum);\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n```",
        "postTime": 1591585136,
        "uid": 172489,
        "name": "lhm_",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3639 \u3010[APIO2013]\u9053\u8def\u8d39\u7528 \u3011"
    },
    {
        "content": "[\u5b89\u5229\u4e00\u4e0b\u81ea\u5df1csdn\u7684\u535a\u5ba2](https://blog.csdn.net/xyc1719)\n\n\u5927\u610f\u662f\u8bf4\uff0c\u8c03\u6574k\u6761\u7279\u6b8a\u8fb9\u8fb9\u7684\u503c\uff0c\u5e76\u5728\u539f\u56fe\u7684\u57fa\u7840\u4e0a\u6784\u5efa\u6700\u5c0f\u751f\u6210\u6811\u3002\u4f7f\u5f97\u7ecf\u8fc7\u6240\u6709\u7279\u6b8a\u8fb9\u7684\u503c\u4e4b\u548c\u6700\u5927\u3002\n\n\u611f\u8c22dasxxx\u5b66\u957f\u6307\u51fa\u9898\u76ee\u8981\u7d20(\u52a0\u4e0a\u65b0\u8fb9\uff0c\u4e24\u70b9\u4e4b\u95f4\u6700\u591a\u53ea\u6709\u4e00\u6761\u8fb9)\uff0c\u8bf7\u5404\u4f4d\u5728\u7406\u89e3\u4e0b\u6587\u89e3\u6cd5\u65f6\u7279\u522b\u6ce8\u610f\uff0c\u5982\u679c\u6ca1\u6709\u8fd9\u4e00\u8981\u6c42\u662f\u4e0d\u80fd\u8bbe\u8ba1\u5982\u4e0b\u7b97\u6cd5\u7684\u3002\u5728\u6b64\u5b89\u5229\u4e00\u4e0b[HGEEK\u9996\u5e2d\u7a0b\u5e8f\u5458\u7684\u535a\u5ba2](https://www.hgeek.cn/dasxxx/)\u3002\n\n**\u5927\u81f4\u89e3\u6cd5\uff1a**\n\u5148\u7f29\u70b9\u3002\u53ef\u4ee5\u77e5\u9053\uff0c\u5bf9\u7b54\u6848\u6709\u8d21\u732e\u7684\u53ea\u6709k\u6761\u65b0\u8fb9\u3002\u5148\u5c06k\u6761\u8fb9\u8fdb\u884c\u6700\u5c0f\u751f\u6210\u6811\uff0c\u518d\u6784\u5efa\u4e00\u68f5\u5b8c\u6210\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002\n\u9664\u53bb\u90a3\u4e9b\u65b0\u8fb9\u4f1a\u4ea7\u751fk+1\u4e2a\u8fde\u901a\u5757\uff0c\u800c\u8fd9\u8fde\u901a\u5757\u4e2d\u7684\u8fb9\u7684\u8fde\u63a5\u65b9\u6cd5\u5bf9\u7b54\u6848\u662f\u6ca1\u6709\u8d21\u732e\u7684\uff0c\u8d77\u5230\u4e3b\u8981\u8d21\u732e\u7684\u662f\u8fde\u63a5\u8fd9\u4e9b\u8fde\u901a\u5757\u7684\u65b0\u8fb9\u3002\u5f53\u7136\u4e5f\u4f1a\u6709k\u6761\u539f\u8fb9\u53ef\u4ee5\u66ff\u4ee3\u5b83\u4eec\u3002\n\n\u5148\u8fdb\u884c\u66b4\u529b\u679a\u4e3ek\u6761\u8fb9\u7684\u9009\u6216\u8005\u4e0d\u9009\uff0c\u603b\u5171$2^k $\u79cd\u72b6\u6001\u3002\u7528\u9009\u5b9a\u7684\u65b0\u8fb9\u5c06\u8fde\u901a\u5757\u76f8\u8fde\uff0c\u4e0d\u8db3\u7684\u90e8\u5206\u7528\u539f\u8fb9\u4ee3\u66ff\u3002\u90a3\u4e48\u5728\u8fd9\u68f5\u6811\u4e2d\u4e3b\u8981\u662f\u6c42\u5230\u6bcf\u4e2a\u70b9\u7684\u4eba\u6570\u548c\u6240\u6709\u65b0\u8fb9\u7684\u6700\u5927\u503c\u3002\u6bcf\u70b9\u4eba\u6570\u7528\u6811\u4e0a\u524d\u7f00\u548c\u5373\u53ef\uff1b\u6c42\u65b0\u8fb9\u6700\u503c\u9700\u8981\u501f\u7528kruskal\u7684\u601d\u60f3\uff0c\u5373\u5728\u6811\u4e0a\u4eceu\u5230v\u7684\u8def\u5f84\u4e2d\u7684\u6240\u6709\u8fb9\u6743\u5fc5\u987b\u5c0f\u4e8e\u7b49\u4e8e\u65b0\u52a0\u8fdb\u7684\u8fb9\uff0c\u4e0d\u7136\u5c31\u53ef\u4ee5\u7528\u65b0\u8fb9\u4ee3\u66ff\u4e4b\uff0c\u5982\u6b64\u7ea6\u675f\u6bcf\u6761\u65b0\u8fb9\u7684\u503c\u5373\u53ef\u3002\n\ncode:\n```cpp\n#include<bits/stdc++.h>\ntypedef long long ll;\nconst int INF=1<<30;\nusing namespace std;\nll ans;\nint n,m,K,top,cnt,st;\nint fa[100005],fa2[100005],p[100005];\nstruct edgege{\n\tint u,v,w;\n}e[300005],ne[25],q[300005];\nstruct data{\n\tint v,nxt;\n}edge[50];\nint ag[25],dep[100005],head[100005],mn[100005];\nll val[100005],sum[100005];\nbool mark[300005];\nvoid insert(int u,int v)\n{\n\tedge[++cnt]=(data){v,head[u]};head[u]=cnt;\n\tedge[++cnt]=(data){u,head[v]};head[v]=cnt;\n}\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\nint find2(int x){return x==fa2[x]?x:fa2[x]=find2(fa2[x]);}\nbool operator<(edgege a,edgege b){return a.w<b.w;}\nvoid dp(int x)\n{\n\tsum[x]=val[x];\n\tfor(int i=head[x];i;i=edge[i].nxt)\n\t\tif(edge[i].v!=fa2[x])\n\t\t{\n\t\t\tdep[edge[i].v]=dep[x]+1;\n\t\t\tfa2[edge[i].v]=x;\n\t\t\tdp(edge[i].v);\n\t\t\tsum[x]+=sum[edge[i].v];\n\t\t}\n}\nvoid solve()\n{\n\tcnt=0;\n\tfor(int i=1;i<=K+1;i++)\n\t{\n\t\tint p=ag[i];\n\t\thead[p]=fa2[p]=0;\n\t\tfa[p]=p;mn[p]=INF;\n\t}\n\tfor(int i=1;i<=K;i++)\n\t\tif(mark[i])\n\t\t{\n\t\t\tint x=find(ne[i].u),y=find(ne[i].v);\n\t\t\tif(x==y)return;\n\t\t\tfa[x]=y;\n\t\t\tinsert(ne[i].u,ne[i].v);\n        }//\u5c06\u65b0\u8fb9\u52a0\u5165MST \n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tint x=find(q[i].u),y=find(q[i].v);\n\t\tif(x!=y)fa[x]=y,insert(q[i].u,q[i].v);\n\t}//\u6784\u5efa\u5b8c\u6574\u7684MST \n\tdp(st);//\u6811\u4e0a\u524d\u7f00\u548c(\u4eba\u6570)\n\tfor(int i=1;i<=K;i++)\n\t{\n\t\tint u=q[i].u,v=q[i].v;\n\t\tif(dep[u]>dep[v])swap(u,v);\n\t\twhile(dep[v]>dep[u])mn[v]=min(mn[v],q[i].w),v=fa2[v];\n\t\twhile(u!=v)\n\t\t{\n            mn[v]=min(mn[v],q[i].w);\n            mn[u]=min(mn[u],q[i].w);\n            u=fa2[u];v=fa2[v];\n        }\n\t}//\u9000\u5316\u7248lca \n\tll res=0;\n\tfor(int i=1;i<=K;i++)\n\t\tif(mark[i])\n\t\t{\n\t\t\tint u=ne[i].u,v=ne[i].v;\n\t\t\tif(dep[u]>dep[v])swap(u,v);\n\t\t\tres+=mn[v]*sum[v];\n\t\t}\n\tans=max(res,ans);\n}\nvoid dfs(int x)\n{//\u9009\u8fb9\u7684\u72b6\u6001\u679a\u4e3e \n\tif(x>K)\n\t{\n\t\tsolve();return;\n\t}\n\tmark[x]=0;dfs(x+1);\n\tmark[x]=1;dfs(x+1);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&K);\n\tfor(int i=1;i<=m;i++)\n\t\tscanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n\tsort(e+1,e+m+1);\n\tfor(int i=1;i<=K;i++)\n\t\tscanf(\"%d%d\",&ne[i].u,&ne[i].v);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&p[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i]=fa2[i]=i;\n    for(int i=1;i<=K;i++)\n\t\tfa[find(ne[i].u)]=find(ne[i].v);//\u65b0\u8fb9\u7684\u7f29\u70b9 \n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u=e[i].u,v=e[i].v;\n\t\tif(find(u)!=find(v))//\u4e00\u5b9a\u4f1a\u501f\u52a9\u5176\u4ed6\u8fb9\u8fde\u63a5\u7684\u4e24\u70b9 \n\t\t{\n\t\t\tfa[find(u)]=fa[find(v)];\n\t\t\tfa2[find2(u)]=fa2[find2(v)];\n\t\t}\n\t}\n\t//\u8fd9\u91ccfind\u5408\u5e76\u6210\u4e86\u4e00\u68f5\u6811\n\t//find2\u662fK+1\u5757 \n\tst=find2(1);//\u521d\u59cb1\u6240\u5728\u96c6\u5408 \n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tval[find2(i)]+=p[i];//\u6bcf\u5757\u7684\u4eba\u6570 \n\t\tif(find2(i)==i)ag[++ag[0]]=i;//\u6bcf\u4e2a\u7f29\u70b9(\u96c6\u5408)\u7684\u7f16\u53f7\n\t}\n\tfor(int i=1;i<=K;i++)\n\t\tne[i].u=find2(ne[i].u),ne[i].v=find2(ne[i].v); \n\tfor(int i=1;i<=m;i++)\n\t\te[i].u=find2(e[i].u),e[i].v=find2(e[i].v);\n\t//\u91cd\u6784\u8fb9\uff0c\u8d1f\u8d23\u8fde\u5757 \n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint p=find2(e[i].u),q=find2(e[i].v);\n\t\tif(p!=q)mark[i]=1,fa2[p]=q;\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tif(mark[i])q[++top]=e[i];//\u53d6\u90a3\u4e9b\u6709\u7528\u7684\u8fb9\n\tmemset(mark,0,sizeof(mark));\n\tdfs(1);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```",
        "postTime": 1536481439,
        "uid": 24212,
        "name": "xyc1719",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3639 \u3010[APIO2013]\u9053\u8def\u8d39\u7528 \u3011"
    },
    {
        "content": "**\u6765\u6e90\uff1a\u94b1\u6865_toll.pptx**\n\n\u7b97\u6cd5\u4e00\uff1a\u5411\u6700\u5c0f\u751f\u6210\u6811\u4e2d\u9010\u4e00\u52a0\u8fb9\uff0c\u66ff\u6362\u539f\u8def\u5f84\u4e0a\u6743\u503c\u6700\u5927\u7684\u8fb9\u3002\u5f53k>1\u65f6\uff0c\u4e0d\u80fd\u4fdd\u8bc1\u6b63\u786e\u6027\uff01\u4e3e\u4f8b\uff1a\n\n![\u94b1\u6865toll](https://cdn.luogu.com.cn/upload/pic/32387.png)\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(k*m)\n\u671f\u671b\u7684\u5206\uff1a15\u5206~\uff1f\n___\n\n\u7b97\u6cd5\u4e8c\uff1a\u66b4\u529b\u679a\u4e3e\u4f7f\u7528\u54ea\u4e9b\u8fb9\uff0c\u8ba9\u9009\u4e2d\u7684\u8fb9\u5c3d\u53ef\u80fd\u5927\n\n\u51712k\u79cd\u60c5\u51b5\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u60c5\u51b5\uff1a\n        Step 1\uff1a\u6784\u9020\u6700\u7ec8\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\u4f18\u5148\u4f7f\u7528\u9009\u4e2d\u7684\u8fb9\n        Step2\uff1a\u786e\u5b9a\u9009\u4e2d\u8fb9\u7684\u6743\u503c\u2014\u2014\u7ecf\u8fc7\u5b83\u7684\u6700\u5c0f\u503c\n\n\u65f6\u95f4\u590d\u6742\u5ea6O(m*logm + 2k*m*k)\n\u671f\u671b\u7684\u5206\uff1a35\u5206\n___\n\u7b97\u6cd5\u4e09\uff1a\u5148\u7f29\u70b9\uff0c\u518d\u901a\u8fc7\u7b97\u6cd5\u4e8c\u5904\u7406\n\n\u9009\u4e2d\u7684\u8fb9\u4e3a0~20\u6761\uff0cStep 1\u4e2d\u6784\u9020\u7684\u6700\u5c0f\u751f\u6210\u6811\u6709n-1\u6761\u3002\n\u7ed3\u8bba\uff1a\u6709\u5f88\u591a\u70b9\u662f\u4e00\u5b9a\u201c\u7c98\u201d\u5728\u4e00\u8d77\u7684\u3002\u600e\u6837\u7f29\u70b9\uff1f\n\n\u521d\u59cb\u5316\u6784\u9020\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5176\u4e2d\uff0c\u4f18\u5148\u4f7f\u7528k\u6761\u8fb9\u3002\n\u5f62\u6210\u7684k+1\u4e2a\u8fde\u901a\u5757\u53ef\u5206\u522b\u7f29\u4e3a\u4e00\u4e2a\u70b9\u3002\n\n\u521d\u59cb\u5316\u6784\u9020\u6700\u5c0f\u751f\u6210\u6811\uff08\u4f18\u5148\u4f7f\u7528k\u6761\u8fb9\uff09\n\u5f62\u6210\u7684k+1\u4e2a\u8fde\u901a\u5757\u53ef\u5206\u522b\u7f29\u4e3a\u4e00\u4e2a\u70b9\n\n\u518d\u6c42\u8fd9k+1\u4e2a\u70b9\u7684\u6700\u5c0f\u751f\u6210\u6811\uff0c\uff08\u4e0d\u4f7f\u7528k\u6761\u8fb9\uff09\n\u5f97\u5230k+1\u4e2a\u70b9\uff0ck\u6761\u8fb9\u7684\u4e00\u5f20\u56fe\n\n\u901a\u8fc7\u7b97\u6cd5\u4e8c\u6c42\u89e3\u8fd9\u5f20\u56fe\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(m*logm + 2k*k2)\n\u671f\u671b\u5f97\u5206\uff1a90~100\u5206 \uff08\u6570\u636e\u4e3a\u9636\u68af\u5206\u5e03\uff09\n\n___\n95\u5206\u4ee3\u7801\uff1a\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N = 101010, M = 301010, K = 22;\n\nint n, m, k, cn = 0;\nlong long ans = 0, maxL, ssize;\nint cost[N], father[N], color[N];\nlong long size[N] = {0};\n\nlong long get_max(long long a, long long b)\n{\n    if (a > b) return a; else return b;\n}\nlong long get_min(long long a, long long b)\n{\n    if (a < b) return a; else return b;\n}\n\nclass Road\n{\npublic :\n    int x, y, w, flag, ans;\n    Road (int x, int y, int w = 0, int flag = 0) \n        : x(x), y(y), w(w), flag(flag) {}\n};\n\nRoad * road[M], \n     * road_sp[K];\n\nclass Node;\n\nclass Edge\n{\npublic :\n    Node * target;\n    Edge * next;\n    int flag;\n    /*Edge(Node * target, Edge * next, int flag) :\n        target(target), next(next), flag(flag) {};\n    ~Edge()\n    {\n        if (next) delete next;\n    }*/\n};\n\nclass Node\n{\npublic :\n    Edge * head;\n    Node * father;\n    long long size, deep, flag;\n    /*\n    Node (long long size) :\n        size(size), head(0), father(0), deep(0), flag(0) {}\n    ~Node()\n    {\n        if (head) delete head;\n    }\n    */\n};\n\nNode * node[K];\n\nNode * my_node[1010]; int my_node_count;\nEdge * my_edge[1010]; int my_edge_count;\n\nNode * get_node(long long size)\n{\n    Node * now = my_node[my_node_count ++];\n    now->size = size;\n    now->head = 0;\n    now->father = 0;\n    now->deep = 0;\n    now->flag = 0;\n    return now;\n}\n\nEdge * get_edge(Node * target, Edge * next, int flag)\n{\n    Edge * now = my_edge[my_edge_count ++];\n    now->target = target;\n    now->next = next;\n    now->flag = flag;\n    return now;\n}\n\nvoid newedge(Node * x, Node * y, int flag)\n{\n    Edge * e1 = get_edge(y, x->head, flag),\n         * e2 = get_edge(x, y->head, flag);\n    x->head = e1; y->head = e2;\n}\n\nbool cmp_w(const Road * a, const Road * b)\n    {return a->w < b->w;}\n\nvoid init()\n{\n    for (int i=0; i<1010; i++)\n    {\n        my_edge[i] = new Edge();\n        my_node[i] = new Node();\n    }\n    scanf(\"%d%d%d\", &n, &m, &k);\n    int x, y, w;\n    for (int i=0; i<m; i++)\n    {\n        scanf(\"%d%d%d\", &x, &y, &w);\n        road[i] = new Road(x, y, w);\n    }\n    for (int i=0; i<k; i++)\n    {\n        scanf(\"%d%d\", &x, &y);\n        road_sp[i] = new Road(x, y);\n    }\n    for (int i=1; i<=n; i++)\n        scanf(\"%d\", cost+i);\n}\n\nint get_father(int x)\n{\n    int head = x;\n    while (father[head] != head) head = father[head];\n    while (x != head)\n    {\n        int tmp = father[x];\n        father[x] = head;\n        x = tmp;\n    }\n    return head;\n}\n\nvoid select()\n{\n    sort(road, road+m, cmp_w);\n    for (int i=1; i<=n; i++) father[i] = i;\n    for (int i=0; i<m; i++)\n    {\n        int x = get_father(road[i]->x),\n            y = get_father(road[i]->y);\n        if (x != y)\n        {\n            road[i]->flag = 1;\n            father[x] = y;\n        }\n    }\n    m = 0;\n    for (int i=0; m<n-1; i++)\n        if (road[i]->flag) road[m++] = road[i];\n}\n\nvoid check_select()\n{\n    printf(\"m = %d\\n\", m);\n    for (int i=0; i<m; i++)\n        printf(\"x = %d y = %d w = %d\\n\", road[i]->x, road[i]->y, road[i]->w);\n}\n\nvoid build()\n{\n    for (int i=1; i<=n; i++) father[i] = i;\n    for (int i=0; i<k; i++)\n    {\n        int x = get_father(road_sp[i]->x),\n            y = get_father(road_sp[i]->y);\n        if (x != y) father[x] = y;\n    }\n    for (int i=0; i<m; i++)\n    {\n        int x = get_father(road[i]->x),\n            y = get_father(road[i]->y);\n        if (x != y)\n            father[x] = y;\n        else\n            road[i]->flag = 0;\n    }\n    for (int i=1; i<=n; i++) father[i] = i;\n    for (int i=0; i<m; i++)\n        if (road[i]->flag)\n        {\n            int x = get_father(road[i]->x),\n                y = get_father(road[i]->y);\n            father[x] = y;\n        }\n    for (int i=1; i<=n; i++)\n        if (father[i] == i)\n            color[i] = cn++;\n    for (int i=1; i<=n; i++)\n    {\n        color[i] = color[get_father(i)];\n        size[color[i]] += cost[i];\n    }\n    m = 0;\n    for (int i=0; i<n-1; i++)\n        if (!road[i]->flag) road[m++] = road[i];\n}\n\nvoid check_build()\n{\n    for (int i=0; i<cn; i++)\n    {\n        printf(\"Color %d :\", i);\n        for (int j=1; j<=n; j++)\n            if (color[j] == i) printf(\"%d \", j);\n        printf(\"  size = %I64d\\n\", size[i]);\n    }\n    printf(\"sp edge:\\n\");\n    for (int i=0; i<k; i++)\n        printf(\"x = %d  y = %d\\n\", color[road_sp[i]->x], color[road_sp[i]->y]);\n    printf(\"other edge:\\n\");\n    for (int i=0; i<m; i++)\n        printf(\"x = %d  y = %d w = %d\\n\", color[road[i]->x], color[road[i]->y], road[i]->w);\n}\n\nlong long work(Node * & x, int w)\n{\n    long long s = 0;\n    if (x->flag)\n    {\n        //road_sp[x->flag-1]->ans = w;\n        s = x->size * w;\n        x->flag = 0;\n        ssize -= x->size;\n    }\n    x = x->father;\n    return s;\n}\n\nvoid dfs(Node * now)\n{\n    for (Edge * e = now->head; e!=0; e=e->next)\n    {\n        if (!e->target->deep)\n        {\n            e->target->deep = now->deep + 1;\n            e->target->flag = e->flag;\n            e->target->father = now;\n            dfs(e->target);\n            if (e->flag) ssize += e->target->size;\n            now->size += e->target->size;\n        }\n    }\n}\n\nvoid clear_road_sp()\n{\n    for (int i=0; i<k; i++) road_sp[i]->ans = 9999999;\n}\n\nvoid print_road_sp(long long s)\n{\n    return ;\n    printf(\"%I64d \", s);\n    for (int i=0; i<k; i++) printf(\"%d \", road_sp[i]->ans);\n    printf(\"\\n\", s);\n}\n\nlong long get_ans()\n{\n    my_node_count = 0;\n    my_edge_count = 0;\n    for (int i=0; i<cn; i++) node[i] = get_node(size[i]);\n    for (int i=0; i<cn; i++) father[i] = i;\n    for (int i=0; i<k; i++)\n        if (road_sp[i]->flag)\n        {\n            int x = get_father(color[road_sp[i]->x]),\n                y = get_father(color[road_sp[i]->y]);\n            if (x == y) return 0;\n            father[x] = y;\n            newedge(node[color[road_sp[i]->x]], node[color[road_sp[i]->y]], i+1);\n        }\n    maxL = 0;\n    for (int i=0; i<m; i++)\n    {\n        int x = get_father(color[road[i]->x]),\n            y = get_father(color[road[i]->y]);\n        if (x != y)\n        {\n            road[i]->flag = 0;\n            father[x] = y;\n            newedge(node[color[road[i]->x]], node[color[road[i]->y]], 0);\n        }\n        else\n        {\n            if (road[i]->w > maxL) maxL = road[i]->w;\n            road[i]->flag = 1;\n        }\n    }\n    \n    node[color[1]]->deep = 1;\n    ssize = 0;\n    dfs(node[color[1]]);\n    long long s = 0;\n    //clear_road_sp();\n    for (int i=0; i<m; i++)\n    {\n        if (ssize * maxL + s < ans) break;\n        if (road[i]->flag)\n        {\n            Node * x = node[color[road[i]->x]],\n                 * y = node[color[road[i]->y]];\n            int c = 0;\n            while (x != y)\n                if (x->deep > y->deep) s += work(x, road[i]->w); else s += work(y, road[i]->w);\n        }\n    }\n    //if (ssize != 0) printf(\"A = %I64d\\n\", ssize);\n    //print_road_sp(s);\n    for (int i=1; i<=cn; i++) delete node[i];\n    return s;\n}\n\nvoid dfs(int now)\n{\n    if (now == k)\n    {\n        ans = get_max(get_ans(), ans);\n        return ;\n    }\n    road_sp[now]->flag = 1;\n    dfs(now+1);\n    road_sp[now]->flag = 0;\n    dfs(now+1);\n}\n\nint main()\n{\nfreopen(\"toll.in\", \"r\", stdin);\n    freopen(\"toll.out\", \"w\", stdout);\n    init();\n    select();\n    //check_select();\n    build();\n    //check_build();\n    dfs(0);\n    \n    cout << ans << endl;\n    return 0;\n}\n```",
        "postTime": 1536473155,
        "uid": 24212,
        "name": "xyc1719",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3639 \u3010[APIO2013]\u9053\u8def\u8d39\u7528 \u3011"
    }
]