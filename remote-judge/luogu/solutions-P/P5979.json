[
    {
        "content": "\u8bf4\u4e00\u4e2a $O(n\\log^2 n)$ \u7684 cdq \u5206\u6cbb\u505a\u6cd5\uff0c\u5e38\u6570\u4e0d\u5927\uff0c\u4e0d\u7528\u5206\u7c7b\u8ba8\u8bba\uff0c\u8f83\u4e3a\u597d\u5199\u3002\n\n## \u4e00\u4e9b\u7b26\u53f7\n\n- \u8bb0 $\\operatorname{mxl}(l,r)$ \u8868\u793a\u4e0b\u6807\u5728 $l$ \u5230 $r$ \u4e4b\u95f4\u7684\u6240\u6709\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u6700\u5927\u503c\uff0c$\\operatorname{mnr}(l,r)$ \u610f\u4e49\u7c7b\u4f3c\u3002\n- \u8bb0 $\\operatorname{rng}(l,r)=[\\operatorname{mxl}(l,r),\\operatorname{mnr}(l,r)]$\u3002\n\n## \u66b4\u623e\n\n\u9996\u5148\u662f\u4e00\u4e2a\u7b80\u5355\u7684 $O(n^2)$ dp\uff1a\n\n$$dp_i=1+\\max_{[j<i]\\land [(i-j)\\in\\operatorname{rng}(i+1,j)]}dp_j$$\n\n\u56e0\u4e3a\u8fd9\u4e2a\u8f6c\u79fb\u7684\u6761\u4ef6\u6bd4\u8f83\u590d\u6742\uff0c\u5408\u6cd5\u7684 $j$ \u90fd\u662f\u4e0d\u8fde\u7eed\u7684\uff0c\u8003\u8651\u7528 cdq \u5206\u6cbb\u6765\u505a\u3002\n\n## cdq\n\n\u5047\u8bbe\u6211\u4eec\u76ee\u524d\u5df2\u7ecf\u77e5\u9053 $dp_{[l, mid]}$\uff0c\u8003\u8651\u8fd9\u4e9b dp \u503c\u5bf9 $dp_{[mid+1, r]}$ \u7684\u8d21\u732e\u3002\n\n$dp_i(i\\le mid)$ \u53ef\u4ee5\u66f4\u65b0 $dp_j(j>mid)$ \u5f53\u4e14\u4ec5\u5f53\uff1a\n\n1. $j-i\\in\\operatorname{rng}(i,mid)$\n1. $j-i\\in\\operatorname{rng}(mid+1,j)$\n\n\u6ce8\u610f\u5230\u6761\u4ef6 1 \u4e0e $i$ \u76f8\u5173\u6027\u8f83\u5927\uff0c\u6761\u4ef6 2 \u4e0e $j$ \u76f8\u5173\u6027\u6bd4\u8f83\u5927\uff0c\u8003\u8651\u5206\u522b\u6ee1\u8db3\u4e24\u4e2a\u6761\u4ef6\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5f00\u4e00\u4e2a\u4e0b\u6807\u7ebf\u6bb5\u6811 $T$\uff0c\u7136\u540e\u679a\u4e3e $j\\in[mid+1,r]$\uff0c\u6bcf\u6b21\u8fdb\u884c\u4e09\u7c7b\u64cd\u4f5c\uff1a\n1. \u5bf9\u4e8e\u6240\u6709\u6ee1\u8db3 $j=i+\\operatorname{mxl}(i,mid)-1$ \u7684 $i$\uff0c$T_i\\gets dp_i+1$\u3002\n1. \u5bf9\u4e8e\u6240\u6709\u6ee1\u8db3 $j=i+\\operatorname{mnr}(i,mid)$ \u7684 $i$\uff0c$T_i\\gets-\\infty$\u3002\n1. $dp_j\\gets\\min_{j\\in[j-\\operatorname{mnr}(mid+1,r),j-\\operatorname{mxl}(mid+1,r)]}$\u3002\n\n\u524d 2 \u79cd\u64cd\u4f5c\u4fdd\u8bc1\u53ea\u6709\u6ee1\u8db3 **\u6761\u4ef6 1** \u7684 $i$ \u6b64\u65f6\u624d\u4f1a\u5728\u7ebf\u6bb5\u6811\u91cc\u3002\n\u800c\u7b2c 3 \u4e2a\u64cd\u4f5c\u5219\u4ece\u7ebf\u6bb5\u6811\u4e2d\u7b5b\u9009\u51fa\u6ee1\u8db3 **\u6761\u4ef6 2** \u7684 $i$ \u7528\u6765\u66f4\u65b0 $dp_j$\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u5c31\u6bd4\u8f83\u597d\u641e\u4e86\uff0c\u53ef\u4ee5\u5148\u626b\u4e00\u4e0b $i\\in[l,mid]$\uff0c\u7136\u540e\u5176\u5bf9\u5e94\u8fdb\u884c 1\uff0c2 \u64cd\u4f5c\u7684 $j$ \u5904\u5f00 `vector` \u6253\u4e2a\u6807\u8bb0\u5373\u53ef\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing pi = pair<int, int>;\nconst char nl = '\\n';\nconst int MXN = 1e6 + 5, INF = 1e9, P = 1e9 + 7;\nint n;\npi rng[MXN];\ninline void upd(pi &x, const pi &y) {\n    x.fi = max(x.fi, y.fi);\n    x.se = min(x.se, y.se);\n}\nnamespace segt {\nstruct node {\n    int mx, mxc;\n    node(int mx = -INF, int mxc = 0) : mx(mx), mxc(mxc) {}\n} t[MXN << 2];\ninline int norm(int x) { return x < P ? x : x - P; }\ninline node operator+(const node &x, const node &y) {\n    if (x.mx == y.mx) return node(x.mx, norm(x.mxc + y.mxc));\n    if (x.mx > y.mx) return x;\n    return y;\n}\n#define ls p << 1\n#define rs p << 1 | 1\ninline void pull(int p) { t[p] = t[ls] + t[rs]; }\nvoid _mdf(int p, int l, int r, int mi, const node &mv) {\n    if (l == r) {\n        t[p] = mv;\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (mi <= mid)\n        _mdf(ls, l, mid, mi, mv);\n    else\n        _mdf(rs, mid + 1, r, mi, mv);\n    pull(p);\n}\nnode _qry(int p, int l, int r, int ql, int qr) {\n    if (qr < l || r < ql) return node();\n    if (ql <= l && r <= qr) return t[p];\n    int mid = (l + r) >> 1;\n    return _qry(ls, l, mid, ql, qr) + _qry(rs, mid + 1, r, ql, qr);\n}\nint sz;\nvoid init(int _sz) {\n    sz = _sz;\n    fill(t + 1, t + 1 + (sz << 2), node());\n}\nvoid mdf(int mi, const node &mv) { _mdf(1, 1, sz, mi, mv); }\nnode qry(int ql, int qr) { return _qry(1, 1, sz, ql, qr); }\n} // namespace segt\n\nusing segt::init;\nusing segt::mdf;\nusing segt::qry;\nvector<pi> id[MXN];\nsegt::node dp[MXN];\nvoid solve(int l, int r) {\n    if (r - l <= 50) {\n        for (int i = l; i <= r; i++) {\n            pi tmp = {1, n};\n            for (int j = i - 1; j >= l; j--) {\n                upd(tmp, rng[j + 1]);\n                if (i - j > tmp.se) break;\n                if (i - j >= tmp.fi) dp[i] = dp[i] + segt::node(dp[j].mx + 1, dp[j].mxc);\n            }\n        }\n        return;\n    }\n    int mid = (l + r) >> 1;\n    solve(l, mid);\n    pi tmp = {1, n};\n    for (int i = mid + 1; i <= r; i++) id[i].clear();\n    for (int i = mid; i >= l; i--) {\n        if (tmp.se < tmp.fi || i + tmp.se <= mid) break;\n        if (i + tmp.fi <= r) {\n            id[max(mid + 1, i + tmp.fi)].push_back({i, 1});\n            id[min(r + 1, i + tmp.se + 1)].push_back({i, 0});\n        }\n        upd(tmp, rng[i]);\n    }\n    init(mid - l + 1);\n    tmp = {1, n};\n    for (int i = mid + 1; i <= r; i++) {\n        for (auto j : id[i]) {\n            if (j.se)\n                mdf(j.fi - l + 1, dp[j.fi]);\n            else\n                mdf(j.fi - l + 1, segt::node());\n        }\n        upd(tmp, rng[i]);\n        if (tmp.se < tmp.fi || i - tmp.se > mid) break;\n        segt::node res = qry(max(l, i - tmp.se) - l + 1, min(mid, i - tmp.fi) - l + 1);\n        ++res.mx;\n        dp[i] = dp[i] + res;\n    }\n    solve(mid + 1, r);\n}\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n;\n    pi tmp = {1, n};\n    for (int i = 1; i <= n; i++) {\n        cin >> rng[i].fi >> rng[i].se;\n        upd(tmp, rng[i]);\n    }\n    dp[0] = {0, 1};\n    solve(0, n);\n    if (dp[n].mx < 0)\n        cout << \"NIE\";\n    else\n        cout << dp[n].mx << \" \" << dp[n].mxc;\n\n    return 0;\n}\n```",
        "postTime": 1648977524,
        "uid": 124740,
        "name": "ethan_zhou",
        "ccfLevel": 8,
        "title": "P5979 [PA2014]Druzyny \u9898\u89e3"
    },
    {
        "content": "~~\u6a21\u62df\u8d5b\u9898\uff0c\u7ec8\u4e8e\u5b66\u4f1a\u4e86 cdq \u5206\u6cbb~~\n\n\u6734\u7d20 DP \u5c31\u662f\u5bf9\u4e8e $\\max_{j\\le k\\le i} l_k \\le i-j+1\\le \\min_{j\\le k\\le i} r_k$\uff0c$f_j\\rightarrow f_i$\n\n\u8003\u8651\u5982\u4f55\u4f18\u5316\uff0c\u4e00\u822c\u5bf9 min/max \u53ef\u4ee5\u7528\u5355\u8c03\u6808\u6216\u8005\u5206\u6cbb\u89e3\u51b3\uff0c\u7531\u4e8e\u5355\u8c03\u6808\u4f1a\u8ba9\u5de6\u53f3\u4e24\u8fb9\u7684\u8fb9\u754c\u53d1\u751f\u53d8\u5316\uff0c\u6240\u4ee5\u5c1d\u8bd5\u4f7f\u7528 cdq \u5206\u6cbb\uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u6bcf\u6b21\u5904\u7406\u5de6\u8fb9\u5bf9\u53f3\u8fb9\u7684\u8d21\u732e\n\n\u5206\u522b\u4ee4 $a_j,b_j$ \u8868\u793a\u524d\u4e00\u534a\u7684\u540e\u7f00 $\\max l$ \u548c $\\min r$\u3001$c_i,d_i$ \u8868\u793a\u540e\u4e00\u534a\u7684\u524d\u7f00 $\\max l$ \u548c $\\min r$\uff0c\u4e0d\u96be\u5206\u7c7b\u8ba8\u8bba $a_j,c_i$ \u548c $b_j,d_i$ \u7684\u5927\u5c0f\u5173\u7cfb\uff0c\u5206\u4e3a\u56db\u7c7b\uff1a\n\n- $c_i>a_j,d_i<b_j$\uff0c\u6709 $j\\le i+1-c_i,j\\ge i+1-d_i$\uff0c\u7531\u4e8e $a_j,b_j$ \u90fd\u662f\u5355\u8c03\u7684\uff0c\u6240\u4ee5\u662f\u4e00\u6bb5\u533a\u95f4\u5411\u4e00\u4e2a\u70b9\u8f6c\u79fb\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\n- $c_i\\le a_j,d_i<b_j$\uff0c\u6709 $a_j+j\\le i+1,j\\ge i+1-d_i$\uff0c\u662f\u4e00\u4e2a\u5f62\u5982 $j\\in [l,r],a_j+j\\le k$ \u7684\u8f6c\u79fb\uff0c\u7528\u4e3b\u5e2d\u6811\u6216\u8005\u79bb\u7ebf\u7ebf\u6bb5\u6811\u7ef4\u62a4\n- $c_i>a_j,d_i\\ge b_j$\uff0c\u6709 $j\\le i+1-c_i,b_j+j\\ge i+1$\uff0c\u7531\u4e8e $b_j+j$ \u6709\u5355\u8c03\u6027\uff0c\u6240\u4ee5\u548c\u7b2c\u4e00\u79cd\u4e00\u6837\uff0c\u662f\u4e00\u6bb5\u533a\u95f4\u5411\u4e00\u4e2a\u70b9\u8f6c\u79fb\n- $c_i\\le a_j,d_i\\ge b_j$\uff0c\u6709 $a_j+j\\le i+1,b_j+j\\ge i+1$\uff0c\u548c\u7b2c\u4e8c\u79cd\u4e00\u6837\u7531\u4e8e $b_j+j$ \u6709\u5355\u8c03\u6027\uff0c\u7528\u4e3b\u5e2d\u6811\u6216\u79bb\u7ebf\u7ebf\u6bb5\u6811\u7ef4\u62a4\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$\uff0c\u6ce8\u610f\u521d\u59cb\u503c\u8981\u5f04\u6210 `-inf`\uff0c\u4ee3\u7801\u5199\u7684\u6bd4\u8f83\u4e11\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i, s, t) for(int i = (s); i <= (t); ++i)\n#define per(i, s, t) for(int i = (t); i >= (s); --i)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n\nconst int N = 1e6 + 5;\nconst int M = N * 22;\nconst int P = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\n\nint n, l[N], r[N];\nint a[N], b[N], c[N], d[N], pa[N], vala[N], valb[N];\nint posa[N], posb[N], pospa[N], pospb[N];\npair<int, int> f[N];\nint rt[N], tt;\n\ninline void upd(pair<int, int>& x, const pair<int, int>& y) {\n    if(x.fi == y.fi) x.se = (x.se + y.se) % P;\n    else if(x.fi < y.fi) x = y;\n}\n\ninline void upd2(pair<int, int>& x, pair<int, int> y) {\n    ++y.fi;\n    if(x.fi == y.fi) x.se = (x.se + y.se) % P;\n    else if(x.fi < y.fi) x = y;\n}\n\npair<int, int> inc(const pair<int, int>& x) { return mp(x.fi + 1, x.se); }\n\nnamespace seg1 {\n    int ls[M], rs[M];\n    pair<int, int> val[M];\n\n    inline int newnode(int o) {\n\t++tt;\n\tls[tt] = ls[o];\n\trs[tt] = rs[o];\n\tval[tt] = val[o];\n\treturn tt;\n    }\n\n    inline void insert(int& o1, int& o2, int p, int l, int r) {\n        o1 = newnode(o2);\n\tif(l == r) {\n\t    assert(val[o1] == val[0]);\n\t    val[o1] = f[p-1];\n\t    return;\n\t}\n\tint mid = l + r >> 1;\n\tif(p <= mid) insert(ls[o1], ls[o2], p, l, mid);\n\telse insert(rs[o1], rs[o2], p, mid + 1, r);\n\n\tval[o1] = mp(-inf, 0);\n\tupd(val[o1], val[ls[o1]]);\n\tupd(val[o1], val[rs[o1]]);\n    }\n\n    inline pair<int, int> query(int o, int ql, int qr, int l, int r) {\n\tif(ql > qr) return mp(-inf, 0);\n\tif(!o) return mp(-inf, 0);\n\tif(ql <= l && r <= qr) {\n\t    //cerr << \"seg1 \" << o << \" \" << l << \" \" << r << \" \" <<  val[o].fi << \" \" << val[o].se << \"\\n\";\n\t    return val[o];\n\t}\n\tint mid = l + r >> 1;\n\tpair<int, int> res = mp(-inf, 0);\n\tif(ql <= mid) upd(res, query(ls[o], ql, qr, l, mid));\n\tif(mid < qr) upd(res, query(rs[o], ql, qr, mid + 1, r));\n\treturn res;\n    }\n}\n\nnamespace seg2 {\n    pair<int, int> val[N<<2];\n    inline void build(int o, int l, int r) {\n\tif(l == r) {\n\t    val[o] = f[l-1];\n\t    return;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(o << 1, l, mid);\n\tbuild(o << 1 | 1, mid + 1, r);\n\tval[o] = mp(-inf, 0);\n\tupd(val[o], val[o << 1]);\n\tupd(val[o], val[o << 1 | 1]);\n    }\n\n    inline pair<int, int> query(int o, int ql, int qr, int l, int r) {\n\tif(ql > qr) return mp(-inf, 0);\n\tif(ql <= l && r <= qr) return val[o];\n\tint mid = l + r >> 1;\n\tpair<int, int> res = mp(-inf, 0);\n\tif(ql <= mid) upd(res, query(o << 1, ql, qr, l, mid));\n\tif(mid < qr) upd(res, query(o << 1 | 1, ql, qr, mid + 1, r));\n\treturn res;\n    }\n}\n\ninline void solve(int l, int r) {\n    if(l == r) {\n\tif(::l[l] <= 1) upd2(f[l], f[l-1]);\n\treturn;\n    }\n    \n    int mid = l + r >> 1;\n    solve(l, mid);\n\n    //cerr << \"solve = \" << l << \", \" << mid << \" -> \" << mid + 1 << \", \" << r << \"\\n\";\n    per(i, l, mid) {\n\ta[i] = max(a[i + 1], ::l[i]);\n\tb[i] = min(b[i + 1], ::r[i]);\n    }\n    rep(i, mid + 1, r) {\n\tc[i] = max(c[i - 1], ::l[i]);\n\td[i] = min(d[i - 1], ::r[i]);\n    }\n    \n    rep(i, l, mid) vala[i] = a[i] + i;\n    rep(i, l, mid) valb[i] = b[i] + i;\n    \n    rep(i, mid + 1, r) {\n\tposa[i] = upper_bound(a + l, a + mid + 1, c[i], greater<int>()) - a;\n\tposb[i] = upper_bound(b + l, b + mid + 1, d[i]) - b;\n    }\n    \n    // c[i] > a[j], d[i] < b[j]\n\n    seg2::build(1, l, mid);\n    rep(i, mid + 1, r) {\n\tint ql = l, qr = mid;\n\tql = max<int>(ql, posb[i]);\n\tql = max<int>(ql, posa[i]);\n\tql = max(ql, i + 1 - d[i]);\n\tqr = min(qr, i + 1 - c[i]);\n\tupd2(f[i], seg2::query(1, ql, qr, l, mid));\n    }\n    \n    //c[i] <= a[j], d[i] < b[j]\n\n    auto compa = [&](int i, int j) { return vala[i] < vala[j]; };\n    rep(i, l, mid) pa[i] = i;\n    sort(pa + l, pa + mid + 1, compa);\n    rep(i, l, mid) {\n\tseg1::insert(rt[i], rt[i-1], pa[i], l, mid);\n    }\n\n    rep(i, mid + 1, r) {\n\tvala[i] = i + 1;\n\tpospa[i] = upper_bound(pa + l, pa + mid + 1, i, compa) - pa;\n\tpospb[i] = lower_bound(valb + l, valb + mid + 1, i + 1) - valb;\n    }\n    \n    rep(i, mid + 1, r) {\n\tint p = pospa[i] - 1;\n\tint ql = l, qr = mid;\n\tql = max<int>(ql, posb[i]);\n\tql = max(ql, i + 1 - d[i]);\n\tqr = min<int>(qr, posa[i] - 1);\n\tupd2(f[i], seg1::query(rt[p], ql, qr, l, mid));\n    }\n    //c[i] > a[j], d[i] >= b[j]\n    rep(i, mid + 1, r) {\n\tint ql = l, qr = mid;\n\tql = max<int>(ql, posa[i]);\n\tqr = min<int>(qr, posb[i] - 1);\n\tqr = min(qr, i + 1 - c[i]);\n\tql = max<int>(ql, pospb[i]);\n\tupd2(f[i], seg2::query(1, ql, qr, l, mid));\n    }\n\n    rep(i, mid + 1, r) {\n\tint ql = l, qr = mid;\n\tqr = min<int>(qr, posa[i] - 1);\n\tqr = min<int>(qr, posb[i] - 1);\n\tql = max<int>(ql, pospb[i]);\n\t\n\tint p = pospa[i] - 1;\n\tupd2(f[i], seg1::query(rt[p], ql, qr, l, mid));\n    }\n    \n    rep(i, l, r) {\n\tvala[i] = valb[i] = a[i] = c[i] = 0;\n\tb[i] = d[i] = inf;\n\trt[i] = 0;\n    }\n    tt = 0;\n\n    solve(mid + 1, r);\n}\n\nint main() {\n    // freopen(\"elect.in\", \"r\", stdin);\n    // freopen(\"elect.out\", \"w\", stdout);\n    \n    ios::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    cin >> n;\n    rep(i, 1, n) cin >> l[i] >> r[i];\n    rep(i, 1, n) f[i] = mp(-inf, 0);\n\n    memset(b, 0x3f, sizeof b);\n    memset(d, 0x3f, sizeof d);\n    f[0] = mp(0, 1);\n    seg1::val[0] = mp(-inf, 0);\n\n    solve(1, n);\n    \n    if(f[n].fi <= 0) cout << \"NIE\" << \"\\n\";\n    else cout << f[n].fi << \" \" << f[n].se << \"\\n\";\n    cout.flush();\n\n    return 0;\n}\n```",
        "postTime": 1648881045,
        "uid": 95103,
        "name": "KellyFrog",
        "ccfLevel": 9,
        "title": "\u9898\u89e3\u3010P5979 [PA2014]Druzyny\u3011"
    },
    {
        "content": "\u9996\u5148\uff0c\u5bb9\u6613\u5f97\u5230\u4e00\u4e2a\u6734\u7d20 dp\uff1a\u8bbe $f_i$ \u4e3a\u524d $i$ \u4e2a\u4eba\u5212\u5206\u7684\u6700\u5927\u7ec4\uff0c\u679a\u4e3e\u6700\u540e\u4e00\u6b21\u5212\u5206\u70b9\uff0c\u6709\n\n$$f_i=\\max(f_j+1)(\\max(c_{j+1},c_{j+2}...c_i)\\le i-j\\le \\min(d_{j+1},d_{j+2}...d_i))$$\n\n\u5bf9\u4e8e\u8ba1\u6570\uff0c\u8bbe $g_i$ \u4e3a $f_i$ \u53d6\u6700\u5927\u503c\u7684\u65b9\u6848\u6570\uff0c\u628a\u6240\u6709\u80fd\u8ba9 $f$ \u53d6\u6700\u5927\u503c\u7684\u8f6c\u79fb\u7684 $g$ \u52a0\u8d77\u6765\u5373\u53ef\u3002\n\n\u8003\u8651\u5206\u6cbb\u4f18\u5316\u3002\n\n\u8bb0\u5f53\u524d\u533a\u95f4\u4e3a $[l,r]$\u3002\n\n\u9996\u5148\u627e\u5230 $[l+1,r]$ \u4e2d $c_k$ \u6700\u5927\u7684 $k$\uff0c\u5148\u9012\u5f52\u5904\u7406 $[l,k-1]$\uff0c\u7136\u540e\u8003\u8651 $[l,k-1]$ \u5bf9 $[k,r]$ \u7684\u8d21\u732e\uff0c\u6700\u540e\u9012\u5f52\u5904\u7406 $[k,r]$\u3002\n\n\u8fd9\u6837\u5904\u7406\u6709\u4e00\u4e2a\u6027\u8d28\uff1a$[l,k-1]$ \u5bf9 $[k,r]$ \u66f4\u65b0\u65f6\uff0c$c$ \u6700\u5927\u7684\u503c\u6c38\u8fdc\u662f $c_k$\uff0c\u8fd9\u6837\u5c31\u538b\u4e86\u4e00\u4e2a\u9650\u5236\u3002\n\n\u5bf9\u4e8e\u5de6\u533a\u95f4\u957f\u5ea6\u66f4\u957f\u7684\u60c5\u51b5\uff0c\u679a\u4e3e\u53f3\u533a\u95f4\u7684\u6bcf\u4e2a\u70b9 $i$\uff0c\u5219\u5de6\u533a\u95f4\u5185**\u80fd\u66f4\u65b0\u8fd9\u4e2a\u70b9** $j$ \u7684\u6700\u5c0f\u503c\u662f $\\min(k-1,i-c_k)$\uff0c\u6700\u5927\u503c\u662f $\\max(l,lim_i)$\u3002\u5176\u4e2d $lim_i$ \u4e3a\u6700\u5927\u7684\u6ee1\u8db3 $d$ \u9650\u5236\u7684 $j$\u3002\n\n\u5bf9\u4e8e\u53f3\u533a\u95f4\u957f\u5ea6\u66f4\u957f\u7684\u60c5\u51b5\uff0c\u679a\u4e3e\u5de6\u533a\u95f4\u7684\u6bcf\u4e2a\u70b9 $j$\uff0c\u5219\u53f3\u533a\u95f4\u5185**\u80fd\u88ab\u8fd9\u4e2a\u70b9\u66f4\u65b0**\u7684 $i$ \u7684\u6700\u5c0f\u503c\u662f $\\max(k,j+c_k)$\uff0c\u6700\u5927\u503c\u662f $\\min(r,lim2_j)$\u3002\u5176\u4e2d $lim2_j$ \u4e3a\u6700\u5927\u7684\u6ee1\u8db3 $d$ \u9650\u5236\u7684 $i$\u3002\n\n\u5bf9\u4e8e $lim,lim2$ \u7684\u5904\u7406\uff0c\u53ef\u4ee5\u63a8\u51fa\u6765\u6709\u5355\u8c03\u6027\uff0c\u53cc\u6307\u9488 +multiset \u53ef\u4ee5\u5728 $O(nlogn)$ \u7684\u590d\u6742\u5ea6\u9884\u5904\u7406\u3002\n\n\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 $f$ \u548c $g$\uff0c\u6211\u4eec\u9700\u8981\u652f\u6301\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n1. \u67e5\u8be2\u533a\u95f4 $c$ \u6700\u5927\u503c\u548c\u4f4d\u7f6e\u3002\n2. \u67e5\u8be2\u533a\u95f4 $f$ \u6700\u5927\u503c\u3002\n3. \u533a\u95f4 $f$ \u4e0e\u4e00\u4e2a\u6570\u53d6 $\\max$ \u5e76\u7ef4\u62a4 $g$\u3002\n\n\u590d\u6742\u5ea6\u8bc1\u660e\u7c7b\u4f3c\u542f\u53d1\u5f0f\u5206\u88c2\uff0c\u6bcf\u5c42\u7528\u8f83\u5c0f\u533a\u95f4\u7684\u590d\u6742\u5ea6\u5904\u7406\u3002\n\n\u7136\u540e\u5982\u679c\u4f60\u548c\u6211\u4e00\u6837\u5927\u5e38\u6570\uff0c\u53ef\u80fd\u9700\u8981\u4e00\u4e2a\u526a\u679d\uff1a\u679a\u4e3e\u53f3\u533a\u95f4 $lim_i\\ge k$ \u65f6\uff0c\u6216\u8005\u679a\u4e3e\u5de6\u533a\u95f4 $i+c_k\\ge r$ \u65f6\uff0c\u4e4b\u540e\u4e5f\u4e0d\u4f1a\u6709\u5408\u6cd5\u7684\u533a\u95f4\uff0c\u76f4\u63a5 `break`\u3002\n\n\u4ee3\u7801\u6bd4\u8f83\u4e11\uff0c\u5c31\u4e0d\u653e\u4e86\u3002",
        "postTime": 1644797115,
        "uid": 196899,
        "name": "lndjy",
        "ccfLevel": 9,
        "title": "P5979 \u9898\u89e3"
    },
    {
        "content": "## \u66f4\u597d\u4f53\u9a8c\n\n- [\u535a\u5ba2\u56ed](https://www.cnblogs.com/kyeecccccc/p/17247889.html)\n\n- [\u6d1b\u8c37\u535a\u5ba2](https://ky-ee.blog.luogu.org/solution-p5979)\n\n## \u7b80\u8981\u9898\u610f\n\n> \u6709 $n$ \u4e2a\u4eba\uff0c\u628a\u4ed6\u4eec\u5212\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u533a\u95f4\uff0c\u5176\u4e2d\u7b2c $i$ \u4e2a\u4eba\u8981\u6c42\u5b83\u6240\u5728\u7684\u533a\u95f4\u957f\u5ea6\u5927\u4e8e\u7b49\u4e8e $c_i$\uff0c\u5c0f\u4e8e\u7b49\u4e8e $d_i$\uff0c\u6c42\u6700\u591a\u7684\u533a\u95f4\u6570\u91cf\u4ee5\u53ca\u5982\u6b64\u5212\u5206\u7684\u65b9\u6848\u6570\u3002\n>\n> \u6570\u636e\u8303\u56f4\uff1a$1\\le n \\le 10^6, 1\\le c_i, d_i\\le n$\u3002\u65f6\u95f4\u9650\u5236 7s\uff08\u4f18\u79c0\u89e3 500-700ms\uff0c\u6211\u7684\u5783\u573e\u5927\u5e38\u6570\u5b9e\u73b0 2s\uff0c\u6211\u90fd\u89c9\u5f97\u5199\u5047\u4e86\uff09\u3002\n\n## \u9898\u89e3\n\n\u65b9\u6848\u6570\u662f trivial \u7684\uff0c\u5b9e\u73b0\u4e00\u4e2a `Data` \u7c7b\uff0c\u5408\u5e76\u4fe1\u606f\u7684\u65f6\u5019\u540c\u65f6\u7ef4\u62a4\u6700\u5927\u503c\u548c\u65b9\u6848\u6570\u5373\u53ef\u3002\u6ce8\u610f\u4fe1\u606f\u5931\u53bb\u4e86\u5e42\u7b49\u6027\u3002\n\n\u9996\u5148\u8003\u8651\u6734\u7d20 DP\uff0c\u8bbe $f_i$ \u8868\u793a\u524d $i$ \u4e2a\u6570\u53ef\u4ee5\u5212\u5206\u6210\u7684\u6700\u5927\u533a\u95f4\u6570\u3002\u8f6c\u79fb\u679a\u4e3e\u4e0a\u4e00\u6bb5\u7684\u7aef\u70b9\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $\\Theta(n^2)$\u3002\n\n\u4e0b\u9762\u8003\u8651\u4f18\u5316\u3002\u6ce8\u610f\u5230\u7ebf\u6027\u7ed3\u6784\uff0c\u8f6c\u79fb\u5f7c\u6b64\u72ec\u7acb\uff0c\u8003\u8651\u5206\u6cbb\u4f18\u5316\u3002\u9898\u89e3\u533a\u8bb8\u591a\u89e3\u6cd5\u4f3c\u4e4e\u662f\u6807\u51c6 CDQ \u5206\u6cbb\u505a\u6cd5\uff0c\u7136\u800c\u65f6\u95f4\u590d\u6742\u5ea6\u662f\u53cc $\\log$ \u7684\u540c\u65f6\u5b9e\u73b0\u4e5f\u8f83\u4e3a\u590d\u6742\u3002\u6211\u6ca1\u6709\u7814\u7a76\u3002\n\n\u8fd9\u9898\u5904\u7406\u7684\u96be\u70b9\u5728\u4e8e\u6211\u8981\u540c\u65f6\u7ef4\u62a4 $c$ \u548c $d$ \u4e24\u4e2a\u65b9\u5411\u7684\u9650\u5236\uff0c\u80fd\u8f6c\u79fb\u5230 $i$ \u7684\u6240\u6709 $j$ \u5206\u5e03\u5f88\u8be1\u5f02\uff0c\u800c CDQ \u5206\u6cbb\u5e76\u4e0d\u80fd\u5e2e\u52a9\u6539\u5584\u8fd9\u4e00\u70b9\u3002\u800c\u6211\u4eec\u5bf9\u4e8e $c, d$ \u5173\u6ce8\u7684\u53ea\u6709\u6700\u503c\u3002\u8fd9\u542f\u793a\u6211\u4eec\u4f7f\u7528\u6700\u503c\u5206\u6cbb\u7684\u505a\u6cd5\uff0c\u5c06\u5176\u4e2d\u4e00\u4e2a\u7684\u6700\u503c\u5bf9\u5e94\u70b9\u653e\u5230\u5206\u6cbb\u4e2d\u5fc3\uff0c\u8fd9\u6837\u6240\u6709\u5de6\u533a\u95f4\u5230\u53f3\u533a\u95f4\u7684\u8f6c\u79fb\u90fd\u4f1a\u8de8\u8d8a\u8fd9\u4e2a\u70b9\uff0c\u5b83\u53c8\u662f\u6700\u503c\uff0c\u76f8\u5f53\u4e8e\u8fd9\u4e00\u7ef4\u9650\u5236\u88ab\u56fa\u5b9a\u4e86\u3002\u89c2\u5bdf\u9898\u76ee\u53ef\u4ee5\u53d1\u73b0\uff0c$d$ \u4f5c\u4e3a\u4e0a\u754c\u9650\u5236\uff0c\u53ea\u8003\u8651\u5b83\u9650\u5236\u4e0b\u80fd\u5bf9 $i$ \u8fdb\u884c\u8f6c\u79fb\u7684 $j$ \u4e00\u5b9a\u662f $[0, i - 1]$ \u7684\u4e00\u6bb5\u540e\u7f00\uff0c\u8bbe\u4e3a $[pre_i, i - 1]$\uff0c\u8fd9\u4e2a\u4e1c\u897f\u5f88\u597d\u9884\u5904\u7406\uff0c\u5e76\u4e14\u5f88\u4f18\u7f8e\uff08\u6ce8\u610f\u5230 $pre_i$ \u4e0d\u964d\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u56fa\u5b9a $c$\uff0c\u5f53\u524d\u5206\u6cbb\u533a\u95f4\u8bbe\u4e3a $[l, r]$\uff0c\u4e2d\u70b9\u8bbe\u4e3a $mid$\uff08\u6ce8\u610f\u5de6\u533a\u95f4\u662f $[l, mid)$\uff09\uff0c\u90a3\u4e48\u80fd\u8f6c\u79fb\u5230\u53f3\u533a\u95f4 $i$ \u7684 $j$ \u6240\u5c5e\u533a\u95f4\u662f $[l, mid)\\cap [pre_i, i - c_{mid}]$\u3002\n\n\u7136\u800c\u6700\u503c\u5206\u6cbb\u5931\u53bb\u4e86\u5206\u6cbb\u5c42\u6570 $\\log$ \u7684\u7279\u6027\uff0c\u4e00\u822c\u5730\u9700\u8981\u5728\u5408\u5e76\u65f6\u7cbe\u7ec6\u5b9e\u73b0\u6765\u907f\u514d\u9000\u5316\u6210\u5e73\u65b9\uff08\u6211\u5c31\u9000\u5316\u8fc7\uff09\u3002\u5f53\u7136\uff0c\u5206\u6cbb\u533a\u95f4\u603b\u4e2a\u6570\u4ecd\u7136\u4fdd\u8bc1\u662f $\\Theta(n)$ \u7684\u3002\u63a5\u4e0b\u6765\u8003\u8651\u5206\u7c7b\u8f6c\u79fb\uff1a\n\n1. $i < l + c_mid$ \u6216\u8005 $pre_i \\ge mid$\uff1a\u5f88\u5bb9\u6613\u6392\u9664\u6389\u3002\n\n1. $pre_i < l, i - c_{mid} < mid$\uff1a\u533a\u95f4\u662f $[l, mid)$ \u7684\u524d\u7f00\uff0c\u968f\u7740 $i$ \u4e0d\u65ad\u589e\u52a0\uff0c\u53f3\u7aef\u70b9\u53ea\u4f1a\u6bcf\u6b21\u79fb\u52a8 1\uff0c\u90a3\u4e48\u7b2c\u4e00\u6b21\u5728\u7ebf\u6bb5\u6811\u4e0a\u67e5\u4e00\u4e0b\uff0c\u540e\u9762\u5c31\u76f4\u63a5\u7528 $f_j$ \u6765 $\\Theta(1)$ \u66f4\u65b0\u5373\u53ef\u3002\u8fd9\u4e00\u90e8\u5206\u7684\u65f6\u95f4\u590d\u6742\u5ea6\uff1a\u7b2c\u4e00\u6b21\u67e5\u7ebf\u6bb5\u6811 $\\Theta(n\\log n)$\uff0c\u540e\u9762\u7684\u66f4\u65b0\u6b21\u6570\u53ea\u4f1a\u662f\u5de6\u53f3\u533a\u95f4\u957f\u5ea6\u7684 $\\min$\uff0c\u7c7b\u6bd4\u542f\u53d1\u5f0f\u5408\u5e76\u53ef\u4ee5\u5f97\u5230\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathrm O(n\\log n)$\u3002\n\n1. $pre_i < l, i - c_{mid} \\ge mid$\uff1a\u533a\u95f4\u662f $[l, mid)$\uff0c\u4e8c\u5206\u4e00\u4e0b\u53f3\u8fb9\u80fd\u88ab\u8fd9\u6837\u66f4\u65b0\u7684 $i$\uff0c\u4e00\u5b9a\u4e5f\u662f\u4e2a\u533a\u95f4\uff0c\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u67e5\u4e00\u4e0b\uff0c\u533a\u95f4\u53d6 $max$ \u4e00\u4e0b\uff0c$\\Theta(n\\log n)$\u3002\n\n1. $pre_i \\in [l, mid), i - c_{mid} \\ge mid$\uff1a\u5168\u90e8\u66b4\u529b $\\Theta(\\log n)$\uff0c\u8fd9\u662f\u56e0\u4e3a\u5bf9\u4e8e\u4e00\u4e2a $i$\uff0c\u5b83\u6240\u5c5e\u7684\u6240\u6709\u5206\u6cbb\u53f3\u533a\u95f4\uff0c\u6240\u5bf9\u5e94\u7684\u5206\u6cbb\u5de6\u533a\u95f4\u4e24\u4e24\u4e0d\u4ea4\uff08\u53ef\u4ee5\u753b\u51fa\u5206\u6cbb\u6811\u770b\u4e00\u4e0b\uff09\uff0c\u6240\u4ee5 $pre_i$ \u53ea\u5c5e\u4e8e\u5176\u4e2d\u67d0\u4e00\u4e2a\uff0c\u4e8e\u662f\u6bcf\u4e2a $i$ \u53ea\u4f1a\u8fd9\u6837\u66b4\u529b\u8f6c\u79fb\u4e00\u6b21\u3002\n\n\u4e8e\u662f\u8fd9\u6837\u505a\u5b8c\u4e86\uff0c\u603b\u590d\u6742\u5ea6 $\\Theta(n\\log n)$\u3002\n\n## \u4ee3\u7801\n\n```cpp\n// Author: kyEEcccccc\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing LL = long long;\nusing ULL = unsigned long long;\n\n#define F(i, l, r) for (int i = (l); i <= (r); ++i)\n#define FF(i, r, l) for (int i = (r); i >= (l); --i)\n#define MAX(a, b) ((a) = max(a, b))\n#define MIN(a, b) ((a) = min(a, b))\n#define SZ(a) ((int)((a).size()) - 1)\n\nconst int N = 1000005, MOD = 1000000007;\n\nint n, c[N], d[N];\n\nstruct Data { int mx; LL s; };\n\nData mer(Data x, Data y)\n{\n\tData r = {max(x.mx, y.mx), 0};\n\tif (x.mx == r.mx) r.s += x.s;\n\tif (y.mx == r.mx) (r.s += y.s) %= MOD;\n\treturn r;\n}\n\nstruct SegTree\n{\n\tData x[N << 2], tg[N << 2];\n\n\tvoid init(int p, int cl, int cr)\n\t{\n\t\tx[p] = tg[p] = {-n, 0};\n\t\tif (cl == cr) return;\n\t\tint cm = cl + cr >> 1;\n\t\tinit(p << 1, cl, cm);\n\t\tinit(p << 1 | 1, cm + 1, cr);\n\t}\n\n\tvoid pushdown(int p)\n\t{\n\t\tData d = tg[p]; tg[p] = {-n, 0};\n\t\tx[p << 1] = mer(x[p << 1], d);\n\t\tx[p << 1 | 1] = mer(x[p << 1 | 1], d);\n\t\ttg[p << 1] = mer(tg[p << 1], d);\n\t\ttg[p << 1 | 1] = mer(tg[p << 1 | 1], d);\n\t}\n\n\tData get_max(int p, int cl, int cr, int l, int r)\n\t{\n\t\tif (l > r) return {-n, 0};\n\t\tif (cl >= l && cr <= r) return x[p];\n\t\tpushdown(p);\n\t\tint cm = cl + cr >> 1;\n\t\tif (l <= cm && r > cm)\n\t\t{\n\t\t\treturn mer(get_max(p << 1, cl, cm, l, r),\n\t\t\t\tget_max(p << 1 | 1, cm + 1, cr, l, r));\n\t\t}\n\t\telse if (l <= cm) return get_max(p << 1, cl, cm, l, r);\n\t\telse return get_max(p << 1 | 1, cm + 1, cr, l, r);\n\t}\n\n\tvoid assign_max(int p, int cl, int cr, int l, int r, Data d)\n\t{\n\t\tif (l > r) return;\n\t\tif (cl >= l && cr <= r)\n\t\t{\n\t\t\tx[p] = mer(x[p], d), tg[p] = mer(tg[p], d);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(p);\n\t\tint cm = cl + cr >> 1;\n\t\tif (l <= cm) assign_max(p << 1, cl, cm, l, r, d);\n\t\tif (r > cm) assign_max(p << 1 | 1, cm + 1, cr, l, r, d);\n\t\tx[p] = mer(x[p << 1], x[p << 1 | 1]);\n\t}\n} sgt;\n\nint pre[N];\nData f[N];\n\nstruct SegTree2\n{\n\tint x[N << 2];\n\n\tvoid init(int p, int cl, int cr)\n\t{\n\t\tif (cl == cr) return x[p] = cl, void();\n\t\tint cm = cl + cr >> 1;\n\t\tinit(p << 1, cl, cm);\n\t\tinit(p << 1 | 1, cm + 1, cr);\n\t\tif (c[x[p << 1]] > c[x[p << 1 | 1]]) x[p] = x[p << 1];\n\t\telse x[p] = x[p << 1 | 1];\n\t}\n\n\tint get_max(int p, int cl, int cr, int l, int r)\n\t{\n\t\tif (cl >= l && cr <= r) return x[p];\n\t\tint cm = cl + cr >> 1;\n\t\tif (l <= cm && r > cm)\n\t\t{\n\t\t\tint a = get_max(p << 1, cl, cm, l, r),\n\t\t\t\tb = get_max(p << 1 | 1, cm + 1, cr, l, r);\n\t\t\treturn c[a] > c[b] ? a : b;\n\t\t}\n\t\telse if (l <= cm) return get_max(p << 1, cl, cm, l, r);\n\t\telse return get_max(p << 1 | 1, cm + 1, cr, l, r);\n\t}\n} sgt2;\n\nvoid solve(int l, int r)\n{\n\tif (l == r)\n\t{\n\t\tData t = f[l];\n\t\tf[l] = mer(f[l], sgt.get_max(1, 0, n, l, l));\n\t\tsgt.assign_max(1, 0, n, l, l, t);\n\t\treturn;\n\t}\n\n\tint mid = sgt2.get_max(1, 1, n, l + 1, r) - 1, mxc = c[mid + 1];\n\n\tsolve(l, mid);\n\n\tint p = max(mid + 1, l + mxc);\n\tData cur_x = {INT_MIN, 0};\n\twhile (p <= r && p - mxc < mid && pre[p] <= l)\n\t{\n\t\tif (cur_x.mx == INT_MIN) cur_x = sgt.get_max(1, 0, n, l, p - mxc);\n\t\telse cur_x = mer(cur_x, f[p - mxc]);\n\t\tData x = cur_x; ++x.mx;\n\t\tf[p] = mer(f[p], x);\n\t\t++p;\n\t}\n\tif (p > r) goto SOLVE_R;\n\n\tif (pre[p] <= l)\n\t{\n\t\tint cl = p, cr = r, ca = p;\n\t\twhile (cl <= cr)\n\t\t{\n\t\t\tint cm = cl + cr >> 1;\n\t\t\tif (pre[cm] <= l) ca = cm, cl = cm + 1;\n\t\t\telse cr = cm - 1;\n\t\t}\n\t\tData x = sgt.get_max(1, 0, n, l, mid); ++x.mx;\n\t\tsgt.assign_max(1, 0, n, p, ca, x);\n\t\tp = ca + 1;\n\t}\n\tif (p > r) goto SOLVE_R;\n\n\twhile (p <= r && pre[p] <= mid)\n\t{\n\t\tData x = sgt.get_max(1, 0, n, pre[p], min(mid, p - mxc));\n\t\t++x.mx;\n\t\tf[p] = mer(f[p], x);\n\t\t++p;\n\t}\n\n\tSOLVE_R: solve(mid + 1, r);\n}\n\nstruct SegTree3\n{\n\tint x[N << 2];\n\n\tvoid init(int p, int cl, int cr)\n\t{\n\t\tif (cl == cr) return x[p] = d[cl], void();\n\t\tint cm = cl + cr >> 1;\n\t\tinit(p << 1, cl, cm);\n\t\tinit(p << 1 | 1, cm + 1, cr);\n\t\tx[p] = min(x[p << 1], x[p << 1 | 1]);\n\t}\n\n\tint get_min(int p, int cl, int cr, int l, int r)\n\t{\n\t\tif (cl >= l && cr <= r) return x[p];\n\t\tint cm = cl + cr >> 1;\n\t\tif (l <= cm && r > cm)\n\t\t{\n\t\t\treturn min(get_min(p << 1, cl, cm, l, r),\n\t\t\t\tget_min(p << 1 | 1, cm + 1, cr, l, r));\n\t\t}\n\t\telse if (l <= cm) return get_min(p << 1, cl, cm, l, r);\n\t\telse return get_min(p << 1 | 1, cm + 1, cr, l, r);\n\t}\n} sgt3;\n\nsigned main(void)\n{\n\t// freopen(\".in\", \"r\", stdin);\n\t// freopen(\".out\", \"w\", stdout);\n\tios::sync_with_stdio(0), cin.tie(nullptr);\n\n\tcin >> n;\n\tF(i, 1, n) cin >> c[i] >> d[i];\n\n\tsgt3.init(1, 1, n);\n\tpre[1] = 0;\n\tF(i, 2, n)\n\t{\n\t\tpre[i] = pre[i - 1];\n\t\twhile (sgt3.get_min(1, 1, n, pre[i] + 1, i) < i - pre[i]) ++pre[i];\n\t\t// cout << i << \": \" << pre[i] << '\\n';\n\t}\n\n\tf[0] = {0, 1};\n\tF(i, 1, n) f[i] = {-n, 0};\n\tsgt.init(1, 0, n);\n\n\tsgt2.init(1, 1, n);\n\tsolve(0, n);\n\n\t// F(i, 0, n) cout << i << \": \" << f[i].mx << ' ' << f[i].s << '\\n';\n\n\tif (f[n].s == 0) cout << \"NIE\" << endl;\n\telse cout << f[n].mx << ' '  << f[n].s << endl;\n\t\n\treturn 0;\n}\n```",
        "postTime": 1679561429,
        "uid": 312811,
        "name": "Retired_kyEEcccccc",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5979 [PA2014]Druzyny"
    },
    {
        "content": "\u6a21\u62df\u8d5b\u7684\u9898\uff0c\u573a\u4e0a\u6ca1\u8c03\u5b8c\uff0c\u7834\u9632\u4e86\u3002\n\n\u5148\u8003\u8651\u5982\u679c\u6ca1\u6709 $c_i$ \u8fd9\u4e2a\u9650\u5236\u6211\u4eec\u8be5\u600e\u4e48\u505a\uff0c\u8fd9\u4e2a\u95ee\u9898\u663e\u7136\u662f\u4e00\u4e2a\u666e\u53ca\u7ec4\u9898\u76ee\uff0c\u8bbe $f_i$ \u8868\u793a\u5230 $i$ \u7684\u6700\u5927\u6bb5\u6570\uff0c$g_i$ \u8868\u793a $f_i$ \u7684\u65b9\u6848\uff0c\u7531\u4e8e\u53ea\u6709 $d_i$ \uff0c\u8f6c\u79fb\u663e\u7136\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u76f4\u63a5\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u4f46\u662f\u5f53\u6211\u4eec\u52a0\u5165\u4e86 $c_i$ \u4e4b\u540e\uff0c\u8f6c\u79fb\u5c31\u4e0d\u518d\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u8003\u8651\u600e\u4e48\u53bb\u6389\u8fd9\u4e2a\u9650\u5236\u3002\n\n\u5bb9\u6613\u60f3\u5230\u5206\u6cbb\u8fdb\u884c\u8f6c\u79fb\uff0c\u4f46\u662f\u666e\u901a\u7684 CDQ \u5206\u6cbb\u8f6c\u79fb\u96be\u4ee5\u5904\u7406\u4e0b\u754c\u9650\u5236\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u6309\u7167\u7b1b\u5361\u5c14\u6811\u7684\u7ed3\u6784\u8fdb\u884c\u5206\u6cbb\uff0c\u8fd9\u6837\u7684\u8bdd\u5de6\u8fb9\u5230\u53f3\u8fb9\u7684\u8f6c\u79fb\u7684\u9650\u5236\u5c31\u662f\u5f53\u524d\u8fd9\u68f5\u5b50\u6811\u7684\u6839\u7684\u9650\u5236\u3002\n\n\u4e8e\u662f\u5f88\u5bb9\u6613\u60f3\u5230\u7c7b\u4f3c\u4e8e CDQ\uff0c\u679a\u4e3e\u53f3\u5b50\u6811\u91cc\u7684\u70b9\u3002\u9884\u5904\u7406\u51fa\u53ea\u8003\u8651 $l_i$ \u8868\u793a\u5982\u679c $i$ \u4f5c\u4e3a\u53f3\u7aef\u70b9\u4e14\u4e0d\u8003\u8651 $c_i$ \u7684\u9650\u5236\uff0c\u5176\u5de6\u7aef\u70b9\u6700\u8fdc\u80fd\u5230\u54ea\u91cc\uff0c$r_i$ \u540c\u7406\u3002\u90a3\u4e48\u5728\u53f3\u5b50\u6811\u91cc\u6bcf\u4e2a\u70b9\u7684\u8f6c\u79fb\u90fd\u662f\u5de6\u5b50\u6811\u7684\u4e00\u6bb5\u533a\u95f4\uff0c\u4e8e\u662f\u53ea\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u4f46\u8fd9\u6837\u7684\u590d\u6742\u5ea6\u662f\u4e0d\u5bf9\u7684\uff0c\u56e0\u4e3a\u7b1b\u5361\u5c14\u6811\u5e76\u4e0d\u662f\u5e73\u8861\u7684\u3002\u4e0a\u9762\u7684\u505a\u6cd5\u5f53\u5de6\u5b50\u6811\u5927\u5c0f\u5c0f\u4e8e\u53f3\u5b50\u6811\u5927\u5c0f\u65f6\u6ca1\u6709\u590d\u6742\u5ea6\u4fdd\u8bc1\uff0c\u53ef\u80fd\u4f1a\u9000\u5316\u6210 $O(n^2 \\log n)$\u3002\n\n\u6240\u4ee5\u6211\u4eec\u8003\u8651\u7c7b\u4f3c\u4e8e\u542f\u53d1\u5f0f\u5408\u5e76\u7684\u65b9\u6cd5\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u679a\u4e3e\u5de6\u5b50\u6811\u8f6c\u79fb\u53f3\u5b50\u6811\uff0c\u5bb9\u6613\u53d1\u73b0\u8f6c\u79fb\u4f9d\u65e7\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u4e8e\u662f\u6211\u4eec\u8003\u8651\u5982\u4f55\u7ef4\u62a4\u3002\n\n\u5177\u4f53\u7684\uff0c\u6211\u4eec\u8981\u5b9e\u73b0\u8fd9\u4e48\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff1a\n\n+ \u5355\u70b9\u67e5\u8be2\n\n+ \u5c06\u4e00\u4e2a\u533a\u95f4\u5185\u7684\u6570\u548c $x$ \u53d6 max\uff0c\u540c\u65f6\u7ef4\u62a4\u5176 max \u65b9\u6848\u6570\n\n\u663e\u7136\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u5199\u4e24\u68f5\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u7528\u7c7b\u4f3c\u4e8e\u542f\u53d1\u5f0f\u5408\u5e76\u7684\u5206\u6790\u53ef\u4ee5\u5f97\u77e5\uff0c\u590d\u6742\u5ea6\u5c31\u662f $O(n \\log^2 n)$ \u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u3002\n\n\u4ee3\u7801\u53ef\u80fd\u5199\u7684\u6bd4\u8f83\u4e11\u3002\n\nCode\uff1a\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 5;\nconst int mod = 1e9 + 7;\nconst int inf = 0x3f3f3f3f;\nint n, L[maxn], R[maxn];\ninline int add(int x, int y){\n    return x + y >= mod ? x + y - mod : x + y;\n}\nstruct Node{\n    int x, y;\n    Node(int xx = 0, int yy = 0){\n        x = xx; y = yy;\n    }\n    Node friend operator+(Node n1, Node n2){\n        if(n1.y == 0 && n2.y == 0) return Node(-inf, 0);\n        if(n1.y == 0) return n2;\n        if(n2.y == 0) return n1;\n        if(n1.x == n2.x) return Node(n1.x, add(n1.y, n2.y));\n        if(n1.x < n2.x) return n2;\n        return n1;\n    }\n};\nstruct TreeNode{\n    Node mx; Node sum;\n};\nTreeNode t[maxn << 2];\nvoid pushup(int p){\n    t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum; return ;\n}\nvoid build(int p, int l, int r){\n    t[p].mx = Node(-inf, 0); t[p].sum = Node(-inf, 0);\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r);\n    return ;\n}\nvoid upd(int p, int pl, int pr, int l, int r, int x, int v){\n    if(pl <= l && r <= pr){\n        // cerr << pl << \" \" << pr << \" \" << x << \" \" << v << endl;\n        t[p].mx = t[p].mx + Node(x, v); // cerr << t[p].mx.x << endl;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if(pl <= mid) upd(p << 1, pl, pr, l, mid, x, v);\n    if(pr > mid) upd(p << 1 | 1, pl, pr, mid + 1, r, x, v);\n    return ;\n}\nvoid upd1(int p, int l, int r, int x, Node v){\n    if(l == r){\n        // cerr << \"! \" << x << \" \" << v.x << \" \" << v.y << endl;\n        t[p].sum = v; return ;\n    }\n    int mid = (l + r) >> 1;\n    if(x <= mid) upd1(p << 1, l, mid, x, v);\n    if(x > mid) upd1(p << 1 | 1, mid + 1, r, x, v);\n    pushup(p); // cerr << \":: \" << l << \" \" << r << \" \" << t[p].sum.x << endl;\n    return ;\n}\nNode que1(int p, int pl, int pr, int l, int r){\n    if(pl > pr) return Node(-inf, 0);\n    if(pl <= l && r <= pr) return t[p].sum;\n    int mid = (l + r) >> 1; Node res = Node(-inf, 0);\n    if(pl <= mid) res = res + que1(p << 1, pl, pr, l, mid);\n    if(pr > mid) res = res + que1(p << 1 | 1, pl, pr, mid + 1, r);\n    return res;\n}\nNode que(int p, int l, int r, int x){\n    if(l == r) return t[p].mx;\n    int mid = (l + r) >> 1; Node res = t[p].mx;\n    if(x <= mid) res = res + que(p << 1, l, mid, x);\n    if(x > mid) res = res + que(p << 1 | 1, mid + 1, r, x);\n    return res;\n}\nint st[maxn][21], mlg[maxn];\nint rmq(int x, int y){\n    int len = mlg[y - x + 1];\n    return min(st[x][len], st[y - (1 << len) + 1][len]);\n}\nint rl[maxn], rr[maxn];\nint stk[maxn], top = 0; int rt = 0; int son[maxn][2];\nint sum[maxn]; int lp[maxn], rp[maxn];\nvoid init(int now){\n    if(now == 0) return ;\n    init(son[now][0]); init(son[now][1]);\n    lp[now] = son[now][0] ? lp[son[now][0]] : now;\n    rp[now] = son[now][1] ? rp[son[now][1]] : now;\n    return ;\n}\nint sz(int now){\n    if(now == 0) return 0;\n    return rp[now] - lp[now] + 1;\n}\nvoid dfs(int now){\n    if(now == 0) return ;\n    dfs(son[now][0]);\n    int szl = sz(son[now][0]); int szr = sz(son[now][1]);\n    if(szl > szr){\n        for(int i = now;i <= rp[now];i++){\n            int lt = max(rl[i], lp[now]);\n            int rt = min(now, i - L[now] + 1);\n            if(rt < lp[now] || rt < lt) continue;\n            Node val = que1(1, lt - 1, rt - 1, 0, n);\n            upd(1, i, i, 0, n, val.x + 1, val.y);\n            // cerr << lt - 1 << \" \" << rt - 1 << \" -> \" << i << \" \" << val.y << endl;\n        }\n    }\n    if(szl <= szr){\n        for(int i = lp[now] - 1;i < now;i++){\n            Node val = que(1, 0, n, i);\n            int lt = max(now, i + L[now]);\n            int rt = min(rr[i + 1], rp[now]);\n            // cerr << i << \" \" << now << \" \" << lt << \" \" << rp[now] << endl;\n            if(lt > rp[now] || rt < lt) continue;\n            upd(1, lt, rt, 0, n, val.x + 1, val.y);\n            // cerr << i << \" -> \" << lt << \" \" << rt << endl;\n        }\n    }\n    Node nowval = que(1, 0, n, now); upd1(1, 0, n, now, nowval);\n    dfs(son[now][1]); return ;\n}\nint main(){\n    // freopen(\"elect.in\", \"r\", stdin);\n    // freopen(\"tmp.out\", \"w\", stdout);\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    cin >> n;\n    for(int i = 1;i <= n;i++){\n        cin >> L[i] >> R[i]; st[i][0] = R[i];\n    }\n    for(int j = 1;(1 << j) <= n;j++){\n        for(int i = 1;i + (1 << j) - 1 <= n;i++){\n            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);\n        }\n    }\n    mlg[1] = 0;\n    for(int i = 1;i <= n;i++){\n        mlg[i] = mlg[i - 1] + ((1 << (mlg[i - 1] + 1)) == i);\n    }\n    for(int i = 1;i <= n;i++){\n        int pl = i, pr = n, res = i;\n        while(pl <= pr){\n            int mid = (pl + pr) >> 1;\n            if(rmq(i, mid) >= mid - i + 1){\n                res = mid; pl = mid + 1;\n            } else {\n                pr = mid - 1;\n            }\n        }\n        rr[i] = res; pl = 1; pr = i; res = i;\n        while(pl <= pr){\n            int mid = (pl + pr) >> 1;\n            if(rmq(mid, i) >= i - mid + 1){\n                res = mid; pr = mid - 1;\n            } else {\n                pl = mid + 1;\n            }\n        }\n        rl[i] = res;\n    }\n    // cerr << \"ok\" << endl;\n    for(int i = 1;i <= n;i++){\n        int las = 0;\n        while(top && L[stk[top]] <= L[i]){\n            son[stk[top]][1] = las; las = stk[top]; top--;\n        }\n        son[i][0] = las; stk[++top] = i;\n    }\n    while(top > 1){\n        son[stk[top - 1]][1] = stk[top]; top--;\n    }\n    rt = stk[1];\n    // for(int i = 1;i <= n;i++) cerr << son[i][0] << \" \" << son[i][1] << endl;\n    build(1, 0, n); upd(1, 0, 0, 0, n, 0, 1);\n    upd1(1, 0, n, 0, Node(0, 1));\n    init(rt); dfs(rt);\n    Node val = que(1, 0, n, n);\n    if(val.y == 0) cout << \"NIE\" << endl;\n    else cout << val.x << \" \" << val.y << endl;\n    return 0;\n}\n```",
        "postTime": 1648889545,
        "uid": 177999,
        "name": "juicyyou",
        "ccfLevel": 9,
        "title": "P5979 [PA2014]Druzyny"
    }
]