[
    {
        "content": "[\u6765\u535a\u5ba2\u56ed\u91cc\u770b /kel /kel /kel /kel /kel](https://www.cnblogs.com/zkyJuruo/p/14317051.html)\n\n\u770b\u9898\u89e3\u91cc\u90fd\u662f\u591a\u70b9\u6c42\u503c\uff0c\u4f46\u662f\u8fd9\u4e0d\u662f\u663e\u7136\u53ef\u4ee5\u5206\u6cbb $\\tt FFT$ \u5417 /yiw\n\n\u8003\u8651\u628a\u4e0b\u964d\u5e42\u5206\u6210\u4e24\u534a\uff0c$F(x) = G(x) = \\sum\\limits_{i = 0}^{mid} b_i x^{\\underline{i}} + x^{\\underline{mid+1}} \\sum\\limits_{i = mid + 1}^{n - 1} b_i (x - mid - 1)^{\\underline{i - mid - 1}}$\n\n\u53d1\u73b0\u5de6\u8fb9\u90a3\u90e8\u5206\u7684\u6b21\u6570\u662f $mid$ \u6b21\uff0c\u53f3\u8fb9\u90a3\u90e8\u5206\u662f $mid+1$ \u6b21\u591a\u9879\u5f0f $x^{\\underline{mid+1}}$ \u7684\u500d\u6570\u3002\n\n\u5de6\u8fb9\u90a3\u90e8\u5206\u76f8\u5f53\u4e8e\u628a $F(x)$ \u5bf9 $x^{\\underline{mid + 1}}$ \u53d6\u6a21\uff0c\u53f3\u8fb9\u90a3\u90e8\u5206\u76f8\u5f53\u4e8e $F(x)$ \u5bf9 $x^{\\underline{mid + 1}}$ \u505a\u9664\u6cd5\u3002\n\n\u4e8e\u662f\u505a\u4e00\u904d\u591a\u9879\u5f0f\u9664\u6cd5\uff0c\u5c31\u53d8\u6210\u8981\u7b97 $\\sum\\limits_{i = 0}^{mid} b_i x^{\\underline{i}}$ \u548c $\\sum\\limits_{i = mid + 1}^{n - 1} b_i (x - mid)^{\\underline{i - mid - 1}}$ \u3002\n\n\u8fd9\u4e2a\u4e1c\u897f\u5206\u6cbb\u4e0b\u53bb\u7b97\u5c31\u884c\u4e86\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $\\Theta(n \\log ^ 2 n)$\n\n\u6bcf\u6b21\u5206\u6cbb\u53ea\u9700\u8981\u4e00\u6b21\u53d6\u6a21\uff0c\u5feb\u4e8e\u591a\u70b9\u6c42\u503c\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define L(i, j, k) for(int i = j, i##E = k; i <= i##E; i++)\n#define R(i, j, k) for(int i = j, i##E = k; i >= i##E; i--)\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define pii pair<int, int>\n#define mkp make_pair\nusing namespace std;\nchar buf[512], *p1 = buf, *p2 = buf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,512,stdin),p1==p2)?EOF:*p1++)\ninline int read() {\n\tint x = 0; char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + (ch ^ 48), ch = getchar();\n\treturn x;\n}\nvoid print(int x) {\n    if(x > 9) print(x / 10);\n    putchar(x % 10 + '0');\n}\nconst int N = (1 << 21), mod = 998244353, G = 3, iG = (mod + 1) / G;\nint qpow(int x, int y = mod - 2) {\n\tint res = 1;\n\tfor(; y; x = (ll) x * x % mod, y >>= 1) if(y & 1) res = (ll) res * x % mod;\n\treturn res;\n}\nint *A[N], tmp[N * 40], *Id = tmp; \nint Lim, lim, pp[N], PowG[N], iPowG[N];\nvoid revlim() { L(i, 0, lim - 1) pp[i] = ((pp[i >> 1] >> 1) | ((i & 1) * (lim >> 1))); }\nvoid up(int x) { lim = 1; for(; lim <= x; lim <<= 1); }\nvoid cle(int *f) { L(i, 0, lim - 1) f[i] = 0; }\nvoid init(int x) {\n\tint Pw;\n\tup(x), Lim = lim;\n\tPw = qpow(G, (mod - 1) / Lim), PowG[0] = 1;\n\tL(i, 1, lim - 1) PowG[i] = (ll) PowG[i - 1] * Pw % mod;\n\tPw = qpow(iG, (mod - 1) / Lim), iPowG[0] = 1;\n\tL(i, 1, lim - 1) iPowG[i] = (ll) iPowG[i - 1] * Pw % mod;\n}\nvoid NTT(int *f, int flag) {\n\tL(i, 0, lim - 1) if(pp[i] < i) swap(f[pp[i]], f[i]);\n\tfor(int i = 2; i <= lim; i <<= 1) \n\t\tfor(int j = 0, l = (i >> 1), ch = Lim / i; j < lim; j += i) \n\t\t\tfor(int k = j, now = 0; k < j + l; k ++) {\n\t\t\t\tint pa = f[k], pb = (ll) f[k + l] * (flag == 1 ? PowG[now] : iPowG[now]) % mod;\n\t\t\t\tf[k] = (pa + pb) % mod, f[k + l] = (pa + mod - pb) % mod, now += ch;\n\t\t\t}\n\tif(flag == -1) {\n\t\tint nylim = qpow(lim);\n\t\tL(i, 0, lim - 1) f[i] = (ll) f[i] * nylim % mod;\n\t}\n}\nint sav[N], sv[N], svA[N], svB[N];\nvoid inv(int *f, int *g, int len) { \n\tif(len == 1) return g[0] = qpow(f[0]), void();\n\tinv(f, g, (len + 1) >> 1), up(len << 1), cle(sav), copy(f, f + len, sav), revlim(), NTT(sav, 1), NTT(g, 1);\n\tL(i, 0, lim - 1) g[i] = (ll) g[i] * (2ll + mod - (ll) g[i] * sav[i] % mod) % mod;\n\tNTT(g, -1), fill(g + len, g + lim, 0);\n}\nvoid Mul(int *f, int *g, int *ans, int n, int m) {\n\tstatic int A[N], B[N];\n\tup(n + m), revlim(), cle(A), cle(B), copy(f, f + n, A), copy(g, g + m, B);\n\tNTT(A, 1), NTT(B, 1);\n\tL(i, 0, lim - 1) A[i] = (ll) A[i] * B[i] % mod;\n\tNTT(A, -1), copy(A, A + n + m - 1, ans);\n}\nvoid div(int *f, int *g, int *ansa, int *ansb, int n, int m) {\n\tstatic int A[N];\n\treverse(f, f + n), reverse(g, g + m), up((n - m + 1) << 1), cle(A);\n\tinv(g, A, n - m + 1), Mul(f, A, A, n - m + 1, n - m + 1);\n\treverse(A, A + n - m + 1), copy(A, A + n - m + 1, ansa);\n\treverse(f, f + n), reverse(g, g + m), Mul(g, A, A, m, n - m + 1);\n\tL(i, 0, m - 2) ansb[i] = (f[i] - A[i] + mod) % mod;\n}\nint ans[N], sava[N], savb[N];\nvoid div1(int id, int l, int r) {\n\tA[id] = Id, Id += r - l + 2;\n\tif(l == r) return A[id][0] = mod - l, A[id][1] = 1, void();\n\tint mid = (l + r) >> 1;\n\tdiv1(id << 1, l, mid), div1(id << 1 | 1, mid + 1, r);\n\tup(r - l + 1), revlim(), cle(svA), cle(svB);\n\tcopy(A[id << 1], A[id << 1] + mid - l + 2, svA), copy(A[id << 1 | 1], A[id << 1 | 1] + r - mid + 1, svB);\n\tNTT(svA, 1), NTT(svB, 1);\n\tL(i, 0, lim - 1) svA[i] = (ll) svA[i] * svB[i] % mod;\n\tNTT(svA, -1), copy(svA, svA + r - l + 2, A[id]);\n}\nvoid div2(int id, int l, int r, int *f) {\n\tif(l == r) return ans[l] = f[0], void();\n\tint len = r - l + 1, mid = (l + r) >> 1, La = mid - l + 1, Lb = r - mid, *a1, *a2;\n\ta1 = Id, Id += La + 1, a2 = Id, Id += Lb + 1;\n\tup(len + Lb), cle(sava), cle(savb);\n\tdiv(f, A[id << 1], savb, sava, len, La + 1);\n\tcopy(sava, sava + La, a1), copy(savb, savb + Lb, a2);\n\tdiv2(id << 1, l, mid, a1), div2(id << 1 | 1, mid + 1, r, a2);\n}\nint n, m, f[N], g[N], ansa[N], ansb[N];\nint main() {\n\tn = read(), init(n * 2);\n\tL(i, 0, n - 1) f[i] = read();\n\tdiv1(1, 0, n - 1), div2(1, 0, n - 1, f);\n\tL(i, 0, n - 1) print(ans[i]), putchar(' ');\n\treturn 0;\n} \n```\n\n\u5176\u5b9e\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f\u4e5f\u53ef\u4ee5\u5206\u6cbb $\\tt FFT$\uff0c\u4f46\u90a3\u9053\u9898\u7684\u9898\u89e3\u533a\u91cc\u6709\u4e14\u6bd4\u8f83\u663e\u7136\u5c31\u4e0d\u8bb2\u4e86\u3002\n\n**\u795d\u5927\u5bb6\u5b66\u4e60\u6109\u5feb\uff01**",
        "postTime": 1611373362,
        "uid": 173660,
        "name": "zhoukangyang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5383 \u3010\u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3011"
    },
    {
        "content": "\u4eca\u5929\u4e0a\u8bfe\u4e86\u89e3\u5230\u4e86\u8fd9\u4e2a\u77e5\u8bc6\uff0c\u4e8e\u662f\u6765\u5199\u4e00\u5199\u3002\n\n\u8fd9\u7bc7\u9898\u89e3**\u4e0d**\u9700\u8981\u591a\u70b9\u6c42\u503c\uff01**\u4e0d**\u9700\u8981\u591a\u9879\u5f0f\u9664\u6cd5\uff01\n\n## \u4e0b\u964d\u5e42\u591a\u9879\u5f0f\n\n\u5f62\u5982 $f(x) = \\sum_{i = 0}^{n}a_i x^{\\underline{i} }$ \u7684\u591a\u9879\u5f0f\u88ab\u79f0\u4e3a**\u4e0b\u964d\u5e42\u591a\u9879\u5f0f**\u3002\n\n\u5b83\u6709\u4e00\u4e9b\u7edd\u5999\u7684\u6027\u8d28\u3002\n\n\u6c42\u503c\uff1a\u53ef\u4ee5\u5feb\u901f\u6c42\u4e00\u6bb5 $0 \\sim m$ \u5185\u7684\u6240\u6709\u70b9\u503c\u3002\n\n\u63d2\u503c\uff1a\u53ef\u4ee5\u6839\u636e $0 \\sim n + 1$ \u7684\u70b9\u503c\u7b80\u5355\u5730\u63d2\u51fa\u8fd9\u4e2a\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3002\n\n\u5bf9\u4e8e\u6c42\u503c\uff0c\u8003\u8651\n\n$$\n\\begin{aligned}\nf(x) & = \\sum_{i = 0}^{n} a_i x^{\\underline{i} } \\\\\n& = x!\\sum_{i = 0}^{n} a_i \\frac{1}{(x - i)!}\n\\end{aligned}\n$$\n\n\u53ea\u9700\u8981\u6c42 $f$ \u548c $\\exp$ \u7684\u5377\u79ef\uff0c\u4e58\u4e0a $x!$ \u5373\u53ef\u8ba1\u7b97\u51fa $f(x)$\u3002\n\n\u5bf9\u4e8e\u63d2\u503c\uff0c\u8003\u8651\n\n$$\n\\begin{aligned}\nf(x) & = \\sum_{i = 0}^{n} a_i x^{\\underline{i} } \\\\\n& = \\sum_{i = 0}^{x} \\binom{x}{i} i! a_i\n\\end{aligned}\n$$\n\n\u4e8c\u9879\u5f0f\u53cd\u6f14\u3002\n\n$$\n\\begin{aligned}\na_x & = \\frac{1}{x!} \\sum_{i = 0}^{x} (-1)^{x - i} \\binom{x}{i} f(i) \\\\\n& = \\sum_{i = 0}^{x}\\frac{f(i)}{i!} \\cdot \\frac{(-1)^{x - i}}{(x - i)!}\n\\end{aligned}\n$$\n\n\u8fd9\u6837\u5c31\u7528 $0 \\sim n$ \u5904\u7684\u70b9\u503c\u63d2\u51fa\u4e86\u6240\u6709 $a_i$\u3002\u53ea\u9700\u8981\u4e00\u6b21\u5377\u79ef\u3002\n\n## \u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\n\n\u8003\u8651\u5206\u6cbb\u3002\n\n\u8bbe $f$ \u4e3a\u5f85\u8f6c\u6362\u7684\u666e\u901a\u591a\u9879\u5f0f\uff0c$g$ \u4e3a\u8f6c\u6362\u540e\u7684\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3002\n\n\u5c06 $f_{l\\sim mid}$ \u4e0e $f_{mid + 1 \\sim r}$ \u9012\u5f52\u5904\u7406\uff0c\u6c42\u51fa $g_{l\\sim mid}$ \u548c $g_{mid + 1 \\sim r}$\u3002\n\n\u8bbe $m = mid - l + 1$\uff0c$len = r - l + 1$\u3002\n\n\u90a3\u4e48 $g_{l\\sim r} = g_{l\\sim mid} + x^m \\cdot g_{mid + 1 \\sim r}$\u3002\n\n\u8003\u8651 $x^{m} \\cdot g_{\\ldots}$ \u600e\u4e48\u6c42\u3002\u5176\u4e2d $g$ \u5df2\u7ecf\u662f\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u4e86\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u6c42\u51fa $x^{m}$ \u4e0e $g$ \u5728 $0 \\sim len - 1$ \u5904\u7684\u6240\u6709\u70b9\u503c\uff0c$x^m$ \u53ef\u4ee5\u66b4\u529b\uff0c$g$ \u53ef\u4ee5\u91c7\u7528\u4e0a\u8ff0\u65b9\u6cd5\u5904\u7406\u3002\n\n\u7136\u540e\u5c06\u70b9\u503c\u4e24\u4e24\u76f8\u4e58\u5f97\u5230 $x^m\\cdot g$ \u7684\u70b9\u503c\uff0c\u518d\u63d2\u503c\u56de\u53bb\u5373\u53ef\u5f97\u5230 $x^m\\cdot g$\u3002\n\n\u8fd9\u6837\u6211\u4eec\u5c31\u5c06 $g_{l\\sim mid}$ \u548c $g_{mid + 1 \\sim r}$ \u5408\u5e76\u6210\u4e86 $g_{l\\sim r}$\u3002\n\nCode:\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define per(i, a, b) for (int i = (a); i >= (b); --i)\nusing namespace std;\nconst int N = 1 << 18 | 5;\nconst int mod = 998244353;\nint qpow(int a, int b) {\n    int res = 1;\n    while (b) {\n        if (b & 1) res = res * a % mod;\n        a = a * a % mod;\n        b >>= 1;\n    }\n    return res;\n}\nint rev[N];\nvoid NTT(int *f, int n, int sign) {\n    int p = __lg(n);\n    rep(i, 0, n - 1) {\n        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (p - 1));\n        if (i < rev[i]) swap(f[i], f[rev[i]]);\n    }\n    for (int len = 2; len <= n; len <<= 1) {\n        int w = qpow(3, (mod - 1) / len), mid = len >> 1;\n        for (int i = 0; i < n; i += len) {\n            int now = 1;\n            rep(j, 0, mid - 1) {\n                int tx = f[i + j], ty = f[i + j + mid] * now % mod;\n                f[i + j] = (tx + ty) % mod;\n                f[i + j + mid] = (tx - ty + mod) % mod;\n                now = now * w % mod;\n            }\n        }\n    }\n    if (sign == -1) {\n        reverse(f + 1, f + n);\n        int inv = qpow(n, mod - 2);\n        rep(i, 0, n - 1) f[i] = f[i] * inv % mod;\n    }\n}\nint n, f[N], g[N], gl[N], gr[N];\nint ex[N], fac[N], ifac[N];\nint C(int n, int m) {\n    return fac[n] * ifac[m] % mod * ifac[n - m] % mod;\n}\nvoid solve(int l, int r) {\n    if (l == r) {\n        g[l] = f[l];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    solve(l, mid);\n    solve(mid + 1, r);\n    int m = mid - l + 1, mr = r - mid;\n    // * x ^ m\n    rep(i, 0, m - 1) gl[i] = g[i + l];\n    rep(i, 0, mr - 1) gr[i] = g[i + mid + 1];\n    // gr\n    // 0 ~ m + mr - 1\n    rep(i, 0, m + mr - 1) ex[i] = ifac[i];\n    int p = 0;\n    while ((1 << p) <= mr - 1 + m + mr - 1) ++p;\n    rep(i, mr, (1 << p) - 1) gr[i] = 0;\n    rep(i, m + mr, (1 << p) - 1) ex[i] = 0;\n    NTT(gr, 1 << p, 1); NTT(ex, 1 << p, 1);\n    rep(i, 0, (1 << p) - 1) ex[i] = ex[i] * gr[i] % mod;\n    NTT(ex, 1 << p, -1);\n    rep(i, 0, m + mr - 1) ex[i] = ex[i] * qpow(i, m) % mod; // * fac[i] * ifac[i]\n    rep(i, 0, m + mr - 1) {\n        int fl = 1;\n        if (i & 1) fl = mod - 1;\n        gr[i] = ifac[i] * fl % mod;\n    }\n    p = 0;\n    while ((1 << p) <= m + mr - 1 + m + mr - 1) ++p;\n    rep(i, m + mr, (1 << p) - 1) ex[i] = gr[i] = 0;\n    NTT(gr, 1 << p, 1); NTT(ex, 1 << p, 1);\n    rep(i, 0, (1 << p) - 1) ex[i] = ex[i] * gr[i] % mod;\n    NTT(ex, 1 << p, -1);\n    rep(i, 0, m + mr - 1) g[i + l] = ((i < m ? gl[i] : 0) + ex[i]) % mod;\n}\nsigned main() {\n    fac[0] = 1;\n    rep(i, 1, N - 5) fac[i] = fac[i - 1] * i % mod;\n    ifac[N - 5] = qpow(fac[N - 5], mod - 2);\n    per(i, N - 6, 0) ifac[i] = ifac[i + 1] * (i + 1) % mod;\n    scanf(\"%lld\", &n);\n    rep(i, 0, n - 1) scanf(\"%lld\", &f[i]);\n    solve(0, n - 1);\n    rep(i, 0, n - 1) printf(\"%lld \", g[i]);\n    return 0;\n}\n```",
        "postTime": 1660219022,
        "uid": 76156,
        "name": "henrytb",
        "ccfLevel": 8,
        "title": "\u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f"
    },
    {
        "content": "**\u524d\u7f6e\u829d\u58eb**:\n\n\u751f\u6210\u51fd\u6570\n\n[P5394 \u3010\u6a21\u677f\u3011\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u4e58\u6cd5](https://www.luogu.org/problem/P5394)\n\n[P5050 \u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u591a\u70b9\u6c42\u503c](https://www.luogu.org/problem/P5050)\n\n\u201c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u4e58\u6cd5\u201d\u7684\u4e3b\u8981\u601d\u60f3\u5c31\u662f(**\u8fde\u7eed**)\u70b9\u503cEGF\u548c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u4e4b\u95f4\u7684$O(nlogn)$\u8f6c\u6362,\u79f0\u4e4b\u4e3a(I)FDT\u3002\n\n\u5177\u4f53\u53ef\u89c1[Link](https://www.luogu.org/blog/command-block/solution-p5394)\n\n\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u91c7\u7528\u591a\u70b9\u6c42\u503c\u6c42\u51fa\u539f\u666e\u901a\u591a\u9879\u5f0f\u5728$1...n$\u7684\u70b9\u503c,\u7136\u540eIFDT\u53d8\u6210\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3002\n\n\u8bf4\u8d77\u6765\u7b80\u5355\u7801\u8d77\u6765\u96be\u2026\u2026\u5df2\u7ecf\u7a81\u7834\u4e86\u6211\u5728luogu\u6700\u957fAC\u4ee3\u7801\u7684\u8bb0\u5f55\u2026\u2026\n\n\u522b\u5fd8\u8bb0\u662fEGF,\u8981\u4e58\u9636\u4e58\u9006\u5143\u7684!\n\n```cpp\n// luogu-judger-enable-o2\n#include<algorithm>\n#include<cstdio>\n#define mod 998244353\n#define G 3\n#define Maxn 140000\n#define ll long long \nusing namespace std;\ninline int read()\n{\n  register int X=0;\n  register char ch=0;\n  while(ch<48||ch>57)ch=getchar();\n  while(ch>=48&&ch<=57)X=X*10+(ch^48),ch=getchar();\n  return X;\n}\nint r[Maxn<<1];\nlong long invn,invG;\nll powM(ll a,ll t=mod-2)\n{\n  ll ans=1;\n  while(t){\n  \tif(t&1)ans=ans*a%mod;\n  \ta=a*a%mod;\n  \tt>>=1;\n  }return ans;\n}\ninline void print(long long *f,int len)\n{\n  for (int i=0;i<len;i++)\n   printf(\"%lld \",f[i]);\n  puts(\"\");\n}\n//f=g\ninline void cop(ll *f,ll *g,int len)\n{for (int i=0;i<len;i++)f[i]=g[i];}\nvoid NTT(ll *f,int n,int op)\n{\n  for (int i=0;i<n;i++)\n    if (r[i]<i)swap(f[r[i]],f[i]);\n  for (int p=2;p<=n;p<<=1){\n  \tint len=p>>1,\n  \t    w=powM(op==1 ?G:invG,(mod-1)/p);\n  \tfor (int k=0;k<n;k+=p){\n  \t  ll buf=1;\n  \t  for (int i=k;i<k+len;i++){\n  \t  \tint sav=f[len+i]*buf%mod;\n  \t  \tf[len+i]=f[i]-sav;\n  \t  \tif (f[len+i]<0)f[len+i]+=mod;\n  \t  \tf[i]=f[i]+sav;\n  \t  \tif (f[i]>=mod)f[i]-=mod;\n  \t  \tbuf=buf*w%mod;\n  \t  }\n    }\n  }\n}\nll _g[Maxn<<1];//f*=g\nvoid times(ll *f,ll *gg,int len1,int len2,int limit)\n{\n  int n=1;for(;n<len1+len2;n<<=1);\n  ll *g=_g;\n  for (int i=0;i<len2;i++)g[i]=gg[i];\n  for(int i=0;i<n;i++)\n    r[i]=(r[i>>1]>>1)|((i&1)?n>>1:0);\n  NTT(f,n,1);NTT(g,n,1);\n  for(int i=0;i<n;++i)f[i]=f[i]*g[i]%mod;\n  NTT(f,n,-1);invn=powM(n);\n  for(int i=0;i<limit;++i)f[i]=f[i]*invn%mod;\n  for(int i=limit;i<n;++i)f[i]=0;\n  for (int i=0;i<n;i++)g[i]=0;\n}\nll _sav[Maxn<<1];//f*=g\ninline void savtimes(ll *f,ll *g,int len1,int len2,int limit)\n{\n  for (int i=0;i<len1;i++)_sav[i]=f[i];\n  times(_sav,g,len1,len2,limit);\n  for(int i=0;i<limit;++i)f[i]=_sav[i];\n  for(int i=0;i<limit;++i)_sav[i]=0;\n}\nll _r[Maxn<<1],_rr[Maxn<<1];\nvoid invp(ll *f,int len)\n{\n  ll *r=_r,*rr=_rr;\n  int n=1;for(;n<len;n<<=1);\n  rr[0]=powM(f[0]);\n  for (int len=2;len<=n;len<<=1){\n  \tfor (int i=0;i<len;i++)\n  \t  r[i]=(rr[i]<<1)%mod;\n  \ttimes(rr,rr,len>>1,len>>1,len);\n  \ttimes(rr,f,len,len,len);\n  \tfor (int i=0;i<len;i++)\n  \t  rr[i]=(r[i]-rr[i]+mod)%mod;\n  }for (int i=0;i<len;i++)f[i]=rr[i];\n  for (int i=0;i<n;i++)r[i]=rr[i]=0;\n}\nll *sav=_g;\nvoid fan(ll *f,int m)\n{\n  for (int i=0;i<m;i++)sav[i]=f[i];\n  for (int i=0;i<m;i++)f[i]=sav[m-i-1];\n  for (int i=0;i<m;i++)sav[i]=0;\n}\nll _q[Maxn<<1],_t[Maxn<<1];//f%=g\nvoid mof(ll *f,ll *g,int n,int m)\n{\n  ll *q=_q,*t=_t;\n  fan(g,m);cop(q,g,n-m+1);fan(g,m);\n  invp(q,n-m+1);\n  fan(f,n);cop(t,f,n-m+1);fan(f,n);\n  times(q,t,n-m+1,n-m+1,n-m+1);\n  fan(q,n-m+1);\n  times(q,g,n-m+1,m,n);\n  for (int i=0;i<m-1;i++)f[i]=(f[i]-q[i]+mod)%mod;\n  for (int i=m-1;i<n;i++)f[i]=0;\n  for (int i=0;i<n;i++)q[i]=t[i]=0;\n}\nll gl[17][Maxn<<1];\nvoid qfpre(int lev,int l,int r)\n{\n  if (l==r){\n    gl[lev][l<<1]=mod-l;\n    gl[lev][l<<1|1]=1;\n    return ;\n  }int mid=(l+r)>>1;\n  qfpre(lev+1,l,mid);\n  qfpre(lev+1,mid+1,r);\n  cop(&gl[lev][l<<1],&gl[lev+1][l<<1],mid-l+2);\n  savtimes(&gl[lev][l<<1],&gl[lev+1][(mid+1)<<1],mid-l+2,r-mid+1,r-l+2);\n}\nll _s1[Maxn<<1],_s2[Maxn<<1];\nvoid _queryf(int lev,int l,int r,ll *f,ll *y)\n{\n  if (r-l<=400){\n    for (int i=l;i<=r;i++){\n      long long buf=1;\n      for (int j=l+l;j<l+r+1;j++){\n        y[i]=(y[i]+buf*f[j])%mod;\n        buf=buf*i%mod;\n      }\n    }return ;\n  }int mid=(l+r)>>1;\n  cop(_s1,&f[l<<1],r-l+1);\n  mof(_s1,&gl[lev+1][l<<1],r-l+1,mid-l+2);\n  cop(_s2,&f[l<<1],r-l+1);\n  mof(_s2,&gl[lev+1][(mid+1)<<1],r-l+1,r-mid+1);\n  for (int i=(l<<1);i<(r<<1|1);i++)f[i]=0;\n  cop(&f[l<<1],_s1,mid-l+1);\n  cop(&f[(mid+1)<<1],_s2,r-mid);\n  for (int i=0;i<r-l+1;i++)_s1[i]=_s2[i]=0;\n  _queryf(lev+1,l,mid,f,y);\n  _queryf(lev+1,mid+1,r,f,y);\n}\nvoid queryf(ll *f,ll *y,int n,int m)\n{\n  qfpre(0,0,m-1);\n  if (n>m)mof(f,gl[0],n,m+1);\n  _queryf(0,0,m-1,f,y);\n}\nll fac[Maxn],inv[Maxn];\nvoid Init(int lim)\n{\n  inv[1]=inv[0]=fac[0]=1;\n  for (int i=1;i<=lim;i++)fac[i]=fac[i-1]*i%mod;\n  for (int i=2;i<=lim;i++)\n  \tinv[i]=inv[mod%i]*(mod-mod/i)%mod;\n  for (int i=2;i<=lim;i++)inv[i]=inv[i-1]*inv[i]%mod;\n}\nll _s[Maxn<<2];\nvoid FDT(ll *f,int n)\n{\n  ll *s=_s;\n  for (int i=0;i<n;i++)\n    if (i&1)s[i]=mod-inv[i];\n    else s[i]=inv[i];\n  int len=1;for (;len<n+n;len<<=1);\n  for (int i=n;i<len;i++)s[i]=0;\n  for (int i=0;i<len;i++)\n    r[i]=(r[i>>1]>>1)|(i&1?len>>1:0);\n  NTT(f,len,1);NTT(s,len,1);\n  for (int i=0;i<len;i++)f[i]=f[i]*s[i]%mod;\n  NTT(f,len,-1);invn=powM(len);\n  for (int i=0;i<n;i++)f[i]=f[i]*invn%mod;\n  for (int i=n;i<len;i++)f[i]=0;\n}\nint n;\nll f[Maxn<<1],y[Maxn<<1];\nint main()\n{\n  invG=powM(G);\n  n=read();Init(n);\n  for (int i=0;i<n;i++)f[i]=read();\n  queryf(f,y,n,n);\n  for (int i=0;i<n;i++)y[i]=y[i]*inv[i]%mod;\n  FDT(y,n);\n  for (int i=0;i<n;i++)printf(\"%lld \",y[i]);\n  return 0;\n}\n```\n\n\u66f4\u591a\u4fe1\u606f\u8bf7\u89c1[\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u6742\u8c08](https://www.luogu.org/blog/command-block/xia-xiang-mi-duo-xiang-shi-za-tan)\n",
        "postTime": 1564112890,
        "uid": 58705,
        "name": "command_block",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P5383 \u3010\u3010\u6a21\u677f\u3011\u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3011"
    },
    {
        "content": "\u6838\u5fc3\u5c31\u662f\u628a \u5e42\u7528\u4e0b\u964d\u5e42\u6765\u4ee3\u66ff\u3002\n\n\u4f7f\u7528\u65af\u7279\u6797\u6570\u5c55\u5f00\u5e42\u4e3a\u4e0b\u964d\u5e42:\n\n$$x^n=\\sum_{i=0}^n{x\\choose i}i!S(n,i)=\\sum_{i=0}^nS(n,i)x^{\\underline i}$$\n\n\u90a3\u4e48\u8981\u6c42\u7684\u591a\u9879\u5f0f:\n\n$$\\sum_{i=0}^{n-1}a_ix^i=\\sum_{i=0}^{n-1}a_i\\sum_{j=0}^jS(i,j)x^{\\underline j}$$\n\u4ea4\u6362\u6c42\u548c\u987a\u5e8f:\n$$\\sum_{j=0}^{n-1}x^{\\underline j}\\sum_{i=j}^{n-1} a_iS(i,j)$$\n\n\u90a3\u4e48\u6c42\u51fa\u540e\u9762\u90a3\u4e2a\u4e1c\u897f\u5c31\u884c\u4e86\u3002\u7531\u4e8e\u5f53 $i<j$\u65f6 $S(i,j)=0$,\u6240\u4ee5 $i$ \u53ef\u4ee5\u4ece $0$ \u5f00\u59cb\u679a\u4e3e\u3002\u8fd9\u4e2a\u5c31\u662f\u4e00\u4e2a\u8981\u6c42\u4e00\u5217\u7684\u65af\u7279\u6797\u6570\u7684\u6a21\u578b\u3002\n\n\u628a\u65af\u7279\u6797\u6570\u62c6\u5f00:\n$$\\sum_{i=0}^{n-1}\\frac{a_i}{j!}\\sum_{k=0}^j (-1)^{j-k}{j\\choose k}k^i$$\n\n\u7ec4\u5408\u6570\u62c6\u5f00\u5f62\u6210\u5377\u79ef:\n\n$$\\sum_{k=0}^j\\frac{(-1)^{j-k}}{(j-k)!}*\\sum_{i=0}^{n-1}\\frac{a_ik^i}{k!}$$\n\n\u4ee4 $f_k=\\frac{(-1)^k}{k!},g_k=\\sum_{i=0}^{n-1}\\frac{a_ik^i}{k!}$ ,\u90a3\u4e48\u5bf9 $F(x)$\u4e0e$G(x)$\u505a\u5377\u79ef\u5373\u53ef\u3002\n\n\u6c42 $G(x)$ \u9700\u8981\u591a\u9879\u5f0f\u591a\u70b9\u6c42\u503c\u3002\n\ncode:\n```cpp\n#include<bits/stdc++.h>\n#define Set(a,b) memset(a,b,sizeof(a))\n#define Clear(a,_begin_,_end_) for(int i=_begin_;i<_end_;++i) a[i]=0\n#define Input_Array(a,_begin_,_end_) for(int i=_begin_;i<_end_;++i) init(a[i])\n#define __ NULL\nusing namespace std;\nconst int N=1e5+10,MAXN=N<<2,MAXM=5e6;\ntypedef vector<int> Poly;\ntemplate <typename T> inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}typedef double db;\ntypedef long long ll;\nint Inv[MAXN],rader[MAXN];\nconst int mod=998244353,phi=998244352,SIZE=sizeof(rader),inv2=499122177;\ntemplate<typename T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;return;}\ntemplate<typename T>inline void Dec(T&x,int y){x-=y;if(x <\t0) x+=mod;return;}\ntemplate<typename T>inline int fpow(int x,T k){int ret=1;for(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ret=(ll)ret*x%mod;return ret;}\ninline int Sum(int x,int y){x+=y;if(x>=mod) return x-mod;return x;}\ninline int Dif(int x,int y){x-=y;if(x < 0 ) return x+mod;return x;}\ninline int Init(int n){int len=1,up=-1;while(len<=n) len<<=1,++up;for(int i=0;i<len;++i) rader[i]=(rader[i>>1]>>1)|((i&1)<<up);return len;}\ninline void Calc_Inversion(){Inv[1]=1;for(int i=2;i<MAXN;++i) Inv[i]=(ll)(mod-mod/i)*Inv[mod%i]%mod;return;}\nnamespace NTT{\n\tint wn[30],iwn[30];\n\tinline void Calcw(){for(int i=0;i<30;++i) wn[i]=fpow(3,phi/(1<<i)),iwn[i]=fpow(wn[i],mod-2);}\n\tinline void NTT(int*A,int n,int f){\n\t\tfor(int i=0;i<n;++i) if(rader[i]>i) swap(A[i],A[rader[i]]);\n\t\tfor(int i=1,h=1;i<n;++h,i<<=1){\n\t\t\tint W=(~f)? wn[h]:iwn[h];\n\t\t\tfor(int j=0,p=i<<1;j<n;j+=p){\n\t\t\t\tfor(int w=1,k=0;k<i;++k,w=(ll)w*W%mod){\n\t\t\t\t\tint X=A[j|k],Y=(ll)w*A[j|k|i]%mod;\n\t\t\t\t\tA[j|k]=Sum(X,Y),A[j|k|i]=Dif(X,Y);\n\t\t\t\t}\n\t\t\t}\n\t\t}if(!~f) for(int i=0;i<n;++i) A[i]=(ll)A[i]*Inv[n]%mod;\n\t\treturn;\n\t}\n\tinline void Mul(int*a,int*b,int*c,int n,int m) {\n\t\tint L=n+m-1;int len=Init(L);static int A[MAXN],B[MAXN];\n\t\tfor(int i=0;i<n;++i) A[i]=a[i];for(int i=0;i<m;++i) B[i]=b[i];\n\t\tClear(A,n,len);Clear(B,m,len);NTT(A,len,1),NTT(B,len,1);\n\t\tfor(int i=0;i<len;++i) c[i]=(ll)A[i]*B[i]%mod;\n\t\tNTT(c,len,-1);return;\n\t}\n\tinline void Poly_Inv(int*F,int*I,int n){\n\t\tif(n==1) {memset(I,0,SIZE);I[0]=fpow(F[0],mod-2);return;}\n\t\tPoly_Inv(F,I,(n+1)>>1);int L=n<<1,len=Init(L);\n\t\tstatic int A[MAXN];for(int i=0;i<n;++i) A[i]=F[i];Clear(A,n,len);\n\t\tNTT(I,len,1);NTT(A,len,1);\n\t\tfor(int i=0;i<len;++i) I[i]=Dif(Sum(I[i],I[i]),(ll)I[i]*I[i]%mod*A[i]%mod);\n\t\tNTT(I,len,-1);Clear(I,n,len);return;\n\t}\n\tinline void Poly_Mod(int*A,int*B,int*Q,int*R,int n,int m){\n\t\tif(n<m) {for(int i=0;i<=n;++i) R[i]=A[i];return;}\n\t\tstatic int C[MAXN],D[MAXN],E[MAXN];\n\t\tconst int r=(n-m)<<1;int len=1;while(len<=r)len<<=1;\n\t\tfor(int i=0;i<=n-m;++i) D[i]=A[n-i];Clear(D,n-m+1,len);\n\t\tfor(int i=0;i<=m;++i)   E[i]=B[m-i];Clear(E,m+1,len);\n\t\tPoly_Inv(E,C,n-m+1);len=Init(r);NTT(C,len,1),NTT(D,len,1);\n\t\tfor(int i=0;i<len;++i) C[i]=(ll)C[i]*D[i]%mod;\n\t\tNTT(C,len,-1);reverse(E,E+1+m),reverse(C,C+1+n-m);\n\t\tif(Q) for(int i=0;i<=n-m;++i) Q[i]=C[i];\n\t\tlen=Init(n);Clear(C,n-m+1,len);Clear(E,m+1,len);\n\t\tNTT(C,len,1),NTT(E,len,1);\n\t\tfor(int i=0;i<len;++i) C[i]=(ll)C[i]*E[i]%mod;\n\t\tNTT(C,len,-1);for(int i=0;i<m;++i) R[i]=Dif(A[i],C[i]);\n\t\treturn;\n\t}\n#define ls (u<<1)\n#define rs (u<<1|1)\n\tint POOL[MAXM],cnt=0;\n\tint *P[MAXN],*F[MAXN],*G[MAXN],X[N],*val;\n\tinline int* Neospace(int len){int*ret=&POOL[cnt];cnt+=len;return ret;}\n\tinline int Calc(int*F,int n,const int x){int X=1,ret=0;for(int i=0;i<n;++i) Inc(ret,(ll)F[i]*X%mod),X=(ll)X*x%mod;return ret;}\n\tinline void Divide(int u,int l,int r){P[u]=NULL;//\u5206\u6cbb+NTT , \u4fdd\u7559\u4e86\u4e2d\u95f4\u7684\u7ed3\u679c\n\t\tif(l==r) {P[u]=Neospace(2);P[u][0]=mod-X[l];P[u][1]=1;return;}\n\t\tstatic int L[MAXN],R[MAXN];int mid=(l+r)>>1;int LS=ls,RS=rs;\n\t\tDivide(LS,l,mid);Divide(RS,mid+1,r);\n\t\tint n=r-l+2,nl=mid-l+2,nr=r-mid+1;\n\t\tfor(int i=0;i<nl;++i) L[i]=P[LS][i];\n\t\tfor(int i=0;i<nr;++i) R[i]=P[RS][i];\n\t\tMul(L,R,L,nl,nr);P[u]=Neospace(n);\n\t\tfor(int i=0;i<n;++i) P[u][i]=L[i];\n\t\treturn;\n\t}\n\tinline void Poly_Evaluate(int u,int l,int r){// \u591a\u70b9\u6c42\u503c\n\t\tif(r-l+1<=500) {for(int i=l;i<=r;++i) val[i]=Calc(F[u],r-l+1,X[i]);return;}// \u957f\u5ea6\u5c0f\u7684\u66b4\u529b\u8ba1\u7b97\n\t\tint mid=(l+r)>>1,LS=ls,RS=rs;\n\t\tint n=r-l+1,nl=mid-l+1,nr=r-mid;\n\t\tstatic int R[MAXN];\n\t\tF[LS]=Neospace(nl),F[RS]=Neospace(nr);\n\t\tPoly_Mod(F[u],P[LS],__,R,n-1,nl);\n\t\tfor(int i=0;i<nl;++i) F[LS][i]=R[i];\n\t\tPoly_Mod(F[u],P[RS],__,R,n-1,nr);\n\t\tfor(int i=0;i<nr;++i) F[RS][i]=R[i];\n\t\tPoly_Evaluate(LS,l,mid);\n\t\tPoly_Evaluate(RS,mid+1,r);\n\t\treturn;\n\t}\n\tinline void Solve_Evaluation(int*A,int*_X,int*ans,int n,int m){\n\t\tcnt=0;F[1]=Neospace(m);val=ans;\n\t\tfor(int i=1;i<=m;++i) X[i]=_X[i];Divide(1,1,m);\n\t\tPoly_Mod(A,P[1],__,F[1],n-1,m);//\u6ce8\u610f\u6700\u5f00\u59cb\u7684\u591a\u9879\u5f0f\u4e5f\u8981\u53d6\u4e00\u6b21\u6a21\n\t\tPoly_Evaluate(1,1,m);return;\n\t}\n}\nint fac[N],finv[N];\nint main()\n{\n\tCalc_Inversion();NTT::Calcw();\n\tint n;fac[0]=finv[0]=1;init(n);\n\tfor(int i=1;i<n;++i) fac[i]=(ll)fac[i-1]*i%mod,finv[i]=(ll)finv[i-1]*Inv[i]%mod;\n\tstatic int F[MAXN],A[MAXN],X[MAXN];\n\tfor(int i=0;i<n;++i) init(A[i]),X[i+1]=i,F[i]=(i&1)? (mod-finv[i]):finv[i];\n\tNTT::Solve_Evaluation(A,X,X,n,n);\n\tfor(int i=0;i<n;++i) X[i]=(ll)X[i+1]*finv[i]%mod;X[n]=0;\n\tNTT::Mul(X,F,F,n,n);\n\tfor(int i=0;i<n;++i) printf(\"%d \",F[i]);putchar('\\n');\n\treturn 0;\n}\n\n```\n\n\n",
        "postTime": 1558060297,
        "uid": 47803,
        "name": "NeosKnight",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5383 \u3010\u3010\u6a21\u677f\u3011\u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3011"
    },
    {
        "content": "\uff08\u975e\u5e38\u62b1\u6b49\uff0c\u4e0a\u4e00\u6b21\u4ea4\u9519\u4f4d\u7f6e\u4e86\uff0c\u589e\u52a0\u4e86\u7ba1\u7406\u5458\u7684\u5de5\u4f5c\u91cf\uff0c\u4ee5\u540e\u4f1a\u66f4\u52a0\u6ce8\u610f\uff0c\u5e0c\u671b\u7ba1\u7406\u5458\u7ed9\u8fc7/kel\uff09\n\n\n\u5b66\u4e60\u4e86 bztMinamoto \u5927\u4f6c\u7684\u505a\u6cd5\uff0c\u5e0c\u671b\u8fd9\u7bc7\u9898\u89e3\u53ef\u4ee5\u4f7f\u5f97\u90a3\u4e2a\u65b9\u6cd5\u66f4\u52a0\u6613\u4e8e\u7406\u89e3\u3002\n\n\u65e2\u7136\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f\u53ef\u4ee5\u91c7\u53d6\u5206\u6cbb $\\operatorname{NTT}$\uff0c\u90a3\u4e48\u53ef\u4ee5\u731c\u6d4b\u9006\u8fc7\u6765\u4e5f\u53ef\u4ee5\u3002\uff08\u5206\u6cbb\u9664\u6cd5\uff1f\uff1f\uff1f\uff09\n\n\u5f15\u7406\uff1a\u8003\u8651\uff0c$\\forall j>i$\uff0c\u90fd\u6709 $x^{\\underline{j}}\\bmod x^{\\underline{i}}=0$\uff0c\u90a3\u4e48\uff0c\u5982\u679c\u6211\u4eec\u53ea\u662f\u6c42 $x^{\\underline{i}}$ \u9879\u7684\u7cfb\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u628a\u539f\u5f0f\u6a21 $x^{\\underline{i+1}}$\uff0c\u518d\u9664\u4ee5 $x^{\\underline{i}}$ \u83b7\u5f97\u7b54\u6848\u3002\uff08\u4ee5\u4e0b\u9664\u6cd5\u5747\u4e3a\u5e26\u4f59\u9664\u6cd5\uff0c\u5982\u679c\u6ca1\u6709\u5199\u660e\u53d6\u4f59\u6570\uff0c\u5747**\u53ea\u53d6\u5546**\uff09\u3002\n\n\u5982\u679c\u5bf9\u4e8e\u6bcf\u4e2a\u4f4d\u7f6e\u90fd\u505a\u4e24\u6b21\u9664\u6cd5\uff0c\u4f1a\u5bfc\u81f4\u5927\u91cf\u91cd\u590d\u8ba1\u7b97\uff0c\u6240\u4ee5\u53ef\u4ee5\u8003\u8651\u5206\u6cbb\u505a\u3002\n\n**\u5177\u4f53\u505a\u6cd5\uff1a**\n\n\u6211\u4eec\u8bb0 $D_{l,r}$\uff0c\u8868\u793a\uff1a\n$$\nD_{l,r}=\\prod_{i=l}^{r-1}(x-i)\n$$\n\n\u6211\u4eec\u901a\u8fc7\u5206\u6cbb $\\operatorname{NTT}$ \u5904\u7406\u51fa $D_{l,r}$\uff0c\u4e8e\u662f $x^{\\underline{i}}$\uff0c\u4e5f\u5c31\u662f $D_{0,i}$ \u53ef\u4ee5\u901a\u8fc7 $O(\\log n)$ \u4e2a\u533a\u95f4\u5408\u5e76\u51fa\u6765\u3002\n\n\u4e0d\u8fc7\u5f53\u7136\u4e0d\u5fc5\u5982\u6b64\u7e41\u7410\uff0c\u5047\u8bbe\u6211\u4eec\u6b63\u5728\u5904\u7406 $[l,r)$ \u8fd9\u6bb5\u533a\u95f4\u4e2d\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u7684\u7cfb\u6570\uff0c\u4e14\u5df2\u7ecf\u5f97\u5230\uff1a\n\n$$\nF'(x)=\\frac{F(x)\\bmod x^{\\underline{r}}}{x^{\\underline{l}}}\n$$\n\u90a3\u4e48\uff0c\u6211\u4eec\u5c06 $F'(x)$ \u9664\u4ee5 $D_{l,mid}$\uff0c\u5c06\u4f59\u6570\u653e\u5165\u5de6\u5b50\u533a\u95f4\uff0c\u5546\u653e\u5165\u53f3\u5b50\u533a\u95f4\u9012\u5f52\u5904\u7406\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n\\log^{2}n)$\u3002\n\n\u5173\u952e\u4ee3\u7801\uff1a\n\n```c++\nusing namespace Poly_NTT;\n\nconst int N = 1 << 18;\nint n;\npoly F[N << 2], D[N << 2], ans;\n#define lc (k << 1)\n#define rc ((k << 1) | 1) \nvoid calc(int k, int l, int r) {//\u4ee3\u7801\u4e2d\u5747\u4e3a\u95ed\u533a\u95f4\n\tif (l == r) {\n\t\tD[k] = poly(vector <ll> {(mo - l) % mo, 1});\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tcalc(lc, l, mid);\n\tcalc(rc, mid + 1, r);\n\tD[k] = D[lc] * D[rc];\n}\npair <poly, poly> tmp;\nvoid solve(int k, int l, int r) {\n\tif (l == r) {\n\t\tans[l] = F[k][0];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\ttmp = F[k] / D[lc];//second\u4e3a\u4f59\u6570\uff0cfirst\u4e3a\u5546\u3002\n\tF[lc] = tmp.second;\n\tF[rc] = tmp.first;\n\tsolve(lc, l, mid);\n\tsolve(rc, mid + 1, r); \n}\nint main() {\n\tread(n);\n\tF[1].resize(n); ans.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tread(F[1][i]);\n\t}\n\tcalc(1, 0, n - 1);\n\tsolve(1, 0, n - 1);\n\tans.print();\n\treturn 0;\n}\n```\n\n\u76f8\u4fe1\u5927\u5bb6\u90fd\u6709\u81ea\u5df1\u7684\u677f\u5b50\u4e86\uff0c\u5b8c\u6574\u7684\u5c31\u4e0d\u653e\u4e86\uff0c\u8fd0\u7b97\u7b26\u8fd8\u662f\u5f88\u597d\u7406\u89e3\u7684\u5427\u3002\n\n",
        "postTime": 1657117542,
        "uid": 137176,
        "name": "lazytag",
        "ccfLevel": 7,
        "title": "P5383 \u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f \u9898\u89e3"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P5383)\n# \u9898\u76ee\u5927\u610f\n\u7ed9\u51fa\u4e00\u4e2a$n$\u6b21\u666e\u901a\u591a\u9879\u5f0f$F(x)=\\sum_{i=0}^{n-1} a_ix^i$\uff0c\u6c42\u51fa\u4e00\u4e2a\u4e0b\u964d\u5e42\u591a\u9879\u5f0f$G(x)=\\sum_{i=0}^{n-1} b_ix^{\\underline{i}}$\uff0c\u4f7f\u5f97$F(x)=G(x)$\u3002\n\n$n\\le 10^5$\n# \u601d\u8def\n\u8fd9\u4e2a\u9898\u5176\u5b9e\u63a8\u5f0f\u5b50\u7684\u65b9\u6cd5\u6709\u5f88\u591a\u79cd\uff0c\u8fd9\u91cc\u4ecb\u7ecd\u9898\u89e3\u91cc\u9762\u6ca1\u6709\u63d0\u5230\u7684\u4e24\u79cd\u65b9\u6cd5\u3002\u7b2c\u4e00\u79cd\u65b9\u6cd5\u5c31\u662f\u501f\u7528\u4e00\u4e0b[\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u4e58\u6cd5](https://www.cnblogs.com/Dark-Romance/p/13340138.html)\u91cc\u9762\u7684\u5f0f\u5b50\uff0c\u76f4\u63a5\u591a\u70b9\u6c42\u503c\uff0c\u7136\u540e\u7528\u5b83\u7684$\\texttt{EGF}$\u4e58\u4e0a$e^{-x}$\u5c31\u662f\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3002\n\n\u7b2c\u4e8c\u79cd\u65b9\u6cd5\u5c31\u662f\u7528\u65af\u7279\u6797\u53cd\u6f14+\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u7684\u8868\u8fbe\u516c\u5f0f\u63a8\u5f0f\u5b50\uff0c\u8fd9\u91cc\u8bb2\u4e00\u4e0b\u7b2c\u4e8c\u79cd\u3002\n\n\u56e0\u4e3a\u6211\u4eec\u77e5\u9053:\n\n$$x^{\\underline{n}}=\\sum_{i=0}^{n} (-1)^{n-i} \\begin{bmatrix} n\\\\i\\end{bmatrix}x^i$$\n\n\u4e8e\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230:\n\n$$a_i = \\sum_{x=i}^{n} (-1)^{x-i} \\begin{bmatrix}x\\\\i \\end{bmatrix} b_x$$\n\n\u901a\u8fc7\u65af\u7279\u6797\u53cd\u6f14\u53ef\u4ee5\u5f97\u5230:\n\n$$b_i=\\sum_{x=i}^{n} \\begin{Bmatrix}x\\\\i\\end{Bmatrix}a_x$$\n\n\u53c8\u56e0\u4e3a\u6211\u4eec\u77e5\u9053:\n\n$$\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\frac{1}{m!}\\sum_{i=0}^{m} \\binom{m}{i} (-1)^{m-i} i^n$$\n\n\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5f97\u5230:\n\n$$b_i=\\sum_{x=i}^{n} \\frac{a_x}{i!} \\sum_{k=0}^{i} \\binom{i}{k}(-1)^{k-i}k^x$$\n\n\u8c03\u6362\u6c42\u548c\u987a\u5e8f\u3001\u62c6\u5f00\u7ec4\u5408\u6570\u53ef\u4ee5\u5f97\u5230:\n\n$$b_i=\\sum_{k=0}^{i} (\\frac{(-1)^{i-k}}{(i-k)!}\\frac{1}{k!}\\sum_{j=0}^{n-1} a_jk^j)$$\n\n\u7136\u540e\u8fd9\u4e2a\u4e1c\u897f\u62ec\u53f7\u91cc\u9762\u7684$\\sum$\u53ef\u4ee5\u7528\u591a\u70b9\u6c42\u503c\u6c42\u51fa\u6765\u3002\u5176\u5b9e\u548c\u4e0a\u9762\u90a3\u4e2a\u65b9\u6cd5\u7684\u6700\u540e\u7684\u5f0f\u5b50\u662f\u4e00\u6837\u7684\u3002\n\n\u8fd9\u9053\u9898\u6709\u70b9\u5361\u5e38\uff0c\u6240\u4ee5\u591a\u70b9\u6c42\u503c\u7684\u90e8\u5206\u501f\u9274\u4e86$\\texttt{bztMinamoto}$\u7684\u601d\u8def\uff0c\u5c31\u662f\u5f53\u533a\u95f4\u957f\u5ea6\u6bd4\u8f83\u5c0f\u7684\u65f6\u5019\uff0c\u6211\u4eec\u76f4\u63a5\u5faa\u73af\u5c55\u5f00\u66b4\u529b\uff0c\u7ecf\u8fc7\u5b9e\u6d4b\uff0c\u4e0d\u52a0\u4e0a\u8fd9\u79cd\u4f18\u5316\u6211\u7684\u4ee3\u7801\u53ea\u6709$30$\uff0c\u52a0\u4e0a\u4e4b\u540e\u5f00\u4e86 O2 $\\texttt{10.84s}$\u901a\u8fc7\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n\\log^2n)$\u3002\n# $\\texttt{Code}$\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) ((int)x.size())\n#define Int register int\n#define mod 998244353\n#define MAXN 1000005\n\nint mul (int a,int b){return 1ll * a * b % mod;}\nint dec (int a,int b){return a >= b ? a - b : a + mod - b;}\nint add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}\nint qkpow (int a,int k){\n\tint res = 1;for (;k;k >>= 1,a = 1ll * a * a % mod) if (k & 1) res = 1ll * res * a % mod;\n\treturn res;\n}\nint inv (int x){return qkpow (x,mod - 2);}\n\ntypedef vector <int> poly;\n\nint w[MAXN],rev[MAXN];\n\nvoid init_ntt (){\n\tint lim = 1 << 18;\n\tfor (Int i = 0;i < lim;++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << 17);\n\tint Wn = qkpow (3,(mod - 1) / lim);w[lim >> 1] = 1;\n\tfor (Int i = lim / 2 + 1;i < lim;++ i) w[i] = mul (w[i - 1],Wn);\n\tfor (Int i = lim / 2 - 1;i;-- i) w[i] = w[i << 1];\n}\n\nvoid ntt (poly &a,int lim,int type){\n#define G 3\n#define Gi 332748118\n\tstatic int d[MAXN];\n\tfor (Int i = 0,z = 18 - __builtin_ctz(lim);i < lim;++ i) d[rev[i] >> z] = a[i];\n\tfor (Int i = 1;i < lim;i <<= 1)\n\t\tfor (Int j = 0;j < lim;j += i << 1)\n\t\t\tfor (Int k = 0;k < i;++ k){\n\t\t\t\tint x = mul (w[i + k],d[i + j + k]);\n\t\t\t\td[i + j + k] = dec (d[j + k],x),d[j + k] = add (d[j + k],x);\n\t\t\t}\n\tfor (Int i = 0;i < lim;++ i) a[i] = d[i] % mod;\n\tif (type == -1){\n\t\treverse (a.begin() + 1,a.begin() + lim);\n\t\tfor (Int i = 0,Inv = inv (lim);i < lim;++ i) a[i] = mul (a[i],Inv);\n\t}\n#undef G\n#undef Gi \n}\n\npoly operator - (poly a,poly b){\n\ta.resize (max (SZ (a),SZ (b)));\n\tfor (Int i = 0;i < SZ (b);++ i) a[i] = dec (a[i],b[i]);\n\treturn a;\n}\n\npoly operator * (poly a,poly b){\n\tint d = SZ (a) + SZ (b) - 1,lim = 1;while (lim < d) lim <<= 1;\n\ta.resize (lim),b.resize (lim);\n\tntt (a,lim,1),ntt (b,lim,1);\n\tfor (Int i = 0;i < lim;++ i) a[i] = mul (a[i],b[i]);\n\tntt (a,lim,-1),a.resize (d);\n\treturn a;\n}\n\npoly inv (poly a,int n){\n\tpoly b(1,inv (a[0])),c;\n\tfor (Int l = 4;(l >> 2) < n;l <<= 1){\n\t\tc.resize (l >> 1);\n\t\tfor (Int i = 0;i < (l >> 1);++ i) c[i] = i < n ? a[i] : 0;\n\t\tc.resize (l),b.resize (l);\n\t\tntt (c,l,1),ntt (b,l,1);\n\t\tfor (Int i = 0;i < l;++ i) b[i] = mul (b[i],dec (2,mul (b[i],c[i])));\n\t\tntt (b,l,-1),b.resize (l >> 1);\n\t}\n\tb.resize (n);\n\treturn b;\n}\n\npoly inv (poly a){return inv (a,SZ (a));}\n\npoly Mod (poly F,poly G){\n\tint n = SZ (F) - 1,m = SZ (G) - 1;poly Q;Q.resize (m + 1);for (Int i = 0;i <= m;++ i) Q[i] = G[i];\n\treverse (F.begin(),F.end()),reverse (G.begin(),G.end()),reverse (Q.begin(),Q.end()),Q.resize (n - m + 1),Q = inv (Q) * F,Q.resize (n - m + 1),reverse (Q.begin(),Q.end());\n\treverse (F.begin(),F.end()),reverse (G.begin(),G.end()),Q = G * Q,Q.resize (m),Q = F - Q,Q.resize (m);\n\treturn Q;\n}\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,fac[MAXN],ifac[MAXN];\npoly A,BB,CC,DR[MAXN << 2];\n\nvoid divide1 (int i,int l,int r){\n\tif (l == r) return DR[i].resize (2),DR[i][0] = mod - l,DR[i][1] = 1,void ();\n\tint mid = (l + r) >> 1;divide1 (i << 1,l,mid),divide1 (i << 1 | 1,mid + 1,r);\n\tDR[i] = DR[i << 1] * DR[i << 1 | 1];\n}\n\nvoid divide2 (int i,int l,int r,poly AA){\n\tif (l == r) return CC[l] = AA[0],void ();\n\tpoly B = Mod (AA,DR[i << 1]);int mid = (l + r) >> 1;divide2 (i << 1,l,mid,B);B = Mod (AA,DR[i << 1 | 1]);divide2 (i << 1 | 1,mid + 1,r,B);\n}\n\nsigned main(){\n\tinit_ntt(),read (n),A.resize (n);\n\tfac[0] = 1;for (Int i = 1;i <= n;++ i) fac[i] = mul (fac[i - 1],i);\n\tifac[n] = inv (fac[n]);for (Int i = n;i;-- i) ifac[i - 1] = mul (ifac[i],i);\n\tfor (Int i = 0;i < n;++ i) read (A[i]);CC.resize (n);divide1 (1,0,n - 1),divide2 (1,0,n - 1,A),BB.resize (n);\n\tfor (Int i = 0;i < n;++ i) BB[i] = i & 1 ? mod - ifac[i] : ifac[i],CC[i] = mul (CC[i],ifac[i]);BB = BB * CC;\n\tfor (Int i = 0;i < n;++ i) write (BB[i]),putchar (' ');\n\tputchar ('\\n');\n\treturn 0;\n}\n```",
        "postTime": 1595164799,
        "uid": 124781,
        "name": "Walking_Dead",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 \u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f"
    },
    {
        "content": "~~\u4f17\u6240\u5468\u77e5~~\u6709\n\n$$x^k=\\sum_{i=0}^k\\begin{Bmatrix}k\\\\i\\end{Bmatrix}x^{\\underline i}$$\n\n\u5957\uff1a\n\n$$\\sum_{k=0}^{n-1}a_kx^k=\\sum_{k=0}^{n-1}\\sum_{i=0}^ka_k\\begin{Bmatrix}k\\\\i\\end{Bmatrix}x^{\\underline i}=\\sum_{i=0}^n(\\sum_{k=i}^na_k\\begin{Bmatrix}k\\\\i\\end{Bmatrix})x^{\\underline i}$$\n\n\u4e8e\u662f\u7b54\u6848\u5e8f\u5217 $b$ \u5c31\u662f\uff08\u6ce8\u610f\u5728\u8fd9\u91cc\u91cd\u65b0\u6807\u53f7\uff09\n\n$$b_k=\\sum_{i=k}^na_i\\begin{Bmatrix}i\\\\k\\end{Bmatrix}=\\sum_{i=0}^na_i\\begin{Bmatrix}i\\\\k\\end{Bmatrix}$$\n\n\u7b2c\u4e8c\u7c7b\u65af\u7279\u6797\u5c55\u5f00\uff1a\n\n$$b_k=\\sum_{i=0}^na_i\\sum_{t=0}^k\\frac{t^i}{t!}\\frac{(-1)^{k-t}}{(k-t)!}=\\sum_{t=0}^k\\frac{\\sum_{i=0}^na_it^i}{t!}\\frac{(-1)^{k-t}}{(k-t)!}$$\n\n\u6ce8\u610f\u91cc\u9762\u7684\u548c\u5c31\u662f\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\uff01\n\n$$b_k=\\sum_{t=0}^k\\frac{F(t)}{t!}\\frac{(-1)^{k-t}}{(k-t)!}$$\n\n\u7528\u591a\u70b9\u6c42\u503c\u9884\u5904\u7406 $F(0),F(1),\\dots,F(n)$ \u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u6807\u51c6\u5377\u79ef\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\",\"-ffast-math\")\n#pragma GCC optimize(\"-fno-math-errno\")\n#pragma GCC optimize(\"-funsafe-math-optimizations\")\n#pragma GCC optimize(\"-freciprocal-math\")\n#pragma GCC optimize(\"-fno-trapping-math\")\n#pragma GCC optimize(\"-ffinite-math-only\")\n#pragma GCC optimize(\"-fno-stack-protector\")\n#pragma GCC target (\"avx2\",\"sse4.2\",\"fma\")\n#include <immintrin.h>\n// writer: w33z8kqrqk8zzzx33\n#include <bits/stdc++.h>\nusing namespace std;\n\n// https://judge.yosupo.jp/submission/5253\n\nstruct IO {\n  static constexpr size_t buf_size = 1 << 18;\n  char buf_in[buf_size], buf_out[buf_size];\n  size_t pt_in = 0, pt_out = 0, tail_in = 0;\n  char strs[10000 * 4];\n  inline size_t num_digits(long long x) {\n    if (x >= (long long)1e9) {\n      if (x >= (long long)1e18) return 19;\n      if (x >= (long long)1e17) return 18;\n      if (x >= (long long)1e16) return 17;\n      if (x >= (long long)1e15) return 16;\n      if (x >= (long long)1e14) return 15;\n      if (x >= (long long)1e13) return 14;\n      if (x >= (long long)1e12) return 13;\n      if (x >= (long long)1e11) return 12;\n      if (x >= (long long)1e10) return 11;\n      return 10;\n    } else {\n      if (x >= (long long)1e8) return 9;\n      if (x >= (long long)1e7) return 8;\n      if (x >= (long long)1e6) return 7;\n      if (x >= (long long)1e5) return 6;\n      if (x >= (long long)1e4) return 5;\n      if (x >= (long long)1e3) return 4;\n      if (x >= (long long)1e2) return 3;\n      if (x >= (long long)1e1) return 2;\n      return 1;\n    }\n  }\n  IO() {\n    load();\n    for (int i = 0; i < 10000; ++i) {\n      int j = i;\n      for (int t = 3; t >= 0; --t) {\n        strs[i * 4 + t] = j % 10 + '0';\n        j /= 10;\n      }\n    }\n  }\n  ~IO() { flush(); }\n  inline void load() {\n    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);\n    size_t width = tail_in - pt_in;\n    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);\n    pt_in = 0;\n  }\n  inline void flush() {\n    fwrite(buf_out, 1, pt_out, stdout);\n    pt_out = 0;\n  }\n  inline void read(char& c) { c = buf_in[pt_in++]; }\n  template <class T>\n  inline void read(T& x) {\n    if (pt_in + 32 > tail_in) load();\n    char c;\n    do {\n      read(c);\n    } while (c < '0');\n    bool minus = 0;\n    if (c == '-') {\n      minus = 1;\n      read(c);\n    }\n    x = 0;\n    while (c >= '0') {\n      x = x * 10 + (c & 15);\n      read(c);\n    }\n    if (minus) x = -x;\n  }\n  inline void write(char c) { buf_out[pt_out++] = c; }\n  template <class T>\n  inline void write(T x) {\n    if (pt_out > buf_size - 32) flush();\n    if (x < 0) {\n      write('-');\n      x = -x;\n    }\n    size_t digits = num_digits(x);\n    int i;\n    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {\n      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);\n      x /= 10000;\n    }\n    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);\n    pt_out += digits;\n  }\n  inline void write(const char* s) {\n    if (pt_out > buf_size - 32) flush();\n    for (int i = 0; s[i] != 0; ++i) write(s[i]);\n  }\n  template <class T>\n  inline void writeln(T x) {\n    write(x);\n    write('\\n');\n  }\n} io;\n\n#define iter(i, a, b) for(int i=(a); i<(b); i++)\n#define rep(i, a) iter(i, 0, (int)(a))\n#define rep1(i, a) iter(i, 1, (int)(a)+1)\n#define fi first\n#define se second\n#define pb push_back\n#define intsize (sizeof(int))\n \n#define ll long long\n#define pii pair<int, int>\n//#define int ll\nconst int MOD = 998244353;\n\ntypedef unsigned us;\ntypedef unsigned long long ull;\n\nstatic char buf[450 << 20];\nvoid* operator new(size_t s) {\n\tstatic size_t i = sizeof buf;\n\tassert(s < i);\n\treturn (void*)&buf[i -= s];\n}\nvoid operator delete(void*) {}\n\ntemplate<class T> struct ptr {\n\tunsigned ind;\n\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {\n\t\tassert(ind < sizeof buf);\n\t}\n\tT& operator*() const { return *(T*)(buf + ind); }\n\tT* get() const { return &**this; }\n\tT& operator[](int a) const { return (&**this)[a]; }\n\texplicit operator bool() const { return ind; }\n};\n\nnamespace poly {\n\tconst int MOD = 998244353;\n\tconst int IMAG = 86583718;\n\tconst int NTTG = 3;\n\t\n\tint qpow(int b, int e) {\n\t\tint re=1;\n\t\twhile(e){\n\t\t\tif(e&1)re=1ll*re*b%MOD;\n\t\t\tb=1ll*b*b%MOD;e>>=1;\n\t\t}\n\t\treturn re;\n\t}\n\t\n// https://www.luogu.com.cn/record/32153077\n// zzq orz\n#define SZ 524320\nll qp(ll a,ll b)\n{\n\tll ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\nint getK(int n)\n{int s=1; while(s<n) s<<=1; return s;}\nus pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;\nus *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];\n__attribute__((always_inline)) void bit_flip(us*p,int t)\n{\n\tfor(int i=0,j=0;i<t;++i)\n\t{\n\t\tif(i>j) swap(p[i],p[j]);\n\t\tfor(int l=t>>1;(j^=l)<l;l>>=1);\n\t}\n}\nvoid prep(int n)\n{\n\tstatic int t=1;\n\tfor(;t<n;t<<=1)\n\t{\n\t\tint g=qp(3,(MOD-1)/(t*2));\n\t\tus*p,*q;\n\t\tp=p0[t]=ptr; ptr+=max(t,16); p[0]=1;\n\t\tfor(int m=1;m<t;++m)\n\t\t\tp[m]=p[m-1]*(ull)g%us(MOD);\n\t\tbit_flip(p,t);\n\t\tq=q0[t]=ptr; ptr+=max(t,16);\n\t\tfor(int i=0;i<t;++i)\n\t\t\tq[i]=(ull(p[i])<<32)/MOD;\n\t\tg=qp(g,MOD-2);\n\t\tp=p1[t]=ptr; ptr+=max(t,16); p[0]=1;\n\t\tfor(int m=1;m<t;++m)\n\t\t\tp[m]=p[m-1]*(ull)g%us(MOD);\n\t\tbit_flip(p,t);\n\t\tq=q1[t]=ptr; ptr+=max(t,16);\n\t\tfor(int i=0;i<t;++i)\n\t\t\tq[i]=(ull(p[i])<<32)/MOD;\n\t}\n}\ntypedef unsigned long long ull;\n__attribute__((always_inline)) us my_mul(us a,us b,us c)\n{\n\treturn b*(ull)a-((ull(a)*c)>>32)*ull(998244353);\n}\n__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)\n{\n\treturn _mm_mullo_epi32(a,b);\n\t/*\n\t__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)\n\t__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)\n\t__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)\n\t__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)\n\t__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) \n\t__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) \n\t__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)\n\treturn prod;\n\t*/\n}\n__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)\n{\n\t__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)\n\t__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)\n\t__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)\n\t__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)\n\t__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) \n\t__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) \n\t__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)\n\treturn prod;\n}\nvoid ntt(us* __restrict__ x,int n)\n{\n\tint t=n;\n\tfor(int m=1;m<n;m<<=1)\n\t{\n\t\tt>>=1;\n\t\tus* __restrict__ p=p0[m];\n\t\tus* __restrict__ q=q0[m];\n\t\tif(t==1)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\tus v=my_mul(xb[j],p[i],q[i]);\n\t\t\t\t\txa[j]=u+v;\n\t\t\t\t\txb[j]=u-v+us(MOD+MOD);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==2)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\tus v=my_mul(xb[j],p[i],q[i]);\n\t\t\t\t\txa[j]=u+v;\n\t\t\t\t\txb[j]=u-v+us(MOD+MOD);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==4)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\tfor(int j=0;j<t;j+=4)\n\t\t\t\t{\n\t\t\t\t\t__m128i u=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\tu=_mm_sub_epi32(u,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u)),mm));\n\t\t\t\t\t__m128i v=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\tv=_mm_sub_epi32(my_mullo_epu32(v,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v,q4),m1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\t//unfold 2x\n\t\t\t\tfor(int j=0;j<t;j+=8)\n\t\t\t\t{\n\t\t\t\t\t__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));\n\t\t\t\t\t__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));\n\t\t\t\t\tu0=_mm_sub_epi32(u0,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u0)),mm));\n\t\t\t\t\tu1=_mm_sub_epi32(u1,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u1)),mm));\n\t\t\t\t\tv0=_mm_sub_epi32(my_mullo_epu32(v0,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v0,q4),m1));\n\t\t\t\t\tv1=_mm_sub_epi32(my_mullo_epu32(v1,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v1,q4),m1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j+4),\n\t\t\t\t\t_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i)\n\t\tx[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),\n\t\tx[i]-=(x[i]>=us(MOD))*us(MOD);\n}\nvoid intt(us* __restrict__ x,int n)\n{\n\tint t=1;\n\tfor(int m=(n>>1);m;m>>=1)\n\t{\n\t\tus* __restrict__ p=p1[m];\n\t\tus* __restrict__ q=q1[m];\n\t\tif(t==1)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j],v=xb[j];\n\t\t\t\t\txa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\txb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==2)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j],v=xb[j];\n\t\t\t\t\txa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\txb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==4)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\tfor(int j=0;j<t;j+=4)\n\t\t\t\t{\n\t\t\t\t\t__m128i u=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i v=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i uv=_mm_add_epi32(u,v);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv)),mm)));\n\t\t\t\t\tuv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\t//unfold 2x\n\t\t\t\tfor(int j=0;j<t;j+=8)\n\t\t\t\t{\n\t\t\t\t\t__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));\n\t\t\t\t\t__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));\n\t\t\t\t\t__m128i uv0=_mm_add_epi32(u0,v0);\n\t\t\t\t\t__m128i uv1=_mm_add_epi32(u1,v1);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv0)),mm)));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv1)),mm)));\n\t\t\t\t\tuv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);\n\t\t\t\t\tuv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv0,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j+4),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv1,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt<<=1;\n\t}\n\tus rn=qp(n,MOD-2);\n\tfor(int i=0;i<n;++i)\n\t\tx[i]=x[i]*(ull)rn%MOD;\n}\n\t\n\tvoid mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {\n\t\tus n = as+bs-1;\n\t\tif(n >= 40) {\n    \t\twhile(n - (n & (-n))) n += (n & (-n));\n    \t\tassert(!construct);\n    \t\t//constructrev(n);\n    \t\tntt(a, n); ntt(b, n);\n    \t\trep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;\n    \t\tintt(o, n);\n\t\t} else {\n\t\t    static ll tmp[41];\n\t\t    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];\n\t\t    rep(i, n) {\n\t\t        o[i] = tmp[i] % MOD;\n\t\t        tmp[i] = 0;\n\t\t    }\n\t\t}\n\t\titer(i, th, n) o[i] = 0;\n\t\tif(clean) rep(i, n) a[i] = b[i] = 0;\n\t}\n\n\tvoid cfn(us* a, us as, us *o) {\n\t\tstatic us tmp[524320];\n\t\tif(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }\n\t\tcfn(a, (as+1)/2, o); us le = 0;\n\t\twhile((1 << le) < (as << 1)) le++;\n\t\t//constructrev(1 << le);\n\t\tmemcpy(tmp, a, as*intsize);\n\t\tmemset(tmp+as, 0, ((1<<le)-as)*intsize);\n\t\tntt(tmp, 1<<le); ntt(o, 1<<le);\n\t\trep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;\n\t\tintt(o, 1<<le);\n\t\tmemset(o+as, 0, ((1<<le)-as)*intsize);\n\t}\n\n\tvoid init(us n) { prep(n); }\n\t\n\tvoid divide(us *a, us as, us *b, us bs, us *q, us *r) {\n\t\tstatic us ar[524320], br[524320], bin[524320];\n\t\tus th = as, re = as-bs+1;\n\t\t//th = re+1;\n\t\trep(i, as) ar[i] = a[as-1-i];\n\t\trep(i, bs) br[i] = b[bs-1-i];\n\t\tcfn(br, th, bin);\n\t\tmult(ar, th, bin, th, q, 0, 1, re);\n\t\treverse(q, q+re);\n\t\tmult(q, re, b, bs, r, 0, 1, bs - 1);\n\t\trep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;\n\t}\n\t\n}\n\n#define array MY_FUCKING_ARRAY\n\nstruct array {\n    ptr<us> head; us sz;\n    array() : sz(0) { head = nullptr; }\n    array(us size) : sz(size) { head = new us[size]; }\n    us& operator[](const us idx) { return head[idx]; }\n    us* get() { return head.get(); }\n    const us size() { return sz; }\n};\n\narray pol[524320];\n\n\nnamespace Eval {\n    us points[524320];\n    us answer[524320];\n    \n    void init(us idx, us l, us r) {\n        // [l, r)\n        if(r - l == 0) {\n            pol[idx] = array(1);\n            pol[idx][0] = 1;\n            return;\n        }\n        if(r - l == 1) {\n            pol[idx] = array(2);\n            pol[idx][0] = (MOD - points[l]) % MOD;\n            pol[idx][1] = 1;\n            return;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320];\n        init(idx*2, l, (l+r)/2);\n        init(idx*2+1, (l+r)/2, r);\n        us n = pol[idx*2].size();\n        us m = pol[idx*2+1].size();\n        memcpy(tmp1, pol[idx*2].get(), n * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);\n        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);\n        pol[idx] = array(n+m-1);\n        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);\n        //assert(pol[idx] == Eval::pol[idx]);\n    }\n\n    void solve(us idx, us l, us r, array& polynomial) {\n        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];\n        //assert(polynomial.size() == r-l);\n        if(r - l == 0) return;\n        if(r - l == 1) {\n            answer[l] = polynomial[0];\n            return;\n        }\n        us m = (l+r)/2;\n        if(m - l) {\n            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);\n            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);\n            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);\n            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);\n            solve(idx*2, l, m, p2);\n        }\n        if(r - m) { \n            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);\n            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);\n            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);\n            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);\n            solve(idx*2+1, m, r, p2);\n        }\n    }\nus p[524320];\nus dv[524320];\nus rp[524320];\nus BULLsHIT[524320];\n    array eval(array& po, array& v) {\n        us n = po.size(), m = v.size();\n        rep(i, m) {\n            points[i] = v[i];\n            if(!v[i]) v[i] = MOD;\n        }\n        init(1, 0, m);\n        static us tmp[524320];\n        array pp(m);\n        if(n >= m+1) {\n            rep(i, m+1) dv[i] = pol[1][i];\n            rep(i, n) p[i] = po[i];\n            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);\n            memcpy(pp.get(), tmp, m*intsize);\n        } else pp = po;\n        solve(1, 0, m, pp);\n        array res(m); memcpy(res.get(), answer, m*intsize);\n        return res;\n    }\n}\n\n/*\nnamespace Inter {\n    us points[524320], values[524320];\n    \n    array drv, coeff;\n\n    void init(us idx, us l, us r) {\n        // [l, r)\n        if(r - l == 0) {\n            pol[idx] = array(1);\n            pol[idx][0] = 1;\n            return;\n        }\n        if(r - l == 1) {\n            pol[idx] = array(2);\n            pol[idx][0] = (MOD - points[l]) % MOD;\n            pol[idx][1] = 1;\n            return;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320];\n        init(idx*2, l, (l+r)/2);\n        init(idx*2+1, (l+r)/2, r);\n        us n = pol[idx*2].size();\n        us m = pol[idx*2+1].size();\n        memcpy(tmp1, pol[idx*2].get(), n * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);\n        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);\n        pol[idx] = array(n+m-1);\n        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);\n        //assert(pol[idx] == Eval::pol[idx]);\n    }\n    \n    array solve(us idx, us l, us r) {\n        if(r - l == 0) {\n            array ans(1); ans[0] = 1;\n            return ans;\n        }\n        if(r - l == 1) {\n            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;\n            return ans;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];\n        array tmp = solve(idx*2, l, (l+r)/2);\n        array tmpp = solve(idx*2+1, (l+r)/2, r);\n        memcpy(tmp1, tmp.get(), tmp.size() * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);\n        us s1 = tmp.size() + pol[idx*2+1].size() - 1;\n        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); \n        rep(i, tmpp.size()) tmp1[i] = tmpp[i];\n        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);\n        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);\n        us s2 = tmpp.size() + pol[idx*2].size() - 1;\n        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); \n        s2 = max(s2, s1); tmp = array(s2);\n        rep(i, s2) {\n            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);\n            tmp[i] = p;\n            //tmp3[i] = tmp4[i] = 0;\n        }\n        return tmp;\n    }\n\n    array inter(array& pt, array& vl) {\n        assert(pt.size() == vl.size());\n        us n = pt.size();\n        memcpy(points, pt.get(), n * intsize);\n        memcpy(values, vl.get(), n * intsize);\n        init(1, 0, n);\n        drv = array(n);\n        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }\n        coeff = Eval::eval(drv, pt);\n        return solve(1, 0, n);\n    }\n}\n*/\n\n#define pol MY_FUCKING_pol\n\narray pts;\narray pol;\narray tmp;\n\nus fac[524300], ifac[524300], inv[524300];\nus ar1[524320], ar2[524320], f[524320];\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int n; io.read(n);\n    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;\n    iter(i, 2, n+2) {\n    \tinv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;\n    \tfac[i] = 1ll * fac[i-1] * i % MOD;\n    \tifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;\n    }\n    pts = array(n+1);\n    rep(i, n+1) pts[i] = i;\n    pol = array(n);\n    rep(i, n) io.read(pol[i]);\n    int k = 1; while(k < ((n+2) << 1)) k <<= 1;\n    poly::init(k);\n    tmp = Eval::eval(pol, pts);\n    rep(i, n+1) ar1[i] = 1ll * tmp[i] * ifac[i] % MOD;\n    rep(i, n+1) ar2[i] = 1ll * ((i % 2) ? (MOD - 1) : 1) * ifac[i] % MOD;\n    poly::mult(ar1, n+1, ar2, n+1, f, 0);\n    rep(i, n) io.write(f[i]), io.write(' ');\n}\n```",
        "postTime": 1594463554,
        "uid": 220037,
        "name": "w33z8kqrqk8zzzx33",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5383 \u3010\u666e\u901a\u591a\u9879\u5f0f\u8f6c\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u3011"
    }
]