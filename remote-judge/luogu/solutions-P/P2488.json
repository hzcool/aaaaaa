[
    {
        "content": "\u5148\u5410\u69fd\u4e00\u4e0b\u65f6\u9650\uff0c0.5s\u4ec0\u4e48\u9b3c\uff0c\u4e0d\u5e94\u8be5\u662f1s\u4e48\u3002\u3002\n\n\u597d\u5427\u56de\u5230\u6b63\u9898\uff0c\u5148\u89c2\u5bdf\u6570\u636e\u8303\u56f4\uff0cn,m<=250\uff0c\u8fd9\u662f\u660e\u663e\u7684\u7f51\u7edc\u6d41\u7684\u6570\u636e\u8303\u56f4\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u6765\u5efa\u4e00\u4e0b\u56fe\u3002\n\n\u5982\u679c\u629b\u5f00\u5206\u6bb5\u51fd\u6570\uff0c\u8fd9\u9053\u9898\u7684\u5efa\u56fe\u601d\u8def\u5e94\u8be5\u975e\u5e38\u6e05\u6670\uff0cS\u5f80\u4eba\u8fde\u8d39\u7528\u4e3a\u6124\u6012\u503c\u7684\u8fb9\uff0c\u4eba\u5f80\u80fd\u52a0\u5de5\u7684\u4ea7\u54c1\u8fde\u6d41\u91cfinf\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u4ea7\u54c1\u5f80T\u8fde\u6d41\u91cf\u4e3aci\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\u5373\u53ef\u3002\n\n\u4f46\u662f\u600e\u4e48\u5904\u7406\u5206\u6bb5\u51fd\u6570\u5462\u3002\u770b\u4e00\u4e0b\u5206\u6bb5\u51fd\u6570\u7684\u6bb5\u975e\u5e38\u5c11\uff0c\u90a3\u6211\u4eec\u53ef\u4ee5\u62c6\u8fb9\u3002\u628aS\u5f80\u4eba\u8fde\u7684\u8d39\u7528\u4e3a\u6124\u6012\u503c\u7684\u8fb9\u6309\u7167\u5206\u6bb5\u51fd\u6570\u8fdb\u884c\u62c6\u5206\uff0c\u62c6\u89e3\u6210si+1\u6761\u8fb9\uff0c\u524dsi\u6761\u8fb9\u7684\u6d41\u91cf\u5c31\u7b49\u4e8eti-t(i-1)\uff0c\u8d39\u7528\u5c31\u7b49\u4e8e\u8fd9\u4e00\u6bb5\u7684\u6124\u6012\u503cwi\uff0c\u7b2csi+1\u6761\u8fb9\u7684\u6d41\u91cf\u4e3ainf\uff0c\u8d39\u7528\u4e3aw(i+1)\u3002\u8fd9\u6837\u5b50\u62c6\u5b8c\u8fb9\u540e\uff0c\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u987a\u4fbf\u5206\u4eab\u4e00\u4e0b\u4e4b\u524d\u7684\u601d\u8def\uff1a\u628a\u4eba\u62c6\u70b9\uff0c\u6bcf\u4e2a\u4eba\u62c6\u6210si+1\u4e2a\u70b9\uff0c\u5f80\u6bcf\u4e2a\u70b9\u8fde\u62c6\u51fa\u6765\u7684\u8fb9\uff0c\u8fd9\u6837\u5b50\u4f1a\u5bfc\u81f4\u8fb9\u6570\u66b4\u589e\u3002\u4f46\u662f\u5728BZOJ\u4e0a\u4f9d\u65e7\u80fd\u8fc7\uff0c\u6d1b\u8c37\u4e0a\u4f1a\u88ab\u5361\u6389\u3002\u6240\u4ee5\u6700\u540e\u6211\u53d1\u73b0\u6211\u600e\u4e48\u8fd9\u4e48\u8822\u5462\uff0c\u76f4\u63a5\u62c6\u8fb9\u4e0d\u5c31\u597d\u4e86\u4e48\u3002\u3002\u3002\n\n\u9644\u8dd1\u7684\u6bd4\u5927\u9646\u8bb0\u8005\u8fd8\u6162\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nint head[1010],nxt[500010],point[500010],remain[500010],sum;\nlong long w[500010];\nint lastedge[1010],exist[1010];\nlong long dis[1010];\nint wi[1010],si[255][255];\nint ti[10],ci[10];\nint n,m,x;\nconst int inf=1e9+7;\nconst long long longinf=(1ll<<50);\nqueue<int>q;\n#define min(a,b) (a<b?a:b)\nvoid read(int &ans,char ch=getchar())\n{\n    ans=0;\n    for(;ch<'0'||ch>'9';ch=getchar());\n    for(;ch>='0'&&ch<='9';ans=ans*10+ch-48,ch=getchar());\n} \nvoid add(int x,int y,int flow,int cost)\n{\n    ++sum;nxt[sum]=head[x];head[x]=sum;point[sum]=y;remain[sum]=flow;w[sum]=cost;\n    ++sum;nxt[sum]=head[y];head[y]=sum;point[sum]=x;remain[sum]=0;w[sum]=-cost;\n}\nint addflow(int s,int t)\n{\n    int now=t,f=inf;\n    while(now!=s)\n    {\n        f=min(f,remain[lastedge[now]]);\n        now=point[lastedge[now]^1];\n    }\n    now=t;\n    while(now!=s)\n    {\n        remain[lastedge[now]]-=f;\n        remain[lastedge[now]^1]+=f;\n        now=point[lastedge[now]^1];\n    }\n    return f;\n}\nbool spfa(int s,int t,int &maxflow,long long &mincost)\n{\n    memset(dis,127,sizeof(dis));\n    dis[s]=0;\n    q.push(s);\n    while(!q.empty())\n    {\n        int now=q.front();q.pop();\n        exist[now]=0;\n        for(int tmp=head[now];tmp!=-1;tmp=nxt[tmp])\n        {\n            int u=point[tmp];\n            long long v=w[tmp];\n            if(dis[u]>dis[now]+v&&remain[tmp])\n            {\n                dis[u]=dis[now]+v;\n                lastedge[u]=tmp;\n                if(!exist[u])\n                q.push(u),exist[u]=1;\n            }\n        } \n    }\n    if(dis[t]>longinf) return false;\n    int flow=addflow(s,t);\n    maxflow+=flow;\n    mincost+=flow*dis[t];\n    return true;\n} \nvoid mfmc(int s,int t,int &maxflow,long long &mincost)\n{\n    mincost=maxflow=0;\n    while(spfa(s,t,maxflow,mincost));\n}\nint main()\n{\n    sum=-1;\n    memset(nxt,-1,sizeof(nxt));\n    memset(head,-1,sizeof(head));\n    read(n),read(m);\n    for(int i=1;i<=m;i++)\n    {\n        read(x);\n        add(i+n,m+n+1,x,0);\n    }\n    for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++)\n    read(si[i][j]);\n    for(int i=1;i<=n;i++)\n    {\n        read(x);\n        for(int j=1;j<=x;j++)\n        read(ti[j]);\n        for(int j=1;j<=x+1;j++)\n        read(ci[j]);\n        for(int j=1;j<=x;j++)\n        add(0,i,ti[j]-ti[j-1],ci[j]);\n        add(0,i,inf,ci[x+1]);\n        for(int j=1;j<=m;j++)\n        if(si[i][j])\n        add(i,j+n,inf,0);\n    }\n    int mflow;\n    long long mcost;\n    mfmc(0,m+n+1,mflow,mcost);\n    printf(\"%lld\",mcost);\n} \n\u6700\u540e\uff0c\u518d\u5410\u69fd\u4e00\u904d\u65f6\u9650\uff0c\u4e0d\u653e1s\u771f\u7684\u597d\u4e48\u3002\u3002\n```",
        "postTime": 1493102261,
        "uid": 17828,
        "name": "revenger",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2488 \u3010[SDOI2011]\u5de5\u4f5c\u5b89\u6392\u3011"
    },
    {
        "content": "> 11.29 \u4fee\u6539\u6392\u7248\n\n\u88f8\u7684\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u53ea\u8981\u8bfb\u61c2\u9898\u610f\u5c31\u884c\u4e86\n\n\u5efa\u8d85\u6e90\u70b9\u548c\u8d85\u6c47\u70b9\uff0c\u8d85\u6e90\u70b9\u8fde\u7269\u54c1\uff0c\u8fb9\u5bb9\u91cf\u4e3a$C_i$\n\n\u8d85\u6c47\u70b9\u8fde\u4eba\uff0c\u6bcf\u4e2a\u4eba\u8fde$S_{i+1}$\u6761\u8fb9\n\n\u6bcf\u6761\u8fb9\u5bb9\u91cf\u4e3a$T_{i,j}-T_{i,j-1}$\uff0c\u8d39\u7528\u4e3a$W_{i,j}$\n\n\u7136\u540e\u6839\u636e\u5df2\u77e5\u4fe1\u606f\uff0c\u628a\u7269\u54c1\u548c\u4eba\u4e4b\u95f4\u5efa\u8fb9\n\n\u5bb9\u91cf\u4e3a$inf$\uff0c\u8d39\u7528\u4e3a$0$\n\n\u7136\u540e\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u884c\u4e86\n\n\u7b54\u6848\u4f3c\u4e4e\u8981\u5f00```long long```\n\n\u4ee3\u7801\uff1a\n```cpp\n# include<iostream>\n# include<cstring>\n# include<cstdio>\n# include<queue>\nusing namespace std;\nstruct p{\n    int x,y,dis,cn;\n}c[200001];\nint n,m,num,t;\nlong long tot1;\nint h[2001],pre[2001],T[11];\nlong long d[2001];\nbool use[2001];\nbool a[301][301];\nvoid add(int x,int y,int dis,int cn)\n{\n    c[num].x=h[x];\n    c[num].y=y;\n    c[num].cn=cn;\n    c[num].dis=dis;\n    h[x]=num++;\n}\nvoid EK()\n{\n    while(1)\n    {\n        memset(use,0,sizeof(use));\n        memset(d,127,sizeof(d));\n        d[0]=0;\n        queue<int> qu;\n        qu.push(0);\n        while(!qu.empty())\n        {\n            int tt=qu.front();\n            qu.pop();\n            use[tt]=0;\n            for(int i=h[tt];i;i=c[i].x)\n              if(d[c[i].y]>d[tt]+c[i].cn&&c[i].dis)\n              {\n                  d[c[i].y]=d[tt]+c[i].cn;\n                  pre[c[i].y]=i;\n                  if(!use[c[i].y])\n                  {\n                      use[c[i].y]=1;\n                      qu.push(c[i].y);\n                }\n              }\n        }\n        if(d[t]>1e8) return;\n        int hh=t,sum=1e9;\n        while(pre[hh])\n        {\n            int l=pre[hh];\n            sum=min(sum,c[l].dis);\n            hh=c[l^1].y;\n        }\n        hh=t;\n        while(pre[hh])\n        {\n            int l=pre[hh];\n            c[l].dis-=sum;\n            c[l^1].dis+=sum;\n            tot1+=sum*c[l].cn;\n            hh=c[l^1].y;\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    t=n+m+1;\n    for(int i=1;i<=n;i++)\n      {\n          int x;\n          scanf(\"%d\",&x);\n          add(i,0,0,0);\n          add(0,i,x,0);\n      }\n    for(int i=1;i<=m;i++)\n      for(int j=1;j<=n;j++)\n        {\n            scanf(\"%d\",&a[i][j]);\n            if(!a[i][j]) continue;\n            add(i+n,j,0,0);\n            add(j,i+n,1e9,0);\n        }\n    for(int i=1;i<=m;i++)\n      {\n          int s;\n          scanf(\"%d\",&s);\n          memset(T,0,sizeof(T));\n          for(int j=1;j<=s;j++)\n            scanf(\"%d\",&T[j]);\n          T[s+1]=1e9;\n          for(int j=1;j<=s+1;j++)\n            {\n                int x;\n                scanf(\"%d\",&x);\n                add(t,i+n,0,-x);\n                add(i+n,t,T[j]-T[j-1],x);\n          }\n      }\n    EK();\n    printf(\"%lld\",tot1);\n    return 0;\n}\n```",
        "postTime": 1513941015,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2488 \u3010[SDOI2011]\u5de5\u4f5c\u5b89\u6392\u3011"
    },
    {
        "content": "\u6211\u4e3b\u8981\u8bf4\u660e\u6211\u7684\u65b9\u6cd5\u7684\u4e0d\u540c\u4e4b\u5904\uff0c\u8bfb\u8005\u53ef\u4ee5\u53c2\u8003\u5176\u4ed6\u9898\u89e3\u3002\n\n\u6b63\u5982\u524d\u4eba\u6240\u8bf4\uff0c\u5982\u679c\u629b\u5f00\u5206\u6bb5\u51fd\u6570\uff0c\u8fd9\u9053\u9898\u7684\u5efa\u56fe\u601d\u8def\u5e94\u8be5\u975e\u5e38\u6e05\u6670\uff0cS\u5f80\u4eba\u8fde\u8d39\u7528\u4e3a\u6124\u6012\u503c\u7684\u8fb9\uff0c\u4eba\u5f80\u80fd\u52a0\u5de5\u7684\u4ea7\u54c1\u8fde\u6d41\u91cfinf\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u4ea7\u54c1\u5f80T\u8fde\u6d41\u91cf\u4e3aci\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff0c\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\u5373\u53ef\u3002\n\n\u5206\u6bb5\u51fd\u6570\u7684\u5904\u7406\u53ef\u4ee5\u53c2\u7167P2053 [SCOI2007]\u4fee\u8f66\uff0c\u7136\u800c\u6709\u4e00\u70b9\u4e0d\u540c\uff0c\u90a3\u5c31\u662f\u4fee\u8f66\u90a3\u9053\u9898\u4fdd\u8bc1\u4fee\u5f97\u8d8a\u665a\uff0c\u8d39\u65f6\u8d8a\u591a\uff0c\u800c\u672c\u9898\u5e76\u6ca1\u6709\u4fdd\u8bc1w\u5355\u8c03\u9012\u589e\u3002\u56e0\u6b64\uff0c\u76f4\u63a5\u628aS\u5f80\u4eba\u8fde\u7684\u8d39\u7528\u4e3a\u6124\u6012\u503c\u7684\u8fb9\u6309\u7167\u5206\u6bb5\u51fd\u6570\u8fdb\u884c\u62c6\u5206\u53ef\u80fd\u5bfc\u81f4\u9519\u8bef\u7684\u7ed3\u679c\uff08\u6bd4\u5982\u8bf4\u67d0\u4e2a\u4eba\u8fd8\u6ca1\u505a\u7b2c\u4e00\u4ef6\u4ea7\u54c1\uff0c\u5c31\u5f00\u59cb\u505a\u7b2c\u4e8c\u4ef6\uff09\u3002\n\n\u5982\u4f55\u89e3\u51b3\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u52a8\u6001\u52a0\u8fb9\u7684\u65b9\u6cd5\u3002\u9996\u5148\u6dfb\u52a0\u5206\u6bb5\u51fd\u6570\u7684\u7b2c\u4e00\u9636\u6bb5\u7684\u8fb9\u548c\u5176\u5b83\u7684\u8fb9\u3002\u4e4b\u540e\u5728\u5897\u5e7f\u8fc7\u7a0b\u4e2d\uff0c\u6bcf\u5f53\u67d0\u4e00\u9636\u6bb5\u7684\u8fb9\u88ab\u586b\u6ee1\uff0c\u5c31\u52a0\u5165\u4e0b\u4e00\u9636\u6bb5\u7684\u8fb9\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u7ed3\u679c\u5408\u6cd5\u3002\u540c\u65f6\uff0c\u52a8\u6001\u52a0\u8fb9\u4e5f\u53ef\u4ee5\u52a0\u5feb\u901f\u5ea6\u3002\n\n[\u8bc4\u6d4b\u8bb0\u5f55](https://www.luogu.org/record/show?rid=6837112)\uff0c\u4ee5\u4e0b\u662f\u4ee3\u7801\uff0c\u6211\u628a\u6a21\u677f\u5c01\u88c5\u5728\u4e86\u7ed3\u6784\u4f53\u4e2d\uff0c\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\u4e0a\u9762\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u770b\u4e3b\u51fd\u6570\uff0c\u51fd\u6570\u540d\u5e94\u8be5\u8fd8\u7b97\u6e05\u695a\u3002\n```\n#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <cstring>\n#include <time.h>\n\n#pragma warning(disable:4996)\n#define INF 2000000005//2 * 10^9\n#define lowbit(a) ((a)&-(a))\ninline long long max(long long a, long long b)\n{\n    return a>b ? a : b;\n}\ninline long long min(long long a, long long b)\n{\n    return a<b ? a : b;\n}\n\nconst long long MAXN = 100000;\n\nstruct Graph {\n\n    struct element {\n        long long id;\n        long long d;\n        bool operator < (element &a)\n        {\n            return d < a.d;\n        }\n    };\n    struct heap {\n    private:\n        element e[1000000];\n        long long hsize;\n        void swap(element &a, element &b)\n        {\n            element t = a;\n            a = b;\n            b = t;\n        }\n    public:\n        void heapify(long long i)\n        {\n            long long m;\n            if (i * 2 <= hsize&&e[i * 2] < e[i])\n                m = i * 2;\n            else\n                m = i;\n            if (i * 2 + 1 <= hsize&&e[i * 2 + 1] < e[m])\n                m = i * 2 + 1;\n            if (m != i)\n            {\n                swap(e[i], e[m]);\n                heapify(m);\n            }\n        }\n        void fixup(long long i)\n        {\n            if (i > 1 && e[i] < e[i / 2])\n            {\n                swap(e[i], e[i / 2]);\n                fixup(i / 2);\n            }\n        }\n        void push(element i)\n        {\n            e[++hsize] = i;\n            fixup(hsize);\n        }\n        element pop()\n        {\n            element t = e[1];\n            e[1] = e[hsize--];\n            heapify(1);\n            return t;\n        }\n        void clear()\n        {\n            hsize = 0;\n        }\n        long long size()\n        {\n            return hsize;\n        }\n    };\n\n    struct node {\n        long long to;\n        long long cp;\n        long long w;\n        node *next;\n    };\n    long long c[1000000], bak[1000000], k;\n\n    void add(node *&head, long long to, long long C, long long w)\n    {\n        node *p = new(node);\n        p->to = to;\n        p->w = w;\n        p->cp = k;\n        bak[k] = C;\n        c[k++] = C;\n        p->next = head;\n        head = p;\n    }\n    node *edge[MAXN];\n    long long d[MAXN], fa[MAXN], S, T;\n    node *path[MAXN];\n    long long to;\n    node *eto;\n\n    bool relax(long long v, node *p)\n    {\n        if (d[p->to] > d[v] + p->w)\n        {\n            d[p->to] = d[v] + p->w;\n            fa[p->to] = v;\n            path[p->to] = p;\n            return true;\n        }\n        return false;\n    }\n\n    heap H;\n\n    bool spfa()\n    {\n        long long i;\n        H.clear();\n        memset(fa, 0, sizeof(fa));\n        memset(path, 0, sizeof(path));\n        for (i = 0; i < MAXN; i++)\n            d[i] = INF;\n        d[S] = 0;\n        H.push({ S,0 });\n\n        while (H.size())\n        {\n            element t = H.pop();\n            while (H.size() && d[t.id] != t.d)\n                t = H.pop();\n            long long v = t.id;\n            for (node *p = edge[v]; p; p = p->next)\n                if (c[p->cp] && relax(v, p))\n                    H.push({ p->to,d[p->to] });\n        }\n        return d[T] < INF;\n    }\n\n    long long flow(long long cur, long long lim)\n    {\n        if (cur == S)\n            return lim;\n        if (fa[cur] == S)\n        {\n            to = cur;\n            eto = path[cur];\n        }\n        long long f = flow(fa[cur], min(lim, c[path[cur]->cp]));\n        c[path[cur]->cp] -= f;\n        c[path[cur]->cp ^ 1] += f;\n        return f;\n    }\n\n    long long flow()\n    {\n        return flow(T, INF);\n    }\n\n    long long getans()\n    {\n        long long i, ans = 0;\n        for (i = 0; i < MAXN; i++)\n            for (node *p = edge[i]; p; p = p->next)\n                if (bak[p->cp] - c[p->cp] > 0)\n                    ans += (bak[p->cp] - c[p->cp])*p->w;\n        return ans;\n    }\n\n    long long MC, MF;\n    void addedge(long long u, long long v, long long C, long long w = 0)\n    {\n        add(edge[u], v, C, w);\n        add(edge[v], u, 0, -w);\n    }\n    long long MCMF(long long s, long long t, const char *ch = \"C\")\n    {\n        memcpy(c, bak, sizeof(c));\n        S = s;\n        T = t;\n        long long ans = 0;\n        while (spfa())\n            ans += flow();\n        MF = ans;\n        MC = getans();\n        if (ch == \"F\")\n            return MF;\n        return MC;\n    }\n};\n\nlong long N, M, S, T;\nlong long C[300], s[300], r[300][10], w[300][10];\nlong long cur[MAXN];\nbool A[300][300];\nGraph G;\n\nlong long id(long long i)\n{\n    return M + i;\n}\n\nint main()\n{\n    long long i, j;\n\n    scanf(\"%lld %lld\", &M, &N);\n    T = M + N + 1;\n\n    for (i = 1; i <= N; i++)\n        scanf(\"%lld\", &C[i]);\n\n    for (i = 1; i <= M; i++)\n        for (j = 1; j <= N; j++)\n            scanf(\"%d\", &A[i][j]);\n\n    for (i = 1; i <= M; i++)\n    {\n        scanf(\"%lld\", &s[i]);\n        for (j = 1; j <= s[i]; j++)\n            scanf(\"%lld\", &r[i][j]);\n        r[i][s[i] + 1] = INF;\n        for (j = 1; j <= s[i] + 1; j++)\n            scanf(\"%lld\", &w[i][j]);\n        cur[i] = 1;\n    }\n\n    G.S = S;\n    G.T = T;\n\n    for (i = 1; i <= M; i++)\n        G.addedge(S, i, r[i][1], w[i][1]);\n    for (i = 1; i <= N; i++)\n        G.addedge(id(i), T, C[i], 0);\n    for (i = 1; i <= M; i++)\n        for (j = 1; j <= N; j++)\n            if (A[i][j])\n                G.addedge(i, id(j), INF, 0);\n\n    long long ans = 0;\n    while (G.spfa())\n    {\n        ans += G.flow();\n        if (!G.c[G.eto->cp])\n        {\n            cur[G.to]++;\n            G.addedge(S, G.to, r[G.to][cur[G.to]] - r[G.to][cur[G.to] - 1]\n                , w[G.to][cur[G.to]]);\n        }\n    }\n\n    printf(\"%lld\", G.getans());\n\n//\tsystem(\"pause\");\n    return 0;\n}\n```",
        "postTime": 1523891588,
        "uid": 64366,
        "name": "ddwqwq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2488 \u3010[SDOI2011]\u5de5\u4f5c\u5b89\u6392\u3011"
    },
    {
        "content": "# P2488 [SDOI2011]\u5de5\u4f5c\u5b89\u6392\n\n[P2488 [SDOI2011]\u5de5\u4f5c\u5b89\u6392](https://www.luogu.com.cn/problem/P2488)\n\n## \u5206\u6790\n\n\u8fd9\u9053\u9898\u770b\u8d77\u6765\u53ef\u4ee5\u76f4\u63a5\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u628a\u70b9\u5206\u6210 $n$ \u4e2a\u4ee3\u8868\u4ea7\u54c1\u7684\u70b9\u548c $m$ \u4e2a\u4ee3\u8868\u5458\u5de5\u7684\u70b9\uff0c\u628a\u5458\u5de5\u53ef\u4ee5\u505a\u7684\u8d27\u7269\u4e4b\u95f4\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a $1$\uff0c\u8d39\u7528\u4e3a $0$\uff0c\u628a\u5458\u5de5\u548c\u6c47\u70b9\u8fde\u8d77\u6765\uff0c\u5bb9\u91cf\u4e3a $inf$\uff0c\u8d39\u7528\u4e3a $W_i$\uff0c\u628a\u6e90\u70b9\u548c\u4ea7\u54c1\u8fde\u8d77\u6765\u540e\u8dd1\u4e00\u904d\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4f46\u662f\u5b9a\u775b\u4e00\u770b\uff0c\u5458\u5de5\u7684\u5355\u4f4d\u4ea7\u54c1\u6124\u6012\u503c\u5c45\u7136\u4e0d\u662f\u5b9a\u503c\uff0c\u6124\u6012\u503c\u548c\u4ea7\u54c1\u6570\u4e3a\u4e00\u4e2a\u5206\u6bb5\u51fd\u6570\uff0c\u8fd9\u5c31\u4e0d\u80fd\u7528\u4e0a\u9762\u7684\u65b9\u6cd5\u505a\u4e86\u3002\u8fd9\u65f6\u6211\u4eec\u60f3\u5230\u4e86\u8981\u8ba9\u4e00\u6761\u8fb9\u7684\u5355\u4f4d\u8d39\u7528\u4e5f\u968f\u6d41\u91cf\u53d8\u5316\uff0c\u8fd9\u5c31\u8ba9\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\u201c\u62c6\u8fb9\u201d\u3002\u5c06\u5458\u5de5 $i$ \u548c\u6c47\u70b9\u8fde $S_i+1$ \u6761\u8fb9\uff1a\u7b2c\u4e00\u6761\u8fb9\u7684\u5bb9\u91cf\u4e3a $T_{i,1}$\uff0c\u8d39\u7528\u4e3a $W_{i,1}$\uff0c\u8868\u793a\u6d41\u91cf\u4e3a $1 \\sim T_{i,1}$ \u7684\u65f6\u5019\u5355\u4f4d\u6124\u6012\u503c\u4e3a $W_{i,1}$\uff1b\u7b2c\u4e8c\u6761\u8fb9\u7684\u5bb9\u91cf\u4e3a $T_{i,2}-T_{i,1}$\uff0c\u8d39\u7528\u4e3a $W_{i,2}$\uff0c\u7531\u4e8e $W_{i,1}<W_{i,2}$\uff0c\u6240\u4ee5\u6d41\u91cf\u4f1a\u5148\u6d41\u6ee1\u7b2c\u4e00\u6761\u8fb9\u518d\u6d41\u6ee1\u7b2c\u4e8c\u6761\u8fb9\uff0c\u6240\u4ee5\u8868\u793a\u6d41\u91cf\u4e3a $T_{i,1}+1 \\sim T_{i,2}$ \u7684\u65f6\u5019\u5355\u4f4d\u6124\u6012\u503c\u4e3a $W_{i,2}$\uff1b\u7b2c $j$ \u6761\u8fb9\u7684\u5bb9\u91cf\u4e3a $T_{i,j}-T_{i,j-1}$\uff0c\u8d39\u7528\u4e3a $W_{i,j}$\uff0c\u8868\u793a\u6d41\u91cf\u4e3a $T_{i,j-1}+1 \\sim T_{i,j}$ \u7684\u65f6\u5019\u5355\u4f4d\u6124\u6012\u503c\u4e3a $W_{i,j}$\u3002\u8fd9\u91cc\u6211\u4eec\u4ee4 $T_{i,0}=0$\uff0c$T_{i,S_i+1}=maxn$ \u5c31\u53ef\u4ee5\u4e86\u3002\u63a5\u4e0b\u6765\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\n## code\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\nconst int N=10001,M=1000001;\nint n,m,p=1,s1,s2,t[N],t0[N],c[N];\nll f[N],b[N],q,v;\nbool h[N];\nstruct str\n{\n    int m,q;\n    ll r,w;\n}a[M];\nvoid road(int x,int y,ll r,ll w)\n{\n    a[++p].m=y;\n    a[p].q=t[x];\n    t[x]=p;\n    a[p].r=r;\n    a[p].w=w;\n}\nbool SPFA()\n{\n    queue<int> Q;\n    Q.push(s1);\n    for(int i=1;i<=s2;++i)\n    {\n        f[i]=1e18;\n        h[i]=false;\n    }\n    f[s1]=0;\n    h[s1]=true;\n    while(!Q.empty())\n    {\n        int k=Q.front();\n        Q.pop();\n        if(h[k]==false) continue;\n        h[k]=false;\n        for(int i=t[k];i!=0;i=a[i].q)\n        {\n            if(a[i].r>0&&f[k]+a[i].w<f[a[i].m])\n            {\n                f[a[i].m]=f[k]+a[i].w;\n                Q.push(a[i].m);\n                h[a[i].m]=true;\n            }\n        }\n    }\n    if(f[s2]!=1e18) return true;\n    return false;\n}\nll dfs(int x,ll r)\n{\n    if(x==s2) return r;\n    ll s=0;\n    for(int i=t0[x];i!=0;i=a[i].q)\n    {\n        t0[x]=i;\n        if(h[a[i].m]==false&&a[i].r>0&&f[a[i].m]==f[x]+a[i].w)\n        {\n            h[a[i].m]=true;\n            ll z=dfs(a[i].m,min(r,a[i].r));\n            h[a[i].m]=false;\n            if(z!=0)\n            {\n                a[i].r-=z;\n                a[i^1].r+=z;\n                r-=z;\n                s+=z;\n                v+=z*a[i].w;\n            }\n            else f[a[i].m]=0;\n            if(r==0) return s; \n        }\n    }\n    return s;\n}\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    for(int i=1;i<=n;++i)\n    {\n        scanf(\"%lld\",&b[i]);\n        q+=b[i];\n    }\n    s1=n+m+1;\n    s2=n+m+2;\n    for(int i=1;i<=n;++i)\n    {\n        road(s1,i,b[i],0);\n        road(i,s1,0,0);\n    }\n    for(int i=1;i<=m;++i)\n    {\n        for(int j=1;j<=n;++j)\n        {\n            int z;\n            scanf(\"%d\",&z);\n            if(z==0) continue;\n            road(j,n+i,1e18,0);\n            road(n+i,j,0,0);\n        }\n    }\n    for(int i=1;i<=m;++i)\n    {\n        int s;\n        scanf(\"%d\",&s);\n        c[0]=0;\n        c[s+1]=q;\n        for(int j=1;j<=s;++j)\n        {\n            scanf(\"%d\",&c[j]);\n        }\n        for(int j=1;j<=s+1;++j)\n        {\n            ll w;\n            scanf(\"%lld\",&w);\n            road(n+i,s2,c[j]-c[j-1],w);\n            road(s2,n+i,0,-w);\n        }\n    }\n    while(SPFA())\n    {\n        for(int i=1;i<=s2;++i) \n        {\n            t0[i]=t[i];\n            h[i]=false;\n        }\n        dfs(s1,1e18);\n    }\n    printf(\"%lld\",v);\n    return 0;\n}\n```",
        "postTime": 1650608193,
        "uid": 291248,
        "name": "\u8d75\u60a6\u5c91",
        "ccfLevel": 7,
        "title": "P2488 [SDOI2011]\u5de5\u4f5c\u5b89\u6392"
    },
    {
        "content": "# \u9898\u76ee\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[\u70b9\u8fd9\u91cc](https://www.luogu.com.cn/problem/P2488)\u770b\u9898\u76ee\u3002  \n# \u5206\u6790\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e0d\u96be\u770b\u51fa\u662f\u8d39\u7528\u6d41\u7684\u9898\u76ee\u3002\u8003\u8651\u5982\u679c\u6ca1\u6709\u5206\u6bb5\u51fd\u6570\u7684\u9650\u5236\uff0c\u8fd9\u5c31\u662f\u4e00\u4e2a\u7f51\u7edc\u6d41\u7684\u677f\u5b50\u9898\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u6709\u4e86\u8fd9\u4e2a\u9650\u5236\uff0c\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u60f3\u5230\u62c6\u70b9\uff0c\u5c06\u539f\u6765\u7684\u4e00\u4e2a\u4eba\u62c6\u6210$S+1$\u4e2a\u70b9\uff0c\u5206\u522b\u5bf9\u5e94\u4e86\u4e0d\u540c\u6bb5\u7684\u51fd\u6570\uff1b\u7136\u540e\u7528$(\\infty, 0)$\uff08\u524d\u4e00\u4e2a\u4e3a\u5bb9\u91cf\uff0c\u540e\u4e00\u4e2a\u4e3a\u8d39\u7528\uff0c\u4e0b\u540c\uff09\u7684\u8fb9\u5c06\u5b83\u4eec\u4e32\u8d77\u6765\uff0c\u5e76\u5404\u81ea\u4ee5$(T_j-T_{j-1},W_j)$\u8fde\u5411\u7ec8\u70b9\u3002\u7531\u4e8e\u6709$W_j<W_{j+1}$\u8fd9\u4e2a\u9650\u5236\uff0c\u6240\u4ee5\u5728\u8dd1\u7f51\u7edc\u6d41\u7684\u65f6\u5019\uff0c\u4e00\u5b9a\u4f1a\u6309\u7167\u8d39\u7528\u6b63\u5e8f\u6d41\u8fc7\u8fd9\u4e9b\u8fb9\uff0c\u8fd9\u662f\u7b26\u5408\u9898\u610f\u7684\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e0d\u8fc7\uff0c\u8003\u8651\u5230\u6d41\u8fc7$(\\infty,0)$\u7684\u8fb9\u76f8\u5f53\u4e8e\u5565\u4e5f\u6ca1\u5e72\uff0c\u6211\u4eec\u4fbf\u53ef\u4ee5\u60f3\u5230\uff0c\u5c06$S+1$\u4e2a\u70b9\u5408\u5e76\u4e3a\u4e00\u4e2a\u70b9\uff0c\u4e5f\u5c31\u76f8\u5f53\u4e8e\u5c06\u8fb9\u62c6\u6210\u4e86$S+1$\u6761\uff0c\u8fd9\u6837\u5c31\u51cf\u5c0f\u4e86\u56fe\u7684\u89c4\u6a21\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u6700\u540e\u63d0\u9192\u4e00\u4e0b\uff0c\u4e00\u5b9a\u8981\u5f00$long\\ long$\uff0c\u4e0d\u7136\u600e\u4e48\u7206\u96f6\u7684\u90fd\u4e0d\u77e5\u9053\u3002  \n# \u4ee3\u7801\n```cpp\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long LL;\n\n#define int LL\n\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst int MAXN = 255, MAXM = 255, MAXS = 6, MAXSIZ = 100005, MAXE = 200005;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar();int f = 1;\n\twhile( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n\twhile( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MIN( const _T a, const _T b )\n{\n\treturn a < b ? a : b;\n}\n\nstruct edge\n{\n\tint to, nxt, c, w;\n}Graph[MAXE];\n\nqueue<int> q;\n\nint C[MAXN], Ss[MAXM], beg[MAXM], Ts[MAXM][MAXS], W[MAXM][MAXS];\nint head[MAXSIZ], dist[MAXSIZ], pre[MAXSIZ];\nint N, M, cnt = 1, siz;\nbool inQ[MAXSIZ], G[MAXM][MAXN];\n\nvoid addEdge( const int from, const int to, const int C, const int W )\n{\n\tGraph[++ cnt].to = to, Graph[cnt].nxt = head[from], Graph[cnt].c = C, Graph[cnt].w = W;\n\thead[from] = cnt;\n}\n\nvoid addE( const int from, const int to, const int C, const int W ) \n{ addEdge( from, to, C, W ), addEdge( to, from, 0, -W ); }\n\nbool SPFA( const int S, const int T, int &cost )\n{\n\twhile( ! q.empty() ) q.pop();\n\tfor( int i = 1 ; i <= siz ; i ++ ) dist[i] = INF, inQ[i] = false;\n\tinQ[S] = true, dist[S] = 0, q.push( S );\n\tint u, v, w;\n\twhile( ! q.empty() )\n\t{\n\t\tinQ[u = q.front()] = false, q.pop();\n\t\tfor( int i = head[u] ; i ; i = Graph[i].nxt )\n\t\t\tif( Graph[i].c && dist[v = Graph[i].to] > dist[u] + ( w = Graph[i].w ) )\n\t\t\t{\n\t\t\t\tdist[v] = dist[u] + w, pre[v] = i;\n\t\t\t\tif( ! inQ[v] ) inQ[v] = true, q.push( v );\n\t\t\t}\n\t}\n\tif( dist[T] == INF ) return false;\n\tLL mn = INF;\n\tfor( int i = T ; i ^ S ; i = Graph[pre[i] ^ 1].to ) mn = MIN( mn, Graph[pre[i]].c );\n\tfor( int i = T ; i ^ S ; i = Graph[pre[i] ^ 1].to ) Graph[pre[i]].c -= mn, Graph[pre[i] ^ 1].c += mn;\n\tcost += mn * dist[T];\n\treturn true;\n}\n\nint EK( const int S, const int T )\n{\n\tLL cost = 0;\n\twhile( SPFA( S, T, cost ) );\n\treturn cost;\n}\n\nsigned main()\n{\n//\tfreopen( \"1.in\", \"r\", stdin );\n\tread( M ), read( N );\n\tfor( int i = 1 ; i <= N ; i ++ ) read( C[i] );\n\tfor( int i = 1 ; i <= M ; i ++ )\n\t\tfor( int j = 1 ; j <= N ; j ++ )\n\t\t\tread( G[i][j] );\n\tsiz = N + M + 2;\n\tfor( int i = 1 ; i <= M ; i ++ )\n\t{\n\t\tread( Ss[i] );\n\t\tfor( int j = 1 ; j <= Ss[i] ; j ++ ) read( Ts[i][j] );\n\t\tfor( int j = 0 ; j <= Ss[i] ; j ++ ) read( W[i][j] );\n\t}\n\tint S = N + M + 1, T = siz;\n\tfor( int i = 1 ; i <= N ; i ++ ) addE( S, i, C[i], 0 );\n\tfor( int i = 1 ; i <= M ; i ++ )\n\t\tfor( int j = 1 ; j <= N ; j ++ )\n\t\t\tif( G[i][j] )\n\t\t\t\taddE( j, N + i, INF, 0 );\n\tfor( int i = 1 ; i <= M ; i ++ )\n\t{\n\t\tfor( int j = 0 ; j < Ss[i] ; j ++ ) \n\t\t\taddE( N + i, T, Ts[i][j + 1] - Ts[i][j], W[i][j] );\n\t\taddE( N + i, T, INF, W[i][Ss[i]] );\n\t}\n\twrite( EK( S, T ) ), putchar( '\\n' );\n\treturn 0;\n}\n```",
        "postTime": 1579169516,
        "uid": 123809,
        "name": "crashed",
        "ccfLevel": 0,
        "title": "[SDOI2011]\u5de5\u4f5c\u5b89\u6392"
    },
    {
        "content": "# \u5e7f\u544a\n\n[\u849f\u84bb\u7684blog](http://www.cnblogs.com/dedicatus545/p/8745373.html)\n\n# \u6b63\u6587\n\n\u6570\u636e\u8303\u56f4n,m<=250\n\n\u5206\u914d\u4efb\u52a1\u95ee\u9898\n\n\u8fd9\u662f\u5178\u578b\u7684\u201c\u770b\u5230\u6570\u636e\u8303\u56f4\u5c31\u77e5\u9053\u7b97\u6cd5\u201d\u7c7b\u578b\n\n\u800c\u4e14\u6211\u4eec\u53d1\u73b0\u6211\u4eec\u8981\u4fdd\u8bc1\u4e00\u5b9a\u4ea7\u51fa\u7684\u60c5\u51b5\u4e0b\u6700\u5c0f\u5316\u82b1\u8d39\n\n\u8fd9\u53e5\u8bdd\u7b49\u4ef7\u4e8e\u4fdd\u8bc1\u4e00\u5b9a\u6d41\u91cf\u7684\u60c5\u51b5\u4e0b\u6700\u5c0f\u5316\u8d39\u7528\n\n\u6240\u4ee5\u5148\u786e\u5b9a\u7b97\u6cd5\uff1a\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\n\n\u518d\u89c2\u5bdf\u4e00\u4e0b\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u9053\u9898\u7684\u8d39\u7528\u548c\u4eba\u552f\u4e00\u76f8\u5173\uff0c\u800c\u4e14\u4eba\u548c\u7269\u54c1\u4e4b\u95f4\u7684\u5173\u7cfb\u662f\u72ec\u7acb\u7684\n\n\u56e0\u6b64\u6211\u4eec\u5efa\u7acb\u4e00\u4e2a\u7f51\u7edc\u6d41\u56fe\uff0c\u5176\u4e2d\u5305\u542bS\uff0cT\uff0c\u4eba\u70b9\u548c\u7269\u54c1\u70b9\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u7269\u54c1i\uff0c\u6211\u4eec\u8fde\u8fb9(i,T)\uff0c\u8d39\u75280\uff0c\u6d41\u91cf\u4e3a$C_i$\n\n\u5bf9\u4e8e\u4e00\u4e2a\u4ebai\u53ef\u4ee5\u64cd\u4f5c\u7269\u54c1j\uff0c\u6211\u4eec\u8fde\u8fb9(i,j)\uff0c\u8d39\u75280\uff0c\u6d41\u91cfinf\n\n\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\u5904\u7406\u4eba\u7684\u8d39\u7528\u4e86\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u9053\u9898\u7684\u8d39\u7528\u662f\u5206\u6bb5\u5904\u7406\u7684\n\n\u770b\u5230\u5206\u6bb5\uff0c\u7b2c\u4e00\u60f3\u6cd5\u5c31\u662f\u628a\u4eba\u62c6\u70b9\uff0c\u4f46\u662f\u8fd9\u6837\u52bf\u5fc5\u4f1a\u5927\u5927\u589e\u52a0\u5197\u4f59\u8fb9\u6570\uff0c\u62d6\u6162\u7a0b\u5e8f\u901f\u5ea6\n\n\u56e0\u6b64\u6211\u4eec\u8003\u8651\u4e0d\u62c6\u70b9\u6765\u505a\n\n\u89c2\u5bdf\u53d1\u73b0\uff0c\u8fd9\u9053\u9898\u5206\u6bb5\u4e2d\u4fdd\u8bc1$W_{i,j}$\u9012\u589e\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u5982\u679c\u6709\u4e00\u5768\u91cd\u8fb9\uff0c\u6211\u4eec\u7684\u7b97\u6cd5\u4f1a\u5148\u8dd1\u4ee3\u8868\u9760\u524d\u7684\u5206\u6bb5\u7684\u8fb9\n\n\u8fd9\u5f15\u5bfc\u6211\u4eec\u5f80\u91cd\u8fb9\u65b9\u5411\u4e0a\u60f3\n\n\u5bf9\u4e8e\u4e00\u4e2a\u70b9i\uff0c\u6211\u4eec\u628a\u6bcf\u4e2a\u957f\u5ea6\u4e3al\uff0c\u6bb5\u4e2d\u8d39\u7528\u4e3acost\u7684\u5206\u6bb5\uff0c\u8fde\u4e00\u6761\u8fb9(S,i)\uff0c\u8d39\u7528cost\uff0c\u6d41\u91cfl\n\n\u56e0\u4e3a\u6bcf\u4e2a\u70b9\u6700\u591a\u516d\u6bb5\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7b97\u6cd5\u7684\u8fb9\u6570\u5f88\u5c11\uff0c\u8dd1\u5f97\u8fc7\n\n\u6700\u540e\u53ea\u8981\u4e00\u6b65(S,T)\u8d39\u7528\u6d41\uff0c\u8f93\u51fa\u603b\u8d39\u7528\u5c31\u53ef\u4ee5\u4e86\n\n# Code:\n\n\u8fd9\u9898\u5361\u5e38\u6570\u554a......\n\n\u800c\u4e14\u6211\u7684zkw\u8d39\u7528\u6d41\u88ab\u5361\u4e86\u8fc7\u4e0d\u4e86\uff0c\u6d1b\u8c37\u8bc4\u6d4b\u673a\u53c8\u4e0d\u7a33\u5b9a\uff0c\u4e00\u4f1aTLE\u4e00\u4f1aRE\u7684......\n\n```cpp\n// luogu-judger-enable-o2\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define inf 1e9\n#define ll long long\nusing namespace std;\ninline ll read(){\n    ll re=0,flag=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){\n        if(ch=='-') flag=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n    return re*flag;\n}\nll first[5010],dis[5010],vis[5010],n,m,cnt=-1,ans;\nstruct edge{\n    ll to,next,w,cap;\n}a[600010];\ninline void add(ll u,ll v,ll w,ll cap){\n    a[++cnt]=(edge){v,first[u],w,cap};first[u]=cnt;\n    a[++cnt]=(edge){u,first[v],-w,0};first[v]=cnt;\n}\nll q[1000010];\nll limit[5010],pre[5010];\nbool Spfa(int s,int t){\n    ll head=0,tail=1,i,u,v,w;\n    memset(dis,-1,sizeof(dis));memset(vis,0,sizeof(vis));\n    memset(limit,0,sizeof(limit));memset(pre,-1,sizeof(pre));\n    q[0]=s;dis[s]=0;vis[s]=1;limit[s]=inf;\n    while(head<tail){\n        u=q[head++];vis[u]=0;\n        for(i=first[u];~i;i=a[i].next){\n            v=a[i].to;w=a[i].w;\n            if(a[i].cap&&((dis[v]==-1)||(dis[v]>dis[u]+w))){\n                dis[v]=dis[u]+w;pre[v]=i;\n                limit[v]=_min(limit[u],a[i].cap);\n                if(!vis[v]) q[tail++]=v,vis[v]=1;\n            }\n        }\n    }\n    return ~dis[t];\n}\nint mcmf(int s,int t){\n    int re=0,u;\n    while(Spfa(s,t)){\n        re+=limit[t];\n        for(u=t;~pre[u];u=a[pre[u]^1].to){\n            a[pre[u]].cap-=limit[t];a[pre[u]^1].cap+=limit[t];\n            ans+=limit[t]*a[pre[u]].w;\n        }\n    }\n    return re;\n}\nint main(){\n    memset(first,-1,sizeof(first));\n    m=read();n=read();ll i,j,t1,t2[10],t3;\n    for(i=1;i<=n;i++) t1=read(),add(0,i,0,t1);\n    for(i=1;i<=m;i++){\n        for(j=1;j<=n;j++){\n            t1=read();\n            if(t1) add(j,n+i,0,inf);\n        }\n    }\n    for(i=1;i<=m;i++){\n        t1=read();t2[0]=0;\n        for(j=1;j<=t1;j++) t2[j]=read();\n        for(j=0;j<t1;j++){//\u5206\u6bb5\u5efa\u91cd\u8fb9\n            t3=read();\n            add(n+i,n+m+1,t3,t2[j+1]-t2[j]);\n        }\n        t3=read();add(n+i,n+m+1,t3,inf);\n    }\n    mcmf(0,n+m+1);\n    cout<<ans<<endl;\n}\n```",
        "postTime": 1523173561,
        "uid": 27753,
        "name": "Orion545",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2488 \u3010[SDOI2011]\u5de5\u4f5c\u5b89\u6392\u3011"
    },
    {
        "content": "\u88f8\u7684\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\n\n\u601d\u8def\u662f\u5f04\u4e00\u4e2a\u539f\u70b9\uff0c\u5f04\u4e00\u4e2a\u4f1a\u70b9\uff0c\u5c06\u539f\u70b9\u8fde\u4e0a\u7269\u54c1\u5bb9\u91cf\u4e3ac[i]\uff0c\n\n\u8d39\u7528\u4e3a\u96f6\uff0c\u5c06\u7269\u54c1\u548c\u4eba\u6309a\u6570\u7ec4\u7684\u5173\u7cfb\u8fde\u8d77\u6765\uff0c\u5bb9\u91cf\u4e3aINF,\u82b1\u8d39\u4e3a\u96f6\uff0c\u7136\u540e\u5c06\u4eba\u548c\u4f1a\u70b9\u8fde\u8d77\u6765\u5bb9\u91cf\u4e3a\u4ed6\n\n\u505a\u51e0\u4ef6\u7269\u54c1\uff0c\u4e5f\u5c31\u662fss[j]-ss[j-1],\u82b1\u8d39\u4e3a\u4ed6\u505a\u8fd9\u51e0\u4ef6\u7684\u6124\u6012\u503c,\u518d\u8dd1\u6700\u5927\u6d41\u6700\u5c0f\u8d39\u7528\u7b97\u6cd5\u5c31\u884c\u4e86;\n\n    \n    \n            \n        \n\n        \n        \n   \n  \n         \n    \n    \n\n        \n        \n   \n  \n    \n  \n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring> \n#include<queue>\n#define LL long long\nusing namespace std;\nconst int M=199999;\nconst int INF=2139062143;\nint n,m,s,t;int dis[M],c[M],a[999][999],ss[M];\nint nex[M],head[M],cos[M],to[M],tot,pre[M],cap[M],vis[M],flo[M],id[M];\nint add(int x,int y,int z,int w){\n    cos[tot]=z;\n    cap[tot]=w;\n    nex[++tot]=head[x];\n    to[tot]=y;\n    head[x]=tot;\n     cos[tot]=-z;\n    cap[tot]=0;\n    nex[++tot]=head[y];\n    to[tot]=x;\n    head[y]=tot;\n}\nint spfa(int s,int t){\n    queue <int> q;\n    memset(dis,127,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    memset(pre,-1,sizeof(pre));\n    dis[s]=0;\n    vis[s]=1;\n    q.push(s);\n    flo[s]=INF;\n    while(!q.empty()){\n        int x=q.front();\n        vis[x]=0;\n        q.pop();\n        for(int i=head[x];i;i=nex[i])\n        {\n            int tmp=to[i];\n            if(dis[tmp]>dis[x]+cos[i-1]&&cap[i-1]){\n                dis[tmp]=dis[x]+cos[i-1];\n                pre[tmp]=x;\n                flo[tmp]=min(flo[x],cap[i-1]);\n                id[tmp]=i-1;\n                if(!vis[tmp]){\n                q.push(tmp);\n                vis[tmp]=1;\n                }\n            }\n        }\n    }\n    if(dis[t]>=INF)return 0;\n    return 1; \n}\nstruct st{\n    LL cost;\n    LL flow;\n}; \nst  maxflow(int s,int t){\n       st a;\n       a.flow=0,a.cost=0;\n    while(spfa(s,t)){\n        int k=t;\n           while(k!=s){\n            cap[id[k]]-=flo[t];\n            cap[id[k]^1]+=flo[t];\n            k=pre[k];\n        }\n           //a.flow+=flo[t];\n           a.cost+=flo[t]*dis[t];\n    }\n    return a;\n}\nint main(){\n    scanf(\"%d%d\",&m,&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&c[i]);\n        add(0,i,0,c[i]);\n    }// \u5c06\u539f\u70b9\u8fde\u4e0a\u7269\u54c1\u5bb9\u91cf\u4e3ac[i]\uff0c\u8d39\u7528\u4e3a\u96f6\n    for(int i=1;i<=m;i++)\n    for(int j=1;j<=n;j++){\n        scanf(\"%d\",&a[i][j]);\n        if(a[i][j]){\n            add(j,i+n,0,INF);//\u5c06\u7269\u54c1\u548c\u4eba\u6309a\u6570\u7ec4\u7684\u5173\u7cfb\u8fde\u8d77\u6765\uff0c\u5bb9\u91cf\u4e3aINF,\u82b1\u8d39\u4e3a\u96f6\n        }\n    }\n    for(int i=1;i<=m;i++){\n        int s;\n        scanf(\"%d\",&s);\n        for(int j=1;j<=s;j++){\n            scanf(\"%d\",&ss[j]);\n        } \n        ss[s+1]=INF;\n        for(int j=1;j<=s+1;j++){\n            int w;\n            scanf(\"%d\",&w);\n                add(i+n,n+m+1,w,ss[j]-ss[j-1]);//\u7136\u540e\u5c06\u4eba\u548c\u4f1a\u70b9\u8fde\u8d77\u6765\u5bb9\u91cf\u4e3a\u4ed6\u505a\u51e0\u4ef6\u7269\u54c1\uff0c\u4e5f\u5c31\u662fss[j]-ss[j-1],\u82b1\u8d39\u4e3a\u4ed6\u505a\u8fd9\u51e0\u4ef6\u7684\u6124\u6012\u503c\n        }\n    }\n    st d=maxflow(0,n+m+1);\n    printf(\"%lld\",d.cost);\n    return 0;\n}\n```",
        "postTime": 1493972726,
        "uid": 18371,
        "name": "alpq010815",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2488 \u3010[SDOI2011]\u5de5\u4f5c\u5b89\u6392\u3011"
    }
]