[
    {
        "content": "[\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/T154242)\n\n\u672c\u9898\u662f\u4e00\u9053\u5178\u578b\u7684\u8ba1\u7b97\u51e0\u4f55\u9898\u76ee\u3002\u9700\u8981\u89e3\u9898\u8005\u638c\u63e1\u51f8\u5305\u548c\u534a\u5e73\u9762\u4ea4\u7684\u6c42\u89e3\u65b9\u6cd5\u3002\n\n\u9898\u76ee\u7ed9\u5b9a\u7684\u964d\u96e8\u4e91\u662f\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\uff0c\u5f53\u5c06\u5176\u8fdb\u884c\u5e73\u79fb\u64cd\u4f5c\u540e\uff0c\u5176\u8def\u5f84\u6240\u8986\u76d6\u7684\u533a\u57df\u4e5f\u662f\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\uff0c\u8fd9\u4e2a\u51f8\u591a\u8fb9\u5f62\u5e94\u8be5\u5982\u4f55\u6c42\u5462\uff1f\u5f88\u7b80\u5355\uff0c\u5c06\u5e73\u79fb\u540e\u7684\u5404\u4e2a\u51f8\u5305\u9876\u70b9\u6c42\u51fa\u6765\uff0c\u4e0e\u539f\u6765\u7684\u51f8\u5305\u9876\u70b9\u4e00\u8d77\uff0c\u518d\u6c42\u4e00\u6b21\u51f8\u5305\u5373\u53ef\u3002\u77e5\u9053\u4e86\u964d\u96e8\u4e91\u8986\u76d6\u7684\u533a\u57df\uff0c\u5c06\u5176\u4e0e\u5efa\u7b51\u9876\u9762\u7684\u77e9\u5f62\u4f5c\u534a\u5e73\u9762\u4ea4\uff0c\u6c42\u51fa\u5404\u4e2a\u4ea4\u7684\u9762\u79ef\uff0c\u7136\u540e\u7d2f\u52a0\u5373\u53ef\u3002\n\n\u4e3b\u8981\u6ce8\u610f\u5b9e\u73b0\u7684\u7ec6\u8282\u5373\u53ef\u3002\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXV = 1100;\nconst double EPSILON = 1E-7;\n\n// \u8868\u793a\u70b9\u7684\u6570\u636e\u7ed3\u6784\nstruct point {\n    double x, y;\n    point (double x = 0, double y = 0): x(x), y(y) {}\n    point operator + (point p) { return point(x + p.x, y + p.y); };\n    point operator - (point p) { return point(x - p.x, y - p.y); };\n    point operator * (double k) { return point(x * k, y * k); };\n    point operator / (double k) { return point(x / k, y / k); };\n    \n    bool operator<(const point &p) const\n\t{\n\t    if (fabs(y - p.y) > EPSILON) return y < p.y;\n\t    return x < p.x;\n\t}\n\t\n\tbool operator==(const point &p) const\n\t{\n\t    return fabs(x - p.x) <= EPSILON && fabs(y - p.y) <= EPSILON;\n\t}\n};\n\n// \u5b9a\u4e49\u591a\u8fb9\u5f62\ntypedef vector<point> polygon;\n\n\n// \u8303\u6570\ndouble norm(point a)\n{\n    return a.x * a.x + a.y * a.y;\n}\n\n// \u6a21\ndouble abs(point a)\n{\n    return sqrt(norm(a));\n}\n\n// \u5185\u79ef\uff08\u70b9\u79ef\uff09\ndouble dot(point a, point b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\n// \u5916\u79ef\uff08\u53c9\u79ef\uff09\ndouble cross(point a, point b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n// \u5b9a\u4e49\u76f4\u7ebf\uff0c\u4f7f\u7528\u4e24\u70b9\u548c\u6781\u89d2\u5b9a\u4e49\u76f4\u7ebf\uff0c\u52a0\u5165\u6781\u89d2\u662f\u7528\u4e8e\u534a\u5e73\u9762\u4ea4\nstruct line\n{\n    point a, b;\n    double angle;\n};\n\n// \u6709\u5411\u9762\u79ef\ndouble cp(point a, point b, point c)\n{\n    return cross(b - a, c - a);\n}\n\n// \u5229\u7528\u6709\u5411\u9762\u79ef\u5224\u65ad\u987a\u65f6\u9488\u65cb\u8f6c\nbool cw(point a, point b, point c)\n{\n    return cp(a, b, c) < -EPSILON;\n}\n\n// \u5229\u7528\u6709\u5411\u9762\u79ef\u5224\u65ad\u9006\u65f6\u9488\u65cb\u8f6c\nbool ccw(point &a, point &b, point &c)\n{\n    return cp(a, b, c) > EPSILON;\n}\n\n// \u5229\u7528\u6709\u5411\u9762\u79ef\u5224\u65ad\u9006\u65f6\u9488\u65cb\u8f6c\u6216\u5171\u7ebf\nbool ccwOrCollinear(point &a, point &b, point &c)\n{\n    double cp1 = cp(a, b, c);\n\treturn cp1 > EPSILON || fabs(cp1) <= EPSILON;\n}\n\n// \u5229\u7528 Andrew \u5408\u5e76\u6cd5\u6c42\u51f8\u5305\npolygon andrewConvexHull(polygon pg)\n{\n\tpolygon ch;\n\n    sort(pg.begin(), pg.end());\n\tfor (int i = 0; i < pg.size(); i++)\n\t{\n\t\twhile (ch.size() >= 2 &&\n\t\t    ccwOrCollinear(ch[ch.size() - 2], ch[ch.size() - 1], pg[i]))\n\t\t\tch.pop_back();\n\t\tch.push_back(pg[i]);\n\t}\n\tfor (int i = pg.size() - 1, upper = ch.size() + 1; i >= 0; i--)\n\t{\n\t\twhile (ch.size() >= upper &&\n\t\t    ccwOrCollinear(ch[ch.size() - 2], ch[ch.size() - 1], pg[i]))\n\t\t\tch.pop_back();\n\t\tch.push_back(pg[i]);\n\t}\n    ch.pop_back();\n    \n\treturn ch;\n}\n\n// \u6309\u6781\u89d2\u5bf9\u76f4\u7ebf\u8fdb\u884c\u6392\u5e8f\u7684\u6bd4\u8f83\u51fd\u6570\nbool cmpLine(line p, line q)\n{\n    if (fabs(p.angle - q.angle) <= EPSILON) return cw(p.a, p.b, q.a);\n    return p.angle < q.angle;\n}\n\n// \u6309\u6781\u89d2\u5bf9\u76f4\u7ebf\u8fdb\u884c\u53bb\u91cd\u7684\u6bd4\u8f83\u51fd\u6570\nbool cmpAngle(line p, line q)\n{\n    return fabs(p.angle - q.angle) <= EPSILON;\n}\n\n// \u5224\u5b9a\u4e24\u6761\u76f4\u7ebf\u662f\u5426\u5e73\u884c\nbool parallel(line p, line q)\n{\n    return fabs((p.a.x - p.b.x) * (q.a.y - q.b.y) -\n        (q.a.x - q.b.x) * (p.a.y - p.b.y)) <= EPSILON;\n}\n\n// \u786e\u5b9a\u4e24\u6761\u76f4\u7ebf\u7684\u4ea4\u70b9\npoint getIntersection(line p, line q)\n{\n    point p1 = p.a;\n    double scale =\n        ((p.a.x - q.a.x) * (q.a.y - q.b.y) - (p.a.y - q.a.y) * (q.a.x - q.b.x)) /\n        ((p.a.x - p.b.x) * (q.a.y - q.b.y) - (p.a.y - p.b.y) * (q.a.x - q.b.x));\n    p1.x += (p.b.x - p.a.x) * scale;\n    p1.y += (p.b.y - p.a.y) * scale;\n    return p1;\n}\n\n// \u6839\u636e\u4e24\u70b9\u786e\u5b9a\u4e00\u6761\u76f4\u7ebf\nline pointToLine(point a, point b)\n{\n    line lr;\n    lr.a = a, lr.b = b, lr.angle = atan2(b.y - a.y, b.x - a.x);\n    return lr;\n}\n\n// \u4f7f\u7528\u6731\u6cfd\u56ed\u4ecb\u7ecd\u7684\u201c\u6392\u5e8f\u589e\u91cf\u6cd5\u201d\u6c42\u534a\u5e73\u9762\u4ea4\npolygon halfPlaneIntersection(line *sides, int nLine)\n{\n    polygon pg;\n    line deq[MAXV];\n\n    sort(sides, sides + nLine, cmpLine);\n    nLine = unique(sides, sides + nLine, cmpAngle) - sides; \n\n    int btm = 0, top = 1;\n    deq[0] = sides[0], deq[1] = sides[1];\n\n    for (int i = 2; i < nLine; i++)\n    {\n        if (parallel(deq[top], deq[top - 1]) || parallel(deq[btm], deq[btm + 1]))\n            return pg;\n\n        while (btm < top &&\n            cw(sides[i].a, sides[i].b, getIntersection(deq[top], deq[top - 1])))\n            top--;\n        while (btm < top &&\n            cw(sides[i].a, sides[i].b, getIntersection(deq[btm], deq[btm + 1])))\n            btm++;\n\n        deq[++top] = sides[i];\n    }\n\n    while (btm < top &&\n        cw(deq[btm].a, deq[btm].b, getIntersection(deq[top], deq[top - 1])))\n        top--;\n    while (btm < top &&\n        cw(deq[top].a, deq[top].b, getIntersection(deq[btm], deq[btm + 1])))\n        btm++;\n\n    if (top <= (btm + 1)) return pg;\n\n    for (int i = btm; i < top; i++)\n        pg.push_back(getIntersection(deq[i], deq[i + 1]));\n    if (btm < (top + 1))\n        pg.push_back(getIntersection(deq[btm], deq[top]));\n\n    return pg;\n}\n\n// \u8ba1\u7b97\u591a\u8fb9\u5f62\u7684\u9762\u79ef\ndouble getArea(polygon pg)\n{\n    if (pg.size() < 3) return 0.0;\n    double A = 0.0;\n    int n = pg.size();\n    for (int i = 0, j = (i + 1) % n; i < n; i++, j = (i + 1) % n)\n        A += (pg[i].x * pg[j].y - pg[j].x * pg[i].y);\n    return fabs(A / 2.0);\n}\n\n// \u6839\u636e\u5bf9\u89d2\u9876\u70b9\u5750\u6807\u786e\u5b9a\u77e9\u5f62\npolygon getRectFromPoint(int x1, int y1, int x2, int y2)\n{\n    polygon rect;\n    int minx = min(x1, x2), maxx = max(x1, x2);\n    int miny = min(y1, y2), maxy = max(y1, y2);\n    rect.push_back(point(minx, miny));\n    rect.push_back(point(maxx, miny));\n    rect.push_back(point(maxx, maxy));\n    rect.push_back(point(minx, maxy));\n    return rect;\n}\n\n// \u89e3\u6790\u65f6\u95f4\nint getTime(string text)\n{\n    return stoi(text.substr(0, 2)) * 60 + stoi(text.substr(3));\n}\n\nint main(int argc, char *argv[])\n{\n    cin.tie(0), cout.tie(0), ios::sync_with_stdio(false);\n\n    int cases, n, m, v;\n    string time1, time2;\n\n    cin >> cases;\n    for (int cs = 1; cs <= cases; cs++)\n    {\n        cin >> n;\n        \n        // \u8bfb\u5165\u6bcf\u680b\u5efa\u7b51\u7684\u5bf9\u89d2\u70b9\u5750\u6807\uff0c\u7531\u5bf9\u89d2\u70b9\u5750\u6807\u786e\u5b9a\u77e9\u5f62\uff0c\u77e9\u5f62\u7684\u9876\u70b9\u6309\u9006\u65f6\u9488\u6392\u5217\u3002\n        vector<polygon> rects;\n        int x1, y1, x2, y2;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> x1 >> y1 >> x2 >> y2;\n            rects.push_back(getRectFromPoint(x1, y1, x2, y2));\n        }\n        \n        // \u8bfb\u5165\u964d\u96e8\u4e91\u3002\n        polygon cloud;\n        cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            cin >> x1 >> y1;\n            cloud.push_back(point(x1, y1));\n        }\n        \n        // \u964d\u96e8\u4e91\u6cbf\u7740\u76f4\u7ebf\u65b9\u5411\u505a\u5e73\u79fb\u8fd0\u52a8\uff0c\u5176\u626b\u8fc7\u7684\u533a\u57df\u6784\u6210\u4e00\u4e2a\u51f8\u591a\u8fb9\u5f62\u3002\u4f7f\u7528\u51f8\u5305\u7b97\u6cd5\u6c42\u51fa\u51f8\u591a\u8fb9\u5f62\u7684\u9876\u70b9\uff0c\u9876\u70b9\u6309\u7167\u9006\u65f6\u9488\u65b9\u5411\u6392\u5e8f\u3002\n        point s, e;\n        cin >> s.x >> s.y >> e.x >> e.y;\n        cin >> v >> time1 >> time2;\n        double d = v * (getTime(time2) - getTime(time1));\n        int cnt = cloud.size();\n        for (int i = 0; i < cnt; i++)\n        {\n            point moved = cloud[i] + (e - s) * d / abs(e - s);\n            cloud.push_back(moved);\n        }\n        cloud = andrewConvexHull(cloud);\n        reverse(cloud.begin(), cloud.end());\n\n        // \u4f7f\u7528\u534a\u5e73\u9762\u4ea4\u786e\u5b9a\u964d\u96e8\u4e91\u4e0e\u6bcf\u680b\u5efa\u7b51\u7684\u9876\u5c42\u7684\u4ea4\uff0c\u8ba1\u7b97\u9762\u79ef\u5e76\u6c42\u548c\u3002\n        double area = 0;\n        line sides[MAXV];\n        for (int i = 0; i < rects.size(); i++)\n        {\n            int nLine = 0;\n            for (int j = 0; j < cloud.size(); j++)\n                sides[nLine++] = pointToLine(cloud[j], cloud[(j + 1) % cloud.size()]);\n            for (int j = 0; j < rects[i].size(); j++)\n                sides[nLine++] = pointToLine(rects[i][j], rects[i][(j + 1) % rects[i].size()]);\n            area += getArea(halfPlaneIntersection(sides, nLine));\n        }\n        cout << fixed << setprecision(1) << area << '\\n';\n    }\n\n    return 0;\n}\n```",
        "postTime": 1604536376,
        "uid": 333388,
        "name": "metaphysis",
        "ccfLevel": 0,
        "title": "T5 \u96e8\u6c34\u6536\u96c6\u7cfb\u7edf"
    },
    {
        "content": "\u505a\u6cd5\u663e\u7136\u7684\u8ba1\u7b97\u51e0\u4f55\u3002\n\n\u5047\u5982\u80fd\u6c42\u51fa\u4e91\u8fd0\u52a8\u65f6\u6240\u626b\u8fc7\u7684\u56fe\u5f62\uff0c\u56e0\u4e3a\u77e9\u5f62\u4e0d\u76f8\u4ea4\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u5bf9\u4e8e\u6bcf\u4e2a\u77e9\u5f62\u4f7f\u7528\u9762\u79ef\u4ea4\u6765\u6c42\u51fa\u9762\u79ef\u4e4b\u548c\u3002\u800c\u4e91\u7684\u6bcf\u4e2a\u70b9\u79fb\u52a8\u7684\u65b9\u5411\u548c\u8ddd\u79bb\u76f8\u540c\uff0c\u6240\u4ee5\u8d77\u59cb\u6240\u6709\u70b9\u4e0e\u6700\u540e\u72b6\u6001\u6240\u6709\u70b9\u6240\u5f62\u6210\u7684\u7684\u51f8\u5305\u5c31\u662f\u4e91\u8fd0\u52a8\u65f6\u6240\u626b\u8fc7\u7684\u56fe\u5f62\u3002\u6c42\u51f8\u5305\u662f $O(m)$ \u7684\uff0c\u6c42\u9762\u79ef\u4ea4\u7684\u603b\u590d\u6742\u5ea6\u662f $O(nm)$ \u7684\uff0c\u6240\u4ee5\u80fd\u8fc7\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300;\nconst double eps = 1e-8;\nint sig(double d) {\n    return (d > eps) - (d < -eps);\n}\nstruct Point {\n    double x, y;\n    Point() {}\n    Point(double x, double y): x(x), y(y) {}\n    bool operator==(const Point &p)const {\n        return sig(x - p.x) == 0 && sig(y - p.y) == 0;\n    }\n};\ndouble cross(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (b.x - o.x) * (a.y - o.y);\n}\ndouble area(Point *ps, int n) {\n    ps[n] = ps[0];\n    double res = 0;\n\n    for (int i = 0; i < n; i++) {\n        res += ps[i].x * ps[i + 1].y - ps[i].y * ps[i + 1].x;\n    }\n\n    return res / 2.0;\n}\nint lineCross(Point a, Point b, Point c, Point d, Point &p) {\n    double s1, s2;\n    s1 = cross(a, b, c);\n    s2 = cross(a, b, d);\n\n    if (sig(s1) == 0 && sig(s2) == 0)\n        return 2;\n\n    if (sig(s2 - s1) == 0)\n        return 0;\n\n    p.x = (c.x * s2 - d.x * s1) / (s2 - s1);\n    p.y = (c.y * s2 - d.y * s1) / (s2 - s1);\n    return 1;\n}\n\nvoid polygon_cut(Point *p, int &n, Point a, Point b) {\n    static Point pp[maxn];\n    int m = 0;\n    p[n] = p[0];\n\n    for (int i = 0; i < n; i++) {\n        if (sig(cross(a, b, p[i])) > 0)\n            pp[m++] = p[i];\n\n        if (sig(cross(a, b, p[i])) != sig(cross(a, b, p[i + 1])))\n            lineCross(a, b, p[i], p[i + 1], pp[m++]);\n    }\n\n    n = 0;\n\n    for (int i = 0; i < m; i++)\n        if (!i || !(pp[i] == pp[i - 1]))\n            p[n++] = pp[i];\n\n    while (n > 1 && p[n - 1] == p[0])\n        n--;\n}\n\ndouble intersectArea(Point a, Point b, Point c, Point d) {\n    Point o(0, 0);\n    int s1 = sig(cross(o, a, b));\n    int s2 = sig(cross(o, c, d));\n\n    if (s1 == 0 || s2 == 0)\n        return 0.0;\n\n    if (s1 == -1)\n        swap(a, b);\n\n    if (s2 == -1)\n        swap(c, d);\n\n    Point p[10] = {o, a, b};\n    int n = 3;\n    polygon_cut(p, n, o, c);\n    polygon_cut(p, n, c, d);\n    polygon_cut(p, n, d, o);\n    double res = fabs(area(p, n));\n\n    if (s1 * s2 == -1)\n        res = -res;\n\n    return res;\n}\n\ndouble intersectArea(Point *ps1, int n1, Point *ps2, int n2) {\n    if (area(ps1, n1) < 0)\n        reverse(ps1, ps1 + n1);\n\n    if (area(ps2, n2) < 0)\n        reverse(ps2, ps2 + n2);\n\n    ps1[n1] = ps1[0];\n    ps2[n2] = ps2[0];\n    double res = 0;\n\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < n2; j++) {\n            res += intersectArea(ps1[i], ps1[i + 1], ps2[j], ps2[j + 1]);\n        }\n    }\n\n    return res;\n}\nPoint p1[1000], p2[1000];\nstruct point {\n    double x, y;\n    int ids;\n} eg[100010], stacks[100010];\nbool pd(point i, point j) {\n    return (i.x < j.x || (i.x == j.x && i.y < j.y));\n}\ndouble dist(point i, point j) {\n    return (double)sqrt((i.x - j.x) * (i.x - j.x) + (i.y - j.y) * (i.y - j.y));\n}\ndouble comp(point j, point i, point j1, point i1) {\n    return (i.y - j.y) * (i1.x - j1.x) < (i1.y - j1.y) * (i.x - j.x);\n}\n\nint sx1[100010], sy1[100010], sx2[100010], sy2[100010];\nint sf[210];\nint main() {\n    int n1, n2;\n    int t;\n    scanf(\"%d\", &t);\n\n    while (t --) {\n        int n;\n        scanf(\"%d\", &n);\n\n        for (int i = 1; i <= n; ++ i)\n            scanf(\"%d%d%d%d\", &sx1[i], &sy1[i], &sx2[i], &sy2[i]);\n\n        scanf(\"%d\", &n1);\n\n        for (int i = 0; i < n1; ++ i) {\n            scanf(\"%lf%lf\", &eg[i].x, &eg[i].y);\n            eg[i].ids = i;\n            sf[i] = 0;\n        }\n\n        double x1, y1, x2, y2, v, m1, m2, m3, m4;\n        scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n        scanf(\"%lf\", &v);\n        scanf(\"%lf:%lf %lf:%lf\", &m1, &m2, &m3, &m4);\n        double dis = (m3 * 60 + m4 - m1 * 60 - m2) * v;\n        x2 -= x1;\n        y2 -= y1;\n        double bb = dis / dist((point) {\n            0, 0\n        }, (point) {\n            x2, y2\n        });\n        x2 *= bb;\n        y2 *= bb;\n\n        for (int i = 0; i < n1; ++ i) {\n            eg[i + n1].y = eg[i].y + y2;\n            eg[i + n1].x = eg[i].x + x2;\n            eg[i + n1].ids = i + n1;\n            sf[i + n1] = 0;\n        }\n\n        n1 *= 2;\n        sort(eg, eg + n1, pd);\n        int num = 0;\n\n        for (int i = 0; i < n1; ++ i) {\n            if (i)\n                if (eg[i].x == eg[i - 1].x)\n                    continue;\n\n            stacks[++ num] = eg[i];\n\n            while (num >= 3 && comp(stacks[num - 2], stacks[num], stacks[num - 2], stacks[num - 1])) {\n                stacks[num - 1] = stacks[num];\n                -- num;\n            }\n        }\n\n        int tt = 0;\n\n        for (int i = 1; i <= num; ++ i) {\n            p1[tt].x = stacks[i].x, p1[tt].y = stacks[i].y;\n            ++ tt;\n        }\n\n        memset(stacks, 0, sizeof(stacks));\n        num = 0;\n\n        for (int i = n1 - 1; i >= 0; -- i) {\n            if (i)\n                if (eg[i].x == eg[i + 1].x)\n                    continue;\n\n            stacks[++ num] = eg[i];\n\n            while (num >= 3 && comp(stacks[num - 2], stacks[num], stacks[num - 2], stacks[num - 1])) {\n                stacks[num - 1] = stacks[num];\n                -- num;\n            }\n        }\n\n        for (int i = 1; i <= num; ++ i) {\n            p1[tt].x = stacks[i].x, p1[tt].y = stacks[i].y;\n            ++ tt;\n        }\n\n        n1 = tt;\n        double ans = 0;\n\n        for (int i = 1; i <= n; ++ i) {\n            n2 = 4;\n            p2[0].x = min(sx1[i], sx2[i]);\n            p2[0].y = min(sy1[i], sy2[i]);\n            p2[1].x = max(sx1[i], sx2[i]);\n            p2[1].y = min(sy1[i], sy2[i]);\n            p2[2].x = max(sx1[i], sx2[i]);\n            p2[2].y = max(sy1[i], sy2[i]);\n            p2[3].x = min(sx1[i], sx2[i]);\n            p2[3].y = max(sy1[i], sy2[i]);\n            ans += intersectArea(p1, n1, p2, n2);\n        }\n\n        printf(\"%lf\\n\", ans);\n    }\n\n    return 0;\n}\n```\n",
        "postTime": 1614735013,
        "uid": 111728,
        "name": "\u5e7b\u5f71\u661f\u575a\u5f3a",
        "ccfLevel": 7,
        "title": "P7397"
    }
]