[
    {
        "content": "####  \u7ec8\u4e8e\u6765\u5230\u4e86Qtree3\uff0c \u5176\u5b9e\u8fd9\u662fQtree\u7cfb\u5217\u4e2d\u6700\u7b80\u5355\u7684\u4e00\u9053\u9898\uff0c\u5e76\u4e0d\u9700\u8981\u7ebf\u6bb5\u6811\uff0c \u53ea\u8981\u6811\u94fe\u5256\u5206\u7684\u4e00\u70b9\u601d\u60f3\u5c31\u543c\u4e86\u3002\n\n\u5bf9\u4e8e\u6811\u94fe\u5256\u5206\u5256\u51fa\u6765\u7684\u6bcf\u4e00\u6839\u91cd\u94fe\uff0c\u5728\u91cd\u94fe\u4e0a\u7ef4\u62a4\u4e00\u4e2aSet\u5c31\u597d\u4e86\uff0c \u6bcf\u4e00\u4e2aSet\u91cc\u5b58\u7684\u90fd\u662f\u91cd\u94fe\u4e2d\u7684\u9ed1\u70b9\uff0c \u6df1\u5ea6\u5c31\u662f\u5173\u952e\u5b57\u3002\n\n\u8003\u8651\u6bcf\u4e00\u79cd\u64cd\u4f5c\n\n------------------------------\n### 0 \uff1a \u6539\u53d8\u989c\u8272\n\t    \u5728\u4ed6\u6240\u5728\u7684\u91cd\u94fe\u4e0a\u63d2\u5165\u4e00\u4e2a\u9ed1\u70b9\u6216\u8005earse\u6389\n### 1 :  \u67e5\u8be2\n\t\t\u5c31\u50cf\u6811\u94fe\u5256\u5206\u4e00\u6837\uff0c \u4e00\u76f4\u5f80\u4e0a\u8df3\u91cd\u94fe\u5934\u7136\u540e\u66f4\u65b0\u7b54\u6848\u5373\u53ef\n       \n--------------------\n\u4ee3\u7801\u8f83\u77ed\n\n```cpp\n#include <bits/stdc++.h>\n#define maxn 101000\n#define maxm 303000\nusing namespace std;\n\ntemplate<class T>\ninline void read(T &a){\n\tT s = 0, w = 1;\n\tchar c = getchar();\n\twhile(c < '0' || c  > '9') {if(c == '-') w = -1; c = getchar();}\n\twhile(c >= '0' && c <= '9') {s = (s << 1) + (s << 3) + (c ^ 48); c = getchar();}\n\ta = s*w;\n}\n\nstatic int n,q;\nstatic int head[maxn], net[maxm], to[maxm],tot;\n\ninline void add(int x, int y){\n\tnet[++tot] = head[x], head[x] = tot, to[tot] = y;\n}\n\nstatic int dfn[maxn],tid[maxn], fat[maxn], size[maxn], son[maxn], deep[maxn];\nstatic int top[maxn], cnt;\n\nset<int> Ans[maxn];\n\nvoid dfs1(int x, int fa){\n\tsize[x] = 1;\n\tson[x] = 0; size[0] = 0;\n\tfat[x] = fa;\n//\tprintf(\"%d\\n\", x);\n\tfor (int i = head[x]; i; i = net[i]){\n\t\tint v = to[i];\n\t\tif(v == fa) continue;\n\t\tdeep[v] = deep[x] + 1;\n\t\tdfs1(v, x);\n\t\tsize[x] += size[v];\n\t\tif(size[v] > size[son[x]]) son[x] = v;\n\t}\n}\nvoid dfs2(int x, int fa, int t){\n\tdfn[++cnt] = x;\n\t//printf(\"%d %d %d\\n\", cnt, x, t);\n\ttid[x] = cnt;\n\ttop[x] = t;\n\tif(!son[x]) return;\n\tdfs2(son[x], x, t);\n\tfor (int i = head[x]; i; i = net[i]){\n\t\tint v = to[i];\n\t\tif(v == fa || v == son[x]) continue;\n\t\tdfs2(v, x, v);\n\t}\n}\n\n\nint col[maxn];\nint main(){\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"p4116.in\",\"r\", stdin);\n\t\tfreopen(\"p4116.out\",\"w\", stdout);\n\t#endif\n\tread(n); read(q);\n//\tprintf(\"%d\\n\", n); return 0;\n\tfor (int i = 1; i < n; i++){\n\t\tint x, y;\n\t\tread(x); read(y);\n\t\tadd(x, y); add(y, x);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, 0, 1); \n\tfor (int i = 1; i <= q; i++){\n\t\tint opt, x;\n\t\tread(opt); read(x);\n\t\tif(opt == 0){\n\t\t\tcol[x] ^= 1;\n\t\t\tif(col[x] == 1) Ans[top[x]].insert(tid[x]);\n\t\t\t else Ans[top[x]].erase(tid[x]);\n\t\t}\n\t\telse{\n\t\t\tint ans = 0x3f3f3f3f;\n\t\t\twhile(x){\n\t\t\t\tint k = *Ans[top[x]].begin();\n\t\t\t\tif(Ans[top[x]].size())\n\t\t\t\t\tif(deep[dfn[k]] <= deep[x]) ans = dfn[k];\n\t\t\t\tx = fat[top[x]];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", ans == 0x3f3f3f3f ? -1: ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1552706255,
        "uid": 33339,
        "name": "Zcus",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "$$\\color{cornflowerblue}{\\mathcal{Treaker}}$$\n# \u6811\u94fe\u5256\u5206\n\u770b\u89c1\u9898\u89e3\u91cc\u6709\u7528set\u7684\uff0c\u672c\u4eba\u8868\u793a\u4e0d\u662f\u5f88\u4f1aSTL\uff1b\n\n\u4e8e\u662f\u8fd8\u662f\u7528\u662f\u6811\u5256+\u7ebf\u6bb5\u6811\u8fc7\u4e86\u8fd9\u9053\u9898\u3002\u3002\n\n\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u4e8b\u60c5\u5c31\u662f\uff0c\u4ece1\u5230v\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u70b9\u7684dfs\u5e8f\u662f\u8d8a\u6765\u8d8a\u5927\uff0c\u56e0\u4e3a\u4ed6\u7684\u6df1\u5ea6\u8d8a\u6765\u8d8a\u5927\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6027\u8d28\u6765\u7ef4\u62a4\u3002\u3002\n\n\u6211\u4eec\u5bf9\u4e8e\u9ed1\u70b9\uff0c\u8ba9\u5b83\u7684\u503c\u7b49\u4e8e\u5b83\u7684dfs\u5e8f\uff0c\u767d\u70b9\u7684\u8bdd\uff0c\u76f4\u63a5\u8d4binf\uff0c\u90a3\u4e48\u6211\u67e5\u8be2\u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u67e5\u8be2dfs\u5e8f\u7684\u6700\u5c0f\u503c\uff0c\u518d\u628a\u5b83\u8f6c\u5316\u6210\u7f16\u53f7\u5373\u53ef\u3002\u3002\n\n\u5b8c\u6574~~\u6307\u9488~~\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int N = 100005 , inf = 1e9;\ninline int read()\n{\n\tint x = 0 , f = 1;\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint n , Q , cnt;\nint dfn[N] , size[N] , top[N] , fa[N] , dep[N] , hs[N] , id[N];\nstruct Tree_Div\n{\n\tstruct Edge\n\t{\n\t\tint to; Edge *nxt;\n\t\tEdge(int to,Edge *nxt) : to(to) , nxt(nxt) {}\n\t}*head[N];\n\tinline void add(int u,int v) {head[u] = new Edge(v,head[u]);}\n\tvoid get_tree(int x)\n\t{\n\t\tsize[x] = 1;\n\t\tfor(Edge *i = head[x];i;i = i -> nxt)\n\t\t{\n\t\t\tint to = i -> to;\n\t\t\tif(dep[to]) continue;\n\t\t\tdep[to] = dep[x] + 1;\n\t\t\tfa[to] = x;\n\t\t\tget_tree(to);\n\t\t\tsize[x] += size[to];\n\t\t\tif(size[to] > size[hs[x]]) hs[x] = to;\n\t\t}\n\t}\n\tvoid dfs(int x,int topfa)\n\t{\n\t\tdfn[x] = ++cnt;\n\t\tid[cnt] = x;\n\t\ttop[x] = topfa;\n\t\tif(hs[x]) dfs(hs[x],topfa);\n\t\tfor(Edge *i = head[x];i;i = i -> nxt)\n\t\t{\n\t\t\tint to = i -> to;\n\t\t\tif(to == hs[x] || to == fa[x]) continue;\n\t\t\tdfs(to,to);\n\t\t}\n\t}\n\t#define mid ((p -> l + p -> r) >> 1)\n\tstruct node\n\t{\n\t\tnode *ls , *rs;\n\t\tint l , r , minn;\n\t\tnode(int l,int r) : l(l) , r(r) {ls = rs = NULL; minn = inf;}\n\t\tinline void up() {minn = min(ls -> minn,rs -> minn);}\n\t}*root;\n\tvoid build(node *&p,int l,int r)\n\t{\n\t\tp = new node(l,r);\n\t\tif(l == r) return ;\n\t\tbuild(p -> ls,l,mid); build(p -> rs,mid+1,r); p -> up();\n\t}\n\tvoid chenge(node *p,int x)\n\t{\n\t\tif(p -> l == p -> r) return (void)(p -> minn == inf ? p -> minn = x : p -> minn = inf);\n\t\tx <= mid ? chenge(p -> ls,x) : chenge(p -> rs,x);\n\t\tp -> up();\n\t}\n\tint query(node *p,int x,int y)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return p -> minn;\n\t\treturn min(x <= mid ? query(p -> ls,x,y) : inf,y > mid ? query(p -> rs,x,y) : inf);\n\t}\n\tinline int sec_query(int x)\n\t{\n\t\tint res = inf;\n\t\twhile(top[x] != 1)\n\t\t{\n\t\t\tres = min(res,query(root,dfn[top[x]],dfn[x]));\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tres = min(res,query(root,dfn[1],dfn[x]));\n\t\treturn res == inf ? -1 : id[res];\n\t}\n\tinline void LOL()\n\t{\n\t\tn = read(); Q = read();\n\t\tfor(int i = 1 , u , v;i < n;i ++)\n\t\t{\n\t\t\tu = read(); v = read();\n\t\t\tadd(u,v); add(v,u);\n\t\t} dep[1] = 1;\n\t\tget_tree(1);\n\t\tdfs(1,1);\n\t\tbuild(root,1,n);\n\t\tfor(int i = 1 , opt , x;i <= Q;i ++)\n\t\t{\n\t\t\topt = read(); x = read();\n\t\t\tif(opt & 1) printf(\"%d\\n\",sec_query(x));\n\t\t\telse chenge(root,dfn[x]);\n\t\t}\n\t}\n}CF;\nint main()\n{\n\tCF.LOL();\n\treturn 0;\n}\n```\n",
        "postTime": 1570312295,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "### \u9898\u76ee\n[P4116 Qtree3](https://www.luogu.com.cn/problem/P4116)\n\n### \u601d\u8def\n\u6811\u94fe\u5256\u5206\u3002$1$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u7b2c\u4e00\u4e2a\u9ed1\u70b9\u5c31\u662f $1$ \u5230 $v$ \u8def\u5f84\u4e0a $dfs$ \u5e8f\u6700\u5c0f\u7684\u9ed1\u70b9\u3002\u6211\u4eec\u53ea\u9700\u8981\u628a\u9ed1\u70b9\u7684\u6743\u503c\u8d4b\u6210\u8be5\u70b9\u7684 $dfs$ \u5e8f\uff0c\u767d\u70b9\u7684\u6743\u503c\u8d4b\u6210\u65e0\u7a77\u5927\uff0c\u5c31\u628a\u67e5\u8be2 $1$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u7b2c\u4e00\u4e2a\u9ed1\u70b9\u8f6c\u5316\u6210\u4e86\u67e5\u8be2$1$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u6700\u5c0f\u503c\u7684\u95ee\u9898\u4e86\u3002\u5982\u679c\u6700\u5c0f\u503c\u7b49\u4e8e\u65e0\u7a77\u5927\u90a3\u4e48\u8f93\u51fa $-1$\uff0c\u5426\u5219\u8f93\u51fa\u6700\u5c0f\u503c\uff08$dfs$ \u5e8f\uff09\u5bf9\u5e94\u7684\u70b9\u7684\u7f16\u53f7\u3002\n\n### Code\n\n```cpp\n#include<cstdio>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<iostream>\n#define MAXN 100001\n#define inf 2147483647\n\ninline void read(int &T) {\n\tint x=0;bool f=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\tT=f?-x:x;\n}\n\nint n,q,dfn[MAXN],pre[MAXN],size[MAXN];\n\nint min(int a,int b) {return a<b?a:b;}\n\nnamespace Seg {\n\t#define lson now<<1\n\t#define rson now<<1|1\n\tstruct Node {\n\t\tint l,r,w;\n\t}tree[MAXN<<2];\n\tvoid build(int l,int r,int now) {\n\t\ttree[now].l=l,tree[now].r=r;\n\t\tif(tree[now].l==tree[now].r) {\n\t\t\ttree[now].w=inf;return;\n\t\t}\n\t\tint mid=(tree[now].l+tree[now].r)>>1;\n\t\tbuild(l,mid,lson),build(mid+1,r,rson);\n\t\ttree[now].w=min(tree[lson].w,tree[rson].w);\n\t}\n\tvoid update(int x,int now) {\n\t\tif(tree[now].l==tree[now].r) {\n\t\t\tif(tree[now].w!=inf) tree[now].w=inf;\n\t\t\telse tree[now].w=tree[now].l;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(tree[now].l+tree[now].r)>>1;\n\t\tif(x<=mid) update(x,lson);\n\t\telse update(x,rson);\n\t\ttree[now].w=min(tree[lson].w,tree[rson].w);\n\t}\n\tint query(int x,int y,int now) {\n\t\tif(tree[now].l>=x&&tree[now].r<=y) return tree[now].w;\n\t\tint mid=(tree[now].l+tree[now].r)>>1,ans=inf;\n\t\tif(x<=mid) ans=min(ans,query(x,y,lson));\n\t\tif(y>mid) ans=min(ans,query(x,y,rson));\n\t\treturn ans;\n\t}\n}\n\nnamespace Cut {\n\tint cnt,pthn,head[MAXN],dep[MAXN];\n\tint fa[MAXN],son[MAXN],top[MAXN];\n\tstruct Edge {\n\t\tint next,to;\n\t}pth[MAXN<<1];\n\tvoid add(int from,int to) {\n\t\tpth[++pthn].to=to,pth[pthn].next=head[from];\n\t\thead[from]=pthn;\n\t}\n\tvoid dfs1(int u,int father) {\n\t\tfa[u]=father,dep[u]=dep[father]+1,size[u]=1;\n\t\tfor(int i=head[u];i;i=pth[i].next) {\n\t\t\tint x=pth[i].to;\n\t\t\tif(x!=father) {\n\t\t\t\tdfs1(x,u),size[u]+=size[x];\n\t\t\t\tif(size[son[u]]<size[x]) son[u]=x;\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs2(int u,int tp) {\n\t\ttop[u]=tp,dfn[u]=++cnt,pre[cnt]=u;\n\t\tif(son[u]) dfs2(son[u],tp);\n\t\tfor(int i=head[u];i;i=pth[i].next) {\n\t\t\tint x=pth[i].to;\n\t\t\tif(x!=fa[u]&&x!=son[u]) dfs2(x,x);\n\t\t}\n\t}\n\tint ask(int x,int y) {\n\t\tint ans=inf;\n\t\twhile(top[x]!=top[y]) {\n\t\t\tif(dep[top[x]]<dep[top[y]]) std::swap(x,y);\n\t\t\tans=min(ans,Seg::query(dfn[top[x]],dfn[x],1));\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(dep[x]>dep[y]) std::swap(x,y);\n\t\tans=min(ans,Seg::query(dfn[x],dfn[y],1));\n\t\tif(ans==inf) return -1;\n\t\treturn ans;\n\t}\n}\n\nint main() {\n\tread(n),read(q);\n\tfor(int i=1,u,v;i<n;++i) {\n\t\tread(u),read(v);\n\t\tCut::add(u,v),Cut::add(v,u);\n\t}\n\tCut::dfs1(1,1),Cut::dfs2(1,1),Seg::build(1,n,1);\n\tfor(int i=1,opt,x;i<=q;++i) {\n\t\tread(opt),read(x);\n\t\tif(opt==0) Seg::update(dfn[x],1);\n\t\telse {\n\t\t\tint ccc=Cut::ask(1,x);\n\t\t\tif(ccc==-1) puts(\"-1\");\n\t\t\telse printf(\"%d\\n\",pre[ccc]);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1589093633,
        "uid": 142110,
        "name": "yu__xuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u6211\u5bfb\u601d\u8fd9\u9898\u4e3a\u4ec0\u4e48LCT\u9898\u89e3\u8fd9\u4e48\u5c11\u554a...   \n\u8fd9\u4e2a\u9898\u76ee\u8fde\u6362\u6839\u90fd\u4e0d\u8981\u7684\u8bddLCT\u5c82\u4e0d\u662f\u4e0d\u7528\u7ef4\u62a4\u7ffb\u8f6c\u64cd\u4f5c\u4e86\u561b\uff1f\n\u7136\u540epushdown,makeroot\u7b49\u7b49\u51fd\u6570\u90fd\u4e0d\u8981\u5199\u4e86  \n\u7136\u540e50\u884c\u5c31\u5b8c\u4e8b\u4e86\uff1f\uff1f\uff1f\n```cpp\n#include <cstdio>\n#define R register\nconst int MAXN=1e5+10;\nint ch[MAXN][2],fa[MAXN],id[MAXN],co[MAXN];\n#define ls(x) ch[x][0]\n#define rs(x) ch[x][1]\ninline int nroot(int x) { return ls(fa[x])==x||rs(fa[x])==x; }\ninline int get(int x) { return x==rs(fa[x]); }\ninline void update(int x) {\n\tid[x]=id[ls(x)]?id[ls(x)]:(co[x]?x:(id[rs(x)]?id[rs(x)]:0));\n}\ninline void rotate(int x) {\n\tint y=fa[x],z=fa[y],k=get(x),w=ch[x][!k];\n\tif(nroot(y)) ch[z][get(y)]=x;ch[x][!k]=y;ch[y][k]=w;\n\tif(w) fa[w]=y;fa[y]=x;fa[x]=z;update(x);update(y);\n}\ninline void splay(int x) {\n\tfor(;nroot(x);rotate(x))\n\t\tif(nroot(fa[x])) rotate(get(x)^get(fa[x])?x:fa[x]);\n}\ninline void access(int x) {\n\tfor(R int y=0;x;x=fa[y=x]) splay(x),rs(x)=y,update(x);\n}\nint n,q;\nstruct edge{ int y,next; }e[MAXN*2];\nint cnt,head[MAXN];\ninline void add(int x,int y) {\n\te[++cnt].y=y;e[cnt].next=head[x];head[x]=cnt;\n}\ninline void dfs(int x,int fx) {\n\tfa[x]=fx;\n\tfor(R int i=head[x];i;i=e[i].next) {\n\t\tif(e[i].y==fx)continue; dfs(e[i].y,x);\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(R int i=1;i<n;i++) {\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\twhile(q--) {\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x==0) { splay(y);co[y]^=1;update(y); }\n\t\telse {\n\t\t\taccess(y);splay(y);\n\t\t\tprintf(\"%d\\n\",id[y]==0?-1:id[y]);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u8fd8\u633a\u5feb\u7684\uff0c\u5feb\u8bfb\u90fd\u4e0d\u52a0\u5c313s\u4e86",
        "postTime": 1586677686,
        "uid": 139012,
        "name": "______OvO______",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "## \u9898\u610f\n\n\u6709\u4e00\u68f5$n$\u4e2a\u70b9$n-1$\u6761\u8fb9\u7684\u6811\u3002\n\n\u6811\u4e0a\u7684\u6bcf\u4e2a\u70b9\u53ef\u4ee5\u4e3a\u9ed1\u8272\u4e5f\u53ef\u4ee5\u662f\u767d\u8272\u3002\n\n\u5f00\u59cb\u6240\u6709\u7684\u70b9\u4e3a\u767d\u8272\u3002\n\n\u73b0\u5728\u9700\u8981$2$\u79cd\u64cd\u4f5c\uff1a\n\n$0~~i$ \u8868\u793a\u6539\u53d8$i$\u53f7\u70b9\u7684\u989c\u8272\uff08\u4e0e\u7684\u989c\u8272\u539f\u6765\u76f8\u53cd\uff09\u3002\n\n$1~~v$ \u8868\u793a\u8be2\u95ee$1$\u5230$v$\u7684\u8def\u5f84\u4e0a\u7684\u7b2c$1$\u4e2a\u9ed1\u70b9\uff0c\u82e5\u8def\u5f84\u4e0a\u65e0\u9ed1\u70b9\uff0c\u8f93\u51fa$-1$\u3002\n\n## \u601d\u8def\n\n\u521d\u59cb\u65f6\u6240\u6709\u70b9\u4e3a\u767d\u70b9\uff0c\u90a3\u6211\u4eec\u5bf9\u6240\u6709\u70b9\u8d4b\u6781\u5927\u503c\u3002\n\n\u5728\u4fee\u6539\u64cd\u4f5c\u65f6\uff0c\u8fd9\u4e2a\u70b9\u82e5\u53d8\u6210\u9ed1\u70b9\uff0c\u6211\u4eec\u5bf9\u8fd9\u70b9\u7684\u503c\u8d4b\u4e3a\u8be5\u70b9\u7684dfs\u5e8f\u3002\n\n\u82e5\u53d8\u6210\u767d\u70b9\u5219\u8d4b\u503c\u4e3a\u4e0e\u521d\u59cb\u6781\u5927\u503c\u76f8\u540c\u7684\u6781\u5927\u503c\u3002\n\n\u9996\u5148\u4e00\u6761\u8def\u5f84\u4e0a\u7684dfs\u5e8f\u80af\u5b9a\u662f\u9012\u589e\u7684\u3002\n\n\u90a3\u4e48\u67e5\u8be2\u64cd\u4f5c\u65f6\u6211\u4eec\u67e5\u8be2\u5230\u7684\u8be5\u6761\u8def\u5f84\u7684\u6700\u5c0f\u503c\u4e00\u5b9a\u662f\u7b2c\u4e00\u4e2a\u9ed1\u70b9\u7684dfs\u5e8f\u3002\u6b64\u65f6\u8f93\u51fadfs\u5e8f\u5bf9\u5e94\u7684\u70b9\u7684\u7f16\u53f7\u3002\n\n\u5982\u679c\u4e3a\u6781\u5927\u503c\u5219\u8f93\u51fa$-1$\u5373\u53ef\u3002\n\n\u6b64\u65f6\u5df2\u7ecf\u5f88\u663e\u7136\u4e86\u3002\n\n\u90a3\u4e48\u7ef4\u62a4\u4ee5\u4e0a\u64cd\u4f5c\u76f4\u63a5\u7528\u6211\u4eec\u559c\u95fb\u4e50\u89c1\u7684\u6811\u5256+\u7ebf\u6bb5\u6811\u5c31\u53ef\u4ee5\u5566qwq\u3002\n\n~~\u8fd8\u662f\u5f88\u7b80\u5355\u7684~~\u3002\n\n\n## \u4ee3\u7801\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\n#define ls (now << 1)\n#define rs (now<<1|1)\n#define mid ((l+r)>>1)\n\ntemplate<typename temp>\ntemp read(temp& x){\n\tx = 0; temp f = 1; char ch;\n\twhile(!isdigit(ch = getchar())) (ch == '-') and (f = -1);\n\tfor(x = ch^48; isdigit(ch = getchar()); x = (x<<3)+(x<<1)+(ch^48));\n\treturn x *= f;\n}\ntemplate <typename temp, typename ...Args>\nvoid read(temp& a, Args& ...args){read(a), read(args...);}\n\nconst int maxn = 1e5+10, inf = 1e9+10;\n\nint n, q, a[maxn];\n\nvector<int> v[maxn];\n\nstruct trees{\nprotected:\n\tstruct nods{\n\t\tint l, r, minnum;\n\t}node[maxn<<2];\n\tint cnt, dfn[maxn], id[maxn], top[maxn], dep[maxn], fa[maxn], size[maxn], height_son[maxn];\n\tvoid build(int now){\n\t\tsize[now] = 1;\n\t\tfor(unsigned int i = 0; i < v[now].size(); i ++){\n\t\t\tint to = v[now][i];\n\t\t\tif(dep[to]) continue;\n\t\t\tdep[to] = dep[now] + 1, fa[to] = now;\n\t\t\tbuild(to);\n\t\t\tsize[now] += size[to];\n\t\t\tif(size[to] > size[height_son[now]]) height_son[now] = to;\n\t\t}\n\t\treturn;\n\t}\n\tvoid dfs(int now, int topfa){\n\t\ttop[now] = topfa;\n\t\tdfn[now] = ++cnt, id[cnt] = now;\n\t\tif(height_son[now]) dfs(height_son[now], topfa);\n\t\tfor(unsigned int i = 0; i < v[now].size(); i ++){\n\t\t\tint to = v[now][i];\n\t\t\tif(height_son[now] == to or to == fa[now]) continue;\n\t\t\tdfs(to,to);\n\t\t}\n\t\treturn;\n\t}\n\tvoid up(int now){return (void)(node[now].minnum = min(node[ls].minnum, node[rs].minnum));}\n\tvoid build(int l, int r, int now){\n\t\tnode[now].l = l, node[now].r = r;\n\t\tif(l == r) return (void)(node[now].minnum = inf);\n\t\tbuild(l, mid, ls), build(mid+1, r, rs);\n\t\treturn up(now);\n\t}\n\tvoid quary(int l, int r, int now, int& ans){\n\t\tif(r < node[now].l or node[now].r < l) return;\n\t\tif(l <= node[now].l and node[now].r <= r) return(void)(ans = min(ans, node[now].minnum));\n\t\tquary(l, r, ls, ans), quary(l, r, rs, ans);\n\t\treturn up(now);\n\t}\n\tvoid chenge(int l, int r, int now, int val){\n\t\tif(r < node[now].l or node[now].r < l) return;\n\t\tif(l <= node[now].l and node[now].r <= r){\n\t\t\tif(node[now].minnum == inf) node[now].minnum = val;\n\t\t\telse node[now].minnum = inf;\n\t\t\treturn;\n\t\t}\n\t\tchenge(l, r, ls, val), chenge(l, r, rs, val);\n\t\treturn up(now);\n\t}\npublic:\n\tint quary(int x){\n\t\tint ans = inf;\n\t\twhile(top[x] != 1){\n\t\t\tquary(dfn[top[x]], dfn[x], 1, ans);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tquary(dfn[1], dfn[x], 1, ans);\n\t\treturn ans == inf ? -1 : id[ans];\n\t}\n\tvoid chenge(int x){return chenge(dfn[x], dfn[x], 1, dfn[x]);}\n\tvoid build(){return build(dep[1]=1), dfs(1,1), build(1,n,1);}\n}tree;\n\nsigned main(){\n\tread(n, q);\n\tfor(int i = 1, x, y; i < n; i ++){\n\t\tread(x, y);\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\ttree.build();\n\tfor(int opt, x; q; q --){\n\t\tread(opt, x);\n\t\tif(opt&1) printf(\"%d\\n\", tree.quary(x));\n\t\telse tree.chenge(x);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1601469601,
        "uid": 58323,
        "name": "Vanyun",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u663e\u7136\u7684\u4e00\u9053\u6811\u5256\u9898;\n\n\u542c\u8bf4\u53ef\u4ee5\u7528set\u7ef4\u62a4,\u4f46\u662f\u8fd9\u79cd\u7ef4\u62a4\u7ebf\u6bb5\u6811\u4e5f\u80af\u5b9a\u662f\u53ef\u4ee5\u505a\u7684.\n\n\u6539\u53d8\u989c\u8272\u663e\u7136\u662f\u5f02\u6216(\u9ed1\u4e3a1,\u767d\u4e3a0),\u76f4\u63a5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u5185\u7684\u6700\u5927\u503c(0\u62161),\u5982\u679c\u4e3a1,\u5219\u518d\u7ef4\u62a4\u533a\u95f4\u5185\u6700\u5de6\u8fb9\u4e3a1\u7684\u7aef\u70b9,\u6ca1\u6709\u7684\u8bdd\u8bb0\u4e3a0\u5c31\u597d.\n\n\u67e5\u627e\u65f6\u76f4\u63a5\u6309\u6811\u5256\u6a21\u7248\u8fdb\u884c\u533a\u95f4\u67e5\u8be2\u53d6\u6700\u540e\u4e00\u6b21\u7684\u7b54\u6848\u5c31\u597d\u4e86.\n~~(\u6b63\u786e\u6027\u663e\u7136)~~\n\n\u56e0\u4e3a\u6811\u5256\u4e2d\u6bcf\u4e00\u6b21\u67e5\u627e\u90fd\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a,\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662fDFS\u5e8f,\u540c\u4e00\u91cd\u94fe\u4e2dDFS\u5e8f\u5c0f\u7684\u6df1\u5ea6\u4e5f\u4e00\u5b9a\u5c0f,\u6240\u4ee5\u7ef4\u62a4\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u533a\u95f4\u6700\u5de6\u7aef\u7684\u9ed1\u70b9\u5373\u53ef.\n\ncode:\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nlong long n,m,h[1000005],cnt,d[1000005],tot,rk[1000005];\nstruct ll\n{\n\tlong long nx;\n\tlong long to;\n}a[2000005];\nstruct sp\n{\n\tlong long size;\n\tlong long son;\n\tlong long tid;\n\tlong long de;\n\tlong long top;\n\tlong long f;\n}t[1000005];\nstruct xds\n{\n\tlong long l;\n\tlong long r;\n\tlong long s;\n\tlong long m;//\u7ef4\u62a4\u6700\u5de6\u7aef\u9ed1\u70b9\n}xd[4000005];\nvoid ad(long long x,long long y)\n{\n\ta[++cnt].nx=h[x];\n\ta[cnt].to=y;\n\th[x]=cnt;\n}\nvoid dfs(long long x,long long fa)\n{\n\tlong long i,j;\n\tfor(i=h[x];i;i=a[i].nx)\n\t{\n\t\tj=a[i].to;\n\t\tif(j==fa)\n\t\tcontinue;\n\t\tt[j].de=t[x].de+1;\n\t\tt[j].f=x;\n\t\tt[j].size=1;\n\t\tdfs(j,x);\n\t\tt[x].size+=t[j].size;\n\t\tif(!t[x].son||t[j].size>t[t[x].son].size)\n\t\tt[x].son=j;\n\t}\n}\nvoid dfs1(long long x,long long tp)\n{\n\tlong long i,j;\n\tt[x].top=tp;\n\tt[x].tid=++tot;\n\trk[tot]=x;\n\tif(t[x].son)\n\tdfs1(t[x].son,tp);\n\tfor(i=h[x];i;i=a[i].nx)\n\t{\n\t\tj=a[i].to;\n\t\tif(j==t[x].f||j==t[x].son)\n\t\tcontinue;\n\t\tdfs1(j,j);\n\t}\n}\nvoid up(long long v)\n{\n\txd[v].s=xd[v<<1].s|xd[v<<1|1].s;\n\tif(xd[v<<1].m)//\u5148\u5224\u5de6\u8fb9\n\txd[v].m=xd[v<<1].m;\n\telse if(xd[v<<1|1].m)xd[v].m=xd[v<<1|1].m;\n\telse xd[v].m=0;\n}\nvoid bd(long long v,long long l,long long r)\n{\n\tlong long mid;\n\txd[v].l=l;\n\txd[v].r=r;\n\tif(l==r)return ;\n\tmid=l+r>>1;\n\tbd(v<<1,l,mid);\n\tbd(v<<1|1,mid+1,r);\n\tup(v);\n}\nvoid xg(long long v,long long x)\n{\n\tif(x>xd[v].r||x<xd[v].l)\n\treturn ;\n\tif(xd[v].l==xd[v].r)\n\t{\n\t\txd[v].s^=1;\n\t\tif(xd[v].s)\n\t\txd[v].m=xd[v].l;\n\t\telse xd[v].m=0;\n\t\treturn ;\n\t}\n\txg(v<<1,x);\n\txg(v<<1|1,x);\n\tup(v);\n}\nlong long ask(long long v,long long l,long long r)\n{\n\tint ls,rs;\n\tif(l>xd[v].r||r<xd[v].l)\n\treturn 0;\n\tif(l<=xd[v].l&&r>=xd[v].r)\n\treturn xd[v].m;\n\tls=ask(v<<1,l,r);\n\trs=ask(v<<1|1,l,r);\n\tif(ls)\n\treturn ls;\n\treturn rs;\n}\nlong long ASK(long long x)\n{\n\tlong long i,j,fx,an=0;\n\tfx=t[x].top;\n\twhile(fx)\n\t{\n\t\tif(i=ask(1,t[fx].tid,t[x].tid))\n\t\tan=i;//\u5982\u679c\u4e0d\u4e3a0\u5c31\u53d6\u6700\u540e\u4e00\u6b21\u7b54\u6848\n\t\tx=t[fx].f;\n\t\tfx=t[x].top;\n\t}\n\tif(i=ask(1,1,t[x].tid))\n\tan=i;\n\tif(!an&&!i)\n\treturn -1;\n\treturn rk[an];\n}\nint main()\n{\n\tlong long i,j,x,y,z;\n\tchar c;\n\tcin>>n>>m;\n\tfor(i=1;i<n;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tad(x,y);\n\t\tad(y,x);\n\t}\n\tdfs(1,0);\n\tdfs1(1,1);\n\tbd(1,1,n);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tcin>>x>>y;\n\t\tif(x)\n\t\tcout<<ASK(y)<<'\\n';\n\t\telse xg(1,t[y].tid);\n\t}\n\treturn 0;\n}\n```\n\n\u7ebf\u6bb5\u6811\u8dd1\u8d77\u6765\u80af\u5b9a\u4f1a\u6162\u4e00\u70b9,\u4f46\u601d\u7ef4\u96be\u5ea6\u4e0d\u9ad8,\n~~\u5199\u5f97\u719f\u7ec3\u7684\u8bdd\u5199\u8d77\u6765\u4e5f\u662f\u5f88\u5feb\u7684~~",
        "postTime": 1566703473,
        "uid": 110857,
        "name": "\u4e9a\u7531\u4e9a\u7531",
        "ccfLevel": 0,
        "title": "P4116 Qtree3"
    },
    {
        "content": "update:\u6211\u8ddf\u5176\u4ed6\u9898\u89e3\u7684\u505a\u6cd5\u4e0d\u4e00\u6837\u554a\uff0c\u5176\u4ed6\u9898\u89e3\u90fd\u7ef4\u62a4\u4e86 dfs \u5e8f\uff0c\u6211\u7684\u6ca1\u6709\u7ef4\u62a4 dfs \u5e8f\u3002\n\n\u91cd\u94fe\u5256\u5206\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u6761\u91cd\u94fe\uff0c\u91c7\u7528 `set` \u7ef4\u62a4\u8fd9\u6761\u91cd\u94fe\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u662f\u4ec0\u4e48\u3002\n\n\u5bf9\u4e8e 0 \u64cd\u4f5c\uff1a\u82e5\u6539\u6210\u9ed1\u8272\uff0c\u6211\u4eec\u5728\u8fd9\u6761\u91cd\u94fe\u7684 `set` \u4e2d\u63d2\u5165\u8fd9\u4e2a\u70b9\uff1b\u82e5\u6539\u6210\u767d\u8272\uff0c\u6211\u4eec\u5220\u9664\u8fd9\u4e2a\u70b9\u3002\n\n\u5bf9\u4e8e 1 \u64cd\u4f5c\uff1a\u4e0d\u65ad\u5730\u8df3 `top`\uff0c\u66f4\u65b0\u7b54\u6848\u3002\u6ce8\u610f `v` \u6240\u5728\u91cd\u94fe\u7684 `set` \u4e2d\u6df1\u5ea6\u6700\u5c0f\u7684\u9ed1\u70b9\u53ef\u80fd\u6bd4 `v` \u7684\u6df1\u5ea6\u5927\uff0c\u800c\u8be5\u91cd\u94fe\u6df1\u5ea6\u6700\u5c0f\u7684\u9ed1\u70b9\u6df1\u5ea6\u90fd\u6bd4 `v` \u5927\uff0c\u663e\u7136\u8fd9\u6761\u91cd\u94fe\u5bf9\u7b54\u6848\u6ca1\u6709\u8d21\u732e\u3002\n\n\u53e6\u5916\uff0c\u7531\u4e8e\u67e5\u8be2\u7684\u662f `1` \u5230 `v`\uff0c\u56e0\u6b64\u4e0d\u5fc5\u7ef4\u62a4 dfs \u5e8f\u3002\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<set>\n\nusing namespace std;\n\n#define INF 1000000000\n#define pprint(x) print(x),putchar(' ')\n#define fprint(x) print(x),putchar('\\n')\n\n//#define getchar() (SS == TT && (TT = (SS = BB) + fread(BB,1,1 << 15,stdin),TT == SS) ? EOF : *SS++)\nchar BB[1 << 15],*SS = BB,*TT = BB;\ninline long long read()\n{\n\tlong long x = 0;int f = 1;\n\tchar ch = getchar();\n\tfor(;!isdigit(ch);ch = getchar())\n\t\tif(ch == '-')\n\t\t\tf = -1;\n\tfor(;isdigit(ch);ch = getchar())\n\t\tx = x * 10 + (ch ^ 48);\n\treturn x * f;\n}\nvoid print(long long x)\n{\n\tif(x < 0)\n\t\tputchar('-'),x = -x;\n\tif(x > 9)\n\t\tprint(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int N = 100010;\n\nint dep[N];\nstruct Tree_Partition\n{\n\tstruct edge\n\t{\n\t\tint nxt,to;\n\t}e[N << 1];\n\tint head[N],cnt;\n\tvoid add(int u,int v)\n\t{\n\t\te[++cnt].to = v,e[cnt].nxt = head[u];\n\t\thead[u] = cnt;\n\t}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tadd(u,v),add(v,u);\n\t}\n\tint col[N],f[N],siz[N],son[N],top[N];\n\tstruct cmp{bool operator()(const int &a,const int &b){ return dep[a] < dep[b]; }};\n\tset<int,cmp> s[N];\n\tvoid dfs1(int u,int fa)\n\t{\n\t\tf[u] = fa,dep[u] = dep[fa] + 1,siz[u] = 1;\n\t\tson[u] = 0;\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif(v == fa)\n\t\t\t\tcontinue;\n\t\t\tdfs1(v,u);\n\t\t\tsiz[u] += siz[v];\n\t\t\tif(siz[v] > siz[son[u]])\n\t\t\t\tson[u] = v;\n\t\t}\n\t}\n\tvoid dfs2(int u,int t)\n\t{\n\t\ttop[u] = t;\n\t\tif(!son[u])\n\t\t\treturn;\n\t\tdfs2(son[u],t);\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].to;\n\t\t\tif(v == f[u] || v == son[u])\n\t\t\t\tcontinue;\n\t\t\tdfs2(v,v);\n\t\t}\n\t}\n\tvoid change(int u)\n\t{\n\t\tif(col[u] ^= 1)\n\t\t\ts[top[u]].insert(u);\n\t\telse\n\t\t\ts[top[u]].erase(u);\n\t}\n\tint solve(int u)\n\t{\n\t\tint ans = -1;\n\t\twhile(u)\n\t\t{\n\t\t\tint k = *s[top[u]].begin();\n\t\t\tif(s[top[u]].size())\n\t\t\t\tif(dep[k] <= dep[u])\n\t\t\t\t\tans = k;\n\t\t\tu = f[top[u]];\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid init()\n\t{\n\t\tdfs1(1,0);\n\t\tdfs2(1,1);\n\t}\n}T;\n\nint main()\n{\n\tint n = read(),m = read();\n\tfor(int i = 1;i < n;i++)\n\t\tT.add_edge(read(),read());\n\tT.init();\n\twhile(m--)\n\t{\n\t\tint op = read();\n\t\tif(!op)\n\t\t\tT.change(read());\n\t\telse\n\t\t\tfprint(T.solve(read()));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1584497544,
        "uid": 53994,
        "name": "81179332_",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u548c\u5404\u4f4d\u5927\u4f6c\u4e00\u6837\uff0c\u540c\u6837\u8003\u8651\u7528\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u3002\n\n\u7a0d\u6709\u4e0d\u540c\u7684\u662f\uff0c\u6211\u5728tree\u6570\u7ec4\u4e2d\u76f4\u63a5\u8bb0\u5f55\u50a8\u5b58\u7684\u70b9\u7684\u7f16\u53f7\uff0c\u5982\u679c\u5f53\u524d\u70b9\u4e3a\u767d\u8272\uff0c\u7f16\u53f7\u4e3an+1\uff0c\u5426\u5219\u5c31\u662f\u5b83\u672c\u8eab\u7684\u7f16\u53f7\u3002\n\n\u56e0\u4e3a\u57281~v\u7684\u8def\u5f84\u4e0a\u67e5\u8be2\uff0c\u6bcf\u4e00\u79cd\u6df1\u5ea6\u6700\u591a\u53ea\u5bf9\u5e94\u4e00\u4e2a\u70b9\uff0c\u800c\u4e14\u6df1\u5ea6\u8d8a\u6d45\u7684\u70b9\u5728\u8d8a\u4e0a\u65b9\uff0c\u6240\u4ee5\u5c06$dep[n+1]$\u8d4b\u503c\u4e3a\u6781\u5927\u503c\u540e\uff0cpushup\u65f6\u53ea\u9700\u6bd4\u8f83\u5bf9\u5e94\u7684\u4e24\u4e2a\u70b9\u7684\u6df1\u5ea6\u5373\u53ef\u3002\n\n\u8be6\u89c1\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint head[100005],pnt[200005],nxt[200005],f[100005],E=0;\nint son[100005],fa[100005],dep[100005],sz[100005];\nint top[100005],id[100005],cnt=0,mp[100005];\nint tree[400005],lazy[400005];\nconst int INF=1000000000;\nint n,q;\nvoid add_edge(int a,int b)\n{\n\tpnt[E]=b;\n\tnxt[E]=head[a];\n\thead[a]=E++;\n}\nvoid dfs1(int u,int dpth)\n{\n\tint maxson=0;\n\tdep[u]=dpth;\n\tsz[u]=1;\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u])continue;\n\t\tfa[v]=u;\n\t\tdfs1(v,dpth+1);\n\t\tsz[u]+=sz[v];\n\t\tif(sz[v]>maxson)\n\t\t{\n\t\t\tson[u]=v;\n\t\t\tmaxson=sz[v];\n\t\t}\n\t}\n}\nvoid dfs2(int u,int tops)\n{\n\tid[u]=++cnt;\n\tmp[cnt]=u;\n\ttop[u]=tops;\n\tif(!son[u])return;\n\tdfs2(son[u],tops);\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=pnt[i];\n\t\tif(v==fa[u]||v==son[u])continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid pushup(int k)\n{\n\tif(dep[tree[k<<1]]<dep[tree[k<<1|1]])tree[k]=tree[k<<1];else tree[k]=tree[k<<1|1];//\u6bd4\u8f83\u4e24\u70b9\u7684\u6df1\u5ea6\n}\nvoid build(int l,int r,int k)\n{\n\tif(l==r)\n\t{\n\t\ttree[k]=n+1;//\u4fdd\u8bc1\u8def\u5f84\u4e0a\u6709\u9ed1\u8272\u7684\u70b9\u65f6\uff0c\u767d\u8272\u7684\u70b9\u4e0d\u4f1a\u88ab\u53d6\u5230\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,k+k);\n\tbuild(mid+1,r,k+k+1);\n\tpushup(k);\n}\nvoid modify(int l,int r,int k,int pos)\n{\n\tif(l==r)\n\t{\n\t\tif(tree[k]==n+1)\n\t\t{\n\t\t\t//cout<<tree[k]<<endl;\n\t\t\ttree[k]=mp[pos];\n\t\t\t//cout<<tree[k]<<endl<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//cout<<tree[k]<<endl;\n\t\t\ttree[k]=n+1;\n\t\t\t//cout<<tree[k]<<endl<<endl;\n\t\t}\n\t\treturn;\n\t}\n\tint m=(l+r)>>1;\n\tif(pos<=m)modify(l,m,k<<1,pos);\n\telse modify(m+1,r,k<<1|1,pos);\n\tpushup(k);\n}\nint query(int L,int R,int l,int r,int k)\n{\n\tif(L<=l&&r<=R)\n\t{\n\t\treturn tree[k];\n\t}\n\tint m=(l+r)>>1,tmp1=n+1,tmp2=n+1;\n\tif(L<=m)tmp1=query(L,R,l,m,k<<1);\n\tif(R>m)tmp2=query(L,R,m+1,r,k<<1|1);\n\tif(dep[tmp1]<dep[tmp2])return tmp1;\n\treturn tmp2;\n}\nint querychain(int x,int y)\n{\n\tint ans=n+1;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\t//cout<<top[x]<<' '<<x<<' '<<query(id[top[x]],id[x],1,cnt,1)<<endl;\n\t\tint tmp=query(id[top[x]],id[x],1,cnt,1);\n\t\tif(dep[ans]>dep[tmp])ans=tmp;\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tint tmp=query(id[x],id[y],1,cnt,1);\n\tif(dep[ans]>dep[tmp])ans=tmp;\n\treturn ans;\n}\nint main()\n{\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&q);\n\tdep[n+1]=INF;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd_edge(a,b);\n\t\tadd_edge(b,a);\n\t}\n\tdfs1(1,1);\n\tdfs2(1,1);\n\tbuild(1,cnt,1);\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tint opt,x;\n\t\tscanf(\"%d%d\",&opt,&x);\n\t\tif(opt==0)\n\t\t{\n\t\t\tmodify(1,cnt,1,id[x]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint tmp=querychain(1,x);\n\t\t\tif(tmp==n+1)\n\t\t\t{\n\t\t\t\tprintf(\"-1\\n\");//\u8def\u5f84\u4e0a\u6ca1\u6709\u9ed1\u70b9\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",tmp);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1569496618,
        "uid": 34217,
        "name": "Katsura_Hinagiku",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u53d1\u73b0\u9898\u89e3\u533a\u91cc\u7684\u5404\u4f4d\u4f6c\u7684\u601d\u8def\u548c\u6211\u90fd\u4e0d\u592a\u4e00\u6837\uff0c\u4e8e\u662f\u6211\u5c31\u6765~~\u732e\u4e00\u6ce2\u4e11~~\u53d1\u8868\u4e00\u4e0b\u81ea\u5df1\u7684\u601d\u8def\u3002\n\n\u6ce8\u610f\u5230\u8fd9\u9053\u9898\u7684\u8be2\u95ee\u662f\u6bcf\u4e2a\u70b9\u5230\u6811\u4e0a\u4e00\u4e2a\u56fa\u5b9a\u8282\u70b9\u7684\u8def\u5f84\u7684\u76f8\u5173\u4fe1\u606f\uff0c\u56e0\u6b64\u53ef\u4ee5\u6307\u5b9a\u8be5\u56fa\u5b9a\u8282\u70b9\u4e3a\u6839\uff0c\u7136\u540e\u7528\u6811\u94fe\u5256\u5206\u53bb\u7ef4\u62a4\u6bcf\u6761\u94fe\u4e0a\u7684\u4fe1\u606f\u3002\u5982\u679c\u4e0d\u4f1a\u6811\u94fe\u5256\u5206\u2026\u2026\u8bf7\u81ea\u884c\u4e0a\u7f51\u5b66\u4e60\u3002\n\uff08~~\u9003~~\uff09\n\n\u4e8e\u662f\u95ee\u9898\u5c31\u8f6c\u5316\u6210\u7ef4\u62a4\u5e8f\u5217\u7684\u64cd\u4f5c\u3002\u6ce8\u610f\u5230\u6811\u94fe\u5256\u5206\u5728\u5bf9\u8282\u70b9\u8fdb\u884c\u6807\u53f7\u7684\u65f6\u5019\uff0c**\u4efb\u610f\u4e00\u4e2a\u8282\u70b9\u7684\u7f16\u53f7\u4e00\u5b9a\u5c0f\u4e8e\u4e8e\u5176\u4efb\u610f\u4e00\u4e2a\u5b50\u5b59\u7684\u7f16\u53f7**\uff0c\u800c\u6211\u4eec\u8981\u67e5\u8be2\u7684\u5c31\u662f\u8ddd\u79bb\u6839\u7ed3\u70b9\u6700\u8fd1\u7684\u6ee1\u8db3\u67d0\u79cd\u8981\u6c42\u7684\u70b9\uff0c\u6240\u4ee5\u53ef\u4ee5\u7ef4\u62a4**\u6700\u5c0f\u503c**\uff08\u6700\u5c0f\u70b9\u6743\uff09\u3002\n\n\u53ea\u5269\u4e0b\u4e00\u4e2a\u95ee\u9898\u4e86\uff1a\u9ed1\u767d\u70b9\u600e\u4e48\u5904\u7406\uff1f\u8003\u8651\u5230\u7ef4\u62a4\u7684\u662f\u6700\u5c0f\u503c\uff0c\u6240\u4ee5\u53ef\u4ee5\u60f3\u529e\u6cd5\u628a\u4e0d\u7b26\u5408\u8981\u6c42\u7684\u70b9\u7684\u503c\u8bbe\u4e3aINF\uff0c\u5373\uff1a\u6bcf\u6b21\u6539\u53d8\u989c\u8272\u65f6\uff0c\u5982\u679c\u662f\u767d\u53d8\u9ed1\u5c31\u628a\u8be5\u70b9\u7684\u6743\u503c\u5355\u70b9\u4fee\u6539\u4e3a\u8be5\u8282\u70b9\u7684\u7f16\u53f7\u503c\uff0c\u82e5\u4e3a\u9ed1\u53d8\u767d\u5c31\u628a\u8be5\u70b9\u7684\u6743\u503c\u4fee\u6539\u4e3aINF\u3002\u67e5\u8be2\u65f6\u53ea\u9700\u8981\u901a\u8fc7\u67e5\u8be2**\u4ece\u8be5\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u8def\u5f84\u6240\u7ecf\u8fc7\u7684\u6700\u5c0f\u70b9\u6743**\u5373\u53ef\u627e\u5230\u79bb\u6839\u7ed3\u70b9\u6700\u8fd1\u7684\u9ed1\u70b9\u3002\u4e8e\u662f\u672c\u9898\u5c31\u53ef\u4ee5\u7528\u4e00\u4e2a\u6bd4\u8f83\u6a21\u677f\u7684\u6811\u5256\u89e3\u51b3\u4e86\u3002\n\n\u6240\u4ee5\u6574\u4f53\u601d\u8def\u4e3a\uff1a\n\n1. \u9884\u5904\u7406\uff0c\u5f97\u5230\u6811\u5256\u7684\u57fa\u672c\u4fe1\u606f\uff0c\u5982\u8282\u70b9\u7f16\u53f7\uff0c\u6df1\u5ea6\uff0c\u5b50\u6811\u5927\u5c0f\u7b49\u3002\n\n1. \u6784\u5efa\u7ebf\u6bb5\u6811\uff0c\u6bcf\u4e00\u4e2a\u533a\u95f4\u7684\u521d\u59cb\u503c\u8bbe\u4e3aINF\uff08\u521a\u5f00\u59cb\u5168\u4e3a\u767d\u70b9\uff09\n\n1. \u8bfb\u5165\u4fee\u6539\u64cd\u4f5c\uff0c\u6309\u7167\u4e0a\u9762\u7684\u6784\u601d\u8fdb\u884c\u5355\u70b9\u4fee\u6539\uff0c\u6bcf\u6b21\u67e5\u8be2\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u6700\u5c0f\u503c\u3002\n\n\u4e8e\u662f\u5c31\u53ef\u4ee5AC\u4e86\u3002\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include<bits/stdc++.h>//\u4e07\u80fd\u5934\u6587\u4ef6 \n#define INF 0x7fffffff//\u8bbe\u7f6e\u6700\u5927\u503c \nusing namespace std;\ninline void read(int &x)//\u8bfb\u5165\u4f18\u5316 \n{\n\tint w=x=0;\n\tchar ch=0;\n\twhile(ch<'0'||'9'<ch)\n\t\tw|=(ch=='-'),ch=getchar();\n\twhile('0'<=ch&&ch<='9')\n\t\tx=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();\n\tx=w?-x:x;\n}\nconst int N=1e5;\nint n,q,a,b,c;//a,b,c\u662f\u4e0e\u9898\u610f\u65e0\u5173\u7684\u53d8\u91cf\uff0c\u8ba9\u6572\u4ee3\u7801\u65f6\u66f4\u8f7b\u677e \nstruct segtree//\u7ebf\u6bb5\u6811 \n{\n\tint l,r,val;//\u5206\u522b\u4e3a\u5de6\u7aef\u70b9\uff0c\u53f3\u7aef\u70b9\uff0c\u533a\u95f4\u6700\u5c0f\u503c \n}tr[N<<2];\n#define ls tr[id].l\n#define rs tr[id].r\n#define lid id<<1\n#define rid id<<1|1 //\u4e00\u624b\u5b8f\u5b9a\u4e49\u7b80\u5316\u4ee3\u7801 \nint E[N<<1],last,fst[N|1],nxt[N<<1];//\u90bb\u63a5\u8868\u5b58\u6811 \nint fa[N|1],dep[N|1],size[N|1];//\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2\uff0c\u6df1\u5ea6\u4ee5\u53ca\u5b50\u6811\u5927\u5c0f \nint top[N|1],son[N|1],vis[N|1];//\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u6240\u5728\u7684\u91cd\u94fe\u7684\u6700\u9ad8\u70b9\uff0c\u91cd\u513f\u5b50\u7f16\u53f7\n//vis\u8868\u793a\u5f53\u524d\u662f\u9ed1\u70b9\u8fd8\u662f\u767d\u70b9\uff081\uff1a\u9ed1\uff1b0\uff1a\u767d\uff09 \nint cnt,name[N|1],node[N|1];//\u8bb0\u5f55\u70b9\u7684\u7f16\u53f7\uff0c\u7f16\u53f7\u6240\u5bf9\u5e94\u7684\u7ed3\u70b9 \nvoid add(int x,int y)//\u52a0\u8fb9 \n{\n\tE[++last]=y,nxt[last]=fst[x],fst[x]=last;\n}\nvoid pre(int x)//\u6811\u94fe\u5256\u5206\u7b2c\u4e00\u6b21dfs \n{\n\tdep[x]=dep[fa[x]]+1,size[x]=1;\n\tfor(int i=fst[x];i;i=nxt[i])\n\t\tif(E[i]^fa[x])//\u76f8\u5f53\u4e8eE[i]!=fa[x] \n\t\t{\n\t\t\tfa[E[i]]=x,pre(E[i]),size[x]+=size[E[i]];\n\t\t\tif(size[son[x]]<size[E[i]])\n\t\t\t\tson[x]=E[i];\n\t\t}\n}\nvoid dfs(int x,int up)//\u6811\u94fe\u5256\u5206\u7b2c\u4e8c\u6b21dfs \n{\n\ttop[x]=up,name[x]=++cnt,node[cnt]=x;//\u8bb0\u5f55 \n\tif(son[x])\n\t\tdfs(son[x],up);\n\tfor(int i=fst[x];i;i=nxt[i])\n\t\tif(E[i]^fa[x]&&E[i]^son[x])\n\t\t\tdfs(E[i],E[i]);\n}\nvoid build(int x,int y,int id)//\u5efa\u7acb\u7ebf\u6bb5\u6811 \n{\n\tls=x,rs=y,tr[id].val=INF;\t\n\tif(x==y)\n\t\treturn;\n\tint mid=(x+y)>>1;\n\tbuild(x,mid,lid),build(mid+1,y,rid);\n}\nvoid modify(int x,int y,int id)//\u5355\u70b9\u4fee\u6539 \n{\n\tif(ls==rs)\n\t{\n\t\ttr[id].val=y;\n\t\treturn;\n\t}\n\tint mid=(ls+rs)>>1;\n\tif(x<=mid)\n\t\tmodify(x,y,lid);\n\telse\n\t\tmodify(x,y,rid);\n\ttr[id].val=min(tr[lid].val,tr[rid].val);\n}\nint query(int x,int y,int id)//\u533a\u95f4\u67e5\u8be2\u6700\u5c0f\u503c \n{\n\tif(x<=ls&&rs<=y)\n\t\treturn tr[id].val;\n\tint mid=(ls+rs)>>1,res=INF;\n\tif(x<=mid)\n\t\tres=min(res,query(x,y,lid));\n\tif(y>mid)\n\t\tres=min(res,query(x,y,rid));\n\treturn res;\n}\nint ask(int x,int y)//\u6811\u94fe\u5256\u5206\u67e5\u8be2\u94fe\u4e0a\u6700\u5c0f\u503c \n{\n\tint res=INF;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tres=min(res,query(name[top[x]],name[x],1));\n\t\tx=fa[top[x]];\n\t}\n\tif(name[x]>name[y])\n\t\tswap(x,y);\n\treturn min(res,query(name[x],name[y],1));\n}\nint main()\n{\n\tread(n),read(q);\n\tfor(int i=1;i<n;++i)\n\t\tread(a),read(b),add(a,b),add(b,a);\n\tpre(1),dfs(1,1),build(1,n,1);\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tread(a),read(b);\n\t\tif(a)\n\t\t{\n\t\t\tc=ask(1,b);//\u5148\u628a\u6700\u5c0f\u503c\u8bb0\u5f55\u4e0b\u6765 \n\t\t\tif(c==INF)//\u8bf4\u660e\u6ca1\u6709\u9ed1\u70b9 \n\t\t\t\tprintf(\"-1\\n\");\n\t\t\telse//\u4e00\u5b9a\u662f\u8f93\u51fanode\uff08\u522b\u95ee\u6211\u4e3a\u4ec0\u4e48\u8981\u5f3a\u8c03\u8fd9\u4e00\u70b9\uff09 \n\t\t\t\tprintf(\"%d\\n\",node[c]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tb=name[b];//\u5148\u53d8\u6210\u7ed3\u70b9\u7f16\u53f7 \n\t\t\tif(!vis[b])//\u672c\u6765\u662f\u767d\u70b9\uff0c\u6539\u4e3a\u8282\u70b9\u7f16\u53f7 \n\t\t\t\tmodify(b,b,1),vis[b]=1;\n\t\t\telse//\u672c\u6765\u662f\u9ed1\u70b9\uff0c\u6539\u4e3aINF \n\t\t\t\tmodify(b,INF,1),vis[b]=0;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u4e8e\u662f\u5c31AC\u4e86\u3002\u8c22\u8c22\u8bfb\u8005\u80fd\u770b\u5230\u6700\u540e\uff01",
        "postTime": 1564650532,
        "uid": 116293,
        "name": "SammyChu",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "# Qtree3\u9898\u89e3\n\n\u4e0b\u5348\u60f3\u9893\u5e9f\u9893\u5e9f\u6253\u4e00\u6ce2\u6811\u5256  \n\u53d1\u73b0\u7ebf\u6bb5\u6811\u7ef4\u62a4\u9ebb\u70e6  \n\u4e8e\u662f\u679c\u65ad\u5206\u5757  \n\u5206\u5757\u771f\u7537\u4eba  \n\u7136\u540e\u53d1\u73b0\u5206\u5757\u901f\u5ea6\u8fd9\u4e48\u5feb   \n\u5c31\u5361\u4e86\u4e00\u6ce2\u5e38   \n\u5206\u5757\u5927\u6cd5\u543c\u554a\uff01\uff01\uff01   \nluogu\u7684O2\u662f\u53cd\u4f18\u5316   \n\n\u7531\u4e8e\u662f\u5904\u7406\u4e00\u6761\u94fe\u4e0a\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u5c3d\u529b\u5bfb\u627edfs\u5e8f\u6700\u5c0f\u7684\u4e00\u4e2a\u5c31\u597d\u5566\n\u6bcf\u4e2a\u5757\u7ef4\u62a4\u4e00\u4e2a`MIN`\u8868\u793a\u6700\u201c\u5de6\u201d\u7684\u4e00\u4e2a\u70b9\u7684dfn\uff0c\u6bcf\u6b21\u67e5\u8be2\u5206\u5757\u5957\u8def\uff0c\u5206\u4e09\u6bb5\u5904\u7406\uff0c\u6bcf\u6b21\u4fee\u6539\u7684\u4e5f\u662f\u6bd4\u8f83\u5957\u8def\u7684...\u5982\u679c\u7279\u5224`col == 1`\u7684\u8bdd\u4f1a\u5feb\u4e00\u70b9\u3002\u6709\u5c11\u91cf\u6ce8\u91ca\nQwQ\n\n```cpp\n// by kririae\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100005;\n\nnamespace IO\n{\ninline char gc()\n{\n  static char buf[1 << 18], *fs, *ft;\n  return (fs == ft && (ft = (fs = buf) + fread(buf, 1, 1 << 18, stdin)), fs == ft) ? EOF : *fs++;\n}\ninline int read()\n{\n  register int k = 0, f = 1;\n  register char c = gc();\n  for (; !isdigit(c); c = gc()) if (c == '-') f = -1;\n  for (; isdigit(c); c = gc()) k = (k << 3) + (k << 1) + (c - '0');\n  return k * f;\n}\n}\n\nnamespace Qtree3\n{\nint head[maxn], ver[maxn << 1], next[maxn << 1], tot;\nint siz[maxn], son[maxn], fa[maxn], dep[maxn], id[maxn], top[maxn], col[maxn], rev[maxn], cnt;\nint bs, sc, L[maxn], R[maxn], MIN[maxn], belong[maxn]; // block_size, size_count\nint n, q, op, val;\n\ninline void addedge(register int from, register int to)\n{\n  ver[++tot] = to, next[tot] = head[from], head[from] = tot;\n}\ninline void dfs1(int k)\n{\n  siz[k] = 1, son[k] = 0;\n  for (register int i = head[k]; i; i = next[i])\n  {\n    int to = ver[i];\n    if(to == fa[k]) continue;\n    fa[to] = k, dep[to] = dep[k] + 1;\n    dfs1(to);\n    if(siz[to] > siz[son[k]]) son[k] = to;\n    siz[k] += siz[to];\n  }\n}\ninline void dfs2(int k, int topf)\n{\n  id[k] = ++cnt, rev[cnt] = k, col[cnt] = 0, top[k] = topf;\n  if(!son[k]) return;\n  dfs2(son[k], topf);\n  for (register int i = head[k]; i; i = next[i])\n  {\n    int to = ver[i];\n    if(to == fa[k] || to == son[k]) continue;\n    dfs2(to, to);\n  }\n}\ninline void init()\n{\n  dfs1(1), dfs2(1, 1);\n  bs = sqrt(n);\n  sc = n % bs == 0 ? n / bs : n / bs + 1;\n  for (register int i = 1; i <= sc; ++i)\n    L[i] = R[i - 1] + 1, R[i] = L[i] + bs - 1, MIN[i] = 1e9;\n  R[sc] = n;\n  for (register int i = 1; i <= sc; ++i)\n    for (register int j = L[i]; j <= R[i]; ++j)\n      belong[j] = i;\n}\ninline void modify(register int pos)\n{\n  // \u5c06id[pos]\u8f6c\u5316\u4e3a\u76f8\u53cd\u7684\u989c\u8272\uff0c\u7136\u540e\u91cd\u7f6e\u5f53\u524d\u5757\u7684\u4fe1\u606f\n  int bl = belong[pos];\n  col[pos] = 1 - col[pos];\n  if(col[pos] == 1) return MIN[bl] = min(MIN[bl], pos), void();\n  else { \n    for (register int i = L[bl]; i <= R[bl]; ++i)\n      if(col[i] == 1) return MIN[bl] = i, void(); // \u6c42\u51fa\u6700\u6d45\u7684\u5757\n  }\n}\ninline int query(register int l, register int r)\n{\n  // \u5206\u6210\u4e09\u90e8\u5206\u5904\u7406...\n  if(l > r) swap(l, r);\n  if(belong[l] == belong[r]) \n  {\n    for (int i = l; i <= r; ++i) if(col[i]) return i;\n    return 1e9;\n  }\n  for (register int i = l; i < L[belong[l] + 1]; ++i) if(col[i]) return i;\n  for (register int i = belong[l] + 1; i <= belong[r] - 1; ++i) if(MIN[i] != 1e9) return MIN[i];\n  for (register int i = L[belong[r]]; i <= r; ++i) if(col[i]) return i;\n  return 1e9;\n  // \u5df2\u7ecf\u5c3d\u529b\u8fd4\u56de\u6700\u5c0f\u7684\u4e86\u554aQAQ\n}\ninline int qtree(int x)\n{\n  int ans = 1e9;\n  while(top[x] != top[1])\n  {\n    ans = min(ans, query(id[top[x]], id[x]));\n    x = fa[top[x]];\n  }\n  ans = min(ans, query(id[1], id[x]));\n  return ans >= 1e9 ? -1 : rev[ans];\n}\ninline void mtree(int pos)\n{\n  modify(id[pos]);\n}\ninline void solve()\n{\n  using namespace IO;\n  n = read(), q = read();\n  register int x, y;\n  for (register int i = 1; i < n; ++i)\n    x = read(), y = read(), addedge(x, y), addedge(y, x);\n  init();\n  while(q--)\n  {\n    op = read();\n    switch(op)\n    {\n      case 0: x = read(), mtree(x); break;\n      case 1: x = read(), printf(\"%d\\n\", qtree(x)); break;\n    }\n  }\n}\n}\n\nint main()\n{\n  return Qtree3::solve(), 0;\n}\n```",
        "postTime": 1532331566,
        "uid": 63667,
        "name": "kririae",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u5176\u5b9e\u53ef\u4ee5\u4e0d\u7528\u7ef4\u62a4\u90a3\u4e48\u591a\u4e71\u4e03\u516b\u7cdf\u7684\u4e1c\u897f\n\n\u7ef4\u62a4$\\min$\u5c31\u53ef\u4ee5\u4e86\n\n\u56e0\u4e3a\u767d\u70b9\u6211\u4eec\u4e0d\u9700\u8981\u77e5\u9053\u4ed6\u5728\u54ea\uff0c\u6240\u4ee5\u6211\u4eec\u628a\u767d\u70b9\u8bbe\u6210inf\n\n\u5bf9\u4e8e\u9ed1\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u4ed6\u5f53\u6210\u4e00\u4e2a\u6743\u503c\u4e3adfn[x]\u7684\u70b9\uff0c\u5176\u4e2ddfn[x]\u8868\u793a\u539f\u6765\u7f16\u53f7\u4e3ax\u7684\u70b9\u91cd\u65b0\u6807\u53f7\u4e4b\u540e\u7684\u7f16\u53f7\n\n\u56e0\u4e3a\u7b54\u6848\u95ee\u7684\u662f1\u5230v\u7684\u8def\u5f84\uff0c\u4ece\u6839\u8282\u70b9\u5230\u4e00\u4e2a\u70b9\u7684\u8def\u5f84\u4e0adfn\u4e00\u5b9a\u662f\u9012\u589e\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u6811\u5256\u7ef4\u62a4\u8def\u5f84\u4e0a\u7684\u6700\u5c0f\u503c\u5c31\u53ef\u4ee5\u4e86\n\n\u7b54\u6848\u518d\u53d6\u4e00\u4e2aredf\u5c31\u53ef\u4ee5\u4e86\uff0credf[x]\u8868\u793adfn\u4e3ax\u7684\u70b9\u539f\u6765\u7684\u6807\u53f7\u662f\u591a\u5c11\n\n~~\u597d\u4e45\u6ca1\u6709\u5199\u8fc7\u8fd9\u4e48\u77ed\u7684\u6811\u5256\u4e86~~\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\n\n# define Rep(i,a,b) for(int i=a;i<=b;i++)\n# define _Rep(i,a,b) for(int i=a;i>=b;i--)\n# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)\n# define debug puts(\"QAQ\");\n\ntypedef long long ll;\nconst int N=1e5+5;\nconst int mod=1e9+7;\nconst double eps=1e-7;\n\ntemplate <typename T> void read(T &x){\n\tx=0;int f=1;\n\tchar c=getchar();\n\tfor(;!isdigit(c);c=getchar())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';\n\tx*=f;\n}\n\nint n,q;\nint head[N],cnt;\nint faz[N],son[N],dep[N],siz[N],top[N],dfn[N],redf[N],tot;\nbool col[N];\n\nstruct Edge{\n\tint to,next;\n}e[N<<1];\n\nvoid add(int x,int y){\n\te[++cnt]=(Edge){y,head[x]},head[x]=cnt;\t\n}\n\n# define lc (u<<1)\n# define rc (u<<1|1)\n\nstruct segment_tree{\n\tint l,r,_min;\n}seg[N<<2];\n\nvoid build(int u,int l,int r){\n\tseg[u].l=l,seg[u].r=r;\n\tseg[u]._min=1e9;\n\tif(l==r)return;\n\tint mid=l+r>>1;\n\tbuild(lc,l,mid);\n\tbuild(rc,mid+1,r);\t\n}\n\nvoid update(int u,int x,int k){\n\tif(seg[u].l==seg[u].r){\n\t\tseg[u]._min=k;\n\t\treturn;\n\t}\n\tint mid=seg[u].l+seg[u].r>>1;\n\tif(x<=mid)update(lc,x,k);\n\telse update(rc,x,k);\n\tseg[u]._min=min(seg[lc]._min,seg[rc]._min);\n}\n\nint query(int u,int l,int r){\n\tif(seg[u].l>=l&&seg[u].r<=r)return seg[u]._min;\n\tint mid=seg[u].l+seg[u].r>>1;\n\tif(r<=mid)return query(lc,l,r);\n\tif(l>mid)return query(rc,l,r);\n\treturn min(query(lc,l,r),query(rc,l,r));\t\n}\n\nint RouteQueryMin(int x,int y){\n\tint res=1e9;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tres=min(res,query(1,dfn[top[x]],dfn[x]));\n\t\tx=faz[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tres=min(res,query(1,dfn[x],dfn[y]));\n\treturn res<1e9?redf[res]:-1;\n}\n\nvoid dfs1(int u,int fa){\n\tfaz[u]=fa;\n\tsiz[u]=1;\n\tdep[u]=dep[fa]+1;\n\tRepG(i,u){\n\t\tint v=e[i].to;\n\t\tif(v==fa)continue;\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]])son[u]=v;\n\t}\n}\n\nvoid dfs2(int u,int _top){\n\ttop[u]=_top;\n\tdfn[u]=++tot;\n\tredf[tot]=u;\n\tif(!son[u])return;\n\tdfs2(son[u],_top);\n\tRepG(i,u){\n\t\tint v=e[i].to;\n\t\tif(v==faz[u]||v==son[u])continue;\n\t\tdfs2(v,v);\n\t}\n}\n\nint main()\n{\tmemset(head,-1,sizeof(head));\n\tread(n),read(q);\n\tRep(i,1,n-1){\n\t\tint x,y;\n\t\tread(x),read(y);\n\t\tadd(x,y),add(y,x); \n\t}\n\tdfs1(1,0),dfs2(1,1);\n\tbuild(1,1,n);\n\twhile(q--){\n\t\tint opt,x;\n\t\tread(opt),read(x);\n\t\tif(!opt)update(1,dfn[x],col[x]?1e9:dfn[x]),col[x]^=1;\n\t\telse printf(\"%d\\n\",RouteQueryMin(1,x));\t\n\t}\n\treturn 0;\n}\n\n```\n",
        "postTime": 1582361746,
        "uid": 97344,
        "name": "devout",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u9996\u5148\u53cc\u500d\u7ecf\u9a8c\uff1a\u6709\u4e00\u9053\u7a0d\u5fae\u6539\u4e00\u4e0b\u5c31\u53ef\u4ee5A\u6389\u7684\uff1a\nP4092 [HEOI2016/TJOI2016]\u6811 \n\n\u4f9d\u7136\u662f\u5728\u91cd\u94fe\u4e0a\u4e8c\u5206\u7684\u5927\u66b4\u529b\u505a\u6cd5...\n\n\u8c8c\u4f3c\u5f88\u591a\u5927\u4f6c\u662fset\u3001priority_queue\u7684\u505a\u6cd5\n\n\u90a3\u79cd\u91cc\u5c31\u6765\u4e00\u53d1\u7ebf\u6bb5\u6811\u7684\u505a\u6cd5\n\n\u50cf\u4e00\u822c\u7684\u6811\u5256\u4e00\u6837\u7ebf\u6bb5\u6811\u7ef4\u62a4\u91cd\u94fe\u4e0a\u7684\u4fe1\u606f\n\n\u8fd9\u91cc\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u548c\uff0c\u5e76\u652f\u6301\u5355\u70b9\u66f4\u6539\n\n1\u4ee3\u8868\u9ed1\uff0c0\u4ee3\u8868\u767d\n\n\u663e\u7136\u5bf9\u4e8e\u6811\u4e0a\u67d0\u4e00\u6bb5\u94fe\uff0c\u5982\u679c\u5176\u4e2dsum>0,\u8bf4\u660e\u5176\u4e2d\u6709\u9ed1\u8272\u7684\u70b9\uff0c\u7136\u540e\u663e\u7136\u8981\u9009\u6df1\u5ea6\u6700\u5c0f\u7684\u9ed1\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4e8c\u5206\u5373\u53ef\uff0c\u5982\u679c\u5728mid\u4e0a\u9762\u6709\u9ed1\u70b9\uff08sum>0\uff09\u90a3\u5c31\u5728\u4e0a\u9762\u4e00\u6bb5\u67e5\u627e\uff0c\u5426\u5219\u5728\u4e0b\u9762\u4e00\u6bb5\u67e5\u627e...\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u91cc\u8981\u6c421~v\u7684\u9ed1\u70b9\uff0c\u4e5f\u5c31\u662f\u79bb1\u6700\u8fd1\u7684\u70b9...\u521a\u5f00\u59cb\u53bb\u6c42\u79bbv\u6700\u8fd1\u7684\u9ed1\u70b9\u4e86...WA0\u5206\u4e86\u597d\u591a\u6b21\n\n\u603b\u4f53\u65f6\u95f4\u590d\u6742\u5ea6$O(nlog^{2}n)$\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#define writeln(x)  write(x),puts(\"\")\nusing namespace std;\ninline int read(){\n\tint ans=0,f=1;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-') f=-1;chr=getchar();}\n\twhile(isdigit(chr)){ans=(ans<<3)+(ans<<1)+chr-48;chr=getchar();}\n\treturn ans*f;\n}void write(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}const int M=100005;char opt[2];\nint head[M<<1],ver[M<<1],x,y,nxt[M<<1],tot,n,m,dep[M],fa[M],tp[M],sz[M],son[M],idx[M],s[M<<2],rk[M];\ninline void add(int x,int y){ver[++tot]=y,nxt[tot]=head[x],head[x]=tot;}\nvoid dfs1(int x,int f){\n\tsz[x]=1;dep[x]=dep[f]+1,fa[x]=f;\n\tfor(register int i=head[x];i;i=nxt[i]){\n\t\tif(!dep[ver[i]]){\n\t\t\tdfs1(ver[i],x),sz[x]+=sz[ver[i]];\n\t\t\tif(sz[son[x]]<sz[ver[i]]) son[x]=ver[i];\n\t\t}\n\t}\n}int t;\nvoid dfs2(int x,int topf){\n\tidx[x]=++t;tp[x]=topf;rk[t]=x;\n\tif(!son[x]) return;\n\tdfs2(son[x],topf);\n\tfor(int i=head[x];i;i=nxt[i])\n\t\tif(!idx[ver[i]]) dfs2(ver[i],ver[i]);\n}\n#define ls (i<<1)\n#define rs (i<<1|1)\n#define mid (l+r>>1)\ninline void Push_Up(int i){s[i]=s[ls]+s[rs];}\nvoid Update(int i,int l,int r,int pos,int x){\n\tif(l==r){s[i]^=1;return;}\n\tif(pos<=mid) Update(ls,l,mid,pos,x);\n\telse Update(rs,mid+1,r,pos,x);\n\tPush_Up(i);\n}\nint Query(int i,int l,int r,int ql,int qr){\n\tif(ql<=l&&r<=qr) return s[i];int ans=0;\n\tif(ql<=mid) ans+=Query(ls,l,mid,ql,qr);\n\tif(qr>mid)  ans+=Query(rs,mid+1,r,ql,qr);\n\treturn Push_Up(i),ans;\n}int a[M],L[M],R[M];\ninline void Ask(int x){\n\tint tt=0;\n\twhile(x){\n\t\ta[++tt]=Query(1,1,n,idx[tp[x]],idx[x]);\n\t\tL[tt]=idx[tp[x]];\n\t\tR[tt]=idx[x];//L,R\u8bb0\u5f55\u533a\u95f4\u5de6\u53f3\u7aef\u70b9 \n\t\tx=fa[tp[x]];\n\t}reverse(a+1,a+tt+1);\n\t reverse(L+1,L+tt+1);\n\t reverse(R+1,R+tt+1);//\u56e0\u4e3a\u8981\u6c42\u79bb1\u6700\u8fd1\u7684\u9ed1\u70b9\uff0c\u6240\u4ee5\u8981\u7ffb\u8f6c\u8fc7\u6765 \n\ta[tt+1]=1;int pos=tt+1;\n\tfor(int i=1;i<=tt+1;i++) if(a[i]) {tt=i;break;}//\u627e\u5230\u79bb1\u6700\u8fd1\u7684\u9ed1\u70b9\u6240\u5728\u533a\u95f4 \n\tif(tt==pos) return (void)(puts(\"-1\"));//\u4e0d\u5b58\u5728\u9ed1\u70b9 \n\tint ll=L[tt],rr=R[tt],midd,ans;\n\twhile(ll<=rr){//\u4e8c\u5206\n\t\tmidd=ll+rr>>1;\n\t\tif(Query(1,1,n,ll,midd)) rr=midd-1,ans=midd;\n\t\telse ll=midd+1;\n\t}writeln(rk[ans]);//\u5bf9\u5e94\u56de\u6765 \n}\nint main(){\n\tn=read(),m=read();\n\tfor(register int i=1;i<n;++i)x=read(),y=read(),add(x,y),add(y,x);\n\tdfs1(1,0),dfs2(1,1);\n\twhile(m--){\n\t\tint opt=read(),x=read();\n\t\tif(opt==1)\tAsk(x);\n\t\telse Update(1,1,n,idx[x],1);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1556160819,
        "uid": 9287,
        "name": "LevenKoko",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u8fd9\u9898\u597d\u50cf\u8fd8\u662f\u633a\u7b80\u5355\u7684\n\n\n# noteskey\n\n\u6211\u4eec\u8003\u8651\u6811\u5256\u5904\u7406 top \n\n## update\n\n\u7136\u540e\u6bcf\u6b21\u4e00\u4e2a\u70b9\u66f4\u65b0\u4e86\u5c31\u53bb push \u6216\u8005 erase \u5b83\u7684 top \u8282\u70b9\n\n\u7136\u540e top \u8282\u70b9\u91cc\u9762\u7ef4\u62a4\u7684\u6240\u6709\u8282\u70b9\u6309 dep \u5347\u5e8f\u6392\u5e8f\uff08\u53ef\u4ee5\u7528 **\u5927\u6839\u5806 + pair + dep** \u53d6\u53cd \u5b9e\u73b0\uff09\n\n\n## query\n\n\u6bcf\u6b21\u8be2\u95ee\u6211\u4eec\u4ece\u8be2\u95ee\u70b9 x \u51fa\u53d1\uff0c\u7206\u8df3 top \uff0c\u7136\u540e\u6cbf\u8def\u7ef4\u62a4\u7b54\u6848\uff08\u6ce8\u610f top \u8282\u70b9\u91cc\u9762\u7ef4\u62a4\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u6765\u81ea x \u6240\u5728\u7684\u5b50\u6811\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5224\u65ad top \u8282\u70b9\u5806\u9876\u7684 dep \u662f\u5426\u5c0f\u4e8e x \u7684 dep \uff09\n\n\n# \u5173\u4e8e\u5e26\u5220\u9664 priority_queue\n\n\u5b89\u5229\u535a\u5ba2\uff1a [\u652f\u6301\u5220\u9664\u4efb\u610f\u5143\u7d20\u4ee5\u53ca\u4e00\u4e9b\u5176\u4ed6\u57fa\u672c\u64cd\u4f5c\u7684\u5806](https://www.cnblogs.com/Judge/p/10557516.html)\n\n\u6211\u4eec\u53d1\u73b0\u7528\u4e86\u8fd9\u4e2a\u5b9e\u73b0\u7b80\u5355\u7136\u9e45\u529f\u80fd\u795e\u5947\u7684\u6570\u636e\u7ed3\u6784\u540e\u8fd9\u9053\u9898\u4f1a\u53d8\u7684\u975e\u5e38\u597d\u505a\n\n\uff08\u4f60\u53ef\u80fd\u4f1a\u8bf4\u7528 set \u66f4\u65b9\u4fbf\u4f46\u662f\u6211\u89c9\u5f97\u7528\u5806\u53ef\u80fd\u4f1a\u5feb\u4e9b\uff1f\uff09\n\n# code\n\n```\n//by Judge\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define P pair<int,int>\n#define fp(i,a,b) for(int i=(a),I=(b)+1;i<I;++i)\n#define go(G,u) for(int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)\nusing namespace std;\nconst int M=1e5+3;\ntypedef int arr[M];\ninline int read(){ int x=0,f=1; char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;\n} inline int cread(){ char c=getchar();\n    while(c!='K'&&c!='I'&&c!='O') c=getchar();\n\treturn c=='I'?1:c=='K'?2:3;\n} char sr[1<<21],z[20];int C=-1,Z;\ninline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\ninline void print(int x,char chr='\\n'){\n    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]=chr;\n} int n,m,tim; arr state,siz,dep,fa,son,top;\nstruct Heap{ priority_queue<P> q1,q2;\n\tinline void push(int x){q1.push(P(-dep[x],x));}\n\tinline void erase(int x){q2.push(P(-dep[x],x));}\n\tinline int size(){return q1.size()-q2.size();}\n\tinline void pop(){for(;q2.size()&&q2.top()==q1.top();q1.pop(),q2.pop());q1.pop();}\n\tinline int top(){for(;q2.size()&&q2.top()==q1.top();q1.pop(),q2.pop());return q1.top().second;}\n}q[M];\nstruct Gr{ int pat,head[M];\n    struct Edge{ int to,nxt; }e[M<<1];\n    inline void clear(){ memset(head,0,sizeof head),pat=0; }\n    inline void add(int u,int v){\n        e[++pat]={v,head[u]},head[u]=pat;\n        e[++pat]={u,head[v]},head[v]=pat;\n    }\n}G;\nvoid dfs(int u,int f){ siz[u]=1,dep[u]=dep[f]+1;\n    go(G,u) if(v^f){ fa[v]=u,dfs(v,u);\n\t\tsiz[u]+=siz[v]; if(siz[v]>siz[son[u]]) son[u]=v; }\n}\nvoid dfs(int u){ if(!top[u]) top[u]=u;\n    if(son[u]) top[son[u]]=top[u],dfs(son[u]);\n    go(G,u) if(v^fa[u]&&v^son[u]) dfs(v);\n}\ninline int query(int x){ int ans=-1;\n\tfor(;x;x=fa[top[x]]) if(q[top[x]].size())\n\t\tif(dep[q[top[x]].top()]<=dep[x])\n\t\t\tans=q[top[x]].top(); return ans;\n}\nint main(){ n=read(),m=read(); int op,x,y,z;\n\tfp(i,1,n-1) x=read(),y=read(),G.add(x,y);\n\tfor(dfs(1,0),dfs(1);m;--m){ op=read(),x=read();\n\t\tif(op) print(query(x));\n\t\telse{ state[x]^=1;\n\t\t\tif(state[x]) q[top[x]].push(x);\n\t\t\telse q[top[x]].erase(x);\n\t\t} \n\t}return Ot(),0;\n}\n```",
        "postTime": 1553045138,
        "uid": 38576,
        "name": "J\u03bcdge",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u4e3a\u4ec0\u4e48\u4e0d\u8bd5\u8bd5\u7ef4\u62a4\u91cd\u94fe\u4e0a\u4e00\u4e2a\u70b9\u5230\u94fe\u9876\u7684\u9ed1\u70b9\u4e2a\u6570\u5462QAQ\n\n\u53ef\u4ee5\u7528\u6807\u8bb0\u6c38\u4e45\u5316\u7684\u65b9\u5f0f\u51cf\u5c0f\u5e38\u6570\n\n\u6811\u94fe\u5256\u5206\u7b2c\u4e8c\u4e2aDFS\u4e0d\u4ec5\u53ef\u4ee5\u9884\u5904\u7406\u94fe\u9876\uff0c\u8fd8\u53ef\u4ee5\u9884\u5904\u7406\u94fe\u5e95\n\n\u5728\u6700\u540e\u4e00\u6761\u6709\u9ed1\u70b9\u7684\u91cd\u94fe\u4e0a\u4e8c\u5206\u7b54\u6848\n\n\u8fd9\u6837\u4e00\u4e2a\u4fee\u6539\u64cd\u4f5c\u662f$\\Theta(\\log n)$\u7684\n\n\u4e00\u4e2a\u8be2\u95ee\u64cd\u4f5c\u662f$\\Theta(\\log ^2 n)$\u7684\n\n\u603b\u590d\u6742\u5ea6$\\Theta(q \\log^2 n)$\n\n```cpp\n#include\"cstdio\"\n#include\"cstring\"\n#include\"iostream\"\n#include\"algorithm\"\nusing namespace std;\n\nconst int MAXN=1<<17;\n\nint n,m,np;\nint h[MAXN],sn[MAXN],f[MAXN],siz[MAXN],deg[MAXN];\nint top[MAXN],id[MAXN],dep[MAXN],rid[MAXN];\nbool clr[MAXN];\nint tag[MAXN<<1];\nstruct rpg{\n\tint li,nx;\n}a[MAXN<<1];\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0'||'9'<ch) ch=getchar();\n\twhile('0'<=ch&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x;\n}\n\nvoid add(int ls,int nx)\n{\n\ta[++np]=(rpg){h[ls],nx};h[ls]=np;\n\ta[++np]=(rpg){h[nx],ls};h[nx]=np;\n}\n\nvoid dfs1(int x,int fa,int tp)\n{\n\tf[x]=fa;siz[x]=1;dep[x]=tp;\n\tfor(int i=h[x];i;i=a[i].li){\n\t\tif(a[i].nx==fa) continue;\n\t\tdfs1(a[i].nx,x,tp+1);\n\t\tsiz[x]+=siz[a[i].nx];\n\t\tif(siz[a[i].nx]>siz[sn[x]]) sn[x]=a[i].nx;\n\t}return;\n}\n\nvoid dfs2(int x,int tpx)\n{\n\ttop[x]=tpx;id[x]=++id[0];rid[id[x]]=x;deg[tpx]=x;\n\tif(!sn[x]) return;\n\tdfs2(sn[x],tpx);\n\tfor(int i=h[x];i;i=a[i].li){\n\t\tif(a[i].nx==f[x]||a[i].nx==sn[x]) continue;\n\t\tdfs2(a[i].nx,a[i].nx);\n\t}return;\n}\n\nvoid cchg(int k,int l,int r,int le,int ri,int v)\n{\n\tif(le<=l&&r<=ri){tag[k]+=v;return;}\n\tint i=k<<1,mid=l+r>>1;\n\tif(le<=mid) cchg(i,l,mid,le,ri,v);\n\tif(mid<ri) cchg(i|1,mid+1,r,le,ri,v);\n\treturn;\n}\n\nint cask(int k,int l,int r,int v)\n{\n\tif(l==r) return tag[k];\n\tint i=k<<1,mid=l+r>>1;\n\tif(v<=mid) return cask(i,l,mid,v)+tag[k];\n\treturn cask(i|1,mid+1,r,v)+tag[k];\n}\n\nint csk(int x)\n{\n\tint sx=0;\n\twhile(top[x]!=1){\n\t\tif(cask(1,1,n,id[x])) sx=x;\n\t\tx=f[top[x]];\n\t}if(cask(1,1,n,id[x])) sx=x;\n\tif(!sx) return -1;\n\tint l=id[top[sx]],r=id[sx];\n\twhile(l<r){\n\t\tint mid=l+r>>1;\n\t\tif(cask(1,1,n,mid)) r=mid;\n\t\telse l=mid+1;\n\t}return rid[l];\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;++i){int x=read(),y=read();add(x,y);}\n\tdfs1(1,1,1);dfs2(1,1);\n\twhile(m--){\n\t\tint p=read(),x=read();\n\t\tif(!p) cchg(1,1,n,id[x],id[deg[top[x]]],clr[x]?-1:1),clr[x]^=1;\n\t\telse printf(\"%d\\n\",csk(x));\n\t}return 0;\n}\n\n```",
        "postTime": 1546412068,
        "uid": 31293,
        "name": "Adove",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206 + \u6811\u72b6\u6570\u7ec4 + \u500d\u589e\u3002\n\n\u8003\u8651\u5c06\u627e\u5230 $1 \\rightarrow u$ \u7684\u7b2c\u4e00\u4e2a\u9ed1\u8272\u70b9 $v$ \u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316\u4e00\u4e0b\uff0c\u53ef\u4ee5\u53d8\u6210\u6c42 $1 \\rightarrow u$ \u8fd9\u6761\u8def\u5f84\u4e0a\uff0c\u627e\u5230\u4e00\u4e2a\u6df1\u5ea6\u6700\u6d45\u7684\u70b9 $v$\uff0c\u6ee1\u8db3 $1 \\rightarrow v$ \u8fd9\u6761\u8def\u5f84\u4e0a\u6709\u9ed1\u8272\u8282\u70b9\u3002\n\n\u8fd9\u65f6\u53ef\u4ee5\u5c06\u9ed1\u8272\u8282\u70b9\u7684\u503c\u8d4b\u4e3a $1$\uff0c\u767d\u8272\u8282\u70b9\u7684\u503c\u8d4b\u4e3a $0$\u3002\u90a3\u4e48\u73b0\u5728\u8981\u505a\u7684\uff0c\u5c31\u662f\u627e\u5230\u4e00\u4e2a\u6df1\u5ea6\u6700\u6d45\u7684\u70b9 $v$\uff0c\u6ee1\u8db3 $1 \\rightarrow v$ \u8fd9\u6761\u8def\u5f84\u4e4b\u548c\u5927\u4e8e $0$\u3002\u67e5\u548c\u53ef\u4ee5\u7528\u6811\u5256 + \u6811\u72b6\u6570\u7ec4\u5b9e\u73b0\uff0c\u800c\u5bfb\u627e\u65f6\u53ef\u4ee5\u500d\u589e\u5b9e\u73b0\u3002\n\n\u8fd9\u6837\u5bf9\u4e8e\u6bcf\u6b21\u67e5\u8be2\uff0c\u500d\u589e\u9700\u8981\u82b1\u8d39 $\\log N$\uff0c\u5728\u500d\u589e\u57fa\u7840\u4e0a\u5957\u4e2a\u6811\u5256\uff0c\u53c8\u6765\u4e2a $\\log N$\uff0c\u518d\u5957\u4e2a\u6811\u72b6\u6570\u7ec4\u2026\u2026 \u6700\u574f\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(Q \\log^3 N)$ \u7684\u2026\u2026 \u4f46\u662f\u8fd9\u79cd\u505a\u6cd5\u7684\u5e38\u6570\u6781\u5c0f\uff0c\u5bf9\u4e8e\u672c\u9898\u6700\u5927\u7684\u4e00\u4e2a\u70b9\uff0c\u53ef\u4ee5\u5728 $115 \\text{ms}$ \u5185\u8dd1\u51fa\u7ed3\u679c\u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nconst int MaxN = 100000 + 5;\nconst int MaxQ = 400000 + 5;\nconst int MaxM = 200000 + 5;\nconst int MaxLog = 20;\n\nint N, Q;\nint cntv, cnte;\nint Opt[MaxQ], X[MaxQ];\nint Head[MaxN], To[MaxM], Next[MaxM];\nint fa[MaxLog + 1][MaxN], size[MaxN], depth[MaxN];\nint dfn[MaxN], id[MaxN], wson[MaxN], top[MaxN];\nint Bit[MaxN];\n\ninline void add_edge( int from, int to ) {\n    cnte++; To[cnte] = to;\n    Next[cnte] = Head[from]; Head[from] = cnte;\n}\n\nvoid init() {\n    scanf( \"%d %d\", &N, &Q );\n    for ( int i = 1; i < N; ++i ) {\n        int u, v;\n        scanf( \"%d %d\", &u, &v );\n        add_edge( u, v ); add_edge( v, u );\n    }\n    for ( int i = 1; i <= Q; ++i )\n        scanf( \"%d %d\", &Opt[i], &X[i] );\n}\n\nvoid dfs1( int u ) {\n    size[u] = 1;\n    for ( int i = Head[u]; i; i = Next[i] ) {\n        int v = To[i];\n        if ( v == fa[0][u] ) continue;\n\n        depth[v] = depth[u] + 1;\n        fa[0][v] = u;\n        for ( int j = 1; ( 1 << j ) <= depth[v]; ++j )\n            fa[j][v] = fa[ j - 1 ][ fa[ j - 1 ][v] ];\n\n        dfs1( v );\n        size[u] += size[v];\n\n        if ( size[v] > size[ wson[u] ] ) wson[u] = v;\n    }\n}\n\nvoid dfs2( int u, int chain ) {\n    dfn[++cntv] = u;\n    id[u] = cntv;\n    top[u] = chain;\n\n    if ( wson[u] != 0 ) dfs2( wson[u], chain );\n    for ( int i = Head[u]; i; i = Next[i] ) {\n        int v = To[i];\n        if ( v == fa[0][u] || v == wson[u] ) continue;\n        dfs2( v, v );\n    }\n}\n\ninline int lowbit( int x ) {\n    return x & -x;\n}\n\ninline void update( int x, int v ) {\n    for ( int i = x; i <= N; i += lowbit( i ) )\n        Bit[i] += v;\n}\n\ninline int query( int x ) {\n    int res = 0;\n    for ( int i = x; i > 0; i -= lowbit( i ) )\n        res += Bit[i];\n    return res;\n}\n\ninline int RSQ( int l, int r ) {\n    return query( r ) - query( l - 1 );\n}\n\ninline int Query_path( int u, int v ) {\n    int sum = 0;\n    while ( top[u] != top[v] ) {\n        if ( depth[ top[u] ] < depth[ top[v] ] ) swap( u, v );\n        sum += RSQ( id[ top[u] ], id[u] );\n        u = fa[0][ top[u] ];\n    }\n\n    if ( depth[u] < depth[v] ) swap( u, v );\n    sum += RSQ( id[v], id[u] );\n    return sum;\n}\n\nvoid solve() {\n    dfs1( 1 );\n    dfs2( 1, 1 );\n\n    for ( int q = 1; q <= Q; ++q ) {\n        int opt = Opt[q], u = X[q];\n        if ( opt == 0 ) {\n            int col = RSQ( id[u], id[u] );\n            if ( col == 0 ) update( id[u], 1 );\n            else update( id[u], -1 );\n        } else {\n            if ( Query_path( 1, u ) == 0 ) {\n                printf( \"-1\\n\" );\n                continue;\n            }\n\n            for ( int i = MaxLog; i >= 0; --i ) {\n                int v = fa[i][u];\n                if ( v == 0 ) continue;\n                if ( Query_path( 1, v ) >= 1 ) u = v;\n            }\n            printf( \"%d\\n\", u );\n        }\n    }\n}\n\nint main() {\n    init();\n    solve();\n    return 0;\n}\n```",
        "postTime": 1538476880,
        "uid": 48843,
        "name": "Tweetuzki",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "**Qtree\u7cfb\u5217\u7b2c\u4e09\u9898**\n\n\u8bfb\u5b8c\u9898\u5927\u6982\u4e0d\u96be\u5224\u65ad\u662f\u4e00\u9053\u6811\u5256\u7684\u9898\n\n\u4e0d\u4f1a\u6811\u5256\u4e00\u4e0d\u5c0f\u5fc3\u70b9\u8fdb\u8fd9\u9898\u7684\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u6211\u6709\u5173\u6811\u5256\u7684\u8bb2\u89e3 [\u6811\u94fe\u5256\u5206](https://www.cnblogs.com/hanruyun/p/9577500.html)\n\n\u8fd9\u9053\u9898\u7684\u5173\u952e\u662f\u8bb0\u5f55\u4e24\u79cd\u72b6\u6001\uff0c\u4ee5\u53ca\u9ed1\u70b9\u7684\u5e8f\u53f7\uff08\u4e0d\u662f\u7f16\u53f7\uff09\n\n\u7ebf\u6bb5\u6811\u554a\u5f53\u7136\n\n\u5b9a\u4e49\u4e24\u4e2a\u53d8\u91cfv,f\uff0cv\u8868\u793a\u8ddd\u79bb\u6839\u8282\u70b9\u6700\u8fd1\u7684\u9ed1\u70b9\uff0c\u9ed8\u8ba4-1\uff0cf\u5219\u8868\u793a\u533a\u95f4\u5185\u662f\u5426\u542b\u6709\u9ed1\u70b9\uff0c\u6709\u4e3a1\uff0c\u65e0\u4e3a0\n\n\u90a3\u4e48\uff0c\u600e\u4e48\u624d\u80fd\u53d6\u5f53\u524d\u8def\u5f84\u8ddd\u79bb\u6839\u8282\u70b9\u6700\u8fd1\u7684\u9ed1\u70b9\u7684\u5462\uff1f\u7ebf\u6bb5\u6811\u66f4\u65b0\u65f6\uff0c\u4f18\u5148\u53d6\u5de6\u5b50\u533a\u95f4\u7684\u9ed1\u70b9\uff0c\u540e\u53d6\u53f3\u5b50\u533a\u95f4\uff0c\u66f4\u65b0\u7b54\u6848\u65f6\uff0c\u4f18\u5148\u53d6\u540e\u51fa\u73b0\u7684\u7b54\u6848\n\n\u90a3\u4e48\u76f4\u63a5\u770b\u7a0b\u5e8f\u5427\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cctype>\n#define ll long long\n#define gc() getchar()\n#define maxn 100005\nusing namespace std;\n\ninline ll read(){\n    ll a=0;int f=0;char p=gc();\n    while(!isdigit(p)){f|=p=='-';p=gc();}\n    while(isdigit(p)){a=(a<<3)+(a<<1)+(p^48);p=gc();}\n    return f?-a:a;\n}\nvoid write(ll a){\n    if(a>9)write(a/10);\n    putchar(a%10+'0');\n}\nint n,m;\n\nstruct ahaha1{     //\u524d\u5411\u661f\u5b58\u8fb9\n    int to,next;\n}e[maxn<<1];int head[maxn],tot;\ninline void add(int u,int v){\n    e[tot].to=v;e[tot].next=head[u];head[u]=tot++;\n}\n\nint sz[maxn],dep[maxn],f[maxn],son[maxn];\nvoid dfs(int u,int fa){\n    sz[u]=1;int maxa=0;\n    for(int i=head[u];~i;i=e[i].next){\n        int v=e[i].to;if(v==fa)continue;\n        f[v]=u;dep[v]=dep[u]+1;\n        dfs(v,u);sz[u]+=sz[v];\n        if(maxa<sz[v]){maxa=sz[v];son[u]=v;}\n    }\n}\nint top[maxn],in[maxn],b[maxn];\nvoid dfs(int u,int fa,int topf){\n    in[u]=++tot;top[u]=topf;b[tot]=u;\n    if(!son[u])return;\n    dfs(son[u],u,topf);\n    for(int i=head[u];~i;i=e[i].next){\n        int v=e[i].to;if(v==fa||v==son[u])continue;\n        dfs(v,u,v);\n    }\n}\n\n#define lc p<<1\n#define rc p<<1|1\nstruct ahaha2{\n    int v;bool f;\n    ahaha2(){v=-1;}   //v\u7684\u521d\u59cb\u503c\u4e3a-1\n}t[maxn<<2];\ninline void pushup(int p){\n    t[p].f=t[lc].f|t[rc].f;   //\u82e5\u5de6\u53f3\u5b50\u533a\u95f4\u4e2d\u542b\u6709\u9ed1\u70b9\uff0c\u5219\u5f53\u524d\u533a\u95f4\u542b\u6709\u9ed1\u70b9\n    t[p].v=t[lc].f?t[lc].v:(t[rc].f?t[rc].v:-1);    //\u4f18\u5148\u53d6\u5de6\u5b50\u533a\u95f4\u7684\u9ed1\u70b9\uff0c\u4f7f\u8ddd\u79bb\u6839\u8282\u70b9\u5c3d\u53ef\u80fd\u8fd1\n}\nvoid update(int p,int l,int r,int L){\n    if(l==r){t[p].f^=1;t[p].v=t[p].f?b[l]:-1;return;}    //\u82e5\u6539\u53d8\u540e\u4e3a\u9ed1\u70b9\uff0c\u5219\u8d4b\u503c\u4e3a\u8282\u70b9\u5e8f\u53f7\uff0c\u5426\u5219\u91cd\u7f6e\n    int m=l+r>>1;\n    if(L<=m)update(lc,l,m,L);\n    else update(rc,m+1,r,L);\n    pushup(p);\n}\nint query(int p,int l,int r,int L,int R){\n    if(l>R||r<L)return -1;\n    if(L<=l&&r<=R)return t[p].v;\n    int m=l+r>>1,l1=query(lc,l,m,L,R),r1=query(rc,m+1,r,L,R);    //\u4f18\u5148\u53d6\u5de6\u5b50\u533a\u95f4\n    return l1==-1?r1:l1;\n}\n\ninline void solve_1(){\n    int x=read();\n    update(1,1,n,in[x]);\n}\ninline void solve_2(){\n    int x=read(),ans=-1,p;     //ans\u4f18\u5148\u53d6\u540e\u51fa\u73b0\u7684\u7684\u7b54\u6848\n    while(top[x]!=1){\n    \tp=query(1,1,n,in[top[x]],in[x]);\n    \tans=(p==-1?ans:p);\n    \tx=f[top[x]];\n    }\n    p=query(1,1,n,1,in[x]);\n    ans=(p==-1?ans:p);\n    if(ans<0)putchar('-'),ans=-ans;\n    write(ans);putchar('\\n');\n}\n\nint main(){memset(head,-1,sizeof head);\n    n=read();m=read();\n    for(int i=1;i<n;++i){\n        int x=read(),y=read();\n        add(x,y);add(y,x);\n    }\n    tot=0;dfs(1,-1);dfs(1,-1,1);\n    for(int i=1;i<=m;++i){\n        int z=read();\n        switch(z){\n            case 0:solve_1();break;\n            case 1:solve_2();break;\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1532602431,
        "uid": 34530,
        "name": "\u5b50\u8c26\u3002",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "```\n//\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u4e0b\u9762\u90a3\u6bb5\u533a\u95f4\u7684\u9ed1\u8272\u7684\u6df1\u5ea6\u6700\u6d45\u7684\u70b9\u662f\u8c01\n//\u4fee\u6539\u5230\u53f6\u5b50\u8282\u70b9\uff0c\u76f4\u63a5\u4fee\u6539\uff0cpushup\u7684\u65f6\u5019\u5728\u5de6\u53f3\u513f\u5b50\u91cc\u53d6\u4e2a\u6700\u4f18\u7684\n\n//\u4e24\u5929\u6ca1\u505a\u6709\u4e9b\u751f\u758f\u4e86\n//update\u7684\u65f6\u5019\u4f4d\u7f6e\u76f4\u63a5\u4f20\u7684v\uff0c\u5e94\u8be5\u662fnode[v].s\uff0c\n//\u56e0\u4e3a\u627e\u7684\u662fv\u8fd9\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\n//\u8fd8\u8981\u4f20\u4e00\u4e0bv\u7b49\u4e8e\u51e0\n//node[v].s\u662f\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\uff0cv\u662f\u8981\u6539\u7684\u8282\u70b9\u7684\u6807\u53f7 \n\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5+5;\n\nint n,m;\nint head[N],num_edge;\nstruct Edge\n{\n\tint v,nxt;\n}edge[N<<1];\nstruct NODE\n{\n\tint fa,son;\n\tint size,dep;\n\tint top;\n\tint s,t;\n}node[N];\nstruct TREE\n{\n\tTREE *lson,*rson;\n\tint l,r,mid;\n\tint num,col;\n}tree[N<<2];\n\ntypedef TREE* Tree;\nTree Root,now_node=tree;\n\ninline int read()\n{\n\tchar c=getchar();int num=0;\n\tfor(;!isdigit(c);c=getchar());\n\tfor(;isdigit(c);c=getchar())\n\t\tnum=num*10+c-'0';\n\treturn num;\n}\n\ninline void add_edge(int u,int v)\n{\n\tedge[++num_edge].v=v;\n\tedge[num_edge].nxt=head[u];\n\thead[u]=num_edge;\n}\n\nvoid dfs1(int u)\n{\n\tnode[u].size=1;\n\tfor(int i=head[u],v;i;i=edge[i].nxt)\n\t{\n\t\tv=edge[i].v;\n\t\tif(v==node[u].fa)\n\t\t\tcontinue;\n\t\tnode[v].fa=u;\n\t\tnode[v].dep=node[u].dep+1;\n\t\tdfs1(v);\n\t\tnode[u].size+=node[v].size;\n\t\tif(node[v].size>node[node[u].son].size)\n\t\t\tnode[u].son=v;\n\t}\n}\n\nint bound;\nvoid dfs2(int u,int top)\n{\n\tnode[u].s=++bound;\n\tnode[u].top=top;\n\tif(node[u].son)\n\t{\n\t\tdfs2(node[u].son,top);\n\t\tfor(int i=head[u],v;i;i=edge[i].nxt)\n\t\t{\n\t\t\tv=edge[i].v;\n\t\t\tif(v==node[u].son||v==node[u].fa)\n\t\t\t\tcontinue;\n\t\t\tdfs2(v,v);\n\t\t}\n\t}\n\tnode[u].t=bound;\n}\n\nvoid build(Tree &root,int l,int r)\n{\n\troot=++now_node;\n\troot->l=l,root->r=r,root->mid=l+r>>1;\n\tif(l==r)\n\t\treturn;\n\tbuild(root->lson,l,root->mid);\n\tbuild(root->rson,root->mid+1,r);\n}\n\nvoid better(Tree root)\n{\n\tif(node[root->lson->num].dep>node[root->rson->num].dep)\n\t\troot->num=root->rson->num;\n\telse\n\t\troot->num=root->lson->num;\n}\n\nvoid update(const Tree &root,int pos,int num)\n{\n\tif(root->l==root->r)\n\t{\n\t\troot->col^=1;\n\t\tif(root->col)\n\t\t\troot->num=num;\n\t\telse\n\t\t\troot->num=0;\n\t\treturn;\n\t}\n\tif(pos<=root->mid)\n\t\tupdate(root->lson,pos,num);\n\telse\n\t\tupdate(root->rson,pos,num);\n\tbetter(root);\n}\n\nint query(const Tree &root,int l,int r)\n{\n\tif(root->l==l&&root->r==r)\n\t\treturn root->num;\n\tif(r<=root->mid)\n\t\treturn query(root->lson,l,r);\n\telse if(l>root->mid)\n\t\treturn query(root->rson,l,r);\n\telse\n\t{\n\t\tint a=query(root->lson,l,root->mid),b=query(root->rson,root->mid+1,r);\n\t\treturn node[a].dep>node[b].dep?b:a;\n\t}\n}\n\ninline int Query(int x,int y)\n{\n\tint fx=node[x].top,fy=node[y].top;\n\tint ans=0,tmp,dep=599518803;\n\twhile(fx!=fy)\n\t{\n\t\tif(node[fx].dep>node[fy].dep)\n\t\t{\n\t\t\ttmp=query(Root,node[fx].s,node[x].s);\n\t\t\tif(dep>node[tmp].dep)\n\t\t\t\tans=tmp,dep=node[tmp].dep;\n\t\t\tx=node[fx].fa;\n\t\t\tfx=node[x].top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp=query(Root,node[fy].s,node[y].s);\n\t\t\tif(dep>node[tmp].dep)\n\t\t\t\tans=tmp,dep=node[tmp].dep;\n\t\t\ty=node[fy].fa;\n\t\t\tfy=node[y].top;\n\t\t}\n\t}\n\tif(node[x].dep>node[y].dep)\n\t{\n\t\ttmp=query(Root,node[y].s,node[x].s);\n\t\tif(dep>node[tmp].dep)\n\t\t\tans=tmp;\n\t}\n\telse\n\t{\n\t\ttmp=query(Root,node[x].s,node[y].s);\n\t\tif(dep>node[tmp].dep)\n\t\t\tans=tmp;\n\t}\n\treturn ans?ans:-1;\n}\n\nint u,v;\nint main()\n{\n\tnode[0].dep=0x7fffffff;\n\tn=read(),m=read();\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tu=read(),v=read();\n\t\tadd_edge(u,v);\n\t\tadd_edge(v,u);\n\t}\n\tdfs1(1);\n\tdfs2(1,1);\n\tbuild(Root,1,n);\n\tint opt,v;\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\topt=read(),v=read();\n\t\tif(opt==0)\n\t\t\tupdate(Root,node[v].s,v);\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",Query(1,v));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1521112179,
        "uid": 39886,
        "name": "Drifterming",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u9898\u610f:\u95ee$1->v$\u8def\u5f84\u4e0a\u7b2c\u4e00\u4e2a\u9ed1\u70b9\n\n\u8003\u8651$1->v$\u7684\u7684\u4e00\u6761\u94fe,\u6211\u4eec\u53ea\u8981\u7ef4\u62a4\u8fd9\u6761\u94fe\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u9ed1\u70b9\u5c31$ok$\u4e86\n\n\u7136\u540e\u8fd9\u6761\u94fe\u53c8\u53ef\u4ee5\u6811\u94fe\u5256\u5206\u5206\u6210\u5f88\u591a\u6761\u91cd\u94fe\n\n\u6240\u4ee5\u6211\u4eec\u6bcf\u6761\u91cd\u94fe\u7ef4\u62a4\u4e00\u4e2a\u53ef\u652f\u6301\u5220\u9664\u7684\u5806\n\n\u6bcf\u6b21\u8be2\u95ee\u95ee\u5806\u91cc\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9,\u6ce8\u610f\u7279\u5224\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9\u7684\u6df1\u5ea6\u662f\u5426\u5927\u4e8e\u5f53\u524d\u70b9\u6df1\u5ea6 \n\n\u590d\u6742\u5ea6$o(nlog^2n)$,\u4f46\u662f\u5e38\u6570\u6781\u5c0f\n\n\u6ce8\u610f$1->v$\u7684\u8def\u5f84,\u4e0d\u662f$v->1$\u7684\u8def\u5f84,\u4e00\u5f00\u59cb\u4ee5\u4e3a\u662f$v->1$\u8fd8\u4ee5\u4e3a\u81ea\u5df1$set$\u6302\u4e86 ",
        "postTime": 1518396597,
        "uid": 20156,
        "name": "Kelin",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u697c\u4e0b\u7684\u5927\u4f6c\u4eec\u592a\u5f3a\u8fa3\u3002\n\n\u849f\u84bb\u6765\u4e00\u53d1lct\u3002\n\n\u9996\u5148\u66b4\u529b\u7684\u505a\u6cd5\u662f\u6bcf\u6b21\u8be2\u95ee\u90fd\u5f80\u4e0a\u8df3\uff0c\u4e00\u76f4\u8df3\u5230\u6839\u3002\n\n\u90a3\u4e48\u4f18\u5316\u8fd9\u4e2a\u8df3\u7684\u8fc7\u7a0b\uff0c\u663e\u7136\u53ef\u4ee5\u7528\u5e73\u8861\u6811\u6765\u7ef4\u62a4\u8fd9\u6761\u94fe\uff0c\u90a3\u5c31\u662f\u4e00\u4e2alct\u7684\u6a21\u677f\u9898\u4e86\u3002\n\n\u53ea\u9700\u8981\u5728splay\u91cc\u7ef4\u62a4\u5b50\u6811\u91cc\u7684\u9ed1\u70b9\u6570\u76ee\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6\uff1a$O(qlogn)$~~\u5927\u5e38\u657064~~\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 110000;\nstruct LinkCutTree\n{\n    int sta[MAX], top;\n    struct Node\n    {\n        int fa, son[2], sum, rev, val;\n    } T[MAX];\n    bool isroot(int x)\n    {\n        return T[T[x].fa].son[0] != x && T[T[x].fa].son[1] != x;\n    }\n    void pushup(int x)\n    {\n        T[x].sum = T[T[x].son[0]].sum + T[T[x].son[1]].sum + T[x].val;\n    }\n    void pushdown(int x)\n    {\n        if (T[x].rev)\n        {\n            T[x].rev ^= 1;\n            T[T[x].son[0]].rev ^= 1;\n            T[T[x].son[1]].rev ^= 1;\n            swap(T[x].son[0], T[x].son[1]);\n        }\n    }\n    void rotate(int x)\n    {\n        int y = T[x].fa, z = T[y].fa;\n        int op = T[y].son[1] == x;\n        T[x].fa = z;\n        if (!isroot(y)) T[z].son[T[z].son[1] == y] = x;\n        T[y].son[op] = T[x].son[!op];\n        T[T[y].son[op]].fa = y;\n        T[x].son[!op] = y;\n        T[y].fa = x;\n        pushup(y);\n    }\n    void splay(int x)\n    {\n        top = 1; sta[top] = x;\n        for (int i = x; !isroot(i); i = T[i].fa) sta[++top] = T[i].fa;\n        for (int i = top; i; i--) pushdown(sta[i]);\n        while (!isroot(x))\n        {\n            int y = T[x].fa, z = T[y].fa;\n            if (!isroot(y))\n                if ((T[z].son[0] == y) ^ (T[y].son[0] == x)) rotate(x);\n                else rotate(y);\n            rotate(x);\n        }\n        pushup(x);\n    }\n    void access(int x)\n    {\n        for (int t = 0; x; t = x, x = T[x].fa)\n            splay(x), T[x].son[1] = t, pushup(x);\n    }\n    void makeroot(int x)\n    {\n        access(x), splay(x); T[x].rev ^= 1;\n    }\n    int findroot(int x)\n    {\n        access(x), splay(x);\n        while (T[x].son[0]) x = T[x].son[0];\n        return x;\n    }\n    void link(int x, int y)\n    {\n        makeroot(x); T[x].fa = y;\n    }\n    void split(int x, int y)\n    {\n        makeroot(x), access(y), splay(y);\n    }\n    void cut(int x, int y)\n    {\n        split(x, y);\n        T[x].fa = T[y].son[0] = 0;\n        pushup(y);\n    }\n    void change(int x)\n    {\n        splay(x);\n        T[x].val ^= 1;\n        pushup(x);\n    }\n    int query(int x)\n    {\n        makeroot(1);\n        access(x), splay(x);\n        if (T[x].sum == 0) return -1;\n        while (x)\n        {\n            if (T[T[x].son[0]].sum == 0 && T[x].val)\n                return x;\n            else if (T[T[x].son[0]].sum) x = T[x].son[0];\n            else x = T[x].son[1];\n        }\n    }\n} lct;\nint n, q;\nint read()\n{\n    int x = 0, f = 1; char ch = getchar();\n    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }\n    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\nint main()\n{\n    n = read(), q = read();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        lct.link(u, v);\n    }\n    while (q--)\n    {\n        int opt = read(), x = read();\n        if (opt == 0) lct.change(x);\n        else printf(\"%d\\n\", lct.query(x));\n    }\n    return 0;\n}\n```",
        "postTime": 1516414882,
        "uid": 37070,
        "name": "Ameyax",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "> \u5916\u8bdd\uff1a\u6700\u8fd1\u6d1b\u8c37\u52a0\u4e86\u597d\u591a\u597d\u9898\u554a...[\u539f\u9898\u5165\u53e3](https://www.luogu.org/problemnew/show/P4116) \u8fd9\u9898\u597d\u50cf\u662fSPOJ\u7684\u9898\uff0c\u633a\u4e0d\u9519\u7684\u3002\u770b\u6ca1\u6709\u9898\u89e3\u8fd8\u662f\u6765\u4e00\u7bc7...\n\n- \u9898\u610f\uff1a\n\n\n\u5f88\u660e\u663e\u5427\u3002\u3002\n\n    \n- \u9898\u89e3\uff1a\n\n    \n\u6211\u7684\u505a\u6cd5\u5341\u5206\u7684\u66b4\u529b\uff1a\u6811\u94fe\u5256\u5206\uff08\u4f2a\uff09+\u7ebf\u6bb5\u6811+$set$...\n\n    \n\u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u6bcf\u6b21\u4fee\u6539\u4e00\u4e2a\u70b9\u7684\u989c\u8272\u7684\u5f71\u54cd\u3002\n\n\u6613\u77e5\uff0c\u7ffb\u8f6c\u4e00\u4e2a\u70b9\u989c\u8272\uff0c\u53ea\u4f1a\u5bf9\u4e8e\u4ed6\u7684\u5b50\u6811\u4ea7\u751f\u5f71\u54cd\uff0c\u5bf9\u4e8e\u522b\u7684\u70b9\u5c31\u6beb\u65e0\u610f\u4e49\u4e86\u3002\n\n    \n\u7136\u540e\uff0c\u53ea\u8981\u5b66\u8fc7\u4e00\u70b9\u6811\u94fe\u5256\u5206\u7684\u5c31\u77e5\u9053\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6574\u68f5\u6811\u6309\u5b83\u7684$dfs$\u5e8f\u8fdb\u884c\u6807\u53f7\uff0c\n\n\u6bcf\u4e2a\u70b9\u7684\u5e8f\u53f7\u5c31\u662f$dfn$\uff0c\n\n\u7136\u540e\u8bb0\u4e0b\u5b83\u7684\u5b50\u6811\u5927\u5c0f$size$\uff0c\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u70b9$u$\u6240\u5728\u7684\u5b50\u6811\u533a\u95f4\u5c31\u662f$[dfn[u], dfn[u]+size[u]-1]$\u3002\n\n\u6240\u4ee5\u6bcf\u6b21\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u53ea\u8981\u5bf9\u4e8e\u90a3\u4e00\u6bb5\u533a\u95f4\u8fdb\u884c\u4fee\u6539\u5c31\u884c\u4e86\u3002\n\n\n\u7136\u540e\u6211\u4eec\u8981\u4fee\u6539\u548c\u67e5\u8be2\u4ec0\u4e48\u5462\uff1f\u4e0d\u5c31\u662f\u67e5\u8be2\u5305\u542b\u8fd9\u4e2a\u70b9\uff0c\u4e14\u6df1\u5ea6\u6700\u5c0f\u7684\u9ed1\u70b9\u5417\uff1f\uff08\u9700\u8981\u628a$1$\u4f5c\u4e3a\u6839\uff09\n\n    \n\u6240\u4ee5\uff0c\u6211\u4eec\u6bcf\u6b21\u8bb0\u4e0b\u4e00\u4e2a\u533a\u95f4\u4e2d\uff0c\u5305\u542b\u8fd9\u4e2a\u70b9\u7684\u6240\u6709\u9ed1\u8272\u6807\u53f7\u4ee5\u53ca\u4ed6\u4eec\u7684\u6df1\u5ea6\uff0c\u7528$pair$\u8bb0\u5f55\u4e00\u4e0b\uff08\u56e0\u4e3a\u8fd9\u4e2a\u53ef\u4ee5\n\n\u81ea\u52a8\u6309\u7167\u7b2c\u4e00\u5173\u952e\u5b57\u6392\u5e8f\uff09\uff0c\u518d\u7528$set$\u7ef4\u62a4\u4e00\u4e0b\u533a\u95f4\u6700\u503c\u5c31\u884c\u4e86\u3002\n\n    \n\u6bcf\u6b21\u66f4\u65b0\u7684\u65f6\u5019\u53ea\u8981\u5728$set$\u91cc\u9762$insert$\u548c$erase$\u3002\n\n\u67e5\u8be2\u5c31\u662f\u4ece\u6839\u8282\u70b9\u4e00\u76f4\u5411\u4e0b\u8dd1\uff0c\u4e0d\u65ad\u53d6\u4e00\u4e2a\u6df1\u5ea6\u66f4\u5c0f\u7684$ans$\u3002\n\n    \n\u5177\u4f53\u6709\u4e9b\u5b9e\u73b0\u5728\u7a0b\u5e8f\u4e2d\u4f1a\u4f53\u73b0\u7684\u2026\u2026\n\n    \n\u603b\u65f6\u95f4\u590d\u6742\u5ea6$O(q \\ log \\ n)$ \u7a7a\u95f4\u590d\u6742\u5ea6\u4e5f\u662f$O(q \\ log \\ n)$\u3002\uff08\u6240\u4ee5\u8bf4\u5f88\u66b4\u529b\u561b\u2026\u2026\uff09\n\n\n- \u4ee3\u7801\uff1a\n\n```cpp\n#include <bits/stdc++.h>\n#define For(i, l, r) for(int i = (l), _end_ = (int)(r); i <= _end_; ++i)\n#define Fordown(i, r, l) for(int i = (r), _end_ = (int)(l); i >= _end_; --i)\n#define Set(a, v) memset(a, v, sizeof(a))\nusing namespace std;\n\nbool chkmin(int &a, int b) {return b < a ? a = b, 1 : 0;}\nbool chkmax(int &a, int b) {return b > a ? a = b, 1 : 0;}\n\ninline int read() {\n    int x = 0, fh = 1; char ch = getchar();\n    for (; !isdigit(ch); ch = getchar() ) if (ch == '-') fh = -1;\n    for (; isdigit(ch); ch = getchar() ) x = (x<<1) + (x<<3) + (ch ^ '0');\n    return x * fh;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n    freopen (\"P4116.in\", \"r\", stdin);\n    freopen (\"P4116.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 1e5 + 1e3, M = N << 1;\nint n, q;\nint sz[N], dfn[N], dep[N];\n\nint to[M], Next[M], Head[N], e = 0;\n\nvoid add(int u, int v) {\n    to[++e] = v;\n    Next[e] = Head[u];\n    Head[u] = e;\n}\n\nvoid Dfs(int u, int fa) {\n    static int clk = 0;\n    sz[u] = 1;\n    dfn[u] = ++ clk;\n    dep[u] = dep[fa] + 1;\n    for (register int i = Head[u]; i; i = Next[i]) {\n        register int v = to[i];\n        if (v == fa) continue ;\n        Dfs(v, u); sz[u] += sz[v];\n    }\n}//\u5c31\u662f\u6811\u94fe\u5256\u5206\u7684\u7b2c\u4e00\u4e2adfs,\u6c42\u51fasize,dep,dfn \n\ntypedef pair<int, int> PII;\n#define mp make_pair\n#define lson o << 1, l, mid\n#define rson o << 1 | 1, mid + 1, r\nset<PII> S[N << 2];\n\nbool col[N];//\u56e0\u4e3a\u4e0d\u77e5\u9053\u662f\u53d8\u5565\u989c\u8272,\u6240\u4ee5\u8981\u8bb0\u4e00\u4e0b\u539f\u6765\u7684\u989c\u8272 \nbool uopt; int ul, ur; PII uv;\nvoid Update(int o, int l, int r) {\n    if (ul <= l && r <= ur) {\n        if (uopt) S[o].erase(uv);\n        else S[o].insert(uv);\n        //erase\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\u90a3\u4e2a\u503c. \n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if (ul <= mid) Update(lson);\n    if (ur > mid) Update(rson);\n}\n\nPII ans; int up;\nvoid Query(int o, int l, int r) {\n    if ((bool)S[o].size() )\n        ans = min(ans, *S[o].begin() );\n    //begin\u5c31\u662f\u8fd9\u4e2aset\u4e2d\u6700\u5c0f\u7684\u90a3\u4e00\u4e2a,\u5373\u8fd9\u91cc\u9762\u6df1\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u70b9 \n    if (l == r) return ;\n    int mid = (l + r) >> 1;\n    if (up <= mid) Query(lson);\n    else Query(rson);\n}\n\nconst int inf = 0x3f3f3f3f;\n\nint main () {\n    n = read(); q = read();\n    For (i, 1, n - 1) {\n        int u, v;\n        scanf (\"%d%d\", &u, &v);\n        //int u = read(), v = read();\n        add(u, v); add(v, u);\n    }\n    Dfs(1, 0);\n    \n    For (i, 1, q) {\n        int opt, pos;\n        scanf (\"%d%d\", &opt, &pos);\n        //int opt = read(), pos = read();\n        if (opt == 0) {\n            uopt = col[pos];\n            col[pos] ^= true;\n            ul = dfn[pos];\n            ur = dfn[pos] + sz[pos] - 1;\n            uv = mp(dep[pos], pos);\n            Update(1, 1, n);\n        } else {\n            ans = mp(inf, inf);\n            up = dfn[pos];\n            Query(1, 1, n);\n            printf (\"%d\\n\", ans.second == inf ? -1 : ans.second);\n        }\n    }\n    //cerr << clock() << endl;\n    return 0;\n}\n```\n\n> \u540e\u8bb0\uff1a\u770b\u5230\u5f88\u591adalao\u90fd\u662f\u7528\u5565 \u4e3b\u5e2d\u6811\uff0c\u500d\u589e\uff0c\u548c\u4e0d\u7528$set$\u7684\u7ebf\u6bb5\u6811\u505a\u8fc7\u53bb\u7684\u3002\u8dd1\u5f97\u90fd\u6bd4\u6211\u5feb\uff0c\u5e0c\u671b\u540e\u9762\u6709\u4eba\u80fd\u8bb2\u4e00\u8bb2QAQ\u3002",
        "postTime": 1516252440,
        "uid": 19128,
        "name": "zjp_shadow",
        "ccfLevel": 9,
        "title": "Qtree3"
    },
    {
        "content": "\u7b2c\u4e00\u6b21\u628a\u9898\u76ee\u770b\u9519\uff0c\uff0c\uff0c\uff0c\uff0c\n\u9898\u76ee\u8981\u6c42\u7684\u662f\u7b2c\u4e00\u4e2a\u9ed1\u70b9\u7684\u7f16\u53f7\uff0c\u76f4\u63a5\u770b\u4e86\u4e00\u4e0b\u6837\u4f8b\u6570\u636e~~\u4ee5\u4e3a\u662f\u6c42\u7f16\u53f7\u6700\u5c0f\u7684\u9ed1\u70b9~~\uff1b\n\n------------------------------------------------\n\u6811\u4e0a\u66f4\u65b0\u548c\u67e5\u8be2\uff0c\u6240\u4ee5\u60f3\u5230\u6811\u94fe\u5256\u5206\uff1b\n\n\u4ece1\u5230v\u7b2c\u4e00\u4e2a\u9ed1\u70b9\u7684\u7f16\u53f7\uff0c\u5219\u4ee51\u4e3a\u6839\u5bf9\u6811\u8fdb\u884c\u7b2c\u4e8c\u904ddfs\u7684\u65f6\u5019\u91cd\u65b0\u7f16\u53f7\uff0c\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u7f16\u53f7\u8d8a\u5c0f\u5fc5\u7136\u8d8a\u9760\u8fd1\u6839\uff1b\u56e0\u6b64\u7ebf\u6bb5\u6811\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u6700\u5c0f\u503cminv\u4fdd\u5b58\u65b0\u7684\u7f16\u53f7\u5373id[x]\uff1b\u4e0d\u96be\u53d1\u73b0\u5149\u4fdd\u5b58minv\u8fd8\u4e0d\u884c\uff0c\u56e0\u4e3a\u6709\u53ef\u80fd\u4e0d\u5b58\u5728\u9ed1\u70b9\uff0c\u56e0\u6b64\u518d\u5b9a\u4e49\u4e00\u4e2ahas\u6807\u8bb0\u5728\u533a\u95f4\u4e2d\u662f\u5426\u542b\u6709\u9ed1\u70b9\u3002\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100005,inf=1e9;\nint fir[N],to[N*2],nxt[N*2],cnt;\nint fa[N],depth[N],top[N],size[N],son[N],inG[N],id[N];\nstruct node{\n\tint l,r,mid,minv,has;\n\tnode(int a=0,int b=0):l(a),r(b){mid=(a+b)>>1;has=0;minv=inf;}\n}tree[N*4];\nvoid addEdge(int f,int t){\n\tto[++cnt]=t;nxt[cnt]=fir[f];fir[f]=cnt;\n}\nvoid build(int rt,int l,int r){\n\ttree[rt]=node(l,r);\n\tif(l==r)return;\n\tint mid=(l+r)>>1,ls=rt<<1,rs=ls+1;\n\tbuild(ls,l,mid);\n\tbuild(rs,mid+1,r);\n}\nvoid dfs(int u,int fu){\n\tdepth[u]=depth[fu]+1;fa[u]=fu;size[u]=1;\n\tfor(int i=fir[u];i;i=nxt[i])\n\t\tif(to[i]!=fu){\n\t\t\tdfs(to[i],u);\n\t\t\tsize[u]+=size[to[i]];\n\t\t\tif(size[to[i]]>size[son[u]])\n\t\t\t\tson[u]=to[i];\n\t\t}\n}\nvoid dfs1(int u,int k){\n\ttop[u]=k;id[u]=++cnt;inG[cnt]=u;\n\tif(son[u])dfs1(son[u],k);\n\tfor(int i=fir[u];i;i=nxt[i])\n\t\tif(to[i]!=fa[u]&&to[i]!=son[u])\n\t\t\tdfs1(to[i],to[i]);\n}\nvoid update(int rt,int x){\n\tif(tree[rt].l==tree[rt].r){\n\t\ttree[rt].has^=1; //\u66f4\u65b0\u4e00\u6b21\u5c31\u548c1\u5f02\u6216\u4e00\u6b21 \n\t\tif(tree[rt].has)tree[rt].minv=x;//\u6709\u9ed1\u70b9\u5219minv\u66f4\u65b0\u4e3ax\u5373\u65b0\u7684\u7f16\u53f7\uff0c\u56e0\u4e3a\u7f16\u53f7\u8d8a\u5c0f\u5219\u8d8a\u9760\u524d\n\t\telse tree[rt].minv=inf;//\u6ca1\u6709\u9ed1\u70b9\u5c31\u66f4\u65b0\u4e3a\u65e0\u7a77\u5927 \n\t\treturn;\n\t}\n\tint mid=tree[rt].mid,ls=rt<<1,rs=ls+1;\n\tif(x<=mid)update(ls,x);\n\telse update(rs,x);\n\ttree[rt].minv=min(tree[ls].minv,tree[rs].minv);\n\ttree[rt].has=tree[ls].has|tree[rs].has;\n}\nint query(int rt,int l,int r){\n\tif(tree[rt].l==l&&tree[rt].r==r)return tree[rt].minv;\n\tif(!tree[rt].has) return inf;//\u63d0\u9ad8\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u7684\u67e5\u8be2 \n\tint mid=tree[rt].mid,ls=rt<<1,rs=ls+1;\n\tif(l>mid)return query(rs,l,r);\n\tif(r<=mid)return query(ls,l,r);\n\treturn min(query(ls,l,mid),query(rs,mid+1,r));\n}\nint getMin(int x,int y){\n\tint ans=inf;\n\twhile(top[x]!=top[y]){\n\t\tif(depth[top[x]]<depth[top[y]])swap(x,y);\n\t\tans=min(ans,query(1,id[top[x]],id[x]));\n\t\tx=fa[top[x]];\n\t}\n\tif(depth[x]>depth[y])swap(x,y);\n\tans=min(ans,query(1,id[x],id[y]));\n\tif(ans==inf)ans=-1;\n\telse ans=inG[ans];\n\treturn ans;\n}\nint main(){\n\tint n,m,x,y;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddEdge(x,y);\n\t\taddEdge(y,x);\n\t}\n\tdfs(1,0);\n\tcnt=0;\n\tdfs1(1,1);\n\tbuild(1,1,n);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(x)printf(\"%d\\n\",getMin(1,y));\n\t\telse update(1,id[y]);\n\t}\n\treturn 0;\n} \n```\n\n\n",
        "postTime": 1552373971,
        "uid": 39079,
        "name": "yqw2486",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "![](https://i.loli.net/2018/08/07/5b69203423c82.png)\n\n\u7531\u4e8e\u521a\u521a\u5b66\u6811\u5256\u6240\u4ee5\u6765\u5237\u5237\u6c34\u9898\u3002\u4e0d\u4f1a\u6811\u5256\u7684\u540c\u5b66\u53ef\u4ee5\u679c\u65ad\u53f3\u8f6c : [$blog$](https://www.cnblogs.com/FibonacciHeap/articles/9797374.html)\u3002\n\n\u8fd9\u9053\u9898\u7684\u601d\u8def\u5c31\u662f\u4e00\u76f4\u4ece\u70b9 $x$ \u5f80\u4e0a\u8df3,\u4e00\u76f4\u5230 $root$ (\u4e5f\u5c31\u662f $1$)\u3002\u5728\u5176\u4e2d\u6bcf\u4e00\u6b21\u90fd\u67e5\u8be2\u4e00\u904d $x$ \u5230 $top[x]$ \u7684\u6700\u9ad8\u7684\u9ed1\u70b9\u3002\n\n\u5148\u968f\u4fbf\u753b\u4e00\u4e2a\u56fe : \n\n![](https://cdn.luogu.com.cn/upload/pic/38569.png)\n\n\u5176\u4e2d\u6211\u4eec\u628a $white$ \u5b9a\u4e49\u4e3a $val$ \u7684 $0$,$black$ \u4e3a $1$\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38570.png)\n\n\u5047\u8bbe\u6211\u4eec\u4ece $10$ \u53f7\u8282\u70b9\u5f00\u59cb\u8df3\u3002\u5148\u8df3\u5230 $10$ \u7684\u94fe\u9876\u7684\u7236\u4eb2\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38571.png)\n\n\u6211\u4eec\u4f1a\u53d1\u73b0 $min\\ dfn=10$ \u4f46\u662f $dfn$ \u4e3a $10$ \u7684\u8282\u70b9\u8fd8\u662f $white$,\u6240\u4ee5 $ans=inf$\u3002\n\n\u4ece $4$ \u5f80\u4e0a\u8df3\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38572.png)\n\n$4$ \u662f $black$,\u73b0\u5728\u662f $ans=8$ (\u56e0\u4e3a\u662f $dfn$)\u3002\u6700\u540e\u8df3\u5230 $1$ \u53d1\u73b0 $1$ \u662f $black$,\u7ed3\u675f\u3002\n\n\u5173\u4e8e\u7ebf\u6bb5\u6811\u7684\u7ef4\u62a4,\u6211\u4eec\u8981\u7ef4\u62a4\u7684\u662f\u533a\u95f4\u6700\u5c0f\u503c\u3002\u4e14\u6240\u6709\u53f6\u5b50\u8282\u70b9\u53ea\u4fdd\u7559 $inf$ \u6216\u8005\u662f \u53f6\u5b50\u8282\u70b9\u7684\u4f4d\u7f6e \u4ee3\u8868 $white$ \u6216\u8005 $black$\u3002(\u7ebf\u6bb5\u6811\u7ef4\u62a4\u9519\u4e86\u8ba9\u6211\u9519\u4e86\u534a\u4e2a\u677f\u5b50)\n\n\u7136\u540e\u6709\u4e00\u4e2a\u4f18\u5316,\u5982\u679c $root$ \u662f $black$,\u76f4\u63a5\u8f93\u51fa\u3002(\u867d\u7136\u6ca1\u6709\u6570\u636e\u662f\u8fd9\u6837\u5b50\u7684)\n\n```pascal\nUses math;\n\nvar\n    recf,cnt,size,dfn,dep,top,father,son:array[-1..210000] of longint;\n    next,reach:array[-1..450000] of longint;\n    left,right:array[-1..450000] of longint;\n    tree:array[-1..450000] of int64;\n    i,n,m,l,r,dfnum,tot,root,order,ans,root_place:longint;\n\nprocedure add(l,r:longint);\nbegin\n    inc(tot);\n    reach[tot]:=r;\n    next[tot]:=cnt[l];\n    cnt[l]:=tot;\nend;\n\nprocedure Dfs_1(x:longint);\nvar i:longint;\nbegin\n    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;\n    while i<>-1 do\n    begin\n        if dep[reach[i]]=0 then\n        begin\n            dep[reach[i]]:=dep[x]+1;\n            father[reach[i]]:=x;\n            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);\n            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];\n        end;\n        i:=next[i];\n    end;\nend;\n\nprocedure Dfs_2(x,centre:longint);\nvar i:longint;\nbegin\n    inc(dfnum); dfn[x]:=dfnum; recf[dfnum]:=x; top[x]:=centre;\n    if son[x]=0 then exit; Dfs_2(son[x],centre);\n    i:=cnt[x];\n    while i<>-1 do\n    begin\n        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);\n        i:=next[i];\n    end;\nend;\n\nprocedure Build(k,l,r:longint);\nvar mid:longint;\nbegin\n    left[k]:=l; right[k]:=r;\n    if (l=r) then begin if l=1 then root_place:=k; tree[k]:=maxlongint; exit; end;\n    mid:=(l+r) >> 1;\n    Build(k << 1,l,mid); Build(k << 1+1,mid+1,r);\n    tree[k]:=maxlongint;\nend;\n\nprocedure Change(k,x:longint);\nvar mid:longint;\nbegin\n    if left[k]=right[k] then\n    begin\n        if tree[k]=maxlongint then tree[k]:=left[k] else tree[k]:=maxlongint;\n        exit;\n    end;\n    mid:=(left[k]+right[k]) >> 1;\n    if x<=mid then Change(k << 1,x) else Change(k << 1+1,x);\n    tree[k]:=min(tree[k << 1],tree[k << 1+1]);\nend;\n\nfunction Query(k,x,y:longint):longint;\nvar mid:longint;\nbegin\n    Query:=maxlongint div 84;\n    if (x<=left[k])and(right[k]<=y) then exit(tree[k]);\n    mid:=(left[k]+right[k]) >> 1;\n    if (x<=mid) then Query:=min(Query,Query(k << 1,x,y));\n    if (y>mid) then Query:=min(Query,Query(k << 1+1,x,y));\nend;\n\nprocedure Refer(x:longint);\nbegin\n    if tree[root_place]<>maxlongint then begin ans:=1; exit; end;\n    while top[x]<>root do\n    begin\n        ans:=min(ans,Query(1,dfn[top[x]],dfn[x]));\n        x:=father[top[x]];\n    end;\n    ans:=min(ans,Query(1,dfn[root],dfn[x]));\n    if ans>maxlongint div 85 then ans:=-1;\nend;\n\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);\n    read(n,m); root:=1; recf[-1]:=-1;\n    for i:=1 to n-1 do begin read(l,r); add(l,r); add(r,l); end;\n    dep[root]:=1; father[root]:=1;\n    Dfs_1(root); Dfs_2(root,root); Build(1,1,n);\n    for i:=1 to m do\n    begin\n        read(order); ans:=maxlongint div 84;\n        if order=0 then begin read(l); Change(1,dfn[l]); end;\n        if order=1 then begin  read(l); Refer(l); writeln(recf[ans]); end;\n    end;\nend.\n```",
        "postTime": 1539942601,
        "uid": 77760,
        "name": "arfa",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u5176\u5b9e\u8fd9\u4e2a\u9898\u6bd4\u8f83\u57fa\u672c\u4f46\u662f\u672c\u849f\u84bb\u4e00\u4e2a\u5c0f\u5730\u65b9\u5374\u6539\u4e86\u4e09\u56db\u6b21\u2026\u2026\uff08uv\u6df7\u4e86\uff09\n\n\u987a\u4fbf\u8bf4\u4e00\u4e0b\u5bf9\u6811\u5256\u7684\u7406\u89e3\n\n\u672c\u849f\u84bb\u8868\u8fbe\u80fd\u529b\u60ca\u4eba\uff08\u5413\u4eba\uff09\u6b22\u8fce\u7ea0\u6b63\u75c5\u53e5\n\n\u5728noip\u91cc\u5176\u5b9e\u6811\u5256\u662f\u4e2a\u6709\u7528\u800c\u80fd\u89e3\u51b3\u5f88\u591a\u95ee\u9898\u7684\u4e1c\u897f\n\n\u6811\u5256\u89e3\u51b3\u7684\u662f\u6811\u7684\u533a\u95f4\u95ee\u9898\n\n\u5bf9\u4e8e\u6570\u7ec4\u7684\u904d\u5386\u4e00\u822c\u662fon\u7684\u5faa\u73af \u800c\u5bf9\u4e8e\u6811\u5c31\u662fdfs \u9488\u5bf9\u95ee\u7684\u95ee\u9898dfsn\u6b21\u4e00\u822c\u662f\u4e00\u4e2a\u6709\u7528\u7684\u66b4\u529b\u505a\u6cd5\n\n\u4f46\u662f\u5982\u679c\u9898\u76ee\u8981\u6c42100000\u5462\uff1f\u663e\u7136nlogn\u7684\u590d\u6742\u5ea6\u662f\u9996\u9009\n\u53ef\u662f\u9664\u4e86lca\u8fd9\u6837\u53ef\u4ee5\u5e7b\u5316\u4e3a\u533a\u95f4rmq\u7684\u95ee\u9898 nlogn\u592a\u5c0f\u4e86 \u56e0\u4e3alogn\u6b21\u4ee3\u8868\u6bcf\u6b21\u5220\u9664\u6811\u7684\u4e00\u534a\uff08\u5c31\u50cf\u70b9\u5206\u6cbb\uff09\u8fd9\u6837\u672c\u8eab\u53ea\u80fd\u89e3\u51b3\u4e0e\u8ddd\u79bb\u6709\u5173\u7684\u95ee\u9898\n\n\u6570\u636e\u7ed3\u6784\u4e0a\u6811\u662f\u4e00\u4e2a\u597d\u7684\u601d\u60f3 \u4e00\u4e9b\u9ad8\u6548\u7684\u6570\u636e\u7ed3\u6784\u6bd4\u5982\u5355\u8c03\u961f\u5217\u5355\u8c03\u6808\u662fon\u7684\u4f46\u662f\u6811\u7684\u8be2\u95ee\u4e00\u822c\u6709\u53ef\u5408\u5e76\u6027 \u8fd9\u79cd\u6570\u636e\u7ed3\u6784\u53ea\u80fd\u89e3\u51b3\u94fe\u4e0a\u95ee\u9898\uff08\u8fd8\u662f\u8981\u628a\u94fe\u9886\u51fa\u6765\uff09\n\n\u540c\u65f6\u6211\u4eec\u53d1\u73b0\u9886\u51fa\u6765\u5927\u94fe\u4f1a\u5bf9\u6811\u7684\u6574\u4f53\u6784\u578b\u9020\u6210\u96be\u4ee5\u5e73\u590d\u7684\u5f25\u5929\u5927\u8fc7 \u62c6\u5f00\u4e86\u6811\n\n\u6811\u94fe\u5256\u5206\u548c\u66f4\u52a0\u5177\u6709\u53ef\u5408\u5e76\u6027\u7684\u7ebf\u6bb5\u6811--\u6811\u5256\n\n\u5b9e\u94fe\u5256\u5206\u548c\u66f4\u5177\u6709\u62c6\u5206\u5408\u5e76\u529f\u80fd\u7684splay\u4ea7\u751f\u4e86-lct\n\n\u6811\u5256\u7ef4\u62a4\u7684\u5c31\u662f\u533a\u95f4\u7684\u5408\u5e76\u6027\u95ee\u9898\n\n\u533a\u95f4\u53ef\u4ee5\u505a\u7684 \u5f53\u7136\u653e\u5230\u6811\u4e0a\u4e5f\u53ef\u4ee5\u505a\n\n\u533a\u95f4\u7684\u7ebf\u6bb5\u6811\u672c\u6765\u5c31\u5f88\u96be\u4e86 \u653e\u5230\u6811\u4e0a\u5176\u5b9e\u96be\u5ea6\u8fd8\u662f\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u90a3\u4e2a\u95ee\u9898\u3001\n\n\u8fd8\u6709\u4e00\u79cd\u60c5\u51b5 \u5c31\u662f\u5229\u7528\u6811\u5256\u6027\u8d28 \u6bcf\u6b21\u66f4\u65b0\u7b54\u6848\n\n\u5bf9\u4e8e\u672c\u9898 \u73b0\u5728\u7684\u89e3\u6cd5\u6211\u90fd\u83ab\u540d\u89c9\u5f97\u96be\u4e86\n\n\u8fd9\u4e2a\u4e1c\u897f\u53ea\u9700\u8981\u8fd0\u7528\u53e6\u5916\u90a3\u79cd\u60c5\u51b5 \u9ed1\u8282\u70b9\u5b58id \u767d\u70b9inf\n\n\u6bcf\u6b21\u533a\u95f4min\u5982\u679c\u8fd9\u6b21\u7684min\u4e0d\u662finf\u66ff\u6362\u539f\u6765\u7684\u5373\u53ef\n\u2026\u2026\u2026\u2026\u2026\u2026\n\u2026\u2026\u2026\u2026\u2026\u2026\n\u4ee3\u7801\n\u2026\u2026\u2026\u2026\u2026\u2026\n\u2026\u2026\u2026\u2026\u2026\u2026\n\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 100005\n#define ll long long\n#define inf 1000000000\n#define lson (node<<1)\n#define rson (lson+1)\nstruct edge{\n    ll from,to;\n};vector<int>g[maxn];vector<edge>edges;\nll n,m,k=0,a,b,c,depth[maxn],sz[maxn],wson[maxn],idx[maxn],id[maxn],visit[maxn],ans=0,num=0,val[maxn],top[maxn],fa[maxn];\nll tree[maxn*4];\nvoid add_edge(int f,int t){\n    g[f].push_back(k);edges.push_back({f,t});g[t].push_back(k+1);edges.push_back({t,f});k+=2;\n}void build(int node,int l,int r){\n    if(l==r){tree[node]=inf;return ;}\n    int mid=(l+r)>>1;\n    build(lson,l,mid);build(rson,mid+1,r);\n    tree[node]=inf;\n}void add(int node,int l,int r,int x){\n    if(l==x&&x==r){if(val[idx[l]]==1)tree[node]=l;else tree[node]=inf;return ;\n\t}int mid=(l+r)>>1;\n    if(x<=mid)add(lson,l,mid,x);\n    else add(rson,mid+1,r,x);\n    tree[node]=min(tree[lson],tree[rson]);\n}ll query(int node,int l,int r,int x,int y){\n    if(x>y)return 0;\n    if(l==x&&y==r){return tree[node];}\n    int mid=(l+r)>>1;\n    if(y<=mid)return query(lson,l,mid,x,y);\n    else if(x>=mid+1) return query(rson,mid+1,r,x,y);\n    else return min(query(lson,l,mid,x,mid),query(rson,mid+1,r,mid+1,y));\n}void dfs1(int u){visit[u]=sz[u]=depth[1]=1;\n    for(int i=0;i<g[u].size();i++){\n        edge &e=edges[g[u][i]];if(visit[e.to])continue;\n        depth[e.to]=depth[u]+1;fa[e.to]=u;\n        dfs1(e.to);\n        sz[u]+=sz[e.to];if(sz[wson[u]]<sz[e.to])wson[u]=e.to;\n    }\n}void dfs2(int u){\n    top[1]=1;id[u]=++num,idx[num]=u;visit[u]=1;\n    if(wson[u]!=0){\n        top[wson[u]]=top[u];dfs2(wson[u]);\n    }\n    for(int i=0;i<g[u].size();i++){\n        edge &e=edges[g[u][i]];if(visit[e.to]||wson[u]==e.to)continue;\n        top[e.to]=e.to;dfs2(e.to);\n    }\n}ll querymin(int u,int v){ll ans=inf,now=inf;\n    while(top[v]!=1){\n        now=query(1,1,n,id[top[v]],id[v]);\n        if(now!=inf)ans=now;\n        v=fa[top[v]];\n    }\n    now=query(1,1,n,1,id[v]);\n    if(now!=inf)ans=now;\n    return ans;\n}int main(){\n    cin>>n>>m;\n    for(int i=1;i<n;i++)cin>>a>>b,add_edge(a,b);\n    dfs1(1);memset(visit,0,sizeof(visit));dfs2(1);\n    build(1,1,n);\n    for(int i=1;i<=m;i++){\n    \tcin>>a>>b;\n    \tif(a==0){val[b]=1-val[b];\n    \t\tadd(1,1,n,id[b]);\n\t\t}\n\t\telse{\n\t\t\tint mx=querymin(1,b);if(mx==inf)cout<<\"-1\"<<endl;\n\t\t\telse\n\t\t\tcout<<idx[mx]<<endl;\n\t\t} \n\t}\n}\n```\n",
        "postTime": 1539865759,
        "uid": 61523,
        "name": "zhengzhi726",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u8bb2\u4e00\u4e0b\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u65b9\u6cd5\uff0c\u7ef4\u62a4dfs\u5e8f\u533a\u95f4\u4e2d\u4e3a\u9ed1\u70b9\u7684\u6700\u5c0f\u7684dfn\u503c\uff0c\u767d\u70b9\u8d4b\u503c\u4e3ainf\uff0c\u67e5\u8be2\u76f4\u63a5\u4ece\u4e0b\u5f80\u4e0a\u8df3\u7684\u65f6\u5019\u67e5\u4e00\u4e0b\u6700\u5c0f\u503c\u5c31\u884c\u4e86\u3002\n\n\u8fd9\u6837\u4e3a\u4ec0\u4e48\u662f\u5bf9\u7684\uff1f\n\n\u56e0\u4e3a\u6bcf\u6b21\u67e5\u8be2\u90fd\u662f\u5728\u4e00\u6761\u94fe\u4e0a\uff0cdfn\u6700\u5c0f\u5c31\u4ee3\u8868\u6df1\u5ea6\u6700\u5c0f\uff0c\u4e5f\u5c31\u662f\u79bb1\u6700\u8fd1\u7684\u70b9\u4e86\u3002\u590d\u6742\u5ea6 $qlogn$.\n\n\u6548\u7387\u4e5f\u662f\u76f8\u5f53\u4e0d\u9519\u7684\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ninline  int read()\n{\n    int k=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;\n}\nconst int N=100055,inf=0x3f3f3f3f;\nint n,m,tot,cnt,to[N<<1],nextt[N<<1],head[N],co[N],fa[N],dep[N],top[N],dfn[N],tr[N],mn[N<<2],size[N],son[N];\n// tr[i]\u662fdfn\u503c\u4e3ai\u7684\u8282\u70b9\u7f16\u53f7\nvoid add(int a,int b)\n{\n    to[++tot]=b;\n    nextt[tot]=head[a];\n    head[a]=tot;\n}\nvoid dfs(int u,int f,int d)\n{\n    fa[u]=f;dep[u]=d;size[u]=1;\n    for(int i=head[u];i;i=nextt[i])\n    {\n        if(to[i]==f) continue;\n        dfs(to[i],u,d+1);size[u]+=size[to[i]];\n        if(size[to[i]]>size[son[u]]) son[u]=to[i];\n    }\n} \nvoid dfs2(int u,int num)\n{\n    top[u]=num;dfn[u]=++cnt;tr[cnt]=u;\n    if(!son[u]) return;\n    dfs2(son[u],num);\n    for(int i=head[u];i;i=nextt[i])\n    {\n        if(to[i]==fa[u]||to[i]==son[u]) continue;\n        dfs2(to[i],to[i]);\n    }\n}\n#define lson k<<1,l,mid\n#define rson k<<1|1,mid+1,r\nvoid pu(int k) {mn[k]=min(mn[k<<1],mn[k<<1|1]);}\nvoid build(int k,int l,int r)\n{\n    if(l==r) {mn[k]=inf;return;}\n    int mid=l+r>>1;\n    build(lson);build(rson);\n    pu(k);\n}\nvoid ch(int k,int l,int r,int x,int opt)\n{\n    if(l==r) {if(opt==1) mn[k]=l;else mn[k]=inf;return;}\n    int mid=l+r>>1;\n    if(x<=mid) ch(lson,x,opt);else ch(rson,x,opt);\n    pu(k);\n}\nint query(int k,int l,int r,int a,int b)\n{\n    if(a<=l&&b>=r) return mn[k];\n    int mid=l+r>>1,ans=inf;\n    if(a<=mid) ans=min(ans,query(lson,a,b));\n    if(b>mid ) ans=min(ans,query(rson,a,b));return ans; \n}\nint query2(int x)\n{\n    int ans=inf;\n    while(top[x]!=1)\n    {\n        ans=min(ans,query(1,1,n,dfn[top[x]],dfn[x]));x=fa[top[x]];\n    }\n    ans=min(ans,query(1,1,n,1,dfn[x]));return ans;\n}\nint main()\n{\n    int a,b;\n    n=read();m=read();\n    for(int i=1;i<n;i++)\n    a=read(),b=read(),add(a,b),add(b,a);\n    dfs(1,1,1);dfs2(1,1);build(1,1,n);\n    for(int i=1;i<=m;i++)\n    {\n        a=read();b=read();\n        if(a==0) \n        {\n            co[b]^=1;ch(1,1,n,dfn[b],co[b]);\n        }\n        else \n        {\n            int k=query2(b);\n            if(k==inf) puts(\"-1\");\n            else printf(\"%d\\n\",tr[k]);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1516332284,
        "uid": 36103,
        "name": "wxgwxg",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u3002\uff08\u7136\u800c\u6ca1\u6253\u7b49\u53f7\u8fdeWA\u4e00\u7248\u4e5f\u662f\u591f\uff09\n\n\u76f4\u63a5\u7528\u6700\u66b4\u529b\u7684\u601d\u60f3\u8dd1\u3002\u6811\u94fe\u5256\u5206\u5b8c\u540e\u76f4\u63a5\u5bf9\u6bcf\u4e00\u6761\u94fe\u7528set\u7ef4\u62a4\u94fe\u4e0a\u9ed1\u8272\u70b9\u7684dfn\u3002\u56e0\u4e3adfn\u552f\u4e00\u5bf9\u5e94\uff0c\u6240\u4ee5\u4e0d\u4f1a\u6709\u91cd\u590d\u3002\u67e5\u8be2\u5c31\u4e00\u8def\u8df3\u94fe\uff0c\u5728\u7ecf\u8fc7\u7684\u94fe\u4e0a\u67e5\u8be2dfn\u6700\u5c0f\u7684\u70b9\u3002\u6ce8\u610f\u5982\u679c\u8fd9\u4e2a\u70b9\u7684dep\u5c0f\u4e8e\u76ee\u524d\u8df3\u5230\u7684\u70b9\u7684dep\uff0c\u90a3\u4e48\u4e0d\u8ba1\u5165\u7b54\u6848\u3002\n\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define For(i,a,b) for(i=(a);i<=(b);++i)\n#define Forward(i,a,b) for(i=(a);i>=(b);--i)\n#define Rep(i,a,b) for(register int i=(a);i<=(b);++i)\n#define Repe(i,a,b) for(register int i=(a);i>=(b);--i)\n#define Chkmax(a,b) a=a>b?a:b;\n#define Chkmin(a,b) a=a<b?a:b;\nusing namespace std;\ntemplate<typename T>inline void read(T &x)\n{\n    T s=0,f=1;char k=getchar();\n    while(!isdigit(k)&&(k^'-'))k=getchar();\n    if(!isdigit(k)){f=-1;k=getchar();}\n    while(isdigit(k)){s=s*10+(k^48);k=getchar();}\n    x=s*f;\n}\nvoid file()\n{\n    #ifndef ONLINE_JUDGE\n        freopen(\"water.in\",\"r\",stdin);\n        freopen(\"water.out\",\"w\",stdout);\n    #endif\n}\nconst int MAXN=200010;\nstatic struct edge\n{\n    int v,next;\n}p[MAXN<<1];\nstatic int n,e,quer,head[MAXN],fa[MAXN],dep[MAXN];\nstatic int sta[MAXN];\ninline void add(int u,int v){p[++e].v=v;p[e].next=head[u];head[u]=e;}\nstatic int dfn[MAXN],ri[MAXN],top[MAXN],sz[MAXN],son[MAXN];\nstatic int t,link[MAXN];\nvoid dfs1(int u)\n{\n    dep[u]=dep[fa[u]]+1;sz[u]=1;\n    for(register int v=head[u];v;v=p[v].next)if(p[v].v^fa[u])\n    {\n        fa[p[v].v]=u;dfs1(p[v].v);sz[u]+=sz[p[v].v];\n        if(!son[u]||sz[p[v].v]>sz[son[u]])son[u]=p[v].v;\n    }\n}\nvoid dfs2(int u,int tp)\n{\n    dfn[u]=++e;ri[e]=u;top[u]=tp;\n    if(u^tp)link[u]=link[tp];\n    else link[u]=++t;\n    if(son[u])dfs2(son[u],tp);else return;\n    for(register int v=head[u];v;v=p[v].next)\n        if(p[v].v!=fa[u]&&p[v].v!=son[u])\n            dfs2(p[v].v,p[v].v);\n}\ninline void init()\n{\n    scanf(\"%d%d\",&n,&quer);\n    static int u,v;\n    Rep(i,1,n-1)scanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n    e=0;dfs1(1);dfs2(1,1);\n}\nstatic set<int>G[100011];\ninline void modify(int x)\n{\n    if(sta[x])G[link[x]].erase(dfn[x]);\n    else G[link[x]].insert(dfn[x]);\n    sta[x]^=1;\n}\ninline int query(int x)\n{\n    int ans=-1,pos=0;\n    if(sta[x])ans=x;\n    while(x)\n    {\n        if(!G[link[x]].empty()&&dep[pos=ri[*G[link[x]].begin()]]<=dep[x])//\u8fd9\u4e2a\u7b49\u53f7wa\u4e86\u6211\u534a\u5929\n            ans=pos;\n        x=fa[top[x]];\n    }\n    return ans;\n}\nvoid solve()\n{\n    static int opt,x;\n    Rep(i,1,quer)\n    {\n        scanf(\"%d%d\",&opt,&x);\n        if(opt)printf(\"%d\\n\",query(x));\n        else modify(x);\n    }\n}\nint main()\n{\n    file();\n    init();\n    solve();\n    return 0;\n}\n```",
        "postTime": 1516280521,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4116 \u3010Qtree3\u3011"
    }
]