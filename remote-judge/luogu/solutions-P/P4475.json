[
    {
        "content": "\u5df2\u5230\u5f88\u4e0d\u9519\u7684KD_tree\u5165\u95e8\u9898\u76ee\n\n\u9996\u5148\u5f97\u77e5\u9053\u4ec0\u4e48\u662fKD_tree\n\n\u9996\u5148KD_tree\u662f\u4e00\u9897\u4e8c\u53c9\u641c\u7d22\u6811 \u6811\u4e2d\u50a8\u5b58\u4e86k\u7ef4\u7684\u6570\u636e\u4fe1\u606f \u6784\u6811\u76f8\u5f53\u4e8e\u662f\u5bf9k\u7ef4\u7a7a\u95f4\u8fdb\u884c\u5212\u5206\u7684\u8fc7\u7a0b \u6240\u4ee5\u6bcf\u4e2a\u8282\u70b9\u5c31\u6709\u4e86\u5bf9\u5e94\u7684k\u7ef4\u7a7a\u95f4\u7684\u4e00\u4e2a\u8303\u56f4\n\n\u6bd4\u5982\u5f53k=1\u65f6  \u8fd9\u65f6\u5019\u7684KD_tree\u5c31\u662f\u6211\u4eec\u6240\u719f\u6089\u7684\u7ebf\u6bb5\u6811 \u6bcf\u4e2a\u8282\u70b9\u5c31\u5bf9\u5e94\u4e86\u4e00\u7ef4\u7684\u4e00\u4e2a\u533a\u95f4 \n\n\u8fd9\u91cc\u6709\u4e0d\u540c\u7684\u662f KD_tree\u7684\u6bcf\u4e2a\u8282\u70b9\u90fd\u50a8\u5b58\u4e86\u4fe1\u606f \u7c7b\u4f3c\u4f38\u5c55\u6811\uff08splay\uff09 \u800c\u7ebf\u6bb5\u6811\u4ec5\u6709\u53f6\u5b50\u8282\u70b9\u50a8\u5b58\u4fe1\u606f\n\n\u8fd9\u91cc\u6211\u7528\u7ed3\u6784\u4f53\u6765\u5448\u73b0\u4e00\u4e2a KD_tree\n\n\u4e00\u4e2a\u8282\u70b9\u542b\u6709\u7684\u4fe1\u606f\u6709\n\n\t1. d[k] \u6bcf\u4e2a\u7ef4\u5ea6\u7684\u503c\n\t2. mx[2],mn[2] \u8be5\u6811\u53ca\u4ee5\u4e0b\u8282\u70b9\u6bcf\u4e2a\u7ef4\u5ea6\u7684max\u548cmin\n\t3.lc,rc \u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\n\t\u6839\u636e\u9898\u76ee\u9700\u8981 \u8fd9\u91cc\u52a0\u5165\u53d8\u91cfval\uff08\u6743\u503c\uff09 \u7ef4\u62a4\u4e00\u4e2asum\uff08\u6743\u503c\u548c\uff09\n    \n\u63a5\u4e0b\u6765\u662fKD_tree\u7684\u6784\u9020\u65b9\u6cd5 \n\n\u6211\u4eec\u628a\u7b2ci\u5c42\u7684\u8282\u70b9\u6309\u7167\u7b2c i%\uff08\u7ef4\u5ea6\u6570\u91cf\uff09\u7ef4\u5ea6\u7684\u4f18\u5148\u7ea7 \u53d6\u4e2d\u4f4d\u6570\uff08\u5c31\u662f\u627e\u5230\u4e00\u4e2a\u5212\u5206\u8282\u70b9mid\uff09\n\u7136\u540e\u6839\u636emid\u5212\u5206\u5de6\u53f3\u513f\u5b50 \u5982\u6b64\u5faa\u73af\u4e0b\u53bb\u76f4\u5230\u53f6\u5b50\u8282\u70b9\n\n\u8fd9\u662f\u6700\u5e38\u89c1\u7684\u5212\u5206\u65b9\u6cd5 \u4f46\u662f\u5bb9\u6613\u88ab\u4e00\u4e9b\u6570\u636e\u7ed9\u5361\u4f4f\uff0c\u89c1[\u8fd9\u7bc7\u6587\u7ae0](https://blog.csdn.net/junshen1314/article/details/51121582)\n\uff08\u4ee5\u4e0a\u89e3\u8bf4\u6216\u591a\u6216\u5c11\u7684\u90fd\u501f\u9274\u4e86\u8fd9\u7bc7\u6587\u7ae0\uff09\n\n\u7136\u540e\u662f\u9488\u5bf9\u6b64\u9898\u7684\u67e5\u8be2\n\n\u5982\u679c\u8be5\u8282\u70b9\u7684mx mn\u5168\u90e8\u6ee1\u8db3a * x+b * y < c  \n\n\u90a3\u4e48\u8be5\u8282\u70b9\u4e00\u4e0b\u7684\u8282\u70b9\u90fd\u6ee1\u8db3 \u76f4\u63a5\u8fd4\u56desum  \n\n\u5426\u5219\u5c31\u53ea\u80fd\u62c6\u5f00\u8be5\u8282\u70b9\u548c\u5de6\u53f3\u513f\u5b50 \u9012\u5f52\u4e0b\u53bb\n\n\u4ee3\u7801\u90e8\u5206\n```cpp\n/*\n\u7b80\u5355\u7684\u5165\u95e8KD_tree\n\n\u9996\u5148\u9700\u8981\u4e00\u4e2a\u4e13\u95e8\u7528\u6765\u6392\u5e8f\u7684\u6570\u7ec4 dat\n\t\u5176\u5185\u5bb9\u4e00\u822c\u5305\u62ec\uff1a\n\t1.\u6bcf\u4e2a\u7ef4\u5ea6\u7684\u503c\n\t2.\u8be5\u6811\u53ca\u4e00\u4e0b\u90e8\u5206\u6bcf\u4e2a\u7ef4\u5ea6\u7684max\u548cmin\n\t3.\u5de6\u513f\u5b50\u548c\u53f3\u513f\u5b50\n\t4.\u6743\u503c\u4e4b\u7c7b\u7684\uff0c\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u7684 \uff08\u8fd9\u91cc\u7ef4\u62a4\u4e86\u4e00\u4e2asum\nKD_tree\u672c\u8d28\u662f\u4e00\u4e2a\u4e8c\u53c9\u641c\u7d22\u6811 \n\u6211\u4eec\u628a\u7b2ci\u5c42\u7684\u8282\u70b9\u6309\u7167\u7b2c i%\uff08\u7ef4\u5ea6\u6570\u91cf\uff09\u552f\u72ec\u7684\u4f18\u5148\u7ea7 \u53d6\u4e2d\u4f4d\u6570\uff08\u5c31\u662f\u627e\u5230\u4e00\u4e2a\u5212\u5206\u8282\u70b9mid\n\u7136\u540e\u6839\u636emid\u5212\u5206\u5de6\u53f3\u513f\u5b50 \u5982\u6b64\u5faa\u73af\u4e0b\u53bb\u76f4\u5230\u53f6\u5b50\u8282\u70b9\n\n\u8be5\u9898\u7684\u601d\u8def\u662f \u5982\u679c\u8be5\u8282\u70b9\u7684mx mn\u5168\u90e8\u6ee1\u8db3a*x+b*y<c\n\u90a3\u4e48\u8be5\u8282\u70b9\u4e00\u4e0b\u7684\u8282\u70b9\u90fd\u6ee1\u8db3 \u76f4\u63a5\u8fd4\u56desum\n\u5426\u5219\u5c31\u53ea\u80fd\u62c6\u5f00\u8be5\u8282\u70b9\u548c\u5de6\u53f3\u513f\u5b50 \u9012\u5f52\u4e0b\u53bb\n*/\n#include<cstdio>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=5e5+50;\nint n,now,m,rt;\nll a,b,c;\nstruct data\n{\n\tint d[2],mx[2],mn[2],lc,rc,val;\n\tll sum;\n\tfriend bool operator < (data a,data b)\n\t\t{return a.d[now]<b.d[now];}\n}dat[N],t[N];\nvoid getmax(int&a,int b){if(a<b)a=b;}\nvoid getmin(int&a,int b){if(a>b)a=b;}\nvoid pushup(int x)\n{\n\tint lc=t[x].lc,rc=t[x].rc;\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tt[x].mn[i]=t[x].mx[i]=t[x].d[i];\n\t\tif(lc)  getmin(t[x].mn[i],t[lc].mn[i]),\n\t\t\tgetmax(t[x].mx[i],t[lc].mx[i]);\n\t\tif(rc)  getmin(t[x].mn[i],t[rc].mn[i]),\n\t\t\tgetmax(t[x].mx[i],t[rc].mx[i]);\n\t}\n\tt[x].sum=t[lc].sum+t[rc].sum+t[x].val;\n}\n\nint build(int l,int r,int pl)\n{\n\tnow=pl; int mid=(l+r)>>1;\n\tnth_element(dat+l,dat+mid,dat+r+1);\n\tt[mid]=dat[mid];\n\tif(l<mid) t[mid].lc=build(l,mid-1,!pl);\n\tif(r>mid) t[mid].rc=build(mid+1,r,!pl);\n\tpushup(mid); return mid;\n}\nbool check(ll x,ll y) {return x*a+y*b<c;}\nll query(int x)\n{\n\tint tot=0;\n\ttot+=check(t[x].mx[0],t[x].mx[1]);\n\ttot+=check(t[x].mn[0],t[x].mx[1]);\n\ttot+=check(t[x].mx[0],t[x].mn[1]);\n\ttot+=check(t[x].mn[0],t[x].mn[1]);\n\tif(tot==4) return t[x].sum; // \u90fd\u6ee1\u8db3\n\tif(tot==0) return 0; // \u90fd\u4e0d\u6ee1\u8db3\n\tll res=0;\n\tif(check(t[x].d[0],t[x].d[1])) res+=t[x].val;\n\tif(t[x].lc) res+=query(t[x].lc);\n\tif(t[x].rc) res+=query(t[x].rc);\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) \n\t\tscanf(\"%d%d%d\",&dat[i].d[0],&dat[i].d[1],&dat[i].val);\n\trt=build(1,n,0); while(m--)\n\t{\n\t\tscanf(\"%lld%lld%lld\",&a,&b,&c);\n\t\tprintf(\"%lld\\n\",query(rt));\n\t}\n\treturn 0;\n}\n```\n\u518d\u63a8\u8350\u4e00\u7bc7[\u597d\u7684\u6587\u7ae0](http://www.cnblogs.com/lysuns/articles/4710712.html)\n\n\u81f3\u4e8eKD_tree\u7684\u90bb\u503c\u67e5\u8be2 ~~\uff08\u4e0d\u662f\u4e0e\u672c\u9898\u65e0\u5173\u5417\uff0c\u6211\u4e5f\u4e0d\u4f1a\uff09~~",
        "postTime": 1551007530,
        "uid": 77807,
        "name": "\u7a1a\u540d\u771f\u767d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4475 \u3010\u5de7\u514b\u529b\u738b\u56fd\u3011"
    },
    {
        "content": "\u5341\u5206\u949f\u5199\uff0c\u5341\u5206\u949f\u8c03\uff0c\u8fd9\u4e5f\u662f\u9053\u96be\u5f97\u7684\u5c0f\u6e05\u65b0\u4e86\uff0c\u4f7f\u7528\u4e8c\u7ef4 K-D Tree \u5bf9\u4e8c\u7ef4\u6570\u70b9\u5750\u6807\u6781\u503c\u8fdb\u884c\u7ef4\u62a4\uff0c\u5728\u67e5\u8be2\u65f6\u8fdb\u884c\u4e0a\u4e0b\u754c\u526a\u679d\u56e0\u4e3a\u4e0d\u7ba1\u67e5\u8be2\u6570\u7684\u6b63\u8d1f\uff0c\u6700\u540e\u7684\u6781\u503c\u4e00\u5b9a\u51fa\u73b0\u5728\u5b83\u4e0e\u6700\u5927/\u5c0f\u503c\u7684\u4e58\u79ef\u4e2d\uff0c\u7531\u4e8e\u6570\u636e\u653e\u5f97\u5f88\u677e\uff0c\u53ea\u9700\u8981\u4ea4\u66ff\u5efa\u6811\u5c31\u80fd\u901a\u8fc7\uff08\u4f60\u60f3\u65b9\u5dee\u5efa\u6811\u4e5f\u53ef\u4ee5\uff09\uff1a\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=5e4+4,M=1e6+6;\nchar buf[M+5],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,M,stdin),p1==p2)?EOF:*p1++)\ninline int read(){\n    int x,f=1;for(c=gc;c<48;c=gc)if(c=='-')f=-f;\n    for(x=0;c>47;x=x*10+(48^c),c=gc);return x*f;\n}\nll lx[N],rx[N],ly[N],ry[N],mx[N],my[N],mm[N],sm[N],ans;\nstruct Node{int x,y,h;}a[N];\nint n,Q,cmpT;\ninline bool operator<(const Node &x,const Node &y){\n    return cmpT?x.x<y.x:x.y<y.y;\n}\n#define Max(a,b) if(a<b)a=b\n#define Min(a,b) if(a>b)a=b\nint build(int l,int r){\n    int x=l+r>>1,y;cmpT^=1;\n    nth_element(a+l,a+x,a+r+1);\n    lx[x]=rx[x]=mx[x]=a[x].x;\n    ly[x]=ry[x]=my[x]=a[x].y;\n    sm[x]=mm[x]=a[x].h;\n    if(l<x){\n        y=build(l,x-1);sm[x]+=sm[y];\n        Min(lx[x],lx[y]);Min(ly[x],ly[y]);\n        Max(rx[x],rx[y]);Max(ry[x],ry[y]);\n    }if(x<r){\n        y=build(x+1,r);sm[x]+=sm[y];\n        Min(lx[x],lx[y]);Min(ly[x],ly[y]);\n        Max(rx[x],rx[y]);Max(ry[x],ry[y]);\n    }return x;\n}\nvoid ask(int l,int r){\n    int x=l+r>>1;ll L,R,D,U;\n    L=lx[x]*a[0].x,R=rx[x]*a[0].x;\n    D=ly[x]*a[0].y,U=ry[x]*a[0].y;\n    if(L>R)L^=R^=L^=R;\n    if(D>U)D^=U^=D^=U;\n    if(L+D>=a[0].h)return;\n    if(R+U<a[0].h){ans+=sm[x];return;}\n    L=mx[x]*a[0].x+my[x]*a[0].y;\n    if(L<a[0].h)ans+=mm[x];\n    if(l<x)ask(l,x-1);\n    if(x<r)ask(x+1,r);\n}\nint main(){\n    n=read(),Q=read();int i;\n    for(i=1;i<=n;++i)a[i]={read(),read(),read()};\n    build(1,n);\n    while(Q--){\n        a[ans=0]={read(),read(),read()};\n        ask(1,n),printf(\"%lld\\n\",ans);\n    }return 0;\n}\n```",
        "postTime": 1646534773,
        "uid": 502410,
        "name": "EnofTaiPeople",
        "ccfLevel": 0,
        "title": "P4475 \u5de7\u514b\u529b\u738b\u56fd \u9898\u89e3"
    },
    {
        "content": "**KD-Tree** \u7684\u677f\u5b50\u9898\n\n[KD-Tree \u5b66\u4e60\u7b14\u8bb0](https://www.cnblogs.com/Isaunoya/p/12243739.html)\n\n- \u8003\u8651\u5230 $ax + by < c$ \u53ea\u8981\u5bf9\u6a2a\u7eb5\u5750\u6807\u4e0b\u624b\uff0c\u65e0\u8111\u67e5\u8be2\u5c31\u53ef\u4ee5\u4e86\n\n- \u56e0\u4e3a\u8fd9\u662f\u4e2a\u4e00\u6b21\u51fd\u6570\uff0c\u90fd\u53ef\u80fd\u4e3a\u8d1f\u6570\uff0c\u6240\u4ee5\u9700\u8981\u56db\u4e2a\u70b9\n\n- \u5bf9\u77e9\u5f62\u7684\u56db\u4e2a\u70b9\u4f9d\u6b21\u67e5\u8be2\uff0c\u5982\u679c\u90fd\u4e0d\u6ee1\u8db3\u6761\u4ef6\uff0c\u77e9\u5f62\u5185\u7684\u4e5f\u4e0d\u4f1a\u6ee1\u8db3\u6761\u4ef6\uff0c\u4e5f\u662f\u56e0\u4e3a\u4e00\u6b21\u51fd\u6570\u7684\u539f\u56e0\u3002\n\n- \u7136\u540e KD-Tree \u65e0\u8111\u67e5\u8be2\u5c31\u5b8c\u4e8b\u4e86\n\n```cpp\n// powered by c++11\n// by Isaunoya\n\n#include<bits/stdc++.h>\n#define rep(i , x , y) for(register int i = (x) ; i < (y) ; i ++)\nusing namespace std ;\nusing db = double ;\nusing ll = long long ;\nusing uint = unsigned int ;\n#define int long long\nusing pii = pair < int , int > ;\n#define ve vector\n#define Tp template\n#define all(v) v.begin() , v.end()\n#define sz(v) ((int)v.size())\n#define pb emplace_back\n#define fir first\n#define sec second\n\n// the cmin && cmax\nTp < class T > void cmax(T & x , const T & y) {\n\tif(x < y) x = y ;\n}\nTp < class T > void cmin(T & x , const T & y) {\n\tif(x > y ) x = y ;\n}\n\n// sort , unique , reverse\nTp < class T > void sort(ve < T > & v) {\n\tsort(all(v)) ;\n}\nTp < class T > void unique(ve < T > & v) {\n\tsort(all(v)) ;\n\tv.erase(unique(all(v)) , v.end()) ;\n}\nTp < class T > void reverse(ve < T > & v) {\n\treverse(all(v)) ;\n}\n\nint n , m , now = 0 ;\nstruct node {\n\tint d[2] , ls , rs , val , sum ;\n\tint mx[2] , mn[2] ;\n\tbool operator < (const node & other) const {\n\t\treturn d[now] < other.d[now] ;\n\t}\n} ;\nconst int maxn = 5e4 + 10 ;\nnode data[maxn] , qwq[maxn] ;\nvoid pushup(int o) {\n\tint ls = qwq[o].ls , rs = qwq[o].rs ;\n\tfor(int i = 0 ; i < 2 ; i ++) {\n\t\tqwq[o].mx[i] = qwq[o].mn[i] = qwq[o].d[i] ;\n\t\tif(ls) {\n\t\t\tcmin(qwq[o].mn[i] , qwq[ls].mn[i]) ;\n\t\t\tcmax(qwq[o].mx[i] , qwq[ls].mx[i]) ;\n\t\t}\n\t\tif(rs) {\n\t\t\tcmin(qwq[o].mn[i] , qwq[rs].mn[i]) ;\n\t\t\tcmax(qwq[o].mx[i] , qwq[rs].mx[i]) ;\n\t\t}\n\t}\n\tqwq[o].sum = qwq[o].val ;\n\tif(ls) qwq[o].sum += qwq[ls].sum ;\n\tif(rs) qwq[o].sum += qwq[rs].sum ;\n}\nint build(int l , int r , int p) {\n\tnow = p ;\n\tint mid = l + r >> 1 ;\n\tnth_element(data + l , data + mid , data + r + 1) ;\n\tqwq[mid] = data[mid] ;\n\tif(l < mid) qwq[mid].ls = build(l , mid - 1 , p ^ 1) ;\n\tif(r > mid) qwq[mid].rs = build(mid + 1 , r , p ^ 1) ;\n\tpushup(mid) ; return mid ;\n}\nint a , b , c ;\nint chk(int x , int y) { return x * a + y * b < c ; }\nint qry(int p) {\n\tint cnt = 0 ;\n\tcnt += chk(qwq[p].mn[0] , qwq[p].mn[1]) ;\n\tcnt += chk(qwq[p].mn[0] , qwq[p].mx[1]) ;\n\tcnt += chk(qwq[p].mx[0] , qwq[p].mn[1]) ;\n\tcnt += chk(qwq[p].mx[0] , qwq[p].mx[1]) ;\n\tif(cnt == 4) return qwq[p].sum ;\n\tif(! cnt) return 0 ;\n\tint res = 0 ;\n\tif(chk(qwq[p].d[0] , qwq[p].d[1])) res += qwq[p].val ;\n\tif(qwq[p].ls) res += qry(qwq[p].ls) ;\n\tif(qwq[p].rs) res += qry(qwq[p].rs) ;\n\treturn res ;\n}\n\nint rt = 0 ;\nsigned main() {\n\tios_base :: sync_with_stdio(false) ;\n\tcin.tie(nullptr) , cout.tie(nullptr) ;\n// code begin.\n\tcin >> n >> m ;\n\tfor(int i = 1 ; i <= n ; i ++) {\n\t\tcin >> data[i].d[0] >> data[i].d[1] >> data[i].val ;\n\t}\n\trt = build(1 , n , 0) ;\n\tfor(int i = 1 ; i <= m ; i ++) {\n\t\tcin >> a >> b >> c ;\n\t\tcout << qry(rt) << '\\n' ;\n\t}\n\treturn 0 ;\n// code end.\n}\n```",
        "postTime": 1580390160,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4475 \u3010\u5de7\u514b\u529b\u738b\u56fd\u3011"
    },
    {
        "content": "\u6709\u4e86KDtree+\u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u8be2\u7684\u57fa\u7840\u8fd9\u9898\u5c31\u5f88\u597d\u505a\u4e86\u3002\n\n\u9996\u5148\u7528KDtree\u7ef4\u62a4\u77e9\u9635\u5185\u7684\u6743\u503c\u603b\u548c\u4ee5\u53ca\u5206\u88c2\u70b9\u6743\u503c\uff0c\u4e4b\u540e\u5728\u67e5\u8be2\u7684\u65f6\u5019\u628a\u77e9\u9635\u7684\u56db\u4e2a\u70b9\u90fdcheck\u4e00\u904d\uff0c\n\n\u5982\u679c\u90fd\u6ee1\u8db3\u5c31\u76f4\u63a5\u52a0\u4e0a\u603b\u6743\u503c\uff0c\u5982\u679c\u90fd\u4e0d\u6ee1\u8db3\u5c31return\uff0c\u5426\u5219check\u5206\u88c2\u70b9\u66f4\u65b0\u7b54\u6848\u4e4b\u540e\u9012\u5f52\u5de6\u53f3\u5206\u88c2\u533a\u95f4\u3002\n\n\u8fd9\u9053\u9898\u505a\u4e861\u4e2a\u591a\u5c0f\u65f6\uff0c\u5f53\u65f6\u4e3b\u8981\u5361\u5230\u4e86\u77e9\u9635\u56db\u4e2a\u70b9\u7684check\u4e0a\uff0c\u800c\u6211\u60f3\u7684\u662f\u53ea\u679a\u4e3e\u4e24\u4e2a\u7aef\u70b9\u4f46\u9700\u8981\u5927\u91cf\u7684\u5206\u7c7b\u8ba8\u8bba\uff0c\u800c\u4e14y==0\u7684\u60c5\u51b5\u9700\u8981\u7528\u524d\u7f00\u548c\u7279\u6b8a\u5904\u7406\n```\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<string>\n#include<cstring>\n#include<map>\n#define int long long\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a>b?b:a)\n#define m(a) memset(a,0,sizeof(a))\n#define AA cout<<\"Alita\"<<endl\nusing namespace std;\nconst int N=5e4+10;\nint size,ans,n,m,now;\nstruct point\n{\n        int x[2],w;\n        int dis(point &b)\n        {\n                return abs(x[0]-b.x[0])+abs(x[1]-b.x[1]);\n        }\n        \n}s[N];\nbool comp(point a,point b)\n{\n        return a.x[now]<b.x[now];\n}\nstruct KDtree\n{\n        KDtree *ch[2];\n        int mn[2],mx[2],sum;\n        point p;\n        void init(point g)\n        {\n                ch[0]=ch[1]=NULL;\n                sum=g.w;\n                p=g;\n                mn[0]=mx[0]=g.x[0];\n                mn[1]=mx[1]=g.x[1];\n        }\n        void update(KDtree *k)\n        {\n                sum+=k->sum;\n                mn[0]=min(mn[0],k->mn[0]);\n                mx[0]=max(mx[0],k->mx[0]);\n                mn[1]=min(mn[1],k->mn[1]);\n                mx[1]=max(mx[1],k->mx[1]);\n        }\n        void pushup()\n        {\n                if(ch[0]!=NULL) update(ch[0]);\n                if(ch[1]!=NULL) update(ch[1]);\n        }\n        \n}*root,a[N];\nvoid build(KDtree *& k,int l,int r,int typ)\n{\n        if(l>r) return;\n        k=a+(size++);\n        int mid=(l+r)>>1;\n        now=typ;\n        nth_element(s+l,s+mid,s+r+1,comp);\n        k->init(s[mid]);\n        build(k->ch[0],l,mid-1,typ^1);\n        build(k->ch[1],mid+1,r,typ^1);\n        k->pushup();\n}\nbool check(int x,int y,int A,int B,int C)\n{\n        if(x*A+y*B<C) return true;\n        return false;\n}\nvoid query(KDtree *k,int x,int y,int z)\n{\n        if(k==NULL) return;\n        if(!check(k->mn[0],k->mn[1],x,y,z)&&\n           !check(k->mn[0],k->mx[1],x,y,z)&&\n           !check(k->mx[0],k->mn[1],x,y,z)&&\n           !check(k->mx[0],k->mx[1],x,y,z)) return;\n        if(check(k->mn[0],k->mn[1],x,y,z)&&\n           check(k->mn[0],k->mx[1],x,y,z)&&\n           check(k->mx[0],k->mn[1],x,y,z)&&\n           check(k->mx[0],k->mx[1],x,y,z))\n        {\n                ans+=k->sum;\n                return;\n        }\n        if(k->p.x[0]*x+k->p.x[1]*y<z) ans+=k->p.w;\n        if(k->ch[0]!=NULL) query(k->ch[0],x,y,z);\n        if(k->ch[1]!=NULL) query(k->ch[1],x,y,z);\n}\nsigned main()\n{\n        //freopen(\"1.in\",\"r\",stdin);\n        //freopen(\"1.out\",\"w\",stdout);\n        scanf(\"%lld%lld\",&n,&m);\n        for(int i=1;i<=n;i++)\n        {\n                scanf(\"%lld%lld%lld\",&s[i].x[0],&s[i].x[1],&s[i].w);\n        }\n        build(root,1,n,0);\n        for(int i=1,x,y,z;i<=m;i++)\n        {\n                ans=0;\n                scanf(\"%lld%lld%lld\",&x,&y,&z);\n                query(root,x,y,z);\n                printf(\"%lld\\n\",ans);\n        }\n        return 0;\n}\n```\n",
        "postTime": 1578364353,
        "uid": 199346,
        "name": "ATHOSD",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4475 \u3010\u5de7\u514b\u529b\u738b\u56fd\u3011"
    },
    {
        "content": "\u6211\u4eec\u53ef\u4ee5\u628a\u4e00\u5757\u5de7\u514b\u529b\u770b\u505a\u5e73\u9762\u4e0a\u7684\u70b9$(x,y)$\n\n\u90a3\u4e48\u663e\u7136\uff0c\u5bf9\u4e8e\u4e00\u6b21\u8be2\u95ee$(a,b)$\uff0c\u6211\u4eec\u53ef\u4ee5\u7528$x_{max}$\u6216$x_{min}$\uff0c\u4ee5\u53ca$y_{max}$\u6216$y_{min}$\u6765\u6c42\u51fa$ax+by$\u7684\u6700\u5927\u503c\uff08\u8fd9\u663e\u7136\u662f\u4e00\u4e2a\u5355\u8c03\u51fd\u6570\uff09\u3002\n\n\u6240\u4ee5\u6211\u4eec\u8003\u8651\u7528$kd-tree$\u6765\u7ef4\u62a4\u8fd9\u4e2a\u4e1c\u4e1c\u3002\n\n\u5bf9\u4e8e$kd-tree$\u4e2d\u5f53\u524d\u8282\u70b9$u$\u7684$max(ax+by)$\uff0c\u5206\u60c5\u51b5\u8ba8\u8bba\u4e00\u4e0b\uff1a\n\n1. \u82e5$a>0$\uff0c\u5219$max(ax)=a*x_{max}$\uff0c\u5426\u5219$max(ax)=a*x_{min}$\u3002\n2. \u82e5$b>0$\uff0c\u5219$max(by)=b*y_{max}$\uff0c\u5426\u5219$max(by)=b*y_{min}$\u3002\n\n\u90a3\u4e48$max(ax+by)$\u5c31\u4e3a$max(ax)+max(by)$\u4e86\u3002\n\n\u540c\u7406\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u6c42\u51fa$min(ax+by)$\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u5f53\u524d\u8282\u70b9\uff0c\u5982\u679c$c \\leq min(ax+by)$\uff0c\u6211\u4eec\u5c31return\u3002\n\n\u5982\u679c$max(ax+by)<c$\uff0c\u6211\u4eec\u5c31\u8fd4\u56de\u5f53\u524d\u6574\u68f5\u5b50\u6811\u7684\u7b54\u6848\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n\n#define N 50010\n#define ll long long\n#define lc t[u].ch[0]\n#define rc t[u].ch[1]\n\nusing namespace std;\n\nstruct Point\n{\n\tll num[2],val;\n\tPoint(){};\n\tPoint(ll x,ll y,ll h){num[0]=x,num[1]=y,val=h;}\n}p[N];\n\nstruct kd_tree\n{\n\tint ch[2],size;\n\tll maxn[2],minn[2],sum;\n\tPoint x;\n}t[N];\n\nconst double alpha=0.75;\n\nint n,m,tot,root;\nint top,rubbish[N];\nint cnt;\n\nbool cmp0(Point a,Point b)\n{\n\treturn a.num[0]<b.num[0];\n}\n\nbool cmp1(Point a,Point b)\n{\n\treturn a.num[1]<b.num[1];\n}\n\nint newnode()\n{\n\tif(top) return rubbish[top--];\n\treturn ++tot;\n}\n\nvoid up(int u)\n{\n\tfor(int i=0;i<2;i++)\n\t{\n\t\tt[u].minn[i]=t[u].maxn[i]=t[u].x.num[i];\n\t\tif(lc)\n\t\t{\n\t\t\tt[u].minn[i]=min(t[u].minn[i],t[lc].minn[i]);\n\t\t\tt[u].maxn[i]=max(t[u].maxn[i],t[lc].maxn[i]);\n\t\t}\n\t\tif(rc)\n\t\t{\n\t\t\tt[u].minn[i]=min(t[u].minn[i],t[rc].minn[i]);\n\t\t\tt[u].maxn[i]=max(t[u].maxn[i],t[rc].maxn[i]);\n\t\t}\n\t}\n\tt[u].size=t[lc].size+t[rc].size+1;\n\tt[u].sum=t[lc].sum+t[rc].sum+t[u].x.val;\n}\n\nvoid slap(int u)\n{\n\tif(!u) return;\n\tp[++cnt]=t[u].x;\n\trubbish[++top]=u;\n\tslap(lc);\n\tslap(rc);\n}\n\nint rebuild(int l,int r,bool d)\n{\n\tif(l>r) return 0;\n\tint mid=(l+r)>>1,u=newnode();\n\tnth_element(p+l,p+mid,p+r+1,d?cmp1:cmp0);\n\tt[u].x=p[mid];\n\tlc=rebuild(l,mid-1,d^1);\n\trc=rebuild(mid+1,r,d^1);\n\tup(u);\n\treturn u;\n}\n\nvoid check(int &u,bool d)\n{\n\tif(t[lc].size>t[u].size*alpha||t[rc].size>t[u].size*alpha)\n\t{\n\t\tcnt=0;\n\t\tslap(u);\n\t\tu=rebuild(1,t[u].size,d);\n\t}\n}\n\nll query(int u,ll a,ll b,ll c)\n{\n\tif(!u) return 0;\n\tll maxx=t[u].maxn[0]*a,minx=t[u].minn[0]*a;\n\tll maxy=t[u].maxn[1]*b,miny=t[u].minn[1]*b;\n\tif(a<0)swap(maxx,minx);\n\tif(b<0)swap(maxy,miny);\n\tif(minx+miny>=c) return 0;\n\tif(maxx+maxy<c) return t[u].sum;\n\tll ans=0;\n\tif(t[u].x.num[0]*a+t[u].x.num[1]*b<c) ans+=t[u].x.val;\n\tans+=query(lc,a,b,c)+query(rc,a,b,c);\n\treturn ans;\n}\n\ninline ll read()\n{\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tx=(x<<1)+(x<<3)+(ch^'0');\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tp[i].num[0]=read(),p[i].num[1]=read(),p[i].val=read();\n\troot=rebuild(1,n,0);\n\twhile(m--)\n\t{\n\t\tll a=read(),b=read(),c=read();\n\t\tprintf(\"%lld\\n\",query(root,a,b,c));\n\t}\n\treturn 0;\n}\n/*\n3 3\n1 2 5\n3 1 4\n2 2 1\n2 1 6\n1 3 5\n1 3 7\n*/\n```\n\n",
        "postTime": 1577455436,
        "uid": 118318,
        "name": "ez_lcw",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4475 \u3010\u5de7\u514b\u529b\u738b\u56fd\u3011"
    }
]