[
    {
        "content": "\u672c\u6587\u662f \u300cByakkai OI 2021\u300dEaquira \u4e00\u9898\u7684\u5b98\u65b9\u9898\u89e3\u3002  \n\u672c\u6587\u540c\u6b65\u53d1\u8868\u4e8e\u6211\u7684\u535a\u5ba2 <https://www.alpha1022.me/articles/byakkai-oi-2021-eaquira.htm>\u3002  \n\u5173\u4e8e Byakkai OI \u7684\u66f4\u591a\u60c5\u62a5\u53ef\u4ee5\u5728[\u8fd9\u91cc](https://www.luogu.com.cn/blog/your-alpha1022/byakkai-oi)\u627e\u5230\u3002\n\n---\n\n\u4e0d\u96be\u770b\u51fa\u4e00\u4e2a\u591a\u9879\u5f0f\u590d\u5408\u7684\u6a21\u578b\uff1a\u5148\u8ba1\u7b97\u533a\u95f4\u4e4b\u95f4\u7684\u9ed1\u767d\u5173\u7cfb\uff0c\u518d\u4ee5\u6bcf\u4e2a\u533a\u95f4\u4e3a\u5355\u4f4d\u590d\u5408\u3002\n\n\u8003\u8651\u5185\u5c42\u4e00\u4e2a\u533a\u95f4\u7684 GF\uff1a\n$$\nF(x) = \\sum\\limits_{i\\ge 1} \\binom{i+1}2 x^i = \\frac x{(1-x)^3}\n$$\n\n\u5bf9\u4e8e\u5916\u5c42\uff0c\u5bb9\u6613\u77e5\u9053\u6240\u6709\u65b9\u6848\u90fd\u5f62\u5982\u300c\u767d\u9ed1\u9ed1\u2026\u2026\u9ed1\u767d\u9ed1\u9ed1\u2026\u2026\u9ed1\u767d\u9ed1\u9ed1\u2026\u2026\u9ed1\uff08\u767d\uff09\u300d\uff08\u9664\u4e86\u9996\u9ed1\u5c3e\u767d\uff0c\u4f46\u662f\u6839\u636e\u5bf9\u79f0\u6027\u5bb9\u6613\u5f97\u5230\u8fd9\u79cd\u65b9\u6848\u6570\uff09\u3002\u56e0\u6b64\u53ef\u4ee5\u8003\u8651\u4ee5\u5f62\u5982\u300c\u767d\u9ed1\u9ed1\u2026\u2026\u9ed1\u300d\u7684\u57fa\u7840\u5355\u4f4d\u6784\u9020\u5e8f\u5217\u6765\u523b\u753b\u3002  \n\u4ee4\u4e00\u4e2a\u6781\u957f\u8fde\u7eed\u9ed1\u533a\u95f4\u6bb5\u7684 GF \u4e3a\uff08\u7528 $w$ \u5143\u8bb0\u5f55\u6743\u503c\uff09\n$$\nG(x) = \\sum\\limits_{i\\ge 1} i x^i w^i (1+w) = \\frac{xw(1+w)}{(1-xw)^2}\n$$\n\n\u5219\u7b54\u6848\u5e94\u5f53\u5f62\u5982\n$$\n\\frac{2+F}{1-F(G \\circ F)}\n$$\n\n\u7531\u4e8e\u6211\u4eec\u9700\u8981\u6c42\u5f97\u7684\u4ec5\u662f $x^n$ \u9879\u7cfb\u6570\uff0c\u56e0\u6b64\u53ef\u4ee5\u8003\u8651\u62c9\u683c\u6717\u65e5\u53cd\u6f14\u3002  \n\u6ce8\u610f\u5230 $F$ \u5177\u6709\u7b80\u5355\u7684\u5c01\u95ed\u5f62\u5f0f\uff0c\u4ece\u800c\u5bb9\u6613\u725b\u987f\u8fed\u4ee3\u6c42\u51fa $F$ \u7684\u590d\u5408\u9006\u3002  \n\u7136\u540e\u4ee4\n$$\nW = \\frac{2+x}{1-xG}\n$$\n\n\u5219\u7b54\u6848\u4e3a\n$$\n[x^n]\\frac{2+F}{1-FG} = \\frac1n [x^{n-1}]W'(x)\\left(\\frac x{F^{-1}(x)}\\right)^n\n$$\n\n\u6ce8\u610f $-1$ \u662f\u51fd\u6570\u5e42\u3002\n\n\u7136\u540e\u8003\u8651 $W'$\uff1a\n$$\n\\begin{aligned}\nW'\n&= \\left(\\frac{2+x}{1-\\frac{x^2w+x^2w^2}{(1-xw)^2}}\\right)' \\\\\n&= \\left(\\frac{2-4xw+2x^2w^2+x-2x^2w+x^3w^2}{1-2xw-x^2w}\\right)' \\\\\n&= \\frac{1+4xw^2+x^2w+3x^2w^2-4x^2w^3-4x^3w^3-x^4w^3}{(1-2xw-x^2w)^2}\n\\end{aligned}\n$$\n\n\u6211\u4eec\u9700\u8981\u63d0\u53d6\u4e0a\u5f0f\u7684 $w^s$ \u9879\u7cfb\u6570\u3002  \n\u8bbe $p(s) = x^s(x+2)^s$\u3002  \n\u5219\u6709\n$$\n\\begin{aligned}\n[w^s]W'\n&= [w^s] (1+4xw^2+x^2w+3x^2w^2-4x^2w^3-4x^3w^3-x^4w^3)\\sum\\limits_{i\\ge 0}(i+1)x^i(x+2)^iw^i \\\\\n&= (s+1)p(s)+4(s-1)xp(s-2)+sx^2p(s-1)+3(s-1)x^2p(s-2) \\\\\n&- 4(s-2)x^2p(s-3)-4(s-2)x^3p(s-3)-(s-2)x^4p(s-3)\n\\end{aligned}\n$$\n\n\u4ee4 $V = \\left(\\frac x{F^{-1}}\\right)^n$\uff0c\u5219\u95ee\u9898\u53d8\u4e3a\u8ba1\u7b97 $5$ \u4e2a\n$$\n[x^r] \\frac{V(x)}{1-tx(x+2)}\n$$\n\n\u4ee4 $P(x)=x(x+2)$\uff0c$Q(x)=V(P^{-1}(x))$\uff0c$U(x) = \\frac{Q(x)}{1-tx}$\uff0c\u5219\u6839\u636e\u6269\u5c55\u62c9\u683c\u6717\u65e5\u53cd\u6f14\u6709\n$$\n[x^r] \\frac{V(x)}{1-tx(1+x)} = \\frac1r[x^{r-1}]U'(x)\\left(\\frac x{P^{-1}(x)}\\right)^r\n$$\n\n$P(x)$ \u7684\u590d\u5408\u9006\u975e\u5e38\u597d\u6c42\uff0c\u5c31\u662f\n$$\n\\sqrt{1+x}-1\n$$\n\n\u53ef\u4ee5\u968f\u624b\u5e7f\u4e49\u4e8c\u9879\u5f0f\u5b9a\u7406\u5c55\u5f00\u4e00\u4e0b\uff0c\u4e0d\u5acc\u9ebb\u70e6\u7684\u4e5f\u53ef\u4ee5\u5199\u4e2a\u591a\u9879\u5f0f\u5f00\u65b9\u3002  \n\uff08\u4f46\u662f\u5982\u679c\u4f60\u4e0d\u4f1a\u5c55\u5f00\u7684\u8bdd\u5e95\u4e0b\u5c31\u505a\u4e0d\u4e86\u4e86\uff09\n\n\u7ee7\u7eed\u8003\u8651\n$$\n\\begin{aligned}\nU'\n&= \\left(\\frac{Q(x)}{1-tx}\\right)' \\\\\n&= \\frac{Q'(x)(1-tx)+Q(x)(1-tx)'}{(1-tx)^2} \\\\\n&= \\frac{Q'(x)+t(Q(x)-xQ'(x))}{(1-tx)^2}\n\\end{aligned}\n$$\n\n\u518d\u4ee4 $R(x) = \\left(\\frac x{P^{-1}(x)}\\right)^r$\u3002  \n\u5219\n$$\n\\begin{aligned}\n[x^{r-1}t^c]U'(x)R(x)\n&= [x^{r-1}t^c]\\left(\\frac{Q'(x)+t(Q(x)-xQ'(x))}{(1-tx)^2}\\right) R(x) \\\\\n&= [x^{r-1}t^c]\\left(Q'(x)\\sum\\limits_{i\\ge 0} (i+1)t^ix^i + (Q(x)-xQ'(x))\\sum\\limits_{i\\ge 0}(i+1)t^{i+1}x^i\\right) R(x) \\\\\n&= (c+1) [x^{r-c-1}] Q'(x)R(x) + c [x^{r-c}] (Q(x)-xQ'(x))R(x)\n\\end{aligned}\n$$\n\n\u95ee\u9898\u53c8\u53d8\u4e3a\u6c42 $Q(x)$\u3002  \n\u8003\u8651\u6c42 $V(\\sqrt{1+x}-1)$\u3002  \n\u53ef\u4ee5\u9996\u5148\u6c42 $V'(x) = V(x-1)$\uff08\u8bb0\u4f4f\u8fd9\u4e2a $'$ \u4e0d\u662f\u6c42\u5bfc\uff09\uff0c\u7136\u540e\u8ba1\u7b97 $V'(\\sqrt{1+x})$\u3002  \n\u8fd9\u90e8\u5206\u53ef\u4ee5\u53c2\u8003 CF923E\u3002\n\n\u8003\u8651\u5bf9\u7cfb\u6570\u7684\u5947\u5076\u6027\u8fdb\u884c\u8ba8\u8bba\u3002  \n\u5bf9\u4e8e\u5076\u6570\u90e8\u5206\u7684\u7cfb\u6570\uff0c\u5355\u72ec\u63d0\u53d6\u51fa\u6765\u5e76\u590d\u5408 $\\sqrt x$\uff08\u8fd9\u4e2a\u65f6\u5019\u5c31\u76f8\u5f53\u4e8e\u628a\u6b21\u6570\u9664\u4ee5\u4e8c\uff09\u5c31\u53d8\u6210\u4e86\u590d\u5408 $1+x$\uff0c\u4e5f\u6bd4\u8f83\u7b80\u5355\u3002  \n\u5bf9\u4e8e\u5947\u6570\u90e8\u5206\u7684\u7cfb\u6570\uff0c\u9996\u5148\u8003\u8651\u4e00\u4e0b $(1+x)^{i+1/2}$\uff1a\n$$\n\\begin{aligned}\n(1+x)^{i+1/2}\n&= \\sum\\limits_{j\\ge 0} \\binom{i+\\frac12}j x^j \\\\\n&= \\sum\\limits_{j\\ge 0} x^j \\frac{(2i+1)\\cdot(2i-1)\\cdots(2i-2j+3)}{j!2^j} \\\\\n&= \\sum\\limits_{j\\ge0} x^j \\frac{(2i+1)!!}{j! 2^j (2i-2j+1)!!}\n\\end{aligned}\n$$\n\n\u7136\u540e\u4ee3\u5165\u7cfb\u6570\n$$\n\\begin{aligned}\n\\sum\\limits_{i\\ge 0} v'_{2i+1} (1+x)^{i+1/2}\n&= \\sum\\limits_{i\\ge 0} v'_{2i+1} \\sum\\limits_{j\\ge 0} x^j \\frac{(2i+1)!!}{j! 2^j (2i-2j+1)!!} \\\\\n&= \\sum\\limits_{j\\ge 0} \\frac{x^j}{j! 2^j} \\sum\\limits_{i\\ge 0} \\frac{v'_{2i+1}(2i+1)!!}{(2i-2j+1)!!}\n\\end{aligned}\n$$\n\n\u53ef\u4ee5\u5377\u79ef\u89e3\u51b3\u3002\n\n\u590d\u6742\u5ea6 $O(n \\log n)$\u3002  \nstd \u6700\u6162\u70b9\u5927\u6982\u662f 1.25s\u3002\n\n---\n\n\u53e6\u5916\uff0c\u8fd9\u4efd\u9898\u89e3\u662f\u6211\u4e00\u6bb5\u65f6\u95f4\u524d\u5199\u7684\u3002\u5b9e\u9645\u4e0a\u5e94\u7528\u53e6\u7c7b\u62c9\u683c\u6717\u65e5\u53cd\u6f14\u7684\u5e42\u7ea7\u6570\u5f62\u5f0f\u53ef\u4ee5\u51cf\u5c11\u4e00\u70b9\u70b9\u7ec6\u8282\u7684\u8ba8\u8bba\uff08\u5e76\u6ca1\u6709\u51cf\u5c0f\u591a\u5c11\uff09\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <utility>\n#include <algorithm>\n#define add(a,b) (a + b >= mod ? a + b - mod : a + b)\n#define dec(a,b) (a < b ? a - b + mod : a - b)\nusing namespace std;\nconst int N = 2e5;\nconst int mod = 998244353;\nint n,m,type;\nint wfac_[4 * N + 5],*wfac = wfac_ + 2 * N;\nint iwfac_[4 * N + 5],*iwfac = iwfac_ + 2 * N;\nint ans[N + 5];\ninline int fpow(int a,int b)\n{\n    int ret = 1;\n    for(;b;b >>= 1)\n        (b & 1) && (ret = (long long)ret * a % mod),a = (long long)a * a % mod;\n    return ret;\n}\nnamespace Poly\n{\n    const int LG = 19;\n    const int N = 1 << LG + 1;\n    const int G = 31;\n    int lg2[N + 5];\n    int rev[N + 5],fac[N + 5],ifac[N + 5],inv[N + 5];\n    int rt[N + 5];\n    inline void init()\n    {\n        for(register int i = 2;i <= N;++i)\n            lg2[i] = lg2[i >> 1] + 1;\n        rt[0] = 1,rt[1 << LG] = fpow(31,1 << 21 - LG);\n        for(register int i = LG;i;--i)\n            rt[1 << i - 1] = (long long)rt[1 << i] * rt[1 << i] % mod;\n        for(register int i = 1;i < N;++i)\n            rt[i] = (long long)rt[i & i - 1] * rt[i & -i] % mod;\n        fac[0] = 1;\n        for(register int i = 1;i <= N;++i)\n            fac[i] = (long long)fac[i - 1] * i % mod;\n        ifac[N] = fpow(fac[N],mod - 2);\n        for(register int i = N;i;--i)\n            ifac[i - 1] = (long long)ifac[i] * i % mod;\n        for(register int i = 1;i <= N;++i)\n            inv[i] = (long long)ifac[i] * fac[i - 1] % mod;\n    }\n    struct poly\n    {\n        vector<int> a;\n        inline poly(int x = 0)\n        {\n            x && (a.push_back(x),1);\n        }\n        inline poly(const vector<int> &o)\n        {\n            a = o,shrink();\n        }\n        inline poly(const poly &o)\n        {\n            a = o.a,shrink();\n        }\n        inline void shrink()\n        {\n            for(;!a.empty() && !a.back();a.pop_back());\n        }\n        inline int size() const\n        {\n            return a.size();\n        }\n        inline void resize(int x)\n        {\n            a.resize(x);\n        }\n        inline int operator[](int x) const\n        {\n            if(x < 0 || x >= size())\n                return 0;\n            return a[x];\n        }\n        inline void clear()\n        {\n            vector<int>().swap(a);\n        }\n        inline poly rever() const\n        {\n            return poly(vector<int>(a.rbegin(),a.rend()));\n        }\n\t\tinline void dif()\n\t\t{\n\t\t\tint n = size();\n            for(register int i = 0,len = n >> 1;len;++i,len >>= 1)\n                for(register int j = 0,*w = rt;j < n;j += len << 1,++w)\n                    for(register int k = j,R;k < j + len;++k)\n                        R = (long long)*w * a[k + len] % mod,\n                        a[k + len] = dec(a[k],R),\n                        a[k] = add(a[k],R);\n\t\t}\n        inline void dit()\n        {\n\t\t\tint n = size();\n            for(register int i = 0,len = 1;len < n;++i,len <<= 1)\n                for(register int j = 0,*w = rt;j < n;j += len << 1,++w)\n                    for(register int k = j,R;k < j + len;++k)\n                        R = add(a[k],a[k + len]),\n                        a[k + len] = (long long)(a[k] - a[k + len] + mod) * *w % mod,\n                        a[k] = R;\n            reverse(a.begin() + 1,a.end());\n            for(register int i = 0;i < n;++i)\n                a[i] = (long long)a[i] * inv[n] % mod;\n\t\t}\n        inline void ntt(int type = 1)\n        {\n            type == 1 ? dif() : dit();\n        }\n        friend inline poly operator+(const poly &a,const poly &b)\n        {\n            vector<int> ret(max(a.size(),b.size()));\n            for(register int i = 0;i < ret.size();++i)\n                ret[i] = add(a[i],b[i]);\n            return poly(ret);\n        }\n        friend inline poly operator-(const poly &a,const poly &b)\n        {\n            vector<int> ret(max(a.size(),b.size()));\n            for(register int i = 0;i < ret.size();++i)\n                ret[i] = dec(a[i],b[i]);\n            return poly(ret);\n        }\n        friend inline poly operator*(poly a,poly b)\n        {\n            if(a.a.empty() || b.a.empty())\n                return poly();\n            if(a.size() < 40 || b.size() < 40)\n            {\n                if(a.size() > b.size())\n                    swap(a,b);\n                poly ret;\n                ret.resize(a.size() + b.size() - 1);\n                for(register int i = 0;i < ret.size();++i)\n                    for(register int j = 0;j <= i && j < a.size();++j)\n                        ret.a[i] = (ret[i] + (long long)a[j] * b[i - j]) % mod;\n                ret.shrink();\n                return ret;\n            }\n            int lim = 1,tot = a.size() + b.size() - 1;\n            for(;lim < tot;lim <<= 1);\n            a.resize(lim),b.resize(lim);\n            a.ntt(),b.ntt();\n            for(register int i = 0;i < lim;++i)\n                a.a[i] = (long long)a[i] * b[i] % mod;\n            a.ntt(-1),a.shrink();\n            return a;\n        }\n        poly &operator+=(const poly &o)\n        {\n            resize(max(size(),o.size()));\n            for(register int i = 0;i < o.size();++i)\n                a[i] = add(a[i],o[i]);\n            return *this;\n        }\n        poly &operator-=(const poly &o)\n        {\n            resize(max(size(),o.size()));\n            for(register int i = 0;i < o.size();++i)\n                a[i] = dec(a[i],o[i]);\n            return *this;\n        }\n        poly &operator*=(poly o)\n        {\n            return (*this) = (*this) * o;\n        }\n        poly deriv() const\n        {\n            if(a.empty())\n                return poly();\n            vector<int> ret(size() - 1);\n            for(register int i = 0;i < size() - 1;++i)\n                ret[i] = (long long)(i + 1) * a[i + 1] % mod;\n            return poly(ret);\n        }\n        poly integ() const\n        {\n            if(a.empty())\n                return poly();\n            vector<int> ret(size() + 1);\n            for(register int i = 0;i < size();++i)\n                ret[i + 1] = (long long)a[i] * inv[i + 1] % mod;\n            return poly(ret);\n        }\n        inline poly modxn(int n) const\n        {\n            if(a.empty())\n                return poly();\n            n = min(n,size());\n            return poly(vector<int>(a.begin(),a.begin() + n));\n        }\n        inline poly inver(int m) const\n        {\n            poly ret(fpow(a[0],mod - 2)),f,g;\n            for(register int k = 1;k < m;)\n            {\n                k <<= 1,f.resize(k),g.resize(k);\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (*this)[i],g.a[i] = ret[i];\n                f.ntt(),g.ntt();\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (long long)f[i] * g[i] % mod;\n                f.ntt(-1);\n                for(register int i = 0;i < (k >> 1);++i)\n                    f.a[i] = 0;\n                f.ntt();\n                for(register int i = 0;i < k;++i)\n                    f.a[i] = (long long)f[i] * g[i] % mod;\n                f.ntt(-1);\n                ret.resize(k);\n                for(register int i = (k >> 1);i < k;++i)\n                    ret.a[i] = dec(0,f[i]);\n            }\n            return ret.modxn(m);\n        }\n        inline pair<poly,poly> div(poly o) const\n        {\n            if(size() < o.size())\n                return make_pair(poly(),*this);\n            poly f,g;\n            f = (rever().modxn(size() - o.size() + 1) * o.rever().inver(size() - o.size() + 1)).modxn(size() - o.size() + 1).rever();\n            g = (modxn(o.size() - 1) - o.modxn(o.size() - 1) * f.modxn(o.size() - 1)).modxn(o.size() - 1);\n            return make_pair(f,g);\n        }\n        inline poly log(int m) const\n        {\n            return (deriv() * inver(m)).integ().modxn(m);\n        }\n        inline poly exp(int m) const\n        {\n            poly ret(1),iv,it,d = deriv(),itd,itd0,t1;\n            if(m < 70)\n            {\n                ret.resize(m);\n                for(register int i = 1;i < m;++i)\n                {\n                    for(register int j = 1;j <= i;++j)\n                        ret.a[i] = (ret[i] + (long long)j * operator[](j) % mod * ret[i - j]) % mod;\n                    ret.a[i] = (long long)ret[i] * inv[i] % mod;\n                }\n                return ret;\n            }\n            for(register int k = 1;k < m;)\n            {\n                k <<= 1;\n                it.resize(k >> 1);\n                for(register int i = 0;i < (k >> 1);++i)\n                    it.a[i] = ret[i];\n                itd = it.deriv(),itd.resize(k >> 1);\n                iv = ret.inver(k >> 1),iv.resize(k >> 1);\n                it.ntt(),itd.ntt(),iv.ntt();\n                for(register int i = 0;i < (k >> 1);++i)\n                    it.a[i] = (long long)it[i] * iv[i] % mod,\n                    itd.a[i] = (long long)itd[i] * iv[i] % mod;\n                it.ntt(-1),itd.ntt(-1),it.a[0] = dec(it[0],1);\n                for(register int i = 0;i < k - 1;++i)\n                    itd.a[i % (k >> 1)] = dec(itd[i % (k >> 1)],d[i]);\n                itd0.resize((k >> 1) - 1);\n                for(register int i = 0;i < (k >> 1) - 1;++i)\n                    itd0.a[i] = d[i];\n                itd0 = (itd0 * it).modxn((k >> 1) - 1);\n                t1.resize(k - 1);\n                for(register int i = (k >> 1) - 1;i < k - 1;++i)\n                    t1.a[i] = itd[(i + (k >> 1)) % (k >> 1)];\n                for(register int i = k >> 1;i < k - 1;++i)\n                    t1.a[i] = dec(t1[i],itd0[i - (k >> 1)]);\n                t1 = t1.integ();\n                for(register int i = 0;i < (k >> 1);++i)\n                    t1.a[i] = t1[i + (k >> 1)];\n                for(register int i = (k >> 1);i < k;++i)\n                    t1.a[i] = 0;\n                t1.resize(k >> 1),t1 = (t1 * ret).modxn(k >> 1),t1.resize(k);\n                for(register int i = (k >> 1);i < k;++i)\n                    t1.a[i] = t1[i - (k >> 1)];\n                for(register int i = 0;i < (k >> 1);++i)\n                    t1.a[i] = 0;\n                ret -= t1;\n            }\n            return ret.modxn(m);\n        }\n        inline poly pow(int m,int k1,int k2 = -1) const\n        {\n            if(a.empty())\n                return poly();\n            if(k2 == -1)\n                k2 = k1;\n            int t = 0;\n            for(;t < size() && !a[t];++t);\n            if((long long)t * k1 >= m)\n                return poly();\n            poly ret;\n            ret.resize(m);\n            int u = fpow(a[t],mod - 2),v = fpow(a[t],k2);\n            for(register int i = 0;i < m - t * k1;++i)\n                ret.a[i] = (long long)operator[](i + t) * u % mod;\n            ret = ret.log(m - t * k1);\n            for(register int i = 0;i < ret.size();++i)\n                ret.a[i] = (long long)ret[i] * k1 % mod;\n            ret = ret.exp(m - t * k1),t *= k1,ret.resize(m);\n            for(register int i = m - 1;i >= t;--i)\n                ret.a[i] = (long long)ret[i - t] * v % mod;\n            for(register int i = 0;i < t;++i)\n                ret.a[i] = 0;\n            return ret;\n        }\n    };\n}\nusing Poly::init;\nusing Poly::poly;\ninline int C(int n,int m)\n{\n    return n < m ? 0 : (long long)Poly::fac[n] * Poly::ifac[m] % mod * Poly::ifac[n - m] % mod;\n}\npoly f,v,v1,p,q,r;\ninline poly solve(int m)\n{\n    poly ret,t,t2,t3;\n    for(register int k = 1;k < m;)\n    {\n        k <<= 1,t.resize(k << 1),t2.resize(k << 1),t3.resize(k << 1);\n        for(register int i = 0;i < (k << 1);++i)\n            t.a[i] = dec(0,ret[i]);\n        t.a[0] = add(t[0],1);\n        t.ntt();\n        for(register int i = 0;i < (k << 1);++i)\n            t2.a[i] = (long long)t[i] * t[i] % mod;\n        t2.ntt(-1);\n        for(register int i = k;i < (k << 1);++i)\n            t2.a[i] = 0;\n        t3 = t2,t3.ntt();\n        for(register int i = 0;i < (k << 1);++i)\n            t3.a[i] = (long long)t3[i] * t[i] % mod;\n        t3.ntt(-1),t2.resize(k),t3.resize(k);\n        for(register int i = k - 1;i;--i)\n            t2.a[i] = t2[i - 1],t3.a[i] = t3[i - 1];\n        t2.a[0] = t3.a[0] = 0;\n        for(register int i = 0;i < k;++i)\n            t2.a[i] = 3LL * t2[i] % mod,\n            t3.a[i] = dec(t3[i],ret[i]);\n        t2.a[0] = add(t2[0],1);\n        t2 = t2.inver(k >> 1),t2.resize(k);\n        for(register int i = 0;i < (k >> 1);++i)\n            t3.a[i] = t3[i + (k >> 1)];\n        for(register int i = (k >> 1);i < k;++i)\n            t2.a[i] = t3.a[i] = 0;\n        t2.ntt(),t3.ntt();\n        for(register int i = 0;i < k;++i)\n            t3.a[i] = (long long)t3[i] * t2[i] % mod;\n        t3.ntt(-1);\n        ret.resize(k);\n        for(register int i = (k >> 1);i < k;++i)\n            ret.a[i] = t3[i - (k >> 1)];\n    }\n    return ret.modxn(m);\n}\npoly t1,t2;\nint cur[N + 5];\ninline void calc(int n)\n{\n    memset(cur,0,sizeof cur);\n    if(n == 0)\n        cur[0] = v[0];\n    if(n <= 0)\n        return ;\n    poly q1 = q.deriv().modxn(n),q2 = q.modxn(n);\n    for(register int i = 0;i < n;++i)\n        q2.a[i] = dec(q2[i],q1[i - 1]);\n    q1 *= r.modxn(n),q2 *= r.modxn(n);\n    for(register int i = 0;i <= n;++i)\n        cur[i] = ((long long)(i + 1) * q1[n - i - 1] + (long long)i * q2[n - i]) % mod * Poly::inv[n] % mod;\n}\nint sum;\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&type);\n    if(type == 1)\n    {\n        f.resize(n + 1);\n        for(register int i = 1;i <= n;++i)\n            f.a[i] = C(i + 1,2);\n        t2 = 1 - f,t2 = (t2 * t2).modxn(n + 1);\n        t2 = (f * t2.inver(n + 1)).modxn(n + 1),t2 *= 2;\n        f = ((2 + f) * (1 - f * t2).inver(n + 1)).modxn(n + 1);\n        printf(\"%d\\n\",f[n]);\n        return 0;\n    }\n    f = solve(n + 1),f.resize(n + 1);\n    for(register int i = 0;i < n;++i)\n        f.a[i] = f[i + 1];\n    f.resize(n),v = f.pow(n,mod - n,mod - n - 1);\n    p.resize(n + 1);\n    for(register int i = 1,pw = mod - Poly::inv[4];i <= n;++i,pw = (long long)pw * (mod - Poly::inv[4]) % mod)\n        p.a[i] = (long long)(mod - 2) * pw % mod * Poly::inv[i] % mod * C(2 * i - 2,i - 1) % mod;\n    for(register int i = 0;i < n;++i)\n        p.a[i] = p[i + 1];\n    p.resize(n);\n    t1.resize(n),t2.resize(n);\n    for(register int i = 0;i < n;++i)\n        t1.a[n - 1 - i] = (long long)Poly::fac[i] * v[i] % mod,\n        t2.a[i] = (long long)(i & 1 ? mod - 1 : 1) * Poly::ifac[i] % mod;\n    t1 *= t2;\n    v1.resize(n);\n    for(register int i = 0;i < n;++i)\n        v1.a[i] = (long long)t1[n - 1 - i] * Poly::ifac[i] % mod;\n    q.resize(n);\n    t1.resize(n),t2.resize(n);\n    for(register int i = 0;i < n;++i)\n        t1.a[n - 1 - i] = (long long)Poly::fac[i] * v1[i << 1] % mod,\n        t2.a[i] = Poly::ifac[i];\n    t1 *= t2;\n    for(register int i = 0;i < n;++i)\n        q.a[i] = (long long)t1[n - 1 - i] * Poly::ifac[i] % mod;\n    m = n + 1 >> 1;\n    t1.resize(m),t2.resize(n + m - 1);\n    wfac[1] = iwfac[1] = wfac[-1] = iwfac[-1] = 1;\n    for(register int i = 3;i <= 2 * n;i += 2)\n        wfac[i] = (long long)wfac[i - 2] * i % mod,\n        iwfac[i] = (long long)iwfac[i - 2] * Poly::inv[i] % mod;\n    for(register int i = -1;i - 2 >= -2 * n;i -= 2)\n        wfac[i - 2] = (long long)wfac[i] * (mod - 1) % mod * Poly::inv[-i] % mod,\n        iwfac[i - 2] = (long long)iwfac[i] * (i + mod) % mod;\n    for(register int i = 0;i < m;++i)\n        t1.a[i] = (long long)v1[(i << 1) | 1] * wfac[(i << 1) | 1] % mod;\n    for(register int i = 0;i < n + m - 1;++i)\n        t2.a[i] = iwfac[2 * ((n + m - 2 - i) - n + 1) + 1];\n    t1 *= t2;\n    for(register int i = 0,pw = 1;i < n;++i,pw = (long long)pw * Poly::inv[2] % mod)\n        q.a[i] = (q[i] + (long long)t1[m + i - 1] * Poly::ifac[i] % mod * pw) % mod;\n    r = p.pow(n,(mod - n + 1) % mod,mod - n),calc(n - 1);\n    for(register int i = 0;i <= n;++i)\n        ans[i] = (long long)(i + 1) * cur[i] % mod;\n    r = (r * p).modxn(n),calc(n - 2);\n    for(register int i = 2;i <= n;++i)\n        ans[i] = (ans[i] + 4LL * (i - 1) % mod * cur[i - 2]) % mod;\n    r = (r * p).modxn(n),calc(n - 3);\n    for(register int i = 1;i <= n;++i)\n        ans[i] = (ans[i] + (long long)i * cur[i - 1]) % mod;\n    for(register int i = 2;i <= n;++i)\n        ans[i] = (ans[i] + 3LL * (i - 1) % mod * cur[i - 2]) % mod;\n    for(register int i = 3;i <= n;++i)\n        ans[i] = (ans[i] - 4LL * (i - 2) % mod * cur[i - 3] % mod + mod) % mod;\n    r = (r * p).modxn(n),calc(n - 4);\n    for(register int i = 3;i <= n;++i)\n        ans[i] = (ans[i] - 4LL * (i - 2) % mod * cur[i - 3] % mod + mod) % mod;\n    r = (r * p).modxn(n),calc(n - 5);\n    for(register int i = 3;i <= n;++i)\n        ans[i] = (ans[i] - (long long)(i - 2) * cur[i - 3] % mod + mod) % mod;\n    for(register int i = 0;i <= n;++i)\n        ans[i] = (long long)ans[i] * Poly::inv[n] % mod;\n    if(!type)\n        for(register int i = 0;i <= n;++i)\n            printf(\"%d%c\",ans[i],\" \\n\"[i == n]);\n    else\n    {\n        for(register int i = 0;i <= n;++i)\n            sum = add(sum,ans[i]);\n        printf(\"%d\\n\",sum);\n    }\n}\n```",
        "postTime": 1617935054,
        "uid": 75840,
        "name": "deserter",
        "ccfLevel": 0,
        "title": "\u300cByakkai OI 2021\u300dEaquira \u5b98\u65b9\u9898\u89e3"
    }
]