[
    {
        "content": "\u6700\u65e0\u8111LCT\u9898\u89e3\uff0cDalao\u4eec\u7684\u5404\u79cd\u7b97\u6cd5\u90fd\u6bd4\u8fd9\u4e2a\u597d\u591a\u5566\u3002\u3002\u3002\n\n\u552f\u4e00\u7684\u597d\u5904\u5c31\u662f\u53ea\u7ba1\u7801\u4ee3\u7801\u5c31\u597d\u4e86\n\n\u5f00\u6218cut\uff0c\u505c\u6218link\uff0c\u8be2\u95eefindroot\u5224\u8fde\u901a\u6027\n\n\u592a\u65e0\u8111\uff0c\u5e94\u8be5\u4e0d\u7528\u6253\u6ce8\u91ca\u4e86\u3002\u5e38\u6570\u5927\u5c31\u4e0d\u7528\u8bf4\u4e86\uff08\u9003\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#define R register int\n#define I inline void\n#define lc c[x][0]\n#define rc c[x][1]\n#define G ch=getchar()\n#define gc G;while(ch<'-')G\n#define in(z) gc;z=ch&15;G;while(ch>'-')z*=10,z+=ch&15,G;\nconst int N=300009;\nint f[N],c[N][2],st[N],u[N],v[N];\nbool r[N];\ninline bool nroot(R x){\n\treturn c[f[x]][0]==x||c[f[x]][1]==x;\n}\nI pushdown(R x){\n\tif(r[x]){\n\t\tR t=lc;lc=rc;rc=t;\n\t\tr[lc]^=1,r[rc]^=1,r[x]=0;\n\t}\n}\nI rotate(R x){\n\tR y=f[x],z=f[y],k=c[y][1]==x,w=c[x][!k];\n\tif(nroot(y))c[z][c[z][1]==y]=x;c[x][!k]=y;c[y][k]=w;\n\tif(w)f[w]=y;f[y]=x;f[x]=z;\n}\nI splay(R x){\n\tR y=x,z=0;\n\tst[++z]=y;\n\twhile(nroot(y))st[++z]=y=f[y];\n\twhile(z)pushdown(st[z--]);\n\twhile(nroot(x)){\n\t\ty=f[x];z=f[y];\n\t\tif(nroot(y))\n\t\t\trotate((c[y][0]==x)^(c[z][0]==y)?x:y);\n\t\trotate(x);\n\t}\n}\nI access(R x){\n\tfor(R y=0;x;x=f[y=x])\n\t\tsplay(x),rc=y;\n}\nI makeroot(R x){\n\taccess(x);splay(x);\n\tr[x]^=1;\n}\ninline int findroot(R x){\n\taccess(x);splay(x);\n    pushdown(x);\n\twhile(lc)pushdown(x=lc);\n\treturn x;\n}\nI split(R x,R y){\n\tmakeroot(x);\n\taccess(y);splay(y);\n}\nI link(R x,R y){\n\tmakeroot(x);f[x]=y;\n}\nI cut(R x,R y){\n\tsplit(x,y);f[x]=c[y][0]=0;\n}\nint main()\n{\n\tregister char ch;\n\tR n,m,p=0,a,b;\n\tin(n);in(m);\n\tfor(R i=1;i<n;++i){in(a);in(b);link(a,b);}\n\twhile(m--){\n\t\tgc;\n\t\tswitch(ch){\n\t\tcase 'U':in(a);link(u[a],v[a]);break;\n\t\tcase 'C':in(a);in(b);++p;cut(u[p]=a,v[p]=b);break;\n\t\tcase 'Q':in(a);in(b);puts(findroot(a)==findroot(b)?\"Yes\":\"No\");\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1522067122,
        "uid": 61325,
        "name": "FlashHu",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\u543c\u554a\n## ~~\u4e00\u770b\u5c31\u770b\u51fa\u662fLCT\u6a21\u677f\u9898\u5566~~\n# \u524d\u8bb0\n\u89c1\u8fd9\u4e48\u591a\u4eba\u5199LCT\uff0c\u5374\u5f88\u5c11\u4eba\u5199\u6811\u94fe\u5256\u5206\uff0c\u4e8e\u662f\u6211\u5c31\u6765\u4e00\u53d1\u6811\u94fe\u5256\u5206\uff08\u5176\u5b9e\u662f\u56e0\u4e3a\u81ea\u5df1\u4e0d\u4f1aLCT\uff09\n\n\u672c\u849f\u84bb\u7684\u5199\u6cd5\u548c\u8bf8\u4f4d\u5199\u6811\u94fe\u5256\u5206\u7684\u5927\u795e\u6709\u70b9\u4e0d\u540c\n\n# \u601d\u8def\n\u6811\u94fe\u5256\u5206\uff0c\u7b80\u5355\u9898\n\n## \u64cd\u4f5c\n\u64cd\u4f5c1\uff1a'C' \u64cd\u4f5c \uff1a \u7b80\u5355\u7684\u8bf4\u5c31\u662f\u628ax\u5230y\u7684\u8fb9cut\u6389\uff0c\u9898\u76ee\u53c8\u4fdd\u8bc1x,y\u76f8\u90bb\uff0c~~\u80af\u5b9a\u76f4\u63a5LCT\u5566~~\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5c06x\uff0cy\u7684\u6240\u4ee5\u8fb9\u6743\u52a01\uff0c\u8868\u793a\u90a3\u4e9b\u8fb9\u591a\u4e86\u4e00\u6b21\u6218\u4e89\u3002\n\n\u64cd\u4f5c2\uff1a'U' \u64cd\u4f5c \uff1a \u7b80\u5355\u7684\u8bf4\u5c31\u662f\u628a\u4e4b\u524dcut\u7684\u8fb9\u52a0\u56de\u6765\uff0c\u6211\u4eec\u53ea\u9700\u8981\u8bb0\u5f55\u4e4b\u524d\u6bcf\u4e00\u6b21\u6218\u4e89\u7684\u4e24\u4e2a\u90e8\u843d\u7f16\u53f7\uff0c\u6218\u4e89\u7ed3\u675f\u5c31\u628a\u90a3\u4e24\u4e2a\u90e8\u843d\u76f4\u63a5\u7684\u8fb9\u6743\u51cf\u53bb1\u5c31\u53ef\u4ee5\u4e86\uff0c\u8868\u793a\u90a3\u4e9b\u8fb9\u5c11\u4e86\u4e00\u6b21\u6218\u4e89\u3002\n\n\u64cd\u4f5c3\uff1a'Q' \u64cd\u4f5c \uff1a \u7b80\u5355\u7684\u8bf4\u5c31\u662f\u8be2\u95eex,y\u4e4b\u95f4\u7684\u8fb9\u6743\u548c\uff0c\u5982\u679c\u662f0\uff0c\u8868\u793a\u7ecf\u8fc7\u7684\u8fb9\u4e00\u6b21\u6218\u4e89\u4e5f\u6ca1\u6709\uff0c\u5c31\u662fyes\uff1b\u4e0d\u7136\u5c31\u6709\u6218\u4e89\uff0c\u662fno\u3002\n\n\u8fd9\u4e48\u4e00\u770b\uff0c\u601d\u8def\u662f\u4e0d\u662f\u5f88\u7b80\u5355\u3002\n\n\u4f46\u8fd8\u6709\u4e9b\u95ee\u9898\uff0c\u6811\u94fe\u5256\u5206\u662f\u9488\u5bf9\u70b9\u6743\u7684\uff0c\u6211\u4eec\u5982\u4f55\u8f6c\u6362\u4e3a\u8fb9\u6743\u5462\uff1f\n\n## \u70b9\u6743\u8f6c\u8fb9\u6743\n\u65b9\u6cd5\u6709\u5f88\u591a\uff0c\u4f8b\u5982\u5728\u6bcf\u4e00\u6761\u8fb9\u90fd\u591a\u52a01\u4e2a\u70b9\uff0c\u5728\u52a0\u7684\u90a3\u4e2a\u70b9\u4e0a\u8bb0\u5f55\u6743\u503c\u3002\n\n\u4f46\u662f\uff0c\u8fd9\u91cc\u8bb2\u4e00\u4e0b\u6211\u7684\u505a\u6cd5\uff1a**\u76f4\u63a5\u5ffd\u7565**\uff01\n\n\u5728\u4e00\u9897\u6811\u5185\uff0c\u70b9\u6709n\u4e2a\uff0c\u8fb9\u6709n-1\u6761\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8ba9\u6bcf\u4e00\u6761\u8fb9\u5bf9\u5e94\u5230\u70b9\u4e0a\uff0c\u5bf9\u5e94\u65b9\u5f0f\u5c31\u662f\u8fb9\u7684\u7f16\u53f7\u662f\u8fb9\u4e0a\u4e24\u70b9\u6df1\u5ea6\u5c0f\u7684\u70b9\u7f16\u53f7\u3002\n\n\u90a3\u4e48\u5c31\u53ea\u4f1a\u6709\u6839\u662f\u6ca1\u6709\u8fb9\u5bf9\u5e94\u7684\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5047\u8bbe\u6709\u4e00\u6761\u7f16\u53f7\u4e3a\u6839\u7684\u8fb9\u548c\u6839\u76f8\u8fde\u3002\n\n\u5c06x,y\u7684\u8fb9\u6743\u52a0\u5c31\u7b49\u4e8e\u5c06x,y\u7684\u70b9\u6743\u5168\u90e8\u52a0\uff0c\u7136\u540eLCA(x,y)\u7684\u70b9\u6743\u51cf\u56de\u53bb\uff08\u53ef\u4ee5\u81ea\u5df1\u753b\u56fe\u5c1d\u8bd5\u4e00\u4e0b\uff09\n\n\u67e5\u8be2x,y\u7684\u8fb9\u6743\u548c\u5c31\u7b49\u4e8e\u5c06x,y\u7684\u70b9\u6743\u5168\u90e8\u7d2f\u52a0\uff0c\u7136\u540e\u51cf\u53bbLCA(x,y)\u7684\u70b9\u6743\uff08\u53ef\u4ee5\u81ea\u5df1\u753b\u56fe\u5c1d\u8bd5\u4e00\u4e0b\uff09\n\n\u4e8e\u662f\u6211\u4eec\u6574\u4e2a\u601d\u8def\u5c31\u51fa\u6765\u4e86(\u8fd9\u6837\u5c31\u4e0d\u7528\u6539\u7ebf\u6bb5\u6811\u5566>w< )\n\n# \u4ee3\u7801\n```cpp\n#include<bits/stdc++.h>\n#define maxn 4000001\n#define L(x) (x<<1)\n#define R(x) ((x<<1)|1)\nusing namespace std;\nint tree[maxn],tag[maxn];\nint rev[maxn],dep[maxn],size[maxn],seg[maxn],top[maxn],son[maxn],father[maxn];\nint n,m,root,x,y,z,a[maxn],visx[maxn],visy[maxn],tot;\nint cnt,from[maxn],to[maxn],Next[maxn],head[maxn];\nchar mode;\nvoid add(int x,int y){\n\tcnt++;\n\tfrom[cnt]=x;to[cnt]=y;\n\tNext[cnt]=head[x];head[x]=cnt;\n}\n//\u7ebf\u6bb5\u6811\nvoid pushdown(int node,int begin,int end){\n\tif(tag[node]){\n\t\ttag[L(node)]+=tag[node];\n\t\ttag[R(node)]+=tag[node];\n\t\tint mid=(begin+end)>>1;\n\t\ttree[L(node)]+=(mid-begin+1)*tag[node];\n\t\ttree[R(node)]+=(end-mid)*tag[node];\n\t\ttag[node]=0;\n\t}\n}\nvoid update(int node,int begin,int end,int x,int y,int val){\n\tif(begin>y||end<x)return;\n\tif(begin>=x&&end<=y){\n\t\ttag[node]+=val;\n\t\ttree[node]+=(end-begin+1)*val;\n\t\treturn;\n\t}else{\n\t\tpushdown(node,begin,end);\n\t\tint mid=(begin+end)>>1;\n\t\tif(x<=mid)update(L(node),begin,mid,x,y,val);\n\t\tif(y>mid) update(R(node),mid+1,end,x,y,val);\n\t\ttree[node]=tree[L(node)]+tree[R(node)];\n\t}\n}\nint query(int node,int begin,int end,int x,int y){\n\tif(begin>y||end<x)return 0;\n\tif(begin>=x&&end<=y){\n\t\treturn tree[node];\n\t}else{\n\t\tpushdown(node,begin,end);\n\t\tint mid=(begin+end)>>1,sum=0;\n\t\tif(x<=mid)sum+=query(L(node),begin,mid,x,y);\n\t\tif(y>mid) sum+=query(R(node),mid+1,end,x,y);\n\t\treturn sum;\n\t}\n}\n//\u7ebf\u6bb5\u6811\nint dfs1(int x){\t\t\t\t\t\t//\u6811\u94fe\u5256\u5206\u6a21\u677f\n\tsize[x]=1;\n\tdep[x]=dep[father[x]]+1;\n\tfor(int i=head[x];i!=-1;i=Next[i]){\n\t\tint v=to[i],big=0;\n\t\tif(father[x]==v)continue;\n\t\tfather[v]=x;\n\t\tbig=dfs1(v);\n\t\tsize[x]+=big;\n\t\tif(big>size[son[x]])son[x]=v;\n\t}\n\treturn size[x]; \n}\nvoid dfs2(int x){\t\t\t\t\t\t//\u6811\u94fe\u5256\u5206\u6a21\u677f\n\tif(son[x]){\n\t\tseg[son[x]]=++seg[0];\n\t\ttop[son[x]]=top[x];\n\t\trev[seg[0]]=son[x];\n\t\tdfs2(son[x]);\n\t}\n\tfor(int i=head[x];i!=-1;i=Next[i]){\n\t\tint v=to[i];\n\t\tif(!top[v]){\n\t\t\tseg[v]=++seg[0];\n\t\t\ttop[v]=v;\n\t\t\trev[seg[0]]=v;\n\t\t\tdfs2(v);\n\t\t}\n\t}\n}\nvoid linkadd(int x,int y,int z){\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy){\n\t\tif(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n\t\tupdate(1,1,seg[0],seg[fx],seg[x],z);\n\t\tx=father[fx];fx=top[x];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tupdate(1,1,seg[0],seg[x],seg[y],z);\n\tupdate(1,1,seg[0],seg[x],seg[x],-z);\t\t\t//LCA\u7279\u6b8a\u5904\u7406\n}\nint linkquery(int x,int y){\n\tint fx=top[x],fy=top[y],ans=0;\n\twhile(fx!=fy){\n\t\tif(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n\t\tans+=query(1,1,seg[0],seg[fx],seg[x]);\n\t\tx=father[fx];fx=top[x];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tans+=query(1,1,seg[0],seg[x],seg[y]);\n\tans-=query(1,1,seg[0],seg[x],seg[x]);\t\t\t//\u51cfLCA\n\treturn ans;\n}\nint main(){\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d%d\",&n,&m);root=1;\n\tfor(int i=1;i<=n-1;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs1(root);\n\tseg[root]=++seg[0];\n\trev[seg[0]]=root;\n\ttop[root]=root;\n\tdfs2(root);\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%s\",&mode);\n\t\tif(mode=='C'){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tvisx[++tot]=x;visy[tot]=y;\t\t//\u8bb0\u5f55\u6bcf\u4e00\u6b21\u6218\u4e89\u7684\u4e24\u4e2a\u90e8\u843d\n\t\t\tlinkadd(x,y,1);\t\t\t//x\u5230y\u7684\u8fb9\u6743\u52a01\n\t\t}\n\t\tif(mode=='U'){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlinkadd(visx[x],visy[x],-1);\t\t//\u6218\u4e89\u7ed3\u675f\u5c31\u51cf\u56de\u53bb\n\t\t}\n\t\tif(mode=='Q'){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tint q=linkquery(x,y);\t//\u67e5\u8be2x\u5230y\u7684\u8fb9\u6743\u548c\n\t\t\tif(q==0)printf(\"Yes\\n\");else\t//\u5982\u679cq\u4e3a0\u5c31\u53ef\u4ee5\n\t\t\tprintf(\"No\\n\");\t\t\t//\u4e0d\u884c\u5c31\u2026\u2026\n\t\t}\n\t}\n}\n```\n# \u53e6\u5916\u63a8\u8350\u9898\u76ee\n[P3258 [JLOI2014]\u677e\u9f20\u7684\u65b0\u5bb6](https://www.luogu.org/problemnew/show/P3258) \u5373\u5176[\u9898\u89e3](https://www.luogu.org/blog/juruohyfhaha/solution-p3258)\n\n# \u8c22\u8c22\u89c2\u8d4f\uff0c\u70b9\u4e2a\u8d5e\u5457\uff01",
        "postTime": 1550815412,
        "uid": 58711,
        "name": "hyfhaha",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u770b\u5927\u5bb6\u53d1\u7684\u90fd\u662f\u6811\u94fe\u5256\u5206\u548cLCT\u7684\u9898\u89e3\uff0c\u7136\u800c\u672c\u4eba\u4f7f\u7528\u7684\u662f\u4e00\u79cd\u5b8c\u5168\u539f\u521b\u7684\u65b9\u6cd5\uff1a\u6807\u8bb0\u6709\u671f\u9650\u7684\u6807\u8bb0\u6c38\u4e45\u5316dfs\u5e8f\u7ebf\u6bb5\u6811\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u6211\u4eec\u628a\u6240\u6709\u6218\u4e89\u548c\u8be2\u95ee\u6309\u65f6\u95f4\u6392\u5e8f\uff0c\u5176\u4e2d\u6218\u4e89\u7684\u65f6\u95f4\u662f\u4e00\u6bb5\u533a\u95f4\uff08\u5f00\u59cb\u65f6\u95f4\u5230\u7ed3\u675f\u65f6\u95f4\uff09\uff0c\u7136\u540e\uff0c\u6211\u4eec\u5148\u7528\u79bb\u7ebf\u65b9\u6cd5\u628a\u6240\u6709\u8be2\u95ee\u70b9\u5bf9\u7684LCA\u5728O\uff08n\uff09\u65f6\u95f4\u5185\u627e\u51fa\u6765\uff0c\u627eLCA\u65f6\u53ef\u4ee5\u5f97\u5230\u6bcf\u4e2a\u8282\u70b9\u7684dep\uff08\u6df1\u5ea6\uff09\uff0cdfn\uff08dfs\u5e8f\uff09\uff0cend\uff08\u5b50\u6811\u5185\u6700\u5927\u7684dfs\u5e8f\uff09\n\n\u6211\u4eec\u5df2\u7ecf\u5f97\u5230\u4e86\u6bcf\u4e2a\u8be2\u95ee\u70b9\u5bf9\u7684LCA\uff0c\u90a3\u4e48\u663e\u7136\uff0c\u6b64\u8be2\u95ee\u4e3aYES\u5145\u8981\u7684\u6761\u4ef6\u5373\u4e3a\u4e24\u4e2a\u70b9\u5411\u6839\u80fd\u8d70\u5230\u7684\u6700\u5c0f\u6df1\u5ea6\u5747\u5c0f\u4e8e\u7b49\u4e8e\u5176LCA\u7684\u6df1\u5ea6\uff08\u597d\u597d\u7406\u89e3\u8fd9\u53e5\u8bdd\uff09\n\n\u6211\u4eec\u5efa\u7acb\u4e00\u9897\u7ebf\u6bb5\u6811\uff0c\u7ebf\u6bb5\u6811\u7684\u4e0b\u6807\u5bf9\u5e94\u7740\u70b9\u7684dfs\u5e8f\uff0c\u4e5f\u5c31\u662fdfn\u503c\uff0c\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u70b9\u7528\u4f18\u5148\u961f\u5217\u7ef4\u62a4\u4e00\u4e2a\u5927\u6839\u5806\n\n\u5f53\u53d1\u751f\u6218\u4e89\u65f6\uff0c\u9009\u62e9\u6218\u4e89\u70b9\u5bf9\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u4e00\u4e2a\uff0c\u8bbe\u4e3ax\uff0c\u5219\u53ef\u77e5\uff0cx\u8fd9\u9897\u5b50\u6811\u4e2d\u7684\u6240\u6709\u70b9\u5411\u6839\u80fd\u8d70\u5230\u7684\u6700\u5c0f\u6df1\u5ea6\u4e00\u5b9a\u5927\u4e8e\u7b49\u4e8ex\u7684\u6df1\u5ea6\uff0c\u800c\u6309\u7167dfs\u5e8f\u7684\u6027\u8d28\uff0c\u6211\u4eec\u53d1\u73b0x\u5b50\u6811\u4e2d\u6240\u6709\u70b9\u7684dfs\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u5373\u4e3a\uff08dfn[x]-end[x]\uff09,\u8fd9\u5c31\u662f\u7ebf\u6bb5\u6811\u4e2d\u7684\u533a\u95f4\u53d6\u6700\u503c\u64cd\u4f5c\uff0c\u6211\u4eec\u5c06\u8fd9\u4e2a\u533a\u95f4\u5bf9\u5e94\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u6240\u6709\u7ed3\u70b9\u7684\u5927\u6839\u5806\u52a0\u4e0a\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff08dep[x],[\u6b64\u6218\u4e89\u7ed3\u675f\u65f6\u95f4]\uff09,\u5927\u6839\u5806\u6309\u7167dep\u6392\u5e8f\n\n\u56e0\u6b64\u6bcf\u6b21\u8be2\u95ee\u65f6\uff0c\u6211\u4eec\u9700\u8981\u77e5\u9053\u8be2\u95ee\u70b9\u5bf9\u7684\u4e24\u4e2a\u70b9\u5411\u6839\u80fd\u8d70\u5230\u7684\u6700\u5c0f\u6df1\u5ea6\uff0c\u4e5f\u5c31\u662f\u6309\u7167dfs\u5e8f\u4ece\u7ebf\u6bb5\u6811\u7684\u6839\u4e00\u76f4\u5f80\u76f8\u5e94\u7684\u533a\u95f4\u8d70\uff0c\u9014\u4e2d\u5bf9\u4e8e\u6bcf\u4e2a\u7ecf\u8fc7\u7684\u70b9\uff0c\u627e\u8fd9\u4e9b\u70b9\u7684\u5806\u91cc\u9762\u7ed3\u675f\u65f6\u95f4\u5927\u4e8e\u8be2\u95ee\u65f6\u95f4\uff0c\u4e14dep\u6700\u5927\u7684\u6807\u8bb0\uff0c\u5373\u4e3a\u5411\u6839\u80fd\u8d70\u5230\u7684\u6700\u5c0f\u6df1\u5ea6\uff0c\u5728\u5224\u65ad\u7ed3\u675f\u65f6\u95f4\u662f\u5426\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u53d6\u5806\u9876\u5143\u7d20\uff0c\u82e5\u6ee1\u8db3\u5219\u53ef\u4ee5\u8df3\u5230\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u82e5\u4e0d\u6ee1\u8db3\uff0c\u5f39\u51fa\u8fd9\u4e2a\u5143\u7d20\u627e\u5806\u4e2d\u7684\u7b2c\u4e8c\u5927\u5143\u7d20\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u4e00\u76f4\u4e0b\u53bb\u5373\u53ef\uff0c\u6b63\u662f\u56e0\u4e3a\u6709\u6807\u8bb0\u7684\u64a4\u9500\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528\u7ebf\u6bb5\u6811\u4f20\u7edf\u7684\u4e0b\u4f20\u6807\u8bb0\u529f\u80fd\uff0c\u5fc5\u987b\u7528\u5806\u7ef4\u62a4\u5b9e\u73b0\u6807\u8bb0\u6c38\u4e45\u5316\uff0c\u7531\u4e8e\u6240\u6709\u64cd\u4f5c\u90fd\u662f\u6309\u65f6\u95f4\u987a\u5e8f\uff0c\u6240\u4ee5\u4e00\u4e2a\u6807\u8bb0\u88ab\u5f39\u51fa\u540e\u5c31\u6c38\u8fdc\u6ca1\u6709\u7528\u4e86\uff0c\u53ef\u4ee5\u653e\u5fc3\u5f39\u51fa\n\n\u7531\u4e8em\u6b21\u6218\u4e89\u6700\u591a\u4ea7\u751fmlogn\u4e2a\u6807\u8bb0\uff0c\u6bcf\u4e2a\u6807\u8bb0\u6700\u591a\u4f1a\u63d2\u5165\u5806\u4e00\u6b21\u548c\u4ece\u5806\u4e2d\u5220\u9664\u4e00\u6b21\uff0c\u67d0\u4e2a\u8282\u70b9\u4e2d\u6807\u8bb0\u6700\u591a\u6709m\u4e2a\uff0c\u56e0\u6b64\u63d2\u5165\u548c\u5220\u9664\u64cd\u4f5c\u590d\u6742\u5ea6\u6700\u591alogm\uff0c\u52a0\u4e0a\u9884\u5904\u7406\u548c\u79bb\u7ebf\u6c42LCA\u7684n\u7684\u590d\u6742\u5ea6\uff0c\u603b\u590d\u6742\u5ea6O(mlognlogm+n);\n\n\u6bd4\u6811\u5256\u548cLCT\u4eb2\u5207\u591a\u4e86\u5427\n\n```cpp\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nstruct node\n{\n\tint dfn,bing,dep,end;\n\tvector<int> s;\n\tvector<int> t;\n}tr[300005];\nstruct task\n{\n\tint x,y,tc,ans;\n}q[300005];\nstruct eve\n{\n\tint dep,t;\t\n\tbool operator<(const eve&y)const\n\t{\n\t\treturn dep<y.dep;\n\t}\n\tbool operator>(const eve&y)const\n\t{\n\t\treturn dep>y.dep;\n\t}\n};\nstruct seg_node\n{\n\tint l,r;\n\tpriority_queue<eve> q;\n}seg[1200005];\nchar s[2];\nconst int inf=1e9;\nint n,m,i,x,y,pos,war[300005],cnt=0,ans;\nint get(int p,int k){return q[p].x==k?q[p].y:q[p].x;}\nint getf(int p){return tr[p].bing==p?p:tr[p].bing=getf(tr[p].bing);}\nvoid dfs(int p,int f,int de)\n{\n\tint i,v,vv;\n\ttr[p].dep=de;\n\ttr[p].bing=p;\n\ttr[p].dfn=tr[p].end=++cnt;\n\tfor(i=0;i<tr[p].t.size();i++)\n\t{\n\t\tv=tr[p].t[i];\n\t\tvv=get(tr[p].t[i],p);\n\t\tif(tr[vv].dfn!=0)q[v].ans=tr[getf(vv)].dep;\t\n\t}\n\tfor(i=0;i<tr[p].s.size();i++)\n\t{\n\t\tv=tr[p].s[i];\n\t\tif(v!=f)dfs(v,p,de+1),tr[p].end=tr[v].end;\n\t}\n\ttr[p].bing=f;\n}\nvoid build(int p,int l,int r)\n{\n\tint mid;\n\tseg[p].l=l;\n\tseg[p].r=r;\n\tmid=(l+r)/2;\n\tif(l!=r)\n\t{\n\t\tbuild(2*p,l,mid);\n\t\tbuild(2*p+1,mid+1,r);\n\t}\n}\nvoid opt(int p,int l,int r,int v,int tc)\n{\n\tif(seg[p].l>r||seg[p].r<l)return;\n\tif(seg[p].l>=l&&seg[p].r<=r)seg[p].q.push((eve){v,tc});\n\telse\n\t{\n\t\topt(2*p,l,r,v,tc);\n\t\topt(2*p+1,l,r,v,tc);\n\t}\n}\nint check(int p,int pos,int t)\n{\n\tint ans=0;\n\twhile(!seg[p].q.empty()&&seg[p].q.top().t<t)seg[p].q.pop();\n\tif(!seg[p].q.empty())ans=max(ans,seg[p].q.top().dep);\n\tif(seg[p].l!=seg[p].r)\n\t{\n\t\tint mid,v;\n\t\tmid=(seg[p].l+seg[p].r)/2;\n\t\tv=pos<=mid?2*p:2*p+1;\n\t\tans=max(ans,check(v,pos,t));\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\ttr[x].s.push_back(y);\n\t\ttr[y].s.push_back(x);\n\t}\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='Q')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tq[i]=(task){x,y,-1,0};\n\t\t\ttr[x].t.push_back(i);\n\t\t\ttr[y].t.push_back(i);\n\t\t}\n\t\tif(s[0]=='C')\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tq[i]=(task){x,y,inf,0};\n\t\t\twar[++cnt]=i;\n\t\t}\n\t\tif(s[0]=='U')\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tq[war[x]].tc=i;\n\t\t}\n\t}\n\tcnt=0;\n\tdfs(1,0,0);\n\tbuild(1,1,n);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tif(q[i].tc==-1)\n\t\t{\n\t\t\tans=max(check(1,tr[q[i].x].dfn,i),check(1,tr[q[i].y].dfn,i));\n\t\t\tif(ans>q[i].ans)printf(\"No\\n\");\n\t\t\telse printf(\"Yes\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpos=tr[q[i].x].dep<tr[q[i].y].dep?q[i].y:q[i].x;\n\t\t\topt(1,tr[pos].dfn,tr[pos].end,tr[pos].dep,q[i].tc);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1526181178,
        "uid": 51879,
        "name": "\u68a6\u68a6\u5b50",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u8bf8\u541b\u90fd\u8bf4\uff1a\"\u770b\u5230\u5927\u5bb6\u90fd\u7528\u7684\u6811\u5256+\u6811\u72b6\u6570\u7ec4\"\n\n\u7136\u800c\u4e00\u4e2a\u7528\u6811\u72b6\u6570\u7ec4\u7684\u9898\u89e3\u90fd\u6ca1\u6709\u2026\u2026\n\n\u6240\u4ee5\u6211\u51b3\u5b9a\u6765\u5403\u8fd9\u4e2a\u5927\u4f6c\u4eec\u90fd\u4e0d\u5403\u7684\u8783\u87f9\u2026\u2026\n\n\u539f\u7406\u5f88\u7b80\u5355\uff0c\u9996\u5148\u4f60\u8981\u6709\u4e00\u4e2adfs\u5e8f\u6570\u7ec4\n\n\u7136\u540e\u5728\u53d1\u751f\u6218\u4e89\u65f6\uff0c\u5c06\u53d1\u751f\u6218\u4e89\u7684\u4e24\u4e2a\u8282\u70b9\u4e2d\u8f83\u6df1\u7684\u90a3\u4e2a++\n\n\u505c\u6218\u65f6--\n\n\u8fd9\u6837\uff0c\u8fd9\u4e2a\u6570\u7ec4\u7684\u524d\u7f00\u548c\u5c31\u662f\u4ece\u5f53\u524d\u8282\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u8def\u5f84\u4e0a\u7684\u548c\n\n\u5982\u679c\u975e\u96f6\u5c31\u4ee3\u8868\u6709\u6218\u4e89\uff0c\u7136\u540e\u5c31\u5f88\u7b80\u5355\u4e86\n\nlca\u4e0d\u53ef\u53d6\uff0c\u5b8c\u4e86\n\n```cpp\n#include <bits/stdc++.h>\n#define lowbit(x) x&-x\nusing namespace std;\ntypedef pair<int, int> P;\nconst int maxn = 1000000;\nP war[maxn];\nint fa[maxn], dep[maxn], val[maxn], sz[maxn], top[maxn], son[maxn];\nint tre[maxn];\nint tot;\nint cntw;\nint n, m;\ninline int read()\n{\n    int ch, x = 0, f = 1;ch = getchar();\n    while((ch < '0' || ch > '9') && ch != '-') ch = getchar();\n    ch == '-' ? f = -1, ch = getchar() : 0;\n    while(ch >= '0' && ch <= '9') {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    return f * x;\n}\nstruct Edge {\n    int to, len, nxt;\n    Edge() {}\n    Edge(int _to, int _len, int _nxt):to(_to), len(_len), nxt(_nxt) {}\n}E[maxn];\nint h[maxn], cnte;\nint L[maxn], R[maxn];\nvoid update(int x, int add) {\n    for(int i = x;i <= maxn; i += lowbit(i)) tre[i] += add;\n}\nint query(int x) {\n    int ans = 0; for(int i = x; i; i -= lowbit(i)) ans += tre[i]; return ans;\n}\ninline void add_edge(int u, int v, int w) {\n    E[++cnte] = Edge(v, w, h[u]), h[u] = cnte;\n    E[++cnte] = Edge(u, w, h[v]), h[v] = cnte;\n}\nvoid dfs1(int x) {\n    \n    sz[x] = 1; dep[x] = dep[fa[x]] + 1;\n    for(int i = h[x]; i; i = E[i].nxt) {\n        int to = E[i].to;\n        if(to == fa[x]) continue;\n        fa[to] = x;val[x] = E[i].len;\n        dfs1(to);\n        sz[x] += sz[to];\n        if(sz[to] > sz[son[x]]) son[x] = to;\n    }\n    \n}\nvoid dfs2(int x) {\n    L[x] = ++tot;\n    if(x == son[fa[x]]) top[x] = top[fa[x]];\n    else top[x] = x;\n    if(son[x]) dfs2(son[x]);\n    for(int i = h[x]; i; i = E[i].nxt) {\n        int to = E[i].to;\n        if(to == fa[x] || to == son[x]) continue;\n        dfs2(to);\n    }\n    R[x] = tot;\n}\n\nvoid cut(int x, int y) {\n    if(L[x] < L[y]) swap(x, y);\n    update(L[x], 1);\n}\nvoid connect(int x, int y) {\n    if(L[x] < L[y]) swap(x, y);\n    update(L[x], -1);\n}\nint qsum(int x, int y) {\n    int ans = 0;\n    while(top[x] != top[y])\n    {\n        if(dep[top[x]] < dep[top[y]])swap(x, y);\n        ans += (query(L[x]) - query(L[top[x]] - 1));\n        x = fa[top[x]];\n    }\n    if(dep[x] < dep[y])swap(x, y);\n    ans += (query(L[x]) - query(L[y]));\n    return ans;\n}\nsigned main() {\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i < n; i++) add_edge(read(), read(), 0);\n    dfs1(1);\n    dfs2(1);\n    for(int i = 1;i <= m; i++) {\n        char s[50];\n        cin >> s;\n        if(s[0] == 'C') {\n            int u = read(), v = read();\n            cut(u, v);\n            war[++cntw] = P(u, v);\n        } \n        else if(s[0] == 'U') {\n            int w = read();\n            connect(war[w].first, war[w].second);\n        }\n        else {\n            if(qsum(read(), read()) != 0) printf(\"No\\n\");\n            else printf(\"Yes\\n\");\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1530931674,
        "uid": 34332,
        "name": "KKarshilov",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u5927\u5bb6\u90fd\u7528log^2\u7684\u6811\u72b6\u6570\u7ec4+\u6811\u5256\uff1f\u90a3\u6211\u6765\u8bb2\u4e00\u4e0b\u79bb\u7ebf\u5427\uff01\n\n\u3010\u548cNOIP2016Day1T2\u6709\u70b9\u7c7b\u4f3c\u3011\n\n\u9996\u5148\uff0c\u6211\u4eec\u628a\u95ee\u9898\u62bd\u8c61\u5316\u4e00\u4e0b\uff1a\u4e00\u68f5\u5e26\u6743\u6811\uff0c\u6743\u503c\u4e00\u5f00\u59cb\u90fd\u662f0\uff0c\u4e09\u79cd\u64cd\u4f5c\uff0c1\uff09\u628a\u67d0\u6761\u8fb9\u6743\u6539\u4e3a1 2\uff09\u628a\u67d0\u6761\u8fb9\u6743\u6539\u4e3a0 3\uff09\u6c42\u51fau\u5230v\u4e4b\u95f4\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\u662f\u5426\u4e3a0\n\n\u600e\u4e48\u505a\u5462\uff1f\u663e\u7136\u53ef\u4ee5LCT\uff0c\u7136\u800c\u9898\u4e3b\u61d2\u5f97\u7801\u6a21\u677f\u3002\n\n\u6ce8\u610f\u5230u\u5230v\u4e4b\u95f4\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c=\uff081\u5230u\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\uff09+\uff081\u5230v\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\uff09-2\\*\uff081\u5230LCA(u,v)\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\uff09\n\n\u4e8e\u662f\u6211\u4eec\u628a1\u4e2aquery\u62c6\u6210\u4e863\u4e2aquery\uff0c\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u662f\uff0c\u5982\u4f55\u79bb\u7ebf\u5904\u74066\\*10^5\u4e2a\u5f62\u5982\u5bf9\u201c\u5728\u7b2cT\u4e2a\u65f6\u95f4\u5355\u4f4d1\u5230v\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u548c\u201c\u7684\u67e5\u8be2\n\n\u6211\u4eec\u8dd1\u4e00\u904ddfs\uff0cdfs\u7684\u65f6\u5019\u4fdd\u5b58\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u5f53\u524d\u8282\u70b9v\u5728\u6240\u6709\u65f6\u95f4\u4e0a\u5230\u6839\u8282\u70b91\u7684\u8fb9\u6743\u548c\u3002\n\n\u4ecev\u7684\u7236\u4eb2\u8f6c\u5316\u5230v\uff0c\u53ea\u9700\u8981\u8fdb\u884c\u5173\u4e8ev\u7684\u7236\u4eb2\u4e0ev\u4e4b\u95f4\u7684\u6218\u4e89\u7684modify\uff1b\u8003\u8651\u5b8c\u5b50\u6811v\u540e\u56de\u5230v\u7684\u7236\u4eb2\uff0c\u4e5f\u53ea\u9700\u8981\u8fdb\u884c\u540c\u7b49\u6570\u91cf\u53cd\u5411\u7684modify\u3002\uff08\u5176\u5b9e\u662fdjq\u4e0d\u4f1a\u7801\u53ef\u6301\u4e45\u5316\u5566\uff09\n\n\u597d\u5427djq\u849f\u84bb\u8bb2\u4e0d\u6e05\u695a\uff0c\u8d34\u4ee3\u7801\u5427\uff08\u4e00\u6837\u4e11\uff09\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <cctype>\n#include <ctime>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <complex>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cwchar>\n#include <cwctype>\n#include <exception>\n#include <locale>\n#include <numeric>\n#include <new>\n#include <stdexcept>\n#include <limits>\n#include <valarray>\n#include <set>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <list>\n#include <utility>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF=1e9+7;\n//segment tree\nint tree[1048576];\nint query(int id){\n    id+=524288;\n    int ans=tree[id];\n    id>>=1;\n    while(id>0){\n        ans+=tree[id];\n        id>>=1;\n    }\n    return ans;\n}\nvoid modify(int l,int r,int v){\n    l+=524288;r+=524288;\n    while(l<r){\n        if(l&1)tree[l]+=v;\n        if(!(r&1))tree[r]+=v;\n        l=(l+1)>>1;\n        r=(r-1)>>1;\n    }\n    if(l==r)tree[l]+=v;\n}\n//\nvector<int> G[300005];\nvector<pii> qy[300005];\nvector<pair<pair<pii,pii>,pii> > Q;\nvector<pii> war[300005];\nint dep[300005],pre[300005][20];\n// lca_part\nvoid init_dfs(int v,int par){\n    dep[v]=dep[par]+1;\n    pre[v][0]=par;\n    rep(k,G[v].size()){\n        int u=G[v][k];\n        if(u!=par)init_dfs(u,v);\n    }\n}\nvoid init_lca(int n){\n    rep1(i,18)rep1(j,n)\n    pre[j][i]=pre[pre[j][i-1]][i-1];\n}\nint LCA(int u,int v){\n    if(dep[u]<dep[v])swap(u,v);\n    int dif=dep[u]-dep[v];\n    rep(k,19)if(dif>>k&1)u=pre[u][k];\n    if(u==v)return u;\n    for(int k=18;k>=0;k--)\n    if(pre[u][k]!=pre[v][k]){\n        u=pre[u][k];\n        v=pre[v][k]; \n    }\n    return pre[u][0];\n}\n//main part\nvoid dfs(int v,int par){\n    rep(k,war[v].size())\n    modify(war[v][k].first,war[v][k].second,1);\n    rep(k,qy[v].size())qy[v][k].second=query(qy[v][k].first);\n    rep(k,G[v].size()){\n        int u=G[v][k];\n        if(u==par)continue;\n        dfs(u,v);\n    }\n    rep(k,war[v].size())\n    modify(war[v][k].first,war[v][k].second,-1);\n}\nvector<pii> w;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,q;\n    cin>>n>>q;\n    rep(k,n-1){\n        int u,v;\n        cin>>u>>v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    init_dfs(1,0);\n    init_lca(n);\n    rep(k,q){\n        char t;\n        int u,v;\n        cin>>t;\n        if(t=='C'){\n            cin>>u>>v;\n            if(dep[u]<dep[v])swap(u,v);\n            w.push_back(MP(u,k));\n        }else if(t=='U'){\n            cin>>u;u--;\n            war[w[u].first].push_back(MP(w[u].second,k));\n            w[u].second=-1;\n        }else{\n            cin>>u>>v;int uv=LCA(u,v);\n            Q.push_back(MP(MP(MP(u,qy[u].size()),MP(v,qy[v].size())),MP(uv,qy[uv].size())));\n            qy[u].push_back(MP(k,-1));qy[v].push_back(MP(k,-1));qy[uv].push_back(MP(k,-1));\n        }\n    }\n    rep(k,w.size())if(w[k].second!=-1)war[w[k].first].push_back(MP(w[k].second,q-1));\n    dfs(1,0);\n    rep(k,Q.size())cout<<(qy[Q[k].first.first.first][Q[k].first.first.second].second+\n                          qy[Q[k].first.second.first][Q[k].first.second.second].second==\n                          2*qy[Q[k].second.first][Q[k].second.second].second?\"Yes\\n\":\"No\\n\");\n    return 0;\n}\n\n```",
        "postTime": 1510668238,
        "uid": 30853,
        "name": "djq_cpp",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "$$\\text{\u5173\u4e8e\u9898\u610f}$$\n\n$\\quad$\u4e00\u9053\u5f88\u7b80\u5355\u7684\u6811\u5256\u9898\uff0c\u53ea\u6709\u4e09\u79cd\u64cd\u4f5c(\u5176\u5b9e\u662f\u4e24\u79cd)\uff0c\u552f\u4e00\u8981\u8003\u8651\u7684\u70b9\u662f\u5982\u4f55\u5c06\u8fb9\u6743\u8f6c\u5316\u6210\u70b9\u6743\uff0c\u8003\u8651\u5230\u6bcf\u4e2a\u70b9\u90fd\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u7236\u4eb2\u8282\u70b9(\u9664\u6839\u8282\u70b91\u4e4b\u5916)\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5c06\u7236\u4eb2\u4e0e\u513f\u5b50\u8fde\u63a5\u7684\u8fb9\u6743\u8bb0\u5f55\u5230\u513f\u5b50\u8eab\u4e0a\uff0c\u8fd9\u6837 $n-1$ \u6761\u8fb9\u5c31\u53ef\u4ee5\u5408\u7406\u7684\u5206\u914d\u5230 $n-1$ \u4e2a\u70b9\u4e0a(\u9664\u4e86\u6839\u8282\u70b9)\uff0c\u8fd9\u6837\u5c31\u8f6c\u5316\u6210\u4e86\u666e\u901a\u7684\u6811\u94fe\u5256\u5206\u6a21\u677f\u4e86(\u5982\u679c\u8fd8\u4e0d\u80fd\u7406\u89e3\u5c31\u770b\u770b\u56fe\u5427)\u3002\n\n\u539f\u56fe\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/o4y4z8vc.png)\n\n\u7ecf\u8fc7\u8f6c\u5316\u540e\u7684\u56fe(\u5c06\u8fb9\u6743\u8f6c\u5316\u4e3a\u70b9\u6743)\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/qtsmvd97.png)\n\n\u6ce8\u610f\uff1a\u5bf9\u4e8e\u8def\u5f84$4-2-5$\uff0c\u53ea\u9700\u8bbf\u95ee\u70b9 $4$ \u548c\u70b9 $5$\uff0c\u5bf9\u4e8e $4$ \u548c $5$ \u7684 $LCA$ (\u6700\u8fd1\u516c\u5171\u7956\u5148)\u4e0d\u53ef\u53d6\uff0c\u56e0\u4e3a $2$ \u5728\u539f\u56fe\u4e2d\u5bf9\u5e94\u7684\u662f\u8fb9 $1-2$\uff0c\u5e76\u4e0d\u5728\u8def\u5f84$4-2-5$\u4e0a\uff0c\u6240\u4ee5\u5728\u6811\u94fe\u5256\u5206\u4e2d\u5f53 $x$ \u548c $y$ \u5728\u540c\u4e00\u6761\u94fe\u4e0a\u65f6($dep[x]<dep[y]$)\uff0c\u53ea\u9700\u8be2\u95ee $x+1$ \u5230 $y$ \u7684\u8def\u5f84\u3002\n\n$$\\text{\u5bf9\u4e8e\u4e09\u79cd\u64cd\u4f5c}$$\n\n1. \u64cd\u4f5c $1$\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u4e24\u4e2a\u76f8\u90bb\u7684\u90e8\u843d\u5f00\u6218\uff0c\u4ed6\u4eec\u4e4b\u95f4\u7684\u9053\u8def\u4e0d\u53ef\u901a\u884c\u3002\n\n2. \u64cd\u4f5c $2$\uff1a\u533a\u95f4\u8be2\u95ee\uff0c\u8be2\u95ee\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u80fd\u5426\u901a\u884c\u3002\n\n3. \u64cd\u4f5c $3$\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u4e24\u4e2a\u5f00\u6218\u7684\u90e8\u843d\u505c\u6218\uff0c\u4ed6\u4eec\u4e4b\u95f4\u7684\u9053\u8def\u53ef\u4ee5\u901a\u884c\u3002\n\n$\\quad$\u53ef\u4ee5\u5f88\u5bb9\u6613\u53d1\u73b0\u64cd\u4f5c $1$\u548c\u64cd\u4f5c $3$ \u5176\u5b9e\u662f\u4e00\u79cd\u64cd\u4f5c\uff0c\u53ea\u9700\u5f00\u4e00\u4e2a\u6570\u7ec4 $u$[$x$][$2$] \u6765\u8bb0\u5f55\u53c2\u4e0e\u7b2c$x$\u6b21\u6218\u4e89\u7684\u4e24\u4e2a\u90e8\u843d\uff0c\u5f00\u6218\u5c06\u8fd9\u6761\u8fb9\u6807\u8bb0\u4e3a $0$\uff0c\u610f\u4e3a\u4e0d\u53ef\u901a\u884c\uff0c\u505c\u6218\u5c31\u628a\u8fd9\u6761\u8fb9\u6807\u8bb0\u4e3a $1$\uff0c\u610f\u4e3a\u53ef\u4ee5\u901a\u884c\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c(\u4e5f\u53ef\u4ee5\u662f\u6700\u5c0f\u503c)\uff0c\u5f53$sum$[$k$]==$r$-$l$+$1$ \u65f6\u8bf4\u660e\u8fd9\u4e2a\u533a\u95f4\u5185\u6240\u6709\u8fb9\u7686\u53ef\u901a\u884c\uff0c\u5426\u5219\u81f3\u5c11\u6709$1$\u6761\u8fb9\u4e0d\u53ef\u901a\u884c\u3002\n\n$\\quad$\u4e0b\u9762\u8d34\u51faAC\u4ee3\u7801\uff0c\u5efa\u8bae\u53cd\u590d\u9605\u8bfb\uff0c\u6df1\u523b\u7406\u89e3\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<algorithm>\n#define il inline\n#define inf 1e18\n#define next nne\n#define re register int\nusing namespace std;\nil int read()\t\t\t\t//\u5feb\u901f\u8bfb\u5165\n{\n\tint x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n    return x*f;\n}\nconst int N=3e5+5;\nint n,m,next[N<<1],go[N<<1],head[N],tot,u[N][2],sum[N<<2];\nint seg[N],son[N],father[N],top[N],size[N],dep[N];\nil void Add(int x,int y)\t\t//\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe\n{\n  next[++tot]=head[x];\n  head[x]=tot;\n  go[tot]=y;\n}\nil void dfs1(int x,int fa)\n{\n  father[x]=fa;dep[x]=dep[fa]+1;size[x]=1;\n  for(re i=head[x],y;i,y=go[i];i=next[i])\n    {\n      if(y==fa)continue;\n      dfs1(y,x);\n      size[x]+=size[y];\n      if(size[y]>size[son[x]])son[x]=y;\n    }\n}\nil void dfs2(int x,int topf)\n{\n  top[x]=topf;seg[x]=++seg[0];\n  if(!son[x])return;\n  dfs2(son[x],topf);\n  for(re i=head[x],y;i,y=go[i];i=next[i])\n    {\n      if(top[y])continue;\n      dfs2(y,y);\n    }\n}\nil void build(int k,int l,int r)\t//\u5efa\u6811\uff0c\u6bcf\u4e2a\u70b9\u521d\u59cb\u503c\u4e3a1\n{\n  if(l==r){sum[k]=1;return;}\n  int mid=l+r>>1;\n  build(k<<1,l,mid);build(k<<1|1,mid+1,r);\n  sum[k]=sum[k<<1]+sum[k<<1|1];\n}\nil void change(int k,int l,int r,int x,int z)\n{\n  if(l==r){sum[k]=z;return;}\n  int mid=l+r>>1;\n  if(x<=mid)change(k<<1,l,mid,x,z);\n  else change(k<<1|1,mid+1,r,x,z);\n  sum[k]=sum[k<<1]+sum[k<<1|1];\n}\nil bool query1(int k,int l,int r,int x,int y)\n{\n  if(x<=l&&y>=r){if(sum[k]==r-l+1)return 1;return 0;}\n  int mid=l+r>>1;\n  if(x<=mid)if(!query1(k<<1,l,mid,x,y))return 0;\n  if(y>mid)if(!query1(k<<1|1,mid+1,r,x,y))return 0;\n  return 1;\n}\nil void change1(int x,int y)\n{\n  if(father[x]==y)change(1,1,n,seg[x],0);//\u4fee\u6539\u513f\u5b50\u8282\u70b9\n  else change(1,1,n,seg[y],0);\n}\nil void change2(int x)\n{\n  int xx=u[x][0],yy=u[x][1];\n  if(father[xx]==yy)change(1,1,n,seg[xx],1);//\u4fee\u6539\u513f\u5b50\u8282\u70b9\n  else change(1,1,n,seg[yy],1);\n}\nil bool query(int x,int y)\n{\n  int fx=top[x],fy=top[y];\n  while(fx!=fy)\n    {\n      if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n      if(!query1(1,1,n,seg[fx],seg[x]))return 0;\n      x=father[fx];fx=top[x];\n    }\n  if(dep[x]>dep[y])swap(x,y);\n  if(seg[x]+1<=seg[y])if(!query1(1,1,n,seg[x]+1,seg[y]))return 0;\t\t//\u6ce8\u610fseg[x]\u8981+1\uff0c\n  return 1;\n}\nsigned main()\n{\n  n=read();m=read();\n  for(re i=1;i<n;i++){re x=read(),y=read();Add(x,y);Add(y,x);}\n  dfs1(1,0);dfs2(1,1);build(1,1,n);tot=0;\n  while(m--)\n    {\n      char ch;cin>>ch;\n      if(ch=='C'){u[++tot][0]=read();u[tot][1]=read();change1(u[tot][0],u[tot][1]);}\n      else if(ch=='Q'){re x=read(),y=read();if(query(x,y))puts(\"Yes\");else puts(\"No\");}\n      else {re x=read();change2(x);}\n    }\n  return 0;\n}\n```\n\n$$\\text{\u540e\u8bdd}$$\n\n$\\quad$\u6b64\u9898\u548c[CF165D Beard Graph](https://www.luogu.com.cn/problem/CF165D)\u5f88\u50cf\uff0c\u90a3\u9898\u4e5f\u6709[\u6211\u7684\u9898\u89e3](https://www.luogu.com.cn/blog/Farkas/solution-cf165d)\uff0c\u6b22\u8fce\u652f\u6301\u3002\n\n$\\quad$\u8c22\u8c22\u89c2\u8d4f\uff0c\u5199\u9898\u89e3\u4e0d\u6613\uff0c\u70b9\u4e2a\u8d5e\u5427\uff01",
        "postTime": 1604287019,
        "uid": 109220,
        "name": "Farkas_W",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u524d\u8a00\uff1a\u4f5c\u4e3a\u56e0\u5b66\u4e1a\u6545\u65e0\u6cd5\u7ee7\u7eed\u73a9$COC$\u7684$5$\u5e74\u8001\u73a9\u5bb6\uff0c\u5bf9\u8fd9\u9898\u8fd8\u662f\u8981\u8d44\u74f7\u4e00\u4e0b\u7684\uff08\u56fe\u7247\u6ca1\u4e86\u633a\u53ef\u60dc\u7684\uff09\u3002\n\n\u597d\u7684\uff0c\u63a5\u4e0b\u6765\u8fdb\u5165\u6b63\u6587\u3002\n\n\u6211\u4eec\u89c2\u5bdf\u9898\u76ee\u7684\u8981\u6c42\uff0c\u53ef\u603b\u7ed3\u5982\u4e0b\uff1a\n\n```\n\u64cd\u4f5c\u4e3aQ\uff0c\u67e5\u8be2\u4ecep\u5230q\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u4e4b\u548c\u662f\u5426\u4e3a0\u3002\n\n\u64cd\u4f5c\u4e3aC\uff0c\u5bf9p\u5230q\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u5168\u90e8+1\u3002\n\n\u64cd\u4f5c\u4e3aU\uff0c\u5bf9\u7b2ck\u6b21C\u64cd\u4f5c\u4e2d\uff0cp\u5230q\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u5168\u90e8-1\u3002\n\n\u540c\u65f6\uff0c\u8fb9\u6743\u4e0d\u4e3a\u8d1f\u6570\u3002\n```\n\u90a3\u4e48\u8fd9\u5c31\u662f\u4e00\u4e2a\u6811\u5256\u677f\u5b50\u9898\u5566\u3002\n\n\u8981\u6ce8\u610f\u7684\u70b9\uff1a\u8fd9\u662f\u5904\u7406\u8fb9\u6743\u800c\u4e0d\u662f\u70b9\u6743\u3002\n\n\u5c06\u70b9\u6743\u53d8\u4e3a\u8fb9\u6743\u5904\u7406\u6709\u591a\u79cd\u65b9\u6cd5\uff0c\u6b64\u5904\u6211\u4eec\u91c7\u7528\u4e00\u79cd\u6bd4\u8f83\u65b9\u4fbf\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u628a\u8fb9\u6743\u653e\u5728$n-1$\u4e2a\u70b9\u4e0a\u5b58\u50a8\u3002\u5f53\u4fee\u6539\u548c\u67e5\u8be2\u65f6\u5c06\u6700\u540e\u4e00\u4e2a$LCA$\u51cf\u53bb\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u533a\u95f4\u4fee\u6539\u548c\u533a\u95f4\u67e5\u8be2\uff0c\u6b64\u5904\u6211\u4eec\u4f7f\u7528\u7ebf\u6bb5\u6811\u53bb\u7ef4\u62a4\u3002\n\n\u90a3\u4e48\u8fd9\u9898\u6574\u4e2a\u6846\u67b6\u5c31\u663e\u800c\u6613\u89c1\u4e86\uff08\u672c\u4eba\u4e0d\u4f1a$LCT$\uff0c\u544a\u8f9e\uff09\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std; const int N=300010;\n#define lc (x<<1)\n#define rc (x<<1|1)\n#define mid (l+r>>1)\nint n,m,head[N],f[N],maxE,d[N],son[N],size[N],id[N],top[N],nowid,pp[N],qq[N],cnt;\nint leaf[N<<2],flag[N<<2]; struct Edge{int nxt,to;}e[N<<1];\ninline void Add(int u,int v) {e[++maxE].nxt=head[u]; head[u]=maxE; e[maxE].to=v; }\nvoid DFS1(int x,int before)\n{\n\td[x]=d[before]+1; size[x]=1;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tif(e[i].to==before) continue; f[e[i].to]=x;\n\t\tDFS1(e[i].to,x); size[x]+=size[e[i].to];\n\t\tif(size[e[i].to]>size[son[x]]) son[x]=e[i].to;\n\t}\n}\nvoid DFS2(int x)\n{\n\tif(son[x])\n\t{\n\t\tid[son[x]]=++nowid;\n\t\ttop[son[x]]=top[x];\n\t\tDFS2(son[x]);\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt) \n\t{\n\t\tif(top[e[i].to]) continue;\n\t\tid[e[i].to]=++nowid;\n\t\ttop[e[i].to]=e[i].to;\n\t\tDFS2(e[i].to);\n\t}\t\n}\ninline void Change(int x,int l,int r,int k) {flag[x]+=k; leaf[x]+=k*(r-l+1); }\ninline void Push_Down(int x,int l,int r)\n{\n\tChange(lc,l,mid,flag[x]);\n\tChange(rc,mid+1,r,flag[x]);\n\tflag[x]=0;\n}\nvoid UpDate(int u,int v,int l,int r,int x,int k)\n{\n\tif(l>=u&&r<=v) {Change(x,l,r,k); return; }\n\tif(flag[x]) Push_Down(x,l,r);\n\tif(u<=mid) UpDate(u,v,l,mid,lc,k);\n\tif(v>mid) UpDate(u,v,mid+1,r,rc,k);\n\tleaf[x]=leaf[lc]+leaf[rc];\n}\nvoid UpDate_Road(int x,int y,int k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]]) swap(x,y);\n\t\tUpDate(id[top[x]],id[x],1,n,1,k);\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y]) swap(x,y);\n\tUpDate(id[x]+1,id[y],1,n,1,k);\n}\nint Ask(int u,int v,int l,int r,int x)\n{\n\tif(l>=u&&r<=v) return leaf[x];\n\tif(flag[x]) Push_Down(x,l,r);\n\tint res=0;\n\tif(u<=mid) res+=Ask(u,v,l,mid,lc);\n\tif(v>mid) res+=Ask(u,v,mid+1,r,rc);\n\treturn res;\n}\nint Ask_Road(int x,int y)\n{\n\tint ans=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(d[top[x]]<d[top[y]]) swap(x,y);\n\t\tans+=Ask(id[top[x]],id[x],1,n,1);\n\t\tx=f[top[x]];\n\t}\n\tif(d[x]>d[y]) swap(x,y);\n\tans+=Ask(id[x]+1,id[y],1,n,1);\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false); cin>>n>>m;\n\tfor(int i=1,u,v;i<n;i++) {cin>>u>>v; Add(u,v); Add(v,u); }\n\tDFS1(1,0); id[1]=++nowid; top[1]=1; DFS2(1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tchar opt; int p,q; cin>>opt;\n\t\tif(opt=='Q')\n\t\t{\n\t\t\tcin>>p>>q;\n\t\t\tif(Ask_Road(p,q)==0) cout<<\"Yes\"<<endl;\n\t\t\telse cout<<\"No\"<<endl;\n\t\t}\n\t\tif(opt=='C') {cin>>p>>q; pp[++cnt]=p; qq[cnt]=q; UpDate_Road(pp[cnt],qq[cnt],1); }\n\t\tif(opt=='U') {cin>>p; UpDate_Road(pp[p],qq[p],-1); }\n\t}\n\treturn 0;\n}\n```\n\u5e0c\u671b\u8fd8\u5728\u73a9\u6216\u66fe\u7ecf\u73a9\u8fc7$COC$\u7684$OIer$\u4eec\u6751\u5e84\u548c\u5e73\uff0c\u5b66\u4e1a\u6709\u6210(\u672c\u849f\u84bb\u53ef\u80fd\u8981\u5148\u9000\u5f79\u4e00\u6b65\u4e86$qwq$)\u3002",
        "postTime": 1571834307,
        "uid": 98618,
        "name": "Provicy",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950"
    },
    {
        "content": "$$\\color{cornflowerblue}{\\mathcal{Treaker}}$$\n## \u6811\u94fe\u5256\u5206\n\u4e00\u773c\u6811\u5256\u3002\u3002\n\n\u6211\u4eec\u53d1\u73b0\u53ea\u8981\u8fd9\u4e00\u6bb5\u8def\u4e0a\u6709\u4e00\u6761\u8def\u5f84\u4e0d\u80fd\u8d70\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5224\u5b9a\u4e3aNo\u3002\n\n\u90a3\u4e48\u662f\u4e0d\u662f\u7ef4\u62a4\u4e00\u4e0b\u533a\u95f4\u6700\u503c\u5c31\u884c\u4e86\u5462\u3002\u3002\u5bf9\uff0c\u662f\u6ef4\uff01\uff01\uff01\n\n\u6211\u4eec\u5bf9\u4e8e\u6253\u4ed7\u7684\u90e8\u843d\u95f4\u7684\u8def\u5f84\u8d4b\u503c\u4e3a1\uff0c\u505c\u6218\u5219\u8d4b\u503c\u4e3a0\u3002\n\n\u67e5\u8be2\u65f6\u770b\u8fd9\u6761\u8def\u5f84\u4e0a\u6700\u5927\u503c\u662f\u4e0d\u662f1\u5373\u53ef\u3002\u3002\u3002\n\n\u6ca1\u6709\u4e00\u904d\u5207\u6389\u7684\u539f\u56e0\u662f\uff0c\u505c\u6218\u65f6\u6ca1\u6709up\u3002\u3002\u3002\n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int N = 300005;\ninline int read()\n{\n    int x = 0 , f = 1;  char ch = getchar();\n    while(ch < '0' || ch > '9') {if(ch == '-')  f = -1; ch = getchar();}\n    while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n    return x * f;\n}\ninline int Max(int x,int y) {return x > y ? x : y;}\nint n , m , cnt;\nint dep[N] , fa[N] , size[N] , dfn[N] , top[N] , hs[N];\nchar ch;\nstruct Tree_Div\n{\n\tstruct war {int u , v;}e[N];\n\tstruct Edge\n\t{\n\t\tint to; Edge *nxt;\n\t\tEdge(int to = 0,Edge *nxt = NULL) : to(to) , nxt(nxt) {}\n\t}*head[N];\n\tinline void add(int u,int v) {head[u] = new Edge(v,head[u]);}\n\tvoid get_tree(int now)\n\t{\n\t\tsize[now] = 1;\n\t\tfor(Edge *i = head[now];i;i = i -> nxt)\n\t\t{\n\t\t\tint to = i -> to;\n\t\t\tif(to == 1 || dep[to]) continue;\n\t\t\tdep[to] = dep[now] + 1;\n\t\t\tfa[to] = now;\n\t\t\tget_tree(to);\n\t\t\tsize[now] += size[to];\n\t\t\tif(size[to] > size[hs[now]]) hs[now] = to;\n\t\t}\n\t}\n\tvoid dfs(int now,int topfa)\n\t{\n\t\tdfn[now] = ++cnt;\n\t\ttop[now] = topfa;\n\t\tif(hs[now]) dfs(hs[now],topfa);\n\t\tfor(Edge *i = head[now];i;i = i -> nxt)\n\t\t{\n\t\t\tint to = i -> to;\n\t\t\tif(to == hs[now] || to == fa[now]) continue;\n\t\t\tdfs(to,to);\n\t\t}\n\t}\n\tstruct node\n\t{\n\t\tnode *ls , *rs;\n\t\tint l , r , maxn;\n\t\tnode(int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL; maxn = 0;}\n\t\tinline void up() {maxn = Max(ls -> maxn,rs -> maxn);}\n\t}*root;\n\t#define mid ((p -> l + p -> r) >> 1)\n\tvoid build(node *&p,int l,int r)\n\t{\n\t\tp = new node(l,r);\n\t\tif(l == r) return;\n\t\tbuild(p -> ls,l,mid); build(p -> rs,mid+1,r);\n\t}\n\tvoid chenge(node *p,int x)\n\t{\n\t\tif(p -> l == p -> r) return (void)(p -> maxn = 1);\n\t\tchenge(x <= mid ? p -> ls : p -> rs,x);\n\t\tp -> up();\n\t}\n\tint query(node *p,int x,int y)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return p -> maxn;\n\t\treturn Max(x <= mid ? query(p -> ls,x,y) : 0,y > mid ? query(p -> rs,x,y) : 0);\n\t}\n\tinline int sec_query(int x,int y)\n\t{\n\t\tint res = 0; \n\t\twhile(top[x] != top[y])\n\t\t{\n\t\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\t\tres = Max(res,query(root,dfn[top[x]],dfn[x]));\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\tif(dep[x] < dep[y]) swap(x,y);\n\t\tif(dfn[y] < dfn[x]) res = Max(res,query(root,dfn[y]+1,dfn[x]));\n\t\treturn res;\n\t}\n\tvoid rev(node *p,int x)\n\t{\n\t\tif(p -> l == p -> r) return (void)(p -> maxn = 0);\n\t\trev(x <= mid ? p -> ls : p -> rs,x); p -> up();\n\t}\n\tinline void League_of_Legends()\n\t{\n\t\tn = read(); m = read();\n\t\tfor(int i = 1 , u , v;i < n;i ++)\n\t\t{\n\t\t\tu = read(); v = read();\n\t\t\tadd(u,v); add(v,u);\n\t\t}\n\t\tget_tree(1); dfs(1,1); cnt = 0; build(root,1,n);\n\t\tfor(int i = 1 , u , v , x;i <= m;i ++)\n\t\t{\n\t\t\tcin >> ch;\n\t\t\tif(ch == 'C') {u = read(); v = read(); e[++cnt] = (war){u,v}; chenge(root,dep[u] > dep[v] ? dfn[u] : dfn[v]);}\n\t\t\tif(ch == 'Q') {u = read(); v = read(); puts(sec_query(u,v) ? \"No\" : \"Yes\");}\n\t\t\tif(ch == 'U') {x = read(); u = e[x].u; v = e[x].v; rev(root,dep[u] > dep[v] ? dfn[u] : dfn[v]);}\n\t\t}\n\t}\n\tTree_Div() {root = NULL;}\n}Dungeon_Fighter;\nint main()\n{\n\tDungeon_Fighter.League_of_Legends();\n\treturn 0;\n}\n\n```\n",
        "postTime": 1569625072,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u542c\u4e86\u5b66\u5f1f\u590d\u8ff0\u7684\u9898\u89e3\uff0c\u611f\u89c9\u771f\u662f\u7384\u5999\u554a\u2026\u2026\u7136\u800c\u4f5c\u4e3a\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u5b66\u50bb\uff0c\u5f53\u7136\u4e00\u5b9a\u8981\u7528\u6811\u5256A\u4e00\u4e0b\u5566\u2026\u2026\n\n\u601d\u8def\u5f88\u7b80\u5355\uff0c\u7ed9\u6bcf\u6761\u8fb9\u8bbe\u5b9a\u4e00\u4e2a\u5e03\u5c14\u503c\uff0cfalse\u8868\u793a\u8fd9\u6761\u8fb9\u4e0d\u80fd\u8d70\uff0ctrue\u8868\u793a\u8fd9\u6761\u8fb9\u53ef\u4ee5\u8d70\uff0c\u521d\u59cb\u65f6\u6240\u6709\u8fb9\u7684\u503c\u5747\u4e3atrue\uff0c\u82e5\u4e24\u4e2a\u90bb\u63a5\u7684\u70b9\u4e4b\u95f4\u53d1\u751f\u6218\u4e89\u5219\u5c06\u8fd9\u6761\u8fb9\uff08\u5176\u5b9e\u5c31\u662fu\u5230v\u4e4b\u95f4\u6240\u6709\u7684\u8fb9\uff09\u95f4\u6240\u6709\u7684\u503c\u53d6\u53cd\uff0c\u6218\u4e89\u7ed3\u675f\u4e5f\u53d6\u53cd\uff0c\u67e5\u8be2u,v\u662f\u5426\u53ef\u8fbe\u65f6\u5c31\u662f\u67e5\u8be2u\u5230v\u95f4\u6240\u6709\u8fb9\u7684\u503c\u7684\u6309\u4f4d\u4e0e\uff0cfalse\u5219\u4e0d\u53ef\u8fbe\uff0ctrue\u5219\u53ef\u8fbe\u3002\u53d1\u73b0\u4ee5\u4e0a\u64cd\u4f5c\u90fd\u662f\u5bf9\u94fe\u8fdb\u884c\u7684\uff0c\u6240\u4ee5\u53ef\u4ee5\u4f7f\u7528\u6811\u5256\u89e3\u51b3\u3002\n\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+10,maxm=6e5+10;\nint heade[maxn],ev[maxm],nexte[maxm];\nint dep[maxn],size[maxn],son[maxn],fa[maxn];\nint top[maxn],tid[maxn],nid[maxn];\nint war[2][maxn];\nbool node[4*maxn],lazy[4*maxn];//lazy\u4e3atrue\u5219\u8868\u793a\u88ab\u53d6\u53cd\u8fc7\nint n,m,tot=0,root,idx=-1,num=0;bool ans;\nvoid add_edge(int u,int v){ev[++tot]=v;nexte[tot]=heade[u];heade[u]=tot;}\nvoid fdfs(int ui)\n{\n    int i,vi;\n    size[ui]=1;son[ui]=0;\n    for(i=heade[ui];~i;i=nexte[i])\n    {\n        vi=ev[i];if(vi==fa[ui]){continue;}\n        dep[vi]=dep[ui]+1;fa[vi]=ui;\n        fdfs(vi);size[ui]+=size[vi];\n        if(size[vi]>size[son[ui]]){son[ui]=vi;}\n    }\n}\nvoid sdfs(int ui,int anc)\n{\n    int i,vi;\n    top[ui]=anc;tid[ui]=++idx;nid[idx]=ui;\n    if(son[ui]){sdfs(son[ui],anc);}\n    for(i=heade[ui];~i;i=nexte[i])\n    {\n        vi=ev[i];if(vi==fa[ui]||vi==son[ui]){continue;}\n        sdfs(vi,vi);\n    }\n}\nvoid pushup(int x){node[x]=node[2*x]&node[2*x+1];}\nvoid build(int x,int l,int r)\n{\n    if(l==r){node[x]=true;return;}\n    int mid=(l+r)>>1;\n    build(2*x,l,mid);build(2*x+1,mid+1,r);\n    pushup(x);\n}\nvoid pushdown(int x)\n{\n    lazy[2*x]^=1;lazy[2*x+1]^=1;\n    node[2*x]^=1;node[2*x+1]^=1;\n    lazy[x]=false;\n}\nvoid change(int x,int l,int r,int sj,int tj)\n{\n    if(sj>tj){swap(sj,tj);}\n    if(sj<=l&&r<=tj){node[x]^=1;lazy[x]^=1;return;}\n    int mid=(l+r)>>1;\n    if(lazy[x]){pushdown(x);}\n    if(sj<=mid){change(2*x,l,mid,sj,tj);}\n    if(mid+1<=tj){change(2*x+1,mid+1,r,sj,tj);}\n    pushup(x);\n}\nvoid query(int x,int l,int r,int sj,int tj)\n{\n    if(sj>tj){swap(sj,tj);}\n    if(sj<=l&&r<=tj){ans&=node[x];return;}\n    int mid=(l+r)>>1;\n    if(lazy[x]){pushdown(x);}\n    if(sj<=mid){query(2*x,l,mid,sj,tj);}\n    if(mid+1<=tj){query(2*x+1,mid+1,r,sj,tj);}\n    pushup(x);\n}\nvoid add(int u,int v)\n{\n    if(dep[u]<dep[v]){swap(u,v);}\n    change(1,1,n-1,tid[u],tid[u]);\n}\nvoid work(int u,int v)\n{\n    int x=top[u],y=top[v];\n    ans=true;\n    while(x!=y)\n    {\n        if(dep[x]<dep[y]){swap(x,y);swap(u,v);}\n        query(1,1,n-1,tid[x],tid[u]);\n        u=fa[x];x=top[u];\n    }\n    if(u!=v)\n    {\n        if(dep[u]<dep[v]){swap(u,v);}\n        query(1,1,n-1,tid[son[v]],tid[u]);\n    }\n    if(ans){printf(\"Yes\\n\");}else{printf(\"No\\n\");}\n}\nint main()\n{\n    int i,j,u,v,x;char flag[10];\n    cin>>n>>m;root=(1+n)>>1;\n    memset(heade,-1,sizeof(heade));\n    for(i=1;i<n;i++){scanf(\"%d%d\",&u,&v);add_edge(u,v);add_edge(v,u);}\n    fdfs(root);sdfs(root,root);build(1,1,n-1);\n    for(i=1;i<=m;i++)\n    {\n        scanf(\"%s\",flag);\n        if(flag[0]=='U'){scanf(\"%d\",&x);/*printf(\"%c %d\\n\",flag[0],x);*/u=war[0][x];v=war[1][x];add(u,v);}\n        else\n        {\n            scanf(\"%d %d\",&u,&v);\n            if(flag[0]=='C'){num++;war[0][num]=u;war[1][num]=v;add(u,v);}\n            else{/*cout<<\"oper;\"<<endl;*/work(u,v);}\n            //printf(\"%c %d %d\\n\",flag[0],u,v);\n        }\n    }\n    return 0;\n}\n\n```\n\u5176\u5b9e\u611f\u89c9\u7528\u6811\u5256\u505a\u786e\u5b9e\u662f\u6740\u9e21\u7528\u725b\u5200\u4e86\uff0c\u5982\u679cn\u8fbe\u52301e6\u7684\u8bdd\u5e94\u8be5\u5c31\u4f1a\u88ab\u5361\u7684\u5427\u2026\u2026\n",
        "postTime": 1509613927,
        "uid": 17913,
        "name": "\u9752\u77f3\u5df7",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "## \u5c31\u662f\u88f8\u7684\u6811\u5256\n~~(\u4e00\u904d\u6c34\u8fc7 \u9f9f\u901f\u9003)~~\n\n**\u5206\u6790\u4e0b\u9898\u76ee**\n\n\u4f60\u9700\u8981\u7ef4\u62a4\u4e09\u4e2a\u64cd\u4f5c\uff1a\n\n**1,\u5efa\u7b51\u5de5\u4eba\u4e3a\u4e86\u4e0d\u8dd1\u51a4\u6789\u8def\uff0c\u5411\u4f60\u8be2\u95ee \u989d~~~\u867d\u7136\u4f60\u4e0d\u60f3\u56de\u7b54~~**\n\n\u600e\u6837\u5224\u5b9a\u5728[u,v]\u4e0a\u6253\u4ed7\u4e86\u5462\uff1f\u5f88\u7b80\u5355\uff0c\u5728\u6253\u4ed7\u7684\u5730\u65b9\u8d4b\u503c\u4e3a1\uff0c\u7ef4\u62a4\u533a\u95f4\u6700\u5927\uff0c\u53ea\u8981\u533a\u95f4\u6700\u5927\u4e0d\u662f0\uff0c\u5c31\u80af\u5b9a\u5728\u6253\u4ed7\u5566\uff01\u60f3\u9171\uff1a\n```cpp\n\ninline int Ask(int k,int l,int r,int a,int b) {\n\tif(a <= l && r <= b) return tr[k];\n\tint mid = (l + r) >> 1,res = 0;\n\tif(a <= mid) res = max(res,Ask(k << 1,l,mid,a,b));\n\tif(b > mid) res = max(res,Ask(k << 1 | 1,mid + 1,r,a,b));\n\treturn res;\n}\n\ninline int Qurry(int u,int v) {\n\tint res = 0;\n\twhile(top[u] != top[v]) {\n\t\tif(dep[top[u]] < dep[top[v]]) swap(u,v);\n\t\tres = max(res,Ask(1,1,n,tpos[top[u]],tpos[u]));\n\t\tu = fa[top[u]];\n\t}\n\tif(tpos[u] > tpos[v]) swap(u,v);\n\tres = max(res,Ask(1,1,n,tpos[u] + 1,tpos[v]));\n   \t //\u56e0\u4e3a\u662f\u8fb9\u6743\u4e0b\u653e\u5230\u70b9\uff0c\u6240\u4ee5tpos[u]\u8981\u52a01\uff1b\n\treturn res;\n}\n```\n\u4e3b\u51fd\u6570\u5c31\u662f\u9171\uff1a\n```cpp\nif(s[1] == 'Q') {\n\tint u = read(),v = read();\n\tif(u > v) swap(u,v);\n\tif(Qurry(u,v)) printf(\"No\\n\");\n\telse printf(\"Yes\\n\");\n}\n```\n**2,\u6253\u4ed7\u5566\uff0c\u5c01\u8def\u4e86\uff0c~~\u56de\u5bb6\u6536\u8863\u670d\u5566~~**\n\n\u7531\u4e8e\u9898\u76ee\u4fdd\u8bc1\u4e24\u4e2a\u70b9\u76f8\u90bb\uff0c\u90a3\u4e48\uff0c\u6807\u8bb0\u8fb9\u5c31\u53d8\u4e3a\u5355\u70b9\u4fee\u6539(\u8d4b\u4e00)\uff0c\u7c7b\u4f3c\u4e8e\u8fb9\u6743\u4e0b\u653e\u70b9\u6743\uff1b\n\u5f53\u7136\uff0c\u8003\u8651\u5230\u4e00\u4f1a\u7684\u505c\u6218\uff0c\u8fd8\u8981\u987a\u5e26\u8bb0\u5f55\u4e00\u4e0b\uff0c\u5c31\u9171\uff1a\n```cpp\nif(s[1] == 'C') {\n\ttag ++;\n\ta[tag].u = read(); a[tag].v = read();\n\tint _ = max(a[tag].u,a[tag].v);//\u7ed9\u70b9\u6570\u5927\u7684\u5c31\u884c\u5566\n\tChange(1,1,n,tpos[_],1); //\u4fee\u6539\u5c31\u662f\u5355\u70b9\u8d4b\u503c\uff0c\u4e0d\u591a\u8d58\u8ff0\n}\n```\n\n**3,\u505c\u6218\u55bd\uff0c\u53c8\u8fc7\u4e0a\u5e78\u798f\u5b89\u5eb7\u7684\u751f\u6d3b**\n\n\u6211\u4eec\u4e0a\u9762\u7ef4\u62a4\u4e86\u4e4b\u524d\u7684\u6218\u4e89\uff0c\u73b0\u5728\u5c31\u53ef\u76f4\u63a5\u4fee\u6539\u5373\u53ef\uff0c\u4e4b\u524d\u8d4b\u4e00\uff0c\u73b0\u5728\u6539\u4e3a\u96f6\u5c31\u884c\u5566\n```cpp\nif(s[1] == 'U') {\n\tint x = read();\n\tint _ = max(a[x].u,a[x].v);\n\tChange(1,1,n,tpos[_],0);\n}\n```\n### \u6700\u540e\u6492\u82b1\u653e\u4ee3\u7801\uff1a\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#define N 700500\nusing namespace std;\n\ninline int read() {\n    int x = 0,f = 1; char s = getchar();\n    while(s < '0' || s > '9') {if(s == '-') f = -1;s = getchar();}\n    while(s >= '0' && s <= '9') {x = x * 10 + s - '0';s = getchar();}\n    return f * x;\n}\n\nint n,m;\nint head[N],cnt;\nstruct node {\n\tint nxt,to;\n}e[N];\nint tpos[N],top[N],dep[N];\nint fa[N],wson[N],size[N];\nint tot,tag,tr[N * 4];\nstruct TE {\n\tint u,v;\n}a[N];\n\ninline void cp(int u,int v) {\n\tcnt ++;\n\te[cnt].to = v;\n\te[cnt].nxt = head[u];\n\thead[u] = cnt;\n}\n\ninline void dfs1(int u,int f) {\n\tsize[u] = 1;\n\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif(v == f) continue;\n\t\tfa[v] = u, dep[v] = dep[u] + 1;\n\t\tdfs1(v,u);\n\t\tsize[u] += size[v];\n\t\tif(size[v] > size[wson[u]]) wson[u] = v;\n\t}\n}\n\ninline void dfs2(int u,int Top) {\n\ttop[u] = Top;\n\ttpos[u] = ++ tot;\n\tif(wson[u]) dfs2(wson[u],Top);\n\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif(v == wson[u] || v == fa[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\n\ninline void Update(int k) {\n\ttr[k] = max(tr[k << 1],tr[k << 1 | 1]);\n}\n\ninline void Change(int k,int l,int r,int a,int b) {\n\tif(l == r) {\n\t\ttr[k] = b;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(a <= mid) Change(k << 1,l,mid,a,b);\n\tif(a > mid) Change(k << 1 | 1,mid + 1,r,a,b);\n\tUpdate(k);\n}\n\ninline int Ask(int k,int l,int r,int a,int b) {\n\tif(a <= l && r <= b) return tr[k];\n\tint mid = (l + r) >> 1,res = 0;\n\tif(a <= mid) res = max(res,Ask(k << 1,l,mid,a,b));\n\tif(b > mid) res = max(res,Ask(k << 1 | 1,mid + 1,r,a,b));\n\treturn res;\n}\n\ninline int Qurry(int u,int v) {\n\tint res = 0;\n\twhile(top[u] != top[v]) {\n\t\tif(dep[top[u]] < dep[top[v]]) swap(u,v);\n\t\tres = max(res,Ask(1,1,n,tpos[top[u]],tpos[u]));\n\t\tu = fa[top[u]];\n\t}\n\tif(tpos[u] > tpos[v]) swap(u,v);\n\tres = max(res,Ask(1,1,n,tpos[u] + 1,tpos[v]));\n\treturn res;\n}\n\nint main() {\n\tn = read(),m = read();\n\tfor(int i = 1;i < n;i ++) {\n\t\tint u = read(),v = read();\n\t\tcp(u,v); cp(v,u);\n\t}\n\tdep[1] = fa[1] = 1;\n\tdfs1(1,-1),dfs2(1,1);\n\tfor(int i = 1;i <= m;i ++) {\n\t\tchar s[5]; scanf(\"%s\",s + 1);\n\t\tif(s[1] == 'C') {\n\t\t\ttag ++;\n\t\t\ta[tag].u = read(); a[tag].v = read();\n\t\t\tint _ = max(a[tag].u,a[tag].v);\n\t\t\tChange(1,1,n,tpos[_],1);\n\t\t}\n\t\tif(s[1] == 'Q') {\n\t\t\tint u = read(),v = read();\n\t\t\tif(u > v) swap(u,v);\n\t\t\tif(Qurry(u,v)) printf(\"No\\n\");\n\t\t\telse printf(\"Yes\\n\");\n\t\t}\n\t\tif(s[1] == 'U') {\n\t\t\tint x = read();\n\t\t\tint _ = max(a[x].u,a[x].v);\n\t\t\tChange(1,1,n,tpos[_],0);\n\t\t}\n\t}\n}\n```",
        "postTime": 1569504753,
        "uid": 153839,
        "name": "\u6e05\u8fdc\u5b66\u4f1a",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "emmm\u2026\u2026\u6807\u7b7e\u91cc\u9762\u4e3a\u4ec0\u4e48\u6ca1\u6709$link-cut-tree$\u7684\u6807\u7b7e\u5462\uff1f\n\n\u8fd9\u9053\u9898\u660e\u663e\u8003\u5bf9\u9898\u610f\u7684\u7406\u89e3\u3002\n\n\u9996\u5148\uff0c\u6211\u4eec\u628a\u5728[P3690 \u3010\u6a21\u677f\u3011Link Cut Tree \uff08\u52a8\u6001\u6811\uff09](https://www.luogu.org/problemnew/show/P3690)\u7684AC\u4ee3\u7801\u62ff\u8fc7\u6765\uff08\u6a21\u677f\u6211\u662f\u53c2\u8003\u7f51\u4e0a\u7684\uff09\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\nconst int maxn=500050;\nint ch[maxn][2],par[maxn],val[maxn],rev[maxn],sum[maxn],sta[maxn];\nbool chk(int x)\n{\n\treturn ch[par[x]][0]==x||ch[par[x]][1]==x;\n}\nvoid update(int x)\n{\n\tsum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];\n}\nvoid reverse(int x)\n{\n\tswap(ch[x][0],ch[x][1]);\n\trev[x]^=1;\n}\nvoid pushdown(int x)\n{\n\tif (rev[x])\n\t{\n\t\trev[x]=0;\n\t\treverse(ch[x][0]),reverse(ch[x][1]);\n\t}\n}\nvoid rotate(int x)\n{\n\tint y=par[x],z=par[y],k=(ch[y][1]==x),w=ch[x][k^1];\n\tif (chk(y)) ch[z][ch[z][1]==y]=x;\n\tch[x][k^1]=y,ch[y][k]=w;\n\tif (w) par[w]=y;\n\tpar[y]=x,par[x]=z;\n\tupdate(x),update(y);\n}\nvoid splay(int x)\n{\n\tint y=x,z=0;\n\tsta[++z]=y;\n\twhile (chk(y)) sta[++z]=y=par[y];\n\twhile (z) pushdown(sta[z--]);\n\twhile (chk(x))\n\t{\n\t\ty=par[x],z=par[y];\n\t\tif (chk(y)) rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);\n\t\trotate(x);\n\t}\n\tupdate(x);\n}\nvoid access(int x)\n{\n\tfor (int y=0;x;x=par[y=x])\n\t\tsplay(x),ch[x][1]=y,update(x);\n}\nvoid makeroot(int x)\n{\n\taccess(x),splay(x),reverse(x);\n}\nint findroot(int x)\n{\n\taccess(x),splay(x);\n\twhile (ch[x][0]) pushdown(x),x=ch[x][0];\n\treturn x;\n}\nvoid split(int x,int y)\n{\n\tmakeroot(x),access(y),splay(y);\n}\nvoid link(int x,int y)\n{\n\tmakeroot(x);\n\tif (findroot(y)!=x) par[x]=y;\n}\nvoid cut(int x,int y)\n{\n\tsplit(x,y);\n\tif (findroot(y)==x&&par[x]==y&&!ch[x][1]) ch[y][0]=par[x]=0;\n}\nint n,m,x,y,opt;\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&val[i]);\n\twhile (m--)\n\t{\n\t\tscanf(\"%d%d%d\",&opt,&x,&y);\n\t\tif (opt==0) split(x,y),printf(\"%d\\n\",sum[y]);\n\t\tif (opt==1) link(x,y);\n\t\tif (opt==2) cut(x,y);\n\t\tif (opt==3) splay(x),val[x]=y;\n\t}\n\treturn 0;\n}\n```\n\n\u4e4b\u540e\uff0c\u6211\u4eec\u6765\u7ec6\u7ec6\u5730\u7406\u89e3\u4e00\u4e0b\u9898\u610f\u3002\uff08\u8bdd\u8bf4\u8fd9\u4e2a\u9898\u610f\u771f\u7684\u6709\u70b9\u5751\uff09\n\n\u5bf9\u4e8e$Q$\u64cd\u4f5c\uff0c\u5c31\u662f\u8be2\u95ee\u4e24\u4e2a\u70b9\u5728\u6811\u4e2d\u7684\u6839\u662f\u5426\u76f8\u540c\uff0c\u76f4\u63a5\n\n```cpp\nfindroot(x)==findroot(y)\n```\n\u5224\u65ad\u5373\u53ef\u3002\n\n\u5bf9\u4e8e$C$\u64cd\u4f5c\uff0c\u5207\u65ad\u8fd9\u4e24\u6761\u51c6\u5907\u5f00\u6218\u7684\u70b9\u4e4b\u95f4\u7684\u8fb9\u5373\u53ef\u3002\n\n\u4f46\u662f\u8981\u6ce8\u610f\uff0c\u6211\u4eec\u5fc5\u987b\u8981\u7528\u4e24\u4e2a\u6876\u88c5\u7740\u8fd9\u4e24\u4e2a\u88ab\u5220\u9664\u7684\u8fb9\uff0c\u64cd\u4f5c3\u4f1a\u7528\u5230\u3002\n\n```cpp\nint bin1[maxn],bin2[maxn],stop;\nbin1[++stop]=x,bin2[stop]=y;\ncut(x,y);\n```\n\n\u5bf9\u4e8e$U$\u64cd\u4f5c\uff0c\u8fd9\u662f\u4e00\u4e2a\u6bd4\u8f83\u7ed5\u7684\u4e1c\u897f\u3002\n\n\u4e0a\u9762\u7684\u9898\u76ee\u80cc\u666f\u8bf4\u5230\uff1a\n\n> \u201c\u5929\u4e0b\u4e4b\u52bf\uff0c\u5206\u4e45\u5fc5\u5408\uff0c\u5f53\u4e24\u4e2a\u90e8\u843d\u7ecf\u5386\u4e86\u4e0d\u6253\u4e0d\u76f8\u8bc6\u7684\u82e6\u6218\u4e4b\u540e\uff0c\u4ed6\u4eec\u53ef\u4ee5\u7b7e\u8ba2\u505c\u6218\u534f\u8bae\uff08\u6682\u65f6\u505c\u6218\uff0c\u4ee5\u540e\u4f9d\u65e7\u53ef\u80fd\u518d\u6b21\u5f00\u6218\uff09\uff0c\u8fd9\u6837\uff0c\u4e24\u4e2a\u90e8\u843d\u4e4b\u95f4\u7684\u9053\u8def\u53c8\u4f1a\u91cd\u65b0\u6062\u590d\u4e3a\u53ef\u901a\u884c\u72b6\u6001\uff0c\u5efa\u7b51\u5de5\u4eba\u4eec\u53c8\u53ef\u4ee5\u7ecf\u8fc7\u6b64\u5730\u8d2d\u4e70\u6700\u65b0\u7684\u5927\u672c\u8425\u8bbe\u8ba1\u56fe\u7eb8\u6765\u5f3a\u5927\u81ea\u5df1\u7684\u90e8\u843d\u4e86\u3002\u201d\n\n\u8bf4\u660e\u5982\u679c\u6267\u884c\u4e86$U$\u64cd\u4f5c\uff0c\u90a3\u4e48\u7b2cx\u4e2a\u5f00\u6218\u7684\u4e24\u4e2a\u56fd\u5bb6\u5c31\u505c\u6218\u4e86\uff0c\u90a3\u4e48\u9053\u8def\u5c31\u91cd\u65b0\u5f00\u653e\u4e86\uff0c\u5c31\u8981\u518d\u6b21link\u56de\u53bb\u3002\n\n\u6240\u4ee5\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u7b80\u5316\u6210\u5982\u4e0b\uff1a\n\n1. \u8be2\u95eex\u7684\u6839\u662f\u5426\u4e0ey\u7684\u6811\u6839\u76f8\u540c\uff1b\n2. \u5c06x\u4e0ey\u4e4b\u95f4\u7684\u8fb9\u5207\u65ad\uff1b\n3. \u5c06\u7b2cx\u6b21\u5207\u65ad\u7684\u4e24\u6761\u8fb9\u8fde\u56de\u6765\u3002\n\n~~\u6240\u4ee5\u8fd9\u8fd8\u662f\u4e00\u9053\u6a21\u677f\u9898\u561b\u5bf9\u4e0d\u5bf9~~\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include<cctype>\nconst int maxn=500050;\nint ch[maxn][2],par[maxn],val[maxn],rev[maxn],sum[maxn],sta[maxn];\nint bin1[maxn],bin2[maxn],stop;\ninline int read()\n{\n    int X=0,w=0; char ch=0;\n    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    return w?-X:X;\n}\nbool chk(int x)\n{\n\treturn ch[par[x]][0]==x||ch[par[x]][1]==x;\n}\nvoid update(int x)\n{\n\tsum[x]=sum[ch[x][0]]^sum[ch[x][1]]^val[x];\n}\nvoid reverse(int x)\n{\n\tstd::swap(ch[x][0],ch[x][1]);\n\trev[x]^=1;\n}\nvoid pushdown(int x)\n{\n\tif (rev[x])\n\t{\n\t\trev[x]=0;\n\t\treverse(ch[x][0]),reverse(ch[x][1]);\n\t}\n}\nvoid rotate(int x)\n{\n\tint y=par[x],z=par[y],k=(ch[y][1]==x),w=ch[x][k^1];\n\tif (chk(y)) ch[z][ch[z][1]==y]=x;\n\tch[x][k^1]=y,ch[y][k]=w;\n\tif (w) par[w]=y;\n\tpar[y]=x,par[x]=z;\n\tupdate(x),update(y);\n}\nvoid splay(int x)\n{\n\tint y=x,z=0;\n\tsta[++z]=y;\n\twhile (chk(y)) sta[++z]=y=par[y];\n\twhile (z) pushdown(sta[z--]);\n\twhile (chk(x))\n\t{\n\t\ty=par[x],z=par[y];\n\t\tif (chk(y)) rotate((ch[y][0]==x)^(ch[z][0]==y)?x:y);\n\t\trotate(x);\n\t}\n\tupdate(x);\n}\nvoid access(int x)\n{\n\tfor (int y=0;x;x=par[y=x])\n\t\tsplay(x),ch[x][1]=y,update(x);\n}\nvoid makeroot(int x)\n{\n\taccess(x),splay(x),reverse(x);\n}\nint findroot(int x)\n{\n\taccess(x),splay(x);\n\twhile (ch[x][0]) pushdown(x),x=ch[x][0];\n\treturn x;\n}\nvoid split(int x,int y)\n{\n\tmakeroot(x),access(y),splay(y);\n}\nvoid link(int x,int y)\n{\n\tmakeroot(x);\n\tif (findroot(y)!=x) par[x]=y;\n}\nvoid cut(int x,int y)\n{\n\tsplit(x,y);\n\tif (findroot(y)==x&&par[x]==y&&!ch[x][1]) ch[y][0]=par[x]=0;\n}\nint n,m,x,y;\nint main()\n{\n\tchar opt[10];\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tint tmp1=read(),tmp2=read();\n\t\tlink(tmp1,tmp2);\n\t}\n\twhile (m--)\n\t{\n\t\tscanf(\"%s\",opt);\n\t\tif (opt[0]=='Q')\n\t\t{\n\t\t\tx=read(),y=read();\n\t\t\tif (findroot(x)==findroot(y)) printf(\"Yes\\n\");\n\t\t\telse printf(\"No\\n\");\n\t\t}\n\t\telse if (opt[0]=='C')\n\t\t{\n\t\t\tx=read(),y=read();\n\t\t\tbin1[++stop]=x,bin2[stop]=y;\n\t\t\tcut(x,y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx=read();\n\t\t\tlink(bin1[x],bin2[x]);\n\t\t}\t\n\t}\n\treturn 0;\n}\n```\n\n### \u540e\u8bb0\n\n$link-cut-tree$\u8fd9\u4e2a\u4e1c\u897f\u5e38\u6570\u662f\u771f\u7684\u5927\uff0c\u4e0d\u52a0\u4efb\u4f55\u4f18\u5316\u6700\u540e\u4e00\u4e2a\u70b9$1023ms$\uff0c\u7adf\u7136\u6ca1\u8fc7\uff0c\u5bb3\u5f97\u6211\u52a0\u4e86\u4e2a\u5feb\u8bfb\uff0c\u624d\u52c9\u5f3a\u64e6\u8fb9\uff08$982ms$\uff09\n\n\u603b\u4e4b\u662f\u8981\u52a0\u5f3a\u5bf9\u9898\u76ee\u7684\u7406\u89e3\u80fd\u529b\u2026\u2026",
        "postTime": 1552887687,
        "uid": 114479,
        "name": "presucc",
        "ccfLevel": 6,
        "title": "\u3010P3950 \u90e8\u843d\u51b2\u7a81\u3011\u9898\u89e3"
    },
    {
        "content": "# \u66b4\u529blct\u89e3\u51b3\u4e00\u5207\u95ee\u9898\n\n\u4e00\u5f00\u59cb\u5148link\uff0c\u5f00\u6218cut\uff0c\u505c\u6218link\uff0c\u67e5\u8be2makeroot+findroot\n\n\u5e38\u6570\u5927\u4e5f\u6ca1\u6709\u5173\u7cfb\uff0c1424ms\u7a33\u7a33\u5730\u8fc7\u4e86\n\nLCT\u7ec3\u624b\u9898\n\n```cpp\n#include<bits/stdc++.h>\n#define ls ch[x][0]\n#define rs ch[x][1]\n#define sz 301010\nusing namespace std;\nint tag[sz],fa[sz],ch[sz][2],st[sz];\nbool nroot(int x){return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}\nbool get(int x){return ch[fa[x]][1]==x;}\nvoid pushdown(int x)\n{\n\tif (tag[x])\n\t{\n\t\ttag[x]=0;\n\t\tif (ls) tag[ls]^=1;\n\t\tif (rs) tag[rs]^=1;\n\t\tswap(ls,rs);\n\t}\n}\nvoid rotate(int x)\n{\n\tint y=fa[x],z=fa[y],k=get(x),w=ch[x][!k];\n\tif (w) fa[w]=y;\n\tch[y][k]=w;\n\tif (nroot(y)) ch[z][get(y)]=x;\n\tfa[x]=z;\n\tch[x][!k]=y;\n\tfa[y]=x;\n}\nvoid splay(int x)\n{\n\tint cnt=1;\n\tst[1]=x;\n\tfor (int i=x;nroot(i);i=fa[i]) st[++cnt]=fa[i];\n\tfor (int i=cnt;i;i--) pushdown(st[i]);\n\twhile (nroot(x))\n\t{\n\t\tint y=fa[x];\n\t\tif (nroot(y)) rotate(get(x)==get(y)?y:x);\n\t\trotate(x);\n\t}\n}\nvoid access(int x)\n{\n\tfor (int y=0;x;x=fa[y=x])\n\t{\n\t\tsplay(x);\n\t\tch[x][1]=y;\n\t}\n}\nvoid makeroot(int x){access(x);splay(x);tag[x]^=1;}\nint findroot(int x)\n{\n\taccess(x);splay(x);\n\twhile (ls) pushdown(x),x=ls;\n\treturn x;\n}\nvoid link(int x,int y)\n{\n\tmakeroot(x);\n\tif (findroot(y)!=x) fa[x]=y;\n}\nvoid cut(int x,int y)\n{\n\tmakeroot(x);\n\tif (findroot(y)==x&&fa[x]==y&&!rs) fa[x]=ch[y][0]=0;\n}\nint war[sz][2];\nint main()\n{\n\tregister int i=0,x,y,n,m;\n\tregister char ch;\n\tscanf(\"%d %d\",&n,&m);\n\tn--;\n\twhile (n--) scanf(\"%d %d\",&x,&y),link(x,y);\n\twhile (m--)\n\t{\n\t\tcin>>ch;\n\t\tif (ch=='U') scanf(\"%d\",&x),link(war[x][0],war[x][1]);\n\t\telse if (ch=='Q') scanf(\"%d %d\",&x,&y),makeroot(x),puts(findroot(y)==x?\"Yes\":\"No\");\n\t\telse scanf(\"%d %d\",&x,&y),cut(x,y),war[++i][0]=x,war[i][1]=y;\n\t}\n}\n```",
        "postTime": 1525769080,
        "uid": 76481,
        "name": "p_b_p_b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u5173\u4e8e\u90e8\u843d\u51b2\u7a81\u8fd9\u9053\u9898\u76ee\uff0c\u5bf9\u8fd9\u4e2a\u9898\u76ee\u77e5\u5e95\u7684\u540c\u5b66\u60f3\u5fc5\u77e5\u9053\uff0c\u6700\u521d\u8fd9\u662f\u4e00\u9053\u6a21\u62df\u8d5b\u7684\u9898\uff0c\u5f53\u65f6\u4e0d\u4f1a\u3002\u73b0\u5728\u6211\u5c31\u662f\u6a21\u62df\u8003\u8bd5\u8ffd\u6c42\u901f\u5ea6\u6ca1\u600e\u4e48\u52a8\u8111\u5b50\uff0c\u6253\u4e86\u4e2a\u51e0\u4e4e\u88f8\u7684\u6811\u5256\uff0c\u61c2\u7684\u4eba\u5f53\u7136\u4e00\u4e0b\u5c31\u4f1a\u660e\u767d\uff0c\u4e0d\u61c2\u7684\u4e5f\u80fd\u627e\u627e\u542f\u53d1\u3002\u6211\u5176\u5b9e\u4e5f\u662f\u770b\u4e86\u53e6\u4e00\u7bc7\u9898\u89e3\u7684\uff0c\u5e0c\u671b\u80fd\u5199\u7684\u66f4\u8be6\u7ec6\u4e00\u70b9\u3002\n\n\n\n\u89e3\u9898\u601d\u8def\uff1a\n\n1.\u628a\u6bcf\u4e00\u6761\u8fb9\u770b\u4e3a\u65e0\u6743\u503c\uff0c\u53cd\u4e4b\u7ed9\u70b9\u5e26\u6743\u503c\uff0c\u521d\u59cb\u5316\u4e3a1\n\n2.\u5982\u679c\u6218\u4e89\u7684\u8bdd\uff0c\u9009\u53d6\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\u6743\u503c\u52a0\u4e00\n\n3.\u5982\u679c\u63d0\u95ee\u7684\u8bdd\uff0c\u76f4\u63a5\u770b\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u5927\u5c0f\uff08\u56e0\u4e3a\u53ea\u4f1a\u6709\u4e00\u6761\u8def\uff09\n\n4.\u6218\u4e89\u7528\u4e00\u4e2a\u6570\u7ec4\u5b58\u4e00\u4e0b\u5230\u65f6\u5019\u518d\u6539\u5c31\u597d\u4e86\n\n\n```cpp\nint dfs1(int x)\n{\n    size[x]=1;\n    for(int i=head[x]; i; i=e[i].next)\n    {\n        if(e[i].to==fa[x])\n            continue;\n        deep[e[i].to]=deep[x]+1;\n        fa[e[i].to]=x;\n        size[x]+=dfs1(e[i].to);\n        if(!son[x] || size[e[i].to]>size[son[x]])\n            son[x]=e[i].to;\n    }\n    return size[x];\n}\n```\n\u7b2c\u4e00\u904ddfs\u662f\u4e3a\u4e86\u627e\u51fa\u91cd\u513f\u5b50\uff08\u6982\u5ff5\u8bf7\u81ea\u5df1\u641c\u7d22\uff09\n\n------------\n\n\n\n```cpp\nvoid dfs2(int x,int root)\n{\n    rec[++rec[0]]=x;\n    top[x]=root;\n    if(son[x])\n        dfs2(son[x],root);\n    for(int i=head[x]; i; i=e[i].next)\n    {\n        if(e[i].to==fa[x]||e[i].to==son[x])\n            continue;\n        dfs2(e[i].to,e[i].to);\n    }\n}\n```\n\u5728\u7b2c\u4e00\u904d\u6784\u6210\u7684\u65e0\u5e8f\u6811\u7684\u57fa\u7840\u4e0a\u6309\u91cd\u94fe\uff08\u4e0d\u6e05\u695a\u7684\u8bdd\u4e5f\u53ef\u4ee5\u767e\u5ea6\uff09\uff0c\u5256\u6210\u6709\u5e8f\u6811\n\n------------\n\n\n\n```cpp\nint chain_query(int u,int v)\n{\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]>deep[top[v]])    swap(u,v);\n        query_val(1,1,n,pos[top[v]],pos[v]);\n        if(ans>0)    return 0;\n        v=fa[top[v]];\n    }\n    if(deep[u]>deep[v])      swap(u,v);\n    query_val(1,1,n,pos[u],pos[v]);\n    int k=ans;\n    if(k>1)\n        return 0;\n    ans=0;\n    query_val(1,1,n,pos[u],pos[u]);\n    if(k-ans==0)\n        return 1;\n    return 0;\n}\n```\n\u628a\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u52a0\u8d77\u6765\uff0c\u5982\u679c\u5927\u4e8e\u4e00\uff0c\u90a3\u4e48\u5c31\u4e0d\u8fde\u901a\n\n------------\n\n\n\n\u6ce8\u610f\u5230\u4e0a\u6587\u4e2d\u6709\u4e00\u4e2achain-query\u51fd\u6570\n\n\n```cpp\nint chain_query(int u,int v)\n{\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]>deep[top[v]])    swap(u,v);\n        query_val(1,1,n,pos[top[v]],pos[v]);\n        if(ans>0)    return 0;\n        v=fa[top[v]];\n    }\n    if(deep[u]>deep[v])      swap(u,v);\n    query_val(1,1,n,pos[u],pos[v]);\n    int k=ans;\n    if(k>1)\n        return 0;\n    ans=0;\n    query_val(1,1,n,pos[u],pos[u]);\n    if(k-ans==0)\n        return 1;\n    return 0;\n}\n```\nor\u6700\u540e\u90e8\u5206\u8fd9\u4e48\u5199\n if (dep[u]<dep[v]) swap(u,v);\n\n    ans=ans+query(1,n,1,id[v],id[u])\uff1b\n\n\u7136\u540e\u76f4\u63a5return ans\u5c31\u597d\u4e86\n\n\n------------\n\n\n\u6ce8\u610f\u5230\u89e3\u9898\u7684\u601d\u60f3\uff0c\u600e\u4e48\u6539\u53d8\u70b9\u503c\u5462\uff1f\u5176\u5b9e\u53ea\u9700\u8981\u5bf9\u7ebf\u6bb5\u6811\u8fdb\u884c\u64cd\u4f5c\u5c31\u597d\u4e86\uff0c\u6700\u540e\u4e0d\u8981\u5fd8\u4e86\u66f4\u65b0\u5168\u90e8\u7684\u6839\n\n\n```cpp\nvoid update(int cur,int l,int r,int tar,int val)\n{\n    if(l==r)\n    {\n        tree[cur]+=val;\n        return ;\n    }\n    int mid=(l+r)>>1;\n    if(tar<=mid)\n        update(cur*2,l,mid,tar,val);\n    else if(tar>mid)\n        update(cur*2+1,mid+1,r,tar,val);\n    tree[cur]=tree[cur*2]+tree[cur*2+1];\n}\n\u4ee3\u7801\u5c31\u4e0d\u9644\u5e26\u4e86\uff0c\u8fd8\u6709\u4e0d\u61c2\u7684\u770b\u770b\u6811\u94fe\u5c31\u597d\u4e86\n```",
        "postTime": 1513152054,
        "uid": 63019,
        "name": "\u661f\u661f\u4e4b\u706b",
        "ccfLevel": 0,
        "title": "\u90e8\u843d\u51b2\u7a81\u9898\u89e3"
    },
    {
        "content": "\u66b4\u529b\u6570\u636e\u7ed3\u6784\u7231\u597d\u8005\u3002\n\n\u5728\u6811\u5256\u4e4b\u540e\u5efa\u7acb\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u80fd\u652f\u6301\u5355\u70b9\u4fee\u6539\u548c\u533a\u95f4\u67e5\u8be2\u3002\n\n\u628a\u4e24\u70b9\u4e4b\u95f4\u7684\u8fb9\u8f6c\u5316\u6210\u6df1\u5ea6\u6df1\u7684\u70b9\u7684\u6743\u503c\uff0c\u8fdb\u884c\u4fee\u6539\u548c\u67e5\u8be2\uff0c\u5c31\u53ef\u4ee5AC\u672c\u9898\u4e86\u3002\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n\u4e24\u70b9\u6218\u4e89\uff1a\u6df1\u5ea6\u6df1\u7684\u70b9\u70b9\u6743+1\u3002\u4e24\u70b9\u548c\u5e73\uff1a\u6df1\u5ea6\u6df1\u7684\u70b9\u70b9\u6743-1\u3002\n\n\u4e0d\u80fd\u5230\u8fbe\uff1a\u4e24\u70b9\u4e4b\u95f4\u70b9\u6743\u6743\u503c\u548c\u5927\u4e8e0,\uff08\u7279\u5224lca\u70b9\u6743\u503c\u53ef\u4ee5\u4e3a1\uff09\n\n\u80fd\u5230\u8fbe\uff1a\u4e24\u70b9\u4e4b\u95f4\u70b9\u6743\u6743\u503c\u548c\u7b49\u4e8e0\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n\u4e0d\u8981\u95ee\u6211\u4e3a\u4ec0\u4e48\u4e0d\u5199\u6811\u72b6\u6570\u7ec4 \u5dee\u5206\u4ec0\u4e48\u7684\u3002\u3002\u3002\u3002\n\n\u56e0\u4e3a\u6253\u6811\u5256\u7ebf\u6bb5\u6811\u4e0d\u7528\u52a8\u8111\u5b50\u3002\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n\n\u4ee3\u7801\u91cf\u597d\u50cf\u8fd8\u4e0d\u5c0f\uff08\u53cd\u6b63\u4e0d\u52a8\u8111\u5b50\n\n\n\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\u2014\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int N=300300,M=300300;\nint n,m,ans;\nint size[N],head[N],fa[N],son[N];\nint deep[N],top[N],tree[N<<2];\nint rec[N],pos[N];\nstruct next_list\n{\n    int next,to;\n}e[M<<1];\nstruct pro\n{\n    int u,v;\n}q[M];\nint read()\n{\n    int rt=0,in=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9')\n        ch=getchar();\n    while(ch>='0'&&ch<='9')\n    {\n        rt=rt*10+ch-48;\n        ch=getchar();\n    }\n    return rt*in;\n}\nvoid add_edge(int u,int v)\n{\n    e[++head[0]].to=v;\n    e[head[0]].next=head[u];\n    head[u]=head[0];\n}\nint dfs1(int x)\n{\n    size[x]=1;\n    for(int i=head[x]; i; i=e[i].next)\n    {\n        if(e[i].to==fa[x])\n            continue;\n        deep[e[i].to]=deep[x]+1;\n        fa[e[i].to]=x;\n        size[x]+=dfs1(e[i].to);\n        if(!son[x] || size[e[i].to]>size[son[x]])\n            son[x]=e[i].to;\n    }\n    return size[x];\n}\nvoid dfs2(int x,int root)\n{\n    rec[++rec[0]]=x;\n    top[x]=root;\n    if(son[x])\n        dfs2(son[x],root);\n    for(int i=head[x]; i; i=e[i].next)\n    {\n        if(e[i].to==fa[x]||e[i].to==son[x])\n            continue;\n        dfs2(e[i].to,e[i].to);\n    }\n}\nvoid query_val(int cur,int l,int r,int L,int R)\n{\n    if(L<=l&&r<=R)\n    {\n        ans+=tree[cur];\n        return ;\n    }\n    int mid=(l+r)>>1;\n    if(R<=mid)\n        query_val(cur*2,l,mid,L,R);\n    else if(L>mid)\n        query_val(cur*2+1,mid+1,r,L,R);\n    else\n    {\n        query_val(cur*2,l,mid,L,mid);\n        query_val(cur*2+1,mid+1,r,mid+1,R);\n    }\n}\nint query_LCA(int u,int v)\n{\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]>deep[top[v]])    swap(u,v);\n        query_val(1,1,n,pos[top[v]],pos[v]);\n        if(ans>0)    return 0;\n        v=fa[top[v]];\n    }\n    if(deep[u]>deep[v])      swap(u,v);\n    query_val(1,1,n,pos[u],pos[v]);\n    int k=ans;\n    if(k>1)\n        return 0;\n    ans=0;\n    query_val(1,1,n,pos[u],pos[u]);\n    if(k-ans==0)\n        return 1;\n    return 0;\n}\nvoid modify(int cur,int l,int r,int tar,int val)\n{\n    if(l==r)\n    {\n        tree[cur]+=val;\n        return ;\n    }\n    int mid=(l+r)>>1;\n    if(tar<=mid)\n        modify(cur*2,l,mid,tar,val);\n    else if(tar>mid)\n        modify(cur*2+1,mid+1,r,tar,val);\n    tree[cur]=tree[cur*2]+tree[cur*2+1];\n}\nint main()\n{\n    n=read(),m=read();\n    for(int i=1; i<n; i++)\n    {\n        int u,v;\n        u=read(),v=read();\n        add_edge(u,v);\n        add_edge(v,u);\n    }\n    deep[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    for(int i=1; i<=n; i++)\n        pos[rec[i]]=i;\n    int _=0;\n    for(int i=1; i<=m; i++)\n    {\n        char ch;\n        int u,v;\n        cin>>ch;\n        ans=0;\n        if(ch=='Q')\n        {\n            u=read(),v=read();\n            if(query_LCA(u,v))\n                printf(\"Yes\\n\");\n            else   printf(\"No\\n\");\n        }\n        if(ch=='C')\n        {\n            u=read(),v=read();\n            if(deep[u]>deep[v])      swap(u,v);\n            q[++_].u=u,q[_].v=v;\n            modify(1,1,n,pos[v],1);\n        }\n        if(ch=='U')\n        {\n            u=read();\n            modify(1,1,n,pos[q[u].v],-1);\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1510039241,
        "uid": 19215,
        "name": "OIer991215",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u4e0e\u697c\u4e0b\u540c\u4e3a~~\u6570\u636e\u7ed3\u6784\u5b66\u50bb\u4e86~~\u6570\u636e\u7ed3\u6784\u7231\u597d\u8005\uff0c\u770b\u5230\u8fd9\u4e2a\u9898\u7684\u7b2c\u4e00\u53cd\u5e94\u662f\uff1alink cut tree\u554a\uff01\u7136\u540e\u76f4\u63a5\u66b4\u529bcut\u548clink\uff0c\u53d1\u751f\u6218\u4e89\u5c31cut\uff0c\u7ed3\u675f\u5c31link\uff0c\u7b2c\u4e00\u6b21\u63d0\u4ea4\u628a'^'\u6253\u6210'!'\u5c31\u7206\u96f6\u4e86\uff0c\u6539\u5b8c\u4e00\u6b21A\uff0c\u8fd0\u884c\u901f\u5ea6\u5149\u8363\u57ab\u5e95\uff0c\u4f46\u8c8c\u4f3c\u6bd4\u6807\u79f0\u77ed\uff0c\u9632\u6b62\u5361\u5e38\u628alink\u51fd\u6570cut\u51fd\u6570\u8fd8\u6709makeroot\u51fd\u6570\u5168\u90fd\u5199\u6210\u4e86define\uff0c\u6709\uff08fei\uff09\u70b9\uff08chang\uff09\u4e11\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#define makeroot(x) Access(x);splay(x);rev[x]^=1;\n#define Link(x,y) makeroot(x);fa[x]=y;\n#define cut(x,y) makeroot(x);Access(y);splay(y);if(ch[y][0]==x) fa[x]=ch[y][0]=0;\n#define maxx 300005\nusing namespace std;\nstruct ans{\n    int u,v;\n}e[300005];\nint n,m,ch[maxx][2],fa[maxx],st[maxx],top;\nbool rev[maxx];\nbool isroot(int x){ return ch[fa[x]][0]!=x&&ch[fa[x]][1]!=x; }\nvoid pushdown(int x)\n{\n    if(rev[x]){\n        swap(ch[x][0],ch[x][1]); rev[x]=0;\n        rev[ch[x][0]]^=1; rev[ch[x][1]]^=1;\n    }\n}\nvoid rotate(int x)\n{\n    int y=fa[x],z=fa[y],l=ch[y][1]==x,r=l^1;\n    if(!isroot(y)) ch[z][ch[z][1]==y]=x;\n    fa[x]=z; fa[y]=x; fa[ch[x][r]]=y;\n    ch[y][l]=ch[x][r]; ch[x][r]=y;\n}\nvoid splay(int x)\n{\n    st[++top]=x;\n    for(int i=x;!isroot(i);i=fa[i]) st[++top]=fa[i];\n    while(top) pushdown(st[top--]);\n    while(!isroot(x)){\n        int y=fa[x],z=fa[y];\n        if(!isroot(y)){\n            if(ch[y][0]==x^ch[z][0]==y) rotate(x);\n            else rotate(y);\n        }rotate(x);\n    }\n}\nvoid Access(int x)\n{\n    for(int y=0;x;y=x,x=fa[x])\n        splay(x),ch[x][1]=y;\n}\nint findrt(int x)\n{\n    while(fa[x]) x=fa[x];\n    return x;\n}\nint main()\n{\n    int x,y,t=0;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<n;++i){\n        scanf(\"%d%d\",&x,&y);\n        Link(x,y);\n    }\n    while(m--){\n        char opt=' ';\n        while(opt!='Q'&&opt!='C'&&opt!='U') opt=getchar();\n        if(opt=='Q'){\n            scanf(\"%d%d\",&x,&y);\n            if(findrt(x)==findrt(y)) puts(\"Yes\");\n            else puts(\"No\");\n        }else if(opt=='C'){\n            scanf(\"%d%d\",&x,&y);\n            e[++t]=(ans){x,y};\n            cut(x,y);\n        }else{\n            scanf(\"%d\",&x);\n            if(x>t) continue;\n            if(findrt(e[x].u)!=findrt(e[x].v)) {\n                Link(e[x].u,e[x].v);\n            }\n        }\n    }\n    return 0;\n}\n```\n\u770b\u4e86\u4e00\u4e0b\u9898\u89e3\uff0c\u771f\u662f\u2026\u2026\u679c\u7136\u6211\u662f\u4e2a\u53ea\u4f1a\u6253\u66b4\u529b\u7684\u849f\u84bb\n",
        "postTime": 1509937275,
        "uid": 31925,
        "name": "Holmes",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u677f\u5b50\u9898\n\n## Description\n\n\u4e09\u79cd\u64cd\u4f5c\n\n- `Q p q` \u8be2\u95ee $p$ \u4e0e $q$ \u662f\u5426\u8fde\u901a\uff1b\n\n- `C p q` \u4f7f\u76f8\u4e34\u7684 $p,q$ \u4e24\u70b9\u95f4\u7684\u8def\u65ad\u5f00\uff0c\u5e76\u8fdb\u884c\u7f16\u53f7\uff1b\n\n- `U x` \u4f7f\u7f16\u53f7\u4e3a $x$ \u7684\u8def\u53d8\u5f97\u53ef\u901a\u3002\n\n## Solution\n\n\u8fd9\u91cc\u63d0\u4f9b\u4e00\u79cd\u7b80\u5355\u7684\u60f3\u6cd5\u3002\n\n\u521d\u59cb\u6bcf\u6761\u8fb9\u7684\u8fb9\u6743\u662f\u4e00\uff0c\u6bcf\u5f53\u4e00\u6761\u8def\u53d8\u5f97\u4e0d\u53ef\u540c\u884c\u65f6\u5c06\u5176\u8d4b\u503c\u4e3a\u65e0\u7a77\u5927\u3002\u6240\u4ee5\u4e24\u4e2a\u70b9\u4e92\u76f8\u53ef\u8fbe\u7684\u5145\u8981\u6761\u4ef6\u5c31\u662f\u5176\u8def\u5f84\u4e0a\u7684\u6700\u5927\u503c\u4e0d\u4e3a\u65e0\u7a77\u5927\u3002\n\n\u81f3\u4e8e\u6bcf\u6b21\u6218\u4e89\uff0c\u7528\u7ed3\u6784\u4f53\u6216\u8005\u522b\u7684\u4e1c\u897f\u5b58\u4e0b\u4ea4\u6218\u7684\u53cc\u65b9\u548c\u7f16\u53f7\u5373\u53ef\u3002\n\n\u6240\u4ee5\u53ea\u9700\u8981\u7ef4\u62a4\u4e00\u4e2a\u6700\u5927\u503c\u5373\u53ef\uff0c\u540c\u65f6\u6ce8\u610f\u70b9\u6743\u4e0b\u653e\u3002\n\n## Code\n\n```cpp\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define rr register \n#define maxn 1200100 \n#define INF 0x3f3f3f3f\n//#define int long long\nusing namespace std;\n\nint n,m,cnt,now,tot,head[maxn];\nstruct War{int fir,sec;}w[maxn];\nstruct edge{int fr,to,nxt;}e[maxn];\n\ninline int read(){\n    rr int s=0,w=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n    return s*w;\n}\n\nvoid add(int fr,int to){e[++tot]=(edge){fr,to,head[fr]};head[fr]=tot;}\n\nnamespace Seg{\n    #define ls x<<1\n    #define rs x<<1|1\n    int Max[maxn];\n    void pushup(int x){Max[x]=max(Max[ls],Max[rs]);}\n    \n    void build(int x,int l,int r){\n        if(l==r){Max[x]=1;return;}\n        int mid=l+r>>1;build(ls,l,mid);build(rs,mid+1,r);\n        pushup(x);\n    }\n    \n    void update(int x,int l,int r,int pos,int val){\n        if(l==r){Max[x]=val;return;}\n        int mid=l+r>>1;\n        if(pos<=mid) update(ls,l,mid,pos,val);\n        else update(rs,mid+1,r,pos,val);\n        pushup(x);\n    }\n    \n    int getmax(int x,int l,int r,int L,int R){\n        if(L<=l&&R>=r) return Max[x];\n        int mid=l+r>>1,ans=-1;\n        if(L<=mid) ans=max(ans,getmax(ls,l,mid,L,R));\n        if(R>=mid+1) ans=max(ans,getmax(rs,mid+1,r,L,R));\n        return ans; \n    }\n}\n\nnamespace Cut{\n    int fa[maxn],son[maxn],top[maxn];\n    int dfn[maxn],dep[maxn],siz[maxn];\n    void dfs1(int u,int fat){\n        dep[u]=dep[fat]+1;\n        siz[u]=1;fa[u]=fat;\n        for(int i=head[u];i;i=e[i].nxt){\n            int to=e[i].to;\n            if(to==fat) continue;\n            dfs1(to,u);siz[u]+=siz[to];\n            if(siz[to]>siz[son[u]])son[u]=to;\n        }\n    }\n    \n    void dfs2(int u,int tp){\n        top[u]=tp;dfn[u]=++now;\n        if(son[u]) dfs2(son[u],tp);\n        for(int i=head[u];i;i=e[i].nxt){\n            int to=e[i].to;\n            if(to==son[u]||to==fa[u])continue;\n            dfs2(to,to);\n        }\n    }\n    \n    int query(int x,int y){\n        int ans=-1;\n        while(top[x]!=top[y]){\n            if(dep[top[x]]<dep[top[y]]) swap(x,y);\n            ans=max(ans,Seg::getmax(1,1,n,dfn[top[x]],dfn[x]));\n            x=fa[top[x]];\n        }\n        if(dep[x]>dep[y]) swap(x,y);\n        ans=max(ans,Seg::getmax(1,1,n,dfn[x]+1,dfn[y]));\n        return ans; \n    }\n}\n\nint main(){\n    n=read();m=read();\n    for(int i=1,fr,to;i<n;i++){\n        fr=read();to=read();\n        add(fr,to);add(to,fr);\n    }\n    Seg::build(1,1,n);\n    Cut::dfs1(1,0);Cut::dfs2(1,1);\n    for(int i=1,fr,to,x;i<=m;i++){\n        string opt;cin>>opt;\n        if(opt==\"Q\"){\n            fr=read();to=read();\n            Cut::query(fr,to)<INF?printf(\"Yes\\n\"):printf(\"No\\n\");\n        }\n        else if(opt==\"C\"){\n            w[++cnt].fir=fr=read(),w[cnt].sec=to=read();\n            Seg::update(1,1,n,max(Cut::dfn[to],Cut::dfn[fr]),INF);\n        }\n        else{\n            x=read();fr=w[x].fir;to=w[x].sec;\n            Seg::update(1,1,n,max(Cut::dfn[to],Cut::dfn[fr]),1);\n        }\n    } \n    return 0;\n}\n```\n",
        "postTime": 1622642633,
        "uid": 281497,
        "name": "KEBrantily",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3950 \u90e8\u843d\u51b2\u7a81"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u677f\u5b50\u9898\u3002\n\n\u8fd9\u91cc\u5148\u628a\u8fb9\u6743\u8f6c\u70b9\u6743\uff0c\u628a\u6bcf\u6761\u8fb9\u7684\u6743\u503c\u4e0b\u653e\u5230\u70b9\u4e0a\u5373\u53ef\uff0c\u4e00\u822c\u90fd\u53ef\u4ee5\u8fd9\u6837\u5904\u7406\u3002\n\n\u8f6c\u5316\u9898\u610f\uff0c\u53d1\u8d77\u6218\u4e89\u65f6\uff0c\u6211\u4eec\u76f4\u63a5\u5355\u70b9\u4fee\u6539\u6743\u503c\u52a0\u4e00\uff0c\u505c\u6b62\u6218\u4e89\u540c\u7406\u6743\u503c\u51cf\u4e00\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee\uff0c\u533a\u95f4\u67e5\u8be2\u6c42\u548c\uff0c\u5982\u679c\u7b54\u6848\u4e3a\u96f6\u5219\u4e3a\u6ca1\u6709\u6218\u4e89\uff0c\u8f93\u51faYes\uff0c\u5426\u5219\u8f93\u51faNo\u3002\n\n\u8be2\u95ee\u65f6\u9700\u8981\u6ce8\u610f\uff0c\u56e0\u4e3a\u4e0b\u653e\u8fb9\u6743\uff0c\u8def\u5f84x\u5230y\uff0c\u6c42\u5b8c\u548c\u4e4b\u540e\u8981\u51cf\u53bblca\u7684\u6743\u503c\u3002\n\n\u7531\u4e8e\u6211\u7528\u7684\u6811\u5256\uff0c\u53ef\u4ee5\u8fd9\u6837\u5904\u7406\uff1a\u5f53\u4e0bx\uff0cy\u5728\u4e0d\u540c\u94fe\u65f6\uff0c\u76f4\u63a5\u6c42\u548c\uff0c\u5728\u540c\u4e00\u94fe\u65f6\u6df1\u5ea6\u8f83\u5c0f\u7684\u5373\u4e3alca\uff0c\u628a\u6c42\u548c\u7684\u4f4d\u7f6e\u52a0\u4e00\u5373\u53ef\uff0c\u5177\u4f53\u89c1\u4ee3\u7801\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=3e5+5;\nint head[N],ver[N*2],net[N*2],tot;\nint siz[N],far[N],deep[N],son[N];\nint tp[N],id[N],cnt;\nint n,m,l[N],r[N],q;\nstruct nod{\n\tint l,r,sum;\n}tree[N*4];\nvoid add(int a,int b){\n\tnet[++tot]=head[a];\n\thead[a]=tot;\n\tver[tot]=b;\n}\nvoid dfs(int x,int fa){\n\tdeep[x]=deep[fa]+1;\n\tsiz[x]=1;\n\tfar[x]=fa;\n\tfor(int i=head[x];i;i=net[i]){\n\t\tint v=ver[i];\n\t\tif(v==fa)continue;\n\t\tdfs(v,x);\n\t\tsiz[x]+=siz[v];\n\t\tif(siz[son[x]]<siz[v])son[x]=v;\n\t}\n}\nvoid dfs2(int x,int fa,int num){\n\ttp[x]=num;\n\tid[x]=++cnt;\n\tif(!son[x])return ;\n\tdfs2(son[x],x,num);\n\tfor(int i=head[x];i;i=net[i]){\n\t\tint v=ver[i];\n\t\tif(v==fa||v==son[x])continue;\n\t\tdfs2(v,x,v);\n\t}\n}\nvoid build(int l,int r,int p){\n\ttree[p].l=l;\n\ttree[p].r=r;\n\tif(l==r)return ;\n\tint mid=(l+r)/2;\n\tbuild(l,mid,p*2);\n\tbuild(mid+1,r,p*2+1);\n}\nvoid chang(int x,int p,int k){\n\tif(tree[p].l==tree[p].r){\n\t\ttree[p].sum+=(tree[p].r-tree[p].l+1)*k;\n\t\treturn ;\n\t}\n\tint mid=(tree[p].l+tree[p].r)/2;\n\tif(x<=mid)chang(x,p*2,k);\n\telse chang(x,p*2+1,k);\n\ttree[p].sum=tree[p*2].sum+tree[p*2+1].sum;\n}\nint find(int l,int r,int p){\n\tif(tree[p].l>=l&&tree[p].r<=r){\n\t\treturn tree[p].sum;\n\t}\n\tint mid=(tree[p].l+tree[p].r)/2;\n\tint ans=0;\n\tif(l<=mid)ans+=find(l,r,p*2);\n\tif(r>mid)ans+=find(l,r,p*2+1);\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);\n\t\tadd(b,a);\n\t}\n\tdfs(1,0);\n\tdfs2(1,0,1);\n\tbuild(1,n,1);\n\twhile(m--){\n\t\tint x,y,z;\n\t\tchar op;\n\t\tcin>>op;\n\t\tif(op=='Q'){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tint ans=0;\n\t\t\twhile(tp[x]!=tp[y]){\n\t\t\t\tif(deep[tp[x]]<deep[tp[y]])swap(x,y);\n\t\t\t\tans+=find(id[tp[x]],id[x],1);\n\t\t\t\tx=far[tp[x]];\n\t\t\t}\n\t\t\tif(deep[x]<deep[y])swap(x,y);\n\t\t\tans+=find(id[y]+1,id[x],1);\n\t\t\tif(!ans)printf(\"Yes\\n\");\n\t\t\telse printf(\"No\\n\");\n\t\t}\n\t\telse if(op=='C'){\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tl[++q]=x,r[q]=y;\n\t\t\tif(far[y]==x)swap(x,y);\n\t\t\tchang(id[x],1,1);\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d\",&z);\n\t\t\tx=l[z],y=r[z];\n\t\t\tif(far[y]==x)swap(x,y);\n\t\t\tchang(id[x],1,-1);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1620283592,
        "uid": 277664,
        "name": "\u968f\u4fbfAK",
        "ccfLevel": 6,
        "title": "P3950 \u90e8\u843d\u51b2\u7a81 \u9898\u89e3"
    },
    {
        "content": "# Algorithm\n\n\u6811\u72b6\u6570\u7ec4\n\n# Mentality\n\n\u5176\u5b9e\u672c\u6765\u662f\u60f3\u7ec3\u624b\u4e00\u4e0b $LCT$ \u7684\uff0c\u4f46\u662f\u8fd9\u9898\u7528 $LCT$ \u5b9e\u5728\u663e\u5f97\u725b\u5200\u6740\u9e21 \u2026\u2026\n\n\u5927\u81f4\u770b\u4e86\u4e00\u4e0b\u9898\u89e3\uff0c\u90fd\u7528\u4e86\u6811\u5256\u548c $LCT$ \u8fd9\u6837\u7684\uff0c\u4f46\u5176\u5b9e\u6709\u4e00\u79cd\u5f88\u7b80\u5355\u7684\u65b9\u6cd5\uff0c\u53ea\u9700\u8981\u6811\u72b6\u6570\u7ec4 + \u968f\u673a\u6570\u3002\n\n\u6839\u636e\u9898\u76ee\uff0c\u5bf9\u4e8e\u4e00\u6761\u8def\u5f84 $u, v$ \uff0c\u8fd9\u6761\u8def\u5f84\u8054\u901a\u5f53\u4e14\u4ec5\u5f53 $u, v$ \u4e0a\u7684\u8fb9\u90fd\u6ca1\u6709\u88ab\u65ad\u5f00\u3002\n\n\u90a3\u4e48\u5982\u4f55\u624d\u80fd\u6ee1\u8db3\u8fd9\u4e2a\u6761\u4ef6\u5462\uff1f\u6362\u6210\u5bf9\u65ad\u8fb9\u7684\u8981\u6c42\uff0c\u5c31\u662f\u5bf9\u4e8e\u5f53\u524d\u6240\u6709\u65ad\u5f00\u4e86\u7684\u8fb9\uff0c$u, v$ \u8981\u4e48\u90fd\u5728\u5b83\u7684\u5b50\u6811\u5185\uff0c\u8981\u4e48\u90fd\u4e0d\u5728\u3002\n\n\u5219\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u7528 $dfn$ \u5e8f + \u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\uff0c\u53ea\u8981\u5728\u6bcf\u6b21\u65ad\u8fb9\u7684\u65f6\u5019\uff0c\u7ed9\u5b50\u6811\u5185\u6bcf\u4e2a\u70b9\u90fd\u8d4b\u4e0a\u4e00\u4e2a\u7279\u6709\u4fe1\u606f\uff0c\u7136\u540e\u8be2\u95ee\u7684\u65f6\u5019\u5bf9 $u, v$ \u67e5\u8be2\u4e0a\u9762\u7684\u4fe1\u606f\u662f\u5426\u76f8\u7b49\u5373\u53ef\u3002\n\n\u5982\u4f55\u8d4b\u4e0a\u8fd9\u4e2a\u7279\u6b8a\u4fe1\u606f\u5462\uff1f\u5f88\u7b80\u5355\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u65ad\u8fb9\u90fd $rand$ \u4e00\u4e2a\u7279\u5b9a\u6743\u503c\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u7ed9\u5b50\u6811\u5185\u7684\u6240\u6709\u8282\u70b9\u90fd\u52a0\u4e0a\u8fd9\u4e2a\u6743\u503c\u5373\u53ef\u3002\n\n\u67e5\u8be2\u7684\u65f6\u5019\u53ea\u9700\u8981\u67e5\u4e00\u4e0b\u4e24\u70b9\u6743\u503c\u662f\u5426\u76f8\u540c\u5c31\u884c\u3002\n\n\u8fd8\u539f\u7684\u65f6\u5019\u518d\u5220\u6389\u5c31\u597d\u4e86\u3002\n\n# Code\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#define LL long long\n#define go(G, x, i, v) \\\n  for (int i = G.hd[x], v = G.to[i]; i; v = G.to[i = G.nx[i]])\n#define inline __inline__ __attribute__((always_inline))\ninline LL read() {\n  LL x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) {\n    if (ch == '-') w = -1;\n    ch = getchar();\n  }\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\n\nconst int Max_n = 3e5 + 5, mod = 998244353;\nint n, m;\nint cntd, dep[Max_n], dfn[Max_n], siz[Max_n];\nint c[Max_n];\nstruct graph {\n  int hd[Max_n];\n  int cntr, nx[Max_n << 1], to[Max_n << 1];\n  void addr(int u, int v) {\n    cntr++;\n    nx[cntr] = hd[u], to[cntr] = v;\n    hd[u] = cntr;\n  }\n} G;\nstruct que {\n  int u, v, x;\n} k[Max_n];\n\nnamespace Input {\nvoid main() {\n  n = read(), m = read();\n  int u, v;\n  for (int i = 1; i < n; i++) {\n    u = read(), v = read();\n    G.addr(u, v), G.addr(v, u);\n  }\n}\n}  // namespace Input\n\nnamespace Init {\nvoid build(int x, int fa) {\n  dep[x] = dep[fa] + 1, siz[x] = 1, dfn[x] = ++cntd;\n  go(G, x, i, v) if (v != fa) build(v, x), siz[x] += siz[v];\n}\nvoid main() { build(1, 0); }\n}  // namespace Init\n\nnamespace Solve {\nvoid add(int k, int x) {\n  for (int i = k; i <= n; i += i & -i) (c[i] += x) %= mod;\n}\nint query(int k) {\n  int ans = 0;\n  for (int i = k; i; i -= i & -i) (ans += c[i]) %= mod;\n  return (ans + mod) % mod;\n}\nvoid main() {\n  srand((unsigned)time(NULL));\n  int cnt = 0, u, v;\n  char op;\n  for (int i = 1; i <= m; i++) {\n    scanf(\" %c\", &op);\n    u = read();\n    if (op == 'U')\n      add(dfn[k[u].v], -k[u].x), add(dfn[k[u].v] + siz[k[u].v], k[u].x);\n    else {\n      v = read();\n      if (op == 'Q')\n        printf(\"%s\\n\", query(dfn[u]) == query(dfn[v]) ? \"Yes\" : \"No\");\n      else {\n        k[++cnt].x = rand() % mod;\n        if (dep[u] > dep[v]) swap(u, v);\n        add(dfn[v], k[cnt].x), add(dfn[v] + siz[v], -k[cnt].x);\n        k[cnt].u = u, k[cnt].v = v;\n      }\n    }\n  }\n}\n}  // namespace Solve\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"3950.in\", \"r\", stdin);\n  freopen(\"3950.out\", \"w\", stdout);\n#endif\n  Input::main();\n  Init::main();\n  Solve::main();\n}\n```\n",
        "postTime": 1578059382,
        "uid": 39954,
        "name": "\u6d1b\u6c34\u00b7\u9526\u4f9d\u536b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "link-cut tree \u677f\u5b50\u9898\n\n\u8fd9\u9053\u9898\u53ef\u4ee5\u7528\u6765\u4f5c\u4e3alink-cut tree\u7684\u7ec3\u624b\u9898\n \nC\u64cd\u4f5c:\u628a\u53d1\u751f\u6218\u4e89\u7684\u4fe9\u90e8\u843d\u7684\u8fde\u8fb9cut\u6389\n\nU\u64cd\u4f5c:\u628a\u505c\u6218\u7684\u4fe9\u90e8\u843dlink\u8d77\u6765\n\nQ\u64cd\u4f5c:\u5982\u679cp\u90e8\u843d\u548cq\u90e8\u843d\u5728\u4e00\u68f5\u6811\u91cc(\u6811\u6839\u76f8\u540c)\uff0c\u5c31\u8f93\u51fa\"Yes\",\u5426\u5219\u8f93\u51fa\"No\"\n\n($lct$\u6a21\u677f\u7528\u7684\u662fP3690 \u3010\u6a21\u677f\u3011Link Cut Tree \uff08\u52a8\u6001\u6811\uff09\u7684\u6a21\u677f\u4ee3\u7801)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MaxN = 300010;\nint n, m, val[MaxN], p[MaxN], q[MaxN], war;\nstruct Link_Cut_Tree\n{\n    int top, ch[MaxN][2], fa[MaxN], sum[MaxN], q[MaxN], rev[MaxN];\n    inline void pushup(int x) { sum[x] = sum[ch[x][0]] ^ sum[ch[x][1]] ^ val[x]; }\n    inline void pushdown(int x)\n    {\n        int l = ch[x][0], r = ch[x][1];\n        if (rev[x])\n        {\n            rev[l] ^= 1;\n            rev[r] ^= 1;\n            rev[x] ^= 1;\n            swap(ch[x][0], ch[x][1]);\n        }\n    }\n    inline bool isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\n    void rotate(int x)\n    {\n        int y = fa[x], z = fa[y], l, r;\n        if (ch[y][0] == x)\n            l = 0;\n        else\n            l = 1;\n        r = l ^ 1;\n        if (!isroot(y))\n        {\n            if (ch[z][0] == y)\n                ch[z][0] = x;\n            else\n                ch[z][1] = x;\n        }\n        fa[x] = z;\n        fa[y] = x;\n        fa[ch[x][r]] = y;\n        ch[y][l] = ch[x][r], ch[x][r] = y;\n        pushup(y), pushup(x);\n    }\n    void splay(int x)\n    {\n        top = 1;\n        q[top] = x;\n        for (int i = x; !isroot(i); i = fa[i])\n            q[++top] = fa[i];\n        for (int i = top; i; i--)\n            pushdown(q[i]);\n        while (!isroot(x))\n        {\n            int y = fa[x], z = fa[y];\n            if (!isroot(y))\n            {\n                if ((ch[y][0] == x) ^ (ch[z][0] == y))\n                    rotate(x);\n                else\n                    rotate(y);\n            }\n            rotate(x);\n        }\n    }\n    void access(int x)\n    {\n        for (int t = 0; x; t = x, x = fa[x])\n            splay(x), ch[x][1] = t, pushup(x);\n    }\n    void makeroot(int x)\n    {\n        access(x);\n        splay(x);\n        rev[x] ^= 1;\n    }\n    int find(int x)\n    {\n        access(x);\n        splay(x);\n        while (ch[x][0])\n            x = ch[x][0];\n        return x;\n    }\n    void split(int x, int y)\n    {\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n    void cut(int x, int y)\n    {\n        makeroot(x);\n        if (find(y) != x || fa[x] != y || ch[x][1])\n            return;\n        fa[x] = ch[y][0] = 0;\n        pushup(y);\n    }\n    void link(int x, int y)\n    {\n        makeroot(x);\n        fa[x] = y;\n    }\n} t;\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i < n; i++)\n    {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        t.link(u, v);\n    }\n    for(int i = 1; i <= m; i++)\n    {\n        std::string op;\n        std::cin >> op;\n        if(op == \"Q\")\n        {\n            int x, y;\n            scanf(\"%d%d\", &x, &y);\n            int fx = t.find(x), fy = t.find(y);\n            if(fx == fy)\n                printf(\"Yes\\n\");\n            else printf(\"No\\n\");\n        }\n        else if(op == \"C\")\n        {\n            ++war;\n            scanf(\"%d%d\", &p[war], &q[war]);\n            t.cut(p[war], q[war]);\n        }\n        else\n        {\n            int x;\n            scanf(\"%d\", &x);\n            t.link(p[x], q[x]);\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1549677272,
        "uid": 61966,
        "name": "little_sun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "### [\u66f4\u597d\u7684\u9605\u8bfb](https://www.cnblogs.com/yzhang-rp-inf/p/10203241.html)\n\n### [\u539f\u9898\u4f20\u9001\u95e8](https://www.luogu.org/problemnew/show/P3950)\n\n### \u8fd9\u9898\u7528Link-Cut-Tree\u89e3\u51b3\uff0c[Link-Cut-Tree\u8be6\u89e3](https://www.cnblogs.com/yzhang-rp-inf/p/10201857.html)\n\n\u6211\u4eec\u7528Link-Cut-Tree\u7ef4\u62a4\u8fde\u901a\u6027~~\uff08\u5341\u5206\u65e0\u8111\uff09~~\n\n\u4e00\u5f00\u59cb\u5148\u628a\u6811\u4e2d\u6bcf\u6761\u8fb9\u7684\u4e24\u7aef\u8fde\u63a5\n\nU\u64cd\u4f5c\uff1a\u628au,v\u4e24\u4e2a\u70b9\u8fde\u8d77\u6765\n\nC\u64cd\u4f5c\uff1a\u628au,v\u4e24\u4e2a\u70b9\u5206\u5f00\u6765\n\nQ\u64cd\u4f5c\uff1a\u5224\u65ad\u5728\u8fd9\u4e2a\u68ee\u6797\u91ccu\u7684\u6839\u548cv\u7684\u6839\u662f\u5426\u76f8\u7b49\uff08\u662f\u5426\u8fde\u901a\uff09\n\n```cpp\n#include <bits/stdc++.h>\n#define N 300005\n#define getchar nc\nusing namespace std;\ninline char nc(){\n    static char buf[100000],*p1=buf,*p2=buf; \n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++; \n}\ninline int read()\n{\n    register int x=0,f=1;register char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n    return x*f;\n}\ninline void Swap(register int &a,register int &b)\n{\n    a^=b^=a^=b;\n}\nstruct Link_Cut_Tree{\n\tint c[N][2],fa[N],top,q[N],rev[N];\n\tinline bool isroot(register int x)\n\t{\n\t\treturn c[fa[x]][0]!=x&&c[fa[x]][1]!=x;\n\t}\n\tinline void pushdown(register int x)\n\t{\n\t\tif(rev[x])\n\t\t{\n\t\t\tint l=c[x][0],r=c[x][1];\n\t\t\trev[l]^=1,rev[r]^=1,rev[x]^=1;\n\t\t\tSwap(c[x][0],c[x][1]);\n\t\t}\n\t}\n\tinline void rotate(register int x)\n\t{\n\t\tint y=fa[x],z=fa[y],l,r;\n\t\tl=c[y][0]==x?0:1;\n\t\tr=l^1;\n\t\tif(!isroot(y))\n\t\t\tc[z][c[z][0]==y?0:1]=x;\n\t\tfa[x]=z;\n\t\tfa[y]=x;\n\t\tfa[c[x][r]]=y;\n\t\tc[y][l]=c[x][r];\n\t\tc[x][r]=y;\n\t}\n\tinline void splay(register int x)\n\t{\n\t\ttop=1;\n\t\tq[top]=x;\n\t\tfor(register int i=x;!isroot(i);i=fa[i])\n\t\t\tq[++top]=fa[i];\n\t\tfor(register int i=top;i;--i)\n\t\t\tpushdown(q[i]);\n\t\twhile(!isroot(x))\n\t\t{\n\t\t\tint y=fa[x],z=fa[y];\n\t\t\tif(!isroot(y))\n\t\t\t\trotate((c[y][0]==x)^(c[z][0]==y)?(x):(y));\n\t\t\trotate(x);\n\t\t}\n\t}\n\tinline void access(register int x)\n\t{\n\t\tfor(register int t=0;x;t=x,x=fa[x])\n\t\t{\n\t\t\tsplay(x);\n\t\t\tc[x][1]=t;\n\t\t}\n\t}\n\tinline void makeroot(register int x)\n\t{\n\t\taccess(x);\n\t\tsplay(x);\n\t\trev[x]^=1;\n\t}\n\tinline int findroot(register int x)\n\t{\n\t\taccess(x);\n\t\tsplay(x);\n\t\twhile(c[x][0])\n\t\t\tx=c[x][0];\n\t\treturn x;\n\t}\n\tinline void split(register int x,register int y)\n\t{\n\t\tmakeroot(x);\n\t\taccess(y);\n\t\tsplay(y);\n\t}\n\tinline void cut(register int x,register int y)\n\t{\n\t\tsplit(x,y);\n\t\tc[y][0]=0;\n\t\tfa[x]=0;\n\t}\n\tinline void link(register int x,register int y)\n\t{\n\t\tmakeroot(x);\n\t\tfa[x]=y;\t\n\t}\t\n}T;\nint n,m,cnt;\nint a[N],b[N];\nint main()\n{\n\tn=read(),m=read();\n\tfor(register int i=1;i<n;++i)\n\t{\n\t\tint u=read(),v=read();\n\t\tT.link(u,v);\n\t}\n\twhile(m--)\n\t{\n\t\tchar ch=getchar();\n\t\twhile(ch!='Q'&&ch!='C'&&ch!='U')\n\t\t\tch=getchar();\n\t\tif(ch=='Q')\n\t\t{\n\t\t\tint x=read(),y=read();\n\t\t\tputs(T.findroot(x)==T.findroot(y)?\"Yes\":\"No\");\n\t\t} \n\t\telse if(ch=='C')\n\t\t{\n\t\t\ta[++cnt]=read(),b[cnt]=read();\n\t\t\tT.cut(a[cnt],b[cnt]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint x=read();\n\t\t\tT.link(a[x],b[x]);\n\t\t}\n\t}\n}\n```\n\n\n",
        "postTime": 1546259799,
        "uid": 37881,
        "name": "yzhang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u6b64\u9898\u7528\u6811\u94fe\u5256\u5206\u662f\u5927\u6750\u5c0f\u7528\u4e86,\u56e0\u4e3a\u5b83\u53ef\u4ee5\u5904\u7406 $p,q$ \u4e0d\u76f8\u90bb\u7684\u60c5\u51b5\u3002\n\n\u7b80\u5316\u4e00\u4e0b\u9898\u610f:\n\n- $Q\\ p\\ q$ \u4ee3\u8868\u67e5\u8be2\u6811\u4e0a\u6700\u77ed\u8def\u5f84 $p\\ q$ (\u4e5f\u5c31\u662f $p->lca(p,q)->q$)\u4e4b\u95f4\u6709\u6ca1\u6709\u8fb9\u7684\u4e3a\u9ed1\u8272\u3002\u6709\u9ed1\u8272\u5c31\u8f93\u51fa $No$,\u5168\u90e8\u90fd\u662f\u767d\u8272\u8f93\u51fa $Yes$\u3002\n\n- $C\\ p\\ q$ \u4ee3\u8868\u8ba9 $p,q$ \u7684\u8fde\u8fb9\u53d8\u4e3a\u9ed1\u8272\u3002($p,q$ \u76f8\u90bb)\n\n- $U\\ p$ \u4ee3\u8868\u8ba9\u7b2c $p$ \u6b21\u4fee\u6539\u7684\u8fde\u8fb9\u53d8\u4e3a\u767d\u8272\u3002\n\n\u8fd9\u90fd\u662f\u4e00\u4e9b\u6811\u4e0a\u7684\u64cd\u4f5c,\u4e4d\u4e00\u770b\u53ef\u4ee5\u7528\u6811\u5256\u76f4\u63a5\u641e\u3002\u4f46\u662f\u56e0\u4e3a\u8fd9\u91cc\u662f **\u8fb9** \u8fdb\u884c\u64cd\u4f5c,\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5 **\u4ee5\u70b9\u4ee3\u8fb9** ,\u628a\u8fb9\u770b\u505a\u70b9\u3002\u6bcf\u4e00\u6b21\u67e5\u8be2\u7684\u65f6\u5019 $lca(p,q)$ \u662f\u4e0d\u80fd\u7b97\u7684\u3002\n\n\u4fee\u6539\u7684\u8bdd\u5c31\u7b80\u5355\u4e86,\u56e0\u4e3a\u662f\u76f8\u90bb\u7684,\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u628a $dep$ \u6bd4\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\u8bb0\u5f55 (\u7528\u6765\u7ed3\u675f\u6218\u4e89) \u5e76\u5728\u7ebf\u6bb5\u6811\u4e0a\u5355\u70b9 $+1$\u3002\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u7ed3\u675f\u6218\u4e89\u6211\u4eec\u5c31\u628a\u8bb0\u5f55\u7684\u90a3\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u4e0a $-1$\u3002\n\n\u5982\u679c $p,q$ \u4e0d\u76f8\u90bb,\u6211\u4eec\u53ef\u4ee5\u52a0\u5165\u6811\u5256\u7684\u4fee\u6539\u64cd\u4f5c,\u4f46\u662f\u7ebf\u6bb5\u6811\u7684\u4fee\u6539\u64cd\u4f5c\u5c31\u5fc5\u987b\u662f **\u533a\u95f4\u8d4b\u503c**,\u9700\u8981\u6253\u4e00\u4e2a\u7cbe\u5999\u7684\u6807\u8bb0\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6: $O(n\\log^2 n)$,\u5e38\u6570\u5de8\u5927\u3002\n\n```pascal\n// luogu-judger-enable-o2\n\nUses math;\n\nvar\n    recf,cnt,size,dfn,dep,top,father,son:array[-1..3100000] of longint;\n    next,reach:array[-1..8500000] of longint;\n    left,right:array[-1..8500000] of longint;\n    ques:array[-1..3100000] of longint;\n    tree:array[-1..15000000] of int64; // \u7ebf\u6bb5\u6811\u7684\u7a7a\u95f4\u8981\u5f00\u5927\n    i,n,m,l,r,dfnum,tot,root,tail:longint;\n    order:char;\n\nprocedure swap(var a,b:longint);var t:longint; begin t:=a; a:=b; b:=t; end;\n\nprocedure add(l,r:longint);\nbegin\n    inc(tot);\n    reach[tot]:=r;\n    next[tot]:=cnt[l];\n    cnt[l]:=tot;\nend;\n\nprocedure Dfs_1(x:longint);\nvar i:longint;\nbegin\n    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;\n    while i<>-1 do\n    begin\n        if dep[reach[i]]=0 then\n        begin\n            dep[reach[i]]:=dep[x]+1;\n            father[reach[i]]:=x;\n            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);\n            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];\n        end;\n        i:=next[i];\n    end;\nend;\n\nprocedure Dfs_2(x,centre:longint);\nvar i:longint;\nbegin\n    inc(dfnum); dfn[x]:=dfnum; recf[dfnum]:=x; top[x]:=centre;\n    if son[x]=0 then exit; Dfs_2(son[x],centre);\n    i:=cnt[x];\n    while i<>-1 do\n    begin\n        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);\n        i:=next[i];\n    end;\nend;\n\nprocedure Build(k,l,r:longint);\nvar mid:longint;\nbegin\n    left[k]:=l; right[k]:=r;\n    if (l=r) then exit;\n    mid:=(l+r) >> 1;\n    Build(k << 1,l,mid); Build(k << 1+1,mid+1,r);\nend;\n\nprocedure Change(k,x,modify:longint);\nvar mid:longint;\nbegin\n    if left[k]=right[k] then begin inc(tree[k],modify); exit; end;\n    mid:=(left[k]+right[k]) >> 1;\n    if x<=mid then Change(k << 1,x,modify) else Change(k << 1+1,x,modify);\n    tree[k]:=tree[k << 1]+tree[k << 1+1];\nend;\n\nfunction Query(k,x,y:longint):int64;\nvar mid:longint;\nbegin\n    Query:=0;\n    if x>y then exit(0);\n    if (x<=left[k])and(right[k]<=y) then exit(tree[k]);\n    mid:=(left[k]+right[k]) >> 1;\n    if mid>=y then inc(Query,Query(k << 1,x,y)) else\n    if mid<x then inc(Query,Query(k << 1+1,x,y)) else\n    inc(Query,Query(k << 1,x,mid)+Query(k << 1+1,mid+1,y));\nend;\n\nfunction Refer(x,y:longint):string; // \u67e5\u8be2\nvar tmp:longint;\nbegin\n    while top[x]<>top[y] do\n    begin\n        if dep[top[x]]<dep[top[y]] then swap(x,y);\n        tmp:=Query(1,dfn[top[x]],dfn[x]); if tmp>=1 then exit('No'); // \u5982\u679c\u8fd9\u4e00\u6bb5\u6709\u4e00\u4e2a\u9ed1\u8272,\u90a3\u4e48 No\n        x:=father[top[x]];\n    end;\n    if dep[x]>dep[y] then swap(x,y);\n    tmp:=Query(1,dfn[x]+1,dfn[y]); if tmp>=1 then exit('No'); // dfn[x]+1 \u662f\u56e0\u4e3a lca(x,y) \u4e0d\u80fd\u52a0\n    exit('Yes'); \nend;\n\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);\n    readln(n,m); root:=1; recf[-1]:=-1;\n    for i:=1 to n-1 do begin readln(l,r); add(l,r); add(r,l); end;\n    dep[root]:=1; father[root]:=1;\n    Dfs_1(root); Dfs_2(root,root); Build(1,1,n);\n    for i:=1 to m do\n    begin\n        read(order);\n        if order='C' then begin readln(l,r); if dep[l]<dep[r] then l:=r; Change(1,dfn[l],1); inc(tail); ques[tail]:=l; end;\n        if order='Q' then begin readln(l,r); writeln(Refer(l,r));end;\n        if order='U' then begin readln(l); Change(1,dfn[ques[l]],-1);  end;\n    end;\nend.\n```",
        "postTime": 1540020829,
        "uid": 77760,
        "name": "arfa",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "# \u8fd9\u662f\u4e00\u7bc7\u5047\u7684\u6811\u5256\u9898\u89e3\n\n###### ~~\u4e3a\u4ec0\u4e48\u662f\u5047\u7684?\u56e0\u4e3a\u6211\u662f\u7528\u5355\u70b9\u6765\u641e\u7684~~\n\n### \u9898\u76ee\u5206\u6790\n\n\u9996\u5148\u8fd9\u662f\u4e2a\u6811,\u7ef4\u62a4\u4e00\u4e2a\u8def\u5f84\u7684\u4fe1\u606f.\n\n~~\u5176\u6b21,\u8fd9\u662f\u4e00\u4e2a\u5b66_\u6811\u636e\u7ed3\u6784_\u5b66\u50bb\u4e86\u7684\u4eba~~\n\n\u6211\u4eec\u628a\u8fb9\u80fd\u5426\u901a\u884c\u89c6\u4e3a\u5b83\u8fde\u63a5\u7684\u76f8\u5bf9\u8f83\u6df1\u7684\u8282\u70b9\u80fd\u5426\u901a\u884c.\n\n\u6bcf\u6b21\u627e\u8def\u5f84\u6211\u4eec\u5c31\u627e\u8fd9\u4e9b\u70b9\u6743\u5c31\u884c\u4e86.\n\n### \u5177\u4f53\u5b9e\u73b0\n\n\u521d\u59cb\u6bcf\u4e2a\u70b9\u6743\u90fd\u662f0.\n\n\u6bcf\u8fdb\u884c\u4e00\u6b21\u6218\u4e89\u5c31\u5728\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\u4e0a-1.\n\n\u6218\u4e89\u7ed3\u675f\u5c31\u5728\u5bf9\u5e94\u7684\u70b9\u4e0a+1.\n\n\u90a3\u4e48\u6574\u4e2a\u8def\u901a\u4e0d\u901a\u5c31\u662f\u8def\u5f84\u4e0a\u6743\u503c\u548c\u662f\u5426\u662f0.\n\n### \u8fd8\u6709\u4e2a\u95ee\u9898\n\n**\u4efb\u4f55\u4e24\u4e2a\u8def\u5f84\u4e0a\u7684\u70b9,\u5728LCA\u5904\u7684\u70b9\u6743\u662f\u65e0\u610f\u4e49\u7684**\n\n\u4e3a\u4ec0\u4e48?LCA\u8bb0\u5f55\u7684\u662fLCA\u4e0e\u4e0a\u9762\u7684\u70b9\u7684\u76f8\u5bf9\u5173\u7cfb,\u4f46\u662f,\u6211\u4eec**\u6839\u672c\u4e0d\u8d70\u8fd9\u6761\u8fb9!**\n\n\u4e8e\u662f\u5c31\u5f97\u641e\u4e00\u4e0b\u4e86.\n\n#### \u8fd9\u91cc\u63d0\u4f9b\u4e24\u79cd\u65b9\u6cd5\n\n1.\u6bcf\u6b21\u67e5\u8be2\u5728LCA\u5904+1.\n\n\u5177\u4f53\u5b9e\u73b0\u76f4\u63a5\u5c31\u6811\u5256LCA\u4e00\u5757\u5c31\u597d\u4e86.\n\n2.\u67e5\u5230LCA\u4e86\u5c31\u8f6c\u6210\u91cd\u513f\u5b50.\n\n\u56e0\u4e3a\u4e00\u5b9a\u662f\u4e00\u4e2a\u94fe\u4e86,\u90a3\u5c31\u76f4\u63a5\u8f6c\u91cd\u513f\u5b50\u80af\u5b9a\u8fd8\u662f\u4e00\u4e2a\u94fe\u554a,\u800c\u4e14\u8fd8\u4e0d\u4f1a\u6d89\u53caLCA\u7684\u70b9\u6743.\n\n## Code\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int Nmax = 300010;\nlong long Pointval[Nmax],ans;\nint to[Nmax<<1],net[Nmax<<1],fr[Nmax],cntside,n,m,r,p1,p2,p3;\nvoid add_side(int froms,int tos){\n\tnet[++cntside]=fr[froms];fr[froms]=cntside;to[cntside]=tos;\n}\nint fa[Nmax],size[Nmax],hson[Nmax],deep[Nmax];\nvoid dfs1(int start,int fat){\n\tdeep[start]=deep[fat]+1;\n\tfa[start]=fat;size[start]=1;\n\tfor(int lzh=fr[start];lzh;lzh=net[lzh]){\n\t\tif(to[lzh]==fat)continue;\n\t\tdfs1(to[lzh],start);\n\t\tsize[start]+=size[to[lzh]];\n\t\tif(size[to[lzh]]>size[hson[start]])\n\t\t\thson[start]=to[lzh];\n\t}\n}\nint id[Nmax],cntid,top[Nmax];\nvoid dfs2(int start,int tops){\n\tid[start]=++cntid;\n\ttop[start]=tops;\n\tif(hson[start])\n\t\tdfs2(hson[start],tops);\n\tfor(int lzh=fr[start];lzh;lzh=net[lzh]){\n\t\tif(to[lzh]==fa[start])continue;\n\t\tif(to[lzh]==hson[start])continue;\n\t\tdfs2(to[lzh],to[lzh]);\n\t}\n}\n#define mid ((ln+rn)>>1)\n#define ls lson[num]\n#define rs rson[num]\nlong long P,sum[Nmax<<1],pt;\nint lson[Nmax<<1],rson[Nmax<<1],root;\nvoid Change(int &num,int ln,int rn,int pos,int nd){\n\tif(!num)\tnum=++pt;\tsum[num]+=nd;\n\tif(ln==rn)\treturn;\n\tif(pos<=mid)Change(ls,ln,mid,pos,nd);\n\telse \t\tChange(rs,mid+1,rn,pos,nd);\n}\nlong long Gsum(int num,int ln,int rn,int ld,int rd){\n\tif(rn<ld||ln>rd)return 0;if(!num)return 0;\n\tif(ln>=ld&&rn<=rd)\treturn sum[num];\n\treturn Gsum(ls,ln,mid,ld,rd)+Gsum(rs,mid+1,rn,ld,rd);\n}\n\nint Wars[Nmax],cntwar;\nvoid work1(){\n\tscanf(\"%d%d\",&p1,&p2);\n\twhile(top[p1]!=top[p2]){\n\t\tif(deep[top[p1]]<deep[top[p2]])\tswap(p1,p2);\n\t\tif(Gsum(root,1,n,id[top[p1]],id[p1])<0){cout<<\"No\\n\";return;}\n\t\tp1=fa[top[p1]];\n\t}\n\tif(p1==p2){cout<<\"Yes\\n\";return;}\n\tif(id[p1]>id[p2])swap(p1,p2);p1=hson[p1];\n\tif(Gsum(root,1,n,id[p1],id[p2])<0){cout<<\"No\\n\";return;}\n\tcout<<\"Yes\\n\";return;\n}\nvoid work2(){\n\tscanf(\"%d%d\",&p1,&p2);\n\tif(fa[p1]==p2)\tChange(root,1,n,id[p1],-1),Wars[++cntwar]=p1;\n\telse\t\t\tChange(root,1,n,id[p2],-1),Wars[++cntwar]=p2;\n}\nvoid work3(){\n\tscanf(\"%d\",&p1);\n\tChange(root,1,n,id[Wars[p1]],1);\n}\nchar opt;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",&p1,&p2);\n\t\tadd_side(p1,p2);add_side(p2,p1);\n\t}\n\tdfs1(1,0);dfs2(1,1);\n\tfor(int i=1;i<=m;++i){\n\t\tfor(opt=getchar();opt!='Q'&&opt!='C'&&opt!='U';opt=getchar());\n\t\tswitch(opt){\n\t\t\tcase 'Q':work1();break;\n\t\t\tcase 'C':work2();break;\n\t\t\tcase 'U':work3();break;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n~~\u4e3a\u4e86\u8282\u7701\u7a7a\u95f4,\u6211\u5199\u4e86\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811,\u7136\u800c\u6ca1\u6709\u4efb\u4f55\u4f5c\u7528~~\n\n$T^{hank}_{you}$ $F^{or}_{read}$",
        "postTime": 1521938411,
        "uid": 43931,
        "name": "SofanHe",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "##\u9898\u610f\u63cf\u8ff0\uff1a\n\n\n\u7ed9\u4f60\u6709N\u4e2a\u70b9\u7684\u4e00\u68f5\u6811\u3002\n\nC u v \u8868\u793a u v\u4e4b\u95f4\u7684\u9053\u8def\u4e0d\u80fd\u901a\u884c\n\nQ u v \u8868\u793a \u8be2\u95ee u v\u4e4b\u95f4\u662f\u5426\u6709\u4e0d\u53ef\u901a\u884c\u7684\u9053\u8def\n\nU u \u8868\u793a \u7b2cu\u4e2a C\u64cd\u4f5c\u5931\u6548\n\n\u5199\u4e00\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u4ee5\u4e0a\u4e09\u79cd\u64cd\u4f5c\u3002\n\n##\u9898\u76ee\u5206\u6790\uff1a\n\n\n~~Woc\uff0c\u8fd9\u9898\u76ee\u4e0d\u4f1a\u8ba9\u6211\u6253LCT\u5427\u3002~~\n\n\u7b49\u4e00\u4e0b\uff0c\u597d\u50cf\u53ef\u4ee5\u6811\u5256\u89e3\u51b3\u5509\uff01\n\n~~\u949f\u7231\u66b4\u529b\u6570\u636e\u7ed3\u6784\u7684\u6211~~\n\n\u6211\u4eec\u5148\u8fdb\u884c\u6811\u5256\uff0c\u7136\u540e\u7ef4\u62a4\u4e00\u9897\u8fb9\u6743\u7ebf\u6bb5\u6811\uff0c\u652f\u6301\u533a\u95f4\u4fee\u6539\u548c\u533a\u95f4\u67e5\u8be2\u3002\n\n\u6bcf\u6b21\u628a\u5c01\u9501\u9053\u8def\u7684\u65f6\u95f4\u89c6\u4e3a u->lca(u,v)->v\u4e0a\u7684\u8def\u6743\u503c+1\n\n\u67e5\u8be2\u7684\u65f6\u5019\u53ea\u8981\u67e5\u8be2 u->lca(u,v)->v\u8fd9\u6761\u8def\u4e0a\u7684\u6743\u503c\u662f\u5426\u4e3a0\u5373\u53ef\n\n800ms\u5de6\u53f3\uff0c\u6548\u7387\u8fd8\u53ef\u4ee5\uff0c\u5c31\u4e0d\u5199\u6811\u72b6\u6570\u7ec4\u548czhw\u4e86\u3002\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#define lson (o<<1),l,mid\n#define rson (o<<1)+1,mid+1,r\nusing namespace std;\nconst int maxm=310000;\nint deep[maxm],son[maxm],size[maxm],fa[maxm],top[maxm];\nint head[maxm],to[maxm<<1],net[maxm<<1],cnt;\nint p[maxm],val[maxm];\nint id[maxm],tot;\nint n,m,root;\nstruct node{\n    int l,r,siz,maxi,sum,add;\n};\nnode t[maxm*4];\nstruct war{\n    int u,v;\n};\nwar a[maxm];\ninline void add(int x,int y)\n{\n    to[++cnt]=y;\n    net[cnt]=head[x];\n    head[x]=cnt;\n}\nint dfs1(int now,int fax,int dep)\n{\n    fa[now]=fax,deep[now]=dep,size[now]=1;\n    int maxson=-1;\n    for(int i=head[now];i;i=net[i])\n    if(to[i]!=fax)\n    {\n        size[now]+=dfs1(to[i],now,dep+1);\n        if(maxson<size[to[i]])\n         son[now]=to[i],maxson=size[to[i]];\n    }\n    return size[now];\n}\nvoid dfs2(int now,int topx)\n{\n    id[now]=++tot;\n    val[tot]=p[now];\n    top[now]=topx;\n    if(!son[now]) return;\n    dfs2(son[now],topx);\n    for(int i=head[now];i;i=net[i])\n     if(!id[to[i]])\n      dfs2(to[i],to[i]);\n}\ninline void update(int o)\n{\n    t[o].sum=(t[(o<<1)].sum+t[(o<<1)|1].sum);\n    t[o].maxi=max(t[(o<<1)].maxi,t[(o<<1)|1].maxi);\n}\ninline void pushdown(int o)\n{\n    int adi=t[o].add;\n    for(int i=0;i<=1;i++)\n     t[(o<<1)+i].sum=(t[(o<<1)+i].sum+(t[(o<<1)+i].siz*adi)),t[(o<<1)+i].add=(t[(o<<1)+i].add+adi);\n    t[o].add=0;\n}\nvoid build(int o,int l,int r)\n{\n    t[o].l=l,t[o].r=r,t[o].siz=r-l+1;\n    if(l==r)\n    {\n        t[o].sum=t[o].maxi=val[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(lson),build(rson);\n    update(o);\n}\nvoid adj(int o,int ql,int qr,int num)\n{\n    int l=t[o].l,r=t[o].r;\n    if(ql<=l&&qr>=r)\n    {\n        t[o].sum=(t[o].sum+(t[o].siz*num));\n        t[o].add=(t[o].add+num);\n        return;\n    }\n    pushdown(o);\n    int mid=(l+r)>>1;\n    if(ql<=mid) adj((o<<1),ql,qr,num);\n    if(qr>mid) adj((o<<1)|1,ql,qr,num);\n    update(o);\n}\nint ask(int o,int ql,int qr)\n{\n    int l=t[o].l,r=t[o].r;\n    if(ql<=l&&qr>=r)\n     return t[o].sum;\n    pushdown(o);\n    int mid=(l+r)>>1;\n    int p1=0,p2=0;\n    if(ql<=mid) p1=ask((o<<1),ql,qr);\n    if(qr>mid) p2=ask((o<<1)|1,ql,qr);\n    return (p1+p2);\n}\ninline int tree_sum(int u,int v)\n{\n    int ans=0;\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]<deep[top[v]]) swap(u,v);\n        ans=(ans+ask(1,id[top[u]],id[u]));\n        if(ans) return ans;\n        u=fa[top[u]];\n    }\n    if(deep[u]<deep[v]) swap(u,v);\n    ans=(ans+ask(1,id[v]+1,id[u]));\n    return ans;\n}\ninline void tree_x(int u,int v,int num)\n{\n    while(top[u]!=top[v])\n    {\n        if(deep[top[u]]<deep[top[v]]) swap(u,v);\n        adj(1,id[top[u]],id[u],num);\n        u=fa[top[u]];\n    }\n    if(deep[u]<deep[v]) swap(u,v);\n    adj(1,id[v]+1,id[u],num);\n}\ninline int read()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9') \n    {\n        if(ch=='-') w=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n    return x*w;\n}\nint main()\n{   \n    freopen(\"lct.in\",\"r\",stdin);\n    freopen(\"lct.out\",\"w\",stdout);\n    n=read(),m=read();\n    for(int i=1;i<n;i++)\n    {\n        int u=read(),v=read();\n        add(u,v),add(v,u);\n    }\n    dfs1(1,0,0),dfs2(1,1);\n    build(1,1,tot);\n    char s[10];\n    int nows=0;\n    for(int i=1,u,v,x;i<=m;i++)\n    {\n        scanf(\"%s\",s);\n        if(s[0]=='U')\n         x=read(),tree_x(a[x].u,a[x].v,-1);\n        if(s[0]=='Q')\n        {\n            u=read(),v=read();\n            if(tree_sum(u,v)) printf(\"No\\n\");\n            else printf(\"Yes\\n\");\n        }\n        if(s[0]=='C')\n        {\n           a[++nows].u=read(),a[nows].v=read();\n           tree_x(a[nows].u,a[nows].v,1);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1516432730,
        "uid": 19842,
        "name": "\u534a\u4ed9\u80e1\u5c0f\u6843",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u6765\u7bc7\u7ebf\u6bb5\u6811+\u500d\u589elca\u7684\u4eb2\u6c11\u9898\u89e3\u3002\n\n\u6211\u4eec\u628a\u6811\u4e0a\u7684\u8fb9\u6743\u521d\u59cb\u5316\u4e3a $0$\uff0c\u5f00\u6218\u89c6\u4e3a\u5c06 $p,q$ \u4e24\u70b9\u95f4\u7684\u8fb9\u6743 $+1$\uff0c\u505c\u6218\u89c6\u4e3a $-1$\u3002\u90a3\u4e48 $p,q$ \u4e24\u70b9\u4e92\u76f8\u53ef\u8fbe\u7b49\u4ef7\u4e8e\u4ece $p$ \u5230 $q$ \u7684\u7b80\u5355\u8def\u5f84\u7684\u8fb9\u6743\u548c\u4e3a $0$\u3002\n\n\u6307\u5b9a $1$ \u4e3a\u6839\u7ed3\u70b9\uff0c\u8003\u8651\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5230\u6839\u7ed3\u70b9\u7684\u7b80\u5355\u8def\u5f84\u7684\u8fb9\u6743\u548c $f_i$\u3002\u8be2\u95ee $p$ \u5230 $q$ \u7684\u8fb9\u6743\u548c\u5c31\u53ef\u4ee5\u8f6c\u5316\u4e3a\u8be2\u95ee $f_p+f_q-2\\times f_{lca(p,q)}$\u3002\u800c\u5c06 $p,q$ \uff08\u4e0d\u59a8\u8bbe $q$ \u662f $p$ \u7684\u7236\u4eb2\uff09\u4e24\u70b9\u95f4\u7684\u8fb9\u6743 $+k$\uff08$k$ \u4e3a\u6574\u6570\uff09\u5c31\u76f8\u5f53\u4e8e\u628a\u4ee5 $p$ \u4e3a\u6839\u7684\u5b50\u6811\u91cc\u7684\u6240\u6709\u70b9\u7684\u6743\u503c\u90fd $+k$\u3002\u8fd9\u662f\u7ecf\u5178\u95ee\u9898\uff0c\u7528\u4e00\u68f5\u652f\u6301\u533a\u95f4\u52a0\u5355\u70b9\u67e5\u8be2\u7684\u7ebf\u6bb5\u6811\u7ef4\u62a4 $dfs$ \u5e8f\u5217\u5373\u53ef\uff08\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u4ee3\u66ff\uff09\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O((n+m)logn)$\n\n\u4ee3\u7801\u5982\u4e0b\uff08\u70b9\u4e2a\u8d5e\u518d\u8d70\u5427\uff0c\u8c22\u8c22\u60a8\uff01QAQ\uff09\uff1a\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ls(p) p<<1\n#define rs(p) p<<1|1\n#define ll long long\n#define fo(i,x,y) for(register int i=x;i<=y;++i)\n#define go(i,x,y) for(register int i=x;i>=y;--i)\nusing namespace std;\ninline int read(){int x=0,fh=1; char ch=getchar(); while(!isdigit(ch)){if(ch=='-') fh=-1; ch=getchar();} while(isdigit(ch)){x=(x<<1)+(x<<3)+ch-'0'; ch=getchar();} return x*fh;}\n\nconst int N=3e5+5,M=20;\nstruct Edge{\n\tint to,next;\n}e[N<<1];\n\nstruct Node{\n\tint L,R,val=0,tag=0;\n}tree[N<<2];\nint head[N],tot,dfn[N],ti,dep[N],fa[N][M],n,q,lg,war[N],top,siz[N];\n\nvoid connect(int x,int y){\n\te[++tot]=(Edge){y,head[x]};\n\thead[x]=tot;\n}\n\nvoid dfs(int x){\n\tdfn[x]=++ti;\n\tsiz[x]=1;\n\tfor(int i=head[x];i;i=e[i].next){\n\t\tint p=e[i].to;\n\t\tif(dfn[p]) continue;\n\t\tdep[p]=dep[x]+1;\n\t\tfa[p][0]=x;\n\t\tdfs(p);\n\t\tsiz[x]+=siz[p];\n\t}\n}\n\nvoid push_up(int now){tree[now].val=tree[ls(now)].val+tree[rs(now)].val;}\n\nvoid build(int now,int L,int R){\n\ttree[now].L=L,tree[now].R=R;\n\tif(L==R) return;\n\tint mid=(L+R)>>1;\n\tbuild(ls(now),L,mid);\n\tbuild(rs(now),mid+1,R);\n}\n\nvoid push_down(int now){\n\tint lt=ls(now),rt=rs(now),k=tree[now].tag;\n\ttree[lt].val+=(tree[lt].R-tree[lt].L+1)*k;\n\ttree[lt].tag+=k;\n\ttree[rt].val+=(tree[rt].R-tree[rt].L+1)*k;\n\ttree[rt].tag+=k;\n\ttree[now].tag=0;\n}\n\nvoid update(int now,int aim_L,int aim_R,int k){\n\tif(tree[now].L>=aim_L&&tree[now].R<=aim_R){\n\t\ttree[now].val+=(tree[now].R-tree[now].L+1)*k;\n\t\ttree[now].tag+=k;\n\t\treturn;\n\t}\n\tint mid=(tree[now].L+tree[now].R)>>1;\n\tif(tree[now].tag) push_down(now);\n\tif(aim_L<=mid) update(ls(now),aim_L,aim_R,k);\n\tif(aim_R>mid) update(rs(now),aim_L,aim_R,k);\n\tpush_up(now);\n}\n\nint ask(int now,int aim){\n\tif(tree[now].L==tree[now].R) return tree[now].val;\n\tint mid=(tree[now].L+tree[now].R)>>1;\n\tif(tree[now].tag) push_down(now);\n\tif(aim<=mid) return ask(ls(now),aim);\n\treturn ask(rs(now),aim);\n}\n\nint lca(int x,int y){\n\tif(dep[x]<dep[y]) swap(x,y);\n\tgo(i,lg,0) if(dep[fa[x][i]]>=dep[y]) x=fa[x][i];\n\tif(x==y) return x;\n\tgo(i,lg,0) if(fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\n\nint main(){\n\tcin>>n>>q;lg=log(n)/log(2);\n\tfo(i,1,n-1){\n\t\tint x=read(),y=read();\n\t\tconnect(x,y);\n\t\tconnect(y,x);\n\t}\n\tbuild(1,1,n);\n\tdep[1]=1;dfs(1);\n\tfo(j,1,lg)\n\t\tfo(i,1,n) fa[i][j]=fa[fa[i][j-1]][j-1];\n\tchar ch;\n\twhile(q--){\n\t\tch=getchar();while(!isalpha(ch)) ch=getchar();\n\t\tif(ch=='Q'){\n\t\t\tint x=read(),y=read(),k=lca(x,y);\n\t\t\tputs(ask(1,dfn[x])+ask(1,dfn[y])==2*ask(1,dfn[k])?\"Yes\":\"No\");\n\t\t}else if(ch=='C'){\n\t\t\tint x=read(),y=read();\n\t\t\tif(fa[x][0]!=y) swap(x,y);\n\t\t\twar[++top]=x;//,war[top][1]=y;\n\t\t\tupdate(1,dfn[x],dfn[x]+siz[x]-1,1);\n\t\t}else{\n\t\t\tint p=read(),x=war[p];\n\t\t\tupdate(1,dfn[x],dfn[x]+siz[x]-1,-1);\n\t\t}\n\t}\n\treturn 0;\n}\n/*\n-------------------------------------------------\n*/\n```\n",
        "postTime": 1616742163,
        "uid": 238408,
        "name": "vectorwyx",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "## \u9898\u610f\n1.\uff08Q p q\uff09\u4ece\u7b2c p \u4e2a\u90e8\u843d\u51fa\u53d1\u7684\u5efa\u7b51\u5de5\u4eba\u60f3\u77e5\u9053\u80fd\u5426\u5230\u8fbe\u7b2c q \u4e2a\u90e8\u843d\u4e86\uff0c\u4f60\u8981\u56de\u7b54\u7684\u4fbf\u662f\uff08Yes/No\uff09\uff0c\u6ce8\u610f\u5927\u5c0f\u5199\n\n2.\uff08C p q\uff09\u7b2c p \u4e2a\u90e8\u843d\u4e0e\u7b2c q \u4e2a\u90e8\u843d\u5f00\u6218\u4e86\uff0c\u4fdd\u8bc1\u4ed6\u4eec\u4e00\u5b9a\u662f\u76f8\u90bb\u7684\u90e8\u843d\uff0c\u4e14\u76ee\u524d\u5904\u4e8e\u505c\u6218\uff08\u672a\u5f00\u6218\uff09\u72b6\u6001\n\n3.\uff08U x \uff09 \u7b2c x \u6b21\u53d1\u751f\u7684\u6218\u4e89\u7ed3\u675f\u4e86\uff0c\u5b83\u5c06\u6c38\u8fdc\u7684\u88ab\u8f7d\u5165\u53f2\u518c\uff0c\u4e0d\u590d\u5b58\u5728\uff08\u4fdd\u8bc1\u8fd9\u4e2a\u6d88\u606f\u4e0d\u4f1a\u544a\u8bc9\u4f60\u591a\u6b21\uff09\n\n## solution\n\u6211\u4eec\u628a\u4e0d\u80fd\u901a\u8fc7\u7684\u5728\u7ebf\u6bb5\u6811\u4e0a\u8d4b\u6210-1,\u7136\u540e\u53ea\u9700\u8981\u53bb\u4e00\u4e2a\u533a\u95f4min\n\n\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f-1\u5c31\u77e5\u9053\u80fd\u4e0d\u80fd\u8fc7\u53bb\u4e86.\n\n\u533a\u95f4min\n\n```cpp\nint query(int rt, int l, int r, int L, int R) {\n\t\tif (L <= l && r <= R) return tree[rt].min;\n\t\tint mid = (l + r) >> 1, ans = 1e9;\n\t\tif (L <= mid) ans = min(ans, query(lson, l, mid, L, R));\n\t\tif (R > mid) ans = min(ans, query(rson, mid + 1, r, L, R));\n\t\treturn ans; \n\t}\n```\n\n## code\n```cpp\n/*\n\tAuther:_Destiny\n\ttime:2020.5.6\n*/\n#include <bits/stdc++.h>\n#define ll long long\n#define N 300010\n#define M 1010\n\nusing namespace std;\nint n, m, p[N], q[N];\nint pre[N], dep[N], top[N], fath[N], siz[N], son[N], dfn[N], w[N];\n\nint read() {\n\tint s = 0, f = 0; char ch = getchar();\n\twhile (!isdigit(ch)) f |= (ch == '-'), ch = getchar();\n\twhile (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -s : s;\n}\n\nnamespace Seg {\n\t#define lson rt << 1\n\t#define rson rt << 1 | 1\n\tstruct node {\n\t\tint min;\n\t}tree[N << 2];\n\tvoid push_up(int rt) {\n\t\ttree[rt].min = min(tree[lson].min, tree[rson].min);\n\t}\n\tvoid build(int rt, int l, int r) {\n\t\tif (l == r) {\n\t\t\ttree[rt].min = w[pre[l]];\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tbuild(lson, l, mid);\n\t\tbuild(rson, mid + 1, r);\n\t\tpush_up(rt);\n\t}\n\tvoid update(int rt, int c, int l, int r, int pow) {\n\t\tif (l == r) {\n\t\t\ttree[rt].min = c;\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tif (pow <= mid) update(lson, c, l, mid, pow);\n\t\telse update(rson, c, mid + 1, r, pow);\n\t\tpush_up(rt);\n\t}\n\tint query(int rt, int l, int r, int L, int R) {\n\t\tif (L <= l && r <= R) return tree[rt].min;\n\t\tint mid = (l + r) >> 1, ans = 1e9;\n\t\tif (L <= mid) ans = min(ans, query(lson, l, mid, L, R));\n\t\tif (R > mid) ans = min(ans, query(rson, mid + 1, r, L, R));\n\t\treturn ans; \n\t}\n}\n\nnamespace Cut {\n\tint head[N << 1], add_edge, cnt;\n\tstruct node {\n\t\tint next, to;\n\t}edge[N << 1];\n\tvoid add(int from, int to) {\n\t\tedge[++add_edge].next = head[from];\n\t\tedge[add_edge].to = to;\n\t\thead[from] = add_edge;\n\t}\n\tvoid dfs(int x, int fa) {\n\t\tdep[x] = dep[fa] + 1, fath[x] = fa, siz[x] = 1;\n\t\tfor (int i = head[x]; i; i = edge[i].next) {\n\t\t\tint to = edge[i].to;\n\t\t\tif (to == fa) continue;\n\t\t\tw[to] = 1;  \n\t\t\tdfs(to, x), siz[x] += siz[to];\n\t\t\tif (siz[son[x]] < siz[to]) son[x] = to;\n\t\t}\n\t}\n\tvoid dfs2(int x, int tp) {\n\t\ttop[x] = tp, dfn[x] = ++cnt, pre[cnt] = x;\n\t\tif (son[x]) dfs2(son[x], tp);\n\t\tfor (int i = head[x]; i; i = edge[i].next) {\n\t\t\tint to = edge[i].to;\n\t\t\tif (to == son[x] || to == fath[x]) continue;\n\t\t\tdfs2(to, to);\n\t\t}\n\t}\n\tbool askmin(int x, int y) {\n\t\tint ans = 11111;\n\t\twhile (top[x] != top[y]) {\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\t\tans = min(ans, Seg::query(1, 1, n, dfn[top[x]], dfn[x]));\n\t\t\tx = fath[top[x]];\n\t\t}\n\t\tif (dfn[x] > dfn[y]) swap(x, y);\n\t\tans = min(ans, Seg::query(1, 1, n, dfn[x] + 1, dfn[y]));\n\t\tif (ans == 1) return 1;\n\t\telse return 0;\n\t}\n}\n\nint main() {\n\tn = read(), m = read();\n\tfor (int i = 1, x, y; i <= n - 1; i++) {\n\t\tx = read(), y = read();\n\t\tCut::add(x, y), Cut::add(y, x);\n\t}\n\tCut::dfs(1, 1), Cut::dfs2(1, 1), Seg::build(1, 1, n);\n\tchar cc; int ji = 0;\n\tfor (int i = 1, x, y; i <= m; i++) {\n\t\tcin >> cc;\n\t\tif (cc == 'Q') {\n\t\t\tx = read(), y = read();\n\t\t\tif (x == y) puts(\"Yes\");\n\t\t\telse if (Cut::askmin(x, y) == 1) puts(\"Yes\");\n\t\t\telse puts(\"No\"); \n\t\t} else if (cc == 'C') {\n\t\t\tx = read(), y = read();\n\t\t\tp[++ji] = x, q[ji] = y;\n\t\t\tSeg::update(1, -1, 1, n, max(dfn[x], dfn[y])); \n\t\t} else if (cc == 'U') {\n\t\t\tx = read();\n\t\t\tSeg::update(1, 1, 1, n, max(dfn[p[x]], dfn[q[x]]));\n\t\t}\t\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1588769466,
        "uid": 188155,
        "name": "K2sen",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u6700\u8fd1\u4e00\u76f4\u6ca1\u5199\u6811\u5256\uff0c\u57fa\u672c\u5fd8\u5149\u4e86\uff0c\u590d\u4e60\u4e00\u4e0b\u987a\u4fbf\u5199\u7bc7\u9898\u89e3\u5e2e\u52a9\u81ea\u5df1\u7406\u89e3\n\n### \u9898\u76ee\u5927\u610f\n\n\u7ed9\u51fa\u4e00\u68f5\u8282\u70b9\u6570\u4e3a $N$ \u7684\u6811\uff0c\u8981\u6c42\u5904\u7406\u4e09\u4e2a\u64cd\u4f5c\n\n- ```C p q``` \u5728\u7aef\u70b9\u4e3a $q$ \u4e0e $p$ \u7684\u8fb9\u4e0a\u6253\u4e0a\u6807\u8bb0\n\n- ```Q p q``` \u8be2\u95ee\u8282\u70b9 $p$ \u5230\u8282\u70b9 $q$ \u7684\u552f\u4e00\u8def\u5f84\u4e2d\u662f\u5426\u5b58\u5728\u88ab\u6253\u4e0a\u6807\u8bb0\u7684\u8fb9\n\n- ```U x``` \u5c06\u7b2c $x$ \u6b21 C \u64cd\u4f5c\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u6807\u8bb0\u6e05\u9664\uff0c\u6570\u636e\u4fdd\u8bc1\u4e0d\u4f1a\u91cd\u590d\u6e05\u9664\n\n\u5bf9\u4e8e\u6bcf\u4e00\u6b21 Q \u8be2\u95ee\uff0c\u82e5\u8def\u5f84\u5b58\u5728\u6807\u8bb0\u8fb9\u8f93\u51fa ```No``` \uff0c\u5426\u5219\u8f93\u51fa ```Yes```\n\n### \u601d\u8def\n\n\u9996\u5148\u53d1\u73b0\u8fd9\u4e9b\u64cd\u4f5c\u4f7f\u7528\u6811\u5256\u5f88\u5bb9\u6613\u64cd\u4f5c\uff0c\u5177\u4f53\u65b9\u6cd5\u662f\u5c06\u6bcf\u4e00\u6761\u8fb9\u90fd\u521d\u59cb\u5316\u4e00\u4e2a\u6743\u503c $0$ \uff0c\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u64cd\u4f5c\u4f9d\u6b21\u8fd0\u884c\n\n- \u5bf9\u4e8e C \u4fee\u6539\u64cd\u4f5c\uff1a \u53ef\u4ee5\u5c06\u88ab\u6253\u4e0a\u6807\u8bb0\u7684\u8fb9\u7684\u6743\u503c + 1\n\n- \u5bf9\u4e8e Q \u8be2\u95ee\u64cd\u4f5c\uff1a \u8be2\u95ee\u8def\u5f84\u4e2d\u7684\u6700\u5927\u6743\u503c\uff0c\u5982\u679c\u4e3a $0$ \u5219\u65e0\u6807\u8bb0\u8fb9\uff0c\u5426\u5219\u5c31\u5b58\u5728\n\n- \u5bf9\u4e8e U \u6e05\u9664\u64cd\u4f5c\uff1a \u5c06\u8fd9\u4e00\u6761\u8fb9\u7684\u6743\u503c - 1 \u5373\u53ef\n\n\u7136\u540e\u5c31\u662f\u6811\u5256\u7684\u677f\u5b50\u4e86\n\n### \u4ee3\u7801\n\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define MAX_N 300010\n#define inf 0x3f3f3f3f\nstruct Tree{\n    int dep,father,siz,son,id,top;\n    vector<int> next;\n}node[MAX_N];\nvoid dfs1(int u,int fa,int deep){\n    node[u].father = fa;\n    node[u].dep = deep;\n    node[u].siz = 1;\n    int max_son = -1;\n    for(int i = 0;i < node[u].next.size();i++){\n        int v = node[u].next[i];\n        if(v == node[u].father)continue;\n        dfs1(v,u,deep+1);\n        node[u].siz += node[v].siz;\n        if(node[v].siz > max_son){\n            max_son = node[v].siz;\n            node[u].son = v;\n        }\n    }\n}\nint cnt = 0,a[MAX_N];\nvoid dfs2(int u,int tops){\n    cnt++;\n    node[u].id = cnt;\n    node[u].top = tops;\n    a[cnt] = 0;\n    if(node[u].son == 0)return;\n    dfs2(node[u].son,tops);\n    for(int i = 0;i < node[u].next.size();i++){\n        int v = node[u].next[i];\n        if(v == node[u].son || v == node[u].father)continue;\n        dfs2(v,v);\n    }\n}\nstruct SegmentTree{\n    int lson,rson;\n    int dat;\n}tree[MAX_N * 4];\nint lazy_tag[MAX_N * 4];\nvoid build(int p,int l,int r){\n    tree[p].lson = l;\n    tree[p].rson = r;\n    if(l == r){\n        tree[p].dat = a[l];\n        return;\n    }\n    int mid = (l + r) >> 1;\n    build(p*2,l,mid);\n    build(p*2+1,mid+1,r);\n    tree[p].dat = max(tree[p*2].dat,tree[p*2+1].dat);\n}\nvoid pushdown(int p){\n    if(lazy_tag[p] == 0)return;\n    tree[p*2].dat += lazy_tag[p];\n    tree[p*2+1].dat += lazy_tag[p];\n    lazy_tag[p*2] += lazy_tag[p];\n    lazy_tag[p*2+1] += lazy_tag[p];\n    lazy_tag[p] = 0;\n}\nint query(int p,int l,int r){\n    if(tree[p].lson >= l && tree[p].rson <= r)\n        return tree[p].dat;\n    pushdown(p);\n    int mid = (tree[p].lson + tree[p].rson) >> 1,val = -inf;\n    if(l <= mid)val = max(val,query(p*2,l,r));\n    if(r > mid)val = max(val,query(p*2+1,l,r));\n    return val;\n}\nvoid change(int p,int l,int r,int d){\n    if(tree[p].lson >= r && tree[p].rson <= r){\n        tree[p].dat += d;\n        lazy_tag[p] += d;\n        return;\n    }\n    pushdown(p);\n    int mid = (tree[p].lson + tree[p].rson) >> 1;\n    if(l <= mid)change(p*2,l,r,d);\n    if(r > mid)change(p*2+1,l,r,d);\n    tree[p].dat = max(tree[p*2].dat,tree[p*2+1].dat);\n}\nvoid updRange(int x,int y,int d){\n    while(node[x].top != node[y].top){\n        int topx = node[x].top,topy = node[y].top;\n        if(node[topx].dep < node[topy].dep)swap(x,y),swap(topx,topy);\n        change(1,node[topx].id,node[x].id,d);\n        x = node[topx].father;\n    }\n    if(node[x].dep > node[y].dep)swap(x,y);\n    change(1,node[x].id+1,node[y].id,d);\n}\nint qRange(int x,int y){\n    int ans = -inf;\n    while(node[x].top != node[y].top){\n        int topx = node[x].top,topy = node[y].top;\n        if(node[topx].dep < node[topy].dep)swap(x,y),swap(topx,topy);\n        ans = max(ans,query(1,node[topx].id,node[x].id));\n        x = node[topx].father;\n    }\n    if(node[x].dep > node[y].dep)swap(x,y);\n    ans = max(ans,query(1,node[x].id + 1,node[y].id));\n    return ans;\n}\nstruct battles{\n    int x,y;\n}battle[MAX_N];\nint t = 0;\nint main(){\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    for(int i = 1;i < n;i++){\n        int u,v;\n        cin >> u >> v;\n        node[u].next.push_back(v);\n        node[v].next.push_back(u);\n    }\n    dfs1(1,1,1);\n    dfs2(1,1);\n    build(1,1,n);\n    while(m--){\n        char opt;\n        cin >> opt;\n        if(opt == 'Q'){\n            int x,y;\n            cin >> x >> y;\n            int ans = qRange(x,y);\n            if(x == y)cout << \"Yes\" << endl;\n            else if(ans == 0)cout << \"Yes\" << endl;\n            else cout << \"No\" << endl;\n        }\n        else if(opt == 'C'){\n            t++;\n            cin >> battle[t].x >> battle[t].y;\n            updRange(battle[t].x,battle[t].y,1);\n        }\n        else{\n            int c;\n            cin >> c;\n            updRange(battle[c].x,battle[c].y,-1);\n        }\n    }\n    return 0;\n}\n```\n\n### \u540e\u8bb0\n\n$Updata \\ 2021.1.11$ \u5b8c\u6210\u9898\u89e3",
        "postTime": 1610250952,
        "uid": 355559,
        "name": "FutureThx",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "\u4e3a\u4ec0\u4e48\u6811\u94fe\u5256\u5206\u7684\u9898\u76ee\u4e00\u5b9a\u8981\u7528\u6811\u94fe\u5256\u5206\u6765\u505a\u5462\uff1f\n\n## \u3010\u601d\u8def\u3011\n\u663e\u7136\u53ea\u9700\u8981\u67e5\u4e24\u70b9\u4e4b\u95f4\u662f\u5426\u6709\u65ad\u8fb9\u5373\u53ef\u3002\n\n\u90a3\u4e48\u65ad\u8fb9\u6807 $1$ \uff0c\u7136\u540e\u5c31\u662f\u7528 dfs \u5e8f\u7ef4\u62a4\u6811\u4e0a\u7684\u94fe\u4e0a\u4fe1\u606f\uff0c\u611f\u89c9\u633a\u677f\u5b50\u7684\u3002\n\n\u52a0\u4e00\u4e2a\u8fb9\u6743\u8f6c\u70b9\u6743\u5373\u53ef\u3002\n\n\u7136\u540e\u8fde\u8fb9\u7684\u8bdd\u6807\u56de $0$ \u5c31\u884c\u4e86\u3002\n\n\u7531\u4e8e dfs \u5e8f\u5957\u4e0a\u7ebf\u6bb5\u6811\u53ea\u80fd\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\uff0c\u8003\u8651\u4f7f\u7528\u6811\u4e0a\u5dee\u5206\u7684\u601d\u60f3\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u7ef4\u62a4\u94fe\u4e0a\u4fe1\u606f\u4e86\u3002\n\n## \u3010\u4ee3\u7801\u3011\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef unsigned int UI;\ntypedef pair <int, int> pi;\n\ntemplate <typename T>\ninline void read(T &x){\n    x = 0;int fu = 1;\n    char c = getchar();\n    while(c > 57 || c < 48){\n        if(c == 45) fu = -1;\n        c = getchar();\n    }\n    while(c <= 57 && c >= 48){\n        x = (x << 3) + (x << 1) + c - 48;\n        c = getchar();\n    }\n    x *= fu;\n}\ntemplate <typename T>\ninline void fprint(T x){\n    if(x < 0) putchar(45), x = -x;\n    if(x > 9) fprint(x / 10);\n    putchar(x % 10 + 48);\n}\ntemplate <typename T>\ninline void fprint(T x, char ch){\n    fprint(x);putchar(ch);\n}\ninline char next_char(){\n    char ch = getchar();\n    while(ch == 9 || ch == 10 || ch == 32) ch = getchar();\n    return ch;\n}\n\nint n, m;\n\nint head[300005], nxt[600005], e[600005], cnt;\n\ninline void add(int u, int v){\n    nxt[++ cnt] = head[u];\n    head[u] = cnt;\n    e[cnt] = v;\n}\nint fa[300005][21], tot, dep[300005], dfn[300005], low[300005];\nvoid dfs(int x, int pre){\n    dfn[x] = ++ tot;\n    dep[x] = dep[pre] + 1;\n    for (register int i = head[x];i;i = nxt[i]){\n        if(e[i] == pre) continue;\n        fa[e[i]][0] = x;\n        for (register int j = 1;j <= 20;j ++) fa[e[i]][j] = fa[fa[e[i]][j - 1]][j - 1];\n        dfs(e[i], x);\n    }\n    low[x] = tot;\n}\n\n#define LSON rt << 1, l, mid\n#define RSON rt << 1 | 1, mid + 1, r\n\nLL lazy[1200005], t[1200005];\ninline void pushup(int rt){t[rt] = t[rt << 1] + t[rt << 1 | 1];}\ninline void update(int rt, int l, int r, LL val){\n    t[rt] += 1ll * (r - l + 1) * val;\n    lazy[rt] += val;\n}\ninline void pushdown(int rt, int l, int r){\n    if(lazy[rt]){\n        int mid = (l + r) >> 1;\n        update(LSON, lazy[rt]);\n        update(RSON, lazy[rt]);\n        lazy[rt] = 0;\n    }\n}\nvoid modify(int rt, int l, int r, int x, int y, LL z){\n    if(l > r) return ;\n    if(x <= l && r <= y) return update(rt, l, r, z);\n    pushdown(rt, l, r);\n    int mid = (l + r) >> 1;\n    if(x <= mid) modify(LSON, x, y, z);\n    if(y > mid) modify(RSON, x, y, z);\n    pushup(rt);\n}\nLL query(int rt, int l, int r, int x, int y){\n    if(x <= l && r <= y) return t[rt];\n    pushdown(rt, l, r);\n    int mid = (l + r) >> 1;LL ret = 0;\n    if(x <= mid) ret += query(LSON, x, y);\n    if(y > mid) ret += query(RSON, x, y);\n    return ret;\n}\ninline int LCA(int x, int y){\n    if(dep[x] < dep[y]) swap(x, y);\n    for (register int i = 20;i >= 0;i --){\n        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];\n        if(dep[x] == dep[y]) break;\n    }\n    if(x == y) return x;\n    for (register int i = 20;i >= 0;i --){\n        if(fa[x][i] ^ fa[y][i]){\n            x = fa[x][i];\n            y = fa[y][i];\n        }\n    }\n    return fa[x][0];\n}\nint _u[300005], _v[300005], _tot;\nint main(){\n    read(n);read(m);\n    for (register int i = 1;i < n;i ++){\n        int u, v;read(u);read(v);\n        add(u, v);add(v, u);\n    }\n    dfs(1, 0);\n    while(m --){\n        char opt = next_char();\n        int u, v;read(u);\n        if(opt == 'U'){\n            v = _v[u];u = _u[u];\n            if(dep[u] < dep[v]) swap(u, v);\n            modify(1, 1, n, dfn[u], low[u], -1);\n        }\n        if(opt == 'C'){\n            read(v);\n            _u[++ _tot] = u;_v[tot] = v;\n            if(dep[u] < dep[v]) swap(u, v);\n            modify(1, 1, n, dfn[u], low[u], 1);\n        }\n        if(opt == 'Q'){\n            read(v);\n            int lca = LCA(u, v);\n            int num1 = query(1, 1, n, dfn[u], dfn[u]);\n            int num2 = query(1, 1, n, dfn[v], dfn[v]);\n            int num3 = query(1, 1, n, dfn[lca], dfn[lca]);\n            printf(\"%s\\n\", num1 + num2 - (num3 << 1)? \"No\" : \"Yes\");\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1602591349,
        "uid": 66511,
        "name": "DPair",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    },
    {
        "content": "$\\text{\u8fd9\u9898\u662f\u4e2a\u6811\u94fe\u5256\u5206\u7684\u677f\u5b50\u9898 \uff08\u597d\u50cf\u6811\u5256\u8dd1\u7684\u6bd4 LCT \u5feb\uff09}$\n\n$\\text{\u8fd9\u9898\u7684\u64cd\u4f5c \uff1a \u533a\u95f4\u4fee\u6539 \u533a\u95f4\u67e5\u8be2}$\n\n$\\text{\u6211\u4eec\u8003\u8651\u9898\u76ee\u6240\u8bf4\u7684\u6ca1\u6709\u91cd\u590d\u7684x\u6240\u4ee5\u6211\u4eec\u4e0d\u7528\u5224\u91cd\u76f4\u63a5\u5e72}$\n\n$\\text{\u6240\u4ee5\u628a\u6bcf\u4e2a\u52a0\u6cd5\u64cd\u4f5c\u5373\u5f00\u6218\u5b58\u5728vector\u91cc\u9762 \u7136\u540e\u7ed3\u675f\u4e86\u76f4\u63a5\u67e5\u8be2\u3002\u3002}$\n\n$\\text{Yes No \u662f\u533a\u95f4\u67e5\u8be2 \u5982\u679c\u80fd\u5230\u90a3\u4e2a\u4f4d\u7f6e \u5c31\u80af\u5b9a\u6ca1\u6709\u6218\u4e89\u5373\u67e5\u8be2\u7684\u662f0}$\n\n\n\n$\\mathcal Code$\n\n```cpp\n//Isaunoya\n#include<bits/stdc++.h>\nusing namespace std ;\ninline int read() { register int x = 0 ; register int f = 1 ; register char c = getchar() ;\n\tfor( ; ! isdigit(c) ; c = getchar()) if(c == '-') f = -1 ;\n\tfor( ; isdigit(c) ; c = getchar()) x = (x << 1) + (x << 3) + (c & 15) ;\n\treturn x * f ;\n} int st[105] ;\ntemplate < typename T > inline void write(T x , char c = '\\n') { int tp = 0 ;\n\tif(x == 0) return (void) puts(\"0\") ;\n\tif(x < 0) putchar('-') , x = -x ;\n\tfor( ; x ; x /= 10) st[++ tp] = x % 10 ;\n\tfor( ; tp ; tp --) putchar(st[tp] + '0') ;\n\tputchar(c) ;\n}\n//#define Online_Judge\nint n ;\nvector < pair < int , int > > v ;\nconst int N = 3e5 + 10 ;\nint a[N] ;\nstruct node {\n\tint v ;\n\tint nxt ;\n};\nnode e[N << 1] ; int head[N] ;\nint cnt = 0 ;\ninline void Add(int u , int v) {\n\te[++ cnt].v = v ;\n\te[cnt].nxt = head[u] ;\n\thead[u] = cnt ;\n\treturn ;\n} \nint size[N] ;\nint top[N] , son[N] ;\nint fa[N] ; int id[N] ; int d[N] ;\nint idx = 0 ;\ninline void Dfs1(int u) {\n\tsize[u] = 1 ;\n\tfor(register int i = head[u] ; i ; i = e[i].nxt) {\n\t\tint v = e[i].v ;\n\t\tif(v ^ fa[u]) {\n\t\t\tfa[v] = u ;\n\t\t\td[v] = d[u] + 1 ;\n\t\t\tDfs1(v) ;\n\t\t\tsize[u] += size[v] ;\n\t\t\tif(size[son[u]] < size[v]) son[u] = v ;\n\t\t}\n\t}\n}\ninline void Dfs2(int u , int t) {\n\tid[u] = ++ idx ;\n\ttop[u] = t ;\n\ta[idx] = 0 ;\n\tif(! son[u]) return ;\n\tDfs2(son[u] , t) ;\n\tfor(register int i = head[u] ; i ; i = e[i].nxt) {\n\t\tint v = e[i].v ;\n\t\tif(v ^ fa[u] && v ^ son[u]) {\n\t\t\tDfs2(v , v) ;\n\t\t}\n\t}\n}\nint sum[N << 2] ;\nint tag[N << 2] ;\ninline void build(int l , int r , int rt) {\n\tif(l == r) {\n\t\tsum[rt] = a[l] ; \n\t\ttag[rt] = 0 ;\n\t\treturn ;\n\t}\n\tint mid = l + r >> 1 ;\n\tbuild(l , mid , rt << 1) ;\n\tbuild(mid + 1 , r , rt << 1 | 1) ;\n\tsum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;\n\treturn ;\n}\ninline void Push_down(int rt , int l , int r) {\n\tif(tag[rt]) {\n\t\ttag[rt << 1] += tag[rt] ;\n\t\ttag[rt << 1 | 1] += tag[rt] ;\n\t\tint mid = l + r >> 1 ;\n\t\tsum[rt << 1] += tag[rt] * (mid - l + 1) ;\n\t\tsum[rt << 1 | 1] += tag[rt] * (r - mid) ;\n\t\ttag[rt] = 0 ;\n\t\treturn ;\n\t}\n}\ninline void Change(int a , int b , int l , int r , int rt , int val) {\n\tif(a <= l && r <= b) {\n\t\tsum[rt] += val * (r - l + 1) ;\n\t\ttag[rt] += val ;\n\t\treturn ;\n\t}\n\tint mid = l + r >> 1 ;\n\tPush_down(rt , l , r) ;\n\tif(a <= mid) Change(a , b , l , mid , rt << 1 , val) ;\n\tif(b > mid) Change(a , b , mid + 1 , r , rt << 1 | 1 , val) ;\n\tsum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;\n\treturn ;\n}\ninline int Query(int a , int b , int l , int r , int rt) {\n\tif(a <= l && r <= b) return sum[rt] ;\n\tint mid = l + r >> 1 ;\n\tint ans = 0 ;\n\tPush_down(rt , l , r) ;\n\tif(a <= mid) ans += Query(a , b , l , mid , rt << 1) ;\n\tif(b > mid) ans += Query(a , b , mid + 1 , r , rt << 1 | 1) ;\n\treturn ans ;\n}\ninline int Query_Range(int x , int y) {\n\tint fx = top[x] ;\n\tint fy = top[y] ;\n\tint ans = 0 ;\n\twhile(fx ^ fy) {\n\t\tif(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n\t\tans += Query(id[fx] , id[x] , 1 , n , 1) ;\n\t\tx = fa[fx] ;\n\t\tfx = top[x] ;\n\t}\n\tif(id[x] > id[y]) swap(x , y) ;\n\tans += Query(id[x] + 1 , id[y] , 1 , n , 1) ;\n\treturn ans ;\n}\ninline void Change_Range(int x , int y , int val) {\n\tint fx = top[x] ;\n\tint fy = top[y] ;\n\tint ans = 0 ;\n\twhile(fx ^ fy) {\n\t\tif(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n\t\tChange(id[fx] , id[x] , 1 , n , 1 , val) ;\n\t\tx = fa[fx] ;\n\t\tfx = top[x] ;\n\t}\n\tif(id[x] > id[y]) swap(x , y) ;\n\tChange(id[x] + 1 , id[y] , 1 , n , 1 , val) ;\n}\nsigned main() {\n#ifdef Online_Judge\n\tfreopen(\"testdata.in\" , \"r\" , stdin) ;\n\tfreopen(\"testdata2.out\" , \"w\" , stdout) ;\n#endif\n\tn = read() ; int q = read() ;\n\tfor(register int  i = 1 ; i <= n - 1 ; i ++) {\n\t\tint u = read() ;\n\t\tint v = read() ;\n\t\tAdd(u , v) ;\n\t\tAdd(v , u) ;\n\t}\n\tDfs1(1) ;\n\tDfs2(1 , 1) ;\n\tbuild(1 , n , 1) ;\n\tfor(register int i = 1 ; i <= q ; i ++) {\n\t\tregister char c = getchar() ;\n\t\tfor( ; c != 'C' && c != 'Q' && c != 'U' ; c = getchar()) ;\n\t\tif(c == 'Q') {\n\t\t\tint x = read() , y = read() ;\n\t\t\tif(Query_Range(x , y)) puts(\"No\") ;\n\t\t\telse puts(\"Yes\") ;\n\t\t}\n\t\tif(c == 'C') {\n\t\t\tint x = read() , y = read() ;\n\t\t\tChange_Range(x , y , 1) ;\n\t\t\tv.push_back(make_pair(x , y)) ;\n\t\t}\n\t\tif(c == 'U') {\n\t\t\tint num = read() - 1 ;\n\t\t\tint x = v[num].first ;\n\t\t\tint y = v[num].second ;\n\t\t\tChange_Range(x , y , - 1) ;\n\t\t}\n\t}\n\treturn 0 ;\n}\n```",
        "postTime": 1567814658,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3950 \u3010\u90e8\u843d\u51b2\u7a81\u3011"
    }
]