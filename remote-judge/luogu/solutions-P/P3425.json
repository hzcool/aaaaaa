[
    {
        "content": "### \u524d\u7f6e\u829d\u58eb\uff1a\u7f51\u7edc\u6d41  \n\u6bd4\u8f83\u597d\u7684\u4e00\u9053\u7f51\u7edc\u6d41\u9898\u4e86\uff0c\u6bd4\u8f83\u9002\u5408\u6765\u7ec3\u4e60\u601d\u7ef4\u548c\u6784\u56fe\u80fd\u529b\uff0c\u8fd8\u662f\u8001\u751f\u5e38\u8c08\u7684\u4e00\u53e5\u8bdd\uff1a\u56fe\u8bba\u7684\u9898\u5c31\u662f\u6784\u56fe $+$ \u8dd1\u677f\u5b50  \n\u9996\u5148~~\u6700\u96be~~\u7684\u4e00\u6b65\uff0c\u753b\u51fa\u6e90\u70b9\u548c\u6c47\u70b9\u8fd9\u91cc\u7528 st \u548c en \u8868\u793a \n![](https://cdn.luogu.com.cn/upload/image_hosting/lmxdtbnp.png)\n\u597d\u7136\u540e\u6211\u4eec\u8003\u8651\u5c06\u8d77\u70b9\u548c\u6bcf\u4e00\u573a\u6bd4\u8d5b\u8fde\u7ebf\uff0c\u5bb9\u91cf\u4e3a 1\uff0c\u8fd9\u4e2a\u7684\u610f\u601d\u5c31\u662f\u6bcf\u4e2a\u6bd4\u8d5b\u6700\u591a\u6709\u4e00\u4e2a\u4eba\u83b7\u80dc\uff0c\u8fd9\u91cc\u7528\u7c89\u8272\u8868\u793a\uff0c~~\u56e0\u4e3a\u7c89\u8272\u597d\u5eb7~~  \n![](https://cdn.luogu.com.cn/upload/image_hosting/q6mbio13.png)\n\u7136\u540e\u5c06\u6bcf\u4e00\u573a\u6bd4\u8d5b\u548c\u76f8\u5bf9\u5e94\u7684\u4e24\u4e2a\u4eba\u8fde\u7ebf\uff0c\u5bb9\u91cf\u4e3a 1\uff0c\u4ee3\u8868\u8fd9\u4e2a\u4eba\u83b7\u80dc\u6216\u8005\u662f\u4e0d\u83b7\u80dc\uff0c\u8fd9\u91cc\u7528\u7eff\u8272\u8868\u793a  \n![](https://cdn.luogu.com.cn/upload/image_hosting/5p4n7cwf.png)\n\u7136\u540e\u5c06\u6240\u6709\u4eba\u548c\u7ec8\u70b9\u8fde\u7ebf \n![](https://cdn.luogu.com.cn/upload/image_hosting/bh7wv3a9.png)  \n\u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5bb9\u91cf\u4e3a\u591a\u5c11\u5462\uff1f  \n\u8fd9\u4e2a\u503c\u6211\u4eec\u4e0d\u786e\u5b9a\u5bf9\u5427\uff0c\u8868\u793a\u7684\u662f\u80dc\u573a\u7684\u573a\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u53bb\u679a\u4e3e\uff0c\u600e\u4e48\u679a\u4e3e\u5462 $1-n$ \u4f9d\u6b21\u679a\u4e3e\uff1f\u90a3\u5c82\u4e0d\u76f4\u63a5\u4e0a\u5929\u3002\u5f88\u5bb9\u6613\u53ef\u4ee5\u53d1\u73b0\u8fd9\u4e2a\u5176\u4e2d\u662f\u6709\u5355\u8c03\u6027\u7684\uff0c\u5982\u679c\u7ed9\u7684\u5bb9\u91cf\u8d8a\u5927\uff0c\u90a3\u4e48\u80dc\u573a\u5c31\u4f1a\u76f8\u5e94\u7684\u53d8\u5927\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u4e8c\u5206\u7b54\u6848\uff0c\u597d\u50cf \u4e8c\u5206\u7b54\u6848 $+$ \u7f51\u7edc\u6d41 \u5df2\u7ecf\u6210\u56fa\u5b9a\u5957\u8def\u4e86    \n\u6b64\u9898\u6709\u53ef\u80fd\u8fd8\u8fc7\u4e0d\u4e86\uff0c\u53ef\u80fd\u4f1a T \u6389\uff0c\u6240\u4ee5\u7b80\u5355\u7684\u518d\u89c2\u5bdf\u4ebf\u4e0b\uff0c\u53ef\u4ee5\u53d1\u73b0\uff0c\u6211\u4eec\u753b\u7684\u662f\u4e8c\u5206\u56fe\uff0c\u6240\u4ee5\u66fe\u5e7f\u8def\u4f1a\u5f88\u77ed\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7f29\u5c0f\u9000\u51fa $dfs$ \u5f53\u7136\u5982\u679c\u4f60\u7528\u7684\u662f $dinic$ \u5c31\u5f53\u6211\u6ca1\u8bf4\u5566\uff0c\u56e0\u4e3a\u662f\u5230\u6e90\u70b9\u7684\u8ddd\u79bb\uff0c\u6240\u4ee5\u4e5f\u65e0\u6240\u8c13\u5566\uff0c\u6211\u8fd9\u79cd\u53ea\u662f\u63d0\u9192\u4f7f\u7528 $ISAP$ \u7684\u540c\u5b66qwq      \n\u7136\u540e\u5c31\u8f7b\u677e\u7684\u89e3\u51b3\u4e86\u8fd9\u4e00\u9898\u5566\uff0c\u4ee3\u7801\u4e5f\u5c31\u5f88\u7b80\u5355\u4e86  \n```\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\n#define ll long long\nusing namespace std;\nconst int N=300010,M=80000010;\nstruct MS{\n\tint from,to,next,z;\n}e[M];\nint elast[N],cur[N],k=1;\nvoid print(int x,int y,int z){cout<<x<<\"->\"<<y<<\"=\"<<z<<endl;}\nvoid add(int x,int y,int z)\n{\n\t//print(x,y,z);\n\te[++k].to=y,e[k].from=x,e[k].z=z,e[k].next=elast[x],elast[x]=k;\n\te[++k].to=x,e[k].from=y,e[k].z=0,e[k].next=elast[y],elast[y]=k;\n}\nstruct MSQWQ{\n\tint x,y;\n}a[N];\nint n,m;\nint ans;\nint st,en;\nint dis[N],cnt[N];\nvoid bfs(int en)\n{\n\tqueue<int>q;\n\tq.push(en);\n\tfor(int i=0;i<=N-10;i++)cur[i]=elast[i],dis[i]=-1,cnt[i]=0;\n\tdis[en]=0;\n\tcnt[0]=1;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();q.pop();\n\t\tfor(int i=elast[now];i;i=e[i].next)\n\t\t{\n\t\t\tint to=e[i].to;\n\t\t\tif(dis[to]==-1)\n\t\t\t{\n\t\t\t\tdis[to]=dis[now]+1;\n\t\t\t\tcnt[dis[to]]++;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int x,int flow)\n{\n\tif(x==en)return flow;\n\tint d=0;\n\tfor(int i=cur[x];i;i=e[i].next)\n\t{\n\t\tcur[x]=i;\n\t\tint to=e[i].to;\n\t\tif(e[i].z>0&&dis[x]==dis[to]+1)\n\t\t{\n\t\t\tint tmp=dfs(to,min(e[i].z,flow-d));\n\t\t\te[i].z-=tmp;\n\t\t\te[i^1].z+=tmp;\n\t\t\td+=tmp;\n\t\t\tif(d==flow||dis[st]>=666)return d;\n\t\t}\n\t}\n\tif(dis[st]>=666)return d;\n\tcnt[dis[x]]--;\n\tif(cnt[dis[x]]==0)dis[st]=666;\n\tdis[x]++;\n\tcur[x]=elast[x];\n\tcnt[dis[x]]++;\n\treturn d;\n}\nint L,R,mid,qans;\nint id[N];\nbool check(int mid)\n{\n\tk=1;\n\tmemset(elast,0,sizeof(elast));\n\tfor(int i=1;i<=m;i++)add(st,i,1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tid[i]=k+1;\n\t\tadd(i,m+a[i].x,1);\n\t\tadd(i,m+a[i].y,1);\t\t\n\t}\n\tfor(int i=1;i<=n;i++)add(m+i,en,mid);\n\tans=0;\n\tbfs(en);\n\twhile(dis[st]<666)ans+=dfs(st,1e9);\n\tif(ans>=m)return true;\n\treturn false;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tst=0,en=n+m+1;\n\tfor(int i=1;i<=m;i++)scanf(\"%d%d\",&a[i].x,&a[i].y);\n\tL=m/n,R=m;\n\twhile(L<=R)\n\t{\n\t\tmid=(L+R)/2;\n\t\tif(check(mid))qans=mid,R=mid-1;\n\t\telse L=mid+1;\n\t}\n\tprintf(\"%d\\n\",qans);\n\tcheck(qans);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(e[id[i]].z==0)printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1627005967,
        "uid": 247269,
        "name": "MSqwq",
        "ccfLevel": 0,
        "title": "P3425 [POI2005]KOS-Dicing"
    },
    {
        "content": "## \u4e8c\u5206+\u7f51\u7edc\u6d41\n- \u770b\u5230\"\u6700\u5927\u503c\u6700\u5c0f\",\u663e\u7136\u8981\u4e8c\u5206\u6700\u5c11\u8d62\u591a\u5c11\u573a\u3002\n- \u6e90\u70b9\u5411\u6bcf\u4e00\u4e2a\u6bd4\u8d5b\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a1\u7684\u8fb9\uff0c\u8868\u660e\u6bcf\u4e2a\u6bd4\u8d5b\u53ea\u80fd\u8d62\u4e00\u6b21\n- \u6bcf\u4e2a\u6bd4\u8d5b\u54112\u4f4d\u9009\u624b\u5404\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a1\u7684\u8fb9\uff0c\u8868\u660e\u6bcf\u4e2a\u6bd4\u8d5b\u53ea\u80fd\u6709\u4e00\u4e2a\u4eba\u8d62\n- \u6700\u540e\u6bcf\u4e2a\u9009\u624b\u5411\u6c47\u70b9\u8fde\u4e00\u6761\u6d41\u91cf\u4e3amid\u7684\u8fb9\uff0c\u5982\u679c\u603b\u6d41\u91cf>=\u6bd4\u8d5b\u6570\uff0c\u90a3\u4e48\u8fd9\u4e2a\u505a\u6cd5\u53ef\u884c\n- \u7b49\u7b49\uff0c\u8981\u8f93\u51fa\u65b9\u6848\uff01\n- \u6bcf\u4e00\u4e2a\u6bd4\u8d5b\u5411\u54ea\u4e00\u4e2a\u9009\u624b\u8fde\u7684\u8fb9\u6d41\u91cf\u662f1\uff0c\u5c31\u4ee3\u8868\u8fd9\u4e2a\u9009\u624b\u8d62\u4e86\n- \u597d\u5427\uff0c\u4e0b\u9762\u5c31\u662f\u6211\u7684code\n\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nconst int p=2e4;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\nint n,m,U[N],V[N],de[N],first[N],cur[N],cnt,dis[N],s,t;\nstruct node{\n\tint v,w,nxt;\n}e[N];\ninline void add(int u,int v,int w){\n   e[++cnt].v=v;e[cnt].w=w;\n   e[cnt].nxt=first[u];first[u]=cnt;\n}\ninline int bfs(){\n\tqueue<int>q;\n\tmemset(dis,-1,sizeof(dis));\n\tdis[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w>0&&dis[v]==-1){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t\tif(v==t) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(int x,int f){\n\tif(x==t||f==0) return f;\n\tint used=0;\n\tfor(int& i=cur[x];i;i=e[i].nxt){\n\t\tif(e[i].w&&dis[e[i].v]==dis[x]+1){\n\t\t\tint w=dfs(e[i].v,min(f,e[i].w));\n\t\t\tif(!w) continue;\n\t\t\tused+=w;\n\t\t\tf-=w;\n\t\t\te[i].w-=w;\n\t\t\te[i^1].w+=w;\n\t\t\tif(f==0) break;\n\t\t}\n\t}\n\tif(!used) dis[x]=-1;\n\treturn used;\n}\ninline int dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tmemcpy(cur,first,sizeof(first));\n\t\tans+=dfs(s,inf);\n\t}\n\treturn ans;\n}//\u7f51\u7edc\u6d41\u677f\u5b50 \ninline int check(int x){\n\tmemset(first,0,sizeof(first));\n\tcnt=1;s=n+p+1,t=s+1;\n\tfor(int i=1;i<=m;i++){\n\t\tadd(s,i,1);add(i,s,0);\n\t\tadd(i,U[i]+p,1);add(U[i]+p,i,0);\n\t\tadd(i,V[i]+p,1);add(V[i]+p,i,0);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tadd(i+p,t,x),add(t,i+p,0);\n\treturn dinic()>=m;\n}//\u672c\u9898\u7684\u91cd\u70b9\uff1a\u5efa\u56fe \ninline int Print(){\n\tfor(int i=0;i<m;i++){\n\t\tif(e[i*6+4].w==0) puts(\"1\");\n\t\telse puts(\"0\");\n\t}\n}//\u6253\u5370\u65b9\u6848 \nint main(){\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++)\n\t\tU[i]=read(),V[i]=read();\n\tint l=m/n,r=m;\n\twhile(l<r){\n\t\tint mid=(l+r)>>1;\n\t\tif(check(mid)) r=mid;\n\t\telse l=mid+1;\n\t}//\u4e8c\u5206 \n\tprintf(\"%d\\n\",l);\n\tcheck(l);\n\tPrint();\n\treturn 0;\n}\n```\n",
        "postTime": 1564972337,
        "uid": 66831,
        "name": "T_Q_X",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "[P3425 [POI2005]KOS-Dicing](https://www.luogu.com.cn/problem/P3425)\n\n\u9898\u610f\u975e\u5e38\u7b80\u5355\uff0c\u3002\n\n\u8003\u8651\u5efa\u56fe\u3002\n\n1\u3001\u6e90\u70b9\u5411\u6bcf\u4e00\u573a\u6bd4\u8d5b\u8fde\u8fb9\uff0c\u8fb9\u6743\u4e3a $ 1 $\uff0c\u8868\u793a\u6bcf\u4e00\u573a\u6bd4\u8d5b\u53ea\u80fd\u6709\u4e00\u4e2a\u4eba\u83b7\u80dc\u3002\n\n2\u3001\u6bcf\u573a\u6bd4\u8d5b\u5411\u5b83\u6240\u5bf9\u5e94\u7684\u4e24\u4e2a\u4eba\u8fde\u8fb9\uff0c\u8fb9\u6743\u4e3a $ 1 $\uff0c\u8868\u793a\u8fd9\u4e2a\u4eba\u83b7\u80dc\u6216\u8005\u8f93\u6389\u3002\n\n3\u3001\u6bcf\u4e2a\u4eba\u5411\u6c47\u70b9\u8fde\u8fb9\u3002\u8fd9\u4e2a\u65f6\u5019\u53d1\u73b0\u8fb9\u6743\u7684\u610f\u4e49\u4e3a\u6bcf\u4e2a\u4eba\u80dc\u5229\u7684\u573a\u6570\uff0c\u4f46\u6211\u4eec\u4e0d\u77e5\u9053\u3002\u4f46\u662f\u601d\u8003\u4e00\u4e0b\uff08\u5176\u5b9e\u4e5f\u662f\u5e38\u89c1\u5957\u8def\uff09\uff0c\u5bb9\u91cf\u8d8a\u5927\u80dc\u573a\u8d8a\u591a\uff0c\u5177\u6709\u5355\u8c03\u6027\u3002\u8003\u8651\u8fdb\u884c\u4e8c\u5206\u7b54\u6848\u5373\u53ef\u3002\u5982\u679c\u603b\u6d41\u91cf $ \\geq $ \u6bd4\u8d5b\u6570\uff0c\u5c31\u5408\u6cd5\uff0c\u7f29\u5c0f\u5bb9\u91cf\u3002\n\nCode\n\n```cpp\n# include <iostream>\n# include <cstdio>\n# include <queue>\n# include <cstring>\n\nusing namespace std;\n\nconst int N = 2e6 + 5;\nconst int M = 1e7 + 5;\nconst int inf = 0x3f3f3f3f;\nint S , T;\n\ntypedef struct {\n\tint x , y , z , next;\n} Edge;\nEdge edge[M];\ntypedef struct {\n\tint xuexsshuan , Kikyo;\n}Yzj;\nYzj match[M];\nint E = 1 , elast[N];\nint n , m;\n\nvoid add(int x , int y , int z) {\n\tE ++;\n\tedge[E].x = x;\n\tedge[E].y = y;\n\tedge[E].z = z;\n\tedge[E].next = elast[x];\n\telast[x] = E;\n}\nint x;\nint dis[N] , cnt[N];\nvoid bfs(int start) {\n\tqueue<int> q;\n\tq.push(start);\n\tdis[start] = 0;\n\tcnt[S] = 1;\n\twhile (!q.empty()) {\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tfor (int i = elast[cur] ; i ; i = edge[i].next) {\n\t\t\tint v = edge[i].y;\n\t\t\tif (dis[v] != -1) continue;\n\t\t\tdis[v] = dis[cur] + 1;\n\t\t\tq.push(v);\n\t\t\tcnt[dis[v]] ++;\n\t\t}\n\t}\n}\nint cur[N];\nint dfs(int u , int flow) {\n\tif (u == T) return flow;\n\tint temp , delta = 0;\n\tfor (int i = cur[u] ; i ; i = edge[i].next) {\n\t\tcur[u] = i;\n\t\tint v = edge[i].y;\n\t\tif (edge[i].z > 0 && dis[u] == dis[v] + 1) {\n\t\t\ttemp = dfs(v , min(flow - delta , edge[i].z));\n\t\t\tedge[i].z -= temp;\n\t\t\tedge[i ^ 1].z += temp;\n\t\t\tdelta += temp;\n\t\t\tif (delta == flow) return delta;\n\t\t}\n\t}\n\tif (dis[S] >= T) return delta;\n\tcur[u] = elast[u];\n\tif (-- cnt[dis[u]] == 0) dis[S] = T;\n\tcnt[++ dis[u]] ++;\n\treturn delta;\n}\nint Isap() {\n\tint ans = 0;\n\tmemset(cnt , 0 , sizeof cnt);\n\tmemset(dis , -1 , sizeof dis);\n\tbfs(T);\n\tfor (int i = 0 ; i <= T ; i ++) {\n\t\tcur[i] = elast[i];\n\t}\n\twhile (dis[S] < T) ans += dfs(S , inf);\n\treturn ans;\n}\nvoid init() {\n\tmemset(elast , 0 , sizeof elast);\n\tE = 1;\n}\nint id[M];\nbool check(int x) {\n\tinit();\n\tfor (int i = 1 ; i <= m ; i ++) {\n\t\tadd(S , i , 1);\n\t\tadd(i , S , 0);\n\t}\n\tfor (int i = 1 ; i <= m ; i ++) {\n\t\tid[i] = E + 1;\n\t\tint attack = match[i].xuexsshuan , suffer = match[i].Kikyo;\n\t\tadd(i , attack + m , 1);\n\t\tadd(attack + m , i , 0);\n\t\tadd(i , suffer + m , 1);\n\t\tadd(suffer + m , i , 0);\n\t}\n\tfor (int i = 1 ; i <= n ; i ++) {\n\t\tadd(i + m , T , x);\n\t\tadd(T , i + m , 0);\n\t}\n\tif (Isap() >= m) return true;\n\telse return false;\n}\nint main() {\n\tcin >> n >> m;\n\tS = 0 , T = n + m + 1;\n\tfor (int i = 1 ; i <= m ; i ++) {\n\t    scanf(\"%d%d\" , &match[i].xuexsshuan , &match[i].Kikyo);\n\t} \n\tint l = m / n , r = m;\n\tint ans = 0;\n\twhile (l <= r) {\n\t\tint mid = l + r >> 1;\n\t\tif (check(mid) == true) r = mid - 1 , ans = mid;\n\t\telse l = mid + 1;\n\t}\n\tprintf(\"%d\\n\" , ans);\n\tcheck(ans);\n\n\tfor (int i = 1 ; i <= m ; i ++) {\n\t\tif (edge[id[i]].z == 0) printf(\"1\\n\");\n\t\telse printf(\"0\\n\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1629269682,
        "uid": 335477,
        "name": "ker_xyxyxyx_xxs",
        "ccfLevel": 0,
        "title": "P3425 [POI2005]KOS-Dicing"
    },
    {
        "content": "### \u4e3a\u4ec0\u4e48\u6240\u6709\u4eba\u505a\u6cd5\u90fd\u548c\u6211\u4e0d\u4e00\u6837\n\n\u4e0d\u4f1a\u753b\u56fe\uff0c\u5168\u51ed\u53e3\u80e1\n\n\u770b\u5230\u8fd9\u9053\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u663e\u7136\u5730\u628a\u5b83\u8f6c\u5316\u4e3a\u4e00\u4e2a\u56fe\u8bba\u6a21\u578b\uff1a\n\n\u7ed9\u4e00\u4e2a\u65e0\u5411\u56fe\u7684\u7684\u6240\u6709\u8fb9\u5b9a\u5411\uff0c\u4ee4\u51fa\u5ea6\u6700\u5927\u7684\u70b9\u51fa\u5ea6\u6700\u5c0f\n\n\u8fd9\u4e2a\u4e1c\u897f\u600e\u4e48\u641e\u5462\uff1f\u6211\u4eec\u53ef\u4ee5\u501f\u9274\u6df7\u5408\u56fe\u5224\u5b9a\u6b27\u62c9\u56de\u8def\u7684\u601d\u60f3\n\n\u663e\u7136\uff0c\u8981\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u8fd8\u662f\u8981**\u4e8c\u5206\u7b54\u6848**\n\n\u7136\u540e\uff0c\u5148\u7ed9\u6bcf\u6761\u8fb9\u968f\u610f\u5b9a\u5411\uff0c\u7edf\u8ba1\u6bcf\u4e2a\u70b9\u7684\u51fa\u5ea6\u3002\u53ef\u4ee5\u53d1\u73b0\uff0c\u53cd\u6094\u5b9e\u9645\u4e0a\u5c31\u662f\u901a\u8fc7\u4e00\u6761\u8fb9\u628a\u4e00\u4e2a\u70b9\u7684\u51fa\u5ea6\u5300\u7ed9\u5176\u4ed6\u70b9\u3002\n\n\u4e8e\u662f\uff0c\u5c31\u6709\u4e86\u5efa\u56fe\u601d\u8def\uff1a\uff08\u4ee4\u4e8c\u5206\u51fa\u7684\u7b54\u6848\u4e3a$x$\uff09\n\n- \u6e90\u70b9\u8fde\u51fa\u5ea6\u5927\u4e8e$x$\u7684\u70b9\uff0c\u6d41\u91cf\u4e3a\u5dee\u503c\n\n- \u51fa\u5ea6\u5c0f\u4e8e$x$\u7684\u70b9\u8fde\u6c47\u70b9\uff0c\u6d41\u91cf\u4e3a\u5dee\u503c\n\n- \u56fe\u4e2d\u539f\u6709\u7684\u8fb9\u6309\u7167\u539f\u65b9\u5411\u8fde\u8fb9\uff0c\u6d41\u91cf\u4e3a$1$\n\n\u5982\u679c\u5de6\u4fa7\u4e0e\u539f\u70b9\u76f8\u8fde\u7684\u8fb9\u5168\u90e8\u6ee1\u6d41\uff0c\u8bf4\u660e\u6240\u6709\u7684\u70b9\u7684\u51fa\u5ea6\u90fd\u63a7\u5236\u5728\u4e86$x$\u4ee5\u4e0b\uff0c$check$\u901a\u8fc7\u3002\n\n\u8f93\u51fa\u65b9\u6848\u7684\u8bdd\uff0c\u770b\u539f\u56fe\u6bcf\u6761\u8fb9\u662f\u5426\u6ee1\u6d41\u3002\u6ee1\u6d41\u5219\u8bf4\u660e\u4e0e\u539f\u5b9a\u5411\u4e0d\u540c\uff0c\u5e76\u4e0d\u96be\u5199\u3002\u7136\u800c\uff0c\u6211dinic\u5c01\u88c5\u4e86\uff0c\u8fb9\u8fd8\u653e\u5728\u4e86private\u91cc\uff0c\u4e8e\u662f\u3002\u3002\u3002\u7b49\u6211\u54ea\u5929\u6709\u65f6\u95f4\u518d\u8865\u8fd9\u4e2a\u5751\u5427QAQ\n\n\u4ee5\u4e0b\u662f\u7b2c\u4e00\u95ee\u4ee3\u7801\n\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf=0x3f3f3f3f;\n\nclass MaxFlow\n{\n    private:\n        struct Edge\n        {\n            int to,nxt,val;\n\n            Edge():nxt(-1){}\n            Edge(int to,int nxt,int val):to(to),nxt(nxt),val(val){}\n\n            ~Edge(){}\n        }e[500010];\n        int head[10010],cnt;\n\n        void addedge(int u,int v,int val)\n        {\n            e[++cnt]=Edge(v,head[u],val);\n            head[u]=cnt;\n        }\n\n        queue<int>q;\n        int dpth[10010];\n        bool bfs(int s,int t)\n        {\n            memset(dpth,0,sizeof(dpth));\n            q.push(s);\n            dpth[s]=1;\n            while(!q.empty())\n            {\n                int now=q.front();\n                q.pop();\n                for(int i=head[now];~i;i=e[i].nxt)\n                {\n                    int vs=e[i].to,valn=e[i].val;\n                    if(dpth[vs]||!valn) continue;\n                    dpth[vs]=dpth[now]+1;\n                    q.push(vs);\n                }\n            }\n            return dpth[t];\n        }\n\n        int dfs(int now,int fl,int t)\n        {\n            if(now==t||fl==0)\n            {\n                return fl;\n            }\n            int res=0;\n            for(int i=head[now];~i;i=e[i].nxt)\n            {\n                int vs=e[i].to;\n                if(dpth[now]!=dpth[vs]-1||!e[i].val) continue;\n                int tmp=dfs(vs,min(fl-res,e[i].val),t);\n                if(!tmp)\n                {\n                    dpth[vs]=0;\n                }\n                res+=tmp;\n                e[i].val-=tmp;\n                e[i^1].val+=tmp;\n                if(res==fl) break;\n            }\n            return res;\n        }\n\n    public:\n        MaxFlow(){}\n\n        ~MaxFlow(){}\n\n        void insedge(int u,int v,int val)\n        {\n            addedge(u,v,val);\n            addedge(v,u,0);\n        }\n\n        int dinic(int s,int t)\n        {\n            int res=0;\n            while(bfs(s,t))\n            {\n                res+=dfs(s,inf,t);\n            }\n            return res;\n        }\n\n        void init()\n        {\n            memset(head,-1,sizeof(head));\n            cnt=-1;\n        }\n}a;\n\nint n,m;\n\nint dgr[10010];\n\nstruct Edge\n{\n    int to,nxt;\n\n    Edge(){}\n    Edge(int to,int nxt):to(to),nxt(nxt){}\n}e[10010];\nint head[10010],cnt;\n\nvoid addedge(int u,int v)\n{\n    e[++cnt]=Edge(v,head[u]);\n    head[u]=cnt;\n}\n\nbool check(long long x)\n{\n    a.init();\n    int s=n+1,t=s+1;\n    int sum=0;\n    for(int i=1;i<=n;i++)\n    {\n        int tmp=dgr[i]-x;\n        if(tmp>0)\n        {\n            a.insedge(s,i,tmp);\n            sum+=tmp;\n        }\n        else if(tmp<0)\n        {\n            a.insedge(i,t,-tmp);\n        }\n        for(int j=head[i];j;j=e[j].nxt)\n        {\n            int vs=e[j].to;\n            a.insedge(i,vs,1);\n        }\n    }\n    int ans=a.dinic(s,t);\n    return ans==sum;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;\n        cin>>u>>v;\n        if(u==v) while(1)cout<<\"fuck!\";\n        if(u>v) swap(u,v);\n        addedge(u,v);\n        dgr[u]++;\n    }\n    long long l=1,r=m;\n    while(l<r)\n    {\n        long long mid=(l+r)>>1;\n        if(check(mid))\n        {\n            r=mid;\n        }\n        else\n        {\n            l=mid+1;\n        }\n    }\n    cout<<l<<'\\n';\n}\n```",
        "postTime": 1547021297,
        "uid": 53241,
        "name": "partychicken",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "\u3010POI\u8865\u5168\u8ba1\u5212#9 POI2005 KOS\u3011\n\n\u601d\u7ef4\u96be\u5ea6\u7b97\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u9898\u4e86\n\n\u4e8c\u5206\u540e\u7528\u7f51\u7edc\u6d41\u5224\u5b9a\n\n\u5efa\u56fe\u52063\u90e8\u5206\n\n1.S->\u4eba\uff0c\u6d41\u91cf\u4e3a\u4e8c\u5206\u7684mid\n\n2.\u4eba->\u6bd4\u8d5b\uff0c\u6d41\u91cf\u4e3a1\uff08\u53ea\u6709\u53c2\u8d5b\u9009\u624b\u9700\u8981\u8fde\u8fb9\uff09\n\n3.\u6bd4\u8d5b->T\uff0c\u6d41\u91cf\u4e3a1\n\n\u8f93\u51fa\u65b9\u6848\u53ea\u9700\u8981\u8bb0\u5f55\u6bcf\u4e00\u573a\u6bd4\u8d5b\u7684\u6ee1\u6d41\u8fb9\u8fde\u5411\u90a3\u4e2a\u4eba\u5c31\u884c\n\n**\u4e0d\u8981\u5fd8\u8bb0\u521d\u59cb\u5316**\n\n\u8d34\u4ee3\u7801\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\nusing namespace std;\nconst int MAXN=20010,inf=0x3f3f3f3f;\nstruct edge\n{\n    int v,f;\n    edge *next,*rev;\n}*h[MAXN],pool[MAXN*5];\nconst int S=20005,T=20006,SHIFT=10000;\nint top;\ninline void addedge(int u,int v,int c)\n{\n    edge *tmp=&pool[++top];tmp->v=v;tmp->f=c;tmp->next=h[u];h[u]=tmp;\n    edge *pmt=&pool[++top];pmt->v=u;pmt->f=0;pmt->next=h[v];h[v]=pmt;\n    tmp->rev=pmt;pmt->rev=tmp;\n}\nint level[MAXN];\nqueue<int> q;\ninline bool mklevel()\n{\n    while(!q.empty())q.pop();\n    memset(level,-1,sizeof(level));\n    level[S]=0;\n    q.push(S);\n    while(!q.empty())\n    {\n        int u=q.front();q.pop();\n        for(edge *tmp=h[u];tmp;tmp=tmp->next)\n        {\n            if(tmp->f&&level[tmp->v]==-1)\n            {\n                level[tmp->v]=level[u]+1;\n                q.push(tmp->v);\n            }\n        }\n        if(level[T]!=-1)return true;\n    }\n    return false;\n}\nint dinic(int u,int minf)\n{\n    if(u==T)return minf;\n    int totf=0,f;\n    for(edge *tmp=h[u];tmp&&totf<minf;tmp=tmp->next)\n    {\n        if(tmp->f&&level[tmp->v]==level[u]+1)\n        {\n            if(minf-totf<tmp->f)f=dinic(tmp->v,minf-totf);\n            else f=dinic(tmp->v,tmp->f);\n            totf+=f;\n            tmp->f-=f;\n            tmp->rev->f+=f;\n        }\n    }\n    if(!totf)level[u]=-1;\n    return totf;\n}\nint n,m,a[MAXN],b[MAXN],ans[MAXN];\ninline void getans()\n{\n    for(int i=1;i<=m;i++)\n    {\n        for(edge *tmp=h[i+SHIFT];tmp;tmp=tmp->next)\n        {\n            if(tmp->v!=T&&tmp->f==1)\n            {\n                if(tmp->v==a[i])ans[i]=1;\n                else ans[i]=0;\n            }\n        }\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    if(!m)\n    {\n        printf(\"0\\n\");\n        return 0;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&a[i],&b[i]);\n    }\n    int l=1,r=10000;\n    while(l<r)\n    {\n        int mid=(l+r)/2;\n        memset(h,0,sizeof(h));\n        top=0;\n        for(int i=1;i<=n;i++)\n        {\n            addedge(S,i,mid);\n        }\n        for(int i=1;i<=m;i++)\n        {\n            addedge(a[i],i+SHIFT,1);\n            addedge(b[i],i+SHIFT,1);\n            addedge(i+SHIFT,T,1);\n        }\n        int totf=0;\n        while(mklevel())totf+=dinic(S,inf);\n        if(totf==m)\n        {\n            getans();\n            r=mid;\n        }\n        else l=mid+1;\n    }\n    printf(\"%d\\n\",l);\n    for(int i=1;i<=m;i++)\n    {\n        printf(\"%d\\n\",ans[i]);\n    }\n    return 0;\n}\n```",
        "postTime": 1505492666,
        "uid": 3346,
        "name": "oscar",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "\u8003\u8651\u4e8c\u5206\u7b54\u6848 $x$\uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u5224\u65ad\u662f\u5426\u5b58\u5728\u65b9\u6848\u4f7f\u5f97\u6240\u6709\u4eba\u8d62\u7684\u6b21\u6570\u90fd\u5c0f\u4e8e $x$\u3002\n\n### \u65b9\u6cd5\u4e00\n\n\u82b1\u91cc\u80e1\u54e8\u505a\u6cd5.jpg\n\n\u53d1\u73b0\u539f\u9898\u76f8\u5f53\u4e8e\u7ed9\u4e00\u4e2a\u65e0\u5411\u56fe\u5b9a\u5411\uff0c\u4f7f\u5f97 $\\forall i,\\text{out}_i\\leq x$\u3002\n\n\u8003\u8651\u94a6\u5b9a\u4e00\u79cd\u5b9a\u5411\u65b9\u6848\u7136\u540e\u8c03\u6574\u3002\u4e3a\u4e86\u65b9\u4fbf\u63a5\u4e0b\u6765\u7684\u8c03\u6574\u64cd\u4f5c\uff0c\u6211\u4eec\u628a\u6761\u4ef6\u8f6c\u5316\u4e3a $\\forall i,f(i)=(\\text{in}_i-\\text{out}_i)-(\\text{deg}_i-2x)\\geq 0$\uff08\u5176\u5b9e\u5c31\u662f\u8003\u8651 $\\text{in}_i-\\text{out}_i$ \u7684\u8303\u56f4\uff0c\u7136\u540e\u79fb\u4e86\u4e2a\u9879\uff09\u3002\u6b64\u65f6\u7ffb\u8f6c\u4e00\u6761\u8fb9 $(u,v)$ \u76f8\u5f53\u4e8e $f(u)\\gets f(u)+2,f(v)\\gets f(v)-2$\u3002\n\n\u6b64\u65f6\u6211\u4eec\u4ee4 $g(i)=f(i)/2$\u3002\u90a3\u4e48\u628a $g(i)\\geq 0$ \u7684\u548c $g(i)<0$ \u7684\u5206\u522b\u62c9\u51fa\u6765\u5206\u6210\u4e24\u7c7b\uff0c\u5efa\u7acb\u5982\u4e0b\u6a21\u578b\uff1a\n\n* $g(i)\\geq 0$\uff0c\u5efa\u8fb9 $(S,i)$\uff0c\u6d41\u91cf $g(i)$\u3002\n* $g(i)<0$\uff0c\u5efa\u8fb9 $(i,T)$\uff0c\u6d41\u91cf $-g(i)$\u3002\n* $(u,v)\\in E$\uff0c\u5efa\u8fb9 $(u,v)$\uff0c\u6d41\u91cf $1$\u3002\n\n\u8bc1\u660e\u5982\u4e0a\u64cd\u4f5c\u7684\u6b63\u786e\u6027\uff1a\u5bf9\u4e8e $S\\to u\\to v\\to T,g(u)\\geq 0,g(v)<0$ \u7684\u8def\u5f84\uff0c\u5408\u6cd5\u6027\u663e\u7136\u3002\u5426\u5219\u5bf9\u4e8e\u540c\u4fa7\u7684\u8fb9\uff0c\u5b83\u6240\u5c5e\u7684\u8c03\u6574\u8def\u5f84\u5fc5\u7136\u8d77\u70b9\u6ee1\u8db3 $g(u)\\geq 0$\uff0c\u7ec8\u70b9\u6ee1\u8db3 $g(v)<0$\uff0c\u5426\u5219\u8fd9\u6b21\u8c03\u6574\u662f\u65e0\u6548\u7684\u3002\n\n### \u65b9\u6cd5\u4e8c\n\n\u4f20\u7edf\u505a\u6cd5\u3002\n\n\u8003\u8651\u5230\u4e00\u6b21\u6bd4\u8d5b\u7684\u7ed3\u679c\u5408\u6cd5\u5f53\u4e14\u4ec5\u5f53\u6070\u597d\u6709\u4e00\u65b9\u7684\u80dc\u8d1f\u6b21\u6570 $+1$\uff0c\u6b64\u65f6\u6bd4\u8d5b\u5411\u53cc\u65b9\u8fde\u8fb9\uff0c\u53cc\u65b9\u5411\u6c47\u70b9\u8fde\u6d41\u91cf\u4e3a $x$ \u8fb9\u3002\u5224\u65ad\u662f\u5426\u6ee1\u6d41\u5219\u5b58\u5728\u5408\u6cd5\u65b9\u6848\u3002\n\n\u4ee3\u7801\uff08\u65b9\u6cd5\u4e00\uff09\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define ldb long double\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\nusing namespace std;\ninline int read() {\n    int x = 0; bool op = 0;\n    char c = getchar();\n    while(!isdigit(c))op |= (c == '-'), c = getchar();\n    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n    return op ? -x : x;\n}\ntemplate<int N> struct MFL {\n  \tconst int INF = 1e9;\n    int n, etot, S, T, head[N], to[N], nxt[N], flow[N];\n    void addedge(int u, int v, int w) { \n        to[++etot] = v; flow[etot] = w; nxt[etot] = head[u]; head[u] = etot;\n    }\n    void add(int u, int v, int w) {\n        addedge(u, v, w); addedge(v, u, 0);\n        return ;\n    }\n    void init(int nn, int ns, int nt) {\n        n = nn; S = ns; T = nt; etot = 1;\n        memset(head, 0, sizeof(head));\n        return ;\n    }\n    int lev[N], cur[N];\n    bool bfs() {\n        for(int i = 0; i <= n; i++)cur[i] = head[i], lev[i] = 0;\n        queue<int> q;\n        q.push(S); lev[S] = 1;\n        while(q.empty() == false) {\n            int u = q.front(); q.pop();\n            for(int i = head[u]; i; i = nxt[i]) {\n                if(lev[to[i]] || flow[i] == 0)continue;\n                lev[to[i]] = lev[u] + 1;\n                if(to[i] == T)return true;\n                q.push(to[i]);\n            }\n        }\n        return false;\n    }\n    int dinic(int u, int fl) {\n        if(u == T)return fl;\n        int rest = fl;\n        for(int i = cur[u]; i && rest; i = nxt[i]) {\n            cur[u] = i;\n            if(lev[to[i]] ^ (lev[u] + 1) || flow[i] == 0)continue;\n            int inc = dinic(to[i], min(flow[i], rest));\n            if(inc == 0)lev[to[i]] = 0;\n            flow[i] -= inc; flow[i ^ 1] += inc; rest -= inc;\n        }\n        return fl - rest;\n    }\n    int query() {\n        int mxfl = 0, fl = 0;\n        while(bfs()) {\n            while(fl = dinic(S, INF))mxfl += fl;\n        }\n        return mxfl;\n    }\n};\nconst int N = 1e6 + 10;\nMFL<N> mf;\nint n, m;\nint deg[N], in[N], out[N], val[N];\nstruct Node {\n    int u, v;\n    Node() {}\n    Node(int u, int v):u(u), v(v) {}\n}e[N];\nbool check(int x) {\n    mf.init(n + 1, 0, n + 1);\n    int sum = 0;\n    for(int i = 1; i <= m; i++) {\n        int u = e[i].u, v = e[i].v;\n        mf.add(v, u, 1);\n    }\n    for(int i = 1; i <= n; i++) {\n        int val = ((in[i] - out[i]) - (deg[i] - 2 * x)) / 2;\n        if(val < 0)mf.add(i, mf.T, -val), sum += -val;\n        else mf.add(mf.S, i, val);\n    }\n    if(mf.query() < sum)return false;\n    for(int i = 1; i <= m; i++) {\n        val[i] = mf.flow[i << 1]; \n    }\n    return true;\n}\nint main() {\n    n = read(); m = read();\n    for(int i = 1; i <= m; i++) {\n        int u = read(), v = read();\n        e[i] = Node(u, v); \n        deg[u]++; deg[v]++; in[v]++; out[u]++;\n    }\n    int lef = 0, rig = m + 1;\n    while(lef + 1 < rig) {\n        int mid = lef + rig >> 1;\n        // printf(\"%d %d\\n\", lef, rig); \n        if(check(mid))rig = mid;\n        else lef = mid;\n    }\n    // printf(\"chk:%d\\n\", check(1));\n    printf(\"%d\\n\", rig);\n    for(int i = 1; i <= m; i++)printf(\"%d\\n\", val[i]);\n    return 0;\n}\n```\n\n\n",
        "postTime": 1649472394,
        "uid": 682934,
        "name": "yllcm",
        "ccfLevel": 0,
        "title": "Solution-P3425"
    },
    {
        "content": "### P.S.\n\u8349\uff0c\u8fd9\u79cd\u65e0\u540d\u9898\u662f\u6211 2k AC\u3002  \n\u597d\u4e0d\u7518\u5fc3\u3002\u3002\u3002/kel  \n\u4e0d\u8fc7\u8fd8\u662f\u7eaa\u5ff5\u4e00\u4e0b\u5427\u3002\u3002\u3002  \n### Description.\n\u7ed9\u5b9a\u4e00\u5f20\u65e0\u5411\u56fe\uff0c\u7ed9\u5176\u5b9a\u5411\u3002  \n\u73b0\u5728\u8981\u6c42\u6700\u4f18\u65b9\u6848\uff0c\u4f7f\u6bcf\u4e2a\u70b9\u6700\u5927\u5165\u5ea6\u6700\u5c0f\uff0c\u5e76\u8f93\u51fa\u65b9\u6848\u3002  \n### Solution.\n\u6700\u5927\u503c\u6700\u5c0f\u95ee\u9898\u76f4\u63a5\u4e8c\u5206\u8f6c\u5224\u5b9a\uff0c\u73b0\u5728\u6bcf\u4e2a\u70b9\u5165\u5ea6\u6709\u9650\u5236\u3002  \n\u6bcf\u6761\u8fb9\u80fd\u4e14\u4ec5\u80fd\u8d21\u732e\u4e00\u4e2a\u5165\u5ea6\u3002  \n\u6240\u4ee5\u76f4\u63a5\u5bf9\u5165\u5ea6\u6765\u8ba8\u8bba\u3002  \n\u76f4\u63a5\u5bf9\u6bcf\u6761\u8fb9\u5411\u4e24\u4e2a\u9876\u8fde\u8fb9\uff0c\u5bb9\u91cf\u968f\u610f\uff08\u4e0d\u662f0\u5c31\u884c\u3002  \n\u518d\u4ece\u6e90\u70b9\u5411\u6bcf\u6761\u8fb9\u8fde\u8fb9\u5bb9\u91cf\u4e3a1\uff0c\u6bcf\u4e2a\u70b9\u5411\u6c47\u70b9\u8fde\u8fb9\u5bb9\u91cf\u4e3a\u9650\u5236\u3002  \n\u76f4\u63a5dinic\u5224\u6bcf\u6761\u8fb9\u7684\u5bb9\u91cf\u662f\u5426\u5168\u90fd\u80fd\u8d21\u732e\u6389\u3002  \n\u8f93\u51fa\u7684\u8bdd\u76f4\u63a5\u770b\u6bcf\u8fb9\u5165\u5ea6\u8d21\u732e\u7ed9\u8c01\u4e86\u5c31\u597d\u4e86\u3002  \n~~\u521a\u5f00\u59cb\u7a7a\u95f4\u5f00\u5c0f\u4e86\u76f4\u63a5TLE\u7136\u540e\u8c03\u81ea\u95ed~~  \n\u5b8c\u7ed3\u6492\u82b1\n### Coding.\n```cpp\nint n,m,X[100005],Y[100005];\ninline char check(int x)\n{\n\tmemset(head,0,sizeof(head)),et=0;\n\tfor(int i=1;i<=m;i++) adde(s,i,1),adde(i,X[i]+m,1),adde(i,Y[i]+m,1);\n\tfor(int i=1;i<=n;i++) adde(i+m,t,x);\n\treturn dinic(s,t)==m;\n}\ninline void paint()\n{\n\tfor(int x=1;x<=m;x++) for(int i=head[x];i;i=e[i].nxt) if(!e[i].w) printf(\"%d\\n\",X[x]==e[i].to-m);\n}\nint main()\n{\n\tread(n),read(m),s=n+m+1,t=s+1;for(int i=1;i<=m;i++) read(X[i]),read(Y[i]);\n\tint le=0,ri=n,md,rs=n;while(le<=ri) {md=(le+ri)>>1;if(check(md)) ri=md-1,rs=md;else le=md+1;}\n\treturn check(rs),printf(\"%d\\n\",rs),paint(),0;\n}\n```\n",
        "postTime": 1609660725,
        "uid": 44805,
        "name": "Leap_Frog",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "## \u4e3a\u4ec0\u4e48\u7f51\u7edc\u6d41\u8981\u4e8c\u5206\uff01\uff01\uff01\n\u6b8b\u91cf\u7f51\u7edc\u4e07\u5c81\uff01\uff01\uff01  \n\u6211\u4eec\u5927\u5927\u53ef\u4ee5\u4ece1\u5230m\u679a\u4e3e\u7b54\u6848\uff0c\u6bcf\u6b21\u5c06\u6240\u6709\u8fde\u5411t\u7684\u8fb9\u6d41\u91cf\u52a01  \n\u6839\u636e\u6b8b\u91cf\u7f51\u7edc\u590d\u6742\u5ea6\u4e8b\u5b9e\u4e0a\u53ea\u8dd1\u4e86\u4e00\u6b21\u7f51\u7edc\u6d41  \n\u73b0\u5728\u53ea\u9700\u8981\u5efa\u56fe\u4e86  \ns\u5411\u6bcf\u573a\u6bd4\u8d5b\u8fde\u6761\u6d41\u91cf\u4e3a1\u7684\u8fb9\uff0c\u8868\u793a\u6bcf\u573a\u6bd4\u8d5b\u53ea\u6709\u4e00\u4e2a\u4eba\u80fd\u8d62  \n\u6bcf\u573a\u6bd4\u8d5b\u5411\u53c2\u8d5b\u8005\u8fde\u8fb9\u3002  \n\u6bcf\u4eba\u5411t \u8fde\u8fb9\uff0c\u7136\u540e\u50cf\u524d\u9762\u90a3\u6837\u52a8\u6001\u66f4\u65b0\u6d41\u91cf\u5373\u53ef  \n\u6bcf\u6b21\u770b\u6700\u5927\u6d41\u662f\u5426\u7b49\u4e8em\uff08\u5373\u90fd\u51b3\u51fa\u80dc\u8d1f\uff09\nCode:\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5;\ninline int rd(){\n\tint x=0,fl=1;char ch=getchar();\n\tfor(;ch>'9'||ch<'0';ch=getchar())fl=(ch=='-'?-1:1);\n\tfor(;ch>='0'&&ch<='9';ch=getchar())x=(x<<1)+(x<<3)+(ch^48);\n\treturn x*fl;\n}\nint fi[N],ne[N],to[N],w[N],tot=1;\nvoid add(int x,int y,int z){ne[++tot]=fi[x];to[tot]=y;w[tot]=z;fi[x]=tot;}\nvoid ad(int x,int y,int z){add(x,y,z);add(y,x,0);}\nint n,m,dis[N],s,t,mf,pre[N];\nbool bfs(){\n\tfor(int i=1;i<=t;i++)\n\t\tdis[i]=-1;\n\tdis[s]=1;\n\tqueue<int>q;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=fi[x];i;i=ne[i]){\n\t\t\tif(!w[i]||dis[to[i]]!=-1)continue;\n\t\t\tdis[to[i]]=dis[x]+1;\n\t\t\tif(to[i]==t)return true;\n\t\t\tq.push(to[i]);\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x,int fl){\n\tif(x==t||!fl)return fl;\n\tint u,ans=0;\n\tfor(int i=fi[x];i;i=ne[i]){\n\t\tif(!w[i]||dis[to[i]]!=dis[x]+1)continue;\n\t\tu=dfs(to[i],min(w[i],fl));\n\t\tw[i]-=u;w[i^1]+=u;fl-=u;ans+=u;\n\t\tif(!fl)break;\n\t}\n\tif(!ans||fl)dis[x]=-1;\n\treturn ans;\n}\nint dinic(){\n\tint mxf=0,x;\n\twhile(bfs())\n\t\twhile(x=dfs(s,INT_MAX))\n\t\t\tmxf+=x;\n\treturn mxf;\n}//\u7f51\u7edc\u6d41\u677f\u5b50\nint main(){\n\tn=rd();m=rd();\n\ts=n+m+1;t=s+1;\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;\n\t\tx=rd();y=rd();\n\t\tad(s,i,1);\n\t\tad(i,x+m,1);\n\t\tad(i,y+m,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tpre[i]=tot+1,ad(i+m,t,1);//\u5efa\u56fe\uff0c\u5b58\u8fde\u5411t\u7684\u8fb9\n\tfor(int k=1;k<=m;k++){\n\t\tmf+=dinic();\n\t\tif(mf==m){\n\t\t\tprintf(\"%d\\n\",k);\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tw[pre[i]]++;//\u66f4\u65b0\u6d41\u91cf\n\t}\n\tfor(int i=1;i<=m;i++)\n\t\tprintf(\"%d\\n\",w[fi[i]]);//fi[i]\u662f\u8fde\u5411y\u7684\u8fb9\n\treturn 0;\n}\n```\n",
        "postTime": 1564971188,
        "uid": 103990,
        "name": "asd_a",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "### \u8fd9\u662f\u4e00\u9053\u6700\u5927\u6d41\u52a0\u4e8c\u5206\u7684\u597d\u9898\n#### \u4e3a\u4e86\u826f\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\uff0c\u53ef\u4ee5\u8bbf\u95eehttps://www.cnblogs.com/wenci/p/10122656.html\u8fdb\u884c\u67e5\u770b\n#### \u9898\u9762\u8bf4\u8d62\u7684\u6700\u591a\u7684\u4eba\u6700\u5c11\u8d62\u51e0\u573a\uff0c\u80af\u5b9a\u662f\u5411\u4e8c\u5206\u7684\u65b9\u5411\u601d\u8003\n\n#### \u5efa\u7acb\u6e90\u70b9\u5411\u6bcf\u4e00\u573a\u6bd4\u8d5b\u8fde\u5bb9\u91cf\u4e3a1\u7684\u8fb9\uff0c\u4ece\u6bcf\u573a\u6bd4\u8d5b\u5411\u53c2\u8d5b\u4e24\u4e2a\u4eba\u5404\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a1\u7684\u8fb9\uff0c\u8868\u793a\u4e00\u573a\u6bd4\u8d5b\u6709\u4e00\u4e2a\u4eba\u8d62\n\n#### \u4e8c\u5206\u4e00\u4e2a\u6700\u591a\u7684\u4eba\u8d62\u7684\u573a\u6570\uff0c\u4ece\u6bcf\u4e2a\u4eba\u5411\u6c47\u70b9\u8fde\u5bb9\u91cf\u4e3amid\u7684\u8fb9\uff0c\u82e5\u6700\u5927\u6d41\u7b49\u4e8e\u573a\u6570\uff0c\u8bf4\u660e\u7b26\u5408\u9898\u610f\uff0c\u53ef\u4ee5\u51cf\u5c0f\u6700\u591a\u7684\u4eba\u8d62\u7684\u573a\u6570\uff0c\u53cd\u4e4b\u7f29\u5c0f\n\n#### \u56e0\u4e3a\u8981\u8f93\u51fa\u65b9\u6848\uff0c\u53ef\u4ee5\u8bb0\u5f55\u4e0b\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5c0f\u7b54\u6848\uff0c\u7136\u540e\u4ee5\u8fd9\u4e2a\u7b54\u6848\u518d\u8dd1\u4e00\u6b21\uff0c\u4ece\u6bd4\u8d5b\u6d41\u5411\u4e2a\u4eba\u7684\u8fb9\u5982\u679c\u5bb9\u91cf\u4e3a0\uff08\u4e5f\u5c31\u662f\u5728\u589e\u5e7f\u65f6\u88ab\u6d41\u8fc7\u4e86\uff09\u8bf4\u660e\u4ed6\u8d62\u4e86\u8fd9\u573a\u6bd4\u8d5b\n```cpp\n#include<bits/stdc++.h>\n#include<queue>\nusing namespace std;\n#define INF 0x3f3f3f3f\ninline int read(){\n    int w=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){\n        if(ch=='-') f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        w=(w<<3)+(w<<1)+ch-48;\n        ch=getchar();\n    }\n    return w*f;\n}\nint n,m,cnt=-1,head[100010],cur[100010],depth[100010],S,T,u[100010],v[100010],ans,x[100010],y[100010];\nconst int p=10000;\nbool vis[100010];\nstruct Edge{\n    int from,to,next,flow;\n}edge[1000010];\ninline void addedge(int u,int v,int w){\n    cnt++;\n    edge[cnt].from=u;\n    edge[cnt].to=v;\n    edge[cnt].flow=w;\n    edge[cnt].next=head[u];\n    head[u]=cnt;\n}\ninline void ins(int u,int v,int w){\n    addedge(u,v,w);addedge(v,u,0);\n}\nqueue<int> q;\ninline bool bfs(int st,int ed){\n    memset(depth,0,sizeof(depth));\n    int u,v,i,j,k;q.push(st);depth[st]=1;\n    for(i=S;i<=T;i++)cur[i]=head[i]; \n    while(!q.empty()){\n        u=q.front();q.pop();\n        for(i=head[u];i!=-1;i=edge[i].next){\n            v=edge[i].to;\n            if(!depth[v]&&edge[i].flow){\n                depth[v]=depth[u]+1;q.push(v);\n            }\n        }\n    }\n    return depth[ed];\n}\ninline int dfs(int u,int ed,int limit){\n    if(!limit||u==ed) return limit;\n    int v,i,j,k;int flow=0,f;\n    for(i=cur[u];i!=-1;i=edge[i].next){\n        v=edge[i].to;cur[u]=i;\n        if(depth[v]==depth[u]+1&&(f=dfs(v,ed,min(limit,edge[i].flow)))){\n            limit-=f;flow+=f;\n            edge[i].flow-=f;edge[i^1].flow+=f;\n            if(!limit) break;\n        }\n    }\n    return flow;\n}\ninline void Dinic(){\n    while(bfs(S,T)){\n        ans+=dfs(S,T,INF);\n    }\n}\ninline bool check(int mid){\n    cnt=-1;memset(head,-1,sizeof(head));\n    int i,j,k;\n    for(i=1;i<=m;i++){\n        ins(S,i,1);\n        ins(i,x[i]+p,1);\n        ins(i,y[i]+p,1);\n    }\n    for(i=1;i<=n;i++){\n        ins(i+p,T,mid);\n    }\n    ans=0;Dinic();\n    return ans==m;\n}\nint main(){\n    n=read();m=read();int i,j,k;int ans1;\n    memset(head,-1,sizeof(head));S=0;T=99999;\n    for(i=1;i<=m;i++){\n        x[i]=read();y[i]=read();\n    }\n    int l=0,r=m+1;\n    while(l<=r){\n        int mid=(l+r)>>1;\n        if(check(mid)) r=mid-1,ans1=mid;\n        else l=mid+1;\n    }\n    cout<<ans1<<endl;\n    check(ans1);\n    for(int u=1;u<=m;u++){\n        for(i=head[u];i!=-1;i=edge[i].next){\n            int v=edge[i].to;v-=p;if(v<1 or edge[i].flow) continue;\n            if(v==x[u]) vis[u]=true;\n        }\n    }\n    for(i=1;i<=m;i++){\n        printf(\"%d\\n\",vis[i]);\n    }\n    return 0;\n}\n```",
        "postTime": 1544841042,
        "uid": 106035,
        "name": "\u6e29\u8bcd",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3425 \u3010[POI2005]KOS-Dicing\u3011"
    },
    {
        "content": "\u7f51\u7edc\u6d41\u795e\u9898\uff01\n\n\u9996\u5148\u7406\u89e3\u9898\u610f\u662f\u7b2c\u4e00\u8981\u4e49\uff0c\u5b9e\u5728\u4e0d\u884c\u5c31\u770b\u4e00\u4e0b\u535a\u5ba2\u91cc\u90a3\u4e9bBZOJ\u7684\u9898\u9762\u5c31\u53ef\u4ee5\u3002\n\n\u7136\u540e\u8bf4\u4e00\u4e0b\u8f93\u51fa\u65b9\u6848\u7684\u610f\u601d\uff1a\u5bf9\u4e8e\u6bcf\u573a\u6bd4\u8d5b\u7684a\uff0cb\u9009\u624b\uff0c\u5982\u679ca\u8981\u8d62b\uff0c\u90a3\u4e48\u8fd9\u573a\u6bd4\u8d5b\u8f93\u51fa1\uff0c\u5426\u5219\u8f93\u51fa0.\n\n\u5efa\u56fe\u6bd4\u8f83\u6b63\u5e38\uff0c\u6bd4\u8f83\u5bb9\u6613\u60f3\u7684\u662f\u4e8c\u5206\u6c42\u89e3\u3002\u9996\u5148\u6211\u4eec\u4ece\u8d85\u7ea7\u6c47\u5411\u6240\u6709\u6bd4\u8d5b\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a1\u7684\u8fb9\uff0c\u7136\u540e\u4ece\u6bcf\u4e2a\u6bd4\u8d5b\u5411\u5b83\u6240\u5305\u542b\u7684\u4e24\u4e2a\u9009\u624b\u8fde\u6d41\u91cf\u4e3a1\u7684\u8fb9\u3002\u6700\u540e\u6211\u4eec\u628a\u6bcf\u4e2a\u9009\u624b\u5411\u8d85\u7ea7\u6c47\u8fde\u8fb9\uff0c\u6d41\u91cf\u5c31\u662f\u4f60\u4e8c\u5206\u7684\u90a3\u4e2a\u503c\u3002\u7136\u540e\u5224\u65ad\u6700\u5927\u6d41\u662f\u5426\u662f\u6bd4\u8d5b\u603b\u573a\u6570m\u3002\n\n\u597d\u4e86\uff0c\u7136\u540e\u662f\u8f93\u51fa\u65b9\u6848\u7684\u95ee\u9898\uff0c\u8fd9\u4e2a\u90e8\u5206\u6309\u7167\u60ef\u4f8b\u6709\u5f88\u591a\u65b9\u6cd5\uff0c\u90a3\u4e48\u6211\u4eec\u73b0\u5728\u63a8\u51fa\u6700\u7b80\u5355\u7684\u66b4\u529b\u679a\u4e3e\u3002\u6bcf\u6b21\u6211\u4eec\u7f29\u5c0f\u4e8c\u5206\u4e0a\u754c\u65f6\uff0c\u6211\u4eec\u90fd\u662f\u627e\u51fa\u4e86\u4e00\u79cd\u53ef\u884c\u89e3\uff0c\u6240\u4ee5\u66b4\u529b\u679a\u4e3e\u6240\u6709\u6bd4\u8d5b\uff0c\u5224\u65ad\u4e00\u4e0b\u5b83\u7684\u5bf9\u90a3\u4e2a\u9009\u624b\u6ee1\u6d41\u5373\u53ef\u3002\n\n\u4e3a\u4ec0\u4e48\u4e0d\u80fd\u5728\u6700\u540e\u9762\u6c42\u5f97\u987a\u5e8f\uff1f\u4f60\u5728\u4e8c\u5206\u7684\u65f6\u5019\uff0c\u9000\u51fa\u4e8c\u5206\u7684\u6761\u4ef6\u5c31\u662f\u4f60\u7684dinic\u8dd1\u4e0d\u51fa\u6765\u671f\u671b\u7684\u6700\u5927\u6d41\u4e86\uff0c\u8fd9\u4e2a\u65f6\u5019\u6bcf\u573a\u6bd4\u8d5b\u7684\u7ed3\u679c\u4e5f\u548c\u521a\u624d\u4f60\u6c42\u51fa\u6765\u7684\u65f6\u5019\u4e0d\u4e00\u6837\u4e86\uff0c\u6240\u4ee5\u5fc5\u987b\u5728\u4e8c\u5206\u5185\u90e8\u6c42\u51fa\u3002\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#define re register\n#define inf 400000000\nusing namespace std;\nint n,s,q,dis[2000011],t,l,cur[200051];\nstruct po\n{\n    int nxt,to,w;\n}edge[3000021];\nint head[40151],tot,dep[40051],map[20005][2],id,d,num=-1,ct[20001];\nint x,y,m;\ninline int read()\n{\n    int x=0,c=1;\n    char ch=' ';\n    while((ch>'9'||ch<'0')&&ch!='-')ch=getchar();\n    while(ch=='-')c*=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-'0',ch=getchar();\n    return x*c;\n}\ninline void add_edge(int from,int to,int w)\n{\n    edge[++num].nxt=head[from];\n    edge[num].to=to;\n    edge[num].w=w;\n    head[from]=num;\n}\ninline void add(int from,int to,int w)\n{\n    add_edge(from,to,w);\n    add_edge(to,from,0);\n}\ninline bool bfs()\n{\n    memset(dep,0,sizeof(dep));\n    queue<int> q;\n    while(!q.empty())\n    q.pop();\n    q.push(s);\n    dep[s]=1;\n    while(!q.empty())\n    {\n        int u=q.front();\n        q.pop();\n        for(re int i=head[u];i!=-1;i=edge[i].nxt)\n        {\n            int v=edge[i].to;\n            if(dep[v]==0&&edge[i].w>0)\n            {\n                dep[v]=dep[u]+1;\n                if(v==t)\n                return 1;\n                q.push(v);\n            }\n        }\n    }\n    return 0;\n}\ninline int dfs(int u,int dis)\n{\n    if(u==t)\n    return dis;\n    int diss=0;\n    for(re int& i=cur[u];i!=-1;i=edge[i].nxt)\n    {\n        int v=edge[i].to;\n        if(edge[i].w!=0&&dep[v]==dep[u]+1)\n        {\n            int check=dfs(v,min(dis,edge[i].w));\n            if(check>0)\n            {\n                dis-=check;\n                diss+=check;\n                edge[i].w-=check;\n                edge[i^1].w+=check;\n                if(dis==0)\n                break;\n            }\n        }\n    }\n    return diss;\n}\ninline int dinic()\n{\n    int ans=0;\n    while(bfs())\n    {\n        for(re int i=0;i<=t;i++)\n        cur[i]=head[i];\n        while(int d=dfs(s,inf))\n        ans+=d;\n    }\n    return ans;\n}\ninline void build(int x)\n{\n\tnum=-1;\n\tmemset(head,-1,sizeof(head));\n\tfor(re int i=1;i<=m;i++){\n\t\tadd(s,i,1),add(i,map[i][0],1),add(i,map[i][1],1);\n\t}\n\tfor(re int i=m+1;i<=m+n;i++)\n\tadd(i,t,x);\n}\nint main()\n{\n\tn=read();m=read();\n\ts=0;t=n+m+1;\n\tfor(re int i=1;i<=m;i++){\n\t\tmap[i][0]=read()+m;map[i][1]=read()+m;\n\t}\n\tint l=0,r=m;\n\twhile(l<=r){\n\t\tint mid=l+r>>1;\n\t\tbuild(mid);\n\t\tif(dinic()==m) {\n\t\t\tint winner=0;\n\t\t\tfor(re int i=1;i<=m;i++)\n\t\t\t{\n\t\t\t\t\tfor(re int j=head[i];j!=-1;j=edge[j].nxt){\n\t\t\t\t\tint v=edge[j].to;\n\t\t\t\t\tif(v!=t&&edge[j^1].w==1)\n\t\t\t\t\tif(v==map[i][0])\n\t\t\t\t\tct[i]=1; else ct[i]=0;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tr=mid-1;\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tl=mid+1;\n\t\t}\n\t}\n\tcout<<l<<endl;\n\t\n\t\n\tfor(re int i=1;i<=m;i++)\n\tcout<<ct[i]<<endl;\n}\n```",
        "postTime": 1520075626,
        "uid": 49223,
        "name": "Victorique",
        "ccfLevel": 0,
        "title": "\u3010P3425\u3011KOI\u2014dicing"
    }
]