[
    {
        "content": "\n\u65e2\u7136\u6ca1\u6709\u9898\u89e3\u90a3\u6211\u5c31\u53d1\u4e00\u7bc7\u5427\n\n\n\u8fd9\u9898\u662f\u4e09\u9053\u9898\u7684\u7ed3\u5408\u4f53\uff1a[CF464E The Classic Problem](https://www.luogu.com.cn/problem/CF464E)\u3001[\u6d1b\u8c37 P4178 Tree](https://www.luogu.com.cn/problem/P4178)\u3001[S2oj 55. \u5c0f\u8288](https://sjzezoj.com/problem/55)\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u7531\u4e8e\u56fe\u4e2d\u53ea\u6709 $n-1$ \u6761\u8fb9\uff0c\u82e5\u8fb9\u6743\u4e3a $n^z$ \uff0c\u76f8\u52a0\u65f6\u662f\u4e0d\u4f1a\u53d1\u751f\u8fdb\u4f4d\u7684\u3002\n\n\u56e0\u6b64\u6211\u4eec\u6bd4\u8f83\u4e24\u6761\u8def\u5f84\u65f6\uff0c\u53ea\u9700\u4f9d\u6b21\u6bd4\u8f83\u6bcf\u4e2a\u6570\u5b57\u51fa\u73b0\u7684\u4e2a\u6570\u5373\u53ef\u3002\n\n\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u54c8\u5e0c\u503c\uff0c\u628a\u5355\u6b21\u6bd4\u8f83\u7684\u590d\u6742\u5ea6\u4f18\u5316\u5230 $O(\\log n)$\u3002\n\n\u8003\u8651\u4e8c\u5206\u7b54\u6848\u3002\n\n\u6211\u4eec\u5148\u8fdb\u884c\u4e00\u6b21\u8fb9\u5206\u6cbb\uff0c\u9884\u5904\u7406\u51fa\u6240\u6709\u7684\u201c\u534a\u6761\u8def\u5f84\u201d\uff0c\u7136\u540e\u6392\u5e8f\u3002\n\n\u8fd9\u6837\u4e00\u6765\uff0c\u5bf9\u4e8e\u5de6\u8fb9\u7684\u4e00\u6761\u8def\u5f84\uff0c\u53f3\u8fb9\u548c\u5b83\u76f8\u52a0\u540e\u6743\u503c\u5728\u5f53\u524d\u533a\u95f4\u5185\u7684\u8def\u5f84\u4f1a\u5728\u4e00\u4e2a\u533a\u95f4\u5185\u3002\n\n\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u5de6\u8fb9\u7684\u8def\u5f84\u7ef4\u62a4\u53ef\u4ee5\u548c\u5b83\u5339\u914d\u7684\u53f3\u8def\u5f84\u7684\u533a\u95f4\uff0c\u4e0d\u5fc5\u7ef4\u62a4\u6240\u6709\u7684\u8def\u5f84\u5bf9\uff0c\u5e76\u4e14\u53ef\u4ee5\u53cc\u6307\u9488\u5728 $O(n\\log^2n)$ \uff08\u542b $O(\\log n)$ \u7684\u6bd4\u8f83\u548c $O(\\log\\ n)$ \u7684\u8fb9\u5206\u6cbb\uff09\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u7b97\u51fa\u4e00\u6761\u8def\u5f84\u5728\u5f53\u524d\u8def\u5f84\u96c6\u5408\u4e2d\u7684\u6392\u540d\u3002\n\n\u8003\u8651\u5230\u8fb9\u6743\u5f88\u5927\uff0c\u800c\u8def\u5f84\u53ea\u6709 $n^2$ \u6761\uff0c\u6211\u4eec\u53ef\u4ee5\u53bb\u4e8c\u5206\u8def\u5f84\u3002\n\n\u7531\u4e8e\u6211\u4eec\u4e0d\u597d\u76f4\u63a5\u627e\u51fa\u5f53\u524d\u8def\u5f84\u96c6\u5408\u7684\u4e2d\u4f4d\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u968f\u673a\u9009\u51fa\u4e00\u6761\u8def\u5f84\u6765\u5f53\u4f5c\u4e2d\u4f4d\u6570\u3002\n\n\u56e0\u4e3a\u4e0d\u540c\u8def\u5f84\u7684\u957f\u5ea6\u6709\u53ef\u80fd\u76f8\u540c\uff0c\u6211\u4eec\u4e0d\u80fd\u7b49\u96c6\u5408\u5927\u5c0f\u4e3a 1 \u4e86\u518d\u505c\u6b62\u4e8c\u5206\uff0c\u6211\u4eec\u53ef\u4ee5\u4eba\u4e3a\u8bbe\u5b9a\u4e00\u4e2a\u4e8c\u5206\u6b21\u6570\uff0c50~60 \u6700\u597d\u3002 \n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^3n)$\n\n**code\uff1a**\n\n\u76ee\u524d\u540c\u65f6\u662f\u6d1b\u8c37\u548c LOJ \u7684 rank1\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,lim;long long k;\nvector<int> rt1[400005],rt2[400005];\nnamespace Main{\n\tint le[10000005],ri[10000005],siz[10000005],cnt;\n\tunsigned long long tree[10000005],val[100005];\n\tint insert(int loc,int y,int l=1,int r=n){\n\t\tif(loc<l||loc>r)return y;\n\t\tint i=++cnt;tree[i]=tree[y]+val[loc];siz[i]=siz[y]+1;\n\t\tif(l!=r){\n\t    \tint mid=(l+r)>>1;\n    \t\tle[i]=insert(loc,le[y],l,mid);ri[i]=insert(loc,ri[y],mid+1,r);\n \t\t}\n\t\treturn i;\n\t}\n\tinline bool cmp(int a,int b,int c,int d){\n\t\tint l=1,r=n;\n\t\twhile(l!=r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(tree[ri[a]]+tree[ri[b]]!=tree[ri[c]]+tree[ri[d]]){\n\t\t\t\tl=mid+1;\n\t\t\t\ta=ri[a];b=ri[b];c=ri[c];d=ri[d];\n\t\t\t}else {\n\t\t\t\tr=mid;\n\t\t\t\ta=le[a];b=le[b];c=le[c];d=le[d];\n\t\t\t}\n\t\t}\n\t\treturn siz[a]+siz[b]<siz[c]+siz[d];\n\t}\n\tinline bool ccmp(int x,int y){\n\t\treturn cmp(x,0,y,0);\n\t}\n\tvector<int> L[400005],R[400005],pos[400005];\n\tstruct node{\n\t\tint x,y;\n\t\tnode(int _x,int _y){\n\t\t\tx=_x;y=_y;\n\t\t}\n\t\tinline bool operator <(const node &b)const{\n\t\t\treturn cmp(x,y,b.x,b.y);\n\t\t}\n\t};\n\tlong long ans,base=1;\n\tconst long long md=1e9+7;\n\tvoid Get(int x,int y,int l=1,int r=n){\n\t\tif(l==r){\n\t\t\tbase=base*n%md;ans=(ans+(siz[x]+siz[y])*base)%md;\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tGet(le[x],le[y],l,mid);Get(ri[x],ri[y],mid+1,r);\n\t}\n\tinline void main(){\n\t\tlong long all=0;\n\t\tfor(int i=1;i<=lim;i++){\n\t\t\tL[i].resize(rt1[i].size());R[i].resize(rt1[i].size());pos[i].resize(rt1[i].size());\n\t\t\tfor(auto &it:R[i])it=rt2[i].size()-1;all+=1ll*rt1[i].size()*rt2[i].size();\n\t\t}\n\t\tnode mid(0,0);\n\t\tfor(int t=1;t<=60;t++){\n\t\t\tlong long rk=abs(1ll*rand()*rand()+rand())%all+1;\n\t\t\tfor(int i=1;rk&&i<=lim;i++){\n\t\t\t\tfor(int j=0;j<rt1[i].size();j++){\n\t\t\t\t\tint tmp=R[i][j]-L[i][j]+1;\n\t\t\t\t\tif(tmp>=rk){\n\t\t\t\t\t\tmid=node(rt1[i][j],rt2[i][L[i][j]+rk-1]);\n\t\t\t\t\t\trk=0;break;\n\t\t\t\t\t}else rk-=tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long tmp=0;\n\t\t\tfor(int i=1;i<=lim;i++){\n\t\t\t\tint r=rt2[i].size()-1;\n\t\t\t\tfor(int j=0;j<rt1[i].size();j++){\n\t\t\t\t\tr=min(r,R[i][j]);\n\t\t\t\t\twhile(r>=L[i][j]&&mid<node(rt1[i][j],rt2[i][r]))r--;\n\t\t\t\t\tpos[i][j]=r;tmp+=r-L[i][j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(k==tmp)break;\n\t\t\telse if(k<tmp){\n\t\t\t\tall=tmp;\n\t\t\t\tfor(int i=1;i<=lim;i++){\n\t\t\t\t\tfor(int j=0;j<rt1[i].size();j++)R[i][j]=pos[i][j];\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tk-=tmp;all-=tmp;\n\t\t\t\tfor(int i=1;i<=lim;i++){\n\t\t\t\t\tfor(int j=0;j<rt1[i].size();j++)L[i][j]=pos[i][j]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tGet(mid.x,mid.y);\n\t\tprintf(\"%lld\",ans);\n\t}\n}\nnamespace Init{\n\tint ver[400005],ne[400005],head[200005],cnt=1,val[400005];\n\tinline void link(int x,int y,int v){\n\t\tver[++cnt]=y;\n     \tne[cnt]=head[x];\n\t\thead[x]=cnt;val[cnt]=v;\n\t}\n\tvector<pair<int,int> > son[100005];\n\tint las[100005];\n\tvoid init(int x,int fi){\n\t\tfor(auto it:son[x]){\n\t\t\tint u=it.first;if(u==fi)continue;\n\t\t\tinit(u,x);\n\t\t\tif(!las[x])link(x,u,it.second),link(u,x,it.second),las[x]=x;\n\t\t\telse {\n\t\t\t\tlink(las[x],++m,0);link(m,las[x],0);las[x]=m;\n\t\t\t\tlink(las[x],u,it.second);link(u,las[x],it.second);\n\t\t\t}\n\t\t}\n\t}\n\tint siz[200005],mxp[200005],root;\n\tbool vis[400005];\n\tvoid findrt(int x,int fi,int tot){\n\t\tsiz[x]=1;\n\t\tfor(int i=head[x];i;i=ne[i]){\n\t\t\tint u=ver[i];if(vis[i]||u==fi)continue;\n\t\t\tfindrt(u,x,tot);siz[x]+=siz[u];mxp[i>>1]=max(tot-siz[u],siz[u]);\n\t\t\tif(mxp[root]>mxp[i>>1])root=(i>>1);\n\t\t}\n\t}\n\tint rt[200005];\n\tvector<int> vec;\n\tvoid dfs(int x,int fi){\n\t\tif(x<=n)vec.push_back(rt[x]);\n\t\tsiz[x]=1;\n\t\tfor(int i=head[x];i;i=ne[i]){\n\t\t\tint u=ver[i];\n\t\t\tif(vis[i]||u==fi)continue;\n\t\t\trt[u]=Main::insert(val[i],rt[x]);\n\t\t\tdfs(u,x);siz[x]+=siz[u];\n\t\t}\n\t}\n\tvoid solve(int x,int tot){\n\t\tmxp[root=0]=m;findrt(x,x,tot);\n\t\tif(!root)return ;vis[root<<1]=vis[root<<1|1]=1;\n\t\tint L=ver[root<<1],R=ver[root<<1|1];++lim;\n\t\trt[L]=0;vec.clear();dfs(L,R);\n\t\tsort(vec.begin(),vec.end(),Main::ccmp);swap(rt1[lim],vec);\n\t\trt[R]=Main::insert(val[root<<1],0);vec.clear();dfs(R,L);\n\t\tsort(vec.begin(),vec.end(),Main::ccmp);swap(rt2[lim],vec);\n\t\tsolve(L,siz[L]);solve(R,siz[R]);\n\t}\n\tinline void main(){\n\t\tfor(int i=1;i<=n;i++)Main::val[i]=1ll*rand()*rand()*rand()+1ll*rand()*rand()+rand();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint x,y,v;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&v);\n\t\t\tson[x].push_back(make_pair(y,v));\n\t\t\tson[y].push_back(make_pair(x,v));\n\t\t}m=n;\n\t\tinit(1,1);solve(1,m);\n\t}\n}\nint main(){\n\tscanf(\"%d%lld\",&n,&k);\n\tInit::main();\n\tMain::main();\n\n\treturn 0;\n}\n```\n\n\n\n\n",
        "postTime": 1642218179,
        "uid": 483966,
        "name": "\u4e00\u7c92\u5938\u514b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 [PA2019]Podatki drogowe"
    },
    {
        "content": "\u53e3\u80e1\u4e86\u4e00\u4e0b\uff0c\u61d2\u5f97\u5199\u4e86\u3002\n\n\u8003\u8651\u6bcf\u4e2a\u8def\u5f84\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u8868\u793a\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u5b58\u54c8\u5e0c\u503c\uff0c\u6bd4\u8f83\u64cd\u4f5c\u662f $O(\\log n)$ \u7684 \u3002\n\n\u7b2c $k$ \u5c0f\u663e\u7136\u4e8c\u5206\u7b54\u6848\uff0c\u7136\u540e\u8def\u5f84\u70b9\u5206\u5904\u7406\u3002\n\n\u70b9\u5206\u672c\u8d28\u662f\u679a\u4e3e LCA \uff0c\u7136\u540e\u5f04\u51fa\u6bcf\u4e2a\u70b9\u5230 LCA \u4e4b\u95f4\u7684\u503c\uff0c\u6bcf\u6b21\u9009\u4e24\u6761\u8def\u5f84\u5408\u5e76\u3002\n\n\u5408\u5e76\u7684\u65f6\u5019\u8003\u8651\u628a\u4e24\u4e2a\u96c6\u5408\u6392\u5e8f\uff0c\u7136\u540e\u663e\u7136\u53ef\u4ee5\u53cc\u6307\u9488\uff0c\u6bcf\u6b21\u5224\u65ad\u52a0\u8d77\u6765\u662f\u5426\u5c0f\u4e8e\u4e8c\u5206\u7684 mid \u53bb\u79fb\u52a8\u6307\u9488\uff0c\u7136\u540e\u76f4\u63a5\u7edf\u8ba1\u3002\n\n\u53d1\u73b0\u76f4\u63a5\u4e8c\u5206\u7b54\u6848\u590d\u6742\u5ea6\u591a\u5e26\u4e2a $O(n)$ \uff0c\u8003\u8651\u968f\u673a\u4e8c\u5206\u8def\u5f84\uff0c\u6bcf\u6b21\u4e8c\u5206\u76f8\u5f53\u4e8e\u968f\u673a\u627e\u4e00\u4e2a\u957f\u5ea6\u5728 $l,r$ \u4e4b\u95f4\u7684\u8def\u5f84\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u5728\u70b9\u5206\u7684\u65f6\u5019\u987a\u4fbf\u968f\u673a\u4e00\u4e0b\uff0c\u590d\u6742\u5ea6\u671f\u671b $O(\\log n)$ \u3002\n\n\u603b\u590d\u6742\u5ea6\u4e3a $O(n\\log^3n)$ \u3002\n\nupd on 2022.07.16\uff1a\u8fd8\u662f\u5199\u4e86\uff0c\u8fc7\u4e86\u3002\n\n\u5b9e\u73b0\u4e0a\u7684\u542f\u53d1\uff1a\u5b9e\u9645\u60c5\u51b5\u7b49\u5230\u4e8c\u5206\u5230 $l=r$ \u7684\u8bdd\u82b1\u8d39\u7684\u65f6\u95f4\u592a\u4e45\u4e86\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u94a6\u5b9a\u4e00\u4e2a\u4e8c\u5206\u6b21\u6570\u3002\n\n\u7136\u540e\u8fd9\u4e2a\u4e8c\u5206\u6b21\u6570\u4f1a\u5f71\u54cd WA \u6216 TLE \uff0c\u6240\u4ee5\u8fd9\u91cc\u6211\u9009\u62e9\u5361\u65f6\u3002\n\n\u5b9e\u9645\u4ee3\u7801\u957f\u5ea6\u53ea\u6709 6.2k \u3002\n\n\u653e\u4e2a\u4ee3\u7801\uff0c\u6bd5\u7adf\u662f\u6210\u5c31\u611f\uff08\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#include<set>\n#include<deque>\n#include<ctime>\nusing namespace std;\ntypedef long long LL;\nconst int N=5e4+5;\nconst int Mod=1e9+7;\nint n;\nLL k;\nint power[N];\nint sum[N<<10],lc[N<<10],rc[N<<10],tot,cnt[N<<10];\nint Head[N],Ver[N<<1],Nxt[N<<1],cnt_edge=-1,Val[N<<1];\ndouble st;\ninline int Read(){\n\tchar ch;\n\tint f=1;\n\twhile((ch=getchar())<'0'||ch>'9')\n\t\tif(ch=='-') f=-1;\n\tint x=ch^48;\n\twhile((ch=getchar())>='0'&&ch<='9')\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\treturn x*f;\n}\ninline void print(const int x){\n\tif(x>=10) print(x/10);\n\tputchar(x%10+48);\n\treturn ;\n}\ninline void Print(const int x,const char ch='\\n'){\n\tif(x<0){\n\t\tputchar('-');\n\t\tprint(-x);\n\t}\n\telse print(x);\n\tputchar(ch);\n\treturn ;\n}\ninline void add(int&x,const int y){\n\tx+=y;\n\tif(x>=Mod) x-=Mod;\n\treturn ;\n}\ninline void sub(int&x,const int y){\n\tx-=y;\n\tif(x<0) x+=Mod;\n\treturn ;\n}\ninline void Add(const int u,const int v,const int value){\n\t++cnt_edge;\n\tVer[cnt_edge]=v;\n\tVal[cnt_edge]=value;\n\tNxt[cnt_edge]=Head[u];\n\tHead[u]=cnt_edge;\n\treturn ;\n}\ninline void Add_Edge(const int u,const int v,const int value){\n\tAdd(u,v,value);\n\tAdd(v,u,value);\n\treturn ;\n}\ninline void Init(){\n\tst=time(0);\n\tmemset(Head,-1,sizeof(Head));\n\tn=Read();\n\tscanf(\"%lld\",&k);\n\tfor(int i=1;i<n;i++){\n\t\tint u=Read();\n\t\tint v=Read();\n\t\tint value=Read();\n\t\tAdd_Edge(u,v,value);\n\t}\n\tpower[0]=1;\n\tfor(int i=1;i<=n+1;i++)\n\t\tpower[i]=1ll*power[i-1]*n%Mod;\n\treturn ;\n}\ninline void Add_Edge(const int u,const int v){\n\t++cnt_edge;\n\tVer[cnt_edge]=v;\n\tNxt[cnt_edge]=Head[u];\n\tHead[u]=cnt_edge;\n\treturn ;\n}\ninline void Add(int&u,const int v,const int ll,const int rr,const int p){\n\tu=++tot;\n\tsum[u]=sum[v];\n\tadd(sum[u],power[p]);\n\tcnt[u]=cnt[v]+1;\n\tif(ll==rr) return ;\n\tint mid=ll+rr>>1;\n\tif(mid>=p){\n\t\tAdd(lc[u],lc[v],ll,mid,p);\n\t\trc[u]=rc[v];\n\t}\n\telse{\n\t\tlc[u]=lc[v];\n\t\tAdd(rc[u],rc[v],mid+1,rr,p);\n\t}\n\treturn ;\n}\ninline bool Small(const int u,const int v,const int ll,const int rr){\n\tif(ll==rr) return cnt[u]<cnt[v];\n\tint mid=ll+rr>>1;\n\tif(sum[rc[u]]!=sum[rc[v]]) return Small(rc[u],rc[v],mid+1,rr);\n\treturn Small(lc[u],lc[v],ll,mid);\n}\ninline bool Small2(const int u1,const int u2,const int v,const int ll,const int rr){\n\tif(ll==rr) return cnt[u1]+cnt[u2]<cnt[v];\n\tint mid=ll+rr>>1;\n\tint sr=(sum[rc[u1]]+sum[rc[u2]])%Mod;\n\tif(sr!=sum[rc[v]]) return Small2(rc[u1],rc[u2],rc[v],mid+1,rr);\n\treturn Small2(lc[u1],lc[u2],lc[v],ll,mid);\n}\nstruct Node{\n\tint uu,inr,sgt;\n\tNode(){uu=inr=sgt=0;return ;}\n};\nvector<Node>in[N];\nbool vis[N];\nint siz[N],root,mn;\ninline int Max(const int x,const int y){\n\treturn x>y?x:y;\n}\ninline int Min(const int x,const int y){\n\treturn x<y?x:y;\n}\ninline void FindRoot(const int u,const int fa,const int all){\n\tsiz[u]=1;\n\tint mx=-1;\n\tfor(int i=Head[u];i!=-1;i=Nxt[i]){\n\t\tint v=Ver[i];\n\t\tif(v==fa||vis[v]) continue ;\n\t\tFindRoot(v,u,all);\n\t\tsiz[u]+=siz[v];\n\t\tmx=Max(mx,siz[v]);\n\t}\n\tmx=Max(mx,all-siz[u]);\n\tif(mn>mx){\n\t\tmn=mx;\n\t\troot=u;\n\t}\n\treturn ;\n}\ninline void Calc(const int u,const int fa,const int fasgt,const int p,const int fr,const int frall){\n\tNode u1;\n\tu1.uu=u,u1.inr=fr;\n\tAdd(u1.sgt,fasgt,1,n+1,p);\n\tin[frall].push_back(u1);\n\tfor(int i=Head[u];i!=-1;i=Nxt[i]){\n\t\tint v=Ver[i];\n\t\tif(v==fa||vis[v]) continue ;\n\t\tCalc(v,u,u1.sgt,Val[i],fr,frall);\n\t}\n\treturn ;\n}\ninline bool Cmp(const Node x,const Node y){\n\treturn Small(x.sgt,y.sgt,1,n+1);\n}\ninline void Dfs(const int u){\n\tNode u1;\n\tu1.uu=u,u1.inr=u;\n\tin[u].push_back(u1);\n\tfor(int i=Head[u];i!=-1;i=Nxt[i]){\n\t\tint v=Ver[i];\n\t\tif(vis[v]) continue ;\n\t\tCalc(v,u,0,Val[i],v,u);\n\t}\n\tsort(in[u].begin(),in[u].end(),Cmp);\n\tvis[u]=1;\n\tfor(int i=Head[u];i!=-1;i=Nxt[i]){\n\t\tint v=Ver[i];\n\t\tif(vis[v]) continue ;\n\t\troot=-1,mn=n+1;\n\t\tFindRoot(v,0,siz[v]);\n\t\tDfs(root);\n\t}\n\treturn ;\n}\ninline void Init_Tree(){\n\troot=-1,mn=n+1;\n\tFindRoot(1,0,n);\n\tDfs(root);\n\treturn ;\n}\nint cntt[N];\ninline bool Check(const int mid){\n\tLL ss=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint j1=0;\n\t\tfor(int j=in[i].size()-1;j>=0;j--){\n\t\t\twhile(j1<in[i].size()&&Small2(in[i][j].sgt,in[i][j1].sgt,mid,1,n+1)){\n\t\t\t\tcntt[in[i][j1].inr]++;\n\t\t\t\tj1++;\n\t\t\t}\n\t\t\tss+=j1-cntt[in[i][j].inr];\n\t\t}\n\t\tfor(int j=0;j<in[i].size();j++)\n\t\t\tcntt[in[i][j].inr]=0;\n\t}\n\treturn ss/2<k;\n}\ninline int Merge(const int u,const int v,const int ll,const int rr){\n\tif(!u||!v) return u+v;\n\tint now=++tot;\n\tsum[now]=(sum[u]+sum[v])%Mod;\n\tcnt[now]=cnt[u]+cnt[v];\n\tif(ll<rr){\n\t\tint mid=ll+rr>>1;\n\t\tlc[now]=Merge(lc[u],lc[v],ll,mid);\n\t\trc[now]=Merge(rc[u],rc[v],mid+1,rr);\n\t}\n\treturn now;\n}\ninline int Random(const int ll,const int rr){\n\treturn 1ll*rand()*rand()%(rr-ll+1)+ll;\n}\nint u_rand[N<<5],v_rand[N<<5],cnt_rand,fr_rand[N<<5];\nset<int>s;\ndeque<int>q[N];\ninline int Find(const int ll,const int rr){\n\tcnt_rand=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint l=0,r=0;\n\t\tfor(int j=in[i].size()-1;j>=0;j--){\n\t\t\twhile(r<in[i].size()&&Small2(in[i][j].sgt,in[i][r].sgt,rr,1,n+1)){\n\t\t\t\tif(!cntt[in[i][r].inr]) s.insert(in[i][r].inr);\n\t\t\t\tcntt[in[i][r].inr]++;\n\t\t\t\tq[in[i][r].inr].push_back(r);\n\t\t\t\tr++;\n\t\t\t}\n\t\t\twhile(l<in[i].size()&&Small2(in[i][j].sgt,in[i][l].sgt,ll,1,n+1)){\n\t\t\t\tcntt[in[i][l].inr]--;\n\t\t\t\tif(!cntt[in[i][l].inr]) s.erase(in[i][l].inr);\n\t\t\t\tif(q[in[i][l].inr].size()) q[in[i][l].inr].pop_front();\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(l==r) continue ;\n\t\t\tif(!s.size()) continue ;\n\t\t\tif(s.size()==1&&*s.begin()==in[i][j].inr) continue ;\n\t\t\tset<int>::iterator it=s.begin();\n\t\t\tif(*it==in[i][j].inr) it=--s.end();\n\t\t\tint inr1=*it;\n\t\t\t++cnt_rand;\n\t\t\tfr_rand[cnt_rand]=i;\n\t\t\tu_rand[cnt_rand]=j;\n\t\t\tint rd=Random(0,q[inr1].size()-1);\n\t\t\tv_rand[cnt_rand]=q[inr1][rd];\n\t\t}\n\t\tfor(int j=0;j<in[i].size();j++){\n\t\t\tcntt[in[i][j].inr]=0;\n\t\t\tq[in[i][j].inr].clear();\n\t\t}\n\t\ts.clear();\n\t}\n\tint rd=Random(1,cnt_rand);\n\tint fr=fr_rand[rd];\n\tint i1=u_rand[rd],i2=v_rand[rd];\n\tint ge=Merge(in[fr][i1].sgt,in[fr][i2].sgt,1,n+1);\n\treturn ge;\n}\ninline void Solve(){\n\tInit_Tree();\n\tint ll=0,rr=0;\n\tAdd(rr,0,1,n+1,n+1);\n\twhile(time(0)-st<=5.2){\n\t\tint mid=Find(ll,rr);\n\t\tif(Check(mid)) ll=mid;\n\t\telse rr=mid;\n\t\tif(sum[ll]==sum[rr]) break ;\n\t}\n\tint ans=Find(ll,rr);\n\treturn Print(sum[ans]);\n}\nint main(){\n\tInit();\n\tSolve();\n\treturn 0;\n}\n```",
        "postTime": 1657856921,
        "uid": 115936,
        "name": "\u6cf7\u6cfd\u4e09\u6708",
        "ccfLevel": 0,
        "title": "P5984"
    }
]