[
    {
        "content": "## [THUSCH 2017 \u6362\u684c](https://www.luogu.com.cn/problem/P7452)\uff08\u8d39\u7528\u6d41\uff0c\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\uff09\n\n\u4e8c\u5206\u56fe\u5e26\u6743\u5339\u914d\uff0c\u53ef\u4ee5\u7528\u8d39\u7528\u6d41\u89e3\u51b3\u3002\n\n\u9996\u5148\u6709\u4e2a\u5f88\u660e\u663e\u7684\u8fde\u8fb9\u65b9\u5f0f\uff0c\u6bcf\u4e2a\u4eba\u5411\u80fd\u53bb\u7684\u5ea7\u4f4d\u8fde\u8fb9\uff0c\u8fb9\u6570\u662f $\\mathcal{O}(n^2m^2)$ \u7684\uff0c\u5f88\u660e\u663e\u4e0d\u884c\u3002\n\n\u8003\u8651\u4f18\u5316\u4e00\u4e0b\u5efa\u56fe\u65b9\u5f0f\u3002\n\n\u53ef\u4ee5\u628a**\u684c\u5b50\u7f16\u53f7**\u7684\u79fb\u52a8\u548c**\u4f4d\u7f6e\u7f16\u53f7**\u7684\u79fb\u52a8**\u5206\u5f00\u8003\u8651**\u3002\n\n\u5efa\u7acb $nm$ \u4e2a\u4e2d\u8f6c\u70b9\uff0c\u4e00\u4fa7\u7684\u8fb9\u8868\u793a\u684c\u5b50\u7f16\u53f7\u7684\u79fb\u52a8\uff0c\u4e00\u4fa7\u7684\u8fb9\u8868\u793a\u4f4d\u7f6e\u7f16\u53f7\u7684\u79fb\u52a8\uff0c\u8fd9\u6837\u8fb9\u6570\u5c31\u53ef\u4ee5\u4f18\u5316\u5230 $\\mathcal{O}(nm(n+m))$\u3002\n\n\u7136\u540e\u53d1\u73b0\u684c\u5b50\u7f16\u53f7\u7684\u79fb\u52a8\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u56e0\u6b64\u53ef\u4ee5\u4f7f\u7528**\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe**\uff0c\u8fd9\u6837\u8fb9\u6570\u53ef\u4ee5\u4f18\u5316\u5230 $\\mathcal{O}(nm(\\log n+m))$\u3002\u6709\u4e00\u4e2a\u7ec6\u8282\u662f\u7edd\u5bf9\u503c\u7684\u5904\u7406\uff0c\u8fd9\u53ef\u4ee5\u7528\u4e24\u6b21\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\u89e3\u51b3\u3002\n\n\u8003\u8651\u7ee7\u7eed\u4f18\u5316\uff0c\u53d1\u73b0\u4f4d\u7f6e\u7f16\u53f7\u7684\u79fb\u52a8\u53ef\u4ee5\u8fde\u6210\u4e00\u4e2a\u73af\u7684\u5f62\u5f0f\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u628a\u8fb9\u6570\u4f18\u5316\u5230 $\\mathcal{O}(nm\\log n)$\u3002\n\n```c++\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int inf = 1e9;\nnamespace MCMF {\n\tconst int maxN = 1e5;\n\tconst int maxM = 1e6;\n\tint S, T, n, tot, maxflow, mincost;\n\tint head[maxN], now[maxN], dis[maxN];\n\tbool vis[maxN];\n\tstruct edge {\n\t\tint to, nxt;\n\t\tint f, c;\n\t} e[maxM];\n\tvoid add(int u, int v, int f, int c) {\n\t\te[++tot].to = v;\n\t\te[tot].nxt = head[u];\n\t\te[tot].f = f;\n\t\te[tot].c = c;\n\t\thead[u] = tot;\n\t}\n\tvoid add2(int u, int v, int f, int c) {\n\t\tadd(u, v, f, c);\n\t\tadd(v, u, 0, -c);\n\t}\n\tbool spfa() {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tdis[i] = inf;\n\t\t\tvis[i] = 0;\n\t\t}\n\t\tstd::deque<int> q;\n\t\tq.push_back(S);\n\t\tdis[S] = 0;\n\t\tvis[S] = 1;\n\t\twhile(!q.empty()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop_front();\n\t\t\tvis[u] = 0;\n\t\t\tfor(int i = head[u]; i; i = e[i].nxt) {\n\t\t\t\tint v = e[i].to, f = e[i].f, c = e[i].c;\n\t\t\t\tif(f && dis[u] + c < dis[v]) {\n\t\t\t\t\tdis[v] = dis[u] + c;\n\t\t\t\t\tif(!vis[v]) {\n\t\t\t\t\t\tif(!q.empty() && dis[v] < dis[q.front()]) {\n\t\t\t\t\t\t\tq.push_front(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tq.push_back(v);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T] < inf;\n\t}\n\tint dfs(int u, int flow) {\n\t    if(u == T) {\n\t    \treturn flow;\n\t\t}\n\t    int res = 0;\n\t    vis[u] = 1;\n\t    for(int &i = now[u]; i; i = e[i].nxt) {\n\t        int v = e[i].to, c = e[i].c, f = e[i].f;\n\t\t\tif(dis[v] == dis[u] + c && f && !vis[v]) {\n\t\t\t\tint t = dfs(v, std::min(flow, f));\n\t\t\t\tif(t) {\n\t\t\t\t\tflow -= t;\n\t\t\t\t\tres += t;\n\t\t\t\t\tmincost += t * c;\n\t\t\t\t\te[i].f -= t;\n\t\t\t\t\te[i ^ 1].f += t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdis[v] = -inf;\n\t\t\t\t}\n\t\t\t\tif(!flow) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t    }\n\t    vis[u] = 0;\n\t    return res;\n\t}\n\tvoid mcmf() {\n\t    while(spfa()) {\n\t    \tfor(int i = 1; i <= n; i++) {\n\t    \t\tvis[i] = 0;\n\t    \t\tnow[i] = head[i];\n\t\t\t}\n\t\t\tmaxflow += dfs(S, inf);\n\t    }\n\t}\n\tvoid init(int x) {\n\t\tn = x;\n\t\tS = n - 1;\n\t\tT = n;\n\t\ttot = 1;\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\thead[i] = 0;\n\t\t}\n\t}\n}\nusing MCMF::S;\nusing MCMF::T;\nusing MCMF::add2;\nusing MCMF::maxflow;\nusing MCMF::mincost;\nusing namespace std;\nconst int maxn = 305;\nint n, m, cnt, l[maxn][maxn], r[maxn][maxn];\nint id(int x, int y) {\n\treturn (x - 1) * m + y;\n}\n#define lc (x << 1)\n#define rc (x << 1 | 1)\n#define mid ((l + r) >> 1)\nstruct SGT {\n\tint num[maxn * 4], leaf[maxn];\n\tvoid build_pre(int x, int l, int r) {\n\t\tnum[x] = ++cnt;\n\t\tif(l == r) {\n\t\t\tleaf[l] = cnt;\n\t\t\treturn;\n\t\t}\n\t\tbuild_pre(lc, l, mid);\n\t\tbuild_pre(rc, mid + 1, r);\n\t}\n\tvoid build(int x, int l, int r) {\n\t\tif(l == r) {\n\t\t\treturn;\n\t\t}\n\t\tadd2(num[x], num[lc], inf, 0);\n\t\tadd2(num[x], num[rc], inf, 0);\n\t\tbuild(lc, l, mid);\n\t\tbuild(rc, mid + 1, r);\n\t}\n\tvoid link(int x, int l, int r, int L, int R, int u, int f, int c) {\n\t\tif(L > R || l > R || r < L) {\n\t\t\treturn;\n\t\t}\n\t\tif(l >= L && r <= R) {\n\t\t\tadd2(u, num[x], f, c);\n\t\t\treturn;\n\t\t}\n\t\tlink(lc, l, mid, L, R, u, f, c);\n\t\tlink(rc, mid + 1, r, L, R, u, f, c);\n\t}\n} A[11], B[11];\n#undef lc\n#undef rc\n#undef mid\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= m; j++) {\n\t\t\tcin >> l[i][j];\n\t\t\tl[i][j]++;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= m; j++) {\n\t\t\tcin >> r[i][j];\n\t\t\tr[i][j]++;\n\t\t}\n\t}\n\t/*\n\tO(nm(m + log n))\n\tcnt = n * m * 3;\n\tfor(int i = 1; i <= m; i++) {\n\t\tA[i].build_pre(1, 1, n);\n\t\tB[i].build_pre(1, 1, n);\n\t}\n\tMCMF::init(cnt + 2);\n\tfor(int i = 1; i <= m; i++) {\n\t\tA[i].build(1, 1, n);\n\t\tB[i].build(1, 1, n);\n\t}\n\tfor(int i = 1; i <= n * m; i++) {\n\t\tadd2(S, i, 1, 0);\n\t\tadd2(i, i + n * m, 1, 0);\n\t\tadd2(i + n * m * 2, T, 1, 0);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= m; j++) {\n\t\t\tfor(int k = 1; k <= m; k++) {\n\t\t\t\tadd2(A[j].leaf[i], id(i, k) + n * m * 2, inf, min(abs(j - k), m - abs(j - k)) + i * 2);\n\t\t\t\tadd2(B[j].leaf[i], id(i, k) + n * m * 2, inf, min(abs(j - k), m - abs(j - k)) - i * 2);\n\t\t\t}\n\t\t\tif(l[i][j] >= i) {\n\t\t\t\tA[j].link(1, 1, n, l[i][j], r[i][j], id(i, j) + n * m, 1, -i * 2);\n\t\t\t}\n\t\t\telse if(r[i][j] <= i) {\n\t\t\t\tB[j].link(1, 1, n, l[i][j], r[i][j], id(i, j) + n * m, 1, i * 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tA[j].link(1, 1, n, i, r[i][j], id(i, j) + n * m, 1, -i * 2);\n\t\t\t\tB[j].link(1, 1, n, l[i][j], i - 1, id(i, j) + n * m, 1, i * 2);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\t// O(nm log n)\n\tcnt = n * m * 2;\n\tfor(int i = 1; i <= m; i++) {\n\t\tA[i].build_pre(1, 1, n);\n\t\tB[i].build_pre(1, 1, n);\n\t}\n\tMCMF::init(cnt + 2);\n\tfor(int i = 1; i <= m; i++) {\n\t\tA[i].build(1, 1, n);\n\t\tB[i].build(1, 1, n);\n\t}\n\tfor(int i = 1; i <= n * m; i++) {\n\t\tadd2(S, i, 1, 0);\n\t\tadd2(i + n * m, T, 1, 0);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = 1; j <= m; j++) {\n\t\t\tint L = j - 1 > 0 ? j - 1 : m, R = j + 1 <= m ? j + 1 : 1;\n\t\t\tadd2(A[j].leaf[i], A[L].leaf[i], inf, 1);\n\t\t\tadd2(A[j].leaf[i], A[R].leaf[i], inf, 1);\n\t\t\tadd2(B[j].leaf[i], B[L].leaf[i], inf, 1);\n\t\t\tadd2(B[j].leaf[i], B[R].leaf[i], inf, 1);\n\t\t\tadd2(A[j].leaf[i], id(i, j) + n * m, inf, i * 2);\n\t\t\tadd2(B[j].leaf[i], id(i, j) + n * m, inf, -i * 2);\n\t\t\tif(l[i][j] >= i) {\n\t\t\t\tA[j].link(1, 1, n, l[i][j], r[i][j], id(i, j), 1, -i * 2);\n\t\t\t}\n\t\t\telse if(r[i][j] <= i) {\n\t\t\t\tB[j].link(1, 1, n, l[i][j], r[i][j], id(i, j), 1, i * 2);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tA[j].link(1, 1, n, i, r[i][j], id(i, j), 1, -i * 2);\n\t\t\t\tB[j].link(1, 1, n, l[i][j], i - 1, id(i, j), 1, i * 2);\n\t\t\t}\n\t\t}\n\t}\n\tMCMF::mcmf();\n\tif(maxflow < n * m) {\n\t\tcout << \"no solution\\n\";\n\t}\n\telse {\n\t\tcout << mincost << '\\n';\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1674871032,
        "uid": 114168,
        "name": "yanchengzhi",
        "ccfLevel": 7,
        "title": "THUSCH 2017 \u6362\u684c\uff08\u8d39\u7528\u6d41\uff0c\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\uff09"
    },
    {
        "content": "~~\u6765\u4e00\u4e2a\u778e\u51e0\u628a\u53e3\u80e1\u7684\u8d39\u7528\u6d41\u505a\u6cd5~~\n\n\u9996\u5148\u6bcf\u4e2a\u70b9\u5411\u76ee\u6807\u70b9\u8fde\u8fb9\uff0c\u663e\u7136\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u5b8c\u5907\u5339\u914d\u3002\n\n\u7136\u540e\u663e\u7136\u76f4\u63a5\u8dd1 MCMF \u662f\u4f1a\u5bc4\u6389\u7684\u3002\n\n\u4e0d\u59a8\u6765\u60f3\u4e00\u60f3\u600e\u4e48\u8ba9\u8d39\u7528\u6d41\u6a21\u578b\u5e2e\u6211\u4eec\u201c\u81ea\u52a8\u201d\u8ba1\u7b97\u8d39\u7528\u3002\n\n\u56e0\u4e3a\u7ed5\u7740\u4e00\u4e2a\u73af\u7684\u90a3\u4e2a\u7edd\u5bf9\u503c\u7684\u6700\u5c0f\u503c\u76f8\u5f53\u4e8e\u6700\u77ed\u8def\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u684c\u5b50\uff0c\u8fde\u4e00\u6761\u8fb9 $(i,(i+1)\\bmod n,n)$\uff08\u6700\u574f\u6709 $n$ \u4e2a\u8282\u70b9\u4f1a\u7ecf\u8fc7\u8fd9\u6761\u8fb9\uff09\n\n\u7136\u540e\u5728\u684c\u5b50\u4e0e\u684c\u5b50\u4e4b\u95f4\u8fde\u8fb9\u3002\n\n\u5177\u4f53\u5730\n\n\u5bf9\u4e8e $nm$ \u4e2a\u4f4d\u7f6e\uff0c\u6bcf\u4e2a\u4f4d\u7f6e\u8fde\u6bcf\u5f20\u684c\u5b50\u4e0a\u5bf9\u5e94\u7684\u4f4d\u7f6e\n\n\u6bcf\u4e2a\u684c\u5b50\u5185\u90e8\u6709 $2m$ \u6761\u8fb9\u3002\n\n\u8282\u70b9\u6570\u91cf\u662f $2nm+2$\uff0c\u8fb9\u6570\u91cf\u662f $n^2m+2nm$\u3002\n\n\u4e5f\u8bb8\u662f\u53ef\u4ee5\u8dd1\u8fc7\u53bb\u7684\u3002\uff08$6002$ \u4e2a\u70b9\u548c $900600$ \u6761\u8fb9\uff09\n\n\u800c\u4e14\u8fd8\u6709\u5206\u5c42\uff0c\u8fb9\u6743\u4e5f\u5f88\u6709\u89c4\u5f8b\u3002\u3002\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\u6b64\u56fe\u5b58\u5728\u8d1f\u73af\uff0c\u9700\u8981\u5904\u7406\u4e00\u4e0b\u7ec6\u8282\u3002\n\n\u597d\u50cf\u6570\u636e\u6709\u70b9\u513f\u6c34\uff0c\u76f4\u63a5\u8dd1\u5c31\u80fd\u8fc7\uff08\n\n\u4ee5\u53ca\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u8981\u628a\u524d\u5411\u661f\u6362\u6210 vector \u624d\u80fd\u8fc7\u3002\n\n\u542c\u8bf4\u6b63\u89e3\u662f\u628a\u8fd9\u4e2a\u5efa\u56fe\u5728\u8fde $[L,R]$ \u7684\u65f6\u5019\u7528\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\u3002\uff08\u597d\u50cf\u662f\u8bf4\u4e0d\u8fd9\u6837\u7684\u8bdd\u4e0d\u5199 zkw \u8d39\u7528\u6d41\u8fc7\u4e0d\u53bb\uff09\n```cpp\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-funroll-loops\",\"-fdelete-null-pointer-checks\")\n#include<cstdio>\n#include<vector>\n#include<queue>\nconst int M=305,N=15;\nint n,m,s,t,tot,l[M][N],r[M][N],in[M][N],out[M][N];\nint d[6005];bool iq[6005],vis[6005];\nstd::deque<int>q;int flow,ret;\ninline int min(const int&a,const int&b){return a>b?b:a;}\ninline int abs(const int&a){return a>0?a:-a;}\nstruct Edge{\n\tint v,w,flow,id;\n};std::vector<Edge>G[6005];\ninline void Add(const int&u,const int&v,const int&flow,const int&w){\n\tG[u].push_back((Edge){v,w,flow,G[v].size()});\n\tG[v].push_back((Edge){u,-w,0,G[u].size()-1});\n}\ninline bool BFS(){\n\tfor(int i=s;i<=t;++i)d[i]=0x7fffffff,vis[i]=false;d[s]=0;q.push_back(s);\n\twhile(!q.empty()){\n\t\tconst int u=q.front();int v;iq[u]=false;q.pop_front();\n\t\tfor(Edge&E:G[u])if(E.flow){\n\t\t\tconst int&w=d[u]+E.w;\n\t\t\tif(w<d[v=E.v]){\n\t\t\t\td[v]=w;if(iq[v])continue;iq[v]=true;\n\t\t\t\tif(!q.empty()&&d[v]<d[q.front()])q.push_front(v);else q.push_back(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t]!=0x7fffffff;\n}\ninline int DFS(const int&u,const int&flow){\n\tif(u==t)return flow;\n\tint v,ret(flow);vis[u]=true;\n\tfor(Edge&E:G[u])if(d[v=E.v]==d[u]+E.w&&E.flow&&!vis[v]){\n\t\tconst int&F=DFS(v,min(ret,E.flow));if(!F)d[v]=-0x7fffffff;E.flow-=F;G[v][E.id].flow+=F;ret-=F;\n\t\tif(!ret)return flow;\n\t}\n\treturn flow-ret;\n}\ninline void Dinic(){\n\twhile(BFS())while(const int&F=DFS(s,n*m))ret+=F*d[t],flow+=F;\n\tif(flow!=n*m)printf(\"no solution\");else printf(\"%d\",ret);\n}\nsigned main(){\n\tscanf(\"%d%d\",&n,&m);\n\ts=++tot;for(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf(\"%d\",l[i]+j),++l[i][j],in[i][j]=++tot;\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=m;++j)scanf(\"%d\",r[i]+j),++r[i][j],out[i][j]=++tot;t=++tot;\n\tfor(int i=1;i<=n;++i)for(int j=1;j<=m;++j){\n\t\tAdd(s,in[i][j],1,0);Add(out[i][j],t,1,0);Add(out[i][j],out[i][j%m+1],m,1);Add(out[i][j%m+1],out[i][j],m,1);\n\t\tfor(int k=l[i][j];k<=r[i][j];++k)Add(in[i][j],out[k][j],1,abs(i-k)<<1);\n\t}\n\tDinic();\n}\n```",
        "postTime": 1652496846,
        "uid": 160839,
        "name": "Prean",
        "ccfLevel": 7,
        "title": "\u8d39\u7528\u6d41 P7452\u9898\u89e3"
    }
]