[
    {
        "content": "\u9996\u5148\u5bb9\u6613\u53d1\u73b0\uff1a$\\max\\limits_{i=1}^{l}(num(p,i,r))=num(p,l,r)$~~\uff0c\u6240\u4ee5\u8fd9\u53e5\u8bdd\u5b8c\u5168\u662f\u552c\u4eba\u7684~~\u3002\n\n## \u505a\u6cd5\u4e00\uff1ahash\n\n\u4e71\u641e\u505a\u6cd5\uff0c\u4e0d\u505a\u8bb2\u89e3\uff0c\u5206\u6570\u4e0d\u5b9a\u3002\n\n## \u505a\u6cd5\u4e8c\uff1aAC \u81ea\u52a8\u673a\uff08$l=1$\uff09\n\n\u8003\u8651 $l=1$ \u8be5\u600e\u4e48\u505a\uff0c\u76f4\u63a5\u5bf9\u6240\u6709\u6a21\u677f\u4e32\u5efa\u51fa AC \u81ea\u52a8\u673a\u548c fail \u6811\uff0c\u5bf9\u4e8e\u8be2\u95ee $1$\uff0c\u76f4\u63a5\u5728 AC \u81ea\u52a8\u673a\u4e0a\u8dd1\u5339\u914d\uff0c\u5e76\u628a\u7ecf\u8fc7\u7684\u6240\u6709\u8282\u70b9\u5b58\u8d77\u6765\uff0c\u5e76\u628a\u8fd9\u4e9b\u8282\u70b9\u5230\u6839\u7684\u94fe\u7684\u5e76\u6253\u4e0a $+1$ \u6807\u8bb0\uff0c\u8fd9\u6837\u8be2\u95ee $2$ \u7684\u7b54\u6848\u5c31\u662f\u8fd9\u4e2a\u524d\u7f00\u4e32\u6240\u4ee3\u8868\u7684\u8282\u70b9\u7684\u6807\u8bb0\u548c\u3002\n\n## \u505a\u6cd5\u4e09\uff1a\u79bb\u7ebf SAM\n\n\u73b0\u5728\u53d8\u6210\u4e86\u5b50\u4e32\u95ee\u9898\uff0c\u5bb9\u6613\u60f3\u5230\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u4f46\u662f\u8981\u628a\u6a21\u677f\u4e32\u548c\u8be2\u95ee\u4e32\u4e00\u8d77\u5efa\uff0c\u539f\u56e0\u4f1a\u5728\u4e0b\u6587\u89e3\u91ca\u3002\u8be2\u95ee $1$ \u7684\u5904\u7406\u65b9\u6cd5\u548c\u539f\u6765\u4e00\u6837\u3002\u8be2\u95ee $2$ \u5148\u9700\u8981\u627e\u5230\u8fd9\u4e2a\u5b50\u4e32\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u7ecf\u5178\u5957\u8def\uff0c\u5728\u5efa\u5e7f\u4e49 SAM \u7684\u65f6\u5019\u8bb0\u5f55 $ed[i][j]$ \u8868\u793a $S_i$ \u7684 $[1,j]$ \u5b50\u4e32\u6240\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u7136\u540e\u500d\u589e\u8df3\u5230 $dep[x]$ \u6700\u5c0f\u7684\u6ee1\u8db3 $len[x]\\ge(r-l+1)$ \u7684\u8282\u70b9\u5373\u53ef\uff0c\u7136\u540e\u67e5\u8be2\u8282\u70b9\u6807\u8bb0\u548c\u3002\n\n\u4e3a\u4ec0\u4e48\u8981\u628a\u6a21\u677f\u4e32\u548c\u8be2\u95ee\u4e32\u4e00\u8d77\u5efa\uff1f\u6211\u4eec\u8003\u8651\u53ea\u5efa\u6a21\u677f\u4e32\u7684\u60c5\u51b5\uff0c\u4e0b\u9762\u4e3e\u4e00\u7ec4\u4f8b\u5b50\uff1a\n\n### input\n\n```\n2 2\nsuffixtree\nfixtree\n1 tree\n2 1 4 10\n```\n\n### output\n\n```\n0\n```\n\n\u8fd9\u7ec4\u6837\u4f8b\u7684 `fixtree` \u548c `tree` \u8fd9\u4e24\u4e2a\u4e32\u5982\u679c\u4e0d\u5efa\u8be2\u95ee\u4e32\u7684\u8bdd\uff0c\u6240\u5728\u8282\u70b9\u5b8c\u5168\u76f8\u540c\uff0c\u8fd9\u6837\u5728\u8dd1\u5339\u914d\u7684\u65f6\u5019\uff0c\u660e\u660e\u5339\u914d\u7684\u662f `tree`\uff0c\u4f46\u4f1a\u628a\u6574\u4e2a\u8282\u70b9\u6253\u4e0a\u6807\u8bb0\uff0c\u5bfc\u81f4\u67e5\u8be2 `fixtree` \u7684\u65f6\u5019\u4f1a\u67e5\u5230 `tree` \u7684\u6807\u8bb0\u3002\n\n\u8003\u8651\u6a21\u677f\u4e32\u548c\u8be2\u95ee\u4e32\u4e00\u8d77\u5efa\u5e7f\u4e49 SAM \u7684\u6b63\u786e\u6027\uff1a\u5bf9\u4e8e\u67d0\u4e00\u7ec4\u8be2\u95ee\u4e32\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a $r$\uff0c\u5982\u679c $T_{l...r}$ \u662f\u5b83\u548c\u6a21\u677f\u4e32\u80fd\u5339\u914d\u5230\u7684\u6700\u957f\u5b50\u4e32\uff0c\u6240\u5728\u8282\u70b9\u4e3a $now$\uff0c\u8bbe\u8fd9\u4e00\u6bb5\u662f $S_i$ \u7684 $[l',r']$ \u5b50\u4e32\uff0c\u5219 $S_i$ \u7684 $[l'-1,r']$ \u4e00\u5b9a\u7531 $son[now]$ \u8868\u793a\uff0c\u800c\u4e0d\u662f\u548c $now$ \u540c\u5c5e\u4e8e\u4e00\u4e2a\u8282\u70b9\u3002\n\n## \u505a\u6cd5\u56db\uff1a\u5728\u7ebf SAM\n\n\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u5b83\u662f\u4e00\u68f5\u6811\uff0c\u5b83\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u53ea\u4ee3\u8868\u6a21\u677f\u4e32\u7684\u4e00\u79cd\u5b50\u4e32\uff0c\u4e00\u4e2a\u8282\u70b9\u6240\u4ee3\u8868\u7684\u5b50\u4e32\u662f\u5b83\u7684\u7236\u4eb2\u8282\u70b9\u6240\u4ee3\u8868\u7684\u5b50\u4e32\u524d\u52a0\u4e00\u4e2a\u5b57\u7b26\u5f62\u6210\u7684\uff0c\u6211\u4eec\u5bb9\u6613\u53d1\u73b0\uff0c\u5e7f\u4e49 SAM \u7684 parent tree \u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u5373\u662f\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u4e00\u6761\u94fe\u3002\u5ef6\u7eed\u79bb\u7ebf\u505a\u6cd5\uff0c\u6211\u4eec\u628a\u6a21\u677f\u4e32\u5efa\u5e7f\u4e49 SAM\uff08\u62fc\u5728\u4e00\u8d77\u5efa SAM \u4e5f\u53ef\u4ee5\uff09\uff0c\u8fd9\u65f6\u6211\u4eec\u8ba4\u4e3a SAM \u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u6240\u4ee3\u8868\u7684\u90fd\u662f\u4e0a\u8ff0\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u4e00\u6761\u94fe\uff0c\u4e4b\u540e\u6211\u4eec\u5e0c\u671b\u7ed9\u4e0a\u8ff0\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u6bcf\u4e2a\u70b9\u4e00\u4e2a dfs \u5e8f\uff0c\u5176\u5b9e\u53ea\u9700\u8981\u904d\u5386 SAM \u5373\u53ef\uff0c\u5e76\u5b9a\u4e49 SAM \u4e0a\u4e00\u4e2a\u70b9\u7684\u201cdfs \u5e8f\u201d\u4e3a\u5b83\u6240\u4ee3\u8868\u7684\u94fe\u7684\u6df1\u5ea6\u6700\u5927\u7684\u70b9\u5728\u6570\u636e\u7ed3\u6784\u4e0a\u7684 dfs \u5e8f\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee $1$\uff0c\u4e00\u6837\u5728 SAM \u4e0a\u8dd1\u5339\u914d\u5e76\u8bb0\u5f55\u5339\u914d\u957f\u5ea6\uff08\u5177\u4f53\u7684\uff0c\u5982\u679c\u6ca1\u6709\u5f53\u524d\u8981\u627e\u7684\u513f\u5b50\u5219\u8df3\u5230\u7236\u4eb2\uff0c\u5e76\u5c06\u5f53\u524d\u957f\u5ea6\u66f4\u65b0\u4e3a\u7236\u4eb2\u7684 $len$\uff0c\u8df3\u5230\u513f\u5b50\u7684\u65f6\u5019\u5f53\u524d\u957f\u5ea6 $+1$\uff09\uff0c\u6839\u636e\u6240\u8bb0\u5f55\u7684\u957f\u5ea6\u548c\u6240\u5728\u8282\u70b9\u7684 $len$ \u503c\u53ca\u5176\u201cdfs \u5e8f\u201d\u503c\uff0c\u5f88\u5bb9\u6613\u6c42\u51fa\u5176\u5728\u4e0a\u8ff0\u6570\u636e\u7ed3\u6784\u4e2d\u7684 dfs \u5e8f\u503c\uff0c\u6309\u7167\u5b9e\u9645\u7684 dfs \u5e8f\u503c\u505a\u201c\u6811\u94fe\u7684\u5e76\u201d\u64cd\u4f5c\u5373\u53ef\u3002\u7531\u4e8e\u8fd9\u91cc dfs \u5e8f\u662f $n^2$ \u7ea7\u522b\uff0c\u6240\u4ee5\u9700\u8981\u4f7f\u7528\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u8fdb\u884c\u5355\u70b9\u4fee\u6539\u64cd\u4f5c\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee $2$\uff0c\u4e5f\u662f\u500d\u589e\u627e\u5230 SAM \u4e0a\u5bf9\u5e94\u8282\u70b9\uff0c\u518d\u6839\u636e\u957f\u5ea6\u7b97\u51fa\u5728\u6570\u636e\u7ed3\u6784\u4e2d\u7684 dfs \u5e8f\uff0c\u7136\u540e\u533a\u95f4\u67e5\u8be2\u5373\u53ef\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nnamespace Wilson_Inversion{\ntypedef long long ll;\nvoid main();\n}\nint main(){\n\tWilson_Inversion::main();\n\treturn 0;\n}\nnamespace Wilson_Inversion{\nconst int N(1000010),M(100010);\nint n,q,tot1(1),tot2(1),tot4(1);\nll tot3;\nstruct trienode{\n\tint son[26],p;\n\tvector<pair<int,int> >pos;\n}trie[N>>1];\nint son[N][26],fa[N][20],len[N],dep[N],rt(1),tr[30000010],ls[30000010],rs[30000010],w0,le[M];\nll st[N],edn[N];\nint sta1[N],top,id[N];\nll sta2[N];\nchar s[N>>1];\nvector<int>ed[M],e[N];\nvoid ins(int x){\n\tint len(strlen(s+1)), now(1);\n\ted[x].resize(len + 1, 0);\n\tfor (int i(1); i <= len; ++i) {\n\t\tint op(s[i] - 'a');\n\t\tif (!trie[now].son[op]) trie[now].son[op] = ++tot1;\n\t\tnow = trie[now].son[op];\n\t\ttrie[now].pos.push_back(make_pair(x, i));\n\t}\n}\nvoid insert(int x, int y, int& z) {\n\tint p(y);\n\tint np(z = ++tot2);\n\tlen[np]=len[p]+1;\n\twhile (p && (!son[p][x])) {\n\t\tson[p][x] = np;\n\t\tp = fa[p][0];\n\t}\n\tif (!p)\n\t\tfa[np][0]=1;\n\telse {\n\t\tint q(son[p][x]);\n\t\tif (len[q] == len[p] + 1)\n\t\t\tfa[np][0] = q;\n\t\telse {\n\t\t\tint nq(++tot2);\n\t\t\tmemcpy(son[nq], son[q], sizeof(son[q]));\n\t\t\tfa[nq][0]=fa[q][0];\n\t\t\tlen[nq]=len[p]+1;\n\t\t\tfa[q][0]=fa[np][0]=nq;\n\t\t\twhile (p && son[p][x] == q) {\n\t\t\t\tson[p][x] = nq;\n\t\t\t\tp = fa[p][0];\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bfs() {\n\tqueue<int> q;\n\tq.push(1);\n\ttrie[1].p = 1;\n\twhile (!q.empty()) {\n\t\tint u(q.front());\n\t\tq.pop();\n\t\tfor (auto i : trie[u].pos) {\n\t\t\ted[i.first][i.second] = trie[u].p;\n\t\t}\n\t\tfor (int i(0); i < 26; ++i) {\n\t\t\tif (trie[u].son[i]) {\n\t\t\t\tinsert(i, trie[u].p, trie[trie[u].son[i]].p);\n\t\t\t\tq.push(trie[u].son[i]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int x) {\n\ttot3+=(len[x]-len[fa[x][0]]);\n\tst[x] = tot3;\n\tfor (int i(1); i <= 19; ++i) fa[x][i] = fa[fa[x][i - 1]][i - 1];\n\tfor (int i : e[x]) {\n\t\tdep[i] = dep[x] + 1;\n\t\tdfs(i);\n\t}\n\tedn[x] = tot3;\n}\nvoid pp(){\n\tint now(1),nowlen(0),l(strlen(s+1));\n\tfor(int i(1);i<=l;++i){\n\t\tint op(s[i]-'a');\n\t\twhile(!son[now][op]){\n\t\t\tnow=fa[now][0];\n\t\t\tnowlen=len[now];\n\t\t}\n\t\tnow=son[now][op];\n\t\t++nowlen;\n\t\tif(now==1)continue;\n\t\tsta1[++top]=now;\n\t\tsta2[top]=st[now]-(len[now]-nowlen);\n\t\tid[top]=top;\n\t}\n}\nint lcadfs(int x,int xdfs,int y,int ydfs){\n\tif(x==y)return min(xdfs,ydfs);\n\tif(dep[x]<dep[y])swap(x,y),swap(xdfs,ydfs);\n\tfor(int i(19);~i;--i){\n\t\tif(dep[fa[x][i]]<dep[y])continue;\n\t\tx=fa[x][i];\n\t}\n\tif(x==y)return ydfs;\n\tfor(int i(19);~i;--i){\n\t\tif(fa[x][i]==fa[y][i])continue;\n\t\tx=fa[x][i],y=fa[y][i];\n\t}\n\treturn st[fa[x][0]];\n}\npair<ll,ll> find(int p,int l,int r){\n\tint now(ed[p][r]),tlen(r-l+1);\n\tfor(int i(19);~i;--i){\n\t\tif(len[fa[now][i]]>=tlen)now=fa[now][i];\n\t}\n\treturn make_pair(st[now]-(len[now]-tlen),edn[now]);\n}\nvoid modify(int &x,ll l,ll r,ll pos,int num){\n\tif(l==1ll&&r==tot3){\n\t\t++l,--l;\n\t}\n\tif(!x)x=++tot4;\n\ttr[x]+=num;\n\tif(l==r)return;\n\tll mid((l+r)>>1);\n\tif(pos<=mid)modify(ls[x],l,mid,pos,num);\n\telse modify(rs[x],mid+1,r,pos,num);\n}\nint query(int x,ll l,ll r,ll L,ll R){\n\tif(L<=l&&r<=R)return tr[x];\n\tif(!x)return 0;\n\tll mid((l+r)>>1);\n\tint res(0);\n\tif(L<=mid)res+=query(ls[x],l,mid,L,R);\n\tif(R>mid)res+=query(rs[x],mid+1,r,L,R);\n\treturn res;\n}\nbool cmp(int x,int y){\n\treturn sta2[x]<sta2[y];\n}\nvoid main(){\n\tscanf(\"%d%d%d\",&n,&q,&w0);\n\tint A,B,C;\n\tif(w0){\n\t\tscanf(\"%d%d%d\",&A,&B,&C);\n\t}\n\tfor(int i(1);i<=n;++i){\n\t\tscanf(\"%s\",s+1);\n\t\tle[i]=strlen(s+1);\n\t\tins(i);\n\t}\n\tbfs();\n\tdep[1]=1;\n\tfor(int i(2);i<=tot2;++i)e[fa[i][0]].push_back(i);\n\tfor(int i(0);i<26;++i)son[0][i]=1;\n\tlen[0]=-1;\n\tdfs(1);\n\tint lst(0);\n\twhile(q--){\n\t\tint op;\n\t\tscanf(\"%d\",&op);\n\t\tif(op==1){\n\t\t\tscanf(\"%s\",s+1);\n\t\t\tif(w0==1){\n\t\t\t\tint x((1ll*A*lst+B)%C),l(strlen(s+1));\n\t\t\t\tfor(int i(1);i<=l;++i){\n\t\t\t\t\tswap(s[i],s[x%l+1]);\n\t\t\t\t\tx=(1ll*A*x+B)%C;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttop=0;\n\t\t\tpp();\n\t\t\tsort(id+1,id+1+top,cmp);\n\t\t\tmodify(rt,1ll,tot3,sta2[id[1]],1);\n\t\t\tfor(int i(2);i<=top;++i){\n\t\t\t\tmodify(rt,1ll,tot3,sta2[id[i]],1);\n\t\t\t\tmodify(rt,1ll,tot3,lcadfs(sta1[id[i-1]],sta2[id[i-1]],sta1[id[i]],sta2[id[i]]),-1);\n\t\t\t}\n\t\t}else{\n\t\t\tint p,l,r;\n\t\t\tscanf(\"%d%d%d\",&p,&l,&r);\n\t\t\tif(w0==1){\n\t\t\t\tint x((1ll*A*lst+B)%C);\n\t\t\t\tp=(p+x)%n+1;\n\t\t\t\tx=(1ll*A*x+B)%C;\n\t\t\t\tl=(l+x)%le[p]+1;\n\t\t\t\tx=(1ll*A*x+B)%C;\n\t\t\t\tr=(r+x)%le[p]+1;\n\t\t\t\tif(l>r)swap(l,r);\n\t\t\t}\n\t\t\tpair<ll,ll>t(find(p,l,r));\n\t\t\tprintf(\"%d\\n\",lst=query(1,1ll,tot3,t.first,t.second));\n\t\t}\n\t}\n}\n}\n```\n",
        "postTime": 1672283959,
        "uid": 576737,
        "name": "Wilson_Inversion",
        "ccfLevel": 7,
        "title": "RiOI Round 1 Div.1 D \u9898\u89e3"
    },
    {
        "content": "> [P8947 Angels & Demons](https://www.luogu.com.cn/problem/P8947)\n\n\u56e0\u4e3a\u67e5\u8be2\u548c\u6240\u6709\u8be2\u95ee\u4e32\u76f8\u5173\uff0c\u6240\u4ee5\u5728\u52a0\u5165\u8be2\u95ee\u4e32\u65f6\uff0c\u5b83\u5bf9\u6bcf\u4e2a\u6a21\u677f\u4e32\u7684\u8d21\u732e\u90fd\u8981\u8003\u8651\u5230\u3002\u56e0\u6b64\u53ea\u80fd\u5bf9\u6240\u6709\u6a21\u677f\u4e32\u7edf\u4e00\u5efa\u51fa\u7ed3\u6784\u3002\n\n\u56e0\u4e3a\u67e5\u8be2\u548c\u6a21\u677f\u4e32\u5b50\u4e32\u76f8\u5173\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7ed3\u6784\u9700\u8981\u63cf\u8ff0\u6240\u6709\u6a21\u677f\u4e32\u7684\u6240\u6709\u5b50\u4e32\u3002\u6211\u4eec\u8003\u8651\u5e7f\u4e49 SAM\u3002\n\n\u52a0\u5165\u8be2\u95ee\u4e32 $T$\uff0c\u8003\u8651\u5b83\u7684\u8d21\u732e\u3002\u6211\u4eec\u5c06 $T$ \u8f93\u5165 SAM\uff0c\u5f97\u5230\u5b83\u7684\u6bcf\u4e2a\u524d\u7f00\u7684\u6700\u957f\u7684\u7b49\u4e8e\u67d0\u4e2a\u6a21\u677f\u4e32\u5b50\u4e32\u7684\u540e\u7f00\u957f\u5ea6 $L$\uff0c\u4ee5\u53ca\u5bf9\u5e94\u72b6\u6001 $p$\u3002\u6839\u636e SAM \u7684 link \u6811\u7684\u6027\u8d28\uff0c\u53ef\u77e5 $T$ \u5bf9\u67d0\u5b50\u4e32\u4ea7\u751f\u8d21\u732e\u7684\u5145\u8981\u6761\u4ef6\u662f\uff1a\n\n- \u5b58\u5728 $p$ \u5728\u8be5\u5b50\u4e32\u5bf9\u5e94\u72b6\u6001\u7684\u5b50\u6811\u5185\uff08\u4e0d\u5305\u62ec\u81ea\u8eab\uff09\u3002\n- \u5b58\u5728 $p$ \u7b49\u4e8e\u8be5\u5b50\u4e32\u7684\u5bf9\u5e94\u72b6\u6001\uff0c\u4e14\u5b50\u4e32\u957f\u5ea6\u4e0d\u5927\u4e8e\u5bf9\u5e94\u7684 $L$\u3002\n\n\u76f8\u540c\u7684 $p$ \u53ea\u4fdd\u7559 $L$ \u6700\u5927\u7684\u4e00\u4e2a\uff0c\u7136\u540e\u5220\u53bb\u6240\u6709\u5b50\u6811\u5185\u8fd8\u6709\u5176\u5b83 $p$ \u7684 $(p, L)$\u3002\u63a5\u4e0b\u6765\uff0c\u5c06\u6240\u6709 $p$ \u7684\u7236\u4eb2\u5230\u6839\u7684\u94fe\u5e76\u4e0a\u6240\u6709\u8282\u70b9\u7684\u7b54\u6848\u52a0 $1$\uff0c\u8868\u793a\u5bf9\u5e94\u72b6\u6001\u7684\u6240\u6709\u5b50\u4e32\u7b54\u6848\u5747\u52a0 $1$\uff0c\u94fe\u52a0\u5355\u70b9\u67e5\u8f6c\u6210\u5355\u70b9\u52a0\u5b50\u6811\u67e5\u3002\u6700\u540e\u5c06\u6240\u6709 $p$ \u7684\u6240\u6709\u957f\u5ea6\u4e0d\u5927\u4e8e $L$ \u7684\u5b50\u4e32\u7b54\u6848\u52a0 $1$\uff0c\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u8bf4\u767d\u4e86\uff0c\u5c31\u662f\u628a Divljak \u653e\u5728\u5e7f\u4e49 SAM \u4e0a\u3002\n\n\u65f6\u7a7a\u590d\u6742\u5ea6\u7ebf\u6027\u5bf9\u6570\u52a0\u7ebf\u6027\u5b57\u7b26\u96c6\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n\nconstexpr int N = 1e6 + 5;\nconstexpr int M = N << 4;\nconstexpr int K = 20;\nconstexpr int S = 26;\n\nnamespace GSAM {\n  int node, cnt = 1;\n  int son[N][S], len[N], fa[N], anc[K][N];\n  int ins(int p, int it) {\n    int to = son[p][it];\n    if(to && len[p] + 1 == len[to]) return to;\n    int cur = ++cnt;\n    len[cur] = len[p] + 1;\n    while(!son[p][it]) son[p][it] = cur, p = fa[p];\n    if(!p) return fa[cur] = 1, cur;\n    int q = son[p][it];\n    if(len[p] + 1 == len[q]) return fa[cur] = q, cur;\n    int cl = ++cnt;\n    len[cl] = len[p] + 1;\n    memcpy(son[cl], son[q], S << 2);\n    fa[cl] = fa[q], fa[q] = fa[cur] = cl;\n    while(son[p][it] == q) son[p][it] = cl, p = fa[p];\n    return to ? cl : cur;\n  }\n  void build() {\n    for(int i = 0; i < K; i++)\n      for(int j = 1; j <= cnt; j++) {\n        if(i) anc[i][j] = anc[i - 1][anc[i - 1][j]];\n        else anc[i][j] = fa[j];\n      }\n  }\n  int locate(int pos, int L) {\n    for(int i = K - 1; ~i; i--) {\n      int q = anc[i][pos];\n      if(len[q] >= L) pos = q;\n    }\n    return pos;\n  }\n  void path(char *s, int m, auto P) {\n    int L = 0, p = 1;\n    for(int i = 1; i <= m; i++) {\n      int it = s[i] - 'a';\n      while(p > 1 && !son[p][it]) L = len[p = fa[p]];\n      if(son[p][it]) L++, p = son[p][it];\n      P[i - 1] = {p, L};\n    }\n  }\n}\n\nnamespace BIT {\n  int c[N];\n  void add(int x, int v) {\n    while(x < N) c[x] += v, x += x & -x;\n  }\n  int query(int x) {\n    int s = 0;\n    while(x) s += c[x], x -= x & -x;\n    return s;\n  }\n  int query(int l, int r) {\n    return query(r) - query(l - 1);\n  }\n}\n\nnamespace SEG {\n  int node, R[N], ls[M], rs[M], val[M];\n  void modify(int l, int r, int p, int &x) {\n    if(!x) x = ++node;\n    val[x]++;\n    if(l == r) return;\n    int m = l + r >> 1;\n    if(p <= m) modify(l, m, p, ls[x]);\n    else modify(m + 1, r, p, rs[x]);\n  }\n  int query(int l, int r, int ql, int qr, int x) {\n    if(ql <= l && r <= qr || !x) return val[x];\n    int m = l + r >> 1, ans = 0;\n    if(ql <= m) ans = query(l, m, ql, qr, ls[x]);\n    if(m < qr) ans += query(m + 1, r, ql, qr, rs[x]);\n    return ans;\n  }\n}\n\nusing GSAM::fa;\nusing GSAM::len;\nusing GSAM::cnt;\n\nint n, q, lg[N], w0, A, B, C = 1;\nstring str[N];\nvector<int> pos[N], e[N];\n\nint dn, dfn[N], dep[N], sz[N], mi[K][N];\nvoid dfs(int id) {\n  dfn[id] = ++dn, sz[id] = 1;\n  mi[0][dn] = fa[id], dep[id] = dep[fa[id]] + 1;\n  for(int it : e[id]) dfs(it), sz[id] += sz[it];\n}\nbool isa(int u, int v) {\n  return dfn[u] <= dfn[v] && dfn[v] < dfn[u] + sz[u];\n}\nint get(int x, int y) {\n  return dep[x] < dep[y] ? x : y;\n}\nint lca(int u, int v) {\n  if(u == v) return u;\n  if((u = dfn[u]) > (v = dfn[v])) swap(u, v);\n  int d = lg[v - u++];\n  return get(mi[d][u], mi[d][v - (1 << d) + 1]);\n}\n\n\nint main() {\n  #ifdef ALEX_WEI\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n  #endif\n  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cin >> n >> q >> w0;\n  if(w0) cin >> A >> B >> C;\n  for(int i = 1, lst = 1; i <= n; i++, lst = 1) {\n    cin >> str[i], pos[i].resize(str[i].size());\n    for(int j = 0; j < str[i].size(); j++) {\n      lst = pos[i][j] = GSAM::ins(lst, str[i][j] - 'a');\n    }\n  }\n  GSAM::build();\n  for(int i = 2; i <= cnt; i++) e[fa[i]].push_back(i);\n  for(int i = 2; i <= cnt; i++) lg[i] = lg[i >> 1] + 1;\n  dfs(1), assert(cnt == dn);\n  for(int i = 1; i <= lg[cnt]; i++) {\n    for(int j = 1; j + (1 << i) - 1 <= cnt; j++) {\n      mi[i][j] = get(mi[i - 1][j], mi[i - 1][j + (1 << i - 1)]);\n    }\n  }\n\n  for(int _ = 1, lst = 0; _ <= q; _++) {\n    int op, x = (1ll * A * lst + B) % C;\n    cin >> op;\n    if(op == 1) {\n      static char s[N];\n      cin >> s + 1;\n      int m = strlen(s + 1);\n      if(w0) {\n        for(int i = 1; i <= m; i++) {\n          swap(s[i], s[x % m + 1]);\n          x = (1ll * A * x + B) % C;\n        }\n      }\n      static pair<int, int> P[N], Q[N];\n      GSAM::path(s, m, P);\n      sort(P, P + m, [&](auto a, auto b) {\n        return a.fi != b.fi ? dfn[a.fi] < dfn[b.fi] : a.se < b.se;\n      });\n      int c = 0;\n      for(int i = 0; i < m; i++) {\n        while(c && isa(Q[c - 1].fi, P[i].fi)) c--;\n        Q[c++] = P[i];\n      }\n      if(c == 1 && Q[0].fi == 1) continue;\n      for(int i = 0; i < c; i++) {\n        int id = Q[i].fi;\n        BIT::add(dfn[fa[id]], 1);\n        if(i) BIT::add(dfn[lca(fa[id], Q[i - 1].fi)], -1);\n        SEG::modify(len[fa[id]] + 1, len[id], Q[i].se, SEG::R[id]);\n      }\n    }\n    else {\n      int p, l, r;\n      cin >> p >> l >> r;\n      if(w0) {\n        p = (p + x) % n + 1;\n        x = (1ll * A * x + B) % C;\n        l = (l + x) % str[p].size() + 1;\n        x = (1ll * A * x + B) % C;\n        r = (r + x) % str[p].size() + 1;\n        x = (1ll * A * x + B) % C;\n        if(l > r) swap(l, r);\n      }\n      int L = r - l + 1;\n      p = GSAM::locate(pos[p][r - 1], L);\n      int ans = BIT::query(dfn[p], dfn[p] + sz[p] - 1);\n      ans += SEG::query(len[fa[p]] + 1, len[p], L, len[p], SEG::R[p]);\n      cout << (lst = ans) << \"\\n\";\n    }\n  }\n\n  cerr << 1e3 * clock() / CLOCKS_PER_SEC << \" ms\\n\";\n  return 0;\n}\n\n```",
        "postTime": 1676180260,
        "uid": 123294,
        "name": "Alex_Wei",
        "ccfLevel": 10,
        "title": "P8947 Angels & Demons"
    }
]