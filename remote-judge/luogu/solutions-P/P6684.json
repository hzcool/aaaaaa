[
    {
        "content": "\u6ca1\u6709\u5947\u73af<->\u4e8c\u5206\u56fe\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u8be2\u95ee\u5220\u53bb\u4e00\u4e2a\u533a\u95f4\u7684\u8fb9\u4e4b\u540e\uff0c\u539f\u56fe\u662f\u5426\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002\n\n\u4fdd\u7559\u7684\u8fb9\u4e0d\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u8fd9\u4e2a\u4e0d\u592a\u65b9\u4fbf\uff0c\u8003\u8651\u5c06\u8fb9\u7684\u5e8f\u5217\u6392\u6210\u4e00\u4e2a\u73af\uff0c\u8fd9\u6837\u5c31\u662f\u6c42\uff1a\u73af\u4e0a\u7684\u67d0\u4e00\u4e2a\u533a\u95f4\u7684\u8fb9\u662f\u5426\u5f62\u6210\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002\n\n\u5bf9\u6bcf\u4e00\u4e2a\u4f4d\u7f6e $i$\uff0c\u9884\u5904\u7406\u51fa\uff1a\u4ece\u5b83\u5f80\u540e\u6700\u591a\u591a\u5c11\u6761\u8fde\u7eed\u7684\u8fb9\uff0c\u6ee1\u8db3\u8fd9\u4e9b\u8fb9\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\uff0c\u4e14\u6ca1\u6709\u8fb9\u88ab\u52a0\u5165\u4e24\u6b21\uff08\u53ef\u80fd\u4ece\u73af\u7684\u53e6\u4e00\u7aef\u7ed5\u56de\u6765)\u3002\u6709\u4e86\u8fd9\u4e2a\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u901f\u56de\u7b54\u8be2\u95ee\u4e86\u3002\n\n\u8003\u8651\u4f7f\u7528\u53cc\u6307\u9488\u6765\u9884\u5904\u7406\u8fd9\u4e2a\u4e1c\u897f\uff0c\u4e5f\u5c31\u662f\u652f\u6301\u52a0\u8fb9\u5220\u8fb9\u5224\u65ad\u662f\u5426\u662f\u4e8c\u5206\u56fe\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528 LCT \u7ef4\u62a4\u5173\u4e8e\u52a0\u5165\u65f6\u95f4\u7684\u6700\u5927\u751f\u6210\u6811\uff0c\u5c31\u53ef\u4ee5\u5feb\u901f\u52a0\u8fb9\u5220\u8fb9\u4e86\u3002\n\n\u590d\u6742\u5ea6 $O(n \\log n + q)$\uff0c\u6709\u70b9\u5361\u5e38\u6570\uff0c\u9700\u8981\u8fdb\u884c\u4e00\u5b9a\u7684\u5e38\u6570\u4f18\u5316\u3002\n\n```\n\n#include <bits/stdc++.h>\n#define maxn 400005\n\nint t[maxn]={0},x[maxn],y[maxn],ch[maxn][2],fa[maxn]={0},rev[maxn]={0},vis[maxn],\nmax[maxn]={0},a[maxn],b[maxn],n,m,q,opt[maxn],lim[maxn]={0},size[maxn],R[maxn];\nint stk[maxn],top;\n\nint nxt(int x) { x++; if (x>m) x = 1; return x; }\n\nint gmax(int a,int b) {return t[a]>t[b]?a:b;}\n\nvoid update(int x) {max[x]=gmax(gmax(max[ch[x][0]],max[ch[x][1]]),x);size[x]=size[ch[x][0]]^size[ch[x][1]]^(x>n);}\nvoid reverse(int x) {std::swap(ch[x][0],ch[x][1]); rev[x]^=1;}\nvoid pushdown(int x) {if (rev[x]) {reverse(ch[x][0]);reverse(ch[x][1]);rev[x]=0;}}\nint not_root(int x) {return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}\n\nvoid rotate(int x) {\n\tint f=fa[x],g=fa[f],l=ch[f][1]==x;\n\tif (not_root(f)) ch[g][ch[g][1]==f]=x; \n\tch[f][l]=ch[x][l^1]; fa[ch[x][l^1]]=f;\n\tfa[f]=x;fa[x]=g; ch[x][l^1]=f;\n\tupdate(f);update(x); \n}\n\nvoid spaly(int x) {\n    int u=x; stk[++top]=u;\n    while (not_root(u)) {stk[++top]=(u=fa[u]);}\n    while (top) {pushdown(stk[top--]);}\n    while(not_root(x)){\n    \trotate(x);\n  \t \tif (not_root(fa[x])&&not_root(x)) rotate(rand()%2?fa[x]:x);\n    }\n}\n\nvoid access(int x) {\n\tfor (int y=0;x;x=fa[y=x]) {\n\t\tspaly(x); ch[x][1]=y; update(x);\n\t}\n}\n\nvoid make_root(int x) {\n\taccess(x); spaly(x); reverse(x);\n}\n\nint find_root(int x) {\n\taccess(x); spaly(x); while (ch[x][0]) pushdown(x),x=ch[x][0]; return x;\n}\n\nvoid split(int x,int y) {\n//\tprintf(\"split:%d %d\\n\",x,y);\n\tmake_root(y);access(x);spaly(y);}\n\nvoid link(int x,int y) {\n\tmake_root(x); fa[x]=y;// printf(\"lk:%d-%d\\n\",x,y);\n} \n\nvoid cut(int x,int y) {\n\tmake_root(x); access(y); spaly(x); ch[x][1]=fa[y]=0;\n}\n\nint dis(int a,int b) {\n\tmake_root(b); if (find_root(a) != b) {return 1;}\n\t//printf(\"size[b] = %d\\n\",size[b]);\n\treturn size[a];\n}\n\nvoid Cut(int b) {\n//\tprintf(\"cut %d\\n\",b);\n\tvis[b]=0;\n\tcut(x[b],b+n),cut(b+n,y[b]);\n}\n\nvoid Link(int a,int w) {\n\tvis[a]=1;\n\t//printf(\"Link %d %d\\n\",a,w);\n\tt[a+n] = 2*m+1-w;\n//\tprintf(\"link:%d<->%d\\n\",x[a],y[a]);\n\tmake_root(x[a]);\n\tif (find_root(y[a])!=x[a]) {\n\t\tlink(x[a],a+n),link(a+n,y[a]); }\n\telse {\n\t\t//printf(\"interact\\n\");\n\t\t//split(y[a],x[a]); //spaly(x[a]);\n\t\tif (t[max[y[a]]]>t[a+n]) {\n\t\t\tint b=max[y[a]]-n; \n\t\t//\tprintf(\"%d\\n\",b);\n\t\t//\tprintf(\"cut:%d<->%d\\n\",x[b],y[b]);\n\t\t\tCut(b);\n\t\t\tlink(x[a],a+n),link(a+n,y[a]);\n\t\t}\n\t}\n}\n\nint read() {\n\tint x = 0; char c = getchar();\n\twhile (c<'0'||c>'9')c=getchar();\n\twhile('0'<=c&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x;\n}\n\nint main() {\n\t//freopen(\"c.in\",\"r\",stdin);\n//\tfreopen(\"c2.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&m,&q);\n\tfor (int i=1;i<=m;++i) {\n\t\tx[i]=read();y[i]=read();\n\t//\tconj[x[i]][y[i]]=conj[y[i]][x[i]]=i;\n\t} int p = 0,w=0,last=0;\n\tfor (int i = 1; i <= m; ++ i) {\n\t\twhile (1) {\n\t\t\tif (w>=m&&nxt(p) == i ) break;\n\t\t\tif (dis(x[nxt(p)],y[nxt(p)])%2==0){ last = max[y[nxt(p)]]-n; break;}\n\t\t//\tprintf(\"p->%d\\n\",nxt(p));\n\t\t\tp = nxt(p); w ++;\n\t\t\tLink(p,w);\n\t\t} R[i] = p;\n\t//\tprintf(\"R[%d] = %d\\n\",i,p);\n\t\tif (vis[i]) { Cut(i); if (last == i) last = 0; }\n\t} //for (int i = 1; i <= m; ++ i) printf(\"%d \",R[i]); \n\twhile (q--) {\n\t\tint l,r;\n\t\tl=read();r=read();\n\t\tint p = R[nxt(r)];\n\t\tif ((p < nxt(r) && p >= l-1) || (p == m && l == 1) || (r == m && p >= l-1)) puts(\"NO\");\n\t\telse puts(\"YES\");\n\t}\n\treturn 0;\n}\n\n\t\t\t\n\t\n\t\n\t\n```\n",
        "postTime": 1595467598,
        "uid": 100014,
        "name": "Niko\uff01",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P6684 \u3010[BalticOI 2020 Day1] \u5c0f\u4e11\u3011"
    }
]