[
    {
        "content": "\u65b9\u6cd51\uff1a\n\n\n\u9884\u5904\u7406\u6bcf\u4e2a\u70b9\u5230\u6839\u8282\u70b9\u7684xor\u503c\u4e4b\u540e\u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u8def\u5f84\u4e0a\u4efb\u610f\u4e24\u70b9xor\u7684\u548c\uff0c\u8fd9\u4e2a\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u7ef4\u62a4\u67d0\u4e00\u4f4d\u662f1\u7684\u4e2a\u6570\uff0c\u7136\u540e\u5206\u522b\u7edf\u8ba1\u8d21\u732e\u6765\u505a\u5230\u3002\u81f3\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u5c31\u7b49\u4ef7\u4e8e\u4e00\u4e2a\u5b50\u6811\u67d0\u4e00\u4f4d\u7ffb\u8f6c\u4fee\u6539\u3002\u5177\u4f53\u7528\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u5b9e\u73b0\u5373\u53ef\u3002\n\n\n\u65b9\u6cd52\uff1a\n\n\n\u8003\u8651\u5e8f\u5217\u4e0a\u7684\u505a\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u53d1\u5de6\u53f3\u5b50\u6811\u7684\u7b54\u6848\u548c\u6bcf\u4e00\u4f4d\u7684\u60c5\u51b5\u6765\u5408\u5e76\u7b54\u6848\u3002\u628a\u6254\u5230\u6811\u4e0a\u53bb\u53ea\u8981\u52a0\u4e0a\u6811\u94fe\u5256\u5206\u5373\u53ef\u3002\u8fd9\u79cd\u65b9\u6cd5\u5199\u8d77\u6765\u6bd4\u7b2c\u4e00\u79cd\u65b9\u6cd5\u9ebb\u70e6\u4e00\u4e9b\u3002\n\n\n\u4e24\u79cd\u505a\u6cd5\u7684\u590d\u6742\u5ea6\u90fd\u662fO(nlog^2n\\*w)\u7684\u3002\n",
        "postTime": 1476011530,
        "uid": 3182,
        "name": "Created_equal1",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "[\u4f20\u9001\u95e8 qwq](https://www.luogu.com.cn/problem/P3401)\n\n\u672c\u9898\u89e3\u4f7f\u7528\u6811\u5256\u5957\u7ebf\u6bb5\u6811\uff0c\u8001\u5c11\u7686\u5b9c\u3002\n\n\u591a\u6b21\u8be2\u95ee\u6811\u7684\u4e00\u6761\u94fe\u4e0a\u6240\u6709\u5b50\u8def\u5f84\u5404\u8fb9\u5f02\u6216\u548c\u7684\u548c\uff0c\u8fb9\u6743\u7ed9\u5b9a\uff0c\u652f\u6301\u5355\u8fb9\u4fee\u6539\u3002\n\n\u5148\u8003\u8651\u5982\u679c\u5199\u66b4\u529b\u8981\u600e\u4e48\u505a\u3002\u66b4\u529b\u679a\u4e3e\u4e00\u6761\u94fe\u4e0a\u6240\u6709\u7684\u70b9\u5bf9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u5bf9\uff0c\u66b4\u529b\u628a\u8fd9\u4e00\u5bf9\u70b9\u4e4b\u95f4\u7684\u6bcf\u6761\u8fb9\u5f02\u6216\u8d77\u6765\uff0c\u7136\u540e\u628a\u6bcf\u6b21\u7684\u7ed3\u679c\u76f8\u52a0\u3002\u8003\u8651\u4f18\u5316\u628a\u4e00\u5bf9\u70b9\u4e4b\u95f4\u7684\u6240\u6709\u8fb9\u5f02\u6216\u8d77\u6765\u8fd9\u4e00\u8fc7\u7a0b\uff0c\u53ef\u4ee5\u7ef4\u62a4\u4e00\u4e2a\u6570\u7ec4 $s$\uff0c$s_i$ \u4ee3\u8868\u4ece $1$ \u53f7\u70b9\u5230 $i$ \u53f7\u70b9\u8fd9\u4e00\u6761\u94fe\u5404\u8fb9\u7684\u5f02\u6216\u548c\u3002\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u5bf9 $(i,j)$ \uff0c\u663e\u7136\u5b83\u4eec\u4e4b\u95f4\u5404\u8fb9\u7684\u5f02\u6216\u548c\u5c31\u662f $s_i \\oplus s_j$\u3002\u7136\u540e\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u5bf9\u4e8e\u94fe\u4e0a\u6240\u6709\u7684\u70b9\u7684 $s$ \u503c\uff0c\u6c42\u51fa\u4e24\u4e24\u5f02\u6216\u548c\u4e4b\u548c\uff0c\u518d\u8003\u8651\u4f18\u5316\u6389\u66b4\u529b\u679a\u4e3e\u70b9\u5bf9\u8fd9\u4e00\u8fc7\u7a0b\u3002\n\n\u6ce8\u610f\u5230\u6743\u503c\u975e\u5e38\u4e4b\u5c0f\uff0c\u8fd9\u91cc\u8981\u7528\u5230\u4e00\u79cd\u5f88\u5999\u7684\u65b9\u6cd5\uff1a\u6309\u4e8c\u8fdb\u5236\u9010\u4f4d\u7ef4\u62a4\uff0c\u5176\u5b9e\u662f\u56de\u5f52\u4e86\u201c\u5f02\u6216\u201d\u6700\u672c\u8d28\u7684\u5730\u65b9\uff1a\u76f8\u540c\u5f97 $0$\uff0c\u4e0d\u76f8\u540c\u5f97 $1$\u3002\u800c\u672c\u9898\u5f53\u4e2d\u662f\u8ba1\u7b97\u4e00\u4e9b\u6570\u503c\u4e24\u4e24\u5f02\u6216\u518d\u6c42\u548c\uff0c\u4e0d\u59a8\u8003\u8651\u6bcf\u4e00\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f\u591a\u5c11\uff0c\u663e\u7136\u6211\u4eec\u628a\u6bcf\u4e00\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u7684\u8d21\u732e\u76f8\u52a0\u5c31\u662f\u6700\u7ec8\u7b54\u6848\u3002\n\n\u5047\u8bbe\u4e8c\u8fdb\u5236\u6700\u4f4e\u4f4d\u662f\u7b2c $0$ \u4f4d\uff0c\u73b0\u5728\u8003\u8651\u7b2c $i$ \u4f4d\u7684\u8d21\u732e\u3002\n\n\u5047\u5982\u5f85\u6c42\u7684\u6570\u4e2d\uff0c\u7b2c $i$ \u4f4d\u4e3a $1$ \u7684\u6709 $a$ \u4e2a\uff0c\u7b2c $i$ \u4f4d\u4e3a $0$ \u7684\u6709 $b$ \u4e2a\uff0c\u5219\u7b2c $i$ \u4f4d\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a $a\\times b\\times 2^i$\u3002\n\n\u4e24\u4e24\u5f02\u6216\uff0c\u6211\u4eec\u53ef\u4ee5\u4f9d\u6b21\u62ff\u7740\u4e00\u4e2a\u7b2c $i$ \u4f4d\u4e3a $1$ \u7684\u6570\u548c\u6240\u6709\u7684\u6570\u5206\u522b\u53bb\u505a\u5f02\u6216\uff0c\u8fd9 $a$ \u4e2a\u6570\u5206\u522b\u4f1a\u548c $b$ \u4e2a\u6570\u5f02\u6216\u4ea7\u751f $2^i$ \u7684\u8d21\u732e\uff08\u56e0\u4e3a\u53ea\u6709 $b$ \u4e2a\u6570\u5728\u7b2c $i$ \u4e0a\u4e0e\u5b83\u4e0d\u540c\uff09\uff0c\u603b\u8d21\u732e\u5c31\u662f $a\\times b\\times 2^i$\uff08\u4ee5\u4e0a\u6240\u8bf4\u7684\u8d21\u732e\u662f\u4ec5\u4ec5\u8003\u8651\u7b2c $i$ \u4f4d\uff09\u3002\n\n\u4e8e\u662f\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\uff0c\u6bcf\u7247\u53f6\u5b50\u4e0a\u653e\u7740\u76f8\u5e94 $s$ \u503c\u4e8c\u8fdb\u5236\u4e0b\u7684 $1$ \u548c $0$ \u7684\u4e2a\u6570\uff0c\u7ef4\u62a4\u533a\u95f4\u548c\u3002\u6bcf\u6b21\u8be2\u95ee\u5c31\u53bb\u67e5\u8be2\u94fe\u4e0a $0$ \u548c $1$ \u7684\u4e2a\u6570\u4ece\u800c\u8ba1\u7b97\u7b54\u6848\uff0c\u7ed3\u5408\u6811\u5256\u5373\u53ef\u3002\n\n\u5443\u5176\u5b9e\u53ea\u7ef4\u62a4 $1$ \u7684\u4e2a\u6570\u5c31\u597d\u4e86\uff0c\u56e0\u4e3a\u8be2\u95ee\u7684\u94fe\u4e0a\u603b\u5171\u7684\u70b9\u6570\u5f88\u597d\u6c42\uff08\u4e0b\u6587\u5c31\u662f\u6309\u7167\u8fd9\u6837\u8bb2\u7684\uff09\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u53d7\u5230\u5f71\u54cd\u7684\u70b9\u5c31\u662f\u6240\u6709\u5411\u6839\u8282\u70b9\u8d70\u4f1a\u7ecf\u8fc7\u8fd9\u6761\u8fb9\u7684\u70b9\uff0c\u4e5f\u5c31\u662f\u4ee5\u5f85\u4fee\u6539\u8fb9\u6df1\u5ea6\u5927\u7684\u7aef\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u70b9\uff0c\u6bcf\u6b21\u4fee\u6539\u8981\u5bf9\u5b50\u6811\u8fdb\u884c\u4fee\u6539\u3002\n\n\u5982\u4f55\u4fee\u6539\uff1f\u5bf9\u4e8e\u6bcf\u4e2a $i$\uff0c\u5982\u679c\u4fee\u6539\u540e\u7684\u503c\u7684\u4e8c\u8fdb\u5236\u4e0b\u7b2c $i$ \u4f4d\u548c\u8fd9\u6761\u8fb9\u539f\u6765\u7684\u503c\u7684\u4e8c\u8fdb\u5236\u4e0b\u7b2c $i$ \u4f4d\u76f8\u540c\uff0c\u4e0d\u7528\u64cd\u4f5c\uff0c\u5426\u5219\u628a\u8fd9\u4e2a\u5b50\u6811\u5bf9\u5e94\u7684\u7ebf\u6bb5\u6811\u533a\u95f4\u4e2d\u7ef4\u62a4\u4e8c\u8fdb\u5236\u7b2c $i$ \u4f4d $1$ \u7684\u4e2a\u6570\u7684\u5143\u7d20\u503c\u6539\u53d8\u4e3a\u533a\u95f4\u957f\u5ea6\u51cf\u539f\u503c\uff0c\u518d\u6253\u4e0a\u4e00\u4e2a tag\u3002\u4e3a\u4f55\u8fd9\u4e48\u505a\uff1f\u5982\u679c\u7b2c $i$ \u4f4d\u53d1\u751f\u6539\u53d8\uff0c\u5219\u5b50\u6811\u4e2d\u8fd9\u4e00\u4f4d\u539f\u672c\u662f $1$ \u7684\u5c31\u53d8\u6210 $0$\uff0c\u539f\u672c\u662f $0$ \u7684\u5c31\u53d8\u6210 $1$\uff0c\u5176\u5b9e\u662f\u4e00\u4e2a $0\u30011$ \u4e2a\u6570\u4ea4\u6362\u7684\u64cd\u4f5c\u3002\uff08\u6211\u5f00\u4e86\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u70b9\u548c\u4ed6\u7236\u4eb2\u4e4b\u95f4\u7684\u8fb9\u5f53\u524d\u7684\u6743\u503c\u662f\u591a\u5c11\uff09\n\n\u7136\u540e\u5c31\u8bb2\u5b8c\u4e86 qwq\u3002\n\n\u6709\u4efb\u4f55\u4e0d\u61c2\u7684\u5730\u65b9\u6216\u662f\u9898\u89e3\u6709\u5565\u95ee\u9898\u968f\u65f6\u79c1\u4fe1~~\u9a9a\u6270~~\u3002![](//\u56fe.tk/3)\n\n\u4ee3\u7801\uff1a\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=30010;\nint read(){\n\tint ss=0,ww=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-')\n\t\t\tww=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\tss=ss*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn ss*ww;\n}\nint head[N],to[N*2],nex[N*2],e[N*2],cnt;\nvoid add(int x,int y,int z){\n\tcnt++;\n\tto[cnt]=y;\n\tnex[cnt]=head[x];\n\thead[x]=cnt;\n\te[cnt]=z;\n}\nint n,m;\nint tot,dfn[N],tp[N],dep[N],fa[N],sz[N],son[N],s[N],a[N],in[N];\nvoid dfs1(int x,int f){\n\tfa[x]=f;\n\tdep[x]=dep[f]+1;\n\tsz[x]=1;\n\tint maxn=-1;\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tint y=to[i];\n\t\tif(y==f)\n\t\t\tcontinue;\n\t\ts[y]=(s[x]^e[i]);\n\t\tin[y]=e[i];\n\t\tdfs1(y,x);\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>maxn){\n\t\t\tson[x]=y;\n\t\t\tmaxn=sz[y];\n\t\t}\n\t}\n}\nvoid dfs2(int x,int top){\n\ttp[x]=top;\n\ttot++;\n\tdfn[x]=tot;\n\ta[tot]=s[x];\n\tif(son[x])\n\t\tdfs2(son[x],top);\n\tfor(int i=head[x];i;i=nex[i]){\n\t\tint y=to[i];\n\t\tif(y==fa[x]||y==son[x])\n\t\t\tcontinue;\n\t\tdfs2(y,y);\n\t}\n}\nstruct ST{\n\tint b[15];\n\tint tag[15];\n}st[N*4];\nvoid build(int root,int l,int r){\n\tif(l==r){\n\t\tint x=a[l];\n\t\tfor(int i=0;i<=10;i++)\n\t\t\tif((1<<i)&x)\n\t\t\t\tst[root].b[i]=1;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(root*2,l,mid);\n\tbuild(root*2+1,mid+1,r);\n\tfor(int i=0;i<=10;i++)\n\t\tst[root].b[i]=st[root*2].b[i]+st[root*2+1].b[i];\n}\nint res[15];\nint lca(int x,int y){\n\twhile(tp[x]!=tp[y]){\n\t\tif(dep[tp[x]]<dep[tp[y]])\n\t\t\tswap(x,y);\n\t\tx=fa[tp[x]];\n\t}\n\tif(dep[x]>dep[y])\n\t\treturn y;\n\treturn x;\n}\nvoid push_down(int root,int l,int r){\n\tint mid=(l+r)/2;\n\tfor(int i=0;i<=10;i++){\n\t\tif(!st[root].tag[i])\n\t\t\tcontinue;\n\t\tst[root].tag[i]=0;\n\t\tst[root*2].b[i]=mid-l+1-st[root*2].b[i];\n\t\tst[root*2+1].b[i]=r-mid-st[root*2+1].b[i];\n\t\tst[root*2].tag[i]^=1;\n\t\tst[root*2+1].tag[i]^=1;\n\t}\n}\nvoid ask(int root,int l,int r,int x,int y){\n\tif(l>=x&&r<=y){\n\t\tfor(int i=0;i<=10;i++)\n\t\t\tres[i]+=st[root].b[i];\n\t\treturn;\n\t}\n\tpush_down(root,l,r);\n\tint mid=(l+r)/2;\n\tif(mid>=x)\n\t\task(root*2,l,mid,x,y);\n\tif(mid+1<=y)\n\t\task(root*2+1,mid+1,r,x,y);\n}\nvoid change(int root,int l,int r,int x,int y,int k){\n\tif(l>=x&&r<=y){\n\t\tst[root].tag[k]^=1;\n\t\tst[root].b[k]=r-l+1-st[root].b[k];\n\t\treturn;\n\t}\n\tpush_down(root,l,r);\n\tint mid=(l+r)/2;\n\tif(mid>=x)\n\t\tchange(root*2,l,mid,x,y,k);\n\tif(mid+1<=y)\n\t\tchange(root*2+1,mid+1,r,x,y,k);\n\tfor(int i=0;i<10;i++)\n\t\tst[root].b[i]=st[root*2].b[i]+st[root*2+1].b[i];\n}\nsigned main(){\n\tn=read();\n\tm=read();\n\tfor(int i=1;i<n;i++){\n\t\tint x,y,z;\n\t\tx=read();\n\t\ty=read();\n\t\tz=read();\n\t\tadd(x,y,z);\n\t\tadd(y,x,z);\n\t}\n\tdfs1(1,1);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\tint p[15];\n\tfor(int i=1;i<=m;i++){\n\t\tint opt;\n\t\topt=read();\n\t\tif(opt==1){\n\t\t\tint x,y;\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tint xx=x,yy=y;\n\t\t\tmemset(p,0,sizeof(p));\n\t\t\twhile(tp[x]!=tp[y]){\n\t\t\t\tif(dep[tp[x]]<dep[tp[y]])\n\t\t\t\t\tswap(x,y);\n\t\t\t\tmemset(res,0,sizeof(res));\n\t\t\t\task(1,1,n,dfn[tp[x]],dfn[x]);\n\t\t\t\tfor(int i=0;i<=10;i++)\n\t\t\t\t\tp[i]+=res[i];\n\t\t\t\tx=fa[tp[x]];\n\t\t\t}\n\t\t\tmemset(res,0,sizeof(res));\n\t\t\tif(dep[x]>dep[y])\n\t\t\t\tswap(x,y);\n\t\t\task(1,1,n,dfn[x],dfn[y]);\n\t\t\tfor(int i=0;i<=10;i++)\n\t\t\t\tp[i]+=res[i];\n\t\t\tint LCA=lca(xx,yy);\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<=10;i++)\n\t\t\t\tans+=(1<<i)*p[i]*(dep[xx]+dep[yy]-2*dep[LCA]+1-p[i]);\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t}\n\t\telse{\n\t\t\tint x,y,z;\n\t\t\tx=read();\n\t\t\ty=read();\n\t\t\tz=read();\n\t\t\tint c;\n\t\t\tif(dep[x]>dep[y])\n\t\t\t\tc=x;\n\t\t\telse\n\t\t\t\tc=y;\n\t\t\tfor(int i=0;i<=10;i++){\n\t\t\t\tif(((1<<i)&in[c])!=((1<<i)&z))\n\t\t\t\t\tchange(1,1,n,dfn[c],dfn[c]+sz[c]-1,i);\n\t\t\t}\n\t\t\tin[c]=z;\n\t\t}\n\t}\n}\n```",
        "postTime": 1649777287,
        "uid": 140360,
        "name": "LKawaii",
        "ccfLevel": 0,
        "title": "P3401 \u9898\u89e3"
    },
    {
        "content": "\u9898\u76ee\u5927\u610f\uff1a\n\u7ed9\u4e00\u68f5\u6811\uff0c\u6709\u8fb9\u6743\uff0c\u652f\u6301\u4e24\u4e2a\u64cd\u4f5c\u3002\n\uff081\uff09\u4fee\u6539\u4e00\u4e2a\u8fb9\u6743\n\uff082\uff09\u67e5\u8be2u\u5230v\u7684\u7b80\u5355\u8def\u5f84\u7684\u6240\u6709\u5b50\u94fe\u7684\u5f02\u6216\u548c\u7684\u548c\n\n\u505a\u6cd5\uff1a\n\u9996\u5148\u8fd9\u662f\u5f02\u6216\uff0c\u6ce8\u610f\u5230\u6ee1\u8db3a^b^b = a\uff0c\n\u8981\u6c42\u6240\u6709\u5b50\u94fe\u7684\u5f02\u6216\u548c\uff0c\u5373\u6c42\u5728(u, v)\u8fd9\u4e2a\u8def\u5f84\u4e0a\u7684\u4efb\u610f\u4e24\u70b9(x, y)\u7684\u8def\u5f84\u7684\u5f02\u6216\u548c\u4e4b\u548c\n\u8003\u8651\u5904\u7406\u6811\u4e0a\u5f02\u6216\u524d\u7f00\u548c\uff0c\u5373sum[i] = i \u5f02\u6216\u5230\u6839\uff0c\u4ece\u800csum[i]^sum[j]\u5c31\u662f i \u5f02\u6216\u5230 j\n\u7136\u540e\u53d1\u73b0\u8981\u6c42\u6240\u6709\u7684\u70b9\u5bf9\uff0c\u4e00\u6b21\u4e00\u6b21\u6c42\u80af\u5b9a\u4f1atle\uff0c\u90a3\u4e48\u8003\u8651\u5982\u4f55\u4e00\u6b21\u7edf\u8ba1\u6240\u6709\u70b9\u5bf9\n\u5bf9\u4e8e\u67d0\u4e00\u4f4dk\uff0c\u53ea\u9700\u8981\u6c42\u51fa\u6765\u6240\u6709\u7684\u524d\u7f00\u548c\u4e2d\uff0c\u8fd9\u4e00\u4f4d\u662f0\u7684\u6709\u51e0\u4e2a\uff0c\u8fd9\u4e00\u4f4d\u662f1\u7684\u6709\u51e0\u4e2a\uff0c\u628a\u8fd9\u4e24\u4e2a\u4e58\u8d77\u6765\u5c31\u662f\u7ec4\u6210\u70b9\u5bf9\u8fd9\u4e00\u4f4d\u662f1\u7684\u4e2a\u6570\uff0c\u90a3\u4e48\u8fdb\u884c\u6811\u5256+\u7ebf\u6bb5\u6811\u5373\u53ef\n```\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <set>\n#include <algorithm>\n#define MAXN 30050\nusing namespace std;\n/*\n\u8f93\u5165\u683c\u5f0f\uff1a\n\u7b2c\u4e00\u884c\u4e24\u4e2a\u6b63\u6574\u6570n\u548cq\uff0c\u8868\u793a\u70b9\u7684\u4e2a\u6570\uff0c\u67e5\u8be2\u548c\u8be2\u95ee\u7684\u603b\u6b21\u6570\u3002\n\n\u63a5\u4e0b\u6765n-1\u884c\uff0c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570u\u3001v\u3001w\uff0c\u8868\u793au\u548cv\u4e24\u4e2a\u70b9\u4e4b\u95f4\u6709\u4e00\u6761\u8fb9\u6743\u4e3aw\u7684\u8fb9\u3002\n\n\u63a5\u4e0b\u6765q\u884c\uff0c\u683c\u5f0f\u4e3a1 u v\u62162 u v w\u3002\u5982\u679c\u4e3a1 u v\u64cd\u4f5c\uff0c\n\u4f60\u9700\u8981\u8f93\u51fau\u5230v\u7684\u8def\u5f84\u4e0a\u6240\u6709\u5b50\u8def\u5f84\u7ecf\u8fc7\u7684\u8fb9\u7684\u8fb9\u6743\u7684xor\u503c\u7684\u548c\u662f\u591a\u5c11\uff1b\n\u5982\u679c\u4e3a2 u v w\u64cd\u4f5c\uff0c\u4f60\u9700\u8981\u628au\u5230v\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u6539\u4e3aw\uff0c\u4fdd\u8bc1\u8fd9\u6761\u8fb9\u5b58\u5728\u3002\n\n\u8f93\u51fa\u683c\u5f0f\uff1a\n\u5bf9\u4e8e\u6bcf\u4e2a1\u64cd\u4f5c\uff0c\u8f93\u51fa\u7b54\u6848\u3002*/\nint n, q, son[MAXN], size[MAXN], dep[MAXN], fa[MAXN], top[MAXN], id[MAXN], b[MAXN], num[MAXN], ecnt, tcnt, ed[MAXN]; \nstruct node{\n    int v, w;\n    node *next;\n    node(){}\n    node(int _v, int _w, node *_n) {\n        v = _v, w = _w, next = _n;\n    }\n}pool[MAXN<<2], *h[MAXN];\nstruct node2{\n    int num0, num1, rev;\n    node2 operator + (const node2 &x){\n        node2 t;\n        t.num0 = num0 + x.num0;\n        t.num1 = num1 + x.num1;\n        t.rev = 0;\n        return t;\n    }\n}t[25][MAXN<<3];\ninline void addedge(int u, int v, int w){\n    node *p1 = &pool[ecnt++], *p2 = &pool[ecnt++];\n    *p1 = node(v, w, h[u]), h[u] = p1;\n    *p2 = node(u, w, h[v]), h[v] = p2;\n}\nvoid dfs1(int u){\n    size[u] = 1;\n    for(node *p = h[u]; p; p = p->next){\n        if(p->v != fa[u]){\n            //cout<<u<<' '<<p->v<<' '<<b[u]<<' '<<p->w<<' '<<b[p->v]<<' ';\n            b[p->v] = b[u]^p->w;\n            ed[p->v] = p->w;\n            //cout<<b[p->v]<<endl;\n            fa[p->v] = u;\n            dep[p->v] = dep[u]+1;\n            dfs1(p->v);\n            size[u] += size[p->v];\n            if(size[p->v] > size[son[u]]) son[u] = p->v;\n        }\n    }\n}\nvoid dfs2(int u, int t){\n    id[u] = ++tcnt;\n    num[tcnt] = b[u];\n    top[u] = t;\n    if(!son[u]) return;\n    dfs2(son[u], t);\n    for(node *p = h[u]; p; p = p->next){\n        if(!id[p->v]) dfs2(p->v, p->v);\n    }\n}\nvoid build(int k, int u, int l, int r){\n    if(l == r){\n        if((num[l]>>k)&1)\n            t[k][u].num1 = 1;\n        else t[k][u].num0 = 1;\n        return;\n    }\n    int mid = (l+r)>>1;\n    build(k, u<<1, l, mid); build(k, u<<1|1, mid+1, r);\n    t[k][u] = t[k][u<<1] + t[k][u<<1|1];\n    //cout<<k<<' '<<u<<' '<<l<<' '<<r<<' '<<t[k][u].num0<<' '<<t[k][u].num1<<' '<<t[k][u].rev<<endl;\n}\nvoid pushdown(int k, int u){\n    if(t[k][u].rev == 0) return;\n    //cout<<\"IN \"<<k<<' '<<u<<endl;\n    swap(t[k][u<<1].num0, t[k][u<<1].num1);\n    swap(t[k][u<<1|1].num0, t[k][u<<1|1].num1);\n    t[k][u<<1].rev ^= 1;\n    t[k][u<<1|1].rev ^= 1;\n    t[k][u].rev = 0;\n}\nvoid rev(int k, int u, int l, int r, int tl, int tr){\n    if(tl <= l && r <= tr){\n        swap(t[k][u].num0, t[k][u].num1);\n        t[k][u].rev ^= 1;\n        return;\n    }\n    int mid = (l+r)>>1;\n    pushdown(k, u);\n    if(tl <= mid) rev(k, u<<1, l, mid, tl, tr);\n    if(mid < tr) rev(k, u<<1|1, mid+1, r, tl, tr);\n    t[k][u] = t[k][u<<1] + t[k][u<<1|1];\n}\nvoid change(int u, int w){\n    for(int i = 0; i <= 10; i++){\n        if(((w^ed[u])>>i)&1)\n            rev(i, 1, 1, n, id[u], id[u]+size[u]-1);\n    }\n    ed[u] = w;\n}\nnode2 query(int k, int u, int l, int r, int tl, int tr){\n    if(tl <= l && r <= tr){\n        return t[k][u];\n    }\n    int mid = (l+r)>>1;\n    pushdown(k, u);\n    node2 ret; ret.num0 = ret.num1 = 0; \n    if(tl <= mid) ret = ret + query(k, u<<1, l, mid, tl, tr);\n    if(mid < tr) ret = ret + query(k, u<<1|1, mid+1, r, tl, tr);\n    //cout<<k<<' '<<u<<' '<<l<<' '<<r<<' '<<t[k][u].num0<<' '<<t[k][u].num1<<endl;\n    return ret;\n}\nlong long Query(int u, int v){\n    long long ret = 0;\n    int U = u, V = v;\n    for(int i = 0; i <= 10; i++){\n        u = U, v = V;\n        //cout<<i<<endl;\n        node2 res; res.num0 = res.num1 = 0;\n        while(top[u] != top[v]){\n            if(dep[top[u]] < dep[top[v]]) swap(u, v);\n            res = res + query(i, 1, 1, n, id[top[u]], id[u]);\n            //cout<<id[top[u]]<<' '<<id[u]<<' '<<res.num0<<' '<<res.num1<<endl;\n            u = fa[top[u]];\n        }\n        if(dep[u] > dep[v]) swap(u, v);\n        res = res + query(i, 1, 1, n, id[u], id[v]);\n        //cout<<id[u]<<' '<<id[v]<<' '<<res.num0<<' '<<res.num1<<endl;\n        ret += (1LL<<i)*res.num0*res.num1;\n    }\n    return ret;\n}\nint main(){\n    //freopen(\"1.in\", \"r\", stdin);\n    //freopen(\"1.out\", \"w\", stdout);\n    int opt, u, v, w;\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i < n; i++) scanf(\"%d%d%d\", &u, &v, &w), addedge(u, v, w);\n    dep[1] = 1;\n    dfs1(1);\n    dfs2(1, 1);\n    //for(int i = 1; i <= n; i++) cout<<dep[i]<<' ';cout<<endl;\n    for(int i = 0; i <= 10; i++) build(i, 1, 1, n);\n    while(q--){\n        scanf(\"%d%d%d\", &opt, &u, &v);\n        if(opt == 1){\n            printf(\"%lld\\n\", Query(u, v));\n        }\n        else{\n            scanf(\"%d\", &w);\n            if(u != fa[v]) swap(u, v);\n            change(v, w);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1525491837,
        "uid": 3369,
        "name": "hychyc",
        "ccfLevel": 0,
        "title": "P3401 \u6d1b\u8c37\u6811"
    },
    {
        "content": "\u8fd9\u9053\u9898\u597d\u5e72\u71e5\u554a\u3002\u3002\u3002\u6298\u817e\u4e86\u534a\u4e2a\u6708\u3002\u3002\u3002\u611f\u8c22bogo\u5927\u4f6c\u5bf9\u6211\u7684\u6307\u5bfc\u3002\u3002\u3002\n\n\u697c\u4e0b\u5927\u4f6c\u7684\u4ee3\u7801(\u83ab\u975e\u662fzkw\u8fd9\u79cd\u6211\u6ca1\u5b66\u8fc7\u7684\u4e1c\u897f)\u770b\u4e0d\u61c2\u554a\u3002\u3002\u3002\u597d\u4e0d\u5bb9\u6613\u628a\u8fd9\u9898\u641e\u51fa\u6765\u4e86\uff0c\u90a3\u6211\u5c31\u6765\u53d1\u4e2a\u597d\u61c2\u4e00\u4e9b\u7684\u5427\n\n\u9898\u76ee\u8981\u6c42\u652f\u6301\u7684\u64cd\u4f5c\uff1a1.\u67e5\u8be2\u67d0\u6bb5\u8def\u5f84\u7684\u6240\u6709\u5b50\u8def\u5f84\u7684xor\u503c\u4e4b\u548c\uff1b2.\u4fee\u6539\u67d0\u6761\u8fb9\u7684\u6743\u503c\u3002\u91cd\u70b9\u662f\u64cd\u4f5c1\u3002\n\n\u521a\u5f00\u59cb\uff0c\u6211\u770b\u5230\u4e86\u64cd\u4f5c1\u4e4b\u540e\u5c31\u4e0d\u81ea\u89c9\u7684\u60f3\u5230\u4e86\u975e~\u5e38\u66b4\u529b\u7684\u4e1c\u897f\u3002\u3002\u3002\u8fd8\u597d\u5927\u4f6c\u53ca\u65f6\u628a\u6211\u5f15\u4e0a\u6b63\u9014\uff1a\u5206\u6cbb\uff01\n\n\u5927\u5bb6\u77e5\u9053\uff0c\u6700\u5927\u5b50\u6bb5\u548c\u6709\u4e2a\u5206\u6cbb\u7b97\u6cd5\uff0c\u672c\u9898\u7684\u65b9\u6cd5\u5c31\u8ddf\u8fd9\u4e2a\u6bd4\u8f83\u7c7b\u4f3c\u3002\n\n\u5bf9\u4e8e\u4e00\u6bb5\u5b50\u8def\u5f84\uff0c\u82e5\u5b83\u80fd\u5bf9\u7b54\u6848\u4ea7\u751f\u8d21\u732e\uff0c\u90a3\u4e48\u5b83\u8981\u4e48\u5b8c\u5168\u5728\u5de6\u513f\u5b50\u4e2d\uff0c\u8981\u4e48\u5b8c\u5168\u5728\u53f3\u513f\u5b50\u4e2d\uff0c\u8981\u4e48\u8de8\u8d8a\u5de6\u53f3\u513f\u5b50\u3002\n\n\u5bf9\u4e8e\u6bcf\u6bb5\u8def\u5f84\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u5f55\u5982\u4e0b\u53d8\u91cf\uff1ayh:\u5f02\u6216\u548c\uff0cans:\u7b54\u6848\uff0c\u5c31\u662f\u8981\u67e5\u8be2\u7684\u4e1c\u897f\uff0cp0[i]:\u6b64\u5e8f\u5217\u7684\u524d\u7f00\u5e8f\u5217\u4e2d\uff0c\u5f02\u6216\u548c\u7684\u4e8c\u8fdb\u5236\u7b2ci\u4f4d\u4e3a0\u7684\u5e8f\u5217\u6709\u591a\u5c11\u6bb5\uff0c\u540e\u9762\u7684p1,s0,s1\u7c7b\u4f3c\u3002\n\n\u4e8e\u662f\uff0c\u5728\u5206\u6cbb\u7684\u5408\u5e76\u9636\u6bb5\uff0c\u7b54\u6848\u4fbf\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\uff1a\u7b2c\u4e00\u90e8\u5206\u662f\u5de6\u53f3\u513f\u5b50\u8fd4\u56de\u7684ans\uff1b\u7b2c\u4e8c\u90e8\u5206\u662f\u5de6\u513f\u5b50\u7684s0[i]\\*p1[i]\u548cs1[i]\\*p0[i]\uff0c\u8fd9\u4e24\u4e2a\u7ed3\u679c\u8fd8\u8981\u518d\u4e58\u4ee5(1 << i)\uff0c\u8868\u793a\u6709\u591a\u5c11\u6bb5\u8de8\u8d8a\u5de6\u53f3\u513f\u5b50\u7684\u5b50\u8def\u5f84\u7684xor\u503c\u7684\u4e8c\u8fdb\u5236\u7b2ci\u4f4d\u4e3a1\uff0c\u4e58\u4e0a(1 << i)\u4e4b\u540e\u5c31\u8868\u793a\u7b54\u6848\u5b9e\u9645\u5e94\u8be5\u7d2f\u52a0\u7684\u503c\u3002\u56e0\u4e3a0\u548c1\u30011\u548c0\u5f02\u6216\u7684\u7ed3\u679c\u662f1\u561b\uff0c\u56e0\u6b64\u5c31\u5bf9\u7b54\u6848\u4ea7\u751f\u4e86\u8d21\u732e\u3002\n\n\u6211\u4eec\u5f53\u7136\u4e5f\u8981\u7ef4\u62a4p0\u3001p1\u3001s0\u3001s1\u3002\u8fd9\u91cc\u8f83\u4e0a\u9762\u7b80\u5355\u4e00\u4e9b\uff0c\u7ec6\u8282\u8be6\u89c1\u4ee3\u7801\u7684rg\\_a\u7ed3\u6784\u4f53\u5b9a\u4e49\u90e8\u5206\u3002\n\n\u4ee5\u4e0a\u8ba8\u8bba\u7684\u90fd\u662f\u94fe\u4e0a\u7684\u505a\u6cd5\uff0c\u9898\u76ee\u7ed9\u5b9a\u7684\u662f\u4e00\u68f5\u6811\uff0c\u90a3\u4e48\u6811\u5256\u5c31Ok\u4e86\uff0c\u4e4b\u540e\u6254\u5230\u7ebf\u6bb5\u6811\u91cc\u5927\u529bmerge\u5373\u53ef~\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u5728\u7ebf\u6bb5\u6811\u5e95\u5c42\u91cd\u5efa\u8282\u70b9\uff0c\u7136\u540e\u987a\u6b21merge\u5176\u6240\u6709\u7956\u5148\u5373\u53ef\u3002\n\n\u4e0b\u9762\u8bf4\u51e0\u4e2a\u7591\u96be\u7684\u95ee\u9898\uff1a\n\n\u4e00.\u8981\u5efa\u7ebf\u6bb5\u6811\uff0c\u8981\u6c42\u6743\u503c\u5728\u70b9\u4e0a\uff0c\u4f46\u9898\u76ee\u5374\u8bf4\u5728\u8fb9\u4e0a\u3002\u600e\u4e48\u529e\u5462\uff1f\u53ef\u4ee5\u628a\u6bcf\u6761\u8fb9\u7684\u8fb9\u6743\u4e0b\u653e\u5230\u6811\u4e2d\u6b64\u6761\u8fb9\u4e0b\u65b9\u8fde\u63a5\u7684\u8282\u70b9\u4e0a\u3002\u8fd9\u6837\uff0c\u6839\u8282\u70b9\u5c31\u4e0d\u4f1a\u88ab\u4e0b\u653e\uff0c\u4f46\u662f\u5e76\u4e0d\u5f71\u54cd\u7ed3\u679c\uff0c\u81f3\u4e8e\u4e3a\u4ec0\u4e48\uff0c\u4f1a\u5728\u4e0b\u9762\u63d0\u5230\u3002\n\n\u4e8c.\u67e5\u8be2\u65f6\uff0c\u5bf9\u4e8e\u4e00\u6bb5\u8def\u5f84u->lca->v\uff0c\u56e0\u4e3alca\u4e5f\u88ab\u4e0b\u653e\u4e86\u6743\u503c\uff0c\u4f46\u662f\u5b83\u5bf9\u5e94\u7684\u8fb9\u5e76\u4e0d\u5728u->v\u8def\u5f84\u4e2d\uff0c\u56e0\u6b64\u4e0d\u80fd\u88ab\u7edf\u8ba1\uff0c\u6240\u4ee5\u67e5\u8be2\u65f6\u53ea\u7edf\u8ba1\u8def\u5f84\u4e0a\u9664lca\u4e4b\u5916\u7684\u70b9\u3002\u9274\u4e8e\u6b64\uff0c\u4e0a\u9762\u63d0\u5230\u7684\u6839\u8282\u70b9\u4fbf\u65e0\u6240\u8c13\u662f\u5426\u4e0b\u653e\u4e86\u3002\u5177\u4f53\u64cd\u4f5c\u65f6\uff0c\u5728\u6811\u5256\u201c\u8df3\u201d\u7684\u8fc7\u7a0b\u7684\u672b\u7aef\u7a0d\u52a0\u4fee\u6539\u5373\u53ef\u3002\n\n\u4e09.\u8fd9\u70b9\u975e\u5e38\u91cd\u8981\uff01\n\n\u6211\u5728\u505a\u8fd9\u9898\u65f6\uff0c\u524d\u51e0\u4efd\u4ee3\u7801\u72c2WA\u4e0d\u6b62\uff0c\u540e\u6765\u627e\u5230\u539f\u56e0\uff1amerge\u64cd\u4f5c\u4e0d\u6ee1\u8db3\u4ea4\u6362\u5f8b\uff0c\u4f46\u662f\u6211\u5728\u67e5\u8be2\u65f6\u5374\u51fa\u73b0\u4e86\u8fd0\u7b97\u987a\u5e8f\u7684\u6f0f\u6d1e\u3002\u7ecf\u8fc7\u4e00\u756a\u8111\u6d1e\uff0c\u6211\u627e\u5230\u4e86\u6b63\u786e\u7684\u8fd0\u7b97\u987a\u5e8f\uff0c\u73b0\u63cf\u8ff0\u5982\u4e0b\uff1a\n\n1.\u5c06\u6811\u5256\u7684\u5f85\u5408\u5e76\u7ed3\u679c\u5206\u6210u->lca\u548clca->v\u4e24\u90e8\u5206\uff0c\u5b58\u5165\u6570\u7ec4TL\u548cTR\uff1b\n\n2.\u5c06TL\u548cTR\u7684\u7ed3\u679c\u5206\u522b\u5168\u90e8\u5408\u5e76\u5230TL[1]\u548cTR[1]\u4e2d(\u6ce8\u610f\u8fd9\u91cc\u7684\u8fd0\u7b97\u987a\u5e8f\uff0c\u5efa\u8bae\u624b\u52a8\u753b\u56fe\u9a8c\u8bc1)\uff1b\n\n3.\u8fdb\u884c\u7279\u5224\uff0c\u5982\u679cTL\u4e3a\u7a7a\uff0c\u90a3\u4e48\u76f4\u63a5\u8fd4\u56deTR[1].ans\uff0c\u53cd\u4e4b\u4ea6\u7136\uff1b\n\n4.\u82e5TL\u3001TR\u5747\u975e\u7a7a\uff0c\u5219\u5148\u5c06TL[1]\u8fdb\u884c\u201c\u7ffb\u8f6c\u201d(\u7ec6\u8282\u89c1\u4ee3\u7801\uff0c\u540c\u6837\u5efa\u8bae\u753b\u56fe\u9a8c\u8bc1)\uff0c\u7136\u540e\u5408\u5e76TL[1]\u3001TR[1]\uff0c\u8fd4\u56de\u5408\u5e76\u540e\u7684ans\u5373\u53ef\u3002\n\n\u56db.\u6709\u4e2a\u5c0f\u5751\uff0c\u6216\u8bb8\u662f\u6211\u4e0d\u591f\u7ec6\u5fc3\u5427\uff0c\u90a3\u5c31\u662f\u67e5\u8be2\u7684\u8def\u5f84\u7684\u8d77\u70b9\u548c\u7ec8\u70b9\u6709\u53ef\u80fd\u662f\u540c\u4e00\u4e2a\u70b9\u3002\u5f00\u59cb\u6ca1\u6ce8\u610f\u8fd9\u4e2a\uff0c\u7ed3\u679c\u5bfc\u81f4WA\u621070\u5206\u3002\u6240\u4ee5\u6211\u5728\u67e5\u8be2\u65f6\u52a0\u4e86\u4e2a\u7279\u5224\uff0c\u82e5u==v\u5219\u76f4\u63a5\u8fd4\u56de0\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff0c\u53c8\u4e11\u53c8\u957f\uff0c\u89c1\u8c05\u89c1\u8c05\uff1a\n\n    \n    \n    \n    \n    \n        \n        \n        \n    \n    \n    \n    \n    \n    \n        \n            \n            \n                \n                \n                \n                \n                \n            \n    \n        \n                \n                \n        \n                \n                \n        \n                    \n    \n    \n    \n        \n        \n        \n        \n        \n        \n        \n            \n        \n    \n    \n        \n        \n                \n                \n            \n    \n        \n        \n        \n            \n    \n        \n        \n        \n        \n        \n            \n```cpp\n    #include<cstdio>\n    #include<iostream>\n    #include<cstring>\n    #include<cmath>\n    #include<ctime>\n    #include<cstdlib>\n    #include<string>\n    #include<stack>\n    #include<queue>\n    #include<vector>\n    #include<algorithm>\n    #include<map>\n    #include<set>\n    #define inf 2147483647\n    #define ri register int\n    #define ll long long\n    #define mid (l+r>>1)\n    #define lson (o<<1)\n    #define rson ((o<<1)+1)\n    using namespace std;\n    inline void read(int &x){\n        x=0;\n        char t=getchar();\n        bool f=0;\n        while(t<'0' || t>'9'){\n            if(t=='-')f=1;\n            t=getchar();\n        }\n        while(t>='0' && t<='9'){\n            x=(x<<3)+(x<<1)+t-'0';\n            t=getchar();\n        }\n        if(f)x=-x;\n    }\n    inline void addedge(int,int,int);\n    int u[60005];\n    int v[60005];\n    int w[60005];\n    int fi[30005];\n    int ne[60005];\n    int pe=0;  //\u65e0\u5411\u90bb\u63a5\u8868 \n    int wp[30005];  //\u4e0b\u653e\u7684\u70b9\u6743 \n    void dfs1(int);\n    int fa[30005];  //\u7236\u4eb2 \n    int dep[30005];  //\u6df1\u5ea6 \n    int size[30005];  //\u5b50\u6811\u5927\u5c0f \n    int son[30005];  //\u91cd\u513f\u5b50 \n    void dfs2(int);\n    int top[30005];  //\u94fe\u9876\u8282\u70b9 \n    int dfsx[30005];  //dfs\u5e8f \n    int xu=0;\n    int pos[30005];  //\u8282\u70b9\u4f4d\u7f6e,in Sgt.\n    struct rg_a{\n        ll yh;  //\u5f02\u6216\u548c \n        ll ans;  //\u7b54\u6848 \n        ll p0[10],p1[10],s0[10],s1[10];  //\u672c\u6bb5\u533a\u95f4\u4e8c\u8fdb\u5236\u7b2cj\u4f4d\u4e3a0/1\u7684\u524d/\u540e\u7f00\u533a\u95f4\u6570 \n        inline void merge(rg_a &A,rg_a &B){  //\u5408\u5e76 \n            rg_a T;  //\u8bb0\u5f55\u5408\u5e76\u7ed3\u679c\n            int bl,br;  //\u62bd\u53d6A/B\u7684\u5f02\u6216\u548c\u7684\u4e8c\u8fdb\u5236\u7b2ci\u4f4d\n            T.yh=A.yh^B.yh;\n            T.ans=A.ans+B.ans;\n            for(ri i=0;i<10;i++){\n                T.ans+=A.s0[i]*B.p1[i]*(1<<i);\n                T.ans+=A.s1[i]*B.p0[i]*(1<<i);\n                bl=(A.yh>>i)&1;\n                br=(B.yh>>i)&1;\n                T.p0[i]=A.p0[i];\n                if(bl)T.p0[i]+=B.p1[i];\n                else T.p0[i]+=B.p0[i];\n                T.p1[i]=A.p1[i];\n                if(bl)T.p1[i]+=B.p0[i];\n                else T.p1[i]+=B.p1[i];\n                T.s0[i]=B.s0[i];\n                if(br)T.s0[i]+=A.s1[i];\n                else T.s0[i]+=A.s0[i];\n                T.s1[i]=B.s1[i];\n                if(br)T.s1[i]+=A.s0[i];\n                else T.s1[i]+=A.s1[i];\n            }\n            *this=T;\n        }\n    };\n    struct sgt{  //\u7ebf\u6bb5\u6811\n        rg_a node[120005];\n        void build(int o,int l,int r){\n            if(l==r){\n                node[o].yh=node[o].ans=wp[dfsx[l]];\n                for(ri i=0;i<10;i++){\n                    node[o].p0[i]=node[o].s0[i]=((node[o].yh>>i)&1)^1;\n                    node[o].p1[i]=node[o].s1[i]=(node[o].yh>>i)&1;\n                }\n            }\n            else{\n                build(lson,l,mid);\n                build(rson,mid+1,r);\n                node[o].merge(node[lson],node[rson]);\n            }\n        }\n        void update(int o,int l,int r,int p,int x){\n            if(l==r && l==p){\n                node[o].yh=node[o].ans=x;\n                for(ri i=0;i<10;i++){\n                    node[o].p0[i]=node[o].s0[i]=((x>>i)&1)^1;\n                    node[o].p1[i]=node[o].s1[i]=(x>>i)&1;\n                }\n            }\n            else{\n                if(p<=mid)update(lson,l,mid,p,x);\n                else update(rson,mid+1,r,p,x);\n                node[o].merge(node[lson],node[rson]);\n            }\n        }\n        rg_a query(int o,int l,int r,int a,int b){\n            if(l>=a && r<=b)return node[o];\n            else{\n                if(b<=mid)return query(lson,l,mid,a,b);\n                else if(a>mid)return query(rson,mid+1,r,a,b);\n                else{\n                    rg_a tl=query(lson,l,mid,a,b);\n                    rg_a tr=query(rson,mid+1,r,a,b);\n                    tl.merge(tl,tr);\n                    return tl;\n                }\n            }\n        }\n    } tree;\n    inline ll path_query(int,int);\n    rg_a TL[50],TR[50];  //\u5916\u5c42\u67e5\u8be2\u4e34\u65f6\u7ed3\u679c\n    int pl,pr;  //\u8bb0\u5f55TL\u548cTR\u5b58\u653e\u7684\u4e34\u65f6\u7ed3\u679c\u7684\u6570\u91cf\n    int n,q;\n    int f,x,y,z;\n    int root;\n    int main(){\n        srand(time(0)+19260817);\n        read(n);read(q);\n        root=rand()%n+1;  //Ha~\n        for(ri i=1;i<n;i++){\n            read(x);read(y);read(z);\n            addedge(x,y,z);\n            addedge(y,x,z);\n        }\n        fa[root]=0;\n        dep[root]=1;\n        wp[root]=0;\n        dfs1(root);\n        top[root]=root;\n        dfs2(root);\n        for(ri i=1;i<=n;i++)pos[dfsx[i]]=i;\n        tree.build(1,1,n);\n        while(q--){\n            read(f);\n            if(f==1){\n                read(x);read(y);\n                printf(\"%lld\\n\",path_query(x,y));\n            }\n            else{\n                read(x);read(y);read(z);\n                if(pos[x]<pos[y])tree.update(1,1,n,pos[y],z);\n                else tree.update(1,1,n,pos[x],z);\n            }\n        }\n        return 0;\n    }\n    inline void addedge(int x,int y,int z){\n        pe++;\n        u[pe]=x;\n        v[pe]=y;\n        w[pe]=z;\n        ne[pe]=fi[x];\n        fi[x]=pe;\n    }\n    void dfs1(int s){\n        size[s]=1;\n        int maxson=0;\n        int t=fi[s];\n        int to=v[t];\n        while(t){\n            if(to!=fa[s]){\n                fa[to]=s;\n                dep[to]=dep[s]+1;\n                wp[to]=w[t];\n                dfs1(to);\n                size[s]+=size[to];\n                if(size[to]>maxson){\n                    son[s]=to;\n                    maxson=size[to];\n                }\n            }\n            t=ne[t];\n            to=v[t];\n        }\n    }\n    void dfs2(int s){\n        xu++;\n        dfsx[xu]=s;\n        if(son[s]){\n            top[son[s]]=top[s];\n            dfs2(son[s]);\n        }\n        int t=fi[s];\n        int to=v[t];\n        while(t){\n            if(to!=fa[s] && to!=son[s]){\n                top[to]=to;\n                dfs2(to);\n            }\n            t=ne[t];\n            to=v[t];\n        }\n    }\n    inline ll path_query(int x,int y){\n        if(x==y)return 0;  //\u7279\u5224\u8d77\u7ec8\u70b9\u76f8\u540c\n        pl=pr=0;  //\u91cd\u7f6e\u4e34\u65f6\u7ed3\u679c\u6570\u7ec4\n        int tx=top[x],ty=top[y];\n        while(tx!=ty){\n            if(dep[tx]>dep[ty]){\n                pl++;\n                TL[pl]=tree.query(1,1,n,pos[tx],pos[x]);\n                x=fa[tx];\n                tx=top[x];\n            }\n            else{\n                pr++;\n                TR[pr]=tree.query(1,1,n,pos[ty],pos[y]);\n                y=fa[ty];\n                ty=top[y];\n            }\n        }\n        if(x!=y){\n            if(pos[x]<pos[y]){\n                pr++;\n                TR[pr]=tree.query(1,1,n,pos[x]+1,pos[y]);\n            }\n            else{\n                pl++;\n                TL[pl]=tree.query(1,1,n,pos[y]+1,pos[x]);\n            }\n        }\n        for(ri i=2;i<=pl;i++)TL[1].merge(TL[i],TL[1]);\n        for(ri i=2;i<=pr;i++)TR[1].merge(TR[i],TR[1]);\n        //\u8fd9\u91cc\u5168\u90e8\u90fd\u8981\u6ce8\u610f\u8fd0\u7b97\u987a\u5e8f\uff01\n        if(!pl)return TR[1].ans;\n        else if(!pr)return TL[1].ans;  //\u7279\u5224\u7b54\u6848\u4ec5\u5728lca\u4e00\u4fa7\u7684\u60c5\u51b5\n        else{\n            for(ri i=0;i<10;i++){\n                swap(TL[1].p0[i],TL[1].s0[i]);\n                swap(TL[1].p1[i],TL[1].s1[i]);\n            }  //\u201c\u7ffb\u8f6c\u201dTL[1]\n            TL[1].merge(TL[1],TR[1]);\n            return TL[1].ans;\n        }\n}\n```",
        "postTime": 1515243658,
        "uid": 22630,
        "name": "Running_Coder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u554a\n\n\u5bf9\u4e8e\u6bcf\u6761\u94fex,\n\n\u8bb0\u4e00\u4e2apre[x][j][k],suf[x][j][k]\u8868\u793a\u5bf9\u4e8e\u8fd9\u6761\u94fe,\u524d\u7f00\u6216\u540e\u7f00\u7684\u5f02\u6216\u5728j\u4f4d\u6709\u51e0\u4e2ak(0/1)\n\n\u8bb0\u4e00\u4e2a\u7b54\u6848ans[x],\u8bb0\u4e00\u4e2a\u5f02\u6216\u548cyh[x]\n\n\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u7528\u5206\u6cbb\u7684\u601d\u60f3,\u66f4\u65b0ans,pre,suf\n\n\u94fe\u5256\u67e5\u8be2\u65f6\u5c31\u7528\u4e00\u4e2al\u548cr\u8868\u793a\u5de6\u53f3\u7684\u7ed3\u679c\u5206\u522b\u662f\u4ec0\u4e48\n\n\u6700\u7ec8\u7b54\u6848\u5c31\u662fans[o]=ans[l]+ans[r]+Sum{(pre[l][i][0]\\*pre[r][i][1]+pre[l][i][1]\\*pre[r][i][0])<<i}\n\n\n```Cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define maxn 30100\n#define lans (maxn*4 -10)\n#define rans (maxn*4 -100)\n#define xans (maxn*4 -20)\n#define yans (maxn*4 -30)\nusing namespace std;\nstruct edges{\n    int r,nxt,w;\n}e[maxn<<1];\nint head[maxn],esz;\nint dep[maxn],fa[maxn],top[maxn],son[maxn],id[maxn],idsz,m,w[maxn];\nlong long ans[maxn<<2],pre[maxn<<2][10][2],suf[maxn<<2][10][2],yh[maxn<<2];\nint dfs(int u,int f,int d){\n    fa[u]=f;\n    dep[u]=d;\n    int ssz=0,mxs=0,so=0;\n    for(int t=head[u];t;t=e[t].nxt)if(e[t].r!=f){\n        w[e[t].r]=e[t].w;\n        int a=dfs(e[t].r,u,d+1);\n        if(mxs<a)mxs=a,so=e[t].r;\n        ssz+=a;\n    }\n    son[u]=so;\n    return ssz+1;\n}\nvoid dfs2(int u,int tp){\n    id[u]=++idsz;\n    top[u]=tp;\n    if(son[u])dfs2(son[u],tp);\n    for(int t=head[u];t;t=e[t].nxt)\n        if(e[t].r!=fa[u]&&e[t].r!=son[u])\n            dfs2(e[t].r,e[t].r);\n}\nvoid merge(int o,int l,int r){\n    ans[o]=ans[l]+ans[r];\n    for(int i=0;i<10;++i){\n        int zp=(yh[l]>>i)&1;\n        int zs=(yh[r]>>i)&1;\n        ans[o]+=(suf[l][i][0]*pre[r][i][1]+suf[l][i][1]*pre[r][i][0])<<i;\n//        printf(\"[%d]\",(suf[l][i][0]*pre[r][i][1]+suf[l][i][1]*pre[r][i][0])<<i);\n        long long a=pre[l][i][0]+pre[r][i][zp];\n        long long b=pre[l][i][1]+pre[r][i][!zp];\n        long long c=suf[r][i][0]+suf[l][i][zs];\n        long long d=suf[r][i][1]+suf[l][i][!zs];\n        pre[o][i][0]=a;\n        pre[o][i][1]=b;\n        suf[o][i][0]=c;\n        suf[o][i][1]=d;\n    }\n    yh[o]=yh[l]^yh[r];    \n}\nvoid init(int x){\n    memset(pre[x],0,sizeof(pre[x]));\n    memset(suf[x],0,sizeof(suf[x]));\n    yh[x]=ans[x]=0;\n}\nvoid qsum(int x,int l,int r){\n    if(l>r)swap(l,r);\n    l+=m-1-1,r+=m+1-1;\n    init(xans),init(yans);\n    for(;l^r^1;l>>=1,r>>=1){\n        if(~l&1)merge(xans,xans,l^1);\n        if(r&1)merge(yans,r^1,yans);\n    }    \n    \n    merge(xans,xans,yans);\n    merge(x,xans,x);\n//    printf(\"[%d=%d]\\n\",x,ans[x]);\n//    for(int i=0;i<10;++i)printf(\"[%d,%d]\\n\",pre[x][i][1],pre[x][i][0]);\n//    printf(\"\\n---------------\\n\");\n}\nvoid modify(int l,int a){\n    l+=m-1;\n    ans[l]=yh[l]=a;\n    for(int i=0;i<10;++i)\n        pre[l][i][0]=suf[l][i][0]=pre[l][i][1]=suf[l][i][1]=0;\n    for(int i=0;i<10;++i)\n        pre[l][i][(a>>i)&1]++,suf[l][i][(a>>i)&1]++;\n    for(l>>=1;l;l>>=1)merge(l,l<<1,l<<1|1);\n}\nlong long calc(int l,int r){\n    ans[0]=ans[l]+ans[r];\n    for(int i=0;i<10;++i)\n        ans[0]+=(pre[l][i][0]*pre[r][i][1]+pre[l][i][1]*pre[r][i][0])<<i;\n    return ans[0];\n}\n\nlong long query(int u,int v){\n    init(lans),init(rans),init(0);\n    int tp1=top[u],tp2=top[v],l=lans,r=rans;\n    while(tp1!=tp2){\n        if(dep[tp1]<dep[tp2])\n            swap(tp1,tp2),swap(u,v),swap(l,r);\n//        printf(\"[%d,%d]\",u,tp1);\n        qsum(l,id[u],id[tp1]);\n        u=fa[tp1];tp1=top[u];\n    }\n    if(u==v)return calc(l,r);\n    if(dep[u]>dep[v])swap(u,v),swap(l,r);\n    qsum(r,id[son[u]],id[v]);\n    return calc(l,r);\n}\nvoid addedge(int u,int v,int w){\n    e[++esz].r=v;e[esz].nxt=head[u];head[u]=esz;\n    e[esz].w=w;         \n}\nint main(){\n    int n,q;scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<n;++i){\n        int u,v,a;\n        scanf(\"%d%d%d\",&u,&v,&a);\n        addedge(u,v,a);\n        addedge(v,u,a);\n    }\n    \n    dfs(1,0,1);\n    dfs2(1,1);\n    for(m=1;m-2<=n;m<<=1);\n    for(int i=2;i<=n;++i)modify(id[i],w[i]);\n    for(int i=1;i<=q;++i){\n        int c,u,v,w;scanf(\"%d%d%d\",&c,&u,&v);\n        if(c==1){\n            printf(\"%lld\\n\",query(u,v));\n        } else {\n            scanf(\"%d\",&w);\n            modify(dep[u]<dep[v]?id[v]:id[u],w);\n        }\n    }\n    \n}\n```\n",
        "postTime": 1476008116,
        "uid": 11751,
        "name": "ComeIntoPower",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "### Solve\n\n**\u524d\u7f6e\u77e5\u8bc6**\uff1a\u5f02\u6216\u3001\u7ebf\u6bb5\u6811\u3001\u91cd\u94fe\u5256\u5206\u3002\n\n\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u70b9\u5230\u6839\u7ed3\u70b9\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u6240\u6709\u8fb9\u6743\u7684\u5f02\u6216\u548c $s_i$\uff0c\u56e0\u4e3a $a\\operatorname{xor}a\\operatorname{xor}b=b$\uff0c\u8be2\u95ee\u64cd\u4f5c\u53ef\u4ee5\u8f6c\u5316\u4e3a $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u6240\u6709\u70b9\u7684 $s_i$ \u4e2d\u4efb\u9009\u4e24\u4e2a\u5f02\u6216\u4ea7\u751f\u7684\u6240\u6709\u7ed3\u679c\u7684\u548c\u3002\n\n\u56e0\u4e3a\u5f02\u6216\u8fd0\u7b97\u4f4d\u4e0e\u4f4d\u4e4b\u95f4\u662f\u72ec\u7acb\u7684\uff0c\u8003\u8651\u5efa $\\log_2 \\max\\{w\\}=10$ \u68f5\u7ebf\u6bb5\u6811\uff0c\u7b2c $i$ \u68f5\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u7ed3\u70b9\u7ef4\u62a4\u4e00\u6bb5 $\\text{dfn}$ \u503c\u8fde\u7eed\u7684\u7ed3\u70b9\u533a\u95f4\u4e2d $s$ \u503c\u7b2c $i$ \u4f4d\u4e3a $1$ \u7684\u7ed3\u70b9\u6709\u591a\u5c11\u4e2a\u3002\n\n**\u8be2\u95ee\u64cd\u4f5c**\uff1a\n\n\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u6811\u5256\u7edf\u8ba1 $u,v$ \u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9 $s$ \u503c\u7b2c $i$ \u4f4d\u4e3a $1$ \u7684\u4e2a\u6570 $w_i$\uff0c\u8bb0 $u,v$ \u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u7ed3\u70b9\u4e2a\u6570\u4e3a $z$\u3002\u7136\u540e\u6309\u4f4d\u5904\u7406\uff0c\u4f9d\u6b21\u8003\u8651\u6bcf\u4e00\u4f4d\u7684\u8d21\u732e\u3002\u7b2c $i$ \u4f4d\u5e26\u6765\u7684\u8d21\u732e\u5373\u4e3a $w_i\\cdot (x-w_i)\\cdot 2^i$\uff0c\u610f\u601d\u662f\u6bcf\u4e00\u4e2a\u8be5\u4f4d\u4e3a $1$ \u7684\u7ed3\u70b9 $s$ \u503c\u4e0e\u4e00\u4e2a\u8be5\u4f4d\u4e3a $0$ \u7684\u7ed3\u70b9\u7684 $s$ \u503c\u5f02\u6216\u540e\u8be5\u4f4d\u4f1a\u53d8\u6210 $1$\u3002\n\n**\u4fee\u6539\u64cd\u4f5c**\uff1a\n\n\u8bb0\u5f55\u8fd9\u6761\u8fb9\u539f\u6765\u7684\u8fb9\u6743 $x$\uff0c\u8bbe\u65b0\u8fb9\u6743\u4e3a $y$\uff0c\u82e5 $x$ \u4e0e $y$ \u7b2c $i$ \u4e3a\u4e0d\u76f8\u540c\uff0c\u5219\u5c06\u6df1\u5ea6\u8f83\u6df1\u7684\u7ed3\u70b9\u7684\u5b50\u6811\u6240\u6709\u7ed3\u70b9\u7684 $s$ \u503c\u7b2c $i$ \u4f4d\u53cd\u8f6c\uff08\u5373 $1$ \u53d8 $0$\uff0c$0$ \u53d8 $1$\uff09\u3002\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n, q, a[30010], tim, wid[30010], fa[30010], dis[30010], siz[30010], son[30010], dfn[30010], top[30010];\nvector<pair<int, int> > g[30010];\ninline void init(const int &u, const int &f) {\n\tsiz[u] = 1;\n\tfor (register int i = 0; i < g[u].size(); i++) {\n\t\tconst int v = g[u][i].first, w = g[u][i].second;\n\t\tif (v == f) continue;\n\t\tfa[v] = u;\n\t\twid[v] = w;\n\t\tdis[v] = dis[u] + 1;\n\t\tinit(v, u);\n\t\tsiz[u] += siz[v];\n\t\tif (siz[v] > siz[son[u]]) son[u] = v;\n\t}\n}\ninline void dfs(const int &u, const int &p, const int &s) {\n\ttop[u] = p;\n\tdfn[u] = ++tim;\t\n\ta[dfn[u]] = s;\n\tif (!son[u]) return;\n\tdfs(son[u], p, s ^ wid[son[u]]);\n\tfor (register int i = 0; i < g[u].size(); i++) {\n\t\tconst int v = g[u][i].first, w = g[u][i].second;\n\t\tif (v == fa[u] || v == son[u]) continue;\n\t\tdfs(v, v, s ^ w);\n\t}\n}\nstruct Segment_Tree {\n\tint sum[120010][12];   // \u533a\u95f4\u5185\u6240\u6709\u6570\u4e2d\u7b2c i \u4f4d\u4e3a 1 \u7684\u6570\u7684\u4e2a\u6570 \n\tbool lzy[120010][12];\n\tinline bool GetIdx(const int &x, const int &k) { return x & (1ll << k); }\n\tinline bool InRange(const int &l, const int &r, const int &L, const int &R) { return L <= l && R >= r; }\n\tinline bool OutoRange(const int &l, const int &r, const int &L, const int &R) { return r < L || R < l; }\n\tinline void pushup(const int &u) { for (register int i = 0; i <= 10; i++) sum[u][i] = sum[u << 1][i] + sum[u << 1 | 1][i]; }\n\tinline void pushup_k(const int &u, const int &k) { sum[u][k] = sum[u << 1][k] + sum[u << 1 | 1][k]; }\n\tinline void maketag(const int &u, const int &l, const int &r, const int &k) {\n\t\tlzy[u][k] = !lzy[u][k]; sum[u][k] = r - l + 1 - sum[u][k]; \n\t}\n\tinline void pushdown(const int &u, const int &l, const int &r, const int &k) {\n\t\tif (!lzy[u][k]) return;\n\t\tlzy[u][k] = 0;\n\t\tconst int mid = (l + r) >> 1;\n\t\tmaketag(u << 1, l, mid, k), maketag(u << 1 | 1, mid + 1, r, k);\n\t}\n\tinline void build(const int &u, const int &l, const int &r) {\n\t\tif (l == r) { for (register int i = 0; i <= 10; i++) sum[u][i] = GetIdx(a[l], i); return; } \n\t\tconst int mid = (l + r) >> 1; build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r); pushup(u);\n\t}\n\tinline void update(const int &u, const int &l, const int &r, const int &L, const int &R, const int &k) {\n\t\t// \u533a\u95f4\u5185\u6240\u6709\u6570\u7684\u7b2c k \u4f4d\u53d6\u53cd \n\t\tif (InRange(l, r, L, R)) { maketag(u, l, r, k); return; } \n\t\telse if (!OutoRange(l, r, L, R)) {\n\t\t\tpushdown(u, l, r, k);\n\t\t\tconst int mid = (l + r) >> 1;\n\t\t\tupdate(u << 1, l, mid, L, R, k), update(u << 1 | 1, mid + 1, r, L, R, k);\n\t\t\tpushup_k(u, k);\n\t\t}\n\t}\n\tinline int query(const int &u, const int &l, const int &r, const int &L, const int &R, const int &k) {\n\t\t// \u533a\u95f4\u5185\u7b2c k \u4f4d\u4e3a 1 \u7684\u6570\u7684\u4e2a\u6570\n\t\tif (InRange(l, r, L, R)) return sum[u][k];\n\t\telse if (!OutoRange(l, r, L, R)) {\n\t\t\tconst int mid = (l + r) >> 1;\n\t\t\tpushdown(u, l, r, k);\n\t\t\treturn query(u << 1, l, mid, L, R, k) + query(u << 1 | 1, mid + 1, r, L, R, k);\n\t\t} else return 0;\n\t}\n} tree;\nint tmp[12];   // \u8def\u5f84\u4e0a\u7b2c i \u4f4d\u4e3a 1 \u7684\u6570\u7684\u4e2a\u6570 \ninline int query(int u, int v) {\n\tmemset(tmp, 0, sizeof tmp);\n\tint cnt = 0;\n\twhile (top[u] != top[v]) {\n\t\tif (dis[top[u]] < dis[top[v]]) swap(u, v);\n\t\tfor (register int i = 0; i <= 10; i++) tmp[i] += tree.query(1, 1, n, dfn[top[u]], dfn[u], i); \n\t\tcnt += dfn[u] - dfn[top[u]] + 1; u = fa[top[u]]; \n\t}\n\tif (dis[u] < dis[v]) swap(u, v);\n\tcnt += dfn[u] - dfn[v] + 1;\n\tfor (register int i = 0; i <= 10; i++) tmp[i] += tree.query(1, 1, n, dfn[v], dfn[u], i);\n\tint ans = 0;\n\tfor (register int i = 0; i <= 10; i++) ans += (1ll << i) * tmp[i] * (cnt - tmp[i]);\n\treturn ans; \n}\ninline void update(int u, int v, const int &w) {\n\tif (dis[u] > dis[v]) swap(u, v);\n\tfor (register int i = 0; i <= 10; i++) {\n\t\tbool x = tree.GetIdx(w, i), y = tree.GetIdx(wid[v], i);\n\t\tif (x != y) tree.update(1, 1, n, dfn[v], dfn[v] + siz[v] - 1, i);\n\t}\n\twid[v] = w;\n}\nsigned main() {\n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> n >> q;\n\tfor (register int i = 1; i < n; i++) {\n\t\tint u, v, w;\n\t\tcin >> u >> v >> w;\n\t\tg[u].push_back({v, w}), g[v].push_back({u, w});\n\t}\n\tdis[1] = 1; init(1, 0); dfs(1, 1, 0); tree.build(1, 1, n);\n\twhile (q--) {\n\t\tint opt, u, v, w;\n\t\tcin >> opt >> u >> v;\n\t\tif (opt == 1) cout << query(u, v) << \"\\n\";\n\t\telse {\n\t\t\tcin >> w;\n\t\t\tupdate(u, v, w);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1666847160,
        "uid": 534654,
        "name": "Network_Error",
        "ccfLevel": 0,
        "title": "P3401 \u6d1b\u8c37\u6811 \u9898\u89e3"
    },
    {
        "content": "### \u6709\u5173\u5f02\u6216\u548c\u7684\u6811\u5256+\u7ebf\u6bb5\u6811\n\n\u9996\u5148\u7528\u6811\u5256\u5efa\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u7684\u662f\u6811\u4e0a\u6bcf\u4e2a\u70b9\u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u59cb\u4f4d\u7f6e\u7684\u8fb9\u6743\u524d\u7f00\u548c\uff0c\u5bb9\u6613\u60f3\u5230\u8fb9\u6743\u524d\u7f00\u548c\u53ef\u4ee5\u653e\u5728\u513f\u5b50\u8282\u70b9\u5904\u4ee5\u65b9\u4fbf\u5904\u7406\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e00\u6761\u6811\u4e0a\u8def\u5f84\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u7528\u4e24\u70b9\u6240\u4fdd\u5b58\u7684\u524d\u7f00\u548c\u76f8\u4e92 Xor \u6240\u5f97\u3002\u7136\u800c\u6bcf\u5bf9\u8282\u70b9\u5339\u914d\u65f6\u957f\u592a\u5927\uff0c\u6211\u4eec\u5c06\u5176\u6309\u4f4d\u62c6\u5206\uff08\u4f9d\u65e7\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff09\uff0c\u5bf9\u4e8e\u7b2c $i$ \u4f4d\u4e0a\u7684\u7b54\u6848\u5c31\u662f $2 ^ i \\times ans_i \\times (sum - ans_i)$ \uff0c\u5176\u4e2d $ans_i$ \u8868\u793a\u7b2c $i$ \u4f4d\u76ee\u6807\u76ee\u6807\u8def\u5f84\u4e0a\u7684 $1$ \u603b\u6570\u7684\u603b\u6570\uff0c$sum$ \u53ef\u4ee5\u7531 $dep_u + dep_v - dep_{LCA(u, v)}$ \u5f97\u5230, \u5982\u6b64\u4fbf\u5b8c\u6210\u4e86 1 \u64cd\u4f5c\u3002\n\n\u5bf9\u4e8e 2 \u64cd\u4f5c\uff0c\u9009\u62e9 $u$ , $v$ \u4e2d\u4e3a\u513f\u5b50\u7684\u90a3\u4e2a\uff0c\u8bb0\u4e3a $p$ ,  \u4fee\u6539\u5176\u6743\u503c\uff0c\u800c\u5b83\u7684\u513f\u5b50\u7684\u524d\u7f00\u548c\u4e5f\u4f1a\u6539\u53d8\uff0c\u6539\u53d8\u503c\u5c31\u662f $now_p$ Xor $w$ , \u5728\u7ebf\u6bb5\u6811\u4e0a\u4fee\u6539\u5373\u53ef\uff0c\u540c\u65f6\u4e0d\u8981\u5fd8\u4e86\u5c06 $now_p$ \u6539\u4e3a $w$ .\n\n\u4e0e\u5176\u4ed6\u9898\u89e3\u4e0d\u540c\u7684\u662f\uff0c\u6211\u4eec\u4fee\u6539\u65f6\u5c06\u4fee\u6539\u503c\u76f4\u63a5\u4f20\u9012\uff0c\u8282\u7701\u4e86\u7a7a\u95f4\uff0c\u65f6\u95f4\u4e5f\u76f8\u5bf9\u6bd4\u8f83\u4f18\u79c0\u3002\n\n\u4e0b\u9762\u7ed9\u4e0a\u4ee3\u7801 $-->$\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cctype>\n#define ll long long\n#define inf 1023456789\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,w=0;char ch=getchar();\n\twhile (!isdigit(ch))w|=ch=='-',ch=getchar();\n\twhile (isdigit(ch))x=(x<<1)+(x<<3)+ch-'0',ch=getchar();\n\treturn w?-x:x;\n}\n\nstruct node{\n\tint to, nxt, val;\n}e[1000005];\n\nint n, q, head[100005], cnt;\n\ninline void add(int from, int to, int val){\n\te[++cnt].nxt = head[from];\n\thead[from] = cnt;\n\te[cnt].to = to;\n\te[cnt].val = val;\n}\n\nint f[100005], dep[100005], son[100005], siz[100005], vv[100005], two[15], QAQ[100005];\n\ninline void dfs1(int p, int fa, int w){\n\tvv[p] = w;\n\tf[p] = fa;\n\tdep[p] = dep[fa] + 1;\n\tsiz[p] = 1;\n\tfor(int i = head[p]; i; i = e[i].nxt ){\n\t\tif(e[i].to == fa) continue;\n\t\tdfs1(e[i].to , p, e[i].val ^ w);\n\t\tQAQ[e[i].to ] = e[i].val ;\n\t\tsiz[p] += siz[e[i].to ];\n\t\tif(siz[son[p]] < siz[e[i].to ]) son[p] = e[i].to ; \n\t}\n}\n\nint id[100005], top[100005], tot, vvv[100005];\n\ninline void dfs2(int p, int topf){\n\ttop[p] = topf;\n\tid[p] = ++tot;\n\tvvv[tot] = vv[p];\n\tif(!son[p]) return ;\n\tdfs2(son[p] , topf); \n\tfor(int i = head[p]; i; i = e[i].nxt ){\n\t\tif(e[i].to == f[p] || e[i].to == son[p]) continue ;\n\t\tdfs2(e[i].to ,e[i].to );\n\t}\n}\n\nstruct Segment_Tree{\n\tint val[12];\n\tint tag;\n}a[5000005]; \n\ninline int ls(int p){\n\treturn p << 1;\n} \n\ninline int rs(int p){\n\treturn p << 1 | 1;\n}\n\ninline void update(int p){\n\tfor(int i = 0; i <= 10; i++)\n\ta[p].val[i] = a[ls(p)].val[i] + a[rs(p)].val[i];\n}\n\ninline void push_up(int p, int l, int r, int k){\n\ta[p].tag ^= k;\n\tint now = 0;\n\twhile(k){\n\t\tif(k & 1) a[p].val[now] = r - l + 1 - a[p].val[now];\n\t\tnow ++;\n\t\tk >>= 1;\n\t}\n}\n\ninline void push_down(int p, int l, int r){\n\tif(!a[p].tag ) return ;\n\tint mid = l + r >> 1;\n\tpush_up(ls(p), l, mid, a[p].tag );\n\tpush_up(rs(p), mid + 1, r, a[p].tag );\n\ta[p].tag = 0;\n}\n\ninline void build(int p, int l, int r){\n\tif(l == r){\n\t\tint now = 0, w = vvv[l];\n\t\twhile(w){\n\t\t\ta[p].val[now] = w & 1;\n\t\t\tw >>= 1;\n\t\t\tnow++;\n\t\t}\n\t\treturn ;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(ls(p), l, mid);\n\tbuild(rs(p), mid + 1, r);\n\tupdate(p);\n}\n\nint ans[12];\n\ninline void modify(int p, int l, int r, int L, int R, int k){\n\tif(L <= l && r <= R){\n\t\tint now = 0, w = k;\n\t\twhile(w){\n\t\t\tif(w & 1)\n\t\t\ta[p].val[now] = r - l + 1 - a[p].val[now] ;\n\t\t\tw >>= 1;\n\t\t\tnow++;\n\t\t}\n\t\ta[p].tag ^= k;\n\t\treturn ;\n\t}\n\tpush_down(p, l, r);\n\tint mid = l + r >> 1;\n\tif(L <= mid) modify(ls(p), l, mid, L, R, k);\n\tif(mid < R) modify(rs(p), mid + 1, r, L, R, k);\n\tupdate(p);\n}\n\ninline void query(int p, int l, int r, int L, int R){\n\tif(L <= l && r <= R){\n\t\tfor(int i = 0; i <= 10; i++)\n\t\tans[i] += a[p].val[i];\n\t\treturn ;\n\t}\n\tpush_down(p, l, r);\n\tint mid = l + r >> 1;\n\tif(L <= mid) query(ls(p), l, mid, L, R);\n\tif(mid < R) query(rs(p), mid + 1, r, L, R); \n\tupdate(p);\n}\n\ninline ll query_range(int u, int v){\n\tint sum = dep[u] + dep[v];\n\tfor(int i = 0; i <= 10; i++) ans[i] = 0;\n\twhile(top[u] != top[v]){\n\t\tif(dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tquery(1, 1, n, id[top[u]], id[u]);\n\t\tu = f[top[u]];\n\t}\n\tif(dep[u] < dep[v]) swap(u, v);\n\tquery(1, 1, n, id[v], id[u]);\n\tsum += - 2 * dep[v] + 1;\n\tll res = 0;\n\tfor(int i = 0; i <= 10; i++){\n\t\tres += (ll) two[i] * ans[i] * (sum - ans[i]);\n\t}\n\treturn res;\n}\n\ninline void up_son(int p, int k){\n\tmodify(1, 1, n, id[p], id[p] + siz[p] - 1, k);\n}\n\nint main(){\n\tn = read(), q = read();\n\ttwo[0] = 1;\n\tfor(int i = 1; i <= 10; i++) two[i] = two[i - 1] * 2;\n\tfor(int i = 1; i < n; i++){\n\t\tint x = read(), y = read(), z = read();\n\t\tadd(x, y, z);\n\t\tadd(y, x, z);\n\t}\n\tdfs1(1, 0, 0);\n\tdfs2(1, 1);\n\tbuild(1, 1, n);\n\tfor(int i = 1; i <= q; i++){\n\t\tint opt = read();\n\t\tif(opt == 1){\n\t\t\tint u = read(), v = read();\n\t\t\tprintf(\"%lld\\n\",query_range(u, v));\n\t\t}\n\t\telse {\n\t\t\tint u = read(), v = read(), w = read();\n\t\t\tint ww = w;\n\t\t\tif(f[u] == v){\n\t\t\t\tw ^= QAQ[u];\n\t\t\t\tQAQ[u] = ww;\n\t\t\t\tup_son(u, w);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tw ^= QAQ[v];\n\t\t\t\tQAQ[v] = ww;\n\t\t\t\tup_son(v, w);\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n\u5b8c\u7ed3\u6492\u82b1*\u2605,\u00b0*:.\u2606(\uffe3\u25bd\uffe3)/$:*.\u00b0\u2605* \u3002",
        "postTime": 1599828605,
        "uid": 209604,
        "name": "pikabi",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "# \u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011\n[$\\mathfrak{View\\space it\\space on\\space my\\space Blog}$](https://blog.seniorious.cc/2019/luogu-3401/)\n## \u5206\u6790\n\u4ee4$s_u$\u4e3a$u$\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u5f02\u6216\u548c, $s_{u,v}$\u4e3a$u$\u5230$v$\u7684\u7b80\u5355\u8def\u5f84\u4e0a\u7684\u8fb9\u6743\u5f02\u6216\u548c\n\n\u7531\u6811\u4e0a\u5dee\u5206\u7684\u77e5\u8bc6\u53ef\u5f97$s_{u,v}=s_u\\otimes s_v\\otimes s_{lca}\\otimes s_{lca}=s_u\\otimes s_v$\n\n\u539f\u95ee\u9898\u53ef\u5316\u4e3a\u6c42$\\sum_{i,j\\in\\left\\langle u,v\\right\\rangle}s_i\\otimes s_j$\n\n## \u505a\u6cd5\n\u8003\u8651\u7ef4\u62a4\u6bcf\u4e00\u4f4d,\u82e5\u8def\u5f84$\\left\\langle u,v\\right\\rangle$\u7ecf\u8fc7$siz$\u4e2a\u7ed3\u70b9,\u5176\u4e2d$s$\u7684\u7b2c$i$\u4f4d\u4e3a$1$\u7684\u6709$cnt$\u4e2a,\u5219\u4e3a$0$\u7684\u6709$(siz-cnt)$\u4e2a\u7b2c$i$\u4f4d\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3a$cnt\\cdot(siz-cnt)\\cdot 2^i$(\u4e00\u4e2a$0$\u4e00\u4e2a$1$\u624d\u5bf9\u7b54\u6848\u6709\u8d21\u732e)\n\n\u8def\u5f84\u4e0a\u7ef4\u62a4$1$\u7684\u4e2a\u6570,\u5bb9\u6613\u60f3\u5230\u6811\u94fe\u5256\u5206\u52a0\u7ebf\u6bb5\u6811\n\n\u4fee\u6539\u64cd\u4f5c\u4e2d,\u5c06\u8fb9$(u,v)(dep_u<dep_v)$\u7684\u6743\u503c\u4fee\u6539\u4e3a$w$,\u539f\u6743\u503c\u4e3a$w_b$,\u82e5$w$\u7684\u7b2c$i$\u4f4d\u4e0e$w_b$\u7684\u7b2c$i$\u4f4d\u4e0d\u540c,\u5219\u5c06$v$\u6240\u5728\u5b50\u6811\u7684$s$\u7684\u7b2c$i$\u4f4d\u7ffb\u8f6c\u5373\u53ef,\u5177\u4f53\u5728\u7ebf\u6bb5\u6811\u4e0a,\u5bf9\u4e8e\u539f\u672c\u6709$cnt$\u4e2a$1$\u7684\u533a\u95f4$\\left[l,r\\right]$,\u5c06$1$\u7684\u4e2a\u6570\u6539\u4e3a$(r-l+1-cnt)$\n\n## \u4ee3\u7801\n```cpp\nconst int N = 30005;\nconst int M = 60005;\n#define lc(x) (x << 1)\n#define rc(x) (x << 1 | 1)\n\nvoid add(int, int, int);\nvoid dfs1(int);\nvoid dfs2(int);\nvoid build(int, int, int);\nvoid update(int, int, int);\nll query(int, int);\n\nint hed[N], nxt[M], to[M], val[M], id;\nint dep[N], fa[N], siz[N], son[N], top[N], ttl[N], ltt[N], tot;\nint vf[N];\nint xs[N];\nint sum[N << 2][10];\nbool tag[N << 2][10];\nint n, q;\n\nint main () {\n  read(n), read(q);\n  for (int i = 1; i < n; ++i) {\n    int u, v, w;\n    read(u), read(v), read(w);\n    add(u, v, w), add(v, u, w);\n  }\n  dfs1(1);\n  top[1] = 1;\n  dfs2(1);\n  build(1, 1, n);\n  for (int i = 1; i <= q; ++i) {\n    int type;\n    read(type);\n    int u, v;\n    read(u), read(v);\n    switch (type) {\n    case 1:\n      write(query(u, v)), EL;\n      break;\n    case 2:\n      int w;\n      read(w);\n      update(u, v, w);\n      break;\n    }\n  }\n  return 0;\n}\n\ninline void add(int u, int v, int w) {\n  nxt[++id] = hed[u];\n  hed[u] = id;\n  to[id] = v;\n  val[id] = w;\n}\nvoid dfs1(int u) {\n  siz[u] = 1;\n  for (int i = hed[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v != fa[u]) {\n      dep[v] = dep[u] + 1;\n      fa[v] = u;\n      xs[v] = xs[u] ^ val[i];\n      vf[v] = val[i];\n      dfs1(v);\n      siz[u] += siz[v];\n      if (siz[v] > siz[son[u]]) {\n        son[u] = v;\n      }\n    }\n  }\n}\nvoid dfs2(int u) {\n  ltt[ttl[u] = ++tot] = u;\n  if (son[u]) {\n    top[son[u]] = top[u];\n    dfs2(son[u]);\n  }\n  for (int i = hed[u]; i; i = nxt[i]) {\n    int v = to[i];\n    if (v != fa[u] && v != son[u]) {\n      top[v] = v;\n      dfs2(v);\n    }\n  }\n}\ninline void pushdown(int x, int xl, int xr, int bit) {\n  if (tag[x][bit]) {\n    int xm = (xl + xr) >> 1;\n    sum[lc(x)][bit] = (xm - xl + 1) - sum[lc(x)][bit];\n    sum[rc(x)][bit] = (xr - xm) - sum[rc(x)][bit];\n    tag[lc(x)][bit] ^= 1;\n    tag[rc(x)][bit] ^= 1;\n    tag[x][bit] = false;\n  }\n}\ninline void pushup(int x, int bit) {\n  sum[x][bit] = sum[lc(x)][bit] + sum[rc(x)][bit];\n}\nvoid update(int x, int xl, int xr, int bit, int ul, int ur) {\n  if (xl >= ul && xr <= ur) {\n    sum[x][bit] = (xr - xl + 1) - sum[x][bit];\n    tag[x][bit] ^= 1;\n    return;\n  }\n  pushdown(x, xl, xr, bit);\n  int xm = (xl + xr) >> 1;\n  if (xm >= ul) {\n    update(lc(x), xl, xm, bit, ul, ur);\n  }\n  if (xm < ur) {\n    update(rc(x), xm + 1, xr, bit, ul, ur);\n  }\n  pushup(x, bit);\n}\nint query(int x, int xl, int xr, int bit, int ql, int qr) {\n  if (xl >= ql && xr <= qr) {\n    return sum[x][bit];\n  }\n  pushdown(x, xl, xr, bit);\n  int xm = (xl + xr) >> 1;\n  int ans = 0;\n  if (xm >= ql) {\n    ans += query(lc(x), xl, xm, bit, ql, qr);\n  }\n  if (xm < qr) {\n    ans += query(rc(x), xm + 1, xr, bit, ql, qr);\n  }\n  return ans;\n}\nvoid build(int x, int xl, int xr) {\n  if (xl == xr) {\n    for (int i = 0; i < 10; ++i) {\n      sum[x][i] = (xs[ltt[xl]] >> i) & 1;\n    }\n    return;\n  }\n  int xm = (xl + xr) >> 1;\n  build(lc(x), xl, xm);\n  build(rc(x), xm + 1, xr);\n  for (int i = 0; i < 10; ++i) {\n    pushup(x, i);\n  }\n}\nvoid update(int u, int v, int w) {\n  int x = dep[u] < dep[v] ? v : u;\n  for (int i = 0; i < 10; ++i) {\n    if (((vf[x] ^ w) >> i) & 1) {\n      update(1, 1, n, i, ttl[x], ttl[x] + siz[x] - 1);\n    }\n  }\n  vf[x] = w;\n}\nll query(int u, int v) {\n  int cnt[10];\n  int siz = 0;\n  for (int i = 0; i < 10; ++i) {\n    cnt[i] = 0;\n  }\n  while (top[u] ^ top[v]) {\n    if (dep[top[u]] < dep[top[v]]) {\n      u ^= v ^= u ^= v;\n    }\n    siz += ttl[u] - ttl[top[u]] + 1;\n    for (int i = 0; i < 10; ++i) {\n      cnt[i] += query(1, 1, n, i, ttl[top[u]], ttl[u]);\n    }\n    u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) {\n    u ^= v ^= u ^= v;\n  }\n  siz += ttl[u] - ttl[v] + 1;\n  for (int i = 0; i < 10; ++i) {\n    cnt[i] += query(1, 1, n, i, ttl[v], ttl[u]);\n  }\n  ll ans = 0;\n  for (int i = 0; i < 10; ++i) {\n    ans += cnt[i] * (siz - cnt[i]) * 1ll * (1 << i);\n  }\n  return ans;\n}\n```\n",
        "postTime": 1577025704,
        "uid": 25251,
        "name": "moongazer",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "\u672c\u9898\u6709\u4e00\u4e2a\u5f31\u5316\u7248\u672c\uff1a[GDKOI2016\u9b54\u5361\u5c11\u5973](https://www.cnblogs.com/xiefengze1/p/9681682.html)\u3002\n\n\u5f31\u5316\u7248\u5927\u81f4\u9898\u610f\u662f\uff1a\u8be2\u95ee\u4e00\u4e2a\u533a\u95f4\u7684\u5b50\u533a\u95f4\u5f02\u6216\u548c\u3002\u5177\u4f53\u65b9\u6cd5\u662f\u62c6\u5f00\u4e8c\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\uff0c\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5f02\u6216\u524d\u7f00\u548c\u4e2d $0,1$ \u7684\u4e2a\u6570\uff0c\u4e2a\u6570\u76f8\u4e58\u540e\u518d\u52a0\u6743\u5373\u4e3a\u7b54\u6848\u3002\u8fd9\u6837\u6b63\u786e\u7684\u539f\u56e0\u662f\uff1a\u5bf9\u4e8e\u4e00\u4e2a\u6709\u8d21\u732e\u7684\u533a\u95f4 $[L,R]$\uff0c\u5b83\u4e00\u5b9a\u4f1a\u88ab $sum[L-1]$ \u548c $sum[R]$ \u7b97\u5230\u4e14\u4ec5\u4e00\u6b21\u3002\n\n\u7136\u540e\u8fd9\u9898\u53ea\u8981\u628a\u5e8f\u5217\u7684\u95ee\u9898\u642c\u5230\u6811\u94fe\u5256\u5206\u4e0a\u5c31\u884c\u4e86\uff0c\u7ec6\u8282\u5904\u7406\u6bd4\u8f83\u591a\uff08\u800c\u4e14\u9ebb\u70e6\uff09\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define mid ((L+R)>>1)\n#define lc (id<<1)\n#define rc (td<<1|1)\ntypedef long long LL;\n\nusing namespace std;\n\nconst int maxk=10,maxn=3e4+5;\n\nstruct edge {\n    int obj,len;\n    edge *Next;\n}e[maxn<<1];\n\nstruct data {\n    int sum,num0,num1;\n}tree[maxk][maxn<<2];\n\nedge *head[maxn];\nint cur=-1;\n\ndata zero;\n\nint fa[maxn],dep[maxn],Son[maxn],Size[maxn];\nint Top[maxn],dfsx[maxn],dfn[maxn],Time=0;\nint val[maxn],n,q;\n\ninline void Add(int x,int y,int z) {\n    ++cur;\n    e[cur].obj=y;\n    e[cur].len=z;\n    e[cur].Next=head[x];\n    head[x]=e+cur;\n    return ;\n}\n\ninline void Dfs1(int node) {\n    Size[node]=1;\n    for (edge *p=head[node];p;p=p->Next) {\n        int son=p->obj;\n        if(son==fa[node])\n            continue;\n        fa[son]=node;\n        val[son]=p->len;\n        dep[son]=dep[node]+1;\n        Dfs1(son);\n        Size[node]+=Size[son];\n        if(Size[son]>Size[Son[node]])\n            Son[node]=son;\n    }\n    return ;\n}\n\ninline void Dfs2(int node) {\n    dfsx[++Time]=node;\n    dfn[node]=Time;\n    if(Son[node])\n        Top[Son[node]]=Top[node],Dfs2(Son[node]);\n    for (edge *p=head[node];p;p=p->Next) {\n        int son=p->obj;\n        if(son==fa[node] || son==Son[node])\n            continue;\n        Top[son]=son;\n        Dfs2(son);\n    }\n    return ;\n}\n\ninline data Up(data x,data y) {\n    data z;\n    z.sum=x.sum^y.sum;\n    if(x.sum)\n        swap(y.num0,y.num1);\n    z.num0=x.num0+y.num0;\n    z.num1=x.num1+y.num1;\n    return z;\n}\n\ninline void Build(int i,int id,int L,int R) {\n    if(L==R) {\n        int v=((bool)(val[ dfsx[L] ]&(1<<i)));\n        tree[i][id].sum=v;\n        if(v)\n            ++tree[i][id].num1;\n        else\n            ++tree[i][id].num0;\n        return ;\n    }\n    Build(i,lc,L,mid);\n    Build(i,rc,mid+1,R);\n    tree[i][id]=Up(tree[i][lc],tree[i][rc]);\n    return ;\n}\n\ninline int Lca(int u,int v) {\n    if(Top[u]==Top[v])\n        return dfsx[min(dfn[u],dfn[v])];\n    if(dep[Top[u]]<dep[Top[v]])\n        swap(u,v);\n    return Lca(fa[Top[u]],v);\n}\n\ninline data Query(int i,int id,int L,int R,int x,int y) {\n    if(y<L || R<x)\n        return zero;\n    if(x<=L && R<=y)\n        return tree[i][id];\n    data vl=Query(i,lc,L,mid,x,y);\n    data vr=Query(i,rc,mid+1,R,x,y);\n    return Up(vl,vr);\n}\n\ninline data Get(int i,int u,int v) {\n    data x;\n    if(u==v)\n        x=zero;\n    else\n        x=Query(i,1,1,n,dfn[v]+1,dfn[u]);\n    ++x.num0;\n    if(x.sum)\n        swap(x.num0,x.num1);\n    return x;\n}\n\ninline data Work(int i,int u,int v) {\n    if(Top[u]==Top[v])\n        return Get(i,u,v);\n    int w=Top[u];\n    data y=Work(i,fa[w],v);\n    if(val[w]&(1<<i))\n        swap(y.num0,y.num1),y.sum^=1;\n    data x=Get(i,u,w);\n    return Up(x,y);\n}\n\ninline LL Query(int u,int v) {\n    int w=Lca(u,v);\n    LL ans=0;\n    for(int i=0;i<maxk;++i) {\n        data x=Work(i,u,w);\n        data y=Work(i,v,w);\n        if(y.sum)\n            swap(y.num0,y.num1);\n        --y.num0;\n        x=Up(x,y);\n        ans+=( (1LL<<i)*(long long)x.num0*(long long)x.num1 );\n    }\n    return ans;\n}\n\ninline void Update(int i,int id,int L,int R,int x) {\n    if(L==x && x==R) {\n        tree[i][id]=zero;\n        int v=((bool)(val[ dfsx[L] ]&(1<<i)));\n        tree[i][id].sum=v;\n        if(v)\n            ++tree[i][id].num1;\n        else\n            ++tree[i][id].num0;\n        return ;\n    }\n    if(x<L || R<x)\n        return ;\n    Update(i,lc,L,mid,x);\n    Update(i,rc,mid+1,R,x);\n    tree[i][id]=Up(tree[i][lc],tree[i][rc]);\n    return ;\n}\n\nint main() {\n#ifdef\n    freopen(\"tree.in\",\"r\",stdin);\n    freopen(\"tree.out\",\"w\",stdout);\n#endif\n    scanf(\"%d%d\",&n,&q);\n    for(int i=1;i<=n;++i)\n        head[i]=NULL;\n    for(int i=1;i<n;++i) {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        Add(x,y,z);\n        Add(y,x,z);\n    }\n    dep[1]=1;\n    Dfs1(1);\n    Top[1]=1;\n    Dfs2(1);\n    for(int i=0;i<maxk;++i)\n        Build(i,1,1,n);\n    zero.sum=zero.num0=zero.num1=0;\n    while(q--) {\n        int x,u,v,w;\n        scanf(\"%d%d%d\",&x,&u,&v);\n        if(x==1)\n            printf(\"%lld\\n\",Query(u,v));\n        else {\n            scanf(\"%d\",&w);\n            if(fa[u]!=v)\n                swap(u,v);\n            val[u]=w;\n            for(int i=0;i<maxk;++i)\n                Update(i,1,1,n,dfn[u]);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1599992221,
        "uid": 108103,
        "name": "liuyongle",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "\u534a\u5e74\u6ca1\u5199\u6811\u5256\u4e86\uff0c\u5c31\u5f53\u6a21\u677f\u7ec3\u4e00\u4e0b\n\n\u9996\u5148\u8bbe\u6839\u8282\u70b9\u5230$i$\u8def\u5f84\u4e0a\u7684\u5f02\u6216\u548c\u4e3a$val[i]$\uff0c\u5219$i$\u5230$j$\u8def\u5f84\u7684\u5f02\u6216\u548c\u4e3a$val[i]\\oplus val[j]$\u3002\n\n\u5bf9\u4e8e$i$\u5230$j$\u6240\u6709\u5b50\u8def\u5f84\u7684\u5f02\u6216\u548c\u7684\u548c\uff0c\u5bf9\u6bcf\u4e00\u4f4d\u5206\u5f00\u6765\u8003\u8651\uff0c\u5bf9\u4e8e\u7b2c$i$\u4f4d\uff0c\u53d1\u73b0\u8d21\u732e\u5c31\u662f$(1<<i)\\times gs(0)\\times gs(1)$\uff0c\u5176\u4e2d$gs(x)$\u4e3a$i$\u5230$j$\u8def\u5f84\u4e0a$x$\u7684\u4e2a\u6570\u3002\n\n$gs(0/1)$\u663e\u7136\u53ef\u4ee5\u6811\u5256$+$\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5bf9\u4e8e\u4e00\u6b21\u4fee\u6539\uff0c\u76f4\u63a5\u7ffb\u8f6c\u5b50\u6811\u5185\u7684$0,1$\u4e2a\u6570\u5373\u53ef\uff0c\u7528\u6811\u5256$+$\u7ebf\u6bb5\u6811\u53ef\u4ee5\u8f7b\u677e\u7ef4\u62a4\u3002\n\n$Code\\ Below:$\n```cpp\n#include<bits/stdc++.h>\n#define ts cout<<\"ok\"<<endl\n#define int long long\n#define hh puts(\"\")\n#define pc putchar\n#define ls(x) ((x)<<1)\n#define rs(x) ((x)<<1|1)\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n//char buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nconst int N=30005;\nint n,q,cnt,head[N],val[N],f[N],eg[N],sz[N],d[N],son[N];\nint top[N],id[N],rk[N],sum[10][N<<2],tag[10][N<<2];\nstruct Edge{\n    int v,nx,s;\n}e[N<<1];\ninline int read(){\n    int ret=0,ff=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') ff=-1;ch=getchar();}\n    while(isdigit(ch)){ret=ret*10+(ch^48);ch=getchar();}\n    return ret*ff;\n}\nvoid write(int x){if(x<0){x=-x,pc('-');}if(x>9) write(x/10);pc(x%10+48);}\nvoid writeln(int x){write(x),hh;}\nvoid writesp(int x){write(x),pc(' ');}\nvoid add(int x,int y,int s){\n    e[++cnt].v=y;\n    e[cnt].nx=head[x];\n    e[cnt].s=s;\n    head[x]=cnt;\n}\nvoid dfs1(int now,int fa){\n    sz[now]=1;d[now]=d[fa]+1;\n    for(int i=head[now];i;i=e[i].nx){\n        int v=e[i].v;\n        if(v==fa) continue;\n        val[v]=val[now]^e[i].s;\n        dfs1(v,now);\n        f[v]=now;\n        eg[v]=e[i].s;\n        sz[now]+=sz[v];\n        if(sz[v]>sz[son[now]]) son[now]=v;\n    } \n}\nvoid dfs2(int now,int fa){\n    top[now]=fa;\n    id[now]=++cnt;\n    rk[cnt]=now;\n    if(son[now]) dfs2(son[now],fa);\n    for(int i=head[now];i;i=e[i].nx){\n        int v=e[i].v;\n        if(f[now]==v||v==son[now]) continue;\n        dfs2(v,v);\n    }\n}\nvoid build(int l,int r,int k){\n    if(l==r){\n        for(int i=0;i<=9;i++) sum[i][k]=(val[rk[l]]>>i)&1;\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(l,mid,ls(k));\n    build(mid+1,r,rs(k));\n    for(int i=0;i<=9;i++) sum[i][k]=sum[i][ls(k)]+sum[i][rs(k)];\n}\nvoid push_down(int tt,int l,int r,int k){\n    if(tag[tt][k]){\n        int mid=(l+r)>>1;\n        tag[tt][ls(k)]^=1;\n        tag[tt][rs(k)]^=1;\n        sum[tt][ls(k)]=mid-l+1-sum[tt][ls(k)];\n        sum[tt][rs(k)]=r-mid-sum[tt][rs(k)];\n        tag[tt][k]=0;\n    }\n}\nvoid update(int l,int r,int x,int y,int tt,int k){\n    if(x<=l&&r<=y){\n        sum[tt][k]=r-l+1-sum[tt][k];\n        tag[tt][k]^=1;\n        return;\n    }\n    push_down(tt,l,r,k);\n    int mid=(l+r)>>1;\n    if(x<=mid) update(l,mid,x,y,tt,ls(k));\n    if(mid+1<=y) update(mid+1,r,x,y,tt,rs(k));\n    sum[tt][k]=sum[tt][ls(k)]+sum[tt][rs(k)];\n}\nint query(int l,int r,int x,int y,int tt,int k){\n    if(x<=l&&r<=y) return sum[tt][k];\n    push_down(tt,l,r,k);\n    int mid=(l+r)>>1,res=0;\n    if(x<=mid) res+=query(l,mid,x,y,tt,ls(k));\n    if(mid+1<=y) res+=query(mid+1,r,x,y,tt,rs(k));\n    return res;\n}\nint LCA(int x,int y){\n    while(top[x]!=top[y]){\n        if(d[top[x]]>d[top[y]]) x=f[top[x]];\n        else y=f[top[y]]; \n    }\n    if(d[x]>d[y]) return y;\n    return x;\n}\nint ask(int x,int y,int tt){\n    if(d[x]<d[y]) swap(x,y);\n    int lca=LCA(x,y),tot=0,gs=0;\n    tot=d[x]+d[y]-2*d[lca]+1;\n    while(top[x]!=top[y]){\n        if(d[top[x]]<d[top[y]]) swap(x,y);\n        gs+=query(1,n,id[top[x]],id[x],tt,1);\n        x=f[top[x]];\n    }\n    if(id[x]>id[y]) swap(x,y);\n    gs+=query(1,n,id[x],id[y],tt,1);\n    return gs*(tot-gs);\n}\nsigned main(){\n    n=read(),q=read();\n    for(int i=1;i<n;i++){\n        int x=read(),y=read(),s=read();\n        add(x,y,s),add(y,x,s);\n    }\n    dfs1(1,0);cnt=0;\n    dfs2(1,1);\n    build(1,n,1);\n    for(int i=1;i<=q;i++){\n        int opt=read();\n        if(opt==1){\n            int x=read(),y=read();\n            int ans=0;\n            for(int i=0;i<=9;i++) ans+=ask(x,y,i)*(1<<i);\n            writeln(ans);\n        }\n        if(opt==2){\n            int x=read(),y=read(),s=read();\n            if(d[x]<d[y]) swap(x,y);\n            for(int i=0;i<=9;i++)\n                if(((eg[x]>>i)&1)^((s>>i)&1))\n                    update(1,n,id[x],id[x]+sz[x]-1,i,1);\n            eg[x]=s;\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1591526348,
        "uid": 27858,
        "name": "ycyaw",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "# \u6d1b\u8c37\u6811\n[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P3401)\n## \u601d\u8def\n\u8fd9\u9053\u9898\u771f\u7684\u795e\u4ed9\u3002\n\n\u9996\u5148~~\u901a\u8fc7\u6807\u7b7e~~\u53ef\u4ee5\u770b\u51fa\u8fd9\u662f\u9053\u6811\u5256\u7684\u9898\u76ee\u3002\u4f46\u662f\u6240\u6709\u5b50\u8def\u5f84\u7684\u5f02\u6216\u548c\uff1f**Are you kidding me?** \u4e0d\u614c\uff0c\u6211\u4eec\u6765\u5206\u6790\u4e00\u6ce2\u3002\n\n\u9996\u5148\uff0c\u8bbe$val[u]$\u8868\u793a\u4ece\u6839\u5230$u$\u7684\u8def\u5f84\u5f02\u6216\u548c\uff0c\u90a3\u4e48$u\\to v$\u7684\u5f02\u6216\u548c\u5c31\u662f$val[u] \\text{ xor } val[v]$\u3002\u90a3\u4e48\uff0c\u6c42\u4e24\u4e2a\u70b9\u4e4b\u95f4\u4efb\u610f\u5b50\u8def\u5f84\u7684\u5f02\u6216\u548c\u5c31\u662f\u8def\u5f84\u4e2d\u4efb\u610f\u4e24\u4e2a\u7684$val[\\ \\ ]$\u5f02\u6216\u548c\u3002\n\n\u90a3\u6211\u4eec\u5982\u4f55\u7ef4\u62a4\u5462\uff1f\u54a6\uff0c\u6743\u503c\u600e\u4e48\u8fd9\u4e48\u5c0f\uff1f\u4e8e\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u5bf9\u4e8e\u4e8c\u8fdb\u5236\u4e2d\u7684\u6bcf\u4e00\u4f4d\u90fd\u5efa\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u7684\u662f\u4e00\u6bb5\u533a\u95f4\u5185\u8fd9\u4e00\u4f4d\u4e3a$0/1$\u7684\u6570\u5b57\u4e2a\u6570\u3002\n\n\u90a3\u5982\u4f55\u6c42\u5230\u7b54\u6848\u5462\uff1f\u5bf9\u4e8e\u6bcf\u4e00\u4f4d\u6765\u8bf4\uff0c\u53ea\u6709\u4e24\u4e2a\u70b9\u8fd9\u4e00\u4f4d\u5206\u522b\u4e3a$0$\u548c$1$\u7684\u65f6\u5019\u624d\u4f1a\u4ea7\u751f$2^i$\u7684\u8d21\u732e\u3002\u4e8e\u662f\uff0c\u53ef\u4ee5\u7edf\u8ba1\u4e00\u4e0b\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u4e2d\u8fd9\u4e00\u4f4d\u4e3a$0$\u548c\u4e3a$1$\u7684\u4e2a\u6570\uff0c\u4e24\u8005\u76f8\u4e58\uff0c\u518d\u4e58\u4e0a$2^i$\uff0c\u5c31\u662f\u7b54\u6848\u3002\n\n\u4fee\u6539\u5462\uff1f\u6211\u4eec\u53d1\u73b0\uff0c\u6bcf\u6b21\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u7684\u4fee\u6539\uff0c\u5f71\u54cd\u7684\u5176\u5b9e\u662f\u4e00\u4e2a\u5b50\u6811\u3002\u800c\u4e14\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4f4d\u6765\u8bf4\uff0c\u53ea\u6709\u5f53\u65b0\u503c\u548c\u65e7\u503c\u4e0d\u4e00\u6837\u624d\u4f1a\u5f71\u54cd\uff0c\u800c\u4e14\u6070\u597d\u5b50\u6811\u5185\u8fd9\u4e00\u4f4d$0$\u7684\u4e2a\u6570\u548c$1$\u7684\u4e2a\u6570\u4f1a\u4e92\u6362\u3002\n\n\u7136\u540e\u5c31\u6ca1\u6709\u4ec0\u4e48\u7406\u8bba\u4e0a\u7684\u95ee\u9898\u4e86\uff0c\u5177\u4f53\u5b9e\u73b0\u89c1\u4ee3\u7801\u3002\n## $\\text {Code}$\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define int long long\n#define MAXN 30005\n\nstruct edge\n{\n\tint v,w,nxt;\n}e[MAXN << 1];\n\nint toop = 1;\nint head[MAXN];\n\nvoid Add_Edge (int u,int v,int w)\n{\n\te[++ toop] = edge {v,w,head[u]};head[u] = toop;\n\te[++ toop] = edge {u,w,head[v]};head[v] = toop;\t\n}\n\nint n,q,Index;\nint las[MAXN],dep[MAXN],tur[MAXN],par[MAXN],val[MAXN],dfn[MAXN],top[MAXN],son[MAXN],size[MAXN];\n\nvoid dfs1 (int u,int fa)\n{\n\tpar[u] = fa;\n\tsize[u] = 1;\n\tdep[u] = dep[fa] + 1;\n\tfor (Int i = head[u];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v,w = e[i].w;\n\t\tif (v == fa) continue;\n\t\tval[v] = val[u] ^ w;\n\t\tlas[v] = w;\n\t\tdfs1 (v,u);\n\t\tsize[u] += size[v];\n\t\tif (size[v] > size[son[u]]) son[u] = v;\n\t}\n}\n\nvoid dfs2 (int u,int Top)\n{\n\tdfn[u] = ++ Index,tur[Index] = u,top[u] = Top;\n\tif (son[u]) dfs2 (son[u],Top);\n\tfor (Int i = head[u];i;i = e[i].nxt)\n\t{\n\t\tint v = e[i].v;\n\t\tif (v == son[u] || v == par[u]) continue;\n\t\tdfs2 (v,v);\n\t}\n}\n\nstruct Node\n{\n\tint l,r,lazy,num0,num1;\n\tNode operator + (const Node &p)const{return Node {0,0,0,num0 + p.num0,num1 + p.num1};}\n}tree[11][MAXN << 2];\n\nvoid Pushup (int k,int i)\n{\n\ttree[k][i].num0 = tree[k][i << 1].num0 + tree[k][i << 1 | 1].num0;\n\ttree[k][i].num1 = tree[k][i << 1].num1 + tree[k][i << 1 | 1].num1;\n}\n\nvoid Pushdown (int k,int i)\n{\n\tif (!tree[k][i].lazy) return ;\n\tswap (tree[k][i << 1].num0,tree[k][i << 1].num1);\n\tswap (tree[k][i << 1 | 1].num0,tree[k][i << 1 | 1].num1);\n\ttree[k][i << 1].lazy ^= 1,tree[k][i << 1 | 1].lazy ^= 1;\n\ttree[k][i].lazy = 0;\n}\n\nvoid build (int k,int i,int l,int r)\n{\n\ttree[k][i].l = l,tree[k][i].r = r;\n\tif (l == r) \n\t{\n\t\tint get = val[tur[l]];\n\t\tif (get >> k & 1) tree[k][i].num1 = 1;\n\t\telse tree[k][i].num0 = 1;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild (k,i << 1,l,mid),build (k,i << 1 | 1,mid + 1,r);\n\tPushup (k,i);\n}\n\nvoid Reverse (int k,int i,int l,int r)\n{\n\tif (tree[k][i].l > r || l > tree[k][i].r) return ;\n\tif (tree[k][i].l >= l && tree[k][i].r <= r)\n\t{\n\t\tswap (tree[k][i].num0,tree[k][i].num1);\n\t\ttree[k][i].lazy ^= 1;\n\t\treturn ;\n\t}\n\tPushdown (k,i);\n\tReverse (k,i << 1,l,r);\n\tReverse (k,i << 1 | 1,l,r);\n\tPushup (k,i);\n}\n\nvoid Change (int u,int w)\n{\n\tfor (Int i = 0;i <= 10;++ i)\n\t\tif ((w ^ las[u]) >> i & 1)\n\t\t\tReverse (i,1,dfn[u],dfn[u] + size[u] - 1);\n\tlas[u] = w;\n}\n\nNode query (int k,int i,int l,int r)\n{\n\tif (tree[k][i].l > r || l > tree[k][i].r) return Node {0,0,0,0,0};\n\tif (tree[k][i].l >= l && tree[k][i].r <= r) return tree[k][i];\n\tPushdown (k,i);\n\treturn query (k,i << 1,l,r) + query (k,i << 1 | 1,l,r);\n}\n\nint Tree_Query (int x,int y)\n{\n\tint Ans = 0;\n\tfor (Int i = 0;i <= 10;++ i)\n\t{\n\t\tint u = x,v = y;\n\t\tNode Now = Node {0,0,0,0,0};\n\t\twhile (top[u] ^ top[v])\n\t\t{\n\t\t\tif (dep[top[u]] < dep[top[v]]) swap (u,v);\n\t\t\tNow = Now + query (i,1,dfn[top[u]],dfn[u]);\n\t\t\tu = par[top[u]];\n\t\t}\n\t\tif (dfn[u] > dfn[v]) swap (u,v);\n\t\tNow = Now + query (i,1,dfn[u],dfn[v]);\n\t\tAns += (1 << i) * Now.num0 * Now.num1;\n\t}\n\treturn Ans;\n}\n\nint read ()\n{\n\tint x = 0;char c = getchar();int f = 1;\n\twhile (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}\n\twhile (c >= '0' && c <= '9'){x = (x << 3) + (x << 1) + c - '0';c = getchar();}\n\treturn x * f;\n}\n\nvoid write (int x)\n{\n\tif (x < 0){x = -x;putchar ('-');}\n\tif (x > 9) write (x / 10);\n\tputchar (x % 10 + '0');\n}\n\nsigned main()\n{\n\tn = read (),q = read ();\n\tfor (Int i = 2;i <= n;++ i)\n\t{\n\t\tint u = read (),v = read (),w = read ();\n\t\tAdd_Edge (u,v,w);\n\t}\n\tdfs1 (1,0);\n\tdfs2 (1,1);\n\tfor (Int i = 0;i <= 10;++ i) build (i,1,1,n);\n\tfor (Int i = 1;i <= q;++ i)\n\t{\n\t\tint type = read (),u = read (),v = read (),w;\n\t\tif (type == 1) write (Tree_Query (u,v)),putchar ('\\n');\n\t\telse w = read (),u = (dep[u] < dep[v] ? v : u),Change (u,w);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1585101242,
        "uid": 124781,
        "name": "Walking_Dead",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "[\u9898\u9762](https://www.luogu.com.cn/problem/P3401)\n\n\u9996\u5148\u53ef\u4ee5\u77e5\u9053\u6700\u7ec8\u7684\u7b54\u6848\u4e00\u5b9a\u662f\uff1a\n\n$$\n\\sum{\\sum{xr_x\\oplus xr_y}}\n$$\n\n\u5176\u4e2d $xr_i$ \u6307 $i$ \u8282\u70b9\u5230\u6839\u7684\u5f02\u6216\u548c\uff0c\u800c $x,y$ \u90fd\u662f\u5728 $u\\to v$ \u7684\u8def\u5f84\u4e0a\u7684\u3002\n\n\u6709\u6811\u4e0a\u8def\u5f84\u67e5\u8be2\u548c\u4fee\u6539\uff0c\u52a0\u4e0a\u8fd9 $n$ \u7684\u8303\u56f4\uff0c\u53ef\u4ee5\u5927\u6982\u786e\u5b9a\u662f\u6811\u5256\u5957\u4e00\u4e2a\u5e26 $\\log$ \u7684\u6570\u636e\u7ed3\u6784\u3002\n\n\u6709\u4e00\u4e2a\u57fa\u7840\u7684\u601d\u8def\u662f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u91cd\u94fe\u533a\u95f4\u7684\u6700\u7ec8\u7b54\u6848\u3002\n\n\u4f46\u663e\u7136\u8fd9\u6837\u662f\u4e0d\u53ef\u884c\u7684\u3002\n\n\u90a3\u6211\u4eec\u53ef\u4ee5\u56de\u5f52\u5f02\u6216\u7684\u672c\u8d28\uff1a\u4e00\u79cd**\u6309\u4f4d**\u7684\u8fd0\u7b97\u3002\n\n\u770b\u5230 $w$ \u53ea\u6709 $2^{10}-1$\uff0c\u4e5f\u5c31\u662f\u4e8c\u8fdb\u5236\u4e2d\u6700\u591a\u53ea\u6709 $10$ \u4f4d\uff0c\u662f\u5426\u53ef\u4ee5\u5c06\u6bcf\u4e00\u4f4d\u90fd\u5206\u522b\u8bb0\u5f55\u5462\uff1f\n\n\u6211\u4eec\u53d1\u73b0 $0\\oplus 0=0,0\\oplus 1=1,1\\oplus 1=0$\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e8c\u8fdb\u5236\u4e2d\u6bcf\u4e00\u4f4d\u4e2d\u76f8\u540c\u7684\u6570\u5f02\u6216\u662f $0$\uff0c\u4e0d\u540c\u662f $1$\u3002\n\n\u90a3\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u8bb0\u5f55\u91cd\u94fe\u533a\u95f4\u5185\u6240\u6709 $xr$ \u6bcf\u4e00\u4f4d\u7684 $0,1$ \u7684\u4e2a\u6570\u3002\n\n\u77e5\u9053\u4e86\u7b2c $i$ \u4f4d\u662f $1$ \u7684 $xr$ \u7684\u6570\u91cf $a$\uff0c$0$ \u7684\u662f $b$\uff0c\u90a3\u8fd9\u4e00\u4f4d\u7684\u8d21\u732e\u5c31\u662f $2^iab$\u3002\n\n\u53ea\u8981\u6211\u4eec\u77e5\u9053\u6bcf\u4e00\u4f4d\u7684 $a,b$\uff0c\u5c31\u53ef\u4ee5\u77e5\u9053\u6700\u7ec8\u7b54\u6848\u3002\n\n\u800c\u5b9e\u9645\u4e0a\u77e5\u9053 $a+b$ \u662f\u5f88\u5bb9\u6613\u7684\uff0c\u56e0\u6b64\u53ea\u9700\u8981\u7ef4\u62a4 $a$ \u6216 $b$ \u5373\u53ef\u3002\n\n\u90a3\u67e5\u8be2\u5c31\u5f88\u5bb9\u6613\u4e86\uff0c\u4fee\u6539\u5462\uff1f\n\n\u56e0\u4e3a\u7ef4\u62a4\u7684\u662f\u524d\u7f00\u5f02\u6216\u548c\uff0c\u6240\u4ee5\u4fee\u6539\u4e00\u6761\u8fb9\u4e00\u5b9a\u4f1a\u5f71\u54cd\u5230\u8fd9\u6761\u8fb9\u6df1\u5ea6\u66f4\u6df1\u7684\u70b9\u7684\u5b50\u6811\u4e0a\u7684\u6240\u6709\u8fb9\uff0c\u56e0\u6b64\u9700\u8981\u4e00\u4e2a\u533a\u95f4\u4fee\u6539\u3002\n\n\u800c\u5982\u679c\u65b0\u4fee\u6539\u7684\u503c\u548c\u65e7\u7684\u503c\u7684\u7b2c $i$ \u4f4d\u4e0d\u76f8\u7b49\uff0c\u8bf4\u660e\u5b50\u6811\u7684\u8fd9\u4e00\u4f4d\u90fd\u4f1a\u6539\u53d8\uff0c\u56e0\u6b64\u4ea4\u6362\u4e00\u4e0b $0,1$ \u7684\u6570\u91cf\u5c31\u884c\u4e86\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define LL long long\n#define N 30005\nusing namespace std;\nint n,q,op,u,v,w;\nint head[N],nxt[N<<1],to[N<<1],e[N<<1],cnt;\ninline void add(int x,int y,int z){\n    e[++cnt]=z;\n    to[cnt]=y;\n    nxt[cnt]=head[x];\n    head[x]=cnt;\n}\nint dep[N],siz[N],fa[N],son[N],m[N],xr[N];\nint id[N],rnk[N],tot,tp[N];\nvoid dfs1(int k,int f){\n    dep[k]=dep[fa[k]=f]+1;siz[k]=1;\n    for(int i(head[k]);i;i=nxt[i]){\n        int s(to[i]);\n        if(!(s^f)) continue;\n        xr[s]=xr[k]^(m[s]=e[i]);dfs1(s,k);\n        if(siz[s]>siz[son[k]]) son[k]=s;\n        siz[k]+=siz[s];\n    }\n}\nvoid dfs2(int k,int t){\n    rnk[id[k]=++tot]=k;tp[k]=t;\n    if(son[k]) dfs2(son[k],t);\n    for(int i(head[k]);i;i=nxt[i]){\n        int s(to[i]);\n        if(!(s^fa[k])||!(s^son[k])) continue;\n        dfs2(s,s);\n    }\n}\nint c[N<<2][15],tag[N<<2][15],ans[15];\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define mid (l+r>>1)\ninline void pushup(int k){\n    for(int i(0);i<=10;++i)\n        c[k][i]=c[ls][i]+c[rs][i];\n}\nvoid Build(int k,int l,int r){\n    if(l==r){\n        for(int i(0);i<=10;++i)\n            if((1<<i)&xr[rnk[l]]) c[k][i]=1;\n        return;\n    }\n    Build(ls,l,mid);\n    Build(rs,mid+1,r);\n    pushup(k);\n}\ninline void pushdown(int k,int l,int r){\n    for(int i(0);i<=10;++i){\n        if(!tag[k][i]) continue;\n        c[ls][i]=mid-l+1-c[ls][i];\n        c[rs][i]=r-mid-c[rs][i];\n        tag[ls][i]^=1;\n        tag[rs][i]^=1;\n        tag[k][i]=0;\n    }\n}\nvoid Query(int k,int l,int r,int x,int y){\n    if(l>y||r<x) return;\n    if(x<=l&&r<=y){\n        for(int i(0);i<=10;++i)\n            ans[i]+=c[k][i];\n        return;\n    }\n    pushdown(k,l,r);\n    Query(ls,l,mid,x,y);\n    Query(rs,mid+1,r,x,y);\n}\nvoid Update(int k,int l,int r,int x,int y,int z){\n    if(l>y||r<x) return;\n    if(x<=l&&r<=y){\n        c[k][z]=r-l+1-c[k][z];\n        tag[k][z]^=1;\n        return;\n    }\n    pushdown(k,l,r);\n    Update(ls,l,mid,x,y,z);\n    Update(rs,mid+1,r,x,y,z);\n    pushup(k);\n}\ninline int LCA(int x,int y){\n    while(tp[x]^tp[y]){\n        if(dep[tp[x]]<dep[tp[y]]) swap(x,y);\n        x=fa[tp[x]];\n    }\n    if(dep[x]>dep[y]) swap(x,y);\n    return x;\n}\ninline LL QUERY(int x,int y){\n    LL len(dep[x]+dep[y]-(dep[LCA(x,y)]<<1)+1),res(0);\n    memset(ans,0,sizeof(ans));\n    while(tp[x]^tp[y]){\n        if(dep[tp[x]]<dep[tp[y]]) swap(x,y);\n        Query(1,1,n,id[tp[x]],id[x]);x=fa[tp[x]];\n    }\n    if(id[x]>id[y]) swap(x,y);\n    Query(1,1,n,id[x],id[y]);\n    for(int i(0);i<=10;++i)\n        res+=(1LL<<i)*ans[i]*(len-ans[i]);\n    return res;\n}\ninline void UPDATE(int x,int y){\n    for(int i(0);i<=10;++i)\n        if((1<<i)&(m[x]^y))\n            Update(1,1,n,id[x],id[x]+siz[x]-1,i);\n    m[x]=y;\n}\nint main(){\n    scanf(\"%d%d\",&n,&q);\n    for(int i(1);i<n;++i){\n        scanf(\"%d%d%d\",&u,&v,&w);\n        add(u,v,w);add(v,u,w);\n    }\n    dfs1(1,0),dfs2(1,1);Build(1,1,n);\n    while(q--){\n        scanf(\"%d%d%d\",&op,&u,&v);\n        if(op^2) printf(\"%lld\\n\",QUERY(u,v));\n        else{\n            scanf(\"%d\",&w);\n            if(dep[u]<dep[v]) swap(u,v);\n            UPDATE(u,w);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1665575285,
        "uid": 554574,
        "name": "gyyyyx",
        "ccfLevel": 0,
        "title": "P3401 \u6d1b\u8c37\u6811"
    },
    {
        "content": "## Problem\n\n[Luogu](https://www.luogu.com.cn/problem/P3401)\n\n## Solution\n\n\u9996\u5148\u601d\u8003\u4e00\u4e2a\u95ee\u9898\uff0c\u6211\u4eec\u600e\u4e48\u6c42\u5f97\u4e00\u4e2a\u8def\u5f84\u7684\u5f02\u6216\u8d77\u6765\u7684\u548c\u5462\uff1f\n\n\u6ca1\u9519\uff0c\u5feb\u901f\u4e00\u70b9\u7684\u65b9\u6cd5\u5c31\u662f\u524d\u7f00\u548c\uff0c\u5229\u7528\u5f02\u6216\u524d\u7f00\u548c\u53ef\u4ee5\u89e3\u51b3\u4e00\u4e9b\u95ee\u9898\n\n\u5f02\u6216\u6709\u4e2a\u6027\u8d28 $a\\otimes b\\otimes b=a$\uff0c\u6240\u4ee5 $s_{u,v}=s_u\\otimes s_v\\otimes s_{lca}\\otimes s_{lca}=s_u\\otimes s_v$\u3002\n\n\u6240\u4ee5 $\\sum_{i,j \\in (u,v)} s_i \\otimes s_j$\n\n\u90a3\u4e48\u4f60\u5df2\u7ecf\u638c\u63e1\u4e86\u66b4\u529b\u89e3\u6cd5\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u4f18\u5316\uff01\n\n\u9996\u5148\u60f3\u4e00\u4e2a\u95ee\u9898\n\n\u5bf9\u4e8e\u4e00\u4e2a\u8def\u5f84 $(x,y)$\uff0c\u6211\u4eec\u5e94\u8be5\u600e\u4e48\u641e\u51fa\u4ed6\u7684\u7b54\u6848\u5462\uff1f\n\n\u770b\u5230 $0 \\leq w \\leq 2^{10}-1$\uff0c\u4f60\u662f\u4e0d\u662f\u6709\u4e9b\u987f\u609f\u634f\uff1f\n\n\u55ef\uff0c\u90a3\u4e48\u719f\u7ec3\u70b9\uff0c\u62c6\u4e8c\u8fdb\u5236\u4f4d\u5bf9\u4e8e\u6c42\u89e3\u5f02\u6216\u4f3c\u4e4e\u662f\u4e00\u4e2a\u5f88\u65b9\u4fbf\u7684\u505a\u6cd5\n\n\u7136\u540e\u6211\u4eec\u9488\u5bf9\u67d0\u4e2a\u4e8c\u8fdb\u5236\u4f4d\u7814\u7a76\uff1a\n\n\u5bf9\u4e00\u4e2a\u8def\u5f84\uff0c$s_x \\otimes s_y$\uff0c\u624d\u4f1a\u5bf9\u7b54\u6848\u6709 1 \u7684\u8d21\u732e\n\n\u90a3\u4e48\u8981\u6c42\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u5bf9\u7b54\u6848\u6709\u8d21\u732e\u7684\u70b9\u5bf9\uff0c\u5e94\u8be5\u662f\u4e00\u4e2a\u4e3a 1 \u4e00\u4e2a\u4e3a 0\uff0c\u5373\u6570\u503c\u4e0d\u540c\u3002\n\n\u90a3\u4e48\u8fd9\u4e00\u4f4d\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5e94\u4e3a 1 \u7684\u4e2a\u6570\u4e58\u4e0a 0 \u7684\u4e2a\u6570\u4e58\u4e0a $(1<<i)$\u3002\n\n\u597d\u4e86\uff0c\u6211\u4eec\u5927\u6982\u77e5\u9053\u8fd9\u4e48\u6c42\u4e86\uff0c\u5bf9\u4e8e\u6811\u4e0a\u8def\u5f84\u5f53\u7136\u662f\u4f7f\u7528\u6811\u5256\u62c9\uff08\u4f60\u7528 LCT \u6211\u6ca1\u610f\u89c1\uff09\n\n\u7136\u540e\u5462\u5efa\u7acb\u4e00\u4e2a\u7ebf\u6bb5\u6811\uff0c\u8bb0\u5f55\u4e0b\u6bcf\u4e00\u4e2a\u70b9\u5230\u6839\u7684\u5f02\u6216\u524d\u7f00\u548c\uff0c\u7136\u540e\u518d\u4fdd\u5b58\u4e0b 1 \u7684\u4e2a\u6570\u4ee5\u53ca 0 \u7684\u4e2a\u6570\n\n\u7531\u4e8e\u662f\u50a8\u5b58\u5f02\u6216\u524d\u7f00\u548c\uff0c\u6240\u4ee5\u4e00\u4e2a\u70b9\u88ab\u6539\u53d8\uff0c\u4ed6\u7684\u5b50\u6811\u4e5f\u4f1a\u88ab\u6539\u53d8\u3002\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4e2a\u70b9\u7684\u6539\u53d8\uff0c\u90fd\u662f sum - \u76ee\u524d\u7684\u4e2a\u6570\uff0c\u6362\u53e5\u8bdd\u6765\u8bf4\u5c31\u662f\u7ffb\u8f6c\u5b50\u6811\u5185 0\uff0c1 \u7684\u4e2a\u6570\u3002\n\n## Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define cl(a, b) memset(a, b, sizeof(a))\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define N 30300\n\nstruct Edge\n{\n    int val, v, next;\n} e[N << 1];\nint cnt = 1, head[N];\n\nil void edd(int u, int v, int val)\n{\n    e[cnt].val = val;\n    e[cnt].v = v;\n    e[cnt].next = head[u];\n    head[u] = cnt++;\n    return;\n}\n\nll W[N];\nint n, q;\n\nstruct Tree\n{\n    int l, r, f;\n    ll sum;\n};\n#define ls(x) (x << 1)\n#define rs(x) ((x << 1) | 1)\nstruct SeG\n{\n    Tree t[N << 2];\n    il void down(int x)\n    {\n        if (t[x].f == 0) return;\n        t[ls(x)].sum = t[ls(x)].r - t[ls(x)].l + 1 - t[ls(x)].sum;\n        t[rs(x)].sum = t[rs(x)].r - t[rs(x)].l + 1 - t[rs(x)].sum;\n\n        t[ls(x)].f ^= 1;\n        t[rs(x)].f ^= 1;\n\n        t[x].f = 0;\n        return;\n    }\n\n    il void pushup(int x)\n    {\n        t[x].sum = t[ls(x)].sum + t[rs(x)].sum;\n        return;\n    }\n\n    void build(int x, int l, int r, int tt)\n    {\n        t[x].l = l, t[x].r = r;\n        if (l == r)\n        {\n            t[x].sum = (W[l] >> tt) & 1;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(ls(x), l, mid, tt);\n        build(rs(x), mid + 1, r, tt);\n        pushup(x);\n        return;\n    }\n\n    void change(int x, int l, int r)\n    {\n        if (t[x].l > r || t[x].r < l) return;\n        if (t[x].l >= l && t[x].r <= r)\n        {\n            t[x].sum = t[x].r - t[x].l + 1 - t[x].sum;\n            t[x].f ^= 1;\n            return;\n        }\n        down(x);\n        change(ls(x), l, r), change(rs(x), l, r);\n        pushup(x);\n        return;\n    }\n\n    ll ask(int x, int l, int r)\n    {\n        if (t[x].l > r || t[x].r < l) return 0;\n        if (t[x].l >= l && t[x].r <= r) return t[x].sum;\n        down(x);\n        return ask(ls(x), l, r) + ask(rs(x), l, r);\n    }\n};\n\nstruct TLC\n{\n    int size[N], dep[N], fa[N], son[N], eg[N];\n    ll  val[N];\n    int top[N], id[N], rev[N], tot;\n\n    SeG tree[10];\n\n    void dfs1(int u, int f)\n    {\n        dep[u] = dep[f] + 1;\n        size[u] = 1;\n        fa[u] = f;\n        for (int i = head[u]; i; i = e[i].next)\n        {\n            int v = e[i].v;\n            if (f == v) continue;\n            eg[v] = e[i].val;\n            val[v] = val[u] ^ e[i].val;\n            dfs1(v, u);\n            size[u] += size[v];\n            if (size[v] > size[son[u]] || !son[u]) son[u] = v;\n        }\n    }\n\n    void dfs2(int u, int t)\n    {\n        top[u] = t;\n        id[u] = ++tot;\n        rev[tot] = u;\n        if (!son[u]) return;\n        dfs2(son[u], t);\n        for (int i = head[u]; i; i = e[i].next)\n        {\n            int v = e[i].v;\n            if (v == fa[u] || son[u] == v) continue;\n            dfs2(v, v);\n        }\n    }\n\n    void change(int u, int v, int w)\n    {\n        if (dep[u] < dep[v]) swap(u, v);\n        for (int i = 0; i <= 9; i++)\n        {\n            if (((eg[u] >> i) & 1) ^ ((w >> i) & 1)) tree[i].change(1, id[u], id[u] + size[u] - 1);\n        }\n        eg[u] = w;\n        return;\n    }\n\n    int LCA(int u, int v)\n    {\n        while (top[u] != top[v])\n        {\n            if (dep[top[u]] < dep[top[v]]) swap(u, v);\n            u = fa[top[u]];\n        }\n        return dep[u] < dep[v] ? u : v;\n    }\n\n    ll Pask(int u, int v, int tt)\n    {\n        if (dep[u] < dep[v]) swap(u, v);\n        int lca = LCA(u, v), gs = 0, tot = 0;\n        tot = dep[u] + dep[v] - 2 * dep[lca] + 1;\n        while (top[u] != top[v])\n        {\n            if (dep[top[u]] < dep[top[v]]) swap(u, v);\n            gs += tree[tt].ask(1, id[top[u]], id[u]);\n            u = fa[top[u]];\n        }\n        if (dep[u] > dep[v]) swap(u, v);\n        gs += tree[tt].ask(1, id[u], id[v]);\n        return gs * (tot - gs);\n    }\n\n    ll ask(int u, int v)\n    {\n        ll ans = 0;\n        for (int i = 0; i <= 9; i++)\n            ans += Pask(u, v, i) * (1 << i);\n        return ans;\n    }\n} a;\n\n#define in(x) x = read()\nil int read()\n{\n    int v = 1, x = 0;\n    char ch = getchar();\n    while (!isdigit(ch))\n    {\n        if (ch == '-') v = -1;\n        ch = getchar();\n    }\n    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n    return x * v;\n}\n\nint main()\n{\n    in(n), in(q);\n    for (int i = 1; i < n; i++)\n    {\n        int u, v, w;\n        in(u), in(v), in(w);\n        edd(u, v, w);\n        edd(v, u, w);\n    }\n    a.dfs1(1, 0);\n    a.dfs2(1, 1);\n    for (int i = 1; i <= n; i++) W[a.id[i]] = a.val[i];\n    for (int i = 0; i <= 9; i++) a.tree[i].build(1, 1, n, i);\n    for (int i = 0; i < q; i++)\n    {\n        int op;\n        in(op);\n        switch (op)\n        {\n        case 1:\n        {\n            int u, v;\n            in(u), in(v);\n            printf(\"%lld\\n\", a.ask(u, v));\n            break;\n        }\n        case 2:\n        {\n            int u, v, w;\n            in(u), in(v), in(w);\n            a.change(u, v, w);\n            break;\n        }\n        }\n    }\n}\n```\n",
        "postTime": 1650601411,
        "uid": 146852,
        "name": "RocksonLee",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    },
    {
        "content": "\u9898\u610f\uff1a\u7ed9\u4e00\u68f5\u5e26\u8fb9\u6743\u6811\uff0c\u6bcf\u6b21\u652f\u6301\u4fee\u6539\u8fb9\u6743\uff0c\u6216\u8005\u8be2\u95ee $x,y$ \u4e4b\u95f4\u6240\u6709\u5b50\u8def\u5f84\u7684\u5f02\u6216\u548c\u4e4b\u548c\u3002\n\n\u4f60\u53d1\u73b0\u8fd9\u662f\u5f02\u6216\uff0c\u4e8e\u662f\u4f7f\u7528\u5f02\u6216\u7684\u7279\u6027\uff0c\u628a\u5b83\u53d8\u6210\u4e24\u4e2a\u70b9\u4e4b\u95f4\u5f02\u6216\u3002\u7531\u4e8e\u8fd9\u662f\u4e00\u68f5\u6811\uff0c\u4f60\u4f7f\u7528\u4e86\u6811\u4e0a\u524d\u7f00\u5f02\u6216\u548c\uff0c\u4e8e\u662f $(1,x)\\ \\text{xor}\\ (1,y)\\rightarrow(x,y)$ \u3002\n\n\u7136\u540e\u4f60\u8003\u8651\u6bcf\u4e00\u4f4d\u88ab\u8ba1\u7b97\u4e86\u51e0\u6b21\uff0c\u5bf9\u4e8e\u7b2c $t$ \u4f4d\uff0c\u4f60\u628a $(1,k),k\\in \\text{path}(x,y)$ \u4e2d\u7b2c $t$ \u4f4d\u662f $1$ \u7684\u8bb0\u4f5c $sum_t$ \uff0c\u662f $0$ \u7684\u5c31\u80fd\u7b97\u51fa\u6765\uff0c\u7136\u540e\u8fdb\u884c\u7b80\u5355\u6570\u5b66\u8ba1\u7b97\uff0c\u5c31\u662f $1$ \u7684\u4e58\u4ee5 $0$ \u7684\u5c31\u884c\u4e86\u3002\u7b97\u51fa\u88ab\u8ba1\u7b97\u4e86\u51e0\u6b21\uff0c\u518d\u4e58\u4ee5\u8fd9\u4e00\u4f4d\u5bf9\u5e94\u7684\u6743\u503c $2^t$ \u76f8\u52a0\u5373\u53ef\u3002\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(10n\\log^2 n)$\n\n\u73b0\u5728\u662f $9:16$ \uff0c\u6211\u770b\u6211\u4ec0\u4e48\u65f6\u5019\u5199\u5b8c\u3002\n\n\u73b0\u5728\u662f $10:08$ \uff0c\u6211\u5199\u5b8c\u4e86\u3002\u3002\n\n```cpp\n#define maxn 100010\nint n,m,x,y,z,op;\nint head[maxn],Next[maxn<<1],ver[maxn<<1],tot=1;\nvoid add(int x,int y){\n\tver[++tot]=y;\n\tNext[tot]=head[x];\n\thead[x]=tot;\n}\nint dep[maxn],siz[maxn],son[maxn];\nint fa[maxn],dfn[maxn],top[maxn],cnt;\nvoid dfs1(int x){\n\tsiz[x]=1;\n\tfor(int i=head[x];i;i=Next[i]){\n\t\tint y=ver[i];\n\t\tif(dep[y])continue;\n\t\tdep[y]=dep[x]+1;\n\t\tfa[y]=x;\n\t\tdfs1(y);\n\t\tsiz[x]+=siz[y];\n\t\tif(siz[son[x]]<siz[y])son[x]=y;\n\t}\n}\nvoid dfs2(int x,int t){\n\ttop[x]=t;\n\tdfn[x]=++cnt;\n\tif(!son[x])return;\n\tdfs2(son[x],t);\n\tfor(int i=head[x];i;i=Next[i])\n\tif(ver[i]!=fa[x]&&ver[i]!=son[x])dfs2(ver[i],ver[i]);\n}\nstruct prpr{\n\tint l,r;\n\tint w[10],tag;\n}tree[maxn<<2];\nvoid pushup(int x){\n\tfor(int i=0;i<10;i++)tree[x].w[i]=tree[x<<1].w[i]+tree[x<<1|1].w[i];\n}\nvoid pushdown(int x){\n\tif(tree[x].tag){\n\t\ttree[x<<1].tag^=tree[x].tag,tree[x<<1|1].tag^=tree[x].tag;\n\t\tfor(int i=0;i<10;i++)if(tree[x].tag>>i&1)tree[x<<1].w[i]=tree[x<<1].r-tree[x<<1].l+1-tree[x<<1].w[i];\n\t\tfor(int i=0;i<10;i++)if(tree[x].tag>>i&1)tree[x<<1|1].w[i]=tree[x<<1|1].r-tree[x<<1|1].l+1-tree[x<<1|1].w[i];\n\t\ttree[x].tag=0;\n\t}\n}\nvoid build(int l,int r,int x=1){\n\ttree[x].l=l,tree[x].r=r;\n\tif(l==r)return;\n\tint mid=(l+r)>>1;\n\tbuild(l,mid,x<<1),build(mid+1,r,x<<1|1);\n}\nvoid change(int l,int r,int d,int x=1){\n\tif(tree[x].l>=l&&tree[x].r<=r){\n\t\tfor(int i=0;i<10;i++)\n\t\tif(d>>i&1)tree[x].w[i]=tree[x].r-tree[x].l+1-tree[x].w[i];\n\t\ttree[x].tag^=d;\n\t\treturn;\n\t}\n\tpushdown(x);\n\tint mid=(tree[x].l+tree[x].r)>>1;\n\tif(l<=mid)change(l,r,d,x<<1);\n\tif(r>mid)change(l,r,d,x<<1|1);\n\tpushup(x);\n}\nint G[10][2];\nlong long ans;\nvoid ask(int l,int r,int x=1){\n\tif(tree[x].l>=l&&tree[x].r<=r){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tG[i][0]+=tree[x].r-tree[x].l+1-tree[x].w[i];\n\t\t\tG[i][1]+=tree[x].w[i];\n\t\t}\n\t\treturn;\n\t}\n\tpushdown(x);\n\tint mid=(tree[x].l+tree[x].r)>>1;\n\tif(l<=mid)ask(l,r,x<<1);\n\tif(r>mid)ask(l,r,x<<1|1);\n}\nvoid O(int x,int y){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\task(dfn[top[x]],dfn[x]);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\task(dfn[x],dfn[y]);\n}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\ngp_hash_table<long long,int>M;\nsigned main(){\n#ifndef ONLINE_JUDGE\n\tfreopen(\"testdata.in\",\"r\",stdin);\n#endif\n\tcin>>n>>m;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>x>>y>>z;\n\t\tM[x*100000ll+y]=z;\n\t\tM[y*100000ll+x]=z;\n\t\tadd(x,y),add(y,x);\n\t}\n\tdep[1]=1;dfs1(1),dfs2(1,1);\n\tbuild(1,n);\n\tfor(int i=2;i<=tot;i+=2){\n\t\tx=ver[i],y=ver[i^1];\n\t\tif(dep[x]<dep[y])swap(x,y);\n\t\tchange(dfn[x],dfn[x]+siz[x]-1,M[x*100000ll+y]);\n\t}\n\twhile(m--){\n\t\tcin>>op>>x>>y;\n\t\tif(op==1){\n\t\t\tfor(int i=0;i<10;i++)G[i][0]=G[i][1]=0;\n\t\t\tans=0;\n\t\t\tO(x,y);\n\t\t\tfor(int i=0;i<10;i++)ans+=(long long)G[i][0]*G[i][1]*(1<<i);\n\t\t\tcout<<ans<<endl;\n\t\t}else{\n\t\t\tcin>>z;\n\t\t\tif(dep[x]<dep[y])swap(x,y);\n\t\t\tchange(dfn[x],dfn[x]+siz[x]-1,M[x*100000ll+y]);\n\t\t\tchange(dfn[x],dfn[x]+siz[x]-1,z);\n\t\t\tM[x*100000ll+y]=z;\n\t\t}\n\t}\n#ifndef ONLINE_JUDGE\n\tcerr<<endl<<(double)clock()/CLOCKS_PER_SEC;\n#endif\n}\n```\n\u8fd9\u4e2a\u4eba\u592a\u900a\u4e86\uff0c\u5c45\u7136 $\\text{ask}$ \u65f6\u5fd8\u4e86 $\\text{pushdown}$ \u3002\n\n\u8fd9\u662f\u5c1d\u8bd5\u5361\u5e38\u7248\u672c\uff0c\u4e00\u5f00\u59cb\u5199\u7684\u662f $\\text{map}$ \u5b58\u8fb9\uff0c\u73b0\u5728\u6539\u6210\u4e86\u5e73\u677f\u7535\u89c6\u52a0\u624b\u52a8 $\\text{Hash}$ \uff0c\u4ecd\u7136\u5361\u4e0d\u8fc7\u6700\u4f18\u89e3\uff0c\u592a\u900a\u4e86\uff0c\u592a\u900a\u4e86\u3002",
        "postTime": 1631323001,
        "uid": 100325,
        "name": "peterwuyihong",
        "ccfLevel": 7,
        "title": "P3401 \u6d1b\u8c37\u6811 \u8bb0\u5f55"
    },
    {
        "content": "\u6811\u4e0a $\\text{DS}$ \u95ee\u9898\uff0c\u4e00\u822c\u5148\u8003\u8651\u5e8f\u5217\u89e3\u6cd5\u3002\n\n- \u6ca1\u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u591a\u6b21\u8be2\u95ee\uff0c\u6811\u7684\u5f62\u6001\u4e3a\u94fe\u3002\u8003\u8651\u9884\u5904\u7406\u51fa $sum_i$\uff0c$a_{1\\sim i}$ \u7684\u5f02\u6216\u548c\u3002\u5219\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee $(1,L,R)$\uff0c\u6211\u4eec\u9700\u8981\u6c42\u51fa $\\sum\\limits_{i=1}^L\\sum\\limits_{j=i+1}^R sum_i\\oplus sum_j$\uff0c\u5373\u533a\u95f4 $[L,R]$ \u5185\u4e24\u4e24\u524d\u7f00\u5f02\u6216\u548c\u7684\u5f02\u6216\u503c\u4e4b\u548c\u3002\u6309\u4f4d\u6765\u8003\u8651\u8fd9\u4e00\u95ee\u9898\uff0c\u7b2c $i$ \u4f4d\u4e0a\u6709\u503c\uff0c\u4ec5\u5f53\u53c2\u4e0e\u5f02\u6216\u7684\u4e24\u4e2a\u503c $x,y$\uff0c\u5176\u4e2d\u4e00\u4e2a\u5728\u7b2c $i$ \u4f4d\u4e0a\u7684\u503c\u4e3a $1$\uff0c\u800c\u53e6\u4e00\u4e2a\u5728\u7b2c $i$ \u4f4d\u4e0a\u7684\u503c\u4e3a $0$\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5efa $\\log V$ \u68f5\u7ebf\u6bb5\u6811\uff0c\u7b2c $i$ \u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u7b2c $i$ \u4f4d\u4e3a $0/1$ \u7684\u6570\u91cf\uff0c\u8bbe\u533a\u95f4 $[L,R]$ \u7b2c $i$ \u4f4d\u4e3a $1$ \u7684\u6709 $cnt1[L,R,i]$ \u4e2a\u6570\uff0c\u7b2c $i$ \u4f4d\u4e3a $0$ \u7684\u6709 $cnt0[L,R,i]$ \u4e2a\u6570\uff0c\u5219\u7b2c $i$ \u4f4d\u5728\u533a\u95f4 $[L,R]$ \u4e2d\u4f1a\u88ab\u7d2f\u52a0 $cnt1[L,R,i]\\times cnt0[L,R,i]$ \u6b21\uff0c\u5bf9\u533a\u95f4\u8d21\u732e\u4e3a $cnt1[L,R,i]\\times cnt0[L,R,i]\\times 2^i$\u3002\u6309\u4f4d\u7d2f\u52a0\u8d21\u732e\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n\\log n\\log V)$\uff0c$V$ \u4e3a\u503c\u57df\u5927\u5c0f\u3002 \n- \u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u591a\u6b21\u8be2\u95ee\uff0c\u6811\u7684\u5f62\u6001\u4e3a\u94fe\u3002\u8003\u8651\u5f02\u6216\u8fd0\u7b97\u7684\u7279\u6b8a\u6027\uff0c\u4e00\u65e6\u4f4d\u7f6e $i$ \u4e0a\u7684\u6570 $a_i$ \u88ab\u4fee\u6539\u4e3a $x$\uff0c\u5219\u82e5\u7b2c $k$ \u4f4d\u4e0a $a_i$ \u4e0e $x$ \u4e0d\u540c\uff0c$i$ \u4f4d\u7f6e\u4e4b\u540e\u7684\u524d\u7f00\u5f02\u6216\u548c\u90fd\u4f1a\u5728\u7b2c $k$ \u4f4d\u4e0a\u53d6\u53cd\u3002\u5728\u7ebf\u6bb5\u6811\u4e0a\u6253\u6807\u8bb0\u7ef4\u62a4\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e0d\u53d8\u3002\n- \u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u591a\u6b21\u8be2\u95ee\uff0c\u6811\u7684\u5f62\u6001\u4e0d\u9650\u3002\u8003\u8651\u4fee\u6539\u64cd\u4f5c\u4e8b\u5b9e\u4e0a\u662f\u5b50\u6811\u4fee\u6539\uff0c\u800c\u8be2\u95ee\u64cd\u4f5c\u662f\u5bf9\u94fe\u4e0a\u6307\u5b9a\u4e8c\u8fdb\u5236\u4f4d\u7684 $0/1$ \u4e2a\u6570\u6c42\u548c\uff0c\u5957\u4e00\u4e2a\u6811\u94fe\u5256\u5206\u5c31\u53ef\u4ee5\u4e86\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u5347\u4e3a $O(n\\log^2 n\\log V)$\u3002\n\n```cpp\n#include<cstdio>\n#include<map>\n#include<functional>\n#define ls p<<1\n#define rs p<<1|1\ntypedef long long ll;\nint cnt=0,num=0;\nstd::map<std::pair<int,int>,int> mp;\nint h[30005],to[60005],ver[60005],w[60005]; \nint size[30005],dep[30005],fa[30005],son[30005],sum[30005];\nint seg[30005],rev[30005],top[30005];\nstruct Segment {\n\tSegment(int x=0,int y=0,int z=0) {cnt0=x;cnt1=y;tag=z;}\n\tint cnt0,cnt1,tag;\n}res[10];\ninline int read() {\n\tregister int x=0,f=1;register char s=getchar();\n\twhile(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}\n\treturn x*f;\n}\ninline void swap(int &x,int &y) {int tmp=y;y=x;x=tmp;}\ninline void add(int x,int y,int z) {\n\tto[++cnt]=y;\n\tver[cnt]=h[x];\n\tw[cnt]=z;\n\th[x]=cnt;\n}\ninline void dfs1(int x) {\n\tsize[x]=1; \n\tfor(register int i=h[x];i;i=ver[i]) {\n\t\tint y=to[i]; if(y==fa[x]) continue;\n\t\tfa[y]=x; dep[y]=dep[x]+1; sum[y]=sum[x]^w[i]; dfs1(y);\n\t\tsize[x]+=size[y]; if(size[y]>size[son[x]]) son[x]=y;\n\t}\n}\ninline void dfs2(int x,int t) {\n\tseg[x]=++num; rev[num]=x; top[x]=t;\n\tif(son[x]) dfs2(son[x],t);\n\tfor(register int i=h[x];i;i=ver[i]) {\n\t\tint y=to[i]; if(y==fa[x]||y==son[x]) continue;\n\t\tdfs2(y,y);\n\t}\n}\nstruct SegmentTree {\n\tSegment t[120005];\n//\tinline void pushup(int p) {t[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;}  \n\tinline void work(int p) {t[p].tag^=1; swap(t[p].cnt0,t[p].cnt1);}\n\tinline void spread(int p) {if(t[p].tag) work(ls),work(rs),t[p].tag=0;}\n\tinline void build(int p,int l,int r,int bit) {\n\t\tif(l==r) {\n\t\t\tt[p].cnt0=(!(sum[rev[l]]>>bit&1));\n\t\t\tt[p].cnt1=(sum[rev[l]]>>bit&1);\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(ls,l,mid,bit); build(rs,mid+1,r,bit);\n\t\tt[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;\n\t}\n\tinline void reverse(int p,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {work(p); return;}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(L<=mid) reverse(ls,l,mid,L,R);\n\t\tif(R>mid) reverse(rs,mid+1,r,L,R);\n\t\tt[p].cnt0=t[ls].cnt0+t[rs].cnt0; t[p].cnt1=t[ls].cnt1+t[rs].cnt1;\n\t}\n\tinline Segment ask(int p,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) return t[p];\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(L>mid) return ask(rs,mid+1,r,L,R);\n\t\tif(R<=mid) return ask(ls,l,mid,L,R);\n\t\tSegment res1=ask(ls,l,mid,L,mid),res2=ask(rs,mid+1,r,mid+1,R);\n\t\treturn Segment(res1.cnt0+res2.cnt0,res1.cnt1+res2.cnt1);\n\t}\n}SegTree[10];\ninline ll Qsum(int x,int y) {\n\tll ans=0;\n\twhile(top[x]!=top[y]) {//always jump with x\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);//dep[top[x]]>=dep[top[y]]\n\t\tfor(register int i=0;i<10;++i) {\n\t\t\tSegment tmp=SegTree[i].ask(1,1,num,seg[top[x]],seg[x]);\n\t\t\tres[i].cnt0+=tmp.cnt0; res[i].cnt1+=tmp.cnt1;\n\t\t}\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y]) swap(x,y);//dep[x]<=dep[y]\n\tfor(register int i=0;i<10;++i) {\n\t\tSegment tmp=SegTree[i].ask(1,1,num,seg[x],seg[y]);\n\t\tres[i].cnt0+=tmp.cnt0; res[i].cnt1+=tmp.cnt1;\n\t\tans+=res[i].cnt0*res[i].cnt1*(1ll<<i);\n\t\tres[i].cnt0=res[i].cnt1=0;\n\t}\n\treturn ans;\n}\nint main() {\n\tint n=read(),Q=read();\n\tfor(register int i=1;i<n;++i) {\n\t\tint x=read(),y=read(),w=read();\n\t\tmp[std::make_pair(x,y)]=mp[std::make_pair(y,x)]=w;\n\t\tadd(x,y,w); add(y,x,w);\n\t}\n\tdep[1]=1; dfs1(1); dfs2(1,1);\n\tfor(register int i=0;i<10;++i) SegTree[i].build(1,1,num,i);\n\twhile(Q--) {\n\t\tint op=read(),u=read(),v=read();\n\t\tif(op==1) {printf(\"%lld\\n\",Qsum(u,v));}\n\t\tif(op==2) {\n\t\t\tint V=read(); if(fa[u]!=v) swap(u,v);\n\t\t\tint preval=mp[std::make_pair(u,v)];\n\t\t\tfor(register int i=0;i<10;++i) {if((preval>>i&1)^(V>>i&1)) SegTree[i].reverse(1,1,num,seg[u],seg[u]+size[u]-1);}\n\t\t\tmp[std::make_pair(u,v)]=mp[std::make_pair(v,u)]=V;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1606196827,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3401 \u3010\u6d1b\u8c37\u6811\u3011"
    }
]