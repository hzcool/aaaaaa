[
    {
        "content": "[$\\Large\\color{#FFBBFF}\\textit{Tian-Xing's blog}$](https://Tian-Xing.github.io)\n\n------------\n\n# Description\n\n[\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P3714)\n\n------------\n\n# Solution\n\n\u8bbe\u70b9$i$\u5230\u6839\u7684\u7b2c\u4e00\u6761\u8fb9\u7684\u989c\u8272\u4e3a$col_i$\uff0c\u6839\u5230\u70b9$i$\u7684\u8def\u5f84\u4e0a\u7684\u989c\u8272\u548c\u662f$sum_i$\uff0c\u7ecf\u8fc7\u89c2\u5bdf\u53d1\u73b0$col_i$\u76f8\u540c\u7684\u4e0d\u5728\u540c\u4e00\u4e2a\u5b50\u6811\u91cc\u7684\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u7b80\u5355\u8def\u5f84\u62fc\u63a5\u540e\u7684\u7b54\u6848\u662f$sum_i + sum_j - w_{col_i}$\u3002\u8fd9\u662f\u56e0\u4e3a\u4e2d\u95f4\u7684\u4e00\u6bb5\u4f1a\u88ab\u91cd\u590d\u7b97\u4e24\u6b21\uff0c\u800c\u5982\u679c$col_i$\u548c$col_j$\u4e0d\u540c\uff0c\u7b54\u6848\u5c31\u662f$sum_i + sum_j$\u3002\n\n\u8fd9\u6837\u542f\u793a\u6211\u4eec\u5bf9\u4e8e$col_i$\u76f8\u540c\u7684\u70b9\u7684\u5b50\u6811\u548c\u4e0d\u540c\u7684\u70b9\u7684\u5b50\u6811\u5206\u522b\u7b97\u7b54\u6848\uff0c\u70b9$i$\u548c\u70b9$j$\u4e4b\u95f4\u7684\u7b80\u5355\u8def\u5f84\u957f\u5ea6\u5c31\u662f$dep_i + dep_j$\uff08\u5047\u8bbe\u6839\u7684$dep$\u662f$0$\uff09\u3002\n\n\u9996\u5148\u6839\u636e$col_i$\u6392\u5e8f\uff0c\u5c06$col_i$\u76f8\u540c\u7684\u653e\u5728\u4e00\u8d77\u5904\u7406\uff0c\u5bf9\u4e8e\u76f8\u540c\u7684$col_i$\u5c31\u662f\u627e$dep$\u6ee1\u8db3\u6761\u4ef6\u4e14$sum$\u6700\u5927\u7684\u70b9\u3002\u5904\u7406\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u65f6\uff0c\u53ef\u4ee5\u5bf9\u5b50\u6811\u4e2d\u7684\u6bcf\u4e2a\u70b9\u6309\u7167\u6df1\u5ea6\u4ece\u5c0f\u5230\u5927\u8fdb\u884c\u6392\u5e8f\uff0c\u8fd9\u6837\u5bf9\u5e94\u7684\u6ee1\u8db3\u6761\u4ef6\u7684\u70b9\u7684\u6df1\u5ea6\u5c31\u662f\u9012\u51cf\u7684\u3002\u53d1\u73b0\u8fd9\u65f6\u5bf9\u5e94\u7684\u70b9\u7684\u9009\u62e9\u662f\u6ee1\u8db3\u5355\u8c03\u6027\u7684\uff0c\u5c31\u53ef\u4ee5\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002\u5177\u4f53\u64cd\u4f5c\u662f\u5bf9\u4e8e\u4e4b\u524d$col_i$\u76f8\u540c\u4f46\u662f\u4e0d\u5728\u540c\u4e00\u4e2a\u5b50\u6811\u5185\u7684\u70b9\u5f00\u4e00\u4e2a\u6876\u8bb0\u5f55\u6df1\u5ea6\u4e3a$x$\u65f6\u7684\u6700\u5927$sum$\u503c\uff0c\u6bcf\u6b21\u5904\u7406\u4e00\u4e2a\u65b0\u7684\u5b50\u6811\u65f6\u5148\u628a\u5355\u8c03\u961f\u5217\u6e05\u7a7a\uff0c\u7136\u540e\u6309\u6df1\u5ea6\u4ece\u5927\u5230\u5c0f\u4f9d\u6b21\u52a0\u5165\u5355\u8c03\u961f\u5217\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5904\u7406$col_i$\u76f8\u540c\u7684\u5b50\u6811\u7684\u7b54\u6848\uff0c\u5904\u7406\u5b8c\u4e4b\u540e\u5c06\u8fd9\u4e2a\u5b50\u6811\u7684\u7b54\u6848\u52a0\u5165\u6876\u91cc\u3002\n\n\u5bf9\u4e8e\u4e0d\u540c\u7684\u5b50\u6811\uff0c\u6709\u7c7b\u4f3c\u7684\u6c42\u6cd5\u3002\u5982\u679c\u76f4\u63a5\u6309\u7167$dep$\u6392\u5e8f\u6709\u70b9\u6162\uff0c\u76f4\u63a5\u7528$bfs$\u5c31\u53ef\u4ee5\u4f18\u5316\u6389\u8fd9\u90e8\u5206\u590d\u6742\u5ea6\u3002\n\n\u6bcf\u6b21\u6309\u7167\u6df1\u5ea6\u5c06\u70b9\u52a0\u5165\u5355\u8c03\u961f\u5217\u7684\u590d\u6742\u5ea6\u662f\u4e4b\u524d\u7684\u6700\u5927\u6df1\u5ea6\uff0c\u5982\u679c\u7b2c\u4e00\u4e2a\u5904\u7406\u7684\u5c31\u662f\u6df1\u5ea6\u6700\u5927\u7684\u5b50\u6811\uff0c\u590d\u6742\u5ea6\u5c31\u4f1a\u7206\u70b8\uff0c\u6240\u4ee5\u8981\u6309\u7167\u5b50\u6811\u4e2d\u6700\u5927\u6df1\u5ea6\u8fdb\u884c\u6392\u5e8f\u3002\u5bf9\u4e8e\u4e0d\u540c$col_i$\u7684\u5b50\u6811\u96c6\u5408\uff0c\u4e5f\u8981\u6309\u7167\u5176\u4e2d\u51fa\u73b0\u7684\u6700\u5927\u6df1\u5ea6\u6392\u5e8f\u3002\n\n\u7531\u4e8e\u6839\u8282\u70b9\u7684\u6df1\u5ea6\u4e3a$0$\uff0c\u6240\u4ee5\u5982\u679c\u5728$col_i$\u76f8\u540c\u7684\u5b50\u6811\u4e2d\u5904\u7406\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\uff0c\u4f1a\u591a\u51cf\u53bb$w_{col_i}$\uff0c\u4e8e\u662f\u5728\u5bf9\u4e8e$col_i$\u4e0d\u540c\u7684\u65f6\u5019\u7b97\u7b54\u6848\u7684\u65f6\u5019\u7b97\u4e0a\u5373\u53ef\u3002\n\n\u63a5\u4e0b\u6765\u8bc1\u660e\u4e00\u4e0b\u6309\u7167\u6df1\u5ea6\u6392\u5e8f\u4e4b\u540e\u6bcf\u6b21\u52a0\u5165\u5355\u8c03\u961f\u5217\u7684\u590d\u6742\u5ea6\u3002\n\n\u5bf9\u4e8e$col_i$\u76f8\u540c\u7684\u5757\u5185\u6211\u4eec\u6bcf\u6b21\u52a0\u5165\u5355\u8c03\u961f\u5217\u65f6\u7684\u590d\u6742\u5ea6\u662f\u4e4b\u524d\u6240\u6709\u51fa\u73b0\u8fc7\u7684\u8282\u70b9\u7684\u6700\u6df1\u6df1\u5ea6\uff0c\u7531\u4e8e\u6211\u4eec\u6309\u7167\u6700\u6df1\u8282\u70b9\u7684\u6df1\u5ea6\u6392\u5e8f\uff0c\u6240\u4ee5\u6bcf\u6b21\u5904\u7406\u7684\u5b50\u6811\u5927\u5c0f\u4e00\u5b9a\u662f\u9012\u589e\u7684\u3002\u90a3\u4e48\u5982\u679c\u6df1\u5ea6\u589e\u52a0\u4e86$x$\uff0c\u5219\u5b50\u6811\u5927\u5c0f\u81f3\u5c11\u589e\u52a0\u4e86$x$\uff0c\u5982\u679c\u65b0\u7684\u5b50\u6811\u4e0d\u662f\u4e00\u6761\u94fe\uff0c\u90a3\u4e48\u589e\u52a0\u7684\u5b50\u6811\u5927\u5c0f\u8fd8\u4f1a\u66f4\u591a\uff0c\u663e\u7136\u662f\u4e00\u6761\u94fe\u7684\u65f6\u5019\u589e\u52a0\u7684\u8282\u70b9\u6570\u662f\u6700\u5c11\u7684\uff0c\u90a3\u4e48\u5982\u679c\u6bcf\u6b21\u5904\u7406\u7684\u5b50\u6811\u90fd\u662f\u4e00\u6761\u94fe\uff0c\u589e\u52a0\u7684\u6df1\u5ea6\u5c31\u662f\u8282\u70b9\u4e2a\u6570\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bcf\u6b21\u53ea\u4f1a\u4ea7\u751f$O($\u8282\u70b9\u4e2a\u6570$)$\u7684\u590d\u6742\u5ea6\uff0c\u800c\u6700\u540e\u4e00\u6b21\u6700\u6df1\u7684\u5c31\u4e0d\u9700\u8981\u52a0\u5165\u961f\u5217\u4e86\uff1b\u67e5\u8be2\u7684\u65f6\u5019\u540c\u7406\uff0c\u6700\u5c0f\u7684\u6df1\u5ea6\u5c31\u4e0d\u9700\u8981\u52a0\u5165\u961f\u5217\u4e86\u3002\u8fd9\u6837\u7684\u8bdd\u590d\u6742\u5ea6\u6700\u574f\u5c31\u662f$2 \\times \\sum dep - mindep + maxdep$\uff0c\u56e0\u4e3a$\\sum dep$\u662f\u5c0f\u4e8e\u7b49\u4e8e$n$\u7684\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u662f$O(n)$\u7ea7\u522b\u7684\u3002\n\n\u8fd9\u6837\u6bcf\u4e00\u4e2a$col_i$\u76f8\u540c\u7684\u5757\u4f1a\u4ea7\u751f\u6700\u591a$2 \\times siz$\u7684\u590d\u6742\u5ea6\uff0c$col_i$\u4e0d\u540c\u7684\u6700\u591a\u4f1a\u4ea7\u751f$2 \\times allsiz$\u7684\u590d\u6742\u5ea6\uff0c\u76f8\u52a0\u6700\u591a\u662f$4 \\times allsiz$\u7684\u590d\u6742\u5ea6\uff0c\u8fd8\u662f$O(n)$\u7ea7\u522b\u7684\u3002\n\n\u5bf9\u4e8e\u6392\u5e8f\uff0c\u6211\u4eec\u53d1\u73b0\u6bcf\u6761\u8fb9\u53ea\u4f1a\u88ab\u6392\u5e8f\u4e00\u6b21\uff0c\u8bbe\u6bcf\u6b21\u91cd\u5fc3\u76f8\u8fde\u7684\u53d8\u6570\u4e3a$s_i$\u90a3\u4e48\u603b\u590d\u6742\u5ea6\u662f$\\sum \\log_{s_i}$\uff0c\u8fd9\u662f\u5c0f\u4e8e\u70b9\u5206\u6cbb\u7684\u590d\u6742\u5ea6$\\log_n$\u7684\u3002\n\n\u6240\u4ee5\u603b\u590d\u6742\u5ea6\u662f\u70b9\u5206\u6cbb\u7684$n \\log_n$\u3002\n\n------------\n\n# Code\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200000;\nconst int INF = 214748364;\n\nint dep[N +50], col[N + 50], q[N + 50], ans1[N + 50], ans2[N + 50], coldep[N +50], siz[N + 50], had[N + 50], w[N + 50], vis[N + 50], sum[N + 50], tmp[N + 50], inq[N + 50], ans[N + 50], px[N + 50], pxnum;\n\nint num, n, m, maxx, root, all, maxx1, maxx2, L, R, answer = -INF, tmpans;\n\nstruct Node\n{\n\tint next, to, dis;\n} edge[N * 2 + 50];\n\nstruct Tmp\n{\n\tint id, val;\n};\n\nvoid Addedge(int u, int v, int w)\n{\n\tedge[++num] = (Node){had[u], v, w};\n\thad[u] = num;\n\treturn;\n}\n\nstruct Queue\n{\n\tint head, tail;\n\tTmp q[N + 50];\n\tvoid Clear() { head = 1; tail = 0;}\n\tint Empty() { return head > tail; }\n\tTmp Top() { return q[head]; }\n\tvoid Pop() { head++;}\n\tvoid Push(Tmp x)\n\t{\n\t\twhile (head <= tail && x.val >= q[tail].val) tail--;\n\t\tq[++tail] = x;\n\t}\n} q1;\n\nvoid Findroot(int x, int fa)\n{\n\tint maxson = 0;\n\tsiz[x] = 1;\n\tfor (int i = had[x]; i; i = edge[i].next)\n\t{\n\t\tint v = edge[i].to;\n\t\tif (v == fa || vis[v]) continue; \n\t\tFindroot(v, x);\n\t\tsiz[x] += siz[v];\n\t\tmaxson = max(maxson, siz[v]);\n\t}\n\tmaxson = max(maxson, all - siz[x]);\n\tif (maxson < maxx) root = x, maxx = maxson;\n\treturn;\n}\n\nvoid Getdep(int x, int len, int fa)\n{\n\tdep[x] = len;\n\tfor (int i = had[x]; i; i = edge[i].next)\n\t{\n\t\tint v = edge[i].to;\n\t\tif (v == fa || vis[v]) continue;\n\t\tGetdep(v, len + 1, x);\n\t\tdep[x] = max(dep[x], dep[v]);\n\t}\n\treturn;\n}\n\nint Cmp(int a, int b)\n{\n\treturn col[a] == col[b] ? dep[a] < dep[b] : coldep[col[a]] < coldep[col[b]];\n}\n\nvoid Bfs2(int x)\n{\n//\tcout << \"\u540c\u5757\u5185\" << endl;\n\tq1.Clear();\n\tint now = maxx2, head = 0, tail = 1;\n\tq[tail] = x; inq[x] = 1; dep[x] = 1;\n\twhile (head < tail)\n\t{\n\t\tint u = q[++head];\n\t\twhile (now > 0 && now + dep[u] >= L) q1.Push((Tmp){now, ans2[now]}), now--;\n\t\twhile (!q1.Empty() && dep[u] + q1.Top().id > R) q1.Pop(); \n//\t\tif (!q1.Empty()) cout << q1.Top().id << \" \" << u << \" \" << dep[u] << endl;\n\t\tif (!q1.Empty()) ans[u] = sum[u] + q1.Top().val - w[col[x]]; else ans[u] = -INF;\n\t\tanswer = max(answer, ans[u]);\n\t\tfor (int i = had[u]; i; i = edge[i].next)\n\t\t{\n\t\t\tint v = edge[i].to;\n\t\t\tif (inq[v] || vis[v]) continue;\n\t\t\tdep[v] = dep[u] + 1; inq[v] = 1; q[++tail] = v;\n\t\t\tcol[v] = edge[i].dis;\n\t\t\tsum[v] = sum[u] + (col[v] == col[u] ? 0 : w[edge[i].dis]);\n\t\t}\n\t}\n//\tfor (int i = 1; i <= tail; i++) cout << q[i] << \" \" << sum[q[i]] << \" \" << dep[q[i]] << endl;\n\tfor (int i = now + 1; i <= min(dep[q[tail]], R); i++) ans2[i] = -INF;\n\tmaxx2 = max(maxx2, min(dep[q[tail]], R));\n\tfor (int i = 1; i <= tail && dep[q[i]] <= R; i++) ans2[dep[q[i]]] = max(ans2[dep[q[i]]], sum[q[i]]);\n//\tcout << maxx2 << endl;\n//\tfor (int i = 1; i <= maxx2; i++) cout << ans2[i] << \" \";\n//\tcout << endl;\t\n\tfor (int i = 1; i <= tail; i++) inq[q[i]] = 0;\n\treturn;\n}\n\nvoid Bfs1(int tot)\n{\n\tif (!tot) return;\n//\tcout << tot << endl;\n////\tcout << \"\u4e0d\u540c\u5757\" << endl;\n\tq1.Clear();\n\tint now = maxx1;\n\tint head = 0, tail = 0;\n\tfor (int i = 1; i <= tot; i++) q[++tail] = tmp[i], dep[tmp[i]] = 1, inq[tmp[i]] = 1;\n\twhile (head < tail)\n\t{\n\t\tint u = q[++head];\n\t//\tcout << u << \" \" << dep[u] << endl;\n\t\twhile (now >= 0 && now + dep[u] >= L) q1.Push((Tmp){now, ans1[now]}), now--;\n\t\twhile (!q1.Empty() && q1.Top().id + dep[u] > R) q1.Pop();\n\t//\tif (!q1.Empty())cout << q1.Top().val << \" \" << u << \" \" << dep[u] << endl;\n\t\tif (!q1.Empty()) ans[u] = sum[u] + q1.Top().val; else ans[u] = -INF;\n\t\tanswer = max(answer, ans[u]);\n\t\tfor (int i = had[u]; i; i = edge[i].next)\n\t\t{\n\t\t\tint v = edge[i].to;\n\t\t\tif (vis[v] || inq[v]) continue;\n\t\t\tinq[v] = 1; dep[v] = dep[u] + 1; q[++tail] = v; \n\t\t\tcol[v] = edge[i].dis;\n\t\t\tsum[v] = sum[u] + (col[u] == col[v] ? 0 : w[edge[i].dis]);\n\t\t}\n\t}\n//\tfor (int i = 1; i <= tail; i++) cout << q[i] << \" \" << sum[q[i]] << \" \" << dep[q[i]] << endl;\n\tfor (int i = now + 1; i <= min(R, dep[q[tail]]); i++) ans1[i] = -INF;\n\tmaxx1 = max(maxx1, min(R, dep[q[tail]]));\n\tfor (int i = 1; i <= tail && dep[q[i]] <= R; i++) ans1[dep[q[i]]] = max(ans1[dep[q[i]]], sum[q[i]]);\n\tfor (int i = 1; i <= tail; i++) inq[q[i]] = 0; maxx2 = 0;\n\treturn;\n}\n\nvoid Solve(int x)\n{ \n//\tcout << \"\u91cd\u5fc3\uff1a\" << x << endl;\n\tvis[x] = 1;\n\tfor (int i = had[x]; i; i = edge[i].next) coldep[edge[i].dis] = 0, col[edge[i].to] = edge[i].dis;\n\tfor (int i = had[x]; i; i = edge[i].next)\n\t{\n\t\tint v = edge[i].to;\n\t\tif (vis[v]) continue;\n\t\tpx[++pxnum] = v;\n\t\tGetdep(v, 1, x);\n\t\tcoldep[edge[i].dis] = max(coldep[edge[i].dis], dep[v]); \n\t}\n\tsort(px + 1, px + pxnum + 1, Cmp);\n\tmaxx1 = 0; maxx2 = 0;\n\tint precol = 0, tot = 0; ans1[0] = 0;\n\tfor (int i = 1; i <= pxnum; i++)\n\t{\n\t\tint v = px[i];\n\t\tif (vis[v]) continue;\n\t\tif (col[v] != precol) precol = col[v], Bfs1(tot), tot = 0;\n\t\tsum[v] = w[col[v]];\n\t\tBfs2(v); tmp[++tot] = v;\n\t}\n\tBfs1(tot);\n\tpxnum = 0;\n\tfor (int i = had[x]; i; i = edge[i].next)\n\t{\n\t\tint v = edge[i].to;\n\t\tif (vis[v]) continue;\n\t\tall = siz[v]; maxx = INF; Findroot(v, x); Solve(root);\n\t}\n\treturn;\n}\n\nvoid Read(int &x)\n{\n\tx = 0; int p = 0; char st = getchar();\n\twhile (st < '0' || st > '9') p = (st == '-'), st = getchar();\n\twhile (st >= '0' && st <= '9') x = (x << 1) + (x << 3) + st - '0', st = getchar();\n\tx = p ? -x : x;\n\treturn;\n} \n\nint main()\n{\n\tRead(n); Read(m); Read(L); Read(R);\n\tfor (int i = 1; i <= m; i++) Read(w[i]);\n\tfor (int i = 1, u, v, w; i <= n - 1; i++)\n\t{\n\t\tRead(u); Read(v); Read(w);\n\t\tAddedge(u, v, w);\n\t\tAddedge(v, u, w);\n\t}\n\tall = n; maxx = INF; Findroot(1, 0); Solve(root);\n\tprintf(\"%d\", answer);\n\treturn 0;\n} \n\n```",
        "postTime": 1592401408,
        "uid": 73983,
        "name": "Infiltrator",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u542c\u8bf4\u8fd9\u79cd\u9898\u53eb\u5355\u8c03\u961f\u5217\u6309\u79e9\u5408\u5e76\uff1f\n\nzz\u7684\u6211\u4e0d\u4f1a\u5199bfs\u5f3a\u884cdfs\u4e00\u6ce2\u7ed3\u679c\u4ea7\u751f\u4e86\u4e00\u4e2a\u7528\u4e86\u5355\u8c03\u961f\u5217\u5374\u8fd8\u662f\u4e24\u4e2alog\u7684\\**\u505a\u6cd5\u2026\u2026\n\n__________________\n\n\n## \u672c\u9898\u9898\u89e3\n\n### \u524d\u7f6e\u77e5\u8bc6:\u70b9\u5206\u6cbb\n\n\u4e0d\u4f1a\u70b9\u5206\u6cbb\u6216\u8005\u4e0d\u77e5\u9053\u70b9\u5206\u6cbb\u662f\u5565\u7684\u5c31\u8fd8\u662f\u51fa\u95e8\u5de6\u8f6c\u6a21\u677f\u533a\u5427\n\n____________________\n\n\u7b80\u5355\u590d\u8ff0\u4e00\u4e0b\u9898\u76ee\u5185\u5bb9\n\n\u6c42\u6811\u4e0a\u957f\u5ea6\u5728l,r\u4e4b\u95f4\u5e76\u4e14\u6743\u503c\u6700\u5927\u7684\u8def\u5f84\uff0c\u8def\u5f84\u7684\u6743\u503c\u5b9a\u4e49\u4e3a\u6bcf\u4e00\u6bb5\u540c\u8272\u6bb5\u8d21\u732e\u4e00\u4e2a\u81ea\u5df1\u989c\u8272\u7684\u6743\u503c(\u8fb9\u4e0a\u6709\u989c\u8272)\n\n\u5982\u8fd9\u4e2a\u8def\u5f84\u957f\u6210\u8fd9\u6837\n\n\u7ea2\u7ea2\u9ed1\u7ea2\u7ea2 \n\n\u90a3\u4e48\u6743\u503c\u5c31\u662f2\u500d\u7ea2\u8272\u6743\u503c+1\u500d\u9ed1\u8272\u6743\u503c\n\n____________\n\n\u7136\u800c\u4e8b\u5b9e\u4e0a\u4e00\u770b\u957f\u5ea6\u5728l\u5230r\u8fd9\u4e2a\u8def\u5f84\u957f\u5ea6\u9650\u5236\u51e0\u4e4e\u5c31\u53ea\u6709\u70b9\u5206\u6cbb\u53ef\u4ee5\u505a\u8fd9\u9053\u9898\u4e86\n\n**\u6240\u4ee5\u5bf9\u6811T\u8fdb\u884c\u70b9\u5206\u6cbb\u8003\u8651\u8fc7\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3G\u7684\u6240\u6709\u8def\u5f84**\n\n\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u53ef\u4ee5\u5927\u529bdfs\u4e00\u6ce2G\u5230\u5f53\u524d\u8054\u901a\u5757\u4e2d\u6240\u6709\u70b9\u7684\u8def\u5f84\n\n\u7136\u540e\u5904\u7406\u51fa\u8fd9\u4e9b\u8def\u5f84\u7684\u6743\u503c\u6765\n\n\u73b0\u5728\u6211\u4eec\u552f\u4e00\u8981\u505a\u7684\u5c31\u662f\u201c\u62fc\u5408\u4e24\u6761\u8def\u5f84\u201d\n\n\u518d\u5177\u4f53\u70b9\u5c31\u662f\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8def\u5f84\u6c42\u51fa\u4e00\u6761\u6700\u4f18\u7684\u548c\u4ed6\u5339\u914d\u7684\u8def\u5f84\n\n\u7136\u540e\u4f60\u53d1\u73b0\u4e00\u4e2a\u5341\u5206\u9057\u61be\u7684\u4e8b\u5b9e\u662f\n\n**\u4e24\u6761\u8def\u5f84\u62fc\u8d77\u6765\u7684\u6743\u503c\u4e0d\u4e00\u5b9a\u7b49\u4e8e\u8fd9\u4e24\u6761\u8def\u5f84\u7684\u6743\u503c\u4e4b\u548c**\n\n\u7136\u540e\u4f60\u53c8\u53d1\u73b0\u4e00\u4e2a\u6709\u8da3\u7684\u4e8b\u5b9e\u662f\n\n**\u5982\u679c\u4e24\u6761\u8def\u5f84\u6700\u9876\u4e0a\u90a3\u6761\u8fb9(\u548cG\u76f8\u90bb\u7684\u90a3\u6761\u8fb9)\u989c\u8272\u4e0d\u540c\uff0c\u90a3\u4e48\u4e0a\u9762\u7684\u7ed3\u8bba\u8fd8\u662f\u5bf9\u7684\uff0c\u5982\u679c\u989c\u8272\u4e00\u6837\uff0c\u51cf\u53bb\u4e00\u6b21\u672c\u989c\u8272\u7684\u6743\u503c\u5c31\u884c\u4e86**\n\n\u53e6\u4e00\u4e2a\u4e8b\u5b9e\u662f\n\n**\u5982\u679c\u4e24\u6761\u8def\u5f84\u9876\u4e0a\u7684\u989c\u8272\u4e0d\u4e00\u6837\uff0c\u90a3\u4e48\u4e24\u4e2a\u8def\u5f84\u4e0d\u4f1a\u5728\u540c\u4e00\u4e2a\u5b50\u6811\u5f53\u4e2d**\n\n\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5148\u5c06\u5207\u6389\u4e2d\u5fc3\u4e4b\u540e\u5269\u4e0b\u7684\u6240\u6709\u8054\u901a\u5757\u6309\u7167\u4ed6\u4eec\u548cG\u8fde\u8fb9\u7684\u989c\u8272\u6392\u5e8f(\u8fd9\u91cc\u6392\u5e8f\u7684\u76ee\u7684\u662f\u5c06\u76f8\u540c\u989c\u8272\u7684\u8054\u901a\u5757\u65b9\u7a0b\u653e\u5230\u4e00\u4e2a\u533a\u95f4\u91cc,\u989c\u8272\u4e4b\u95f4\u7684\u987a\u5e8f\u5e76\u4e0d\u505a\u8981\u6c42)\n\n\u7136\u540e\u4f9d\u6b21dfs\u6bcf\u4e00\u7ec4\u989c\u8272\u76f8\u540c\u7684\u8054\u901a\u5757\n\n\u5bf9\u4e8e\u62ce\u51fa\u6765\u7684\u8fd9\u4e9b\u8def\u5f84\u5c06\u4ed6\u4eec\u6309\u7167\u8def\u5f84\u957f\u5ea6\u6392\u5e8f\n\n\u6b64\u65f6\u6211\u4eec\u5728\u8fd9\u4e2a\u5e8f\u5217\u4e0a\u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8def\u5f84\u6c42\u51fa\u4e00\u4e2a\u6700\u4f18\u7684\u548c\u5b83\u989c\u8272\u4e0d\u540c\u540c\u7684\u8def\u5f84\u548c\u5b83\u5339\u914d\u8d77\u6765\n\n\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\u5982\u679c\u8fd9\u4e2a\u8def\u5f84\u7684\u957f\u5ea6\u662f$len$\u90a3\u4e48\u5f85\u9009\u8def\u5f84\u957f\u5ea6\u7684\u53d6\u503c\u8303\u56f4\u5c31\u662f\n$[max(l-len,0),min(mx,r-len)]$\n\nmx\u7684\u610f\u4e49\u4e00\u4f1a\u518d\u8bb2(\u73b0\u5728\u8bf4\u7684\u8bdd\u5c31\u662f\u6240\u6709\u5f85\u9009\u8def\u5f84\u4e2d\u957f\u5ea6\u7684\u6700\u5927\u503c)\n\n\u7136\u540e\u7531\u4e8e\u6211\u4eec\u628a\u8def\u5f84\u6309\u7167len\u6392\u5e8f\u4e86\uff0c\u6240\u4ee5\u957f\u5ea6\u53d6\u503c\u8303\u56f4\u7684\u5de6\u7aef\u70b9\u548c\u53f3\u7aef\u70b9\u4e5f\u662f\u5355\u8c03\u79fb\u52a8\u7684\uff0c\u6b64\u65f6\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u5355\u8c03\u961f\u5217\u6c42\u51fa\u5f85\u5339\u914d\u8def\u5f84\u533a\u95f4\u7684\u6700\u5927\u6743\u503c\u4e86\u4e5f\u5c31\u8fbe\u5230\u4e86\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8def\u5f84\u6c42\u51fa\u6743\u503c\u6700\u5927\u7684\u5f02\u8272\u5339\u914d\u8def\u5f84\u7684\u76ee\u7684\u4e86\n\n\u5f53\u8fd9\u4e2a\u989c\u8272\u5168\u90e8\u8dd1\u5b8c\u5355\u8c03\u961f\u5217\u4e4b\u540e\u6211\u4eec\u5c06\u8fd9\u4e9b\u8def\u5f84\u5168\u90e8\u63d2\u5165\u5230\u6743\u503c\u6570\u7ec4\u5f53\u4e2d\uff0c\u540c\u4e8b\u66f4\u65b0\u4e00\u4e0bmx\u7684\u503c\uff0c\u7136\u540e\u63a5\u7740\u53bb\u505a\u4e0b\u4e00\u79cd\u989c\u8272\n\n\u8fd9\u6837\u7684\u8bdd\u5bf9\u4e8e\u4e00\u7ec4\u8def\u5f84$i,j$\u4f1a\u5728\u989c\u8272\u8f83\u5927\u7684\u90a3\u4e00\u5934\u88ab\u7edf\u8ba1\u4e00\u6b21\uff0c\u540c\u65f6\u4e5f\u89c4\u907f\u4e86\u540c\u4e00\u5b50\u8054\u901a\u5757\u4e2d\u7684\u8def\u5f84\u76f8\u4e92\u5339\u914d\u7684\u60c5\u51b5\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u8003\u8651\u5bf9\u6bcf\u4e00\u4e2a\u8def\u5f84\u6c42\u51fa\u6743\u503c\u6700\u5927\u7684\u540c\u8272\u5339\u914d\u8def\u5f84\uff0c\u5f53\u7136\u548c\u5f02\u8272\u8def\u5f84\u7684\u5957\u8def\u5dee\u4e0d\u591a\uff0c\u6211\u4eec\u5728\u6bcf\u4e00\u4e2a\u989c\u8272\u91cc\u9762\u6309\u7167\u6240\u5728\u5b50\u8054\u901a\u5757\u7684\u7f16\u53f7\u6392\u5e8f\uff0c\u7136\u540e\u4f9d\u7136\u4f7f\u7528\u5355\u8c03\u961f\u5217\u5bf9\u6bcf\u4e00\u4e2a\u8def\u5f84\u6c42\u51fa\u4e00\u4e2a\u548c\u4ed6\u5339\u914d\u7684\u6700\u4f18\u7684\u540c\u8272\u8def\u5f84\u4e4b\u540e\u7ed9\u7b54\u6848\u53bb\u53d6\u4e00\u4e2amax\n\n\u7136\u540e\u505a\u5b8c\u4e86\uff1f\n\n**\u4e0d\uff0c\u4f60\u7684\u7b97\u6cd5\u662f\u5047\u7684\u53ef\u4ee5\u53c9\u6210$O(n^2)$**\n\n\u4ed4\u7ec6\u56de\u60f3\uff0c\u5355\u8c03\u961f\u5217\u7684\u5747\u644a\u590d\u6742\u5ea6\u7684\u786e\u662f$O(1)$\u4f46\u662f\u6211\u4eec\u53ef\u80fd\u5ffd\u7565\u4e86\u4e00\u4e2a\u5341\u5206\u91cd\u8981\u7684\u4e8b\u5b9e\u662f\u5355\u8c03\u961f\u5217\u662f\u6709\u521d\u59cb\u5316\u590d\u6742\u5ea6\u7684\n\n\u56e0\u6b64\u6211\u4eec\u8ba4\u771f\u5206\u6790\u4e00\u6b21\u70b9\u5206\u6cbb\u7684\u590d\u6742\u5ea6\n\n\u5bf9\u4e8e\u6c42\u5f02\u8272\u8def\u5f84\u5339\u914d\u7684\u8fc7\u7a0b\u5176\u5b9e\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\n\n\u6211\u4eec\u5355\u8c03\u961f\u5217\u8fdb\u884c\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u662f$O(n)$\u7684\uff0c\u4f46\u662f\u6bcf\u6b21\u521d\u59cb\u5316\u7684\u590d\u6742\u5ea6\u662f$O(mx)$\u7684\uff0cmx\u4e3a\u5019\u9009\u8def\u5f84\u4e2d\u7684\u6700\u6df1\u503c\uff0c\u90a3\u4e48\u5047\u5982\u6211\u4eec\u6784\u9020\u4e00\u4e2a\u6811\u4f7f\u5f97\u4f60\u7b2c\u4e00\u6b21\u5c31\u649e\u4e0a\u4e86\u6240\u6709\u8def\u5f84\u4e2d\u6700\u6df1\u7684\u8def\u5f84\uff0c\u90a3\u4e48\u4f60\u6bcf\u4e00\u6b21\u70b9\u5206\u6cbb\u7684\u590d\u6742\u5ea6\u5c06\u4f1a\u662f$O(n^2)$\u7136\u540e\u4f60\u7684\u7a0b\u5e8f\u5c31\u88ab\u53c9\u6389\u4e86\n\n\u6b63\u786e\u7684\u505a\u6cd5\u662f\u6392\u5e8f\u65f6\u6bd4\u8f83\u989c\u8272\u7684\u65f6\u5019\uff0c\u6bd4\u8f83\u7684\u662f\u8fd9\u4e2a\u989c\u8272\u4e2d\u6700\u6df1\u7684\u8def\u5f84\u503c\uff0c\u5c3d\u91cf\u5c06\u6df1\u5ea6\u8f83\u6df1\u8def\u5f84\u653e\u5728\u540e\u8fb9\uff0c\u800c\u5728\u989c\u8272\u5185\u90e8\u6392\u5e8f\u7684\u65f6\u5019\uff0c\u6309\u7167\u5b50\u6811\u4e2d\u6700\u6df1\u7684\u8def\u5f84\u8fdb\u884c\u6392\u5e8f\uff0c\u4e5f\u662f\u5c3d\u91cf\u7684\u628a\u6df1\u7684\u8def\u5f84\u6240\u5728\u7684\u8054\u901a\u5757\u653e\u5728\u540e\u9762\n\n\u8fd9\u6837\u7684\u8bdd\u6bcf\u6b21\u521d\u59cb\u5316\u7684\u590d\u6742\u5ea6$O(mx)$\u662f\u548c\u8fd9\u4e2a\u5b50\u8054\u901a\u5757\u7684size\u540c\u9636\u7684(\u56e0\u4e3a\u5728\u6b64\u4e4b\u524d\u6ca1\u6709\u8def\u5f84\u6bd4\u8fd9\u4e2a\u8054\u901a\u5757\u4e2d\u7684\u6700\u6df1\u8def\u5f84\u7684\u6df1\u5ea6\u5927)\uff0c\u6240\u4ee5\u603b\u7684\u521d\u59cb\u5316\u590d\u6742\u5ea6\u8fc5\u901f\u964d\u4f4e\u81f3\u6574\u4e2a\u5f53\u524d\u5206\u6cbb\u7684\u8054\u901a\u5757\u7684\u70b9\u6570\n\n\u8fd9\u4e2a\u6280\u5de7\u4f3c\u4e4e\u88ab\u67d0\u4e9b\u4eba\u6210\u4e3a\u5355\u8c03\u961f\u5217\u6309\u79e9\u5408\u5e76\uff1f\n\n\u5982\u679c\u6211\u4eec\u4f7f\u7528\u57fa\u6570\u6392\u5e8f\u6216\u8005bfs\u6765\u7ed9\u8def\u5f84\u6309\u957f\u5ea6\u6392\u5e8f\u7684\u8bdd\uff0c\u6211\u4eec\u7684\u6bcf\u4e00\u8f6e\u5206\u6cbb\u7684\u590d\u6742\u5ea6\u5c31\u662f$O(dlogd+size)$d\u662f\u5206\u6cbb\u4e2d\u5fc3\u7684\u5ea6\u6570\uff0csize\u662f\u6240\u5206\u6cbb\u8054\u901a\u5757\u7684\u70b9\u6570\n\n\u603b\u590d\u6742\u5ea6\u662f\u53ef\u7231\u7684$O(nlogn)$\n\n\u5982\u679c\u4f60\u662f\u4e00\u4e2a\u50cf\u6211\u4e00\u6837\u7684zz\u4e0d\u4f1abfs\uff0c\u5f3a\u884csort\u4e00\u6ce2\u7ed9\u6240\u6709\u8def\u5f84\u6392\u5e8f\u7684\u8bdd\n\n\u590d\u6742\u5ea6\u5c31\u662fzz\u7684$O(nlog^2n)$\u4e86\n\n\u4e0a\u4ee3\u7801~\n\n```C\n// luogu-judger-enable-o2\n#include<cstdio>\n#include<algorithm>\nusing namespace std;const int N=2*1e5+10;typedef long long ll;\nint n;int m;int v[2*N];int x[2*N];int ct;int al[N];int cl[2*N];int L;int R;\nint cd[N];int ud[N];int dep[N];ll dis[N];int tp;ll w[N];ll res;\nstruct data//\u5bf9\u8def\u5f84\u6309\u7167\u5404\u79cd\u5173\u952e\u5b57\u53cd\u590d\u6392\u5e8f\n{\n    ll val;int dep;int col;int u;\n    inline friend bool operator <(data a,data b)\n    {return (a.col==b.col)?a.dep>b.dep:(cd[a.col]==cd[b.col])?a.col<b.col:cd[a.col]<cd[b.col];}\n}a[N];\ninline bool cmp1(const data& a,const data& b)\n{return (a.u==b.u)?a.dep>b.dep:((ud[a.u]==ud[b.u])?a.u<b.u:ud[a.u]<ud[b.u]);}\ninline void add(int u,int V,int c){v[++ct]=V;x[ct]=al[u];al[u]=ct;cl[ct]=c;}\nbool cut[N];bool book[N];int siz[N];ll dw[N];int q[N];int hd;int tl;\ninline int dfs1(int u)//siz\n{\n    book[u]=true;\n    for(int i=al[u];i;i=x[i])if(!book[v[i]]&&!cut[v[i]])siz[u]+=dfs1(v[i]);\n    book[u]=false;return siz[u];\n}\ninline int find(int u,const int& tot)//\u91cd\u5fc3\n{\n    book[u]=true;int ret=u;\n    for(int i=al[u];i;i=x[i])\n        if(!book[v[i]]&&!cut[v[i]]&&2*siz[v[i]]>=tot){ret=find(v[i],tot);break;}\n    book[u]=false;return ret;\n}\ninline void dfs3(int u,int Col,const int& t,const int& crl)//\u628a\u8def\u5f84\u62c9\u51fa\u6765\n{\n    book[u]=true;a[++tp]=(data){dis[u],dep[u],crl,t};\n    for(int i=al[u];i;i=x[i])\n        if(!book[v[i]]&&!cut[v[i]])\n        {\n            dep[v[i]]=dep[u]+1;dis[v[i]]=dis[u]+((Col==cl[i])?0:w[cl[i]]);\n            dfs3(v[i],cl[i],t,crl);\n        }book[u]=false;siz[u]=1;\n}\ninline void solve(int u)//\u5927\u529b\u70b9\u5206\u6cbb\n{\n    dfs1(u);int g=find(u,siz[u]);cut[g]=true;if(siz[u]==1)return;tp=0;\n    for(int i=al[g];i;i=x[i])\n        if(!cut[v[i]]){dep[v[i]]=1;dis[v[i]]=w[cl[i]];dfs3(v[i],cl[i],v[i],cl[i]);}\n    for(int i=1;i<=tp;++i)cd[a[i].col]=max(cd[a[i].col],a[i].dep),ud[a[i].u]=max(ud[a[i].u],a[i].dep);\n    for(int i=1;i<=tp;++i)if(L<=a[i].dep&&a[i].dep<=R)res=max(res,a[i].val);\n    sort(a+1,a+tp+1);\n    int lst=1;int mxd=0;hd=1;tl=0;int nr=0;a[0].col=a[1].col;\n   \tfor(int i=1;i<=tp;++i)//\u8dd1\u5355\u8c03\u961f\u5217\n    {\n        if(a[i].col!=a[i-1].col)\n        {\n            hd=1;tl=0;nr=0;\n            for(int j=lst;j<i;++j)dw[a[j].dep]=max(dw[a[j].dep],a[j].val),mxd=max(mxd,a[j].dep);lst=i;\n        }\n        int dr=min(mxd,max(R-a[i].dep,0));int dl=min(mxd,max(L-a[i].dep,0));if(dl>=dr){continue;}\n        for(int np=nr+1;np<=dr;++np)\n            {while(hd<=tl&&dw[q[tl]]<dw[np])--tl;q[++tl]=np;}nr=dr;\n        while(hd<=tl&&q[hd]<dl)++hd;if(hd<=tl)res=max(res,dw[q[hd]]+a[i].val);\n    }\n    for(int i=1;i<=tp;++i)dw[a[i].dep]=-0x7f7f7f7f;\n    lst=1;hd=1;tl=0;nr=0;mxd=0;int lst2=1;\n    for(int t=1;t<=tp+1;++t)\n        if(a[t].col!=a[t-1].col)\n        {\n            sort(a+lst,a+t,cmp1);\n            for(int i=lst;i<t;++i)\n            {\n                if(a[i].u!=a[i-1].u)\n                {\n                    hd=1;tl=0;nr=0;\n                    for(int j=lst;j<i;j++)dw[a[j].dep]=max(dw[a[j].dep],a[j].val),mxd=max(mxd,a[j].dep);lst2=i;\n                }\n                int dr=min(mxd,max(R-a[i].dep,0));int dl=min(mxd,max(L-a[i].dep,0));if(dl>=dr)continue;\n                for(int np=nr+1;np<=dr;++np)\n                    {while(hd<=tl&&dw[q[tl]]<dw[np])--tl;q[++tl]=np;}nr=dr;\n                while(hd<=tl&&q[hd]<dl)++hd;if(hd<=tl)res=max(res,dw[q[hd]]+a[i].val-w[a[i].col]);\n            }hd=1;tl=0;nr=0;mxd=0;\n            for(int i=lst;i<t;++i)dw[a[i].dep]=-0x7f7f7f7f;lst=t;\n        }\n    for(int i=1;i<=tp;++i)cd[a[i].col]=0,ud[a[i].u]=0;\n    for(int i=al[g];i;i=x[i])if(!cut[v[i]])solve(v[i]);\n}\nint main()\n{\n    scanf(\"%d%d%d%d\",&n,&m,&L,&R);res=-0x7f7f7f7f;\n    for(int i=1;i<=m;i++)scanf(\"%lld\",&w[i]);\n    for(int i=1;i<=n;i++)siz[i]=1;for(int i=0;i<=n;i++)dw[i]=-0x7f7f7f7f;\n    for(int i=1,u,v,w;i<n;i++){scanf(\"%d%d%d\",&u,&v,&w);add(u,v,w);add(v,u,w);}\n    solve(1);printf(\"%lld\",res);return 0;//\u62dc\u62dc\u7a0b\u5e8f~\n}\n```\n\n\n\n\n\n\n\n",
        "postTime": 1534031866,
        "uid": 56384,
        "name": "shadowice1984",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u70b9\u5206\u6cbb\n\t\t\t\n\u4ee5\u4e0b\u7684\u540c\u8272\u8054\u901a\u5757\u4ee5\u53ca\u5f02\u8272\u8054\u901a\u5757\u4e2d\u7684\u8272\u6307\u7684\u662f\u4e0e\u5206\u6cbb\u4e2d\u5fc3\u76f4\u63a5\u76f8\u8fde\u7684\u8fb9\u7684\u989c\u8272\n\t\t\t\n\u8003\u8651\u5bf9\u4e8e\u4e00\u4e2a\u5206\u6cbb\u4e2d\u5fc3\uff0c\u6bcf\u79cd\u989c\u8272\u5355\u72ec\u5904\u7406\uff0c\u4e5f\u5c31\u662f\u5bf9\u5206\u6cbb\u4e2d\u5fc3\u4e0b\u65b9\u7684\u6bcf\u9897\u5b50\u6811\uff0c\u4ee5\u5176\u540c\u989c\u8272\u8054\u901a\u5757\u6700\u5927\u6df1\u5ea6\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u989c\u8272\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\n\u6392\u5e8f\uff0c\u7136\u540e\u518d\u5728\u540c\u8272\u7684\u8054\u901a\u5757\u4e2d\uff0c\u4ee5\u6df1\u5ea6\u6392\u5e8f\u5f97\u5230\u4e00\u4e2a\u904d\u5386\u5e8f\u5217\n\t\t\t\n\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4\u540c\u8272\u8054\u901a\u5757\u4ee5\u53ca\u5f02\u8272\u8054\u901a\u5757\u7684\u4ea7\u751f\u7684\u8d21\u732e\u4e86\n\t\t\t\n\u4f7f\u7528\u5355\u8c03\u961f\u5217\n\t\t\t\n\u5f02\u8272\u8054\u901a\u5757\u4e2d\u9ed8\u8ba4\u5b58\u5728\u4e00\u6761\u6743\u503c\u548c\u957f\u5ea6\u90fd\u4e3a0\u7684\u8def\u5f84\uff0c\u800c\u540c\u8272\u8054\u901a\u5757\u4e0d\u884c\n\t\t\t\n\u5bf9\u540c\u8272\u8054\u901a\u5757\u548c\u5f02\u8272\u8054\u901a\u5757\u5404\u5f00\u4e00\u4e2a\u5355\u8c03\u961f\u5217\uff0c\u5355\u8c03\u961f\u5217\n\u4e2d\u5b58\u4e0b\u5f53\u4e00\u6761\u8def\u5f84 $l$ \u957f\u5ea6\u4e3a $x$ \u65f6\u6743\u503c\u6700\u5927\u7684\u53ef\u4ee5\u4e0e $l$ \u7ec4\u6210\u4e00\u6761\u8def\u5f84\u7684\u8def\u5f84\u6743\u503c\u6700\u5927\u503c\uff0c\u6bcf\u6b21\u5728\u5728DFS\u7684\u65f6\u5019\u66f4\u65b0\u7b54\u6848\n\n\u5f53\u904d\u5386\u5b8c\u4e00\u9897\u5b50\u6811\u65f6\uff0c\u5982\u679c\u4e0b\u4e00\u6b21\u904d\u5386\u7684\u5b50\u6811\u989c\u8272\u4e0e\u8fd9\u9897\u5b50\u6811\u76f8\u540c\uff0c\u90a3\u4e48\u66f4\u65b0\u540c\u8272\u8054\u901a\u5757\u7684\u6743\u503c\uff0c\u5426\u5219\u66f4\u65b0\u5f02\u8272\u8054\u901a\u5757\u7684\u6743\u503c\u5e76\n\u6e05\u7a7a\u540c\u8272\u8054\u901a\u5757\u7684\u6743\u503c\n\t\t\t\n\u6ce8\u610f\u540c\u8272\u8054\u901a\u5757\u7684\u5355\u8c03\u961f\u5217\u91cc\u9762\u7684\u6743\u503c\u8981\u51cf\u53bb\u5206\u6cbb\u4e2d\u5fc3\u76f4\u63a5\u76f8\u8fde\u7684\u8fb9\u7684\u989c\u8272\u7684\u6743\u503c\n\t\t\t\n\u65f6\u95f4\u590d\u6742\u5ea6:$O(N\\log N)$\n\n```cpp\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\n#define DEBUG(args...) fprintf(stderr, args)\n\ntypedef long long LL;\n\n#define FOR(i, l, r) for(int i = (l), i##_end = (r); i <= i##_end; ++i)\n#define REP(i, l, r) for(int i = (l), i##_end = (r); i <  i##_end; ++i)\n#define DFR(i, l, r) for(int i = (l), i##_end = (r); i >= i##_end; --i)\n#define DRP(i, l, r) for(int i = (l), i##_end = (r); i >  i##_end; --i)\n\ntemplate<class T>T Min(const T &a, const T &b) {return a < b ? a : b;}\ntemplate<class T>T Max(const T &a, const T &b) {return a > b ? a : b;}\ntemplate<class T>bool Chkmin(T &a, const T &b) {return a > b ? a = b, 1 : 0;}\ntemplate<class T>bool Chkmax(T &a, const T &b) {return a < b ? a = b, 1 : 0;}\n\nclass fast_input {\nprivate:\n    static const int SIZE = 1 << 15 | 1;\n    char buf[SIZE], *front, *back;\n\n    void Next(char &c) {\n        if(front == back) back = (front = buf) + fread(buf, 1, SIZE, stdin);\n        c = front == back ? (char)EOF : *front++;\n    }\n\npublic :\n    template<class T>void operator () (T &x) {\n        char c, f = 1;\n        for(Next(c); !isdigit(c); Next(c)) if(c == '-') f = -1;\n        for(x = 0; isdigit(c); Next(c)) x = x * 10 + c - '0';\n        x *= f;\n    }\n    void operator () (char &c, char l = 'a', char r = 'z') {\n        for(Next(c); c > r || c < l; Next(c)) ;\n    }\n}input;\n\nstruct triple {\n    int c, d, x, md;\n    explicit triple(int c = 0, int d = 0, int x = 0) : c(c), d(d), x(x) {}\n    bool operator < (const triple &o) const { \n        return c != o.c ? c < o.c : d < o.d;\n    }\n    bool operator > (const triple &o) const {\n        return md != o.md ? md < o.md : c != o.c ? c < o.c : d < o.d;\n    }\n};\n\nconst int SN = 200000 + 47;\nconst int SE = 400000 + 47;\nconst int INF = 2000100000;\n\nint head[SN], nxt[SE], to[SE], col[SE];\nint val[SN], n, left, right;\nint size[SN], max_deep[SN];\nint vis[SN];\ntriple a[SN];\nint ans;\n\nvoid Add(int, int, int);\nvoid GetSize(int, int);\nint GetDeep(int, int, int);\n\nint __size, __root, __max_size;\nvoid GetRoot(int, int);\n\nvoid Solve(int);\nvoid DFS(int, int, int, int, int);\n\nint main() {\n\n#ifdef Cai\n    freopen(\"s.in\", \"r\", stdin);\n#endif\n\n    int x, y, z, m;\n\n    input(n), input(m), input(left), input(right);\n    FOR(i, 1, m) input(val[i]);\n    FOR(i, 2, n) input(x), input(y), input(z), Add(x, y, z);\n\n    GetSize(1, -1);\n    __size = n, __max_size = INF, GetRoot(1, -1);\n    ans = -INF, Solve(__root);\n\n    if(ans < -2000000000) return printf(\"%d\\n\", -INF), 0;\n    \n    printf(\"%d\\n\", ans);\n\n    return 0;\n\n}\n\nvoid Add(int x, int y, int z) {\n    static int _ = 0;\n    nxt[++_] = head[x], head[x] = _, to[_] = y, col[_] = z;\n    nxt[++_] = head[y], head[y] = _, to[_] = x, col[_] = z;\n}\n\nvoid GetSize(int x, int y) {\n    size[x] = 1;\n    for(int i = head[x]; i; i = nxt[i])\n        if(to[i] != y && !vis[to[i]]) {\n            GetSize(to[i], x);\n            size[x] += size[to[i]];\n        }\n}\n\nint GetDeep(int x, int y, int d) {\n    int max_d = d;\n    for(int i = head[x]; i; i = nxt[i])\n        if(to[i] != y && !vis[to[i]]) \n            Chkmax(max_d, GetDeep(to[i], x, d + 1));\n    return max_d;\n}\n\nvoid GetRoot(int x, int y) {\n    int max_size = __size - size[x];\n    for(int i = head[x]; i; i = nxt[i])\n        if(to[i] != y && !vis[to[i]]) {\n            GetRoot(to[i], x);\n            Chkmax(max_size, size[to[i]]);\n        }\n    if(Chkmin(__max_size, max_size)) __root = x;\n}\n\n// q0 for all\n// q1 for same col\nint q0[SN], f0, b0, t0[SN], v0[SN];\nint q1[SN], f1, b1, t1[SN], v1[SN];\nint c[SN], cc, b[SN], cb, d[SN], cd;\n\nvoid Solve(int x) {\n    int cnt = 0;\n    GetSize(x, -1), vis[x] = 1;\n    for(int i = head[x]; i; i = nxt[i])\n        if(!vis[to[i]]) \n            a[++cnt] = triple(col[i], GetDeep(to[i], x, 1), to[i]);\n    std::sort(a + 1, a + cnt + 1);\n    DFR(i, cnt, 1)\n        if(a[i].c == a[i + 1].c) a[i].md = a[i + 1].md;\n        else a[i].md = a[i].d;\n    std::sort(a + 1, a + cnt + 1, std::greater<triple>());\n    int root_all = 0, root_col = 0;\n    FOR(i, 1, a[1].md) q0[i] = q1[i] = c[i] = d[i] = v0[i] = v1[i] = -INF;\n    FOR(i, left, Min(a[1].md, right)) v1[i] = 0;\n    FOR(i, 1, cnt) {\n        cb = 0, DFS(a[i].x, x, 1, val[a[i].c], a[i].c); // ans : updated\n        //if(ans == -4) {DEBUG(\"%d %d\\n\", x, i); throw ;}\n        if(a[i].c == a[i + 1].c) {\n            cc = cb;\n            FOR(j, 1, cb) Chkmax(c[j], b[j]);\n            f0 = 0, b0 = -1, c[0] = val[a[i].c];\n            DFR(j, Min(cc, right - 1), left - 1) {\n                while(f0 <= b0 && q0[b0] <= c[j]) --b0;\n                q0[++b0] = c[j], t0[b0] = j;\n            }\n            FOR(j, 1, a[i + 1].d) {\n                if(f0 > b0) v0[j] = -INF;\n                else v0[j] = q0[f0] - val[a[i].c]; // val[a[i].c] will be calc twice\n                while(f0 <= b0 && t0[f0] + j + 1 > right) ++f0;\n                if(left - j - 1 >= 0 && left - j - 1 <= cc) {\n                    while(f0 <= b0 && q0[b0] <= c[left - j - 1]) --b0;\n                    q0[++b0] = c[left - j - 1], t0[b0] = left - j - 1;\n                }\n            }\n        }\n        else {\n            cd = cb;\n            FOR(j, 1, cd) Chkmax(d[j], Max(b[j], c[j]));\n            f1 = 0, b1 = -1, d[0] = 0;\n            DFR(j, Min(cd, right - 1), left - 1) {\n                while(f1 <= b1 && q1[b1] <= d[j]) --b1;\n                q1[++b1] = d[j], t1[b1] = j;\n            }\n            FOR(j, 1, a[i + 1].md) {\n                if(f1 > b1) v1[j] = -INF;\n                else v1[j] = q1[f1];\n                while(f1 <= b1 && t1[f1] + j + 1 > right) ++f1;\n                if(left - j - 1 >= 0 && left - j - 1 <= cd) {\n                    while(f1 <= b1 && q1[b1] <= d[left - j - 1]) --b1;\n                    q1[++b1] = d[left - j - 1], t1[b1] = left - j - 1;\n                }\n            }\n            cc = 0;\n            FOR(j, 1, a[i + 1].md) c[j] = v0[j] = -INF;\n            FOR(j, a[i].md + 1, a[i + 1].md) d[j] = -INF;\n        }\n    }\n    for(int i = head[x]; i; i = nxt[i])\n        if(!vis[to[i]]) {\n            __size = size[to[i]], __max_size = INF, GetRoot(to[i], x);\n            Solve(__root);\n        }\n}\n\nvoid DFS(int x, int y, int deep, int v, int lc) {\n    if(deep <= cb) Chkmax(b[deep], v);\n    else b[cb = deep] = v;\n    Chkmax(ans, v + Max(v0[deep], v1[deep]));\n    for(int i = head[x]; i; i = nxt[i])\n        if(to[i] != y && !vis[to[i]])\n            if(col[i] == lc)\n                DFS(to[i], x, deep + 1, v, lc);\n            else\n                DFS(to[i], x, deep + 1, v + val[col[i]], col[i]);\n}\n\n/*\ng++ -o s s.cpp -O2; for((i = 1; i <= 10; ++i)) do cp journey$i.in s.in; ./s > s.out; diff journey$i.out s.out -w > s.res; echo $i : $?; done\n*/\n\n```",
        "postTime": 1522416203,
        "uid": 21784,
        "name": "Caii",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "[\u5b89\u5229blog](https://ctz45562.github.io/2019/08/15/%E6%B4%9B%E8%B0%B7-P3714-BJOI2017-%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98/)\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problem/P3714)\n\n---\n\n\u67d0\u4e2a$zz$\u7684\u5047\u505a\u6cd5\uff1a\n\n\u5148\u8003\u8651\u989c\u8272\u4e0d\u5728\u8fb9\u4e0a\u800c\u662f\u5728\u70b9\u4e0a\u7684\u505a\u6cd5\u3002\n\n$dis(i)$\u8868\u793a\u6839\u8282\u70b9\u5230$i$\u7684\u6743\u503c\uff0c$ma(i)$\u8868\u793a\u6df1\u5ea6\u4e3a$i$\u7684\u70b9\u4e2d\u6700\u5927\u7684$dis$\u3002\n\n\u5728\u5408\u5e76\u8def\u5f84\u65f6\uff0c\u6839\u8282\u70b9\u4e00\u5b9a\u88ab\u7ecf\u8fc7\u3002\u8fd9\u6837\u5728\u8ba1\u7b97$dis$\u65f6\uff0c\u4e0d\u7b97\u4e0a\u6839\u8282\u70b9\u7684\u6743\u503c\uff0c\u8ba1\u7b97\u65f6\u76f4\u63a5\u53d6\u6070\u5f53\u7684$ma$\u52a0\u4e0a\u5373\u53ef\uff0c\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002\n\n\u7528$dis$\u66f4\u65b0$ma$\u65f6\uff0c\u518d\u628a\u6839\u8282\u70b9\u7684\u6743\u503c\u52a0\u56de\u6765\u3002\n\n\u8fd9\u662f\u989c\u8272\u5728\u70b9\u4e0a\u7684\u60c5\u51b5\uff0c\u8f6c\u5230\u989c\u8272\u5728\u8fb9\u4e0a\u8003\u8651\u62c6\u8fb9\u4e3a\u70b9\uff0c\u62c6\u51fa\u6765\u7684\u70b9\u989c\u8272\u4e3a\u539f\u8fb9\u7684\u989c\u8272\u3002\n\n> \u90a3\u539f\u6709\u7684\u70b9\u7684\u989c\u8272\u5462\uff1f\n\n\u5b83\u7236\u8282\u70b9\u6307\u5411\u5b83\u7684\u8fb9\u7684\u989c\u8272\u3002\u3002\u3002\n\n> \u6839\u8282\u70b9\u5462\uff1f\n\n\u9009\u4e00\u6761\u51fa\u8fb9\u4e3a\u5176\u989c\u8272\u3002\u3002\u3002\n\n> \u6839\u8282\u70b9\u4e0d\u6b62\u4e00\u6761\u51fa\u8fb9\u5462\uff1f\n\n\u9009\u4e00\u4e2a\u5ea6\u6570\u4e3a$1$\u7684\u70b9\u4e3a\u6839\u8282\u70b9\u3002\u3002\u3002\n\n\u5199\u51fa\u6765\u540e\u6210\u529f\u559c\u63d0$20$\u5206\uff0c\u53d1\u73b0\u8fd9\u4e2a\u505a\u6cd5\u5b8c\u5168\u662f\u5047\u7684\u3002\u3002\u3002\n\n---\n\n\u6b63\u89e3\uff1a\n\n\u8bb0$col(i)$\u4e3a\u6839\u8282\u70b9\u5230$i$\u7684\u8def\u5f84\u7b2c\u4e00\u6761\u8fb9\u7684\u989c\u8272\u3002\n\n\u663e\u7136\u5408\u5e76\u4e24\u6761\u8def\u5f84$x,y$\u65f6\uff0c\u82e5$col(x)=col(y)$\u9700\u8981\u51cf\u53bb$col(x)$\u7684\u6743\u503c\u3002\n\n\u628a$col$\u76f8\u540c\u7684\u653e\u5728\u4e00\u8d77\u8003\u8651\uff0c\u5bf9\u5b83\u4eec\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\uff0c\u7edf\u8ba1\u7b54\u6848\u65f6\u51cf\u53bb\u8be5\u989c\u8272\u7684\u6743\u503c\u3002\n\n\u5bf9$col$\u4e0d\u540c\u7684\u8fd8\u662f\u5355\u8c03\u961f\u5217\uff0c\u76f4\u63a5\u52a0\u8d77\u6765\u7edf\u8ba1\u3002\n\n\u4e3a\u4fdd\u8bc1\u590d\u6742\u5ea6\uff0c\u4e0d\u540c$col$\u4e4b\u95f4\u6309\u5305\u542b\u8def\u5f84\u4e2d\u6700\u5927\u6df1\u5ea6\u6392\u5e8f\uff0c\u4f18\u5148\u5904\u7406\u6df1\u5ea6\u5c0f\u7684\u3002\n\n\u540c\u6837\u5730\uff0c\u76f8\u540c$col$\u5185\u90e8\u4e5f\u4f18\u5148\u5904\u7406\u6df1\u5ea6\u5c0f\u7684\u3002\n\n\u7edf\u8ba1\u65f6\u8fd8\u8981\u628a\u6df1\u5ea6\u76f8\u540c\u7684\u653e\u4e00\u5757\u5904\u7406\uff0c\u7528$bfs$\u6d88\u53bb\u6392\u5e8f\u7684$\\log$\u3002\n\n\u8fd9\u6837\u6bcf\u6b21\u5206\u6cbb\u7684\u590d\u6742\u5ea6\u4e3a\u5f53\u524d\u6811\u5927\u5c0f\u3002\n\n\u603b\u590d\u6742\u5ea6$O(n\\log n)$\u3002\n\n~~\u8bdd\u8bf4\u6211\u5c31\u5bf9\u4e2a\u62cdhack\u6389\u4e86\u6240\u6709\u6709\u4ee3\u7801\u7684\u9898\u89e3\u3002\u3002\u3002~~\n\n\u4ee3\u7801\uff1a\n\n``` cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n\n#define maxn 200005\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nstruct Monoqueue{\n\tint l1[maxn],l2[maxn],head,tail;\n\tvoid clear(){head=1,tail=0;}\n\tvoid check(int x){\n\t\twhile(head<=tail&&l1[head]>x)++head;\n\t}\n\tvoid push(int pos,int d){\n\t\tif(d==-inf)return;\n\t\twhile(head<=tail&&l2[tail]<d)--tail;\n\t\tl1[++tail]=pos,l2[tail]=d;\n\t}\n\tint front(){\n\t\tif(head<=tail)return l2[head];\n\t\treturn -inf;\n\t}\n}q1,q2;\nstruct edge{\n\tint pre,to,l;\n}e[maxn<<1];\nint md[maxn],mmd[maxn],siz[maxn],v[maxn],c[maxn],h[maxn],col[maxn],L,R,mx,root,all,num,head,tail,ans;\nint f[maxn],line[maxn],deep[maxn],dis[maxn],sma[maxn],srec[maxn],dma[maxn];\nvector<int>poi[maxn];\nbool vis[maxn];\ninline bool cmp1(int x,int y){return md[x]<md[y];}\ninline bool cmp2(int x,int y){return mmd[x]<mmd[y];}\ninline void add(int from,int to,int l){\n\te[++num].pre=h[from],h[from]=num,e[num].to=to,e[num].l=l;\n}\nvoid getroot(int node,int fa){\n\tsiz[node]=1;\n\tint x,ma=0;\n\tfor(register int i=h[node];i;i=e[i].pre){\n\t\tx=e[i].to;\n\t\tif(x==fa||vis[x])continue;\n\t\tgetroot(x,node),siz[node]+=siz[x],ma=max(ma,siz[x]);\n\t}\n\tma=max(ma,all-siz[node]);\n\tif(ma<mx)mx=ma,root=node;\n}\nvoid bfs(int node){\n\tint x,y;\n\thead=0,line[tail=1]=node,deep[node]=1;\n\twhile(head<tail){\n\t\tx=line[++head];\n\t\tif(deep[x]>R){md[node]=R;return;}\n\t\tfor(register int i=h[x];i;i=e[i].pre){\n\t\t\ty=e[i].to;\n\t\t\tif(y==f[x]||vis[y])continue;\n\t\t\tc[y]=e[i].l,f[y]=x,line[++tail]=y,deep[y]=deep[x]+1;\n\t\t}\t\n\t}\n\tmd[node]=deep[line[tail]];\n}\nvoid calc(int node,int m){\n\tq2.clear();\n\tfor(register int i=m;i>=L;--i)q2.push(i,sma[i]);\n\tint x,y,l,r;\n\thead=0,line[tail=1]=node;\n\twhile(head<tail){\n\t\tx=line[++head];\n\t\tif(deep[x]>R)return;\n\t\tdis[x]=dis[f[x]]+v[c[x]]*bool(c[x]^c[f[x]]);\n\t\tsrec[deep[x]]=max(srec[deep[x]],dis[x]);\n\t\tfor(register int i=h[x];i;i=e[i].pre){\n\t\t\ty=e[i].to;\n\t\t\tif(y==f[x]||vis[y])continue;\n\t\t\tline[++tail]=y;\n\t\t}\n\t\tif(head==tail||deep[x]!=deep[line[head+1]]){\n\t\t\tl=L-deep[x],r=R-deep[x];\n\t\t\tq2.check(r);\n\t\t\tif(l>=0)q2.push(l,sma[l]);\n\t\t\tans=max(ans,q2.front()+srec[deep[x]]-dis[node]);\n\t\t}\n\t}\n}\nvoid solve(int node){\n\tint x,y,z,len=0;\n\tvis[node]=1;\n\tfor(register int i=h[node];i;i=e[i].pre){\n\t\tx=e[i].to;\n\t\tif(vis[x])continue;\n\t\tif(poi[e[i].l].empty())col[++len]=e[i].l,mmd[e[i].l]=0;\n\t\tc[x]=e[i].l,f[x]=node,poi[c[x]].push_back(x),bfs(x);\n\t\tmmd[c[x]]=max(mmd[c[x]],md[x]);\n\t}\n\tc[node]=dis[node]=0;\n\tsort(col+1,col+1+len,cmp2);\n\ty=mmd[col[len]];\n\tfor(register int i=1;i<=len;++i){\n\t\tx=col[i],z=0;\n\t\tsort(poi[x].begin(),poi[x].end(),cmp1);\n\t\tfor(vector<int>::iterator iter=poi[x].begin();iter!=poi[x].end();++iter){\n\t\t\tdis[*iter]=v[x],calc(*iter,z);\n\t\t\tfor(register int j=z=md[*iter];j;--j)\n\t\t\t\tsma[j]=max(sma[j],srec[j]),srec[j]=-inf;\n\t\t}\n\t\tq1.clear();\n\t\tfor(register int j=mmd[col[i-1]];j>=L;--j)q1.push(j,dma[j]);\n\t\tfor(register int j=1;j<=mmd[x];++j){\n\t\t\tq1.check(R-j);\n\t\t\tif(L>=j)q1.push(L-j,dma[L-j]);\n\t\t\tans=max(q1.front()+sma[j],ans);\n\t\t}\n\t\tfor(register int j=mmd[x];j;--j)\n\t\t\tdma[j]=max(dma[j],sma[j]),sma[j]=-inf;\n\t\tpoi[x].clear();\n\t}\n\tfor(register int i=y;i;--i)dma[i]=-inf;\n\tfor(register int i=h[node];i;i=e[i].pre){\n\t\tx=e[i].to;\n\t\tif(vis[x])continue;\n\t\troot=0,all=siz[x],mx=inf,getroot(x,node),solve(root);\n\t}\n}\nint main(){\n\tmemset(sma,~0x3f,sizeof sma);\n\tmemset(srec,~0x3f,sizeof srec);\n\tmemset(dma,~0x3f,sizeof dma);\n\tans=-inf,dma[0]=0;\n\tint n=read(),m=read(),x,y,z;\n\tL=read(),R=read();\n\tfor(register int i=1;i<=m;++i)v[i]=read();\n\tfor(register int i=1;i<n;++i)x=read(),y=read(),z=read(),add(x,y,z),add(y,x,z);\n\tmx=inf,all=n,getroot(1,0),solve(root);\n\tprintf(\"%d\\n\",ans);\n}\n```\n\n",
        "postTime": 1565871907,
        "uid": 111762,
        "name": "_ctz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "**Update On 20200714: \u4fee\u590d\u4e86\u4ee3\u7801\u4e2d\u7684\u95ee\u9898\uff0c\u73b0\u5728\u53ef\u4ee5\u901a\u8fc7 Hack \u6570\u636e\uff1b\u4fee\u6539\u4e86\u90e8\u5206\u9898\u89e3\u63cf\u8ff0\u3002**\n\n---\n\n\u8def\u5f84\u7edf\u8ba1\u95ee\u9898\u8003\u8651\u70b9\u5206\u6cbb\uff0c\u4ece\u5206\u6cbb\u4e2d\u5fc3\u51fa\u53d1\u5f97\u5230\u82e5\u5e72\u8def\u5f84\uff0c\u91cd\u70b9\u662f\u5408\u5e76\u3002\u4e24\u6761\u8def\u5f84\u7684\u8d77\u59cb\u8fb9\u5982\u679c\u989c\u8272\u76f8\u540c\uff0c\u5b83\u4eec\u7684\u8d21\u732e\u9700\u8981\u51cf\u6389\u4e24\u6761\u8def\u5f84\u8d77\u59cb\u8fb9\u989c\u8272\u7684\u6743\u503c\uff0c\u5426\u5219\u8d21\u732e\u5c31\u662f\u4e24\u6761\u8def\u5f84\u7684\u6743\u503c\u548c\u3002\n\n\u8003\u8651\u5206\u5f00\u5904\u7406\u8fd9\u4e24\u79cd\u4e0d\u540c\u7684\u8d21\u732e\u3002\u5bf9\u4e8e\u786e\u5b9a\u7684\u5206\u6cbb\u4e2d\u5fc3\uff0c\u5c06\u5176\u6240\u6709\u51fa\u8fb9\u6309\u989c\u8272\u6392\u5e8f\u4f9d\u6b21 dfs\uff0c\u76ee\u7684\u662f\u8ba9\u989c\u8272\u76f8\u540c\u7684\u82e5\u5e72\u8def\u5f84\u4e00\u8d77\u5904\u7406\u3002\u7ef4\u62a4\u4e24\u68f5\u7ebf\u6bb5\u6811\uff0c\u4ee5\u8def\u5f84\u957f\u5ea6\u4e3a\u4e0b\u6807\u5206\u522b\u7ef4\u62a4\u8def\u5f84\u8d77\u59cb\u8fb9\u989c\u8272\u4e0e\u5f53\u524d\u989c\u8272\u76f8\u540c/\u4e0d\u540c\u7684\u8def\u5f84\u6743\u503c\u6700\u5927\u503c\u3002\n\n\u904d\u5386\u7684\u65f6\u5019\u5148\u641c\u51fa\u6240\u6709\u8def\u5f84\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8def\u5f84\u5728\u4e24\u68f5\u7ebf\u6bb5\u6811\u4e0a\u5206\u522b\u67e5\u8be2\u5f97\u5230\u5176\u8d21\u732e\uff0c\u7136\u540e\u5c06\u5b83\u4eec\u63d2\u5165\u5230\u7ebf\u6bb5\u6811\u4e2d\u3002\u5f53\u6b63\u5728\u505a\u7684\u989c\u8272\u53d8\u6210\u4e0d\u540c\u7684\u989c\u8272\u65f6\uff0c\u5c06\u8fd9\u4e24\u68f5\u7ebf\u6bb5\u6811\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u5408\u5e76\u4fe1\u606f\u3002\u590d\u6742\u5ea6 $O(n \\log^2 n)$\u3002\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define sz(x) (int)x.size()\nconst int INF = 2e9 + 1 , _ = 2e5 + 7; int N , M , L , R , col[_];\nstruct Edge{int end , upEd , c;}Ed[_ << 1]; int head[_] , cntEd;\nvoid addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}\n\nint nsz , msz , id; bool vis[_];\nvoid getsz(int x){++nsz; vis[x] = 1; for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) getsz(Ed[i].end); vis[x] = 0;}\nint getrt(int x){\n\tint sz = 1 , mx = 0; vis[x] = 1;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]){int t = getrt(Ed[i].end); mx = max(mx , t); sz += t;}\n\tmx = max(mx , nsz - sz); if(mx < msz){msz = mx; id = x;} vis[x] = 0; return sz;\n}\n\n#define mid ((l + r) >> 1)\nconst int __ = _ << 6; int ch[__][2] , mx[__] , cnt;\nint alloc(){++cnt; mx[cnt] = -INF; ch[cnt][0] = ch[cnt][1] = 0; return cnt;}\n\nvoid ins(int &x , int l , int r , int t , int v){\n\tx = x ? x : alloc(); mx[x] = max(mx[x] , v); if(l != r) mid >= t ? ins(ch[x][0] , l , mid , t , v) : ins(ch[x][1] , mid + 1 , r , t , v);\n}\n\nint qry(int x , int l , int r , int L , int R){\n\tif(!x) return -INF;\n\tif(l >= L && r <= R) return mx[x];\n\tint mx = -INF; if(mid >= L) mx = qry(ch[x][0] , l , mid , L , R);\n\tif(mid < R) mx = max(mx , qry(ch[x][1] , mid + 1 , r , L , R));\n\treturn mx;\n}\n\nint merge(int p , int q){\n\tif(!p || !q) return p + q;\n\tmx[p] = max(mx[p] , mx[q]); ch[p][0] = merge(ch[p][0] , ch[q][0]); ch[p][1] = merge(ch[p][1] , ch[q][1]); return p;\n}\n\nint ans = -INF , r1 , r2; vector < pair < int , int > > rte;\nvoid qroute(int x , int l , int c , int val){\n\tif(l > R) return;\n\trte.push_back(make_pair(l , val)); vis[x] = 1;\n\tfor(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) qroute(Ed[i].end , l + 1 , Ed[i].c , c == Ed[i].c ? val : val + col[Ed[i].c]);\n\tvis[x] = 0;\n}\n\nvoid solve(int x){\n\tnsz = 0; msz = 1e9; getsz(x); getrt(x); x = id; cnt = r1 = r2 = 0; ins(r1 , 0 , N , 0 , 0); vis[x] = 1;\n\tvector < pair < int , int > > ch; for(int i = head[x] ; i ; i = Ed[i].upEd) if(!vis[Ed[i].end]) ch.push_back(make_pair(Ed[i].c , Ed[i].end));\n\tsort(ch.begin() , ch.end());\n\tfor(int i = 0 ; i < sz(ch) ; ++i){\n\t\tif(i && ch[i].first != ch[i - 1].first){r1 = merge(r1 , r2); r2 = 0;}\n\t\trte.clear(); qroute(ch[i].second , 1 , ch[i].first , col[ch[i].first]);\n\t\tfor(int j = 0 ; j < sz(rte) ; ++j)\n\t\t\tans = max(ans , max(qry(r1 , 0 , N , max(0 , L - rte[j].first) , R - rte[j].first) ,\n\t\t\t\t\t\t\t\tqry(r2 , 0 , N , max(0 , L - rte[j].first) , R - rte[j].first) - col[ch[i].first]) + rte[j].second);\n\t\tfor(int i = 0 ; i < sz(rte) ; ++i) ins(r2 , 0 , N , rte[i].first , rte[i].second);\n\t}\n\tfor(int i = 0 ; i < sz(ch) ; ++i) solve(ch[i].second);\n}\n\nint main(){\n\tios::sync_with_stdio(0); cin >> N >> M >> L >> R; for(int i = 1 ; i <= M ; ++i) cin >> col[i];\n\tfor(int i = 1 ; i < N ; ++i){int p , q , c; cin >> p >> q >> c; addEd(p , q , c); addEd(q , p , c);}\n\tsolve(1); cout << ans; return 0;\n}\n```",
        "postTime": 1544058445,
        "uid": 96296,
        "name": "Itst",
        "ccfLevel": 0,
        "title": "P3714 BJOI2017 \u6811\u7684\u96be\u9898"
    },
    {
        "content": "[\u6d1b\u8c37\u9898\u9762\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P3714)\n\n\u54a6\uff1f\u9e3d\u5b50 tzc \u7adf\u7136\u6765\u8865\u9898\u89e3\u4e86\uff1fincredible\uff08\n\n\u9996\u5148\u770b\u5230\u8fd9\u6837\u7c7b\u4f3c\u4e8e\u8def\u5f84\u7edf\u8ba1\u7684\u95ee\u9898\u6211\u4eec\u53ef\u4ee5\u975e\u5e38\u81ea\u7136\u5730\u60f3\u5230\u70b9\u5206\u6cbb\u3002\u6bcf\u6b21\u6211\u4eec\u627e\u51fa\u6bcf\u4e2a\u8fde\u901a\u5757\u7684\u91cd\u5fc3 $x$ \u7136\u540e\u4ee5 $x$ \u4e3a\u6839 DFS \u4e00\u904d\u6574\u4e2a\u5b50\u6811\uff0c\u6211\u4eec\u5047\u8bbe $y$ \u5230 $x$ \u7684\u8ddd\u79bb\u4e3a $dep_y$\uff0c$x\\to y$ \u8fd9\u4e00\u6bb5\u4e0a\u989c\u8272\u7684\u6743\u503c\u4e4b\u548c\u4e3a $sum_y$\uff0c\u90a3\u4e48\u8003\u8651\u600e\u6837\u5408\u5e76\u4e24\u6761\u8def\u5f84\u3002\u663e\u7136\u5bf9\u4e8e\u4e24\u4e2a\u5728 $x$ \u4e0d\u540c\u5b50\u6811\u5185\u7684\u70b9 $y,z$\uff0c$y\\to z$ \u8def\u5f84\u4e0a\u8fb9\u7684\u4e2a\u6570\u5c31\u662f $dep_y+dep_z$\uff0c\u8def\u5f84\u4e0a\u6743\u503c\u4e4b\u548c\u5c31\u662f $sum_y+sum_z-c_{col_y}\u00b7[col_y=col_z]$\uff0c\u5176\u4e2d $col_y$ \u4e3a $x\\to y$ \u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u7b2c\u4e00\u6761\u8fb9\u7684\u6743\u503c\u3002\u770b\u5230\u8fd9\u4e2a $[col_y=col_z]$ \u8c8c\u4f3c\u6709\u70b9\u68d8\u624b\uff0c\u4e0d\u8fc7\u6ce8\u610f\u5230\u6211\u4eec\u8d21\u732e\u663e\u7136\u662f\u4e00\u4e2a\u5b50\u6811\u4e00\u4e2a\u5b50\u6811\u8ba1\u7b97\u7684\u5bf9\u5427\uff0c\u56e0\u6b64\u6211\u4eec\u8003\u8651**\u5c06 $x$ \u6240\u6709\u5b50\u6811\u6309 $x$ \u5230\u8fd9\u68f5\u5b50\u6811\u7ecf\u8fc7\u7684\u7b2c\u4e00\u6761\u8fb9\u7684\u989c\u8272**\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u7136\u540e\u7ef4\u62a4\u4e24\u68f5\u7ebf\u6bb5\u6811\uff0c\u7b2c\u4e00\u68f5\u7ebf\u6bb5\u6811\u4e0a\u4e0b\u6807\u4e3a $d$ \u7684\u4f4d\u7f6e\u4e0a\u7ef4\u62a4 $\\max\\limits_{dep_y=d\\land col_y\\ne C}sum_y$\uff0c\u7b2c\u4e8c\u68f5\u7ef4\u62a4 $\\max\\limits_{dep_y=d\\land col_y=C}sum_y$\uff0c\u5176\u4e2d $C$ \u4e3a\u5f53\u524d\u989c\u8272\u79cd\u7c7b\uff0c\u7136\u540e\u6bcf\u6b21\u989c\u8272\u6539\u53d8\u5c31\u66b4\u529b\u5730\u5c06\u7b2c\u4e8c\u68f5\u7ebf\u6bb5\u6811\u4e2d\u6240\u6709\u5143\u7d20\u63d2\u5165\u7b2c\u4e00\u68f5\u7ebf\u6bb5\u6811\u4e2d\u5373\u53ef\uff0c\u67e5\u8be2\u5c31\u5728\u4e24\u68f5\u6811\u4e2d\u5206\u522b\u67e5 $[r-dep_y,l-dep_y]$ \u7684\u6700\u5927\u503c\uff0c\u8bb0\u4f5c $mx1$ \u548c $mx2$\uff0c\u7136\u540e\u7528 $mx1+sum_y,mx2-c_{col_y}+sum_y$ \u66f4\u65b0\u7b54\u6848\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $n\\log^2n$\uff0c\u5176\u4e2d\u4e00\u4e2a $\\log$ \u5728\u4e8e\u70b9\u5206\u6cbb\uff0c\u4e00\u4e2a $\\log$ \u5728\u4e8e\u7ebf\u6bb5\u6811\u3002\n\n\u6700\u540e\u7a0d\u5fae\u603b\u7ed3\u4e00\u4e0b\u8fd9\u7c7b\u70b9\u5206\u6cbb\u89e3\u51b3\u6811\u4e0a\u8def\u5f84\u8ba1\u6570\u9898\u76ee\u7684\u89e3\u9898\u6280\u5de7\uff1a\u9996\u5148\u8981\u8003\u8651\u600e\u6837\u5408\u5e76\u4e24\u6bb5\u8def\u5f84\uff0c\u5982\u679c\u4e0d\u597d\u5408\u5e76\u90a3\u4e00\u822c\u4f7f\u7528\u70b9\u5206\u6cbb\u4e0d\u592a\u597d\u89e3\u51b3\uff0c\u5176\u6b21\u8981\u601d\u8003\u5982\u4f55\u7ef4\u62a4\u4e24\u6bb5\u8def\u5f84\u7684\u51b3\u7b56\uff0c\u6bd4\u8f83\u7b80\u5355\u7684\u4f7f\u7528\u4e00\u4e2a\u6876\u5373\u53ef\u7ef4\u62a4\uff0c\u6bd4\u8f83\u590d\u6742\u7684\u9700\u7528 BIT/\u7ebf\u6bb5\u6811/\u5e73\u8861\u6811\u89e3\u51b3\u3002\u5bf9\u4e8e\u8ba1\u6570\u95ee\u9898\uff0c\u5bb9\u65a5\u4e5f\u662f\u4e00\u4e2a\u4e0d\u9519\u7684\u9009\u62e9\uff0c\u5373\u5148\u4e0d\u8003\u8651\u4e24\u4e2a\u7aef\u70b9\u4e0d\u5728\u540c\u4e00\u5b50\u6811\u8fd9\u4e00\u6761\u4ef6\uff0c\u5148\u4e00\u80a1\u8111\u628a\u8d21\u732e\u5168\u52a0\u4e0a\u53bb\uff0c\u518d\u6263\u6389\u5728\u540c\u4e00\u5b50\u6811\u5185\u7684\u60c5\u51b5\u3002\n\n```cpp\nconst int MAXN=2e5;\nconst int INF=0x3f3f3f3f;\nconst ll INFll=0x3f3f3f3f3f3f3f3fll;\nint n,m,L,R,c[MAXN+5],hd[MAXN+5],to[MAXN*2+5],val[MAXN*2+5],nxt[MAXN*2+5],ec=0;\nvoid adde(int u,int v,int w){to[++ec]=v;val[ec]=w;nxt[ec]=hd[u];hd[u]=ec;}\nint mx[MAXN+5],cent=0,siz[MAXN+5];bool vis[MAXN+5];\nvoid findcent(int x,int f,int tot){\n\tmx[x]=0;siz[x]=1;\n\tfor(int e=hd[x];e;e=nxt[e]){\n\t\tint y=to[e];if(y==f||vis[y]) continue;\n\t\tfindcent(y,x,tot);siz[x]+=siz[y];\n\t\tchkmax(mx[x],siz[y]);\n\t} chkmax(mx[x],tot-siz[x]);\n\tif(mx[cent]>mx[x]) cent=x;\n}\nint dep[MAXN+5];ll sum[MAXN+5];\nvoid getdep(int x,int f,int pre){\n\tfor(int e=hd[x];e;e=nxt[e]){\n\t\tint y=to[e],z=val[e];if(y==f||vis[y]) continue;\n\t\tdep[y]=dep[x]+1;sum[y]=sum[x]+((z==pre)?0:c[z]);\n\t\tgetdep(y,x,z);\n\t}\n}\nstruct segtree{\n\tstruct node{int l,r;ll mx;} s[MAXN*4+5];\n\tstack<int> stk;\n\tvoid pushup(int k){s[k].mx=max(s[k<<1].mx,s[k<<1|1].mx);stk.push(k);}\n\tvoid build(int k,int l,int r){\n\t\ts[k].l=l;s[k].r=r;s[k].mx=-INFll;if(l==r) return;\n\t\tint mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);\n\t}\n\tvoid modify(int k,int p,ll v){\n\t\tif(s[k].l==s[k].r) return chkmax(s[k].mx,v),stk.push(k),void();\n\t\tint mid=s[k].l+s[k].r>>1;(p<=mid)?modify(k<<1,p,v):modify(k<<1|1,p,v);\n\t\tpushup(k);\n\t}\n\tll query(int k,int l,int r){\n\t\tif(l>r) return -INFll;\n\t\tif(l<=s[k].l&&s[k].r<=r) return s[k].mx;\n\t\tint mid=s[k].l+s[k].r>>1;\n\t\tif(r<=mid) return query(k<<1,l,r);\n\t\telse if(l>mid) return query(k<<1|1,l,r);\n\t\telse return max(query(k<<1,l,mid),query(k<<1|1,mid+1,r));\n\t}\n\tvoid relax(){\n\t\twhile(!stk.empty()){\n\t\t\tint k=stk.top();stk.pop();\n\t\t\ts[k].mx=-INFll;\n\t\t}\n\t}\n} s1,s2;\nvector<int> pt;\nll res=-INFll;\nvoid findpts(int x,int f){\n\tpt.pb(x);\n\tfor(int e=hd[x];e;e=nxt[e]){\n\t\tint y=to[e];if(y==f||vis[y]) continue;\n\t\tfindpts(y,x);\n\t}\n}\nvoid divcent(int x){\n//\tprintf(\"divcent %d\\n\",x);\n\tvis[x]=1;dep[x]=sum[x]=0;\n\tvector<pii> sub;\n\tfor(int e=hd[x];e;e=nxt[e]){\n\t\tint y=to[e],z=val[e];if(vis[y]) continue;\n\t\tdep[y]=1;sum[y]=c[z];getdep(y,x,z);\n\t\tsub.pb(mp(z,y));\n\t} sort(sub.begin(),sub.end());\n\tvector<int> wt;s1.modify(1,0,0);\n\tfor(int i=0;i<sub.size();i++){\n\t\tif(i&&sub[i].fi!=sub[i-1].fi){\n\t\t\ts2.relax();\n\t\t\tfor(int y:wt) s1.modify(1,dep[y],sum[y]);\n\t\t\twt.clear();\n\t\t} int y=sub[i].se;pt.clear();findpts(y,x);\n\t\tfor(int z:pt){\n\t\t\tint d=dep[z];\n\t\t\tif(d<=R){\n\t\t\t\tchkmax(res,s1.query(1,max(L-d,0),R-d)+sum[z]);\n\t\t\t\tchkmax(res,s2.query(1,max(L-d,0),R-d)+sum[z]-c[sub[i].fi]);\n\t\t\t}\n\t\t} for(int z:pt) wt.pb(z),s2.modify(1,dep[z],sum[z]);\n//\t\tfor(int z:pt) printf(\"%d %d %lld\\n\",z,dep[z],sum[z]);\n\t} s1.relax();s2.relax();\n\tfor(int e=hd[x];e;e=nxt[e]){\n\t\tint y=to[e];if(vis[y]) continue;cent=0;\n\t\tfindcent(y,x,siz[y]);divcent(cent);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);s1.build(1,0,n);s2.build(1,0,n);\n\tfor(int i=1;i<=m;i++) scanf(\"%d\",&c[i]);\n\tfor(int i=1,u,v,w;i<n;i++) scanf(\"%d%d%d\",&u,&v,&w),adde(u,v,w),adde(v,u,w);\n\tmx[0]=INF;findcent(1,0,n);divcent(cent);\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1632108686,
        "uid": 115194,
        "name": "lTgMFePRoeZ",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3714 [BJOI2017]\u6811\u7684\u96be\u9898"
    },
    {
        "content": "\u70b9\u5206\u6cbb+\u7ebf\u6bb5\u6811  \n\u9996\u5148\u7528\u70b9\u5206\u6cbb\u53bb\u5206\u5272\u8def\u5f84\uff0c\u95ee\u9898\u662f\u5982\u4f55\u7edf\u8ba1\u4e0d\u540c\u989c\u8272\u3002  \n\u5728\u70b9\u5206\u6cbb\u7684\u65f6\u5019\uff0c\u5982\u679c\u4ece\u6839\u5ef6\u4f38\u51fa\u7684\u4e24\u6761\u94fe\u6700\u4e0a\u9762\u7684\u8fb9\u7684\u989c\u8272\u4e0d\u540c\uff0c\u90a3\u4e48\u8fd9\u4e24\u6761\u94fe\u7684\u8d21\u732e\u5c31\u662f\u4e24\u6761\u94fe\u7684\u8d21\u732e\u52a0\u548c\uff0c\u5982\u679c\u4e24\u6761\u94fe\u6700\u4e0a\u9762\u7684\u8fb9\u7684\u989c\u8272\u4e00\u6837\uff0c\u8d21\u732e\u5c31\u662f\u4e24\u6761\u94fe\u7684\u989c\u8272\u52a0\u548c\u51cf\u53bb\u6700\u4e0a\u9762\u989c\u8272\u7684\u6743\u503c\u3002  \n\u8003\u8651\u628a\u6bcf\u4e2a\u70b9\u8fde\u51fa\u53bb\u7684\u8fb9\u6309\u7167\u989c\u8272\u6392\u5e8f\uff0c\u8fd9\u6837\u5728\u70b9\u5206\u6cbb\u7684\u65f6\u5019\u9876\u4e0a\u989c\u8272\u76f8\u540c\u7684\u94fe\u5c31\u4e00\u5b9a\u4f1a\u5728\u4e00\u8d77\u88ab\u5904\u7406\u3002\u7528\u4e24\u9897\u7ebf\u6bb5\u6811\u5206\u522b\u4fdd\u5b58\u5df2\u7ecf\u88ab\u904d\u5386\u8fc7\u7684\u989c\u8272\u7684\u6700\u5927\u6743\u503c\u548c\u5f53\u524d\u88ab\u904d\u5386\u7684\u989c\u8272\u7684\u6700\u5927\u6743\u503c\uff0c\u5728\u7ed3\u675f\u904d\u5386\u65f6\u5c06\u5f53\u524d\u904d\u5386\u7684\u989c\u8272\u52a0\u5165\u5230\u5df2\u7ecf\u88ab\u904d\u5386\u7684\u989c\u8272\uff0c\u540c\u65f6\u6e05\u7a7a\u8868\u793a\u5f53\u524d\u88ab\u904d\u5386\u7684\u989c\u8272\u6743\u503c\u7684\u7ebf\u6bb5\u6811\u3002  \n\u5e38\u6570\u53ef\u80fd\u6709\u4e00\u4e9b\u5927  \n\u4ee3\u7801\u7ec6\u8282\u5728\u6ce8\u91ca\u91cc\n```\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int maxn=2e5+10;\nint n,m,L,R;\nint ans=-2e9;\nint c[maxn];\nstruct edge\n{\n\tint to,col;\n};\nbool comp_by_col(edge a,edge b){return a.col<b.col;}\nvector<edge>e[maxn];\nint rt,maxp[maxn],siz[maxn],nodenum;\nint vis[maxn];\nvoid getrt(int now,int last)\n{\n\tsiz[now]=1;maxp[now]=0;\n\tfor(int i=0;i<e[now].size();i++)\n\t{\n\t\tint to=e[now][i].to;\n\t\tif(to==last||vis[to])continue;\n\t\tgetrt(to,now);siz[now]+=siz[to];\n\t\tmaxp[now]=max(maxp[now],siz[to]);\n\t}\n\tmaxp[now]=max(maxp[now],nodenum-siz[now]);\n\tif(maxp[rt]>maxp[now])rt=now;\n}\nstruct segmenttree\n{\n\tstruct node\n\t{\n\t\tint maxnum;\n\t\tint tag;\n\t};\n\tnode t[maxn<<3];\n\tvoid clear()\n\t{\n\t\tt[1].tag=1;t[1].maxnum=-2e9;//\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u6839\u4e0a\u6253\u6807\u8bb0\u6765\u6e05\u7a7a\u7ebf\u6bb5\u6811 \n\t}\n\tvoid pushdown(int u)\n\t{\n\t\tif(t[u].tag)\n\t\t{\n\t\t\tt[u<<1].tag=t[u<<1|1].tag=1;\n\t\t\tt[u<<1].maxnum=-2e9;t[u<<1|1].maxnum=-2e9;\n\t\t\tt[u].tag=0;\n\t\t}\n\t}\n\tvoid update(int u)\n\t{\n\t\tt[u].maxnum=max(t[u<<1].maxnum,t[u<<1|1].maxnum);\n\t}\n\tvoid change(int u,int l,int r,int p,int x)\n\t{\n\t\tif(l>p||r<p)return;\n\t\tif(l==r)\n\t\t{\n\t\t\tt[u].tag=0;//\u8fd9\u91cc\u8bb0\u5f97\u6e05\u9664\u6807\u8bb0 \n\t\t\tt[u].maxnum=max(t[u].maxnum,x);return;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tpushdown(u);\n\t\tif(mid>=p)change(u<<1,l,mid,p,x);\n\t\telse change(u<<1|1,mid+1,r,p,x);\n\t\tupdate(u);\n\t}\n\tint query(int u,int l,int r,int nl,int nr)\n\t{\n\t\tif(l>nr||r<nl)return -2e9;\n\t\tif(l>=nl&&r<=nr)return t[u].maxnum;\n\t\tif(t[u].tag)return -2e9;\n\t\tpushdown(u);\n\t\tint mid=(l+r)>>1;\n\t\treturn max(query(u<<1,l,mid,nl,nr),query(u<<1|1,mid+1,r,nl,nr));\n\t}\n};\nsegmenttree diff,same;\nint dep[maxn],nowcol;\nvoid getdis(int u,int last,int val,int lastcol)//\u66f4\u65b0\u7b54\u6848 \n{\n\tdep[u]=dep[last]+1;\n\tif(dep[u]>R)return;\n \tif(dep[u]>=L&&dep[u]<=R)ans=max(ans,val);\n\tans=max(ans,max(val+same.query(1,0,n,max(0,L-dep[u]),R-dep[u])-c[nowcol],val+diff.query(1,0,n,max(0,L-dep[u]),R-dep[u])));//dep[u]\u53ef\u80fd\u8d85\u8fc7L\uff0c\u6545\u5de6\u7aef\u70b9\u4e3amax(0,L-dep[u]) \n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint to=e[u][i].to,tc=e[u][i].col;\n\t\tif(to==last||vis[to])continue;\n\t\tif(tc==lastcol)getdis(to,u,val,lastcol);\n\t\telse getdis(to,u,val+c[tc],tc);\n\t}\n}\nvoid update(int u,int last,long long val,int lastcol)//\u66f4\u65b0\u540c\u4e00\u989c\u8272\u7684\u7ebf\u6bb5\u6811 \n{\n\tdep[u]=dep[last]+1;\n\tif(dep[u]>R)return;\n \tsame.change(1,0,n,dep[u],val);\n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint to=e[u][i].to,tc=e[u][i].col;\n\t\tif(to==last||vis[to])continue;\n\t\tif(tc==lastcol)update(to,u,val,lastcol);\n\t\telse update(to,u,val+c[tc],tc);\n\t}\n}\nvoid add(int u,int last,int val,int lastcol)//\u66f4\u65b0\u4e0d\u540c\u989c\u8272\u7684\u7ebf\u6bb5\u6811 \n{\n\tdep[u]=dep[last]+1;\n\tif(dep[u]>R)return;\n\tdiff.change(1,0,n,dep[u],val);\n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint to=e[u][i].to,tc=e[u][i].col;\n\t\tif(to==last||vis[to])continue;\n\t\tif(tc==lastcol)add(to,u,val,lastcol);\n\t\telse add(to,u,val+c[tc],tc);\n\t}\n}\nint sta[maxn],top;//\u4fdd\u5b58\u540c\u4e00\u989c\u8272\u7684\u8282\u70b9 \nvoid calc(int u)\n{\n\tdiff.clear();same.clear();\n\tint top=0;\n\tdep[u]=0;//\u4f7f\u6839\u6df1\u5ea6\u4e3a0 \n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint to=e[u][i].to;\n\t\tif(vis[to])continue;\n\t\tif(i==0||e[u][i].col==e[u][i-1].col)//\u5982\u679c\u548c\u4e4b\u524d\u989c\u8272\u4e00\u6837 \n\t\t{\n\t\t\tsta[++top]=to;continue;\n\t\t}\n\t\tnowcol=e[u][i-1].col;//\u8bb0\u5f55\u5f53\u524d\u6240\u679a\u4e3e\u5b50\u6811\u6700\u4e0a\u7aef\u989c\u8272 \n\t\tfor(int j=1;j<=top;j++)\n\t\t{\n\t\t\tgetdis(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);\n\t\t\tupdate(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);\n\t\t}\n\t\tsame.clear();\n\t\tfor(int j=1;j<=top;j++)\n\t\t{\n\t\t\tadd(sta[j],u,c[e[u][i-1].col],e[u][i-1].col);\n\t\t}\n\t\ttop=0;//\u5f00\u59cb\u8bb0\u5f55\u4e0b\u4e00\u79cd\u989c\u8272 \n\t\tsta[++top]=e[u][i].to;\n\t}\n\tsame.clear();\n\tnowcol=e[u][e[u].size()-1].col;//\u6700\u540e\u4e00\u79cd\u989c\u8272\u5728\u5faa\u73af\u4e2d\u4e0d\u4f1a\u88ab\u8ba1\u7b97 \n\tfor(int i=1;i<=top;i++)\n\t{\n\t\tgetdis(sta[i],u,c[e[u][e[u].size()-1].col],e[u][e[u].size()-1].col);\n\t\tupdate(sta[i],u,c[e[u][e[u].size()-1].col],e[u][e[u].size()-1].col);\n\t}\n\ttop=0;\n\tsame.clear();diff.clear();\n}\nvoid solve(int u)\n{\n\tvis[u]=1;calc(u);\n\tfor(int i=0;i<e[u].size();i++)\n\t{\n\t\tint to=e[u][i].to;\n\t\tif(vis[to])continue;\n\t\trt=0;maxp[rt]=n;nodenum=siz[to];\n\t\tgetrt(to,u);solve(rt);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&c[i]);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y,z;scanf(\"%d%d%d\",&x,&y,&z);\n\t\te[x].push_back(edge{y,z});e[y].push_back(edge{x,z});\n\t}\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end(),comp_by_col);//\u6309\u7167\u989c\u8272\u6392\u5e8f \n\trt=0;maxp[rt]=nodenum=n;\n\tgetrt(1,0);solve(rt);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n```\n",
        "postTime": 1618638990,
        "uid": 174469,
        "name": "zero4338",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 [BJOI2017]\u6811\u7684\u96be\u9898"
    },
    {
        "content": "## \u5206\u6790\n\u8def\u5f84\u95ee\u9898\u8003\u8651\u70b9\u5206\u6cbb\n\n\u5bf9\u4e8e\u4e00\u4e2a\u5206\u6cbb\u4e2d\u5fc3\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5730\u5f97\u5230\u4ece\u5b83\u5f00\u59cb\u7684\u4e00\u6761\u8def\u5f84\u7684\u4ef7\u503c\u548c\u957f\u5ea6\n\n\u95ee\u9898\u5c31\u662f\u5982\u4f55\u5c06\u4e0d\u540c\u7684\u8def\u5f84\u5408\u5e76\n\n\u5f88\u663e\u7136\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u5b50\u6811\u4e2d\u7684\u6240\u6709\u8def\u5f84\uff0c\u5b83\u4eec\u8d77\u59cb\u7684\u989c\u8272\u662f\u76f8\u540c\u7684\n\n\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u4e00\u4e2a\u8282\u70b9\u7684\u6240\u6709\u5b50\u7ed3\u70b9\u6309\u7167\u989c\u8272\u6392\u5e8f\n\n\u8fd9\u4e2a\u53ef\u4ee5\u5728\u5efa\u56fe\u4e4b\u524d\u5904\u7406\u597d\n\n\u7136\u540e\u5f00\u4e24\u4e2a\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u4ee5\u8def\u5f84\u7684\u957f\u5ea6\u4f5c\u4e3a\u4e0b\u6807\n\n\u4e00\u68f5\u5b58\u50a8\u4e0e\u5f53\u524d\u8282\u70b9\u8d77\u59cb\u989c\u8272\u76f8\u540c\u7684\u6240\u6709\u8def\u5f84\uff0c\u53e6\u4e00\u68f5\u5b58\u50a8\u8d77\u59cb\u989c\u8272\u4e0d\u540c\u7684\u6240\u6709\u8def\u5f84\n\n\u5bf9\u4e8e\u957f\u5ea6\u4e3a $i$ \u7684\u8def\u5f84\uff0c\u6211\u4eec\u76f4\u63a5\u67e5\u8be2\u533a\u95f4 $[l-i,r-i]$ \u7684\u6700\u5927\u503c\u5373\u53ef\n\n\u5f53\u8282\u70b9\u7684\u989c\u8272\u6539\u53d8\u65f6\uff0c\u628a\u76f8\u540c\u7684\u90a3\u4e00\u5806\u5408\u5e76\u5230\u53e6\u4e00\u5806\u5373\u53ef\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $nlog^2n$\n\n## \u4ee3\u7801\n``` cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#define rg register\ninline int read(){\n\trg int x=0,fh=1;\n\trg char ch=getchar();\n\twhile(ch<'0' || ch>'9'){\n\t\tif(ch=='-') fh=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0' && ch<='9'){\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*fh;\n}\nconst int maxn=4e5+5;\nint h[maxn],tot=1,n,m,lef,rig,val[maxn];\nstruct asd{\n\tint to,nxt,val;\n}b[maxn];\nvoid ad(rg int aa,rg int bb,rg int cc){\n\tb[tot].to=bb;\n\tb[tot].nxt=h[aa];\n\tb[tot].val=cc;\n\th[aa]=tot++;\n}\nint siz[maxn],maxsiz[maxn],rt,totsiz;\nbool vis[maxn];\nvoid getroot(rg int now,rg int lat){\n\tsiz[now]=1,maxsiz[now]=0;\n\tfor(rg int i=h[now];i!=-1;i=b[i].nxt){\n\t\trg int u=b[i].to;\n\t\tif(u==lat || vis[u]) continue;\n\t\tgetroot(u,now);\n\t\tsiz[now]+=siz[u];\n\t\tmaxsiz[now]=std::max(maxsiz[now],siz[u]);\n\t}\n\tmaxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);\n\tif(maxsiz[now]<maxsiz[rt]) rt=now;\n}\nstruct trr{\n\tint lch,rch,val;\n\ttrr(){\n\t\tlch=rch=0;\n\t\tval=-0x3f3f3f3f;//\u4e00\u5b9a\u8981\u521d\u59cb\u5316\u6210\u65e0\u7a77\u5c0f\n\t}\n}tr[maxn*40];\nint cnt,rt1,rt2,tp,ans=-0x3f3f3f3f;\nvoid push_up(rg int da){\n\ttr[da].val=std::max(tr[tr[da].lch].val,tr[tr[da].rch].val);\n}\nint xg(rg int da,rg int l,rg int r,rg int wz,rg int val){\n\tif(!da){\n\t\tda=++cnt;\n\t\ttr[da].lch=tr[da].rch=0,tr[da].val=-0x3f3f3f3f;\n\t}\n\tif(l==r){\n\t\ttr[da].val=std::max(tr[da].val,val);\n\t\treturn da;\n\t}\n\trg int mids=(l+r)>>1;\n\tif(wz<=mids) tr[da].lch=xg(tr[da].lch,l,mids,wz,val);\n\telse tr[da].rch=xg(tr[da].rch,mids+1,r,wz,val);\n\tpush_up(da);\n\treturn da;\n}\nint bing(rg int aa,rg int bb,rg int l,rg int r){\n\tif(!aa || !bb) return aa+bb;\n\tif(l==r){\n\t\ttr[aa].val=std::max(tr[aa].val,tr[bb].val);\n\t\ttr[bb].val=-0x3f3f3f3f;\n\t\treturn aa;\n\t}\n\trg int mids=(l+r)>>1;\n\ttr[aa].lch=bing(tr[aa].lch,tr[bb].lch,l,mids);\n\ttr[aa].rch=bing(tr[aa].rch,tr[bb].rch,mids+1,r);\n\tpush_up(aa);\n\treturn aa;\n}\nint cx(rg int da,rg int l,rg int r,rg int nl,rg int nr){\n\tif(!da || l>r) return -0x3f3f3f3f;\n\tif(l>=nl && r<=nr) return tr[da].val;\n\trg int mids=(l+r)>>1,nans=-0x3f3f3f3f;\n\tif(nl<=mids) nans=std::max(nans,cx(tr[da].lch,l,mids,nl,nr));\n\tif(nr>mids) nans=std::max(nans,cx(tr[da].rch,mids+1,r,nl,nr));\n\treturn nans;\n}\nstruct jie{\n\tint val,dep;\n\tjie(){}\n\tjie(rg int aa,rg int bb){\n\t\tval=aa,dep=bb;\n\t}\n}sta[maxn];\nbool cmp(rg jie aa,rg jie bb){\n\treturn aa.val>bb.val;\n}\nstd::vector<jie> g[maxn];\nvoid dfs(rg int now,rg int lat,rg int nval,rg int ndep,rg int latcol){\n\tif(ndep>rig) return;\n\tsta[++tp]=jie(nval,ndep);\n\tfor(rg int i=h[now];i!=-1;i=b[i].nxt){\n\t\trg int u=b[i].to;\n\t\tif(u==lat || vis[u]) continue;\n\t\tdfs(u,now,(latcol==b[i].val)?nval:nval+val[b[i].val],ndep+1,b[i].val);\n\t}\n}\nvoid solve(rg int now){\n\tvis[now]=1;\n\trt1=rt2=cnt=0;\n\trg int latcol=0,jud=0;\n\tfor(rg int i=h[now];i!=-1;i=b[i].nxt){\n\t\trg int u=b[i].to;\n\t\tif(!vis[u]){\n\t\t\ttp=jud=0;\n\t\t\tdfs(u,now,val[b[i].val],1,b[i].val);\n\t\t\tif(b[i].val==latcol) jud=1;\n\t\t\telse {\n\t\t\t\trt1=bing(rt1,rt2,1,n);\n\t\t\t\trt2=0;\n\t\t\t}\n\t\t\tfor(rg int j=1;j<=tp;j++){\n\t\t\t\tif(jud) ans=std::max(ans,cx(rt2,1,n,std::max(1,lef-sta[j].dep),rig-sta[j].dep)+sta[j].val-val[latcol]);\n\t\t\t\tans=std::max(ans,cx(rt1,1,n,std::max(1,lef-sta[j].dep),rig-sta[j].dep)+sta[j].val);\n\t\t\t\tif(sta[j].dep>=lef && sta[j].dep<=rig) ans=std::max(ans,sta[j].val);\n\t\t\t}\n\t\t\tfor(rg int j=1;j<=tp;j++) rt2=xg(rt2,1,n,sta[j].dep,sta[j].val);\n\t\t\tlatcol=b[i].val;\n\t\t}\n\t}\n\tfor(rg int i=h[now];i!=-1;i=b[i].nxt){\n\t\trg int u=b[i].to;\n\t\tif(!vis[u]){\n\t\t\ttotsiz=siz[u],rt=0;\n\t\t\tgetroot(u,now);\n\t\t\tsolve(rt);\n\t\t}\n\t}\n}\nint main(){\n\tmemset(h,-1,sizeof(h));\n\tn=read(),m=read(),lef=read(),rig=read();\n\tfor(rg int i=1;i<=m;i++) val[i]=read();\n\trg int aa,bb,cc;\n\tfor(rg int i=1;i<n;i++){\n\t\taa=read(),bb=read(),cc=read();\n\t\tg[aa].push_back(jie(cc,bb)),g[bb].push_back(jie(cc,aa));\n\t}\n\tfor(rg int i=1;i<=n;i++) std::sort(g[i].begin(),g[i].end(),cmp);\n\tfor(rg int i=1;i<=n;i++){\n\t\tfor(rg int j=0;j<g[i].size();j++){\n\t\t\tad(i,g[i][j].dep,g[i][j].val);\n\t\t}\n\t}\n\tmaxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;\n\tgetroot(1,0);\n\tsolve(rt);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```",
        "postTime": 1610529489,
        "uid": 316322,
        "name": "hzoi_liuchang",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u9898\u76ee\u5927\u610f\uff1a\u4e00\u68f5\u6811\u4e0a\uff0c\u6bcf\u6761\u8fb9\u6709\u989c\u8272\uff0c\u6bcf\u79cd\u989c\u8272\u6709\u6743\u503c\u3002\u6c42\u6240\u6709\u957f\u5ea6\u5728 $l,r$ \u4e4b\u95f4\u7684\u8def\u5f84\u4e2d\uff0c\u8def\u5f84\u6743\u503c\u7684\u6700\u5927\u503c\u3002\n\n\u6b64\u5904\u8def\u5f84\u6743\u503c\u610f\u4e3a\uff1a\u7531\u8def\u5f84\u4e0a\u7684\u8fb9\u7ec4\u6210\u4e00\u4e2a\u989c\u8272\u5e8f\u5217\uff0c\u8be5\u5e8f\u5217\u4e0a\u6bcf\u4e2a\u540c\u989c\u8272\u6bb5\u7684\u6743\u503c\u548c\u3002\n\n[\u539f\u9898](https://www.luogu.com.cn/problem/P3714)\n\n\u4e0d\u9519\u7684\u70b9\u5206\u6cbb\u7ec3\u4e60\u9898\u3002\n\n\u8003\u8651\u82e5\u786e\u5b9a\u4e00\u6761\u8def\u5f84\u7684LCA\uff0c\u5982\u4f55\u6c42\u6240\u6709\u4ee5\u8be5\u70b9\u4e3aLCA\u7684\u8def\u5f84\u4e2d\uff0c\u6ee1\u8db3\u9898\u610f\u7684\u8def\u5f84\u6743\u503c\u6700\u5927\u503c\uff1f\n\n\u6211\u4eec\u53ef\u4ee5\u8fc5\u901f\u60f3\u5230\u4e00\u4e2anaive\u7684\u4e1c\u897f\uff1a\u6c42\u51fa\u4e00\u68f5\u5b50\u6811\u4e2d\uff0c\u6bcf\u79cd\u957f\u5ea6\u7684\u94fe\u6743\u503c\u7684 $\\max$ \uff0c\u7136\u540e\u5c06\u5b83\u4e0e\u4e4b\u524d\u5df2\u6c42\u5f97\u7684\u5bf9\u5e94\u957f\u5ea6\u7684\u94fe\u6743\u503c\u7684 $\\max$ \u5408\u5e76\u6765\u66f4\u65b0\u7b54\u6848\u3002\n\n\u5177\u4f53\u6765\u8bf4\u5c31\u662f\u679a\u4e3e\u8be5\u5b50\u6811\u4e2d\u8def\u5f84\u957f\u5ea6\u4e3a $p$ \u7684\u94fe\uff0c\u90a3\u4e48\u4e0e\u5df2\u6c42\u5f97\u7684\u94fe\u4e2d\u957f\u5728 $l-p,r-p$ \u4e4b\u95f4\u7684\u6700\u5927\u503c\u5408\u5e76\uff0c\u5c1d\u8bd5\u66f4\u65b0\u7b54\u6848\u3002\n\n\u8fd9\u4e2a $\\max$ \u53ef\u4ee5\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u51fa\u6765\u3002\n\n\u4f46\u73b0\u5728\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u4e0d\u80fd\u7b80\u5355\u7684\u5408\u5e76\u94fe\uff1a\u5982\u679c\u4e24\u6761\u94fe\u5230LCA\u7684\u8fb9\u989c\u8272\u76f8\u540c\uff0c\u7b54\u6848\u8981\u51cf\u6389\u8be5\u989c\u8272\u7684\u6743\u503c\u3002\n\n\u90a3\u4e48\uff0c\u96be\u9053\u6211\u4eec\u8981\u628a\u5df2\u6c42\u5f97\u7684\u94fe\u6309\u5230LCA\u7684\u989c\u8272\u5206\u6210 $m$ \u7c7b\u5417\uff1f\u90a3\u6837\u6015\u4e0d\u662f\u4f1a\u65f6\u7a7a\u53cc\u53cc\u7206\u70b8\u3002\n\n\u4e0d\u7528\u3002\u6ce8\u610f\u5230\uff0c\u5bf9\u4e8e\u4e00\u68f5\u5b50\u6811\u6765\u8bf4\uff0c\u4e4b\u524d\u5df2\u6c42\u5f97\u7684\u8def\u5f84\u6743\u503c\u4ec5\u6709\u4e24\u79cd\uff1a\u4e0e\u5b83\u5230LCA\u989c\u8272\u76f8\u540c\u7684\uff0c\u548c\u4e0e\u5b83\u5230LCA\u989c\u8272\u4e0d\u76f8\u540c\u7684\u3002\n\n\u4e8e\u662f\u6709\u4e86\u4e00\u4e2a\u60f3\u6cd5\uff1a**\u5c06\u6240\u6709\u513f\u5b50\u6309\u5230LCA\u989c\u8272\u6392\u5e8f\uff0c\u4ece\u800c\u4f7f\u989c\u8272\u76f8\u540c\u7684\u88ab\u653e\u5728\u4e00\u8d77\u3002**\n\n\u90a3\u4e48\u628a\u5df2\u6c42\u5f97\u7684\u8def\u5f84\u6309\u989c\u8272\u5206\u7c7b\uff1a\u4e0e\u5f53\u524d\u989c\u8272\u4e0d\u540c\u7684\uff0c\u548c\u4e0e\u5f53\u524d\u989c\u8272\u76f8\u540c\u7684\u3002\n\n\u6bcf\u6b21\u82e5\u53d1\u73b0\u989c\u8272\u6539\u53d8\uff0c\u628a\u201c\u76f8\u540c\u7684\u201d\u90a3\u4e00\u7c7b\u5168\u90e8\u5e76\u5230\u201c\u4e0d\u540c\u7684\u201d\u90a3\u4e00\u7c7b\u4e2d\u3002\n\n\u90a3\u4e48\uff0c\u6765\u51b3\u5b9a\u4f7f\u7528\u7684\u6570\u636e\u7ed3\u6784\uff1a\u652f\u6301\u8be2\u95ee\u533a\u95f4\u6700\u503c\uff0c\u652f\u6301\u201c\u5408\u5e76\u201d\u3002\n\n\u7ebf\u6bb5\u6811\u55bd\u3002\n\n\u4e0d\u8fc7\uff0c\u8fd9\u9053\u9898\u6bd4\u8d77\u5408\u5e76\uff0c\u76f4\u63a5\u786c\u6539\u4f1a\u66f4\u4f18\u79c0\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u5408\u5e76\u66f4\u9002\u7528\u4e8e\u52a8\u6001\u5f00\u70b9\u7684\u60c5\u51b5\u3002\n\n\u89e3\u51b3\u4e86\u786e\u5b9aLCA\u60c5\u51b5\u4e0b\u7684\u95ee\u9898\uff0c\u518d\u52a0\u4e0a\u70b9\u5206\u6cbb\uff0c\u5c31\u7b49\u4e8e\u89e3\u51b3\u4e86\u8fd9\u9053\u9898\u3002\n\n\u603b\u590d\u6742\u5ea6 $O(n \\log^2n)$\uff0c\u5728\u6d1b\u8c37\u8fd1\u65e5\u8bc4\u6d4b\u673a\u8dd1\u5f97\u98de\u5feb\u7684\u60c5\u51b5\u4e0b\u62ff\u5230\u4e86\u6700\u4f18\u89e3\u7b2c\u4e8c\u540d\u3002\n\n~~\u7136\u800c\u628a\u4ee5\u524d\u5927\u4f6c$O(n \\log n)$\u7684\u4ee3\u7801\u4ea4\u4e0a\u53bb\u8dd1\u5f97\u66f4\u5feb\u3002~~\n\n$\\texttt{Talk is cheap,show me your code.}$\n\n```\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\n\nconst int maxn=2e5+5,inf=2e9+7;\nint n,m,l,r,col[maxn],T_1[maxn],T_2[maxn];\n\ntemplate<typename T> inline T max(T a,T b){\n\treturn a>b?a:b;\n}\n\ntemplate<typename T> inline T min(T a,T b){\n\treturn a<b?a:b;\n}\n\nstruct IO{\n\tIO(){};char c;\n\tinline char gc(){\n\t\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\t\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n\t}\n\tinline IO&operator>>(int &_){\n\t\t_=0;bool f=1;c=gc();while(c<'0'||c>'9'){if(c=='-') f=0; c=gc();}\n\t\twhile(c>='0'&&c<='9'){_=_*10+c-48;c=gc();}if(!f) _=-_;return *this;\n\t}\n}io;\n\nstruct Sgt{\n\t#define null 0\n\tstruct node{\n\t\tnode *l,*r;int maxx;\n\t\tnode(){l=r=null;maxx=-inf;}\n\t\tvoid push_up(){\n\t\t\tif(!l) return;\n\t\t\tmaxx=max(l->maxx,r->maxx);\n\t\t}\n\t}*rt,*p;\n\tSgt(){rt=null,p=(node*)std::malloc(sizeof(node)*maxn*2);}\n\tnode *build(node *now,int l,int r,int data[]){\n\t\tif(!now) now=p++;\n\t\tif(l==r){now->maxx=data[l];return now;}\n\t\tint mid=(l+r)>>1;\n\t\tnow->l=build(now->l,l,mid,data),now->r=build(now->r,mid+1,r,data);\n\t\treturn now->push_up(),now;\n\t}\n\tvoid modify(int _l,int _r,node *now,int l,int r,int data[]){\n\t\tif(_l>r||_r<l) return;\n\t\tif(l==r){now->maxx=data[l];return;}\n\t\tint mid=(l+r)>>1;\n\t\tmodify(_l,_r,now->l,l,mid,data),modify(_l,_r,now->r,mid+1,r,data);\n\t\treturn now->push_up();//\u6b64\u5904\u610f\u4e3a\u5c06_l,_r\u8303\u56f4\u5185\u7684\u7ed3\u70b9\uff0c\u6309data\u6570\u7ec4\u66f4\u65b0\n\t}\n\tinline int wonder(int _l,int _r,node *now,int l,int r){\n\t\tif(l>_r||r<_l) return -inf;if(_l<=l&&r<=_r) return now->maxx;\n\t\tint mid=(l+r)>>1;\n\t\treturn max(wonder(_l,_r,now->l,l,mid),wonder(_l,_r,now->r,mid+1,r));\n\t}\n}S_1,S_2;\n\nnamespace Tree{\n\tstruct edge{\n\t\tint v,nxt,w;\n\t\tbool operator<(const edge _Comp)const{\n\t\t\treturn w<_Comp.w;\n\t\t}\n\t}e[maxn<<1];\n\tint fir[maxn],edge_cnt;\n\tinline void add_edge(int u,int v,int w){\n\t\te[++edge_cnt].nxt=fir[u];e[edge_cnt].v=v,e[edge_cnt].w=w;fir[u]=edge_cnt;\n\t}\n}using namespace Tree;\n\nint size[maxn],rt,mas;bool vis[maxn];\nint sum_size,dep[maxn],max_dep,dis[maxn];int ans=-inf;//\u8fd9\u91cc\u521d\u59cb\u62100\u7684\u8bdd\uff0c\u606d\u559c\uff0c\u4f60\u4f1a\u88abhack\u6389,\u6bd5\u7adf\u7b54\u6848\u6709\u53ef\u80fd\u4e3a\u8d1f\uff0c\u4e4b\u540e\u521d\u59cb\u5316\u6570\u7ec4\u65f6\u540c\u7406\n\nvoid dfs_rt(int now,int fa){\n\tsize[now]=1;int temp=0;\n\tfor(int i=fir[now];i;i=e[i].nxt){\n\t\tint v=e[i].v;if(v==fa||vis[v]) continue;\n\t\tdfs_rt(v,now);size[now]+=size[v];\n\t\ttemp=max(temp,size[v]);\n\t}\n\ttemp=max(temp,sum_size-size[now]);\n\tif(temp<mas) rt=now,mas=temp;//\u91cd\u5fc3\n}\n\nvoid dfs_dis(int now,int fa,int las_col,int DIS){\n\tmax_dep=max(max_dep,dep[now]);//\u786e\u5b9a\u5f53\u524d\u5b50\u6811\u6df1\u5ea6\n\tdis[dep[now]]=max(dis[dep[now]],DIS);\n\tfor(int i=fir[now];i;i=e[i].nxt){\n\t\tint v=e[i].v;if(v==fa||vis[v]) continue;\n\t\tdep[v]=dep[now]+1;dfs_dis(v,now,e[i].w,DIS+(e[i].w!=las_col?col[e[i].w]:0));\n\t}//\u5f97\u5230\u5f53\u524d\u5b50\u6811\u7684\u94fe\u4fe1\u606f\n}\n\nvoid dfs_lim(int now,int fa,int dep,int &lim){\n\tlim=max(lim,dep);\n\tfor(int i=fir[now];i;i=e[i].nxt){\n\t\tint v=e[i].v;if(v==fa||vis[v]) continue;\n\t\tdfs_lim(v,now,dep+1,lim);\n\t}//\u4e3a\u4e86\u786e\u5b9a\u7ebf\u6bb5\u6811\u8981\u5f00\u591a\u5927\uff0c\u8fd9\u91cc\u7b97\u51fa\u6765\u6700\u957f\u7684\u94fe\u6709\u591a\u957f\n\t//\u8fd9\u4e2a\u51fd\u6570\u5176\u5b9e\u7528dfs_dis\u5b9e\u73b0\uff0c\u4f46\u8fd9\u6837\u5e94\u8be5\u4f1a\u7a0d\u5fae\u5feb\u4e00\u70b9\n}\n\nvoid solve(int now){\n\tstd::vector<edge> ev;int maxx=0,lim=0;\n\tfor(int i=fir[now];i;i=e[i].nxt){\n\t\tev.push_back(e[i]);\n\t}\n\tstd::sort(ev.begin(),ev.end());//\u6309\u989c\u8272\u6392\u5e8f\n\tdfs_lim(now,0,0,lim);lim++;//\u6c42\u6700\u6df1\u5b50\u6811\uff0c\u51b3\u5b9a\u7ebf\u6bb5\u6811\u5927\u5c0f\n\tfor(int i=1;i<=lim;i++) T_1[i]=T_2[i]=dis[i]=-inf;//T_1->\u989c\u8272\u4e0d\u540c\uff0cT_2->\u989c\u8272\u76f8\u540c\n\tS_1.rt=S_1.build(S_1.rt,1,lim,T_1),S_2.rt=S_2.build(S_2.rt,1,lim,T_2);\n\tfor(int i=0,v=ev[0].v;i<ev.size()&&(v=ev[i].v);i++){\n\t\tif(vis[v]) continue;\n\t\tmax_dep=0,dep[v]=1;dfs_dis(v,now,ev[i].w,col[ev[i].w]);\n\t\tif(i&&ev[i].w!=ev[i-1].w){\n\t\t\tfor(int i=1;i<=maxx&&i<=r;i++) T_1[i]=max(T_1[i],T_2[i]),T_2[i]=-inf;\n\t\t\tS_1.modify(1,maxx,S_1.rt,1,lim,T_1),S_2.modify(1,maxx,S_2.rt,1,lim,T_2);//\u786c\u6539\n\t\t\tmaxx=0;\n\t\t}\n\t\tfor(int p=1;p<r&&p<=max_dep;p++){\n\t\t\tint _l=l-p,_r=r-p;if(_l<=0) _l=1;//\u8bf4\u4e0d\u5b9ap>l\u3002\u4e3a\u4ec0\u4e48\u4e0d\u6539\u62100\uff1f\u56e0\u4e3a\u6211\u4f1a\u7279\u5224\u94fe\uff0c\u8fd9\u91cc\u6ca1\u5fc5\u8981\u53bb\u7ba1\u94fe\u7684\u90e8\u5206\n\t\t\tans=max(ans,S_1.wonder(_l,r-p,S_1.rt,1,lim)+dis[p]);\n\t\t\tans=max(ans,S_2.wonder(_l,r-p,S_2.rt,1,lim)+dis[p]-col[ev[i].w]);//\u51cf\u53bb\u5f53\u524d\u989c\u8272\u6743\u503c\n\t\t}\n\t\tfor(int i=1;i<=max_dep&&i<=r;i++) T_2[i]=max(T_2[i],dis[i]),dis[i]=-inf;\n\t\tS_2.modify(1,max_dep,S_2.rt,1,lim,T_2);maxx=max(maxx,max_dep);//maxx\u8868\u793a\u4e0e\u5f53\u524d\u540c\u989c\u8272\u7684\u94fe\u4e2d\uff0c\u6700\u6df1\u7684\u94fe\u6709\u591a\u6df1\n\t}\n\tans=max(ans,S_1.wonder(l,min(r,lim),S_1.rt,1,lim));\n\tans=max(ans,S_2.wonder(l,min(r,lim),S_2.rt,1,lim));//\u7279\u6b8a\u5904\u7406\u94fe\u7684\u60c5\u51b5\uff0c\u6ce8\u610f\u8981\u628ar,lim\u53d6min\n}\n\nvoid divide(int now){\n\tvis[now]=1;solve(now);\n\tfor(int i=fir[now];i;i=e[i].nxt){\n\t\tint v=e[i].v;if(vis[v]) continue;\n\t\tsum_size=size[v],mas=inf;\n\t\tdfs_rt(v,now);divide(rt);\n\t}//\u70b9\u5206\u6cbb\n}\n\nint main(){\n\tio>>n>>m>>l>>r;for(int i=1;i<=m;i++) io>>col[i];\n\tfor(int i=2;i<=n;i++){\n\t\tint u,v,w;io>>u>>v>>w;\n\t\tadd_edge(u,v,w),add_edge(v,u,w);\n\t}\n\tsum_size=n,mas=inf;dfs_rt(1,0);\n\tdivide(rt);printf(\"%d\\n\",ans);\n\treturn 0;\n}\n```",
        "postTime": 1603362554,
        "uid": 101984,
        "name": "Rui_R",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u9009\u4e00\u4e2a\u70b9x\u4f5c\u4e3a\u5206\u6cbb\u4e2d\u5fc3\uff0c\u62fc\u63a5x\u51fa\u53d1\u5230\u5b50\u6811\u5404\u70b9\u7684\uff08\u534a\uff09\u8def\u5f84\u3002\n\n\u5bf9\u4e8e\u62fc\u63a5\u65f6\u4e24\u6bb5\u63a5\u53e3\u5904\uff08\u5373x\u8fde\u51fa\u7684\u90a3\u6761\u8fb9\uff0c\u82e5\u6ca1\u6709\uff0c\u8bbe\u4e3a0\u53f7\u8fb9\uff1a\u989c\u8272\u4e3a0\uff0c\u957f\u5ea6\u4e3a0\uff0c\u5230\u8fbe0\u53f7\u513f\u5b50\uff09\u989c\u8272\u7684\u5f71\u54cd\uff0c\u53ef\u4ee5\u8bb0\u5f55\u6bcf\u6bb5\u7684\u8def\u5f84\u6743\u503c\u3001\u8fb9\u6570\u4ee5\u53ca\u8be5\u6bb5\u7684\u63a5\u53e3\uff0c\u5c06\u6240\u6709\u7684\u8def\u5f84\u4ee5\u63a5\u53e3\u989c\u8272\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u63a5\u53e3\u7f16\u53f7\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\u6392\u5e8f\u3002\u663e\u7136\uff0c\u5bf9\u4e8e\u540c\u4e00\u63a5\u53e3\u7684\u8def\u5f84\u5fc5\u4e3a\u8fde\u7eed\u7684\u4e00\u6bb5\u5e8f\u5217\u3002\n\n\u8fd9\u6837\u679a\u4e3e\u6bcf\u4e2a\u8def\u5f84\uff0c\u627e\u5230\u4e4b\u524d\u51fa\u73b0\u7684\u7b26\u5408\u8fb9\u6570\u548c\u7684\u8981\u6c42\u7684\u6700\u5927\u7684\u8def\u5f84\u6743\u503c\u5373\u53ef\u3002\u7528\u4e24\u9897\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u4e00\u68f5\u7ef4\u62a4\u4e0e\u672c\u8def\u5f84\u4e0d\u540c\u989c\u8272\u7684\uff0c\u4e00\u9897\u7ef4\u62a4\u4e0e\u672c\u8def\u5f84\u989c\u8272\u76f8\u540c\u4f46\u63a5\u53e3\u4e0d\u540c\u7684\uff08\u56e0\u4e3a\u7b80\u5355\u8def\u5f84\u7684\u62fc\u63a5\u8981\u6ee1\u8db3\u4e24\u4e2a\u7aef\u70b9\u4e0d\u5728\u540c\u4e00\u4e2a\u5b50\u6811\u5185\uff09\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 O(nlognlogn)\n\n~~\u5e38\u6570\u5de8\u5927\uff0c\u9700\u8981\u5438\u6c27\u548cc++11 \u5bf9\u4e0d\u8d77\u5440~~\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nconst int M=4e5+10;\nconst int inf=0x3f3f3f3f;\n\nint n,m,L,R;\nint c[N],head[N],to[M],clr[M],last[M];\nint sum,top,rt,fiz[N],siz[N];\nbool ban[N];\n\nstruct Seg {\n\tint dis,num,bel;\n} p[N];\n\nstruct Rmq {\n\t#define ls (x<<1)\n\t#define rs (x<<1|1)\n\tint val[N<<2];\n\tbool tag[N<<2];\n\tvoid clear() {\n\t\tval[1]=-inf;\n\t\ttag[1]=1;\n\t}\n\tvoid pushDown(int x) {\n\t\tval[ls]=-inf,tag[ls]=1;\n\t\tval[rs]=-inf,tag[rs]=1;\n\t\ttag[x]=0;\n\t}\n\tvoid modify(int x,int l,int r,int p,int w) {\n\t\tif(l==r) return void(val[x]=w);\n\t\tint mid=(l+r)>>1;\n\t\tval[x]=max(val[x],w);\n\t\tif(tag[x]) pushDown(x);\n\t\tif(p<=mid) modify(ls,l,mid,p,w);\n\t\telse modify(rs,mid+1,r,p,w);\n\t}\n\tint query(int x,int l,int r,int L,int R) {\n\t\tif(L<=l && r<=R) return val[x];\n\t\tint mid=(l+r)>>1, ret=-inf;\n\t\tif(tag[x]) return ret;\n\t\tif(L<=mid) ret=max(ret,query(ls,l,mid,L,R));\n\t\tif(mid<R) ret=max(ret,query(rs,mid+1,r,L,R));\n\t\treturn ret;\n\t}\n\tinline void modify(int p,int w) {\n\t\tmodify(1,1,n+1,p+1,w);\n\t}\n\tinline int query(int L,int R) {\n\t\tif(R<L || R<0) return -inf;\n\t\treturn query(1,1,n+1,L+1,R+1);\n\t}\n\t#undef ls \n\t#undef rs\n} A,B;\n\nvoid addEdge(int x,int y,int c) {\n\tstatic int cnt=0;\n\tto[++cnt]=y;\n\tclr[cnt]=c;\n\tlast[cnt]=head[x];\n\thead[x]=cnt;\n}\nvoid getRoot(int x,int pa) {\n\tfiz[x]=0,siz[x]=1;\n\tfor(int i=head[x]; i; i=last[i]) {\n\t\tif(to[i]==pa||ban[to[i]]) continue;\n\t\tgetRoot(to[i],x);\n\t\tsiz[x]+=siz[to[i]];\n\t\tfiz[x]=max(fiz[x],siz[to[i]]);\n\t}\n\tfiz[x]=max(fiz[x],sum-siz[x]);\n\tif(fiz[x]<fiz[rt]) rt=x;\n} \nint ans=-2e9;\nvoid getDis(int x,int pa,int dis,int num,int pClr,int bel) {\n\tp[++top]=(Seg){dis,num,bel};\n\tfor(int i=head[x]; i; i=last[i]) {\n\t\tif(to[i]==pa||ban[to[i]]) continue;\n\t\tif(pClr==clr[i]) getDis(to[i],x,dis,num+1,clr[i],bel);\n\t\telse getDis(to[i],x,dis+c[clr[i]],num+1,clr[i],bel);\n\t}\n}\nvoid calc(int x) {\n\tp[top=1]=(Seg){0,0,0};\n\tfor(int i=head[x]; i; i=last[i]) {\n\t\tif(ban[to[i]]) continue;\n\t\tgetDis(to[i],x,c[clr[i]],1,clr[i],i);\n\t}\n\tsort(p+1,p+top+1,[=](Seg x,Seg y){\n\t\tif(clr[x.bel]!=clr[y.bel]) return clr[x.bel]<clr[y.bel];\n\t\treturn x.bel<y.bel; \n\t});\n\tA.clear();\n\tB.clear(); \n\tfor(int l=1,r; l<=top; l=r+1) {\n\t\tfor(r=l; r<top && clr[p[l].bel]==clr[p[r+1].bel]; ++r);\n\t\tfor(int x=l,y; x<=r; x=y+1) {\n\t\t\tfor(y=x; y<r && p[x].bel==p[y+1].bel; ++y);\n\t\t\tif(x!=l) for(int i=x; i<=y; ++i) \n\t\t\t\tans=max(ans,p[i].dis+B.query(L-p[i].num,R-p[i].num)-c[clr[p[i].bel]]);\n\t\t\tfor(int i=x; i<=y; ++i) B.modify(p[i].num,p[i].dis);\n\t\t}\n\t\tB.clear();\n\t\tif(l!=1) for(int i=l; i<=r; ++i) \n\t\t\tans=max(ans,p[i].dis+A.query(L-p[i].num,R-p[i].num));\n\t\tfor(int i=l; i<=r; ++i) A.modify(p[i].num,p[i].dis);\n\t}\n}\nvoid solveAt(int x) {\n\tban[x]=true;\n\tcalc(x);\n\tfor(int i=head[x]; i; i=last[i]) {\n\t\tif(ban[to[i]]) continue;\n\t\trt=0;\n\t\tsum=siz[to[i]];\n\t\tgetRoot(to[i],x);\n\t\tsolveAt(rt);\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d%d%d\",&n,&m,&L,&R);\n\tfor(int i=1; i<=m; ++i) scanf(\"%d\",&c[i]);\n\tfor(int x,y,c,i=n; --i; ) {\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\taddEdge(x,y,c);\n\t\taddEdge(y,x,c);\n\t}\n\trt=0;\n\tsum=n;\n\tfiz[0]=2e9;\n\tgetRoot(1,0);\n\tsolveAt(rt);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n} \n```",
        "postTime": 1546777196,
        "uid": 125139,
        "name": "nosta",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u4ee5\u8282\u70b9 1 \u4e3a\u6839\u5efa\u6811\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u8282\u70b9 p \uff0c\u6c42\u51fa\u6240\u6709\u4ee5\u8282\u70b9 p \u4e3a\u8f6c\u6298\u70b9\u7684\u6700\u5927\u6743\u503c\u8def\u5f84\u3002\n\n\n\u5bf9\u6bcf\u4e2a\u8282\u70b9 x \uff0c\u8ba1\u7b97\u8282\u70b9\u6df1\u5ea6 d[x] \uff0c\u548c\u7236\u8282\u70b9\u7684\u8fb9\u7684\u989c\u8272 e[x] \u548c 1 \u5230 x \u7684\u8def\u5f84\u6743\u503c s[x]\uff08\u540c\u9898\u4e2d\u6240\u5b9a\u4e49\uff09\u3002\u7136\u540e\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u5305\u542b\u81ea\u5df1\u5b50\u6811\u6240\u6709\u8282\u70b9\u7684\u3001\u6309 d[x] \u6392\u5e8f\u7684\u5e73\u8861\u6811\u3002\u5982\u679c\u4e0d\u8003\u8651\u5408\u5e76\u540c\u989c\u8272\u6bb5\u7684\u95ee\u9898\uff0c\u90a3\u4e48\u53ef\u4ee5\u7528\u542f\u53d1\u5f0f\u5408\u5e76\uff08\u540e\u9762\u7684\u5408\u5e76\u90fd\u4e3a\u542f\u53d1\u5f0f\u5408\u5e76\uff09\u76f4\u63a5\u5904\u7406\uff0c\u5373\u62c6\u8282\u70b9\u4e2a\u6570\u5c11\u7684\u5e73\u8861\u6811\uff0c\u7136\u540e\u5bf9\u8fd9\u4e9b\u8282\u70b9\u67e5\u8be2\u5b8c\u4e4b\u540e\uff0c\u5168\u90e8\u63d2\u5165\u53e6\u4e00\u4e2a\u5e73\u8861\u6811\u4e2d\u3002\n\n\n\u5728\u8003\u8651\u540c\u989c\u8272\u6bb5\u7684\u60c5\u51b5\u4e0b\uff0c\u9996\u5148\u6211\u4eec\u5148\u628a\u76f8\u540c\u989c\u8272\uff08\u8282\u70b9 p \u548c\u5b50\u8282\u70b9\u7684\u8fb9\u7684\u989c\u8272\uff09\u5b50\u8282\u70b9\u5408\u5e76\u3002\u8bbe\u8282\u70b9 x \u548c y \u5206\u522b\u6765\u81ea\u540c\u989c\u8272 z \u7684\u4e0d\u540c\u5b50\u8282\u70b9\u7684\u6811\uff0c\u90a3\u4e48\u8def\u5f84 x \u2013 y \u7684\u6743\u503c\u4e3a (s[x] \u2013 s[p]) + (s[y] \u2013 s[p]) \u2013 c[z]\uff0c\u5176\u4e2d s[x] \u2013 s[p] \u8868\u793a x \u2013 p \u7684\u8def\u5f84\u6743\u503c\uff0c\u7531\u4e8e\u989c\u8272 z \u88ab\u52a0\u4e86\u4e24\u904d\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u6389\u4e00\u904d\u3002\u4f46\u662f\u5982\u679c\u989c\u8272 z \u548c e[p] \u76f8\u540c\uff0c\u90a3\u4e48 s[x] \u2013 s[p] \u5c31\u4e0d\u5305\u542b\u8fd9\u90e8\u5206 c[z] \u4e86\uff0c\u6240\u4ee5\u9700\u8981\u989d\u5916\u52a0\u4e0a\u4e00\u6b21\uff0c\u56e0\u6b64\u8fd9\u4e2a\u60c5\u51b5 x \u2013 y \u7684\u8def\u5f84\u6743\u503c\u5c31\u53d8\u4e3a (s[x] \u2013 s[p]) + (s[y] \u2013 s[p]) + c[z]\u3002\n\n\n\u5408\u5e76\u5b8c\u540c\u989c\u8272\u7684\u4e4b\u540e\uff0c\u518d\u5c06\u4e0d\u540c\u989c\u8272\u7684\u5408\u5e76\u3002\u4f46\u662f\u4e5f\u8981\u989d\u5916\u8003\u8651\u989c\u8272 e[p]\u3002\u56e0\u4e3a e[p] \u7684\u90a3\u4e9b\u8282\u70b9\uff0c\u9700\u8981\u989d\u5916\u52a0\u4e00\u6b21 c[e[p]]\u3002\u5904\u7406\u65b9\u6cd5\u5c31\u662f\u628a\u8fd9\u4e2a\u989c\u8272\u7684\u6700\u540e\u5408\u5e76\u8fdb\u53bb\u3002\n\n\n\u65f6\u95f4\u590d\u6742\u5ea6 O(n log^2 n)\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 O(n)\u3002\n",
        "postTime": 1510324218,
        "uid": 54522,
        "name": "\u51b7\u6708\u51b0\u77b3",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "[\u4e5f\u8bb8\u4f1a\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://www.cnblogs.com/A2484337545/p/14566431.html)\n\n\n\u9996\u5148\u5410\u69fd\u4e00\u4e0b\u81ea\u5df1\u521a\u5f00\u59cb\u7406\u89e3\u9519\u9898\u610f\u4e86\uff0c\u4ee5\u4e3a\u9898\u76ee\u4e2d\u7684\u6309\u987a\u5e8f\u53ef\u4ee5\u6309\u4efb\u610f\u987a\u5e8f.\n\n\u8fd9\u9053\u9898\u662f\u4e00\u9053\u5173\u4e8e\u6811\u4e0a\u8def\u5f84\u7684\u95ee\u9898\uff0c\u5f88\u660e\u663e\u53ef\u4ee5\u60f3\u5230\u70b9\u5206\u6cbb\uff0c\u8003\u8651\u5f53\u524d\u7684\u5206\u6cbb\u4e2d\u5fc3\u4e3ax.\n\n\u90a3\u4e48\u7b54\u6848\u53ef\u4ee5\u5206\u4e3a\u4e0b\u9762\u56db\u79cd\u60c5\u51b5\n\n1.\u5e8f\u5217\u4e00\u7aef\u4e3ax, \u53e6\u4e00\u7aef\u5728\u5b50\u6811\u5185.\n\n2.\u5e8f\u5217\u4e24\u7aef\u5728\u4e24\u4e2a\u4e0d\u540c\u7684\u5b50\u6811\u5185,\u4e14\u4e24\u4e2a\u5b50\u6811\u5230\u5206\u6cbb\u4e2d\u5fc3\u7684\u989c\u8272\u76f8\u540c\n\n3.\u5e8f\u5217\u4e24\u7aef\u5728\u4e24\u4e2a\u4e0d\u540c\u7684\u5b50\u6811\u5185,\u4e14\u4e24\u4e2a\u5b50\u6811\u5230\u5206\u6cbb\u4e2d\u5fc3\u7684\u989c\u8272\u4e0d\u540c\n\n4.\u5e8f\u5217\u4e24\u7aef\u5728\u4e00\u4e2a\u5b50\u6811\u5185\n\n\u5bf9\u4e8e\u7b2c4\u79cd\u60c5\u51b5,\u5f88\u597d\u89e3\u51b3,\u76f4\u63a5\u9012\u5f52\u5c31\u884c,\u7b2c1\u79cd\u60c5\u51b5\u4e5f\u662f,\u91cd\u70b9\u662f\u7b2c2\u79cd\u548c\u7b2c3\u79cd.\n\n\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u5c06\u6240\u6709\u53ef\u80fd\u7684\u60c5\u51b5\u90fd\u5b58\u8d77\u6765,\u6240\u4ee5\u8003\u8651\u7528\u7ebf\u6bb5\u6811, x\u7684\u6240\u6709\u513f\u5b50\u6309\u8fb9\u7684\u989c\u8272\u6392\u5e8f,\u7136\u540e\u518d\u6765\u679a\u4e3e,\n\n\u90a3\u4e48\u5c31\u53ea\u9700\u8981\u5f00\u4e24\u68f5\u7ebf\u6bb5\u6811\u4e86,\u4e00\u68f5\u5b58\u4e86\u4e4b\u524d\u7684\u6709\u513f\u5b50,\u4e00\u68f5\u53ea\u5b58\u4e86\u5f53\u524d\u989c\u8272\u7684\u513f\u5b50,\u5728 dfs\u7684\u65f6\u5019\u5206\u522b\u67e5\u8be2\u4e00\u4e0b\u5c31\u662f\u4e86,\n\n\u53ea\u9700\u8981\u5728\u67e5\u8be2\u5b58\u7684\u662f\u5f53\u524d\u989c\u8272\u7684\u513f\u5b50\u65f6\u9700\u8981\u51cf\u53bb\u4e00\u4e2aval.\n\n\u4ee3\u7801\n\n```\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#define INF (0x3f3f3f3f)\nusing namespace std;\nconst int N = 2e5 + 5;\ntypedef pair<int, int> PII;\n\nint n, m, ql, qr;\nint idx, rt1, rt2, tot, val[N], ans = -INF;\nint head[2 * N], net[2 * N], edge[2 * N], ver[2 * N];\nstruct tree\n{\n    int l, r, v, maxn;\n    void init()\n    {\n        l = r = 0;\n        v = maxn = -INF;\n    }\n} tr[80 * N];\nbool st[N];\n\nvoid pushup(int p)\n{\n    tr[p].maxn = max(tr[tr[p].l].maxn, tr[tr[p].r].maxn);\n}\n\nint merge(int p, int q, int l, int r)\n{\n    if (!p || !q)\n        return p + q;\n    if (l == r)\n    {\n        tr[p].maxn = tr[p].v = max(tr[p].v, tr[q].v);\n        tr[q].init();\n        return p;\n    }\n    int mid = (l + r) >> 1;\n    tr[p].l = merge(tr[p].l, tr[q].l, l, mid);\n    tr[p].r = merge(tr[p].r, tr[q].r, mid + 1, r);\n    tr[q].init();\n    pushup(p);\n    return p;\n}\n\nvoid insert(int p, int l, int r, int d, int x)\n{\n    if (l == r)\n    {\n        tr[p].maxn = tr[p].v = max(tr[p].v, x);\n        return;\n    }\n    int mid = (l + r) >> 1;\n    if (d <= mid)\n    {\n        if (!tr[p].l)\n            tr[p].l = ++tot;\n        insert(tr[p].l, l, mid, d, x);            \n    }\n    else\n    {\n        if (!tr[p].r)\n            tr[p].r = ++tot;\n        insert(tr[p].r, mid + 1, r, d, x);        \n    }\n    pushup(p);\n}\n\nint query(int p, int L, int R, int l, int r)\n{\n    if (L >= l && R <= r)\n        return tr[p].maxn;\n    int mid = (L + R) >> 1, res = -INF;\n    if (l <= mid && tr[p].l)\n        res = max(res, query(tr[p].l, L, mid, l, r));\n    if (r > mid && tr[p].r)\n        res = max(res, query(tr[p].r, mid + 1, R, l, r));\n    return res;\n}\n\nvoid add(int a, int b, int c)\n{\n    net[++idx] = head[a], ver[idx] = b;\n    edge[idx] = c, head[a] = idx;\n}\n\nint get_siz(int u, int fa)\n{\n    int res = 1;\n    for (int i = head[u]; i; i = net[i])\n        if (ver[i] != fa && !st[ver[i]])\n            res += get_siz(ver[i], u);\n    return res;\n}\n\nint get_wc(int u, int fa, int tot, int &wc)\n{\n    int sum = 1, ms = 0;\n    for (int i = head[u]; i; i = net[i])\n    {\n        int v = ver[i];\n        if (st[v] || v == fa)\n            continue;\n        int t = get_wc(v, u, tot, wc);\n        sum += t;\n        ms = max(ms, t);\n    }\n    ms = max(ms, tot - sum);\n    if (ms <= tot / 2)\n        wc = u;\n    return sum;\n}\n\nvoid get_dist(int rt, int u, int fa, int vals, int len, int last, int ned)\n{\n    if (len > qr)\n        return;\n    ans = max(ans, query(rt1, 1, qr, max(1, ql - len), max(1, qr - len))  + vals - ned);\n    ans = max(ans, query(rt2, 1, qr, max(1, ql - len), max(1, qr - len)) + vals);\n    if (len >= ql)\n        ans = max(ans, vals);\n    insert(rt, 1, qr, len, vals);\n    for (int i = head[u]; i; i = net[i])\n    {\n        int v = ver[i];\n        if (v == fa || st[v])\n            continue;\n        if (edge[i] == last)\n            get_dist(rt, v, u, vals, len + 1, last, ned);\n        else\n            get_dist(rt, v, u, vals + val[edge[i]], len + 1, edge[i], ned);\n    }\n}\n\nvoid clear(int x)\n{\n    if (tr[x].l)\n        clear(tr[x].l);\n    if (tr[x].r)\n        clear(tr[x].r);\n    tr[x].init();\n}\n\nvoid calc(int u)\n{\n    get_wc(u, -1, get_siz(u, -1), u);\n    priority_queue<PII> q;\n    st[u] = true;\n    for (int i = head[u]; i; i = net[i])\n    {\n        int v = ver[i];\n        if (st[v])\n            continue;\n        q.push(make_pair(edge[i], v));\n    }\n    int last = 0;\n    rt2 = ++tot;\n    while (!q.empty())\n    {\n        int v = q.top().second, tp = q.top().first;\n        q.pop();   \n        if (tp != last)\n        {\n            merge(rt2, rt1, 1, qr);\n            rt1 = ++tot;\n        }\n        int rt = ++tot;    \n        get_dist(rt, v, u, val[tp], 1, tp, val[tp]);\n        merge(rt1, rt, 1, qr);\n        last = tp;\n    }\n    tot = 0, clear(rt1), clear(rt2);\n    for (int i = head[u]; i; i = net[i])\n        if (!st[ver[i]])\n            calc(ver[i]);\n}\n\nint main()\n{\n    for (int i = 0; i < 10 * N; i++)\n        tr[i].v = tr[i].maxn = -INF;\n    scanf(\"%d%d%d%d\", &n, &m, &ql, &qr);\n    for (int i = 1; i <= m; i++)\n        scanf(\"%d\", &val[i]);\n    for (int i = 1; i < n; i++)\n    {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        add(a, b, c), add(b, a, c);\n    }\n    calc(1);\n    printf(\"%d\", ans);\n    return 0;\n}\n```\n",
        "postTime": 1616913628,
        "uid": 277863,
        "name": "BzhH",
        "ccfLevel": 6,
        "title": "\u9898\u89e3P3714 [BJOI2017]\u6811\u7684\u96be\u9898"
    },
    {
        "content": ">\u7ed9\u5b9a\u4e00\u68f5\u8fb9\u6709\u8272\u7684\u6811\uff0c\u5b9a\u4e49\u4e00\u6761\u8def\u5f84\u6743\u503c\u4e3a\u8def\u5f84\u4e0a**\u4f9d\u5e8f\u7ecf\u8fc7\u7684\u540c\u8272\u6bb5\u96c6\u5408\u7684\u989c\u8272\u6743\u503c\u4e4b\u548c**\n>\n>\u6c42\u6811\u4e0a\u957f\u5ea6$\\in[l,r]$\u7684\u8def\u5f84\u7684\u6743\u503c\u6700\u5927\u503c\n\n\u8def\u5f84\u95ee\u9898\u4e14\u5bf9\u957f\u5ea6\u6709\u9650\u5236\u6211\u4eec\u76f4\u63a5\u8003\u8651\u70b9\u5206\u6cbb\uff0c\u6ce8\u610f\u5230\u6211\u4eec\u6c42\u5206\u6cbb\u4e2d\u5fc3\u5230\u4e00\u4e2a\u70b9\u8def\u5f84\u7684\u8272\u6bb5\u8d21\u732e\u548c\u662f\u5f88\u597d\u6c42\u7684\n\n\u5206\u6790\u62fc\u63a5\u8def\u5f84\u7684\u8fc7\u7a0b\uff0c\u6211\u4eec\u79f0$x$\u5230$rt$\u8def\u5f84\u4e0a\u5012\u6570\u7b2c\u4e8c\u4e2a\u70b9$y$\u4e3a$x$\u4ece\u5c5e\u7684\u652f\u7cfb$bel_x$,$x$\u4ece\u5c5e\u70b9\u5230$rt$\u7684\u989c\u8272\u662f$belc_x$\n\n- $rt\\to x$\u4e0e$rt\\to y$\u4ece\u5c5e\u4e8e\u4e0d\u540c\u7684\u7956\u5148\uff0c\u4e0d\u4f1a\u8d21\u732e\n- $rt\\to x$\u4e0e$rt\\to y$\u4ece\u5c5e\u76f8\u540c\u4f46\u4ece\u5c5e\u989c\u8272\u4e0d\u540c\u76f4\u63a5\u62fc\u63a5\n- $rt\\to x$\u4e0e$rt\\to y$\u4ece\u5c5e\u76f8\u540c\u4f46\u4ece\u5c5e\u989c\u8272\u76f8\u540c\u51cf\u6389\u591a\u4f59\u8d21\u732e\u540e\u62fc\u63a5\n\n\u8003\u8651\u53d6\u51fa\u5206\u6cbb\u4e2d\u5fc3\u7684\u5404\u652f\u8109\u540e\u6309\u7167\u4ece\u5c5e\u989c\u8272\u5206\u5f00\uff0c\u505a\u4e00\u7c7b\u8d21\u732e\uff0c\u518d\u8fdb\u4e00\u6b65\u6309\u4ece\u5c5e\u70b9\u5206\u5f00\u505a\u4e8c\u7c7b\u8d21\u732e\n\n\u4e3a\u4ec0\u4e48\u6b63\u786e?\u6211\u4eec\u9996\u5148\u505a\u5f3a\u5236\u8ba9\u989c\u8272\u4e0d\u540c\u7684\u8d21\u732e\uff0c\u8fd9\u90e8\u5206\u662f\u7b97\u5168\u4e86\u7684\n\n\u7136\u540e\u505a\u540c\u8272\u5757\u5185\u90e8\u8de8\u8d8a\u7684\u8d21\u732e\u56e0\u4e3a\u6211\u4eec\u662f\u5148\u5b9a\u7684\u8981\u88ab\u51cf\u6389\u7684$-v_{belc}$\u6240\u4ee5\u4e5f\u662f\u72ec\u7acb\u7684\u6700\u503c\n\n\u5b9e\u73b0\u4e0a\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5728$2,3$\u7c7b\u8d21\u732e\u4e2d\u67d0\u4e2a\u957f\u5ea6\u8303\u56f4\u5185\u7684\u8def\u5f84\u6700\u5927\u503c\u66f4\u65b0\u5373\u53ef\n\n\u9644\u4e00\u4e2a\u6570\u636e\n\n```\n61 23 1 59\n5477 -1582 6699 7154 -779 -1201 -4225 3243 -4340 8812 8244 -9545 -5144 8948 -2165 -8895 381 -7111 8390 947 -5123 -4004 -9014 \n2 1 2\n3 1 1\n4 3 5\n5 2 21\n6 5 14\n7 1 1\n8 4 19\n9 1 21\n10 6 1\n11 5 21\n12 8 19\n13 4 17\n14 11 11\n15 2 8\n16 11 5\n17 14 11\n18 17 11\n19 17 6\n20 13 6\n21 5 6\n22 11 19\n23 2 16\n24 7 6\n25 13 20\n26 5 19\n27 17 5\n28 1 12\n29 23 21\n30 25 14\n31 29 10\n32 31 21\n33 8 11\n34 22 13\n35 8 20\n36 21 20\n37 2 19\n38 32 16\n39 17 10\n40 34 3\n41 6 14\n42 26 5\n43 8 6\n44 2 12\n45 17 18\n46 10 21\n47 20 22\n48 28 21\n49 34 12\n50 16 19\n51 46 17\n52 51 21\n53 52 16\n54 50 5\n55 50 19\n56 46 5\n57 48 10\n58 49 4\n59 55 2\n60 56 16\n61 51 1\n\n```\n",
        "postTime": 1599896952,
        "uid": 40629,
        "name": "zzw4257",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "\u4e0e\u591a\u6570\u5927\u4f6c\u5355\u8c03\u961f\u5217\u7684\u65b9\u6cd5\u4e0d\u540c\uff0c\n\n\u672c\u7bc7\u9898\u89e3\u8fd0\u7528\u70b9\u5206\u6cbb+\u7ebf\u6bb5\u6811\u901a\u8fc7\u4e86\u6b64\u9898\u3002\n\n---\n\n### $\\text{Solution}$\n\n\u9898\u76ee\u8981\u6c42\u5f97\u5230\u6240\u6709\u957f\u5ea6\u5728 $[l,r]$ \u8303\u56f4\u5185\u7684\u8def\u5f84\u7684\u6743\u503c\u6700\u5927\u503c\u3002\n\n\u8003\u8651\u5728\u8def\u5f84\u7684\u67d0\u4e00\u70b9\u4e0a\u8ba1\u7b97\u7b54\u6848\uff0c\u76f4\u63a5\u4e0a\u70b9\u5206\u6cbb\u3002\n\n\u5728\u5f53\u524d\u70b9\u5206\u6cbb\u7684\u8fde\u901a\u5757\u4e2d\uff0c\u6211\u4eec\u9700\u8981\u7b97\u51fa\u91cd\u5fc3 $h$ \u7684\u4e0d\u540c\u5b50\u6811\u76f4\u63a5\u8def\u5f84\u7684\u6700\u5927\u503c\n\n\u8003\u8651\u5c06\u8def\u5f84\u4ece $h$ \u5288\u5f00\uff0c\u62c6\u5206\u4e3a\u4e24\u6761\u94fe\n\n\u5bf9\u4e8e\u4e00\u6761\u94fe\u7684\u6743\u503c\u6211\u4eec\u662f\u597d\u7ef4\u62a4\u7684\uff0c\u66b4\u529bdfs\u4e0b\u53bb\u8ba1\u7b97\u5373\u53ef\n\n\u53d1\u73b0\u6211\u4eec\u552f\u4e00\u9700\u8981\u8003\u8651\u7684\u662f\u4e24\u6761\u94fe\u9876\u8fb9\u989c\u8272\u4e00\u6837\u65f6\uff0c\u6211\u4eec\u9700\u8981\u51cf\u53bb\u4e00\u904d\u591a\u7b97\u7684\u6743\u503c\n\n\u540c\u65f6\uff0c\u6211\u4eec\u4e5f\u80fd\u53d1\u73b0\u4e00\u4e2a\u663e\u7136\u7684\u7ed3\u8bba **\u540c\u5b50\u6811\u5185\u7684\u94fe\u9876\u8fb9\u989c\u8272\u76f8\u540c**\n\n\u628a\u4e0d\u540c\u7684\u5b50\u6811\u6309**\u94fe\u9876\u8fb9\u989c\u8272**\uff0c\u94fe\u9876\u8fb9\u989c\u8272\u76f8\u540c\u6309**\u94fe\u5c5e\u5b50\u6811\u7f16\u53f7**\u6392\u5e8f\n\n>\u6211\u4eec\u8003\u8651\u5c06\u4e00\u6761\u8def\u5f84\u5728\u6392\u5e8f\u540e\u6392\u540d\u9760\u540e\u7684\u94fe\u4e0a\u8ba1\u7b97\n\n>\u8003\u8651\u5bf9\u4e8e\u6bcf\u4e00\u6761\u94fe\u53ea\u9700\u8ba1\u7b97\u53e6\u4e00\u6761\u6743\u503c\u6700\u957f\u94fe\u4e0e\u5176\u62fc\u63a5\uff0c\u7279\u6b8a\u8003\u8651\u94fe\u9876\u989c\u8272\u76f8\u540c\u94fe\n\n\u628a\u6bcf\u4e2a\u5b50\u6811\u626b\u4e00\u904d\uff0c\u540c\u65f6\u7ef4\u62a4\u4e24\u9897\u4ee5\u94fe\u957f\u4e3a\u4e0b\u6807\u7684\u7ebf\u6bb5\u6811\n\n$a_x$ \u8868\u793a\u4ee5 $x$\u4e3a\u94fe\u5c3e\u7684\u94fe\u6743\u503c\n\n$b_x$ \u8868\u793a\u4ee5 $x$\u4e3a\u94fe\u5c3e\u7684\u94fe\u5c5e\u5b50\u6811\n\n$c_x$ \u8868\u793a\u4ee5 $x$\u4e3a\u94fe\u5c3e\u7684\u94fe\u9876\u8fb9\n\n$d_x$ \u8868\u793a\u4ee5 $x$\u4e3a\u94fe\u5c3e\u7684\u94fe\u957f\n\n\u679a\u4e3e\u5230 $u$ \u5b50\u6811\u5185\u7684\u70b9 $x$ \u65f6\n\n\u7b2c\u4e00\u9897\u7ebf\u6bb5\u6811\u8bb0\u5f55\u6240\u6709\u94fe\u9876\u8fb9\u989c\u8272**\u5c0f\u4e8e** $c_x$ \u7684\u6240\u6709\u94fe\u4fe1\u606f\n\n\u5bf9\u4e8e\u7b2c\u4e00\u9897\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u76f4\u63a5\u67e5\u4e0b\u6807\u5728 $[l-d_x,r-d_x]$ \u7684\u94fe\u6743\u503c\u6700\u5927\u503c\u5373\u53ef\uff0c\u5c06\u5176\u4e0e $x$ \u94fe\u62fc\u63a5\n\n\u7b2c\u4e8c\u9897\u7ebf\u6bb5\u6811\u8bb0\u5f55\u6240\u6709\u94fe\u9876\u8fb9\u989c\u8272**\u7b49\u4e8e** $c_x$\u4e14\u94fe\u5c5e\u5b50\u6811\u7f16\u53f7\u5c0f\u4e8e $b_x$ \u7684\u6240\u6709\u94fe\u4fe1\u606f\n\n\u5bf9\u4e8e\u7b2c\u4e8c\u9897\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u540c\u7b2c\u4e00\u9897\u7ebf\u6bb5\u6811\uff0c\u6700\u540e\u51cf\u6389\u4e00\u4e2a\u989c\u8272 $c_x$ \u7684\u6743\u503c\u5373\u53ef\n\n\u8bb0\u5f97\u6bcf\u5c42\u70b9\u5206\u6cbb\u5e94\u6e05\u7a7a\u7ebf\u6bb5\u6811\uff0c\u5177\u4f53\u5b9e\u73b0\u53ef\u53c2\u8003\u4ee3\u7801\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(nlog_2^2n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2e5+5,inf=2e9+1;\nstruct Edge{\n\tint to,w,nxt;\n}e[2*maxn];\nint cnt;\nint head[maxn];\nint n,p,L,R,ans;\nint C[maxn];\nint read(){\n\tint x=0,y=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n\treturn x*y;\n}\nvoid add(int u,int v,int w){\n\te[cnt].to=v;\n\te[cnt].w=w;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt++;\n\treturn ;\n}\nint t1[maxn<<2],t2[maxn<<2];\nvoid build(int k,int l,int r){\n\tt1[k]=t2[k]=-inf;\n\tif(l==r)return ;\n\tint mid=l+((r-l)>>1);\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\treturn ;\n}\nvoid modify1(int k,int l,int r,int x,int val){\n\tif(l>x||r<x)return ;\n\tif(l==r){t1[k]=max(t1[k],val);return ;}\n\tint mid=l+((r-l)>>1);\n\tmodify1(k<<1,l,mid,x,val);\n\tmodify1(k<<1|1,mid+1,r,x,val);\n\tt1[k]=max(t1[k<<1],t1[k<<1|1]);\n\treturn ;\n}\nvoid modify2(int k,int l,int r,int x,int val){\n\tif(l>x||r<x)return ;\n\tif(l==r){t2[k]=max(t2[k],val);return ;}\n\tint mid=l+((r-l)>>1);\n\tmodify2(k<<1,l,mid,x,val);\n\tmodify2(k<<1|1,mid+1,r,x,val);\n\tt2[k]=max(t2[k<<1],t2[k<<1|1]);\n\treturn ;\n}\nvoid clear1(int k,int l,int r,int x){\n\tif(l>x||r<x)return ;\n\tif(l==r){t1[k]=-inf;return ;}\n\tint mid=l+((r-l)>>1);\n\tclear1(k<<1,l,mid,x);\n\tclear1(k<<1|1,mid+1,r,x);\n\tt1[k]=-inf;\n\treturn ;\n}\nvoid clear2(int k,int l,int r,int x){\n\tif(l>x||r<x)return ;\n\tif(l==r){t2[k]=-inf;return ;}\n\tint mid=l+((r-l)>>1);\n\tclear2(k<<1,l,mid,x);\n\tclear2(k<<1|1,mid+1,r,x);\n\tt2[k]=-inf;\n\treturn ;\n}\nint query1(int k,int l,int r,int x,int y){\n\tif(l>y||r<x)return -inf;\n\tif(l>=x&&r<=y)return t1[k];\n\tint mid=l+((r-l)>>1);\n\treturn max(query1(k<<1,l,mid,x,y),query1(k<<1|1,mid+1,r,x,y));\n}\nint query2(int k,int l,int r,int x,int y){\n\tif(l>y||r<x)return -inf;\n\tif(l>=x&&r<=y)return t2[k];\n\tint mid=l+((r-l)>>1);\n\treturn max(query2(k<<1,l,mid,x,y),query2(k<<1|1,mid+1,r,x,y));\n}\n//\u7ebf\u6bb5\u6811\nint h,m;\nbool vis[maxn];\nint siz[maxn];\nvoid dfs1(int x,int fa){\n\tsiz[x]=1;\n\tfor(int i=head[x];i!=-1;i=e[i].nxt){\n\t\tint tmp=e[i].to;\n\t\tif(tmp==fa||vis[tmp])continue;\n\t\tdfs1(tmp,x);\n\t\tsiz[x]+=siz[tmp];\n\t}\n\treturn ;\n}\nvoid dfs2(int x,int fa){\n\tbool flag=1;\n\tfor(int i=head[x];i!=-1;i=e[i].nxt){\n\t\tint tmp=e[i].to;\n\t\tif(tmp==fa||vis[tmp])continue;\n\t\tdfs2(tmp,x);\n\t\tif(siz[tmp]>m/2)flag=0;\n\t}\n\tif(flag&&m-siz[x]<=m/2)h=x;\n\treturn ;\n}\n//\u6c42\u91cd\u5fc3\nstruct node{\n\tint a,b,c,d;\n\t//a\uff1a\u94fe\u6743\u503c\uff0cb\uff1a\u5c5e\u4e8e\u54ea\u4e2a\u5b50\u6811\uff0cc\uff1a\u94fe\u9876\u989c\u8272\uff0cd\uff1a\u94fe\u957f \n\tbool operator <(node i)const{\n\t\treturn c==i.c?b<i.b:c<i.c;\n\t}\n}g[maxn];\nint val,dis,len;\nvoid dfs4(int x,int fa,int b,int c,int W,int fW){\n\tif(W!=fW)val+=C[W];\n\tdis++;\n\tg[++len]=(node){val,b,c,dis};\n\tfor(int i=head[x];i!=-1;i=e[i].nxt){\n\t\tint tmp=e[i].to;\n\t\tif(tmp==fa||vis[tmp])continue;\n\t\tdfs4(tmp,x,b,c,e[i].w,W);\n\t}\n\tif(W!=fW)val-=C[W];\n\tdis--;\n   //\u56de\u6eaf\n\treturn ;\n}\n//\u63d0\u51fa\u6bcf\u6761\u94fe\nvoid dfs3(int x,int fa){\n\tdfs1(x,fa);\n\tm=siz[x];\n\tdfs2(x,fa);\n\tint H=h;\n\tvis[H]=1;\n\tlen=0;\n\tfor(int i=head[H];i!=-1;i=e[i].nxt){\n\t\tint tmp=e[i].to;\n\t\tif(vis[tmp])continue;\n\t\tval=dis=0;\n\t\tdfs4(tmp,H,tmp,e[i].w,e[i].w,10001);\n\t}\n\tsort(g+1,g+len+1);\n\tg[0].c=-1;\n\tint lst1=1,lst2=1;\n\tfor(int i=1;i<=len;i++){\n\t\tif(g[i].c>g[i-1].c){\n\t\t\tfor(int j=lst1;j<i;j++)if(g[j].d<R)modify1(1,1,R,g[j].d,g[j].a);\n\t\t\tfor(int j=lst1;j<lst2;j++)if(g[j].d<R)clear2(1,1,R,g[j].d);\n\t\t\tlst1=lst2=i;\n        //\u6362\u94fe\u9876\u989c\u8272\uff0c\u6362\u5b50\u6811\n\t\t}\n\t\telse if(g[i].b>g[i-1].b){\n\t\t\tfor(int j=lst2;j<i;j++)if(g[j].d<R)modify2(1,1,R,g[j].d,g[j].a);\n\t\t\tlst2=i;\n        //\u6362\u5b50\u6811\n\t\t}\n\t\tif(g[i].d>R)continue;\n\t\tint lt=L-g[i].d,rt=R-g[i].d,v=g[i].a;\n\t\tif(g[i].d>=L&&g[i].d<=R)ans=max(ans,v);//\u5355\u94fe\u8ba1\u7b97\n\t\tans=max(ans,max(query1(1,1,R,lt,rt),query2(1,1,R,lt,rt)-C[g[i].c])+v);\n\t}\n\tfor(int i=1;i<lst1;i++)if(g[i].d<R)clear1(1,1,R,g[i].d);\n\tfor(int i=lst1;i<lst2;i++)if(g[i].d<R)clear2(1,1,R,g[i].d);\n\tfor(int i=head[H];i!=-1;i=e[i].nxt){\n\t\tint tmp=e[i].to;\n\t\tif(vis[tmp])continue;\n\t\tdfs3(tmp,H);\n\t}\n\treturn ;\n}\nint main(){\n\tn=read();p=read();L=read();R=read();\n\tfor(int i=1;i<=p;i++)C[i]=read();\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++){\n\t\tint u,v,c;\n\t\tu=read();v=read();c=read();\n\t\tadd(u,v,c);\n\t\tadd(v,u,c);\n\t}\n\tans=-inf;\n\tbuild(1,1,R);\n\tdfs3(1,0);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n```",
        "postTime": 1598788799,
        "uid": 98527,
        "name": "juju527",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3714 \u3010[BJOI2017]\u6811\u7684\u96be\u9898\u3011"
    },
    {
        "content": "# [BJOI 2017] \u6811\u7684\u96be\u9898\n\n## \u9898\u76ee\u53d9\u8ff0\n\n\u7ed9\u4f60\u4e00\u9897\u6811\uff0c\u6bcf\u4e2a\u8fb9\u6709\u4e00\u4e2a\u6743\u503c\uff0c\u4e00\u6761\u8def\u5f84\u7684\u6743\u503c\u5b9a\u4e49\u4e3a\u8fd9\u6761\u8def\u5f84\u7684\u989c\u8272\u5757\uff08\u8fde\u5728\u4e00\u8d77\u90fd\u662f\u4e00\u4e2a\u989c\u8272\u7684\u4e00\u90e8\u5206\uff09\u6bcf\u4e2a\u989c\u8272\u5feb\u7684\u90a3\u4e2a\u989c\u8272\u7684\u6743\u503c\u548c\u3002\n\n## \u9898\u89e3\n\n+ \u8003\u8651\u5206\u6cbb\u91cd\u5fc3\u4e3a$k$\u7684\u65f6\u5019\u3002\u7531\u4e8e\u6c42\u6700\u5927\u503c\uff0c\u6240\u4ee5\u4e0d\u80fd\u5bb9\u65a5\uff0c\u6240\u4ee5\u8003\u8651\u7ed9\u6bcf\u4e2a\u70b9\u67d3\u8272\uff08\u67d3\u4ed6\u662f\u54ea\u4e2a\u5b50\u6811\u7684\uff09\uff0c\u8bb0\u5f55\u8fd9\u4e2a\u70b9\u5230$k$\u7684\u8def\u5f84\u4e0a\u6700\u9760\u4e0a\u7684\u4e00\u6761\u8fb9\u7684\u989c\u8272\u3002\n+ \u8003\u8651\u5982\u4f55\u5408\u5e76\u8def\u5f84\u3002\u5c06\u8fd9\u4e2a\u5269\u4e0b\u7684\u4e00\u5806\u534a\u94fe\u6309\u7167\u6700\u9876\u7aef\u989c\u8272\u6392\u5e8f\uff0c\u518d\u6309\u7167\u6240\u5c5e\u5b50\u6811\u6392\u5e8f\u3002\u8fd9\u6837\u6240\u6709\u5b50\u6811\u76f8\u540c\u7684\u70b9\u5728\u4e00\u4e2a\u533a\u95f4\u91cc\uff0c\u6240\u6709\u9876\u7aef\u989c\u8272\u76f8\u540c\u7684\u70b9\u4e5f\u5728\u4e00\u4e2a\u8fde\u7eed\u533a\u95f4\u91cc\u3002\n+ \u8003\u8651\u5230\u9876\u7aef\u989c\u8272\u76f8\u540c\u7684\u9700\u8981\u51cf\u53bb\u9876\u7aef\u989c\u8272\u6743\u503c\uff0c\u9876\u7aef\u989c\u8272\u4e0d\u540c\u7684\u4e0d\u9700\u8981\u3002\n+ \u8003\u8651\u7ef4\u62a4\u4e00\u4e2a\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u4ee5\u957f\u5ea6\u4e3a\u4e0b\u6807\uff0c\u4ee5\u8def\u5f84\u6743\u503c\u4e3a\u503c\u7684\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u3002\u8fd9\u4e2a\u7ebf\u6bb5\u6811\u5728\u4e00\u4e2a\u989c\u8272\u533a\u95f4\u91cc\u7684\u6240\u6709\u70b9\u90fd\u8ba1\u7b97\u5b8c\u4e4b\u540e\uff0c\u628a\u8fd9\u4e9b\u70b9\u5168\u90fd\u63d2\u5165\u3002\u8fd9\u662f\u4e3a\u4e86\u8ba1\u7b97\u8de8\u989c\u8272\u7684\u8def\u5f84\u5408\u5e76\u3002\u53e6\u4e00\u4e2a\u7ebf\u6bb5\u6811\uff0c\u5728\u540c\u4e00\u4e2a\u989c\u8272\u91cc\u521d\u59cb\u5316\u4e00\u6b21\uff0c\u5728\u4e00\u4e2a\u5b50\u6811\u533a\u95f4\u91cc\u5168\u90e8\u8ba1\u7b97\u5b8c\u540e\u628a\u8fd9\u4e9b\u70b9\u90fd\u63d2\u5165\u3002\u4ee5\u957f\u5ea6\u4e3a\u4e0b\u6807\u7684\u76ee\u7684\u662f\uff0c\u6c42\u957f\u5ea6\u5728\u67d0\u4e00\u8303\u56f4\u5185\u7684\u548c\u7684\u6700\u5927\u503c\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int maxNode = 2e5 + 5, maxColor = 2e5 + 5, negInf = -2e9 - 1;\ntemplate <const int maxNodeNum>\nstruct TREE {\n    int tot, head[maxNodeNum], to[maxNodeNum << 1], next[maxNodeNum << 1], col[maxNodeNum << 1];\n    TREE() {\n        tot = 0;\n        memset(head, -1, sizeof(head));\n    }\n    void AddEdge(int from, int TO, int color) {\n        to[++tot] = TO;\n        next[tot] = head[from];\n        col[tot] = color;\n        head[from] = tot;\n    }\n};\nstruct ELEMENT {\n    int col, bel, len, sum;\n    ELEMENT(int _c, int _b, int _l, int _s) : col(_c), bel(_b), len(_l), sum(_s) {}\n    ELEMENT() : col(0), bel(0), len(0), sum(0) {}\n} ele[maxNode];\nTREE<maxNode> tree;\nint nbNode, nbColor, limL, limR, tot, ans = negInf, colNum, sonTreeNum;\nint val[maxColor], siz[maxNode], maxPart[maxNode], sum[maxNode], dep[maxNode];\nint sonTreeL[maxNode], sonTreeR[maxNode], colL[maxNode], colR[maxNode];\nint colSeq[maxNode], sonTreeSeq[maxNode];\nbool vis[maxNode];\nint GetCentroid(int now, int from, int all) {\n    siz[now] = 1;\n    maxPart[now] = 0;\n    int ret = 0;\n    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {\n        int to = tree.to[pt];\n        if (to != from && (!vis[to])) {\n            int sonRoot = GetCentroid(to, now, all);\n            if ((!ret) || maxPart[sonRoot] < maxPart[ret])\n                ret = sonRoot;\n            siz[now] += siz[to];\n            maxPart[now] = max(maxPart[now], siz[to]);\n        }\n    }\n    maxPart[now] = max(maxPart[now], all - siz[now]);\n    if ((!ret) || maxPart[now] < maxPart[ret])\n        ret = now;\n    return ret;\n}\nbool cmp(ELEMENT fir, ELEMENT sec) {\n    return (fir.col == sec.col) ? (fir.bel < sec.bel) : (fir.col < sec.col);\n}\nvoid Dfs1(int now, int from, int come) {\n    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {\n        int to = tree.to[pt], col = tree.col[pt];\n        if (to != from && (!vis[to])) {\n            sum[to] = sum[now];\n            if (col != come)\n                sum[to] += val[col];\n            Dfs1(to, now, col);\n        }\n    }\n}\nvoid Dfs2(int now, int from, int bel, int col) {\n    dep[now] = dep[from] + 1;\n    ele[++tot] = ELEMENT(col, bel, dep[now], sum[now]);\n    //\tif (check)\n    //\t\tprintf(\"col : %d bel : %d dep[now] : %d sum[now] : %d\\n\", col, bel, dep[now], sum[now]);\n    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {\n        int to = tree.to[pt];\n        if (to != from && (!vis[to]))\n            Dfs2(to, now, bel, col);\n    }\n}\nstruct SEGMENTTREE {\n    int tot, root, ls[maxNode << 2], rs[maxNode << 2], mx[maxNode << 2];\n    void Init() {\n        root = ls[0] = rs[0] = 0, mx[0] = negInf;\n        while (tot) {\n            ls[tot] = rs[tot] = 0;\n            mx[tot--] = negInf;\n        }\n    }\n    SEGMENTTREE() { Init(); }\n    void Create(int &now) {\n        ++tot;\n        ls[tot] = ls[now], rs[tot] = rs[now], mx[tot] = mx[now];\n        now = tot;\n    }\n    void Update(int now) { mx[now] = max(mx[ls[now]], mx[rs[now]]); }\n    void Insert(int &now, int lEP, int rEP, int pos, int val) {\n        if (!now)\n            Create(now);\n        if (lEP == rEP) {\n            mx[now] = max(mx[now], val);\n            return;\n        }\n        int mid = (lEP + rEP) >> 1;\n        if (pos <= mid)\n            Insert(ls[now], lEP, mid, pos, val);\n        else\n            Insert(rs[now], mid + 1, rEP, pos, val);\n        Update(now);\n    }\n    int Query(int now, int lEP, int rEP, int askL, int askR) {\n        if (lEP > askR || rEP < askL)\n            return negInf;\n        if (!now)\n            return negInf;\n        if (askL <= lEP && rEP <= askR)\n            return mx[now];\n        int mid = (lEP + rEP) >> 1, ret = negInf;\n        if (askL <= mid)\n            ret = max(ret, Query(ls[now], lEP, mid, askL, askR));\n        if (askR > mid)\n            ret = max(ret, Query(rs[now], mid + 1, rEP, askL, askR));\n        return ret;\n    }\n    void Check() {\n        for (int i = 1; i <= tot; ++i) printf(\"ls : %d rs : %d max : %d\\n\", ls[i], rs[i], mx[i]);\n    }\n};\nSEGMENTTREE seg, sml;\nvoid Solve(int root) {\n    dep[root] = 0;\n    sum[root] = 0;\n    tot = 0;\n    for (int pt = tree.head[root]; ~pt; pt = tree.next[pt]) {\n        int to = tree.to[pt];\n        if (!vis[to]) {\n            dep[to] = 1;\n            sum[to] = val[tree.col[pt]];\n            Dfs1(to, root, tree.col[pt]);\n            Dfs2(to, root, to, tree.col[pt]);\n        }\n    }\n    sort(ele + 1, ele + tot + 1, cmp);\n    //\tif (root == 3)\n    //\t\tfor (int i = 1; i <= tot; ++i)\n    //\t\t\tprintf(\"col : %d bel : %d dep : %d sum : %d\\n\", ele[i].col, ele[i].bel, ele[i].len,\n    //ele[i].sum);\n    colNum = sonTreeNum = 0;\n    seg.Init();\n    sml.Init();\n    for (int i = 1; i <= tot; ++i) {\n        if (!sonTreeL[ele[i].bel]) {\n            sonTreeL[ele[i].bel] = i;\n            sonTreeSeq[++sonTreeNum] = ele[i].bel;\n        }\n        sonTreeR[ele[i].bel] = i;\n        if (!colL[ele[i].col]) {\n            colL[ele[i].col] = i;\n            colSeq[++colNum] = ele[i].col;\n        }\n        colR[ele[i].col] = i;\n    }\n    for (int col = 1, ptSon = 1; col <= colNum; ++col) {\n        for (int pt = colL[colSeq[col]]; pt <= colR[colSeq[col]]; ++pt) {\n            int maxVal =\n                seg.Query(seg.root, 1, nbNode, max(limL - ele[pt].len, 1), max(limR - ele[pt].len, 1));\n            if (maxVal != negInf) {\n                ans = max(maxVal + ele[pt].sum, ans);\n                //\t\t\t\tif (maxVal + ele[pt].sum == -20)\n                //\t\t\t\t\tprintf(\"root : %d\\n\", root);\n            }\n        }\n        for (int pt = colL[colSeq[col]]; pt <= colR[colSeq[col]]; ++pt)\n            seg.Insert(seg.root, 1, nbNode, ele[pt].len, ele[pt].sum);\n        sml.Init();\n        while (ptSon <= sonTreeNum && sonTreeR[sonTreeSeq[ptSon]] <= colR[colSeq[col]]) {\n            for (int pt = sonTreeL[sonTreeSeq[ptSon]]; pt <= sonTreeR[sonTreeSeq[ptSon]]; ++pt) {\n                //\t\t\t\tif (root == 3) printf(\"ptSon : %d pt : %d\\n\", ptSon, pt);\n                int maxVal =\n                    sml.Query(sml.root, 1, nbNode, max(limL - ele[pt].len, 1), max(limR - ele[pt].len, 1));\n                if (maxVal != negInf) {\n                    ans = max(ans, maxVal + ele[pt].sum - val[ele[pt].col]);\n                    //\t\t\t\t\tif (pt == 8)\n                    //\t\t\t\t\t\tprintf(\"maxVal : %d ele[pt].sum : %d val[ele[pt].col] : %d\\n\", maxVal,\n                    //ele[pt].sum, val[ele[pt].col]); \t\t\t\t\tif (maxVal + ele[pt].sum - val[ele[pt].col] == -20)\n                    //\t\t\t\t\t\tprintf(\"root : %d\\n\", root);\n                }\n            }\n            for (int pt = sonTreeL[sonTreeSeq[ptSon]]; pt <= sonTreeR[sonTreeSeq[ptSon]]; ++pt)\n                sml.Insert(sml.root, 1, nbNode, ele[pt].len, ele[pt].sum);\n            ++ptSon;\n            //\t\t\tif (root == 3)\n            //\t\t\t\tprintf(\"sonTreeSeq[ptSon] : %d sonTreeR[sonTreeSeq[ptSon]] : %d colR[col] : %d\\n\",\n            //sonTreeSeq[ptSon], sonTreeR[sonTreeSeq[ptSon]], colR[col]);\n        }\n    }\n    for (int i = 1; i <= tot; ++i)\n        if (limL <= ele[i].len && ele[i].len <= limR) {\n            ans = max(ans, ele[i].sum);\n            //\t\t\tif (ele[i].sum == -20)\n            //\t\t\t\tprintf(\"root : %d\\n\", root);\n        }\n    for (int i = 1; i <= tot; ++i) {\n        sonTreeL[ele[i].bel] = sonTreeR[ele[i].bel] = 0;\n        colL[ele[i].col] = colR[ele[i].col] = 0;\n    }\n}\nvoid Divide(int now, int real) {\n    //\tprintf(\"now : %d\\n\", now);\n    Solve(now);\n    vis[now] = 1;\n    for (int pt = tree.head[now]; ~pt; pt = tree.next[pt]) {\n        int to = tree.to[pt];\n        if (!vis[to]) {\n            int realSize = (siz[to] > siz[now]) ? (real - siz[now]) : siz[to];\n            Divide(GetCentroid(to, 0, realSize), realSize);\n            //\u6211\u5728\u5199 horse \uff01\u5206\u6cbb\u4e0b\u9762\u4e00\u5c42\u5199\u7684 GetCentroid(now, 0, realSize)\n        }\n    }\n}\nint main() {\n    scanf(\"%d%d%d%d\", &nbNode, &nbColor, &limL, &limR);\n    for (int col = 1; col <= nbColor; ++col) scanf(\"%d\", &val[col]);\n    for (int eg = 1; eg < nbNode; ++eg) {\n        int u, v, c;\n        scanf(\"%d%d%d\", &u, &v, &c);\n        tree.AddEdge(u, v, c);\n        tree.AddEdge(v, u, c);\n    }\n    Divide(GetCentroid(1, 0, nbNode), nbNode);\n    if (ans > -2e9)\n        printf(\"%d\\n\", ans);\n    return 0;\n}\n```\n\n## \u77e5\u8bc6\u70b9\n\n+ \u6ce8\u610f\u89c2\u5bdf\uff0c\u53d1\u73b0\u53ef\u4ee5\u628a\u5b50\u6811\u548c\u989c\u8272\u540c\u65f6\u5f04\u6210\u4e00\u4e2a\u8fde\u7eed\u7684\u533a\u95f4\u3002",
        "postTime": 1582348750,
        "uid": 75715,
        "name": "KokiNiwa",
        "ccfLevel": 0,
        "title": "[BJOI 2017] \u6811\u7684\u96be\u9898\uff08\u7ebf\u6bb5\u6811\uff0c\u70b9\u5206\u6cbb\uff09"
    }
]