[
    {
        "content": "###  \u9898\u610f\u7b80\u8ff0\uff1a\n\n\u9898\u9762\u8bf4\u7684\u5f88\u6e05\u695a\u4e86\u3002\n\n### \u9898\u89e3\uff1a\n\n\u53d1\u73b0\u6ca1\u6709\u4fee\u6539\u5f88\u5feb\u4e50\u3002\u518d\u770b\u5f02\u6216\u6700\u5927\u503c\u64cd\u4f5c\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u53ef\u6301\u4e45\u5316 01trie\u3002\n\n\u8fd9\u91cc\u8981\u628a 01trie \u642c\u5230\u6811\u4e0a\uff0c\u6709\u70b9\u96be\u53d7\u3002\n\n\u6811\u5256\u592a\u635e\u4e86\uff0c\u8003\u8651 DFS \u5e8f\u3002\n\n\u5b50\u6811\u67e5\u8be2\u8f6c\u6210 DFS \u5e8f\u4e0a\u4e00\u6bb5\u533a\u95f4\uff0c\u800c\u94fe\u4e0a\u67e5\u8be2\u8f6c\u6210\u4e24\u6761\u94fe\u3002\n\n\u6240\u4ee5\u7ef4\u62a4\u4e24(\u4e2a?)\u79cd\u53ef\u6301\u4e45\u5316 01trie\uff0c\u4e00\u4e2a\u6309\u7167 DFS \u5e8f\uff0c\u53e6\u4e00\u4e2a\u6309\u7167\u4ece\u6839\u5230\u7ed3\u70b9\u7684\u8def\u5f84\u3002\n\n\u8fd8\u8981\u6c42 LCA\uff0c\u8fd9\u91cc\u6211\u5199\u4e86\u4e2a\u500d\u589e\u3002\n\n```cpp\n#include <cstdio>\n\ninline int Max(int x, int y) { return x > y ? x : y; }\n\nconst int MN = 100005;\nconst int MS = 6200005;\nconst int BK = 29;\n\nint N, Q;\nint A[MN];\nint eh[MN], nxt[MN * 2], to[MN * 2], tot;\ninline void insw(int x, int y) {\n\tnxt[++tot] = eh[x]; to[tot] = y; eh[x] = tot;\n\tnxt[++tot] = eh[y]; to[tot] = x; eh[y] = tot;\n}\n\nint sz[MS], ch[MS][2], cnt;\nint rt1[MN], rt2[MN];\ninline void Ins(int &rt, int x, int j) {\n\tch[++cnt][0] = ch[rt][0], ch[cnt][1] = ch[rt][1], sz[cnt] = sz[rt], rt = cnt;\n\t++sz[rt];\n\tif (~j) Ins(ch[rt][x >> j & 1], x, j - 1);\n}\n\nint ldf[MN], rdf[MN], dep[MN], faz[MN][17], dfc;\n\nvoid DFS(int u, int fa) {\n\tldf[u] = ++dfc; faz[u][0] = fa; dep[u] = dep[fa] + 1;\n\tIns(rt1[dfc] = rt1[dfc - 1], A[u], BK);\n\tIns(rt2[u] = rt2[fa], A[u], BK);\n\tfor (int j = 1; 1 << j < dep[u]; ++j) faz[u][j] = faz[faz[u][j - 1]][j - 1];\n\tfor (int i = eh[u]; i; i = nxt[i]) if (to[i] != fa) DFS(to[i], u);\n\trdf[u] = dfc;\n}\n\ninline int LCA(int x, int y) {\n\tif (dep[x] < dep[y]) x ^= y ^= x ^= y;\n\tfor (int d = dep[x] - dep[y], j = 0; d; d >>= 1, ++j) if (d & 1) x = faz[x][j];\n\tif (x == y) return x;\n\tfor (int j = 16; ~j; --j) if (faz[x][j] != faz[y][j]) x = faz[x][j], y = faz[y][j];\n\treturn faz[x][0];\n}\n\nint Qu(int rt1, int rt2, int x, int j) {\n\tif (j == -1) return 0;\n\tint p = (x >> j & 1) ^ 1;\n\tif (sz[ch[rt1][p]] - sz[ch[rt2][p]])\n\t\treturn Qu(ch[rt1][p], ch[rt2][p], x, j - 1) | 1 << j;\n\treturn Qu(ch[rt1][p ^ 1], ch[rt2][p ^ 1], x, j - 1);\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tfor (int i = 1; i <= N; ++i)\n\t\tscanf(\"%d\", A + i);\n\tfor (int i = 1, x, y; i < N; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tinsw(x, y);\n\t}\n\tDFS(1, 0);\n\tfor (int i = 1, opt, x, y, z; i <= Q; ++i) {\n\t\tscanf(\"%d\", &opt);\n\t\tif (opt == 1) {\n\t\t\tscanf(\"%d%d\", &x, &z);\n\t\t\tprintf(\"%d\\n\", Qu(rt1[rdf[x]], rt1[ldf[x] - 1], z, BK));\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tint w = faz[LCA(x, y)][0];\n\t\t\tprintf(\"%d\\n\", Max(Qu(rt2[x], rt2[w], z, BK), Qu(rt2[y], rt2[w], z, BK)));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1545663222,
        "uid": 10703,
        "name": "\u5c0f\u7c89\u5154",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "### \u9898\u610f\n\n\u7ed9\u4e00\u68f5 $n$ \u4e2a\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u70b9\u6709\u70b9\u6743\u3002\u6709 $q$ \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e3a\u67e5\u8be2\u94fe\u4e0a\u6216\u5b50\u6811\u4e2d\u70b9\u6743\u4e0e $x$ \u5f02\u6216\u7684\u6700\u5927\u503c\u3002\n\n$\\texttt{Data Range:}1\\leq n,q\\leq 10^5$\n\n### \u9898\u89e3\n\n\u4e0d\u4f1a\u6570\u636e\u7ed3\u6784\u7684\u5927\u5f69\u7b14\u5c45\u7136\u4e0d\u770b\u9898\u89e3 1A \u4e86\u8fd9\u9898\uff0c\u611f\u52a8\u2026\u2026\n\n\u9996\u5148\u8fd9\u79cd\u9898\u76ee\u5e94\u8be5\u662f 01trie \u6c42\u6700\u5927\u5f02\u6216\u548c\u3002\u7531\u4e8e\u5904\u7406\u5b50\u6811\u8be2\u95ee\u7684\u65f6\u5019\u5bf9\u6bcf\u4e2a\u70b9\u90fd\u5f00\u4e00\u4e2a 01trie \u663e\u7136\u4e0d\u73b0\u5b9e\uff0c\u6240\u4ee5\u8003\u8651\u53ef\u6301\u4e45\u5316 01trie\u3002\n\n\u9996\u5148\u8003\u8651\u6240\u6709\u7684\u5b50\u6811\u5185\u8be2\u95ee\u3002\u56e0\u4e3a\u53ef\u6301\u4e45\u5316 01trie \u672c\u8d28\u4e0a\u662f\u9ad8\u5ea6\u4e3a $32$ \u7684\u4e3b\u5e2d\u6811\uff0c\u5177\u6709\u53ef\u51cf\u6027\uff0c\u6240\u4ee5\u5982\u679c\u628a\u8fd9\u4e2a\u4e1c\u897f\u62cd\u5230\u5e8f\u5217\u4e0a\u4f1a\u975e\u5e38\u597d\u505a\u3002\u4e8e\u662f\u7528 dfs \u5e8f\u5c06\u4e00\u4e2a\u5b50\u6811\u5185\u7684\u4e1c\u897f\u62cd\u5230\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\u4e0a\uff0c\u7136\u540e\u7c7b\u4f3c\u533a\u95f4 $k$ \u5c0f\u503c\u5c31\u505a\u5b8c\u4e86\u3002\n\n\u5bf9\u4e8e\u6240\u6709\u7684\u94fe\u4e0a\u8be2\u95ee\uff0c\u53ef\u4ee5\u53c2\u8003 Count on a tree \u90a3\u9898\u7684\u505a\u6cd5\uff0c\u4e5f\u5c31\u662f\u4e00\u4e2a\u8282\u70b9\u4e0a\u7684\u53ef\u6301\u4e45\u5316 01trie \u4e0a\u6709\u8fd9\u4e2a\u8282\u70b9\u5230\u6839\u8def\u5f84\u4e0a\u6240\u6709\u6570\uff0c\u5bf9\u4e8e\u67e5\u8be2\u7684\u8bdd\u76f4\u63a5\u6811\u4e0a\u5dee\u5206\u5c31\u597d\u4e86\u3002\u56e0\u4e3a\u8fd9\u4e1c\u897f\u5177\u6709\u53ef\u51cf\u6027\u6240\u4ee5\u6ca1\u4ec0\u4e48\u95ee\u9898\u3002\n\n### \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef long long int li;\nconst ll MAXN=2e5+51;\nstruct Edge{\n\tll to,prev;\n};\nEdge ed[MAXN<<1];\nll n,qcnt,op,u,v,c,tot,totn,totd;\nll x[MAXN],last[MAXN],rt[MAXN],rt2[MAXN],dfn[MAXN],sz[MAXN];\nll fa[MAXN],depth[MAXN],rdfn[MAXN],hv[MAXN],top[MAXN],s[MAXN<<6];\nll ch[MAXN<<6][2];\ninline ll read()\n{\n    register ll num=0,neg=1;\n    register char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')\n    {\n        ch=getchar();\n    }\n    if(ch=='-')\n    {\n        neg=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch))\n    {\n        num=(num<<3)+(num<<1)+(ch-'0');\n        ch=getchar();\n    }\n    return num*neg;\n}\ninline void addEdge(ll from,ll to)\n{\n\ted[++tot].prev=last[from];\n\ted[tot].to=to;\n\tlast[from]=tot;\n}\ninline ll insert(ll x,ll node,ll depth) \n{\n\tll cur=++totn;\n\ts[cur]=s[node]+1,ch[cur][0]=ch[node][0],ch[cur][1]=ch[node][1];\n\tif(depth==-1)\n\t{\n\t\treturn cur;\n\t}\n\treturn ch[cur][(x>>depth)&1]=insert(x,ch[node][(x>>depth)&1],depth-1),cur;\n}\ninline void dfs(ll node,ll f)\n{\n\tll mx=-1;\n\trdfn[dfn[node]=++totd]=node,sz[node]=1,depth[node]=depth[f]+1;\n\trt2[node]=insert(x[node],rt2[fa[node]=f],31);\n\tfor(register int i=last[node];i;i=ed[i].prev)\n\t{\n\t\tif(ed[i].to!=f)\n\t\t{\n\t\t\tdfs(ed[i].to,node),sz[node]+=sz[ed[i].to];\n\t\t\tsz[ed[i].to]>mx?mx=sz[hv[node]=ed[i].to]:1;\n\t\t}\n\t}\n}\ninline void dfs2(ll node,ll link)\n{\n\tll to;\n\ttop[node]=link;\n\tif(!hv[node])\n\t{\n\t\treturn;\n\t}\n\tdfs2(hv[node],link);\n\tfor(register int i=last[node];i;i=ed[i].prev)\n\t{\n\t\t(to=ed[i].to)!=fa[node]&&to!=hv[node]?dfs2(to,to):(void)1;\n\t}\n}\ninline ll LCA(ll x,ll y)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tdepth[top[x]]<depth[top[y]]?swap(x,y):(void)1,x=fa[top[x]];\n\t}\n\treturn depth[x]<depth[y]?x:y;\n}\ninline ll query(ll x,ll lc,ll rc,ll depth)\n{\n\tif(depth==-1)\n\t{\n\t\treturn 0;\n\t}\n\tll nxt=!((x>>depth)&1),d=nxt^(!(s[ch[rc][nxt]]-s[ch[lc][nxt]]));\n\treturn (d<<depth)+query(x,ch[lc][d],ch[rc][d],depth-1);\n}\ninline ll query(ll x,ll l1,ll l2,ll l3,ll l4,ll depth)\n{\n\tif(depth==-1)\n\t{\n\t\treturn 0;\n\t}\n\tll nxt=!((x>>depth)&1);\n\tll d=nxt^(!(s[ch[l1][nxt]]+s[ch[l2][nxt]]-s[ch[l3][nxt]]-s[ch[l4][nxt]]));\n\treturn (d<<depth)+query(x,ch[l1][d],ch[l2][d],ch[l3][d],ch[l4][d],depth-1);\n}\ninline ll query(ll u,ll v,ll x)\n{\n\tll l=LCA(u,v);\n\treturn query(x,rt2[u],rt2[v],rt2[l],rt2[fa[l]],31);\n}\nint main()\n{\n\tn=read(),qcnt=read();\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\tx[i]=read();\n\t}\n\tfor(register int i=0;i<n-1;i++)\n\t{\n\t\tu=read(),v=read(),addEdge(u,v),addEdge(v,u);\n\t}\n\tdfs(1,0),dfs2(1,1);\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\trt[i]=insert(x[rdfn[i]],rt[i-1],31);\n\t}\n\tfor(register int i=1;i<=qcnt;i++)\n\t{\n\t\top=read();\n\t\tif(op==1)\n\t\t{\n\t\t\tu=read(),c=read();\n\t\t\tprintf(\"%d\\n\",query(c,rt[dfn[u]-1],rt[dfn[u]+sz[u]-1],31)^c);\n\t\t}\n\t\tif(op==2)\n\t\t{\n\t\t\tu=read(),v=read(),c=read(),printf(\"%d\\n\",query(u,v,c)^c);\n\t\t}\n\t}\n}\n```",
        "postTime": 1609849723,
        "uid": 60990,
        "name": "Karry5307",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u6211\u6ca1\u6709\u60f3\u5230\u5dee\u5206\u7684\u601d\u8def\u2026\u2026\u6211\u6765\u63d0\u4f9b $O(30nlogn)$ \u7684\u601d\u8def\n\n\u64cd\u4f5c $1$\uff1a\u5c06\u5b50\u6811\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u6bb5 $dfs$ \u5e8f\u7136\u540e\u5728\u53ef\u6301\u4e45\u5316 $trie$ \u4e0a\u5229\u7528\u5f02\u6216\u7684\u6027\u8d28\u9ad8\u4f4d\u5f80\u4f4e\u4f4d\u8d2a\u5fc3\uff0c\u5355\u6b21\u64cd\u4f5c $O(30)$\n\n\u64cd\u4f5c $2$\uff1a\u7528\u6811\u5256\u7684\u601d\u60f3\u4e0d\u505c\u5f80 $top$ \u4e0a\u8df3\uff0c\u5c06\u4e00\u6761\u6811\u4e0a\u8def\u5f84\u8f6c\u5316\u4e3a\u591a\u6bb5 $dfs$ \u5e8f\u7684\u7b54\u6848\u53d6\u4e2a $max$\uff0c\u5355\u6b21\u64cd\u4f5c $O(30logn)$\n\n\u4e0d\u8fc7\u6211\u76f8\u5f53\u4e8e\u4e24\u4e2a $log$ \u7684\u4ee3\u7801\u6ca1\u5f00 $O_2$ \u6700\u5927\u4e00\u4e2a\u70b9 $425ms$\uff0c\u53ef\u80fd\u662f\u6811\u5256\u5e38\u6570\u8dd1\u4e0d\u6ee1\u6240\u4ee5\u6ca1\u6709\u88ab\u5361\u6389\n\n$Code\\ Below:$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=100000+10;\nint n,m,a[maxn],head[maxn],to[maxn<<1],nxt[maxn<<1],tot;\nint top[maxn],dep[maxn],siz[maxn],son[maxn],fa[maxn],id[maxn],mp[maxn],tim;\nint T[maxn],ch[maxn<<5][2],sum[maxn<<5],cnt;\nbool b[maxn];\n\ninline int read(){\n\tregister int x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn (f==1)?x:-x;\n}\ninline void add(int x,int y){\n\tto[++tot]=y;\n\tnxt[tot]=head[x];\n\thead[x]=tot;\n}\n\nvoid dfs1(int x,int f){\n\tsiz[x]=1;fa[x]=f;\n\tdep[x]=dep[f]+1;\n\tint maxson=-1;\n\tfor(int i=head[x],y;i;i=nxt[i]){\n\t\ty=to[i];\n\t\tif(y==f) continue;\n\t\tdfs1(y,x);\n\t\tsiz[x]+=siz[y];\n\t\tif(maxson<siz[y]){\n\t\t\tmaxson=siz[y];\n\t\t\tson[x]=y;\n\t\t}\n\t}\n}\n\nvoid dfs2(int x,int topf){\n\tid[x]=++tim;\n\tmp[tim]=a[x];\n\ttop[x]=topf;\n\tif(son[x]) dfs2(son[x],topf);\n\tfor(int i=head[x],y;i;i=nxt[i]){\n\t\ty=to[i];\n\t\tif(y==fa[x]||y==son[x]) continue;\n\t\tdfs2(y,y);\n\t}\n}\n\nvoid split(int x){\n\tfor(int i=0;i<=30;i++){\n\t\tb[i]=x&1;x>>=1;\n\t}\n}\n\nvoid update(int pre,int now){\n\tfor(int i=30;i>=0;i--){\n\t\tch[now][b[i]]=++cnt;\n\t\tch[now][b[i]^1]=ch[pre][b[i]^1];\n\t\tnow=ch[now][b[i]];pre=ch[pre][b[i]];\n\t\tsum[now]=sum[pre]+1;\n\t}\n}\n\nint query(int u,int v){\n\tint ans=0;\n\tfor(int i=30;i>=0;i--){\n\t\tans<<=1;\n\t\tif(sum[ch[v][b[i]^1]]-sum[ch[u][b[i]^1]]>0){\n\t\t\tans|=1;\n\t\t\tv=ch[v][b[i]^1];u=ch[u][b[i]^1];\n\t\t}\n\t\telse {\n\t\t\tv=ch[v][b[i]];u=ch[u][b[i]];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tint opt,x,y,z,ans;\n\tfor(int i=1;i<n;i++){\n\t\tx=read(),y=read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs1(1,0);dfs2(1,1);\n\tfor(int i=1;i<=n;i++){\n\t\tsplit(mp[i]);T[i]=++cnt;\n\t\tupdate(T[i-1],T[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\topt=read();\n\t\tif(opt==1){\n\t\t\tx=read(),y=read();split(y);\n\t\t\tprintf(\"%d\\n\",query(T[id[x]-1],T[id[x]+siz[x]-1]));\n\t\t}\n\t\telse {\n\t\t\tx=read(),y=read(),z=read();\n\t\t\tsplit(z);ans=0;\n\t\t\twhile(top[x]!=top[y]){\n\t\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\t\t\tans=max(ans,query(T[id[top[x]]-1],T[id[x]]));\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\t\tans=max(ans,query(T[id[x]-1],T[id[y]]));\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1542797630,
        "uid": 35069,
        "name": "Owen_codeisking",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u6b63\u89e3\uff08\u96fe\uff0c\u662f\u53ef\u6301\u4e45\u5316$01Trie$\u3002\n\n\u524d\u7f6e\u77e5\u8bc6:\u53ef\u6301\u4e45\u5316$01Trie$\u6c42\u89e3\u533a\u95f4$Xor$\u95ee\u9898($P4735 \\text{\u6700\u5927\u5f02\u6216\u548c}$)\u3001\u6811\u4e0a\u7248\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u6c42$k$\u5c0f($P2633Count\\ on\\ a\\ tree$)\n\n\u8fd9\u9898\u5176\u5b9e\u5c31\u662f\u6811\u4e0a\u7248\u3002\u7b2c$1$\u95ee\u5f88\u7b80\u5355\uff0c\u76f4\u63a5\u7528$DFS$\u5e8f\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```\ntr.query(tpos[x],tpos[x]+size[x]-1,y)//tpos \u8282\u70b9x\u7684DFS\u5e8f\n```\n\n\u7b2c$2$\u95ee?\u56de\u60f3\u4e00\u4e0b\u6811\u4e0a\u7684\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811($count\\ on \\ a \\ tree\\ COT1$)\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u76f4\u63a5\u5728$DFS$\u904d\u5386\u6574\u68f5\u6811\u7684\u65f6\u5019\u4ee5\u6b64\u65f6\u8282\u70b9\u7684\u7236\u4eb2\u4e3a\u57fa\u7840\u63d2\u5165\u8fd9\u4e2a\u6743\u503c\u5c31\u597d\u4e86\u3002\n\n$P4735 \\text{\u6700\u5927\u5f02\u6216\u548c}$\u662f\u8fd9\u4e48\u63d2\u5165\u7684:\n```\nroot[i]=root[i-1];\ntr.insert(root[i],x);\n```\n\u6211\u4eec\u53ea\u9700\u8981\u6539\u4e3a:\n```\nroot[i]=root[fa];\ntr.insert(root[i],x);\n```\n\u5c31\u597d\u4e86$QwQ$\n\n\u67e5\u8be2\uff1f\u548c$count\\ on \\ a \\ tree\\ COT1$\u4e00\u6837\uff0c\u5229\u7528$LCA$\u8fdb\u884c\u5dee\u5206\u67e5\u8be2\u5c31\u53ef\u4ee5\u5566\uff01\n\n\u6211\u7528$struct$\u5c01\u88c5\u4e86$01Trie$\uff0c\u4ee3\u7801\u77ed\u4e86\u5f88\u591a\u800c\u4e14\u4e11\u4e86\u5f88\u591a\u2026\u2026\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m,sum,dep[200001],a[200001],ktot,size[200001],tpos[200001],pre[200001],head[200001],tot,f[200001][25];\nstruct edge{\n    int to,next;\n}g[1000001];\ninline void made(int from,int to){\n    g[++tot].to=to;g[tot].next=head[from];head[from]=tot;\n}\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}\n    while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}\n    return x*f;\n}\nstruct Trie{\n    int n,son[10000001][2],cnt=1,sum,root[200001],ct[10000001];\n    void ins(int &rt,int x,int T){\n        ct[++cnt]=ct[rt]+1;son[cnt][0]=son[rt][0];\n        son[cnt][1]=son[rt][1];rt=cnt;\n        if (T==-1) return;\n        register bool y=(x>>T)&1;\n        ins(son[rt][y],x,T-1);\n    }\n    inline void insert(int pre,int rt,int x){\n        root[rt]=root[pre];\n        ins(root[rt],x,30);\n    }\n    int QUE(int i,int j,int x,int T){//\u5e8f\u5217\u7248\n        if (T==-1) return 0;\n        register bool y=(x>>T)&1;\n        if (ct[son[j][1^y]]>ct[son[i][1^y]]) return ((1<<T)+QUE(son[i][1^y],son[j][1^y],x,T-1));\n        else return QUE(son[i][y],son[j][y],x,T-1);\n    }\n    int queryxx(int i,int j,int lc,int flc,int x,int T){//\u6811\u4e0a\u5dee\u5206\u7248\n        if (T==-1) return 0;\n        register bool y=(x>>T)&1;\n        if (ct[son[j][1^y]]+ct[son[i][1^y]]>ct[son[lc][1^y]]+ct[son[flc][1^y]]) return ((1<<T)+queryxx(son[i][1^y],son[j][1^y],son[lc][1^y],son[flc][1^y],x,T-1));\n        else return queryxx(son[i][y],son[j][y],son[lc][y],son[flc][y],x,T-1);\n    }\n    int queryx(int i,int j,int lc,int flc,int x,int T){\n        return queryxx(root[i],root[j],root[lc],root[flc],x,T);\n    }\n    inline int query(int l,int r,int x){\n        return QUE(root[l-1],root[r],x,30);\n    }\n}tr1,tr2;\nvoid dfs0(int u,int fa){\n    dep[u]=dep[fa]+1;f[u][0]=fa;tpos[u]=++ktot;pre[ktot]=u;\n    tr1.insert(fa,u,a[u]);size[u]=1;\n    for (int i=1;i<=21;i++) f[u][i]=f[f[u][i-1]][i-1];\n    for (int i=head[u];i;i=g[i].next){\n        int v=g[i].to;\n        if (v==fa) continue;\n        dfs0(v,u);size[u]+=size[v];\n    }\n}\ninline int lca(int x,int y){\n    if (dep[x]<dep[y]) swap(x,y);\n    for (int i=21;i>=0;i--){\n        if (dep[f[x][i]]>=dep[y]) x=f[x][i];\n    }\n    if (x==y) return x;\n    for (int i=21;i>=0;i--){\n        if (f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n    }\n    return f[x][0];\n}\nint main(){\n    n=read();m=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    for (int i=1;i<n;i++){\n    \tint x=read(),y=read();\n    \tmade(x,y);made(y,x);\n    }\n    dfs0(1,0);\n    for (int i=1;i<=n;i++){\n    \ttr2.insert(i-1,i,a[pre[i]]);\n    }\n    while (m--){\n        int opt=read();\n        if (opt==1){\n            int x=read(),y=read();\n            printf(\"%d\\n\",tr2.query(tpos[x],tpos[x]+size[x]-1,y));\n        }else{\n            int x=read(),y=read(),z=read(),a=lca(x,y);\n            printf(\"%d\\n\",tr1.queryx(x,y,a,f[a][0],z,30));\n        }\n    }\n}\n\n```",
        "postTime": 1542805231,
        "uid": 20309,
        "name": "Fading",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "------------\n\u6211\u4eec\u5ba1\u9898\uff1a\u4e24\u4e2a\u64cd\u4f5c  \n1. \u4ece\u5b50\u6811\u4e2d\u9009\u4e00\u4e2a\u70b9\u4f7f\u5f97\u5f02\u6216\u7ed3\u679c\u66f4\u5927  \n2.   $  x  \\to  y  $  \u7684\u8def\u5f84\u4e0a\u9009\u4e00\u4e2a\u70b9\u4f7f\u5f97\u5f02\u6216\u7ed3\u679c\u66f4\u5927    \n\uff08\u6811\u4e0a\u4e3b\u5e2d\u6811\u53ef\u4ee5\u89e3\u51b3\uff09\n\n------------\n\n  \n\u6b64\u5916\uff1a\u67e5\u8be2\u6700\u5927\u503c\uff08\u5f02\u6216\uff09\u3002  \n\u6211\u4eec\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u6765\u5b58\u50a8  01trie  \u6811 \u3002  \n\u4e5f\u5c31\u662f\u5efa\u7acb\u4e00\u4e2a\u53ef\u6301\u4e45\u7684  01trie  \u518d\u7ed3\u5408\u6811\u5256\u3002\n    \n  \u5728\u6bcf\u6b21\u67e5\u627e\u6700\u5927\u503c\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4e00\u79cd\u7c7b\u4f3c\u8d2a\u5fc3\u7684\u60f3\u6cd5\uff0c\u5c3d\u91cf\u8ba9\u524d\u51e0\u4f4d\u5927 \u3002  \n  \u8bb0\u5f97\u5f00 long long \u3002  \n  \u63a8\u8350\u5176\u4ed6\u9898 \uff1a  [\u6700\u5927\u5f02\u6216\u548c](https://www.luogu.com.cn/problem/P4735)\n```cpp\n#include<bits/stdc++.h>\n\n#define int long long \nusing namespace std;\nconst int N=4e5+7;\n\nint n,m;\nint son[N],dep[N],siz[N],f[N];\nint top[N],id[N],p;\nint tot,t[N];\n\nint head[N],nxt[N],to[N];\n\nint tree[N*20][2];\nint root[N],num[N*20];\nint data[N],flag[2];\nint ans;\n\n\nint _,cnt;\nvoid added(int x,int y)//\u52a0\u8fb9\n{\n\t_++;\n\tto[_]=y;\n\tnxt[_]=head[x];\n\thead[x]=_;\n\treturn ;\n}\n\nint add(int fa,int x,int k)//\u6211\u4eec\u63d2\u5165\n{\n\tint re=++cnt;\n\tint now=((x>>k)&1);\n\t//\u53d6\u51fa\u6765 \n\t\n\ttree[re][0]=tree[fa][0];//\u7ee7\u627f\u4e0a\u5c42\u5173\u7cfb\n\ttree[re][1]=tree[fa][1];\n\tnum[re]=num[fa]+1;\n\t\n\tif(k>=0)\n\ttree[re][now]=add(tree[re][now],x,k-1);\n\t\n\treturn re;//\u8fd4\u56de\u6807\u53f7 \n}\n\n\nvoid query(int l,int r,int x,signed k)\n{\n\tint now=((x>>k)&1);\n\tflag[0]=num[tree[r][0]]-num[tree[l][0]];\n\tflag[1]=num[tree[r][1]]-num[tree[l][1]];\t\n\t\n\tif(flag[now^1])\n\t{//\u56e0\u4e3a1^0=1\u7684\u60c5\u51b5\u6700\u5927\n\t\tans+=(1<<k);\n\t\tif(k>=0)\n\t\tquery(tree[l][now^1],tree[r][now^1],x,k-1);\n\t}\n\telse if(k>=0)\n\t{\n\t\tquery(tree[l][now],tree[r][now],x,k-1);\n\t}\n\treturn ;\n}\n\nvoid dfs1(int x)//\u6811\u5256\n{\n    siz[x]=1;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int tt=to[i];\n        if(!siz[tt])\n        {\n            dep[tt]=dep[x]+1;\n            f[tt]=x;\n            dfs1(tt);\n            siz[x]+=siz[tt];\n            if(siz[tt]>siz[son[x]])\n            son[x]=tt;\n        }\n    }\n}\nvoid dfs2(int x,int fa)\n{\n    top[x]=fa;\n    id[x]=++tot;\n    t[tot]=data[x];\n    if(son[x])\n    dfs2(son[x],fa);\n    for(int i=head[x];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(!top[y])\n        if(y!=son[x])\n            dfs2(y,y);\n    }\n    return ; \n}\n\n\nint solve(int x,int y,int w)\n{\n    int  re=0;\n    while(top[x]!=top[y])\n    {//lca\u4e0b\n        if(dep[top[x]]<dep[top[y]])\n        swap(x,y);\n        ans=0;\n       //32\u4e8c\u8fdb\u5236\u4f4d \n       query(root[id[top[x]]-1],root[id[x]],w,32);\n        re=max(ans,re);\n        x=f[top[x]];\n    }\n    if(id[x]>id[y])\n    swap(x,y);\n    ans=0;\n    query(root[id[x]-1],root[id[y]],w,32);\n    re=max(re,ans);\n    // \u6700\u5927 \n    return re;\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n>>m;\n\t\n\tfor(int i=1;i<=n;i++)\n\tcin>>data[i];\n\t\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint q,w;\n\t\tcin>>q>>w;\n\t\tadded(q,w);\n\t\tadded(w,q);\n\t}\n\tdfs1(1);//\u6811\u5256\u7684\u6811\u5efa\u51fa\u6765 \n    dfs2(1,1);\n    \n    for(int i=1;i<=n;i++)\n    {\n    \troot[i]=add(root[i-1],t[i],32);\n\t}\n\t\n\twhile(m--)\n\t{\n\t\tint tmp,q,w,e;\n\t\tcin>>tmp;\n\t\tif(tmp==1)\n\t\t{\n\t\t\tcin>>q>>w;\n\t\t\tans=0;\n\t\t\tquery(root[id[q]-1],root[id[q]+siz[q]-1],w,32);\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcin>>q>>w>>e;\n\t\t\tif(q==w)//\u4e00\u4e2a\u70b9\u7684\u8bdd\uff0c\u76f4\u63a5\u5f02\u6216 \n\t\t\tcout<<(data[q]^e)<<endl;\n\t\t\telse//q\u5230w\u7684\u94fe\u4e0a \n\t\t\tcout<<solve(q,w,e)<<endl;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n } \n```\n\n",
        "postTime": 1626578382,
        "uid": 130114,
        "name": "Hehe_0",
        "ccfLevel": 0,
        "title": "P4592 [TJOI2018]\u5f02\u6216"
    },
    {
        "content": "## \u53ef\u6301\u4e45\u53160/1Trie\u6811\n\n[\u535a\u5ba2\u9605\u8bfb](https://www.cnblogs.com/wljss/p/12601445.html)\n\n\u5bf9\u4e8e\u4e00\u6bb5\u533a\u95f4\u67e5\u8be2\u6700\u5927\u5f02\u6216\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u7528 \u53ef\u6301\u4e45\u53160/1Trie\u6811 \u6765\u7ef4\u62a4\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\uff0c\u5b83\u4eec\u7684 $dfs$ \u5e8f\u662f\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\u3002\n\n\u5bf9\u4e8e\u4e00\u6761\u8def\u7ecf\uff0c\u6211\u4eec\u62c6\u6210\u4e24\u4e2a\u7aef\u70b9\u5206\u522b\u5230\u8fbe $LCA$ \u7684\u4e24\u6761\u8def\u5f84\uff0c\u5b83\u4eec\u7684 $dep$ \u662f\u8fde\u7eed\u7684\u3002\n\n\u6211\u4eec\u5206\u522b\u5efa\u51fa\u6765 1.\u4ee5 $dfs$ \u5e8f\u4e3a\u5916\u5c42\u7684\u6811 2.\u4ee5 $dep$ \u4e3a\u5916\u5c42\u7684\u6811 \u8fd9\u4e24\u79cd\u6811\u5373\u53ef\u3002\n```cpp\n#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, q, x, y, z, tot, DFN, opt, cnt, lca;\nconst int N = 100010;\nint head[N], to[N << 1], nt[N << 1], v[N], dfn[N], nfd[N], siz[N], son[N], top[N], dep[N], fa[N], root1[N], root2[N], tr[N * 63][2], sum[N * 63];\nvoid add(int f, int t)\n{\n\tto[++tot] = t; nt[tot] = head[f]; head[f] = tot;\n}\nvoid Insert(int pre, int &k, int x, int t)\n{\n\tk = ++cnt; sum[k] = sum[pre] + 1;\n\tif (!t)return;\n\tint i = (x >> (t - 1)) & 1;\n\ttr[k][!i] = tr[pre][!i]; Insert(tr[pre][i], tr[k][i], x, t - 1);\n}\nint ask(int pre, int k, int x, int t)\n{\n\tif (!t)return 0;\n\tint i = x >> (t - 1) & 1;\n\tif (sum[tr[k][!i]] > sum[tr[pre][!i]])return (1 << (t - 1)) | ask(tr[pre][!i], tr[k][!i], x, t - 1);\n\telse return ask(tr[pre][i], tr[k][i], x, t - 1);\n}\nvoid dfs1(int x, int f)\n{\n\tInsert(root1[f], root1[x], v[x], 30); //\u7236\u5b50\n\tfa[x] = f; siz[x] = 1; dep[x] = dep[f] + 1;\n\tfor (int i = head[x]; i; i = nt[i])\n\t\tif (to[i] != f)\n\t\t{\n\t\t\tdfs1(to[i], x);\n\t\t\tsiz[x] += siz[to[i]];\n\t\t\tif (siz[to[i]] > siz[son[x]])son[x] = to[i];\n\t\t}\n}\nvoid dfs2(int x, int t)\n{\n\ttop[x] = t; dfn[x] = ++DFN; nfd[DFN] = x;\n\tInsert(root2[nfd[DFN - 1]], root2[x], v[x], 30); //\u5b50\u6811\n\tif (son[x])dfs2(son[x], t);\n\telse return;\n\tfor (int i = head[x]; i; i = nt[i])\n\t\tif (to[i] != fa[x] && to[i] != son[x])dfs2(to[i], to[i]);\n}\nint LCA(int x, int y)\n{\n\twhile (top[x] != top[y])\n\t{\n\t\tif (dep[top[x]] < dep[top[y]])swap(x, y);\n\t\tx = fa[top[x]];\n\t}\n\treturn dep[x] < dep[y] ? x : y;\n}\nint main()\n{\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; ++i)scanf(\"%d\", &v[i]);\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tadd(x, y); add(y, x);\n\t}\n\tdfs1(1, 0); dfs2(1, 1);\n\twhile (q--)\n\t{\n\t\tscanf(\"%d\", &opt);\n\t\tif (opt == 1)\n\t\t{\n\t\t\tscanf(\"%d%d\", &x, &z);\n\t\t\tprintf(\"%d\\n\", ask(root2[nfd[dfn[x] - 1]], root2[nfd[dfn[x] + siz[x] - 1]], z, 30));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\t\tlca = LCA(x, y);\n\t\t\tprintf(\"%d\\n\", max(ask(root1[fa[lca]], root1[x], z, 30), ask(root1[fa[lca]], root1[y], z, 30)));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1587335125,
        "uid": 153843,
        "name": "wljss",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u5b50\u6811\u67e5\u8be2\uff0c\u4e5f\u5c31\u662f\u8bf4dfs\u5e8f\u4e0a\u7684\u8fde\u7eed\u4e00\u6bb5\u4e86\uff0c\u4e5f\u5c31\u8f6c\u5316\u6210\u4e86\u533a\u95f4\u95ee\u9898\n\n\u94fe\u4e0a\u67e5\u8be2\uff0c\u76f8\u5f53\u4e8ex\u5230lca\uff0cy\u5230lca\u67e5\u8be2\uff0c\u4e5f\u5c31\u76f8\u5f53\u4e8e\u533a\u95f4\u95ee\u9898\u4e86\n\n\u533a\u95f4\u95ee\u9898\uff1f\u8fd9\u4e0d\u5c31\u662f\u53ef\u6301\u4e45\u5316trie\u6811\u7684\u6a21\u677f\u9898\u4e48\n\n\u8003\u8651\u7ed9\u5b9a\u4e00\u4e2a\u96c6\u5408\uff0c\u6bcf\u6b21\u67e5\u8be2y\uff0c\u627e\u4e00\u4e2ax\u4f7f\u5f97x xor y\u6700\u5927\n\n\u4e0d\u59a8\u5c06\u96c6\u5408\u4e2d\u7684\u5143\u7d20\u6309\u7167\u4e8c\u8fdb\u5236\u4ece\u9ad8\u5411\u4f4e\u4f4d\u63d2\u5165\u5230trie\u4e2d\uff08\u5b57\u5178\u96c6\u5927\u5c0f\u4e3a2\uff09\n\n\u90a3\u4e48\u5bf9\u4e8ey\uff0c\u53ea\u9700\u8981\u4ece\u9ad8\u5f80\u4f4e\u4f4d\u8d2a\u5fc3\u7684\u53bb\u8dd1\u5c31\u53ef\u4ee5\u4e86\n\n\u6bd4\u5982\u8bf4y\u7684\u5f53\u524d\u4f4d\u4e3abit\uff0c\u90a3\u4e48\u8981\u8d2a\u5fc3\u7684\u8bdd\uff0c\u5fc5\u987b\u8d70bit xor 1\u90a3\u4e2a\u4e0b\u4e00\u4f4d\n\n\u53ea\u8981\u4f60\u7a7a\u95f4\u5f00\u5bf9\u4e86\uff0c\u4ee5\u53ca\u6ca1\u6709\u72af\u4e00\u4e9bzz\u9519\u8bef\uff0c\u5c31\u53ef\u4ee51A\u4e86\n\n``` cpp\n// luogu-judger-enable-o2\n#include \"bits/stdc++.h\"\nusing namespace std;\nconst int N = 1e5 + 10;\ntypedef long long ll;\n\nint n, q, val[N];\n\nint head[N], rest[N * 2], to[N * 2], tot;\n\nvoid add(int u, int v) {\n    to[++ tot] = v, rest[tot] = head[u], head[u] = tot;\n}\n\nstruct Trie {\n    int root[N], tot, ch[N * 35][2], cnt[N * 35];\n    Trie() { root[0] = tot = 1; }\n    void ins(int last, int &now, int x) {\n        int rt = now = ++ tot;\n        for(int i = 30 ; ~ i ; -- i) {\n            int bit = (x >> i) & 1;\n            ch[rt][!bit] = ch[last][!bit];\n            ch[rt][bit] = ++ tot;\n            rt = ch[rt][bit];\n            last = ch[last][bit];\n            cnt[rt] = cnt[last] + 1;\n        }\n    }\n    int query(int L, int R, int x) {\n        int res = 0;\n        for(int i = 30 ; ~ i ; -- i) {\n            int bit = (x >> i) & 1;\n            if(cnt[ch[R][!bit]] - cnt[ch[L][!bit]]) {\n                R = ch[R][!bit];\n                L = ch[L][!bit];\n                res |= 1 << i;\n            } else {\n                R = ch[R][bit];\n                L = ch[L][bit];\n            }\n        }\n        return res;\n    }\n} seq, tre;\n\nint dfn[N], l[N], r[N], clk, fa[N][30], dep[N];\n\nvoid dfs(int u, int fa) {\n    tre.ins(tre.root[fa], tre.root[u], val[u]);\n    :: fa[u][0] = fa;\n    dep[u] = dep[fa] + 1;\n    l[u] = ++ clk;\n    dfn[clk] = val[u];\n    for(int i = head[u] ; i ; i = rest[i]) {\n        int v = to[i];\n        if(v == fa) continue;\n        dfs(v, u);\n    }\n    r[u] = clk;\n}\n\nint lca(int u, int v) {\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 25 ; ~ i ; -- i)\n        if(dep[fa[u][i]] >= dep[v])\n            u = fa[u][i];\n    if(u == v) return u;\n    for(int i = 25 ; ~ i ; -- i)\n        if(fa[u][i] != fa[v][i])\n            u = fa[u][i],\n            v = fa[v][i];\n    return fa[u][0];\n}\n\nint main() {\n\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1 ; i <= n ; ++ i) scanf(\"%d\", &val[i]);\n    for(int i = 1, u, v ; i < n ; ++ i) {\n        scanf(\"%d%d\", &u, &v);\n        add(u, v), add(v, u);\n    }\n    dfs(1, 0);\n    for(int j = 1 ; j <= 25 ; ++ j)\n        for(int i = 1 ; i <= n ; ++ i)\n            fa[i][j] = fa[fa[i][j - 1]][j - 1];\n    for(int i = 1 ; i <= n ; ++ i) {\n        seq.ins(seq.root[i - 1], seq.root[i], dfn[i]);\n    }\n    for(int i = 1, op, x, y, z ; i <= q ; ++ i) {\n        scanf(\"%d%d%d\", &op, &x, &y);\n        if(op == 1) {\n            printf(\"%d\\n\", seq.query(seq.root[l[x] - 1], seq.root[r[x]], y));\n        } else {\n            scanf(\"%d\", &z);\n            int d = lca(x, y);\n            printf(\"%d\\n\", max(tre.query(tre.root[fa[d][0]], tre.root[x], z), tre.query(tre.root[fa[d][0]], tre.root[y], z)));\n        }\n    }\n}\n```",
        "postTime": 1531057879,
        "uid": 47111,
        "name": "nekko",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u5176\u5b9e\u8fd9\u9053\u9898\u5f88\u6c34\uff1f\n\n\u597d\u4e45\u6ca1\u6709\u6253\u6301\u4e45\u5316 trie \u7684\u6211\u8fd8\u662f~~\u7528\u5c0f\u53f7~~ \u4e00\u904d A \u6389\u4e86\uff08\u6211\u4f1a\u544a\u8bc9\u4f60\u6211\u7528\u5927\u53f7\u4ea4\u7684\u65f6\u5019\u6539\u4e86\u4e0b\u6570\u7ec4\u5927\u5c0f\u7ed3\u679c RE \u4e86\u4e48\uff1f\uff09\n\n# noteskey\n\n\u53cd\u6b63\u5c31\u662f\u6811\u5256+\u53ef\u6301\u4e45\u5316 trie \u5566\uff0c\u633a\u88f8\u7684\u5427...\n\n\u73b0\u5728\u8fd8\u662f\u5f88\u6d41\u884c\u6811\u4e0a\u73a9\u6e38\u620f\u7684\u554a...\n\n\u603b\u4e4b\u6253\u7684\u65f6\u5019\u6ce8\u610f\u4e00\u70b9\u7ec6\u8282\u5c31\u597d\u4e86\u5427...\n\n# code\n\n\u4f5c\u4e3a\u6570\u636e\u7ed3\u6784\u9898\u8fd9\u4ee3\u7801\u591f\u77ed\u7684\u4e86\uff08\u4f55\u51b5\u4e24\u4e2a\u6570\u636e\u7ed3\u6784\uff09\n\n```cpp\n//by Judge\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define Rg register\n#define fp(i,a,b) for(Rg int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(Rg int i=(a),I=(b)-1;i>I;--i)\n#define go(G,u) for(Rg int i=G.head[u],v=G.e[i].to;i;v=G.e[i=G.e[i].nxt].to)\n#define ll long long\nusing namespace std;\nconst int N=1<<30|3;\nconst int M=6e6+3;\ntypedef int arr[M];\n#ifndef Judge\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n#endif\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline bool cmax(int& a,int b){return a<b?a=b,1:0;}\ninline int read(){ int x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;\n} char sr[1<<21],z[20];int CCF=-1,Z;\ninline void Ot(){fwrite(sr,1,CCF+1,stdout),CCF=-1;}\ninline void print(int x,char chr='\\n'){\n    if(CCF>1<<20)Ot();if(x<0)sr[++CCF]=45,x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++CCF]=z[Z],--Z);sr[++CCF]=chr;\n} int n,q,cnt,tim,ans,to[M][2],d[33],num[M];\narr a,siz,dep,f,son,top,dfn,rt;\nstruct Gr{ int pat,head[M];\n\tstruct Edge{ int to,nxt; }e[M<<1];\n\tinline void add(int u,int v){\n\t\te[++pat]={v,head[u]},head[u]=pat;\n\t\te[++pat]={u,head[v]},head[v]=pat;\n\t}\n}G;\ninline void div(int x){ fp(i,0,30) d[i]=x&1,x>>=1; }\ninline void update(int now,int las){\n\tfor(int k=30;~k;--k,num[now]=num[las]+1)\n\t\tto[now][d[k]^1]=to[las][d[k]^1],\n\t\tnow=to[now][d[k]]=++cnt,las=to[las][d[k]];\n}\ninline int query(int u,int v){ int ans=0;\n\tfor(int k=30;~k;--k)\n\t\tif(num[to[v][d[k]^1]]-num[to[u][d[k]^1]])\n\t\t\tans|=1<<k,u=to[u][d[k]^1],v=to[v][d[k]^1];\n\t\telse u=to[u][d[k]],v=to[v][d[k]]; return ans;\n}\nvoid dfs(int u,int fa){\n\tsiz[u]=1,dep[u]=dep[fa]+1;\n\tgo(G,u) if(v^fa){\n\t\tf[v]=u,dfs(v,u),siz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]]) son[u]=v;\n\t}\n}\nvoid dfs(int u){ dfn[u]=++tim; if(!top[u]) top[u]=u;\n\tdiv(a[u]),rt[tim]=++cnt,update(rt[tim],rt[tim-1]);\n\tif(son[u]) top[son[u]]=top[u],dfs(son[u]);\n\tgo(G,u) if(v^f[u]&&v^son[u]) dfs(v);\n}\ninline int ask(int u,int v,int w){ ans=0,div(w);\n\tfor(;top[u]^top[v];u=f[top[u]]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tcmax(ans,query(rt[dfn[top[u]]-1],rt[dfn[u]]));\n\t} if(dep[u]>dep[v]) swap(u,v);\n\treturn cmax(ans,query(rt[dfn[u]-1],rt[dfn[v]])),ans;\n}\ninline int ask(int u,int w){ ans=0,div(w);\n\treturn query(rt[dfn[u]-1],rt[dfn[u]+siz[u]-1]);\n}\nint main(){ n=read(),q=read();\n\tfp(i,1,n) a[i]=read(); int x,y;\n\tfp(i,2,n) x=read(),y=read(),G.add(x,y);\n\tfor(dfs(1,0),dfs(1);q;--q){ int op=read(),x,y,z;\n\t\tif(op&1) x=read(),y=read(),print(ask(x,y));\n\t\telse x=read(),y=read(),z=read(),print(ask(x,y,z));\n\t} return Ot(),0;\n}\n```",
        "postTime": 1554644508,
        "uid": 38576,
        "name": "J\u03bcdge",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u6c42\u5b50\u6811\u6216x-y\u8def\u5f84\u4e0a\u4efb\u610f\u4e00\u4e2a\u6570\u548c\u67d0\u4e2a\u6570\u5f02\u6216\u503c\u6700\u5927\n\u5206\u522bdfs\u5e8f\u548c\u5230\u6839\u5efa\u53ef\u6301\u4e45\u5316trie\u6811\n\u6bcf\u6b21\u52a0\u52a0\u51cf\u51cf\u5f97\u5230\u4e92\u76f8\u7684\u5173\u7cfb \u5728trie\u6811\u4e0a\u8d2a\u5fc3\u5373\u53ef\n```\n#include<cstdio>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\ninline char gc(){\n\tstatic char now[1<<16],*S,*T;\n\tif (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0,f=1;char ch=gc();\n\twhile(!isdigit(ch)) {if (ch=='-') f=-1;ch=gc();}\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=gc();\n\treturn x*f;\n}\nconst int N=1e5+10;\nstruct node{\n\tint sum[2],ch[2];\n}tree1[N*33],tree2[N*33];\nstruct node1{\n\tint y,next;\n}data[N<<1];\nint h[N],cnt1,cnt2,num,rt1[N],rt2[N],fa[N][20],v[N],dep[N],Log[N],n,q,in[N],out[N],ans,bin[33];\ninline void init1(int &x){tree1[++cnt1]=tree1[x];x=cnt1;}\ninline void insert1(int &x,int v){\n\tinit1(x);int p=x;\n\tfor (int i=30,op;~i;--i){\n\t\top=(v&bin[i])>0;\n\t\t++tree1[p].sum[op];init1(tree1[p].ch[op]);p=tree1[p].ch[op];\n\t}\n}\ninline void init2(int &x){tree2[++cnt2]=tree2[x];x=cnt2;}\ninline void insert2(int &x,int v){\n\tinit2(x);int p=x;\n\tfor (int i=30,op;~i;--i){\n\t\top=(v&bin[i])>0;\n\t\t++tree2[p].sum[op];init2(tree2[p].ch[op]);p=tree2[p].ch[op];\n\t}\n}\ninline void query1(int rt1,int rt2,int v){\n\tfor (int i=30,op;~i;--i){\n\t\top=(v&bin[i])>0;\n\t\tif (tree1[rt2].sum[op^1]-tree1[rt1].sum[op^1]){\n\t\t\tans+=bin[i];rt2=tree1[rt2].ch[op^1];rt1=tree1[rt1].ch[op^1];\n\t\t}else rt2=tree1[rt2].ch[op],rt1=tree1[rt1].ch[op];\n\t}\n}\ninline void query2(int rt1,int rt2,int rt3,int rt4,int v){\n\tfor (int i=30,op;~i;--i){\n\t\top=(v&bin[i])>0;\n\t\tif (tree2[rt4].sum[op^1]+tree2[rt3].sum[op^1]-tree2[rt2].sum[op^1]-tree2[rt1].sum[op^1]){\n\t\t\trt4=tree2[rt4].ch[op^1];rt3=tree2[rt3].ch[op^1];ans+=bin[i];\n\t\t\trt2=tree2[rt2].ch[op^1];rt1=tree2[rt1].ch[op^1];\n\t\t}else{\n\t\t\trt4=tree2[rt4].ch[op];rt3=tree2[rt3].ch[op];\n\t\t\trt2=tree2[rt2].ch[op];rt1=tree2[rt1].ch[op];\n\t\t}\n\t}\n}\ninline void dfs(int x){\n\tin[x]=++num;rt1[in[x]]=rt1[in[x]-1];insert1(rt1[in[x]],v[x]);insert2(rt2[x],v[x]);\n\tfor (int i=h[x];i;i=data[i].next){\n\t\tint y=data[i].y;if (y==fa[x][0]) continue;\n\t\tfa[y][0]=x;dep[y]=dep[x]+1;rt2[y]=rt2[x];\n\t\tfor (int j=1;j<=Log[dep[y]];++j) fa[y][j]=fa[fa[y][j-1]][j-1];dfs(y);\n\t}out[x]=num;\n}\ninline int lca(int x,int y){\n\tif (dep[x]<dep[y]) swap(x,y);int dis=dep[x]-dep[y];\n\tfor (int i=0;i<=Log[dis];++i) if (dis&(1<<i)) x=fa[x][i];\n\tif (x==y) return x;\n\tfor (int i=Log[dep[y]];~i;--i)\n\t\tif (fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\nint main(){\n\tfreopen(\"xor.in\",\"r\",stdin);\n\tfreopen(\"xor.out\",\"w\",stdout);\n\tn=read();q=read();Log[0]=-1;\n\tfor (int i=0;i<=30;++i) bin[i]=1<<i;\n\tfor (int i=1;i<=n;++i) v[i]=read(),Log[i]=Log[i>>1]+1;\n\tfor (int i=1;i<n;++i){\n\t\tint x=read(),y=read();\n\t\tdata[++num].y=y;data[num].next=h[x];h[x]=num;\n\t\tdata[++num].y=x;data[num].next=h[y];h[y]=num;\n\t}num=0;dfs(1);\n\tfor (int i=1;i<=q;++i){\n\t\tint op=read();\n\t\tif (op==1){\n\t\t\tint x=read(),z=read();ans=0;\n\t\t\tquery1(rt1[in[x]-1],rt1[out[x]],z);printf(\"%d\\n\",ans);\n\t\t}else{\n\t\t\tint x=read(),y=read(),z=read(),t=lca(x,y);ans=0;\n\t\t\tquery2(rt2[fa[t][0]],rt2[t],rt2[x],rt2[y],z);printf(\"%d\\n\",ans);\n\t\t}\n\t}\n}\n```",
        "postTime": 1526469898,
        "uid": 5037,
        "name": "elijahqi",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u5bf9\u4e8e\u9898\u76ee\u7ed9\u51fa\u7684\u4e24\u4e2a\u67e5\u8be2\uff0c\u6211\u4eec\u6211\u53ef\u4ee5\u5c06\u5b83\u8fd9\u6837\u8f6c\u6362\uff1a\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u7528dfs\u5e8f\u5c06\u4e00\u4e2a\u5b50\u6811\u8f6c\u5316\u4e3a\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4,\u7136\u540e\u6839\u636edfs\u5e8f\u5efa\u7acb\u4e00\u4e2atrie\u6811\uff0c\u90a3\u4e48\u67e5\u8be2\u4e00\u4e2a\u5b50\u6811\u5373\u4e3a\u67e5\u8be2\u4e00\u6bb5\u533a\u95f4\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e8c\uff0c\u6839\u636e\u6839\u5230\u7ed3\u70b9\u7684\u8def\u5f84\u5efa\u7acb\u4e00\u4e2atrie\u6811,\u540c\u6837\u4e5f\u53ef\u4ee5\u8f6c\u5316\u4e3a\u4e00\u4e2a\u533a\u95f4\u67e5\u8be2\n\n\u4e8e\u662f\u5c31\u53ef\u4ee5\u5efa\u4e24\u4e2atrie\u6811,\u5206\u522b\u5bf9\u5e94\u4e24\u4e2a\u64cd\u4f5c\n\n\u7ed3\u5408\u4ee3\u7801\u7406\u89e3\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int N = 4e5 + 50, M = 32 * N;\n\nint tr1[M][2], root1[N], tot1, siz[N];\nint w[N], n, q, maxn[M], id[N], it[N];\nint head[N], ver[N], net[N], idx, cnt, root2[N];\nint tr2[M][2], dep[N], fa[N][25], maxd[M], tot2;\n\nvoid add(int a, int b)\n{\n    net[idx] = head[a];\n    ver[idx] = b;\n    head[a] = idx++;\n}\n\nvoid insert1(int p, int q, int i, int k)\n{\n    if (i < 0)\n    {\n        maxn[p] = k;//\u8bb0\u5f55\u4e00\u4e0b\u6700\u5927dfs\u5e8f\n        return;\n    }\n    int v = w[it[k]] >> i & 1;\n    if (q)\n        tr1[p][!v] = tr1[q][!v];\n    tr1[p][v] = ++tot1;   \n    insert1(tr1[p][v], tr1[q][v], i - 1, k);\n    maxn[p] = max(maxn[tr1[p][0]], maxn[tr1[p][1]]);\n    return;\n}\n\nvoid insert2(int p, int q, int i, int k)\n{\n    if (i < 0)\n    {\n        maxd[p] = dep[k];//\u8bb0\u5f55\u4e00\u4e0b\u6700\u5927\u6df1\u5ea6\n        return;\n    }\n    int v = w[k] >> i & 1;\n    if (q)\n        tr2[p][!v] = tr2[q][!v];\n    tr2[p][v] = ++tot2;\n    insert2(tr2[p][v], tr2[q][v], i - 1, k);\n    maxd[p] = max(maxd[tr2[p][0]], maxd[tr2[p][1]]);\n    return;\n}\n\nint query1(int p, int v, int l)\n{\n    for (int i = 30; ~i; --i)\n    {\n        int s = v >> i & 1;\n        if (maxn[tr1[p][!s]] >= l)\n            p = tr1[p][!s];\n        else\n            p = tr1[p][s];\n    }\n    return v ^ w[it[maxn[p]]];\n}\n\nint query2(int p, int v, int l)\n{\n    int res = 0;\n    for (int i = 30; ~i; --i)\n    {\n        int s = v >> i & 1;\n        if (maxd[tr2[p][!s]] >= l)\n            p = tr2[p][!s], res += 1 << i;\n        else\n            p = tr2[p][s];\n    }\n    return res;\n}\n\nvoid dfs(int u, int f)\n{\n    id[u] = ++cnt, it[cnt] = u;\n    siz[u] = 1, dep[u] = dep[f] + 1, fa[u][0] = f;\n    for (int i = 1; i <= 20; i++)\n        fa[u][i] = fa[fa[u][i - 1]][i - 1];\n    root2[u] = ++tot2;\n    insert2(root2[u], root2[f], 30, u);//\u6309\u7167\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u5efa\u6811\n    for (int i = head[u]; ~i; i = net[i])\n    {\n        int v = ver[i];\n        if (v == f)\n            continue;\n        dfs(v, u);\n        siz[u] += siz[v];\n    }\n}\n\nint lca(int x, int y)\n{\n    if (dep[x] > dep[y])\n        swap(x, y);\n    for (int i = 20; ~i; --i)\n        if (dep[fa[y][i]] >= dep[x])\n            y = fa[y][i];\n    if (x == y)\n        return x;\n    for (int i = 20; ~i; --i)\n        if (fa[x][i] != fa[y][i])\n            x = fa[x][i], y = fa[y][i];\n    return fa[x][0];\n}\n\nint main()\n{\n    memset(head, -1, sizeof(head));\n    scanf(\"%d%d\", &n, &q);\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", &w[i]);\n    for (int i = 1; i < n; i++)\n    {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        add(u, v), add(v, u);\n    }\n    dfs(1, 0);\n    for (int i = 1; i <= n; i++)\n    {\n        root1[i] = ++tot1;\n        insert1(root1[i], root1[i - 1], 30, i);\n    }\n    while (q--)\n    {\n        int op, x, y, z;\n        scanf(\"%d\", &op);\n        if (op == 1)\n        {\n            scanf(\"%d%d\", &x, &z);\n            printf(\"%d\\n\", query1(root1[id[x] + siz[x] - 1], z, id[x]));//\u67e5\u627ex\u7684\u5b50\u6811,\n        }\n        else\n        {\n            scanf(\"%d%d%d\", &x, &y, &z);\n            int u = lca(x, y);\n            printf(\"%d\\n\", max(query2(root2[x], z, dep[u]), query2(root2[y], z, dep[u])));\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1614565884,
        "uid": 277863,
        "name": "BzhH",
        "ccfLevel": 6,
        "title": "[TJOI2018]\u5f02\u6216 \u9898\u89e3"
    },
    {
        "content": "[$myblog$](https://www.cnblogs.com/Isaunoya/p/11771880.html)\n\n[Problem](https://www.luogu.org/problem/P4592)\n\n- 1 $x,y$\uff1a\u67e5\u8be2\u8282\u70b9$x$\u7684\u5b50\u6811\u4e2d\u4e0e$y$\u5f02\u6216\u7ed3\u679c\u7684\u6700\u5927\u503c\n- 2 $x,y,z$\uff1a\u67e5\u8be2\u8def\u5f84$x$\u5230$y$\u4e0a\u70b9\u4e0e$z$\u5f02\u6216\u7ed3\u679c\u6700\u5927\u503c\n\n\u770b\u5230\u533a\u95f4\u5f02\u6216\u7684\u6700\u5927\u503c \u4e0d\u96be\u60f3\u5230 `\u53ef\u6301\u4e45\u5316trie`\n\n\u7528\u6811\u5256\u628a\u8fd9\u4e9b\u5256\u6210\u94fe \u6bcf\u6b21\u5c31\u662f\u94fe\u7684\u67e5\u8be2\u3002\u3002\u8fd9\u6837\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```cpp\n\n#include<bits/stdc++.h>\nusing namespace std ;\nint n , q ;\nconst int N = 1e5 + 10 ;\nstruct node { int v , nxt ; } e[N << 1] ;\nint val[N] ;\nint head[N] , cnt = 0 ;\ninline void add(int u , int v) { e[++ cnt] = { v , head[u] } ; head[u] = cnt ; }\nint size[N] , son[N] , fa[N] , d[N] ;\ninline void dfs1(int u) { size[u] = 1 ;\n  for(int i = head[u] ; i ; i = e[i].nxt) {\n    int v = e[i].v;\n    if(v == fa[u]) continue ;\n    fa[v] = u ; d[v] = d[u] + 1 ;\n    dfs1(v) ;\n    size[u] += size[v] ;\n    if(size[v] > size[son[u]]) son[u] = v ;\n  }\n}\nint top[N] , id[N] , idx = 0 , a[N] ;\ninline void dfs2(int u , int t) {\n  top[u] = t ; id[u] = ++ idx ; a[idx] = val[u] ;\n  if(! son[u]) return ; dfs2(son[u] , t) ;\n  for(int i = head[u] ; i ; i = e[i].nxt) {\n    int v = e[i].v ;\n    if(v == fa[u]) continue ;\n    if(v == son[u]) continue ;\n    dfs2(v , v) ;\n  }\n}\nint tot = 0 ;\nint t[N] ; int ch[N << 5][2] ;\nint sz[N << 5] ;\ninline void upd(int x , int p , int q) {\n\tch[p][0] = ch[q][0] ; ch[p][1] = ch[q][1] ; sz[p] = sz[q] + 1 ;\n\tfor(register int i = 29 ; ~ i ; i --) {\n\t\tint c = (x >> i) & 1 ;\n\t\tch[p][c] = ++ tot ;\n\t\tp = ch[p][c] ;\n\t\tq = ch[q][c] ;\n\t\tch[p][0] = ch[q][0] ;\n\t\tch[p][1] = ch[q][1] ;\n\t\tsz[p] = sz[q] + 1 ;\n\t}\n}\ninline int query(int x , int p , int q) {\n  int res = 0 ;\n\tfor(register int i = 29 ; ~ i ; i --) {\n\t\tint c = (x >> i) & 1 ;\n\t\tif(sz[ch[q][c ^ 1]] - sz[ch[p][c ^ 1]]) res |= 1 << i , p = ch[p][c ^ 1] , q = ch[q][c ^ 1] ;\n\t\telse p = ch[p][c] , q = ch[q][c] ;\n\t} return res ;\n}\ninline int query_range(int x , int y , int val) {\n  int fx = top[x] , fy = top[y] ; int res = 0 ;\n  while(fx ^ fy) {\n    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n    res = max(res , query(val , t[id[fx] - 1] , t[id[x]])) ;\n    x = fa[fx] , fx = top[x] ;\n  }\n  if(d[x] > d[y]) swap(x , y) ;\n  res = max(res , query(val , t[id[x] - 1] , t[id[y]])) ;\n  return res ;\n}\nsigned main() {\n  ios :: sync_with_stdio(false) ;\n  cin.tie(nullptr) ;\n  cout.tie(nullptr) ;\n  cin >> n >> q ;\n  for(register int i = 1 ; i <= n ; i ++) cin >> val[i] ;\n  for(register int i = 1 ; i <= n - 1 ; i ++) {\n    int u , v ; cin >> u >> v ;\n    add(u , v) ; add(v , u) ;\n  } dfs1(1) ; dfs2(1 , 1) ;\n  for(register int i = 1 ; i <= n ; i ++) t[i] = ++ tot , upd(a[i] , t[i] , t[i - 1]) ;\n  for(register int i = 1 ; i <= q ; i ++) {\n    int opt ; cin >> opt ;\n    if(opt == 1) {\n      int x , y ;\n      cin >> x >> y ;\n      cout << query(y , t[id[x] - 1] , t[id[x] + size[x] - 1]) << '\\n' ;\n    }\n    else {\n      int x , y , z ;\n      cin >> x >> y >> z ;\n      cout << query_range(x , y , z) << '\\n' ;\n    }\n  }\n  return 0 ;\n}\n```",
        "postTime": 1572509859,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "\u7ed9\u4e2a\u6bd4\u8f83\u5c0f\u6e05\u65b0\u7684\u505a\u6cd5\uff0c\u6211\u4eec\u6ce8\u610f\u52301\u64cd\u4f5c\u548c2\u64cd\u4f5c\u4e92\u4e0d\u5e72\u6270\u800c\u4e14\u4e0d\u5e26\u4fee\u6539\uff0c\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f88\u8f7b\u6613\u5730\u7528\u79bb\u7ebf\u505a\u6cd5\u505a\u5230nlogn\u7684\u590d\u6742\u5ea6\u30021\u64cd\u4f5c1\u91c7\u7528dsu on tree \u79bb\u7ebf\u5904\u7406\uff0c\u64cd\u4f5c2\u53ef\u4ee5\u7528\u7c7b\u4f3c\u6811\u4e0a\u70b9\u6743k\u5c0f\u7684\u505a\u6cd5\u53bb\u89e3\u51b3\uff0c\u8fd9\u6837\u5b50\u8fd9\u9898\u5c31\u53d8\u6210\u6bd4\u8f83\u65e0\u8111\u7684\u7801\u519c\u9898\u4e86/\n\n\nAC\u4ee3\u7801\uff1a\n```cpp\nnamespace trie01\n{\n\tconst int sigma = 32;\n\tlong long base = 1;\n\tstruct node\n\t{\n\t\tnode *child[2];\n\t\tint times;\n\t\tint element;\n\t\tbool lazy;\n\t\tvoid clear()\n\t\t{\n\t\t\tlazy = times = element = 0;\n\t\t}\n\t};\n\tnode *prefix[120000], *dsu[120000];\n\tint ans[120000], w[120000];\n\tvector<pair<int, int> > query1[120000];\n\tqueue<tuple<int, int, int, int> > query2;\n\tnode *history[200000];\n\tnode pool[11000000];\n\tnode *root, *cur = pool, *null;\n\tnode *new_()\n\t{\n\t\tcur->clear();\n\t\tcur->child[0] = cur->child[1] = null;\n\t\treturn cur++;\n\t}\n\tvoid init()\n\t{\n\t\tnull = new node();\n\t\tnull->times = null->element = null->lazy = 0;\n\t\tnull->child[0] = null->child[1] = null;\n\t\tcur = pool;\n\t\troot = new_();\n\t\thistory[0] = new_();\n\t}\n\tvoid insert(node *ver_s, int pos, int element, int add)\n\t{\n\t\tnode *found = ver_s;\n\t\tbitset<sigma + 1> kkk = pos;\n\t\tfound->times += add;\n\t\tfor (int i = sigma; i >= 0; --i)\n\t\t{\n\t\t\tif (found->child[kkk[i]] == null)\n\t\t\t{\n\t\t\t\tfound->child[kkk[i]] = new_();\n\t\t\t\tfound = found->child[kkk[i]];\n\t\t\t}\n\t\t\telse\n\t\t\t\tfound = found->child[kkk[i]];\n\t\t\tfound->times += add;\n\t\t}\n\t\tfound->element = element;\n\t}\n\tnode *insert_new(int pos, int element, node *old, int add)\n\t{\n\t\tnode *found = old, *_new = new_(), *_new2;\n\t\tbitset<sigma + 1> kkk = pos;\n\t\t_new2 = _new;\n\t\tfor (int i = sigma; i >= 0; --i)\n\t\t{\n\t\t\t_new->times += add;\n\t\t\t_new->child[kkk[i]] = new_();\n\t\t\tif (found == null)\n\t\t\t\t_new = _new->child[kkk[i]];\n\t\t\telse\n\t\t\t{\n\t\t\t\t_new->times += found->times;\n\t\t\t\t_new->child[!kkk[i]] = found->child[!kkk[i]];\n\t\t\t\t_new = _new->child[kkk[i]];\n\t\t\t\tfound = found->child[kkk[i]];\n\t\t\t}\n\t\t}\n\t\t_new->times += found->times;\n\t\t_new->times += add;\n\t\t_new->element = element;\n\t\treturn _new2;\n\t}\n\tvoid merge(node *a, node *b)\n\t{\n\t\tb->times += a->times;\n\t\tfor (int i = 0; i < 2; ++i)\n\t\t{\n\t\t\tif (a->child[i] != null && b->child[i] != null)\n\t\t\t\tmerge(a->child[i], b->child[i]);\n\t\t\telse if (b->child[i] == null)\n\t\t\t\tb->child[i] = a->child[i];\n\t\t}\n\t}\n\tint querymax(node *p, int a)\n\t{\n\t\tbitset<sigma + 1> kkk = a, ans;\n\t\tfor (int i = sigma; i >= 0; --i)\n\t\t{\n\t\t\tif (p->child[!kkk[i]] != null && p->child[!kkk[i]]->times > 0)\n\t\t\t\tp = p->child[!kkk[i]], ans[i] = !kkk[i];\n\t\t\telse\n\t\t\t\tp = p->child[kkk[i]], ans[i] = kkk[i];\n\t\t}\n\t\treturn ans.to_ulong() ^ a;\n\t}\n\tint querymax(int a, int u, int v, int lca, int fal)\n\t{\n\t\tbitset<sigma + 1> kkk = a, ans;\n\t\tnode *pu = prefix[u], *pv = prefix[v], *plca = prefix[lca], *falca;\n\t\tif (lca == 1)\n\t\t\tfalca = null;\n\t\telse\n\t\t\tfalca = prefix[fal];\n\t\tfor (int i = sigma; i >= 0; --i)\n\t\t{\n\t\t\tint kk = pu->child[!kkk[i]]->times + pv->child[!kkk[i]]->times - plca->child[!kkk[i]]->times - falca->child[!kkk[i]]->times;\n\t\t\tif (kk > 0)\n\t\t\t\tpu = pu->child[!kkk[i]], pv = pv->child[!kkk[i]], plca = plca->child[!kkk[i]], ans[i] = !kkk[i], falca = falca->child[!kkk[i]];\n\t\t\telse\n\t\t\t\tpu = pu->child[kkk[i]], pv = pv->child[kkk[i]], plca = plca->child[kkk[i]], ans[i] = kkk[i], falca = falca->child[kkk[i]];\n\t\t}\n\t\treturn ans.to_ulong() ^ a;\n\t}\n}\nusing namespace trie01;\nconst int maxn = 120000;\nconst int max2 = 22;\nvector<int> edge[120000];\nint father[max2][maxn];\nint depth[maxn];\nvoid addedge(int u, int v)\n{\n\tedge[u].emplace_back(v);\n\tedge[v].emplace_back(u);\n}\nvoid dfs2(int x)\n{\n\tfor (auto &s : edge[x])\n\t{\n\t\tif (father[0][x] != s)\n\t\t{\n\t\t\tfather[0][s] = x;\n\t\t\tdepth[s] = depth[x] + 1;\n\t\t\tdfs2(s);\n\t\t}\n\t}\n}\nvoid  build(int root, int n)\n{\n\tdepth[root] = 1;\n\tdfs2(root);\n\tfor (int k = 0; k < max2; k++)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (father[k][i])\n\t\t\t\tfather[k + 1][i] = father[k][father[k][i]];\n}\nint LCA(int u, int v)\n{\n\tif (depth[u] > depth[v])\n\t\treturn LCA(v, u);\n\tif (depth[u] != depth[v]) {\n\t\tfor (int k = 20 - 1; k >= 0; k--) {\n\t\t\tif (depth[v] - (1 << k) >= depth[u])\n\t\t\t\tv = father[k][v];\n\t\t}\n\t}\n\tif (u == v) return u;\n\tfor (int k = max2 - 1; k >= 0; k--) {\n\t\tif (father[k][u] == 0) continue;\n\t\tif (father[k][u] != father[k][v]) {\n\t\t\tu = father[k][u];\n\t\t\tv = father[k][v];\n\t\t}\n\t}\n\treturn father[0][u];\n}\nlong long Max = INT_MAX;\n\nvoid dfs(int cur, int fa)\n{\n\tfor (auto &p : edge[cur])\n\t{\n\t\tif (p != fa)\n\t\t{\n\t\t\tdfs(p, cur);\n\t\t\tmerge(dsu[p],dsu[cur]);\n\t\t}\n\t}\n\tfor (auto &p : query1[cur])\n\t\tans[p.second] = querymax(dsu[cur], p.first);\n}\nvoid dfs1(int cur, int fa)\n{\n\tfor (auto &p : edge[cur])\n\t{\n\t\tif (p != fa)\n\t\t{\n\t\t\tprefix[p] = insert_new(w[p], w[p], prefix[cur], 1);\n\t\t\tdfs1(p, cur);\n\t\t}\n\t}\n}\nint32_t main()\n{\n\tinit();\n\tint n, q, u, v, val, opt;\n\tcin >> n >> q;\n\tfor (int i = 1; i <= n; ++i)\n\t{\n\t\tcin >> w[i];\n\t\tdsu[i] = new_();\n\t\tinsert(dsu[i], w[i], w[i], 1);\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tcin >> u >> v;\n\t\taddedge(u, v);\n\t}\n\tbuild(1, n);\n\tfor (int i = 1; i <= q; ++i)\n\t{\n\t\tcin >> opt;\n\t\tif (opt == 1)\n\t\t{\n\t\t\tcin >> u >> v;\n\t\t\tquery1[u].emplace_back(v, i);\n\t\t}\n\t\telse if (opt == 2)\n\t\t{\n\t\t\tcin >> u >> v >> val;\n\t\t\tif (u != v)\n\t\t\t\tquery2.push(make_tuple(u, v, val, i));\n\t\t\telse\n\t\t\t\tans[i] = val ^ w[u];\n\t\t}\n\t}\n\tdfs(1, 0);\n\tinit();\n\tprefix[1] = new_();\n\tinsert(prefix[1], w[1], w[1], 1);\n\tdfs1(1, 0);\n\twhile (!query2.empty())\n\t{\n\t\tauto p = query2.front();\n\t\tquery2.pop();\n\t\tint lca = LCA(get<0>(p), get<1>(p)), fal = father[0][lca];\n\t\tans[get<3>(p)] = querymax(get<2>(p), get<0>(p), get<1>(p), lca, fal);\n\t}\n\tfor (int i = 1; i <= q; ++i)\n\t\t cout<< ans[i] << endl;\n\treturn 0;\n}\n```\n",
        "postTime": 1565966737,
        "uid": 154957,
        "name": "qiyue7",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    },
    {
        "content": "# Description\n\n\u73b0\u5728\u6709\u4e00\u9897\u4ee5 $1$ \u4e3a\u6839\u8282\u70b9\u7684\u7531 $n$ \u4e2a\u8282\u70b9\u7ec4\u6210\u7684\u6811\uff0c\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u4e0a\u90fd\u6709\u4e00\u4e2a\u6743\u503c $v_i$\u3002\u73b0\u5728\u6709$Q$\u6b21\u64cd\u4f5c\uff0c\u64cd\u4f5c\u5982\u4e0b\uff1a\n\n - 1 $x$ $y$ \uff1a\u67e5\u8be2\u8282\u70b9 $x$ \u7684\u5b50\u6811\u4e2d\u4e0e $y$ \u5f02\u6216\u7ed3\u679c\u7684\u6700\u5927\u503c\u3002\n - 2 $x$ $y$ $z$ \uff1a\u67e5\u8be2\u8def\u5f84 $x$ \u5230 $y$ \u4e0a\u70b9\u4e0e $z$ \u5f02\u6216\u7ed3\u679c\u6700\u5927\u503c\u3002\n \n# Solution\n\n\u8003\u8651\u53ef\u6301\u4e45\u548cTrie\u3002\n\n\u9996\u5148\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u5efa\u7acb\u53ef\u6301\u4e45\u5316Trie\u3002\n\n\u5bf9\u4e8e\u4e00\u6761\u8def\u5f84\uff0c\u628a\u5b83\u62c6\u5206\u6210$x$\u5230\u6839\u52a0\u4e0a$y$\u5230\u8ddf\u51cf\u53bb$lca$\u5230\u6839\u518d\u51cf\u53bb$lca$\u7684\u7236\u4eb2\u5230\u6839\u7684\u8def\u5f84\u3002\u7136\u540e\u5c31\u53ef\u4ee5\u56de\u7b54\u7c7b\u578b$2$\u7684\u8be2\u95ee\u3002\n\n\u7136\u540e\u5bf9\u4e8e$dfs$\u5e8f\u5efa\u7acb\u53ef\u6301\u4e45\u5316Trie\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a\u5b50\u6811\uff0c\u628a\u5b83\u62c6\u6210$low_x$\u51cf\u53bb$dfn_x-1$\u5373\u53ef\u3002\n\n```cpp\n// luogu-judger-enable-o2\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005;\n\nint n, Q;\nint op[maxn], x[maxn], y[maxn], z[maxn], ans[maxn], v[maxn];\nint dep[maxn], Siz[maxn], son[maxn], dfn[maxn], low[maxn], ord[maxn], Time, fa[maxn], top[maxn];\nint root[maxn], ch[maxn * 35][2], siz[maxn * 35];\n\ninline int gi()\n{\n    char c = getchar();\n    while (c < '0' || c > '9') c = getchar();\n    int sum = 0;\n    while ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n    return sum;\n}\n\nstruct edge\n{\n    int to, next;\n} e[maxn * 2];\nint h[maxn], tot;\n\ninline void add(int u, int v)\n{\n    e[++tot] = (edge) {v, h[u]}; h[u] = tot;\n    e[++tot] = (edge) {u, h[v]}; h[v] = tot;\n}\n\nvoid insert(int &s, int k, int v)\n{\n    ++tot;\n    ch[tot][0] = ch[s][0]; ch[tot][1] = ch[s][1]; siz[tot] = siz[s] + 1;\n    s = tot;\n    if (k == -1) return ;\n    if ((v >> k) & 1) insert(ch[s][1], k - 1, v);\n    else insert(ch[s][0], k - 1, v);\n}\n\nint query(int s1, int s2, int s3, int s4, int v)\n{\n    int t, ans = 0;\n    for (int i = 29; i >= 0; --i) {\n        t = (v >> i) & 1;\n        if (siz[ch[s1][t ^ 1]] + siz[ch[s2][t ^ 1]] - siz[ch[s3][t ^ 1]] - siz[ch[s4][t ^ 1]]) {\n            s1 = ch[s1][t ^ 1];\n            s2 = ch[s2][t ^ 1];\n            s3 = ch[s3][t ^ 1];\n            s4 = ch[s4][t ^ 1];\n            ans ^= 1 << i;\n        } else {\n            s1 = ch[s1][t];\n            s2 = ch[s2][t];\n            s3 = ch[s3][t];\n            s4 = ch[s4][t];\n        }\n    }\n    return ans;\n}\n\nvoid dfs1(int u, int fa)\n{\n    root[u] = root[fa]; Siz[u] = 1;\n    insert(root[u], 29, v[u]);\n    ord[dfn[u] = ++Time] = u; dep[u] = dep[fa] + 1;\n    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n        if (v != fa) {\n            dfs1(v, u);\n            Siz[u] += Siz[v];\n            if (Siz[v] >= Siz[son[u]]) son[u] = v;\n        }\n    low[u] = Time;\n}\n\nvoid dfs2(int u)\n{\n    if (son[u]) fa[son[u]] = u, top[son[u]] = top[u], dfs2(son[u]);\n    for (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n        if (v != fa[u] && v != son[u]) top[v] = v, fa[v] = u, dfs2(v);\n}\n\nint lca(int u, int v)\n{\n    while (top[u] != top[v]) {\n        if (dep[top[u]] > dep[top[v]]) u = fa[top[u]];\n        else v = fa[top[v]];\n    }\n    return dep[u] < dep[v] ? u : v;\n}\n\nint main()\n{\n    n = gi(); Q = gi();\n    for (int i = 1; i <= n; ++i) v[i] = gi();\n    for (int i = 1; i < n; ++i) add(gi(), gi());\n\n    for (int i = 1; i <= Q; ++i) {\n        op[i] = gi(); x[i] = gi(), y[i] = gi();\n        if (op[i] == 2) z[i] = gi();\n    }\n    \n    tot = 0;\n    dfs1(1, 0);\n    top[1] = 1; dfs2(1);\n\n    for (int i = 1; i <= Q; ++i)\n        if (op[i] == 2) ans[i] = query(root[x[i]], root[y[i]], root[lca(x[i], y[i])], root[fa[lca(x[i], y[i])]], z[i]);\n\n    tot = 0;\n    for (int i = 1; i <= n; ++i)\n        root[i] = root[i - 1], insert(root[i], 29, v[ord[i]]);\n\n    for (int i = 1; i <= Q; ++i)\n        if (op[i] == 1) ans[i] = query(root[low[x[i]]], root[0], root[0], root[dfn[x[i]] - 1], y[i]);\n\n    for (int i = 1; i <= Q; ++i) printf(\"%d\\n\", ans[i]);\n    \n    return 0;\n}\n```",
        "postTime": 1551230666,
        "uid": 119899,
        "name": "dsidsi",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4592 \u3010[TJOI2018]\u5f02\u6216\u3011"
    }
]