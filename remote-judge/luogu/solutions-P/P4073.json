[
    {
        "content": "\u5176\u5b9e\u5982\u679c\u4f60\u5bf9\u5e73\u9762\u56fe\u76f8\u5173\u7684\u4e1c\u897f\u975e\u5e38\u719f\u6089\u7684\u8bdd\u8fd9\u9898\u5c31\u662f\u4e2a\u677f\u5b50\u9898\uff0c\u53ea\u8981\u8dd1\u4e2a\u5e73\u9762\u56fe\u8f6c\u5bf9\u5076\u56fe\uff0c\u7136\u540e\u5bf9\u8be2\u95ee\u7684\u70b9\u5728\u5e73\u9762\u56fe\u4e0a\u70b9\u5b9a\u4f4d\u627e\u5230\u6240\u5728\u533a\u57df\uff0c\u7136\u540e\u5c31\u662fNoip\u8d27\u8f66\u8fd0\u8f93\u90a3\u4e2a\u9898\u4e86\u2026\u2026\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e0a\u67e5\u8be2\u6700\u5927\u8fb9\u6743\u5373\u53ef\u3002\n\n\u5982\u679c\u4f60\u4e0d\u4f1a\u5e73\u9762\u56fe\u8f6c\u5bf9\u5076\u56fe\u7684\u8bdd\u53ef\u4ee5\u53bb[\u8fd9\u9898](https://www.luogu.org/problemnew/show/P3249)\u7684\u9898\u89e3\u91cc\u5b66\u4e60\u4e00\u4e0b\uff0c\u8fd9\u91cc\u7b80\u5355\u8bf4\u4e00\u4e0b\u5e73\u9762\u56fe\u70b9\u5b9a\u4f4d\uff0c\u5c31\u662f\u6211\u4eec\u5e0c\u671b\u627e\u5230\u7ed9\u5b9a\u70b9\u5728\u5e73\u9762\u56fe\u4e0a\u6240\u5728\u7684\u533a\u57df\uff0c\u8fd9\u4e2a\u6211\u4eec\u626b\u63cf\u7ebf+\u5e73\u8861\u6811\u89e3\u51b3\u3002\u6211\u4eec\u77e5\u9053\u8ba1\u7b97\u51e0\u4f55\u91cc\u5f88\u591a\u4e1c\u897f\u90fd\u662f\u90a3\u79cd\u76f8\u5bf9\u987a\u5e8f\u4e0d\u6539\u53d8\u7684\uff0c\u5c31\u53ef\u4ee5\u626b\u63cf\u7ebf\uff0c\u8fd9\u4e2a\u5e73\u9762\u56fe\u4e5f\u662f\u5982\u6b64\u3002\u6211\u4eec\u628a\u5173\u952e\u70b9\u4e0e\u8be2\u95ee\u70b9\u4ece\u5de6\u5230\u53f3\u6392\u5e8f\uff0c\u7136\u540e\u5f00\u4e00\u4e2a\u5e73\u8861\u6811\u7ef4\u62a4\u5f53\u524d\u52a0\u5165\u7684\u8fb9\uff0c\u8fd9\u4e2a\u8fb9\u6211\u4eec\u5e94\u8be5\u4ece\u5de6\u6307\u5411\u53f3\uff0c\u5728\u8fd9\u6761\u8fb9\u4e0a\u5b58\u8fb9\u4e0b\u9762\u7684\u8fd9\u4e2a\u533a\u57df\u7f16\u53f7\uff0c\u5c31\u50cf\u8fd9\u6837\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/57929.png)\n\n\u7136\u540e\u5bf9\u4e8e\u8fd9\u4e2a\u8be2\u95ee\u70b9\u6211\u4eec\u53bb\u5e73\u8861\u6811\u4e0a\u4e8c\u5206\u5b83\u4e0a\u9762\u7684\u7b2c\u4e00\u6761\u8fb9\uff08\u5982\u679c\u6ca1\u6709\u90a3\u4ed6\u5728\u5916\u90e8\u533a\u57df\u91cc\uff09\uff0c\u8fd9\u6837\u5c31\u80fd\u627e\u4e86\u3002\u6ce8\u610f\u4e3a\u4e86\u907f\u514d\u7279\u6b8a\u60c5\u51b5\u6211\u4eec\u9700\u8981\u5728\u5e73\u8861\u6811\u4e0a\u64cd\u4f5c\u7684\u65f6\u5019\u5bf9x\u52a0\u6216\u51cf\u4e00\u4e2aeps\u3002\n\n\u53e6\u5916\u7531\u4e8e\u662f\u201c\u63d2\u5165\u65f6\u7684\u76f8\u5bf9\u987a\u5e8f\u4e0d\u53d8\u201d\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u4e0d\u80fd\u7528\u61d2\u60f0\u5220\u9664\u7684\u66ff\u7f6a\u7f8a\u6811\uff08\u56e0\u4e3a\u5220\u5b8c\u4e86\u70b9\u8fd8\u7559\u5728\u6811\u4e0a\u5c31\u4e71\u5957\u4e86\u2026\u2026\u6211\u5f00\u59cb\u5199\u4e86\u4e2a\u66ff\u7f6a\u7f8a\u6811\u600e\u4e48\u4e5f\u8fc7\u4e0d\u53bb\u2026\u2026\uff09\u3002\n\n\u4e0a\u4ee3\u7801~\n\n```cpp\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define opp(_o) (_o == ch[fa[_o]][1])\nusing namespace std;\nnamespace ywy {\n\tinline int get() {\n\t    int n = 0;\n\t    char c;\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            break;\n\t        if (c == '-')\n\t            goto s;\n\t    }\n\t    n = c - '0';\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 + c - '0';\n\t        else\n\t            return (n);\n\t    }\n\ts:\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 - c + '0';\n\t        else\n\t            return (n);\n\t    }\n\t}\n\tnamespace tree {\n\ttypedef struct _b {\n\t    int dest;\n\t    int nxt;\n\t    int len;\n\t} bian;\n\tbian memchi[1000001];\n\tint gn = 1, heads[100001];\n\tinline void add(int s, int t, int l) {\n\t    memchi[gn].dest = t;\n\t    memchi[gn].len = l;\n\t    memchi[gn].nxt = heads[s];\n\t    heads[s] = gn;\n\t    gn++;\n\t}\n\tint ance[100001][17], mx[100001][17], deep[100001];\n\tvoid dfs(int pt, int baba) {\n\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t        if (memchi[i].dest == baba)\n\t            continue;\n\t        deep[memchi[i].dest] = deep[pt] + 1;\n\t        ance[memchi[i].dest][0] = pt;\n\t        mx[memchi[i].dest][0] = memchi[i].len;\n\t        dfs(memchi[i].dest, pt);\n\t    }\n\t}\n\tinline int lca(int a, int b) {\n\t    if (deep[a] > deep[b])\n\t        swap(a, b);\n\t    int maxn = 0;\n\t    for (register int i = 16; i >= 0; i--) {\n\t        if (deep[ance[b][i]] >= deep[a])\n\t            maxn = max(maxn, mx[b][i]), b = ance[b][i];\n\t    }\n\t    if (a == b)\n\t        return (maxn);\n\t    for (register int i = 16; i >= 0; i--) {\n\t        if (ance[a][i] != ance[b][i]) {\n\t            maxn = max(maxn, max(mx[a][i], mx[b][i]));\n\t            a = ance[a][i];\n\t            b = ance[b][i];\n\t        }\n\t    }\n\t    return (max(maxn, max(mx[a][0], mx[b][0])));\n\t}\n\t}  // namespace tree\n\tint ints[100001];\n\tint find(int n) {\n\t    if (ints[n] == n)\n\t        return (n);\n\t    return (ints[n] = find(ints[n]));\n\t}\n\tunsigned char gg[1000001];\n\ttypedef struct _b {\n\t    int s;\n\t    int t;\n\t    int l;\n\t    friend bool operator<(const _b &a, const _b &b) { return (a.l < b.l); }\n\t} xiabb;\n\txiabb bians[200001];\n\tdouble dx;\n\ttypedef struct _n {\n\t    double k, b;\n\t    int id;\n\t    friend bool operator<(const _n &a, const _n &b) { return (a.k * dx + a.b < b.k * dx + b.b); }\n\t} node;\n\tint root = 0;\n\tint ch[1000001][2], fa[1000001];\n\tnode data[1000001];\n\tint gn = 1;\n\tinline void xuan(int me) {\n\t    int tree = fa[me], cjr = fa[tree], op = opp(me), ls = ch[me][op ^ 1];\n\t    fa[ls] = tree;\n\t    ch[tree][op] = ls;\n\t    ch[me][op ^ 1] = tree;\n\t    if (cjr)\n\t        ch[cjr][opp(tree)] = me;\n\t    fa[tree] = me;\n\t    fa[me] = cjr;\n\t}\n\tinline void splay(int tree) {\n\t    while (fa[tree]) {\n\t        int cjr = fa[tree];\n\t        if (fa[cjr])\n\t            xuan((opp(tree) == opp(cjr)) ? cjr : tree);\n\t        xuan(tree);\n\t    }\n\t}\n\tvoid insert_s(int &tree, int me) {\n\t    if (!tree) {\n\t        tree = me;\n\t        return;\n\t    }\n\t    insert_s(ch[tree][data[tree] < data[me]], me);\n\t    fa[ch[tree][data[tree] < data[me]]] = tree;\n\t}\n\tinline void insert(node dat) {\n\t    int me = gn;\n\t    gn++;\n\t    data[me] = dat;\n\t    insert_s(root, me);\n\t    splay(me);\n\t    root = me;\n\t}\n\tint find(int tree, node dat) {\n\t    if (dat.k == data[tree].k && dat.b == data[tree].b) {\n\t        return (tree);\n\t    }\n\t    return (find(ch[tree][data[tree] < dat], dat));\n\t}\n\tint getmx(int tree) {\n\t    while (ch[tree][1]) tree = ch[tree][1];\n\t    return (tree);\n\t}\n\tinline void del(node dat) {\n\t    int me = find(root, dat);\n\t    splay(me);\n\t    int ls = ch[me][0], rs = ch[me][1];\n\t    fa[ls] = 0;\n\t    fa[rs] = 0;\n\t    if (!ls) {\n\t        root = rs;\n\t        return;\n\t    }\n\t    ls = getmx(ls);\n\t    splay(ls);\n\t    fa[rs] = ls;\n\t    ch[ls][1] = rs;\n\t    root = ls;\n\t}\n\tdouble x[100001], y[100001];\n\ttypedef struct _b_t {\n\t    int s;\n\t    int t;\n\t    int id;\n\t    friend bool operator<(const _b_t &a, const _b_t &b) {\n\t        return (atan2(y[a.t] - y[a.s], x[a.t] - x[a.s]) < atan2(y[b.t] - y[b.s], x[b.t] - x[b.s]));\n\t    }\n\t} bian_t;\n\tvector<bian_t> vec[100001];\n\tint vid[200001];\n\tint anss[200001];\n\ttypedef struct _pt {\n\t    double x;\n\t    double y;\n\t    unsigned char gj;\n\t    int id;\n\t    friend bool operator<(const _pt &a, const _pt &b) {\n\t        if (a.x != b.x)\n\t            return (a.x < b.x);\n\t        return (a.gj > b.gj);\n\t    }\n\t} pt;\n\tpt pts[1000001];\n\tint val[100001], bel[200001], ss[200001], ts[200001];\n\tinline double cross(double x1, double y1, double x2, double y2) { return (x1 * y2 - x2 * y1); }\n\tint getnxt(int tree, double y) {\n\t    if (!tree)\n\t        return (0);\n\t    if (data[tree].k * dx + data[tree].b > y) {\n\t        int cjr = getnxt(ch[tree][0], y);\n\t        if (cjr)\n\t            return (cjr);\n\t        return (tree);\n\t    }\n\t    return (getnxt(ch[tree][1], y));\n\t}\n\tvoid ywymain() {\n\t    tree::deep[0] = -1;\n\t    int n = get(), m = get();\n\t    for (register int i = 1; i <= n; i++) x[i] = get(), y[i] = get(), ints[i] = i;\n\t    for (register int i = 1; i <= m; i++) {\n\t        int s = get(), t = get(), l = get();\n\t        val[i] = l;\n\t        bian_t cjr;\n\t        cjr.s = s;\n\t        cjr.t = t;\n\t        cjr.id = i;\n\t        vec[s].push_back(cjr);\n\t        cjr.s = t;\n\t        cjr.t = s;\n\t        cjr.id = i + m;\n\t        vec[t].push_back(cjr);\n\t        ss[i] = s;\n\t        ts[i] = t;\n\t        ss[i + m] = t;\n\t        ts[i + m] = s;\n\t    }\n\t    for (register int i = 1; i <= n; i++) sort(vec[i].begin(), vec[i].end());\n\t    for (register int i = 1; i <= n; i++) {\n\t        for (register int j = 0; j < vec[i].size(); j++) vid[vec[i][j].id] = j;\n\t    }\n\t    int gpt = 1;\n\t    int rt = 0;\n\t    for (register int i = 1; i <= m * 2; i++) {\n\t        if (bel[i])\n\t            continue;\n\t        int me = gpt;\n\t        gpt++;\n\t        double s = 0;\n\t        int cur = i;\n\t        do {\n\t            s += cross(x[ts[cur]] - x[ss[cur]], y[ts[cur]] - y[ss[cur]], x[ts[cur]], y[ts[cur]]);\n\t            bel[cur] = me;\n\t            cur = vec[ts[cur]][(vid[(cur > m) ? (cur - m) : (cur + m)] + vec[ts[cur]].size() - 1) %\n\t                               vec[ts[cur]].size()]\n\t                      .id;\n\t        } while (cur != i);\n\t        if (s >= 0)\n\t            rt = me;\n\t    }\n\t    int ptr = 1;\n\t    for (register int i = 1; i <= m; i++) {\n\t        if (bel[i] == rt || bel[i + m] == rt)\n\t            continue;\n\t        bians[ptr].s = bel[i];\n\t        bians[ptr].t = bel[i + m];\n\t        bians[ptr].l = val[i];\n\t        ptr++;\n\t    }\n\t    sort(bians + 1, bians + ptr);\n\t    for (register int i = 1; i < ptr; i++) {\n\t        int aa = find(bians[i].s), ab = find(bians[i].t);\n\t        if (aa == ab)\n\t            continue;\n\t        ints[aa] = ab;\n\t        tree::add(bians[i].s, bians[i].t, bians[i].l);\n\t        tree::add(bians[i].t, bians[i].s, bians[i].l);\n\t    }\n\t    for (register int i = 1; i < gpt; i++)\n\t        if (ints[i] == i)\n\t            tree::dfs(i, 0);\n\t    for (register int i = 1; i <= 16; i++) {\n\t        for (register int j = 1; j < gpt; j++) {\n\t            tree::ance[j][i] = tree::ance[tree::ance[j][i - 1]][i - 1];\n\t            tree::mx[j][i] = max(tree::mx[j][i - 1], tree::mx[tree::ance[j][i - 1]][i - 1]);\n\t        }\n\t    }\n\t    ptr = 1;\n\t    for (register int i = 1; i <= n; i++) {\n\t        pts[ptr].x = x[i];\n\t        pts[ptr].y = y[i];\n\t        pts[ptr].id = i;\n\t        pts[ptr].gj = 1;\n\t        ptr++;\n\t    }\n\t    int q = get();\n\t    for (register int i = 1; i <= q; i++) {\n\t        double x1, y1, x2, y2;\n\t        scanf(\"%lf%lf%lf%lf\", &x1, &y1, &x2, &y2);\n\t        pts[ptr].x = x1;\n\t        pts[ptr].y = y1;\n\t        pts[ptr].gj = 0;\n\t        pts[ptr].id = i;\n\t        ptr++;\n\t        pts[ptr].x = x2;\n\t        pts[ptr].y = y2;\n\t        pts[ptr].gj = 0;\n\t        pts[ptr].id = i + q;\n\t        ptr++;\n\t    }\n\t    sort(pts + 1, pts + ptr);\n\t    for (register int i = 1; i < ptr;) {\n\t        int cjr = i;\n\t        while (cjr < ptr && pts[cjr].x == pts[i].x) cjr++;\n\t        for (register int j = i; j < cjr; j++) {\n\t            if (!pts[j].gj)\n\t                break;\n\t            for (register int k = 0; k < vec[pts[j].id].size(); k++) {\n\t                bian_t tmp = vec[pts[j].id][k];\n\t                if (x[tmp.t] >= x[tmp.s])\n\t                    continue;\n\t                dx = pts[i].x - 0.00001;\n\t                node t;\n\t                t.k = (y[tmp.t] - y[tmp.s]) / (x[tmp.t] - x[tmp.s]);\n\t                t.b = y[tmp.t] - x[tmp.t] * t.k;\n\t                t.id = bel[tmp.id];\n\t                del(t);\n\t            }\n\t        }\n\t        for (register int j = i; j < cjr; j++) {\n\t            if (!pts[j].gj)\n\t                break;\n\t            for (register int k = 0; k < vec[pts[j].id].size(); k++) {\n\t                bian_t tmp = vec[pts[j].id][k];\n\t                if (x[tmp.t] <= x[tmp.s])\n\t                    continue;\n\t                dx = pts[i].x + 0.00001;\n\t                node t;\n\t                t.k = (y[tmp.s] - y[tmp.t]) / (x[tmp.s] - x[tmp.t]);\n\t                t.b = y[tmp.s] - x[tmp.s] * t.k;\n\t                t.id = bel[(tmp.id > m) ? (tmp.id - m) : (tmp.id + m)];\n\t                insert(t);\n\t            }\n\t        }\n\t        for (register int j = i; j <= cjr; j++) {\n\t            if (pts[j].gj)\n\t                continue;\n\t            dx = pts[j].x + 0.00001;\n\t            int nx = getnxt(root, pts[j].y);\n\t            if (!nx) {\n\t                anss[pts[j].id] = rt;\n\t                continue;\n\t            }\n\t            anss[pts[j].id] = data[nx].id;\n\t        }\n\t        i = cjr;\n\t    }\n\t    for (register int i = 1; i <= q; i++) {\n\t        int s = anss[i], t = anss[i + q];\n\t        if (find(s) != find(t)) {\n\t            printf(\"-1\\n\");\n\t            continue;\n\t        }\n\t        if (s == rt && t == rt) {\n\t            printf(\"-1\\n\");\n\t            continue;\n\t        }\n\t        printf(\"%d\\n\", tree::lca(s, t));\n\t    }\n\t}\n}\nint main() {\n    ywy::ywymain();\n    return (0);\n}\n```",
        "postTime": 1556853317,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4073 \u3010[WC2013]\u5e73\u9762\u56fe\u3011"
    },
    {
        "content": "\u73b0\u6709\u9898\u89e3\u90fd\u662f\u6811\u4e0a\u500d\u589e\u7684\uff0c\u63d0\u4f9b\u4e00\u4e2akruskal\u91cd\u6784\u6811\u7684\u505a\u6cd5\n\n\u6240\u6709\u51fa\u8fb9\u6309\u8f90\u89d2\u6392\u5e8f\uff0c\u505a\u4e2a\u5e73\u9762\u56fe\u8f6c\u5bf9\u5076\u56fe\n\n\u7136\u540ekruskal\u91cd\u6784\u6811\n\n\u8be2\u95ee\u5c31\u5e73\u8861\u6811\u626b\u63cf\u7ebf\u5e73\u9762\u56fe\u70b9\u5b9a\u4f4d\uff0c\u5bf9\u4e8e\u540c\u4e2a\u8be2\u95ee(s,t)\uff0c\u626b\u5230s\u5c31\u8bb0\u4e0bs\u6240\u5728\u7684\u57df\u5728\u5bf9\u5076\u56fe\u4e0a\u7684\u70b9p\uff0c\u626b\u5230t\u5c31\u5b9a\u4f4d\u70b9q\uff0c\u7b54\u6848\u662f\u91cd\u6784\u6811\u4e0alca(p,q)\u7684\u70b9\u6743\n\n\u6211\u9009\u62e9\u6811\u5256lca\n```cpp\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing std::set;\nusing std::pair;\nusing std::sort;\nusing std::vector;\nusing std::make_pair;\nusing std::lower_bound;\ntemplate<class type>inline const type max(const type &a,const type &b)\n{\n\treturn a>b?a:b;\n}\ntypedef long long ll;\ntypedef double dbl;\nconst int N=1e5+10;\nconst dbl eps=1e-10;\nstruct Point\n{\n\tint x,y;\n\tinline Point(const int &x=0,const int &y=0):x(x),y(y){}\n\tinline const bool operator==(const Point &p)const\n\t{\n\t\treturn x==p.x&&y==p.y;\n\t}\n}p[N];\nstruct Vector\n{\n\tint x,y;\n\tinline Vector(const int &x=0,const int &y=0):x(x),y(y){}\n\tinline Vector(const Point &a=0,const Point &b=0):x(b.x-a.x),y(b.y-a.y){}\n\tinline const dbl Radial_Angle()\n\t{\n\t\treturn atan2(1.0*y,1.0*x);\n\t}\n\tinline const bool operator<(Vector v)\n\t{\n\t\treturn Radial_Angle()<v.Radial_Angle();\n\t}\n\tinline const bool operator==(Vector v)\n\t{\n\t\treturn fabs(Radial_Angle()-v.Radial_Angle())<=eps;\n\t}\n\tinline const ll operator*(const Vector &v)const\n\t{\n\t\treturn (ll)x*v.y-(ll)y*v.x;\n\t}\n};\nbool aspect;\nstruct Edge\n{\n\tint w,id,s,t;\n\tinline Edge(const int &s=0,const int &t=0,const int &w=0,const int &id=0):s(s),t(t),w(w),id(id){}\n\tinline const bool operator<(const Edge &e)const\n\t{\n\t\tif (aspect)return w<e.w;\n\t\tVector v1(p[s],p[t]),v2(p[e.s],p[e.t]);\n\t\tif (v1==v2)return t<e.t;\n\t\treturn v1<v2;\n\t}\n}e[N<<1],d[N];\nint nowx;\nstruct Radial\n{\n\tPoint s;\n\tdbl k;\n\tinline Radial(const Point &s,const dbl &k=0.0):s(s),k(k){}\n\tinline Radial(const Point &s=0,const Point &t=0):s(s),k(1.0*(s.y-t.y)/(s.x-t.x)){}\n\tinline const bool operator<(const Radial &l)const\n\t{\n\t\tif (s==l.s)return k<l.k;\n\t\tint x=max(s.x,l.s.x);\n\t\treturn s.y+(x-s.x)*k<l.s.y+(x-l.s.x)*l.k;\n\t}\n};\nstruct scan\n{\n\tint opt,x,id;\n\tRadial l;\n\tinline scan(const int &opt=0,const int &x=0,const int &id=0,const Radial &l=Radial(0,0)):x(x),opt(opt),l(l),id(id){}\n\tinline const bool operator<(const scan &s)const\n\t{\n\t\tif (x^s.x)return x<s.x;\n\t\treturn opt<s.opt;\n\t}\n}o[N<<2];\ntypedef set<pair<Radial,int> >sri;\ntypedef vector<Edge>veg;\ntypedef vector<int>vit;\nsri s;\nveg g[N];\nvit t[N<<1];\nint n,m,q,ans[N],edc=1,next[N<<1],pos[N<<1],outside,dualn,dualm,treen,w[N<<1],cnt;\ninline const void link(int u,int v,int w)\n{\n\tedc++;g[u].push_back(e[edc]=Edge(u,v,w,edc));\n\tedc++;g[v].push_back(e[edc]=Edge(v,u,w,edc));\n}\nint fa[N<<1];\ninline const int Find(int x)\n{\n\treturn fa[x]==x?x:fa[x]=Find(fa[x]);\n}\ninline const void Init()\n{\n\tfor (int i=1;i<=dualn*2-1;i++)fa[i]=i;\n}\ninline const void kruskal()\n{\n\tInit();\n\ttreen=dualn;aspect=1;\n\tsort(d+1,d+dualm+1);\n\tfor (int x,y,i=1;i<=dualm;i++)\n\t\tif ((x=Find(d[i].s))^(y=Find(d[i].t)))\n\t\t\tw[++treen]=d[i].w,\n\t\t\tfa[x]=fa[y]=treen,\n\t\t\tt[treen].push_back(x),\n\t\t\tt[treen].push_back(y);\n}\nint top[N],wson[N],size[N],dep[N];\ninline const void dfs(int p)\n{\n\tsize[p]=1;\n\tfor (vit::iterator i=t[p].begin();i!=t[p].end();i++)\n\t{\n\t\tint son=*i;\n\t\tfa[son]=p;dep[son]=dep[p]+1;\n\t\tdfs(son);size[p]+=size[son];\n\t\tif (size[son]>size[wson[p]])wson[p]=son;\n\t}\n}\ninline const void dfs(int p,int tp)\n{\n\ttop[p]=tp;\n\tif (wson[p])dfs(wson[p],tp);\n\tfor (vit::iterator i=t[p].begin();i!=t[p].end();i++)\n\t\tif (!top[*i])\n\t\t\tdfs(*i,*i);\n}\ninline const int lca(int a,int b)\n{\n\twhile (top[a]^top[b])\n\t\tdep[top[a]]>dep[top[b]]\n\t\t?a=fa[top[a]]:b=fa[top[b]];\n\treturn dep[a]<dep[b]?a:b;\n}\ninline const int bottleneck(int a,int b)\n{\n\treturn w[lca(a,b)];\n}\ninline const void insert(int id,Radial l)\n{\n\ts.insert(make_pair(l,id));\n}\ninline const void remove(int id,Radial l)\n{\n\ts.erase(make_pair(l,id));\n}\ninline const void query(int id,Radial l)\n{\n\tsri::iterator it=s.upper_bound(make_pair(l,0));\n\tif (it==s.end()||it==s.begin())return ans[id]=-1,void();\n\tif (!ans[id])return ans[id]=it->second,void();\n\tif (~ans[id])ans[id]=bottleneck(it->second,ans[id]);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;i++)scanf(\"%d%d\",&p[i].x,&p[i].y),p[i].x<<=1,p[i].y<<=1;\n\tfor (int u,v,w;m--;)scanf(\"%d%d%d\",&u,&v,&w),link(u,v,w);\n\tfor (int i=1;i<=n;i++)sort(g[i].begin(),g[i].end());\n\tfor (int i=2;i<=edc;i++)\n\t{\n\t\tint v=e[i].t;\n\t\tveg::iterator it=lower_bound(g[v].begin(),g[v].end(),e[i^1]);\n\t\tif (it==g[v].begin())it=g[v].end();\n\t\tnext[i]=(--it)->id;\n\t}\n\tfor (int i=2;i<=edc;i++)\n\t{\n\t\tif (pos[i])continue;\n\t\tpos[i]=pos[next[i]]=++dualn;\n\t\tll size=0;\n\t\tfor (int j=next[i];e[j].t^e[i].s;j=next[j],pos[j]=dualn)size+=Vector(p[e[i].s],p[e[j].s])*Vector(p[e[i].t],p[e[j].t]);\n\t\tif (size<=0)outside=dualn;\n\t}\n\tfor (int i=2;i<=edc;i+=2)\n\t\tif (pos[i]^outside&&pos[i^1]^outside)\n\t\t\td[++dualm]=Edge(pos[i],pos[i^1],e[i].w);\n\tkruskal();fa[treen]=0;dfs(treen);dfs(treen,treen);\n\tfor (int i=2;i<=edc;i++)\n\t\tif (p[e[i].s].x<p[e[i].t].x)\n\t\t\to[++cnt]=scan(2,p[e[i].s].x,pos[i^1],Radial(p[e[i].s],p[e[i].t])),\n\t\t\to[++cnt]=scan(1,p[e[i].t].x,pos[i^1],Radial(p[e[i].s],p[e[i].t]));\n\tscanf(\"%d\",&q);\n\tfor (int i=1;i<=q;i++)\n\t{\n\t\tdbl xa,ya,xb,yb;\n\t\tscanf(\"%lf%lf%lf%lf\",&xa,&ya,&xb,&yb);\n\t\tint xp=(int)(xa*2),yp=(int)(ya*2),xq=(int)(xb*2),yq=(int)(yb*2);\n\t\to[++cnt]=scan(3,xp,i,Radial(Point(xp,yp),0.0));\n\t\to[++cnt]=scan(3,xq,i,Radial(Point(xq,yq),0.0));\n\t}\n\tsort(o+1,o+cnt+1);\n\tfor (int i=1;i<=cnt;i++)\n\t\tswitch (o[i].opt)\n\t\t{\n\t\t\tcase 1:remove(o[i].id,o[i].l);break;\n\t\t\tcase 2:insert(o[i].id,o[i].l);break;\n\t\t\tcase 3:query(o[i].id,o[i].l);break;\n\t\t}\n\tfor (int i=1;i<=q;i++)printf(\"%d\\n\",ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1571883881,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4073 \u3010[WC2013]\u5e73\u9762\u56fe\u3011"
    }
]