[
    {
        "content": "### **\u6807\u7b7e\uff1a\u7ebf\u6bb5\u6811\uff0c\u5355\u8c03\u961f\u5217\uff0c\u52a8\u6001\u89c4\u5212\u3002**\n\n\u4ee4front[i]\u8868\u793a**\u6700\u8fd1\u7684\u4e0d\u80fd\u548ci\u5171\u533a\u95f4\u7684\u5143\u7d20\u4f4d\u7f6e**\uff0c\u663e\u7136front[i]\u53ef\u4ee5\u5728\u8f93\u5165\u65f6\u901a\u8fc7\u53d6\u6700\u5927\u503c\u5904\u7406\u51fa\u6765\u3002**\u663e\u7136\uff0ci\u4e0d\u80fd\u548cfront[i]\u4ee5\u53ca\u4f4d\u7f6e\u66f4\u9760\u524d\u7684\u5143\u7d20\u5212\u4e3a\u4e00\u6bb5\u3002**\n\n\u4ee4dp[i]\u8868\u793a\u4f7f\u533a\u95f4[1, i]\u4e2d\u7684\u5143\u7d20\u5408\u6cd5\u5206\u6bb5\u6240\u9700\u8981\u7684\u6700\u5c0f\u4ee3\u4ef7\n\n\u8003\u8651\u5411\u4f4d\u7f6ei\u8f6c\u79fb\uff0c\u5047\u8bbe\u6709\u4f4d\u7f6ej\u5728i\u524d\u4e14\u5408\u6cd5\u3002\u5219\u8981\u4e48dp[i] = dp[i - 1] + k\uff0c\u5373\u5143\u7d20i\u5355\u72ec\u5206\u4e00\u6bb5\uff0c**\u8981\u4e48\u627e\u5230\u67d0\u4e2a\u503cj\u4f7f\u5f97dp[j] + cost(j + 1, i)\u6700\u5c0f**\u3002\u5176\u4e2dcost(j + 1, i) = s * (Max(j + 1, i) - Min(j + 1, i)),**\u5373\u5c06\u533a\u95f4[j + 1, i]\u5206\u4e3a\u4e00\u6bb5\u7684\u4ee3\u4ef7**\u3002\n\n\u663e\u7136\uff0c\u91cd\u70b9\u5728\u4e8e\u5982\u4f55**\u9ad8\u6548\u5730\u627e\u5230j\u4f7f\u5f97dp[j] + cost(j + 1, i)\u6700\u5c0f**\u3002\n\n\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002**\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f\u4ece\u4e4b\u524d\u67d0\u4e00\u4f4d\u7f6ej\u8fdb\u884c\u8f6c\u79fb\u4e14\u5c06\u4f4d\u7f6ej\u4e0e\u5f53\u524d\u4f4d\u7f6e\u5212\u4e3a\u4e00\u6bb5\u7684\u6700\u5c0f\u4ee3\u4ef7**\uff0c\u5f53\u7136\u4f7f\u7528\u65f6\u662f\u533a\u95f4\u67e5\u8be2\u800c**\u4e0d\u5173\u5fc3\u5177\u4f53\u4f4d\u7f6e**\u3002\u5047\u5b9a\u6211\u4eec\u5df2\u7ecf\u6c42\u5f97\u4e86dp[i]\uff0c\u4e14\u5c06\u533a\u95f4[j, i - 1]\u5212\u4e3a\u4e00\u6bb5\u7684\u4ee3\u4ef7\u8bb0\u4e3aV0\uff0c\u90a3\u4e48\u6211\u4eec\u53d1\u73b0\uff0c\u5982\u679c\u6709\u4f4d\u7f6ej < i\u4e14Vj\u4e3aMin(j + 1, i - 1)\u4e14Vi < Vj\uff0c**\u5373\u5728\u4f4d\u7f6ej\u4e4b\u540e\u9664\u4e86Vi\u6ca1\u6709\u6bd4Vj\u5c0f\u7684\u503c**\uff0c\u90a3\u4e48\u5982\u679c\u4f4d\u7f6ei+1\u5e0c\u671b\u4ecej\u4f4d\u7f6e\u6216\u8005\u66f4\u9760\u524d**\u4e00\u4e9b**\u7684\u4f4d\u7f6e\u8f6c\u79fb\uff0c\u5219\u4ee3\u4ef7\u4e3aV0 + s \\* (Vj - Vi)\uff0c**\u56e0\u4e3aVi\u53d6\u4ee3\u4e86Vj\u6700\u5c0f\u503c\u7684\u5730\u4f4d\uff0c\u9700\u8981\u8865\u4e0a\u589e\u52a0\u7684\u4ee3\u4ef7**\u3002\u4e3a\u4ec0\u4e48\u8bf4\u662f\u66f4\u9760\u524d\u201c\u4e00\u4e9b\u201d\u5462\uff1f\u56e0\u4e3a\u4f4d\u7f6ej\u4e4b\u524d\u53ef\u80fd\u6709\u6bd4Vj\u8fd8\u5c0f\u7684\u5143\u7d20\uff0c\u800c\u8fd9\u4e2a\u65f6\u5019\u5982\u679c\u6709Vk > Vi\uff0c\u90a3\u4e48\u5bf9\u5e94\u9700\u8981\u589e\u52a0\u7684\u4ee3\u4ef7\u5c31\u662fs \\* (Vk - Vi)\u3002\u56e0\u6b64\uff0c\u8fd9\u4e9b\u4f4d\u7f6e\u662f**\u4ece\u540e\u5f80\u524d\u503c\u9012\u51cf**\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u51fa\u73b0\u4e86\u4f4d\u7f6ej > k\u4e14Vj < Vk\uff0c\u90a3\u4e48k\u4e0d\u53ef\u80fd\u662f\u4e4b\u540e\u8ba1\u7b97\u4ee3\u4ef7\u7528\u5230\u7684\u6700\u5c0f\u503c\uff0c\u6211\u4eec\u5c31\u4e0d\u518d\u5173\u5fc3\u4e86\u3002\u56e0\u6b64\uff0c\u53ef\u4ee5\u7528\u4e00\u4e2a**\u4ece\u524d\u5f80\u540e\u5355\u8c03\u9012\u589e**\u7684\u5355\u8c03\u961f\u5217Min\u6765\u7ef4\u62a4\u8fd9\u4e2a\u4f4d\u7f6e\u7684\u5e8f\u5217\uff0c\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u505a\u533a\u95f4\u52a0\u6cd5\u7ef4\u62a4\u6700\u5c0f\u4ee3\u4ef7\u3002\n\n\u6700\u5927\u503c\u540c\u7406\u5229\u7528\u5355\u8c03\u961f\u5217\u7ef4\u62a4\u3002\n\n\u663e\u7136\uff0c\u6587\u5b57\u53d9\u8ff0\u8fc7\u4e8e\u7e41\u7410\uff0c\u66f4\u7b80\u660e\u7684\u601d\u8def\u8bf7\u53c2\u7167\u4ee3\u7801\u3002\n```cpp\n#include <cstdio>\n#include <cstdlib>\n\n#include <deque>\n#include <algorithm>\n\nnamespace my {\n\ttemplate <class T> inline void getmax(T& a, T b) { if (b > a) a = b; }\n\ttemplate <class T> inline void getmin(T& a, T b) { if (b < a) a = b; }\n}\nconst int maxn(112345);\nnamespace seg {\n\tlong long val[maxn << 2], tag[maxn << 2];\n#define ls (n << 1)\n#define rs (n << 1 | 1)\n\tinline void push(int n) {\n\t\tif (tag[n]) {\n\t\t\tval[ls] += tag[n], tag[ls] += tag[n];\n\t\t\tval[rs] += tag[n], tag[rs] += tag[n];\n\t\t\ttag[n] = 0;\n\t\t}\n\t}\n\tinline void update(int n) {\n\t\tval[n] = std::min(val[ls], val[rs]);\n\t}\n\tlong long quary(int n, int left, int right, int l, int r) {\n\t\tif (left == l && right == r) {\n\t\t\treturn val[n];\n\t\t}\n\t\tpush(n);\n\t\tint mid(left + right >> 1);\n\t\tif (r <= mid) return quary(ls, left, mid, l, r);\n\t\telse if (l > mid) return quary(rs, mid + 1, right, l, r);\n\t\treturn std::min(quary(ls, left, mid, l, mid), quary(rs, mid + 1, right, mid + 1, r));\n\t}\n\tvoid modify(int n,int left, int right, int l, int r, long long v) {\n\t\tif (left == l && right == r) {\n\t\t\tval[n] += v, tag[n] += v;\n\t\t\treturn;\n\t\t}\n\t\tpush(n);\n\t\tint mid(left + right >> 1);\n\t\tif (r <= mid) modify(ls, left, mid, l, r, v);\n\t\telse if (l > mid) modify(rs, mid + 1, right, l, r, v);\n\t\telse modify(ls, left, mid, l, mid, v), modify(rs, mid + 1, right, mid + 1, r, v);\n\t\tupdate(n);\n\t}\n}\nstd::deque<int> min, max;\nint n, m, front[maxn];\nlong long k, s, v[maxn], dp[maxn];\nvoid solve() {\n\tint f(0);\n\tfor (int i(1); i <= n; ++i) {\n\t\tmy::getmax(f, front[i]);\n\t\twhile (!min.empty() && min.front() <= f) min.pop_front();\n\t\tint fp(i - 1);//\u5728fp\u4e4b\u540e\u7684\u6700\u5c0f\u503c\u4e0d\u662fv[min.back()]\uff0c\u56e0\u6b64\u53ea\u52a0\u533a\u95f4[fr + 1, fp]\n\t\twhile (!min.empty() && v[min.back()] >= v[i]) {\n\t\t\t//v[i]\u53d6\u4ee3v[pos]\u6210\u4e3a\u4e4b\u540e\u7684\u6700\u5c0f\u503c\uff0cv[pos]\u5bf9\u4e4b\u540e\u65e0\u201c\u8d21\u732e\u201d \n\t\t\tint pos(min.back()); min.pop_back();\n\t\t\tint fr(min.empty() ? f : min.back());\n\t\t\tseg::modify(1, 1, n, fr + 1, fp, s * (v[pos] - v[i]));\n\t\t\t//v[i]\u53d6\u4ee3v[pos]\u6210\u4e3a\u4e4b\u540e\u7684\u6700\u5c0f\u503c\uff0c\u6545\u589e\u52a0s * (v[pos] - v[i])\n\t\t\tfp = fr;\n\t\t} min.push_back(i);\n\t\twhile (!max.empty() && max.front() <= f) max.pop_front();\n\t\tfp = i - 1;\n\t\twhile (!max.empty() && v[max.back()] <= v[i]) {\n\t\t\tint pos(max.back()); max.pop_back();\n\t\t\tint fr(max.empty() ? f : max.back());\n\t\t\tseg::modify(1, 1, n, fr + 1, fp, s * (v[i] - v[pos]));\n\t\t\tfp = fr;\n\t\t} max.push_back(i);\n\t\tdp[i] = dp[i - 1] + k;\n\t\tif (f + 1 < i) my::getmin(dp[i], seg::quary(1, 1, n, f + 1, i) + k);\n\t\t//\u4ece[f + 1, i]\u4e2d\u627e\u5230\u4e00\u4e2a\u6700\u5408\u9002\u7684\u4f4d\u7f6ep\u4f7f\u5f97p\u4e0ei\u5212\u5206\u4e3a\u4e00\u6bb5\u4e14\u603b\u4ee3\u4ef7\u6700\u5c0f\n\t\tif (i != n)\tseg::modify(1, 1, n, i + 1, i + 1, dp[i]);\n\t\t//\u8bfb\u8005\u53ef\u4ee5\u4f53\u4f1a\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u8981\u5728i + 1\u5904\u52a0\u4e0adp[i]\u4ee5\u53ca\u4e3a\u4ec0\u4e48\u8fd9\u4e48\u505a\u662f\u5bf9\u7684 \n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n}\nint main() {\n\tscanf(\"%d%d%lld%lld\", &n, &m, &k, &s);\n\tfor (int i(1); i <= n; ++i) scanf(\"%d\", v + i);\n\tfor (int i(0); i != m; ++i) {\n\t\tint a, b; scanf(\"%d%d\", &a, &b);\n\t\tif (a > b) std::swap(a, b);\n\t\tmy::getmax(front[b], a);\n\t}\n\tsolve();\n\treturn 0;\n}\n\n```",
        "postTime": 1555172872,
        "uid": 163894,
        "name": "kyel",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2248 \u3010\u5206\u6bb5\u3011"
    }
]