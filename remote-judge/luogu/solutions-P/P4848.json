[
    {
        "content": "# **kd-tree?\u4e0d\u5b58\u5728\u7684\u3002**\n\u66b4\u529b\u80fd\u8fc7\u7684\u9898\u5199\u4ec0\u4e48k-dtree???\n\n\u66b4\u529b\u7b97\u6cd5\uff1a\n\n\u7ef4\u62a4\u4e00\u4e2a $v$ \u4ece\u5927\u5230\u5c0f\u7684\u6570\u7ec4\uff0c\u67e5\u8be2\u5c31\u66b4\u529b\u4ece\u5927\u5f80\u5c0f\u627e\uff0c\u627e\u5230\u7b2ck\u4e2a\u5728\u77e9\u5f62\u5185\u90e8\u7684\u70b9\u3002\n\n\u7ef4\u62a4\u7684\u65b9\u6cd5\u4e3a\u7ef4\u62a4\u5927\u5c0f\u4e24\u4e2a\u6570\u7ec4\u6bcf\u4e00\u6b21\u52a0\u70b9\u5c31\u628a\u70b9\u7528\u63d2\u5165\u6392\u5e8f\u63d2\u8fdb\u5c0f\u6570\u7ec4\uff0c\u5f53\u5c0f\u6570\u7ec4\u5927\u4e8e $\\sqrt n$ \u65f6\u628a\u5c0f\u6570\u7ec4\u5f52\u5e76\u8fdb\u5927\u6570\u7ec4\u3002\n\n\u8fd9\u6837\u590d\u6742\u5ea6\u4e3a\u63d2\u5165\u7684 $O(q \\sqrt q)$ \u52a0\u4e0a\u67e5\u8be2\u7684 $(q^2)$ \u3002\u7136\u540e\u5c31\u8fc7\u4e86\uff0c\u8fc7\u4e86\uff01\uff01\uff01\n\n\u8fd9\u4e2a\u66b4\u529b\u6781\u9650\u6570\u636e\u4e5f\u53ea\u8981\u8dd1 $5s+$ \u7136\u800ckd-tree\u6781\u9650\u6570\u636e\u8981\u8dd1 $20s+$ \u3002\n\n\u6240\u4ee5\u5927\u5bb6\u4e00\u8d77\u5199\u66b4\u529b\u5427\uff01\n\n\u66b4\u529b\u4ee3\u7801\uff08\u6700\u5927\u70b9\u53ea\u8981\u8dd1 $2s$ \uff09\uff1a\n\n\uff08\u4ee3\u7801\u8fdb\u884c\u4e86\u90e8\u5206\u4fee\u6539\uff0c\u8bf7\u4e0d\u8981\u76f4\u63a5\u6284\u8fd9\u4efd\u4ee3\u7801\uff09\n```\n#include<bits/stdc++.h>\nusing namespace std;\u3000\n#define re register\nstruct qus\n{\n\u3000  int x,y,v;\u3000\n}c1[100100],c2[10100];\nchar B[1<<26],*S=B;int r(){for(;*S<'-';S++);register int x=*S++-'0';for(;*S>='0';x=(x<<3)+(x<<1)+*S++-'0');return x;\u3000}\nint main()\n{\n \u3000 fread(B,1,1<<26,stdin\uff09;r\uff08\uff09;\u3000\n    re int q=r(),tp,x1,y1,x2,y2,k,la=0,n1=0,n2=0;\u3000\n    for(\u3000;q--;\u3000)\n    {\n     \u3000 tp=r();\u3000\n        if(tp==1)\u3000\n        {\n    \u3000\u3000    x1=r\uff08\uff09^la,y1=r\uff08\uff09^la,k=r()^la;\u3000\n            for(x2=n2++;x2&&c2[x2].v>k;x2--)\u3000c2[x2+1]=c2[x2];\u3000\n            c2[x2+1]=\uff08qus){x1,y1,k};\n            if(n2>=800)\n \u3000         {\n   \u3000           for(re int i=n1,j=n2,i1=(n1+=n2);i1;i1--)\n                {\n           \u3000\u3000     if(\uff08!j)||(i&&(c1[i].v>c2[j].v)\uff09)c1[i1]=c1[i],i--;\n                 \u3000 else c1[i1]=c2[j],j--;\n                }n2=0;\n            }\n        }//\u4e0d\u8981\u6284\u4ee3\u7801\uff01\uff01\uff01\n        if(tp==2\uff09\n        {\n         \u3000 x1=r()^la,y1=r()^la,x2=r()^la,y2=r()^la,k=r()^la\uff1b;\u3000\n            if(k>n1+n2){puts(\"NAIVE!ORZzyz.\");la=0;continue;}\n            for(re int i=n1,j=n2;i|j;\u3000)\n            {\n          \u3000\u3000  if((!j)||(i&&c1[i].v>c2[j].v)){if(c1[i].x>=x1&&c1[i].y>=y1&&c1[i].x<=x2&&c1[i]\u3000.y<=y2&&!--k){printf(\"%d\\n\",la=c1[i].v);\u3000break;}i--;}\n                else {if(c2[j].x>=x1&&c2[j].y>=y1&&c2[j].x<=x2&&c2[j].y<=y2&&!--k){printf(\"%d\\n\",la=c2[j].v);break;}j--;}\n            }if(k){puts(\"NAIVE!ORZzyz.\");la=0;}\n\u3000\u3000    }\u3000\u3000\u3000  \u3000\u3000\n    }\u3000\n}\n```\n",
        "postTime": 1557112039,
        "uid": 22751,
        "name": "Lagoon",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4848 \u3010\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\u3011"
    },
    {
        "content": "\u4e4d\u4e00\u773c\u770b\u5230\u8fd9\u9053\u9898\uff0c\u7531\u4e8e\u521a\u505a\u4e86K\u8fdc\u70b9\u5bf9\uff0c\u7b2c\u4e00\u4e2a\u60f3\u6cd5\u662f\u5927\u5c0f\u6839\u5806A*\u4e71\u641e\u4e00\u4e0b\uff0c\u770b\u4e86\u4e0bK\u7684\u8303\u56f4orz\u3002\n\n\u597d\u5427\u3002\u6211\u4eec\u53d1\u73b0\u6c42\u7b2cK\u5927\u7684\u90a3\u4e2a\u70b9\u7684\u74f6\u6570\uff0c\u8fd9\u4e2a\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u4e3b\u5e2d\u6811\u3002\u6240\u4ee5\u8bf4\u7406\u8bba\u4e0a\u5916\u5c42\u5957\u4e00\u4e2aKD-TREE\u5185\u5c42\u4e00\u4e2a\u6811\u4e0a\u4e3b\u5e2d\u6811\uff0c\u6bcf\u6b21\u4e3b\u5e2d\u6811\u63d0\u51falog\u4e2a\u70b9\u6765\u641e\u5e94\u8be5\u662f\u53ef\u4ee5\u7684\u3002\u4f46\u662f\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u4ed6\u7684\u5e38\u6570\u6709\u70b9\u7206\u70b8,\u56e0\u4e3a\u6700\u5173\u952e\u7684\u5185\u5c42\u6811\u65f6\u95f4\u590d\u6742\u5ea6\u603b\u8981\u8dd1\u6ee1\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6362\u4e00\u4e0b\u60f3\u6cd5\uff0c\u5916\u5c42\u5957\u4e00\u4e2a\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u6240\u6709\u6743\u503c\u5728\u533a\u95f4\u70b9\u7684KD-TREE\uff0c\u8fd9\u6837\u6211\u4eec\u67e5\u8be2\u7684\u65f6\u5019\u770b\u4e00\u4e0b\u7ebf\u6bb5\u6811\u53f3\u513f\u5b50\u7684KD-TREE\u88ab\u5305\u542b\u662f\u5426\u6709k\u4e2a\u9012\u5f52\u5230\u53f3\u8fb9\uff0c\u5426\u5219\u9012\u5f52\u5230\u5de6\u8fb9\uff0c\u5229\u7528kd-tree\u5224\u4e00\u4e0b\u77e9\u5f62\u662f\u5426\u6709\u4ea4\u548c\u77e9\u5f62\u662f\u5426\u8986\u76d6\u65e2\u53ef\uff0c\u7136\u540e\u6700\u540e\u7ebf\u6bb5\u6811\u6700\u7ec8\u5230\u7684\u70b9\u5c31\u662f\u6700\u7ec8\u7684\u7b54\u6848\u3002\u7136\u540e\u7531\u4e8e\u5e26\u63d2\u5165\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u66ff\u7f6a\u7f8a\u6811\u6765\u7ef4\u62a4~~\u91cd\u6784\u7684\u56e0\u5b50\u662f\u7384\u5b66\u5e94\u8be5\u65e0\u65cbtreap\u4f1a\u66f4\u5feb~~\u3002\n\n~~\u4e0d\u5438\u6c27\u6c14\u8fc7\u4e0d\u4e86\uff0c\u4f46\u4f3c\u4e4e\u76ee\u524d\u6ca1\u6709\u6ca1\u5438\u6c27\u8fc7\u7684\u73a9\u5bb6~~\n\n[\u6b22\u8fce\u6765newuser\u5c0f\u7ad9van!](http://www.newuser.top/2018/11/24/%E3%80%90%E5%B4%82%E5%B1%B1%E7%99%BD%E8%8A%B1%E8%9B%87%E8%8D%89%E6%B0%B4%E3%80%91%E6%9D%83%E5%80%BC%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%A5%97kd-tree/)\n\n```\n// luogu-judger-enable-o2\n#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\nconst int maxn = 100005;\nconst int inf = 1e9;\nint n,q;\nstruct node{\n    node *ls,*rs; int siz;\n    int sx[2],sy[2]; int x,y;\n}z[maxn*40],*tl,*nul,**RT,*pool[maxn];\nint lj;\nbool isbad(node *&p) {\n    if(max(p->ls->siz,p->rs->siz)*4>p->siz*3) return 1;\n    return 0;\n}\nstruct orz{\n    int xx,yy;\n}sta[maxn]; int top;\nvoid upd(node *&p) {\n    p->siz=1;\n    if(p->ls!=nul) {\n        p->sx[0] = min(p->sx[0],p->ls->sx[0]);\n        p->sx[1] = max(p->sx[1],p->ls->sx[1]);\n        p->sy[0] = min(p->sy[0],p->ls->sy[0]);\n        p->sy[1] = max(p->sy[1],p->ls->sy[1]);\n        p->siz+=p->ls->siz;\n    }\n    if(p->rs!=nul) {\n        p->sx[0] = min(p->sx[0],p->rs->sx[0]);\n        p->sx[1] = max(p->sx[1],p->rs->sx[1]);\n        p->sy[0] = min(p->sy[0],p->rs->sy[0]);\n        p->sy[1] = max(p->sy[1],p->rs->sy[1]);\n        p->siz+=p->rs->siz;\n    }\n}\nnode* nwnode(int x,int y) {\n    node* p = lj?pool[lj--]:++tl;\n    p->ls = p->rs = nul; p->siz = 1;\n    p->sx[0] = p->sx[1] = p->x = x;\n    p->sy[0] = p->sy[1] = p->y = y;  \n    return p;\n}\nvoid tra(node *&p) {\n    if(p==nul)return;\n    tra(p->ls);\n    pool[++lj] = p;\n    ++top;\n    sta[top].xx= p->x; sta[top].yy = p->y;\n    tra(p->rs);\n}\nbool cmpx(orz aa,orz bb) {\n    return aa.xx < bb.xx ;\n}\nbool cmpy(orz aa,orz bb) {\n    return aa.yy < bb.yy;\n}\nvoid build(node *&p,int l,int r,int nw) {\n    int mid = (l+r)>>1;\n    if(!nw) nth_element(sta+l,sta+mid,sta+r+1,cmpx);\n    else nth_element(sta+l,sta+mid,sta+r+1,cmpy);\n    p = nwnode(sta[mid].xx,sta[mid].yy);\n    if(l<mid) build(p->ls,l,mid-1,nw^1);\n    if(mid<r) build(p->rs,mid+1,r,nw^1);\n    upd(p);\n}\nvoid rebuild() {// luogu-judger-enable-o2\n#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n\nusing namespace std;\nconst int maxn = 100005;\nconst int inf = 1e9;\nint n,q;\nstruct node{\n    node *ls,*rs; int siz;\n    int sx[2],sy[2]; int x,y;\n}z[maxn*40],*tl,*nul,**RT,*pool[maxn];\nint lj;\nbool isbad(node *&p) {\n    if(max(p->ls->siz,p->rs->siz)*4>p->siz*3) return 1;\n    return 0;\n}\nstruct orz{\n    int xx,yy;\n}sta[maxn]; int top;\nvoid upd(node *&p) {\n    p->siz=1;\n    if(p->ls!=nul) {\n        p->sx[0] = min(p->sx[0],p->ls->sx[0]);\n        p->sx[1] = max(p->sx[1],p->ls->sx[1]);\n        p->sy[0] = min(p->sy[0],p->ls->sy[0]);\n        p->sy[1] = max(p->sy[1],p->ls->sy[1]);\n        p->siz+=p->ls->siz;\n    }\n    if(p->rs!=nul) {\n        p->sx[0] = min(p->sx[0],p->rs->sx[0]);\n        p->sx[1] = max(p->sx[1],p->rs->sx[1]);\n        p->sy[0] = min(p->sy[0],p->rs->sy[0]);\n        p->sy[1] = max(p->sy[1],p->rs->sy[1]);\n        p->siz+=p->rs->siz;\n    }\n}\nnode* nwnode(int x,int y) {\n    node* p = lj?pool[lj--]:++tl;\n    p->ls = p->rs = nul; p->siz = 1;\n    p->sx[0] = p->sx[1] = p->x = x;\n    p->sy[0] = p->sy[1] = p->y = y;  \n    return p;\n}\nvoid tra(node *&p) {\n    if(p==nul)return;\n    tra(p->ls);\n    pool[++lj] = p;\n    ++top;\n    sta[top].xx= p->x; sta[top].yy = p->y;\n    tra(p->rs);\n}\nbool cmpx(orz aa,orz bb) {\n    return aa.xx < bb.xx ;\n}\nbool cmpy(orz aa,orz bb) {\n    return aa.yy < bb.yy;\n}\nvoid build(node *&p,int l,int r,int nw) {\n    int mid = (l+r)>>1;\n    if(!nw) nth_element(sta+l,sta+mid,sta+r+1,cmpx);\n    else nth_element(sta+l,sta+mid,sta+r+1,cmpy);\n    p = nwnode(sta[mid].xx,sta[mid].yy);\n    if(l<mid) build(p->ls,l,mid-1,nw^1);\n    if(mid<r) build(p->rs,mid+1,r,nw^1);\n    upd(p);\n}\nvoid rebuild() {\n    if(*RT==nul) return;\n    top = 0;\n    tra(*RT);\n    if(top>0) build(*RT,1,top,0);\n    else *RT = nul;\n    RT = &nul;\n}\n\nint XA,YA,XB,YB,VV;\nvoid inskd(node *&p,int nw) {\n    if(p==nul) {\n        p = nwnode(XA,YA);\n        return;\n    }\n    if(nw==0) {\n        XA<=p->x?inskd(p->ls,nw^1):inskd(p->rs,nw^1);\n    } else {\n        YA<=p->y?inskd(p->ls,nw^1):inskd(p->rs,nw^1);\n    }\n    upd(p);\n    if(isbad(p)) RT = &p;\n}\nbool panj(node *&p) {\n    int xo1 = max(p->sx[0],XA);\n    int yo1 = min(p->sy[1],YB);\n    int xo2 = min(p->sx[1],XB);\n    int yo2 = max(p->sy[0],YA);\n    if(xo1<=xo2&&yo2<=yo1) return 1;\n    return 0;\n}\nbool baohan(node *&p) {\n    if(XA<=p->sx[0]&&p->sx[1]<=XB&&YA<=p->sy[0]&&p->sy[1]<=YB) return 1;\n    return 0;\n}\nbool dianh(node *&p) {\n    if(XA<=p->x&&p->x<=XB&&YA<=p->y&&p->y<=YB) return 1;\n    return 0;\n}\nint kdquery(node *&p) {\n    if(p==nul||p==NULL) return 0;\n    if(!panj(p)) return 0;\n    if(baohan(p)) return p->siz;\n    return kdquery(p->ls) + kdquery(p->rs) + dianh(p);\n}\nstruct nod{\n    int ls,rs;\n    node *rt;\n}dt[maxn*40]; int tot;\nint rrt;\nvoid init() {\n    tl = nul = z;\n    nul->ls = nul->rs = nul;\n    rrt = ++tot; dt[rrt].rt = nul;\n    RT = &nul;\n}\nvoid zxins(int &p,int l,int r) {\n    if(!p) {\n        p = ++tot; dt[p].rt = nul;\n    }\n    inskd(dt[p].rt,0);\n    if(*RT!=nul) rebuild();\n    if(l==r) return;\n    int mid = (l+r)>>1;\n    if(VV<=mid) zxins(dt[p].ls,l,mid);\n    else zxins(dt[p].rs,mid+1,r);\n}\nint query(int &p,int l,int r,int k) {\n    if(!p) {\n        p = ++tot; dt[p].rt = nul;\n    }\n    if(l==r) return l;\n    int mid = (l+r)>>1;\n    int rsz = dt[p].rs ? kdquery(dt[dt[p].rs].rt) : 0;\n    if(rsz>=k) return query(dt[p].rs,mid+1,r,k);\n    else return query(dt[p].ls,l,mid,k-rsz);\n}\nint main() {\n    init();\n    scanf(\"%d%d\",&n,&q);\n    int type,k;\n    int lastans = 0;\n    for(int i=1;i<=q;i++) {\n        scanf(\"%d\",&type);\n        if(type==1) {\n            scanf(\"%d%d%d\",&XA,&YA,&VV);\n            XA^=lastans; YA^=lastans; VV^=lastans;\n            zxins(rrt,1,inf);\n        } else {\n            scanf(\"%d%d%d%d%d\",&XA,&YA,&XB,&YB,&k);\n            XA^=lastans; YA^=lastans; XB^=lastans; YB^=lastans; k^=lastans;\n            if(XA>XB) swap(XA,XB);\n            if(YA>YB) swap(YA,YB);\n            if( kdquery(dt[rrt].rt ) <k ) puts(\"NAIVE!ORZzyz.\"),lastans=0;\n            else {\n                lastans = query(rrt,1,inf,k);\n                printf(\"%d\\n\",lastans);\n            }\n        }\n    }\n}\n    if(*RT==nul) return;\n    top = 0;\n    tra(*RT);\n    if(top>0) build(*RT,1,top,0);\n    else *RT = nul;\n    RT = &nul;\n}\n\nint XA,YA,XB,YB,VV;\nvoid inskd(node *&p,int nw) {\n    if(p==nul) {\n        p = nwnode(XA,YA);\n        return;\n    }\n    if(nw==0) {\n        XA<=p->x?inskd(p->ls,nw^1):inskd(p->rs,nw^1);\n    } else {\n        YA<=p->y?inskd(p->ls,nw^1):inskd(p->rs,nw^1);\n    }\n    upd(p);\n    if(isbad(p)) RT = &p;\n}\nbool panj(node *&p) {\n    int xo1 = max(p->sx[0],XA);\n    int yo1 = min(p->sy[1],YB);\n    int xo2 = min(p->sx[1],XB);\n    int yo2 = max(p->sy[0],YA);\n    if(xo1<=xo2&&yo2<=yo1) return 1;\n    return 0;\n}\nbool baohan(node *&p) {\n    if(XA<=p->sx[0]&&p->sx[1]<=XB&&YA<=p->sy[0]&&p->sy[1]<=YB) return 1;\n    return 0;\n}\nbool dianh(node *&p) {\n    if(XA<=p->x&&p->x<=XB&&YA<=p->y&&p->y<=YB) return 1;\n    return 0;\n}\nint kdquery(node *&p) {\n    if(p==nul||p==NULL) return 0;\n    if(!panj(p)) return 0;\n    if(baohan(p)) return p->siz;\n    return kdquery(p->ls) + kdquery(p->rs) + dianh(p);\n}\nstruct nod{\n    int ls,rs;\n    node *rt;\n}dt[maxn*40]; int tot;\nint rrt;\nvoid init() {\n    tl = nul = z;\n    nul->ls = nul->rs = nul;\n    rrt = ++tot; dt[rrt].rt = nul;\n    RT = &nul;\n}\nvoid zxins(int &p,int l,int r) {\n    if(!p) {\n        p = ++tot; dt[p].rt = nul;\n    }\n    inskd(dt[p].rt,0);\n    if(*RT!=nul) rebuild();\n    if(l==r) return;\n    int mid = (l+r)>>1;\n    if(VV<=mid) zxins(dt[p].ls,l,mid);\n    else zxins(dt[p].rs,mid+1,r);\n}\nint query(int &p,int l,int r,int k) {\n    if(!p) {\n        p = ++tot; dt[p].rt = nul;\n    }\n    if(l==r) return l;\n    int mid = (l+r)>>1;\n    int rsz = dt[p].rs ? kdquery(dt[dt[p].rs].rt) : 0;\n    if(rsz>=k) return query(dt[p].rs,mid+1,r,k);\n    else return query(dt[p].ls,l,mid,k-rsz);\n}\nint main() {\n    init();\n    scanf(\"%d%d\",&n,&q);\n    int type,k;\n    int lastans = 0;\n    for(int i=1;i<=q;i++) {\n        scanf(\"%d\",&type);\n        if(type==1) {\n            scanf(\"%d%d%d\",&XA,&YA,&VV);\n            XA^=lastans; YA^=lastans; VV^=lastans;\n            zxins(rrt,1,inf);\n        } else {\n            scanf(\"%d%d%d%d%d\",&XA,&YA,&XB,&YB,&k);\n            XA^=lastans; YA^=lastans; XB^=lastans; YB^=lastans; k^=lastans;\n            if(XA>XB) swap(XA,XB);\n            if(YA>YB) swap(YA,YB);\n            if( kdquery(dt[rrt].rt ) <k ) puts(\"NAIVE!ORZzyz.\"),lastans=0;\n            else {\n                lastans = query(rrt,1,inf,k);\n                printf(\"%d\\n\",lastans);\n            }\n        }\n    }\n}\n```\n",
        "postTime": 1543066456,
        "uid": 55343,
        "name": "Newuser",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4848 \u3010\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\u3011"
    },
    {
        "content": "\u5927\u5bb6\u4e00\u5b9a\u8981\u5438\u53d6\u6559\u8bad\uff0c\u4e0d\u8981\u60f3\u5f53\u7136\uff01\u662f\u7b2c K \u5927\u4e0d\u662f\u7b2c K \u5c0f\uff01\u8981\u662f\u53d1\u73b0\u6211\u5c31\u4e00\u904d\u8fc7\u4e86\uff01~~\u7ed3\u679c\u8c03\u4e86\u4e24\u4e2a\u5c0f\u65f6\u6539\u4e00\u4e0b\u5c31\u8fc7\u4e86~~\u3002\n\n\u4f17\u6240\u5468\u77e5\uff0c~~\u4e5f\u53ef\u80fd\u6ca1\u4ec0\u4e48\u4eba\u77e5\u9053~~\uff0c\u6743\u503c\u7ebf\u6bb5\u6811\u3001\u5e73\u8861\u6811\u300101trie \u5728\u5f88\u591a\u65f6\u5019\u90fd\u662f\u53ef\u4ee5\u4e92\u76f8\u8f6c\u5316\u7684\uff0c\u6211\u5c31\u7528\u4e86\u66f4\u597d\u5199\uff0c\u53ef\u80fd\u5e38\u6570\u66f4\u5c0f\u7684 01trie\u3002\n\n\u5bb9\u6613\u53d1\u73b0\uff0c\u8fd9\u9053\u9898\u53ef\u4ee5\u4e8c\u5206\uff0c\u5982\u679c\u79bb\u7ebf\u6574\u4f53\u4e8c\u5206\u5c31\u53ef\u4ee5\u4e86\uff0c\u7136\u800c\u51fa\u9898\u4eba\u5e76\u6ca1\u6709\u5141\u8bb8\u79bb\u7ebf\uff01\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u5728\u5916\u5c42\u5957\u4e00\u68f5\u6743\u503c\u7ebf\u6bb5\u6811\u6216 01trie\uff0c\u6bcf\u4e2a\u8282\u70b9\u5b58\u7ef4\u62a4\u4e86\u503c\u57df\u5185\u6240\u6709\u201c\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\u201d\u5750\u6807\u7684 K-D Tree\uff0c\u6bcf\u6b21\u6811\u4e0a\u4e8c\u5206\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\sqrt{n}\\log_2C)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 $O(n\\log_2n\\log_2C)$\uff0c\u4ee5\u4e0a C \u5747\u4e3a\u503c\u57df\uff1a\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e6+6;\nchar buf[N+5],*p1,*p2,c;\n#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,N,stdin),p1==p2)?EOF:*p1++)\ninline int read(){\n    int an=0,f=1;while(!isdigit(c=gc))if(c=='-')f=-f;\n    do an=an*10+(48^c);while(isdigit(c=gc));return an*f;\n}\nnamespace tree_2d{\n\tint lx[N],rx[N],mx[N],sz[N],pt[N],bt,lc[N],rc[N];\n\tint ly[N],ry[N],my[N],stk[N],t,nrb,cnt;\n\tstruct rbtp{int x,y;}a[N];\n\t#define Mn(a,b) if(a>b)a=b\n\t#define Mx(a,b) if(a<b)a=b\n\tvoid Ins(int &x,int dep=0){\n\t\tif(!x){sz[x=++cnt]=1;lx[x]=rx[x]=mx[x]=mx[0];ly[x]=ry[x]=my[x]=my[0];pt[x]=pt[0]^=1;return;}\n\t\tMn(lx[x],mx[0]);Mn(ly[x],my[0]);\n\t\tMx(rx[x],mx[0]);Mx(ry[x],my[0]);++sz[x];\n\t\tif((pt[x]&&mx[0]<mx[x])||(!pt[x]&&my[0]<my[x])){\n\t\t\tIns(lc[x]);if(sz[lc[x]]>sz[rc[x]]*3+2)nrb=x;\n\t\t}else{\n\t\t\tIns(rc[x]);if(sz[rc[x]]>sz[lc[x]]*3+2)nrb=x;\n\t\t}return;\n\t}\n\tint build(int l=1,int r=bt){\n\t\tint md=l+r>>1,x;pt[x=stk[t--]]=pt[0]^=1;\n\t\tnth_element(a+l,a+md,a+r+1,[&](rbtp g,rbtp h){return pt[x]?g.x<h.x:g.y<h.y;});\n\t\tlx[x]=rx[x]=mx[x]=a[md].x,ly[x]=ry[x]=my[x]=a[md].y,sz[x]=1;\n\t\tif(l<md){\n\t\t\tlc[x]=build(l,md-1);Mx(rx[x],rx[lc[x]]);Mx(ry[x],ry[lc[x]]);\n\t\t\tMn(lx[x],lx[lc[x]]);Mn(ly[x],ly[lc[x]]);sz[x]+=sz[lc[x]];\n\t\t}else lc[x]=0;\n\t\tif(md<r){\n\t\t\trc[x]=build(md+1,r);Mx(rx[x],rx[rc[x]]);Mx(ry[x],ry[rc[x]]);\n\t\t\tMn(lx[x],lx[rc[x]]);Mn(ly[x],ly[rc[x]]);sz[x]+=sz[rc[x]];\n\t\t}else rc[x]=0;\n\t\treturn x;\n\t}\n\tvoid get(int x=nrb){\n\t\tif(lc[x])get(lc[x]);a[++bt]={mx[x],my[x]};\n\t\tif(rc[x])get(rc[x]);stk[++t]=x;\n\t}\n\tinline bool ck(int x){\n\t\treturn x&&lx[x]<=rx[0]&&rx[x]>=lx[0]&&ly[x]<=ry[0]&&ry[x]>=ly[0];\n\t}\n\tvoid ask(int x){\n\t\tif(lx[x]>=lx[0]&&rx[x]<=rx[0]&&ly[x]>=ly[0]&&ry[x]<=ry[0]){\n\t\t\tnrb+=sz[x];return;\n\t\t}if(mx[x]>=lx[0]&&mx[x]<=rx[0]&&my[x]>=ly[0]&&my[x]<=ry[0])++nrb;\n\t\tif(ck(lc[x]))ask(lc[x]);if(ck(rc[x]))ask(rc[x]);\n\t}\n\tstruct KDT{\n\t\tint rt;\n\t\tinline void insert(int x,int y){\n\t\t\tmx[0]=x,my[0]=y,nrb=0,Ins(rt);\n\t\t\tif(nrb)bt=0,get(),build();\n\t\t}\n\t\tinline int order(int Lx,int Ly,int Rx,int Ry){\n\t\t\tlx[0]=Lx,ly[0]=Ly,rx[0]=Rx,ry[0]=Ry;\n\t\t\tnrb=0;if(ck(rt))ask(rt);\n\t\t\treturn nrb;\n\t\t}\n\t}tre[N];\n};\nusing tree_2d::tre;\nnamespace trie_01{\n\tint t[N][2],val,cnt,Lx,Ly,Rx,Ry;\n\tvoid Ins(int &x,int w=31){\n\t\tif(!x)x=++cnt;tre[x].insert(Lx,Ly);\n\t\tif(w--)Ins(t[x][(val>>w)&1],w);\n\t}\n\tint gvl(int x,int rk){\n\t\tint w=31,res=0,k;\n\t\twhile(w--){\n\t\t\tk=tre[t[x][1]].order(Lx,Ly,Rx,Ry);\n\t\t\tif(rk<=k)x=t[x][1],res|=1<<w;\n\t\t\telse rk-=k,x=t[x][0];\n\t\t}return res;\n\t}\n\tstruct Trie{\n\t\tint rt;\n\t\tvoid insert(int x,int y,int vl){\n\t\t\tLx=x,Ly=y,val=vl,Ins(rt);\n\t\t}\n\t\tint getval(int lx,int ly,int rx,int ry,int rk){\n\t\t\tLx=lx,Ly=ly,Rx=rx,Ry=ry;\n\t\t\treturn gvl(rt,rk);\n\t\t}\n\t}tr;\n};\nusing trie_01::tr;\nint T,las;\nint main(){\n\tread(),T=read();int lx,ly,rx,ry;\n\twhile(T--)\n\t\tif(read()&1){\n\t\t\tlx=read()^las,ly=read()^las,rx=read()^las;\n\t\t\ttr.insert(lx,ly,rx);\n\t\t}else{\n\t\t\tlx=read()^las,ly=read()^las,rx=read()^las,ry=read()^las,las^=read();\n\t\t\tlas=tr.getval(lx,ly,rx,ry,las);\n\t\t\tif(las)printf(\"%d\\n\",las);\n\t\t\telse puts(\"NAIVE!ORZzyz.\");\n\t\t}\n\treturn 0;\n}\n```",
        "postTime": 1646896715,
        "uid": 502410,
        "name": "EnofTaiPeople",
        "ccfLevel": 0,
        "title": "01trie \u5957 K-D Tree"
    },
    {
        "content": "~~\u4e3a\u4ec0\u4e48\u8fd9\u4e9b kdt \u9898\u89e3\u7684\u4ee3\u7801\u90fd\u8fd9\u4e48\u957f\u554a~~\n\n\u672c\u7bc7\u9898\u89e3\u7684\u4ee3\u7801\u957f\u5ea6\u4e3a 2.52 K\u3002\uff08\u5f00 O2 \u6700\u5927\u70b9 1.55s\uff09\n\n___\n\n\u5176\u5b9e\u672c\u9898\u6ca1\u4ec0\u4e48\u601d\u7ef4\u96be\u5ea6\u3002~~\u5c31\u5f88\u9002\u5408\u6211\u8fd9\u79cd\u53ea\u4f1a\u5957\u8def\u9898\u7684\u5bb6\u4f19~~\u3002\n\n- \u5e73\u9762\u533a\u57df\u67e5\u8be2\uff0c\u5e76\u4e14\u5f3a\u5236\u5728\u7ebf \u2014\u2014 kdt\u3002\n\n- k \u5927\u95ee\u9898\uff0c\u6743\u503c\u7ebf\u6bb5\u6811\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u5f97\u5230\u4e24\u79cd\u505a\u6cd5\uff1a\n\n- \u5916\u5c42 kdt\uff0c\u5185\u5c42\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u6bcf\u6b21\u628a\u6240\u6709\u5305\u542b\u7684\u77e9\u5f62\u62bd\u51fa\u6765\u540c\u6b65\u4e8c\u5206\u3002\n\n- \u5916\u5c42\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u5185\u5c42 kdt\uff0c\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5f97\u7b54\u6848\u3002\n\n\u5df2\u7ecf\u6709\u5148\u8f88\u5e2e\u6211\u4eec\u5c1d\u8bd5\u8fc7\u4e86\u2014\u2014\u7b2c\u4e00\u79cd\u505a\u6cd5\u4f1a\u56e0\u4e3a\u5e38\u6570\u8fc7\u5927\u800c T \u6389\u3002\n\n\u6240\u4ee5\u6211\u4eec\u91c7\u7528\u7b2c\u4e8c\u79cd\u505a\u6cd5\u3002\n\n\u4e00\u4e9b\u5c0f\u7684\u5b9e\u73b0\u7ec6\u8282\uff1a\n\n- \u56e0\u4e3a kdt \u65e0\u6cd5\u901a\u8fc7\u5e38\u89c1\u7684\u65cb\u8f6c\u6216\u9644\u968f\u673a\u4f18\u5148\u7ea7\u8868\u793a\u5e73\u8861\uff0c\u6240\u4ee5\u5185\u90e8 kdt \u4f7f\u7528\u66ff\u7f6a\u7f8a\u5f0f\u91cd\u6784 \u2014\u2014 \u5f53\u5b50\u6811\u4e0d\u5e73\u8861\u65f6\u62cd\u6241\u91cd\u5efa\u3002\uff08\u53c8\u7531\u4e8e kdt \u7684\u67e5\u8be2\u590d\u6742\u5ea6\u6781\u9ad8\uff0c\u6240\u4ee5\u672c\u9898\u66ff\u7f6a\u7f8a\u7684 $\\alpha$ \u53ef\u4ee5\u8bbe\u6210 0.6~0.65\uff09\n\n- kdt \u4e2d Query \u51fd\u6570\u7684\u5b9e\u73b0\u53ef\u4ee5\u4e0d\u5c06\u9700\u8981\u7684\u77e9\u5f62\u653e\u5165\u51fd\u6570\u4f20\u53c2\u3002\u505a\u4e2a\u5168\u5c40\u53d8\u91cf\u5c31\u884c\u4e86\uff0c\u5e38\u6570\u4f1a\u5c0f\u4e00\u4e9b\u3002\n\n- \u5269\u4e0b\u7684\u53ea\u9700\u8981\u4fdd\u8bc1\u7406\u6e05\u695a\u601d\u8def\uff0c\u624b\u522b\u6296\u5c31\u884c\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(q\\sqrt{q}\\log q)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 $O(q\\log q)$\u3002\n\n___\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nconst int maxn = 1e5+5;\nconst double alpha = 0.6;\ninline int max(int a,int b){return a>b?a:b;}\nint n,q,m,lastans,tmp[maxn<<7],cnt;\nstruct point{int x,y;}p[maxn];\nint ch[maxn<<7][2],id[maxn<<7],siz[maxn<<7],tot;\nbool cmpx(int x,int y){return p[id[x]].x<p[id[y]].x;}\nbool cmpy(int x,int y){return p[id[x]].y<p[id[y]].y;}\ninline bool ndpia(int x){return max(siz[ch[x][0]],siz[ch[x][1]])>alpha*siz[x];}\ninline void pushup(int x){siz[x] = siz[ch[x][0]] + siz[ch[x][1]] + 1;}\nvoid pia(int x){\n\ttmp[++cnt] = x;\n\tif(ch[x][0])pia(ch[x][0]);\n\tif(ch[x][1])pia(ch[x][1]);\n}\nint reb(int l,int r,int ty){\n\tif(l>r)return 0;\n\tint mid = l+r>>1;\n\tstd :: nth_element(tmp+l,tmp+mid,tmp+r+1,(ty?cmpx:cmpy));\n\tint pos = tmp[mid];\n\tch[pos][0] = reb(l,mid-1,ty^1),ch[pos][1] = reb(mid+1,r,ty^1);\n\treturn pushup(pos),pos;\n}\nint reb(int x,int ty){return cnt=0,pia(x),reb(1,cnt,ty);}\nvoid insert(int &u,int ty){\n\tif(!u)return u=++tot,siz[u]=1,id[u]=m,void();\n\tint sid=(ty?p[m].x>p[id[u]].x:p[m].y>p[id[u]].y);\n\tinsert(ch[u][sid],ty^1),pushup(u);\n\tif(ndpia(u))u = reb(u,ty);\n}\nint xb[2],yb[2];\nint Query(int u,int lx,int rx,int ly,int ry,int ty){\n\tif(!u||lx>xb[1]||rx<xb[0]||ly>yb[1]||ry<yb[0])return 0;\n\tif(xb[0]<=lx&&rx<=xb[1]&&yb[0]<=ly&&ry<=yb[1])return siz[u];\n\tint res = (xb[0]<=p[id[u]].x&&p[id[u]].x<=xb[1]&&yb[0]<=p[id[u]].y&&p[id[u]].y<=yb[1]);\n\treturn res+(ty?Query(ch[u][0],lx,p[id[u]].x,ly,ry,ty^1)+Query(ch[u][1],p[id[u]].x,rx,ly,ry,ty^1):Query(ch[u][0],lx,rx,ly,p[id[u]].y,ty^1)+Query(ch[u][1],lx,rx,p[id[u]].y,ry,ty^1));\n}\nint Root,tr[maxn<<5][2],root[maxn<<5],nodcnt;\nvoid insert(int &u,int l,int r,int p){\n\tif(!u)u = ++nodcnt;\n\tinsert(root[u],1);\n\tif(l == r)return ;\n\tint mid = l+r>>1;\n\tp<=mid?insert(tr[u][0],l,mid,p):insert(tr[u][1],mid+1,r,p);\n}\nint Erf(int u,int l,int r,int k){\n\tif(l == r)return l;\n\tint mid = l+r>>1,res = Query(root[tr[u][1]],1,n,1,n,1);\n\tif(k <= res)return Erf(tr[u][1],mid+1,r,k);\n\telse return Erf(tr[u][0],l,mid,k-res);\n}\nint main(){\n\tscanf(\"%d %d\",&n,&q);\n\twhile(q--){\n\t\tint ty,v;\n\t\tscanf(\"%d\",&ty);\n\t\tif(ty == 1){\n\t\t\t++m,scanf(\"%d %d %d\",&p[m].x,&p[m].y,&v);\n\t\t\tp[m].x^=lastans,p[m].y^=lastans,v^=lastans,insert(Root,1,1e9,v);\n\t\t}\n\t\tif(ty == 2){\n\t\t\tscanf(\"%d %d %d %d %d\",&xb[0],&yb[0],&xb[1],&yb[1],&v);\n\t\t\txb[0] ^= lastans,yb[0] ^= lastans,xb[1] ^= lastans,yb[1] ^= lastans,v ^= lastans;\n\t\t\tif(v > Query(root[1],1,n,1,n,1))puts(\"NAIVE!ORZzyz.\"),lastans=0;\n\t\t\telse printf(\"%d\\n\",lastans=Erf(Root,1,1e9,v));\n\t\t}\n\t}\n\treturn 0;\n} \n```\n",
        "postTime": 1617867767,
        "uid": 114153,
        "name": "Sali\u0435ri",
        "ccfLevel": 7,
        "title": "\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34"
    },
    {
        "content": "# \u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\n\n\u7ed9\u4f60\u4e00\u4e2a\u5e73\u9762\u4e0a\u7684\u70b9\uff0c\u6bcf\u4e2a\u70b9\u6709\u6743\u503c\uff0c\u7136\u540e\u67e5\u8be2\u4e00\u4e2a\u77e9\u5f62\u5185\u6743\u503c\u7b2c $k$ \u5927\u7684\u70b9\u7684\u6743\u503c\u3002\n\n\u5f3a\u5236\u5728\u7ebf\u3002\n\nhttps://www.luogu.com.cn/problem/P4848\n\n\u770b\u5230\u7684\u65f6\u5019\u5c31\u89c9\u5f97\u5f88\u7b80\u5355\uff0c\u5176\u5b9e\u4e5f\u5f88\u7b80\u5355\u3002\n\n## solution\n\n\u5176\u5b9e\u6211\u4eec\u53ea\u8981\u5199\u4e00\u4e2a\u7ebf\u6bb5\u6811\u5957Kd-Tree\u90a3\u4e48\u5c31\u53ef\u4ee5\u5728\u5916\u5c42\u7684\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u7b54\u6848\uff0c\u7136\u540e\u5185\u5c42kd\u6811\u5b8c\u6210\u77e9\u5f62\u67e5\u8be2\u7684\u64cd\u4f5c\u5373\u53ef\u3002\n\n\u8fd9\u91cc\u987a\u5e26\u4e00\u63d0\uff0ckd\u6811\u7684\u77e9\u5f62\u8be2\u95ee\u7684\u590d\u6742\u5ea6\u662f$O(\\sqrt n)$ \u7684\u3002\n\n\u90a3\u4e48\u6211\u4eec\u68b3\u7406\u4e00\u4e0b\u601d\u8def\uff0c\u8fd9\u9053\u9898\u5c31\u53ef\u4ee5\u89e3\u51b3\u4e86\u3002\n\n\u9996\u5148\u5916\u5c42\u5efa\u7acb\u52a8\u6001\u5f00\u70b9\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u6211\u4eec\u8003\u8651\u5982\u4f55\u89e3\u51b3\u67e5\u8be2\u548c\u63d2\u5165\u3002\n\n\u5bf9\u4e8e\u63d2\u5165\u64cd\u4f5c\uff0c\u6211\u4eec\u53ea\u8981\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u5bf9\u5e94\u7684 $\\log n$ \u4e2a\u533a\u95f4\u7684kdtree\u66b4\u529b\u6dfb\u52a0\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u67e5\u8be2\u64cd\u4f5c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5373\u53ef\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662fkd\u6811\u53ef\u80fd\u9700\u8981\u91cd\u6784\uff0c\u56e0\u4e3a\u662f\u5728\u7ebf\u63d2\u5165\u7684\u3002\n\n\u6240\u4ee5\u5927\u6982\u590d\u6742\u5ea6\u5c31\u662f $O(n\\sqrt n\\log w)$ \uff0c\u53cd\u6b63\u8dd1\u8fc7\u53bb\u5c31\u597d\u4e86\u3002\n\n```c++\n#include <bits/stdc++.h>\ntemplate<typename T>\ninline T read() {\n\tT x = 0;\n\tchar ch = getchar();\n\tbool f = 0;\n\twhile (!isdigit(ch)) {\n\t\tf = ch == '-';\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn f ? -x : x;\n}\nconst int N = 505000, MX = 1e9;\nconst double alpha = 0.65;\nint n, q, tot;\nstruct KdTree_Node {\n\tint son[2], U, D, L, R, x, y, sz;\n} kk[N * 30];\n#define U(k) kk[k].U\n#define D(k) kk[k].D\n#define L(k) kk[k].L\n#define R(k) kk[k].R\n#define X(k) kk[k].x\n#define Y(k) kk[k].y\n#define sz(k) kk[k].sz\n#define son(k, i) kk[k].son[i]\nbool cmpx(int &a, int &b) {\n\treturn X(a) < X(b);\n}\nbool cmpy(int &a, int &b) {\n\treturn Y(a) < Y(b);\n}\nstd::vector<int> v;\ninline bool bad(int nd) {\n\treturn std::max(sz(son(nd, 0)), sz(son(nd, 1))) >= alpha * sz(nd);\n}\nvoid dfs(int u) {\n\tif (u) {\n\t\tdfs(son(u, 0));\n\t\tv.push_back(u);\n\t\tdfs(son(u, 1));\n\t}\n\treturn;\n}\nvoid maintain(int k) {\n\tsz(k) = sz(son(k, 0)) + sz(son(k, 1)) + 1;\n\tU(k) = D(k) = Y(k);\n\tL(k) = R(k) = X(k);\n\tif (son(k, 0)) {\n\t\tU(k) = std::max(U(k), U(son(k, 0)));\n\t\tD(k) = std::min(D(k), D(son(k, 0)));\n\t\tL(k) = std::min(L(k), L(son(k, 0)));\n\t\tR(k) = std::max(R(k), R(son(k, 0)));\n\t}\n\tif (son(k, 1)) {\n\t\tU(k) = std::max(U(k), U(son(k, 1)));\n\t\tD(k) = std::min(D(k), D(son(k, 1)));\n\t\tL(k) = std::min(L(k), L(son(k, 1)));\n\t\tR(k) = std::max(R(k), R(son(k, 1)));\n\t}\n\treturn;\n}\nint rebuild(int l, int r, int d) {\n\tif (r < l) {\n\t\treturn 0;\n\t}\n\tint mid = (l + r) / 2;\n\tif (d ^ 1) {\n\t\tstd::nth_element(v.begin() + l, v.begin() + mid, v.begin() + r + 1, cmpx);\n\t}\n\telse {\n\t\tstd::nth_element(v.begin() + l, v.begin() + mid, v.begin() + r + 1, cmpy);\n\t}\n\tint nw = v[mid];\n\tson(nw, 0) = rebuild(l, mid - 1, d ^ 1);\n\tson(nw, 1) = rebuild(mid + 1, r, d ^ 1);\n\tmaintain(nw);\n\treturn nw;\n}\nvoid insert(int &nw, double x, double y, int d) {\n\tif (!nw) {\n\t\tnw = ++tot;\n\t\tsz(nw) = 1; \n\t\tX(nw) = L(nw) = R(nw) = x;\n\t\tY(nw) = U(nw) = D(nw) = y;\n\t\treturn;\n\t}\n\tif (d ^ 1) {\n\t\tinsert(son(nw, x > X(nw)), x, y, d ^ 1);\n\t}\n\telse {\n\t\tinsert(son(nw, y > Y(nw)), x, y, d ^ 1);\n\t}\n\tmaintain(nw);\n\tif (bad(nw)) {\n\t\tv.clear();\n\t\tdfs(nw);\n\t\tnw = rebuild(0, v.size() - 1, d);\n\t}\n\treturn;\n}\nint query(int nw, int d, int u, int l, int r) {\n\tif (!nw || L(nw) > r || R(nw) < l || D(nw) > u || U(nw) < d) {\n\t\treturn 0;\n\t}\n\tif (L(nw) >= l && R(nw) <= r && D(nw) >= d && U(nw) <= u) {\n\t\treturn sz(nw);\n\t}\n\tint res = X(nw) <= r && X(nw) >= l && Y(nw) <= u && Y(nw) >= d;\n\treturn res + query(son(nw, 0), d, u, l, r) + query(son(nw, 1), d, u, l, r);\n}\nint num, ls[N * 30], rs[N * 30], rt[N * 30], SGT;\nvoid modify(int &nw, int l, int r, int pos, int x, int y) {\n\tif (!nw) {\n\t\tnw = ++num;\n\t}\n\tinsert(rt[nw], x, y, 0);\n\tif (l == r) {\n\t\treturn;\n\t}\n\tint mid((l + r) / 2);\n\tpos <= mid ? modify(ls[nw], l, mid, pos, x, y) : modify(rs[nw], mid + 1, r, pos, x, y); \n}\nint query(int nw, int d, int u, int l, int r, int k, int ql, int qr) {\n\tif (ql == qr) {\n\t\treturn ql;\n\t}\n\tint mid((ql + qr) / 2), res = query(rt[rs[nw]], d, u, l, r);\n\tif (res >= k) {\n\t\treturn query(rs[nw], d, u, l, r, k, mid + 1, qr);\n\t}\n\telse {\n\t\treturn query(ls[nw], d, u, l, r, k - res, ql, mid);\n\t}\n}\nint main() {\n\tfreopen(\".in\", \"r\", stdin);\n\tn = read<int>();\n\tq = read<int>();\n\tint ty, x, y, l, r, d, u, v, k, lstans = 0;\n\twhile (q--) {\n\t\tty = read<int>();\n\t\tif (ty == 1) {\n\t\t\tx = read<int>() ^ lstans;\n\t\t\ty = read<int>() ^ lstans;\n\t\t\tv = read<int>() ^ lstans;\n\t\t\tmodify(SGT, 1, MX, v, x, y);\n//\t\t\tprintf(\"%d\\n\", num);\n\t\t}\n\t\telse {\n\t\t\tl = read<int>() ^ lstans;\n\t\t\td = read<int>() ^ lstans;\n\t\t\tr = read<int>() ^ lstans;\n\t\t\tu = read<int>() ^ lstans;\n\t\t\tk = read<int>() ^ lstans;\n\t\t\tint res = query(rt[1], d, u, l, r);\n\t\t\tif (res < k) {\n\t\t\t\tlstans = 0;\n\t\t\t\tputs(\"NAIVE!ORZzyz.\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlstans = query(SGT, d, u, l, r, k, 1, MX);\n\t\t\tif (!lstans) {\n\t\t\t\tputs(\"NAIVE!ORZzyz.\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"%d\\n\", lstans);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1618328538,
        "uid": 232125,
        "name": "SiRiehn_nx",
        "ccfLevel": 9,
        "title": "[P4848 \u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34] \u9898\u89e3"
    },
    {
        "content": "\u70b9\u6b64\u98df\u7528\u66f4\u4f73\uff1a[$\\huge\\texttt{My Blog}$](https://www.lu-anlai.com/oi/solution/luogu-p4848/)\u3002\n\n\u4e00\u9053\u6bd2\u7624\u7684 \u4e3b\u5e2d\u6811\u5957 $\\texttt{k-D Tree}$ \u9898\uff0c\u6216\u8005 \u66b4\u529b\u5206\u5757 \u7684\u7b80\u5355\u9898\u3002\n\n\u9898\u76ee\u94fe\u63a5\uff1a[Luogu P4848](https://www.luogu.com.cn/problem/P4848)/[LibreOJ 6016](https://loj.ac/problem/6016)\u3002\n\n# \u9898\u76ee\n\n## \u9898\u76ee\u63cf\u8ff0\n\n\u5177\u4f53\u8bf4\u6765\uff0c\u849f\u84bb Bob \u4f1a\u5728\u4e00\u4e2a\u5bbd\u655e\u7684\u5e7f\u573a\u4e0a\u653e\u7f6e\u4e00\u4e9b\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\uff08\u53ef\u89c6\u4e3a\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684\u4e00\u4e9b\u6574\u70b9\uff09\uff0c\u7136\u540e\u8be2\u95ee\u795e\u7287 Aleph \u5728\u77e9\u5f62\u533a\u57df $x_1\\leq x\\leq x_2,y_1\\leq y\\leq y_2$ \u4e2d\uff0c\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\u74f6\u6570\u7b2c $k$ \u591a\u7684\u662f\u591a\u5c11\u3002\u4e3a\u4e86\u907f\u514d\u9ebb\u70e6\uff0c\u849f\u84bb Bob \u4e0d\u4f1a\u5728\u540c\u4e00\u4e2a\u4f4d\u7f6e\u653e\u7f6e\u4e24\u6b21\u6216\u4e24\u6b21\u4ee5\u4e0a\u7684\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\uff0c\u4f46\u849f\u84bb Bob \u60f3\u4e3a\u96be\u4e00\u4e0b\u795e\u7287 Aleph\uff0c\u5e0c\u671b\u4ed6\u80fd\u5728\u6bcf\u6b21\u8be2\u95ee\u65f6\u7acb\u523b\u56de\u7b54\u51fa\u7b54\u6848\u3002\n\n\u795e\u7287 Aleph \u4e0d\u5c51\u4e8e\u505a\u8fd9\u79cd\u95ee\u9898\uff0c\u6240\u4ee5\u628a\u8fd9\u4e2a\u95ee\u9898\u4ea4\u7ed9\u4e86\u4f60\u3002\n\n## \u6570\u636e\u8303\u56f4\n\n|\u53d8\u91cf|\u6570\u636e\u8303\u56f4|\n|:-:|:-:|\n|\u5750\u6807\u8303\u56f4|$5\\times 10^5$|\n|\u64cd\u4f5c\u6b21\u6570|$10^5$|\n|$v$|$10^9$|\n\n## \u65f6\u7a7a\u9650\u5236\n\n|\u9898\u76ee\u7f16\u53f7|\u65f6\u95f4\u9650\u5236|\u7a7a\u95f4\u9650\u5236|\n|:-:|:-:|:-:|\n|[Luogu P4848](https://www.luogu.com.cn/problem/P4848)|$3\\text{s}$|$500\\text{MiB}$|\n|[LibreOJ 6016](https://loj.ac/problem/6016)|$4\\text{s}$|$512\\text{MiB}$|\n\n# \u9898\u89e3\n\n\u672c\u9898\u6709\u591a\u79cd\u5199\u6cd5\u3002\n\n## \u5199\u6cd5\u4e00\n\n~~\u4e0d\u4fdd\u8bc1\u80fd\u8fc7\u7684\u5947\u602a\u5199\u6cd5\uff08\u6570\u636e\u8fc7\u6c34\uff09\u3002~~\n\n\u66b4\u529b\u5206\u5757\uff0c\u5f00\u4e24\u4e2a\u6570\u7ec4\uff0c\u4e00\u5927\u4e00\u5c0f\uff0c\u5c0f\u7684\u5927\u5c0f\u7ea6\u4e3a $\\sqrt{q}+1$\u3002\n\n\u6bcf\u6b21\u52a0\u70b9**\u5f80\u5c0f\u7684\u6570\u7ec4\u91cc\u9762\u7528\u63d2\u5165\u6392\u5e8f\u7684\u65b9\u6cd5\u52a0**\uff0c\u6309 $v$ \u6392\u5217\uff0c**\u8d85\u8fc7\u5927\u5c0f\u540e\u6309\u7167\u5f52\u5e76\u6392\u5e8f\u7684\u65b9\u6cd5\u5408\u5e76\u4e24\u4e2a\u6570\u7ec4**\u3002\n\n\u67e5\u8be2\u65f6**\u6309\u7167\u5f52\u5e76\u7684\u65b9\u6cd5\u67e5\u8be2**\u3002\n\n\u671f\u671b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\Theta(q\\sqrt{q}+q^2)$\u3002**\u5b9e\u9645\u5f00 O2 \u4f18\u5316\u80fd\u8fc7\uff08\u6570\u636e\u592a\u6c34\u4e86\uff09**\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define getcharead()(p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)\nstatic char buf[100000],*p1=buf,*p2=buf;\ninline int read(void){\n\treg bool f=false;\n\treg char ch=getcharead();\n\treg int res=0;\n\twhile(ch<'0'||'9'<ch)f|=(ch=='-'),ch=getcharead();\n\twhile('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getcharead();\n\treturn f?-res:res;\n}\n\nconst int MAXQ=100000+5;\n\nstruct Querys{\n\tint x,y,v;\n\tinline Querys(reg int x=0,reg int y=0,reg int v=0):x(x),y(y),v(v){\n\t\treturn;\n\t}\n};\n\nint n,Q;\nQuerys big[MAXQ],small[MAXQ];\n\ninline bool in(const Querys& Q,reg int x1,reg int x2,reg int y1,reg int y2){\n\treturn x1<=Q.x&&Q.x<=x2&&y1<=Q.y&&Q.y<=y2;\n}\n\nint main(void){\n\tn=read(),Q=read();\n\treg int cnt1=0,cnt2=0;\n\treg int lastans=0;\n\treg int BLOCK=sqrt(n)+1;\n\twhile(Q--){\n\t\tstatic int type;\n\t\ttype=read();\n\t\tif(type==1){\n\t\t\tstatic int x,y,v;\n\t\t\tx=read(),y=read(),v=read();\n\t\t\tx^=lastans,y^=lastans,v^=lastans;\n\t\t\treg int ptr=0;\n\t\t\tfor(ptr=cnt2;ptr&&small[ptr].v>v;--ptr)\n\t\t\t\tsmall[ptr+1]=small[ptr];\n\t\t\tsmall[ptr+1]=Querys(x,y,v);\n\t\t\t++cnt2;\n\t\t\tif(cnt2>=BLOCK){\n\t\t\t\tstatic Querys temp[MAXQ];\n\t\t\t\treg int i=cnt1,j=cnt2,k=cnt1+cnt2;\n\t\t\t\twhile(i&&j){\n\t\t\t\t\tif(big[i].v>small[j].v)\n\t\t\t\t\t\ttemp[k--]=big[i--];\n\t\t\t\t\telse\n\t\t\t\t\t\ttemp[k--]=small[j--];\n\t\t\t\t}\n\t\t\t\twhile(i)\n\t\t\t\t\ttemp[k--]=big[i--];\n\t\t\t\twhile(j)\n\t\t\t\t\ttemp[k--]=small[j--];\n\t\t\t\tfor(reg int i=1;i<=cnt1+cnt2;++i)\n\t\t\t\t\tbig[i]=temp[i];\n\t\t\t\tcnt1=cnt1+cnt2;\n\t\t\t\tcnt2=0;\n\t\t\t}\n\t\t}\n\t\tif(type==2){\n\t\t\tstatic int x1,y1,x2,y2,k;\n\t\t\tx1=read(),y1=read(),x2=read(),y2=read(),k=read();\n\t\t\tx1^=lastans,y1^=lastans,x2^=lastans,y2^=lastans,k^=lastans;\n\t\t\tif(k>cnt1+cnt2){\n\t\t\t\tputs(\"NAIVE!ORZzyz.\");\n\t\t\t\tlastans=0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treg int i=cnt1,j=cnt2;\n\t\t\twhile(i&&j&&k){\n\t\t\t\tif(big[i].v>small[j].v){\n\t\t\t\t\tif(in(big[i],x1,x2,y1,y2))\n\t\t\t\t\t\t--k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tprintf(\"%d\\n\",lastans=big[i].v);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(in(small[j],x1,x2,y1,y2))\n\t\t\t\t\t\t--k;\n\t\t\t\t\tif(k==0){\n\t\t\t\t\t\tprintf(\"%d\\n\",lastans=small[j].v);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t--j;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(i&&k){\n\t\t\t\tif(in(big[i],x1,x2,y1,y2))\n\t\t\t\t\t--k;\n\t\t\t\tif(k==0){\n\t\t\t\t\tprintf(\"%d\\n\",lastans=big[i].v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--i;\n\t\t\t}\n\t\t\twhile(j&&k){\n\t\t\t\tif(in(small[j],x1,x2,y1,y2))\n\t\t\t\t\t--k;\n\t\t\t\tif(k==0){\n\t\t\t\t\tprintf(\"%d\\n\",lastans=small[j].v);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t--j;\n\t\t\t}\n\t\t\tif(k){\n\t\t\t\tputs(\"NAIVE!ORZzyz.\");\n\t\t\t\tlastans=0;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n## \u5199\u6cd5\u4e8c\n\n### \u601d\u8def\n\n\u9996\u5148\u89c2\u5bdf\u5230\u4e8c\u7ef4\u5e73\u9762\uff0c\u8003\u8651\u4f7f\u7528 $\\texttt{k-D Tree}$\u3002\n\n\u5176\u6b21\u89c2\u5bdf\u5230\u7b2c $k$ \u5927\uff0c\u8003\u8651 \u4e3b\u5e2d\u6811\u3002\n\n\u4e8e\u662f\u51b3\u5b9a\u4f7f\u7528 \u4e3b\u5e2d\u6811\u5957 $\\texttt{k-D Tree}$ \u6765\u89e3\u51b3\u95ee\u9898\u3002\u76f8\u5f53\u4e8e\u6bcf\u4e2a\u7ed3\u70b9\u4e0a\u5f00\u4e00\u4e2a $\\texttt{k-D Tree}$\u3002**\u52a8\u6001\u63d2\u5165 + \u66ff\u7f6a\u7f8a\u6811\u5f0f\u91cd\u6784**\uff0c\u67e5\u8be2\u65f6\u53ef\u4ee5\u8fd9\u4e48\u505a\uff1a\n\n1. \u786e\u5b9a\u4e00\u4e2a $t$\uff1b\n2. **\u6c42 $v$ \u5927\u4e8e\u7b49\u4e8e $t$ \u4e14\u5728 \u67e5\u8be2\u8303\u56f4\u5185\u7684\u70b9\u7684\u4e2a\u6570** \uff08\u7528 $\\texttt{k-D Tree}$\uff09\uff1b\n3. **\u5982\u679c\u4e2a\u6570\u5927\u4e8e $k$\uff0c\u589e\u52a0 $t$\uff0c\u5426\u5219\u51cf\u5c0f $t$\u3002**\n4. \u6700\u540e\u5f97\u5230\u7684 $t$ \u5c31\u662f\u7b54\u6848\u3002\n\n**\u4e8c\u5206 $t$ \u5373\u53ef**\uff0c\u6700\u7ec8\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\Theta(q\\log_2v\\log_2q)$\uff0c\u6bd4\u8f83\u4f18\u79c0\u3002\n\n### \u4ee3\u7801\n\n\u4ee3\u7801\u6bd4\u8f83\u957f\uff0c\u5e76\u4e14\u8fd9\u9053\u9898\u76ee\u65f6\u95f4\u6bd4\u8f83\u677e\uff08$3\\text{s}$\u6bd4\u8f83\u957f\uff09\uff0c\u63a8\u8350\u7ba1\u7406\u5458\u5361\u5230 $1.5\\text{s}$\uff0c\u8fd9\u9053\u9898\u76ee\u4e5f\u53ef\u4ee5\u5361\u4e00\u5361\u5e38\u6570\u3002\n\n#### \u5361\u5e38\u6570\n\n1. \u5199\u5feb\u8bfb\uff0c\u56e0\u4e3a\u672c\u9898\u6570\u5b57\u90fd\u662f\u6b63\u6570\uff08\u597d\u50cf\u6ca1\u6709 $0$\uff09\uff0c\u6240\u4ee5**\u4e0d\u9700\u8981\u8003\u8651\u7b26\u53f7**\uff1b\n2. \u4e0d\u8981\u5199\u5feb\u901f\u8f93\u51fa\uff0c\u90a3\u4e2a\u4e1c\u897f\u6162\u7684\u5f88\uff1b\n3. $\\texttt{k-D Tree}$ \u91cc\u9762\u4e0d\u8981\u7528\u5f88\u591a\u6570\u7ec4\uff0c\u8981\u5199\u6210\u7ed3\u6784\u4f53\u7684\u5f62\u5f0f\uff0c\u4e0d\u7136\u5f88\u6162\uff1b\n4. `x=max(x,y)` \u5168\u90e8\u6539\u6210 `cMax(x,y)` \u8fd9\u6837\u7684\u5f62\u5f0f\uff0c\u5176\u4e2d\u6709\u5b8f\u5b9a\u4e49`#define cMax(x,y) ( (x) < (y) ? (x) = (y) : (0) )`\uff1b\n5. ~~\u5f00 O2 \u4f18\u5316\u3002~~\n\n\u4e0b\u9762\u5c31\u662f\u4ee3\u7801\u4e86\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define reg register\n#define INF 1e9\n#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)\nstatic char buf[100000],*p1=buf,*p2=buf;\ninline int read(void){\n\treg char ch=getchar();\n\treg int res=0;\n\twhile(ch<'0'||'9'<ch)ch=getchar();\n\twhile('0'<=ch&&ch<='9')res=10*res+ch-'0',ch=getchar();\n\treturn res;\n}\n\nconst int MAXN=100000+5;\nconst double alpha=0.75;\n\nconst int MAXSIZE=MAXN*20;\n\nint n,K;\nint X[2];\nint _Max[2],_Min[2];\n\nnamespace SegmentTree{\n\t#define mid ( ( (l) + (r) ) >> 1 )\n\tint lastans;\n\tnamespace kD_Tree{\n\t\t#define cMax(x,y) ( (x) < (y) ? (x) = (y) : (0) )\n\t\t#define cMin(x,y) ( (x) > (y) ? (x) = (y) : (0) )\n\t\tint cnt;\n\t\t#define val(x,y) T[x].val[y]\n\t\t#define Max(x,y) T[x].Max[y]\n\t\t#define Min(x,y) T[x].Min[y]\n\t\t#define lson(x) T[x].lson\n\t\t#define rson(x) T[x].rson\n\t\t#define size(x) T[x].size\n\t\tstruct Node{\n\t\t\tint size;\n\t\t\tint lson,rson;\n\t\t\tint Max[2],Min[2];\n\t\t\tint val[2];\n\t\t}T[MAXSIZE];\n\t\tint WD,p[MAXN];\n\t\tinline bool cmp(reg int a,reg int b){\n\t\t\treturn val(a,WD)<val(b,WD);\n\t\t}\n\t\tinline void pushup(reg int k){\n\t\t\treg int l=lson(k),r=rson(k);\n\t\t\tif(l)\n\t\t\t\tcMax(Max(k,0),Max(l,0)),cMax(Max(k,1),Max(l,1)),cMin(Min(k,0),Min(l,0)),cMin(Min(k,1),Min(l,1));\n\t\t\tif(r)\n\t\t\t\tcMax(Max(k,0),Max(r,0)),cMax(Max(k,1),Max(r,1)),cMin(Min(k,0),Min(r,0)),cMin(Min(k,1),Min(r,1));\n\t\t\tsize(k)=size(l)+size(r)+1;\n\t\t\treturn;\n\t\t}\n\t\tinline void flat(reg int k){\n\t\t\tif(lson(k)) \n\t\t\t\tflat(lson(k));\n\t\t\tp[++cnt]=k;\n\t\t\tif(rson(k))\n\t\t\t\tflat(rson(k));\n\t\t\treturn;\n\t\t}\n\t\tint buf[MAXN];\n\t\tinline int Build(reg int l,reg int r,reg int wd){\n\t\t\tif(l>r)\n\t\t\t\treturn 0;\n\t\t\tWD=wd;\n\t\t\tstd::nth_element(p+l,p+mid,p+r+1,cmp);\n\t\t\treg int k=p[mid];\n\t\t\tMax(k,0)=Min(k,0)=val(k,0),Max(k,1)=Min(k,1)=val(k,1);\n\t\t\tlson(k)=Build(l,mid-1,wd^1),rson(k)=Build(mid+1,r,wd^1);\n\t\t\tpushup(k);\n\t\t\treturn k;\n\t\t}\n\t\tinline void Insert(reg int& root,reg int c){\n\t\t\tif(!root){\n\t\t\t\troot=c;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treg int top=0;\n\t\t\tfor(reg int wd=0,x=root;;wd^=1){\n\t\t\t\tbuf[++top]=x;\n\t\t\t\tcMax(Max(x,0),Max(c,0)),cMax(Max(x,1),Max(c,1)),cMin(Min(x,0),Min(c,0)),cMin(Min(x,1),Min(c,1));\n\t\t\t\t++size(x);\n\t\t\t\tif(val(c,wd)<val(x,wd))\n\t\t\t\t\tif(!lson(x)){\n\t\t\t\t\t\tlson(x)=c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tx=lson(x);\n\t\t\t\telse\n\t\t\t\t\tif(!rson(x)){\n\t\t\t\t\t\trson(x)=c;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tx=rson(x);\n\t\t\t}\n\t\t\tbuf[++top]=c;\n\t\t\twhile(size(lson(c))<alpha*size(c)&&size(rson(c))<alpha*size(c))\n\t\t\t\tc=buf[--top];\n\t\t\tif(!c)\n\t\t\t\treturn;\n\t\t\tif(c==root){\n\t\t\t\tcnt=0;\n\t\t\t\tflat(root);\n\t\t\t\troot=Build(1,cnt,0);\n\t\t\t\tcnt=0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treg int fa=buf[--top],crt;\n\t\t\tflat(c);\n\t\t\tcrt=Build(1,cnt,top&1);\n\t\t\tcnt=0;\n\t\t\tif(lson(fa)==c)\n\t\t\t\tlson(fa)=crt;\n\t\t\telse\n\t\t\t\trson(fa)=crt;\n\t\t}\n\t\tinline void Query(reg int x){\n\t\t\tif(!x||Max(x,0)<_Min[0]||Max(x,1)<_Min[1]||Min(x,0)>_Max[0]||Min(x,1)>_Max[1]||lastans>=K)\n\t\t\t\treturn;\n\t\t\tif(_Min[0]<=Min(x,0)&&Max(x,0)<=_Max[0]&&_Min[1]<=Min(x,1)&&Max(x,1)<=_Max[1]){\n\t\t\t\tlastans+=size(x);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(_Min[0]<=val(x,0)&&val(x,0)<=_Max[0]&&_Min[1]<=val(x,1)&&val(x,1)<=_Max[1])\n\t\t\t\t++lastans;\n\t\t\tQuery(lson(x));\n\t\t\tQuery(rson(x));\n\t\t\treturn;\n\t\t}\n\t\t#undef lson\n\t\t#undef rson\n\t}\n\tusing kD_Tree::T;\n\tint ct,tot=1;\n\tint root[MAXSIZE],lson[MAXSIZE],rson[MAXSIZE];\n\tinline void Update(void){\n\t\treg bool flag=true;\n\t\treg int ID=1;\n\t\treg int l=1,r=INF;\n\t\twhile(true){\n\t\t\tif(flag){\n\t\t\t\t++ct;\n\t\t\t\tMax(ct,0)=Min(ct,0)=val(ct,0)=X[0],Max(ct,1)=Min(ct,1)=val(ct,1)=X[1];\n\t\t\t\tsize(ct)=1;\n\t\t\t\tkD_Tree::Insert(root[ID],ct);\n\t\t\t}\n\t\t\tif(l==r)\n\t\t\t\treturn;\n\t\t\tif(K<=mid){\n\t\t\t\tif(!lson[ID])\n\t\t\t\t\tlson[ID]=++tot;\n\t\t\t\tID=lson[ID],r=mid;\n\t\t\t\tflag=false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(!rson[ID])\n\t\t\t\t\trson[ID]=++tot;\n\t\t\t\tID=rson[ID],l=mid+1;\n\t\t\t\tflag=true;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tinline void Query(void){\n\t\tlastans=0;\n\t\tkD_Tree::Query(root[1]);\n\t\tif(lastans<K){\n\t\t\tputs(\"NAIVE!ORZzyz.\");\n\t\t\tlastans=0;\n\t\t\treturn;\n\t\t}\n\t\treg int ID=1,l=1,r=INF;\n\t\twhile(l<r){\n\t\t\tlastans=0;\n\t\t\tkD_Tree::Query(root[rson[ID]]);\n\t\t\tif(K<=lastans)\n\t\t\t\tID=rson[ID],l=mid+1;\n\t\t\telse\n\t\t\t\tK-=lastans,ID=lson[ID],r=mid;\n\t\t}\n\t\tprintf(\"%d\\n\",lastans=l);\n\t\treturn;\n\t}\n}\n\nusing SegmentTree::lastans;\n\nint main(void){\n\treg int cnt=0;\n\tread(),n=read();\n\treg int type,x1,y1,x2,y2;\n\tfor(reg int i=1;i<=n;++i)\n\t\tswitch(type=read()){\n\t\t\tcase 1:{\n\t\t\t\tx1=read()^lastans,y1=read()^lastans,K=read()^lastans;\n\t\t\t\tX[0]=x1,X[1]=y1;\n\t\t\t\tSegmentTree::Update();\n\t\t\t\t++cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2:{\n\t\t\t\tx1=read()^lastans,y1=read()^lastans,x2=read()^lastans,y2=read()^lastans,K=read()^lastans;\n\t\t\t\t_Min[0]=x1,_Min[1]=y1,_Max[0]=x2,_Max[1]=y2;\n\t\t\t\tSegmentTree::Query();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault:break;\n\t\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1588588780,
        "uid": 38502,
        "name": "agicy",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4848 \u3010\u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34\u3011"
    },
    {
        "content": "### \u7b80\u5316\u9898\u9762\n\n\u7ef4\u62a4\u4e00\u4e2a\u4e8c\u7ef4\u5e73\u9762\uff0c\u652f\u6301\u4e24\u79cd\u64cd\u4f5c\n\n$1$\uff0c\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u5750\u6807\u4e3a$(x,y)$\u4e14\u6743\u503c\u4e3a$v$\n\n$2$\uff0c\u67e5\u8be2\u77e9\u5f62\u8303\u56f4\u4e3a$x_0,x_1,y_0,y_1$\u5185\u7b2c$k$\u5927\u7684\u8282\u70b9\u6743\u503c\u4e3a\u591a\u5c11\uff0c\u82e5\u4e0d\u591f$k$\u4e2a\u5219\u8f93\u51faNAIVE!ORZzyz.\n\n\u5f3a\u5236\u5728\u7ebf\u3002\n\n\u6570\u636e\u8303\u56f4$n\\le500000$\uff0c$q\\le100000$\uff0c$1\\le x, y\\le n$\uff0c$1\\le v\\le 10^9$\uff0c$1\\le x_1\\le x_2\\le n$\uff0c$1\\le y_1\\le y_2\\le n$\uff0c$1\\le k\\le q$\u3002\n\n### \u89e3\u9898\u601d\u8def\n\n\u4e8c\u7ef4\u5e73\u9762\u5185\u63d2\u5165\u8282\u70b9\u67e5\u8be2\u8303\u56f4\u5185\u4fe1\u606f\u9996\u5148\u60f3\u5230\u7528$\\mathcal{KDtree}$\u7ef4\u62a4\uff0c\u4f46\u662f\u8003\u8651\u67e5\u8be2\u7b2c$k$\u5927\u5982\u4f55\u8fdb\u884c\u7ef4\u62a4\uff0c\u8003\u8651\u5efa\u7acb\u4e00\u68f5\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u67e5\u8be2\u65f6\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u3002\u5219\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u4e0a\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e2a$\\mathcal{KDtree}$\u5373\u53ef\uff0c\u63d2\u5165\u7684\u65f6\u5019\u76f4\u63a5\u5728\u5bf9\u5e94\u7684\u7ebf\u6bb5\u6811\u4e0a\u7684$log$\u4e2a\u8282\u70b9\u4e0a\u5c06\u8282\u70b9\u63d2\u5165\u76f8\u5e94\u7684$\\mathcal{KDtree}$\u4e0a\uff0c$\\mathcal{KDtree}$\u4e0a\u7ef4\u62a4\u6bcf\u4e2a\u8282\u70b9\u7684$size$\u5373\u53ef\u3002\n\n\u56e0\u4e3a\u662f\u7b2c$k$\u5927\uff0c\u56e0\u6b64\u4e8c\u5206\u7684\u65f6\u5019\u8981\u4ee5\u53f3\u513f\u5b50\u7684$size$\u4e3a\u5224\u65ad\u6807\u51c6\n\n\u6ce8\u610f\u6743\u503c\u7ebf\u6bb5\u6811\u9700\u8981\u52a8\u6001\u5f00\u70b9\u8981\u4e0d\u7136\u7a7a\u95f4\u4f1a\u70b8\u6389\uff0c$\\mathcal{KDtree}$\u7ef4\u62a4\u8282\u70b9\u63d2\u5165\u7684\u65f6\u5019\u5e94\u5f53\u6ce8\u610f\u5931\u8861\u65f6\u548c\u66ff\u7f6a\u7f8a\u6811\u4e00\u6837\u91cd\u6784\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6\u6211\u4e0d\u592a\u4f1a\u5206\u6790\uff0c\u5927\u6982\u662f\u4e00\u4e2a\u63d2\u5165\u590d\u6742\u5ea6$O(nlog^2 nlogv)$\u548c\u4e00\u4e2a\u67e5\u8be2\u590d\u6742\u5ea6$O(n\\sqrt nlogv)$\n\n### $\\mathcal{Code}$\n\n```c++\n// Author: Ame__\n#include<bits/stdc++.h>\n#include<stdint.h>\n#define _ 0\n#define AME__DEBUG\n#define bomb exit(0)\n#define LOG(FMT...) fprintf(stderr , FMT)\n#define TOWA(FMT...) fprintf(stdout , FMT)\nusing namespace std;\n/*Grievous Lady*/\n    \ntypedef int32_t i32;\ntypedef int64_t i64;\ntypedef double qwq;\n    \nconst int BUF_SIZE = 1 << 12;\nchar buf[BUF_SIZE] , *buf_s = buf , *buf_t = buf + 1;\n    \n#define PTR_NEXT() \\\n{ \\\n    buf_s ++; \\\n    if(buf_s == buf_t) \\\n    { \\\n        buf_s = buf; \\\n        buf_t = buf + fread(buf , 1 , BUF_SIZE , stdin); \\\n    } \\\n}\n    \n#define mians(_s_) \\\n{ \\\n    while(!isgraph(*buf_s)) PTR_NEXT();\\\n    char register *_ptr_ = (_s_); \\\n    while(isgraph(*buf_s) || *buf_s == '-') \\\n    { \\\n        *(_ptr_ ++) = *buf_s; \\\n        PTR_NEXT(); \\\n    } \\\n    (*_ptr_) = '\\0'; \\\n}\n    \ntemplate <typename _n_> void mian(_n_ & _x_){\n    while(*buf_s != '-' && !isdigit(*buf_s)) PTR_NEXT();\n    bool register _nega_ = false; if(*buf_s == '-'){ _nega_ = true; PTR_NEXT(); }\n    _x_ = 0; while(isdigit(*buf_s)){ _x_ = _x_ * 10 + *buf_s - '0'; PTR_NEXT(); } if(_nega_) _x_ = -_x_;\n}\n    \nconst i32 INF = 0x3f3f3f3f;\nconst i32 maxv = 1e9;\nconst i32 kato = 5e5 + 10;\n\ntemplate <typename _n_> bool cmax(_n_ &a , const _n_ &b){ return a < b ? a = b , 1 : 0; }\ntemplate <typename _n_> bool cmin(_n_ &a , const _n_ &b){ return a > b ? a = b , 1 : 0; }\n    \ni32 n , q , x , y , z , t , k , opt , lastans = 0;\n\nstruct point{\n    i32 x , y , val;\n    point(i32 x = 0 , i32 y = 0 , i32 val = 0): x(x) , y(y) , val(val){ }\n    friend bool operator !=(const point &a , const point &b){\n        return a.x != b.x || a.y != b.y;\n    }\n}b[kato];\n\ninline bool cmp1(const point &a , const point &b){\n    return a.x < b.x;\n}\n\ninline bool cmp2(const point &a , const point &b){\n    return a.y < b.y;\n}\n\nnamespace K_D_tree{\n    struct node{\n        node *ls , *rs;\n        static queue<node*> q;\n        point p;\n        i32 x1 , x2 , y1 , y2 , size;\n        node(){ }\n        node(const point &qaq): p(qaq){\n            ls = rs = 0x0 , x1 = x2 = p.x , y1 = y2 = p.y , size = 1;\n        }\n        inline void up1(node *x){\n            this -> x1 = min(this -> x1 , x -> x1) , this -> x2 = max(this -> x2 , x -> x2);\n            this -> y1 = min(this -> y1 , x -> y1) , this -> y2 = max(this -> y2 , x -> y2);\n        }\n        inline void up2(){\n            size = (this -> ls ? this -> ls -> size : 0) + (this -> rs ? this -> rs -> size : 0) + 1;\n        }\n        void *operator new(size_t){\n            static node *S = 0x0 , *T = 0x0; node *tmp;\n            return q.empty() ? (S == T && (T = (S = new node[1024]) + 1024 , S == T) ? 0x0 : S ++) : (tmp = q.front() , q.pop() , tmp); \n        }\n        void operator delete(void *qaq){ q.push(static_cast<node*>(qaq)); }\n    };\n\n    queue<node*> node::q;\n\n    i32 tot , top;\n\n    inline void del(node *&o){\n        if(o -> ls) del(o -> ls);\n        if(o -> rs) del(o -> rs);\n        b[++ tot] = o -> p;\n    }\n\n    inline node *build(node *fa , i32 l , i32 r , i32 opt , point *a){\n        if(l > r) return 0x0;\n        i32 mid = (l + r) >> 1;\n        nth_element(a + l , a + mid , a + r + 1 , opt ? cmp2 : cmp1);\n        node *o = new node(a[mid]);\n        o -> ls = build(o , l , mid - 1 , opt ^ 1 , a);\n        o -> rs = build(o , mid + 1 , r , opt ^ 1 , a);\n        if(o -> ls) o -> up1(o -> ls);\n        if(o -> rs) o -> up1(o -> rs);\n        o -> up2();\n        return o;\n    }\n\n    inline void judge(node *&o , i32 opt){\n        tot = 0; i32 res = o -> size;\n        if(0.725 * o -> size <= static_cast<qwq>(max(o -> ls ? o -> ls -> size : 0 , o -> rs ? o -> rs -> size : 0))) del(o) , o = build(0x0 , 1 , res , opt , b);\n    }\n\n    inline void insert(node *&o , const point &p , i32 opt){\n        if(!o) return void(o = new node(p));\n        if(opt == 1){\n            if(p.y <= o -> p.y) insert(o -> ls , p , opt ^ 1);\n            else insert(o -> rs , p , opt ^ 1);\n        }else{\n            if(p.x <= o -> p.x) insert(o -> ls , p , opt ^ 1);\n            else insert(o -> rs , p , opt ^ 1);\n        }\n        if(o -> ls) o -> up1(o -> ls);\n        if(o -> rs) o -> up1(o -> rs);\n        o -> up2();\n        judge(o , opt);\n    }\n\n    inline i32 ask(node *o , i32 x1 , i32 x2 , i32 y1 , i32 y2){\n        if(!o || x2 < o -> x1 || x1 > o -> x2 || y2 < o -> y1 || y1 > o -> y2) return 0;\n        if(x1 <= o -> x1 && o -> x2 <= x2 && y1 <= o -> y1 && o -> y2 <= y2) return o -> size;\n        i32 res = 0;\n        if(x1 <= o -> p.x && o -> p.x <= x2 && y1 <= o -> p.y && o -> p.y <= y2) res += 1;\n        return res + ask(o -> ls , x1 , x2 , y1 , y2) + ask(o -> rs , x1 , x2 , y1 , y2);\n    }\n}\n\nnamespace Segement_Tree{\n    struct node{\n        node *ls , *rs;\n        K_D_tree::node *p;\n    }_pool[kato] = {{_pool , _pool , 0x0}} , *tail = _pool , *null = tail ++ , *root = null;\n    \n    inline void insert(node *&o , i32 l , i32 r , const point &p , i32 k){\n        if(o == null) o = new(tail ++) node(*null);\n        K_D_tree::insert(o -> p , p , 0); \n        if(l == r) return;\n        i32 mid = (l + r) >> 1;\n        if(k <= mid) insert(o -> ls , l , mid , p , k);\n        else insert(o -> rs , mid + 1 , r , p , k);\n    }\n\n    inline i32 ask(node *o , i32 l , i32 r , i32 x1 , i32 x2 , i32 y1 , i32 y2 , i32 k){\n        if(l == r) return l;\n        i32 res = K_D_tree::ask(o -> rs -> p , x1 , x2 , y1 , y2);\n        i32 mid = (l + r) >> 1;\n        if(k > res) return ask(o -> ls , l , mid , x1 , x2 , y1 , y2 , k - res);\n        else return ask(o -> rs , mid + 1 , r , x1 , x2 , y1 , y2 , k);\n    }\n}\n\ninline int Ame_(){\n#ifdef AME__\n    freopen(\".in\" , \"r\" , stdin); freopen(\".out\" , \"w\" , stdout); int nol_cl = clock();\n#endif\n    mian(n) , mian(q);\n    for(; q --> 0 ;){\n        mian(opt);\n        if(opt == 1){ mian(x) , mian(y) , mian(k) , x ^= lastans , y ^= lastans , k ^= lastans , Segement_Tree::insert(Segement_Tree::root , 0 , maxv , point(x , y) , k); }\n        if(opt == 2){ mian(x) , mian(y) , mian(z) , mian(t) , mian(k) , x ^= lastans , y ^= lastans , z ^= lastans , t ^= lastans , k ^= lastans; if((lastans = Segement_Tree::ask(Segement_Tree::root , 0 , maxv , x , z , y , t , k))) TOWA(\"%d\\n\" , lastans); else TOWA(\"NAIVE!ORZzyz.\\n\"); }\n    }\n#ifdef AME__TIME\n    LOG(\"Time: %dms\\n\", int((clock() - nol_cl) / (qwq)CLOCKS_PER_SEC * 1000));\n#endif\n    return ~~(0^_^0); /*\u3055\u3088\u3046\u306a\u3089\u30d7\u30ed\u30b0\u30e9\u30e0*/\n}\n    \nint Ame__ = Ame_();\n    \nint main(){;}\n```",
        "postTime": 1613877592,
        "uid": 245875,
        "name": "Ame__",
        "ccfLevel": 0,
        "title": "P4848 \u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34 \u9898\u89e3"
    },
    {
        "content": "\u5355\u70b9\u4fee\u6539\uff0c\u77e9\u9635 kth\uff0c\u8003\u8651\u6811\u5957\u6811\u3002\n\n\u53d1\u73b0\u9700\u8981\u5957\u4e09\u5c42\uff0c\u8003\u8651\u600e\u4e48\u4e0d\u5199\u6743\u503c\u7ebf\u6bb5\u6811\u5957\u4e8c\u7ef4\u7ebf\u6bb5\u6811\u3002\n\n\u7528 KDT \u4ee3\u66ff\u6389\u4e24\u5c42\u6570\u636e\u7ed3\u6784\u5373\u53ef\u3002\n\nKDT \u5957\u6743\u503c\u7ebf\u6bb5\u6811\u662f\u4e0d\u53ef\u884c\u7684\uff0c\u56e0\u4e3a KDT \u4f9d\u8d56 push up\uff0c\u9700\u8981\u6743\u503c\u7ebf\u6bb5\u6811\u5408\u5e76\u3002\n\n\u6743\u503c\u7ebf\u6bb5\u6811\u5957 KDT \u662f\u53ef\u884c\u7684\uff0c\u5916\u5c42\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e00\u68f5 KDT \u8868\u793a\u5bf9\u5e94\u503c\u57df\u533a\u95f4\u5185\u7684\u70b9\u96c6\u3002\n\n\u67e5\u8be2\u65f6\u5728\u5916\u5c42\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n^{\\frac32}\\log V)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 $O(n\\log n)$\u3002\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#define A 0.65\nusing namespace std;\nstruct T\n{\n    int l, r, x, y, s, D, L1, R1, L2, R2, V, Q;\n    bool c();\n    void u();\n} z[5000050];\nbool C1(int a, int b) { return z[a].x < z[b].x; }\nbool C2(int a, int b) { return z[a].y < z[b].y; }\nbool T::c() { return s * A <= max(z[l].s, z[r].s); }\nvoid T::u()\n{\n    s = z[l].s + z[r].s + 1;\n    Q = z[l].Q + z[r].Q + V;\n    L1 = R1 = x;\n    L2 = R2 = y;\n    if (l)\n        L1 = min(L1, z[l].L1),\n        R1 = max(R1, z[l].R1),\n        L2 = min(L2, z[l].L2),\n        R2 = max(R2, z[l].R2);\n    if (r)\n        L1 = min(L1, z[r].L1),\n        R1 = max(R1, z[r].R1),\n        L2 = min(L2, z[r].L2),\n        R2 = max(R2, z[r].R2);\n}\nint n, q, c, o, r, h, g[5000050];\nvoid D(int x)\n{\n    if (x)\n    {\n        D(z[x].l);\n        g[++g[0]] = x;\n        D(z[x].r);\n    }\n}\nint B(int s, int t)\n{\n    if (s > t)\n        return 0;\n    int m = s + t >> 1;\n    double x1 = 0, x2 = 0, s1 = 0, s2 = 0;\n    for (int i = s; i <= t; ++i)\n        x1 += z[g[i]].x, x2 += z[g[i]].y;\n    x1 /= t - s + 1;\n    x2 /= t - s + 1;\n    for (int i = s; i <= t; ++i)\n        s1 += (z[g[i]].x - x1) * (z[g[i]].x - x1),\n            s2 += (z[g[i]].y - x2) * (z[g[i]].y - x2);\n    if (s1 > s2)\n        nth_element(g + s, g + m, g + t + 1, C1), z[g[m]].D = 1;\n    else\n        nth_element(g + s, g + m, g + t + 1, C2), z[g[m]].D = 2;\n    z[g[m]].l = B(s, m - 1);\n    z[g[m]].r = B(m + 1, t);\n    z[g[m]].u();\n    return g[m];\n}\nvoid I(int &x, int v)\n{\n    if (!x)\n        return x = v, z[x].u();\n    if (z[x].D & 1)\n        if (C1(v, x))\n            I(z[x].l, v);\n        else\n            I(z[x].r, v);\n    else if (C2(v, x))\n        I(z[x].l, v);\n    else\n        I(z[x].r, v);\n    z[x].u();\n    if (z[x].c())\n        g[0] = 0, D(x), x = B(1, g[0]);\n}\nint Q(int x, int l1, int r1, int l2, int r2)\n{\n    if (!x || l1 > z[x].R1 || r1 < z[x].L1 || l2 > z[x].R2 || r2 < z[x].L2)\n        return 0;\n    if (l1 <= z[x].L1 && z[x].R1 <= r1 && l2 <= z[x].L2 && z[x].R2 <= r2)\n        return z[x].Q;\n    return Q(z[x].l, l1, r1, l2, r2) + Q(z[x].r, l1, r1, l2, r2) + (l1 <= z[x].x && z[x].x <= r1 && l2 <= z[x].y && z[x].y <= r2 ? z[x].V : 0);\n}\nstruct S{int l, r, o;}R[5000050];\nvoid M(int l, int x, int y, int s, int t, int &p)\n{\n    z[++c].x = x;z[c].y = y;z[c].V = 1;I(R[p ? p : p = ++o].o, c);\n\tif(s == t) return;int m = s + t >> 1;\n    if(l <= m) M(l, x, y, s, m, R[p].l);else M(l, x, y, m + 1, t, R[p].r);\n}\nint Q(int k, int l1, int r1, int l2, int r2, int s, int t, int p)\n{\n    if(s == t) return s;int m = s + t >> 1, o = Q(R[R[p].r].o, l1, r1, l2, r2);\n    if(k <= o) return Q(k, l1, r1, l2, r2, m + 1, t, R[p].r);\n    else return Q(k - o, l1, r1, l2, r2, s, m, R[p].l);\n}\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> q;\n    for(int i = 0, L = 0, o, l1, l2, r1, r2, k;i < q;++i)\n    {\n        cin >> o >> l1 >> l2 >> r1;\n        l1 ^= L;l2 ^= L;r1 ^= L;\n        if(o & 1) M(r1, l1, l2, 1, 1e9, h);\n        else\n        {\n            cin >> r2 >> k;r2 ^= L;k ^= L;\n            if(Q(R[h].o, l1, r1, l2, r2) < k)\n                cout << \"NAIVE!ORZzyz.\" << '\\n', L = 0;\n            else cout << (L = Q(k, l1, r1, l2, r2, 1, 1e9, h)) << '\\n';\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1684111594,
        "uid": 388651,
        "name": "5k_sync_closer",
        "ccfLevel": 7,
        "title": "P4848 \u5d02\u5c71\u767d\u82b1\u86c7\u8349\u6c34 \u9898\u89e3"
    }
]