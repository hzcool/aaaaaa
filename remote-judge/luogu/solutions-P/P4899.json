[
    {
        "content": "~~\u63d0\u9ad8\u7ec4\u9009\u624b\u627f\u53d7\u8303\u56f4\u5185~~\n\n\u4ece$s$\u51fa\u53d1\uff0c\u53ea\u80fd\u7ecf\u8fc7$L$~$N$\uff0c\u4ece$t$\u51fa\u53d1\uff0c\u53ea\u80fd\u7ecf\u8fc7$1$~$R$\uff0c\u6839\u636e\u8fd9\u4e2a\u5355\u8c03\u6027\uff0c$kruskal$\u751f\u6210\u4e24\u4e2a\u6811\uff0c$A$\u6811\u975e\u6839\u8282\u70b9\u5927\u4e8e\u7236\u8282\u70b9\uff0c$B$\u6811\u975e\u6839\u8282\u70b9\u5c0f\u4e8e\u7236\u8282\u70b9\n\n\u751f\u6210\u6811\u539f\u7406\uff1a\u6bd4\u5982$A$\u6811\uff0c\u8282\u70b9$x$\u9650\u5236$L$\uff0c\u901a\u8fc7\u500d\u589e\u5f80\u4e0a\u722c\u5230\u7684\u6700\u5c0f\u70b9\u5b50\u6811\u5c31\u662f$x$\u80fd\u6d3b\u52a8\u7684\u533a\u57df\uff0c\u5f62\u5982\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5012\u5e8f\u5904\u7406\u8282\u70b9\u8fde\u8fb9\n\n\u4ee5\u4e24\u6811\u65f6\u95f4\u6233\u4e3a\u5750\u6807$(x,y)$\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u67e5\u8be2\uff0c\u5224\u4e24\u6811\u70b9\u96c6\u662f\u5426\u6709\u4ea4(\u77e9\u9635\u6570\u70b9)\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u79bb\u7ebf\u5904\u7406~~\u5176\u5b9e\u662f\u4e0d\u4f1a\u4e3b\u5e2d\u6811~~\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstruct node{\n    int to,next;\n}dis[800010];\nint num,n,m,q; int head[200010],tree[200010],ans[200010];\nbool visit[200010];\ninline void add(int u,int v){\n    dis[++num]=(node){v,head[u]}; head[u]=num;\n}\nstruct code{\n    bool mark;\n    int cnt,tot,time; int f[200010],inc[200010][30],dfn[200010],low[200010],top[200010];\n    struct cody{\n        int to,next;\n    }edge[200010];\n    int find(int x){\n        return f[x]==x?x:f[x]=find(f[x]);\n    }\n    void add(int u,int v){\n        edge[++cnt]=(cody){v,top[u]}; top[u]=cnt;\n    }\n    void kruskal(){\n        for(int i=1;i<=n;++i)\n            f[i]=i;\n        if(mark)\n            for(int u=n;u;--u)\n                for(int j=head[u];j;j=dis[j].next){\n                    int v=dis[j].to;\n                    if(v>u){\n                        int fx=find(u),fy=find(v);\n                        if(fx==fy)\n                            continue;\n                        f[fy]=fx;\n                        add(fx,fy);\n                        if(++tot==n-1)\n                            return;\n                    }\n                }\n        else\n            for(int u=1;u<=n;++u)\n                for(int j=head[u];j;j=dis[j].next){\n                    int v=dis[j].to;\n                    if(v<u){\n                        int fx=find(u),fy=find(v);\n                        if(fx==fy)\n                            continue;\n                        f[fy]=fx;\n                        add(fx,fy);\n                        if(++tot==n-1)\n                            return;\n                    }\n                }\n    }\n    void dfs(int u,int fa){\n        dfn[u]=++time;\n        inc[u][0]=fa;\n        for(int i=1;i<=20;++i)\n            inc[u][i]=inc[inc[u][i-1]][i-1];\n        for(int i=top[u];i;i=edge[i].next){\n            int v=edge[i].to;\n            if(v==fa)\n                continue;\n            dfs(v,u);\n        }\n        low[u]=time;\n    }\n    int query(int x,int k){\n        if(mark)\n            for(int i=20;i>=0;i--){\n                if(inc[x][i]&&inc[x][i]>=k)\n                    x=inc[x][i];\n            }\n        else\n            for(int i=20;i>=0;i--)\n                if(inc[x][i]&&inc[x][i]<=k)\n                    x=inc[x][i];\n                \n        return x;\n    }\n}A,B;\nstruct nody{\n    int x,y,v,id;\n}a[1000010];\nbool cmp(nody g1,nody g2){\n    if(g1.x==g2.x)\n        return g1.id<g2.id;\n    return g1.x<g2.x;\n}\ninline int lowbit(int x){\n    return x&-x;\n}\nvoid ad(int x){\n    for(;x<=n;x+=lowbit(x))\n        tree[x]++;\n}\ninline int query(int x){\n    int sum=0;\n    for(;x;x-=lowbit(x))\n        sum+=tree[x];\n    return sum;\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i=1;i<=m;++i){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u++; v++;\n        add(u,v); add(v,u);\n    }\n    A.mark=true;\n    A.kruskal();\n    B.kruskal();\n    A.dfs(1,0);\n    B.dfs(n,0);  \n    num=0;\n    for(int i=1;i<=n;++i)\n        a[++num]=(nody){A.dfn[i],B.dfn[i],0,0};\n    for(int i=1;i<=q;++i){\n        int s,t,l,r;\n        scanf(\"%d%d%d%d\",&s,&t,&l,&r);\n        l++; r++; s++; t++;\n        s=A.query(s,l);\n        t=B.query(t,r);\n        int x1=A.dfn[s]-1,x2=A.low[s];\n        int y1=B.dfn[t]-1,y2=B.low[t];\n        a[++num]=(nody){x1,y1,1,i};\n        a[++num]=(nody){x1,y2,-1,i};\n        a[++num]=(nody){x2,y1,-1,i};\n        a[++num]=(nody){x2,y2,1,i};\n    }\n    sort(a+1,a+1+num,cmp);\n    for(int i=1;i<=num;++i)\n        if(!a[i].id)\n            ad(a[i].y);\n        else\n            ans[a[i].id]+=query(a[i].y)*a[i].v;\n    for(int i=1;i<=q;++i)\n        printf(\"%d\\n\",ans[i]!=0?1:0);\n    return 0;\n}/*\n10 9 1\n6 7\n1 5\n8 0\n2 9\n9 4\n2 7\n8 5\n6 0\n3 4\n8 1 8 9\n\n1\n1*/\n```",
        "postTime": 1540602555,
        "uid": 88804,
        "name": "y2823774827y",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u611f\u89c9\u5df2\u7ecf\u51e0\u6b21\u78b0\u5230\u8fd9\u79cd\u7c7b\u578b\u7684\u9898\u76ee\u4e86\uff0c\u5199\u7bc7$Blog$\u603b\u7ed3\u4e00\u4e0b\n\n### \u9898\u610f\uff1a\n\n\u662f\u5426\u5b58\u5728\u4e00\u6761$(s_i, t_i)$\u7684\u8def\u5f84\uff0c\u6ee1\u8db3\u5148\u53ea\u8d70\u7f16\u53f7\u8d85\u8fc7$L_i$\u7684\u70b9\uff0c\u518d\u8d70\u7f16\u53f7\u4e0d\u8d85\u8fc7$R_i$\u7684\u70b9\n### $Solution$\uff1a\n\u5bf9\u4e8e\u8fd9\u79cd\u9650\u5b9a\u7ecf\u8fc7\u70b9\u6570\u7684\u9898\u76ee\uff0c\u53ef\u4ee5\u6bd4\u8f83\u81ea\u7136\u5730\u60f3\u5230\u91cd\u6784\u6811\uff1a\n\n\u7531\u4e8e\u524d\u540e\u90fd\u6709\u9650\u5b9a\uff0c\u6211\u4eec\u8003\u8651\u5efa\u4e24\u9897\u91cd\u6784\u6811\n\n\u7b2c\u4e00\u9897\u6309\u7167\u8fb9\u6743\u4e3a\u4e24\u4e2a\u7aef\u70b9\u7f16\u53f7\u7684\u6700\u5c0f\u503c\u6784\u5efa\u91cd\u6784\u6811\uff0c\u91cd\u6784\u6811\u6bcf\u4e2a\u70b9\u7684\u70b9\u6743$x$\u8868\u793a\u4e0d\u7ecf\u8fc7\u8fb9\u6743\u8d85\u8fc7$x$\u7684\u8fb9\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\uff1b\n\n\u7b2c\u4e8c\u9897\u5219\u6309\u7167\u8fb9\u6743\u4e3a\u4e24\u4e2a\u7aef\u70b9\u6700\u5927\u503c\u6765\u6784\u5efa\u91cd\u6784\u6811\uff0c\u91cd\u6784\u6811\u4e0a\u6bcf\u4e2a\u70b9\u70b9\u6743$x$\u8868\u793a\u4e0d\u7ecf\u8fc7\u8fb9\u6743$\u2264x$\u7684\u8fb9\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\u3002\n\n\u6784\u5efa\u5b8c\u91cd\u6784\u6811\u540e\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a$s_i$\uff0c\u53ea\u9700\u8981\u5728\u91cd\u6784\u6811\u4e0a\u4e00\u76f4\u5f80\u4e0a\u8df3\uff0c\u627e\u5230\u4e00\u4e2a\u70b9$x$\uff0c\u6ee1\u8db3$L_i\u2264val_x$\u5373\u53ef\uff0c$t_i$\u540c\u7406\n\n\u8fd9\u6837\u6211\u4eec\u4f1a\u5728\u4e24\u9897\u91cd\u6784\u6811\u4e0a\u627e\u5230\u4e24\u4e2a\u70b9\uff0c\u73b0\u5728\u95ee\u9898\u5c31\u8f6c\u5316\u6210\u4e86\uff1a\u8fd9\u4e24\u4e2a\u70b9\u6784\u6210\u7684\u5b50\u6811\u4e2d\uff0c\u6709\u6ca1\u6709\u516c\u5171\u70b9\uff08\u56e0\u4e3a\u6709\u516c\u5171\u70b9$x$\u7684\u8bdd\u5c31\u80af\u5b9a\u5b58\u5728\u4e00\u6761\u5408\u6cd5\u8def\u5f84\u4e3a$s_i->x->t_i$\uff09\n\n\u6811\u4e0a\u4e24\u4e2a\u8282\u70b9\u7684\u4ea4\u6211\u4eec\u4e0d\u592a\u597d\u505a\uff0c\u8003\u8651\u6211\u4eec\u9700\u8981\u7684\u662f\u5b50\u6811\u7684\u4ea4\uff0c\u5bf9\u5e94\u5728$dfs$\u5e8f\u4e2d\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u4e8e\u662f\u95ee\u9898\u5c31\u8fdb\u4e00\u6b65\u8f6c\u5316\uff1a\n\n\u5bf9\u4e8e\u4e24\u4e2a\u6392\u5217$a, b$\uff0c\u6bcf\u6b21\u8be2\u95ee\u6392\u5217$a$\u5728$[l_1, r_1]$\u533a\u95f4\u5185\uff0c\u6392\u5217$b$\u5728$[l_2, r_2]$\u533a\u95f4\u5185\u6709\u65e0\u516c\u5171\u5143\u7d20\n\n~~\u5176\u4ed6\u9898\u89e3\u5230\u8fd9\u4e00\u6b65\u600e\u4e48\u5c31\u662f\u4e00\u53e5\uff1a \u79bb\u7ebf\u6811\u72b6\u6570\u7ec4/\u5728\u7ebf\u4e3b\u5e2d\u6811\u4e00\u4e0b \u5c31\u6ca1\u4e86\u554a~~\n\n\u7531\u4e8e\u4e24\u4e2a\u6570\u5217\u90fd\u662f\u6392\u5217\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u5f8b\u628a\u6392\u5217$a$\u6620\u5c04\u5230\u6392\u5217$b$\u4e2d\u53bb\uff1a\n\n\u8bb0$gg[i]$\u8868\u793a$i$\u8fd9\u4e2a\u5143\u7d20\u5728\u6392\u5217$a$\u4e2d\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a$gg[b[i]]$\u7684\u4e00\u4e2a\u65b0\u7684\u6392\u5217\uff0c\u8fd9\u4e2a\u6392\u5217\u7684\u610f\u4e49\u4e3a\uff1a$b_i$\u5728$a$\u4e2d\u7684\u51fa\u73b0\u4f4d\u7f6e\n\n\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8003\u5f8b\u5bf9$gg[b[i]]$\u5efa\u4e00\u68f5\u4e3b\u5e2d\u6811\uff08\u79bb\u7ebf\u6811\u72b6\u6570\u7ec4\u4e5f\u884c\uff09\uff0c\u6bcf\u4e00\u4e2a\u8be2\u95ee\u53ea\u9700\u8981\u67e5\u8be2\u5728$[l_2, r_2]$\u8fd9\u4e9b\u7248\u672c\u5185\uff0c$[l_1, r_1]$\u6709\u65e0\u5143\u7d20\u5373\u53ef\n\n## $Code:$\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define re register\nil int read() {\n    re int x = 0, f = 1; re char c = getchar();\n    while(c < '0' || c > '9') { if(c == '-') f = -1; c = getchar();}\n    while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();\n    return x * f;\n}\n#define rep(i, s, t) for(re int i = s; i <= t; ++ i)\n#define drep(i, s, t) for(re int i = t; i >= s; -- i)\n#define Next(i, u) for(re int i = head[u]; i; i = e[i].next)\n#define _ 400005\nint n, m, fa[_], q, fr[_], to[_], head[_], cnt, gg[_], size[_ * 15], ls[_ * 15], rs[_ * 15], gk, rt[_];\nstruct Edge { int v, next; }e[_ << 1];\nstruct edge { int u, v, w; }E[_];\nil void add(int u, int v) {\te[++ cnt] = (Edge){v, head[u]}, head[u] = cnt; }\nil bool cmp(edge a, edge b) { return a.w < b.w; }\nil int find(int x) {\n\twhile(x != fa[x]) x = fa[x] = fa[fa[x]];\n\treturn x;\n}\nstruct Tree {\n\tint L[_], R[_], pax, dfn[_], val[_], f[21][_];\n\til void dfs(int u) {\n\t\tif(u <= n) L[u] = ++ pax, dfn[pax] = u, val[u] = u;\n\t\telse L[u] = pax + 1;\n\t\trep(i, 1, 20) f[i][u] = f[i - 1][f[i - 1][u]];\n\t\tNext(i, u) f[0][e[i].v] = u, dfs(e[i].v);\n\t\tR[u] = pax;\n\t}\n\til int find_pre(int x, int y) {\n\t\tdrep(i, 0, 20) if(val[f[i][x]] >= y && f[i][x]) x = f[i][x];\n\t\treturn x;\n\t}\n\til int find_nxt(int x, int y) {\n\t\tdrep(i, 0, 20) if(val[f[i][x]] <= y && f[i][x]) x = f[i][x];\n\t\treturn x;\n\t}\n}t1, t2;//\u91cd\u6784\u6811\u4e2d\u7528\u500d\u589e\u627e\u5230\u6211\u4eec\u9700\u8981\u7684\u6700\u9ad8\u70b9\nil void solve(Tree&t, int opt) {\n\trep(i, 1, n * 2) fa[i] = i;\n\tint tot = n;\n\trep(i, 1, m) {\n\t\tif(opt == 1) E[i] = (edge){fr[i], to[i], -min(fr[i], to[i])};\n\t\tif(opt == 2) E[i] = (edge){fr[i], to[i], max(fr[i], to[i])};\n\t}\n\tsort(E + 1, E + m + 1, cmp);\n\trep(i, 1, m) {\n\t\tint u = E[i].u, v = E[i].v, a = find(u), b = find(v);\n\t\tif(a != b) fa[a] = fa[b] = ++ tot, t.val[tot] = abs(E[i].w), add(tot, a), add(tot, b);\n\t}\n\tt.dfs(tot);\n}//\u6784\u5efa\u91cd\u6784\u6811\nil void insert(int &k, int kk, int l, int r, int ll) {\n\tif(!k) k = ++ gk; size[k] = size[kk] + 1;\n\tif(l == r) return;\n\tint mid = (l + r) >> 1;\n\tif(ll <= mid) insert(ls[k], ls[kk], l, mid, ll), rs[k] = rs[kk];\n\telse insert(rs[k], rs[kk], mid + 1, r, ll), ls[k] = ls[kk];\n}\nil int query(int k, int kk, int l, int r, int ll, int rr) {\n\tif(ll <= l && r <= rr) return size[kk] - size[k];\n\tint mid = (l + r) >> 1, ans = 0;\n\tif(ll <= mid) ans += query(ls[k], ls[kk], l, mid, ll, rr);\n\tif(mid < rr) ans += query(rs[k], rs[kk], mid + 1, r, ll, rr);\n\treturn ans;\n}//\u4e3b\u5e2d\u6811\u6c42\u4ea4\nint main() {\n\tn = read(), m = read(), q = read();\n\trep(i, 1, m) fr[i] = read() + 1, to[i] = read() + 1;\n\tsolve(t1, 1), cnt = 0, memset(head, 0, sizeof(head)), solve(t2, 2);\n\trep(i, 1, n) gg[t1.dfn[i]] = i;\n\trep(i, 1, n) insert(rt[i], rt[i - 1], 1, n, gg[t2.dfn[i]]);\n\twhile(q --) {\n\t\tint s = read() + 1, t = read() + 1, l = read() + 1, r = read() + 1, x = t1.find_pre(s, l), y = t2.find_nxt(t, r);\n\t\tprintf(\"%d\\n\", query(rt[t2.L[y] - 1], rt[t2.R[y]], 1, n, t1.L[x], t1.R[x]) > 0);\n\t}\n\treturn 0;\n}\n```\n~~\u4ee3\u7801\u5c31\u51d1\u5408\u7740\u770b\u5427\uff0c\u6211\u627f\u8ba4\u5b83\u975e\u5e38\u4e11\uff0c\u628a\u5b83\u62c6\u6210\u53ca\u90e8\u5206\u770b\u7684\u8bdd\u4e5f\u4e0d\u662f\u5f88\u96be\u5199~~",
        "postTime": 1571059641,
        "uid": 57014,
        "name": "Nemlit",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u4e09\u4e2a\u7528\u4e3b\u5e2d\u6811\u7684\u7406\u7531\uff1a  \n1. \u89e3\u9898\u9700\u6c42 ~~\uff08\u5e9f\u8bdd\uff09~~\n2. \u590d\u6742\u5ea6\u5c0f $O(nlogn)$\n3. \u5f3a\u5236\u5728\u7ebf  \n## Step1\uff1a\n\u6211\u4eec\u53ef\u4ee5\u5148kruskal\u91cd\u6784\u4e24\u68f5\u6811\uff1a  \nA\u6811\u975e\u6839\u8282\u70b9\u5927\u4e8e\u7236\u8282\u70b9\uff0cBB\u6811\u975e\u6839\u8282\u70b9\u5c0f\u4e8e\u7236\u8282\u70b9\u3002  \n\u6211\u4eec\u53d1\u73b0\u8fd9\u4e24\u68f5\u6811\u6709\u4e00\u4e2a\u6027\u8d28\uff1a  \n\u4e00\u4e2a\u5b50\u6811\u5185\u4efb\u610f\u8282\u70b9\u53ef\u4ee5\u4ec5\u901a\u8fc7\u5b50\u6811\u5185\u7684\u8282\u70b9\u5230\u8fbe\u5b50\u6811\u5185\u7684\u4efb\u610f\u8282\u70b9\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6bcf\u4e2a\u5b50\u6811\u90fd\u662f\u8054\u901a\u7684\u4e14\u7f16\u53f7\u6ee1\u8db3\u5806\u7684\u6027\u8d28\u3002  \n\u90a3\u4e48\uff0c\u6211\u4eec\u53ef\u4ee5\u73b0\u5728A\u6811\u4e2d\u627e\u5230$S$\uff0c\u500d\u589e\u8df3\u5230$X$,\u4f7f$X>=L,Fa_X<L$  \n\u5219$S$\u53ef\u4ee5\u53ea\u901a\u8fc7\u7f16\u53f7\u5927\u4e8e\u7b49\u4e8e$L$\u7684\u70b9\u6240\u80fd\u5230\u7684\u70b9\u7684\u96c6\u5408\u662f$X$\u7684\u5b50\u6811\u5185\u6240\u6709\u70b9\u7684\u96c6\u5408,\u4ee4\u4e3a$Vs$\u3002  \n\u540c\u7406\u6211\u4eec\u53ef\u4ee5\u5f97\u5230$T$\u53ea\u7ecf\u8fc7\u7f16\u53f7\u5c0f\u4e8e\u7b49\u4e8e$R$\u7684\u70b9\u6240\u80fd\u5230\u7684\u70b9\u7684\u96c6\u5408$Vt$\u3002  \n\u6c42\u662f\u5426\u6709\u89e3\u5373\u4e3a\u8fd9\u4e24\u4e2a\u96c6\u5408\u662f\u5426\u516c\u5171\u70b9\u3002\n## Step2\uff1a  \n\u5206\u522b\u5904\u7406\u51faA\u6811\u548cB\u6811\u7684dfs\u5e8f\uff1adfa,dfb.  \n$Vs$\u7684dfa\u5728$dfa_X$~$dfa_X+siz_X-1$  \n$Vt$\u7684dfb\u5728$dfb_Y$~$dfa_Y+siz_Y-1$  \n\u5efa\u7acb\u7ed3\u6784\u4f53\uff0c\u6309dfa\u6392\u5e8f\uff0c\u4ee5dfb\u4e3a\u6743\u503c\u5efa\u7acb\u4e3b\u5e2d\u6811  \n\u67e5\u8be2$dfa_X$~$dfa_X+siz_X-1$\u7684\u4e3b\u5e2d\u6811\u4e2d\u503c\u5728  \n$dfb_Y$~$dfa_Y+siz_Y-1$\u4e4b\u95f4\u7684\u4e2a\u6570\u3002  \n\u82e5\u4e3a0\u5219\u8f93\u51fa0\uff0c\u5426\u5219\u8f93\u51fa1.  \n\u89e3\u6bd5\u3002  \n### Code:\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=8e5+5;\nconst int T=N<<4;\nint n,m,q,fi[N],ne[N],to[N],tot;\nint dfa[N],dfb[N],sia[N],sib[N];\nvoid add(int x,int y){ne[++tot]=fi[x];to[tot]=y;fi[x]=tot;}\nvoid ad(int x,int y){add(x,y);add(y,x);}\nstruct kruskal{\n    int type,fk[N],nk[N],tk[N],tok;\n    int fa[N],jp[N][20],rt,dfn[N],cnt,siz[N];\n    void adk(int x,int y){nk[++tok]=fk[x];tk[tok]=y;fk[x]=tok;}\n    int fd(int x)\n    {\n        if(x!=fa[x])fa[x]=fd(fa[x]);\n        return fa[x];\n    }\n    void dfs(int x)\n    {\n        dfn[x]=++cnt;siz[x]=1;\n        for(int i=fk[x];i;i=nk[i])\n        {\n            int y=tk[i];\n            jp[y][0]=x;\n            dfs(y);\n            siz[x]+=siz[y];\n        }\n    }\n    void build()\n    {\n        for(int i=1;i<=n;i++)fa[i]=i;\n        if(type==1)\n            for(int x=n;x;x--)\n                for(int i=fi[x];i;i=ne[i])\n                {\n                    int y=to[i];\n                    if(y>x)\n                    {\n                        int fx=fd(x),fy=fd(y);\n                        if(fx==fy)continue;\n                        fa[fy]=fx;\n                        adk(fx,fy);\n                    }\n                }\n        else\n            for(int x=1;x<=n;x++)\n                for(int i=fi[x];i;i=ne[i])\n                {\n                    int y=to[i];\n                    if(y<x)\n                    {\n                        int fx=fd(x),fy=fd(y);\n                        if(fx==fy)continue;\n                        fa[fy]=fx;\n                        adk(fx,fy);\n                    }\n                }\n        cnt=0;\n        rt=fd(1);\n        dfs(rt);\n        for(int j=1;j<=18;j++)\n            for(int i=1;i<=n;i++)\n                jp[i][j]=jp[jp[i][j-1]][j-1];\n    }\n    int lca(int x,int y)\n    {\n        for(int i=18;i>=0;i--)\n        {\n            if(type==1)\n            {\n                if(jp[x][i]>=y)\n                    x=jp[x][i];\n            }\n            else\n            {\n                if(jp[x][i]<=y && jp[x][i])\n                    x=jp[x][i];\n            }\n        }\n        return x;\n    }\n}A,B;\nstruct DFN{\n    int a,b;\n}ss[N];\nbool cmp(DFN x,DFN y){return x.a<y.a;}\nint ls[T],rs[T],tr[T],rt[N],t_cnt;\nvoid build(int pre,int &now,int l,int r,int x)\n{\n    now=++t_cnt;tr[now]=tr[pre]+1;\n    if(l==r)return ;\n    int mid=(l+r)>>1;\n    if(x<=mid)\n    {\n        rs[now]=rs[pre];\n        build(ls[pre],ls[now],l,mid,x);\n    }\n    else\n    {\n        ls[now]=ls[pre];\n        build(rs[pre],rs[now],mid+1,r,x);\n    }\n    return ;\n}\nint query(int now1,int now2,int l,int r,int L,int R)\n{\n    if(L<=l && R>=r)\n        return tr[now2]-tr[now1];\n    int mid=(l+r)>>1,anss=0;\n    if(L<=mid)anss+=query(ls[now1],ls[now2],l,mid,L,R);\n    if(R>mid)anss+=query(rs[now1],rs[now2],mid+1,r,L,R);\n    return anss;\n}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&q);\n    int x,y,z,v;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        ad(x+1,y+1);\n    }\n    A.type=1;\n    A.build();\n    B.type=0;\n    B.build();\n    for(int i=1;i<=n;i++)\n    {\n        dfa[i]=A.dfn[i];sia[i]=A.siz[i];\n        dfb[i]=B.dfn[i];sib[i]=B.siz[i];\n        ss[i].a=dfa[i];\n        ss[i].b=dfb[i];\n    }\n    sort(ss+1,ss+n+1,cmp);\n    for(int i=1;i<=n;i++)\n        build(rt[i-1],rt[i],1,n,ss[i].b);\n    for(int i=1;i<=q;i++)\n    {\n        scanf(\"%d%d%d%d\",&x,&y,&z,&v);\n        x++;y++;z++;v++;\n        x=A.lca(x,z);\n        y=B.lca(y,v);\n        if(query(rt[dfa[x]-1],rt[dfa[x]+sia[x]-1],1,n,dfb[y],dfb[y]+sib[y]-1))\n            puts(\"1\");\n        else\n            puts(\"0\");\n    }\n    return 0;\n}\n```",
        "postTime": 1549163875,
        "uid": 103990,
        "name": "asd_a",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u5148\u8003\u8651\u72fc\u5f62\uff0c\u5176\u53ea\u80fd\u8d70\u7f16\u53f7\u5c0f\u4e8e$R$\u7684\u70b9\u3002\u82e5\u5c06\u6bcf\u6761\u8fb9\u8d4b\u8fb9\u6743\u4e3a\u5176\u4e24\u7aef\u70b9\u7f16\u53f7\u7684\u8f83\u5927\u503c\uff0c\u7136\u540e\u6309\u6700\u5c0f\u751f\u6210\u6811\u7684\u987a\u5e8f\u6784\u5efa$Kruskal$\u91cd\u6784\u6811\u3002\n\n\u90a3\u4e48\u4ece\u539f\u56fe\u7684\u4e00\u4e2a\u70b9$x$\u5728\u6811\u4e0a\u500d\u589e\uff0c\u5230\u8fbe\u6ee1\u8db3\u8981\u6c42\u4e14\u6df1\u5ea6\u6700\u6d45\u7684\u8282\u70b9\uff0c\u8be5\u8282\u70b9\u5b50\u6811\u5185\u6240\u6709\u539f\u56fe\u4e2d\u7684\u70b9\uff0c\u72fc\u5f62\u4ece$x$\u90fd\u80fd\u5230\u8fbe\u3002\n\n\u540c\u6837\u7684\uff0c\u4eba\u5f62\u6784\u5efa\u91cd\u6784\u6811\u5c31\u662f\u8fb9\u6743\u4e3a\u4e24\u7aef\u70b9\u7f16\u53f7\u7684\u8f83\u5c0f\u503c\uff0c\u6309\u6700\u5927\u751f\u6210\u6811\u7684\u987a\u5e8f\u3002\n\n\u5148\u6784\u5efa\u8fd9\u4e24\u68f5$Kruskal$\u91cd\u6784\u6811\uff0c\u5bf9\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u53ea\u9700\u67e5\u8be2\u8d77\u70b9\u548c\u7ec8\u70b9\u5206\u522b\u6811\u4e0a\u500d\u589e\u540e\u5b50\u6811\u5185\u7684\u8282\u70b9\u662f\u5426\u6709\u4ea4\u5373\u53ef\u3002\n\n\u5224\u65ad\u6709\u4ea4\u53ef\u4ee5\u901a\u8fc7$dfs$\u5e8f\u3002\u8bbe\u4e24\u68f5\u91cd\u6784\u6811\u5206\u522b\u4e3a$A$\u548c$B$\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u5728\u4e24\u68f5\u6811\u4e0a\u7684$dfs$\u5e8f\u770b\u4f5c\u70b9\u5bf9\u7684\u5f62\u5f0f$(dfn_A,dfn_B)$\u3002\u56e0\u4e3a\u5b50\u6811\u4e2d\u7684$dfs$\u5e8f\u90fd\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u5c31\u628a\u95ee\u9898\u8f6c\u5316\u4e3a\u4e8c\u7ef4\u6570\u70b9\u3002\u53ef\u4ee5\u5bf9$dfn_A$\u8fd9\u4e00\u7ef4\u6784\u5efa\u4e3b\u5e2d\u6811\uff0c$dfn_B$\u4f5c\u4e3a\u6743\u503c\u63d2\u5165\uff0c\u5224\u65ad\u6709\u4ea4\u53ea\u9700\u770b\u77e9\u5f62\u4e2d\u662f\u5426\u5b58\u5728\u70b9\u5373\u53ef\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\u5427\u3002\n\n$code:$\n\n```cpp\n#include<bits/stdc++.h>\n#define maxn 1200010\n#define maxm 10000010\n#define inf 1000000000\n#define mid ((l+r)>>1)\nusing namespace std;\ntemplate<typename T> inline void read(T &x)\n{\n    x=0;char c=getchar();bool flag=false;\n    while(!isdigit(c)){if(c=='-')flag=true;c=getchar();}\n    while(isdigit(c)){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    if(flag)x=-x;\n}\nint n,m,q,tree_cnt;\nint p[maxn],rt[maxn],cnt[maxm],ls[maxm],rs[maxm];\nstruct Edge\n{\n    int x,y;\n}ed[maxn];\nbool cmp1(const Edge &a,const Edge &b)\n{\n    return max(a.x,a.y)<max(b.x,b.y);\n}\nbool cmp2(const Edge &a,const Edge &b)\n{\n    return min(a.x,a.y)>min(b.x,b.y);\n}\nstruct node\n{\n    int tot,dfn_cnt;\n    int val[maxn],fa[maxn],f[maxn][25],in[maxn],out[maxn];\n    struct edge\n    {\n        int to,nxt;\n    }e[maxn];\n    int head[maxn],edge_cnt;\n    void add(int from,int to)\n    {\n        e[++edge_cnt]=(edge){to,head[from]};\n        head[from]=edge_cnt;\n    }\n    int find(int x)\n    {\n        return fa[x]==x?x:fa[x]=find(fa[x]);\n    }\n    void dfs(int x)\n    {\n        for(int i=1;i<=20;++i) f[x][i]=f[f[x][i-1]][i-1];\n        in[x]=++dfn_cnt;\n        for(int i=head[x];i;i=e[i].nxt) dfs(e[i].to);\n        out[x]=dfn_cnt;\n    }\n    void build(int type)\n    {\n    \ttot=n;\n        if(!type) sort(ed+1,ed+m+1,cmp1);\n        else sort(ed+1,ed+m+1,cmp2);\n        for(int i=1;i<=2*n-1;++i) fa[i]=i;\n        for(int i=1;i<=m;++i)\n        {\n            int x=find(ed[i].x),y=find(ed[i].y);\n            if(x==y) continue;\n            if(!type) val[++tot]=max(ed[i].x,ed[i].y);\n            else val[++tot]=min(ed[i].x,ed[i].y);\n            add(tot,y),add(tot,x),fa[x]=fa[y]=f[x][0]=f[y][0]=tot;\n            if(tot==2*n-1) break;\n        }\n        dfs(tot);\n    }\n    int get(int x,int v,int type)\n    {\n        for(int i=20;i>=0;--i)\n        {\n            if(!type&&f[x][i]&&val[f[x][i]]<=v) x=f[x][i];\n            if(type&&f[x][i]&&val[f[x][i]]>=v) x=f[x][i];\n        }\n        return x;\n    }\n}A,B;\nbool cmp3(const int &a,const int &b)\n{\n    return A.in[a]<A.in[b];\n}\nvoid modify(int l,int r,int pos,int v,int &cur)\n{\n    int x=++tree_cnt;\n    ls[x]=ls[cur],rs[x]=rs[cur],cnt[x]=cnt[cur]+v,cur=x;\n    if(l==r) return;\n    if(pos<=mid) modify(l,mid,pos,v,ls[cur]);\n    else modify(mid+1,r,pos,v,rs[cur]);\n}\nint query(int L,int R,int l,int r,int x,int y)\n{\n    if(L<=l&&R>=r) return cnt[y]-cnt[x];\n    int v=0;\n    if(L<=mid) v+=query(L,R,l,mid,ls[x],ls[y]);\n    if(R>mid) v+=query(L,R,mid+1,r,rs[x],rs[y]);\n    return v;\n}\nint main()\n{\n    read(n),read(m),read(q);\n    for(int i=1;i<=m;++i)\n    {\n        read(ed[i].x),read(ed[i].y);\n        ed[i].x++,ed[i].y++;\n    }\n    A.build(0),B.build(1);\n    for(int i=1;i<=2*n-1;++i) p[i]=i;\n    sort(p+1,p+2*n,cmp3);\n    for(int i=1;i<=2*n-1;++i)\n        rt[i]=rt[i-1],modify(1,2*n-1,B.in[p[i]],p[i]<=n,rt[i]);\n    while(q--)\n    {\n        int x,y,l,r;\n        read(x),read(y),read(l),read(r);\n        x++,y++,l++,r++,x=B.get(x,l,1),y=A.get(y,r,0);\n        if(query(B.in[x],B.out[x],1,2*n-1,rt[A.in[y]-1],rt[A.out[y]])) puts(\"1\");\n        else puts(\"0\");\n    }\n    return 0;\n}\n```\n",
        "postTime": 1589108606,
        "uid": 172489,
        "name": "lhm_",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u9996\u5148\u8fd9\u9898\u662f$Kruskal$\u91cd\u6784\u6811\u6ca1\u95ee\u9898\uff0c\u8fd9\u91cc\u63d0\u4f9b\u53e6\u5916\u4e00\u79cd\u5224\u65ad\u4e24\u68f5\u5b50\u6811\u662f\u5426\u6709\u4ea4\u96c6\u7684\u65b9\u6cd5\uff0c\u5c31\u662f\u5148\u628a\u6bcf\u4e2a\u70b9\u7684\u5728\u6811$A$\u4e2d\u7684$dfs$\u5e8f\u641e\u51fa\u6765\uff0c\u7136\u540e\u5728\u6811$B$\u4e0a\u8fdb\u884c\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u67e5\u8be2\u7684\u65f6\u5019\u5c31\u5728\u6811$B$\u4e0a\u7684\u70b9\u7684\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u67e5\u8be2\u662f\u5426\u6709\u6811$A$\u7684$dfs$\u5e8f\u533a\u95f4\u5185\u7684\u70b9\uff0c\u7b80\u5355\u7c97\u66b4\u3002~~\u867d\u7136\u5e38\u6570\u5927\u70b9~~\n\n\u4e0a\u4ee3\u7801~\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ls(_o) lef[_o]\n#define rs(_o) rgh[_o]\nusing namespace std\uff1b\nnamespace ywy{\n\tinline int get(){\n\t\tint n=0;char c;while((c=getchar())||23333){\n\t\t\tif(c>='0'&&c<='9')break;if(c=='-')goto s;\n\t\t}n=c-'0';while((c=getchar())||23333){\n\t\t\tif(c>='0'&&c<='9')n=n*10+c-'0';else return(n);\n\t\t}s:while((c=getchar())||23333){\n\t\t\tif(c>='0'&&c<='9')n=n*10-c+'0';else return(n);\n\t\t}\n\t}\n\ttypedef struct _xb{\n\t\tint s;int t;\n\t\tfriend bool operator <(const _xb &a,const _xb &b){\n\t\t\treturn(max(a.s,a.t)<max(b.s,b.t));\n\t\t}\n\t}xiabb;\n\txiabb bians[400001];int ints[1000001];int gn=1;int heads[1000001];\n\tunsigned char data[10000001];int lef[10000001],rgh[10000001],root[1000001],gseg=1;\n\tint united(int a,int b){\n\t\tif(!(a&&b))return(a|b);\n\t\tint tree=gseg;gseg++;\n\t\tdata[tree]=data[a]|data[b];\n\t\tlef[tree]=united(lef[a],lef[b]);\n\t\trgh[tree]=united(rgh[a],rgh[b]);return(tree);\n\t}\n\tvoid insert(int l,int r,int pt,int &tree){\n\t\tif(!tree)tree=gseg,gseg++;\n\t\tdata[tree]=1;if(l==r)return;\n\t\tint mid=(l+r)>>1;if(pt<=mid)insert(l,mid,pt,lef[tree]);\n\t\telse insert(mid+1,r,pt,rgh[tree]);\n\t}\n\tint find(int n){\n\t\tif(ints[n]==n)return(n);\n\t\treturn(ints[n]=find(ints[n]));\n\t}int ancea[1000001][20],anceb[1000001][20],val[1000001];\n\tunsigned char query(int rl,int rr,int l,int r,int tree){\n\t\tif(!data[tree])return(0);\n\t\tif(rl==l&&rr==r)return(1);\n\t\tint mid=(l+r)>>1;\n\t\tif(rl>mid)return(query(rl,rr,mid+1,r,rs(tree)));\n\t\tif(rr<=mid)return(query(rl,rr,l,mid,ls(tree)));\n\t\treturn(query(rl,mid,l,mid,ls(tree))||query(mid+1,rr,mid+1,r,rs(tree)));\n\t}\n\ttypedef struct _b{\n\t\tint dest;int nxt;\n\t}\n\tbian;bian memchi[1000001];\n\tinline void add(int s,int t){\n\t\tmemchi[gn].dest=t;memchi[gn].nxt=heads[s];heads[s]=gn;gn++;\n\t}\n\tint dfn[1000001],size[1000001],deepa[1000001],deepb[1000001],gdfn=1;\n\tvoid dfsa(int pt){\n\t\tfor(register int i=heads[pt];i;i=memchi[i].nxt){\n\t\t\tancea[memchi[i].dest][0]=pt;deepa[memchi[i].dest]=deepa[pt]+1;\n\t\t\tdfsa(memchi[i].dest);\n\t\t\troot[pt]=united(root[pt],root[memchi[i].dest]);\n\t\t}\n\t}\n\tvoid dfsb(int pt){dfn[pt]=gdfn;gdfn++;size[pt]=1;\n\t\tfor(register int i=heads[pt];i;i=memchi[i].nxt){\n\t\t\tanceb[memchi[i].dest][0]=pt;\n\t\t\tdeepb[memchi[i].dest]=deepb[pt]+1;\n\t\t\tdfsb(memchi[i].dest);\n\t\t\tsize[pt]+=size[memchi[i].dest];\n\t\t}\n\t}\n\tint cmp(const xiabb &a,const xiabb &b){\n\t\treturn(min(a.s,a.t)>min(b.s,b.t));\n\t}\n\tvoid ywymain(){\n\t\tint n=get(),m=get(),q=get();\n\t\tfor(register int i=1;i<=m;i++)bians[i].s=get()+1,bians[i].t=get()+1;\n\t\tsort(bians+1,bians+1+m);\n\t\tfor(register int i=1;i<=n;i++)ints[i]=i;\n\t\tint gnn=n+1;\n\t\tfor(register int i=1;i<=m;i++){\n\t\t\tint aa=find(bians[i].s),ab=find(bians[i].t);\n\t\t\tif(aa==ab)continue;\n\t\t\tint me=gnn;gnn++;\n\t\t\tval[me]=max(bians[i].s,bians[i].t);\n\t\t\tints[aa]=me;\n\t\t\tints[ab]=me;\n\t\t\tints[me]=me;\n\t\t\tadd(me,aa);\n\t\t\tadd(me,ab);\n\t\t}\n\t\tint K=gnn-1;gnn+=n;\n\t\tfor(register int i=K+1;i<=K+n;i++)ints[i]=i;\n\t\tsort(bians+1,bians+1+m,cmp);\n\t\tfor(register int i=1;i<=m;i++){\n\t\t\tint aa=find(bians[i].s+K),ab=find(bians[i].t+K);\n\t\t\tif(aa==ab)continue;\n\t\t\tint me=gnn;gnn++;\n\t\t\tval[me]=min(bians[i].s,bians[i].t);\n\t\t\tints[aa]=me;\n\t\t\tints[ab]=me;\n\t\t\tints[me]=me;\n\t\t\tadd(me,aa);\n\t\t\tadd(me,ab);\n\t\t}\n\t\tdfsb(find(K+1));gdfn--;\n\t\tfor(register int i=1;i<=n;i++)insert(1,gdfn,dfn[K+i],root[i]);\n\t\tdfsa(find(1));\n\t\tfor(register int i=1;i<=19;i++){\n\t\t\tfor(register int j=1;j<=K;j++){\n\t\t\t\tif(deepa[j]<(1<<i))continue;\n\t\t\t\tancea[j][i]=ancea[ancea[j][i-1]][i-1];\n\t\t\t}for(register int j=K+1;j<gnn;j++){\n\t\t\t\tif(deepb[j]<(1<<i))continue;\n\t\t\t\tanceb[j][i]=anceb[anceb[j][i-1]][i-1];\n\t\t\t}\n\t\t}\n\t\twhile(q){\n\t\t\tq--;\n\t\t\tint s=get()+1,t=get()+1,l=get()+1,r=get()+1;\n\t\t\tint curb=s+K,cura=t;\n\t\t\tfor(register int i=19;i>=0;i--){\n\t\t\t\tif(ancea[cura][i]&&val[ancea[cura][i]]<=r)cura=ancea[cura][i];\n\t\t\t\tif(anceb[curb][i]&&val[anceb[curb][i]]>=l)curb=anceb[curb][i];\n\t\t\t}\n\t\t\tif(query(dfn[curb],dfn[curb]+size[curb]-1,1,gdfn,root[cura]))putchar('1');\n\t\t\telse putchar('0');putchar('\\n');\n\t\t}\n\t}\n}\nint main(){\n\tywy::ywymain();return(0);\n}\n\n```\n",
        "postTime": 1543230563,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "### **\u9898\u610f:**\n\n\u5f53\u4f60\u662f\u4eba\u5f62\u7684\u65f6\u5019\u4f60\u53ea\u80fd\u8d70 $[L,N-1]$ \u7684\u7f16\u53f7\u7684\u70b9\uff08\u5373**\u5927\u4e8e\u7b49\u4e8e**L\u7684\u70b9\uff09\n\n\u5f53\u4f60\u662f\u72fc\u5f62\u7684\u65f6\u5019\u4f60\u53ea\u80fd\u8d70 $[1,R]$ \u7684\u7f16\u53f7\u7684\u70b9\uff08\u5373**\u5c0f\u4e8e\u7b49\u4e8e**R\u7684\u70b9\uff09\n\n\u7136\u540e\u95ee\u9898\u8f6c\u5316\u6210\u4eba\u5f62\u548c\u72fc\u5f62\u80fd\u5230\u7684\u70b9\u6709\u6ca1\u6709\u4ea4\u96c6\u3002\n\n\n\n### **solution:**\n\u53d1\u73b0\u53ef\u4ee5\u5efa kruskal\u91cd\u6784\u6811\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u5728\u6811\u4e0a\u500d\u589e\u6765\u6c42\u51fa\u6765\u4e00\u4e2a\u5b50\u6811\uff0c\u8fd9\u4e2a\u5b50\u6811\u5185\u662f\u4f60\u53ef\u4ee5\u5230\u7684\u70b9\u3002\u7136\u540e\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u4e24\u4e2a\u5b50\u6811\u533a\u95f4\u7684\u4ea4\uff0c\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u89e3\u51b3\u3002\n\n\u5b9a\u4e49 $rev1_i$ \u662f\u5728\u6811\u4e0a\u7684\u7b2c $i$ \u4e2a\u4f4d\u7f6e\u5bf9\u5e94\u7684\u6570\uff0c\u90a3\u4f60\u5b9a\u4e49 $r_{rev1_i}=i$\uff0c\u90a3\u4e48 $r_i$ \u5c31\u662f\u8fd9\u4e2a\u5143\u7d20\u5728\u6811\u4e0a\u51fa\u73b0\u7684\u4f4d\u7f6e\uff0c$rev2_i$\u540c\u7406\uff0c\u5373\u8fd9\u4e2a\u6570\u5728\u7b2c\u4e8c\u68f5\u6811\u4e0a\u5bf9\u5e94\u7684\u6570\uff0c\u7136\u540e\u4e3b\u5e2d\u6811\u6c42\u89e3\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nint read() {\n  int x = 0;\n  char c = getchar();\n  while (c < 48) c = getchar();\n  while (c > 47) x = x * 10 + (c - 48), c = getchar();\n  return x;\n}\n\nint n, m, q;\nconst int maxn = 4e5 + 54;\n\nstruct edge {\n  int u, v;\n};\nvector<edge> e;\n\nint fa[maxn];\nint find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }\n\nvector<int> g[maxn];\n\nstruct Tree {\n  int L[maxn], R[maxn], idx;\n  int rev[maxn], val[maxn], f[maxn][22];\n  void dfs(int u) {\n    if (u <= n) {\n      rev[L[u] = ++idx] = u;\n      val[u] = u;\n    } else\n      L[u] = idx + 1;\n    for (int i = 1; i <= 20; i++) f[u][i] = f[f[u][i - 1]][i - 1];\n    for (int v : g[u]) f[v][0] = u, dfs(v);\n    R[u] = idx;\n  }\n  int getu(int s, int l) {\n    for (int i = 20; ~i; i--)\n      if (f[s][i] && val[f[s][i]] >= l) s = f[s][i];\n    return s;\n  }\n  int getv(int t, int r) {\n    for (int i = 20; ~i; i--)\n      if (f[t][i] && val[f[t][i]] <= r) t = f[t][i];\n    return t;\n  }\n} t1, t2;\n\nint tot;\nint rt[maxn], ls[maxn << 5], rs[maxn << 5], val[maxn << 5], cnt = 0;\n\nvoid upd(int& p, int pre, int l, int r, int x) {\n  ls[p = ++cnt] = ls[pre], rs[p] = rs[pre], val[p] = val[pre] + 1;\n  if (l == r) return;\n  int mid = l + r >> 1;\n  if (x <= mid)\n    upd(ls[p], ls[pre], l, mid, x);\n  else\n    upd(rs[p], rs[pre], mid + 1, r, x);\n}\n\nint qry(int a, int b, int ql, int qr, int l, int r) {\n  if (ql <= l && r <= qr) return val[b] - val[a];\n  int mid = l + r >> 1, ans = 0;\n  if (ql <= mid) ans = qry(ls[a], ls[b], ql, qr, l, mid);\n  if (qr > mid) ans += qry(rs[a], rs[b], ql, qr, mid + 1, r);\n  return ans;\n}\n\nint main() {\n  n = read(), m = read(), q = read();\n  for (int i = 0; i < m; i++) {\n    int u = read(), v = read();\n    ++u, ++v;\n    if (u > v) u ^= v ^= u ^= v;\n    e.push_back({ u, v });\n  }\n  for (int i = 1; i <= n * 2; i++) fa[i] = i, g[i].clear();\n  sort(e.begin(), e.end(), [](edge a, edge b) { return a.u > b.u; });\n  tot = n;\n  for (auto x : e) {\n    int u = find(x.u), v = find(x.v);\n    if (u == v) continue;\n    fa[u] = fa[v] = ++tot;\n    t1.val[tot] = x.u;\n    g[tot].push_back(u), g[tot].push_back(v);\n  }\n  t1.dfs(tot);\n\n  for (int i = 1; i <= n * 2; i++) fa[i] = i, g[i].clear();\n  sort(e.begin(), e.end(), [](edge a, edge b) { return a.v < b.v; });\n  tot = n;\n  for (auto x : e) {\n    int u = find(x.u), v = find(x.v);\n    if (u == v) continue;\n    fa[u] = fa[v] = ++tot;\n    t2.val[tot] = x.v;\n    g[tot].push_back(u), g[tot].push_back(v);\n  }\n  t2.dfs(tot);\n  vector<int> r(n + 1);\n  for (int i = 1; i <= n; i++) r[t1.rev[i]] = i;\n  for (int i = 1; i <= n; i++) upd(rt[i], rt[i - 1], 1, n, r[t2.rev[i]]);\n  for (int i = 0; i < q; i++) {\n    int s = read(), t = read(), l = read(), r = read();\n    ++s, ++t, ++l, ++r;\n    int u = t1.getu(s, l), v = t2.getv(t, r);\n    if (qry(rt[t2.L[v] - 1], rt[t2.R[v]], t1.L[u], t1.R[u], 1, n))\n      puts(\"1\");\n    else\n      puts(\"0\");\n  }\n  return 0;\n}\n```",
        "postTime": 1582637298,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u4e00\u53e5\u8bdd\u9898\u610f\uff1a$n$ \u4e2a\u70b9 $m$ \u6761\u8fb9\u7684\u56fe\uff0c\u6709 $Q$ \u4e2a\u8be2\u95ee\uff0c\u6bcf\u6b21\u4ece $s_i$ \u51fa\u53d1\uff0c\u53ea\u80fd\u591f\u5230\u8fbe $\\geq l_i$ \u7684\u70b9\uff0c\u5728 $[l_i,r_i]$ \u5fc5\u987b\u53d8\u8eab\u4e00\u6b21\uff0c\u4e4b\u540e\u53ea\u80fd\u591f\u5230\u8fbe $\\leq r_i$ \u7684\u70b9\uff0c\u95ee\u80fd\u5426\u5230\u8fbe $t_i$\u3002\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u95ee\u9898\u7b49\u4ef7\u4e8e\u4ece $s_i$ \u51fa\u53d1\u80fd\u591f\u5230\u8fbe\u7684\u70b9\u4e0e\u4ece $t_i$ \u51fa\u53d1\u80fd\u591f\u5230\u8fbe\u7684\u70b9\u662f\u5426\u5b58\u5728\u4ea4\u96c6\u3002\u5bf9\u4e8e\u8fd9\u4e00\u7c7b\u5bf9\u8def\u5f84\u9014\u5f84\u7684\u70b9 $/$ \u8fb9\u8fdb\u884c\u9650\u5236\uff0c\u5374\u53ea\u8981\u6c42\u5224\u65ad\u8fde\u901a\u6027 $/$ \u53ef\u8fbe\u6027\u7684\u95ee\u9898\uff0c\u53ef\u4ee5\u4f7f\u7528 $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\u89e3\u51b3\u3002\n\n\u57fa\u4e8e $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\u7684\u8fde\u901a\u6027\u4e0e\u539f\u751f\u6210\u6811\u76f8\u540c\uff0c\u53ef\u4ee5\u5f88\u597d\u7684\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u3002\u4f46\u662f $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\u9700\u8981\u6709\u8fb9\u6743\uff0c\u539f\u56fe\u4e0a\u6ca1\u6709\uff0c\u600e\u4e48\u529e\u5462\uff1f\u6211\u4eec\u7ed9\u6bcf\u6761\u8fb9 $(x,y)$ \u8d4b\u4e0a\u4e00\u4e2a\u6743\u503c $w$ \u5373\u53ef\u3002\n\n\u8fd9\u91cc\u4ee5 $\\leq r_i$ \u4e3a\u4f8b\uff0c\u91cd\u6784\u8fc7\u7a0b\u4e2d\uff0c\u628a\u4e00\u6761\u8fb9\u8f6c\u6362\u6210\u4e00\u4e2a\u70b9\uff0c\u8bf4\u660e\u8fd9\u4e24\u4e2a\u70b9\u5728\u751f\u6210\u6811\u4e0a\u5fc5\u987b\u7ecf\u8fc7\u8fd9\u6761\u8fb9 $(u,v)$\uff0c\u5e76\u4e14\u7ecf\u8fc7\u8fd9\u6761\u8fb9\u65f6\uff0c\u53ea\u6709 $\\max(u,v)$ \u53ef\u80fd\u4f1a\u5bf9\u5f53\u524d\u7ecf\u8fc7\u70b9\u7684\u6700\u5927\u503c\u4ea7\u751f\u5f71\u54cd\u3002\u6240\u4ee5\u5c06 $(u,v)$ \u7684\u8fb9\u6743\u8d4b\u4e3a $\\max(u,v)$\uff0c\u7136\u540e\u6c42\u6700\u5c0f\u751f\u6210\u6811\u7684 $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\uff0c\u8bb0\u8fd9\u68f5 $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\u4e3a $T_1$\u3002$\\geq l_i$ \u7684\u90e8\u5206\u540c\u7406\u3002\u53c2\u7167\u4e0a\u8ff0\u5206\u6790\u8fc7\u7a0b\uff0c\u5c06 $(u,v)$ \u8fb9\u6743\u8d4b\u4e3a $\\min(u,v)$ \u518d\u6c42\u6700\u5927\u751f\u6210\u6811\u7684 $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\uff0c\u8bb0\u8fd9\u68f5 $\\mathrm{Kruskal}$ \u91cd\u6784\u6811\u4e3a $T_2$\u3002\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u73b0\u5728\u5f97\u5230\u4e86\u4e24\u68f5\u91cd\u6784\u6811 $T_1,T_2$\uff0c\u5e76\u4e14\u80fd\u591f\u5728\u6bcf\u6b21\u8be2\u95ee\u65f6\u53d6\u51fa\u8fd9\u4e24\u68f5\u6811\u7684\u5b50\u6811 $x,y$\uff0c\u95ee\u9898\u53d8\u4e3a\u5224\u65ad\u8fd9\u4e24\u68f5\u5b50\u6811 $x,y$ \u662f\u5426\u5b58\u5728\u4ea4\u96c6\u3002\u5c06\u8fd9\u4e24\u68f5\u6811\u7684 $\\mathrm{dfs}$ \u5e8f\u6c42\u51fa\u6765\u3002\u95ee\u9898\u518d\u6b21\u88ab\u8f6c\u5316\u6210\u5224\u65ad\u4e24\u4e2a\u5e8f\u5217\u662f\u5426\u5b58\u5728\u4ea4\u96c6\u3002\n\n\u8bb0\u5b50\u6811 $x$ \u5728 $T_1$ \u7684 $\\mathrm{dfs}$ \u5e8f\u4e0a\u5bf9\u5e94\u533a\u95f4 $[l_1,r_1]$\uff0c\u5b50\u6811 $y$ \u5728 $T_2$ \u7684 $\\mathrm{dfs}$ \u5e8f\u4e0a\u5bf9\u5e94\u533a\u95f4 $[l_2,r_2]$\uff0c$T_1$ \u7684 $\\mathrm{dfs}$ \u5e8f\u5217\u4e3a $a$\uff0c$T_2$ \u7684 $\\mathrm{dfs}$ \u5e8f\u5217\u4e3a $b$ \u3002\u5c06\u8fd9\u4e2a\u95ee\u9898\u5f62\u5f0f\u5316\uff0c\u5373\u5224\u65ad $\\exists i\\in [l_1,r_1],j\\in [l_2,r_2],a_i,b_j\\leq n,a_i=b_j$\u3002\u4f3c\u4e4e\u4e0d\u662f\u5f88\u597d\u505a\uff0c\u4e0d\u59a8\u56fa\u5b9a\u5176\u4e2d\u4e00\u4e2a\u7ea6\u675f\u3002\u8bb0 $c_x$ \u4e3a\u8282\u70b9\u7f16\u53f7 $x$ \u5728\u5e8f\u5217 $a$ \u4e2d\u51fa\u73b0\u7684\u4f4d\u7f6e\u3002\u5219\u4ee5\u4e0a\u5224\u5b9a\u53ef\u4ee5\u88ab\u5199\u4f5c $\\exists b_j\\leq n,j\\in [l_2,r_2],c_{b_j}\\in [l_1,r_1]$\u3002\u76f4\u63a5\u4e3b\u5e2d\u6811\u7ef4\u62a4\u5c31\u597d\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O((Q+n) \\log n+m\\log m)$\u3002\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nstruct edge {int x,y,w;} e[2][400005];\nint n,m,t,tot[2],cnt[2],num[2];\nint h[2][400005],to[2][400005],ver[2][400005];\nint f[2][400005][20],g[2][400005][20],fa[400005];\nint dfn[2][400005],rev[2][400005],size[2][400005],val[2][400005];\nint rt[400005],sonL[16000005],sonR[16000005],sum[16000005];\ninline int read() {\n\tregister int x=0,f=1;register char s=getchar();\n\twhile(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}\n\treturn x*f;\n}\ninline int find(int x) {return x==fa[x]? x:fa[x]=find(fa[x]);}\ninline bool cmp(const edge &x,const edge &y) {return x.w<y.w;} \ninline int max(const int &x,const int &y) {return x>y? x:y;}\ninline int min(const int &x,const int &y) {return x<y? x:y;}\ninline void assign(int x,int y) {sonL[x]=sonL[y]; sonR[x]=sonR[y]; sum[x]=sum[y];}\ninline void add(int x,int y,int id) {to[id][++cnt[id]]=y;ver[id][cnt[id]]=h[id][x];h[id][x]=cnt[id];}\ninline void dfs1(int x,const int &id,int fa) {\n\tdfn[id][x]=++num[id]; rev[id][num[id]]=x; size[id][x]=1; //printf(\"%d\\n\",x);\n\tfor(register int i=1;i<=19;++i) f[id][x][i]=f[id][f[id][x][i-1]][i-1],g[id][x][i]=max(g[id][x][i-1],g[id][f[id][x][i-1]][i-1]);\n\tfor(register int i=h[id][x],y;i;i=ver[id][i]) {if((y=to[id][i])==fa) continue; f[id][y][0]=x; g[id][y][0]=val[id][x]; dfs1(y,id,x); size[id][x]+=size[id][y];} \n}\ninline int jump(int u,int lim,int id) {for(register int i=19;i>=0;--i) if(f[id][u][i]&&g[id][u][i]<=lim) u=f[id][u][i]; return u;}\ninline void prework(int id) {\n\tstd::sort(e[id]+1,e[id]+1+m,cmp); tot[id]=n; for(register int i=1;i<=2*n-1;++i) fa[i]=i;\n\tfor(register int i=1,fx,fy;i<=m;++i) if((fx=find(e[id][i].x))!=(fy=find(e[id][i].y))) {fa[fx]=fa[fy]=++tot[id]; val[id][tot[id]]=e[id][i].w; add(tot[id],fx,id); add(tot[id],fy,id);}\n\tfor(register int i=n+1;i<=tot[id];++i) if(fa[i]==i) dfs1(i,id,-1);\n}\ninline void change(int &p,int lst,int l,int r,int x) {assign(p=++t,lst); ++sum[p]; if(l==r) return; int mid=l+r>>1; x<=mid? change(sonL[p],sonL[lst],l,mid,x):change(sonR[p],sonR[lst],mid+1,r,x);}\ninline int ask(int x,int y,int l,int r,int L,int R) {if(L<=l&&r<=R) return sum[y]-sum[x]; int mid=l+r>>1,res=0; if(L<=mid) res+=ask(sonL[x],sonL[y],l,mid,L,R); if(R>mid) res+=ask(sonR[x],sonR[y],mid+1,r,L,R); return res;}\nint main() {\n\tn=read();m=read(); int Q=read();\n\tfor(register int i=1;i<=m;++i) {\n\t\te[0][i].x=e[1][i].x=read()+1;\n\t\te[0][i].y=e[1][i].y=read()+1;\n\t\te[0][i].w=max(e[0][i].x,e[0][i].y);\n\t\te[1][i].w=-min(e[0][i].x,e[0][i].y);\n\t}\n\tprework(0); prework(1);\n\tfor(register int i=1,x;i<=tot[1];++i) {if((x=rev[1][i])<=n) change(rt[i],rt[i-1],1,tot[0],dfn[0][x]); else rt[i]=rt[i-1];}\n\twhile(Q--) {\n\t\tint S=read()+1,E=read()+1,L=read()+1,R=read()+1;\n\t\tint u=jump(S,-L,1),v=jump(E,R,0);\n\t\tint l1=dfn[0][v],r1=dfn[0][v]+size[0][v]-1,l2=dfn[1][u],r2=dfn[1][u]+size[1][u]-1;\n\t\tint res=ask(rt[l2-1],rt[r2],1,tot[0],l1,r1);\n\t\tprintf(\"%d\\n\",res>0); \n\t}\n\treturn 0; \n} \n```",
        "postTime": 1602905793,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "# \u3010IOI2018\u3011\u72fc\u4eba\n\n\u95ee\u9898\u8f6c\u5316\u4e00\u4e0b\uff0c\u5176\u5b9e\u5c31\u662f\u95ee\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u70b9\uff0c\u80fd\u53ea\u7ecf\u8fc7\u5927\u4e8e\u7b49\u4e8eL\u7684\u70b9\u5230\u8fbeS\uff0c\u53ea\u7ecf\u8fc7\u5c0f\u4e8e\u7b49\u4e8eR\u7684\u70b9\u5230\u8fbeT\u3002\u4e8e\u662f\u6211\u4eec ~~\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u5c31\u5ffd\u7136~~ \u8003\u8651kruskal\u91cd\u6784\u6811\u3002\n\n\u5bf9\u4e8e\u68111\uff0c\u6211\u4eec\u8bbe\u8fb9(u,v)\u7684\u6743\u503c\u4e3a**min(u,v)**\uff0c\u7136\u540e\u6c42\u51fa\u6700**\u5927**\u751f\u6210\u6811\u7684kruskal\u91cd\u6784\u6811\u3002\u8bbe\u4ece\u70b9u\u51fa\u53d1\uff0c\u5728\u68111\u4e2d\u5f80\u4e0a\u8df3\u5230\u6700\u9876\u90e8\u7684\u6743\u503c**\u5927\u4e8e\u7b49\u4e8e**x\u7684\u70b9\u4e3av\uff0c\u5219v\u7684\u5b50\u6811\u4e2d\u6240\u6709\u70b9\u5c31\u662fu\u5728\u539f\u56fe\u4e2d\u53ea\u7ecf\u8fc7**\u5927\u4e8e\u7b49\u4e8e**x\u7684\u70b9\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\u3002\u6211\u4eec\u8bb0v=jump1(u,x)\n\n\u5bf9\u4e8e\u68112\uff0c\u6211\u4eec\u8bbe\u8fb9(u,v)\u7684\u6743\u503c\u4e3a**max(u,v)**\uff0c\u7136\u540e\u6c42\u51fa\u6700**\u5c0f**\u751f\u6210\u6811\u7684kruskal\u91cd\u6784\u6811\u3002\u8bbe\u4ece\u70b9u\u51fa\u53d1\uff0c\u5728\u68112\u4e2d\u5f80\u4e0a\u8df3\u5230\u6700\u9876\u90e8\u7684\u6743\u503c**\u5c0f\u4e8e\u7b49\u4e8e**x\u7684\u70b9\u4e3av\uff0c\u5219v\u7684\u5b50\u6811\u4e2d\u6240\u6709\u70b9\u5c31\u662fu\u5728\u539f\u56fe\u4e2d\u53ea\u7ecf\u8fc7**\u5c0f\u4e8e\u7b49\u4e8e**x\u7684\u70b9\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\u3002\u6211\u4eec\u8bb0v=jump2(u,x)\n\n\u8fd9\u6837\u4e00\u6765\uff0c\u4e00\u7ec4\u8be2\u95ee\u5c31\u88ab\u6211\u4eec\u8f6c\u5316\u4e3a\u4e86\uff1a\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u70b9\uff0c\u540c\u65f6\u4f4d\u4e8e\u68111\u7684jump1(S,L)\u5b50\u6811\u548c\u68112\u7684jump2(T,R)\u5b50\u6811\u4e2d\u3002\u5982\u679c\u6211\u4eec\u5c06\u4e00\u4e2a\u70b9\u5728\u68111\u4e0a\u7684dfs\u5e8f\u770b\u4f5c\u5b83\u5728\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684\u6a2a\u5750\u6807\uff0c\u5728\u68112\u4e0a\u7684dfs\u5e8f\u770b\u4f5c\u7eb5\u5750\u6807\uff0c\u90a3\u4e48\u539f\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u95ee\u5e73\u9762\u4e0a\u4e00\u4e2a\u77e9\u5f62\u4e2d\u662f\u5426\u5b58\u5728\u70b9\uff0c\u76f4\u63a5\u626b\u63cf\u7ebf+\u6811\u72b6\u6570\u7ec4\u5373\u53ef\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> pii;\nconst int N=400010;\nstruct E{int u,v;} e[N];\nstruct Event{int ty,a,b,c;};\nint n,m,q,tot,bit[N];\nvector<Event> g[N];\nint ans[N];\n\ninline int min(int x,int y){return x<y?x:y;}\ninline int max(int x,int y){return x>y?x:y;}\ninline bool leq(int x,int y){return x<=y;}\ninline bool geq(int x,int y){return x>=y;}\n\nstruct Kruskal\n{\n    int fa[N],val[N],ch[N][2],go[20][N];\n    int in[N],out[N],dfc;\n    int find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n    void dfs(int u)\n    {\n        in[u]=++dfc;\n        if(u>n) dfs(ch[u][0]);\n        if(u>n) dfs(ch[u][1]);\n        out[u]=dfc;\n    }\n    void build(int(*cmp)(int,int))\n    {\n        dfc=0;tot=n;\n        for(int i=1;i<=n;i++) val[i]=i;\n        for(int i=1;i<=n<<1;i++) fa[i]=i;\n        for(int i=1;i<=m;i++)\n        {\n            int u=e[i].u,v=e[i].v;\n            u=find(u);v=find(v);\n            if(u==v) continue;\n            val[++tot]=cmp(val[u],val[v]);\n            fa[u]=fa[v]=go[0][u]=go[0][v]=tot;\n            ch[tot][0]=u;ch[tot][1]=v;\n        }\n        dfs(tot);\n        go[0][tot]=tot;\n        for(int k=1;k<=18;k++)\n            for(int i=1;i<=tot;i++)\n                go[k][i]=go[k-1][go[k-1][i]];\n    }\n    pii jump(int u,int x,bool(*cmp)(int,int))\n    {\n        for(int k=18;k>=0;k--)\n            if(cmp(val[go[k][u]],x)) u=go[k][u];\n        return pii(in[u],out[u]);\n    }\n} t1,t2;\n\ninline int lowbit(const int &x){return x&-x;}\nvoid add(int p){for(p++;p<=n<<1;p+=lowbit(p)) bit[p]++;}\nint sum(int p){int res=0;for(p++;p;p-=lowbit(p)) res+=bit[p];return res;}\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&e[i].u,&e[i].v);\n        if(e[i].u>e[i].v) swap(e[i].u,e[i].v);\n        e[i].u++;e[i].v++;\n    }\n    sort(e+1,e+1+m,[](E a,E b){return a.u>b.u;});\n    t1.build(min);\n    sort(e+1,e+1+m,[](E a,E b){return a.v<b.v;});\n    t2.build(max);\n    for(int i=1;i<=n;i++)\n        g[t1.in[i]].push_back({1,t2.in[i],0,0});\n    for(int i=1,s,t,l,r,x1,x2,y1,y2;i<=q;i++)\n    {\n        scanf(\"%d%d%d%d\",&s,&t,&l,&r);\n        s++;t++;l++;r++;\n        tie(x1,x2)=t1.jump(s,l,geq);\n        tie(y1,y2)=t2.jump(t,r,leq);\n        g[x1-1].push_back({2,y1-1,i,1});\n        g[x1-1].push_back({2,y2,i,-1});\n        g[x2].push_back({2,y1-1,i,-1});\n        g[x2].push_back({2,y2,i,1});\n    }\n    for(int i=0;i<=n<<1;i++)\n        for(Event ev : g[i])\n        {\n            if(ev.ty==1) add(ev.a);\n            else ans[ev.b]+=ev.c*sum(ev.a);\n        }\n    for(int i=1;i<=q;i++)\n        puts(ans[i]?\"1\":\"0\");\n    return 0;\n}\n```",
        "postTime": 1549203490,
        "uid": 20158,
        "name": "Ebola",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u51ed\u501f\u7740\u8270\u82e6\u5353\u7edd\u7684\u6bc5\u529b\u548c Isaunoya \u7684\u9898\u89e3\u5c06\u8fd9\u9053\u9898\u5199\u4e86\u51fa\u6765\u3002\n\n\u8003\u8651\u5bf9\u6211\u4eec\u884c\u8d70\u7684\u9650\u5236\u3002\u5982\u679c\u6211\u4eec\u80fd\u627e\u5230\u4e00\u4e2a\u4e2d\u8f6c\u70b9 $x$\uff0c\u4f7f\u5f97\u5b58\u5728\u4e00\u6761\u8def\u5f84 $s \\to x \\to e$\uff0c\u4f5c\u4e3a\u4eba\u5f62\u7684\u65f6\u5019\u80fd\u591f\u4ece $s$ \u8d70\u5230 $x$\uff0c\u4f5c\u4e3a\u72fc\u5f62\u7684\u65f6\u5019\u80fd\u591f\u4ece $x$ \u8d70\u5230 $e$\uff0c\u8fd9\u4e2a\u8def\u5f84\u5c31\u662f\u5408\u6cd5\u7684\u3002\n\n\u8003\u8651\u5bf9\u4e8e\u4eba\u5f62\u548c\u72fc\u5f62\u7684\u9650\u5236\uff0c\u6211\u4eec\u9996\u5148\u5728 $s$ \u968f\u4fbf\u8d70\uff0c\u8d70\u904d\u4eba\u5f62\u4ece $e$ \u5f00\u59cb\u6240\u6709\u80fd\u591f\u8d70\u5230\u7684\u5730\u65b9\uff0c\u80fd\u8d70\u5230\u7684\u70b9\u96c6\u4e3a $S_1$\uff1b\u7136\u540e\u5047\u8bbe\u6211\u4eec\u8d70\u5230\u4e86 $e$\uff0c\u7136\u540e\u56de\u9000\uff0c\u8d70\u904d\u72fc\u5f62 $e$ \u5f00\u59cb\u6240\u6709\u80fd\u591f\u8d70\u5230\u7684\u5730\u65b9\uff0c\u80fd\u8d70\u5230\u7684\u70b9\u96c6\u4e3a $S_2$\u3002\u53d1\u73b0\u6ee1\u8db3\u5b58\u5728\u4e00\u6761\u5408\u6cd5\u7684\u8def\u5f84\uff0c\u5f53\u4e14\u4ec5\u5f53 $S_1\u222aS_2 \\neq \\varnothing$\u3002\u5feb\u901f\u6c42\u51fa\u8fd9\u4e24\u4e2a\u96c6\u5408\uff0c\u663e\u7136\u53ea\u662f\u4e00\u4e2a\u514b\u9c81\u65af\u5361\u5c14\u91cd\u6784\u6811\u7684\u677f\u5b50\uff0c\u5efa\u4e24\u68f5\u6811\u5c31\u884c\u4e86\u3002\u500d\u589e\u627e\u5230\u6811\u4e0a\u7684\u8282\u70b9\u4e4b\u540e\uff0c\u8fd9\u4e2a\u5b50\u6811\u6240\u6709\u7684\u53f6\u8282\u70b9\u90fd\u80fd\u591f\u8d70\u5230\u3002\u5c06\u5176\u62bd\u8c61\u4e3a\u4e24\u4e2a\u5e8f\u5217\uff0c\u73b0\u5728\u8981\u6c42\u7684\u5c31\u662f\u4e24\u4e2a\u5e8f\u5217\u6709\u6ca1\u6709\u4ea4\u96c6\u3002\n\n\u800c\u8fd9\u4e2a\u95ee\u9898\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u3002\u5bf9\u7b2c\u4e00\u4e2a\u5e8f\u5217\u505a\u5173\u4e8e\u7b2c\u4e8c\u4e2a\u5e8f\u5217\u7684\u6620\u5c04\uff0c\u6309\u6620\u5c04\u6570\u7ec4\u5efa\u6811\uff0c\u6700\u540e\u67e5\u8be2\u7684\u65f6\u5019\u5373\u770b $[L_e,R_e]$ \u533a\u95f4\u7248\u672c\u5185\u662f\u5426\u5b58\u5728 $[L_s,R_s]$ \u4e2d\u95f4\u7684\u4efb\u610f\u4e00\u4e2a\u6570\u5373\u53ef\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nchar buf[1<<21],*p1=buf,*p2=buf;\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nint read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0' || c>'9')\n\t{\n\t\tif(c=='-')\tf=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9')\tx=(x<<1)+(x<<3)+(c^'0'),c=getchar();\n\treturn x*f;\n}\nvoid write(int x)\n{\n\tif(x<0)\tputchar('-'),x=-x;\n\tif(x>9)\twrite(x/10);\n\tputchar(x%10+'0');\n}\nstruct Edge{\n\tint u,v,val;\n\tEdge(){u=v=val=0;}\n\tEdge(int U,int V,int VAL){u=U,v=V,val=VAL;}\n\tbool operator < (Edge another) const {return val<another.val;}\n}ed[400005];\nstruct UnionFindSet{\n\tint fa[1000005];\n\tvoid makeSet(int up){for(int i=0;i<=up;++i)\tfa[i]=i;}\n\tint findSet(int x)\n\t{\n\t\tif(x==fa[x])\treturn x;\n\t\treturn fa[x]=findSet(fa[x]);\n\t}\n\tvoid unionSet(int x,int y)\n\t{\n\t\tint xx=findSet(x),yy=findSet(y);\n\t\tif(xx==yy)\treturn ;\n\t\tfa[xx]=yy;\n\t}\n}ufs;\nint n,m,q,maped[1000005];\nint Abs(int x){return x>0?x:-x;}\nstruct KruskalRebuildTree{\n\tvector<int> G[1000005];\n\tint fa[1000005][21],tur[1000005],L[1000005],R[1000005],p[1000005],sjc;\n\tEdge sur[400005];\n\tvoid dfs(int u)\n\t{\n\t\tif(u<=n)\tL[u]=++sjc,tur[sjc]=u,p[u]=u;\n\t\telse\tL[u]=sjc+1;\n\t\tfor(int i=1;i<=20;++i)\tfa[u][i]=fa[fa[u][i-1]][i-1];\n\t\tfor(unsigned int i=0;i<G[u].size();++i)\tfa[G[u][i]][0]=u,dfs(G[u][i]);\n\t\tR[u]=sjc;\n\t}\n\tvoid Kruskal(int id)\n\t{\n//\t\tprintf(\"%d\\n\",id);\n\t\tufs.makeSet(2*n);\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tif(id==1)\tsur[i]=Edge(ed[i].u,ed[i].v,-min(ed[i].u,ed[i].v));\n\t\t\tif(id==2)\tsur[i]=Edge(ed[i].u,ed[i].v,max(ed[i].u,ed[i].v));\n\t\t}\n\t\tsort(sur+1,sur+1+m);\n\t\tint now=n;\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tint u=ufs.findSet(sur[i].u),v=ufs.findSet(sur[i].v),val=Abs(sur[i].val);\n\t\t\tif(u!=v)\n\t\t\t{\n\t\t\t\tufs.fa[u]=ufs.fa[v]=++now;\n\t\t\t\tG[now].push_back(u);\n\t\t\t\tG[now].push_back(v);\n\t\t\t\tp[now]=val;\n\t\t\t}\n\t\t}\n\t\tdfs(now);\n\t}\n\tint greatFind(int s,int up)\n\t{\n\t\tfor(int i=20;~i;--i)\tif(p[fa[s][i]]>=up && fa[s][i])\ts=fa[s][i];\n\t\treturn s;\n\t}\n\tint lessFind(int s,int up)\n\t{\n\t\tfor(int i=20;~i;--i)\tif(p[fa[s][i]]<=up && fa[s][i])\ts=fa[s][i];\n\t\treturn s;\n\t}\n}t1,t2;\nstruct ChairmanTree{\n\t#define Mm int mid=(l+r)>>1\n\tint root[22*400005],lch[22*400005],rch[22*400005],sum[22*400005],cnt;\n\tint build(int l,int r)\n\t{\n\t\tint rt=++cnt;\n\t\tif(l==r)\treturn rt;\n\t\tMm;\n\t\tlch[rt]=build(l,mid);\n\t\trch[rt]=build(mid+1,r);\n\t\treturn rt;\n\t}\n\tvoid buildEmptyTree(int pos){root[pos]=build(1,n);}\n\tvoid modify(int &rt,int x,int l,int r,int val)\n\t{\n\t\tif(!rt)\trt=++cnt;\n\t\tsum[rt]=sum[x]+1;\n\t\tif(l==r)\treturn ;\n\t\tMm;\n\t\tif(val<=mid)\tmodify(lch[rt],lch[x],l,mid,val),rch[rt]=rch[x];\n\t\telse\tmodify(rch[rt],rch[x],mid+1,r,val),lch[rt]=lch[x];\n\t}\n\tint query(int x,int y,int l,int r,int quel,int quer)\n\t{\n\t\tif(quel<=l && r<=quer)\treturn sum[y]-sum[x];\n\t\tMm,ans=0;\n\t\tif(quel<=mid)\tans+=query(lch[x],lch[y],l,mid,quel,quer);\n\t\tif(mid<quer)\tans+=query(rch[x],rch[y],mid+1,r,quel,quer);\n\t\treturn ans;\n\t}\n}fuck;\nint main(){\n\tn=read(),m=read(),q=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint u=read()+1,v=read()+1;\n\t\ted[i]=Edge(u,v,0);\n\t}\n\tt1.Kruskal(1);\n\tt2.Kruskal(2);\n\tfor(int i=1;i<=n;++i)\tmaped[t1.tur[i]]=i;\n\tfuck.buildEmptyTree(0);\n\tfor(int i=1;i<=n;++i)\tfuck.modify(fuck.root[i],fuck.root[i-1],1,n,maped[t2.tur[i]]);\n\twhile(q-->0)\n\t{\n\t\tint s=read()+1,e=read()+1,l=read()+1,r=read()+1;\n\t\ts=t1.greatFind(s,l);\n\t\te=t2.lessFind(e,r);\n\t\tint que=fuck.query(fuck.root[t2.L[e]-1],fuck.root[t2.R[e]],1,n,t1.L[s],t1.R[s]);\n\t\tputs(que?\"1\":\"0\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1599037147,
        "uid": 184977,
        "name": "pomelo_nene",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "\u4ece$S$\u51fa\u53d1\uff0c\u53ea\u7ecf\u8fc7\u7f16\u53f7\u5927\u4e8e\u7b49\u4e8e$L$\u7684\u70b9\uff0c\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\u6784\u6210\u7684\u96c6\u5408\u8bb0\u4e3a$A$\uff1b\n\n\u4ece$E$\u51fa\u53d1\uff0c\u53ea\u7ecf\u8fc7\u7f16\u53f7\u5c0f\u4e8e\u7b49\u4e8e$R$\u7684\u70b9\uff0c\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\u6784\u6210\u7684\u96c6\u5408\u8bb0\u4e3a$B$\uff0c\n\n\u90a3\u4e48\u5c31\u662f\u8981\u6c42$A\\cap B$\u662f\u5426\u4e3a\u7a7a\u96c6\u3002\n\n\u81ea\u7136\u60f3\u5230kruskal\u91cd\u6784\u6811\uff0c\u5148\u5bf9\u6bcf\u6761\u8fb9\u4ee5\u4e24\u4e2a\u7aef\u70b9\u7684\u7f16\u53f7\u8f83\u5c0f\u503c\u4e3a\u6743\u503c\u751f\u6210\u6700\u5927\u751f\u6210\u6811\u5bf9\u5e94\u7684\u91cd\u6784\u6811$TS$\uff0c\u518d\u5bf9\u6bcf\u6761\u8fb9\u4ee5\u7aef\u70b9\u7f16\u53f7\u8f83\u5927\u503c\u4e3a\u6743\u503c\u751f\u6210\u6700\u5c0f\u751f\u6210\u6811\u5bf9\u5e94\u7684\u91cd\u6784\u6811$TE$\n\n\u90a3\u4e48\u5728$TS$\u4e0a\u500d\u589e\u5730\u5f80\u4e0a\u8df3\uff0c\u627e\u5230\u7ed3\u70b9$x$\uff0c\u6ee1\u8db3\uff1a\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u53f6\u8282\u70b9\uff08\u4e5f\u5c31\u5bf9\u5e94\u5230\u539f\u56fe\u4e2d\u7684\u7ed3\u70b9\uff09\u7f16\u53f7\u90fd\u5927\u4e8e\u7b49\u4e8e$L$\uff0c\u5e76\u4e14$x$\u662f\u6df1\u5ea6\u5c3d\u53ef\u80fd\u5c0f\u7684\u90a3\u4e2a\u70b9\u3002\u5728$TE$\u4e0a\u4e5f\u500d\u589e\u5f80\u4e0a\u8df3\uff0c\u627e\u5230$y$\uff0c\u6ee1\u8db3\uff1a\u4ee5$y$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u53f6\u8282\u70b9\u7f16\u53f7\u90fd\u5c0f\u4e8e\u7b49\u4e8e$R$\uff0c\u5e76\u4e14$y$\u662f\u6df1\u5ea6\u5c3d\u53ef\u80fd\u5c0f\u7684\u90a3\u4e2a\u70b9\u3002\n\n\u90a3\u4e48$TS$\u4e2d\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6240\u6709\u53f6\u8282\u70b9\u5c31\u6784\u6210\u4e86\u96c6\u5408$A$\uff0c$TE$\u4e2d\u4ee5$y$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6240\u6709\u53f6\u8282\u70b9\u5c31\u6784\u6210\u4e86\u96c6\u5408$B$\uff0c\u73b0\u5728\u8981\u6c42\u5b83\u4eec\u7684\u4ea4\u96c6\u3002\u8003\u8651\u6c42\u51fa\u4e24\u68f5\u6811\u7684dfs\u5e8f\uff0c\u4e8e\u662f\u5c31\u53d8\u6210\u4e86\u4e24\u4e2a\u5e8f\u5217\uff0c\u6bcf\u6b21\u7ed9\u51fa\u4e24\u4e2a\u533a\u95f4\uff0c\u6c42\u4ea4\u96c6\u3002[\u5e26\u4fee\u6539\u7248\uff1aCF1093E](https://www.luogu.org/problemnew/show/CF1093E)\u3002\u4e0a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u5c31\u884c\u4e86\u3002\u53ef\u4ee5\u79bb\u7ebf\u6811\u72b6\u6570\u7ec4\uff0c\u4f46\u662f\u6211\u8fd9\u79cd\u61d2\u4eba\u5f53\u7136\u662f\u7528\u4e3b\u5e2d\u6811\u4e86\n\n```cpp\n#include <cctype>\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\ntemplate <typename T> inline void read(T &x) {\n    int f = 0, c = getchar(); x = 0;\n    while (!isdigit(c)) f |= c == '-', c = getchar();\n    while (isdigit(c)) x = x * 10 + c - 48, c = getchar();\n    if (f) x = -x;\n}\ntemplate <typename T, typename... Args>\ninline void read(T &x, Args &...args) {\n    read(x); read(args...);\n}\ntemplate <typename T> void write(T x) {\n    if (x < 0) x = -x, putchar('-');\n    if (x > 9) write(x / 10);\n    putchar(x % 10 + 48);\n}\ntemplate <typename T> inline void writeln(T x) { write(x); puts(\"\"); }\ntemplate <typename T> inline bool chkmin(T &x, const T &y) { return y < x ? x = y, 1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x, const T &y) { return x < y ? x = y, 1 : 0; }\n\nconst int maxn = 2e5 + 207, maxm = 4e5 + 207, inf = INT_MAX;\n\nstruct Edge {\n    int x, y;\n    Edge(int a, int b) : x(a), y(b) {}\n    Edge() : x(0), y(0) {}\n};\nEdge e[maxm];\nint n, m, q;\n\nstruct Tree {\n    int v[maxm], head[maxm], next[maxm], value[maxm], tot;\n    int dfn[maxm], st[maxm], ed[maxm], fa[30][maxm], xys;\n    void add_edge(int x, int y) {\n        v[++tot] = y;\n        next[tot] = head[x];\n        head[x] = tot;\n    }\n    void dfs(int x) {\n        if (x <= n) {\n            dfn[++xys] = x, value[x] = x;\n            st[x] = xys;\n        } else st[x] = xys + 1;\n        for (int i = 1; i <= 20; ++i)\n            fa[i][x] = fa[i - 1][fa[i - 1][x]];\n        for (int i = head[x]; i; i = next[i]) {\n            fa[0][v[i]] = x;\n            dfs(v[i]);\n        }\n        ed[x] = xys;\n    }\n    int find_s(int x, int ll) {\n        for (int i = 20; ~i; --i)\n            if (value[fa[i][x]] >= ll) x = fa[i][x];\n        return x;\n    }\n    int find_e(int x, int rr) {\n        for (int i = 20; ~i; --i)\n            if (value[fa[i][x]] <= rr) x = fa[i][x];\n        return x;\n    }\n};\nTree TS, TE;\n\ninline bool cmpmin(const Edge &a, const Edge &b) {\n    return std::min(a.x, a.y) > std::min(b.x, b.y);\n}\ninline bool cmpmax(const Edge &a, const Edge &b) {\n    return std::max(a.x, a.y) < std::max(b.x, b.y);\n}\n\nstruct Ufs {\n    int fa[maxm];\n    void init(int n) { for (int i = 1; i <= n; ++i) fa[i] = i; }\n    int findf(int x) { return fa[x] == x ? x : fa[x] = findf(fa[x]); }\n};\n\ninline void kruskal(Tree &T, int tp) {\n    if (tp == 1) std::sort(e + 1, e + m + 1, cmpmin);\n    else std::sort(e + 1, e + m + 1, cmpmax);\n    int node = n;\n    Ufs ufs;\n    ufs.init(n << 1);\n    for (int i = 1; i <= m; ++i) {\n        int x = e[i].x, y = e[i].y;\n        int w = tp == 1 ? std::min(x, y) : std::max(x, y);\n        if ((x = ufs.findf(x)) != (y = ufs.findf(y))) {\n            ufs.fa[x] = ufs.fa[y] = ++node;\n            T.value[node] = w;\n            T.add_edge(node, x);\n            T.add_edge(node, y);\n        }\n    }\n    T.dfs(node);\n}\n\nstruct Ctree_node {\n    int lc, rc, s;\n    Ctree_node() : lc(0), rc(0), s(0) {}\n};\n\nint p[maxn];\n\nstruct Chairman_tree {\n    Ctree_node T[maxn << 5];\n    int root[maxn], tot;\n    void insert(int &o, int l, int r, int pos, int val) {\n        T[++tot] = T[o]; T[o = tot].s += val;\n        if (l == r) return;\n        int mid = (l + r) >> 1;\n        if (pos <= mid) insert(T[o].lc, l, mid, pos, val);\n        else insert(T[o].rc, mid + 1, r, pos, val);\n    }\n    int query(int lt, int rt, int lb, int rb, int l, int r) {\n        if (!(lt || rt) || l > rb || r < lb) return 0;\n        if (l <= lb && r >= rb) return T[rt].s - T[lt].s;\n        int mid = (lb + rb) >> 1;\n        return query(T[lt].lc, T[rt].lc, lb, mid, l, r) + query(T[lt].rc, T[rt].rc, mid + 1, rb, l, r);\n    }\n};\nChairman_tree ct;\n\nint main() {\n    read(n, m, q);\n    for (int i = 1; i <= m; ++i) {\n        read(e[i].x, e[i].y);\n        ++e[i].x; ++e[i].y;\n    }\n    kruskal(TS, 1);\n    kruskal(TE, 2);\n    TE.value[0] = inf;\n    for (int i = 1; i <= n; ++i) p[TS.dfn[i]] = i;\n    ct.root[0] = 0;\n    for (int i = 1; i <= n; ++i) {\n        ct.root[i] = ct.root[i - 1];\n        ct.insert(ct.root[i], 1, n, p[TE.dfn[i]], 1);\n    }\n    for (int i = 1; i <= q; ++i) {\n        int s, e, ll, rr;\n        read(s, e, ll, rr);\n        ++s; ++e; ++ll; ++rr;\n        int x = TS.find_s(s, ll);\n        int y = TE.find_e(e, rr);\n        int res = ct.query(ct.root[TE.st[y] - 1], ct.root[TE.ed[y]], 1, n, TS.st[x], TS.ed[x]);\n        puts(res ? \"1\" : \"0\");\n    }\n    return 0;\n}\n```\n",
        "postTime": 1553960097,
        "uid": 72071,
        "name": "GKxx",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "[\u9898\u9762](https://www.luogu.org/problemnew/show/P4899)\n\n\u91cd\u6784\u6811\u3002\n\n\u8bbe\u8fb9\u6743\u4e3a\u8fb9\u4e24\u7aef\u70b9\u7684\u7f16\u53f7\uff08\u5927\u7684\u5c0f\u7684\u5206\u522b\u8bbe\u4e00\u68f5\uff09\uff0c\u4ee5\u6b64\u5efa\u4e24\u68f5\u91cd\u6784\u6811\u3002\u7136\u540e\u5904\u7406\u4e00\u4e0b$dfs$\u5e8f\uff0c\u53d1\u73b0\u5176\u5b9e\u6240\u6c42\u7684\u5c31\u662f\u88ab$dfs$\u5305\u542b\u7684\u8fd9\u4e2a\u4e8c\u7ef4\u77e9\u5f62\u91cc\u6709\u6ca1\u6709\u70b9\uff0c\u8fd9\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002\n\ncode:\n```\n//2018.10.3 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-15\ninline int read(){\n    res s=0;\n    bool w=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return w?-s:s;\n}\ninline void _swap(res &x,res &y){\n    x^=y^=x^=y;\n}\ninline int _abs(const res &x){\n    return x>0?x:-x;\n}\ninline int _max(const res &x,const res &y){\n    return x>y?x:y;\n}\ninline int _min(const res &x,const res &y){\n    return x<y?x:y;\n}\nconst int N=2e5+10,M=4e5+10;\nnamespace MAIN{\n    int n,m,Q;\n    vector<int> ED[N];\n#define pb push_back\n    struct Kruskal{\n        int kind;\n        struct E{\n            int next,to;\n            E() {}\n            E(res next,res to):next(next),to(to) {}\n        }edge[M<<1];\n        int head[N],cnt;\n        inline void addedge(const res &u,const res &v){\n            edge[++cnt]=E(head[u],v),head[u]=cnt;\n        }\n        int fa[N];\n        int dfn[N],low[N],idx,F[N][21];\n        void dfs(const res &x){\n            dfn[x]=++idx;\n            for(res i=1;i<=20;i++)F[x][i]=F[F[x][i-1]][i-1];\n            for(res i=head[x];~i;i=edge[i].next)dfs(edge[i].to);\n            low[x]=idx;\n        }\n        inline int jump(res x,res k){\n            for(res i=20;~i;i--)if(F[x][i]&&((kind==1&&F[x][i]<=k)||(kind==-1&&F[x][i]>=k)))x=F[x][i];\n            return x;\n        }\n        inline int find(res x){\n            while(x!=fa[x])x=fa[x]=fa[fa[x]];\n            return x;\n        }\n        inline void build(){\n            for(res i=1;i<=n;i++)fa[i]=i,head[i]=-1;\n            if(kind==1){\n                for(res u=1;u<=n;u++)\n                    for(res i=0,siz=ED[u].size();i<siz;i++)\n                        if(ED[u][i]<u){\n                            res v=find(ED[u][i]);\n                            if(u==v)continue;\n                            addedge(u,v),fa[v]=F[v][0]=u;\n                        }\n                dfs(n);\n            }\n            else {\n                for(res u=n;u>=1;u--)\n                    for(res i=0,siz=ED[u].size();i<siz;i++)\n                        if(ED[u][i]>u){\n                            res v=find(ED[u][i]);\n                            if(u==v)continue;\n                            addedge(u,v),fa[v]=F[v][0]=u;\n                        }\n                dfs(1);\n            }\n        }\n    }Max,Min;\n    namespace Segtree{\n        int ls[N<<5],rs[N<<5],sz[N<<5],tot,rt[N];\n        int update(const res &rt,const res &l,const res &r,const res &p){\n            res pos=++tot;\n            ls[pos]=ls[rt],rs[pos]=rs[rt],sz[pos]=sz[rt]+1;\n            if(l==r)return pos;\n            res mid=(l+r)>>1;\n            if(p<=mid)ls[pos]=update(ls[rt],l,mid,p);\n            else rs[pos]=update(rs[rt],mid+1,r,p);\n            return pos;\n        }\n        int query(const res &rt0,const res &rt1,const res &l,const res &r,const res &L,const res &R){\n            if(L<=l&&r<=R)return sz[rt0]-sz[rt1];\n            res mid=(l+r)>>1,ret=0;\n            if(L<=mid)ret+=query(ls[rt0],ls[rt1],l,mid,L,R);\n            if(R>mid)ret+=query(rs[rt0],rs[rt1],mid+1,r,L,R);\n            return ret;\n        }\n    }\n    int val[N];\n    inline void MAIN(){\n        n=read(),m=read(),Q=read();\n        for(res i=1;i<=m;i++){\n            res u=read()+1,v=read()+1;\n            ED[u].pb(v),ED[v].pb(u);\n        }\n        Max.kind=1,Min.kind=-1,Max.build(),Min.build();\n        for(res i=1;i<=n;i++)val[Min.dfn[i]]=Max.dfn[i];\n        for(res i=1;i<=n;i++)Segtree::rt[i]=Segtree::update(Segtree::rt[i-1],1,n,val[i]);\n        while(Q--){\n            res S=read()+1,T=read()+1,L=read()+1,R=read()+1;\n            S=Min.jump(S,L),T=Max.jump(T,R);\n            puts(Segtree::query(Segtree::rt[Min.low[S]],Segtree::rt[Min.dfn[S]-1],1,n,Max.dfn[T],Max.low[T])?\"1\":\"0\");\n        }\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n```",
        "postTime": 1538608919,
        "uid": 32878,
        "name": "foreverlasting",
        "ccfLevel": 7,
        "title": "\u3010IOI2018\u3011werewolf \u72fc\u4eba"
    },
    {
        "content": "#### AC\u7b2c\u56db\u9053\u9ed1\u9898\u796d\n\u611f\u89c9\u8fd9\u9053\u9898\u5f88\u503c\u5f97\u601d\u8003\u4e0a\u4e00\u4e24\u5929\uff0c\u5c31\u6765\u5199\u7bc7\u9898\u89e3\u5427\n\n## 1.\u9898\u610f\n\u7ed9\u4e00\u5f20$N$\u4e2a\u70b9$M$\u6761\u8fb9\u7684\u65e0\u5411\u56fe\uff0c\u6709$q$\u4e2a\u8be2\u95ee\uff0c\u6bcf\u6b21\u7ed9\u51fa$S$\uff0c$E$\uff0c$L$\uff0c$R$\uff0c\u95ee\u80fd\u5426\u4ece$S$\u8d70\u5230$E$\uff0c\u4e14\u5206\u4e09\u4e2a\u9636\u6bb5\uff08**\u5fc5\u987b\u6309\u987a\u5e8f\u6765**\uff09\uff1a\n\n1.\u53ea\u5728$L$~$N$\u4e0a\u7684\u70b9\u4e0a\u8d70\uff1b\n\n2.\u53ea\u5728$L$~$R$\u4e0a\u7684\u70b9\u4e0a\u8d70\uff1b\n\n3.\u53ea\u5728$1$~$R$\u4e0a\u7684\u70b9\u4e0a\u8d70\u3002\n\n## 2.\u60f3\u6cd5\n\u8bbe\u4ece$S$\u51fa\u53d1\uff0c\u53ea\u7ecf\u8fc7\u7f16\u53f7$L$~$N$\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\u96c6\u4e3a$A$\uff1b\n\n\u4ece$E$\u51fa\u53d1\uff0c\u53ea\u7ecf\u8fc7\u7f16\u53f7$1$~$R$\u80fd\u591f\u5230\u8fbe\u7684\u6240\u6709\u70b9\u96c6\u4e3a$B$\u3002\n\n\u90a3\u4e48\u95ee\u9898\u5c31\u8f6c\u5316\u4e3a\u5224\u5b9a$A$\u4e0e$B$\u7684\u4ea4\u96c6\u662f\u5426\u4e3a\u7a7a\u3002\n\n## 3.\u9898\u89e3\n\u8003\u8651\u5efa\u4e24\u68f5$kruskal$\u91cd\u6784\u6811\u3002\n\n\u7b2c\u4e00\u68f5\u6309\u7167\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u8f83\u5c0f\u503c\u4e3a\u8fb9\u6743\u6784\u9020\u4e00\u68f5\u6700\u5927\u91cd\u6784\u6811\uff1b\n\n\u7b2c\u4e8c\u68f5\u5219\u6309\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u8f83\u5927\u503c\u4e3a\u8fb9\u6743\u6784\u9020\u4e00\u68f5\u6700\u5c0f\u91cd\u6784\u6811\u3002\n\n\u90a3\u4e48\u641e\u51fa\u4e24\u68f5\u6811\u7684$DFS$\u5e8f\uff0c\u90a3\u4e48$A$\uff0c$B$\u96c6\u5408\u5c31\u8f6c\u6362\u4e3a\u4e86\u4e24\u4e2a\u533a\u95f4\u3002\n\n\u5982\u679c\u628a\u7b2c\u4e00\u68f5\u6811\u4e0a\u7684$DFS$\u5e8f\u770b\u505a\u6a2a\u5750\u6807\uff0c\u7b2c\u4e8c\u68f5\u6811\u4e0a\u7684$DFS$\u5e8f\u770b\u505a\u7eb5\u5750\u6807\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4e00\u7ec4\u8be2\u95ee\uff0c\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u8be2\u95ee\u4e00\u4e2a\u77e9\u5f62\u533a\u57df\u5185\u90e8\u70b9\u7684\u6570\u91cf\u3002\n\n\u7136\u540e\u6811\u72b6\u6570\u7ec4\u79bb\u7ebf\u5904\u7406\u4e00\u4e0b\u5c31\u884c\u4e86\uff08~~\u548c\u8fd9\u4f4d[\u5927\u4f6c](https://www.luogu.com.cn/user/88804)\u4e00\u6837\uff0c\u5565\u65f6\u5019\u4e3b\u5e2d\u6811\u4f1a\u4e86\u518d\u8bf4\u5728\u7ebf\u89e3\u6cd5\u5427~~\uff09\n\n\u9644\u4e0a\u6211\u8fd9\u4e11\u964b\u7684\u4ee3\u7801\uff08\u76ee\u524d\u5c45\u7136\u662f\u6700\u4f18\u89e3$1st$~~\uff0c\u9b3c\u6653\u5f97\u4e3a\u4ec0\u4e48~~\uff09\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+10,M=8e5+10,Q=1e6+10;\nint n,m,q,x,y,s,e,l,r,tal;\nint fst[N],nxt[M],to[M],tot;\nint aray[N],ans[N];\nstruct ljzz\n{\n\tint x,y,val,id;\n\tbool operator < (const ljzz& b) const\n\t{return x<b.x||(x==b.x&&id<b.id);}\n}a[Q];\ninline ll read()\n{\n\tll s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n\treturn s*w;\n}\ninline void add(int u,int v)\n{\n\tnxt[++tot]=fst[u];\n\tto[tot]=v;fst[u]=tot;\n}\nstruct mdzz\n{\n\tbool mark;\n\tint fa[N],k;\n\tint dfn[N],low[N],tim,cir[N][24];\n\tint fst1[N],nxt1[N],to1[N],cnt;\n\tinline void add1(int u,int v)\n\t{\n\t\tnxt1[++cnt]=fst1[u];\n\t\tto1[cnt]=v;fst1[u]=cnt;\n\t}\n\tint find(int x)\n\t{\n\t\tif(fa[x]==x)return fa[x];\n\t\treturn fa[x]=find(fa[x]);\n\t}\n\tvoid kruskal()\n\t{\n\t\tfor(int i=1;i<=n;++i)fa[i]=i;\n\t\tif(mark)\n\t\t{\n\t\t\tfor(int u=n;u>=1;--u)\n\t\t\tfor(int i=fst[u];i;i=nxt[i])\n\t\t\t{\n\t\t\t\tint v=to[i];\n\t\t\t\tif(u<v)\n\t\t\t\t{\n\t\t\t\t\tint uu=find(u),vv=find(v);\n\t\t\t\t\tif(uu==vv)continue;\n\t\t\t\t\t++k;fa[vv]=uu,add1(uu,vv);\n\t\t\t\t\tif(k==n-1)return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int u=1;u<=n;++u)\n\t\t\tfor(int i=fst[u];i;i=nxt[i])\n\t\t\t{\n\t\t\t\tint v=to[i];\n\t\t\t\tif(u>v)\n\t\t\t\t{\n\t\t\t\t\tint uu=find(u),vv=find(v);\n\t\t\t\t\tif(uu==vv)continue;\n\t\t\t\t\t++k;fa[vv]=uu,add1(uu,vv);\n\t\t\t\t\tif(k==n-1)return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs(int u,int fth)\n\t{\n\t\tdfn[u]=++tim;\n\t\tcir[u][0]=fth;\n\t\tfor(int i=1;i<21;++i)\n\t\tcir[u][i]=cir[cir[u][i-1]][i-1];\n\t\tfor(int i=fst1[u];i;i=nxt1[i])\n\t\t{\n\t\t\tint v=to1[i];\n\t\t\tif(v==fth)continue;\n\t\t\tdfs(v,u);\n\t\t}\n\t\tlow[u]=tim;\n\t}\n\tinline int query(int u,int val)\n\t{\n\t\tif(mark)\n\t\t{\n\t\t\tfor(int i=20;~i;--i)\n\t\t\tif(cir[u][i]&&cir[u][i]>=val)\n\t\t\tu=cir[u][i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=20;~i;--i)\n\t\t\tif(cir[u][i]&&cir[u][i]<=val)\n\t\t\tu=cir[u][i];\n\t\t}\n\t\treturn u;\n\t}\n}pos,rev;\ninline int lowbit(int k)\n{return k&(-k);}\ninline void off_add(int k)\n{for(;k<=n;k+=lowbit(k))aray[k]++;}\ninline int off_sum(int k)\n{\n\tint tmp=0;\n\tfor(;k;k-=lowbit(k))tmp+=aray[k];\n\treturn tmp;\n}\nint main()\n{\n\tn=read(),m=read(),q=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tx=read(),y=read();\n\t\tx++,y++;\n\t\tadd(x,y),add(y,x);\n\t}\n\tpos.mark=1,rev.mark=0;\n\tpos.kruskal();\n\trev.kruskal();\n\tpos.dfs(1,0),rev.dfs(n,0);\n\tfor(int i=1;i<=n;++i)\n\ta[++tal]=(ljzz){pos.dfn[i],rev.dfn[i],0,0};\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\ts=read(),e=read(),l=read(),r=read();\n\t\ts++,e++,l++,r++;\n\t\ts=pos.query(s,l);\n\t\te=rev.query(e,r);\n\t\tint x1=pos.dfn[s]-1,x2=pos.low[s];\n\t\tint y1=rev.dfn[e]-1,y2=rev.low[e];\n\t\ta[++tal]=(ljzz){x1,y1,1,i};\n\t\ta[++tal]=(ljzz){x2,y2,1,i};\n\t\ta[++tal]=(ljzz){x1,y2,-1,i};\n\t\ta[++tal]=(ljzz){x2,y1,-1,i};\n\t}\n\tsort(a+1,a+1+tal);\n\tfor(int i=1;i<=tal;++i)\n\t{\n\t\tif(a[i].id)\n\t\t{\n\t\t\tint tmp=off_sum(a[i].y)*a[i].val;\n\t\t\tans[a[i].id]+=tmp;\n\t\t}\n\t\telse off_add(a[i].y);\n\t}\n\tfor(int i=1;i<=q;++i)\n\tprintf(\"%d\\n\",ans[i]?1:0);\n\treturn 0;\n}\n```\n\u5b9e\u9645\u4e0a\u6253\u5f00\u6765\u770b\u6bcf\u4e2a\u90e8\u5206\u4e5f\u4e0d\u96be\u5199\uff0c\u4f46\u662f\u9898\u76ee\u672c\u8eab\u662f\u5f88\u5177\u601d\u8003\u4ef7\u503c\u7684\uff08\u4e0d\u7136\u600e\u4e48\u662f$IOI$\u7684\u9898\u5462\uff09\n\n\u53ea\u6c42\u80fd\u5e2e\u52a9\u5230\u51e0\u4e2a\u4eba\u7f62\u3002\u3002",
        "postTime": 1610533889,
        "uid": 206024,
        "name": "Illusory_dimes",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    },
    {
        "content": "## [my blog](https://www.cnblogs.com/suxxsfe/p/12822957.html)  \n\n--------  \n\n\n[P4899 [IOI2018] werewolf \u72fc\u4eba](https://www.luogu.com.cn/problem/P4899)  \n[LOJ#2865.\u300cIOI2018\u300d\u72fc\u4eba](https://loj.ac/problem/2865)\uff0c\u7b2c\u4e00\u6b21AC\u4ea4\u4e92\u9898  \n\nkruskal \u91cd\u6784\u6811+\u4e3b\u5e2d\u6811  \n\u5176\u5b9e\u77e5\u9053\u91cd\u6784\u6811\u7684\u7b97\u6cd5\u7684\u8bdd\uff0c\u96be\u5ea6\u5c31\u4e3b\u8981\u5728\u4e3b\u5e2d\u6811\u4e0a  \n\n![](https://pic.downk.cc/item/5eae8795c2a9a83be597c1f1.png)  \n\n-----------------  \n\n\u4e60\u60ef\u4ece $1$ \u5f00\u59cb\u6807\u53f7\uff0c\u6240\u4ee5\u4ee5\u4e0b\u8bb2\u89e3\u4e2d\u7684\u6807\u53f7\u90fd\u662f\u4ece $1$ \u5f00\u59cb\u7684  \n\u4ece $s$ \u5f00\u59cb\u8d70\uff0c\u53ea\u8d70\u70b9 $L,L+1,\\cdots,n$\uff0c\u80fd\u8d70\u5230\u7684\u70b9\u96c6\u8bb0\u4e3a $V_1$  \n\u4ece $e$ \u5f00\u59cb\uff0c\u53ea\u8d70 $1,2,\\cdots,R$\uff0c\u80fd\u8d70\u5230\u7684\u70b9\u96c6\u8bb0\u4e3a $V_2$  \n\u5219\uff0c\u82e5 $V_1\\cap V_2 \\neq \\varnothing$\uff0c\u5c31\u8bf4\u660e\u6709\u89e3\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u4ea4\u96c6\u5185\u7684\u4efb\u610f\u4e00\u4e2a\u70b9\u53d8\u6362\u4eba\u72fc\u5f62\u5f0f  \n\n\u7b2c\u4e00\u6b65\uff0c\u6c42 $V_1,V_2$  \n\u8003\u8651 kruskal \u91cd\u6784\u6811\uff0c\u5148\u53bb[\u8fd9\u91cc](https://www.cnblogs.com/suxxsfe/p/12802162.html)\u770b\u66f4\u8be6\u7ec6\u7684\u8bb2\u89e3 ~~\u4e0d\u77e5\u9053\u8be6\u7ec6\u4e0d\u8be6\u7ec6~~\uff0c\u5728\u8fd9\u91cc\u4e0d\u4f1a\u91cd\u5934\u5f00\u59cb\u8bb2\u91cd\u6784\u6811\u5185\u5bb9  \n\u5efa\u7acb\u4e24\u4e2a\u91cd\u6784\u6811  \n\n- $A$ \u4e3a\u4ee5 $\\max(u,v)$ \u4e3a\u6743\u503c\uff0c\u7528 **\u6700\u5c0f** \u751f\u6210\u6811\u91cd\u6784\uff0c\u53ef\u4ee5\u77e5\u9053\uff0c$u,v$ \u4e24\u70b9\u8def\u5f84\u4e2d\uff0c\u7ecf\u8fc7\u7684\u70b9\u7684\u6700\u5927\u7f16\u53f7\u7684\u6700\u5c0f\u503c\uff0c\u5c31\u662f\u5f97\u51fa\u7684\u91cd\u6784\u6811\u4e2d $lca(u,v)$ \u7684\u70b9\u6743  \n- $B$ \u4e3a\u4ee5 $\\min(u,v)$ \u4e3a\u6743\u503c\uff0c\u7528 **\u6700\u5927** \u751f\u6210\u6811\u91cd\u6784\uff0c\u53ef\u4ee5\u77e5\u9053\uff0c$u,v$ \u4e24\u70b9\u8def\u5f84\u4e2d\uff0c\u7ecf\u8fc7\u7684\u70b9\u7684\u6700\u5c0f\u7f16\u53f7\u7684\u6700\u5927\u503c\uff0c\u5c31\u662f\u5f97\u51fa\u7684\u91cd\u6784\u6811\u4e2d $lca(u,v)$ \u7684\u70b9\u6743  \n\n\u6240\u4ee5\uff0c\u7531\u4e8e kruskal \u91cd\u6784\u6811\u7684\u4e00\u822c\u6027\u8d28\uff0c\u4e5f\u53ef\u4ee5\u77e5\u9053\uff0c\u4ee5 $A$ \u6811\u4e3a\u4f8b\uff0c\u4e0e\u4e00\u4e2a\u70b9 $u$ \u4e4b\u95f4\u7684\u8def\u5f84\uff0c\u7ecf\u8fc7\u7684\u70b9\u7684\u6700\u5927\u7f16\u53f7\u7684\u6700\u5c0f\u503c\u5c0f\u4e8e\u7b49\u4e8e $x$ \u7684\u8282\u70b9\uff0c\u5c31\u662f\u4ee5 \u4ece $u$ \u5230\u6839\u7684\u8def\u5f84\u4e2d\uff0c\u6df1\u5ea6\u6700\u5c0f\u7684\uff0c\u6743\u503c\u5c0f\u4e8e\u7b49\u4e8e $x$ \u7684\u90a3\u4e2a\u70b9 \u4e3a\u6839\uff0c\u7684\u5b50\u6811\u4e2d\u7684\u6240\u6709\u53f6\u5b50\u8282\u70b9  \n~~\u597d\u7ed5\uff0c\u53ef\u4ee5\u7528\u6765\u7ec3\u4e60\u53e5\u5b50\u6210\u5206\u7684\u786e\u5b9a~~  \n\u7136\u540e $x=R$ \u65f6\uff0c\u8fd9\u6837\u5f97\u5230\u7684\u70b9\u96c6\uff0c\u5c31\u662f $V_2$  \n\u540c\u7406\uff0c\u53ef\u4ee5\u7528 $B$ \u6811\uff0c\u4ee5\u76f8\u4f3c\u7684\u65b9\u6cd5\u6c42\u51fa $V_1$  \n\n\u7b2c\u4e8c\u6b65\uff0c\u6c42 $V_1,V_2$ \u662f\u5426\u4ea4\u96c6\u4e0d\u4e3a\u7a7a  \n\u7528\u4e3b\u5e2d\u6811\uff0c\u5176\u5b9e\u53ef\u4ee5\u79bb\u7ebf\u7528\u6811\u72b6\u6570\u7ec4\uff0c\u4f46\u662f\u5e76\u6ca1\u6709\u770b\u61c2\u662f\u600e\u4e48\u505a  \n\n\u4e3b\u5e2d\u6811\u5176\u5b9e\u53ef\u4ee5\u7406\u89e3\u4e3a\u7ebf\u6bb5\u6811\u7684\u524d\u7f00\u548c\uff0c\u6211\u4eec\u628a\u8fd9\u4e9b\u70b9\uff08$2n-1$ \u4e2a\uff09\uff0c\u6309\u7167\u5728 $A$ \u6811\u4e2d\u7684 dfs \u5e8f\u6765\u6392\u5e8f\uff0c\u5e76\u4ee5\u8fd9\u4e9b\u70b9\u5728 $B$ \u6811\u4e0a\u7684 dfs \u5e8f\u5efa\u4e3b\u5e2d\u6811  \n\u7136\u540e\u6211\u4eec\u8bbe\u901a\u8fc7\u91cd\u6784\u6811\u627e\u5230\u7684\u4e24\u4e2a\u70b9\uff08\u5b50\u6811\u7684\u6839\uff09\u5206\u522b\u662f $a,b$\uff0c\u90a3\u4e48\u53c8\u56e0\u4e3a\u5728\u4e00\u4e2a\u5b50\u6811\u5185\uff0cdfs \u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u6bcf\u6b21\u67e5\u8be2 $dfn_b\\cdots dfn_b+size_b-1$ \u4e2d\uff0c\u6709\u6ca1\u6709\u6570\u5728 $dfn_a\\cdots dfn_a+size_a-1$ \u4e2d  \n\u5176\u5b9e\u4e5f\u4e0d\u96be  \n\n```cpp  \n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<iomanip>\n#include<cstring>\n#define reg register\n#define EN std::puts(\"\")\n#define LL long long\ninline int read(){\n\tregister int x=0;register int y=1;\n\tregister char c=std::getchar();\n\twhile(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}\n\treturn y?x:-x;\n}\n#define N 400006\n#define M 400006\nint n,m;\nstruct edge{\n\tint u,v;\n}e[M];\ninline int get_max(int x,int y){return x>y?x:y;}\ninline int get_min(int x,int y){return x<y?x:y;}\nstruct TREE{\n\tint up[N*2],vertex;\n\tint son[2][N];\n\tint fa[19][N],size[N],dfn[N],dfscnt;\n\tint val[N];\n\tinline int find(int k){\n\t\treturn k==up[k]?k:up[k]=find(up[k]);\n\t}\n\tstatic inline int cmp_A(edge aa,edge aaa){return get_max(aa.u,aa.v)<get_max(aaa.u,aaa.v);}\n\tstatic inline int cmp_B(edge aa,edge aaa){return get_min(aa.u,aa.v)>get_min(aaa.u,aaa.v);}\n\tinline void build_A(){\n\t\tstd::sort(e+1,e+1+m,cmp_A);\n\t\tvertex=n;\n\t\tfor(reg int i=1;i<=2*n;i++) up[i]=i;\n\t\tfor(reg int u,v,i=1,cnt=1;cnt<n;i++){\n\t\t\tu=find(e[i].u);v=find(e[i].v);\n\t\t\tif(u==v) continue;\n\t\t\tval[++vertex]=get_max(e[i].u,e[i].v);\n\t\t\tson[0][vertex]=u;son[1][vertex]=v;\n\t\t\tcnt++;up[u]=up[v]=vertex;\n\t\t}\n\t}\n\tinline void build_B(){\n\t\tstd::sort(e+1,e+1+m,cmp_B);\n\t\tvertex=n;\n\t\tfor(reg int i=1;i<=2*n;i++) up[i]=i;\n\t\tfor(reg int u,v,i=1,cnt=1;cnt<n;i++){\n\t\t\tu=find(e[i].u);v=find(e[i].v);\n\t\t\tif(u==v) continue;\n\t\t\tval[++vertex]=get_min(e[i].u,e[i].v);\n\t\t\tson[0][vertex]=u;son[1][vertex]=v;\n\t\t\tcnt++;up[u]=up[v]=vertex;\n\t\t}\n\t}\n\tvoid dfs(int u,int father){\n\t\tfa[0][u]=father;size[u]=1;dfn[u]=++dfscnt;\n\t\tfor(reg int i=1;i<19;i++) fa[i][u]=fa[i-1][fa[i-1][u]];\n\t\tif(!son[0][u]) return;\n\t\tdfs(son[0][u],u);dfs(son[1][u],u);\n\t\tsize[u]+=size[son[0][u]]+size[son[1][u]];\n\t}\n\tinline int get_A(int u,int x){\n\t\tfor(reg int i=18;~i;i--)if(val[fa[i][u]]<=x) u=fa[i][u];\n\t\treturn u;\n\t}\n\tinline int get_B(int u,int x){\n\t\tfor(reg int i=18;~i;i--)if(val[fa[i][u]]>=x) u=fa[i][u];\n\t\treturn u;\n\t}\n}A,B;\n//\u4e3b\u5e2d\u6811\u90e8\u5206 \nstruct tr{\n\ttr *ls,*rs;\n\tint x;\n}dizhi[10000006],*root[N];\nint tot;\ninline int cmp(int x,int y){return A.dfn[x]<A.dfn[y];}\nvoid build(tr *tree,int l,int r){\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\ttree->ls=&dizhi[tot++];tree->rs=&dizhi[tot++];\n\tbuild(tree->ls,l,mid);build(tree->rs,mid+1,r);\n}\nvoid insert(tr *last,tr *tree,int l,int r,int num,int k){\n\tif(l==r) return tree->x=last->x+k,void();\n\tint mid=(l+r)>>1;\n\t*tree=*last;\n\tif(num<=mid){\n\t\ttree->ls=&dizhi[tot++];\n\t\tinsert(last->ls,tree->ls,l,mid,num,k);\n\t}\n\telse{\n\t\ttree->rs=&dizhi[tot++];\n\t\tinsert(last->rs,tree->rs,mid+1,r,num,k);\n\t}\n\ttree->x=tree->ls->x+tree->rs->x;\n}\nint find(tr *left,tr *right,int l,int r,int ql,int qr){\n\tif(ql<=l&&r<=qr) return right->x-left->x;\n\tint mid=(l+r)>>1;\n\tif(ql<=mid){\n\t\tif(find(left->ls,right->ls,l,mid,ql,qr)) return 1;\n\t}\n\tif(qr>mid){\n\t\tif(find(left->rs,right->rs,mid+1,r,ql,qr)) return 1;\n\t}\n\treturn 0;\n}\nint main(){\n\tn=read();m=read();int q=read();\n\tfor(reg int i=1;i<=m;i++){\n\t\te[i].u=read()+1;e[i].v=read()+1;\n\t}\n\tA.build_A();B.build_B();\n\tA.dfs(2*n-1,2*n-1);B.dfs(2*n-1,2*n-1);\n\tint tmp[n*2];\n\tfor(reg int i=1;i<n*2;i++) tmp[i]=i;\n\tstd::sort(tmp+1,tmp+n*2,cmp);\n\tfor(reg int i=0;i<2*n;i++) root[i]=&dizhi[tot++];\n\tbuild(root[0],1,2*n-1);\n\tfor(reg int i=1;i<2*n;i++) insert(root[i-1],root[i],1,2*n-1,B.dfn[tmp[i]],tmp[i]<=n);\n\treg int s,t,L,R;\n\twhile(q--){\n\t\ts=read()+1;t=read()+1;L=read()+1;R=read()+1;\n\t\t//\u4ece s \u5f00\u59cb\uff0c\u80fd\u8d70 L \u5230 n\uff0c\u6700\u5c0f\u503c\u4e0d\u5c0f\u4e8e L\uff0c\u7528 B \u6811\n\t\t//\u4ece t \u5f00\u59cb\uff0c\u80fd\u8d70 1 \u5230 R\uff0c\u6700\u5927\u503c\u4e0d\u5927\u4e8e R\uff0c\u7528 A \u6811\n\t\t//\u627e\u4ea4\u96c6\n\t\tint tmpa=A.get_A(t,R),tmpb=B.get_B(s,L);\n\t\tstd::puts(find(root[A.dfn[tmpa]-1],root[A.dfn[tmpa]+A.size[tmpa]-1],1,2*n-1,B.dfn[tmpb],B.dfn[tmpb]+B.size[tmpb]-1)?\"1\":\"0\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1588503228,
        "uid": 164432,
        "name": "suxxsfe",
        "ccfLevel": 9,
        "title": "[LOJ2865] P4899 [IOI2018] werewolf \u72fc\u4eba"
    },
    {
        "content": "\u5148\u662f\u8d77\u70b9\uff1a[l,n];\u5373\u4eces\u51fa\u53d1\u53ea\u8d70[l,n]\u53ef\u4ee5\u5230\u8fbe\u7684\u70b9\u3002\n \n\u540e\u53d8\u72fc\uff0c\u5219\u4fee\u6539\u4e3a\uff1a[0,r];\uff08\u9006\u5411\u601d\u8003\uff09\u5373\u4ece\u7ec8\u70b9\u53ea\u8d70[0,r]\u53ef\u4ee5\u5230\u8fbe\u7684\u70b9\u3002\n\n**\u4ece\u8d77\u70b9\u53ef\u4ee5\u8d70\u5230\u7684\u70b9\u4e2d\u4ece\u7ec8\u70b9\u4e5f\u53ef\u4ee5\u8d70\u5230\u5c31\u6709\u89e3\uff01**\n\nSolution\uff1a\u514b\u9c81\u65af\u5361\u5c14\u91cd\u6784\u7136\u540e\u6c42dfs\u5e8f\u533a\u95f4\u8986\u76d6\u7684\u76f8\u540c\u70b9\u3002\n\n1.\u5bf9\u4e8es\uff0c\u5efa\u6700\u5927\u751f\u6210\u6811\uff1b\u5bf9\u4e8et\uff0c\u5efa\u6700\u5c0f\u751f\u6210\u6811\u3002\n\n\uff08Tips1\uff1a\u7ef4\u62a4\u6839\u8282\u70b9\u4e0e\u5b50\u8282\u70b9\u5927\u5c0f\u5355\u8c03\u6027\u65f6\u53ef\u501f\u52a9\u5e76\u67e5\u96c6\uff09\n\n\uff08Tips2\uff1a\u201c\u8fb9\u6743\u201d\u7406\u89e3\u4e3a\u4e24\u8282\u70b9\u4e2d\u5927\u7684\u90a3\u4e2a\u3002\uff09\n\n2.\u500d\u589e\u6cd5DFS\u5e8f\n\n3.DFS1\u4e3ax\uff0cDFS2\u4e3ay\uff0c\u6784\u6210\uff08x\uff0cy\uff09\n\n4.\u6570\u70b9\n\n\u3010~~\u795e\u6e05\u6c14\u723d~~\u3011\n\n\u501f\u7528\u4e4b\u524d\u67d0\u795e\u7287\u7684\u786c\u6838\u4f18\u5316\n```cpp\n%:pragma GCC optimize(3)\n%:pragma GCC optimize(\"Ofast\")\n%:pragma GCC optimize(\"inline\")\n%:pragma GCC optimize(\"-fgcse\")\n%:pragma GCC optimize(\"-fgcse-lm\")\n%:pragma GCC optimize(\"-fipa-sra\")\n%:pragma GCC optimize(\"-ftree-pre\")\n%:pragma GCC optimize(\"-ftree-vrp\")\n%:pragma GCC optimize(\"-fpeephole2\")\n%:pragma GCC optimize(\"-ffast-math\")\n%:pragma GCC optimize(\"-fsched-spec\")\n%:pragma GCC optimize(\"unroll-loops\")\n%:pragma GCC optimize(\"-falign-jumps\")\n%:pragma GCC optimize(\"-falign-loops\")\n%:pragma GCC optimize(\"-falign-labels\")\n%:pragma GCC optimize(\"-fdevirtualize\")\n%:pragma GCC optimize(\"-fcaller-saves\")\n%:pragma GCC optimize(\"-fcrossjumping\")\n%:pragma GCC optimize(\"-fthread-jumps\")\n%:pragma GCC optimize(\"-funroll-loops\")\n%:pragma GCC optimize(\"-fwhole-program\")\n%:pragma GCC optimize(\"-freorder-blocks\")\n%:pragma GCC optimize(\"-fschedule-insns\")\n%:pragma GCC optimize(\"inline-functions\")\n%:pragma GCC optimize(\"-ftree-tail-merge\")\n%:pragma GCC optimize(\"-fschedule-insns2\")\n%:pragma GCC optimize(\"-fstrict-aliasing\")\n%:pragma GCC optimize(\"-fstrict-overflow\")\n%:pragma GCC optimize(\"-falign-functions\")\n%:pragma GCC optimize(\"-fcse-skip-blocks\")\n%:pragma GCC optimize(\"-fcse-follow-jumps\")\n%:pragma GCC optimize(\"-fsched-interblock\")\n%:pragma GCC optimize(\"-fpartial-inlining\")\n%:pragma GCC optimize(\"no-stack-protector\")\n%:pragma GCC optimize(\"-freorder-functions\")\n%:pragma GCC optimize(\"-findirect-inlining\")\n%:pragma GCC optimize(\"-fhoist-adjacent-loads\")\n%:pragma GCC optimize(\"-frerun-cse-after-loop\")\n%:pragma GCC optimize(\"inline-small-functions\")\n%:pragma GCC optimize(\"-finline-small-functions\")\n%:pragma GCC optimize(\"-ftree-switch-conversion\")\n%:pragma GCC optimize(\"-foptimize-sibling-calls\")\n%:pragma GCC optimize(\"-fexpensive-optimizations\")\n%:pragma GCC optimize(\"-funsafe-loop-optimizations\")\n%:pragma GCC optimize(\"inline-functions-called-once\")\n%:pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define max_1 400001\n#define max_2 6000001\n#define logg 21\nint n,m,Q,ans;\nvoid read(int &x) {\n\tint f=1;\n\tx=0;\n\tchar s=getchar();\n\twhile(s<'0'||s>'9') {\n\t\tif(s=='-')f=-1;\n\t\ts=getchar();\n\t}\n\twhile(s>='0'&&s<='9') {\n\t\tx=x*10+s-48;\n\t\ts=getchar();\n\t}\n\tx=x*f;\n}\nvoid output(int x) {\n\tif(x<0) {\n\t\tx=-x;\n\t\tputchar('-');\n\t}\n\tif(x>9) {\n\t\toutput(x/10);\n\t}\n\tputchar(x%10+'0');\n}\nbool vis1[max_1],vis2[max_1];\nstruct node {\n\tint u,v;\n\tint x,y;\n} a[max_1];\nint cnt,cntt,tot,tott;\nint s1[max_1],s2[max_1],t1[max_1],t2[max_1];\nvoid Sky(int &a,int &b,int &c,int &d) {\n\ta++,b++,c++,d++;\n}\nint fa[max_1],dad[max_1];\nint ls1[max_1],rs1[max_1],ls2[max_1],rs2[max_1];\nint ls[max_2],rs[max_2];\nint getfather(int x) {\n\tif(fa[x]==x) return x;\n\treturn fa[x]=getfather(fa[x]);\n}\nint getdad(int x) {\n\tif(dad[x]==x) return x;\n\treturn dad[x]=getdad(dad[x]);\n}\nint s,t,l,r;\nbool cmp(node a,node b) {\n\treturn a.x>b.x;\n}\nbool cmpp(node a,node b) {\n\treturn a.y<b.y;\n}\nint Cnt;\nvoid build(int &cn_t,int l,int r) {\n\tcn_t=++Cnt;\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(ls[cn_t],l,mid);\n\tbuild(rs[cn_t],mid+1,r);\n}\nint ToT[max_2];\nvoid update(int &cn_t,int pre,int l,int r,int k) {\n\tcn_t=++Cnt;\n\tToT[cn_t]=ToT[pre]+1;\n\tif(l==r) return;\n\tls[cn_t]=ls[pre];\n\trs[cn_t]=rs[pre];\n\tint mid=(l+r)>>1;\n\t(k>mid)?update(rs[cn_t],rs[pre],mid+1,r,k):update(ls[cn_t],ls[pre],l,mid,k);\n}\nint query(int x,int y,int l,int r,int L,int R) {\n\tif(L<=l&&r<=R) return ToT[y]-ToT[x];\n\tint mid=(l+r)>>1,temp=0;\n\tif(L<=mid) temp+=query(ls[x],ls[y],l,mid,L,R);\n\tif(R>mid) temp+=query(rs[x],rs[y],mid+1,r,L,R);\n\treturn temp;\n}\nint q1[max_1],q2[max_1],v1[max_1],v2[max_1];\nint grandf[max_1];\nint f1[max_1][logg],f2[max_1][logg];\nvoid dfs1(int x) {\n\tvis1[x]=1;\n\ts1[x]=tot;\n\tif(x<=n) q1[++tot]=x;\n\tfor(int i=1; i<=17; i++) f1[x][i]=f1[f1[x][i-1]][i-1];\n\tif(ls1[x]) dfs1(ls1[x]);\n\tif(rs1[x]) dfs1(rs1[x]);\n\tt1[x]=tot;\n}\nvoid dfs2(int x) {\n\tvis2[x]=1;\n\ts2[x]=tott;\n\tif(x<=n) q2[++tott]=x;\n\tfor(int i=1; i<=17; i++) f2[x][i]=f2[f2[x][i-1]][i-1];\n\tif(ls2[x]) dfs2(ls2[x]);\n\tif(rs2[x]) dfs2(rs2[x]);\n\tt2[x]=tott;\n}\n//DFS\u5e8f \nint merge1(int aa,int bb){\n\tint cc=getfather(aa),dd=getfather(bb);\n\tfa[dd]=cc;\n}\nint merge2(int aa,int bb){\n\tint cc=getfather(aa),dd=getfather(bb);\n\tfa[dd]=cc;\n}\nint sear(int x,int dd) {\n\tfor(int i=17; i>=0; i--) {\n\t\tif(v1[f1[x][i]]>=dd&&f1[x][i]) x=f1[x][i];\n\t}\n\treturn x;\n}\nint tlook(int x,int dd) {\n\tfor(int i=17; i>=0; i--) {\n\t\tif(v2[f2[x][i]]<=dd&&f2[x][i]) x=f2[x][i];\n\t}\n\treturn x;\n}\nint main() {\n//\tfreopen(\"lll.in\",\"r\",stdin);\n//\tfreopen(\"lll.out\",\"w\",stdout);\n\tread(n);\n\tread(m);\n\tread(Q);\n\tint nn=n+n;\n\tfor(int i=1; i<=m; i++) {\n\t\tread(a[i].u),read(a[i].v);\n\t\ta[i].u++,a[i].v++;\n\t\ta[i].x=min(a[i].u,a[i].v),a[i].y=max(a[i].u,a[i].v);\n\t}\n\tfor(int i=1; i<nn; i++) {\n\t\tfa[i]=i,dad[i]=i;\n\t}\n\tcnt=cntt=n;\n\tsort(a+1,a+1+m,cmp);\n\tfor(int i=1; i<=m; i++) {\n\t\tint fx=getfather(a[i].u),fy=getfather(a[i].v);\n\t\tif(fx!=fy) {\n\t\t\tv1[++cnt]=a[i].x;\n\t\t\tls1[cnt]=fx,rs1[cnt]=fy;\n\t\t\tf1[fx][0]=cnt,f1[fy][0]=cnt;\n\t\t\tfa[fx]=cnt,fa[fy]=cnt;\n\t\t\tif(cnt==nn-1) break;\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) {\n\t\tif(vis1[i]==false) dfs1(getfather(i));\n\t}\n\tsort(a+1,a+1+m,cmpp);\n\tfor(int i=1; i<=m; i++) {\n\t\tint fx=getdad(a[i].u),fy=getdad(a[i].v);\n\t\tif(fx!=fy) {\n\t\t\tv2[++cntt]=a[i].y;\n\t\t\tls2[cntt]=fx,rs2[cntt]=fy;\n\t\t\tf2[fx][0]=cntt,f2[fy][0]=cntt;\n\t\t\tdad[fx]=cntt,dad[fy]=cntt;\n\t\t\tif(cntt==nn-1) break;\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) {\n\t\tif(vis2[i]==false) dfs2(getdad(i));\n\t}\n\tbuild(grandf[0],1,n);\n\tfor(int i=1; i<=n; i++) {\n\t\tupdate(grandf[i],grandf[i-1],1,n,s2[q1[i]]+1);\n\t}\n\tfor(int i=1;i<=Q;i++){\n\t\tread(s),read(t),read(l),read(r);\n\t\tSky(s,t,l,r);\n\t\ts=sear(s,l),t=tlook(t,r);\n\t\tans=query(grandf[s1[s]],grandf[t1[s]],1,n,s2[t]+1,t2[t]);\n\t\tbool p=((!ans)?0:1);\n\t\toutput(p);\n\t\tprintf(\"\\n\");\n\t}\n}\n```",
        "postTime": 1542379203,
        "uid": 74080,
        "name": "Andy_SkyWalker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4899 \u3010[IOI2018] werewolf \u72fc\u4eba\u3011"
    }
]