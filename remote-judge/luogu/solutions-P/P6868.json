[
    {
        "content": "[P6868 [COCI2019-2020#5] Matching](https://www.luogu.com.cn/problem/P6868)\n\n## \u9898\u76ee\u63cf\u8ff0\n\n\u7ed9 $n$ \u4e2a\u70b9\uff0c\u6700\u591a\u5b58\u5728\u4efb\u610f\u4e24\u70b9\u7684 $x$ \u6216 $y$ \u76f8\u7b49\uff0c\u4e00\u6761\u8fde\u7ebf\u53ea\u80fd\u5e73\u884c\u4e8e $x$ \u6216 $y$ \uff0c\u6c42\u662f\u5426\u5b58\u5728\u4e00\u79cd\u65b9\u6848\uff0c\u4f7f\u5f97\u6bcf\u4e2a\u70b9\u5747\u88ab\u8fde\u7ebf\u8986\u76d6\uff0c\u4e14\u8fde\u7ebf\u95f4\u6ca1\u6709\u516c\u5171\u70b9\uff08\u5373\u4e0d\u76f8\u4ea4\uff09\u3002\n\n## \u9898\u89e3\n\n\u5982\u679c\u5c06\u6240\u6709\u8fde\u7ebf\u90fd\u653e\u5165\u56fe\u4e2d\uff08\u4e0d\u8003\u8651\u76f8\u4ea4\uff09\uff0c\u53ef\u4ee5\u53d1\u73b0\u53ea\u5b58\u5728\u4e24\u79cd\u60c5\u51b5\uff1a\u94fe\u548c\u73af\u3002\n\n\u8003\u8651\u94fe\u7684\u60c5\u51b5\uff1a\n\n\u5982\u679c\u94fe\u4e0a\u6709\u5947\u6570\u4e2a\u70b9\uff0c\u663e\u7136\u4e0d\u5b58\u5728\u5408\u6cd5\u65b9\u6848\uff0c\u5982\u56fe\u3002\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/rkwuhbv1.png)\n\n\u5982\u679c\u94fe\u4e0a\u6709\u5076\u6570\u4e2a\u70b9\uff0c\u5219\u53ea\u5b58\u5728\u4e00\u79cd\u53ef\u80fd\u5408\u6cd5\u7684\u65b9\u6848\uff0c\u5373\u7531\u4e00\u7aef\u5f00\u59cb\u76f8\u95f4\u9009\u62e9\uff0c\u5982\u56fe\u3002\n\n![2](https://cdn.luogu.com.cn/upload/image_hosting/tza4jtaq.png)\n\n\u800c\u5173\u4e8e\u73af\uff0c\u5219\u6709\u4e24\u79cd\u53ef\u80fd\u5408\u6cd5\u7684\u65b9\u6848\uff0c\u5373\u5168\u9009\u7ad6\u8fb9\u6216\u5168\u9009\u6a2a\u8fb9\uff0c\u5982\u56fe\u3002\n\n![3](https://cdn.luogu.com.cn/upload/image_hosting/8pgockfw.png)\n\n~~\uff08\u4e00\u5f20\u56fe\u7528\u5230\u5e95\uff09~~\n\n\u9898\u76ee\u7684\u5173\u952e\u5c31\u5728\u4e8e\u901a\u8fc7\u68c0\u67e5\u8fb9\u4e0e\u8fb9\u662f\u5426\u76f8\u4ea4\uff0c\u4ece\u800c\u5224\u65ad\u94fe\u4e0e\u94fe\u3001\u94fe\u4e0e\u73af\u3001\u73af\u4e0e\u73af\u95f4\u7684\u5f71\u54cd\uff0c\u6700\u7ec8\u5f97\u51fa\u5408\u6cd5\u65b9\u6848\u3002\n\n## \u5b9e\u73b0\n\n\u9996\u5148\u8981\u5c06\u94fe\u548c\u73af\u627e\u51fa\u6765\u3002\u56e0\u4e3a\u56fe\u4e2d\u975e\u94fe\u5373\u73af\uff0c\u6240\u6709\u57fa\u672c\u4e0a\u6ca1\u4ec0\u4e48\u7ec6\u8282\uff0c\u5f88\u597d\u5b9e\u73b0\u3002\n\n```cpp\n...\nconst int M=1e5+5,T=1e5;\nint n,head[M],cnte,cnt,m,rt;\nbool vis[M],fl;\nvector<int> ax[M],ay[M];\nstruct node{int x,y;}a[M],tmp,ans[M];\nstruct edge{int to,nxt;}e[M<<1];\nvoid Add(int x,int y){\n\te[++cnte]=(edge){y,head[x]};\n\thead[x]=cnte;\n}\nvoid dfs(int x,int fa){\n\tvis[rt=x]=1;++cnt;\n\terep(i,x){\n\t\tint y=e[i].to;\n\t\tif(y==fa)continue;\n\t\tif(!vis[y])dfs(y,x);\n\t\telse fl=1;\n\t}\n}\n...\nint tot,mk[M];\nvector<node> gx,gy,cx[M],cy[M];\nvoid dfs1(int x,int fa,int d){\n\terep(i,x){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tif(d){\n\t\t\tif(a[x].x==a[y].x)gx.pb((node){x,y}),Tx.Ins((node){x,y},0);\n\t\t\tif(a[x].y==a[y].y)gy.pb((node){x,y}),Ty.Ins((node){x,y},0);\n\t\t\tans[++m]=(node){x,y};\n\t\t}\n\t\tdfs1(y,x,!d);\n\t}\n}\nbool vis2[M];\nvoid dfs2(int x,int fa){\n\tvis2[x]=1;\n\terep(i,x){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tif(y!=rt && vis2[y])continue;\n\t\tif(a[x].x==a[y].x)cx[tot].pb((node){x,y}),Cx.Ins((node){x,y},tot);\n\t\tif(a[x].y==a[y].y)cy[tot].pb((node){x,y}),Cy.Ins((node){x,y},tot);\n\t\tif(!vis2[y])dfs2(y,x);\n\t}\n}\n...\nrep(i,1,n=rd()){\n\ta[i].x=rd(),a[i].y=rd();\n\tax[a[i].x].pb(i);ay[a[i].y].pb(i);\n}\nrep(i,1,T)if(ax[i].size()==2)Add(ax[i][0],ax[i][1]),Add(ax[i][1],ax[i][0]);\nrep(i,1,T)if(ay[i].size()==2)Add(ay[i][0],ay[i][1]),Add(ay[i][1],ay[i][0]);\nrep(i,1,n)if(!vis[i]){\n\tcnt=0;fl=0;dfs(i,0);\n\tif(cnt&1)return puts(\"NE\"),0;\n\tif(!fl)dfs1(rt,0,1);\n\telse ++tot,dfs2(rt,0);\n}\n...\n```\n\n\u5bf9\u4e8e\u4ee5\u4e0a\u4ee3\u7801\uff0c\u5927\u5bb6\u53ef\u80fd\u770b\u4e0d\u61c2\u5176\u4e2d\u7684 Tx\u3001Cx \u7b49\uff0c\u8fd9\u6b63\u662f\u63a5\u4e0b\u6765\u8981\u8bb2\u7684\u3002\n\n\u5728\u627e\u51fa\u6240\u6709\u94fe\u548c\u73af\u7684\u8fb9\u540e\uff0c\u5c31\u8981\u5224\u65ad\u5b83\u4eec\u76f8\u4e92\u4e4b\u95f4\u7684\u5f71\u54cd\u4e86\u3002\u6ce8\u610f\u5230\u53ea\u6709\u6a2a\u8fb9\u548c\u7ad6\u8fb9\u4f1a\u76f8\u4e92\u5236\u7ea6\uff0c\u56e0\u6b64\u5bf9\u4e8e\u6a2a\u8fb9 $(x_1,x_2,y_1)$\uff0c\u53ef\u4ee5\u5728\u533a\u95f4 $[x_1,x_2]$ \u5185\u52a0\u5165 $y_1$\uff0c\u800c\u5f53\u67e5\u8be2\u7ad6\u8fb9 $(x_1,y_1,y_2)$ \u65f6\uff0c\u5bf9 $x_1$ \u5355\u7ebf\u67e5\u8be2\u662f\u5426\u6709 $[y_1,y_2]$ \u5185\u7684\u70b9\u3002\n\n\u53ef\u4ee5\u7528\u5e26 set \u7684\u7ebf\u6bb5\u6811\u5b9e\u73b0\u4e0a\u8ff0\u64cd\u4f5c\uff0c\u4e5f\u5c31\u662f\u4ee3\u7801\u4e2d\u7684 Tx\u3001Cx \u7b49\u3002\u5b9e\u73b0\u4e0a\u6ca1\u4ec0\u4e48\u56f0\u96be\uff0c\u63d2\u5165\u7528 insert\uff0c\u67e5\u8be2\u7528 lower_bound\uff0c\u5220\u9664\u7528 erase\uff0c\u5177\u4f53\u5982\u4e0b\uff1a\n\n```cpp\n...\n#define lp p<<1\n#define rp p<<1|1\nset<node>::iterator it;\nbool operator < (const node &a,const node &b){return a.y<b.y;}\nstruct Seg{\n\tset<node> t[M<<2];\n\tvoid chg(int x,int y,node z,int l=1,int r=T,int p=1){\n\t\tif(l==x && r==y)return t[p].insert(z),void();\n\t\tint mid=(l+r)>>1;\n\t\tif(y<=mid)chg(x,y,z,l,mid,lp);\n\t\telse if(mid<x)chg(x,y,z,mid+1,r,rp);\n\t\telse chg(x,mid,z,l,mid,lp),chg(mid+1,y,z,mid+1,r,rp);\n\t}\n\tvoid era(int x,int y,node z,int l=1,int r=T,int p=1){\n\t\tif(l==x && r==y){\n\t\t\tit=t[p].lb(z);\n\t\t\tif(it!=t[p].end() && it->y==z.y)t[p].erase(it);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(y<=mid)era(x,y,z,l,mid,lp);\n\t\telse if(mid<x)era(x,y,z,mid+1,r,rp);\n\t\telse era(x,mid,z,l,mid,lp),era(mid+1,y,z,mid+1,r,rp);\n\t}\n\tnode qry(int x,node z,int l=1,int r=T,int p=1){\n\t\tit=t[p].lb(z);\n\t\tnode s=(node){n+1,T+1};\n\t\tif(it!=t[p].end())s=*it;\n\t\tif(l==r)return s;\n\t\tint mid=(l+r)>>1;\n\t\tif(x<=mid)return min(s,qry(x,z,l,mid,lp));\n\t\treturn min(s,qry(x,z,mid+1,r,rp));\n\t}\n\tvoid Ins(node s,int id){\n\t\tint x=s.x,y=s.y;\n\t\tif(a[x].x==a[y].x)chg(min(a[x].y,a[y].y),max(a[x].y,a[y].y),(node){id,a[x].x});\n\t\tif(a[x].y==a[y].y)chg(min(a[x].x,a[y].x),max(a[x].x,a[y].x),(node){id,a[x].y});\n\t}\n\tvoid Era(node s,int id){\n\t\tint x=s.x,y=s.y;\n\t\tif(a[x].x==a[y].x)era(min(a[x].y,a[y].y),max(a[x].y,a[y].y),(node){id,a[x].x});\n\t\tif(a[x].y==a[y].y)era(min(a[x].x,a[y].x),max(a[x].x,a[y].x),(node){id,a[x].y});\n\t}\n}Tx,Ty,Cx,Cy;\n...\n```\n\n\u6709\u4e86\u6570\u636e\u7ed3\u6784\u7684\u652f\u6301\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5bfb\u627e\u5408\u6cd5\u65b9\u6848\u4e86\u3002\n\n\u9996\u5148\u5148\u5bfb\u627e\u94fe\u5bf9\u73af\u7684\u5f71\u54cd\u3002\u5982\u679c\u94fe\u7684\u6a2a\u8fb9\u4e0e\u73af\u7684\u7ad6\u8fb9\u76f8\u4ea4\uff0c\u5219\u73af\u7684\u7ad6\u8fb9\u4e0d\u53ef\u7528\uff0c\u6b64\u65f6\u73af\u53ea\u6709\u4e00\u79cd\u53ef\u80fd\u5408\u6cd5\u7684\u65b9\u6848\uff0c\u5373\u6a2a\u8fb9\u3002\u4e3a\u4e86\u65b9\u4fbf\uff0c\u53ef\u4ee5\u5c06\u5b83\u5f53\u505a\u53ea\u6709\u6a2a\u8fb9\u65b9\u6848\u7684\u94fe\uff0c\u4ece\u73af\u4e2d\u5220\u9664\uff0c\u52a0\u5165\u94fe\u4e2d\uff0c\u4fbf\u4e8e\u4e0e\u5176\u4ed6\u73af\u5224\u65ad\u3002\u540c\u7406\u7ad6\u8fb9\u4e0e\u6a2a\u8fb9\u4e5f\u662f\u4e00\u6837\u3002\n\n```cpp\n...\nfor(int i=0;i<(int)gx.size();++i){\n\tint x=gx[i].x,y=gx[i].y;\n\tint l=min(a[x].y,a[y].y),r=max(a[x].y,a[y].y);\n\tfor(tmp=Cy.qry(a[x].x,(node){0,l});tmp.y<=r;tmp=Cy.qry(a[x].x,(node){0,l})){\n\t\tint id=tmp.x;mk[id]=1;\n\t\trep(j,0,cx[id].size()-1)gx.pb(ans[++m]=cx[id][j]),Tx.Ins(cx[id][j],id);\n\t\trep(j,0,cx[id].size()-1)Cx.Era(cx[id][j],id);\n\t\trep(j,0,cy[id].size()-1)Cy.Era(cy[id][j],id);\n\t}\n}\nfor(int i=0;i<(int)gy.size();++i){\n\tint x=gy[i].x,y=gy[i].y;\n\tint l=min(a[x].x,a[y].x),r=max(a[x].x,a[y].x);\n\tfor(tmp=Cx.qry(a[x].y,(node){0,l});tmp.y<=r;tmp=Cx.qry(a[x].y,(node){0,l})){\n\t\tint id=tmp.x;mk[id]=1;\n\t\trep(j,0,cy[id].size()-1)gy.pb(ans[++m]=cy[id][j]),Ty.Ins(cy[id][j],id);\n\t\trep(j,0,cx[id].size()-1)Cx.Era(cx[id][j],id);\n\t\trep(j,0,cy[id].size()-1)Cy.Era(cy[id][j],id);\n\t}\n}\n...\n```\n\n\u7ecf\u8fc7\u4ee5\u4e0a\u64cd\u4f5c\uff0c\u6211\u4eec\u6210\u529f\u5f97\u5230\u4e86\u4e00\u4e9b\u552f\u4e00\u65b9\u6848\u7684\u94fe\u548c\u4e00\u4e9b\u4e0d\u4f1a\u88ab\u94fe\u5e72\u6270\u7684\u73af\uff0c\u63a5\u4e0b\u6765\u5224\u65ad\u94fe\u4e0e\u94fe\u4e4b\u95f4\u662f\u5426\u4f1a\u76f8\u4e92\u77db\u76fe\uff0c\u5982\u679c\u77db\u76fe\u5219\u7ed3\u675f\u7a0b\u5e8f\u3002\u800c\u5173\u4e8e\u5269\u4e0b\u73af\uff0c\u56e0\u4e3a\u4e0d\u53d7\u94fe\u7684\u5e72\u6270\uff0c\u56e0\u6b64\u53ea\u9700\u5168\u90e8\u9009\u6a2a\u8fb9\u6216\u7ad6\u8fb9\u5c31\u4e0d\u4f1a\u77db\u76fe\u3002\n\n```cpp\n...\nfor(int i=0;i<(int)gx.size();++i){\n\tint x=gx[i].x,y=gx[i].y;\n\tint l=min(a[x].y,a[y].y),r=max(a[x].y,a[y].y);\n\ttmp=Ty.qry(a[x].x,(node){0,l});\n\tif(tmp.y<=r)return puts(\"NE\"),0;\n}\nfor(int i=0;i<(int)gy.size();++i){\n\tint x=gy[i].x,y=gy[i].y;\n\tint l=min(a[x].x,a[y].x),r=max(a[x].x,a[y].x);\n\ttmp=Tx.qry(a[x].y,(node){0,l});\n\tif(tmp.y<=r)return puts(\"NE\"),0;\n}\nrep(i,1,tot)if(!mk[i])\n\trep(j,0,cx[i].size()-1)ans[++m]=cx[i][j];\nputs(\"DA\");\nrep(i,1,m)printf(\"%d %d\\n\",ans[i].x,ans[i].y);\n...\n```\n\n\u6700\u540e\u653e\u4e0a\u5b8c\u6574\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define db double\n#define reg register\n#define LL long long\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define ull unsigned long long\n#define rep(i,a,b) for(int i=a,i##end=b;i<=i##end;++i)\n#define drep(i,a,b) for(int i=a,i##end=b;i>=i##end;--i)\n#define erep(i,a) for(int i=head[a];i;i=e[i].nxt)\n\n\nusing namespace std;\nbool Handsome;\ninline int rd(){\n\treg int x=0;reg char o=getchar();reg bool O=0;\n\tfor(;o<48 || 57<o;o=getchar())if(o=='-')O=1;\n\tfor(;48<=o && o<=57;o=getchar())x=(x<<1)+(x<<3)+(o^48);\n\treturn O?-x:x;\n}\ninline void Mi(int &x,int y){if(x>y && (x=y));}\ninline void Mx(int &x,int y){if(x<y && (x=y));}\nconst int M=1e5+5,T=1e5;\nint n,head[M],cnte,cnt,m,rt;\nbool vis[M],fl;\nvector<int> ax[M],ay[M];\nstruct node{int x,y;}a[M],tmp,ans[M];\nstruct edge{int to,nxt;}e[M<<1];\nvoid Add(int x,int y){\n\te[++cnte]=(edge){y,head[x]};\n\thead[x]=cnte;\n}\nvoid dfs(int x,int fa){\n\tvis[rt=x]=1;++cnt;\n\terep(i,x){\n\t\tint y=e[i].to;\n\t\tif(y==fa)continue;\n\t\tif(!vis[y])dfs(y,x);\n\t\telse fl=1;\n\t}\n}\n#define lp p<<1\n#define rp p<<1|1\nset<node>::iterator it;\nbool operator < (const node &a,const node &b){return a.y<b.y;}\nstruct Seg{\n\tset<node> t[M<<2];\n\tvoid chg(int x,int y,node z,int l=1,int r=T,int p=1){\n\t\tif(l==x && r==y)return t[p].insert(z),void();\n\t\tint mid=(l+r)>>1;\n\t\tif(y<=mid)chg(x,y,z,l,mid,lp);\n\t\telse if(mid<x)chg(x,y,z,mid+1,r,rp);\n\t\telse chg(x,mid,z,l,mid,lp),chg(mid+1,y,z,mid+1,r,rp);\n\t}\n\tvoid era(int x,int y,node z,int l=1,int r=T,int p=1){\n\t\tif(l==x && r==y){\n\t\t\tit=t[p].lb(z);\n\t\t\tif(it!=t[p].end() && it->y==z.y)t[p].erase(it);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(y<=mid)era(x,y,z,l,mid,lp);\n\t\telse if(mid<x)era(x,y,z,mid+1,r,rp);\n\t\telse era(x,mid,z,l,mid,lp),era(mid+1,y,z,mid+1,r,rp);\n\t}\n\tnode qry(int x,node z,int l=1,int r=T,int p=1){\n\t\tit=t[p].lb(z);\n\t\tnode s=(node){n+1,T+1};\n\t\tif(it!=t[p].end())s=*it;\n\t\tif(l==r)return s;\n\t\tint mid=(l+r)>>1;\n\t\tif(x<=mid)return min(s,qry(x,z,l,mid,lp));\n\t\treturn min(s,qry(x,z,mid+1,r,rp));\n\t}\n\tvoid Ins(node s,int id){\n\t\tint x=s.x,y=s.y;\n\t\tif(a[x].x==a[y].x)chg(min(a[x].y,a[y].y),max(a[x].y,a[y].y),(node){id,a[x].x});\n\t\tif(a[x].y==a[y].y)chg(min(a[x].x,a[y].x),max(a[x].x,a[y].x),(node){id,a[x].y});\n\t}\n\tvoid Era(node s,int id){\n\t\tint x=s.x,y=s.y;\n\t\tif(a[x].x==a[y].x)era(min(a[x].y,a[y].y),max(a[x].y,a[y].y),(node){id,a[x].x});\n\t\tif(a[x].y==a[y].y)era(min(a[x].x,a[y].x),max(a[x].x,a[y].x),(node){id,a[x].y});\n\t}\n}Tx,Ty,Cx,Cy;\nint tot,mk[M];\nvector<node> gx,gy,cx[M],cy[M];\nvoid dfs1(int x,int fa,int d){\n\terep(i,x){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tif(d){\n\t\t\tif(a[x].x==a[y].x)gx.pb((node){x,y}),Tx.Ins((node){x,y},0);\n\t\t\tif(a[x].y==a[y].y)gy.pb((node){x,y}),Ty.Ins((node){x,y},0);\n\t\t\tans[++m]=(node){x,y};\n\t\t}\n\t\tdfs1(y,x,!d);\n\t}\n}\nbool vis2[M];\nvoid dfs2(int x,int fa){\n\tvis2[x]=1;\n\terep(i,x){\n\t\tint y=e[i].to;if(y==fa)continue;\n\t\tif(y!=rt && vis2[y])continue;\n\t\tif(a[x].x==a[y].x)cx[tot].pb((node){x,y}),Cx.Ins((node){x,y},tot);\n\t\tif(a[x].y==a[y].y)cy[tot].pb((node){x,y}),Cy.Ins((node){x,y},tot);\n\t\tif(!vis2[y])dfs2(y,x);\n\t}\n}\nbool Most;\nint main(){\n//\tprintf(\"%.2lfMB\\n\",(&Most-&Handsome)/1024.0/1024.0);\n\trep(i,1,n=rd()){\n\t\ta[i].x=rd(),a[i].y=rd();\n\t\tax[a[i].x].pb(i);ay[a[i].y].pb(i);\n\t}\n\trep(i,1,T)if(ax[i].size()==2)Add(ax[i][0],ax[i][1]),Add(ax[i][1],ax[i][0]);\n\trep(i,1,T)if(ay[i].size()==2)Add(ay[i][0],ay[i][1]),Add(ay[i][1],ay[i][0]);\n\trep(i,1,n)if(!vis[i]){\n\t\tcnt=0;fl=0;dfs(i,0);\n\t\tif(cnt&1)return puts(\"NE\"),0;\n\t\tif(!fl)dfs1(rt,0,1);\n\t\telse ++tot,dfs2(rt,0);\n\t}\n\tfor(int i=0;i<(int)gx.size();++i){\n\t\tint x=gx[i].x,y=gx[i].y;\n\t\tint l=min(a[x].y,a[y].y),r=max(a[x].y,a[y].y);\n\t\tfor(tmp=Cy.qry(a[x].x,(node){0,l});tmp.y<=r;tmp=Cy.qry(a[x].x,(node){0,l})){\n\t\t\tint id=tmp.x;mk[id]=1;\n\t\t\trep(j,0,cx[id].size()-1)gx.pb(ans[++m]=cx[id][j]),Tx.Ins(cx[id][j],id);\n\t\t\trep(j,0,cx[id].size()-1)Cx.Era(cx[id][j],id);\n\t\t\trep(j,0,cy[id].size()-1)Cy.Era(cy[id][j],id);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)gy.size();++i){\n\t\tint x=gy[i].x,y=gy[i].y;\n\t\tint l=min(a[x].x,a[y].x),r=max(a[x].x,a[y].x);\n\t\tfor(tmp=Cx.qry(a[x].y,(node){0,l});tmp.y<=r;tmp=Cx.qry(a[x].y,(node){0,l})){\n\t\t\tint id=tmp.x;mk[id]=1;\n\t\t\trep(j,0,cy[id].size()-1)gy.pb(ans[++m]=cy[id][j]),Ty.Ins(cy[id][j],id);\n\t\t\trep(j,0,cx[id].size()-1)Cx.Era(cx[id][j],id);\n\t\t\trep(j,0,cy[id].size()-1)Cy.Era(cy[id][j],id);\n\t\t}\n\t}\n\tfor(int i=0;i<(int)gx.size();++i){\n\t\tint x=gx[i].x,y=gx[i].y;\n\t\tint l=min(a[x].y,a[y].y),r=max(a[x].y,a[y].y);\n\t\ttmp=Ty.qry(a[x].x,(node){0,l});\n\t\tif(tmp.y<=r)return puts(\"NE\"),0;\n\t}\n\tfor(int i=0;i<(int)gy.size();++i){\n\t\tint x=gy[i].x,y=gy[i].y;\n\t\tint l=min(a[x].x,a[y].x),r=max(a[x].x,a[y].x);\n\t\ttmp=Tx.qry(a[x].y,(node){0,l});\n\t\tif(tmp.y<=r)return puts(\"NE\"),0;\n\t}\n\trep(i,1,tot)if(!mk[i])\n\t\trep(j,0,cx[i].size()-1)ans[++m]=cx[i][j];\n\tputs(\"DA\");\n\trep(i,1,m)printf(\"%d %d\\n\",ans[i].x,ans[i].y);\n\treturn 0;\n}\n```\n\n$\\mathcal{By}\\quad\\mathcal{Most}\\ \\mathcal{Handsome}$\n\n$\\mathcal{2021.08.24}$",
        "postTime": 1629803164,
        "uid": 51733,
        "name": "Most_Handsome",
        "ccfLevel": 7,
        "title": "\u9898\u89e3P6868 [COCI2019-2020#5] Matching"
    },
    {
        "content": "## 1. \u9898\u610f\n\n\u7ed9\u4f60\u4e8c\u7ef4\u5e73\u9762\u4e0a\u7684 $n$ \u4e2a\u6574\u70b9\u3002\u4fdd\u8bc1 $\\forall a$\uff0c\u6709\u81f3\u591a\u4e24\u4e2a\u5f62\u5982 $(a,x)$ \u7684\u70b9\uff1b$\\forall b$\uff0c\u6709\u81f3\u591a\u4e24\u4e2a\u5f62\u5982 $(x,b)$ \u7684\u70b9\u3002\n\n\u8bf7\u4f60\u7528 $n\\over 2$ \u6761\u7ebf\u6bb5\u8fde\u63a5\u8fd9 $n$ \u4e2a\u70b9\u3002\u8981\u6c42\u6bcf\u4e2a\u70b9\u90fd\u662f\u4e00\u6761\u7ebf\u6bb5\u7684\u7aef\u70b9\u3002\u8981\u6c42\u8fd9\u4e9b\u7ebf\u6bb5\u90fd\u662f\u6c34\u5e73\u7684\u6216\u7ad6\u76f4\u7684\u3002\u8981\u6c42\u8fd9\u4e9b\u7ebf\u6bb5\u90fd\u4e0d\u76f8\u4ea4\u3002\n\n\u8bf7\u4f60\u6c42\u51fa\u8fd9\u662f\u5426\u53ef\u80fd\u3002\u5982\u679c\u53ef\u80fd\uff0c\u8bf7\u4f60\u8f93\u51fa\u4efb\u610f\u4e00\u79cd\u65b9\u6cd5\u3002\n\n$2\\le n\\le 100000, 1\\leq x_i,y_i\\leq 100000$\n\n## 2. \u601d\u8def\n\n\u8003\u8651\u4e00\u5f00\u59cb\u5c06\u6240\u6709\u70b9\u90fd\u6309\u7167\u7ad6\u7740\u5339\u914d\uff0c\u5982\u679c\u6ca1\u6709\u5355\u4e2a\u7684\u70b9\u6ca1\u6709\u5339\u914d\uff0c\u90a3\u4e48\u5c31\u76f4\u63a5\u5408\u6cd5\u3002\n\n\u5426\u5219\u5c06\u8fd9\u4e9b\u6ca1\u6709\u5339\u914d\u7684\u70b9\u52a0\u5165\u5230\u4e00\u4e2a\u961f\u5217\u91cc\u9762\uff0c\u8868\u793a\u8fd9\u4e9b\u70b9\u53ea\u80fd\u6a2a\u7740\u5339\u914d\uff0c\u4e00\u65e6\u5c06\u8fd9\u4e9b\u70b9\u6a2a\u7740\u5339\u914d\uff0c\u5c31\u4f1a\u4ea7\u751f\u8fde\u9501\u53cd\u5e94\uff0c\u539f\u6765\u7684\u4e00\u4e9b\u7ad6\u7740\u7684\u5339\u914d\u56e0\u4e3a\u548c\u8fd9\u4e9b\u65b0\u7684\u5339\u914d\u4ea4\u53c9\u6240\u4ee5\u4e5f\u53ea\u80fd\u6539\u6210\u6a2a\u7740\u5339\u914d\uff0c\u628a\u8fd9\u4e9b\u70b9\u4e5f\u52a0\u5165\u5230\u961f\u5217\u91cc\u9762\u3002\n\n\u73b0\u5728\u7684\u95ee\u9898\u662f\u5982\u4f55\u5feb\u901f\u627e\u5230\u4e0e\u5f53\u524d\u65b0\u52a0\u7684\u6a2a\u7740\u7684\u5339\u914d\u4ea4\u53c9\u7684\u5339\u914d\uff0c\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u5957 set \u89e3\u51b3\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2n)$\u3002\n\n## 3. \u4ee3\u7801\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2e5 + 10;\nint n, vis[N], tag[N];\nvector<int> row[N], col[N];\nset<int> s;\nstruct Point { int x, y; } a[N];\n\nnamespace SegTree {\nstruct SegNode { int l, r; vector<int> v; } t[N << 2];\ninline int ls(int i) { return i << 1; }\ninline int rs(int i) { return i << 1 | 1; }\nvoid build(int i, int l, int r) {\n  t[i].l = l, t[i].r = r;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(ls(i), l, mid), build(rs(i), mid + 1, r);\n}\nvoid modify(int i, int l, int r, int v) {\n  if (l <= t[i].l && r >= t[i].r) {\n    auto &res = t[i].v;\n    res.emplace(std::lower_bound(res.begin(), res.end(), v), v);\n    return;\n  }\n  int mid = (t[i].l + t[i].r) >> 1;\n  if (l <= mid) modify(ls(i), l, r, v);\n  if (r > mid) modify(rs(i), l, r, v);\n}\nvoid del(int i, int l, int r, int v) {\n  if (l <= t[i].l && r >= t[i].r) {\n    auto &res = t[i].v;\n    res.erase(lower_bound(res.begin(), res.end(), v));\n    return;\n  }\n  int mid = (t[i].l + t[i].r) >> 1;\n  if (l <= mid) del(ls(i), l, r, v);\n  if (r > mid) del(rs(i), l, r, v);\n}\nvoid query(int i, int x, int l, int r) {\n  auto &res = t[i].v;\n  auto it = std::lower_bound(res.begin(), res.end(), l);\n  while (it != res.end() && *it <= r) s.emplace(*it), ++it;\n  if (t[i].l == t[i].r) return;\n  int mid = (t[i].l + t[i].r) >> 1;\n  if (x <= mid) return query(ls(i), x, l, r);\n  else return query(rs(i), x, l, r);\n}\n} using namespace SegTree;\n\nint main() {\n  ios::sync_with_stdio(0), cin.tie(0);\n  queue<int> Q;\n  vector<pair<int, int>> ans;\n  build(1, 1, N - 10);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i].x >> a[i].y;\n    row[a[i].x].emplace_back(i), col[a[i].y].emplace_back(i);\n  }\n  for (int i = 1; i <= n; ++i) if (!vis[i]) {\n    if (row[a[i].x].size() == 2) {\n      int p = i, q = row[a[i].x][0] + row[a[i].x][1] - i;\n      vis[p] = vis[q] = 1;\n      if (a[p].y > a[q].y) swap(p, q);\n      modify(1, a[p].y, a[q].y, a[p].x);\n    } else Q.push(i);\n  }\n  while (!Q.empty()) {\n    int u = Q.front(); Q.pop();\n    if (tag[u]) continue;\n    if (col[a[u].y].size() == 1) { cout << \"NE\\n\"; return 0; }\n    int p = u, q = col[a[u].y][0] + col[a[u].y][1] - p;\n    if (a[p].x > a[q].x) swap(p, q);\n    ans.emplace_back(p, q), tag[p] = tag[q] = 1;\n    query(1, a[p].y, a[p].x, a[q].x);\n    for (auto x: s) {\n      p = row[x][0], q = row[x][1];\n      if (a[p].y > a[q].y) swap(p, q);\n      vis[p] = vis[q] = 0;\n      del(1, a[p].y, a[q].y, a[p].x);\n      Q.emplace(p), Q.emplace(q);\n    }\n    s.clear();\n  }\n  for (int i = 1; i <= n; ++i) if (vis[i]) {\n    int p = i, q = row[a[i].x][0] + row[a[i].x][1] - i;\n    vis[p] = vis[q] = 0;\n    ans.emplace_back(p, q);\n  }\n  cout << \"DA\\n\";\n  for (auto x: ans) cout << x.first << \" \" << x.second << \"\\n\";\n  return 0;\n}\n```",
        "postTime": 1663148212,
        "uid": 86576,
        "name": "zlxFTH",
        "ccfLevel": 7,
        "title": "P6868 [COCI2019-2020#5] Matching"
    }
]