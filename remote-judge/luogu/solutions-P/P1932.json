[
    {
        "content": "\u6781\u7b80\u7248Python3~\n\n```Py3\na , b = int(input()),int(input())\nprint (a + b)\nprint (a - b)\nprint (a * b)\nprint (a // b)\nprint (a % b)\n```",
        "postTime": 1508072813,
        "uid": 52938,
        "name": "\u53e3\u2022\u2022\u53e3",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u66f4\u65b0\u4e00\u6b21~~\n\n\u770b\u5230\u597d\u591a\u4eba\u5361\u5230\u6211\u524d\u9762\u53bb\u4e86\uff0c\u5fc3\u60c5\u590d\u6742\uff0c\u4e8e\u662f\u53c8\u5199\u4e86\u4e00\u4e2a\u66f4\u5feb\u4e00\u70b9\u7684\u3002\u73b0\u572816ms\uff0c\u8fd8\u662f\u7b2c\u4e00\u3002\u6ca1\u6709\u7528vector\uff0c\u7528\u8d77\u6765\u7684\u786e\u6709\u70b9\u9ebb\u70e6\u3002\n\n\u9664\u6cd5\u7684\u5b9e\u73b0\u65b9\u6cd5\u6539\u4e86\u4e00\u4e0b\uff0c\u6539\u6210\u6bcf\u4e00\u4e2a1e9\u4e4b\u5185\u4e8c\u5206\u7b54\u6848\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u8fd8\u662fO(n^2)\uff0c\u4f46\u662f\u5e38\u6570\u5c0f\u4e86\u5f88\u591a\u3002\n```cpp\n// luogu-judger-enable-o2\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cassert>\n\ntypedef int i32;\ntypedef unsigned u32;\ntypedef unsigned long long u64;\n\nstruct BigInt\n{\n    const static u32 exp = 9;\n    const static u32 mod = 1000000000;\n\n    static i32 abs_comp(const BigInt &lhs, const BigInt &rhs)\n    {\n        if (lhs.len != rhs.len)\n            return lhs.len < rhs.len ? -1 : 1;\n        for (u32 i = lhs.len - 1; ~i; --i)\n            if (lhs.val[i] != rhs.val[i])\n                return lhs.val[i] < rhs.val[i] ? -1 : 1;\n        return 0;\n    }\n\n    u32 *val, len, sgn;\n\n    BigInt(u32 *val = nullptr, u32 len = 0, u32 sgn = 0) : val(val), len(len), sgn(sgn) {}\n\n    // copy_to cannot guarantee val[x] == 0 for x >= len\n    // other function should set (the position they assume to be zero) as zero\n    void copy_to(BigInt &dst) const\n    {\n        dst.len = len, dst.sgn = sgn;\n        memcpy(dst.val, val, sizeof(u32) * len);\n    }\n\n    void trim()\n    {\n        while (len && !val[len - 1])\n            --len;\n        if (len == 0)\n            sgn = 0;\n    }\n\n    void add(BigInt &x)\n    {\n        if (sgn ^ x.sgn)\n            return x.sgn ^= 1, sub(x);\n        val[len = std::max(len, x.len)] = 0;\n        for (u32 i = 0; i < x.len; ++i)\n            if ((val[i] += x.val[i]) >= mod)\n                val[i] -= mod, ++val[i + 1];\n        for (u32 i = x.len; i < len && val[i] >= mod; ++i)\n            val[i] -= mod, ++val[i + 1];\n        if (val[len])\n            ++len;\n    }\n\n    void sub(BigInt &x)\n    {\n        if (sgn ^ x.sgn)\n            return x.sgn ^= 1, add(x);\n        if (abs_comp(*this, x) < 0)\n            std::swap(*this, x), sgn ^= 1;\n        val[len] = 0;\n        for (u32 i = 0; i < x.len; ++i)\n            if ((val[i] -= x.val[i]) & 0x80000000)\n                val[i] += mod, --val[i + 1];\n        for (u32 i = x.len; i < len && val[i] & 0x80000000; ++i)\n            val[i] += mod, --val[i + 1];\n        trim();\n    }\n\n    void mul(BigInt &x, u32 *ext_mem)\n    {\n        assert(this != &x);\n        memcpy(ext_mem, val, sizeof(u32) * len);\n        memset(val, 0, sizeof(u32) * (len + x.len));\n        for (u32 i = 0; i < len; ++i)\n            for (u32 j = 0; j < x.len; ++j)\n            {\n                u64 tmp = (u64)ext_mem[i] * x.val[j] + val[i + j];\n                val[i + j] = tmp % mod;\n                val[i + j + 1] += tmp / mod;\n            }\n        len += x.len, sgn ^= x.sgn;\n        trim();\n    }\n\n    void mul(u32 x)\n    {\n        if (x & 0x80000000)\n            x = -x, sgn ^= 1;\n        u64 carry = 0;\n        for (u32 i = 0; i < len; ++i)\n        {\n            carry += (u64)val[i] * x;\n            val[i] = carry % mod;\n            carry /= mod;\n        }\n        if (carry)\n            val[len++] = carry;\n        trim();\n    }\n\n    void div(BigInt &x, BigInt &remainder, u32 *ext_mem)\n    {\n        assert(this != &x && this != &remainder);\n        copy_to(remainder), memset(val, 0, sizeof(u32) * len);\n        u32 shift = len - x.len;\n        if (shift & 0x80000000)\n            return void(len = sgn = 0);\n        while (~shift)\n        {\n            u32 l = 0, r = mod;\n            BigInt mul_test{ext_mem}, remainder_high{remainder.val + shift, remainder.len - shift};\n            while (l <= r)\n            {\n                u32 mid = (l + r) / 2;\n                x.copy_to(mul_test), mul_test.mul(mid);\n                abs_comp(mul_test, remainder_high) < 0 ? l = mid + 1 : r = mid - 1;\n            }\n            val[shift] = r;\n            x.copy_to(mul_test), mul_test.mul(r);\n            remainder_high.sub(mul_test), remainder.trim();\n            --shift;\n        }\n        sgn ^= x.sgn;\n        trim();\n    }\n\n    void div(u32 x)\n    {\n        if (x & 0x80000000)\n            x = -x, sgn ^= 1;\n        u64 carry = 0;\n        for (u32 i = len - 1; ~i; --i)\n        {\n            carry = carry * mod + val[i];\n            val[i] = carry / x;\n            carry %= x;\n        }\n        trim();\n    }\n\n    void read(const char *s)\n    {\n        sgn = len = 0;\n        i32 bound = 0, pos;\n        if (s[0] == '-')\n            sgn = bound = 1;\n        u64 cur = 0, pow = 1;\n        for (pos = strlen(s) - 1; pos + 1 >= exp + bound; pos -= exp, val[len++] = cur, cur = 0, pow = 1)\n            for (i32 i = pos; i + exp > pos; --i)\n                cur += (s[i] - '0') * pow, pow *= 10;\n        for (cur = 0, pow = 1; pos >= bound; --pos)\n            cur += (s[pos] - '0') * pow, pow *= 10;\n        if (cur)\n            val[len++] = cur;\n    }\n\n    void print()\n    {\n        if (len)\n        {\n            if (sgn)\n                putchar('-');\n            printf(\"%u\", val[len - 1]);\n            for (u32 i = len - 2; ~i; --i)\n                printf(\"%0*u\", exp, val[i]);\n        }\n        else\n            putchar('0');\n        puts(\"\");\n    }\n};\n\nconst int N = 1e4 + 20;\nu32 a_[N], b_[N], r_[N], tmp[N * 2];\nchar sa[N], sb[N];\n\nint main()\n{\n    scanf(\"%s%s\", sa, sb);\n    {\n        BigInt a{a_}, b{b_};\n        a.read(sa), b.read(sb), a.add(b), a.print();\n    }\n    {\n        BigInt a{a_}, b{b_};\n        a.read(sa), b.read(sb), a.sub(b), a.print();\n    }\n    {\n        BigInt a{a_}, b{b_};\n        a.read(sa), b.read(sb), a.mul(b, tmp), a.print();\n    }\n    {\n        BigInt a{a_}, b{b_}, r{r_};\n        a.read(sa), b.read(sb), a.div(b, r, tmp), a.print();\n        r.print();\n    }\n}\n```\n--------------------------------------\n\n\u5404\u4f4dC++\u5927\u4f6c\uff0c\u901f\u5ea6\u6bd4\u4e0d\u8fc7python\u4f60\u4eec\u7684\u5fc3\u4e0d\u4f1a\u75db\u5417?\n\n76ms\uff0c\u76ee\u524d\u7b2c\u4e00\uff0c\u5e72\u6389python\uff0c\u7b97\u662f\u7ef4\u62a4\u4e00\u4e0bC++\u7684\u5c0a\u4e25\u5427\u3002\n\n\u9664\u6cd5\u7684\u601d\u8def\u662f\u500d\u589e\uff0c\u8bb0n\u4e3a\u8f93\u5165\u4e32\u7684\u957f\u5ea6(\u800c\u975e\u8f93\u5165\u4e32\u4ee3\u8868\u7684\u6570\u503c\u5927\u5c0f)\uff0c\u5219\u500d\u589e\u7684\u5224\u65ad\u6b21\u6570\u662fO(n)\uff0c\u6bcf\u6b21\u5224\u65ad\u53ea\u6d89\u53ca\u5230\u52a0\u6cd5\uff0c\u590d\u6742\u5ea6\u4e5f\u662fO(n)\uff0c\u603b\u4f53O(n^2)\u3002\u4e8c\u5206\u67e5\u627e\u7684\u8bdd\uff0c\u6bcf\u6b21\u5224\u65ad\u90fd\u662f\u4e58\u6cd5\uff0c\u603b\u4f53\u590d\u6742\u5ea6O(n^3)\u3002\n\n```cpp\n// luogu-judger-enable-o2\n#include <bits/stdc++.h>\nclass BigInt\n{\n#define Value(x, nega) ((nega) ? -(x) : (x))\n#define At(vec, index) ((index) < vec.size() ? vec[(index)] : 0)\n    //C\u98ce\u683c\u7684\u6bd4\u8f83\u51fd\u6570,\u5176\u6b63\u8d1f\u7b49\u4e8eabs(lhs)-abs(rhs)\u7684\u6b63\u8d1f\n    static int absComp(const BigInt &lhs, const BigInt &rhs)\n    {\n        if (lhs.size() != rhs.size())\n            return lhs.size() < rhs.size() ? -1 : 1;\n        for (int i = lhs.size() - 1; i >= 0; --i)\n            if (lhs[i] != rhs[i])\n                return lhs[i] < rhs[i] ? -1 : 1;\n        return 0;\n    }\n    using Long = long long;\n    const static int Exp = 9;\n    const static Long Mod = 1000000000;\n    mutable std::vector<Long> val;\n    mutable bool nega = false;\n    //\u89c4\u5b9a:0\u7684nega\u5fc5\u987b\u662ffalse,0\u7684size\u5fc5\u987b\u662f0\n    void trim() const\n    {\n        while (val.size() && val.back() == 0)\n            val.pop_back();\n        if (val.empty())\n            nega = false;\n    }\n    int size() const { return val.size(); }\n    Long &operator[](int index) const { return val[index]; }\n    Long &back() const { return val.back(); }\n    BigInt(int size, bool nega) : val(size), nega(nega) {}\n    BigInt(const std::vector<Long> &val, bool nega) : val(val), nega(nega) {}\n\n  public:\n    friend std::ostream &operator<<(std::ostream &os, const BigInt &n)\n    {\n        if (n.size())\n        {\n            if (n.nega)\n                putchar('-');\n            for (int i = n.size() - 1; i >= 0; --i)\n            {\n                if (i == n.size() - 1)\n                    printf(\"%lld\", n[i]); \n                else\n                    printf(\"%0*lld\", n.Exp, n[i]); \n            }\n        }\n        else\n            putchar('0');\n        return os;\n    }\n    friend BigInt operator+(const BigInt &lhs, const BigInt &rhs)\n    {\n        BigInt ret(lhs);\n        return ret += rhs;\n    }\n    friend BigInt operator-(const BigInt &lhs, const BigInt &rhs)\n    {\n        BigInt ret(lhs);\n        return ret -= rhs;\n    }\n    BigInt(Long x = 0)\n    {\n        if (x < 0)\n            x = -x, nega = true;\n        while (x >= Mod)\n            val.push_back(x % Mod), x /= Mod;\n        if (x)\n            val.push_back(x);\n    }\n    BigInt(const char *s)\n    {\n        int bound = 0, pos;\n        if (s[0] == '-')\n            nega = true, bound = 1;\n        Long cur = 0, pow = 1;\n        for (pos = strlen(s) - 1; pos >= Exp + bound - 1; pos -= Exp, val.push_back(cur), cur = 0, pow = 1)\n            for (int i = pos; i > pos - Exp; --i)\n                cur += (s[i] - '0') * pow, pow *= 10;\n        for (cur = 0, pow = 1; pos >= bound; --pos)\n            cur += (s[pos] - '0') * pow, pow *= 10;\n        if (cur)\n            val.push_back(cur);\n    }\n    BigInt &operator+=(const BigInt &rhs)\n    {\n        const int cap = std::max(size(), rhs.size()) + 1;\n        val.resize(cap);\n        int carry = 0;\n        for (int i = 0; i < cap - 1; ++i)\n        {\n            val[i] = Value(val[i], nega) + Value(At(rhs, i), rhs.nega) + carry, carry = 0;\n            if (val[i] >= Mod)\n                val[i] -= Mod, carry = 1; //\u81f3\u591a\u53ea\u9700\u8981\u51cf\u4e00\u6b21\uff0c\u4e0d\u9700\u8981\u53d6\u6a21\n            else if (val[i] < 0)\n                val[i] += Mod, carry = -1; //\u540c\u7406\n        }\n        if ((val.back() = carry) == -1) //assert(val.back() == 1 or 0 or -1)\n        {\n            nega = true, val.pop_back();\n            bool tailZero = true;\n            for (int i = 0; i < cap - 1; ++i)\n            {\n                if (tailZero && val[i])\n                    val[i] = Mod - val[i], tailZero = false;\n                else\n                    val[i] = Mod - 1 - val[i];\n            }\n        }\n        trim();\n        return *this;\n    }\n    friend BigInt operator-(const BigInt &rhs)\n    {\n        BigInt ret(rhs);\n        ret.nega ^= 1;\n        return ret;\n    }\n    BigInt &operator-=(const BigInt &rhs)\n    {\n        rhs.nega ^= 1;\n        *this += rhs;\n        rhs.nega ^= 1;\n        return *this;\n    }\n    //\u9ad8\u7cbe*\u9ad8\u7cbe\u6ca1\u529e\u6cd5\u539f\u5730\u64cd\u4f5c\uff0c\u6240\u4ee5\u5b9e\u73b0operator*\n    //\u9ad8\u7cbe*\u4f4e\u7cbe\u53ef\u4ee5\u539f\u5730\u64cd\u4f5c\uff0c\u6240\u4ee5operator*=\n    friend BigInt operator*(const BigInt &lhs, const BigInt &rhs)\n    {\n        const int cap = lhs.size() + rhs.size() + 1;\n        BigInt ret(cap, lhs.nega ^ rhs.nega);\n        //j < l.size(),i - j < rhs.size() => i - rhs.size() + 1 <= j\n        for (int i = 0; i < cap - 1; ++i) // assert(0 <= ret[cap-1] < Mod)\n            for (int j = std::max(i - rhs.size() + 1, 0), up = std::min(i + 1, lhs.size()); j < up; ++j)\n            {\n                ret[i] += lhs[j] * rhs[i - j];\n                ret[i + 1] += ret[i] / Mod, ret[i] %= Mod;\n            }\n        ret.trim();\n        return ret;\n    }\n    BigInt &operator*=(const BigInt &rhs) { return *this = *this * rhs; }\n    friend BigInt operator/(const BigInt &lhs, const BigInt &rhs)\n    {\n        static std::vector<BigInt> powTwo{BigInt(1)};\n        static std::vector<BigInt> estimate;\n        estimate.clear();\n        if (absComp(lhs, rhs) < 0)\n            return BigInt();\n        BigInt cur = rhs;\n        int cmp;\n        while ((cmp = absComp(cur, lhs)) <= 0)\n        {\n            estimate.push_back(cur), cur += cur;\n            if (estimate.size() >= powTwo.size())\n                powTwo.push_back(powTwo.back() + powTwo.back());\n        }\n        if (cmp == 0)\n            return BigInt(powTwo.back().val, lhs.nega ^ rhs.nega);\n        BigInt ret = powTwo[estimate.size() - 1];\n        cur = estimate[estimate.size() - 1];\n        for (int i = estimate.size() - 1; i >= 0 && cmp != 0; --i)\n            if ((cmp = absComp(cur + estimate[i], lhs)) <= 0)\n                cur += estimate[i], ret += powTwo[i];\n        ret.nega = lhs.nega ^ rhs.nega;\n        return ret;\n    }\n    bool operator==(const BigInt &rhs) const\n    {\n        return nega == rhs.nega && val == rhs.val;\n    }\n    bool operator!=(const BigInt &rhs) const { return nega != rhs.nega || val != rhs.val; }\n    bool operator>=(const BigInt &rhs) const { return !(*this < rhs); }\n    bool operator>(const BigInt &rhs) const { return !(*this <= rhs); }\n    bool operator<=(const BigInt &rhs) const\n    {\n        if (nega && !rhs.nega)\n            return true;\n        if (!nega && rhs.nega)\n            return false;\n        int cmp = absComp(*this, rhs);\n        return nega ? cmp >= 0 : cmp <= 0;\n    }\n    bool operator<(const BigInt &rhs) const\n    {\n        if (nega && !rhs.nega)\n            return true;\n        if (!nega && rhs.nega)\n            return false;\n        return (absComp(*this, rhs) < 0) ^ nega;\n    }\n    void swap(const BigInt &rhs) const\n    {\n        std::swap(val, rhs.val);\n        std::swap(nega, rhs.nega);\n    }\n};\nconst int N = 1e4 + 10;\nchar a[N], b[N];\nint main()\n{\n    scanf(\"%s%s\", a, b);\n    BigInt ba(a), bb(b);\n    std::cout << ba + bb << '\\n';\n    std::cout << ba - bb << '\\n';\n    std::cout << ba * bb << '\\n';\n    BigInt d;\n    std::cout << (d = ba / bb) << '\\n';\n    std::cout << ba - d * bb << '\\n';\n    return 0;\n}\n```",
        "postTime": 1522160869,
        "uid": 68618,
        "name": "MashPlant",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "~~\u96be\u9053\u6211\u8c37\u8fd9\u4e48\u591a\u5927\u4f6c\u6ca1\u6709\u4eba\u77e5\u9053bc\u5417\uff1f~~\n\n\u81ea\u4ece\u849f\u84bb\u4e86\u89e3\u4e86bc\uff0c\u5c31\u50cf\u54e5\u4f26\u5e03\u53d1\u73b0\u65b0\u5927\u9646\uff0c\u8d76\u7d27\u5c31\u7528\u5b83\u6765\u6c34\u9ad8\u7cbe\u6a21\u677f\u9898\u4e86\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    char a[100000],b[100000],c[100000];\n    scanf(\"%s%s\",a,b);\n    sprintf(c,\"echo %s+%s | bc | tr '\\n' ' ' | tr '\\\\' ' ' | sed 's/ //g'\",a,b);\n    system(c);\n    cout<<endl;\n    sprintf(c,\"echo %s-%s | bc | tr '\\n' ' ' | tr '\\\\' ' ' | sed 's/ //g'\",a,b);\n    system(c);\n    cout<<endl;\n    sprintf(c,\"echo %s*%s | bc | tr '\\n' ' ' | tr '\\\\' ' ' | sed 's/ //g'\",a,b);\n    system(c);\n    cout<<endl;\n    sprintf(c,\"echo %s/%s | bc | tr '\\n' ' ' | tr '\\\\' ' ' | sed 's/ //g'\",a,b);\n    system(c);\n    cout<<endl;\n    sprintf(c,\"echo %s %% %s | bc | tr '\\n' ' ' | tr '\\\\' ' ' | sed 's/ //g'\",a,b);\n    system(c);\n    cout<<endl;\n    return 0;\n}\n```\n\n\u4f46\u662f\u8fd9\u4e2a\u505a\u6cd5\u6709\u4e00\u4e2a\u5f88\u5927\u7684\u7f3a\u9677\uff0c\u5c31\u662f\u4e0d\u80fd\u628a\u8ba1\u7b97\u7684\u7ed3\u679c\u7528\u4e00\u4e2a\u53d8\u91cf\uff08\u5b57\u7b26\u6570\u7ec4\uff09\u4fdd\u5b58\uff0c\u800c\u662f\u53ea\u80fd\u76f4\u63a5\u8f93\u51fa\u3002\u8fd9\u5c31\u76f4\u63a5\u5bfc\u81f4\u8fd9\u79cd\u505a\u6cd5\u53ea\u80fd\u6c34\u9ad8\u7cbe\u5ea6\u7684\u6a21\u677f\u9898\uff0c\u800c\u4e0d\u662f\u6a21\u677f\u7684\u9ad8\u7cbe\u5ea6\u9898\u662f\u5f88\u96be\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u7684\n\n\u867d\u7136\u6709\u8fd9\u4e2a\u5c40\u9650\uff0c\u4f46\u4e5f\u80fd\u8ba9C\u515a20\u884c\u5207\u6389\u9ad8\u7cbe\u5ea6\uff0c\u4eab\u53d7Python\u7684\u5feb\u611f\uff01\n\n\u5bf9\u4e86\uff0c\u5982\u679c\u6709\u54ea\u4e2a\u5927\u4f6c\u77e5\u9053\u5982\u4f55\u5c06\u9ad8\u7cbe\u5ea6\u7684\u8fd0\u7b97\u7ed3\u679c\u4fdd\u5b58\u4e0b\u6765\u9ebb\u70e6\u79c1\u4fe1\u6211\uff0c\u8c22\u8c22",
        "postTime": 1544257548,
        "uid": 149845,
        "name": "\u6211\u662fPG",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u697c\u4e0b\u7684\u9898\u89e3\u90fd\u5728\u5751\u6211\u5462\uff0c\u600e\u4e48\u4ea4\u4e0a\u53bb\u90fd40\u5206\uff1f\n\n\u6ca1\u529e\u6cd5\u81ea\u5df1\u5199\u4e00\u4e2a\u3002\n\n\u9ad8\u7cbe\u5ea6\u6a21\u677f\u53ea\u80fd\u5f9790\u5206TLE\uff0c\u901f\u5ea6\u592a\u6162\uff0c\u4ebf\u8fdb\u5236\u4f18\u5316\u8981\u5f00long long\u53cd\u800c\u66f4\u6162\uff0c\u53ea\u670980\u5206\u3002\n\n\u7b2c\u5341\u4e2a\u70b9\u6570\u636e\u4e0b\u4e0b\u6765\u53d1\u73b0\u9664\u6cd5\u8fc7\u4e8eslow\uff0c\u7528\u4e8610s\uff0c\u60f3\u4e2a\u529e\u6cd5\u4f18\u5316\u9664\u6cd5\uff1f\n\n\u53d1\u73b0while\u5faa\u73af\u4e2d\u4e00\u76f4\u5728\u505a\u9ad8\u7cbe\u5ea6\u51cf\u6cd5\uff0c\u8fd9\u6837\u4f1a\u4f7f\u6548\u7387\u53d8\u5f97\u5f02\u5e38\u4f4e\uff0c\u600e\u4e48\u529e\u5462\uff1f\n\n\u6211\u4eec\u7528\u500d\u589e\u6765\u51cf\u5c11\u9ad8\u7cbe\u5ea6\u51cf\u6cd5\u7684\u6b21\u6570\uff0c\u9884\u5904\u7406\u51falog2(1e)\u5185\u76842\u7684\u5e42\uff0c\u7136\u540e\u500d\u589e\u51fa\u89e3\u3002\n\n\u9644\u4ee3\u7801\uff1a\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cstdlib>\n#include<vector>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\ninline const int Get_Int() {\n    int num=0,bj=1;\n    char x=getchar();\n    while(x<'0'||x>'9') {\n        if(x=='-')bj=-1;\n        x=getchar();\n    }\n    while(x>='0'&&x<='9') {\n        num=num*10+x-'0';\n        x=getchar();\n    }\n    return num*bj;\n}\nstruct BigInteger {\n    static const int BASE=100000000; //\u9ad8\u8fdb\u5236\n    static const int WIDTH=8; //\u9ad8\u8fdb\u5236\u4f4d\u6570\n    vector<long long>s;\n    BigInteger() { //\u6784\u9020\u51fd\u6570\uff1a\u521d\u59cb\u8d4b0\n        *this=0;\n    }\n    BigInteger(const int& num) { // \u6784\u9020\u51fd\u6570\n        *this=num;\n    }\n    //\u8d4b\u503c\n    BigInteger operator = (int num) {\n        s.clear();\n        do {\n            s.push_back(num%BASE);\n            num/=BASE;\n        } while(num>0);\n        return *this;\n    }\n    BigInteger operator = (const string& str) {\n        s.clear();\n        int x,len=(str.length()-1)/WIDTH+1;\n        for(int i=0; i<len; i++) {\n            int end=str.length()-i*WIDTH;\n            int start=max(0,end-WIDTH);\n            sscanf(str.substr(start,end-start).c_str(),\"%lld\",&x);\n            s.push_back(x);\n        }\n        return *this;\n    }\n    //\u6bd4\u8f83\n    bool operator < (const BigInteger& b) {\n        if(s.size()<b.s.size())return true;\n        if(s.size()>b.s.size())return false;\n        for(int i=s.size()-1; i>=0; i--) {\n            if(s[i]<b.s[i])return true;\n            if(s[i]>b.s[i])return false;\n        }\n        return false;\n    }\n    bool operator >= (const BigInteger& b) {\n        return !(*this<b);\n    }\n    bool operator == (const BigInteger& b) {\n        if(s.size()!=b.s.size())return false;\n        for(int i=0; i<s.size(); i++)\n            if(s[i]!=b.s[i])return false;\n        return true;\n    }\n    //+\n    BigInteger operator + (const BigInteger& b) {\n        BigInteger c;\n        c.s.clear();\n        for(int i=0,g=0; ; i++) {\n            if(g==0&&i>=s.size()&&i>=b.s.size())break;\n            int x=g;\n            if(i<s.size())x+=s[i];\n            if(i<b.s.size())x+=b.s[i];\n            c.s.push_back(x%BASE);\n            g=x/BASE;\n        }\n        return c;\n    }\n    //-\n    BigInteger operator - (const BigInteger& b) {\n        BigInteger c;\n        c=*this;\n        for(int i=0; i<c.s.size(); i++) {\n            int tmp;\n            if(i>=b.s.size())tmp=0;\n            else tmp=b.s[i];\n            if(c.s[i]<tmp) {\n                c.s[i+1]-=1;\n                c.s[i]+=BASE;\n            }\n            c.s[i]-=tmp;\n        }\n        while(c.s.back()==0&&c.s.size()>1)c.s.pop_back();\n        return c;\n    }\n    void operator -= (const BigInteger& b) {\n        *this=*this-b;\n    }\n    //*\n    BigInteger operator * (const BigInteger& b) {\n        BigInteger c;\n        c.s.resize(s.size()+b.s.size());\n        for(int i=0; i<s.size(); i++)\n            for(int j=0; j<b.s.size(); j++)c.s[i+j]+=s[i]*b.s[j];\n        for(int i=0; i<c.s.size()-1; i++) {\n            c.s[i+1]+=c.s[i]/BASE;\n            c.s[i]%=BASE;\n        }\n        while(c.s.back()==0&&c.s.size()>1)c.s.pop_back();\n        return c;\n    }\n    friend istream& operator >> (istream& input,BigInteger& x) {\n        string s;\n        if(!(input>>s))return input;\n        x=s;\n        return input;\n    }\n    friend ostream& operator << (ostream& output,const BigInteger& x) {\n        output<<x.s.back();\n        for(int i=x.s.size()-2; i>=0; i--) {\n            char buf[20];\n            sprintf(buf,\"%08d\",x.s[i]);\n            for(int j=0; j<strlen(buf); j++)output<<buf[j];\n        }\n        return output;\n    }\n};\n// /\nBigInteger Copy(const BigInteger& b,int x) {\n    BigInteger t;\n    t.s.resize(b.s.size()+x);\n    for(int i=0; i<b.s.size(); i++)t.s[i+x]=b.s[i];\n    return t;\n}\nBigInteger Divide(const BigInteger& a,const BigInteger& b,BigInteger& mod) {\n    BigInteger c;\n    c.s.resize(a.s.size()-b.s.size()+1);\n    mod=a;\n    int Pow[(int)log2(BigInteger::BASE)+5];\n    Pow[0]=1;\n    for(int i=1; i<=log2(BigInteger::BASE); i++)Pow[i]=Pow[i-1]*2;\n    for(int i=c.s.size()-1; i>=0; i--) {\n        BigInteger t;\n        t=Copy(b,i);\n        for(int j=log2(BigInteger::BASE); j>=0; j--)\n            if(mod>=t*Pow[j]) {\n                c.s[i]+=Pow[j];\n                mod-=t*Pow[j];\n            }\n    }\n    while(c.s.back()==0&&c.s.size()>1)c.s.pop_back();\n    return c;\n}\nBigInteger a,b;\nint main() {\n    cin>>a>>b;\n    if(a<b)cout<<a+b<<endl<<'-'<<b-a<<endl<<a*b<<endl<<0<<endl<<a<<endl;\n    else {\n        BigInteger c,d;\n        c=Divide(a,b,d);\n        cout<<a+b<<endl<<a-b<<endl<<a*b<<endl<<c<<endl<<d<<endl;\n    } \n    return 0;\n}\n```\n\u7ba1\u7406\u5458\u7ed9\u8fc7\u5427\uff0c\u6bd5\u7adf\u8fd9\u662f\u552f\u4e00\u4e00\u4e2a\u771f\u6b63\u7684\u9898\u89e3\n",
        "postTime": 1501662348,
        "uid": 31877,
        "name": "BillYang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u53d1\u73b0\u5148\u524d\u6ca1\u6709\u4ec0\u4e48\u4eba\u53d1\u5728\u91cd\u8f7d\u8fd0\u7b97\u7b26\u7684\u89e3\u6cd5\uff0c\u4e8e\u662f\u8eab\u4e3a\u5fc3\u7cfb\u67d0\u8c37\u7684**\u5c0f\u849f\u84bb**\u6211\u51b3\u5b9a\u633a\u8eab\u800c\u51fa\u82b1\u4e86\u4e00\u4e0b\u5348\u8c03\u8bd5\u51fa\u8fd9\u4e48\u4e00\u4efd\u4ee3\u7801\u3002\n\n------------\n\n\u867d\u7136\u901f\u5ea6\u6bd4\u4e0d\u4e0a\u524d\u9762\u7684\u90a3\u4e9bC++\u548cPython\u5927\u4f6c\uff0c\u4f46\u6211\u8fd9\u662f\u4e00\u6761**\u91cd\u8f7d\u8fd0\u7b97\u7b26**\u4e4b\u540e\u7684**\u9ad8\u7cbe\u6a21\u677f**\uff0c\u800c\u4e14\u5176\u4e2d\u7684\u6ce8\u91ca\u4e5f\u5341\u5206\u8be6\u7ec6\u4f5c\u4e3a\u4e00\u4e2a\u521d\u5b66\u8005\u548c**\u7b2c\u4e00\u6b21\u53d1\u9898\u89e3**\u7684**\u5c0f\u849f\u84bb**\uff0c\u5e0c\u671b\u80fd\u5bf9\u770b\u8fd9\u7bc7\u9898\u89e3\u7684**\u795e\u7287**\u6709\u70b9\u5e2e\u52a9\n\n------------\n\n\u4e0d\u591a\u8bf4\u4e86\u4e0a\u4ee3\u7801\uff08**\u5728\u7f16\u8bd1\u5668\u4e0a\u670d\u7528\u6548\u679c\u66f4\u4f73**\uff09\uff1a\n------------\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\n\nstruct data{\n    int num[20110];     //\u6b64\u5904\u8303\u56f4\u8981\u5f00\u5230\u6570\u636e\u8303\u56f4\u7684\u4e24\u500d,\u56e0\u4e3a\u4e58\u6cd5\u65f6\u4f4d\u6570\u4f1a\u7ffb\u500d \n    int len;\n    char op;\n    data(){ memset(num,0,sizeof(num));  len = 1; op = '+';}\n};//\u6ce8\u610f\u5b58\u4e4b\u524d\u8981\u5012\u5e8f\u5904\u7406\u6700\u9ad8\u4f4d\u653e\u6700\u540e \nint max(int a,int b){\n    return (a > b) ? a : b;\n}\nbool operator > (data a,data b){//\u91cd\u8f7d\u4e86\u5927\u4e8e\u5224\u65ad\u7b26,\u4ee5\u7b26\u53f7\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57,\u4ee5\u957f\u5ea6\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57,\u4ee5\u7edd\u5bf9\u503c\u4e3a\u7b2c\u4e09\u5173\u952e\u5b57,\u6ce8\u610f\u7b26\u53f7 \n    if(a.op == '+' && b.op == '-')  return true;\n    if(a.op == '-' && b.op == '+')  return false;\n    if(a.len > b.len)               return true;\n    if(a.len < b.len)               return false;\n    if(a.op == '-' && b.op == '-')\n    {\n        for(int i = a.len;i >= 1;i --)\n            if(a.num[i] > b.num[i])         return false;\n            else if(a.num[i] < b.num[i])    return true;\n            else if(a.num[i] == b.num[i])   continue;\n    }\n    if(a.op == '+' && b.op == '+')\n    {\n        for(int i = a.len;i >= 1;i --)\n            if(a.num[i] > b.num[i])         return true;\n            else if(a.num[i] < b.num[i])    return false;\n            else if(a.num[i] == b.num[i])   continue;\n    }\n    return false;\n}\nbool operator < (data a,data b){//\u91cd\u8f7d\u4e86\u5c0f\u4e8e,\u539f\u7406\u540c\u4e0a \n    if(a.op == '+' && b.op == '-')  return false;\n    if(a.op == '-' && b.op == '+')  return true;\n    if(a.len > b.len)               return false;\n    if(a.len < b.len)               return true;\n    if(a.op == '-' && b.op == '-')\n    {\n        for(int i = a.len;i >= 1;i --)\n            if(a.num[i] > b.num[i])         return true;\n            else if(a.num[i] < b.num[i])    return false;\n            else if(a.num[i] == b.num[i])   continue;\n    }\n    if(a.op == '+' && b.op == '+')\n    {\n        for(int i = a.len;i >= 1;i --)\n            if(a.num[i] > b.num[i])         return false;\n            else if(a.num[i] < b.num[i])    return true;\n            else if(a.num[i] == b.num[i])   continue;\n    }\n    return false;\n}\nbool operator ==(data a,data b){//\u91cd\u8f7d\u4e86\u7b49\u4e8e,\u539f\u7406\u540c\u4e0a \n    if(a.len == b.len)\n    {\n        for(int i = a.len;i >= 1;i --)\n        {\n            if(a.num[i] != b.num[i])    return false;\n            else continue;\n        }\n        return true;\n    }\n    return false;\n}\ndata operator + (data a,data b){//\u6c42\u548c \n    data c;                             //c\u4e3a\u6240\u6c42\u7684\u548c \n    c.len = max(a.len,b.len);           //\u6b64\u5904\u53d6\u6700\u5927\u662f\u4e3a\u4e86\u4fdd\u8bc1\u4e24\u4e2a\u52a0\u6570\u4e2d\u7684\u6bcf\u4e00\u4f4d\u90fd\u88ab\u7b97\u5230 \n    for(int i = 1;i <= c.len;i ++)      //\u5148\u9884\u5904\u7406\u5f97\u5230\u672a\u8fdb\u4f4d\u7684\u7b54\u6848 \n        c.num[i] = a.num[i] + b.num[i]; \n    for(int i = 1;i <= c.len;i ++)      //\u4ee5\u4e0b\u4e3a\u8fdb\u4f4d\u5904\u7406,\u6ce8\u610f\u4ece\u6700\u4f4e\u4f4d\u5f00\u59cb\u626b\u63cf \n        if(c.num[i] >= 10)              //\u5982\u679c\u8fd9\u4f4d\u9884\u5904\u7406\u5f97\u5230\u7684\u7b54\u6848\u5927\u4e8e10\u5219\u9700\u8981\u8fdb\u4f4d \n        {\n            c.num[i + 1] += c.num[i] / 10;//\u8fdb\u4f4d,\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u9700\u8981\u4ece\u6700\u4f4e\u4f4d\u5f00\u59cb\u626b,\u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u4e00\u6b21\u6027\u8fdb\u4f4d\u5e72\u51c0 \n            c.num[i] %= 10;             //\u4fdd\u7559\u4e2a\u4f4d\u6570 \n            c.len = max(c.len,i + 1);   //\u6ce8\u610f:\u4fdd\u7559\u4e0b\u6765\u7684\u957f\u5ea6\u8981\u786e\u4fdd\u6700\u9ad8\u4f4d\u6709\u8fdb\u4f4d\u624d\u9700\u8981\u66f4\u6539\uff0c\u4e0d\u7136\u53ea\u9700\u8981\u7559\u4e0b\u4e24\u4e2a\u52a0\u6570\u4e2d\u7684\u6700\u5927\u957f\u5ea6\u5c31\u884c \n        }\n    return c;\n}\ndata operator - (data a,data b){//\u6c42\u5dee \n    data c,temp;                        //c\u4e3a\u6240\u6c42\u7684\u5dee,temp\u4e3a\u4ea4\u6362\u7684\u8fc7\u7a0b\u91cf \n    c.len = max(a.len,b.len);           //\u539f\u7406\u548c\u52a0\u6cd5\u4e00\u6837\uff0c\u4fdd\u8bc1\u6bcf\u4e00\u4f4d\u90fd\u7b97\u8fc7 \n    if(b > a)                           //\u5982\u679c\u51cf\u6570\u6bd4\u88ab\u51cf\u6570\u5927\u9700\u8981\u7279\u6b8a\u64cd\u4f5c \n    {\n        c.op = '-';                     //\u7ed9\u7b54\u6848\u4e0a\u4e2a\u8d1f\u53f7 \n        temp = a,a = b,b = temp;        //\u4ea4\u6362\u51cf\u6570\u548c\u88ab\u51cf\u6570\u4fdd\u8bc1\u8fd9\u65f6\u7684\u7b54\u6848\u5927\u4e8e\u7b49\u4e8e0 \n    }\n    for(int i = 1;i <= c.len;i ++)      //\u9884\u5904\u7406\u5f97\u5230\u521d\u59cb\u7b54\u6848 \n        c.num[i] = a.num[i] - b.num[i];\n    for(int i = 1;i <= c.len;i ++)      //\u4e00\u4e0b\u4e3a\u501f\u4f4d\u5904\u7406,\u540c\u6837\u4ece\u6700\u4f4e\u4f4d\u5f00\u59cb \n        if(c.num[i] < 0)                //\u5982\u679c\u9884\u5904\u7406\u5f97\u5230\u7684\u8fd9\u4e00\u4f4d\u7b54\u6848\u5c0f\u4e8e0 \n        {\n            c.num[i] += 10;             //\u501f\u4f4d \n            c.num[i + 1] -= 1;          //\u4e0a\u4e00\u4f4d\u51cf\u4e00 \n        }\n    return c;\n}\ndata operator * (data a,data b){//\u6c42\u79ef \n    data c;                             //c\u4e3a\u6240\u6c42\u7684\u79ef \n    c.len = a.len + b.len + 1;          //\u4ece\u5c0f\u5f00\u59cb\u627e\u4e00\u4e0b\u89c4\u5f8b\u4f1a\u53d1\u73b0\u4e24\u6570\u76f8\u4e58\u4f1a\u6709\u4ee5\u4e0b\u89c4\u5f8b\n/*\n                    a[3]        a[2]        a[1]\n*                               b[2]        b[1]\n--------------------------------------------------\n                a[3]b[1]  a[2]*b[1]   a[1]*b[1] \n+   a[3]b[2]    a[2]b[2]  a[1]*b[2]\n--------------------------------------------------\n    c[4]          c[3]      c[2]        c[1]\n\n###\u6b64\u65f6\u6211\u4eec\u6ce8\u610f\u5230\u4e00\u4e2a\u6570\u7684\u7b2ci\u4f4d\u548c\u53e6\u4e00\u4e2a\u6570\u7684\u7b2cj\u4f4d\u76f8\u4e58\u7684\u5230\u7684\u6570\u5e94\u8be5\u5728\u7b54\u6848\u7684\u7b2ci + j - 1\u4f4d\uff1b\n###\u800c\u4e14\u4e0d\u540c\u4e8e\u52a0\u51cf\u6cd5\u7684\u662f\u6b64\u65f6\u7684\u7b54\u6848\u662f\u901a\u8fc7\u4e8c\u7ef4\u679a\u4e3e\u5f97\u5230\u7684\u9700\u8981\u7528\u7d2f\u52a0 \n### \n*/ \n    for(int i = 1;i <= a.len;i++)       //\u6bcf\u4e00\u4f4d\u4f9d\u6b21\u679a\u4e3e \n        for(int j = 1;j <= b.len;j++)\n            c.num[i + j - 1] += a.num[i]*b.num[j];//\u7d2f\u52a0\u7684\u610f\u4e49\u5982\u4e0a\u6240\u793a \n    for (int i = 1;i <= c.len;i ++)     //\u548c\u52a0\u6cd5\u4e00\u6837\u9700\u8981\u8fdb\u4f4d\uff0c\u8981\u4e00\u6b21\u6027\u8fdb\u4f4d\u5e72\u51c0 \n    {\n        if(c.num[i] >= 10)\n        {\n            c.num[i + 1] += c.num[i] / 10;//\u8fdb\u4f4d\u7684\u503c\u4e0d\u96be\u7406\u89e3\u662f\u5f53\u524d\u4f4d\u9664\u4ee510\u4ee5\u540e\u5411\u4e0b\u53d6\u6574 \n            c.num[i] %= 10;             //\u4fdd\u7559\u5404\u4f4d \n            c.len = max(c.len,i + 1);   //\u610f\u4e49\u548c\u52a0\u6cd5\u4e00\u6837 \n        }\n    }\n    return c;\n}\ndata numcopy(data a,int l){//\u8f6c\u79fb\u503c\u7684\u51fd\u6570 \n    data b;\n    for (int i=1;i<=a.len;i++) b.num[i+l-1]=a.num[i];\n    b.len=a.len+l-1;\n    b.op = '+';\n    return b;\n}\ndata operator / (data a,data b){//\u6c42\u5546 \n    data c;\n    c.len = a.len - b.len + 1;\n    for(int i = c.len;i >= 1;i --)\n    {\n        data t = numcopy(b,i);          //\u5c06\u9664\u6570\u4e58\u4ee510\u7684(i - 1)\u6b21\u76f8\u5f53\u4e8e\u5728\u679a\u4e3e\u5546\u7684\u4f4d\u6570 \n        while(a > t || a == t)          //\u7531\u4e8e\u61d2\u5f97\u5199>= \u7684\u91cd\u8f7d\u5c31\u53ea\u597d\u8fd9\u6837\u4e0d\u538c\u5176\u70e6\u4e86 \n        {\n            c.num[i]++;                 //\u5546\u7684\u8fd9\u4e00\u4f4d\u52a0\u4e00 \n            if(a == t) \t break;\t\t\t//\u5982\u679c\u5269\u4e0b\u7684\u88ab\u9664\u6570\u5df2\u7ecf\u53ef\u4ee5\u88ab\u6574\u9664\u4e86\u5c31\u4e0d\u7528\u63a5\u7740\u64cd\u4f5c\u4e86        \n            a = a - t;\t\t\t\t\t//\u51cf\u53bb\u53ef\u4ee5\u4fdd\u5b58\u7684\u503c\n\t\t\twhile (a.len>0 && !a.num[a.len]) a.len--;         \n        }\n    }\n\twhile (c.len > 0 && !c.num[c.len]) c.len--;\n    return c;\n/*\n###\u9664\u6cd5\u7684\u6982\u5ff5\u76f8\u5bf9\u6bd4\u8f83\u62bd\u8c61\uff0c\u9700\u8981\u82b1\u70b9\u65f6\u95f4\u53bb\u7406\u89e3 \n*/\n}\ndata operator % (data a,data b){//\u6c42\u4f59,\u5927\u90e8\u5206\u548c\u9664\u6cd5\u6982\u5ff5\u4e00\u6837,\u6700\u540e\u7684\u8fd4\u56de\u503c\u53ea\u9700\u8981\u8fd4\u56de\u591a\u6b21\u51cf\u5b8c\u5269\u4e0b\u7684a\u5c31\u884c\u4e86 \n    for(int i = a.len - b.len + 1;i >= 1;i --)\n    {\n        data t = numcopy(b,i);\n        while(a > t || a == t)\n        {\n            if(a == t)    break;\n            a = a - t;\n            while (a.len>0&&!a.num[a.len]) a.len--;         \n        }\n    }\n    return a;\n}\ndata kkk(int b){//\u5c06\u4e00\u4e2a\u6574\u6570\u7c7b\u578b\u8f6c\u5316\u4e3adata\u7c7b\u578b\uff0c\u907f\u514d\u4e86\u91cd\u8f7d\u5f88\u591a\u4e0d\u540c\u7c7b\u578b\u95f4\u7684\u8fd0\u7b97\u7b26 \n    int t = 0;\n    data c;\n    while(b)\n    { \n        t ++;                           //\u6c42\u4f4d\u6570 \n        c.num[t] = b % 10;              //\u4fdd\u7559\u8fd9\u4e00\u4f4d\u7684\u6570 \n        b /= 10;                        //\u5220\u53bb\u8fd9\u4e00\u4f4d \n    }\n    c.len = t;\n    return c;\n}\ndata gcd(data x,data y){//\u9012\u5f52\u6c42\u6700\u5927\u516c\u7ea6\u6570 \n    if(y == kkk(0)) return x;\n    else return gcd(y,x % y);\n}\n//\u8fd0\u7b97\u7b26\u91cd\u8f7d \n\nvoid get_data(data &a,data &b){//\u5c06\u6570\u636e\u7528\u5b57\u7b26\u4e32\u8bfb\u5165,\u5e76\u5904\u7406\u6b63\u8d1f \n    string s1,s2;\n    cin >> s1 >> s2;\n    if(s1[0] == '-')    a.op = '-',s1.erase(0,1);\n    if(s2[0] == '-')    b.op = '-',s2.erase(0,1);\n    for(int i = 1;i <= s1.size();i ++)\n        a.num[i] = int(s1[s1.size() - i]) - '0';//\u6ce8\u610f\u8981\u5012\u5e8f\u50a8\u5b58\u6570\u5b57 \n    a.len = s1.size();\n    for(int i = 1;i <= s2.size();i ++)\n        b.num[i] = int(s2[s2.size() - i]) - '0';\n    b.len = s2.size();\n}\nvoid print(data c){\n    if(c.op == '-')printf(\"-\");\n    bool flag = false;\n    for(int i = c.len;i >= 1;i --)\n        if(c.num[i] != 0 || flag == true)\n        {\n            printf(\"%d\",c.num[i]);\n            flag = true;\n        }\n    if(flag == false)\n        printf(\"0\");\n    printf(\"\\n\"); \n}\n//\u521d\u59cb\u6570\u636e\u5904\u7406 \n\nint main(){\n//    freopen(\"1.in\",\"r\",stdin);\n    data a,b,c;\n    get_data(a,b);\n    c = a + b;\n    print(c); \n    c = a - b;\n    print(c);\n    c = a * b;\n    print(c);   \n    c = a / b;\n    print(c);   \n    c = a % b;\n    print(c); \n}\n```\n",
        "postTime": 1558010317,
        "uid": 129621,
        "name": "\u5fd8\u65e0\u7fa1\u673a",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u6b64\u7bc7\u9898\u89e3\u652f\u6301\u8d1f\u6570\u8bfb\u5165\u4e0e\u56db\u5219\u8fd0\u7b97\uff0c\u652f\u6301\u4fee\u6539\u538b\u4f4d\u4f4d\u6570\uff0c\u4e14\u65e0\u8bba\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662f\u7a7a\u95f4\u590d\u6742\u5ea6\u90fd\u5927\u5927\u4f18\u4e8e\u5176\u4ed6\u4ee3\u7801\uff0c\u76ee\u524d\u5438\u6c2760ms,2.22MB\u7a33\u5c45\u6700\u4f18\u89e3\u3002\n\n\u5bf9\u4e8e\u9664\u6cd5\u590d\u6742\u5ea6\u7684\u4f18\u5316\uff0c\u8fd0\u7528\u4e86\u500d\u589e\u7684\u601d\u60f3\uff0c\u4f7f\u7528\u500d\u589e\u51cf\u6cd5\u4ee3\u66ff\u9664\u6cd5\u3001\u666e\u901a\u51cf\u6cd5\uff0c\u914d\u5408\u538b\u4f4d\uff0c\u5927\u5927\u4f18\u5316\u4e86\u65f6\u7a7a\u6548\u7387\u3002\n\n\u4e58\u6cd5\u6211\u8bd5\u8fc7\u7c7b\u4f3c\u7684\u500d\u589e\u52a0\u6cd5\u5f62\u5f0f\uff0c\u4f46\u6548\u7387\u8fdc\u4e0d\u5982\u9010\u4f4d\u8ba1\u7b97\u3002\n\n\u53e6\u5916\uff0c\u6b64\u4efd\u4ee3\u7801\u7684\u9ad8\u7cbe\u4e58\u90e8\u5206\uff0c\u5438\u6c27812ms\u6c34\u8fc7FFT\uff0c\u6700\u6162\u7684\u70b9\u4ec5\u7528\u4e86276ms\n\n\u5e0c\u671b\u80fd\u5bf9\u5927\u5bb6\u6709\u6240\u5e2e\u52a9\n\n\u4ee5\u4e0b\u662f\u6a21\u677f\u2193\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAXN=1e5;\nconst int siz=8;\nconst long long MOD=1e8;//MOD=10^siz\n\nchar ch1[MAXN],ch2[MAXN];\nbool f1,f2,f;//0\u4e3a\u975e\u8d1f\uff0c1\u4e3a\u8d1f\nlong long n;\nlong long a[MAXN>>2],b[MAXN>>2],s[MAXN>>2];\nlong long cp[MAXN>>2],lt[MAXN>>2],wsd[MAXN>>2];\n\nvoid write(long long num[]);//\u8f93\u51fa\u9ad8\u7cbe\u5ea6\u6570\nvoid clear(long long num[]);//\u6570\u7ec4\u91cd\u7f6e\nvoid ry(long long num[]);//>>\u53f3\u79fb\u4e00\u4f4d\nvoid ly(long long num[]);//<<\u5de6\u79fb\u4e00\u4f4d\nvoid cpy(long long num1[],long long num2[]);//num1=num2\nint cmp(long long num1[],long long num2[]);//compare num1 and num2\nvoid pls(long long a[],long long b[]);//plus\u52a0\u6cd5\nvoid mnu(long long a[],long long b[]);//minus\u51cf\u6cd5\nvoid mul(long long a[],long long b[]);//multiply\u4e58\u6cd5\nvoid div(long long a[],long long b[]);//divided\u9664\u6cd5\n\nvoid write(long long num[])\n{\n\tif(f) putchar('-'),f=0;\n\tprintf(\"%lld\",num[num[0]]);\n\tfor(int i=num[0]-1;i;--i) printf(\"%08lld\",num[i]);\n\tputs(\"\");\n}\n\nvoid clear(long long num[])\n{\n\tfor(int i=num[0];i;--i) num[i]=0;\n\tnum[0]=1;\n}\n\nvoid ry(long long num[])\n{\n\tfor(int i=num[0];i;--i){\n\t\tif((num[i]&1)&&i>1) num[i-1]+=MOD;//\u5c061\u501f\u5230\u4e0b\u4e00\u4f4d\n\t\tnum[i]>>=1;\n\t}if(!num[num[0]]&&num[0]>1) --num[0];\n}\n\nvoid ly(long long num[])\n{\n\t++num[0];\n\tfor(int i=1;i<=num[0];++i){\n\t\tnum[i]<<=1;\n\t\tif(num[i-1]>=MOD) num[i-1]-=MOD,++num[i];//\u8fdb\u4f4d\uff0c\u6ce8\u610f\u540e\u6548\u6027\n\t}if(!num[num[0]]&&num[0]>1) --num[0];\n\treturn;\n}\n\nvoid cpy(long long num1[],long long num2[])\n{\n\tfor(int i=num1[0];i>num2[0];--i) num1[i]=0;\n\tfor(int i=0;i<=num2[0];++i) num1[i]=num2[i];\n}\n\nint cmp(long long num1[],long long num2[])\n{\n\tif(num1[0]>num2[0]) return 1;\n\tif(num1[0]<num2[0]) return -1;\n\tfor(int i=num1[0];i;--i){\n\t\tif(num1[i]>num2[i]) return 1;\n\t\tif(num1[i]<num2[i]) return -1;\n\t}return 0;\n}\n\nvoid init()\n{\n\tscanf(\"%s%s\",ch1,ch2);\n\tif(ch1[0]=='-') ch1[0]='0',f1=1;\n\tif(ch2[0]=='-') ch2[0]='0',f2=1;//\u7b26\u53f7\u5904\u7406\n\tint l1=strlen(ch1),l2=strlen(ch2);\n\tfor(int i=l1-1;i>=0;i-=siz){\n\t\tlong long pw=1;++a[0];\n\t\tfor(int j=i;j>i-siz&&j>=0;--j){\n\t\t\ta[a[0]]+=(ch1[j]^48)*pw;\n\t\t\tpw=(pw<<3)+(pw<<1);\n\t\t}\n\t}for(int i=l2-1;i>=0;i-=siz){\n\t\tlong long pw=1;++b[0];\n\t\tfor(int j=i;j>i-siz&&j>=0;--j){\n\t\t\tb[b[0]]+=(ch2[j]^48)*pw;\n\t\t\tpw=(pw<<3)+(pw<<1);\n\t\t}\n\t}return;//\u53cd\u5e8f\u8bfb\u5165\u5b58\u50a8\n}\n\nvoid pls(long long a[],long long b[])\n{\n\tif(f1^f2){\n\t\tif(f1) f1^=1,mnu(b,a),f1^=1;//a+b=b-(-a)\n\t\tif(f2) f2^=1,mnu(a,b),f2^=1;//a+b=a-(-b)\n\t\treturn;\n\t}if(f1&f2){\n\t\tf1=f2=0,f^=1,pls(a,b);//\u4e24\u4e2a\u8d1f\u6570\u7edd\u5bf9\u503c\u76f8\u52a0\uff0c\u7b26\u53f7\u4e3a\u8d1f\n\t\tf1=f2=1;return;\n\t}clear(s);\n\ts[0]=max(a[0],b[0])+1;\n\tfor(int i=1;i<=s[0];++i){\n\t\ts[i]+=a[i]+b[i];\n\t\tif(s[i]>=MOD) s[i]-=MOD,++s[i+1];//\u8fdb\u4f4d\n\t}if(!s[s[0]]&&s[0]>1) --s[0];\n\treturn;\n}\n\nvoid mnu(long long a[],long long b[])\n{\n\tif(f1^f2){\n\t\tif(f1) f1^=1,f^=1,pls(a,b);//a-b=-(-a+b)\n\t\tif(f2) f2^=1,pls(a,b);//a-b=a+(-b)\n\t\treturn;\n\t}if(f1&f2){\n\t\tf1=f2=0,mnu(b,a);//a-b=-b-(-a)\n\t\tf1=f2=1;return;\n\t}if(cmp(a,b)==-1) swap(a,b),f^=1;//\u7edd\u5bf9\u503c\u76f8\u51cf\uff0c\u7b26\u53f7\u4e0e\u7edd\u5bf9\u503c\u5927\u7684\u6570\u7b26\u53f7\u76f8\u540c\n\tclear(s);\n\ts[0]=max(a[0],b[0]);\n\tfor(int i=1;i<=s[0];++i){\n\t\ts[i]+=a[i]-b[i];\n\t\tif(s[i]<0) s[i]+=MOD,--s[i+1];//\u501f\u4f4d\n\t}while(!s[s[0]]&&s[0]>1) --s[0];\n\treturn;\n}\n\nvoid mul(long long a[],long long b[])//\u6a21\u62df\u7ad6\u5f0f\u4e58\u6cd5\n{\n\tif(f1^f2) f^=1;\n\tclear(s);\n\ts[0]=a[0]+b[0];\n\tfor(int i=1;i<=a[0];++i){\n\t\tfor(int j=1;j<=b[0];++j){\n\t\t\ts[i+j-1]+=a[i]*b[j];\n\t\t\tif(s[i+j-1]>=MOD) s[i+j]+=s[i+j-1]/MOD,s[i+j-1]%=MOD;//\u8fdb\u4f4d\n\t\t}\n\t}if(!s[s[0]]&&s[0]>1) --s[0];\n\treturn;\n}\n\nvoid div(long long a[],long long b[])\n{\n\tif(f1^f2) f^=1;\n\tclear(cp),cp[1]=1;clear(lt);\n\twhile(cmp(a,b)!=-1) ly(b),ly(cp);//\u5c06\u9664\u6570\u500d\u589e\u5230\u4e0d\u5c0f\u4e8e\u88ab\u9664\u6570\uff0c\u786e\u5b9a\u5546\u4e8c\u8fdb\u5236\u6700\u9ad8\u4f4d\n\twhile(cp[0]>1||cp[1]){\n\t\tif(cmp(a,b)!=-1){\n\t\t\tmnu(a,b),cpy(a,s);//a-=b\n\t\t\tpls(lt,cp),cpy(lt,s);//lt+=cp\n\t\t}ry(b),ry(cp);//b>>=1,cp>>=1\n\t}cpy(s,lt),cpy(lt,a);//s=lt,lt=a\uff0c\u6b64\u65f6\uff0cs\u662f\u5546\uff0clt\u662f\u4f59\u6570\n\treturn;\n}\n\nint main()\n{\n\tinit();\n\tclear(s);\n\tpls(a,b);\n\twrite(s);\n\tmnu(a,b);\n\twrite(s);\n\tmul(a,b);\n\twrite(s);\n\tdiv(a,b);\n\twrite(s);\n\twrite(lt);\n\treturn 0;\n}\n```",
        "postTime": 1523281949,
        "uid": 31293,
        "name": "Adove",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u9ad8\u7cbe\u5ea6\u96c6\u5408\u554a\n\n\u5148\u63a8\u6211\u7684[blog](https://www.luogu.com.cn/blog/fzj2007/)\n\n\u7136\u540e\u7b80\u5355\u8bb2\u89e3\u4e00\u4e0b\u538b\u4f4d\u5b58\u50a8\u9ad8\u7cbe\u5ea6\n\n------------\n### (1) \u5b9a\u4e49\n```\nstatic const int MAX=10001;\nstruct hp{\n    int num[MAX];\n    \n    hp&operator=(const char*);\n    hp&operator=(int);\n    hp();\n    hp(int);\n    //\u4ee5\u4e0b\u8fd0\u7b97\u7b26\u6839\u636e\u9700\u8981\u5b9a\u4e49\u3002\u3002\n    bool operator>(const hp&)const;\n    bool operator<(const hp&)const;\n    bool operator<=(const hp&)const;\n    bool operator>=(const hp&)const;\n    bool operator!=(const hp&)const;\n    bool operator==(const hp&)const;\n    hp operator+(const hp&)const;\n    hp operator-(const hp&)const;\n    hp operator*(const hp&)const;\n    hp operator/(const hp&)const;\n    hp operator%(const hp&)const;\n    \n    hp&operator+=(const hp&);\n    hp&operator-=(const hp&);\n    hp&operator*=(const hp&);\n    hp&operator/=(const hp&);\n    hp&operator%=(const hp&);\n};\n```\nTHEN \n### (2) \u8d4b\u503c\u548c\u521d\u59cb\u5316\n```\n// num[0]\u7528\u6765\u4fdd\u5b58\u6570\u5b57\u4f4d\u6570\u3002\u5229\u752810000\u8fdb\u5236\u53ef\u4ee5\u8282\u7701\u7a7a\u95f4\u548c\u65f6\u95f4\u3002\nhp&hp::operator=(const char* c){\n    memset(num,0,sizeof(num));\n    int n=strlen(c),j=1,k=1;\n    for(int i=1;i<=n;i++){\n        if(k==10000) j++,k=1;// 10000\u8fdb\u5236\uff0c4\u4e2a\u6570\u5b57\u624d\u7b971\u4f4d\u3002\n        num[j]+=k*(c[n-i]-'0');\n        k*=10;\n    }\n    num[0]=j;\n    return *this;\n}\n\nhp&hp::operator=(int a){\n    char s[MAX];\n    sprintf(s,\"%d\",a);\n    return *this=s;\n}\nhp::hp(){\n\tmemset(num,0,sizeof(num)); \n\tnum[0]=1;\n}\nhp::hp(int n){\n\t*this=n;\n}// \u76ee\u7684\uff1a\u652f\u6301\u201chp a=1;\u201d\u4e4b\u7c7b\u7684\u4ee3\u7801\u3002\n```\nANE THE THIRD:\n### (3) \u6bd4\u8f83\u8fd0\u7b97\u7b26\n```\n// \u5982\u679c\u4f4d\u6570\u4e0d\u7b49\uff0c\u5927\u5c0f\u662f\u53ef\u4ee5\u660e\u663e\u770b\u51fa\u6765\u7684\u3002\u5982\u679c\u4f4d\u6570\u76f8\u7b49\uff0c\u5c31\u9700\u8981\u9010\u4f4d\u6bd4\u8f83\u3002\nbool hp::operator > (const hp &b) const{\n    if(num[0]!=b.num[0]) return num[0]>b.num[0];\n    for(int i=num[0];i>=1;i--)\n        if(num[i]!=b.num[i])\n            return (num[i]>b.num[i]);\n    return false;\n}\n//\u987a\u624b\u5b9a\u4e49\u4e86\uff0c\u8f83\u597d\u7406\u89e3\uff0c\u4ed4\u7ec6\u770b\u4e00\u4e0b\nbool hp::operator<(const hp &b)const{return b>*this;}\nbool hp::operator<=(const hp &b)const{return !(*this>b);}\nbool hp::operator>=(const hp &b)const{return !(b>*this);}\nbool hp::operator!=(const hp &b)const{return (b>*this)||(*this>b);}\nbool hp::operator==(const hp &b)const{return !(b>*this)&&!(*this>b);}\n```\n\u5269\u4e0b\u7684\uff1a\n### (4) \u56db\u5219\u8fd0\u7b97\n### (5) \u8f93\u5165/\u8f93\u51fa\n\u8bf7\u53c2\u89c1\n### [here](https://www.luogu.com.cn/blog/fzj2007/solution-p1096)\n\u6216\n### [here](https://www.luogu.com.cn/blog/fzj2007/solution-p1601)\n\u987a\u4fbf\u63a8\u8350**P1096**\u548cP**1061**\n\n\n------------\n\u6700\u540e\u8d34\u4e0a~~\u5b8c\u7f8e~~\uff08chou lou\uff09\u7684\u4ee3\u7801\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=10001;\nstruct hp{\n    int num[MAX];\n    \n    hp&operator=(const char*);\n    hp&operator=(int);\n    hp();\n    hp(int);\n    \n    bool operator>(const hp&)const;\n    bool operator<(const hp&)const;\n    bool operator<=(const hp&)const;\n    bool operator>=(const hp&)const;\n    bool operator!=(const hp&)const;\n    bool operator==(const hp&)const;\n\n    hp operator+(const hp&)const;\n    hp operator-(const hp&)const;\n    hp operator*(const hp&)const;\n    hp operator/(const hp&)const;\n    hp operator%(const hp&)const;\n    \n    hp&operator+=(const hp&);\n    hp&operator-=(const hp&);\n    hp&operator*=(const hp&);\n    hp&operator/=(const hp&);\n    hp&operator%=(const hp&);\n};\n// num[0]\u7528\u6765\u4fdd\u5b58\u6570\u5b57\u4f4d\u6570\u3002\u5229\u752810000\u8fdb\u5236\u53ef\u4ee5\u8282\u7701\u7a7a\u95f4\u548c\u65f6\u95f4\u3002\nhp&hp::operator=(const char* c){\n    memset(num,0,sizeof(num));\n    int n=strlen(c),j=1,k=1;\n    for(int i=1;i<=n;i++){\n        if(k==10000) j++,k=1;// 10000\u8fdb\u5236\uff0c4\u4e2a\u6570\u5b57\u624d\u7b971\u4f4d\u3002\n        num[j]+=k*(c[n-i]-'0');\n        k*=10;\n    }\n    num[0]=j;\n    return *this;\n}\n\nhp&hp::operator=(int a){\n    char s[MAX];\n    sprintf(s,\"%d\",a);\n    return *this=s;\n}\nhp::hp(){\n\tmemset(num,0,sizeof(num)); \n\tnum[0]=1;\n}\nhp::hp(int n){\n\t*this=n;\n}// \u76ee\u7684\uff1a\u652f\u6301\u201chp a=1;\u201d\u4e4b\u7c7b\u7684\u4ee3\u7801\u3002\n\n// \u5982\u679c\u4f4d\u6570\u4e0d\u7b49\uff0c\u5927\u5c0f\u662f\u53ef\u4ee5\u660e\u663e\u770b\u51fa\u6765\u7684\u3002\u5982\u679c\u4f4d\u6570\u76f8\u7b49\uff0c\u5c31\u9700\u8981\u9010\u4f4d\u6bd4\u8f83\u3002\nbool hp::operator > (const hp &b) const{\n    if(num[0]!=b.num[0]) return num[0]>b.num[0];\n    for(int i=num[0];i>=1;i--)\n        if(num[i]!=b.num[i])\n            return (num[i]>b.num[i]);\n    return false;\n}\nbool hp::operator<(const hp &b)const{return b>*this;}\nbool hp::operator<=(const hp &b)const{return !(*this>b);}\nbool hp::operator>=(const hp &b)const{return !(b>*this);}\nbool hp::operator!=(const hp &b)const{return (b>*this)||(*this>b);}\nbool hp::operator==(const hp &b)const{return !(b>*this)&&!(*this>b);}\n// \u6ce8\u610f\uff1a\u6700\u9ad8\u4f4d\u7684\u4f4d\u7f6e\u548c\u4f4d\u6570\u8981\u5339\u914d\u3002\n//\u52a0\u6cd5 \nhp hp::operator+(const hp&b)const{\n    hp c;\n    c.num[0]=max(num[0],b.num[0]);\n    for(int i=1;i<=c.num[0];i++){\n        c.num[i]+=num[i]+b.num[i];\n        if(c.num[i]>=10000){// \u8fdb\u4f4d\n            c.num[i]-=10000;\n            c.num[i+1]++;\n        }\n    }\n    if(c.num[c.num[0]+1]>0) c.num[0]++;// 9999+1\uff0c\u8ba1\u7b97\u5b8c\u6210\u540e\u591a\u4e86\u4e00\u4f4d\n    return c;\n}\n//\u51cf\u6cd5 \nhp hp::operator-(const hp&b)const{\n   hp c;\n   c.num[0]=num[0];\n   for (int i=1;i<=c.num[0];i++){\n       c.num[i]+=num[i]-b.num[i];\n       if(c.num[i]<0){  // \u9000\u4f4d\n            c.num[i]+=10000;\n            c.num[i+1]--;\n        }\n    }\n    while(c.num[c.num[0]]==0&&c.num[0]>1) c.num[0]--;// 100000000-99999999\n    return c;\n}\n//\u987a\u4fbf\u58f0\u660e \nhp&hp::operator+=(const hp &b){return *this=*this+b;}\nhp&hp::operator-=(const hp &b){return *this=*this-b;}\n//\u4e58\u6cd5 \nhp hp::operator*(const hp&b)const{\n    hp c;\n    c.num[0]=num[0]+b.num[0]+1;\n    for(int i=1;i<=num[0];i++){\n        for(int j=1;j<=b.num[0];j++){\n            c.num[i+j-1]+=num[i]*b.num[j];            // \u548c\u5c0f\u5b66\u7ad6\u5f0f\u7684\u7b97\u6cd5\u4e00\u6a21\u4e00\u6837\n            c.num[i+j]+=c.num[i+j-1]/10000;            // \u8fdb\u4f4d\n            c.num[i+j-1]%=10000;\n        }\n    }\n    while(c.num[c.num[0]]==0&&c.num[0]>1) c.num[0]--;    // 99999999*0\n    return c;\n}\n//\u540c\u4e0a \nhp&hp::operator*=(const hp &b){return *this=*this*b;}\nhp hp::operator/(const hp&b)const{\n    hp c, d;\n    c.num[0]=num[0]+b.num[0]+1;\n    d.num[0]=0;\n    for(int i=num[0];i>=1;i--){\n        // \u4ee5\u4e0b\u4e09\u884c\u7684\u542b\u4e49\u662f\uff1ad=d*10000+num[i];\n        memmove(d.num+2, d.num+1, sizeof(d.num)-sizeof(int)*2);\n        d.num[0]++;\n        d.num[1]=num[i];\n\n        // \u4ee5\u4e0b\u5faa\u73af\u7684\u542b\u4e49\u662f\uff1ac.num[i]=d/b; d%=b; \u5229\u7528\u4e8c\u5206\u67e5\u627e\u6c42c.num[i]\u7684\u4e0a\u754c\u3002\n        // \u6ce8\u610f\uff0c\u8fd9\u91cc\u662f\u4e8c\u5206\u4f18\u5316\u540e\u9664\u6cd5\u548c\u6734\u7d20\u9664\u6cd5\u7684\u533a\u522b\uff01\n        int left=0,right=9999,mid;\n        while(left<right){\n            mid = (left+right)/2;\n            if(b*hp(mid)<=d) left=mid+1;\n            else right=mid;\n        }\n        c.num[i]=right-1;\n        d=d-b*hp(right-1);\n    }\n    while(c.num[c.num[0]]==0&&c.num[0]>1) c.num[0]--;    // 99999999/99999999\n    return c;            \n}\nhp hp::operator%(const hp&b)const{\n    hp c, d;\n    c.num[0]=num[0]+b.num[0]+1;\n    d.num[0]=0;\n    for(int i=num[0];i>=1;i--){\n        // \u4ee5\u4e0b\u4e09\u884c\u7684\u542b\u4e49\u662f\uff1ad=d*10000+num[i];\n        memmove(d.num+2, d.num+1, sizeof(d.num)-sizeof(int)*2);\n        d.num[0]++;\n        d.num[1]=num[i];\n\n        // \u4ee5\u4e0b\u5faa\u73af\u7684\u542b\u4e49\u662f\uff1ac.num[i]=d/b; d%=b; \u5229\u7528\u4e8c\u5206\u67e5\u627e\u6c42c.num[i]\u7684\u4e0a\u754c\u3002\n        // \u6ce8\u610f\uff0c\u8fd9\u91cc\u662f\u4e8c\u5206\u4f18\u5316\u540e\u9664\u6cd5\u548c\u6734\u7d20\u9664\u6cd5\u7684\u533a\u522b\uff01\n        int left=0,right=9999,mid;\n        while(left<right){\n            mid = (left+right)/2;\n            if(b*hp(mid)<=d) left=mid+1;\n            else right=mid;\n        }\n        c.num[i]=right-1;\n        d=d-b*hp(right-1);\n    }\n    while(c.num[c.num[0]]==0&&c.num[0]>1) c.num[0]--;    // 99999999/99999999\n    return d;            \n}\nhp&hp::operator/=(const hp &b){return *this=*this/b;}\nhp&hp::operator%=(const hp &b){return *this=*this%b;}\nostream&operator<<(ostream &o,hp &n){\n    o<<n.num[n.num[0]];\n    for(int i=n.num[0]-1;i>=1;i--){\n        o.width(4);\n        o.fill('0');\n        o<<n.num[i];\n    }\n    return o;\n}\nistream & operator>>(istream &in, hp &n){\n    char s[MAX];\n    in>>s;\n    n=s;\n    return in;\n}\ninline int read(){\n\tint ans=0,flag=1;\n\tchar ch=getchar();\n\twhile((ch>'9'||ch<'0')&&ch!='-') ch=getchar();\n\tif(ch=='-') flag=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9'){\n\t\tans=ans*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn ans*flag;\n}\nhp a,b,c,d,e,f,g; \nint main(){\n\tcin>>a>>b;\n\tc=a+b;\n\tcout<<c<<endl; \n\tif(a>=b){\n\t\td=a-b;\n\t\tcout<<d<<endl;\t\n\t}else{\n\t\td=b-a;\n\t\tcout<<\"-\"<<d<<endl;\t\n\t}\n\te=a*b;\n\tf=a/b;\n\tg=a%b;\n\tcout<<e<<endl<<f<<endl<<g<<endl;\n\treturn 0;\n}\n\n  \n```\n\u6709\u5e2e\u52a9\u7684\uff0c\u8bb0\u5f97\u70b9\u4e2a\u8d5e\n",
        "postTime": 1575380345,
        "uid": 172370,
        "name": "fzj2007",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "BIGNUM\u5927\u6574\u6570\u578b\u538b\u4f4d\uff08\u53ef\u4fee\u6539\u538b\u4f4d\u6570\u53ca\u6700\u5927\u6570\u5b57\u957f\u5ea6\uff09\n\n\u9664\u6cd5\u7528\u4e86\u500d\u589e\u4f18\u5316\n\n\u538b\u5230\u516b\u4f4d\u7684\u65f6\u5019\u5e94\u628a\u6574\u578b\u6570\u7ec4\u5f00\u6210long long\n\n\u56e0\u4e3a\u516b\u4f4d\u7684\u65f6\u5019\u8fdb\u884c\u5927\u6574\u6570\u76f8\u4e58\u65f6\u4f1a\u7206\u6389int\n\n\u5f00\u4e86long long\u538b\u516b\u4f4d\u4e4b\u540e\uff0c\u76f8\u6bd4\u4e8e\u5f00int\u538b\u56db\u4f4d\uff0c\u7a7a\u95f4\u6ca1\u6709\u4f18\u5316\n\n\u4f46\u662f\u5374\u53ef\u4ee5\u63d0\u9ad8\u7b97\u6cd5\u7684\u65f6\u95f4\u6548\u7387\n\n\u8fd8\u6709\u4e00\u79cd\u4e0d\u5927\u5e38\u89c4\u4f46\u662f\u6548\u679c\u5f88\u663e\u8457\u7684\u4f18\u5316\uff1a\n\n\u5f00\u4e86long long\u540e\u6700\u591a\u53ef\u4ee5\u538b\u4f4d\u538b\u52309\u4f4d\n\n\u6bd4long long\u538b8\u4f4d\u548cint\u538b4\u4f4d\u90fd\u8981\u5feb\uff0c\u6d88\u8017\u7684\u5185\u5b58\u5c11.\n\n\u5404\u79cd\u91cd\u8f7d\u8fd0\u7b97\u7b26\uff08+\u3001-\u3001*\u3001/\u3001%\u3001>>\u3001<<\uff09\n\n\u5199\u8d77\u6765\u6709\u70b9\u7e41\u7410~~\uff08200\u884c\u597d\u5413\u4eba\uff09~~\u4f46\u7528\u8d77\u6765\u5f88\u7b80\u4fbf\n\n\n------------\n\u867d\u7136\u6709\u4eba\u5199\u8fc7\u91cd\u8f7d\u8fd0\u7b97\u7b26\u4e86\uff0c\u4f46\u662f\u5e76\u6ca1\u6709\u91cd\u8f7d/\n\n\u8fd9\u4e2aBIGNUM\u5927\u6574\u6570\u578b\u5c01\u88c5\u7684\u5f88\u5b8c\u7f8e\uff0c\u65e2\u6709\u538b\u4f4d\uff089\u4f4d\u800c\u4e14\u53ef\u4ee5\u4fee\u6539\uff09\uff0c\u53c8\u6709\u500d\u589e\u4f18\u5316\u7684\u9ad8\u7cbe\u5ea6\u9664\u6cd5\n\n\u6c42\u901a\u8fc7\n\n------------\n\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n\nstatic const int LEN = 10000 + 1;\n\nstruct BIGNUM {\n\t//\u4e0d\u5b9a\u4e49\u6210\u5168\u5c40\u5e38\u91cf\uff0c\u65b9\u4fbf\u79fb\u690dBIGNUM\u7c7b\n\tstatic const int BIT = 9;//\u538b\u4f4d\u4f4d\u6570\n\tstatic const int MOD = 1000000000;//1eBIT \n\t\n\tlong long s[LEN];\n\tbool flag;//\u8d1f\u6570\u7684\u8bddflag\u4e3afalse\n\tBIGNUM() {\n\t\tmemset(s, 0, sizeof(s));\n\t\tflag = s[0] = 1;\n\t}\n\tvoid init() {\n\t\tmemset(s, 0, sizeof(s));\n\t\ts[0] = 1;\n\t}\n\t\n    //\u538b\u4f4d\u7684\u7279\u6b8a\u5904\u7406\n    //\u4ece\u540e\u5411\u524d\u6bcfBIT\u4e2a\u6570\u5b57\u653e\u5728\u4e00\u7ec4\n\tBIGNUM operator = (const char *num) {\n\t\tint l = strlen(num);\n\t\ts[0] = 0;\n\t\tfor(int i = l - 1; i >= 0; i -= BIT) {\n\t\t\t++s[0];\n\t\t\tlong long w = 1;\n\t\t\tfor(int j = i; j > i - BIT && j >= 0; j--) {\n\t\t\t\ts[s[0]] += (num[j] ^ 48) * w;\n\t\t\t\tw = (w << 1) + (w << 3); \n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n\tBIGNUM operator = (const int num) {\n\t\tchar a[LEN];\n\t\tsprintf(a, \"%d\", num);\n\t\t*this = a;\n\t\treturn *this;\n\t}\n\tBIGNUM(int num) { *this = num; }\n\tBIGNUM(const char *num) { *this = num; }\n\t\n\tBIGNUM operator + (const BIGNUM &a) {\n\t\tBIGNUM c;\n\t\tint x = 0;\n\t\tc.s[0] = max(a.s[0], s[0]) + 1;\n\t\tfor(int i = 1; i <= c.s[0]; i++) {\n\t\t\tc.s[i] = a.s[i] + s[i] + x;\n            //\u538b\u4f4d\u5176\u5b9e\u5c31\u662f\u628a/10\u53d8\u6210\u4e86/MOD\n            //%10\u53d8\u6210\u4e86%MOD\n\t\t\tx = c.s[i] / MOD;\n\t\t\tc.s[i] %= MOD;\n\t\t}\n\t\twhile(c.s[c.s[0]] == 0 && c.s[0] > 1) c.s[0]--;\n\t\treturn c;\n\t}\n\tBIGNUM operator += (const BIGNUM &a) {\n\t\t*this = *this + a;\n\t\treturn *this;\n\t}\n\t\n    //\u91cd\u8f7d\u903b\u8f91\u5173\u7cfb\u8fd0\u7b97\u7b26\n\tbool operator == (const BIGNUM &a) {\n\t\tint up = max(s[0], a.s[0]);\n\t\tfor(int i = 0; i < up; i++)\n\t\t\tif(s[up - i] != a.s[up - i]) return false;\n\t\treturn true;\n\t}\n\tbool operator > (const BIGNUM &a) {\n\t\tif(s[0] != a.s[0]) return s[0] > a.s[0];\n\t\tint up = max(s[0], a.s[0]);\n\t\tfor(int i = 0; i < up; i++)\n\t\t\tif(s[up - i] != a.s[up - i]) return s[up - i] > a.s[up - i];\n\t\treturn false;\n\t}\n\tbool operator < (const BIGNUM &a) {\n\t\tif(s[0] != a.s[0]) return s[0] < a.s[0];\n\t\tint up = max(s[0], a.s[0]);\n\t\tfor(int i = 0; i < up; i++)\n\t\t\tif(s[up - i] != a.s[up - i]) return s[up - i] < a.s[up - i];\n\t\treturn false;\n\t}\n\tbool operator >= (const BIGNUM &a) {\n\t\tif(*this > a || *this == a) return true;\n\t\treturn false;\n\t}\n\tbool operator <= (const BIGNUM &a) {\n\t\tif(*this < a || *this == a) return true;\n\t\treturn false;\n\t}\n\t\n\tBIGNUM operator - (const BIGNUM &a) {\n\t\tBIGNUM c;\n\t\tc.s[0] = max(a.s[0], s[0]) + 1;\n\t\tif(*this < a) c.flag = false;\n\t\tfor(int i = 1; i <= c.s[0]; i++) {\n\t\t\tif(c.flag) c.s[i] += s[i] - a.s[i];\n\t\t\telse c.s[i] += a.s[i] - s[i];\n\t\t\tif(c.s[i] < 0) {\n\t\t\t\tc.s[i] += MOD;\n\t\t\t\tc.s[i + 1]--;\n\t\t\t}\n\t\t}\n        //\u9664\u53bb\u591a\u4f59\u7684\u524d\u5bfc\u96f6\n\t\twhile(c.s[c.s[0]] == 0 && c.s[0] > 1) c.s[0]--;\n\t\treturn c;\n\t}\n\tBIGNUM operator -= (const BIGNUM &a) {\n\t\t*this = *this - a;\n\t\treturn *this;\n\t}\n\tBIGNUM operator * (const BIGNUM &a) {\n\t\tBIGNUM c;\n\t\tc.s[0] = s[0] + a.s[0];\n\t\tfor(int i = 1; i <= s[0]; i++) {\n\t\t\tint x = 0;\n\t\t\tfor(int j = 1; j <= a.s[0]; j++) {\n\t\t\t\tc.s[i + j - 1] += s[i] * a.s[j] + x;\n\t\t\t\tx = c.s[i + j - 1] / MOD;\n\t\t\t\tc.s[i + j - 1] %= MOD;\n\t\t\t}\n\t\t\tc.s[i + a.s[0]] = x;\n\t\t}\n\t\twhile(c.s[c.s[0]] > 0) c.s[0]++;\n\t\twhile(c.s[c.s[0]] == 0 && c.s[0] > 1) c.s[0]--;\n\t\treturn c;\n\t}\n\tBIGNUM operator *= (const BIGNUM &a) {\n\t\t*this = *this * a;\n\t\treturn *this;\n\t}\n\t\n    //\u91cd\u8f7d\u5de6\u79fb\u53f3\u79fb\u8fd0\u7b97\u7b26\n    //\u500d\u589e\u4f18\u5316\u51cf\u6cd5\u6a21\u62df\u7684\u9664\u6cd5\u65f6\u9700\u8981\u7528\n\tBIGNUM operator << (const int &num) {\n\t\ts[0]++;\n\t\tfor(int i = 1; i <= s[0]; i++) {\n\t\t\ts[i] <<= num;\n\t\t\tif(s[i - 1] >= MOD)\n\t\t\t\ts[i - 1] -= MOD, ++s[i];\n\t\t}\n\t\twhile(s[s[0]] == 0 && s[0] > 1) s[0]--;\n\t\treturn *this;\n\t}\n\tBIGNUM operator >> (const int &num) {\n\t\tfor(int i = s[0]; i >= 1; i--) {\n\t\t\tif((s[i] & 1) && i > 1) s[i - 1] += MOD;\n\t\t\ts[i] >>= num;\n\t\t}\n\t\twhile(s[s[0]] == 0 && s[0] > 1) s[0]--;\n\t\treturn *this;\n\t}\n\t\n\tBIGNUM operator / (const BIGNUM &k) {\n\t\tBIGNUM c = *this, tmp, lt, a;\n\t\ta = k;\n\t\ttmp.s[1] = 1;\n        //\u627e\u5230\u5c0f\u4e8e\u7b49\u4e8ec\u7684a\n        //\u4f7f\u7528\u500d\u589e\u4f18\u5316\uff0c\u6bcf\u6b21*2\n        //\u590d\u6742\u5ea6\u964d\u5230\u4e86log\n        //\u500d\u589e\u4f18\u5316\u697c\u4e0b\n        //\u660e\u6708\u306e\u536b\u2014\u2014AH \u5df2\u7ecf\u8bf4\u7684\u5f88\u8be6\u7ec6\u4e86\uff0c\u4e0d\u591a\u8bf4\n\t\twhile(c >= a) {\n\t\t\ta = a << 1;\n\t\t\ttmp = tmp << 1;\n\t\t}\n\t\twhile(tmp.s[0] > 1 || tmp.s[1]) {\n\t\t\tif(c >= a) {\n\t\t\t\tc -= a;\n\t\t\t\tlt += tmp;\n\t\t\t}\n\t\t\ta = a >> 1;\n\t\t\ttmp = tmp >> 1;\n\t\t}\n\t\tc = lt;//a\u4e3a\u5f53\u524d\u4f59\u6570\n\t\twhile(c.s[c.s[0]] == 0 && c.s[0] > 1) c.s[0]--;\n\t\tif(c.s[0] < 1) c.s[c.s[0] = 1] = 0;\n\t\treturn c;\n\t}\n\tBIGNUM operator /= (const BIGNUM &a) {\n\t\t*this = *this / a;\n\t\treturn *this;\n\t}\n    //\u867d\u7136\u505a\u9664\u6cd5\u7684\u65f6\u540c\u65f6\u6c42\u51fa\u4e86\u5546\u548c\u4f59\u6570\n    //\u4f46\u662f\u8fd4\u56de\u7684\u53ea\u662f\u5546\u7684\u503c\n    //\u6240\u4ee5\u8fd8\u8981\u91cd\u8f7d mod \u8fd0\u7b97\n\tBIGNUM operator % (const BIGNUM &a) {\n\t\tBIGNUM d = *this, c = *this / a;\n\t\tc *= a;\n\t\treturn d - c;\n\t}\n\tBIGNUM operator %= (const BIGNUM &a) {\n\t\t*this = *this % a;\n\t\treturn *this;\n\t}\n};\n\n//\u91cd\u8f7d\u8bfb\u5165\u8bfb\u51fa\nostream& operator << (ostream &out, const BIGNUM &a) {\n\tif(!a.flag) putchar('-');\n    //\u8bfb\u51fa\u65f6\u5148\u628a\u7b2c\u4e00\u7ec4BIT\u4f4d\u6570\u8f93\u51fa\n\t//\u4e4b\u540e\u7684\u6bcf\u4e00\u7ec4\u6570\u4e0d\u8db3BIT\u4f4d\u7684\u8981\u5728\u5de6\u8fb9\u8865\u96f6\n\tprintf(\"%d\", a.s[a.s[0]]);\n\tfor(int i = a.s[0] - 1; i >= 1; i--)\n\t\tprintf(\"%09d\", a.s[i]);\n\treturn out;\n}\nistream& operator >> (istream &in, BIGNUM &a) {\n\tchar str[LEN];\n\tin >> str;\n\ta = str;\n\treturn in;\n}\n\nBIGNUM a, b;\nint main() {\n\tcin >> a >> b;\n\tcout << a + b << endl;\n\tcout << a - b << endl;\n\tcout << a * b << endl;\n\tcout << a / b << endl;\n\tcout << a % b << endl;\n}\n```\n\u9644\u535a\u5ba2\u94fe\u63a5\uff1a\n[\u5185\u542b\u666e\u901a\u9ad8\u7cbe\u5ea6\uff0c\u538b\u4f4d\u9ad8\u7cbe\u5ea6\u548cBIGNUM\u5927\u6574\u6570\u578b](http://www.cnblogs.com/devilk-sjj/p/8992281.html)",
        "postTime": 1525526424,
        "uid": 24922,
        "name": "DEVILK",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u5199\u4e2a\u5927\u6574\u6570\u7c7b \u4f7f\u7528\u8d77\u6765\u5c31\u50cfint\u4e00\u6837\u65b9\u4fbf\n\n\u8be5\u5927\u6574\u6570\u7c7b\u5e26\u7b26\u53f7 \u4f7f\u7528\u6d41\u8f93\u5165\u8f93\u51fa \u4f7f\u7528std::vector\u5b58\u50a8\u6570\u636e \u4f7f\u7528std::stringstream\u89e3\u6790\u5b57\u7b26\u4e32 \u590d\u6742\u5ea6\u5e38\u6570\u7565\u5927\n\n\u5bf9\u4e8e\u672c\u9898 \u5176\u5b9e\u6ca1\u6709\u5fc5\u8981\u505a\u4e00\u6b21\u9664\u6cd5\u540e\u518d\u505a\u4e00\u6b21\u6a21\u8fd0\u7b97\uff08\u4f46\u662f\u6ca1\u6709TLE\uff09 \u6240\u4ee5\u53ef\u4ee5\u5c06 Bigint &div(Bigint &, Bigint, div\\_type = division); public\u6389\u5e76\u5728main\u4e2d\u76f4\u63a5\u8c03\u7528\u8be5\u63a5\u53e3\n\n\u622a\u81f3\u8be5\u9898\u89e3\u63d0\u4ea4\u65f6 \u672c\u9898\u6570\u636e\u8981\u6c42\u51cf\u6cd5\u8f93\u51fa\u7edd\u5bf9\u503c\uff08\u800c\u9898\u9762\u4e2d\u5e76\u672a\u8bf4\u660e\uff09 \u6240\u4ee5\u6211\u5728main\u51fd\u6570\u4e2d\u5bf9\u4e8e\u51cf\u6cd5\u52a0\u4e86\u4e2a\u5224\u65ad\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iomanip>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::istream;\nusing std::ostream;\nusing std::vector;\nusing std::string;\nusing std::stringstream;\nusing std::setfill;\nusing std::setw;\n\nclass Bigint\n{\npublic :\n    //constructor \n    Bigint(long long = 0);\n    Bigint(const string &);\n    Bigint(const char *str) { *this = string(str); }\n\n    //assignment operators\n    Bigint &operator=(long long num) { return *this = Bigint(num); }\n    Bigint &operator=(const string &str) { return *this = Bigint(str); }\n    Bigint &operator=(const char *str) { return *this = Bigint(str); }\n\n    //relatiional operators \n    bool operator<(const Bigint &obj) const { return cmp(obj) < 0; }\n    bool operator>(const Bigint &obj) const { return cmp(obj) > 0; }\n    bool operator<=(const Bigint &obj) const { return cmp(obj) <= 0; }\n    bool operator>=(const Bigint &obj) const { return cmp(obj) >= 0; }\n    bool operator==(const Bigint &obj) const { return cmp(obj) == 0; }\n    bool operator!=(const Bigint &obj) const { return cmp(obj) != 0; }\n\n    //arithmetic operators\n    Bigint operator+() const { return *this; }\n    Bigint operator-() const { return Bigint(-sign_, val_); }\n    Bigint operator+(const Bigint &) const;\n    Bigint operator-(const Bigint &) const;\n    Bigint operator*(const Bigint &) const;\n    Bigint operator/(const Bigint &) const;\n    Bigint operator%(const Bigint &) const;\n\n    //compound assignment operators\n    Bigint &operator+=(const Bigint &obj) { return *this = *this + obj; }\n    Bigint &operator-=(const Bigint &obj) { return *this = *this - obj; }\n    Bigint &operator*=(const Bigint &obj) { return *this = *this * obj; }\n    Bigint &operator/=(const Bigint &obj) { return *this = *this / obj; }\n    Bigint &operator%=(const Bigint &obj) { return *this = *this % obj; }\n\n    //increment and decrement operators\n    Bigint &operator++() { return *this += 1; }\n    Bigint &operator--() { return *this -= 1; }\n    Bigint operator++(int);\n    Bigint operator--(int);\n\n    //input and output\n    friend istream &operator>>(istream &, Bigint &);\n    friend ostream &operator<<(ostream &, const Bigint &);\n\nprotected :\n    enum div_type { division, remainder };\n    enum cmp_type { with_sign, without_sign };\n    static const int base_ = (int)1e4;\n    static const int width_ = 4;\n    Bigint(int s, const vector<int> &v) : sign_(s), val_(v) {}\n    int cmp(const Bigint &, cmp_type = with_sign) const;\n    Bigint &delZero();\n    Bigint &add(const Bigint &);\n    Bigint &sub(const Bigint &);\n    Bigint &mul(const Bigint &, const Bigint &);\n    Bigint &div(Bigint &, Bigint, div_type = division);\n\nprivate :\n    int sign_;\n    vector<int> val_;\n};\n\nint main()\n{\n    Bigint a, b;\n    cin >> a >> b;\n    cout << a + b << endl;\n    if (a > b) cout << a - b << endl;\n    else cout << b - a << endl;\n    cout << a * b << endl;\n    cout << a / b << endl;\n    cout << a % b << endl;\n    return 0;\n}\n\nBigint::Bigint(long long num) : sign_(0)\n{\n    if (num < 0) sign_ = -1, num = -num;\n    else if (num > 0) sign_ = 1;\n    do\n    {\n        val_.push_back(num % base_);\n        num /= base_;\n    } while (num);\n}\n\nBigint::Bigint(const string &str)\n{\n    sign_ = str[0] == '-' ? -1 : 1;\n    int be = str[0] == '-' ? 1 : 0, en = str.size();\n    while ((en -= width_) >= be)\n    {\n        stringstream ss(str.substr(en, width_));\n        int temp;\n        ss >> temp;\n        val_.push_back(temp);\n    }\n    if ((en += width_) > be)\n    {\n        stringstream ss(str.substr(be, en - be));\n        int temp;\n        ss >> temp;\n        val_.push_back(temp);\n    }\n    delZero();\n}\n\nBigint Bigint::operator+(const Bigint &obj) const\n{\n    if (sign_ * obj.sign_ == 1)\n    {\n        Bigint temp;\n        return cmp(obj, without_sign) >= 0 ? (temp = *this).add(obj) : (temp = obj).add(*this);\n    }\n    else if (sign_ * obj.sign_ == -1) return *this - -obj;\n    else return sign_ == 0 ? obj : *this;\n}\n\nBigint Bigint::operator-(const Bigint &obj) const\n{\n    if (sign_ * obj.sign_ == 1)\n    {\n        Bigint temp;\n        return cmp(obj, without_sign) >= 0 ? (temp = *this).sub(obj) : (temp = -obj).sub(*this);\n    }\n    else if (sign_ * obj.sign_ == -1) return *this + -obj;\n    else return sign_ == 0 ? -obj : *this;\n}\n\ninline Bigint Bigint::operator*(const Bigint &obj) const\n{\n    Bigint temp;\n    return (temp.sign_ = sign_ * obj.sign_) == 0 ? temp : temp.mul(*this, obj);\n}\n\ninline Bigint Bigint::operator/(const Bigint &obj) const\n{\n    Bigint temp, mod = *this;\n    return cmp(obj, without_sign) < 0 || (temp.sign_ = sign_ * obj.sign_) == 0 ? temp : temp.div(mod, obj);\n}\n\ninline Bigint Bigint::operator%(const Bigint &obj) const\n{\n    Bigint temp, mod = *this;\n    return cmp(obj, without_sign) < 0 || (temp.sign_ = sign_) == 0 ? mod : temp.div(mod, obj, remainder);\n}\n\ninline Bigint Bigint::operator++(int)\n{\n    Bigint temp = *this;\n    ++*this;\n    return temp;\n}\n\ninline Bigint Bigint::operator--(int)\n{\n    Bigint temp = *this;\n    --*this;\n    return temp;\n}\n\ninline istream &operator>>(istream &in, Bigint &obj)\n{\n    string str;\n    if (in >> str) obj = str;\n    return in;\n}\n\nostream &operator<<(ostream &out, const Bigint &obj)\n{\n    if (obj.sign_ == -1) cout << '-';\n    out << obj.val_.back();\n    for (int i = obj.val_.size() - 2; i >= 0; i--)\n        out << setw(Bigint::width_) << setfill('0') << obj.val_[i];\n    return out;\n}\n\nint Bigint::cmp(const Bigint &obj, cmp_type typ) const\n{\n    if (typ == with_sign && sign_ != obj.sign_) return sign_ - obj.sign_;\n    int sign = typ == with_sign ? sign_ : 1;\n    if (val_.size() != obj.val_.size()) return sign * (val_.size() - obj.val_.size());\n    for (int i = val_.size() - 1; i >= 0; i--)\n        if (val_[i] != obj.val_[i]) return sign * (val_[i] - obj.val_[i]);\n    return 0;\n}\n\ninline Bigint &Bigint::delZero()\n{\n    while(val_.back() == 0 && val_.size() > 1) val_.pop_back();\n    if (val_.back() == 0) sign_ = 0;\n    return *this;\n}\n\nBigint &Bigint::add(const Bigint &obj)\n{\n    int ts = val_.size(), os = obj.val_.size();\n    for (int i = 0; i < os; i++) val_[i] += obj.val_[i];\n    val_.push_back(0);\n    for (int i = 0; i < ts; i++)\n        if (val_[i] >= base_) val_[i] -= base_, ++val_[i + 1];\n    return delZero();\n}\n\nBigint &Bigint::sub(const Bigint &obj)\n{\n    int pos = obj.val_.size();\n    for (int i = 0; i < pos; i++)\n        if ((val_[i] -= obj.val_[i]) < 0) val_[i] += base_, --val_[i + 1];\n    while (val_[pos] < 0) val_[pos] += base_, --val_[++pos];\n    return delZero();\n}\n\nBigint &Bigint::mul(const Bigint &a, const Bigint &b)\n{\n    int as = a.val_.size(), bs = b.val_.size();\n    val_.resize(as + bs);\n    for (int i = 0; i < as; i++) for (int j = 0; j < bs; j++)\n    {\n        int x = i + j;\n        val_[x] += a.val_[i] * b.val_[j];\n        val_[x + 1] += val_[x] / base_;\n        val_[x] %= base_;\n    }\n    return delZero();   \n}\n\nBigint &Bigint::div(Bigint &a, Bigint b, div_type typ)\n{\n    int move = a.val_.size() - b.val_.size();\n    val_.resize(move + 1);\n    b.val_.insert(b.val_.begin(), move, 0);\n    for (int i = move; i >= 0; i--)\n    {\n        int left = 0, right = base_;\n        while (left + 1 < right)\n        {\n            int mid = (left + right) >> 1;\n            if (a.cmp(b * Bigint(mid), without_sign) >= 0) left = mid;\n            else right = mid;\n        }\n        val_[i] = left;\n        a.sub(b * Bigint(left));\n        b.val_.erase(b.val_.begin());\n    }\n    return typ == division ? delZero() : a;\n}\n```",
        "postTime": 1481817666,
        "uid": 6518,
        "name": "baqkqpfhv",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "\u81ea\u4ece\u6709\u4e86Python\uff0c\u8fd9\u8fdf\u65e9\u8981\u53d8\u7ea2\u9898\u2026\u2026\n\n\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u6b63\u7ecf\u5730\u7ec3\u4e60\u9ad8\u7cbe\u6a21\u677f\u7684\u62fc\u51d1\u2026\u2026\n\n```cpp\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<string>\n#include<cstring>\nusing namespace std;\nint a[10009],b[10009],c[20009],tmp[20009],flag,x;\nstring t,s1,s2;\nvoid print(int a[])//\u8f93\u51fa\n{\n    if(a[0]==0){printf(\"0\\n\");return;}\n    for(int i=a[0];i>0;i--){printf(\"%d\",a[i]);}\n    printf(\"\\n\");\n    return;\n}\nvoid clear(int a[])//\u5904\u7406\u9000\u4f4d\u60c5\u51b5\n{\n    while((a[a[0]]==0)&&(a[0]>0)){a[0]--;}\n    return;\n}\nvoid aplb(string a1,string b1)//a+b\n{\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    memset(c,0,sizeof(c));\n    a[0]=a1.size();for(int i=0;i<=a[0]-1;i++){a[a[0]-i]=a1[i]-48;}\n    b[0]=b1.size();for(int i=0;i<=b[0]-1;i++){b[b[0]-i]=b1[i]-48;}\n    c[0]=1,x=0;\n    while(c[0]<=a[0]||c[0]<=b[0])\n    {\n        c[c[0]]=a[c[0]]+b[c[0]]+x,\n        x=c[c[0]]/10,\n        c[c[0]]=c[c[0]]%10,\n        c[0]++;\n    }\n    c[c[0]]=x;\n    clear(c);\n    print(c);\n}\nvoid amib(string a1,string b1)//a-b\n{\n    if(a1.size()<b1.size())//\u5224\u65ad\u5f97\u6570\u6b63\u8d1f\n    {\n        cout<<\"-\";\n        t=a1,a1=b1,b1=t;//\u4fdd\u8bc1\u80fd\u51cf\u5c31\u8981\u6362\u8fc7\u6765\n    }\n    if(a1.size()==b1.size())\n    {\n        for(int i=0;i<a1.size();i++)\n        {\n            if(a1[i]>b1[i]){break;}\n            if(a1[i]<b1[i])\n            {\n                cout<<\"-\";\n                t=a1,a1=b1,b1=t;\n                break;\n            }\n        }\n    }\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    memset(c,0,sizeof(c));\n    a[0]=a1.size();for(int i=0;i<=a[0]-1;i++){a[a[0]-i]=a1[i]-48;}\n    b[0]=b1.size();for(int i=0;i<=b[0]-1;i++){b[b[0]-i]=b1[i]-48;}\n    for(int i=1;i<=a[0]||i<=b[0];i++)\n    {\n        if(a[i]<b[i])\n        {\n            a[i]=a[i]+10,\n            a[i+1]--;\n        }\n        c[i]=a[i]-b[i],\n        c[0]=i;\n    }\n    clear(c);\n    print(c);\n}\nvoid amlb(string a1,string b1)//\u4e58\u6cd5\n{\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    memset(c,0,sizeof(c));\n    if(a1==\"0\"||b1==\"0\"){printf(\"0\\n\");return;}//\u5fae\u5c0f\u7684\u4e0d\u5b58\u5728\u7684\u7279\u5224\n    a[0]=a1.size();for(int i=0;i<=a[0]-1;i++){a[a[0]-i]=a1[i]-48;}\n    b[0]=b1.size();for(int i=0;i<=b[0]-1;i++){b[b[0]-i]=b1[i]-48;}\n    for(int i=1;i<=a[0];i++)\n    {\n        for(int j=1;j<=b[0];j++)\n        {\n            c[i+j-1]=c[i+j-1]+a[i]*b[j];\n        }\n    }\n    c[0]=a[0]+b[0];\n    for(int i=1;i<=c[0];i++)\n    {\n        c[i+1]=c[i+1]+c[i]/10,\n        c[i]=c[i]%10;\n    }\n    clear(c);\n    print(c);\n}\nint compare(int a[],int b[])//\u6bd4\u5927\u5c0f\n{\n    if(a[0]>b[0]){return 1;}\n    if(a[0]<b[0]){return -1;}\n    for(int i=a[0];i>0;i--)\n    {\n        if(a[i]>b[i]){return 1;}\n        if(a[i]<b[i]){return -1;}\n    } \n    return 0;\n}\nvoid numcpy(int p[],int q[],int det)//\u795e\u5947\u7684\u51cf\u6cd5\n{\n    for(int i=1;i<=p[0];i++){q[i+det-1]=p[i];}\n    q[0]=p[0]+det-1;\n}\nvoid jian(int a[],int b[])//\u5224\u65ad\u591f\u4e0d\u591f\u51cf\n{ \n    flag=compare(a,b); \n    if(flag==0){a[0]=0;return;}\n    if(flag==1) \n    {\n        for(int i=1;i<=a[0];i++) \n        {\n            if(a[i]<b[i])\n            {\n```\na[i+1]--,\n```cpp\n                a[i]=a[i]+10;\n            }\n            a[i]=a[i]-b[i];\n        } \n        clear(a);\n        return;\n    } \n} \nvoid chugao(int a[],int b[],int c[])\n{\n    c[0]=a[0]-b[0]+1;\n    for(int i=c[0];i>0;i--)\n    {\n        memset(tmp,0,sizeof(tmp));\n        numcpy(b,tmp,i);\n        for(;compare(a,tmp)>=0;)\n        {\n            c[i]++;\n            jian(a,tmp);\n        }\n    }\n    clear(c);\n    return;\n}\nvoid adib(string a1,string b1)//\u9664\u6cd5\n{\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    memset(c,0,sizeof(c));\n    a[0]=a1.size();for(int i=1;i<=a[0];i++){a[i]=a1[a[0]-i]-48;}\n    b[0]=b1.size();for(int i=1;i<=b[0];i++){b[i]=b1[b[0]-i]-48;}\n    chugao(a,b,c);\n    if(a1.size()<b1.size()){printf(\"0\\n\");print(a);return;}//a<b\u4e5f\u9700\u8981\u7279\u5224\u4e00\u4e0b\n    if(a1.size()==b1.size())\n    {\n        for(int i=0;i<a1.size();i++)\n        {\n            if(a1[i]>b1[i]){break;}\n            if(a1[i]<b1[i]){printf(\"0\\n\");print(a);return;}\n        }\n    }\n    print(c);\n    print(a);\n    return;\n}\nint main()\n{\n    cin>>s1>>s2;\n    aplb(s1,s2);\n    amib(s1,s2);\n    amlb(s1,s2);\n    adib(s1,s2);\n}\n```",
        "postTime": 1509976550,
        "uid": 14378,
        "name": "doby",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "luogu\u597d\u50cf\u652f\u6301\u4e86`python`\u7684\u6837\u5b50\u3002\u3002`python`\u4f5c\u4e3a\u4e00\u4e2a\u81ea\u5e26\u9ad8\u7cbe\u7684\u8bed\u8a00\u3002\u3002emmmmmmm\n\n\u4ee5\u4e0b\u662f`python3`\u7684\u4ee3\u7801\uff0c\u9700\u8981\u6ce8\u610f\u7684\u4e00\u70b9\u5c31\u662f`input()`\u51fd\u6570\u4e00\u6b21\u8bfb\u5165\u4e00\u884c\uff0c\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u8981\u5148\u8f6c\u6210`int`\n\n``` python\na = int(input())\nb = int(input())\nprint(a + b)\nprint(a - b)\nprint(a * b)\nprint(a // b)\nprint(a % b)\n```",
        "postTime": 1508037806,
        "uid": 51529,
        "name": "Margatroid",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    },
    {
        "content": "python\u6c34\u9898\n\n\u4ee3\u7801\uff1a\n\n```python\na=int(input())\nb=int(input())\nprint(a+b)\nprint(a-b)\nprint(a*b)\nprint(a//b)\nprint(a-a//b*b)\n```",
        "postTime": 1508072299,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P1932 \u3010A+B  A-B  A*B  A/B A%B Problem\u3011"
    }
]