[
    {
        "content": "\u901a\u8fc7\u5e73\u8861\u6811\u6765\u7ef4\u62a4\u533a\u95f4\u64cd\u4f5c\u7684\u4e00\u9053\u6bd4\u8f83\u50cf\u6a21\u677f\u7684\u9898\u76ee\u3002\n\n\u770b\u89c1\u697c\u4e0a\u7684\u51e0\u4f4d\u5927\u4f6c\u7528\u7684\u90fd\u662fsplay\uff0c\u8865\u4e00\u53d1fhq_treap\u7684\u9898\u89e3\u597d\u4e86\u3002\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#define ls(x) t[x].ch[0]\n#define rs(x) t[x].ch[1]\nusing namespace std;\n\nstruct node{\n    int size,key,val,cx,add,tur,ch[2],maxn;\n}t[100010];\n//size:\u5b50\u6811\u5927\u5c0f key:\u968f\u673a\u751f\u6210\u7684key\u503c val:\u5f53\u524d\u4f4d\u7f6e\u7684\u503c cx:\u5728\u6570\u7ec4\u4e2d\u7684\u4f4d\u7f6e\uff08\u597d\u50cf\u540e\u9762\u6ca1\u7528\u5230\uff1f\uff09 add:\u52a0\u6cd5\u7684\u5ef6\u8fdf\u6807\u8bb0 tur:\u65cb\u8f6c\u7684\u5ef6\u8fdf\u6807\u8bb0 ch\uff1a\u5de6\u53f3\u513f\u5b50\uff08\u7528ls\uff08x\uff09\u4e0ers\uff08x\uff09\u8868\u793a\uff09 maxn:\u533a\u95f4\u7684\u6700\u5927\u503c \nint n,m,gs,rt;\nint seed=623; \nint com,l,r,zhi;\n\ninline int rand(){\n    return seed=(int)((seed*1000000007ll)%0x7fffffff);\n}\n//\u4ece\u4e0b\u5411\u4e0a\u63a8\u65f6\uff0c\u9700\u8981\u540c\u65f6\u66f4\u65b0\u4e24\u4e2a\u503c\uff1a\u6700\u5927\u503c\u4e0e\u5b50\u6811\u5927\u5c0f \ninline void push_up(int x){\n    t[x].size=t[ls(x)].size+t[rs(x)].size+1;\n    t[x].maxn=t[x].val;\n    //\u9632\u6b62\u5728\u6700\u5927\u503c\u4e3a\u8d1f\u503c\u65f6\u8bbf\u95ee\u5230\u7a7a\u8282\u70b9\uff08\u7a7a\u8282\u70b9\u5904\u6700\u5927\u503c\u4e3a0\uff09 \n    if(ls(x))t[x].maxn=max(t[x].maxn,t[ls(x)].maxn);\n    if(rs(x))t[x].maxn=max(t[x].maxn,t[rs(x)].maxn);\n}\n//\u5411\u4e0b\u63a8\u540c\u6837\u9700\u8981\u7ef4\u62a4\u4e24\u4e2a\u503c\uff1a\u52a0\u7684lazy\u6807\u8bb0\u4e0e\u65cb\u8f6c\u7684lazy\u6807\u8bb0 \ninline void push_down(int x){\n    if(t[x].tur){\n        if(ls(x))t[ls(x)].tur^=1;\n        if(rs(x))t[rs(x)].tur^=1;\n        ls(x)^=rs(x)^=ls(x)^=rs(x);\n        t[x].tur=0;\n    }\n    if(t[x].add){\n        if(ls(x)){//\u9632\u6b62\u7ed90\u8282\u70b9\u52a0\u4e0a\u5947\u5947\u602a\u602a\u7684\u503c \n            t[ls(x)].add+=t[x].add;\n            t[ls(x)].val+=t[x].add;\n            t[ls(x)].maxn+=t[x].add;\n        }\n        if(rs(x)){\n            t[rs(x)].add+=t[x].add;\n            t[rs(x)].val+=t[x].add;\n            t[rs(x)].maxn+=t[x].add;\n        }\n        t[x].add=0;\n        update(x);\n    }\n}\n//\u6b63\u5e38\u7684\u5206\u79bb/\u5408\u5e76 \nint merge(int x,int y){\n    int now;\n    push_down(x);push_down(y);\n    if(!x || !y)return x|y;\n    if(t[x].key<t[y].key){\n        now=x,rs(x)=merge(t[x].ch[1],y);\n    }\n    else now=y,ls(y)=merge(x,t[y].ch[0]);\n    push_up(now);\n    return now;\n}\n\nvoid split(int root,int bz,int &x,int &y){\n    if(!root){x=y=0;return;}\n    push_down(root);\n    if(t[ls(root)].size>=bz)y=root,split(ls(root),bz,x,ls(y));\n    else x=root,split(rs(root),bz-t[ls(root)].size-1,rs(x),y);\n    push_up(root);\n}\n\ninline void insert(int x){\n    t[++gs].key=rand();\n    t[gs].val=x;\n    t[gs].cx=gs;\n    t[gs].maxn=x;\n    t[gs].size=1;\n    rt=merge(rt,gs);\n}\n//\u5bf9l-r\u8fd9\u6bb5\u533a\u95f4\u8fdb\u884c\u64cd\u4f5c\u65f6\uff0c\u53ea\u9700\u8981\u5148\u628al-r\u8fd9\u6bb5\u533a\u95f4\u5355\u72ec\u5206\u79bb\u51fa\u6765\uff0c\u518d\u5728\u5206\u51fa\u6765\u7684\u533a\u95f4\u7684\u6839\u8282\u70b9\u4e0a\u52a0lazy\u6807\u8bb0\u5373\u53ef \ninline void update1(int l,int r,int zhi){\n    int x,y,z;\n    split(rt,l-1,x,y);\n    split(y,r-l+1,y,z);\n    t[y].maxn+=zhi;\n    t[y].add+=zhi;\n    t[y].val+=zhi;\n    rt=merge(merge(x,y),z);\n}\n\ninline void update2(int l,int r){\n    int x,y,z;\n    split(rt,l-1,x,y);\n    split(y,r-l+1,y,z);\n    t[y].tur^=1;\n    rt=merge(merge(x,y),z);\n}\n\ninline void query(int l,int r){\n    int x,y,z;\n    split(rt,l-1,x,y);\n    split(y,r-l+1,y,z);\n    printf(\"%d\\n\",t[y].maxn);\n    rt=merge(merge(x,y),z);\n}\n\nint main(){\n    scanf(\"%d %d\",&n,&m); \n    for(int i=1;i<=n;i++){\n        insert(0);\n    }\n    while(m--){\n        scanf(\"%d\",&com);\n        if(com==1){scanf(\"%d %d %d\",&l,&r,&zhi),update1(l,r,zhi);}\n        else if(com==2){scanf(\"%d %d\",&l,&r),update2(l,r);}\n        else if(com==3){scanf(\"%d %d\",&l,&r),query(l,r);}\n    }\n    return 0;\n}\n```",
        "postTime": 1535611051,
        "uid": 82611,
        "name": "PurpleWonder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "\u5e73\u8861\u6811\u3002\u64cd\u4f5c\u6d89\u53ca\u533a\u95f4\u52a0\u3001\u533a\u95f4\u53cd\u8f6c\u3001\u533a\u95f4\u6700\u5927\u503c\uff0c\u5982\u679c\u6ca1\u6709\u533a\u95f4\u53cd\u8f6c\u53ef\u4ee5\u76f4\u63a5\u65e0\u8111\u7ebf\u6bb5\u6811\uff0c\u4f46\u662f\u6709\u533a\u95f4\u53cd\u8f6c\uff0c\u8003\u8651\u5e73\u8861\u6811\uff0c\u6211\u8fd8\u662f\u5199\u4e86 $\\text{FHQ Treap}$\uff0c\u64cd\u4f5c\u90fd\u5f88\u65e0\u8111\uff0c\u4f46\u6709\u4e00\u4e2a\u6ce8\u610f\u70b9\uff0c\u5c31\u662f\u533a\u95f4\u64cd\u4f5c\u7684 $\\text{FHQ Treap}$ \u5728 $\\text{Split}$ \u7684\u65f6\u5019\u8981\u6309\u7167 $siz$ \u6765\uff0c\u4ee5\u53ca\u5728 $\\text{Split}$ \u53f3\u5b50\u6811\u7684\u65f6\u5019\u8981\u628a $pos$ \u51cf\u53bb\u5de6\u5b50\u6811\u7684 $siz+1$\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 50005\nusing namespace std;\nstruct FHQTreap\n{\n\tint son[2],siz,val,key,add,rev,maxn;\n}t[MAXN];\nint n,m,siz,root;\nvoid Update(int rt)\n{\n\tt[rt].siz=t[t[rt].son[0]].siz+t[t[rt].son[1]].siz+1;\n\tt[rt].maxn=t[rt].val;\n\tif(t[rt].son[0]) t[rt].maxn=max(t[rt].maxn,t[t[rt].son[0]].maxn);\n\tif(t[rt].son[1]) t[rt].maxn=max(t[rt].maxn,t[t[rt].son[1]].maxn);\n}\nvoid PushDown(int rt)\n{\n\tif(t[rt].rev)\n\t{\n\t\tif(t[rt].son[0]) t[t[rt].son[0]].rev^=1;\n\t\tif(t[rt].son[1]) t[t[rt].son[1]].rev^=1;\n\t\tswap(t[rt].son[0],t[rt].son[1]);\n\t\tt[rt].rev=0;\n\t}\n\tif(t[rt].add)\n\t{\n\t\tif(t[rt].son[0])\n\t\t{\n\t\t\tt[t[rt].son[0]].add+=t[rt].add;\n\t\t\tt[t[rt].son[0]].val+=t[rt].add;\n\t\t\tt[t[rt].son[0]].maxn+=t[rt].add;\n\t\t}\n\t\tif(t[rt].son[1])\n\t\t{\n\t\t\tt[t[rt].son[1]].add+=t[rt].add;\n\t\t\tt[t[rt].son[1]].val+=t[rt].add;\n\t\t\tt[t[rt].son[1]].maxn+=t[rt].add;\n\t\t}\n\t\tt[rt].add=0;\n\t\tUpdate(rt);\n\t}\n}\nint NewNode(int val)\n{\n\tt[++siz].siz=1;\n\tt[siz].val=val;\n\tt[siz].key=rand();\n\tt[siz].maxn=val;\n\treturn siz;\n}\nint Merge(int x,int y)\n{\n\tif(x) PushDown(x);\n\tif(y) PushDown(y);\n\tif(!x || !y) return x+y;\n\tif(t[x].key<t[y].key)\n\t{\n\t\tt[x].son[1]=Merge(t[x].son[1],y);\n\t\tUpdate(x);\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\tt[y].son[0]=Merge(x,t[y].son[0]);\n\t\tUpdate(y);\n\t\treturn y;\n\t}\n}\nvoid Split(int rt,int pos,int &x,int &y)\n{\n\tif(!rt) x=y=0;\n\telse\n\t{\n\t\tPushDown(rt);\n\t\tif(t[t[rt].son[0]].siz>=pos)\n\t\t{\n\t\t\ty=rt;\n\t\t\tSplit(t[rt].son[0],pos,x,t[rt].son[0]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tx=rt;\n\t\t\tSplit(t[rt].son[1],pos-t[t[rt].son[0]].siz-1,t[rt].son[1],y);\n\t\t}\n\t\tUpdate(rt);\n\t}\n}\nvoid Insert(int val)\n{\n\tint x,y;\n\tSplit(root,val,x,y);\n\troot=Merge(Merge(x,NewNode(val)),y);\n}\nvoid Modify(int pos,int sum,int val)\n{\n\tint x,y,z;\n\tSplit(root,pos-1,x,y);\n\tSplit(y,sum,y,z);\n\tt[y].val+=val;\n\tt[y].maxn+=val;\n\tt[y].add+=val;\n\troot=Merge(Merge(x,y),z);\n}\nvoid Reverse(int pos,int sum)\n{\n\tint x,y,z;\n\tSplit(root,pos-1,x,y);\n\tSplit(y,sum,y,z);\n\tt[y].rev^=1;\n\troot=Merge(Merge(x,y),z);\n}\nvoid Query(int pos,int sum)\n{\n\tint x,y,z;\n\tSplit(root,pos-1,x,y);\n\tSplit(y,sum,y,z);\n\tprintf(\"%d\\n\",t[y].maxn);\n\troot=Merge(Merge(x,y),z);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;i++) Insert(0);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint opt,x,y,z;\n\t\tscanf(\"%d %d %d\",&opt,&x,&y);\n\t\tif(opt==1)\n\t\t{\n\t\t\tscanf(\"%d\",&z);\n\t\t\tModify(x,y-x+1,z);\n\t\t}\n\t\telse if(opt==2) Reverse(x,y-x+1);\n\t\telse if(opt==3) Query(x,y-x+1);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546998648,
        "uid": 23243,
        "name": "VenusM1nT",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "#### \u8fd9\u9053\u9898\u5bf9\u4e8e\u50cf\u6211\u8fd9\u6837\u53ea\u505a\u8fc7\u4e24\u9053\u6a21\u677f\u9898\u7684splay\u521d\u5b66\u8005\u6765\u8bf4\u771f\u7684\u662f\u6bd2\u7624\u7206\u4e86\uff0c\u7ec6\u8282\u633a\u591a\uff0c\u4f46\u662f\u4e0d\u5f97\u4e0d\u8bf4\u6211\u5b66\u5230\u4e86\u5f88\u591a\uff0c\u7279\u610f\u5199\u9898\u89e3\u7eaa\u5ff5\u4e00\u4e0b\u3002\n\n---\n\n\u8fd9\u9053\u9898\u8981\u6c42\u6211\u4eec\u8981\u652f\u6301\u4e09\u4e2a\u64cd\u4f5c\uff1a**\u533a\u95f4\u52a0**\uff0c**\u533a\u95f4\u7ffb\u8f6c**\u548c**\u533a\u95f4\u6700\u5927\u503c**\u3002\u770b\u5230\u533a\u95f4\u7ffb\u8f6c\u6761\u4ef6\u53cd\u5c04\u5730\u5c31\u8981\u60f3\u5230**splay**\u3002\n\nsplay\u7684\u57fa\u672c\u64cd\u4f5c\u50cfrotate\u3001splay\u3001kth\uff08\u7b2ck\u5927\uff09\u4ec0\u4e48\u7684\u5c31\u4e0d\u8bb2\u4e86\uff0c\u90fd\u627e\u5230\u8fd9\u9053\u9898\u4e86\u8d77\u7801\u4e5f\u4f1a\u5427\u3002\n\n### split\u64cd\u4f5c\n\u8fd9\u4e2a\u64cd\u4f5c\u7684\u5b58\u5728\u4f7fsplay\u80fd\u591f\u7ef4\u62a4\u5e8f\u5217\u3002\u6bd4\u5982\u6211\u4eec\u8981\u60f3\u5f97\u5230$[l,r]$\u8fd9\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u5c31\u5bfb\u627e$l-1$\u8fd9\u4e2a\u7ed3\u70b9\uff0c\u628a\u5b83splay\u5230\u6839\u8282\u70b9\u7684\u4f4d\u7f6e\uff0c\u4e4b\u540e\u518d\u5bfb\u627e$r+1$\u8fd9\u4e2a\u7ed3\u70b9\uff0c\u628a\u5b83splay\u5230$l-1$\u90a3\u4e2a\u7ed3\u70b9\u7684\u53f3\u5b50\u6811\u4f4d\u7f6e\uff08\u4f60\u4e5f\u53ea\u80fd\u628a\u5b83\u65cb\u5230\u53f3\u5b50\u6811\u4f4d\u7f6e\uff09\u3002\u6309\u7167\u4e8c\u53c9\u6392\u5e8f\u6811\u7684\u6027\u8d28\uff0c\u5de6\u513f\u5b50\u5c0f\u4e8e\u6839\u8282\u70b9\u5c0f\u4e8e\u53f3\u513f\u5b50\uff0c\u5927\u4e8e$l-1$\u7684\u7ed3\u70b9\u5728\u5b83\u7684\u53f3\u8fb9\uff0c\u5c0f\u4e8e$r+1$\u7684\u7ed3\u70b9\u5728\u5b83\u7684\u5de6\u8fb9\uff0c\u90a3\u4e48$[l,r]$\u8fd9\u4e2a\u533a\u95f4\u4e0d\u5c31\u662f\u6839\u8282\u70b9\u7684\u53f3\u513f\u5b50\u7684\u5de6\u513f\u5b50\u4e86\u5417\uff1f\n### \u533a\u95f4\u52a0\n\u5bf9\u4e8e\u533a\u95f4\u52a0\uff0c\u6211\u4eec\u7528\u5230\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\u7684**lazy\u601d\u60f3**\u3002pushdown\u7684\u65f6\u5019\u5c31\u628a\u5de6\u53f3\u513f\u5b50\uff08\u524d\u63d0\u662f\u6709\u5de6\u53f3\u513f\u5b50\uff09\u7684**\u61d2\u6807\u8bb0**\u3001**\u6700\u5927\u503c**\u548c**\u7ed3\u70b9\u503c**\u52a0\u4e0a\u53bb\u5373\u53ef\u3002\u5f53\u6211\u4eec\u4e0b\u8bbf\u7ed3\u70b9\u7684\u65f6\u5019\u5c31\u53bbpushdown\u4e00\u4e0b\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u5f88\u597d\u3002\n\n### \u533a\u95f4\u7ffb\u8f6c\n\u533a\u95f4\u7ffb\u8f6c\u5c31\u662fsplay\u7684\u5e38\u89c4\u64cd\u4f5c\u4e86\uff0c\u540c\u6837\u4e5f\u662f\u4e00\u79cdlazy\u601d\u60f3\u3002\u6211\u4eec\u53ea\u8981\u628a\u9700\u8981\u533a\u95f4\u7ffb\u8f6c\u7684\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u4ea4\u6362\uff0c\u540c\u65f6\u4e5f\u7ed9\u5de6\u53f3\u513f\u5b50\uff08\u524d\u63d0\u662f\u6709\uff09\u6253\u61d2\u6807\u8bb0\uff0c\u4e4b\u540epushdown\u7684\u65f6\u5019\u4e5f\u7ee7\u7eed\u8fdb\u884c\u4e0b\u53bb\u5c31\u53ef\u4ee5\u4e86\u3002\u4e5f\u7b97\u662f\u57fa\u672c\u64cd\u4f5c\u5c31\u4e0d\u8bb2\u592a\u591a\u3002\n\n### \u533a\u95f4\u6700\u5927\u503c\n\u8fd9\u4e2a\u4e1c\u897f\u4e5f\u5bb9\u6613\u7ef4\u62a4\uff0c\u53ea\u9700\u8981\u5728pushup\u7684\u65f6\u5019\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002\u67e5\u8be2\u7684\u65f6\u5019\u627e\u5230\u5bf9\u5e94\u7ed3\u70b9\u76f4\u63a5\u8f93\u51fa\u7ed3\u70b9\u7684\u6700\u5927\u503c\u3002\n\n### \u5efa\u6811\n\n\u5efa\u6811\u8fd9\u4e2a\u8fc7\u7a0b\u4e2a\u4eba\u8ba4\u4e3a\u662f\u6bd4\u8f83\u503c\u5f97\u6ce8\u610f\u7684\u3002\u8fd9\u91cc\u7528\u5230\u7684\u5efa\u6811\u65b9\u6cd5\u4e5f\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\uff0c\u4ee5\u6b64\u6765\u5efa\u7acb\u4e00\u9897\u5f88\u5e73\u8861\u7684\u4e8c\u53c9\u6392\u5e8f\u6811\uff0c\u800c\u4e0d\u662f\u6211\u4eec\u5e73\u5e38\u89c1\u5230\u7684\u5355\u70b9\u63d2\u5165\uff0c\u56e0\u6b64\u5efa\u6811\u8fc7\u7a0b\u8fdesplay\u64cd\u4f5c\u90fd\u7528\u4e0d\u5230\uff0c\u8282\u7701\u65f6\u95f4\u3002\n\n\u5f04\u4e2a\u8349\u56fe\u7ed9\u5927\u5bb6\u770b\u770b\uff0c\u6bd4\u5982\u6211\u4eec\u5efa\u7acb$[1,8]$\u7684\u5e73\u8861\u6811\uff0c\u5efa\u51fa\u6765\u662f\u8fd9\u4e2a\u6837\u5b50\u7684\uff1a\n```\n        4\n       / \\\n      2   6\n     / \\ / \\\n    1  3 5  7\n```\n\u5177\u4f53\u53c2\u89c1\u4ee3\u7801\uff0c\u770b\u770b\u4e5f\u5e94\u8be5\u4f1a\u61c2\u7684\uff0c\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\u3002\n\n### \u7ec6\u8282\n\n~~AC\u548cWA\u7684\u8ddd\u79bb\u5f80\u5f80\u5c31\u5728\u4e8e\u7ec6\u8282\u3002~~\n\nsplay\u7ef4\u62a4\u533a\u95f4\u7684\u65f6\u5019\u4e00\u822c\u90fd\u4f1a\u5efa\u7acb$[1,n+2]$\u7684\u7ed3\u70b9\uff0c\u7136\u540e\u7528$[2,n-1]$\u7684\u7ed3\u70b9\u8868\u793a\u5e8f\u5217\uff0c\u4e5f\u5c31\u662f\u4e0b\u6807\u79fb\u4e86\u4e00\u4f4d\u3002\u5269\u4f59\u4e24\u4e2a\u70b9\u5373\u662f\u865a\u62df\u7ed3\u70b9\u3002\u8981\u662f\u4e0d\u52a0\u865a\u62df\u8282\u70b9\u7684\u8bdd**\u4f1a\u51c9\u7684**\u3002\n\n\u672c\u9898\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\uff0c\u90a3\u4e48\u6211\u4eec\u7684**\u4e24\u4e2a\u865a\u62df\u7ed3\u70b91\u548cn+2\u7684\u539f\u59cb\u503c\u5c31\u5e94\u8be5\u662f\u8d1f\u65e0\u7a77**\uff01\u4e0d\u80fd\u8ba9\u865a\u62df\u7ed3\u70b9\u4e32\u5165\u6211\u4eec\u7684\u5e8f\u5217\u4e4b\u4e2d\u3002\n\n\u6709\u4e00\u4e2a\u4e0d\u660e\u767d\u7684\u70b9\uff0c\u697c\u4e0a\u7684\u9898\u89e3\u4e5f\u90fd\u63d0\u9192\u5927\u5bb6\u4e86\uff1a**\u7ed3\u70b90\u7684\u6700\u5927\u503c\u4e5f\u8981\u662f\u8d1f\u65e0\u7a77**\uff01\u849f\u84bb\u4e0d\u77e5\u9053\u539f\u7406\uff0c\u6073\u8bf7dalao\u544a\u8bc9\u5c0f\u5f1f\u3002\n\n\u522b\u7684\u5730\u65b9\u5c31\u6ca1\u6709\u95ee\u9898\u4e86\u3002\u6211\u7684\u4ee3\u7801\u81ea\u8ba4\u4e3a\u8dd1\u5f97\u8fd8\u4e0d\u9519\uff0c\u5f00O2\u8dd1\u4e86\u76ee\u524d\u7684\u7b2c\u4e09\u540d\u3002\u4ee3\u7801\u5949\u4e0a\uff1a\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 50005;\nconst int INF = 99999999;\nint read()//\u5feb\u8bfb\n{\n\tint ans = 0, s = 1;\n\tchar ch = getchar();\n\twhile(ch > '9' || ch < '0')\n\t{\n\t\tif(ch == '-') s = -1;\n\t\tch = getchar();\n\t}\n\twhile(ch >= '0' && ch <= '9')\n\t{\n\t\tans = ans * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn s * ans;\n}\nstruct Splay\n{\n\tint fa, ch[2], size;//\u5e38\u89c4splay\n\tint lazy, rev, maxl, val;//\u533a\u95f4\u52a0\u6807\u8bb0\u3001\u7ffb\u8f6c\u6807\u8bb0\u3001\u6700\u5927\u503c\u3001\u7ed3\u70b9\u503c\n} s[maxn];\nint n, m, root, a[maxn];\nvoid pushup(int x)\n{\n\ts[x].size = s[s[x].ch[0]].size + s[s[x].ch[1]].size + 1;\n\ts[x].maxl = max(s[x].val, max(s[s[x].ch[0]].maxl, s[s[x].ch[1]].maxl));//\u6ce8\u610f\u5de6\u53f3\u5b50\u6811\u4e0d\u5305\u542b\u81ea\u5df1\n}\nvoid pushdown(int x)//\u8fd9\u91cc\u5728\u4f20lazy\u7684\u65f6\u5019\u4e5f\u987a\u4fbf\u5b8c\u6210\u5b50\u7ed3\u70b9\u7684\u4fee\u6539\n{\n\tif(s[x].lazy)\n\t{\n\t\tif(s[x].ch[0])\n\t\t{\n\t\t\ts[s[x].ch[0]].lazy += s[x].lazy;\n\t\t\ts[s[x].ch[0]].maxl += s[x].lazy;\n\t\t\ts[s[x].ch[0]].val += s[x].lazy;\n\t\t}\n\t\tif(s[x].ch[1])\n\t\t{\n\t\t\ts[s[x].ch[1]].lazy += s[x].lazy;\n\t\t\ts[s[x].ch[1]].maxl += s[x].lazy;\n\t\t\ts[s[x].ch[1]].val += s[x].lazy;\n\t\t}\n\t\ts[x].lazy = 0;\n\t}\n\tif(s[x].rev)\n\t{\n\t\tif(s[x].ch[0])\n\t\t{\n\t\t\ts[s[x].ch[0]].rev ^= 1;\n\t\t\tswap(s[s[x].ch[0]].ch[0], s[s[x].ch[0]].ch[1]);\n\t\t}\n\t\tif(s[x].ch[1])\n\t\t{\n\t\t\ts[s[x].ch[1]].rev ^= 1;\n\t\t\tswap(s[s[x].ch[1]].ch[0], s[s[x].ch[1]].ch[1]);\n\t\t}\n\t\ts[x].rev = 0;\n\t}\n}\nint identify(int x)\n{\n\treturn s[s[x].fa].ch[1] == x;\n}\nvoid connect(int son, int fa, int k)\n{\n\ts[son].fa = fa;\n\ts[fa].ch[k] = son;\n}\nvoid rotate(int x)\n{\n\tint y = s[x].fa;\n\tint z = s[y].fa;\n\tint yk = identify(x);\n\tint zk = identify(y);\n\tint b = s[x].ch[yk ^ 1];\n\tconnect(b, y, yk);\n\tconnect(y, x, yk ^ 1);\n\tconnect(x, z, zk);\n\tpushup(y); pushup(x);\n}\nvoid splay(int x, int goal)\n{\n\twhile(s[x].fa != goal)\n\t{\n\t\tint y = s[x].fa;\n\t\tint z = s[y].fa;\n\t\tif(z != goal) identify(x) == identify(y) ? rotate(y) : rotate(x);\n\t\trotate(x);\n\t}\n\tif(goal == 0) root = x;\n}\nint kth(int k)//\u5e73\u8861\u6811\u7b2ck\u5927\uff0c\u8fd9\u91cc\u5c31\u662f\u7b2ck\u4e2a\u6570\n{\n\tint now = root;\n\twhile(2333)\n\t{\n\t\tpushdown(now);//\u4e0b\u8bbf\u7ed3\u70b9\u8981pushdown\n\t\tint left = s[now].ch[0];\n\t\tif(s[left].size + 1 < k)\n\t\t{\n\t\t\tk -= s[left].size + 1;\n\t\t\tnow = s[now].ch[1];\n\t\t}\n\t\telse if(s[left].size >= k) now = left;\n\t\telse return now;\n\t}\n}\nint build(int l, int r, int fa)//\u5efa\u6811\uff0c\u8fd4\u56demid\uff0c\u4e2a\u4eba\u8ba4\u4e3a\u8f83\u65b9\u4fbf\n{\n\tif(l > r) return 0;//\u6ca1\u6709\n\tif(l == r)\n\t{\n\t\ts[l].fa = fa;\n\t\ts[l].maxl = s[l].val = a[l];\n\t\ts[l].size = 1;\n\t\treturn l;\n\t}\n\tint mid = (l + r) >> 1;\n\ts[mid].ch[0] = build(l, mid - 1, mid);//\u8fd9\u91cc\u76f4\u63a5\u5b8c\u6210\u5de6\u53f3\u5b50\u6811\u7684\u8d4b\u503c\n\ts[mid].ch[1] = build(mid + 1, r, mid);//\u6ce8\u610f\u5b50\u6811\u4e0d\u5305\u542b\u81ea\u8eab\n\ts[mid].val = a[mid];\n\ts[mid].fa = fa;\n\tpushup(mid);//\u5f97\u5230size\u548cmaxl\n\treturn mid;\n}\nint split(int l, int r)\n{\n\tl = kth(l); r = kth(r + 2);//\u6ce8\u610f\u4e0b\u6807\u90fd\u5411\u53f3\u79fb\u4e86\u4e00\u4f4d\n\tsplay(l, 0); splay(r, l);\n\treturn s[s[root].ch[1]].ch[0];\n}\nvoid update(int l, int r, int v)//\u64cd\u4f5c1\n{\n\tint now = split(l, r);\n\ts[now].lazy += v;\n\ts[now].maxl += v;\n\ts[now].val += v;\n\tpushup(s[root].ch[1]);\n\tpushup(root);\n}\nvoid reverse(int l, int r)//\u64cd\u4f5c2\n{\n\tint now = split(l, r);\n\ts[now].rev ^= 1;\n\tswap(s[now].ch[0], s[now].ch[1]);\n\tpushup(s[root].ch[1]);\n\tpushup(root);\n}\nint querymax(int l, int r)//\u64cd\u4f5c3\n{\n\treturn s[split(l, r)].maxl;\n}\nint main()\n{\n\tn = read(), m = read();\n\ta[1] = a[n + 2] = s[0].maxl = -INF;//\u7ec6\u8282\u3002\u3002\u3002\n\troot = build(1, n + 2, 0);//\u76f4\u63a5\u83b7\u5f97\u6839\n\tint k, l, r, v;\n\twhile(m--)\n\t{\n\t\tk = read(), l = read(), r = read();\n\t\tif(k == 1)\n\t\t{\n\t\t\tv = read();\n\t\t\tupdate(l, r, v);\n\t\t}\n\t\telse if(k == 2) reverse(l, r);\n\t\telse if(k == 3) printf(\"%d\\n\", querymax(l, r));\n\t}\n\treturn 0;//88\n}\n```",
        "postTime": 1522467178,
        "uid": 51497,
        "name": "Garen",
        "ccfLevel": 0,
        "title": "P4146 \u5e8f\u5217\u7ec8\u7ed3\u8005"
    },
    {
        "content": "# \u9898\u89e3-\u5e8f\u5217\u7ec8\u7ed3\u8005\n\u8fd9\u662f\u6a21\u677f\uff0c\u6240\u6709\u5e73\u8861\u6811\u7684\u9898\u5dee\u4e0d\u591a\u90fd\u662f\u6a21\u677f\u3002\n\n**\u53c2\u8003\u8d44\u6599**\n> \u6682\u65e0\n\n**[\u535a\u5ba2\u4e2d\u539f\u6587](https://blog.csdn.net/KonnyWen/article/details/104582119)**\n\n---\n\n## $\\color{#000}\\texttt{Introduction}$\n\n\u849f\u84bb\u521d\u5b66\u5e73\u8861\u6811\u4e00\u65e5\uff0c\u505a\u6b64\u9898\u8017\u65f6\u4e94\uff0c\u867d\u9519\u4e0d\u5947\uff0c\u8bb0\u6b64\u6587\u4ee5\u5178\u4e3a\u4eba\uff0c\u4ee5\u5811\u4e3a\u5df1\u3002\n\n---\n## $\\color{#000}\\texttt{Description}$\n\n> [\u5e8f\u5217\u7ec8\u7ed3\u8005](https://www.luogu.com.cn/problem/P4146)\n> \u6709\u4e00\u4e2a $N$ \u4e2a\u6570\u7684\u5e8f\u5217 $a_1,a_2,...,a_n$ \u521a\u5f00\u59cb\u65f6\u90fd\u4e3a $0$\uff0c\u6709 $M$ \u4e2a\u64cd\u4f5c\u5982\u4e0b\uff1a\n> 1. \u5c06 $[L,R]$ \u8fd9\u4e2a\u533a\u95f4\u5185\u7684\u6240\u6709\u6570\u52a0\u4e0a $V$\u3002\n> 2. \u5c06 $[L,R]$ \u8fd9\u4e2a\u533a\u95f4\u7ffb\u8f6c\uff0c\u6bd4\u5982 $1,2,3,4$ \u53d8\u6210 $4,3,2,1$\u3002\n> 3. \u6c42 $[L,R]$ \u8fd9\u4e2a\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u3002\n> \u6570\u636e\u8303\u56f4\uff1a$1\\le N\\le 5\\times 10^4$\uff0c$1\\le M\\le 10^5$\u3002\n\n---\n## $\\color{#000}\\texttt{Solution}$\n**\u533a\u95f4\u7ffb\u8f6c**\u64cd\u4f5c\u5c31\u8bf4\u660e\u8981\u7528 $\\texttt{Splaytree}$ \u4e86\uff08[\u901f\u5b66\u5e73\u8861\u6811](https://blog.csdn.net/KonnyWen/article/details/104565245)\uff09\u3002\u7528\u7ed3\u6784\u4f53 $(node)\\{d,v\\}$ \u4f5c\u4e3a\u6bcf\u4e2a\u8282\u70b9\u7684\u503c\uff0c\u8868\u793a\u503c\u4e3a $v$\uff0c\u539f\u5e8f\u5217\u4e2d\u4e0b\u6807\u4e3a $d$\u3002\u5982\u679c\u7528\u5e73\u8861\u6811\u7684\u4e2d\u5e8f\u904d\u5386\u8868\u793a\u6570\u5217\uff0c\u90a3\u4e48\u627e\u5230\u533a\u95f4 $[L,R]$\uff0c**\u53ea\u9700\u5148\u628a $L$ \u7684\u4e0b\u6807\u524d\u9a71\u8282\u70b9 $pre$ \u65cb\u5230\u6839\u8282\u70b9\uff0c\u518d\u628a $R$ \u7684\u4e0b\u6807\u540e\u7ee7\u8282\u70b9 $nex$ \u65cb\u5230\u6839\u8282\u70b9\uff08$pre$\uff09\u7684\u53f3\u5b50\u6811\uff0c\u90a3\u4e48\u8fd9\u65f6 $nex$ \u7684\u5de6\u5b50\u6811\u5c31\u662f $[L,R]$ \u533a\u95f4\u5bf9\u5e94\u7684\u8282\u70b9**\u3002\n\n\u7136\u540e\u7ffb\u8f6c\u5462\u5c31\u662f\u5728 $nex$ \u7684\u5de6\u513f\u5b50\u4e0a\u6253\u4e2a\u6807\u8bb0 $mk$\uff0c\u4e0b\u6b21\u8981\u64cd\u4f5c\u5b83\u4e86\u5c31\u8f83\u6362\u5b83\u7684\u4e24\u4e2a\u5b50\u6811\uff0c\u7136\u540e\u6807\u8bb0\u4e0b\u4f20\u3002\n\n\u600e\u4e48\u533a\u95f4\u52a0\u6570\u5462\uff1f\u540c\u7406\u901a\u8fc7\u7ffb\u8f6c $pre$ \u548c $nex$ \u5f97\u5230 $[L,r]$ \u533a\u95f4\u5bf9\u5e94\u8282\u70b9\u662f $nex$ \u7684\u5de6\u5b50\u6811\uff0c\u7136\u540e\u5728 $nex$ \u7684\u5de6\u4e8c\u5b50\u4e0a\u6253\u4e0b\u6807\u8bb0 $ad+=V$\uff0c\u5e76\u628a\u5b83\u7684\u503c\u52a0\u4e0a $V$\u3002\u4e0b\u6b21\u8981\u64cd\u4f5c\u5b83\u7684\u65f6\u5019\u518d\u5728\u5b83\u7684\u5b50\u6811\u4e0a $+V$\uff0c\u7136\u540e\u6807\u8bb0\u4e0b\u4f20\u5373\u53ef\u3002\n\n\u53d6\u533a\u95f4\u6700\u5927\u503c\u4e5f\u662f\u540c\u7406\uff0c\u6bcf\u4e2a\u8282\u70b9 $x$ \u8bb0\u5f55 $node$ \u7c7b\u578b\u7684 $mx_x$ \u8868\u793a $x$ \u7684\u5b50\u6811\u4e2d $v$ \u6700\u5927\u7684\u8282\u70b9\u503c $node$\u3002\u7528 $\\texttt{pushup}$ \u51fd\u6570\u548c\u5b50\u6811\u5927\u5c0f\u6570\u7ec4\u4e00\u8d77\u7b97\u3002\u8981\u8be2\u95ee\u7684\u65f6\u5019\u540c\u6837\u662f\u7ffb\u8f6c $pre$ \u548c $nex$\uff0c\u7136\u540e\u8f93\u51fa $nex$ \u7684\u5de6\u513f\u5b50\u7684 $mx$ \u7684 $v$ \u503c\u3002\n\n---\n\n## $\\color{#000}\\texttt{Code}$\n\u4ee3\u7801\u5b9e\u73b0\u7684\u65f6\u5019\u6709\u4e2a\u5f88\u91cd\u8981\u7684\u7ec6\u8282\uff0c**\u56e0\u4e3a\u5e8f\u5217\u4e2d\u7684\u6570\u5f88\u53ef\u80fd\u51cf\u6210\u8d1f\u6570\uff0c\u6240\u4ee5 $\\texttt{pushup}$** $mx$ \u7684\u65f6\u5019\u8981\u5224\u65ad\u662f\u5426\u6709\u5b50\u6811\uff0c\u5426\u5219 $mx$ \u4f1a\u7b49\u4e8e\u7a7a\u5b50\u6811\u7684\u503c\u3002\n\n \n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n//&Start\n#define lng long long\nconst int inf=0x3f3f3f3f;\nconst lng Inf=1e16;\n\n//&Debug\nint open(0);\n#define Debug if(open)\nqueue<int> B;\nvoid debug(const char s[]){\n\tprintf(\"--------%s--------\\n\",s);\n\twhile(B.size()){printf(\"%d%c\",B.front(),\"\\n \"[B.size()>1]);B.pop();}\n}\n\n//&Splay\nstruct node{//\u5373\u8282\u70b9\u503c\uff0cd\u4e3a\u4e0b\u6807\uff0cv\u4e3a\u503c\n\tint d,v;\n\tfriend bool operator<(node x,node y){return x.d<y.d;}\n\tfriend bool operator>(node x,node y){return x.d>y.d;}\n\tfriend node operator+=(node&x,int y){x.v+=y;return x;}\n\tfriend node max(node x,node y){return (x.v>y.v)?x:y;}\n}; \ntemplate<int N,class T>struct Splaytree{\n\tint sz,rt,sm[N],ad[N],mk[N],fa[N],ch[N][2],q[N];\n\tT key[N],mx[N];\n\t//\u5c31\u662f\u6a21\u677f\u548c\u6807\u8bb0\n\tbool dire(int x){return ch[fa[x]][1]==x;}\n\tvoid pushup(int x){\n\t\tsm[x]=sm[ch[x][0]]+sm[ch[x][1]]+1;\n\t\tmx[x]=key[x];\n\t\t//\u5224\u65ad\u662f\u5426\u6709\u5b50\u6811\uff0c\u5426\u5219\u51fa\u9505\n\t\tif(ch[x][0]) mx[x]=max(mx[x],mx[ch[x][0]]);\n\t\tif(ch[x][1]) mx[x]=max(mx[x],mx[ch[x][1]]);\n\t}\n\tvoid pushdown(int x){\n\t\t//\u50cf\u7ebf\u6bb5\u6811\u4e00\u6837\u7684pushdown\n\t\tint &ls=ch[x][0],&rs=ch[x][1];\n\t\tif(mk[x]){if(ls) mk[ls]^=1;if(rs) mk[rs]^=1;swap(ls,rs);mk[x]=0;}\n\t\tif(ad[x]){\n\t\t\tif(ls){ad[ls]+=ad[x];key[ls]+=ad[x];mx[ls]+=ad[x];}\n\t\t\tif(rs){ad[rs]+=ad[x];key[rs]+=ad[x];mx[rs]+=ad[x];}\n\t\t\tad[x]=0;\n\t\t}\n\t}\n\tvoid connect(int x,int f,bool d){if(x) fa[x]=f;if(f) ch[f][d]=x;}\n\tint newnode(T v,int f){fa[++sz]=f;mx[sz]=key[sz]=v;sm[sz]=1;return sz;}\n\tvoid rotate(int x){\n\t\tint f=fa[x],ff=fa[f],dx=dire(x),df=dire(f);\n\t\tpushdown(x);pushdown(f);\n\t\tconnect(ch[x][dx^1],f,dx);connect(f,x,dx^1);connect(x,ff,df);\n\t\tpushup(f);pushup(x);\n\t}\n\tvoid splay(int x,int ff){\n\t\tint len=0;\n\t\tfor(int i=x;i;i=fa[i]) q[++len]=i;\n\t\tfor(int i=len;i>=1;i--) pushdown(q[i]);\n\t\tfor(int f;(f=fa[x])!=ff;rotate(x))\n\t\t\tif(fa[f]!=ff) rotate(dire(x)==dire(f)?f:x);\n\t\tif(!ff) rt=x;\n\t}\n\tvoid insert(T v){\n\t\tint x=rt,f=0;\n\t\twhile(x){f=x;x=ch[f][v>key[f]];}\n\t\tif(f) ch[f][v>key[f]]=sz+1;\n\t\tsplay(newnode(v,f),0);\n\t}\n\tint kth(int k){\n\t\tfor(int x=rt;pushdown(x),1;) \n\t\t\tif(k<=sm[ch[x][0]]) x=ch[x][0];\n\t\t\telse {k-=sm[ch[x][0]]+1;if(!k) return x;x=ch[x][1];}\n\t\treturn inf;\n\t}\n\t//\u7ffb\u8f6c\u533a\u95f4\uff0c\u6253\u6807\u8bb0mk\n\tvoid flip(int pre,int nex){splay(pre,0);splay(nex,rt);mk[ch[nex][0]]^=1;}\n\t//\u533a\u95f4\u52a0V\uff0c\u6253\u6807\u8bb0ad+=V\uff08\u56e0\u4e3amx\u7684\u503c\u5fc5\u7136+V\uff0c\u6240\u4ee5\u5148+V\uff09\n\tvoid add(int pre,int nex,int y){\n\t\tsplay(pre,0);splay(nex,rt);\n\t\tkey[ch[nex][0]]+=y;mx[ch[nex][0]]+=y;ad[ch[nex][0]]+=y;\n\t}\n\t//\u6c42\u533a\u95f4\u6700\u5927\u503c\uff08\u8fd4\u56denode\u503c\uff09\n\tT fmax(int pre,int nex){splay(pre,0);splay(nex,rt);return mx[ch[nex][0]];}\n};\n\n//&Main\nconst int N=5e4+10;\nint n,m;\nSplaytree<N,node> F;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) F.insert((node){i,0});\n\tF.insert((node){-inf,0});\n\tF.insert((node){inf,0});\n\tfor(int i=1,h,l,r,v;i<=m;i++){\n\t\tscanf(\"%d%d%d\",&h,&l,&r);\n\t\tif(h==1){\n\t\t\tscanf(\"%d\",&v);\n\t\t\tF.add(F.kth(l),F.kth(r+2),v);\n\t\t} else if(h==2){\n\t\t\tF.flip(F.kth(l),F.kth(r+2));\n\t\t} else if(h==3)\n\t\t\tprintf(\"%d\\n\",F.fmax(F.kth(l),F.kth(r+2)).v);\n\t\tDebug{//\u8fd9\u90e8\u5206\u662f\u8c03\u8bd5\u4ee3\u7801\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.fa[i]);\n\t\t\tdebug(\"fa\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.ch[i][0]);\n\t\t\tdebug(\"ls\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.ch[i][1]);\n\t\t\tdebug(\"rs\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.key[i].d);\n\t\t\tdebug(\"id\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.key[i].v);\n\t\t\tdebug(\"val\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.mx[i].v);\n\t\t\tdebug(\"mx\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.ad[i]);\n\t\t\tdebug(\"add\");\n\t\t\tfor(int i=1;i<=F.sz;i++) B.push(F.mk[i]);\n\t\t\tdebug(\"mk\");\n\t\t}\n\t}\n\treturn 0;\n}\n```\n---\n\n\u6211\u8fd8\u662f\u592a\u84bb\u4e86\uff0c**\u795d\u5927\u5bb6\u5b66\u4e60\u6109\u5feb\uff01**\n\n",
        "postTime": 1582984672,
        "uid": 118365,
        "name": "George1123",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "\u5f88\u660e\u663e\u53ef\u4ee5\u7528 Splay \u6765\u7ef4\u62a4\u5bf9\u4e0d\u5bf9\n\n\u5c31\u662f\u6bcf\u6b21\u5c06\u5f85\u64cd\u4f5c\u533a\u95f4\u63d0\u53d6\u51fa\u6765\uff0c\u7136\u540e\u6253\u4e0a\u6807\u8bb0\uff0c\u8bb0\u5f97\u4e0b\u7a7f\u6807\u8bb0\u3002\n\n\u7136\u800c\u81ea\u5df1\u8fd8\u662f\u5199\u7684\u4e0d\u719f\u7ec3\uff0c\u7adf\u7136\u8c03\u4e86\u534a\u4e2a\u5c0f\u65f6\u3002\u3002\u3002\u8fd9\u91cc\u603b\u7ed3\u4e0b\u6211\u72af\u8fc7\u7684sb\u9519\u8bef\n\n- `return o -> father ? o -> father -> ch[1] == o;` ---> `return o ?  o -> father -> ch[1] == o;`\n- \u6ca1\u6709\u4e0b\u4f20\u6807\u8bb0\n- \u53ea\u66f4\u65b0\u4e86\u6700\u5927\u503c\uff0c\u6ca1\u6709\u66f4\u65b0\u5f53\u524d\u7ed3\u70b9\u7684\u503c\n\n\u5e0c\u671b\u8fd9\u91cc\u7684\u4ee3\u7801\u5bf9\u6307\u9488\u515a\u6709\u5e2e\u52a9 qwq\n\n```cpp\n#include <iostream>\n#include <cstdio>\n\nconst int INF = -1e9;\n\nint n, m;\n\nnamespace Splay {\n    struct Tree {\n        struct Splay {\n            int val, size, maxv, lazy;\n            bool rev;\n            Splay *ch[2], *father;\n            Splay() {}\n            Splay(int _val, Splay *_father) : val(_val), size(1), maxv(_val), lazy(0), rev(0), father(_father) { ch[0] = ch[1] = NULL; }\n        } *root;\n        inline int size(Splay *o) { return o ? o -> size : 0; }\n        inline int maxv(Splay *o) { return o ? o -> maxv : INF; }\n        inline void pushup(Splay *o) {\n            o -> size = size(o -> ch[0]) + 1 + size(o -> ch[1]);\n            o -> maxv = std::max(std::max(maxv(o -> ch[0]), maxv(o -> ch[1])), o -> val);        \n        }\n        inline void pushdown(Splay *o) {\n            Splay *&ls = o -> ch[0], *&rs = o -> ch[1];\n            if(o -> lazy) {\n                if(ls) {\n                    ls -> val += o -> lazy;\n                    ls -> maxv += o -> lazy;\n                    ls -> lazy += o -> lazy;\n                }\n                if(rs) {\n                    rs -> val += o -> lazy;\n                    rs -> maxv += o -> lazy;\n                    rs -> lazy += o -> lazy;\n                }\n                o -> lazy = 0;\n            }\n            if(o -> rev) {\n                if(ls) ls -> rev ^= 1;\n                if(rs) rs -> rev ^= 1;\n                std::swap(ls, rs);\n                o -> rev = 0;\n            }\n        }\n        inline int relation(Splay *o) { return o -> father ? o -> father -> ch[1] == o : 0; }\n        inline void connect(Splay *x, Splay *y, int relation) {\n            if(x) x -> father = y;\n            if(y) y -> ch[relation] = x;\n        }\n        inline void rotate(Splay *o) {\n            Splay *p = o -> father, *q = p -> father;\n            int wson = relation(o);\n            connect(o, q, relation(p));\n            connect(o -> ch[wson ^ 1], p, wson);\n            connect(p, o, wson ^ 1);\n            pushup(p);\n            pushup(o);\n        }\n        inline void splay(Splay *o, Splay *goal) {\n            if(!o) return;\n            while(o -> father != goal) {\n                Splay *p = o -> father;\n                if(p -> father != goal) relation(o) ^ relation(p) ? rotate(o) : rotate(p);\n                rotate(o);\n            }\n            if(!goal) root = o;\n        }\n        inline Splay *kth(int k) {\n            Splay *o = root;\n            while(1) {\n                pushdown(o);\n                if(size(o -> ch[0]) + 1 == k) return o;\n                else if(size(o -> ch[0]) >= k) o = o -> ch[0];\n                else {\n                    k -= size(o -> ch[0]) + 1;\n                    o = o -> ch[1];\n                }\n            }\n            return NULL;\n        }\n        inline void build(Splay *&o, Splay *fa, int l, int r) {\n            if(l > r) return;\n            int mid = (l + r) >> 1;\n            o = new Splay((mid == 1 || mid == n + 2) ? INF : 0, fa);\n            build(o -> ch[0], o, l, mid - 1);\n            build(o -> ch[1], o, mid + 1, r);\n            pushup(o);\n        }\n        inline void Add(int l, int r, int val) {\n            ++l;\n            ++r;\n            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            root -> ch[1] -> ch[0] -> val += val;\n            root -> ch[1] -> ch[0] -> maxv += val;\n            root -> ch[1] -> ch[0] -> lazy += val;\n            pushup(root -> ch[1]);\n            pushup(root);\n        }\n        inline void Reverse(int l, int r) {\n            ++l;\n            ++r;\n            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            root -> ch[1] -> ch[0] -> rev ^= 1;\n        }\n        inline void Max(int l, int r) {\n            ++l;\n            ++r;\n            Splay *o1 = kth(l - 1), *o2 = kth(r + 1);\n            splay(o1, NULL);\n            splay(o2, o1);\n            printf(\"%d\\n\", root -> ch[1] -> ch[0] -> maxv); \n        }\n    } tree;\n}\n\ninline int read() {\n    register int x = 0, v = 1;\n    register char ch = getchar();\n    while(!isdigit(ch)) {\n        if(ch == '-') v = -1;\n        ch = getchar();\n    }\n    while(isdigit(ch)) {\n        x = x * 10 + ch - '0';\n        ch = getchar();\n    }\n    return x * v;\n}\n\nusing namespace Splay;\n\nint main() {\n    n = read();\n    m = read();\n    tree.build(tree.root, NULL, 1, n + 2);\n    while(m--) {\n        int opt = read();\n        if(opt == 1) {\n            int l = read(), r = read(), val = read();\n            tree.Add(l, r, val);\n        } else if(opt == 2) {\n            int l = read(), r = read();\n            tree.Reverse(l, r);\n        } else if(opt == 3) {\n            int l = read(), r = read();\n            tree.Max(l, r);\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1544360193,
        "uid": 24878,
        "name": "iodwad",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "### \u9898\u76ee\u63cf\u8ff0\n\n\u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3aN\u7684\u5e8f\u5217\uff0c\u6bcf\u4e2a\u5e8f\u5217\u7684\u5143\u7d20\u662f\u4e00\u4e2a\u6574\u6570\uff08\u5e9f\u8bdd\uff09\u3002\u8981\u652f\u6301\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a\n\n\u5c06[L,R]\u8fd9\u4e2a\u533a\u95f4\u5185\u7684\u6240\u6709\u6570\u52a0\u4e0aV\u3002\n\n\u5c06[L,R]\u8fd9\u4e2a\u533a\u95f4\u7ffb\u8f6c\uff0c\u6bd4\u59821 2 3 4\u53d8\u62104 3 2 1\u3002\n\n\u6c42[L,R]\u8fd9\u4e2a\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u3002\n\n\u6700\u5f00\u59cb\u6240\u6709\u5143\u7d20\u90fd\u662f0\u3002\n\n### \u8f93\u5165\u8f93\u51fa\u683c\u5f0f\n\n#### \u8f93\u5165\u683c\u5f0f\uff1a\n\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570N\uff0cM\u3002M\u4e3a\u64cd\u4f5c\u4e2a\u6570\u3002\n\n\u4ee5\u4e0bM\u884c\uff0c\u6bcf\u884c\u6700\u591a\u56db\u4e2a\u6574\u6570\uff0c\u4f9d\u6b21\u4e3aK\uff0cL\uff0cR\uff0cV\u3002K\u8868\u793a\u662f\u7b2c\u51e0\u79cd\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\u7b2c1\u79cd\u64cd\u4f5c\u5219K\u540e\u9762\u53ea\u6709\u4e24\u4e2a\u6570\u3002\n\n#### \u8f93\u51fa\u683c\u5f0f\uff1a\n\u5bf9\u4e8e\u6bcf\u4e2a\u7b2c3\u79cd\u64cd\u4f5c\uff0c\u7ed9\u51fa\u6b63\u786e\u7684\u56de\u7b54\u3002\n\n### \u8f93\u5165\u8f93\u51fa\u6837\u4f8b\n\n\u8f93\u5165\u6837\u4f8b#1\uff1a\n\n    4 4\n    1 1 3 2\n    1 2 4 -1\n    2 1 3\n    3 2 4\n\u8f93\u51fa\u6837\u4f8b#1\uff1a\n\n    2\n   \n### \u8bf4\u660e\n\n\tN\u226450000,M\u2264100000\u3002\n    \n### \u4e3b\u8981\u601d\u8def\uff1aFHQ Treap\u533a\u95f4\u64cd\u4f5c\n\n\u7b97\u662f\u4e00\u9053\u6a21\u677f\u9898\u5427\u3002\u4e3b\u8981\u662f\u5728\u7ef4\u62a4\u533a\u95f4\u52a0\u548c\u533a\u95f4\u7ffb\u8f6c\u4e0a\u3002\n\n\u91cd\u70b9\u5c31\u662f\u6253\u6807\u8bb0\u3002\u5176\u5b9e\u533a\u95f4\u7ffb\u8f6c\u7684\u6807\u8bb0\u65b9\u5f0f\u5728\u6587\u827a\u5e73\u8861\u6811\u90a3\u9053\u9898\u91cc\u9762\u6709\u7528\u5230\u8fc7\u3002\u5c31\u662f\u5728\u505a\u4e00\u4e2a\u6807\u8bb0\uff0c\u6807\u8bb0\u533a\u95f4\u662f\u5426\u7ffb\u8f6c\u3002\u7136\u540e\u5728\u6709\u6807\u8bb0\u7684\u8282\u70b9\u4e0a\u4ea4\u6362\u5de6\u53f3\u5b50\u6811\u5373\u53ef\u3002\u90e8\u5206\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n// z[rt].col\u8868\u793a\u533a\u95f4\u52a0\u7684\u61d2\u6807\u8bb0\n// z[rt].coll\u8868\u793a\u533a\u95f4\u7ffb\u8f6c\u7684\u61d2\u6807\u8bb0\n// z[rt].ch[0]\u8868\u793art\u8282\u70b9\u7684\u5de6\u5b50\u6811\n// z[rt].ch[1]\u8868\u793art\u8282\u70b9\u7684\u53f3\u5b50\u6811\n// \u8fd9\u4e2a\u4ee3\u7801\u662f\u4e0b\u65b9\u6807\u8bb0\u7684\u51fd\u6570\ninline void push_col(int rt) {\n\tif(z[rt].col) {\n\t\tif(z[rt].ch[0]) { // \u5206\u7c7b\u8ba8\u8bba\n\t\t\tz[z[rt].ch[0]].col += z[rt].col;\n\t\t\tz[z[rt].ch[0]].maxx += z[rt].col;\n\t\t\tz[z[rt].ch[0]].w += z[rt].col;\n\t\t}\n\t\tif(z[rt].ch[1]) {\n\t\t\tz[z[rt].ch[1]].col += z[rt].col;\n\t\t\tz[z[rt].ch[1]].maxx += z[rt].col;\n\t\t\tz[z[rt].ch[1]].w += z[rt].col;\n\t\t}\n\t\tz[rt].col = 0; // \u6700\u540e\u53bb\u6389\u6807\u8bb0\n\t}\n\tif(z[rt].coll) { \n\t\tif(z[rt].ch[0]) z[z[rt].ch[0]].coll ^= 1;\n\t\tif(z[rt].ch[1]) z[z[rt].ch[1]].coll ^= 1;\n\t\tswap(z[rt].ch[0], z[rt].ch[1]); // \u4ea4\u6362\n\t\tz[rt].coll = 0; // \u53bb\u6807\u8bb0\n\t}\n}\n```\n\u8981\u6ce8\u610f\u7684\u662f\u5728split\u548cmerge\u65f6\u52a0\u4e0apush_col\u548cupdate\u7684\u64cd\u4f5c\u3002\n\n### code\uff1a\n\n\u9644\u5e26debug\u4ee3\u7801\u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n#define go(i, j, n, k) for(int i = j; i <= n; i += k) \n#define fo(i, j, n, k) for(int i = j; i >= n; i -= k)\n#define rep(i, x) for(int i = h[x]; i; i = e[i].nxt)\n#define mn 50010\n#define inf 1 << 30\n#define ll long long\ninline int read(){\n    int x = 0, f = 1; char ch = getchar();\n    while(ch > '9' || ch < '0') { if(ch == '-') f = -f; ch = getchar(); }\n    while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n} \nstruct tree{\n    int ch[2], pri, sze, w;\n    int maxx;\n    int col, coll;\n} z[mn];\ninline void update(int rt) {\n    z[rt].sze = 1;\n    z[rt].maxx = z[rt].w;\n    if(z[rt].ch[0]) {\n        z[rt].sze += z[z[rt].ch[0]].sze;\n        z[rt].maxx = max(z[rt].maxx, z[z[rt].ch[0]].maxx);\n    }\n    if(z[rt].ch[1]) {\n        z[rt].sze += z[z[rt].ch[1]].sze;\n        z[rt].maxx = max(z[rt].maxx, z[z[rt].ch[1]].maxx);\n    }\n}\ninline void push_col(int rt) {\n    if(z[rt].col) {\n        if(z[rt].ch[0]) {\n            z[z[rt].ch[0]].col += z[rt].col;\n            z[z[rt].ch[0]].maxx += z[rt].col;\n            z[z[rt].ch[0]].w += z[rt].col;\n        }\n        if(z[rt].ch[1]) {\n            z[z[rt].ch[1]].col += z[rt].col;\n            z[z[rt].ch[1]].maxx += z[rt].col;\n            z[z[rt].ch[1]].w += z[rt].col;\n        }\n        z[rt].col = 0;\n// \t\tupdate(rt);\n    }\n    if(z[rt].coll) {\n        if(z[rt].ch[0]) z[z[rt].ch[0]].coll ^= 1;\n        if(z[rt].ch[1]) z[z[rt].ch[1]].coll ^= 1;\n        swap(z[rt].ch[0], z[rt].ch[1]);\n        z[rt].coll = 0;\n    }\n}\nint cnt;\ninline int newnode(int w = 0) {\n    z[++cnt].maxx = w;\n    z[cnt].w = w;\n    z[cnt].pri = rand();\n    z[cnt].sze = 1;\n    z[cnt].col = z[cnt].coll = 0;\n    return cnt;\n} \ninline int merge(int x, int y) {\n    if(!x || !y) return x + y;\n    if(z[x].pri < z[y].pri) {\n        push_col(x);\n        z[x].ch[1] = merge(z[x].ch[1], y);\n        update(x);\n        return x;\n    } else {\n        push_col(y);\n        z[y].ch[0] = merge(x, z[y].ch[0]);\n        update(y);\n        return y;\n    }\n}\ninline void split(int rt, int k, int &x, int &y) {\n    if(!rt) x = y = 0;\n    else {\n        push_col(rt);\n        if(k <= z[z[rt].ch[0]].sze) {\n            y = rt, split(z[rt].ch[0], k, x, z[rt].ch[0]);\n        } else {\n            x = rt, split(z[rt].ch[1], k - z[z[rt].ch[0]].sze - 1, z[rt].ch[1], y);\n        }\n        update(rt);\n    }\n}\ninline void debug(int rt) {\n    if(!rt) return;\n    if(z[rt].ch[0]) debug(z[rt].ch[0]);\n    printf(\"%d %d %d %d\\n\", z[rt].w, z[rt].maxx, z[rt].pri, z[rt].sze);\n    if(z[rt].ch[1]) debug(z[rt].ch[1]);\n    \n}\nint n, m, rot, xx, yy, zz;\nint main() {\n    n = read(), m = read();\n    go(i, 1, n, 1) {\n        rot = merge(rot, newnode(0));\n    }\n    go(i, 1, m, 1) {\n        int s = read(), l = read(), r = read(), v;\n        if(s == 1) {\n            v = read();\n            split(rot, r, xx, zz);\n            split(xx, l - 1, xx, yy);\n            z[yy].col += v;\n            z[yy].maxx += v;\n            z[yy].w += v;\n            rot = merge(merge(xx, yy), zz);\n        } else if(s == 2) {\n            split(rot, r, xx, zz);\n            split(xx, l - 1, xx, yy);\n            z[yy].coll ^= 1;\n            rot = merge(merge(xx, yy), zz);\n        } else if(s == 3) {\n            split(rot, r, xx, zz);\n            split(xx, l - 1, xx, yy);\n            printf(\"%d\\n\", z[yy].maxx);\n            rot = merge(merge(xx, yy), zz);\n        }\n    }\n//\tdebug(rot);\n    return 0;\n}\n```",
        "postTime": 1543997495,
        "uid": 71168,
        "name": "yizimi\u8fdc\u6b23",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "\u539f\u9898\u5730\u5740\uff1a[\u5e8f\u5217\u7ec8\u7ed3\u8005](https://www.luogu.org/recordnew/show/19802000)\n\n(\u505a\u4e86\u8fd9\u9053\u9898\u5c31\u4e0d\u80fd\u518d\u4f5c\u5e8f\u5217\u9898\u4e86\u5440qaq)\n\nfhq treap\u5927\u6cd5\u597d\u554a\uff01\n\n\u6807\u8bb0\u4e0b\u4f20\u7684\u8fdb\u9636\u4e4b\u9898\n\n\u548c\u4f1a\u6709\u8d1f\u6570\uff0c\u521d\u59cb\u5316\u8981-INF\uff08\u6572\u91cd\u70b9!\uff09\n\n\u5efa\u8bae\u4e0b\u4f20\u4e4b\u524d\u5148\u66f4\u6539\u503c\uff0c\u624d\u53ef\u4ee5\u4fdd\u8bc1\u5982\u679c\u6709\u6807\u8bb0\u4ecd\u672a\u4f20\u5b8c\uff0c\u5f53\u524d\u7b54\u6848\u4e5f\u662f\u5bf9\u7684\n\n\u8d34\u4ee3\u7801\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100010\nint n, m, root, cnt;\nstruct node {\n    int l, r, val, max, key, size, tag, add;\n} t[MAXN];\ninline int read() {\n    int s = 0, w = 1;\n    char c = getchar();\n    for (; !isdigit(c); c = getchar()) if (c == '-') w = -1;\n    for (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);\n    return s * w;\n}\ninline int New(int val) {\n    t[++cnt].val = val, t[cnt].key = rand() * rand(), t[cnt].size = 1;\n    return cnt;\n}\ninline void update(int now) {\n    t[0].add = 0;\n    t[0].val = 0;\n    t[0].max = -2e9;\n    t[now].size = t[t[now].l].size + t[t[now].r].size + 1;\n    t[now].max = max(t[now].val, max(t[t[now].l].max, t[t[now].r].max));\n}\ninline void pushdown(int now) {\n    t[0].add = 0;\n    t[0].val = 0;\n    t[0].max = -2e9;\n    if (t[now].tag) {\n        swap(t[now].l, t[now].r);\n        t[t[now].l].tag ^= 1, t[t[now].r].tag ^= 1;\n        t[now].tag = 0;\n    }\n    if (t[now].add) {\n        t[t[now].l].add += t[now].add, t[t[now].r].add += t[now].add;\n        t[t[now].l].val += t[now].add, t[t[now].r].val += t[now].add;\n        t[t[now].l].max += t[now].add, t[t[now].r].max += t[now].add;\n        t[now].add = 0;\n    }\n}\ninline void Split(int now, int w, int &u, int &v) {\n    if (!now) u = v = 0;\n    else {\n        pushdown(now);\n        if (t[t[now].l].size < w)\n            u = now, Split(t[now].r, w - t[t[now].l].size - 1, t[now].r, v);\n        else\n            v = now, Split(t[now].l, w, u, t[now].l);\n        update(now);\n    }\n}\ninline int Merge(int u, int v) {\n    if (!u || !v) return u + v;\n    if (t[u].key < t[v].key) {\n        pushdown(u);\n        t[u].r = Merge(t[u].r, v);\n        update(u);\n        return u;\n    }\n    else {\n        pushdown(v);\n        t[v].l = Merge(u, t[v].l);\n        update(v);\n        return v;\n    }\n}\nint main() {\n    n = read(), m = read();\n    for (register int i = 1; i <= n; i++)\n        root = Merge(root, New(0));\n    while (m--) {\n        int opt, l, r, v, x, y, z;\n        opt = read();\n        if (opt == 1) {\n            l = read(), r = read(), v = read();\n            Split(root, r, x, y);\n            Split(x, l - 1, x, z);\n            t[z].add += v;\n            t[z].val += v;\n            t[z].max += v;\n            root = Merge(Merge(x, z), y);\n        }\n        if (opt == 2) {\n            l = read(), r = read();\n            Split(root, r, x, y);\n            Split(x, l - 1, x, z);\n            t[z].tag ^= 1;\n            root = Merge(Merge(x, z), y);\n        }\n        if (opt == 3) {\n            l = read(), r = read();\n            Split(root, r, x, y);\n            Split(x, l - 1, x, z);\n            printf(\"%d\\n\", t[z].max);\n            root = Merge(Merge(x, z), y);\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1560859688,
        "uid": 31069,
        "name": "Agakiss",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "[\u9898\u89e3\u7b2c\u4e00\u65f6\u95f4\u53d1\u5e03\u5728\u672c\u4eba\u7684\u535a\u5ba2](https://www.lzoi.org/article.php?id=234e0808881970854f0804bb13faca73)\n\n\u8fd9\u9053\u9898\u548c\u6587\u827a\u5e73\u8861\u6811\u6709\u70b9\u76f8\u4f3c \u5c31\u662f\u591a\u4e86\u533a\u95f4\u52a0\u4e0a\u67d0\u4e2a\u503c\n\u5176\u5b9e\u505a\u6cd5\u5f88\u7b80\u5355 \u5c31\u662f\u628a\u533a\u95f4\u63d0\u53d6\u51fa\u6765 \u7136\u540e\u4e0b\u653e\u6807\u8bb0\n\n\u5728\u6811\u4e2d\u52a0\u5165\u4e24\u4e2a\u8f85\u52a9\u8282\u70b9 \u4f46\u8fd9\u4e24\u4e2a\u8f85\u52a9\u8282\u70b9\u7684\u533a\u95f4\u6700\u5927\u503c\u6807\u8bb0\u5f97\u662f-inf\n\u8fd9\u4e24\u4e2a\u70b9\u4e2d\u5e8f\u904d\u5386\u7684\u6392\u540d\u5c31\u662f1\u548cn+1\n\n\u63d0\u53d6\u533a\u95f4: \u73b0\u5c06\u6392\u540d\u4e3ax\u7684\u65cb\u8f6c\u5230\u6839\u8282\u70b9 \u518d\u628a\u6392\u540d\u4e3ay+2\u7684\u70b9\u65cb\u8f6c\u5230x\u7684\u53f3\u513f\u5b50\ny+2\u7684\u5de6\u513f\u5b50\u90a3\u9897\u6811\u5c31\u662f\u8981\u6c42\u7684\u533a\u95f4\u4e86\n\n\u533a\u95f4\u52a0: \u5148\u63d0\u53d6\u533a\u95f4 \u518d\u533a\u95f4\u7684\u6839\u8282\u70b9\u4fee\u6539\u503c \u7136\u540e\u4e0b\u653e\u4fee\u6539\u6807\u8bb0 \u67e5\u8be2\u65f6\u518d\u4fee\u6539\n\n\u533a\u95f4\u7ffb\u8f6c: \u5148\u63d0\u53d6\u533a\u95f4 \u7136\u540e\u4e0b\u653e\u7ffb\u8f6c\u6807\u8bb0 \u67e5\u8be2\u65f6\u518d\u7ffb\u8f6c\n\n\u5e9f\u8bdd\u5c31\u90a3\u4e48\u591a \u4e0b\u9762\u4e0a\u4ee3\u7801 306\u884c\u3002\u3002\u3002 (\u6709\u4e8c\u5341\u591a\u884c\u662f\u8c03\u8bd5\u9057\u7559\u4e0b\u6765\u7684233)\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF=233333333;\n\nnamespace _Splay{\n    class SplayNode{\n        public:\n            \n            SplayNode *L,*R,*F;\n            int key,tag,size,maxc,data;\n            \n            SplayNode(int k){\n            \tdata=0;\n            \tmaxc=0;\n                tag=0;\n                key=k;\n                L=R=F=NULL;\n            }\n            \n            void RightRotate();\n            void LeftRotate();\n            SplayNode* Find(int k);\n            SplayNode* Insert(int k);\n    };\n\n    void PushUp(SplayNode *G){\n        if(G->L==NULL&&G->R==NULL){\n        \tG->size=1;\n        \tG->maxc=G->key;\n        }else if(G->L==NULL){\n        \tG->size=G->R->size+1;\n\t\t\tG->maxc=G->R->maxc;\n        }else if(G->R==NULL){\n            G->size=G->L->size+1;\n\t\t\tG->maxc=G->L->maxc;\n        }else{\n            G->size=G->L->size+G->R->size+1;\n        \tG->maxc=max(G->L->maxc,G->R->maxc);\n\t\t}\n        G->maxc=max(G->key,G->maxc);\n    }\n    \n    void PushDown(SplayNode *G){\n        if(G->tag){\n\t\t\tswap(G->L,G->R);\n            if(G->L!=NULL){\n                G->L->tag^=1;\n            }\n            if(G->R!=NULL){\n                G->R->tag^=1;\n            }\n            G->tag^=1;            \t\n\t\t}\n\t\tif(G->data){\n\t\t\tif(G->L!=NULL){\n\t\t\t\tG->L->data+=G->data;\n\t\t\t\tG->L->key+=G->data;\n\t\t\t\tG->L->maxc+=G->data;\n\t\t\t}\n\t\t\tif(G->R!=NULL){\n\t\t\t\tG->R->data+=G->data;\n\t\t\t\tG->R->key+=G->data;\n\t\t\t\tG->R->maxc+=G->data;\t\t\t\t\n\t\t\t}\n\t\t\tG->data=0;\n\t\t}\n    }\n    \n    void Splay(SplayNode *X,SplayNode *S){\n        SplayNode *SF=S->F;\n        while(X->F!=SF){\n            SplayNode *Y=X->F; \n            SplayNode *Z=Y->F; \n        \tif(Z==SF){\n                if(Y->L==X){\n                    X->RightRotate();\n                }else{\n                    X->LeftRotate();\n                }\n        \t}else{\n                if(Y->L==X&&Z->L==Y){\n                    Y->RightRotate();\n                    X->RightRotate();\n                }\n                if(Y->R==X&&Z->R==Y){\n                    Y->LeftRotate();\n                    X->LeftRotate();\n                }\n                if(Y->L==X&&Z->R==Y){\n                    X->RightRotate();\n                    X->LeftRotate();\n                }\n                if(Y->R==X&&Z->L==Y){\n                    X->LeftRotate();\n                    X->RightRotate(); \n                }\t\t\t\t\n            } \n        }\n    }\t \n    \n    void SplayNode::RightRotate(){\n        SplayNode *y=this->F;\n        this->F=y->F;\n        if(F!=NULL){\n            if(F->L==y){\n                F->L=this;\n            }else{\n                F->R=this;\n            }\n        }\n        if(R!=NULL){\n            R->F=y;\n        }\n        y->L=R;\n        y->F=this;\n        this->R=y;\n        PushUp(y);PushUp(this);\n    }\n\n    void SplayNode::LeftRotate(){\n        SplayNode *y=this->F;\n        this->F=y->F;\n        if(F!=NULL){\n            if(F->L==y){\n                F->L=this;\n            }else{\n                F->R=this;\n            }\n        }\n        if(L!=NULL){\n            L->F=y;\n        }\n        y->R=L;\n        y->F=this;\n        this->L=y;\n        PushUp(y);PushUp(this);\n    }\t\n\n    SplayNode* SplayNode::Find(int k){\n        PushDown(this);\t\t\n//    \tprintf(\"%d %dth! %d \\n\",this->key,k,this->size);\n    \tif(this->L==NULL){\n//    \t\tprintf(\"233333?\\n\");\n    \t\tif(k==1){\n    \t\t\treturn this;\n            }\n            if(R==NULL){\n                return NULL;\n            }\n            return R->Find(k-1);\n        }else{\n            if(this->L->size+1==k){\n                return this;\n            }\n            if(k<this->L->size+1){\n//            \tprintf(\"L!!!!!!!!\");\n                return L->Find(k);\n            }else{\n                if(R==NULL){\n                    return NULL;\n                }\n                return R->Find(k-this->L->size-1);\n            }\t\t\n        }\n\n    }\n    \n    SplayNode* SplayNode::Insert(int k){\n        if(k<=key){\n            if(L==NULL){\n                L=new SplayNode(k);\n                L->F=this;\n                return L; \n            }else{\n                return L->Insert(k);\n            }\n        }else{\n            if(R==NULL){\n                R=new SplayNode(k);\n                R->F=this;\n                return R; \n            }else{\n                return  R->Insert(k); \n            }\n        }\n    }\n    \n    SplayNode *Root,*Fx,*Fy;int cnt;\n    \n    void AddSum(int x,int y,int val){\n//    \tprintf(\"find root = %d\\n\",Root->key);\n        SplayNode *TempA=Root->Find(x);\n//       printf(\"find %d = %d\\n\",y+1,TempA->key);\n        Splay(TempA,Root);\n        Root=TempA;\n        SplayNode *TempB=Root->Find(y+2);\n//        printf(\"find %d = %d\",x-1,TempB->key);\n        Splay(TempB,Root->R);\n        //Root=TempB;\n        Root->R->L->data+=val; \n        Root->R->L->key+=val;\n        Root->R->L->maxc+=val;\n    }\n    \n    void Turn(int x,int y){\n//    \tprintf(\"find root = %d\\n\",Root->key);\n        SplayNode *TempA=Root->Find(x);\n//       printf(\"find %d = %d\\n\",y+1,TempA->key);\n        Splay(TempA,Root);\n        Root=TempA;\n        SplayNode *TempB=Root->Find(y+2);\n//        printf(\"find %d = %d\",x-1,TempB->key);\n        Splay(TempB,Root->R);\n        //Root=TempB;\n        Root->R->L->tag^=1; \n    }\n    \n    int GetMax(int x,int y){\n//    \tprintf(\"find root = %d\\n\",Root->key);\n        SplayNode *TempA=Root->Find(x);\n//       printf(\"find %d = %d\\n\",y+1,TempA->key);\n        Splay(TempA,Root);\n        Root=TempA;\n        SplayNode *TempB=Root->Find(y+2);\n//        printf(\"find %d = %d\",x-1,TempB->key);\n        Splay(TempB,Root->R);\n        //Root=TempB;\n        return Root->R->L->maxc; \n    }    \n    \n    void SplayInsert(int k){\n        if(!cnt){\n            Root=new SplayNode(k);\n            Root->size=1;\n        }else{\n            SplayNode *Temp=Root->Insert(k);\n            Splay(Temp,Root);\n            Root=Temp;\n            PushUp(Root);\n        }\n        cnt++;\n    }\n    \n\n    void Print(SplayNode *G){\n        PushDown(G);\n        if(G->L!=NULL){\n            Print(G->L);\n        }\n        if(G!=Fx&&G!=Fy){\n/*        if(G->L)\n        \tprintf(\"L= %d \",G->L->key);\n        if(G->R)\n        \tprintf(\"R= %d \",G->R->key);\n        printf(\"key=%d size=%d\\n\",G->key,G->size);\n            \n        //*/\n            printf(\"%d \",G->key);\n        }\n        if(G->R!=NULL){\n            Print(G->R);\n        }\n    }\n}\n\nint n,m;\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<=n+1;i++){\n        _Splay::SplayInsert(0);\n    }\n/*    _Splay::SplayNode *T=_Splay::Root->Find(4);\n    _Splay::Splay(T,_Splay::Root);\n    _Splay::Root=T;\n    cout<<T->L->size<<\" \"<<T->R->size<<endl;*/\n    _Splay::Fx=_Splay::Root->Find(1); \n    _Splay::Fx->maxc=-INF;\n    _Splay::Fy=_Splay::Root->Find(n+2);\n\t_Splay::Fy->maxc=-INF;\n    //cout<<_Splay::Root->size<<endl;\n    //_Splay::Print(_Splay::Root);\n    //cout<<endl;\n    for(int i=1;i<=m;i++){\n        int id,x,y,val;\n        scanf(\"%d\",&id);\n        if(id==1){\n        \tscanf(\"%d%d%d\",&x,&y,&val);\n        \t_Splay::AddSum(x,y,val);\n\t\t}else if(id==2){\n\t        scanf(\"%d%d\",&x,&y);\n        \t_Splay::Turn(x,y);\t\t\n\t\t}else if(id==3){\n\t        scanf(\"%d%d\",&x,&y);\n        \t//cout<<_Splay::GetMax(x,y)<<endl;\n\t\t\tprintf(\"%d\\n\",_Splay::GetMax(x,y));\t\t\t\t\n\t\t}\n\t\t//cout<<\" id=\"<<id<<\" x=\"<<x<<\" y=\"<<y<<\" val=\"<<val<<endl;\n        //_Splay::Print(_Splay::Root);\n        //cout<<endl; \n    }\n   //_Splay::Print(_Splay::Root);\n    return 0;\t\n}\n\n```\n\u6307\u9488\u5199\u7684 \u662f\u4e0d\u662f\u770b\u8d77\u6765\u5f88\u723d 2333",
        "postTime": 1531901562,
        "uid": 60467,
        "name": "Cloud_Shadow",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    },
    {
        "content": "\u4f5c\u4e3a\u4e00\u4e2a\u5e73\u8861\u6811\u840c\u65b0\uff0c\u80fdAC\u8fd9\u9053\u9898\u4e5f\u662f\u5f88\u4e0d\u5bb9\u6613\n\n\u601d\u8def\u4e3b\u8981\u53c2\u8003\u4e86P2042\u7ef4\u62a4\u6570\u5217\u9898\u89e3\u4e2dI_AM_HelloWord\u5927\u4f6c\u7684\u8bb2\u89e3\n\n\u5efa\u7acb\u54e8\u5175\u8282\u70b91\u548cn+2\uff0c\u5c06\u64cd\u4f5c\u5e8f\u5217\u6574\u4f53\u540e\u79fb\u4e00\u4f4d\n\n\u4e4b\u540e\u5efa\u6811\uff0c\u5728\u5efa\u6811\u4e2d\u9884\u5904\u7406\u5e73\u8861\u6811\u5404\u4e2a\u8282\u70b9\u7684val\u548cmaxn\n\n\u63a5\u4e0b\u6765\u5206\u6790\u9898\u76ee\u4e2d\u7684\u4e09\u79cd\u64cd\u4f5c\n\n\u5bf9\u4e00\u4e2a\u533a\u95f4\u8fdb\u884c\u64cd\u4f5c\uff0c\u53ef\u4ee5\u770b\u6210\u4ece\u5de6\u7aef\u70b9L\u5f00\u59cb\u8fde\u7eed\u5904\u7406R-L+1\u7684\u70b9\n\n\u4e8e\u662f\u6211\u4eec\u7528\u4e00\u4e2asplit\u64cd\u4f5c\u627e\u5230\u5728\u5e73\u8861\u6811\u4e2d\u5e8f\u904d\u5386\u4e2d\u5b9e\u9645\u9700\u8981\u64cd\u4f5c\u7684\u533a\u95f4\n\n\u7136\u540e\u5728reverse\uff0cchange\u548cgetmax\u64cd\u4f5c\u4e2d\u76f4\u63a5\u8c03\u7528\u5373\u53ef\n\n\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u64cd\u4f5c\u5206\u522b\u7ef4\u62a4\u53cd\u8f6c\u6807\u8bb0\uff0c\u52a0\u6cd5\u6807\u8bb0\uff0c\u533a\u95f4\u6700\u5927\u503c\n\n\u7531\u4e8e\u6bcf\u4e00\u6b21\u64cd\u4f5c\u90fd\u8981\u7528\u5230find\n\n\u6240\u4ee5\u76f4\u63a5\u5728find\u51fd\u6570\u4e2d\u4e0b\u4f20\u6807\u8bb0\u5c31\u53ef\u4ee5\u4e86\n\nps:maxn[0]\u8981\u521d\u59cb\u5316\u4e3a-inf\uff0cinf\u4e00\u5b9a\u8981\u5f00\u6781\u5927\u503c ~~\uff08\u5426\u5219\u5c31\u4f1a\u50cf\u6211\u4e00\u6837WA\uff09~~\n\n\u4e11\u964b\u7684\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define ls ch[now][0]\n#define rs ch[now][1]\nusing namespace std;\nconst int N=1e5+5,inf=2147483640;\nint n,m,cnt,root,a[N],tag[N],maxn[N],ch[N][2],val[N],f[N],size[N],id[N];\nbool rev[N];\ninline int read()\n{\n\tint x=0,w=1;\n\tchar c=getchar();\n\twhile (!isdigit(c)&&c!='-') c=getchar();\n\tif (c=='-') c=getchar(),w=-1;\n\twhile (isdigit(c))\n\t{\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*w;\n}\ninline bool get(int x)\n{\n\treturn ch[f[x]][1]==x;\n}\ninline void update(int now)\n{\n\tsize[now]=size[ls]+size[rs]+1;\n\tmaxn[now]=max(val[now],max(maxn[ls],maxn[rs]));\n}\ninline void pushdown(int now)\n{\n\tif (rev[now])\n\t{\n\t\tif (ls) rev[ls]^=1,swap(ch[ls][0],ch[ls][1]);\n\t\tif (rs) rev[rs]^=1,swap(ch[rs][0],ch[rs][1]);\n\t\trev[now]=0;\n\t}\n\tif (tag[now])\n\t{\n\t\tif (ls) tag[ls]+=tag[now],maxn[ls]+=tag[now],val[ls]+=tag[now];\n\t\tif (rs) tag[rs]+=tag[now],maxn[rs]+=tag[now],val[rs]+=tag[now];\n\t\ttag[now]=0;\n\t}\n}\nvoid build(int l,int r,int p)\n{\n\tint mid=(l+r)>>1,now=mid,pre=p;\n\tif (l==r)\n\t{\n\t\tmaxn[now]=a[l];\n\t\tsize[now]=1; rev[now]=0;\n\t}\n\tif (l<mid) build(l,mid-1,mid);\n\tif (mid<r) build(mid+1,r,mid);\n\tval[now]=a[mid]; f[now]=pre;\n\tupdate(now); ch[pre][mid>=p]=now;\n}\ninline void rotate(int x,int &k)\n{\n\tint y=f[x],z=f[y],t=get(x),w=ch[x][t^1];\n\tif (y==k) k=x; else ch[z][ch[z][1]==y]=x;\n\tch[y][t]=w; if (w) f[w]=y;\n\tch[x][t^1]=y; f[y]=x; f[x]=z;\n\tupdate(y); update(x);\n}\ninline void splay(int x,int &k)\n{\n\twhile (x!=k)\n\t{\n\t\tint y=f[x],z=f[y];\n\t\tif (y!=k) rotate(get(y)==get(x)?y:x,k);\n\t\trotate(x,k);\n\t}\n}\nint find(int now,int k)\n{\n\tpushdown(now);\n\tif (size[ls]==k-1) return now;\n\tif (size[ls]>=k) return find(ls,k);\n\treturn find(rs,k-size[ls]-1);\n}\ninline int split(int x,int tot)\n{\n\tint l=find(root,x),r=find(root,tot+2);\n\tsplay(l,root); splay(r,ch[root][1]);//\u627e\u5230[x+1,x+tot]\n\treturn ch[r][0];\n}\ninline void reverse(int x,int y)\n{\n\tint now=split(x,y),z=f[now];\n\trev[now]^=1; swap(ls,rs);\n\tupdate(z); update(f[z]);\n}\ninline void change(int x,int y,int v)\n{\n\tint now=split(x,y),z=f[now];\n\tval[now]+=v; tag[now]+=v; maxn[now]+=v;\n\tupdate(z); update(f[z]);\n}\ninline int getmax(int x,int y)\n{\n\treturn maxn[split(x,y)];\n}\nint main()\n{\n\tn=read(),m=read(); maxn[0]=a[1]=a[n+2]=-inf;\n\troot=(n+3)>>1; build(1,n+2,0);\n\twhile (m--)\n\t{\n\t\tint opt=read(),x=read(),y=read();\n\t\tif (opt==1) change(x,y,read());\n\t\tif (opt==2) reverse(x,y);\n\t\tif (opt==3) printf(\"%d\\n\",getmax(x,y)); \n\t}\n\treturn 0;\n}\n```",
        "postTime": 1522376850,
        "uid": 43471,
        "name": "Captain_Paul",
        "ccfLevel": 0,
        "title": "P4146 \u5e8f\u5217\u7ec8\u7ed3\u8005"
    },
    {
        "content": "(http://www.elijahqi.win/2018/01/22/bzoj1251-%E5%BA%8F%E5%88%97%E7%BB%88%E7%BB%93%E8%80%85/%20%E2%80%8E)\n\nhttp://blog.csdn.net/elijahqi/article/details/79128002\n\nDescription\n\n\n\u7f51\u4e0a\u6709\u8bb8\u591a\u9898\uff0c\u5c31\u662f\u7ed9\u5b9a\u4e00\u4e2a\u5e8f\u5217\uff0c\u8981\u4f60\u652f\u6301\u51e0\u79cd\u64cd\u4f5c\uff1aA\u3001B\u3001C\u3001D\u3002\u4e00\u770b\u53e6\u4e00\u9053\u9898\uff0c\u53c8\u662f\u4e00\u4e2a\u5e8f\u5217 \u8981\u652f\u6301\u51e0\u79cd\u64cd\u4f5c\uff1aD\u3001C\u3001B\u3001A\u3002\u5c24\u5176\u662f\u6211\u4eec\u8fd9\u91cc\u7684\u67d0\u4eba\uff0c\u51fa\u6a21\u62df\u8bd5\u9898\uff0c\u5c45\u7136\u8fd8\u51fa\u4e86\u4e00\u9053\u8fd9\u6837\u7684\uff0c\u771f\u662f\u6ca1\u6280\u672f\u542b\u91cf\u2026\u2026\u8fd9\u6837 \u6211\u4e5f\u51fa\u4e00\u9053\u9898\uff0c\u6211\u51fa\u8fd9\u4e00\u9053\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u8ba9\u5927\u5bb6\u4ee5\u540e\u505a\u8fd9\u79cd\u9898\u76ee\u6709\u4e00\u4e2a\u201c\u5e93\u201d\u53ef\u4ee5\u4f9d\u9760\uff0c\u6ca1\u6709\u4ec0\u4e48\u5176\u4ed6\u7684\u610f\u601d\u3002\u8fd9\u9053\u9898\u76ee \u5c31\u53eb\u5e8f\u5217\u7ec8\u7ed3\u8005\u5427\u3002 \u3010\u95ee\u9898\u63cf\u8ff0\u3011 \u7ed9\u5b9a\u4e00\u4e2a\u957f\u5ea6\u4e3aN\u7684\u5e8f\u5217\uff0c\u6bcf\u4e2a\u5e8f\u5217\u7684\u5143\u7d20\u662f\u4e00\u4e2a\u6574\u6570\uff08\u5e9f\u8bdd\uff09\u3002\u8981\u652f\u6301\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\uff1a 1. \u5c06[L,R]\u8fd9\u4e2a\u533a\u95f4\u5185\u7684\u6240\u6709\u6570\u52a0\u4e0aV\u3002 2. \u5c06[L,R]\u8fd9\u4e2a\u533a\u95f4\u7ffb\u8f6c\uff0c\u6bd4\u59821 2 3 4\u53d8\u62104 3 2 1\u3002 3. \u6c42[L,R]\u8fd9\u4e2a\u533a\u95f4\u4e2d\u7684\u6700\u5927\u503c\u3002 \u6700\u5f00\u59cb\u6240\u6709\u5143\u7d20\u90fd\u662f0\u3002\n\nInput\n\n\u7b2c\u4e00\u884c\u4e24\u4e2a\u6574\u6570N\uff0cM\u3002M\u4e3a\u64cd\u4f5c\u4e2a\u6570\u3002 \u4ee5\u4e0bM\u884c\uff0c\u6bcf\u884c\u6700\u591a\u56db\u4e2a\u6574\u6570\uff0c\u4f9d\u6b21\u4e3aK\uff0cL\uff0cR\uff0cV\u3002K\u8868\u793a\u662f\u7b2c\u51e0\u79cd\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\u7b2c1\u79cd\u64cd\u4f5c\u5219K\u540e\u9762\u53ea\u6709\u4e24\u4e2a\u6570\u3002\n\nOutput\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u7b2c3\u79cd\u64cd\u4f5c\uff0c\u7ed9\u51fa\u6b63\u786e\u7684\u56de\u7b54\u3002\n\nSample Input\n\n4 4\n1 1 3 2\n\n1 2 4 -1\n\n2 1 3\n3 2 4\n\n\nSample Output\n\n2\n\u3010\u6570\u636e\u8303\u56f4\u3011\n\n\n\nN<=50000\uff0cM<=100000\u3002\n\n\u5e73\u8861\u6811 splay\u7684\u4e00\u4e9b\u57fa\u672c\u64cd\u4f5c \u6ce8\u610f0\u53f7\u8282\u70b9\u7684max1\u9700\u8981\u7ed9-inf\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define N 55000\n#define inf 0x3f3f3f3f \nusing namespace std;\ninline char gc(){\n    static char now[1<<16],*S,*T;\n    if (T==S){T=(S=now)+fread(now,1,1<<16,stdin);if (T==S) return EOF;}\n    return *S++;\n}\ninline int read(){\n    int x=0,f=1;char ch=gc();\n    while(ch<'0'||ch>'9') {if (ch=='-') f=-1;ch=gc();}\n    while(ch<='9'&&ch>='0') x=x*10+ch-'0',ch=gc();\n    return x*f;\n}\nint size[N],n,max1[N],c[N][2],rev[N],tag[N],fa[N],v[N],root,m;\ninline void update(int x){\n    size[x]=size[c[x][0]]+size[c[x][1]]+1;\n    max1[x]=max(max(max1[c[x][0]],max1[c[x][1]]),v[x]);\n}\ninline void pushdown(int x){\n    int l=c[x][0],r=c[x][1];\n    if (tag[x]){\n        if (l) tag[l]+=tag[x],max1[l]+=tag[x],v[l]+=tag[x];\n        if (r) tag[r]+=tag[x],max1[r]+=tag[x],v[r]+=tag[x];tag[x]=0;\n    }\n    if (rev[x]){\n        if (l) rev[l]^=1,swap(c[l][1],c[l][0]);\n        if (r) rev[r]^=1,swap(c[r][1],c[r][0]);rev[x]=0;\n    }\n}\ninline void build(int f,int l,int r){\n    if (l>r) return;\n    if (l==r){size[l]=1;fa[l]=f;c[f][l>f]=l;return;}\n    int mid=l+r>>1;build(mid,l,mid-1);build(mid,mid+1,r);\n    fa[mid]=f;c[f][mid>f]=mid;update(mid);\n}\ninline int find(int x,int sz){\n    pushdown(x);\n    int l=c[x][0],r=c[x][1];\n    if (size[l]+1==sz) return x;\n    if (sz<=size[l]) return find(l,sz);else return find(r,sz-size[l]-1);\n}\ninline void rotate(int x,int &tar){\n    int y=fa[x],z=fa[y];\n    int l=c[y][1]==x,r=l^1;\n    if (y==tar) tar=x;else c[z][c[z][1]==y]=x;\n    fa[c[x][r]]=y;fa[y]=x;fa[x]=z;\n    c[y][l]=c[x][r];c[x][r]=y;update(y);update(x);\n}\ninline void splay(int x,int &tar){\n    while(x!=tar){\n        int y=fa[x],z=fa[y];\n        if (y!=tar){\n            if ((c[y][0]==x)^(c[z][0]==y)) rotate(x,tar);else rotate(y,tar);\n        }rotate(x,tar);\n    }\n}\ninline int split(int x,int y){\n    int xx=find(root,x),yy=find(root,y);\n    splay(yy,root);splay(xx,c[root][0]);return c[xx][1];\n}\ninline void print(int x){\n    if (c[x][0]) print(c[x][0]);\n    printf(\"%d %d %d %d %d %d %d\\n\",x,c[x][0],c[x][1],v[x],max1[x],tag[x],rev[x]);\n    if (c[x][1]) print(c[x][1]);\n}\nint main(){\n    freopen(\"bzoj1251.in\",\"r\",stdin);\n    n=read();m=read();build(0,1,n+2);root=n+3>>1;\n    max1[0]=-inf;\n    for (int i=1;i<=m;++i){\n        int op=read();//print(root);puts(\"fds\");\n        if (op==1){\n            int x=read(),y=read(),vv=read();\n            int tmp=split(x,y+2);tag[tmp]+=vv;v[tmp]+=vv;max1[tmp]+=vv;\n        }\n        if (op==2){\n            int x=read(),y=read();\n            int tmp=split(x,y+2);rev[tmp]^=1;swap(c[tmp][0],c[tmp][1]);\n        }    \n        if (op==3){\n            int x=read(),y=read();\n            int tmp=split(x,y+2);printf(\"%d\\n\",max1[tmp]);\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1516683397,
        "uid": 5037,
        "name": "elijahqi",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4146 \u3010\u5e8f\u5217\u7ec8\u7ed3\u8005\u3011"
    }
]