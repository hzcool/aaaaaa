[
    {
        "content": "\u505a\u8fd9\u79cd\u9898\u5148\u5206\u6790\u4e00\u4e0b\u6bcf\u4e2a\u64cd\u4f5c\uff1a\n- $0$ \u64cd\u4f5c\u662f\u5c06\u4ece $x$ \u5f00\u59cb\u7684\u7b2c\u4e00\u5757\u5de6\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $L$ \u548c\u7b2c\u4e00\u5757\u53f3\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $R$ \u8fd9\u4e00\u6bb5\u533a\u95f4\u8d4b\u503c\u4e3a $h$\uff0c\u82e5 $x$ \u7684\u6c34\u4f4d\u5df2\u4e0d\u5c0f\u4e8e $h$ \u5219\u4e0d\u64cd\u4f5c\u3002\n- $1$ \u64cd\u4f5c\u662f\u5c06\u4ece $x$ \u5f00\u59cb\u7684\u7b2c\u4e00\u5757\u5de6\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $L$ \u548c\u7b2c\u4e00\u5757\u53f3\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $R$ \u8fd9\u4e00\u6bb5\u533a\u95f4\uff0c$\\forall i\\in[L,R]$ \u8d4b\u503c\u4e3a\u4ece $i$ \u5230 $x$ \u7684\u9694\u677f\u9ad8\u5ea6\u6700\u5927\u503c\u3002\n- $2$ \u64cd\u4f5c\u662f\u5355\u70b9\u4fee\u6539\u4e00\u5757\u9694\u677f\u7684\u9ad8\u5ea6\u3002\n- $3$ \u64cd\u4f5c\u662f\u5355\u70b9\u67e5\u8be2\u6c34\u4f4d\u9ad8\u5ea6\u3002\n\n\u77e5\u9053\u4e86\u8fd9\u4e9b\uff0c\u76f4\u63a5\u7528\u4e00\u68f5\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5de6\u9694\u677f\u6700\u503c\uff0c\u53f3\u9694\u677f\u6700\u503c\uff0c\u533a\u95f4\u6c34\u4f4d\u9ad8\u5ea6\u5373\u53ef\u3002**\u6ce8\u610f\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u4e0b\u53d1\u6807\u8bb0\u65f6\u9700\u8981\u65b0\u5efa\u65b0\u7684\u8282\u70b9**\uff08\n\n```cpp\nstruct SegmentTree {\n\tint tot;\n\tint sonL[8000005],sonR[8000005];\n\tint lmx[8000005],rmx[8000005],val[8000005],tag[8000005];\n\tinline int max(const int &x,const int &y) {return x>y? x:y;}\n\tinline void pushup(int p) {\n\t\tlmx[p]=max(lmx[sonL[p]],lmx[sonR[p]]);\n\t\trmx[p]=max(rmx[sonL[p]],rmx[sonR[p]]);\n\t}\n\tinline int newNode(int lst) {int cur=++tot; sonL[cur]=sonL[lst]; sonR[cur]=sonR[lst]; val[cur]=val[lst]; tag[cur]=tag[lst]; lmx[cur]=lmx[lst]; rmx[cur]=rmx[lst]; return cur;} \n\tinline void spread(int p) {\n\t\tif(tag[p]) {\n\t\t\tsonL[p]=newNode(sonL[p]); sonR[p]=newNode(sonR[p]);\n\t\t\tif(tag[p]==1) {\n\t\t\t\ttag[sonL[p]]=tag[sonR[p]]=1;\n\t\t\t\tval[sonL[p]]=val[sonR[p]]=val[p];\n\t\t\t}\n\t\t\telse if(tag[p]==2) {\n\t\t\t\ttag[sonL[p]]=tag[sonR[p]]=2; val[sonR[p]]=val[p];\n\t\t\t\tval[sonL[p]]=max(val[p],lmx[sonR[p]]);\n\t\t\t}\n\t\t\telse if(tag[p]==3) {\n\t\t\t\ttag[sonL[p]]=tag[sonR[p]]=3; val[sonL[p]]=val[p];\n\t\t\t\tval[sonR[p]]=max(val[p],rmx[sonL[p]]);\n\t\t\t}\n\t\t\ttag[p]=0;\n\t\t}\n\t}\n\tinline void build(int &p,int l,int r) {\n\t\tp=++tot; val[p]=0;\n\t\tif(l==r) {lmx[p]=h[l-1]; rmx[p]=h[r]; return;}\n\t\tint mid=l+r>>1; build(sonL[p],l,mid); build(sonR[p],mid+1,r);\n\t\tpushup(p);\n\t}\n\tinline void init() {tot=0; build(rt[0],1,n);}\n\tinline int getL(int p,int l,int r,int x,int val) {\n//\t\tprintf(\"L=%d %d %d\\n\",l,r,lmx[p]);\n\t\tif(lmx[p]<val) return -1;\n\t\tif(l==r) return l;\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(x<=mid) {return getL(sonL[p],l,mid,x,val);}\n\t\telse {\n\t\t\tint res=getL(sonR[p],mid+1,r,x,val);\n\t\t\tif(res==-1) return getL(sonL[p],l,mid,x,val); \n\t\t\treturn res;\n\t\t} \n\t}\n\tinline int getR(int p,int l,int r,int x,int val) {\n//\t\tprintf(\"R=%d %d %d\\n\",l,r,rmx[p]);\n\t\tif(rmx[p]<val) return -1;\n\t\tif(l==r) return l;\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(x>mid) {return getR(sonR[p],mid+1,r,x,val);}\n\t\telse {\n\t\t\tint res=getR(sonL[p],l,mid,x,val);\n\t\t\tif(res==-1) return getR(sonR[p],mid+1,r,x,val);\n\t\t\treturn res;\n\t\t}\n\t}\n\tinline void modify(int &p,int l,int r,int L,int R,int d) {\n\t\tp=newNode(p);\n\t\tif(L<=l&&r<=R) {tag[p]=1; val[p]=d; return;}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(L<=mid) modify(sonL[p],l,mid,L,R,d);\n\t\tif(R>mid) modify(sonR[p],mid+1,r,L,R,d);\n\t}\n\tinline void modifyL(int &p,int l,int r,int L,int R,int &tmp) {\n\t\tp=newNode(p);\n\t\tif(L<=l&&r<=R) {\n\t\t\ttag[p]=2; val[p]=tmp;\n\t\t\ttmp=max(tmp,lmx[p]);\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(R>mid) modifyL(sonR[p],mid+1,r,L,R,tmp);\n\t\tif(L<=mid) modifyL(sonL[p],l,mid,L,R,tmp);\n\t}\n\tinline void modifyR(int &p,int l,int r,int L,int R,int &tmp) {\n\t\tp=newNode(p);\n\t\tif(L<=l&&r<=R) {\n\t\t\ttag[p]=3; val[p]=tmp;\n\t\t\ttmp=max(tmp,rmx[p]);\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(L<=mid) modifyR(sonL[p],l,mid,L,R,tmp);\n\t\tif(R>mid) modifyR(sonR[p],mid+1,r,L,R,tmp);\n\t}\n\tinline void modifyB(int &p,int l,int r,int x,int d,int opt) {\n\t\tp=newNode(p);\n\t\tif(l==r) {\n\t\t\topt? (rmx[p]=d):(lmx[p]=d); \n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1; spread(p); \n\t\tif(x<=mid) modifyB(sonL[p],l,mid,x,d,opt);\n\t\telse modifyB(sonR[p],mid+1,r,x,d,opt);\n\t\tpushup(p);\n\t}\n\tinline int ask(int p,int l,int r,int x) {\n\t\tif(l==r) {return val[p];}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(x<=mid) return ask(sonL[p],l,mid,x);\n\t\telse return ask(sonR[p],mid+1,r,x);\n\t}\n}SGT;\nint main() {\n\tn=read(); int Q=read(); h[0]=h[n]=inf;\n\tfor(register int i=1;i<n;++i) h[i]=read();\n\tSGT.init(); //printf(\"init\\n\");\n\tfor(register int round=1;round<=Q;++round) {\n\t\tint op=read(),vsr=read(),x=read();\n\t\trt[round]=rt[vsr];\n//\t\tprintf(\"a=\");\n//\t\tfor(register int i=1;i<=n;++i) printf(\"%d \",SGT.ask(rt[round],1,n,i));printf(\"\\n\");\n//\t\tint L=SGT.getL(rt[round],1,n,4,3),R=SGT.getR(rt[round],1,n,4,3);\t\t\t\n//\t\tprintf(\"SGT=%d %d\\n\",L,R);\n\t\tif(op==0) {\n\t\t\tint val=read();\n//\t\t\tprintf(\"???\\n\");\n\t\t\tif(SGT.ask(rt[round],1,n,x)<val) {\n//\t\t\t\tprintf(\"???\\n\");\n\t\t\t\tint L=SGT.getL(rt[round],1,n,x,val),R=SGT.getR(rt[round],1,n,x,val);\t\t\t\n//\t\t\t\tprintf(\"SGT=%d %d\\n\",L,R);\n\t\t\t\tSGT.modify(rt[round],1,n,L,R,val);\n\t\t\t} \n\t\t}\n\t\telse if(op==1) {\n\t\t\tint val=SGT.ask(rt[round],1,n,x),tmpVal=0;\n\t\t\tint L=SGT.getL(rt[round],1,n,x,val),R=SGT.getR(rt[round],1,n,x,val);\n\t\t\ttmpVal=0; SGT.modifyL(rt[round],1,n,L,x,tmpVal); \n\t\t\ttmpVal=0; SGT.modifyR(rt[round],1,n,x,R,tmpVal);\n\t\t}\n\t\telse if(op==2) {\n\t\t\tint val=read(); \n\t\t\tSGT.modifyB(rt[round],1,n,x+1,val,0);//lmx\n\t\t\tSGT.modifyB(rt[round],1,n,x,val,1);//rmx\n\t\t}\n\t\telse {printf(\"%d\\n\",SGT.ask(rt[round],1,n,x));}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1616546043,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P6794 \u3010[SNOI2020] \u6c34\u6c60\u3011"
    },
    {
        "content": "### \u524d\u8a00\uff1a\u8fd9\u662f\u6211\u4eec\u7b2c\u4e00\u5929\u6478\u5e95\u8d5b\u7684T4\uff0c\u53d1\u73b0 ~~\u6478\u5e95\u8d5b\u88ab\u6253\u6210\u4e86\u7834\u96f6\u8d5b~~\n\n----\n\n\u770b\u5230\u8fd9\u9053\u9898\u6240\u8981\u6c42\u7684\u64cd\u4f5c\uff0c\u5f88\u660e\u663e\u662f\u4e00\u4e2a\u53ef\u6301\u4e45\u5316\u7684\u6570\u636e\u7ed3\u6784\uff0c ~~\u90fd\u5230\u4e86\u505a\u8fd9\u4e2a\u6c34\u5e73\u7684\u9898\u76ee\uff0c\u4e0d\u4f1a\u770b\u4e0d\u51fa\u6765\u5427~~\uff0c\u90a3\u4e48\u9898\u76ee\u4e2d\u6d89\u53ca\u5230\u5355\u70b9\u4fee\u6539\u3001\u5355\u70b9\u67e5\u8be2\u3001\u533a\u95f4\u4fee\u6539\uff0c\u6240\u4ee5\u6211\u4eec\u81ea\u7136\u800c\u7136\u7684\u53ef\u4ee5\u60f3\u5230\u4f7f\u7528\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u6765\u8fdb\u884c\u64cd\u4f5c\u3002\n\n+ \u5bf9\u4e8e\u64cd\u4f5c `0`\uff0c\u662f\u5c06\u4ece $x$ \u5f00\u59cb\u5411\u5de6\u7b2c\u4e00\u5757\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $L$ \u548c\u5411\u53f3\u7b2c\u4e00\u5757\u9694\u677f\u9ad8\u5ea6 $\\leq h$ \u7684 $R$\uff0c\u8fd9\u4e00\u533a\u95f4\u8d4b\u503c\u6210 $x$\uff0c\u4f46\u662f $x$ \u7684\u6c34\u4f4d\u82e5\u662f\u5df2\u7ecf\u5927\u4e8e $h$ \u4e86\u90a3\u4e48\u5c31\u4e0d\u8fdb\u884c\u64cd\u4f5c\u4e86\u3002\n+ \u5bf9\u4e8e\u64cd\u4f5c `1`\uff0c\u662f\u5c06\u4ece $x$ \u5f00\u59cb\u5411\u5de6\u7b2c\u4e00\u5757\u9694\u677f\u9ad8\u5ea6 $\\geq h$ \u7684 $L$ \u548c\u5411\u53f3\u7b2c\u4e00\u5757\u9694\u677f\u9ad8\u5ea6 $\\leq h$ \u7684 $R$\uff0c\u5c06\u4ece $L$ \u5230 $R$ \u7684\u6bcf\u4e00\u4e2a\u683c\u5b50\u7684\u503c\u8d4b\u6210\u5230 $x$ \u8fd9\u4e00\u8def\u5f84\uff08\u533a\u95f4\uff09\u9694\u677f\u7684\u6700\u5927\u503c\u3002\n+ \u5bf9\u4e8e\u64cd\u4f5c `2`\uff0c\u662f\u5355\u70b9\u4fee\u6539\u9694\u677f\u7684\u9ad8\u5ea6\u3002\n+ \u5bf9\u4e8e\u64cd\u4f5c `3`\uff0c\u662f\u5355\u70b9\u67e5\u8be2\u6c34\u4f4d\u9ad8\u5ea6\u3002\n\n\u90a3\u4e48\u6211\u4eec\u6700\u7ec8\u53ea\u9700\u8981\u7ef4\u62a4\uff1a\n1. \u533a\u95f4\u5de6\u9694\u677f\u6700\u503c\u3002\n2. \u533a\u95f4\u53f3\u9694\u677f\u6700\u503c\u3002\n3. \u533a\u95f4\u6c34\u4f4d\u9ad8\u5ea6\u3002\n\n**Code\uff1a**\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\nconst int MAXN=200005;\nconst int inf=2147483647;\nint h[MAXN],root[MAXN];\nint n,m,cnt;\nstruct tree{\n\tint ls,rs;\n\tint tag,val,lx,rx;\n}tr[MAXN<<6];\nvoid update(int now){\n\ttr[now].lx=max(tr[tr[now].ls].lx,tr[tr[now].rs].lx);\n\ttr[now].rx=max(tr[tr[now].ls].rx,tr[tr[now].rs].rx);\n}\nint newnode(int last){\n\tcnt++;\n\t tr[cnt].ls=tr[last].ls;\n  \t tr[cnt].rs=tr[last].rs;\n  \t tr[cnt].val=tr[last].val;\n  \t tr[cnt].tag=tr[last].tag;//\u61d2\u6807\u8bb0\n  \t tr[cnt].lx=tr[last].lx;\n     tr[cnt].rx=tr[last].rx;\n  \t return cnt;\n}\nvoid pd(int now){\n\tif(tr[now].tag){\n\t\ttr[now].ls=newnode(tr[now].ls);\n\t\ttr[now].rs=newnode(tr[now].rs);\n\t\tif(tr[now].tag==1){\n\t\t\tint ls=tr[now].ls;\n\t\t\tint rs=tr[now].rs;\n\t\t\ttr[ls].tag=1;\n\t\t\ttr[ls].val=tr[now].val;\n\t\t\ttr[rs].tag=1;\n\t\t\ttr[rs].val=tr[now].val;\n\t\t}\n\t\tif(tr[now].tag==2){\n\t\t\tint ls=tr[now].ls;\n\t\t\tint rs=tr[now].rs;\n\t\t\ttr[ls].tag=tr[rs].tag=2;\n\t\t\ttr[rs].val=tr[now].val;\n\t\t\ttr[ls].val=max(tr[now].val,tr[tr[now].rs].lx);\n\t\t}\n\t\tif(tr[now].tag==3){\n\t\t\tint ls=tr[now].ls;\n\t\t\tint rs=tr[now].rs;\n\t\t\ttr[ls].tag=tr[rs].tag=3;\n\t\t\ttr[ls].val=tr[now].val;\n\t\t\ttr[rs].val=max(tr[now].val,tr[tr[now].ls].rx);\n\t\t}\n\t\ttr[now].tag=0;\n\t}\n}\n\tvoid build(int &now,int l,int r){\n\t\tif(!now){\n\t\t\tnow=++cnt;\n\t\t}\n\t\tif(l==r){\n\t\t\ttr[now].lx=h[l-1];\n\t\t\ttr[now].rx=h[l];\n\t\t\treturn ;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(tr[now].ls,l,mid);\n\t\tbuild(tr[now].rs,mid+1,r);\n\t\tupdate(now);\n\t}\n\nint query(int now,int l,int  r,int k){\n\tif(l==k&&r==k){\n\t\treturn tr[now].val;\n\t}\n\tpd(now);\n\tint mid=(l+r)>>1;\n\tif(k<=mid){\n\t\treturn query(tr[now].ls,l,mid,k);\n\t}else{\n\t\treturn query(tr[now].rs,mid+1,r,k);\n\t}\n}\nint get_L(int now,int l,int r,int x,int h){\n\tif(tr[now].lx<h) return -1;\n   if(l==r) return l;\n   int mid=(l+r)>>1;\n   pd(now);\n   int ls=tr[now].ls,rs=tr[now].rs;\n   if(x<=mid) return get_L(ls,l,mid,x,h);\n   else\n   {\n   \t   int res=get_L(rs,mid+1,r,x,h);\n   \t   if(res==-1){\n   \t   \t\tres=get_L(ls,l,mid,x,h);\n   \t   }\n   \t   return res;\n   }\n}\nint get_R(int now,int l,int r,int x,int h){\n   if(tr[now].rx<h) return -1;\n   if(l==r) return l;\n   int mid=(l+r)>>1;\n   pd(now);\n   int ls=tr[now].ls,rs=tr[now].rs;\n   if(x>mid) return get_R(rs,mid+1,r,x,h);\n   else\n   {\n   \t   int res=get_R(ls,l,mid,x,h);\n   \t   if(res==-1){\n   \t    \tres=get_R(rs,mid+1,r,x,h);\n   \t   }\n   \t   return res;\n   }\n}\nvoid change(int &now,int L,int R,int l,int r,int val){\n\tnow=newnode(now);\n\tif(L>=l&&R<=r){\n\t\ttr[now].tag=1;\n\t\ttr[now].val=val;\n\t\treturn ;\n\t}\n\tpd(now);\n\tint mid=(L+R)>>1;\n\tif(l<=mid){\n\t\tchange(tr[now].ls,L,mid,l,r,val);\n\t}\n\tif(r>mid){\n\t\tchange(tr[now].rs,mid+1,R,l,r,val);\n\t}\n}\nvoid changel(int &now,int L,int R,int l,int r,int &val){\n\tnow=newnode(now);\n\tif(l<=L&&R<=r){\n\t\ttr[now].tag=2;\n\t\ttr[now].val=val;\n\t\tval=max(val,tr[now].lx);\n\t\treturn;\n\t}\n\tpd(now);\n\tint mid=(L+R)>>1;\n\t\n\tif(r>mid){\n\t\tchangel(tr[now].rs,mid+1,R,l,r,val);\n\t}if(l<=mid){\n\t\tchangel(tr[now].ls,L,mid,l,r,val);\n\t}\n}\nvoid changer(int &now,int L,int R,int l,int r,int &val){\n\tnow=newnode(now);\n\tif(L>=l&&R<=r){\n\t\ttr[now].tag=3;\n\t\ttr[now].val=val;\n\t\tval=max(val,tr[now].rx);\n\t\treturn ;\n\t}\n\tpd(now);\n\tint mid=(L+R)>>1;\n\tif(l<=mid){\n\t\tchanger(tr[now].ls,L,mid,l,r,val);\n\t}\n\tif(r>mid){\n\t\tchanger(tr[now].rs,mid+1,R,l,r,val);\n\t}\n}\nvoid changeh(int &now,int L,int R,int p,int k,int op){\n\tnow=newnode(now);\n\tif(L==R){\n\t\tif(op){\n\t\t\ttr[now].rx=k;\n\t\t}else{\n\t\t\ttr[now].lx=k;\n\t\t}\n\t\treturn ;\n\t}\n\tpd(now);\n\tint mid=(L+R)>>1;\n\tif(p<=mid){\n\t\tchangeh(tr[now].ls,L,mid,p,k,op);\n\t}else{\n\t\tchangeh(tr[now].rs,mid+1,R,p,k,op);\n\t}\n\tupdate(now);\n}\nint op,x,h1,p;\nint main(){\n\tcin>>n>>m;\n\th[0]=h[n]=inf;\n\tfor(int i=1;i<n;i++){\n\t\tcin>>h[i];\n\t}\n\tbuild(root[0],1,n);\n\tfor(int i=1;i<=m;i++){\n\t\tcin>>op>>p;\n\t\troot[i]=root[p];\n\t\tif(op==0){\n\t\t\tcin>>x>>h1;\n\t\t\tif(query(root[i],1,n,x)<h1){\n\t\t\t\tint L=get_L(root[i],1,n,x,h1);\n\t\t\t\tint R=get_R(root[i],1,n,x,h1);\n\t\t\t\tchange(root[i],1,n,L,R,h1);\n\t\t\t}\n\t\t}\n\t\tif(op==1){\n\t\t\tcin>>x;\n\t\t\th1=query(root[i],1,n,x);\n\t\t\tint L=get_L(root[i],1,n,x,h1);\n\t\t\tint R=get_R(root[i],1,n,x,h1);\n\t\t\tint mv=0;\n\t\t\tchangel(root[i],1,n,L,x,mv);\n\t\t\tmv=0;\n\t\t\tchanger(root[i],1,n,x,R,mv);\n\t\t}\n\t\tif(op==2){\n\t\t\tcin>>x>>h1;\n\t\t\tchangeh(root[i],1,n,x+1,h1,0);\n\t\t\tchangeh(root[i],1,n,x,h1,1);\n\t\t}\n\t\tif(op==3){\n\t\t\tcin>>x;\n\t\t\tcout<<query(root[i],1,n,x)<<endl;\n\t\t}\n\t}\n}\n```\n\n**\u611f\u8c22\u9605\u8bfb\uff01**\n\n",
        "postTime": 1662547682,
        "uid": 376347,
        "name": "\u4f4f\u5728\u9694\u58c1\u5c0f\u8398",
        "ccfLevel": 0,
        "title": "P6794 [SNOI2020] \u6c34\u6c60"
    },
    {
        "content": "### \u6ce8\uff1a\u672c\u9898\u7a7a\u95f4 128MB \u5bfc\u81f4\u8fd9\u9898\u65e0\u6cd5\u901a\u8fc7\uff0c\u4f46\u662f\u5728\u9694\u58c1 Loj 512MB \u4e0b\u53ef\u4ee5\u901a\u8fc7...\u522b\u76f4\u63a5\u6284\u4ee3\u7801\u5c31\u662f\u4e86\n\n\u64cd\u4f5c\u96f6\uff1a\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u627e\u5230\u6c34\u4f4d\u4f1a\u4e0a\u5347\u7684\u533a\u95f4\uff0c\u7136\u540e\u533a\u95f4\u63a8\u5e73\u3002\n\n\u64cd\u4f5c\u4e00\uff1a\u5c06\u4e00\u4e2a\u70b9\u7684\u6c34\u6f0f\u5b8c\u7b49\u4ef7\u4e8e\u5c06\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u6c34\u4f4d\u5bf9\u5230\u4fee\u6539\u4f4d\u7f6e\u95f4\u7684\u6700\u9ad8\u6321\u677f\u53d6 $\\min$\uff0c\u5206\u6210\u5de6\u8fb9\u7684\u6700\u5f3a\u9650\u5236\u548c\u53f3\u8fb9\u7684\u6700\u5f3a\u9650\u5236\uff0c\u5728\u4e0b\u4f20\u65f6\u66f4\u65b0\u6807\u8bb0\u5373\u53ef\u3002\n\n\u64cd\u4f5c\u4e8c\uff1a\u5355\u70b9\u4fee\u6539\u3002\n\n\u64cd\u4f5c\u4e09\uff1a\u5355\u70b9\u67e5\u8be2\u3002\n\n\u90a3\u4e48\u76f4\u63a5\u4e3b\u5e2d\u6811\u7ef4\u62a4\u5c31\u884c\u4e86\uff0c\u65f6\u7a7a\u590d\u6742\u5ea6\u90fd\u662f $O(nlogn)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define I inline int\n#define V inline void\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nV cmax(int&x,int y){if(x-y>>31)x=y;}\nV cmin(int&x,int y){if(y-x>>31)x=y;}\nconst int N=2e5+1,INF=0x3f3f3f3f;\nint n,m,tot,a[N],rt[N];\nstruct ele{\n\tint ls,rs,tag,lw,rw,h,mv;\n\tV addl(int x){cmin(lw,x);}\n\tV addr(int x){cmin(rw,x);}\n\tV assign(int x){lw=rw=INF,tag=x;}\n}t[N<<6];\nV input(){\n\tscanf(\"%d%d\",&n,&m),a[0]=a[n]=INF;\n\tFOR(i,1,n-1)scanf(\"%d\",a+i);\n}\n#define lc t[p].ls\n#define rc t[p].rs\n#define lson lc,L,mid\n#define rson rc,mid+1,R\n#define root(p) rt[p],1,n\nV cpy(int&x){t[++tot]=t[x],x=tot;}\nV upd(int p){t[p].h=max(t[lc].h,t[rc].h),cmax(t[p].h,t[p].mv);}\nV psd(int p){\n\tcpy(lc),cpy(rc);\n\tif(t[p].tag)t[lc].assign(t[p].tag),t[rc].assign(t[p].tag),t[p].tag=0;\n\tt[lc].addr(max(t[p].rw,max(t[rc].h,t[p].mv))),t[rc].addr(t[p].rw),t[p].rw=INF;\n\tt[rc].addl(max(t[p].lw,max(t[lc].h,t[p].mv))),t[lc].addl(t[p].lw),t[p].lw=INF;\n}\nV build(int&p,int L,int R){\n\tif(p=++tot,L==R)return t[p].lw=t[p].rw=INF,void();\n\tint mid=L+R>>1;\n\tbuild(lson),build(rson),t[p].mv=a[mid],upd(p);\n}\nV init(){build(root(0));}\nV getl(int p,int L,int R,int&out,int x,int w){\n\tif(R<=x&&t[p].h<w)return void(out=L);\n\tint mid=L+R>>1;\n\tif(x<=mid)return getl(lson,out,x,w);\n\tif(getl(rson,out,x,w),out==mid+1&&t[p].mv<w)getl(lson,out,x,w);\n}\nV getr(int p,int L,int R,int&out,int x,int w){\n\tif(L>=x&&t[p].h<w)return void(out=R);\n\tint mid=L+R>>1;\n\tif(x>mid)return getr(rson,out,x,w);\n\tif(getr(lson,out,x,w),out==mid&&t[p].mv<w)getr(rson,out,x,w);\n}\nV assign(int p,int L,int R,int l,int r,int x){\n\tif(L==l&&R==r)return t[p].assign(x);\n\tint mid=L+R>>1;psd(p);\n\tif(l>mid)return assign(rson,l,r,x);\n\tif(r<=mid)return assign(lson,l,r,x);\n\tassign(lson,l,mid,x),assign(rson,mid+1,r,x);\n}\nV change(int p,int L,int R,int x,int w){\n\tif(L==R)return void(a[x]=w);\n\tint mid=L+R>>1;\n\tif(psd(p),x<R)cmax(t[p].h,w);\n\tif(mid==x)t[p].mv=w;\n\tx>mid?change(rson,x,w):change(lson,x,w);\n\tupd(p);\n}\nI ask(int p,int L,int R,int x){\n\tif(L==R)return min(t[p].tag,min(t[p].lw,t[p].rw));\n\tint mid=L+R>>1;psd(p);\n\treturn x>mid?ask(rson,x):ask(lson,x);\n}\nI modifyl(int p,int L,int R,int x,int w=0){\n\tif(R<=x)return t[p].addr(w),max(t[p].h,w);\n\tint mid=L+R>>1;psd(p);\n\tif(x<=mid)return modifyl(lson,x,w);\n\treturn modifyl(lson,x,max(t[p].mv,modifyl(rson,x,w)));\n}\nI modifyr(int p,int L,int R,int x,int w=0){\n\tif(L>=x)return t[p].addl(w),max(t[p].h,w);\n\tint mid=L+R>>1;psd(p);\n\tif(x>mid)return modifyr(rson,x,w);\n\treturn modifyr(rson,x,max(t[p].mv,modifyr(lson,x,w)));\n}\nV work(){\n\tint opt,p,x,h,l,r;\n\tFOR(i,1,m){\n\t\tscanf(\"%d%d%d\",&opt,&p,&x),cpy(rt[i]=rt[p]),(~opt&1)&&scanf(\"%d\",&h);\n\t\tif(opt==0&&ask(root(i),x)<h)getl(root(i),l,x,h),getr(root(i),r,x,h),assign(root(i),l,r,h);\n\t\tif(opt==1)modifyl(root(i),x),modifyr(root(i),x);\n\t\tif(opt==2)change(root(i),x,h);\n\t\tif(opt==3)cout<<ask(root(i),x)<<'\\n';\n\t}\n}\nint main(){\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}\n```\n",
        "postTime": 1598510675,
        "uid": 109236,
        "name": "Fuyuki",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P6794 \u3010[SNOI2020] \u6c34\u6c60\u3011"
    }
]