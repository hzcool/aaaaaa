[
    {
        "content": ">\u5728 $366666$ \u7684\u5929\u5e55\u4e0b\uff0c\u70b9\u5206\u6cbb\u3001\u8fb9\u5206\u6cbb\u4e0e\u865a\u6811\u7684\u78e8\u5408\u6b63\u8f70\u8f70\u70c8\u70c8\u5730\u8fdb\u884c\u7740\uff0c\u4f3c\u5c06\u524d\u8def\u96ea\u5c01\u3002  \n\u6b63\u5f53\u8fb9\u5206\u6cbb\u80fd\u4ee5\u4e00\u4e2a $\\log$ \u7684\u4f18\u52bf\u4e00\u9a6c\u5f53\u5148\u4e4b\u9645\uff1b  \n\u6b8a\u4e0d\u77e5\uff0c\u6000\u63e3\u7740 $\\log^3$ \u7684\u4e09\u4eba\u5c0f\u961f\u5df2\u4e00\u4e3e\u62ff\u4e0b[\u6682\u65f6\u6700\u4f18\u89e3](https://www.luogu.com.cn/record/68875662)\u3002  \n\u4ed6\u4eec\u662f\u8c01\uff1f\u4e0d\u51fa\u6240\u6599\uff0c\u6b63\u662f\u5c0f\u5e38\u6570\u4e09\u4eba\u7ec4\uff1a$\\text{Dsu on Tree}$\uff0c\u6811\u5256\uff0c$\\text{Bit}$\u3002\n\n[\u539f\u9898\u94fe\u63a5](https://www.luogu.com.cn/problem/P4565)\n\n>\u9898\u610f\uff1a\u7ed9\u5b9a\u4e24\u68f5\u6811\uff0c\u8fb9\u6709\u8fb9\u6743\uff0c\u6c42 $\\mathrm{MAX}\\left(\\operatorname{dep}_x+\\operatorname{dep}_y-\\operatorname{dep}_{\\operatorname{lca}(x,y)}-\\operatorname{\\hat {dep}}_{\\operatorname{\\hat{lca}}(x,y)}\\right)$\uff0c$n\\leq 366666$\n\n\u5bf9\u7b2c\u4e00\u68f5\u6811\u8fdb\u884c $\\text{Dsu on Tree}$\uff0c\u76ee\u6807\u662f\u5728\u6bcf\u4e2a\u8282\u70b9\u5904\u7406\u51fa\u8de8\u8fc7\u5b83\u7684\u6240\u6709\u70b9\u5bf9\u3002\n\n\u7531\u4e8e\u5f0f\u5b50\u5177\u6709\u826f\u597d\u7684\u5bf9\u79f0\u6027\uff0c\u6240\u4ee5\u91cd\u513f\u5b50\u7684\u4fe1\u606f\u80fd\u76f4\u63a5\u5229\u7528\uff0c\u53ea\u9700\u5728\u8f7b\u5b50\u6811\u5185**\u67e5\u8be2**\uff0c\u6bcf\u4e2a\u513f\u5b50\u5b50\u6811\u67e5\u5b8c\u540e**\u66f4\u65b0**\u4fe1\u606f\u3002\n\n\u5047\u8bbe\u76ee\u524d\u5728\u5904\u7406\u8282\u70b9 $t$\uff0c\u5219 $t=\\operatorname{lca}(x,y)$\uff0c\u800c $x$ \u5728 $t$ \u7684\u4e00\u4e2a\u8f7b\u513f\u5b50\u5b50\u6811\u5185\uff0c$y$ \u662f $t$ \u4e4b\u524d\u904d\u5386\u8fc7\u7684\u513f\u5b50\u5b50\u6811\u5185\u4e00\u70b9\uff08\u5305\u62ec\u91cd\u513f\u5b50\uff09\u3002\n\n\u8f7b\u5b50\u6811\u662f\u5141\u8bb8\u76f4\u63a5\u904d\u5386\u7684\uff0c\u6240\u4ee5\u6b64\u65f6 $\\operatorname{dep}_x$ \u4e0e $\\operatorname{dep}_t$ \u90fd\u5df2\u77e5\uff0c\u53ea\u9700\u6c42 $\\mathrm{MAX}\\left(\\operatorname{dep}_y-\\operatorname{\\hat {dep}}_{\\operatorname{\\hat{lca}}(x,y)}\\right)$\n\n\u8fd9\u4ec5\u4ec5\u4e0e\u7b2c\u4e8c\u68f5\u6811\u6709\u5173\u4e86\uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u4e00\u4e2a\u6811\u4e0a\u52a8\u6001\u52a0 $y$\uff0c\u67e5 $\\mathrm{MAX}\\left(a_y-\\operatorname{dep}_{\\operatorname{lca}(x,y)}\\right)$\n\n\u8fd9\u53ef\u4ee5\u7528\u6811\u5256\u4f18\u5316\u4e86\uff0c\u4e0a\u56fe\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/e8nyukim.png)\n\n\u5176\u4e2d $u$ \u662f $x$ \u8df3\u5230\u7684\u4e00\u4e2a\u91cd\u94fe\u4e0a\u4e00\u70b9\uff0c$\\text{Part 2,3}$ \u662f $u$ \u5b50\u6811\u4e2d\u9664\u4e86 $x$ \u4e00\u8fb9\u7684\u4e24\u90e8\u5206\uff0c$\\text{Part 1,4}$ \u662f\u91cd\u94fe $u$ \u4e0a\u4e0b\u7684\u90e8\u5206\u3002\n\n\u5982\u679c $y$ \u5728 $\\text{Part}\\ 1,2,3$ \u4e2d\uff0c$\\operatorname{lca}(x,y)=u$ \u53ea\u9700\u6c42\u8fd9\u90e8\u5206\u7684 $\\mathrm{MAX}(a_y)$\u3002\n\n\u8fd9\u53ef\u4ee5\u5728\u6bcf\u6b21\u52a0\u5165 $y$ \u65f6\u5411\u4e0a\u8df3\u94fe\uff0c\u5c06\u4fe1\u606f\u5b58\u5728**\u94fe\u4e0a** $\\text{Part 1}$ \u4ee5\u53ca**\u70b9\u4e0a** $\\text{Part 2,3}$\n\n\u800c $y$ \u5728 $\\text{Part 4}$ \u4e2d\uff0c$\\operatorname{lca}(x,y)$ \u4e00\u5b9a\u662f**\u91cd\u94fe\u4e0a $y$ \u8df3\u5230\u7684\u4f4d\u7f6e**\uff0c\u5728\u66f4\u65b0 $y$ \u65f6\u540c\u6837\u53ef\u4ee5\u5b58\u5230\u91cd\u94fe\u4e0a\u3002\n\n\u800c\u5bf9\u4e8e\u91cd\u94fe\u4ee5\u53ca\u513f\u5b50\u4fe1\u606f\u7684\u5b58\u50a8\uff0c\u53ef\u4ee5\u5bf9\u6bcf\u6761\u94fe\uff0c\u6bcf\u4e2a\u70b9\u5f00**\u6811\u72b6\u6570\u7ec4**\u5b9e\u73b0\u3002\n\n\u67e5\u8be2\u4e0e\u66f4\u65b0\u5c31\u6b64\u7ed3\u675f\uff0c\u4f46 $\\text{Dsu on Tree}$ \u8fd8\u4f1a\u81ea\u5e26\u4e00\u4e2a\u5220\u9664\uff0c\u4f3c\u4e4e\u6811\u72b6\u6570\u7ec4\u5b9e\u73b0\u4e0d\u4e86\u3002\n\n\u4f46\u7531\u4e8e $\\text{Dsu on Tree}$ \u65f6\u65f6\u53ea\u4f1a\u5904\u7406\u4e00\u4e2a\u5b50\u6811\uff0c\u76f4\u63a5\u5728\u7b2c\u4e8c\u68f5\u6811\u628a\u5f71\u54cd\u7684\u70b9\u6e05\u9664\u5373\u53ef\u3002\n\n\u7406\u8bba\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(n\\log^3 n)$\uff0c\u540e\u9762\u7684\u6811\u5256\u4ee5\u53ca\u6811\u72b6\u6570\u7ec4\u5176\u5b9e\u4e5f\u80fd\u7528 $\\text{LCT}$ \u505a\u5230\u5927\u5e38\u6570 $O(n\\log^2n)$\u3002\n\n\u7531\u4e8e\u5916\u5c42\u6709 $\\text{Dsu on Tree}$\uff0c\u5341\u5206\u96be\u5361\u6ee1\uff0c\u4f46\u4e34\u65f6\u6700\u4f18\u89e3\u786e\u5b9e\u51fa\u4e4e\u610f\u6599\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=4e5+10;\nconst ll inf=1e18;\nint n,m,x,y,v,tot;ll res,ans;\nint to[N<<1],nextn[N<<1],w[N<<1],h[N],edg;\nint son[N],sz[N],tmp[N];ll d[N];\nchar ch;bool rf;\ninline void read(int &x){\n\tx=0;ch=getchar();while(ch<47)ch=getchar();\n\twhile(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n}\ninline void read_(int &x){\n\tx=0;ch=getchar();rf=0;while(ch<47&&ch^'-')ch=getchar();\n\tif(ch=='-')rf=1,ch=getchar();\n\twhile(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\tif(rf)x=-x;\n}\ninline ll max(ll a,ll b){return a>b?a:b;}\ninline void add(){to[++edg]=y,nextn[edg]=h[x],h[x]=edg,w[edg]=v;}\nvoid init(int x,int anc){\n\tint i,y;sz[x]=1;\n\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc){\n\t\td[y]=d[x]+w[i];init(y,x);sz[x]+=sz[y];\n\t\tsz[y]>sz[son[x]]?son[x]=y:0;\n\t}\n}\n#define lowbit(i) i&(-i) \nstruct bit{\n\tll *t,res;int n;bit()=default;\n\tbit(ll *tt,int nn):t(tt),n(nn){for(int i=1;i<=n;++i)t[i]=-inf;}\n\tinline void update(int i,ll v){for(;i<=n;i+=lowbit(i))t[i]=max(t[i],v);}\n\tinline void inquiry(int i){for(res=-inf;i;i-=lowbit(i))res=max(res,t[i]);}\n\tinline void clear(int i){for(;i<=n;i+=lowbit(i))t[i]=-inf;} \n};\nstruct the_second_tree{\n\tint x,y,tot,nn,i,edg;\n\tint to[N<<1],nextn[N<<1],w[N<<1],h[N],tmp[N],id[N];\n\tint sz[N],son[N],anc[N],top[N],cnum[N],vnum[N];\n\tint crk[N],crk_[N],vrk[N],vrk_[N];\n\tll up_[N<<1],*upp=up_,dn_[N<<1],*dnn=dn_;\n\tll vl_[N<<1],*vll=vl_,vr_[N<<1],*vrr=vr_;\n\tbit up[N],dn[N],vl[N],vr[N];\n\tll a[N],d[N],res,ax,dx;bool b[N];\n\tinline void add(){to[++edg]=y,nextn[edg]=h[x],h[x]=edg,w[edg]=v;}\n\tvoid dfs(int x,int anc_){\n\t\tanc[x]=anc_;sz[x]=1;int i,y;\n\t\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc_){\n\t\t\td[y]=d[x]+w[i];dfs(y,x);sz[x]+=sz[y];\n\t\t\tsz[y]>sz[son[x]]?son[x]=y:0;\n\t\t}\n\t}\n\tvoid init(int x,int anc_,int tp){\n\t\ttop[x]=tp;\n\t\tif(!son[x]){\n\t\t\t++nn;i=0;id[tp]=nn;\n\t\t\twhile(top[x]==tp)++i,crk[x]=i,x=anc[x];cnum[nn]=i;\n\t\t\tup[nn]=bit(upp,i),upp+=i+1;dn[nn]=bit(dnn,i),dnn+=i+1; \n\t\t}\n\t\telse {\n\t\t\tinit(son[x],x,tp);int i,y,j=0;\n\t\t\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc_&&y^son[x])\n\t\t\t\tvrk[y]=++j,init(y,x,y);vnum[x]=j;\n\t\t\tvl[x]=bit(vll,j),vll+=j+1;vr[x]=bit(vrr,j),vrr+=j+1;\n\t\t}\n\t}\n\tvoid update(int x){\n\t\tax=a[x];b[x]=1;\n\t\twhile(x){\n\t\t\ty=top[x];i=id[y];\n\t\t\tdn[i].update(crk[x],ax);\n\t\t\tup[i].update(crk_[x],ax-d[x]);\n\t\t\tx=anc[y];\n\t\t\tif(x){\n\t\t\t\tvl[x].update(vrk[y],ax);\n\t\t\t\tvr[x].update(vrk_[y],ax);\n\t\t\t} \n\t\t}\n\t}\n\tvoid inquiry(int x){\n\t\tres=-inf;\n\t\tif(vnum[x]){\n\t\t\tvl[x].inquiry(vnum[x]);res=max(res,vl[x].res-d[x]);\n\t\t\tvr[x].inquiry(vnum[x]);res=max(res,vr[x].res-d[x]);\n\t\t}\n\t\twhile(x){\n\t\t\ty=top[x];i=id[y];\n\t\t\tdn[i].inquiry(crk[x]-1);res=max(res,dn[i].res-d[x]);\n\t\t\tup[i].inquiry(crk_[x]-1);res=max(res,up[i].res);\n\t\t\tx=anc[y];b[x]?res=max(res,a[x]-d[x]):0;x=anc[y];\n\t\t\tif(x){\n\t\t\t\tvl[x].inquiry(vrk[y]-1);res=max(res,vl[x].res-d[x]);\n\t\t\t\tvr[x].inquiry(vrk_[y]-1);res=max(res,vr[x].res-d[x]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid clear(int x){\n\t\tb[x]=0;\n\t\twhile(x){\n\t\t\ty=top[x];i=id[y];\n\t\t\tdn[i].clear(crk[x]);\n\t\t\tup[i].clear(crk_[x]);\n\t\t\tx=anc[y];\n\t\t\tif(x){\n\t\t\t\tvl[x].clear(vrk[y]);\n\t\t\t\tvr[x].clear(vrk_[y]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid pre_work(){\n\t\tint i;\n\t\tfor(i=1;i^n;++i)read(x),read(y),read_(v),add(),x^=y^=x^=y,add();\n\t\tdfs(1,0);init(1,0,1);\n\t\tfor(i=1;i<=n;++i)crk_[i]=cnum[id[top[i]]]-crk[i]+1;\n\t\tfor(i=1;i<=n;++i)if(vrk[i])vrk_[i]=vnum[anc[i]]-vrk[i]+1;\n\t}\n}T;\nvoid clear(int x,int anc){\n\tint i,y;T.clear(x);\n\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc)clear(y,x);\n}\nvoid dfs(int x,int anc){\n\tint i,y;T.inquiry(x);res=max(res,T.res+d[x]);tmp[++tot]=x;\n\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc)dfs(y,x);\n}\nvoid solve(int x,int anc){\n\tint i,y,j;\n\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc&&y^son[x])solve(y,x),clear(y,x);\n\tif(son[x])solve(son[x],x);res=-inf;\n\tfor(i=h[x];y=to[i];i=nextn[i])if(y^anc&&y^son[x]){\n\t\ttot=0;dfs(y,x);\n\t\tfor(j=1;j<=tot;++j)T.update(tmp[j]); \n\t}\n\tT.inquiry(x);res=max(res,T.res+d[x]);\n\tT.update(x);ans=max(ans,res-d[x]);\n}\nmain(){\n\tread(n);register int i;\n\tfor(i=1;i^n;++i)read(x),read(y),read_(v),add(),x^=y^=x^=y,add();\n\tinit(1,0);T.pre_work();for(i=1;i<=n;++i)T.a[i]=d[i];\n\tsolve(1,0);\n\tfor(i=1;i<=n;++i)ans=max(ans,d[i]-T.d[i]);\n\tprintf(\"%lld\",ans);\n}\n```",
        "postTime": 1644377773,
        "uid": 334380,
        "name": "Y_B_X",
        "ccfLevel": 7,
        "title": "\u9898\u89e3[P4565 \u66b4\u529b\u5199\u6302]"
    },
    {
        "content": "\u611f\u8c22i207M\u795e\u7287\u6559\u6211\u7684\u8fb9\u5206\u6811Orz\n\n\u8fd9\u9898\u8ba9\u6211\u4eec\u6c42\u8fd9\u4e2a\uff1a\n\n$ans=max_{x,y}\\{deep_x+deep_y-deep_{LCA(x,y)}-deep'_{LCA'(x,y)}\\}$\n\n\u7136\u540e\u8fd9\u5f0f\u5b50\u91cc\u5e26\u4e862\u4e2aLCA\u4e0d\u597d\u5904\u7406\uff0c\u7ed9\u4ed6\u53d8\u5f62\uff1a\n\n$ans=\\frac 1 2max_{x,y}\\{dis(x,y)+deep_x+deep_y-2deep'_{LCA'(x,y)}\\}$\n\n\u7136\u540e\u8fd9\u91cc\u51fa\u73b0\u4e86$dis(x,y)$\uff0c\u4e0d\u96be\u60f3\u5230[\u901a\u9053\u90a3\u9898](https://www.luogu.org/problemnew/show/P4220)\u7684\u8fb9\u5206\u6cbb\u505a\u6cd5\uff0c\u6211\u4eec\u628a\u5b83\u7167\u642c\u8fc7\u6765\uff0c\u5bf9$T_1$\u8fdb\u884c\u8fb9\u5206\u6cbb\uff0c\u7136\u540e\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u5212\u5206\u4e86\u4e24\u4e2a\u8fde\u901a\u5757\uff0c\u628a\u4e00\u8fb9\u7684\u770b\u6210\u9ed1\u70b9\uff0c\u4e00\u8fb9\u7684\u770b\u6210\u767d\u70b9\uff0c\u7136\u540e\u4ee4$val_i$\u4e3a\u5f53\u524d\u8fb9\u5206\u6cbb\u7684\u65f6\u5019\u7684$i$\u7684\u6df1\u5ea6$+deep_i$\uff0c\u90a3\u4e48\u6211\u4eec\u76f8\u5f53\u4e8e\u6700\u5927\u5316$val_x+val_y-2deep'_{LCA'(x,y)}$\uff0c\u5176\u4e2dx\u4e3a\u9ed1\u70b9\uff0cy\u4e3a\u767d\u70b9\uff0c\u8fd9\u4e2a\u5728$T_2$\u4e0a\u5efa\u4e2a\u865a\u6811\u679a\u4e3e$LCA'$\u5c31\u53ef\u4ee5\u7edf\u8ba1\u7b54\u6848\u4e86\uff0c\u52a0\u4e0a\u5efa\u865a\u6811\u7684\u6392\u5e8f\u8fd9\u662f$O(n\\log^2n)$\u7684\u663e\u7136~~\u540c\u4e00\u4f4d~~\u51fa\u9898\u4eba\u6545\u610f\u5361\u4e86\u8fd9\u4e2a\u8fc7\u4e0d\u53bb\u2026\u2026~~\u6bd5\u7adf1\u4e2alog\u90fd\u8981\u8dd12s\u591a\u2026\u2026~~\n\n\u7136\u540e\u6211\u4eec\u628a\u4e0a\u9762\u90a3\u4e2a\u601d\u8def\u7a0d\u5fae\u6539\u4e00\u4e0b\uff0c\u8003\u8651\u5728$T_2$\u4e0a\u76f4\u63a5\u679a\u4e3e$LCA'$\uff0c\u7136\u540e\u5408\u5e76\u4e24\u68f5$LCA'$\u4e3a\u8fd9\u4e2a\u70b9\u7684\u5b50\u6811\u7684\u65f6\u5019\u7edf\u8ba1\u8fd9\u4e24\u68f5\u5b50\u6811\u4e4b\u95f4\u5728$T_1$\u4e0a\u4ea7\u751f\u7684\u8d21\u732e\uff0c\u7136\u800c\u663e\u7136\u6211\u4eec\u5c31\u4e0d\u80fd\u8fb9\u5206\u6cbb\u4e86\uff0c\u7136\u800c\u2026\u2026\u6709\u4e2a\u4e1c\u897f\u53eb\u8fb9\u5206\u6811\u2026\u2026\n\n\u6240\u8c13\u8fb9\u5206\u6811\u5176\u5b9e\u548c\u70b9\u5206\u6811\u5b8c\u5168\u4e0d\u540c\uff0c\u5b9e\u9645\u4e0a\u5b83\u521d\u59cb\u7684\u65f6\u5019\u662f\u4e00\u4e2a\u68ee\u6797\u7684\u5f62\u5f0f\uff0c\u6211\u4eec\u5148\u5bf9$T_1$\u8fdb\u884c\u4e00\u904d\u8fb9\u5206\u6cbb\uff0c\u7136\u540e\u6211\u4eec\u5728\u6bcf\u4e2a\u70b9\u4e0a**\u7ef4\u62a4\u4e00\u6761\u9ad8\u5ea6\u4e3a$O(logn)\u7684\u4e8c\u53c9\u6811\u94fe$**\uff08\u6ce8\u610f\u6b64\u6811\u975e\u5f7c\u6811\uff09\uff0c\u5728\u5206\u6cbb\u7684\u65f6\u5019\uff0c\u6211\u4eec\u628a\u4e00\u7aef\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u8fde\u901a\u5757\u91cc\u7684\u6240\u6709\u70b9\u7684\u94fe\u7684\u5e95\u90e8\u90fd\u6dfb\u52a0\u4e00\u4e2a\u53f3\u513f\u5b50\uff0c\u6df1\u5ea6\u8f83\u5c0f\u7684\u90a3\u4e00\u7aef\u7684\u8fde\u901a\u5757\u7684\u6240\u6709\u70b9\u90fd\u6dfb\u52a0\u4e00\u4e2a\u5de6\u513f\u5b50\u3002\u8fd9\u91cc\u6240\u8bf4\u7684\u201c\u6df1\u5ea6\u201d\u662f\u7528\u4e8e\u533a\u5206\u8fd9\u6761\u8fb9\u7684\u4e24\u4e2a\u7aef\u70b9\u7684\u3002\u6bcf\u4e2a\u70b9\u4e0a\u7ef4\u62a4\u7684\u8fd9\u6761\u94fe\u4e0a\u7684\u70b9\u5176\u5b9e\u5c31\u662f\u8868\u793a\u4e86\u8fd9\u4e2a\u70b9\u81ea\u5df1\u5728\u8fb9\u5206\u6cbb\u65f6\u6240\u5c5e\u7684$O(\\log n)$\u4e2a\u8fde\u901a\u5757\u3002\u6240\u4ee5\u8fd9\u4e2a\u7a7a\u95f4\u590d\u6742\u5ea6\u662f$O(\\log n)$\u7684\uff0c\u5176\u5b9e\u8fd9\u4e2a\u7c7b\u4f3c\u4e8e\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u3002\n\n\u7136\u540e\u8003\u8651\u4e24\u4e2a$T_1$\u4e0a\u7684\u70b9$a$\u548c$b$\u4ec0\u4e48\u65f6\u5019\u4f1a\u4ea7\u751f\u8d21\u732e\uff0c\u663e\u7136\u5c31\u662f\u4e24\u4e2a\u70b9\u7b2c\u4e00\u6b21\u4e0d\u5728\u4e00\u4e2a\u8fde\u901a\u5757\u5185\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u8003\u8651a\u7684\u8fb9\u5206\u6811\u4e0a\u4e00\u4e2a\u70b9$i$\u4e0eb\u7684\u8fb9\u5206\u6811\u4e0a\u4e00\u4e2a\u70b9j\uff0c$ij$\u6df1\u5ea6\u76f8\u540c\uff0c\u90a3\u4e48i\u7684\u6240\u6709\u7956\u5148\u7684\u5de6\u53f3\u7236\u5b50\u5173\u7cfb\u90fd\u4e0ej\u7684\u76f8\u540c\uff0c\u76f4\u5230i\u548cj\u4ed6\u4eec\u4e0e\u7236\u4eb2\u7684\u5de6\u53f3\u7236\u5b50\u5173\u7cfb\u624d\u5f00\u59cb\u53d8\u5f97\u4e0d\u540c\u3002\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5bf9\u8fb9\u5206\u6811\u8fdb\u884c\u5408\u5e76\u4e86\uff0c\u8fd9\u4e2a\u5408\u5e76\u548c\u7ebf\u6bb5\u6811\u5408\u5e76\u5b8c\u5168\u4e00\u6837\uff0c\u540c\u65f6\u6211\u4eec\u53ef\u4ee5\u5728\u5408\u5e76\u7684\u65f6\u5019\u987a\u4fbf\u628a\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u7edf\u8ba1\u51fa\u6765\u3002\u6211\u4eec\u73b0\u5728\u4e0d\u662f\u5728\u679a\u4e3e$LCA'$\u5417\uff1f\u5c31\u5728\u8fd9\u4e2a$dfs$\u7684\u65f6\u5019\u5408\u5e76\u5b50\u6811\u7684\u8fb9\u5206\u6811\uff0c\u6211\u4eec\u6c42\u7684\u76f8\u5f53\u4e8e\u6700\u5927\u7684$val_i+val_j$\uff0c\u5f53\u5408\u5e76$ab$\u4e24\u68f5\u8fb9\u5206\u6811\u7684\u65f6\u5019\uff0c\u663e\u7136$a$\u7684\u6240\u6709\u7956\u5148\u7684\u7236\u5b50\u7684\u5de6\u53f3\u5173\u7cfb\u90fd\u548c$b$\u7684\u76f8\u7b49\uff08\u56e0\u4e3a\u8fd9\u4e2a\u548c\u7ebf\u6bb5\u6811\u5408\u5e76\u4e00\u6837\uff09\uff0c\u90a3\u4e48\u5c31\u76f8\u5f53\u4e8e$ab$\u8868\u793a\u7684\u662f\u540c\u4e00\u4e2a\u8fde\u901a\u5757\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u628a\u4ed6\u4eec\u5408\u5e76\u6210\u4e00\u4e2a\u70b9\uff0c\u540c\u65f6\u7ef4\u62a4\u8fd9\u4e2a\u70b9\u8868\u793a\u7684\u8fde\u901a\u5757\u91cc\u6700\u5927\u7684$val$\uff08\u53d6\u4e2amax\u5373\u53ef\uff09\uff0c\u7136\u540ea\u7684\u5de6\u513f\u5b50\u663e\u7136\u662f\u548cb\u7684\u53f3\u513f\u5b50\u5206\u6cbb\u5728\u4e00\u6761\u8fb9\u7684\u4e24\u8fb9\u7684\uff0c\u540c\u7406a\u7684\u53f3\u513f\u5b50\u4e0eb\u7684\u5de6\u513f\u5b50\u4e5f\u5982\u6b64\uff0c\u90a3\u4e48\u628a\u4ed6\u4eec\u4ea7\u751f\u7684\u8d21\u732e\u7edf\u8ba1\u4e00\u4e0b\u5373\u53ef\u3002\u4e8e\u662f\u5c31\u505a\u5230\u4e86$O(n\\log n)$\u3002\n\n\u4e0d\u96be\u53d1\u73b0\uff0c\u6211\u4eec\u6700\u540e\u4f1a\u5408\u5e76\u6210\u4e00\u68f5\u6781\u5927\u7684\u8fb9\u5206\u6811\uff0c\u8fd9\u68f5\u8fb9\u5206\u6811\u5c31\u771f\u7684\u662f\u771f\u6b63\u610f\u4e49\u4e0a\u7684\u201c\u8fb9\u5206\u6811\u201d\u4e86\uff0c\u5373\u7236\u4eb2\u7684\u5de6\u53f3\u513f\u5b50\u662f\u4e00\u4e2a\u5927\u8fde\u901a\u5757\u5206\u6cbb\u6210\u7684\u4e24\u4e2a\u5c0f\u8fde\u901a\u5757\uff0c\u53e6\u5916\u8fd8\u8981\u6ce8\u610f\u5728\u8fb9\u5206\u6811\u4e0a\u7ef4\u62a4\u5b50\u6811\u7684\u4fe1\u606f\u6ca1\u6709\u4efb\u4f55\u610f\u4e49\u2026\u2026\n\n\u54e6\u8fd9\u9898\u8fd8\u9700\u8981\u7279\u5224$x=y$\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u4f60\u7684\u7b54\u6848\u662f\u8fb9\u5206\u6811\u5408\u5e76\u7edf\u8ba1\u51fa\u6765\u7684\uff0c\u6240\u4ee5\u4e00\u4e2a\u70b9\u81ea\u8eab\u4e0e\u81ea\u8eab\u7684\u7b54\u6848\u7edf\u8ba1\u4e0d\u51fa\u6765\u2026\u2026\n\n\u4e0a\u4ee3\u7801~\n\n```cpp\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define ll long long\n#define inf (1ll << 60)\n#define abs(_o) ((_o < 0) ? -(_o) : _o)\nusing namespace std;\nnamespace ywy {\n\tinline int get() {\n\t    int n = 0;\n\t    char c;\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            break;\n\t        if (c == '-')\n\t            goto s;\n\t    }\n\t    n = c - '0';\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 + c - '0';\n\t        else\n\t            return (n);\n\t    }\n\ts:\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 - c + '0';\n\t        else\n\t            return (n);\n\t    }\n\t}\n\tint n;\n\ttypedef struct _b {\n\t    int dest;\n\t    int nxt;\n\t    int len;\n\t    unsigned char gg;\n\t} bian;\n\tint root[400001];\n\tll val[10000001];\n\tint gb;\n\tint ch[10000001][2];\n\tnamespace t1 {\n\t\tbian memchi[2000001];\n\t\tint gn = 2, heads[800001];\n\t\tinline void add(int s, int t, int l) {\n\t\t    memchi[gn].dest = t;\n\t\t    memchi[gn].len = l;\n\t\t    memchi[gn].nxt = heads[s];\n\t\t    heads[s] = gn;\n\t\t    gn++;\n\t\t}\n\t\tll deep[800001];\n\t\tint size[800001], tot, zx, minn;\n\t\tll dp[800001];\n\t\tint rdp[800001];\n\t\tvoid dfs(int pt, int baba) {\n\t\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t\t        if (memchi[i].dest == baba)\n\t\t            continue;\n\t\t        deep[memchi[i].dest] = deep[pt] + memchi[i].len;\n\t\t        rdp[memchi[i].dest] = rdp[pt] + 1;\n\t\t        dfs(memchi[i].dest, pt);\n\t\t    }\n\t\t}\n\t\tvoid afs(int pt, int baba) {\n\t\t    tot++;\n\t\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t\t        if (memchi[i].gg || memchi[i].dest == baba)\n\t\t            continue;\n\t\t        afs(memchi[i].dest, pt);\n\t\t    }\n\t\t}\n\t\tvoid bfs(int pt, int baba) {\n\t\t    size[pt] = 1;\n\t\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t\t        if (memchi[i].gg || memchi[i].dest == baba)\n\t\t            continue;\n\t\t        bfs(memchi[i].dest, pt);\n\t\t        size[pt] += size[memchi[i].dest];\n\t\t        if (abs(tot - 2 * size[memchi[i].dest]) < minn) {\n\t\t            minn = abs(tot - 2 * size[memchi[i].dest]);\n\t\t            zx = i;\n\t\t        }\n\t\t    }\n\t\t}\n\t\tvoid cfs(int pt, int baba, int op) {\n\t\t    if (pt <= n) {\n\t\t        int me = gb;\n\t\t        gb++;\n\t\t        val[me] = deep[pt] + dp[pt];\n\t\t        ch[root[pt]][op] = me;\n\t\t        root[pt] = me;\n\t\t    }\n\t\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t\t        if (memchi[i].dest == baba || memchi[i].gg)\n\t\t            continue;\n\t\t        dp[memchi[i].dest] = dp[pt] + memchi[i].len;\n\t\t        cfs(memchi[i].dest, pt, op);\n\t\t    }\n\t\t}\n\t\tvoid digui(int pt) {\n\t\t    tot = 0;\n\t\t    afs(pt, 0);\n\t\t    if (tot == 1)\n\t\t        return;\n\t\t    minn = 12345678;\n\t\t    bfs(pt, 0);\n\t\t    int me = zx, a = memchi[me].dest, b = memchi[me ^ 1].dest;\n\t\t    memchi[me].gg = memchi[me ^ 1].gg = 1;\n\t\t    dp[a] = memchi[me].len;\n\t\t    dp[b] = 0;\n\t\t    cfs(a, 0, rdp[a] > rdp[b]);\n\t\t    cfs(b, 0, rdp[b] > rdp[a]);\n\t\t    digui(a);\n\t\t    digui(b);\n\t\t}\n\t}\n\tvector<int> vec[400001], len[400001];\n\tint gpt;\n\tvoid rebuild(int pt, int baba) {\n\t    int lst = pt;\n\t    for (register int i = 0; i < vec[pt].size(); i++) {\n\t        if (vec[pt][i] == baba)\n\t            continue;\n\t        int me = gpt;\n\t        gpt++;\n\t        t1::add(lst, me, 0);\n\t        t1::add(me, lst, 0);\n\t        t1::add(me, vec[pt][i], len[pt][i]);\n\t        t1::add(vec[pt][i], me, len[pt][i]);\n\t        rebuild(vec[pt][i], pt);\n\t        lst = me;\n\t    }\n\t}\n\tll maxn = -inf;\n\tll ans = -inf;\n\tinline int united(int a, int b) {\n\t    if (!(a && b))\n\t        return (a | b);\n\t    if (ch[a][0] && ch[b][1]) {\n\t        ans = max(ans, val[ch[a][0]] + val[ch[b][1]]);\n\t    }\n\t    if (ch[a][1] && ch[b][0]) {\n\t        ans = max(ans, val[ch[a][1]] + val[ch[b][0]]);\n\t    }\n\t    val[a] = max(val[a], val[b]);\n\t    ch[a][0] = united(ch[a][0], ch[b][0]);\n\t    ch[a][1] = united(ch[a][1], ch[b][1]);\n\t    return (a);\n\t}\n\tnamespace t2 {\n\t\tbian memchi[1000001];\n\t\tint gn = 1, heads[400001];\n\t\tinline void add(int s, int t, int l) {\n\t\t    memchi[gn].dest = t;\n\t\t    memchi[gn].len = l;\n\t\t    memchi[gn].nxt = heads[s];\n\t\t    heads[s] = gn;\n\t\t    gn++;\n\t\t}\n\t\tll deep[400001];\n\t\tvoid dfs(int pt, int baba) {\n\t\t    for (register int i = heads[pt]; i; i = memchi[i].nxt) {\n\t\t        if (memchi[i].dest == baba)\n\t\t            continue;\n\t\t        deep[memchi[i].dest] = deep[pt] + memchi[i].len;\n\t\t        dfs(memchi[i].dest, pt);\n\t\t        ans = -inf;\n\t\t        root[pt] = united(root[pt], root[memchi[i].dest]);\n\t\t        if (ans != -inf)\n\t\t            maxn = max(maxn, ans - 2 * deep[pt]);\n\t\t    }\n\t\t}\n\t}\n\tvoid ywymain() {\n\t    n = get();\n\t    gpt = n + 1;\n\t    for (register int i = 1; i <= n; i++) root[i] = i;\n\t    gb = n + 1;\n\t    val[0] = -inf;\n\t    for (register int i = 1; i < n; i++) {\n\t        int s = get(), t = get(), l = get();\n\t        vec[s].push_back(t);\n\t        len[s].push_back(l);\n\t        vec[t].push_back(s);\n\t        len[t].push_back(l);\n\t    }\n\t    for (register int i = 1; i < n; i++) {\n\t        int s = get(), t = get(), l = get();\n\t        t2::add(s, t, l);\n\t        t2::add(t, s, l);\n\t    }\n\t    rebuild(1, 0);\n\t    t1::dfs(1, 0);\n\t    t1::digui(1);\n\t    for (register int i = 1; i <= n; i++) root[i] = i;\n\t    t2::dfs(1, 0);\n\t    maxn /= 2;\n\t    for (register int i = 1; i <= n; i++) {\n\t        maxn = max(maxn, t1::deep[i] - t2::deep[i]);\n\t    }\n\t    cout << maxn << endl;\n\t}\n}\nint main() {\n    ywy::ywymain();\n    return (0);\n}\n```",
        "postTime": 1555679735,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "\u770b\u5230\u70b9\u5206\u6cbb\u7684\u9898\u89e3\u5982\u6b64\u5b64\u72ec\uff0c\u6211\u4e5f\u5c31\u6765\u6dfb\u4e00\u7bc7\u2026\u2026\n\n**\u7b97\u6cd5\uff1a\u70b9\u5206\u6cbb+\u865a\u6811**\n\n\u50cf\u8fd9\u79cd\u201c\u591a\u6811\u7edf\u8ba1\u201d\u95ee\u9898\uff0c\u5f80\u5f80\u4f1a\u7528\u5230\u865a\u6811\uff08\u6bd4\u5982[P4220 [WC2018]\u901a\u9053](https://www.luogu.com.cn/problem/P4220)\uff0c~~\u6211\u624d\u4e0d\u4f1a\u544a\u8bc9\u4f60\u4eec\u6211\u662f\u968f\u673a\u5316\u778e\u641eAC\u7684\u90a3\u9053\u9898~~\uff09\u3002\u4e3a\u4ec0\u4e48\u5462\uff1f\u9996\u5148\u6211\u4eec\u5f97\u8f6c\u5316\u4e00\u4e0b\u8fd9\u4e2a\u5f0f\u5b50\uff0c\u56e0\u4e3a\u5728\u4e00\u68f5\u6811\u6811\u5206\u6cbb\u8fc7\u7a0b\u4e2d\uff0c**\u539f\u6765\u4ee51\u4e3a\u6839\u65f6\u7684lca\u5df2\u7ecf\u4e0d\u5728\u597d\u5904\u7406\u4e86**\u3002\u4f46\u662f\uff0c\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\uff0c\u6811\u5206\u6cbb\u5f88\u5584\u4e8e\u89e3\u51b3\u4e24\u70b9\u4e4b\u95f4\u8ddd\u79bb\u7c7b\u7684\u95ee\u9898\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u5f80\u8fd9\u65b9\u9762\u60f3\uff1a\n\n$val(x, y)=depth(x)+depth(y)-depth(lca(x, y))-depth'(lca'(x,y))$\n\n$=\\frac{1}{2}(depth(x)+depth(y)-2\\cdot depth(lca(x, y))+depth(x)+depth(y)-2*depth'(lca'(x, y))$\n\n$=\\frac{1}{2}(dist(x, y)+depth(x)+depth(y)-2\\cdot depth'(lca'(x, y))$\n\n\u4f7f\u7528\u70b9\u5206\u6cbb\uff0c\u82e5\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3\u4e3a $rt$ \uff0c\u4ee4 $w(x)=dist(x, rt)+depth(x)$ \uff0c \u5219\n\n$ans(x, y)=w(x)+w(y)-2\\cdot depth'(lca'(x, y))$\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u6bcf\u6b21\u70b9\u5206\u6cbb\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u5c06**rt \u81ea\u5df1**\u548c\u4ed6\u7684\u6bcf\u9897\u5b50\u6811\u67d3\u4e0a\u4e0d\u540c\u7684\u989c\u8272\uff0c$x$ \u7684\u989c\u8272\u8bb0\u4e3a $col_x$\uff0c\u7136\u540e\u5c31\u662f\u6c42\n\n$\\max\\limits_{col_x\\ne col_y} w(x)+w(y)-2\\cdot depth'(lca'(x, y))$\n\n\u53d1\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u4e00\u904d\u6811\u5f62 DP \u6c42\u51fa\u6700\u5927\u7b54\u6848\uff0c\u65b9\u6cd5\u5982\u4e0b\uff1a\n\n- \u8bbe $f_{u, 0/1}$ \u8868\u793a\u4ee5 $u$ \u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u6700\u5927/\u6b21\u5927\u7684 $w(x)$ \u53ca\u5176\u5bf9\u5e94\u7684\u989c\u8272\uff08\u4e24\u4e2a\u989c\u8272\u8981\u6c42\u4e0d\u540c\uff09\u3002\n\n- \u6bcf\u6b21 dp \u5b8c\u4e00\u4e2a\u513f\u5b50\uff0c\u90fd\u5148\u7528\u5f53\u524d\u513f\u5b50\u7684 dp \u503c\u548c\u524d\u9762\u5df2\u7ecf\u7edf\u8ba1\u7684\u513f\u5b50\u7684 dp \u503c\uff08\u4e5f\u5c31\u662f\u73b0\u5728\u7236\u4eb2\u7684 dp \u503c\uff09\u6765\u66f4\u65b0\u7b54\u6848\u3002\n\n- \u66f4\u65b0\u5b8c\u7b54\u6848\u540e\uff0c\u7528\u8be5\u513f\u5b50\u7684 dp \u503c\u6765\u66f4\u65b0\u7236\u4eb2\u7684 dp \u503c\u3002\n\n\uff08\u8fd9\u79cd\u5f62\u5f0f\u7684 dp \u4f3c\u4e4e\u662f noip \u9636\u6bb5\u7ecf\u5e38\u7528\u7684\u4e00\u4e2a trick\uff09\n\n\u7136\u800c\uff0c\u4e0d\u80fd\u591f\u6bcf\u6b21\u90fd\u5bf9\u6574\u68f5\u6811 dp\uff0c\u5426\u5219\u4f60\u70b9\u5206\u6cbb\u5c31\u767d\u5199\u4e86\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u8981\u7528\u5230**\u865a\u6811**\u3002\u8fd9\u6837\uff0c\u590d\u6742\u5ea6\u5f97\u5230\u4e86\u4fdd\u8bc1\uff0c\u5982\u679c\u4f7f\u7528 st \u8868\u6c42 lca \uff0c\u5e76\u7528\u57fa\u6570\u6392\u5e8f+\u5355\u8c03\u6808\u6765\u5efa\u865a\u6811\uff0c\u5219\u53ef\u4ee5\u8fbe\u5230 $O(n\\log n)$ \u7684\u590d\u6742\u5ea6\uff0c\u53ef\u4ee5\u901a\u8fc7\u6b64\u9898\u3002\n\n\uff08\u53ef\u4ee5\u901a\u8fc7\u4e2a\u9524\u5b50\uff0c\u6211\u5728 loj \u4e0a\u8dd1\u7684\u98de\u5feb\uff0c\u7ed3\u679c\u4e0d\u77e5\u9053\u4e3a\u5565 luogu \u4e0a\u4e00\u76f4\u88ab\u5361 #13 TLE QAQ\uff0c~~\u53ea\u80fd\u901a\u8fc7\u4e00\u4e9b\u4e0d\u5730\u9053\u7684\u624b\u6bb5\u6765\u8c0b\u6c42AC~~\uff09\n\n\u4e0b\u9762\u662f\u4ee3\u7801\uff08\u6ce8\u610f\u4f1aTLE #13\uff0c\u6211\u4e4b\u540e\u6253\u4e86\u8868\uff08~~\u6bd5\u7adf\u5176\u4ed6oj\u4e0a\u80fdA\u561b\uff0c\u6c42\u4e0d\u8981\u68d5\u540dQAQ~~\uff09\n\n```cpp\n#include <bits/stdc++.h>\n#define mkp make_pair\n#define ft first\n#define sd second\n#define Path(i, u, G) for(int i=G.hd[u]; i!=-1; i=G.nxt[i])\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T> inline void read(T &x){\n\tchar c=getchar();x=0;int f=1;\n\twhile(!isdigit(c))f=c=='-'?-f:f,c=getchar();\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();x*=f;\n}\nconst int N=4e5+5;\nconst ll inf=0x3f3f3f3f3f3f3f3fll;\nint n, col[N];\nll wgt[N];\nstruct standard_Graph{\n\tint e, hd[N], to[N<<1], nxt[N<<1];\n\tll val[N<<1];\n\tinline standard_Graph(){\n\t\te=-1, memset(hd, 0xff, sizeof(hd));\n\t}\n\tinline void add_path(int u, int v, ll w){\n\t\tto[++e]=v;\n\t\tval[e]=w;\n\t\tnxt[e]=hd[u];\n\t\thd[u]=e;\n\t}\n\tinline void add_edge(int u, int v, int w){\n\t\tadd_path(u, v, w);\n\t\tadd_path(v, u, w);\n\t}\n};\nstruct simple_Graph{\n\tint e, hd[N], to[N<<1], nxt[N<<1];\n\tinline simple_Graph(){\n\t\te=-1, memset(hd, 0xff, sizeof(hd));\n\t}\n\tinline void add_path(int u, int v){\n\t\tto[++e]=v;\n\t\tnxt[e]=hd[u];\n\t\thd[u]=e;\n\t}\n};\nnamespace VT{int p[N], cnt, stk[N], top;}\nnamespace T2{\n\tstandard_Graph G0;\n\tsimple_Graph G;\n\tint dep[N], dfn[N], dfn_clock, od[N<<1], pos[N], mi[N<<1][22], lg[N<<1];\n\tll d[N];\n\tinline void dfs(int u, int fa, ll dis){\n\t\tod[pos[u]=++od[0]]=u;\n\t\td[u]=dis;\n\t\tdep[u]=dep[fa]+1;\n\t\tdfn[u]=++dfn_clock;\n\t\tPath(i, u, G0){\n\t\t\tint v=G0.to[i];\n\t\t\tll w=G0.val[i];\n\t\t\tif(v!=fa){\n\t\t\t\tdfs(v, u, dis+w);\n\t\t\t\tod[++od[0]]=u;\n\t\t\t}\n\t\t}\n\t}\n\tinline int Min(int x, int y){\n\t\treturn dep[x]<dep[y]?x:y;\n\t}\n\tinline void prepro(){\n\t\tfor(int i=2; i<=od[0]; ++i) lg[i]=lg[i>>1]+1;\n\t\tfor(int i=1; i<=od[0]; ++i) mi[i][0]=od[i];\n\t\tfor(int j=1; j<=lg[od[0]]; ++j)\n\t\t\tfor(int i=1; i+(1<<j)-1<=od[0]; ++i)\n\t\t\t\tmi[i][j]=min(mi[i][j-1], mi[i+(1<<(j-1))][j-1]);\n\t}\n\tinline void init(){\n\t\tfor(int i=1; i<n; ++i){\n\t\t\tint u, v; ll w;\n\t\t\tread(u);read(v);read(w);\n\t\t\tG0.add_edge(u, v, w);\n\t\t}\n\t\tdfs(1, 0, 0);\n\t\tprepro();\n\t}\n\tinline int get_lca(int x, int y){\n\t\tx=pos[x], y=pos[y];\n\t\tif(x>y) swap(x, y);\n\t\tint l=lg[y-x+1];\n\t\treturn Min(mi[x][l], mi[y-(1<<l)+1][l]);\n\t}\n\tinline void Sort(int* l, int *r){\n\t\tstatic int cnt[10], mx, key[N], tmp[N];\n\t\tmx=1;\n\t\tfor(int *i=l; i<r; ++i) while(dfn[*i]>=mx) mx*=10;\n\t\tfor(int o=1; o<mx; o*=10){\n\t\t\tfor(int i=0; i<10; ++i) cnt[i]=0;\n\t\t\tfor(int *i=l; i<r; ++i) key[*i]=dfn[*i]/o%10;\n\t\t\tfor(int *i=l; i<r; ++i) ++cnt[key[*i]];\n\t\t\tfor(int i=1; i<10; ++i) cnt[i]+=cnt[i-1];\n\t\t\tfor(int *i=r-1; i>=l; --i) tmp[cnt[key[*i]]--]=*i;\n\t\t\tfor(int *i=l; i<r; ++i) *i=tmp[i-l+1];\n\t\t}\n\t}\n\tinline void get_G(){\n\t\tusing namespace VT;\n\t\tSort(p+1, p+1+cnt);\n\t\tstk[top=1]=1;\n\t\tG.e=G.hd[1]=-1;\n\t\tfor(int i=1, lca; i<=cnt; ++i) if(p[i]!=1){\n\t\t\tlca=get_lca(p[i], stk[top]);\n\t\t\tif(lca!=stk[top]){\n\t\t\t\twhile(dfn[lca]<dfn[stk[top-1]]){\n\t\t\t\t\tG.add_path(stk[top-1], stk[top]);\n\t\t\t\t\t--top;\n\t\t\t\t}\n\t\t\t\tif(dfn[lca]>dfn[stk[top-1]]){\n\t\t\t\t\tG.hd[lca]=-1;\n\t\t\t\t\tG.add_path(lca, stk[top]);\n\t\t\t\t\tstk[top]=lca;\n\t\t\t\t}\n\t\t\t\telse G.add_path(lca, stk[top--]);\n\t\t\t}\n\t\t\tG.hd[p[i]]=-1;\n\t\t\tstk[++top]=p[i];\n\t\t}\n\t\tfor(int i=1; i<top; ++i)\n\t\t\tG.add_path(stk[i], stk[i+1]);\n\t}\n\tll ans;\n\tpair<ll, int> f[N][2];\n\tinline void upd_f(int u, pair<ll, int> g){\n\t\tif(g.ft>f[u][0].ft){\n\t\t\tif(g.sd!=f[u][0].sd) f[u][1]=f[u][0];\n\t\t\tf[u][0]=g;\n\t\t}\n\t\telse if(g.ft>f[u][1].ft&&g.sd!=f[u][0].sd)\n\t\t\tf[u][1]=g;\n\t}\n\tinline void upd_ans(int u, int v){\n\t\tif(f[v][0].sd!=f[u][0].sd) ans=max(ans, ((f[v][0].ft+f[u][0].ft)>>1)-d[u]);\n\t\tif(f[v][0].sd!=f[u][1].sd) ans=max(ans, ((f[v][0].ft+f[u][1].ft)>>1)-d[u]);\n\t\tif(f[v][1].sd!=f[u][0].sd) ans=max(ans, ((f[v][1].ft+f[u][0].ft)>>1)-d[u]);\n\t\tif(f[v][1].sd!=f[u][1].sd) ans=max(ans, ((f[v][1].ft+f[u][1].ft)>>1)-d[u]);\n\t}\n\tinline void dp(int u){\n\t\tf[u][0]=f[u][1]=mkp(-inf, 0);\n\t\tif(col[u]) upd_f(u, mkp(wgt[u], col[u]));\n\t\twgt[u]=col[u]=0;\n\t\tPath(i, u, G){\n\t\t\tint v=G.to[i];\n\t\t\tdp(v);\n\t\t\tupd_ans(u, v);\n\t\t\tupd_f(u, f[v][0]);\n\t\t\tupd_f(u, f[v][1]);\n\t\t}\n\t}\n\tinline ll work(){\n\t\tget_G();\n\t\tans=-inf;\n\t\tdp(1);\n\t\treturn ans;\n\t}\n}\nnamespace T1{\n\tstandard_Graph G;\n\tll d[N], ans;\n\tinline void get_d(int u, int fa, ll dis){\n\t\td[u]=dis;\n\t\tPath(i, u, G) if(G.to[i]!=fa)\n\t\t\tget_d(G.to[i], u, dis+G.val[i]);\n\t}\n\tinline void init(){\n\t\tfor(int i=1; i<n; ++i){\n\t\t\tint u, v; ll w;\n\t\t\tread(u);read(v);read(w);\n\t\t\tG.add_edge(u, v, w);\n\t\t}\n\t\tget_d(1, 0, 0);\n\t}\n\tint sz[N], rt, Size, maxp[N]={0x3f3f3f3f};\n\tbool vis[N];\n\tinline void get_sz(int u, int fa){\n\t\tsz[u]=1, maxp[u]=0;\n\t\tPath(i, u, G){\n\t\t\tint v=G.to[i];\n\t\t\tif(v==fa||vis[v]) continue;\n\t\t\tget_sz(v, u);\n\t\t\tsz[u]+=sz[v];\n\t\t\tmaxp[u]=max(maxp[u], sz[v]);\n\t\t}\n\t\tmaxp[u]=max(maxp[u], Size-sz[u]);\n\t\tif(maxp[u]<maxp[rt]) rt=u;\n\t}\n\tinline void calc(int u, int fa, ll dis, const int &C){\n\t\tusing namespace VT;\n\t\tcol[u]=C;\n\t\twgt[u]=d[u]+dis;\n\t\tp[++cnt]=u;\n\t\tPath(i, u, G){\n\t\t\tint v=G.to[i];\n\t\t\tif(v==fa||vis[v]) continue;\n\t\t\tcalc(v, u, dis+G.val[i], C);\n\t\t}\n\t}\n\tinline void divide(int u){\n\t\tusing namespace VT;\n\t\tvis[u]=true;\n\t\tget_sz(u, 0);\n\t\tint C=1;\n\t\tcol[u]=C, wgt[u]=d[u];\n\t\tp[cnt=1]=u;\n\t\tPath(i, u, G){\n\t\t\tint v=G.to[i];\n\t\t\tif(vis[v]) continue;\n\t\t\tcalc(v, u, G.val[i], ++C);\n\t\t}\n\t\tans=max(ans, T2::work());\n\t\tPath(i, u, G){\n\t\t\tint v=G.to[i];\n\t\t\tif(vis[v]) continue;\n\t\t\trt=0, Size=sz[v];\n\t\t\tget_sz(v, u);\n\t\t\tdivide(rt);\n\t\t}\n\t}\n\tinline ll work(){\n\t\tans=-inf;\n\t\tfor(int i=1; i<=n; ++i)\n\t\t\tans=max(ans, d[i]-T2::d[i]);\n\t\trt=0, Size=n;\n\t\tget_sz(1, 0);\n\t\tdivide(rt);\n\t\treturn ans;\n\t}\n}\nint main(){\n\tread(n);\n\tT1::init();\n\tT2::init();\n\tprintf(\"%lld\\n\", T1::work());\n\treturn 0;\n}\n```\n",
        "postTime": 1593354789,
        "uid": 68203,
        "name": "wyt2357",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "\u7ed9\u5b9a\u4e24\u68f5\u6811\uff0c\u6c42 $\\text{depth}(x)+\\text{depth}(y)-(\\text{depth}(\\text{lca}(x,y))+\\text{depth}'(\\text{lca}'(x,y)))$ \u7684\u6700\u5927\u503c\uff0c$n\\leqslant 366666$\u3002\n\n\u8fd9\u91cc\u6709\u4e00\u4e2a\u53eb\u505a\u8fb9\u5206\u6811\u5408\u5e76\u7684\u4e1c\u897f\uff0c\u6211\u4eec\u8003\u8651\u8fb9\u5206\u6cbb\u8fc7\u7a0b\u4e2d\uff0c\u628a\u6bcf\u6b21\u5206\u6cbb\u7684\u8fb9\u770b\u4f5c\u70b9\uff0c\u5206\u6cbb\u8fc7\u7a0b\u4e2d\u76f8\u90bb\u4e24\u5c42\u7684\u91cd\u8fb9\u8fde\u8fb9\uff0c\u5f53\u8fde\u901a\u5757\u5927\u5c0f\u4e3a $1$ \u65f6\uff0c\u4e0e\u70b9\u8fde\u8fb9\uff0c\u8fd9\u6837\u4f1a\u5f62\u6210\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5176\u4e2d\u53f6\u5b50\u90fd\u662f\u539f\u6811\u4e2d\u7684\u70b9\uff0c\u975e\u53f6\u5b50\u662f\u539f\u6811\u4e2d\u7684\u8fb9\u3002\u7136\u540e\u6211\u4eec\u4e00\u5f00\u59cb\u628a\u8fb9\u5206\u6811\u62c6\u6210\u6839\u8282\u70b9\u5230\u6bcf\u4e2a\u53f6\u5b50\u8282\u70b9\u7684\u94fe\uff0c\u5e76\u6309\u7167\u67d0\u79cd\u987a\u5e8f\u5408\u5e76\uff0c\u6ce8\u610f\u5230\u8fb9\u5206\u6811\u662f\u4e8c\u53c9\u6811\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u548c\u7ebf\u6bb5\u6811\u5408\u5e76\u4e00\u6837\u7684\u65b9\u6cd5\u5408\u5e76\u3002\u5e76\u4e14\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8def\u5f84 $(x,y)$ \u7684\u8d21\u732e\uff0c\u5b83\u90fd\u53ef\u4ee5\u5728 $x$ \u548c $y$ \u7b2c\u4e00\u6b21\u88ab\u5408\u5e76\u65f6\u5728\u8fb9\u5206\u6811\u4e2d $x,y$ \u7684 lca \u5904\u7edf\u8ba1\u5230\u3002\n\n\u6211\u4eec\u628a\u7b54\u6848\u6539\u5199\u6210 $\\dfrac{1}{2}(\\text{dis}(x,y)+\\text{depth}(x)+\\text{depth}(y)-2\\text{depth}'(\\text{lca}'(x,y)))$ \u7684\u5f62\u5f0f\uff0c\u6211\u4eec\u8003\u8651\u5bf9\u7b2c\u4e00\u68f5\u6811\u8fdb\u884c\u8fb9\u5206\u6cbb\uff0c\u5e76\u5efa\u51fa\u6bcf\u4e2a\u70b9\u4ece\u6839\u5230\u8fd9\u4e2a\u70b9\u7684\u8fb9\u5206\u6811\uff08$n$ \u6761\u94fe\uff09\uff0c\u6211\u4eec\u5728\u8fb9\u5206\u6811\u4e0a\u6bcf\u4e2a\u975e\u53f6\u5b50\u7ed3\u70b9\u7ef4\u62a4\u4ee5\u4e0b\u4fe1\u606f\uff1a\u5206\u522b\u6765\u81ea\u5de6\u3001\u53f3\u5b50\u6811\u6240\u5305\u542b\u7684\u539f\u6811\u4e2d\u7684\u70b9\u4e2d $\\text{dis}(x)+\\text{depth(x)}$ \u7684\u6700\u5927\u503c $vl,vr$\uff0c\u5176\u4e2d $\\text{dis}(x)$ \u662f $x$ \u5230\u539f\u6811\u4e2d\u8fd9\u4e2a\u70b9\u5bf9\u5e94\u7684\u8fb9\u67d0\u4e00\u4e2a\u7aef\u70b9\u7684\u8ddd\u79bb\u3002\n\n\u63a5\u7740\u6211\u4eec\u5bf9\u7b2c\u4e8c\u68f5\u6811\u8fdb\u884c dfs\uff0c\u6211\u4eec\u679a\u4e3e $\\text{lca}'(x,y)$\uff0c\u6bcf\u9047\u5230\u4e00\u6761\u8fb9\uff0c\u5c31\u628a\u4e24\u4e2a\u7aef\u70b9\u7684\u8fb9\u5206\u6811\u6309\u7167\u7ebf\u6bb5\u6811\u7684\u5408\u5e76\u65b9\u6cd5\u5408\u5e76\u8d77\u6765\uff0c\u7136\u540e\u6211\u4eec\u5728\u5408\u5e76\u8fc7\u7a0b\u4e2d\u7edf\u8ba1\u7b54\u6848\uff1a\u5047\u8bbe\u8fd9\u4e24\u68f5\u8fb9\u5206\u6811\u540c\u65f6\u5305\u62ec\u67d0\u4e00\u4e2a\u70b9\uff0c\u8fd9\u4e2a\u70b9\u5728\u4e24\u68f5\u8fb9\u5206\u6811\u7684\u7f16\u53f7\u5206\u522b\u662f $u,v$\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u7528 $\\max(vl_u+vr_v,vr_u+vl_v)-2\\text{depth}'(\\text{lca}'(x,y))$ \u6765\u66f4\u65b0\u5168\u5c40\u7b54\u6848\uff0c\u5e76\u66f4\u65b0\u5408\u5e76\u540e\u7684\u70b9\u7684 $vl,vr$\uff0c\u4e0d\u96be\u53d1\u73b0\u8fd9\u6837\u7edf\u8ba1\u7684\u70b9\u5bf9 $(x,y)$ \u7684 lca \u4e00\u5b9a\u90fd\u662f\u6211\u4eec\u5f53\u524d\u679a\u4e3e\u5230\u7684\u70b9\u3002\u6ce8\u610f\u7279\u5224 $x=y$ \u7684\u60c5\u51b5\u548c\u8fb9\u5206\u6cbb\u524d\u8bb0\u5f97\u4e09\u5ea6\u5316\u3002\u8fd9\u6837\u505a\u7684\u590d\u6742\u5ea6\u662f $O(n\\log n)$ \u7684\uff08\u8fb9\u5206\u6cbb\u548c\u8fb9\u5206\u6811\u5408\u5e76\u90fd\u662f 1 \u4e2a log \u7684\uff09\u3002\n\n\u53ef\u80fd\u6709\u4e9b\u7ec6\u8282\u53ef\u4ee5\u770b\u4ee3\u7801\uff08\u61d2\u5f97\u5f00 long long \u6240\u4ee5\u4e0d\u505a\u732b\u4e86\uff09\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint const N=366671;\ntemplate<unsigned M>struct graph\n{\n    int target[2*M],pre[2*M],last[M],tot,w[2*M];\n    void add(int x,int y,int z)\n    {\n        target[++tot]=y;\n        pre[tot]=last[x];\n        last[x]=tot;\n        w[tot]=z;\n    }\n};\ngraph<N>g1,g3;graph<N<<1>g2;\nint n,now,siz[N<<1],nows,ed,li,cnt,mx[N<<5|1][2],ch[N<<5|1][2],last[N],dis[N],\ntmp,ans=-1e18,rt[N];\nbool del[N<<2];\nvoid dfs(int x,int fa)\n{\n    int las=x;\n    for(int i=g1.last[x];i;i=g1.pre[i])\n    {\n        int tar=g1.target[i];\n        if(tar==fa)continue;\n        g2.add(las,++now,0),g2.add(now,las,0),g2.add(now,tar,g1.w[i]),g2.add(tar,now,g1.w[i]);\n        dis[tar]=dis[x]+g1.w[i];las=now;dfs(tar,x);\n    }\n}\nvoid dfs2(int x,int fa,int nowd,int op)\n{\n    if(!op)tmp++;\n    if(x<=n)\n    {\n        cnt++;\n        if(!last[x])rt[x]=last[x]=cnt,cnt++;\n        ch[last[x]][op]=cnt;\n        mx[last[x]][op]=dis[x]+nowd;\n        last[x]=cnt;\n    }\n    for(int i=g2.last[x];i;i=g2.pre[i])\n    {\n        int tar=g2.target[i];\n        if(tar==fa||del[i])continue;\n        dfs2(tar,x,nowd+g2.w[i],op);\n    }\n}\nvoid get(int x,int fa)\n{\n    siz[x]=1;\n    for(int i=g2.last[x];i;i=g2.pre[i])\n    {\n        int tar=g2.target[i];\n        if(tar==fa||del[i])continue;\n        get(tar,x);siz[x]+=siz[tar];\n        if(max(siz[tar],nows-siz[tar])<li)li=max(siz[tar],nows-siz[tar]),ed=(i+1)>>1;\n    }\n}\nvoid solve(int x,int s)\n{\n    if(s==1)return;\n    ed=li=1e9;nows=s;\n    get(x,0);\n    int r1=g2.target[(ed<<1)-1],r2=g2.target[ed<<1];\n    del[(ed<<1)-1]=del[ed<<1]=1;tmp=0;\n    dfs2(r1,r2,0,0),dfs2(r2,r1,g2.w[ed<<1],1);\n    int tt=siz[x]-tmp;\n    solve(r1,tmp);solve(r2,tt);\n}\nint merge(int x,int y,int t)\n{\n    if((!x)||(!y))return x+y;\n    ans=max(ans,max(mx[x][0]+mx[y][1],mx[y][0]+mx[x][1])+2*t);\n    mx[x][0]=max(mx[x][0],mx[y][0]),mx[x][1]=max(mx[x][1],mx[y][1]);\n    ch[x][0]=merge(ch[x][0],ch[y][0],t),ch[x][1]=merge(ch[x][1],ch[y][1],t);\n    return x;\n}\nvoid dfs3(int x,int fa,int nowd)\n{\n    ans=max(ans,2*(dis[x]-nowd));\n    for(int i=g3.last[x];i;i=g3.pre[i])\n    {\n        int tar=g3.target[i];\n        if(tar==fa)continue;\n        dfs3(tar,x,nowd+g3.w[i]);\n        rt[x]=merge(rt[x],rt[tar],-nowd);\n    }\n}\nsigned main()\n{\n    memset(mx,0xc0,sizeof(mx));\n    int x,y,z;\n    scanf(\"%lld\",&n);now=n;\n    for(int i=1;i<n;i++)scanf(\"%lld%lld%lld\",&x,&y,&z),g1.add(x,y,z),g1.add(y,x,z);\n    dfs(1,0);\n    solve(1,now);\n    for(int i=1;i<n;i++)scanf(\"%lld%lld%lld\",&x,&y,&z),g3.add(x,y,z),g3.add(y,x,z);\n    dfs3(1,0,0);\n    printf(\"%lld\",ans>>1);\n    return 0;\n}\n```\n",
        "postTime": 1611126437,
        "uid": 96912,
        "name": "AzusaCat",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "[\u9898\u76ee](https://www.luogu.org/problem/P4565)\n\n\u8fb9\u5206\u6cbb+\u865a\u6811=\u53cc\u500d\u7684\u5feb\u4e50\n\n\u8fd9\u4e2a\u67ff\u5b50\u91cc\u6709\u4e24\u4e2a$LCA$\uff0c\u6211\u4eec\u8003\u8651\u9b54\u6539\u4e00\u4e0b\u524d\u9762\u7684$\\operatorname{depth(x)+depth(y)-depth(LCA(x,y))}$\uff0c\u4e3a\u4e86\u65b9\u4fbf\u8fb9\u5206\uff0c\u6211\u4eec\u8003\u8651\u628a$\\operatorname{depth(LCA(x,y))}$\u53bb\u6389\u53d8\u6362\u4e3a\u6811\u4e0a\u8ddd\u79bb\n\n\u7ecf\u8fc7\u4e00\u756a\u9b54\u6539\uff0c\u8fd9\u4e2a\u67ff\u5b50\u53d8\u6210\u4e86$\\frac{1}{2}(\\operatorname{depth(x)+depth(y)+dis(x,y)})$\n\n\u81f3\u4e8e\u7b2c\u4e8c\u68f5\u6811\u4e0a\u7684$\\operatorname{LCA}$\uff0c\u6211\u4eec\u53ea\u80fd\u8003\u8651\u5230\u865a\u6811\u4e0a\u53bb\u641e\u4e86\n\n\u5bf9\u4e8e\u5f53\u524d\u7684\u5206\u6cbb\u8fb9$w$\uff0c\u6211\u4eec\u5904\u7406\u5904\u5206\u5757\u5185\u6240\u6709\u70b9$i$\u5230\u8fd9\u6761\u8fb9\u7684\u8ddd\u79bb$p_i$\uff0c\u90a3\u4e48$\\operatorname{depth(x)+depth(y)+dis(x,y)}=p_x+p_y+w+depth_x+depth_y$\n\n\u540c\u65f6\u6211\u4eec\u628a\u5206\u6cbb\u8fb9\u5de6\u53f3\u4e24\u8fb9\u7684\u70b9\u9ed1\u767d\u67d3\u8272\uff0c\u70b9\u6743\u8bbe\u4e3a$p_i+depth_i$\uff0c\u5230\u7b2c\u4e8c\u9897\u6811\u4e0a\u53bb\u5efa\u865a\u6811\uff0c\u5bf9\u4e8e\u865a\u6811\u4e0a\u7684\u6bcf\u4e2a\u70b9\u8003\u8651\u5176\u4f5c\u4e3a$\\operatorname{LCA}$\u65f6\u7684\u8d21\u732e\uff0c\u4e8e\u662f\u628a\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u5728\u4e00\u4e2a\u70b9\u7684\u4e0d\u540c\u513f\u5b50\u91cc\u627e\u5230\u4e00\u5bf9\u5f02\u8272\u70b9\uff0c\u4f7f\u5f97\u70b9\u6743\u6700\u5927\uff0c\u663e\u7136\u76f4\u63a5\u865a\u6811\u4e0adp\u5c31\u597d\u4e86\n\n\u5982\u679c\u865a\u6811\u5b9e\u73b0\u5f97\u4e0d\u597d\uff0c\u8fd9\u4e2a\u7b97\u6cd5\u5c31\u662f$\\operatorname{O(nlog^2n)}$\n\n\u5982\u679c\u4f7f\u7528st\u8868\u6c42$\\operatorname{LCA}$\uff0c\u5e76\u4e14\u5728\u4e00\u5f00\u59cb\u5c31\u628a\u6240\u6709\u70b9\u6309\u7167$\\operatorname{dfn}$\u6392\u5e8f\uff0c\u6bcf\u6b21\u6839\u636e\u8fd9\u4e2a\u70b9\u67d3\u6210\u7684\u989c\u8272\u5206\u5230\u4e24\u4e2a\u63a5\u4e0b\u6765\u7684\u5206\u6cbb\u5757\u91cc\u53bb\uff0c\u5c31\u80fd\u505a\u5230\u7ebf\u6027\u5efa\u865a\u6811\uff0c\u6574\u4e2a\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\u5c31\u80fd\u5230$\\operatorname{O(nlogn)}$\n\n\u8bb0\u5f97\u7279\u5224$x=y$\u7684\u60c5\u51b5\n\n\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n#define re register\n#define LL long long\n#define pt putchar(1)\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\nconst int maxn=366667;\nconst int M=maxn*4;\nconst LL inf=-1e15;\ninline int read() {\n\tchar c=getchar();int x=0,r=1;\n\twhile(c<'0'||c>'9') {if(c=='-') r=-1;c=getchar();}\n\twhile(c>='0'&&c<='9') x=(x<<3ll)+(x<<1ll)+c-48,c=getchar();return r*x;\n}\nstd::vector<int> son[M];\nstd::vector<LL> v[M];\nstruct E{int v,nxt,w;}e[M<<1];\nint head[M],sum[M],vis[M],dfn[maxn],b[maxn];\nint S,mnow,rn,n,num,col[maxn],rt,Mnow,tp[2],c[2][maxn];\nLL g[maxn],dp[maxn][2],deep[maxn],tmp,ans;\ninline int cmp(int A,int B) {return dfn[A]<dfn[B];}\ninline void add(int x,int y,LL w) {\n\te[++num].v=y;e[num].nxt=head[x];head[x]=num,e[num].w=w;\n}\nvoid dfs1(int x,int fa) {\n\tfor(re int i=head[x];i;i=e[i].nxt) {\n\t\tif(e[i].v==fa) continue;\n\t\tdeep[e[i].v]=deep[x]+e[i].w;\n\t\tson[x].push_back(e[i].v);v[x].push_back(e[i].w);\n\t\tdfs1(e[i].v,x);\n\t}\n} \nvoid getrt(int x,int fa) {\n\tsum[x]=1;\n\tfor(re int i=head[x];i;i=e[i].nxt) {\n\t\tif(vis[i>>1]||e[i].v==fa) continue;\n\t\tgetrt(e[i].v,x);sum[x]+=sum[e[i].v];\n\t\tint now=max(sum[e[i].v],S-sum[e[i].v]);\n\t\tif(now<Mnow) Mnow=now,rt=i;\n\t}\n}\nstruct Virtual_Tree {\n\tstruct E{int v,nxt,w;}e[maxn<<1];\n\tint pos[maxn],f[21][maxn<<1],lg[maxn<<1];\n\tLL pre[maxn];int num,cnt,tot,head[maxn],top,st[maxn],d[maxn],root;\n\tinline void add(int x,int y,LL w) {\n\t\te[++num].v=y;e[num].nxt=head[x];head[x]=num;e[num].w=w;\n\t}\n\tvoid dfs(int x) {\n\t\tdfn[x]=++cnt,f[0][++tot]=x;pos[x]=tot;\n\t\tfor(re int i=head[x];i;i=e[i].nxt) {\n\t\t\tif(dfn[e[i].v]) continue;\n\t\t\tpre[e[i].v]=pre[x]+e[i].w;d[e[i].v]=d[x]+1;\n\t\t\tdfs(e[i].v);f[0][++tot]=x;\n\t\t}\n\t}\n\tinline int LCA(int x,int y) {\n\t\tint l=pos[x],r=pos[y];\n\t\tif(l>r) std::swap(l,r);\n\t\tint k=lg[r-l+1];\n\t\tif(d[f[k][l]]<d[f[k][r-(1<<k)+1]]) return f[k][l];\n\t\treturn f[k][r-(1<<k)+1];\n\t}\n\tinline void build() {\n\t\tfor(re int x,y,w,i=1;i<rn;i++) {\n\t\t\tx=read(),y=read(),w=read();\n\t\t\tadd(x,y,w),add(y,x,w);\n\t\t}\n\t\td[1]=1;dfs(1);memset(head,0,sizeof(head));\n\t\tfor(re int i=2;i<=tot;i++) lg[i]=lg[i>>1]+1;\n\t\tfor(re int j=1;j<=lg[tot];j++)\n\t\t\tfor(re int i=1;i+(1<<(j-1))<=tot;i++)\n\t\t\t\tif(d[f[j-1][i]]<d[f[j-1][i+(1<<(j-1))]]) f[j][i]=f[j-1][i];\n\t\t\t\t\telse f[j][i]=f[j-1][i+(1<<(j-1))];\n\t\tfor(re int i=1;i<=rn;i++) b[i]=i;\n\t\tstd::sort(b+1,b+rn+1,cmp);\n\t}\n\tinline void ins(int x) {\n\t\tif(top<1) {st[++top]=x;return;}\n\t\tint lca=LCA(x,st[top]);\n\t\tif(lca==st[top]) {st[++top]=x;return;}\n\t\twhile(top>1&&dfn[st[top-1]]>=dfn[lca]) \n\t\t\tadd(st[top-1],st[top],0),top--;\n\t\tif(lca!=st[top]) add(lca,st[top],0),st[top]=lca;\n\t\tst[++top]=x;\n\t}\n\tvoid tree_dp(int x) {\n\t\tdp[x][col[x]]=g[x];\n\t\tfor(re int i=head[x];i;i=e[i].nxt) {\n\t\t\ttree_dp(e[i].v);\n\t\t\ttmp=max(tmp,-2ll*pre[x]+dp[x][0]+dp[e[i].v][1]);\n\t\t\ttmp=max(tmp,-2ll*pre[x]+dp[x][1]+dp[e[i].v][0]);\n\t\t\tdp[x][0]=max(dp[x][0],dp[e[i].v][0]);\n\t\t\tdp[x][1]=max(dp[x][1],dp[e[i].v][1]);\n\t\t}\n\t}\n\tinline void get_tree(int l,int r) {\n\t\ttop=0;num=0;\n\t\tif(b[l]!=1) ins(1);\n\t\tfor(re int i=l;i<=r;i++) ins(b[i]);\n\t\twhile(top>1) add(st[top-1],st[top],0),top--;\n\t\ttree_dp(1);\n\t}\n\tvoid del(int x) {\n\t\tfor(re int i=head[x];i;i=e[i].nxt) del(e[i].v);\n\t\tdp[x][0]=dp[x][1]=g[x]=inf;head[x]=0;\n\t}\n}T;\nvoid dfs2(int x,int fa,int o,LL d) {\n\tif(x<=rn) col[x]=o,g[x]=deep[x]+d;\n\tfor(re int i=head[x];i;i=e[i].nxt) {\n\t\tif(vis[i>>1]||e[i].v==fa) continue;\n\t\tdfs2(e[i].v,x,o,d+e[i].w);\n\t}\n}\nvoid solve(int x,int s,int l,int r) {\n\tif(l>r) return;\n\tMnow=M,S=s,getrt(x,0);\n\tif(Mnow==M) return;vis[rt>>1]=1;\n\tdfs2(e[rt].v,0,0,0),dfs2(e[rt^1].v,0,1,e[rt].w);\n\ttmp=inf;T.get_tree(l,r);\n\tans=max(ans,tmp);\n\ttp[0]=tp[1]=0;T.del(1);\n\tfor(re int i=l;i<=r;i++) c[col[b[i]]][++tp[col[b[i]]]]=b[i];\n\tfor(re int i=l,k=1;k<=tp[0];i++,k++) b[i]=c[0][k];\n\tfor(re int i=l+tp[0],k=1;k<=tp[1];i++,k++) b[i]=c[1][k];\n\tint now=s-sum[e[rt].v],k=rt,L=l+tp[0]-1,R=r-tp[1]+1;\n\tsolve(e[k].v,sum[e[k].v],l,L);\n\tsolve(e[k^1].v,now,R,r);\n}\nint main() {\n\trn=n=read();\n\tfor(re int w,x,y,i=1;i<n;i++) {\n\t\tx=read(),y=read(),w=read();\n\t\tadd(x,y,w),add(y,x,w);\n\t}\n\tdfs1(1,0);num=1;memset(head,0,sizeof(head));\n\tint s[2];\n\tfor(re int i=1;i<=n;i++) {\n\t\tint t=son[i].size();\n\t\tif(!t) continue;\n\t\tif(t==1) {\n\t\t\tadd(i,son[i][0],v[i][0]),add(son[i][0],i,v[i][0]);\n\t\t\tcontinue;\n\t\t}\n\t\tif(t==2) {\n\t\t\tadd(i,son[i][0],v[i][0]),add(son[i][0],i,v[i][0]);\n\t\t\tadd(son[i][1],i,v[i][1]),add(i,son[i][1],v[i][1]);\n\t\t\tcontinue;\n\t\t}\n\t\ts[0]=++n,s[1]=++n;\n\t\tadd(i,s[0],0),add(s[0],i,0);add(i,s[1],0),add(s[1],i,0);\n\t\tfor(re int j=0;j<v[i].size();j++)\n\t\t\tson[s[j&1]].push_back(son[i][j]),v[s[j&1]].push_back(v[i][j]);\n\t}\n\tT.build();ans=inf;\n\tfor(re int i=1;i<=rn;i++) dp[i][0]=dp[i][1]=g[i]=inf;\n\tsolve(1,n,1,rn);ans>>=1ll;\n\tfor(re int i=1;i<=n;i++) ans=max(ans,deep[i]-T.pre[i]);\n\tstd::cout<<ans;\n\treturn 0;\n}\n```\n",
        "postTime": 1565002293,
        "uid": 35178,
        "name": "asuldb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "**\u9898\u610f**:  \n\n> \u7ed9\u4e24\u68f5\u6811 $A,B$ ,\u6c42 $\\max depA_x+depA_y-(depA_{lca(x,y)}+depB_{lca(x,y)})$ .  \n>\n> $n\\le366666$ .  \n\n**\u9898\u89e3**:  \n\n> \u70b9\u5206+\u865a\u6811.  \n>\n> \u65f6\u95f4\u4e45\u8fdc,\u4ec5\u53e3\u80e1.  \n>\n> \u5148\u5904\u7406 $x=y$ \u7684\u60c5\u51b5.  \n>\n> \u5c06\u67ff\u5b50\u53d8\u5f62: $\\frac{1}{2}(depA_x+depA_y+disA(x,y)-2depB_{lca(x,y)})$ .  \n>\n> (\u5148 $\\times2$ \u6700\u540e\u518d\u9664\u56de\u6765).  \n>\n> \u5728 $A$ \u4e0a\u70b9\u5206,\u8bbe $u$ \u4e3a\u5206\u6cbb\u4e2d\u5fc3,\u7ed9\u6bcf\u4e2a\u70b9\u70b9\u6743 $a_x=depA_x+disA(u,x)$ ,\u5e76\u6309\u5b50\u6811\u7ed9\u6bcf\u4e2a\u70b9\u989c\u8272.  \n>\n> (\u6ce8\u610f\u8fd9\u91cc\u7684\u6240\u6709\u70b9\u662f\u5728 $u$ \u7684\u5206\u6cbb\u8303\u56f4\u5185\u7684\u70b9).  \n>\n> \u518d\u5c06\u6240\u6709\u70b9\u6309 $B$ \u5efa\u865a\u6811,\u8bbe\u865a\u6811\u4e3a $C$ ,\u7b54\u6848\u4e3a $C$ \u4e2d $\\max\\limits_{col_x\\not=col_y}a_x+a_y-2depB(lca(x,y))$ .  \n>\n> \u5728 $C$ \u4e0a dp , $f[u][2]$ \u8bb0\u5f55 $u$ \u5b50\u6811\u5185\u989c\u8272\u4e0d\u540c\u7684\u4e24\u70b9\u7684\u6700\u5927\u6743\u503c\u53ca\u5176\u989c\u8272,\u5408\u5e76\u65f6\u5c06\u4e0d\u540c\u989c\u8272\u5408\u5e76.  \n>\n> $O(n\\log^2n)$ .  \n>\n> (\u4e3a\u5565\u627e\u4e0d\u5230\u70b9\u5206\u9898\u89e3\u554a,\u5168\u662f\u8fb9\u5206).  \n\n```c++\n#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=510000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nint n;\nstruct EDGE { int v,w,nx; };\nstruct TREE2\n{\n\tEDGE lb[N<<1]; int tot=1,top[N];\n\tvoid add (int u,int v,int w) { lb[++tot]=(EDGE){v,w,top[u]},top[u]=tot; }\n\tLL dis[N]; int dep[N],siz[N],son[N],faa[N];\n\tvoid dfs0 (int u,int fa)\n\t{\n\t\tdep[u]=dep[faa[u]=fa]+(siz[u]=1);\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\tif (v==fa) continue;\n\t\t\tdis[v]=dis[u]+w;\n\t\t\tdfs0 (v,u);\n\t\t\tsiz[u]+=siz[v];\n\t\t\tif (siz[v]> siz[son[u]]) son[u]=v;\n\t\t}\n\t}\n\tint dfn[N],ddd[N],tf[N];\n\tvoid dfs00 (int u,int tof)\n\t{\n\t\ttf[u]=tof;\n\t\tddd[dfn[u]=++dfn[0]]=u;\n\t\tif (son[u]) dfs00 (son[u],tof);\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v;\n\t\t\tif (v==faa[u]||v==son[u]) continue;\n\t\t\tdfs00 (v,v);\n\t\t}\n\t}\n\tint lca (int x,int y)\n\t{\n\t\twhile (tf[x]!=tf[y])\n\t\t{\n\t\t\tif (dep[tf[x]]< dep[tf[y]]) swap (x,y);\n\t\t\tx=faa[tf[x]];\n\t\t}\n\t\treturn dep[x]< dep[y]?x:y;\n\t}\n}B;\nLL ans=-1e18;\nLL a[N]; int col[N];\nstruct TREE3\n{\n\tstruct EDGE { int v,nx; }lb[N]; int tot=1,top[N];\n\tvoid add (int u,int v) { lb[++tot]=(EDGE){v,top[u]},top[u]=tot; }\n\tint st[N],z=0;\n\tvoid init () { tot=1; z=0; }\n\tvoid ins (int x)\n\t{\n\t    if (z<=1) return st[++z]=x,void ();\n\t    int y=B.lca (x,st[z]);\n\t    if (y==st[z]) return st[++z]=x,void ();\n\t    while (B.dep[st[z-1]]>=B.dep[y]) add (st[z-1],st[z]),--z;\n\t    if (y!=st[z]) add (y,st[z]),st[z]=y;\n\t    st[++z]=x;\n\t}\n\tvoid build (int *q,int n)\n\t{\n\t\tinit ();\n\t\tif (q[1]!=1) ins (1);\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tins (q[i]);\n\t\twhile (z> 1) add (st[z-1],st[z]),--z;\n\t}\n\tstruct LY { LL w; int c; }f[N][2],O;\n\tvoid update (int u,LY x)\n\t{\n\t\tif (f[u][1].c==x.c) chkmax (f[u][1].w,x.w);\n\t\telse if (f[u][0].c==x.c) chkmax (f[u][0].w,x.w);\n\t\telse if (f[u][1].w< x.w) f[u][1]=x;\n\t\tif (f[u][1].w> f[u][0].w) swap (f[u][0],f[u][1]);\n\t}\n\tvoid dfs (int u)\n\t{\n\t\tf[u][0]=f[u][1]=O;\n\t\tif (col[u]) update (u,(LY){a[u],col[u]});\n\t\tcol[u]=a[u]=0;\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v;\n\t\t\tdfs (v);\n\t\t\tfor (int i=0; i<=1; i++)\n\t\t\t\tfor (int j=0; j<=1; j++)\n\t\t\t\t\tif (f[u][i].c!=f[v][j].c) chkmax (ans,f[u][i].w+f[v][j].w-2*B.dis[u]);\n\t\t\tfor (int j=0; j<=1; j++)\n\t\t\t\tupdate (u,f[v][j]);\n\t\t}\n\t\ttop[u]=0;\n\t}\n}C;\n\nstruct TREE1\n{\n\tEDGE lb[N<<1]; int tot=1,top[N];\n\tvoid add (int u,int v,int w) { lb[++tot]=(EDGE){v,w,top[u]},top[u]=tot; }\n\tLL dis[N];\n\tvoid dfs0 (int u,int fa)\n\t{\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\tif (v==fa) continue;\n\t\t\tdis[v]=dis[u]+w;\n\t\t\tdfs0 (v,u);\n\t\t}\n\t}\n\tint siz[N],masiz[N]; bool vis[N]; int q[N],he,ta;\n\tvoid dfsiz (int u)\n\t{\n\t\tvis[u]=1;\n\t\tq[++ta]=u;\n\t\tsiz[u]=1,masiz[u]=0;\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v;\n\t\t\tif (vis[v]) continue;\n\t\t\tdfsiz (v);\n\t\t\tsiz[u]+=siz[v];\n\t\t\tchkmax (masiz[u],siz[v]);\n\t\t}\n\t\tvis[u]=0;\n\t}\n\tvoid dfsa (int u,int rt)\n\t{\n\t\tvis[u]=1;\n\t\tq[++ta]=u;\n\t\tcol[u]=rt?rt:u;\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\tif (vis[v]) continue;\n\t\t\ta[v]=a[u]+w;\n\t\t\tdfsa (v,rt?rt:v);\n\t\t}\n\t\tvis[u]=0;\n\t}\n\tvoid solve (int u)\n\t{\n\t\the=1,ta=0; dfsiz (u);\n\t\tint mi=oo,s=siz[u];\n\t\tfor (int i=1; i<=ta; i++)\n\t\t{\n\t\t\tint v=q[i],ma=max (masiz[v],s-siz[v]);\n\t\t\tif (ma< mi) mi=ma,u=v;\n\t\t}\n\t\the=1,ta=0; a[u]=0,dfsa (u,0);\n\t\tsort (q+1,q+ta+1,[](int x,int y) { return B.dfn[x]< B.dfn[y]; });\n\t\tfor (int i=1; i<=ta; i++)\n\t\t\ta[q[i]]+=dis[q[i]];\n\t\tC.build (q,ta);\n\t\tC.dfs (1);\n\t\tvis[u]=1;\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v;\n\t\t\tif (!vis[v]) solve (v);\n\t\t}\n\t}\n}A;\n\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n);\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint x,y,w; sc(x),sc(y),sc(w);\n\t\tA.add (x,y,w),A.add (y,x,w);\n\t}\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint x,y,w; sc(x),sc(y),sc(w);\n\t\tB.add (x,y,w),B.add (y,x,w);\n\t}\n\tA.dfs0 (1,0);\n\tB.dfs0 (1,0),B.dfs00 (1,1); \n\tC.O.w=-1e18,C.O.c=0;\n\tA.solve (1);\n\tans>>=1;\n\tfor (int i=1; i<=n; i++)\n\t\tchkmax (ans,A.dis[i]-B.dis[i]);\n\tpr(ans);\n\n    return 0;\n}",
        "postTime": 1591919752,
        "uid": 109716,
        "name": "ILoLy",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4565 [CTSC2018]\u66b4\u529b\u5199\u6302"
    },
    {
        "content": "\u5927\u5bb6\u597d\u8fd9\u91cc\u662f**\u70b9\u540d\u88ab\u5361**\u7684 $O\\left(n\\log^2{n}\\right)$ \u505a\u6cd5\u3002  \n\nPS\uff1a\u611f\u8c22 [yyb\u5927\u4f6c](https://www.cnblogs.com/cjyyb/p/10197651.html) \u7684\u535a\u5ba2\u7ed9\u849f\u84bb\u7684\u53c2\u8003\u3002  \n\n---\n\n### \u9898\u610f\n\n\u7ed9\u4f60\u4e24\u9897\u6811 $tree1$\u3001$tree2$\uff0c\u8ba9\u4f60\u6c42\u51fa\uff1a \n\n$$\\mathrm{max} \\left\\{ dep(x)+dep(y)-dep(lca(x,y))-dep'(lca'(x,y)) \\right\\}$$ \n\n\u5176\u4e2d\uff1a \n\n$$\nx,y,lca(x,y)\\in \\{ tree1\\}\\ \\ \\ x,y,lca'(x,y) \\in \\{tree2\\}\n$$\n\n\u663e\u7136 $dep'(lca'(x,y))$ \u4e0d\u80fd\u76f4\u63a5\u6c42\uff0c\u8003\u8651\u6811\u5f62 $dp$\u3002\n* \u4e8e\u662f\u6211\u4eec\u53ea\u9700\u8981\u5de7\u5999\u5730\u6c42\u51fa $dep(x)+dep(y)-dep(lca(x,y))$ \u5373\u53ef\u3002\n\n\u8003\u8651\u6539\u4e00\u4e0b\u5f0f\u5b50\uff1a\n\n$$\nAns=\\dfrac{1}{2}\\left( dep(x)+dep(y)+dis(x,y)\\right)\n$$\n\n\u56e0\u4e3a\u51fa\u73b0\u4e86 $dis(x,y)$\uff0c\u8003\u8651\u5bf9\u4e8e $tree1$ \u8fdb\u884c\u8fb9\u5206\u6cbb\uff0c\u7136\u540e\u5bf9\u4e8e$tree2$ \u8fdb\u884c $dp$\u3002\n\n* \u8fd9\u6837\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O\\left( n^2\\log{n}\\right)$\uff0c\u6811\u5f62 $dp$ \u590d\u6742\u5ea6\u4e3a $O(n)$\u3002 \n\n---\n\n\u8003\u8651\u4f18\u5316\uff0c\u8dd1\u865a\u6811 $dp$\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u505a\u5230 $O\\left(n\\log^2{n}\\right)$\u5566\uff01\u4f1a TLE \u4e00\u4e2a\u70b9\u3002  \n\n### tricks\n\n\u500d\u589e $lca$ \u592a\u6162\u4e86\uff0c\u8003\u8651 $O(n\\log{n})-O(1)$ \u7684 `RMQ-LCA`\uff0c\u53ef\u4ee5\u62ff\u6765\u5361\u5361\u5e38\u6570\u3002  \n\n* \u53ef\u4ee5\u901a\u8fc7\u57fa\u6570\u6392\u5e8f\u505a\u5230 $O\\left(n\\log{n}\\right)$\uff0c\u4f46\u662f\u7a9d\u592a\u83dc\u4e86\uff0c\u52a0\u52a0\u7f16\u8bd1\u4f18\u5316\u677e\u677e\u677e\u5c31\u8fc7\u4e86\u3002\n\n\n## Code(\u590d\u5236\u4f1aRe)\n\n```cpp\n// \u4fdd\u8bc1\u4e0d\u5f71\u54cd\u89c2\u770b\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define ak *\n#define ll long long\ninline char getch()\n{\n    static char buf[10000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,10000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc() getch()\nchar qwq;\ninline ll read()\n{\n    ll cz=0,ioi=1;qwq=gc();\n    while(qwq<'0'||qwq>'9') ioi=qwq=='-'?~ioi+1:1,qwq=gc();\n    while(qwq>='0'&&qwq<='9') cz=(cz<<3)+(cz<<1)+(qwq^48),qwq=gc();\n    return cz ak ioi;\n}\nconst int M=400005;\nint ans[2][M],num[2],tp[M],m;\nll res=-1e18,w[M];\nnamespace t2\n{\n    int cnt=1,h[M],dfn[M],low[M],sum,tim,dep[M],st[M<<1][21];\n    int lg2[M<<1],fir[M],vis[M];\n    ll f[M][2],dis[M];\n    struct did{int next,to;ll w;}e[M<<1];\n    void add(re x,re y,ll z) {e[++cnt]=(did){h[x],y,z},h[x]=cnt;}\n    void dfs(re u,re fa)\n    {\n        dep[u]=dep[fa]+1;dfn[u]=++tim;\n        st[++sum][0]=u;fir[u]=sum;\n        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)\n        {\n            if(v==fa) continue;\n            dis[v]=dis[u]+e[i].w;dfs(v,u);\n            st[++sum][0]=u;\n        }\n        low[u]=tim;\n    }\n    int cmp(re x,re y) {return dep[x]<dep[y]?x:y;}\n    void ST()\n    {\n        for(re i=2;i<=sum;i++) lg2[i]=lg2[i>>1]+1;\n        for(re j=1;j<=lg2[sum];j++)\n        for(re i=1;i+(1<<j)-1<=sum;i++)\n        st[i][j]=cmp(st[i][j-1],st[i+(1<<(j-1))][j-1]);\n        memset(h,0,sizeof(h));\n    }\n    int lca(re u,re v)\n    {\n        u=fir[u],v=fir[v];if(u>v) swap(u,v);\n        re k=lg2[v-u+1];\n        return cmp(st[u][k],st[v-(1<<k)+1][k]);\n    }\n    void dp(re u,ll sum)\n    {\n        f[u][0]=f[u][1]=-1e18;\n        if(vis[u]) f[u][tp[u]]=w[u];\n        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)\n        {\n            dp(v,sum);ll nw=max(f[u][0]+f[v][1],f[u][1]+f[v][0]);\n            res=max(res,sum+nw-2*dis[u]);\n            f[u][0]=max(f[u][0],f[v][0]);\n            f[u][1]=max(f[u][1],f[v][1]);\n        }\n        vis[u]=h[u]=0;\n    }\n    int q[M<<1],stk[M],tot;\n    bool dfn_cmp(int a,int b){return dfn[a]<dfn[b];}\n    void svt(ll sum)\n    {\n        cnt=1;tot=0;\n        for(re i=1;i<=num[0];i++) q[++tot]=ans[0][i];\n        for(re i=1;i<=num[1];i++) q[++tot]=ans[1][i];\n        for(re i=1;i<=tot;i++) vis[q[i]]=1;\n        sort(q+1,q+tot+1,dfn_cmp);\n        re top=0; if(q[1]!=1) stk[++top]=1;\n        for(re i=1;i<=tot;i++)\n        {\n            re u=q[i],v=lca(u,stk[top]);\n            while(top>1&&dep[stk[top-1]]>=dep[v])\n            add(stk[top-1],stk[top],0),top--;\n            if(v!=stk[top]) add(v,stk[top],0),stk[top]=v;\n            stk[++top]=u;\n        }\n        while(top>1) add(stk[top-1],stk[top],0),top--;\n        dp(1,sum);\n    }\n};\nnamespace t1\n{\n    int cnt=1,h[M<<2],size[M<<2],vis[M<<2],n,ct,maxn;\n    ll dis[M<<2],dep[M<<2];\n    struct did{int next,to;ll w;}e[M<<3];\n    struct par{int a,b;par() {} par(re x,re y) : a(x),b(y) {}};\n    vector<par>ve[M<<2];\n    void add(re x,re y,ll z)\n    {\n        e[++cnt]=(did){h[x],y,z},h[x]=cnt;\n        e[++cnt]=(did){h[y],x,z},h[y]=cnt;\n    }\n    void pre(re u,re fa)\n    {\n        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)\n        {\n            if(v==fa) continue;\n            ve[u].push_back(par(v,e[i].w));\n            dep[v]=dep[u]+e[i].w,pre(v,u);\n        }\n    }\n    void rebuild()\n    {\n        memset(h,0,sizeof(h));cnt=1;\n        for(re x=1;x<=n;x++)\n        {\n            re sz=ve[x].size();\n            if(sz<=2)\n            {\n                for(re i=0;i<sz;i++)\n                add(x,ve[x][i].a,ve[x][i].b);\n            }\n\t\t\telse\n            {\n                re ls=++n,rs=++n;\n                add(x,ls,0);add(x,rs,0);\n                for(re i=0;i<sz;i++)\n                ve[i&1?ls:rs].push_back(par(ve[x][i].a,ve[x][i].b));\n            }\n        }\n    }\n    void find_ct(re u,re fa,re sum)\n    {\n        size[u]=1;\n        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)\n        {\n            if(v==fa||vis[i>>1]) continue;\n            find_ct(v,u,sum);size[u]+=size[v];\n            re now=max(size[v],sum-size[v]);\n            if(maxn>now) maxn=now,ct=i;\n        }\n    }\n    void dfs(re u,re fa,re pos)\n    {\n        if(u<=m) ans[pos][++num[pos]]=u,tp[u]=pos;\n        for(re i=h[u],v;v=e[i].to,i;i=e[i].next)\n        {\n            if(v==fa||vis[i>>1]) continue;\n            dis[v]=dis[u]+e[i].w,dfs(v,u,pos);\n        }\n    }\n    bool getans()\n    {\n        if(!num[0]&&!num[1]) return 0;\n        for(re i=1;i<=num[0];i++) w[ans[0][i]]+=dis[ans[0][i]]+dep[ans[0][i]];\n        for(re i=1;i<=num[1];i++) w[ans[1][i]]+=dis[ans[1][i]]+dep[ans[1][i]];\n        t2::svt(e[ct].w);\n        for(re i=1;i<=num[0];i++) w[ans[0][i]]-=dis[ans[0][i]]+dep[ans[0][i]];\n        for(re i=1;i<=num[1];i++) w[ans[1][i]]-=dis[ans[1][i]]+dep[ans[1][i]];\n        return 1;\n    }\n    void divide(re u,re sum)\n    {\n        maxn=1e9,find_ct(u,0,sum);\n        if(maxn>=1e9) return;\n        re s=e[ct].to,t=e[ct^1].to;vis[ct>>1]=1;\n        num[0]=num[1]=dis[s]=dis[t]=0;\n        dfs(s,0,0);dfs(t,0,1);\n        if(!getans()) return;\n        re nw=ct,ss=sum-size[e[nw].to];\n        divide(s,size[e[nw].to]);divide(t,ss);\n    }\n};\nint main()\n{\n    int sized=40<<20;\n    __asm__ (\"movq %0,%%rsp\\n\"::\"r\"((char*)malloc(sized)+sized));\n    t1::n=m=read();\n    for(re i=1;i<m;i++)\n    {\n        re x=read(),y=read(),z=read();\n        t1::add(x,y,z);\n    }\n    for(re i=1;i<m;i++)\n    {\n        re x=read(),y=read(),z=read();\n        t2::add(x,y,z);t2::add(y,x,z);\n    }\n    t1::pre(1,0);t1::rebuild();\n    t2::dfs(1,0);t2::ST();\n    t1::divide(1,t1::n);\n    res/=2;\n    for(re i=1;i<=m;i++) res=max(res,t1::dep[i]-t2::dis[i]);\n    printf(\"%lld\\n\",res);\n    return 0; \n}\n```",
        "postTime": 1556107937,
        "uid": 72679,
        "name": "disangan233",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "# Description\n\n\u7ed9\u5b9a\u5927\u5c0f\u4e3a $n$ \u7684\u4e24\u68f5\u6709\u6839\u6811 $T_1,T_2$\uff0c\u4e24\u68f5\u6811\u5747\u4ee5 $1$ \u4e3a\u6839\uff0c\u8fb9\u6709\u6743\u503c\u3002\u5b9a\u4e49 ${\\rm dep}_x$ \u4e3a\u6839\u5230 $x$ \u7684\u8ddd\u79bb\uff0c\u6c42\n\n$$\\max_{x\\le y} {{\\rm dep}T_1}_x+{{\\rm dep}T_1}_y-{{\\rm dep}T_1}_{{\\rm LCA}(x,y)}-{{\\rm dep}T_2}_{{\\rm LCA}(x,y)}$$\n\n\u3002\n\n$n \\le 366666, |V| \\le 2017011328$\uff0c\u65f6\u9650 4s\u3002\n\n# Solution\n\n\u5178\u578b\u7684\u6811\u4e0a\u8ddd\u79bb\u95ee\u9898\uff0c\u4e0d\u59a8\u8003\u8651\u5bf9 $T_1$ \u8fdb\u884c\u70b9\u5206\u6cbb\u3002\n\n${\\rm LCA}(x,y)$ \u4e0d\u662f\u5f88\u597d\u770b\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u539f\u5f0f\u8f6c\u5316\u6210\n\n$$\\dfrac{1}{2}\\bigg({{\\rm dep}T_1}_x+{{\\rm dep}T_1}_y+ {\\rm dis}{T_1}(x,y)-2{{\\rm dep}T_2}_{{\\rm LCA}(x,y)}\\bigg)$$\n\n\u5728\u4ee5 $1$ \u4e3a\u6839\u65f6\uff0c${{\\rm dep}T_1}_x$ \u548c ${{\\rm dep}T_1}_y$ \u90fd\u5f88\u5bb9\u6613\u88ab\u9884\u5904\u7406\u51fa\u6765\u3002\u800c\u5047\u8bbe\u76ee\u524d\u70b9\u5206\u6cbb\u7684\u5206\u6cbb\u4e2d\u5fc3\u4e3a $u$\uff0c${\\rm dis}{T_1}(x,y)$ \u53c8\u53ef\u4ee5\u88ab\u5199\u6210 ${\\rm dis}{T_1}(u,x)+{\\rm dis}{T_1}(u,y)$\u3002\n\n\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u7ed9\u6bcf\u4e2a\u70b9\uff08\u8fd9\u91cc\u7684\u6bcf\u4e2a\u70b9\u90fd\u662f $u$ \u7684\u5206\u6cbb\u8303\u56f4\u5185\u7684\uff09\u8d4b\u4e00\u4e2a\u70b9\u503c $v_x={{\\rm dep}T_1}_x+{\\rm dis}{T_1}(u,x)$\u3002\u6b64\u65f6\u5bf9\u5e94\u5230 $T_2$ \u4e0a\uff0c\u6211\u4eec\u8981\u6c42\u51fa\u7684\u7b54\u6848\u5373\u4e3a\n\n$$\\max v_x+v_y-2{{\\rm dep}T_2}_{{\\rm LCA}(x,y)}$$\n\n\uff08\u6ce8\u610f\u5230\u5047\u5982 $x,y$ \u6765\u81ea $T_1$ \u4e2d $u$ \u7684\u540c\u4e00\u68f5\u5b50\u6811\uff0c\u8fd9\u6837\u4f1a\u7b97\u91cd\uff0c\u6240\u4ee5\u9700\u8981\u5728\u8d4b\u70b9\u503c\u65f6\u540c\u65f6\u7ed9 $T_1$ \u4e2d\u6765\u81ea $u$ \u7684\u4e0d\u540c\u5b50\u6811\u7684\u70b9\u67d3\u4e0d\u540c\u7684\u989c\u8272\uff09\n\n\u8fd9\u4e2a\u663e\u7136\u5c31\u53ef\u4ee5\u7528\u6811\u5f62 DP \u6765\u5904\u7406\u3002\u8bbe $f_{u,0/1}$ \u8868\u793a $u$ \u5b50\u6811\u5185\u989c\u8272\u4e0d\u540c\u7684\u4e24\u4e2a\u70b9\u7684\u6700\u5927\u70b9\u503c\u53ca\u989c\u8272\uff08\u4e0d\u8981\u548c\u4e0a\u9762\u7684 $u$ \u641e\u6df7\u4e86\uff09\u3002\u8f6c\u79fb\u65f6\u5c06\u4e0d\u540c\u5b50\u6811\u7684 $f$ \u5408\u5e76\u5373\u53ef\uff0c\u7b54\u6848\u4e5f\u53ef\u4ee5\u5728\u5408\u5e76\u65f6\u540c\u65f6\u6c42\u51fa\u6765\u3002\u8fd9\u662f NOIP \u8303\u56f4\u5185\u7684 DP\uff0c\u8fd9\u91cc\u4e0d\u505a\u8fc7\u591a\u8bb2\u89e3\u3002\n\n\u4f46\u662f\u5047\u5982\u5bf9\u6574\u68f5 $T_2$ \u8fdb\u884c\u6811\u5f62 DP \u663e\u7136\u662f\u4e0d\u884c\u7684\u3002\u6240\u4ee5\u6211\u4eec\u8981\u5c06 $T_1$ \u4e0a $u$ \u7684\u5206\u6cbb\u8303\u56f4\u5185\u7684\u70b9\u6295\u5f71\u5230 $T_2$ \u4e0a\u5efa\u4e00\u68f5\u865a\u6811\uff0c\u5728\u865a\u6811\u4e0a\u8dd1 DP\uff0c\u8fd9\u6837\u590d\u6742\u5ea6\u5c31\u6709\u4e86\u4fdd\u8bc1\u3002\n\n\u6700\u540e\u5207\u8bb0\u5904\u7406 $x=y$ \u7684\u60c5\u51b5\u3002\n\n\u81f3\u6b64\u6211\u4eec\u5728 $\\mathcal O(n \\log^2 n)$ \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5b8c\u6210\u4e86\u672c\u9898\u3002\n\n# Code\n\n\u4ee3\u7801\u5199\u7684\u5f88\u4e11\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define cmx(x,y) x=max(x,y)\nusing namespace std;\nconst int N=8e5+5;\nint n,sl[N],sz[N],rt,Sum,dfsc,Ans=-1e18,dep1[N],dis[N],fa[N],s[N],d[N],zs[N],tp[N],st[N],top,dep2[N],dis2[N],dfn2[N],a[N],col[N];\nbool vis[N],fl;\nbool mdfk[N];\nstruct Grp {\n\tint NumE,Fir[N];\n\tstruct Edge {\n\t\tint v,w,nxt;\n\t}E[N];\n\tvoid AddE(int u,int v,int w) {\n\t\tE[++NumE]=(Edge){v,w,Fir[u]};\n\t\tFir[u]=NumE;\n\t}\n}T1,T2,X;\nvoid Dfs1(int x,int ft) {\n\tfa[x]=ft,s[x]=1,d[x]=d[ft]+1;\n    for (int i=T2.Fir[x];i;i=T2.E[i].nxt) \n    \tif (T2.E[i].v!=ft) {\n    \t\tDfs1(T2.E[i].v,x);\n\t\t\ts[x]+=s[T2.E[i].v];\n        \tif (s[zs[x]]<s[T2.E[i].v]) zs[x]=T2.E[i].v;\n\t\t}\n}\nvoid Dfs2(int x,int ft) {\n\ttp[x]=ft;\n    if (!zs[x]) return;\n\tDfs2(zs[x],ft);\n    for (int i=T2.Fir[x];i;i=T2.E[i].nxt)\n      \tif (T2.E[i].v!=fa[x] && T2.E[i].v!=zs[x])\n\t\t\tDfs2(T2.E[i].v,T2.E[i].v);\n}\nint LCA(int x,int y) {\n\twhile (tp[x]!=tp[y]) {\n\t\tif (d[tp[x]]<d[tp[y]]) swap(x,y);\n\t\tx=fa[tp[x]];\n\t}\n\tif (d[x]>d[y]) swap(x,y);\n\treturn x;\n}\nvoid GetR(int x,int fa) {\n\tsl[x]=0,sz[x]=1;\n\tfor (int i=T1.Fir[x];i;i=T1.E[i].nxt) {\n\t\tif (!vis[T1.E[i].v] && T1.E[i].v!=fa) {\n\t\t\tif (!fl) dep1[T1.E[i].v]=dep1[x]+T1.E[i].w;\n\t\t\tGetR(T1.E[i].v,x);\n\t\t\tsl[x]=max(sl[x],sz[T1.E[i].v]);\n\t\t\tsz[x]+=sz[T1.E[i].v];\n\t\t}\n\t}\n\tsl[x]=max(sl[x],Sum-sz[x]);\n\tif (sl[x]<sl[rt]) rt=x;\n}\nint cnt;\nstruct ddd {\n\tint v,id,col;\n\tbool operator<(const ddd &x) const {\n\t\treturn dfn2[id]<dfn2[x.id];\n\t}\n}p[N];\nvoid GetD(int x,int fa,int gua) {\n\tp[++cnt]=(ddd){dis[x]+dep1[x],x,gua};\n\tfor (int i=T1.Fir[x];i;i=T1.E[i].nxt) {\n\t\tint to=T1.E[i].v;\n\t\tif (!vis[to] && to!=fa) {\n\t\t\tdis[to]=dis[x]+T1.E[i].w;\n\t\t\tGetD(to,x,gua);\n\t\t}\n\t}\n}\nvoid gsmg(int x,int fa) {\n\tdfn2[x]=++dfsc;\n\tdep2[x]=dep2[fa]+1;\n\tfor (int i=T2.Fir[x];i;i=T2.E[i].nxt) {\n\t\tint to=T2.E[i].v;\n\t\tif (to!=fa) {\n\t\t\tdis2[to]=dis2[x]+T2.E[i].w;\n\t\t\tgsmg(to,x);\n\t\t}\n\t}\n}\nvoid InsV(int x) {\n\tif (!top) {\n\t\tst[1]=x,top=1;\n\t\treturn;\n\t}\n\tint lca=LCA(st[top],x);\n\twhile (top>1 && dep2[lca]<dep2[st[top-1]])\n\t\tX.AddE(st[top-1],st[top],0),top--;\n\tif (dep2[lca]<dep2[st[top]])\n\t\tX.AddE(lca,st[top],0),top--;\n\tif (!top || st[top]!=lca) st[++top]=lca;\n\tst[++top]=x;\n}\nstruct jjzf {\n\tint v,c;\n}f[N][2];\nvoid Chg(int x,jjzf y) {\n\tif (f[x][0].c==y.c) cmx(f[x][0].v,y.v);\n\telse if (f[x][1].c==y.c) cmx(f[x][1].v,y.v);\n\telse if (f[x][1].v<y.v) f[x][1]=y;\n\tif (f[x][0].v<f[x][1].v) swap(f[x][0],f[x][1]);\n}\nvoid Dp2(int u) {\n\tf[u][0].v=f[u][1].v=-1e18;\n\tf[u][0].c=f[u][1].c=0;\n\tif (col[u]) Chg(u,(jjzf){a[u],col[u]});\n\tcol[u]=a[u]=0;\n\tfor (int i=X.Fir[u];i;i=X.E[i].nxt) {\n\t\tint to=X.E[i].v;\n\t\tDp2(to);\n\t\tfor (int j=0;j<=1;j++)\n\t\t\tfor (int k=0;k<=1;k++)\n\t\t\t\tif (f[u][j].c!=f[to][k].c)\n\t\t\t\t\tcmx(Ans,f[u][j].v+f[to][k].v-dis2[u]*2);\n\t\tChg(u,f[to][0]),Chg(u,f[to][1]);\n\t}\n\tX.Fir[u]=0;\n}\nvoid Dfs(int u) {\n\tdis[u]=0;\n\tvis[u]=1;\n\tcnt=0;\n\tp[++cnt]=(ddd){dep1[u],u,u};\n\tfor (int i=T1.Fir[u];i;i=T1.E[i].nxt) {\n\t\tint to=T1.E[i].v;\n\t\tif (!vis[to]) {\n\t\t\tdis[to]=dis[u]+T1.E[i].w;\n\t\t\tGetD(to,u,to);\n\t\t}\n\t}\n\tGetR(u,0);\n\tsort(p+1,p+cnt+1);\n\ttop=0;\n\tif (p[1].id!=1) InsV(1);\n\tfor (int i=1;i<=cnt;i++) InsV(p[i].id),a[p[i].id]=p[i].v,col[p[i].id]=p[i].col;\n\tif (top) {\n\t\twhile (--top) X.AddE(st[top],st[top+1],0)/*,printf(\"%lld %lld\\n\",st[top],st[top+1])*/;\n\t}\n\tDp2(1);\n\tfor (int i=1;i<=X.NumE;i++) X.E[i]=(Grp::Edge){0,0,0};\n\tX.NumE=0;\n\tfor (int i=T1.Fir[u];i;i=T1.E[i].nxt) {\n\t\tint to=T1.E[i].v;\n\t\tif (!vis[to]) {\n\t\t\trt=0,Sum=sz[to],sl[0]=n;\n\t\t\tGetR(to,u);Dfs(rt);\n\t\t}\n\t}\n}\nsigned main() {\n\tscanf(\"%lld\",&n);\n\tfor (int i=1;i<n;i++) {\n\t\tint x,y,z;\n\t\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n\t\tT1.AddE(x,y,z),T1.AddE(y,x,z);\n\t}\n\tfor (int i=1;i<n;i++) {\n\t\tint x,y,z;\n\t\tscanf(\"%lld%lld%lld\",&x,&y,&z);\n\t\tT2.AddE(x,y,z),T2.AddE(y,x,z);\n\t}\n\tSum=sl[0]=n;\n\tGetR(1,0);fl=1;\n\tgsmg(1,0);\n\tDfs1(1,0),Dfs2(1,1);\n//\tprintf(\"%lld\\n\",LCA(4,5));\n//\tfor (int i=1;i<=n;i++) printf(\"%lld\\n\",dep2[i]);\n\tDfs(rt);\n\tAns/=2;\n\tfor (int i=1;i<=n;i++) cmx(Ans,dep1[i]-dis2[i]);\n\tprintf(\"%lld\",Ans);\n\treturn 0;\n}\n```\n",
        "postTime": 1657067790,
        "uid": 283913,
        "name": "ZillionX",
        "ccfLevel": 6,
        "title": "\u3010\u70b9\u5206\u6cbb\uff0c\u865a\u6811\u3011P4565 [CTSC2018]\u66b4\u529b\u5199\u6302"
    },
    {
        "content": "\u4f3c\u4e4e\u57fa\u672c\u6ca1\u6709\u8fb9\u5206\u6cbb+\u865a\u6811\u7684\u505a\u6cd5\uff1f\n\n\u5b9a\u4e49 $dis_k(x, y)$ \u8868\u793a\u70b9\u5bf9 $(x, y)$ \u5728\u7b2c $k$ \u68f5\u6811\u4e0a\u7684\u8ddd\u79bb\u3002\n\u5219\u539f\u201c\u8ddd\u79bb\u201d\u5f0f\u53ef\u4ee5\u8f6c\u5316\u4e3a\uff1a$\\dfrac{1}{2}dis_1(x,y)+\\dfrac{1}{2}depth_1(x)+\\dfrac{1}{2}depth_1(y)-depth_2(LCA_2(x,y))$\n\n\u5982\u679c\u8fb9\u6743\u5747\u975e\u8d1f\uff0c\u90a3\u4e48\u6700\u8fdc\u70b9\u5bf9\u4fe1\u606f\u53ef\u4ee5\u5408\u5e76\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u7528\u7c7b\u4f3c\u4e8e\u901a\u9053\u8fd9\u4e00\u9898\u4e2d\u7684\u65b9\u6cd5\u6765\u89e3\u51b3\u3002\u4f46\u662f\u8fd9\u91cc\u8fb9\u6743\u53ef\u80fd\u4e3a\u8d1f\u6570\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5bf9\u7b2c\u4e00\u68f5\u6811\u8fdb\u884c\u8fb9\u5206\u6cbb\u5047\u8bbe\u7b2c\u4e00\u68f5\u6811\u4e0a\u8282\u70b9 $x$ \u5230\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3\u7684\u8ddd\u79bb\u4e3a $D(x)$\uff0c\u5219\u539f\u5f0f\u53ef\u4ee5\u8fdb\u4e00\u6b65\u8f6c\u5316\u4e3a\n$\\dfrac{1}{2}(depth_1(x) + D(x) +depth_1(y) + D(y))-depth_2(LCA_2(x, y))$\n\n\u76f4\u63a5\u5728\u7b2c\u4e8c\u68f5\u6811\u4e0a\u5efa\u51fa\u865a\u6811\uff0c\u7136\u540e\u5728\u6811\u4e0a DFS\uff0c\u5e76\u8bb0\u5f55\u5b50\u6811\u5185\u8282\u70b9\u5728\u8fb9\u5206\u6cbb\u4e2d\u4e0d\u540c\u5b50\u6811\u4e2d $depth_1(x) + D(x)$ \u7684\u6700\u5927\u503c\uff0c\u8bb0\u4e3a $f_1(x),f_2(x)$\uff0c\u8fd9\u6837\u5728\u5408\u5e76\u5b50\u6811\u7684\u65f6\u5019\u7528 $f_1(x)+f_2(y)$ \u548c $f_2(x)+f_1(y)$ \u66f4\u65b0\u7b54\u6848\u5373\u53ef\uff08\u5176\u5b9e\u5c31\u662f\u6c42\u76f4\u5f84\u7684\u53e6\u4e00\u79cd\u65b9\u6cd5\uff09\u3002\n\n\u590d\u6742\u5ea6\u74f6\u9888\u5728\u4e8e\u5efa\u865a\u6811\u524d\u7684\u6392\u5e8f\u800c\u8fd9\u4e00\u90e8\u5206\u53ef\u4ee5\u7528\u5728\u901a\u9053\u4e00\u9898\u4e2d\u4f7f\u7528\u7684\u5f52\u5e76\u65b9\u5f0f\u5feb\u901f\u89e3\u51b3\uff0c\u590d\u6742\u5ea6 $O(n\\log n)$\u3002\n\n\u4ee3\u7801\u633a\u6a21\u5757\u5316\u7684\uff0c\u5c31\u662f\u8dd1\u5f97\u592a\u6162\u4e86\u3002\u3002\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define N 800005\n#define ll long long\nusing namespace std;\nconst ll inf=1ll<<61;\nint n,Log[N],is[N];ll W[N],ans=-inf;\ninline int read() {\n\tint s=0,f=0;\n\tchar ch=getchar();\n\twhile(ch<48||ch>57)f|=(ch=='-'),ch=getchar();\n\twhile(ch>47&&ch<58)s=(s<<1)+(s<<3)+(ch^48),ch=getchar();\n\treturn f?-s:s;\n}\nnamespace T2 {\n\tint h[N],cnt,nx[N<<1],to[N<<1],vl[N<<1],s[N];\n\tint dfn[N],in[N],tot,t2,fp[N<<1],dep[N],top;\n\tll dis[N],f1[N],f2[N];vector<int>g[N];\n\tstruct node {\n\t\tint dep,x;\n\t\tnode(int D=0,int X=0){dep=D,x=X;}\n\t\tbool operator<(node a) const {return dep<a.dep;}\n\t} rmq[20][N];\n\tvoid Addedge(int x,int y,int z) {nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z,nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;}\n\tvoid Dfs(int x,int fa) {\n\t\tdfn[x]=++tot,dep[x]=dep[fa]+1,fp[in[x]=++t2]=x;\n\t\tfor(int i=h[x],y; i; i=nx[i])if((y=to[i])!=fa)dis[y]=dis[x]+vl[i],Dfs(y,x),fp[++t2]=x;\n\t}\n\tvoid Pre() {\n\t\tfor(int i=1; i<=t2; ++i)rmq[0][i]=node(dep[fp[i]],fp[i]);\n\t\tfor(int j=1; (1<<j)<=t2; ++j)for(int i=1; i+(1<<j)<=t2+1; ++i)rmq[j][i]=min(rmq[j-1][i],rmq[j-1][i+(1<<j-1)]);\n\t}\n\tint Lca(int x,int y) {\n\t\tif(in[x]<in[y])swap(x,y);int len=Log[in[x]-in[y]+1];\n\t\treturn min(rmq[len][in[y]],rmq[len][in[x]-(1<<len)+1]).x;\n\t}\n\tvoid Calc(int x) {\n\t\tif(is[x]==1)f1[x]=max(f1[x],W[x]);if(is[x]==0)f2[x]=max(f2[x],W[x]);\n\t\tfor(int y:g[x]) {\n\t\t\tCalc(y),ans=max(ans,(max(f1[x]+f2[y],f2[x]+f1[y])>>1)-dis[x]);\n\t\t\tf1[x]=max(f1[x],f1[y]),f2[x]=max(f2[x],f2[y]);\n\t\t}\n\t}\n\tvoid Clear(int x) {f1[x]=f2[x]=-inf;for(int y:g[x])Clear(y);is[x]=-1,g[x].clear();}\n\tvoid Solve(vector<int>&p) {\n\t\ts[top=1]=1;\n\t\tfor(int x:p) {\n\t\t\tint lca=Lca(s[top],x);\n\t\t\tif(lca==s[top])((x!=s[top])?s[++top]=x:0);\n\t\t\telse {\n\t\t\t\twhile(dep[s[top-1]]>dep[lca])g[s[top-1]].push_back(s[top]),--top;\n\t\t\t\tif(g[lca].push_back(s[top--]),s[top]!=lca)s[++top]=lca;if(s[top]!=x)s[++top]=x;\n\t\t\t}\n\t\t}\n\t\twhile(top>1)g[s[top-1]].push_back(s[top]),--top;Calc(1),Clear(1);\n\t}\n}\nnamespace T1 {\n\tint h[N],cnt=1,nx[N<<1],to[N<<1],vl[N<<1],siz[N],vis[N],mn,E,gs;\n\tll dis[N],dep[N];vector<int>p[N];\n\tbool cmp(int x,int y) {return T2::dfn[x]<T2::dfn[y];}\n\tstruct node {\n\t\tint x,v;\n\t\tnode(int _x=0,int _v=0) {x=_x,v=_v;}\n\t\tbool operator!=(node a) const {return x!=a.x||v!=a.v;}\n\t};\n\tvector<node>g[N];\n\tvoid Addedge(int x,int y,int z) {g[x].push_back(node(y,z)),g[y].push_back(node(x,z));}\n\tvoid Add(int x,int y,int z) {nx[++cnt]=h[x],to[h[x]=cnt]=y,vl[cnt]=z,nx[++cnt]=h[y],to[h[y]=cnt]=x,vl[cnt]=z;}\n\tvoid Rebuild(int x,int fa) {\n\t\tint las=x;\n\t\tfor(auto y:g[x])if(y.x!=fa&&(Add(las,y.x,y.v),y!=g[x].back()))Add(las,++gs,0),las=gs;\n\t\tfor(auto y:g[x])if(y.x!=fa)Rebuild(y.x,x);\n\t}\n\tvoid Dfs(int x,int fa) {for(int i=h[x]; i; i=nx[i])if(to[i]!=fa)dep[to[i]]=dep[x]+vl[i],Dfs(to[i],x);}\n\tvoid Getsz(int x,int fa) {siz[x]=1;for(int i=h[x],y; i; i=nx[i])if(!vis[i>>1]&&(y=to[i])!=fa)Getsz(y,x),siz[x]+=siz[y];}\n\tvoid Gete(int x,int fa,int Sz) {\n\t\tfor(int i=h[x],y,tmp; i; i=nx[i]) {\n\t\t\tif(vis[i>>1]||(y=to[i])==fa)continue;\n\t\t\tGete(y,x,Sz);if((tmp=max(siz[y],Sz-siz[y]))<mn)mn=tmp,E=i>>1;\n\t\t}\n\t}\n\tint Getg(int x) {return mn=2e9,E=0,Getsz(x,0),Gete(x,0,siz[x]),E;}\n\tvoid Merge(int x,int y,int z) {\n\t\tint i=0,j=0,sx=p[x].size(),sy=p[y].size();\n\t\twhile(i<sx||j<sy)if(j>=sy||(i<sx&&T2::dfn[p[x][i]]<T2::dfn[p[y][j]]))p[z].push_back(p[x][i++]);else p[z].push_back(p[y][j++]);\n\t}\n\tvoid Get(int x,int fa,int opt) {\n\t\tW[x]=dep[x]+dis[x],is[x]=opt;\n\t\tfor(int i=h[x],y; i; i=nx[i]) {if(vis[i>>1]||(y=to[i])==fa)continue;dis[y]=dis[x]+vl[i],Get(y,x,opt);}\n\t}\n\tvoid Divide(int g) {\n\t\tvis[g]=1;int e1,e2,x=to[g<<1],y=to[g<<1|1];\n\t\tif(e1=Getg(x))Divide(e1);if(e2=Getg(y))Divide(e2);\n\t\tGet(x,dis[x]=0,0),dis[y]=vl[g<<1],Get(y,0,1);\n\t\tif(!e1&&!e2) {if(x<=n)p[g].push_back(x);if(y<=n)p[g].push_back(y);sort(p[g].begin(),p[g].end(),cmp);}\n\t\telse {if(p[0].clear(),!e1){if(x<=n)p[0].push_back(x);}else {if(y<=n)p[0].push_back(y);}Merge(e1,e2,g);}T2::Solve(p[g]),vis[g]=0;\n\t}\n}\nint main() {\n\tT1::gs=n=read();\n\tLog[0]=-1;for(int i=1; i<=n; ++i)Log[i]=Log[i>>1]+1,is[i]=-1,T2::f1[i]=T2::f2[i]=-inf;\n\tfor(int i=1,x,y,z; i<n; ++i)x=read(),y=read(),z=read(),T1::Addedge(x,y,z);\n\tfor(int i=1,x,y,z; i<n; ++i)x=read(),y=read(),z=read(),T2::Addedge(x,y,z);\n\tT1::Rebuild(1,0),T1::Dfs(1,0),T2::Dfs(1,0),T2::Pre(),T1::Divide(T1::Getg(1));\n\tfor(int i=1; i<=n; ++i)ans=max(ans,T1::dep[i]-T2::dis[i]);\n\tcout<<ans;\n\treturn 0;\n} \n```",
        "postTime": 1622208721,
        "uid": 112569,
        "name": "Time_tears",
        "ccfLevel": 9,
        "title": "[CTSC2018]\u66b4\u529b\u5199\u6302"
    },
    {
        "content": "\u6487\u4e00\u7bc7 `DSU on tree` + \u52a8\u6001\u70b9\u5206 \u7684\u9898\u89e3\u3002\n\n\u9996\u5148\u5957\u8def\u5730\u628a\u539f\u5f0f\u5316\u6210 $\\frac{1}{2}\\max\\{dis(i,j)+dep(i)+dep(j)-2dep'(lca'(i,j))\\}$ \u3002\n\n\u5728\u7b2c\u4e8c\u68f5\u6811\u4e0a\u679a\u4e3e $p=lca'(i,j)$ \u3002\u6839\u636e `DSU on tree` \u7684\u5957\u8def\uff0c\u6211\u4eec\u8981\u5148\u9012\u5f52\u89e3\u51b3 $p$ \u7684\u6240\u6709\u8f7b\u5b50\u6811\u5185\u90e8\u7684\u7b54\u6848\uff0c\u7136\u540e\u89e3\u51b3\u6389 $p$ \u7684\u91cd\u5b50\u6811\u5e76\u7ee7\u627f\u4fe1\u606f\u3002\n\n\u63a5\u4e0b\u6765\uff0c\u8003\u8651\u679a\u4e3e $p$ \u7684\u8f7b\u5b50\u6811\u5185\u7684\u70b9 $q$ \uff0c\u5e76\u5728\u8ba1\u7b97\u5b8c\u5904\u4e8e $p$ \u7684\u540c\u4e00\u4e2a\u513f\u5b50\u5185\u7684\u70b9\u7684\u7b54\u6848\u4e4b\u540e\uff0c\u5c06\u8fd9\u4e9b\u70b9\u4e0e $p$ \u4e4b\u524d\u7684\u5b50\u6811\u5408\u5e76\u3002\n\n\u6211\u4eec\u73b0\u5728\u5df2\u77e5\u4e86 $dep'(p)$ \u548c $dep(q)$ \uff0c\u56e0\u6b64\u6211\u4eec\u8fd8\u9700\u8981\u5bf9\u4e8e\u6bcf\u4e2a\u91cd\u5b50\u6811\u8282\u70b9 $r$ \uff0c\u7ef4\u62a4 $\\max\\{dis(q,r)+dep(r)\\}$ \u3002\n\n\u8fd9\u76f8\u5f53\u4e8e\uff1a\u5728\u7b2c\u4e00\u68f5\u6811\u4e0a\u6807\u8bb0\u5173\u952e\u70b9\uff08\u5b9e\u9645\u76f8\u5f53\u4e8e\u65b0\u5efa\u4e00\u4e2a\u5173\u952e\u70b9\uff0c\u5e76\u7531\u8fd9\u4e2a\u70b9\u5411 $r$ \u8fde\u63a5\u4e00\u6761\u957f\u5ea6\u4e3a $dep(r)$ \u7684\u8fb9\u3002\u4f46\u662f\u663e\u800c\u6613\u89c1\u7684\u662f\u8fd9\u4e2a\u65b0\u52a0\u7684\u5173\u952e\u70b9\u5e76\u4e0d\u9700\u8981\u663e\u5f0f\u5730\u52a0\u5165\uff0c\u76f4\u63a5\u5728\u70b9 $r$ \u5904\u63d2\u5165\u5373\u53ef\uff09\uff0c\u5e76\u591a\u6b21\u8be2\u95ee\u4e00\u4e2a\u70b9\u5230\u5f53\u524d\u5173\u952e\u70b9\u96c6\u7684\u6700\u5927\u8ddd\u79bb\u3002\n\n\u5bf9\u7b2c\u4e00\u68f5\u6811\u5efa\u7acb\u70b9\u5206\u6811\uff0c\u6bcf\u4e2a\u70b9\u4e0a\u7ef4\u62a4\u4e09\u4e2a\u503c\uff1a\u8fd9\u4e2a\u70b9\u4ee3\u8868\u5206\u6cbb\u8303\u56f4\u4e0b\u7684\u6700\u8fdc\u8ddd\u79bb\u7684\u503c $fir$ \uff1b\u6700\u8fdc\u8ddd\u79bb\u7684\u70b9\u6240\u5c5e\u7684\u5b50\u6811 $frm$ \u548c\u4e0d\u4e0e\u6700\u8fdc\u70b9\u540c\u5c5e\u4e00\u5b50\u6811\u7684\u6b21\u8fdc\u8ddd\u79bb $sec$ \u3002\n\n\u8be2\u95ee\uff0c\u4fee\u6539\u90fd\u53ef\u4ee5\u66b4\u529b\u8df3\u70b9\u5206\u6811\u8fdb\u884c\u4fee\u6539\u3002\n\n\u5751\uff1a\u7531\u4e8e\u8fd9\u6837\u7b97\u7684\u662f\u4e24\u4e24\u4e0d\u540c\u7684\u70b9\u5bf9\u7684\u7b54\u6848\uff0c\u6700\u540e\u8981\u5355\u72ec\u7b97 $i$ \u548c\u5b83\u81ea\u5df1\u7684\u7b54\u6848\u3002\n\n\u590d\u6742\u5ea6\u5206\u6790\uff1a\u6bcf\u4e2a\u70b9\u4f1a\u88ab\u63d2\u5165\u3001\u67e5\u8be2 $O(\\log_2n)$ \u6b21\uff0c\u5355\u6b21\u64cd\u4f5c\u590d\u6742\u5ea6 $O(\\log_2n)$ \u3002\u56e0\u6b64\u603b\u590d\u6742\u5ea6 $O(n\\log_2^2n)$ \u3002\n\n\u5b9e\u9645\u4e0a\u8fd9\u73a9\u610f\u7531\u4e8e\u51fa\u9898\u4eba\u503e\u5411\u4e8e\u5361\u9519\u8bef\u590d\u6742\u5ea6\u7684\u8fb9\u5206\u6cbb\uff0c\u56e0\u6b64\u8dd1\u5f97\u98de\u5feb~~\uff0c\u751a\u81f3\u548c\u67d0\u4e9b\u5355 $\\log$ \u7684\u505a\u6cd5\u6548\u7387\u76f8\u5f53~~\uff08\n\n> \u7406\u8bba\u590d\u6742\u5ea6\u548c\u7a0b\u5e8f\u8fd0\u884c\u6548\u7387\u6ca1\u6709\u4efb\u4f55\u5173\u7cfb\u3002 \u2014\u2014 \u67d0oier\n\nCode: \n\n```cpp\n#include<bits/stdc++.h>\nint n;\ntypedef long long ll;\nconst ll INF=1e18;\nll ans=-INF;\nstruct pii{int t,l;};\nstruct intree\n{\n\tstd::vector<pii>v[377777];\n\tint sz[377777],ds[377777],d[377777],fa[377777][22];\n\tll dep[377777];\n\tvoid dfs(int p=1,int f=0)\n\t{\n\t\tsz[p]=1,d[p]=d[f]+1,fa[p][0]=f;\n\t\tfor(register int i=0;fa[p][i];i++)fa[p][i+1]=fa[fa[p][i]][i];\n\t\tfor(pii t:v[p])if(t.t^f)\n\t\t\tdep[t.t]=dep[p]+t.l,dfs(t.t,p),\n\t\t\tsz[p]+=sz[t.t],sz[ds[p]]<sz[t.t]?ds[p]=t.t:0;\n\t}\n\tint lca(int x,int y)\n\t{\n\t\tif(d[x]<d[y])x^=y^=x^=y;\n\t\tregister int i,ii;\n\t\tfor(ii=d[x]-d[y],i=0;ii;ii>>=1,i++)\n\t\t\tif(ii&1)x=fa[x][i];\n\t\tif(x==y)return x;\n\t\tfor(i=18;~i;i--)\n\t\t\tif(fa[x][i]^fa[y][i])x=fa[x][i],y=fa[y][i];\n\t\treturn fa[x][0];\n\t}\n\tll dis(int x,int y){return dep[x]+dep[y]-2*dep[lca(x,y)];}\n\tvoid rd()\n\t{\n\t\tregister int i;\n\t\tfor(i=1;i<n;i++)\n\t\t{\n\t\t\tint x,y,l;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&l),\n\t\t\tv[x].push_back(pii{y,l}),\n\t\t\tv[y].push_back(pii{x,l});\n\t\t}dfs();\n\t}\n}T1,T2;\ninline void emax(ll&x,ll y){x<y?x=y:0;}\nnamespace tree\n// \u52a8\u6001\u70b9\u5206\u6cbb\u90e8\u5206\n{\n\tint tfa[377777],col[377777],tsz[377777];\n\tvoid dfs(int p,int f=0)\n\t{\n\t\ttsz[p]=1;\n\t\tfor(pii t:T1.v[p])\n\t\t\tif(t.t^f)if(!col[t.t])\n\t\t\t\tdfs(t.t,p),tsz[p]+=tsz[t.t];\n\t}\n\tint getg(int p)\n\t{\n\t\tdfs(p);int GS=tsz[p];\n\t\tfor(;;)\n\t\t{\n\t\t\tfor(pii t:T1.v[p])\n\t\t\t\tif(tsz[t.t]<tsz[p]&&((tsz[t.t]<<1)>=GS)&&!col[t.t])\n\t\t\t\t\t{p=t.t;goto RE;}\n\t\t\treturn p;\n\t\t\tRE:;\n\t\t}\n\t}\n\tint split(int p=1,int d=1)\n\t{\n\t\tp=getg(p),col[p]=d;\n\t\tfor(pii t:T1.v[p])if(!col[t.t])tfa[split(t.t,d+1)]=p;\n\t\treturn p;\n\t}\n\tll le[377777][22];\n\tll dev[377777],fir[377777],sec[377777];\n\tint frm[377777];\n\tstd::vector<int>inserted_list;\n\tvoid ins(int x)\n\t{\n\t\tinserted_list.push_back(x);\n\t\tregister ll Z=dev[x]=T1.dep[x];\n\t\tfor(register int i=1,f=x;;i++)\n\t\t{\n\t\t\tint y=tfa[x];\n\t\t\tif(!y)return;\n\t\t\tll dc=le[f][i]+Z;\n\t\t\tif(dc>fir[y])\n\t\t\t{\n\t\t\t\tif(x!=frm[y])\n\t\t\t\t\tsec[y]=fir[y],fir[y]=dc,frm[y]=x;\n\t\t\t\telse fir[y]=dc;\n\t\t\t}else if(dc>sec[y])if(x!=frm[y])sec[y]=dc;\n\t\t\tx=y;\n\t\t}\n\t}\n\tvoid rem(int x)\n\t{\n\t\tfor(dev[x]=-INF;x;x=tfa[x])fir[x]=sec[x]=-INF,frm[x]=0;\n\t}\n\tvoid clear()\n\t{\n\t\tfor(int t:inserted_list)rem(t);\n\t\tinserted_list.clear();\n\t}\n\tll ask(int x)\n\t{\n\t\tll ret=dev[x];\n\t\tfor(register int i=1,f=x;;i++)\n\t\t{\n\t\t\tint y=tfa[x];\n\t\t\tif(!y)return ret;\n\t\t\temax(ret,dev[y]+le[f][i]);\n\t\t\tif(x!=frm[y])emax(ret,fir[y]+le[f][i]);\n\t\t\telse emax(ret,sec[y]+le[f][i]);\n\t\t\tx=y;\n\t\t}\n\t}\n\tvoid init()\n\t{\n\t\tsplit(1);\n\t\tfor(register int i=1,ii,x;i<=n;i++)\n\t\t{\n\t\t\temax(ans,2*(T1.dep[i]-T2.dep[i])),rem(i);\n\t\t\tfor(x=tfa[i],ii=1;x;x=tfa[x],ii++)\n\t\t\t\tle[i][ii]=T1.dis(i,x);\n\t\t}\n\t}\n}\nstd::vector<int>tmp;\nvoid dsurec(int p,int f)\n{\n\ttmp.push_back(p);\n\tfor(pii t:T2.v[p])if(t.t^f)dsurec(t.t,p);\n}\nvoid dsu(int p=1,int f=0,bool light=1)\n// \u7b97\u6cd5\u6838\u5fc3\uff1alight \u8868\u793a\u8fd9\u4e2a\u70b9\u5230\u7236\u4eb2\u7684\u8fb9\u662f\u5426\u662f\u8f7b\u8fb9\u3002\n// \u5f53 light=1 \u65f6\uff0c\u820d\u5f03 p \u7684\u5b50\u6811\u4fe1\u606f\u3002\u5426\u5219\u4fdd\u7559 p \u7684\u5b50\u6811\u4fe1\u606f\u3002\n{\n\tfor(pii t:T2.v[p])if(t.t^f)if(t.t^T2.ds[p])dsu(t.t,p);\n\tif(T2.ds[p])\n\t{\n\t\tdsu(T2.ds[p],p,0),emax(ans,-T2.dep[p]*2+T1.dep[p]+tree::ask(p)),tree::ins(p);\n\t\tfor(pii t:T2.v[p])if(t.t^f)if(t.t^T2.ds[p])\n\t\t{\n\t\t\ttmp.clear(),dsurec(t.t,p);\n\t\t\tfor(int x:tmp)emax(ans,-T2.dep[p]*2+T1.dep[x]+tree::ask(x));\n\t\t\tfor(int x:tmp)tree::ins(x);\n\t\t}\n\t}else if(!light)tree::ins(p);\n\tif(light)tree::clear();\n}\nint main()\n{scanf(\"%d\",&n),T1.rd(),T2.rd(),tree::init(),dsu(),printf(\"%lld\\n\",ans>>1);}\n```\n\n",
        "postTime": 1616490573,
        "uid": 85053,
        "name": "namespace_std",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4565 \u3010[CTSC2018]\u66b4\u529b\u5199\u6302\u3011"
    },
    {
        "content": "### P4565\u3010CTSC 2018\u3011\u66b4\u529b\u5199\u6302\n\n#### \u9898\u610f\n\n\u7ed9\u5b9a\u4e24\u68f5\u6811\uff0c\u6c42\n$$\n\\max_{u, v} d_1(u) + d_1(v) - (d_1(\\text{lca}_1(u, v)), d_2(\\text{lca}(u, v)))\n$$\n$d$ \u8868\u793a\u6839 $1$ \u5230\u5f53\u524d\u70b9\u7684\u8def\u5f84\uff0c\u8fb9\u6743\u53ef\u4ee5\u4e3a\u8d1f\u3002\n\n$n \\le 366666, |w|\\le 2017011328$\u3002\n\n#### 3 log \u505a\u6cd5\n\n\u597d\u50cf\u6bd4\u9898\u89e3\u533a\u53e6\u5916\u4e00\u7bc7 3 log \u8981\u597d\u5199\u4e00\u70b9\uff1f\n\n\u5728\u7b2c\u4e00\u68f5\u6811\u4e0a\u9762\u8fdb\u884c dsu on tree\uff0c\u7edf\u8ba1\u7b2c\u4e00\u4e2a\u6811\u4e0a $\\text{lca}$ \u4e3a $x$ \u7684\u7b54\u6848\uff0c\u679a\u4e3e\u8f7b\u5b50\u6811\u5185\u7684\u4e00\u4e2a\u70b9 $u$\uff0c\u4e0a\u9762\u7684\u5f0f\u5b50\u5c31\u53ea\u6709 $d_1(v) - d_2(\\text{lca}_2(u, v))$ \u672a\u77e5\uff0c\u5e76\u4e14\u8fd9\u53ea\u548c\u7b2c\u4e8c\u68f5\u6811\u6709\u5173\u3002\n\n\u8003\u8651\u7b2c\u4e8c\u68f5\u6811\u4e0a $\\text{lca}$ \u4e00\u5b9a\u662f $1\\to u$ \u7684\u4e00\u6761\u94fe\u4e0a\uff0c\u4e8e\u662f\u679a\u4e3e\u7684\u65f6\u5019\u53ef\u4ee5\u8003\u8651\u6811\u5256\u4f18\u5316\u3002\n\n![1.png](https://s2.loli.net/2023/04/21/BkFqZAc3Hntb6pR.png)\n\n\u8003\u8651\u5f53\u524d\u8fd9\u6761\u91cd\u94fe\uff1a\n\n1. $u$ \u5b50\u6811\u5185\u53ea\u9700\u8981\u627e\u5230 $d_1(v)$ \u7684\u6700\u5927\u503c\uff1b\n2. \u5bf9\u4e8e $u$ \u4e0a\u65b9\u7684\u8fd9\u6761\u6a59\u8272\u94fe\uff0c$v$ \u7684\u8d21\u732e\u4e3a $d_1(v)$ \u51cf\u53bb $v$ \u8df3\u4e0a\u8fd9\u6761\u91cd\u94fe\u7684\u70b9\u7684 $d_2$\uff0c\u8fd9\u91cc $v$ \u4e0d\u5728\u91cd\u94fe\u4e0a\u4e5f\u4e0d\u5728 $u$ \u5b50\u6811\u4e2d\uff1b\n3. \u5bf9\u4e8e $u$ \u4e0a\u65b9\u8fd9\u6761\u6a59\u8272\u94fe\u4e0a\u9762\u7684\u70b9\uff0c\u8d21\u732e\u4e3a $d_1(v) - d_2(v)$\uff0c\u8fd9\u4e00\u7c7b\u53ef\u4ee5\u5f52\u5230\u7b2c $2$ \u7c7b\u4e0a\u9762\u3002\n\n\u8003\u8651\u4e0a\u9762\u7684\u91cd\u94fe\uff1a\n\n1. $\\text{fa}(\\text{top}(u))$ \u7684\u5b50\u6811\u5185\u9664\u5f00 $\\text{top}(u)$ \u8fd9\u68f5\u5b50\u6811\u70b9\u53ea\u9700\u8981\u627e\u5230 $d_1(v)$ \u7684\u6700\u5927\u503c\u3002\n2. \u8fd9\u6761\u94fe\u4e0a\u7684\u5176\u4ed6\u70b9\u7edf\u8ba1\u6765\u81ea\u4ed6\u7684\u8f7b\u513f\u5b50\u548c\u4ed6\u672c\u8eab\u7684\u8d21\u732e\u3002\n\n\u8bb0\u5f55 $u$ \u5f00\u59cb\u8df3\u91cd\u94fe\u904d\u5386\u5230\u7684\u6240\u6709\u70b9\u4e3a\u5173\u952e\u70b9\uff0c\u4e0a\u9762\u7684\u4e24\u4e2a\u8ba8\u8bba\u4e5f\u53ef\u4ee5\u5408\u5e76\uff1a\n\n1. \u5173\u952e\u70b9\u5904\u8be2\u95ee\u5b50\u6811\u4fe1\u606f\uff0c\u53ea\u9700\u8981\u7ef4\u62a4 $d_1(v)$ \u7684\u6700\u5927\u503c\uff0c\u8003\u8651\u5168\u5c40\u5f00\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0cdfs \u5e8f\u8f6c\u6210\u5e8f\u5217\uff08\u4e3a\u4e86\u51cf\u5c0f\u5e38\u6570\u91c7\u7528 zkw \u7ebf\u6bb5\u6811\uff09\u3002\n2. \u5bf9\u4e8e $u$ \u4e0a\u65b9\u6240\u6709\u975e\u5173\u952e\u70b9\uff0c\u53ea\u9700\u8981\u7ef4\u62a4\u6240\u6709\u8f7b\u513f\u5b50\u5b50\u6811\u91cc $v$ \u7684 $d_1(v)$ \u51cf\u53bb\u5f53\u524d\u70b9\u7684 $d_2$ \u503c\uff0c\u6bcf\u6b21\u65b0\u52a0\u70b9 $v$ \u65f6\u66b4\u529b\u8df3\u94fe\u53ef\u4ee5\u7ef4\u62a4\u8fd9\u4e2a\u4fe1\u606f\uff0c\u6ce8\u610f\u5230\u67e5\u8be2\u4e00\u5b9a\u662f\u4e00\u6761\u91cd\u94fe\u4ece $\\text{top}$ \u5f00\u59cb\u7684\u524d\u7f00\uff0c\u8003\u8651\u6bcf\u4e00\u4e2a\u91cd\u94fe\u5f00\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\uff0c\u5728\u8df3 $u$ \u7684\u65f6\u5019\u5bf9\u6bcf\u6761\u94fe\u8fdb\u884c\u67e5\u8be2\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^3n)$\uff0c\u5e38\u6570\u5f88\u5c0f\uff0c\u751a\u81f3\u6bd4\u5176\u4ed6\u505a\u6cd5\u8fd8\u5feb\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define rep(i, alpha, iee) for(auto gs##i = (iee), i = (alpha); i <= gs##i; ++i)\n#define per(i, alpha, iee) for(auto gs##i = (iee), i = (alpha); i >= gs##i; --i)\n#define let const auto\n#define debug(...) fprintf(stderr, __VA_ARGS__)\nusing i64 = long long;\nconstexpr int maxn = 366666 + 5;\nconstexpr i64 inf = 1e18;\n\nstruct Graph{\n    int tot, head[maxn];\n    struct Edge{\n        int nxt, v, w;\n    } e[maxn << 1];\n    void add(int u, int v, int w){\n        e[++tot] = {head[u], v, w};\n        head[u] = tot;\n    }\n} G1, G2;\n\ni64 d1[maxn];\nint js, ss[maxn], so[maxn], di[maxn], rev[maxn];\nvoid dfs0(int u, int fa){\n    ss[u] = 1;\n    di[u] = ++js, rev[js] = u;\n    for(int i = G1.head[u]; i; i = G1.e[i].nxt){\n        int v = G1.e[i].v, w = G1.e[i].w;\n        if(v == fa) continue;\n        d1[v] = d1[u] + w;\n        dfs0(v, u);\n        ss[u] += ss[v];\n        if(ss[v] > ss[so[u]]) so[u] = v;\n    }\n}\n\ni64 d2[maxn];\nint ti, dfn[maxn], siz[maxn], son[maxn], cnt[maxn], dep[maxn], pa[maxn], top[maxn];\nvoid dfs1(int u, int fa){\n    siz[u] = 1, pa[u] = fa, dep[u] = dep[fa] + 1;\n    for(int i = G2.head[u]; i; i = G2.e[i].nxt){\n        int v = G2.e[i].v, w = G2.e[i].w;\n        if(v == fa) continue;\n        d2[v] = d2[u] + w;\n        dfs1(v, u);\n        siz[u] += siz[v];\n        if(siz[v] > siz[son[u]]) son[u] = v;\n    }\n}\nvoid dfs2(int u, int x){\n    cnt[x]++, top[u] = x, dfn[u] = ++ti;\n    if(son[u]) dfs2(son[u], x);\n    for(int i = G2.head[u]; i; i = G2.e[i].nxt){\n        int v = G2.e[i].v;\n        if(!top[v]) dfs2(v, v);\n    }\n}\n\nnamespace SGT{\n    int N;\n    i64 t[maxn << 2];\n    void init(int n){\n        N = 1 << int(std::__lg(n + 1)) + 1;\n        rep(i, 0, n + 1) t[i + N] = -inf;\n        per(i, N - 1, 1) t[i] = std::max(t[i << 1], t[i << 1 | 1]);\n    }\n    void mdf(int x, i64 v){\n        t[x + N] = v;\n        for(int i = (x + N) >> 1; i; i >>= 1){\n            t[i] = std::max(t[i << 1], t[i << 1 | 1]);\n        }\n    }\n    i64 qry(int l, int r){\n        i64 res = -inf;\n        for(l += N - 1, r += N + 1; l ^ r ^ 1; l >>= 1, r >>= 1){\n            if(~l & 1) res = std::max(res, t[l ^ 1]);\n            if(r & 1) res = std::max(res, t[r ^ 1]);\n        }\n        return res;\n    }\n}\n\nstruct BIT{\n    int n;\n    i64 *c;\n    void init(int n){\n        this->n = n;\n        c = new i64[n + 1];\n        std::fill(c + 1, c + n + 1, -inf);\n    }\n    void clr(int x){\n        for(; x <= n; x += x & -x) c[x] = -inf;\n    }\n    void mdf(int x, i64 v){\n        for(; x <= n; x += x & -x) c[x] = std::max(c[x], v);\n    }\n    i64 qry(int x){\n        i64 res = -inf;\n        for(; x; x -= x & -x) res = std::max(res, c[x]);\n        return res;\n    }\n} B[maxn];\n\nint n;\ni64 ans = -inf;\n\nvoid solve(int u, int x){\n    i64 res = -inf;\n    int v = u, ban = 0;\n    while(v){\n        let tt = top[v];\n        if(!ban){\n            res = std::max(res, SGT::qry(dfn[v], dfn[v] + siz[v] - 1) - d2[v]);\n        }\n        else{\n            res = std::max(res, SGT::qry(dfn[v], dfn[ban] - 1) - d2[v]);\n            if(dfn[ban] + siz[ban] <= dfn[v] + siz[v] - 1){\n                res = std::max(res, SGT::qry(dfn[ban] + siz[ban], dfn[v] + siz[v] - 1) - d2[v]);\n            }\n        }\n        if(dfn[tt] != dfn[v]){\n            res = std::max(res, B[tt].qry(dfn[v] - dfn[tt]));\n        }\n        ban = tt, v = pa[tt];\n    }\n    if(res != -inf){\n        ans = std::max(ans, res + d1[u] - d1[x]);\n    }\n}\nvoid add(int u){\n    SGT::mdf(dfn[u], d1[u]);\n    int v = u;\n    while(v){\n        let tt = top[v];\n        B[tt].mdf(dep[v] - dep[tt] + 1, d1[u] - d2[v]);\n        v = pa[top[v]];\n    }\n}\nvoid del(int u){\n    SGT::mdf(dfn[u], -inf);\n    while(u){\n        let tt = top[u];\n        B[tt].clr(dep[u] - dep[tt] + 1);\n        u = pa[top[u]];\n    }\n}\nvoid dsu(int u, int fa, int kp){\n    for(int i = G1.head[u]; i; i = G1.e[i].nxt){\n        int v = G1.e[i].v;\n        if(v == fa || v == so[u]) continue;\n        dsu(v, u, 0);\n    }\n    if(so[u]) dsu(so[u], u, 1);\n    add(u), solve(u, u);\n    for(int i = G1.head[u]; i; i = G1.e[i].nxt){\n        int v = G1.e[i].v;\n        if(v == fa || v == so[u]) continue;\n        for(int j = di[v]; j < di[v] + ss[v]; ++j){\n            int cur = rev[j];\n            solve(cur, u);\n        }\n        for(int j = di[v]; j < di[v] + ss[v]; ++j){\n            int cur = rev[j];\n            add(cur);\n        }\n    }\n    if(!kp){\n        for(int i = di[u]; i < di[u] + ss[u]; ++i){\n            int v = rev[i];\n            del(v);\n        }\n    }\n}\n\nint main(){\n    scanf(\"%d\", &n);\n    rep(i, 1, n - 1){\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        G1.add(u, v, w);\n        G1.add(v, u, w);\n    }\n    rep(i, 1, n - 1){\n        int u, v, w;\n        scanf(\"%d%d%d\", &u, &v, &w);\n        G2.add(u, v, w);\n        G2.add(v, u, w);\n    }\n    dfs0(1, 0);\n    dfs1(1, 0);\n    dfs2(1, 1);\n    rep(i, 1, n) if(top[i] == i) B[i].init(cnt[i]);\n    SGT::init(n);\n    dsu(1, 0, 0);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```",
        "postTime": 1682068198,
        "uid": 86576,
        "name": "zlxFTH",
        "ccfLevel": 7,
        "title": "\u300a\u66b4\u529b\u5199\u6302\u300b\u66f4\u597d\u5199\u7684 3 log\uff1f"
    }
]