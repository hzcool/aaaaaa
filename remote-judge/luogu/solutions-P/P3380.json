[
    {
        "content": "\u8fd9\u9053\u9898\u6700\u7ecf\u5178\u7684\u505a\u6cd5\u4fbf\u662f\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u3002\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u7528\u4e00\u9897\u7ebf\u6bb5\u6811\u7ba1\u7406\u4e0b\u6807\u533a\u95f4 $[L,R]$ \uff0c\u7136\u540e\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u90fd\u662f\u4e00\u9897\u5e73\u8861\u6811\uff0c\u5e73\u8861\u6811\u4e2d\u5b58\u50a8\u4e86\u6240\u6709\u4e0b\u6807\u5728 $[L,R]$ \u4e4b\u95f4\u7684\u6240\u6709\u6570\u7684\u4fe1\u606f\u3002\u8fd9\u6837\u7684\u8bdd\uff0c\u6240\u6709\u533a\u95f4\u90fd\u53ef\u4ee5\u88ab\u5206\u4e3a $O(\\log N)$ \u4e2a\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\uff0c\u533a\u95f4\u95ee\u9898\u4fbf\u8f6c\u5316\u4e3a\u4e86\u51e0\u4e2a\u5e73\u8861\u6811\u4e0a\u7684\u95ee\u9898\u3002\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u5982\u4f55\u5177\u4f53\u5b9e\u73b0\u5404\u4e2a\u64cd\u4f5c\uff1a\n\n1\u3001\u67e5\u8be2\u533a\u95f4\u5185\u4e00\u4e2a\u6570\u7684\u6392\u540d\uff1a\u5728\u7ebf\u6bb5\u6811\u4e0a\u627e\u5230\u533a\u95f4\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u7136\u540e\u6bcf\u4e2a\u8282\u70b9\u7684\u5e73\u8861\u6811\u5185\u67e5\u8be2\u5bf9\u5e94\u6570\u7684\u6392\u540d\u5e76\u6c42\u548c\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $O(\\log^2N)$\n\n2\u3001\u67e5\u8be2\u533a\u95f4\u5185\u6392\u540d\u4e3ak\u7684\u6570\u662f\u51e0\uff1a\u7531\u4e8e\u8fd9\u9879\u64cd\u4f5c\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e0d\u53ef\u52a0\u3002\u6240\u4ee5\u6211\u4eec\u8003\u8651\u8f6c\u6362\u4e3a\u5224\u5b9a\u4e00\u4e2a\u6570\u662f\u4e0d\u662f\u533a\u95f4\u5185\u6392\u540d\u4e3ak\u7684\u3002\u8fd9\u4e2a\u53ef\u4ee5\u5728 $O(\\log^2N)$ \u7684\u65f6\u95f4\u5185\u901a\u8fc7\u64cd\u4f5c1\u5b8c\u6210\u3002\u90a3\u4e48\u6211\u4eec\u8003\u8651\u4e8c\u5206\u7b54\u6848\uff0c\u5c31\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $O(\\log^3N)$\n\n3\u3001\u5355\u70b9\u4fee\u6539\uff1a\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u627e\u5230\u6240\u6709\u8986\u76d6\u8fd9\u4e2a\u70b9\u7684\u533a\u95f4\uff0c\u7136\u540e\u5728\u6240\u6709\u533a\u95f4\u5bf9\u5e94\u7684\u5e73\u8861\u6811\u4e2d\u5220\u9664\u539f\u6570\uff0c\u52a0\u5165\u65b0\u6570\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $O(\\log^2N)$\n\n4\uff0c5\u3001 \u67e5\u8be2\u533a\u95f4\u5185\u4e00\u4e2a\u6570\u524d\u9a71\u3001\u540e\u7ee7\uff1a\u8fd9\u662f\u5e73\u8861\u6811\u4e0a\u7684\u7ecf\u5178\u95ee\u9898\u3002\u6211\u4eec\u53ea\u9700\u8981\u5bf9\u4e8e\u6240\u6709\u533a\u95f4\u5206\u522b\u67e5\u8be2\uff0c\u7136\u540e\u7b54\u6848\u76f8\u5e94\u7684\u53d6 $\\max \\min$ \u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $O(\\log^2N)$\n\n\u5f53\u7136\uff0c\u7531\u4e8e\u5e8f\u5217\u4e2d\u7684\u4e00\u4e2a\u6570\u6700\u591a\u88ab\u63d2\u5165 $O(\\log N)$ \u4e2a\u5e73\u8861\u6811\u5185\uff0c\u8003\u8651\u5230\u6bcf\u6b21\u4fee\u6539\u64cd\u4f5c\u6700\u591a\u589e\u52a0\u5e76\u5220\u9664\u4e00\u4e2a\u8282\u70b9\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a $O(N\\log N)$ \u3002\u7ecf\u8fc7\u6211\u4eec\u7684\u5206\u6790\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(N\\log^3N)$\u3002\u5f53\u7136\u8fd9\u662f\u4e00\u4e2a\u8f83\u677e\u7684\u4e0a\u754c\u3002\n\n\u5bf9\u4e8e\u5b9e\u73b0\u6765\u8bf4\uff0c\u6211\u4f7f\u7528\u4e86 Treap \u4f5c\u4e3a\u5e73\u8861\u6811\uff0c\u4e3b\u8981\u539f\u56e0\u662f\u56e0\u4e3a\u597d\u5199\u800c\u4e14\u5e38\u6570\u8f83\u5c0f\u3002\uff08\u6211\u8fd9\u4efd\u4ee3\u7801\u4e0d\u5f00O2\u7adf\u7136\u4e5f\u80fd\u8fc7\uff09\u800c\u4e14\u8981\u6ce8\u610f\u64cd\u4f5c1\u4e0e\u64cd\u4f5c2\u7684\u4e00\u4e9b\u8fb9\u754c\u95ee\u9898\u3002\n\n\u4ee3\u7801\u5199\u7684\u5f88\u4e11\u3002\u3002\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <cstring>\n#include <cstdlib>\n#include <complex>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n\nconst int MAXN = 1e5 + 100;\nint n, m;\nint a[MAXN];\n\nnamespace Treap\n{\n\tstruct balanced\n\t{\n\t\tint w;\n\t\tint sz;\n\t\tint num;\n\t\tint fix;\n\t\tint ch[2];\n\t};\n\tint tot;\n\tbalanced tree[MAXN * 20];\n\tint newnode(int w)\n\t{\n\t\t++tot;\n\t\ttree[tot].w = w;\n\t\ttree[tot].fix = rand();\n\t\ttree[tot].num = 1;\n\t\ttree[tot].ch[0] = tree[tot].ch[1] = 0;\n\t\ttree[tot].sz = 1;\n\t\treturn tot;\n\t}\n\tvoid pushup(int p)\n\t{\n\t\ttree[p].sz = tree[tree[p].ch[0]].sz + tree[tree[p].ch[1]].sz + tree[p].num;\n\t}\n\tvoid rotate(int &p, int d)\n\t{\n\t\tint y = tree[p].ch[d];\n\t\ttree[p].ch[d] = tree[y].ch[d ^ 1];\n\t\ttree[y].ch[d ^ 1] = p;\n\t\tpushup(p);\n\t\tpushup(y);\n\t\tp = y;\n\t}\n\tvoid insert(int &p, int w)\n\t{\n\t\tif (!p)\n\t\t\tp = newnode(w);\n\t\telse if (tree[p].w == w)\n\t\t\t++tree[p].num;\n\t\telse \n\t\t{\n\t\t\tif (tree[p].w > w)\n\t\t\t{\n\t\t\t\tinsert(tree[p].ch[0], w);\n\t\t\t\tif (tree[tree[p].ch[0]].fix > tree[p].fix)\n\t\t\t\t\trotate(p, 0);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tinsert(tree[p].ch[1], w);\n\t\t\t\tif (tree[tree[p].ch[1]].fix > tree[p].fix)\n\t\t\t\t\trotate(p, 1);\n\t\t\t}\n\t\t}\n\t\tpushup(p);\n\t}\n\tvoid remove(int &p, int w)\n\t{\n\t\tif (tree[p].w > w)\n\t\t\tremove(tree[p].ch[0], w);\n\t\telse if (tree[p].w < w)\n\t\t\tremove(tree[p].ch[1], w);\n\t\telse\n\t\t{\n\t\t\tif (tree[p].num > 1)\n\t\t\t\t--tree[p].num;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!tree[p].ch[0] && !tree[p].ch[1])\n\t\t\t\t\tp = 0;\n\t\t\t\telse if (!tree[p].ch[0])\n\t\t\t\t{\n\t\t\t\t\trotate(p, 1);\n\t\t\t\t\tremove(tree[p].ch[0], w);\n\t\t\t\t}\n\t\t\t\telse if (!tree[p].ch[1])\n\t\t\t\t{\n\t\t\t\t\trotate(p, 0);\n\t\t\t\t\tremove(tree[p].ch[1], w);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (tree[tree[p].ch[0]].fix > tree[tree[p].ch[1]].fix)\n\t\t\t\t\t{\n\t\t\t\t\t\trotate(p, 0);\n\t\t\t\t\t\tremove(tree[p].ch[1], w);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trotate(p, 1);\n\t\t\t\t\t\tremove(tree[p].ch[0], w);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p)\n\t\t\tpushup(p);\n\t}\n\tint queryrank(int p, int k) // return the highest rank of value 'k'\n\t{\n\t\tif (!p)\n\t\t\treturn 0;\n\t\tif (tree[p].w > k)\n\t\t\treturn queryrank(tree[p].ch[0], k);\n\t\telse if (tree[p].w == k)\n\t\t\treturn tree[tree[p].ch[0]].sz;\n\t\telse\n\t\t\treturn tree[tree[p].ch[0]].sz + tree[p].num + queryrank(tree[p].ch[1], k);\n\t}\n\tint querynum(int p, int k) // return the value of kth rank node\n\t{\n\t\tif (tree[tree[p].ch[0]].sz + 1 == k)\n\t\t\treturn tree[p].w;\n\t\telse if (tree[tree[p].ch[0]].sz + 1 < k)\n\t\t\treturn querynum(tree[p].ch[1], k - 1 - tree[tree[p].ch[0]].sz);\n\t\telse\t\n\t\t\treturn querynum(tree[p].ch[0], k);\n\t}\n\tint querypre(int p, int k) // return the prefix of value k\n\t{\n\t\tif (!p) \n\t\t\treturn -2147483647;\n\t\tif (tree[p].w >= k)\n\t\t\treturn querypre(tree[p].ch[0], k);\n\t\telse\n\t\t\treturn max(tree[p].w, querypre(tree[p].ch[1], k));\n\t}\n\tint querysuf(int p, int k) // return the suffix of value k\n\t{\n\t\tif (!p)\n\t\t\treturn 2147483647;\n\t\tif (tree[p].w <= k)\n\t\t\treturn querysuf(tree[p].ch[1], k);\n\t\telse\n\t\t\treturn min(tree[p].w, querysuf(tree[p].ch[0], k));\n\t}\n\tvoid listall(int p)\n\t{\n\t\tif (tree[p].ch[0])\n\t\t\tlistall(tree[p].ch[0]);\n\t\tcerr << tree[p].w << \",sz=\" << tree[p].num << \"   \";\n\t\tif (tree[p].ch[1])\n\t\t\tlistall(tree[p].ch[1]);\n\t}\n}\nusing Treap::listall;\n\nnamespace SEG\n{\n\tstruct segment\n\t{\n\t\tint l;\n\t\tint r;\n\t\tint root;\n\t};\n\tsegment tree[MAXN * 8];\n\tvoid build(int p, int l, int r)\n\t{\n\t\ttree[p].l = l;\n\t\ttree[p].r = r;\n\t\tfor (int i = l; i < r + 1; ++i)\n\t\t\tTreap::insert(tree[p].root, a[i]);\n\t\tif (l != r)\n\t\t{\n\t\t\tint mid = (l + r) / 2;\n\t\t\tbuild(p * 2, l, mid);\n\t\t\tbuild(p * 2 + 1, mid + 1, r);\n\t\t}\n\t}\n\tvoid modify(int p, int x, int y)\n\t{\n\t\tTreap::remove(tree[p].root, a[x]);\n\t\tTreap::insert(tree[p].root, y);\n\t\tif (tree[p].l == tree[p].r)\n\t\t\treturn;\n\t\tint mid = (tree[p].l + tree[p].r) / 2;\n\t\tif (x > mid)\n\t\t\tmodify(p * 2 + 1, x, y);\n\t\telse\n\t\t\tmodify(p * 2, x, y);\n\t}\n\tint queryrank(int p, int l, int r, int k) // query the highest rank of value 'k'\n\t{\n\t\tif (tree[p].l > r || tree[p].r < l)\n\t\t\treturn 0;\n\t\tif (tree[p].l >= l && tree[p].r <= r)\n\t\t\treturn Treap::queryrank(tree[p].root, k);\n\t\telse\n\t\t\treturn queryrank(p * 2, l, r, k) + queryrank(p * 2 + 1, l, r, k);\n\t}\n\tint querynum(int u, int v, int k) // query the value of kth num\n\t{\n\t\tint l = 0, r = 1e8;\n\t\twhile (l < r)\n\t\t{\n\t\t\tint mid = (l + r + 1) / 2;\n\t\t\tif (queryrank(1, u, v, mid) < k)\n\t\t\t\tl = mid;\n\t\t\telse\n\t\t\t\tr = mid - 1;\n\t\t}\n\t\treturn r;\n\t}\n\tint querypre(int p, int l, int r, int k)\n\t{\n\t\tif (tree[p].l > r || tree[p].r < l)\n\t\t\treturn -2147483647;\n\t\tif (tree[p].l >= l && tree[p].r <= r)\n\t\t\treturn Treap::querypre(tree[p].root, k);\n\t\telse\n\t\t\treturn max(querypre(p * 2, l, r, k), querypre(p * 2 + 1, l, r, k));\n\t}\n\tint querysuf(int p, int l, int r, int k)\n\t{\n\t\tif (tree[p].l > r || tree[p].r < l)\n\t\t\treturn 2147483647;\n\t\tif (tree[p].l >= l && tree[p].r <= r)\n\t\t\treturn Treap::querysuf(tree[p].root, k);\n\t\telse\n\t\t\treturn min(querysuf(p * 2, l, r, k), querysuf(p * 2 + 1, l, r, k));\n\t}\n}\n\nint read()\n{\n\tchar ch = getchar();\n\tint x = 0, flag = 1;\n\twhile (ch != '-' && (ch < '0' || ch > '9'))\n\t\tch = getchar();\n\tif (ch == '-')\n\t{\n\t\tch = getchar();\n\t\tflag = -1;\n\t}\n\twhile (ch >= '0' && ch <= '9')\n\t{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\treturn x * flag;\n}\n\nint main()\n{\n\tn = read();\n\tm = read();\n\tfor (int i = 1; i < n + 1; ++i)\n\t\ta[i] = read();\n\tSEG::build(1, 1, n);\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\tint opt = read();\n\t\tif (opt == 3)\n\t\t{\n\t\t\tint x = read(), y = read();\n\t\t\tSEG::modify(1, x, y);\n\t\t\ta[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l = read(), r = read(), k = read();\n\t\t\tif (opt == 1)\n\t\t\t\tprintf(\"%d\\n\", SEG::queryrank(1, l, r, k) + 1);\n\t\t\telse if (opt == 2)\n\t\t\t\tprintf(\"%d\\n\", SEG::querynum(l, r, k));\n\t\t\telse if (opt == 4)\n\t\t\t\tprintf(\"%d\\n\", SEG::querypre(1, l, r, k));\n\t\t\telse\n\t\t\t\tprintf(\"%d\\n\", SEG::querysuf(1, l, r, k));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\t",
        "postTime": 1522934577,
        "uid": 25739,
        "name": "scallop",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u4f69\u670d\u5206\u5757\u5927\u4f6c\uff0corzorzorz\n\n\n\u9a97\u53d6\u70b9\u51fb\u91cf\uff1ahttp://www.cnblogs.com/xzz_233/p/bzoj3196.html\n\n\n\u7136\u540e\u6211\u5b9e\u5728\u662f\u4e0d\u60f3\u518d\u6253\u4e00\u904d\u6811\u72b6\u6570\u7ec4\u5957\u66ff\u7f6a\u7f8a\u6811\u4e86\u3002\u3002\u3002\n\n\n\u7136\u540e\u5728\u666e\u901a\u5e73\u8861\u6811\u778e\u901b\u7684\u65f6\u5019\u627e\u5230\u4e86\u4ee5\u524d\u770b\u8fc7vector\u9898\u89e3\n\n\n\u4e8e\u662f\u6211\u60f3\uff1a\u4e3a\u5565\u4e0d\u628a\u5e73\u8861\u6811\u6362\u6210vector\u5462\uff1f\uff1f\uff1f\n\n\n\u7136\u540e\u6211\u53c8\u53bb\u5b66\u4e86\u4e00\u4e0bZKW\u7ebf\u6bb5\u6811\n\n\n\u5c31\u7528**ZKW\u7ebf\u6bb5\u6811\u5957vector**\u6c34\u8fc7\u5566\uff01\uff01\uff01\n\n\n\u6bcf\u4e2aZKW\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u4fdd\u5b58\u4e00\u4e2avector\n\n\n\u64cd\u4f5c1\u5728\u5206\u51fa\u7684vector\u4e0a\u67e5\u8be2\u6bd4\u5b83\u5c0f\u7684\u6570\u6709\u591a\u5c11\u4e2a\u7136\u540e\u76f8\u52a0\u518d\u52a01\n\n\n\u64cd\u4f5c2\u4e8c\u5206\u518d\u4e0a\u64cd\u4f5c1\n\n\n\u64cd\u4f5c3\u4fee\u6539\u9700\u8981\u4fee\u6539\u7684\u8282\u70b9\u7684vector\n\n\n\u64cd\u4f5c4\u5728\u5206\u51favector\u4e0a\u67e5\u8be2\u524d\u9a71\u53d6\u6700\u5927\n\n\n\u64cd\u4f5c5\u4e0e\u64cd\u4f5c4\u540c\u7406\n\n\nluogu\u4e3b\u7ad95772ms\u4e0a\u5361\u8fc7\uff0c\u5f00O2\u7684\u8bdd2296ms\uff0cbzoj\u4e0a8196ms\uff0cCOGS\u4e0a\u76f4\u63a5\u8fc7\n\n\n```cpp\n// It is made by XZZ\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define il inline\n#define rg register\n#define vd void\n#define sta static\nusing std::vector;\ntypedef long long ll;\nil int gi(){\n    rg int x=0,f=1;rg char ch=getchar();\n    while(ch<'0'||ch>'9')f=ch=='-'?-1:f,ch=getchar();\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*f;\n}\nconst int maxn=50001;\nint lb[maxn],W[maxn],n,N=65536,m;\ntypedef const int& fast;\nvector<int>d[65537<<1];\nvector<int>::iterator it;\nil vd Insert(fast x,fast y){d[x].insert(upper_bound(d[x].begin(),d[x].end(),y),y);}\nil vd Erase(fast x,fast y){d[x].erase(lower_bound(d[x].begin(),d[x].end(),y));}\nil int Rank(fast x,fast y){return lower_bound(d[x].begin(),d[x].end(),y)-d[x].begin();}\nil int Kth(fast x,fast y){return d[x][y-1];}\nil int Prev(fast x,fast y){\n    it=lower_bound(d[x].begin(),d[x].end(),y);\n    if(it==d[x].begin())return -2147483647;\n    return *--it;\n}\nil int Next(fast x,fast y){\n    it=upper_bound(d[x].begin(),d[x].end(),y);\n    if(it==d[x].end())return 2147483647;\n    return *it;\n}\nil vd UPD1(rg int x,fast y){for(x+=N;x;x>>=1)Insert(x,y);}\nil vd UPD2(rg int x,fast y){for(x+=N;x;x>>=1)Erase(x,y);}\nil int max(fast a,fast b){return a>b?a:b;}\nil int min(fast a,fast b){return a<b?a:b;}\nil int RNK(rg int l,rg int r,fast k){\n    sta int ret;ret=1;\n    for(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1)ret+=Rank(l^1,k);\n        if(r&1)ret+=Rank(r^1,k);\n    }return ret;\n}\nil int PRE(rg int l,rg int r,fast k){\n    sta int ret;ret=-2147483647;\n    for(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1)ret=max(ret,Prev(l^1,k));\n        if(r&1)ret=max(ret,Prev(r^1,k));\n    }return ret;\n}\nil int NXT(rg int l,rg int r,fast k){\n    sta int ret;ret=2147483647;\n    for(l+=N-1,r+=N+1;l^r^1;l>>=1,r>>=1){\n        if(~l&1)ret=min(ret,Next(l^1,k));\n        if(r&1)ret=min(ret,Next(r^1,k));\n    }return ret;\n}\nint main(){\n    n=gi(),m=gi();\n    for(N=1;N<n;N<<=1)\n    for(rg int i=1;i<=n;++i)lb[i]=i&-i;\n    for(rg int i=1;i<=n;++i){\n        W[i]=gi();\n        UPD1(i,W[i]);\n    }\n    int opt,l,r,k;\n    while(m--){\n        opt=gi();\n        if(opt==3)l=gi(),k=gi();\n        else l=gi(),r=gi(),k=gi();\n        if(opt==1)printf(\"%d\\n\",RNK(l,r,k));\n        else if(opt==2){\n            sta int ll,rr,mid;\n            ll=0,rr=100000000;\n            while(ll<rr){\n                mid=((ll+rr)>>1)+1;\n                if(RNK(l,r,mid)>k)rr=mid-1;\n                else ll=mid;\n            }printf(\"%d\\n\",ll);\n        }else if(opt==3)UPD2(l,W[l]),UPD1(l,W[l]=k);\n        else if(opt==4)printf(\"%d\\n\",PRE(l,r,k));\n        else if(opt==5)printf(\"%d\\n\",NXT(l,r,k));\n        else while(1);\n    }\n    return 0;\n}\n```",
        "postTime": 1515198104,
        "uid": 23118,
        "name": "\u03bb\u1d09\u028d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011 ZKW\u7ebf\u6bb5\u6811\u5957vector\uff08\u6ed1\u7a3d\uff09"
    },
    {
        "content": "\u4eca\u5929\u7ed9\u5927\u5bb6\u4ecb\u7ecd\u4e00\u79cd\u65b0\u7684\u505a\u6cd5\n\n\u8fd9\u79cd\u505a\u6cd5\u662f**\u76ee\u524d\u6240\u6709\u672c\u9898\u5728\u7ebf\u505a\u6cd5\u7684\u9898\u89e3\u4e2d\uff0c\u7406\u8bba\u590d\u6742\u5ea6\u6700\u4f18\u7684\u505a\u6cd5**\n\n\u8fd9\u79cd\u505a\u6cd5\u662f**\u5728\u7ebf\u7684\uff0c\u5e76\u4e14\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n(logn)^2),\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3ao\uff08nlogn\uff09**\n\n\u5e38\u89c4\u4e00\u4e9b\u7684\u601d\u8def\u662f\uff0c\u5916\u5c42\u6811\u8bb0\u5f55\u4f4d\u7f6e\uff0c\u5185\u5c42\u4e00\u9897\u5e73\u8861\u6811\u8bb0\u5f55\u6570\u503c\uff0c\u4f46\u662f\u8fd9\u6837\u505a\uff0c\u5bf9\u4e8e\u67e5\u8be2\u6392\u540d\u4e3ak\u7684\u6570\u7684\u503c\u4e0d\u597d\u64cd\u4f5c\uff0c\u9700\u8981\u5148\u4e8c\u5206\u7b54\u6848\uff0c\u518d\u5224\u5b9a\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe\u4e09\u4e2alog\n\n\u8fd8\u6709\u4e00\u79cd\u601d\u8def\u662f\uff0c\u6811\u72b6\u6570\u7ec4\u5957\u4e3b\u5e2d\u6811\uff0c\u8fd9\u79cd\u65b9\u6cd5\u867d\u7136\u80fd\u505a\u5230\u4e24\u4e2alog\u67e5\u8be2\u6392\u540d\u4e3ak\u7684\u6570\u7684\u503c\uff0c\u4f46\u662f\u7a7a\u95f4\u590d\u6742\u5ea6\u9ad8\u8fbe\u4e24\u4e2alog,\u53ca\u5176\u5bb9\u6613MLE\n\n\u5e38\u89c4\u601d\u8def\u7684\u74f6\u9888\u5c31\u5728\u4e8e\u67e5\u8be2\u8fd9\u4e2a\u6392\u540d\u4e3ak\u7684\u503c\uff0c\u6211\u4eec\u8f6c\u6362\u4e0b\u601d\u8def\uff0c\u6539\u4e3a\n**\u5916\u5c42\u6811\u8bb0\u5f55\u6570\u503c\uff0c\u5185\u5c42\u6811\u8bb0\u5f55\u4f4d\u7f6e**\uff0c\u7528\u4e00\u4e2a\u52a8\u6001\u5f00\u70b9\u7684\u6743\u503c\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u6765\u89e3\u51b3\n\n\u5bf9\u4e8e\u64cd\u4f5c1\uff0c\u6211\u4eec\u67e5\u8be2\u503c\u5728[0,k-1]\u4e2d\uff0c\u6709\u591a\u5c11\u4f4d\u7f6e\u5728\u7ed9\u5b9a\u533a\u95f4\u5185\uff0c\u518d\u52a0\u4e00\u5c31\u662f\u6392\u540d\n\n\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u6211\u4eec\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u5e76\u67e5\u8be2\u8be5\u8282\u70b9\u6709\u591a\u5c11\u6570\u5728\u7ed9\u5b9a\u4f4d\u7f6e\u533a\u95f4\u5185\u5224\u5b9a\u5373\u53ef\n\n\u5bf9\u4e8e\u64cd\u4f5c3\uff0c\u6211\u4eec\u5148\u628a\u539f\u6765\u7684\u90a3\u4e9b\u8282\u70b9\u5168\u90e8\u5220\u9664\uff0c\u7136\u540e\u518d\u63d2\u5165\u65b0\u7684\u8282\u70b9\n\n\u5bf9\u4e8e\u64cd\u4f5c4\uff0c\u6211\u4eec\u5148\u67e5\u8be2k\u7684\u6392\u540d\uff0c\u5982\u679c\u662f1\u8bf4\u660e\u6ca1\u6709\u524d\u9a71\uff0c\u5426\u5219\u8f93\u51fa\u6392\u540d\u4e3ak\u7684\u6392\u540d-1\u7684\u6570\n\n\u5bf9\u4e8e\u64cd\u4f5c5\uff0c\u6211\u4eec\u5148\u67e5\u8be2k+1\u7684\u6392\u540d\uff0c\u5982\u679ck+1\u7684\u6392\u540d\u5927\u4e8er-l+1\uff0c\u8bf4\u660e\u6ca1\u6709\u540e\u7ee7\uff0c\u5426\u5219\u8f93\u51fa\u6392\u540d\u4e3ak+1\u7684\u6392\u540d\u7684\u6570\n\n\u4ee5\u4e0b\u662f\u4ee3\u7801\uff0c\n\n```cpp\n#include<stdio.h>\n#define fa 4800000\n#define fa2 1600000\n#define LL long long\ntypedef struct Splay\n{\n    typedef struct Ts\n    {\n        int size,x;\n        Ts*f,*l,*r;\n    }Ts;\n    static Ts mem[fa],*stk[fa],**top;\n    Ts*root;\n    inline Ts*New(int x,Ts*f)\n    {\n        Ts*p=*--top;\n        p->size=1;\n        p->x=x;\n        p->f=f;\n        p->l=p->r=0;\n        return p;\n    }\n    inline void Del(Ts*&t)\n    {\n        *top++=t;\n        t=0;\n    }\n    void init()\n    {\n        root=New(999999,0);\n        root->l=New(-1,root);\n        root->size=2;\n    }\n    void del(Ts*t)\n    {\n        if(t)\n        {\n            del(t->l);\n            del(t->r);\n            Del(t);\n        }\n    }\n    inline void updata(Ts*t)\n    {\n        t->size=1;\n        if(t->l)t->size+=t->l->size;\n        if(t->r)t->size+=t->r->size;\n    }\n    inline void zuoxuan(Ts*t)\n    {\n        Ts*p=t->f;\n        p->r=t->l;\n        if(t->l)t->l->f=p;\n        t->l=p;\n        if(p->f)\n        {\n            if(p->f->l==p)p->f->l=t;\n            else p->f->r=t;\n        }\n        t->f=p->f;\n        p->f=t;\n        updata(p);\n        updata(t);\n    }\n    inline void youxuan(Ts*t)\n    {\n        Ts*p=t->f;\n        p->l=t->r;\n        if(t->r)t->r->f=p;\n        t->r=p;\n        if(p->f)\n        {\n            if(p->f->l==p)p->f->l=t;\n            else p->f->r=t;\n        }\n        t->f=p->f;\n        p->f=t;\n        updata(p);\n        updata(t);\n    }\n    void danxuan(Ts*t)\n    {\n        if(t->f->l==t)youxuan(t);\n        else zuoxuan(t);\n    }\n    void splay(Ts*t,Ts*f=0)\n    {\n        Ts*tt;\n        while((tt=t->f)!=f)\n        {\n            if(tt->f!=f)\n            {\n                if((tt->f->l==tt)==(t->f->l==t))danxuan(tt);\n                else danxuan(t);\n            }\n            danxuan(t);\n        }\n        if(!f)root=t;\n    }\n    void insert(int x)\n    {\n        Ts*t=root;\n        while(1)\n        {\n            t->size++;\n            if(x<t->x)\n            {\n                if(t->l)t=t->l;\n                else\n                {\n                    t->l=New(x,t);\n                    t=t->l;\n                    break;\n                }\n            }\n            else\n            {\n                if(t->r)t=t->r;\n                else\n                {\n                    t->r=New(x,t);\n                    t=t->r;\n                    break;\n                }\n            }\n        }\n        splay(t);\n    }\n    void erase(int x)\n    {\n        Ts*t=root;\n        while(t->x!=x)\n        {\n            if(x<t->x)t=t->l;\n            else t=t->r;\n        }\n        splay(t);\n        Ts*l=t->l,*r=t->r;\n        while(l->r)l=l->r;\n        while(r->l)r=r->l;\n        splay(l);splay(r,l);\n        Del(r->l);\n        l->size--;r->size--;\n    }\n    \n    Ts*qianqu(int x)\n    {\n        Ts*q,*t=root;\n        int min=9999999;\n        while(t)\n        {\n            if(t->x>=x)t=t->l;\n            else\n            {\n                if(x-t->x<min)\n                {\n                    q=t;\n                    min=x-t->x;\n                }\n                t=t->r;\n            }\n        }\n        return q;\n    }\n    Ts*houji(int x)\n    {\n        Ts*q,*t=root;\n        int min=9999999;\n        while(t)\n        {\n            if(t->x<=x)t=t->r;\n            else\n            {\n                if(t->x-x<min)\n                {\n                    q=t;\n                    min=t->x-x;\n                }\n                t=t->l;\n            }\n        }\n        return q;\n    }\n    int num(int l_,int r_)\n    {\n        Ts*l=qianqu(l_),*r=houji(r_);\n        splay(l);splay(r,l);\n        return r->l?r->l->size:0;\n    }\n}Splay;\nSplay::Ts Splay::mem[fa],*Splay::stk[fa],**Splay::top=Splay::stk+fa;\ntypedef struct Ts\n{\n    Splay t;\n    Ts*l,*r;\n}Ts;\nTs*root,mem[fa2],*stk[fa2],**top=stk+fa2;\ninline Ts*New()\n{\n    Ts*p=*--top;\n    p->l=p->r=0;\n    p->t.init();\n    return p;\n}\ninline void Del(Ts*&t)\n{\n    *top++=t;\n    t->t.del(t->t.root);\n    t=0;\n}\nvoid insert(Ts*&t,int x,int y,int L=0,int R=100000000)\n{\n    if(!t)t=New();\n    t->t.insert(y);\n    if(L^R)\n    {\n        int mid=L+R>>1;\n        if(x<=mid)insert(t->l,x,y,L,mid);\n        else insert(t->r,x,y,mid+1u,R);\n    }\n}\nvoid erase(Ts*&t,int x,int y,int L=0,int R=100000000)\n{\n    t->t.erase(y);\n    if(L^R)\n    {\n        int mid=L+R>>1;\n        if(x<=mid)erase(t->l,x,y,L,mid);\n        else erase(t->r,x,y,mid+1u,R);\n    }\n    if(t->t.root->size==2)Del(t);\n}\nint kth(Ts*t,int l,int r,int l_,int r_,int L=0,int R=100000000)\n{\n    if(!t)return 0;\n    if(l==L&&r==R)return t->t.num(l_,r_);\n    else\n    {\n        int mid=L+R>>1;\n        if(r<=mid)return kth(t->l,l,r,l_,r_,L,mid);\n        else if(l>mid)return kth(t->r,l,r,l_,r_,mid+1,R);\n        else return kth(t->l,l,mid,l_,r_,L,mid)+kth(t->r,mid+1,r,l_,r_,mid+1,R);\n    }\n}\nint num(Ts*t,int k,int l_,int r_,int L=0,int R=100000000)\n{\n    if(L==R)return L;\n    int ls=t->l?t->l->t.num(l_,r_):0;\n    int mid=L+R>>1;\n    if(ls<k)return num(t->r,k-ls,l_,r_,mid+1,R);\n    else return num(t->l,k,l_,r_,L,mid);\n}\nint a[50000];\nint main()\n{\n    for(int i=0;i<fa;i++)Splay::stk[i]=Splay::mem+i;\n    for(int i=0;i<fa2;i++)stk[i]=mem+i;\n    int N,M,ls,l,r,k;\n    scanf(\"%d%d\",&N,&M);\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%d\",a+i);\n        insert(root,a[i],i);\n    }\n    while(M--)\n    {\n        scanf(\"%d\",&ls);\n        if(ls==1)\n        {\n            scanf(\"%d%d%d\",&l,&r,&k);\n            if(k==0)puts(\"1\");\n            else printf(\"%d\\n\",kth(root,0,k-1,l-1,r-1)+1);\n        }\n        else if(ls==2)\n        {\n            scanf(\"%d%d%d\",&l,&r,&k);\n            printf(\"%d\\n\",num(root,k,l-1,r-1));\n        }\n        else if(ls==3)\n        {\n            scanf(\"%d%d\",&l,&k);--l;\n            erase(root,a[l],l);\n            insert(root,a[l]=k,l);\n        }\n        else if(ls==4)\n        {\n            scanf(\"%d%d%d\",&l,&r,&k);\n            int no=kth(root,0,k-1,l-1,r-1);\n            if(no==0)puts(\"-2147483647\");\n            else printf(\"%d\\n\",num(root,no,l-1,r-1));\n        }\n        else\n        {\n            scanf(\"%d%d%d\",&l,&r,&k);\n            int no=kth(root,0,k,l-1,r-1);\n            if(no>r-l)puts(\"2147483647\");\n            else printf(\"%d\\n\",num(root,no+1,l-1,r-1));\n        }\n    }\n}\n\n```",
        "postTime": 1533140178,
        "uid": 58279,
        "name": "cuking",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8bf4\u8bf4\u6b64\u9898\u6211\u77e5\u9053\u7684\u51e0\u79cd\u65b9\u6cd5\n\n\n\u53ef\u4fee\u6539\u533a\u95f4k\u5927\u7684\u9a97\u5206\u505a\u6cd5:\u5206\u5757\u3002\n\n\u5206\u6210\u6839\u53f7n\u4e2a\u5757\uff0c\u5757\u5185\u6392\u5e8f\u3002\n\n\u6bcf\u4e2a\u6570\u5728\u5757\u5185\u4fbf\u53ef\u4e8c\u5206\u67e5\u627e\u524d\u9a71\uff0c\u4ece\u800c\u5f97\u5230\u591a\u5c11\u4e2a\u6570\u6bd4\u4ed6\u5c0f\u3002\n\n\u5757\u5916\u90e8\u5206\u66b4\u529b\u68c0\u9a8c\u3002\n\n\u6bcf\u6b21\u4e8c\u5206\u81f3\u4e00\u4e2a\u503ci,\u4f7f\u5f97<i-1\u7684\u6570<k,<i\u7684\u6570<=k\u3002\n\n\u4e00\u6b21\u65f6\u95f4O(log\u8303\u56f4\\*(\u6839\u53f7n\\*log(\u6839\u53f7n)))\n\n\n\u66b4\u529b\u505a\u6cd5:\u8ddf\u4e0a\u4e00\u79cd\u7c7b\u4f3c\uff0c\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\n\n\n\u6b63\u89e3\uff1a\n\n1 \u6574\u4f53\u4e8c\u5206\n\n\u5c31\u662f\u4e8c\u5206\u7b54\u6848\u8dd1cdq\uff0c\n\n\u5bf9\u4e8e\u67e5\u8be2k\u5927\uff0c\u6211\u4eec\u5f97\u5230\u5de6\u8fb9\u7684\u4e2a\u6570num\uff0c\u5982\u679ck<=num,\u53bb\u5de6\u8fb9\uff0c\u5426\u5219k-=num,\u53bb\u53f3\u8fb9\n\n\u5426\u5219k<=mid\u5206\u5de6\uff0c\u5426\u5219\u5206\u53f3\u8fb9\u3002\n\n\u5bf9\u4e8e\u67e5\u8be2rank\uff0c\u6211\u4eec\u53ea\u5728k>mid\u7684\u65f6\u5019\uff0c\u7528num\u66f4\u65b0\u7b54\u6848\u3002\n\n\u5bf9\u4e8e\u67e5\u8be2\u524d\u9a71\uff0c\u6211\u4eec\u53ea\u5728k>mid\u7684\u65f6\u5019\uff0c\u7528\u5de6\u8fb9\u7684\u5bf9\u5e94\u533a\u95f4max\u66f4\u65b0\u7b54\u6848(\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef)\u3002\n\n(\u6211\u901a\u8fc7\u5c06\u6240\u6709\u6570\u53d6\u53cd\u6765\u5c06\u540e\u7ee7\u8f6c\u5316\u4e3a\u524d\u9a71\u5904\u7406\u3002)\n\n\n\u6b64\u6cd5\u8f83\u597d\u5b9e\u73b0\u3002\n\n\u8bbeU\u4e3a\u6570\u7684\u8303\u56f4\uff0c\u65f6\u95f4(n+m)\\*logUlogn\u3002\u79bb\u6563\u540e\u5e94\u8be5\u662f(n+m)\\*lognlogn\uff0c\u4f46\u6211\u61d2\u5f97\u79bb\u6563\u3002\u3002\n\n\u76ee\u524d\u62ff\u4e86\u8fd9\u9898\u6d1b\u8c37\u7684rank2\u3002\n\n\n\u6838\u5fc3\u90e8\u5206:\n\n```cpp\nvoid solve(int L,int R,int l,int r)\n{\n    if (l>r) return;\n    if (L==R)\n    {\n        for (i=l;i<=r;++i)\n        {\n            x=q[i];\n            if (a[x].type==2) ans[a[x].id]=L;\n        }\n        return;\n    }\n    int mid=(L+R)>>1;\n    t1=t2=t3=0;\n    for (i=l;i<=r;++i)\n    {\n        now=q[i];\n        if (a[now].type==2)\n        {\n            num=T.qiu_s(a[now].l,a[now].r);\n            if (num<a[now].x) { a[now].x-=num;q2[++t2]=now; }\n            else  q1[++t1]=now; \n        } else\n        {\n            if (a[now].x>mid) q2[++t2]=now; \n            else  q1[++t1]=now; \n             \n            if (a[now].type==3)\n            {\n                if (a[now].x<=mid)\n                {\n                    q3[++t3]=now;\n                 T.add(a[now].l,a[now].id,a[now].x);\n                }\n            } else\n            if (a[now].x>mid)\n            if (a[now].type==4)\n            {\n                chmax(ans[a[now].id],T.qiu_m(a[now].l,a[now].r));\n            } else\n             ans[a[now].id]+=T.qiu_s(a[now].l,a[now].r);\n        }\n    }\n     \n    while (t3) { now=q3[t3--];T.clear(a[now].l); }\n    int k=l-1;\n    for (i=1;i<=t1;++i) q[++k]=q1[i];\n    for (i=1;i<=t2;++i) q[k+i]=q2[i];\n    solve(L,mid,l,k);solve(mid+1,R,k+1,r);\n}\n```\n\n2\u6811\u72b6\u6570\u7ec4\u5957\u52a8\u6001\u52a0\u70b9\u7ebf\u6bb5\u6811\n\n\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u5f88\u591a\u4eba\u8bf4\u662f\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u3002\u5176\u5b9e\u6211\u4eec\u662f\u5bf9\u6811\u72b6\u6570\u7ec4\u6bcf\u4e2a\u8282\u70b9\u5957\u4e86\u4e2a\u7ebf\u6bb5\u6811\uff0c\u5f7c\u6b64\u4e4b\u95f4\u5e76\u6ca1\u6709\u5173\u8054\u7684\u3002\n\n\u60f3\u6cd5\u5c31\u662f\uff0c\u5047\u5982\u6211\u4eec\u5f97\u5230\u4e86[l,r]\u7684\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u90a3\u4e48\u663e\u7136\u4e00\u5207\u64cd\u4f5c\u90fd\u80fdlogn\u505a\u4e86\u3002\n\n\u7531\u4e8e\u6211\u4eec\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f\u6743\u503c\u533a\u95f4\u5185\u7684\u70b9\u7684\u4e2a\u6570\uff0c\u8fd9\u662f\u53ef\u4ee5\u52a0\u548c\u7684\u3002\n\n\u6240\u4ee5\u5982\u679c\u6211\u4eec\u7ed9\u6bcf\u4e2a\u70b9\u5efa\u4e2a\u7ebf\u6bb5\u6811\uff0c\u90a3\u4e48\u5c31\u662f\u8be2\u95ee[l,r]\u7684\u7ebf\u6bb5\u6811\u7684\u548c\u3002\n\n\u90a3\u4e48\u5b9e\u9645\u4e0a\u8fd9\u5c31\u662f\u4ee5\u7ebf\u6bb5\u6811\u4e3a\u5bf9\u8c61\u7684\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u6c42\u548c!\n\n\u7528\u6811\u72b6\u6570\u7ec4\u5e94\u8be5\u662f\u6700\u597d\u7684\uff0c\u51cf\u5c11\u4e86\u4fee\u6539\u65f6\u6d89\u53ca\u7684\u7ebf\u6bb5\u6811\u7684\u4e2a\u6570\uff0c\u4fdd\u62a4\u65f6\u7a7a\u3002\n\n\u6570\u636e\u4e5f\u662f\u8981\u5148\u79bb\u6563\u7684\uff0c\u4fdd\u62a4\u65f6\u7a7a\u3002\n\n\u5176\u5b9e\u4e3b\u8981\u662f\u4fdd\u62a4\u7a7a\u95f4\u5566\uff0c\u6bd5\u7adf\u52a8\u6001\u52a0\u70b9\u7684\u4e0a\u9650\u53ea\u67098e6(\u518d\u5927\u4e5f\u5f00\u4e0d\u4e86)\uff0c\u8fd9\u662f\u8fdc\u8fdc\u5c0f\u4e8e\u65f6\u95f4\u4e0a\u9650\u7684\u3002\n\n\n\u65f6\u95f4(n+m)\\*lognlogn\u3002\u7a7a\u95f4\u4e5f\u4e00\u6837\u3002\n\n\u76ee\u524d\u62ff\u4e86\u8fd9\u9898bzoj\u7684rank1(\u5f53\u7136\u4e5f\u662f\u6d1b\u8c37\u7684)\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ch_top 10000000\nchar ch[ch_top],*now_r=ch;\nvoid read(int &x)\n{\n    while (*now_r<48) ++now_r;\n    for (x=*now_r-48;*++now_r>=48;)\n     x=(x<<1)+(x<<3)+*now_r-48;\n}\n \n#define N 50010\n#define M 20\n#define MN 8000000\n#define oo 2147483647 \n\nstruct tree\n{\n    int c[2],s;\n}T[MN];int TOT;\n\nstruct query\n{\n    int o,l,r,k;\n}a[N];\nint c[N],last[N];\nint *p[N<<1],dy[N<<1],pt;\n\n#define L(x) T[x].c[0]\n#define R(x) T[x].c[1]\n#define S(x) T[x].s\n\n#define LX   T[x].c[0]\n#define RX   T[x].c[1]\n#define mid ((l+r)>>1)\nint l,r,w;\nvoid modify(int x,int i)\n{\n    l=1;r=pt;\n    for (;;)\n    {\n        S(x)+=w;    \n        if (l==r) return;\n        if (i<=mid) \n        { \n          if (!LX) LX=++TOT;\n          x=LX;r=mid; \n        }\n        else\n        {\n          if (!RX) RX=++TOT;\n          x=RX;l=mid+1;         \n        }\n    }\n}\n\nint n;\nvoid mo(int i,int x)\n{\n    for (;i<=n;i+=i&-i)\n     modify(c[i],x);\n}\n\nint ql[M][M],qr[M][M];\nvoid init(int *q,int i)\n{\n    for (q[0]=0;i;i-=i&-i)\n     q[++q[0]]=c[i];\n}\n\nint i;\nvoid _move(int *qx,int *qy,bool d)\n{\n    for (i=qy[0]=qx[0];i;--i)\n     qy[i]=T[qx[i]].c[d];\n}\nvoid move(int x,int y,bool d)\n{\n    _move(ql[x],ql[y],d);\n    _move(qr[x],qr[y],d);  \n}\n\nint Get;\nint _get(int *q,bool d)\n{\n    for (i=1,Get=0;i<=q[0];++i) Get+=S(T[q[i]].c[d]); \n    return Get;\n}\nint get(int x,bool d)\n{\n    return _get(qr[x],d)-_get(ql[x],d);\n}\n\nint ans;\nvoid order(int x)\n{\n   l=1;r=pt;\n   for (ans=1;l!=r;)\n         if (x>mid) {ans+=get(0,0);move(0,0,1);l=mid+1;} else\n         {move(0,0,0);r=mid;}\n}\nvoid find_by_order(int k)\n{\n   l=1;r=pt;\n   while (l!=r)\n   {\n         ans=get(0,0);\n         if (k>ans) {k-=ans;move(0,0,1);l=mid+1;} else\n         {move(0,0,0);r=mid;}\n   }\n   \n   ans=dy[l];\n}\n\nstruct ever\n{\n    int l,r;\n}e[M];\nint top;\nvoid pre(int x)\n{\n   l=1;r=pt;top=0;\n   while (l!=r)\n   if (x>mid) \n   { \n     e[top]={l,mid};\n     move(top,top+1,1);++top;\n     l=mid+1; \n   } \n   else\n   { move(top,top,0);r=mid; }\n\n   while (top--)\n     if ( get(top,0) ) \n     {\n         move(top,0,0);\n         l=e[top].l;r=e[top].r;\n         while (l!=r)\n         if ( get(0,1) ) { move(0,0,1);l=mid+1; }\n         else { move(0,0,0);r=mid; }\n         \n         ans=dy[l];\n         return ;\n     }\n     \n   ans=-oo;\n}\nvoid next(int x)\n{\n   l=1;r=pt;top=0;\n   while (l!=r)\n   if (x>mid) \n   { \n     move(top,top,1);\n     l=mid+1; \n   } \n   else\n   { \n     e[top]={mid+1,r};\n     move(top,top+1,0);++top;\n     r=mid; \n   }\n   \n   while (top--)\n     if ( get(top,1) ) \n     {\n         move(top,0,1);\n         l=e[top].l;r=e[top].r;\n         while (l!=r)\n         if ( get(0,0) ) { move(0,0,0);r=mid; }\n         else { move(0,0,1);l=mid+1; }\n         \n         ans=dy[l];\n         return ;\n     }\n     \n   ans=oo;\n}\n\nbool xiao(const int *x,const int *y)\n{\n    return *x<*y;\n}\n\nint main()\n{ //freopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n    ch[fread(ch,1,ch_top,stdin)]=0;\n    int m,i,o;\n    read(n);read(m);\n     \n    for (i=1;i<=n;++i) \n    {\n        read(last[i]);\n        p[i]=last+i;\n    }\n    int tot=n;\n    for (i=1;i<=m;++i)\n    {\n        read(a[i].o);read(a[i].l);read(a[i].r);\n        if (a[i].o==3) p[++tot]=&a[i].r;\n        else\n        {\n            read(a[i].k);\n            if (a[i].o!=2) p[++tot]=&a[i].k;\n        }\n    }\n    //\u5148\u79bb\u6563\u6389\uff0c\u8282\u7ea6\u5f00\u7ebf\u6bb5\u6811\u7684\u65f6\u7a7a\n    sort(p+1,p+tot+1,xiao);\n    dy[1]=*p[1];*p[1]=pt=1;\n    for (i=2;i<=tot;++i)\n    {\n        if (*p[i]!=dy[pt]) dy[++pt]=*p[i]; \n        *p[i]=pt;\n    }\n\n    w=1;\n    for (i=1;i<=n;++i) c[i]=i;TOT=n;\n    for (i=1;i<=n;++i)  mo(i,last[i]);\n    \n    for (o=1;o<=m;++o)\n    {\n    if (a[o].o==3)\n    {\n        w=-1;i=a[o].l;\n        mo(i,last[i]);\n        w=1;\n        mo(i,last[i]=a[o].r);\n    } else\n    {\n        init(ql[0],a[o].l-1);init(qr[0],a[o].r);\n        if (a[o].o==1) order(a[o].k); else\n        if (a[o].o==2) find_by_order(a[o].k); else\n        if (a[o].o==4) pre(a[o].k);\n        else next(a[o].k);\n        \n        printf(\"%d\\n\",ans);\n    }\n    }   \n}\n\n```",
        "postTime": 1480723175,
        "uid": 9168,
        "name": "kczno1",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u5927\u5bb6\u597d\uff0c\u6211\u975e\u5e38\u559c\u6b22\u66b4\u529b\u6570\u636e\u7ed3\u6784\uff0c\u4e8e\u662f\u6211\u5c31\u7528\u5206\u5757\u8fc7\u4e86\u8fd9\u9053\u9898\u3002\n\n# \u5e76\u4e14\u53ef\u80fd\u6bd4\u5927\u591a\u6570\u4eba\u7684\u6811\u5957\u6811\u90fd\u5757\n\n~~\u5176\u5b9e\u8fd9\u9898\u5c31\u662fP4119\u7684\u5f31\u5316\u7248~~\n\n## \u672c\u4f53\u9898\u89e3\n\n\u8fd9\u9898\u8ba9\u6211\u4eec\u5b9e\u73b04\u4e2a\u64cd\u4f5c\uff0c\u533a\u95f4kth\uff0c\u533a\u95f4\u524d\u9a71\uff0c\u533a\u95f4\u540e\u7ee7\uff0c\u533a\u95f4\u67e5\u8be2\u6392\u540d\n\n\u90a3\u4e48\u5982\u679c\u4f60\u5bf9\u57fa\u672c\u7684\u6570\u636e\u7ed3\u6784\u8db3\u591f\u719f\u7ec3\u7684\u8bdd\u4f1a\u77e5\u9053\u8fd9\u4e9b\u5176\u5b9e\u53ef\u4ee5\u8fd9\u4e9b\u95ee\u9898\u90fd\u53ef\u4ee5\u7528\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u5728$O(log(n))$\u7684\u65f6\u95f4\u5185\u89e3\u51b3\n\n\u4f46\u662f\u8fd9\u9898\u8fd8\u591a\u4e00\u4e2a\u64cd\u4f5c\uff0c\u90a3\u5c31\u662f\u5355\u70b9\u4fee\u6539\u70b9\u6743\uff0c\u6b64\u65f6\u6211\u4eec\u7684\u95ee\u9898\u53ef\u80fd\u5c31\u4f1a\u53d8\u5f97\u6bd4\u8f83\u8fa3\u624b\u4e86\uff0c\u8be5\u600e\u4e48\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u5462?\n\n~~\u6811\u72b6\u6570\u7ec4\u5957\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u6b64\u9898\u5b8c\u7ed3~~\n\n\u5f53\u7136\u8fd9\u53ef\u80fd\u4e5f\u662f\u8fd9\u9053\u9898\u7684\u6811\u5957\u6811\u89e3\u6cd5\u4e4b\u4e00\uff0c\u800c\u4e14\u8dd1\u7684\u5e76\u4e0d\u6162\n\n~~\u4f46\u662f\u6211\u4eec\u5c31\u662f\u559c\u6b22\u5206\u5757~~\n\n\u5728\u8fd9\u9053\u9898\u7684\u4e00\u7bc7\u9898\u89e3\u5f53\u4e2d\u4ecb\u7ecd\u4e86\u4e00\u79cd\u4e71\u4e03\u516b\u7cdf\u7684\u4e8c\u5206+\u5206\u5757\u505a\u6cd5\u2026\u2026\n\n\u95ee\u9898\u6765\u4e86\uff0c**\u5206\u5757\u8fd9\u4e2a\u7b97\u6cd5\u548c\u4e8c\u5206\u6cd5\u6839\u672c\u4e0d\u5951\u5408**\n\n\u4e3a\u4ec0\u4e48\u6211\u4eec\u5728\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u4e0a\u4f1a\u4f7f\u7528\u4e8c\u5206\u6cd5\uff1f\u56e0\u4e3a\u7ebf\u6bb5\u6811\u8fd9\u4e2a\u4e1c\u897f\u672c\u8eab\u5c31\u548c\u4e8c\u5206\u7684\u7b97\u6cd5\u6d41\u7a0b\u76f8\u5f53\u50cf\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u4f7f\u7528\u4e8c\u5206\u5c31\u53ef\u4ee5\u5728$O(logn)$\u7684\u65f6\u95f4\u5185\u51fa\u89e3\n\n\u4f46\u662f\u73b0\u5728\u652f\u6301\u4e8c\u5206\u7684\u5e95\u5c42\u6570\u636e\u7ed3\u6784\u53d8\u6210\u4e86\u5206\u5757\uff0c\u4f17\u6240\u5468\u77e5\uff0c\u4e8c\u5206\u7684\u601d\u60f3\u662f\u5206\u6cbb,\u800c\u5206\u5757\u7684\u601d\u60f3\u662f\u66b4\u529b\u4e4b\u95f4\u7684\u5e73\u8861\uff0c\u8fd9\u4e24\u4e2a\u7b97\u6cd5\u4e4b\u95f4\u660e\u663e\u4e0d\u642d\u8c03\uff0c\u56e0\u6b64\u6211\u4eec\u7684\u590d\u6742\u5ea6\u4f1a\u51ed\u7a7a\u591a\u4e2alog\u51fa\u6765\u53d8\u6210\u4e86$O(\\sqrt{N} logn)$\n\n\u90a3\u4e48\u5bf9\u4e8ekth\u95ee\u9898\u6211\u4eec\u5176\u5b9e\u8fd8\u6709\u4e00\u4e2a\u7b97\u6cd5\u662f\u57fa\u4e8e\u5bf9\u503c\u57df\u5206\u5757\u7684\u7b97\u6cd5\n\n\u5047\u8bbe\u6211\u4eec\u73b0\u5728\u9700\u8981\u77e5\u9053\u4e00\u4e9b\u6570\u5b57\u4e2d\u7684\u7b2ck\u5927,\u5e76\u4e14\u4ec5\u4ec5\u8981\u6c42\u5728$O(\\sqrt{N})$\u7684\u65f6\u95f4\u5185\u51fa\u89e3\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u53d6\u8fd9\u6837\u4e00\u79cd\u7b97\u6cd5\uff0c\u5c06\u503c\u57df\u5206\u6210$O(\\sqrt{N})$\u5757\n\n\u7136\u540e\u8bbe\u4e24\u4e2a\u6570\u7ec4$cnt1(i)$\u8868\u793a\u7b2ci\u4e2a\u503c\u57df\u5757\u6709\u51e0\u4e2a\u70b9\uff0c$cnt2(i)$\u8868\u793a\u7b2ci\u8fd9\u4e2a\u503c\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\n\n\u90a3\u4e48\u6211\u4eec\u601d\u8def\u5c31\u662f\u66b4\u529b\u7684for\u5faa\u73af\n\n\u5bf9\u4e8e\u67e5\u8be2\u5143\u7d20\u6392\u540d\u7684\u64cd\u4f5c\uff0c\u5047\u8bbe\u8fd9\u4e2a\u5143\u7d20\u5728\u7b2ci\u5757\u800c\u503c\u4e3ax\uff0c\u6211\u4eec\u5148\u66b4\u529b\u7684\u628a$cnt1(1)$\u5230$cnt1(i-1)$\u7684\u503c\u52a0\u5230\u7b54\u6848\u5f53\u4e2d\u53bb,\u7136\u540e\u518d\u628a\u548cx\u5728\u540c\u4e00\u4e2a\u503c\u57df\u5757\u7684\u6570\u5b57\u52a0\u5230\u7b54\u6848\u4e2d\u53bb\uff0c\u8fd9\u4e2a\u4e1c\u897f\u53ef\u4ee5\u67e5$cnt2$\u5f97\u5230\n\n\u5bf9\u4e8e\u67e5\u8be2kth\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u679a\u4e3e\u8fd9\u4e2a\u5143\u7d20\u5728\u7b2c\u51e0\u5757\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d$cnt1$\u5f97\u5230\uff0c\u5c06kth\u5b9a\u4f4d\u5728\u67d0\u4e00\u4e2a\u5757\u5185\u4e4b\u540e\uff0c\u5728\u8fd9\u4e2a\u503c\u57df\u5757\u5185\u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d\uff0c\u901a\u8fc7\u67e5$cnt2$\u5c31\u53ef\u4ee5\u5f97\u77e5kth\u5230\u5e95\u662f\u54ea\u4e2a\u5143\u7d20\u4e86\n\n\u5bf9\u4e8e\u67e5\u8be2\u524d\u9a71\u548c\u540e\u7ee7\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u901a\u8fc7\u67e5$cnt2$\u53ef\u4ee5\u67e5\u8be2\u5b83\u81ea\u5df1\u503c\u57df\u5757\u6709\u6ca1\u6709\u5b83\u7684\u524d\u9a71\u548c\u540e\u7ee7\uff0c\u5982\u679c\u6709\u7684\u8bdd\u76f4\u63a5\u8f93\u51fa\u7ed3\u679c\uff0c\u5426\u5219\u627e\u5230\u8fd9\u4e2a\u70b9\u5de6\u4fa7\u6216\u8005\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u975e\u7a7a\u7684\u5757\u7136\u540e\u5728\u8fd9\u4e2a\u5757\u5185\u66b4\u529b\u627e\u524d\u9a71\u540e\u7ee7\u5373\u53ef\n\n\u8fd9\u6837\u6211\u4eec\u5c31\u5728$O(\\sqrt{N})$\u7684\u65f6\u95f4\u5185\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\n\n\u4f60\u53ef\u80fd\u4f1a\u95ee\uff0c\u8fd9\u4e1c\u897f\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u4e8c\u5206\u76f4\u63a5\u5b8c\u7206\u8fd9\u4e2a\u5783\u573e\u7b97\u6cd5\n\n\u4f46\u662f\u4e0d\u77e5\u9053\u4f60\u53d1\u73b0\u6ca1\u6709\u53d1\u73b0\u4e00\u4e2a\u4e8b\u5b9e\uff0c\u4e8c\u5206\u6cd5\u8981\u6c42\u6211\u4eec\u5feb\u901f\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\n\n**\u5728\u8fd9\u4e2a\u6570\u5b57\u96c6\u5408\u5f53\u4e2d\u6709\u51e0\u4e2a\u6570\u5b57\u6bd4x\u5927**\n\n\u4f46\u662f\u521a\u624d\u7684\u7b97\u6cd5\u6211\u4eec\u4ec5\u4ec5\u9700\u8981\u56de\u7b54\u8fd9\u4e2a\u95ee\u9898\n\n**\u5728\u8fd9\u4e2a\u6570\u5b57\u96c6\u5408\u5f53\u4e2d\u6709\u51e0\u4e2a\u6570\u5b57\u6070\u597d\u4e3ax\uff0c\u4ee5\u53ca\u5728\u8fd9\u4e2a\u6570\u5b57\u96c6\u5408\u5f53\u4e2d\u6709\u51e0\u4e2a\u6570\u5b57\u6070\u597d\u843d\u5728\u4e86\u7b2ci\u4e2a\u503c\u57df\u5757\u91cc**\n\n\u663e\u7136\u7ef4\u62a4\u8fd9\u4e24\u4e2a\u4fe1\u606f\u7684\u96be\u5ea6\u662f\u76f8\u5f53\u4e0d\u4e00\u6837\u7684\n\n_________________\n\n\u73b0\u5728\u8ba9\u6211\u4eec\u6765\u8003\u8651\u5982\u4f55\u7528\u5206\u5757\u6765\u89e3\u51b3\u8fd9\u9053\u9898\n\n\u9996\u5148\u5c06\u6574\u4e2a\u5e8f\u5217\u5206\u6210$O(\\sqrt{N})$\u5757\uff0c\u7136\u540e\u5c06\u51fa\u73b0\u7684\u503c\u5168\u90e8\u79bb\u6563\u5316\u8fd9\u6837\u503c\u57df\u4e5f\u53d8\u6210$O(N+M)$\u7ea7\u522b\u7684\u4e86\uff0c\u7136\u540e\u5c06\u503c\u57df\u5206\u6210$O(\\sqrt{N+M})$\u5757\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u6253\u4e24\u4e2a\u8868\u51fa\u6765$cnt1(i,j)$\u8868\u793a\u524di\u5757\u843d\u5728\u7b2cj\u4e2a\u503c\u57df\u5757\u7684\u6570\u5b57\u6709\u51e0\u4e2a,$cnt2(i,j)$\u8868\u793a\u524di\u4e2a\u5757\u503c\u6070\u597d\u4e3aj\u7684\u6570\u5b57\u6709\u51e0\u4e2a\uff0c\u8fd9\u4e24\u4e2a\u8868\u663e\u7136\u53ef\u4ee5\u5728$O(N\\sqrt{N})$\u7684\u65f6\u95f4\u5185\u9884\u5904\u7406\u51fa\u6765\n\n\u90a3\u4e48\u4fee\u6539\u7684\u65f6\u5019\u76f8\u5f53\u7b80\u5355\uff0c\u628ax\u6539\u6210y\u5c31\u76f4\u63a5\u66b4\u529b\u4fee\u6539\u8fd9\u4e24\u4e2a\u8868\u5c31\u884c\u4e86\uff0c\u590d\u6742\u5ea6\u663e\u7136$O(\\sqrt{N})$\n\n\u5bf9\u4e8e\u5176\u4ed6\u7684\u8be2\u95ee\u64cd\u4f5c\uff0c\u5176\u5b9e\u6211\u4eec\u5c31\u662f\u60f3\u8981\u5f97\u5230\u8fd9\u4e2a\u533a\u95f4\u7684cnt1\u548ccnt2\u6570\u7ec4\u957f\u4ec0\u4e48\u6837,\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u66b4\u529b\u7684\u5904\u7406\u51fa\u6765\u8fb9\u89d2\u70b9\u7684cnt1\u548ccnt2\u6570\u7ec4\uff0c\u7136\u540e\u5bf9\u4e8e\u7b2ci\u4e2a\u5757\u548c\u7b2cj\u5757\u4e4b\u95f4\u7684cnt1\u548ccnt2\u6570\u7ec4\u6211\u4eec\u53ef\u4ee5\u7528$cnt1(j,...)-cnt1(i-1,...)$\u548c$cnt2(j,...)-cnt2(i-1,...)$\u6765\u5f97\u5230\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728$O(\\sqrt{N+M})$\u7684\u65f6\u95f4\u5185\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u4e86\uff0c\u81f3\u4e8e4\u4e2a\u64cd\u4f5c\u7684\u5177\u4f53\u6d41\u7a0b\u5df2\u7ecf\u5728\u4e0a\u9762\u5199\u7684\u76f8\u5f53\u6e05\u695a\u4e86\u6b64\u5904\u5c31\u4e0d\u5728\u8d58\u8ff0\uff0c\u5982\u679c\u8fd8\u4e0d\u660e\u767d\u53ef\u4ee5\u770b\u6211\u4ee3\u7801\n\n\u4e0a\u4ee3\u7801~\n\n```C\n#include<cstdio>\n#include<algorithm>\n#include<map>\nusing namespace std;const int N=5*1e4+10;const int M=1e5+10;\nconst int B=260;const int B2=300;int a[N];//\u7ef4\u62a4\u7684\u8868\u683c \nint cnt1[N/B+3][M/B2+3];int cnt2[N/B+3][M];int n;int m;int bi[N];int bi1[M];\nint tr1[M];int tr2[M];map <int,int> mp;int S;int Pr[M];int Pl[M];int val[M];\ninline int frk(int l,int r,int va)//\u67e5\u8be2\u5143\u7d20\u7684\u6392\u540d \n{\n    int p1=bi[l];int p2=bi[r];int ret=0;\n    if(p1==p2){for(int i=l;i<=r;i++)ret+=(a[i]<va);return ret+1;}\n    for(int i=l;bi[i]==p1;i++)ret+=(a[i]<va);\n    for(int i=r;bi[i]==p2;i--)ret+=(a[i]<va);p2--;\n    for(int i=1;i<bi1[va];i++)ret+=cnt1[p2][i];\n    for(int i=1;i<bi1[va];i++)ret-=cnt1[p1][i];\n    for(int i=va-1;bi1[i]==bi1[va];i--)ret+=cnt2[p2][i];\n    for(int i=va-1;bi1[i]==bi1[va];i--)ret-=cnt2[p1][i];return ret+1;\n}\ninline int ckth(const int& p1,const int& p2,int k)//\u8f85\u52a9\u51fd\u6570\uff0c\u67e5\u8be2kth \n{\n    int ret=B2;int cur=0;\n    for(int t=1;cur<k;ret+=B2,t++)cur+=cnt1[p2][t]-cnt1[p1][t]+tr1[t];ret-=B2;\n    for(;cur>=k;ret--)cur-=cnt2[p2][ret]-cnt2[p1][ret]+tr2[ret];return ret+1;\n}\ninline int cpre(const int& p1,const int& p2,int k)//\u8f85\u52a9\u51fd\u6570\uff0c\u67e5\u8be2\u524d\u9a71 \n{\n    for(int i=k-1;bi1[i]==bi1[k];i--)\n        if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;\n    int p;for(p=bi1[k]-1;(cnt1[p2][p]-cnt1[p1][p]+tr1[p])==0;p--);\n    for(int i=Pr[p];;i--)if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;\n}\ninline int csuf(const int& p1,const int& p2,int k)//\u8f85\u52a9\u51fd\u6570\uff0c\u67e5\u8be2\u540e\u7ee7 \n{\n    for(int i=k+1;bi1[i]==bi1[k];i++)\n        if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;\n    int p;for(p=bi1[k]+1;(cnt1[p2][p]-cnt1[p1][p]+tr1[p])==0;p++);\n    for(int i=Pl[p];;i++)if(cnt2[p2][i]-cnt2[p1][i]+tr2[i])return i;\n}\n# define ins(x) tr1[bi1[x]]++,tr2[x]++\n# define del(x) tr1[bi1[x]]--,tr2[x]--\ninline int calc(int l,int r,int k,int(*f)(const int& p1,const int& p2,int k))//\u8fd9\u91cc\u7528\u4e86\u4e2a\u51fd\u6570\u6307\u9488 \n{\n    int p1=bi[l];int p2=bi[r];int ret=0;//\u76f4\u63a5\u5904\u7406\u51fa\u533a\u95f4\u7684cnt1,cnt2\u6570\u7ec4 \n    if(p1==p2)\n    {\n        for(int i=l;i<=r;i++)ins(a[i]);ret=f(p1,p2,k);\n        for(int i=l;i<=r;i++)del(a[i]);return val[ret];\n    }\n    for(int i=l;bi[i]==p1;i++)ins(a[i]);\n    for(int i=r;bi[i]==p2;i--)ins(a[i]);ret=f(p1,p2-1,k);\n    for(int i=l;bi[i]==p1;i++)del(a[i]);\n    for(int i=r;bi[i]==p2;i--)del(a[i]);return val[ret];//\u8bb0\u5f97\u8fd8\u539f\u56de\u79bb\u6563\u5316\u4e4b\u524d\u7684\u503c \n}\ninline void modify(int pos,int y)//\u66b4\u529b\u4fee\u6539 \n{\n    int p=bi1[a[pos]];for(int i=bi[pos];i<=bi[n];i++)cnt1[i][p]--;\n    p=a[pos];for(int i=bi[pos];i<=bi[n];i++)cnt2[i][p]--;\n    p=bi1[y];for(int i=bi[pos];i<=bi[n];i++)cnt1[i][p]++;\n    for(int i=bi[pos];i<=bi[n];i++)cnt2[i][y]++;a[pos]=y;\n}\nstruct opt{int tp;int l;int r;int k;}op[N];\nint main()\n{\n    scanf(\"%d%d\",&n,&m);mp[-2147483647]=1;mp[2147483647]=1;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]),mp[a[i]]=1;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d\",&op[i].tp);\n        if(op[i].tp!=3)scanf(\"%d%d%d\",&op[i].l,&op[i].r,&op[i].k);\n        else scanf(\"%d%d\",&op[i].l,&op[i].k);if(op[i].tp!=2)mp[op[i].k]=1;\t\n    }\n    S=mp.size();map <int,int> :: iterator it,it1;//\u79bb\u6563\u5316 \n    for(it=mp.begin(),it1=it,++it1;it1!=mp.end();++it,++it1)it1->second+=it->second;\n    for(it=mp.begin();it!=mp.end();++it)val[it->second]=it->first;\n    for(int i=1;i<=n;i++)a[i]=mp[a[i]];\n    for(int i=1;i<=m;i++)if(op[i].tp!=2)op[i].k=mp[op[i].k];\n    for(int i=1;i<=n;i++)bi[i]=(i-1)/B+1;for(int i=1;i<=S;i++)bi1[i]=(i-1)/B2+1;\n    for(int i=1;i<=S;i++)Pr[bi1[i]]=i;for(int i=S;i>=1;i--)Pl[bi1[i]]=i;\n    for(int i=1;i<=n;i++)\n    {\n        int p=bi1[a[i]];for(int j=bi[i];j<=bi[n];j++)cnt1[j][p]++;\n        p=a[i];for(int j=bi[i];j<=bi[n];j++)cnt2[j][p]++;\n    }ins(1);ins(S);//\u63d2\u5165\u54e8\u5175 \n    for(int i=1;i<=m;i++)\n        switch(op[i].tp)\n        {\n            case 1:{printf(\"%d\\n\",frk(op[i].l,op[i].r,op[i].k));break;}\n            case 2:{printf(\"%d\\n\",calc(op[i].l,op[i].r,op[i].k+1,ckth));break;}\n            case 3:{modify(op[i].l,op[i].k);break;}\n            case 4:{printf(\"%d\\n\",calc(op[i].l,op[i].r,op[i].k,cpre));break;}\n            case 5:{printf(\"%d\\n\",calc(op[i].l,op[i].r,op[i].k,csuf));break;}\n        }return 0;//\u62dc\u62dc\u7a0b\u5e8f~ \n}\n\n\n```\n\n\n\n\n\n\n\n\n",
        "postTime": 1543057998,
        "uid": 56384,
        "name": "shadowice1984",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "### [\u5f00\u5934\u5c0f\u5e7f\u544a\uff1a\u81ea\u5df1\u505a\u7684\u4e00\u4e2a\u6a21\u677f\u5e93OwO](https://www.luogu.org/blog/29354/Templet)\n------------\n## \u63d0\u4f9b\u4e00\u4efd\u65e0\u6307\u9488\u7ebf\u6bb5\u6811\u5957FHQ Treap\u7684\u4ee3\u7801\n\u4e0a\u9762\u7684\u6a21\u677f\u5e93\u6709\u6211\u7684FHQ Treap\u7684\u677f\u5b50\uff0c\u5982\u679c\u548c\u60a8\u7684\u98ce\u683c\u4e0d\u4e00\u6837\u53ef\u4ee5\u770b\u4e00\u4e0b\n\n\u5927\u4f53\u601d\u8def\u5c31\u4e0d\u7528\u591a\u8bf4\u4e86\uff0c\u8ddf\u5176\u4ed6\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u64cd\u4f5c\u662f\u4e00\u6837\u7684\u3002\n\n\u6b64\u9898\u89e3\u5c31\u7ed9\u90a3\u4e9b\u65e0\u6307\u9488\u7684FHQ Treap\u515a\u53c2\u8003\uff0c\u5bf9\u62cd\u4f7f\u7528\u5427\n\n\u6ce8\u610f\uff1a\u4e0d\u5f00O2\u4f1aT\u4e00\u4e2a\u70b9\uff08#9\uff09\uff0c\u8bf7\u81ea\u884c\u5361\u5e38\u901a\u8fc7\u6216\u8005\u5f00O2 qwq\n\n------------\n# Code\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 5e4 + 5, MAXM = 1e7;\nconst int INF = 0x7fffffff;\n\nint a[MAXN];\n\nint n, m;\n\nint val[MAXM], sz[MAXM], heap[MAXM], l[MAXM], r[MAXM];\nint tot;\n\nstruct FHQ_Treap\n{\n    int root;\n\n    inline void Update(int x)\n    {\n        sz[x] = sz[l[x]] + sz[r[x]] + 1;\n\n        return;\n    }\n\n    inline int Merge(int x, int y)\n    {\n        if (!x || !y)\n            return x + y;\n        if (heap[x] < heap[y])\n            return r[x] = Merge(r[x], y), Update(x), x;\n        return l[y] = Merge(x, l[y]), Update(y), y;\n    }\n\n    inline void Split(int x, int key, int &u, int &v)\n    {\n        if (!x)\n        {\n            u = v = 0;\n            return;\n        }\n\n        if (val[x] <= key)\n            u = x, Split(r[x], key, r[u], v);\n        else\n            v = x, Split(l[x], key, u, l[v]);\n\n        Update(x);\n        return;\n    }\n\n    inline int Create(int key)\n    {\n        val[++tot] = key, heap[tot] = rand(), sz[tot] = 1;\n\n        return tot;\n    }\n\n    int x, y, z;\n\n    inline void Insert(int key)\n    {\n        Split(root, key, x, y);\n        root = Merge(x, Merge(Create(key), y));\n\n        return;\n    }\n\n    inline void Delete(int key)\n    {\n        Split(root, key, x, z);\n        Split(x, key - 1, x, y);\n        y = Merge(l[y], r[y]);\n        root = Merge(x, Merge(y, z));\n\n        return;\n    }\n\n    inline int FindRank(int key)\n    {\n        Split(root, key - 1, x, y);\n        int ans = sz[x] + 1;\n        root = Merge(x, y);\n\n        return ans;\n    }\n\n    inline void Build(int l, int r)\n    {\n        for (int i = l; i <= r; i++)\n            Insert(a[i]);\n\n        return;\n    }\n\n    inline int FindKey(int x, int rak)\n    {\n        if (rak <= sz[l[x]])\n            return FindKey(l[x], rak);\n        if (rak == sz[l[x]] + 1)\n            return val[x];\n        return FindKey(r[x], rak - sz[l[x]] - 1);\n    }\n\n    inline int Lower(int key)\n    {\n        Split(root, key - 1, x, y);\n\n        int ans;\n        if (sz[x])\n            ans = FindKey(x, sz[x]);\n        else\n            ans = -INF;\n\n        root = Merge(x, y);\n        return ans;\n    }\n\n    inline int Upper(int key)\n    {\n        Split(root, key, x, y);\n\n        int ans;\n        if (sz[y])\n            ans = FindKey(y, 1);\n        else\n            ans = INF;\n\n        root = Merge(x, y);\n        return ans;\n    }\n\n} FT[MAXN << 2];\n\n#define mid ((x + y) >> 1)\n#define lson (pst << 1)\n#define rson (pst << 1 | 1)\n\nstruct SegmentTree\n{\n    int root[MAXN << 2];\n\n    inline void Build(int x, int y, int pst)\n    {\n        FT[pst].Build(x, y);\n        if (x != y)\n            Build(x, mid, lson), Build(mid + 1, y, rson);\n\n        return;\n    }\n\n    inline int QueryRank(int x, int y, int pst, int l, int r, int key)\n    {\n        if (y < l || x > r)\n            return 0;\n        if (l <= x && y <= r)\n            return FT[pst].FindRank(key) - 1;\n\n        return QueryRank(x, mid, lson, l, r, key) + QueryRank(mid + 1, y, rson, l, r, key);\n    }\n\n    inline int QueryKey(int l, int r, int rak)\n    {\n        int x = 0, y = 1e8, ans = -1;\n        while (x <= y)\n        {\n            if (QueryRank(1, n, 1, l, r, mid) + 1 <= rak)\n                ans = mid, x = mid + 1;\n            else\n                y = mid - 1;\n        }\n\n        return ans;\n    }\n\n    inline void Update(int x, int y, int pst, int p, int k)\n    {\n        FT[pst].Delete(a[p]);\n        FT[pst].Insert(k);\n\n        if (x != y)\n        {\n            if (p <= mid)\n                Update(x, mid, lson, p, k);\n            else\n                Update(mid + 1, y, rson, p, k);\n        }\n\n        return;\n    }\n\n    inline int Lower(int x, int y, int pst, int l, int r, int k)\n    {\n        if (y < l || x > r)\n            return -INF;\n        if (l <= x && y <= r)\n            return FT[pst].Lower(k);\n        return max(Lower(x, mid, lson, l, r, k), Lower(mid + 1, y, rson, l, r, k));\n    }\n\n    inline int Upper(int x, int y, int pst, int l, int r, int k)\n    {\n        if (y < l || x > r)\n            return INF;\n        if (l <= x && y <= r)\n            return FT[pst].Upper(k);\n        return min(Upper(x, mid, lson, l, r, k), Upper(mid + 1, y, rson, l, r, k));\n    }\n\n} ST;\n\nsigned main(void)\n{\n    cin >> n >> m;\n    for (int i = 1; i <= n; i++)\n        scanf(\"%d\", a + i);\n\n    ST.Build(1, n, 1);\n\n    for (int i = 1, opt, l, r, p, k; i <= m; i++)\n    {\n        scanf(\"%d\", &opt);\n\n        if (opt == 1)\n        {\n            scanf(\"%d %d %d\", &l, &r, &k);\n            printf(\"%d\\n\", ST.QueryRank(1, n, 1, l, r, k) + 1);\n        }\n\n        if (opt == 2)\n        {\n            scanf(\"%d %d %d\", &l, &r, &k);\n            printf(\"%d\\n\", ST.QueryKey(l, r, k));\n        }\n\n        if (opt == 3)\n        {\n            scanf(\"%d %d\", &p, &k);\n            ST.Update(1, n, 1, p, k);\n            a[p] = k;\n        }\n\n        if (opt == 4)\n        {\n            scanf(\"%d %d %d\", &l, &r, &k);\n            printf(\"%d\\n\", ST.Lower(1, n, 1, l, r, k));\n        }\n\n        if (opt == 5)\n        {\n            scanf(\"%d %d %d\", &l, &r, &k);\n            printf(\"%d\\n\", ST.Upper(1, n, 1, l, r, k));\n        }\n    }\n\n    return 0;\n}\n```",
        "postTime": 1542547794,
        "uid": 29354,
        "name": "CodyTheWolf",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8fd9\u4e00\u5b9a\u662f\u9898\u89e3\u4e2d\u6700\u7b80\u6d01\u7684\u4e8c\u903c\u5e73\u8861\u6811\u4ee3\u7801\u4e86\u3002\uff08\u4e0d\u52302k\uff09\n\n\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\uff0c\u4fdd\u8bc1\u4e86\u65f6\u7a7a\u90fd\u662f\u4e24\u4e2alog\u7684\u3002\n\n\u8fd9\u91cc\u6c42\u524d\u9a71\u540e\u7ee7\u6709\u70b9\u6280\u5de7\uff1a\u6211\u7684$rnk()$\u51fd\u6570\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u5185\u5c0f\u4e8e\u7b49\u4e8e\u67d0\u4e2a\u6570\u7684\u6570\u7684\u4e2a\u6570\uff0c\u6240\u4ee5\u524d\u9a71\u7684\u6392\u540d\u5c31\u662f$rnk(x-1)$\uff0c\u540e\u7ee7\u7684\u6392\u540d\u5c31\u662f$rnk(x)+1$\uff0c\u7136\u540e$kth()$\u8fd4\u56de\u4e00\u4e2a\u533a\u95f4\u7b2ck\u5927\u7684\u6570\u5b57\u662f\u8c01\uff0c\u8fd9\u6837$kth(rnk(...))$\u5c31\u5f97\u5230\u4e86\u524d\u9a71\u540e\u7ee7\u3002\u5173\u4e8e\u662f\u5426\u6709\u524d\u9a71\u540e\u7ee7\uff0c\u76f4\u63a5\u548c\u6b63\u8d1f\u65e0\u7a77\u7684\u6392\u540d\u4f5c\u6bd4\u8f83\u5c31\u884c\u5566\u3002\n\n\u7136\u540e\u4e0a\u4ee3\u7801\u5427\uff0c\u57fa\u672c\u6ca1\u6709\u4ec0\u4e48\u9700\u8981\u6df1\u5ea6\u7406\u89e3\u7684\u4e1c\u897f\uff1a\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint Rt,n,m,Tot,tot,x,y,z,o,a[50005],rt[1000005],sm[30000005],ls[30000005],rs[30000005],Ls[1000005],Rs[1000005];\nvoid add(int &x,int l,int r,int p,int o)\n{\n\tif(o==1&&!x) x=++tot;if(x) sm[x]+=o;if(!x||l==r) return;\n\tint mid=(l+r)>>1;(p<=mid)?add(ls[x],l,mid,p,o):add(rs[x],mid+1,r,p,o);\n}\nint que(int x,int l,int r,int b,int e)\n{\n\tif(!x) return 0;if(b<=l&&r<=e) return sm[x];int mid=(l+r)>>1;\n\treturn (b<=mid?que(ls[x],l,mid,b,e):0)+(e>mid?que(rs[x],mid+1,r,b,e):0);\n}\nint rnk(int x,int l,int r,int b,int e,int L,int R)\n{\n\tif(!x) return 0;if(b<=l&&r<=e) return que(rt[x],1,n,L,R);int mid=(l+r)>>1;\n\treturn (b<=mid?rnk(Ls[x],l,mid,b,e,L,R):0)+(e>mid?rnk(Rs[x],mid+1,r,b,e,L,R):0);\n}\nint kth(int x,int l,int r,int k,int L,int R)\n{\n\tif(l==r) return l;int mid=(l+r)>>1,tmp=que(rt[Ls[x]],1,n,L,R);\n\treturn (k<=tmp)?kth(Ls[x],l,mid,k,L,R):kth(Rs[x],mid+1,r,k-tmp,L,R);\n}\nvoid upd(int &x,int l,int r,int v,int p,int o)\n{\n\tif(o==1&&!x) x=++Tot;if(x) add(rt[x],1,n,p,o);if(!x||l==r) return;\n\tint mid=(l+r)>>1;(v<=mid)?upd(Ls[x],l,mid,v,p,o):upd(Rs[x],mid+1,r,v,p,o);\n}\nint pre(int X,int Y,int Z)\n{\n\tif(rnk(Rt,0,1e8,0,Z-1,X,Y)==rnk(Rt,0,1e8,0,-1e9,X,Y)) return -2147483647;\n\treturn kth(Rt,0,1e8,rnk(Rt,0,1e8,0,Z-1,X,Y),X,Y);\n}\nint nex(int X,int Y,int Z)\n{\n\tif(rnk(Rt,0,1e8,0,Z,X,Y)==rnk(Rt,0,1e8,0,1e9,X,Y)) return 2147483647;\n\treturn kth(Rt,0,1e8,rnk(Rt,0,1e8,0,Z,X,Y)+1,X,Y);\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]),upd(Rt,0,1e8,a[i],i,1);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d\",&o);if(o==3) scanf(\"%d%d\",&x,&y);else scanf(\"%d%d%d\",&x,&y,&z);\n\t\tif(o==1) printf(\"%d\\n\",rnk(Rt,0,1e8,0,z-1,x,y)+1);\n\t\tif(o==2) printf(\"%d\\n\",kth(Rt,0,1e8,z,x,y));\n\t\tif(o==3) upd(Rt,0,1e8,a[x],x,-1),upd(Rt,0,1e8,y,x,1),a[x]=y;\n\t\tif(o==4) printf(\"%d\\n\",pre(x,y,z));\n\t\tif(o==5) printf(\"%d\\n\",nex(x,y,z));\n\t}\n}\n```\n\n",
        "postTime": 1546350853,
        "uid": 70545,
        "name": "Awar3ness",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "### 2018.3.30UPD\n\u539f\u5148\u7684\u4ee3\u7801\u5176\u5b9e\u6709bug?\uff0c\u4f46\u662fluogu\u548cbzoj\u5565\u7684\u90fd\u80fd\u8fc7\uff0c\uff0c\uff0c\uff08\u96fe\n\n\u4e3a\u4e86\u4e0d\u7978\u5bb3\u82cd\u751f(?)\u6211\u8fd8\u662f\u6539\u4e00\u4e0b\u5427\u3002\n\n\u611f\u8c22\u5927\u4f6c\u5411\u6211\u6307\u51fa\u9519\u8bef~\n\n\u9519\u8bef\u662fsplay\u7684\u65f6\u5019`rot((ch[z][0] == y) == (ch[y][0] == x) ? y : x);`\u8fd9\u53e5\uff0c\u539f\u5148\u5199\u6210\u4e86`rot((ch[z][0] == y) == (ch[y][0] == z) ? y : x);`\u3002\n\n--------\n\n\uff08\u561b\uff0c\u8fd9\u9898\u5c31\u662f\u4e2a\u5927\u529b\u6811\u5957\u6811= =\n\n\uff08\u7136\u800c\u5bf9\u4e8e\u6211\u8fd9\u79cdsplay\u90fd\u6ca1\u5199\u51e0\u9898\u7684\u4eba\u6765\u8bf4\u7b80\u76f4\u662f\u767b\u5929= =\n\n\u8fd8\u662f\u82b1\u4e86\u51e0\u5c0f\u65f6\u5199\u4e86\u8fd9\u4e2a\u4ee3\u7801qwq\u3002\n\n\u4e3b\u8981\u601d\u60f3\u5c31\u662f**\u7ebf\u6bb5\u6811+splay**\uff0c\u5f62\u8c61\u70b9\u53ef\u4ee5\u7406\u89e3\u4e3a\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9\u6302\u7740\u4e00\u68f5splay\u3002\n\n\u7b2c\u4e00\u95ee\u6c42rank\uff0c\u53ea\u9700\u6bcf\u4e00\u533a\u95f4\u6c42\u8fd9\u4e2a\u6570\u5728splay\u4e2d\u7684\u6392\u540d\u5c0f\u4e8e\u4ed6\u7684\u6570\u91cf\uff0c\u7136\u540e\u76f8\u52a0\u3002\n\n\u7b2c\u4e8c\u95ee\u6c42kth\uff0c\u8981\u5148\u4e8c\u5206\u7b54\u6848\u4e00\u6ce2\uff0c\u7136\u540e\u6c42rank\u68c0\u9a8c\u3002\n\n\u7b2c\u4e09\u95ee\uff0c\u989d\u4e0d\u662f\u95ee\u662f\u64cd\u4f5c\uff0c\u5c31\u76f4\u63a5delete+insert\u5373\u53ef\u3002\n\n\u7b2c\u56db\u95ee\u6c42\u524d\u9a71\uff0c\u53ea\u9700\u6c42\u6bcf\u4e00\u533a\u95f4\u7684splay\u4e2d\u7684\u524d\u9a71\u53d6max\u3002\n\n\u7b2c\u4e94\u95ee\u6c42\u540e\u7ee7\uff0c\u53ea\u9700\u6c42\u6bcf\u4e00\u533a\u95f4\u7684splay\u4e2d\u7684\u540e\u7ee7\u53d6min\u3002\n\n---\n\n\u6253\u5b8c\u8fd9\u9898\u771f\u662f\u4e0d\u5bb9\u6613===\n\n\u5509\u81ea\u884c\u4f53\u4f1aQwQ\n\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i, x, y) for (int i = (x); i <= (y); i ++)\n#define down(i, x, y) for (int i = (x); i >= (y); i --)\n#define mid ((l+r)/2)\n#define lc (o<<1)\n#define rc (o<<1|1)\n#define pb push_back\n#define mp make_pair\n#define PII pair<int, int>\n#define F first\n#define S second\n#define B begin()\n#define E end()\nusing namespace std;\ntypedef long long LL;\n//head\n\nconst int N = 4000010;\nconst int INF = 2147483647;\nint n, m, tot, ans, MX;\nint a[N], sz[N], cnt[N], ch[N][2], fa[N], data[N], rt[N];\n\n//=====================================================================\n//\u5e73\u8861\u6811\n\ninline void splayClear(int x)\n{\n    fa[x] = ch[x][0] = ch[x][1] = sz[x] = cnt[x] = data[x] = 0;\n}\n\ninline void pushup(int x)\n{\n    sz[x] = (ch[x][0]?sz[ch[x][0]]:0) + (ch[x][1]?sz[ch[x][1]]:0) + cnt[x];\n}\n\ninline void rot(int x)\n{\n    int y = fa[x], z = fa[y]; bool f = ch[y][1] == x;\n    ch[y][f] = ch[x][f^1]; if (ch[x][f^1]) fa[ch[x][f^1]] = y;\n    fa[x] = z; if (z) ch[z][ch[z][1] == y] = x;\n    fa[y] = x; ch[x][f^1] = y;\n    pushup(y); pushup(x);\n}\n\ninline void splay(int i, int x, int top)\n{\n    while (fa[x] != top){\n        int y = fa[x], z = fa[y];\n        if (z != top) rot((ch[z][0] == y) == (ch[y][0] == x) ? y : x);\n        rot(x);\n    }\n    if (!top) rt[i] = x;\n}\n\ninline void splayInsert(int i, int v)\n{\n    int x = rt[i];\n    if (!rt[i]){\n        rt[i] = x = ++ tot;\n        data[x] = v; sz[x] = cnt[x] = 1;\n        fa[x] = ch[x][0] = ch[x][1] = 0;\n        return;\n    } int last = 0;\n    while (1){\n        if (data[x] == v){ cnt[x] ++; pushup(last); break; }\n        last = x;\n        x = ch[x][v > data[x]];\n        if (!x){\n            x = ++ tot; data[x] = v; sz[x] = cnt[x] = 1;\n            ch[last][v > data[last]] = x;\n            fa[x] = last; ch[x][0] = ch[x][1] = 0;\n            pushup(last); break;\n        }\n    }\n    splay(i, x, 0);\n}\n\ninline int splayRank(int i, int v)//\u5728\u7b2ci\u68f5splay\u4e2d\u6c42\u6bd4v\u5c0f\u7684\u6570\u7684\u4e2a\u6570\n{\n    int x = rt[i], ret = 0;\n    while (x){\n        if (data[x] == v) return ret + ((ch[x][0])?sz[ch[x][0]]:0);\n        if (data[x] < v){\n            ret += ((ch[x][0])?sz[ch[x][0]]:0) + cnt[x];\n            x = ch[x][1];\n        } else x = ch[x][0];\n    }\n    return ret;\n}\n\ninline int splayFind(int i, int v)//\u5728\u7b2ci\u68f5splay\u4e2d\u627e\u5230\u503c\u4e3av\u7684\u8282\u70b9\u5e76\u5c06\u5b83\u63d0\u5347\u5230\u6839\n{\n    int x = rt[i];\n    while (x){\n        if (data[x] == v){ splay(i, x, 0); return x; }\n        x = ch[x][v > data[x]];\n    }\n}\n\ninline int splayPre(int i){ int x = ch[rt[i]][0]; while (ch[x][1]) x = ch[x][1]; return x; }\ninline int splaySuc(int i){ int x = ch[rt[i]][1]; while (ch[x][0]) x = ch[x][0]; return x; }\n\ninline void splayDelete(int i, int key)//\u5c06\u7b2ci\u68f5splay\u7684\u503c\u4e3akey\u7684\u5143\u7d20\u5220\u6389 \n{\n    int x = splayFind(i, key);\n    if (cnt[x] > 1){ cnt[x] --; pushup(x); return; }\n    if (!ch[x][0] && !ch[x][1]){ splayClear(rt[i]); rt[i] = 0; return; }\n    if (!ch[x][0]){\n        int y = ch[x][1]; rt[i] = y; fa[y] = 0;\n        return;\n    }\n    if (!ch[x][1]){\n        int y = ch[x][0]; rt[i] = y; fa[y] = 0;\n        return;\n    }\n    int p = splayPre(i); int oldrt = rt[i];\n    splay(i, p, 0);\n    ch[rt[i]][1] = ch[oldrt][1]; fa[ch[oldrt][1]] = rt[i];\n    splayClear(oldrt);\n    pushup(rt[i]);\n}\n\ninline int splayGetpre(int i, int v)\n{\n    int x = rt[i];\n    while (x){\n        if (data[x] < v){\n            if (ans < data[x]) ans = data[x];\n            x = ch[x][1];\n        } else x = ch[x][0];\n    } return ans;\n}\n\ninline int splayGetsuc(int i, int v)\n{\n    int x = rt[i];\n    while (x){\n        if (data[x] > v){\n            if (ans > data[x]) ans = data[x];\n            x = ch[x][0];\n        } else x = ch[x][1];\n    } return ans;\n}\n\n//=====================================================================\n//\u7ebf\u6bb5\u6811\n\ninline void segInsert(int o, int l, int r, int x, int w)\n{\n    splayInsert(o, w);\n    if (l == r) return;\n    if (x <= mid) segInsert(lc, l, mid, x, w);\n    else segInsert(rc, mid+1, r, x, w);\n}\n\ninline void segRank(int o, int l, int r, int x, int y, int v)\n{\n    if (l == x && r == y){ ans += splayRank(o, v); return; }\n    if (y <= mid) segRank(lc, l, mid, x, y, v);\n    else if (x > mid) segRank(rc, mid+1, r, x, y, v);\n    else segRank(lc, l, mid, x, mid, v), segRank(rc, mid+1, r, mid+1, y, v);\n}\n\ninline void segChange(int o, int l, int r, int x, int v)\n{\n    splayDelete(o, a[x]); splayInsert(o, v);\n    if (l == r){ a[x] = v; return; }\n    if (x <= mid) segChange(lc, l, mid, x, v);\n    else segChange(rc, mid+1, r, x, v);\n}\n\ninline void segPre(int o, int l, int r, int x, int y, int v)\n{\n    if (l == x && r == y){ ans = max(ans, splayGetpre(o, v)); return; }\n    if (y <= mid) segPre(lc, l, mid, x, y, v);\n    else if (x > mid) segPre(rc, mid+1, r, x, y, v);\n    else segPre(lc, l, mid, x, mid, v), segPre(rc, mid+1, r, mid+1, y, v);\n}\n\ninline void segSuc(int o, int l, int r, int x, int y, int v)\n{\n    if (l == x && r == y){ ans = min(ans, splayGetsuc(o, v)); return; }\n    if (y <= mid) segSuc(lc, l, mid, x, y, v);\n    else if (x > mid) segSuc(rc, mid+1, r, x, y, v);\n    else segSuc(lc, l, mid, x, mid, v), segSuc(rc, mid+1, r, mid+1, y, v);\n}\n\n//=====================================================================\n//\u7b2c\u4e8c\u95ee\n\ninline int getKth(int x, int y, int k)\n{\n    int ll = 0, rr = MX+1, mm;\n    while (ll < rr){\n        mm = (ll + rr) / 2;\n        ans = 0; segRank(1, 1, n, x, y, mm);\n        if (ans < k) ll = mm+1;\n        else rr = mm;\n    }\n    return ll-1;\n}\n\n//=====================================================================\n//main\n\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    rep(i, 1, n){\n        scanf(\"%d\", &a[i]);\n        segInsert(1, 1, n, i, a[i]);\n        MX = max(MX, a[i]);\n    }\n    while (m --){\n        int opt, x, y, z; scanf(\"%d%d%d\", &opt, &x, &y);\n        if (opt == 1) scanf(\"%d\", &z), ans = 0, segRank(1, 1, n, x, y, z), printf(\"%d\\n\", ans+1);\n        else if (opt == 2) scanf(\"%d\", &z), printf(\"%d\\n\", getKth(x, y, z));\n        else if (opt == 3) segChange(1, 1, n, x, y);\n        else if (opt == 4) scanf(\"%d\", &z), ans = -INF, segPre(1, 1, n, x, y, z), printf(\"%d\\n\", ans);\n        else scanf(\"%d\", &z), ans = INF, segSuc(1, 1, n, x, y, z), printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```",
        "postTime": 1513266702,
        "uid": 19722,
        "name": "fy0123",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "emm\u3002\u3002\u3002\u9898\u76ee\u540d\u5199\u4e86\u4e2a\u5e73\u8861\u6811\uff0c\u4f46\u662f\u8fd9\u9053\u9898\u7684\u7406\u8bba\u590d\u6742\u5ea6\u6700\u4f18\u89e3\u5e94\u8be5\u8fd8\u662f\u6811\u72b6\u6570\u7ec4\u5957\u503c\u57df\u7ebf\u6bb5\u6811\u5427\u3002\n\n\u5c31\u50cf[dynamic ranking](https://www.luogu.org/problemnew/show/P2617)\u90a3\u6837\uff08\u849f\u84bb\u7684[Sol](https://www.cnblogs.com/flashhu/p/8324297.html),\u653e\u4e00\u4e2alink\u9a97\u8bbf\u95ee\u91cf233\uff09\n\n\u6240\u6709\u7684\u503c\uff08\u5305\u62ec\u521d\u59cba\u6570\u7ec4\uff0c\u64cd\u4f5c1\u30013\u30014\u30015\u7684k\uff09\u5168\u90e8\u5148\u4e22\u8fdb\u53bb\u79bb\u6563\u5316\n\n\u5bf9\u4e8e1\u64cd\u4f5c\u67e5\u6bd4\u5b83\u5c0f\u7684\u6570\uff0c\u6311log\u68f5\u7ebf\u6bb5\u6811\uff0c\u627e\u533a\u95f4\u5c0f\u4e8e\u8fd9\u4e2a\u6570\u7684\u4e2a\u6570+1\uff0c\u8fd9\u4e2a\u8fd8\u6bd4\u8f83\u597d\u50cf\n\n\u64cd\u4f5c2\u5c31\u662fdynamic ranking\uff0clog\u68f5\u7ebf\u6bb5\u6811\u4e00\u8d77\u52a0\u51cf\uff0c\u50cf\u9759\u6001\u4e3b\u5e2d\u6811\u6c42\u7b2ck\u5c0f\u4e00\u6837\u8df3\uff0c\u64cd\u4f5c3 dynamic ranking\u91cc\u4e5f\u6709\n\n\u64cd\u4f5c4\u5148\u6c42\u5c0f\u4e8e\u8fd9\u4e2a\u6570\u7684\u4e2a\u6570\uff0c\u90a3\u4e48\u524d\u9a71\u7684\u6392\u540d\u5c31\u7b49\u4e8e\u8fd9\u4e2a\u4e2a\u6570\uff0c\u6ce8\u610f\u7279\u52240\u5c31\u597d\u4e86\u3002\n\n\u64cd\u4f5c5\u4e5f\u662f\u5148\u6c42\u6392\u540d\u518d\u53bb\u627e\u8fd9\u4e2a\u6570\uff0c\u6392\u540d\u662f\u5c0f\u4e8e\u4e14\u7b49\u4e8e\u8fd9\u4e2a\u6570\u7684\u4e2a\u6570\uff08\u7b49\u4e8e\u67e5\u5c0f\u4e8e\u8fd9\u4e2a\u6570\u5728\u503c\u57df\u91cc\u52a0+1\u7684\u6570\u6392\u540d\uff09\n\n\u62fc\u547d\u5361\u5e38\uff08\u5c0f\u6280\u5de7\uff0c\u53d1\u73b0\u5f53\u524d\u8df3\u5230\u7684\u70b9size\u5df2\u7ecf\u4e3a0\u4e86\u5c31\u4e0d\u7528\u518d\u5f80\u4e0b\u8df3\u4e86\uff09\uff0c\u7136\u800c\u5e38\u6570\u8fd8\u662f\u4e11\u3002\u3002\u3002\u8bf4\u4e0d\u5b9a\u5e94\u8be5\u7834\u6389\u975e\u9012\u5f52\u7248\u8dd1\u7684\u6bd4\u9012\u5f52\u7248\u591a\u591a\u5c11\u5c11\u5feb\u4e00\u70b9\u7684\u8c23\u8a00\u4e86\uff1f\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define RG register\n#define R RG int\n#define II inline int\n#define IV inline void\n#define gc          if(++pi==iend)fread(pi=ibuf,1,SZ,stdin)\n#define pc(C) *po=C;if(++po==oend)fwrite(po=obuf,1,SZ,stdout)\n#define Q b+1,b+L+1\n#define lb(X) X=lower_bound(Q,X)-b\nusing namespace std;\nconst int SZ=1<<20,N=50009,M=5000009,INF=2147483647;//\u5361\u4e86\u7a7a\u95f4\uff0cM\u6ca1\u5230Nlog^2\nchar ibuf[SZ],obuf[SZ],*pi=ibuf+SZ-1,*po=obuf;\nconst char*iend=ibuf+SZ,*oend=obuf+SZ;\nIV in(R&x){\n    gc;\n    while(*pi<'-')gc;\n    x=*pi&15;gc;\n    while(*pi>'-'){x*=10;x+=*pi&15;gc;}\n}\nIV out(R x){\n    if(x>9)out(x/10);\n    pc(x%10|'0');\n}\nint n,L,P,a[N],b[N<<1],op[N],ql[N],qr[N],qk[N];\nint rt[N],lc[M],rc[M],s[M],ra[20],rs[20];\nIV upd(R p,R k,R v){//\u66f4\u65b0\n    for(R u,l,r,m,i=p;i<=n;i+=i&-i){\n        if(!rt[i])rt[i]=++P;u=rt[i];l=1;r=L;\n        while(l^r){\n            s[u]+=v;m=(l+r)>>1;\n            if(k<=m){r=m;if(!lc[u])lc[u]=++P;u=lc[u];}\n            else  {l=m+1;if(!rc[u])rc[u]=++P;u=rc[u];}\n        }\n        s[u]+=v;\n    }\n}\nII kth(R p,R k){//\u6c42\u7b2ck\u5c0f\u7684\u503c\n    R i,l=1,r=L,m,sum,pa=0,ps=0;\n    for(i=qr[p]  ;i;i-=i&-i)ra[++pa]=rt[i];\n    for(i=ql[p]-1;i;i-=i&-i)rs[++ps]=rt[i];\n    while(l^r){\n        sum=0;m=(l+r)>>1;\n        for(i=1;i<=pa;++i)sum+=s[lc[ra[i]]];\n        for(i=1;i<=ps;++i)sum-=s[lc[rs[i]]];\n        if(k<=sum){\n            r=m;\n            for(i=1,p=pa,pa=0;i<=p;++i)ra[++pa]=lc[ra[i]];\n            for(i=1,p=ps,ps=0;i<=p;++i)rs[++ps]=lc[rs[i]];\n        }\n        else{\n            l=m+1;k-=sum;\n            for(i=1,p=pa,pa=0;i<=p;++i)ra[++pa]=rc[ra[i]];\n            for(i=1,p=ps,ps=0;i<=p;++i)rs[++ps]=rc[rs[i]];\n        }\n    }\n    return b[l];\n}\nII rank(R p,R x){//\u6c42\u79bb\u6563\u5316\u540e\u7684\u503c\u7684\u6392\u540d\uff08\u4ece0\u8ba1\uff0c\u4e5f\u5c31\u662f\u5c0f\u4e8e\u7b49\u4e8e\u503c\u7684\u6570\u7684\u4e2a\u6570\uff09\n    R i,u,l,r,m,k=0;\n    for(i=qr[p];i;i-=i&-i){\n        u=rt[i];l=1;r=L;\n        while(s[u]&&l^r){\n            m=(l+r)>>1;\n            if(x<=m)           r=m,u=lc[u];\n            else k+=s[lc[u]],l=m+1,u=rc[u];\n        }\n    }\n    for(i=ql[p]-1;i;i-=i&-i){\n        u=rt[i];l=1;r=L;\n        while(s[u]&&l^r){\n            m=(l+r)>>1;\n            if(x<=m)           r=m,u=lc[u];\n            else k-=s[lc[u]],l=m+1,u=rc[u];\n        }\n    }\n    return k;\n}\nint main(){\n    R m,i,rk;\n    in(n);in(m);L=n;\n    for(i=1;i<=n;++i)in(a[i]);\n    memcpy(b,a,(n+1)<<2);\n    for(i=1;i<=m;++i){\n        in(op[i]);//\u5148\u5b58\u8d77\u6765\n        in(ql[i]);if(op[i]!=3)in(qr[i]);\n        in(qk[i]);if(op[i]!=2)b[++L]=qk[i];\n    }\n    b[++L]=INF;sort(Q);L=unique(Q)-b-1;\n    for(i=1;i<=n;++i)\n        upd(i,lb(a[i]),1);\n    for(i=1;i<=m;++i){\n    \tif(op[i]!=2)lb(qk[i]);\n        switch(op[i]){\n            case 1:out(rank(i,qk[i])+1);pc('\\n');break;\n            case 2:out(kth(i,qk[i]));pc('\\n');break;\n            case 3:upd(ql[i],a[ql[i]],-1);\n                upd(ql[i],a[ql[i]]=qk[i],1);break;\n            case 4:rk=rank(i,qk[i]);\n                if(rk)out(kth(i,rk));\n                else{pc('-');out(INF);}pc('\\n');break;\n            case 5:rk=rank(i,qk[i]+1);\n                out(rk>qr[i]-ql[i]?INF:kth(i,rk+1));pc('\\n');\n        }\n    }\n    fwrite(obuf,1,po-obuf,stdout);\n    return 0;\n}\n```",
        "postTime": 1523368730,
        "uid": 61325,
        "name": "FlashHu",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "~~\u7ebf\u6bb5\u6811\u5957$Splay$~~\n\n\u533a\u522b\u4e8e\u7ebf\u6bb5\u6811\uff0c\u8fd9\u9053\u9898\u8981\u6c42\u7edf\u8ba1\u533a\u95f4$k$\u5927\uff0c\u533a\u95f4\u67d0\u4e2a\u6570\u7684\u524d\u9a71\u4ec0\u4e48\u7684\u3002\n\n\u6240\u4ee5\u7528\u6811\u5957\u6811\uff0c\u6211\u4eec\u5bf9\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u68f5\u5e73\u8861\u6811\u3002\n\n\u5bf9\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u8bb0\u4e00\u4e2a$root$\uff0c\u8868\u793a\u8fd9\u4e2a\u70b9\u5bf9\u5e94\u7684\u5e73\u8861\u6811\u7684\u6839\u8282\u70b9\u3002\n\n\u6211\u4eec\u770b\u770b$5$\u4e2a\u64cd\u4f5c\u600e\u4e48\u89e3\u51b3\u7684\uff1f\n\n\u64cd\u4f5c$1:$\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u53bb\u627e\u533a\u95f4\uff0c\u9047\u5230\u67d0\u4e2a\u5408\u6cd5\u533a\u95f4\u540e\uff0c\u628a\u8fd9\u4e2a\u533a\u95f4\u5185\u6bd4\u6570$x$\u5c0f\u7684\u6570\u7edf\u8ba1\u51fa\u6765\uff0c\u6700\u540e\u8f93\u51fa\u5176$+1$\u5c31\u662f\u6392\u540d\u4e86\n\n\u64cd\u4f5c$2:$\u6211\u4eec$2$\u5206\u4e00\u4e2a\u503c\uff0c\u7136\u540e\u5bf9\u8fd9\u4e2a\u503c\u8dd1\u64cd\u4f5c$1$\u3002\u4ee5\u6b64\u6cd5\u5224\u65ad\u8fd9\u4e2a\u503c\u662f\u5426\u6ee1\u8db3\u6392\u540d\u4e3a$k$\n\n\u64cd\u4f5c$3:$\u5047\u8bbe\u6211\u4eec\u8981\u628a$wh$\u4e0a\u7684\u70b9\u4ece$a[wh]$\u6539\u4e3a$k$\uff0c\u90a3\u4e48\u5c31\u5728\u7ebf\u6bb5\u6811\u4e0a\u627e\uff0c\u6bcf\u9047\u5230\u4e00\u4e2a\u8282\u70b9\uff0c\u90fd\u5728\u5176\u5bf9\u5e94\u7684\u5e73\u8861\u6811\u4e2d\u5220\u6389$a[wh]$\uff0c\u7136\u540e\u63d2\u5165$k$\uff0c\u6700\u540e\u5f53\u533a\u95f4\u6ee1\u8db3$l == r == wh$\u65f6\u5c31\u628a$a[wh]$\u6539\u4e3a$k$\n\n\u64cd\u4f5c$4:$\u5728\u7ebf\u6bb5\u6811\u4e0a\u4f9d\u6b21\u627e\u8282\u70b9\uff0c\u6bcf\u6b21\u627e\u5230\u5408\u6cd5\u533a\u95f4\u540e\u7528$Splay$\u6c42\u524d\u9a71\uff0c\u5bf9\u6240\u6709\u524d\u9a71\u53d6$max$\n\n\u64cd\u4f5c$5:$\u5728\u7ebf\u6bb5\u6811\u4e0a\u4f9d\u6b21\u627e\u8282\u70b9\uff0c\u6bcf\u6b21\u627e\u5230\u5408\u6cd5\u533a\u95f4\u540e\u7528$Splay$\u6c42\u540e\u7ee7\uff0c\u5bf9\u6240\u6709\u524d\u9a71\u53d6$min$\n\n\u4ee3\u7801\u732e\u4e0a\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint read(){\n\tchar cc = getchar(); int cn = 0, flus = 1;\n\twhile(cc < '0' || cc > '9'){\n    \tif(cc == '-') flus = -flus;\n\t\tcc = getchar();\n\t}\n\twhile(cc >= '0' && cc <= '9')\n\t    cn = cn * 10 + cc - '0', cc = getchar();\n\treturn cn * flus;\n}\nconst int N = 5e4 + 5;\n#define ls(x) t[x].son[0]\n#define rs(x) t[x].son[1]\n#define inf 2147483647\n#define il inline\nstruct Splay{\n\tint size, tot, val, son[2], fa; \n}t[N * 50];\nstruct Seg_tree{\n\tint l, r, root;\n}tr[N * 4];\nint a[N], n, m, cnt;\n//Splay\n\nil void pushup(int x) {\n\tt[x].size = t[ls(x)].size + t[rs(x)].size + t[x].tot;\n} \nil void turn(int x) {\n\tint f = t[x].fa, ff = t[f].fa, qwq = (t[f].son[1] == x);\n\tt[ff].son[(t[ff].son[1] == f)] = x, t[x].fa = ff;\n\tt[t[x].son[qwq ^ 1]].fa = f; t[f].son[qwq] = t[x].son[qwq ^ 1];\n\tt[x].son[qwq ^ 1] = f; t[f].fa = x;\n\tpushup(f); pushup(x);\n}\nil void Splay( int x, int goal, int node ) {\n\twhile( t[x].fa != goal ) {\n\t\tint f = t[x].fa, ff = t[f].fa;\n\t\tif(ff != goal) (t[ff].son[1] == f) ^ (t[f].son[1] == x) ? turn(f) : turn(x);\n\t\tturn(x); \n\t}\n\tif( goal == 0 ) tr[node].root = x;\n}\nil int init( int v, int fa ) {\n\tt[++cnt].val = v, t[cnt].fa = fa, t[cnt].tot = 1;\n\tpushup(cnt); return cnt;\n}\nil void insert( int x, int node ) {\n\tint u = tr[node].root, fa = 0;\n\tif(!u) { u = init(x, 0), tr[node].root = u; return ;}\n\twhile( u && (t[u].val != x) ) fa = u, u = t[u].son[t[u].val < x];\n\tif(x == t[u].val && u) t[u].tot ++;\n\telse {\n\t\tu = init(x, fa);\n\t\tif(fa) t[fa].son[t[fa].val < x] = u;\n\t}\n\tSplay( u, 0, node ); \n}\nil void find( int x, int node ) {\n\tint u = tr[node].root;  if(!u) return ;\n\twhile( t[u].son[t[u].val < x] && t[u].val != x) \n\t\tu = t[u].son[t[u].val < x];\n\tSplay( u, 0, node );\n}\nil int Next( int x, int qwq, int node ) {//qwq\u4e3a0\uff0c\u540e\u7ee7\uff0c1\u5219\u524d\u9a71 \n\tfind(x, node); int u = tr[node].root;\n\tif((qwq && t[u].val < x) || (!qwq && t[u].val > x)) return u;\n\tu = t[u].son[qwq ^ 1];\n\twhile(t[u].son[qwq]) u = t[u].son[qwq];\n\treturn u;\n}\nil void Del( int x, int node ) {\n\tint u = tr[node].root, pre = Next(x, 1, node), nxt = Next(x, 0, node);\n\tSplay(nxt, 0, node); Splay(pre, nxt, node);\n\tint wh = t[pre].son[1];\n\tif(t[wh].tot > 1) -- t[wh].tot, Splay(wh, 0, node);\n\telse t[pre].son[1] = 0;\n\tpushup(pre); \n}\n//seg_tree\nil void build( int node, int l, int r ) {\n\tinsert(inf, node); insert(-inf, node);\n\tif(l == r) return ;\n\tint mid = (l + r) >> 1;\n\tbuild(node * 2, l, mid ); build(node * 2 + 1, mid + 1, r);\n}\nil void seg_insert( int node, int l, int r, int k, int val ) {\n\tint mid = (l + r) >> 1;\n\tinsert(val, node);\n\tif(l == r) return ;\n\tif( mid >= k )  seg_insert(node * 2, l, mid, k, val);\n\telse seg_insert(node * 2 + 1, mid + 1, r, k, val);\n} \nil int seg_rank( int node, int l, int r, int k, int ql, int qr ) {\n\tif(l > qr || r < ql) return 0;\n\tif(l >= ql && r <= qr) {\n\t\tfind( k, node );  int u = tr[node].root;\n\t\tif( t[u].val >= k ) return t[ls(u)].size - 1;\n\t\telse return t[ls(u)].size + t[u].tot - 1; \n\t}\n\tint mid = (l + r) >> 1;\n\treturn seg_rank(node * 2, l, mid, k, ql, qr) + seg_rank(node * 2 + 1, mid + 1, r, k, ql, qr);\n}\nil void seg_update(int node, int l, int r, int wh, int val) {\n\tDel(a[wh], node), insert(val, node);\n\tif ( l == r && l == wh )  { a[wh] = val; return ; }\n\tint mid = ( l + r ) >> 1;\n\tif(mid >= wh) seg_update(node * 2, l, mid, wh, val);\n\telse seg_update(node * 2 + 1, mid + 1, r, wh, val);\n}\nil int seg_Pre(int node, int l, int r, int ql, int qr, int k) { \n\tif(l > qr || r < ql) return -inf;\n\tif(l >= ql && r <= qr)  return t[Next(k, 1, node)].val;\n\tint mid = (l + r) >> 1;\n\treturn max(seg_Pre(node * 2, l, mid, ql, qr, k), seg_Pre(node * 2 + 1, mid + 1, r, ql, qr, k));\n}\nil int seg_Nxt(int node, int l, int r, int ql, int qr, int k) {\n\tif(l > qr || r < ql) return inf;\n\tif(l >= ql && r <= qr)  return t[Next(k, 0, node)].val;\n\tint mid = (l + r) >> 1;\n\treturn min(seg_Nxt(node * 2, l, mid, ql, qr, k), seg_Nxt(node * 2 + 1, mid + 1, r, ql, qr, k));\n}\nil int seg_Kth(int ql, int qr, int k) {\n\tint l = 0, r = 1e8, mid, check, ans;\n\twhile(l <= r) {\n\t\tmid = (l + r) >> 1;\n\t\tcheck = seg_rank(1, 1, n, mid, ql, qr) + 1;\n\t\tif( check > k ) r = mid - 1;\n\t\telse l = mid + 1, ans = mid;\n\t}\n\treturn ans;\n}\nsigned main()\n{\n\tn = read(), m = read(); \n\tbuild(1, 1, n); int opt, l, r, k;\n\tfor( int i = 1; i <= n; ++ i )  a[i] = read(), seg_insert(1, 1, n, i, a[i]);\n\tfor( int i = 1; i <= m; ++ i ) {\n\t\topt = read(), l = read(), r = read();\n\t\tif(opt == 1)  k = read(), printf(\"%d\\n\", seg_rank(1, 1, n, k, l, r) + 1);\n\t\tif(opt == 2)  k = read(), printf(\"%d\\n\", seg_Kth(l, r, k));\n\t\tif(opt == 3)  seg_update(1, 1, n, l, r);\n\t\tif(opt == 4)  k = read(), printf(\"%d\\n\", seg_Pre(1, 1, n, l, r, k));\n\t\tif(opt == 5)  k = read(), printf(\"%d\\n\", seg_Nxt(1, 1, n, l, r, k));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1550936219,
        "uid": 30036,
        "name": "Soulist",
        "ccfLevel": 9,
        "title": "P3380\u6811\u5957\u6811"
    },
    {
        "content": "# P3380\uff08\u6811\u72b6\u6570\u7ec4\u5957\u6743\u503c\u6811\u5199\u6cd5\uff09\n\u76f4\u63a5\u770b\u6807\u9898\u5427qaq\uff0c\u8fd9\u4e0d\u662f\u672c\u9898\u7684\u6700\u4f18\u505a\u6cd5~~\u5176\u5b9e\u6211\u89c9\u5f97\u662f~~\n\n\u5176\u5b9e\u6211\u559c\u6b22\u53eb\u5b83\u52a8\u6001\u4e3b\u5e2d\u6811~~\u4f46\u662f\u6709\u4e9b\u5927\u4f6c\u4e0d\u559c\u6b22qaq~~\n\n~~\u4e3a\u4ec0\u4e48\u6211\u611f\u89c9\u540e\u9762\u7684\u52a8\u6001\u4e3b\u5e2d\u6811\u9898\u89e3\u5199\u7684\u4e0d\u662f\u5f88\u7b80\u6d01qaq~~\n\n## \u5207\u5165\u6b63\u9898\n\u5728\u8fd9\u513f\u9ed8\u8ba4\u5404\u4f4d\u5df2\u7ecf\u5b66\u8fc7\u9759\u6001\u4e3b\u5e2d\u6811\u4e86\u3002\n\n\uff08\u6ca1\u5b66\u8fc7\u7684\u8bf7\u8df3\u8f6c[P3834](https://www.luogu.com.cn/problem/P3834)\uff09\n\n\u5728\u9759\u6001\u4e3b\u5e2d\u6811\u4e2d\uff0c\u6211\u4eec\u4e86\u89e3\u4e86\u7ebf\u6bb5\u6811\u7684\u524d\u7f00\u548c\u64cd\u4f5c\uff0c\n\n\u4ee5\u53ca\u7528\u4e00\u4e2a\u503c\u51fa\u73b0\u7684\u6b21\u6570\u6765\u5f00\u7ebf\u6bb5\u6811\u7684\u795e\u5947\u64cd\u4f5c\u3002\n\n\u90a3\u4e48\u5176\u5b9e\u6211\u4eec\u7684\u95ee\u9898\u53ea\u662f\u5728\u4e8e\u4fee\u6539\u800c\u5df2\u3002\n\n\u8003\u8651\u5230\u7ebf\u6bb5\u6811\u53ef\u4ee5\u524d\u7f00\u548c\uff0c\n\n\u90a3\u4e48\u5176\u5b9e\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528\u4e00\u4e9b\u7ef4\u62a4\u524d\u7f00\u548c\u7684\u795e\u5947\u64cd\u4f5c\u6765\u7ef4\u62a4\u7ebf\u6bb5\u6811\u7684\u524d\u7f00\u548c\uff0c\n\n\u6bd4\u5982\uff0c\u5957\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u6216\u8005\u7ebf\u6bb5\u6811\u4ec0\u4e48\u7684\u3002\n\n\u90a3\u4e48\uff0c\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784\u7684\u6838\u5fc3\u601d\u8def\u5c31\u8fd9\u6837\u5b50\u5566~\n\n\uff08\u6ce8\uff1a\u4e0b\u6587\u7684$len$\u662f\u79bb\u6563\u5316\u4e4b\u540e\u7684\u6570\u7684\u4e2a\u6570\uff09\n## \u4fee\u6539\n\u5728\u8fd9\u91cc\u6211\u4f7f\u7528\u7684\u662f\u6811\u72b6\u6570\u7ec4\u5957\u4e3b\u5e2d\u6811\u3002\n\n\u6211\u4eec\u90fd\u719f\u6089\u6811\u72b6\u6570\u7ec4\u7684\u4fee\u6539\u65b9\u5f0f\uff0c\n\n\u90a3\u4e48\u6211\u4eec\u53ea\u8981\u5728\u5916\u5c42\u627e\u5230\u9700\u8981\u4fee\u6539\u90a3\u51e0\u68f5\u6743\u503c\u6811\uff08\u6216\u8005\u8bf4\u662f\u4e3b\u5e2d\u6811\uff09\u3002\n\n\u6bd4\u5982\u6211\u4eec\u8981\u4fee\u6539$x$\u53f7\u8282\u70b9\uff0c\n\n\u90a3\u4e48\u6839\u636e\u6811\u72b6\u6570\u7ec4\u7684\u6027\u8d28\uff0c\n\n\u6211\u4eec\u53ea\u9700\u8981\u6bcf\u6b21\u52a0\u4e0a$lowbit(x)$\u5c31\u884c\u5566\u3002\n\n\u7136\u540e\u8fdb\u5165\u8981\u4fee\u6539\u7684\u4e3b\u5e2d\u6811\uff0c\n\n\u518d\u6309\u7167\u4e3b\u5e2d\u6811\u4fee\u6539\u7684\u64cd\u4f5c\u6539\u5c31\u7ed3\u675f\u5566~\n\ncode\uff1a\n```cpp\nint lb(int x){\n\treturn x&(-x);\n}\nvoid pushup(int o){\n\tt[o].v=t[t[o].ls].v+t[t[o].rs].v;\n}\nvoid change(int &o,int l,int r,int k,int v){\n\tif(!o) o=++tot;\n\tif(l==r){\n\t\tt[o].v+=v;\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tif(k<=mid) change(t[o].ls,l,mid,k,v);\n\telse change(t[o].rs,mid+1,r,k,v);\n\tpushup(o);\n}//\u4e3b\u5e2d\u6811\u4fee\u6539\nvoid add(int o,int v){\n\tfor(int i=o;i<=n;i+=lb(i)) change(rt[i],1,len,a[o],v);\n} //\u6811\u72b6\u6570\u7ec4\u67e5\u627e\u4fee\u6539\u7684\u6811\n```\n## \u67e5\u8be2\u7b2ck\u5c0f\n\u6211\u4eec\u4e3b\u5e2d\u6811\u7684\u64cd\u4f5c\uff0c\n\n\u5c31\u662f\u5c06\u7b2c$r$\u68f5\u6811\u51cf\u53bb\u7b2c$l-1$\u68f5\u6811\u3002\n\n\u5f97\u51fa\u6211\u4eec\u9700\u8981\u67e5\u8be2\u7684\u6811\uff0c\n\n\u90a3\u4e48\u8fd9\u8fb9\u4e5f\u662f\u4e00\u6837\u7684\u3002\n\n\u5047\u8bbe\u4f7f\u7528\u6811\u72b6\u6570\u7ec4\u627e\u5230\u6211\u4eec\u8981\u67e5\u8be2\u7684$r_1,r_2 \\ldots r_k$\u548c$l_1,l_2 \\ldots l_k$\uff0c\n\n\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u5c06\u6240\u6709\u7684$r$\u6811\u51cf\u53bb\u6240\u6709\u7684$l$\u6811\uff0c\n\n\u5c31\u80fd\u5f97\u51fa\u6211\u4eec\u8981\u7684\u6811\u4e86\u3002\n\n\u7b2ck\u5c0f\u67e5\u8be2\uff0cget~\n\ncode\uff1a\n```cpp\nint query_num(int l,int r,int k){\n\tif(l==r) {\n\t\treturn l;\n\t}\n\tint mid=l+r>>1,sum=0;\n\tfor(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v;\n\tfor(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v;\n   \t//\u540c\u4e3b\u5e2d\u6811\uff0c\u6240\u6709\u6709\u8282\u70b9\u7684\u6811\u51cf\u53bb\u6240\u6709\u5de6\u8282\u70b9\u7684\u6811\n\tif(k<=sum){\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;\n\t\treturn query_num(l,mid,k);\n\t}\n\telse{\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].rs;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].rs;\n\t\treturn query_num(mid+1,r,k-sum);\n\t}\n    \t//\u6ce8\u610f\u8981\u6240\u6709\u7684\u8282\u70b9\u4e00\u8d77\u53d8\u6210\u5b50\u8282\u70b9\n}\nint find_num(int l,int r,int k){\n\tcnt=num=0;\n\tfor(int i=r;i;i-=lb(i)){\n\t\ttem[++cnt]=rt[i];\n\t}//\u8fd9\u4e9b\u662f\u53f3\u7aef\u70b9\u5206\u51fa\u6765\u7684\u6811\n\tfor(int i=l-1;i;i-=lb(i)){\n\t\ttmp[++num]=rt[i];\n\t}//\u8fd9\u4e9b\u662f\u5de6\u7aef\u70b9\u5206\u51fa\u6765\u7684\u6811\uff0c\u6ce8\u610fl-1\n\treturn query_num(1,len,k);\n} //\u5148\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u51fa\u9700\u8981\u67e5\u7684\u6811\n```\n## \u67e5\u8be2\u6392\u540d\n\u8fd9\u4e00\u6b65\u64cd\u4f5c\u5c31\u663e\u5f97\u6bd4\u8f83\u7b80\u5355\u3002\n\n\u6211\u4eec\u53ea\u8981\u628a\u4e00\u6bb5\u533a\u95f4\u4e2d\u5c0f\u4e8e$k$\u7684\u6570\u7684\u4e2a\u6570\u52a0\u8d77\u6765\u518d\u52a0\u4e2a\u4e00\u5c31\u884c\u5566\u3002\n\n\u5177\u4f53\u7684\u64cd\u4f5c\u540c\u67e5\u8be2\u7b2ck\u5c0f\uff0c\n\n\u5148\u9884\u5904\u7406\u51fa\u9700\u8981\u627e\u7684\u6811\uff0c\n\n\u4e0d\u540c\u7684\u662f\u6211\u4eec\u53ea\u9700\u8981\u5728\u6bcf\u68f5\u6811\u4e2d\u6c42\u4e00\u4e2a\u533a\u95f4\u548c\u5c31\u884c\u5566~\n\ncode\uff1a\n```cpp\nint query_rnk(int l,int r,int k){\n\tif(l==r) {\n\t\treturn 0;//\u6ce8\u610f\u8fd9\u91cc\u8981return 0\uff0c\u56e0\u4e3a\u7b49\u4e8ek\u662f\u4e0d\u80fd\u7b97\u8fdb\u53bb\u7684\n\t}\n\tint mid=l+r>>1,sum=0;\n\tif(k<=mid){\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;\n\t\treturn query_rnk(l,mid,k);\n\t}\n\telse{\n\t\tfor(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v,tem[i]=t[tem[i]].rs;\n\t\tfor(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v,tmp[i]=t[tmp[i]].rs;\n\t\treturn sum+query_rnk(mid+1,r,k);\n\t}\n}//\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7684\u6c42\u548c\u64cd\u4f5c\uff0c\u6c42\u51fa1-k-1\u4f4d\u7f6e\u7684\u548c\n//\u5176\u5b9e\u4e5f\u53ef\u4ee5\u6bcf\u68f5\u6811\u67e5\u4e00\u6b21\uff0c\u5728\u8fd9\u91cc\u6211\u559c\u6b22\u6240\u6709\u7684\u6811\u4e00\u8d77\u67e5\nint find_rnk(int l,int r,int k){\n\tcnt=num=0;\n\tfor(int i=r;i;i-=lb(i)){\n\t\ttem[++cnt]=rt[i];\n\t}\n\tfor(int i=l-1;i;i-=lb(i)){\n\t\ttmp[++num]=rt[i];\n\t}\n\treturn query_rnk(1,len,k)+1;\n    //\u4e0d\u8981\u5fd8\u8bb0\u52a01qaq\n}\n```\n## \u67e5\u8be2\u524d\u9a71\n\u5176\u5b9e\uff0c\u8fd9\u4e2a\u64cd\u4f5c\u6211\u4eec\u53ef\u4ee5\u7528\u4e0a\u9762\u7684\u4e24\u4e2a\u64cd\u4f5c\u6765\u5b8c\u6210\u3002\n\n\u5047\u8bbe\u8fd9\u4e2a\u6570\u7684\u6392\u540d\u662f$rk$\uff0c\u90a3\u4e48$rk-1$\u540d\u7684\u6570\uff0c\u662f\u4e0d\u662f\u5c31\u662f\u5b83\u7684\u524d\u9a71\u5462~\n\n\u5f53\u7136\u6709\u4e00\u4e2a\u7279\u5224\uff1a\n\n\u5047\u8bbe$rk$\u5df2\u7ecf\u7b49\u4e8e$1$\u4e86\uff0c\u90a3\u4e48\u5c31\u662f\u4e0d\u5b58\u5728\u524d\u9a71\u7684\u60c5\u51b5\n\n\u90a3\u4e48\u524d\u9a71\u5c31\u8fd9\u4e48\u7ed3\u675f\u5566~\n\ncode\uff1a\n```cpp\nint find_pri(int l,int r,int k){\n\tint rk=find_rnk(l,r,k)-1;\n\tif(rk==0) return 0;\n    \t//\u56e0\u4e3a\u6211\u524d\u9762\u51cf\u4e00\u5df2\u7ecf\u51cf\u597d\u4e86\uff0c\u6240\u4ee5\u7279\u5224\u7684\u65f6\u5019\u5224\u662f\u5426\u7b49\u4e8e0\n\treturn find_num(l,r,rk);\n}\n```\n## \u67e5\u8be2\u540e\u7ee7\n\u5176\u5b9e\u662f\u4e00\u4e2a\u9053\u7406\u5462~\n\n\u4f46\u662f\u8fd9\u91cc\u5c31\u6d89\u53ca\u5230\u4e00\u4e2a\u6392\u540d\u662f\u591a\u5c11\u7684\u95ee\u9898\u3002\n\n\u5982\u679c\u5047\u8bbe\u540e\u7ee7\u7684\u6392\u540d\u662f$rk$\uff0c\n\n\u90a3\u4e48$k$\u7684\u6392\u540d\u4e0d\u4e00\u5b9a\u662f$rk-1$\uff0c\n\n\u56e0\u4e3a\u53ef\u80fd\u6709\u6570\u7684\u6392\u540d\u76f8\u540c\u3002\n\n\u5176\u5b9e\u4e5f\u6ca1\u6709\u5173\u7cfb\u3002\n\n\u6211\u4eec\u770b\u5230\u6392\u540d\u64cd\u4f5c\uff0c\u5176\u5b9e\u6211\u4eec\u67e5\u8be2\u6392\u540d\u7684\u65f6\u5019\uff0c\n\n\u4ec5\u4ec5\u662f\u67e5\u8be2\u4e86\u5c0f\u4e8e$k$\u7684\u6570\uff0c\u7136\u540e\u52a0\u4e86$1$\u3002\n\n\u90a3\u4e48\u5176\u5b9e\u54ea\u6015\u8fd9\u4e2a\u6570\u4e0d\u5b58\u5728\uff0c\n\n\u6211\u4eec\u67e5\u8be2\u6392\u540d\u7684\u65f6\u5019\u4e5f\u4e0d\u4f1a\u51fa\u95ee\u9898\u3002\n\n\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u67e5\u8be2$k+1$\u7684\u6392\u540d\n\n\u7531\u4e8e\u5c0f\u4e8e\u7b49\u4e8e$k$\u7684\u6570\u5c31\u662f$rk-1$\u4e2a\n\n\u6240\u4ee5\u8fd4\u56de\u7684\u6392\u540d\u5c31\u4e00\u5b9a\u662f$rk$\u3002\n\n\u56e0\u6b64\uff0c\u6211\u4eec\u53ea\u9700\u8981\u67e5\u8be2$k+1$\u7684\u6392\u540d\uff0c\n\n\u5c31\u53ef\u4ee5\u5f97\u5230\u5176\u540e\u7ee7\u7684\u6392\u540d\u3002\n\n\u7136\u540e\uff0c\u518d\u67e5\u4e00\u6b21\u7b2c$k$\u5c0f\u5c31\u7ed3\u675f\u5566~\n\ncode\uff1a\n```cpp\nint find_nxt(int l,int r,int k){\n\tif(k==len) return len+1;\n    \t//\u4e3a\u4e86\u9632\u6b62\u8d8a\u754c\uff0c\u6211\u589e\u52a0\u4e86\u4e00\u4e2a\u7279\u5224\n    \t//\u8981\u662f\u5df2\u7ecf\u662f\u6700\u5927\u503c\u4e86\uff0c\u90a3\u4e48\u5b83\u5c31\u4e0d\u53ef\u80fd\u6709\u540e\u7ee7\n\tint rk=find_rnk(l,r,k+1);\n\tif(rk==r-l+2) return len+1;\n\treturn find_num(l,r,rk);\n}\n```\n## \u590d\u6742\u5ea6\n\u53ef\u4ee5\u770b\u5230\uff0c\u6211\u4eec\u4efb\u610f\u7684\u4e00\u6b21\u64cd\u4f5c\uff0c\n\n\u90fd\u662f\u5728\u6811\u72b6\u6570\u7ec4\u4e0a\u5148\u67e5\u8be2\u4e86\u4e00\u6b21\uff0c\n\n\u518d\u5230\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2\u4e86\u4e00\u6b21\uff0c\n\n\u4e24\u4e2a$\\log$\u52a0\u8d77\u6765\uff0c\u5c31\u662f$n \\log ^2 n$\u3002\n\n\u5982\u679c\u662f\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u8bdd\uff0c\n\n\u5176\u5927\u90e8\u5206\u64cd\u4f5c\u4e5f\u662f\u8fd9\u4e2a\u590d\u6742\u5ea6\uff0c\n\n\u4f46\u662f\u5728\u67e5\u8be2\u7b2c$k$\u5c0f\u65f6\u8fd8\u8981\u591a\u4e58\u4e00\u4e2a$\\log$\u3002\n\n\u5bf9\u4e8e\u7a7a\u95f4\uff0c\u5176\u5b9e\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\n\n\u6bcf\u6b21\u4fee\u6539\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4ec5\u9700\u8981\u6539\u81f3\u591a$\\log n$\u68f5\u6811\uff0c\n\n\u800c\u6bcf\u68f5\u6811\u53c8\u53ea\u8981\u6539\u4e00\u6761\u94fe\uff0c\u6240\u4ee5\u53c8\u662f\u4e00\u4e2a$log$\u3002\n\n\u4e8e\u662f\uff0c\u7a7a\u95f4\u4e5f\u662f$n \\log ^2 n$\u7ea7\u522b\u7684\u590d\u6742\u5ea6\uff0c\n\n\u5b8c\u5168\u53ef\u4ee5\u627f\u53d7\u3002\n\n\u65f6\u95f4\u548c\u7a7a\u95f4\u90fd\u662f\u4e0a\u754c\uff0c\n\n\u7279\u522b\u662f\u7a7a\u95f4\uff0c\u4e00\u822c\u7684\u6570\u636e\u6839\u672c\u4e0d\u53ef\u80fd\u8fbe\u5230\u8fd9\u4e48\u9ad8\u3002\n\n~~\u7136\u540e\u6d1b\u8c37\u7684\u6570\u636e\u53c8\u6c34~~\n\n## \u5b8c\u6574\u4ee3\u7801\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int read(){\n\tregister int x=0;\n\tregister bool f=0;\n\tregister char c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-') f=1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<3)+(x<<1)+c-48;\n\t\tc=getchar();\n\t}\n\treturn f?-x:x;\n}\nconst int maxn=50005;\nint len=0;\nconst int inf=2147483647;\nstruct seg{\n\tint v,ls,rs;\n}t[maxn*100];\nint rt[maxn],n,m,tot,tem[maxn],tmp[maxn],cnt,num;\nint lsh[maxn<<1],a[maxn];\nstruct cz{\n\tint a,b,c,d;\n}q[maxn];\nint lb(int x){\n\treturn x&(-x);\n}\nvoid pushup(int o){\n\tt[o].v=t[t[o].ls].v+t[t[o].rs].v;\n}\nvoid change(int &o,int l,int r,int k,int v){\n\tif(!o) o=++tot;\n\tif(l==r){\n\t\tt[o].v+=v;\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tif(k<=mid) change(t[o].ls,l,mid,k,v);\n\telse change(t[o].rs,mid+1,r,k,v);\n\tpushup(o);\n}\nvoid add(int o,int v){\n\tfor(int i=o;i<=n;i+=lb(i)) change(rt[i],1,len,a[o],v);\n} \nint query_num(int l,int r,int k){\n\tif(l==r) {\n\t\treturn l;\n\t}\n\tint mid=l+r>>1,sum=0;\n\tfor(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v;\n\tfor(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v;\n\tif(k<=sum){\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;\n\t\treturn query_num(l,mid,k);\n\t}\n\telse{\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].rs;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].rs;\n\t\treturn query_num(mid+1,r,k-sum);\n\t}\n}\nint find_num(int l,int r,int k){\n\tcnt=num=0;\n\tfor(int i=r;i;i-=lb(i)){\n\t\ttem[++cnt]=rt[i];\n\t}\n\tfor(int i=l-1;i;i-=lb(i)){\n\t\ttmp[++num]=rt[i];\n\t}\n\treturn query_num(1,len,k);\n} \nint query_rnk(int l,int r,int k){\n\tif(l==r) {\n\t\treturn 0;\n\t}\n\tint mid=l+r>>1,sum=0;\n\t\n\tif(k<=mid){\n\t\tfor(int i=1;i<=cnt;i++) tem[i]=t[tem[i]].ls;\n\t\tfor(int i=1;i<=num;i++) tmp[i]=t[tmp[i]].ls;\n\t\treturn query_rnk(l,mid,k);\n\t}\n\telse{\n\t\tfor(int i=1;i<=cnt;i++) sum+=t[t[tem[i]].ls].v,tem[i]=t[tem[i]].rs;\n\t\tfor(int i=1;i<=num;i++) sum-=t[t[tmp[i]].ls].v,tmp[i]=t[tmp[i]].rs;\n\t\treturn sum+query_rnk(mid+1,r,k);\n\t}\n}\nint find_rnk(int l,int r,int k){\n\tcnt=num=0;\n\tfor(int i=r;i;i-=lb(i)){\n\t\ttem[++cnt]=rt[i];\n\t}\n\tfor(int i=l-1;i;i-=lb(i)){\n\t\ttmp[++num]=rt[i];\n\t}\n\treturn query_rnk(1,len,k)+1;\n}\nint find_pri(int l,int r,int k){\n\tint rk=find_rnk(l,r,k)-1;\n\tif(rk==0) return 0;\n\treturn find_num(l,r,rk);\n}\nint find_nxt(int l,int r,int k){\n\tif(k==len) return len+1;\n\tint rk=find_rnk(l,r,k+1);\n\tif(rk==r-l+2) return len+1;\n\treturn find_num(l,r,rk);\n}\nsigned main(){\n\t\tn=read();m=read();\n\t\ttot=cnt=num=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=read();\n\t\t\tlsh[++len]=a[i];\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tq[i].a=read();q[i].b=read();q[i].c=read();\n\t\t\tif(q[i].a!=3) q[i].d=read();\n\t\t\telse lsh[++len]=q[i].c;\n\t\t\tif(q[i].a==4 || q[i].a==5) lsh[++len]=q[i].d;\n\t\t}\n\t\tsort(lsh+1,lsh+len+1);\n\t\tlen=unique(lsh+1,lsh+len+1)-lsh-1;//\u79bb\u6563\u5316\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[i]=lower_bound(lsh+1,lsh+1+len,a[i])-lsh;\n\t\t\tadd(i,1);\n\t\t}\n\t\tlsh[0]=-inf;\n\t\tlsh[len+1]=inf;\n        \t//\u4e3a\u4e86\u524d\u9a71\u548c\u540e\u7ee7\u7528\u3002\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tif(q[i].a==3){\n\t\t\t\tadd(q[i].b,-1);\n\t\t\t\ta[q[i].b]=lower_bound(lsh+1,lsh+1+len,q[i].c)-lsh;\n\t\t\t\tadd(q[i].b,1);\n\t\t\t}\n\t\t\tif(q[i].a==1){\n\t\t\t\tq[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;\n\t\t\t\tprintf(\"%d\\n\",find_rnk(q[i].b,q[i].c,q[i].d));\n\t\t\t}\n\t\t\tif(q[i].a==2){\n\t\t\t\tprintf(\"%d\\n\",lsh[find_num(q[i].b,q[i].c,q[i].d)]);\n\t\t\t}\n\t\t\tif(q[i].a==4){\n\t\t\t\tq[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;\n\t\t\t\tprintf(\"%d\\n\",lsh[find_pri(q[i].b,q[i].c,q[i].d)]);\n\t\t\t}\n\t\t\tif(q[i].a==5){\n\t\t\t\tq[i].d=lower_bound(lsh+1,lsh+1+len,q[i].d)-lsh;\n\t\t\t\tprintf(\"%d\\n\",lsh[find_nxt(q[i].b,q[i].c,q[i].d)]);\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\n```\nqaq\u5b8c\u6574\u7684\u4ee3\u7801\u5c31\u662f\u8fd9\u6837\u5566~\n\n\u795d\u5404\u4f4dWC/NOI/CSP2020\u52a0\u6cb9qaq\n\n\u8981\u662f\u5df2\u7ecf\u9000\u5f79\u7684\u90a3\u5c31\u795d\u9ad8\u8003\u52a0\u6cb9\u5427qaq",
        "postTime": 1576214606,
        "uid": 120074,
        "name": "BFqwq",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8fd8\u597d,\u534a\u4e2a\u4e0b\u5348\u641e\u51fa\u6765\u4e86.. ~~(\u64e6\u6c57~~\n\n\u88ab\u4e00\u4e2a\u7ec6\u8282\u5361\u4e86\u8001\u534a\u5929,\u4e00\u76f4WA 70pts,\u7b49\u4f1a\u513f\u4f1a\u8bb2\n\n*\u732e\u7ed9\u50cf\u6211\u4e00\u6837\u53ea\u559c\u6b22\u5199$fhqTreap$\u7684\u4eba*\n\n[\u539f\u9898\u94fe\u63a5](https://www.luogu.org/problem/P3380)\n\n---\n\n### \u8c01\u8bf4$fhqTreap$\u5e38\u6570\u5927?\n\n\u4e0d\u52a0O2\u548c\u4efb\u4f55\u4f18\u5316\u6811\u5957\u6811\u4e5f\u8f7b\u677e\u8fc7\u4e86..\n\n\u6211\u770b\u57fa\u672c\u6ca1\u4eba\u5199$fhqTreap$,\u5c31\u7b97\u662f\u8fd8\u8981\u5f00O2,\u6240\u4ee5\u6211\u5c31\u6211\u6765\u53d1\u4e00\u4e2a\u5566!\n\n\u9996\u5148\u8981\u628a\u90a3\u51e0\u9053\u5e73\u8861\u6811\u7684\u6a21\u677f\u9898\u7528$fhqTreap$\u5199\u4e00\u5199(\u8981\u975e\u5e38\u719f\u7ec3\u624d\u884c)\n\n\u4e3a\u4e86\u8ba9\u5927\u5bb6\u66f4\u6e05\u6670\u7684\u5199$fhqTreap$,\u6211\u4e00\u4e2a\u90e8\u5206\u4e00\u4e2a\u90e8\u5206\u5730\u8bb2~\n\n---\n\n#### 1. \u5e73\u8861\u6811\u90e8\u5206:\n\n\u90fd\u662f\u6a21\u677f\u9898\u306e\u5185\u5bb9,\u4e00\u6478\u4e00\u6837,\u5c31\u4e0d\u591a\u8bf4\u4e86\n\n\u65b0\u8282\u70b9\u548c\u66f4\u65b0size:\n\n```cpp\nint cnt=0;\nstruct fhq_node{\n\tint ch[2],key,val,siz;\n}t[M<<1];\ninline int NewNode(int data){\n\tint k=++cnt;\n\tt[k].key=rand();\n\tt[k].val=data;\n\tt[k].siz=1;\n\tt[k].ch[0]=t[k].ch[1]=0;\n\treturn k;\n}\ninline void update(int k){\n\tt[k].siz=t[t[k].ch[0]].siz+t[t[k].ch[1]].siz+1;\n}\n```\n\n\n\u5206\u88c2\u5408\u5e76:\n\n```cpp\nint Merge(int l,int r){\n\tif(!l||!r)return l+r;\n\tif(t[l].key>t[r].key){\n\t\tt[l].ch[1]=Merge(t[l].ch[1],r);\n\t\tupdate(l);\n\t\treturn l;\n\t}\n\telse{\n\t\tt[r].ch[0]=Merge(l,t[r].ch[0]);\n\t\tupdate(r);\n\t\treturn r;\n\t}\n}\nvoid Split(int k,int data,int &l,int &r){\n\tif(!k){\n\t\tl=r=0;\n\t\treturn;\n\t}\n\tif(data>=t[k].val){\n\t\tl=k;\n\t\tSplit(t[k].ch[1],data,t[k].ch[1],r);\n\t}\n\telse{\n\t\tr=k;\n\t\tSplit(t[k].ch[0],data,l,t[k].ch[0]);\n\t}\n\tupdate(k);\n}\n```\n\n\u63d2\u5165\u5220\u9664:**(\u8bf7\u6ce8\u610f\u5220\u9664\u4e2d\u7684\u7ec6\u8282)**\n\n```cpp\nvoid Insert(int &root,int data){//\u6ce8\u610froot\u8981\u4f20\u5740,\u4f20\u7ebf\u6bb5\u6811\u8282\u70b9\u7f16\u53f7\u4e5f\u884c,\u4e0d\u8fc7\u4f20root\u53ef\u4ee5\u51cf\u5c11\u7801\u91cf\n\tint l=0,r=0;\n\tSplit(root,data,l,r);\n\troot=Merge(Merge(l,NewNode(data)),r);\n}\nvoid Delete(int &root,int data){\n\tint l=0,p=0,r=0;\n\tSplit(root,data,l,r);\n\tSplit(l,data-1,l,p);\n\tp=Merge(t[p].ch[0],t[p].ch[1]);\n    //\u8fd9\u91cc\u5361\u4e86\u6211\u8001\u534a\u5929\n    //\u7531\u4e8e\u4e00\u6b21\u53ea\u5220\u9664\u4e00\u4e2a\u70b9,\u6240\u4ee5\u5982\u679c\u628a\u6574\u9897p\u5168\u5220\u7684\u8bdd\u5982\u679c\u6709\u6743\u503c\u76f8\u540c\u7684\u8282\u70b9\u5c31\u5495\u5495(\u591a\u5220\u4e86)\u4e86\n    //\u6240\u4ee5\u8981\u628a\u5de6\u53f3\u5b50\u6811\u5148\u5408\u5e76,\u8fd9\u6837\u5c31\u53ea\u5220\u4e86\u6839\u8fd9\u4e00\u4e2a\u8282\u70b9\n\troot=Merge(l,Merge(p,r));\n}\n```\n\n\u67e5\u8be2\u6392\u540d:\n\n```cpp\nint Find_rank(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data-1,l,r);\n\tint ans=t[l].siz;\n\troot=Merge(l,r);\n\treturn ans;\n}\n```\n\u67e5\u8be2\u524d\u9a71\u4e0e\u540e\u7ee7:\n\n```cpp\nint Find_pre(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data-1,l,r);\n\tint k=l;\n\tif(!k)return -inf;\n\twhile(t[k].ch[1])k=t[k].ch[1];//\u9012\u5f52\u53f3\u5b50\u6811\n\tint ans=t[k].val;\n\troot=Merge(l,r);\n\treturn ans;\n} \nint Find_suf(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data,l,r);\n\tint k=r;\n\tif(!k)return inf;\n\twhile(t[k].ch[0])k=t[k].ch[0];//\u9012\u5f52\u5de6\u5b50\u6811\n\tint ans=t[k].val;\n\troot=Merge(l,r);\n\treturn ans;\n} \n```\n\n\n#### 2.\u7ebf\u6bb5\u6811\u90e8\u5206\n\n\u8282\u70b9:\n\n$tree[i].root$\u4e3a\u7ebf\u6bb5\u6811\u4e0a$i$\u53f7\u8282\u70b9\u6240\u5957\u7684\u5e73\u8861\u6811\u7684\u6839\u8282\u70b9\n\n```cpp\nstruct node{\n\tint l,r,root;\n}tree[N<<2];\n```\n\n\n\u5efa\u6811:\n\n```cpp\nvoid build(int i,int l,int r){\n\ttree[i].l=l;\n\ttree[i].r=r;\n\tif(l==r){\n\t\ttree[i].root=NewNode(a[l]);\n\t\treturn ;\n\t}\n\tfor(int k=l;k<=r;k++){\n\t\tInsert(tree[i].root,a[k]);//\u628a\u5f53\u524d\u8282\u70b9\u6240\u5c5e\u533a\u95f4\u4e2d\u7684\u6240\u6709\u6570\u90fd\u63d2\u5165\u4e00\u4e0b\u5c31\u884c\u4e86\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(i*2,l,mid);\n\tbuild(i*2+1,mid+1,r);\n}\n```\n\n\u67e5\u6392\u540d:\n\n**\u6ce8\u610f:\u8fd9\u91cc\u67e5\u51fa\u6765\u7684\u6392\u540d\u662f\u4e25\u683c\u5c0f\u4e8ek\u7684\u6570\u7684\u4e2a\u6570,\u6240\u4ee5\u5728\u51fd\u6570\u5916\u8fb9\u522b\u5fd8\u4e86+1**\n\n```cpp\nint Rank(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_rank(tree[i].root,d);//\u5f80\u5f53\u524d\u8282\u70b9\u7684\u5e73\u8861\u6811\u91cc\u627e\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=0;\n\tif(l<=mid){\n\t\tval+=Rank(i*2,l,r,d);\n\t}\n\tif(r>mid){\n\t\tval+=Rank(i*2+1,l,r,d);\n\t}\n\treturn val;\n}\n```\n\n\u66f4\u65b0\u6743\u503c:\n\n```cpp\nvoid Change(int i,int pos,int data){\n\tDelete(tree[i].root,a[pos]);\n\tInsert(tree[i].root,data);\n\tif(tree[i].l==tree[i].r)return;\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tif(pos<=mid){\n\t\tChange(i*2,pos,data);\n\t}\n\tif(pos>mid){\n\t\tChange(i*2+1,pos,data);\n\t}\n}\n```\n\n\u67e5\u524d\u9a71\u4e0e\u540e\u7ee7:\n\n```cpp\nint ask_pre(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_pre(tree[i].root,d);//\u8fdb\u5165\u5e73\u8861\u6811\u67e5\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=-inf;\n\tif(l<=mid){\n\t\tval=max(val,ask_pre(i*2,l,r,d));\n\t}\n\tif(r>mid){\n\t\tval=max(val,ask_pre(i*2+1,l,r,d));\n\t}\n\treturn val;\n}\nint ask_suf(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_suf(tree[i].root,d);\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=inf;\n\tif(l<=mid){\n\t\tval=min(val,ask_suf(i*2,l,r,d));\n\t}\n\tif(r>mid){\n\t\tval=min(val,ask_suf(i*2+1,l,r,d));\n\t}\n\treturn val;\n}\n```\n\n#### 3.\u8fd8\u6709\u4e00\u4e2a\u4e1c\u897f: 2\u64cd\u4f5c\u7684\u4e8c\u5206\n\n\u8fd9\u4e2a\u66f4\u597d\u5199\u5427..\n\n```cpp\nint kth(int l,int r,int k){\n\tint L=0,R=1e8+1,ans=0;\n\twhile(L<R){\n\t\tint mid=(L+R)>>1;\n\t\tif(Rank(1,l,r,mid)+1<=k){//Don't Forget to +1\n\t\t\tans=mid;\n\t\t\tL=mid+1;\n\t\t}\n\t\telse{\n\t\t\tR=mid;\n\t\t}\n\t}\n\treturn ans;\n}\n```\n\n\u53d1\u73b0\u5199\u5b8c\u4e86..\n\n\u4e00\u4e2a\u90e8\u5206\u4e00\u4e2a\u90e8\u5206\u5730\u5199\u662f\u4e0d\u662f\u5f88\u6e05\u6670~\n\n\u5176\u5b9e\u5c31\u662f\u7801\u91cf\u5927\u4e86\u70b9,\u5982\u679c\u771f\u6b63\u719f\u7ec3\u638c\u63e1\u4e86\u7ebf\u6bb5\u6811\u548c$fhqTreap$,\u5c31\u6ca1\u4ec0\u4e48\u96be\u7406\u89e3\u3001\u96be\u5199\u7684\u5730\u65b9\u4e86\n\n\u5168\u90e8\u4ee3\u7801:\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<ctime>\n#include<cstdlib>\nusing namespace std;\n#define N 50050\n#define M 1000010\nconst int inf=2147483647;\ninline int read(){\n    int x=0,f=1;\n    char c=getchar();\n    while(c<'0'||c>'9'){\n        if(c=='-')f=-1;\n        c=getchar();\n    }\n    while(c>='0'&&c<='9'){\n        x=(x<<3)+(x<<1)+c-'0';\n        c=getchar();\n    }\n    return x*f;\n}\nstruct node{\n\tint l,r,root;\n}tree[N<<2];\nint a[N],n,m;\nint cnt=0;\nstruct fhq_node{\n\tint ch[2],key,val,siz;\n}t[M<<1];\ninline int NewNode(int data){\n\tint k=++cnt;\n\tt[k].key=rand();\n\tt[k].val=data;\n\tt[k].siz=1;\n\tt[k].ch[0]=t[k].ch[1]=0;\n\treturn k;\n}\ninline void update(int k){\n\tt[k].siz=t[t[k].ch[0]].siz+t[t[k].ch[1]].siz+1;\n}\nint Merge(int l,int r){\n\tif(!l||!r)return l+r;\n\tif(t[l].key>t[r].key){\n\t\tt[l].ch[1]=Merge(t[l].ch[1],r);\n\t\tupdate(l);\n\t\treturn l;\n\t}\n\telse{\n\t\tt[r].ch[0]=Merge(l,t[r].ch[0]);\n\t\tupdate(r);\n\t\treturn r;\n\t}\n}\nvoid Split(int k,int data,int &l,int &r){\n\tif(!k){\n\t\tl=r=0;\n\t\treturn;\n\t}\n\tif(data>=t[k].val){\n\t\tl=k;\n\t\tSplit(t[k].ch[1],data,t[k].ch[1],r);\n\t}\n\telse{\n\t\tr=k;\n\t\tSplit(t[k].ch[0],data,l,t[k].ch[0]);\n\t}\n\tupdate(k);\n}\nvoid Insert(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data,l,r);\n\troot=Merge(Merge(l,NewNode(data)),r);\n}\nvoid Delete(int &root,int data){\n\tint l=0,p=0,r=0;\n\tSplit(root,data,l,r);\n\tSplit(l,data-1,l,p);\n\tp=Merge(t[p].ch[0],t[p].ch[1]);\n\troot=Merge(l,Merge(p,r));\n}\nvoid build(int i,int l,int r){\n\ttree[i].l=l;\n\ttree[i].r=r;\n\tif(l==r){\n\t\ttree[i].root=NewNode(a[l]);\n\t\treturn ;\n\t}\n\tfor(int k=l;k<=r;k++){\n\t\tInsert(tree[i].root,a[k]);\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(i*2,l,mid);\n\tbuild(i*2+1,mid+1,r);\n}\nint Find_rank(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data-1,l,r);\n\tint ans=t[l].siz;\n\troot=Merge(l,r);\n\treturn ans;\n} \nint Rank(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_rank(tree[i].root,d);\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=0;\n\tif(l<=mid){\n\t\tval+=Rank(i*2,l,r,d);\n\t}\n\tif(r>mid){\n\t\tval+=Rank(i*2+1,l,r,d);\n\t}\n\treturn val;\n}\nint kth(int l,int r,int k){\n\tint L=0,R=1e8+1,ans=0;\n\twhile(L<R){\n\t\tint mid=(L+R)>>1;\n\t\tif(Rank(1,l,r,mid)+1<=k){\n\t\t\tans=mid;\n\t\t\tL=mid+1;\n\t\t}\n\t\telse{\n\t\t\tR=mid;\n\t\t}\n\t}\n\treturn ans;\n}\nvoid Change(int i,int pos,int data){\n\tDelete(tree[i].root,a[pos]);\n\tInsert(tree[i].root,data);\n\tif(tree[i].l==tree[i].r)return;\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tif(pos<=mid){\n\t\tChange(i*2,pos,data);\n\t}\n\tif(pos>mid){\n\t\tChange(i*2+1,pos,data);\n\t}\n}\nint Find_pre(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data-1,l,r);\n\tint k=l;\n\tif(!k)return -inf;\n\twhile(t[k].ch[1])k=t[k].ch[1];\n\tint ans=t[k].val;\n\troot=Merge(l,r);\n\treturn ans;\n} \nint Find_suf(int &root,int data){\n\tint l=0,r=0;\n\tSplit(root,data,l,r);\n\tint k=r;\n\tif(!k)return inf;\n\twhile(t[k].ch[0])k=t[k].ch[0];\n\tint ans=t[k].val;\n\troot=Merge(l,r);\n\treturn ans;\n} \nint ask_pre(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_pre(tree[i].root,d);\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=-inf;\n\tif(l<=mid){\n\t\tval=max(val,ask_pre(i*2,l,r,d));\n\t}\n\tif(r>mid){\n\t\tval=max(val,ask_pre(i*2+1,l,r,d));\n\t}\n\treturn val;\n}\nint ask_suf(int i,int l,int r,int d){\n\tif(tree[i].l>=l&&tree[i].r<=r){\n\t\treturn Find_suf(tree[i].root,d);\n\t}\n\tint mid=(tree[i].l+tree[i].r)>>1;\n\tint val=inf;\n\tif(l<=mid){\n\t\tval=min(val,ask_suf(i*2,l,r,d));\n\t}\n\tif(r>mid){\n\t\tval=min(val,ask_suf(i*2+1,l,r,d));\n\t}\n\treturn val;\n}\nint main(){\n\tsrand(time(0));\n\tn=read(),m=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t}\n\tbuild(1,1,n);\n\tfor(int i=1;i<=m;i++){\n\t\tint opt=read();\n\t\tif(opt==1){\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tprintf(\"%d\\n\",Rank(1,l,r,k)+1);\n\t\t} \n\t\telse if(opt==2){\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tprintf(\"%d\\n\",kth(l,r,k));\n\t\t}\n\t\telse if(opt==3){\n\t\t\tint pos=read(),v=read();\n\t\t\tChange(1,pos,v);\n\t\t\ta[pos]=v;\n\t\t}\n\t\telse if(opt==4){\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tprintf(\"%d\\n\",ask_pre(1,l,r,k));\n\t\t}\n\t\telse{\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tprintf(\"%d\\n\",ask_suf(1,l,r,k));\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n[*Froggy's blog*](https://www.luogu.org/blog/1445353309froggy/)\n\n\u6b22\u8fce\u6765\u8e29,\u5471~!\n",
        "postTime": 1567946449,
        "uid": 100285,
        "name": "Froggy",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u5199\u4e2a\u9898\u89e3\u5427\uff0c\u6211\u662f\u662f\u79bb\u7ebf\u7b97\u6cd5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u7684\u3002\n\n\u8fd9\u4e2a\u9898\u6700\u5feb\u7684\u79bb\u7ebf\u7b97\u6cd5\u5e94\u8be5\u662f\u5148\u79bb\u6563\u5316\uff0c\u7136\u540ecdq\u5206\u6cbb\u7ed3\u5408\u6574\u4f53\u4e8c\u5206\u3002\u601d\u8def\u662f\u5148\u7528cdq\u5206\u6cbb\u6c42\u51fa\u64cd\u4f5c1\uff0c4\uff0c5\u7684\u5f53\u524d\u5173\u952e\u5b57\u7684\u6392\u540d\uff0c\u5bf9\u4e8e4\uff0c5\u64cd\u4f5c\u589e\u52a0\u6216\u51cf\u5c11\u6392\u540d\uff0c\u7136\u540e\u518d\u7528\u6574\u4f53\u4e8c\u5206\u6765\u5bfb\u627e\u64cd\u4f5c2, 4, 5\u6392\u540d\u5bf9\u5e94\u7684\u5173\u952e\u5b57\u3002\u4e0d\u8fc7\u7801\u91cf\u4f30\u8ba1\u633a\u5927\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u5c1d\u8bd5\u4e00\u4e0b\u3002\n\n\u6211\u662f\u7528\u5e26\u4fee\u83ab\u961f\u8fc7\u7684\u8fd9\u4e2a\u9898\uff0c\u4e0d\u8fc7\u4e0e\u522b\u7684\u83ab\u961f\u9898\u89e3\u4e0d\u540c\u3002\u5df2\u6709\u7684\u7248\u672c\u662f\u83ab\u961f\u7ed3\u5408\u6811\u72b6\u6570\u7ec4\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^5/3\\*logn)\u3002\u6211\u7528\u7684\u662f\u83ab\u961f\u7ed3\u5408\u503c\u57df\u5206\u5757\u7b97\u6cd5\u3002\u8fd9\u4e2a\u505a\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4ec5\u4e3aO(n^5/3)\uff0c\u6bd4\u7ed3\u5408\u6811\u72b6\u6570\u7ec4\u7684\u89e3\u6cd5\u5feb\u7684\u591a\uff0c\u6700\u5927\u7684\u4e00\u4e2a\u65f6\u95f4\u70b9\u4ec5\u4e3a320ms\uff0c\u7a7a\u95f4\u5360\u75282.8MB\u3002\n\n\u5177\u4f53\u505a\u6cd5\u662f\u8fd9\u6837\u7684\uff0c\u9996\u5148\u662f\u79bb\u6563\u5316\u9664\u4e86\u64cd\u4f5c2\u4e4b\u5916\u7684\u6240\u6709\u6570\u636e\u3002\u7136\u540e\u5bf9\u503c\u57df\u8fdb\u884c\u5206\u5757\uff0c\u901a\u5e38\u503c\u57df\u7684\u5206\u5757\u5927\u5c0f\u4e3asqrt(n+m)\u5c31\u884c\u4e86\u3002\u7136\u540e\u6211\u4eec\u7ef4\u62a4\u4e24\u4e2a\u6570\u7ec4cnt1\u4e0ecnt2\u3002\ncnt1[i]\u8868\u793a\u76ee\u524d\u5728\u7b2ci\u4e2a\u503c\u57df\u5757\u8303\u56f4\u7684\u6570\u5b57\u4e2a\u6570\uff0ccnt2[i]\u8868\u793a\u76ee\u524d\u6570\u503c\u4e3ai\u7684\u6570\u5b57\u4e2a\u6570\u3002\n\n\u4ee3\u7801\u5176\u4ed6\u7684\u90fd\u4e00\u5207\u9075\u5faa\u5e26\u4fee\u83ab\u961f\u7684\u60ef\u4f8b\uff0c\u83ab\u961f\u64cd\u4f5c\u5206\u5757\u7684\u5757\u5927\u5c0f\u4e3aO(n/q^(1/3))\uff0c\u5176\u4e2dq\u4e3a\u67e5\u8be2\u7684\u4e2a\u6570(q\u4e3a\u603b\u64cd\u4f5c\u4e2a\u6570\u51cf\u53bb\u4fee\u6539\u64cd\u4f5c\u7684\u4e2a\u6570)\u3002\u5b9e\u8df5\u8bc1\u660e\u8fd9\u4e2a\u5206\u5757\u5927\u5c0f\u6bd4O(n^(2/3))\u8981\u5feb\u3002\n\n\u5e26\u4fee\u83ab\u961f\u672c\u8eab\u9700\u8981\u79fb\u52a8\u4e09\u79cd\u6307\u9488\uff0c\u5de6\u6307\u9488\uff0c\u53f3\u6307\u9488\u4e0e\u65f6\u95f4\u6233\u6307\u9488\u3002\u53ea\u6709\u4e09\u4e2a\u6307\u9488\u90fd\u4e0e\u5f85\u67e5\u8be2\u7684\u95ee\u9898\u5b8c\u5168\u5339\u914d\u662f\u624d\u80fd\u8c03\u7528\u53bb\u67e5\u8be2\u76f8\u5e94\u7684\u6392\u540d\u6216\u8005\u6839\u636e\u6392\u540d\u53bb\u5bfb\u627e\u6570\u3002\n\n\u5f53\u79fb\u52a8\u5de6\u53f3\u6307\u9488\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u6839\u636e\u79fb\u5165\u6216\u8005\u79fb\u51fa\u7684\u6570\u5b57\u5728O(1)\u65f6\u95f4\u5185\u7ef4\u62a4cnt1\u4e0ecnt2\u3002\u5f53\u5904\u7406\u65f6\u95f4\u6233\u65f6\uff0c\u9700\u8981\u540c\u65f6\u8003\u8651\u4fee\u6539\u524d\u7684\u6570\u5b57\u4e0e\u4fee\u6539\u540e\u7684\u6570\u5b57\u5bf9cnt1\u4e0ecnt2\u4ea7\u751f\u7684\u5f71\u54cd\uff0c\u4e5f\u53ef\u4ee5\u505a\u5230\u5728O(1)\u65f6\u95f4\u5185\u7ef4\u62a4cnt1\u4e0ecnt2\u3002\u5f53\u67e5\u8be2\u95ee\u9898\u65f6\uff0c\u7531\u4e8e\u6709\u4e86cnt1\u4e0ecnt2\u8fd9\u4e24\u4e2a\u6570\u7ec4\u7684\u5e2e\u52a9\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u5bb9\u6613\u5728O(sqrt(n+m))\u65f6\u95f4\u5185\u627e\u5230\u7b54\u6848\u3002\n\n\u5f53m = O(n)\u65f6\u5019\uff0c\u53ef\u4ee5\u63a8\u5bfc\u5f97\u51fa\u6211\u4eec\u6700\u591a\u79fb\u52a8\u6307\u9488\u7684\u6b21\u6570\u4e3aO(n^(5/3))\uff0cq\u6b21\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u4e0d\u4f1a\u8d85\u8fc7O(m\\*sqrt(n+m)) = O(n^(3/2))\u3002\u56e0\u6b64\u6574\u4f53\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO(n^5/3)\u3002\u6bd4\u7528\u6811\u72b6\u6570\u7ec4\u7684\u65b9\u6cd5\u7701\u6389\u4e86\u4e00\u4e2alogn\u7684\u56e0\u5b50\u3002\n\n\u597d\u4e86\uff0c\u4ee3\u7801\u5982\u4e0b\u3002\n```cpp\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define LOCAL 0\n#define CONFIG_USE_MO 1 //offline\n#define MAXN 50000\n#define MAXM 50000\n\nconst int32_t kInf = (1ull<<31)-1;\n\n#if CONFIG_USE_MO\n#define MAX_RANGE_BLOCK 317 //sqrt(MAXN+MAXM)\n\nstruct Query {\n  int left;\n  int right;\n  int time_stamp;\n  int op;\n  int32_t val;\n  int id;\n};\n\nstruct Modification {\n  int pos;\n  int id;\n};\n\nint32_t digits[MAXN+MAXM];\nint32_t buffer[MAXN+MAXM];\nQuery query[MAXM];\nModification modification[MAXM+1];\nint32_t ans[MAXM];\nint counter1[MAX_RANGE_BLOCK];\nint counter2[MAXN+MAXM];\nint block_size;\n\nbool Compare(const Query &a, const Query &b)\n{\n  if (a.left/block_size != b.left/block_size) {\n    return a.left < b.left;\n  } else if (a.right/block_size != b.right/block_size) {\n    return a.right < b.right;\n  } else {\n    return a.time_stamp < b.time_stamp;\n  }\n}\n\nint QueryRank(int range_size, int key)\n{\n  int rank = 0;\n  for (int i=0; i<key/range_size; ++i) {\n    rank += counter1[i];\n  }\n  for (int i=(key/range_size)*range_size; i<key; ++i) {\n    rank += counter2[i];\n  }\n  return rank;\n}\n\nint QuerySelect(int range_size, int rank)\n{\n  int val = 0;\n  while (rank >= counter1[val]) {\n    rank -= counter1[val];\n    ++val;\n  }\n  val *= range_size;\n  while (rank >= counter2[val]) {\n    rank -= counter2[val];\n    ++val;\n  }\n  return val;\n}\n#endif\n\nint ReadInteger(void)\n{\n  int x=0, sign=1;\n  int ch;\n  ch = getchar();\n  while (ch<'0' || ch>'9') {\n    if (ch=='-') {\n      sign = -1;\n    }\n    ch = getchar();\n  }\n  while (ch>='0' && ch<='9') {\n    x = x*10 + ch-'0';\n    ch = getchar();\n  }\n  return x*sign;\n}\n\nint main(void)\n{\n#if LOCAL\n  freopen(\"test.in\", \"r\", stdin);\n  freopen(\"test.out\", \"w\", stdout);\n#endif\n  int n, m;\n  int left, right;\n  int32_t val;\n  int op;\n  uint32_t rank;\n  n = ReadInteger();\n  m = ReadInteger();\n#if CONFIG_USE_MO\n  int total, total_digit, cnt=0;\n  int range_size, time_stamp = 0;\n  int pos, pos_next;\n  for (int i=0; i<n; ++i) {\n    digits[i] = ReadInteger();\n  }\n  total = n;\n  total_digit = n;\n  memcpy(buffer, digits, n*sizeof(digits[0]));\n  for (int i=0; i<m; ++i) {\n    op = ReadInteger();\n    left = ReadInteger();\n    --left; //index starts from 0\n    if (op == 2) {\n      right = ReadInteger();  //[left, right) interval\n      rank = ReadInteger();\n      --rank;  //rank starts from 0\n      query[cnt].left = left;\n      query[cnt].right = right;\n      query[cnt].time_stamp = time_stamp;\n      query[cnt].op = op;\n      query[cnt].val = rank;\n      query[cnt].id = cnt;\n      ++cnt;\n    } else if (op == 3) {\n      val = ReadInteger();\n      digits[n+time_stamp] = val;\n      ++time_stamp;\n      modification[time_stamp].pos = left;\n      modification[time_stamp].id = time_stamp;\n      buffer[total] = val;\n      ++total;\n    } else {  //1, 4, 5\n      right = ReadInteger();\n      val = ReadInteger();\n      query[cnt].left = left;\n      query[cnt].right = right;\n      query[cnt].time_stamp = time_stamp;\n      query[cnt].op = op;\n      query[cnt].val = val;\n      query[cnt].id = cnt;\n      ++cnt;\n      buffer[total] = val;\n      ++total;\n    }\n  }\n  sort(buffer, buffer+total);\n  total = unique(buffer, buffer+total) - buffer;\n  for (int i=0; i<n+time_stamp; ++i) {\n    digits[i] = lower_bound(buffer, buffer+total, digits[i])-buffer;\n  }\n  for (int i=0; i<cnt; ++i) {\n    if (query[i].op != 2) {\n      query[i].val = lower_bound(buffer, buffer+total, query[i].val)-buffer;\n    }\n  }\n  range_size = static_cast<int>(sqrt(total));\n  memset(counter1, 0, (total/range_size+1)*sizeof(counter1[0]));\n  memset(counter2, 0, total*sizeof(counter2[0]));\n  block_size = static_cast<int>(n/pow(cnt, 1.0/3));\n  sort(query, query+cnt, Compare);\n  left = 0;\n  right = 0;\n  time_stamp = 0;\n  for (int i=0; i<cnt; ++i) {\n    while (left < query[i].left) {\n      --counter1[digits[left]/range_size];\n      --counter2[digits[left]];\n      ++left;\n    }\n    while (left > query[i].left) {\n      --left;\n      ++counter1[digits[left]/range_size];\n      ++counter2[digits[left]];\n    }\n    while (right < query[i].right) {\n      ++counter1[digits[right]/range_size];\n      ++counter2[digits[right]];\n      ++right;\n    }\n    while (right > query[i].right) {\n      --right;\n      --counter1[digits[right]/range_size];\n      --counter2[digits[right]];\n    }\n    while (time_stamp < query[i].time_stamp) {\n      ++time_stamp;\n      pos = modification[time_stamp].pos;\n      pos_next = n+modification[time_stamp].id-1;\n      if (pos>=left && pos<right) {\n        --counter1[digits[pos]/range_size];\n        --counter2[digits[pos]];\n        ++counter1[digits[pos_next]/range_size];\n        ++counter2[digits[pos_next]];\n      }\n      swap(digits[pos], digits[pos_next]);\n    }\n    while (time_stamp > query[i].time_stamp) {\n      pos = modification[time_stamp].pos;\n      pos_next = n+modification[time_stamp].id-1;\n      if (pos>=left && pos<right) {\n        --counter1[digits[pos]/range_size];\n        --counter2[digits[pos]];\n        ++counter1[digits[pos_next]/range_size];\n        ++counter2[digits[pos_next]];\n      }\n      swap(digits[pos], digits[pos_next]);\n      --time_stamp;\n    }\n    switch (query[i].op) {\n    case 1:\n      rank = QueryRank(range_size, query[i].val);\n      ans[query[i].id] = rank+1;\n      break;\n    case 2:\n      val = QuerySelect(range_size, query[i].val);\n      ans[query[i].id] = buffer[val];\n      break;\n    case 4:\n      rank = QueryRank(range_size, query[i].val);\n      if (rank != 0) {\n        val = QuerySelect(range_size, rank-1);\n        ans[query[i].id] = buffer[val];\n      } else {\n        ans[query[i].id] = -kInf;\n      }\n      break;\n    case 5:\n      rank = QueryRank(range_size, query[i].val+1);\n      if (rank != right-left) {\n        val = QuerySelect(range_size, rank);\n        ans[query[i].id] = buffer[val];\n      } else {\n        ans[query[i].id] = kInf;\n      }\n      break;\n    default:\n      break;\n    }\n  }\n  for (int i=0; i<cnt; ++i) {\n    printf(\"%d\\n\", ans[i]);\n  }\n#endif\n  return 0;\n}\n```\n",
        "postTime": 1592998299,
        "uid": 119884,
        "name": "damocris",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "### \u9898\u89e3\n\n\u8fc7\u5e74\u7684\u5047\u671f\u91cc\u80af\u5b9a\u8981\u7528\u786c\u6838\u6570\u636e\u7ed3\u6784\u6253\u53d1\u65f6\u95f4\u554a\n\n\u6240\u4ee5\u6211\u5927\u80c6\u5c1d\u8bd5\uff0c\u7528\u4e86\u4e00\u79cd\u901f\u5ea6\u4e0d\u80fd\u7b97\u6700\u5feb\u4f46\u662f\u7801\u91cf\u7edd\u5bf9\u662f\u5f88\u5927\u7684\u4e00\u79cd\u65b9\u6cd5\n\n~~\u5c45\u7136\u63a7\u5236\u5728\u4e866KB\u4ee5\u5185~~\n\n**\u7ebf\u6bb5\u6811\u5957\u7ea2\u9ed1\u6811**~~\uff08\u9003~~\n\n\u8fd9\u662f\u4e00\u6b21\u524d\u6240\u672a\u6709\u7684\u5c1d\u8bd5\n\n\u56e0\u4e3a\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u6c42\u533a\u95f4\u7b2c$k$\u5c0f\u590d\u6742\u5ea6\u662f$\\mathrm{O}(\\log^3n)$\u7684\n\n\u6240\u4ee5\u901f\u5ea6\u6bd4\u4e0d\u4e0a\u6811\u72b6\u6570\u7ec4\u5957\u7ebf\u6bb5\u6811\n\n\u4f46\u662f\u5e94\u8be5\u5728\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u4ee3\u7801\u4e2d\u7b97\u6bd4\u8f83\u5feb\u7684\u4e86\u5427\n\n~~\u4e0d\u7136\u6709\u6127\u4e8e\u7ea2\u9ed1\u6811\u8fd9\u4e2a\u540d\u5b57~~\n\n### \u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<climits>\n#include<algorithm>\n\ninline int read()\n{\n    int data = 0, w = 1;\n    char ch = getchar();\n    while(ch != '-' && (ch < '0' || ch > '9')) ch = getchar();\n    if(ch == '-') w = -1, ch = getchar();\n    while(ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = getchar();\n    return data * w;\n}\n\nconst int maxn(5e4 + 10), maxm(1e7);\nint son[2][maxm], fa[maxm], size[maxm], cur;\nint cnt[maxm], col[maxm], val[maxm], root, tree[maxn << 2];\ninline void newNode(int k, int c, int f)\n{\n    int x = ++cur;\n    fa[x] = f, size[x] = cnt[x] = 1;\n    val[x] = k, col[x] = c;\n}\n\ninline void update(int x) { size[x] = size[son[0][x]] + cnt[x] + size[son[1][x]]; }\ninline void rotate(int x, int r)\n{\n    int y = son[!r][x]; son[!r][x] = son[r][y];\n    if(son[r][y]) fa[son[r][y]] = x;\n    fa[y] = fa[x]; if(!fa[x]) root = y;\n    else son[x == son[1][fa[x]]][fa[x]] = y;\n    son[r][y] = x, fa[x] = y, size[y] = size[x];\n    update(x);\n}\n\ninline void transplant(int to, int from)\n{\n    fa[from] = fa[to]; if(!fa[to]) root = from;\n    else son[to == son[1][fa[to]]][fa[to]] = from;\n}\n\nint findMin(int x) { while(son[0][x]) x = son[0][x]; return x; }\nvoid insertFixUp(int z)\n{\n    while(col[fa[z]])\n    {\n        int f = fa[z], g = fa[f], l = f == son[0][g], y = son[l][g];\n        if(col[y]) col[y] = col[f] = 0, col[z = g] = 1;\n        else\n        {\n            if(z == son[l][f]) z = f, rotate(z, !l);\n            col[fa[z]] = 0, col[fa[fa[z]]] = 1; rotate(g, l);\n        }\n    }\n    col[root] = 0;\n}\n\nvoid insert(int k)\n{\n    int x = root, y = 0;\n    while(x)\n    {\n        ++size[y = x]; if(val[x] == k) return (void) (++cnt[x]);\n        x = son[val[x] < k][x];\n    }\n    newNode(k, 1, y);\n    if(!y) root = cur; else son[val[y] < k][y] = cur;\n    insertFixUp(cur);\n}\n\nvoid delFixUp(int x)\n{\n    while(x != root && (!col[x]))\n    {\n        int l = x == son[0][fa[x]], f = fa[x], w = son[l][f];\n        if(col[w])\n        {\n            col[f] = 1, col[w] = 0;\n            rotate(f, !l); w = son[l][f];\n        }\n        if((!col[son[0][w]]) && (!col[son[1][w]])) col[w] = 0, x = fa[x];\n        else\n        {\n            if(!col[son[l][w]])\n                col[w] = 1, col[son[!l][w]] = 0,\n                rotate(w, l), w = son[l][f];\n            col[w] = col[f], col[f] = 0; col[son[l][w]] = 0;\n            rotate(fa[w], !l); x = root;\n        }\n    }\n    col[x] = 0;\n}\n\nvoid erase(int k)\n{\n    int z = root, w = 0;\n    while(z)\n    {\n        --size[w = z]; if(k == val[z]) break;\n        z = son[val[z] < k][z];\n    }\n    if(z)\n    {\n        if(cnt[z] > 1) return (void) (--cnt[z]);\n        int y = z, x, oldc = col[y];\n        if(!son[0][z]) x = son[1][z], transplant(z, son[1][z]);\n        else if(!son[1][z]) x = son[0][z], transplant(z, son[0][z]);\n        else\n        {\n            y = findMin(son[1][z]); oldc = col[y], x = son[1][y];\n            if(fa[y] == z) fa[x] = y;\n            else\n            {\n                int tmpy = y;\n                while(tmpy != z) size[tmpy] -= cnt[y], tmpy = fa[tmpy];\n                transplant(y, son[1][y]); son[1][y] = son[1][z];\n                fa[son[1][y]] = y;\n            }\n            transplant(z, y); son[0][y] = son[0][z];\n            fa[son[0][y]] = y, col[y] = col[z]; update(y);\n        }\n        if(!oldc) delFixUp(x);\n    }\n    else while(w) ++size[w], w = fa[w];\n}\n\ninline int cmp(int x, int k) { return (val[x] < k) ? 0 : (val[x] ^ k ? 1 : -1); }\nint suc(int k, int b)\n{\n    int x = root, p = 0, res = -INT_MAX;\n    while(x)\n        if(cmp(x, k) == b) res = val[p = x], x = son[!b][x];\n        else x = son[b][x];\n    return res ^ -INT_MAX ? res : (b ? INT_MAX : -INT_MAX);\n}\n\nint rank(int r)\n{\n    int x = root, ret = 0;\n    while(x)\n    {\n        if(val[x] < r) ret += size[son[0][x]] + cnt[x], x = son[1][x];\n        else x = son[0][x];\n    }\n    return ret;\n}\n\nint a[maxn], n, m;\nvoid insert(int pos, int val)\n{\n    int rt = 1, l = 1, r = n, mid;\n    while(l ^ r)\n    {\n        root = tree[rt]; insert(val); tree[rt] = root;\n        mid = (l + r) >> 1, rt <<= 1;\n        if(pos <= mid) r = mid;\n        else l = mid + 1, ++rt;\n    }\n    root = tree[rt]; insert(val); tree[rt] = root;\n}\n\nvoid update(int pos, int val)\n{\n    int rt = 1, l = 1, r = n, mid;\n    while(l ^ r)\n    {\n        root = tree[rt]; insert(val); erase(a[pos]); tree[rt] = root;\n        mid = (l + r) >> 1, rt <<= 1;\n        if(pos <= mid) r = mid;\n        else l = mid + 1, ++rt;\n    }\n    root = tree[rt]; insert(val); erase(a[pos]);\n    tree[rt] = root; a[pos] = val;\n}\n\nint lower(int ql, int qr, int val, int rt = 1, int l = 1, int r = n)\n{\n    if(qr < l || r < ql) return 0;\n    root = tree[rt];\n    if(ql <= l && r <= qr) return rank(val);\n    int mid = (l + r) >> 1, lson = rt << 1, rson = lson | 1;\n    return lower(ql, qr, val, lson, l, mid)\n        + lower(ql, qr, val, rson, mid + 1, r);\n}\n\nint suc(int ql, int qr, int val, int opt, int rt = 1, int l = 1, int r = n)\n{\n    if(qr < l || r < ql) return opt ? INT_MAX : -INT_MAX;\n    root = tree[rt];\n    if(ql <= l && r <= qr) return suc(val, opt);\n    int mid = (l + r) >> 1, lson = rt << 1, rson = lson | 1;\n    int lans = suc(ql, qr, val, opt, lson, l, mid);\n    int rans = suc(ql, qr, val, opt, rson, mid + 1, r);\n    return opt ? std::min(lans, rans) : std::max(lans, rans);\n}\n\nint k_th(int ql, int qr, int k)\n{\n    int l = 0, r = 100000001, mid, rnk;\n    while(l < r)\n    {\n        mid = (l + r) >> 1; rnk = lower(ql, qr, mid);\n        if(rnk < k) l = mid + 1; else r = mid;\n    }\n    return l - 1;\n}\n\nint main()\n{\n    n = read(), m = read();\n    for(int i = 1; i <= n; i++) insert(i, a[i] = read());\n    while(m--)\n    {\n        int opt = read(), x = read(), y = read(), z;\n        switch(opt)\n        {\n            case 1: z = read(); printf(\"%d\\n\", lower(x, y, z) + 1); break;\n            case 2: z = read(); printf(\"%d\\n\", k_th(x, y, z)); break;\n            case 3: update(x, y); break;\n            case 4: case 5: z = read();\n                    printf(\"%d\\n\", suc(x, y, z, opt - 4)); break;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1549522628,
        "uid": 46800,
        "name": "xgzc",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u5565\u73a9\u610f\u554a\uff1f\u548b\u56de\u4e8b\u554a\uff1f\u90a3\u548b\u6574\u554a\uff1f\u2014\u2014\u840c\u65b0\u4e09\u8fde\n\n\u4e3a\u5565\u6ca1\u6709\u66b4\u529b\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\u554a\u3002\u3002\u3002\u3002\u3002\u3002\n\n\u5916\u9762\u666e\u901a\u7ebf\u6bb5\u6811\uff0c\u91cc\u9762\u52a8\u6001\u52a0\u70b9\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u55ef\uff0c\u5c31\u662f\u8fd9\u4e48\u66b4\u529b\u3002\n\n\u4e0a\u4ee3\u7801\n\n```\n//lgp3380\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=50000+9;\nconst int inf=2147483647;\n\nint n,m,num[maxn],map[maxn<<1],cntm;\nstruct node{\n\tint opt,l,r,k;\n}ask[maxn];\n\nstruct seg_{\n\tint lson,rson;\n\tint sum,tmax,tmin;\n}seg[maxn*200];\nint root[maxn<<2],cnt;\n\nvoid clear(int now){\n\tseg[now].tmax=1;\n\tseg[now].tmin=cntm;\n}\nvoid up(int now){\n\tint lson=seg[now].lson,rson=seg[now].rson;\n\tseg[now].tmax=max(seg[lson].tmax,seg[rson].tmax);\n\tseg[now].tmin=min(seg[lson].tmin,seg[rson].tmin);\n}\nvoid ins2(int &now,int segl,int segr,int pos,int x){\n\tif(now==0) now=++cnt;\n\tseg[now].sum+=x;\n\tif(segl==segr){\n\t\tif(seg[now].sum==0) clear(now);\n\t\telse seg[now].tmax=seg[now].tmin=segl;\n\t\treturn;\n\t}\n\tint mid=(segl+segr)>>1;\n\tif(pos<=mid) ins2(seg[now].lson,segl,mid,pos,x);\n\telse ins2(seg[now].rson,mid+1,segr,pos,x);\n\tup(now);\n}\nvoid ins1(int now,int segl,int segr,int pos,int x,int y){\n\tins2(root[now],1,cntm,x,y);\n\tif(segl==segr) return;\n\tint mid=(segl+segr)>>1;\n\tif(pos<=mid) ins1(now<<1,segl,mid,pos,x,y);\n\telse ins1(now<<1|1,mid+1,segr,pos,x,y);\n}\n\nint tmp[maxn],ind;\n\nvoid ppr(int now,int segl,int segr,int l,int r){\n\tif(l<=segl&&segr<=r){\n\t\ttmp[++ind]=root[now];\n\t\treturn;\n\t}\n\tint mid=(segl+segr)>>1;\n\tif(l<=mid) ppr(now<<1,segl,mid,l,r);\n\tif(mid+1<=r) ppr(now<<1|1,mid+1,segr,l,r);\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);\n\tmap[++cntm]=-inf,map[++cntm]=inf;\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]),map[++cntm]=num[i];\n\tfor(int i=1;i<=m;i++){\n\t\tnode &in=ask[i];\n\t\tscanf(\"%d\",&in.opt);\n\t\tif(in.opt==3){\n\t\t\tscanf(\"%d %d\",&in.l,&in.k);\n\t\t}\n\t\telse scanf(\"%d %d %d\",&in.l,&in.r,&in.k);\n\t\tif(in.opt!=2) map[++cntm]=in.k;\n\t}\n\tsort(map+1,map+cntm+1);\n\tcntm=unique(map+1,map+cntm+1)-map-1;\n\tfor(int i=1;i<=n;i++) num[i]=lower_bound(map+1,map+cntm+1,num[i])-map;\n\tfor(int i=1;i<=m;i++) if(ask[i].opt!=2) ask[i].k=lower_bound(map+1,map+cntm+1,ask[i].k)-map;\n\t\n\tclear(0);\n\tfor(int i=1;i<=n;i++){\n\t\tins1(1,1,n,i,num[i],1);\n\t}\n\tfor(int ddf=1;ddf<=m;ddf++){\n\t\tnode &in=ask[ddf];\n\t\tif(in.opt==1){\n\t\t\tint ans=0;\n\t\t\tind=0;\n\t\t\tppr(1,1,n,in.l,in.r);\n\t\t\tint l=1,r=cntm;\n\t\t\twhile(l!=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(in.k<=mid){\n\t\t\t\t\tfor(int i=1;i<=ind;i++) tmp[i]=seg[tmp[i]].lson;\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int i=1;i<=ind;i++) ans+=seg[seg[tmp[i]].lson].sum,tmp[i]=seg[tmp[i]].rson;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans+1);\n\t\t}\n\t\telse if(in.opt==2){\n\t\t\tind=0;\n\t\t\tppr(1,1,n,in.l,in.r);\n\t\t\tint l=1,r=cntm;\n\t\t\twhile(l!=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tint tmp2=0;\n\t\t\t\tfor(int i=1;i<=ind;i++) tmp2+=seg[seg[tmp[i]].lson].sum;\n\t\t\t\tif(in.k<=tmp2){\n\t\t\t\t\tfor(int i=1;i<=ind;i++) tmp[i]=seg[tmp[i]].lson;\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int i=1;i<=ind;i++) tmp[i]=seg[tmp[i]].rson;\n\t\t\t\t\tin.k-=tmp2;\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",map[l]);\n\t\t}\n\t\telse if(in.opt==3){\n\t\t\tins1(1,1,n,in.l,num[in.l],-1);\n\t\t\tnum[in.l]=in.k;\n\t\t\tins1(1,1,n,in.l,num[in.l],1);\n\t\t}\n\t\telse if(in.opt==4){\n\t\t\tind=0;\n\t\t\tppr(1,1,n,in.l,in.r);\n\t\t\tint ans=1,l=1,r=cntm;\n\t\t\twhile(l!=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(in.k<=mid){\n\t\t\t\t\tfor(int i=1;i<=ind;i++) tmp[i]=seg[tmp[i]].lson;\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\tans=max(ans,seg[seg[tmp[i]].lson].tmax);\n\t\t\t\t\t\ttmp[i]=seg[tmp[i]].rson;\n\t\t\t\t\t}\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",map[ans]);\n\t\t}\n\t\telse {\n\t\t\tind=0;\n\t\t\tppr(1,1,n,in.l,in.r);\n\t\t\tint ans=cntm,l=1,r=cntm;\n\t\t\twhile(l!=r){\n\t\t\t\tint mid=(l+r)>>1;\n\t\t\t\tif(in.k<=mid){\n\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\tans=min(ans,seg[seg[tmp[i]].rson].tmin);\n\t\t\t\t\t\ttmp[i]=seg[tmp[i]].lson;\n\t\t\t\t\t}\n\t\t\t\t\tr=mid;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int i=1;i<=ind;i++){\n\t\t\t\t\t\ttmp[i]=seg[tmp[i]].rson;\n\t\t\t\t\t}\n\t\t\t\t\tl=mid+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",map[ans]);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1525783158,
        "uid": 33304,
        "name": "\u53f8\u9a6c\u667a\u6cfd",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u6811\u5957\u6811\u3002\n\n\u81ea\u4ece\u6811\u5957\u6811\u6253\u4e86\u7ebf\u6bb5\u6811\u5957FHQ\u540e\uff0c\u6211\u5c31\u5728\u8fd9\u9053\u9898\u4e0a\u5361\u4e869\u5929\u3002\u75af\u72c2TLE\u4f7f\u5f97\u6211\u6000\u7591\u662f\u4e0d\u662fFHQ\u5e38\u6570\u8d3c\u5927\u3002\u540e\u6765\u6211\u53d1\u73b0\uff0c\u5176\u5b9e\u662f\u6709\u51e0\u4e2a\u5730\u65b9\u6211\u6ca1\u6709\u5361\u5e38\u3002\u5728\u5361\u5e38\u7684\u5e2e\u52a9\u4e0b\uff0c\u6211\u6210\u529f\u5730\u6253\u8fc7\u53bb\u4e86\u8fd9\u9053\u9898\u3002\n\n\n\u56e0\u4e3a\u9898\u89e3\u5f88\u591a\uff0c\u6240\u4ee5\u5c31\u4e0d\u8bb2\u600e\u4e48\u6253\u6811\u5957\u6811\u4e86\u3002\u81f3\u4e8eFHQ\uff0c\u53ef\u4ee5\u5728\u7f51\u4e0a\u67e5\u627e\uff0c\u4e4b\u6240\u4ee5\u5957\u5b83\u662f\u4e3a\u4e86\u66f4\u4e27\u75c5\u7684\u53ef\u6301\u4e45\u5316\u505a\u51c6\u5907\u3002\u7136\u540e\u5f00\u59cb\u4e3b\u8981\u8bb2\u5361\u5e38\u6570\u6280\u5de7\u3002\n\n\n\n1. \u6570\u7ec4\u8c03\u7528\u3002[]\u5f80\u5f80\u6bd4\\*()\u8981\u6162\uff0c\u6240\u4ee5\u591a\u6b21\u8c03\u7528\u6570\u7ec4\u65f6\u53ef\u4ee5\u5c1d\u8bd5\u6307\u9488\u578b\u8c03\u7528\u3002[\u5c31\u662f\u4e0d\u7528x[i]\u800c\u662f\\*(x+i)]\n\n\n3. \u51fd\u6570\u4f18\u5316\u3002\u591a\u4f7f\u7528inline\u4f18\u5316\u51fd\u6570\u3002\u4f46\u662f\u8981\u6ce8\u610f\u9012\u5f52\u5f62\u51fd\u6570\u5343\u4e07\u4e0d\u8981\u6253\u3002\u5f53\u7136\u5982\u679c\u4f60\u7684\u7f16\u8bd1\u5668\u591f\u9ad8\u7ea7\u7684\u8bdd\uff0c\u5f53\u6211\u6ca1\u8bf4\u3002\n\n\n5. \u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u627e\u533a\u95f4\u6700\u503c\u4f18\u5316\u3002\u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u627e\u65f6\uff0c\u4e00\u822c\u662f\u4f7f\u7528\u5e26\u8fd4\u56de\u503c\u5f62\u5f0f\uff0c\u4f46\u662f\u8fd9\u6837\u7684\u8bdd\u4e00\u5b9a\u4f1a\u67e5\u6ee1\u5168\u533a\u95f4\uff0c\u5e76\u4e14\u8fd4\u56de\u503c\u4e5f\u4f1a\u9020\u6210\u5e38\u6570\u589e\u5927\u3002\u53ef\u4ee5\u9009\u62e9\u518d\u5f00\u4e00\u4e2a\u53d8\u91cf\u8bb0\u5f55\u67e5\u8be2\u503c\uff0c\u7136\u540e\u7528\u65e0\u8fd4\u56de\u503c\u51fd\u6570\u67e5\u627e\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5229\u7528\u5df2\u7ecf\u8bb0\u5f55\u7684\u6700\u503c\u6765\u526a\u679d\u3002\n\n\n7. \u4e8c\u5206\u67e5\u627e\u4f18\u5316\u3002\u67e5\u627e\u533a\u95f4\u7b2ck\u5c0f\u9700\u8981\u4e8c\u5206\u7b54\u6848\u5728\u6c42\u89e3\u3002\u4e8c\u5206\u4e0a\u4e0b\u754c\u5e94\u8be5\u662f\u533a\u95f4\u6700\u5927\u6700\u5c0f\u503c\u3002\u591a\u5f00\u4e24\u68f5\u7ebf\u6bb5\u6811\u8bb0\u5f55\u5373\u53ef\u3002\n\n\n9. \u8f93\u5165\u8f93\u51fa\u4f18\u5316\u3002\u8fd9\u662f\u6700\u91cd\u8981\u7684\u3002\u5927\u91cf\u7684\u8f93\u5165\u8f93\u51fa\u65f6\u4e00\u5b9a\u8981\u8bb0\u5f97\u6253\u3002\n\n\n~~6.O2\u4f18\u5316~~\n\n\n\u5176\u5b9e\u4e0d\u7ba1\u600e\u4e48\u4f18\u5316\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u90fd\u662f$O(nlog_2^3n)$\u7684\u3002\u5982\u679c\u60f3\u8981\u57281s\u5185\u8dd1\u51fa\u6765\u7684\u8bdd\uff0c\u8bf7\u7ffb\u4e00\u7ffb\u4e0b\u9762\u7684\u9898\u89e3\uff0c\u627e\u5230\u201c\u6811\u72b6\u6570\u7ec4\u5957\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff08\u5f85\u4fee\u4e3b\u5e2d\u6811\uff09\u201d\u3002\n\n\n\u4ee3\u7801\uff1a\n\n\n```cpp\n    #include<bits/stdc++.h>\n    #include<cctype>\n    #define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)\n    #define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)\n    #define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)\n    #define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)\n    #define Chkmax(a,b) a=a>b?a:b\n    #define Chkmin(a,b) a=a<b?a:b\n    using namespace std;\n    template<typename T>inline void read(T &x){\n        T s=0,f=1;char k=getchar();\n        while(!isdigit(k)&&k^'-')k=getchar();\n        if(!isdigit(k)){f=-1;k=getchar();}\n        while(isdigit(k)){s=s*10+(k^48);k=getchar();}\n        x=s*f;\n    }\n    static short c[20],top;\n    inline void print(int x)\n    {\n        if(!x){putchar(48);putchar('\\n');return;}\n        if(x<0)putchar('-'),x*=-1;\n        for(top=0;x;c[++top]=x%10,x/=10);\n        for(;top;putchar(c[top--]^48));\n        putchar('\\n');\n    }\n    inline void get(char &x){for(x=0;!isupper(x);x=getchar());}\n    void file(void){\n        #ifndef ONLINE_JUDGE\n        freopen(\"tree_in_tree.in\",\"r\",stdin);\n        freopen(\"tree_in_tree.out\",\"w\",stdout);\n        #endif\n    }\n    const int MAXN=5e4+7;\n    static int num[MAXN<<5],l[MAXN<<5],r[MAXN<<5],sz[MAXN<<5],key[MAXN<<5],e;\n    typedef pair<int,int> Pr;\n    static struct FHQ\n    {\n        int root;\n        inline void refresh(int x){*(sz+x)=*(sz+*(l+x))+*(sz+*(r+x))+1;}\n        int merge(int x,int y)\n        {\n            if(!x||!y)return x?x:y;\n            if(*(key+x)<*(key+y))\n            {\n                *(r+x)=merge(*(r+x),y);\n                refresh(x);\n                return x;\n            }\n            *(l+y)=merge(x,*(l+y));\n            refresh(y);\n            return y;\n        }\n        Pr split(int x,int k)\n        {\n            if(!x||!k)return Pr(0,x);\n            if(*(sz+*(l+x))>=k)\n            {\n                Pr y=split(*(l+x),k);\n                *(l+x)=y.second;\n                refresh(x);\n                return Pr(y.first,x);\n            }\n            Pr y=split(*(r+x),k-*(sz+*(l+x))-1);\n            *(r+x)=y.first;\n            refresh(x);\n            return Pr(x,y.second);\n        }\n        inline int Ook(int x)\n        {\n            static int ans;\n            register int now=root;ans=0;\n            while(now)*(num+now)>=x?now=*(l+now):(ans+=*(sz+*(l+now))+1,now=*(r+now));\n            return ans;\n        }\n        inline int Fbo(int k)\n        {\n            static int nu;nu=key[root]-1;\n            static Pr y,z;y=split(root,k-1);\n            z=split(y.second,1);\n            key[z.first]=nu;\n            static int ans;ans=z.first;\n            root=merge(y.first,merge(z.first,z.second));\n            return ans;\n        }\n        inline void insert(int x)\n        {\n            *(num+(++e))=x;*(l+e)=*(r+e)=0;*(sz+e)=1;*(key+e)=rand();\n            if(!root){root=e;return;}\n            static Pr y;y=split(root,Ook(x));\n            root=merge(y.first,merge(e,y.second));\n        }\n        inline void del(int x)\n        {\n            static Pr y,z;y=split(root,Ook(x));\n            z=split(y.second,1);\n            root=merge(y.first,z.second);\n        }\n        inline int pre(int x)\n        {\n            static int now;\n            static Pr y,z;y=split(root,Ook(x)-1);\n            z=split(y.second,1);\n            now=z.first;\n            root=merge(y.first,merge(z.first,z.second));\n            return now;\n        }\n        inline int suf(int x)\n        {\n            static int now;\n            static Pr y;y=split(root,Ook(x+1));\n            now=y.second;\n            while(*(l+now))now=*(l+now);\n            root=merge(y.first,y.second);\n            return now;\n        }\n    }p[MAXN<<2];\n    static int n,m,w[MAXN],ma[MAXN<<2],mi[MAXN<<2];\n    void make_tree(int h,int l,int r)\n    {\n        p[h].insert(2147483647);\n        p[h].insert(-2147483647);\n        if(l==r){*(ma+h)=*(mi+h)=*(w+l);return;}\n        int mid=(l+r)>>1;\n        make_tree(h<<1,l,mid);\n        make_tree(h<<1|1,mid+1,r);\n        *(ma+h)=max(*(ma+(h<<1)),*(ma+(h<<1|1)));\n        *(mi+h)=min(*(mi+(h<<1)),*(mi+(h<<1|1)));\n    }\n    void input(int h,int l,int r,int pos,int z)\n    {\n        p[h].insert(z),Chkmax(*(ma+h),z),Chkmin(*(mi+h),z);\n        if(l==r)return;\n        static int mid;mid=(l+r)>>1;\n        pos<=mid?input(h<<1,l,mid,pos,z):input(h<<1|1,mid+1,r,pos,z);\n    }\n    void modify(int h,int l,int r,int pos,int to)\n    {\n        p[h].del(*(w+pos));\n        p[h].insert(to);\n        if(l==r)\n        {\n            *(ma+h)=*(mi+h)=to;\n            return;\n        }\n        static int mid;mid=(l+r)>>1;\n        pos<=mid?modify(h<<1,l,mid,pos,to):modify(h<<1|1,mid+1,r,pos,to);\n        *(ma+h)=max(*(ma+(h<<1)),*(ma+(h<<1|1)));\n        *(mi+h)=min(*(mi+(h<<1)),*(mi+(h<<1|1)));\n    }\n    void init()\n    {\n        srand(19260817);\n        read(n);read(m);\n        make_tree(1,1,n);\n        Rep(i,1,n)read(*(w+i)),input(1,1,n,i,*(w+i));\n    }\n    int query(int h,int l,int r,int x,int y,int z)\n    {\n        if(l>=x&&r<=y)return p[h].Ook(z)-1;\n        int mid=(l+r)>>1,sum=0;\n        if(x<=mid)sum=query(h<<1,l,mid,x,y,z);\n        if(y>mid)sum+=query(h<<1|1,mid+1,r,x,y,z);\n        return sum;\n    }\n    static int ppr,ssf;\n    void pre(int h,int l,int r,int x,int y,int z)\n    {\n        static int now;now=*(num+p[h].pre(z));\n        if(now<=ppr)return;\n        if(l>=x&&r<=y){Chkmax(ppr,now);return;}\n        int mid=(l+r)>>1;\n        if(x<=mid)pre(h<<1,l,mid,x,y,z);\n        if(y>mid)pre(h<<1|1,mid+1,r,x,y,z);\n    }\n    void suf(int h,int l,int r,int x,int y,int z)\n    {\n        static int now;now=*(num+p[h].suf(z));\n        if(now>=ssf)return;\n        if(l>=x&&r<=y){Chkmin(ssf,now);return;}\n        int mid=(l+r)>>1;\n        if(x<=mid)suf(h<<1,l,mid,x,y,z);\n        if(y>mid)suf(h<<1|1,mid+1,r,x,y,z);\n    }\n    static int suu;\n    void findmi(int h,int l,int r,int x,int y)\n    {\n        if(*(mi+h)>=suu)return;\n        if(l>=x&&r<=y)\n        {\n            Chkmin(suu,*(mi+h));\n            return;\n        }\n        int mid=(l+r)>>1;\n        if(x<=mid)findmi(h<<1,l,mid,x,y);\n        if(y>mid)findmi(h<<1|1,mid+1,r,x,y);\n    }\n    void findma(int h,int l,int r,int x,int y)\n    {\n        if(*(ma+h)<=suu)return;\n        if(l>=x&&r<=y)\n        {\n            Chkmax(suu,*(ma+h));\n            return;\n        }\n        int mid=(l+r)>>1;\n        if(x<=mid)findma(h<<1,l,mid,x,y);\n        if(y>mid)findma(h<<1|1,mid+1,r,x,y);\n    }\n    inline int Chek(int l,int r,int k)\n    {\n        static int lef,rig,mid;\n        suu=2147483647;findmi(1,1,n,l,r);lef=suu;\n        suu=-2147483647;findma(1,1,n,l,r);rig=suu;\n        while(lef<=rig)\n        {\n            mid=(lef>>1)+(rig>>1)+((lef&1)&&(rig&1));\n            query(1,1,n,l,r,mid)+1>k?rig=mid-1:lef=mid+1;\n        }\n        ppr=-2147483647;\n        pre(1,1,n,l,r,rig+1);\n        return ppr;\n    }\n    void solve()\n    {\n        static int opt,l1,r1,k;\n        Rep(i,1,m)\n        {\n            read(opt);read(l1);read(r1);\n            switch(opt)\n            {\n                case 1:read(k);print(query(1,1,n,l1,r1,k)+1);break;\n                case 2:read(k);print(Chek(l1,r1,k));break;\n                case 3:modify(1,1,n,l1,r1);*(w+l1)=r1;break;\n                case 4:read(k);\n                    ppr=-2147483647;pre(1,1,n,l1,r1,k);print(ppr);break;\n                case 5:read(k);\n                    ssf=2147483647;suf(1,1,n,l1,r1,k);print(ssf);break;\n            }\n        }\n    }\n    int main(void){\n        file();\n        init();\n        solve();\n        //cerr<<1.0*clock()/CLOCKS_PER_SEC<<endl;\n        return 0;\n    }\n\n```",
        "postTime": 1516109634,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u663e\u7136\u8fd9\u9053\u9898\u662f\u6ca1\u6709\u4eba\u5199pbds\u7684\uff0c\u4e8e\u662f\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u5957pbds\u7684\u7ea2\u9ed1\u6811\u8fc7\u4e00\u53d1\u3002\n\n\u7136\u800c\u8d3c\u6162\uff0c3000\u591ams\uff0c\u4e0d\u8fc7\u4e0d\u7528\u5199\u5e73\u8861\u6811\u8fd8\u662f\u6bd4\u8f83\u9ad8\u5174\u7684\u3002\n\n\u4e8e\u662f\u6211\u4eec\u8fd9\u91cc\u7528\u5230\u4e86\u4e00\u4e2a\u7ed3\u6784\u4f53\u6765\u50a8\u5b58\u91cd\u590d\u5143\u7d20\uff0c\u5e76\u4e14\u91c7\u7528\u4e86\u5947\u6280\u6deb\u5de7\u6765\u627e\u5230\u5143\u7d20\u3002\n\n\u4e8e\u662f\u4e0b\u9762\u4f1a\u7ed9\u51fa\u4ee3\u7801\u7ec6\u8282\u90e8\u5206\u3002\n\n\u767d\u9001\u4e00\u4e2a\u7ea2\u9ed1\u6811\u662f\u4e0d\u662f\u6709\u4e9b\u5174\u594b\u5462\uff1f\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <climits>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\n#define MAXN 50005\n#define MAXM 876543\n#define INF INT_MAX\n#define Finline __inline__ __attribute__((always_inline))//\u5f3a\u884cinline\ninline char get_char(){\n    static char buf[5000001], *p1 = buf, *p2 = buf + fread(buf, 1, 5000000, stdin);\n    return p1 == p2 ? EOF : *p1 ++;\n}\ninline int read(){\n    int num = 0;\n    char c;\n    while (isspace(c = get_char()));\n    while (num = num * 10 + c - 48, isdigit(c = get_char()));\n    return num;\n}\ninline void upmin(int &a, const int &b){\n    if (a > b) a = b;\n}\ninline void upmax(int &a, const int &b){\n    if (a < b) a = b;\n}\nstruct Node{\n    int v, id;\n    Node(int a, int b){\n        v = a, id = b;\n    }\n    bool operator < (Node tar) const {\n        return v == tar.v ? id < tar.id : v < tar.v;\n    }\n};//\u7c7b\u4f3c\u4e8ehash\u53bb\u91cd......\ntypedef tree<Node, null_type, less<Node>, rb_tree_tag, tree_order_statistics_node_update> Tree;\nint n, m, lc[MAXM], rc[MAXM], cnt, times, num[MAXN], max_num;\nint tmp;//\u7ed9\u6307\u9488\u548c\u8c03\u8bd5\u8f93\u51fa\u7528\nTree stree[MAXM];\nTree::iterator it;//\u8fed\u4ee3\u5668\ninline void Build(int &node, int l, int r){\n    node = ++cnt;\n    if(l == r) return ;\n    int mid = (l + r) >> 1;\n    Build(lc[node], l, mid), Build(rc[node], mid + 1, r);//\u8282\u7ea6\u7a7a\u95f4\u7684\u7ebf\u6bb5\u6811\n}\ninline void Insert(int node, int l, int r, int k, int val){\n    stree[node].insert(Node(val, ++times));\n    if(l == r){\n        upmax(max_num, val);\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if(k <= mid) Insert(lc[node], l, mid, k, val);\n    else Insert(rc[node], mid + 1, r, k, val);\n}\ninline int Get_Rank(int node, int l, int r, int ls, int rs, int val){\n    if(l == ls && r == rs) return tmp = stree[node].order_of_key(Node(val, times + 1));//\u6ce8\u610f\u8fd9\u91cc\u5141\u8bb8\u91cd\u590d\n    int mid = (l + r) >> 1;\n    if(rs <= mid) return Get_Rank(lc[node], l, mid, ls, rs, val);\n    if(ls > mid) return Get_Rank(rc[node], mid + 1, r, ls, rs, val);\n    return Get_Rank(lc[node], l, mid, ls, mid, val) + Get_Rank(rc[node], mid + 1, r, mid + 1, rs, val);\n}\ninline int Get_Rank_Lager(int node, int l, int r, int ls, int rs, int val){\n    if(l == ls && r == rs) return tmp = stree[node].order_of_key(Node(val, 0));//\u6ce8\u610f\u8fd9\u91cc\u4e0d\u5141\u8bb8\u91cd\u590d\n    int mid = (l + r) >> 1;\n    if(rs <= mid) return Get_Rank_Lager(lc[node], l, mid, ls, rs, val);\n    if(ls > mid) return Get_Rank_Lager(rc[node], mid + 1, r, ls, rs, val);\n    return Get_Rank_Lager(lc[node], l, mid, ls, mid, val) + Get_Rank_Lager(rc[node], mid + 1, r, mid + 1, rs, val);\n}\ninline int Get_Kth(int ls, int rs, int k){\n    int l = 0, r = max_num + 1, mid, cnt;\n    while(l < r){\n        mid = (l + r) >> 1;\n        cnt = Get_Rank(1, 1, n, ls, rs, mid);\n        if(cnt < k) l = mid + 1;\n        else r = mid;\n    }\n    return l;//\u4e8c\u5206\u627ekth\n}\ninline void Change(int node, int l, int r, int k, int val){\n    it = stree[node].lower_bound(Node(num[k], 1));\n    stree[node].erase(it), stree[node].insert(Node(val, ++times));//\u6ce8\u610f\u8fd9\u91cc\u8c28\u614e\u76f4\u63a5erase\u503c\uff0c\u5426\u5219\u4f1a\u5220\u9664\u91cd\u590d\u5143\u7d20\uff08\u5728\u8fd9\u4efd\u4ee3\u7801\u91cc\u5176\u5b9e\u4e0d\u9700\u8981\uff09\n    if(l == r){\n        upmax(max_num, val);\n        num[k] = val;\n        return ;\n    }\n    int mid = (l + r) >> 1;\n    if(k <= mid) Change(lc[node], l, mid, k, val);\n    else Change(rc[node], mid + 1, r, k, val);\n}\ninline int Get_Pre(int node, int l, int r, int ls, int rs, int val){\n    if(l == ls && r == rs){\n        it = stree[node].lower_bound(Node(val, 0));\n        it--;//\u6ce8\u610f--\uff0clower_bound\u5141\u8bb8\u7b49\u4e8e\n        return it == stree[node].end() ? -INF : it -> v;\n    }\n    int mid = (l + r) >> 1;\n    if(rs <= mid) return Get_Pre(lc[node], l, mid, ls, rs, val);\n    if(ls > mid) return Get_Pre(rc[node], mid + 1, r, ls, rs, val);\n    return max(Get_Pre(lc[node], l, mid, ls, mid, val), Get_Pre(rc[node], mid + 1, r, mid + 1, rs, val));\n}\ninline int Get_Nxt(int node, int l, int r, int ls, int rs, int val){\n    if(l == ls && r == rs){\n        it = stree[node].upper_bound(Node(val, times + 1));//upper_bound\u4e0d\u5141\u8bb8\n        return it == stree[node].end() ? INF : it -> v;//\u6ce8\u610f\u5224\u65adit\uff0c\u4e00\u5b9a\u9700\u8981\n    }\n    int mid = (l + r) >> 1;\n    if(rs <= mid) return Get_Nxt(lc[node], l, mid, ls, rs, val);\n    if(ls > mid) return Get_Nxt(rc[node], mid + 1, r, ls, rs, val);\n    return min(Get_Nxt(lc[node], l, mid, ls, mid, val), Get_Nxt(rc[node], mid + 1, r, mid + 1, rs, val));\n}\nint main(){\n    n = read(), m = read();\n    Build(tmp, 1, n);\n    for(int i = 1; i <= n; i++) Insert(1, 1, n, i, num[i] = read());\n    for(int i = 1; i <= m; i++){\n        int cons = read(), l, r, val;\n        switch(cons){\n            case 1:\n                l = read(), r = read(), val = read();\n                printf(\"%d\\n\", Get_Rank_Lager(1, 1, n, l, r, val) + 1);\n                break;\n            case 2:\n                l = read(), r = read(), val = read();\n                printf(\"%d\\n\", Get_Kth(l, r, val));\n                break;\n            case 3:\n                l = read(), val = read();\n                Change(1, 1, n, l, val);\n                break;\n            case 4:\n                l = read(), r = read(), val = read();\n                printf(\"%d\\n\", Get_Pre(1, 1, n, l, r, val));\n                break;\n            case 5:\n                l = read(), r = read(), val = read();\n                printf(\"%d\\n\", Get_Nxt(1, 1, n, l, r, val));\n                break;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1514557199,
        "uid": 43464,
        "name": "Creeper_LKF",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u8bf7\u70b9\u8fd9\u91cc](https://www.cnblogs.com/BrianPeng/p/12702028.html)\n\n# \u4e8c\u903c\u5e73\u8861\u6811\u7684\u4e00\u79cd\u4e8c\u903c\u5199\u6cd5\n\n~~\u770b\u5230$n,m\\leqslant 5\\times 10^4$\u7684\u6570\u636e\u8303\u56f4\uff0c\u672c\u849f\u84bb\u4e0d\u7981\u5fc3\u751f\u90aa\u5ff5~~\n\n\u5927\u5bb6\u597d\uff0c\u6211\u975e\u5e38\u559c\u6b22\u66b4\u529b\u7b97\u6cd5\uff0c\u6240\u4ee5\u7528**\u5e26\u4fee\u83ab\u961f**\u8fc7\u4e86\u8fd9\u9053\u9898\n\n## \u524d\u7f6e\u829d\u58eb\n\n**1. \u5e26\u4fee\u83ab\u961f**\n\n**2. \u6811\u72b6\u6570\u7ec4**\n\n\uff08\u672c\u849f\u84bb\u7684\u535a\u5ba2\u8fd8\u4e0d\u591f\u5b8c\u5584 sorry\uff0c\u4e4b\u540e\u4f1a\u8865\u4e0a\u8fd9\u4e9b\u77e5\u8bc6\u70b9\uff09\n\n## \u6b63\u9898\n\n\u5047\u8bbe\u73b0\u5728\u6709\u8fd9\u6837\u4e00\u4e2a\u795e\u5668\u53ef\u4ee5\u9ad8\u6548\u6ee1\u8db3\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n1. \u52a0\u5165\u4e00\u4e2a\u6570\n\n2. \u5220\u9664\u4e00\u4e2a\u6570\n\n3. \u6c42\u4e00\u4e2a\u6570\u7684\u6392\u540d\n\n4. \u6c42\u67d0\u6392\u540d\u7684\u6570\n\n5. \u6c42\u4e00\u4e2a\u6570\u7684\u524d\u9a71\n\n6. \u6c42\u4e00\u4e2a\u6570\u7684\u540e\u7ee7\n\n\u8bf6\uff0c\u7b49\u7b49\uff0c\u8fd9\u4e0d\u5c31\u662f\u666e\u901a\u5e73\u8861\u6811\u5417\uff1f\uff1f\uff1f\n\n\u522b\u6025\uff0c\u6709\u66f4\u597d\u7684\u65b9\u6cd5\n\n\u73b0\u5728\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u4e2a\u795e\u5668\u6570\u636e\u7ed3\u6784\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5e26\u4fee\u83ab\u961f\u7684\u4e8b\u60c5\u4e86\n\n\u5e26\u4fee\u83ab\u961f\u6bd4\u666e\u901a\u83ab\u961f\u591a\u4e86\u4e00\u4e2a\u65f6\u95f4\u7ef4\uff0c\u6240\u4ee5\u4ee5$b=n^{\\frac{2}{3}}$\u4e3a\u957f\u5ea6\u5bf9\u6240\u6709\u8be2\u95ee\u7684$l,r$\u5206\u5757\uff0c\u5177\u4f53\u6765\u8bf4\u5c31\u662f\u5bf9\u6240\u6709\u8be2\u95ee\u6309\u7167$\\lfloor l/b\\rfloor,\\lfloor r/b\\rfloor$\u548c\u65f6\u95f4\u4f5c\u4e09\u5173\u952e\u5b57\u6392\u5e8f\n\n\u4e8e\u662f\u8be2\u95ee\u5c31\u53d8\u6210\u4e86\uff1a\n\n\u521d\u59cb\u5316\u6307\u9488$l=1,r=0,t=0$\uff0c\u5206\u522b\u8868\u793a\u76ee\u524d\u533a\u95f4\u5de6\u7aef\u70b9\uff0c\u53f3\u7aef\u70b9\u548c\u65f6\u95f4\uff0c\u5e76\u4e14\u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784\u4e3a\u7a7a\n\n\u8bbe\u672c\u6b21\u8be2\u95ee\u7684\u6307\u9488\u4e3a$l_q,r_q,t_q$\n\n\u4e8e\u662f\u5c31\u8981\u628a$l,r,t$\u79fb\u52a8\u5230$l_q,r_q,t_q$\uff0c\u7136\u540e\u4ece\u6570\u636e\u7ed3\u6784\u4e2d\u76f4\u63a5\u5f97\u5230\u7b54\u6848\n\n\u5177\u4f53\u79fb\u52a8\u65b9\u5f0f\u5982\u4e0b\uff1a\n\n\u8bbe\u5e8f\u5217\u4e3a$a_{1..n}$\uff0c$mt$\u65f6\u95f4\u7684\u64cd\u4f5c\u4f4d\u7f6e\u4e3a$p_{t}$\uff0c\u6539\u4e3a\u6570\u5b57$k_{t}$\n\n\u5982\u679c$l>l_q$\uff0c\u90a3\u4e48\u5c31\u5c06$l-1$\u52a0\u5165\u6570\u636e\u7ed3\u6784\uff0c$l=l-1$\n\n\u5982\u679c$l<l_q$\uff0c\u90a3\u4e48\u5c31\u5c06$l$\u4ece\u6570\u636e\u7ed3\u6784\u4e2d\u5220\u9664\uff0c$l=l+1$\n\n$r$\u540c\u7406\n\n\u5982\u679c$t<t_q$\uff0c\u90a3\u4e48$a_{p_{t+1}}$\u5c31\u8981\u6539\u6210$k_{t+1}$\uff0c\u6b64\u65f6\u5c06$a_{p_{t+1}}$\u4e0e$k_{t+1}$\u4ea4\u6362\uff0c\u5982\u679c$a_{p_{t+1}}$\u5728$l,r$\u4e4b\u95f4\u5c31\u8981\u4fee\u6539\u6570\u636e\u7ed3\u6784\uff0c\u6700\u540e$t=t+1$\n\n\u5982\u679c$t>t_q$\uff0c\u90a3\u4e48\u5c06$a_{p_{t}}$\u4e0e$k_t$\u6362\u56de\u6765\uff0c\u7ef4\u62a4\u6570\u636e\u7ed3\u6784\uff0c$t=t-1$\n\n\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u7b97\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5df2\u7ecf\u6709\u4e86$O(n^\\frac{5}{3})$\u7684\u56e0\u5b50\n\n\u6240\u4ee5\u63a5\u4e0b\u6765\u5c31\u8981\u770b\u795e\u5668\u7684\u8868\u73b0\u4e86\n\n\u89e3\u51b3\u8fd9\u7c7b\u95ee\u9898\uff0c\u5e73\u8861\u6811\u4e0e\u7ebf\u6bb5\u6811\u90fd\u5177\u6709$O(\\log n)$\u7684\u4f18\u79c0\u590d\u6742\u5ea6\uff0c\u4f46\u662f\u5e38\u6570\u5728\u8fd9\u91cc\u5403\u4e0d\u6d88\n\n\u83ab\u961f\u5df2\u7ecf\u662f\u4e00\u79cd\u79bb\u7ebf\u7b97\u6cd5\u4e86\n\n\u90a3\u6211\u4eec\u5c31\u628a\u79bb\u7ebf\u7684\u65b9\u6cd5\u7528\u5230\u5e95\u5427\uff01\n\n### Step 1: \u79bb\u6563\u5316\n\n\u5c06\u6570\u636e\u4ece$10^8$\u8303\u56f4\u7f29\u5c0f\u5230$10^5$\u8303\u56f4\uff0c\u4f18\u5316\u533a\u95f4\u5904\u7406\u6570\u636e\u7ed3\u6784\u7684\u590d\u6742\u5ea6\n\n### Step 2: \u6743\u503c\u6811\u72b6\u6570\u7ec4\n\n\u7ebf\u6bb5\u6811\u7684\u5e38\u6570\u8fd8\u662f\u592a\u5927\uff0c\u6211\u4eec\u5c06\u6811\u72b6\u6570\u7ec4\u6269\u5c55\u4e3a\u6743\u503c\u6811\u72b6\u6570\u7ec4\n\n\u9996\u5148\u6811\u72b6\u6570\u7ec4\u7684\u4e24\u4e2a\u57fa\u672c\u65b9\u6cd5\uff1a\n\n1. $\\rm{modify}$$(x,v)$\u8868\u793a\u5c06\u5e8f\u5217\u7b2c$x$\u4f4d\u503c\u589e\u52a0$v$\n\n2. $\\rm{query}$$(x)$\u8868\u793a\u6c42\u5e8f\u5217\u7b2c$x$\u4f4d\u524d\u7f00\u548c\n\n\u5728\u6b64\u5f15\u5165\u7b2c\u4e09\u4e2a\u65b9\u6cd5$\\rm kth$$(k)$\u8868\u793a\u6c42\u6700\u5c0f\u7684$x$\u4f7f\u5f97$\\rm{query}$$(x)\\geqslant k$\uff0c\u4e5f\u5c31\u662f\u6c42\u7b2c$k$\u540d\n\n\u4ece\u5b9a\u4e49\u4e0a\u770b\u53ef\u4ee5\u4e8c\u5206$x$\u5b8c\u6210\uff0c\u4f46\u662f\u65f6\u95f4\u590d\u6742\u5ea6$O(\\log^2 n)$\n\n\u5728\u6b64\u7ed9\u51fa\u4e00\u4e2a$O(\\log n)$\u7684\u65b9\u6cd5\uff1a\n\n\u8bbe\u6811\u72b6\u6570\u7ec4$t_{1..m}$\uff0c\u6211\u4eec\u9700\u8981\u8fdb\u884c\u4e00\u4e9b\u6269\u5c55\n\n\u5b9a\u4e49$rt$\u4e3a\u6700\u5927\u7684\u4e00\u4e2a$\\leqslant m$\u7684$2$\u7684\u5e42\uff0c\u4e3a\u6811\u72b6\u6570\u7ec4\u7684\u6839\u8282\u70b9\n\n\u4e8e\u662f$\\rm lowbit$$(rt)$\u662f\u6700\u5927\u7684\n\n\u628a\u6811\u72b6\u6570\u7ec4\u60f3\u8c61\u6210\u4e00\u68f5\u4e8c\u53c9\u6811\uff0c\u5982\u56fe$m=10,rt=8$\uff0c\u662f\u4e0d\u662f\u5f88\u773c\u719f\n\n![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1699892/o_200414141203%E7%A9%BA.png)\n\n\u5982\u679c$u$\u662f\u5947\u6570\uff0c\u90a3\u4e48\u5b83\u662f\u53f6\u5b50\n\n\u5b9a\u4e49$u$\u8282\u70b9\u7684\u5de6\u513f\u5b50$ls$\u4e3a\u8868\u793a\u81ea\u5df1\u5de6\u534a\u90e8\u5206\u7684\u8282\u70b9\uff0c\u53f3\u513f\u5b50$rs$\u4e3a$ls$\u52a0\u4e0a$u$\u8282\u70b9\u957f\u5ea6\u7684\u7684\u8282\u70b9\n\n\u597d\u6df7\u4e71\uff0c\u8fd8\u662f\u4e0a\u56fe\u5427\uff08\u7ea2\u7ebf\u8868\u793a\u5de6\u513f\u5b50\uff0c\u84dd\u7ebf\u8868\u793a\u53f3\u513f\u5b50\uff09\n\n![](https://images.cnblogs.com/cnblogs_com/BrianPeng/1699892/o_200414141835%E6%A0%91.png)\n\n\u7ed9\u51fa\u8ba1\u7b97\u516c\u5f0f$ls=u-$$\\rm lowbit$$(u)/2,rs=u+$$\\rm lowbit$$(u)/2$\n\n\u5982\u679c$rs>m$\uff0c\u6bd4\u5982$u=8$\u7684\u60c5\u51b5\uff0c\u5c31\u8ba9\u5b83\u4e0d\u65ad\u8df3$ls$\u76f4\u5230$\\leqslant m$\n\n\u73b0\u5728\u5f00\u59cb\u5b9e\u73b0$\\rm kth$$(k)$\n\n\u521d\u59cb\u5316\u5f53\u524d\u8282\u70b9$u=rt$\uff0c\u7b54\u6848$r=m$\n\n\u5982\u679c$t_u\\geqslant k$\uff0c\u8bf4\u660e$u$\u662f\u4e00\u4e2a\u53ef\u80fd\u7b54\u6848\uff0c\u4e8e\u662f$r=u,u=ls$\u7ee7\u7eed\u67e5\u627e\n\n\u5982\u679c$t_u<k$\uff0c\u8bf4\u660e\u7b54\u6848\u5728$u$\u7684\u53f3\u8fb9\uff0c\u4e8e\u662f\uff1a\n\n1. $k=k-t_u$\uff0c\u56e0\u4e3a$t_{rs}$\u4e0d\u5305\u542b$u$\u53ca\u4e4b\u524d\u7684\u5185\u5bb9\uff0c\u6240\u4ee5\u51cf\u53bb\n\n2. $u=rs$\uff0c\u5e76\u5982\u679c$u>m$\uff0c\u91cd\u590d\u6267\u884c$u=ls$\u76f4\u5230$u\\leqslant m$\n\n\u6700\u540e\uff0c\u5982\u679c$u$\u662f\u5947\u6570\uff0c\u8bf4\u660e\u5df2\u7ecf\u5230\u8fbe\u53f6\u5b50\uff0c\u8fd4\u56de$r$\u4e3a\u7b54\u6848\n\nP.s \u5728\u4ee3\u7801\u4e2d\u4e3a\u4e86\u65b9\u4fbf\u76f4\u63a5\u8bbe\u5947\u6570$u$\u7684$ls=rs=0$\n\n\u4e8e\u662f\u8fd9\u6837\u5c31\u5b8c\u6210\u4e86$O(\\log n)$\u7684$\\rm kth$$(k)$\u65b9\u6cd5\n\n\u53ea\u8981\u6709\u4e86\u8fd9\u4e9b\uff0c\u5c31\u53ef\u4ee5\u5b8c\u6210\u5168\u90e8\u7684\u67e5\u8be2\n\n\u9996\u5148\u4e3a\u4e86\u65b9\u4fbf\uff0c\u5728\u6570\u636e\u7ed3\u6784\u4e2d\u76f4\u63a5\u52a0\u5165\u4e00\u4e2a$2147483647$\u548c$-2147483647$\n\n\u770b\u4e00\u4e0b\u9700\u8981\u7684\u64cd\u4f5c\uff1a\n\n1. \u52a0\u5165\u4e00\u4e2a\u6570$x$\uff1a\u76f4\u63a5\u6267\u884c$\\rm{modify}$$(x,1)$\n\n2. \u5220\u9664\u4e00\u4e2a\u6570$x$\uff1a\u76f4\u63a5\u6267\u884c$\\rm{modify}$$(x,-1)$\n\n3. \u6c42\u4e00\u4e2a\u6570$x$\u7684\u6392\u540d\uff1a\u56e0\u4e3a\u5df2\u7ecf\u63d2\u5165$-2147483647$\uff0c\u6240\u4ee5$\\rm{query}$$(x-1)$\u5c31\u662f\u7b54\u6848\n\n4. \u6c42\u6392\u540d\u4e3a$k$\u7684\u6570\uff1a\u56e0\u4e3a\u5df2\u7ecf\u63d2\u5165$-2147483647$\uff0c\u6240\u4ee5\u7b54\u6848\u662f$\\rm kth$$(k+1)$\n\n5. \u6c42\u4e00\u4e2a\u6570$x$\u7684\u524d\u9a71\uff1a\u4e00\u4e2a\u6570\u7684\u524d\u9a71\u662f\u6392\u540d\u4e3a$(x$\u7684\u6392\u540d$-1)$\u7684\u6570\n\n6. \u6c42\u4e00\u4e2a\u6570\u7684\u540e\u7ee7\uff1a\u4e00\u4e2a\u6570\u7684\u540e\u7ee7\u662f\u6392\u540d\u4e3a$(\\leqslant x$\u7684\u6570\u7684\u6570\u91cf$+1)$\u7684\u6570\n\n\uff08\u6ca1\u9519\uff0c\u8fd9\u4e2a\u6743\u503c\u6811\u72b6\u6570\u7ec4\u53ef\u4ee5\u76f4\u63a5\u8fc7\u6389\u53ef\u79bb\u7ebf\u7684\u666e\u901a\u5e73\u8861\u6811\u6a21\u677f\uff0c\u800c\u4e14\u8d3c\u5feb\uff09\n\n\u6700\u540e\u662f\u4e00\u4e9b\u5361\u5e38\u6280\u5de7\uff1a\n\n1. \u6253\u5f00\u90aa\u6076\u7684Ofast\uff1a\u6ee1\u6570\u636e\u5f00\u4e86$10$s\uff0c\u4e0d\u5f00$30$s\uff08\u54c7\u585e\uff09\n\n2. \u4e8b\u5148\u5c06\u6240\u6709\u7684$a_i$\u548c$k_i$\u5168\u90e8\u53d8\u6210\u79bb\u6563\u5316\u4e4b\u540e\u7684\u4e0b\u6807\uff0c\u8fd9\u6837\u624d\u53ef\u4ee5\u5145\u5206\u5229\u7528\u6811\u72b6\u6570\u7ec4\u7684\u4f18\u52bf\uff1a\u7528\u4e86$1$s\uff0c\u4e0d\u7528$10$s\uff08\u597d\u53ef\u6015\uff09\n\n3. ~~\u628a\u8138\u6d17\u5e72\u51c0~~\n\n**Time complexity:** $O(n^\\frac{5}{3}\\log n)$\uff08\u771f\u60ca\u9669\uff09\n\n**Memory complexity:** $O(n)$\n\n\u7ec6\u8282\u89c1\u4ee3\u7801\uff08$3.07$s / $3.19$MB\uff09\uff08\u867d\u7136\u65f6\u95f4\u53ef\u80fd\u6709\u70b9\u957f\uff0c\u4f46\u662f\u7a7a\u95f4\u7edd\u5bf9\u78be\u538b\u6811\u5957\u6811\uff09\n\nP.s \u5728\u8fd9\u91cc\u79bb\u6563\u5316\u6570\u7ec4\u4e3a$d$\uff0c\u6811\u72b6\u6570\u7ec4\u4e3a$t$\uff0c\u56e0\u4e3a\u5b9e\u5728\u61d2\u5f97\u5f00\u53d8\u91cf\u4e86\u5c31\u76f4\u63a5\u7528$*d$\uff08\u5373$d_0$\uff09\u6765\u50a8\u5b58\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f\u6587\u4e2d\u7684$m$\n\n```cpp\n//This program is written by Brian Peng.\n#pragma GCC optimize(\"Ofast\",\"inline\",\"no-stack-protector\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define Rd(a) (a=read())\n#define Gc(a) (a=getchar())\n#define Pc(a) putchar(a)\nint read(){\n\tint x;char c(getchar());bool k;\n\twhile(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);\n\tc^'-'?(k=1,x=c&15):k=x=0;\n\twhile(isdigit(Gc(c)))x=x*10+(c&15);\n\treturn k?x:-x;\n}\nvoid wr(int a){\n\tif(a<0)Pc('-'),a=-a;\n\tif(a<=9)Pc(a|'0');\n\telse wr(a/10),Pc((a%10)|'0');\n}\nsigned const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);\nlong long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);\n#define Ps Pc(' ')\n#define Pe Pc('\\n')\n#define Frn0(i,a,b) for(int i(a);i<(b);++i)\n#define Frn1(i,a,b) for(int i(a);i<=(b);++i)\n#define Frn_(i,a,b) for(int i(a);i>=(b);--i)\n#define Mst(a,b) memset(a,b,sizeof(a))\n#define File(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\n#define N (50010)\n#define D (100010)\n#define Ls (u&1?0:u-((u&-u)>>1))\n#define Rs (u&1?0:u|((u&-u)>>1))\nint n,m,b,rt,t[D],d[D]{1,-2147483647},a[N],l(1),r,mt,ans[N];\nstruct Q{int o,l,r,k,t,i;}q[N];\nstruct{int p,k;}o3[N];\nbool cmp(int a,int b,bool c){return a!=b?a<b:c;}\nvoid mdf(int x,int v){while(x<=*d)t[x]+=v,x+=x&-x;}\nint ps(int x){return lower_bound(d+1,d+*d+1,x)-d;}\nint qry(int x){int r(0);while(x)r+=t[x],x^=x&-x;return r;}\nint kth(int x);\nsigned main(){\n\tRd(n),Rd(m),b=pow(n,0.67)+1;\n\tFrn1(i,1,n)d[++*d]=Rd(a[i]);\n\tFrn1(i,1,m)if(Rd(q[i].o)==3)o3[++mt]={read(),Rd(d[++*d])},--i,--m;\n\t\telse q[i]={q[i].o,read(),read(),read(),mt,i},q[i].o==2?0:(d[++*d]=q[i].k);\n\td[++*d]=2147483647,sort(d+2,d+*d),rt=*d=unique(d+1,d+*d+1)-d-1;\n\tFrn1(i,1,n)a[i]=ps(a[i]);\n\tFrn1(i,1,mt)o3[i].k=ps(o3[i].k);\n\twhile(rt^(rt&-rt))rt^=rt&-rt;\n\tsort(q+1,q+m+1,[](Q x,Q y){return cmp(x.l/b,y.l/b,cmp(x.r/b,y.r/b,x.t<y.t));});\n\tmdf(1,1),mdf(*d,1),mt=0;\n\tFrn1(i,1,m){\n\t\twhile(r<q[i].r)mdf(a[++r],1);\n\t\twhile(l>q[i].l)mdf(a[--l],1);\n\t\twhile(r>q[i].r)mdf(a[r--],-1);\n\t\twhile(l<q[i].l)mdf(a[l++],-1);\n\t\twhile(mt<q[i].t){\n\t\t\t++mt,swap(a[o3[mt].p],o3[mt].k);\n\t\t\tif(l<=o3[mt].p&&o3[mt].p<=r)mdf(o3[mt].k,-1),mdf(a[o3[mt].p],1);\n\t\t}\n\t\twhile(mt>q[i].t){\n\t\t\tif(l<=o3[mt].p&&o3[mt].p<=r)mdf(a[o3[mt].p],-1),mdf(o3[mt].k,1);\n\t\t\tswap(a[o3[mt].p],o3[mt].k),--mt;\n\t\t}\n\t\tswitch(q[i].o){\n\t\t\tcase 1:ans[q[i].i]=qry(ps(q[i].k)-1);break;\n\t\t\tcase 2:ans[q[i].i]=d[kth(q[i].k+1)];break;\n\t\t\tcase 4:ans[q[i].i]=d[kth(qry(ps(q[i].k)-1))];break;\n\t\t\tcase 5:ans[q[i].i]=d[kth(qry(ps(q[i].k))+1)];\n\t\t}\n\t}\n\tFrn1(i,1,m)wr(ans[i]),Pe;\n\texit(0);\n}\nint kth(int k){\n\tint u(rt),r(*d);\n\twhile(u)if(k<=t[u])r=u,u=Ls;\n\t\telse{k-=t[u],u=Rs;while(u>*d)u=Ls;}\n\treturn r;\n}\n```",
        "postTime": 1586876584,
        "uid": 66199,
        "name": "Bring",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8fd9\u4e2a\u9898\u6700\u7ecf\u5178\u7684\u505a\u6cd5\u662f\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\uff0c\u5f53\u7136\u7ebf\u6bb5\u6811\u5957\u7ebf\u6bb5\u6811\u663e\u7136\u65f6\u95f4\u590d\u6742\u5ea6\u66f4\u4f18\u4e00\u70b9\uff0c\u662f$log(n) ^ 2$\u7684\n\n\u90a3\u4e48\u4f17\u6240\u5468\u77e5\uff0c\u6570\u636e\u7ed3\u6784\u53ef\u4ee5\u6539\u6210\u5206\u5757\u6765\u7ef4\u62a4\uff0c\u90a3\u4e48\u8fd9\u4e2a\u9898\u53ef\u4e0d\u53ef\u4ee5\u5462\uff1f\n\n\u5b9e\u9645\u4e0a\u5f53\u7136\u662f\u53ef\u4ee5\u7684\uff0c\u800c\u4e14\u5982\u679c\u5957\u5f97\u5408\u9002\uff0c\u53ef\u4ee5\u505a\u5230\u4ecd\u7136\u662f\u4e00\u4e2a$\\sqrt n$\u7684\u590d\u6742\u5ea6\uff0c\u800c\u4e0d\u662f\u4ec0\u4e48\u9b3c\u755c\u7684$(\\sqrt n) ^ 2$\n\n\u6574\u4f53\u601d\u8def\u4eff\u7167\u6743\u503c\u7ebf\u6bb5\u6811\u5957\u533a\u95f4\u7ebf\u6bb5\u6811\uff0c\u6539\u4e3a\u6743\u503c\u5206\u5757\u5957\u533a\u95f4\u5206\u5757\n\n**\u5bf9\u4e8e\u4e00\u4e2a\u8fde\u7eed\u7684\u6743\u503c\u5757\uff0c\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u7684\u6570\u5728\u8fd9\u4e2a\u6743\u503c\u5757\u7684\u51fa\u73b0\u6b21\u6570**\n\n**\u5bf9\u4e8e\u6bcf\u4e2a\u6743\u503c\u70b9\uff0c\u4e5f\u8981\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u7684\u6570\u5728\u8fd9\u4e2a\u6743\u503c\u7684\u51fa\u73b0\u6b21\u6570**\n\n* \u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u4ece\u5de6\u5411\u53f3\u626b\u8fc7\u6bcf\u4e2a\u7b26\u5408\u6761\u4ef6(\u53f3\u7aef\u70b9$ \\le k$)\u7684\u6743\u503c\u5757\uff0c\u6bcf\u6b21\u7d2f\u52a0\u5728$[l,r]$\u91cc\u7684\u70b9\u7684\u6570\u91cf\uff0c\u7136\u540e\u518d\u67e5\u8be2\u96f6\u6563\u7684\u90e8\u5206\n\n* \u5bf9\u4e8e\u64cd\u4f5c\u4e8c\uff0c\u4ece\u5de6\u5411\u53f3\u626b\u8fc7\u6bcf\u4e2a\u6743\u503c\u5757\uff0c\u5f53\u5728$[l,r]$\u91cc\u7684\u70b9\u7d2f\u8ba1$\\ge k$\u7684\u65f6\u5019\uff0c\u66b4\u529b\u626b\u4e00\u904d\u6700\u540e\u90a3\u4e2a\u5757\n\n* \u5bf9\u4e8e\u64cd\u4f5c\u4e09\uff0c\u4fee\u6539\u6743\u503c\u5757\u91cc\u7684\u5185\u5bb9\u548c\u6743\u503c\u70b9\u91cc\u7684\u5185\u5bb9\n\n* \u5bf9\u4e8e\u64cd\u4f5c\u56db\uff0c\u67e5\u8be2\u51fa\u6709$rnk$\u4e2a\u6570$< k$\uff0c\u7136\u540e\u627e\u6392\u540d\u4e3a$rnk$\u7684\u6570\uff0c\u5f53$rnk = 0$\u65f6\uff0c\u8f93\u51fa$-inf$\n\n* \u5bf9\u4e8e\u64cd\u4f5c\u4e94\uff0c\u67e5\u8be2\u51fa\u6709$rnk$\u4e2a\u6570$\\le k$\uff0c\u7136\u540e\u627e\u6392\u540d\u4e3a$rnk + 1$\u7684\u6570\uff0c\u5f53$rnk = r - l + 1$\u65f6\uff0c\u8f93\u51fa$inf$\n\n\u90a3\u4e48\u95ee\u9898\u6765\u4e86\uff0c\u5185\u90e8\u7528\u4ec0\u4e48\u4e1c\u897f\u7ef4\u62a4\u5462\uff1f\u6211\u4eec\u9700\u8981\u5feb\u901f\u67e5\u8be2$[l,r]$\u7684\u548c\uff0c\u6216\u8005\u4fee\u6539(\u6b21\u6570\u8f83\u5c11)\u4e00\u4e2a\u70b9\u7684\u503c\n\n\u4f60\u5f53\u7136\u53ef\u4ee5\u7528\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u6765\u505a\uff0c\u8fd9\u6837\u5199\u8d77\u6765\u65b9\u4fbf\uff0c\u4f46\u662f\u8fd9\u6837\u5e26\u4e2a$log(n)$\uff0c\u590d\u6742\u5ea6\u4e0d\u592a\u597d\n\n\u6240\u4ee5\u5185\u90e8\u8981\u4f7f\u7528\u5206\u5757\u7ef4\u62a4\uff0c\u6bcf\u6b21\u7ef4\u62a4\u4e00\u4e2a\u524d\u7f00\u548c\uff0c\u8fd9\u6837\u5c31\u662f\u533a\u95f4\u4fee\u6539\u3001\u5355\u70b9\u67e5\u8be2\uff0c\u53ef\u4ee5\u8f7b\u677e\u505a\u5230\u4fee\u6539$O(\\sqrt n)$\uff0c\u67e5\u8be2$O(1)$\n\n\u4f46\u662f\u95ee\u9898\u6765\u4e86\uff0c\u6211\u4eec\u8981\u7ef4\u62a4\u6bcf\u4e2a\u6743\u503c\u70b9\u7684\u4fe1\u606f\uff0c\u6bcf\u4e2a\u6743\u503c\u70b9\u90fd\u5f00\u8fd9\u4e2a\u7a7a\u95f4$O(n)$\u7684\u5206\u5757\u6570\u7ec4\u663e\u7136\u8981\u51c9\n\n\u6240\u4ee5\u4f60\u5f97\u641e\u4e00\u4e2a\u52a8\u6001\u5f00\u70b9\u5206\u5757\uff0c\u6bcf\u6b21\u53ea\u6709\u5728\u4fee\u6539\u96f6\u6563\u5757\u7684\u4fe1\u606f\u7684\u65f6\u5019\uff0c\u624d\u5efa\u51fa\u8fd9\u4e2a\u96f6\u6563\u5757\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u63a7\u5236\u7a7a\u95f4\n\n\u5f53\u4f60\u8f9b\u8f9b\u82e6\u82e6\u5199\u5b8c\u3001\u8c03\u5b8c\uff0c\u4ea4\u4e0a\u53bb\u65f6\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/xopjvmy6.png))\n\n\u76f4\u63a5MLE\uff0c\u5f7b\u5e95\u53bb\u4e16\n\n\u6240\u4ee5\u4f60\u5c31\u5f97\u5f00\u59cb\u5361\u7a7a\u95f4\n\n\u6211\u4e5f\u4e0d\u592a\u60f3\u5199\u5361\u7a7a\u95f4\u7684\u8fc7\u7a0b\u4e86\uff0c\u53cd\u6b63\u5f88\u8270\u96be\uff0c\u76f4\u63a5\u653e\u6700\u540e\u7684AC\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nint n,m;\nint p[50005];//\u7528\u4e8e\u5b58\u539f\u6570\u7ec4\u6bcf\u4e2a\u4f4d\u7f6e\u7684\u4fe1\u606f\n\n#define us unsigned short \n\nqueue <int> que;//\u8fd9\u4e2a\u662f\u53ef\u7528\u5185\u5b58\u5206\u914d\u6c60\uff0c\u662f\u5faa\u73af\u7684\uff0c\u5b58\u6bcf\u4e2a\u53ef\u7528\u5185\u5b58\u5757\u7684\u8d77\u70b9 \nus arr[22700005];//\u53ef\u7528\u5185\u5b58\u6c60\uff0c\u5c31\u662f\u5e95\u5c42\u5206\u5757\u7528\u7684\uff0c\u56e0\u4e3an = 50000\uff0c\u6240\u4ee5\u6bcf\u4e2a\u503c\u57df\u80af\u5b9a\u81f3\u591a\u53ea\u670950000\u4e2a\u6570\uff0cunsigned short\u52c9\u5f3a\u5b58\u7684\u4e0b\n\n#define BLOCK_LEN 223//\u5e95\u5c42\u5757\u957f \n\nstruct array{//\u7a0d\u5fae\u5c01\u88c5\u4e0b\uff0c\u5426\u5219\u592a\u96be\u5199\n\tus tag[226];//\u6bcf\u4e2a\u5757\u7684\u52a0\u6cd5tag\uff0c\u4e5f\u662funsigned short\u52c9\u5f3a\u5b58\u7684\u4e0b \n\tint T[226];//\u5b58\u6bcf\u4e2a\u5757\u7684\u5185\u5b58\u5757\u7684\u8d77\u70b9 - \u5757\u7684\u5de6\u7aef\u70b9\uff0c\u8fd9\u6837\u5199\u662f\u4e3a\u4e86\u65b9\u4fbf \n\t#define Bfrom(x) ((x % BLOCK_LEN == 0) ? (x / BLOCK_LEN) : (x / BLOCK_LEN + 1))\n\t#define BL(x) (((x) - 1) * BLOCK_LEN + 1)\n\t#define BR(X) ((x) * BLOCK_LEN)\n\tinline void init(){\n\t\tmemset(T,0x3f,sizeof(T));//\u8868\u793a\u90fd\u4e0d\u5b58\u5728 \n\t}\n\tinline void maintain(int x){//\u5206\u914d\u5185\u5b58 \n\t\tif(T[x] == 0x3f3f3f3f){\n\t\t\tT[x] = que.front() - BL(x) + 1;\n\t\t\tque.pop();\n\t\t} \n\t} \n\tinline void del(int x){//\u5224\u5b9a\u8fd9\u4e2a\u5757\u6709\u6ca1\u6709\u5fc5\u8981\u5b58\u5728\uff0c\u5982\u679c\u90fd\u4e3a\u7a7a\uff0c\u5c31\u53ef\u4ee5\u91ca\u653e\u5185\u5b58 \n\t\tregister int i;\n\t\tfor(i = BL(x);i <= BR(x);++i){\n\t\t\tif(arr[T[x] + i]) return;\n\t\t}\n\t\tque.push(T[x]);//\u628a\u8fd9\u4e2a\u5757\u4e22\u8fdb\u53ef\u7528\u5185\u5b58\u91cc\uff0c\u5982\u679c\u7528new\u3001delete\uff0c\u4f30\u8ba1\u4f1aTLE \n\t\tT[x] = 0x3f3f3f3f;//\u6807\u8bb0\u4e3a\u4e0d\u5b58\u5728\n\t}\n\tinline void upload(int l,int r,int k){//[l,r]\u533a\u95f4\u52a0k \n\t    register int i;\n\t\tint x = Bfrom(l),y = Bfrom(r); \n\t\tif(x == y){//\u7b80\u5355\u7684\u5224\u4e24\u7aef\u70b9\u540c\u5757 \n\t\t\tmaintain(x);\n\t\t\tfor(i = T[x] + l;i <= T[x] + r;++i){//T[x] + i\u5c31\u662fi\u5728\u5185\u5b58\u6c60\u91cc\u7684\u4f4d\u7f6e\uff0c\u5f88\u65b9\u4fbf \n\t\t\t\tarr[i] += k;\n\t\t\t}\n\t\t\tdel(x);\n\t\t\treturn;\n\t\t}\n\t\tif(BL(x) != l){//\u5224\u5de6\u7aef\u70b9\uff0c\u6ca1\u6709\u5fc5\u8981\u5224\u53f3\u7aef\u70b9\uff0c\u56e0\u4e3a\u672c\u9898\u4e2d\u6240\u6709r = n \n\t\t\tmaintain(x);\n\t\t\tfor(i = T[x] + l;i <= T[x] + BR(x);++i){\n\t\t\t\tarr[i] += k;\n\t\t\t}\n\t\t\tdel(x);\n\t\t\tx++;\n\t    }\n\t\tfor(i = x;i <= y;++i){//\u4e2d\u95f4\u6253tag\uff0c\u4e0d\u591a\u8bf4 \n\t\t\ttag[i] += k;\n\t\t}\n\t} \n\tinline int query(int id){//\u7b80\u5355\u7684\u5355\u70b9\u67e5\u8be2 \n\t\tint x = Bfrom(id);\n\t\tif(T[x] != 0x3f3f3f3f) return arr[T[x] + id] + tag[x];\n\t\treturn tag[x];\n\t}\n}value[100005],sum[320];//value\u662f\u503c\u57df\u70b9\uff0csum\u662f\u503c\u57df\u5757 \n\nnamespace OFFLINE{\n\tint tmp[100005];//\u79bb\u6563\u5316\u7528\u7684\u4e34\u65f6\u6570\u7ec4 \n\t\n\tint lis[100005];//lis[i]\u8868\u793ai\u79bb\u6563\u5316\u524d\u7684\u6570 \n\tmap <int,int> R;//R[i]\u8868\u793ai\u79bb\u6563\u5316\u540e\u7684\u6570 \n\tint val_len;\n\tstruct ask{//\u5b58\u6bcf\u4e2a\u4fee\u6539\n\t\tint opt,l,r,k;\n\t}Q[50005]; \n    void input(){\n    \tregister int i;\n    \tscanf(\"%d%d\",&n,&m);\n\t\tfor(i = 1;i <= n;++i){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tfor(i = 1;i <= m;++i){\n\t\t\tscanf(\"%d\",&Q[i].opt);\n\t\t\tif(Q[i].opt != 3){\n\t\t\t\tscanf(\"%d%d%d\",&Q[i].l,&Q[i].r,&Q[i].k);\t\n\t\t\t}else{\n\t\t\t\tscanf(\"%d%d\",&Q[i].l,&Q[i].k);\n\t\t\t}\n\t\t}\n\t}\n\tvoid sol(){//\u79bb\u6563\u5316 \n\t\tregister int i;\n\t\tfor(i = 1;i <= n;++i){\n\t\t\ttmp[i] = p[i];\n\t\t}\n\t\tfor(i = 1;i <= m;++i){\n\t\t\ttmp[n + i] = Q[i].k; \n\t\t}\n\t\tsort(tmp + 1,tmp + n + m + 1);\n\t\tfor(i = 1;i <= n + m;++i){\n\t\t\tif(i == 1 || tmp[i] != tmp[i - 1]){\n\t\t\t\tlis[++val_len] = tmp[i];\n\t\t\t\tR[tmp[i]] = val_len;\n\t\t\t}\n\t\t}\n\t}\t\n};\nusing namespace OFFLINE; \n\n#define len 320//\u503c\u57df\u5206\u5757\u7684\u5757\u957f \n\n#define from(x) ((x % len == 0) ? (x / len) : (x / len + 1))\n#define L(x) (((x) - 1) * len + 1)\n#define R(X) ((x) * len)\n\ninline int rnk(int l,int r,int k){\n\tregister int i;\n\tint x = from(k);\n\tint ans = 0;\n\tfor(i = 1;i < x;++i){//\u503c\u57df\u5757\u626b\u4e00\u904d \n\t\tans += sum[i].query(r) - sum[i].query(l - 1);\n\t}\n\tfor(i = L(x);i <= k;++i){//\u503c\u57df\u70b9 \n\t\tans += value[i].query(r) - value[i].query(l - 1);\n\t}\n\treturn ans;\n}\n\ninline int kth(int l,int r,int k){\n\tregister int x,i;\n\tint tmp;\n\tfor(x = 1;x <= from(val_len);++x){\n\t\ttmp = sum[x].query(r) - sum[x].query(l - 1);\n\t\tif(k > tmp){\n\t\t\tk -= tmp;\t\n\t\t}else{//\u8bf4\u660e[l,r]\u7684kth\u5728\u8fd9\u4e2a\u503c\u57df\u5757\u5185 \n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(i = L(x);i <= R(x);++i){\n\t\ttmp = value[i].query(r) - value[i].query(l - 1);\n\t\tif(k > tmp){\n\t\t\tk -= tmp;\n\t\t}else{\n\t\t\treturn i;\n\t\t}\n\t}\n}\n\ninline void modify(int id,int val){\n\tvalue[p[id]].upload(id,n,-1);//\u64a4\u9500\u4e4b\u524d\u7684\u70b9 \n\tsum[from(p[id])].upload(id,n,-1);//\u6ce8\u610f\u4e24\u5c42\u90fd\u8981\u4fee\u6539\n\tvalue[val].upload(id,n,1);//\u52a0\u5165\u65b0\u70b9 \n\tsum[from(val)].upload(id,n,1);\n\tp[id] = val;\n}\n\ninline int pre(int l,int r,int k){\n\tint tmp = rnk(l,r,k - 1);\n\tif(tmp == 0) return -2147483647;\n\treturn lis[kth(l,r,tmp)];\n}\n\ninline int nxt(int l,int r,int k){\n\tint tmp = rnk(l,r,k);\n\tif(tmp == (r - l + 1)) return 2147483647;\n\treturn lis[kth(l,r,tmp + 1)];\n}\n\nint main(){\n\tregister int i;\n\tinput();\n\tsol();\n\tfor(i = 1;i <= val_len;++i){\n\t\tvalue[i].init();//\u6bcf\u4e2a\u90fd\u8981init\u4e00\u4e0b\uff0c\u5426\u5219\u4f1a\u65e0\u6cd5\u5224\u65ad\u662f\u5426\u5757\u5b58\u5728 \n\t}\n\tfor(i = 1;i <= from(val_len);++i){\n\t\tsum[i].init();\n    }\n    for(i = 1;i <= 100000;++i){//\u6613\u8bc1\u660e\uff0c\u6709\u6548\u7684\u5757\u4e00\u76f4\u81f3\u591a\u53ea\u67092n\u4e2a(\u503c\u57df\u5757n\u4e2a\uff0c\u503c\u57df\u70b9n\u4e2a) \n    \tque.push((i - 1) * BLOCK_LEN);\n\t}\n\tfor(i = 1;i <= n;++i){\n\t\tp[i] = R[p[i]];//\u8fd9\u91cc\u6ce8\u610f\u4e0b \n\t\tvalue[p[i]].upload(i,n,1);\n\t\tsum[from(p[i])].upload(i,n,1);\n\t}\n\tfor(i = 1;i <= m;++i){\n\t\tif(Q[i].opt == 1) printf(\"%d\\n\",rnk(Q[i].l,Q[i].r,R[Q[i].k] - 1) + 1);//\u6ce8\u610f\u5f88\u591a\u90fd\u8981\u79bb\u6563\u5316 \n\t\telse if(Q[i].opt == 2) printf(\"%d\\n\",lis[kth(Q[i].l,Q[i].r,Q[i].k)]);\n\t\telse if(Q[i].opt == 3) modify(Q[i].l,R[Q[i].k]);\n\t\telse if(Q[i].opt == 4) printf(\"%d\\n\",pre(Q[i].l,Q[i].r,R[Q[i].k]));\n\t\telse if(Q[i].opt == 5) printf(\"%d\\n\",nxt(Q[i].l,Q[i].r,R[Q[i].k]));\n\t}\n\treturn 0;\n}\n```\n\n\u7ed3\u679c\u6700\u540e\u4e5f\u6ca1\u6709\u8dd1\u8fc7\u4e8c\u5206\u5957\u7ebf\u6bb5\u6811\u518d\u5957splay\u7684$log(n) ^ 3$\n\n\u8fd8\u662f\u83dc\uff0c\u6700\u540e\u7684\u6218\u679c\u5982\u4e0b\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/euvtpsx4.png)\n\n\u4e0d\u8fc7\u8fd8\u662f\u60f3\u5411\u5927\u5bb6\u666e\u53ca\u4e00\u4e0b\u8fd9\u4e2a\u505a\u6cd5\uff0c\u6bd5\u7adf\u5206\u5757\u5957\u5206\u5757\uff0c\u53ea\u8981\u5957\u5f97\u5408\u9002(\u5916\u5c42$O(\\sqrt n)$\u7684\u5185\u5c42$O(1)$\uff0c\u5916\u5c42$O(1)$\u7684\u5185\u5c42$O(\\sqrt n)$)\uff0c\u8fd8\u662f\u53ef\u4ee5\u505a\u5230\u548c\u6811\u5957\u6811\u590d\u6742\u5ea6**\u5dee\u4e0d\u591a**\u7684\n\n\u6700\u540e\uff0c\u63a8\u8350\u5927\u5bb6\u4e0d\u8981\u5199\u8fd9\u4e2a\u5c51\u505a\u6cd5\uff0c\u5199\u4e00\u4e0b\uff0c\u8c03\u4e00\u5e74\uff0c\u8fd8tm\u8dd1\u4e0d\u8fc7\u6811\u5957\u6811\u3002\u5c31\u7b97\u8981\u5199\u8fd9\u4e2a\uff0c\u4e5f\u63a8\u8350\u5927\u5bb6\u770b[shadowice1984\u7684\u89e3\u6cd5](https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3380)\uff0c\u6bd4\u6211\u5e38\u6570\u5c0f",
        "postTime": 1579922348,
        "uid": 49776,
        "name": "chenxinyang2006",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u4e3b\u5e2d\u6811\u786e\u5b9e\u662f\u4e2a\u597d\u4e1c\u897f\uff0c\u53ef\u4ee5\u907f\u514d\u6811\u5957\u6811= =\u3002\n\n\n\u4e3b\u5e2d\u6811\u5957\u6811\u72b6\u6570\u7ec4\u57fa\u7840\u4f20\u9001\u95e8\u3002\n\n\n\u4e3b\u5e2d\u6811\u5957\u4e2a\u6811\u72b6\u6570\u7ec4\u65f6\uff0c\u826f\u5fc3\u4e00\u70b9\u7684\u51fa\u9898\u4eba\u4f1a\u628a\u7a7a\u95f4\u653e\u7684\u6bd4\u8f83\u5927\uff0c\u5982256,512\uff0c\u800c\u67d0\u4e9b\u5f88\u5389\uff08sang xin\uff09\u5bb3\uff08bing kuang\uff09\u7684\u51fa\u9898\u4eba\u5c31\u7ed9\u4f6064,128\uff0c\u90a3\u4e48\u6211\u4eecO(nlog^2n)\u7684\u7a7a\u95f4\u5c31\u5f00\u4e0d\u4e0b\u4e86\uff01\uff01\n\n\n\u867d\u7136\u6211\u4e5f\u5728\u4e0a\u6b21\u7684\u535a\u5ba2\u4e2d\u63d0\u5230\u4e86\u8fd9\u4e2a\u4f18\u5316\u7a7a\u95f4\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u6211\u89c9\u5f97\u6bd4\u8f83\u9ebb\u70e6\uff0c\u6240\u4ee5\u5c31\u6ca1\u60f3\u6253\uff0c\u8c01\u77e5\u4eca\u513f\u5c31\u5728\u6d1b\u8c37\u78b0\u4e0a\u4e86P3380\u4e8c\u903c\u5e73\u8861\u6811\uff0c\u6211\u6309\u7167\u6628\u5929\u7684\u529e\u6cd5\u4ea4\u4e86\u4e2a\u7a0b\u5e8f\u4e0a\u53bb\uff0c\u7ed3\u679c\u5168\u90e8\u7206\u7a7a\u95f4\u4e86\uff0c\u6240\u4ee5\u4e0d\u5f97\u4e0d\u53c8\u7814\u7a76\u4e86\u4e00\u4e0b\u90a3\u4e2a\u4f18\u5316\u3002\n\n\n\u90a3\u4e2a\u4f18\u5316\u5176\u5b9e\u4e5f\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5c06\u539f\u6765\u7684\u5e8f\u5217\u5efa\u4e00\u4e2a\u9759\u6001\u7684\u4e3b\u5e2d\u6811\uff0c\u7136\u540e\u5bf9\u4e8e\u4fee\u6539\u7684\u6570\uff0c\u5efa\u4e00\u4e2a\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u7684\u4e3b\u5e2d\u6811\uff0c\u90a3\u4e48\u7a7a\u95f4\u5c31\u662fO(nlogn+(\u4fee\u6539\u64cd\u4f5c\u7684\u6570\u91cf)\\*log^2n)\uff0c\u4fee\u6539\u64cd\u4f5c\u7684\u6570\u91cf\u80af\u5b9a\u8981\u6bd4n\u5c0f\u5f97\u591a\uff0c\u6240\u4ee5\u5c31\u80fd\u8282\u7701\u5927\u91cf\u7684\u7a7a\u95f4\uff0c\u81f3\u4e8e\u4ec0\u4e48rank\uff0cselect\uff0cpred\uff0csucc\u7684\u64cd\u4f5c\uff0c\u90fd\u548c\u5e73\u8861\u6811\u7c7b\u4f3c\uff0c\u6bd5\u7adf\u90fd\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5b50\u6811\u7684\u8282\u70b9\u6570\u561b\u3002\n\n\n\u8fd9\u4e2a\u4f18\u5316\u5728\u968f\u673a\u6570\u636e\u4e0b\u6548\u679c\u663e\u8457\uff0c\u5982\u5f53n=m=50000\u65f6\u7684\u7eaf\u968f\u673a\uff0c\u539f\u5148\u7684\u505a\u6cd5\u5f00\u4e866000000\u7684\u7a7a\u95f4\uff0c\u800c\u4f18\u5316\u540e\u53ea\u5f00\u4e86800000.\n\n\n\u7136\u800c\u6211\u53c8\u8c03\u8bd5\u4e86\u4e00\u5929\uff0c\u7ed3\u679c\u53d1\u73b0\u662frank\u91cc\u7684L\uff0c\u4e0eR\u6253\u9519\u4e86\uff0c\u628a\u9898\u76ee\u8bf4\u7684\u64cd\u4f5c2\u5f53\u6210\u4e86\u64cd\u4f5c3......\u5f00\u4e2a\u5c0f\u53f7\uff0c\u7070\u540d\uff0c\u4e0b\u4e0d\u4e86\u6570\u636e\uff0c\u771f\u5fc3\u7d2f\u3002\n\n\n\u6211\u5199\u7684\u7a0b\u5e8f\u91cc\u6c42\u540e\u7ee7\u8fd0\u7528\u4e86\u4e00\u4e2a\u5c0f\u5c0f\u7684\u6280\u5de7\uff0c\u4ece\u800c\u907f\u514d\u4e86\u6c42\u4e00\u4e2a\u6570\u5728\u67d0\u4e2a\u533a\u95f4\u91cc\u51fa\u73b0\u7684\u6b21\u6570\u8fd9\u4e00\u4e2a\u64cd\u4f5c\u3002\u5f53\u7136\uff0c\u52a0\u4e0a\u4e5f\u662f\u6ca1\u6709\u5173\u7cfb\u7684\uff0c\u6211\u5728\u4ee3\u7801\u540e\u9762\u4f1a\u8865\u4e0a\u8fd9\u4e2acount\u7684\u4ee3\u7801\u6bb5\u3002\n\n\n\u63a8\u5e7f\u4e00\u4e0b\u6211\u7684\u535a\u5ba2\u5427\uff0c\u66f4\u8be6\u7ec6\u7684\u5728\u8fd9\u91cc\u54df\uff1fhttp://blog.csdn.net/no1\\_terminator/article/details/77620821\n\n\n\u53c2\u8003\u4ee3\u7801\uff08\u63d0\u4ea4\u4ee3\u7801\u65f6\u52a1\u5fc5\u8981\u628a\u8bed\u8a00\u624b\u52a8\u8c03\u6210C++\uff0c\u56e0\u4e3aC11\u4f1a\u7f16\u8bd1\u9519\u8bef\uff09\uff1a\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define re register\n#define REP(i,a,b) for (re int i=(a);i<=(b);++i)\n#define For(i,a,b) for (re int i=(a);i<=(b);i+=i&(-i))\n#define RFor(i,a,b) for (re int i=(a);i>=(b);i-=i&(-i))\nusing namespace std;\nconst int INF=0x7fffffff;\nconst int N=5e4+5;\nconst int M=101;\nint a[N],b[N<<1],S[N],x[M],y[M],root[N];\nint n,m,loc,totn,totx,toty,T_cnt;\nstruct Quet{\n    int l,r,k,opt;\n}q[N];\nstruct PdT{\n    int L,R,sum;\n}T[N*100];\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while (ch<'0' || ch>'9'){if (ch=='-')f=-1;ch=getchar();}\n    while ('0'<=ch && ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    return x*f;\n}\ninline void insert(int &now,int x,int v,int l=1,int r=totn){\n    T[++T_cnt]=T[now];now=T_cnt;\n    T[now].sum+=v;\n    if (l==r)return;\n    re int mid=(l+r)>>1;\n    if (x<=mid)insert(T[now].L,x,v,l,mid);\n        else insert(T[now].R,x,v,mid+1,r);\n}\ninline void adpre(int s,int e){\n    totx=toty=0;\n    RFor(i,s-1,1)x[++totx]=S[i];\n    RFor(i,e,1)y[++toty]=S[i];\n}\ninline void addv(int x,int v){\n    int rk=lower_bound(b+1,b+totn+1,a[x])-b;\n    For(j,x,n)insert(S[j],rk,v);\n}\ninline int getSum(int i,int j){\n    re int s=0;\n    REP(t,1,totx)s-=T[T[x[t]].L].sum;\n    REP(t,1,toty)s+=T[T[y[t]].L].sum;\n    s+=T[T[j].L].sum-T[T[i].L].sum;\n    return s;\n}\ninline int rank(int i,int j,int k,int l=1,int r=totn){\n    if (l==r)return 1;\n    re int mid=(l+r)>>1;\n    if (k<=mid){\n        REP(t,1,totx)x[t]=T[x[t]].L;\n        REP(t,1,toty)y[t]=T[y[t]].L;\n        return rank(T[i].L,T[j].L,k,l,mid);\n    }else{\n        re int s=getSum(i,j);\n        REP(t,1,totx)x[t]=T[x[t]].R;\n        REP(t,1,toty)y[t]=T[y[t]].R;\n        return s+rank(T[i].R,T[j].R,k,mid+1,r);\n    }\n}\ninline int select(int i,int j,int k,int l=1,int r=totn){\n    if (l==r)return b[l];\n    re int mid=(l+r)>>1,s=getSum(i,j);\n    if (k<=s){\n        REP(t,1,totx)x[t]=T[x[t]].L;\n        REP(t,1,toty)y[t]=T[y[t]].L;\n        return select(T[i].L,T[j].L,k,l,mid);\n    }else{\n        REP(t,1,totx)x[t]=T[x[t]].R;\n        REP(t,1,toty)y[t]=T[y[t]].R;\n        return select(T[i].R,T[j].R,k-s,mid+1,r);\n    }\n}\nint main(){\n    n=read(),m=read();\n    REP(i,1,n)b[i]=a[i]=read();\n    totn=n;\n    REP(i,1,m){\n        q[i].opt=read(),q[i].l=read(),q[i].r=read();\n        if (q[i].opt!=3){\n            q[i].k=read();\n            if (q[i].opt!=2)b[++totn]=q[i].k;\n        }else b[++totn]=q[i].r;\n    }\n    sort(b+1,b+totn+1);\n    totn=unique(b+1,b+totn+1)-b-1;\n    REP(i,1,n){\n        re int rk=lower_bound(b+1,b+totn+1,a[i])-b;\n        root[i]=root[i-1];\n        insert(root[i],rk,1);\n    }\n    REP(i,1,m){\n        re int opt=q[i].opt,s=q[i].l,e=q[i].r,x=q[i].k;\n        if (opt!=2 && opt!=3)x=lower_bound(b+1,b+totn+1,x)-b;\n        if (opt!=3)adpre(s,e);\n        if (opt==1)printf(\"%d\\n\",rank(root[s-1],root[e],x));\n        else if (opt==2)printf(\"%d\\n\",select(root[s-1],root[e],x));\n        else if (opt==3){\n            addv(s,-1);\n            a[s]=e;\n            addv(s,1);\n        }\n        else if (opt==4){\n            re int p=rank(root[s-1],root[e],x);\n            if (p==1)printf(\"%d\\n\",-INF);\n            else{\n                adpre(s,e);\n                printf(\"%d\\n\",select(root[s-1],root[e],p-1));\n            }\n        }\n        else if (opt==5){\n            re int p=rank(root[s-1],root[e],x+1);\n            adpre(s,e);\n            re int t=select(root[s-1],root[e],p);\n            if (t!=x && p<=e-s+1)printf(\"%d\\n\",t);\n                else printf(\"%d\\n\",INF);\n        }\n    }\n}\n\n```\n```cpp\ncount\u51fd\u6570\uff1a int count(int k,int L,int R,int tl,int tr,int l=1,int r=totn){\n    if (l==r)return -1;\n    int mid=(l+r)>>1;\n    int tt=0;\n    if (k<=mid){\n        int tmp=query(R)-query(L);\n        movel(L);movel(R);\n        tt=count(k,L,R,T[tl].L,T[tr].L,l,mid);\n        if (tt==-1)tt=tmp+T[T[tr].L].sum-T[T[tl].L].sum;\n    }else{\n        int tmp=0;\n        for (int x=L;x;x-=x&(-x))tmp-=T[T[use[x]].R].sum;\n        for (int x=R;x;x-=x&(-x))tmp+=T[T[use[x]].R].sum;\n        mover(L);mover(R);\n        tt=count(k,L,R,T[tl].R,T[tr].R,mid+1,r);\n        if (tt==-1)tt=tmp+T[T[tr].R].sum-T[T[tl].R].sum;\n    }\n    return tt;\n}\n```\n\u4e0d\u5f97\u4e0d\u8bf4\u8fd9\u4e2acount\u6709\u4e2a\u7f3a\u70b9\uff0c\u5c31\u662fq[i].l,q[i].r\u4ec0\u4e48\u7684\u6ca1\u6709\u7528\u4e34\u65f6\u53d8\u91cf\u4fdd\u5b58\uff0c\u6240\u4ee5\u5199\u7684\u6709\u70b9\u5197\u957f\u800c\u4e14\u7e41\u4e71\uff0c\u4e0b\u6b21\u4e00\u5b9a\u8981\u6ce8\u610f\u4e86\n",
        "postTime": 1506086748,
        "uid": 54916,
        "name": "I_AM_HelloWord",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "$$\\color{cornflowerblue}{\\mathcal{Treaker}}$$\n# \u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\n\u5e73\u8861\u6811\u6211\u91c7\u7528\u4e86Splay\uff08\u53ea\u4f1aSplay\uff09\u3002\n\n\u64cd\u4f5c1\uff1a\u5728\u7ebf\u6bb5\u6811\u4e0a\u627e\u8fd9\u4e2a\u533a\u95f4\uff0c\u5728\u6bcf\u4e2a\u5206\u533a\u95f4\u5185\uff0c\u627e\u6bd4k\u5c0f\u7684\u6570\u7684\u4e2a\u6570\uff0c\u5168\u52a0\u8d77\u6765\u518d\u52a0\u4e00\u3002\n\n\u64cd\u4f5c2\uff1a\u533a\u95f4\u5185\u7684\u503c\u4e0d\u5728\u4e00\u9897\u5e73\u8861\u6811\u91cc\uff0c\u6240\u4ee5\u76f4\u63a5\u67e5\u627e\u662f\u4e0d\u65b9\u4fbf\u7684\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u4e8c\u5206\u7b54\u6848\uff0c\u5c31\u53c8\u8f6c\u5316\u4e3a\u4e86\u64cd\u4f5c1\u3002\n\n\u64cd\u4f5c3\uff1a\u5355\u70b9\u4fee\u6539\uff0c\u628a\u6240\u6709\u5305\u542b\u8fd9\u4e2a\u70b9\u7684\u5e73\u8861\u6811\uff0c\u5148\u5220\u9664\u518d\u6dfb\u52a0\u3002\n\n\u64cd\u4f5c4\uff1a\u6c42\u51fa\u6bcf\u4e2a\u533a\u95f4\u7684\u524d\u9a71\uff0c\u7136\u540e\u53d6max\n\n\u64cd\u4f5c5\uff1a\u6c42\u51fa\u6bcf\u4e2a\u533a\u95f4\u7684\u540e\u7ee7\uff0c\u7136\u540e\u53d6min\u3002\n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <cstdio>\n#include <iostream>\n#define R register\nusing namespace std;\nconst int N = 50005;\ninline int read()\n{\n\tint x = 0 , f = 1;\tchar ch = getchar();\n\twhile(ch < '0' || ch > '9')\t{if(ch == '-')\tf = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nint n , m , a[N];\nstruct Splay\n{\n\tstruct node\n\t{\n\t\tnode *ch[2] , *fa;\n\t\tint val , size;\n\t\tnode(node *fa = NULL,int val = 0) : fa(fa) , val(val) {ch[0] = ch[1] = NULL;size = 1;}\n\t\tinline bool isr() {return this == fa -> ch[1];}\n\t\tinline int rk() {return 1 + (ch[0] ? ch[0] -> size : 0);}\n\t\tinline void up() {size = 1 + (ch[0] ? ch[0] -> size : 0) + (ch[1] ? ch[1] -> size : 0);}\n\t}*root;\n\tSplay() {root = NULL;}\n\tinline void rot(R node *x)\n\t{\n\t\tbool k = x -> isr();\n\t\tnode *y = x -> fa , *z = y -> fa , *w = x -> ch[!k];\n\t\tif(y == root) root = x;\n\t\telse z -> ch[y -> isr()] = x;\n\t\tx -> fa = z; y -> fa = x;\n\t\tx -> ch[!k] = y; y -> ch[k] = w;\n\t\tif(w) w -> fa = y;\n\t\ty -> up(); x -> up();\n\t}\n\tinline void splay(R node *x)\n\t{\n\t\twhile(x != root)\n\t\t{\n\t\t\tif(x -> fa != root) rot(x -> isr() ^ x -> fa -> isr() ? x : x -> fa);\n\t\t\trot(x);\n\t\t}\n\t}\n\tnode* merge(R node *x,R node *y,R node *fa)\n\t{\n\t\tif(x) x -> fa = fa;\n\t\tif(y) y -> fa = fa;\n\t\tif(!x || !y) return x ? x : y;\n\t\treturn x -> ch[1] = merge(x -> ch[1],y,x) , x -> up() , x;\n\t}\n\tinline void insert(R int val)\n\t{\n\t\tif(!root) return (void)(root = new node(NULL,val));\n\t\tnode *p = root , *fa = NULL;\n\t\twhile(p)\n\t\t{\n\t\t\tfa = p;\n\t\t\tp = p -> ch[val > p -> val];\n\t\t}\n\t\tp = new node(fa,val);\n\t\tfa -> ch[val > fa -> val] = p;\n\t\tsplay(p);\n\t}\n\tinline void del(R int val)\n\t{\n\t\tnode *p = root;\n\t\twhile(p && val != p -> val) p = p -> ch[val > p -> val];\n\t\tif(!p) return;\n\t\tsplay(p);\n\t\troot = merge(p -> ch[0],p -> ch[1],NULL);\n\t}\n\tinline int rank(R int val)\n\t{\n\t\tnode *p = root , *lst = NULL; int res = 0;\n\t\twhile(p)\n\t\t{\n\t\t\tlst = p;\n\t\t\tif(val <= p -> val) p = p -> ch[0];\n\t\t\telse res += p -> rk() , p = p -> ch[1];\t\n\t\t}\n\t\tsplay(lst);\n\t\treturn res;\n\t}\n\tinline int kth(R int k)\n\t{\n\t\tnode *p = root;\n\t\twhile(p && p -> rk() != k)\n\t\t{\n\t\t\tif(p -> rk() > k) p = p -> ch[0];\n\t\t\telse k -= p -> rk() , p = p -> ch[1];\n\t\t}\n\t\tsplay(p);\n\t\treturn p -> val;\n\t}\n\tinline int pre(R int val)\n\t{\n\t\tnode *p = root , *lst = NULL;\n\t\twhile(p)\n\t\t{\n\t\t\tif(p -> val < val)\tlst = p , p = p -> ch[1];\n\t\t\telse p = p -> ch[0];\n\t\t}\n\t\tif(lst) return splay(lst) , lst -> val;\n\t\treturn -2147483647;\n\t}\n\tinline int nxt(R int val)\n\t{\n\t\tnode *p = root , *lst = NULL;\n\t\twhile(p)\n\t\t{\n\t\t\tif(p -> val > val)\tlst = p , p = p -> ch[0];\n\t\t\telse p = p -> ch[1];\n\t\t}\n\t\tif(lst) return splay(lst) , lst -> val;\n\t\treturn 2147483647;\n\t}\n};\nstruct Segment_Tree\n{\n\t#define mid ((p -> l + p -> r) >> 1)\n\tstruct node\n\t{\n\t\tnode *ls , *rs; Splay x;\n\t\tint l , r;\n\t\tnode(int l = 0,int r = 0) : l(l) , r(r) {ls = rs = NULL;}\n\t}*root;\n\tvoid build(R node *&p,R int l,R int r)\n\t{\n\t\tp = new node(l,r);\n\t\tfor(int i = l;i <= r;i ++) p -> x.insert(a[i]);\n\t\tif(l == r) return;\n\t\tbuild(p -> ls,l,mid);\n\t\tbuild(p -> rs,mid+1,r);\n\t}\n\tint rank(R node *p,R int x,R int y,R int k)\n\t{\n\t\tif(x <= p -> l && p -> r <= y)\treturn p -> x.rank(k); int res = 0;\n\t\tif(x <= mid) res += rank(p -> ls,x,y,k);\n\t\tif(y > mid) res += rank(p -> rs,x,y,k);\n\t\treturn res;\n\t}\n\tinline bool check(R int x,R int y,R int m,R int k) {return rank(root,x,y,m) + 1 <= k;}\n\tinline int kth(R int x,R int y,R int k)\n\t{\n\t\tint l = 0 , r = 100000000 , ans;\n\t\twhile(l <= r)\n\t\t{\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif(check(x,y,m,k)) ans = m , l = m + 1;\n\t\t\telse r = m - 1;\n\t\t} \n\t\treturn ans;\n\t}\n\tvoid chenge(R node *p,R int x,R int k)\n\t{\n\t\tp -> x.del(a[x]); p -> x.insert(k);\n\t\tif(p -> l == p -> r) return (void)(a[x] = k);\n\t\tif(x <= mid) chenge(p -> ls,x,k);\n\t\telse chenge(p -> rs,x,k);\n\t}\n\tint pre(R node *p,R int x,R int y,R int k)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return p -> x.pre(k); int res = -2147483647;\n\t\tif(x <= mid) res = max(res,pre(p -> ls,x,y,k));\n\t\tif(y > mid) res = max(res,pre(p -> rs,x,y,k));\n\t\treturn res;\n\t}\n\tint nxt(R node *p,R int x,R int y,R int k)\n\t{\n\t\tif(x <= p -> l && p -> r <= y) return p -> x.nxt(k); int res = 2147483647;\n\t\tif(x <= mid) res = min(res,nxt(p -> ls,x,y,k));\n\t\tif(y > mid) res = min(res,nxt(p -> rs,x,y,k));\n\t\treturn res;\n\t}\n\tinline void LOL()\n\t{\n\t\tn = read(); m = read();\n\t\tfor(int i = 1;i <= n;i ++)\ta[i] = read();\n\t\tbuild(root,1,n);\n\t\tfor(int i = 1 , opt , l , r , k;i <= m;i ++)\n\t\t{\n\t\t\topt = read();\n\t\t\tif(opt == 1) l = read() , r = read() , k = read() , printf(\"%d\\n\",rank(root,l,r,k) + 1);\n\t\t\tif(opt == 2) l = read() , r = read() , k = read() , printf(\"%d\\n\",kth(l,r,k));\n\t\t\tif(opt == 3) l = read() , k = read() , chenge(root,l,k);\n\t\t\tif(opt == 4) l = read() , r = read() , k = read() , printf(\"%d\\n\",pre(root,l,r,k));\n\t\t\tif(opt == 5) l = read() , r = read() , k = read() , printf(\"%d\\n\",nxt(root,l,r,k));\n\t\t}\n\t}\n}DNF;\nint main()\n{\n\tDNF.LOL();\n\treturn 0;\n}\n```\n",
        "postTime": 1569320080,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "&emsp;\u8fd9\u9898\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u5957\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u505a\u7684\u5440\uff01\n\n&emsp;\u5982\u679c\u6ca1\u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u90a3\u4e48\u4e00\u4e2a\u4e3b\u5e2d\u6811\u5c31\u505a\u5b8c\u4e86\uff0c\u4f46\u662f\u8fd9\u9898\u591a\u4e86\u4e2a\u4fee\u6539\u64cd\u4f5c\u3002\n\u6bcf\u4e00\u6b21\u4fee\u6539\u64cd\u4f5c\u76f8\u5f53\u4e8e\u503c\u57df\u7ebf\u6bb5\u6811\u4e0a\u4e00\u6761\u94fe-1\uff0c\u53e6\u4e00\u6761\u94fe+1\uff0c\u5e76\u4e14\u5bf9\u6240\u6709\u540e\u9762\u7684\u6811\u90fd\u6709\u5f71\u54cd\uff0c\u7531\u6b64\u6211\u4eec\u60f3\u5230\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u6765\u7ef4\u62a4\u4fee\u6539\u64cd\u4f5c\u3002\n\n&emsp;\u6bcf\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7684\u70b9\u76f8\u5f53\u4e8e\u4e00\u4e2a\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\uff0c\u4e00\u5f00\u59cb\u4ec0\u4e48\u4e5f\u6ca1\u6709\u3002\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u4fee\u6539\u64cd\u4f5c\uff0c\u6211\u4eec\u5411\u5728\u5e8f\u5217\u4e0a\u4e00\u6837\uff0c\u5bf9\u4e8e\u76f8\u5e94\u7684\u70b9\u5728\u539f\u6570\u7684\u4f4d\u7f6e-1\uff0c\u5728\u4fee\u6539\u6210\u7684\u6570\u7684\u4f4d\u7f6e+1\u3002\u8be2\u95ee\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8981\u628a\u5bf9\u5e94\u7684\u70b9\u7b97\u4e0a\uff0c\u6bcf\u6b21\u5c06\u5b83\u4eec\u4e00\u8d77\u5411\u5de6(\u5411\u53f3)\u8df3\uff0c\u7edf\u8ba1\u7b54\u6848\u5c31ok\u4e86\u3002\n\n&emsp;\u5f53\u7136\uff0c\u8fd9\u5176\u4e2d\u8fd8\u6709\u4e00\u4e2a\u4ee4\u4eba\u96be\u53d7\u7684\u64cd\u4f5c\uff0c\u5c31\u662f\u627e\u524d\u9a71\u540e\u7ee7\u3002\u5728\u4e00\u68f5\u666e\u901a\u7684\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5411\u5de6(\u5411\u53f3)\u8df3\uff0c\u5982\u679c\u627e\u4e0d\u5230\u7b54\u6848\u518d\u5411\u53e6\u4e00\u4e2a\u65b9\u5411\u8df3\u3002\u4f46\u662f\u5728\u8fd9\u9898\uff0c\u6211\u4eec\u540c\u65f6\u8fd8\u8981\u8ba9\u6211\u4eec\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u7684\u6811\u4e0a\u7684\u8282\u70b9\u5411\u5de6(\u5411\u53f3)\u8df3\uff0c\u6240\u4ee5\u6211\u4eec\u5fc5\u9700\u8981\u518d\u6bcf\u5c42\u5148\u8bb0\u5f55\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u7684\u5f53\u524d\u7684\u8282\u70b9\u7f16\u53f7\uff0c\u5f53\u6211\u4eec\u627e\u4e0d\u5230\u65f6\u518d\u5411\u53e6\u4e00\u4e2a\u65b9\u5411\u8df3\u3002\n\n>\u5177\u4f53\u7684\u770b\u4ee3\u7801\u5427\uff0c\u6211\u8868\u8fbe\u592a\u5dee\u4e86\n\n```\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint n,m,sl,fh,tot,rt_num,a[50010],s[100010];\nint S[50010],L[50010],R[50010],rt[50010];\nstruct ask\n{\n    int t,l,r,k;\n}q[50010];\nstruct seg\n{\n    int siz,sn[2];\n}tre[8000010];\nchar gc()\n{\n    static char buf[1<<16],*P,*Q;\n    if(P==Q){Q=(P=buf)+fread(buf,1,1<<16,stdin);if(P==Q)return EOF;}\n    return *P++;\n}\nint rd()\n{\n    sl=0;fh=1;\n    char ch=gc();\n    while(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=gc();}\n    while('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=gc();\n    return sl*fh;\n}\nvoid build(int &no,int l,int r)\n{\n    no=++rt_num;\n    if(l==r) return ;\n    int mid=(l+r)>>1;\n    build(tre[no].sn[0],l,mid);\n    build(tre[no].sn[1],mid+1,r);\n}\nvoid update(int &no,int l,int r,int x,int val)\n{\n    tre[++rt_num]=tre[no];no=rt_num;\n    tre[no].siz+=val;\n    if(l==r) return ;\n    int mid=(l+r)>>1;\n    if(x<=mid) update(tre[no].sn[0],l,mid,x,val);\n    else update(tre[no].sn[1],mid+1,r,x,val);\n}\nint sum(int x,int T[],int k)\n{\n    int ret=0;\n    for(int i=x;i;i-=(i&-i)) ret+=tre[tre[T[i]].sn[k]].siz;\n    return ret;\n}\nint rank(int x,int y,int lr,int rr,int l,int r,int t)\n{\n    if(l==r) return 0;\n    int mid=(l+r)>>1;\n    if(t<=mid)\n    {\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];\n        return rank(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);\n    }\n    else\n    {\n        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];\n        return rank(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t)+k;\n    }\n}\nint kth(int x,int y,int lr,int rr,int l,int r,int k)\n{\n    if(l==r) return l;\n    int mid=(l+r)>>1,t=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;\n    if(k<=t)\n    {\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];\n        return kth(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,k);\n    }\n    else\n    {\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];\n        return kth(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,k-t);\n    }\n}\nvoid change(int x,int y,int val) {for(int i=x;i<=n;i+=(i&-i)) update(S[i],1,tot,y,val);}\nint findpre(int x,int y,int lr,int rr,int l,int r,int t)\n{\n    if(l==r) return l;\n    int mid=(l+r)>>1;\n    if(t<=mid)\n    {\n        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;\n        if(!k) return -1;\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[0];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[0];\n        return findpre(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);\n    }\n    else\n    {\n        int k=sum(y,R,1)-sum(x,L,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;\n        int ql[50010],qr[50010];\n        for(int i=x;i;i-=(i&-i)) ql[i]=L[i],L[i]=tre[L[i]].sn[1];\n        for(int i=y;i;i-=(i&-i)) qr[i]=R[i],R[i]=tre[R[i]].sn[1];\n        if(k) k=findpre(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);else k=-1;\n        if(k!=-1)return k;\n        k=sum(y,qr,0)-sum(x,ql,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[ql[i]].sn[0];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[qr[i]].sn[0];\n        if(k) return findpre(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);\n        return -1;\n    }\n}\nint findsub(int x,int y,int lr,int rr,int l,int r,int t)\n{\n    if(l==r) return l;\n    int mid=(l+r)>>1;\n    if(t<=mid)\n    {\n        int k=sum(y,R,0)-sum(x,L,0)+tre[tre[rr].sn[0]].siz-tre[tre[lr].sn[0]].siz;\n        int ql[50010],qr[50010];\n        for(int i=x;i;i-=(i&-i)) ql[i]=L[i],L[i]=tre[L[i]].sn[0];\n        for(int i=y;i;i-=(i&-i)) qr[i]=R[i],R[i]=tre[R[i]].sn[0];\n        if(k) k=findsub(x,y,tre[lr].sn[0],tre[rr].sn[0],l,mid,t);else k=-1;\n        if(k!=-1) return k;\n        k=sum(y,qr,1)-sum(x,ql,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[ql[i]].sn[1];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[qr[i]].sn[1];\n        if(k) return findsub(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);\n        return -1;\n    }\n    else\n    {\n        int k=sum(y,R,1)-sum(x,L,1)+tre[tre[rr].sn[1]].siz-tre[tre[lr].sn[1]].siz;\n        if(!k) return -1;\n        for(int i=x;i;i-=(i&-i)) L[i]=tre[L[i]].sn[1];\n        for(int i=y;i;i-=(i&-i)) R[i]=tre[R[i]].sn[1];\n        return findsub(x,y,tre[lr].sn[1],tre[rr].sn[1],mid+1,r,t);\n    }\n}\nint main()\n{\n    n=rd();m=rd();tot=n;\n    for(int i=1;i<=n;++i) s[i]=a[i]=rd();\n    for(int i=1;i<=m;++i)\n    {\n        q[i].t=rd();\n        if(q[i].t==3) q[i].l=rd(),s[++tot]=q[i].k=rd();\n        else if(q[i].t==2) q[i].l=rd(),q[i].r=rd(),q[i].k=rd();\n        else q[i].l=rd(),q[i].r=rd(),s[++tot]=q[i].k=rd();\n    }\n    sort(s+1,s+tot+1);tot=unique(s+1,s+tot+1)-s-1;\n    build(rt[0],1,tot);\n    for(int i=1;i<=n;++i)\n    {\n        rt[i]=rt[i-1];a[i]=lower_bound(s+1,s+tot+1,a[i])-s;\n        update(rt[i],1,tot,a[i],1);\n    }\n    for(int i=1;i<=n;++i) S[i]=rt[0];\n    int x,l,r;\n    for(int i=1;i<=m;++i)\n    {\n        if(q[i].t==1)\n        {\n            x=lower_bound(s+1,s+tot+1,q[i].k)-s;l=q[i].l-1;r=q[i].r;\n            for(int j=l;j;j-=(j&-j)) L[j]=S[j];\n            for(int j=r;j;j-=(j&-j)) R[j]=S[j];\n            printf(\"%d\\n\",rank(l,r,rt[l],rt[r],1,tot,x)+1);\n        }\n        else if(q[i].t==2)\n        {\n            l=q[i].l-1;r=q[i].r;\n            for(int j=l;j;j-=(j&-j)) L[j]=S[j];\n            for(int j=r;j;j-=(j&-j)) R[j]=S[j];\n            printf(\"%d\\n\",s[kth(l,r,rt[l],rt[r],1,tot,q[i].k)]);\n        }\n        else if(q[i].t==3)\n        {\n            change(q[i].l,a[q[i].l],-1);\n            a[q[i].l]=lower_bound(s+1,s+tot+1,q[i].k)-s;\n            change(q[i].l,a[q[i].l],1);\n        }\n        else if(q[i].t==4)\n        {\n            x=lower_bound(s+1,s+tot+1,q[i].k)-s-1;l=q[i].l-1;r=q[i].r;\n            for(int j=l;j;j-=(j&-j)) L[j]=S[j];\n            for(int j=r;j;j-=(j&-j)) R[j]=S[j];\n            x=findpre(l,r,rt[l],rt[r],1,tot,x);\n            if(x==-1) puts(\"-2147483647\");\n            else printf(\"%d\\n\",s[x]);\n        }\n        else\n        {\n            x=lower_bound(s+1,s+tot+1,q[i].k)-s+1;l=q[i].l-1;r=q[i].r;\n            for(int j=l;j;j-=(j&-j)) L[j]=S[j];\n            for(int j=r;j;j-=(j&-j)) R[j]=S[j];\n            x=findsub(l,r,rt[l],rt[r],1,tot,x);\n            if(x==-1) puts(\"2147483647\");\n            else printf(\"%d\\n\",s[x]);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1544792300,
        "uid": 27677,
        "name": "day_dream",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "- [P3380 \u3010\u6a21\u677f\u3011\u6811\u5957\u6811](https://www.luogu.com.cn/problem/P3380)\n\n- \u89e3\u9898\u601d\u8def\uff1a\u5206\u5757\u5957\u503c\u57df\u5206\u5757\u3002\n  \n  \u9996\u5148\u5bf9\u4e0b\u6807\u8fdb\u884c\u5206\u5757\u3002\u6bcf\u5757\u7684\u957f\u5ea6\u4e3a $\\lfloor \\sqrt{n} \\rfloor$\u3002\n  \n  \u540c\u65f6\u5bf9\u503c\u57df\u8fdb\u884c\u5206\u5757\u3002\u8bbe\u6709 $(n+m)$ \u4e2a\u4e0d\u540c\u7684\u6570\u503c\uff0c\u79bb\u6563\u5316\u4e4b\u540e\uff0c\u5c06\u503c\u57df\u5206\u6210 $\\sqrt{n+m}$ \u4e2a\u5757\u3002\n  \n  \u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u9884\u5904\u7406\u4e24\u4e2a\u8868\uff1a\n  \n  - $\\text{C1}(i,j)$ \uff1a\u8868\u793a\u6309\u4e0b\u6807\u5206\u5757\u7684\u524d $i$ \u4e2a\u5757\u5185\u6709\u591a\u5c11\u4e2a\u6570\uff08\u79bb\u6563\u5316\u540e\uff09\u843d\u5728\u7b2c $j$ \u4e2a\u503c\u57df\u5757\u3002\n  \n  - $\\text{C2}(i,j)$ \uff1a\u8868\u793a\u6309\u4e0b\u6807\u5206\u5757\u7684\u524d $i$ \u4e2a\u5757\u5185\u6709\u591a\u5c11\u4e2a\u6570\u4e3a $j$\u3002\n  \n  \u4ed4\u7ec6\u60f3\u4e00\u60f3\uff0c\u8fd9\u6837\u7684\u8bdd\uff0c\u5728\u5355\u70b9\u4fee\u6539\u548c\u67e5\u8be2\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5b8c\u7f8e\u5730\u5b9e\u73b0\u66b4\u529b\u4e0e\u66b4\u529b\u4e4b\u95f4\u7684\u5e73\u8861\u3002\n  \n  \u5177\u4f53\u6bcf\u4e2a\u64cd\u4f5c\u7684\u5904\u7406\u65b9\u5f0f\u5982\u4e0b\uff1a\n  \n  - \u4fee\u6539\u64cd\u4f5c\uff1a\u5c06\u4e0b\u6807\u4e3a $p$ \u7684\u6570\u4fee\u6539\u4e3a $v$\u3002\n    \n      \u4ee4 $v$ \u6240\u5728\u7684\u503c\u57df\u5757\u7684\u7f16\u53f7\u4e3a $\\text{pos}$\uff0c\u6309\u4e0b\u6807\u5206\u4e00\u5171\u6709 $\\text{num}$ \u4e2a\u5757\uff0c$\\text{BEL}(i)$ \u8868\u793a\u7b2c $i$ \u4e2a\u503c\u6240\u5728\u503c\u57df\u5757\u7684\u7f16\u53f7, $\\text{bel}(i)$ \u8868\u793a\u4e0b\u6807 $i$ \u6240\u5728\u4e0b\u6807\u5757\u7684\u7f16\u53f7\uff0c$a_i$ \u8868\u793a\u79bb\u6563\u5316\u4e4b\u540e\u7684\u6570\u5217\u3002\n  \n      \u5bf9\u4e8e\u7b2c $i$ \u4e2a\u4e0b\u6807\u5757\uff08$i\\in [\\text{bel}(p),\\text{num}]$\uff09\uff0c\u8fdb\u884c\u5982\u4e0b\u64cd\u4f5c\uff1a\n    \n      ```cpp\n      ++C1[i][BEL[v]], ++C2[i][v], --C1[i][BEL[a[p]], --C2[i][a[p]];\n      ```\n      \u6700\u540e\uff0c\u522b\u5fd8\u4e86\u66f4\u65b0 $a$ \u6570\u7ec4\u3002\n      \n  - \u67e5\u8be2\u6392\u540d\u64cd\u4f5c\uff1a\n      \n      \u4ee4\u67e5\u8be2\u533a\u95f4\u4e3a $[l, r]$\uff0c\u67e5\u8be2 $k$ \u7684\u6392\u540d\uff08$k$ \u7ecf\u8fc7\u79bb\u6563\u5316\uff09\uff0c\u5373\u6bd4 $k$ \u5c0f\u7684\u6570\u7684\u6570\u91cf $+1$ \u7684\u503c\u3002\n      \n      \u5982\u679c $\\text{bel}(l) = \\text{bel}(r)$\uff0c\u6211\u4eec\u76f4\u63a5\u66b4\u529b\u7edf\u8ba1\u533a\u95f4 $[l, r]$ \u5185\u6709\u51e0\u4e2a\u6570\uff08\u79bb\u6563\u5316\u540e\uff09\u6bd4 $k$ \u5c0f\u5373\u53ef\u3002\n      \n      \u5426\u5219\uff0c\u8fb9\u89d2\u66b4\u529b\u7edf\u8ba1\uff08\u548c\u4e0a\u9762\u7c7b\u4f3c\uff09\uff0c\u4e2d\u95f4\u90e8\u5206\u9760\u6211\u4eec\u7ef4\u62a4\u7684 $\\text{C1}$ \u548c $\\text{C2}$ \u6570\u7ec4\u5feb\u901f\u7d2f\u52a0\uff1a\n      \n      ```cpp\n      //\u4e2d\u95f4\u5feb\u901f\u7d2f\u52a0\u90e8\u5206\u4ee3\u7801\uff1a\n\tfor (int i = 1; i < BEL[k]; ++i) ret += C1[bel[r] - 1][i] - C1[bel[l]][i];\n\tfor (int i = L[BEL[k]]; i < k; ++i) ret += C2[bel[r] - 1][i] - C2[bel[l]][i]; //L(i)\u8868\u793a\u7b2ci\u4e2a\u503c\u57df\u5757\u7684\u5de6\u7aef\u70b9\u3002\n      ```\n      \n      \u6700\u540e\u8fd4\u56de $\\text{ret+1}$ \u5373\u53ef\u3002\n      \n  - \u67e5\u8be2\u7b2c $k$ \u5c0f\u64cd\u4f5c\uff1a\n  \n      \u4ee4\u67e5\u8be2\u533a\u95f4\u4e3a $[l, r]$\u3002\u548c\u540e\u9762\u7684\u524d\u9a71\u3001\u540e\u7ee7\u64cd\u4f5c\uff0c\u6211\u4eec\u90fd\u9700\u4e34\u65f6\u7ef4\u62a4\u4e24\u4e2a\u6570\u7ec4 $\\text{Cnt}$ \u548c $\\text{cnt}$\u3002$\\text{Cnt}(i)$ \u8868\u793a\u5728\u67e5\u8be2\u533a\u95f4\u7684\u8fb9\u89d2\u90e8\u5206\u4e2d\uff0c\u843d\u5728\u7b2c $i$ \u4e2a\u503c\u57df\u5757\u7684\u6570\u6709\u591a\u5c11\u4e2a\uff0c$\\text{cnt}(i)$ \u8868\u793a\u5728\u67e5\u8be2\u533a\u95f4\u7684\u8fb9\u89d2\u90e8\u5206\u4e2d\uff0c\u503c\u6070\u597d\u4e3a $i$ \u7684\u6570\u6709\u591a\u5c11\u4e2a\uff08\u7ecf\u8fc7\u79bb\u6563\u5316\uff09\u3002\u5728\u6c42\u51fa\u8fd4\u56de\u7b54\u6848\uff0c\u522b\u5fd8\u4e86\u5c06\u5176\u6e05\u96f6\u3002\n      \n      ```cpp\n      void Add(int x, int y) {//\u7edf\u8ba1     a[x...y] \u4e2d\u7684\u4fe1\u606f\n\t      for (int i = x; i <= y; ++i) ++Cnt[BEL[a[i]]], ++cnt[a[i]];\n      }\n      void Minus(int x, int y) {//\u6062\u590d\u521d\u59cb\u72b6\u6001\n\t      for (int i = x; i <= y; ++i) --Cnt[BEL[a[i]]], --cnt[a[i]];\n      }\n     ```\n      \u6709\u4e86 $\\text{C1},\\text{C2},\\text{Cnt},\\text{cnt}$ \u8fd9\u56db\u4e2a\u6570\u7ec4\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u786e\u5b9a\u7b54\u6848\u5728\u54ea\u4e2a\u503c\u57df\u5757\uff0c\u518d\u5728\u90a3\u4e2a\u503c\u57df\u5757\u4e2d\u6c42\u51fa\u7cbe\u786e\u7684\u7b54\u6848\u3002\u8fd9\u6837\uff0c\u590d\u6742\u5ea6\u5b8c\u7f8e\u5730\u505c\u7559\u5728 $\\sqrt{n+m}$\u3002\n      \n      \u67e5\u8be2\u7b2c $k$ \u5c0f\u4ee3\u7801\uff1a\n\n       ```\n\t\tinline int Get(int x, int y, int k) {//\u8fd4\u56de a[x...y] \u4e2d\u7b2c k+1 \u5927\u7684\u503c\u3002\n\t\t\tint P1 = bel[x], P2 = bel[y], A = 1, B, cur = 0;//A\u8868\u793a\u7b54\u6848\u5728\u54ea\u4e2a\u503c\u57df\u5757\uff0cB\u8868\u793a\u7b54\u6848\u5177\u4f53\u7684\u503c\u3002\u5148\u786e\u5b9aA\uff0c\u540e\u6c42B\u3002\n\t\t\tif (P1 == P2) {//\u67e5\u8be2\u533a\u95f4\u5728\u540c\u4e00\u4e2a\u5757\u4e2d\u3002\n\t\t\t\tAdd(x, y);\n\t\t\t\tfor (; k >= Cnt[A]; ++A) k -= Cnt[A];\n\t\t\t\tfor (B = L[A]; k >= cnt[B]; ++B) k -= cnt[B];\n\t\t\t\tMinus(x, y);\n\t\t\t\treturn val[B];\n\t\t\t}\n\t\t\tAdd(x, r[P1]), Add(l[P2], y);//\u6c42\u51fa Cnt,cnt \u6570\u7ec4\u3002\n\t\t\tfor (; k >= (cur = Cnt[A] + C1[P2 - 1][A] - C1[P1][A]); ++A) k -= cur;//\u786e\u5b9a\u7b54\u6848\u5728\u54ea\u4e2a\u503c\u57df\u5757\u3002\n\t\t\tfor (B = L[A]; k >= (cur = cnt[B] + C2[P2 - 1][B] - C2[P1][B]); ++B) k -= cur;//\u7cbe\u786e\u7b54\u6848\u3002\n\t\t\tMinus(x, r[P1]), Minus(l[P2], y);\n\t\t\treturn val[B];\n\t\t}       \n       ```\n\n   - \u67e5\u8be2\u524d\u9a71\u3001\u540e\u7ee7\u64cd\u4f5c\uff1a\u53ea\u9700\u4e0d\u65ad\u5411\u524d\u6216\u5411\u540e\u627e\u5230\u7b2c\u4e00\u4e2a\u6ee1\u8db3\u6761\u4ef6\u7684\u5373\u53ef\u3002\u601d\u7ef4\u96be\u5ea6\u8f83\u4f4e\uff0c\u4f46\u662f\u7ec6\u8282\u6bd4\u8f83\u7e41\u7410\uff0c\u5b9e\u73b0\u65f6\u4e00\u5b9a\u8981\u975e\u5e38\u6ce8\u610f\u3002\n  \n------------\n```cpp\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include <stdio.h>\n#include <ctype.h>\n#include <math.h>\n#include <algorithm>\n#define N 50005\n#define LEN (1 << 9)\n#define _R register\n#define INF 0x7FFFFFFF\nusing namespace std;\nchar Buf[1 << 24], *S(Buf), *T(Buf);\n#define getchar() (S == T && (T = (S = Buf) + fread(Buf, 1, 1 << 24, stdin), S == T) ? EOF : *S++)\ninline int input() {\n    _R int x(0), f(0);\n    _R char c(getchar());\n    while (!isdigit(c)) f |= (c == '-'), c = getchar();\n    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n    return f ? -x : x;\n}\nint a[N << 1], val[N << 1];\nint bel[N], BEL[N << 1];\nint len, num, Len, Num, n, m; \nint C1[LEN][LEN], C2[LEN][N << 1];\nint L[LEN], R[LEN], l[LEN], r[LEN];\nstruct Oper { int F, S, E, opt; };\nOper d[N];\nstruct Data {\n\tint pos, val;\n\tinline Data() {}\n\tinline Data(int POS, int VAL) : pos(POS), val(VAL) {}\n};\nData b[N << 1];\ninline bool cmp(const Data &A, const Data &B) { return A.val < B.val; }\ninline void Init_Data() {\n\tn = input(), m = input();\n\tint cnt = n, tot = 0;\n\tfor (int i = 1; i <= n; ++i) b[i] = Data(i, input());\n\tfor (int i = 1; i <= m; ++i) {\n\t\tint opt = d[i].opt = input();\n\t\tint F = input(), S = input(), T;\n\t\tif (opt == 3)\n\t\t\td[i].F = F, d[i].E = ++cnt, b[cnt] = Data(cnt, S);\n\t\telse {\n\t\t\tT = input(), d[i].F = F, d[i].S = S;\n\t\t\tif (opt != 2)\n\t\t\t\td[i].E = ++cnt, b[cnt] = Data(cnt, T); \n\t\t\telse\n\t\t\t\td[i].E = T;\n\t\t}\n\t}\n\tsort(b + 1, b + cnt + 1, cmp);\n\tfor (int i = 1; i <= cnt; ++i)\n\t\tif (i == 1 || b[i].val != b[i - 1].val)\n\t\t\tval[a[b[i].pos] = ++tot] = b[i].val;\n\t\telse\n\t\t\tval[a[b[i].pos] = tot] = b[i].val;\n\tlen = sqrt(n), num = n / len;\n\tLen = sqrt(tot), Num = tot / Len;\n\tfor (int i = 1; i <= n; ++i) bel[i] = (i - 1) / len + 1;\n\tfor (int i = 1; i <= tot; ++i) BEL[i] = (i - 1) / Len + 1;\n\tfor (int i = 1; i <= num; ++i) l[i] = r[i - 1] + 1, r[i] = l[i] + len - 1;\n\tif (r[num] != n)\n\t\t++num, l[num] = r[num - 1] + 1, r[num] = n;\n\tfor (int i = 1; i <= Num; ++i) L[i] = R[i - 1] + 1, R[i] = L[i] + Len - 1;\n\tif (R[Num] != tot)\n\t\t++Num, L[Num] = R[Num - 1] + 1, R[Num] = tot;\n\tfor (_R int i = 1; i <= num; ++i) {\n\t\tfor (_R int j = l[i], lim = r[i]; j <= lim; ++j) ++C2[i][a[j]], ++C1[i][BEL[a[j]]];\n\t\tfor (_R int j = 1; j <= tot; ++j) C2[i][j] += C2[i - 1][j];\n\t\tfor (_R int j = 1; j <= Num; ++j) C1[i][j] += C1[i - 1][j];\n\t}\n}\ninline int Rank(int x, int y, int val) {\n\tint P1 = bel[x], P2 = bel[y], ret = 0, pos = BEL[val];\n\tif (P1 == P2) {\n\t\tfor (_R int i = x; i <= y; ++i) ret += (a[i] < val);\n\t\treturn ret + 1;\n\t}\n\tfor (_R int i = x; i <= r[P1]; ++i) ret += (a[i] < val);\n\tfor (_R int i = l[P2]; i <= y; ++i) ret += (a[i] < val);\n\tfor (_R int i = 1; i < pos; ++i) ret += C1[P2 - 1][i] - C1[P1][i];\n\tfor (_R int i = L[pos]; i < val; ++i) ret += C2[P2 - 1][i] - C2[P1][i];\n\treturn ret + 1;\n}\nint Cnt[LEN], cnt[N << 1];\ninline void Add(int x, int y) {\n\tfor (_R int i = x; i <= y; ++i) ++Cnt[BEL[a[i]]], ++cnt[a[i]];\n}\ninline void Minus(int x, int y) {\n\tfor (_R int i = x; i <= y; ++i) --Cnt[BEL[a[i]]], --cnt[a[i]];\n}\ninline int Get(int x, int y, int k) {\n\tint P1 = bel[x], P2 = bel[y], A = 1, B, cur = 0;\n\tif (P1 == P2) {\n\t\tAdd(x, y);\n\t\tfor (; k >= Cnt[A]; ++A) k -= Cnt[A];\n\t\tfor (B = L[A]; k >= cnt[B]; ++B) k -= cnt[B];\n\t\tMinus(x, y);\n\t\treturn val[B];\n\t}\n\tAdd(x, r[P1]), Add(l[P2], y);\n\tfor (; k >= (cur = Cnt[A] + C1[P2 - 1][A] - C1[P1][A]); ++A) k -= cur;\n\tfor (B = L[A]; k >= (cur = cnt[B] + C2[P2 - 1][B] - C2[P1][B]); ++B) k -= cur;\n\tMinus(x, r[P1]), Minus(l[P2], y);\n\treturn val[B];\n}\ninline void Modify(int pos, int x) {\n\tint P = a[pos], BP = BEL[P], BN = BEL[x];\n\tfor (_R int i = bel[pos]; i <= num; ++i) ++C1[i][BN], ++C2[i][x], --C1[i][BP], --C2[i][P];\n\ta[pos] = x;\n}\ninline int Pre(int x, int y, int k) {\n\tint P1 = bel[x], P2 = bel[y], pos = BEL[k], A = pos - 1, B = k - 1;\n\tif (P1 == P2) {\n\t\tAdd(x, y);\n\t\twhile (B >= L[pos] && cnt[B] == 0) --B;\n\t\tif (B == L[pos] - 1) {\n\t\t\twhile (Cnt[A] == 0 && A >= 1) --A;\n\t\t\tif (A == 0) {\n\t\t\t\tMinus(x, y);\n\t\t\t\treturn -INF;\n\t\t\t}\n\t\t\tfor (B = R[A]; (!cnt[B]) && (B > L[A]); --B);\n\t\t}\n\t\tMinus(x, y);\n\t\treturn val[B];\n\t}\n\tAdd(x, r[P1]), Add(l[P2], y);\n\twhile (B >= L[pos] && cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) --B;\n\tif (B == L[pos] - 1) {\n\t\twhile (Cnt[A] + C1[P2 - 1][A] - C1[P1][A] == 0 && A >= 1) --A;\n\t\tif (A == 0) {\n\t\t\tMinus(x, r[P1]), Minus(l[P2], y);\n\t\t\treturn -INF;\n\t\t}\n\t\tfor (B = R[A]; (cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) && (B > L[A]) ; --B);\n\t}\n\tMinus(x, r[P1]), Minus(l[P2], y);\n\treturn val[B];\n}\ninline int Nex(int x, int y, int k) {\n\tint P1 = bel[x], P2 = bel[y], pos = BEL[k], A = pos + 1, B = k + 1;\n\tif (P1 == P2) {\n\t\tAdd(x, y);\n\t\twhile (B <= R[pos] && cnt[B] == 0) ++B;\n\t\tif (B == R[pos] + 1) {\n\t\t\twhile (Cnt[A] == 0 && A <= Num) ++A;\n\t\t\tif (A == Num + 1) {\n\t\t\t\tMinus(x, y);\n\t\t\t\treturn INF;\n\t\t\t}\n\t\t\tfor (B = L[A]; (!cnt[B]) && (B < R[A]); ++B);\n\t\t}\n\t\tMinus(x, y);\n\t\treturn val[B];\n\t}\n\tAdd(x, r[P1]), Add(l[P2], y);\n\twhile (B <= R[pos] && cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) ++B;\n\tif (B == R[pos] + 1) {\n\t\twhile (Cnt[A] + C1[P2 - 1][A] - C1[P1][A] == 0 && A <= Num) ++A;\n\t\tif (A == Num + 1) {\n\t\t\tMinus(x, r[P1]), Minus(l[P2], y);\n\t\t\treturn INF;\n\t\t}\n\t\tfor (B = L[A]; (cnt[B] + C2[P2 - 1][B] - C2[P1][B] == 0) && (B < R[A]); ++B);\n\t}\n\tMinus(x, r[P1]), Minus(l[P2], y);\n\treturn val[B];\n}\nint main() {\n\tInit_Data();\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (d[i].opt == 1)\n\t\t\tprintf(\"%d\\n\", Rank(d[i].F, d[i].S, a[d[i].E]));\n\t\telse if (d[i].opt == 2)\n\t\t\tprintf(\"%d\\n\", Get(d[i].F, d[i].S, d[i].E - 1));\n\t\telse if (d[i].opt == 3)\n\t\t\tModify(d[i].F, a[d[i].E]);\n\t\telse if (d[i].opt == 4)\n\t\t\tprintf(\"%d\\n\", Pre(d[i].F, d[i].S, a[d[i].E]));\n\t\telse\n\t\t\tprintf(\"%d\\n\", Nex(d[i].F, d[i].S, a[d[i].E]));\n\t}\n\treturn 0;\n}\n```\n- \u7b97\u6cd5\u6807\u7b7e\uff1a\u5206\u5757\uff08\u5206\u5757\u5957\u503c\u57df\u5206\u5757\uff09\uff0c\u6392\u5e8f\uff0c\u79bb\u6563\u5316\u3002\n\n- \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O((n+m)\\sqrt{n+m})$\u3002\n\n- \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a$O((n+m)\\sqrt{n})$\u3002\n\n- \u671f\u671b\u5f97\u5206\uff1a$100$ \u5206\u3002[\u63d0\u4ea4\u8bb0\u5f55](https://www.luogu.com.cn/record/34212939)\u3002\n\n- \u5907\u6ce8\uff1a\u8fd9\u662f\u4e00\u4efd\u5728\u8bc4\u6d4b\u673a\u4e0d\u65ad\u53d8\u6162\u540e\u4ecd\u7136\u8fdb\u4e86\u6700\u4f18\u89e3\u524d $20$ \u7684\u4ee3\u7801\u3002",
        "postTime": 1591509767,
        "uid": 148851,
        "name": "StevenLu1103",
        "ccfLevel": 6,
        "title": "P3380 \u3010\u6a21\u677f\u3011\u6811\u5957\u6811"
    },
    {
        "content": "# \u9898\u76ee\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[\u70b9\u8fd9\u91cc](https://www.luogu.com.cn/problem/P3380)\u770b\u9898\u76ee\u3002  \n# \u5206\u6790\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u6709\u8da3\u7684\u9898\u76ee\u3002\u5982\u679c\u60f3\u8981\u6df1\u5165\u5730\u4e86\u89e3**\u7ed3\u6784~~\u5957~~\u6843\u7ed3\u6784**\uff0c\u5f3a\u70c8\u5efa\u8bae\u5927\u5bb6\u53bb\u770b\u4e00\u770b[$Sswhy$\u5de8\u4f6c\u7684\u535a\u5ba2](https://www.luogu.com.cn/blog/3383669u/zong-shu-tao-shu-qian-xi-chang-yong-jie-gou-di-te-xing)\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8fd9\u7bc7\u9898\u89e3\u7684\u4e3b\u8981\u601d\u8def\u662f\u6811\u72b6\u6570\u7ec4\u5957\u6743\u503c\u7ebf\u6bb5\u6811\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e0d\u59a8\u4ece\u6700\u7b80\u5355\u7684\u95ee\u9898\u5f00\u59cb\u8003\u8651\uff1a  \n### [$P3369$,\u666e\u901a\u5e73\u8861\u6811](https://www.luogu.com.cn/problem/P3369)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5e73\u8861\u6811\u7684\u5165\u95e8\u9898\u3002\u4e0d\u8fc7\u53ef\u4ee5\u5c1d\u8bd5\u7528\u6743\u503c\u7ebf\u6bb5\u6811\u6765\u5199\u4e00\u5199\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e0d\u7528\u628a\u64cd\u4f5c\u90fd\u79bb\u6563\u5316\u3002\u6211\u4eec\u53ef\u4ee5\u7528**\u52a8\u6001\u5f00\u70b9\u6743\u503c\u7ebf\u6bb5\u6811**\u3002\u5bf9\u4e8e\u64cd\u4f5c$1$\u548c$2$\uff0c\u5c31\u662f\u7ebf\u6bb5\u6811\u7684\u6a21\u677f\u95ee\u9898\u3002\u5bf9\u4e8e\u64cd\u4f5c$3$\u548c$4$\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u9762\u4e8c\u5206\u3002\u5bf9\u4e8e\u64cd\u4f5c$5$\u548c$6$\uff0c\u53ef\u4ee5\u7528$3$\u548c$4$\u7ec4\u5408\u51fa\u6765\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u6240\u6709\u64cd\u4f5c\u7684\u65f6\u95f4\u90fd\u662f$O(\\log_2n)$\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~\u5148\u628a\u8fd9\u9053\u9898\u7ed9\u6c34\u8fc7\u53bb\u5427\u3002~~ \n### \u539f\u9898\u7684\u5f31\u5316\u7248  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5c31\u662f\u539f\u9898\u53bb\u6389\u4fee\u6539\u64cd\u4f5c\u3002   \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8fd9\u4e2a\u95ee\u9898\u5176\u5b9e\u5f88\u7ecf\u5178\u3002\u770b\u5230\u533a\u95f4\u67e5\u8be2\u7b2c$k$\u5927\u8fd9\u6837\u7684\u95ee\u9898\uff0c\u6211\u4eec\u4e0d\u96be\u60f3\u5230**\u9759\u6001\u4e3b\u5e2d\u6811**\u67e5\u8be2\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4e5f\u53ef\u4ee5\u62d3\u5c55\u5230\u5269\u4f59\u7684\u64cd\u4f5c\u3002\u7531\u4e8e\u503c\u57df\u5f88\u5927\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u4f7f\u7528\u52a8\u6001\u5f00\u70b9\u4e3b\u5e2d\u6811\u3002  \n### \u672c\u9898\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8003\u8651\u4e00\u4e0b\u9b54\u6539\u5f31\u5316\u7248\u672c\u7684\u89e3\u6cd5\u3002\u5728\u5f31\u5316\u7248\u7684\u505a\u6cd5\u4e2d\uff0c\u7b2c$i$\u9897\u4e3b\u5e2d\u6811\u4fdd\u5b58\u7684\u662f$[1,i]$\u7684\u6743\u503c\u4fe1\u606f\uff0c\u4e5f\u5c31\u662f\u4e00\u9897**\u524d\u7f00\u6743\u503c\u7ebf\u6bb5\u6811** !  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u56de\u60f3\u4e00\u4e0b\u6211\u4eec\u4f1a\u7528\u4ec0\u4e48\u4e1c\u897f\u7ef4\u62a4\u5355\u70b9\u4fee\u6539\u7684\u52a8\u6001\u524d\u7f00\uff1f  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$BIT!$  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e8e\u662f\u6211\u4eec\u5c31\u4e0d\u96be\u60f3\u5230\u7528$BIT$\u5957\u4e3b\u5e2d\u6811\u3002\u6b64\u65f6\u7b2c$i$\u68f5\u6811\u5c31\u50cf\u662f$BIT$\u4e2d\u7684\u8282\u70b9\u4e00\u6837\uff0c\u5b58\u50a8\u4e00\u4e2a\u957f\u4e3a$lowbit(i)$\u7684\u533a\u95f4\u3002\u6bcf\u6b21\u64cd\u4f5c\u4f1a\u6d89\u53ca$O(\\log_2n)$\u9897\u4e3b\u5e2d\u6811\uff0c\u5b9e\u73b0\u4e2d\u6211\u4eec\u4f1a\u628a\u8fd9$O(\\log_2n)$\u9897\u6811\u7684\u6839\u63d0\u51fa\u6765\uff1b\u4e00\u9897\u4e3b\u5e2d\u6811\u7684\u64cd\u4f5c\u662f$O(\\log_2n)$\uff0c\u4e8e\u662f\u4e00\u6b21\u603b\u64cd\u4f5c\u5c31\u662f$O(\\log_2^2n)$\u7684\u3002  \n# \u4ee3\u7801\n```cpp\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1e8, WRONG = 2147483647;\nconst int MAXN = 5e4 + 5, MAXM = 5e4 + 5, MAXLOG = 30;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n    x = 0;char s = getchar();int f = 1;\n    while( s > '9' || s < '0' ){if( s == '-' ) f = -1; s = getchar();}\n    while( s >= '0' && s <= '9' ){x = ( x << 3 ) + ( x << 1 ) + ( s - '0' ), s = getchar();}\n    x *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n    if( x < 0 ){ putchar( '-' ); x = ( ~ x ) + 1; }\n    if( 9 < x ){ write( x / 10 ); }\n    putchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MAX( const _T a, const _T b )\n{\n\treturn a > b ? a : b;\n}\n\nstruct segmentTreeNode\n{\n\tint lch, rch, cnt;\n\t#define lch( a ) ( segTree[a].lch )\n\t#define rch( a ) ( segTree[a].rch )\n\t#define cnt( a ) ( segTree[a].cnt )\n}segTree[MAXLOG * MAXLOG * ( MAXN + MAXM )];\n\nint rt[MAXN], a[MAXN];\nint N, M, siz = 1;\n\nint lowbit( const int &x ) { return x & ( -x ); }\nvoid upt( const int u ) { cnt( u ) = cnt( lch( u ) ) + cnt( rch( u ) ); }\nvoid gL( vector<int> &p ) { for( int i = 0 ; i < p.size() ; i ++ ) p[i] = lch( p[i] ); }\nvoid gR( vector<int> &p ) { for( int i = 0 ; i < p.size() ; i ++ ) p[i] = rch( p[i] ); }\nbool chk( const vector<int> p ) { for( int i = 0 ; i < p.size() ; i ++ ) if( p[i] ) return true; return false; }\nvector<int> getIndx( int x ) \n{ vector<int> a; for( a.clear() ; x ; x -= lowbit( x ) ) a.push_back( rt[x] ); return a; }\n\nint update( const int u, const int l, const int r, const int pos, const int add )\n{\n\tint cur = ++ siz, mid = l + r >> 1; segTree[cur] = segTree[u];\n\t#ifdef _DEBUG\n\tsegmentTreeNode &node1 = segTree[u], &node2 = segTree[cur];\n\t#endif;\n\tif( pos <= l && r <= pos ) { cnt( cur ) += add; return cur; }\n\tif( pos <= mid ) lch( cur ) = update( lch( u ), l, mid, pos, add );\n\telse rch( cur ) = update( rch( u ), mid + 1, r, pos, add );\n\tupt( cur );\n\treturn cur;\n}\n\nvoid change( const int indx, const int nVal )\n{\n\tfor( int i = indx ; i <= N ; i += lowbit( i ) )\n\t{\n\t\tif( ~ a[indx] ) rt[i] = update( rt[i], 0, INF, a[indx], -1 );\n\t\trt[i] = update( rt[i], 0, INF, nVal, 1 );\n\t}\n\ta[indx] = nVal;\n}\n\nint getRnk( const int L, const int R, const int pos )\n{\n\tint mid, res = 0, tmp, l = 0, r = INF;\n\tvector<int> lr = getIndx( L - 1 ), rr = getIndx( R );\n\twhile( chk( lr ) || chk( rr ) )\n\t{\n\t\tmid = l + r >> 1;\n\t\tif( pos <= mid ) gL( lr ), gL( rr ), r = mid;\n\t\telse\n\t\t{\n\t\t\ttmp = 0;\n\t\t\tfor( int i = 0 ; i < rr.size() ; i ++ ) tmp += cnt( lch( rr[i] ) );\n\t\t\tfor( int i = 0 ; i < lr.size() ; i ++ ) tmp -= cnt( lch( lr[i] ) );\n\t\t\tres += tmp;\n\t\t\tgR( lr ), gR( rr ), l = mid + 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint getKth( const int L, const int R, int rnk )\n{\n\tint mid, l = 0, r = INF, lcnt;\n\tvector<int> lr = getIndx( L - 1 ), rr = getIndx( R );\n\twhile( l < r )\n\t{\n\t\tmid = l + r >> 1, lcnt = 0;\n\t\tfor( int i = 0 ; i < rr.size() ; i ++ ) lcnt += cnt( lch( rr[i] ) );\n\t\tfor( int i = 0 ; i < lr.size() ; i ++ ) lcnt -= cnt( lch( lr[i] ) );\n\t\tif( rnk <= lcnt ) gL( lr ), gL( rr ), r = mid;\n\t\telse rnk -= lcnt, gR( lr ), gR( rr ), l = mid + 1;\n\t}\n\treturn l;\n}\n\nint main()\n{\n\tint opt, aa, b, c, tmp;\n\tread( N ), read( M );\n\tfor( int i = 1 ; i <= N ; i ++ ) a[i] = -1, rt[i] = 1;\n\tfor( int i = 1, tmp ; i <= N ; i ++ ) \n\t\tread( tmp ), change( i, tmp );\n\twhile( M -- )\n\t{\n\t\tread( opt ), read( aa ), read( b );\n\t\tif( opt ^ 3 ) read( c );\n\t\tif( opt == 1 ) write( getRnk( aa, b, c ) + 1 ), putchar( '\\n' );\n\t\tif( opt == 2 ) write( getKth( aa, b, c ) ), putchar( '\\n' );\n\t\tif( opt == 3 ) change( aa, b );\n\t\tif( opt == 4 )\n\t\t{\n\t\t\ttmp = getRnk( aa, b, c );\n\t\t\tif( ! tmp ) write( -WRONG ), putchar( '\\n' );\n\t\t\telse write( getKth( aa, b, tmp ) ), putchar( '\\n' );\n\t\t}\n\t\tif( opt == 5 ) \n\t\t{\n\t\t\ttmp = getRnk( aa, b, c + 1 );\n\t\t\tif( tmp == b - aa + 1 ) write( WRONG ), putchar( '\\n' );\n\t\t\telse write( getKth( aa, b, tmp + 1 ) ), putchar( '\\n' );\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1575873674,
        "uid": 123809,
        "name": "crashed",
        "ccfLevel": 0,
        "title": "\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09"
    },
    {
        "content": "\u63d0\u4f9b\u6307\u9488\u7ebf\u6bb5\u6811\u5957\u6307\u9488Splay\n\n\u67e5\u7b2ck\u5c0f\u4e8c\u5206\u65f6\u7684\u521d\u59cbl\u548cr\u7528\u7ebf\u6bb5\u6811\u5904\u7406\u51fa\u533a\u95f4\u6700\u5c0f\u6700\u5927\u503c\u6709\u6548\u63d0\u9ad8\u65f6\u6548\n\n```cpp\n#include<cstdio>\n#include<cctype>\n#include<climits>\n#include<algorithm>\nusing std::max;\nusing std::min;\ntemplate<class type>inline void read(type &in)\n{\n    in=0;short fh=1;char ch=getchar();\n    while (!isdigit(ch))fh=ch=='-'?-1:fh,ch=getchar();\n    while (isdigit(ch))in=(in<<3)+(in<<1)+ch-48,ch=getchar();\n    in*=fh;\n}\nconst int N=50001;\nint n,m,a[N];\nnamespace Splay\n{\n    struct tree\n    {\n        int value,size,cnt;\n        tree *son[2],*fa;\n        inline tree(int key)\n        {\n            value=key;\n            fa=son[0]=son[1]=NULL;\n            cnt=size=1;\n        }\n        inline void pushup()\n        {\n            size=cnt;\n            if (son[0])size+=son[0]->size;\n            if (son[1])size+=son[1]->size;\n        }\n    };\n    inline bool connection(tree *p) //\u83b7\u53d6\u7236\u5b50\u5173\u7cfb (p\u662f\u5b83\u7236\u4eb2\u7684x\u513f\u5b50\n    {\n        if (p&&p->fa)return p->fa->son[1]==p;\n    }\n    inline void connect(tree *&p,tree *&fa,bool which) //\u5efa\u7acb\u7236\u5b50\u5173\u7cfb (p\u662ffa\u7684which\u513f\u5b50\uff0cp\u7684\u7236\u4eb2\u662ffa\n    {\n        if (p)p->fa=fa;\n        if (fa)fa->son[which]=p;\n    }\n    inline void rotate(tree *&p) //\u628ap\u65cb\u8f6c\u4e0a\n    {\n        tree *fa=p->fa;\n        bool lr=connection(p);\n        connect(p,fa->fa,connection(fa));\n        connect(p->son[lr^1],fa,lr);\n        connect(fa,p,lr^1);\n        fa->pushup();p->pushup();\n    }\n    inline void splay(tree *&p,tree *goal,tree *&root) //\u5728\u6839\u4e3aroot\u7684Splay\u4e2d\u628ap\u65cb\u4f5cgoal\u7684\u513f\u5b50 (goal==NULL\u65f6\u65cb\u81f3\u6839\n    {\n        for (tree *fa;(fa=p->fa)!=goal;rotate(p))\n            if (fa->fa!=goal)\n                rotate(connection(p)==connection(fa)?fa:p);\n        if (goal==NULL)root=p;\n    }\n    inline void insert(int insertion,tree *&root) //\u628ainsertion\u63d2\u5165\u5230\u6839\u4e3aroot\u7684Splay\u4e2d\n    {\n        if (root==NULL)\n        {\n            root=new tree(insertion);\n            return;\n        }\n        tree *now=root;\n        while (1)\n        {\n            if (insertion==now->value)\n            {\n                now->cnt++;\n                now->pushup();\n                if (now->fa)now->fa->pushup();\n                splay(now,NULL,root);\n                return;\n            }\n            tree *fa=now;\n            bool direction=now->value<insertion;\n            now=fa->son[direction];\n            if (now==NULL)\n            {\n                now=new tree(insertion);\n                connect(now,fa,direction);\n                fa->pushup();\n                splay(now,NULL,root);\n                return;\n            }\n        }\n    }\n    inline void find(int key,tree *&root) //\u5728\u6839\u4e3aroot\u7684Splay\u4e2d\u67e5\u627e\u503c\u4e3akey\u7684\u70b9\u5e76splay\u81f3\u6839\n    {\n        if (root==NULL)return;\n        tree *now=root;\n        while (now->son[now->value<key]&&now->value!=key)\n            now=now->son[now->value<key];\n        splay(now,NULL,root);\n    }\n    inline tree *precursor(int x,tree *&root) //\u524d\u9a71\n    {\n        find(x,root);\n        if (root->value<x)return root;\n        tree *now=root->son[0];\n        while (now->son[1])now=now->son[1];\n        return now;\n    }\n    inline tree *successor(int x,tree *&root) //\u540e\u7ee7\n    {\n        find(x,root);\n        if (root->value>x)return root;\n        tree *now=root->son[1];\n        while (now->son[0])now=now->son[0];\n        return now;\n    }\n    inline void Delete(int x,tree *&root) //\u5220\u9664\n    {\n        tree *pre=precursor(x,root),*nxt=successor(x,root);\n        splay(pre,NULL,root);splay(nxt,pre,root);\n        tree *pop=nxt->son[0];\n        if (pop->cnt>1)\n            pop->cnt--,pop->pushup(),splay(pop,NULL,root);\n        else nxt->son[0]=NULL,delete pop;\n    }\n    inline int get_rank(int x,tree *&root) //\u5728\u6839\u4e3aroot\u7684Splay\u4e2d\u67e5\u8be2\u6709\u591a\u5c11\u4e2a\u6bd4x\u5c0f\u7684\u6570\n    {\n        tree *now=root;int ranking=-1; //\u539f\u672cranking\u8d4b\u7684\u662f1\uff0c\u7531\u4e8e\u63d2\u5165\u4e86-INF\uff0c\u6240\u4ee5\u8981\u53d8\u62100\uff0c\u7531\u4e8e\u662f\u6bd4x\u5c0f\u7684\u6570\u7684\u4e2a\u6570\uff0c\u4e5f\u5c31\u662fx\u7684\u6392\u540d\u51cf1\uff0c\u6240\u4ee5\u8d4b\u7684\u662f-1\n        while (now)\n            if (x<now->value)now=now->son[0];\n            else\n            {\n                ranking+=now->son[0]?now->son[0]->size:0;\n                if (now->value==x)return ranking;\n                ranking+=now->cnt;\n                now=now->son[1];\n            }\n        return ranking;\n    }\n}\nnamespace Segment_Tree\n{\n    struct tree\n    {\n        int l,r,maxval,minval; //\u5b58\u533a\u95f4\u6700\u5927\u6700\u5c0f\u503c\n        tree *lson,*rson;\n        Splay::tree *root;\n        inline tree(int l_,int r_)\n        {\n            l=l_;r=r_;\n            root=NULL;\n            lson=rson=NULL;\n            maxval=minval=0;\n        }\n        inline void pushup() //\u66f4\u65b0\n        {\n            maxval=max(lson->maxval,rson->maxval);\n            minval=min(lson->minval,rson->minval);\n        }\n    }*root;\n    inline void build(int l,int r,tree *&p) //\u5efa\u6811\n    {\n        p=new tree(l,r);\n        Splay::insert(INT_MAX,p->root); //\u63d2\u5165\u00b1INF\u4f7f\u5f97\u5220\u9664\u64cd\u4f5c\u4e2d\u6240\u6709\u6570\u90fd\u80fd\u627e\u5230\u524d\u9a71\u540e\u7ee7\n        Splay::insert(INT_MIN,p->root);\n        for (int i=l;i<=r;i++)\n            Splay::insert(a[i],p->root);\n        if (l==r){p->maxval=p->minval=p->root->value;return;}\n        int mid=l+r>>1;\n        build(l,mid,p->lson);\n        build(mid+1,r,p->rson);\n        p->pushup();\n    }\n    inline void update(int pos,int key,tree *&p) //\u4fee\u6539\u64cd\u4f5c\n    {\n        Splay::Delete(a[pos],p->root);\n        Splay::insert(key,p->root); //\u5148\u5220\u53bb\u539f\u6765\u7684\u6570\uff0c\u518d\u628a\u65b0\u7684\u6570\u63d2\u5165\n        if (p->l==p->r){a[pos]=p->maxval=p->minval=key;return;} //\u540c\u65f6\u6539\u53d8\u6700\u5927\u6700\u5c0f\u503c\n        int mid=p->l+p->r>>1;\n        if (pos<=mid)update(pos,key,p->lson);\n        else update(pos,key,p->rson);\n        p->pushup();\n    }\n    int query_max(int l,int r,tree *p) //\u67e5\u8be2\u533a\u95f4\u6700\u5927\u503c\n    {\n        if (p->l>r||p->r<l)return INT_MIN;\n        if (p->l>=l&&p->r<=r)return p->maxval;\n        return max(query_max(l,r,p->lson),query_max(l,r,p->rson));\n    }\n    int query_min(int l,int r,tree *p) //\u67e5\u8be2\u533a\u95f4\u6700\u5c0f\u503c\n    {\n        if (p->l>r||p->r<l)return INT_MAX;\n        if (p->l>=l&&p->r<=r)return p->minval;\n        return min(query_min(l,r,p->lson),query_min(l,r,p->rson));\n    }\n    inline int get_rank(int l,int r,int x,tree *p) //\u67e5\u8be2\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u6bd4x\u5c0f\u7684\u6570 (x\u7684\u6392\u540d-1\n    {\n        if (p->l>r||p->r<l)return 0;\n        if (p->l>=l&&p->r<=r)return Splay::get_rank(x,p->root);\n        return get_rank(l,r,x,p->lson)+get_rank(l,r,x,p->rson);\n    }\n    inline int find_rank(int l_,int r_,int ranking) //\u67e5\u8be2\u533a\u95f4\u7b2ck\u5c0f\n    {\n        int l=query_min(l_,r_,root),r=query_max(l_,r_,root)+1; //\u5229\u7528\u7ebf\u6bb5\u6811\u533a\u95f4\u6700\u5927\u6700\u5c0f\u503c\u7ed9l/r\u8d4b\u521d\u503c\n        while (l<r)\n        {\n            int mid=l+r>>1;\n            if (get_rank(l_,r_,mid,root)<ranking)l=mid+1;\n            else r=mid;\n        }\n        return l-1;\n    }\n    inline int precursor(int l,int r,int x,tree *p) //\u533a\u95f4\u524d\u9a71\n    {\n        if (p->l>r||p->r<l)return -INT_MAX;\n        if (p->l>=l&&p->r<=r)return Splay::precursor(x,p->root)->value;\n        return max(precursor(l,r,x,p->lson),precursor(l,r,x,p->rson));\n    }\n    inline int successor(int l,int r,int x,tree *p) //\u533a\u95f4\u540e\u7ee7\n    {\n        if (p->l>r||p->r<l)return INT_MAX;\n        if (p->l>=l&&p->r<=r)return Splay::successor(x,p->root)->value;\n        return min(successor(l,r,x,p->lson),successor(l,r,x,p->rson));\n    }\n}using namespace Segment_Tree;\nint main()\n{\n    read(n);read(m);\n    for (int i=1;i<=n;i++)read(a[i]);\n    build(1,n,root);\n    while (m--)\n    {\n        int opt,k;\n        read(opt);\n        if (opt==3)\n        {\n            int pos;\n            read(pos);read(k);\n            update(pos,k,root);\n            continue;\n        }\n        int l,r;read(l);read(r);read(k);\n        switch(opt)\t\n        {\n            case 1:\n                printf(\"%d\\n\",get_rank(l,r,k,root)+1);break; //\u8bb0\u5f97\u52a0\u4e0a1\n            case 2:\n                printf(\"%d\\n\",find_rank(l,r,k));break;\n            case 4:\n                printf(\"%d\\n\",precursor(l,r,k,root));break;\n            case 5:\n                printf(\"%d\\n\",successor(l,r,k,root));break;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1535037853,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u6700\u7ecf\u5178\u7684\uff0c\u76f4\u63a5\u4e0a\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u64cd\u4f5c $2$ \u662f\u6bd4\u8f83\u9ebb\u70e6\u7684\uff0c\u56e0\u4e3a\u533a\u95f4\u7684 $k$ \u503c\u662f\u4e0d\u80fd\u591f\u5408\u5e76\u7684\u3002\n\n\u4f46\u662f\u5982\u679c\u4e8c\u5206\u6700\u7ec8\u7684\u7b54\u6848\uff0c\u5c31\u8f6c\u53d8\u6210\u4e86\u548c\u64cd\u4f5c $1$ \u76f8\u540c\u7684\u95ee\u9898\u4e86\uff08\u4f46\u662f\u8981\u5224\u65ad\u76f8\u7b49\u7684\u60c5\u51b5\uff09\u3002\n\n\u56e0\u4e3a\u6709\u4e86\u4e8c\u5206\uff0c\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6 $O(N\\log^3N)$ \u3002\u7a33\u7a33\u7684 $1000\\text{ms}$ \u8fc7\u4e86\uff08\u9003\n\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#pragma GCC optimize(\"O3\")\n#define N 50020\n#define M 100000000\n#define INFINITE 2147483647\nusing namespace std;\n\nclass Node\n{\npublic:\n    Node *s[2];\n    int v;\n    int e;\n    int w;\n    int z;\n\n    Node(int _v, int _e, int _w, int _z) : v(_v), e(_e), w(_w), z(_z)\n    {\n        s[0] = s[1] = NULL;\n\n        return;\n    }\n\n    int Size(int k)\n    {\n        return s[k] ? s[k] -> z : 0;\n    }\n\n    void Update(void)\n    {\n        z = Size(0) + Size(1) + w;\n\n        return;\n    }\n};\n\nclass Treap\n{\npublic:\n    Node *r;\n\n    void RotateTreap(Node *&x, int k)\n    {\n        Node *t;\n\n        t = x -> s[!k];\n        x -> s[!k] = t -> s[k];\n        t -> s[k] = x;\n\n        x -> Update();\n        t -> Update();\n        x = t;\n\n        return;\n    }\n\n    void InsertTreap(Node *&x, int v, int w = 1)\n    {\n        if(!x)\n            x = new Node(v, rand(), w, w);\n        else if(x -> v == v)\n            x -> w += w;\n        else if(x -> v < v)\n        {\n            InsertTreap(x -> s[1], v, w);\n            if(x -> s[1] -> e < x -> e)\n                RotateTreap(x, 0);\n        }\n        else\n        {\n            InsertTreap(x -> s[0], v, w);\n            if(x -> s[0] -> e < x -> e)\n                RotateTreap(x, 1);\n        }\n        x -> Update();\n\n        return;\n    }\n\n    void RemoveTreap(Node *&x, int v)\n    {\n        Node *t;\n        int k;\n\n        if(x -> v == v)\n        {\n            if(x -> w > 1)\n                x -> w --;\n            else\n            {\n                if(!x -> s[0])\n                {\n                    t = x;\n                    x = x -> s[1];\n\n                    delete t;\n                    return;\n                }\n                if(!x -> s[1])\n                {\n                    t = x;\n                    x = x -> s[0];\n\n                    delete t;\n                    return;\n                }\n                k = x -> s[0] -> e < x -> s[1] -> e;\n                RotateTreap(x, k);\n                RemoveTreap(x -> s[k], v);\n            }\n        }\n        else\n        {\n            k = x -> v < v;\n            RemoveTreap(x -> s[k], v);\n            if(x -> s[k] && x -> s[k] -> e < x -> e)\n                RotateTreap(x, x -> s[k] -> e < x -> e);\n        }\n        x -> Update();\n\n        return;\n    }\n\n    int RankTreap(Node *x, int v)\n    {\n        int o;\n\n        for(o = 0;x;)\n            if(x -> v == v)\n            {\n                //printf(\"G %d\\n\", x -> Size(0));\n                return o + x -> Size(0);\n            }\n            else if(x -> v < v)\n            {\n                o += x -> Size(0) + x -> w;\n                x = x -> s[1];\n            }\n            else\n                x = x -> s[0];\n\n        return o;\n    }\n\n    int CountTreap(Node *x, int v)\n    {\n        while(x)\n        {\n            if(x -> v == v)\n                return x -> w;\n            x = x -> s[x -> v < v];\n        }\n\n        return 0;\n    }\n\n    int PrevTreap(Node *x, int v)\n    {\n        int o;\n\n        for(o = -INFINITE;x;)\n            if(x -> v >= v)\n                x = x -> s[0];\n            else\n            {\n                o = max(o, x -> v);\n                x = x -> s[1];\n            }\n\n        return o;\n    }\n\n    int SuffTreap(Node *x, int v)\n    {\n        int o;\n\n        for(o =  INFINITE;x;)\n            if(x -> v <= v)\n                x = x -> s[1];\n            else\n            {\n                o = min(o, x -> v);\n                x = x -> s[0];\n            }\n\n        return o;\n    }\n\n    void MergeTreap(Node *x)\n    {\n        if(!x)\n            return;\n        MergeTreap(x -> s[0]);\n        MergeTreap(x -> s[1]);\n        InsertTreap(r, x -> v, x -> w);\n\n        return;\n    }\n\n    void OutputTreap(Node *x)\n    {\n        if(!x)\n            printf(\"-1\");\n        else\n        {\n            putchar('(');\n            OutputTreap(x -> s[0]);\n            putchar(')');\n\n            printf(\"%d\",x -> v);\n\n            putchar('(');\n            OutputTreap(x -> s[1]);\n            putchar(')');\n        }\n\n        return;\n    }\n};\n\nclass Segment\n{\npublic:\n    Treap f[N * 4];\n\n    void BuildSegment(int *x, int i, int l, int r)\n    {\n        if(l >= r)\n        {\n            f[i].r = NULL;\n            f[i].InsertTreap(f[i].r, x[l]);\n\n            return;\n        }\n\n        BuildSegment(x, i * 2, l, (l + r) / 2);\n        BuildSegment(x, i * 2 + 1, (l + r) / 2 + 1, r);\n        f[i].r = NULL;\n        f[i].MergeTreap(f[i * 2].r);\n        f[i].MergeTreap(f[i * 2 + 1].r);\n        /*for(int t = l;t <= r;t ++)\n            f[i].InsertTreap(f[i].r, x[t]);*/\n        /*if(f[i * 2].r -> z > f[i * 2 + 1].r -> z)\n        {\n            f[i] = f[i * 2];\n            f[i].MergeTreap(f[i * 2 + 1].r);\n        }\n        else\n        {\n            f[i] = f[i * 2 + 1];\n            f[i].MergeTreap(f[i * 2].r);\n        }*/\n\n        return;\n    }\n\n    int RankSegment(int i, int l, int r, int s, int t, int v)\n    {\n        if(r < s || l > t)\n            return 0;\n        if(l >= s && r <= t)\n            return f[i].RankTreap(f[i].r, v);\n\n        return RankSegment(i * 2, l, (l + r) / 2, s, t, v) + RankSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v);\n    }\n\n    int CountSegment(int i, int l, int r, int s, int t, int v)\n    {\n        if(r < s || l > t)\n            return 0;\n        if(l >= s && r <= t)\n        {\n            //printf(\"[%d - %d] < %d have %d\\n\", l, r, v, f[i].RankTreap(f[i].r, v));\n            //f[i].OutputTreap(f[i].r);\n            return f[i].RankTreap(f[i].r, v) + f[i].CountTreap(f[i].r, v);\n        }\n\n        return CountSegment(i * 2, l, (l + r) / 2, s, t, v) + CountSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v);\n    }\n\n    int PrevSegment(int i, int l, int r, int s, int t, int v)\n    {\n        if(r < s || l > t)\n            return -INFINITE;\n        if(l >= s && r <= t)\n            return f[i].PrevTreap(f[i].r, v);\n\n        return max(PrevSegment(i * 2, l, (l + r) / 2, s, t, v), PrevSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v));\n    }\n\n    int SuffSegment(int i, int l, int r, int s, int t, int v)\n    {\n        if(r < s || l > t)\n            return  INFINITE;\n        if(l >= s && r <= t)\n            return f[i].SuffTreap(f[i].r, v);\n\n        return min(SuffSegment(i * 2, l, (l + r) / 2, s, t, v), SuffSegment(i * 2 + 1, (l + r) / 2 + 1, r, s, t, v));\n    }\n\n    void SetSegment(int *x, int i, int l, int r, int p, int v)\n    {\n        if(l > p || r < p)\n            return;\n        if(l == p && r == p)\n        {\n            f[i].RemoveTreap(f[i].r, x[p]);\n            f[i].InsertTreap(f[i].r, v   );\n\n            return;\n        }\n\n        f[i].RemoveTreap(f[i].r, x[p]);\n        f[i].InsertTreap(f[i].r, v   );\n        SetSegment(x, i * 2, l, (l + r) / 2, p, v);\n        SetSegment(x, i * 2 + 1, (l + r) / 2 + 1, r, p, v);\n\n        return;\n    }\n\n    int KthSegment(int s, int t, int k, int n, pair<int, int> v)\n    {\n        int l, m, r;\n\n        for(l = v.first - 1, r = v.second;l + 1 < r;)\n        {\n            //printf(\"%d : %d\\n\", (l + r) / 2, CountSegment(1, 0, n - 1, s, t, m = (l + r) / 2));\n            if(CountSegment(1, 0, n - 1, s, t, m = (l + r) / 2) >= k)\n                r = m;\n            else\n                l = m;\n        }\n\n        return r;\n    }\n};\n\nclass Segwin\n{\nprivate:\n    int n;\n    int f[N * 4];\n    int g[N * 4];\n\npublic:\n    void BuildSegwin(int n, int *x)\n    {\n        int i;\n\n        this -> n = n;\n        for(i = 0;i < n;i ++)\n            f[i + n] = g[i + n] = x[i];\n        for(i = n - 1;i > -1;i --)\n        {\n            f[i] = min(f[i << 1], f[i << 1 | 1]);\n            g[i] = max(g[i << 1], g[i << 1 | 1]);\n        }\n\n        return;\n    }\n\n    pair<int, int> MixSegwin(int s, int t)\n    {\n        pair<int, int> o;\n\n        for(o = make_pair(INFINITE, -INFINITE), s += n, t += n + 1;s < t;s >>= 1, t >>= 1)\n        {\n            if(s & 1)\n            {\n                o.first  = min(o.first , f[s]);\n                o.second = max(o.second, g[s]);\n                s ++;\n            }\n            if(t & 1)\n            {\n                t --;\n                o.first  = min(o.first , f[t]);\n                o.second = max(o.second, g[t]);\n            }\n        }\n\n        return o;\n    }\n\n    void SetSegwin(int p, int v)\n    {\n        for(p += n, f[p] = g[p] = v;p >>= 1;)\n        {\n            f[p] = min(f[p << 1], f[p << 1 | 1]);\n            g[p] = max(g[p << 1], g[p << 1 | 1]);\n        }\n\n        return;\n    }\n};\n\nint a[N];\nSegment f;\nSegwin g;\n\nint main()\n{\n    int n, m, p, l, r, k;\n    int i;\n\n    scanf(\"%d %d\", &n, &m);\n    for(i = 0;i < n;i ++)\n        scanf(\"%d\", &a[i]);\n\n    f.BuildSegment(a, 1, 0, n - 1);\n    g.BuildSegwin(n, a);\n    while(m --)\n    {\n        scanf(\"%d %d %d\", &p, &l, &r);\n        if(p != 3)\n        {\n            l --;\n            r --;\n            scanf(\"%d\", &k);\n        }\n\n        if(p == 1)\n            printf(\"%d\\n\", f.RankSegment(1, 0, n - 1, l, r, k) + 1);\n        if(p == 2)\n            printf(\"%d\\n\", f.KthSegment(l, r, k, n, /*make_pair(0, M)*/g.MixSegwin(l, r)));\n            //printf(\"%d\\n\", f.CountSegment(1, 0, n - 1, l, r, k));\n        if(p == 3)\n        {\n            f.SetSegment(a, 1, 0, n - 1, -- l, r);\n            g.SetSegwin(l, r);\n            a[l] = r;\n        }\n        if(p == 4)\n            printf(\"%d\\n\", f.PrevSegment(1, 0, n - 1, l, r, k));\n        if(p == 5)\n            printf(\"%d\\n\", f.SuffSegment(1, 0, n - 1, l, r, k));\n    }\n\n    return 0;\n}\n```",
        "postTime": 1510229039,
        "uid": 34354,
        "name": "gorokokoro",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u6811\u5957\u6811\u4e4b\u7ebf\u6bb5\u6811\u5957fhqtreap\u7684\u89e3\u6cd5\n\n\u5728\u9605\u8bfb\u672c\u7bc7\u9898\u89e3\u4e4b\u524d\uff0c\u6211\u4eec\u8ba4\u4e3a\u4f60\u5df2\u7ecf\u638c\u63e1\u4e86\u7ebf\u6bb5\u6811\u548c\u5e73\u8861\u6811\n\n\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u9898\u7684\u64cd\u4f5c\uff1a\n1. \u67e5\u8be2k\u5728\u533a\u95f4\u5185\u7684\u6392\u540d\n2. \u67e5\u8be2\u533a\u95f4\u5185\u6392\u540d\u4e3ak\u7684\u503c\n3. \u4fee\u6539\u67d0\u4e00\u4f4d\u503c\u4e0a\u7684\u6570\u503c\n4. \u67e5\u8be2k\u5728\u533a\u95f4\u5185\u7684\u524d\u9a71(\u524d\u9a71\u5b9a\u4e49\u4e3a\u4e25\u683c\u5c0f\u4e8ex\uff0c\u4e14\u6700\u5927\u7684\u6570\uff0c\u82e5\u4e0d\u5b58\u5728\u8f93\u51fa-2147483647)\n5. \u67e5\u8be2k\u5728\u533a\u95f4\u5185\u7684\u540e\u7ee7(\u540e\u7ee7\u5b9a\u4e49\u4e3a\u4e25\u683c\u5927\u4e8ex\uff0c\u4e14\u6700\u5c0f\u7684\u6570\uff0c\u82e5\u4e0d\u5b58\u5728\u8f93\u51fa2147483647)\n\n\u76f8\u6bd4\u666e\u901a\u5e73\u8861\u6811\u800c\u8a00\u7684\u533a\u522b\uff1a\n1. \u6240\u6709\u67e5\u627e\u5728\u533a\u95f4\u4e0a\u8fdb\u884c\n2. \u4e0d\u518d\u6709\u589e\u5220\u64cd\u4f5c\uff0c\u589e\u52a0\u4e86\u4e00\u4e2a\u4fee\u6539\u64cd\u4f5c\n\n\u90a3\u4e48\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u7528\u4e00\u9897fhq_treap\u6765\u7ef4\u62a4\n\n\u90a3\u4e48\u600e\u4e48\u5feb\u901f\u67e5\u627e\u533a\u95f4\u5462\uff1f\n\n\u7528\u7ebf\u6bb5\u6811\n\n\u90a3\u4e48\uff0c\u7ebf\u6bb5\u6811\u5957fhqtreap\u7684\u601d\u8def\u5c31\u6e05\u6670\u4e86\n\n**\u6765\u770b\u7ebf\u6bb5\u6811\u7684\u5404\u79cd\u4fe1\u606f\uff1a**\n- \u70b9\u4fe1\u606f\uff1a\u5f53\u524d\u8282\u70b9\u5bf9\u5e94\u7684fhq_treap\n- \u533a\u95f4\u4fe1\u606f\uff1a\u5f53\u524d\u533a\u95f4\u5bf9\u5e94\u7684fhq_treap\n- \u76ee\u6807\u4fe1\u606f\uff1a\u6574\u9897fhq_treap\n\n**\u90a3\u4e48fhq_treap\u7ef4\u62a4\u4ec0\u4e48\uff1a**\n\n~~\u5957\u8def\u7684\u5f88\uff0c~~\u503c\uff0c\u5de6\u513f\u5b50\uff0c\u53f3\u513f\u5b50\uff0c\u968f\u673a\u4f18\u5148\u7ea7\uff0c\u503c\uff0c\u5b50\u6811\u5927\u5c0f\n\n\u53d8\u91cf\u547d\u540d\u504f\u5411\u300a\u7b97\u6cd5\u7ade\u8d5b\u8fdb\u9636\u6307\u5357\u300b \u674e\u715c\u4e1c \u8457\n\n**\u4ee3\u7801**\n```cpp\n#pragma GCC optimize(2)\n#include<bits/stdc++.h>\n#include<iostream>\n#include<cstdio>\n#define ll long long\nusing namespace std;\n\nconst ll N=50010,M=1e7,INF=2147483647;\nll n,m,tot,a[N];\nstruct fhqtreap{\n    ll val,size,rnd,lson,rson;\n}tree[M];\n\ninline ll read(){\n    ll x=0,tmp=1;\n    char ch=getchar();\n    while(!isdigit(ch)){\n        if(ch=='-') tmp=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch)){\n        x=(x<<3)+(x<<1)+(ch^48);\n        ch=getchar();\n    }\n    return tmp*x;\n}\n\ninline void write(ll x){\n    if(x<0){\n        putchar('-');\n        x=-x;\n    }\n    ll y=10,len=1;\n    while(y<=x){\n        y=(y<<3)+(y<<1);\n        len++;\n    }\n    while(len--){\n        y/=10;\n        putchar(x/y+48);\n        x%=y;\n    }\n}\n\nstruct fhqTreap{//fhqtreap\n    ll root;\n    inline void pushup(ll x){\n        tree[x].size=tree[tree[x].lson].size+tree[tree[x].rson].size+1;\n    }\n    ll merge(ll x,ll y){\n        if(!x||!y) return x|y;\n        if(tree[x].rnd<tree[y].rnd){\n            tree[x].rson=merge(tree[x].rson,y);\n            pushup(x);\n            return x;\n        }\n        else{\n            tree[y].lson=merge(x,tree[y].lson);\n            pushup(y);\n            return y;\n        }\n    }\n    void split(ll x,ll val,ll &u,ll &v){\n        if(!x){\n            u=v=0;\n            return;\n        }\n        if(tree[x].val<=val){\n            u=x;\n            split(tree[x].rson,val,tree[u].rson,v);\n        }\n        else{\n            v=x;\n            split(tree[x].lson,val,u,tree[v].lson);\n        }\n        pushup(x);\n    }\n    inline ll New(ll val){\n        tree[++tot].val=val;\n        tree[tot].rnd=rand();\n        tree[tot].size=1;\n        return tot;\n    }\n    inline void Insert(ll val){\n        ll x,y,z;\n        split(root,val,x,y);\n        root=merge(x,merge(New(val),y));\n    }\n    inline void Delete(ll val){\n        ll x,y,z;\n        split(root,val,x,z);\n        split(x,val-1,x,y);\n        y=merge(tree[y].lson,tree[y].rson);\n        root=merge(x,merge(y,z));\n    }\n    inline ll getrankbyval(ll val){\n        ll x,y;\n        split(root,val-1,x,y);\n        ll ans=tree[x].size+1;\n        root=merge(x,y);\n        return ans;\n    }\n    inline void build(ll l,ll r){\n        for(ll i=l; i<=r; i++) Insert(a[i]);\n    }\n    ll getvalbyrank(ll x,ll rank){\n        if (rank<=tree[tree[x].lson].size) return getvalbyrank(tree[x].lson,rank);\n        if (rank==tree[tree[x].lson].size+1) return tree[x].val;\n        return getvalbyrank(tree[x].rson,rank-tree[tree[x].lson].size-1);\n    }\n    inline ll getprev(ll val){\n        ll x,y;\n        split(root,val-1,x,y);\n        ll ans;\n        if(tree[x].size) ans=getvalbyrank(x,tree[x].size);\n        else ans=-INF;\n        root=merge(x,y);\n        return ans;\n    }\n    inline ll getnext(ll val){\n        ll x,y;\n        split(root,val,x,y);\n        ll ans;\n        if(tree[y].size) ans=getvalbyrank(y,1);\n        else ans=INF;\n        root=merge(x,y);\n        return ans;\n    }\n}treap[N<<2];\n\nstruct SegmentTree{//\u7ebf\u6bb5\u6811\n    void build(ll p,ll l,ll r){\n        treap[p].build(l,r);\n        if(l==r) return;\n        ll mid=(l+r)>>1;\n        build(p<<1,l,mid);\n        build(p<<1|1,mid+1,r);\n    }\n    ll getrankbyval(ll p,ll L,ll R,ll l,ll r,ll val){\n        if(R<l||L>r) return 0;\n        if(l<=L&&R<=r) return treap[p].getrankbyval(val)-1;\n        ll mid=(L+R)>>1;\n        return getrankbyval(p<<1,L,mid,l,r,val)+getrankbyval(p<<1|1,mid+1,R,l,r,val);\n    }\n    inline ll getvalbyrank(ll l,ll r,ll rank){\n        ll L=0,R=1e8,ans=-1;\n        while(L<=R){\n            ll mid=(L+R)>>1;\n            if(getrankbyval(1,1,n,l,r,mid)+1<=rank){\n                ans=mid;\n                L=mid+1;\n            }\n            else R=mid-1;\n        }\n        return ans;\n    }\n    void update(ll p,ll L,ll R,ll x,ll val){\n        treap[p].Delete(a[x]);\n        treap[p].Insert(val);\n        if(L==R) return;\n        ll mid=(L+R)>>1;\n        if(x<=mid) update(p<<1,L,mid,x,val);\n        else update(p<<1|1,mid+1,R,x,val);\n    }\n     ll getprev(ll p,ll L,ll R,ll l,ll r,ll val){\n        if(R<l||L>r) return -INF;\n        if(l<=L&&R<=r) return treap[p].getprev(val);\n        ll mid=(L+R)>>1;\n        return max(getprev(p<<1,L,mid,l,r,val),getprev(p<<1|1,mid+1,R,l,r,val));\n    }\n    ll getnext(ll p,ll L,ll R,ll l,ll r,ll val){\n        if(R<l||L>r) return INF;\n        if(l<=L&&R<=r) return treap[p].getnext(val);\n        ll mid=(L+R)>>1;\n        return min(getnext(p<<1,L,mid,l,r,val),getnext(p<<1|1,mid+1,R,l,r,val));\n    }\n}Tree;\n\nint main(){\n    cin>>n>>m;\n    for(ll i=1; i<=n; i++) a[i]=read();\n    Tree.build(1,1,n);\n    while(m--){\n        ll opt=read();\n        switch(opt){\n            case 1:{\n                ll l=read(),r=read(),k=read();\n                write(Tree.getrankbyval(1,1,n,l,r,k)+1); putchar('\\n');\n                break;   \n            }\n            case 2:{\n                ll l=read(),r=read(),k=read();\n                write(Tree.getvalbyrank(l,r,k)); putchar('\\n');  \n                break;  \n            }\n            case 3:{\n                ll p=read(),k=read();\n                Tree.update(1,1,n,p,k);\n                a[p]=k;\n                break;\n            }\n            case 4:{\n                ll l=read(),r=read(),k=read();\n                write(Tree.getprev(1,1,n,l,r,k)); putchar('\\n');\n                break;\n            }\n            case 5:{\n                ll l=read(),r=read(),k=read();\n                write(Tree.getnext(1,1,n,l,r,k)); putchar('\\n');    \n                break;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1569455604,
        "uid": 27924,
        "name": "xukuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "[my blog](https://blog.csdn.net/xumingyang0/article/details/86291023)\n\n[\u9898\u76ee](https://www.luogu.org/problemnew/show/P3380)\n# Solution\n\u628a\u666e\u901a\u5e73\u8861\u6811\u4ee3\u7801\u4e2d$rt$\u6539\u6210$rt[pos]$\uff0c\u7136\u540e\u5199\u4e00\u4e2a\u7ebf\u6bb5\u6811\u5373\u53ef\n\n\u8bf4\u8bf4\u5f88\u7b80\u5355\uff0c\u4f46\u662f\u5199\u8d77\u6765\u771f\u7684\u9ebb\u70e6\u6b7b\uff0c\u540e\u6765\u6211\u662f\u627e\u4e86\u4e00\u4efd\u548c\u6211\u5199\u5f97\u6709\u70b9\u50cf\u7684\u4ee3\u7801\u6539\u4e86\u597d\u4e45\u624d\u6539\u51fa\u6765\u7684\uff0c\u5176\u4e2d\u4e00\u4e2a\u539f\u56e0\u7adf\u7136\u662f\u6211\u539f\u672c\u7684\u5e73\u8861\u6811\u677f\u5b50\u5c31\u662f\u9519\u7684\uff01\uff01\uff01\n\n\u5bf9\u4e8e\u6211\u81ea\u5df1\u800c\u8a00\uff0c\u8fd9\u9898\u7684\u96be\u70b9\u5728\u4e8e\u6811\u5957\u6811\uff0c\u800c\u4e0d\u662f\u5e73\u8861\u6811\u6216\u662f\u7ebf\u6bb5\u6811\uff0c\u6240\u4ee5\u6211\u7684\u4ee3\u7801\u4e2d\u8bb2\u7684\u662f\u5404\u79cd\u9519\u8bef\uff0c\u800c\u4e0d\u662f\u600e\u4e48\u5199\n\n# Code\n\u4ee3\u7801\u6709\u70b9\u6162\uff0c$bzoj$\u4e0a\u8dd1\u4e86$9916ms$\n\n\u6ce8\u91ca\u6389\u7684\u4ee3\u7801\u65c1\u8fb9\u82e5\u6ca1\u6709\u6587\u5b57\uff0c\u5219\u8bf4\u660e\u662f\u53e6\u4e00\u79cd\u5199\u6cd5\uff0c\u4e5f\u662f\u5bf9\u7684\uff0c\u53ea\u662f\u6162\u4e00\u70b9\uff0c\u53ef\u4ee5\u76f4\u63a5\u66ff\u6362 \n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2000002,inf=2147483647;\n#define lc ch[0]\n#define rc ch[1]\nint sz[N],fa[N],cnt[N],a[N],ans,mid,l,r,ll,rr,k,rt[N],tot,val[N],ch[2][N],n,m,i,opt;\ninline char gc(){\n\tstatic char buf[100000],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int rd(){\n\tint x=0,fl=1;char ch=gc();\n\tfor (;ch<48||ch>57;ch=gc())if(ch=='-')fl=-1;\n\tfor (;48<=ch&&ch<=57;ch=gc())x=(x<<3)+(x<<1)+(ch^48);\n\treturn x*fl;\n}\ninline void wri(int a){if(a<0)a=-a,putchar('-');if(a>=10)wri(a/10);putchar(a%10|48);}\ninline void wln(int a){wri(a);puts(\"\");}\n//---------------------------------------------------------\u5e73\u8861\u6811 \nvoid upd(int x){sz[x]=sz[lc[x]]+sz[rc[x]]+cnt[x];}\nvoid rot(int x){\n\tint y=fa[x],z=fa[y];bool f=x==rc[y];\n\tif (z) ch[y==rc[z]][z]=x;\n\tfa[x]=z,fa[y]=x,fa[ch[!f][x]]=y,ch[f][y]=ch[!f][x],ch[!f][x]=y;\n\tupd(y);\n}\nvoid splay(int pos,int x){\n\twhile (fa[x]){\n\t\tint y=fa[x],z=fa[y];\n\t\tif (z) rot((y==rc[z])^(x==rc[y])?x:y);\n\t\trot(x);\n\t}\n\tupd(x);\n\trt[pos]=x;\n}\nvoid ins(int pos,int x){\n\tint t=rt[pos],ff=0;\n\twhile (t){\n\t\tsz[t]++;\n\t\tif (x==val[t]){\n\t\t\tcnt[t]++;\n\t\t\treturn;\n\t\t}\n\t\tff=t,t=ch[x>val[t]][t];\n\t}\n\tt=++tot;\n\tch[x>val[ff]][ff]=t;\n\tfa[t]=ff,val[t]=x,lc[t]=rc[t]=0,sz[t]=cnt[t]=1;\n\tsplay(pos,t);\n}\nint find(int pos,int x){\n\tint t=rt[pos];\n\tdo{\n\t\tif (x==val[t]) break;\n\t\tt=ch[x>val[t]][t];\n\t}while (1);\n\tsplay(pos,t);\n\treturn t;\n}\nint rank(int pos,int x){\n\tint t=rt[pos],ret=0;\n\twhile (t){\n\t\tif (x==val[t]) return ret+sz[lc[t]];\n\t\tif (x>val[t]){\n\t\t\tret+=sz[lc[t]]+cnt[t];\n\t\t\tt=rc[t];\n\t\t}else t=lc[t];\n\t}\n\treturn ret;\n}\n//int Max(int x){return rc[x]?Max(rc[x]):x;}\nint Max(int t){while (rc[t]) t=rc[t];return t;}\nvoid del(int pos,int x){\n\tx=find(pos,x);\n\tint ls=lc[x],rs=rc[x];\n\tif (--cnt[x]) return;\n\tif (!ls && !rs){//\u4e0d\u80fd\u76f4\u63a5return,\u5148\u6e05\u7a7a\u4e00\u4e0b \n\t\tint &k=rt[pos];\n\t\tk=fa[k]=lc[k]=rc[k]=sz[k]=cnt[k]=val[k]=0;\n\t\treturn;\n\t}\n\tif (!ls) rt[pos]=rc[x],fa[rt[pos]]=0;\n\telse if (!rs) rt[pos]=lc[x],fa[rt[pos]]=0;\n\telse{\n\t\tint lson=Max(ls);swap(ls,lson);\n\t\tfa[lson]=0,splay(pos,ls),rc[ls]=rs,fa[rs]=ls,upd(ls);\n\t}\n}\n/*int PRE(int t,int x){\n\tif (!t) return 0;\n\tif (x<=val[t]) return PRE(lc[t],x);\n\tint tmp=PRE(rc[t],x);\n\treturn tmp?tmp:t;\n}\nint pre(int pos,int x){return val[PRE(rt[pos],x)];}*/\nint pre(int pos,int x){\n\tint t=rt[pos];int ans=-inf;\n\twhile (t)\n\t\tif (x>val[t]) ans=max(ans,val[t]),t=rc[t];\n\t\telse t=lc[t];\n\treturn ans;\n}\nint nxt(int pos,int x){\n\tint t=rt[pos];int ans=inf;\n\twhile (t)\n\t\tif (x<val[t]) ans=min(ans,val[t]),t=lc[t];\n\t\telse t=rc[t];\n\treturn ans;\n}\n//---------------------------------------------------------\u7ebf\u6bb5\u6811\n#define mid ((l+r)>>1)//\u5982\u679c\u6ca1\u52a0,\u8fd9\u4e2amid\u5c31\u53d8\u4e8c\u5206\u91cc\u7684mid\u4e86 \nvoid insert(int t,int l,int r,int x,int v){\n\tins(t,v);//\u548c\u4e0b\u9762\u7684\u4fee\u6539\u4e00\u6837,\u6211\u521a\u5f00\u59cb\u662f\u5728l==r\u7684\u65f6\u5019\u63d2\u5165\u7684 \n\tif (l==r) return;\n\tif (x<=mid) insert(t<<1,l,mid,x,v);\n\telse insert(t<<1|1,mid+1,r,x,v);\n\t//\u51fd\u6570\u5f00\u59cb\u7684ins()\u4f5c\u7528\u8ddfupdate()\u5dee\u4e0d\u591a \n}\nvoid change(int t,int l,int r,int x,int v){\n\tdel(t,a[x]),ins(t,v);//\u521a\u5f00\u59cb\u5199\u7684\u662fdel(t,v) \n\tif (l==r) return;\n\tif (x<=mid) change(t<<1,l,mid,x,v);\n\telse change(t<<1|1,mid+1,r,x,v);\n}\nint query(int t,int l,int r,int x,int y,int v){\n\tif (x<=l && r<=y) return rank(t,v);\n//\tif (x<=l && r<=y) return sz[lc[find(t,v)]];----\u4f1a\u6709\u4e0d\u5b58\u5728v\u7684\u60c5\u51b5,find()\u4f1a\u6b7b\u5faa\u73af \n\tint ans=0;\n\tif (x<=mid) ans+=query(t<<1,l,mid,x,y,v);\n\tif (mid<y) ans+=query(t<<1|1,mid+1,r,x,y,v);\n\treturn ans;\n}\nint Prev(int t,int l,int r,int x,int y,int v){\n\tif (x<=l && r<=y) return pre(t,v);\n\tint ans=-inf;\n\tif (x<=mid) ans=max(ans,Prev(t<<1,l,mid,x,y,v));\n\tif (mid<y) ans=max(ans,Prev(t<<1|1,mid+1,r,x,y,v));\n\treturn ans;\n}\nint Succ(int t,int l,int r,int x,int y,int v){\n\tif (x<=l && r<=y) return nxt(t,v);\n\tint ans=inf;\n\tif (x<=mid) ans=min(ans,Succ(t<<1,l,mid,x,y,v));\n\tif (mid<y) ans=min(ans,Succ(t<<1|1,mid+1,r,x,y,v));\n\treturn ans;\n}\n#undef mid\nint main(){\n\tn=rd(),m=rd();\n\tfor (i=1;i<=n;i++) a[i]=rd(),insert(1,1,n,i,a[i]);\n\tfor (;m--;){\n\t\topt=rd(),l=rd();\n\t\tif (opt!=3) r=rd();\n\t\tk=rd();\n\t\tif (opt==1) wln(query(1,1,n,l,r,k)+1);\n\t\tif (opt==2){\n\t\t\tll=0,rr=1e8;\n\t\t\twhile (ll<=rr){\n\t\t\t\tmid=ll+rr>>1;\n\t\t\t\tif (query(1,1,n,l,r,mid)+1<=k) ans=mid,ll=mid+1;\n\t\t\t\telse rr=mid-1;\n\t\t\t\t/*if (query(1,1,n,l,r,mid)+1<k) ll=mid+1;------\u6bd4\u5982\u67e5\u8be2k=1\u65f6query()+1\u4e00\u5b9a>=k,\u4f1a\u5bfc\u81f4\u4e0d\u65ad\u5411\u5de6,\u8f93\u51fa0 \n\t\t\t\telse ans=mid,rr=mid-1;\n\t\t\t\t\u5176\u5b9e\u4e24\u8005\u672c\u8d28\u5dee\u522b\u662fquery()+1==k\u7684\u65f6\u5019\u5e94\u8be5\u5411\u5de6\u8fd8\u662f\u5411\u53f3,\n\t\t\t\t\u5982\u679c\u662f\u5c0f\u4e8e\u53f7\u7684\u8bdd,rr\u4e0d\u65ad\u5411\u5de6,query()\u4e5f\u53d8\u5c0f,\u5bfc\u81f4\u7b54\u6848\u548c\u6807\u7a0b\u5dee\u5f88\u591a*/\n\t\t\t}\n\t\t\twln(ans);\n\t\t}\n\t\tif (opt==3) change(1,1,n,l,k),a[l]=k;//a[l]=k\u4e0d\u80fd\u5fd8 \n\t\tif (opt==4) wln(Prev(1,1,n,l,r,k));\n\t\tif (opt==5) wln(Succ(1,1,n,l,r,k));\n\t}\n}\n```",
        "postTime": 1547175673,
        "uid": 22469,
        "name": "Mingoal",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "        \u4e8c\u903c\u5e73\u8861\u6811  \n  \u601d\u8def\u5341\u5206\u7b80\u5355\uff0c\u4f46\u662f\u7801\u91cf\u5f88\u5927\u3002\u3002\u3002   \n \u6211\u7528\u7684\u662f\u7ebf\u6bb5\u6811\u5957 $ splay $ .  \n 1 . \u6392\u540d\u5c31\u76f4\u63a5\u6c42\u51fa\u7ebf\u6bb5\u6811\u533a\u95f4\u4e2d\u6bcf\u4e00\u4e2a $ splay $ \u4e2d\u5176\u524d\u9762\u6709\u591a\u5c11\u4e2a\u6570\u6c42\u548c\u518d\u52a0 $1$ .   \n 2 . \u6392\u540d\u4e3a $k$ \u7684\u663e\u7136\u8981\u4e8c\u5206\uff0c\u8bb0\u5f55\u4e00\u4e0b\u6700\u5927\u503c\u7136\u540e\u4e8c\u5206\u770b\u6392\u540d\u5c31\u597d\u54af \u3002  \n 3 . \u4fee\u6539\u6309\u7167\u7ebf\u6bb5\u6811\u7684\u4fee\u6539\u6bcf\u4e00\u4e2a\u8be5\u70b9\u6240\u5728\u7684\u533a\u95f4\u66f4\u6539\u4e00\u4e0b\u5c31\u597d\u54af \u3002  \n 4 . \u627e $ l~->~r $ \u6bcf\u4e2a\u533a\u95f4\u4e2d\u524d\u9a71\u7684\u6700\u5927\u503c \u3002   \n 5 . \u627e $ l~->~r $ \u6bcf\u4e2a\u533a\u95f4\u4e2d\u540e\u7ee7\u7684\u6700\u5c0f\u503c \u3002\n \n \u6ce8\u610f\u4e00\u5b9a\u8981\u5f00\u5927\u7a7a\u95f4 \uff01\uff01\uff01\n \n ```\n#include<bits/stdc++.h>\n#define ls l,mid,rt<<1\n#define rs mid+1,r,rt<<1|1\n\nusing namespace std;\n\nconst int inf=2147483647;\nconst int maxn=4500001;\nint n,m,a[maxn],ans,tot=0;\nint ch[maxn][2],rot[maxn],fa[maxn],w[maxn],siz[maxn],cnt[maxn];\nint MAX=-inf;\n\ninline int read()\n{\n\tint date=0,f=1;\n\tchar c=getchar();\n\twhile('0'>c||c>'9')\n\t{\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile('0'<=c&&c<='9')\n\t{\n\t\tdate=date*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn date*f; \n}\n\ninline void ud(int x)\n{\n\tsiz[x]=siz[ch[x][0]]+siz[ch[x][1]]+cnt[x];\n}\n\ninline int splaypre2(int i)\n{\n\tint x=ch[rot[i]][0];while(ch[x][1]) x=ch[x][1];return x;\n}\ninline int splaynt2(int i)\n{\n\tint x=ch[rot[i]][1];while(ch[x][0]) x=ch[x][0];\treturn x;\n}\n\ninline int gi(int v,int i)\n{\n\tint now=rot[i];\n\twhile(w[now]!=v)\n\t{\n\t\tif(w[now]>v) \n\t\t{\n\t\t\tif(ch[now][0]==0) break;\n\t\t\tnow=ch[now][0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ch[now][1]==0) break;\n\t\t\tnow=ch[now][1];\n\t\t}\n\t}\n\treturn now;\n}\n\ninline void add(int x,int v)\n{\n\ttot++;\n\tsiz[tot]=cnt[tot]=1;\n\tch[tot][0]=ch[tot][1]=0;\n\tw[tot]=v;\n\tif(w[x]>v)\n\t\tch[x][0]=tot;\n\telse ch[x][1]=tot;\n\tfa[tot]=x;\n} \n\ninline void ronate(int x,int w)\n{\n\tint f=fa[x],ff=fa[f];\n\tch[f][w^1]=ch[x][w];\n\tif(ch[x][w]) fa[ch[x][w]]=f;\n\tif(ch[ff][0]==f) ch[ff][0]=x;\n\telse ch[ff][1]=x;\n\tch[x][w]=f;\n\tfa[x]=ff;\n\tfa[f]=x;\n\tud(f);\n\tud(x);\n}\n\ninline void splay(int i,int x,int tar)\n{\n\twhile(fa[x]!=tar)\n\t{\n\t\tint f=fa[x],ff=fa[f];\n\t\tif(ff==tar)\n\t\t{\n\t\t\tif(ch[f][0]==x) ronate(x,1);\n\t\t\telse ronate(x,0); \n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(ch[ff][0]==f) \n\t\t\t{\n\t\t\t\tif(ch[f][0]==x) ronate(f,1),ronate(x,1);\n\t\t\t\telse ronate(x,0),ronate(x,1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(ch[f][0]==x) ronate(x,1),ronate(x,0);\n\t\t\t\telse ronate(f,0),ronate(x,0);\n\t\t\t}\n\t\t}\n\t}\n\tif(tar==0) rot[i]=x;\n}\n\ninline void spin(int i,int v)\n{\n\tint x=rot[i];\n\tif(!rot[i])\n\t{\n\t\trot[i]=x=++tot;\n\t\tw[x]=v;siz[x]=cnt[x]=1;\n\t\tfa[x]=ch[x][0]=ch[x][1]=0;\n\t\treturn ;\n\t}\n\telse\n\t{\n\t\tint id=gi(v,i);\n\t\tif(w[id]==v)\n\t\t{\n\t\t\tcnt[id]++;\n\t\t\tud(id);\n\t\t\tsplay(i,id,0);\n\t\t\treturn ;\n\t\t}\n\t\tadd(id,v);\n\t\tud(id);\n\t\tsplay(i,tot,0);\n\t}\n}\n\ninline void splayclear(int x)\n{\n\tfa[x]=ch[x][0]=ch[x][1]=siz[x]=w[x]=0;\n}\n\ninline int splayrank(int i,int v)\n{\n\tint x=rot[i],ret=0;\n\twhile(x)\n\t{\n\t\tif(w[x]==v) return ret+siz[ch[x][0]];\n\t\tif(w[x]<v){\n\t\t\tret+=siz[ch[x][0]]+cnt[x];\n\t\t\tx=ch[x][1];\n\t\t}\n\t\telse x=ch[x][0];\n\t}\n\treturn ret;\n}\n\ninline int splaypre(int i,int v)\n{\n\tint x=rot[i];\n\twhile(x)\n\t{\n\t\tif(w[x]<v)\n\t\t{\n\t\t\tif(ans<w[x]) ans=w[x];\n\t\t\tx=ch[x][1];\n\t\t}\n\t\telse x=ch[x][0];\n\t}return ans;\n}\n\ninline int splaynt(int i,int v)\n{\n\tint x=rot[i];\n\twhile(x)\n\t{\n\t\tif(w[x]>v)\n\t\t{\n\t\t\tif(ans>w[x]) ans=w[x];\n\t\t\tx=ch[x][0];\n\t\t}\n\t\telse x=ch[x][1];\n\t}\n\treturn ans;\n}\n\ninline void splaydel(int i,int k)\n{\n\tint x=gi(k,rot[i]);\n\tsplay(i,x,0);\n\tif(cnt[x]>1)\n\t{\n\t\tcnt[x]--;\n\t\tud(x);\n\t\treturn ;\n\t}\n\tif(!ch[x][0]&&!ch[x][1])\n\t{\n\t\tsplayclear(rot[i]);\n\t\trot[i]=0;\n\t\treturn ; \n\t}\n\tif(!ch[x][0])\n\t{\n\t\tint y=ch[x][1];\n\t\trot[i]=y;\n\t\tfa[y]=0;\n\t\tud(y);\n\t\treturn ;\n\t}\n\tif(!ch[x][1])\n\t{\n\t\tint y=ch[x][0];\n\t\trot[i]=y;\n\t\tfa[y]=0;\n\t\treturn ;\n\t}\n\tint p=splaypre2(i);\n\tint o=rot[i];\n\tsplay(i,p,0);\n\tch[rot[i]][1]=ch[o][1];\n\tfa[ch[o][1]]=rot[i];\n\tsplayclear(o);\n\tud(rot[i]);\n}\n\n//\u7ebf\u6bb5\u6811******************************************\n\ninline void segin(int l,int r,int rt,int x,int v)\n{\n\tspin(rt,v);\n\tif(l==r) return ;\n\tint mid=(l+r)>>1;\n\tif(x<=mid) segin(ls,x,v);\n\telse segin(rs,x,v); \n}\n\ninline void segrank(int l,int r,int rt,int nl,int nr,int x)\n{\n\tif(nl<=l&&r<=nr)\n\t{\n\t\tans+=splayrank(rt,x);\n\t}\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(nl<=mid) segrank(ls,nl,nr,x);\n\t\tif(nr>mid) segrank(rs,nl,nr,x);\n\t}\n}\n\ninline void segchange(int l,int r,int rt,int x,int v)\n{\n\tsplaydel(rt,a[x]);spin(rt,v);\n\tif(l==r){a[x]=v;return ;}\n\tint mid=(l+r)>>1;\n\tif(x<=mid) segchange(ls,x,v);\n\telse segchange(rs,x,v);\n}\n\ninline void segpre(int l,int r,int rt,int nl,int nr,int v)\n{\n\tif(nl<=l&&r<=nr){ans=max(ans,splaypre(rt,v));return ;}\n\tint mid=(l+r)>>1;\n\tif(nl<=mid) segpre(ls,nl,nr,v);\n\tif(mid<nr) segpre(rs,nl,nr,v);\n}\n\ninline void segnt(int l,int r,int rt,int nl,int nr,int v)\n{\n\tif(nl<=l&&r<=nr)\n\t{\n\t\tans=min(ans,splaynt(rt,v));\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif(nl<=mid)\n\tsegnt(ls,nl,nr,v);\n\tif(nr>mid)\n\tsegnt(rs,nl,nr,v);\n}\n\n//************************\n\ninline int Kth(int l,int r,int k)\n{\n\tint L=0,R=MAX+1,mid=0,ss=0;k--;\n\twhile(L<=R)\n\t{\n\t\tmid=(L+R)>>1;\n\t\tans=0;\n\t\tsegrank(1,n,1,l,r,mid);\n\t\tif(ans<=k) ss=mid,L=mid+1;\n\t\telse R=mid-1;\n\t}\n\treturn ss;\n} \n\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tn=read(),m=read();\n\t\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=read();\n\t\tsegin(1,n,1,i,a[i]);\n\t\tMAX=max(MAX,a[i]);\n\t}\n\twhile(m--)\n\t{\n\t\tint op,x,y,z;\n\t\top=read(),x=read(),y=read();\n\t\tcout<<m<<endl;\n\t\tif(op==1)\n\t\t{\n\t\t\tz=read();ans=0;\n\t\t\tsegrank(1,n,1,x,y,z);\n\t\t\tprintf(\"%d\\n\",ans+1); \n\t\t}\n\t\telse if(op==2)\n\t\t{\n\t\t\tz=read();\n\t\t\tprintf(\"%d\\n\",Kth(x,y,z));\n\t\t}\n\t\telse if(op==3)\n\t\t{\n\t\t\tsegchange(1,n,1,x,y);\n\t\t}\n\t\telse if(op==4)\n\t\t{\n\t\t\tz=read();\n\t\t\tans=-inf;\n\t\t\tsegpre(1,n,1,x,y,z);\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tz=read();\n\t\t\tans=inf;\n\t\t\tsegnt(1,n,1,x,y,z);\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1544277218,
        "uid": 102786,
        "name": "Sym_Je",
        "ccfLevel": 0,
        "title": "\u6811\u5957\u6811"
    },
    {
        "content": "### \u819c\u62dc\u6253\u7ebf\u6bb5\u6811\u5957splay or treap\u4ee5\u53ca\u83ab\u961f\u3001\u5206\u5757\u5927\u4f6c\n\u8bdd\u4e0d\u591a\u8bf4\uff0c\u8fdb\u6765\u505a\u8fd9\u9053\u9898\u7684\u5e94\u8be5\u90fd\u4f1abit+\u4e3b\u5e2d\u6811\u5427\u3002  \n\u63a8\u8350[Dynamic Rankings](https://www.luogu.org/problemnew/show/P2617)  \n\u524d\u4e09\u4e2a\u662f\u57fa\u672c\u64cd\u4f5c\uff0c\u52a0\u4e00\u4e2a\u79bb\u6563\u5316\u5c31\u53ef\u4ee5\u4e86\u3002  \n\u5982\u4f55\u6c42\u524d\u9a71\uff1f\uff1f\uff1f  \n### \u90a3\u4e0d\u5c31\u662f\u6392\u5e8f\u540e\u6392\u540d\u5c0f\u4e00\u7684\u6570\u5417\uff1f \n\u5373\u4e3a\u533a\u95f4\u5185\uff0c\u7b2ck\uff08\u6bd4\u5b83\u5c0f\u7684\u6570\u7684\u4e2a\u6570\uff09\u5927\u7684\u6570\u3002   \n\u540c\u7406\uff0c\u540e\u7ee7\u5c31\u662f\u7b2ck\uff08\u5c0f\u4e8e\u7b49\u4e8e\u5b83\u7684\u6570\u7684\u4e2a\u6570+1\uff09\u5927\u7684\u6570\u3002  \n\u8fd9\u4e0d\u5c31\u5b8c\u4e86\uff1f\uff1f\uff1f  \n\u65f6\u95f4\uff1aO($nlog^2n$)  \n\u7a7a\u95f4\uff1aO($n log n$)\n\u4e0a\u4ee3\u7801\uff1a\n```\n#include<bits/stdc++.h>\nusing namespace std;\nint lb(int x){return x&-x;}\nconst int N=5e5+5;\nconst int TR=N*60;\nint rt[N],ls[TR],rs[TR],tr[TR],t_cnt;\nint xx[N],yy[N],back[N<<1],nx,ny;\nint a[N];\nstruct qes{\n    int opt,a,x,l,r;\n}q[N];\nstruct node{\n    int pos,x,opt;\n}kk[N];\nint n,m;\nbool cmp(node x,node y){return x.x<y.x;}\nvoid ins(int &now,int l,int r,int k,int x=1)\n{\n    if(!now)now=++t_cnt;\n    tr[now]+=x;\n    if(l==r)return ;\n    int mid=(l+r)>>1;\n    if(k<=mid)ins(ls[now],l,mid,k,x);\n    else ins(rs[now],mid+1,r,k,x);\n}\nint ask_smaller(int l,int r,int k)\n{\n    int ssum=0;\n    if(l>=k)return 0;\n    if(r<k)\n    {\n        for(int i=1;i<=ny;i++) ssum+=tr[yy[i]];\n        for(int i=1;i<=nx;i++) ssum-=tr[xx[i]];\n        return ssum;\n    }\n    int mid=(l+r)>>1;\n    if(k<=mid)\n    {\n        for(int i=1;i<=ny;i++) yy[i]=ls[yy[i]];\n        for(int i=1;i<=nx;i++) xx[i]=ls[xx[i]];\n        return ask_smaller(l,mid,k);\n    }\n    else\n    {\n        for(int i=1;i<=ny;i++) ssum+=tr[ls[yy[i]]],yy[i]=rs[yy[i]];\n        for(int i=1;i<=nx;i++) ssum-=tr[ls[xx[i]]],xx[i]=rs[xx[i]];\n        return ask_smaller(mid+1,r,k)+ssum;\n    }\n}\nint ask_kth(int l,int r,int k)\n{\n    if(l==r) return l;\n    int mid=(l+r)>>1,lssum=0;\n    for(int i=1;i<=ny;i++)\n        lssum+=tr[ls[yy[i]]];\n    for(int i=1;i<=nx;i++)\n        lssum-=tr[ls[xx[i]]];\n    if(lssum>=k)\n    {\n        for(int i=1;i<=ny;i++)yy[i]=ls[yy[i]];\n        for(int i=1;i<=nx;i++)xx[i]=ls[xx[i]];\n        return ask_kth(l,mid,k);\n    }\n    else\n    {\n        for(int i=1;i<=ny;i++)yy[i]=rs[yy[i]];\n        for(int i=1;i<=nx;i++)xx[i]=rs[xx[i]];\n        return ask_kth(mid+1,r,k-lssum);\n    }\n}\nint main()\n{\n    //freopen(\"1.txt\",\"r\",stdin);\n    //freopen(\"2.txt\",\"w\",stdout);\n    cin>>n>>m;\n    int tot=0;\n    for(int i=1;i<=n;i++)\n    {\n        tot++;\n        cin>>kk[tot].x;\n        kk[tot].pos=i;\n        kk[tot].opt=0;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        cin>>q[i].opt;\n        if(q[i].opt!=3)\n            cin>>q[i].l>>q[i].r;\n        else cin>>q[i].a;\n        if(q[i].opt!=2)\n        {\n            tot++;\n            cin>>kk[tot].x;\n            kk[tot].pos=i;\n            kk[tot].opt=1;\n        }\n        else cin>>q[i].x;\n    }\n    sort(kk+1,kk+tot+1,cmp);\n    int cnt=0;\n    for(int i=1;i<=tot;i++)\n    {\n        if(kk[i].x!=kk[i-1].x||i==1) cnt++;\n        back[cnt]=kk[i].x;\n        if(kk[i].opt) q[kk[i].pos].x=cnt;\n        else a[kk[i].pos]=cnt;\n    }\n    for(int i=1;i<=n;i++)\n        for(int j=i;j<=n;j+=lb(j))\n            ins(rt[j],1,cnt,a[i]);\n    for(int i=1;i<=m;i++)\n    {\n        if(q[i].opt==3)\n        {\n            for(int j=q[i].a;j<=n;j+=lb(j))\n                ins(rt[j],1,cnt,a[q[i].a],-1);\n            a[q[i].a]=q[i].x;\n            for(int j=q[i].a;j<=n;j+=lb(j))\n                ins(rt[j],1,cnt,a[q[i].a]);\n        }\n        else\n        {\n            nx=ny=0;\n            int now;\n            for(int j=q[i].l-1;j>0;j-=lb(j))\n                xx[++nx]=rt[j];\n            for(int j=q[i].r;j>0;j-=lb(j))\n                yy[++ny]=rt[j];\n            if(q[i].opt==2)\n            {\n                cout<<back[ask_kth(1,cnt,q[i].x)]<<endl;\n                continue;\n            }\n            if(q[i].opt==1)\n            {\n                cout<<ask_smaller(1,cnt,q[i].x)+1<<endl;\n                continue;\n            }\n            if(q[i].opt==4)\n            {\n                now=ask_smaller(1,cnt,q[i].x);\n                if(now<=0)\n                {\n                    cout<<\"-2147483647\"<<endl;\n                    continue;\n                }\n            }\n            else\n            {\n                now=ask_smaller(1,cnt,q[i].x+1)+1;\n                if(now>q[i].r-q[i].l+1)\n                {\n                    cout<<\"2147483647\"<<endl;\n                    continue;\n                }\n            }\n            nx=ny=0;\n            for(int j=q[i].l-1;j>0;j-=lb(j))\n                xx[++nx]=rt[j];\n            for(int j=q[i].r;j>0;j-=lb(j))\n                yy[++ny]=rt[j];\n            cout<<back[ask_kth(1,cnt,now)]<<endl;\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1540621064,
        "uid": 103990,
        "name": "asd_a",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u5bf9\u4e8e\u8fd9\u9053\u9898\u76ee\uff0c\u591a\u6570\u4eba\u9009\u62e9\u4e86\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u505a\u6cd5\uff0c\u4f46\u662f\u8fd9\u79cd\u65b9\u6cd5\u5bf9\u4e8e\u64cd\u4f5c\u4e8c\u4e0d\u5f97\u4e0d\u5957\u4e0a\u4e00\u4e2a\u4e8c\u5206\uff0c\u4f7f\u5f97\u65f6\u95f4\u590d\u6742\u5ea6\u8fbe\u5230$Mlog^3N$\u7684\u7ea7\u522b\u3002\u6211\u8fd9\u91cc\u91c7\u7528\u4e86\u4e00\u79cd\u7ebf\u6bb5\u6570\u5957\u7ebf\u6bb5\u6811\u7684\u65b9\u6cd5\uff0c\u53ef\u4ee5\u5c06\u65f6\u7a7a\u90fd\u538b\u7f29\u5230\u4e24\u4e2alog\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5916\u5c42\u662f\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u503c\u57df\u662f\u6240\u6709\u539f\u6570\u5217\u4e2d\u7684\u6570\uff0c\u4ee5\u53ca\u4fee\u6539\u64cd\u4f5c\u4e2d\u6539\u6210\u7684\u6570\u3002\u6bcf\u4e00\u4e2a\u5916\u5c42\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u4e0a\u6302\u4e00\u68f5\u4f4d\u7f6e\u7ebf\u6bb5\u6811\uff0c\u7528\u6765\u5feb\u901f\u67e5\u8be2\u533a\u95f4\u4fe1\u606f\uff0c\u7ef4\u62a4\u533a\u95f4\u5185\u6570\u7684\u4e2a\u6570\u548c\u533a\u95f4\u6700\u5927\uff0c\u6700\u5c0f\u503c\u3002\u52a0\u4e0a\u52a8\u6001\u5f00\u70b9\uff0c\u6bcf\u6b21\u64cd\u4f5c\u53ea\u4f1a\u589e\u52a0\u81f3\u591a$log^2N$\u4e2a\u8282\u70b9\uff0c\u7a7a\u95f4\u53ef\u4ee5\u63a5\u53d7\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u5916\u5c42\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\uff0c\u5b83\u6240\u6302\u7684\u7ebf\u6bb5\u6811\u4e0a\uff0c\u53ea\u5b58\u653e\u6743\u503c\u5728\u5b83\u6240\u7ba1\u7406\u6743\u503c\u8303\u56f4\u5185\u7684\u5143\u7d20\u7684\u4fe1\u606f\u3002\n\n\u8fd9\u6837\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u539f\u5e8f\u5217\u4e2d\u7684\u5143\u7d20\uff0c\u53ea\u9700\u5728\u5916\u5c42\u7ebf\u6bb5\u6811\u4e0a\u5411\u5b83\u7684\u6743\u503c\u903c\u8fd1\uff0c\u7136\u540e\u8d70\u5230\u4e00\u4e2a\u70b9\u66f4\u65b0\u5b83\u4e0b\u9762\u6302\u7684\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u6c42k\u7684\u6392\u540d\uff0c\u53ea\u9700\u5728\u5927\u7ebf\u6bb5\u6811\u4e0a\u9012\u5f52\u627ek\uff0c\u7136\u540e\u52a0\u4e0a\u6240\u6709\u5de6\u8fb9\u7684size\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e8c\uff0c\u8003\u5bdf\u7b2ck\u5c0f\uff0c\u53ea\u9700\u5224\u65ad\u5de6\u513f\u5b50\u7684size\u4e0ek\u7684\u5173\u7cfb\u5c31\u80fd\u4e0d\u65ad\u5411\u7b2ck\u5c0f\u903c\u8fd1\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e09\uff0c\u4fee\u6539\u6743\u503c\uff0c\u5148\u628a\u539f\u6765\u7684\u51cf\u6389\uff0c\u5728\u628a\u65b0\u7684\u52a0\u4e0a\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u56db\uff0c\u6c42\u524d\u9a71\uff0c\u8003\u5bdf\u53f3\u513f\u5b50\u4e2d\u5c5e\u4e8e\u533a\u95f4[x,y]\u7684\u6700\u5c0f\u503c\uff0c\u8bbe\u4e3armin\uff0c\u5982\u679ck<=rmin,\u5219\u6240\u6709\u6743\u503c\u5728\u53f3\u8fb9\u7684\u4e0d\u4f1a\u5c0f\u4e8ek\uff0c\u5411\u5de6\u513f\u5b50\u9012\u5f52\uff1b\u53cd\u4e4b\uff0c\u4ee3\u8868\u53f3\u513f\u5b50\u4e2d\u4e00\u5b9a\u6709\u5c0f\u4e8ek\u7684\uff0c\u5de6\u8fb9\u7684\u4e00\u5b9a\u4e0d\u4f1a\u66f4\u5927\uff0c\u5411\u53f3\u513f\u5b50\u9012\u5f52\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e94\uff0c\u4e0e\u56db\u51e0\u4e4e\u76f8\u540c\u3002\n\n\u5bf9\u4e8e\u4e0d\u5b58\u5728\u524d\u9a71\u7684\u60c5\u51b5\uff0c\u6211\u4eec\u53ea\u8981\u5728\u9012\u5f52\u6700\u540e\u5224\u65ad\u5f53\u524d\u6743\u503c\u662f\u5426\u5728\u533a\u95f4\u4e2d\u662f\u5426\u51fa\u73b0\u8fc7\uff0c\u800c\u4e14\u5c0f\u4e8ek\u5373\u53ef\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#define ols u<<1,l,md\n#define ors u<<1|1,md+1,r\n#define ils ls[u],l,md\n#define irs rs[u],md+1,r\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\nusing namespace std;\ntypedef long long ll;\nconst int N=50050,TO=200*N,INF=2147483647;\nint n,m,rgv,b[N<<1],val[N],o[N],L[N],R[N],K[N],P[N],V[N];\nint sz[TO],mx[TO],mi[TO],ls[TO],rs[TO],rt[N<<2],cnt;\nint read(){\n\tchar ch=getchar();int x=0,o=1;\n\tfor(;ch<'0' || '9'<ch;ch=getchar()) if(ch=='-') o=-1;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch^'0');\n\treturn x*o;\n}\nvoid upi(int u){\n\tsz[u]=sz[ls[u]]+sz[rs[u]];\n\tmi[u]=min(mi[ls[u]],mi[rs[u]]);\n\tmx[u]=max(mx[ls[u]],mx[rs[u]]);\n}\nvoid addi(int &u,int l,int r,int pp,int dlt){\n\tif(!u) u=++cnt;\n\tif(l==r){ \n\t    sz[u]+=dlt;\n\t\tif(sz[u]) mi[u]=mx[u]=val[l];\n\t\telse mi[u]=INF,mx[u]=-INF;\n\t\treturn; \n\t}\n\tint md=l+r>>1;\n\tpp<=md?addi(ils,pp,dlt):addi(irs,pp,dlt);upi(u);\n\tif(!sz[u]) u=0;\n}//\u5185\u5c42\u7ebf\u6bb5\u6811\u4fee\u6539 \nint aski_sz(int u,int l,int r,int x,int y){\n\tif(x<=l && r<=y) return sz[u];\n\tif( y<l || r<x || u==0) return 0;\n\tint md=l+r>>1;\n\treturn aski_sz(ils,x,y)+aski_sz(irs,x,y); \n}//\u5185\u5c42\u7ebf\u6bb5\u6811\u6c42\u548c \nint aski_mi(int u,int l,int r,int x,int y){\n\tif(x<=l && r<=y) return mi[u];\n\tif( y<l || r<x || u==0) return +INF;\n\tint md=l+r>>1;\n\treturn min(aski_mi(ils,x,y),aski_mi(irs,x,y)); \n}//\u5185\u5c42\u7ebf\u6bb5\u6811\u6c42\u6700\u5c0f\u503c \nint aski_mx(int u,int l,int r,int x,int y){\n\tif(x<=l && r<=y) return mx[u];\n\tif( y<l || r<x || u==0) return -INF;\n\tint md=l+r>>1;\n\treturn max(aski_mx(ils,x,y),aski_mx(irs,x,y));\n}//\u5185\u5c42\u7ebf\u6bb5\u6811\u6c42\u6700\u5927\u503c \nvoid addo(int u,int l,int r,int pi,int po,int dlt){\n\taddi(rt[u],1,n,pi,dlt);\n\tif(l==r) return;\n\tint md=l+r>>1;\n\tpo<=md?addo(ols,pi,po,dlt):addo(ors,pi,po,dlt);\n}//pi\u8868\u793a\u5185\u5c42\u7ebf\u6bb5\u6811\u7684\u4f4d\u7f6e(\u5373\u5b9e\u9645\u4f4d\u7f6e)\uff0cpo\u8868\u793a\u6743\u503c\u7684\u76f8\u5bf9\u4f4d\u7f6e,\u5373pos-in\u548cpos-out\nint askrk(int u,int l,int r,int x,int y,int z){\n\tif(l==r) return 1;\n\tint md=l+r>>1,lsum=aski_sz(rt[u<<1],1,n,x,y);\n\treturn z<=b[md]?askrk(ols,x,y,z):askrk(ors,x,y,z)+lsum;\n}//1.\u6c42[x,y]\u4e2dz\u7684\u6392\u540d \nint asknu(int u,int l,int r,int x,int y,int z){\n\tif(l==r) return b[l];\n\tint md=l+r>>1,lsum=aski_sz(rt[u<<1],1,n,x,y);\n\treturn z<=lsum?asknu(ols,x,y,z):asknu(ors,x,y,z-lsum); \n}//2.\u6c42[x,y]\u4e2d\u6392\u540d\u7b2cz\u7684\u6570 \nvoid Addo(int p,int x){\n\tint tmp=lower_bound(b+1,b+rgv+1,val[p])-b;\n\taddo(1,1,rgv,p,tmp,x);\n}//3.\u5c06\u5b9e\u9645\u4f4d\u7f6e\u4e3ap\u7684\u6570\u8fdb\u884c\u4fee\u6539\uff0c1\u4e3a\u63d2\u5165,-1\u4e3a\u5220\u9664 \nint askpr(int u,int l,int r,int x,int y,int z){\n\tif(l==r) return b[l]<z && aski_sz(rt[u],1,n,x,y)?b[l]:-INF;\n\tint md=l+r>>1,rmin=aski_mi(rt[u<<1|1],1,n,x,y);\n\treturn z<=rmin?askpr(ols,x,y,z):askpr(ors,x,y,z); \n}//4.\u6c42[x,y]\u4e2d\u5c0f\u4e8ez\u4e14\u6700\u5927\u7684\u6570(\u5373\u524d\u9a71)\nint asknx(int u,int l,int r,int x,int y,int z){\n\tif(l==r) return b[l]>z && aski_sz(rt[u],1,n,x,y)?b[l]:+INF;\n\tint md=l+r>>1,lmax=aski_mx(rt[u<<1  ],1,n,x,y);\n\treturn z>=lmax?asknx(ors,x,y,z):asknx(ols,x,y,z); \n}//5.\u6c42[x,y]\u4e2d\u5927\u4e8ez\u4e14\u6700\u5c0f\u7684\u6570(\u5373\u540e\u7ee7) \nint main(){\n\t//freopen(\"tr.in\",\"r\",stdin);\n\t//freopen(\"t1.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\tFOR(i,1,n) scanf(\"%d\",&val[i]),b[++rgv]=val[i];\n\tFOR(i,1,m){\n\t\tscanf(\"%d\",&o[i]);\n\t\tif(o[i]!=3) scanf(\"%d%d%d\",&L[i],&R[i],&K[i]);\n\t\telse scanf(\"%d%d\",&P[i],&V[i]),b[++rgv]=V[i];\n\t}\n\tsort(b+1,b+rgv+1);rgv=unique(b+1,b+rgv+1)-b-1;\n\tmi[0]=+INF,mx[0]=-INF;\n\tFOR(i,1,n) Addo(i,+1);\n\tFOR(i,1,m){\n\t\tif(o[i]==1) printf(\"%d\\n\",askrk(1,1,rgv,L[i],R[i],K[i]));\n\t\tif(o[i]==2) printf(\"%d\\n\",asknu(1,1,rgv,L[i],R[i],K[i]));\n\t\tif(o[i]==3) Addo(P[i],-1),val[P[i]]=V[i],Addo(P[i],+1);\n\t\tif(o[i]==4) printf(\"%d\\n\",askpr(1,1,rgv,L[i],R[i],K[i]));\n\t\tif(o[i]==5) printf(\"%d\\n\",asknx(1,1,rgv,L[i],R[i],K[i]));\n\t}\n}\n```",
        "postTime": 1533523643,
        "uid": 62267,
        "name": "BJpers2",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u6765\u770b\u770b\u4e00\u4e2a\u5f31\u5230\u81ea\u5e26\u5de8\u5927\u65f6\u7a7a\u5e38\u6570\u7684\u849f\u84bb\u662f\u5982\u4f55\u5361\u8fc7\u8fd9\u9053\u9898\u7684\u3002\u5e0c\u671b\u8fd9\u4e2a\u7701\u7a7a\u95f4\u7684\u5361\u5e38\u6570\u65b9\u6cd5\u80fd\u5e2e\u5230\u5176\u4ed6\u849f\u84bb\u3002  \n\u5c0f\u849f\u84bb\u6211\u7528\u7684\u662f\u6811\u72b6\u6570\u7ec4\u5957\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u3002\u6b63\u5f53\u6211\u6253\u597d\u6a21\u677f\u5174\u9ad8\u91c7\u70c8\u63d0\u4ea4\u4e4b\u9645\uff0c\u5374\u6115\u7136\u53d1\u73b0\u81ea\u5df1\u53ea\u5f97\u4e8670\u5206\uff0c\u4e09\u4e2a\u70b9MLE\u3002\u4e8e\u662f\u6211\u628anew\u51fd\u6570\u6539\u6210\u5185\u5b58\u6c60\uff0c\u653e\u5230\u672c\u5730\u7684VS\u4e0a\u6d4b\u8bd5\uff0c\u53d1\u73b0\u6700\u5927\u7684\u70b9\u4e00\u5171\u7528\u4e86\u4e00\u5343\u4e8c\u767e\u4e07\u4e2a\u7ebf\u6bb5\u6811\u7ed3\u70b9\uff0c\u800c\u6bcf\u4e2a\u7ed3\u70b920B\u3002\u7406\u8bba\u4e0a\u6765\u8bf4\uff0c256MB\u52c9\u52c9\u5f3a\u5f3a\u5f00\u7684\u4e0b\u3002\u7136\u800c\uff0c\u849f\u84bb\u9876\u7740\u8349\u5b57\u5934\uff0c\u6bd5\u7adf\u662f\u83dc\uff0c\u81ea\u5e26\u5e38\u6570\u6123\u662f\u8fc7\u4e0d\u53bb\u3002  \n\u600e\u4e48\u529e\u5462\uff1f\u4ee5\u6211\u8fd9\u6837\u83dc\u7684\u6c34\u5e73\uff0c\u4e00\u822c\u65b9\u6cd5\u6050\u6015\u5361\u4e0d\u8fc7\u53bb\uff0c\u53ea\u80fd\u7528\u522b\u7684\u7279\u6b8a\u65b9\u6cd5\u4e86\u3002  \n\u663e\u7136\uff0c\u7a0b\u5e8f\u8fd0\u884c\u8fc7\u7a0b\u4e2d\u4ea7\u751f\u8bb8\u591a\u4e0d\u53ef\u8fbe\u7ed3\u70b9\uff0c\u4e25\u91cd\u6d6a\u8d39\u5185\u5b58\u3002\u53ea\u8981\u5b9a\u671f\u6e05\u7406\u5783\u573e\u7ed3\u70b9\uff0c\u5c31\u53ef\u4ee5\u7701\u4e0b\u8bb8\u591a\u7a7a\u95f4\u3002\u4e8e\u662f\uff0c\u6211\u7c97\u7565\u5b66\u4e60\u4e86\u4e00\u4e0b\u5783\u573e\u56de\u6536\u7b97\u6cd5\uff1a\u6807\u8bb0\u6e05\u9664\u6cd5\u3002\u5176\u5b9e\u539f\u7406\u5f88\u7b80\u5355\uff1a\u5f53\u5185\u5b58\u4e0d\u591f\u65f6\uff0c\u4ece\u6bcf\u4e00\u4e2a\u6839\u8282\u70b9\u51fa\u53d1\uff0c\u7ed9\u6240\u6709\u53ef\u8fbe\u7ed3\u70b9\u6253\u4e0a\u6807\u8bb0\uff0c\u6700\u540e\u904d\u5386\u5185\u5b58\u6c60\uff0c\u56de\u6536\u6ca1\u6709\u6807\u8bb0\u7684\u7ed3\u70b9\u3002  \n\u4f46\u662f\uff0c\u8fd8\u6709\u4e00\u4e2a\u5730\u65b9\u9700\u8981\u6ce8\u610f\uff1a**\u4e0d\u80fd\u5728\u9012\u5f52\u4e2d\u56de\u6536\u5783\u573e**\u3002\u9012\u5f52\u65f6\u65b0\u5206\u914d\u7684\u5185\u5b58\u8fd8\u6ca1\u6709\u4e0e\u6839\u8282\u70b9\u8054\u901a\uff0c\u6b64\u65f6\u56de\u6536\u5783\u573e\u4f1a\u628a\u8fd9\u90e8\u5206\u7ed3\u70b9\u9519\u8bef\u56de\u6536\uff0c\u5bfc\u81f4RE\u3002\u89e3\u51b3\u65b9\u6cd5\uff1a\u6bcf\u4e2a\u64cd\u4f5c\u524d\u68c0\u67e5\u961f\u5217\u4e2d\u5269\u4f59\u7ed3\u70b9\u6570\u91cf\uff0c\u82e5\u6570\u91cf\u4e0d\u8db3\u5219\u56de\u6536\u5783\u573e\u3002  \n\u5e94\u7528\u5783\u573e\u56de\u6536\u7b97\u6cd5\u540e\uff0c\u672c\u849f\u84bb\u53ea\u5f00\u4e86\u4e03\u767e\u4e07\u4e2a\u7ed3\u70b9\u5c31\u65e0O2\u4e0bAC\u4e86\uff0c\u51e0\u4e4e\u53ef\u4ee5\u7701\u4e0b\u4e00\u534a\u7684\u5185\u5b58\u3002\u4ee5\u4e0b\u662f\u4ee3\u7801\uff0c\u5783\u573e\u56de\u6536\u90e8\u5206\u5df2\u7ecf\u6807\u51fa\u3002//\u6709\u70b9\u957f\uff0c\u5e0c\u671b\u5927\u4f6c\u4eec\u80fd\u6709\u8010\u5fc3\u7ffb\u5230\u5b83\u4eec\u3002\u3002\u3002\n```\n#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <cstring>\n#include <time.h>\n#include <utility>\n\n#pragma warning(disable:4996)\n#define INF 2000000005//2 * 10^9\n#define lowbit(a) ((a)&-(a))\ninline long long max(long long a, long long b)\n{\n\treturn a > b ? a : b;\n}\ninline long long min(long long a, long long b)\n{\n\treturn a < b ? a : b;\n}\n\nstruct tree {\n\tint id;\n\n\tint l;\n\tint r;\n\tint num;\n\ttree *lson;\n\ttree *rson;\n\ttree()\n\t{\n\t\tl = r = num = 0;\n\t\tlson = rson = NULL;\n\t}\n\tvoid operator = (tree &t)\n\t{\n\t\tl = t.l;\n\t\tr = t.r;\n\t\tnum = t.num;\n\t\tlson = t.lson;\n\t\trson = t.rson;\n\t}\n};\n\ntree pool[7000000];//\u5185\u5b58\u6c60\nbool mark[7000000];//\u6807\u8bb0\nint q[7000000], cur;//\u53ef\u7528\u5185\u5b58\u961f\u5217\nvoid collect();//\u5783\u573e\u56de\u6536\u51fd\u6570\uff0c\u5728\u4e0b\u9762\ntree *newtree()//\u5206\u914d\u5185\u5b58\n{\n\tif (cur < 1000)\n\t\tcollect();//\u8fd9\u91cc\u5176\u5b9e\u7528\u4e0d\u5230\uff0c\u5982\u679c\u7528\u5230\u4e86\uff0c\u4f60\u5c31RE\u4e86\n\tif (cur)\n\t\treturn &pool[q[--cur]];\n\telse\n\t\twhile (1);//\u65b9\u4fbf\u6545\u969c\u68c0\u6d4b\n}\n\nvoid build(tree *root, int L, int R)\n{\n\troot->l = L;\n\troot->r = R;\n\tif (L == R)\n\t\treturn;\n\tint mid = (L + R) / 2;\n\troot->lson = newtree();\n\troot->rson = newtree();\n\tbuild(root->lson, L, mid);\n\tbuild(root->rson, mid + 1, R);\n}\n\ntree *update(tree *root, int id, int k)\n{\n\ttree *p = newtree();\n\t*p = *root;\n\tif (root->l == root->r)\n\t{\n\t\tp->num += k;\n\t\treturn p;\n\t}\n\tint mid = (root->l + root->r) / 2;\n\tif (id <= mid)\n\t\tp->lson = update(p->lson, id, k);\n\telse\n\t\tp->rson = update(p->rson, id, k);\n\tp->num = p->lson->num + p->rson->num;\n\treturn p;\n}\nint lessthan(tree *root, int k)\n{\n\tif (root->l == root->r)\n\t\treturn root->l < k ? root->num : 0;\n\tint mid = (root->l + root->r) / 2;\n\tif (k > mid)\n\t\treturn root->lson->num + lessthan(root->rson, k);\n\treturn lessthan(root->lson, k);\n}\nint lessthan_or_equalto(tree *root, int k)\n{\n\tif (root->l == root->r)\n\t\treturn root->l <= k ? root->num : 0;\n\tint mid = (root->l + root->r) / 2;\n\tif (k >= mid)\n\t\treturn root->lson->num + lessthan_or_equalto(root->rson, k);\n\treturn lessthan_or_equalto(root->lson, k);\n}\n\n\nconst int MAXN = 100005;\n\nstruct element {\n\tint val;\n\tint id;\n\tbool operator < (element &t)\n\t{\n\t\treturn val < t.val;\n\t}\n};\n\nelement temp[MAXN];\nvoid msort(element *a, int l, int r)\n{\n\tif (l == r)\n\t\treturn;\n\tint mid = (l + r) / 2;\n\tmsort(a, l, mid);\n\tmsort(a, mid + 1, r);\n\tint i = l, j = mid + 1, k = l;\n\twhile (k <= r)\n\t{\n\t\tif (j > r || i <= mid&&a[i] < a[j])\n\t\t\ttemp[k++] = a[i++];\n\t\telse\n\t\t\ttemp[k++] = a[j++];\n\t}\n\tfor (i = l; i <= r; i++)\n\t\ta[i] = temp[i];\n}\n\ntree *T[MAXN];\ntree *q1[MAXN], *q2[MAXN];\nint s1, s2;\n\nvoid dfs(tree *x)//dfs\u6839\u7ed3\u70b9\uff0c\u6807\u8bb0\u53ef\u8fbe\u7ed3\u70b9\n{\n\tif (!x || mark[x->id])\n\t\treturn;\n\tmark[x->id] = true;\n\tdfs(x->lson);\n\tdfs(x->rson);\n}\nvoid collect()//\u5783\u573e\u56de\u6536\n{\n\tmemset(mark, 0, sizeof(mark));\n\tfor (int i = 0; i < MAXN; i++)\n\t\tdfs(T[i]);\n\tcur = 0;\n\tfor (int i = 0; i < 7000000; i++)\n\t{\n\t\tif (!mark[i])\n\t\t{\n\t\t\tpool[i].l = pool[i].r = pool[i].num = 0;\n\t\t\tpool[i].lson = pool[i].rson = NULL;\n\t\t\tq[cur++] = i;\n\t\t}\n\t}\n}\n\nvoid init()\n{\n\tfor (int i = 0; i < 7000000; i++)\n\t\tpool[i].id = i;\n\n\tcollect();\n\tT[0] = newtree();\n\tbuild(T[0], 0, MAXN);\n\tfor (int i = 1; i < MAXN; i++)\n\t\tT[i] = T[0];\n}\n\nvoid update(int id, int n, int k)\n{\n\twhile (id < MAXN)\n\t{\n\t\tT[id] = update(T[id], n, k);\n\t\tid += lowbit(id);\n\t}\n}\n\nint kth(int l, int r, int k)\n{\n\tint i;\n\n\ts1 = s2 = 0;\n\twhile (r > 0)\n\t{\n\t\tq1[s1++] = T[r];\n\t\tr -= lowbit(r);\n\t}\n\tl--;\n\twhile (l > 0)\n\t{\n\t\tq2[s2++] = T[l];\n\t\tl -= lowbit(l);\n\t}\n\twhile (q1[0]->l != q1[0]->r)\n\t{\n\t\tint t = 0;\n\t\tfor (i = 0; i < s1; i++)\n\t\t\tt += q1[i]->lson->num;\n\t\tfor (i = 0; i < s2; i++)\n\t\t\tt -= q2[i]->lson->num;\n\t\tif (t >= k)\n\t\t{\n\t\t\tfor (i = 0; i < s1; i++)\n\t\t\t\tq1[i] = q1[i]->lson;\n\t\t\tfor (i = 0; i < s2; i++)\n\t\t\t\tq2[i] = q2[i]->lson;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tk -= t;\n\t\t\tfor (i = 0; i < s1; i++)\n\t\t\t\tq1[i] = q1[i]->rson;\n\t\t\tfor (i = 0; i < s2; i++)\n\t\t\t\tq2[i] = q2[i]->rson;\n\t\t}\n\t}\n\treturn q1[0]->l;\n}\nint rank(int l, int r, int k)\n{\n\tint t = 0;\n\tl--;\n\twhile (r > 0)\n\t{\n\t\tt += lessthan(T[r], k);\n\t\tr -= lowbit(r);\n\t}\n\twhile (l > 0)\n\t{\n\t\tt -= lessthan(T[l], k);\n\t\tl -= lowbit(l);\n\t}\n\treturn t + 1;\n}\nint rank2(int l, int r, int k)\n{\n\tint t = 0;\n\tl--;\n\twhile (r > 0)\n\t{\n\t\tt += lessthan_or_equalto(T[r], k);\n\t\tr -= lowbit(r);\n\t}\n\twhile (l > 0)\n\t{\n\t\tt -= lessthan_or_equalto(T[l], k);\n\t\tl -= lowbit(l);\n\t}\n\treturn t + 1;\n}\nint num(int l, int r)\n{\n\tint t = 0;\n\tl--;\n\twhile (r > 0)\n\t{\n\t\tt += T[r]->num;\n\t\tr -= lowbit(r);\n\t}\n\twhile (l > 0)\n\t{\n\t\tt -= T[l]->num;\n\t\tl -= lowbit(l);\n\t}\n\treturn t;\n}\n\nstruct opt {\n\tint type;\n\tint l;\n\tint r;\n\tint k;\n};\n\nint N, M;\nint a[MAXN];\nelement o[MAXN];\nopt op[MAXN];\n\nvoid main1()\n{\n\tprintf(\"%d\", sizeof(pool));\n\tsystem(\"pause\");\n}\n\nint main()\n{\n\tfreopen(\"C:/Users/Administrator/Downloads/testdata (2).in\", \"r\", stdin);\n\tfreopen(\"C:/Users/Administrator/Desktop/test\", \"w\", stdout);\n\n\tint i, cnt = 1;\n\n\tinit();\n\tscanf(\"%d %d\", &N, &M);\n\n\tfor (i = 1; i <= N; i++)\n\t{\n\t\tscanf(\"%d\", &o[i].val);\n\t\to[i].id = i;\n\t}\n\tfor (i = 1; i <= M; i++)\n\t{\n\t\tscanf(\"%d %d %d\", &op[i].type, &op[i].l, &op[i].r);\n\t\tif (op[i].type != 3)\n\t\t{\n\t\t\tscanf(\"%d\", &op[i].k);\n\t\t}\n\t\telse\n\t\t\top[i].k = op[i].r;\n\t\tif (op[i].type != 2)\n\t\t{\n\t\t\to[N + i].val = op[i].k;\n\t\t\to[N + i].id = N + i;\n\t\t}\n\t}\n\tmsort(o, 1, N + M);\n\n\tfor (i = 1; i <= N + M; i++)\n\t{\n\t\tif (o[i].id == 0)\n\t\t\tcontinue;\n\t\tif (o[i].id <= N)\n\t\t\ta[o[i].id] = o[i].val == o[i - 1].val&&o[i - 1].id ?\n\t\t\t(o[i - 1].id <= N ? a[o[i - 1].id] : op[o[i - 1].id - N].k) : i;\n\t\telse\n\t\t\top[o[i].id - N].k = o[i].val == o[i - 1].val&&o[i - 1].id ?\n\t\t\t(o[i - 1].id <= N ? a[o[i - 1].id] : op[o[i - 1].id - N].k) : i;\n\t}\n\n\tfor (i = 1; i <= N; i++)\n\t{\n\t\tif (cur < 5000)\n\t\t\tcollect();\n\t\tupdate(i, a[i], 1);\n\t}\n\n\tfor (i = 1; i <= M; i++)\n\t{\n\t\tif (cur < 5000)\n\t\t\tcollect();\n\n\t\tint type = op[i].type, l = op[i].l, r = op[i].r, k = op[i].k;\n\t\tif (type == 1)\n\t\t\tprintf(\"%d\\n\", rank(l, r, k)); \n\t\tif (type == 2)\n\t\t\tprintf(\"%d\\n\", o[kth(l, r, k)].val); \n\t\tif (type == 3)\n\t\t{\n\t\t\tupdate(l, a[l], -1);\n\t\t\tupdate(l, k, 1);\n\t\t\ta[l] = k;\n\t\t}\n\t\tif (type == 4)\n\t\t{\n\t\t\tint t = rank(l, r, k);\n\t\t\tif (t == 1)\n\t\t\t\tprintf(\"-2147483647\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%d\\n\", o[kth(l, r, t - 1)].val); \n\t\t}\n\t\tif (type == 5)\n\t\t{\n\t\t\tint t = rank2(l, r, k);\n\t\t\tif (t > num(l, r))\n\t\t\t\tprintf(\"2147483647\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"%d\\n\", o[kth(l, r, t)].val); \n\t\t}\n\t}\n\n\t\n\tsystem(\"pause\");\n\treturn 0;\n}\n```",
        "postTime": 1530706794,
        "uid": 64366,
        "name": "ddwqwq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u65f6\u9694\u4e00\u4e2a\u6708\u540e\uff0c\u7ec8\u4e8e\u653b\u514b\u4e86\u4e8c\u5206\u6c42K\u5927\u7684\u96be\u9898\u3002\u3002\u3002\u7279\u6b64\u7eaa\u5ff5 2017.10.3\n\n\u597d\u597d\u7684\u6811\u5957\u6811\u6a21\u677f\u9898\u600e\u4e48\u6ca1\u6709\u4e00\u4efd\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u201c\u6807\u51c6\u201d\u9898\u89e3\u5462\u3002\u3002\u3002\u867d\u7136\u8fd9\u65b9\u6cd5\u6bd4\u8f83low\uff0c\u4f46\u6211\u8fd8\u662f\u6765\u8d34\u4e00\u53d1\u3002\u3002\u3002\n\n\u636e\u8bf4\u8fd9\u9898\u5e38\u6570\u5de8\u5927\uff0c\u82e5\u5e72\u4efd\u7ebf\u6bb5\u6811\u5957BST\u7684\u4ee3\u7801\u90fd\u88ab\u5361\u5e38\u4e86\n\n\u840c\u65b0\u6211\u770b\u5230\u8fd9\u5413\u4eba\u7684\u901a\u8fc7\u7387\u4e0d\u7531\u745f\u745f\u53d1\u6296\n\n\u4e8e\u662f\u4f7f\u51fa\u6d51\u8eab\u89e3\u6570\uff0c\u7528\u4e86\u4e00\u5927\u5806**\u5947\u6280\u6deb\u5de7**\u8fdb\u884c\u75af\u72c2\u7684\u5e38\u6570\u4f18\u5316\u3002\u3002\u3002\n\n\u7136\u540e\u3002\u3002\u3002\u5c45\u7136**\u6ca1\u88ab\u5361\u5230**\u3002\u3002\u3002\u6ed1\u7a3d\u3002\u3002\u3002\n\n\u8fdb\u5165\u6b63\u9898\uff1a\n\n\u4f55\u4e3a\u6811\u5957\u6811\uff1f\n\n\u8003\u8651\u8fd9\u9898\u8981\u6c42\u7684\u64cd\u4f5c\u3002\u533a\u95f4\u64cd\u4f5c\u8981\u6c42\u4f7f\u7528\u7ebf\u6bb5\u6811\uff0c\u6c42\u6392\u540d\u3001K\u5927\u4ec0\u4e48\u7684\u53c8\u8981\u6c42\u4f7f\u7528BST\uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u796d\u51fa\u7ebf\u6bb5\u6811\u5957BST\u4e86\uff0c\u5177\u4f53\u662f\u6307\uff0c\u5728\u7ebf\u6bb5\u6811\u5212\u5b9a\u7684\u6bcf\u4e2a\u533a\u95f4\u4e0a\u90fd\u5206\u522b\u5efa\u7acb\u4e00\u68f5BST\u3002\u8fd9\u6837\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6\u5c31\u662f\u7ebf\u6bb5\u6811\u7684\u5bbd\u00d7\u9ad8\uff0c\u5373\u4e3anlogn\u3002\n\n\u8fd9\u6837\u64cd\u4f5c\uff0c\u5c31\u5c06\u539f\u5148\u7684\u4e00\u6bb5\u533a\u95f4\u5206\u6210\u4e86logn\u68f5BST\u3002\u5bf9\u6bcf\u4e2aBST\u64cd\u4f5c\u540e\uff0c\u5c06\u7ed3\u679c\u5408\u5e76\u5373\u5f97\u7b54\u6848\u3002\u663e\u7136\uff0c\u8fd9\u6837\u4e00\u6b21\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662flog^2n\u3002\n\n\u64cd\u4f5c\u89e3\u6790\uff1a\n\n\u6bcf\u6b21\u64cd\u4f5c\u5148\u7531\u7ebf\u6bb5\u6811\u81ea\u9876\u5411\u4e0b\u67e5\u8be2\uff0c\u82e5\u5f53\u524d\u7ebf\u6bb5\u6811\u533a\u95f4\u5b8c\u5168\u5305\u542b\u4e8e\u5f85\u64cd\u4f5c\u533a\u95f4\uff0c\u5219\u5728\u672c\u533a\u95f4\u6240\u5c5e\u7684BST\u5185\u8fdb\u884c\u76f8\u5e94\u7684\u5e73\u8861\u6811\u64cd\u4f5c\u5e76\u8fd4\u56de\u7ed3\u679c\uff0c\u5168\u90e8\u64cd\u4f5c\u7ed3\u675f\u540e\u5c06\u6240\u6709\u7ed3\u679c\u5408\u5e76\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c1\uff1a\u5728\u6bcf\u4e2aBST\u5185\u67e5\u8be2\u4e25\u683c\u5c0f\u4e8ek\u7684\u6570\u7684\u4e2a\u6570\uff0c\u5c06\u6240\u6709\u7ed3\u679c\u76f8\u52a0\u518d\u52a01\u5373\u4e3a\u7b54\u6848\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c2\uff1a\n\n\u5148\u5410\u69fd\u4e00\u53e5\u3002\u3002\u3002\u5c31\u662f\u8fd9\u4e2a\u64cd\u4f5c\uff0c\u6298\u78e8\u4e86\u6211\u4e00\u4e2a\u6708\u4e4b\u4e45\u3002\u3002\u3002\u4e8c\u5206\u7684\u7ec6\u8282\u4ec0\u4e48\u7684\u592a\u6076\u5fc3\u3002\u3002\u3002\n\n\u5bf9\u4e8e\u6811\u5957\u6811\uff0c\u8fd9\u4e2a\u64cd\u4f5c\u8c8c\u4f3c\u662f\u65e0\u6cd5\u76f4\u63a5\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u533a\u95f4\u5e76\u4e0d\u662f\u6709\u5e8f\u7684QwQ\n\n\u90a3\u4e48\u8981\u600e\u4e48\u641e\u5462\uff1f\u7b54\u6848\u662f\u4e8c\u5206\uff0c\u6bcf\u6b21\u5bf9\u4e8c\u5206\u51fa\u7684\u503c\u67e5\u8be2\u4e00\u6b21\u533a\u95f4\u6392\u540d\uff0c\u4e0d\u65ad\u903c\u8fd1\u7ed9\u5b9a\u7684k\u5373\u53ef\u3002\n\n\u4f46\u662f\uff0c\u7531\u4e8e\u5143\u7d20\u91cd\u590d\u7b49\u7b49\u7684\u539f\u56e0\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u4e8c\u5206\u8fc7\u7a0b\u96be\u4ee5\u5b9e\u73b0\u3002\u3002\u3002\n\n\u8fd9\u91cc\u5bf9\u4ee3\u7801\u4e2d\u7684\u4e8c\u5206\u7ec6\u8282\u4f5c\u4e00\u4e0b\u89e3\u91ca\uff1a\n\n1.x\u7684\u8ba1\u7b97\u7d27\u8ddf\u5728l\u548cr\u7684\u53d8\u52a8\u4e4b\u540e\uff0c\u76ee\u7684\u662f\u4f7f\u8fd9\u4e09\u4e2a\u503c\u4fdd\u6301\u540c\u6b65\uff0c\u4fdd\u8bc1\u7ed3\u679c\u51c6\u786e\uff1b\n\n2.\u5982\u679cx\u7684\u6392\u540d>k\uff0c\u8054\u7cfb\u6c42\u6392\u540d\u64cd\u4f5c\u7684\u6027\u8d28\uff0c\u53ef\u63a8\u77e5\u8fd9\u65f6\u7684x\u4e00\u5b9a\u5927\u4e8e\u7ed3\u679c\uff0c\u90a3\u4e48\u5c31\u5c06x\u4ee5\u53ca\u6bd4x\u5927\u7684\u503c\u90fd\u6392\u9664\uff0c\u6545\u6709r=x-1\u3002\u901a\u8fc7\u7c7b\u4f3c\u63a8\u7406\u53ef\u5f97\uff0c\u5f53x\u7684\u6392\u540d<=k\u65f6\uff0c\u987b\u6267\u884cl=x\uff1b\n\n3.x\u7684\u8ba1\u7b97\u95ee\u9898\u3002\n\n\u5982\u679c\u5199\u6210x=(l+r)>>1\uff0c\u90a3\u4e48\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u4f1a\u6b7b\u5faa\u73af\u3002\u539f\u56e0\u5982\u4e0b\uff1a\n\n\u5f53l+1==r\u4e14\u5bf9l\u67e5\u8be2\u6ee1\u8db3\u5176\u6392\u540d<=k\u65f6\uff0c\u6309\u7167(l+r)>>1\u8ba1\u7b97\u7684x\u7b49\u4e8el\uff0c\u90a3\u4e48\u4f1a\u5bfc\u81f4\u6267\u884cl=x\uff0c\u7136\u800c\u539f\u672c\u5c31\u6709l==x\u3002\u3002\u3002\u4e8e\u662f\u5c31\u6b7b\u5faa\u73af\u4e86~\n\n\u5199\u6210x=(l+r+1)>>1\u7684\u4f5c\u7528\u662f\uff0c\u8ba9x\u504f\u5411\u4e8er\uff0c\u8fd9\u6837\uff0c\u5728\u53d1\u751f\u4e0a\u8ff0\u60c5\u51b5\u65f6\uff0c\u4f1a\u6709\u5982\u4e0b\u53d8\u52a8\uff1a\n\nx=(l+r+1)>>1=r\uff0c\u5f53x\u7684\u6392\u540d>k\uff0c\u90a3\u4e48\u6267\u884cr=x-1=l\uff1b\u5f53x\u7684\u6392\u540d<=k\uff0c\u90a3\u4e48\u6267\u884cl=x=r\u3002\u65e0\u8bba\u5982\u4f55\uff0c\u90fd\u5c06\u5f97\u5230l==r\u800c\u9000\u51fa\u5faa\u73af\uff0c\u800c\u4e0d\u662f\u6b7b\u5faa\u73af\u3002\n\n\u5982\u6b64\u4fbf\u80fd\u89e3\u51b3\u95ee\u9898\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c3\uff1a\u9996\u5148\u5728\u539f\u5e8f\u5217\u4e2d\u627e\u5230pos\u4f4d\u7f6e\u539f\u5148\u7684\u503c\uff0c\u7136\u540e\u5728\u6bcf\u4e2aBST\u4e2d\u5c06\u8be5\u503c\u5220\u9664\u518d\u63d2\u5165k\u5373\u53ef\u3002\u6ce8\u610f\u4e5f\u8981\u4fee\u6539\u539f\u5e8f\u5217\u4e2d\u7684\u503c\uff0c\u4ee5\u4fbf\u4e0b\u4e00\u6b21\u64cd\u4f5c3\u65f6\u4f7f\u7528\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c4\uff1a\u5728\u6bcf\u4e2aBST\u5185\u6c42\u4e00\u6b21\u524d\u9a71\uff0c\u6700\u540e\u5bf9\u6240\u6709\u7ed3\u679c\u53d6\u4e00\u6b21Max\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c5\uff1a\u4e0e\u64cd\u4f5c4\u540c\u7406\u3002\n\n\u4e0b\u9762\u8bb2\u4e00\u4e0b\u6211\u7684\u201c**\u5947\u6280\u6deb\u5de7**\u201d\u3002\u3002\u3002\n\n\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u5957BST\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u7684\u7ed3\u6784\u7a33\u5b9a\uff0c\u6240\u4ee5BST\u5c31\u5728\u5f88\u5927\u7a0b\u5ea6\u4e0a\u51b3\u5b9a\u4e86\u4ee3\u7801\u7684\u6027\u80fd\u5982\u4f55\u3002\n\n\u90a3\u4e48\u9009\u62e9\u600e\u6837\u7684BST\u5462\uff1f\u6bcf\u6b21\u90fd\u8fdb\u884c\u66b4\u529b\u5355\u70b9\u63d2\u5165\uff1f\u4e0d\u884c\u4e0d\u884c\uff0c\u4f1a\u88ab\u5361\u5e38\u3002\u3002\u3002\n\nNOI2005 \u7ef4\u62a4\u6570\u5217 \u8fd9\u9053\u9898\u544a\u8bc9\u6211\uff0c\u5efa\u7acb\u5b8c\u5168\u5e73\u8861\u7684BST\uff0c\u5176\u6027\u80fd\u8fdc\u4f18\u4e8e\u4e0a\u9762\u7684\u65b9\u6cd5\u3002\u8fd9\u6837\u505a\uff0c\u4e0d\u4ec5\u5efa\u6811\u901f\u5ea6\u5feb\uff0c\u800c\u4e14\u5bf9\u4e8e\u63d0\u5347\u540e\u7eed\u64cd\u4f5c\u7684\u6027\u80fd\u6548\u679c\u660e\u663e\u3002\n\n\u4f46\u662f\uff0c\u5efa\u7acb\u5b8c\u5168\u5e73\u8861\u7684BST\uff0c\u9700\u8981\u5e8f\u5217\u6709\u5e8f\uff0c\u7136\u800c\u8fd9\u91cc\u7684\u5e8f\u5217\u662f\u65e0\u5e8f\u7684\u3002\n\n\u6bcf\u6b21\u90fd\u6392\u5e8f\u4e00\u4e0b\uff1f\u4e0d\u884c\u4e0d\u884c\uff0c\u65f6\u95f4\u66f4\u4f1a\u70b8\u6389\u3002\u3002\u3002\n\n\u8fd9\u65f6\u6211\u60f3\uff0c\u80fd\u4e0d\u80fd\u8ba9\u5f53\u524d\u6392\u5e8f\u540e\u7684\u5e8f\u5217\uff0c\u65b9\u4fbf\u4e0a\u5c42\u5e8f\u5217\u7684\u6392\u5e8f\uff0c\u4ece\u800c\u51cf\u5c11\u65f6\u95f4\u6d88\u8017\u5462\uff1f\n\n\u7a81\u7136\u6211\u56de\u60f3\u8d77\u5f52\u5e76\u6392\u5e8f\u7684\u6027\u8d28\u3002\u3002\u3002\u6ca1\u9519\uff01\u5bf9\u4e8e\u5efa\u6811\u7684\u8fc7\u7a0b\uff0c\u6574\u4f53\u5d4c\u5165\u4e00\u4e2a\u5f52\u5e76\uff0c\u4fbf\u53ef\u8fbe\u5230\u76ee\u7684\uff0c\u5efa\u7acb\u8d77\u5b8c\u5168\u5e73\u8861\u7684BST\u3002\n\n\u201c**\u5947\u6280\u6deb\u5de7**\u201d\u7ec6\u8282\u8be6\u89c1\u4ee3\u7801\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n\n\n\n\n    \n    \n    \n\n\n\n\n\n\n    \n    \n\n\n    \n        \n            \n        \n        \n    \n        \n            \n    \n        \n            \n    \n        \n            \n    \n        \n            \n\n    \n    \n    \n    \n        \n                \n            \n                \n                \n                    \n                    \n                \n            \n                \n            \n                \n            \n                \n    \n\n    \n    \n\n    \n    \n\n    \n\n    \n    \n    \n\n    \n    \n\n    \n    \n\n    \n    \n    \n    \n    \n\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#define inf 2147483647\nusing namespace std;\ninline void read(int &x){  //\u8bfb\u5165\u4f18\u5316 \n    x=0;\n    char t=getchar();\n    bool f=0;\n    while(t<'0' || t>'9'){\n        if(t=='-')f=1;\n        t=getchar();\n    }\n    while(t>='0' && t<='9'){\n        x=(x<<3)+(x<<1)+t-'0';\n        t=getchar();\n    }\n    if(f)x=-x;\n}\nstruct xb{  //\u5408\u5e76\u91cd\u590d\u540e\u7684\u5f85\u5efa\u8282\u70b9 \n    int v,num;\n};\nint c[100010];  //\u539f\u5e8f\u5217\nxb yby[100010];  //\u5408\u5e76\u540e\u7684\u5f85\u5efa\u5e8f\u5217 \nint temp[100010];  //\u6392\u5e8f\u7528\u8f85\u52a9\u5e8f\u5217\nint longtao[100010];  //\u5f52\u5e76\u7528\u8f85\u52a9\u5e8f\u5217\nint rank_ans;\nint pre_ans,succ_ans;\nint k,l,r;\nint n,m,i;\nint opt,a,b,pos,x;\nvoid merge(int,int,int);  //\u5f52\u5e76 \nstruct node{  //\u5e73\u8861\u6811\u8282\u70b9\u5b9a\u4e49 \n    int key;\n    int size,num;\n    node *ch[2];\n    void make(int x){  //\u65b0\u5efa\u8282\u70b9\uff0cx\u4e3a\u4e0b\u6807\uff0c\u6307\u5411\u5f85\u5efa\u8282\u70b9 \n        key=yby[x].v;\n        size=num=yby[x].num;\n        ch[0]=ch[1]=NULL;\n    }\n    void maintain(){\n        size=num;\n        if(ch[0]!=NULL)size+=ch[0]->size;\n        if(ch[1]!=NULL)size+=ch[1]->size;\n    }\n};\nvoid rotate(node* &,bool);  //\u65cb\u8f6c \nvoid insert(node* &,int);  //\u63d2\u5165 \nvoid del(node* &,int);  //\u5220\u9664 \nvoid unit(int,int,node* &);  //\u5408\u5e76\u5f85\u5efa\u5e8f\u5217\u4e2d\u7684\u91cd\u590d\u5143\u7d20 \nvoid bst_build(node* &,int,int,int);  //\u5e73\u8861\u6811\u5efa\u6811 \nint bst_rank(node *,int);  //\u6c42\u6392\u540d \nvoid bst_pre(node *,int);  //\u6c42\u524d\u9a71 \nvoid bst_succ(node *,int);  //\u6c42\u540e\u7ee7 \nstruct sgt{  //\u7ebf\u6bb5\u6811 \n    node *p[200010];\n    void build(int o,int l,int r){\n        int mid=(l+r)>>1;\n        if(l<r){\n            int lson=o<<1;\n            int rson=lson|1;\n            build(lson,l,mid);\n            build(rson,mid+1,r);\n        }\n        merge(l,r,mid);\n        p[o]=NULL;\n        unit(l,r,p[o]);\n    }\n    void rank(int o,int l,int r){\n        if(l>=a && r<=b)rank_ans+=bst_rank(p[o],x)-1;\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            if(a<=mid)rank(lson,l,mid);\n            if(b>mid)rank(rson,mid+1,r);\n        }\n    }\n    void update(int o,int l,int r){\n        del(p[o],c[pos]);\n        insert(p[o],x);\n        if(l<r){\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            if(pos<=mid)update(lson,l,mid);\n            else update(rson,mid+1,r);\n        }\n    }\n    void pre(int o,int l,int r){\n        if(l>=a && r<=b)bst_pre(p[o],x);\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            if(a<=mid)pre(lson,l,mid);\n            if(b>mid)pre(rson,mid+1,r);\n        }\n    }\n    void succ(int o,int l,int r){\n        if(l>=a && r<=b)bst_succ(p[o],x);\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            if(a<=mid)succ(lson,l,mid);\n            if(b>mid)succ(rson,mid+1,r);\n        }\n    }\n} tree;\nint main(){\n    srand(time(0));\n    read(n);read(m);\n    for(i=1;i<=n;i++){\n        read(c[i]);\n        temp[i]=c[i];\n    }\n    tree.build(1,1,n);\n    for(i=1;i<=m;i++){\n        read(opt);\n        switch(opt){\n            case 1:{\n                read(a);read(b);read(x);\n                rank_ans=1;\n                tree.rank(1,1,n);\n                printf(\"%d\\n\",rank_ans);\n                break;\n            }\n            case 2:{\n                read(a);read(b);read(k);\n                l=0;\n                r=100000000;\n                x=(l+r+1)>>1;\n                while(l<r){\n                    rank_ans=1;\n                    tree.rank(1,1,n);\n                    if(rank_ans>k)r=x-1;\n                    else l=x;\n                    x=(l+r+1)>>1;\n                }\n                printf(\"%d\\n\",x);\n                break;\n            }\n            case 3:{\n                read(pos);read(x);\n                tree.update(1,1,n);\n                c[pos]=x;\n                break;\n            }\n            case 4:{\n                read(a);read(b);read(x);\n                pre_ans=-inf;\n                tree.pre(1,1,n);\n                printf(\"%d\\n\",pre_ans);\n                break;\n            }\n            case 5:{\n                read(a);read(b);read(x);\n                succ_ans=inf;\n                tree.succ(1,1,n);\n                printf(\"%d\\n\",succ_ans);\n                break;\n            }\n        }\n    }\n    return 0;\n} \nvoid rotate(node* &p,bool f){\n    node *t=p->ch[f^1];\n    p->ch[f^1]=t->ch[f];\n    t->ch[f]=p;\n    p->maintain();\n    t->maintain();\n    p=t;\n}\nvoid insert(node* &p,int x){\n    if(p==NULL){\n        p=(node *)malloc(sizeof(node));\n        p->key=x;\n        p->size=p->num=1;\n        p->ch[0]=p->ch[1]=NULL;\n        return;\n    }\n    if(x==p->key){\n        p->size++;\n        p->num++;\n        return;\n    }\n    if(x<p->key){\n        insert(p->ch[0],x);\n        p->size++;\n    }\n    else{\n        insert(p->ch[1],x);\n        p->size++;\n    }\n}\nvoid del(node* &p,int x){\n    if(p==NULL)return;\n    if(x==p->key){\n        if(p->num>1){\n            p->num--;\n            p->size--;\n            return;\n        }\n        else{\n            if(p->ch[0]==NULL){\n                node* t=p;\n                p=p->ch[1];\n                free(t);\n                return;\n            }\n            else if(p->ch[1]==NULL){\n                node* t=p;\n                p=p->ch[0];\n                free(t);\n                return;\n            }\n            else{\n                bool f=rand()&1;\n                rotate(p,f);\n                del(p->ch[f],x);\n                p->size--;\n            }\n        }\n    }\n    else{\n        if(x<p->key)del(p->ch[0],x);\n        else del(p->ch[1],x);\n        p->size--;\n    }\n}\nvoid unit(int l,int r,node* &root){\n    int i;\n    int p_yby=1;\n    yby[1].v=temp[l];\n    yby[1].num=1;\n    for(i=l+1;i<=r;i++){\n        if(temp[i]==yby[p_yby].v)yby[p_yby].num++;\n        else{\n            p_yby++;\n            yby[p_yby].v=temp[i];\n            yby[p_yby].num=1;\n        }\n    }\n    bst_build(root,1,p_yby,(1+p_yby)>>1);\n}\nvoid bst_build(node* &p,int l,int r,int mid){\n    p=(node *)malloc(sizeof(node));\n    p->make(mid);\n    if(mid-1>=l)bst_build(p->ch[0],l,mid-1,(l+mid-1)>>1);\n    if(mid+1<=r)bst_build(p->ch[1],mid+1,r,(mid+1+r)>>1);\n    p->maintain();\n}\nint bst_rank(node *p,int x){\n    if(p==NULL)return 1;\n    int s=0;\n    if(p->ch[0]!=NULL)s=p->ch[0]->size;\n    if(x<p->key)return bst_rank(p->ch[0],x);\n    else if(x==p->key)return s+1;\n    else return s+p->num+bst_rank(p->ch[1],x);\n}\nvoid merge(int head,int tail,int mid){\n    if(head==tail)return;\n    int p1=head,p2=mid+1,ph=head;\n    while(p1<=mid && p2<=tail){\n        if(temp[p1]<temp[p2]){\n            longtao[ph]=temp[p1];\n            p1++;\n            ph++;\n        }\n        else{\n            longtao[ph]=temp[p2];\n            p2++;\n            ph++;\n        }\n    }\n    while(p1<=mid){\n        longtao[ph]=temp[p1];\n        p1++;\n        ph++;\n    }\n    while(p2<=tail){\n        longtao[ph]=temp[p2];\n        p2++;\n        ph++;\n    }\n    for(i=head;i<=tail;i++)temp[i]=longtao[i];\n}\nvoid bst_pre(node *p,int x){\n    if(p==NULL)return;\n    if(p->key<x){\n        pre_ans=max(pre_ans,p->key);\n        bst_pre(p->ch[1],x);\n    }\n    else bst_pre(p->ch[0],x);\n}\nvoid bst_succ(node *p,int x){\n    if(p==NULL)return;\n    if(p->key>x){\n        succ_ans=min(succ_ans,p->key);\n        bst_succ(p->ch[0],x);\n    }\n    else bst_succ(p->ch[1],x);\n}\n```",
        "postTime": 1507035800,
        "uid": 22630,
        "name": "Running_Coder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "# \u524d\u8a00\n\n\u8fd9\u9053\u6570\u636e\u7ed3\u6784\u7684\u9898\u5341\u5206\u53cb\u597d\uff0c\u6211\u53ea\u8c03\u4e86\u4e00\u5929\u800c\u5df2\uff0c\u6db2\uff01\n\n# \u9898\u76ee\n\n[\u6d1b\u8c37](https://www.luogu.com.cn/problem/P3380)\n\n[BZOJ](https://www.lydsy.com/JudgeOnline/problem.php?id=3196)\n\n# \u6b63\u9898\n\n\u5bf9\u4e8e\u8fd9\u9053\u9898\uff0c\u636e\u8001\u5e08\u7684\u8981\u6c42\uff0c\u6211\u4eec\u91c7\u7528\u6811\u5957\u6811\u7684\u65b9\u6cd5\n\n\u7531\u4e8e\u4e0a\u8bfe\u6ca1\u542c\u8bb2\uff0c\u6700\u8fd1\u53c8\u5b66\u4e86\u5e73\u8861\u6811\uff0c\u81ea\u7136\u800c\u7136\u5c31\u8ba4\u4e3a\u4f7f\u7528**\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811**\n\n\u7136\u800c\u5f00$O2$\u624d\u80fd\u8fc7(\u6d1b\u8c37)\uff0c$BZOJ\\space8000ms$\u5de6\u53f3(\u4e0d\u7528$O2$)\n\n\u5176\u4e2d\u5e73\u8861\u6811\u4f7f\u7528\u7684\u662f~~\u901a\u4fd7\u6613\u61c2\u7684~~$FHQ\\space Treap$\n\n\u7b80\u5355\u6765\u8bf4\uff0c\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u5efa\u4e00\u68f5\u5e73\u8861\u6811\n\n## \u5f00\u59cb\n\n\u5efa\u6811(\u7ebf\u6bb5\u6811)\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\uff0c\u518d\u5efa\u6811(\u5e73\u8861\u6811)\n\n\u8fd9\u91cc\u7684\u5efa\u6811(\u5e73\u8861\u6811)\u76f4\u63a5\u66b4\u529b$insert$\u5c31\u597d\u4e86\n\n## \u64cd\u4f5c\u4e00 \u533a\u95f4\u4e2dk\u7684\u6392\u540d\n\n\u9996\u5148\u5728\u7ebf\u6bb5\u6811\u4e2d\u627e\u5230\u533a\u95f4$l$\u5230$r$\uff0c\u7136\u540e\u5728\u5e73\u8861\u6811\u4e2d\u67e5\u627e\u5c0f\u4e8e$k$\u7684\u4e2a\u6570\uff0c\u6700\u540e\u52a0$1$\u5373\u4e3a$k$\u7684\u6392\u540d\n\n## \u64cd\u4f5c\u4e8c \u533a\u95f4\u7b2ck\u5927\n\n\u6211\u4eec\u8003\u8651\u4e8c\u5206\u7b54\u6848\uff0c\u7136\u540e\u53bb\u68c0\u67e5\u7b54\u6848\n\n\u68c0\u67e5\u7b54\u6848\u7684\u65b9\u6cd5\u4e3a\uff1a\n\n\u5c06$mid$\u5728\u533a\u95f4\u4e2d\u627e\u6392\u540d\n\n\u5c0f\u4e8e\u7b49\u4e8e$k$\uff0c\u8bb0\u5f55\u7b54\u6848\uff0c$l=mid+1$\n\n\u5426\u5219$r=mid-1$\n\n## \u64cd\u4f5c\u4e09 \u5355\u70b9\u4fee\u6539\n\n\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u533a\u95f4\uff0c\u53ea\u8981\u5305\u62ec$pos$\uff0c\u5728\u5e73\u8861\u6811\u4e2d\u5220\u9664\u539f\u6765\u7684\u503c\uff0c\u63d2\u5165\u73b0\u5728\u4fee\u6539\u7684\u503c\n\n## \u64cd\u4f5c\u56db \u533a\u95f4\u4e2dk\u7684\u524d\u9a71\n\n\u7c7b\u4f3c\u4e8e\u53ea\u6709\u5e73\u8861\u6811\u627e\u524d\u9a71\uff0c\u53ea\u662f\u591a\u4e86\u68f5\u7ebf\u6bb5\u6811\u800c\u5df2\n\n\u5728\u533a\u95f4$l$\u5230$r$(\u7ebf\u6bb5\u6811)\u627e\u524d\u9a71(\u5e73\u8861\u6811)\uff0c\u53d6\u6700\u5927\u503c\u5c31\u597d\u4e86\n\n\u6ca1\u6709\u8bb0\u5f97\u8fd4\u56de$-INF$\n\n## \u64cd\u4f5c\u4e94 \u533a\u95f4\u4e2dk\u7684\u540e\u7ee7\n\n\u7c7b\u6bd4\u524d\u9a71\uff0c\u8bb0\u5f97\u8fd4\u56de$INF$\n\n## \u6700\u540e\n\n\u8fd9\u9053\u9898\u5e73\u8861\u6811\u5f00\u591a\u5927\u7684\u7a7a\u95f4\u662f\u4e00\u95e8\u5b66\u95ee\n\n~~\u6211\u4eec\u53ef\u4ee5\u4e00\u904d\u4e00\u904d\u8bd5~~\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5b83\u4f1a\u88ab\u7ea6$log(n)$\u4e2a\u533a\u95f4\u5305\u542b(\u7ebf\u6bb5\u6811\u4e0a)\uff0c\u800c\u4e00\u4e2a\u70b9\u5bf9\u5e94\u7684\u5c31\u662f\u5e73\u8861\u6811\u4e0a\u7684\u4e00\u4e2a\u70b9\uff0c\u5171$n(n \\le 5*10^4)$\u4e2a\u70b9\uff0c\u6240\u4ee5\u8981\u5f00$5*10^4*log(5*10^4)$\n\n\u7136\u540e\u8fd8\u6709\u4fee\u6539\u64cd\u4f5c\uff0c\u6bcf\u4e2a\u4fee\u6539\u64cd\u4f5c\u4f1a\u589e\u52a0$log(n)$\u4e2a\u70b9\uff0c$m(m \\le 5*10^4)$\u4e2a\u64cd\u4f5c\uff0c\u6240\u4ee5\u4e5f\u8981\u5f00$5*10^4*log(5*10^4)$\n\n\u5171\u8981\u5f00$5*10^4*log(5*10^4)*2$\u5927\u7684\u7a7a\u95f4(\u5e73\u8861\u6811)\n\n$log(5*10^4)$\u7ea6\u7b49\u4e8e$16$\uff0c\u6240\u4ee5\u5e73\u8861\u6811\u8981\u5f00$1.6*10^6$\u5927\u7684\u7a7a\u95f4\n\n**\u518d\u63d0\u9192\u4e00\u904d\uff0c\u8981\u5f00$O2$\u624d\u80fd\u8fc7**\n\n# \u4ee3\u7801\n```cpp\n//12252024832524\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std; \n\ntypedef long long LL;\nconst int MAXN = 50005;\nconst int INF = 2147483647;\nint n,m,tot;\nint a[MAXN];\n\nint Read()\n{\n\tint x = 0,f = 1;char c = getchar();\n\twhile(c > '9' || c < '0'){if(c == '-')f = -1;c = getchar();}\n\twhile(c >= '0' && c <= '9'){x = (x*10) + (c^48);c = getchar();}\n\treturn x * f;\n}\nvoid Put1(int x)\n{\n\tif(x > 9) Put1(x/10);\n\tputchar(x%10^48);\n}\nvoid Put(int x)\n{\n\tif(x < 0) putchar('-'),x = -x;\n\tPut1(x);\n}\ntemplate <typename T>T Max(T x,T y){return x > y ? x : y;}\ntemplate <typename T>T Min(T x,T y){return x < y ? x : y;}\ntemplate <typename T>T Abs(T x){return x < 0 ? -x : x;}\n\nstruct treap\n{\n\tint ch[2],siz,rd,val;\n}t[1600005];\nstruct Np\n{\n\tint p[2];\n\tNp(){p[0] = p[1] = 0;} \n};\nstruct FHQ_Treap\n{\n\tint rt;\n\tFHQ_Treap(){rt = 0;}\n\tvoid up(int x)\n\t{\n\t\tt[x].siz = t[t[x].ch[0]].siz + t[t[x].ch[1]].siz + 1;\n\t}\n\tint NewPoint(int val)\n\t{\n\t\ttot++;\n\t\tt[tot].ch[0] = t[tot].ch[1] = 0;\n\t\tt[tot].val = val;\n\t\tt[tot].siz = 1;\n\t\tt[tot].rd = rand();\n\t\treturn tot;\n\t}\n\tvoid Build(int l,int r)\n\t{\n\t\tfor(int i = l;i <= r;++ i)\n\t\t\tins(a[i]);\n\t\treturn ;\n\t}\n\tNp split(int x,int val)\n\t{\n\t\tNp ans;\n\t\tif(x)\n\t\t{\n\t\t\tbool d = (val >= t[x].val);\n\t\t\tif(!d)\n\t\t\t\tans = split(t[x].ch[d],val);\n\t\t\telse \n\t\t\t\tans = split(t[x].ch[d],val);\n\t\t\tt[x].ch[d] = ans.p[d^1];\n\t\t\tans.p[d^1] = x;\n\t\t\tup(x);\n\t\t}\n\t\treturn ans;\n\t}\n\tint merg(int x1,int x2)\n\t{\n\t\tif(!x1 || !x2) return x1^x2;\n\t\tif(t[x1].rd < t[x2].rd)\n\t\t{\n\t\t\tt[x1].ch[1] = merg(t[x1].ch[1],x2);\n\t\t\tup(x1);\n\t\t\treturn x1;\n\t\t}\n\t\tt[x2].ch[0] = merg(x1,t[x2].ch[0]);\n\t\tup(x2);\n\t\treturn x2;\n\t}\n\tvoid ins(int val)\n\t{\n\t\tNp t1 = split(rt,val);\n\t\trt = merg(merg(t1.p[0],NewPoint(val)),t1.p[1]);\n\t\treturn ;\n\t}\n\tvoid delet(int val)\n\t{\n\t\tNp t1 = split(rt,val);\n\t\tNp t0 = split(t1.p[0],val-1);\n\t\tt0.p[1] = merg(t[t0.p[1]].ch[0],t[t0.p[1]].ch[1]);\n\t\trt = merg(t0.p[0],merg(t0.p[1],t1.p[1]));\n\t\treturn;\n\t}\n\tint kth(int x,int k)\n\t{\n\t    while(1)\n\t    {\n\t        if(k <= t[t[x].ch[0]].siz) x = t[x].ch[0];\n\t        else if(k > t[t[x].ch[0]].siz + 1)\n\t        {\n\t            k -= t[t[x].ch[0]].siz + 1;\n\t            x = t[x].ch[1];\n\t        }\n\t        else return t[x].val;\n\t    }\n\t}\n\tint rnk(int val)\n\t{\n\t\tNp x = split(rt,val-1);\n\t\tint ret = t[x.p[0]].siz+1;\n\t\trt = merg(x.p[0],x.p[1]);\n\t\treturn ret;\n\t}\n\tint pre(int val)\n\t{   \n\t\tNp x = split(rt,val-1);\n\t\tint ret;\n\t\tif(t[x.p[0]].siz) ret = kth(x.p[0],t[x.p[0]].siz);\n\t\telse ret = -INF;\n\t\trt = merg(x.p[0],x.p[1]);\n\t\treturn ret;\n\t}\n\tint nxt(int val)\n\t{\n\t    Np x = split(rt,val);\n\t\tint ret;\n\t\tif(t[x.p[1]].siz) ret = kth(x.p[1],1);\n\t\telse ret = INF;\n\t\trt = merg(x.p[0],x.p[1]);\n\t\treturn ret;\n\t}\n}FT[MAXN << 2];\n\nstruct SegmentTree\n{\n\tvoid Build(int x,int l,int r)\n\t{\n\t\tFT[x].Build(l,r);\n\t\tint mid = (l+r) >> 1;\n\t\tif(l < r)\n\t\t{\n\t\t\tBuild(x<<1,l,mid);\n\t\t\tBuild(x<<1|1,mid+1,r);\n\t\t}\n\t\treturn;\n\t}\n\tvoid up(int x,int l,int r,int p,int k)\n\t{\n\t\tFT[x].delet(a[p]);\n\t\tFT[x].ins(k);\n\t\tif(l < r)\n\t\t{\n\t\t\tint mid = (l+r) >> 1;\n\t\t\tif(p <= mid) up(x<<1,l,mid,p,k);\n\t\t\telse up(x<<1|1,mid+1,r,p,k);\n\t\t}\n\t\treturn;\n\t}\n\tint Qrank(int x,int l,int r,int val,int ql,int qr)\n\t{\n\t\tif(l > qr || r < ql) return 0;\n\t\tif(l >= ql && r <= qr) return FT[x].rnk(val)-1;\n\t\tint mid = (l+r) >> 1;\n\t\treturn Qrank(x<<1,l,mid,val,ql,qr) + Qrank(x<<1|1,mid+1,r,val,ql,qr);\n\t} \n\tint Qkth(int l,int r,int val)\n\t{\n\t\tint x = -1e8,y = 1e8,ret = -1;\n        while (x <= y)\n        {\n        \tint mid = (x+y) >> 1;\n            if (Qrank(1,1,n,mid,l,r) + 1 <= val) ret = mid,x = mid + 1;\n            else y = mid - 1;\n        }\n        return ret;\n\t}\n\tint pre(int x,int l,int r,int ql,int qr,int val)\n\t{\n\t\tif(l > qr || r < ql) return -INF;\n\t\tif(l >= ql && r <= qr) return FT[x].pre(val);\n\t\tint mid = (l+r) >> 1;\n\t\treturn Max(pre(x<<1,l,mid,ql,qr,val),pre(x<<1|1,mid+1,r,ql,qr,val));\n\t}\n\tint nxt(int x,int l,int r,int ql,int qr,int val)\n\t{\n\t\tif(l > qr || r < ql) return INF;\n\t\tif(l >= ql && r <= qr) return FT[x].nxt(val);\n\t\tint mid = (l+r) >> 1;\n\t\treturn Min(nxt(x<<1,l,mid,ql,qr,val),nxt(x<<1|1,mid+1,r,ql,qr,val));\n\t}\n}ST;\n\nint main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn = Read();\n\tm = Read();\n\tfor(int i = 1;i <= n;++ i)\n\t\ta[i] = Read();\n\tST.Build(1,1,n);\n\tfor(int i = 1;i <= m;++ i)\n\t{\n\t\tint opt = Read(),l = Read(),r = Read();\n\t\tif(opt == 1)\n\t\t{\n\t\t\tPut(ST.Qrank(1,1,n,Read(),l,r) + 1);\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(opt == 2)\n\t\t{\n\t\t\tPut(ST.Qkth(l,r,Read()));\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(opt == 3)\n\t\t{\n\t\t\tST.up(1,1,n,l,r);\n\t\t\ta[l] = r;\n\t\t}\n\t\telse if(opt == 4)\n\t\t{\n\t\t\tPut(ST.pre(1,1,n,l,r,Read()));\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse if(opt == 5)\n\t\t{\n\t\t\tPut(ST.nxt(1,1,n,l,r,Read()));\n\t\t\tputchar('\\n');\n\t\t}\n\t\telse printf(\"ZiBi++\\n\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1575448318,
        "uid": 137437,
        "name": "PPL_",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8fd9\u5927\u6982\u662f\u53f2\u4e0a\u6700\u77ed$ O(Nlog^2N) $\u4ee3\u7801\uff1f\n\n\u5b66\u4e60\u4e86**pbds**\u548c\u7ebf\u6bb5\u6811\u52a8\u6001\u5f00\u70b9\uff0c\u4e8e\u662f\u6765\u7ec3\u4e60\n\n\u819c\u62dc\u4e86\u5176\u4ed6\u5927\u4f6c\u7684\u9898\u89e3\uff0c\u5916\u9762\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u91cc\u9762pbds\u7ea2\u9ed1\u6811\u7ef4\u62a4\u4e0b\u6807\n\n\u4e8e\u662f\u6240\u6709\u5e73\u8861\u6811\u64cd\u4f5c\u90fd\u6210\u4e86\u4e00\u884c\n\n\u800c\u7ebf\u6bb5\u6811\u53ea\u9700\u8981\u51993\u4e2a\u64cd\u4f5c\n\n1.\u67e5\u6392\u540d\n\n\u5bf9\u4e8e\u6743\u503c\u5c0f\u4e8e$ k $\u7684\u5728\u67e5\u8be2\u533a\u95f4\u5185\u7684\u6570\u6c42\u548c\n\n2.\u627e\u7b2c$ k $\u5c0f\n\n\u5728\u7ebf\u6bb5\u6811\u4e0a\u8d70\n\n\u68c0\u67e5\u5de6\u513f\u5b50(\u5bf9\u5e94\u7684\u503c\u4e00\u5b9a\u90fd\u5c0f\u4e8e\u53f3\u4fa7\u503c)\u5185\u843d\u5728\u67e5\u8be2\u533a\u95f4\u5185\u7684\u6570\u7684\u4e2a\u6570\n\n\u5982\u679c\u5c0f\u4e86\uff0c\u8bf4\u660e\u5f53\u524d\u7684\u503c\u5c0f\u4e86\uff0c\u5f80\u53f3\u8d70\uff0c\u5426\u5219\u5f80\u5de6\u8d70\n\n3.\u5220\u9664/\u63d2\u5165\n\n\u5438\u4e86\u6c27\u6c14\u540e\u5c31\u53ef\u4ee5\u5927\u529bAC\u5566\uff01\n\n\u4ee3\u7801\u53ea\u670982\u884c\uff0cpbds\u771f\u662f\u4e2a\u543c\u4e1c\u897f\u554a\uff01\n\n```cpp\n// luogu-judger-enable-o2\n#include<bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\nconst int MAXN=100000000;\nint n,m,a[50005],tot,rt,lch[1500000],rch[1500000];\ntree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update>tr[1500000];\nvoid read(int& x)\n{\n    char c=getchar();\n    x=0;\n    while(c<'0'||c>'9')c=getchar();\n    while(c>='0'&&c<='9')\n    {\n        x=x*10+c-'0';\n        c=getchar();\n    }\n}\nvoid insert(int& o,int l,int r,int k,int pos,bool op)//l,r\u4e3a\u503c\u57df\u533a\u95f4,k\u4e3a\u503c,pos\u4e3a\u4f4d\u7f6e,op\u4e3a\u5220\u9664\u6216\u63d2\u5165\n{\n    if(!o)o=++tot;\n    if(op)tr[o].insert(pos);\n    else tr[o].erase(pos);\n    if(l==r)return ;\n    int mid=(l+r)>>1;\n    if(k<=mid)insert(lch[o],l,mid,k,pos,op);\n    else insert(rch[o],mid+1,r,k,pos,op);\n}\nint getrank(int& o,int l,int r,int k,int ql,int qr)//l,r\u4e3a\u503c\u57df\u533a\u95f4,ql,qr\u4e3a\u4f4d\u7f6e\u533a\u95f4,k\u4e3a\u503c\n{\n    if(!o)o=++tot;\n    if(r<=k)return tr[o].order_of_key(qr+1)-tr[o].order_of_key(ql);\n    int mid=(l+r)>>1,ans=getrank(lch[o],l,mid,k,ql,qr);\n    if(k>mid)ans+=getrank(rch[o],mid+1,r,k,ql,qr);\n    return ans;\n}\nint kth(int& o,int l,int r,int k,int ql,int qr)\n{\n    if(!o)o=++tot;\n    if(l==r)return l;\n    int mid=(l+r)>>1;\n    int cnt=tr[lch[o]].order_of_key(qr+1)-tr[lch[o]].order_of_key(ql);\n    if(cnt>=k)return kth(lch[o],l,mid,k,ql,qr);\n    else return kth(rch[o],mid+1,r,k-cnt,ql,qr);\n}\nint main()\n{\n    read(n);\n    read(m);\n    for(int i=1;i<=n;i++)read(a[i]);\n    for(int i=1;i<=n;i++)insert(rt,0,MAXN,a[i],i,1);\n    for(int i=1;i<=m;i++)\n    {\n        int op,l,r,pos,k;\n        read(op);\n        if(op!=3)\n        {\n            read(l);\n            read(r);\n        }\n        else read(pos);\n        read(k);\n        if(op==1)printf(\"%d\\n\",getrank(rt,0,MAXN,k-1,l,r)+1);\n        else if(op==2)printf(\"%d\\n\",kth(rt,0,MAXN,k,l,r));\n        else if(op==3)\n        {\n            insert(rt,0,MAXN,a[pos],pos,0);\n            insert(rt,0,MAXN,a[pos]=k,pos,1);\n        }\n        else if(op==4)\n        {\n            int rk=getrank(rt,0,MAXN,k-1,l,r)+1;\n            if(rk==1)printf(\"-2147483647\\n\");\n            else printf(\"%d\\n\",kth(rt,0,MAXN,rk-1,l,r));\n        }\n        else\n        {\n            int rk=getrank(rt,0,MAXN,k,l,r)+1;\n            if(rk>r-l+1)printf(\"2147483647\\n\");\n            else printf(\"%d\\n\",kth(rt,0,MAXN,rk,l,r));\n        }\n    }\n}\n```\n",
        "postTime": 1566029037,
        "uid": 68207,
        "name": "CreeperLordVader",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u8fd9\u9898\u5f88\u660e\u663e\u662f\u4e2a\u6811\u5957\u6811\u6a21\u677f\u2026\u2026\n\n\u4f46\u662f\uff01\u6811\u5957\u6811\u662f\u8981\u5e73\u8861\u6811\u7684\uff01~~\u6253\u5b8c\u4ee3\u7801debug\u4e00\u5e74\u771f\u7684\u662f\u70e6~~\n\n\u540c\u65f6\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u6781\u5ea6\u61d2\u764c\u60a3\u8005\uff0c\u8c03\u8bd5\u90a3\u4e48\u4e45\u7684\u5e73\u8861\u6811\u662f\u4e0d\u7b26\u5408\u6211\u7684\u4fe1\u6761\u7684\u2026\u2026\n\n\u6240\u4ee5\uff0c\u6211$8$\u6253\u7b97\u641e\u90a3\u4e48\u591a\u82b1\u91cc\u80e1\u54e8\u7684\u4e1c\u897f\uff0c\u800c\u662f\u7528\u4e00\u4e2a\u795e\u7ea7STL`vector`\u3002\n\n`vector`\u7684\u63d2\u5165`insert`\u7684\u6548\u7387\u5f88\u9ad8\uff0c\u7406\u8bba\u4e0a\u662f$O(\\log{n})$\u3002\n\n\u5229\u7528\u8fd9\u4e2a\uff0c\u6211\u4eec\u5b8c\u5168\u53ef\u4ee5\u7528`vector`\u6765\u5207\u8fd9\u79cd\u9700\u8981\u7528\u5e73\u8861\u6811\u7684\u9898\u76ee\uff0c\u8fd8\u53ef\u4ee5\u5b9e\u73b0`std::set`\u5b9e\u73b0\u4e0d\u4e86\u7684`findval()`\u3001`findrank()`\u7b49\u64cd\u4f5c\uff01\uff08\u8fd0\u7528`upper_bound()`\u3001`lower_bound()`\u7b49`STL`\u51fd\u6570\uff09\n\n~~\u5438\u4e86\u6c27\u4e4b\u540e\u8dd1\u5f97\u6bd4\u540c\u673a\u623f\u5927\u4f6c\u7684`FHQ_Treap`\u8fd8\u5feb\u2026\u2026~~\n\n\u5b8c\u7206\u4ec0\u4e48Splay Treap \u597d\u5417\u2026\u2026\n\u4ee3\u7801\uff1a\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T, size_t size>\nclass TreeInTree{\nprivate:\n\tstruct Node{\n\t\tvector<T> a;\n        int l, r;\n\t\t// \u5047\u88c5\u662f\u4e2a\u5e73\u8861\u6811\n\t}tr[size << 2];\npublic:\n    void build(int l, int r, T *a, int p = 1) {\n        if(l == r) {\n            tr[p].a.push_back(-2147483647);\n            tr[p].a.push_back(a[l]);\n            tr[p].a.push_back(2147483647);\n            tr[p].l = tr[p].r = l;\n            return;\n        }\n        int mid = (l + r) >> 1;\n        build(l, mid, a, p << 1);\n        build(mid + 1, r, a, p << 1 | 1);\n        tr[p].a.push_back(-2147483647);\n        auto pl = tr[p << 1].a.begin() + 1, pr = tr[p << 1 | 1].a.begin() + 1;\n        for(int i = l; i <= r; i++)\n            tr[p].a.push_back((*pl) > (*pr) ? (*pr++) : (*pl++));\n        tr[p].l = l;\n        tr[p].r = r;\n        tr[p].a.push_back(2147483647);\n    }\n    int findk(int l, int r, T val, int p = 1) {\n        if(l <= tr[p].l && tr[p].r <= r) {\n        \tint rank = (int)(upper_bound(tr[p].a.begin() + 1, tr[p].a.end() - 1, val - 1) - tr[p].a.begin() - 1);\n        \treturn rank;\n\t\t}\n        int mid = (tr[p].l + tr[p].r) >> 1;\n        int ans = 0;\n        if(l <= mid)\n            ans += findk(l, r, val, p << 1);\n        if(mid < r)\n            ans += findk(l, r, val, p << 1 | 1);\n        return ans;\n    }\n    T change(int pos, T val, int p = 1) {\n        if(tr[p].l == tr[p].r) {\n            T d = tr[p].a[1];\n            tr[p].a[1] = val;\n            return d;\n        }\n        int mid = (tr[p].l + tr[p].r) >> 1;\n        T c;\n        if(pos <= mid)\n            c = change(pos, val, p << 1);\n        else\n            c = change(pos, val, p << 1 | 1);\n        tr[p].a.erase(find(tr[p].a.begin(), tr[p].a.end(), c));\n        tr[p].a.insert(upper_bound(tr[p].a.begin(), tr[p].a.end(), val), val);\n        return c;\n    }\n    T findval(int L, int R, int rank) {\n        T l = 0, r = 1e8, mid;\n        while(l < r) {\n            mid = (l + r + 1) >> 1;\n            if(findk(L, R, mid) < rank)\n                l = mid;\n            else \n                r = mid - 1;\n        }\n        return r;\n    }\n    T findpre(int l, int r, T val, int p = 1) {\n        if(l <= tr[p].l && tr[p].r <= r) {\n            return *--lower_bound(tr[p].a.begin(), tr[p].a.end(), val);\n        }\n        int mid = (tr[p].l + tr[p].r) >> 1;\n        T ans = -2147483647;\n        if(l <= mid)\n            ans = max(ans, findpre(l, r, val, p << 1));\n        if(mid < r)\n            ans = max(ans, findpre(l, r, val, p << 1 | 1));\n        return ans;\n    }\n    T findnxt(int l, int r, T val, int p = 1) {\n        if(l <= tr[p].l && tr[p].r <= r) {\n            auto d = upper_bound(tr[p].a.begin(), tr[p].a.end(), val);\n            if(*d == val)\n                return *++d;\n            return *d;\n        }\n        int mid = (tr[p].l + tr[p].r) >> 1;\n        T ans = 2147483647;\n        if(l <= mid)\n            ans = min(ans, findnxt(l, r, val, p << 1));\n        if(mid < r)\n            ans = min(ans, findnxt(l, r, val, p << 1 | 1));\n        return ans;\n    }\n    void debug(int p = 1){\n    \tif(tr[p].l == tr[p].r) {\n    \t\tprintf(\"%d \", tr[p].a[1]);\n    \t\treturn;\n\t\t}\n\t\tdebug(p << 1);\n\t\tdebug(p << 1 | 1);\n\t}\n};\nTreeInTree<int, 100000> a;\nint num[100000];\nint main() {\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d\", num + i);\n    a.build(1, n, num);\n    int op, l, r, k;\n\n    while(m--) {\n        scanf(\"%d\", &op);\n        switch(op) {\n            case 1:\n                scanf(\"%d%d%d\", &l, &r, &k);\n                printf(\"%d\\n\", a.findk(l, r, k) + 1);\n                break;\n            case 2:\n                scanf(\"%d%d%d\", &l, &r, &k);\n                printf(\"%d\\n\", a.findval(l, r, k));\n                break;\n            case 3:\n                scanf(\"%d%d\", &l, &k);\n                a.change(l, k);\n            \t//a.debug(); \n                break;\n            case 4:\n                scanf(\"%d%d%d\", &l, &r, &k);\n                printf(\"%d\\n\", a.findpre(l, r, k));\n                break;\n            case 5:\n                scanf(\"%d%d%d\", &l, &r, &k);\n                printf(\"%d\\n\", a.findnxt(l, r, k));\n                break;\n        }\n    }\n} \n```\n\n\u4e00\u5957\u641e\u4e0b\u6765\uff0c\u4e00\u5c0f\u65f6\u4e0d\u5230\u5c31AC\u4e86\u3002\n",
        "postTime": 1563539719,
        "uid": 84832,
        "name": "MaxDYF",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u3002\u6b63\u89e3\u5e94\u8be5\u662f\u7ebf\u6bb5\u6811\u5957 $\\text{Treap}$ \u6216\u8005\u7ebf\u6bb5\u6811\u5957 $\\text{Splay}$\uff0c\u4f46\u8fd9\u4e24\u79cd\u6211\u90fd\u4e0d\u7cbe\u901a\uff0c\u6240\u4ee5\u5c31\u5199\u4e86\u4e00\u4e2a\u5e73\u65f6\u6bd4\u8f83\u559c\u6b22\u7684 $\\text{FHQ Treap}$\u3002\u7528 $\\text{FHQ Treap}$ \u786e\u5b9e\u5f88\u65b9\u4fbf\uff0c\u4e14\u4ee3\u7801\u597d\u7406\u89e3\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u7684\u590d\u6742\u5ea6\u4f3c\u4e4e\u662f\u591a\u4e00\u4e2a $log$ \u8fd8\u662f\u600e\u4e48\uff0c\u6240\u4ee5\u653e\u8fd9\u9898\u4f1a $\\text{T}$ $3$ \u4e2a\u70b9\uff0c\u7ecf\u8fc7\u5e38\u6570\u4f18\u5316\u5e94\u8be5\u662f\u53ef\u4ee5\u8fc7 $9$ \u4e2a\u70b9\uff08\u6211\u53ea\u8fc7\u4e86 $8$ \u4e2a\uff09\u6700\u540e\u8fd8\u662f\u8981\u5f00 $O2$\uff0c\u4f46\u662f\u4e3a\u4e86\u9632\u6b62\u4ee5\u540e\u7684\u53ef\u6301\u4e45\u5316\uff0c$\\text{FHQ Treap}$ \u8fd8\u662f\u975e\u5e38\u6709\u7528\u7684\u3002\n\n$\\text{FHQ Treap}$ \u7684\u6a21\u677f\u53ef\u4ee5\u89c1\u6211\u7684\u8fd9\u7bc7\u535a\u5ba2\uff1a[\u795e\u7ea7\u6570\u636e\u7ed3\u6784 \u2014\u2014 FHQ Treap](https://www.luogu.org/blog/Venus/shen-ji-shuo-ju-jie-gou-fhq-treap)\uff0c\u5199\u7684\u975e\u5e38\u70c2\uff0c\u4f46\u4e3b\u8981\u53ef\u4ee5\u8bb0\u6a21\u677f\u3002\n\n\u5bf9\u4e8e\u8fd9\u9898\uff0c\u6211\u4eec\u7684 $\\text{FHQ Treap}$ \u9700\u8981\u7f16\u5199\u4ee5\u4e0b\u51fd\u6570\uff1a\n\n$\\text{NewNode}$ $\\text{Merge}$ $\\text{Split}$ $\\text{Update}$ \u8fd9\u56db\u4e2a\u57fa\u672c\u7684\uff0c\u7136\u540e\u662f\u4e00\u4e9b\u7279\u6b8a\u7684\uff0c\u5982\u4e0b\u3002\n\n\u7528\u4e8e\u63d2\u5165\u4e00\u4e2a\u6570\u7684 $\\text{Insert}$\uff0c\u7528\u4e8e\u63d2\u5165\u4e00\u6bb5\u6570\u7684 $\\text{Build}$\uff0c\u7528\u4e8e\u5220\u9664\u4e00\u4e2a\u6570\u7684 $\\text{Delete}$\uff0c\u7528\u4e8e\u5bfb\u627e $val$ \u7684\u6392\u540d\u7684 $\\text{FindRak}$\uff0c\u7528\u4e8e\u5bfb\u627e\u6392\u540d\u4e3a $rk$ \u7684\u6570\u7684\u503c\u7684 $\\text{FindVal}$\uff0c\u7528\u4e8e\u67e5\u627e\u524d\u9a71\u7684 $\\text{FindPre}$\uff0c\u7528\u4e8e\u67e5\u627e\u540e\u7ee7\u7684 $\\text{FindFlw}$\u3002\n\n\u5185\u5c42\u7684\u6811\u641e\u5b9a\u4e86\uff0c\u8fd8\u6709\u5916\u5c42\u7684\u7ebf\u6bb5\u6811\uff0c\u9700\u8981\u7f16\u5199\u7684\u51fd\u6570\u6839\u636e\u7528\u9014\u6bd4\u8f83\u96be\u5199\uff0c\u4e3b\u8981\u8fd8\u662f\u8981\u770b\u4ee3\u7801\uff0c\u8349\u8349\u7684\u8bf4\u4e00\u4e0b\uff0c\u5927\u81f4\u9700\u8981\u5efa\u6811\u51fd\u6570\u3001\u67e5\u8be2\u533a\u95f4\u6392\u540d\u51fd\u6570\u3001\u67e5\u8be2\u533a\u95f4\u6392\u540d\u503c\u51fd\u6570\u3001\u4fee\u6539\u5355\u70b9\u503c\u51fd\u6570\u3001\u67e5\u8be2\u533a\u95f4\u524d\u9a71\u51fd\u6570\u3001\u67e5\u8be2\u533a\u95f4\u540e\u7ee7\u51fd\u6570\uff0c\u4e5f\u5c31\u662f\u9898\u76ee\u4e2d\u63d0\u5230\u7684 $5$ \u79cd\u64cd\u4f5c\u52a0\u4e00\u4e2a\u989d\u5916\u7684\u5efa\u6811\u51fd\u6570\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define MAXN 50005\n#define MAXM 10000005\n#define inf 2147483647\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<21],*p1=buf,*p2=buf;\nusing namespace std;\nstruct FHQTreap\n{\n\tint son[2],val,siz,key;\n}t[MAXM];\nint n,Q,a[MAXN],siz;\ntemplate <typename T> void Read(T &x)\n{\n\tx=0;\n\tchar ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar());\n\tfor(;isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+(ch-48);\n}\nstruct FHQ_Treap\n{\n\tint root;\n\tint NewNode(int val)\n\t{\n\t\tt[++siz].siz=1;\n\t\tt[siz].key=rand();\n\t\tt[siz].val=val;\n\t\treturn siz;\n\t}\n\tvoid Update(int rt)\n\t{\n\t\tt[rt].siz=t[t[rt].son[0]].siz+t[t[rt].son[1]].siz+1;\n\t}\n\tint Merge(int x,int y)\n\t{\n\t\tif(!x || !y) return x+y;\n\t\tif(t[x].key<t[y].key)\n\t\t{\n\t\t\tt[x].son[1]=Merge(t[x].son[1],y);\n\t\t\tUpdate(x);\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt[y].son[0]=Merge(x,t[y].son[0]);\n\t\t\tUpdate(y);\n\t\t\treturn y;\n\t\t}\n\t}\n\tvoid Split(int rt,int pos,int &x,int &y)\n\t{\n\t\tif(!rt) x=y=0;\n\t\telse\n\t\t{\n\t\t\tif(t[rt].val<=pos)\n\t\t\t{\n\t\t\t\tx=rt;\n\t\t\t\tSplit(t[rt].son[1],pos,t[rt].son[1],y);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ty=rt;\n\t\t\t\tSplit(t[rt].son[0],pos,x,t[rt].son[0]);\n\t\t\t}\n\t\t\tUpdate(rt);\n\t\t}\n\t}\n\tvoid Build(int x,int y)\n\t{\n\t\tfor(int i=x;i<=y;i++) Insert(a[i]);\n\t}\n\tvoid Insert(int val)\n\t{\n\t\tint x,y;\n\t\tSplit(root,val,x,y);\n\t\troot=Merge(Merge(x,NewNode(val)),y);\n\t}\n\tvoid Delete(int val)\n\t{\n\t\tint x,y,z;\n\t\tSplit(root,val,x,z);\n\t\tSplit(x,val-1,x,y);\n\t\ty=Merge(t[y].son[0],t[y].son[1]);\n\t\troot=Merge(x,Merge(y,z));\n\t}\n\tint FindRak(int val)\n\t{\n\t\tint x,y,res;\n\t\tSplit(root,val-1,x,y);\n\t\tres=t[x].siz+1;\n\t\troot=Merge(x,y);\n\t\treturn res;\n\t}\n\tint FindVal(int rt,int rk)\n\t{\n\t\twhile(1)\n\t\t{\n\t\t\tif(rk<=t[t[rt].son[0]].siz) rt=t[rt].son[0];\n\t\t\telse if(rk==t[t[rt].son[0]].siz+1) return t[rt].val;\n\t\t\telse\n\t\t\t{\n\t\t\t\trk-=t[t[rt].son[0]].siz+1;\n\t\t\t\trt=t[rt].son[1];\n\t\t\t}\n\t\t}\n\t}\n\tint FindPre(int val)\n\t{\n\t\tint x,y,res;\n\t\tSplit(root,val-1,x,y);\n\t\tif(t[x].siz) res=FindVal(x,t[x].siz);\n\t\telse res=-inf;\n\t\troot=Merge(x,y);\n\t\treturn res;\n\t}\n\tint FindFlw(int val)\n\t{\n\t\tint x,y,res;\n\t\tSplit(root,val,x,y);\n\t\tif(t[y].siz) res=FindVal(y,1);\n\t\telse res=inf;\n\t\troot=Merge(x,y);\n\t\treturn res;\n\t}\n}fhq[MAXN<<2];\nvoid BuildSegmentTree(int rt,int l,int r)\n{\n\tfhq[rt].Build(l,r);\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tBuildSegmentTree(rt<<1,l,mid);\n\tBuildSegmentTree(rt<<1|1,mid+1,r);\n}\nint QueryRak(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr) return fhq[rt].FindRak(val)-1;\n\tint mid=l+r>>1,res=0;\n\tif(tl<=mid) res+=QueryRak(rt<<1,l,mid,tl,tr,val);\n\tif(tr>mid) res+=QueryRak(rt<<1|1,mid+1,r,tl,tr,val);\n\treturn res;\n}\nint QueryVal(int x,int y,int rk)\n{\n\tint l=0,r=inf/20,res=-1;\n\twhile(l<=r)\n\t{\n\t\tint mid=l+r>>1;\n\t\tif(QueryRak(1,1,n,x,y,mid)+1<=rk)\n\t\t{\n\t\t\tres=mid;\n\t\t\tl=mid+1;\n\t\t}\n\t\telse r=mid-1;\n\t}\n\treturn res;\n}\nvoid Modify(int rt,int l,int r,int pos,int val)\n{\n\tfhq[rt].Delete(a[pos]);\n\tfhq[rt].Insert(val);\n\tif(l==r) return;\n\tint mid=l+r>>1;\n\tif(pos<=mid) Modify(rt<<1,l,mid,pos,val);\n\telse Modify(rt<<1|1,mid+1,r,pos,val);\n}\nint GetPre(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr) return fhq[rt].FindPre(val);\n\tint mid=l+r>>1,res=-inf;\n\tif(tl<=mid) res=max(res,GetPre(rt<<1,l,mid,tl,tr,val));\n\tif(tr>mid) res=max(res,GetPre(rt<<1|1,mid+1,r,tl,tr,val));\n\treturn res;\n}\nint GetFlw(int rt,int l,int r,int tl,int tr,int val)\n{\n\tif(tl<=l && r<=tr) return fhq[rt].FindFlw(val);\n\tint mid=l+r>>1,res=inf;\n\tif(tl<=mid) res=min(res,GetFlw(rt<<1,l,mid,tl,tr,val));\n\tif(tr>mid) res=min(res,GetFlw(rt<<1|1,mid+1,r,tl,tr,val));\n\treturn res;\n}\nint main()\n{\n\tRead(n);\n\tRead(Q);\n\tfor(int i=1;i<=n;i++) Read(a[i]);\n\tBuildSegmentTree(1,1,n);\n\twhile(Q--)\n\t{\n\t\tint opt,x,y,z;\n\t\tRead(opt);\n\t\tRead(x);\n\t\tRead(y);\n\t\tif(opt==1)\n\t\t{\n\t\t\tRead(z);\n\t\t\tprintf(\"%d\\n\",QueryRak(1,1,n,x,y,z)+1);\n\t\t}\n\t\telse if(opt==2)\n\t\t{\n\t\t\tRead(z);\n\t\t\tprintf(\"%d\\n\",QueryVal(x,y,z));\n\t\t}\n\t\telse if(opt==3)\n\t\t{\n\t\t\tModify(1,1,n,x,y);\n\t\t\ta[x]=y;\n\t\t}\n\t\telse if(opt==4)\n\t\t{\n\t\t\tRead(z);\n\t\t\tprintf(\"%d\\n\",GetPre(1,1,n,x,y,z));\n\t\t}\n\t\telse if(opt==5)\n\t\t{\n\t\t\tRead(z);\n\t\t\tprintf(\"%d\\n\",GetFlw(1,1,n,x,y,z));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546840761,
        "uid": 23243,
        "name": "VenusM1nT",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    },
    {
        "content": "\u539f\u9898\u4f20\u9001\u95e8[>Here<](https://www.luogu.org/problemnew/show/P3380)\n\n~~\uff08\u636e\u8bf4splay\u5e38\u6570\u6bd4treap\u5927\u5f88\u591a\u4f46\u662f\u8fd8\u662f\u7528\u4e86splay\uff09~~\n\n\u6811\u5957\u6811\uff0c\u5c31\u662f\u5c06\u4e24\u79cd\u6811\u72b6\u7ed3\u6784\u5957\u8d77\u6765\u4f7f\u7528\uff0c\u5916\u5c42\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u5bf9\u5e94\u7740\u4e00\u68f5\u5185\u5c42\u6811\u3002\u5728\u8fd9\u9053\u9898\u4e2d\uff0c\u6211\u4eec\u9009\u62e9\u4f7f\u7528\u7ebf\u6bb5\u6811\u5957\u5e73\u8861\u6811\u7684\u65b9\u6cd5\u3002\n\nps\uff1a\u4e0b\u6587\u4e2d\uff0c\u5f53\u67e5\u8be2\u4e00\u4e2a\u533a\u95f4\u65f6\uff0c\u5c06\u7ebf\u6bb5\u6811\u4e0a\u53ef\u4ee5\u5bf9\u7b54\u6848\u4ea7\u751f\u8d21\u732e\u7684\u8282\u70b9\u6240\u5bf9\u5e94\u7684\u5e73\u8861\u6811\u79f0\u4e3a\u6709\u6548\u6811\u3002\n\n1.\u67e5\u8be2k\u7684\u6392\u540d\uff1a\n\u6bcf\u68f5\u6709\u6548\u6811\u4e2d\u6bd4k\u5c0f\u7684\u6570\u7684\u4e2a\u6570\u603b\u548c+1\uff1b\n\n2.\u67e5\u8be2\u6392\u540d\u4e3ak\u7684\u6570\uff1a\n\u4e8c\u5206\u6570\u5b57\uff0c\u67e5\u627e (\u533a\u95f4\u4e2d$\\le x$\u7684\u6570\u7684\u4e2a\u6570) $\\ge$k\u7684\u6700\u5c0f\u7684$x$\uff1b\n\n3.\u4fee\u6539\u503c\uff1a\n\u5bf9\u4e8e\u6bcf\u68f5\u5305\u542bpos\u7684\u6811\uff0c\u5220\u9664\u539f\u503c\u5e76\u52a0\u5165\u65b0\u503c\uff08\u6709\u4e9b\u66b4\u529b\uff09\uff1b\n\n4.\u67e5\u627e\u524d\u9a71\uff1a\n\u6bcf\u68f5\u6709\u6548\u6811\u4e2d\u7684\u524d\u9a71\u7684\u6700\u5927\u503c\u3002\u524d\u9a71\u6c42\u6cd5\uff1a\u63d2\u5165k\u5e76splay\u5230\u6839\uff0c\u67e5\u627ek\u7684\u5de6\u5b50\u6811\u4e2d\u7684\u6700\u5927\u503c\uff1b\n\n5.\u540c\u4e0a\u3002\n\n\u6ce8\u610f\uff1a\u9700\u8981\u7528\u4e00\u4e2a\u56de\u6536\u6808\u4fdd\u5b58\u5220\u9664\u7684\u8282\u70b9\u7f16\u53f7\uff0c\u56de\u6536\u540e\u91cd\u590d\u5229\u7528\u8282\u70b9\uff0c\u5426\u5219\u4f1aMLE\uff1b\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n\nint fa[2000001],ch[2000001][2],root[800001],size[2000001],num[2000001],sta[2000001],top,now,n,m,opt,l,r,k,x[100001];\nint val[2000001];\nbool no;\nvoid printtree(int x){\n\tif(!x)return;\n\tprintf(\"%d\\t%d\\t%d\\t%d\\t\\t%d\\t%d\\t%d\\t\\n\",x,fa[x],ch[x][0],ch[x][1],val[x],size[x],num[x]);\n\tprinttree(ch[x][0]);\n\tprinttree(ch[x][1]);\n}\nvoid debug(int ro,int l,int r){\n\tno=!no;\n\tprintf(\"root:%d domain:(%d,%d)\\n num\\tfather\\tleftson\\trightson\\tvalue\\tsize\\tnum\\t\\n\",ro,l,r);\n\tprinttree(root[ro]);\n\tif(l==r)return;\n\tdebug(ro<<1,l,(l+r)/2);\n\tdebug(ro<<1|1,(l+r)/2+1,r);\n\tif(ro==1)printf(\"-------------------------------------------------------------------------------------------------------\\n\");\n}\n\nbool son(int x){return ch[fa[x]][1]==x;}\nvoid pushup(int x){size[x]=size[ch[x][0]]+size[ch[x][1]]+num[x];}\nint New(){\n\tif(now<9999990)return ++now;\n\treturn sta[top--];\n}\nvoid Rotate(int x,int r){\n\tif(!x||!fa[x])return;\n\tint faz=fa[x],fazz=fa[faz],g=son(x);\n\tif(faz==root[r])root[r]=x;\n\tfa[x]=fazz;\n\tch[fazz][son(faz)]=x;\n\tfa[ch[x][!g]]=faz;\n\tch[faz][g]=ch[x][!g];\n\tch[x][!g]=faz;\n\tfa[faz]=x;\n\tpushup(faz),pushup(x);\n}\nvoid splay(int x,int r,int ance){\n\twhile(fa[x]!=ance){\n\t\tif(fa[fa[x]]!=ance){\n\t\t\tif(son(x)^son(fa[x]))Rotate(x,r);\n\t\t\telse Rotate(fa[x],r);\n\t\t}\n\t\tRotate(x,r);\n\t}\n}\nint find(int x,int r,int inc){\n\tint u=root[r],last;\n\tfor(;u;){\n\t\tlast=u;\n\t\tsize[u]+=inc;\n\t\tif(val[u]==x)return u;\n\t\tif(val[u]>x)u=ch[u][0];\n\t\telse u=ch[u][1];\n\t}\n\treturn last;\n}\nvoid insert(int x,int r){\n\tif(!root[r]){\n\t\troot[r]=New();\n\t\tval[root[r]]=x;\n\t\tsize[root[r]]=num[root[r]]=1;\n\t\treturn;\n\t}\n\tint u=find(x,r,1);\n\tif(val[u]==x)num[u]++,splay(u,r,0);\n\telse{\n\t\tint tem=New();\n\t\tfa[tem]=u;\n\t\tif(val[u]<x)ch[u][1]=tem;\n\t\telse ch[u][0]=tem;\n\t\tval[tem]=x;\n\t\tsize[tem]=num[tem]=1;\n\t\tsplay(tem,r,0);\n\t}\n}\nvoid erase(int x,int r){\n\tint u=find(x,r,-1);\n\tnum[u]--;\n\tif(!num[u]){\n\t\tsplay(u,r,0);\n\t\tif(ch[u][1]){\n\t\t\tint tem=ch[u][1];\n\t\t\twhile(ch[tem][0])tem=ch[tem][0];\n\t\t\tsplay(tem,r,u);\n\t\t\tfa[ch[u][1]]=0;\n\t\t\tfa[ch[u][0]]=ch[u][1];\n\t\t\tpushup(ch[u][1]);\n\t\t\troot[r]=ch[u][1];\n\t\t\tch[ch[u][1]][0]=ch[u][0];\n\t\t}\n\t\telse fa[ch[u][0]]=0,root[r]=ch[u][0];\n\t\tsta[++top]=u;\n\t\tnum[u]=size[u]=val[u]=ch[u][0]=ch[u][1]=0;\n\t}\n//\tprintf(\"erase %d %d\\n\",x,r);\n}\nint rank(int x,int r){\n\tint tem=root[r],ans=0;\n\twhile(val[tem]!=x&&tem){\n\t\tif(val[tem]<x)ans+=size[ch[tem][0]]+num[tem],tem=ch[tem][1];\n\t\telse tem=ch[tem][0];\n\t}\n\tif(tem)ans+=size[ch[tem][0]],splay(tem,r,0);\n\treturn ans;\n}\nint find(int root,int l,int r,int el,int er,int k){\n\tif(el>r||er<l)return 0;\n\tif(el<=l&&er>=r){\n\t\treturn rank(k,root);\n\t}\n\treturn find(root<<1,l,(l+r)/2,el,er,k)+find(root<<1|1,(l+r)/2+1,r,el,er,k);\n}\nvoid add(int root,int l,int r,int e,int k){\n\tif(l>e||r<e)return;\n\tinsert(k,root);\n\tif(l==r)return;\n\tadd(root<<1,l,(l+r)/2,e,k);\n\tadd(root<<1|1,(l+r)/2+1,r,e,k);\n}\nvoid del(int root,int l,int r,int e,int k){\n\tif(l>e||r<e)return;\n\terase(k,root);\n\tif(l==r)return;\n\tdel(root<<1,l,(l+r)/2,e,k);\n\tdel(root<<1|1,(l+r)/2+1,r,e,k);\n}\nint max(int a,int b){return a>b?a:b;}\nint maximum(int ro,int l,int r,int el,int er,int k){\n\tif(el>r||er<l)return -1;\n\tif(el<=l&&er>=r){\n\t\tinsert(k,ro);\n\t\tint tem=root[ro];\n\t\tif(!ch[tem][0]){\n\t\t\terase(k,ro);\n\t\t\treturn -1;\n\t\t}\n\t\ttem=ch[tem][0];\n\t\twhile(ch[tem][1])tem=ch[tem][1];\n\t\terase(k,ro);\n\t\treturn val[tem];\n\t}\n\treturn max(maximum(ro<<1,l,(l+r)/2,el,er,k),maximum(ro<<1|1,(l+r)/2+1,r,el,er,k));\n}\nint min(int a,int b){return a<b?a:b;}\nint minimum(int ro,int l,int r,int el,int er,int k){\n\tif(el>r||er<l)return 1e8+1;\n\tif(el<=l&&er>=r){\n\t\tinsert(k,ro);\n\t\tint tem=root[ro];\n\t\tif(!ch[tem][1]){\n\t\t\terase(k,ro);\n\t\t\treturn 1e8+1;\n\t\t}\n\t\ttem=ch[tem][1];\n\t\twhile(ch[tem][0])tem=ch[tem][0];\n\t\terase(k,ro);\n\t\treturn val[tem];\n\t}\n\treturn min(minimum(ro<<1,l,(l+r)/2,el,er,k),minimum(ro<<1|1,(l+r)/2+1,r,el,er,k));\n}\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')ch=getchar();\n\twhile(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nint main(){\n//\tfreopen(\"33801.in\",\"r\",stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n\tn=read(),m=read();\n\tfor(register int i=1;i<=n;i++)add(1,1,n,i,x[i]=read());//,debug(1,1,n);\n\tfor(register int i=1;i<=m;i++){\n\t\topt=read();\n\t\tif(opt==1){\n\t\t\tl=read(),r=read(),k=read();\n//\t\t\tprintf(\"%d %d %d %d\\n\",opt,l,r,k);\n\t\t\tprintf(\"%d\\n\",find(1,1,n,l,r,k)+1);\n\t\t}\n\t\telse if(opt==2){\n\t\t\tl=read(),r=read(),k=read();\n//\t\t\tprintf(\"%d %d %d %d\\n\",opt,l,r,k);\n\t\t\tint el=0,er=1e8,mid,ans;\n\t\t\twhile(el<=er){\n\t\t\t\tmid=(el+er)/2;\n\t\t\t\tif(find(1,1,n,l,r,mid+1)>=k){\n\t\t\t\t\tans=mid;\n\t\t\t\t\ter=mid-1;\n\t\t\t\t}\n\t\t\t\telse el=mid+1;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\telse if(opt==3){\n\t\t\tl=read(),k=read();\n//\t\t\tprintf(\"%d %d %d %d\\n\",opt,l,r,k);\n\t\t\tdel(1,1,n,l,x[l]);\n\t\t\tadd(1,1,n,l,k);\n\t\t\tx[l]=k;\n\t\t}\n\t\telse if(opt==4){\n\t\t\tl=read(),r=read(),k=read();\n//\t\t\tprintf(\"%d %d %d %d\\n\",opt,l,r,k);\n\t\t\tint tem=maximum(1,1,n,l,r,k);\n\t\t\tif(tem==-1)printf(\"-2147483647\\n\");\n\t\t\telse printf(\"%d\\n\",tem);\n\t\t}\n\t\telse if(opt==5){\n\t\t\tl=read(),r=read(),k=read();\n//\t\t\tprintf(\"%d %d %d %d\\n\",opt,l,r,k);\n\t\t\tint tem=minimum(1,1,n,l,r,k);\n\t\t\tif(tem==1e8+1)printf(\"2147483647\\n\");\n\t\t\telse printf(\"%d\\n\",tem);\n\t\t}\n//\t\tdebug(1,1,n);\n\t}\n}\n```",
        "postTime": 1534933823,
        "uid": 30903,
        "name": "Isonan",
        "ccfLevel": 0,
        "title": "luoguP3380 \u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09"
    },
    {
        "content": "22 WA/TLE\n\n1 AC\n\u8bba\u4e00\u4e2a\u6811\u5957\u6811\u7684\u6210\u957f\u5386\u7a0b......\n\n\u6c42\u6211\u7684\u5fc3\u91cc\u9634\u5f71\u9762\u79ef........\n\n\n**\u601d\u8def**\uff1a\u663e\u7136\u7684\u533a\u95f4\u64cd\u4f5c+\u5e73\u8861\u6811\u64cd\u4f5c\u3002\u5916\u5c42\u6811\u72b6\u6570\u7ec4\uff0c\u5185\u5c42treap\u53ef\u4ee5\u64e6\u8fb9AC..\n\n\u7136\u800c\u4e00\u5f00\u59cb\u5199\u7684zkw\u5957\u66ff\u7f6a\u7f8a\u5b8c\u7f8eTLE\\*3\uff0c\u672c\u4ee5\u4e3a\u662f\u52a8\u6001\u5f00\u70b9\u7684\u8fc7\uff0c\u5199\u4e86\u5185\u5b58\u6c60\u4ecd\u7136TLE\u3002\n\n\u540e\u6765\u624d\u60f3\u8d77\u6765\u5efa\u6811\u65f6\u5e94\u8be5\u79bb\u7ebf\uff0c\u7528\u5408\u5e76\u5efa\u6811\u3002\u3002\u7136\u800c\u66ff\u7f6a\u7f8a\u505a\u4e0d\u5230\uff0c\u7136\u800ctreap\u4e5f\u505a\u4e0d\u5230\u3002\u3002\u7136\u800c\u53c8\u4e0d\u4f1a\u5199splay\u3002\u3002\u3002\n\n\u4e8e\u662f\u5c31\u5237\u6ee1\u4e86\u4e00\u9875TLE......\n\nOrz\u4e00\u53d1\u697c\u4e0b\u4f1a\u82e5\u5e72\u79cd\u89e3\u6cd5\u7684\u7287\uff0cOrz\u4f1asplay\u7684\u7287\u3002\u3002\u3002\n\n\n\u5c0ftips\uff1a\n\n1. \u5e73\u8861\u4e8c\u53c9\u6811\u53ea\u9700\u8981\u652f\u6301push\u3001pop\u548cnumber\\_less\u5c31\u53ef\u4ee5\u652f\u6301\u6240\u6709\u529f\u80fd\u4e86\u3002\u3002\u5e76\u4e0d\u7528\u5199\u90a3\u4e48\u591a\u3002\u3002\n\n2. \u4e09\u76ee\u8fd0\u7b97\u7b26\u7684\u4f18\u5148\u7ea7\u95ee\u9898\uff01\n\n3. \u7ed9\u81ea\u5df1\u5199\u4e00\u4e2a\u597d\u770b\u7684\u904d\u5386\u6811\u7684\u51fd\u6570\uff0c\u9632\u6b62\u8c03\u8bd5\u7684\u65f6\u5019\u53d1\u75af\uff08\u6781\u5176\u91cd\u8981\uff09\u3002\u3002\n\n",
        "postTime": 1481430006,
        "uid": 12511,
        "name": "ljt12138",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3380 \u3010\u3010\u6a21\u677f\u3011\u4e8c\u903c\u5e73\u8861\u6811\uff08\u6811\u5957\u6811\uff09\u3011"
    }
]