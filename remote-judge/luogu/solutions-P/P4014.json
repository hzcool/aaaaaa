[
    {
        "content": "\u975e\u5e38\u88f8\u7684\u4e8c\u5206\u56fe\u6700\u4f73\u5b8c\u7f8e\u5339\u914d\u3002\n\n\u6211\u4eec\u628a\u4eba\u653e\u4e00\u8fb9\uff0c\u5de5\u4f5c\u653e\u4e00\u8fb9\uff0c\u6548\u7387\u5c31\u662f\u8fb9\u6743\uff0c\u7136\u540e\u6c42\u4e00\u4e2a**\u6743\u503c\u548c**\u6700\u5927\u548c\uff08\u6216\uff09\u6700\u5c0f\u7684\u5b8c\u7f8e\u5339\u914d\u3002\n\n\u81f3\u4e8e\u4e8c\u5206\u56fe\u6700\u4f73\u5b8c\u7f8e\u5339\u914d\u7684\u6c42\u6cd5\uff0c\u6211\u5728\u8fd9\u91cc\u53ea\u7b80\u5355\u8bf4\u4e00\u4e0b\uff0c\u5177\u4f53\u7684\u53ef\u4ee5\u81ea\u627e\u8d44\u6599\u5b66\u4e60\u3002\n\n\u9996\u5148\uff0c\u4ecb\u7ecd\u4e00\u4e2a\u91cd\u8981\u7684\u5b9a\u7406\uff1a\n\n\u6211\u4eec\u5b9a\u4e49**\u9876\u6807**\uff1a\n\nlx[i],ly[j],i\u2208\u5de6\u8fb9\uff0cj\u2208\u53f3\u8fb9\uff0c\u5e76\u4e14\u5bf9\u4e8e\u4efb\u610fw[i][j],\u90fd\u6709lx[i]+ly[j]>=w[i][j]\uff1b\n\n\u6211\u4eec\u518d\u4ece\u539f\u56fe\u4e2d\u62bd\u51falx[i]+ly[j]=w[i][j]\u7684\u8fb9\u5efa\u7acb\u4e00\u4e2a**\u76f8\u7b49\u5b50\u56fe**\uff0c\u5982\u679c\u76f8\u7b49\u5b50\u56fe\u6709**\u5b8c\u7f8e\u5339\u914d**\uff08\u5c31\u662f\u65e0\u8fb9\u6743\uff0c\u5168\u5339\u914d\u7684\u90a3\u4e2a\uff09\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5b8c\u7f8e\u5339\u914d\u5c31\u662f\u539f\u56fe\u7684**\u6700\u4f73\u5b8c\u7f8e\u5339\u914d**\u3002\n\n\u8fd9\u4e2a\u5b9a\u7406\u7684\u8bc1\u660e\u4e5f\u5341\u5206\u7b80\u5355\uff0c\u8fd9\u91cc\u6211\u5c31\u4e0d\u8bc1\u660e\u4e86\uff0c\u6709\u5174\u8da3\u7684\u53ef\u4ee5\u81ea\u884c\u767e\u5ea6\u3002\n\n\u6709\u4e86\u8fd9\u4e2a\u5b9a\u7406\u6211\u4eec\u5c31\u53ef\u4ee5\u7528KM(\u5308\u7259\u5229\u7b97\u6cd5)\u6c42\u89e3\u6b64\u9898\u4e86\u3002\n\n\u5177\u4f53\u7684\u65b9\u6cd5\u5c31\u662f\uff0c\u4e0d\u65ad\u7684\u4fee\u6539\u9876\u6807\u8ba9\u5b83\u6709\u4e00\u4e2a\u5408\u9002\u7684\u503c\uff0c\u4f7f\u5f97\u76f8\u7b49\u5b50\u56fe\u6709\u5b8c\u7f8e\u5339\u914d\u3002\u5b9e\u73b0\u8d77\u6765\u5c31\u662f\u5148\u5f00\u5fc3\u5730\u8bbe\u4e00\u4e2a\u9876\u6807\u521d\u503c\uff08\u4e00\u822c\u662fly=0,lx=max(w[i][j])\uff09\uff0c\u7136\u540e\u5f00\u59cbKM\uff0c\u5982\u679c\u627e\u5230\u4e86\u4e00\u6761\u589e\u5e7f\u8def\uff0c\u5c31\u627e\u5230\u4e86\u5427\uff1b\u5982\u679c\u6ca1\u6709\uff0c\u90a3\u5b83\u4e00\u5b9a\u662f\u5c1d\u8bd5\u8bbf\u95ee\u4e86\u4e00\u4e9b\u5de6\u8fb9\u7684\u70b9\uff08\u6bd4\u5982q\u4e2a\uff09\u6211\u4eec\u628a\u5b83\u4eec\u52a0\u5165**S**,\u7136\u540e\u8bbf\u95ee\u4e86q-1\u4e2a\u53f3\u8fb9\u7684\u70b9,\u6211\u4eec\u628a\u5b83\u4eec\u52a0\u5165**T**\uff08S,T\u662f\u4e24\u4e2a\u96c6\u5408\uff09\u3002\n\n\u7136\u540e\u628alx[i],i\u2208S\u90fd\u51cf\u53bb\u4e00\u4e2a**\u677e\u5f1b\u91cfa**\uff0cly[j],j\u2208T\uff0c\u90fd\u52a0\u4e0a\u4e00\u4e2aa\uff0c\u8fd9\u6837\u5c31\u4f1a\u6709\u4e00\u4e9b\u4e0d\u5728T\u4e2d\u7684\u70b9\u548c\u5728S\u4e2d\u7684\u70b9\u4e4b\u95f4\u7684\u8fb9\u80fd\u591f\u8fdb\u5165\u76f8\u7b49\u5b50\u56fe\uff0c\u540c\u65f6\u5df2\u7ecf\u5728\u76f8\u7b49\u5b50\u56fe\u91cc\u7684\u8fb9\u4e0d\u51fa\u53bb\uff0c\u7ee7\u7eed\u8fdb\u884cKM\u76f4\u5230\u5339\u914d\u4e86\u8fd9\u4e2a\u70b9\u4e3a\u6b62\u3002\n\n\u81f3\u4e8e\u627ea\u7684\u65b9\u6cd5\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u8fdb\u6765\u7684\u8fb9\u662f\u80fd\u8fdb\u6765\u7684\u4e4b\u4e2d\u6700\u5927\u7684\uff0c\u540c\u65f6\u53c8\u6709\u8fb9\u8fdb\u6765\uff0c\n\na=min{lx[i]+ly[j]-w[i][j]|i\u2208S\uff0cj\u2209T}\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u5c31n^2\u66b4\u529b\u679a\u4e3e\u5c31\u597d\u4e86\uff0c\u56e0\u6b64\u6574\u4e2a\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u4e3an^4\uff0c\u5f53\u7136\u8fd8\u6709\u4e00\u4e2an^3\u7684\u4f18\u5316\u65b9\u6cd5\uff0c\u4e0d\u8fc7n^4\u5c31\u80fd0ms\u79d2\u6740\u6b64\u9898\uff0c\u6240\u4ee5\u8fd9\u91cc\u5c31\u4e0d\u7528\u4e86\u3002\n\n\u8fd9\u91cc\u8bb2\u7684\u5e76\u4e0d\u662f\u5f88\u6df1\uff0c\u6709\u4e9b\u6982\u5ff5\u6ca1\u6709\u6d89\u53ca\uff0c\u5efa\u8bae\u5927\u5bb6\u6700\u597d\u8fd8\u662f\u4e0a\u7f51\u67e5\u4e9b\u8d44\u6599\u597d\u597d\u5b66\u4e00\u4e0b\u3002\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\~\u6211\u662f\u5206\u5272\u7ebf~////////////////////\n\n\u4e0a\u9762\u662f\u6c42\u7684\u6700\u5927\u503c\uff0c\u600e\u4e48\u6c42\u6700\u5c0f\u503c\u5462\uff1f\n\n\u628a\u8fb9\u6743\u6574\u4f53\u53d6\u8d1f\u554a\u3002\n\n\u6700\u7ec8\u7b54\u6848\u561b\uff1a\u6839\u636e\u76f8\u7b49\u5b50\u56fe\u7684\u5b9a\u4e49\u5c31\u662f\u9876\u6807\u548c\u4e86\u3002\n\n\u6700\u540e\u8d34\u4ee3\u7801\uff0c\u518d\u4e0d\u6d4e\u53ea\u80fd\u770b\u4ee3\u7801\u4e86\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n#include<queue>\n#include<map>\n#include<vector>\n#include<ctime>\n\n#define ll long long\n#define R register\n#define IL inline\n#define Rf(a,b,c) for(R int (a)=(b);(a)<=(c);++(a))\n#define Tf(a,b,c) for(R int (a)=(b);(a)>=(c);--(a))\n#define MP make_pair\n#define PA pair<int,int>\n#define MES(a,b) memset((a),(b),sizeof((a)))\n#define MEC(a,b) memset((a),(b),sizeof((b)))\n#define D double\n\nusing namespace std;\n\nconst int N=505;\n\nint n,m,lx[N],ly[N],link[N],w[N][N];\nbool S[N],T[N];\n\nIL int read() {\n    int x=0,f=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x*=10;x+=(ch-'0');ch=getchar();}\n    return x*f;\n}\nIL void write(int x) {\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\n\nbool dfs(int x) {//\u8fd9\u5c31\u662f\u4e00\u822c\u7684\u4e8c\u5206\u56fe\u5339\u914d\n    S[x]=true;//\u628a\u5de6\u8fb9\u7684\u70b9\u90fd\u52a0\u5165S\n    Rf(i,1,n) \n    if(lx[x]+ly[i]==w[x][i]&&!T[i]) {//\u5224\u65ad\u8fd9\u6761\u8fb9\u662f\u5426\u5728\u76f8\u7b49\u5b50\u56fe\u91cc\uff0c\u4e0d\u8981\u518d\u5efa\u56fe\u4e86\n        T[i]=true;//\u53f3\u8fb9\u7684\u70b9\u52a0\u5165T\n        if(!link[i]||dfs(link[i])) {\n            link[i]=x;\n            return true;\n        }\n    }\n    return false;\n}\n\nIL void update() {//n^2\u66b4\u529b\u627ea\uff0c\u5e76\u4fee\u6539\n    R int a=1<<30;\n    Rf(i,1,n) if(S[i]) \n        Rf(j,1,n) if(!T[j]) \n            a=min(a,lx[i]+ly[j]-w[i][j]); \n    Rf(i,1,n) {\n        if(S[i]) lx[i]-=a;\n        if(T[i]) ly[i]+=a;\n    }\n}\n\nIL void KM() {\n    Rf(i,1,n) {\n        link[i]=lx[i]=ly[i]=0;\n        Rf(j,1,n) lx[i]=max(lx[i],w[i][j]);//\u9876\u6807\u521d\u503c\n    }\n    Rf(i,1,n) while(true) {\n        Rf(j,1,n) S[j]=T[j]=false;//\u8bb0\u5f97\u6bcf\u6b21\u90fd\u8981\u6e05\u7a7a\n        if(dfs(i)) break;//\u627e\u5230\u589e\u5e7f\u8def\u4e86\n        else update();//\u6ca1\u627e\u5230\u5c31\u5f97\u677e\u5f1b\u4e86\n    }\n} \n\n\nsigned main()\n{\n    n=read();\n    Rf(i,1,n) Rf(j,1,n) w[i][j]=read();\n    KM();\n    int sum1=0,sum2=0;\n    Rf(i,1,n) sum1+=lx[i]+ly[i];//\u6700\u540e\u7684\u9876\u6807\u548c\u5c31\u662f\u6700\u7ec8\u7b54\u6848\u4e86\n    Rf(i,1,n) Rf(j,1,n) w[i][j]*=-1;//\u6574\u4f53\u53d6\u8d1f\u8dd1\u6700\u5c0f\n    KM();\n    Rf(i,1,n) sum2+=lx[i]+ly[i];\n    write(-sum2);//\u8bb0\u5f97\u8981\u628a\u7b54\u6848\u518d\u53d6\u8d1f\u56de\u6765\u554a\n    putchar('\\n');write(sum1);\n    \n    return 0;\n}\n```",
        "postTime": 1514336203,
        "uid": 35700,
        "name": "Khassar",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u6302\u4e2a\u535a\u5ba2[Youngsc](https://youngscc.github.io/)\n\n\n**\u9996\u5148\u819c\u62dc\u697c\u4e0b\u673a\u623f\u5de8\u4f6c%%%KM\u4e8c\u5206\u56fe\u6700\u4f73\u5b8c\u7f8e\u5339\u914d**\n\n**\u849f\u84bb\u53ea\u60f3\u8bf4\u6211\u6839\u672c\u4e0d\u77e5\u9053\u548b\u6c42\u9876\u6807\uff0c\u597d\u5728\u672c\u849f\u84bb\u4f1a~~\u8d39\u7528\u6d41~~**\n\n**\u5173\u4e8e\u4e8c\u5206\u56fe\u6700\u4f73\u5b8c\u7f8e\u5339\u914d\u95ee\u9898\uff0c\u5c31\u662f\u8ba9\u4e8c\u5206\u56fe\u5e26\u4e0a\u8fb9\u6743\uff0c\u7136\u540e\u8ba9\u9009\u51fa\u6765\u7684\u5b8c\u7f8e\u5339\u914d\u6743\u503c\u4e4b\u548c\u6700\u5927**\n\n**\u8d39\u7528\u6d41\u7684\u8bdd\u5f88\u7b80\u5355\uff0c\u5148\u5efa\u4e00\u4e2a\u8d85\u7ea7\u6e90\u8d85\u7ea7\u6c47**\n\n**\u7136\u540e\u4ece\u8d85\u7ea7\u6e90\u60f3\u6bcf\u4e00\u4e2a\u4eba\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0\u7684\u5f27**\n\n**\u540c\u6837\u7684\uff0c\u4ece\u6bcf\u4e00\u4e2a\u4efb\u52a1\u5411\u8d85\u7ea7\u6c47\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0\u7684\u5f27**\n\n**\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4eba\u548c\u6bcf\u4e00\u4e2a\u4efb\u52a1\uff0c\u5bf9\u5e94\u7684\u4ece\u4eba\u5411\u4efb\u52a1\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a$C_{i,j}$\u7684\u5f27**\n\n**\u4ee5\u4e0a\u5404\u5f27\u5bb9\u91cf\u4e3a1\u662f\u4e3a\u4e86\u9632\u6b62\u4e00\u4e2a\u70b9\u88ab\u591a\u6b21\u5339\u914d**\n\n**\u7136\u540e\u8dd1\u4e00\u4e2a\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u548c\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u5b8c\u7f8e\u7684\u89e3\u51b3\u4e86**\n\n\n**\u6ce8\u610f\u9898\u9762\u91cc\u5e76\u6ca1\u6709\u8bf4$C_{i,j}$\u662f\u6b63\u6574\u6570\uff0c\u6240\u4ee5\u53ef\u80fd\u4f1a\u6709\u8d1f\u503c**\n\n\n### \u4ee3\u7801\u5982\u4e0b\n\n\n```cpp\n# include <bits/stdc++.h>\n# define R register\n# define LL long long\n# define inf 2147483647\n\nusing namespace std;\n\nint n,s,t,ans,fr[210],h[210],flo[210],e=-1,dis[210],pre[210],x;\nbool v[210];\n\nqueue <int> q;\n\nstruct zx{int v,flow,w,pre;} ed[50010];\n\ntemplate <typename T> inline void in(R T& a){\n    R char c=getchar();R T x=0,f=1;\n    while(!isdigit(c)) (c=='-'? f=-1:0),c=getchar();\n    while(isdigit(c)) x=(x<<1)+(x<<3)+c-'0',c=getchar();\n    a=x*f;\n}\n\ninline void add(R int x,R int y,R int z,R int w){\n    ed[++e] = (zx){y,z,w,h[x]};\n    h[x] = e;\n}\n\ninline bool bfs_max(){\n    for(R int i=s; i<=t; ++i) dis[i] = -inf/3;\n    dis[s] = 0,flo[s] = inf;\n    q.push(s);\n    while(!q.empty()){\n        R int x=q.front();\n        q.pop();\n        for(R int i=h[x]; i!=-1; i=ed[i].pre){\n            R int p=ed[i].v;\n            if(dis[p] < dis[x] + ed[i].w&&ed[i].flow){\n                dis[p] = dis[x] + ed[i].w;\n                if(!v[p]) v[p] = 1,q.push(p);\n                flo[p] = min(ed[i].flow,flo[x]);\n                pre[p] = i;\n                fr[p] = x;\n            }\n        }\n        v[x] = 0;\n    }\n    return dis[t] > -inf/3;;\n}\n\ninline bool bfs_min(){\n    for(R int i=s; i<=t; ++i) dis[i] = inf/3;\n    dis[s] = 0,flo[s] = inf;\n    q.push(s);\n    while(!q.empty()){\n        R int x=q.front();\n        q.pop();\n        for(R int i=h[x]; i!=-1; i=ed[i].pre){\n            R int p=ed[i].v;\n            if(dis[p] > dis[x] + ed[i].w&&ed[i].flow){\n                dis[p] = dis[x] + ed[i].w;\n                if(!v[p]) v[p] = 1,q.push(p);\n                flo[p] = min(ed[i].flow,flo[x]);\n                pre[p] = i;\n                fr[p] = x;\n            }\n        }\n        v[x] = 0;\n    }\n    return dis[t] < inf/3;\n}\n\nint main(){\n    // freopen(\"home.in\",\"r\",stdin);\n    // freopen(\"home.out\",\"w\",stdout);\n    in(n);\n    memset(h,-1,sizeof(h));\n    for(R int i=1; i<=n; ++i)\n        for(R int j=1; j<=n; ++j)\n            in(x),add(i,j+n,1,x),add(j+n,i,0,-x);\n    s=0,t=n+n+1;\n    for(R int i=1; i<=n; ++i) add(s,i,1,0),add(i,s,0,0),add(i+n,t,1,0),add(t,i+n,0,0);\n    while(bfs_min()){\n        ans += dis[t]*flo[t];\n        R int now = t;\n        while(now != s){\n            ed[pre[now]].flow -= flo[t];\n            ed[pre[now]^1].flow += flo[t];\n            now = fr[now];\n        }\n    }\n    printf(\"%d\\n\",ans);\n    for(R int i=0; i<=e; i+=2) ed[i].flow += ed[i^1].flow,ed[i^1].flow = 0;\n    ans = 0;\n    while(bfs_max()){\n        ans += dis[t]*flo[t];\n        R int now = t;\n        while(now != s){\n            ed[pre[now]].flow -= flo[t];\n            ed[pre[now]^1].flow += flo[t];\n            now = fr[now];\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n```",
        "postTime": 1514376432,
        "uid": 36282,
        "name": "Youngsc",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "### \u8fd9\u662fGD\u521d\u4e8c\u849f\u84bb $lolte$ \u7684\u9898\u89e3\n\n\u5199\u4e86\u4e00\u5468\u591a\u7684\u6700\u5927\u6d41\uff0c\u73b0\u5728\u6362\u6210\u8d39\u7528\u6d41\u7684\u9898\u6765\u7ec3\u7ec3\u624b\u3002\n\n\u7531\u4e8e\u6211\u592a\u5f31\u4e86\uff0c\u4e0d\u4f1aKM/EK/zkw/PD\uff0c\u6240\u4ee5\u53ea\u80fd\u7528 $dinic$ \u4e86\u3002\n\n------\n\n\u8fd9\u9898\u8bf4\u5b9e\u8bdd\u5f88\u88f8\uff0c\u63a5\u8fd1\u4e8e\u6a21\u677f\u4e86~~\uff08\u90a3\u6211\u5728\u4f5c\u751a\uff09~~\n\n\u8d39\u7528\u6d41\u6a21\u677f\u7684\u5b9e\u73b0\u6211\u5c31\u4e0d\u8bb2\u4e86\uff0c\u4e3b\u8981\u8bb2\u4e00\u4e0b\u5efa\u56fe\u3002\n\n---\n### \u5148\u6765\u505a\u6700\u5c0f\u503c\n\n\u7531\u9898\u53ef\u77e5\uff0c\u672c\u9898\u53ef\u62bd\u8c61\u6210\u4e00\u4e2a\u4e8c\u5206\u56fe\uff0c\u4e24\u8fb9\u5206\u522b\u662f\u4eba\u548c\u5de5\u4ef6\u3002\n\n\u9ed8\u8ba4**\u5bb9\u91cf\u4e3a1**\uff08\u56e0\u4e3a\u6bcf\u4eba\u53ea\u80fd\u4fee\u4e00\u4e2a\u5de5\u4ef6\uff09\n\n\u5bf9\u9898\u76ee\u4e2d\u7684 $c_{ij}$ \uff0c\u8003\u8651\u5c06\u4eba\u548c\u5de5\u4f5c\u8fde\u4e00\u6761**\u8d39\u7528\u4e3a $c_{ij}$ **\u7684\u8fb9\u3002\n\n\u7531\u4e8e\u6bcf\u4eba\u53ea\u80fd\u4fee\u4e00\u4e2a\u5de5\u4ef6\uff0c\u6240\u4ee5\u5c06\u6e90\u70b9\u4e0e\u4eba\u8fde\u4e00\u6761**\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0**\u7684\u8fb9\n\n\u4e4b\u540e\u518d\u5c06\u6bcf\u4e2a\u5de5\u4ef6\u548c\u6c47\u70b9\u8fde\u4e00\u6761**\u8d39\u7528\u4e3a0**\u7684\u8fb9\u3002\n\n\u8dd1\u4e00\u904d\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\u6c42\u51fa\u6700\u5c0f\u503c\u3002\n\n---\n\n### \u7b2c\u4e8c\u4e2a\u95ee\u9898\u6765\u4e86\uff0c\u6700\u5927\u503c\u600e\u4e48\u505a\uff1f\n\n\u8fd9\u4e2a\u95ee\u9898\u5f88\u7b80\u5355\u5566\n\n\u53ea\u9700\u5c06\u539f\u6765\u6240\u6709\u8fb9\u7684**\u8d39\u7528**\u53d8\u4e3a**\u76f8\u53cd\u6570**\uff0c\u8dd1\u4e00\u904d\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u5c31\u53ef\u6c42\u51fa**\u6700\u5927\u503c\u7684\u76f8\u53cd\u6570**\u3002\u8f93\u51fa\u65f6\u518d\u5c06\u5b83\u53d6**\u76f8\u53cd**\u5c31\u597d\u5566\u3002\n\n---\n\n\u6700\u540e\u662f\u4ee3\u7801\u3002\n\n\u6211\u7528\u7684\u662f $dinic$ , 37ms(\u65e0O2)\uff0c35ms(O2)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=150,inf=214784360;\nint n,head[maxn*2],dist[maxn*2];\nint q[maxn*100],l,r,cnt=1,s,t,maxflow=0,mincost=0;\nint x[maxn][maxn];\nbool vis[maxn*2];\nstruct node{\n    int to,nxt,w,cost;\n}e[maxn*maxn*2];\ninline void add(int u,int v,int w,int c) {\n    ++cnt;\n    e[cnt].to=v;e[cnt].w=w;e[cnt].cost=c;e[cnt].nxt=head[u];head[u]=cnt;\n    ++cnt;\n    e[cnt].to=u;e[cnt].w=0;e[cnt].cost=-c;e[cnt].nxt=head[v];head[v]=cnt;\n}\nbool spfa(){\n    memset(vis,0,sizeof(vis));\n    memset(dist,0x3f,sizeof(dist));\n    l=1;r=0;\n    q[++r]=s; dist[s]=0; vis[s]=1;\n    while (l<=r) {\n        int u=q[l++];\n        vis[u]=0;\n        for (int i=head[u];i;i=e[i].nxt) {\n            int v=e[i].to;\n            if (e[i].w && dist[v]>dist[u]+e[i].cost) {\n                dist[v]=dist[u]+e[i].cost;\n                if (!vis[v]) {\n                    vis[v]=1;\n                    q[++r]=v;\n                }\n            }\n        }\n    }\n    return dist[t]<9999999;\n}\nint dfs(int u,int flow) {\n    if (u==t) {\n        vis[t]=1;\n        maxflow+=flow;\n        return flow;\n    }\n    int goflow=0,used=0;\n    vis[u]=1;\n    for (int i=head[u];i;i=e[i].nxt) {\n        int v=e[i].to;\n        if ((!vis[v] || v==t) && e[i].w && dist[v]==dist[u]+e[i].cost) {\n            goflow=dfs(v,min(flow-used,e[i].w));\n            if (!goflow) continue;\n            used+=goflow;\n            e[i].w-=goflow;\n            e[i^1].w+=goflow;\n            mincost+=goflow*e[i].cost;\n            if (used==flow) break;\n        }\n    }\n    return used;\n}\nvoid MCMF(){ \n    while (spfa()) {\n        vis[t]=1;\n        while (vis[t]) {\n            memset(vis,0,sizeof(vis));\n            dfs(s,inf);\n        }\n    }\n}\nint a=0;\nint main(){\n    scanf(\"%d\",&n);\n    s=n*2+20;\n    t=s+1;\n    for (int i=1;i<=n;++i) {\n        add(s,i,1,0);\n        add(i+n+1,t,1,0);\n        for (int j=1;j<=n;++j) {\n            scanf(\"%d\",&x[i][j]);\n            add(i,j+n+1,1,-x[i][j]);\n        }\n    }\n    MCMF();\n    int lzr=mincost;\n    mincost=maxflow=0;\n    cnt=1;\n    memset(head,0,sizeof(head));\n    memset(e,0,sizeof(e));\n    memset(vis,0,sizeof(vis));\n    for (int i=1;i<=n;++i) {\n        add(s,i,1,0);\n        add(i+n+1,t,1,0);\n        for (int j=1;j<=n;++j) {\n            add(i,j+n+1,1,x[i][j]);\n        }\n    }\n    MCMF();\n    printf(\"%d\\n%d\\n\",mincost,-lzr);\n    return 0;\n}\n```",
        "postTime": 1544839405,
        "uid": 78752,
        "name": "lolte",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u4e8c\u5206\u56fe\u6700\u4f73\u5b8c\u7f8e\u5339\u914d\u2014\u2014Kuhn-Munkres(KM)\u7b97\u6cd5\u3002\n\n\n\u8fc7\u7a0b\u501f\u9274\u697c\u4e0aDalao\u7684\u9898\u89e3\u3002\n\n\n\u6211\u53ea\u662f\u6765\u4e00\u6ce2\u94fe\u5f0f\u524d\u5411\u661f\u7684\u5199\u6cd5\u3002\n\n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconst int MAXN=210,MAXM=10010,INF=0x3f3f3f3f;\nbool vis[MAXN];\nint n,cnt,ans,head[MAXN],match[MAXN],mark[MAXN];\nstruct edge\n{\n    int nxt,to,w;\n}e[MAXM];\nvoid AddEdge(int u,int v,int w)\n{\n    e[++cnt].nxt=head[u];\n    e[cnt].to=v;\n    e[cnt].w=w;\n    head[u]=cnt;\n}\nvoid Init(bool flag)\n{\n    ans=0;\n    memset(match,0,sizeof match);\n    memset(mark,0xb0,sizeof mark);\n    for(int u=1;u<=n;++u)\n        for(int i=head[u];i;i=e[i].nxt)\n            mark[u]=max(mark[u],flag ? e[i].w=-e[i].w : e[i].w),mark[e[i].to]=0;\n}\nbool DFS(int u)\n{\n    vis[u]=1;\n    for(int i=head[u],v;i;i=e[i].nxt)\n        if(!vis[v=e[i].to] && e[i].w==mark[u]+mark[v])\n        {\n            vis[v]=1;\n            if(!match[v] || DFS(match[v]))\n            {\n                match[v]=u;\n                return 1;\n            }\n        }\n    return 0;\n}\nvoid Update(void)\n{\n    int d=INF;\n    for(int u=1;u<=n;++u)\n        if(vis[u])\n            for(int i=head[u],v;i;i=e[i].nxt)\n                if(!vis[v=e[i].to])\n                    d=min(d,mark[u]+mark[v]-e[i].w);\n    for(int i=1,j;i<=n;++i)\n    {\n        if(vis[i])\n            mark[i]-=d;\n        if(vis[j=i+n])\n            mark[j]+=d;\n    }\n}\nvoid KM(bool flag)\n{\n    Init(flag);\n    for(int i=1;i<=n;++i)\n        while(1)\n        {\n            memset(vis,0,sizeof vis);\n            if(DFS(i))\n                break;\n            Update();\n        }\n    for(int i=1;i<=n;++i)\n        ans+=mark[i]+mark[i+n];\n    printf(\"%d\\n\",flag ? ans : -ans);\n}\nint main(int argc,char *argv[])\n{\n    scanf(\"%d\",&n);\n    memset(mark,0xb0,sizeof mark);\n    for(int i=1;i<=n;++i)\n        for(int j=1,w;j<=n;++j)\n        {\n            scanf(\"%d\",&w);\n            AddEdge(i,j+n,-w);\n        }\n    KM(0);\n    KM(1);\n    return 0;\n}\n```\n\n>\u8c22\u8c22\u9605\u8bfb\n",
        "postTime": 1515390626,
        "uid": 35851,
        "name": "Capella",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "# \u6d1b\u8c37 P4014:\u300c\u5206\u914d\u95ee\u9898\u300d\n[\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/P4014)\n### \u9898\u76ee\u63cf\u8ff0\n\u6709n\u4ef6\u5de5\u4f5c\u8981\u5206\u914d\u7ed9n\u4e2a\u4eba\u505a.\u7b2ci\u4e2a\u4eba\u505a\u7b2cj\u4ef6\u5de5\u4f5c\u4ea7\u751f\u7684\u6548\u76ca\u4e3a$C_{ij}$.\u8bd5\u8bbe\u8ba1\u4e00\u4e2a\u5c06n\u4ef6\u5de5\u4f5c\u5206\u914d\u7ed9n\u4e2a\u4eba\u505a\u7684\u5206\u914d\u65b9\u6848,\u4f7f\u4ea7\u751f\u7684\u603b\u6548\u76ca\u6700\u5927.\n### \u8f93\u5165\u683c\u5f0f\n\u6587\u4ef6\u7684\u7b2c1\u884c\u67091\u4e2a\u6b63\u6574\u6570n,\u8868\u793a\u6709n\u4ef6\u5de5\u4f5c\u8981\u5206\u914d\u7ed9n\u4e2a\u4eba\u505a.\n\u63a5\u4e0b\u6765\u7684n\u884c\u4e2d,\u6bcf\u884c\u6709n\u4e2a\u6574\u6570 $C_{ij}$,\u8868\u793a\u7b2ci\u4e2a\u4eba\u505a\u7b2cj\u4ef6\u5de5\u4f5c\u4ea7\u751f\u7684\u6548\u76ca\u4e3a$C_{ij}$.\n### \u8f93\u51fa\u683c\u5f0f\n\u4e24\u884c\u5206\u522b\u8f93\u51fa\u6700\u5c0f\u603b\u6548\u76ca\u548c\u6700\u5927\u603b\u6548\u76ca\u3002\n### \u8f93\u5165\u8f93\u51fa\u6837\u4f8b\n\n#### \u6837\u4f8b\u8f93\u5165\n    5\n    2 2 2 1 2\n    2 3 1 2 4\n    2 0 1 1 1\n    2 3 4 3 3\n    3 2 1 2 1\n#### \u6837\u4f8b\u8f93\u51fa\n    5\n    14\n### \u8bf4\u660e/\u63d0\u793a\n1$\\le$n$\\le100$\n**\u4e00\u4e2a\u4eba\u53ea\u80fd\u4fee\u4e00\u4e2a\u5de5\u4ef6**\n\n\u8fd9\u662f\u4e00\u9053**\u8d39\u7528\u6d41\u7ecf\u5178\u9898\u76ee**\n### \u5efa\u56fe\n\n- **1.**\u8bbe**0**\u4e3a**\u8d85\u7ea7\u6e90\u70b9**\uff0c**2$\\times$n+1**\u4e3a**\u8d85\u7ea7\u6c47\u70b9**\uff0c\u7b2c**i**\u4e2a\u4eba\u7684\u8282\u70b9\u4e3a**i**\uff0c\u7b2c**j**\u4ef6\u5de5\u4f5c\u8282\u70b9\u4e3a**j+n**\n- **2.**\u4ece**\u8d85\u7ea7\u6e90\u70b9** \u5411$\\forall$i$\\in$[1,n]\u8fde\u63a5\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\n- **3.**\u4ece$\\forall$j$\\in$[n+1,2$\\times$n]\u5411**\u8d85\u7ea7\u6c47\u70b9**\u8fde\u63a5\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\n- **4**.\u4ece$\\forall$i$\\in$ [1, n]\u5411$\\forall$j$\\in$ [n+1,n$\\times$2]\uff0c\u8fde\u63a5\u4e00\u6761\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a$C_{i, j}$\u7684\u8fb9\n\n### \u505a\u6cd5\n\u8dd1\u4e00\u904d**\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41**&**\u6700\u5927\u8d39\u7528\u6700\u5c0f\u6d41**\uff0c\u7136\u540e\u518d\u5206\u522b\u8f93\u51fa\u6700**\u5c0f**\u503c\u4e0e\u6700**\u5927**\u503c\n(**\u6e29\u99a8\u63d0\u9192\uff1a\u4e00\u5b9a\u8981\u8f93\u51fa\uff0c\u4e0d\u7136\u4f1aWA\uff01**)\n\n**\u4e3a\u5404\u4f4d\u5927\u4f6c\u732e\u4e0a\u6211\u4e11\u964b\u7684\u4ee3\u7801~**\n\n```cpp\n#include<bits/stdc++.h>\n#define FQ(i,a,b) for(register int i=a;i<=b;i++)\n#define prf printf\n#define scf scanf\n#define ll long long\nusing namespace std;\nconst int N=5e4+10;\nint INF,n,num=1,ne[N],fi[N],to[N],w[N],pl[N],S,T;\nint dst[N],incf[N],P[N],vis[N],ans;\nqueue<int> q;\nvoid FindMaxN()\n{\n\tint fINDmAXn[1];\n\tmemset(fINDmAXn,128/2,sizeof(fINDmAXn));\t\n\tINF=fINDmAXn[0];\n}\nll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\t\n}\nvoid add(int x,int y,int z,int kl)\n{\n    ne[++num]=fi[x];    \n    fi[x]=num;    \n    to[num]=y;   \n    w[num]=z;\n    pl[num]=kl; \n}\nbool spfa()\n{ \n    for(int i=S;i<=T;i++)dst[i]=INF; \n    memset(vis,0,sizeof(vis));  \n    q.push(S),dst[S]=0;\t\n\tincf[S]=1<<30,vis[S]=true;   \n    while(!q.empty())\n    {      \n        int x=q.front();      \n        vis[x]=false;q.pop();        \n        for(int i=fi[x];i;i=ne[i])\n        {            \n            int ver=to[i];             \n            if(dst[ver]>dst[x]+pl[i]&&w[i])\n            {                \n                dst[ver]=dst[x]+pl[i];                \n                incf[ver]=min(incf[x],w[i]);                \n                P[ver]=i;                \n                if(!vis[ver])vis[ver]=true,q.push(ver);                 \n            }             \n        }    \n    }\n    return dst[T]!=INF;  \n}\nvoid update()\n{\t\n\tint x=T;     \n    while(x!=S)\n    {         \n        int i=P[x];         \n        w[i]-=incf[T];       \n        w[i^1]+=incf[T];\n   \n        x=to[i^1];\n    }\n    ans+=dst[T]*incf[T];\n}\nbool spfa_d()\n{\n    for(int i=S;i<=T;i++)dst[i]=-INF;\n    q.push(S),dst[S]=0;incf[S]=1<<30;\n    while(!q.empty())\n    {\n        int x=q.front();\n        vis[x]=false;q.pop();\n        for(int i=fi[x];i;i=ne[i])\n        {\n            int ver=to[i];\n            if(dst[ver]<dst[x]+pl[i]&&w[i])\n            {\n                dst[ver]=dst[x]+pl[i];\n                incf[ver]=min(incf[x],w[i]);\n                P[ver]=i;\n                if(!vis[ver])vis[ver]=true,q.push(ver);\n            }\n        }\n    }\n    return dst[T]!=-INF;\n}\nvoid update_d()\n{\n\tint x=T;\n    while(x!=S)\n    {\n        int i=P[x];\n        w[i]-=incf[T];\n        w[i^1]+=incf[T];\n        x=to[i^1];\n    }\n    ans+=dst[T]*incf[T];\n}\nvoid add_x(int x,int y,int z,int kl)\n{\n\tadd(x,y,z,kl);\n\tadd(y,x,0,-kl);\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tFindMaxN();\n\tn=read();S=0,T=n*2+1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tint x=read();\n\t\t\tadd_x(i,j+n,1,x);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)add_x(S,i,1,0),add_x(i+n,T,1,0);\n\twhile(spfa())update();\n\tprintf(\"%d\\n\",ans);\n\tans=0;\n\tfor(int i=2;i<=num;i+=2)w[i]+=w[i^1],w[i^1]=0;\n\twhile(spfa_d())update_d();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\t\t\n}\n//**\u6708\u96e9\u00b7\u8587\u5aed**\n```\n\n\n\n### _**by\uff1a\u6708\u96e9\u00b7\u8587\u5aed**_",
        "postTime": 1576669924,
        "uid": 116374,
        "name": "\u6708\u96e9\u00b7\u8587\u5aed",
        "ccfLevel": 4,
        "title": "P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u662f\u7ec3\u4e60\u8d39\u7528\u6d41\u7684\u4e00\u9053\u6a21\u677f\u9898\uff0c\u601d\u8003\u7684\u96be\u70b9\u4e3b\u8981\u5728\u5efa\u56fe\u65b9\u9762\n\n\u8d85\u7ea7\u6e90\u70b9\u548c\u8d85\u7ea7\u6c47\u70b9\u7684\u5efa\u7acb\u4e0d\u9700\u8981\u591a\u8bf4\uff0c\u5927\u5bb6\u90fd\u6e05\u695a\u3002\n\n\u6bcf\u4e2a\u4eba\u548c\u6bcf\u9879\u5de5\u4f5c\u5efa\u8fb9\uff0c\u6d41\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a(+/-)Cij\n\n\u8fd9\u91cc\u6ce8\u610f\u4e00\u4e0b\uff0c\u6c42\u6700\u5c0f\u6536\u76ca\u662f\u4f7f\u7528**\u6b63\u6743\u8fb9**\uff0c\u5373\u8d39\u7528\u662fCij\uff0c\u6c42\u6700\u5927\u6536\u76ca\u65f6\uff0c\u4f7f\u7528**\u8d1f\u6743\u8fb9**\uff0c\u5373\u8d39\u7528\u662f-Cij\uff0c\u8f93\u51fa\u65f6\u8f93\u51fa\u76f8\u53cd\u6570\u65e2\u53ef,\u6bd5\u7adf\u6211\u4eec\u5b66\u7684\u6a21\u677f\u662f\u6700\u5c0f\u8d39\n\n\u7136\u540e\u5c31\u662f\u8fde\u63a5\u8d85\u7ea7\u6e90\u70b9\u548c\u6bcf\u4e00\u4e2a\u4eba\u4ee5\u53ca\u6bcf\u9879\u5de5\u4f5c\u548c\u8d85\u7ea7\u6c47\u70b9\u8fde\u63a5\uff0c\u6d41\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0\n\n\u8865\u5145\u4e00\u53e5\u5173\u4e8e\u6240\u6709\u8fb9\u7684\u6d41\u91cf\u4e3a1\uff0c\u662f\u56e0\u4e3an\u9879\u5de5\u4f5c\u5e73\u5206\u7ed9n\u4e2a\u4eba\u505a\uff0c\u4e5f\u5c31\u662f\u4e00\u4eba\u53ea\u80fd\u505a\u4e00\u9879\n\n\u4e0a\u4ee3\u7801\n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n\nconst int N = 5e3 + 5, M = 1e5 + 5;\nconst int INF = 0x3f3f3f3f;\nint n, m, tot = 1, lnk[N];\nint cur[N], ter[M], nxt[M];\nint cap[M], cost[M], dis[N], ret;\nbool vis[N];\n\ninline int read(){\n    int num = 0, x = 1;\n    char c = getchar();\n    while(c < '0' || c > '9'){\n        if(c == '-') x = -x;\n        c = getchar();\n    }\n    while(c <= '9' && c >= '0'){\n        num = (num << 1) + (num << 3) + c - '0';\n        c = getchar();\n    }\n    return num * x;\n}\n\nvoid add(int u, int v, int w, int c){\n    ter[++tot] = v;\n    nxt[tot] = lnk[u];\n    lnk[u] = tot;\n    cap[tot] = w;\n    cost[tot] = c;\n}\n\nvoid addedge(int u, int v, int w, int c){\n    add(u, v, w, c);\n    add(v, u, 0, -c);\n}\n\nbool spfa(int s, int t){\n    memset(dis, 0x3f, sizeof(dis));\n    memcpy(cur, lnk, sizeof(lnk));\n    std::queue<int> q;\n    q.push(s), dis[s] = 0;\n    vis[s] = 1;\n    while (!q.empty()){\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n        for(int i = lnk[u]; i; i = nxt[i]){\n            int v = ter[i];\n            if(cap[i] && dis[v] > dis[u] + cost[i]){\n                dis[v] = dis[u] + cost[i];\n                if(!vis[v]){\n                    q.push(v);\n                    vis[v] = 1;\n                }\n            }\n        }\n    }\n    return dis[t] != INF;\n}\n\nint dfs(int u, int t, int flow){\n    if (u == t) return flow;\n    vis[u] = 1;\n    int ans = 0;\n    for (int &i = cur[u]; i && ans < flow; i = nxt[i]){\n        int v = ter[i];\n        if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]){\n            int x = dfs(v, t, std::min(cap[i], flow - ans));\n            if(x){\n                ret += x * cost[i];\n                cap[i] -= x;\n                cap[i ^ 1] += x;\n                ans += x;\n            }\n        }\n    }\n    vis[u] = 0;\n    return ans;\n}\n\nint mcmf(int s, int t){\n    int ans = 0;\n    while (spfa(s, t)){\n        int x;\n        while ((x = dfs(s, t, INF))) ans += x;\n    }\n    return ans;\n}\n\nint main(){\n    int s1, s2, t1, t2;\n    n = read();\n    s1 = 0;\n    t1 = 2 * n + 1;\n    s2 = 3 * n;\n    t2 = 5 * n + 1;\n    for(register int i = 1; i <= n; ++i){\n        addedge(s1, i, 1, 0);\n        addedge(n + i, t1, 1, 0);\n        addedge(s2, 3 * n + i, 1, 0);\n        addedge(4 * n + i, t2, 1, 0);\n        for(register int j = 1; j <= n; ++j){\n            int u = read();\n            addedge(i, n + j, 1, u);\n            addedge(3 * n + i, 4 * n + j, 1, -u);\n        }\n    }\n    int ans1 = mcmf(s1, t1);\n    printf(\"%d\\n\", ret);\n    ret = 0;\n    int ans2 = mcmf(s2, t2);\n    printf(\"%d\\n\", -ret);\n    return 0;\n}\n```\n\n\u4ee5\u4e0a\uff0c\u5b8c\u7ed3",
        "postTime": 1582354715,
        "uid": 320102,
        "name": "\u96f7\u795e\u5c71\u901f\u5ea6",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "**\u8d39\u7528\u6d41\u7ecf\u5178\u9898\u76ee\uff0c\u6211\u7528\u7684\u6307\u9488\u7248Zkw\u8d39\u7528\u6d41\u3002**\n\n### \u5efa\u56fe\n\n* \u8bbe$0$\u4e3a\u8d85\u7ea7\u539f\u70b9\uff0c$2 \\times n + 1$\u4e3a\u8d85\u7ea7\u6c47\u70b9\u3002\u7b2c$i$\u4e2a\u4eba\u7684\u8282\u70b9\u4e3a$i$\uff0c\u7b2c$j$\u4ef6\u5de5\u4f5c\u7684\u8282\u70b9\u4e3a$n + j$\n\n* \u4ece$0$\u5411$\\forall i \\in [1,n]$\u8fde\u63a5\u5bb9\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\n\n* \u4ece$\\forall j \\in [n + 1, 2 \\times n]$\u5411$2 \\times n + 1$\u8fde\u63a5\u5bb9\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\n\n* \u4ece$\\forall i \\in [1, n]$\u5411$\\forall j \\in [n + 1, n \\times 2]$\u8fde\u63a5\u5bb9\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$c_{i, j}$\u7684\u8fb9\n\n\u7136\u540e\u8dd1\u4e00\u904d\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u8dd1\u4e00\u904d\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\uff0c\u5206\u522b\u8f93\u51fa\u4e24\u6b21\u5f97\u5230\u7684\u8d39\u7528\u5373\u53ef\u3002\u6253\u4e00\u4e2a\u677f\u5b50\u590d\u5236\u7c98\u8d34\u4e00\u904d\u5c31\u884c\u4e86\u3002\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\nconst int MAXN = 105;\nconst int INF = 0x3f3f3f3f;\n\nint n;\n\nstruct Edge{\n\tint to, val, cost;\n\tEdge *next, *ops;\n\tEdge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}\n};\n\nnamespace Zkw1{\n\tEdge *head[MAXN << 1];\n\tbool vis[MAXN << 1];\n\tint dis[MAXN << 1];\n\tint s, t, res ,ans;\n\n\tvoid AddEdge(int u, int v, int w, int c) {\n\t\thead[u] = new Edge(v, w, c, head[u]);\n\t\thead[v] = new Edge(u, 0, -c, head[v]);\n\t\thead[u]->ops = head[v]; head[v]->ops = head[u];\n\t}\n\n\tbool Spfa() {\n\t\tmemset(dis, INF, sizeof(dis));\n\t\tmemset(vis, false, sizeof(vis));\n\t\tdeque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tvis[u] =false;\n\t\t\tfor (Edge *e = head[u]; e; e = e->next) {\n\t\t\t\tint v = e->to;\n\t\t\t\tif (e->val > 0 && dis[u] + e->cost < dis[v]) {\n\t\t\t\t\tdis[v] = dis[u] + e->cost;\n\t\t\t\t\tif (!vis[v]) {\n\t\t\t\t\t\tvis[v] = true;\n\t\t\t\t\t\tif (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);\n\t\t\t\t\t\telse q.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[t] < INF;\n\t}\n\n\tint Dfs(int u, int flow) {\n\t\tvis[u] = true;\n\t\tif (u == t) {\n\t\t\tres += flow;\n\t\t\treturn flow;\n\t\t}\n\t\tint used = 0;\n\t\tfor (Edge *e = head[u]; e; e = e->next) {\n\t\t\tint v = e->to;\n\t\t\tif ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n\t\t\t\tint mi = Dfs(v, min(e->val, flow - used));\n\t\t\t\tif (mi) {\n\t\t\t\t\tused += mi;\n\t\t\t\t\te->val -= mi;\n\t\t\t\t\te->ops->val += mi;\n\t\t\t\t\tans += e->cost * mi;\n\t\t\t\t}\n\t\t\t\tif (used == flow) break;\n\t\t\t}\n\t\t}\n\t\treturn used;\n\t}\n\n\tvoid Work() {\n\t\tres = ans = 0;\n\t    while (Spfa()) {\n\t\t\tvis[t] = true;\n\t\t\twhile (vis[t]) {\n\t\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\t\tDfs(s, INF);\n\t\t\t}\n\t\t}\n\t}\n}\n\nnamespace Zkw2{\n\tEdge *head[MAXN << 1];\n\tbool vis[MAXN << 1];\n\tint dis[MAXN << 1];\n\tint s, t, res ,ans;\n\n\tvoid AddEdge(int u, int v, int w, int c) {\n\t\thead[u] = new Edge(v, w, c, head[u]);\n\t\thead[v] = new Edge(u, 0, -c, head[v]);\n\t\thead[u]->ops = head[v]; head[v]->ops = head[u];\n\t}\n\n\tbool Spfa() {\n\t\t//memset(dis, -INF, sizeof(dis));\n\t\tfor (int i = 1; i <= 2 * n + 1; i++) dis[i] = -INF;\n\t\tmemset(vis, false, sizeof(vis));\n\t\tdeque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint u = q.front(); q.pop_front();\n\t\t\tvis[u] =false;\n\t\t\tfor (Edge *e = head[u]; e; e = e->next) {\n\t\t\t\tint v = e->to;\n\t\t\t\tif (e->val > 0 && dis[u] + e->cost > dis[v]) {\n\t\t\t\t\tdis[v] = dis[u] + e->cost;\n\t\t\t\t\tif (!vis[v]) {\n\t\t\t\t\t\tvis[v] = true;\n\t\t\t\t\t\tif (!q.empty() && dis[v] > dis[q.front()]) q.push_front(v);\n\t\t\t\t\t\telse q.push_back(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[t] > -INF;\n\t}\n\n\tint Dfs(int u, int flow) {\n\t\tvis[u] = true;\n\t\tif (u == t) {\n\t\t\tres += flow;\n\t\t\treturn flow;\n\t\t}\n\t\tint used = 0;\n\t\tfor (Edge *e = head[u]; e; e = e->next) {\n\t\t\tint v = e->to;\n\t\t\tif ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n\t\t\t\tint mi = Dfs(v, min(e->val, flow - used));\n\t\t\t\tif (mi) {\n\t\t\t\t\tused += mi;\n\t\t\t\t\te->val -= mi;\n\t\t\t\t\te->ops->val += mi;\n\t\t\t\t\tans += e->cost * mi;\n\t\t\t\t}\n\t\t\t\tif (used == flow) break;\n\t\t\t}\n\t\t}\n\t\treturn used;\n\t}\n\n\tvoid Work() {\n\t\tres = ans = 0;\n\t    while (Spfa()) {\n\t\t\tvis[t] = true;\n\t\t\twhile (vis[t]) {\n\t\t\t\tmemset(vis, false, sizeof(vis));\n\t\t\t\tDfs(s, INF);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n\tcin >> n;\n\tZkw1 :: s = 0; Zkw1 :: t = n * 2 + 1; Zkw2 :: s = 0; Zkw2 :: t = n * 2 + 1;\n\tfor (int i = 1; i <= n; i++) Zkw1 :: AddEdge(0, i, 1, 0), Zkw1 :: AddEdge(i + n, n * 2 + 1, 1, 0), Zkw2 :: AddEdge(0, i, 1, 0), Zkw2 :: AddEdge(i + n, n * 2 + 1, 1, 0);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j =1; j <= n; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\tZkw1 :: AddEdge(i, n + j, 1, x);\n\t\t\tZkw2 :: AddEdge(i, n + j, 1, x);\n\t\t}\n\t}\n\tZkw1 :: Work(); Zkw2 :: Work();\n\tcout << Zkw1 :: ans << endl << Zkw2 :: ans << endl;\n\treturn 0;\n}\n\n```",
        "postTime": 1554774265,
        "uid": 126376,
        "name": "Irelia\u10e6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "[\u6392\u7248\u641e\u4e0d\u5b9a\uff0c\u6682\u65f6\u7528\u4e00\u4e0b\u56fe\u7247\u5427](https://blog.csdn.net/qq_33831360/article/details/94043097)\n\n![\u706b\u72d0\u622a\u56fe_2019-06-29T15-31-24.499Z.png](https://i.loli.net/2019/06/29/5d1784862e79992772.png)\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 110\nvoid Out(int a[N][N],int v[N][N],int n) {\n     for (int i = 1; i <= n; i++){\n        for (int j = 1; j <= n; j++) {\n           if(!v[i][j]) printf(\"%4d\",a[i][j]);\n           else printf(\"   %c\",v[i][j]==1?'O':'X');\n        }\n       puts(\"\");\n    }puts(\"End!\");\n}\n\nint HZ[N],LZ[N];\n\nstruct Pair {\n    int x,y;\n    Pair(int x = 0,int y = 0):x(x),y(y){}\n    bool operator < (const Pair & b) const {\n        return HZ[this->x]==HZ[b.x] ? LZ[this->y]<LZ[b.y] : HZ[this->x]<HZ[b.x];\n    }\n}Pt[N*N];\n\nint FH[N],FL[N];\nint Maxx,Mx;\nint st[N*N],tot,used[N*N];\nvoid dfs(int s,int t,int sum) {\n    if (sum > Mx) {\n        Mx = sum;\n        used[0] = tot;//\u8bb0\u5f55\u6700\u597d\u65b9\u6848\n        for (int i = 1; i <= tot; i++) used[i] = st[i];\n    }\n    if (Mx == Maxx) return;//\u5df2\u7ecf\u627e\u5230\u6ee1\u610f\u89e3\n    if (t-s+1+sum <= Mx) return;//\u4e50\u89c2\u4f30\u8ba1\u4e0d\u5982\u76ee\u524d\u6700\u4f18\u89e3\n    if (s > t) return;\n    if (!FH[Pt[s].x] && !FL[Pt[s].y]) { //\u9009s\u70b9\n        FH[Pt[s].x] = 1;\n        FL[Pt[s].y] = 1;\n        st[++tot] = s;\n        dfs(s+1,t,sum+1);\n        --tot;\n        FH[Pt[s].x] = 0;\n        FL[Pt[s].y] = 0;\n    }\n    dfs(s+1,t,sum);//\u4e0d\u9009s\u70b9\n}\n\nint calc(int b[N][N],int n) {\n    int a[N][N],v[N][N];\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            a[i][j] = b[i][j];\n    for (int i = 1; i <= n; i++) {\n        int t = a[i][1];\n        for (int j = 2; j <= n; j++)\n          if (a[i][j] < t) t = a[i][j];\n        for (int j = 1; j <= n; j++)\n          a[i][j] -= t;\n    }\n    for (int i = 1; i <= n; i++) {\n        int t = a[1][i];\n        for (int j = 2; j <= n; j++)\n          if (a[j][i] < t) t = a[j][i];\n        for (int j = 1; j <= n; j++)\n          a[j][i] -= t;\n    }\n    //\u5148\u8ba9\u6bcf\u884c\u6bcf\u5217\u90fd\u67090\n//Out(a,v,n);\n    int H[N],L[N];\n    while(1) {\n      for (int i = 1; i <= n; i++) {\n        H[i] = L[i] = 0; //H[i]\uff0c\u7b2ci\u884c\u6709\u591a\u5c11\u4e2a0\uff0cL\u4e3a\u5217\n        FH[i] = FL[i] = 0; //FH[i],\u7b2ci\u884c\u6709\u6ca1\u6709\u753bO\n        for (int j = 1; j <= n; j++) v[i][j] = 0;//v[i][j] = 1\u4ee3\u8868\u2018O\u2019,-1\u4ee3\u8868\u2018X\u2019\n      }\n      for (int i = 1; i <= n; i++)\n       for (int j = 1; j <= n; j++)\n         if (a[i][j] == 0) {\n            H[i]++; L[j]++;\n         }\n      int cnt = 0;\n      while (1) {\n        int tpcnt = cnt;\n        for (int i = 1; i <= n; i++) //\u627e\u6bcf\u884c\u5355\u72ec\u76840\u753b\u2018O\u2019\uff0c\u540c\u5217\u753b\u2018X\u2019\n         if (H[i] == 1) {\n           int t = 1;\n           while(a[i][t] || v[i][t]) t++;\n           v[i][t] = 1;\n           cnt++;  //cnt\u8bb0\u6709\u51e0\u4e2a\u2018O\u2019\n           H[i]--; L[t]--;\n           FH[i] = 1; FL[t] = 1;\n           for (int j = 1; j <= n; j++)\n            if (a[j][t]==0 && j!=i && v[j][t]==0) {\n              v[j][t] = -1;\n              H[j]--; L[t]--;\n           }\n        }\n        for (int i = 1; i <= n; i++) //\u5bf9\u79f0\u7684\n         if (L[i] == 1) {\n           int t = 1;\n           while(a[t][i] || v[t][i]) t++;\n           v[t][i] = 1;\n           cnt++;\n           H[t]--; L[i]--;\n           FH[t] = 1; FL[i] = 1;\n           for (int j = 1; j <= n; j++)\n            if (a[t][j]==0 && j!=i && v[t][j]==0) {\n              v[t][j] = -1;\n              H[t]--; L[j]--;\n            }\n         }\n         if (tpcnt == cnt) break;\n        }\n//Out(a,v,n);\n      int top = 0;\n      for (int i = 1; i <= n; i++)\n       for (int j = 1; j <= n; j++)\n        if (a[i][j]==0 && v[i][j]==0) {\n            Pt[++top] = Pair(i,j);\n            HZ[i]++;\n            LZ[j]++;\n        }\n      sort(Pt+1,Pt+top+1);//\u540c\u884c\u540c\u5217\u5c11\u7684\u6392\u524d\u9762\n      Maxx = n-cnt;\n      Mx = 0; used[0] = 0;\n      dfs(1,top,0);//\u5bf9\u5269\u4e0b\u76840\u8fdb\u884c\u8bd5\u63a2\u753b\u2018O\u2019\n      cnt += Mx;\n      for (int i = 1; i <= used[0]; i++) {\n            v[Pt[used[i]].x][Pt[used[i]].y] = 1;\n            FH[Pt[used[i]].x] = 1;\n            FL[Pt[used[i]].y] = 1;\n      }\n//Out(a,v,n);\n      if (cnt == n) { //\u5df2\u7ecf\u627e\u5230\n        int ans = 0;\n        for (int i = 1; i <= n; i++)\n          for (int j = 1; j <= n; j++)\n            if (v[i][j] == 1) ans += b[i][j];\n        return ans;\n      }\n      int flagx[N],flagy[N]; //\u5bf9\u53f7\u6807\u8bb0\n      for (int i = 1; i <= n; i++) flagx[i] = flagy[i] = 0;\n      int cas = 1;//\u65f6\u95f4\u6233\uff0c\u6bcf\u6b21\u53ea\u68c0\u67e5\u65b0\u589e\u5bf9\u53f7\u884c/\u5217\n      for (int i = 1; i <= n; i++)\n         if (!FH[i]) flagx[i] = cas;\n      bool chang = 1;\n      while (chang) {\n        chang = 0;\n        cas++;\n        for (int i = 1; i <= n; i++)\n          if (flagx[i] == cas-1)\n            for (int j = 1; j <= n; j++)\n              if (v[i][j] == -1) {\n                flagy[j] = cas;\n                chang = 1;\n              }\n        for (int i = 1; i <= n; i++)\n          if (flagy[i] == cas-1)\n            for (int j = 1; j <= n; j++)\n              if (v[j][i] == 1) {\n                flagx[j] = cas;\n                chang = 1;\n              }\n      }\n      int Mi = ~0u>>2;\n      for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n          if (flagx[i] && !flagy[j] && Mi > a[i][j])\n            Mi = a[i][j];  //\u672a\u5212\u7ebf\u627e\u6700\u5c0f\u7684\n       for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n          if (flagx[i] && !flagy[j]) //\u672a\u5212\u7ebf\n             a[i][j] -= Mi;\n          else if (!flagx[i] && flagy[j]) //\u7ebf\u4ea4\u70b9\n             a[i][j] += Mi;\n    }\n}\n\nint main() {\n    int n,a[N][N],b[N][N];\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++)\n     for (int j = 1; j <= n; j++) {\n       scanf(\"%d\",&a[i][j]);\n       b[i][j] = -a[i][j];\n     }\n    printf(\"%d\\n%d\",calc(a,n),-calc(b,n));\n    return 0;\n}\n```\n\n",
        "postTime": 1561728807,
        "uid": 24701,
        "name": "wine",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u4e00\u4e2a\u5e26\u6743\u503c\u7684\u4e8c\u5206\u56fe\u3002\n\n\u6ce8\u610f\u6e90\u70b9\u548c\u5de6\u8fb9\u7684\u70b9\u8fde\u8fd8\u6709\u53f3\u8fb9\u7684\u70b9\u5411\u6c47\u70b9\u8fde\u7684\u65f6\u5019\u6d41\u91cf\u4e3a $1$ (\u4e0d\u80fd\u88ab\u91cd\u590d\u5339\u914d) \u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u672c\u849f\u84bb\u4e0d\u4f1a $KM$\u3002\n\n```pascal\n// luogu-judger-enable-o2\nUses math;\n\nvar\n    from,reach,next,value,cost:array[-1..50010] of longint;\n    dis,pre,last,flow:array[-1..50010] of int64;\n    queue:array[-1..50010] of longint;\n    cnt:array[-1..8100] of longint;\n    vis:array[-1..8100] of boolean;\n    val:array[-1..101,-1..101] of longint;\n    n,m,i,j,k,tot,now,sink,source,maxflow,mincost:longint;\n\nprocedure add(x,y,sum_1,sum_2:longint);\nbegin\n    inc(tot); from[tot]:=x; reach[tot]:=y; value[tot]:=sum_1; cost[tot]:= sum_2; next[tot]:=cnt[x]; cnt[x]:=tot;\n    inc(tot); from[tot]:=y; reach[tot]:=x; value[tot]:=0    ; cost[tot]:=-sum_2; next[tot]:=cnt[y]; cnt[y]:=tot;\nend;\n\nfunction spfa:boolean;\nvar head,tail,now,i:longint;\nbegin\n    filldword(dis,sizeof(dis) div 4,maxlongint);\n    filldword(flow,sizeof(flow) div 4,maxlongint);\n    filldword(vis,sizeof(vis) div 4,0);\n    head:=1; tail:=1;  queue[1]:=source; vis[source]:=True; dis[source]:=0; pre[sink]:=-1;\n\n    while head<=tail do\n    begin\n        now:=queue[head]; vis[now]:=False; inc(head);\n        i:=cnt[now];\n        while i<>-1 do\n        begin\n            if (value[i]>0)and(dis[reach[i]]>dis[now]+cost[i]) then\n            begin\n                dis[reach[i]]:=dis[now]+cost[i];\n                pre[reach[i]]:=now;\n                last[reach[i]]:=i;\n                flow[reach[i]]:=min(flow[now],value[i]);\n                if vis[reach[i]]=False then\n                begin\n                    vis[reach[i]]:=True;\n                    inc(tail); queue[tail]:=reach[i];\n                end;\n            end;\n            i:=next[i];\n        end;\n    end;\n    if pre[sink]=-1 then exit(False); exit(True);\nend;\n\nprocedure MincostMaxflow;\nbegin\n    maxflow:=0; mincost:=0; now:=0;\n    while (spfa) do\n    begin\n        now:=sink;\n        inc(maxflow,flow[sink]);\n        inc(mincost,flow[sink]*dis[sink]);\n        while now<>source do\n        begin\n            dec(value[last[now]],flow[sink]);\n            inc(value[last[now] xor 1],flow[sink]);\n            now:=pre[now];\n        end;\n    end;\nend;\n\nprocedure Construction_I;\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;\n    fillchar(value,sizeof(value),0);\n    fillchar(reach,sizeof(reach),0);\n    fillchar(cost,sizeof(cost),0);\n    fillchar(next,sizeof(next),0);\n   \tfor i:=1 to n do add(source,i+1,1,0);\n   \tfor i:=1 to n do add(i+n+1,sink,1,0);\n    for i:=1 to n do for j:=1 to n do begin read(val[i,j]); add(i+1,j+n+1,1,val[i,j]); end;\nend;\n\nprocedure Construction_II;\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); tot:=1;\n    fillchar(value,sizeof(value),0);\n    fillchar(reach,sizeof(reach),0);\n    fillchar(cost,sizeof(cost),0);\n    fillchar(next,sizeof(next),0);\n   \tfor i:=1 to n do add(source,i+1,1,0);\n   \tfor i:=1 to n do add(i+n+1,sink,1,0);\n  \tfor i:=1 to n do for j:=1 to n do add(i+1,j+n+1,1,-val[i,j]);\nend;\n\n\nbegin\n    read(n); source:=1; sink:=(n+2) << 1;\n    Construction_I ; MincostMaxflow; writeln( mincost);\n    Construction_II; MincostMaxflow; writeln(-mincost);\nend.\n```",
        "postTime": 1542088770,
        "uid": 77760,
        "name": "arfa",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u8bb2\u89e3\u592a\u957f\uff0c\u6015\u9738\u5360\u6d1b\u8c37\u9898\u89e3\u533a\uff0c\u8d39\u7528\u6d41\u8be6\u89e3\u8bf7\u53bb\u67e5\u770b[blog](https://www.cnblogs.com/rmy020718/p/9548758.html)\n\n\u76f8\u5bf9\u4e8e\u6700\u5927\u6d41\u6765\u8bf4\n\n\u25a0 \u6bcf\u6761\u8fb9\u591a\u4e86\u4e00\u4e2a\u503c\u79f0\u4e3a\u8d39\u7528\u3002\n\n\u25a0 \u5728\u6700\u5927\u5316\u6d41\u91cf\u7684\u540c\u65f6\u6700\u5c0f\u5316\u6bcf\u6761\u8fb9\u7684\u8d39\u7528\u4e0e\u6d41\u91cf\u7684\u4e58\u79ef\u548c\u3002\n\n\u25a0 \u6bcf\u6b21\u6309\u7167\u8d39\u7528\u589e\u5e7f\uff1f\n\n\u25a0 \u53cd\u5411\u8fb9\u7684\u8d39\u7528\u8bbe\u4e3a\u539f\u8fb9\u7684\u76f8\u53cd\u6570(\u60f3\u8c61\u53f8\u673a\u8fd0\u9519\u4e86\u7ed9\u4f60\u518d\u8fd0\u56de\u6765\u5e76\u4e14\u4f1a\u9000\u94b1 [  \u597d\u4eba\u5450\uff01\uff01])\n\n\u25a0\u6bcf\u6b21\u589e\u5e7f\u7684\u65f6\u5019\uff0c\u6d41\u91cf$+m+m$\uff0c\u90a3\u4e48\u8d39\u7528\u589e\u52a0$m\u00d7dis[t]m\u00d7dis[t]$ (t\u4e3a\u76ee\u6807)\n\n### \u53ef\u884c\u6027\n\n\u25a0 \u4f1a\u4e0d\u4f1a\u51fa\u73b0\u8d1f\u73af\uff1f\n\n\u53ea\u8981\u521d\u59cb\u65f6\u6ca1\u6709\u8d1f\u73af\uff0c\u4e4b\u540e\u5c31\u4e0d\u4f1a\u6709\u8d1f\u73af\uff0c\u56e0\u4e3a\u771f\u60f3\u548c\u53cd\u5411\u82b1\u8d39\u76f8\u53cd\u3002\n\n\u25a0 \u6ce8\u610f\u5230\u521d\u59cb\u65f6\u6240\u6709\u53cd\u5411\u8fb9\u7684\u6b8b\u91cf\u4e3a0\uff0c\u53ef\u4ee5\u53ea\u8003\u8651\u539f\u56fe\u4e2d\u7684\u8fb9\u3002\n\n\u25a0 \u5982\u679c\u589e\u5e7f\u8def\u4e2d\u51fa\u73b0\u4e86\u8d1f\u73af\uff0c\u90a3\u4e48\u5728\u4e0a\u4e00\u6b21\u9009\u62e9\u4e2d\u4e00\u5b9a\u6709\u4e00\u6761\u66f4\u77ed\u7684\u8def\u5f84\u3002\n\n\u25a0 \u5982\u679c\u5f00\u59cb\u5c31\u6709\u8d1f\u73af\u5462\uff1f\n\n\u90a3\u4e48\u5b83\u8bf4\u660e\u4f60\u56fe\u5efa\u9519\u4e86(\u5b58\u5728\u67d0\u79cd\u7384\u5b66\u7684\u6d88\u73af\u7684\u65b9\u6cd5\uff0c\u4f46\u662f\u597d\u9ebb\u70e6QAQ\uff0c\u800c\u4e14\u65f6\u95f4\u590d\u6742\u5ea6\u5f97\u4e0d\u5230\u4fdd\u8bc1\u3002)\n\n### \u6b63\u786e\u6027\n\n\u25a0 \u4e3a\u4ec0\u4e48\u662f\u5bf9\u7684\uff1f\n\n\u5f53\u524d\u6700\u5c0f\u8d39\u7528\u6d41 <=> \u6b8b\u91cf\u7f51\u7edc\u65e0\u8d1f\u73af\n\n\u5982\u679c\u6709\u8d1f\u73af\u6211\u4eec\u53ef\u4ee5\u4ece\u8fd9\u4e2a\u8d1f\u73af\u4e0a\u8d70\u4e00\u5708\u6765\u5f97\u5230\u66f4\u5c0f\u7684\u89e3\u3002\n\n\u8fd9\u4e1c\u897f\u53cd\u8fc7\u6765\u4e5f\u662f\u6210\u7acb\u7684\uff0c\u5373\u5982\u679c\u6709\u66f4\u5c0f\u89e3\uff0c\u4e00\u5b9a\u5b58\u5728\u4e00\u4e2a\u8d1f\u73af\u6765\u8ba9\u6211\u4eec\u8d70\u4e00\u5708\u3002\n\n### \u65f6\u95f4\u590d\u6742\u5ea6\n\n\u8fd9\u6211\u548b\u77e5\u9053\uff0c\u7f51\u7edc\u6d41\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u53ea\u6709$O(TLE)$\u548c$O(notTLE)$\n\u4e00\u822c\u7684\u7f51\u7edc\u6d41\u6839\u672c\u8dd1\u4e0d\u5230\u4e0a\u754c\uff0c\u5982\u679c\u60f3\u8981\u4e86\u89e3\u8dd1\u5230\u4e0a\u754c\u7684\u7b97\u6cd5\uff0c\u53ef\u4ee5\u53bb\u4e86\u89e3\u201c\u524d\u7f6e-\u91cd\u8d34\u6807\u7b7e\u7b97\u6cd5\u201d\u3002\n\n\u5b9e\u73b0\n\n\u6211\u4eec\u8003\u8651\u4e00\u4e0b\u6211\u4eec\u662f\u600e\u4e48\u505a\u6700\u5927\u6d41\u7684\uff0c\u6211\u4eec\u662f\u5c06\u589e\u5e7f\u8def\u6309\u7167\u8ddd\u79bb\u6765$bfs$\u5206\u5c42\uff0c\u90a3\u4e48\u8fd9\u4e2a\u6211\u4eec\u4e5f\u53ef\u4ee5\u6a21\u4eff\u6b64\uff0c\u4f46\u662f\u6bcf\u6b21\u6211\u4eec\u600e\u4e48\u8d70\u5462\uff1f\n\nspfa\u4e2d\uff0c\u6211\u4eec\u6309\u7167\u8d39\u7528\u7684\u6700\u5c0f\u6765\u8d70\uff0c\u8fd9\u6837\u5b50\u7684\u8bdd\uff0c\u5c31\u5f88\u660e\u663e\u662f\u4e3a\u4e86\u8d70\u6700\u5c0f\u82b1\u8d39\u4e86\u3002\n\n\u6bcf\u6b21\u4e0d\u65ad\u7684\u53bb\u627e\u6700\u77ed\u8def\uff0c\u4ece\u540e\u5f80\u524d\u4f9d\u6b21\u66f4\u65b0\u7528\u5230\u7684\u8fb9\u3002\n\n\u6700\u5927\u6d41\u4e2d\u5df2\u7ecf\u63d0\u5230\u4e86\u89e3\u6cd5\uff0c\u5728\u8fd9\u91cc\u5c31\u4e0d\u8fc7\u591a\u89e3\u91ca\u4e86\u3002\n\nbfs\u53d8\u6210\u4e86spfa\u8fd4\u56de\u503c\u8fd8\u662f\u4e00\u6837\u7684\u3002\n\n\u8fd9\u9053\u9898\u76ee\u5efa\u7acb\u6e90\u70b90\uff0c\u6c47\u70b9\u8bbe\u4e3a1000\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u5e72\u4e00\u4e2a\uff0c\u6240\u4ee5\u6d41\u91cf\u9650\u5236\u4e3a1\uff0c\u6e90\u70b9\u5411\u6bcf\u4e2a\u4eba\u8fde\u8fb9\uff0c\u5de5\u4f5c\u5411\u6c47\u70b9\u8fde\u8fb9\uff0c\u5176\u82b1\u8d39\u4e3a0\uff0c\u5f53\u6bcf\u4e2a\u4eba\u5411\u5de5\u4f5c\u8fde\u8fb9\uff0c\u82b1\u8d39\u4e3a\u5176\u6536\u76ca\uff0c\u6240\u4ee5\u5c31\u5c06\u6536\u76ca\u95ee\u9898\u8f6c\u5316\u4e3a\u8d39\u7528\u6d41\u3002\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define inf 0x7fffffff\nint head[5050],tot;\nstruct ahah{\n    int nxt,to,flow,dis;\n}edge[10050];\n\nvoid add(int x,int y,int z,int cost)\n{\n    edge[tot].nxt=head[x];\n    edge[tot].to=y;\n    edge[tot].flow=z;\n    edge[tot].dis=cost;\n    head[x]=tot++;\n}\nint n,m,s,t;\nint x,y,z,k;\nint last[50050],flow[10001],dis[10001],pre[10010];\nbool vis[5010];\nqueue <int> Q;\n\nint spfa(int s,int t)\n{\n    memset(flow,0x7f,sizeof(flow));\n    memset(dis,0x7f,sizeof(dis));\n    memset(vis,0,sizeof(vis));\n    Q.push(s);vis[s]=1;dis[s]=0,pre[t]=-1;\n    while(!Q.empty())\n    {\n        int temp=Q.front();\n        Q.pop();\n        vis[temp]=0;\n        for(int i=head[temp];i!=-1;i=edge[i].nxt)\n        {\n            int v=edge[i].to; \n            if(edge[i].flow>0&&dis[v]>dis[temp]+edge[i].dis)\n            {\n                dis[v]=dis[temp]+edge[i].dis;\n                pre[v]=temp;\n                last[v]=i;\n                flow[v]=min(flow[temp],edge[i].flow);\n                if(!vis[v])\n                {\n                    vis[v]=1;\n                    Q.push(v); \n                }\n            }\n        }\n    }\n    return pre[t]!=-1;\n}\n\nint MCMF()\n{\n    int ans=0;\n    while(spfa(s,t))\n    {\n        int now=t;\n        ans+=flow[t]*dis[t];\n        while(now!=s)\n        {\n            edge[last[now]].flow-=flow[t];\n            edge[last[now]^1].flow+=flow[t];\n            now=pre[now];\n        }\n    }\n    return ans;\n}\nint mp[111][111];\nvoid init()\n{\n    tot=0;s=0,t=1000;\n    memset(head,-1,sizeof(head));\n    for(int i=1;i<=n;i++)add(0,i,1,0),add(i,0,0,0);\n    for(int i=n+1;i<=2*n;i++)add(i,t,1,0),add(t,i,0,0);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    init();\n    for(int i=1;i<=n;i++)\n    \tfor(int j=1;j<=n;j++)\n    \t{\n    \t\tscanf(\"%d\",&mp[i][j]);\n    \t\tadd(i,n+j,1,mp[i][j]);\n    \t\tadd(n+j,i,0,-mp[i][j]);\n        }\n    printf(\"%d\\n\",MCMF());\n    memset(&edge,0,sizeof(edge));\n    memset(last,0,sizeof(last));\n    memset(pre,0,sizeof(pre));\n    init();\n    for(int i=1;i<=n;i++)\n    \tfor(int j=1;j<=n;j++)\n    \t{\n    \t\tadd(i,n+j,1,-mp[i][j]);\n    \t\tadd(n+j,i,0,mp[i][j]);\n        }\n    printf(\"%d\",-MCMF());\n}\n```",
        "postTime": 1535445694,
        "uid": 61727,
        "name": "Manjusaka\u4e36\u68a6\u5bd2",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u975e\u5e38\u7ecf\u5178\u7684\u8d39\u7528\u6d41\u7684\u6a21\u578b\u5427\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d\u53bb\u505a\uff0c\u4f46\u662f\u9274\u4e8e\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d\u7684\u7b97\u6cd5\u5b58\u5728\u4e00\u5b9a\u7684\u5c40\u9650\u6027\uff0c\u6545\u8fd8\u662f\u5b66\u4e00\u5b66\u8f83\u4e3a\u901a\u7528\u7684\u8d39\u7528\u6d41\u7684\u505a\u6cd5\u3002\n\n\u8fd9\u9053\u9898\u76ee\u4e2d\u672c\u8d28\u4e0a\u8981\u8ba8\u8bba\u7684\u95ee\u9898\u8ddf\u8fd0\u8f93\u95ee\u9898\uff0c$LuoguP4015$\u662f\u4e00\u81f4\u7684\u3002\n\n\u56e0\u4e3a\u8003\u8651\u5230\u6bcf\u4e2a\u4eba\u53ea\u80fd\u88ab\u5206\u914d\u5230\u4e00\u79cd\u8d27\u7269\uff0c\u6bcf\u79cd\u8d27\u7269\u53ea\u80fd\u88ab\u4e00\u4e2a\u4eba\u6240\u5206\u914d\uff0c\u56e0\u6b64\uff0c\u6211\u4eec\u4e0d\u59a8\u7528\u6d41\u91cf\u5c06\u4ed6\u4eec\u9650\u6d41\u3002\n\n\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8d85\u7ea7\u6e90\u5730$sp$\uff0c\u5c06$sp$\u8ddf\u6bcf\u4e2a\u4eba\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\u3002\n\n\u540c\u65f6\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u8d85\u7ea7\u6c47\u70b9$ep$\uff0c\u5c06\u6bcf\u4e00\u79cd\u8d27\u7269\u8ddf$ep$\u90fd\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\u3002\n\n\u540c\u65f6\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u4eba\u548c\u8d27\u7269\uff0c\u6211\u4eec\u5bf9\u4ed6\u4eec\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a\u65e0\u7a77\u7684\u8fb9\u3002\n\n\u56e0\u4e3a\u6bcf\u4e2a\u4eba\u53ea\u80fd\u4ece\u8d85\u7ea7\u6e90\u70b9\u83b7\u53d6\u6700\u591a$1$\u70b9\u7684\u6d41\u91cf\uff0c\u6bcf\u79cd\u8d27\u7269\u53ea\u80fd\u5411\u8d85\u7ea7\u6c47\u70b9\u4f20\u9001\u6700\u591a$1$\u70b9\u7684\u6d41\u91cf\uff0c\u56e0\u6b64\u5f53\u8fd9\u4e2a\u56fe\u6ee1\u6d41\u65f6\uff0c\u80fd\u591f\u4fdd\u8bc1\u6bcf\u4e2a\u4eba\u4e00\u5b9a\u4f1a\u914d\u5bf9\u6700\u591a\u4e00\u4e2a\u8d27\u7269\uff0c\u5373\u8fbe\u5230\u6211\u4eec\u9650\u6d41\u7684\u8981\u6c42\u3002\n\n\u800c\u5982\u679c\u6211\u4eec\u9700\u8981\u6c42\u89e3\u6700\u5c0f\u82b1\u8d39\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06\u4eba\u548c\u8d27\u7269\u7684\u8fb9\u52a0\u4e0a\u7684\u8d39\u7528\u53d6$val_{ij}$\uff0c\u6700\u540e\u5728\u8fd9\u5f20\u56fe\u4e0a\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u540e\u6700\u5c0f\u8d39\u7528\u5373\u4e3a\u7b54\u6848\u3002\n\n\u800c\u5982\u679c\u6211\u4eec\u9700\u8981\u6c42\u89e3\u6700\u5927\u82b1\u8d39\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5c06\u4eba\u548c\u8d27\u7269\u7684\u8fb9\u52a0\u4e0a\u7684\u8d39\u7528\u53d6\u76f8\u53cd\u6570$-val_{ij}$\uff0c\u6700\u540e\u5728\u8fd9\u5f20\u56fe\u4e0a\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u540e\u6700\u5c0f\u8d39\u7528\u7684\u76f8\u53cd\u6570\u5373\u4e3a\u7b54\u6848\u3002\n\nCode:\n\n```cpp\n#include <bits/stdc++.h>\n#define maxn 4050\nusing namespace std;\nstruct Node{\n    int to,next,val,cost;\n}q[maxn<<1];\nint head[maxn],cnt=0;\nint dis[maxn],vis[maxn],sp,ep,maxflow,cost;\nint n,num[maxn][maxn];\nconst int INF=0x3f3f3f3f;\nvoid init(){\n    memset(head,-1,sizeof(head));\n    cnt=2;\n    maxflow=cost=0;\n}\nvoid addedge(int from,int to,int val,int cost){\n    q[cnt].to=to;\n    q[cnt].next=head[from];\n    q[cnt].val=val;\n    q[cnt].cost=cost;\n    head[from]=cnt++;\n}\nvoid add_edge(int from,int to,int val,int cost){\n    addedge(from,to,val,cost);\n    addedge(to,from,0,-cost);\n}\nbool spfa(){\n    memset(vis,0,sizeof(vis));\n    memset(dis,0x3f,sizeof(dis));\n    dis[sp]=0;\n    vis[sp]=1;\n    queue<int>que;\n    que.push(sp);\n    while(!que.empty()){\n        int x=que.front();\n        que.pop();\n        vis[x]=0;\n        for(int i=head[x];i!=-1;i=q[i].next){\n            int to=q[i].to;\n            if(dis[to]>dis[x]+q[i].cost&&q[i].val){\n                dis[to]=dis[x]+q[i].cost;\n                if(!vis[to]){\n                    que.push(to);\n                    vis[to]=1;\n                }\n            }\n        }\n    }\n    return dis[ep]!=0x3f3f3f3f;\n}\nint dfs(int x,int flow){\n    if(x==ep){\n        vis[ep]=1;\n        maxflow+=flow;\n        return flow;\n    }//\u53ef\u4ee5\u5230\u8fbet\uff0c\u52a0\u6d41\n    int used=0;//\u8be5\u6761\u8def\u5f84\u53ef\u7528\u6d41\u91cf\n    vis[x]=1;\n    for(int i=head[x];i!=-1;i=q[i].next){\n        int to=q[i].to;\n        if((vis[to]==0||to==ep)&&q[i].val!=0&&dis[to]==dis[x]+q[i].cost){\n            int minflow=dfs(to,min(flow-used,q[i].val));\n            if(minflow!=0){\n                cost+=q[i].cost*minflow;\n                q[i].val-=minflow;\n                q[i^1].val+=minflow;\n                used+=minflow;\n            }\n            //\u53ef\u4ee5\u5230\u8fbet\uff0c\u52a0\u8d39\u7528\uff0c\u6263\u6d41\u91cf\n            if(used==flow)break;\n        }\n    }\n    return used;\n}int mincostmaxflow(){\n    while(spfa()){\n        vis[ep]=1;\n        while(vis[ep]){\n            memset(vis,0,sizeof(vis));\n            dfs(sp,INF);\n        }\n    }\n    return maxflow;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    init();\n    sp=2*n+1,ep=2*n+2;\n\n    for(int i=1;i<=n;i++){\n        add_edge(sp,i,1,0);\n        add_edge(i+n,ep,1,0);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            scanf(\"%d\",&num[i][j]);\n            add_edge(i,j+n,INF,num[i][j]);\n        }\n    }\n    mincostmaxflow();\n    printf(\"%d\\n\",cost);\n\n    init();\n    for(int i=1;i<=n;i++){\n        add_edge(sp,i,1,0);\n        add_edge(i+n,ep,1,0);\n    }\n    for(int i=1;i<=n;i++){\n        for(int j=1;j<=n;j++){\n            add_edge(i,j+n,INF,-num[i][j]);\n        }\n    }\n    mincostmaxflow();\n    printf(\"%d\\n\",-cost);\n    return 0;\n}\n```\n",
        "postTime": 1566216496,
        "uid": 83908,
        "name": "ChenJr",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "little_sun\u8d39\u7528\u6d41\u7b2c\u4e00\u9898\uff01 \n\n\u5efa\u6a21\uff1a\n\n1.\u4ece$s$\u5411\u4eba$1-n$\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a$1$,\u8d39\u7528\u4e3a$0$\n\n2.\u4ece\u5de5\u4f5c$1-n$\u5411$t$\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a$1$,\u8d39\u7528\u4e3a$0$\n\n3.\u4ece\u4eba$1-n$\u5411\u5de5\u4f5c$1-n$\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$c_{i,j}$\n \n\u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u8dd1\u88f8\u7684\u8d39\u7528\u6d41\u5566~\n\n\u4ec0\u4e48\uff1f\u4f60\u95ee\u6211\u6700\u5927\u8d39\u7528\u600e\u4e48\u5199\uff1f\u5f53\u7136\u662f\u628a\u8fb9\u6743\u53d6\u53cd\u554a\n\n**Code:**\n\n```cpp\n#include <bits/stdc++.h>\n\n#define R register\n#define ll long long\n#define cmax(a, b) ((a < b) ? b : a)\n#define cmin(a, b) ((a < b) ? a : b)\n#define sum(a, b, mod) ((a + b) % mod)\n\nconst int MaxN = 5e3 + 10;\nconst int MaxM = 5e4 + 10;\n\nstruct edge\n{\n    int next, to, flow, cost;\n};\n\nedge e[MaxM];\nint n, s = 600, t = 601, ans, cnt = 1, mincost, maxflow;\nint head[MaxN], flow[MaxN], dis[MaxN], pre[MaxN], last[MaxN], vis[MaxN], a[210][210];\n\ninline void add(int u, int v, int f, int c)\n{\n    ++cnt;\n    e[cnt].to = v;\n    e[cnt].flow = f;\n    e[cnt].cost = c;\n    e[cnt].next = head[u];\n    head[u] = cnt;\n}\n\ninline void add_edge(int u, int v, int f, int c)\n{\n    add(u, v, f, c);\n    add(v, u, 0, -c);\n}\n\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch > '9' || ch < '0')\n    {\n        if (ch == '-')\n            f = 0;\n        ch = getchar();\n    }\n    while (ch <= '9' && ch >= '0')\n        x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();\n    return f ? x : (-x);\n}\n\nint spfa()\n{\n    memset(dis, 0x3f, sizeof(dis));\n    memset(flow, 0x3f, sizeof(flow));\n    memset(vis, 0, sizeof(vis));\n    std::queue<int> q;\n    q.push(s);\n    vis[s] = 1;\n    dis[s] = 0;\n    pre[t] = -1;\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n        vis[u] = 0;\n        for (int i = head[u]; i; i = e[i].next)\n        {\n            if (e[i].flow && dis[e[i].to] > dis[u] + e[i].cost)\n            {\n                int v = e[i].to;\n                dis[v] = dis[u] + e[i].cost;\n                pre[v] = u;\n                last[v] = i;\n                flow[v] = cmin(flow[u], e[i].flow);\n                if (!vis[v])\n                {\n                    vis[v] = 1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    return pre[t] != -1;\n}\n\nvoid MCMF()\n{\n    while (spfa())\n    {\n        int u = t;\n        maxflow += flow[t];\n        mincost += flow[t] * dis[t];\n        while (u != s)\n        {\n            e[last[u]].flow -= flow[t];\n            e[last[u] ^ 1].flow += flow[t];\n            u = pre[u];\n        }\n    }\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            a[i][j] = read();\n    for (int i = 1; i <= n; i++)\n        add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            add_edge(i, j + n, 1, a[i][j]);\n    MCMF();\n    cnt = 1;\n    printf(\"%d\\n\", mincost);\n    memset(head, 0, sizeof(head));\n    memset(pre, 0, sizeof(pre));\n    memset(last, 0, sizeof(last));\n    maxflow = mincost = 0;\n    for (int i = 1; i <= n; i++)\n        add_edge(s, i, 1, 0), add_edge(i + n, t, 1, 0);\n    for (int i = 1; i <= n; i++)\n        for (int j = 1; j <= n; j++)\n            add_edge(i, j + n, 1, -a[i][j]);\n    MCMF();\n    printf(\"%d\", -mincost);\n    return 0;\n}\n```\n\n\n\n",
        "postTime": 1560075874,
        "uid": 61966,
        "name": "little_sun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u672c\u9898\u662f\u4e00\u4e2a\u5178\u578b\u7684\u8d39\u7528\u6d41\u95ee\u9898\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u8d39\u7528\u6d41\u5efa\u56fe\u6a21\u677f\u4f7f\u7528\n\n\u9996\u5148\u770b\u5230\uff0c\u6bcf\u4e2a\u4eba\u53ea\u80fd\u505a\u4e00\u4ef6\u5de5\u4f5c\uff0c\u6bcf\u4ef6\u5de5\u4f5c\u53ea\u80fd\u505a\u4e00\u6b21\uff0c\u4e00\u4e2a\u4eba\u505a\u67d0\u4ef6\u5de5\u4f5c\u6709\u4e00\u5b9a\u7684\u6536\u76ca\n\n\u90a3\u4e48\u6211\u4eec\u5efa\u7acb\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9st\u548c\u8d85\u7ea7\u7ec8\u70b9ed\uff0c\u7136\u540e\u7531\u6e90\u70b9\u5411\u6240\u6709\u4eba\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a1\uff0c\u8d39\u7528\u4e3a0\n\n\u63a5\u7740\u7531\u5de5\u4f5c\u5411\u6c47\u70b9\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a1\u8d39\u7528\u4e3a0\n\n\u4e0a\u9762\u6ee1\u8db3\u4e86\u6bcf\u4e2a\u4eba\u53ea\u505a\u4e00\u4ef6\u5de5\u4f5c\u4e14\u6bcf\u4ef6\u5de5\u4f5c\u53ea\u505a\u4e00\u6b21\u7684\u8981\u6c42\n\n\u6700\u540e\u7531\u4eba\u5411\u5de5\u4f5c\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a1\u8d39\u7528\u4e3a\u6536\u76ca\uff0c\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\u5373\u4e3a\u6700\u5c0f\u6536\u76ca\n\n\u7136\u540e\u628a\u4eba\u5411\u5de5\u4f5c\u8fde\u8fb9\u7684\u8fb9\u6743\u53d6\u8d1f\u503c\uff0c\u518d\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\uff0c\u6b64\u65f6\u6700\u5c0f\u8d39\u7528\u7684\u76f8\u53cd\u6570\u5373\u4e3a\u6700\u5927\u6536\u76ca\n\n\u8fd9\u9053\u9898\u5411\u6211\u4eec\u63d0\u793a\uff1a\u6700\u5927\u8d39\u7528\u6d41\u4e5f\u662f\u53ef\u4ee5\u8dd1\u7684\uff0c\u53ea\u662f\u5c06\u6240\u6709\u8d39\u7528\u53d6\u53cd\u540e\u8dd1\u6700\u5c0f\u8d39\u7528\u6d41\u5373\u53ef\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nstruct Edge\n{\n    int next;\n    int to;\n    int val;\n    int pri;\n}edge[20005];\nint head[255];\nint dis[255];\nint pre[255];\nint fa[255];\nint lim[255];\nbool used[255];\nint a[255][255];\nint cnt=1;\nint n;\nint st,ed;\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    memset(edge,0,sizeof(edge));\n    cnt=1;\n}\nvoid add(int l,int r,int w,int v)\n{\n    edge[cnt].next=head[l];\n    edge[cnt].to=r;\n    edge[cnt].val=w;\n    edge[cnt].pri=v;\n    head[l]=cnt++;\n}\nint ide(int x)\n{\n    return (x&1)?x+1:x-1;\n}\nbool spfa()\n{\n    memset(dis,0x3f,sizeof(dis));\n    memset(lim,0,sizeof(lim));\n    memset(used,0,sizeof(used));\n    dis[st]=0;\n    lim[st]=INF;\n    pre[ed]=-1;\n    used[st]=1;\n    queue <int> M;\n    M.push(st);\n    while(!M.empty())\n    {\n        int u=M.front();\n        M.pop();\n        for(int i=head[u];i!=-1;i=edge[i].next)\n        {\n            int to=edge[i].to;\n            if(edge[i].val&&dis[to]>dis[u]+edge[i].pri)\n            {\n                dis[to]=dis[u]+edge[i].pri;\n                lim[to]=min(lim[u],edge[i].val);\n                pre[to]=i;\n                fa[to]=u;\n                if(!used[to])used[to]=1,M.push(to);\n            }\n        }\n        used[u]=0;\n    }\n    return pre[ed]!=-1;\n}\nint EK()\n{\n    int maxw=0,minv=0;\n    while(spfa())\n    {\n        minv+=dis[ed]*lim[ed];\n        maxw+=lim[ed];\n        int temp=ed;\n        while(temp!=st)\n        {\n            edge[pre[temp]].val-=lim[ed];\n            edge[ide(pre[temp])].val+=lim[ed];\n            temp=fa[temp];\n        }\n    }\n    return minv;\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    init();\n    for(int i=2;i<=n+1;i++)\n    {\n        for(int j=n+2;j<=2*n+1;j++)\n        {\n            int x;\n            scanf(\"%d\",&x);\n            add(i,j,1,x);\n            add(j,i,0,-x);\n            a[i-1][j-n-1]=x;\n        }\n    }\n    st=1,ed=2*n+2;\n    for(int i=2;i<=n+1;i++)add(st,i,1,0),add(i,st,0,0);\n    for(int i=n+2;i<=2*n+1;i++)add(i,ed,1,0),add(ed,i,0,0);\n    printf(\"%d\\n\",EK());\n    init();\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            add(i+1,j+n+1,1,-a[i][j]);\n            add(j+n+1,i+1,0,a[i][j]);\n        }\n    }\n    st=1,ed=2*n+2;\n    for(int i=2;i<=n+1;i++)add(st,i,1,0),add(i,st,0,0);\n    for(int i=n+2;i<=2*n+1;i++)add(i,ed,1,0),add(ed,i,0,0);\n    printf(\"%d\\n\",-EK());\n    return 0;\n}\n```\n",
        "postTime": 1556234986,
        "uid": 66905,
        "name": "leozhang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "### \u9898\u610f\n\n**\u4e8c\u5206\u56fe\u5b8c\u7f8e\u5339\u914d**\n\n\u7528\u8d39\u7528\u6d41\u53ef\u4ee5\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u8fde\u8d85\u7ea7\u6c47\u6e90\u3002\n\n\u9898\u610f\u5373\u6c42\u4e00\u904d\u6700\u5927\u8d39\u7528\u6d41\uff0c\u4e00\u8fb9\u6700\u5c0f\u8d39\u7528\u5373\u53ef\n\n\u6c42\u6700\u5927\u8d39\u7528\u3002\u5176\u5b9e\u7c7b\u4f3c\u4e8e\u6c42\u6700\u957f\u8def\uff0c\u628a\u8fb9\u6743\u53d8\u8d1f\u6570\uff0c\u7136\u540e\u8dd1\u4e00\u8fb9\u5c31\u597d\u4e86\uff0c\u53d6\u7ed3\u679c\u76f8\u53cd\u6570\uff0c\u5e76\u4e0d\u9700\u8981\u6a21\u62df\u4e00\u904d\u53bb\u6539\n#\n### \u4ee3\u7801\nEK\uff08spfa+\u589e\u5e7f\u8def\uff09\n\n```cpp\n#include<bits/stdc++.h>\n#define inf 0x3f3f3f3f\nusing namespace std;\nconst int maxn=200+100,maxm=40000+100;\nint head[maxn],inq[maxn],cur[maxn];\nint dis[maxn],vis[maxn];\nint a[maxn][maxn];\nint pre[maxn],last[maxn],flow[maxn];\nint s,t,n;\nstruct edge\n{\n\tint to,next,cap,cost;\n}e[maxm];\nint size=1;\nvoid init()\n{\n\tmemset(dis,inf,sizeof(dis));\n\tmemset(inq,0,sizeof(inq));\n\tmemset(flow,inf,sizeof(flow));\n\tdis[s]=0;pre[t]=-1;\n}\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nvoid addedge(int u,int v,int val,int c)\n{\n\te[++size].to=v;e[size].cap=val;e[size].cost=c;e[size].next=head[u];head[u]=size;\n\te[++size].to=u;e[size].cap=0;e[size].cost=-c;e[size].next=head[v];head[v]=size;\n}\nbool spfa()\n{\n    init();\n    queue<int>q;\n    q.push(s);\n    inq[s]=1;\n    while(!q.empty())\n    {\n    \tint u=q.front();\n    \tq.pop();\n    \tinq[u]=0;\n    \tfor(int i=head[u];i;i=e[i].next)\n    \t{\n    \t\tint to=e[i].to;\n    \t\tif(e[i].cap>0&&dis[to]>dis[u]+e[i].cost)\n    \t\t{\n    \t\t\tdis[to]=e[i].cost+dis[u];\n    \t\t\tpre[to]=u;\n    \t\t\tlast[to]=i;\n    \t\t\tflow[to]=min(flow[u],e[i].cap);\n    \t\t\tif(!inq[to])\n    \t\t\t{\n    \t\t\t\tq.push(to);\n    \t\t\t\tinq[to]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[t]!=-1;\n}\nint mcmf()\n{\n\tint mc=0;\n\twhile(spfa())\n\t{\n\t\tint u=t;\n\t\tmc+=flow[t]*dis[t];\n\t    while(u!=s)\n\t    {\n\t      e[last[u]].cap-=flow[t];\n\t      e[last[u]^1].cap+=flow[t];\n\t      u=pre[u];\n\t\t}\n\t}\n\treturn mc;\n}\n\nint main()\n{\n\tn=read();\n\ts=0,t=n*2+1;\n\tfor(int i=1;i<=n;i++)\n\taddedge(s,i,1,0),addedge(i+n,t,1,0);\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t  a[i][j]=read(),addedge(i,j+n,1,a[i][j]);\n\tprintf(\"%d\\n\",mcmf());\n\tmemset(head,0,sizeof(head));\n\tmemset(e,0,sizeof(e));\n\tsize=1;\n\tfor(int i=1;i<=n;i++)\n\taddedge(s,i,1,0),addedge(i+n,t,1,0);\n\tfor(int i=1;i<=n;i++)\n\t  for(int j=1;j<=n;j++)\n\t  addedge(i,j+n,1,-a[i][j]);\n\tprintf(\"%d\\n\",-mcmf());\n\treturn 0;\n}\n```",
        "postTime": 1553245777,
        "uid": 58707,
        "name": "Edward_Elric",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "    \u7531\u4e8e\u672c\u4eba\u975e\u5e38\u849f\u84bb\uff0c\u6240\u4ee5\u53ea\u4f1a\u6253\u6a21\u677f\uff0c\u800c\u4e14\u8fd8\u5f97\u6253\u4e24\u6b21\u3002\n    \u81ea\u7136\u4ee3\u7801\u5341\u5206\u7e41\u7410\uff0c\u5176\u5b9e\u8fd9\u9053\u9898\u5c31\u662f\u4e00\u9053\u88f8\u7684\u6700\u5927\u6700\u5c0f\u8d39\u95ee\u9898\u3002\u7b80\u4fbf\u6613\u61c2\u3002\n    # include <iostream>\n    # include <cstdio>\n    # include <cstring>\n    # include <queue>\n    using namespace std;\n    const int N = 5010,M = 200010;\n    int ver1[M],ver2[M],edge1[M],edge2[M],cost1[M],cost2[M],Next1[M],Next2[M],head1[N],head2[N],d1[N],d2[N],incf1[N],incf2[N],pre1[N],pre2[N],v1[N],v2[N],n,k,tot1 = -1,tot2 = -1,s,t,maxflow1,maxflow2,ans1,ans2;\n    void add1(int x,int y,int z,int c){\n        ver1[++tot1] = y,edge1[tot1] = z,cost1[tot1] = c,Next1[tot1] = head1[x],head1[x] = tot1;\n        ver1[++tot1] = x,edge1[tot1] = 0,cost1[tot1] = -c,Next1[tot1] = head1[y],head1[y] = tot1;\n    }\n    void add2(int x,int y,int z,int c){\n        ver2[++tot2] = y,edge2[tot2] = z,cost2[tot2] = c,Next2[tot2] = head2[x],head2[x] = tot2;\n        ver2[++tot2] = x,edge2[tot2] = 0,cost2[tot2] = -c,Next2[tot2] = head2[y],head2[y] = tot2;\n    }\n    bool spfa1(){\n        queue<int> q1;\n        memset(d1,0x3f,sizeof(d1));\n        memset(v1,0,sizeof(v1));\n        q1.push(s);d1[s] = 0;v1[s] = 1;\n        incf1[s] = 1 << 30;\n        while(q1.size()){\n            int x1 = q1.front();v1[x1] = 0;q1.pop();\n            for(int i = head1[x1];i != -1;i = Next1[i]){\n                if(!edge1[i])continue;\n                int y1 = ver1[i];\n                if(d1[y1] > d1[x1] + cost1[i]){\n                    d1[y1] = d1[x1] + cost1[i];\n                    incf1[y1] = min(incf1[x1],edge1[i]);\n                    pre1[y1] = i;\n                    if(!v1[y1])v1[y1] = 1,q1.push(y1);\n                }\n            }\n        } \n        if(d1[t] == 0x3f3f3f3f)return false;\n        return true;\n    }\n    void update1(){\n        int x1 = t;\n        while(x1 != s){\n            int i1 = pre1[x1];\n            edge1[i1] -= incf1[t];\n            edge1[i1 ^ 1] += incf1[t];\n            x1 = ver1[i1 ^ 1];\n        }\n        maxflow1 += incf1[t];\n        ans1 += d1[t] * incf1[t];\n    }\n    bool spfa2(){\n        queue<int> q2;\n        memset(d2,0xcf,sizeof(d2));\n        memset(v2,0,sizeof(v2));\n        q2.push(s);d2[s] = 0;v2[s] = 1;\n        incf2[s] = 1 << 30;\n        while(q2.size()){\n            int x2 = q2.front();v2[x2] = 0;q2.pop();\n            for(int i = head2[x2];i != -1;i = Next2[i]){\n                if(!edge2[i])continue;\n                int y2 = ver2[i];\n                if(d2[y2] < d2[x2] + cost2[i]){\n                    d2[y2] = d2[x2] + cost2[i];\n                    incf2[y2] = min(incf2[x2],edge2[i]);\n                    pre2[y2] = i;\n                    if(!v2[y2])v2[y2] = 1,q2.push(y2);\n                }\n            }\n        } \n        if(d2[t] == 0xcfcfcfcf)return false;\n        return true;\n    }\n    void update2(){\n        int x2 = t;\n        while(x2 != s){\n            int i2 = pre2[x2];\n            edge2[i2] -= incf2[t];\n            edge2[i2 ^ 1] += incf2[t];\n            x2 = ver2[i2 ^ 1];\n        }\n        maxflow2 += incf2[t];\n        ans2 += d2[t] * incf2[t];\n    }\n    int main(){\n        memset(head1,-1,sizeof(head1));\n        memset(head2,-1,sizeof(head2));\n        cin >> n;t = 2 * n + 1;\n        for(int i = 1;i <= n;i++)add1(s,i,1,0),add2(s,i,1,0);\n        for(int i = 1;i <= n;i++)add1(n + i,t,1,0),add2(n + i,t,1,0);\n        for(int i = 1;i <= n;i++)\n            for(int j = 1;j <= n;j++){\n                int t5;scanf(\"%d\",&t5);\n                add1(i,n + j,1,t5),add2(i,n + j,1,t5);\n            }\n        while(spfa1())update1();\n        while(spfa2())update2();\n        cout << ans1 << endl;\n        cout << ans2 << endl; \n        return 0;\n    } \n",
        "postTime": 1548690496,
        "uid": 115797,
        "name": "\u7b80\u5b87\u537f",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    },
    {
        "content": "\u4e8c\u5206\u56fe\u6700\u5c0f/\u5927\u5e26\u6743\u5339\u914d\uff0c\u7528\u7f51\u7edc\u6700\u5c0f/\u5927\u8d39\u7528\u6700\u5927\u6d41\u5b9e\u73b0\n\n\u63d0\u4f9b\u7528Dijkstra\u8dd1\u6700\u5c0f\u8d39\u7528\u6d41\n\n\u5efa\u7acb\u8d85\u7ea7\u6e90\u70b9\uff0c\u4e0e\u6bcf\u4e00\u4e2a\u4eba\u8fde\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u5efa\u7acb\u8d85\u7ea7\u6c47\u70b9\uff0c\u6bcf\u4e00\u4e2a\u5de5\u4f5c\u4e0e\u5176\u8fde\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u4ebai\u548c\u5de5\u4f5cj\u8fde\u8d39\u7528\u4e3aCij\u7684\u8fb9\n\uff0c\u6240\u6709\u6b63\u5411\u8fb9\u7684\u6d41\u91cf\u4e3a1\uff0c\u53cd\u5411\u8fb9\u6d41\u91cf\u4e3a0\uff0c\u8d39\u7528\u4e3a\u5176\u6b63\u5411\u8d39\u7528\u7684\u76f8\u53cd\u6570\n\n\u7136\u540e\u8dd1\u6e90\u70b9\u6c47\u70b9\u7684\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\n\n\u9898\u76ee\u8fd8\u95ee\u6700\u5927\u8d39\u7528\uff0c\u628a\u6240\u6709\u8fb9\u8d39\u7528\u53d8\u4e3a\u76f8\u53cd\u6570\u3001\u6d41\u91cf\u8fd8\u539f\u518d\u8dd1\u4e00\u904d\u8f93\u51fa\u7ed3\u679c\u7684\u76f8\u53cd\u6570\u5373\u53ef\n\n\u7c7b\u4f3cJohnson\u7b97\u6cd5\uff0c\u8d4b\u4e88\u6bcf\u4e2a\u70b9\u4e00\u4e2a\u52bfh[]\uff0c\u4fdd\u8bc1\u6709\u8d1f\u8fb9\u65f6Dijkstra\u7684\u6b63\u786e\u6027\n\n```cpp\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<utility>\n#include<algorithm>\n#define rev(x) x%2?x+1:x-1\nusing namespace std;\ntemplate<class type>inline const void read(type &in)\n{\n    in=0;char ch=getchar();short fh=1;\n    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();\n    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();\n    in*=fh;\n}\ntypedef pair<int,int>node;\ntypedef priority_queue<node,vector<node>,greater<node> >heap;\nconst int N=500;\nint n,s,t;\nint head[N],cnt;\nstruct edge\n{\n\tint to,next,cost;bool flow;\n\tinline const void create(int u,int v,bool f,int w)\n\t{\n\t\tnext=head[u];\n\t\thead[u]=cnt;\n\t\tflow=f;\n\t\tcost=w;\n\t\tto=v;\n\t}\n}e[N*N];\ninline const void connect(int u,int v,int w)\n{\n\te[++cnt].create(u,v,1,w);\n\te[++cnt].create(v,u,0,-w);\n}\nbool inq[N];\nint h[N],preDot[N],preEdge[N];\ninline const void spfa() //\u5148\u8dd1\u4e00\u8fb9spfa\u786e\u8ba4h\u6570\u7ec4\n{\n\tfill(inq+1,inq+t+1,0);\n\tfill(h+1,h+t+1,INT_MAX);\n\tqueue<int>q;q.push(s);h[s]=0;inq[s]=1;\n\twhile (q.size())\n\t{\n\t\tint u=q.front();q.pop();\n\t\tfor (int v,i=head[u];i;i=e[i].next)\n\t\t\tif (e[i].flow&&h[v=e[i].to]>h[u]+e[i].cost)\n\t\t\t\tif (h[v]=h[u]+e[i].cost,!inq[v])\n\t\t\t\t\tinq[v]=1,q.push(v);\n\t}\n}\nint d[N];\nbool vis[N];\ninline const bool dijkstra()\n{\n\tfill(vis+1,vis+t+1,0);\n\tfill(d+1,d+t+1,INT_MAX);\n\theap q;q.push(make_pair(d[s]=0,s));\n\twhile (q.size())\n\t{\n\t\tint u=q.top().second;q.pop();\n\t\tif (vis[u])continue;vis[u]=1;\n\t\tfor (int v,i=head[u];i;i=e[i].next)\n\t\t\tif (e[i].flow&&!vis[v=e[i].to]&&d[v]>d[u]+e[i].cost+h[u]-h[v]) //\u52a0\u4e0a\u52bf\n\t\t\t\tpreDot[v]=u,preEdge[v]=i,\n\t\t\t\tq.push(make_pair(d[v]=d[u]+e[i].cost+h[u]-h[v],v));\n\t}\n\treturn d[t]!=INT_MAX;\n}\ninline const int dinic()\n{\n\tint cost=0;spfa();\n\tfor (int i=1;i<=cnt;i+=2)e[i].flow=1,e[i+1].flow=0; //\u8fd8\u539f\u6d41\u91cf\n\tfor (int i=1;i<=cnt;i++)e[i].cost*=-1; //\u597d\u50cfprintf\u7684\u8fd0\u7b97\u987a\u5e8f\u662f\u4ece\u540e\u5f80\u524d\uff0c\u6240\u4ee5\u8bf4\u5b83\u4f1a\u5148\u8fd0\u884c\u6700\u5927\u8d39\u7528\uff0c\u53d6\u4e86\u4e00\u6b21\u53cd\uff0c\u63a5\u4e0b\u6765\u8fd0\u884c\u6700\u5c0f\u8d39\u7528\uff0c\u53c8\u4f1a\u53d6\u53cd\u56de\u53bb\n\twhile (dijkstra())\n\t{\n\t\tfor (int i=1;i<=t;i++)h[i]+=d[i];\n\t\tbool mn=1;\n\t\tfor (int i=t;i!=s;i=preDot[i])\n\t\t\tmn=min(mn,e[preEdge[i]].flow);\n\t\tfor (int i=t;i!=s;i=preDot[i])\n\t\t\te[preEdge[i]].flow-=mn,\n\t\t\te[rev(preEdge[i])].flow+=mn;\n\t\tcost+=mn*h[t];\n\t}\n\treturn cost;\n}\nint main()\n{\n\tread(n);s=n+n+1;t=n+n+2; //\u5efa\u7acb\u8d85\u7ea7\u6e90\u70b9\u548c\u6c47\u70b9\n\tfor (int i=1;i<=n;i++)\n\t \tfor (int x,j=1;j<=n;j++)\n\t \t\tread(x),connect(i,j+n,x);\n\tfor (int i=1;i<=n;i++)connect(s,i,0);\n\tfor (int i=1;i<=n;i++)connect(i+n,t,0);\n\tprintf(\"%d\\n%d\\n\",dinic(),-dinic());\n\treturn 0;\n}\n```",
        "postTime": 1544964017,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4014 \u3010\u5206\u914d\u95ee\u9898\u3011"
    }
]