[
    {
        "content": "### [\u535a\u5ba2qwq](https://a-failure.github.io/2019/01/04/POI2007-%E6%A0%91Drz/)\n\n\u5206\u60c5\u51b5\u8ba8\u8bba\uff0c\u5047\u8bbe\u4ea4\u6362\u7684\u662f$i,j$\uff0c\u5219\u7b54\u6848\u662f$ans-val_i-val_j+\\vert h_i-L_j\\vert+\\vert h_i-R_j\\vert+\\vert h_j-L_i\\vert+\\vert h_j-R_i\\vert$\uff0c\u5176\u4e2d$val_i$\u8868\u793a\u539f\u6765$i$\u4f4d\u7f6e\u7684\u7b54\u6848\uff0c$L_i$\u8868\u793a$min(h_{i-1},h_{i+1})$\uff0c$R_i$\u8868\u793a$max(h_{i-1},h_{i+1})$\uff0c\u8fd9\u6837\u5c31\u6709\u4e86$3\\times 3=9$\u79cd\u60c5\u51b5\uff08\u2026\u2026\uff09\uff1a\n\n$h_i<L_j,h_i>R_j,L_j\\le h_i\\le R_j$\n\n$j$\u540c\u7406\n\n\u8fd9\u6837\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811+\u626b\u63cf\u7ebf\u505a\u4e86\uff0c\u5199\u8d77\u6765\u8fd8\u662f\u633a\u9ebb\u70e6\u7684~~\u5199\u51fa\u4e00\u79cd\u60c5\u51b5\u7136\u540e```ctrl+A+C+V```\u6539\u6539\u5c31\u884c\u4e86~~\n\n### \u4ee3\u7801\n```\n# include<iostream>\n# include<cstring>\n# include<cstdlib>\n# include<cstdio>\n# include<algorithm>\n# define tl (k<<1)\n# define tr (k<<1|1)\n# define mid (l+r>>1)\n# define LL long long\nusing namespace std;\nconst int MAX=5e4+5;\nstruct p{\n\tLL x;\n}s[MAX<<2];\nstruct q{\n\tint x,id;\n\tbool operator< (const q &a)\n\tconst{\n\t\treturn x<a.x;\n\t}\n}A[MAX],val[MAX],val_l[MAX],val_r[MAX];\nint n,m,_n;\nLL Ans;\nint h[MAX],H[MAX],_h[MAX],HL[MAX],HR[MAX],_H[MAX],_L[MAX],_R[MAX],__L[MAX],__R[MAX];\nLL ans[MAX];\nbool use[MAX];\nbool cmp(q a,q b) {return a.x>b.x;}\nvoid pus(int k) {s[k].x=min(s[tl].x,s[tr].x);}\nvoid change(int l,int r,int k,int x,LL dis)\n{\n\tif(l==r) return void(s[k].x=min(s[k].x,dis));\n\tif(x<=mid) change(l,mid,tl,x,dis);\n\telse change(mid+1,r,tr,x,dis);\n\tpus(k);\n}\nvoid update(int l,int r,int k,int x,LL dis)\n{\n\tif(l==r) return void(s[k].x=dis);\n\tif(x<=mid) update(l,mid,tl,x,dis);\n\telse update(mid+1,r,tr,x,dis);\n\tpus(k);\n}\nLL ask(int l,int r,int k,int L,int R)\n{\n\tif(r<L||R<l) return 1e18;\n\tif(l>=L&&r<=R) return s[k].x;\n\treturn min(ask(l,mid,tl,L,R),ask(mid+1,r,tr,L,R));\n}\nint read()\n{\n\tint x(0);\n\tchar ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar());\n\tfor(;isdigit(ch);x=x*10+ch-48,ch=getchar());\n\treturn x;\n}\nint look(int x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tif(_h[mid]<=x) ans=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ans;\n}\nint _look(int x)\n{\n\tint l=1,r=n,ans;\n\twhile(l<=r)\n\t{\n\t\tif(_h[mid]>=x) ans=mid,r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ans;\n}\nvoid Init()\n{\n\tmemcpy(_h,h,sizeof(h));\n\tsort(_h+1,_h+1+n);\n\tfor(int i=1;i<=n;++i)\n\t  {\n\t\tif(i!=1) _H[i]+=abs(h[i]-h[i-1]);\n\t\tif(i!=n) _H[i]+=abs(h[i]-h[i+1]);\n\t\tif(i!=1&&i!=n) HL[i]=min(h[i-1],h[i+1]),HR[i]=max(h[i-1],h[i+1]),_L[i]=_look(HL[i]),_R[i]=look(HR[i]),__L[i]=look(HL[i]),__R[i]=look(HR[i]);\n\t  }\n\tfor(int i=2;i<=n;++i)\n\t  Ans+=abs(h[i]-h[i-1]);\n\tfor(int i=1;i<=n;++i)\n\t  ans[i]=Ans;\n\tLL x;\n\tfor(int i=1;i<=n;++i)\n\t  {\n\t  \tif(i>2) ans[1]=min(ans[1],x=Ans-_H[i]-_H[1]+abs(h[i]-h[2])+abs(h[1]-h[i-1])+(i!=n?abs(h[1]-h[i+1]):0)),ans[i]=min(ans[i],x);\n\t  \tif(i<n-1) ans[n]=min(ans[n],x=Ans-_H[i]-_H[n]+abs(h[i]-h[n-1])+abs(h[n]-h[i+1])+(i!=1?abs(h[n]-h[i-1]):0)),ans[i]=min(ans[i],x);\n\t  \tif(i!=1) ans[i]=min(ans[i],Ans-(i!=n?abs(h[i]-h[i+1]):0)-(i>2?abs(h[i-1]-h[i-2]):0)+((i!=n&&i!=1)?abs(h[i-1]-h[i+1]):0)+(i>2?abs(h[i]-h[i-2]):0));\n\t  \tif(i!=n) ans[i]=min(ans[i],Ans-(i!=1?abs(h[i]-h[i-1]):0)-(i<n-1?abs(h[i+1]-h[i+2]):0)+((i!=n&&i!=1)?abs(h[i-1]-h[i+1]):0)+(i<n-1?abs(h[i]-h[i+2]):0));\n\t  }\n\tfor(int i=1;i<=n;++i)\n\t  val[i]=(q){h[i],i},val_l[i]=(q){HL[i],i},val_r[i]=(q){HR[i],i};\n}\nvoid Solve1()\n{\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tsort(val+2,val+n),sort(val_r+2,val_r+n);\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_r[L].x<=val[i].x&&L<n) x=val_r[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]-HR[x]-2*h[x]-_H[x]),++L;\n\t  \tx=val[i].id;\n\t\tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,1,__L[x])-_H[x]+2*h[x]+HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]-HR[x-1]-2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]-HR[x+1]-2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]-HR[x]-2*h[x]-_H[x]);\n\t  }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_r[L].x<=val[i].x&&L<n) x=val_r[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]-HR[x]+2*h[x]-_H[x]),++L;\n\t\tx=val[i].id;\n\t\tif(use[x-1])\n\t\tupdate(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) \n\t\tupdate(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,__R[x],n)-_H[x]+2*h[x]-HL[x]-HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]-HR[x-1]+2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]-HR[x+1]+2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]-HR[x]+2*h[x]-_H[x]);\n\t  }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_r[L].x<=val[i].x&&L<n) x=val_r[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]-HR[x]-_H[x]),++L;\n\t  \tx=val[i].id;\n\t\tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,_L[x],_R[x])-_H[x]+2*h[x]-HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]-HR[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]-HR[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]-HR[x]-_H[x]);\n\t  }\n}\nvoid Solve2()\n{\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tsort(val+2,val+n,cmp),sort(val_l+2,val_l+n,cmp);\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x>=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],HL[x]+HR[x]-2*h[x]-_H[x]),++L;\n\t  \tx=val[i].id;\n\t\tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,1,__L[x])-_H[x]-2*h[x]+HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],HL[x-1]+HR[x-1]-2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],HL[x+1]+HR[x+1]-2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],HL[x]+HR[x]-2*h[x]-_H[x]);\n\t  }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x>=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],HL[x]+HR[x]+2*h[x]-_H[x]),++L;\n\t  \tx=val[i].id;\n\t\tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,__R[x],n)-_H[x]-2*h[x]-HL[x]-HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],HL[x-1]+HR[x-1]+2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],HL[x+1]+HR[x+1]+2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],HL[x]+HR[x]+2*h[x]-_H[x]);\n\t  }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x>=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],HL[x]+HR[x]-_H[x]),++L;\n\t  \tx=val[i].id;\n\t  \tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,_L[x],_R[x])-_H[x]-2*h[x]-HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],HL[x-1]+HR[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],HL[x+1]+HR[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],HL[x]+HR[x]-_H[x]);\n\t  }\n}\nvoid Solve3()\n{\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tsort(val+2,val+n),sort(val_l+2,val_l+n),sort(val_r+2,val_r+n);\n\tfor(int i=2,L=2,R=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x<=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]+HR[x]-2*h[x]-_H[x]),++L;\n\t  \twhile(val_r[R].x<val[i].x&&R<n) x=val_r[R].id,use[x]=0,update(1,n,1,H[x],1e18),++R;\n\t  \tx=val[i].id;\n\t  \tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,1,__L[x])-_H[x]+HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]+HR[x-1]-2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]+HR[x+1]-2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]+HR[x]-2*h[x]-_H[x]);\n\t   }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,R=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x<=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]+HR[x]+2*h[x]-_H[x]),++L;\n\t  \twhile(val_r[R].x<val[i].x&&R<n) x=val_r[R].id,use[x]=0,update(1,n,1,H[x],1e18),++R;\n\t  \tx=val[i].id;\n\t  \tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,__R[x],n)-_H[x]-HL[x]-HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]+HR[x-1]+2*h[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]+HR[x+1]+2*h[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]+HR[x]+2*h[x]-_H[x]);\n\t   }\n\tmemset(s,1,sizeof(s));\n\tmemset(use,0,sizeof(use));\n\tfor(int i=2,L=2,R=2,x;i<n;++i)\n\t  {\n\t  \twhile(val_l[L].x<=val[i].x&&L<n) x=val_l[L].id,use[x]=1,change(1,n,1,H[x],-HL[x]+HR[x]-_H[x]),++L;\n\t  \twhile(val_r[R].x<val[i].x&&R<n) x=val_r[R].id,use[x]=0,update(1,n,1,H[x],1e18),++R;\n\t  \tx=val[i].id;\n\t  \tif(use[x-1]) update(1,n,1,H[x-1],1e18);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],1e18);\n\t\tif(use[x]) update(1,n,1,H[x],1e18);\n\t\tans[x]=min(ans[x],Ans+ask(1,n,1,_L[x],_R[x])-_H[x]-HL[x]+HR[x]);\n\t\tif(use[x-1]) update(1,n,1,H[x-1],-HL[x-1]+HR[x-1]-_H[x-1]);\n\t\tif(use[x+1]) update(1,n,1,H[x+1],-HL[x+1]+HR[x+1]-_H[x+1]);\n\t\tif(use[x]) update(1,n,1,H[x],-HL[x]+HR[x]-_H[x]);\n\t   }\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)\n\t  h[i]=read(),A[i]=(q){h[i],i};\n\tif(n==2) return printf(\"%d\\n%d\",abs(h[1]-h[2]),abs(h[1]-h[2])),0;\n\tsort(A+1,A+1+n);\n\tfor(int i=1;i<=n;++i)\n\t  H[A[i].id]=i;\n\tInit(),Solve1(),Solve2(),Solve3();\n\tfor(int i=1;i<=n;++i)\n\t  printf(\"%lld\\n\",ans[i]);\n\treturn 0;\n}\n```\n",
        "postTime": 1546606625,
        "uid": 49206,
        "name": "Dispwnl",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3453 \u3010[POI2007]DRZ-Trees\u3011"
    },
    {
        "content": "\u7f51\u4e0a\u7684\u9898\u89e3\u5176\u5b9e\u633a\u8be6\u7ec6\u4e86\uff0c\u6211\u5c31\u4e3e\u4e00\u4e2a\u4f8b\u5b50\u8bf4\u4e00\u4e0b\u601d\u60f3\u662f\u4ec0\u4e48\u5427\n\n\u6211\u4eec\u5148\u5b9a\u4e49\u4e00\u4e9b\u53d8\u91cf\n\n$$i$$,$$L_i=min(H_{i-1},H_{i+1})$$,$$R_i=max(H_{i-1},H_{i+1})$$\n\n$$j$$,$$L_j=mjn(H_{j-1},H_{j+1})$$,$$R_j=max(H_{j-1},H_{j+1})$$\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u8fd9\u4e2a\u5173\u7cfb\n\n\n$$L_j<=H_i<=R_j$$\n\n$$L_i<=H_j<=R_i$$\n\n\u7b54\u6848\u5c31\u662f\n\n$$old_ans=|H_j-L_j|+|H_j-R_j|+|H_i-L_i|+|H_i-R_i|$$\n$$new\\_ans=|H\\_i-L\\_j|+|H\\_i-R\\_j|+|H\\_j-L\\_i|+|H\\_j-R\\_i|=\n(R\\_i-L\\_i)+(R\\_j-L\\_j)$$\n\n\n\u5982\u679c\u6211\u4eec\u628a$$H_i$$\u9012\u589e\u6392\u5e8f\uff0c\u53ef\u4ee5\u8bc1\u660e\u6bcf\u4e2a$$[L_j,R_j]$$\u7684\u9650\u5236\u53ea\u4f1a\u51fa\u73b0\u4e00\u6b21\uff0c\u6d88\u5931\u4e00\u6b21\n\n\u6240\u4ee5\u6211\u4eec\u628a$$H_j$$\u4e22\u5230\u7ebf\u6bb5\u6811\u91cc\u9762\uff0c\u67e5\u8be2$$[L_i,R_i]$$\u5c31\u884c\u4e86\n\n\u4e71\u7528auto\u5bfc\u81f4bz\u4ea4\u4e0d\u4e8623333\n\n```cpp\n#pragma GCC optimize (\"O2\")\n#include <bits/stdc++.h>\n#define cmax(a,b) (a<b?a=b:a)\n#define cmin(a,b) (a>b?a=b:a)\n#define R(i,k) for(int i=0;i<(k);++i)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=5e4+50;\nconst ll INF=1e12; \n\nint n,rk[N],rkl[N],rkr[N]; \nll h[N],res[N],raw,l[N],r[N],val[N];\n\nvoid ReadData(){\n    scanf(\"%d\",&n); \n    for(int i=1;i<=n;++i)\n        scanf(\"%lld\",&h[i]); \n}\n\nll cal(int x,int y)\n{\n     if (x==y) return raw;\n     if (x>y) swap(x,y);\n     if (x==1&&y==n) \n         return raw-abs(h[1]-h[2])-abs(h[n-1]-h[n])+abs(h[n]-h[2])+abs(h[1]-h[n-1]);\n     if (x==1&&y==2) return raw-abs(h[2]-h[3])+abs(h[1]-h[3]);\n     if (x==n-1&&y==n) return raw-abs(h[n-1]-h[n-2])+abs(h[n-2]-h[n]);\n     if (x+1==y) return \n         raw-abs(h[x-1]-h[x])-abs(h[y+1]-h[y])+abs(h[x]-h[y+1])+abs(h[y]-h[x-1]);\n     long long ans=raw;\n     if (x!=1) ans=ans-abs(h[x-1]-h[x])+abs(h[x-1]-h[y]);\n     ans=ans-abs(h[x+1]-h[x])+abs(h[x+1]-h[y]);\n     ans=ans-abs(h[y-1]-h[y])+abs(h[y-1]-h[x]);\n     if (y!=n) ans=ans-abs(h[y+1]-h[y])+abs(h[y+1]-h[x]);\n     return ans;\n}\n\nll g(int i){ return abs(h[i]-h[i-1])+abs(h[i+1]-h[i]); }\n\nvoid Init(){\n    //\u5e76\u4e0d\u80fd\u53bb\u91cd\n    static int id[N]; int i;\n    for(i=1;i<=n;++i)id[i]=i,val[i]=h[i];\n    sort(id+1,id+n+1,[](int a,int b){return h[a]<h[b];});\n    sort(val+1,val+n+1);\n    for(i=1;i<=n;++i){\n        rk[id[i]]=i;\n    }\n    for(i=2;i+1<=n;++i){\n        l[i]=min(h[i-1],h[i+1]); \n        r[i]=max(h[i-1],h[i+1]); \n        rkl[i]=lower_bound(val+1,val+n+1,l[i])-val;\n        rkr[i]=upper_bound(val+1,val+n+1,r[i])-val-1; \n    }\n}\n\nvoid CheckForSpecailCases(){\n    int i;\n    for(i=2;i<=n;++i)raw+=abs(h[i]-h[i-1]); \n    for(i=1;i<=n;++i)res[i]=raw; \n    for(i=1;i<n;i++)cmin(res[i],cal(i,i+1));\n    for(i=2;i<=n;i++)cmin(res[i],cal(i,i-1));\n    for(i=2;i<=n;i++)cmin(res[1],cal(1,i)),cmin(res[i],cal(1,i));\n    for(i=1;i<n;i++)cmin(res[n],cal(n,i)),cmin(res[i],cal(n,i));\n}\n\nnamespace ST{\n#define ls (v<<1)\n#define rs (v<<1^1)\n#define mid ((l+r)>>1)\n    const int S=N<<2; \n    struct D { ll a[3]; } t[S],temp;\n    int st,ed,pos; \n    void up(int v){\n        R(k,3) t[v].a[k]=min(t[ls].a[k],t[rs].a[k]); \n    }\n    void setInf(){\n        R(k,3) temp.a[k]=INF;\n    }\n    void clear(){\n        memset(t,0x3f,sizeof(t));\n        setInf(); \n    }\n    D& get() { return temp; }\n    void _update(int v,int l,int r){\n        if(r<pos||l>pos);\n        else if(l==pos&&r==pos){\n            t[v]=temp; \n        }else{\n            _update(ls,l,mid);\n            _update(rs,mid+1,r); \n            up(v); \n        }\n    }\n    void update(int _pos){ pos=_pos,_update(1,1,n); }\n    void _query(int v,int l,int r){\n        if(r<st||l>ed)return;\n        else if(st<=l&&r<=ed){\n            R(k,3) cmin(temp.a[k],t[v].a[k]); \n        }else{\n            _query(ls,l,mid); \n            _query(rs,mid+1,r); \n        }\n    }\n    D query(int l,int r){\n        st=l; ed=r; setInf(); \n        _query(1,1,n); \n        return temp;\n    }\n    /*\n    void setInf(){\n        R(k,3) temp.a[k]=INF;\n    }\n    D query(int l,int r){\n        setInf(); \n        for(int i=l;i<=r;++i)R(k,3)cmin(temp.a[k],t[i].a[k]); \n        return temp;\n    }\n    void update(int p){\n        t[p]=temp; \n    }\n    void clear(){\n        memset(t,0x3f,sizeof(t));\n        setInf(); \n    }\n    D& get() { return temp; }\n    */\n#undef ls \n#undef rs\n#undef mid\n}\n\nint top,aj[N]; bool in[N]; \nint ajl[N],ajr[N],ai[N],topl,topr;\nvoid Solve1(){\n    int i,k; ST::D ans; \n    ST::clear();\n    for(i=2;i+1<=n;++i)\n        aj[i]=ai[i]=i;\n    sort(ai+2,ai+n,[](int a,int b){ return h[a]>h[b]; }); \n    sort(aj+2,aj+n,[](int a,int b){ return l[a]>l[b]; }); \n    auto setData=[](ST::D &x,int j){\n        ll now=g(j); \n        x.a[0]=-now+l[j]+r[j]-2*h[j];\n        x.a[1]=-now+l[j]+r[j];\n        x.a[2]=-now+l[j]+r[j]+2*h[j]; \n    };\n    top=2; \n    memset(in,0,sizeof(in)); \n    for(k=2;k+1<=n;++k){\n        i=ai[k]; \n        for(;top+1<=n&&h[i]<=l[aj[top]];++top){\n            setData(ST::get(),aj[top]);\n            in[aj[top]]=true;\n            ST::update(rk[aj[top]]); \n        }\n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                ST::setInf(); \n                ST::update(rk[i+d]);\n            }\n        }\n        ll now=g(i);\n        ans=ST::query(1,rkl[i]); \n        cmin(res[i],raw-now+ans.a[0]+l[i]+r[i]-2*h[i]); \n        ans=ST::query(rkl[i],rkr[i]); \n        cmin(res[i],raw-now+ans.a[1]-l[i]+r[i]-2*h[i]); \n        ans=ST::query(rkr[i],n); \n        cmin(res[i],raw-now+ans.a[2]-l[i]-r[i]-2*h[i]); \n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                setData(ST::get(),i+d); \n                ST::update(rk[i+d]);\n            }\n        }\n    }\n}\n\nvoid Solve2(){\n    int i,k; ST::D ans; \n    ST::clear(); \n    for(i=2;i+1<=n;++i)\n        aj[i]=ai[i]=i;\n    sort(ai+2,ai+n,[](int a,int b){ return h[a]<h[b]; }); \n    sort(aj+2,aj+n,[](int a,int b){ return r[a]<r[b]; }); \n    auto setData=[](ST::D &x,int j){\n        ll now=g(j); \n        x.a[0]=-now-l[j]-r[j]-2*h[j]; \n        x.a[1]=-now-l[j]-r[j]; \n        x.a[2]=-now-l[j]-r[j]+2*h[j];\n    };\n    top=2; \n    memset(in,0,sizeof(in)); \n    for(k=2;k+1<=n;++k){\n        i=ai[k]; \n\n        for(;top+1<=n&&r[aj[top]]<=h[i];++top){\n            setData(ST::get(),aj[top]);\n            in[aj[top]]=true;\n            ST::update(rk[aj[top]]); \n        }\n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                ST::setInf(); \n                ST::update(rk[i+d]);\n            }\n        }\n\n        ll now=g(i); \n        ans=ST::query(1,rkl[i]); \n        cmin(res[i],ans.a[0]+raw-now+l[i]+r[i]+2*h[i]);\n        ans=ST::query(rkl[i],rkr[i]); \n        cmin(res[i],ans.a[1]+raw-now-l[i]+r[i]+2*h[i]); \n        ans=ST::query(rkr[i],n); \n        cmin(res[i],ans.a[2]+raw-now-l[i]-r[i]+2*h[i]); \n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                setData(ST::get(),i+d); \n                ST::update(rk[i+d]);\n            }\n        }\n    }\n}\n\nvoid Solve3(){\n    int i,k; ST::D ans; \n    ST::clear(); \n    for(i=2;i+1<=n;++i)\n        ajl[i]=ajr[i]=ai[i]=i;\n    sort(ai+2,ai+n,[](int a,int b){ return h[a]<h[b]; }); \n    sort(ajl+2,ajl+n,[](int a,int b){ return l[a]<l[b]; }); \n    sort(ajr+2,ajr+n,[](int a,int b){ return r[a]<r[b]; }); \n    auto setData=[](ST::D &x,int j){\n        ll now=g(j); \n        x.a[0]=-now-l[j]+r[j]-2*h[j]; \n        x.a[1]=-now-l[j]+r[j]; \n        x.a[2]=-now-l[j]+r[j]+2*h[j];\n    };\n    topl=topr=2; \n    memset(in,0,sizeof(in)); \n    for(k=2;k+1<=n;++k){\n        i=ai[k]; \n\n        for(;topl+1<=n&&h[i]>=l[ajl[topl]];++topl){\n            setData(ST::get(),ajl[topl]);\n            in[ajl[topl]]=true;\n            ST::update(rk[ajl[topl]]); \n        }\n        for(;topr+1<=n&&r[ajr[topr]]<h[i];++topr){\n            ST::setInf(); \n            in[ajr[topr]]=false;\n            ST::update(rk[ajr[topr]]); \n        }\n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                ST::setInf(); \n                ST::update(rk[i+d]);\n            }\n        }\n\n        ll now=g(i); \n        ans=ST::query(1,rkl[i]); \n        cmin(res[i],ans.a[0]+raw-now+l[i]+r[i]);\n        ans=ST::query(rkl[i],rkr[i]); \n        cmin(res[i],ans.a[1]+raw-now-l[i]+r[i]); \n        ans=ST::query(rkr[i],n); \n        cmin(res[i],ans.a[2]+raw-now-l[i]-r[i]); \n\n        for(int d=-1;d<=1;++d){\n            if(in[i+d]){\n                setData(ST::get(),i+d); \n                ST::update(rk[i+d]);\n            }\n        }\n    }\n\n}\n\nint main(int argc,char *argv[]){\n#ifndef ONLINE_JUDGE\n    freopen(\"dat.in\",\"r\",stdin); \n    freopen(\"my.out\",\"w\",stdout); \n#endif\n    int i;\n    ReadData(); \n    Init(); \n    if(n<=2) { \n        ll t=abs(h[1]-h[2]); \n        printf(\"%lld\\n%lld\\n\",t,t); \n        return 0; \n    }\n    CheckForSpecailCases(); \n    Solve1(); \n    Solve2(); \n    Solve3(); \n    for(i=1;i<=n;++i)printf(\"%lld\\n\",res[i]); \n    return 0; \n}\n```",
        "postTime": 1509148950,
        "uid": 24745,
        "name": "CuriousCat",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3453 \u3010[POI2007]DRZ-Trees\u3011"
    }
]