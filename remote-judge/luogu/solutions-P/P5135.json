[
    {
        "content": "\u6211\u4eec\u8003\u8651\u8f6c\u5316\u9898\u610f\uff0c\u9898\u76ee\u8981\u6c42\n\n$$\\sum\\limits_{i_1=1}^n\\sum\\limits_{i_2=i_1+opt}^n...\\sum\\limits_{i_m=i_{m-1}+opt}^n1$$\n\n\u7136\u540e\u6211\u4eec\u5206\u60c5\u51b5\u8ba8\u8bba\u4e00\u4e0b\n\n- \u82e5opt=1\uff0c\u90a3\u4e48\u7b54\u6848\u5373\u4e3a$\\binom{n}{m}$\n- \u82e5opt=0\uff0c\u90a3\u4e48\u5e8f\u5217$i_1,i_2,...,i_m$\u5fc5\u7136\u662f\u4e2a\u4e0d\u51cf\u5e8f\u5217\uff0c\u6211\u4eec\u4ee4$A_k=i_k+k$\uff0c\u90a3\u4e48\u5e8f\u5217$A$\u5fc5\u7136\u662f\u4e2a\u4e25\u683c\u9012\u589e\u5e8f\u5217\uff0c\u5e76\u4e14\u53d6\u503c\u5728$(1,n+m]$\uff0c\u6240\u4ee5\u7b54\u6848\u5373\u4e3a$\\binom{n+m-1}{m}$\uff08\u63d2\u677f\u6cd5\u540c\u6837\u53ef\u4ee5\u89e3\u51b3\uff09\n\n\u7136\u540e\u6ce8\u610f\u6c42$\\binom{n}{m}$\u9700\u8981for\u5faa\u73af\uff0c\u590d\u6742\u5ea6$O(Tm)$\n\n```cpp\n/*program from Wolfycz*/\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define inf 0x7f7f7f7f\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ninline char gc(){\n    static char buf[1000000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++;\n}\ninline int frd(){\n    int x=0,f=1;char ch=gc();\n    for (;ch<'0'||ch>'9';ch=gc())\tif (ch=='-')    f=-1;\n    for (;ch>='0'&&ch<='9';ch=gc())\tx=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar())\tif (ch=='-')\tf=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar())\tx=(x<<1)+(x<<3)+ch-'0';\n    return x*f;\n}\ninline void print(int x){\n    if (x<0)    putchar('-'),x=-x;\n    if (x>9)\tprint(x/10);\n    putchar(x%10+'0');\n}\nconst int N=1e6,p=1e9+7;\nint inv[N+10];\nint C(ll n,int m){\n    if (n<m)\treturn 0;\n    int res=1;\n    for (int i=1;i<=m;i++)\tres=1ll*res*((n-i+1)%p)%p*inv[i]%p;\n    return res;\n}\nint main(){\n    inv[1]=1;\n    for (int i=2;i<=N;i++)\tinv[i]=1ll*(p-p/i)*inv[p%i]%p;\n    for (int Data=read();Data;Data--){\n        ll n; int m,opt;\n        scanf(\"%lld%d%d\",&n,&m,&opt);\n        printf(\"%d\\n\",opt?C(n,m):C(n+m-1,m));\n    }\n    return 0;\n}\n```",
        "postTime": 1545696572,
        "uid": 21633,
        "name": "Wolfycz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5135 \u3010painting\u3011"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P5135)\n## \u524d\u7f6e\u77e5\u8bc6\n\n\u4f17\u6240\u5468\u77e5\uff0c\u7ec4\u5408\u6709\u4e24\u79cd\uff1a\u975e\u91cd\u7ec4\u5408\u548c\u53ef\u91cd\u7ec4\u5408\u3002\u975e\u91cd\u7ec4\u5408\u7684\u516c\u5f0f\u662f $C^m_n$\uff0c\u53ef\u91cd\u7ec4\u5408\u7684\u662f $C^m_{n+m-1}$\u3002\u65e2\u7136\u5df2\u7ecf\u5728\u9898\u76ee\u6807\u7b7e\u91cc\u770b\u5230\u4e86\u201c\u7ec4\u5408\u6570\u5b66\u201d\uff08\uff1f\uff09\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u60f3\u529e\u6cd5\u5c06\u8fd9\u4e24\u79cd\u7ec4\u5408\u4e0e\u8fd9\u9053\u9898\u7ed3\u5408\u5728\u4e00\u8d77\u3002\n\n## \u9898\u76ee\u5206\u6790\n\n\u6211\u4eec\u901a\u8fc7 $opt$ \u7684\u503c\u6765\u5206\u7c7b\u8ba8\u8bba\u3002\n\n### $opt$ \u7684\u503c\u4e3a $1$\n\n\u56e0\u4e3a Wolfycz \u60f3\u8981\u7684\u662f $m$ \u4e2a\u4e0d\u76f8\u7b49\u7684\u884c\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u8fde\u7ebf\u5ffd\u7565\u4e0d\u7ba1\uff0c\u56e0\u4e3a\u6211\u4eec\u53ea\u8981\u5f97\u5230\u4e86 $m$ \u4e2a\u4e0d\u76f8\u7b49\u7684\u884c\u6570\uff0c\u5c06\u5b83\u4eec\u6392\u5e8f\u4e00\u4e0b\u5c31\u662f\u4e25\u683c\u4e0b\u964d\u7684\u8fde\u7ebf\u4e86\u3002\u56e0\u6b64\u53ef\u4ee5\u53d1\u73b0\uff0c\u8fd9\u4e0d\u5c31\u662f\u6c42\u975e\u91cd\u7ec4\u5408\u5417\uff1f\u7684\u786e\uff0c\u53ea\u8981\u7528\u4e00\u4e0b\u4e0a\u6587\u6240\u8bf4\u7684\u975e\u91cd\u7ec4\u5408\u7684\u516c\u5f0f\u5373\u53ef\uff08\u521a\u521a\u8bf4\u7684\u6392\u5e8f\u5176\u5b9e\u662f\u9898\u5916\u8bdd\uff0c\u56e0\u4e3a\u6211\u4eec\u5e76\u4e0d\u9700\u8981\u6c42\u51fa\u4e00\u4e2a\u7ec4\u5408\uff0c\u53ea\u662f\u6c42\u7ec4\u5408\u6570\u800c\u5df2\uff09\u3002\n\n### $opt$ \u7684\u503c\u4e3a $0$\n\n\u548c\u4e0a\u9762\u90a3\u79cd\u60c5\u51b5\u5dee\u4e0d\u591a\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5c31\u53ef\u4ee5\u53d1\u73b0\uff0c\u968f\u4fbf\u5f04\u51fa $m$ \u4e2a\u53ef\u4ee5\u76f8\u7b49\u7684\u884c\u6570\uff0c\u7136\u540e\u5c06\u5b83\u4eec\u6392\u4e00\u4e0b\u5e8f\uff0c\u5b83\u4eec\u5c31\u80af\u5b9a\u4f1a\u53d8\u6210\u4e0d\u4e0a\u5347\u7684\u8fde\u7ebf\u3002\u56e0\u6b64\u8fd9\u5c31\u662f\u53ef\u91cd\u7ec4\u5408\u3002\u548c\u4e0a\u9762\u7684\u60c5\u51b5\u4e00\u6837\uff0c\u7528\u53ef\u91cd\u7ec4\u5408\u7684\u516c\u5f0f\uff08$C^m_{n+m-1}$\uff09\u5373\u53ef\u3002\n\n## \u4ee3\u7801\u5b9e\u73b0\n\n\uff08\u4e0b\u9762\u7528 Lucas \u5b9a\u7406\u5176\u5b9e\u662f\u5927\u6750\u5c0f\u7528\uff0c\u628a Lucas \u90e8\u5206\u5220\u6389\u76f4\u63a5\u7528\u666e\u901a\u7684 $C$ \u7b97\u7ec4\u5408\u6570\u5e94\u8be5\u4e5f\u53ef\u4ee5\uff09\n\n```cpp\n#include<cstdio>\n#define int long long\nusing namespace std;\nconst int maxn=1e6;\nconst int mod=1e9+7;\nint t,n,m,opt,inv[maxn+1];\ninline int pow(int a,int b,int p){\n\tint res=1;\n\twhile(b){\n\t\tif(b&1) res=res*a%p;\n\t\tb>>=1,a=a*a%p;\n\t}\n\treturn res;\n}\ninline int C(int n,int m,int p){\n\tif(m>n) return 0;\n\tint x=1,y=1;\n\tfor(int i=1;i<=m;++i) x=x*(n-i+1)%p,y=y*i%p;\n\treturn x*pow(y,p-2,p)%p;//\u7528\u9006\u5143\u6c42\u7ec4\u5408\u6570\n}\ninline int Lucas(int n,int m,int p){\n\tif(m==0) return 1;\n\treturn C(n%p,m%p,p)*Lucas(n/p,m/p,p)%p;\n}\nsigned main(){\n\tscanf(\"%lld\",&t);\n\twhile(t--){\n\t\tscanf(\"%lld%lld%lld\",&n,&m,&opt);\n\t\tif(opt==1) printf(\"%lld\\n\",Lucas(n,m,mod));\n\t\telse printf(\"%lld\\n\",Lucas(n+m-1,m,mod));\n\t}\n\treturn 0;\n}\n```\n\n## \u5199\u5728\u6700\u540e\n\n\u5e0c\u671b\u8fd9\u7bc7\u9898\u89e3\u80fd\u8ba9\u5927\u5bb6\u6709\u6240\u6536\u83b7\uff0c\u6709\u6240\u6536\u83b7\u7684\u540c\u65f6\u4e0d\u8981\u5fd8\u4e86\u7559\u4e0b\u4e00\u4e2a\u514d\u8d39\u7684\u8d5e\uff08",
        "postTime": 1657111245,
        "uid": 324350,
        "name": "xiaomuyun",
        "ccfLevel": 5,
        "title": "P5135 painting \u9898\u89e3"
    },
    {
        "content": "~~\u8fd9\u9898\uff0c\u7d2b\u7684\uff1f\uff1f\u7b97\u4e86\u4e0d\u7ba1\u4e86\u53cd\u6b63\u8fd9\u6837\u6c34\u4e2a\u7d2b\u9898\u89e3\u4e5f\u4e0d\u9519~~\n## \u9898\u610f\n\u5728\u6bcf\u4e00\u5217\u6d82\u4e00\u4e2a\u9ed1\u683c\u5b50\uff0c\u4f7f\u6bcf\u5217\u9ed1\u683c\u5b50\u8fde\u8d77\u6765\u4e25\u683c\u9012\u51cf\u6216\u975e\u4e25\u683c\u9012\u51cf\u3002\n## \u89e3\u6cd5\n\u5148\u8bf4\u4e25\u683c\u9012\u51cf\u7684\u60c5\u51b5\uff0c\u8fd9\u79cd\u60c5\u51b5\u6211\u4eec\u662f\u4ece $n$ \u884c\u79cd\u627e\u51fa $m$ \u884c\u6765\u6d82\u9ed1\uff0c\u540c\u65f6\u4fdd\u8bc1\uff0c\u8fd9 $m$ \u884c\u4e24\u4e24\u4e4b\u95f4\u90fd\u4e0d\u76f8\u7b49\uff0c\u6240\u4ee5\u5c31\u662f $C(n,m)$\u3002\n\n\u7136\u540e\u662f\u975e\u4e25\u683c\u9012\u51cf\u7684\u60c5\u51b5\uff0c\u5f53\u524d\u5217\u548c\u4e0b\u4e00\u5217\u53ef\u80fd\u76f8\u7b49\u53ef\u80fd\u4e0d\u7b49\uff0c\u90a3\u6211\u4eec\u5c31\u76f8\u5f53\u4e8e\u603b\u5171\u591a\u4e86 $m - 1$ \u79cd\u9009\u62e9\uff1b\u53e6\u4e00\u79cd\u89e3\u91ca\u201c\u9694\u677f\u6cd5\u201d\uff1a\u9664\u4e86\u7b2c\u4e00\u5217\uff0c\u5047\u8bbe\u540e\u9762\u7684\u6bcf\u4e00\u5217\u90fd\u5fc5\u5b9a\u4e0b\u964d\u4e00\u4e2a\uff0c\u7136\u540e\u5c31\u6ca1\u6709\u76f8\u7b49\u7684\u53ef\u80fd\u4e86\uff0c\u4e8e\u662f\u5c31\u662f $C(n + m - 1, m)$\uff0c\u8fd9\u4e2a\u4e1c\u897f\u4e5f\u4e0d\u597d\u89e3\u91ca\uff0c\u53ef\u4ee5\u53bb\u5b66\u4e00\u5b66\u9ad8\u4e2d\u6570\u5b66\uff0c\u611f\u53d7\u4e00\u4e0b\u5b9e\u9645\u610f\u4e49\u80fd\u4fbf\u4e8e\u7406\u89e3\u3002\n\n## lucas \u5b9a\u7406\n\u53ef\u4ee5\u770b\u5230 $n$ \u975e\u5e38\u5927\uff0c\u968f\u4fbf\u4e00\u4e58\u5c31\u7206\u4e86\uff0c\u800c\u4e14\u6a21\u6570\u4e8b\u8d28\u6570\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u5362\u5361\u65af\u5b9a\u7406\u554a\u3002\n\n\u90a3\u5c31\u76f4\u63a5\u4e0a\u5b9a\u7406\u3002\n\n$C(n, m) = C(\\frac{n}{p}, \\frac{m}{p})$ $\\times$ $C(n\\ \\bmod p, m \\bmod p)$\n\n## \u4ee3\u7801\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nconst int mod = 1e9 + 7;\nusing namespace std;\nint t, n, m, op, fac[1000010];\nint quick_pow(int a, int b)\n{\n\tint res = 1;\n\twhile(b)\n\t{\n\t\tif(b & 1) (res *= a) %= mod;\n\t\t(a *= a) %= mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\nint C(int x, int y)\n{\n\tif(x < y) return 0;\n\tif(x < mod && y < mod)\n\t{\n\t\tint a = 1, b = 1;\n\t\tfor (int i = x; i >= x - y + 1; i--) (a *= i) %= mod;\n\t\treturn a * quick_pow(fac[y], mod - 2) % mod;//\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u9006\u5143\n\t}\n\treturn C(x / mod, y / mod) * C(x % mod, y % mod) % mod;\n}\nsigned main()\n{\n\tscanf(\"%lld\", &t);\n\tfac[0] = fac[1] = 1;\n\tfor (int i = 2; i <= 1000000; i++) fac[i] = (fac[i - 1] * i) % mod;\n\twhile(t--)\n\t{\n\t\tscanf(\"%lld%lld%lld\", &n, &m, &op);\n\t\tif(op == 1) printf(\"%lld\\n\", C(n, m));\n\t\telse printf(\"%lld\\n\", C(n + m - 1, m));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1663921117,
        "uid": 453100,
        "name": "Tzs_yousa",
        "ccfLevel": 4,
        "title": "P5135\u9898\u89e3"
    },
    {
        "content": "\u57fa\u7840\u7ec4\u5408\u6570\u5b66\uff0c\u96be\u5ea6\u8c8c\u4f3c\u6ca1\u6709\u7d2b\u5427\uff08\n\n## \u5206\u6790\n\n\u5bf9\u4e8e $opt=0,1$ \u5206\u522b\u8003\u8651\u4e00\u4e0b\u3002\n\n### case 1: $opt=1$\n\n\u8003\u8651\u4ece $n$ \u884c\u4e2d\u9009\u62e9\u4e0d\u540c\u7684 $m$ \u884c\u3002\u6b64\u65f6\uff0c\u5c06\u6240\u6709\u9009\u51fa\u7684\u884c\u6392\u5e8f\uff0c\u6211\u4eec\u53d1\u73b0\u6b63\u597d\u6bcf\u4e00\u884c\u53ef\u4ee5\u5bf9\u5e94\u4e00\u5217\u7684\u9009\u62e9\u3002\u6240\u4ee5\uff0c\u5f53 $opt=1$ \u65f6\uff0c\u7b54\u6848\u5c31\u662f\u4ece $n$ \u884c\u4e2d\u9009\u62e9\u4e0d\u540c\u7684 $m$ \u884c\u7684\u65b9\u6848\u6570\uff0c\u4e5f\u5c31\u662f $C_n^m$\u3002\n\n### case 2: $opt=0$\n\n\u8003\u8651\u4ece $n$ \u884c\u4e2d\u9009\u62e9\u53ef\u4ee5\u76f8\u540c\u7684 $m$ \u884c\u3002\u6b64\u65f6\uff0c\u5c06\u6240\u6709\u9009\u51fa\u7684\u884c\u6392\u5e8f\uff0c\u6211\u4eec\u53d1\u73b0\u6b63\u597d\u6bcf\u4e00\u884c\u53ef\u4ee5\u5bf9\u5e94\u4e00\u5217\u7684\u9009\u62e9\u3002\u6240\u4ee5\uff0c\u5f53 $opt=0$ \u65f6\uff0c\u7b54\u6848\u5c31\u662f\u4ece $n$ \u884c\u4e2d\u9009\u62e9\u53ef\u4ee5\u76f8\u540c\u7684 $m$ \u884c\u7684\u65b9\u6848\u6570\uff0c\u4e5f\u5c31\u662f $C_{n+m-1}^m$\u3002\n\n\u5176\u5b9e\uff0c\u4ee5\u4e0a\u4e24\u4e2a $opt=0,1$ \u6b63\u597d\u5bf9\u5e94\u7740\u6392\u5217\u7ec4\u5408\u4e24\u79cd\u9009\u62e9\u65b9\u6848\uff0c\u4e5f\u662f\u6bd4\u8f83\u57fa\u7840\u7684\u6392\u5217\u7ec4\u5408\u5185\u5bb9\u3002\n\n\u5728\u5b9e\u73b0\u65f6\uff0c\u53ef\u4ee5\u76f4\u63a5\u6309\u7167\u6700\u57fa\u672c\u7684\u8ba1\u7b97 $C_i^j=\\dfrac{i\\times(i-1)\\times(i-2)\\times\\dots\\times(i-j+1)}{j!}$\u3002\u5355\u6b21\u8be2\u95ee\u590d\u6742\u5ea6 $O(m)$\uff0c\u5373\u53ef\u901a\u8fc7\u6b64\u9898\u3002\n\n## \u4ee3\u7801\u5b9e\u73b0\n\n```cpp\n#include<bits/stdc++.h>\n#define int __int128\nusing namespace std;\nint m[15],n;\nint fac[1000005],inv[1000005];\nconst int mod=1000000007;\nint qp(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1) ans=(ans*a)%mod;\n\t\ta=(a*a)%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nsigned main(){\n\tlong long t;\n\tcin>>t;\n\twhile(t--){\n\t\tlong long N,M,OPT;\n\t\tcin>>N>>M>>OPT;\n\t\tint n=N,m=M,opt=OPT;\n\t\tif(!opt){\n\t\t\tn=n+m-1;\n\t\t}\n\t\tint cur=1;\n\t\tfor(int i=n;i>=n-m+1;i--){\n\t\t\tcur*=i;\n\t\t\tcur%=mod;\n\t\t}\n\t\tint dvd=1;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tdvd*=i;\n\t\t\tdvd%=mod;\n\t\t}\n\t\tlong long ans=(cur*qp(dvd,mod-2))%mod;\n\t\tcout<<ans<<endl;\n\t}\n    return 0;\n}\n```",
        "postTime": 1646830547,
        "uid": 116664,
        "name": "Daniel_lele",
        "ccfLevel": 8,
        "title": "P5135 \u9898\u89e3"
    },
    {
        "content": "~~\u8fd9\u9898\u8fdc\u8fdc\u6ca1\u6709\u7d2b\u7684\u96be\u5ea6~~\n\n\u82e5 `opt=1`\uff0c\u90a3\u4e48\u5f88\u660e\u663e\u662f\u8981\u6211\u4eec\u6c42 $\\binom{n}{m}$\u3002\n\n\u82e5 `opt=0`\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u6c42\u51fa\u8fde\u7ebf\u4e25\u683c\u4e0b\u964d\u7684\u65b9\u6848\u6570\uff0c\u5373\u4e0a\u4e00\u95ee\u3002\u7b54\u6848\u662f $\\binom{n}{m}$\u3002\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u5c06\u76f8\u540c\u7684\u5143\u7d20\u63d2\u8fdb\u8fd9\u4e2a\u5e8f\u5217\u3002\u4f7f\u7528\u63d2\u677f\u6cd5\u53ef\u5f97\u7b54\u6848\u662f $\\binom{n+m-1}{m}$\u3002\n\n\u6211\u7684\u5b9e\u73b0\u65b9\u5f0f\u662f\u4f7f\u7528\u5b9a\u4e49 $\\binom{n}{m}=\\frac{\\prod\\limits_{i=m}^ni}{m!}$\u3002\u4e0a\u9762\u76f4\u63a5\u66b4\u529b\u4e58\uff0c\u4e0b\u9762[\u5feb\u901f\u9636\u4e58\u7b97\u6cd5](https://www.luogu.com.cn/blog/SomeMusical-MathBoy/fast-factorial) $\\Theta(\\sqrt{w}\\log w)$ \u9884\u5904\u7406\uff0c$\\Theta(\\sqrt w)$ \u5355\u6b21\u8be2\u95ee\uff08\u5176\u4e2d $w$ \u4e3a $m$ \u7684\u503c\u57df\uff09\u3002\n\n\u7531\u4e8e\u672c\u9898\u6a21\u6570\u56fa\u5b9a\uff0c\u53ef\u4ee5\u4f7f\u7528\u7f16\u8bd1\u5668\u81ea\u5e26\u53d6\u6a21\u4f18\u5316\uff08\u5982\u679c\u5199\u4e09\u6a21\u6570 NTT \u90a3\u4e48\u5185\u90e8\u53ef\u4ee5\u91c7\u7528\u8499\u54e5\u9a6c\u5229\u6a21\u4e58\u52a0\u901f\uff09\u3002\n\n\u4ee3\u7801\u6709\u4e00\u70b9\u957f\u3002\u5df2\u7701\u7565 `cin,cout` \u7684\u5b9e\u73b0\u3002\n```cpp\n// #define __MY_USE_LONG_DOUBLE__\n// @code long double is not used in this problem\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string.h>\n#include <type_traits>\n#include <unordered_map>\n#include <cstdint>\n#include <utility>\n// here is cin,cout\nnamespace OY {\ntemplate <typename _ModType, _ModType _P>\nstruct Modular {\n    static constexpr _ModType mod() { return _P; }\n    static constexpr _ModType mod(uint64_t __a) { return __a % _P; }\n    static constexpr _ModType plus(_ModType __a, _ModType __b) {\n        if (__a += __b; __a >= _P) __a -= _P;\n        return __a;\n    }\n    static constexpr _ModType minus(_ModType __a, _ModType __b) {\n        if (__a += _P - __b; __a >= _P) __a -= _P;\n        return __a;\n    }\n    static constexpr _ModType multiply(uint64_t __a, uint64_t __b) {\n        if constexpr (std::is_same<_ModType, uint64_t>::value) return multiply_ld(__a, __b);\n        else return multiply_64(__a, __b);\n    }\n    static constexpr _ModType multiply_64(uint64_t __a, uint64_t __b) { return mod(__a * __b); }\n    static constexpr _ModType multiply_128(uint64_t __a, uint64_t __b) { return __uint128_t(__a) * __b % _P; }\n    static constexpr _ModType multiply_ld(uint64_t __a, uint64_t __b) {\n        if (std::__countl_zero(__a) + std::__countl_zero(__b) >= 64) return multiply_64(__a, __b);\n        int64_t res = __a * __b - uint64_t(1.L / _P * __a * __b) * _P;\n        if (res < 0) res += _P;\n        else if (res >= _P) res -= _P;\n        return res;\n    }\n    static constexpr _ModType pow(uint64_t __a, uint64_t __n) {\n        if constexpr (std::is_same<_ModType, uint64_t>::value) return pow_ld(__a, __n);\n        else return pow_64(__a, __n);\n    }\n    static constexpr _ModType pow_64(uint64_t __a, uint64_t __n) {\n        _ModType res = 1, b = mod(__a);\n        while (__n) {\n            if (__n & 1) res = multiply_64(res, b);\n            b = multiply_64(b, b);\n            __n >>= 1;\n        }\n        return res;\n    }\n    static constexpr _ModType pow_128(uint64_t __a, uint64_t __n) {\n        _ModType res = 1, b = mod(__a);\n        while (__n) {\n            if (__n & 1) res = multiply_128(res, b);\n            b = multiply_128(b, b);\n            __n >>= 1;\n        }\n        return res;\n    }\n    static constexpr _ModType pow_ld(uint64_t __a, uint64_t __n) {\n        _ModType res = 1, b = mod(__a);\n        while (__n) {\n            if (__n & 1) res = multiply_ld(res, b);\n            b = multiply_ld(b, b);\n            __n >>= 1;\n        }\n        return res;\n    }\n    template <typename _Tp>\n    static constexpr _Tp divide(_Tp __a) { return __a / _P; }\n    template <typename _Tp>\n    static constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) {\n        _Tp quo = __a / _P, rem = __a - quo * _P;\n        return {quo, rem};\n    }\n};\ntemplate <uint32_t _P>\nusing Modular32 = Modular<uint32_t, _P>;\ntemplate <uint64_t _P>\nusing Modular64 = Modular<uint64_t, _P>;\n}\nnamespace OY {\ntemplate <typename _ModType, _ModType _P, bool _IsPrime = false>\nstruct StaticModInt {\n    using mint = StaticModInt<_ModType, _P, _IsPrime>;\n    _ModType m_val;\n    static_assert(_P > 1 && _P < 1ull << 63);\n    constexpr StaticModInt() : m_val(0) {}\n    template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>, bool> = true>\n    constexpr StaticModInt(_Tp __val) : m_val(0) {\n        int64_t x = int64_t(__val) % int64_t(mod());\n        if (x < 0) x += mod();\n        m_val = x;\n    }\n    template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>, bool> = true>\n    constexpr StaticModInt(_Tp __val) : m_val(__val % mod()) {}\n    static constexpr mint raw(_ModType __val) {\n        mint res;\n        res.m_val = __val;\n        return res;\n    }\n    static constexpr _ModType mod() { return _P; }\n    constexpr _ModType val() const { return m_val; }\n    constexpr mint pow(uint64_t __n) const { return Modular<_ModType, _P>::pow(m_val, __n); }\n    constexpr mint inv() const {\n        if constexpr (_IsPrime) return inv_Fermat();\n        else return inv_exgcd();\n    }\n    constexpr mint inv_exgcd() const {\n        _ModType x = mod(), y = m_val, m0 = 0, m1 = 1;\n        while (y) {\n            _ModType z = x / y;\n            x -= y * z;\n            m0 -= m1 * z;\n            std::swap(x, y);\n            std::swap(m0, m1);\n        }\n        if (m0 >= mod()) m0 += mod() / x;\n        return raw(m0);\n    }\n    constexpr mint inv_Fermat() const { return pow(mod() - 2); }\n    constexpr mint &operator++() {\n        if (++m_val == mod()) m_val = 0;\n        return *this;\n    }\n    constexpr mint &operator--() {\n        if (m_val == 0) m_val = mod();\n        m_val--;\n        return *this;\n    }\n    constexpr mint operator++(int) {\n        mint old(*this);\n        ++*this;\n        return old;\n    }\n    constexpr mint operator--(int) {\n        mint old(*this);\n        --*this;\n        return old;\n    }\n    constexpr mint &operator+=(const mint &__other) {\n        m_val = Modular<_ModType, _P>::plus(m_val, __other.m_val);\n        return *this;\n    }\n    constexpr mint &operator-=(const mint &__other) {\n        m_val = Modular<_ModType, _P>::minus(m_val, __other.m_val);\n            return *this;\n    }\n    constexpr mint &operator*=(const mint &__other) {\n        m_val = Modular<_ModType, _P>::multiply(m_val, __other.m_val);\n        return *this;\n    }\n    constexpr mint &operator/=(const mint &__other) { return *this *= __other.inv(); }\n    constexpr mint operator+() const { return *this; }\n    constexpr mint operator-() const { return raw(m_val ? mod() - m_val : 0); }\n    constexpr bool operator==(const mint &__other) const { return m_val == __other.m_val; }\n    constexpr bool operator!=(const mint &__other) const { return m_val != __other.m_val; }\n    constexpr bool operator<(const mint &__other) const { return m_val < __other.m_val; }\n    constexpr bool operator>(const mint &__other) const { return m_val > __other.m_val; }\n    constexpr bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }\n    constexpr bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }\n    template <typename _Tp>\n    constexpr explicit operator _Tp() const { return _Tp(m_val); }\n    constexpr friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }\n    constexpr friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }\n    constexpr friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }\n    constexpr friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }\n    template <typename _Istream>\n    friend _Istream &operator>>(_Istream &is, mint &self) { return is >> self.m_val; }\n    template <typename _Ostream>\n    friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.m_val; }\n};\ntemplate <uint32_t _P, bool _IsPrime>\nusing StaticModInt32 = StaticModInt<uint32_t, _P, _IsPrime>;\ntemplate <uint64_t _P, bool _IsPrime>\nusing StaticModInt64 = StaticModInt<uint64_t, _P, _IsPrime>;\n}\nusing mint = OY::StaticModInt32<1000000007, true>;\nusing std::vector;\n#ifdef __MY_USE_LONG_DOUBLE__\n#define double long double\n#define llround llroundl\nconst double pi = acosl(-1.0L);\nconst double two = 2.0L;\n#else\nconst double pi = acos(-1.0);\nconst double two = 2.0;\n#endif\ntemplate <typename T>\nstruct cp_base {\n    T m_real, m_imag;\n    inline constexpr cp_base(const T& r, const T& i) : m_real(r), m_imag(i) {}\n    inline constexpr cp_base(const T& r = T()) : m_real(r), m_imag(0) {}\n    inline constexpr cp_base<T> operator+(const cp_base<T> &o) const\n    { return cp_base<T>(m_real + o.m_real, m_imag + o.m_imag); }\n    inline constexpr cp_base<T> operator-(const cp_base<T> &o) const\n    { return cp_base<T>(m_real - o.m_real, m_imag - o.m_imag); }\n    inline constexpr cp_base<T> operator*(const cp_base<T> &o) const\n    { return cp_base<T>(m_real * o.m_real - m_imag * o.m_imag, m_real * o.m_imag + m_imag * o.m_real); }\n    inline constexpr cp_base<T> conj() const\n    { return cp_base<T>(m_real, -m_imag); }\n    inline constexpr T real() const { return m_real; }\n    inline constexpr T imag() const { return m_imag; }\n    inline constexpr T& real() { return m_real; }\n    inline constexpr T& imag() { return m_imag; }\n};\ntypedef cp_base<double> cp;\nstatic vector<size_t> rev;\nvector<cp> omegas;\ninline void get_rev(size_t len, int x) {\n    if (len == rev.size()) return;\n    rev.resize(len);\n    for (size_t i = 0; i < len; i++) rev[i] = rev[i >> 1ull] >> 1ull | (i & 1ull) << x;\n    omegas.resize(len);\n    for (size_t i = 0; i < len; i++) omegas[i] = cp(std::cos(two * pi / len * i), std::sin(two * pi / len * i));\n}\ninline void FFT(vector<cp>& a, size_t n, bool type) {\n    for (size_t i = 1ull; i < n; ++i) if (i < rev[i]) std::swap(a[i], a[rev[i]]);\n    for (size_t i = 2ull; i <= n; i <<= 1ull) for (size_t j = 0ull, l = (i >> 1ull), ch = n / i; j < n; j += i) for (size_t k = j, now = 0ull; k < j + l; k++) {\n        cp x = a[k], y = a[k + l] * (type ? omegas[now] : omegas[now].conj());\n        a[k] = x + y;\n        a[k + l] = x - y;\n        now += ch;\n    }\n    if (!type) {\n        for (size_t i = 0; i < n; i++) {\n            a[i].real() /= n;\n            a[i].imag() /= n;\n        }\n    }\n}\ninline void mul(size_t n, size_t m, const vector<mint>& a, const vector<mint>& b, vector<mint>& c, size_t len) {\n    const size_t up = sqrt(mint::mod());\n    mint v1, v2, v3;\n    vector<cp> P(len, cp(0, 0)), Q(len, cp(0, 0)), R(len, cp(0, 0));\n    for (size_t i = 0ull; i < n; i++) P[i] = cp(a[i].val() % up, a[i].val() / up);\n    for (size_t i = 0ull; i < m; i++) R[i] = cp(b[i].val() % up, b[i].val() / up);\n    FFT(P, len, true);\n    FFT(R, len, true);\n    Q[0] = P[0].conj();\n    for (size_t i = 1ull; i < len; i++) Q[i] = P[len - i].conj();\n    for (size_t i = 0ull; i < len; i++) {\n        P[i] = P[i] * R[i];\n        Q[i] = Q[i] * R[i];\n    }\n    FFT(P, len, false);\n    FFT(Q, len, false);\n    c.resize(n + m - 1);\n    for (size_t i = 0ull; i < n + m - 1; i++) {\n        v1 = llround((P[i].real() + Q[i].real()) / two);\n        v2 = llround((Q[i].real() - P[i].real()) / two);\n        v3 = llround(P[i].imag());\n        c[i] = v1 + v2 * up * up + v3 * up;\n    }\n}\nstatic vector<mint> fac, mfac, invfac, minvfac, inv, minv;\ninline void init(size_t n, mint m) {\n    size_t tmp = n << 1ull | 1ull;\n    tmp++;\n    fac.resize(tmp);\n    mfac.resize(tmp);\n    invfac.resize(tmp);\n    minvfac.resize(tmp);\n    inv.resize(tmp);\n    minv.resize(tmp);\n    fac[0] = mfac[0] = 1ull;\n    for (size_t i = 1ull; i < tmp; i++) {\n        fac[i] = fac[i - 1ull] * i;\n        mfac[i] = mfac[i - 1ull] * (m - n + i - 1ull);\n    }\n    tmp--;\n    invfac[tmp] = fac[tmp].inv();\n    minvfac[tmp] = mfac[tmp].inv();\n    for (size_t i = tmp; i; i--) {\n        invfac[i - 1ull] = invfac[i] * i;\n        minvfac[i - 1ull] = minvfac[i] * (m - n + i - 1ull);\n        inv[i] = invfac[i] * fac[i - 1ull];\n        minv[i] = minvfac[i] * mfac[i - 1ull];\n    }\n    minv[0] = 1ull;\n}\ninline void LagrangeInterpolation_ex(size_t n, mint m, const vector<mint>& a, vector<mint> &b) {\n    vector<mint> f, g;\n    size_t len = 1ull;\n    int x = -1;\n    while (len < n * 3ull + 2ull) len <<= 1ull, x++;\n    get_rev(len, x);\n    f.resize(len);\n    g.resize(len);\n    init(n, m);\n    for (size_t i = 0ull; i <= n; i++) {\n        f[i] = invfac[i] * invfac[n - i] * a[i];\n        ((n - i) & 1ull) && (f[i] = -f[i]);\n    }\n    for (size_t i = 0; i <= (n << 1); i++) g[i] = minv[i + 1];\n    mul(n + 1ull, n << 1ull | 1ull, f, g, f, len);\n    b.resize(n + 1ull);\n    for (size_t i = n; i <= (n << 1ull); i++) b[i - n] = mfac[i + 1ull] * minvfac[i - n] * f[i];\n}\nstatic vector<mint> mc;\nsize_t sval;\ninline void prepare(mint n) {\n    static vector<mint> md;\n    int pos = 0;\n    sval = sqrt(n.val()) + 1e-6;\n    mint s(sval);\n    mc.reserve(sval);\n    md.reserve(sval);\n    mint invs = s.inv();\n    static vector<size_t> st;\n    st.resize(log2(sval) + 5);\n    for (size_t i = sval; i > 1ull; i >>= 1ull) st[++pos] = i;\n    mc.resize(2ull);\n    md.resize(2ull);\n    mc[0] = 1ull;\n    mc[1] = s + 1ull;\n    for (size_t l = st[pos]; pos; l = st[--pos]) {\n        LagrangeInterpolation_ex(l >> 1ull, mint((l >> 1ull) + 1ull), mc, md);\n        mc.resize(mc.size() << 1ull);\n        std::copy(md.begin(), md.end(), mc.begin() + md.size());\n        LagrangeInterpolation_ex(mc.size() - 1ull, invs * (l >> 1ull), mc, md);\n        for (size_t i = 0ull, iend = mc.size(); i < iend; i++) mc[i] *= md[i];\n        if (l & 1ull) for (size_t i = 0; i <= l; i++) mc[i] *= s * i + l;\n        else mc.resize(l + 1ull);\n    }\n}\ninline mint get_fac(unsigned long long v) {\n    mint res(1);\n    unsigned long long iend = v / sval;\n    for (unsigned long long i = 0ull; i < iend; i++) res *= mc[i];\n    for (unsigned long long i = 1ull * iend * sval + 1ull, iendd = v; i <= iendd; i++) res *= i;\n    return res;\n}\nint main() {\n    prepare(mint(1000005));\n    int T = 0;\n    unsigned long long n, m;\n    int opt;\n    mint ans, tmp;\n    cin >> T;\n    while (T--) {\n        cin >> n >> m >> opt;\n        if (!opt) n = n + m - 1;\n        if (n < m) {\n            cout << '0' << '\\n';\n            continue;\n        }\n        ans = 1;\n        for (unsigned long long i = n, iend = n - m + 1; i >= iend; i--) ans *= i;\n        tmp = get_fac(m);\n        cout << ans / tmp << '\\n';\n    }\n    return 0;\n}\n```\n~~\u6210\u529f\u628a\u7d2b\u9898\u505a\u6210\u9ed1\u9898~~",
        "postTime": 1672574093,
        "uid": 589895,
        "name": "Ruiqun2009",
        "ccfLevel": 0,
        "title": "\u9898\u89e3P5135 painting"
    }
]