[
    {
        "content": "<http://www.lydsy.com/JudgeOnline/problem.php?id=1036>\n\n\u76f4\u63a5\u6811\u94fe\u5256\u5206\u7ebf\u6bb5\u6811\u7ef4\u62a4\u597d\u4e86\uff0c\u795e\u7287\u4f1a\u5199lct\uff0c\u7136\u800c\u6211\u4e0d\u4f1a23333\n\n\u6811\u94fe\u5256\u5206\u5165\u95e8\u9898\uff0c\u5efa\u8bae\u4e00\u505a\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define N 100005\n#define inf 1000000000\nusing namespace std;\nint n,q,a[4*N];\nstruct Edge{\n    int u,v,next;\n}G[N];\nint tot=0,head[N];\nint size[100005],wson[100005],fa[100005],d[100005],top[100005];\nint tpos[100005],pre[100005],cnt=0;\ninline void addedge(int u,int v){\n    G[++tot].u=u;G[tot].v=v;G[tot].next=head[u];head[u]=tot;\n    G[++tot].u=v;G[tot].v=u;G[tot].next=head[v];head[v]=tot;\n}\nvoid dfs1(int u,int f){\n    size[u]=1;\n    for (int i=head[u];i;i=G[i].next){\n        int v=G[i].v;if (v==f)continue;\n        d[v]=d[u]+1;fa[v]=u;\n        dfs1(v,u);\n        size[u]+=size[v];\n        if (size[v]>size[wson[u]])wson[u]=v;\n    }\n}\nvoid dfs2(int u,int TP){\n    tpos[u]=++cnt;pre[cnt]=u;top[u]=TP;\n    if (wson[u])dfs2(wson[u],TP);\n    for (int i=head[u];i;i=G[i].next){\n        int v=G[i].v;\n        if (v==fa[u]||v==wson[u])continue;\n        dfs2(v,v);\n    }\n}\nint sumv[4*N],maxv[4*N];\ninline void pushup(int o){\n    sumv[o]=sumv[o*2]+sumv[o*2+1];\n    maxv[o]=max(maxv[o*2],maxv[o*2+1]);\n}\nvoid build(int o,int l,int r){\n    int mid=(l+r)/2;\n    if (l==r){sumv[o]=maxv[o]=a[pre[l]];return;}\n    build(o*2,l,mid);build(o*2+1,mid+1,r);\n    pushup(o);\n}\nvoid update(int o,int l,int r,int q,int v){\n    int mid=(l+r)/2;\n    if (l==r){sumv[o]=maxv[o]=v;return;}\n    if (q<=mid)update(o*2,l,mid,q,v);\n    else update(o*2+1,mid+1,r,q,v);\n    pushup(o);\n}\nint querysum(int o,int l,int r,int ql,int qr){\n    int mid=(l+r)/2,ans=0;\n    if (ql<=l&&r<=qr)return sumv[o];\n    if (ql<=mid)ans+=querysum(o*2,l,mid,ql,qr);\n    if (qr>mid)ans+=querysum(o*2+1,mid+1,r,ql,qr);\n    pushup(o);\n    return ans;\n}\nint querymax(int o,int l,int r,int ql,int qr){\n    int mid=(l+r)/2,ans=-inf;\n    if (ql<=l&&r<=qr)return maxv[o];\n    if (ql<=mid)ans=max(ans,querymax(o*2,l,mid,ql,qr));\n    if (qr>mid)ans=max(ans,querymax(o*2+1,mid+1,r,ql,qr));\n    pushup(o);\n    return ans;\n}\nint qsum(int u,int v){\n    int ans=0;\n    while (top[u]!=top[v]){\n        if (d[top[u]]<d[top[v]])swap(u,v);\n        ans+=querysum(1,1,n,tpos[top[u]],tpos[u]);\n        u=fa[top[u]];\n    }\n    if (d[u]<d[v])swap(u,v);\n    ans+=querysum(1,1,n,tpos[v],tpos[u]);\n    return ans;\n}\nint qmax(int u,int v){\n    int ans=-inf;\n    while (top[u]!=top[v]){\n        if (d[top[u]]<d[top[v]])swap(u,v);\n        ans=max(ans,querymax(1,1,n,tpos[top[u]],tpos[u]));\n        u=fa[top[u]];\n    }\n    if (d[u]<d[v])swap(u,v);\n    ans=max(ans,querymax(1,1,n,tpos[v],tpos[u]));\n    return ans;\n}\nint main(){\n    memset(head,0,sizeof(head));\n    memset(a,0,sizeof(a));\n    scanf(\"%d\",&n);\n    for (int i=1;i<n;i++){\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        addedge(u,v);\n    }\n    for (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    d[1]=1;fa[1]=1;dfs1(1,-1);dfs2(1,1);build(1,1,n);\n    scanf(\"%d\",&q);\n    while (q--){\n        int x,y;\n        char s[10];\n        scanf(\"%s%d%d\",s,&x,&y);\n        if (s[1]=='H')update(1,1,n,tpos[x],y);\n        if (s[1]=='M')printf(\"%d\\n\",qmax(x,y));\n        if (s[1]=='S')printf(\"%d\\n\",qsum(x,y));\n    }\n    return 0;\n}\n```",
        "postTime": 1481415752,
        "uid": 2978,
        "name": "zcysky",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "### \u524d\u8a00\n\n\u521a\u521a\u5b66\u5b8c\u6811\u94fe\u5256\u5206\u5c31\u6765\u62ff\u8fd9\u9053\u9898\u7ec3\u624b\u4e86\uff0c\u4e3a\u4e86\u589e\u8fdb\u81ea\u5df1\u5bf9\u6811\u94fe\u5256\u5206\u7684\u7406\u89e3\uff0c\u56e0\u6b64\u6765\u5199\u4e86\u4e00\u7bc7\u9898\u89e3\u3002\n\n## \u601d\u8def\n\n### \u6811\u94fe\u5256\u5206 + \u7ebf\u6bb5\u6811\u5355\u70b9\u4fee\u6539 + \u7ef4\u62a4\u533a\u95f4\u6700\u5927\u548c\u533a\u95f4\u548c\n\n## \u6811\u94fe\u5256\u5206\u57fa\u672c\u64cd\u4f5c \n\n- ## \u4e00\u3001\u53d8\u91cf\u58f0\u660e\n\n\n```cpp\nint num; //Dfs\u5e8f\u65b0\u8282\u70b9\u7f16\u53f7 (\u770b\u4e0d\u61c2\u53ef\u4ee5\u4e0d\u8981\u7ba1\nint f[N],dep[N],size[N],son[N];\t//Dfs1\u5904\u7406 \u7236\u4eb2\uff0c\u6df1\u5ea6\uff0c\u5927\u5c0f\uff0c\u91cd\u513f\u5b50 \nint top[N],id[N],rk[N];\t//Dfs2\u5904\u7406 \u94fe\u9876\uff0cDfs\u5e8f\u65b0\u7f16\u53f7 \uff0c\u65b0\u7f16\u53f7\u5bf9\u5e94\u539f\u7f16\u53f7 \n```\n\n\uff08PS\uff1a~~\u770b\u5f97\u90fd\u8111\u888b\u75dbQWQ~~\uff09\n\n------------\n\n\n------------\n\n- ## \u4e8c\u3001Dfs1 \uff08\u5904\u7406\u7236\u4eb2\uff0c\u6df1\u5ea6\uff0c\u5927\u5c0f\uff0c\u91cd\u513f\u5b50\uff09\n\n\n```cpp\nvoid Dfs1(int p,int fa)\t//\u5f53\u524d\u8282\u70b9\uff0c\u5f53\u524d\u8282\u70b9\u7236\u4eb2\n{\n\tf[p]=fa ,dep[p]=dep[fa]+1 ,size[p]=1;\t//\u5904\u7406\u7236\u4eb2\uff0c\u6df1\u5ea6\u662f\u7236\u4eb2+1\uff0c\u521d\u59cb\u5927\u5c0f\u4e3a1\uff08\u5373\u628a\u81ea\u5df1\u7b97\u8fdb\u53bb\uff09\n//\t\u5386\u904d\u8fb9\n\tfor(int i=head[p],v;i;i=edge[i].next) {\n\t\tif((v=edge[i].to) != fa) {\n\t\t\tDfs1(v,p);\t//\u7ee7\u7eedDfs1\uff08\uff09\uff1b\n\t\t\tsize[p] += size[v];\t//\u8fd9\u65f6\u5019\u5b50\u6811\u7684size\u5df2\u7ecf\u5904\u7406\u51fa\u6765\uff0c\u6240\u4ee5\u628asize[p]\u52a0\u4e0a\u5b50\u6811size[v]\uff1b\n\t\t\tif(size[v] > size[son[p]])\n\t\t\t\tson[p] = v;\t//\u627e\u91cd\u513f\u5b50\uff0c\u91cd\u513f\u5b50\u7684size\u8981\u6700\u5927\n\t\t}\n\t}\n}\n```\n\n\n------------\n\n\n------------\n\n- ## \u4e09\u3001Dfs2\n>- #### Dfs\u5e8f\u904d\u5386\n>- #### \u5904\u7406\u5f53\u524d\u8282\u70b9\u5bf9\u5e94\u5f53\u524d\u8282\u70b9\u6240\u5904\u94fe\u7684\u94fe\u9876\uff08top[]\uff09\n>- #### \u5f53\u524d\u8282\u70b9\u65b0\u7f16\u53f7(id[ ])\uff0c\n>- #### \u65b0\u7f16\u53f7\u5bf9\u5e94\u539f\u7f16\u53f7\uff08rk[ ]\uff09\n\n```cpp\nvoid Dfs2(int p,int t)\t//\u5f53\u524d\u8282\u70b9 \uff0c\u5f53\u524d\u91cd\u94fe\u9876\n{\n\ttop[p]=t ,id[p]=++num ,rk[num]=p;\t//p\u7684\u94fe\u9876\u662ft\uff0cp\u7684\u65b0\u5e8f\u53f7\u662f++num,rk[num]\u5bf9\u5e94p\n\tif(son[p]) Dfs2(son[p],t);\t//\u6709\u91cd\u513f\u5b50\u5148\u8d70\u91cd\u513f\u5b50\n\t//\u5386\u904d\u8fb9\n\tfor(int i=head[p],v;i;i=edge[i].next) {\n\t\tif((v=edge[i].to)!=f[p] && v!=son[p])\t//\u4e0d\u662f\u7236\u4eb2\u4e5f\u4e0d\u662f\u91cd\u513f\u5b50\n\t\t\tDfs2(v,v);\t//\u8fd9\u4e2a\u8f7b\u94fe\u7684\u91cd\u94fe\u9876\u662f\u81ea\u5df1\n\t}\n}\n```\n\n\uff08PS\uff1aDfs2~~\u4ee3\u7801\u91cf\u66f4\u5c11\u5374\u66f4\u96be\u7406\u89e3~~\u53ea\u8981\u591a\u6253\u4ee3\u7801\u591a\u60f3\u5176\u5b9e\u5c31\u5f88\u7b80\u5355\u7684QWQ\uff09\n\n- ## \u56db\u3001\u67e5\u8be2\n\n#### \u5148\u770b\u5728\u4e0d\u5728\u540c\u4e00\u91cd\u94fe\u4e0a\uff0c\u5982\u679c\u4e0d\u5728\uff0c\u5c31\u8df3\u91cd\u94fe\u9876\u5c0f\u7684\u90a3\u4e2a\u8282\u70b9\uff0c\u8df3\u5230\u4ed6\u6240\u5728\u91cd\u94fe\u9876\u7684\u7236\u8282\u70b9\u4e0a\uff0c\u5e76\u533a\u95f4\u67e5\u8be2\u8fd9\u6761\u94fe\uff0c\u52a0\u5165res\uff08result\u7ed3\u679c\uff09,\u4ee5\u6b64\u7c7b\u63a8\uff0c\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u94fe\u4e0a\u3002\n\n#### \u5728\u540c\u4e00\u94fe\u4e0a\u5728\u518d\u786e\u5b9a\u4e24\u70b9\u7684\u6df1\u5ea6\u5173\u7cfb\uff0c\u533a\u95f4\u67e5\u8be2\u4ece\u5c0f\u70b9\u5230\u5927\u70b9\uff08\u76f8\u5f53\u4e8e\u91cd\u94fe\u4e0a\u7684\u4e00\u90e8\u5206\uff09\uff0c\u52a0\u5165res\u3002\n\n\n```cpp\nint qsum(int x,int y)\t//\u4e24\u4e2a\u70b9x\uff0cy\n{\n\tint res = 0;\t//\u521d\u59cb\u7f6e0 \uff0c\u6ce8\u610f\u533a\u95f4Max\u8981\u521d\u59cb\u7f6e -INF \u56e0\u4e3a\u6709\u8d1f\u6570\n\twhile(top[x] != top[y]) {\t//\u4e0d\u5728\u540c\u94fe\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\t//\u8df3\u94fe\u9876\u5c0f\u7684\n\t\tres+=tree.Querysum(id[top[x]],id[x],1,1,n);\t//\u533a\u95f4\u67e5\u8be2\u8fd9\u6761\u94fe \n\t\tx = f[top[x]];\t//\u8df3 jump\uff0cjunp\uff08\u5531\u8df3rap\u7bee\u7403\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\t//\u786e\u5b9a\u5148\u540e\u4f4d\u7f6e\n\treturn res += tree.Querysum(id[x],id[y],1,1,n); \t//\u533a\u95f4\u67e5\u8be2\u94fe\u7684\u8fd9\u90e8\u5206\n}\n```\n\n\n\n\uff08PS\uff1a\u6c42Max\u548csum\u7684\u677f\u5b50\u90fd\u4e00\u6837\uff0c~~\u4e3e\u4e00\u53cd\u4e09\u5c31\u597d\u4e86~~\uff09\n\n\u7ebf\u6bb5\u6811\u57fa\u672c\u64cd\u4f5c\u5c31\u4e0d\u8981\u5199\u4e86\u5427\uff0c\u53ea\u662f**\u8981\u6ce8\u610f\u53f6\u5b50\u8282\u70b9\u8d4b\u521d\u503c\u65f6\u8981\u7528Dfs\u5e8f\u5bf9\u5e94\u539f\u5148\u8282\u70b9\u7684\u503c\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u7684\u4e0b\u6807\u662fDfs\u5e8f\u7684\u4e0b\u6807\uff0c\u4e0e\u539f\u4e0b\u6807\u4e0d\u540c**\u3002\u53e6\u5916**\u4f7f\u7528\u7ebf\u6bb5\u6811\u64cd\u4f5c\u65f6\u8981\u628a\u8282\u70b9\u8f6c\u6362\u6210\u7ebf\u6bb5\u6811\u8282\u70b9\u4e0b\u6807**\u3002\u7ebf\u6bb5\u6811**\u9012\u5f52\u8bb0\u5f97\u8fb9\u754creturn\uff0c\u5426\u5219\u4f1aRE**\u3002\n\n#### \u82e5\u8fd8\u6709\u4e0d\u61c2\u8bf7\u770b\u4ee3\u7801\uff1a\n\n## AC Code\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#define N 100007\n#define INF 10000000\nusing namespace std;\nint n,cnt,num,Q;\nint val[N],head[N];\nint f[N],dep[N],size[N],son[N];\t//Dfs1\u5904\u7406 \u7236\u4eb2\uff0c\u6df1\u5ea6\uff0c\u5927\u5c0f\uff0c\u91cd\u513f\u5b50 \nint top[N],id[N],rk[N];\t//Dfs2\u5904\u7406 \u94fe\u9876\uff0cDfs\u5e8f\u65b0\u7f16\u53f7 \uff0c\u65b0\u7f16\u53f7\u5bf9\u5e94\u539f\u7f16\u53f7 \nstruct Edge {\n\tint next,to;\n}edge[N<<1];\nstruct Segment_Tree\n{\n\tint sum[N<<2] ,maxv[N<<2];\n\tinline int ls(int p) {return p<<1;}\n\tinline int rs(int p) {return p<<1|1;}\n\tvoid push_up(int p) {\n\t\tsum[p] = sum[ls(p)] + sum[rs(p)];\n\t\tmaxv[p] = max(maxv[ls(p)],maxv[rs(p)]);\n\t}\n\tvoid build(int p,int l,int r)\n\t{\n\t\tif(l==r) {sum[p]=maxv[p]=val[rk[l]]; return ;}\n\t\tint mid = (l+r)>>1;\n\t\tbuild(ls(p),l,mid);\n\t\tbuild(rs(p),mid+1,r);\n\t\tpush_up(p);\n\t}\n\tint Querysum(int ql,int qr,int p,int l,int r)\n\t{\n\t\tif(ql<=l && r<=qr) return sum[p];\n\t\tint res=0 ,mid=(l+r)>>1;\n\t\tif(ql<=mid) res += Querysum(ql,qr,ls(p),l,mid);\n\t\tif(qr>mid) res += Querysum(ql,qr,rs(p),mid+1,r);\n\t\treturn res;\n\t}\n\tint Querymax(int ql,int qr,int p,int l,int r)\n\t{\n\t\tif(ql<=l && r<=qr) return maxv[p];\n\t\tint Max=-INF ,mid=(l+r)>>1;\n\t\tif(ql<=mid) Max = max(Max,Querymax(ql,qr,ls(p),l,mid));\n\t\tif(qr>mid) Max = max(Max,Querymax(ql,qr,rs(p),mid+1,r));\n\t\treturn Max;\n\t}\n\tvoid update(int p,int l,int r,int q,int v)\n\t{\n\t\tint mid = (l+r)>>1;\n\t\tif(l==r) {sum[p] = maxv[p] = v; return ;}\n\t\tif(q<=mid) update(ls(p),l,mid,q,v);\n\t\telse update(rs(p),mid+1,r,q,v);\n\t\tpush_up(p);\n\t}\n}tree;\nvoid add(int u,int v) {\n\tedge[++cnt].next = head[u];\n\tedge[cnt].to = v;\n\thead[u] = cnt;\n}\nvoid Dfs1(int p,int fa)\n{\n\tf[p]=fa ,dep[p]=dep[fa]+1 ,size[p]=1;\n\tfor(int i=head[p],v;i;i=edge[i].next) {\n\t\tif((v=edge[i].to) != fa) {\n\t\t\tDfs1(v,p);\n\t\t\tsize[p] += size[v];\n\t\t\tif(size[v] > size[son[p]])\n\t\t\t\tson[p] = v;\n\t\t}\n\t}\n}\nvoid Dfs2(int p,int t)\n{\n\ttop[p]=t ,id[p]=++num ,rk[num]=p;\n\tif(son[p]) Dfs2(son[p],t);\n\tfor(int i=head[p],v;i;i=edge[i].next) {\n\t\tif((v=edge[i].to)!=f[p] && v!=son[p])\n\t\t\tDfs2(v,v);\n\t}\n}\nint qsum(int x,int y)\n{\n\tint res = 0;\n\twhile(top[x] != top[y]) {\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tres += tree.Querysum(id[top[x]],id[x],1,1,n); \n\t\tx = f[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\treturn res += tree.Querysum(id[x],id[y],1,1,n); \n}\nint qmax(int x,int y)\n{\n\tint res = -INF;\n\twhile(top[x] != top[y]) {\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tres = max(res,tree.Querymax(id[top[x]],id[x],1,1,n));\n\t\tx = f[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\treturn res = max(res,tree.Querymax(id[x],id[y],1,1,n));\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<=n-1;++i) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v) ,add(v,u);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&val[i]);\n\tDfs1(1,0) ,Dfs2(1,1) ,tree.build(1,1,n);\n\tscanf(\"%d\",&Q);\n\twhile(Q--) {\n\t\tchar s[10]; int x,y;\n\t\tcin>>s;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(s[0] == 'C') tree.update(1,1,n,id[x],y);\n\t\telse if(s[1] == 'M') printf(\"%d\\n\",qmax(x,y));\n\t\telse printf(\"%d\\n\",qsum(x,y));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1557931551,
        "uid": 147511,
        "name": "\u57fa\u5730A_I",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "$2019.6.29\\ update:$\u7ed9\u51fa\u4e86\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u8bc1\u660e\uff0c\u66f4\u65b0\u4e86$L_AT^EX$\n\n---\n\u5148\u5f15\u5165\u4e00\u4e2a\u95ee\u9898\uff1a\n```\n\u7ed9\u5b9a\u4e00\u9897\u6709n\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u7ed9\u5b9a\u6839\u8282\u70b9\n\u6bcf\u6b21\u7ed9\u51fa\u70b9\u5bf9(x,y)\uff0c\u67e5\u8be2x\u5230y\u8def\u5f84\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u8282\u70b9(\u5373LCA)\u3002\n```\n![\u6811](https://cdn.luogu.com.cn/upload/pic/53670.png)\n\n\u770b\u5230\u8fd9\u6837\u7684\u9898\u76ee\uff0c\u5927\u5bb6\u9996\u5148\u60f3\u5230\u7684\u662f\u66b4\u529b\u5427\uff1f\n1. \u4ece$x$\u51fa\u53d1\u5411\u4e0a\u8d70\u5230\u6839\uff0c\u6807\u8bb0\u6bcf\u4e2a\u7ecf\u8fc7\u7684\u8282\u70b9\u3002\n2. \u4ece$y$\u51fa\u53d1\u5411\u4e0a\u8d70\uff0c\u7ecf\u8fc7\u7684\u7b2c\u4e00\u4e2a**\u6709\u6807\u8bb0**\u7684\u8282\u70b9\u5c31\u662f\"x\u5230y\u8def\u5f84\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u8282\u70b9\"$(LCA)$\u3002\n\n![(3,2)](https://cdn.luogu.com.cn/upload/pic/53671.png)\n\n$Code:$\n\n```cpp\nint LCA(int x,int y)\n{\n\tif(x==y)return x;\n\twhile(x!=root)vis[x]=true,x=fa[x];\n\twhile(y!=root)\n\t\tif(vis[y])return y;\n\t\telse y=fa[y];\n\treturn root;\n}\n```\n\u4f46\u662f\u8ba9\u6211\u4eec\u7b97\u7b97\u590d\u6742\u5ea6... $\\Theta(N)\\ $~~TLE~~ \n\n\u4e3a\u4ec0\u4e48\u590d\u6742\u5ea6\u5982\u6b64\u4e4b\u9ad8\uff1f\u660e\u663e\u662f\u56e0\u4e3a\u8d70\u5f97\u592a\u6162\u4e86\u3002\n\n\u6211\u4eec\u9700\u8981\u66f4\u597d\u7684\u7b97\u6cd5\u3002\n\n\u600e\u4e48\u505a\u5462\uff1f\n\n\u777f\u667a\u7684\u5148\u4eba\u60f3\u5230\u4e86~~\u500d\u589e~~**\u6811\u5256**\n\n\u5148\u628a\u6811\u5256\u5206\u6210\u4e00\u6761\u6761\u7684\u94fe\n\n\u6bcf\u6b21\u76f4\u63a5\u8df3\u4e00\u6574\u6761\u94fe\uff0c\u4e0d\u5c31\u5feb\u4e86\u5417\uff1f\n\n\u4e8e\u662f\uff0c\u6811\u94fe\u5256\u5206($Tree-chain\\ Partition$)\u8bde\u751f\u4e86\u3002\n\n---\n~~\u4ee5\u4e0a\u5747\u4e3a\u5e9f\u8bdd~~\n## \u9884\u5904\u7406\n\u5148\u6765\u8bf4\u5256\u5206\uff1a\n\n**\u5256\u5206\uff0c\u662f\u6307\u4f9d\u636e\u67d0\u79cd\u8fd0\u7b97\uff0c\u5c06\u51e0\u4e2a\u8282\u70b9\u5206\u5165\u540c\u4e00\u6761\u94fe\uff0c\u800c\u5c06\u4e00\u9897\u6811\u5206\u6210\u51e0\u6761\u94fe\u7684\u65b9\u6cd5\u3002**\n\n\u770b\u4e0d\u61c2\u6ca1\u5173\u7cfb~~\u53cd\u6b63\u5b83\u4e0d\u91cd\u8981~~\n\n\u5e38\u89c1\u7684\u5256\u5206\u6709\u4e09\u79cd\uff1a\n1. \u91cd\u94fe\u5256\u5206\n2. \u5b9e\u94fe\u5256\u5206\uff08Link-Cut Tree\u624d\u7528\uff09\n3. \u957f\u94fe\u5256\u5206\uff08\u51e0\u4e4e\u4e0d\u7528\uff09\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u8bb2\u7684\u662f**\u91cd\u94fe\u5256\u5206**\n\n\u91cd\u94fe\u5256\u5206\u4f9d\u636e\u5565\u5462\uff1f\u4f9d\u636e\u7684\u662f\u513f\u5b50\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u5373$x$**\u5b50\u6811\u6700\u5927**\u7684\u513f\u5b50\u4e0e$x$\u5c5e\u4e8e\u540c\u4e00\u6761\u91cd\u94fe\u3002\n\n\u9996\u5148\u5b9a\u4e49\u51e0\u79cd\u53d8\u91cf\uff1a\n- $dep_x$\uff1a$x$\u7684\u6df1\u5ea6\n- $fa_x$\uff1a$x$\u7684\u7236\u4eb2\n- $siz_x$\uff1a\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u6570\n- $son_x$:$x$\u7684\u91cd\u513f\u5b50\n- $top_x$:$x$\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u7f16\u53f7\n- $root$:\u6574\u68f5\u6811\u7684\u6839\n- $son(x)$:$x$\u7684\u513f\u5b50\u6240\u6784\u6210\u7684\u96c6\u5408\n\n\u6240\u4ee5\u6211\u4eec\u5148\u8981dfs\u4e00\u904d\u628a\u524d4\u79cd\u503c\u7b97\u51fa\u6765\u3002\n### code:\n($head,ver,next$\u5747\u4e3a\u90bb\u63a5\u8868,\u4e0d\u4f1a\u7684~~\u4f60\u8fd8\u770b\u4ec0\u4e48\u6811\u5256~~\u8bf7\u5148\u5b66\u4f1a)\n\n```cpp\nvoid dfs1(ci&x){//ci -> const int,\u540e\u6587\u540c\n\tsiz[x]=1;\n\tfor(int k=head[x],y;y=ver[k],k;k=next[k])\n\t{\n\t\tif(y==fa[x])continue;\n\t\tfa[y]=x;dep[y]=dep[x]+1;dfs1(y);\n\t\tif(siz[son[x]]<siz[y])son[x]=y;//\u6c42\u91cd\u513f\u5b50\n\t\tsiz[x]+=siz[y];\n\t}\n}\n//\u4ee5\u4e0b\u8bed\u53e5\u52a0\u5728main(int argc,char **argv)/main() \u4e2d\ndep[root]=1;dfs1(root);\n```\n\u7b97\u5b8c\u4e86\u524d$4$\u79cd\u503c\uff0c$top$\u8be5\u600e\u4e48\u7b97\u5462\uff1f\n\n\u6839\u636e\u5b9a\u4e49\uff0c\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u8282\u70b9\u7684$top$\u503c**\u76f8\u540c**\u3002\n\n\u800c\u5728\u91cd\u94fe\u5256\u5206\u4e2d\uff0c$x$\u548c$son_x$\u5728**\u4e00\u6761**\u91cd\u94fe\u4e0a\u3002\n\n~~\u662f\u4e0d\u662f\u53d1\u73b0\u4e86\u4ec0\u4e48~~\n\n\u4e8e\u662f\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u6761\u89c4\u5f8b\uff1a\n$$top_x=\\{^{top_{fa_x}|son_{fa_x}==x}_{x|son_{fa_x} \\neq x}\\}$$\n\n~~\u662f\u4e0d\u662f\u5f88\u7b80\u5355~~\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u6109\u5feb\u7684~~\u518ddfs\u4e00\u904d~~\u8ba1\u7b97\u5566\n\n### code:\n```cpp\nvoid dfs2(ci&x){\n\tif(!son[x])return;\n\ttop[son[x]]=top[x];dfs2(son[x]);//\u76f4\u63a5\u5728fa[x]\u5904\u8d4b\u503c\uff0c\u51cf\u5c11\u53c2\u6570\u4f20\u9012\n\tfor(int k=head[x],y;y=ver[k],k;k=next[k])\n\t{\n\t\tif(y==fa[x]||y==son[x])continue;\n\t\ttop[y]=y;dfs2(y);//\u975e\u91cd\u513f\u5b50\u7684top[]\u4e00\u5b9a\u662f\u81ea\u5df1\n\t}\n}\n//\u4ee5\u4e0b\u8bed\u53e5\u52a0\u5728main(int argc,char **argv)/main() \u4e2d\ntop[root]=root;dfs2(root);\n```\n\u9884\u5904\u7406\u590d\u6742\u5ea6$\\Theta(N)$\n\n\u5256\u5b8c\u540e\u7684\u6811\n![\u4f8b\u91cd\u94fe](https://cdn.luogu.com.cn/upload/pic/53672.png)\n## \u67e5\u627eLCA\n\u6709\u4eba\u95ee\uff0c\u628a\u94fe\u5256\u51fa\u6765\u6709\u5bf9\u4e8e\u67e5LCA\u4ec0\u4e48\u7528\u5462\uff1f\n\n\u6211\u7b54\uff1a\u8fd8\u8bb0\u5f97\u66b4\u529b\u4e3a\u4ec0\u4e48TLE\u5417\uff1f\n\n\u8d70\u592a\u6162\u5566\uff01\n\n\u6240\u4ee5\uff0c\u6811\u94fe\u5256\u5206\u7684\u5b9e\u9645\u4f5c\u7528\u2014\u2014\u52a0\u901f\uff01\n\n\u4f46\u662f\uff0c\u5256\u5b8c\u540e\u5982\u4f55\u67e5\u627e\u5462\uff1f\n\n~~\u7ecf\u8fc7\u82e6\u601d\u51a5\u60f3\uff0c~~ \u6211\u4eec\u53d1\u73b0\u4e00\u6761\u89c4\u5f8b\uff1a\n\n**\u65e0\u8bba\u4ec0\u4e48\u65f6\u5019\uff0c\u53ea\u8981\u4e24\u4e2a\u8282\u70b9\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a$($\u5373$top_x!=top_y)$\uff0c\u90a3\u4e48\u4ed6\u4eec\u7684$LCA$\u80af\u5b9a\u4e0d\u5728\u6df1\u5ea6\u5927\u7684\u90a3\u6761\u91cd\u94fe\u4e0a\u3002**\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u53ef\u4ee5\u8fd9\u6837\uff1a\n1. \u5bf9\u4e8e\u70b9\u5bf9$(x,y)$\uff0c\u8bb0$fx=top_x,fy=top_y$.\n2. \u5982\u679c$fx!=fy$\uff0c\u8f6c\u7b2c3\u6b65\uff1b\u5426\u5219\u8f6c\u7b2c4\u6b65.\n3. \u5c06$fx,fy$\u4e2d$dep[]$\u503c\u5927\u7684\u5f80\u4e0a\u8df3(\u8bbe$dep_{fx}>dep_{fy}$)\uff0c\u66f4\u65b0$((x,y)->(fa_{fx},y))$\uff0c\u56de\u5230\u7b2c2\u6b65.\n4. \u8fd9\u65f6$(x,y)$\u80af\u5b9a\u5728\u4e00\u6761\u91cd\u94fe\u4e0a$(top_x=top_y)$\uff0c\u800c\u6df1\u5ea6\u8f83\u5c0f\u7684\u90a3\u4e2a\u5c31\u662f$LCA$.\n\n### code:\n\n```cpp\nint LCA(int x,int y)\n{\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy)\n\t{\n\t\tif(dep[fx]<dep[fy])std::swap(x,y),std::swap(fx,fy);\n\t\tx=fa[fx],fx=top[x];\n\t}\n\treturn dep[x]<dep[y]?x:y;\n}\n```\n\u90a3\u4e48\u8fd9\u79cd\u52a0\u901f\u8df3\u6cd5\u7684\u6548\u679c\u600e\u4e48\u6837\u5462\uff1f\n\n\u53ef\u4ee5\u8bc1\u660e\u5355\u6b21\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(lgN)$\n\n\u8bc1\u660e\uff1a\n\n\u6211\u4eec\u9700\u8981$3$\u4e2a\u5b9a\u7406\uff1a\n1. $\\forall y\\in son(x)\\  \\&\\ y\\neq son_x$\uff0c\u90fd\u6709$siz_y\\le \\frac{siz_x}{2}$\n\n\u53cd\u8bc1\u6cd5\uff0c\u5047\u8bbe\u6709$siz_y>\\frac{siz_x}{2}$\u4e14$y\\in son(x)$\n\n\u90a3\u4e48\u5c31\u6709$y=son_x$\uff0c\u4e0e\u5b9a\u7406\u77db\u76fe\n\n\u6240\u4ee5\u5047\u8bbe\u4e0d\u6210\u7acb\uff0c\u539f\u547d\u9898\u6210\u7acb\n\n2. $\\forall x\\in son(root)$,\u4ece$root$\u5230$x$\u7684\u8def\u5f84\u4e0a\u5b58\u5728\u4e0d\u8d85\u8fc7$lgN$\u6761\u8f7b\u8fb9\n\n\u56e0\u4e3a\u6bcf\u7ecf\u8fc7\u4e00\u6761\u8f7b\u8fb9\uff0c\u5230\u8fbe\u7684\u70b9\u7684$siz$\u5c31\u4f1a\u51cf\u534a\n\n\u6240\u4ee5\u6700\u591a\u51cf$lgN$\u6b21$siz_x$\u5c31\u53d8\u6210$1$\u4e86$($\u5230\u8fbe\u53f6\u5b50\u8282\u70b9$)$\n\n3. $\\forall x\\in son(root)$\uff0c\u4ece$root$\u5230$x$\u7684\u8def\u5f84\u4e0a\u5b58\u5728\u4e0d\u8d85\u8fc7$lgN$\u6761\u91cd\u94fe\n\n\u56e0\u4e3a\u4e00\u6761**\u91cd\u94fe**\u7684**\u4e24\u7aef**\u5fc5\u5b9a\u662f**\u8f7b\u8fb9**\n\n\u6240\u4ee5\u91cd\u94fe\u7684\u6570\u91cf\u6bd4\u8f7b\u8fb9\u5c11\u4e00\u6761\uff08\u91cd\u94fe\u901a\u5411$root$\u9664\u5916\uff09\n\n\u6700\u574f\u60c5\u51b5\u4e0b\u8f7b\u91cd\u94fe\u6570\u91cf\u4e00\u6837\uff0c\u4e3a$lgN$\n\n\u6240\u4ee5\u6bcf\u6b21\u6211\u4eec\u8df3\u8fc7\u4e00\u6761\u91cd\u94fe\uff0c\u8fd9\u6837\u7684\u91cd\u94fe\u6709$lgN$\u6761\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u4e3a$\\Theta(lgN)$\u5566\n\n\u4f8b\u9898[P3379](https://www.luogu.org/fe/problem/P3379)\n\n\u627e$LCA$\u7684\u677f\u5b50\u9898\n\n\u8fd9\u91cc\u662f[BFS\u5b9e\u73b0\u7248](https://www.luogu.org/recordnew/show/20058405)$($\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u66f4\u6162$)$\n\n$Code(DFS):$\n```cpp\n#include<algorithm>\n#include<cstdio>\n#define N 500010\n#define M 500010\n#define ci const int\nusing namespace std;\nint head[N],ver[M<<1],next[M<<1],tot;\nint dep[N],fa[N],siz[N],son[N],top[N];\nint n,m,root;\nvoid add(ci&x,ci&y){ver[++tot]=y;next[tot]=head[x];head[x]=tot;}\nvoid dfs1(ci&x)\n{\n    siz[x]=1;\n    for(int k=head[x],y;y=ver[k],k;k=next[k])\n    {\n        if(y==fa[x])continue;\n        fa[y]=x;dep[y]=dep[x]+1;dfs1(y);\n        if(siz[son[x]]<siz[y])son[x]=y;\n        siz[x]+=siz[y];\n    }\n}\nvoid dfs2(ci&x)\n{\n    if(!son[x])return;\n    top[son[x]]=top[x];dfs2(son[x]);\n    for(int k=head[x],y;y=ver[k],k;k=next[k])\n    {\n        if(y==fa[x]||y==son[x])continue;\n        top[y]=y;dfs2(y);\n    }\n}\nint LCA(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        x=fa[top[x]];\n    }\n    return dep[x]<dep[y]?x:y;\n}\nsigned main(int argc,char **agrv)\n{\n    scanf(\"%d%d%d\",&n,&m,&root);\n    for(int i=1,x,y;i<n;++i)\n        scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);//\u8bb0\u5f97\u6dfb\u53cc\u5411\u8fb9\u54e6\n    dep[root]=1;dfs1(root);\n    top[root]=root;dfs2(root);\n    register int x,y;\n    while(m--)\n        scanf(\"%d%d\",&x,&y),printf(\"%d\\n\",LCA(x,y));\n    return 0;\n}\n```\n\n## \u5957\u7ebf\u6bb5\u6811\n\u53c8\u6709~~\u777f\u667a~~\u806a\u660e\u7684\u5c0f\u76c6\u53cb\u95ee\u4e86\uff1a\n\n\u8fd9\u4e2a\u5947\u602a\u7684\u4e1c\u897f\u600e\u4e48\u5957\u7ebf\u6bb5\u6811\u5462\uff1f\n\n\u6211\u4eec\u6765\u518d\u770b\u4e00\u770b\u6811\u94fe\u5256\u5206\u540e\u8f7b\u91cd\u8fb9\u7684\u5206\u914d\u60c5\u51b5\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/53672.png)\n\n\u5982\u679c\u6211\u4eec\u628a\u94fe\u62fc\u6210\u4e00\u4e2a\u5e8f\u5217\uff0c\u5c31\u50cf\u8fd9\u6837\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/53789.png)\n\n\u90a3\u4e48\u662f\u4e0d\u662f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5462\uff1f\n\n~~\u4e0d\u662f\u4e5f\u5f97\u662f~~\n\n\u5982\u4f55\u786e\u5b9a\u6bcf\u4e2a\u8282\u70b9\u5728\u5e8f\u5217\u4e2d\u7684\u4f4d\u7f6e\u5462\uff1f\n\n\u6211\u4eec\u56de\u5230$dfs2()$\u4e2d\n\n\u5f88\u5bb9\u6613\u53d1\u73b0\u4e00\u4e2a\u6027\u8d28\uff1a\n\n\u5bf9\u4e8e\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u8282\u70b9\uff0c\u4ed6\u4eec\u4e00\u5b9a\u662f\u88ab**\u8fde\u7eed\u8bbf\u95ee**\u7684\uff01\n\n\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5728$dfs2()$\u4e2d\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728\u5e8f\u5217\u4e2d\u7684\u4f4d\u7f6e\uff08\u5176\u5b9e\u5c31\u662f\u91cd\u6807\u53f7\uff09\n\n$Code:$\n\n```cpp\nvoid dfs2(int x)\n{\n    if(!son[x])return;\n    seg[son[x]]=++cnt;rev[cnt]=son[x];//rev[x]\u8868\u793a\u5e8f\u5217\u4e2dx\u7684\u5bf9\u5e94\u6811\u4e0a\u8282\u70b9\n    top[son[x]]=top[x];dfs2(son[x]);//\u76f4\u63a5\u8bbf\u95eeson[x]\u4fdd\u8bc1\u8fde\u7eed\u6027\n    for(int k=head[x],y;y=ver[k],k;k=next[k])\n    {\n        if(y==fa[x]||y==son[x])continue;\n        seg[y]=++cnt;rev[cnt]=y;//\u7528seg[0]\u4ee3\u66ffcnt\u53ef\u4ee5\u7701\u7a7a\u95f4\n        top[y]=y;dfs2(y);\n    }\n}\n```\n\n\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u662f\uff1a\n\n\u5982\u679c\u8981\u67e5\u8be2\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u6743\u503c\u548c/\u6700\u5927\u503c\uff0c\u600e\u4e48\u529e\u5462\uff1f\n\n\u8bb0$x$\u5230$y$\u7684**\u8def\u5f84\u6743\u503c\u548c**\u4e3a$sum(x,y)$\u3002\n\n\u6765\u770b\u8fd9\u5f20\u56fe\uff1a\n![](https://cdn.luogu.com.cn/upload/pic/58441.png)\n\n\u5047\u8bbe\u73b0\u5728\u67e5\u8be2$sum(3,4)$\n\n\u5c06\u4e0a\u56fe\u6811\u62c6\u6210\u5e8f\u5217\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\n![](https://cdn.luogu.com.cn/upload/pic/58443.png)\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c$top_x\\neq top_y$\uff0c\u90a3\u4e48$dep_{top}$\u8f83\u5927\u7684\u90a3\u6761\u94fe\u7684**\u5168\u90e8\u8282\u70b9**\u90fd\u5728\u7b54\u6848\u4e2d\uff08\u5373$sum(x,top_x)\\in sum(x,y)$ | {$top_x\\neq top_y\\ \\&\\ dep_x>dep_y$}\uff09\n\n\u53c8\u56e0\u4e3a\u6211\u4eec\u7684\u91cd\u94fe\u8282\u70b9\u662f**\u8fde\u7eed\u50a8\u5b58**\u7684\uff0c\u5728\u7ebf\u6bb5\u6811\u4e2d\u662f\u4e00\u6bb5**\u533a\u95f4**\n\n~~\u4e0d\u7528\u6211\u8bf4\u4e86\u5427~~\n\n\u548c\u4e4b\u524d\u4e00\u6837\uff0c\u5f53\u8ba1\u7b97\u5b8c\u5f53\u524d\u94fe\u7684\u7b54\u6848\u540e\uff0c$x$\u8df3\u5230$fa_{top_x}$\n\n\u6700\u540e$top_x==top_y$\u65f6\uff0c\u53ea\u7528\u8ba1\u7b97$sum(x,y)$\u8fd9\u4e00\u6bb5**\u533a\u95f4**\u4e86\u3002\n\n\u6574\u7406\u4e00\u4e0b\uff1a\n\n1. \u8bbe$fx=top_x,fy=top_y$\u3002\n\n2. \u82e5$fx==fy$\uff0c\u6267\u884c\u7b2c4\u6b65\uff1b\u5426\u5219\uff0c\u8bbe$dep_x>dep_y$\uff0c\u6267\u884c\u7b2c\u4e09\u6b65\u3002\n\n3. \u8ba1\u7b97$(x,top_x)$\u5bf9\u7b54\u6848\u7684\u8d21\u732e\uff0c$x=fa_{top_x}$\u3002\n\n4. \u8bbe$dep_x<dep_y$\uff0c\u8ba1\u7b97$(x,y)$\u5bf9\u7b54\u6848\u7684\u8d21\u732e\n\n$Code:$\uff08\u4ee5\u6c42\u548c\u4e3a\u4f8b\uff09\n\n```cpp\nint query_sum(int x,int y)\n{\n    int fx=top[x],fy=top[y],ans=0;\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n        ans+=ask_sum(1,1,n,seg[fx],seg[x]);\n        x=fa[fx],fx=top[x];\n    }\n    if(dep[x]>dep[y])swap(x,y);\n    ans+=ask_sum(1,1,n,seg[x],seg[y]);\n    return ans;\n}\n```\n\u540c\u6837\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u5e7f\u5230 \u6c42$max$/ \u6c42$min$ /\u4fee\u6539 \u7684\u64cd\u4f5c\n\n\u56e0\u4e3a\u6bcf\u6b21\u8df3\u91cd\u94fe\u90fd\u8981\u8fdb\u884c$\\Theta(lgN)$\u7684\u67e5\u8be2\n\n\u6240\u4ee5\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(lg^2N)$\n\n\u4f8b\u9898[P2590](https://www.luogu.org/fe/problem/P2590)\n\n\u8ba4\u771f\u770b\u4ee3\u7801\uff0c\u4e0d\u4f1a\u5f88\u96be\n\n$Code:$\n```cpp\n#include<algorithm>\n#include<cstdio>\n#define N 30010\nusing namespace std;\nint head[N],ver[N<<1],next[N<<1],tot;\nint dep[N],fa[N],siz[N],son[N],top[N];\nint seg[N],rev[N],sum[N<<2],maxn[N<<2];\nint n,m,num[N];char op[10];\ninline void add(int x,int y){ver[++tot]=y;next[tot]=head[x];head[x]=tot;}\n//---------------------------------------------------------\nvoid dfs1(int x)\n{\n    siz[x]=1;\n    for(int k=head[x],y;y=ver[k],k;k=next[k])\n    {\n        if(y==fa[x])continue;\n        fa[y]=x;dep[y]=dep[x]+1;dfs1(y);\n        if(siz[son[x]]<siz[y])son[x]=y;\n        siz[x]+=siz[y];\n    }\n}\nvoid dfs2(int x)\n{\n    if(!son[x])return;\n    seg[son[x]]=++seg[0];rev[seg[0]]=son[x];//\u5206\u914d\u7ebf\u6bb5\u6811\u8282\u70b9\n    top[son[x]]=top[x];dfs2(son[x]);\n    for(int k=head[x],y;y=ver[k],k;k=next[k])\n    {\n        if(y==fa[x]||y==son[x])continue;\n        seg[y]=++seg[0];rev[seg[0]]=y;\n        top[y]=y;dfs2(y);\n    }\n}\n//---------------------------------------------------------\nvoid build(int p,int l,int r)//\u4e0d\u4f1a\u7ebf\u6bb5\u6811\u7684\u53ef\u4ee5\u53bb\u901b\u6211\u7684blog\n{\n    if(l==r){sum[p]=maxn[p]=num[rev[l]];return;}\n    int mid=l+r>>1;\n    build(p<<1,l,mid);build(p<<1|1,mid+1,r);\n    sum[p]=sum[p<<1]+sum[p<<1|1];\n    maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);\n}\nvoid change(int p,int l,int r,int x,int val)\n{\n    if(l==r){sum[p]=maxn[p]=val;return;}\n    int mid=l+r>>1;\n    if(x<=mid)change(p<<1,l,mid,x,val);\n    else change(p<<1|1,mid+1,r,x,val);\n    sum[p]=sum[p<<1]+sum[p<<1|1];\n    maxn[p]=max(maxn[p<<1],maxn[p<<1|1]);\n}\nint ask_sum(int p,int l,int r,int x,int y)\n{\n    if(x<=l&&r<=y)return sum[p];\n    int mid=l+r>>1,ans=0;\n    if(x<=mid)ans=ask_sum(p<<1,l,mid,x,y);\n    if(y>mid)ans+=ask_sum(p<<1|1,mid+1,r,x,y);\n    return ans;\n}\nint ask_max(int p,int l,int r,int x,int y)\n{\n    if(x<=l&&r<=y)return maxn[p];\n    int mid=l+r>>1,ans=-30000;\n    if(x<=mid)ans=ask_max(p<<1,l,mid,x,y);\n    if(y>mid)ans=max(ans,ask_max(p<<1|1,mid+1,r,x,y));\n    return ans;\n}\n//---------------------------------------------------------\nint query_max(int x,int y)//\u67e5\u8be2\u90e8\u5206\n{\n    int fx=top[x],fy=top[y],ans=-30000;//\u8bb0\u5f97\u521d\u59cb\u5316\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n        ans=max(ans,ask_max(1,1,n,seg[fx],seg[x]));//fx~x\u7684\u8fd9\u6761\u94fe\n        x=fa[fx],fx=top[x];\n    }\n    if(dep[x]>dep[y])swap(x,y);\n    ans=max(ans,ask_max(1,1,n,seg[x],seg[y]));//x~y\u7684\u8fd9\u6761\u94fe\n    return ans;\n}\nint query_sum(int x,int y)\n{\n    int fx=top[x],fy=top[y],ans=0;\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n        ans+=ask_sum(1,1,n,seg[fx],seg[x]);//\u540c\u4e0a\n        x=fa[fx],fx=top[x];\n    }\n    if(dep[x]>dep[y])swap(x,y);\n    ans+=ask_sum(1,1,n,seg[x],seg[y]);\n    return ans;\n}\nsigned main()\n{\n    scanf(\"%d\",&n);\n    int x,y;\n    for(int i=1;i<n;++i)\n    scanf(\"%d%d\",&x,&y),add(x,y),add(y,x);\n    for(int i=1;i<=n;++i)scanf(\"%d\",num+i);\n    dep[1]=rev[1]=seg[0]=seg[1]=top[1]=1;//\u8bb0\u5f97\u521d\u59cb\u5316\uff01\uff01\uff01\n    dfs1(1);dfs2(1);build(1,1,n);\n    scanf(\"%d\",&m);\n    while(m--)\n    {\n        scanf(\"%s%d%d\",op,&x,&y);\n        if(*op=='C')change(1,1,n,seg[x],y);\n        else{\n            if(op[1]=='M')printf(\"%d\\n\",query_max(x,y));\n            else printf(\"%d\\n\",query_sum(x,y));\n        }\n    }\n}\n```\n\n---\n\n### \u540e\u8bdd\n\n\u770b\u5b8c\u4e4b\u540e\u8fd9\u4e9b\u9898\u5c31\u53ef\u4ee5\u6109\u5feb\u5730~~WA~~$AC$\u5566\n\n1. [\u3010\u56fd\u5bb6\u96c6\u8bad\u961f\u3011\u65c5\u6e38](https://www.luogu.org/problemnew/show/P1505)\n\n\u4e3b\u8981\u662f\u7ebf\u6bb5\u6811\u4e0a\u7684\u533a\u95f4\u4fee\u6539\n\n\u8fc7\u7a0b\u5982\u4e0b:\n\n\u56e0\u4e3a\u662f\u533a\u95f4$*(-1)$\uff0c\u6240\u4ee5\u4fee\u6539\u540e\u6700\u5927\u503c\u662f$-($\u6700\u5c0f\u503c$)$\uff0c\u6700\u5c0f\u503c\u662f$-($\u6700\u5927\u503c$)$\uff0c\u533a\u95f4\u548c\u662f$-($\u533a\u95f4\u548c$)$\n\n$Code:$\n```\nvoid pushdown(ci&p,ci&l,ci&r)//\u4fee\u6539\u8282\u70b9\n{\n    tree[p]=Node(-tree[p].minn,//\u6700\u5927\u503c = -\u6700\u5c0f\u503c\n                 -tree[p].maxn,//\u6700\u5c0f\u503c = -\u6700\u5927\u503c\n                 -tree[p].sum,tree[p].tag^1);//\u533a\u95f4\u548c = -\u533a\u95f4\u548c\uff0c\u6807\u8bb0 ^= 1\n}\n```\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(Mlg^2N)$\n\n[AC\u4ee3\u7801](https://www.luogu.org/recordnew/show/19845430)\n\n2. [\u8f6f\u4ef6\u5305\u7ba1\u7406\u5668](https://www.luogu.org/fe/problem/P2146)\n\n\u601d\u8def\uff1a\n\n\u8fd0\u7528$dfs()$\u7684\u672c\u8d28$->$\u4ee5$x$\u4e3a\u6839\u7684\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e2d\u4e3a\n$$[seg[x],seg[x]+siz[x]-1]$$\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(Mlg^2N)$\n\n[AC\u4ee3\u7801](https://www.luogu.org/recordnew/show/14296083)\n\n\u4f60\u90fd\u770b\u5230\u8fd9\u4e86\uff0c\u4e0d\u7ed9\u8d5e\u7684\u8bdd~\n\n~~\u90a3\u8fd8\u662f\u4eba\u5417~~",
        "postTime": 1561263661,
        "uid": 84836,
        "name": "a999999",
        "ccfLevel": 6,
        "title": "\u6811\u94fe\u5256\u5206\uff08\u7b2c\u4e8c\u7248\uff09"
    },
    {
        "content": "## \u5927\u5bb6\u597d\uff0c\u6211\u975e\u5e38\u559c\u6b22\u66b4\u529b\u6570\u636e\u7ed3\u6784\uff0c\u4e8e\u662f\u6211\u7528\u5757\u72b6\u6811\u8fc7\u4e86\u8fd9\u9053\u9898\u76ee\n\n## [MY BLOG](https://www.cnblogs.com/HenryHuang-Never-Settle/p/10786200.html)\n\n\u9898\u76ee\uff1a\n\n\u4e00\u68f5\u6811\u4e0a\u6709n\u4e2a\u8282\u70b9\uff0c\u7f16\u53f7\u5206\u522b\u4e3a1\u5230n\uff0c\u6bcf\u4e2a\u8282\u70b9\u90fd\u6709\u4e00\u4e2a\u6743\u503cw\u3002\n\n\u6211\u4eec\u5c06\u4ee5\u4e0b\u9762\u7684\u5f62\u5f0f\u6765\u8981\u6c42\u4f60\u5bf9\u8fd9\u68f5\u6811\u5b8c\u6210\u4e00\u4e9b\u64cd\u4f5c\uff1a\n\nI. CHANGE u t : \u628a\u7ed3\u70b9u\u7684\u6743\u503c\u6539\u4e3at\n\nII. QMAX u v: \u8be2\u95ee\u4ece\u70b9u\u5230\u70b9v\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u7684\u6700\u5927\u6743\u503c\n\nIII. QSUM u v: \u8be2\u95ee\u4ece\u70b9u\u5230\u70b9v\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u7684\u6743\u503c\u548c\n\n\u6ce8\u610f\uff1a\u4ece\u70b9u\u5230\u70b9v\u7684\u8def\u5f84\u4e0a\u7684\u8282\u70b9\u5305\u62ecu\u548cv\u672c\u8eab\n\n----\n\n\u6211\u4eec\u53ef\u4ee5\u5c06\u6811\u5927\u7ea6\u5212\u5206\u4e3a$\\sqrt{n}$\u5757\uff0c\u6bcf\u4e2a\u5757\u5185\u7ef4\u62a4\u5230\u5757\u5185\u6839\u8282\u70b9\u7684\u8def\u5f84\u957f\u5ea6\u4ee5\u53ca\u70b9\u6743\u6700\u5927\u503c\uff0c\u800c\u4e14\uff0c\u663e\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5bfb\u627e\u5b83\u4eec\u7684$LCA$\u6765\u627e\u5230\u4ed6\u4eec\u8def\u5f84\u4e0a\u7684\u6709\u5173\u4fe1\u606f\uff0c\u800c\u8fd9\u91cc\u6211\u4eec\u5df2\u7ecf\u5bf9\u6811\u8fdb\u884c\u4e86\u5206\u5757\u3002\n\n\u6240\u4ee5\u5728\u540c\u4e00\u4e2a\u5757\u5185\u7684\u66b4\u8df3\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u574f\u4e3a$O(\\sqrt{n})$\n\n\u5728\u5757\u4e0e\u5757\u4e4b\u95f4\u7684\u66b4\u8df3\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6700\u574f\u4e3a$O(\\sqrt{n})$\n\n\u8f7b\u677eAC\u672c\u9898\u76ee\n\n\u4ee3\u7801\u4e2d\u6709\u8f83\u8be6\u7ec6\u6ce8\u91ca\uff0c\u8d34\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\nstruct cc{\n\tint to,nex;\n}e[maxn],dis[maxn];\nint head[maxn],cnt1,h[maxn],cnt2;\nvoid add1(int u,int v)//\u539f\u6811\u8fb9 \n{\n\t++cnt1;\n\te[cnt1].to=v;\n\te[cnt1].nex=head[u];\n\thead[u]=cnt1;\n}\nvoid add2(int u,int v)//\u5206\u5757\u540e\u5757\u5185\u6811\u8fb9 \n{\n\t++cnt2;\n\tdis[cnt2].to=v;\n\tdis[cnt2].nex=h[u];\n\th[u]=cnt2;\n}\nint rt[maxn],mx[maxn],sum[maxn],siz[maxn];\nint n,m,v[maxn],deep[maxn],len,fa[maxn];\nvoid dfs(int u,int f,int dep)\n{\n\tdeep[u]=dep;\n\tint tmp=rt[u];\n\tfa[u]=f;\n\tfor(int i=head[u];i;i=e[i].nex)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v!=f)\n\t\t{\n\t\t\tif(siz[tmp]+1<len)\n\t\t\t{\n\t\t\t\tadd2(u,v);//\u5757\u5185\u6811\u8fde\u8fb9 \n\t\t\t\trt[v]=tmp;\n\t\t\t\t++siz[tmp];\n\t\t\t}\n\t\t\tdfs(v,u,dep+1);\n\t\t}\n\t}\n}\nvoid build(int u,int num,int vmx)//\u7ef4\u62a4\u5f53\u524d\u8282\u70b9\uff0c\u5230\u5757\u5185\u6839\u8282\u70b9\u7684\u548c\uff0c\u6700\u5927\u503c\n{\n\tnum+=v[u],sum[u]=num;\n\tvmx=max(vmx,v[u]),mx[u]=vmx;\n\tfor(int i=h[u];i;i=dis[i].nex)\n\t\tbuild(dis[i].to,num,vmx);\n} \nint query(int a,int b,int tag)\n{\n\tint ans1=0;//QSUM\n\tint ans2=-(1<<30);//QMAX\n\twhile(a!=b)//\u7c7b\u4f3c\u4e8e\u500d\u589e\uff0c\u53ea\u4e0d\u8fc7\u8fd9\u91cc\u7684\u8ddd\u79bb\u4e3asqrt(n) \n\t{\n\t\tif(deep[a]<deep[b]) swap(a,b);\n\t\tif(rt[a]==rt[b])//\u82e5\u6240\u5c5e\u540c\u4e00\u4e2a\u5757\n\t\t{\n\t\t\tans1+=v[a];\n\t\t\tans2=max(ans2,v[a]);\n\t\t\ta=fa[a];//\u7531\u4e8e\u5728\u540c\u4e00\u5757\u5185\uff0c\u66b4\u529b\u8df3\u7684\u590d\u6742\u5ea6\u53ea\u4e3aO(sqrt(n)) \n\t\t} \n\t\telse\n\t\t{\n\t\t\tif(deep[rt[a]]<deep[rt[b]]) swap(a,b);//\u5757\u7684\u6df1\u5ea6\u66f4\u6df1 \n\t\t\tans1+=sum[a];\n\t\t\tans2=max(ans2,mx[a]);\n\t\t\ta=fa[rt[a]];//\u76f4\u63a5\u8df3\u4e00\u4e2a\u5757 \n\t\t}\n\t}\n\tans1+=v[a];\n\tans2=max(ans2,v[a]);//\u66f4\u65b0\u5b83\u4eec\u7684LCA\u7684\u503c \n\tif(tag==0) return ans2;\n\telse return ans1; \n} \nvoid change(int u,int x)\n{\n\tv[u]=x;\n\tif(u==rt[u]) build(u,0,-(1<<30));//\u5982\u679c\u662f\u5757\u5185\u6839\u8282\u70b9\u5c31\u6574\u4e2a\u5757\u66f4\u65b0\n\telse build(u,sum[fa[u]],mx[fa[u]]);//\u5982\u679c\u4e0d\u662f\uff0c\u5c31\u4ece\u5176\u7236\u4eb2\u5f00\u59cb\u66f4\u65b0\n}\nint main()\n{\n\tint x,y;\n\tscanf(\"%d\",&n);\n\tlen=sqrt(n);\n\tfor(int i=1;i<n;++i)\n\t\tscanf(\"%d%d\",&x,&y),add1(x,y),add1(y,x);//\u539f\u6811\u8fb9 \n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&v[i]),rt[i]=i;\n\tdfs(1,0,0);\n\tfor(int i=1;i<=n;++i)\n\t\tif(rt[i]==i) \n\t\t\tbuild(i,0,-(1<<30));\n\tscanf(\"%d\",&m);\n\tchar opt[30];\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s%d%d\",opt,&x,&y);\n\t\tif(opt[1]=='M')//QMAX\n\t\t\tprintf(\"%d\\n\",query(x,y,0));//01\u7ef4\u62a4\u8be2\u95ee\u95ee\u9898 \n\t\telse if(opt[1]=='S')//QSUM\n\t\t\tprintf(\"%d\\n\",query(x,y,1));//01\u7ef4\u62a4\u8be2\u95ee\u95ee\u9898 \n\t\telse //CHANGE \n\t\t\tchange(x,y);\n\t}\n\treturn 0;\n}\n\n```\n\n### \u9a97\u5206\u8fc7\u6837\u4f8b\uff0c\u66b4\u529b\u51fa\u5947\u8ff9\uff01\uff01\uff01\n\n\n",
        "postTime": 1556452741,
        "uid": 43957,
        "name": "HenryHuang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u9996\u5148\uff0c\u5b66\u8fc7\u6811\u5256\u7684\u90fd\u77e5\u9053\uff08~~\u867d\u7136\u6211\u6ca1\u5b66\u8fc7~~\uff09\u6811\u4e0a\u64cd\u4f5c\u7528\u6811\u5256\u89e3\u51b3\u5e94\u8be5\u662f\u663e\u7136\u6613\u89c1\u7684\u5427\uff0c\u63a8\u8350\u51e0\u9053\u597d\u9898[\u6a21\u677f](https://www.luogu.org/problem/P3384)\n\n\nAC\u6b64\u9898\u540e\uff0c\u5fc3\u91cc\u6162\u6162\u7684\u8bc9\u8bf4\n\n## \u73cd\u7231\u751f\u547d\uff0c\u8fdc\u79bb\u6811\u5256\uff01\n\n# \u6811\u5256\n\n\u8fd9\u662f\u4e00\u79cd\u7528\u6765\u89e3\u51b3\u7ef4\u62a4\u9759\u6001\u6811\u4e0a\u8def\u5f84\u7684\u95ee\u9898\uff08~~\u867d\u7136\u7801\u91cf\u5f88\u5927~~\uff09\n\n\u57fa\u672c\u95ee\u9898\uff1a\u4fee\u6539\u67d0\u6761\u8def\u5f84\u4e0a\u7684\u6743\u503c\uff0c\u8be2\u95ee\u67d0\u6761\u8def\u5f84\u6240\u6709\u70b9\u7684\u6743\u503c\u548c\u3002\n\n\u76f8\u4fe1\u5927\u5bb6\u90fd\u5b66\u8fc7\u7ebf\u6bb5\u6811\uff0c\u5728\u8fd9\u91cc\uff0c\u7ebf\u6bb5\u6811\u662f\u6b64\u95ee\u9898\u7684\u7279\u6b8a\u60c5\u51b5\uff0c\u60f3\u8c61\u4e00\u4e0b\u8fd9\u9897\u6811\u662f\u4e00\u6761\u94fe\n\n\u6811\u94fe\u5256\u5206\uff0c\u4fbf\u662f\u5c06\u6811\u5256\u5206\u6210\u591a\u6761\u94fe\uff0c\u786e\u5b9a\u94fe\u540e\uff0c\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u89e3\u51b3\u3002\n\n## \u90a3\u8ba9\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0b\u6811\u5256\u5427\uff01\n\n\u57fa\u672c\u4e86\u89e3\uff1a\u91cd\u8fb9\u8f7b\u8fb9\u3002\n\n```cpp\n          7\n         / \\\n        4   2\n       / \\  / \\\n      1 2     1\n       /\n       1\n```\n\u5728\u5982\u4e0a\u56fe\u4e2d\uff0c7-4-2-1,2-1\u662f\u91cd\u8fb9\u3002\u5982\u679c\u8bb0size[x]\u4e3ax\u70b9\u7684\u5b50\u7ed3\u70b9\u6570\u7684\u8bdd\uff0c\u5176\u91cd\u8fb9\u6240\u8fde\u513f\u5b50\u4e2a\u6570\u5fc5\u5927\u4e8e\u6b64\u7ed3\u70b9\u76841/2\n\n\u63a5\u4e0b\u6765\u7684\u9884\u5904\u7406\u4e5f\u53d8\u5f97\u5c24\u4e3a\u7b80\u5355:\n\n\u5904\u74061\uff1a\n\n\u8ba1\u7b97size\u53ca\u91cd\u513f\u5b50\u3002\u6b64\u65f6\u6211\u4eec\u9700\u8981\u6709father\u6570\u7ec4\u8bb0\u5f55\u7236\u7ed3\u70b9\uff0cdep\u6570\u7ec4\u8bb0\u5f55\u6df1\u5ea6\uff0cson\u6570\u7ec4\u8bb0\u5f55\u91cd\u513f\u5b50\u8282\u70b9\n\n\u90a3\u4e48\u7531\u6211\u4eec\u521a\u624d\u7684\u63a8\u8bba\uff0c\u7b97\u91cd\u513f\u5b50\u5fc5\u7136\u7b80\u5355\uff0c\u53ea\u8981\u5c06size\u4e00\u6bd4\u8f83\u5373\u53ef\n\n### \u6ce8\u610f\uff01\n\n\u6bcf\u6b21\u9884\u5904\u7406\u65f6\u9700\u8981\u521d\u59cb\u5316\uff0cdep\u8981\u7b49\u4e8e\u7236\u7ed3\u70b9\u7684dep++\u3002\u7528\u6bcf\u8fb9\u904d\u5386\u5373\u53ef\uff01\n\n```cpp\nvoid dfs1(ll u,ll f)\n{\n\tll e,v;\n\tsize[u]=1;\n\tfather[u]=f;\n\tdep[u]=dep[f]+1;\n\tfor(e=first[u];v=go[e],e;e=next[e])\n\t if(v!=f)\n\t {\n\t \tdfs1(v,u);\n\t \tsize[u]+=size[v];\n\t \tif(size[v]>size[son[u]]) son[u]=v;//\u91cd\u513f\u5b50\uff0c\u4e00\u6bd4\u5373\u53ef\n\t }\n}\n```\n\n\n\u5904\u74062\uff1a\n\n\u8ba1\u7b97\u91cd\u8def\u5f84\uff1a\n\n\u91cd\u8def\u5f84\u7684\u5f00\u59cb\u7684\u7236\u7ed3\u70b9\u5fc5\u4e3a\u8f7b\u8fb9\u6240\u8fde\u7ed3\u70b9\uff08\u5982\u679c\u662f\u6839\u5c31\u8d4b\u521d\u503c\u4e3a0\uff09\n\n```cpp\nvoid dfs2(ll u,ll f)\n{\n\tll e,v;\n\tif(son[u])//\u8ba9\u91cd\u513f\u5b50\u4e0d\u6363\u4e71\uff0c\u4f4d\u7f6e\u8fde\u7eed\n\t{\n\t\tseg[son[u]]=++seg[0];\n\t\ttop[son[u]]=top[u];\n\t\trev[seg[0]]=son[u];\n\t\tdfs2(son[u],u);\n\t}\n\tfor(e=first[u];v=go[e],e;e=next[e])\n\t if(!top[v])\n\t {\n\t \tseg[v]=++seg[0];\n\t \trev[seg[0]]=v;\n\t \ttop[v]=v;\n\t \tdfs2(v,u);\n\t }\n}\n```\n\n## \u6709\u4e86\u9884\u5904\u7406\uff0c\u5c31\u53ef\u4ee5\u5f00\u5f00\u5fc3\u5fc3\u7684AC\u4e86\u5566\uff01\n\n[\u7ebf\u6bb5\u6811\u6a21\u677f](https://www.luogu.org/problem/P3373)\n\n\u63a5\u4e0b\u6765\u8f6c\u5316\u7684\u7ebf\u6bb5\u6811\uff0c\u4e5f\u5df2\u662f\u6211\u4eec\u6240\u53ef\u4ee5AC\u7684\u3002\u90a3\u4e48\u6709\u4e86\u7ebf\u6bb5\u6811\u7684\u5efa\u6811\uff0c\u67e5\u8be2\uff0c\u8be2\u95ee\uff0c\u5c31\u53ef\u4ee5AC\u6811\u5256\uff01\uff01\uff01\n\n\u82e5\u4e0d\u61c2\u7ebf\u6bb5\u6811\uff0c\u8fd9\u91cc\u7ed9\u4e0a\u4ee3\u7801\uff08~~\u867d\u7136\u8fd9\u4e0d\u662f\u7ebf\u6bb5\u6811\u9898\u89e3~~\uff09\n\n```cpp\nvoid build(ll k,ll l,ll r)//\u5efa\u6811\n{\n\tll mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tMax[k]=sum[k]=num[rev[l]];//\u521d\u59cb\u5316\n\t\treturn ;\n\t}\n\tbuild(k<<1,l,mid);//\u5411\u5de6\u5efa\u6811\n\tbuild((k<<1)+1,mid+1,r);//\u5411\u53f3\u5efa\u6811\n\tsum[k]=sum[k<<1]+sum[(k<<1)+1];//\u4e0b\u4f20\u6807\u8bb0\n\tMax[k]=max(Max[k<<1],Max[(k<<1)+1]);\n}\n```\n\n\u5efa\u6811\u4e0d\u61c2\u5f97\u8fd8\u53ef\u4ee5\u641c\u767e\u5ea6\u54e6\uff01\uff01\uff01\n\n```cpp\nvoid ask(ll x,ll y)//\u8def\u5f84\u8be2\u95ee\uff01\n{\n\tll fx=top[x],fy=top[y];\n\twhile(fx!=fy)\n\t{\n\t\tif(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);//\u611f\u89c9\u8fd9\u53e5\u6709\u70b9\u50cfLCA\n\t\tquery(1,1,seg[0],seg[fx],seg[x]);\n\t\tx=father[fx];\n\t\tfx=top[x];\n\t}\n\tif(dep[x]>dep[y]) swap(x,y);\n\tquery(1,1,seg[0],seg[x],seg[y]);//\u5df2\u7ecf\u5728\u4e86\uff0c\u4e0d\u8981\u641c\u4e86\uff01\uff01\uff01\n}\n```\n\n```cpp\nvoid change(ll k,ll l,ll r,ll Val,ll pos)//\u533a\u95f4\u4fee\u6539\uff01\n{\n\tif(pos>r||pos<l) return ;\n\tif(l==r&&r==pos)\n\t{\n\t\tsum[k]=Val;\n\t\tMax[k]=Val;\n\t\treturn ;\n\t}\n\tll mid=l+r>>1;\n\tif(mid>=pos) change(k<<1,l,mid,Val,pos);\n\tif(mid+1<=pos) change((k<<1)+1,mid+1,r,Val,pos);\n\tsum[k]=sum[k<<1]+sum[(k<<1)+1];\n\tMax[k]=max(Max[k<<1],Max[(k<<1)+1]);\n}\n```\n\n\n## \u6b65\u5165\u6b64\u9898\u6b63\u89e3\uff01\uff01\uff01\n\n\u9898\u76ee\u8981\u6c42\u64cd\u4f5c1\n\n\u65e2\u7136\u662fCHANGE\uff0c\u6211\u4eec\u53ea\u9700\u5224\u65ad\u7b2c1\u4e2a\u5b57\u7b26\uff1achange\u4e00\u4e0b\u5373\u53ef\n\n\u64cd\u4f5c2\n\n\u65e2\u7136\u662fQMAX,\u6211\u4eec\u5224\u65ad\u7b2c2\u4e2a\u5b57\u7b26\uff0cask\u4e00\u4e0b\uff0c\u8f93\u51faMaxx\u5373\u53ef\n\n\u64cd\u4f5c3\n\n\u548c\u64cd\u4f5c2\u7c7b\u4f3c\uff0c\u5224\u65ad\u7b2c2\u4e2a\u5b57\u7b26\uff0cask\u4e00\u4e0b\uff0c\u8f93\u51faSumm\u5373\u53ef\n\n# \u6b64\u9898\u5c45\u7136\u88ab\u6211AC\u4e86\uff1f\uff1f\uff1f\n\n\n\uff08~~\u867d\u7136\u4e0d\u662f\u5f88\u76f8\u4fe1~~\uff09\n\u4f46\u8fd8\u662f\u84af\u4e00\u4e0b\u4ee3\u7801\u5427\uff1f\uff1f\uff1f\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define next Next\nusing namespace std;\nconst int N=310000;\nconst int M=124000;\nll n,m,Summ,Maxx,seg[N],rev[M],size[N],son[N],top[N],dep[N],sum[M],num[N],father[N],Max[M],first[N],next[N],go[N];\nvoid query(ll k,ll l,ll r,ll L,ll R)//\u533a\u95f4\u8be2\u95ee \n{\n\tif(L>r||R<l) return ;\n\tif(L<=l&&r<=R)\n\t{\n\t\tSumm+=sum[k];\n\t\tMaxx=max(Maxx,Max[k]);\n\t\treturn ;\n\t } \n\tll mid=(l+r)>>1,res=0;\n\tif(mid>=L) query(k<<1,l,mid,L,R);\n\tif(mid+1<=R) query((k<<1)+1,mid+1,r,L,R);\n}\nvoid change(ll k,ll l,ll r,ll Val,ll pos)\n{\n\tif(pos>r||pos<l) return ;\n\tif(l==r&&r==pos)\n\t{\n\t\tsum[k]=Val;\n\t\tMax[k]=Val;\n\t\treturn ;\n\t}\n\tll mid=l+r>>1;\n\tif(mid>=pos) change(k<<1,l,mid,Val,pos);\n\tif(mid+1<=pos) change((k<<1)+1,mid+1,r,Val,pos);\n\tsum[k]=sum[k<<1]+sum[(k<<1)+1];\n\tMax[k]=max(Max[k<<1],Max[(k<<1)+1]);\n}\nvoid dfs1(ll u,ll f)\n{\n\tll e,v;\n\tsize[u]=1;\n\tfather[u]=f;\n\tdep[u]=dep[f]+1;\n\tfor(e=first[u];v=go[e],e;e=next[e])\n\t if(v!=f)\n\t {\n\t \tdfs1(v,u);\n\t \tsize[u]+=size[v];\n\t \tif(size[v]>size[son[u]]) son[u]=v;\n\t }\n}\nvoid dfs2(ll u,ll f)\n{\n\tll e,v;\n\tif(son[u])\n\t{\n\t\tseg[son[u]]=++seg[0];\n\t\ttop[son[u]]=top[u];\n\t\trev[seg[0]]=son[u];\n\t\tdfs2(son[u],u);\n\t}\n\tfor(e=first[u];v=go[e],e;e=next[e])\n\t if(!top[v])\n\t {\n\t \tseg[v]=++seg[0];\n\t \trev[seg[0]]=v;\n\t \ttop[v]=v;\n\t \tdfs2(v,u);\n\t }\n}\nvoid build(ll k,ll l,ll r)\n{\n\tll mid=l+r>>1;\n\tif(l==r)\n\t{\n\t\tMax[k]=sum[k]=num[rev[l]];\n\t\treturn ;\n\t}\n\tbuild(k<<1,l,mid);\n\tbuild((k<<1)+1,mid+1,r);\n\tsum[k]=sum[k<<1]+sum[(k<<1)+1];\n\tMax[k]=max(Max[k<<1],Max[(k<<1)+1]);\n}\nll read()\n{\n\tll r=0,f=1;char c=getchar();\n\twhile((c<'0'||c>'9')&&(c!='-')) c=getchar();\n\tif(c=='-') f=-1,c=getchar();\n\twhile(c>='0'&&c<='9') r=r*10+c-'0',c=getchar();\n\treturn r*f;\n}\nll tot;\nvoid add(ll x,ll y)\n{\n\tnext[++tot]=first[x];\n\tfirst[x]=tot;\n\tgo[tot]=y;\n}\nvoid insert(ll x,ll y)\n{\n\tadd(x,y);\n\tadd(y,x);\n}\nvoid ask(ll x,ll y)\n{\n\tll fx=top[x],fy=top[y];\n\twhile(fx!=fy)\n\t{\n\t\tif(dep[fx]<dep[fy]) swap(x,y),swap(fx,fy);\n\t\tquery(1,1,seg[0],seg[fx],seg[x]);\n\t\tx=father[fx];\n\t\tfx=top[x];\n\t}\n\tif(dep[x]>dep[y]) swap(x,y);\n\tquery(1,1,seg[0],seg[x],seg[y]);\n}\nint main()\n{\n\tll i,j,k;\n\tn=read();\n\tfor(i=1;i<n;i++)\n\t{\n\t\tll x=read(),y=read();\n\t\tinsert(x,y);\n\t}\n\tfor(i=1;i<=n;i++) num[i]=read();\n\tdfs1(1,0);\n\tseg[0]=seg[1]=top[1]=rev[1]=1;\n\tdfs2(1,0);\n\tbuild(1,1,seg[0]);\n\tm=read();                                   \n\tchar sr[10];\n\tll u,v;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%s\",sr+1);\n\t\tu=read(),v=read();\n\t\tif(sr[1]=='C') change(1,1,seg[0],v,seg[u]);\n\t\telse\n\t\t{\n\t\t\tSumm=0;\n\t\t\tMaxx=-10000000;\n\t\t\task(u,v);\n\t\t\tif(sr[2]=='M') printf(\"%lld\\n\",Maxx);\n\t\t\telse printf(\"%lld\\n\",Summ);\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n\n\u540e\u9762\u611f\u53f9\u4e00\u4e0b\n\n# \u6811\u5256\u7801\u91cf\u771f\u5927\uff01\uff01\uff01\n\n\u4e0d\u5acc\u7d2f\u7684\u8fd8\u53ef\u4ee5\u505a\u4e0b\u8fd9\u51e0\u9053\u8ba9\u6211\u4e27\u5931\u81ea\u5df1\u81ea\u4fe1\u5fc3\u7684\u9898\u5427\n\n[\u8f6f\u4ef6\u5305\u6811\u5256](https://www.luogu.org/problem/P2146)\n\n[\u67d3\u8272\u6811\u5256](https://www.luogu.org/problem/P2486)\n\n# \u52a0\u6cb9\uff0c\u8ba9\u81ea\u5df1\u7206\u8e29STD\uff01\uff01\uff01\n\n\u8c22\u8c22\u5927\u5bb6\u89c2\u770b\uff01",
        "postTime": 1572251022,
        "uid": 138649,
        "name": "\u7237\uff0c\u65e0\u9650\u9738\u6c14",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "### **\u4e0d\u5f97\u4e0d\u8bf4\uff0c\u6811\u5256\u6bd4\u7ebf\u6bb5\u6811\u66f4\u70e6\u4eba\uff0c\u4f46\u5982\u679c\u4f60\u638c\u63e1\u4e86\u7ebf\u6bb5\u6811\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u8fd8\u662f\u4f1a\u8f7b\u677e\u4e00\u4e9b**\n\n\u6ca1\u638c\u63e1\u7684\u540c\u5b66\u53ef\u4ee5\u53bb\u770b\u5927\u4f6c\u535a\u5ba2\uff0c\u5728\u8fd9\u91cc\u5b89\u5229\u6211\u7684[\u7ebf\u6bb5\u6811\u7ffb\u8f66\u70b9](https://www.luogu.org/blog/lcx/guan-yu-xian-duan-shu)\n\n## **\u7167\u65e7\u8bb2\u6811\u94fe\u5256\u5206\u7ffb\u8f66\u70b9**\n\n1. \u7ebf\u6bb5\u6811\u7684\u6570\u7ec4**\u5f004\u500d**\n\n2. \u5f00**long long**\uff08\u4fd7\u8bdd\u8bf4long long\u662f100\u5206\u4e0e0\u5206\u7684\u5206\u754c\u7ebf\uff09\n\n3. dfs1()\u4e0edfs2()\u5728main\u51fd\u6570\u4e2d\u8981**\u653e\u5728build()\u51fd\u6570\u524d**\uff08~~\u6d6a\u8d39\u4e86\u6211\u4e00\u4e0a\u5348~~\uff09\uff0c~~\u6bd5\u7adf\u8fd9\u662f\u5199\u7ed9\u849f\u84bb\u7684~~\n\n4. \u5f53\u4f60\u7f16\u8bd1\u5668\u51fa\u73b0\u8fd0\u884c\u505c\u6b62\u65f6\uff0c\u4e00\u822c\u5e94\u4e3a\u4e24\u70b9\uff1a\n   \n       (1)\u51fd\u6570\u7684\u51fa\u53e3\u4e0d\u660e\u786e\uff0c\u6ce8\u610f\u662f\u4e0d\u662f\u54ea\u91cc\u5c11\u6253\u4e86return\uff1b\n       (2)\u8c03\u7528\u51fd\u6570\u65f6\u8fb9\u754c\u6253\u9519\uff0c\u5bfc\u81f4\u51fd\u6570\u5361\u6b7b\n\n5. \u8bb0\u5f97\u8c03\u7528dfs1()\uff0cdfs2()\u548cbuild()\n\n6. \u5176\u4f59\u7ffb\u8f66\u70b9\u5927\u591a\u5728\u7ebf\u6bb5\u6811\u4e0a\uff0c\u53c2\u8003[\u7ebf\u6bb5\u6811\u8df3\u5751](https://www.luogu.org/blog/lcx/guan-yu-xian-duan-shu)\n\n------------\n\u9898\u76ee\u4f20\u9001\u95e8\uff1a[P2590 [ZJOI2008]\u6811\u7684\u7edf\u8ba1](https://www.luogu.org/problem/P2590)\n\n\u7c98\u4ee3\u7801\uff1a\n\n```cpp\n\n#include<bits/stdc++.h>\n#define ll long long\n#define re register int\nusing namespace std;\nconst int maxn=30005;\nconst int inf=900000005;\ninline ll read()\n{\n\tll x=0,f=1;char c=getchar();\n\twhile(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nll tot=0;\nll w[maxn],b[maxn],d[maxn],fa[maxn];\nll size[maxn],son[maxn],id[maxn],top[maxn];\nstruct node\n{\n\tll nex,to;\n}e[maxn<<1];ll head[maxn<<1],cnt=0;\nstruct dd\n{\n\tll l,r,sum,maxx;\n}t[maxn<<2];\ninline void add(ll x,ll y)\n{\n\te[++cnt].to=y;\n\te[cnt].nex=head[x];\n\thead[x]=cnt;\n}\ninline void dfs1(ll x,ll f,ll deep)\n{\n\tsize[x]=1;\n\td[x]=deep;\n\tfa[x]=f;\n\tfor(re i=head[x];i;i=e[i].nex)\n\t{\n\t\tll y=e[i].to;\n\t\tif(y==f)continue;\n\t\tdfs1(y,x,deep+1);\n\t\tsize[x]+=size[y];\n\t\tif(size[son[x]]<size[y])\n\t\t{\n\t\t\tson[x]=y;\n\t\t}\n\t}\n\treturn;\n}\ninline void dfs2(ll x,ll top_)\n{\n\tid[x]=++tot;\n\tb[tot]=w[x];\n\ttop[x]=top_;\n\tif(!son[x])return;\n\tdfs2(son[x],top_);\n\tfor(re i=head[x];i;i=e[i].nex)\n\t{\n\t\tll y=e[i].to;\n\t\tif(!id[y])dfs2(y,y);\n\t}\n\treturn;\n}\ninline void push_up(ll x)\n{\n\tt[x].sum=t[x<<1].sum+t[x<<1|1].sum;\n\tt[x].maxx=max(t[x<<1].maxx,t[x<<1|1].maxx);\n}\ninline void build(ll x,ll l,ll r)\n{\n\tt[x].l=l;t[x].r=r;\n\tif(l==r)\n\t{\n\t\tt[x].sum=b[l];\n\t\tt[x].maxx=b[l];\n\t\treturn;//return\u4e0d\u80fd\u5c11 \n\t}\n\tll mid=(l+r)>>1;\n\tbuild(x<<1,l,mid);\n\tbuild(x<<1|1,mid+1,r);\n\tpush_up(x);\n\treturn;\n}\ninline void tree_change(ll x,ll l,ll r,ll q,ll v)//\u5355\u70b9\u4fee\u6539 \n{\n\tif(l==r)\n\t{\n\t\tt[x].sum=t[x].maxx=v;\n\t\treturn;//return\u4e0d\u80fd\u5c11 \n\t}\n\tll mid=(l+r)>>1;\n\tif(q<=mid)tree_change(x<<1,l,mid,q,v);\n\telse tree_change(x<<1|1,mid+1,r,q,v);\n\tpush_up(x);\n}\ninline ll querysum(ll x,ll l,ll r)//\u6c42\u65b0\u5e8f\u5217 l\u5230r \u7684\u533a\u95f4\u548c \n{\n\tll ans=0;\n\tif(l<=t[x].l&&r>=t[x].r)\n\t{\n\t\treturn t[x].sum;//return\u4e0d\u80fd\u5c11 \n\t}\n\tll mid=(t[x].l+t[x].r)>>1;\n\tif(l<=mid)ans+=querysum(x<<1,l,r);\n\tif(r>mid)ans+=querysum(x<<1|1,l,r);\n\t//push_up(x);\n\treturn ans;\n}\ninline ll querymax(ll x,ll l,ll r)//\u6c42\u65b0\u5e8f\u5217 l\u5230r \u7684\u533a\u95f4\u6700\u5927\u503c \n{\n\tll ans=-inf;\n\tif(l<=t[x].l&&r>=t[x].r)return t[x].maxx;//return\u4e0d\u80fd\u5c11 \n\tll mid=(t[x].l+t[x].r)>>1;\n\tif(l<=mid)ans=max(ans,querymax(x<<1,l,r));\n\tif(r>mid)ans=max(ans,querymax(x<<1|1,l,r));\n\t//push_up(x);\n\treturn ans;\n}\ninline ll tree_sum(ll u,ll v)//\u6c42\u6811\u4e0a\u8282\u70b9 u\u5230v \u7684\u7b80\u5355\u8def\u5f84\u8282\u70b9\u6743\u503c\u548c \n{\n\tll ans=0;\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(d[top[u]]<d[top[v]])swap(u,v);\n\t\tans+=querysum(1,id[top[u]],id[u]);\n\t\tu=fa[top[u]];\n\t}\n\tif(d[u]>d[v])swap(u,v);\n\tans+=querysum(1,id[u],id[v]);\n\treturn ans;\n}\ninline ll tree_max(ll u,ll v)//\u6c42\u6811\u4e0a\u8282\u70b9 u\u5230v \u7684\u7b80\u5355\u8def\u5f84\u8282\u70b9\u6743\u503c\u6700\u5927\u503c\n{\n\tll ans=-inf;\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(d[top[u]]<d[top[v]])swap(u,v);\n\t\tans=max(ans,querymax(1,id[top[u]],id[u]));\n\t\tu=fa[top[u]];\n\t}\n\tif(d[u]>d[v])swap(u,v);\n\tans=max(ans,querymax(1,id[u],id[v]));\n\treturn ans;\n}\nll n,m;\nint main()\n{\n\tn=read();\n\tint x,y;\n\tfor(re i=1;i<n;i++)\n\t{\n\t\tx=read();y=read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tfor(re i=1;i<=n;i++)w[i]=read();\n\tdfs1(1,0,1);//\u6ce8\u610f\u5148\u540e\u987a\u5e8f \n\tdfs2(1,1);//\u6ce8\u610f\u5148\u540e\u987a\u5e8f \n\tbuild(1,1,n);//\u6ce8\u610f\u5148\u540e\u987a\u5e8f \n\tm=read();\n\tfor(re i=1;i<=m;i++)\n\t{\n\t\tchar cxk[10];\n\t\tcin>>cxk;\n\t\tx=read();y=read();\n\t\tif(cxk[1]=='H')\n\t\t{\n\t\t\ttree_change(1,1,n,id[x],y);\n\t\t}\n\t\telse if(cxk[1]=='M')\n\t\t{\n\t\t\tprintf(\"%lld\\n\",tree_max(x,y));\n\t\t}\n\t\telse if(cxk[1]=='S')\n\t\t{\n\t\t\tprintf(\"%lld\\n\",tree_sum(x,y));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1571793035,
        "uid": 198995,
        "name": "\u8001\u90e8\u957f",
        "ccfLevel": 4,
        "title": "\u6811\u94fe\u5256\u5206\u8df3\u5751"
    },
    {
        "content": "\u54c8\u54c8\u54c8\u54c8\u54c8\u54c8\u54c8\uff0c\u849f\u84bb\u5c45\u7136\u8fc7\u4e86\u6811\u5256\uff0c\u54c8\u54c8\u54c8\u54c8\u54c8\u554a\u54c8\uff0c\u55dd~\n\n\u90a3\u4e48\u8bf7\u5f00\u59cb\u6211\u7684\u6811\u5256\n\n------------\n\n\n\u9996\u5148\u4e0a\u5b9a\u4e49\uff1a\n\n\u5b9a\u4e49siz(x)\u4e3a\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u7684\u7ed3\u70b9\u4e2a\u6570\u3002\n\n\u4ee4v\u4e3au\u7684\u513f\u5b50\u7ed3\u70b9\u4e2dsiz()\u503c\u6700\u5927\u7684\u7ed3\u70b9\uff1a\n\n\u91cd\u7ed3\u70b9\uff1a\u5b50\u6811\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u7684\u7ed3\u70b9\n\n\u8f7b\u8282\u70b9\uff1a\u7236\u4eb2\u8282\u70b9\u4e2d\u9664\u4e86\u91cd\u7ed3\u70b9\u4ee5\u5916\u7684\u7ed3\u70b9\n\n\u91cd\u8fb9\uff1a\u7236\u4eb2\u7ed3\u70b9\u548c\u91cd\u7ed3\u70b9\u8fde\u6210\u7684\u8fb9\uff0c\u5373\u8fb9(u,v)\n\n\u8f7b\u8fb9\uff1a\u91cd\u8fb9\u4e4b\u5916\u7684\u8fb9\n\n\u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\n\n\u8f7b\u94fe\uff1a\u7531\u591a\u6761\u8f7b\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\n\n\u4e00\u4e2a\u975e\u53f6\u8282\u70b9\u6709\u4e14\u4ec5\u6709\u4e00\u4e2a\u91cd\u513f\u5b50\n\n![](https://cdn.luogu.com.cn/upload/pic/19692.png)\n\n\u52a0\u7c97\u7684\u94fe\u5c31\u662f\u91cd\u94fe\uff0c\u6ce8\u610f4\uff0c7\uff0c8\u8fd9\u4e09\u4e2a\u70b9\u4e5f\u662f\u91cd\u94fe\n\n------------\n\u90a3\u4e48\u518d\u4e0a\u4e00\u5806\u6570\u7ec4\uff1a\n\nsiz[i]\u4ee5i\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u4e2d\u7ed3\u70b9\u7684\u6570\u76ee\n\nhson[i]\u7ed3\u70b9i\u7684\u91cd\u513f\u5b50\u7684\u7f16\u53f7\n\ndep[i]\u7ed3\u70b9i\u7684\u6df1\u5ea6\uff0c\u6839\u7684\u6df1\u5ea6\u4e3a1\n\ntop[i]\u7ed3\u70b9i\u6240\u5728\u7684\u91cd\u94fe\u7684\u94fe\u9996\u7ed3\u70b9\u7f16\u53f7\n\nfa[i]\u7ed3\u70b9i\u7684\u7236\u7ed3\u70b9\u7f16\u53f7\n\ntid[i]\u7ed3\u70b9i\u5256\u5206\u4ee5\u540e\u7684\u65b0\u7f16\u53f7\uff08dfs2\u5e8f\u53f7\uff09\n\nrnk[i]\u7ed3\u70b9i\u5728\u6811\u4e2d\u7684\u539f\u4f4d\u7f6e\uff1ai\u4e3a\u65b0\u7f16\u53f7\uff0crnk[i]\u4e3a\u539f\u7f16\u53f7\n\n------------\n\u90a3\u4e48\u600e\u4e48\u6c42\u8fd9\u4e9b\u6570\u7ec4\u5462\uff1f\n\nDFS1\u627e\u91cd\u8fb9 \u987a\u4fbf\u6c42\u51fasiz[i],dep[i],fa[i],hson[i]\n\nDFS2\u5c06\u91cd\u8fb9\u8fde\u6210\u91cd\u94fe \u987a\u4fbf\u6c42\u51fatop[i],tid[i]\uff0c\u8bf4\u7684dfs2\u5e8f\u53f7\u5c31\u662fdfs\u5e8f\u5566\n\n![](https://cdn.luogu.com.cn/upload/pic/19693.png)\n\n\u6a59\u8272\u7684\u662f\u539f\u5e8f\u53f7\uff0c\u7eff\u8272\u7684\u662fdfs\u5e8f\uff0c\u6ce8\u610f\uff0c\u6211\u4eec\u5148\u8d70\u91cd\u513f\u5b50\uff0c\u8fde\u6210\u91cd\u94fe\uff0c\u8ba9\u4e00\u4e2a\u91cd\u94fe\u4e2d\u7684\u6570dfs\u5168\u90e8\u8fde\u5728\u4e00\u8d77\uff0c\u8fd9\u6837\u5c31\u4e3a\u6211\u4eec\u540e\u9762\u7684\u7ebf\u6bb5\u6811\u7ef4\u62a4\u505a\u4e86\u94fa\u57ab\n\n![](https://cdn.luogu.com.cn/upload/pic/19694.png)\n\n\u8fd9\u6837\u6e05\u695a\u4e00\u70b9\n\n------------\n\u73b0\u5728\u662f\u7ebf\u6bb5\u6811\u7ef4\u62a4\u90e8\u5206\n\n\u6211\u4eec\u5df2\u7ecf\u628a\u6811\u5904\u7406\u6210\u4e86\u7ebf\u6027\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\n\n\u5982\u679c\u8981\u6c42i~j\u7684\u6700\u5927\u503c\uff0c\u5982\u679ci\u548cj\u5728\u540c\u4e00\u4e2a\u91cd\u94fe\u4e2d\uff0c\u6211\u4eec\u5c31\u76f4\u63a5\u8f93\u51famax\uff08tid[i]~tid[j]\uff09\uff0c\u800c\u5982\u679c\u4e0d\u5728\u540c\u4e00\u4e2a\u91cd\u94fe\u4e2d\uff0c\u6211\u4eec\u5c31\u8ba9\u6df1\u5ea6\u5927\u7684\u90a3\u4e00\u4e2a\u722c\u6811\uff0c\u722c\u5230\u5b83\u7684top\uff0c\u6c42\u51fa\u5176\u4e2d\u7684\u6700\u5927\u503c\uff0c\u76f4\u5230\u4e24\u4e2a\u6570\u5728\u540c\u4e00\u91cd\u94fe\u4e2d\uff0c\u6211\u4eec\u518d\u6c42\u4e00\u4e0b\u53d6\u4e2amax\u5c31\u53ef\u4ee5\u8f93\u51fa\u4e86\n\n\u90a3\u4e3a\u4ec0\u4e48\u4e0d\u53ef\u4ee5\u76f4\u63a5\u7ebf\u6bb5\u6811\u5462\uff1f\u5f53\u7136\u662f\u56e0\u4e3a\u4e0d\u540c\u91cd\u94fe\u5e76\u4e0d\u4e00\u5b9a\u4e0d\u8fde\u7eed\n\n\u81f3\u4e8e\u4fee\u6539\u7684\u8bdd\uff0c\u6b63\u5e38\u7ebf\u6bb5\u6811\u4fee\u6539\u5c31\u884c\u4e86\n\n------------\n\u90a3\u4e48\uff0c\u4ee3\u7801\u65f6\u95f4\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,cnt=0;\nint a[300100],f[300100];\nint head[300100],nxt[300100],to[300100];\nint siz[300100],d[300100],hs[300100];\nint top[300100],ran[300100],tid[300100];\nint sum[300100],ma[300100];\nvoid addedge(int x,int y,int cn)\n{\n\tnxt[cn]=head[x];\n\thead[x]=cn;\n\tto[cn]=y;\n}\nvoid dfs1(int u,int fa)\n{\n\tf[u]=fa,siz[u]=1;//\u6c42\u51fafa\uff0csize\uff0cdep\uff0chson\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==fa) continue;\n\t\td[v]=d[u]+1;\n\t\tdfs1(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[hs[u]]) hs[u]=v;\n\t}\n}\nvoid dfs2(int u,int h)\n{\n\ttop[u]=h,tid[u]=++cnt,ran[cnt]=u;//\u6c42\u51fatop\uff0ctid\uff0crank\n\tif(!hs[u]) return;//\u91cd\u8fb9\u8d70\u5230\u5934return\n\tdfs2(hs[u],h);//\u5148\u8d70\u91cd\u8fb9\n\tfor(int i=head[u];i!=-1;i=nxt[i])\n\t{\n\t\tint v=to[i];\n\t\tif(v==f[u] || v==hs[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid build(int l,int r,int x)//\u5efa\u6811\n{\n\tif(l==r)\n\t{\n\t\tsum[x]=ma[x]=a[ran[l]];\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(l,mid,x*2);\n\tbuild(mid+1,r,x*2+1);\n\tsum[x]=sum[x*2]+sum[x*2+1];\n\tma[x]=max(ma[x*2],ma[x*2+1]);\n}\nvoid Change(int l,int r,int x,int u,int v)//\u7ebf\u6bb5\u6811\u4fee\u6539\n{\n\tif(l==r)\n\t{\n\t\tma[x]=sum[x]=v;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tif(u<=mid) Change(l,mid,x*2,u,v);\n\telse Change(mid+1,r,x*2+1,u,v);\n\tsum[x]=sum[x*2]+sum[x*2+1];\n\tma[x]=max(ma[x*2],ma[x*2+1]);\n}\nint Clacm(int l,int r,int x,int L,int R)\n{\n\tif(L<=l && R>=r) return ma[x];\n\tint mid=(l+r)/2;\n\tif(R<=mid) return Clacm(l,mid,x*2,L,R);\n\telse if(L>mid) return Clacm(mid+1,r,x*2+1,L,R);\n\telse return max(Clacm(l,mid,x*2,L,R),Clacm(mid+1,r,x*2+1,L,R));\n}\nint Querym(int l,int r,int x,int u,int v)//max\u67e5\u8be2\n{\n\tint ans=-1000000000;//\u6ce8\u610f\u6743\u503c\u6709\u8d1f\u6570\uff0c\u8d4b\u4e2a\u8d1f\u65e0\u7a77\n\twhile(top[u]!=top[v])//\u4e0d\u5728\u540c\u4e00\u91cd\u94fe\u4e2d\uff0c\u722c\u6811\n\t{\n        if(d[top[u]]<d[top[v]]) swap(u,v);\n        ans=max(ans,Clacm(1,n,1,tid[top[u]],tid[u]));//\u6df1\u5ea6\u5927\u7684\u90a3\u4e2a\u722c\u5230top\uff0c\u540c\u65f6\u53d6u~top[u]\u7684\u6700\u5927\u503cmax\u4e00\u4e0b\n        u=f[top[u]];\n    }\n    if(d[u]<d[v]) swap(u,v);\n    ans=max(ans,Clacm(1,n,1,tid[v],tid[u]));//\u540c\u4e00\u91cd\u94fe\u76f4\u63a5\u7ebf\u6bb5\u6811\u6c42max\n    return ans;\n}\nint Clacs(int l,int r,int x,int L,int R)\n{\n\tif(L<=l && R>=r) return sum[x];\n\tint mid=(l+r)/2;\n\tif(R<=mid) return Clacs(l,mid,x*2,L,R);\n\telse if(L>mid) return Clacs(mid+1,r,x*2+1,L,R);\n\telse return Clacs(l,mid,x*2,L,R)+Clacs(mid+1,r,x*2+1,L,R);\n}\nint Querys(int l,int r,int x,int u,int v)//sum\u540c\u7406\n{\n\tint ans=0;\n\twhile(top[u]!=top[v])\n\t{\n        if(d[top[u]]<d[top[v]]) swap(u,v);\n        ans+=Clacs(1,n,1,tid[top[u]],tid[u]);\n        u=f[top[u]];\n    }\n    if(d[u]<d[v]) swap(u,v);\n    ans+=Clacs(1,n,1,tid[v],tid[u]);\n    return ans;\n}\nint main()\n{\n\tmemset(hs,0,sizeof(hs));\n\tmemset(head,-1,sizeof(head));\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\taddedge(x,y,i*2-1);\n\t\taddedge(y,x,i*2);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\td[1]=1,dfs1(1,1),dfs2(1,1);\n\tbuild(1,n,1);\n\tchar tmp[10];\n\tint m,x,y;\n\tscanf(\"%d\",&m);\n\twhile(m--)\n\t{\n\t\tscanf(\"%s%d%d\",tmp,&x,&y);\n\t\tif(tmp[0]=='C') Change(1,n,1,tid[x],y);\n\t\telse if(tmp[1]=='M') printf(\"%d\\n\",Querym(1,n,1,x,y));\n\t\telse printf(\"%d\\n\",Querys(1,n,1,x,y));\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1526819789,
        "uid": 21874,
        "name": "hicc0305",
        "ccfLevel": 0,
        "title": "\u6811\u94fe\u5256\u5206 P2950\u6811\u7684\u7edf\u8ba1\uff08\u6bd4\u6a21\u677f\u8fd8\u7b80\u5355\u3002\u3002\uff09"
    },
    {
        "content": "## \u4e00\u4e2a\u6811\u5256\u9898\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u7ef4\u62a4\u4e00\u4e0b\u4ed6\u7684\u603b\u548c \u4e0e \u6700\u5927\u503c \u5373\u53ef\n\n\u8fd8\u662f\u6bd4\u8f83\u88f8\u7684\uff08~~\u4e00\u773c\u6811\u5256\u5168\u662f\u677f\u5b50~~\uff09\n\n\u8fd9\u91cc\u91c7\u7528\u6570\u7ec4\u5199\u6cd5\uff0c\u6307\u9488\u5199\u6cd5\u8be6\u89c1[\u6211\u535a\u5ba2](https://www.luogu.org/blog/Treaker/#)\u5176\u4ed6\u6811\u5256\u9898\u3002\n\n\u987a\u4fbf\u63a8\u8350\u505a\u4e00\u4e0b\u6a21\u677f[\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384)  \n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <cstdio>\n#include <iostream>\nusing namespace std;\nconst int N = 30030;\nint ls(int x) {return x << 1;}\nint rs(int x) {return x << 1 | 1;}\nint n , m , cnt;\nint head[N] , dep[N] , dfn[N] , id[N] , hs[N] , fa[N] , top[N] , w[N] , sum[N << 2] , maxn[N << 2] , size[N];\nchar s[10];\nstruct Edge // \u94fe\u5f0f\u524d\u5411\u661f\n{\n\tint to , nxt;\n}e[N << 1];\nvoid add(int from,int to) // \u52a0\u8fb9\n{\n\te[++cnt] = (Edge){to,head[from]};\n\thead[from] = cnt;\n}\nvoid get_tree(int now) //\u5efa\u6811\n{\n\tsize[now] = 1;\n\tfor(int i = head[now] , to;i;i = e[i].nxt)\n\t{\n\t\tto = e[i].to;\n\t\tif(dep[to])\tcontinue;\n\t\tfa[to] = now;\n\t\tdep[to] = dep[now] + 1;\n\t\tget_tree(to);\n\t\tsize[now] += size[to];\n\t\tif(size[to] > size[hs[now]])\ths[now] = to;\n\t}\n}\nvoid dfs(int now,int topfa)\n{\n\tdfn[now] = ++cnt;\n\tid[cnt] = now;\n\ttop[now] = topfa;\n\tif(hs[now])\tdfs(hs[now],topfa);\n\tfor(int i = head[now] , to;i;i = e[i].nxt)\n\t{\n\t\tto = e[i].to;\n\t\tif(to == fa[now] || to == hs[now])\tcontinue;\n\t\tdfs(to,to);\n\t}\n}\nvoid build(int p,int l,int r)\n{\n\tif(l == r)\n\t{\n\t\tmaxn[p] = sum[p] = w[id[l]];\n\t\treturn ; \n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(p),l,mid);\n\tbuild(rs(p),mid+1,r);\n\tsum[p] = sum[ls(p)] + sum[rs(p)];\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nvoid chenge(int p,int l,int r,int x,int k)\n{\n\tif(l == r)\t\n\t{\n\t\tsum[p] = k;\n\t\tmaxn[p] = k;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(x <= mid)\tchenge(ls(p),l,mid,x,k);\n\telse\tchenge(rs(p),mid+1,r,x,k);\n\tsum[p] = sum[ls(p)] + sum[rs(p)];\n\tmaxn[p] = max(maxn[ls(p)],maxn[rs(p)]);\n}\nint query_sum(int p,int l,int r,int x,int y)\n{\n\tif(x <= l && r <= y)\treturn sum[p];\n\tint res = 0;\n\tint mid = (l + r) >> 1;\n\tif(x <= mid)\tres = res + query_sum(ls(p),l,mid,x,y);\n\tif(y > mid)\t\tres = res + query_sum(rs(p),mid+1,r,x,y);\n\treturn res;\n}\nint query_max(int p,int l,int r,int x,int y)\n{\n\tif(x <= l && r <= y)\treturn maxn[p];\n\tint res = -2147483647;\n\tint mid = (l + r) >> 1;\n\tif(x <= mid)\tres = max(res,query_max(ls(p),l,mid,x,y));\n\tif(y > mid)\t\tres = max(res,query_max(rs(p),mid+1,r,x,y));\n\treturn res;\n}\nint slove1(int x,int y)\n{\n\tint res = 0;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tres = res + query_sum(1,1,n,dfn[top[x]],dfn[x]);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tres = res + query_sum(1,1,n,dfn[y],dfn[x]);\n\treturn res;\n}\nint slove2(int x,int y)\n{\n\tint res = -2147483647;\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tres = max(res , query_max(1,1,n,dfn[top[x]],dfn[x]));\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tres = max(res , query_max(1,1,n,dfn[y],dfn[x]));\n\treturn res;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 , a , b;i < n;i ++)\n\t{\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadd(a,b);add(b,a);\n\t}\n\tfor(int i = 1;i <= n;i ++)\tscanf(\"%d\",&w[i]);\n\tcnt = 0;\n\tdep[1] = 1;\n\tget_tree(1);\n\tdfs(1,1);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&m);\n\tfor(int i = 1 , u , v;i <= m;i ++)\n\t{\n\t\tscanf(\"%s%d%d\",s,&u,&v);\n\t\tif(s[1] == 'H')\tchenge(1,1,n,dfn[u],v);\n\t\telse\tif(s[1] == 'S')\tprintf(\"%d\\n\",slove1(u,v));\n\t\telse\tprintf(\"%d\\n\",slove2(u,v));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1568809439,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "### \u8fd9\u662f\u4e00\u7bc7\u849f\u84bb\u7684LCT\u9898\u89e3\n\n------------\n\n##### Link Cut Tree\uff08\u52a8\u6001\u6811\uff09\uff0c~~\u4e00\u79cd\u57fa\u7840\u7684\u6570\u636e\u7ed3\u6784~~\uff0c\u53c8\u540d\u6811\u94fe\u5256\u5206PLUS\n\n------------\n\u5148\u8bf4\u4e0bLCT\u7684\u57fa\u672c\u64cd\u4f5c\n\n\uff08LINK,CUT,FINDROOT\u5728\u672c\u9898\u4e2d\u53ef\u4ee5\u4e0d\u7528\uff09\n\nACCESS\uff08\u6253\u901a\u4e00\u4e2a\u70b9\u5230\u6839\u7684\u8def\u5f84\uff09\n```cpp\ninline void access(int o){\n        int last=0;\n        while(o){\n            splay(o);\n            rs=last;\n            pushup(o);\n            last=o;\n            o=tr[o].parent;\n        }\n        return;\n    }\n```\nMAKEROOT\uff08\u4f7f\u4e00\u4e2a\u70b9\u505a\u6839\uff09\n```cpp\ninline void makeroot(int o){\n        access(o);\n        splay(o);\n        pushr(o);\n        return;\n    }\n```\nSPILT\uff08\u8fde\u4e00\u6761x\uff0cy\u7684\u8fb9\uff09\n```cpp\ninline void spilt(int x,int y){\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n```\n------------\n\u7136\u540e\u8bf4\u4e00\u4e0b\u672c\u9898\u9700\u8981\u7528\u7684\u64cd\u4f5c\n```\n    inline int query_sum(int x,int y){\n        return spilt(x,y),tr[y].summ;\n    }\n    inline int query_max(int x,int y){\n        return spilt(x,y),tr[y].maxx;\n    }\n    inline void modify(int o,int v){\n        access(o),splay(o),tr[o].v=v,pushup(o);\n        return;\n    }\n```\n------------\n\u7136\u540e\u8fde\u8fb9\uff1a\n```cpp\nstruct EDGE{\n    struct{\n        int nxt,to;\n    }e[maxn];\n    int first[maxn];\n    #define add(a,b)e[++cnt].nxt=first[a],first[a]=cnt,e[cnt].to=b\n    inline void connect(int a,int b){\n        add(a,b),add(b,a);\n    }\n}E;\nvoid dfs(int u){\n    for(register int ee=E.first[u],v;v=E.e[ee].to,ee;ee=E.e[ee].nxt)\n        if(v!=L.tr[u].parent)\n            L.tr[v].parent=u,dfs(v);\n    return;\n}\n```\n------------\n\u5361\u5e38\u7684\u5feb\u8bfb\u548c\u5feb\u5199\uff1a\n```cpp\nnamespace IO{\n    char buf[1<<21],*pa=buf,*pb=buf;\n    #define gc() (pa==pb&&(pb=(pa=buf)+fread(buf,1,1<<21,stdin),pa==pb)?EOF:*pa++)\n    template<class T>inline void read(T &x){\n        x=0;\n        register int y=0;register char ch=gc();\n        for(;!isdigit(ch);ch=gc())if(ch=='-')y=1;\n        for(;isdigit(ch);ch=gc())x=(x<<3)+(x<<1)+(ch^48);\n        (y)&&(x=-x);\n        return;\n    }\n    inline int readt(){\n        register char ch=gc();\n        for(;!isalpha(ch);ch=gc());//isalpha\u8fd4\u56dech\u662f\u5426\u4e3a\u5b57\u6bcd\n        if(ch=='Q'){\n            ch=gc();\n            if(ch=='M')return 1;\n            else return 2;\n        }\n        if(ch=='C'){\n            return 3;\n        }\n        return 0;\n    }\n    char buffer[1<<21];\n    int p1=-1;const int p2=(1<<21)-1;\n    inline void flush(){\n        fwrite(buffer,1,p1+1,stdout);\n        p1=-1;\n        return;\n    }\n    inline void pc(int x){\n        if(p1==p2)flush();\n        buffer[++p1]=x;\n        return;\n    }\n    template<class T>inline void write(T x){\n        static char buf[20];\n        static int len=-1;\n        if(x>=0){\n            do{\n                buf[++len]=(x%10)^48,x/=10;\n            }while(x);\n        }else{\n            pc('-');\n            do{\n                buf[++len]=(-(x%10)^48),x/=10;\n            }while(x);\n        }\n        while(len>=0)pc(buf[len--]);\n        return;\n    }\n}\nusing IO::read;\nusing IO::readt;\nusing IO::write;\nusing IO::pc;\nusing IO::flush;\n```\n\n\n------------\n\u7136\u540e\u5408\u8d77\u6765\u4e0d\u5c31AC\u4e86\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cctype>\n#define local\n#define maxn 500000\nusing namespace std;\nint cnt=0;\n//namespace IO\u7701\u7565\nstruct LCT{\n    #define ls tr[o].child[0]\n    #define rs tr[o].child[1]\n    #define MAX(a,b,c) max(max(a,b),c)\n    struct luna{\n        int parent,child[2],maxx,summ,v;\n        bool rev;\n    }tr[maxn];\n    int st[maxn],top;\n    inline bool identify(int o){//\u5224\u65ad\u4f4d\u7f6e\n        return tr[tr[o].parent].child[1]==o;\n    }\n    inline bool nroot(int o){//\u5224\u65ad\u662f\u5426\u4e3a\u6839\n        return tr[tr[o].parent].child[1]==o||tr[tr[o].parent].child[0]==o;\n    }\n    inline void pushup(int o){//\u65e5\u5e38pushup\n        tr[o].maxx=MAX(tr[ls].maxx,tr[rs].maxx,tr[o].v);\n        tr[o].summ=tr[ls].summ+tr[rs].summ+tr[o].v;\n        return;\n    }\n    inline void connect(int o,int pa,bool flag){//\u8fde\u8fb9\n        tr[o].parent=pa;\n        tr[pa].child[flag]=o;\n        return;\n    }\n    inline void pushr(int o){//\u7ffb\u8f6c\n        swap(ls,rs);\n        tr[o].rev^=1;\n        return;\n    }\n    inline void pushdown(int o){//\u6807\u8bb0\u4e0b\u653e\n        if(tr[o].rev){\n            if(rs)pushr(rs);\n            if(ls)pushr(ls);\n            tr[o].rev=0;\n        }\n        return;\n    }\n    inline void rotate(int x){//\u57fa\u672crotate\u65cb\u8f6c\n        int y=tr[x].parent;\n        int r=tr[y].parent;\n        bool flag_x=identify(x);\n        bool flag_y=identify(y);\n        int b=tr[x].child[!flag_x];\n        if(nroot(y))tr[r].child[flag_y]=x;\n        tr[x].parent=r;\n        connect(b,y,flag_x);\n        connect(y,x,!flag_x);\n        pushup(y);\n        pushup(x);\n        return;\n    }\n    inline void splay(int at){//splay\u65cb\u8f6c\n        top=0;\n        int pa=at;\n        st[++top]=pa;\n        while(nroot(pa))pa=tr[pa].parent,st[++top]=pa;\n        while(top)pushdown(st[top--]);\n        while(nroot(at)){\n            int pa=tr[at].parent;\n            if(!nroot(pa))rotate(at);\n            else if(identify(pa)==identify(at))rotate(pa),rotate(at);\n            else rotate(at),rotate(at);\n        }\n        return;\n    }\n    inline void access(int o){\n        int last=0;\n        while(o){\n            splay(o);\n            rs=last;\n            pushup(o);\n            last=o;\n            o=tr[o].parent;\n        }\n        return;\n    }\n    inline void makeroot(int o){\n        access(o);\n        splay(o);\n        pushr(o);\n        return;\n    }\n    inline void spilt(int x,int y){\n        makeroot(x);\n        access(y);\n        splay(y);\n    }\n    inline int findroot(int o){\n        access(o);\n        splay(o);\n        while(ls){\n            pushdown(o);\n            o=ls;\n        }\n        return o;\n    }\n    inline void link(int x,int y){\n        makeroot(x);\n        if(findroot(y)!=x){\n            tr[x].parent=y;\n            pushup(x);\n        }\n        return;\n    }\n    inline void cut(int x,int y){\n        makeroot(x);\n        if(findroot(y)==x&&tr[x].parent==y&&!tr[x].child[1]){\n            tr[y].child[0]=0;\n            tr[x].parent=0;\n            pushup(y);\n        }\n        return;\n    }\n    inline int query_sum(int x,int y){\n        return spilt(x,y),tr[y].summ;\n    }\n    inline int query_max(int x,int y){\n        return spilt(x,y),tr[y].maxx;\n    }\n    inline void modify(int o,int v){\n        access(o),splay(o),tr[o].v=v,pushup(o);\n        return;\n    }\n    //\u9632\u6b62\u51b2\u7a81\u597d\u4e60\u60ef\n    #undef MAX\n    #undef ls\n    #undef rs\n}L;\n//struct EDGE\u7701\u7565\nvoid dfs(int u){//\u901a\u8fc7dfs\u5efa\u6811\uff1b\n    for(register int ee=E.first[u],v;v=E.e[ee].to,ee;ee=E.e[ee].nxt)\n        if(v!=L.tr[u].parent)\n            L.tr[v].parent=u,dfs(v);\n    return;\n}\nsigned main(){\n    #ifdef local\n    freopen(\"test.in\",\"r\",stdin);\n    freopen(\"test.out\",\"w\",stdout);\n    #endif\n    int n,q,a,b,c;\n    read(n);\n    for(register int i=1;i<n;++i)\n    read(a),read(b),\n    E.connect(a,b);\n    L.tr[0].maxx=-2147483647;\n    dfs(1);\n    for(register int i=1;i<=n;++i)\n        read(c),\n        L.tr[i].summ=L.tr[i].v=L.tr[i].maxx=c;\n    read(q);\n    for(register int i=1;i<=q;++i){\n        c=readt(),read(a),read(b);\n        if(c==1){\n            printf(\"%d\\n\",L.query_max(a,b));//\u8be2\u95eemax\n        }else if(c==2){\n            printf(\"%d\\n\",L.query_sum(a,b));//\u8be2\u95eesum\n        }else if(c==3){\n            L.modify(a,b);//\u66f4\u6539\u503c\n        }\n    }\n    flush();//\u522b\u5fd8\u4e86flush\uff08\uff09\u4e00\u4e0b\uff0c\u4e0d\u7136WA\u58f0\u4e00\u7247\n    return 0;\n}\n```\n~~\u795e\u5947\u7684\u7ed3\u6784\u4f53\u5d4c\u5957\u554a~~",
        "postTime": 1575207194,
        "uid": 158869,
        "name": "\u76e7\u92c5",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u770b\u5230lct\u7684\u9898\u89e3\u6bd4\u8f83\u5c11\uff0c\u6240\u4ee5\u6211\u6765\u8d21\u732e\u4e00\u7bc7\n\n## \u6ce8\u610f\u7684\u5730\u65b9and\u5751\u70b9\n\n 1. \u53ea\u7528\u628ammax [ 0 ]\uff08\u7ef4\u62a4\u7684\u6700\u5927\u503c\uff09\u521d\u59cb\u5316\u4e3a\u6781\u5c0f\u503c\n \n 2. sum [ i ] , mmax [ i ]\u5728\u8f93\u5165\u65f6\u5c31\u53ef\u8d4b\u503c\u4e3aval [ i ]\n \n 3. \u8981\u5148\u50a8\u5b58\u4e0b\u8054\u901a\u7684\u70b9\uff0c\u5728\u8f93\u5165\u5b8cval\u540e\u518d\u8fdb\u884clink\u64cd\u4f5c \n\n\n\n### CHANGE\u64cd\u4f5c\n\nchange ( x , v )\u8868\u793a\u628a val [ x ] \u6539\u6210v\n\n\u6b65\u9aa4\uff1a\n\n1. \u5c06x\u70b9splay\u5230\u6839\n\n2. \u66f4\u65b0 val [ x ] = v\n\n3. \u8fdb\u884cpushup(x)\u64cd\u4f5c\n\n### QMAX and QSUM\u64cd\u4f5c\n\n\u8f93\u5165x,y\u8868\u793a\u8be2\u95eex,y\u8def\u5f84\u4e0a\u7684\u6700\u5927\u6743\u503c\u6216\u8005\u8def\u5f84\u548c\n\n\u6b65\u9aa4\n\n1. \u53ea\u9700split ( x , y ),\u7136\u540e\u8f93\u51fa mmax [ y ] \u6216\u8005 sum [ y ] \u5373\u53ef\n\n2. \u6b64\u65f6 mmax [ y ]  \u6216 sum [ y ] \u8868\u793a\u7684\u5c31\u662fx\u5230y\u8fd9\u6761\u94fe\u4e0a\u7684\u6700\u5927\u6743\u503c \u6216\u8005 \u6743\u503c\u548c\u4e86\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#define MN 4000001\n#define re register int\n#define ll long long\n#define inf 0x7fffffff\nusing namespace std;\nint f[MN], val[MN], sum[MN], r[MN], son[MN][2];\nint mmax[MN], size[MN];\nint fake1[MN], fake2[MN];\nint zhan[MN];\nint n, m, cnt;\nint get(int x) {  ////\u5224\u65ad\u8282\u70b9\u662f\u5426\u4e3a\u4e00\u4e2aSplay\u7684\u6839\uff08\u4e0e\u666e\u901aSplay\u7684\u533a\u522b1\uff09\n    return son[f[x]][0] == x || son[f[x]][1] == x;\n}  ////\u5982\u679c\u8fde\u7684\u662f\u8f7b\u8fb9\uff0c\u4ed6\u7684\u7236\u4eb2\u7684\u513f\u5b50\u91cc\u6ca1\u6709\u5b83\nvoid pushup(int x) {\n    sum[x] = sum[son[x][0]] + sum[son[x][1]] + val[x];\n    mmax[x] = max(max(mmax[son[x][0]], mmax[son[x][1]]), val[x]);\n}\nvoid filp(int x) {\n    swap(son[x][0], son[x][1]);\n    r[x] ^= 1;\n}\nvoid pushdown(int x) {\n    if (!r[x])\n        return;\n    r[x] = 0;\n    if (son[x][0])\n        filp(son[x][0]);\n    if (son[x][1])\n        filp(son[x][1]);\n}\nvoid rotate(int x) {\n    int y = f[x], z = f[y], k = (son[y][1] == x), s = son[x][!k];\n    if (get(y))\n        son[z][son[z][1] == y] = x;\n    son[x][!k] = y;\n    son[y][k] = s;\n    if (s)\n        f[s] = y;\n    f[y] = x;\n    f[x] = z;\n    pushup(y);\n    // pushup(x);\n}\nvoid splay(int x) {\n    int y = x, top = 0;\n    zhan[++top] = y;\n    while (get(y)) zhan[++top] = f[y], y = f[y];\n    while (top) pushdown(zhan[top--]);\n    while (get(x)) {\n        y = f[x], top = f[y];\n        if (get(y))\n            rotate((son[y][0] == x) ^ (son[top][0] == y) ? x : y);\n        rotate(x);\n    }\n    pushup(x);\n    return;\n}\nvoid access(int x) {\n    for (re y = 0; x; y = x, x = f[x]) {\n        splay(x);\n        son[x][1] = y;\n        pushup(x);\n    }\n}\nvoid makeroot(int x) {\n    access(x);\n    splay(x);\n    filp(x);\n}\nint findroot(int x) {\n    access(x);\n    splay(x);\n    while (son[x][0]) pushdown(x), x = son[x][0];\n    splay(x);\n    return x;\n}\nvoid split(int x, int y) {\n    makeroot(x);\n    access(y);\n    splay(y);\n}\nvoid cut(int x, int y) {\n    split(x, y);\n    if (findroot(y) == x && f[y] == x && !son[y][0]) {\n        f[y] = son[x][1] = 0;\n        pushup(x);\n    }\n    return;\n}\nvoid link(int x, int y) {\n    makeroot(x);\n    if (findroot(y) != x)\n        f[x] = y;\n}\nvoid change(int x, int v) {\n    splay(x);\n    val[x] = v;\n    pushup(x);\n}\nint main() {\n    mmax[0] = -inf;\n    scanf(\"%d\", &n);\n    for (re i = 1; i <= n - 1; i++) {\n        scanf(\"%d%d\", &fake1[i], &fake2[i]);\n    }  //\u5148\u50a8\u5b58\u4e0b\u8981link\u7684\u70b9\uff0c\u7b49\u8f93\u5165\u5b8cval\u540e\u518d\u64cd\u4f5c\n    //\u5de8\u5751\n    for (re i = 1; i <= n; i++) {\n        scanf(\"%d\", &val[i]);\n        sum[i] = mmax[i] = val[i];\n    }\n    int t;\n    for (re i = 1; i <= n - 1; i++) link(fake1[i], fake2[i]);\n    scanf(\"%d\", &t);\n    for (re i = 1; i <= t; i++) {\n        char s[7];\n        int a1, a2;\n        scanf(\"%s\", s);\n        scanf(\"%d%d\", &a1, &a2);\n        if (s[0] == 'C') {\n            change(a1, a2);\n        }\n        if (s[0] == 'Q' && s[1] == 'M') {\n            split(a1, a2);\n            printf(\"%d\\n\", mmax[a2]);\n        }\n        if (s[0] == 'Q' && s[1] == 'S') {\n            split(a1, a2);\n            printf(\"%d\\n\", sum[a2]);\n        }\n    }\n    // for(re i=1;i<=n;i++)\n    // printf(\"%d %d\\n\",mmax[i],sum[i]);\n\n    return 0;\n}\n```\n",
        "postTime": 1563180696,
        "uid": 57823,
        "name": "\u7ea2\u8272OI\u518d\u4e34",
        "ccfLevel": 0,
        "title": "P2590\u6811\u7684\u7edf\u8ba1"
    },
    {
        "content": "\u672c\u849f\u84bb\u7684\u7b2c\u4e00\u4e2a\u6811\u5256\u9898  \n\u6765\u4e00\u4e2avector\u7684\u9898\u89e3\uff08\u56e0\u4e3avector\u597d\u5199\u554a\u54c8\u54c8\u54c8\uff09  \n\u8fd9\u4e2a\u9898\u662f\u5355\u70b9\u4fee\u6539\u533a\u95f4\u67e5\u8be2\uff0c\u4e3a\u4ec0\u4e48\u8981\u7528\u7ebf\u6bb5\u6811\uff1f  \n~~\u4f46\u6211\u4e0d\u4f1a\u7528\u6811\u72b6\u6570\u7ec4\u6c42\u533a\u95f4\u6700\u503c\uff0c\u6240\u4ee5\u8fd8\u662f\u7ebf\u6bb5\u6811\u5427~~   \n~~\u771f\u9999~~  \n#### \u6811\u94fe\u5256\u5206\n\u628a\u4e00\u68f5\u6811\u4e0a\u7684\u94fe\u5206\u6210\u8f7b\u94fe\u548c\u91cd\u94fe\uff0c\u4e00\u4e2a\u6839\u8282\u70b9\u5230\u5176\u8282\u70b9\u6570\u6700\u5927\u7684\u5b50\u6811\u7684\u94fe\u53eb\u91cd\u94fe\uff0c\u5176\u4ed6\u7684\u53eb\u8f7b\u94fe\u3002\u7279\u522b\u7684\uff0c\u4efb\u610f\u4e00\u4e2a\u5355\u72ec\u7684\u70b9\u4e5f\u662f\u4e00\u4e2a\u91cd\u94fe\u3002  \n\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u5904\u7406\u6240\u6709\u70b9\uff0c\u8981\u628a\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u653e\u5728\u4e00\u8d77\uff0c\u4ee5\u4fbf\u4ee5\u540e\u67e5\u8be2\u7684\u65f6\u5019\u4f7f\u7528\u533a\u95f4\u67e5\u8be2\u3002  \n\u67e5\u8be2\u7684\u65f6\u5019\u4ece\u8f83\u6df1\u7684\u90a3\u4e2a\u70b9\u5f80\u4e0a\u8df3\uff0c\u8df3\u7684\u65f6\u5019\u66f4\u65b0\u7b54\u6848\uff0c\u4e00\u76f4\u8df3\u5230\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u7528\u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u8be2\uff08\u662f\u4e0d\u662f\u5f88\u5f62\u8c61\uff09\u3002  \n\u7136\u540e\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u8fd9\u4e2a\u6811\u5e76\u6ca1\u6709\u7ed9\u51fa\u660e\u786e\u7684\u6839\u8282\u70b9\uff0c\u90a3\u5c31\u53ef\u4ee5\u5728\u5efa\u56fe\u7684\u65f6\u5019\u53cc\u5411\u5efa\u8fb9\uff0c\u7136\u540e\u904d\u5386\u7684\u65f6\u5019\u8bb0\u5f55\u7236\u8282\u70b9\u5c31\u597d\u4e86\uff0c\u8fd9\u662f\u5904\u7406\u4e0e\u6811\u6709\u5173\u7684\u95ee\u9898\u65f6\u7684\u5e38\u89c1\u505a\u6cd5\u3002  \n\u7136\u540e\u5c31\u662f\u9884\u5904\u7406\u4e86\uff0c\u9700\u8981\u8fdb\u884c2\u904ddfs\uff0c\u5728dfs\u65f6\u8981\u7ef4\u62a4\u4ee5\u4e0b\u51e0\u4e2a\u91cf\uff1a  \nfather \u8fd9\u4e2a\u70b9\u7684\u7236\u8282\u70b9  \ndep \u8fd9\u4e2a\u70b9\u5728\u6811\u4e2d\u7684\u6df1\u5ea6  \nsize \u4ee5\u8fd9\u4e2a\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u4e2a\u6570  \nson \u8fd9\u4e2a\u70b9\u7684\u91cd\u94fe\u7684\u513f\u5b50  \nseg \u8fd9\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u5bf9\u5e94\u7684\u7f16\u53f7\uff08\u8981\u6ce8\u610f\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\u8981\u6328\u5728\u4e00\u8d77\uff0c\u5f62\u6210\u4e00\u6bb5\u533a\u95f4\uff09  \nrev \u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\u5bf9\u5e94\u7684\u70b9  \ntop \u8fd9\u4e2a\u70b9\u6240\u5728\u91cd\u94fe\u7684\u6700\u9876\u4e0a\u7684\u70b9\uff0c\u611f\u89c9\u5c31\u50cf\u5e76\u67e5\u96c6\uff0c\u7528\u6700\u9876\u4e0a\u7684\u70b9\u6765\u4ee3\u8868\u8fd9\u6761\u94fe\uff08\u53cd\u6b63\u6211\u8fd9\u4e48\u611f\u89c9\uff0c\u5e94\u8be5\u66f4\u597d\u7406\u89e3\uff09  \n\u524d4\u4e2a\u91cf\u5728\u7b2c\u4e00\u904ddfs\u65f6\u53ef\u4ee5\u6c42\u51fa\uff0c\u540e3\u4e2a\u91cf\u5728\u7b2c\u4e8c\u904ddfs\u65f6\u6c42\u51fa  \n\u5c31\u8fd9\u4e9b\u7ec6\u8282\u4e86\uff0c\u81f3\u4e8e\u548c\u7ebf\u6bb5\u6811\u6709\u5173\u7684\u77e5\u8bc6\u53bb\u770b\u7ebf\u6bb5\u6811\u7684\u6a21\u677f\u9898  \n\u6b38\uff1f\u600e\u4e48\u624d10\u5206\uff1f  \n\u539f\u6765\u70b9\u8fd8\u6709\u8d1f\u6743\uff0c\u5728\u7528\u7ebf\u6bb5\u6811\u6c42\u89e3\u65f6\u8981\u628a\u521d\u59cb\u503c\u8bbe\u6210\u4e00\u4e2a\u5f88\u5c0f\u7684\u8d1f\u6570  \n\u8d34\u4ee3\u7801\n```\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector> \n#include<cstring>\nusing namespace std;\nconst int N=100005;\nconst int M=4*N;\nvector <int> edge[N];\nint father[N],dep[N],size[N],son[N],top[N],seg[N],rev[M];\nint sum[M],Max[N],w[N];\nint n,x,y,q;\nstring str;\nint left(int zy)\n{\n\treturn zy<<1;\n}\nint right(int zy)\n{\n\treturn zy<<1|1;\n}\nvoid dfs1(int u,int fa)\n{\n\tint v;\n\tsize[u]=1;\n\tfather[u]=fa;\n\tdep[u]=dep[fa]+1;\n\tfor(int i=0;i<edge[u].size();i++)\n\t{\n\t\tif(edge[u][i]!=fa)\n\t\t{\n\t\t\tv=edge[u][i];\n\t\t\tdfs1(v,u);\n\t\t\tsize[u]+=size[v];\n\t\t\tif(size[v]>size[son[u]])\n\t\t\t\tson[u]=v;\n\t\t}\n\t}\n}\nvoid dfs2(int u,int fa)\n{\n\tint v;\n\tseg[u]=++seg[0];rev[seg[0]]=u;top[u]=top[fa];\n\tif(son[u])\n\t\tdfs2(son[u],u);\n\tfor(int i=0;i<edge[u].size();i++)\n\t{\n\t\tv=edge[u][i];\n\t\tif(!seg[v])\n\t\tdfs2(v,v);\n\t}\n}\nvoid push_up(int zy)\n{\n\tsum[zy]=sum[left(zy)]+sum[right(zy)];\n\tMax[zy]=max(Max[left(zy)],Max[right(zy)]);\n}\nvoid build(int l,int r,int zy)\n{\n\tif(l==r)\n\t{\n\t\tMax[zy]=sum[zy]=w[rev[l]];\n\t}\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,left(zy));\n\t\tbuild(mid+1,r,right(zy));\n\t\tpush_up(zy);\n\t}\n}\nvoid change(int zy,int q,int l,int r,int k)\n{\n\tint mid=(l+r)>>1;\n\tif(l==r)sum[zy]=Max[zy]=k;\n\telse\n\t{\n\t\tif(q<=mid)change(left(zy),q,l,mid,k);\n\t\telse change(right(zy),q,mid+1,r,k);\n\t\tpush_up(zy);\n\t}\n}\nint check_sum(int zy,int l,int r,int nl,int nr)\n{\n\tint ans=0;\n\tif(nl<=l&&nr>=r)\n\t{\n\t\treturn sum[zy];\n\t}\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(nl<=mid)ans+=check_sum(left(zy),l,mid,nl,nr);\n\t\tif(nr>mid)ans+=check_sum(right(zy),mid+1,r,nl,nr);\n\t\treturn ans;\n\t}\n}\nint check_max(int zy,int l,int r,int nl,int nr)\n{\n\tint ans=-4*N;\n\tif(nl<=l&&nr>=r)\n\t{\n\t\treturn Max[zy];\n\t}\n\telse\n\t{\n\t\tint mid=(l+r)>>1;\n\t\tif(nl<=mid)ans=max(ans,check_max(left(zy),l,mid,nl,nr));\n\t\tif(nr>mid)ans=max(ans,check_max(right(zy),mid+1,r,nl,nr));\n\t\treturn ans;\n\t}\n}\nint q_sum(int u,int v)\n{\n\tint ans=0;\n\tint fu=top[u],fv=top[v];\n\twhile(fu!=fv)\n\t{\n\t\tif(dep[fu]<dep[fv])\n\t\t{\n\t\t\tswap(u,v);\n\t\t\tswap(fu,fv);\n\t\t}\n\t\tans+=check_sum(1,1,n,seg[fu],seg[u]);\n\t\tu=father[fu];fu=top[u];\n\t}\n\tif(dep[u]>dep[v])swap(u,v);\n\tans+=check_sum(1,1,n,seg[u],seg[v]);\n\treturn ans;\n}\nint q_max(int u,int v)\n{\n\tint ans=-4*N;\n\tint fu=top[u],fv=top[v];\n\twhile(fu!=fv)\n\t{\n\t\tif(dep[fu]<dep[fv])\n\t\t{\n\t\t\tswap(u,v);\n\t\t\tswap(fu,fv);\n\t\t}\n\t\tans=max(ans,check_max(1,1,n,seg[fu],seg[u]));\n\t\tu=father[fu];fu=top[u];\n\t}\n\tif(dep[u]>dep[v])swap(u,v);\n\tans=max(ans,check_max(1,1,n,seg[u],seg[v]));\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tedge[x].push_back(y);\n\t\tedge[y].push_back(x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\ttop[i]=i;\n\tscanf(\"%d\",&q);\n\tdfs1(1,0);\n\tdfs2(1,1);\n\tbuild(1,n,1);\n\tfor(int i=1;i<=q;i++)\n\t{\n\t\tcin>>str;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tif(str==\"CHANGE\")\n\t\t{\n\t\t\tchange(1,seg[x],1,seg[0],y);\n\t\t}\n\t\tif(str==\"QMAX\")\n\t\t{\n\t\t\tprintf(\"%d\\n\",q_max(x,y));\n\t\t}\n\t\tif(str==\"QSUM\")\n\t\t{\n\t\t\tprintf(\"%d\\n\",q_sum(x,y));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1550139343,
        "uid": 86830,
        "name": "\u4e2d\u4e8c\u75c5",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "$LCT$\u4e5d\u5206\u949f\u8fc7\u6389\u6b64\u9898\uff0c\u7559\u4e2a\u7eaa\u5ff5...\n\n~~\u8bba\u6a21\u677f\u7684\u91cd\u8981\u6027~~\n\n\u8fd9\u7bc7\u9898\u89e3\u4e3b\u8981\u5439\u5618\u6269\u5c55\u6027\u6781\u5f3a\u7684$LCT$\u548c\u4fbf\u4e8e\u91cd\u7528\u7684$C++$`template`\n\n$LCT$\u662f\u4e00\u79cd\u5f3a\u5927\u7684\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u5747\u644a$O(log\\,n)$\u7684\u52a8\u6001\u8fde\u8fb9\u3001\u5220\u8fb9\u3001\u5355\u70b9\u53ca\u8def\u5f84\u7684\u4fee\u6539\u548c\u67e5\u8be2\uff0c\u751a\u81f3\u53ef\u4ee5\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\n\n\u6240\u4ee5\u8fd9\u9898\u663e\u7136\u662f\u4e2a\u88f8\u7684$LCT$\u677f\u5b50\uff08\u96fe\n\n\u5bf9$LCT$\u5b8c\u5168\u4e0d\u4e86\u89e3\u7684[\u5de6\u8f6c\u6a21\u677f\u9898](https://www.luogu.org/problemnew/show/P3690)\n\n\u6b64\u9898\u89e3\u4e3b\u8981\u5c55\u793a\u5bf9$LCT$\u7684\u5927\u529b\u5c01\u88c5\n\n\u65e2\u7136\u662f\u677f\u5b50\uff0c\u5c31\u8981\u201c\u677f\u201d\u5f97\u5f7b\u5e95\u4e00\u70b9\n\n~~\u5199\u51faStandard Template Library\u7684\u98ce\u683c\u6765~~\n\n~~template\u7528\u8d77\u6765\uff0c\u9762\u5411\u5bf9\u8c61\u7528\u8d77\u6765~~\n\n~~\u4f1a\u5199\u9762\u5411\u5bf9\u8c61\u624d\u627e\u5f97\u5230\u5bf9\u8c61~~\n\n\u6211\u7684$LCT$\u6a21\u677f\u9ad8\u5ea6\u5c01\u88c5\uff0c\u53ea\u7559\u4e0b\u4ee5\u4e0b\u63a5\u53e3\u51fd\u6570\uff1a\n\n`make_node:\u521b\u5efa\u65b0\u7ed3\u70b9`\n\n`link:\u8fde\u8fb9`\n\n`cut:\u5220\u8fb9`\n\n`query:\u67e5\u8be2\u8def\u5f84\u4fe1\u606f`\n\n`modify:\u5355\u70b9\u4fee\u6539`\n\n\u6240\u4ee5\u6bcf\u6b21\u91cd\u7528\u4ee3\u7801\u65f6\u53ea\u8981\u91cd\u65b0\u5b9e\u73b0\u4fe1\u606f\u7ef4\u62a4\u65b9\u5f0f\u7684\u4eff\u51fd\u6570\u5c31\u884c\u4e86\u3002\u53ea\u8981\u6ee1\u8db3\u4ea4\u6362\u5f8b\u3001\u7ed3\u5408\u5f8b\u5c31OK\u3002\n\n\u7136\u540e\u8fd9\u9898\u8981\u67e5\u8be2\u4e24\u79cd\u4fe1\u606f\uff1f\n\n\u5f88\u7b80\u5355\uff0c\u5f00\u4e2a`pair`\u5b58\u4e00\u4e0b\u5c31\u597d\u4e86\u3002\u3002\u3002\n\n\u4e0a\u4ee3\u7801\uff0c\u6a21\u677f\u5728\u540e\u9762\uff0c\uff0c\uff0c\n\n```cpp\nconst int N=100005,M=600005;\n\ntypedef std::pair<int,int> Node;\n\nNode operator+(const Node &lhs,const Node &rhs)\n{\n    return Node(lhs.first+rhs.first,std::max(lhs.second,rhs.second));\n}\n\nstruct Add//\u5b9a\u4e49\u7ef4\u62a4\u4fe1\u606f\u7684\u4eff\u51fd\u6570\n{\n    Node operator()(const Node &lhs,const Node &rhs)const\n    {\n        return lhs+rhs;\n    }\n};\n\nlink_cut_tree<Node,Add> LCT;\nlink_cut_tree<Node,Add>::iterator iters[N];//\u4e3a\u4e86\u5c01\u88c5\u5c31\u5199\u4e86\u4e2a\u8fed\u4ee3\u5668\uff0c\u76f8\u5f53\u4e8e\u6307\u5411\u7ed3\u70b9\u7684\u6307\u9488\n\nint main()\n{\n    int n;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)iters[i]=LCT.make_node(Node(0,0));\n    //\u8fd9\u9898\u6bd2\u7624\u628a\u521d\u59cb\u6743\u503c\u653e\u5728\u540e\u9762\uff0c\u6211\u53c8\u4e0d\u60f3\u5b58\u8be2\u95ee\n    for(int i=1;i<n;++i)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        LCT.link(iters[u],iters[v]);\n    }\n    for(int i=1;i<=n;++i)//\u4e8e\u662f\u5c31\u9009\u62e9\u4e00\u4e2a\u4e00\u4e2a\u5355\u70b9\u4fee\u6539\n    {\n        int x;\n        scanf(\"%d\",&x);\n        LCT.modify(iters[i],Node(x,x));//\u663e\u7136\u5bf9\u4e8e\u5355\u4e2a\u7ed3\u70b9\u800c\u8a00\uff0c\u548c\u4e0e\u6700\u5927\u503c\u90fd\u662f\u81ea\u8eab\u7684\u6743\u503c\n    }\n    int q;\n    scanf(\"%d\",&q);\n    while(q--)\n    {\n        char op;\n        int u,v;\n        scanf(\"\\n%*c%c%*s%d%d\",&op,&u,&v);//*\u8868\u793a\u5ffd\u7565\u6b64\u5360\u4f4d\u7b26\u8bfb\u5165\u7684\u6570\u636e\n        if(op=='H')\n        {\n            LCT.modify(iters[u],Node(v,v));\n        }\n        if(op=='S')\n        {\n            printf(\"%d\\n\",LCT.query(iters[u],iters[v]).second.first);\n            //\u4e3a\u4e86\u5224\u65ad\u8fde\u901a\u6027\uff0cquery\u8fd4\u56depair\n            //first\u662fbool\uff0c\u8868\u793a\u662f\u5426\u8054\u901a\uff0csecond\u662f\u8def\u5f84\u4fe1\u606f\n        }\n        if(op=='M')\n        {\n            printf(\"%d\\n\",LCT.query(iters[u],iters[v]).second.second);\n        }\n    }\n}\n```\n\n$LCT\u200b$\u6a21\u677f\uff0c\u7ee7\u7eed\u5439\u7206\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n\n//#define MEMPOOL\n\ntemplate<typename Value_type,typename Functor>\nclass LCT_splay\n{\n    public:\n        struct Node;\n        Node* __new_node(const Value_type&);\n#ifdef MEMPOOL\n    private:\n        Node mem_pool[1<<20];\n        int tot;\n#endif\n};\ntemplate<typename Value_type,typename Functor>\nstruct LCT_splay<Value_type,Functor>::Node:Functor\n{\n    Value_type val,sum;\n    Node* ftr;\n    Node* ch[2];\n//    Node*& lc;\n//    Node*& rc;\n    #define lc ch[0]\n    #define rc ch[1]\n    bool rev;\n\n    Node(const Value_type& v=Value_type()):\n        val(v),\n        sum(v),\n        ftr(NULL),\n//        lc(ch[0]),\n//        rc(ch[1]),\n        rev(0) {ch[0]=ch[1]=NULL;}\n\n    void reverse();\n    void push_down();\n    void push_all();\n    void maintain();\n    bool is_root();\n    void rotate();\n    void splay();\n};\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::reverse()\n{\n    rev^=1;\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::push_down()\n{\n    if(!rev)return;\n    rev=0;\n    Node* ptr=lc;\n    lc=rc;\n    rc=ptr;\n    if(lc!=NULL)lc->reverse();\n    if(rc!=NULL)rc->reverse();\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::push_all()\n{\n    if(!is_root())this->ftr->push_all();\n    push_down();\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::maintain()\n{\n    sum=val;\n    if(lc!=NULL)sum=Functor::operator()(lc->sum,sum);\n    if(rc!=NULL)sum=Functor::operator()(sum,rc->sum);\n}\n\ntemplate<typename Value_type,typename Functor>\nbool LCT_splay<Value_type,Functor>::Node::is_root()\n{\n    return ftr==NULL||(ftr->lc!=this&&ftr->rc!=this);\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::rotate()\n{\n    Node *nftr=ftr,*gftr=ftr->ftr;\n    bool is_rc=nftr->rc==this;\n    bool is_rf=gftr!=NULL?gftr->rc==nftr:0;\n    ftr=gftr;\n    if(!nftr->is_root())gftr->ch[is_rf]=this;\n    nftr->ch[is_rc]=this->ch[!is_rc];\n    if(this->ch[!is_rc]!=NULL)this->ch[!is_rc]->ftr=nftr;\n    nftr->ftr=this;\n    this->ch[!is_rc]=nftr;\n    nftr->maintain();\n    maintain();\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid LCT_splay<Value_type,Functor>::Node::splay()\n{\n    push_all();\n    while(!is_root())\n    {\n        Node *nftr=ftr,*gftr=ftr->ftr;\n        if(nftr->is_root())rotate();\n        else\n        {\n            if((gftr->lc==nftr)^(nftr->lc==this))rotate();\n            else nftr->rotate();\n            rotate();\n        }\n    }\n}\n\ntemplate<typename Value_type,typename Functor>\ntypename\nLCT_splay<Value_type,Functor>::Node* LCT_splay<Value_type,Functor>::__new_node(const Value_type& v)\n{\n#ifdef MEMPOOL\n    if(tot==1<<20)\n    {\n        fprintf(stderr,\"Error:No enough memory\\n\");\n        return NULL;\n    }\n    mem_pool[tot++].val=v;\n    return mem_pool+tot-1;\n#else\n    return new Node(v);\n#endif\n}\n\ntemplate<typename Value_type,typename Functor>\nclass link_cut_tree:public LCT_splay<Value_type,Functor>\n{\n    typedef typename LCT_splay<Value_type,Functor>::Node Node;\n    private:\n        void access(Node*);\n        void make_root(Node*);\n        Node* find_root(Node*);\n        bool split(Node*,Node*);\n    public:\n        struct iterator;\n        iterator make_node(const Value_type&);\n        bool link(const iterator&,const iterator&);\n        bool cut(const iterator&,const iterator&);\n        std::pair<bool,Value_type> query(iterator,iterator);\n        bool modify(iterator,const Value_type&);\n};\n\ntemplate<typename Value_type,typename Functor>\nstruct link_cut_tree<Value_type,Functor>::iterator\n{\n    private:\n        Node* ptr;\n        friend class link_cut_tree;\n    public:\n        Value_type operator*()const{return ptr->val;}\n        iterator(Node* p=NULL):ptr(p) {}\n        iterator(const iterator& iter):ptr(iter.ptr) {}\n};\n\ntemplate<typename Value_type,typename Functor>\nvoid link_cut_tree<Value_type,Functor>::access(Node* ptr)\n{\n    for(Node* nptr=NULL;ptr!=NULL;nptr=ptr,ptr=ptr->ftr)\n        {\n            ptr->splay();\n            ptr->rc=nptr;\n            ptr->maintain();\n        }\n}\n\ntemplate<typename Value_type,typename Functor>\nvoid link_cut_tree<Value_type,Functor>::make_root(Node* ptr)\n{\n    access(ptr);\n    ptr->splay();\n    ptr->reverse();\n}\n\ntemplate<typename Value_type,typename Functor>\ntypename\nlink_cut_tree<Value_type,Functor>::Node* link_cut_tree<Value_type,Functor>::find_root(Node* ptr)\n{\n    access(ptr);\n    ptr->splay();\n    while(ptr->lc!=NULL)ptr->push_down(),ptr=ptr->lc;\n    ptr->splay();\n    return ptr;\n}\n\ntemplate<typename Value_type,typename Functor>\nbool link_cut_tree<Value_type,Functor>::split(Node* sptr,Node* eptr)\n{\n    make_root(sptr);\n    if(find_root(eptr)!=sptr)return 0;\n    eptr->splay();\n    return 1;\n}\n\ntemplate<typename Value_type,typename Functor>\ntypename\nlink_cut_tree<Value_type,Functor>::iterator link_cut_tree<Value_type,Functor>::make_node(const Value_type& v)\n{\n    return iterator(LCT_splay<Value_type,Functor>::__new_node(v));\n}\n\ntemplate<typename Value_type,typename Functor>\nbool link_cut_tree<Value_type,Functor>::link(const iterator& siter,const iterator& eiter)\n{\n    Node* sptr=siter.ptr;\n    Node* eptr=eiter.ptr;\n    make_root(sptr);\n    if(find_root(eptr)==sptr)return 0;\n    sptr->ftr=eptr;\n    return 1;\n}\n\ntemplate<typename Value_type,typename Functor>\nbool link_cut_tree<Value_type,Functor>::cut(const iterator& siter,const iterator& eiter)\n{\n    Node* sptr=siter.ptr;\n    Node* eptr=eiter.ptr;\n    make_root(sptr);\n    if(find_root(eptr)!=sptr||eptr->ftr!=sptr||eptr->lc!=NULL)return 0;\n    eptr->ftr=NULL;\n    sptr->lc=NULL;\n    sptr->maintain();\n    return 1;\n}\n\ntemplate<typename Value_type,typename Functor>\nstd::pair<bool,Value_type> link_cut_tree<Value_type,Functor>::query(iterator siter,iterator eiter)\n{\n    Node* sptr=siter.ptr;\n    Node* eptr=eiter.ptr;\n    if(!split(sptr,eptr))return std::make_pair(0,Value_type());\n    return std::make_pair(1,eptr->sum);\n}\n\ntemplate<typename Value_type,typename Functor>\nbool link_cut_tree<Value_type,Functor>::modify(iterator iter,const Value_type& v)\n{\n    Node* ptr=iter.ptr;\n    if(ptr==NULL)return 0;\n    ptr->splay();\n    ptr->val=v;\n    ptr->maintain();\n    return 1;\n}\n#undef lc\n#undef rc\n```\n\n",
        "postTime": 1563538134,
        "uid": 60489,
        "name": "\u5c0f\u83dc\u9e1f",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "LCT\u677f\u5b50\u9898\uff0c\u7167\u6837\u7528splay\u7ef4\u62a4\u5b9e\u94fe~~\uff08\u6811\u5256\u662f\u4ec0\u4e48\u6211\u4e0d\u4f1a\u8c03\uff09~~\n\n~~\u600e\u4e48LCT\u7684\u9898\u76ee\u90fd\u662f\u677f\u5b50\u9898~~\n\n\u5bf9\u4e8eCHANGE\u64cd\u4f5c\uff0c\u5148\u628a\u8981\u6539\u7684\u8282\u70b9splay\u4e00\u4e0b\u518d\u4fee\u6539\uff0c\u4ee5\u514d\u5f71\u54cd\u5176\u7956\u5148\u7684\u7b54\u6848\u4fe1\u606f\uff08\u597d\u50cf\u4e5f\u53ef\u4ee5\u5148\u6539\u518dsplay+\u66f4\u65b0\uff0c\u4e0d\u8fc7\u6ca1\u8fd9\u4e2a\u5fc5\u8981\u4e86\uff09\n\n\u5bf9\u4e8eQMAX\u548cQSUM\uff0c\u53ea\u9700\u7528splay\u4e0a\u4f20\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u5148\u8bfb\u5165\u70b9\u6743\u518d\u8fde\u8fb9\u5efaLCT\u907f\u514dWA\u548c\u6ca1\u6709\u5fc5\u8981\u7684pushup\u3002\n\ncode\uff1a\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n#define maxn 30005\n#define isdigit(x) ((x) >= '0' && (x) <= '9')\ninline int read() {\n    int res = 0, flag = 1;\n    char c = getchar();\n    while (!isdigit(c)) flag = (c == '-') ? -1 : 1, c = getchar();\n    while (isdigit(c)) res = (res << 1) + (res << 3) + (c ^ 48), c = getchar();\n    return res * flag;\n}\nint fa[maxn], ch[maxn][2], s[maxn], val[maxn], rev[maxn], mx[maxn], n, m, aa[maxn], bb[maxn];\ninline void getrev(int x) {\n    swap(ch[x][0], ch[x][1]);\n    rev[x] ^= 1;\n}\ninline void pushdown(int x) {\n    if (rev[x]) {\n        if (ch[x][0]) getrev(ch[x][0]);\n        if (ch[x][1]) getrev(ch[x][1]);\n        rev[x] = 0;\n    }\n}\ninline void pushup(int x) {\n    s[x] = s[ch[x][0]] + s[ch[x][1]] + val[x];\n    mx[x] = max(max(mx[ch[x][0]], mx[ch[x][1]]), val[x]);\n}\ninline int nroot(int x) {\n    return ch[fa[x]][0] == x || ch[fa[x]][1] == x;\n}\ninline int chk(int x) {\n    return ch[fa[x]][1] == x;\n}\ninline void rotate(int x) {\n    int y = fa[x], z = fa[y], o = chk(x), a = ch[x][o ^ 1];\n    if (nroot(y)) ch[z][chk(y)] = x; fa[x] = z;\n    ch[y][o] = a; if (a) fa[a] = y;\n    ch[x][o ^ 1] = y; fa[y] = x;\n    pushup(y); pushup(x);\n}\nvoid pushall(int x) {\n    if (nroot(x)) pushall(fa[x]);\n    pushdown(x);\n}\ninline void splay(int x) {\n    pushall(x);\n    while (nroot(x)) {\n        int y = fa[x];\n        if (nroot(y)) {\n            if (chk(x) == chk(y)) rotate(y);\n            else rotate(x);\n        }\n        rotate(x);\n    }\n    pushup(x);\n}\ninline void access(int x) {\n    for (int y = 0; x; y = x, x = fa[x])\n        splay(x), ch[x][1] = y, pushup(x);\n}\ninline void makeroot(int x) {\n    access(x); splay(x); getrev(x);\n}\ninline void split(int x, int y) {\n    makeroot(x); access(y); splay(y);\n}\ninline void link(int x, int y) {\n    makeroot(x); fa[x] = y;\n}\nchar opt[10];\nsigned main() {\n    n = read();\n    for (int i = 1; i < n; ++i) {\n        aa[i] = read(), bb[i] = read();\n    }\n    for (int i = 1; i <= n; ++i) val[i] = read();\n    memset(mx, 0xcf, sizeof(mx));\n    for (int i = 1; i < n; ++i) link(aa[i], bb[i]);\n    m = read();\n    while (m--) {\n        scanf(\"%s\", opt);\n        if (opt[0] == 'C') {\n            int u = read(), t = read();\n            splay(u);\n            val[u] = t;\n            pushup(u);\n        }\n        else if (opt[1] == 'S') {\n            int u = read(), v = read();\n            split(u, v);\n            printf(\"%d\\n\", s[v]);\n        }\n        else if (opt[1] == 'M') {\n            int u = read(), v = read();\n            split(u, v);\n            printf(\"%d\\n\", mx[v]);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1547529016,
        "uid": 73574,
        "name": "WAMonster",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u6574\u7406\u4e86\u4e00\u665a\u4e0a\u633a\u5168\u9762\u7684\u6811\u5256\u8be6\u89e3\uff0c\u81ea\u8ba4\u4e3a\u86ee\u8be6\u7ec6\u7684\uff0c\u4e5f\u7b97\u662f\u81ea\u5df1\u7684\u5b66\u4e60\u7b14\u8bb0\u5427\uff1a\n```cpp\n// luogu-judger-enable-o2\n//Copyright (c)2018 Zhang Henry\n//This sourcecode is licensed under Devc++ 5.5.3\n\n#include<bits/stdc++.h>\n#define Lsn (x<<1)  //the left son.\n#define Rsn (x<<1|1)  //the right son (notice : plus one).\n#define Mid (L+R>>1)  //the log2 searching.\nusing namespace std;\n\n/*heavy chain (path):HC;\nson tree:ST.*/\n\nconst int Maxn=30000+19,oo=(1<<30)-1;\ntypedef int one[Maxn];\n\none size,deep,son,ID,top,Fa,Last;\n \n/*size:the size of the ST;\ndeep:the depth of the son;\nson:the largest ST;\ntop:the top point of the HC;\nFa:the father point of the point now;\nID:the dfs order of the point.*/\n\nint Sum[Maxn*4],Max[Maxn*4];\nint nxt[Maxn*2],to[Maxn*2];\nint n,Q,x,y,t,v,cnt,tot,Ql,Qr;\nchar opt[10];\nint f,c;\n\ninline void read(int &x){\t//the reading part.\n    while (!isdigit(c=getchar())&&c!='-');\n    if (c=='-') f=1,x=0;else f=0,x=c-'0';\n    while (isdigit(c=getchar())) x=x*10+c-'0';\n    if (f) x=-x;\n}\n\n////////////////////The Beginning Of The Initalization//////////////////////////// \ninline void DFS_find(int x){\t //the initalization DFS.\n    size[x]=1;\t//the initialization of the size[].\n    for (int i=Last[x];i!=-1;i=nxt[i])\t//search every edge from 'x'.\n        if (to[i]!=Fa[x]){  //if the point next to 'x' is not it's father point:\n            Fa[to[i]]=x;\t//that point's father initialize to 'x'.\n            deep[to[i]]=deep[x]+1;\t//the depth of that point initalize to plusing one.\n            DFS_find(to[i]);\t//search for the that point's sons.\n            size[x]+=size[to[i]];\t//the size of the ST will change after searching.\n            if (size[to[i]]>size[son[x]]) son[x]=to[i];\t //the largest ST changes.\n        }\n}\n\ninline void DFS_con(int x,int anc){\t//the searching of orders DFS.\n//anc:the top of the HC now.\n    ID[x]=++tot;  //the DFS order of 'x'.\n    top[x]=anc;\t//change the top of HC.\n    if (son[x]) DFS_con(son[x],anc);  //serching for the next point on the HC.\n    for (int i=Last[x];i!=-1;i=nxt[i]) \n        if (to[i]!=Fa[x]&&to[i]!=son[x]) DFS_con(to[i],to[i]); \n        //if the point is not on the HC,then itself is a HC.\n}\n////////////////////The End Of The Initalization//////////////////////////// \n\n////////////////////The Beginning Of The Operation//////////////////////////// \ninline void Update(int x,int L,int R){  //log2 searching to change the number.\n    if (L==R) {Sum[x]=Max[x]=v;return;};  //if the query is only one point:\n    if (t<=Mid) Update(Lsn,L,Mid);else Update(Rsn,Mid+1,R); //finding the point.\n    Sum[x]=Sum[Lsn]+Sum[Rsn];  //update the HC sum.\n    Max[x]=max(Max[Lsn],Max[Rsn]);  //update the HC maxnum.\n}\n\ninline int Qsum(int x,int L,int R){  //get the sum in the HC by log2.\n    if (Ql<=L&&R<=Qr) return Sum[x];  //if find the root in the interval -> return the Sum of HC.\n    int Ans=0;  \n    if (Ql<=Mid) Ans+=Qsum(Lsn,L,Mid);  //the recursion.\n    if (Qr>Mid) Ans+=Qsum(Rsn,Mid+1,R);\n    return Ans;\n}\n\ninline int Qmax(int x,int L,int R){  //get the maxnum in the HC by log2.\n    if (Ql<=L&&R<=Qr) return Max[x];  //if find the root in the interval -> return the Max of HC.\n    int Ans=-oo;  //notice:ans should be MAX.\n    if (Ql<=Mid) Ans=max(Ans,Qmax(Lsn,L,Mid));  //the recursion.\n    if (Qr>Mid) Ans=max(Ans,Qmax(Rsn,Mid+1,R));\n    return Ans;\n}\n\ninline int Query(int opt){  //Getting Answer.\n    int a=top[x],b=top[y],Ans=(opt?-oo:0);  //get HC initalization.\n    while (a!=b){\n        if (deep[a]>deep[b]) swap(a,b),swap(x,y);  //just make sure Ql < Qr.\n        Ql=ID[b],Qr=ID[y];  //get DFS order.\n        if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);  //get answer.\n        y=Fa[b];b=top[y];  \n    }\n    Ql=min(ID[x],ID[y]),Qr=max(ID[x],ID[y]);  \n    if (opt) Ans=max(Ans,Qmax(1,1,n));else Ans+=Qsum(1,1,n);  //get answer , so metaphysical!!!\n    return Ans;\n}\n////////////////////The End Of The Operation//////////////////////////// \n \nint main(){\n    read(n);  //the number of points\n    memset(Last,-1,sizeof(Last));  //equals to 'head[]'.\n    for (int i=1;i<n;i++) {\n        read(x),read(y);\n        nxt[cnt]=Last[x];to[cnt]=y;Last[x]=cnt++;  \n        nxt[cnt]=Last[y];to[cnt]=x;Last[y]=cnt++;\n    }  // set up the form.\n    DFS_find(1);  //the initalizational part.\n    DFS_con(1,1);  //the initalizational part.\n    for (int i=1;i<=n;i++) read(v),t=ID[i],Update(1,1,n);  //get in the number of the whole tree.\n    read(Q);\n    while (Q--){\n        scanf(\"%s\",opt);  //get in the opt.\n        if (opt[0]=='C'){\n            read(t),read(v);t=ID[t];\n            Update(1,1,n);  //upload the point.\n        } else{\n            read(x),read(y);\n            printf(\"%d\\n\",Query(opt[1]=='M'));  //a very metaphysical function.\n        }\n    }\n    return 0;\n}\n//Made By ZHRRRRRR.\n//Copyright (c)2018 Zhang Henry\n//This sourcecode is licensed under Devc++ 5.5.3\n```",
        "postTime": 1526134342,
        "uid": 72336,
        "name": "ZHRRRRRR",
        "ccfLevel": 0,
        "title": "\u3010\u77e5\u8b58\u9ede\u3011\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "\u8fd9\u9898\u601d\u8def\u5176\u5b9e\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u78e8\u53fd\u4e00\u70b9\u3002\n\n\u9996\u5148\u6811\u94fe\u5256\u5206\uff0c\u5728dfs\u5e8f\uff0c\u6ce8\u610f\u5c06\u91cd\u94fe\u7684\u70b9\u8fde\u5728\u4e00\u8d77\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\n\n\u522b\u5fd8\u4e86\u5f00long long\uff01\n\n\u6ce8\u610f\u4e00\u4e0b\uff0c\u9898\u76ee\u4e2d\u6709\u53ef\u80fd\u51fa\u73b0\u8d1f\u503c\uff0c\u6545ans\u8d1f\u503c\u4e3a\u8d1f\u65e0\u7a77\u3002\n\n\u800cans\u5927\u5c0f\u4e3along long,\u5e94\u8be5\u51990xefefefefefefefef\u6211\u5f53\u65f6\u51990xefefefef\u72c2WA\u3002T_T\n\n\u770b\u4ee3\u7801\u5427\uff1a\n\n```\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 30004\nusing namespace std;\ntypedef long long ll;\nchar opt[21];\nint n,T,fir[N],sec[N],tot,low[N],fa[N],siz[N];\nint to[N<<1],nxt[N<<1],head[N],cnt,sn[N],tp[N];\nll ml[N<<2],vl[N<<2],a[N];\n\nvoid add(int x,int y)\n{\n    to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;\n}\n\nvoid dfs1(int now,int pre)\n{\n    low[now]=low[pre]+1,fa[now]=pre,siz[now]=1;\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=pre)\n        {\n            dfs1(y,now);\n            siz[now]+=siz[y];\n            if(siz[y]>siz[sn[now]])\n            {\n                sn[now]=y;\n            }\n        }\n    }\n}\n\nvoid dfs2(int now,int tpo)\n{\n    tp[now]=tpo;\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=fa[now])\n        {\n            if(y==sn[now])\n            {\n                dfs2(y,tpo);\n            }else\n            {\n                dfs2(y,y);\n            }\n        }\n    }\n}\n\nvoid dfs3(int now)\n{\n    fir[now]=++tot;\n    if(sn[now])\n    {\n        dfs3(sn[now]);\n    }\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=fa[now]&&y!=sn[now])\n        {\n            dfs3(y);\n        }\n    }\n    sec[now]=tot;\n}\n\nvoid build(int lx,int rx,int nx)\n{\n    if(lx==rx)\n    {\n        ml[nx]=vl[nx]=a[lx];\n        return;\n    }\n    int mid=(lx+rx)>>1;\n    build(lx,mid,nx<<1);\n    build(mid+1,rx,(nx<<1)|1);\n    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);\n}\n\nvoid update(int to,ll aim,int lx,int rx,int nx)\n{\n    if(lx==rx)\n    {\n        vl[nx]=ml[nx]=aim;\n        return;\n    }\n    int mid=(lx+rx)>>1;\n    if(to<=mid)\n    {\n        update(to,aim,lx,mid,nx<<1);\n    }else\n    {\n        update(to,aim,mid+1,rx,(nx<<1)|1);\n    }\n    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);\n}\n\nll query(int ord,int lm,int rm,int lx,int rx,int nx)\n{\n    if(lm<=lx&&rm>=rx)\n    {\n    \tif(ord)\n    \t{\n        \treturn vl[nx];\n        }else\n        {\n        \treturn ml[nx];\n        }\n    }\n    int mid=(lx+rx)>>1;\n    ll ret=0;\n    if(!ord)\n    {\n        ret=0xefefefefefefefef;\n    }\n    if(lm<=mid)\n    {\n    \tif(ord)\n    \t{\n        \tret+=query(ord,lm,rm,lx,mid,nx<<1);\n        }else\n        {\n    \t\tret=max(ret,query(ord,lm,rm,lx,mid,nx<<1));\n    \t}\n    }\n    if(rm>mid)\n    {\n    \tif(ord)\n    \t{\n    \t\tret+=query(ord,lm,rm,mid+1,rx,(nx<<1)|1);\n        }else\n        {\n        \tret=max(ret,query(ord,lm,rm,mid+1,rx,(nx<<1)|1));\n        }\n    }\n    return ret;\n}\n\nvoid solve(int ord,int x,int y)\n{\n    ll ans=0;\n    if(!ord)\n    {\n        ans=0xefefefefefefefef;\n    }\n    while(tp[x]!=tp[y])\n    {\n        if(low[tp[x]]<low[tp[y]])\n        {\n            swap(x,y);\n        }\n        if(ord)\n        {\n            ans+=query(ord,fir[tp[x]],fir[x],1,n,1);\n        }else\n        {\n            ans=max(ans,query(ord,fir[tp[x]],fir[x],1,n,1));\n        }\n        x=fa[tp[x]];\n    }\n    if(low[x]<low[y])\n    {\n        swap(x,y);\n    }\n    if(ord)\n    {\n        ans+=query(ord,fir[y],fir[x],1,n,1);\n    }else\n    {\n        ans=max(ans,query(ord,fir[y],fir[x],1,n,1));\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,ui,vi;i<n;i++)\n    {\n        scanf(\"%d%d\",&ui,&vi);\n        add(ui,vi);\n        add(vi,ui);\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    dfs3(1);\n    for(int i=1;i<=n;i++)\n    {\n    \tscanf(\"%lld\",&a[fir[i]]);\n    }\n    build(1,n,1);\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        scanf(\"%s\",opt);\n        if(opt[0]=='C')\n        {\n            int to;\n            ll aim;\n            scanf(\"%d%lld\",&to,&aim);\n            update(fir[to],aim,1,n,1);\n        }else\n        {\n    \t\tint xi,yi;\n    \t\tscanf(\"%d%d\",&xi,&yi);\n        \tif(opt[1]=='S')\n        \t{\n            \tsolve(1,xi,yi);\n            }else\n            {\n        \t\tsolve(0,xi,yi);\n        \t}\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1524737316,
        "uid": 51082,
        "name": "\u7b11\u7ec6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "```cpp\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#define ll long long\n#define inf 2147483647\n#define max(x,y) ((x)>(y)?(x):(y))\n#define min(x,y) ((x)<(y)?(x):(y))\n#define fur(i,x,y) for(i=x;i<=y;i++)\n#define fdr(i,x,y) for(i=x;i>=y;i--)\n#define Fur(i,x,y) for(ll i=x;i<=y;i++)\n#define Fdr(x,y) for(ll i=x;i>=y;i--)\n#define in2(x,y) in(x);in(y)\n#define in3(x,y,z) in2(x,y);in(z)\n#define in4(a,b,c,d) in2(a,b);in2(c,d)\n#define ln pc('\\n')\n#define pk pc(' ')\n#define outn(x) out(x);ln;\n#define outk(x) out(x);pk\n#define out2(x,y) outk(x);outn(y);\n#define out3(x,y,z) outk(x);out2(y,z)\n#define out4(w,x,y,z) outk(w);out3(x,y,z)\n#define clr(x,y) memset(x,y,sizeof(x))\n#define cpy(x,y) memcpy(x,y,sizeof(x))\nusing namespace std;\n/*---------------------------------------*/\nnamespace fib{char b[300000]= {},*f=b;}\n#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))\ninline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;} \nnamespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}\n#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)\n#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)\nstruct foce{~foce(){pob;fflush(stdout);}} _foce;\nnamespace ib{char b[100];}\ninline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}\n/*------------------------------------------------------------------------------------------------*/\n\n/*------------------------------------------------------------------------------------------------*/\n#define N 40000\nstruct edge{ll to,next;}e[N<<1];\nll n,m,cnt=1,ds=0,p;\nll head[N],siz[N],top[N],pos[N],f[N],d[N],s[N<<2],b[N<<2];\ninline void add(ll x,ll y){e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;}\n//\u4e24\u4e2adfs\ninline void dfs(ll x){//\u6807\u51fa\u6bcf\u4e2a\u70b9\u5305\u62ec\u5b83\u548c\u5b83\u7684\u5b50\u6811\u4e00\u5171\u6709\u591a\u5c11\u4e2a\u70b9\n\tsiz[x]=1;\n\tfor(ll i=head[x];i;i=e[i].next){\n\t\tll to=e[i].to;if(to==f[x])continue;\n\t\tf[to]=x;d[to]=d[x]+1;\n\t\tdfs(to);\n\t\tsiz[x]+=siz[to];\n\t}\n}\ninline void bt(ll x,ll tp){//\u6807\u8bb0\u91cd\u94fe\uff0c\u6807\u51fa\u6bcf\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\n\tpos[x]=++ds;top[x]=tp;\n\tll k=0,i;\n\tfor(i=head[x];i;i=e[i].next)if(e[i].to!=f[x]&&siz[e[i].to]>siz[k])k=e[i].to;\n\tif(!k)return;\n\tbt(k,tp);\n\tfor(i=head[x];i;i=e[i].next)\n\tif(e[i].to!=f[x]&&e[i].to!=k)bt(e[i].to,e[i].to);\n}\n//zkw\u7ebf\u6bb5\u6811\u8dd1\u5f97\u5feb\uff08\u53ea\u662f\u624b\u9178\uff0c\u60f3\u5077\u61d2\uff09\ninline void upd(ll x,ll c){for(s[x+=p]=c,b[x]=c,x>>=1;x;x>>=1){s[x]=s[x<<1]+s[x<<1|1];b[x]=max(b[x<<1],b[x<<1|1]);}}\ninline ll qs(ll l,ll r){\n\tll sum=0;\n\tfor(l=l+p-1,r=r+p+1;l^r^1;l>>=1,r>>=1){if(~l&1)sum+=s[l^1];if(r&1)sum+=s[r^1];}\n\treturn sum;\n}\ninline ll qm(ll l,ll r){\n\tll ans=-inf;\n\tfor(l=l+p-1,r=r+p+1;l^r^1;l>>=1,r>>=1){if(~l&1)ans=max(ans,b[l^1]);if(r&1)ans=max(ans,b[r^1]);}\n\treturn ans;\n}\ninline ll finds(ll x,ll y){\n\tll ans=0;\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tans+=qs(pos[top[x]],pos[x]);x=f[top[x]];\n\t}\n\tif(pos[x]>pos[y])swap(x,y);\n\tans+=qs(pos[x],pos[y]);\n\treturn ans;\n}\n//\u67e5\u8be2\ninline ll findm(ll x,ll y){\n\tll ans=-inf;\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tans=max(ans,qm(pos[top[x]],pos[x]));x=f[top[x]];\n\t}\n\tif(pos[x]>pos[y])swap(x,y);\n\treturn max(ans,qm(pos[x],pos[y]));\n}\nint main(){\n\tchar c[20];\n\tin(n);\n\tll x,y;\n\tFur(i,1,n-1){in2(x,y);add(x,y);add(y,x);}\n\tdfs(1);bt(1,1);\n\tfor(p=1;p<=n+2;p<<=1);\n\tFur(i,1,n){in(x);upd(pos[i],x);}\n\tin(m);\n\twhile(m--){\n\t\tscanf(\"%s\",c);in2(x,y);\n\t\tif(c[0]=='C')upd(pos[x],y);\n\t\telse{outn((c[1]=='S')?finds(x,y):findm(x,y));}\n\t} \n}\n\n```\n\u8981\u4e86\u89e3\u66f4\u591a\uff0c\u53ef\u53c2\u8003[\u9ec4\u5b66\u957f\u7684\u535a\u5ba2](http://hzwer.com/2543.html)\n\n\u66f4\u5b8c\u6574\u7248\uff1ahttps://www.luogu.org/problemnew/show/P3384\n```cpp\n#include<cstdio>\n#define ll long long\n#define inf 2333333\n#define max(x,y) ((x)>(y)?(x):(y))\n#define Fur(i,x,y) for(ll i=x;i<=y;i++)\n#define in2(x,y) in(x);in(y)\n#define in3(x,y,z) in2(x,y);in(z)\n#define in4(a,b,c,d) in2(a,b);in2(c,d)\n#define pn pc('\\n')\nusing namespace std;\n/*---------------------------------------*/\nnamespace fib{char b[300000]= {},*f=b;}\n#define gc ((*fib::f)?(*(fib ::f++)):(fgets(fib::b,sizeof(fib::b),stdin)?(fib::f=fib::b,*(fib::f++)):-1))\ninline void in(ll &x){x=0;char c;bool f=0;while((c=gc)>'9'||c<'0')if(c=='-')f=!f;x=c-48;while((c=gc)<='9'&&c>='0')x=x*10+c-48;if(f)x=-x;}\nnamespace fob{char b[300000]= {},*f=b,*g=b+300000-2;}\n#define pob (fwrite(fob::b,sizeof(char),fob::f-fob::b,stdout),fob::f=fob::b,0)\n#define pc(x) (*(fob::f++)=(x),(fob::f==fob::g)?pob:0)\nstruct foce{~foce(){pob;fflush(stdout);}} _foce;\nnamespace ib{char b[100];}\ninline void out(ll x){if(x==0){pc(48);return;}if(x<0){pc('-');x=-x;}char *s=ib::b;while(x) *(++s)=x%10,x/=10;while(s!=ib::b) pc((*(s--))+48);}\ninline void outn(ll x){out(x);pc('\\n');}\ninline void swap(ll &x,ll &y){ll t=x;x=y;y=t;}\n/*------------------------------------------------------------------------------------------------*/\n\n/*------------------------------------------------------------------------------------------------*/\n#define N 100001\n#define P 1,n,1\nstruct xds{\n#define ls rt<<1\n#define rs ls|1\n#define pu s[rt]=s[ls]+s[rs]\n#define Z ll m=(l+r)>>1;\nll a[N],s[N<<2],add[N<<2];\ninline void pd(ll ln,ll rn,ll rt){if(add[rt]){s[ls]+=add[rt]*ln;s[rs]+=add[rt]*rn;add[ls]+=add[rt];add[rs]+=add[rt];add[rt]=0;}}\ninline void build(ll l,ll r,ll rt){if(l==r){s[rt]=a[l];return;}Z;build(l,m,ls);build(m+1,r,rs);pu;}\ninline void upd(ll L,ll R,ll c,ll l,ll r,ll rt){if(L<=l&&r<=R){s[rt]+=c*(r-l+1);add[rt]+=c;return;}Z;pd(m-l+1,r-m,rt);if(L<=m)upd(L,R,c,l,m,ls);if(R>m)upd(L,R,c,m+1,r,rs);pu;}\ninline ll qh(ll L,ll R,ll l,ll r,ll rt){if(L<=l&&r<=R)return s[rt];Z;pd(m-l+1,r-m,rt);return ((L<=m)?qh(L,R,l,m,ls):0)+((R>m)?qh(L,R,m+1,r,rs):0);}\n}T;\nstruct edge{ll to,next;}e[N<<1];\nll n,sz=0,m,cnt=1,mod,RT;\nll f[N],siz[N],head[N],d[N],top[N],id[N],u[N];\ninline void add(ll x,ll y){e[cnt].to=y;e[cnt].next=head[x];head[x]=cnt++;}\ninline void dfs(ll x){\n\tsiz[x]=1;\n\tfor(ll i=head[x];i;i=e[i].next)\n\tif(e[i].to!=f[x]){\n\t\tf[e[i].to]=x;\n\t\td[e[i].to]=d[x]+1;\n\t\tdfs(e[i].to);\n\t\tsiz[x]+=siz[e[i].to];\n\t}\n}\ninline void bt(ll x,ll tp){\n\tid[x]=++sz;top[x]=tp;T.a[sz]=u[x];\n\tll k=0,i;\n\tfor(i=head[x];i;i=e[i].next)\n\tif(e[i].to!=f[x]&&siz[e[i].to]>siz[k])k=e[i].to;\n\tif(!k)return;\n\tbt(k,tp);\n\tfor(i=head[x];i;i=e[i].next)if(e[i].to!=f[x]&&e[i].to!=k)bt(e[i].to,e[i].to);\n}\ninline ll fh(ll x,ll y){\n\tll ans=0;\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tans+=T.qh(id[top[x]],id[x],P);x=f[top[x]];\n\t}\n\tif(id[x]>id[y])swap(x,y);\n\treturn (ans+T.qh(id[x],id[y],P))%mod;\n}\ninline void updl(ll x,ll y,ll c){\n\twhile(top[x]!=top[y]){\n\t\tif(d[top[x]]<d[top[y]])swap(x,y);\n\t\tT.upd(id[top[x]],id[x],c,P);x=f[top[x]];\n\t}\n\tif(id[x]>id[y])swap(x,y);\n\tT.upd(id[x],id[y],c,P);\n}\ninline void upds(ll x,ll c){T.upd(id[x],id[x]+siz[x]-1,c,P);}\ninline ll qs(ll x){return T.qh(id[x],id[x]+siz[x]-1,P)%mod;}\nint main(){\n\tin4(n,m,RT,mod);\n\tFur(i,1,n)in(u[i]);\n\tll q,x,y,c;\n\tFur(i,1,n-1){in2(x,y);add(x,y);add(y,x);}\n\tdfs(RT);bt(RT,RT);T.build(P);\n\twhile(m--){\n\t\tin2(q,x);\n\t\tif(q==1){in2(y,c);updl(x,y,c);}\n\t\tif(q==2){in(y);outn(fh(x,y));}\n\t\tif(q==3){in(c);upds(x,c);}\n\t\tif(q==4)outn(qs(x));\n\t}\n}\n```\n\u9644\u4e0a\u7801\u9898\u8fc7\u7a0b\uff1ahttps://www.bilibili.com/video/av21350214/",
        "postTime": 1518694191,
        "uid": 36532,
        "name": "localhost",
        "ccfLevel": 0,
        "title": "\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "\u6811\u5256\u5165\u95e8\u9898\u554a\u3002\u3002\u3002\u6bd4\u6a21\u677f\u8fd8\u8981\u7b80\u5355\u3002\u3002\u3002\u4f30\u8ba1zjoi\u5f53\u5e74\u8fd9\u9898\u662f\u6765\u9001\u5206\u7684\u3002\u3002\u3002\n\n~~\u505a\u4e00\u4e0b\u7ec3\u4e0b\u624b\u901f~~\n\n\u8fd9\u91cc\u4ecb\u7ecd\u4e00\u4e0b\u6811\u5256\u7684\u51e0\u4e2a\u57fa\u672c\u6982\u5ff5\uff0c\u5e0c\u671b\u5bf9\u521a\u5b66\u6811\u5256\u7684\u540c\u5b66\u6709\u5e2e\u52a9\u3002\n\n**\u6765\u81eaff\u5de8\u4f6c\u7684\u8bfe\u4ef6**\n\nsize[v]\u8868\u793a\u4ee5v\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u6570\n\n\u91cd\u513f\u5b50\uff1asize[u]\u4e3av\u7684\u5b50\u8282\u70b9\u4e2dsize\u503c\u6700\u5927\u7684\uff0c\u90a3\u4e48u\u5c31\u662fv\u7684\u91cd\u513f\u5b50\n\n\u8f7b\u513f\u5b50\uff1av\u7684\u5176\u4ed6\u5b50\u8282\u70b9\n\n\u91cd\u8fb9\uff1a\u70b9v\u4e0e\u5176\u91cd\u513f\u5b50\u7684\u8fde\u8fb9\n\n\u8f7b\u8fb9\uff1a\u70b9v\u4e0e\u5176\u8f7b\u513f\u5b50\u7684\u8fde\u8fb9\n\n\u91cd\u94fe\uff1a\u7531\u91cd\u8fb9\u8fde\u6210\u7684\u8def\u5f84\n\n\u8f7b\u94fe\uff1a\u8f7b\u8fb9\n\ndep[v]\u8868\u793av\u7684\u6df1\u5ea6\uff08\u6839\u6df1\u5ea6\u4e3a1\uff09\n\ntop[v]\u8868\u793av\u6240\u5728\u7684**\u91cd\u94fe**\u7684\u9876\u7aef\u8282\u70b9\n\nfa[v]\u8868\u793av\u7684\u7236\u4eb2\n\nson[v]\u8868\u793av\u7684\u91cd\u513f\u5b50\n\nidx[v]\u8868\u793av\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\n\ntree[i]\u8868\u793a\u7ebf\u6bb5\u6811\u7b2ci\u4e2a\u70b9\u5bf9\u5e94\u539f\u6811\u7684\u54ea\u4e2a\u8282\u70b9\uff0c\u5373idx\u7684\u9006\u6570\u7ec4\n\n\u7136\u540e\u6211\u5c31\u4e0d\u591a\u8bf4\u4e86\u3002\u3002\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#define For(i,x,y) for (int i=x;i<=y;i++)\n#define cross(i,k) for (int i=first[k];i!=0;i=last[i])\n#define N 30010\n#define kkk -233333333\nusing namespace std;\nstruct tree{\n    int l,r,max,sum;\n}a[8*N]; \nint b[N],to[N<<1],first[N],last[N<<1];\nint n,m,tot,x,y;\nchar s[20];\nvoid add(int x,int y){to[++tot]=y,last[tot]=first[x],first[x]=tot;}\nint size[N],dep[N],son[N],fa[N];\nvoid dfs1(int k){\n    size[k]=1,dep[k]=dep[fa[k]]+1;\n    cross(i,k){\n        int v=to[i];\n        if (v==fa[k]) continue;\n        fa[v]=k,dfs1(v);\n        size[k]+=size[v];\n        if (!son[k]||size[son[k]]<size[v]) son[k]=v;\n    }\n}\nint idc,idx[N],tree[N],top[N];\nvoid dfs2(int k,int tp){\n    top[k]=tp,idx[k]=++idc,tree[idc]=k;\n    if (!son[k]) return;\n    dfs2(son[k],tp);\n    cross(i,k){\n        int v=to[i];\n        if (v==fa[k]||v==son[k]) continue;\n        dfs2(v,v);\n    }\n}\nvoid build(int k,int l,int r){\n    a[k].l=l,a[k].r=r;\n    if (l==r){\n        a[k].sum=a[k].max=b[tree[l]];\n        return;\n    }\n    int mid=l+r >> 1;\n    build(k<<1,l,mid),build(k<<1^1,mid+1,r);\n    a[k].sum=a[k<<1].sum+a[k<<1^1].sum;\n    a[k].max=max(a[k<<1].max,a[k<<1^1].max);\n}\nvoid ud(int k,int l,int r,int x){\n    if (a[k].l>r||a[k].r<l) return;\n    if (a[k].l==l&&a[k].r==r){\n        a[k].sum=a[k].max=x;\n        return;\n    }\n    ud(k<<1,l,r,x),ud(k<<1^1,l,r,x);\n    a[k].sum=a[k<<1].sum+a[k<<1^1].sum;\n    a[k].max=max(a[k<<1].max,a[k<<1^1].max);\n}\nint querysum(int k,int l,int r){\n    if (a[k].l>r||a[k].r<l) return 0;\n    if (a[k].l>=l&&a[k].r<=r) return a[k].sum;\n    return querysum(k<<1,l,r)+querysum(k<<1^1,l,r);\n}\nint querymax(int k,int l,int r){\n    if (a[k].l>r||a[k].r<l) return kkk;\n    if (a[k].l>=l&&a[k].r<=r) return a[k].max;\n    return max(querymax(k<<1,l,r),querymax(k<<1^1,l,r));\n}\nvoid swap(int &x,int &y){int t;t=x,x=y,y=t;}\nint querys(int x,int y){\n    int ans=0;\n    while (top[x]!=top[y]){\n        if (dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans+=querysum(1,idx[top[x]],idx[x]);\n        x=fa[top[x]];\n    }\n    if (dep[x]>dep[y]) swap(x,y);\n    ans+=querysum(1,idx[x],idx[y]);\n    return ans;\n}\nint querym(int x,int y){\n    int ans=kkk;\n    while (top[x]!=top[y]){\n        if (dep[top[x]]<dep[top[y]]) swap(x,y);\n        ans=max(ans,querymax(1,idx[top[x]],idx[x]));\n        x=fa[top[x]];\n    }\n    if (dep[x]>dep[y]) swap(x,y);\n    ans=max(ans,querymax(1,idx[x],idx[y]));\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    For(i,1,n-1){\n        scanf(\"%d%d\",&x,&y);\n        add(x,y),add(y,x);\n    }\n    dfs1(1);\n    dfs2(1,1);\n    For(i,1,n) scanf(\"%d\",&b[i]);\n    build(1,1,n);\n    scanf(\"%d\",&m);\n    For(i,1,m){\n        scanf(\"%s%d%d\",&s,&x,&y);\n        if (s[0]=='C') ud(1,idx[x],idx[x],y);\n        if (s[0]=='Q'&&s[1]=='S') printf(\"%d\\n\",querys(x,y));\n        if (s[0]=='Q'&&s[1]=='M') printf(\"%d\\n\",querym(x,y));\n    }\n    return 0;\n}\n```",
        "postTime": 1514376458,
        "uid": 25355,
        "name": "\u590f\u8272\u796d",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u9898\u89e3\u5199\u7684\u4e0d\u597d\uff0cdalao\u52ff\u55b7\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\n\n\u5efa\u8bae\u6709\u4e00\u70b9\u6570\u5256\u57fa\u7840\u7684\u770b\u6b64\u9898\u89e3\uff0c\u8fd9\u662f\u4e00\u9053\u6811\u5256\u6a21\u677f\u9898\uff0c\u53ef\u4ee5\u7528\u6765\u7ec3\u7ec3\u624b\u3002\n\n###\u4e00.\u9996\u5148\u6211\u5148\u8bb2\u8bb2\u4e66\u5256\u90e8\u5206\u601d\u60f3\uff1a\n\n![1](https://p1.ssl.qhmsg.com/dr/270\\_500\\_/t016907872b80ef36c1.jpg)\n\n1.\u5c06\u4e00\u68f5\u6811\u5212\u5206\u6210\u82e5\u5e72\u6761\u94fe\uff0c\u7528\u6570\u636e\u7ed3\u6784\uff08\u7ebf\u6bb5\u6811\uff09\u53bb\u7ef4\u62a4\u6bcf\u6761\u94fe\uff0c\u590d\u6742\u5ea6\u4e3aO(logN)\uff1b\n\n2.**\u6838\u5fc3\u6570\u7ec4\uff1a**\n\nsiz[x]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u8282\u70b9\u4e2a\u6570\uff1b\n\ntop[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u7684\u6240\u5728\u94fe\u7684\u9876\u7aef\u8282\u70b9\uff1b\n\nson[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u91cd\u513f\u5b50\uff1b\n\ndep[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u7684\u6df1\u5ea6\uff1b\n\nfa[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u7684\u7236\u4eb2\uff1b\n\ntid[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9\u5256\u5206\u540e\u7684\u65b0\u7f16\u53f7\uff1b\n\npos[ ]\u6570\u7ec4\uff0c\u7528\u6765\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\uff1b\n\n3.\u5148\u662f\u4e24\u4e2adfs\uff0c\u5206\u522b\u6c42\u51fafa\u3001dep\u3001siz\u3001son\u548ctop\u3001pos\u3001tid\uff1b\n\n4.\u7ebf\u6bb5\u6811\u64cd\u4f5c\uff1b\n\n###\u4e8c.\u6b64\u9898\u601d\u8def\uff1a\n\n1.\u6b64\u9898\u662f\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u6c42\u503c\uff0c\u6240\u4ee5\u7ebf\u6bb5\u6811\u64cd\u4f5c\u8f83\u4e3a\u7b80\u5355\uff1b\n\n2.\u53ea\u662f\u67e5\u627esum\u548cmax\u65f6\u9700\u5404\u5199\u4e00\u4e2a\u51fd\u6570\uff0c\u4e24\u51fd\u6570\u5dee\u5f02\u4e0d\u5927\uff1b\n\n###\u4e09.\u4e0a\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<iostream> \n#define ls id<<1\n#define rs id<<1|1\nusing namespace std;\nconst int N=100010;\nint pos[N],deep[N],tid[N],son[N],top[N],size[N],fa[N];\nint k=0,head[N],tim=0;\nlong long begi[N];\nstruct node{int to,next;}edge[N*4];\nstruct tree\n{\n    int left,right,maxn;\n    long long sum;\n}tree[N*4];\nvoid add(int u,int v){edge[++k].next=head[u];edge[k].to=v;head[u]=k;}\nvoid dfsfir(int u,int father,int dep)\n{\n    fa[u]=father;deep[u]=dep;size[u]=1;\n    for(int i=head[u];i;i=edge[i].next)\n    {\n        int v=edge[i].to;\n        if(v!=father)\n        {\n            dfsfir(v,u,dep+1);\n            size[u]+=size[v];\n            if(son[u]==0||size[v]>size[son[u]])son[u]=v;\n        }\n    }\n}\nvoid dfsec(int u,int tp)\n{\n    top[u]=tp;\n    tid[u]=++tim;\n    pos[tid[u]]=u;\n    if(son[u]==0)return;\n    dfsec(son[u],tp);\n    for(int i=head[u];i;i=edge[i].next)\n    {\n        int v=edge[i].to;\n        if(v!=fa[u]&&v!=son[u])dfsec(v,v);\n    }\n}\nvoid built(int id,int l,int r)\n{\n    tree[id].left=l;tree[id].right=r;\n    if(l==r)\n    {\n        tree[id].maxn=tree[id].sum=begi[pos[l]];\n        return;\n    }\n    int mid=(l+r)>>1;\n    built(ls,l,mid);built(rs,mid+1,r);\n    tree[id].sum=(tree[ls].sum+tree[rs].sum);\n    tree[id].maxn=max(tree[ls].maxn,tree[rs].maxn);\n}\nvoid update(int id,int l,int r,int w)//\u4fee\u6539\n{\n    if(tree[id].left>r||tree[id].right<l)return;\n    if(tree[id].left==tree[id].right)\n    {\n        tree[id].sum=w;\n        tree[id].maxn=w;\n        return;\n    }\n    update(ls,l,r,w);\n    update(rs,l,r,w);\n    tree[id].sum=(tree[ls].sum+tree[rs].sum);\n    tree[id].maxn=max(tree[ls].maxn,tree[rs].maxn);\n}\nlong long getsum(int id,int l,int r)\n{\n    if(tree[id].left>r || tree[id].right<l)return 0;\n    if(tree[id].left>=l && tree[id].right<=r)return tree[id].sum;\n    return (getsum(id*2,l,r)+getsum(id*2+1,l,r));\n}\nlong long getmax(int id,int l,int r)\n{\n    int ans=-1e9;\n    if(tree[id].left>r || tree[id].right<l)return -1e9;\n    if(tree[id].left>=l && tree[id].right<=r)return max(ans,tree[id].maxn);\n    return max(getmax(id*2,l,r),getmax(id*2+1,l,r));\n}\nlong long find(int x,int y)\n{\n    long long sum=0;\n    int fx,fy;\n    fx=top[x];fy=top[y];\n    while(fx!=fy)//\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u5373\u975e\u8fde\u7eed\u4e00\u6bb5\u533a\u95f4 \n    {\n        if(deep[fx]<deep[fy])\n        {\n            swap(fx,fy);swap(x,y);\n        }\n        sum=(sum+getsum(1,tid[fx],tid[x]));\n        x=fa[fx];fx=top[x];\n    }\n    if(deep[x]>deep[y]) swap(x,y);//\u540c\u4e00\u6761\u91cd\u94fe \n    return sum=(sum+getsum(1,tid[x],tid[y]));\n}\nlong long findmax(int x,int y)\n{\n    int fx,fy;\n    long long ans=-1e9;\n    fx=top[x];fy=top[y];\n    while(fx!=fy)//\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u5373\u975e\u8fde\u7eed\u4e00\u6bb5\u533a\u95f4 \n    {\n        if(deep[fx]<deep[fy])\n        {\n            swap(fx,fy);swap(x,y);\n        }\n        ans=max(ans,getmax(1,tid[fx],tid[x]));\n        x=fa[fx];fx=top[x];\n    }\n    if(deep[x]>deep[y]) swap(x,y);//\u540c\u4e00\u6761\u91cd\u94fe\n    return max(ans,getmax(1,tid[x],tid[y]));\n}\nint main()\n{\n    int n,m,r;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n-1;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v);add(v,u);\n    }\n    for(int i=1;i<=n;i++)scanf(\"%lld\",&begi[i]);\n    scanf(\"%d\",&m);\n    dfsfir(1,0,1);\n    dfsec(1,1);\n    built(1,1,tim);\n    int x,y,z;\n    string mode;\n    for(int i=1;i<=m;i++)\n    {\n        cin>>mode;\n        if(mode==\"QSUM\")\n        {\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%lld\\n\",find(x,y));\n        }\n        else if(mode==\"CHANGE\")\n        {\n            scanf(\"%d%d\",&x,&z);\n            update(1,tid[x],tid[x],z);\n        }\n        else if(mode==\"QMAX\")\n        {\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%lld\\n\",findmax(x,y));\n        }\n    }\n    return 0;\n}\n\u5199\u7684\u4e0d\u597d\uff0cdalao\u52ff\u55b7\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01QAQ\n```",
        "postTime": 1503578046,
        "uid": 25709,
        "name": "SNiFe",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u4ec0\u4e48\uff0c\u8fd9\u9898\u5df2\u7ecf\u6709ZKW\u5199\u7684\u4e86\uff1f\n\n\u7136\u9e45\u90a3\u5e76\u6ca1\u6709\u7528ZKW\u5199\u533a\u95f4\u6700\u503c\u554a\uff0c\u6240\u4ee5\u8fd9\u624d\u662fZKW\u5b8c\u5168\u4f53\u3002\n\n\u5176\u4ed6\u7684\u64cd\u4f5c\u5c31\u662f\u4e00\u4e2a\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\uff0c\u533a\u95f4\u548c\u7528ZKW\u5199\u5f88\u7b80\u5355\n\n\u533a\u95f4\u6700\u503c\u7684\u64cd\u4f5c\u5927\u6982\u5c31\u662f\u7528\u5dee\u5206\u4e86\uff1a\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<bits/stdc++.h>\n#define ri register int\n#define Max(a,b) (a)>(b)?(a):(b)\nconst int maxn=30005;\nusing namespace std;\ntemplate<typename TP>inline void read(TP&x)\n{\n    x=0;int f=1;char c=getchar();\n    while(c>'9'||c<'0'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0'&&c<='9'){x=(x<<1)+(x<<3)+(c^48);c=getchar();}\n    x*=f;\n}\ntemplate<typename TP>inline void print(TP x)\n{\n    if(x<0)x=-x,putchar('-');\n    if(x>=10)print(x/10);\n    putchar(x%10+'0');\n}\nstruct Map {\n\tint to,nxt;\n}e[maxn<<1];\nint head[maxn],tot,weight[maxn];\nint size[maxn],son_h[maxn],dep[maxn],fath[maxn];\nint newid[maxn],top[maxn],cnt,rank[maxn];\nint n,a,b;\nint q;\nchar type[10];\nclass Segment_tree {\n\t\n\tprotected:\n\t\tint leaf;\n\t\tint tree_sum[maxn<<2],tree_max[maxn<<2];\n\tpublic:\n\t\tinline void build()\n\t\t{\n\t\t\tleaf=1;\n\t\t\tfor(;leaf<=n+1;leaf<<=1);\n\t\t\tfor(ri i=leaf+1;i<=leaf+n;++i)\n\t\t\t\ttree_sum[i]=tree_max[i]=weight[rank[i-leaf]];\n\t\t\tfor(ri i=leaf-1;i;--i)\n\t\t\t\ttree_sum[i]=tree_sum[i<<1]+tree_sum[i<<1|1],\n\t\t\t\ttree_max[i]=Max(tree_max[i<<1],tree_max[i<<1|1]),\n\t\t\t\ttree_max[i<<1]-=tree_max[i],tree_max[i<<1|1]-=tree_max[i];\n\t\t\treturn;\n\t\t}\n\t\tinline int query_max(int L,int R)\n\t\t{\n\t\t\tint lans=-0x7f7f7f7f,rans=-0x7f7f7f7f,ans;\n\t\t\tfor(L+=leaf-1,R+=leaf+1;L^R^1;L>>=1,R>>=1)\n\t\t\t{\n\t\t        lans+=tree_max[L],rans+=tree_max[R];\n\t\t\t\tif(~L&1)lans=Max(tree_max[L^1],lans);\n\t\t        if( R&1)rans=Max(tree_max[R^1],rans);\n\t\t    }\n\t\t    lans+=tree_max[L],rans+=tree_max[R];\n\t\t    ans=Max(lans,rans);\n\t\t    for(L>>=1;L;L>>=1)ans+=tree_max[L];\n\t\t\treturn ans;\n\t\t}\n\t\tinline void update(int pos,int val)\n\t\t{\n\t\t\tpos+=leaf;\n\t\t\ttree_sum[pos]=val;\n\t\t\tint tp=query_max(pos-leaf,pos-leaf);\n\t\t\ttree_max[pos]+=val-tp;\n\t\t\twhile(pos>1)\n\t\t\t{\n\t\t\t\tpos>>=1;\n\t\t\t\ttree_sum[pos]=tree_sum[pos<<1]+tree_sum[pos<<1|1];\n\t\t\t\tint temp=Max(tree_max[pos<<1],tree_max[pos<<1|1]);\n\t\t\t\ttree_max[pos]+=temp,tree_max[pos<<1]-=temp,tree_max[pos<<1|1]-=temp;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tinline int query_sum(int L,int R)\n\t\t{\n\t\t\tint ret=0;\n\t\t\tfor(L+=leaf-1,R+=leaf+1;L^R^1;L>>=1,R>>=1)\n\t\t\t{\n\t\t        if(~L&1)ret+=tree_sum[L^1];\n\t\t        if( R&1)ret+=tree_sum[R^1];\n\t\t    }\n\t\t\treturn ret;\n\t\t}\n}tree;\nclass Heavy_light_Decomposition {\n\t\n\tpublic:\n\t\tinline void add(int from,int to)\n\t\t{\n\t\t\te[++tot].to=to;\n\t\t\te[tot].nxt=head[from];\n\t\t\thead[from]=tot;\n\t\t}\n\t\tinline void dfs1(int x,int fa,int deep)\n\t\t{\n\t\t\tdep[x]=deep;\n\t\t\tfath[x]=fa;\n\t\t\tsize[x]=1;\n\t\t\tfor(ri i=head[x];i;i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint to=e[i].to;\n\t\t\t\tif(to!=fa)\n\t\t\t\t{\n\t\t\t\t\tdfs1(to,x,deep+1);\n\t\t\t\t\tsize[x]+=size[to];\n\t\t\t\t\tif(son_h[x]==0||size[to]>size[son_h[x]])son_h[x]=to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinline void dfs2(int x,int rt)\n\t\t{\n\t\t\ttop[x]=rt;\n\t\t\tnewid[x]=++cnt;\n\t\t\trank[cnt]=x;\n\t\t\tif(!son_h[x])return;\n\t\t\tdfs2(son_h[x],rt);\n\t\t\tfor(ri i=head[x];i;i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint to=e[i].to;\n\t\t\t\tif(to!=son_h[x]&&to!=fath[x])dfs2(to,to);\n\t\t\t}\n\t\t}\n\t\tinline int query_s(int from,int to)\n\t\t{\n\t\t\tint ans=0;\n\t\t\twhile(top[from]!=top[to])\n\t\t\t{\n\t\t\t\tif(dep[top[from]]<dep[top[to]])swap(from,to);\n\t\t\t\tans+=tree.query_sum(newid[top[from]],newid[from]);\n\t\t\t\tfrom=fath[top[from]];\n\t\t\t}\n\t\t\tif(dep[from]>dep[to])swap(from,to);\n\t\t\tans+=tree.query_sum(newid[from],newid[to]);\n\t\t\treturn ans;\n\t\t}\n\t\tinline int query_m(int from,int to)\n\t\t{\n\t\t\tint ans=-0x7f7f7f7f;\n\t\t\twhile(top[from]!=top[to])\n\t\t\t{\n\t\t\t\tif(dep[top[from]]<dep[top[to]])swap(from,to);\n\t\t\t\tint temp=tree.query_max(newid[top[from]],newid[from]);\n\t\t\t\tans=Max(ans,temp);\n\t\t\t\tfrom=fath[top[from]];\n\t\t\t}\n\t\t\tif(dep[from]>dep[to])swap(from,to);\n\t\t\tint temp=tree.query_max(newid[from],newid[to]);\n\t\t\tans=Max(ans,temp);\n\t\t\treturn ans;\n\t\t}\n}poufen;\nint main()\n{\n\tread(n);\n\tfor(ri i=1;i<n;++i)\n\t{\n\t\tread(a),read(b);\n\t\tpoufen.add(a,b),poufen.add(b,a);\n\t}\n\tfor(ri i=1;i<=n;++i)read(weight[i]);\n\tpoufen.dfs1(1,0,1),poufen.dfs2(1,1),tree.build();\n\tread(q);\n\tfor(ri i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%s\",type),read(a),read(b);\n\t\tif(type[1]=='M')print(poufen.query_m(a,b)),putchar('\\n');\n\t\telse if(type[1]=='S')print(poufen.query_s(a,b)),putchar('\\n');\n\t\telse tree.update(newid[a],b);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1550981671,
        "uid": 118265,
        "name": "superMB",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u849f\u84bb\u767b\u573a\n\n\u6811\u5256\u6a21\u677f\u9898\uff08https://www.luogu.org/problemnew/show/P3384\uff09\uff08\u5efa\u8bae\u5148\u5b66\u597d\u6811\u5256\u518d\u6765\u5199\u6b64\u9898\u4f1a\u8212\u670d\u5f88\u591a\uff09\n\n\u672c\u849f\u84bb\u6700\u8fd1\u521a\u597d\u5b66\u4e86zkw\u7ebf\u6bb5\u6811\uff0c\u5c31\u62ff\u6b64\u9898\u6765\u7ec3\u624b\u3002\n\n\u672c\u9898\u6700\u76f4\u63a5\u7684\u60f3\u6cd5\uff0c\u5efa\u4e24\u9897\u7ebf\u6bb5\u6811\uff0c\u4e00\u68f5\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\uff0c\n\u4e00\u68f5\u7ef4\u62a4\u533a\u95f4\u548c\u3002\n\n\u6211\u7528zkw\uff08\u91cd\u53e3\u5473\uff09\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c\uff0c\u7528\u666e\u901a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u3002\uff08\u4f46\u5176\u5b9e\u53ef\u4ee5\u53ea\u5efa\u4e00\u68f5\u666e\u901a\u7ebf\u6bb5\u6811\uff08\u4e00\u4e2a\u6570\u7ec4\u7ef4\u62a4\u533a\u95f4\u548c\uff0c\u53e6\u4e00\u4e2a\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\uff09\uff09\n\n\n```cpp\n#include<bits/stdc++.h>\n#define ls rt<<1\n#define rs rt<<1|1\nusing namespace std;\ninline int read()\n{\n    int f=1,num=0;\n    char ch=getchar();\n    while(0==isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n    while(0!=isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();\n    return num*f;\n}//\u5feb\u8bfb\nconst int N=30010;\nconst int inf=0x3f3f3f3f;\nint tot,head[N],next[N<<1],to[N<<1];\nint size[N],son[N],dep[N],fa[N],top[N],now[N],past[N];\nint a[N];\nchar s[100];\nint n,m,root,p;\ninline void Add(int x,int y)\n{\n    next[++tot]=head[x],head[x]=tot,to[tot]=y;\n}//\u90bb\u63a5\u8868\nvoid dfs_getson(int x)\n{\n    size[x]=1;\n    for(register int i=head[x];i;i=next[i])\n    {\n        int y=to[i];\n        if(y==fa[x])continue;\n        fa[y]=x;dep[y]=dep[x]+1;\n        dfs_getson(y);\n        size[x]+=size[y];\n        if(size[y]>size[son[x]])son[x]=y;\n    }\n}\nvoid dfs_rewrite(int x,int tp)\n{\n    top[x]=tp;\n    now[x]=++tot;\n    past[tot]=x;\n    if(son[x])dfs_rewrite(son[x],tp);\n    for(register int i=head[x];i;i=next[i])\n    {\n        int y=to[i];\n        if(y!=son[x]&&y!=fa[x])dfs_rewrite(y,y);\n    }\n}//\u6807\u51c6\u6811\u5256\n\n\u4ee5\u4e0b\u4e3a\u5c01\u88c5\u5728\u7ed3\u6784\u4f53\u7684ZKW\u4e3b\u4f53\u51fd\u6570\uff08\u65b9\u4fbf\u4f7f\u7528\uff09\nstruct ZKW{\n\tlong long tr[N*8]={0};//\u8bb0\u5f97\u5f00long long\n\tlong long add[N*8];\n\tint M=1;\n    inline void buildtree()\n    {\n    \twhile(M<(n+2))M<<=1;\n    \tfor(register int i=M+1;i<=M+n;i++)\n    \t{\n    \ttr[i]=a[past[i-M]];\n    \tint x=i;\n    \twhile(x>>=1)tr[x]=tr[x<<1]+tr[x<<1|1];\n    \t}\n    }//\u5efa\u6811\n    \n    inline void change(int p, int v)\n    {\n        p += M;\n        tr[p] = v;\n        while(p > 1){\n            p >>= 1;\n            tr[p] = tr[p<<1]+tr[p<<1|1];\n        }\n    }//\u5355\u70b9\u4fee\u6539\n    \n    inline long long getsum(int l,int r)\n    {\n        l+=M-1;r+=M+1;\n        long long ans=0;\n        int L=0,R=0;\n        for(register int i=1;l^r^1;i<<=1,l>>=1,r>>=1)\n        {\n            ans+=add[l]*L+add[r]*R;\n            if(~l&1)ans+=tr[l^1],L+=i;\n            if(r&1) ans+=tr[r^1],R+=i;\n        }\n        ans+=add[l]*L+add[r]*R;\n        while(l>>=1)ans+=add[l]*(L+R);\n        return ans;\n    }//\u6c42\u533a\u95f4\u548c\n    \n   \tinline void getsum_xtoy(int x,int y)\n    {\n        long long ans=0;\n        while(top[x]!=top[y])\n        {\n        \tif(dep[top[x]]>dep[top[y]])swap(x,y);\n        \tans=(ans+getsum(now[top[y]],now[y]));\n        \ty=fa[top[y]];\n        }\n        if(dep[x]>dep[y])swap(x,y);\n        (ans+=getsum(now[x],now[y]));\n        printf(\"%lld\\n\",ans);\n    }//\u6c42\u6700\u77ed\u8def\u5f84\u548c\n    \n}zkw;\n\u4ee5\u4e0b\u4e3a\u5c01\u88c5\u5728\u7ed3\u6784\u4f53\u7684\u666e\u901a\u7ebf\u6bb5\u6811\u4e3b\u4f53\u51fd\u6570\uff08\u65b9\u4fbf\u4f7f\u7528\uff09\nstruct node{\n\tint tree[N*4];\n    inline void pushup(int rt)\n    {\n        tree[rt]=max(tree[ls],tree[rs]);\n    }\n    \n    inline void build(int rt,int l,int r)\n    {\n        if(l==r)\n        {\n            tree[rt]=a[past[l]];\n            return;\n        }\n        int mid=(l+r)>>1;\n        build(ls,l,mid);\n        build(rs,mid+1,r);\n        pushup(rt);\n    }\n    \n    void update(int k,int l,int r,int rt,int val)\n    {\n        if(l==k&&r==k)\n        {\n            tree[rt]=val;\n            return;\n        }\n        int mid=(l+r)>>1;\n        if(k<=mid)update(k,l,mid,ls,val);\n        if(k>mid)update(k,mid+1,r,rs,val);\n        pushup(rt);\n    }\n    \n    int query(int L,int R,int l,int r,int rt)\n    {\n        if(L<=l&&r<=R)\n        {\n            return tree[rt];\n        }\n        int mid=(l+r)>>1;\n        int ans=-inf;\n        if(L<=mid)ans=max(ans,query(L,R,l,mid,ls));\n        if(R>mid)ans=max(ans,query(L,R,mid+1,r,rs));\n        pushup(rt);\n        return ans;\n    }\n    \n    inline void solve(int x,int y)\n    {\n    \tint ans=-inf;\n    \twhile(top[x]!=top[y])\n\t    {\n\t    \tif(dep[top[x]]>dep[top[y]])swap(x,y);\n\t    \tans=max(ans,query(now[top[y]],now[y],1,tot,1));\n\t    \ty=fa[top[y]];\n\t    }\n\t    if(dep[x]>dep[y])swap(x,y);\n\t    ans=max(ans,query(now[x],now[y],1,tot,1));\n\t    printf(\"%d\\n\",ans);\n\t}\n}normal;\n\nint main()\n{\n    n=read();\n    for(register int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        Add(x,y);Add(y,x);\n    }\n    for(register int i=1;i<=n;i++)\n    {\n        a[i]=read();\n    }\n    tot=0;root=1;\n    dfs_getson(root);\n    dfs_rewrite(root,root);\n    zkw.buildtree();\n    normal.build(1,1,tot);\n    m=read();\n    for(register int i=1;i<=m;i++)\n    {\n        cin>>s+1;int x,y;\n        x=read();y=read();\n        if(s[1]=='C')\n        {\n            zkw.change(now[x],y);\n            normal.update(now[x],1,tot,1,y);\n        }\n        if(s[1]=='Q'&&s[2]=='M')\n        {\n            normal.solve(x,y);\n        }\n        if(s[1]=='Q'&&s[2]=='S')\n        {\n            zkw.getsum_xtoy(x,y);\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1545832312,
        "uid": 110031,
        "name": "z1431346079",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "   **\u5f3a\u70c8\u63a8\u8350**\u521a\u5b66**\u6811\u94fe\u5256\u5206**\u7684\u7ae5\u978b\u6765\u505a\u4e0b\u8fd9\u9053\u9898\uff0c\u672c\u849f\u84bb\u5199\u4e86\u56db\u6b21\u624dAC\u8fd9\u9053\u9898(~~\u8c01\u8ba9\u6211\u592a\u5f31\u4e86~~)\uff0c\u53d1\u4e0b\u9898\u89e3\u5de9\u56fa\u4e00\u4e0b\u3002(\u91cd\u65b0\u53d1\u4e00\u4e0b\uff0c\u539f\u6765\u7684\u6392\u7248\u6709\u95ee\u9898)\n   \n\n------------\n\n### \u7b80\u7565\u8bf4\u4e0b\u6811\u94fe\u5256\u5206\n\u6811\u5256\u53ef\u4ee5\u5c06\u4e00\u68f5\u6811\u8f6c\u5316\u4e3a\u6709\u5e8f\u7684\u4e00\u6bb5\uff0c\u540c\u65f6\u65b9\u4fbf\u4e86\u6211\u4eec\u8fdb\u884c\u7edf\u8ba1\u548c\u4fee\u6539\uff0c\u540c\u65f6\u5b83\u4e5f\u662f\u5341\u5206\u9ad8\u6548\u7684\uff0c\u5728\u7ebf\u6bb5\u6811\u7684\u7ef4\u62a4\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u6700\u574fO(log\u00b2n)\u7684\u590d\u6742\u5ea6\u8fdb\u884c\u64cd\u4f5c\uff0c~~\u5f53\u7136\u7801\u91cf\u662f\u5341\u5206\u5de8\u5927\u7684~~  \n    \u8fd9\u91cc\u6211\u63a8\u8350\u4e00\u7bc7\u5f88\u68d2\u7684[\u535a\u5ba2](http://www.cnblogs.com/chinhhh/p/7965433.html)\uff0c\u6211\u7684\u6811\u5256\u5c31\u662f\u5728\u90a3\u91cc\u5b66\u4f1a\u7684\u3002    \n    \n\n------------\n\n### \u9884\u5904\u7406\n \u5206\u4e3a\u4e24\u6b65dfs     \n####  \u7b2c\u4e00\u6b65\n ```cpp\nvoid dfs1( int p ){\n\tdp[ p ] = dp[ fa[ p ] ] + 1;\n\tsize[ p ] = 1;\n\tfor( register int i = head[ p ] ; i ; i = e[ i ].next ){\n\t\tint v = e[ i ].to;\n\t\tif( v == fa[ p ] )\n\t\t  continue;\n\t\tfa[ v ] = p;\n\t\tdfs1( v );\n\t\tsize[ p ] += size[ v ];\n\t\tif( size[ v ] > size[ son[ p ] ] || !son[ p ] )\n\t\t  son[ p ] = v;//\u8bb0\u5f97\u8981\u7279\u5224\u7b2c\u4e00\u4e2a\u513f\u5b50\n\t} \n} \n```   \n\u627e\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\uff0c\u7236\u4eb2\uff0csize(\u5373\u4ee5\u5b83\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f),\u91cd\u513f\u5b50(\u4e00\u4e2a\u8282\u70b9\u7684\u6240\u6709\u513f\u5b50\u4e2dsize\u6700\u5927\u7684\u90a3\u4e2a\u8282\u70b9\uff0c\u6700\u591a\u6709\u4e00\u4e2a)\n#### \u7b2c\u4e8c\u6b65\n```cpp   \nvoid dfs2( int p , int tp ){\n\ttop[ p ] = tp;\n\tid[ p ] = ++tot;\n\tnw[ tot ] = w[ p ];\n\tif( son[ p ] )\n\t  dfs2( son[ p ] , tp );//\u4f18\u5148\u904d\u5386\u91cd\u513f\u5b50\n\tfor( register int i = head[ p ] ; i ; i = e[ i ].next ){\n\t\tint v = e[ i ].to;\n\t\tif( v == fa[ p ] || v == son[ p ] )\n\t\t  continue;\n\t\tdfs2( v , v );//\u4ee5\u8f7b\u513f\u5b50\u5f00\u59cb\u7684\u65b0\u94fe\n\t}\n}\n```   \n\u627e\u51fa\u6bcf\u4e2a\u8282\u70b9\u5728dfs\u5e8f\u91cc\u7684\u4f4d\u7f6e\uff0c\u5373id[ p ],dfs\u5e8f\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u6743\u503c\uff0c\u5373nw[ tot ],\u6bcf\u4e2a\u8282\u70b9\u7684top,\u5373\u4f9d\u9760\u201c\u91cd\u94fe\u201d\u53ef\u4ee5\u201c\u722c\u5347\u201d\u5230\u7684\u6df1\u5ea6\u6700\u6d45\u7684\u70b9\n\n\n------------\n\n### \u5982\u4f55\u7ef4\u62a4   \n\u5b8c\u6210\u4e0a\u8ff0\u64cd\u4f5c\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4e00\u68f5\u590d\u6742\u7684\u6811\u7684\u4fe1\u606f\u5df2\u7ecf\u88ab\u4fdd\u5b58\u5728\u4e86\u4e00\u4e2a\u76f8\u5bf9\u66f4\u6709\u89c4\u5f8b\u7684\u5e8f\u5217\u91cc\uff0c\u6211\u4eec\u5c31\u8981\u9760\u5b83\u6765\u5b8c\u6210\u6240\u6709\u7684\u590d\u6742\u64cd\u4f5c\u3002\n\u5b83\u6709\u4ee5\u4e0b\u4f18\u79c0\u6027\u8d28\uff1a   \n1.\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u5728dfs\u5e8f\u4e2d\u4e00\u5b9a\u662f\u8fde\u7eed\u7684\uff1b    \n2.\u5b50\u6811\u7684dfs\u5e8f\u4e5f\u662f\u8fde\u7eed\u7684\uff1b   \n\u8fd9\u6b63\u597d\u7b26\u5408\u7ebf\u6bb5\u6811\u7684\u53e3\u5473\u3002\n```cpp\nstruct NODE{\n\tll sum,maxn;\n\tNODE *ls,*rs;\n\tinline void update(){\n\t\tsum = ls->sum + rs->sum;\n\t\tmaxn = max( ls->maxn , rs->maxn );\n\t}\n\tNODE(){\n\t\tsum = maxn = 0;\n\t\tls = rs = NULL;\n\t}\n}*root,tree[ N * 4 ],*p = tree;\n//\u8fd9\u91cc\u6211\u7528\u7684\u662f\u6307\u9488\u5efa\u6811\nNODE *build( int l , int r ){\n\tNODE *nd = ++p;\n\tif( l == r ){\n\t\tnd->sum = nd->maxn = nw[ l ];//\u8bb0\u5f97\u662fnw[],\u4e0d\u8981\u6253\u6210\u4e86w[]\n\t\treturn nd;\n\t}\n\tint mid = ( l + r ) >> 1;\n\tnd->ls = build( l , mid );\n\tnd->rs = build( mid + 1 , r );\n\tnd->update();\n\treturn nd;\n}\n```\n\n\n\u5176\u4ed6\u64cd\u4f5c\u5c31\u662f\u6a21\u677f\u4e86\uff0c\u4e0d\u518d\u8fc7\u591a\u53d9\u8ff0\n\n\n------------\n\n### \u6838\u5fc3\u64cd\u4f5c    \n\u4e0b\u9762\u662f\u6811\u5256\u7684\u6838\u5fc3\u64cd\u4f5c\n\u65e0\u8bba\u662f\u94fe\u67e5\u8be2\u8fd8\u662f\u4fee\u6539\uff0c\u90fd\u8981\u7d27\u7d27\u56f4\u7ed5\u4e0b\u9762\u64cd\u4f5c\n```cpp\nvoid unknown( int x , int y ){//\u7701\u7565\u53f7\u5904\u662f\u67d0\u4e9b\u64cd\u4f5c\n\t......\n\twhile( top[ x ] != top[ y ] ){\n\t\tif( dp[ top[ x ] ] < dp[ top[ y ] ] )\n\t\t  swap( x , y );\n\t\t......\n\t\tx = fa[ top[ x ] ];\n\t}//\u4e0d\u65ad\u7684\u5c06top\u66f4\u6df1\u7684\u70b9\u5f80\u4e0a\u722c\u5347\uff0c\u76f4\u5230\u4e24\u70b9\u7684top\u76f8\u540c\n\tif( dp[ x ] > dp[ y ] )\n\t  swap( x , y );//\u8fd9\u91ccx,y\u7684top\u5df2\u76f8\u540c\n\t......\n} \n```\n\u81f3\u4e8e\u5b50\u6811\u7684\u64cd\u4f5c\u5c31\u5f88\u7b80\u5355\u4e86\uff0c\u4e0d\u61c2\u5f97\u53ef\u4ee5\u53c2\u8003\u6211\u63a8\u8350\u7684\u535a\u5ba2    \n\n------------\n\n\u8bb2\u89e3\u5c31\u5230\u8fd9\u91cc\u4e86~~\u6709\u70b9\u6c34~~\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff08\u672c\u4eba\u7801\u98ce\u6e05\u5947\uff0c\u4e0d\u4e60\u60ef\u7684dalao\u53ef\u4ee5\u8df3\u8fc7\uff09   \n\u867d\u7136\u6211\u7684\u65b9\u6cd5\u53ef\u80fd\u5f88\u5f31\uff0c\u4f46\u5e0c\u671b\u80fd\u7ed9\u9700\u8981\u7684\u4eba\u4e00\u70b9\u5e2e\u52a9\u628a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define N 200000\n#define oo 2147483647000\n#define BASE 2\nint n,m,tot = 0,head[ N ],dp[ N ],size[ N ],fa[ N ],son[ N ],w[ N ],nw[ N ],id[ N ],top[ N ];\n//----------------------------------------------------------------\ntemplate<class T>\ninline void read(T &res)\n{\n\tstatic char ch;\n    T flag = 1;\n\twhile( ( ch = getchar() ) < '0' || ch > '9' )\n      if( ch == '-' )\n        flag = -1;\n    res = ch - 48;\n\twhile( ( ch = getchar() ) >= '0' && ch <= '9' )\n      res = res * 10 + ch - 48;\n    res *= flag;\n}\n\nll max( ll a , ll b ){\n\treturn a > b ? a : b;\n}\n//\u5efa\u56fe\u90e8\u5206----------------------------------------------------------------\nstruct E{\n\tint to,next;\n}e[ N * 4 ];\n\ninline void add( int from , int to ){\n\te[ ++tot ].to = to;\n\te[ tot ].next = head[ from ];\n\thead[ from ] = tot;\n}\n//\u7ebf\u6bb5\u6811----------------------------------------------------------------\nstruct NODE{\n\tll sum,maxn;\n\tNODE *ls,*rs;\n\tinline void update(){\n\t\tsum = ls->sum + rs->sum;\n\t\tmaxn = max( ls->maxn , rs->maxn );\n\t}\n\tNODE(){\n\t\tsum = maxn = 0;\n\t\tls = rs = NULL;\n\t}\n}*root,tree[ N * 4 ],*p = tree;\n\nNODE *build( int l , int r ){\n\tNODE *nd = ++p;\n\tif( l == r ){\n\t\tnd->sum = nd->maxn = nw[ l ];\n\t\treturn nd;\n\t}\n\tint mid = ( l + r ) >> 1;\n\tnd->ls = build( l , mid );\n\tnd->rs = build( mid + 1 , r );\n\tnd->update();\n\treturn nd;\n}\n\nll sum( NODE *nd , int l , int r , int ql , int qr ){\n\tif( ql <= l && r <= qr ){\n\t\treturn nd->sum;\n\t}\n\tint mid = ( l + r ) >> 1;\n\tll res = 0;\n\tif( ql <= mid )\n\t  res += sum( nd->ls , l , mid , ql , qr );\n\tif( qr > mid )\n\t  res += sum( nd->rs , mid + 1 , r , ql , qr );\n\treturn res;\n}//\u533a\u95f4\u6c42\u548c\n\nll amax( NODE *nd , int l , int r , int ql , int qr ){\n\tif( ql <= l && r <= qr ){\n\t\treturn nd->maxn;\n\t}\n\tint mid = ( l + r ) >> 1;\n\tll res = -oo;\n\tif( ql <= mid )\n\t  res = max( amax( nd->ls , l , mid , ql , qr ) , res );\n\tif( qr > mid )\n\t  res = max( res , amax( nd->rs , mid + 1 , r , ql , qr ) );\n\treturn res;\n}//\u533a\u95f4\u6c42\u6700\u5927\u503c\n\nvoid change( NODE *nd , int l , int r , int x , int add ){\n\tif( l <= x && x <= r ){\n\t\tif( l == r ){\n\t\t    nd->sum += add;\n\t\t    nd->maxn += add;\n\t\t    return;\n\t\t}\n\t\tint mid = ( l + r ) >>1;\n\t\tchange( nd->ls , l , mid , x , add );\n\t\tchange( nd->rs , mid + 1 , r , x , add );\n\t\tnd->update();\n\t}\n}//\u5355\u70b9\u4fee\u6539\n\nll ask( NODE *nd , int l , int r , int x ){\n\tif( l == r )\n\t  return nd->sum;\n\tint mid = ( l + r ) >> 1;\n\tif( x <= mid )\n\t  return ask( nd->ls , l , mid , x );\n\telse\n\t  return ask( nd->rs , mid + 1 , r , x );\n}//\u5355\u70b9\u67e5\u8be2\n//----------------------------------------------------------------\nvoid dfs1( int p ){\n\tdp[ p ] = dp[ fa[ p ] ] + 1;\n\tsize[ p ] = 1;\n\tfor( register int i = head[ p ] ; i ; i = e[ i ].next ){\n\t\tint v = e[ i ].to;\n\t\tif( v == fa[ p ] )\n\t\t  continue;\n\t\tfa[ v ] = p;\n\t\tdfs1( v );\n\t\tsize[ p ] += size[ v ];\n\t\tif( size[ v ] > size[ son[ p ] ] || !son[ p ] )\n\t\t  son[ p ] = v;\n\t} \n} \n\nvoid dfs2( int p , int tp ){\n\ttop[ p ] = tp;\n\tid[ p ] = ++tot;\n\tnw[ tot ] = w[ p ];\n\tif( son[ p ] )\n\t  dfs2( son[ p ] , tp );\n\tfor( register int i = head[ p ] ; i ; i = e[ i ].next ){\n\t\tint v = e[ i ].to;\n\t\tif( v == fa[ p ] || v == son[ p ] )\n\t\t  continue;\n\t\tdfs2( v , v );\n\t}\n}\n//----------------------------------------------------------------\nint gat(){\n\tchar c = getchar();\n\twhile( 'A' > c || c > 'Z' )\n\t  c = getchar();\n\tint ret = 0;\n\tret = ret * BASE + c;\n\tc = getchar();\n\twhile( 'A' <= c && c <= 'Z' )\n\t  ret = ret * BASE + c,c = getchar();\n\treturn ret;\n}//\u8bfb\u5165\u64cd\u4f5c\n//----------------------------------------------------------------\nll qmax( int x , int y ){\n\tll res = -oo;\n\twhile( top[ x ] != top[ y ] ){\n\t\tif( dp[ top[ x ] ] < dp[ top[ y ] ] )\n\t\t  swap( x , y );\n\t\tres = max( res , amax( root , 1 , n , id[ top[ x ] ] , id[ x ] ) );\n\t\tx = fa[ top[ x ] ];\n\t}\n\tif( dp[ x ] > dp[ y ] )\n\t  swap( x , y );\n\tres = max( res , amax( root , 1 , n , id[ x ] , id[ y ] ) );\n\treturn res;\n}//\u94fe\u6700\u5927\u503c\u67e5\u8be2\n\nll qsum( int x , int y ){\n\tll res = 0;\n\twhile( top[ x ] != top[ y ] ){\n\t\tif( dp[ top[ x ] ] < dp[ top[ y ] ] )\n\t\t  swap( x , y );\n\t\tres += sum( root , 1 , n , id[ top[ x ] ] , id[ x ] );\n\t\tx = fa[ top[ x ] ];\n\t}\n\tif( id[ x ] > id[ y ] )\n\t  swap( x , y );\n\tres += sum( root , 1 , n , id[ x ] , id[ y ] );\n\treturn res;\n}//\u94fe\u306e\u548c\u67e5\u8be2\n//----------------------------------------------------------------\nint main()\n{\n\tread( n );\n\tfor( register int i = 1 ; i <= n - 1 ; i++ ){\n\t\tint x,y;\n\t\tread( x ),read( y );\n\t\tadd( x , y );\n\t\tadd( y , x );\n\t}\n\tfor( register int i = 1 ; i <= n ; i++ )\n\t  read( w[ i ] );\n\ttot = 0,dfs1( 1 );\n\ttot = 0,dfs2( 1 , 1 );\n\troot = build( 1 , n );\n\tread( m );\n\tfor( register int i = 1 ; i <= m ; i++ ){\n\t\tint f;\n\t\tf = gat();\n\t\tswitch( f ){\n\t\t\tcase 1174:{//\u6c42\u6700\u5927 \n\t\t\t\tint x,y;\n\t\t\t\tread( x ),read( y );\n\t\t\t\tprintf( \"%lld\\n\" , qmax( x , y ) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1227:{//\u6c42\u548c \n\t\t\t\tint x,y;\n\t\t\t\tread( x ),read( y );\n\t\t\t\tprintf( \"%lld\\n\" , qsum( x , y ) );\n\t\t\t\tbreak;\n\t\t\t} \n\t\t\tcase 4339:{//\u5355\u70b9\u4fee\u6539 \n\t\t\t\tint x,y;\n\t\t\t\tread( x ),read( y );\n                change( root , 1 , n , id[ x ] , y - ask( root , 1 , n , id[ x ] ) );\n                //\u597d\u597d\u54c1\u5473\u8fd9\u4e00\u6b65\uff0c\u5bf9\u4f60\u7684\u6811\u5256\u7684\u7406\u89e3\u7684\u63d0\u5347\u5f88\u6709\u5e2e\u52a9\u54e6\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1545485491,
        "uid": 117655,
        "name": "YZhe",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "### \u3010\u4f8b\u9898\u3011\n![\u4f8b\u9898](https://cdn.luogu.com.cn/upload/pic/29919.png)\n\n### \u3010\u7b97\u6cd5\u76ee\u6807\u3011\n- \u5728$log$\u7ea7\u522b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\uff0c\u901a\u8fc7\u628a\u6811\u5206\u5272\u6210\u4e00\u6761\u6761\u94fe\uff0c\u5e76\u7528\u5404\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u52a0\u901f\u89e3\u51b3\u5404\u79cd\u6811\u4e0a\u533a\u95f4\u95ee\u9898\u3002\n\n### \u3010\u7b97\u6cd5\u8fc7\u7a0b\u3011\n#### \u5b9a\u4e49\n- \u628a\u6bcf\u4e2a\u70b9\u8fde\u51fa\u7684\u4e24\u6761\u8fb9\u5206\u4e3a\u91cd\u8fb9\u548c\u8f7b\u8fb9\uff0c\u91cd\u8fb9\u8fde\u63a5\u5b50\u6811\u70b9\u6570\u8f83\u5927\u7684\u4e00\u8fb9\uff0c\u8f7b\u8fb9\u8fde\u5411\u53e6\u4e00\u8fb9\u3002\n- \u628a\u6bcf\u4e2a\u70b9\u7684\u4e24\u4e2a\u513f\u5b50\u5206\u4e3a\u91cd\u7ed3\u70b9\u548c\u8f7b\u7ed3\u70b9\uff0c\u91cd\u7ed3\u70b9\u7684\u5b50\u6811\u8f83\u5927\uff0c\u8f7b\u7ed3\u70b9\u5b50\u6811\u8f83\u5c0f\u3002\n\n#### \u9884\u5904\u7406\n- \u6c42\u51fa\u5b9a\u4e49\u5185\u7684\u53c2\u6570\uff1b\n- \u6bcf\u4e2a\u7ed3\u70b9\u6700\u9760\u8fd1\u5f53\u524d\u7ed3\u70b9\u7684\u91cd\u7ed3\u70b9top\uff0c\u5176\u4e2d\uff0c\u5bf9\u4e8e\u8f7b\u7ed3\u70b9\uff0ctop\u662f\u81ea\u5df1\u3002\u8fd9\u4e00\u6b65\u9aa4\u6709\u52a9\u4e8e\u8fdb\u884c\u201c\u8de8\u8d8a\u201d\uff0c\u4ee5\u63d0\u9ad8\u901f\u5ea6\u3002\n- **\u6bcf\u4e2a\u7ed3\u70b9\u5728DFS\u5e8f\u4e0b\u7684\u7f16\u53f7**\uff0c\u8fd9\u4e00\u6b65\u9aa4\u662f\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f18\u5316\u7684\u5173\u952e\u3002**\u6ce8\u610f**\uff1a\u8fd9\u91cc\u7684DFS\u5e8f\u5fc5\u987b\u5148\u641c\u5bfb\u91cd\u7ed3\u70b9\u3002\u56e0\u4e3a\u8fd9\u6837\u53ef\u4ee5\u4f7f\u91cd\u7ed3\u70b9\u90fd\u5728\u76f8\u90bb\u7684\u5730\u65b9\uff0c\u4fbf\u4e8e\u540e\u9762\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f18\u5316\u3002\n- \u8fd9\u4e00\u6b65\u9aa4\u53ef\u4ee5\u7528\u4e24\u4e2aDFS\u6765\u5b9e\u73b0\u3002\n\n#### \u4fee\u6539\u4e0e\u67e5\u8be2\n- \u5bf9\u6811\u8fdb\u884c\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u66f4\u65b0\u4e0e\u67e5\u8be2\uff1a\n\t- \u8dd1\u4e00\u6ce2\u7c7b\u4f3c\u4e8eLCA\u7684\u7b97\u6cd5\uff1b\n    - \u5bf9\u4e8e\u91cd\u7ed3\u70b9\uff0c\u628a\u7ebf\u6bb5\u6811\u4e2d\u5b83\u5230top\u7684\u533a\u95f4\u66f4\u65b0\uff1b\n    - \u5bf9\u4e8e\u8f7b\u7ed3\u70b9\uff0c\u4e3a\u4e86\u201c\u4fdd\u6301\u961f\u578b\u201d\uff0c\u5728\u7ebf\u6bb5\u6811\u4e2d\u81ea\u5df1\u7684\u4f4d\u7f6e\u66f4\u65b0\uff1b\n    - \u628ax\u6216y\u8df3\u5230\u5bf9\u5e94\u7684top\u3002\n    - \u76f4\u5230\u8df3\u5230\u76f8\u540c\u7684\u70b9\u3002\n    - \u540c\u7406\uff0c\u5bf9\u4e8e\u67e5\u8be2\u7528\u76f8\u4f3c\u7684\u64cd\u4f5c\u3002\n\n### \u3010\u65f6\u95f4\u590d\u6742\u5ea6\u3011\n- \u7531\u4e8e\u8f7b\u7ed3\u70b9\u7684\u4e2a\u6570\u4f1a\u968f\u7740\u5c42\u6570\u7684\u589e\u52a0\u800c/2\uff0c\u56e0\u6b64\u66b4\u529b\u8f7b\u7ed3\u70b9\u7684\u6b21\u6570\u662flogn\uff1b\u7531\u4e8e\u91cd\u7ed3\u70b9\u6709\u7ebf\u6bb5\u6811\u4f18\u5316\uff0c\u56e0\u6b64\u4e5f\u662flogn\uff1b\u7531\u4e8e\u6811\u7684\u6df1\u5ea6\u5e73\u644a\u8d77\u6765\u4e5f\u662flogn\uff0c\u56e0\u6b64\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f$O(Qlogn)$\u3002\n\n### \u3010\u89e3\u9898\u53cd\u601d\u3011\n- \u5728\u6c42\u6700\u5927\u503c\u7684\u65f6\u5019\uff0c\u8981\u6ce8\u610f\u8d1f\u6570\u7684\u60c5\u51b5\uff0c\u5fc5\u987b\u8fd4\u56de\u65e0\u7a77\u5c0f\u3002\n\n### \u3010\u53c2\u8003\u7a0b\u5e8f\u3011\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define INF 0x3f3f3f3f\nint n,Q,Mod,cnt,rt;\nstruct Tree{\n\tint sum,max;\n}tree[400005];\nstruct EDGE{\n\tint t,next;\n}e[400005];\nint cur,head[400005],\n\td[400005],dep[400005],top[400005],fa[400005],siz[400005],son[400005],\n\tid[400005],D[400005];\n\nvoid Wei_Hu(int x)\n{\n\ttree[x].sum=tree[x*2].sum+tree[x*2+1].sum;\n\ttree[x].max=max(tree[x*2].max,tree[x*2+1].max);\n}\nvoid Build(int now,int l,int r)\n{\n\tif (l==r)\n\t{\n\t\ttree[now].sum=d[l];\n\t\ttree[now].max=d[l];\n\t\treturn;\n\t}\n\tint mid=((l+r)>>1);\n\tBuild(now*2,l,mid);\n\tBuild(now*2+1,mid+1,r);\n\tWei_Hu(now);\n}\nvoid Update(int now,int l,int r,int x,int z)\n{\n\tif (l>x||r<x) return;\n\tif (l==r&&l==x)\n\t{\n\t\ttree[now].max=tree[now].sum=z;\n\t\treturn;\n\t}\n\tint mid=((l+r)>>1);\n\tif (x<=mid)\n\t\tUpdate(now*2,l,mid,x,z);\n\telse\n\t\tUpdate(now*2+1,mid+1,r,x,z);\n\tWei_Hu(now);\n}\nint Query_sum(int now,int l,int r,int s,int t)\n{\n\tif (l>t||r<s) return 0;\n\tif (s<=l&&r<=t)\n\t{\n\t\treturn tree[now].sum;\n\t}\n\tint mid=((l+r)>>1);\n\treturn Query_sum(now*2,l,mid,s,t)+Query_sum(now*2+1,mid+1,r,s,t);\n}\nint Query_max(int now,int l,int r,int s,int t)\n{\n\tif (l>t||r<s) return -INF;\n\tif (s<=l&&r<=t)\n\t{\n\t\treturn tree[now].max;\n\t}\n\tint mid=((l+r)>>1);\n\treturn max(Query_max(now*2,l,mid,s,t),Query_max(now*2+1,mid+1,r,s,t));\n}\n\n\n\nvoid add(int a,int b)\n{\n\tcur++;\n\te[cur].t=b;\n\te[cur].next=head[a];\n\thead[a]=cur;\n}\nvoid DFS1(int u,int f,int d)\n{\n\tdep[u]=d;\n\tfa[u]=f;\n\tsiz[u]=1;\n\tint hson=0;\n\tfor (int h=head[u];h!=-1;h=e[h].next)\n\t{\n\t\tint v=e[h].t;\n\t\tif (v==fa[u]) continue;\n\t\tDFS1(v,u,d+1);\n\t\tsiz[u]+=siz[v];\n\t\tif (siz[v]>hson)\n\t\t{\n\t\t\thson=siz[v];\n\t\t\tson[u]=v;\n\t\t}\n\t}\n}\nvoid DFS2(int u,int Top)\n{\n\tid[u]=++cnt;\n\td[cnt]=D[u];\n\ttop[u]=Top;\n\tif (!son[u])\n\t\treturn;\n\tDFS2(son[u],Top);\n\tfor (int h=head[u];h!=-1;h=e[h].next)\n\t{\n\t\tint v=e[h].t;\n\t\tif (v==fa[u]||v==son[u])\n\t\t\tcontinue;\n\t\tDFS2(v,v); \n\t}\n}\nint Query_Dis_sum(int x,int y)\n{\n\tint ans=0;\n\tfor (;top[x]!=top[y];x=fa[top[x]])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tans+=Query_sum(1,1,n,id[top[x]],id[x]);\n\t}\n\tif (dep[x]>dep[y])\n\t\tswap(x,y);\n\tans+=Query_sum(1,1,n,id[x],id[y]);\n\treturn ans;\n}\nint Query_Dis_max(int x,int y)\n{\n\tint ans=-INF;\n\tfor (;top[x]!=top[y];x=fa[top[x]])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tans=max(ans,Query_max(1,1,n,id[top[x]],id[x]));\n\t}\n\tif (dep[x]>dep[y])\n\t\tswap(x,y);\n\tans=max(ans,Query_max(1,1,n,id[x],id[y]));\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tmemset(head,-1,sizeof head);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&D[i]);\n\tfor (int i=1;i<=4*n;i++)\n\t\ttree[i].max=-INF;\n\trt=1;\n\tDFS1(rt,0,1);\n\tDFS2(rt,rt);\n\tBuild(1,1,n);\n\tscanf(\"%d\",&Q);\n\twhile (Q--)\n\t{\n\t\tint x,y;\n\t\tchar cmd[105];\n\t\tscanf(\"%s%d%d\",cmd,&x,&y);\n\t\tif (cmd[0]=='C')\n\t\t{\n\t\t\tUpdate(1,1,n,id[x],y);\n\t\t}\n\t\telse\n\t\tif (cmd[1]=='S')\n\t\t{\n\t\t\tprintf(\"%d\\n\",Query_Dis_sum(x,y));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",Query_Dis_max(x,y));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1534865239,
        "uid": 12349,
        "name": "FREEH",
        "ccfLevel": 6,
        "title": "\u6811\u94fe\u5256\u5206\u2014\u2014\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u539f\u9898\u4f20\u9001\u95e8[>Here<](https://www.luogu.org/problemnew/show/P2590)\n\n\u6700\u8fd1\u6253\u591a\u4e86LCT\u679c\u7136\u662f\u6709\u597d\u5904\u7684\u3002\n\n\u6b64\u9898\u662fLCT\u88f8\u9898\uff0c\u5957\u7528LCT\u6a21\u677f\u50cf\u6211\u8fd9\u6837\u7684\u849f\u84bb\u82b1\u4e8617\u5206\u949f\u4e5f\u6253\u51fa\u6765\u4e86\u3002\n\n\u8fd9\u9053\u9898\u53ea\u9700\u8981link\u64cd\u4f5c\u548c\u94fe\u6c42\u548c\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6ce8\u610f\u8981\u5148\u8bfb\u5165value\u518d\u5efa\u8fb9\uff01\u8fd8\u6709\u521a\u5f00\u59cbmx\u6570\u7ec4\u9700\u8981\u7f6e\u4e3a\u6781\u5c0f\u503c\uff01\uff01\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstring>\n\nint max(int a,int b){\n    return a>b?a:b;\n}\nint fa[30001],ch[30001][2],val[30001],tot[30001],mx[30001],n,a[30001],b[30001],q;\nbool lazy[30001];\nchar cha[101];\nvoid pushup(int x){\n    tot[x]=tot[ch[x][0]]+tot[ch[x][1]]+val[x];\n    mx[x]=max(max(mx[ch[x][0]],mx[ch[x][1]]),val[x]);\n}\nbool son(int x){return ch[fa[x]][1]==x;}\nbool isroot(int x){return ch[fa[x]][1]!=x&&ch[fa[x]][0]!=x;}\nvoid Rotate(int x){\n    if(isroot(x)||!x||!fa[x])return;\n    int faz=fa[x],fazz=fa[faz],g=son(x);\n    fa[x]=fazz;\n    if(!isroot(faz))ch[fazz][son(faz)]=x;\n    fa[ch[x][!g]]=faz;\n    ch[faz][g]=ch[x][!g];\n    fa[faz]=x;\n    ch[x][!g]=faz;\n    pushup(faz);\n    pushup(x);\n}\nvoid clean(int x){\n    if(!isroot(x))clean(fa[x]);\n    if(!lazy[x])return;\n    int tem=ch[x][0];\n    ch[x][0]=ch[x][1];\n    ch[x][1]=tem;\n    lazy[ch[x][0]]^=1;\n    lazy[ch[x][1]]^=1;\n    lazy[x]=0;\n}\nvoid splay(int x){\n    clean(x);\n    while(!isroot(x)){\n        if(!isroot(fa[x]))\n            if(son(x)^son(fa[x]))Rotate(x);\n            else Rotate(fa[x]);\n        Rotate(x);\n    }\n}\nvoid access(int x){\n    for(int y=0;x;y=x,x=fa[x])\n        splay(x),ch[x][1]=y,pushup(x);\n}\nvoid mroot(int x){\n    access(x);\n    splay(x);\n    lazy[x]^=1;\n}\nvoid link(int x,int y){\n    mroot(x);\n    fa[x]=y;\n}\nvoid split(int x,int y){\n    mroot(x);\n    access(y);\n    splay(y); \n}\nint main(){\n    memset(mx,-0x7f7f7f7f,sizeof mx);\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)scanf(\"%d%d\",a+i,b+i);\n    for(int i=1;i<=n;i++)scanf(\"%d\",val+i);\n    for(int i=1;i<n;i++)link(a[i],b[i]);\n    scanf(\"%d\",&q);\n    for(int i=1;i<=q;i++){\n        scanf(\"%s%d%d\",cha,&a[0],&a[1]);\n        if(cha[0]=='C'){\n            access(a[0]);\n            splay(a[0]);\n            val[a[0]]=a[1];\n        }\n        else if(cha[1]=='M'){\n            split(a[0],a[1]);\n            printf(\"%d\\n\",mx[a[1]]);\n        }\n        else{\n            split(a[0],a[1]);\n            printf(\"%d\\n\",tot[a[1]]);\n        }\n    }\n}\n```",
        "postTime": 1533810286,
        "uid": 30903,
        "name": "Isonan",
        "ccfLevel": 0,
        "title": "luoguP2590 [ZJOI2008]\u6811\u7684\u7edf\u8ba1"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u677f\u5b50\u9898\n\u6a21\u677f\u9898\u90fd\u6bd4\u8fd9\u4e2a\u96be\u5341\u500d\u5de6\u53f3\u5427\n\u652f\u6301\u5355\u70b9\u4fee\u6539,\u533a\u95f4\u67e5\u8be2\u6c42\u548c,\u6c42\u6700\u5927\u503c\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\n```\n#include<bits/stdc++.h>\n#define LL long long\n#define rg register\nconst int N=30005;\nconst int inf=2147483647;\nusing namespace std;\ninline int gi(){\n    char ch=getchar();int x=0,q=0;\n    while(ch<'0' || ch>'9') ch=='-'?q=1:0,ch=getchar();\n    while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n    return q?(-x):x;\n}\nclass Segement{\npublic:\n\tint sum,mx;\n};\nSegement S[N<<2];\nint Next[N<<1],Head[N],V[N<<1],W[N],Fa[N],Size[N],Depth[N],Faedge[N],Hson[N],Id[N],Top[N];\nint idcnt,cnt,n;\nvoid Add(int u,int v){\n\tNext[++cnt]=Head[u];\n\tV[cnt]=v;\n\tHead[u]=cnt;\n}\nvoid Update(int now){\n\tint lson=now<<1,rson=now<<1|1;\n\tS[now].mx=max(S[lson].mx,S[rson].mx);\n\tS[now].sum=S[lson].sum+S[rson].sum;\n\treturn ;\n}\nvoid Modify(int now,int l,int r,int pos,int key){\n\tif (l==r){\n\t\tS[now].mx=S[now].sum=key;\n\t\treturn ;\n\t}\n\tint mid=(l+r)>>1;\n\tif (pos<=mid)   Modify(now<<1,l,mid,pos,key);\n\tif (pos>=mid+1) Modify(now<<1|1,mid+1,r,pos,key);\n\tUpdate(now);\n}\nvoid dfs1(int u,int fa){\n\tSize[u]=1;Fa[u]=fa;Faedge[u]=W[u];\n\tfor(int i=Head[u];i!=-1;i=Next[i])\n\t{\n\t\tint v=V[i];\n\t\tif (v==Fa[u]) continue;\n\t\tDepth[v]=Depth[u]+1;\n\t\tdfs1(v,u);\n\t\tSize[u]+=Size[v];\n\t\tif (Size[v]>Size[Hson[u]]) Hson[u]=v;\n\t}\n}\nvoid dfs2(int u,int top){\n\tId[u]=++idcnt;\n\tModify(1,1,n,idcnt,Faedge[u]);\n\tTop[u]=top;\n\tif (Hson[u]==0) return;\n\tdfs2(Hson[u],top);\n\tfor (int i=Head[u];i!=-1;i=Next[i]){\n\t\tint v=V[i];\n\t\tif (v!=Fa[u]&&v!=Hson[u]) dfs2(v,v);\n\t}\n\treturn ;\n}\nint Query_sum(int now,int l,int r,int L,int R){\n\tif (L<=l&&R>=r){\n\t\treturn S[now].sum;\n\t}\n\tint ret=0;\n\tint mid=(l+r)>>1;\n\tif(L<=mid)ret+=Query_sum(now<<1,l,mid,L,R);\n\tif(R>mid)ret+=Query_sum(now<<1|1,mid+1,r,L,R);\n\treturn ret;\n}\nint Query_max(int now,int l,int r,int L,int R){\n\tif (L<=l&&R>=r){\n\t\treturn S[now].mx;\n\t}\n\tint mid=(l+r)>>1;\n\tint ret=-inf;\n\tif(L<=mid)ret=max(ret,Query_max(now<<1,l,mid,L,R));\n\tif(R>mid)ret=max(ret,Query_max(now<<1|1,mid+1,r,L,R));\n\treturn ret;\n}\nint QC_max(int u,int v){\n\tint ret=-inf;\n\twhile (Top[u]!=Top[v]){\n\t\tif (Depth[Top[u]]<Depth[Top[v]]) swap(u,v);\n\t\tret=max(ret,Query_max(1,1,n,Id[Top[u]],Id[u]));\n\t\tu=Fa[Top[u]];\n\t}\n\tif (Depth[u]>Depth[v]) swap(u,v);\n\tret=max(ret,Query_max(1,1,n,Id[u],Id[v]));\n\treturn ret;\n}\nint QC_sum(int u,int v){\n\tint ret=0;\n\twhile (Top[u]!=Top[v]){\n\t\tif (Depth[Top[u]]<Depth[Top[v]]) swap(u,v);\n\t\tret+=Query_sum(1,1,n,Id[Top[u]],Id[u]);\n\t\tu=Fa[Top[u]];\n\t}\n\tif (Depth[u]>Depth[v]) swap(u,v);\n\tret+=Query_sum(1,1,n,Id[u],Id[v]);\n\treturn ret;\n}\nint main(){\n\t//freopen(\"count.in\",\"r\",stdin);\n\t//freopen(\"count.out\",\"w\",stdout);\n\tmemset(Head,-1,sizeof(Head));\n\tn=gi();\n\tfor(int i=1,u,v;i<n;i++){\n\t\tu=gi();v=gi();\n\t\tAdd(u,v);Add(v,u);\n\t}\n\tfor(int i=1;i<=n;i++) W[i]=gi();\n    Depth[1]=1;\n \tdfs1(1,0);\n\tdfs2(1,1);\n\tint q=gi();\n\tchar opt[10];\n\twhile(q){\n\t\tq--;\n\t\tscanf(\" %s\",opt);\n\t\tif(opt[0]=='C'){\n\t\t\tint pos,key;\n\t\t\tpos=gi();key=gi();\n\t\t\tModify(1,1,n,Id[pos],key);\n\t\t}\n\t\tif(opt[1]=='S'){\n\t\t\tint u,v;\n\t\t\tu=gi();v=gi();\n\t\t\tcout<<QC_sum(u,v)<<endl;\n\t\t}\n\t\tif(opt[1]=='M'){\n\t\t\tint u,v;\n\t\t\tu=gi();v=gi();\n\t\t\tcout<<QC_max(u,v)<<endl;\n\t\t}\n\t}\n    return 0;\n}\n\n```",
        "postTime": 1519630948,
        "uid": 61360,
        "name": "KingBenQi",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u6a21\u677f\u56fe\n\u611f\u89c9\u5e38\u6570\u4e0d\u7b97\u7279\u522b\u5927\u5427\n\u4e0d\u5f00O2 1012ms\n\u611f\u89c9\u81ea\u5df1\u5199\u7684\u8fd8\u662f\u633a\u6e05\u6670\u7684\uff0c\uff0c\uff0c\uff0c\n\u4f46\u662f\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u6211\u7684\u4ee3\u7801\u6bcf\u6b21\u90fd\u7279\u522b\u957f\u3002\u3002\u3002\n\u8fd9\u91cc\u7b80\u5355\u8bb2\u4e00\u4e0b\u505a\u6cd5\n\u5148\u5256\u5206\u4e00\u4e0b\uff0c\u7136\u540e\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u548c\u533a\u95f4\u548c\n\u6700\u540e\u5199\u4e00\u4e2a\u5355\u70b9\u4fee\u6539\u5c31\u53ef\u4ee5\u4e86\n\uff0c\uff0c\u8bb0\u5f97\u8981\u6ce8\u610f\u6743\u503c\u662f\u6709\u8d1f\u6570\u7684\uff01\n\n\t#include<bits/stdc++.h>\n\tusing namespace std;\n\t#define AC 40100\n\t#define ACway 80010\n\t#define R register int\n\tint ans,n,m,num;\n\tint power[AC],deep[AC],size[AC],son[AC],top[AC],father[AC];\n\tint date[ACway],Next[ACway],Head[AC],tot;//\u94fe\u5f0f\u524d\u5411\u661f\n\tint sum[ACway],maxn[ACway],l[ACway],r[ACway],cnt,id[AC],repower[AC];\n\n\tinline int read()//\u8bfb\u5165\u4f18\u5316\n\t{\n\t\tint x=0;char c;bool z=false;\n\t\twhile(isspace(c=getchar()));\n\t\tif(c=='-')z=true,c=getchar();\n\t\twhile(c>='0' && c<='9')x=x*10+c-'0',c=getchar();\n\t\tif(!z)return x;\n\t\telse return -x;\n\t}\n\n\tinline void upmax(int &a,int b)\n\t{\n\t\tif(b>a) a=b;\n\t}\n\n\tinline void add(int f,int w)//\u52a0\u53cc\u5411\u8fb9\n\t{\n\t    date[++tot]=w,Next[tot]=Head[f],Head[f]=tot;\n\t    date[++tot]=f,Next[tot]=Head[w],Head[w]=tot;\n\t}\n\n\tvoid pre()\n\t{\n\t\tR a,b;\n\t\tn=read();\n\t\tmemset(maxn,128,sizeof(maxn));\n\t\tfor(R i=1;i<n;i++)\n\t\t{\n\t\t\ta=read(),b=read();\n\t\t\tadd(a,b);\n\t\t}\n\t\tfor(R i=1;i<=n;i++) power[i]=read();\n\t}\n\n\tvoid dfs1(int x,int fa,int dep)//get size && son && deep && father\n\t{\n\t\tR maxson=-1,now;//maxson\u8bb0\u5f55\u91cd\u513f\u5b50\u7684\u5927\u5c0f\n\t\tdeep[x]=dep;\n\t\tsize[x]=1;\n\t\tfather[x]=fa;\n\t\tfor(R i=Head[x]; i ;i=Next[i])\n\t\t{\n\t\t\tnow=date[i];\n\t\t\tif(now!=fa)//\u8df3\u8fc7\u7236\u4eb2\n\t\t\t{\n\t\t\t\tdfs1(now,x,dep+1);\n\t\t\t\tsize[x]+=size[now];\n\t\t\t\tif(size[now] > maxson) son[x]=now,maxson=size[now];//\u8bb0\u5f55\u91cd\u513f\u5b50\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs2(int x,int topx)//get repower && top && id\n\t{\n\t\tR now;\n\t\tid[x]=++cnt;//\u8bb0\u5f55\u65b0id\n\t\trepower[cnt]=power[x];//\u8bb0\u5f55\u5bf9\u5e94\u6743\u503c\n\t\ttop[x]=topx;\n\t\tif(!son[x])return ;//\u5982\u679c\u6ca1\u6709\u513f\u5b50\u4e86\u5c31\u8fd4\u56de\n\t\tdfs2(son[x],topx);\n\t\tfor(R i=Head[x]; i ;i=Next[i])\n\t\t{\n\t\t\tnow=date[i];\n\t\t\tif(now != father[x] && now !=son[x])//\u8df3\u8fc7\u91cd\u513f\u5b50\u548c\u7236\u4eb2\n\t\t\t{\n\t\t\t\tdfs2(now,now);//\u65b0\u62c9\u4e00\u6761\u94fe\n\t\t\t}\n\t\t}\n\t}\t\n\n\tvoid built(int x,int ll,int rr)//\u9012\u5f52\u5efa\u6811\n\t{\n\t\tint mid=(ll+rr)/2;\n\t\tl[x]=ll,r[x]=rr;\n\t\tif(ll==rr)\n\t\t{\n\t\t\tsum[x]=repower[ll];\n\t\t\tmaxn[x]=repower[ll];\n\t\t\treturn ;\n\t\t}\n\t\tbuilt(x*2,ll,mid);\n\t\tbuilt(x*2+1,mid+1,rr);\n\t\tsum[x]=sum[x*2]+sum[x*2+1];\n\t\tupmax(maxn[x],maxn[x*2]);\n\t\tupmax(maxn[x],maxn[x*2+1]);\n\t}\n\n\tvoid change(int want)//\u5355\u70b9\u4fee\u6539\n\t{\n\t\tR mid,x=1;\n\t\twhile(1)//\u627e\u5230\u8fd9\u4e2a\u8282\u70b9\u7684\u4e0b\u6807 \n\t\t{\n\t\t\tmid=(l[x]+r[x])/2;\n\t\t\tif(l[x]==r[x])\tbreak;//\u5982\u679c\u627e\u5230\u76ee\u6807\u8282\u70b9\u5c31\u9000\u51fa,\u56e0\u4e3a\u662f\u5355\u70b9\u4fee\u6539\uff0c\u6240\u4ee5\u78b0\u5230\u53f6\u8282\u70b9\u4e00\u5b9a\u5c31\u662f\u76ee\u6807\u8282\u70b9\u4e86\n\t\t\tx*=2;\n\t\t\t//if(want<=mid) x*=2;\t\n\t\t\tif(want>=mid+1) ++x;\n\t\t}\n\t\tmaxn[x]=num;\n\t\tsum[x]=num;\n\t\tx/=2;\n\t\twhile(x)\n\t\t{\n\t\t\tsum[x]=sum[x*2]+sum[x*2+1];//\u91cd\u65b0\u83b7\u53d6\u6743\u503c\u548c\n\t\t\tmaxn[x]=-30010;//error!!!\u4e0d\u80fd\u76f4\u63a5\u53d6max\uff0c\u8981\u5148\u6e05\u7a7a\u539f\u503cerror!!!\u6743\u503c\u6709\u8d1f\u7684\uff01\uff01\uff01\n\t\t\tupmax(maxn[x],maxn[x*2]);\n\t\t\tupmax(maxn[x],maxn[x*2+1]);\t\t\n\t\t\tx/=2;//\u627e\u5230\u7236\u4eb2\n\t\t}\n\t}\n\n\tvoid searchmax(int x,int ll,int rr)//\u533a\u95f4\u6700\u5927\u503c\u67e5\u8be2\n\t{\n\t\tR mid;\n\t\tif(l[x]==ll && r[x]==rr)\n\t\t{\n\t\t\tupmax(ans,maxn[x]);\n\t\t\treturn ;\n\t\t}\n\t\tmid=(l[x]+r[x])/2;\n\t\tif(rr<=mid)searchmax(x*2,ll,rr);\n\t\telse if(ll>=mid+1)searchmax(x*2+1,ll,rr);\n\t\telse\n\t\t{\n\t\t\tsearchmax(x*2,ll,mid);\n\t\t\tsearchmax(x*2+1,mid+1,rr);\n\t\t}\n\t}\n\n\tvoid searchsum(int x,int ll,int rr)//\u533a\u95f4\u548c\u67e5\u8be2\n\t{\n\t\tR mid;\n\t\tif(l[x]==ll && r[x]==rr)\n\t\t{\n\t\t\tans+=sum[x];\n\t\t\treturn ;\n\t\t}\n\t\tmid=(l[x]+r[x])/2;\n\t\tif(rr<=mid)searchsum(x*2,ll,rr);\n\t\telse if(ll>=mid+1)searchsum(x*2+1,ll,rr);\n\t\telse\n\t\t{\n\t\t\tsearchsum(x*2,ll,mid);\n\t\t\tsearchsum(x*2+1,mid+1,rr);\n\t\t}\n\t}\n\n\tvoid getmax(int x,int y)\n\t{\n\t\tans=-30100;\n\t\twhile(top[x]!=top[y])\n\t\t{\n\t\t\tif(deep[top[x]] < deep[top[y]])\tswap(x,y);//\u5148\u5904\u7406\u6df1\u7684error!!!\u5e94\u8be5\u662f\u5148\u5904\u7406top\u6df1\u7684\n\t\t\tsearchmax(1,id[top[x]],id[x]);//\u6d45\u7684\u6807\u53f7\u5c0f\n\t\t\tx=father[top[x]];\n\t\t}\n\t\tif(deep[x] < deep[y]) searchmax(1,id[x],id[y]);\n\t\telse searchmax(1,id[y],id[x]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\tvoid getsum(int x,int y)\n\t{\n\t\tans=0;\n\t\twhile(top[x]!=top[y])\n\t\t{\n\t\t\tif(deep[top[x]] < deep[top[y]])\tswap(x,y);//error\uff01\uff01\uff01\u5148\u5904\u7406top\u6df1\u7684\n\t\t\tsearchsum(1,id[top[x]],id[x]);\n\t\t\tx=father[top[x]];\n\t\t}\n\t\tif(deep[x] < deep[y]) searchsum(1,id[x],id[y]);\n\t\telse searchsum(1,id[y],id[x]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\tvoid work()\n\t{\n\t\tchar c[10];\n\t\tR a,b;\n\t\tm=read();\n\t\tfor(R i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"%s\",c+1);\n\t\t\tif(c[1]=='C')//\u5355\u70b9\u4fee\u6539\n\t\t\t{\n\t\t\t\ta=read(),num=read();\n\t\t\t\tchange(id[a]);\n\t\t\t}\n\t\t\telse if(c[2]=='M')//\u8be2\u95ee\u6700\u5927\u503c\n\t\t\t{\n\t\t\t\ta=read(),b=read();\n\t\t\t\tgetmax(a,b);\n\t\t\t}\n\t\t\telse //\u8be2\u95ee\u6743\u503c\u548c\n\t\t\t{\n\t\t\t\ta=read(),b=read();\n\t\t\t\tgetsum(a,b);\n\t\t\t}\n\t\t}\n\t}\n\n\tint main()\n\t{\n\t\tfreopen(\"in.in\",\"r\",stdin);\n\t\tpre();\n\t\tdfs1(1,0,1);\n\t\tdfs2(1,1);\n\t\tbuilt(1,1,cnt);\n\t\twork();\n\t\tfclose(stdin);\n\t\treturn 0;\n\t}",
        "postTime": 1519056674,
        "uid": 47136,
        "name": "ww3113306",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u57fa\u7840\u6811\u5256\uff08\u4ece[P3178](https://www.luogu.org/problemnew/show/P3178)\u7684\u4ee3\u7801\u7a0d\u4f5c\u4fee\u6539\u4fbf\u53efA\u6389\n\u8fd9\u91cc\u548c3178\u5dee\u522b\u5728\u4e8e\u7ebf\u6bb5\u6811\u7684\u8fc7\u7a0b\u4e0d\u540c\u548c\u4e00\u4e2adeep\u6570\u7ec4\uff0c\u5177\u4f53\u770b\u4ee3\u7801\n```cpp\n#include <bits/stdc++.h>\n#pragma GCC optimize(3)//\u624b\u5f00O3\u306e\u65e5\u5e38\n#define N 100010\nusing namespace std;\nint n,m,fr,t,a,c,data[N],Size[N],num,p[2*N],fa[N],id,out[2*N],pos[2*N],h[2*N],belong[2*N],b[2*N],nt[2*N],son[N*2],deep[2*N];\nchar s[10];\nstruct node\n{\n    int left,right,mx;\n    long long sum,val;\n};struct node tree[4*N];//\u7ebf\u6bb5\u6811\nvoid pushdown(int p)\n{\n    if(tree[p].val!=0)\n    {\n        tree[2*p].val=tree[p].val;\n        tree[2*p+1].val=tree[p].val;\n        tree[2*p].sum=(tree[2*p].right-tree[2*p].left+1)*tree[p].val;\n        tree[2*p+1].sum=(tree[2*p+1].right-tree[2*p+1].left+1)*tree[p].val;\n        tree[p].val=0;\n    }\n}//lazy tag\u7684\u4e0b\u653e\nvoid dfs(int x,int dep)\n{\n    deep[x]=dep;\n    Size[x]=1;\n    int e=p[x];\n    while(e>0)\n    {\n        int k=b[e];\n        if(fa[x]!=k)\n        {\n            fa[k]=x;//\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u7684\u7236\u8282\u70b9\uff0c\u65b9\u4fbf\u5411\u4e0a\u8df3\n            dfs(k,dep+1);\n            if(Size[k]>Size[son[x]])\n                son[x]=k;//\u4e0d\u65ad\u66f4\u65b0\u8be5\u8282\u70b9\u7684\u91cd\u513f\u5b50\n            Size[x]+=Size[k];//\u66f4\u65b0\u8be5\u8282\u70b9\u4e0b\u65b9\u7684\u8282\u70b9\u6570\n        }\n        e=nt[e];\n    }\n}//\u641c\u7d22\u786e\u5b9a\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\u4e0e\u5176\u4e0b\u7684\u7ed3\u70b9\u4e2a\u6570\nvoid DFS(int x,int bh)//bh\u4e3a\u8be5\u8282\u70b9\u6240\u5c5e\u91cd\u94fe\u7684\u7f16\u53f7(\u7f16\u53f7\u4e3a\u8be5\u91cd\u94fe\u8d77\u70b9\u7f16\u53f7\n{\n    id++;\n    pos[x]=id;//\u641c\u7d22\u5e8f\u8bb0\u5f55\n    out[x]=id;//\u8fd9\u4e2a\u6570\u7ec4\u8bf7\u5ffd\u89c6(\u505a3178\u540e\u5fd8\u4e86\u6539QAQ\n    h[id]=x;//\u7ebf\u6bb5\u6811\u4e0a\u7684\u4f4d\u7f6e\n    int e=p[x];\n    int k=0;\n    belong[x]=bh;//\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u6240\u5c5e\u7684\u91cd\u94fe\u7f16\u53f7\n    if(son[x])\n    {\n        DFS(son[x],bh);//\u4f18\u5148\u641c\u7d22\u91cd\u513f\u5b50\u53ef\u5f97\u5230\u91cd\u94fe\n        out[x]=max(out[x],out[son[x]]);\n    }\n    e=p[x];\n    while(e>0)\n    {\n        int kk=b[e];\n        if(fa[x]!=kk&&kk!=son[x])\n        {\n            DFS(kk,kk);\n            out[x]=max(out[x],out[kk]);\n        }\n        e=nt[e];\n    }//\u641c\u7d22\u8f7b\u94fe\n}\nvoid add(int u,int v)\n{\n    ++num;\n    b[num]=v;\n    nt[num]=p[u];\n    p[u]=num;\n}//\u524d\u5411\u661f\u5b58\u56fe\nvoid build(int p,int l,int r)\n{\n    tree[p].left=l;\n    tree[p].right=r;\n    if(l==r)\n    {\n        tree[p].sum=data[h[l]];\n        tree[p].mx=data[h[l]];\n        return;\n    }\n    int mid=(l+r)/2;\n    build(2*p,l,mid);\n    build(2*p+1,mid+1,r);\n    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;\n    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);\n}//\u5efa\u6811\nvoid change(int p,int l,int r,long long d)\n{\n    if(tree[p].left==l&&tree[p].right==r)\n    {\n        tree[p].sum=(r-l+1)*d;\n        tree[p].mx=d;\n        tree[p].val=d;\n        return;\n    }\n    pushdown(p);\n    int mid=(tree[p].left+tree[p].right)/2;\n    if(r<=mid)\n        change(2*p,l,r,d);\n    else if(l>mid)\n        change(2*p+1,l,r,d);\n    else\n    {\n        change(2*p,l,mid,d);\n        change(2*p+1,mid+1,r,d);\n    }\n    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;\n    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);\n}//\u7ebf\u6bb5\u6811\u4fee\u6539\u64cd\u4f5c(\u6ce8\u610f\u6b64\u5904\u8981\u540c\u65f6\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u4e0e\u533a\u95f4\u548c\nlong long query(int p,int l,int r)\n{\n    if(tree[p].left==l&&tree[p].right==r)\n        return tree[p].sum;\n    pushdown(p);\n    int mid=(tree[p].left+tree[p].right)/2;\n    if(r<=mid)\n        return query(2*p,l,r);\n    else if(l>mid)\n        return query(2*p+1,l,r);\n    else\n        return query(2*p,l,mid)+query(2*p+1,mid+1,r);\n}//\u67e5\u8be2\u533a\u95f4\u548c\nint Query(int p,int l,int r)\n{\n    if(tree[p].left==l&&tree[p].right==r)\n        return tree[p].mx;\n    pushdown(p);\n    int mid=(tree[p].left+tree[p].right)/2;\n    if(r<=mid)\n        return Query(2*p,l,r);\n    else if(l>mid)\n        return Query(2*p+1,l,r);\n    else\n        return max(Query(2*p,l,mid),Query(2*p+1,mid+1,r));\n}//\u67e5\u8be2\u533a\u95f4\u6700\u5927\u503c\nlong long work(int x,int y)\n{\n    long long sum=0;\n    while(belong[x]!=belong[y])\n    {\n        if(deep[belong[x]]<deep[belong[y]])\n            swap(x,y);\n        sum+=query(1,pos[belong[x]],pos[x]);\n        x=fa[belong[x]];\n    }\n    if(deep[x]>deep[y])\n        swap(x,y);\n    sum+=query(1,pos[x],pos[y]);\n    return sum;\n}//QSUM\u7684\u64cd\u4f5c\uff08\u89e3\u91ca\u89c1\u4e0b\uff09\nint Work(int x,int y)\n{\n    int ans=-214748;\n    while(belong[x]!=belong[y])\n    {\n        if(deep[belong[x]]<deep[belong[y]])\n            swap(x,y);//\u6bd4\u8f83x\u548cy\u6240\u5c5e\u91cd\u94fe\u8d77\u70b9\u7684\u6df1\u6d45\uff0c\u5c06\u8f83\u6d45\u7684\u5411\u4e0a\u8df3\n        ans=max(ans,Query(1,pos[belong[x]],pos[x]));\n        x=fa[belong[x]];\n    }//\u5982\u679cx\u4e0ey\u4e0d\u5728\u540c\u4e00\u91cd\u94fe\u4e2d\uff0c\u5c31\u91cd\u590d\u6267\u884c\u64cd\u4f5c\n    if(deep[x]>deep[y])\n        swap(x,y);\n    ans=max(ans,Query(1,pos[x],pos[y]));//x\u4e0ey\u5728\u540c\u4e00\u91cd\u94fe\u4e2d\u6700\u540e\u8fdb\u884c\u4e00\u6b21\u64cd\u4f5c\n    return ans;\n}//QMAX\u7684\u64cd\u4f5c\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&fr,&t);\n        add(fr,t);\n        add(t,fr);\n    }\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&data[i]);\n    dfs(1,1);\n    DFS(1,1);//\u5148\u8fdb\u884c\u641c\u7d22\u786e\u5b9a\u4e86\u7ebf\u6bb5\u6811\u4e0a\u7684\u7f16\u53f7\u518d\u5efa\u6811\n    build(1,1,n);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%s\",s);\n        if(s[1]=='H')\n        {\n            scanf(\"%d%d\",&a,&c);\n            change(1,pos[a],pos[a],c);\n        }\n        else if(s[1]=='M')\n        {\n            scanf(\"%d%d\",&a,&c);\n            printf(\"%d\\n\",Work(a,c));\n        }\n        else\n        {\n            scanf(\"%d%d\",&a,&c);\n            printf(\"%lld\\n\",work(a,c));\n        }\n    }\n    return 0;\n}\n```\n\u7136\u800c\u8dd1\u7684\u5f88\u6162\n[1208ms 7.92Mb](https://www.luogu.org/record/show?rid=5654505)\n\n\u849f\u84bb\u7b2c\u4e00\u6b21\u53d1\u7d2b\u9898\u9898\u89e3\uff0c\u6709\u89e3\u91ca\u7684\u4e0d\u6e05\u695a\u7684\u5730\u65b9\u671b\u5404\u4f4d\u795e\u7287\u8c05\u89e3",
        "postTime": 1517986036,
        "uid": 55454,
        "name": "DimensionTripper",
        "ccfLevel": 0,
        "title": "[P2590] \u6811\u7684\u7edf\u8ba1"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u7ec3\u624b\u9898\uff0c\u6253\u4e00\u6253\u6a21\u677f\u5c31\u597d\u4e86\u3002\n\n\u6ce8\u610f\uff1a\n\n1.\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e24\u4e2a\u503c\u5e94\u8be5\u4e0d\u7528\u591a\u8bf4\uff0c\u4e0d\u4f1a\u7ebf\u6bb5\u6811\u7684\u81ea\u884c\u767e\u5ea6\u3002\u3002\u3002\n\n2.\u6811\u5256\u7684\u5e8f\u53f7\uff01=\u8282\u70b9\u53f7\uff0c\u8fd9\u4e2a\u5751\u4e86\u6211\u534a\u5c0f\u65f6\u3002\u3002\u3002\n\n3.\u7ebf\u6bb5\u6811\u5f004\u500d\u3002\u3002\u3002\n\n\u8bdd\u8bf4\u8fd9\u5e74\u5934\u7528 \u5b8f\u5b9a\u4e49 \u7684\u4eba\u600e\u4e48\u8fd9\u4e48\u5c11\u3002\u3002\u3002\n\n\u8fd8\u6709\uff0c\u6811\u5256\u662f\u4e2a\u597d\u4e1c\u4e1c\u3002\u3002\u3002\n\n\u9644\u4ee3\u7801\uff1a\n\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#define LSON rt<<1\n#define RSON rt<<1|1\n#define DATA1(x) b[x].data1\n#define DATA2(x) b[x].data2\n#define LSIDE(x) b[x].l\n#define RSIDE(x) b[x].r//\u7ebf\u6bb5\u6811\u57fa\u672c\n#define MAXN 30010\n#define MAX 999999999//\u6781\u503c\nusing namespace std;\nint n,m,c=1,d=1;\nint head[MAXN],deep[MAXN],size[MAXN],son[MAXN],top[MAXN],fa[MAXN],id[MAXN];\nstruct node1{//\u524d\u5411\u661f\u5b58\u56fe\u6ca1\u8bdd\u8bf4\n    int next,to;\n}a[MAXN<<1];\nstruct node2{//\u7ebf\u6bb5\u6811\u6ca1\u8bdd\u8bf4\n    int data1,data2;\n    int l,r;\n}b[MAXN<<2];\ninline int read(){//\u4e8c\u8bdd\u4e0d\u8bf4\u4e0a\u8bfb\u4f18\u3002\u3002\u3002\n    int date=0,w=1;char c=0;\n    while(c<'0'||c>'9'){if(c=='-')w=-1;c=getchar();}\n    while(c>='0'&&c<='9'){date=date*10+c-'0';c=getchar();}\n    return date*w;\n}\ninline int max(const int x,const int y){if(x<y)return y;return x;}//\u611f\u89c9 STL \u4e0d\u9760\u8c31\uff0c\u4e8e\u662f\u624b\u5199\nvoid pushup(int rt){//\u4e0a\u4f20\n    DATA1(rt)=max(DATA1(LSON),DATA1(RSON));\n    DATA2(rt)=DATA2(LSON)+DATA2(RSON);\n}\nvoid buildtree(int l,int r,int rt){//\u5efa\u6811\n    int mid;\n    LSIDE(rt)=l;\n    RSIDE(rt)=r;\n    if(l==r){\n        DATA1(rt)=DATA2(rt)=0;//\u76f4\u63a5\u8d4b\u4e3a0\uff0c\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\uff0c\u4e0d\u8fc7\u8fd8\u8981\u518d\u5f00\u4e00\u4e2a\u6570\u7ec4\uff0c\u5c31\u50cf\u697c\u4e0b\u7ba1\u7406\u5458\u4e00\u6837\n        return;\n    }\n    mid=l+r>>1;\n    buildtree(l,mid,LSON);\n    buildtree(mid+1,r,RSON);\n    pushup(rt);\n}\nvoid update(int l,int r,int c,int rt){//\u5355\u70b9\u4fee\u6539\n    int mid;\n    if(l<=LSIDE(rt)&&RSIDE(rt)<=r){\n        DATA1(rt)=DATA2(rt)=c;//\u76f4\u63a5\u4ed8\u5c31\u597d\u5566\n        return;\n    }\n    mid=LSIDE(rt)+RSIDE(rt)>>1;\n    if(l<=mid)update(l,r,c,LSON);\n    if(mid<r)update(l,r,c,RSON);\n    pushup(rt);\n}\nint query1(int l,int r,int rt){//\u6c42\u6700\u503c\n    int mid,ans=-MAX;//\u521d\u503c\u662f\u6781\u5c0f\u503c\uff0c\u4e0d\u662f0\uff08\u5de8\u5751\u3002\u3002\u3002\uff09\n    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)\n    return DATA1(rt);\n    mid=LSIDE(rt)+RSIDE(rt)>>1;\n    if(l<=mid)ans=max(ans,query1(l,r,LSON));\n    if(mid<r)ans=max(ans,query1(l,r,RSON));\n    return ans;\n}\nint query2(int l,int r,int rt){//\u6c42\u548c\u503c\n    int mid,ans=0;\n    if(l<=LSIDE(rt)&&RSIDE(rt)<=r)\n    return DATA2(rt);\n    mid=LSIDE(rt)+RSIDE(rt)>>1;\n    if(l<=mid)ans+=query2(l,r,LSON);\n    if(mid<r)ans+=query2(l,r,RSON);\n    return ans;\n}\nvoid add(int u,int v){//\u52a0\u8fb9\n    a[c].to=v;\n    a[c].next=head[u];\n    head[u]=c++;\n    a[c].to=u;\n    a[c].next=head[v];\n    head[v]=c++;\n}\nvoid dfs1(int rt){\n    son[rt]=0;size[rt]=1;\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(!deep[will]){\n            deep[will]=deep[rt]+1;\n            fa[will]=rt;\n            dfs1(will);\n            size[rt]+=size[will];\n            if(size[will]>size[son[rt]])son[rt]=will;\n        }\n    }\n}\nvoid dfs2(int rt,int f){//\u6811\u52562\u4e2a dfs \u4e0d\u7528\u591a\u8bf4\u4e86\u5427\n    id[rt]=d++;top[rt]=f;\n    if(son[rt])dfs2(son[rt],f);\n    for(int i=head[rt];i;i=a[i].next){\n        int will=a[i].to;\n        if(will!=son[rt]&&will!=fa[rt])\n        dfs2(will,will);\n    }\n}\nvoid work1(int x,int y){//\u6811\u4e0a\u4fee\u6539\uff0c\u597d\u50cf\u6709\u70b9\u591a\u4e8b\u4e86\u3002\u3002\u3002\n    update(id[x],id[x],y,1);\n    return;\n}\nvoid work2(int x,int y){//\u6c42\u6700\u503c\n    int s=-MAX;\n    while(top[x]!=top[y]){\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        s=max(s,query1(id[top[x]],id[x],1));\n        x=fa[top[x]];\n    }\n    if(deep[x]>deep[y])swap(x,y);\n    s=max(s,query1(id[x],id[y],1));//\u6ce8\u610f\u4e0d\u7528\u5224\u65adx\u4e0ey\u662f\u5426\u4e0d\u7b49\n    printf(\"%d\\n\",s);\n    return;\n}\nvoid work3(int x,int y){//\u6c42\u548c\u503c\n    int s=0;\n    while(top[x]!=top[y]){\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        s+=query2(id[top[x]],id[x],1);\n        x=fa[top[x]];\n    }\n    if(deep[x]>deep[y])swap(x,y);\n    s+=query2(id[x],id[y],1);//\u6ce8\u610f\u4e0d\u7528\u5224\u65adx\u4e0ey\u662f\u5426\u4e0d\u7b49\n    printf(\"%d\\n\",s);\n    return;\n}\nvoid work(){//\u5904\u7406\u95ee\u9898\n    char ch[10];\n    int x,y;\n    m=read();\n    while(m--){\n        scanf(\"%s\",ch);x=read();y=read();\n        if(ch[0]=='C')work1(x,y);\n        if(ch[1]=='M')work2(x,y);\n        if(ch[1]=='S')work3(x,y);\n    }\n}\nvoid init(){//\u9884\u5904\u7406+\u8bfb\u5165\n    int u,v,w;\n    n=read();\n    for(int i=1;i<n;i++){\n        u=read();v=read();\n        add(u,v);\n    }\n    deep[1]=fa[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    buildtree(1,n,1);\n    for(int i=1;i<=n;i++){\n        w=read();\n        update(id[i],id[i],w,1);//\u5efa\u5b8c\u6811\u518d\u63d2\u5165\n    }\n    work();\n}\nint main(){//\u4e3b\u51fd\u6570So easy\uff01\n    init();\n    return 0;\n}\n\n```",
        "postTime": 1513515289,
        "uid": 49998,
        "name": "\u65af\u5fb7\u54e5\u5c14\u6469",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u52a8\u6001\u6811,\u76f4\u63a5splay\uff0c\u7531\u4e8e\u52a8\u6001\u6811\u672c\u6765\u4e0d\u9002\u5408\u7ef4\u62a4\u9759\u6001\uff0c\u4f46\u5361\u5361\u5e38\u8fd8\u662f\u5f88\u5feb\u7684\uff0c\u4ee5\u4e0b\u662fAC\u4ee3\u7801\uff0c\u5e0c\u671b\u53ef\u4ee5\u4f5c\u4e3aLCT\u6a21\u677f\u9898\u53c2\u8003\n\n\n\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define L 25\n#define M 30001\n#define l(h) (ch[h][0])\n#define f(h) (fa[h])\n#define r(h) (ch[h][1])\n#define sum(h) sum[h]\n#define Q inline\n#define R register\n#define SET(A,B) memset(A,B,sizeof(A))\nusing namespace std;\nint sum[M], fa[M], ch[M][2], key[M], rev[M];\nint bgn[M], nxt[M<<1], to[M<<1], e, max_[M], sta[M], sta_siz;\nQ int chkmax(int a,int b) {return a > b ? a : b;}\nint cmp(int a,int b) {return (a ^ b) ? 0 : 1;}\nQ int isroot(int h) {return (l(f(h))^h && r(f(h))^h);}\nQ void swap(int &x, int &y) {int z = x; x = y; y = z;}\nstruct LCT\n{\n  void maintain(int h)\n  {\n      sum[h] = key[h]; max_[h] = key[h];\n      if(l(h)) sum[h] += sum(l(h)); if(l(h)) max_[h] = chkmax(max_[l(h)], max_[h]);\n      if(r(h)) sum[h] += sum(r(h)); if(r(h)) max_[h] = chkmax(max_[r(h)], max_[h]);\n  }\n  void revtag(int h) {rev[h] ^= 1; swap(l(h), r(h));}\n  void pushdown(int h)\n  {\n      if(rev[h])\n      {\n        rev[h] = 0;\n        if(l(h)) revtag(l(h));\n        if(r(h)) revtag(r(h));\n    }\n  }\n  void pushroad(int h)\n  {\n      sta_siz = 0;\n     for(int i=h; ;i=f(i)) {sta[++sta_siz] = i; if(isroot(i))break;}\n      for(int i=sta_siz; i>=1; --i) pushdown(sta[i]);\n  }\n  void rotate(int h)\n  {\n      int f = f(h), g = f(f), c=cmp(h,r(f));\n      if(!isroot(f)) {ch[g][cmp(f,r(g))] = h;} f(h) = g; f(f) = h;\n      f(ch[h][!c]) = f;\n      ch[f][c] = ch[h][!c];\n      ch[h][!c] = f; \n      maintain(f); maintain(h);\n  }\n  void splay(int h)\n  {\n      pushroad(h);\n      while(!isroot(h))\n      {\n        if(!isroot(f(h))) rotate(h);\n        rotate(h);    \n      }\n  }\n  void access(int x)\n  {\n    int y = 0;\n    while(x)\n    {\n        splay(x);\n        r(x) = y;\n        maintain(x);\n        y = x, x = f(x);\n    }\n  }\n  void chanroot(int x)\n  {\n      access(x), splay(x), revtag(x);\n  }\n  void cut(int x,int y)\n  {\n      chanroot(x), access(y), splay(y), f(l(y)) = 0; l(y) = 0;\n  }\n  void link(int x,int y)\n  {\n      chanroot(x), f(x) = y; splay(y), maintain(y);\n  }\n  int findroot(int x)\n  {\n      access(x), splay(x); while(l(x)) x = l(x); return x;\n  }\n  void init()\n  {\n      SET(bgn, 0); e = 0; SET(max_,0); \n      SET(key,0), SET(sum,0); SET(ch, 0), SET(fa, 0), SET(rev, 0);\n  }\n  void Updateroad(int x, int y)\n  {\n      access(x), splay(x), key[x] = y;\n  }\n  int askroad(int x,int y)\n  {\n      chanroot(x), access(y), splay(y); return sum[y];\n  }\n  int askmaxroad(int x,int y)\n  {\n      chanroot(x), access(y), splay(y); return max_[y];\n  }\n} jun;\nstruct Graph\n{\n  void add(int x,int y) {to[++e] = y; nxt[e] = bgn[x]; bgn[x] = e;}\n  void dfs(int x)\n  {\n      for(register int i=bgn[x]; i; i=nxt[i])\n      {\n        int y = to[i]; if(y == f(x)) continue;\n        f(y) = x; dfs(y);    \n    }\n  }\n} g;\ninline int read()\n{\n  int x = 0;\n  int d = 1;\n  char ch = getchar();\n  if(ch == '-') d = -1;\n  while(ch > '9' || ch < '0'){ ch =getchar(); if(cmp(ch,'-')) d = -1;}\n  while(ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n  return x * d;\n}\nint main()\n{\n  char str[L];\n  int n, x, y, m;\n  if(1)\n  {\n      n = read();\n      for(R int i=1; i<n; ++i) {x = read(), y = read(), g.add(x,y), g.add(y,x);}\n      g.dfs(1);\n      for(R int i=1; i<=n; ++i) key[i] = read();\n      m = read();\n      for(R int i=1; i<=m; ++i)\n      {\n        scanf(\"%s\", str);\n        x = read(); y = read();\n        if(str[1] == 'S') printf(\"%d\\n\",jun.askroad(x,y));\n        if(str[1] == 'M') printf(\"%d\\n\",jun.askmaxroad(x,y));\n        if(str[1] == 'H') jun.Updateroad(x,y);\n      } \n  }\n}\n```",
        "postTime": 1486383909,
        "uid": 7268,
        "name": "_bestknife",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\uff0c\u7b97\u662f\u6bd4\u8f83\u5feb\u7684\u7248\u672c\u4e4b\u4e00\u3002\n\n\u5efa\u6811\u548c\u4fee\u6539\u7528\u7684\u662fzkw\u7ebf\u6bb5\u6811\u5199\u6cd5\uff0c\u7531\u4e8e\u592a\u5f31\u2026\u2026\u67e5\u8be2\u4e0d\u4f1a\uff0c\u4f7f\u7528\u7684\u666e\u901a\u7ebf\u6bb5\u6811\u5199\u6cd5\u3002\n\n\n\n\n\n\n\n\n        \n\n\n\n\n    \n\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define MAXN 60000\n#define INF 0x3f3f3f3f\n#define mx(x) t[x].mx\n#define sm(x) t[x].sm\n#define lc(x) (x<<1)\n#define rc(x) (x<<1|1)\n#define mid ((lef+rig)>>1)\n#define gc() getchar()\ninline int read(int ans = 0, int sgn = ' ', int ch = gc())\n{\n    for(;ch < '0' || ch > '9'; sgn=ch,ch=gc());\n    for(;ch >='0' && ch <='9'; (ans*=10)+=ch-'0',ch=gc());\n    return sgn-'-' ? ans : -ans;\n}\nstruct Edge\n{\n    int to,nex;\n    Edge(){}\n    Edge(int _to, int _nex):to(_to),nex(_nex){}\n}e[MAXN+5];\nint first[MAXN+5], fa[MAXN+5], dep[MAXN+5], sz[MAXN+5], heavy[MAXN+5], pos[MAXN+5], top[MAXN+5], tot, n, dfn = 1, N;\nchar s[10];\ninline void Add(int a, int b)\n{\n    e[tot] = Edge(b,first[a]);\n    first[a] = tot++;\n    return;\n}\nvoid DFS1(int p)\n{\n    sz[p] = 1;\n    for(register int u = first[p], v; u+1; u = e[u].nex)\n        if((v=e[u].to) != fa[p])\n        {\n            fa[v] = p, dep[v] = dep[p]+1, DFS1(v), sz[p] += sz[v];\n            if(!heavy[p] || sz[v] > sz[heavy[p]])\n                heavy[p] = v;\n        }\n    return;\n}\nvoid DFS2(int p)\n{\n    pos[p] = dfn++;\n    if(heavy[p])\n        top[heavy[p]] = top[p], DFS2(heavy[p]);\n    for(register int u = first[p], v; u+1; u = e[u].nex)\n        if((v=e[u].to) != fa[p] && v != heavy[p])\n            top[v] = v, DFS2(v);\n}\nstruct Node\n{\n    int mx,sm;\n    Node()\n    {\n        sm = 0, mx = -INF;\n    }\n}t[(1<<16)+MAXN+5], ans;\ninline Node Merge(Node a, Node b)\n{\n    a.sm += b.sm, a.mx = max(a.mx,b.mx);\n    return a;\n}\ninline void Push(int p)\n{\n    mx(p) = max(mx(lc(p)),mx(rc(p))), sm(p) = sm(lc(p))+sm(rc(p));\n    return;\n}\nNode Query(int p, int lef, int rig, int L, int R)\n{\n    if(L == lef && R == rig)\n        return t[p];\n    if(R <= mid)\n        return Query(lc(p),lef,mid,L,R);\n    if(L >  mid)\n        return Query(rc(p),mid+1,rig,L,R);\n    return Merge( Query(lc(p),lef,mid,L,mid) , Query(rc(p),mid+1,rig,mid+1,R) );\n}\ninline void Edit(int x, int v)\n{\n    for(x += N-1, mx(x) = sm(x) = v, x >>= 1; x; Push(x), x >>= 1);\n    return;\n}\ninline void Q(int a, int b)\n{\n    for(ans.sm = 0, ans.mx = -INF; top[a] != top[b]; )\n    {\n        if(dep[top[a]] < dep[top[b]])\n            a^=b^=a^=b;\n        ans = Merge(ans,Query(1,1,N,pos[top[a]],pos[a])), a = fa[top[a]];\n    }\n    if(dep[a] < dep[b])\n        a^=b^=a^=b;\n    ans = Merge(ans,Query(1,1,N,pos[b],pos[a]));\n    return;\n}\nint main()\n{\n    for(n = read(), memset(first,-1,sizeof(first)), N = 1; N < n; N <<= 1);\n    for(register int i = 2, a, b; i <= n; i++)\n        a = read(), b = read(), Add(a,b), Add(b,a);\n    fa[1] = 0, dep[1] = 1, top[1] = 1, sz[1] = 1, DFS1(1), DFS2(1);\n    for(register int i = 1; i <= n; i++)\n        mx(pos[i]+N-1) = sm(pos[i]+N-1) = read();\n    for(register int i = N-1; i >= 1; Push(i), i--);\n    for(register int m = read(), a, b; m--; )\n        switch(scanf(\"%s\",s), a = read(), b = read(), s[1])\n        {\n            case 'M' :    Q(a,b), printf(\"%d\\n\",ans.mx);    break;\n            case 'S' :    Q(a,b), printf(\"%d\\n\",ans.sm);    break;\n            case 'H' :    Edit(pos[a],b);                    break;\n        }\n    return 0;\n}\n```",
        "postTime": 1485784347,
        "uid": 16528,
        "name": "magolor",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u6761\u94fe\u3002\n\n```cpp\n\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#define N 30001\n\nusing namespace std;\n\nstruct node{int l,r,ls,rs,s,c;}tr[2*N];int t=0;\nint nw(int l,int r){tr[++t]=(node){l,r,0,0,0,0};return t;}\nvoid xg(int o,int p,int c){\n    if(tr[o].l==tr[o].r){tr[o].s=tr[o].c=c;return;}\n    int mid=(tr[o].l+tr[o].r)>>1;\n    if(p<=mid)xg(tr[o].ls?tr[o].ls:tr[o].ls=nw(tr[o].l,mid),p,c);\n    else xg(tr[o].rs?tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r),p,c);\n    tr[o].s=tr[tr[o].ls].s+tr[tr[o].rs].s;\n    tr[o].c=max(tr[tr[o].ls].c,tr[tr[o].rs].c);}\nint cxm(int o,int l,int r){\n    if(tr[o].l==l&&tr[o].r==r)return tr[o].c;\n    int mid=(tr[o].l+tr[o].r)>>1;\n    if(l>mid)return cxm(tr[o].rs,l,r);\n    if(r<=mid)return cxm(tr[o].ls,l,r);\n    return max(cxm(tr[o].ls,l,mid),cxm(tr[o].rs,mid+1,r));}\nint cxs(int o,int l,int r){\n    if(tr[o].l==l&&tr[o].r==r)return tr[o].s;\n    int mid=(tr[o].l+tr[o].r)>>1;\n    if(l>mid)return cxs(tr[o].rs,l,r);\n    if(r<=mid)return cxs(tr[o].ls,l,r);\n    return cxs(tr[o].ls,l,mid)+cxs(tr[o].rs,mid+1,r);}\n\nint n,q;\nint f[N],c[N],s[N],d[N],p[N],hd[N];\nvector<int>g[N];\nvoid slpf(){\n    for(s[d[s[0]=1]=1]=1;s[0];){\n        int u=s[s[0]];if(c[u]==g[u].size()){c[u]=1;s[0]--;\n            for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u])c[u]+=c[g[u][i]];}\n        for(int& i=c[u];i<g[u].size();i++)if(g[u][i]^f[u]){\n            d[s[++s[0]]=g[u][i]]=d[f[g[u][i]]=u]+1;i++;break;}\n    }\n    for(s[s[0]=1]=1;s[0];){\n        int u=s[s[0]--],y=0;p[u]=++p[0];if(!hd[u])hd[u]=u;\n        for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u]&&c[g[u][i]]>c[y])y=g[u][i];\n        for(int i=0;i<g[u].size();i++)if(g[u][i]^f[u]&&g[u][i]^y)s[++s[0]]=g[u][i];\n        if(!y)continue;s[++s[0]]=y;hd[y]=hd[u];\n    }\n}\n\nint main(){\n    cin>>n;nw(1,n);tr[0].c=-2e9;\n    for(int i=1;i<n;i++){\n        int x,y;scanf(\"%d%d\",&x,&y);\n        g[x].push_back(y);g[y].push_back(x);\n    }\n    slpf();for(int i=1;i<=n;i++)scanf(\"%d\",&q),xg(1,p[i],q);\n    for(cin>>q;q--;){\n        char s[7];int x,y;scanf(\"%s%d%d\",s,&x,&y);\n        if(s[1]=='H')xg(1,p[x],y);\n        if(s[1]=='M'){\n            int ans=-2e9;\n            while(hd[x]!=hd[y]){\n                if(d[hd[x]]<d[hd[y]])swap(x,y);\n                ans=max(ans,cxm(1,p[hd[x]],p[x]));\n                x=f[hd[x]];\n            }\n            ans=max(ans,cxm(1,min(p[x],p[y]),max(p[x],p[y])));\n            printf(\"%d\\n\",ans);\n        }\n        if(s[1]=='S'){\n            int ans=0;\n            while(hd[x]!=hd[y]){\n                if(d[hd[x]]<d[hd[y]])swap(x,y);\n                ans+=cxs(1,p[hd[x]],p[x]);\n                x=f[hd[x]];\n            }\n            ans+=cxs(1,min(p[x],p[y]),max(p[x],p[y]));\n            printf(\"%d\\n\",ans);\n        }\n    }\n}\n\n```",
        "postTime": 1444028430,
        "uid": 6750,
        "name": "lezdzh",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    },
    {
        "content": "\u8fd9\u9898\u601d\u8def\u5176\u5b9e\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u78e8\u53fd\u4e00\u70b9\u3002\n\n\u9996\u5148\u6811\u94fe\u5256\u5206\uff0c\u5728dfs\u5e8f\uff0c\u6ce8\u610f\u5c06\u91cd\u94fe\u7684\u70b9\u8fde\u5728\u4e00\u8d77\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\n\n\u522b\u5fd8\u4e86\u5f00long long\uff01\n\n\u6ce8\u610f\u4e00\u4e0b\uff0c\u9898\u76ee\u4e2d\u6709\u53ef\u80fd\u51fa\u73b0\u8d1f\u503c\uff0c\u6545ans\u8d1f\u503c\u4e3a\u8d1f\u65e0\u7a77\u3002\n\n\u800cans\u5927\u5c0f\u4e3along long,\u5e94\u8be5\u51990xefefefefefefefef\u6211\u5f53\u65f6\u51990xefefefef\u72c2WA\u3002T_T\n\n\u770b\u4ee3\u7801\u5427\uff1a\n\n```\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 30004\nusing namespace std;\ntypedef long long ll;\nchar opt[21];\nint n,T,fir[N],sec[N],tot,low[N],fa[N],siz[N];\nint to[N<<1],nxt[N<<1],head[N],cnt,sn[N],tp[N];\nll ml[N<<2],vl[N<<2],a[N];\n\nvoid add(int x,int y)\n{\n    to[++cnt]=y,nxt[cnt]=head[x],head[x]=cnt;\n}\n\nvoid dfs1(int now,int pre)\n{\n    low[now]=low[pre]+1,fa[now]=pre,siz[now]=1;\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=pre)\n        {\n            dfs1(y,now);\n            siz[now]+=siz[y];\n            if(siz[y]>siz[sn[now]])\n            {\n                sn[now]=y;\n            }\n        }\n    }\n}\n\nvoid dfs2(int now,int tpo)\n{\n    tp[now]=tpo;\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=fa[now])\n        {\n            if(y==sn[now])\n            {\n                dfs2(y,tpo);\n            }else\n            {\n                dfs2(y,y);\n            }\n        }\n    }\n}\n\nvoid dfs3(int now)\n{\n    fir[now]=++tot;\n    if(sn[now])\n    {\n        dfs3(sn[now]);\n    }\n    for(int i=head[now];i;i=nxt[i])\n    {\n        int y=to[i];\n        if(y!=fa[now]&&y!=sn[now])\n        {\n            dfs3(y);\n        }\n    }\n    sec[now]=tot;\n}\n\nvoid build(int lx,int rx,int nx)\n{\n    if(lx==rx)\n    {\n        ml[nx]=vl[nx]=a[lx];\n        return;\n    }\n    int mid=(lx+rx)>>1;\n    build(lx,mid,nx<<1);\n    build(mid+1,rx,(nx<<1)|1);\n    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);\n}\n\nvoid update(int to,ll aim,int lx,int rx,int nx)\n{\n    if(lx==rx)\n    {\n        vl[nx]=ml[nx]=aim;\n        return;\n    }\n    int mid=(lx+rx)>>1;\n    if(to<=mid)\n    {\n        update(to,aim,lx,mid,nx<<1);\n    }else\n    {\n        update(to,aim,mid+1,rx,(nx<<1)|1);\n    }\n    vl[nx]=vl[nx<<1]+vl[(nx<<1)|1],ml[nx]=max(ml[nx<<1],ml[(nx<<1)|1]);\n}\n\nll query(int ord,int lm,int rm,int lx,int rx,int nx)\n{\n    if(lm<=lx&&rm>=rx)\n    {\n    \tif(ord)\n    \t{\n        \treturn vl[nx];\n        }else\n        {\n        \treturn ml[nx];\n        }\n    }\n    int mid=(lx+rx)>>1;\n    ll ret=0;\n    if(!ord)\n    {\n        ret=0xefefefefefefefef;\n    }\n    if(lm<=mid)\n    {\n    \tif(ord)\n    \t{\n        \tret+=query(ord,lm,rm,lx,mid,nx<<1);\n        }else\n        {\n    \t\tret=max(ret,query(ord,lm,rm,lx,mid,nx<<1));\n    \t}\n    }\n    if(rm>mid)\n    {\n    \tif(ord)\n    \t{\n    \t\tret+=query(ord,lm,rm,mid+1,rx,(nx<<1)|1);\n        }else\n        {\n        \tret=max(ret,query(ord,lm,rm,mid+1,rx,(nx<<1)|1));\n        }\n    }\n    return ret;\n}\n\nvoid solve(int ord,int x,int y)\n{\n    ll ans=0;\n    if(!ord)\n    {\n        ans=0xefefefefefefefef;\n    }\n    while(tp[x]!=tp[y])\n    {\n        if(low[tp[x]]<low[tp[y]])\n        {\n            swap(x,y);\n        }\n        if(ord)\n        {\n            ans+=query(ord,fir[tp[x]],fir[x],1,n,1);\n        }else\n        {\n            ans=max(ans,query(ord,fir[tp[x]],fir[x],1,n,1));\n        }\n        x=fa[tp[x]];\n    }\n    if(low[x]<low[y])\n    {\n        swap(x,y);\n    }\n    if(ord)\n    {\n        ans+=query(ord,fir[y],fir[x],1,n,1);\n    }else\n    {\n        ans=max(ans,query(ord,fir[y],fir[x],1,n,1));\n    }\n    printf(\"%lld\\n\",ans);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1,ui,vi;i<n;i++)\n    {\n        scanf(\"%d%d\",&ui,&vi);\n        add(ui,vi);\n        add(vi,ui);\n    }\n    dfs1(1,0);\n    dfs2(1,1);\n    dfs3(1);\n    for(int i=1;i<=n;i++)\n    {\n    \tscanf(\"%lld\",&a[fir[i]]);\n    }\n    build(1,n,1);\n    scanf(\"%d\",&T);\n    while(T--)\n    {\n        scanf(\"%s\",opt);\n        if(opt[0]=='C')\n        {\n            int to;\n            ll aim;\n            scanf(\"%d%lld\",&to,&aim);\n            update(fir[to],aim,1,n,1);\n        }else\n        {\n    \t\tint xi,yi;\n    \t\tscanf(\"%d%d\",&xi,&yi);\n        \tif(opt[1]=='S')\n        \t{\n            \tsolve(1,xi,yi);\n            }else\n            {\n        \t\tsolve(0,xi,yi);\n        \t}\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1524739402,
        "uid": 51082,
        "name": "\u7b11\u7ec6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2590 \u3010[ZJOI2008]\u6811\u7684\u7edf\u8ba1\u3011"
    }
]