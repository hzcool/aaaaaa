[
    {
        "content": "\u8fd9\u9053\u9898\u8c8c\u4f3c\u5f88\u591a\u4eba\u7528\u7684\u662f\u7f51\u7edc\u6d41+\u5206\u5c42\u56fe\u3002\u8fd9\u91cc\u4ecb\u7ecd\u4e00\u79cd\u8d39\u7528\u6d41\u89e3\u6cd5\u3002\n\n\u53ef\u4ee5\u8bc1\u660e\uff0c\u6700\u540e\u4e00\u4e2a\u4eba\u5230\u8fbe\u7684\u65f6\u95f4\u662f\u5c0f\u4e8e\u7b2c100\u5929\u7684\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u8d9f\u822a\u73ed\uff0c\u5982\u679c\u4ed6\u7684\u8d77\u70b9\u662f$u$\uff0c\u7ec8\u70b9\u4e3a$v$\uff0c\u53ef\u642d\u4e58\u7684\u4eba\u7684\u6570\u91cf\u4e3a$w$\u3002\u90a3\u6211\u4eec\u5c31\u5bf9$(u,v)$\u8fde100\u6761\u6d41\u91cf\u4e3a$w$,\u8d39\u7528\u4e3a$i$\u7684\u8fb9\uff08$i$\u8868\u793a\u7b2c\u51e0\u5929\uff09\uff0c\u5206\u522b\u8868\u793a\u7b2c$i$\u5929\u7684\u822a\u73ed\u3002\n\n\u6211\u4eec\u8dd1\u8d39\u7528\u6d41\u65f6\uff0c\u4e5f\u4e0d\u662f\u8ba1\u7b97\u6700\u77ed\u8ddd\u79bb\uff0c\u800c\u662f\u627e\u5230\u8d77\u70b9\u5230\u7ec8\u70b9\u7684\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u4e00\u6761\u8d39\u7528\u6700\u5927\u7684\u8fb9\u7684\u6700\u5c0f\u503c\u3002\n\n\u6bd4\u5982\n\n![1.PNG](https://i.loli.net/2019/10/22/CDAfuEbINWJkQTw.png)\n\n\u6211\u4eec\u8981\u7684\u8def\u5f84\u662f$A \\to C \\to D$,\u56e0\u4e3a$max(AC,CD)<max(AB,BD)$\n\n\u8dd1\u4e00\u4e2a\u6d41\u91cf\u4e3a$t$\u7684\u8d39\u7528\u6d41\u5373\u53ef\u3002\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <cstring>\nusing namespace std;\n#define INF 0x3f3f3f3f\n\nconst int MAXN = 5005;\nint flow , cost;\nint n , m , u , v , w , f;\nstruct node{\n\tint v , w , f , rev;\n};\nvector< node > Graph[ MAXN + 5 ];\n\nint dis[ MAXN + 5 ] , vis[ MAXN + 5 ];\nint prevv[ MAXN + 5 ] , preve[ MAXN + 5 ];\nvoid spfa( int s , int t ) {\n\tqueue< int > Que;\n\tmemset( dis , 0x3f , sizeof( dis ) );\n\tmemset( vis , 0 , sizeof( vis ) );\n\n\tdis[ s ] = 0 , vis[ s ] = 1 , Que.push( s );\n\twhile( !Que.empty( ) ) {\n\t\tint u = Que.front( );\n\t\tQue.pop( ) , vis[ u ] = 0;\n\n\t\tfor( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {\n\t\t\tint v = Graph[ u ][ i ].v , w = Graph[ u ][ i ].w;\n\t\t\tif( w <= dis[ u ] ) continue;\t//\u4fdd\u8bc1\u4e00\u5929\u53ea\u5750\u4e00\u73ed\u98de\u673a\n\t\t\tif( Graph[ u ][ i ].f && dis[ v ] > max( dis[ u ] , w ) ) {\n\t\t\t\tdis[ v ] = max( dis[ u ] , w );\n\t\t\t\tprevv[ v ] = u , preve[ v ] = i;\n\t\t\t\tif( !vis[ v ] )\n\t\t\t\t\tQue.push( v ) , vis[ v ] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Costflow( int S , int T ) {\n\twhile( 1 ) {\n\t\tspfa( S , T );\n\t\tif( !flow || dis[ T ] == INF ) return;\n\t\t\n\t\tint d = INF;\n\t\tfor( int v = T ; v != S ; v = prevv[ v ] )\n\t\t\td = min( d , Graph[ prevv[ v ] ][ preve[ v ] ].f );\n\t\tflow -= d , cost = max( cost , dis[ T ] );\n\t\tfor( int v = T ; v != S ; v = prevv[ v ] ) {\n\t\t\tGraph[ prevv[ v ] ][ preve[ v ] ].f -=d;\n\t\t\tGraph[ v ][ Graph[ prevv[ v ] ][ preve[ v ] ].rev ].f += d;\n\t\t}\n\t}\n}\n\nint main( ) {\n\tscanf(\"%d %d %d\",&n,&m,&flow);\n\tfor( int i = 1 ; i <= m ; i ++ ) {\n\t\tscanf(\"%d %d %d\",&u,&v,&f);\n\t\tfor( int j = 1 ; j <= 105 ; j ++ ) {\n\t\t\tw = j;\n\t\t\tGraph[ u ].push_back( { v , w , f , Graph[ v ].size( ) } );\n\t\t\tGraph[ v ].push_back( { u , -w , 0 , Graph[ u ].size( ) - 1 } );\n\t\t}\n\t}\n\tCostflow( 1 , n );\n\tprintf(\"%d\\n\",cost);\n\treturn 0;\n}\n```\n\nUpdate: 2021.1.5\n\n\u6df1\u6df1\u7684\u4f53\u4f1a\u5230 1 \u5e74\u524d\u7684\u81ea\u5df1\u592a\u83dc\u4e86\u3002\n\n\u8003\u8651\u8fd9\u9053\u9898\u7684\u52a0\u5f3a\u7248\uff1a[BZOJ4669 \u62a2\u593a](https://darkbzoj.tk/problem/4669)\n\n\u552f\u4e00\u4e0d\u540c\u7684\u662f\uff0c\u8fd9\u9053\u9898\u7684\u4eba\u6570\u5f88\u5927\uff0c\u6240\u4ee5\u4e0d\u80fd\u5efa\u5206\u5c42\u56fe\u3002\n\n\u6709\u4e24\u4e2a\u663e\u7136\u7684\u7ed3\u8bba\uff1a\n\n- \u6bcf\u5929\u53ef\u4ee5\u65b0\u5230\u8fbe\u7684\u4eba\u6570\u4e00\u5b9a\u4e0d\u964d\n\n- \u540e\u9762\u7684\u4eba\u53ef\u4ee5\u8ddf\u7740\u524d\u9762\u7684\u4eba\u8d70\uff0c\u65f6\u95f4\u76f8\u5dee 1 \u5929\n\n\u4f46\u662f\u53ef\u80fd\u8fc7\u7a0b\u4e2d\u5b58\u5728\u4e00\u6761\u65b0\u7684\u6700\u77ed\u8def\uff0c\u8ba9\u8fd9\u4e9b\u8ddf\u522b\u4eba\u8d70\u7684\u4eba\uff0c\u901a\u8fc7\u65b0\u7684\u6700\u77ed\u8def\u5230\u8fbe\u7ec8\u70b9\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u6709 1 \u5929\u7684\u65f6\u5dee\u4e86\u3002\n\n\u6240\u4ee5\u6bcf\u6b21\u589e\u5e7f\u540e\u901a\u8fc7\u65f6\u95f4\u5dee\u503c\u5224\u65ad\u901a\u8fc7\u4eba\u6570\uff0c\u65e0\u589e\u5e7f\u8def\u4e4b\u540e\u7528\u6700\u5927\u6d41\u8ba1\u7b97\u3002\n\n\u4e3a\u4e86\u4fdd\u8bc1\u5c3d\u91cf\u5c11\u7684\u65f6\u95f4\u901a\u8fc7\u7684\u4eba\u6570\u591a\uff0c\u7528\u8d39\u7528\u6d41\u589e\u5e7f\u3002\n\n\u8fd9\u6837\u505a\u5c31\u4e0d\u9700\u8981\u4e8c\u5206\u4e86\u3002\n\n~~\u5982\u679c\u4f60\u6ca1\u6709\u53d1\u73b0\u5b83\u662f\u591a\u6d4b\uff0c\u5c31\u4f1a\u50cf\u6211\u4e00\u6837\u7206\u96f6\u3002~~\n\n```cpp\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#define Inf 0x3f3f3f3f\n\nconst int MAXN = 1000 , MAXM = 5000;\nint head[ MAXN + 5 ] , Enum = 1;\nstruct Edge {\n\tint v , nxt , flw , w;\n\tEdge(){}\n\tEdge( int V , int Nxt , int Flw , int W ) { v = V , nxt = Nxt , flw = Flw , w = W; }\n} Graph[ 2 * MAXM + 5 ];\nvoid Add_Edge( int u , int v , int flw , int c ) {\n\tGraph[ ++ Enum ] = Edge( v , head[ u ] , flw ,  c ); head[ u ] = Enum;\n\tGraph[ ++ Enum ] = Edge( u , head[ v ] , 0   , -c ); head[ v ] = Enum;\n}\n\nint dis[ MAXN + 5 ]; bool inq[ MAXN + 5 ];\nint cur[ MAXN + 5 ]; bool vis[ MAXN + 5 ];\nbool Spfa( int s , int t ) {\n\tqueue< int > Que;\n\tmemset( dis , 0x3f , sizeof( dis ) );\n\tmemset( inq , 0 , sizeof( inq ) );\n\tmemset( vis , 0 , sizeof( vis ) );\n\tmemcpy( cur , head , sizeof( head ) );\n\tdis[ s ] = 0; Que.push( s ) , inq[ s ] = 1;\n\twhile( !Que.empty() ) {\n\t\tint u = Que.front();  Que.pop() , inq[ u ] = 0;\n\t\tfor( int i = head[ u ] ; i ; i = Graph[ i ].nxt ) {\n\t\t\tint v = Graph[ i ].v , flw = Graph[ i ].flw , w = Graph[ i ].w;\n\t\t\tif( flw && dis[ v ] > dis[ u ] + w ) {\n\t\t\t\tdis[ v ] = dis[ u ] + w;\n\t\t\t\tif( !inq[ v ] ) Que.push( v ) , inq[ v ] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[ t ] != Inf;\n}\nint dfs( int u , int t , int f ) {\n\tif( u == t ) return f; vis[ u ] = 1;\n\tfor( int &i = cur[ u ] ; i ; i = Graph[ i ].nxt ) {\n\t\tint v = Graph[ i ].v , flw = Graph[ i ].flw , w = Graph[ i ].w;\n\t\tif( flw && dis[ v ] == dis[ u ] + w && !vis[ v ] ) {\n\t\t\tint mf = dfs( v , t , min( f , flw ) );\n\t\t\tif( mf ) {\n\t\t\t\tGraph[ i ].flw -= mf , Graph[ i ^ 1 ].flw += mf;\n\t\t\t\treturn mf;\n\t\t\t}\n\t\t}\n\t} dis[ u ] = Inf;\n\treturn 0;\n}\n\nint n , m , k , s , t;\nint main( ) {\n    // freopen(\"snatch.in\",\"r\",stdin);\n    // freopen(\"snatch.out\",\"w\",stdout);\n\n    while( ~scanf(\"%d %d %d\",&n,&m,&k) ) {\n        memset( head , 0 , sizeof( head ) ); Enum = 1;\n\n        s = 1 , t = n;\n        for( int i = 1 , u , v , c ; i <= m ; i ++ ) {\n            scanf(\"%d %d %d\",&u,&v,&c);\n            Add_Edge( u , v , c , 1 );\n        }\n\n        if( k == 0 ) { printf(\"0\\n\"); }\n        else {\n            int Maxf = 0 , last = 0;\n            for( ; Spfa( s , t ) ; last = dis[ t ] ) {\n                int nowf = 0; for( int fl = 0 ; ( fl = dfs( s , t , Inf ) ) != 0 ; nowf += fl );\n\n                if( k <= ( dis[ t ] - last ) * Maxf ) { \n                    printf(\"%d\\n\", last - 1 + (int)ceil( k * 1.0 / Maxf ) ) & 0;\n                    goto there;\n                }\n\n                k -= ( dis[ t ] - last ) * Maxf;\n                Maxf += nowf;\n            }\n            if( last == 0 ) { puts( \"No solution\" ); goto there; }\n            printf(\"%d\\n\", last - 1 + (int)ceil( k * 1.0 / Maxf ) ) & 0;\n        }\n        there:;\n    }\n    return 0;\n}\n```",
        "postTime": 1571748791,
        "uid": 123802,
        "name": "chihik",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4400 \u3010[JSOI2008]Blue Mary\u7684\u65c5\u884c\u3011"
    },
    {
        "content": "\u5bf9\u4e8e\u539f\u9898\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\u662f\u4e00\u4e2a\u7f51\u7edc\u6d41\u6a21\u578b\uff0c\u770b\u5230\u8fd9\u4e2a\u6700\u5927\u503c\u6700\u5c0f\uff0c\u6211\u4eec\u80fd\u591f\u60f3\u5230\u4e8c\u5206\u3002\u7136\u540e\u5462\uff0c\u6211\u4eec\u8fd8\u8981\u8003\u8651\u5230\u8fd9\u4e2a\u9650\u5236\u6761\u4ef6\uff0d\uff0d\u6bcf\u5929\u53ea\u80fd\u8d70\u4e00\u6b65\u3002\u90a3\u4e48\u5176\u5b9e\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u5929\u5206\u5c42\u5c31\u53ef\u4ee5\u4e86\uff0c\u4e0a\u4e00\u5929\u7684\u70b9\u5411\u4e0b\u4e00\u6761\u8fb9\u7684\u70b9\u8fde\u8fb9\uff0c\u5206\u6210\u82e5\u5e72\u5929\u5c42\uff0c\u5982\u679c\u5728\u5206\u5c42\u56fe\u4e0b\u6700\u5927\u6d41\u80fd\u8dd1\u51fa\uff54\u4e2a\u4eba\uff0c\u4e5f\u5c31\u6ee1\u8db3\u4e86\u9898\u610f\u3002\n\n\u518d\u4e00\u6df1\u601d,\u6211\u4eec\u53d1\u73b0\uff0c\u5176\u5b9e\u4e8c\u5206\u5f88\u9ebb\u70e6\uff0c\u6bcf\u6b21\u8fb9\u90fd\u8981\u91cd\u6784\u4e00\u4e0b\uff0c\u539f\u6765\u8dd1\u51fa\u6765\u7684\u4fe1\u606f\u90fd\u4e0d\u80fd\u4fdd\u7559\u3002\u90a3\u4e48\u6211\u4eec\u8fed\u4ee3\u52a0\u6df1\u7684\u6bcf\u6b21\u65b0\u5efa\u56fe\uff0c\u518d\u8dd1\u6700\u5927\u6d41\u5c31\u53ef\u4ee5\u4e86\u3002\n\n[\u6b22\u8fce\u6765Newuser\u5c0f\u7ad9van!](http://www.newuser.top/2018/12/26/%E3%80%90jsoi2008blue-mary%E7%9A%84%E6%97%85%E8%A1%8C%E3%80%91%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%B5%81/)\n\nisap code:\n```cpp\n#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\nconst int maxm = 500005;\nint en[maxm],nt[maxm],la[maxm],owo=1,v[maxm];\nvoid adg(int x,int y,int z) {\n\ten[++owo]=y; nt[owo]=la[x]; la[x]=owo; v[owo]=z;\n\ten[++owo]=x; nt[owo]=la[y]; la[y]=owo; v[owo]=0;\n}\nint tot;\nint n,m,t,S,T;\nint X[2555],Y[2555],Z[2555];\nint dis[maxm],cnt[maxm];\nint sap(int x,int flow) {\n\tif(x==T) return flow;\n\tint dlt = 0;\n\tfor(int it=la[x];it;it=nt[it]) {\n\t\tint y = en[it];\n\t\tif(v[it]&&dis[y]+1==dis[x]) {\n\t\t\tint tmp = sap(y,min(flow-dlt,v[it]));\n\t\t\tv[it]-=tmp; v[it^1]+=tmp;\n\t\t\tdlt +=tmp;\n\t\t\tif(dlt==flow||dis[S]>=tot) return dlt;\n\t\t}\n\t}\n\tcnt[dis[x]]--;\n\tif(cnt[dis[x]]==0) dis[S] = tot;\n\tdis[x]++;\n\tcnt[dis[x]]++;\n\treturn dlt;\n}\nint getmaxflow() {\n\tfor(int i=0;i<=tot;i++) cnt[i]=dis[i]=0;\n\tint sm = 0;\n\twhile(dis[S]<tot) sm+=sap(S,0x3f3f3f3f);\n\treturn sm;\n}\nint DY[205][105];\nint main() {\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\tS = ++tot; T = ++tot;\n\tfor(int i=1;i<=m;i++) {\n\t\tscanf(\"%d%d%d\",&X[i],&Y[i],&Z[i]);\t\n\t}\n\tfor(int i=1;i<=n;i++) DY[0][i] = ++tot;\n\tadg(S,DY[0][1],t);\n\tadg(DY[0][n],T,t);\n\tint flow = 0;\n\tfor(int tim=1;;tim++) {\n\t\tfor(int i=1;i<=n;i++) DY[tim][i] = ++tot,adg(DY[tim-1][i],tot,0x3f3f3f3f);\n\t\tfor(int i=1;i<=m;i++) {\n\t\t\tadg(DY[tim-1][X[i]],DY[tim][Y[i]],Z[i]);\n\t\t}\n\t\tadg(DY[tim][n],T,t);\n\t\tflow += getmaxflow();\n\t\tif(flow==t) {\n\t\t\tprintf(\"%d\",tim);\n\t\t\texit(0);\n\t\t}\n\t}\n}\n```",
        "postTime": 1545839553,
        "uid": 55343,
        "name": "Newuser",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4400 \u3010[JSOI2008]Blue Mary\u7684\u65c5\u884c\u3011"
    },
    {
        "content": "[\u6d1b\u8c37\u94fe\u63a5](https://www.luogu.com.cn/problem/P4400)\n\n\u8fd9\u662f\u4e00\u9053\u5f88\u6709\u610f\u601d\u7684\u9898\u76ee\u3002\n\n\u7ecf\u8fc7\u4e00\u756a\u5316\u7b80\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u9898\u76ee\u7406\u89e3\u4e3a\u6c42\u5f97\u6700\u5c11\u4f7f\u6240\u6709\u4eba\u90fd\u5230\u8fbe\u7684\u6700\u5c11\u65f6\u95f4\u4e3a $day$ \uff0c\u540c\u65f6\u5bf9\u4e8e\u8fd9\u4e2a\u65f6\u95f4\u6211\u4eec\u627e\u5230\u4e86\u82e5\u5e72\u6761\u4e0d\u51b2\u7a81\u7684\u65b9\u6848 $dis_i$ \u548c $p_i$ \u8868\u793a\u8def\u5f84\u7684\u957f\u5ea6\u548c\u4e00\u6279\u6709\u591a\u5c11\u4eba\u5230\u8fbe\uff0c\u4f7f\u5f97\u5176\u6ee1\u8db3\uff1a\n\n$$\nk \\le \\sum (k - dis_i + 1) \\times p_i\n$$\n\n\u5316\u7b80\u53ef\u5f97\uff1a\n\n$$\nk + \\sum dis_i \\times p_i \\le k \\times \\sum p_i\n$$\n\n\u56e0\u6b64\u6211\u4eec\u53ea\u8981\u6c42\u5f97\u4e86 $\\sum p_i$ \u548c $\\sum dis_i \\times p_i$ \u5c31\u53ef\u4ee5\u5feb\u901f\u6c42\u5f97\u7b54\u6848\u3002\n\n\u6211\u4eec\u53d1\u73b0\u4ed6\u7684\u5355\u4f4d\u65f6\u95f4\u5185\u7684\u9650\u5236\u4e0e\u7f51\u7edc\u6d41\u7684\u6d41\u91cf\u9650\u5236\u5f88\u50cf\uff0c\u540c\u65f6 $\\sum dis_i \\times p_i$ \u53c8\u548c\u8d39\u7528\u6d41\u7684\u8d39\u7528\u8ba1\u7b97\u5f88\u50cf\uff0c\u56e0\u6b64\u6211\u4eec\u8003\u8651\u4f7f\u7528\u8d39\u7528\u6d41\u8f85\u52a9\u3002\u4f46\u662f\u7531\u4e8e\u603b\u6d41\u91cf\u4e0d\u786e\u5b9a\uff0c\u6211\u4eec\u8003\u8651\u679a\u4e3e\u603b\u6d41\u91cf\u3002\u5bb9\u6613\u53d1\u73b0\uff0c\u5728\u524d\u671f\u8d39\u7528\u589e\u957f\u6bd4\u8f83\u7f13\u6162\uff0c\u800c\u540e\u671f\u53d8\u5316\u91cf\u8f83\u5927\uff0c\u56e0\u6b64\u8fd9\u662f\u4e00\u4e2a\u5355\u5cf0\u51fd\u6570\uff0c\u53ef\u4ee5\u4e09\u5206\u3002\n\n\u6ce8\u610f\uff0c\u5728\u4e09\u5206\u65f6\uff0c\u6211\u4eec\u8981\u628a\u5929\u6570\u4ee5\u6d6e\u70b9\u6570\u5f62\u5f0f\u6bd4\u8f83\uff0c\u4ee5\u9632\u6b62\u5728\u5411\u4e0a\u53bb\u6574\u540e\u5e73\u53f0\u7684\u51fa\u73b0\u5bf9\u6b63\u786e\u6027\u7684\u5f71\u54cd\u3002\uff08~~\u867d\u7136\u6ca1\u6709\u4efb\u4f55\u4e00\u4e2a\u6570\u636e\u5361\u4e86\u8fd9\u4e00\u70b9~~\uff09\n\n\u5f97\u5230\u5982\u4e0b\u4ee3\u7801\uff1a\n\n```cpp\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\ntemplate <typename T>\nvoid read(T &x) {\n\tT f=1;x=0;char s=getchar();\n\twhile(s<'0'||s>'9') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=(x<<3)+(x<<1)+(s^'0');s=getchar();}\n\tx *= f;\n}\n\nconst int MAXN = 1e5 + 5;\nconst int MAXM = 1e5 + 5;\nconst LL inf = 1e15;\n\nint head[MAXN] , to[MAXM << 1] , nxt[MAXM << 1] , cnt = 1;\nLL edge[MAXM << 1] , val[MAXM << 1];\nvoid add(int u , int v , LL c , LL w) {\n\tnxt[++cnt] = head[u];head[u] = cnt;to[cnt] = v;edge[cnt] = c;val[cnt] = w;\n\tnxt[++cnt] = head[v];head[v] = cnt;to[cnt] = u;edge[cnt] = 0;val[cnt] = -w;\n}\n\nint las[MAXN] , pre[MAXN] , num , s , t , vis[MAXN];\nLL dis[MAXN] , flow[MAXN];\n\nstruct MinCostMaxFlow {\n\tLL MaxFlow , MinCost;\n\tbool bfs() {\n\t\tfor (int i = 1; i <= num; ++i) las[i] = 0 , dis[i] = inf , pre[i] = 0 , flow[i] = 0 , vis[i] = 0;\n\t\tflow[s] = inf , dis[s] = 0;\n\t\tqueue <int> q;q.push(s);\n\t\tint flag = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tvis[x] = 0;\n\t\t\tfor (int i = head[x]; i; i = nxt[i]) {\n\t\t\t\tif(!edge[i]) continue;\n\t\t\t\tint v = to[i];\n\t\t\t\tif(dis[v] > dis[x] + val[i]) {\n\t\t\t\t\tdis[v] = dis[x] + val[i];\n\t\t\t\t\tflow[v] = min(flow[x] , edge[i]);\n\t\t\t\t\tpre[v] = x;\n\t\t\t\t\tlas[v] = i;\n\t\t\t\t\tif(v == t) {\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(!vis[v]) vis[v] = 1 , q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t\treturn flag;\n\t}\n\tvoid MVMC() {\n\t\tMaxFlow = 0 , MinCost = 0;\n\t\twhile(bfs()) {\n\t\t\tint now = t;\n\t\t\tMaxFlow += flow[t];\n\t\t\tMinCost += dis[t] * flow[t];\n\t\t\twhile(now != s) {\n\t\t\t\tedge[las[now]] -= flow[t];\n\t\t\t\tedge[las[now] ^ 1] += flow[t];\n\t\t\t\tnow = pre[now];\n\t\t\t}\n\t\t}\n\t} \n}MIN;\n\nint n , m , k;\n\ndouble cal(int x) {\n\tfor (int i = 2; i <= cnt; i += 2) edge[i] += edge[i ^ 1] , edge[i ^ 1] = 0;\n\tedge[cnt - 1] = x;\n\tMIN.MVMC();\n\treturn (k + MIN.MinCost) * 1.0 / MIN.MaxFlow;\n}\n\nint main() {\n//\tfreopen(\"snatch.in\" , \"r\" , stdin);\n//\tfreopen(\"snatch.out\" , \"w\" , stdout)\n\twhile(scanf(\"%d %d %d\" , &n , &m , &k) != EOF) {\n\t\tnum = n + 2;\n\t\ts = n + 2 , t = n;\n\t\tfor (int i = 1; i <= m; ++i) {\n\t\t\tint u , v , c;\n\t\t\tread(u),read(v),read(c);\n//\t\t\tu ++ , v ++;\n\t\t\tadd(u , v , c , 1);\n\t\t}\n\t\tif(!k) {\n\t\t\tputs(\"0\");\n\t\t\tcnt = 1;\n\t\t\tfor (int i = 1; i <= num; ++i) head[i] = 0; \n\t\t\tcontinue;\n\t\t}\n\t\tadd(s , 1 , inf , 0);\n\t\tMIN.MVMC();\n\t\tif(MIN.MaxFlow == 0) {\n\t\t\tputs(\"No solution\");\n\t\t\tcnt = 1;\n\t\t\tfor (int i = 1; i <= num; ++i) head[i] = 0; \n\t\t\tcontinue;\n\t\t}\n\t\tint l = 1 , r = MIN.MaxFlow;\n\t\tLL ans = (k + MIN.MinCost + MIN.MaxFlow - 1) / MIN.MaxFlow - 1;\n\t\twhile(l <= r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tdouble ans1 = cal(mid) , ans2 = cal(mid + 1);\n\t\t\tif(ans1 > ans2) l = mid + 1 , ans = min(ans , (LL)ceil(ans2));\n\t\t\telse r = mid - 1 , ans = min(ans , (LL)ceil(ans1));\n\t\t}\n\t\tprintf(\"%lld\\n\" , ans);\n\t\tcnt = 1;\n\t\tfor (int i = 1; i <= num; ++i) head[i] = 0; \n\t}\n\t\n\treturn 0;\n}\n```",
        "postTime": 1609855428,
        "uid": 171554,
        "name": "Reanap",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4400 \u3010[JSOI2008]Blue Mary\u7684\u65c5\u884c\u3011"
    }
]