[
    {
        "content": "[\u6d1b\u8c37\u9898\u9762\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P4023)\n\n\u9996\u5148\u5efa\u51fa $S$ \u7684\u51f8\u5305\uff0c\u5047\u8bbe\u51f8\u5305\u4e0a\u7684\u70b9\u6309\u987a\u65f6\u9488\u6392\u5217\u7684\u7ed3\u679c\u4e3a $P_0,P_1,\\dots,P_{k-1}$\u3002\n\n\u4e0d\u96be\u53d1\u73b0\u5f80\u51f8\u5305\u52a0\u5165\u4e00\u4e2a\u70b9\u5bf9\u51f8\u5305\u4ea7\u751f\u7684\u8d21\u732e\u662f\u5c06\u51f8\u5305\u53d8\u6210\u5176\u4e0e\u4e00\u4e2a\u4e09\u89d2\u5f62\u7684\u5e76\uff0c\u5177\u4f53\u6765\u8bf4\uff0c\u5047\u8bbe\u52a0\u5165\u7684\u70b9\u4e3a $A$\uff0c\u90a3\u4e48\u5982\u679c $A$ \u5728\u51f8\u5305\u5185\u5219\u51f8\u5305\u4e0d\u53d8\uff0c\u5426\u5219\u5047\u8bbe\u5176\u4e0e $A$ \u7684\u4e24\u4e2a\u5207\u70b9\u4e3a $P_x,P_y$\uff0c\u90a3\u4e48\u51f8\u5305\u4f1a\u53d8\u4e3a\u5176\u4e0e $\\triangle AP_xP_y$ \u7684\u5e76\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651\u4ec0\u4e48\u6837\u7684\u70b9\u662f\u6781\u70b9\uff0c\u663e\u7136\u5982\u679c\u6263\u6389\u51f8\u5305\u5185\u7684\u70b9\uff0c\u90a3\u4e48\u4e00\u4e2a\u70b9\u4e0d\u662f\u6781\u70b9\u5f53\u4e14\u4ec5\u5f53\u5b83\u4e0d\u5728\u4efb\u4f55\u4e00\u4e2a\u9664\u81ea\u5df1\u4e4b\u5916\u7684 $\\triangle AP_xP_y$\u3002\u5bb9\u6613\u53d1\u73b0\u4e00\u4e2a\u6027\u8d28\uff0c\u5c31\u662f\u5982\u679c\u6211\u4eec\u628a\u8fd9\u4e9b\u4e09\u89d2\u5f62\u5b83\u5f53\u4f5c\u4e00\u4e2a\u4e2a\u73af\u4e0a\u7684\u533a\u95f4\uff0c\u90a3\u4e48\u5982\u679c\u4e00\u4e2a\u533a\u95f4 $[l_1,r_1]$ \u5b8c\u5168\u88ab\u53e6\u4e00\u4e2a\u533a\u95f4 $[l_2,r_2]$ \u4e25\u683c\u5305\u542b\uff08\u5373 $l_2<l_1<r_1<r_2$\uff09\uff0c\u90a3\u4e48\u8fd9\u4e2a\u533a\u95f4\u5bf9\u5e94\u7684\u70b9\u80af\u5b9a\u4e0d\u662f\u6781\u70b9\uff0c\u4e5f\u5c31\u662f\u8bf4\u5982\u679c\u6211\u4eec\u65ad\u73af\u6210\u94fe\uff0c\u90a3\u4e48\u6240\u6709\u6781\u70b9\u5bf9\u5e94\u7684\u533a\u95f4\u5fc5\u7136\u968f\u7740\u5de6\u7aef\u70b9\u7684\u9012\u589e\uff0c\u53f3\u7aef\u70b9\u4e5f\u662f\u4e0d\u964d\u7684\uff0c\u56e0\u6b64\u6392\u4e2a\u5e8f\u62ff\u4e2a\u5355\u8c03\u6808\u7ef4\u62a4\u4e00\u4e0b\u5373\u53ef\u3002\n\n\u63a5\u4e0b\u6765\u5c31\u662f\u5b9e\u73b0\u7684\u95ee\u9898\u4e86\u3002\u6bd4\u8f83\u96be\u5b9e\u73b0\u7684\u5730\u65b9\u5728\u4e8e\u6c42\u4e00\u4e2a\u70b9\u4e0e\u51f8\u5305\u7684\u5207\u7ebf\uff0c\u76f4\u63a5\u4e8c\u5206\u662f\u4e0d\u53ef\u53d6\u7684\uff0c\u56e0\u4e3a\u4e0d\u5b58\u5728\u5355\u8c03\u6027\uff0c\u6b63\u786e\u7684\u65b9\u6cd5\u662f\uff0c\u5c06\u51f8\u5305\u5288\u6210\u4e0a\u51f8\u5305\u548c\u4e0b\u51f8\u5305\uff0c\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u51f8\u5305\u4e0a\u4e00\u6761\u7ebf\u6bb5 $P_iP_{i+1}$\uff0c\u6c42\u51fa\u5176\u662f\u5426\u5728\u4e09\u89d2\u5f62\u5185\uff0c\u8fd9\u53ef\u4ee5\u7528\u7c7b\u4f3c\u4e8e\u534a\u5e73\u9762\u4ea4\u4e2d\u5224\u65ad\u4e00\u4e2a\u70b9\u5728\u76f4\u7ebf\u5de6\u8fb9\u8fd8\u6709\u53f3\u8fb9\u6c42\u51fa\uff0c\u8fd9\u65f6\u5019\u5206\u7c7b\u8ba8\u8bba\uff0c\u5982\u679c\u4e0a\u51f8\u5305\u548c\u4e0b\u51f8\u5305\u4e0a\u90fd\u6709\u7ebf\u6bb5\u5728\u4e09\u89d2\u5f62\u5185\uff08\u6b64\u65f6\u5176\u8981\u4e48\u90fd\u662f\u6700\u5de6\u8fb9\u7684\u7ebf\u6bb5\uff0c\u8981\u4e48\u90fd\u662f\u6700\u53f3\u8fb9\u7684\u7ebf\u6bb5\uff0c\u53ea\u7528\u8fdb\u884c $\\mathcal O(1)$ \u6b21 check\uff09\uff0c\u5c31\u76f4\u63a5\u5728\u4e0a\u4e0b\u51f8\u5305\u4e0a\u5404\u4e8c\u5206\u4e00\u904d\u3002\u5426\u5219\u5176\u8981\u4e48\u53ea\u5728\u4e0a\u51f8\u5305\u4e0a\uff0c\u8981\u4e48\u53ea\u5728\u4e0b\u51f8\u5305\u4e0a\uff0c\u6211\u4eec\u5c31\u73b0\u5728\u4e0a\u51f8\u5305\u4e0a\u4e8c\u5206\u627e\u5230\u6a2a\u5750\u6807\u6700\u5927\u4e14 $\\le x_A$ \u7684\u70b9 $P_i$\uff0c\u663e\u7136\u5982\u679c $P_iP_{i+1}$ \u4e0d\u5728\u4e09\u89d2\u5f62\u4e2d\u5c31\u53ea\u80fd\u5728\u4e0b\u51f8\u5305\u4e0a\uff0c\u5426\u5219\u6211\u4eec\u5f80\u5de6\u5f80\u53f3\u5404\u4e8c\u5206\u4e00\u904d\u627e\u5230\u5bf9\u5e94\u7684\u8303\u56f4\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $n\\log n$\u3002\n\n\u7531\u4e8e\u6709\u677f\u5b50\u4e14\u5b9e\u73b0\u6bd4\u8f83\u5783\u573e\uff0c\u6240\u4ee5\u5199\u5f97\u5f88\u957f\u3002\u4e0d\u5efa\u8bae\u9605\u8bfb\u3002\n\n```cpp\nconst double EPS = 1e-8;\nint sgn(double x) {return ((x < -EPS) ? -1 : ((x < EPS) ? 0 : 1));}\nstruct point {\n\tdouble x, y;\n\tpoint() {x = y = 0;}\n\tpoint(double _x, double _y) {x = _x; y = _y;}\n\tfriend point operator + (const point &X, const point &Y) {return point(X.x + Y.x, X.y + Y.y);}\n\tfriend point operator - (const point &X, const point &Y) {return point(X.x - Y.x, X.y - Y.y);}\n\tfriend point operator * (const point &X, const double &Y) {return point(X.x * Y, X.y * Y);}\n\tfriend double operator | (const point &X, const point &Y) {return X.x * Y.y - X.y * Y.x;}\n\tfriend double operator ^ (const point &X, const point &Y) {return X.x * Y.x + X.y * Y.y;}\n\tfriend bool operator == (const point &X, const point &Y) {return sgn(X.x - Y.x) == 0 && sgn(X.y - Y.y) == 0;}\n\tfriend bool operator != (const point &X, const point &Y) {return sgn(X.x - Y.x) != 0 || sgn(X.y - Y.y) != 0;}\n\tfriend int get_dir(point u, point v) {return sgn(u | v);} // v is on clockwise of u\n\tdouble operator ~ () const {return sqrt(x * x + y * y);}\n\tdouble operator ! () const {return atan2(y, x);}\n};\nbool cmp_ang(point u, point v) {\n\tauto up = [&](point u) {return sgn(u.y) > 0 || (sgn(u.y) == 0 && sgn(u.x) > 0);};\n\tbool U = up(u), V = up(v); return (U == V) ? (get_dir(u, v) > 0) : U;\n}\nbool cmp_xy(point u, point v) {return sgn(u.x - v.x) ? (sgn(u.x - v.x) < 0) : (sgn(u.y - v.y) < 0);}\nstruct line { // directed ray\n\tpoint A, B;\n\tline() {}\n\tline(point _A, point _B) {A = _A; B = _B;}\n\tint dir(point x) {return get_dir(B - A, x - A);} // 0: on line, 1: left of A -> B, -1: right of A -> B\n\tfriend bool para(line x, line y) {return get_dir(x.B - x.A, y.B - y.A) == 0;}\n\tfriend bool coin(line x, line y) {return para(x, y) && x.dir(y.A) == 0;}\n\tfriend point inter(line x, line y) {\n\t\tif (para(x, y)) {fprintf(stderr, \"bad line intersection!\\n\"); exit(-1);}\n\t\tdouble U = ((y.B - x.A) | (y.A - x.A)), V = ((y.B - x.B) | (y.A - x.B));\n\t\treturn x.A + (x.B - x.A) * (U / (U - V));\n\t}\n};\nstruct segment {\n\tpoint A, B;\n\tsegment() {}\n\tsegment(point _A, point _B) {A = _A; B = _B;}\n\toperator line() const {return line(A, B);}\n\tfriend bool para(segment x, segment y) {return para(line(x), line(y));}\n\tbool on_seg(point x) {\n\t\treturn line(*this).dir(x) == 0 && sgn(x.x - min(A.x, B.x)) >= 0 && sgn(x.x - max(A.x, B.x)) <= 0 &&\n\t\tsgn(x.y - min(A.y, B.y)) >= 0 && sgn(x.y - max(A.y, B.y)) <= 0;\n\t}\n\tfriend bool has_inter(segment x, segment y) {\n\t\tif (para(x, y)) return 0;\n\t\tpoint p = inter(line(x), line(y));\n\t\tif (!x.on_seg(p) || !y.on_seg(p)) return 0;\n\t\treturn 1;\n\t}\n\tfriend point get_inter(segment x, segment y) {\n\t\tif (!has_inter(x, y)) {fprintf(stderr, \"bad segment intersection!\\n\"); exit(-1);}\n\t\treturn inter(line(x), line(y));\n\t}\n};\ndouble area(point x, point y, point z) {return fabs((z - x) | (y - x));}\nstruct convex {\n\tvector<point> v, up, dw;\n\tconvex() {}\n\tvoid construct(vector<point> vec) {\n\t\tsort(vec.begin(), vec.end(), cmp_xy);\n\t\tv.clear(); up.clear(), dw.clear();\n\t\tvector<int> stk; stk.pb(0);\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\twhile (stk.size() > 1 && get_dir(vec[i] - vec[stk.back()], vec[stk[stk.size() - 2]] - vec[stk.back()]) != 1) stk.ppb();\n\t\t\tstk.pb(i);\n\t\t}\n\t\tfor (int i = 0; i < stk.size(); i++) v.pb(vec[stk[i]]), dw.pb(vec[stk[i]]);\n\t\tstk.clear(); stk.pb(0);\n\t\tfor (int i = 1; i < vec.size(); i++) {\n\t\t\twhile (stk.size() > 1 && get_dir(vec[i] - vec[stk.back()], vec[stk[stk.size() - 2]] - vec[stk.back()]) != -1) stk.ppb();\n\t\t\tstk.pb(i);\n\t\t}\n\t\tfor (int i = (int)(stk.size()) - 2; i >= 1; i--) v.pb(vec[stk[i]]);\n\t\tfor (int i = 0; i < stk.size(); i++) up.pb(vec[stk[i]]);\n//\t\tfor (point p : v) printf(\"(%.10lf, %.10lf)\\n\", p.x, p.y);\n\t}\n\tconvex(vector<point> vec) {construct(vec);}\n\tdouble poly_area() {\n\t\tdouble res = 0;\n\t\tfor (int i = 1; i + 1 < v.size(); i++) res += area(v[0], v[i], v[i + 1]);\n\t\treturn res;\n\t}\n\tbool in(point x) {\n\t\tif (get_dir(v[1] - v[0], x - v[0]) < 0) return 0;\n\t\tif (get_dir(v.back() - v[0], x - v[0]) > 0) return 0;\n\t\tif (v.size() == 2) return segment(v[0], v[1]).on_seg(x);\n\t\tint l = 2, r = v.size() - 2, p = 1;\n\t\twhile (l <= r) {\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (get_dir(v[mid] - v[0], x - v[0]) > 0) p = mid, l = mid + 1;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\treturn get_dir(v[p + 1] - v[p], x - v[p]) >= 0;\n\t}\n} H;\nconst int MAXN = 1e5;\nint n, m, vis[MAXN + 5]; point a[MAXN + 5];\ndouble getang(point X, point Y, point Z) {return acos(((Y - X) ^ (Z - X)) / (~(Y - X)) / (~(Z - X)));}\nbool in_tri(point X, point Y, point Z, point A) {return convex(vector<point>{X, Y, Z}).in(A);}\nint main() {\n//\tfreopen(\"extreme.in\", \"r\", stdin);\n//\tfreopen(\"extreme.out\", \"w\", stdout);\n\tscanf(\"%d%d\", &n, &m); vector<point> vec;\n\tfor (int i = 1; i <= n; i++) {double x, y; scanf(\"%lf%lf\", &x, &y); vec.pb(point(x, y));}\n\tfor (int i = 1; i <= m; i++) scanf(\"%lf%lf\", &a[i].x, &a[i].y);\n\tH.construct(vec);\n\tvector<tuple<int, int, int> > v;\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (H.in(a[i])) {vis[i] = 1; continue;}\n\t\tauto chk = [&](point x, point y) {return line(x, y).dir(a[i]) == -1;};\n\t\tint A = chk(H.dw[0], H.dw[1]), B = chk(H.dw[H.dw.size() - 2], H.dw.back());\n\t\tint C = chk(H.up.back(), H.up[H.up.size() - 2]), D = chk(H.up[1], H.up[0]);\n\t\tint pos1 = 0, pos2 = 0;\n\t\tif (A && D) {\n\t\t\tint l = 1, r = H.up.size() - 1, p = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (chk(H.up[mid], H.up[mid - 1])) p = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t\tpos1 = H.dw.size() - 1 + H.up.size() - 1 - p;\n\t\t\tl = 1, r = H.dw.size() - 1, p = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (chk(H.dw[mid - 1], H.dw[mid])) p = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t\tpos2 = p;\n\t\t} else if (B && C) {\n\t\t\tint l = 1, r = H.up.size() - 1, p = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (chk(H.up[mid], H.up[mid - 1])) p = mid, r = mid - 1;\n\t\t\t\telse l = mid + 1;\n\t\t\t}\n\t\t\tpos2 = H.dw.size() - 1 + H.up.size() - 1 - (p - 1);\n\t\t\tl = 1, r = H.dw.size() - 1, p = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (chk(H.dw[mid - 1], H.dw[mid])) p = mid, r = mid - 1;\n\t\t\t\telse l = mid + 1;\n\t\t\t}\n\t\t\tpos1 = p - 1;\n\t\t} else {\n\t\t\tint l = 0, r = H.dw.size() - 1, p = 0;\n\t\t\twhile (l <= r) {\n\t\t\t\tint mid = l + r >> 1;\n\t\t\t\tif (H.dw[mid].x <= a[i].x) p = mid, l = mid + 1;\n\t\t\t\telse r = mid - 1;\n\t\t\t}\n\t\t\tif ((p == H.dw.size() - 1) ? B : chk(H.dw[p], H.dw[p + 1])) {\n\t\t\t\tl = 0, r = p - 1; int x = p, y = p;\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\tif (chk(H.dw[mid], H.dw[mid + 1])) x = mid, r = mid - 1;\n\t\t\t\t\telse l = mid + 1;\n\t\t\t\t}\n\t\t\t\tpos1 = x; l = p + 1; r = H.dw.size() - 1;\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\tif (chk(H.dw[mid - 1], H.dw[mid])) y = mid, l = mid + 1;\n\t\t\t\t\telse r = mid - 1;\n\t\t\t\t}\n\t\t\t\tpos2 = y;\n\t\t\t} else {\n\t\t\t\tl = 0, r = H.up.size() - 1; p = 0;\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\tif (H.up[mid].x <= a[i].x) p = mid, l = mid + 1;\n\t\t\t\t\telse r = mid - 1;\n\t\t\t\t}\n\t\t\t\tl = 0, r = p - 1; int x = p, y = p;\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\tif (chk(H.up[mid + 1], H.up[mid])) x = mid, r = mid - 1;\n\t\t\t\t\telse l = mid + 1;\n\t\t\t\t}\n\t\t\t\tpos2 = H.dw.size() - 1 + H.up.size() - 1 - x; l = p + 1; r = H.up.size() - 1;\n\t\t\t\twhile (l <= r) {\n\t\t\t\t\tint mid = l + r >> 1;\n\t\t\t\t\tif (chk(H.up[mid], H.up[mid - 1])) y = mid, l = mid + 1;\n\t\t\t\t\telse r = mid - 1;\n\t\t\t\t}\n\t\t\t\tpos1 = H.dw.size() - 1 + H.up.size() - 1 - y;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"! %d %d %d\\n\", i, pos1, pos2);\n\t\tif (pos1 > pos2) v.pb(mt(pos1, pos2 + H.v.size(), i));\n\t\telse v.pb(mt(pos1, pos2, i)), v.pb(mt(pos1 + H.v.size(), pos2 + H.v.size(), i));\n\t}\n\tauto cmp = [&](tuple<int, int, int> x, tuple<int, int, int> y) {\n\t\tif (get<0>(x) != get<0>(y)) return get<0>(x) < get<0>(y);\n\t\tif (get<1>(x) != get<1>(y)) return get<1>(x) < get<1>(y);\n\t\treturn getang(H.v[get<0>(y) % H.v.size()], H.v[(get<0>(x) + 1) % H.v.size()], a[get<2>(x)])\n\t\t\t > getang(H.v[get<0>(y) % H.v.size()], H.v[(get<0>(y) + 1) % H.v.size()], a[get<2>(y)]);\n\t};\n\tsort(v.begin(), v.end(), cmp); vector<tuple<int, int, int> > stk;\n\tauto get_in = [&](int id, tuple<int, int, int> t) {\n\t\treturn in_tri(H.v[get<0>(t) % H.v.size()], H.v[get<1>(t) % H.v.size()], a[get<2>(t)], a[id]);\n\t};\n\tfor (auto t : v) {\n\t\tif (stk.empty() || get<2>(t) == get<2>(stk.back()) || !get_in(get<2>(t), stk.back())) {\n\t\t\twhile (!stk.empty() && get_in(get<2>(stk.back()), t)) {\n\t\t\t\tif (get<2>(t) != get<2>(stk.back())) vis[get<2>(stk.back())] = 1;\n\t\t\t\tstk.ppb();\n\t\t\t}\n\t\t\tstk.pb(t);\n\t\t} else vis[get<2>(t)] = 1;\n\t}\n\tint res = 0; for (int i = 1; i <= m; i++) res += (!vis[i]);\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1658902024,
        "uid": 115194,
        "name": "lTgMFePRoeZ",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4023 [CTSC2012] \u6781\u70b9\u7edf\u8ba1"
    }
]