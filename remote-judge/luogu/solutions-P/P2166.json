[
    {
        "content": "\u4e0b\u9762\u662f\u4e00\u4e2a\u4e0d\u57fa\u4e8e\u6811\u5206\u5757\u7684\u505a\u6cd5\uff08\u6811\u5206\u5757\u5bf9\u5757\u6570\u65e0\u6cd5\u4fdd\u8bc1\uff0c\u53ef\u4ee5\u7528\u83ca\u82b1\u56fe\u5361\u6389\uff09\uff1a\n\n\u867d\u7136\u8fd9\u4e2a\u505a\u6cd5\u4e5f\u53ef\u4ee5\u88ab\u5361\uff0c\u4f46\u5fc5\u987b\u9488\u5bf9\u5757\u957f\uff08\u4e00\u6761\u94fe\uff0c\u5e73\u5206\u7b2c\u4e00\u5757\uff0c\u524d\u4e00\u534a2\u64cd\u4f5c\uff0c\u540e\u4e00\u534a3\u64cd\u4f5c\uff0c\u7136\u540e\u8be2\u95ee\uff09\u3002\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a[Gty\u7684\u59b9\u5b50\u6811](https://www.luogu.org/problem/P2137)\n\n\u4e0a\u9762\u8fd9\u9898$O(n^{1.5}\\log n)$\u7684\u89e3\u6cd5\uff1a\u5bf9\u6811\u7684DFS\u5e8f\u5efa\u5212\u5206\u6811\uff08\u7ebf\u6bb5\u6811\u7684\u4e00\u79cd\uff0c\u8fd0\u7528\u5f52\u5e76\u6392\u5e8f\u7684\u65b9\u6cd5\u5728\u5404\u4e2a\u8282\u70b9\u7ef4\u62a4\u5bf9\u5e94\u533a\u95f4\u5185\u5143\u7d20\u6392\u597d\u5e8f\u7684\u7ed3\u679c\uff0c\u53ef\u4ee5$O(logn)$\u8be2\u95ee\u533a\u95f4k\u5927\uff0c\u4e0d\u652f\u6301\u4fee\u6539\uff09\uff0c\u5bf9\u6bcf\u4e2a\u8be2\u95ee\u5148\u627e\u5230\u5212\u5206\u6811\u4e0a\u7684\u7ed3\u679c\uff0c\u7136\u540e\u66b4\u529b\u8ba8\u8bba\u6bcf\u4e2a\u4fee\u6539\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\uff0c\u79ef\u7d2f\u5230$O(\\sqrt{n})$\u4e2a\u8be2\u95ee\u540e\u66b4\u529b\u91cd\u5efa\u5212\u5206\u6811\u3002\n\n\u5982\u65e0\u6cd5\u7406\u89e3\u4e0a\u9762\u8fd9\u6bb5\u8bdd\u8bf7\u51fa\u95e8\u5de6\u8f6c\u8be5\u9898\u9898\u89e3\u3002\n\n### \u73b0\u5728\u6211\u4eec\u8ba8\u8bba3\u53f7\u64cd\u4f5c\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u3002\uff08\u5047\u8bbe\u5f53\u524d\u8be2\u95ee\u8282\u70b9\u4e3a$u$\uff09\uff08\u5148\u5ffd\u75651\u30012\u64cd\u4f5c\uff09\n\n1.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u4e0d\u662f$u$\u7684\u513f\u5b50\u3002\u5b83\u5bf9\u7b54\u6848\u6ca1\u6709\u5f71\u54cd\u3002$O(1)$\n\n2.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u5e76\u4e14$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u6ca1\u6709\u5176\u4ed6\u8282\u70b9\u88ab3\u53f7\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8be5\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u5404\u4e2a\u8282\u70b9\u90fd\u4e0d\u5e94\u5f53\u88ab\u8ba1\u5165\u7b54\u6848\uff08\u4f46\u5b9e\u9645\u4e0a\u90fd\u88ab\u8ba1\u5165\u4e86\uff09\uff0c\u53ea\u8981\u628a\u8fd9\u4e00\u90e8\u5206\u7684\u7b54\u6848\u53bb\u6389\u5373\u53ef\uff08\u5728\u5212\u5206\u6811\u4e0a\u8be2\u95ee\uff09\u3002$O(\\log n)$\n\n3.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u4f46$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u8fd8\u6709\u5176\u4ed6\u8282\u70b9\u88ab3\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8fd9\u4e00\u8282\u70b9\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u5df2\u88ab\u53bb\u9664\uff0c\u65e0\u9700\u4fee\u6539\u3002$O(1)$\n\n\u4e0a\u9762\u6709\u4e24\u4e2a\u95ee\u9898\uff1a\u8be2\u95ee\u662f\u5426\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff08\u89e3\u6cd5\uff1a\u7ef4\u62a4\u6bcf\u4e2a\u8282\u70b9\u5411\u4e0a\u8df3$2^i$\u540e\u7684\u8282\u70b9\uff09\u3001\u8be2\u95ee\u67d0\u8def\u5f84\uff08\u4e24\u7aef\u70b9\u95f4\u6709\u7956\u5148\u2014\u2014\u540e\u4ee3\u5173\u7cfb\uff09\u4e0a\u662f\u5426\u6709\u8282\u70b9\u88ab3\u64cd\u4f5c\u5f71\u54cd\uff08\u89e3\u6cd5\uff1a\u5148\u8f6c\u5316\u4e3a\u5bf9\u88ab3\u64cd\u4f5c\u5f71\u54cd\u7684\u8282\u70b9\u8fdb\u884c\u8ba1\u6570\uff0c\u6811\u4e0a\u5dee\u5206\u8f6c\u5316\u4e3a\u5bf9\u6839\u5230\u67d0\u4e00\u8282\u70b9\u88ab3\u64cd\u4f5c\u5f71\u54cd\u7684\u8282\u70b9\u8fdb\u884c\u8ba1\u6570\uff0c\u5219\u6bcf\u4e2a3\u64cd\u4f5c\u5bf9\u4ee5\u5b83\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u7684\u8282\u70b9\u6709\u8d21\u732e\uff0c\u53ef\u4ee5\u5728\u5212\u5206\u6811\u4e2d\u8282\u70b9\u591a\u5f00\u4e00\u4e2a\u53d8\u91cf\u7ef4\u62a4\uff09\n\n### 1\u53f7\u64cd\u4f5c\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\uff1a\n\n1.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u4e0d\u662f$u$\u7684\u513f\u5b50\u3002\u5b83\u5bf9\u7b54\u6848\u6ca1\u6709\u5f71\u54cd\u3002$O(1)$\n\n2.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u5e76\u4e14$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u6ca1\u6709\u8282\u70b9\u88ab3\u53f7\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8be5\u8282\u70b9\u53ef\u80fd\u5bf9\u7b54\u6848\u6709\u5f71\u54cd\uff0c\u8bb0\u5f55\u4fee\u6539\u524d\u540e\u7684\u6743\u503c\u4e0d\u96be\u5224\u65ad\u3002$O(1)$\n\n3.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u4f46$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u8fd8\u6709\u5176\u4ed6\u8282\u70b9\u88ab3\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8fd9\u4e00\u8282\u70b9\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u5df2\u88ab\u53bb\u9664\uff0c\u65e0\u9700\u4fee\u6539\u3002$O(1)$\n\n### 2\u53f7\u64cd\u4f5c\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\uff1a\n\n1.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u4e0d\u662f$u$\u7684\u513f\u5b50\u3002\u5b83\u5bf9\u7b54\u6848\u6ca1\u6709\u5f71\u54cd\u3002$O(1)$\n\n2.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u5e76\u4e14$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u6ca1\u6709\u8282\u70b9\u88ab3\u53f7\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8be5\u8282\u70b9\u53ef\u80fd\u5bf9\u7b54\u6848\u6709\u5f71\u54cd\uff0c\u4e0d\u96be\u5224\u65ad\u3002$O(1)$\n\n3.\u8fd9\u4e00\u64cd\u4f5c\u7684\u8282\u70b9\u5728$u$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u4f46$u$\u5230\u8be5\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u8fd8\u6709\u5176\u4ed6\u8282\u70b9\u88ab3\u64cd\u4f5c\u5f71\u54cd\u3002\u90a3\u4e48\u8fd9\u4e00\u8282\u70b9\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u5df2\u88ab\u53bb\u9664\uff0c\u65e0\u9700\u4fee\u6539\u3002$O(1)$\n\n\u4e0b\u9762\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u4e1c\u897f\uff1a\n\n### \u7ef4\u62a4\u6839\u52302\u53f7\u64cd\u4f5c\u4e2d\u65b0\u5efa\u8282\u70b9\u7684\u8def\u5f84\u4e0a\u88ab3\u64cd\u4f5c\u5f71\u54cd\u7684\u8282\u70b9\u6570\uff08\u5f00\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\uff09\uff1a\n\n1.\u65b0\u5efa\u4e86\u4e00\u4e2a\u8282\u70b9\u3002\u90a3\u4e48\u65b0\u5efa\u7684\u8282\u70b9\u53ef\u4ee5\u7ee7\u627f\u5176\u7236\u4eb2\u7684\u7b54\u6848\u3002\n\n2.\u4ea7\u751f\u4e86\u88ab3\u64cd\u4f5c\u5f71\u54cd\u7684\u8282\u70b9\u3002\u66b4\u529b\u626b\u63cf\u65b0\u5efa\u7684\u8282\u70b9\uff0c\u5224\u65ad\u662f\u5426\u88ab\u5f71\u54cd\u3002\n\n### \u4ee5\u4e0b\u662f\u590d\u6742\u5ea6\u5206\u6790\uff1a\n1\u64cd\u4f5c\uff1a\u8bb0\u5f55\u4fee\u6539\u5176\u524d\u540e\u7684\u6743\u503c$O(1)$\uff0c\u603b\u8ba1$O(n)$\n\n2\u64cd\u4f5c\uff1a\u57fa\u7840\u7ef4\u62a4$O(1)$\uff0c\u7ef4\u62a4\u5411\u4e0a\u8df3$2^i$\u540e\u7684\u8282\u70b9$O(\\log n)$\uff0c\u7ee7\u627f\u7236\u4eb2\u7684\u88ab\u5f71\u54cd\u8282\u70b9\u6570$O(\\log n)$\uff0c\u603b\u8ba1$O(n\\log n)$\n\n3\u64cd\u4f5c\uff1a\u4fee\u6539\u5f71\u54cd\u5230\u7684\u8282\u70b9\uff08\u539f\u6811\u4e2d\u7684\u8282\u70b9\uff09$O(\\log n)$\uff0c\uff08\u65b0\u5efa\u7684\u8282\u70b9\uff09$O(\\sqrt{n}\\log n)$\uff0c\u603b\u8ba1$O(n^{1.5}\\log n)$\n\n\u8be2\u95ee\uff1a\u53ef\u4ee5\u53d1\u73b0\u4e3a$O(n^{1.5}\\log n)$\n\n\u91cd\u5efa\uff1a\u5355\u6b21$O(n\\log n)$\uff0c\u603b\u8ba1$O(n^{1.5}\\log n)$\n\n\u56e0\u6b64\u603b\u590d\u6742\u5ea6\u4ecd\u4e3a$O(n^{1.5}\\log n)$\n\n### \u5b9e\u73b0\u7ec6\u8282\uff1a\n\n\u770b\u7740\u4e0d\u957f\uff0c\u5199\u5b8c\u4ee5\u540e\u53d1\u73b0\u548c\u6811\u5957\u6811\u5dee\u4e0d\u591a\u2026\u2026\n\n\u51c6\u5907\u5bf9\u62cd\u5427\uff08\u53bb\u6389\u91cd\u5efa\u90e8\u5206\u5bf9\u62cd\u4e00\u6b21\uff0c\u6bcf\u6b21\u91cd\u5efa\u518d\u5bf9\u62cd\u4e00\u6b21\uff09\n\n\u5757\u957f\u53d6\u5927\u4e00\u70b9\uff0c\u6070\u597d$\\sqrt{n}$\u5bb9\u6613\u88ab\u5361\u5e38\uff08\u5982\u679c\u77e5\u9053\u4e3a\u4ec0\u4e48\u8bf7\u79c1\u4fe1\uff09\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint read() {\n\tchar c=getchar();while(!isdigit(c))c=getchar();\n\tint num=0;while(isdigit(c))num=num*10+c-'0',c=getchar();\n\treturn num;\n}\nvoid write(int num){if(num>=10)write(num/10);putchar(num%10+'0');}\nint head[200001], ver[400001], nxt[400001], sz;\nvoid addedge(int u, int v) {\n\tver[++sz] = v, nxt[sz] = head[u], head[u] = sz;\n\tver[++sz] = u, nxt[sz] = head[v], head[v] = sz;\n}\nint fa[200001], dep[200001];\nvoid dfs(int x) {\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tif (fa[x] != ver[i]) {\n\t\t\tfa[ver[i]] = x;\n\t\t\tdep[ver[i]] = dep[x] + 1;\n\t\t\tdfs(ver[i]);\n\t\t}\n}\nint n;\nint seq[200001], pt[200001];\nint top;\nint size[200001];\nint w[200001];\nvoid getsq(int x) {\n\tseq[++top] = x, pt[x] = top;\n\tsize[x] = 1;\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tif (fa[ver[i]] == x) {\n\t\t\tgetsq(ver[i]);\n\t\t\tsize[x] += size[ver[i]];\n\t\t}\n}\nint bf;\nvector<int> sq[800001];\nint dat[800001];\nint cnt[800001];\nint out[100001];\nvoid erase(int p, int l, int r) {\n\tsq[p].clear();\n\tdat[p] = cnt[p] = 0;\n\tif (l == r) return;\n\tint mid = (l + r) / 2;\n\terase(p * 2, l, mid);\n\terase(p * 2 + 1, mid + 1, r);\n}\nvoid pushdown(int p, int l, int r) {\n\tint mid = (l + r) / 2;\n\tcnt[p*2] += dat[p]*(mid-l+1);\n\tcnt[p*2+1] += dat[p]*(r-mid);\n\tdat[p*2] += dat[p];\n\tdat[p*2+1] += dat[p];\n\tdat[p] = 0;\n}\nvoid init(int p, int l, int r) {\n\tif (l == r) {sq[p].push_back(w[seq[l]]);return;}\n\tint mid = (l + r) / 2;\n\tinit(p * 2, l, mid);\n\tinit(p * 2 + 1, mid + 1, r);\n\tint p1 = 0, p2 = 0;\n\twhile (p1 < sq[p*2].size() && p2 < sq[p*2+1].size())\n\t\tif (sq[p*2][p1]<sq[p*2+1][p2]) sq[p].push_back(sq[p*2][p1++]);\n\t\telse sq[p].push_back(sq[p*2+1][p2++]);\n\twhile (p1 < sq[p*2].size()) sq[p].push_back(sq[p*2][p1++]);\n\twhile (p2 < sq[p*2+1].size()) sq[p].push_back(sq[p*2+1][p2++]);\n}\nvoid insert(int p, int l, int r, int l0, int r0) {\n\tif (l0 >= l && r0 <= r) {\n\t\t++dat[p];\n\t\tcnt[p] += r0 - l0 + 1;\n\t\treturn;\n\t}\n\tpushdown(p, l0, r0);\n\tint mid = (l0 + r0) / 2;\n\tif (l <= mid) insert(p * 2, l, r, l0, mid);\n\tif (r > mid) insert(p * 2 + 1, l, r, mid + 1, r0);\n\tcnt[p] = cnt[p*2] + cnt[p*2+1];\n}\nint query(int p, int l0, int r0, int u) {\n\tif (l0 == r0) return cnt[p];\n\tpushdown(p, l0, r0);\n\tint mid = (l0 + r0) / 2;\n\tif (u <= mid) return query(p * 2, l0, mid, u);\n\telse return query(p * 2 + 1, mid + 1, r0, u);\n}\nint query(int p, int l, int r, int l0, int r0, int k) {\n\tif (l0 >= l && r0 <= r) return sq[p].end() - upper_bound(sq[p].begin(), sq[p].end(), k);\n\tint ans = 0, mid = (l0 + r0) / 2;\n\tif (l <= mid) ans += query(p * 2, l, r, l0, mid, k);\n\tif (r > mid) ans += query(p * 2 + 1, l, r, mid + 1, r0, k);\n\treturn ans;\n}\nint qu(int u, int maxn) {\n\tif (u > maxn) return out[u];\n\treturn query(1, 1, maxn, pt[u]);\n}\nint f[200001][20];\nvoid build() {\n    top = 0;\n\tfor (int i = 1; i <= n; i++) if (!fa[i]) getsq(i);\n\terase(1, 1, bf);\n\tmemset(f, 0, sizeof(f));\n\tfor (int i = 1; i <= n; i++) f[i][0] = fa[i];\n\tfor (int j = 1; j <= 18; j++)\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tf[i][j] = f[f[i][j-1]][j-1];\n\tinit(1, 1, n);\n}\ninline int jmp(int x, int d) {\n\tfor (int i = 18; i >= 0; i--)\n\t\tif (dep[f[x][i]] >= d)\n\t\t\tx = f[x][i];\n\treturn x;\n}\nstruct cmd {\n\tint op, u, x, x0;\n}c[100001];\nint main() {\n\tn = read();\n\tfor (int i = 1; i < n; i++) {\n\t\tint u = read(), v = read();\n\t\taddedge(u, v);\n\t}\n\tdep[1] = 1;\n\tdfs(1);\n\tfor (int i = 1; i <= n; i++) w[i] = read();\n\tbf = n;\n\tbuild();\n\tint m = read();\n\tint s = sqrt(m) * 4;\n\tint q = 1;\n\tint lastans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint op = read();\n\t\tswitch (op) {\n\t\t\tcase 0: {\n\t\t\t\tint u = read() ^ lastans, x = read() ^ lastans;\n\t\t\t\tint ans = 0;\n\t\t\t\tif (u <= bf) ans = query(1, pt[u], pt[u]+size[u]-1, 1, bf, x);\n\t\t\t\tfor (int j = 1; j < q; j++) {\n\t\t\t\t\tif (c[j].op == 1) {\n\t\t\t\t\t\tif (jmp(c[j].u, dep[u]) != u || qu(c[j].u, bf) > qu(u, bf)) continue;\n\t\t\t\t\t\tif (c[j].x > x) ++ans;\n\t\t\t\t\t\tif (c[j].x0 > x) --ans;\n\t\t\t\t\t}\n\t\t\t\t\tif (c[j].op == 2) {\n\t\t\t\t\t\tif (jmp(c[j].u, dep[u]) != u || qu(c[j].u, bf) > qu(u, bf)) continue;\n\t\t\t\t\t\tif (c[j].x > x) ++ans;\n\t\t\t\t\t}\n\t\t\t\t\tif (c[j].op == 3) {\n\t\t\t\t\t\tif (c[j].u > bf || jmp(c[j].u, dep[u]) != u || qu(fa[c[j].u], bf) != qu(u, bf)) continue;\n\t\t\t\t\t\tans -= query(1, pt[c[j].u], pt[c[j].u]+size[c[j].u]-1, 1, bf, x);\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twrite(lastans = ans);\n\t\t\t\tputchar('\\n');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 1: {\n\t\t\t\tint u = read() ^ lastans, x = read() ^ lastans;\n\t\t\t\tc[q].op = op, c[q].u = u, c[q].x = x, c[q].x0 = w[u];\n\t\t\t\tw[u] = x;\n\t\t\t\t++q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 2: {\n\t\t\t\tint u = read() ^ lastans, x = read() ^ lastans;\n\t\t\t\t++n;\n\t\t\t\tfa[n] = u, w[n] = x, dep[n] = dep[u] + 1;\n\t\t\t\tf[n][0] = u;\n\t\t\t\taddedge(n, u);\n\t\t\t\tfor (int i = 1; i <= 18; i++) f[n][i] = f[f[n][i-1]][i-1];\n\t\t\t\tout[n] = qu(u, bf);\n\t\t\t\tc[q].op = op, c[q].u = n, c[q].x = x;\n\t\t\t\t++q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 3: {\n\t\t\t\tint u = read() ^ lastans;\n\t\t\t\tif (u <= bf) insert(1, pt[u], pt[u]+size[u]-1, 1, bf);\n\t\t\t\tfor (int j = bf + 1; j <= n; j++)\n\t\t\t\t\tif (jmp(j, dep[u]) == u) ++out[j];\n\t\t\t\tc[q].op = op, c[q].u = u;\n\t\t\t\t++q;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (q > s) {\n\t\t\tfor (int j = 1; j <= q; j++)\n\t\t\t\tif (c[j].op == 3) fa[c[j].u] = 0;\n\t\t\tq = 1;\n\t\t\tbf = n;\n\t\t\tbuild();\n\t\t}\n\t}\n}\n```",
        "postTime": 1564723916,
        "uid": 61068,
        "name": "01190220csl",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P2166 \u3010Gty\u7684\u8d85\u7ea7\u59b9\u5b50\u6811\u3011"
    },
    {
        "content": "\u5206\u5757\u5427\uff01\u8fd9\u9898\u7684\u5206\u5757\u4e0d\u662f\u7ed9\u6811\u5206\u5757\uff0c\u800c\u662f\u7a0b\u5e8f\u5206\u5757\uff0c\u5c31\u6ca1\u4e86\uff01\n\n\u597d\u50cf3\u64cd\u4f5c\u6570\u636e\u91cc\u5e76\u6ca1\u6709\uff0c\u800c\u4e14\u6570\u636e\u8303\u56f4\u6ca1\u9053100000\u5427\uff0c\u6240\u4ee5\u76f4\u63a5\u6c34\uff01\n\n\u5c31\u662f\u8be2\u95ee\u5957\u5957\u4e3b\u5e2d\u6811\uff0c\u5176\u4ed6\u778e\u641e\uff0c\u66b4\u529b+\u5361\u5e38\u5c31\u53ef\u4ee5\u8dd1\u8fc7\u4e86\uff0c\u975e\u5e38\u5f00\u5fc3\u5427\uff01\n\n\u7136\u540e\u8981\u6ce8\u610f\u4e0d\u80fd\u79bb\u6563\u5316\uff0c\u540c\u65f6\u8981\u5f53\u5fc3\u67090\n\n\u6240\u4ee5\u76f4\u63a5\u57280 - 2 ^ 30 \u641e\u4e00\u4e0b\u5373\u53ef\uff01\uff08chairman tree\u5927\u6cd5\u597d\uff09\n\n\u8fd9\u9898\u597d\u50cf\u548c\u8d85\u7ea7\u59b9\u5b50\u6811\u4e00\u6837\u5427qwq\n\n\u4ee3\u7801\uff1a\n```cpp\n// luogu-judger-enable-o2\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005, M = (N << 1), P = (1 << 30);\nint n, ecnt, val[N], to[M], nxt[M], fir[N];\ntemplate <class T> void cmax(T &x, T y) {x = x > y ? x : y;}\ntemplate <class T> void cmin(T &x, T y) {x = x < y ? x : y;}\ntemplate <class T> void rd(T &x) {\n    char c = getchar(); int f = 1; x = 0;\n    for (; !isdigit(c); c = getchar()) if (c == '-') f = -1;\n    for (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n    x *= f;\n}\nvoid ae(int u, int v) {to[++ecnt] = v; nxt[ecnt] = fir[u]; fir[u] = ecnt;}\nnamespace subtask1 {\n    int ls[N * 60], rs[N * 60], size[N * 60], Rt[N], siz[N], dfn[N], idx = 0, tot = 0, ans = 0;\n    struct Segment_Tree {\n        #define mid (l + r >> 1)\n        #define lc ls[rt]\n        #define rc rs[rt] \n        void modify(int rt, int pre, int l, int r, int x) {\n            size[rt] = size[pre] + 1;\n            if (l == r) return; lc = ls[pre], rc = rs[pre];\n            if (x <= mid) modify(lc = ++tot, ls[pre], l, mid, x);\n            else modify(rc = ++tot, rs[pre], mid + 1, r, x); \t\t\t\n        }\n        int query(int rt, int pre, int l, int r, int x) {\n            if (l == r) return size[rt] - size[pre];\n            if (x < mid) return size[rc] - size[rs[pre]] + query(lc, ls[pre], l, mid, x);\n            return query(rc, rs[pre], mid + 1, r, x);\n        }\n    } T;\n    void dfs(int u, int f) {\n        int i; dfn[u] = ++idx, siz[u] = 1; T.modify(Rt[idx] = ++tot, Rt[idx - 1], 1, P, val[u]);\n        for (i = fir[u]; i; i = nxt[i]) {\n            int v = to[i];\n            if (v != f) dfs(v, u), siz[u] += siz[v];\n        }\n    }\n    void solve() {\n        int Q; rd(Q); dfs(1, 0);\n        while (Q--) {\n            int opt, x, y; rd(opt); rd(x); rd(y); x ^= ans, y ^= ans;\n            printf(\"%d\\n\", ans = T.query(Rt[dfn[x] + siz[x] - 1], Rt[dfn[x] - 1], 0, P, y));\n        }\n    }\n};\nnamespace subtask2 {\n    int fa[N], k, ans = 0;\n    void dfs(int u, int f) {\n        int i; fa[u] = f;\n        for (i = fir[u]; i; i = nxt[i]) {\n            int v = to[i];\n            if (v != f) dfs(v, u); \n        }\n    }\n    void work(int u) {\n        int i; ans += val[u] > k;\n        for (i = fir[u]; i; i = nxt[i]) {\n            int v = to[i];\n            if (v != fa[u]) work(v);\n        }\n    }\n    void solve() {\n        int Q; rd(Q); dfs(1, 0);\n        while (Q--) {\n            int opt, x, y; rd(opt); rd(x); rd(y); x ^= ans, y ^= ans;\n            if (!opt) ans = 0, k = y, work(x), printf(\"%d\\n\", ans);\n            if (opt == 1) val[x] = y;\n            if (opt == 2) val[++n] = y, fa[n] = x, ae(x, n);\n        }\n    }\n}\nint main() {\n    int i; rd(n);\n    for (i = 1; i < n; ++i) {\n        int u, v; rd(u); rd(v);\n        ae(u, v); ae(v, u);\n    }\n    for (i = 1; i <= n; ++i) rd(val[i]);\n    if (n == 30000) subtask1 :: solve();\n    else subtask2 :: solve();\n    return 0;\n}\n\n```",
        "postTime": 1547522602,
        "uid": 30817,
        "name": "muller",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2166 \u3010Gty\u7684\u8d85\u7ea7\u59b9\u5b50\u6811\u3011"
    },
    {
        "content": "\u5206\u5757\u6811\uff0c\u4ee3\u7801\u53c2\u8003\u4e86Manchery\u7684\n\n\u7b80\u800c\u8a00\u4e4b\uff0c\u5c31\u662f\u6211\u4eec\u628a\u6811\u7ed9\u8fdb\u884c\u5206\u5757\uff0c\u5982\u679c\u67d0\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u7684\u5757\u52a0\u4e0a\u5b83\u4f1a\u5927\u4e8e\u67d0\u4e2a\u8bbe\u5b9a\u7684\u503cSIZE\uff0c\u90a3\u4e48\u5c31\u628a\u4ed6\u5355\u72ec\u5f00\u4e00\u5757\uff0c\u5426\u5219\u628a\u5b83\u653e\u5230\u7236\u4eb2\u7684\u5757\u91cc\u3002\u6bcf\u4e2a\u5757\u5f00\u4e00\u4e2avector\uff0c\u5e76\u4fdd\u8bc1\u5757\u5185\u5143\u7d20\u6709\u5e8f\uff0c\u90a3\u4e48\u67e5\u8be2\u4e00\u4e2a\u5757\u5185\u5927\u4e8e\u67d0\u4e2a\u6570\u7684\u6570\u7684\u4e2a\u6570\u53ea\u8981lower_bound\u4e00\u4e0b\u5c31\u597d\u4e86\u3002\u63d2\u5165\u8282\u70b9\u76f4\u63a5\u8fde\u4e0a\u53bb\uff0c\u770b\u4e00\u4e0b\u662f\u5426\u8981\u5355\u72ec\u5f00\u4e00\u5757\u3002\u65ad\u5f00\u7684\u8bdd\u53ef\u80fd\u8981\u628a\u5757\u62c6\u5f00\n\n\u5177\u4f53\u7ec6\u8282\u8fd8\u662f\u770b\u4ee3\u7801\u597d\u4e86\n\n\u8fd9\u9898\u5361\u5e38\u2026\u2026\u6ce8\u610f\u5e38\u6570\u5199\u597d\u70b9\u2026\u2026\n```\n//minamoto\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\n#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline int read(){\n    #define num ch-'0'\n    char ch;bool flag=0;int res;\n    while(!isdigit(ch=getc()))\n    (ch=='-')&&(flag=true);\n    for(res=num;isdigit(ch=getc());res=res*10+num);\n    (flag)&&(res=-res);\n    #undef num\n    return res;\n}\nconst int N=100005;\nstruct Block{\n    vector<int> a;\n    inline void insert(int x){\n        a.insert(lower_bound(a.begin(),a.end(),x+1),x);\n    }\n    inline void erase(int x){\n        a.erase(lower_bound(a.begin(),a.end(),x));\n    }\n    inline void modify(int x,int y){\n        erase(x),insert(y);\n    }\n    inline int query(int x){\n        return a.end()-upper_bound(a.begin(),a.end(),x);\n    }\n    inline int size(){return a.size();}\n}Blo[N];\nint tot,ver[N<<2],head[N],Next[N<<2],first[N];\ninline void add(int u,int v){\n    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;\n}\ninline void addb(int u,int v){\n    ver[++tot]=v,Next[tot]=first[u],first[u]=tot;\n}\nint n,B,a[N],fa[N],belong[N],bat[N],cnt;\nvoid dfs(int u,int f){\n    fa[u]=f;\n    if(u==1||Blo[belong[f]].size()==B)\n    Blo[belong[u]=++cnt].insert(a[u]),addb(belong[f],belong[u]),bat[cnt]=belong[f];\n    else Blo[belong[u]=belong[f]].insert(a[u]);\n    for(int i=head[u];i;i=Next[i])\n    if(ver[i]!=f) dfs(ver[i],u);\n}\nint Y,ans=0;\nvoid block_dfs(int u){\n    ans+=Blo[u].query(Y);\n    for(int i=first[u];i;i=Next[i])\n    if(bat[ver[i]]==u) block_dfs(ver[i]);\n}\nvoid find(int u,int f){\n    if(a[u]>Y) ++ans;\n    for(int i=head[u];i;i=Next[i])\n    if(ver[i]!=f&&fa[ver[i]]==u)\n    if(belong[ver[i]]==belong[u]) find(ver[i],u);\n    else block_dfs(belong[ver[i]]);\n}\nint c[N],d[N];\nvoid cont(int u,int f){\n    c[++*c]=u;\n    for(int i=head[u];i;i=Next[i])\n    if(ver[i]!=f&&fa[ver[i]]==u)\n    if(belong[ver[i]]==belong[u]) cont(ver[i],u);\n    else d[++*d]=belong[ver[i]];\n}\nint main(){\n    int q,op,u,v,lastans=0;\n    //freopen(\"testdata.in\",\"r\",stdin);\n    n=read(),B=sqrt(n);\n    for(int i=1;i<n;++i)\n    u=read(),v=read(),add(u,v),add(v,u);\n    for(int i=1;i<=n;++i) a[i]=read();\n    dfs(1,0);q=read();\n    while(q--){\n        op=read();\n        switch(op){\n            case 0:{\n                u=read(),v=read();\n                u^=lastans,v^=lastans;\n                Y=v,ans=0;\n                find(u,fa[u]);\n                printf(\"%d\\n\",lastans=ans);\n                break;\n            }\n            case 1:{\n                u=read(),v=read();\n                u^=lastans,v^=lastans;\n                Blo[belong[u]].modify(a[u],v);\n                a[u]=v;\n                break;\n            }\n            case 2:{\n                u=read(),v=read();\n                u^=lastans,v^=lastans;\n                a[++n]=v;\n                add(u,n),add(n,u);\n                fa[n]=u;\n                if(Blo[belong[u]].size()==B)\n                Blo[belong[n]=++cnt].insert(a[n]),addb(belong[u],belong[n]),bat[cnt]=belong[u];\n                else Blo[belong[n]=belong[u]].insert(a[n]);\n                break;\n            }\n            case 3:{\n                u=read(),u^=lastans;\n                if(belong[u]!=belong[fa[u]]){\n                    fa[u]=0,bat[belong[u]]=0;break;\n                }\n                cont(u,fa[u]);\n                belong[u]=++cnt;\n                for(int i=1;i<=*c;++i){\n                    Blo[belong[fa[u]]].erase(a[c[i]]);\n                    Blo[cnt].insert(a[c[i]]);\n                    belong[c[i]]=cnt;\n                }\n                for(int i=1;i<=*d;++i)\n                addb(cnt,d[i]),bat[d[i]]=cnt;\n                fa[u]=0,*c=*d=0;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1536140529,
        "uid": 41781,
        "name": "bztMinamoto",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2166 \u3010Gty\u7684\u8d85\u7ea7\u59b9\u5b50\u6811\u3011"
    }
]