[
    {
        "content": "\uff08\u683c\u5f0f\u590d\u5236\u8fc7\u6765\u4e71\u4e86\u70b9\uff0c\u539f\u7248\u5728\u6211\u535a\u5ba2\u91cc\uff09\n\nmyblog: http://blog.csdn.net/miaomiao\\_ymxl/article/details/54908607\n\n\n\u601d\u8def\uff1a\n\n\u9996\u5148\u56e0\u4e3aR\u4e0eC\u4e0d\u786e\u5b9a\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u5c06\u70b9\u4eec\u653e\u5728\u4e00\u4e2a\u4e00\u7ef4\u6570\u7ec4\u4e2d\uff0c\u7b97\u7b97\u7f16\u53f7\u5c31\u597d\u4e86\n\n\u63a5\u4e0b\u6765\u8bb0\u5f55lr[i]\u4e0edown[i]\u5206\u522b\u8868\u793a\u70b9i\u6700\u591a\u53ef\u4ee5\u5411\u5de6\u53f3\u5ef6\u4f38\u548c\u5411\u4e0b\u5ef6\u4f38\u591a\u5c11\u4e2a1(\u4e0d\u5305\u62ec\u81ea\u5df1)\n\n\n\u7136\u540e\u6211\u4eec\u679a\u4e3e\u53cc\u5341\u5b57\u7684\u4e0b\u9762\u90a3\u4e2a\u4ea4\u70b9\uff0c\u63a8\u4e00\u63a8\u516c\u5f0f\uff1a\n\n\n{\u6ce8\uff1alen\u662f\u4e0b\u9762\u6a2a\u7ebf\u7684\u957f\u5ea6\uff0ctop\u8868\u793a\u80fd\u5230\u8fbe\u7684\u6700\u4e0a\u7684\u4f4d\u7f6e\uff08\u8fde\u7eed\u76841\uff09\uff0cj\u662f\u4e0a\u9762\u7684\u6a2a\u7ebf\u7684\u4e2d\u5fc3\u4f4d\u7f6e}\n\n\u5bf9\u4e8e\u4e00\u4e2a\u70b9i\uff0c\u5b83\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u662f\uff1a\n\n\u2211lr[i]len=1min(lr[j],len\u22121)\u00d7down[i]\u00d7(j\u2212top)\n\n\u663e\u7136\u8fd9\u4e2amin\u975e\u5e38\u6076\u5fc3\uff0c\u6211\u4eec\u8003\u8651\u628a\u5b83\u62c6\u5f00\u6210\u4e0b\u9762\u7684\u6837\u5b50\uff1a\n\n1.\u5f53(lr[j] <= len-1) \u8d21\u732e\u662f\u2211lr[i]len=1lr[j]\u00d7down[i]\u00d7(j\u2212top)\n\n2.\u5f53(lr[j] > len-1) \u8d21\u732e\u662f\u2211lr[i]len=1(len\u22121)\u00d7down[i]\u00d7(j\u2212top)\n\n\n\u518d\u8fdb\u4e00\u6b65\u53d8\u5f62\uff1a\n\n1.\u5f53(lr[j] <= lr[i]) \u8d21\u732e\u662f(lr[i]\u00d7lr[j]\u2212lr[j]\u00d7(lr[j]+1)/2)\u00d7down[i]\u00d7(j\u2212top)\n\n2.\u5f53(lr[j] > lr[i]) \u8d21\u732e\u662flr[i]\u00d7(lr[i]\u22121)/2\u00d7down[i]\u00d7(j\u2212top)\n\n\uff08\u5bf9\u4e8e1\u7684\u89e3\u91ca:lr[i]\u00d7lr[j]\u662f\u603b\u65b9\u6848\u6570\uff0clr[j]\u00d7(lr[j]+1)/2\u662f\u4e0d\u5408\u6cd5\u65b9\u6848\u6570\uff09\n\n\n\u73b0\u5728\uff0c\u9700\u8981\u89e3\u51b3\u7684\u662f\u6240\u6709\u5e26j\u7684\u5f0f\u5b50\uff0c\u6211\u4eec\u5b9a\u4e493\u4e2a\u6811\u72b6\u6570\u7ec4t1, t2, t3\uff0c\u5206\u522b\u8bb0\u5f55:\n\n1.\u2212lr[j]\u2217(lr[j]+1)/2)\u00d7(j\u2212top)\n\n2.lr[j]\u00d7(j\u2212top)\n\n3.(j\u2212top)\n\n\u628alr[i]\u4f5c\u4e3a\u4f4d\u7f6e\u63d2\u5165\uff0c\u5148\u679a\u4e3e\u5217\u518d\u679a\u4e3e\u884c\uff0c\u6bcf\u6b21\u6ce8\u610f\u6e05\u7a7a\u3002\n\n\u5e76\u4e14\u56e0\u4e3a\u4e24\u6839\u6a2a\u7ebf\u4e0d\u80fd\u6328\u5728\u4e00\u8d77\uff0c\u6240\u4ee5\u679a\u4e3e\u70b9(i, j)\u63d2\u5165(i-1, j)\u7684\u503c\n\n\n\u4ee3\u7801\uff1a\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n<\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n#define Set(a, v) memset(a, v, sizeof(a))\n#define For(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define Forr(i, a, b) for(int i = (a); i >= (int)(b); i--)\n#define N (10000+5)\n#define NM (1200000+5)\nconst LL MOD = 1e9+9;\nint n, m, lr[NM], L[NM], R[NM], down[NM];\nbool is0[NM];\nstruct Tbit{\n    LL c[N];\n    void clear(){Set(c, 0);}\n    int lowbit(int x){return x&(-x);}\n    void add(int x, LL v){\n        while(x < N){c[x] = (c[x]+v)%MOD; x += lowbit(x);}\n    }\n    LL query(int x){\n        LL ret = 0;\n        while(x > 0){ret = (ret+c[x])%MOD; x -= lowbit(x);}\n        return ret;\n    }\n}t1, t2, t3;\nint ID(int x, int y){return m*(x-1)+y;}\ninline void init(){\n    For(i, 1, n){\n        L[ID(i,1)] = !is0[ID(i,1)]; R[ID(i,m)] = !is0[ID(i,m)];\n        For(j, 2, m) if(!is0[ID(i,j)]) L[ID(i,j)] = L[ID(i,j-1)]+1;\n        Forr(j, m-1, 1) if(!is0[ID(i,j)]) R[ID(i,j)] = R[ID(i,j+1)]+1;\n        For(j, 1, m) if(!is0[ID(i,j)]) lr[ID(i,j)] = min(L[ID(i,j)], R[ID(i,j)])-1;\n    }\n    For(i, 1, m){\n        down[ID(n,i)] = !is0[ID(n,i)];\n        Forr(j, n-1, 1) if(!is0[ID(j,i)]) down[ID(j,i)] = down[ID(j+1,i)]+1;\n        Forr(j, n, 1) if(down[ID(j,i)]) down[ID(j,i)]--;\n    }\n}\ninline void work(){\n    int top, now;\n    LL ans = 0;\n    For(j, 1, m){\n        top = 0; t1.clear(); t2.clear(); t3.clear(); \n        For(i, 1, n){\n            if(is0[ID(i,j)]){top=i; t1.clear(); t2.clear(); t3.clear(); continue;}\n            now = ID(i,j);\n            ans += t1.query(lr[now])*down[now]%MOD;\n            ans += t2.query(lr[now])*down[now]*lr[now]%MOD;\n            ans += (t3.query(m)-t3.query(lr[now]))*lr[now]*(lr[now]-1)/2*down[now]%MOD; ans %= MOD;\n            if(i==1) continue;\n            now = ID(i-1,j);\n            if(lr[now]){\n                t1.add(lr[now], -lr[now]*(lr[now]+1)/2%MOD*(i-1-top-1)%MOD);\n                t2.add(lr[now], lr[now]*(i-1-top-1)%MOD); t3.add(lr[now], i-1-top-1);\n            }\n        }\n    }\n    printf(\"%lld\\n\", (ans+MOD)%MOD);\n}\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"test.in\", \"r\", stdin);\n    freopen(\"test.out\", \"w\", stdout);\n#endif\n    int cnt1, x, y;\n    scanf(\"%d%d%d\", &n, &m, &cnt1);\n    For(i, 1, cnt1){scanf(\"%d%d\", &x, &y); is0[ID(x, y)] = true;}\n    init(); work();\n    return 0;\n}\n>\n```",
        "postTime": 1486479118,
        "uid": 8925,
        "name": "miaowey",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3221 \u3010[HNOI2012]\u53cc\u5341\u5b57\u3011"
    },
    {
        "content": "\u6211\u4eec\u53bb\u5e74\u6691\u5047\u7684\u65f6\u5019\u8003\u8bd5\u8003\u8fc7\u3002\u6211\u5f53\u65f6\u5199\u4e86\u4e2a\u5927\u66b4\u529b\u6df7\u4e86$70$\u5206\u3002\u3002\u3002\u3002\n\n\u5927\u66b4\u529b\u662f\u8fd9\u4e48\u5199\u7684\uff1a\n\n\u9884\u5904\u7406\u6bcf\u4e2a\u4f4d\u7f6e\u5411\u5de6\u53f3/\u4e0a/\u4e0b\u80fd\u591f\u62d3\u5c55\u7684\u6700\u591a\u7684\u957f\u5ea6(\u5de6\u53f3\u76f8\u5f53\u4e8e\u5206\u522b\u6c42\u7136\u540e\u53d6$min$)  \n\u63a5\u7740\u679a\u4e3e\u53cc\u5341\u5b57\u7684\u4e2d\u8f74\u7ebf\uff0c\u6240\u5728\u7684\u5217  \n\u7136\u540e\u679a\u4e3e\u4e0a\u9762\u90a3\u4e00\u884c\uff0c\u679a\u4e3e\u4e0b\u9762\u90a3\u4e00\u884c\u3002  \n\u90a3\u4e48\uff0c\u8d21\u732e\u663e\u7136\u662f\u4e0a\u9762\u9009\u62e9\u7684\u5de6\u53f3\u957f\u5ea6$*$\u4e0b\u9762\u53ef\u4ee5\u9009\u62e9\u7684\u5de6\u53f3\u957f\u5ea6$*$\u4e0a\u4e0b\u4e24\u884c\u5206\u522b\u5411\u4e0a/\u4e0b\u62d3\u5c55\u7684\u957f\u5ea6\u3002  \n\u53d1\u73b0\u590d\u6742\u5ea6\u74f6\u9888\u5728\u4e8e\u679a\u4e3e\u5b8c\u4e0a\u9762\u90a3\u4e00\u884c\u4e4b\u540e\u53c8\u53bb\u679a\u4e3e\u4e0b\u9762\u90a3\u4e00\u884c\u3002  \n\u8fd9\u4e2a\u4e1c\u897f\u663e\u7136\u53ef\u4ee5\u524d\u7f00\u548c\u4f18\u5316\uff0c\u90a3\u4e48\u6bcf\u6b21\u4fee\u6539\u90fd\u662f\u4e00\u4e2a\u533a\u95f4\u52a0\u6cd5\uff0c\u5e76\u4e14\u8fd8\u662f\u52a0\u7b49\u5dee\u6570\u5217\u3002  \n\n\u7ebf\u6bb5\u6811\u6216\u8005\u6811\u72b6\u6570\u7ec4\u5c31\u597d\u5566\uff1f  \n\u7ebf\u6bb5\u6811\u600e\u4e48\u7ef4\u62a4\u53ef\u4ee5\u53c2\u8003\u6d1b\u8c37\u7684\u8fd9\u9053\u9898\u76ee[\u65e0\u804a\u7684\u6570\u5217]\uff0c\u6253\u5f00\u94fe\u63a5\u540e\u7684\u7b2c\u4e00\u9053\u9898\u76ee\u3002(https://www.cnblogs.com/cjyyb/p/8567674.html)  \n\n\u6811\u72b6\u6570\u7ec4\u7684\u505a\u6cd5\uff0c\u9996\u5148\u8981\u77e5\u9053[\u600e\u4e48\u7ef4\u62a4\u533a\u95f4\u52a0\u6cd5](http://www.cnblogs.com/cjyyb/p/8688692.html)  \n\u6838\u5fc3\u601d\u60f3\u662f\u5dee\u5206\u3002    \n\u6211\u4eec\u8981\u52a0\u4e00\u4e2a\u7b49\u5dee\u6570\u5217\uff0c\u5982\u679c\u53ea\u8fdb\u884c\u4e00\u6b21\u5dee\u5206\uff0c\u90a3\u4e48\u5c31\u662f\u7ed9\u5dee\u5206\u6570\u7ec4\u505a\u533a\u95f4\u52a0\u6cd5\u3002  \n\u8fd9\u6837\u663e\u7136\u8fd8\u4e0d\u884c\uff0c\u6240\u4ee5\u6211\u4eec\u5bf9\u4e8e\u5dee\u5206\u6570\u7ec4\u518d\u5dee\u5206\u4e00\u6b21\uff0c\u5047\u8bbe\u5f97\u5230\u7684\u6570\u7ec4  \u662f$c_i$\uff0c\u539f\u6570\u7ec4\u662f$a_i$\uff0c\u5dee\u5206\u4e00\u6b21\u7684\u7ed3\u679c\u662f$b_i$  \n\u90a3\u4e48  \n$$\\begin{aligned}\\sum_{i=1}^xa_i&=\\sum_{i=1}^x\\sum_{j=1}^ib[i]\\\\&=\\sum_{i=1}^x(x-i+1)b[i]\\\\&=\\sum_{i=1}^x(x-i+1)\\sum_{j=1}^ic[i]\\\\&=\\sum_{i=1}^xc[i]\\sum_{j=i}^x(x-j+1)\\\\&=\\sum_{i=1}^xc[i]\\times\\frac{1}{2}(n-i+2)(n-i+1)\\\\&=\\frac{1}{2}\\sum_{i=1}^xc[i]((n^2+3n+2)-(i^2+(2n+3)i))\\end{aligned}$$\n\n\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4$c[i],ic[i],i^2c[i]$\u5373\u53ef\u3002\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define RG register \n#define MAX 1500000\n#define MOD 1000000009\n#define inv2 500000005\n#define id(x,y) ((x-1)*m+y)\ninline int read()\n{\n\tRG int x=0,t=1;RG char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return x*t;\n}\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\nbool vis[MAX];\nint n,m,L[MAX],U[MAX],D[MAX],ans,K;\nint c1[MAX],c2[MAX],c3[MAX];\ninline int lb(int x){return x&(-x);}\nvoid modify(int x,int w)\n{\n\tfor(int i=x;i<=m;i+=lb(i))\n\t{\n\t\tadd(c1[i],w);\n\t\tadd(c2[i],1ll*x*w%MOD);\n\t\tadd(c3[i],1ll*x*x%MOD*w%MOD);\n\t}\n}\nint getsum(int x)\n{\n\tint s1=0,s2=0,s3=0,ret=0;\n\tfor(int i=x;i;i-=lb(i))\n\t\tadd(s1,c1[i]),add(s2,c2[i]),add(s3,c3[i]);\n\tadd(ret,(1ll*(x+3)*x%MOD+2)*s1%MOD);add(ret,s3);\n\tadd(ret,MOD-1ll*(x+x+3)*s2%MOD);\n\tret=1ll*ret*inv2%MOD;\n\treturn ret;\n}\nvoid modify(int l,int r,int w){modify(l,w);modify(r+1,MOD-w);}\nvoid init(){for(int i=1;i<=m;++i)c1[i]=c2[i]=c3[i]=0;}\nint main()\n{\n\tn=read();m=read();K=read();\n\tfor(int i=1;i<=n*m;++i)vis[i]=true;\n\twhile(K--)vis[id(read(),read())]=false;\n\tfor(int i=1;i<=n;++i)//Left\n\t{\n\t\tint s=0,now=(i-1)*m+1;\n\t\tfor(int j=1;j<=m;++j,++now)\n\t\t{\n\t\t\ts=vis[now]?s+1:0;\n\t\t\tL[now]=s;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)//Right\n\t{\n\t\tint s=0,now=i*m;\n\t\tfor(int j=m;j>=1;--j,--now)\n\t\t{\n\t\t\ts=vis[now]?s+1:0;\n\t\t\tL[now]=min(L[now],s);if(L[now])--L[now];\t\t\t\n\t\t}\n\t}\n\tfor(int j=1;j<=m;++j)//Up\n\t{\n\t\tint s=0,now=j;\n\t\tfor(int i=1;i<=n;++i,now+=m)\n\t\t{\n\t\t\ts=vis[now]?s+1:0;\n\t\t\tU[now]=s;if(U[now])--U[now];\n\t\t}\n\t}\n\tfor(int j=1;j<=m;++j)//Down\n\t{\n\t\tint s=0,now=id(n,j);\n\t\tfor(int i=n;i>=1;--i,now-=m)\n\t\t{\n\t\t\ts=vis[now]?s+1:0;\n\t\t\tD[now]=s;if(D[now])--D[now];\n\t\t}\n\t}\n\tfor(int j=2;j<m;++j,init())\n\t\tfor(int i=3;i<n;++i)\n\t\t{\n\t\t\tint u=id(i,j);\n\t\t\tif(!vis[u]){init();continue;}\n\t\t\tif(L[u])add(ans,1ll*D[u]*getsum(L[u]-1)%MOD);\n\t\t\tmodify(1,L[u-m],U[u-m]);\n\t\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n```",
        "postTime": 1531552602,
        "uid": 21283,
        "name": "yybyyb",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P3221 \u3010[HNOI2012]\u53cc\u5341\u5b57\u3011"
    },
    {
        "content": "\u9996\u5148\u80af\u5b9a\u8981\u8ba1\u7b97\u4e0a\u4e0b\u5de6\u53f3\u6700\u591a\u5ef6\u4f38\u591a\u5c11\u4e2a $1$\uff0c\u8fd9\u662f\u5bb9\u6613\u7684\u3002\n\n\u8003\u8651\u679a\u4e3e\u4e2d\u95f4\u6240\u5728\u7684\u5217\uff0c\u8bb0\u4e3a $j$\u3002\n\n\u6700\u6734\u7d20\u7684\u60f3\u6cd5\u662f\u679a\u4e3e\u4e24\u4e2a\u6a2a\u6240\u5728\u7684\u884c $i_1,i_2$\uff0c\u4e0d\u96be\u8ba1\u7b97\u7b26\u5408\u8981\u6c42\u7684\u5de6\u53f3\u5ef6\u4f38\u6570\u3002\u4e58\u4e0a $(i_1,j)$ \u5411\u4e0a\u5ef6\u4f38\u6570\u548c $(i_2,j)$ \u5411\u4e0b\u5ef6\u4f38\u6570\u5373\u53ef\u3002\u590d\u6742\u5ea6 $O(CR^2)$\u3002\n\n\u8003\u8651\u4f18\u5316\uff0c\u679a\u4e3e\u4e0b\u9762\u4e00\u4e2a\u5341\u5b57\u6240\u5728\u884c $i$\uff0c\u6211\u4eec\u8981\u8ba1\u7b97\u7684\u662f\u6240\u6709\u4e0a\u9762\u7684\u5339\u914d\u6570\u3002\u5206\u4e24\u7c7b\u8ba8\u8bba\uff0c\u4e00\u7c7b\u662f\u4e0a\u9762\u5de6\u53f3\u5ef6\u4f38\u6570\u5c0f\u4e8e\u7b49\u4e8e $(i,j)$ \u5de6\u53f3\u5ef6\u4f38\uff0c\u4e00\u7c7b\u662f\u5927\u4e8e\u7b49\u4e8e\uff0c\u5206\u522b\u6254\u5230\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u5373\u53ef\u3002\u590d\u6742\u5ea6 $O(CR\\log C)$\u3002\n\n\u7ec6\u8282\u4e0d\u5c11\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\n#define s(i,j) ((i-1)*c+j)\n#define mid ((l+r)>>1)\nusing namespace std;\nconst int mod=1e9+9;\nint col[3000005];\nint up[3000005],down[3000005],lft[3000005],rht[3000005];\nstruct sgt{\n\tint f[1000005],tag[1000005],siz[1000005];\n\tvoid clear(){\n\t\ttag[1]=1;\n\t}\n\tvoid build(int i,int l,int r){\n\t\tf[i]=tag[i]=0;\n\t\tif(l==r){\n\t\t\tsiz[i]=1;\n\t\t\treturn ;\n\t\t}\n\t\tbuild(i*2,l,mid);\n\t\tbuild(i*2+1,mid+1,r);\n\t\tsiz[i]=siz[i*2]+siz[i*2+1];\n\t}\n\tvoid pushdown(int i){\n\t\tif(tag[i]){\n\t\t\ttag[i*2]=tag[i*2+1]=1;\n\t\t\tf[i*2]=f[i*2+1]=0;\n\t\t\ttag[i]=0;\n\t\t}\n\t}\n\tvoid change(int i,int l,int r,int ql,int qr,int cg){\n\t\tif(ql<=l&&r<=qr){\n\t\t\t(f[i]+=cg*siz[i])%=mod;\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(i);\n\t\tif(ql<=mid) change(i*2,l,mid,ql,qr,cg);\n\t\tif(qr>mid) change(i*2+1,mid+1,r,ql,qr,cg);\n\t\tf[i]=(f[i*2]+f[i*2+1])%mod;\n\t}\n\tint qry(int i,int l,int r,int ql,int qr){\n\t\tif(ql>qr) return 0;\n\t\tif(ql<=l&&r<=qr) return f[i];\n\t\tif(ql>r||qr<l) return 0;\n\t\tpushdown(i);\n\t\treturn (qry(i*2,l,mid,ql,qr)+qry(i*2+1,mid+1,r,ql,qr))%mod;\n\t}\n}tree1,tree2,tree3;\nsigned main(){\n\tint r,c,n,ans=0; cin>>r>>c>>n;\n\tfor(int i=1;i<=r;i++) for(int j=1;j<=c;j++) col[s(i,j)]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y; cin>>x>>y; col[s(x,y)]=0;\n\t}\n\tfor(int i=1;i<=r;i++) for(int j=2;j<=c;j++) if(col[s(i,j)]&col[s(i,j-1)]) lft[s(i,j)]=lft[s(i,j-1)]+1;\n\tfor(int i=1;i<=r;i++) for(int j=c-1;j>=1;j--) if(col[s(i,j)]&col[s(i,j+1)]) rht[s(i,j)]=rht[s(i,j+1)]+1;\n\tfor(int i=2;i<=r;i++) for(int j=1;j<=c;j++) if(col[s(i,j)]&col[s(i-1,j)]) up[s(i,j)]=up[s(i-1,j)]+1;\n\tfor(int i=r-1;i>=1;i--) for(int j=1;j<=c;j++) if(col[s(i,j)]&col[s(i+1,j)]) down[s(i,j)]=down[s(i+1,j)]+1;\n\ttree1.build(1,1,c);\n\ttree2.build(1,1,c);\n\ttree3.build(1,1,c);\n\tfor(int j=1;j<=c;j++){\n\t\ttree1.clear();\n\t\ttree2.clear();\n\t\ttree3.clear();\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tint minv=min(lft[s(i,j)],rht[s(i,j)]);\n\t\t\tif(minv){\n\t\t\t\tint tmp=(tree1.qry(1,1,c,minv,c)*((minv*(minv-1)/2)%mod)%mod+tree3.qry(1,1,c,1,minv-1)*minv%mod+mod-tree2.qry(1,1,c,1,minv-1))*down[s(i,j)]%mod;\n\t\t\t\t(ans+=tmp)%=mod;\n\t\t\t}\n\t\t\tif(i-1){\n\t\t\t\tminv=min(lft[s(i-1,j)],rht[s(i-1,j)]);\n\t\t\t\tif(minv){\n\t\t\t\t\ttree1.change(1,1,c,minv,minv,up[s(i-1,j)]);\n\t\t\t\t\ttree2.change(1,1,c,minv,minv,((minv*(minv+1))/2)%mod*up[s(i-1,j)]%mod);\n\t\t\t\t\ttree3.change(1,1,c,minv,minv,minv*up[s(i-1,j)]%mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!col[s(i,j)]){\n\t\t\t\ttree1.clear(),tree2.clear(),tree3.clear();\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n    return 0;\n} \n```",
        "postTime": 1683904382,
        "uid": 116664,
        "name": "Daniel_lele",
        "ccfLevel": 8,
        "title": "P3221 \u9898\u89e3"
    },
    {
        "content": "\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u9053\u9898\u76ee\n\n\u5904\u7406\u51fa\u6765\u6bcf\u4e2a\u4f4d\u7f6e\u5411\u4e0a\u4e0b\u5de6\u53f3\u5206\u522b\u80fd\u6269\u5c55\u591a\u8fdc\n\n\u7136\u540e\u679a\u4e3e\u4e2d\u8f74\u7ebf\u548c\u4e0b\u8fb9\u754c\uff0c\u66b4\u529b\u5c31\u662f\u518d\u679a\u4e3e\u4e00\u4e2a\u4e0a\u8fb9\u754c\u8ba1\u7b97\u7b54\u6848\n\n\u4f60\u53d1\u73b0\u66b4\u529b\u6709 $90$ \u5206\uff0c$BZOJ$ \u4e0a\u9762\u8fc7\u4e86\u3002\u3002\u3002\n\n\u8003\u8651\u4f18\u5316\uff0c\u89c2\u5bdf\u8ba1\u7b97\u7b54\u6848\u7684\u65f6\u5019\u7684\u5199\u6cd5\n\n\u5047\u8bbe\u4e0b\u8fb9\u754c\u7684\u6700\u957f\u534a\u5f84\u4e3a $len1$ \u4e0a\u8fb9\u754c\u7684\u4e3a $len2$\n\n\u5982\u679c $len2 >= len1$ \u90a3\u4e48\u8d21\u732e\u5c31\u662f $\\sum_{i=1}^{len1-1}1=\\frac{len1(len1-1)}{2}$\n\n\u8fd8\u8981\u4e58\u4e0a\u5411\u4e0a\u4e0b\u6269\u5c55\u7684\u957f\u5ea6\uff0c\u4e0a\u8fb9\u754c\u7684\u8d21\u732e\u663e\u7136\u53ef\u4ee5\u7528\u4e00\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\n\n\u5982\u679c $len2 < len1$ \u90a3\u4e48\u8d21\u732e\u5c31\u662f $len2(len2-len1)+\\frac{(len2-1)(len2-2)}{2}$\n\n\u4e5f\u8981\u4e58\u4e0a\u5411\u4e0a\u4e0b\u6269\u5c55\u7684\u957f\u5ea6\uff0c\u628a\u4e0e\u4e0a\u8fb9\u754c\u6709\u5173\u7684\u4e1c\u897f\u63d0\u51fa\u6765\uff0c\u663e\u7136\u53ef\u4ee5\u7528\u4e09\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u8d21\u732e\n\n\u7ec6\u8282\u81ea\u5df1\u6ce8\u610f\u4e00\u4e0b\u5c31\u597d\u4e86\n\n\u6ce8\u610f\u6bcf\u6b21\u662f\u5bf9\u679a\u4e3e\u7684\u4e2d\u8f74\u7ebf\u7684\u4e00\u6bb5\u8fde\u7eed\u7684 $1$ \u505a\u67e5\u8be2\uff0c\u6bcf\u6b21\u8981\u6e05\u7a7a\u6811\u72b6\u6570\u7ec4\n\n```cpp\n# include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nnamespace IO {\n\tconst int maxn(1 << 21 | 1);\n\n\tchar ibuf[maxn], *iS, *iT, c;\n\tint f;\n\n\tinline char Getc() {\n\t\treturn iS == iT ? (iT = (iS = ibuf) + fread(ibuf, 1, maxn, stdin), (iS == iT ? EOF : *iS++)) : *iS++;\n\t}\n\t\n\ttemplate <class Int> inline void In(Int &x) {\n\t\tfor (f = 1, c = Getc(); c < '0' || c > '9'; c = Getc()) f = c == '-' ? -1 : 1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; c = Getc()) x = x * 10 + (c ^ 48);\n\t\tx *= f;\n\t}\n}\n\nusing IO :: In;\n\nconst int mod(1e9 + 9);\nconst int maxn(2e6 + 5);\n\nint n, r, c, mp[maxn], le[maxn], ri[maxn], up[maxn], down[maxn], ans;\n\n# define ID(i, j) (i - 1) * c + j\n\ninline void Inc(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\n\ninline int S(ll x) {\n\treturn (x * (x + 1) >> 1) % mod;\n}\n\nstruct BIT {\n\tint sum[maxn];\n\n\tinline void Init() {\n\t\tfor (int i = 1; i <= c; ++i) sum[i] = 0;\n\t}\n\n\tinline void Clear(int x) {\n\t\tif (x <= 0 || x > c) return;\n\t\tfor (; x <= c; x += x & -x) sum[x] = 0;\n\t}\n\n\tinline void Add(int x, int v) {\n\t\tif (x <= 0 || x > c) return;\n\t\tfor (; x <= c; x += x & -x) Inc(sum[x], v);\n\t}\n\n\tinline int Query(int x) {\n\t\tif (x <= 0 || x > c) return 0;\n\t\tint ret = 0;\n\t\tfor (; x; x ^= x & -x) Inc(ret, sum[x]);\n\t\treturn ret;\n\t}\n} c1, c2, c3, c4;\n\nint main() {\n\tfreopen(\"a.in\", \"r\", stdin);\n\tIn(r), In(c), In(n);\n\tfor (int i = 1, a, b; i <= n; ++i) In(a), In(b), mp[ID(a, b)] = 1;\n\tfor (int i = 1; i <= r; ++i) {\n\t\tfor (int j = 1; j <= c; ++j) {\n\t\t\tint p = ID(i, j);\n\t\t\tup[p] = mp[p] ? 0 : (i == 1 ? 1 : up[p - c] + 1);\n\t\t\tle[p] = mp[p] ? 0 : (j == 1 ? 1 : le[p - 1] + 1);\n\t\t}\n\t\tfor (int j = c; j; --j) {\n\t\t\tint p = ID(i, j);\n\t\t\tri[p] = mp[p] ? 0 : (j == c ? 1 : ri[p + 1] + 1);\n\t\t}\n\t}\n\tfor (int i = r; i; --i)\n\t\tfor (int j = 1; j <= c; ++j) {\n\t\t\tint p = ID(i, j);\n\t\t\tdown[p] = mp[p] ? 0 : (i == r ? 1 : down[p + c] + 1);\n\t\t}\n\tfor (int j = 1, p; j <= c; ++j) {\n\t\tc1.Init(), c2.Init(), c3.Init(), c4.Init();\n\t\tfor (int i = 1, lst = 1; i < r; ++i) {\n\t\t\tif (down[p = ID(i, j)] > 1) {\n\t\t\t\tint len1 = min(le[p], ri[p]) - 1;\n\t\t\t\tif (len1 > 1) {\n\t\t\t\t\tint g = down[p] - 1, s4 = c4.Query(c - len1 + 1);\n\t\t\t\t\tInc(ans, 1LL * g * s4 % mod * S(len1 - 1) % mod);\n\t\t\t\t\tint s1 = c1.Query(len1 - 1), s2 = c2.Query(len1 - 1), s3 = c3.Query(len1 - 1);\n\t\t\t\t\ts1 = (1LL * s1 * len1 % mod - s2 + mod) % mod;\n\t\t\t\t\tInc(s1, s3), Inc(ans, 1LL * g * s1 % mod);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i > 1 && up[p = ID(i - 1, j)] > 1) {\n\t\t\t\tint len1 = min(le[p], ri[p]) - 1;\n\t\t\t\tc4.Add(c - len1 + 1, up[p] - 1);\n\t\t\t\tc3.Add(len1, 1LL * S(len1 - 1) * (up[p] - 1) % mod);\n\t\t\t\tc2.Add(len1, 1LL * len1 * len1 % mod * (up[p] - 1) % mod);\n\t\t\t\tc1.Add(len1, 1LL * len1 * (up[p] - 1) % mod);\n\t\t\t}\n\t\t\tif (mp[ID(i, j)]) {\n\t\t\t\tfor (int k = lst, q; k <= i; ++k) {\n\t\t\t\t\tq = ID(k, j);\n\t\t\t\t\tint len1 = min(le[q], ri[q]) - 1;\n\t\t\t\t\tc4.Clear(c - len1 + 1);\n\t\t\t\t\tc3.Clear(len1), c2.Clear(len1), c1.Clear(len1);\n\t\t\t\t}\n\t\t\t\tlst = i + 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n```",
        "postTime": 1537923862,
        "uid": 47640,
        "name": "Cyhlnj",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3221 \u3010[HNOI2012]\u53cc\u5341\u5b57\u3011"
    },
    {
        "content": "\u6211\u597d\u6c14\u554a\uff01\u539f\u9898\u7684\u65f6\u9650\u662f10s\uff0c\u8fd9\u91cc\u53ea\u67091s\u8fa3\uff0c\u6211\u5982\u4f55\u662f\u597d\u554a\uff01\n\n\u4e3a\u4ec0\u4e48\u4f60\u4eec\u6253\u7684\u90fd\u662f\u6811\u72b6\u6570\u7ec4\u554a\uff0c\u5c31\u6211\u8fd9\u4e2a\u5f31\u9e21\u6253\u7684\u662fsplay\u554a\uff01\n\n\u4ee3\u7801\u6709250+\u884c\u554a\uff0c\u88ab\u5361\u523080\u5206\u554a\uff01\n\n\n```cpp\n#include <bits/stdc++.h>\n\ntypedef long long LL;\n\n#define FOR(i, a, b) for (LL i = (a), i##_END_ = (b); i <= i##_END_; i++)\n#define DNF(i, a, b) for (LL i = (a), i##_END_ = (b); i >= i##_END_; i--)\n\ntemplate <typename Tp> void in(Tp &x) {\n    char ch = getchar(); x = 0;\n    while (ch < '0' || ch > '9') ch = getchar();\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n}\n\ntemplate <typename Tp> Tp Min(Tp x, Tp y) {return x < y ? x : y;}\ntemplate <typename Tp> Tp Max(Tp x, Tp y) {return x > y ? x : y;}\ntemplate <typename Tp> Tp chkmax(Tp &x, Tp y) {return x > y ? x : x=y;}\ntemplate <typename Tp> Tp chkmin(Tp &x, Tp y) {return x < y ? x : x=y;}\n\nusing std::vector;\n\nconst LL MAXN = 10010, MOD = 1000000009;\n\nvector<LL>line[MAXN];\nvector<LL>lr[MAXN], tp[MAXN], co[MAXN];\n\nLL r, c, n;\n\nstruct Node {\n    Node *ch[2], *fa;\n    LL data1, data2, sum1, sum2, sum3, sz;\n\n    void clear();\n    void update();\n    void rotate();\n    void insert(LL, LL);\n    LL get_rnk(LL);\n    void splay(Node*);\n    Node *find_key(LL);\n} *treap;\n\nvoid Node::rotate()\n{\n    Node *pa = fa;\n    fa = pa -> fa; pa -> fa = this;\n    if (fa != NULL) {\n        bool t = (fa -> ch[0] == pa ? 0 : 1);\n        fa -> ch[t] = this;\n    }\n    bool t = (pa -> ch[0] == this ? 0 : 1);\n    Node *chd = ch[t ^ 1];\n    ch[t ^ 1] = pa; pa -> ch[t] = chd;\n    if (chd != NULL) chd -> fa = pa;\n    pa -> update(); update();\n}\n\nvoid Node::splay(Node *top)\n{\n    while (fa != top) {\n        if (fa -> fa != top) {\n            bool t = (fa -> fa -> ch[0] == fa ? 0 : 1);\n            if (fa -> ch[t] == this) fa -> rotate(), rotate();\n            else rotate(), rotate();\n        }\n        else rotate();\n    }\n    if (top == NULL) treap = this;\n}\n\nLL Node::get_rnk(LL now)\n{\n    Node *x = this;\n\n    LL ret = 0;\n    \n    while (true) {\n        if (x -> data1 == now) {\n            return (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) + ret;\n        }\n        if (x -> data1 > now) {\n            if (x -> ch[0] == NULL) return ret;\n            x = x -> ch[0];\n        }\n        else {\n            if (x -> ch[1] == NULL) return x -> sz + ret;\n            ret += (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1);\n            x = x -> ch[1];\n        }\n    }\n}\n\nNode* Node::find_key(LL rnk)\n{\n    Node *x = this;\n    while (true) {\n        if ((x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) == rnk) return x;\n        else if ((x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1) < rnk) {\n            rnk -= (x -> ch[0] == NULL ? 1 : x -> ch[0] -> sz + 1);\n            x = x -> ch[1];\n        }\n        else x = x -> ch[0];\n    }\n}\n\nvoid Node::insert(LL now, LL now2)\n{\n    if (treap == NULL) {\n        Node *hr = new Node;\n        hr -> ch[0] = hr -> ch[1] = hr -> fa = NULL;\n        hr -> data1 = now; hr -> data2 = now2; treap = hr; treap -> update();\n        return;\n    }\n    LL rnk = treap -> get_rnk(now);\n    if (rnk == 0) {\n        Node *hr = new Node;\n        hr -> ch[0] = hr -> fa = NULL;\n        hr -> ch[1] = treap; hr -> data1 = now; hr -> data2 = now2;\n        treap -> fa = hr; hr -> update();\n        treap = hr;\n    }\n    else if (rnk == treap -> sz) {\n        Node *hr = new Node;\n        hr -> ch[1] = hr -> fa = NULL;\n        hr -> ch[0] = treap; hr -> data1 = now; hr -> data2 = now2;\n        treap -> fa = hr; hr -> update();\n        treap = hr; \n    }\n    else {\n        Node *hr = new Node;\n        treap -> find_key(rnk) -> splay(NULL);\n        treap -> find_key(rnk + 1) -> splay(treap);\n        hr -> data1 = now;\n        hr -> data2 = now2;\n        hr -> ch[0] = NULL;\n        hr -> ch[1] = treap -> ch[1];\n        hr -> fa = treap; treap -> ch[1] = hr;\n        hr -> ch[1] -> fa = hr; hr -> update(); treap -> update();\n    }\n}\n\nvoid Node::clear()\n{\n    if (ch[0] != NULL) ch[0] -> clear();\n    if (ch[1] != NULL) ch[1] -> clear();\n    delete this;\n}\n\nvoid Node::update()\n{\n    sz = 1;\n    sum1 = data1 * data2 % MOD;\n    sum2 = (data1 * (data1 + 1) / 2) * data2 % MOD;\n    sum3 = data2;\n\n    if (ch[0] != NULL) {\n        sz += ch[0] -> sz;\n        sum1 = (sum1 + ch[0] -> sum1) % MOD;\n        sum2 = (sum2 + ch[0] -> sum2) % MOD;\n        sum3 = (sum3 + ch[0] -> sum3) % MOD;\n    }\n    if (ch[1] != NULL) {\n        sz += ch[1] -> sz;\n        sum1 = (sum1 + ch[1] -> sum1) % MOD;\n        sum2 = (sum2 + ch[1] -> sum2) % MOD;\n        sum3 = (sum3 + ch[1] -> sum3) % MOD;\n    }\n}\n\nint main()\n{\n    freopen(\"cross.in\", \"r\", stdin);\n    freopen(\"cross.out\", \"w\", stdout);\n    \n    in(r); in(c); in(n);\n\n    FOR(i, 0, r + 1) {\n        lr[i].resize(c + 2);\n        tp[i].resize(c + 2);\n        co[i].resize(c + 2);\n        line[i].resize(c + 2);\n    }\n\n    FOR(i, 1, r) FOR(j, 1, c) line[i][j] = 1;\n    \n    FOR(i, 1, n) {\n        LL x, y;\n        in(x); in(y);\n        line[x][y] = 0;\n    }\n\n    FOR(i, 1, r) {\n        FOR(j, 1, c) {\n            if (line[i][j] == 0) continue;\n            if (j == 1 || line[i][j - 1] == 0) lr[i][j] = 0;\n            else lr[i][j] = lr[i][j - 1] + 1;\n        }\n        DNF(j, c, 1) {\n            if (line[i][j] == 0) continue;\n            if (j == c || line[i][j + 1] == 0) lr[i][j] = 0;\n            else chkmin(lr[i][j], lr[i][j + 1] + 1);\n        }\n\n        FOR(j, 1, c) if (line[i][j]) {\n            if (i == 1 || !line[i - 1][j]) tp[i][j] = 0;\n            else tp[i][j] = tp[i - 1][j] + 1;\n        }\n    }\n\n    DNF(i, r, 1) {\n        FOR(j, 1, c) if (line[i][j]) {\n            if (i == r || !line[i + 1][j]) co[i][j] = 0;\n            else co[i][j] = co[i + 1][j] + 1;\n        }\n    }\n\n    treap = NULL;\n    bool is_cleared = true;\n\n    LL ans = 0;\n    \n    FOR(j, 1, c) {\n        if (!is_cleared) {\n            treap -> clear();\n            treap = NULL;\n            is_cleared = true;\n        }\n\n        FOR(i, 1, r) {\n            if (i > 2) {\n                if (lr[i - 2][j] != 0 && line[i - 1][j]) {\n                    treap -> insert(lr[i - 2][j], tp[i - 2][j]);\n                    is_cleared = false;\n                }\n            }\n            \n            if (!line[i][j]) {\n                if (!is_cleared) {\n                    treap -> clear();\n                    treap = NULL;\n                    is_cleared = true;\n                }\n                continue;\n            }\n\n            LL now = lr[i][j];\n            \n            if (now && treap != NULL) {\n                LL rnk = treap -> get_rnk(now);\n                if (rnk != 0) {\n                    Node *hr;\n                    if (rnk != treap -> sz) {\n                        treap -> find_key(rnk + 1) -> splay(NULL);\n                        treap -> find_key(rnk) -> splay(treap);\n                        hr = treap -> ch[0];\n                    }\n                    else {\n                        treap -> find_key(rnk) -> splay(NULL);\n                        hr = treap;\n                    }\n                    LL fst = hr -> sum1 * now % MOD * co[i][j] % MOD;\n                    LL sec = hr -> sum2 * co[i][j] % MOD;\n                    ans = (ans + fst - sec) % MOD;\n                }\n\n                if (rnk != treap -> sz) {\n                    Node *hr;\n                    if (rnk != 0) {\n                        treap -> find_key(rnk) -> splay(NULL);\n                        treap -> find_key(rnk + 1) -> splay(treap);\n                        hr = treap -> ch[1];\n                    }\n                    else {\n                        treap -> find_key(rnk + 1) -> splay(NULL);\n                        hr = treap;\n                    }\n                    LL valu =\n                        (now * now - now * (now + 1) / 2) * co[i][j] % MOD;\n                    ans = (ans + hr -> sum3 * valu % MOD) % MOD;\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n        \n    return 0;\n}\n\n```",
        "postTime": 1490971704,
        "uid": 30363,
        "name": "pengyihao",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3221 \u3010[HNOI2012]\u53cc\u5341\u5b57\u3011"
    }
]