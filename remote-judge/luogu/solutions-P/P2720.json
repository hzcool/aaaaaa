[
    {
        "content": "\u8003\u8651\u7528\u6743\u503c\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5b50\u6811\u5185\u7684\u6240\u6709\u989c\u8272\uff0c\u7136\u540e\u56e0\u4e3a\u6b64\u9898\u4e0d\u5e26\u4fee\uff0c\u76f4\u63a5\u4e0a\u6811\u4e0a\u7ebf\u6bb5\u6811\u5408\u5e76\u5c31\u597d\u4e86\uff0c\u590d\u6742\u5ea6\u662f\u5341\u5206\u6b63\u786e\u7684$O(n\\log n)$\u3002\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N=1e5+10;\nstruct sgnd{int ls,rs,sum;};\n\nsgnd t[N*20];\nint rt[N],st[N],top,cnt;\n\nint nnd() {return top?st[top--]:++cnt;}\nvoid dnd(int&x) {memset(&t[x],0,sizeof t[x]);st[++top]=x;x=0;}\nvoid ist(int&x,int l,int r,int p) {\n\tif(!x) x=nnd();\n\tif(l==r) {t[x].sum=1;return;}\n\tint mid=(l+r)>>1;\n\tif(p<=mid) ist(t[x].ls,l,mid,p);\n\telse ist(t[x].rs,mid+1,r,p);\n\tt[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;\n}\nvoid mge(int&x,int&y,int l,int r) {\n\tif(!y) return;\n\tif(!x) {x=y;y=0;return;}\n\tif(l==r) t[x].sum|=t[y].sum;\n\telse {\n\t\tint mid=(l+r)>>1;\n\t\tmge(t[x].ls,t[y].ls,l,mid);\n\t\tmge(t[x].rs,t[y].rs,mid+1,r);\n\t\tt[x].sum=t[t[x].ls].sum+t[t[x].rs].sum;\n\t}\n\tdnd(y);\n}\n\nint n,m,c;\nint val[N],fa[N],knd[N];\nlist<int> ch[N];\n\nvoid dfs(int x) {\n\tfor(int y:ch[x]) dfs(y);\n\tist(rt[x],1,c,val[x]);\n\tknd[x]=t[rt[x]].sum;\n\tif(x!=1) mge(rt[fa[x]],rt[x],1,c);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=2; i<=n; ++i) {\n\t\tscanf(\"%d\",&fa[i]);\n\t\tch[fa[i]].push_back(i);\n\t}\n\tfor(int i=1; i<=n; ++i) {\n\t\tscanf(\"%d\",&val[i]);\n\t\tc=max(c,val[i]);\n\t}\n\tdfs(1);\n\tscanf(\"%d\",&m);\n\tfor(int x; m--; ) {\n\t\tscanf(\"%d\",&x);\n\t\tprintf(\"%d\\n\",knd[x]);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1553243312,
        "uid": 125139,
        "name": "nosta",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P2720 \u3010\u5c0fA\u7684\u793c\u7269\u3011"
    },
    {
        "content": "\u5404\u4f4d\u90fd\u4f1a\u83ab\u961f\uff0c\u6211\u4e0d\u4f1a\uff0c\u4e8e\u662f\u6211\u5c31\u4ea4\u4e86\u4e2a\u6811\u5957\u6811\n\n\u9996\u5148\u5206\u6790\u56fe\u7684\u6027\u8d28\uff1a\n\n1.\u4e3a\u4e86\u9632\u6b62\u591a\u6b21\u9886\u793c\u7269\uff0c\u8fd9\u4e9b\u9053\u8def\u90fd\u662f\u5355\u5411\u7684\u9053\u8def\uff0c\u5e76\u4e14\u6ca1\u6709\u73af  \n\n\u5206\u6790\uff1a**DAG**\n\n2.\u800c\u4e14\u5bf9\u4e8e\u6bcf\u6761\u8fb9\u8054\u63a5a\uff0cb\u70b9\uff0c\u5982\u679c\u5220\u53bb\u8fd9\u6761\u8fb9\u4e4b\u540e\uff0c\u5b58\u5728\u70b9c\u53ef\u4ee5\u5230\u8fbea\uff0c\u4e5f\u80fd\u5230\u8fbeb\uff0c\u90a3\u4e48\u8fd9\u6761\u8fb9\u5c31\u4e0d\u4f1a\u5b58\u5728\u4e8e\u8def\u5f84\u4e2d \n\n\u5206\u6790\uff1a\u4e5f\u5c31\u662f\u8bf4\u4e0d\u4f1a\u5b58\u5728\u7c7b\u4f3c\u8fd9\u79cd\u4e1c\u897f\uff0c\u4e0d\u80fd\u6709\u4e2d\u95f4\u7684\u9ed1\u8fb9![luogu](https://cdn.luogu.com.cn/upload/pic/52968.png)\n\n3.\u5e76\u4e14\u9664\u4e86\u70b91\u4e4b\u5916\uff0c\u6240\u6709\u70b9\u6709\u4e14\u53ea\u6709\u4e00\u6761\u5165\u8fb9&\u4fdd\u8bc11\u53f7\u70b9\u53ef\u5230\u8fbe\u6240\u6709\u70b9\n\n\u5206\u6790\uff1a\u663e\u7136\u5c31\u957f\u5f97\u50cf\u4e2a\u4ee51\u4f4d\u6839\u8282\u70b9\u7684\u6811\n\n\u4e8e\u662f\u6211\u4eec\u5c31\u53ef\u4ee5\u7528dfs\u5e8f\u8f6c\u5316\u4e3a\u8fde\u7eed\u533a\u95f4 \u7136\u540e\u8dd1[P1903 [\u56fd\u5bb6\u96c6\u8bad\u961f]\u6570\u989c\u8272 / \u7ef4\u62a4\u961f\u5217 ](https://www.luogu.org/problemnew/show/P1903)\n\n[\u6211\u7684\u6811\u5957\u6811\u8be6\u89e3](https://www.luogu.org/blog/van/solution-p1903)\n\n\u4e8e\u662f\u6211\u5c31\u5199\u4e86\u4e2a\u7ebf\u6bb5\u6811\u5957Splay\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing std::max;\nusing std::min;\ntemplate<class type>inline const void read(type &in)\n{\n    in=0;char ch=getchar();short fh=1;\n    while (ch<48||ch>57)fh=ch=='-'?-1:fh,ch=getchar();\n    while (ch>47&&ch<58)in=(in<<3)+(in<<1)+ch-48,ch=getchar();\n    in*=fh;\n}\nconst int N=1e5+10,C=6e4+10;\nint n,q,last[N],tmp[N],tot,col[N];\nint head[N],cnt,to[N],next[N];\ninline const void addedge(int u,int v)\n{\n    next[++cnt]=head[u];\n    to[head[u]=cnt]=v;\n}\nint ranking,l[N],r[N],org[N];\ninline const void renumber(int p) //\u91cd\u65b0\u7f16\u53f7\uff0c\u6211\u662f\u53f6\u8282\u70b9l=r=dfs\u5e8f\uff0c\u975e\u53f6\u8282\u70b9l=min{l[son]},r=max{r[son]}\uff0c\u4e5f\u53ef\u4ee5\u6240\u6709\u7684\u70b9\u90fd\u5904\u7406dfn\u548csize\uff0c\u7136\u540e\u533a\u95f4\u5c31\u662f[dfn[x],dfn[x]+size[x]-1]\n{\n    l[p]=n;r[p]=1;\n    for (int i=head[p];i;i=next[i])\n        renumber(to[i]),\n        l[p]=min(l[to[i]],l[p]),\n        r[p]=max(r[to[i]],r[p]);\n    ranking++;\n    if (!head[p])l[p]=r[p]=ranking;\n    else l[p]=min(l[p],ranking),r[p]=max(r[p],ranking);\n    org[ranking]=p;\n}\nnamespace Splay\n{\n    struct tree\n    {\n        int val,cnt,size;\n        tree *fa,*son[2];\n        inline const void pushup()\n        {\n            size=son[0]->size+cnt+son[1]->size;\n        }\n        inline const bool identity()\n        {\n            return fa->son[1]==this;\n        }\n    }memory_pool[N<<6],*recycle[N<<6],*tail,*null,*root[C];\n    int top;\n    inline const void init()\n    {\n        tail=memory_pool;\n        null=tail++;\n        null->val=null->cnt=null->size=top=0;\n        null->fa=null->son[0]=null->son[1]=null;\n        std::fill(root+1,root+C,null);\n    }\n    inline tree *spawn(int key)\n    {\n        tree *p=top?recycle[--top]:tail++;\n        p->val=key;\n        p->size=p->cnt=1;\n        p->fa=p->son[0]=p->son[1]=null;\n        return p;\n    }\n    inline const void erase(tree *&p)\n    {\n        recycle[top++]=p;\n        p=null;\n    }\n    inline const void connect(tree *p,tree *fa,bool which)\n    {\n        if (p!=null)p->fa=fa;\n        if (fa!=null)fa->son[which]=p,fa->pushup();\n    }\n    inline const void rotate(tree *p)\n    {\n        tree *fa=p->fa;\n        bool id=p->identity();\n        connect(p,fa->fa,fa->identity());\n        connect(p->son[id^1],fa,id);\n        connect(fa,p,id^1);\n    }\n    inline const void splay(tree *&root,tree *p)\n    {\n        for (tree *fa;(fa=p->fa)!=null;rotate(p))\n            if (fa->fa!=null)\n                rotate(p->identity()^fa->identity()?fa:p);\n        root=p;\n    }\n    inline const void insert(tree *&root,int key)\n    {\n        if (root==null)return (void)(root=spawn(key));\n        tree *now=root;\n        while (1)\n        {\n            if (now->val==key)\n                return now->cnt++,now->pushup(),splay(root,now);\n            tree *fa=now;\n            bool nxt=fa->val<key;\n            now=fa->son[nxt];\n            if (now==null)\n                return now=spawn(key),connect(now,fa,nxt),splay(root,now);\n        }\n    }\n    inline const void find(tree *&root,int key)\n    {\n        tree *now=root;\n        if (now==null)return;\n        while (now->son[now->val<key]!=null&&now->val!=key)\n            now=now->son[now->val<key];\n        splay(root,now);\n    }\n    inline tree *precursor(tree *&root,int key)\n    {\n        find(root,key);\n        if (root->val<key)return root;\n        tree *now=root->son[0];\n        while (now->son[1]!=null)now=now->son[1];\n        return now;\n    }\n    inline tree *successor(tree *&root,int key)\n    {\n        find(root,key);\n        if (root->val>key)return root;\n        tree *now=root->son[1];\n        while (now->son[0]!=null)now=now->son[0];\n        return now;\n    }\n    inline const void Delete(tree *&root,int key)\n    {\n        find(root,key);tree *p=root;\n        if (p->cnt>1)return p->cnt--,p->pushup();\n        if (p->son[0]==null&&p->son[1]==null)return root=null,erase(p);\n        if (p->son[0]==null)return (root=p->son[1])->fa=null,erase(p);\n        if (p->son[1]==null)return (root=p->son[0])->fa=null,erase(p);\n        tree *pre=precursor(root,key);splay(root,pre);connect(p->son[1],pre,1);erase(p);\n    }\n    inline const int less(tree *&root,int key)\n    {\n        tree *now=root;int tot=0;\n        while (now!=null)\n            if (key<now->val)now=now->son[0];\n            else\n            {\n                tot+=now->son[0]->size;\n                if (now->val==key)return tot;\n                tot+=now->cnt;\n                now=now->son[1];\n            }\n        return tot;\n    }\n}using namespace Splay;\nclass Segment_Tree\n{\n    private:\n        struct tree\n        {\n            Splay::tree *root;\n            tree *lson,*rson;\n            inline const void update(int l,int r,int pos,int key)\n            {\n                Delete(root,last[pos]);\n                insert(root,key);\n                if (l==r)return;\n                int mid=l+r>>1;\n                if (pos<=mid)lson->update(l,mid,pos,key);\n                else rson->update(mid+1,r,pos,key);\n            }\n            inline const int query(int l,int r,int L,int R)\n            {\n                if (l>R||r<L)return 0;\n                if (l>=L&&r<=R)return less(root,L);\n                int mid=l+r>>1;\n                return lson->query(l,mid,L,R)+rson->query(mid+1,r,L,R);\n            }\n        }memory_pool[N<<2],*tail;\n        inline const void init()\n        {\n            tail=memory_pool;\n        }\n        inline tree *spawn()\n        {\n            tree *p=tail++;\n            p->root=null;\n            p->lson=p->rson=NULL;\n            return p;\n        }\n    public:\n        tree *root;\n        inline Segment_Tree(){init();}\n        inline const void build(tree *&p,int l,int r)\n        {\n            p=spawn();\n            for (int i=l;i<=r;i++)\n                insert(p->root,last[i]);\n            if (l==r)return;\n            int mid=l+r>>1;\n            build(p->lson,l,mid);\n            build(p->rson,mid+1,r);\n        }\n}sgt;\nint main()\n{\n    read(n);int x;\n    for (int i=2;i<=n;i++)read(x),addedge(x,i);\n    for (int i=1;i<=n;i++)read(col[i]);\n    renumber(1);init();\n    for (int i=1;i<=n;i++)\n        x=col[org[i]],\n        last[i]=tmp[x],\n        insert(root[x],tmp[x]=i);\n    sgt.build(sgt.root,1,n);\n    read(q);\n    while (q--)\n        read(x),printf(\"%d\\n\",sgt.root->query(1,n,l[x],r[x]));\n    return 0;\n}\n```",
        "postTime": 1551434964,
        "uid": 14374,
        "name": "zhengrunzhe",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P2720 \u3010\u5c0fA\u7684\u793c\u7269\u3011"
    },
    {
        "content": "\u8ddf\u5927\u5bb6\u8bf4\u4e00\u4e2a\u4e8b\uff0c\u4e4b\u524d\u7684std\u662f\u9519\u7684\uff0c\u4f5c\u8005dfs\u7684\u65f6\u5019\u5fd8\u8bb0\u7ed9\u6570\u7ec4\u91cd\u6807\u53f7\u4e86......\n\n\u5c31\u7b80\u5355\u8bf4\u5427\u3002\u672c\u9898\u505a\u6cd5\u5f88\u591a\uff0c\u53ef\u4ee5dfs\u540e\u8f6c\u4e3a\u533a\u95f4\u9898\uff0c\u7136\u540e\u5c31\u662f\u533a\u95f4\u5904\u7406\u4e86\u3002\uff08std\u5c31\u662f\u8fd9\u4e48\u6253\u7684\uff0c\u7528\u83ab\u961f\uff09\n\n\u4f46\u662f\u53d1\u73b0n\u53ea\u67091e5\uff0c\u8c8c\u4f3c$\\frac{nc}{\\omega}$\u4e5f\u53ef\u4ee5\u8fc7\u3002\u7136\u540e\u5c31\u771f\u7684\u80fd\u8fc7\u3002\u3002\u3002\u3002\u3002\u3002\u76f4\u63a5dfs\u65f6\u7528bitset\u7ef4\u62a4\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#include<cctype>\n#define For(i,a,b) for(i=(a),i##end=(b);i<=i##end;++i)\n#define Forward(i,a,b) for(i=(a),i##end=(b);i>=i##end;--i)\n#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)\n#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)\nusing namespace std;\ntemplate<typename T>inline void read(T &x){\n    T s=0,f=1;char k=getchar();\n    while(!isdigit(k)&&k^'-')k=getchar();\n    if(!isdigit(k)){f=-1;k=getchar();}\n    while(isdigit(k)){s=s*10+(k^48);k=getchar();}\n    x=s*f;\n}\nvoid file(void){\n    #ifndef ONLINE_JUDGE\n    freopen(\"input8.in\",\"r\",stdin);\n    freopen(\"water.out\",\"w\",stdout);\n    #endif\n}\nvector<bitset<60011> >G;\nbitset<60011> emp;\nconst int MAXN=100101;\nstatic struct edge\n{\n    int v,next;\n}p[MAXN];\nstatic int head[MAXN],e,ans[MAXN],w[MAXN],sz=-1,n,m,b[MAXN],tt;\ninline void add(int u,int v){p[++e].v=v;p[e].next=head[u];head[u]=e;}\nbool flag;\nvoid dfs(int u)\n{\n    G.push_back(emp);G[++sz].set(w[u]);\n    for(register int v=head[u];v;v=p[v].next)\n        dfs(p[v].v);\n    ans[u]=G[sz].count();\n    if(sz)G[sz-1]|=G[sz];--sz;G.pop_back();\n}\n#define Find(x) (lower_bound(b+1,b+tt+1,x)-b);\nvoid init()\n{\n    read(n);\n    static int f;\n    Rep(i,2,n)read(f),add(f,i);\n    Rep(i,1,n)read(w[i]),b[i]=w[i];\n    sort(b+1,b+n+1);tt=unique(b+1,b+n+1)-b-1;\n    //Rep(i,1,n)w[i]=Find(w[i])-1;\n    dfs(1);\n}\nvoid solve()\n{\n    read(m);\n    static int x;\n    Rep(i,1,m)\n    {\n        read(x);printf(\"%d\\n\",ans[x]);\n    }\n}\nint main(void){\n    file();\n    init();\n    solve();\n    return 0;\n}\n\n```\n\n\u518d\u9644\u4e0a\u7f6a\u6076\u7684std\u3002(\u5df2\u4fee\u6539)\n\n```cpp\n#include<bits/stdc++.h>\n#define N 100005\nusing namespace std;\nvector<int> E[100005];\nstruct question\n{\n    int l,r;\n    int s;\n}ques[N];\nstruct orz\n{\n    int l,r;\n}sec[N];\nint size;\nbool cmp(question a , question b)\n{\n    int x = (a.l-1)/size,y = (b.l-1)/size;\n    if(x != y) return x < y;\n    return a.r < b.r;\n}\nint n;\nint a[N],w[N];\nlong long ans[N];\nlong long last[N];\nlong long lastsum;\ninline void asks(int lastl,int lastr,int left,int right,int k)\n{\n //   printf(\"%d %d %d %d %d\\n\",lastl,lastr,left,right,k);\n    if(lastr < right)\n        for(int i = lastr + 1;i <= right;i++)\n        {\n            if(last[a[i]] == 0) lastsum++;\n            last[a[i]]++;\n        }\n    else if(lastr > right)\n        for(int i = right + 1;i <= lastr;i++)\n        {\n            last[a[i]]--;\n            if(last[a[i]] == 0) lastsum--;\n        }\n   // printf(\"lastsum = %d\\n\",lastsum);\n    if(lastl < left)\n        for(int i = lastl;i <= left - 1;i++)\n        {\n            last[a[i]]--;\n            if(last[a[i]] == 0) lastsum--;\n        }\n    else if(lastl > left)\n        for(int i = left;i <= lastl - 1;i++)\n        {\n            if(last[a[i]] == 0) lastsum++;\n            last[a[i]]++;\n        }\n    int cnt=0;\n    // printf(\"lastsum = %d\\n\",lastsum);\n    ans[k]= lastsum;\n    return;\n}\ninline void add(int u,int v)\n{\n    E[u].push_back(v);\n}\nint dfst = 0;\nbool flag;\nvoid dfs(int u)\n{\n    dfst++;a[dfst]=w[u];\n    sec[u].l = dfst;\n    for(int i = 0;i < E[u].size();i++)\n        dfs(E[u][i]);\n    sec[u].r = dfst;\n    return;\n}\nint main()\n{\n    int q;\n    freopen(\"input1.in\",\"r\",stdin);\n    freopen(\"output1.out\",\"w\",stdout);\n    memset(last,0,sizeof(last));\n    scanf(\"%d\",&n);\n    for(int i = 2;i <= n;i++)\n    {\n        int s;\n        scanf(\"%d\",&s);\n        add(s,i);\n    }\n    int l,r;\n    size = (int)sqrt(n)+1;\n    for(int i = 1;i <= n;i++)\n    {\n        scanf(\"%d\",&w[i]);//\u539f\u6765\u76f4\u63a5\u8f93\u5165a[i]\uff0c\u7136\u540e\u5c31\u6ca1\u6709\u91cd\u6807\u53f7\uff0c\u5c31\u51c9\u4e86\n    }\n    dfs(1);\n    scanf(\"%d\",&q);\n    for(int i = 0;i < q;i++)\n    {\n        int p;\n        scanf(\"%d\",&p);\n        ques[i].l = sec[p].l;\n        ques[i].r = sec[p].r;\n        ques[i].s = i;\n    }\n    sort(ques,ques+q,cmp);\n    l = 1,r = 1;\n    lastsum = 1;\n    last[a[1]] = 1;\n    for(int i = 0;i < q;i++)\n    {\n        asks(l,r,ques[i].l,ques[i].r,ques[i].s);\n        l = ques[i].l,r = ques[i].r;\n    }\n    for(int i = 0;i < q;i++)\n        printf(\"%d\\n\",ans[i]);\n    return 0;\n}\n```",
        "postTime": 1519958800,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2720 \u3010\u5c0fA\u7684\u793c\u7269\u3011"
    }
]