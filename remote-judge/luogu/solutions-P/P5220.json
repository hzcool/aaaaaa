[
    {
        "content": "\u672c\u6587\u540c\u6b65\u53d1\u8868\u4e8e\u6211\u7684\u535a\u5ba2\uff1ahttps://www.alpha1022.me/articles/lg-5220.htm\n\n\u8fd9\u9898\u867d\u7136\u539f idea \u662f\u6211\u7684\uff0c\u4f46\u662f noname \u6539\u4e86\u4e4b\u540e\u6211\u5c31\u4e00\u76f4\u5495\u5495\u5495\u6ca1\u505a\u4e86\u3002  \n\u4eca\u5929\u95f2\u5f97\u53d1\u614c\u6765\u7ec3\u624b\u901f\u2026\u2026\n\n\u5199\u5b8c\u8fd9\u9898\u7684\u7b2c\u4e00\u611f\u89c9\u662f\u53ef\u4ee5\u56de\u53bb\u628a\u300cSDOI2011\u300d\u989c\u8272 \u7684\u5751\u7ed9\u586b\u4e86\uff08\u867d\u7136\u6211\u8fd8\u662f\u6ca1\u6253\u7b97\u5199\n\n\u5176\u5b9e\u505a\u6cd5\u6bd4\u8f83\u663e\u7136\uff0c\u5148\u8003\u8651\u5728\u5e8f\u5217\u4e0a\u7684\u505a\u6cd5\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c \u548c\u533a\u95f4\u79ef\uff0c\u90a3\u4e48\u5408\u5e76\u5de6\u53f3\u5b50\u6811\u7684\u65f6\u5019\uff0c\u6839\u636e\u4e58\u6cd5\u5206\u914d\u5f8b\u53ef\u5f97\uff1a\n\n$$\\sum_{i=l}^r\\prod_{j=i}^r a_j = \\prod_{i=m+1}^r a_i\\left(\\sum_{i=l}^m\\prod_{j=i}^m a_j\\right) + \\sum\\limits_{i=m+1}^r\\prod\\limits_{j=i}^r a_j (m \\in [l,r))$$\n\n\u4e8e\u662f\u5c31\u663e\u7136\u3002\n\n\u8003\u8651\u628a\u8fd9\u4e2a\u505a\u6cd5\u653e\u5230\u6811\u4e0a\uff0c\u4f46\u662f\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53d1\u73b0\u5982\u679c\u628a\u8def\u5f84\u4ece LCA \u5212\u5206\u6210\u4e24\u6bb5\u7684\u8bdd\uff0c\u6709\u4e00\u6bb5\u9700\u8981\u7528\u4e0e\u7b54\u6848\u76f8\u53cd**\u524d\u7f00\u79ef\u4e4b\u548c**\u6765\u7edf\u8ba1\uff0c\u4e8e\u662f\u6539\u4e00\u6539\u7ebf\u6bb5\u6811\u5c31\u597d\u4e86\u3002\n\n\u5173\u4e8e\u6b64\u9898\u6811\u5256\u505a\u6cd5\u7684\u7801\u91cf\u74f6\u9888\uff0c\u6211\u8ba4\u4e3a\u5e94\u8be5\u5728\u4e8e\u67e5\u8be2\u7684\u8fc7\u7a0b\u2026\u2026  \n\u5fc5\u987b\u4fdd\u8bc1\u601d\u8def\u6e05\u6670\u624d\u80fd\u4e0d\u5199\u9519\u3002\n\n\u7136\u540e\u662f\u53d6\u6a21\u7684\u95ee\u9898\uff0c\u867d\u7136\u6a21\u6570\u5f88\u5c0f\u4f46\u662f\u4e5f\u5370\u8bc1\u4e86\u90a3\u53e5\u8bdd\uff1a\n\n> \u4e0d\u5f00 long long \u89c1\u7956\u5b97\uff0c\u5341\u5e74 OI \u4e00\u573a\u7a7a\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#define ls (p << 1)\n#define rs (ls | 1)\nusing namespace std;\nconst int N = 1e5;\nconst long long mod = 20924;\nint n,m;\nlong long a[N + 5];\nint to[(N << 1) + 5],pre[(N << 1) + 5],first[N + 5];\ninline void add(int u,int v)\n{\n\tstatic int tot = 0;\n\tto[++tot] = v;\n\tpre[tot] = first[u];\n\tfirst[u] = tot;\n}\nint fa[N + 5],dep[N + 5],sz[N + 5],son[N + 5],top[N + 5],id[N + 5],rk[N + 5];\nvoid dfs1(int p)\n{\n\tsz[p] = 1;\n\tfor(register int i = first[p];i;i = pre[i])\n\t\tif(to[i] ^ fa[p])\n\t\t{\n\t\t\tfa[to[i]] = p,dep[to[i]] = dep[p] + 1;\n\t\t\tdfs1(to[i]),sz[p] += sz[to[i]];\n\t\t\tif(!son[p] || sz[to[i]] > sz[son[p]])\n\t\t\t\tson[p] = to[i];\n\t\t}\n}\nvoid dfs2(int p)\n{\n\tstatic int tot = 0;\n\trk[id[p] = ++tot] = p;\n\tif(!son[p])\n\t\treturn ;\n\ttop[son[p]] = top[p],dfs2(son[p]);\n\tfor(register int i = first[p];i;i = pre[i])\n\t\tif(!id[to[i]])\n\t\t\ttop[to[i]] = to[i],dfs2(to[i]);\n}\nstruct segnode\n{\n\tlong long prod,sufsum,presum;\n} seg[(N << 2) + 10];\nvoid build(int p,int tl,int tr)\n{\n\tif(tl == tr)\n\t{\n\t\tseg[p].prod = seg[p].sufsum = seg[p].presum = a[rk[tl]];\n\t\treturn ;\n\t}\n\tint mid = tl + tr >> 1;\n\tbuild(ls,tl,mid);\n\tbuild(rs,mid + 1,tr);\n\tseg[p].prod = seg[ls].prod * seg[rs].prod % mod;\n\tseg[p].sufsum = (seg[ls].sufsum * seg[rs].prod % mod + seg[rs].sufsum) % mod;\n\tseg[p].presum = (seg[rs].presum * seg[ls].prod % mod + seg[ls].presum) % mod;\n}\nvoid modify(int x,int k,int p,int tl,int tr)\n{\n\tif(tl == tr)\n\t{\n\t\tseg[p].prod += k,seg[p].sufsum += k,seg[p].presum += k;\n\t\treturn ;\n\t}\n\tint mid = tl + tr >> 1;\n\tif(x <= mid)\n\t\tmodify(x,k,ls,tl,mid);\n\telse\n\t\tmodify(x,k,rs,mid + 1,tr);\n\tseg[p].prod = seg[ls].prod * seg[rs].prod % mod;\n\tseg[p].sufsum = (seg[ls].sufsum * seg[rs].prod % mod + seg[rs].sufsum) % mod;\n\tseg[p].presum = (seg[rs].presum * seg[ls].prod % mod + seg[ls].presum) % mod;\n}\nlong long query_prod(int l,int r,int p,int tl,int tr)\n{\n\tif(l <= tl && tr <= r)\n\t\treturn seg[p].prod;\n\tint mid = tl + tr >> 1;\n\tlong long ret = 1;\n\tif(l <= mid)\n\t\tret = ret * query_prod(l,r,ls,tl,mid) % mod;\n\tif(r > mid)\n\t\tret = ret * query_prod(l,r,rs,mid + 1,tr) % mod;\n\treturn ret;\n}\nlong long query_sufsum(int l,int r,int p,int tl,int tr)\n{\n\tif(l <= tl && tr <= r)\n\t\treturn seg[p].sufsum;\n\tint mid = tl + tr >> 1;\n\tif(l <= mid && r > mid)\n\t\treturn (query_sufsum(l,r,ls,tl,mid) * query_prod(l,r,rs,mid + 1,tr) % mod + query_sufsum(l,r,rs,mid + 1,tr)) % mod;\n\tif(l <= mid)\n\t\treturn query_sufsum(l,r,ls,tl,mid);\n\telse\n\t\treturn query_sufsum(l,r,rs,mid + 1,tr);\n}\nlong long query_presum(int l,int r,int p,int tl,int tr)\n{\n\tif(l <= tl && tr <= r)\n\t\treturn seg[p].presum;\n\tint mid = tl + tr >> 1;\n\tif(l <= mid && r > mid)\n\t\treturn (query_presum(l,r,rs,mid + 1,tr) * query_prod(l,r,ls,tl,mid) % mod + query_presum(l,r,ls,tl,mid)) % mod;\n\tif(l <= mid)\n\t\treturn query_presum(l,r,ls,tl,mid);\n\tif(r > mid)\n\t\treturn query_presum(l,r,rs,mid + 1,tr);\n}\npair<int,int> getlca(int x,int y)\n{\n\twhile(top[x] ^ top[y])\n\t\tdep[top[x]] > dep[top[y]] ? x = fa[top[x]] : y = fa[top[y]];\n\treturn dep[x] < dep[y] ? make_pair(x,0) : make_pair(y,1);\n}\nlong long query(int x,int y)\n{\n\tpair<int,int> t = getlca(x,y);\n\tint lca = t.first,w = t.second;\n\tvector< pair<int,int> > range;\n\twhile(top[x] ^ top[lca])\n\t\trange.push_back(make_pair(id[top[x]],id[x])),x = fa[top[x]];\n\tif(w)\n\t\trange.push_back(make_pair(id[lca],id[x]));\n\tlong long temp = 0,prod = 1;\n\tfor(register int i = range.size() - 1;~i;--i)\n\t\ttemp = (temp + query_presum(range[i].first,range[i].second,1,1,n) * prod % mod) % mod,prod = prod * query_prod(range[i].first,range[i].second,1,1,n) % mod;\n\trange.clear();\n\twhile(top[y] ^ top[lca])\n\t\trange.push_back(make_pair(id[top[y]],id[y])),y = fa[top[y]];\n\tif(!w)\n\t\trange.push_back(make_pair(id[lca],id[y]));\n\tlong long ret = 0;\n\tprod = 1;\n\tfor(register int i = 0;i < range.size();++i)\n\t\tret = (ret + query_sufsum(range[i].first,range[i].second,1,1,n) * prod % mod) % mod,prod = prod * query_prod(range[i].first,range[i].second,1,1,n) % mod;\n\treturn (ret + temp * prod % mod) % mod;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(register int i = 1;i <= n;++i)\n\t\tscanf(\"%lld\",a + i);\n\tint u,v;\n\tfor(register int i = 1;i < n;++i)\n\t\tscanf(\"%d%d\",&u,&v),add(u,v),add(v,u);\n\tdep[1] = 1,dfs1(1),top[1] = 1,dfs2(1);\n\tbuild(1,1,n);\n\tchar op;\n\tint x,y;\n\twhile(m--)\n\t{\n\t\tscanf(\" %c%d%d\",&op,&x,&y);\n\t\tif(op == 'Q')\n\t\t\tprintf(\"%lld\\n\",(query(x,y) + mod) % mod);\n\t\telse\n\t\t\tmodify(id[x],y,1,1,n);\n\t}\n}\n```",
        "postTime": 1550892647,
        "uid": 75840,
        "name": "deserter",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5220 \u3010\u7279\u5de5\u7684\u4fe1\u606f\u6d41\u3011"
    },
    {
        "content": "\u4e00\u9053\u5f88\u4f20\u7edf\u7684\u6811\u4e0a\u64cd\u4f5c\u9898\u3002\n\n\u8fd9\u9898\u7531\u4e8e\u533a\u95f4\u4e4b\u95f4\u7684\u5408\u5e76\u6709\u4e0d\u5c11\u7ec6\u8282\uff0c\u6240\u4ee5\u6bd4\u8d5b\u7684\u65f6\u5019\u653e\u5f03\u4e86\u6811\u5256\u5199\u4e86LCT\u3002\u672c\u9898\u8981\u6c42\u540e\u7f00\u79ef\u4e4b\u548c\uff0c\u53ef\u4ee5\u8003\u8651\u5728LCT\u4e0a\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u8fde\u4e58\u3001\u4e00\u4e2a\u524d\u7f00\u79ef\u4e4b\u548c\u3001\u4e00\u4e2a\u540e\u7f00\u79ef\u4e4b\u548c\uff0c\u5c31\u53ef\u4ee5\u5f88\u65b9\u4fbf\u5730\u5728makeroot\u65f6\u5b9e\u73b0\u4ea4\u6362\u5b69\u5b50\u4e86\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u6309\u7167\u5957\u8def\u76f4\u63a5makeroot(x)\u5e76access(y)\u63d0\u53d6\u94fe\uff0c\u800c\u5bf9\u4e8e\u4fee\u6539\u5219\u66f4\u5bb9\u6613\uff0c\u76f4\u63a5makeroot(x)\u5e76access(x)\u5c31\u4e0d\u4f1a\u5bf9\u5176\u4ed6\u5143\u7d20\u4ea7\u751f\u4efb\u4f55\u5f71\u54cd\u3002\u521d\u59cb\u65f6\u628a\u6811\u8fb9\u90fd\u5f53\u6210\u865a\u8fb9\u53ef\u4ee5\u5c11\u5199\u4e00\u4e2alink\u51fd\u6570\u3002\n\n```cpp\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nconst int N=1e5+2,p=20924,M=2e5+2;\nint lj[M],nxt[M],fir[N],f[N],c[N][2],s1[N],s2[N],s3[N];\nint a[N],lz[N],st[N];\nint n,m,i,j,x,y,cc,bs,tp;\ninline void read(int &x)\n{\n    cc=getchar();\n    while ((cc<48)||(cc>57)) cc=getchar();\n    x=cc^48;cc=getchar();\n    while ((cc>=48)&&(cc<=57))\n    {\n        x=x*10+(cc^48);\n        cc=getchar();\n    }\n}\ninline void add()\n{\n    lj[++bs]=y;\n    nxt[bs]=fir[x];\n    fir[x]=bs;\n    lj[++bs]=x;\n    nxt[bs]=fir[y];\n    fir[y]=bs;\n}\ninline bool nroot(int x)\n{\n    return ((c[f[x]][0]==x)||(c[f[x]][1]==x));\n}\ninline void pushup(int x)\n{\n    s1[x]=s1[c[x][0]]*s1[c[x][1]]%p*a[x]%p;\n    s2[x]=(s2[c[x][0]]+a[x]*s1[c[x][0]]+a[x]*s1[c[x][0]]%p*s2[c[x][1]])%p;\n    s3[x]=(s3[c[x][1]]+a[x]*s1[c[x][1]]+a[x]*s1[c[x][1]]%p*s3[c[x][0]])%p;\n}\ninline void pushdown(int x)\n{\n    if (lz[x])\n    {\n        swap(c[c[x][0]][0],c[c[x][0]][1]);\n        swap(c[c[x][1]][0],c[c[x][1]][1]);\n        swap(s2[c[x][0]],s3[c[x][0]]);\n        swap(s2[c[x][1]],s3[c[x][1]]);\n        lz[c[x][0]]^=1;lz[c[x][1]]^=1;\n        lz[x]=0;\n    }\n}\ninline void zigzag(int x)\n{\n    int y=f[x],z=f[y],typ=(c[y][1]==x);\n    if (nroot(y)) c[z][c[z][1]==y]=x;\n    f[f[y]=x]=z;\n    if (c[x][typ^1]) f[c[x][typ^1]]=y;\n    c[y][typ]=c[x][typ^1];\n    c[x][typ^1]=y;\n    pushup(y);\n}\ninline void splay(int x)\n{\n    int y=st[tp=1]=x;\n    while (nroot(y)) st[++tp]=y=f[y];\n    while (tp) pushdown(st[tp--]);\n    while (nroot(x))\n    {\n        if (nroot(y=f[x]))\n        {\n            if (c[f[y]][0]==y^c[y][0]==x) zigzag(x); else zigzag(y);\n        }\n        zigzag(x);\n    }\n    pushup(x);\n}\ninline void access(int x)\n{\n    for (int y=0;x;x=f[y=x])\n    {\n        splay(x);\n        c[x][1]=y;\n        pushup(x);\n    }\n}\ninline void makeroot(int x)\n{\n    access(x);splay(x);\n    swap(c[x][0],c[x][1]);\n    swap(s2[x],s3[x]);\n    lz[x]^=1;pushup(x);\n}\ninline void split(int x,int y)\n{\n    makeroot(x);access(y);splay(y);\n}\nvoid dfs(int x)\n{\n    s1[x]=s2[x]=s3[x]=a[x];\n    int i;\n    for (i=fir[x];i;i=nxt[i]) if (lj[i]!=f[x])\n    {\n        f[lj[i]]=x;\n        dfs(lj[i]);\n    }\n}\nint main()\n{\n    s1[0]=1;\n    read(n);read(m);\n    for (i=1;i<=n;i++) read(a[i]);\n    i=n;\n    while (--i)\n    {\n        read(x);read(y);\n        add();\n    }\n    dfs(1);\n    while (m--)\n    {\n        cc=getchar();\n        while ((cc!='C')&&(cc!='Q')) cc=getchar();\n        if (cc=='C')\n        {\n            read(x);read(y);\n            split(x,x);\n            a[x]=(a[x]+y)%p;\n            s1[x]=s2[x]=s3[x]=a[x];\n        }\n        else\n        {\n            read(x);read(y);\n            split(x,y);pushdown(y);\n            printf(\"%d\\n\",s3[y]);\n        }\n    }\n}\n```",
        "postTime": 1549709480,
        "uid": 29826,
        "name": "SSerxhs",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P5220 \u3010\u7279\u5de5\u7684\u4fe1\u606f\u6d41\u3011"
    },
    {
        "content": "[\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/P5220)   [\u4e2a\u4eba\u535a\u5ba2\u7248\u672c](https://code.watertomato.com/p5220-%e7%89%b9%e5%b7%a5%e7%9a%84%e4%bf%a1%e6%81%af%e6%b5%81-%e9%a2%98%e8%a7%a3/)\n\n> @GuidingStar \u8ba9\u6211\u6765\u505a\u8fd9\u9053\u9898\u76ee\u7136\u540e\u6211\u5c31\u505a\u4e86\u4e00\u4e0b\uff0c\u7ed3\u679c\u56e0\u4e3a\u4e00\u4e2a\u611a\u8822\u7684\u9519\u8bef\u8c03\u4e86\u4e00\u4e2a\u5c0f\u65f6\u4ee3\u7801\u2026\u2026\n\n## \u9898\u610f\n\n\u7ed9\u5b9a\u4e00\u68f5\u6811\uff0c\u7ef4\u62a4\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c\uff0c\u652f\u6301\u5355\u70b9\u4fee\u6539\u3002\n\n## \u89e3\u6790\n\n\u4e2a\u4eba\u89c9\u5f97\u6ca1\u90a3\u4e48\u96be\u60f3\uff08~~\u55ef\uff0c\u641e\u6b7b\u6211\u7684\u662f\u7ec6\u8282~~\uff09\u3002\n\n\u6211\u4eec\u5148\u8003\u8651\u7ebf\u6bb5\u6811\u4e0a\u5982\u4f55\u7ef4\u62a4\u8fd9\u4e2a\u4e1c\u897f\u3002\u6211\u4eec\u53ef\u4ee5\u5728\u7ef4\u62a4\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c\u7684\u540c\u65f6\u7ef4\u62a4\u4e00\u4e0b\u533a\u95f4\u79ef\uff0c\u7136\u540e\u5408\u5e76\u7684\u65f6\u5019\u53ea\u9700\u8981\u5c06\u5de6\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c\u4e58\u4e0a\u53f3\u533a\u95f4\u79ef\uff0c\u518d\u52a0\u4e0a\u53f3\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c\u5c31\u597d\u4e86\u3002\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u600e\u4e48\u5c06\u8fd9\u4e2a\u4e1c\u897f\u642c\u5230\u6811\u4e0a\u3002\u8003\u8651\u6811\u94fe\u5256\u5206\uff08~~LCT\u6211\u4e0d\u4f1a\u554a~~\uff09\u3002\n\n\u6211\u4eec\u5982\u679c\u8981\u67e5\u8be2\u70b9 $x,y$ \u4e4b\u95f4\u90a3\u6bb5\u8def\u5f84\uff0c\u5c31\u662f\u5c06\u4e24\u8fb9\u5206\u522b\u5f80\u4e0a\u8df3\uff0c\u7136\u540e\u5728\u4ea4\u6c47\u5904\u5408\u5e76\u4e00\u4e0b\u5c31\u884c\u4e86\u3002\u8fd9\u65f6\u5019\u5bb9\u6613\u60f3\u5230\uff0c$x$ \u5f80\u4e0a\u8df3\u65f6\uff0c\u8df3\u7684\u65b9\u5411\u548c dfs \u5e8f\u7684\u65b9\u5411\u662f\u76f8\u53cd\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4\u6b64\u65f6\u7684\u7b54\u6848\u5e76\u975e\u662f\u540e\u7f00\u79ef\u4e4b\u548c\u800c\u662f\u524d\u7f00\u79ef\u4e4b\u548c\uff0c\u7ebf\u6bb5\u6811\u518d\u7ef4\u62a4\u4e00\u4e0b\u8fd9\u73a9\u610f\u513f\u5c31\u597d\u4e86\u3002\n\n\u5355\u70b9\u4fee\u6539\u975e\u5e38\u5bb9\u6613\uff0c\u4e0d\u591a\u8d58\u8ff0\u3002\u8fd9\u4e9b\u4fe1\u606f\u7684\u67e5\u8be2\u4e5f\u53ef\u4ee5\u5168\u90e8\u4e22\u5230\u4e00\u4e2a\u51fd\u6570\u91cc\u4e00\u8d77\u67e5\u8be2\u3002\n\n\u8be6\u89c1\u4ee3\u7801\uff0c\u90fd\u6ce8\u91ca\u4e86\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define ls u<<1\n#define rs u<<1|1\nusing namespace std;\nconst int mod = 20924;\nconst int N = 4e5 + 5;\nstruct Segment_Tree {\n\tint prod, ans, fans;\n} tree[N << 3];\nstruct edge {\n\tint to, nxt;\n} e[N << 1];\nint cnt, head[N], n, m;\nint a[N], w[N];\nchar ch[20];\ninline void add(int u, int v) {\n\te[++cnt].to = v;\n\te[cnt].nxt = head[u];\n\thead[u] = cnt;\n}\nint dep[N], son[N], siz[N], fa[N];\ninline void dfs1(int u, int f) {\n\tdep[u] = dep[f] + 1;\n\tfa[u] = f; siz[u] = 1;\n\tfor (int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif (v == f) continue;\n\t\tdfs1(v, u);\n\t\tsiz[u] += siz[v];\n\t\tif (siz[v] > siz[son[u]]) son[u] = v;\n\t}\n}\nint top[N], id[N], tot;\ninline void dfs2(int u, int Top) {\n\tid[u] = ++tot;\n\ta[tot] = w[u];\n\ttop[u] = Top;\n\tif (!son[u]) return;\n\tdfs2(son[u], Top);\n\tfor (int i = head[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].to;\n\t\tif (v == fa[u] || v == son[u]) continue;\n\t\tdfs2(v, v);\n\t}\n}\ninline void pushup(int u) {\n\ttree[u].prod = tree[ls].prod * tree[rs].prod % mod;//\u5408\u5e76\n\ttree[u].ans = (tree[rs].ans + tree[ls].ans * tree[rs].prod % mod) % mod;\n\ttree[u].fans = (tree[ls].fans + tree[rs].fans * tree[ls].prod % mod) % mod;\n}\ninline void build(int u, int l, int r) {\n\tif (l == r) {\n\t\ttree[u].ans = tree[u].prod = tree[u].fans = a[l];\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls, l, mid); build(rs, mid + 1, r);\n\tpushup(u);\n}\ninline void update(int u, int l, int r, int x, int k) {//\u5355\u70b9\u4fee\u6539\n\tif (l == r) {\n\t\ttree[u].prod = (tree[u].prod + k) % mod;\n\t\ttree[u].ans = (tree[u].ans + k) % mod;\n\t\ttree[u].fans = (tree[u].fans + k) % mod;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif (mid >= x) update(ls, l, mid, x, k);\n\telse update(rs, mid + 1, r, x, k);\n\tpushup(u);\n}\nint prod, ans, fans;\ninline void query(int u, int l, int r, int L, int R) {//\u4e09\u4e2a\u4e1c\u897f\u4e00\u8d77\u67e5\u8be2\n\tif (l >= L && r <= R) {\n\t\tprod = tree[u].prod;//\u533a\u95f4\u79ef\n\t\tans = tree[u].ans;//\u533a\u95f4\u540e\u7f00\u79ef\u4e4b\u548c\n\t\tfans = tree[u].fans;//\u533a\u95f4\u524d\u7f00\u79ef\u4e4b\u548c\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tint tp = 0, ta = 0, tf = 0;\n\tif (mid >= L && mid < R) {//\u4e24\u8fb9\u90fd\u6709\uff0c\u9700\u8981\u5408\u5e76\n\t\tquery(rs, mid + 1, r, L, R);\n\t\ttp = prod, ta = ans, tf = fans;//\u8bb0\u5f55\u53f3\u8fb9\u7684\u8fd4\u56de\u503c\n\t\tquery(ls, l, mid, L, R);\n\t\tta = (ta + ans * tp) % mod;//\u5408\u5e76\n\t\ttf = (fans + tf * prod) % mod;\n\t\ttp = prod * tp % mod;\n\t\tprod = tp; ans = ta; fans = tf;\n\t}\n\telse if (mid < R) {\n\t\tquery(rs, mid + 1, r, L, R);\n\t}\n\telse if (mid >= L) {\n\t\tquery(ls, l, mid, L, R);\n\t}\n\treturn;\n}\ninline void queryTree(int x, int y) {\n\tint sa = 0, ta = 0, tp = 1;\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] >= dep[top[y]]) {\n\t\t\tquery(1, 1, n, id[top[x]], id[x]);\n\t\t\tsa = (fans + sa * prod) % mod;//x \u5411\u4e0a\u8df3\u65b9\u5411\u65f6\u548c dfs \u5e8f\u662f\u53cd\u7684\uff0c\u7528 fans\uff0c\u5408\u5e76\u540c\u6837\u6ce8\u610f\u65b9\u5411\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\telse {\n\t\t\tquery(1, 1, n, id[top[y]], id[y]);//y \u5411\u4e0a\u8df3\u65b9\u5411\u65f6\u6ca1\u95ee\u9898\uff0c\u76f4\u63a5\u7528 ans\n\t\t\tta = (ta + ans * tp) % mod;\n\t\t\ttp = tp * prod % mod;\n\t\t\ty = fa[top[y]];\n\t\t}\n\t}\n\tif (dep[x] < dep[y]) {//\u5224\u65ad\u6700\u540e\u4e00\u6bb5\u7684\u65b9\u5411\n\t\tquery(1, 1, n, id[x], id[y]);\n\t\tta = (ans * tp + ta) % mod;//\u5148\u548c\u4e2d\u95f4\u8fd9\u6bb5\u5408\u5e76\n\t\ttp = tp * prod % mod;\n\t\tsa = (sa * tp + ta) % mod;//\u518d\u628a\u4e24\u6bb5\u5408\u5e76\u8d77\u6765\n\t}\n\telse {\n\t\tquery(1, 1, n, id[y], id[x]);\n\t\tta = (fans * tp + ta) % mod;\n\t\ttp = tp * prod % mod;\n\t\tsa = (sa * tp + ta) % mod;\n\t}\n\tprintf(\"%lld\\n\", sa);\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &w[i]);\n\tfor (int i = 1, u, v; i < n; i++) {\n\t\tscanf(\"%lld%lld\", &u, &v);\n\t\tadd(u, v); add(v, u);\n\t}\n\tdfs1(1, 0);\n\tdfs2(1, 1);\n\tbuild(1, 1, n);\n\tfor (int i = 1, a, b; i <= m; i++) {\n\t\tscanf(\"%s\", ch);\n\t\tscanf(\"%lld%lld\", &a, &b);\n\t\tif (ch[0] == 'Q') queryTree(a, b);\n\t\telse update(1, 1, n, id[a], b);\n\t}\n\treturn 0;\n}\n```\n\n\u81f3\u4e8e\u6211\u8c03\u4e86\u597d\u4e45\u7684\u539f\u56e0\uff1a\u67e5\u8be2\u51fd\u6570\u5199\u5f97\u592a\u5783\u573e\u4e86\u5bfc\u81f4\u4e2a\u522b\u60c5\u51b5\u4e0b $prod,ans,fans$ \u6ca1\u6709\u6b63\u786e\u8fd4\u56de\uff0c\u7136\u540e\u628a\u8fd9\u73a9\u610f\u513f\u641e\u5de5\u6574\u4e00\u70b9\u9760\u8c31\u4e00\u70b9\u5c31\u8fc7\u4e86\uff08~~\u81ea\u95ed~~\uff09\u3002",
        "postTime": 1614309348,
        "uid": 195229,
        "name": "water_tomato",
        "ccfLevel": 7,
        "title": "P5220 \u7279\u5de5\u7684\u4fe1\u606f\u6d41 \u9898\u89e3"
    },
    {
        "content": "# Description\n\n$\\text{TYM}$ \u6240\u5728\u7684\u56fd\u5bb6\u6709 $n$ \u4e2a\u57ce\u5e02\uff0c\u7f16\u53f7\u4e3a $1,\\dots,n$\uff0c\u7531 $n - 1$ \u6761\u53cc\u5411\u9053\u8def\u8fde\u63a5\u3002\u4fdd\u8bc1\u4efb\u610f\u4e24\u4e2a\u57ce\u5e02\u95f4\u90fd\u6709\u552f\u4e00\u7684\u7b80\u5355\u8def\u5f84\u3002  \n\u4ee5\u53ca\uff0c\u6bcf\u4e2a\u57ce\u5e02\u90fd\u6709\u4e00\u4e2a\u4fe1\u606f\u6d41\u7684\u6d41\u91cf $a_i$\u3002\n\n$\\text{TYM}$ \u4e00\u5171\u8981\u6267\u884c $m_0$ \u4e2a\u4efb\u52a1\uff0c\u6bcf\u4e2a\u4efb\u52a1\u7ed9\u5b9a\u4e24\u4e2a\u57ce\u5e02 $s,t$\uff0c\u5176\u6267\u884c\u8fc7\u7a0b\u5982\u4e0b\uff1a  \n\u7b2c\u4e00\u4e2a\u65f6\u523b\uff0c\u4ed6\u4ece\u57ce\u5e02 $s$ \u51fa\u53d1\uff0c\u4ee5\u6bcf\u4e2a\u65f6\u523b\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a\u57ce\u5e02\u7684\u901f\u5ea6\uff0c\u8d70 $s,t$ \u4e4b\u95f4\u7684\u7b80\u5355\u8def\u5f84\u5230 $t$\u3002  \n\u6bcf\u5230\u8fbe\u4e00\u4e2a\u57ce\u5e02\uff0c\u4ed6\u90fd\u4f1a\u628a\u8fd9\u4e2a\u57ce\u5e02\u7684\u4fe1\u606f\u6d41 $a_i$ \u53d1\u9001\u5230\u7ecf\u8fc7\u7684\u6bcf\u4e2a\u57ce\u5e02\u3002  \n\u6211\u4eec\u7ea6\u5b9a\uff0c\u4ed6\u5230\u8fbe\u4e00\u4e2a\u57ce\u5e02\u7684\u540c\u4e00\u65f6\u523b\u4e5f\u4f1a\u628a\u8fd9\u4e2a\u57ce\u5e02\u7684\u4fe1\u606f\u6d41\u53d1\u9001\u7ed9\u8fd9\u4e2a\u57ce\u5e02\u3002\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u57ce\u5e02\u7684\u4ef7\u503c\u4e3a\u8fd9\u4e2a\u57ce\u5e02\u6240\u63a5\u53d7\u5230\u7684\u4fe1\u606f\u6d41\u7684\u4e58\u79ef\u3002\n\n\u8bf7\u4f60\u6c42\u51fa\u6bcf\u4e2a\u4efb\u52a1\u4e2d\uff0c$s$ \u5230 $t$ \u7684\u7b80\u5355\u8def\u5f84\u4e0a\u7ecf\u8fc7\u7684\u57ce\u5e02\u7684\u4ef7\u503c\u7684\u603b\u548c\u5bf9 $20924$ \u53d6\u6a21\u7684\u7ed3\u679c\u3002\n\n\u6b64\u5916\uff0c\u4e0d\u5e78\u5730\uff0c\u7531\u4e8e\u4fb5\u7565\u8005\u540c\u65f6\u4e5f\u5728\u884c\u52a8\uff0c\u6240\u4ee5\u5728\u4ed6\u6267\u884c\u591a\u4e2a\u4efb\u52a1\u4e4b\u95f4\uff0c\u53ef\u80fd\u4f1a\u6709\u67d0\u4e2a $a_i$ \u53d1\u751f\u6539\u53d8\u3002\n\n\u4ed6\u7684\u4efb\u52a1\u603b\u6570\u4e0e\u6539\u53d8\u67d0\u4e2a $a_i$ \u7684\u6b21\u6570\u4e4b\u548c\u4e3a $m$\u3002\n\n-------\n\n# Solution\n\n\u8fd9\u9053\u9898\u7684\u9898\u610f\u662f\u771f\u7684\u7ed5\uff0c\u6211\u524d\u524d\u540e\u540e\u8bfb\u4e86\u4e0d\u4e0b\u4e94\u904d\u624d\u5927\u6982\u610f\u4f1a\u3002\u3002\u3002\n\n\u505a\u6570\u636e\u7ed3\u6784\u7684\u9898\u4e00\u822c\u90fd\u8981\u5148\u6d53\u7f29\u9898\u610f\u3002\u8fd9\u9053\u9898\u662f\u8ba9\u6211\u4eec\u6c42\u540e\u7f00\u79ef\u4e4b\u548c\uff0c\u518d\u52a0\u4e0a\u4fee\u6539\u64cd\u4f5c\u5c31\u57fa\u672c\u4e0a\u786e\u5b9a\u7528LCT\u4e86\n\n\u9700\u8981\u7ef4\u62a4\u7684\u4fe1\u606f\u6709\u524d\u7f00\u79ef\u4e4b\u548c,\u540e\u7f00\u79ef\u4e4b\u548c\uff0c\u533a\u95f4\u4e58\u6cd5\u4e09\u4e2a\u4fe1\u606f\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u76f4\u63a5\u4e0aLCT\u7684\u5957\u8defmakeroot\u548caccess\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee\u64cd\u4f5c\uff0c\u6211\u4eec\u76f4\u63a5\u6309\u7167LCT\u7684\u5957\u8def\u7528makeroot\u548caccess\u628a\u94fe\u7ed9\u641e\u51fa\u6765\u3002\n\n\u5176\u5b9e\u8fd9\u5c31\u76f8\u5f53\u4e8e\u4e00\u9053LCT\u7684\u677f\u9898\u5427\u3002\u3002\u3002\u5168\u90e8\u90fd\u662f\u57fa\u7840\u64cd\u4f5c\u3002\u3002\u3002\n\n\u5b8c\u6574\u4ee3\u7801\u5728\u8fd9\u91cc[Link](https://paste.ubuntu.com/p/tsQ43Pvvg6/)\n\n\u5982\u679c\u94fe\u63a5\u5931\u6548\u4e86\u5c31\u8fd9\u4e2a[Link](https://www.luogu.com.cn/paste/gtishzfw)\n\n###### [\u6084\u6084\u7684\u6253\u4e2a\u5e7f\u544a(blog)](http://boringhacker.github.io/)\n\n```cpp\nconst int SIZE = 1e5 + 5;\nconst int M_SIZE = 2e5 + 5;\nconst int MOD = 20924;\nint head[M_SIZE], nxt[M_SIZE];\nint to[M_SIZE], ints[SIZE];\nint waste[SIZE], n, m, top, tot;\nstruct SPLAY {\n\tint fa;\n\tint ch[2];\n\tint prod;\n\tint preprod;\n\tint sufprod;\n\tint lztg;\n} data[SIZE];\n\nvoid AddEdge(int x, int y) {\n\tto[++tot] = y;\n\tnxt[tot] = head[x];\n\thead[x] = tot;\n}\n\nbool IsRoot(int x) {\n\treturn ((data[data[x].fa].ch[1] ^ x) && (data[data[x].fa].ch[0] ^ x));\n}\n\nbool WhichSon(int x) {\n\treturn (data[data[x].fa].ch[1] == x);\n}\n\nvoid UpdateMessages(int x) {\n\tdata[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD;\n\tdata[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD;\n\tdata[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD;\n}\n\nvoid UpdateSons(int x) {\n\tif (data[x].lztg) {\n\t\tswap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]);\n\t\tswap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]);\n\t\tswap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod);\n\t\tswap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod);\n\t\tdata[data[x].ch[0]].lztg ^= 1;\n\t\tdata[data[x].ch[1]].lztg ^= 1;\n\t\tdata[x].lztg = 0;\n\t}\n}\n\nvoid RotateNode(int x) {\n\tint y = data[x].fa;\n\tint z = data[y].fa;\n\tint k = WhichSon(x);\n\tif (!IsRoot(y)) data[z].ch[WhichSon(y)] = x;\n\tdata[y].fa = x;\n\tdata[data[y].fa].fa = z;\n\tif (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y;\n\tdata[y].ch[k] = data[x].ch[k ^ 1];\n\tdata[x].ch[k ^ 1] = y;\n\tUpdateMessages(y);\n}\n\nvoid SplayToRoot(int x) {\n\tint y = waste[top = 1] = x;\n\twhile (!IsRoot(y)) waste[++top] = y = data[y].fa;\n\twhile (top) UpdateSons(waste[top--]);\n\tfor (; !IsRoot(x); RotateNode(x))\n\t\tif (!IsRoot((y = data[x].fa)))\n\t\t\tRotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y);\n\tUpdateMessages(x);\n}\n\nvoid AccessEdge(int x) {\n\tfor (int y = 0; x; x = data[y = x].fa) {\n\t\tSplayToRoot(x);\n\t\tdata[x].ch[1] = y;\n\t\tUpdateMessages(x);\n\t}\n}\n\nvoid MakeRoot(int x) {\n\tAccessEdge(x);\n\tSplayToRoot(x);\n\tswap(data[x].ch[0], data[x].ch[1]);\n\tswap(data[x].preprod, data[x].sufprod);\n\tdata[x].lztg ^= 1;\n\tUpdateMessages(x);\n}\n\nvoid SplitTree(int x, int y) {\n\tMakeRoot(x);\n\tAccessEdge(y);\n\tSplayToRoot(y);\n}\n\nvoid Prepare(int x) {\n\tdata[x].prod = ints[x];\n\tdata[x].preprod = ints[x];\n\tdata[x].sufprod = ints[x];\n\tfor (int i = head[x]; i; i = nxt[i])\n\t\tif (to[i] ^ data[x].fa)\n\t\t\tdata[to[i]].fa = x, Prepare(to[i]);\n}\n\nint GetAnswers(int x, int y) {\n\tSplitTree(x, y);\n\tUpdateSons(y);\n\treturn data[y].sufprod;\n}\n\nvoid Behavior(int x, int y) {\n\tSplitTree(x, x);\n\tints[x] += y;\n\tints[x] %= MOD;\n\tdata[x].prod = ints[x];\n\tdata[x].preprod = ints[x];\n\tdata[x].sufprod = ints[x];\n}\n\nsigned main() {\n\tread(n, m);\n\tfor (int i = 1; i <= n; ++i) read(ints[i]);\n\tfor (int i = 1, x, y; i < n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x);\n\t(*data).prod = 1;\n\tPrepare(1);\n\tfor (int i = 0, x, y; i < m; ++i) {\n\t\tchar opt[5];\n\t\tread(opt);\n\t\tread(x, y);\n\t\tif (*opt ^ 'C') write(io_l, GetAnswers(x, y));\n\t\telse Behavior(x, y);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1581735840,
        "uid": 161849,
        "name": "cirnovsky",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P5220 \u3010\u7279\u5de5\u7684\u4fe1\u606f\u6d41\u3011"
    }
]