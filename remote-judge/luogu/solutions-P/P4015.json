[
    {
        "content": "\n\u597d\u7ecf\u5178\u7684\u6a21\u578b\u3002\n\n### \u9898\u89e3\n\n\u4e4d\u4e00\u770b\u5c31\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u3002\n\n\u4f46\u662f\u8981\u6c42\u5f88\u660e\u663e\u8981\u6c42\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n\u8003\u8651\u5982\u4f55\u5efa\u6a21\u3002\n\n\u7531\u4e8e\u6bcf\u4e00\u4e2a\u4ed3\u5e93\u53ea\u80fd\u6d41\u51fa\u5b9a\u91cf\u7684\u8d27\u7269\uff0c\u4f46\u662f\u53c8\u4e0d\u80fd\u628a\u6bcf\u4e00\u4e2a\u4ed3\u5e93\u770b\u505a\u6e90\u3002\n\n\u6240\u4ee5\u628a\u6240\u6709\u8d27\u7269\u90fd\u8fde\u5230\u540c\u4e00\u4e2a\u6e90\u4e0a\uff0c\u8fde\u5230\u7b2c$i$\u4e2a\u4ed3\u5e93\u7684\u8fb9\u561a\u7684\u5bb9\u91cf\u4e3a$A_i$\uff0c\u8d39\u7528\u4e3a$0$\u3002\n\n\u6bcf\u4e00\u5bb6\u96f6\u552e\u5e97\u53c8\u90fd\u8fde\u5230\u4e00\u4e2a\u6c47\u4e0a\uff0c\u4ece\u7b2c$i$\u5bb6\u96f6\u552e\u5e97\u8fde\u51fa\u7684\u8fb9\u7684\u5bb9\u91cf\u4e3a$B_i$\uff0c\u8d39\u7528\u4e3a$0$\u3002\n\n\u4e2d\u95f4\u4ece\u4ed3\u5e93\u5230\u96f6\u552e\u5e97\u7684\u8fb9\u5c31\u6309\u7167\u9898\u76ee\u91cc\u7684\u8bf4\u7684\u90a3\u6837\u8fde\uff0c\u5bb9\u91cf\u4e3a$+\\infty$\u3002\n\n![1.png](https://www.chnxuzhiyuan.cn/images/\u300c\u7f51\u7edc\u6d4124\u9898\u300d\u8fd0\u8f93\u95ee\u9898-Solution-1.png)\n\n\u7136\u540e\u76f4\u63a5\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5c31\u597d\u4e86\u3002\n\n### \u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int maxn=210,maxm=20205,inf=0x3F3F3F3F;\nint m,n,S,T,tot,lnk[maxn],son[maxm],nxt[maxm],w[maxm],cap[maxm],que[maxn],lst[maxn],pre[maxn],dist[maxn],flow[maxn],ans;bool vis[maxn];\ninline int read()\n{\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}\n\treturn ret*f;\n}\ninline void add_e(int x,int y,int z,int c){tot++;son[tot]=y;w[tot]=z;cap[tot]=c;nxt[tot]=lnk[x];lnk[x]=tot;}\ninline void MinCostMaxFlow(int flg)\n{\n\twhile(true)\n\t{\n\t\tif(flg==1) memset(dist,63,sizeof(dist));\n\t\telse memset(dist,192,sizeof(dist));\n\t\tmemset(flow,63,sizeof(flow));\n\t\tint hed=0,til=1;\n\t\tque[1]=S;dist[S]=0;vis[S]=true;pre[T]=0;\n\t\twhile(hed!=til)\n\t\t{\n\t\t\thed=(hed+1)%maxn;vis[que[hed]]=false;\n\t\t\tfor(int i=lnk[que[hed]];i;i=nxt[i])\n\t\t\t{\n\t\t\t\tif(cap[i]&&((flg==1&&dist[que[hed]]+w[i]<dist[son[i]])||(flg==-1&&dist[que[hed]]+w[i]>dist[son[i]])))\n\t\t\t\t{\n\t\t\t\t\tdist[son[i]]=dist[que[hed]]+w[i];\n\t\t\t\t\tpre[son[i]]=que[hed];\n\t\t\t\t\tlst[son[i]]=i;\n\t\t\t\t\tflow[son[i]]=min(flow[que[hed]],cap[i]);\n\t\t\t\t\tif(!vis[son[i]])\n\t\t\t\t\t{\n\t\t\t\t\t\tvis[son[i]]=true;\n\t\t\t\t\t\ttil=(til+1)%maxn;\n\t\t\t\t\t\tque[til]=son[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pre[T]==0) return;\n\t\tans+=flow[T]*dist[T];\n\t\tint p=T;\n\t\twhile(p!=S)\n\t\t{\n\t\t\tcap[lst[p]]-=flow[T];\n\t\t\tcap[(lst[p]&1)?lst[p]+1:lst[p]-1]+=flow[T];\n\t\t\tp=pre[p];\n\t\t}\n\t}\n}\nint main()\n{\n\tm=read();n=read();S=1;T=m+n+2;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint ai=read();\n\t\tadd_e(S,i+1,0,ai);\n\t\tadd_e(i+1,S,0,0);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint bi=read();\n\t\tadd_e(i+m+1,T,0,bi);\n\t\tadd_e(T,i+m+1,0,0);\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tint cij=read();\n\t\t\tadd_e(i+1,j+m+1,cij,inf);\n\t\t\tadd_e(j+m+1,i+1,-cij,0);\n\t\t}\n\t}\n\tMinCostMaxFlow(1);\n\tprintf(\"%d\\n\",ans);\n\tfor(int i=2;i<=tot;i+=2){cap[i-1]+=cap[i];cap[i]=0;}\n\tans=0;\n\tMinCostMaxFlow(-1);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1552883892,
        "uid": 42392,
        "name": "\u5f90\u81f4\u8fdc",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u770b\u4e86\u4e0bSPFA\u9898\u89e3\uff0c\u4e00\u4e2a\u4e00\u4e2a\u592a\u9ebb\u70e6\u4e86\uff0c\u53e6\u4e00\u4e2a\u5199\u7684\u5f88\u4e0d\u6e05\u695a\uff0c\u800c\u4e14\u6ce8\u91ca\u90fd\u53d8\u6210\u4e86\"????\"\u4e0d\u77e5\u9053\u600e\u4e48\u8fc7\u7684\uff0c\u4e8e\u662f\u81ea\u5df1\u6765\u4e00\u53d1SPFA\u7b97\u6cd5\u3002\n\n## Part 1.\u9898\u610f\n\n$M$\u4e2a\u4ed3\u5e93\uff0c\u5356\u7ed9$N$\u4e2a\u5546\u5e97\uff0c\u4e24\u4e2a\u95ee\uff0c\u7b2c\u4e00\u95ee\u6c42\u8fd0\u4ef7\u6700\u5c0f\u503c\uff0c\u7b2c\u4e8c\u95ee\u6700\u5927\u503c\u3002\n\n\u663e\u7136\u662f\u4e00\u4e2a\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41(MCMF)\u3002\n\n## Part 2.\u601d\u8def\n\n1.\u8fde\u8ba9\u6bcf\u4e2a\u4ed3\u5e93\u8fde\u63a5\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9$S$\uff0c\u8d39\u7528(dis)\u4e3a0\uff0c\u6d41\u91cf\u4e3a\u4ed3\u5e93\u7684\u6d41\u91cf\uff0c\u8868\u793a\u6bcf\u4e2a\u4ed3\u5e93\u6700\u591a\u53ef\u4ee5\u8fd0\u51fa\u591a\u5c11\u8d27\u7269\u3002\n\n2.\u8ba9\u6bcf\u4e00\u4e2a\u4ed3\u5e93\u8fde\u63a5\u6bcf\u4e00\u5bb6\u5546\u5e97\uff0c\u8fb9\u6743\u4e3a$cost[i][j]$\uff0c\u5176\u4e2d\uff0ci\u4e3a\u4ed3\u5e93\u7f16\u53f7\uff0cj\u4e3a\u5546\u5e97\u7f16\u53f7\u7f16\u53f7\uff0c\u6d41\u91cf\u4e3a$need[j]$\uff0c\u5176\u5b9e\u6d41\u91cf\u53ef\u4ee5\u53d6\u5f97\u8303\u56f4\u662f$[need[j]...INF]$ \uff0c\u53e6\u5916\u5982\u679c\u51fa\u73b0$need[j]$<\u8fd9\u4e2a\u4ed3\u5e93\u8d27\u7269\u91cf\u7684\u60c5\u51b5\u4e5f\u53ef\u4ee5\u4e0d\u6015(\u8fd9\u65f6\u5019\u53d6\u503c\u7684\u4e0b\u9650\u53d8\u6210$min(hw[i],need[j])$) hw\u6307\u7684\u662f\u8fd9\u5bb6\u4ed3\u5e93\u7684\u8d27\u7269\uff0c\u8fd8\u6709\u6ce8\u610f\u7f16\u53f7\u7684\u8303\u56f4\uff08\u6211\u9ed8\u8ba4\u8d85\u7ea7\u6e90\u70b9\u662f$0$\uff0c\u4ed3\u5e93\u662f$1\u2026\u2026n$,\u5546\u5e97\u662f$n+1\u2026\u2026n+m$\uff0c\u8d85\u7ea7\u6c47\u70b9\u662f$10000$\uff09\n\n3.\u8ba9\u6bcf\u4e00\u5bb6\u5546\u5e97\u8fde\u63a5\u8d85\u7ea7\u6c47\u70b9$T$\n\n\u56fe\u50cf\u5e2e\u52a9\u7406\u89e3\uff1a\n![](https://cdn.luogu.com.cn/upload/pic/62883.png)\n\n## Part 3.\u4ee3\u7801\n\n\u73b0\u5728\u4ee3\u7801\u5c31\u597d\u529e\u4e86\n\u6ce8\u91ca\u7ed9\u7684\u5f88\u6e05\u695a\n```cpp\n#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<vector>\n#include<map>\n#include<set>\n#include<algorithm>\n\n#define I_copy_this_answer return 0;\n\nusing namespace std;\n\nint n,m,head[1100],size=1;\nint mmx=1000,mincost,maxwater;\nint flow[1100];\nint need[1100],cost[310][310];\nint pre[1100],las[1100],dis[1100],vis[1100],hw[1100];\n\nstruct edge{\n\tint next,to,dis,flow; \n}e[100860]; \n\nvoid addedge(int next,int to,int dis,int flow)\n{\n\te[++size].to=to;\n\te[size].dis=dis;\n\te[size].flow=flow;\n\te[size].next=head[next];\n\thead[next]=size;\n}\n\n\nint spfa(int s)\n{\n\tmemset(flow,0x3f,sizeof(flow));\n\tmemset(dis,0x3f,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tqueue <int> q;\n\tq.push(s);\n\tdis[s]=0;\n\tvis[s]=1;\n\tpre[mmx]=-1;  //\uff08\u5176\u5b9e\u53ea\u8981\u4e0d\u662f\u4e0ep\u76f4\u63a5\u8fde\u7684\u70b9(n+1......n+m)\u5c31\u53ef\u4ee5\u4e86 \n\twhile(!q.empty())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\tvis[t]=0;\n\t\tint i,j,k,l;\n\t\tfor(i=head[t];i;i=e[i].next)\n\t\t{\n\t\t\tj=e[i].to;\n\t\t\tk=e[i].dis;\n\t\t\tl=e[i].flow;\n\t\t\tif(dis[t]+k<dis[j]&&l>0)  //\u6ca1\u6709\u6d41\u91cf\u7684\u8bdd\u8fd9\u6761\u8def\u5c31\u589e\u5e7f\u4e0d\u4e86\uff0c\u6700\u77ed\u8ddd\u79bb\u662f\u5efa\u7acb\u5728\u589e\u5e7f\u8def\u5b58\u5728\u7684\u57fa\u7840\u4e0a\u7684 \n\t\t\t{\n\t\t\t\tdis[j]=dis[t]+k;\n\t\t\t\tlas[j]=i;  //las\u6307\u7684\u662f\u8fd9\u4e2a\u70b9(j)\u4e0e\u4e0a\u4e2a\u70b9(t)\u76f8\u8fde\u7684\u8fb9\u7684\u7f16\u53f7 \n\t\t\t\tpre[j]=t;  //pre\u6307\u7684\u662f\u8fd9\u6761\u8def\u5f84\u4e0a\u8fd9\u4e2a\u70b9(j)\u7684\u4e0a\u4e00\u4e2a\u70b9 \n\t\t\t\tflow[j]=min(flow[t],l);  //\u628a\u5f53\u524d\u8fb9\u6d41\u91cf\u4e0e\u4e0a\u4e2a\u70b9\u7684\u6d41\u91cf\u5bf9\u6bd4\uff0c\u89e3\u51b3\u51fa\u73b0\u4ed3\u5e93\u8d27\u7269\u6bd4\u9700\u8981\u7684\u5c11\u7684\u60c5\u51b5 \n\t\t\t\tif(!vis[j])\n\t\t\t\t{\n\t\t\t\t\tq.push(j);\n\t\t\t\t\tvis[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn pre[mmx]!=-1;  //\u5982\u679c\u4e0d\u662f\u8fd9\u4e2a\u503c\u5c31\u8bf4\u660e\u8fd9\u4e2a\u70b9\u88ab\u5237\u65b0\uff0c\u589e\u5e7f\u6210\u529f \n}\n\nvoid mcmf()\n{\n\twhile(spfa(0))\n\t{\n\t\tmincost+=dis[mmx]*flow[mmx];   //\u4ece\u6e90\u70b9\u51fa\u53d1\u5230\u6c47\u70b9\u7684\u5355\u4f4d\u8d39\u7528\u518d\u4e58\u4ee5\u5355\u4f4d\uff0c\u7531\u4e8e\u6bcf\u6b21\u53ea\u589e\u5e7f\u4e00\u6761\u8def\uff0c\u800c\u4e14\u4ed3\u5e93\u548c\u5546\u5e97\u662f\u76f4\u63a5\u8fde\u63a5\u7684\uff0c\u53ef\u4ee5\u8fd9\u6837\u5199 \n\t\tint t=mmx;\n\t\twhile(t!=0)\n\t\t{\n\t\t\te[las[t]].flow-=flow[mmx];  //\u56de\u6eaf\uff0c\u4fee\u6539\u6bcf\u6761\u8fb9\u7684\u6d41\u91cf\uff0c\u56e0\u4e3a\u8be5\u7b97\u6cd5\u4e2d\u9014\u627e\u5230\u7684\u589e\u5e7f\u8def\u4e0d\u662f\u6700\u540e\u7684\u589e\u5e7f\u8def\uff0c\u6240\u4ee5\u8fd9\u4e2a\u8981\u7b49\u5230\u6700\u540e\u6765\u6539\u53d8 \n\t\t\te[las[t]^1].flow+=flow[mmx];\n\t\t\tt=pre[t];\n\t\t}\n\t}\n}\n\nvoid build_edge(int t)\n{\n\tint i,j;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\taddedge(0,i,0,hw[i]);\n\t\taddedge(i,0,0,0);\n\t} \n\tfor(i=1;i<=m;i++)\n\tfor(j=1;j<=n;j++)\n\t{\n\t\taddedge(i,j+m,cost[i][j]*t,need[j]);\n\t\taddedge(j+m,i,-cost[i][j]*t,0);\n\t}\n\tfor(i=1;i<=n;i++)\n\t{\n\t\taddedge(i+m,mmx,0,need[i]);\n\t\taddedge(mmx,i+m,0,0);\n\t}\n}\n\nint main()\n{\n\tint i,j;\n\tscanf(\"%d %d\",&m,&n);\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tint t1;\n\t\tscanf(\"%d\",&hw[i]);\t\n\t}\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&need[i]);\n\tfor(i=1;i<=m;i++)\n\tfor(j=1;j<=n;j++)\n\t\tscanf(\"%d\",&cost[i][j]);  //\u8bfb\u5165\uff0c\u4e0e\u4e0a\u9762\u7684cost,need,hw\u5982\u679c\u4e0d\u660e\u767d\u53ef\u4ee5\u5bf9\u7167\u8f93\u5165\u683c\u5f0f\u770b\u4ee3\u8868\u4ec0\u4e48\u610f\u601d \n\tbuild_edge(1);  //\u5efa\u7acb\u8fb9\u6743\u4e3a\u6b63\u7684\u8fb9\uff0c\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 \n\tmcmf();//\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41(Min Cost Max Flow \uff09\u7684\u7f29\u5199 \n\tprintf(\"%d\",mincost); \n\tmaxwater=0;\n\tmincost=0; \n\tsize=1;\n\tmemset(head,0,sizeof(head));\n\tbuild_edge(-1);\n\tmcmf();\n\tprintf(\"\\n%d\",-mincost);\n\tI_copy_this_answer\n}\n```\n",
        "postTime": 1562726683,
        "uid": 38636,
        "name": "\u5bd2\u51b0\u5927\u5927",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "### \u3010\u9898\u76ee\u5927\u610f\u3011\n- \u6709m\u4e2a\u4ed3\u5e93\uff0c\u6709n\u4e2a\u9500\u552e\u70b9\uff0c\u7b2ci\u4e2a\u4ed3\u5e93\u6709a[i]\u4ef6\u8d27\uff0c\u7b2cj\u4e2a\u9500\u552e\u70b9\u5fc5\u987b\u9500\u552eb[i]\u4ef6\u8d27\uff0c\u7b2ci\u4e2a\u4ed3\u5e93\u5230\u7b2cj\u4e2a\u9500\u552e\u70b9\u8981c[i][j]\u5143\uff0c\u95ee\u5b8c\u6210\u9500\u552e\u6700\u5c11/\u6700\u591a\u8981\u591a\u5c11\u5143\uff1f\n\n### \u3010\u89e3\u9898\u601d\u8def\u3011\n- \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u548c\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u3002\n- \u6784\u56fe\uff1a\n\t1. \u6e90\u70b9\u5411\u6bcf\u4e00\u4e2a\u4ed3\u5e93\u8fde\u63a5\u4e00\u6761\u6d41\u91cf\u4e3aa[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\u3002\n    1. \u4ed3\u5e93i\u5411\u9500\u552e\u70b9j\u8fde\u63a5\u4e00\u6761\u6d41\u91cf\u4e3a\u65e0\u7a77\u5927\uff0c\u8d39\u7528\u4e3ac[i][j]\u3002\n    1. \u9500\u552e\u70b9j\u5411\u6c47\u70b9\u8fde\u63a5\u4e00\u6761\u6d41\u91cf\u4e3ab[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\n- \u8dd1\u4e00\u4e2a\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u8f7b\u677e\u5b8c\u6210\u7b2c\u4e00\u4e2a\u4efb\u52a1\u3002\n- \u7b2c\u4e8c\u4e2a\u4efb\u52a1\u53ea\u8981\u6e05\u7a7a\u56fe\uff0c\u7136\u540e\u91cd\u65b0\u8fde\u63a5\u4e3a\u8d39\u7528\u662f-c[i]\u7684\u8fb9\u5373\u53ef\u3002\n\n### \u3010\u89e3\u9898\u53cd\u601d\u3011\n- \u627e\u6700\u5927\u53ef\u4ee5\u53d6\u53cd\u4ee5\u540e\u627e\u6700\u5c0f\u3002\n\n### \u3010\u53c2\u8003\u7a0b\u5e8f\u3011\n```cpp\n#include<cstdio>\n#include<queue>\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n#define INF 0x3f3f3f3f\nint cur=1,n,m,s,t,mcost,mflow;\nint head[5005],dis[5005],flow[5005],pre[5005];\nint a[5005],b[5005],c[5005][5005];\nstruct EDGE{\n    int t,next,w,f;\n}e[100005];\nvoid add(int a,int b,int w,int f)\n{\n    cur++;e[cur].t=b;e[cur].next=head[a];e[cur].w=w;e[cur].f=f;head[a]=cur;\n    cur++;e[cur].t=a;e[cur].next=head[b];e[cur].w=0;e[cur].f=-f;head[b]=cur;\n}\n\nqueue < int > q;\nbool vis[5005];\nbool SPFA(int s,int t)\n{\n    memset(dis,INF,sizeof dis);\n    memset(vis,0,sizeof vis);\n    dis[s]=0;\n    vis[s]=1;\n    flow[s]=INF;\n    q.push(s);\n    while (!q.empty())\n    {\n        int u=q.front();q.pop();\n        vis[u]=false;\n        for (int h=head[u];h!=-1;h=e[h].next)\n        {\n            int v=e[h].t,f=e[h].f;\n            if (e[h].w&&dis[u]+f<dis[v])//????????????\n            {\n                dis[v]=dis[u]+f;//??????\n                flow[v]=min(flow[u],e[h].w);//??????\n                pre[v]=h;//????\n                if (!vis[v])\n                {\n                    vis[v]=true;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    return dis[t]!=INF;\n}\n\nvoid Update(int s,int t)\n{\n    int x=t;\n    while (x!=s)\n    {\n        int i=pre[x];\n        e[i].w-=flow[t];\n        e[i^1].w+=flow[t];\n        x=e[i^1].t;\n    }//??????????????\n    mflow+=flow[t];\n    mcost+=flow[t]*dis[t];//????\n}\nvoid E_K(int s,int t)\n{\n    while (SPFA(s,t))//????????\n        Update(s,t);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&m,&n);\n    memset(head,-1,sizeof head);\n    s=0;t=m+n+1;\n    for (int i=1;i<=m;i++)\n    {\n    \tscanf(\"%d\",&a[i]);\n    \tadd(s,i,a[i],0);\n    }\n    for (int i=1;i<=n;i++)\n    {\n    \tscanf(\"%d\",&b[i]);\n    \tadd(i+m,t,b[i],0);\n    }\n    for (int i=1;i<=m;i++)\n    \tfor (int j=1;j<=n;j++)\n    \t{\n    \t\tscanf(\"%d\",&c[i][j]);\n    \t\tadd(i,j+m,INF,c[i][j]);\n    \t}\n    E_K(s,t);\n    printf(\"%d\\n\",mcost);\n    \n    memset(head,-1,sizeof head);\n    memset(e,0,sizeof e);\n    memset(flow,0,sizeof flow);\n    memset(pre,0,sizeof pre);\n    mcost=0;\n    for (int i=1;i<=m;i++)\n    {\n    \tadd(s,i,a[i],0);\n    }\n    for (int i=1;i<=n;i++)\n    {\n    \tadd(i+m,t,b[i],0);\n    }\n    for (int i=1;i<=m;i++)\n    \tfor (int j=1;j<=n;j++)\n    \t{\n    \t\tadd(i,j+m,INF,-c[i][j]);\n    \t}\n    E_K(s,t);\n    printf(\"%d\\n\",-mcost);\n    return 0;\n} \n```",
        "postTime": 1532787692,
        "uid": 12349,
        "name": "FREEH",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u4f7f\u7528\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u7b97\u6cd5\u3002\n\n\uff08\u63d2\u64ad\uff1a\u672c\u4eba\u6700\u8fd1\u4e13\u653b\u7d2b\u9898\u6700\u5927\u6d41\uff0c\u5177\u4f53\u89c1\u6211\u7684\u535a\u5ba2https://www.luogu.org/blog/user38212/\uff09\n\n\u5efa\u7acb\u4e00\u4e2a\u8d85\u7ea7\u539f\u70b9\uff08src\uff09\uff0c\u4e00\u4e2a\u8d85\u7ea7\u6c47\u70b9\uff08sink\uff09\u3002\u8fd9\u4e24\u4e2a\u70b9\u662f\u865a\u62df\u7684\u3002\n\n\u6700\u5927\u6d41\u4e2d\uff0c\u6700\u5927\u6d41\u4ee3\u8868\u4e70\u5356\u8d27\u7269\u7684\u60c5\u51b5\uff0c\u8d39\u7528\u4ee3\u8868\u5b9e\u9645\u8981\u82b1\u7684\u8d39\u7528\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a\u62e5\u6709a[i]\u8d27\u7269\u7684k\u70b9\uff0c\u6211\u4eec\u8fde\u4e00\u6761\u7531src\u5230k\uff0c\u5bb9\u91cf\u4e3aa[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u5bf9\u4e8e\u4e00\u4e2a\u8981\u6c42\u83b7\u5f97b[i]\u8d27\u7269\u7684k\u70b9\uff0c\u6211\u4eec\u8fde\u4e00\u6761\u4ecek\u5230sink\uff0c\u5bb9\u91cf\u4e3ab[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\n\n\u5bf9\u4e8e\u4e00\u6761i\u5230j\u4ef7\u683c\u4e3ap[i][j]\u7684\u53ef\u8fd0\u8f93\u8def\u5f84\uff0c\u6211\u4eec\u8fde\u4e00\u6761\u7531i\u53d1\u8d27\u70b9\u5230j\u8fdb\u8d27\u70b9\uff0c\u5bb9\u91cf\u4e3ainf\uff08\u56e0\u4e3a\u6bcf\u6761\u8def\u53ef\u4ee5\u65e0\u9650\u7528\uff09\u8d39\u7528\u4e3ap[i][j]\u7684\u8fb9\n\n\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\u3002\n\n\n\u4ee5\u6837\u4f8b\u4e3a\u4f8b\uff0c\u5efa\u56fe\u5982\u4e0b\n\n ![](https://cdn.luogu.com.cn/upload/pic/12990.png) \n\n(\u6bcf\u6761\u8fb9\u4e0a\u9ed1\u6570\u4e3a\u6700\u5927\u6d41\u7684\u5bb9\u91cf\uff0c\u7ea2\u8272\u4e3a\u8d39\u7528)\n\n\n\u4e0b\u9762\u89e3\u91ca\u4e00\u4e0bsrc\uff08\u8d85\u7ea7\u539f\u70b9\uff09\u548csink\uff08\u8d85\u7ea7\u6c47\u70b9\uff09\u7684\u5b58\u5728\u7684\u610f\u4e49\u3002\n\n\u9996\u5148\uff0c\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u610f\u4e49\u662f\uff1a\u5728\u6700\u5927\u6d41\u7684\u6761\u4ef6\u4e0b\u8dd1\u6700\u5c0f\u8d39\u7528\u3002\u8dd1\u4ecesrc\u5230sink\u7684\u6700\u5927\u6d41\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u51fa\u8d27\u70b9\uff0c\u51fa\u8d27\u7684\u6570\u91cf\u5c31\u662fsrc\u5230\u8fd9\u4e2a\u70b9\u8fb9\u7684\u6d41\u91cf\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u8fdb\u8d27\u70b9\uff0c\u8fdb\u8d27\u6570\u91cf\u5c31\u662f\u8fdb\u8d27\u70b9\u5230sink\u8fb9\u7684\u6d41\u91cf\u3002\n\n\u56e0\u4e3a\u5728\u6700\u5927\u6d41\u7684\u524d\u63d0\u4e0b\u8dd1\u6700\u5c0f\u8d39\u7528\uff0c\u6240\u4ee5\u4e00\u5b9a\u5df2\u7ecf\u505a\u5230\u6240\u6709\u8fdb\u8d27\u70b9\u8fdb\u8d27\u7684\u603b\u6570\u6700\u5927\u4e86\uff08\u56e0\u4e3a\u9898\u76ee\u4fdd\u8bc1\u53ef\u884c\uff0c\u6240\u4ee5\u4e00\u5b9a\u6240\u6709\u5230sink\u7684\u8fb9\u90fd\u6ee1\u6d41\uff0c\u5373\u6536\u8d27\u70b9\u90fd\u6ee1\u8d27\uff09\u3002\u6b64\u65f6\u518d\u8fdb\u884c\u6700\u5c0f\u8d39\u7528\u7684\u8ba1\u7b97\uff0c\u6b63\u597d\u5c31\u662f\u9898\u76ee\u6761\u4ef6\u3002\n\n\u9700\u8981\u6ce8\u610f\u5230\u7684\u662f\uff0c\u5b9e\u9645\u7a0b\u5e8f\u4e2d\u5e76\u4e0d\u662f\u5148\u628a\u6700\u5927\u6d41\u8dd1\u51fa\u6765\u518d\u8dd1\u6700\u77ed\u8def\uff0c\u8fd9\u91cc\u662f\u4e3a\u4e86\u8bb2\u89e3\u3002\n\n\n\u90a3\u4e48\u5982\u4f55\u6c42\u6700\u5927\u8d39\u7528\u5462\uff1f\n\n\u53ea\u9700\u628a\u6240\u6709\u8d39\u7528\u8fb9\u5efa\u6210\u8d1f\u7684\uff0c\u7ed3\u679c\u518d\u53d6\u76f8\u53cd\u6570\u5373\u53ef\u3002\n\n\u4ee3\u7801\n\n\n\n```cpp\n\n#include<iostream>\n#include <memory.h>\nconst int maxn=1005,maxm=500005,inf=1<<30;\nusing namespace std;\n//\u4ee5\u4e0b\u4e3a\u6211\u4f7f\u7528\u90bb\u63a5\u8868\u8868\u793a\u65b9\u6cd5\u7684\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u6a21\u677f\nstruct Node\n{\n    int v,c,w;\n    Node *next,*rev;\n}pool[maxm],*h[maxn],*pree[maxn];\nint n,m,s,t,tot,src,sink;\nint dis[maxn],q[maxn],prev[maxn];\nbool vis[maxn];\nint a[maxn],b[maxn],MAP[maxn][maxn];\nvoid addEdge(int u,int v,int c,int w)\n{\n    Node *p=&pool[++tot],*q=&pool[++tot];\n    p->v=v; p->c=c; p->w=w; p->next=h[u]; p->rev=q; h[u]=p;\n    q->v=u; q->c=0; q->w=-w; q->next=h[v]; q->rev=p; h[v]=q;\n}\n\nbool spfa(){\n    for(int i=1;i<maxn;i++) dis[i]=1<<30;\n    for(int i=1;i<maxn;i++) vis[i]=0;\n    int front=0,rear=0;\n    vis[src]=1,dis[src]=0;\n    q[rear++]=src;\n    while(front<rear)\n    {\n        int u=q[front++];\n        vis[u]=0;\n        for(Node *p=h[u];p;p=p->next)\n        {\n            if(p->c>0 && dis[p->v]>dis[u]+p->w)\n            {\n                dis[p->v]=dis[u]+p->w;\n                prev[p->v]=u;\n                pree[p->v]=p;\n                if(!vis[p->v])\n                {\n                    vis[p->v]=1;\n                    q[rear++]=p->v;\n                }\n            }\n        } \n    }\n    if(dis[sink]<inf) return true;\n    return false;\n}\n\nint augment(){\n    int u=sink;\n    int delta=inf;\n    while(u!=src)\n    {\n        delta=min(delta,pree[u]->c);\n        u=prev[u];\n    }\n    u=sink;\n    while(u!=src)\n    {\n        pree[u]->c-=delta;\n        pree[u]->rev->c+=delta;\n        u=prev[u];\n    }\n    return delta;\n}\nint ans1, ans2, zyy;\nvoid mincostflow(int flag)\n{\n    int delta=0;\n    while(spfa()==true)\n    {\n        delta=augment();\n        ans1+=delta;//\u6700\u5927\u6d41\n        ans2+=delta*dis[sink];//\u6700\u5c0f\u8d39\u7528\n    }\n    if(flag==4322) zyy=ans2;\n}\n\nint main(){\n//\u4ee5\u4e0b\u4e3a\u5efa\u56fe\uff0c\u672c\u9898\u5173\u952e\n    cin>>m>>n;\n    for(int i=1;i<=m;i++)\n    {\n        cin>>a[i];\n        addEdge(1,i+1,a[i],0); ///\u8fd9\u91cc\u8d85\u7ea7\u539f\u70b9src\u4e3a1\uff0c\u6c47\u70b9sink\u4e3am+n+2\n    }\n    for(int j=1;j<=n;j++)\n    {\n        cin>>b[j];\n        addEdge(j+m+1,m+n+2,b[j],0);//\u8fd9\u91cc\u4e3a\u4e86\u7f16\u53f7\uff0c\u5c06\u6240\u6709\u8fdb\u8d27\u70b9\u7684\u7f16\u53f7\u52a0\u4e86m\n        //\u5426\u5219\uff0c1\u8fdb\u8d27\u70b9\u548c1\u51fa\u8d27\u70b9\u5c06\u4f1a\u91cd\u5408\n    }\n    for(int i=1;i<=m;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            cin>>MAP[i][j];\n            addEdge(i+1,j+m+1,1<<30,MAP[i][j]);\n        }\n    }\n    src=1,sink=m+n+2;\n    mincostflow(4322);\n    cout<<ans2<<endl;\n    memset(h,0,sizeof(h));\n    for(int i=1;i<=m;i++)\n    {\n        addEdge(1,i+1,a[i],0);//\u540c\u6837\u7684\u5efa\u6cd5\u6c42\u6700\u5927\u8d39\u7528\n    }\n    for(int j=1;j<=n;j++)\n    {\n        addEdge(j+m+1,m+n+2,b[j],0);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            addEdge(i+1,j+m+1,1<<30,-1*MAP[i][j]);//\u8fd9\u91cc\u5efa\u8d1f\u8fb9\n        }\n    }\n    src=1,sink=m+n+2;\n    mincostflow(0);\n    cout<<-1*ans2+zyy<<endl;//\u8f93\u51fa\u7684\u6700\u5927\u503c\uff0c\u89c1\u4e0a\u9762\u89e3\u91ca\n    return 0;\n}\n```",
        "postTime": 1515586724,
        "uid": 38212,
        "name": "mydiplomacy",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u7ecf\u5178\u8d39\u7528\u6d41\u7528\u5904\u3002\n\n\u770b\u4e00\u4e0b\u53d1\u73b0\u56fe\u7684\u5f62\u72b6\u662f\u4e8c\u5206\u56fe\uff0c\u548c\u5de6\u8fb9\uff08\u4ed3\u5e93\uff09\u7684\u5165\u6d41\u662f\u56fa\u5b9a\u7684\uff0c\u53f3\u8fb9\uff08\u96f6\u552e\u5546\uff09\u7684\u51fa\u6d41\u662f\u56fa\u5b9a\u7684\uff1b\u4e4b\u95f4\u7684\u8fb9\u6709\u65e0\u9650\u6d41\u91cf\u4f46\u662f\u6709\u56fa\u5b9a\u8d39\u7528\u3002\n\n\u9047\u5230\u5355\u4f4d\u8d39\u7528\uff0c\u60f3\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u3002\u8fd9\u6837\u4fdd\u8bc1\u5de6\u8fb9\u5165\u6d41\u9650\u5236\u4f1a\u6ee1\u8db3\u548c\u5de6\u8fb9\u51fa\u6d41\u9650\u5236\u4e5f\u4f1a\u6ee1\u8db3\uff0c\u548c\u5728\u4e2d\u95f4\u7684\u8d39\u7528\u4e4b\u548c\u4f1a\u6700\u5927/\u6700\u5c0f\u3002\u5e94\u4e3a\u8d39\u7528\u6d41\u5e38\u89c4\u662f\u7b97\u6700\u5c0f\u8d39\u7528\uff0c\u6765\u8ba1\u7b97\u6700\u5927\u8d39\u7528\u53ef\u4ee5\u628a\u6240\u6709\u8d39\u7528\u6362\u6b63\u8d1f\uff0c\u6c42\u6539\u6b63\u8d1f\u8d39\u7528\u7684\u56fe\u7684\u6700\u5c0f\u8d39\u7528\u4e58`-1`.\n\n\u4ee3\u7801\uff08\u53bb\u6389\u8d39\u7528\u6d41\u677f\u5b50\uff09\uff1a\n\n```cpp\nint v1[105], v2[105], v3[105][105];\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int n, m; cin >> n >> m;\n    MCMF::init();\n    rep(i, n) {\n        int v; cin >> v;\n        v1[i] = v;\n        MCMF::ae(n+m, i, v, 0, 0);\n    }\n    iter(i, n, n+m) {\n        int v; cin >> v;\n        v2[i-n] = v;\n        MCMF::ae(i, n+m+1, v, 0, 0);\n    }\n    rep(i, n) iter(j, n, n+m) {\n        int v; cin >> v;\n        v3[i][j-n] = v;\n        MCMF::ae(i, j, MCMF::inf, v, 0);\n    }\n    cout << MCMF::run(n+m, n+m+1).se << endl;\n    MCMF::init();\n    rep(i, n) MCMF::ae(n+m, i, v1[i], 0, 0);\n    iter(i, n, n+m) MCMF::ae(i, n+m+1, v2[i-n], 0, 0);\n    rep(i, n) iter(j, n, n+m) MCMF::ae(i, j, MCMF::inf, -v3[i][j-n], 0);\n    cout << -MCMF::run(n+m, n+m+1).se << endl;\n}\n\n```",
        "postTime": 1581933330,
        "uid": 220037,
        "name": "w33z8kqrqk8zzzx33",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4015"
    },
    {
        "content": "\u597d\u50cf\u8fd8\u6ca1\u6709\u7528`Dijkstra`\u6c42\u6700\u5c0f\u8d39\u7528\u6d41\u7684qwq\n\n`Dijkstra`\u53ea\u80fd\u9002\u7528\u4e8e\u5168\u6b63\u6743\u56fe\u7684\u60c5\u51b5\uff0c\u800c\u6c42\u6700\u5c0f\u8d39\u7528\u6d41\u53ef\u80fd\u6d89\u53ca\u5230\u8d1f\u6743\u8fb9\uff08\u53cd\u8fb9\uff09\uff0c\u53ef\u4ee5\u91c7\u7528\u7c7b\u4f3c\u4e8e`Jhonson`\u7b97\u6cd5\u7684\u601d\u60f3\uff0c\u4f7f\u7528\u8282\u70b9\u7684\u52bf\u80fd\u8c03\u6574\u8fb9\u6743\u6765\u4f7f\u8fb9\u6743\u6052\u4e3a\u6b63\u6570\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u7ed9\u6bcf\u4e2a\u8282\u70b9\u8d4b\u4e00\u4e2a\u9876\u6807$\\pi_i$\uff0c\u4f7f\u5f97$c_{ij}-\\pi_i+\\pi_j\\geq 0$\uff0c\u7136\u540e\u4f7f\u7528$c_{ij}-\\pi_i+\\pi_j$\u4f5c\u4e3a\u8fb9\u6743\uff0c\u8ba1\u7b97\u6700\u77ed\u8def\u4e4b\u540e\u53ea\u9700\u8981\u5c06\u7ed3\u679c\u51cf\u53bb$\\pi_j$\u5c31\u597d\u4e86\u3002\n\n\u9876\u6807\u7684\u9009\u53d6\u53ef\u4ee5\u76f4\u63a5\u91c7\u7528\u4e0a\u4e00\u6b21\u6700\u77ed\u8def\u7684\u7ed3\u679c\u3002\n\n\u4f46\u662f\u95ee\u9898\u662f\u8fd9\u9053\u9898\u7684\u7b2c\u4e8c\u5c0f\u95ee\u4e00\u5f00\u59cb\u5c31\u6709\u8d1f\u6743\u8fb9\u3002\u9762\u5bf9\u8fd9\u79cd\u60c5\u51b5\uff0c\u6807\u51c6\u505a\u6cd5\u662f\u4f7f\u7528`SPFA`\u6c42\u51fa\u521d\u59cb\u9876\u6807\uff08~~\u6240\u4ee5\u4f60\u7684\u7a0b\u5e8f\u65e2\u6709`Dijkstra`\u53c8\u6709`SPFA`~~\uff09\uff0c\u4f46\u662f\u53ef\u4ee5\u53d1\u73b0\u6211\u4eec\u76f4\u63a5\u7528$max(c_{ij})-c_{ij}$\u4f5c\u4e3a\u521d\u59cb\u8fb9\u6743\uff08\u5373\u6bcf\u6761\u8fb9\u53d6\u53cd\u4e4b\u540e\u90fd\u52a0\u4e0a\u4e00\u4e2a\u503c\u4f7f\u5f97\u4ed6\u4eec\u90fd\u4e3a\u6b63\u8fb9\uff09\u4e0d\u4f1a\u5f71\u54cd\u6700\u540e\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u7684\u6240\u6709\u8def\u6d41\u7684\u957f\u5ea6\u76f8\u7b49\u3002\u6240\u4ee5\u5c31\u4e0d\u9700\u8981\u5199`SPFA`\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(\\text{\u7f51\u7edc\u6d41})$\u3002\n\n\u9644AC\u4ee3\u7801\uff1a\n\n```cpp\n#include <queue>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nvoid chkmax(int& a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta = b;\n\t}\n}\n\n#define INF 0x7f7f7f7f\n\nint beg[215];\nint ed[100005];\nint nxt[100005];\nint ci[100005];\nint fi[100005];\nint top = 1;\n\nvoid addedge(int a,int b,int c,int f)\n{\n\t++top;\n\ted[top] = b;\n\tci[top] = c;\n\tfi[top] = f;\n\tnxt[top] = beg[a];\n\tbeg[a] = top;\n}\n\nvoid addedget(int a,int b,int c,int f)\n{\n\taddedge(a,b,c,f);\n\taddedge(b,a,0,-f);\n}\n\nint dn;\nint s,t;\nint dist[215];\nint vis[215];\nint pre[215];\nint cnt[215];\n\nbool dijkstra()\n{\n\tfor(int i=1; i<=dn; ++i)\n\t{\n\t\tdist[i] = INF-pre[i];\n\t\tcnt[i] = beg[i];\n\t\tvis[i] = 0;\n\t}\n\t\n\tdist[t] = 0;\n\tpriority_queue<pair<int,int> > pq;\n\tpq.push(make_pair(0,t));\n\t\n\twhile(!pq.empty())\n\t{\n\t\tint th = pq.top().second;\n\t\tpq.pop();\n\t\tif(vis[th])\n\t\t\tcontinue;\n\t\t\t\n\t\tvis[th] = 1;\n\t\t\n\t\tfor(int p=beg[th]; p; p=nxt[p])\n\t\t{\n\t\t\tif(ci[p^1] && dist[ed[p]]>dist[th]+fi[p^1]+pre[th]-pre[ed[p]])\n\t\t\t{\n\t\t\t\tdist[ed[p]] = dist[th]+fi[p^1]+pre[th]-pre[ed[p]];\n\t\t\t\tpq.push(make_pair(-dist[ed[p]],ed[p]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1; i<=dn; ++i)\n\t{\n\t\tdist[i] += pre[i];\n\t\tpre[i] = dist[i];\n\t}\n\t\n\treturn dist[s]!=INF;\n}\n\nint svis[215];\n\nint sap(int s,int flow)\n{\n\tif(s==t)\n\t\treturn flow;\n\t\n\tsvis[s] = 1;\n\n\tint flowed = 0;\n\tfor(int& p=cnt[s]; p&&flow; p=nxt[p])\n\t{\n\t\tif(ci[p] && !svis[ed[p]] && dist[s]-fi[p]==dist[ed[p]])\n\t\t{\n\t\t\tint f = sap(ed[p],min(ci[p],flow));\n\t\t\tci[p] -= f;\n\t\t\tci[p^1] += f;\n\t\t\tflowed += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\n\tsvis[s] = 0;\n\t\n\treturn flowed;\n}\n\nint ai[105];\nint bi[105];\nint cij[105][105];\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1; i<=n; ++i)\n\t\tscanf(\"%d\",ai+i);\n\tfor(int i=1; i<=m; ++i)\n\t\tscanf(\"%d\",bi+i);\n\tfor(int i=1; i<=n; ++i)\n\t\tfor(int j=1; j<=m; ++j)\n\t\t\tscanf(\"%d\",cij[i]+j);\n\t\t\n\ts = n+m+1;\n\tt = n+m+2;\n\tdn = n+m+2;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\taddedget(s,i,ai[i],0);\n\t}\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\taddedget(i+n,t,bi[i],0);\n\t}\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tfor(int j=1; j<=m; ++j)\n\t\t{\n\t\t\taddedget(i,j+n,INF,cij[i][j]);\n\t\t}\n\t}\n\t\t\t\n\tlong long ans1 = 0;\n\twhile(dijkstra())\n\t{\n\t\tans1 += 1LL*dist[s]*sap(s,INF);\n\t}\n\n\tint maxd = 0;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tfor(int j=1; j<=m; ++j)\n\t\t{\n\t\t\tchkmax(maxd,cij[i][j]);\n\t\t}\n\t}\n\tint sf = 0;\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tsf += ai[i];\n\t}\n\n\tmemset(beg,0,sizeof(beg));\n\ttop = 1;\n\t\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\taddedget(s,i,ai[i],0);\n\t}\n\tfor(int i=1; i<=m; ++i)\n\t{\n\t\taddedget(i+n,t,bi[i],0);\n\t}\n\tfor(int i=1; i<=n; ++i)\n\t{\n\t\tfor(int j=1; j<=m; ++j)\n\t\t{\n\t\t\taddedget(i,j+n,INF,maxd-cij[i][j]);\n\t\t}\n\t}\n\t\n\tlong long ans2 = 0;\n\twhile(dijkstra())\n\t{\n\t\tans2 += 1LL*dist[s]*sap(s,INF);\n\t}\n\t\n\tprintf(\"%lld\\n%lld\\n\",ans1,-(ans2-1LL*maxd*sf));\n}\n```",
        "postTime": 1572438050,
        "uid": 49458,
        "name": "\u6728\u6728\uff01",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "[*\u83b7\u5f97\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c*](https://www.cnblogs.com/Lemir3/p/11161587.html)\n\n\u300c\u7f51\u7edc\u6d41 24 \u9898\u300d\u8fd0\u8f93\u95ee\u9898\n\n[*\u9898\u9762*](https://www.luogu.org/problemnew/show/P4015)\n\n\u5148\u6765\u7406\u89e3\u4e0b\u9898\u610f.\n\n\u6709$m$\u4e2a\u4ed3\u5e93,\u7b2c$i$\u4e2a\u4ed3\u5e93\u6709$a_i$\u4e2a\u8d27\u7269.\u6709$n$\u4e2a\u5546\u5e97,\u7b2c$i$\u4e2a\u5546\u5e97\u9700\u8981$b_i$\u4e2a\u8d27\u7269.\u4ece\u7b2c$i$\u4e2a\u4ed3\u5e93\u8fd0\u5230\u7b2c$j$\u4e2a\u5546\u5e97\u7684\u8d39\u7528\u662f$c_{ij}$.\n\n\u4e8e\u662f\u7f51\u7edc\u6d41\u7684\u5efa\u6a21\u5c31\u51fa\u6765\u4e86,\u6e90\u70b9\u8fde\u5411\u4ed3\u5e93,\u6d41\u91cf\u4e3a$a_i$,\u8d39\u7528\u4e3a$0$.\u4ed3\u5e93\u4e0e\u5546\u5e97\u4e4b\u95f4\u76f8\u8fde,\u6d41\u91cf\u4e3a$INF$,\u8d39\u7528\u4e3a$c_{ij}$,\u5546\u5e97\u4e0e\u6c47\u70b9\u76f8\u8fde,\u6d41\u91cf\u4e3a$b_i$,\u8d39\u7528\u4e3a$0$.\n\n\u8dd1\u4e00\u904d$MCMF$\u6c42\u51fa\u6700\u5c0f\u8d39\u7528.\n\n\u7136\u540e\u518d\u7ed9\u8d39\u7528\u53d6\u53cd,\u518d\u8dd1\u4e00\u904d$MCMF$\u6c42\u51fa\u6700\u5927\u8d39\u7528.\n\n#\u4ee3\u7801\n\n```cpp\n\n#include \"cstdio\"\n#include \"cstring\"\n#include \"algorithm\"\n#include \"iostream\"\n#include \"cmath\"\n#include \"queue\"\n\n#define debug(x) printf(\"debug:%lld\\n\",x)\n#define ll long long\n#define INF 2147483647\n\nusing namespace std;\n\nstruct edge\n{\n    ll to,next,flow,cost;\n}e1[500010],e2[500010];\n\nqueue<ll>q1,q2;\n\nll m,n,start,end,size1,size2,mincost,maxcost;//m\u4e2a\u4ed3\u5e93,n\u4e2a\u5546\u5e97.\nll head1[10010],dis1[10010],flow1[10010],last1[10010],pre1[10010];\nll head2[10010],dis2[10010],flow2[10010],last2[10010],pre2[10010];\nbool flag1[10010];\nbool flag2[10010];\n\ninline void EdgeAdd1(ll,ll,ll,ll);\ninline void EdgeAdd2(ll,ll,ll,ll);\ninline void MCMF1();\ninline void MCMF2();\ninline bool SPFA1();\ninline bool SPFA2();\n\nsigned main(void)\n{\n    memset(head1,-1,sizeof(head1));\n    memset(head2,-1,sizeof(head2));\n    scanf(\"%lld%lld\",&m,&n);\n    start=0;\n    end=m+n+1;\n    for(ll _=1;_<=m;_++)\n    {\n        ll val;\n        scanf(\"%lld\",&val);\n        EdgeAdd1(start,_,val,0);\n        EdgeAdd1(_,start,0,0);\n        EdgeAdd2(start,_,val,0);\n        EdgeAdd2(_,start,0,0);\n    }\n    for(ll _=1;_<=n;_++)\n    {\n        ll val;\n        scanf(\"%lld\",&val);\n        EdgeAdd1(_+m,end,val,0);\n        EdgeAdd1(end,_+m,0,0);\n        EdgeAdd2(_+m,end,val,0);\n        EdgeAdd2(end,_+m,0,0);\n    }\n    for(ll _=1;_<=m;_++)\n    {\n        for(ll __=1;__<=n;__++)\n        {\n            ll cost;\n            scanf(\"%lld\",&cost);\n            EdgeAdd1(_,__+m,INF,cost);\n            EdgeAdd1(__+m,_,0,-cost);\n            EdgeAdd2(_,__+m,INF,-cost);\n            EdgeAdd2(__+m,_,0,cost);\n        }\n    }\n    MCMF1();\n    MCMF2();\n    printf(\"%lld\\n%lld\\n\",mincost,-maxcost);\nreturn 0;\n}\n\ninline void EdgeAdd1(ll from,ll to,ll flow,ll cost)\n{\n    e1[size1].to=to;\n    e1[size1].flow=flow;\n    e1[size1].cost=cost;\n    e1[size1].next=head1[from];\n    head1[from]=size1++;\n}\n\ninline void EdgeAdd2(ll from,ll to,ll flow,ll cost)\n{\n    e2[size2].to=to;\n    e2[size2].flow=flow;\n    e2[size2].cost=cost;\n    e2[size2].next=head2[from];\n    head2[from]=size2++;\n}\n\ninline void MCMF1()\n{\n    while(SPFA1())\n    {\n        ll now=end;\n        mincost+=flow1[end]*dis1[end];\n        while(now!=start)\n        {\n            e1[last1[now]].flow-=flow1[end];\n            e1[last1[now]^1].flow+=flow1[end];\n            now=pre1[now];\n        }\n    }\n}\n\ninline void MCMF2()\n{\n    while(SPFA2())\n    {\n        ll now=end;\n        maxcost+=flow2[end]*dis2[end];\n        while(now!=start)\n        {\n            e2[last2[now]].flow-=flow2[end];\n            e2[last2[now]^1].flow+=flow2[end];\n            now=pre2[now];\n        }\n    }\n}\n\ninline bool SPFA1()\n{\n    memset(dis1,0x3f,sizeof(dis1));\n    memset(flag1,false,sizeof(flag1));\n    memset(flow1,0x3f,sizeof(flow1));\n    q1.push(start);\n    pre1[end]=-1;\n    dis1[start]=0;\n    flag1[start]=true;\n    while(q1.empty()==false)\n    {\n        ll from=q1.front();\n        q1.pop();\n        flag1[from]=false;\n        for(ll _=head1[from];_!=-1;_=e1[_].next)\n        {\n            ll to=e1[_].to;\n            ll cost=e1[_].cost;\n            ll flow_=e1[_].flow;\n            if(flow_>0&&dis1[to]>dis1[from]+cost)\n            {\n                dis1[to]=dis1[from]+cost;\n                pre1[to]=from;\n                last1[to]=_;\n                flow1[to]=min(flow1[from],flow_);\n                if(flag1[to]==false)\n                {\n                    q1.push(to);\n                    flag1[to]=true;\n                }\n            }\n        }\n    }\nreturn pre1[end]==-1?false:true;\n}\n\ninline bool SPFA2()\n{\n    memset(flag2,false,sizeof(flag2));\n    memset(dis2,0x3f,sizeof(dis2));\n    memset(flow2,0x3f,sizeof(flow2));\n    q2.push(start);\n    flag2[start]=true;\n    dis2[start]=0;\n    pre2[end]=-1;\n    while(!q2.empty())\n    {\n        ll from=q2.front();\n        q2.pop();\n        flag2[from]=false;\n        for(ll _=head2[from];_!=-1;_=e2[_].next)\n        {\n            ll to=e2[_].to;\n            ll cost=e2[_].cost;\n            ll flow_=e2[_].flow;\n            if(flow_>0&&dis2[to]>dis2[from]+cost)\n            {\n                dis2[to]=dis2[from]+cost;\n                pre2[to]=from;\n                last2[to]=_;\n                flow2[to]=min(flow2[from],flow_);\n                if(flag2[to]==false)\n                {\n                    q2.push(to);\n                    flag2[to]=true;\n                }\n            }\n        }\n    }\nreturn pre2[end]==-1?false:true;\n}\n\n```",
        "postTime": 1562832359,
        "uid": 54986,
        "name": "lemir3",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u4e8c\u5206\u56fe\u5b8c\u7f8e\u5339\u914d\u95ee\u9898\n\n\u7c7b\u4f3c\u7684\u9898\u76ee\u5728 P4014\u5206\u914d\u95ee\u9898\n\n\u5efa\u6a21\u65b9\u5f0f\u4e0e\u4e0a\u9898\u7c7b\u4f3c\u2193\n\n![](https://cdn.luogu.com.cn/upload/pic/15967.png)\n\n\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u548c\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\n\n\u4e0a\u4ee3\u7801\u2193\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=2e9;\n\nint n,m,s,t,x[101][101],np=1,mct;\nint h[205],ln[205],q[25005];\nbool vis[205];\nstruct rpg{\n\tint li,nx,ln,ct;\n}a[25005];\n\nvoid add(int ls,int nx,int ln,int ct){\n\ta[++np]=(rpg){h[ls],nx,ln,ct};\n\th[ls]=np;\n\ta[++np]=(rpg){h[nx],ls,0,-ct};\n\th[nx]=np;\n}\n\nbool spfa(){\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=0;i<=t;++i) ln[i]=INF;\n\tint hd=1,tl=1;\n\tq[hd]=t;\n\tln[t]=0;\n\tvis[t]=1;\n\twhile(hd<=tl){\n\t\tint nw=q[hd++];\n\t\tvis[nw]=0;\n\t\tfor(int i=h[nw];i;i=a[i].li){\n\t\t\tif(a[i^1].ln&&ln[a[i].nx]>ln[nw]-a[i].ct){\n\t\t\t\tln[a[i].nx]=ln[nw]-a[i].ct;\n\t\t\t\tif(!vis[a[i].nx]){\n\t\t\t\t\tvis[a[i].nx]=1;\n\t\t\t\t\tq[++tl]=a[i].nx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}return ln[s]<INF;\n}\n\nint dfs(int u,int maxn){\n\tif(u==t||!maxn) return maxn;\n\tvis[u]=1;\n\tint sum=0;\n\tfor(int i=h[u];i;i=a[i].li){\n\t\tif(a[i].ln&&!vis[a[i].nx]&&ln[a[i].nx]==ln[u]-a[i].ct){\n\t\t\tint f=dfs(a[i].nx,min(maxn,a[i].ln));\n\t\t\tif(f){\n\t\t\t\tmaxn-=f;\n\t\t\t\tsum+=f;\n\t\t\t\ta[i].ln-=f;\n\t\t\t\ta[i^1].ln+=f;\n\t\t\t\tif(!maxn) break;\n\t\t\t}\n\t\t}\n\t}return sum;\n}\n\nvoid dnc(){\n\twhile(spfa()){\n\t\tvis[t]=1;\n\t\twhile(vis[t]){\n\t\t\tmemset(vis,0,sizeof(vis));\n\t\t\tint d=dfs(s,INF);\n\t\t\tmct+=d*ln[s];\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);t=n+m+1;\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x[i][0]);\n\t\tadd(s,i,x[i][0],0);\n\t}for(int i=1;i<=m;++i){\n\t\tscanf(\"%d\",&x[0][i]);\n\t\tadd(i+n,t,x[0][i],0);\n\t}for(int i=1;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tscanf(\"%d\",&x[i][j]);\n\t\t\tadd(i,j+n,INF,x[i][j]);\n\t\t}\n\t}dnc();\n\tprintf(\"%d\\n\",mct);mct=0;\n\tfor(int i=h[s];i;i=a[i].li){\n\t\ta[i].ln=x[a[i].nx][0];\n\t\ta[i^1].ln=0;\n\t}for(int i=1;i<=n;++i){\n\t\tfor(int j=h[i];j;j=a[j].li){\n\t\t\tif(a[j].nx>i){\n\t\t\t\ta[j].ln=INF;\n\t\t\t\ta[j^1].ln=0;\n\t\t\t\ta[j].ct=-a[j].ct;\n\t\t\t\ta[j^1].ct=-a[j^1].ct;\n\t\t\t}\n\t\t}\n\t}for(int i=h[t];i;i=a[i].li){\n\t\ta[i^1].ln=x[0][a[i].nx-n];\n\t\ta[i].ln=0;\n\t}dnc();\n\tprintf(\"%d\\n\",-mct);\n\treturn 0;\n}\n```",
        "postTime": 1521701967,
        "uid": 31293,
        "name": "Adove",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u51e0\u4e4e\u662f\u8d39\u7528\u6d41\u7684\u6a21\u677f\u9898\u3002\u3002\u3002\n\n\u5efa\u7acbS\u4e0eT\n\ns--->i,\u5bb9\u91cf\u4e3ai\u53f7\u4ed3\u5e93\u7684\u8d27\u7269\u6570\uff0c\u957f\u5ea6\u4e3a0\n\nj--->t,\u5bb9\u91cf\u4e3aj\u5e97\u94fa\u9700\u6c42\u8d27\u7269\u6570\uff0c\u957f\u5ea6\u4e3a0\n\ni--->j\uff0c\u5bb9\u91cf\u4e3ainf\uff0c\u957f\u5ea6\u4e3a\u7ed9\u5b9a\u503c\n\n\u6c42\u4e00\u4e2a\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u548c\u4e00\u4e2a\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\n\n\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u53ef\u4ee5\u5c06\u957f\u5ea6\u53bb\u53cd\uff0c\u7136\u540e\u6700\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u518d\u8f93\u51fa\u8d1f\u7684\u6700\u5c0f\u82b1\u8d39\u5373\u53ef\n\n#\u4ee3\u7801\n\n\n\n```cpp\n#include<iostream>\n#include<cstring>\n#define inf 1<<30\n#include<cstdio>\n#define M 300000\n#include<queue>\n#define N 500\nusing namespace std;\nint s,t,n,m,a[110],b[110],ma[110][110];\nint head[N],from[M],to[M],Next[M],len[M],cup[M],e=1;\nvoid buid(int u,int v,int c,int l)\n{\n    Next[++e]=head[u];head[u]=e;to[e]=v;\n    len[e]=l;cup[e]=c;from[e]=u;\n    Next[++e]=head[v];head[v]=e;to[e]=u;\n    len[e]=-l;cup[e]=0;from[e]=v;\n}\nint dis[N],init[N],pre[N],mflow,mcost;\nqueue<int> q;\nbool bfs()\n{\n    for(int i=s;i<=t;++i) dis[i]=inf;\n    dis[s]=0;init[s]=1;q.push(s);\n    while(!q.empty())\n    {\n        int now=q.front();q.pop();init[now]=0;\n        for(int i=head[now];i;i=Next[i])\n        {\n            if(!cup[i]) continue;\n            int j=to[i];\n            if(dis[j]>dis[now]+len[i])\n            {\n                dis[j]=dis[now]+len[i];\n                pre[j]=i;\n##                 if(!init[j]) init[j]=1,q.push(j); \n            }\n        }\n    }\n    return dis[t]!=inf;\n}\nvoid doit()\n{\n    int now=t,get=inf;\n    while(now!=s)\n    {\n        get=min(get,cup[pre[now]]);\n        now=from[pre[now]];\n    }\n    mflow+=get;mcost+=get*dis[t];\n    now=t;\n    while(now!=s)\n    {\n        cup[pre[now]]-=get;\n        cup[pre[now]^1]+=get;\n        now=from[pre[now]];\n    }\n}\nvoid max_min()\n{\n    while(bfs()) doit();\n}\nvoid MloVtry(int fl)\n{\n    for(int i=1;i<=n;++i) buid(s,i,a[i],0);\n    for(int i=1;i<=m;++i) buid(n+i,t,b[i],0);\n    for(int i=1;i<=n;++i)\n    for(int j=1;j<=m;++j)\n    buid(i,n+j,inf,ma[i][j]*fl);\n    max_min();\n    printf(\"%d\\n\",mcost*fl);\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    t=n+m+1;\n    for(int i=1;i<=n;++i) scanf(\"%d\",&a[i]);\n    for(int i=1;i<=m;++i) scanf(\"%d\",&b[i]);\n    for(int i=1;i<=n;++i)\n    for(int j=1;j<=m;++j) scanf(\"%d\",&ma[i][j]);\n    MloVtry(1);\n    memset(head,0,sizeof(head));\n    e=1;mcost=0;\n    MloVtry(-1);\n    return 0;\n}\n//\u5c9b\u98ce\u5feb\u56de\u5bb6\u554a\u554a\u554a\u554a\u554a\u554a\n//\u6709\u65b0\u8863\u670d\u6709\u6212\u6307\u5c31\u5dee\u4f60\u4eba\u4e86\u554a\u554a\u554a\u554a\u554a\u554a\u554a\u554a\n//QwQ\n\n```",
        "postTime": 1514359749,
        "uid": 35718,
        "name": "MloVtry",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u9898\u9762\u5df2\u7ecf\u63d0\u793a\u6211\u4eec\u8fd9\u662f\u8d39\u7528\u6d41\u4e86\n\n\u90a3\u4e48\u7531\u6e90\u70b9\u5411\u6240\u6709\u4ed3\u5e93\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a\u4ed3\u5e93\u539f\u6709\u8d27\u7269\u91cf\uff0c\u8d39\u7528\u4e3a0\n\n\u7136\u540e\u7531\u6240\u6709\u96f6\u552e\u5546\u5e97\u5411\u6c47\u70b9\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a\u4e00\u4e2a\u96f6\u552e\u5546\u5e97\u7684\u9700\u6c42\u91cf\uff0c\u8d39\u7528\u4e3a0\n\n\u6700\u540e\u7531\u4ed3\u5e93\u5411\u96f6\u552e\u5546\u5e97\u8fde\u8fb9\uff0c\u5bb9\u91cf\u6b63\u65e0\u7a77\uff08\u7531\u4e8e\u6e90\u70b9\u548c\u6c47\u70b9\u7684\u9650\u5236\uff0c\u6240\u4ee5\u4e0d\u4f1a\u51fa\u73b0\u4e0d\u5408\u6cd5\u60c5\u51b5\uff09\uff0c\u8d39\u7528\u4e3a\u9898\u7ed9\u8d39\u7528\n\n\u7136\u540e\u8dd1\u8d39\u7528\u6d41\u5c31\u5f97\u5230\u4e86\u6700\u5c0f\u8d39\u7528\n\n\u81f3\u4e8e\u6700\u5927\u8d39\u7528\uff0c\u6309\u5957\u8def\u6240\u6709\u8d39\u7528\u53d6\u53cd\u540e\u518d\u8dd1\u4e00\u904d\u8d39\u7528\u6d41\u5373\u53ef\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nstruct Edge\n{\n    int next;\n    int to;\n    int val;\n    int pri;\n}edge[40005];\nint head[255];\nint dis[255];\nint pre[255];\nint fa[255];\nbool used[255];\nint lim[255];\nint v1[255];\nint v2[255][255];\nint cnt=1;\nint st,ed;\nint n,m;\nvoid init()\n{\n    memset(head,-1,sizeof(head));\n    memset(edge,0,sizeof(edge));\n    cnt=1;\n}\nvoid add(int l,int r,int w,int v)\n{\n    edge[cnt].next=head[l];\n    edge[cnt].to=r;\n    edge[cnt].val=w;\n    edge[cnt].pri=v;\n    head[l]=cnt++;\n}\nint ide(int x)\n{\n    return (x&1)?x+1:x-1;\n}\nbool spfa()\n{\n    memset(dis,0x3f,sizeof(dis));\n    memset(used,0,sizeof(used));\n    memset(lim,0,sizeof(lim));\n    dis[st]=0;\n    pre[ed]=-1;\n    lim[st]=inf;\n    used[st]=1;\n    queue <int> M;\n    M.push(st);\n    while(!M.empty())\n    {\n        int u=M.front();\n        M.pop();\n        for(int i=head[u];i!=-1;i=edge[i].next)\n        {\n            int to=edge[i].to;\n            if(edge[i].val&&dis[to]>dis[u]+edge[i].pri)\n            {\n                lim[to]=min(lim[u],edge[i].val);\n                dis[to]=dis[u]+edge[i].pri;\n                pre[to]=i,fa[to]=u;\n                if(!used[to])used[to]=1,M.push(to);\n            }\n        }\n        used[u]=0;\n    }\n    return pre[ed]!=-1;\n}\nint EK()\n{\n    int maxw=0,minv=0;\n    while(spfa())\n    {\n        maxw+=lim[ed];\n        minv+=lim[ed]*dis[ed];\n        int temp=ed;\n        while(temp!=st)\n        {\n            edge[pre[temp]].val-=lim[ed];\n            edge[ide(pre[temp])].val+=lim[ed];\n            temp=fa[temp];\n        }\n    }\n    return minv;\n}\nint main()\n{\n    init();\n    scanf(\"%d%d\",&n,&m);\n    st=m+n+1,ed=m+n+2;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&v1[i]);\n        add(st,i,v1[i],0);\n        add(i,st,0,0);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d\",&v1[i+n]);\n        add(i+n,ed,v1[i+n],0);\n        add(ed,i+n,0,0);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            scanf(\"%d\",&v2[i][j+n]);\n            add(i,j+n,inf,v2[i][j+n]);\n            add(j+n,i,0,-v2[i][j+n]);\n        }\n    }\n    printf(\"%d\\n\",EK());\n    init();\n    for(int i=1;i<=n;i++)\n    {\n        add(st,i,v1[i],0);\n        add(i,st,0,0);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        add(i+n,ed,v1[i+n],0);\n        add(ed,i+n,0,0);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            add(i,j+n,inf,-v2[i][j+n]);\n            add(j+n,i,0,v2[i][j+n]);\n        }\n    }\n    printf(\"%d\\n\",-EK());\n    return 0;\n}\n```\n",
        "postTime": 1556235027,
        "uid": 66905,
        "name": "leozhang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u8d39\u7528\u6d41\u7ecf\u5178\u9898\u76ee\uff0c\u6211\u7528\u7684ZKW\u7b97\u6cd5\uff0c\u6307\u9488\u5b58\u56fe\n\n### \u601d\u8def\n\n- \u8bbe\u8d85\u7ea7\u6e90\u70b9\u4e3a$0$\uff0c\u8d85\u7ea7\u6c47\u70b9\u4e3a$n + m + 1$\u8fdb\u884c\u5efa\u56fe\n\n- \u5bf9\u4e8e$\\forall i \\in [1, m]$\uff0c\u4ece$0$\u5411$i$\u5efa\u7acb\u5bb9\u91cf\u4e3a$a_i$\uff0c\u8d39\u7528$0$\u7684\u8fb9\n\n- \u5bf9\u4e8e$\\forall j \\in [1, n]$\uff0c\u4ece$m + j$\u5411$n + m + 1$\u5efa\u7acb\u5bb9\u91cf\u4e3a$b_i$\uff0c\u8d39\u7528$0$\u7684\u8fb9\n\n- \u5bf9\u4e8e$\\forall i \\in [1, m], \\forall j \\in [1, n]$\uff0c\u4ece$i$\u5411$m + j$\u5efa\u7acb\u5bb9\u91cf\u4e3a$\\infty$\uff0c\u8d39\u7528$c_{i, j}$\u7684\u8fb9\n\n\u7136\u540e\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u548c\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\n\n### \u7a0b\u5e8f\u5b9e\u73b0\n\n\u6309\u7167\u4e0a\u9762\u7684\u601d\u8def\uff0c\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n// luogu-judger-enable-o2\n#include <iostream>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\nconst int MAXN = 105;\nconst int INF = 0x3f3f3f3f;\n\nint m, n;\n\nstruct Edge{\n    int to, val, cost;\n    Edge *next, *ops;\n    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}\n};\n\nnamespace Zkw1{\n    Edge *head[MAXN << 1], *cur[MAXN << 1];\n    bool vis[MAXN << 1];\n    int dis[MAXN << 1];\n    int s, t, res ,ans;\n\n    void AddEdge(int u, int v, int w, int c) {\n        head[u] = new Edge(v, w, c, head[u]);\n        head[v] = new Edge(u, 0, -c, head[v]);\n        head[u]->ops = head[v]; head[v]->ops = head[u];\n    }\n\n    bool Spfa() {\n        memset(dis, INF, sizeof(dis));\n        memset(vis, false, sizeof(vis));\n        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop_front();\n            vis[u] =false;\n            for (Edge *e = head[u]; e; e = e->next) {\n                int v = e->to;\n                if (e->val > 0 && dis[u] + e->cost < dis[v]) {\n                    dis[v] = dis[u] + e->cost;\n                    if (!vis[v]) {\n                        vis[v] = true;\n                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);\n                        else q.push_back(v);\n                    }\n                }\n            }\n        }\n        return dis[t] < INF;\n    }\n\n    int Dfs(int u, int flow) {\n        vis[u] = true;\n        if (u == t) {\n            res += flow;\n            return flow;\n        }\n        int used = 0;\n        for (Edge *&e = cur[u]; e; e = e->next) {\n            int v = e->to;\n            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n                int mi = Dfs(v, min(e->val, flow - used));\n                if (mi) {\n                    used += mi;\n                    e->val -= mi;\n                    e->ops->val += mi;\n                    ans += e->cost * mi;\n                }\n                if (used == flow) break;\n            }\n        }\n        return used;\n    }\n\n    void Work() {\n        res = ans = 0;\n        while (Spfa()) {\n            vis[t] = true;\n            while (vis[t]) {\n                memset(vis, false, sizeof(vis));\n                memcpy(cur, head, sizeof(head));\n                Dfs(s, INF);\n            }\n        }\n    }\n}\n\nnamespace Zkw2{\n    Edge *head[MAXN << 1], *cur[MAXN << 1];\n    bool vis[MAXN << 1];\n    int dis[MAXN << 1];\n    int s, t, res ,ans;\n\n    void AddEdge(int u, int v, int w, int c) {\n        head[u] = new Edge(v, w, c, head[u]);\n        head[v] = new Edge(u, 0, -c, head[v]);\n        head[u]->ops = head[v]; head[v]->ops = head[u];\n    }\n\n    bool Spfa() {\n        //memset(dis, -INF, sizeof(dis));\n        for (int i = 1; i <= 2 * n + 1; i++) dis[i] = -INF;\n        memset(vis, false, sizeof(vis));\n        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop_front();\n            vis[u] =false;\n            for (Edge *e = head[u]; e; e = e->next) {\n                int v = e->to;\n                if (e->val > 0 && dis[u] + e->cost > dis[v]) {\n                    dis[v] = dis[u] + e->cost;\n                    if (!vis[v]) {\n                        vis[v] = true;\n                        if (!q.empty() && dis[v] > dis[q.front()]) q.push_front(v);\n                        else q.push_back(v);\n                    }\n                }\n            }\n        }\n        return dis[t] > -INF;\n    }\n\n    int Dfs(int u, int flow) {\n        vis[u] = true;\n        if (u == t) {\n            res += flow;\n            return flow;\n        }\n        int used = 0;\n        for (Edge *&e = cur[u]; e; e = e->next) {\n            int v = e->to;\n            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n                int mi = Dfs(v, min(e->val, flow - used));\n                if (mi) {\n                    used += mi;\n                    e->val -= mi;\n                    e->ops->val += mi;\n                    ans += e->cost * mi;\n                }\n                if (used == flow) break;\n            }\n        }\n        return used;\n    }\n\n    void Work() {\n        res = ans = 0;\n        while (Spfa()) {\n            vis[t] = true;\n            while (vis[t]) {\n                memset(vis, false, sizeof(vis));\n                memcpy(cur, head, sizeof(head));\n                Dfs(s, INF);\n            }\n        }\n    }\n}\n\nint main() {\n    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    cin >> m >> n;\n    Zkw1 :: s = Zkw2 :: s = 0; Zkw1 :: t = Zkw2 :: t = m + n + 1;\n    for (int i = 1; i <= m; i++) {\n        int x;\n        cin >> x;\n        Zkw1 :: AddEdge(0, i, x, 0);\n        Zkw2 :: AddEdge(0, i, x, 0);\n    }\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        Zkw1 :: AddEdge(m + i, m + n + 1, x, 0);\n        Zkw2 :: AddEdge(m + i, m + n + 1, x, 0);\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            int x;\n            cin >> x;\n            Zkw1 :: AddEdge(i, m + j, INF, x);\n            Zkw2 :: AddEdge(i, m + j, INF, x);\n        }\n    }\n    Zkw1 :: Work(); Zkw2 :: Work();\n    cout << Zkw1 :: ans << endl << Zkw2 :: ans << endl;\n    return 0;\n}\n```\n\u4f60\u5f00\u5f00\u5fc3\u5fc3\u590d\u5236\u7c98\u8d34\u63d0\u4ea4\uff0c\u53d1\u73b0\u53ea\u6709$45$\u5206\u3002**\u8fd9\u65f6\u9700\u8981\u4e00\u4e2a\u6280\u5de7\uff1a\u7b2c\u4e8c\u904d\u628a\u8d39\u7528\u53d6\u76f8\u53cd\u6570\u5b58\u8dd1\u6700\u5c0f\u8d39\u7528\uff0c\u8981\u6bd4\u6b63\u5e38\u5b58\u56fe\u8dd1\u6700\u5927\u8d39\u7528\u5feb\u3002**\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n// luogu-judger-enable-o2\n#include <iostream>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\nconst int MAXN = 105;\nconst int INF = 0x3f3f3f3f;\n\nint m, n;\n\nstruct Edge{\n    int to, val, cost;\n    Edge *next, *ops;\n    Edge(int to, int val, int cost, Edge *next): to(to), val(val), cost(cost), next(next){}\n};\n\nnamespace Zkw1{\n    Edge *head[MAXN << 1];\n    bool vis[MAXN << 1];\n    int dis[MAXN << 1];\n    int s, t, res ,ans;\n\n    void AddEdge(int u, int v, int w, int c) {\n        head[u] = new Edge(v, w, c, head[u]);\n        head[v] = new Edge(u, 0, -c, head[v]);\n        head[u]->ops = head[v]; head[v]->ops = head[u];\n    }\n\n    bool Spfa() {\n        memset(dis, INF, sizeof(dis));\n        memset(vis, false, sizeof(vis));\n        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop_front();\n            vis[u] =false;\n            for (Edge *e = head[u]; e; e = e->next) {\n                int v = e->to;\n                if (e->val > 0 && dis[u] + e->cost < dis[v]) {\n                    dis[v] = dis[u] + e->cost;\n                    if (!vis[v]) {\n                        vis[v] = true;\n                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);\n                        else q.push_back(v);\n                    }\n                }\n            }\n        }\n        return dis[t] < INF;\n    }\n\n    int Dfs(int u, int flow) {\n        vis[u] = true;\n        if (u == t) {\n            res += flow;\n            return flow;\n        }\n        int used = 0;\n        for (Edge *e = head[u]; e; e = e->next) {\n            int v = e->to;\n            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n                int mi = Dfs(v, min(e->val, flow - used));\n                if (mi) {\n                    used += mi;\n                    e->val -= mi;\n                    e->ops->val += mi;\n                    ans += e->cost * mi;\n                }\n                if (used == flow) break;\n            }\n        }\n        return used;\n    }\n\n    void Work() {\n        res = ans = 0;\n        while (Spfa()) {\n            vis[t] = true;\n            while (vis[t]) {\n                memset(vis, false, sizeof(vis));\n                Dfs(s, INF);\n            }\n        }\n    }\n}\n\nnamespace Zkw2{\n    Edge *head[MAXN << 1];\n    bool vis[MAXN << 1];\n    int dis[MAXN << 1];\n    int s, t, res ,ans;\n\n    void AddEdge(int u, int v, int w, int c) {\n        head[u] = new Edge(v, w, c, head[u]);\n        head[v] = new Edge(u, 0, -c, head[v]);\n        head[u]->ops = head[v]; head[v]->ops = head[u];\n    }\n\n    bool Spfa() {\n        memset(dis, INF, sizeof(dis));\n        memset(vis, false, sizeof(vis));\n        deque<int> q; q.push_back(s); vis[s] = true; dis[s] = 0;\n        while (!q.empty()) {\n            int u = q.front(); q.pop_front();\n            vis[u] =false;\n            for (Edge *e = head[u]; e; e = e->next) {\n                int v = e->to;\n                if (e->val > 0 && dis[u] + e->cost < dis[v]) {\n                    dis[v] = dis[u] + e->cost;\n                    if (!vis[v]) {\n                        vis[v] = true;\n                        if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);\n                        else q.push_back(v);\n                    }\n                }\n            }\n        }\n        return dis[t] < INF;\n    }\n\n    int Dfs(int u, int flow) {\n        vis[u] = true;\n        if (u == t) {\n            res += flow;\n            return flow;\n        }\n        int used = 0;\n        for (Edge *e = head[u]; e; e = e->next) {\n            int v = e->to;\n            if ((v == t || !vis[v]) && e->val > 0 && dis[v] == dis[u] + e->cost) {\n                int mi = Dfs(v, min(e->val, flow - used));\n                if (mi) {\n                    used += mi;\n                    e->val -= mi;\n                    e->ops->val += mi;\n                    ans += e->cost * mi;\n                }\n                if (used == flow) break;\n            }\n        }\n        return used;\n    }\n\n    void Work() {\n        res = ans = 0;\n        while (Spfa()) {\n            vis[t] = true;\n            while (vis[t]) {\n                memset(vis, false, sizeof(vis));\n                Dfs(s, INF);\n            }\n        }\n    }\n}\n\nint main() {\n    ios :: sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\n    cin >> m >> n;\n    Zkw1 :: s = Zkw2 :: s = 0; Zkw1 :: t = Zkw2 :: t = m + n + 1;\n    for (int i = 1; i <= m; i++) {\n        int x;\n        cin >> x;\n        Zkw1 :: AddEdge(0, i, x, 0);\n        Zkw2 :: AddEdge(0, i, x, 0);\n    }\n    for (int i = 1; i <= n; i++) {\n        int x;\n        cin >> x;\n        Zkw1 :: AddEdge(m + i, m + n + 1, x, 0);\n        Zkw2 :: AddEdge(m + i, m + n + 1, x, 0);\n    }\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            int x;\n            cin >> x;\n            Zkw1 :: AddEdge(i, m + j, INF, x);\n            Zkw2 :: AddEdge(i, m + j, INF, -x);\n        }\n    }\n    Zkw1 :: Work(); Zkw2 :: Work();\n    cout << Zkw1 :: ans << endl << -Zkw2 :: ans << endl;\n    return 0;\n}\n```",
        "postTime": 1554820751,
        "uid": 126376,
        "name": "Irelia\u10e6",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4015 \u3010\u8fd0\u8f93\u95ee\u9898\u3011"
    },
    {
        "content": "\u539f\u9898\u4f20\u9001\u95e8[>Here<](https://www.luogu.org/problemnew/show/P4015)\n\n\u5efa\u56fe\uff1a\n\n1.\u4ece\u6e90\u70b9\u5411\u4ed3\u5e93i\u5efa\u6d41\u4e3aa[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\uff1b\n\n2.\u4ece\u4ed3\u5e93i\u5411\u5546\u5e97j\u5efa\u6d41\u4e3ainf\uff0c\u8d39\u7528\u4e3ac[i][j]\u7684\u8fb9\uff1b\n\n3.\u4ece\u5546\u5e97\u5411\u6c47\u70b9\u5efa\u6d41\u4e3ab[i]\uff0c\u8d39\u7528\u4e3a0\u7684\u8fb9\u3002\n\n\u5bf9\u4e8e\u7b2c\u4e00\u95ee\uff0c\u8dd1\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u7b2c\u4e8c\u95ee\uff0c\u5c06\u8d39\u7528\u53d6\u76f8\u53cd\u6570\uff0c\u518d\u8dd1\u4e00\u6b21\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\uff0c\u5f97\u5230\u7684\u7b54\u6848\u518d\u53d6\u76f8\u53cd\u6570\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#define min(X,Y) ((X)<(Y)?(X):(Y))\n\nint head[301],nxt[50001],b[50001],v[50001],cost[50001],vt[50001],ct[50001],k=1,n,m,ans;\nint pre[301],S,T,q[301],h,t,dis[301],flow[301];\nbool inq[301];\nvoid push(int s,int t,int v1,int v2){\n\tnxt[++k]=head[s];\n\thead[s]=k;\n\tb[k]=t;\n\tv[k]=v1;\n\tcost[k]=v2;\n\tvt[k]=v1;\n\tct[k]=-v2;\n}\nvoid link(int s,int t,int v1,int v2){\n\tpush(s,t,v1,v2);\n\tpush(t,s,0,-v2);\n}\nbool spfa(int v[50001],int cost[50001]){\n\tmemset(inq,0,sizeof inq);\n\tmemset(flow,0x7f7f7f7f,sizeof flow);\n\tmemset(dis,0x7f7f7f7f,sizeof dis);\n\th=t=0;\n\tdis[S]=0;\n\tq[++t]=S;\n\tinq[S]=1;\n\twhile(h<t){\n\t\th++;\n\t\tinq[q[h]]=0;\n\t\tfor(int i=head[q[h]];i;i=nxt[i])\n\t\t\tif(v[i]&&dis[b[i]]>dis[q[h]]+cost[i]){\n\t\t\t\tflow[b[i]]=min(flow[q[h]],v[i]);\n\t\t\t\tdis[b[i]]=dis[q[h]]+cost[i];\n\t\t\t\tpre[b[i]]=i;\n\t\t\t\tif(!inq[b[i]])inq[b[i]]=1,q[++t]=b[i]; \n\t\t\t}\n\t}\n\treturn dis[T]!=0x7f7f7f7f;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tS=0,T=n+m+1;\n\tint tem;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&tem),link(S,i,tem,0);\n\tfor(int i=1;i<=m;i++)scanf(\"%d\",&tem),link(i+n,T,tem,0);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&tem);\n\t\t\tlink(i,j+n,0x7f7f7f7f,tem);\n\t\t}\n\tans=0;\n\twhile(spfa(v,cost)){\n\t\tint t=T;\n\t\twhile(t!=S){\n\t\t\tv[pre[t]]-=flow[T];\n\t\t\tv[pre[t]^1]+=flow[T];\n\t\t\tt=b[pre[t]^1];\n\t\t}\n\t\tans+=flow[T]*dis[T];\n\t}\n\tprintf(\"%d\\n\",ans);\n\tans=0;\n\twhile(spfa(vt,ct)){\n\t\tint t=T;\n\t\twhile(t!=S){\n\t\t\tvt[pre[t]]-=flow[T];\n\t\t\tvt[pre[t]^1]+=flow[T];\n\t\t\tt=b[pre[t]^1];\n\t\t}\n\t\tans+=-flow[T]*dis[T];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n```",
        "postTime": 1533631500,
        "uid": 30903,
        "name": "Isonan",
        "ccfLevel": 0,
        "title": "luoguP4015 \u8fd0\u8f93\u95ee\u9898"
    }
]