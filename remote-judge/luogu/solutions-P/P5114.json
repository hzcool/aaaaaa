[
    {
        "content": "\u6211\u4eec\u53d1\u73b0\u9700\u8981\u6c42\u4e00\u4e2a\u7c7b\u4f3c $\\max(kx+y)$ \u7684\u4e1c\u897f\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u6c42\u51fa\u6240\u6709 $(x,y)$ \u7684\u4e0a\u51f8\u58f3\u7136\u540e\u4e8c\u5206\u5373\u53ef.\n\n\u5b98\u65b9\u9898\u89e3\u7528\u7684\u8fb9\u5206\u6cbb\uff0c\u7531\u4e8e\u6211\u4e0d\u4f1a\u8fb9\u5206\u6cbb\u6240\u4ee5\u6211\u5199\u7684\u70b9\u5206\u6cbb.\n\n\u70b9\u5206\u6cbb\u7684\u5e38\u7528\u8ba1\u7b97\u7b54\u6848\u65b9\u6cd5\u6709\u4e09\u79cd: \u5148\u4e0d\u8003\u8651\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u68f5\u5b50\u6811\u7684\u60c5\u51b5\u8ba1\u7b97\u6700\u540e\u518d\u5bb9\u65a5\u6389\uff1b\u9010\u5b50\u6811\u52a0\u5165\uff0c\u5373\u8003\u8651\u6bcf\u68f5\u5b50\u6811\u5bf9\u4e4b\u524d\u52a0\u5165\u7684\u5b50\u6811\u7684\u8d21\u732e\uff1b\u5408\u5e76\u679c\u5b50\uff0c\u5373\u6bcf\u6b21\u62ff\u51fa\u4e24\u4e2asize\u6700\u5c0f\u7684\u5b50\u6811\u8ba1\u7b97\u7b54\u6848\uff0c\u7136\u540e\u628a\u8fd9\u4e24\u4e2a\u5b50\u6811\u7684\u4fe1\u606f\u5408\u5e76\u540e\u653e\u56de\u53bb. \n\n\u8fd9\u91cc\u9700\u8981\u7b2c\u4e09\u79cd\u7b97\u6cd5\uff0c\u5982\u679c\u5408\u5e76\u4e24\u68f5\u5927\u5c0f\u4e3a $size_x$ \u548c $size_y$ \u7684\u5b50\u6811\u9700\u8981\u7684\u590d\u6742\u5ea6\u662f $O(size_x+size_y)$\uff0c\u90a3\u4e48\u603b\u590d\u6742\u5ea6\u4ecd\u7136\u662f\u4e00\u4e2alog~~\u7136\u800c\u6211\u4e0d\u4f1a\u8bc1~~\n\n\u6c42\u51fa\u6240\u6709\u5b50\u6811\u7684\u672b\u7aef\u4e3a\u9ed1/\u767d\u70b9\u7684\u51f8\u5305\uff0c\u90a3\u4e48\u5408\u5e76\u4e24\u68f5\u5b50\u6811 $x,y$ \u7684\u65f6\u5019\uff0c\u53ea\u9700\u8981\u5bf9 $x$ \u7684\u9ed1\u70b9\u51f8\u5305\u548c $y$ \u7684\u767d\u70b9\u51f8\u5305\u3001$x$ \u7684\u767d\u70b9\u51f8\u5305\u548c $y$ \u7684\u9ed1\u70b9\u51f8\u5305\u5206\u522b\u505a\u4e00\u4e2a\u95f5\u53ef\u592b\u65af\u57fa\u548c\uff0c\u5f97\u5230\u7684\u51f8\u5305\u4e0a\u7684\u70b9\u6254\u5230\u7b54\u6848\u51f8\u5305\u91cc\u53bb(\u5148\u4e0d\u6784\u5efa\uff0c\u53ea\u5b58\u50a8\u70b9). \u4e0d\u4f1a\u95f5\u53ef\u592b\u65af\u57fa\u548c\u7684\u53ef\u4ee5\u53bb\u770b\u4e00\u4e0b[\u8fd9\u9053\u9898](https://www.luogu.com.cn/problem/P5073). \u7136\u540e\u5f52\u5e76 $x$ \u7684\u51f8\u5305\u548c $y$ \u7684\u51f8\u5305\u653e\u56de\u53bb\u5373\u53ef.\n\n\u6c42\u51fa\u7b54\u6848\u51f8\u5305\u4e4b\u540e\u8be2\u95ee\u5728\u4e0a\u9762\u4e8c\u5206\u5373\u53ef\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u50cf\u4e0a\u9762\u90a3\u9053\u9898\u4e00\u6837\u66b4\u529b\u79fb\u52a8\u6307\u9488.\n\n\u7b97\u4e00\u4e0b\u590d\u6742\u5ea6\uff0c\u53d1\u73b0\u5408\u5e76\u51f8\u5305\u7684\u90e8\u5206\u662f\u6ca1\u95ee\u9898\u7684\uff0c\u4f46\u662f\u6784\u5efa\u7b54\u6848\u51f8\u5305\u548c\u6784\u5efa\u5b50\u6811\u51f8\u5305\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u6709\u95ee\u9898\uff0c\u4f7f\u7528sort\u4f1a\u4f7f\u590d\u6742\u5ea6\u53d8\u6210\u4e24\u4e2alog\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u79bb\u7ebf\u57fa\u6570\u6392\u5e8f\u5373\u53ef. \u4e0d\u8fc7\u4e24\u4e2alog\u4e5f\u80fd\u8fc7\uff0c\u6240\u4ee5\u5c31\u61d2\u5f97\u5199\u57fa\u6392\u4e86(\n\n\u8dd1\u5f97\u597d\u50cf\u6bd4\u8fb9\u5206\u6cbb\u6162\u4e0d\u5c11.\n\n\u9700\u8981\u6ce8\u610f\u7684\u7ec6\u8282\u662f\u7531\u4e8e\u503c\u57df\u4e3a $1.5\\times 10^9$\uff0c\u6240\u4ee5\u52a0\u52a0\u51cf\u51cf\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u7206int(\n\n\u7136\u540e\u6392\u5e8f\u7684\u65f6\u5019\u5148\u6309 $x$ \u6392\u5e8f\uff0c$x$ \u4e00\u6837\u7684\u65f6\u5019\u6309 $y$ \u6392\u5e8f\uff0c\u4e0d\u7136\u6c42\u7684\u51f8\u5305\u53ef\u80fd\u4f1a\u6709\u95ee\u9898.\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#define IT vector<int>::iterator\nusing namespace std;\nconst int N=2e5+5000,INF=2e9;\nstruct Point\n{\n    long long x,y;\n    Point operator +(const Point &a)const{return (Point){x+a.x,y+a.y};}\n    Point operator -(const Point &a)const{return (Point){x-a.x,y-a.y};}\n    bool operator >=(const Point &a)const{return 1ll*x*a.y<=1ll*y*a.x;}\n    long long f(int k){return 1ll*k*x+y;}\n}tmpans[N*200],tmp[2][N],w[N];\nstruct Hull\n{\n    int len;\n    vector<Point>a;\n    Hull(){len=0;}\n    Point operator [](const int &x)const{return a[x];}\n    void clear(){len=0;a.clear();}\n    void push(const Point &x)\n    {\n        while(len>1&&(x-a[len-1])>=(a[len-1]-a[len-2]))--len,a.pop_back();\n        ++len,a.push_back(x);\n    }\n}a[N<<1][2];\nvector<int>e[N];\nint ansn=0,len[2],col[N],n,m,nn,mxson,root,size[N],vis[N];\nlong long ans[N];\nstruct Q{int w,id;}q[N];\nvoid ade(int u,int v){e[u].push_back(v);}\nHull merge(const Hull &a,const Hull &b)\n{\n    Hull tmp;\n    for(int i=0,j=0;i<a.len||j<b.len;)\n        if(i==a.len||(j<b.len&&b[j].x<a[i].x))\n            tmp.push(b[j]),j++;\n        else if(j==b.len||a[i].x<b[j].x)\n            tmp.push(a[i]),i++;\n        else tmp.push(a[i].y>b[j].y?a[i]:b[j]),i++,j++;\n\treturn tmp;\n}\nHull Minkow(const Hull &a,const Hull &b)\n{\n    Hull tmp;if(!a.len||!b.len)return tmp;\n\ttmp.push(a[0]+b[0]);int i=0,j=0;\n    for(;i<a.len-1||j<b.len-1;)\n        if(i==a.len-1)tmp.push(a[i]+b[++j]);\n        else if(j==b.len-1)tmp.push(a[++i]+b[j]);\n        else tmp.push((a[i+1]-a[i])>=(b[j+1]-b[j])?a[++i]+b[j]:a[i]+b[++j]);\n    return tmp;\n}\nvoid findroot(int u,int fa)\n{\n    size[u]=1;int mx=0;\n    for(IT i=e[u].begin();i!=e[u].end();i++)\n    {\n        int v=*i;if(vis[v]||v==fa)continue;\n        findroot(v,u),mx=max(mx,size[v]),size[u]+=size[v];\n    }\n    mx=max(mx,nn-size[u]);\n    if(mx<mxson)mxson=mx,root=u;\n}\nvoid dfs(int u,int fa,Point s)\n{\n    tmp[col[u]][++len[col[u]]]=s;\n    for(IT i=e[u].begin();i!=e[u].end();i++)\n    {\n        int v=*i;if(v==fa||vis[v])continue;\n        dfs(v,u,s+w[v]);\n    }\n}\nint cmp(const Point &a,const Point &b){return a.x==b.x?a.y<b.y:a.x<b.x;}\nvoid build(int u)\n{\n    a[u][0].clear();a[u][1].clear();\n    sort(tmp[0]+1,tmp[0]+len[0]+1,cmp),sort(tmp[1]+1,tmp[1]+len[1]+1,cmp);\n    \n    for(int i=1;i<=len[0];i++)a[u][0].push(tmp[0][i]);\n    for(int i=1;i<=len[1];i++)a[u][1].push(tmp[1][i]);\n}\nvoid calc(int x,int y,int u)\n{\n    Hull tmp=Minkow(a[x][0],a[y][1]);\n    for(int i=0;i<tmp.len;i++)tmpans[++ansn]=tmp[i]+w[u];\n    tmp=Minkow(a[x][1],a[y][0]);\n    for(int i=0;i<tmp.len;i++)tmpans[++ansn]=tmp[i]+w[u];\n}\nstruct HeapNode{int u,size;bool operator <(const HeapNode &a)const{return size>a.size;}};\nvoid solve(int u)\n{\n    vis[u]=1;priority_queue<HeapNode>q;\n    for(IT i=e[u].begin();i!=e[u].end();i++)\n    {\n        int v=*i;if(vis[v])continue;\n\t    len[0]=len[1]=0;dfs(v,u,w[v]);\n        build(v);q.push((HeapNode){v,a[v][0].len+a[v][1].len});\n    }\n    int tn=n;\n    while(q.size()>1)\n    {\n        HeapNode x=q.top(),y;\n        q.pop();y=q.top();q.pop();\n        calc(x.u,y.u,u);\n//\t\tcout<<x.u<<\" \"<<y.u<<endl;\n        ++tn;a[tn][0]=merge(a[x.u][0],a[y.u][0]),a[tn][1]=merge(a[x.u][1],a[y.u][1]);\n        q.push((HeapNode){tn,a[tn][0].len+a[tn][1].len});\n    }\n    if(q.empty())return;\n    int t=q.top().u;q.pop();\n    if(col[u])\n    {\n        for(int i=0;i<a[t][0].len;i++)tmpans[++ansn]=a[t][0][i]+w[u];\n    }\n    else\n    {\n        for(int i=0;i<a[t][1].len;i++)tmpans[++ansn]=a[t][1][i]+w[u];\n    }\n    for(IT i=e[u].begin();i!=e[u].end();i++)\n    {\n        int v=*i;if(vis[v])continue;\n        nn=size[v],mxson=INF,findroot(v,u),solve(root);\n    }\n}\nint getin()\n{\n    int x=0,f=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')f=-1,ch=getchar();\n    while(ch>='0'&&ch<='9')x=x*10+ch-48,ch=getchar();\n    return x*f;\n}\nint cmp2(const Q &a,const Q &b){return a.w<b.w;}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)w[i].x=getin();\n    for(int i=1;i<=n;i++)w[i].y=getin();\n    for(int i=1;i<=n;i++)col[i]=getin();\n    for(int i=1,u,v;i<n;i++)scanf(\"%d%d\",&u,&v),ade(u,v),ade(v,u);\n    nn=n,mxson=INF,findroot(1,0),solve(root);\n    sort(tmpans+1,tmpans+ansn+1,cmp);\n//    for(int i=1;i<=ansn;i++)cout<<tmpans[i].x<<\" \"<<tmpans[i].y<<endl;\n    Hull tmp;\n    for(int i=1;i<=ansn;i++)tmp.push(tmpans[i]);\n//    for(int i=0;i<tmp.len;i++)cout<<tmp[i].x<<\" \"<<tmp[i].y<<endl;\n    for(int i=1;i<=m;i++)scanf(\"%d\",&q[i].w),q[i].id=i;\n    if(!tmp.len){for(int i=1;i<=m;i++)puts(\"0\");return 0;}\n    sort(q+1,q+m+1,cmp2);\n    for(int i=1,j=0;i<=m;i++)\n    {\n        while(j+1<tmp.len&&tmp[j+1].f(q[i].w)>=tmp[j].f(q[i].w))++j;\n        ans[q[i].id]=tmp[j].f(q[i].w);\n    }\n    for(int i=1;i<=m;i++)printf(\"%lld\\n\",ans[i]);\n}\n```",
        "postTime": 1593927213,
        "uid": 22136,
        "name": "qwaszx",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P5114 \u3010\u516b\u6708\u8138\u3011"
    },
    {
        "content": "## P5114 \u516b\u6708\u8138\n\u672c\u9898\u76f8\u5f53\u4e8e\u6c42\u51fa\u6240\u6709\u5f02\u8272\u70b9\u5bf9\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\u6240\u6784\u6210\u7684\u4e0a\u51f8\u58f3\uff0c\u800c\u6784\u6210\u51f8\u58f3\u7684\u76f4\u7ebf\u5e76\u4e0d\u4f1a\u5f88\u591a\uff0c\u8fd9\u542f\u793a\u6211\u4eec\u5bfb\u627e\u4e00\u79cd\u66f4\u5feb\u6377\u7684\u65b9\u5f0f\u6c42\u51fa\u7b54\u6848\u51f8\u58f3\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u6cbf\u7528[\u8fd9\u9053\u9898](https://www.luogu.com.cn/problem/CF1019E)\u7684\u5957\u8def\uff0c\u8fb9\u5206\u6cbb\u540e\u5408\u5e76\u4e24\u8fb9\u7684\u51f8\u58f3\uff0c\u5373\u5bf9\u4e24\u8fb9\u505a\u95f5\u53ef\u592b\u65af\u57fa\u548c\uff0c\u8fd9\u6837\u76f4\u7ebf\u7684\u6570\u91cf\u7ea7\u662f $O(n \\log n)$ \u7684\uff0c\u4e14\u7559\u4e0b\u7684\u90fd\u662f\u6709\u6548\u7684\u4fe1\u606f\u3002\u6700\u540e\u79bb\u7ebf\u626b\u4e00\u904d\u51f8\u58f3\u6c42\u7b54\u6848\u5373\u53ef\u3002\n\n\u4f46\u8fd9\u9053\u9898\u8ba9\u6211\u4f53\u4f1a\u5230\u4e86\u7528\u8fb9\u5206\u6cbb\u89e3\u51b3\u7ed3\u70b9\u95ee\u9898\u6df1\u6df1\u7684\u6076\u610f\u3002\u9996\u5148\u5728\u4e09\u5ea6\u5316\u7684\u8fc7\u7a0b\u4e2d\uff0c\u65b0\u5efa\u7ed3\u70b9\u7684\u4fe1\u606f\u5e94\u8be5\u6765\u81ea\u5206\u88c2\u7ed3\u70b9\uff0c\u800c\u4e0d\u662f\u6ca1\u6709\u50a8\u5b58\u4fe1\u606f\u3002\u5176\u6b21\uff0c\u5728\u5206\u6cbb\u8fdb\u884c dfs \u65f6\uff0c\u5e94\u6ce8\u610f\u5f53\u524d\u7ed3\u70b9\u548c\u4e0b\u4e00\u4e2a\u7ed3\u70b9\u662f\u5426\u50a8\u5b58\u7740\u540c\u4e00\u70b9\u7684\u4fe1\u606f\uff0c\u5982\u679c\u662f\u5219\u4e0d\u5e94\u8be5\u628a\u65b0\u7684\u7ed3\u70b9\u7684\u4fe1\u606f\u7d2f\u52a0\u5230\u7b54\u6848\u4e2d\u3002\n\n\u4ee3\u7801\u4e2d\u6c42\u51f8\u58f3\u7528\u5230\u4e86\u7c7b\u4f3c\u4e8e\u6c42\u70b9\u51f8\u58f3\u7684\u65b9\u6cd5\uff0c\u5176\u5b9e\u8be5\u95ee\u9898\u53ef\u4ee5\u5bf9\u5076\u8f6c\u5316\u4e3a\u70b9\u51f8\u58f3\u95ee\u9898\uff0c\u5177\u4f53\u53ef\u53c2\u89c1[\u8fd9\u7bc7\u535a\u5ba2](https://trinkle.blog.uoj.ac/blog/235)\u3002\n\n\u590d\u6742\u5ea6 $O(n \\log^2 n)$ \u3002\u9700\u8981\u6ce8\u610f\u8fb9\u5206\u6cbb\u65f6\u4e24\u8fb9\u5b50\u6811\u5927\u5c0f\u7684\u8ba1\u7b97\uff0c\u5982\u679c\u5927\u5c0f\u4e0d\u5f53\u4f1a\u5bfc\u81f4\u590d\u6742\u5ea6\u9519\u8bef\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lxl;\nconst int MAXN=2e5+5;\n\nint n,m;\nint color[MAXN],rev[MAXN<<1];\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch))(ch=='-')&&(f=-f),ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nstruct Vector{\n\tlxl x,y;\n\tVector(lxl x=0,lxl y=0):x(x),y(y){};\n\tinline void print(){printf(\"(%lld,%lld)\\n\",x,y);}\n\tinline Vector operator +(const Vector &tmp)const{return Vector(x+tmp.x,y+tmp.y);}\n\tinline Vector operator -(const Vector &tmp)const{return Vector(x-tmp.x,y-tmp.y);}\n\tinline Vector operator *(const lxl &tmp)const{return Vector(x*tmp,y*tmp);}\n\tinline Vector operator /(const lxl &tmp)const{return Vector(x/tmp,y/tmp);}\n\tinline lxl operator *(const Vector &tmp)const{return x*tmp.x+y*tmp.y;}\n\tinline lxl operator %(const Vector &tmp)const{return x*tmp.y-y*tmp.x;}\n}val[MAXN<<1];\n\nVector Ans[MAXN*40];int cnta;\nnamespace Tree2{\n\tconst int MAXN=2e5+5;\n\tint head[MAXN],trump=1;\n\tstruct Edge{\n\t\tint to,next;\n\t\tEdge(int u=0,int v=0):to(v),next(head[u]){};\n\t}e[MAXN<<1];\n\tinline void addedge(int u,int v){\n\t\te[++trump]=Edge(u,v);head[u]=trump;\n\t\te[++trump]=Edge(v,u);head[v]=trump;\n\t}\n\tvoid debug(int u,int fa){\n\t\tfor(register int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa) continue;\n\t\t\tprintf(\"%d(%lld,%lld) %d(%lld,%lld)\\n\",u,val[u].x,val[u].y,v,val[v].x,val[v].y);\n\t\t\tdebug(v,u);\n\t\t}\n\t}\n\tint size[MAXN],mx[MAXN];\n\tbool vis[MAXN];int tot,edge;\n\tvoid findedge(int u,int fa){\n\t\tsize[u]=1;\n\t\tfor(register int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa||vis[i>>1]) continue;\n\t\t\tfindedge(v,u);size[u]+=size[v];\n\t\t\tmx[i>>1]=max(size[v],tot-size[v]);\n\t\t\tif(mx[i>>1]<mx[edge>>1]) edge=i;\n\t\t}\n\t}\n\tVector Lb[MAXN],Lw[MAXN],Rb[MAXN],Rw[MAXN];\n\tVector C[MAXN];\n\tint cntlb,cntlw,cntrb,cntrw,cntc;\n\t\n\tinline bool cmp(const Vector &a,const Vector &b){\n\t\treturn a.x!=b.x?a.x<b.x:a.y>b.y;\n\t}\n\tVector stk[MAXN*20];int top;\n\tinline void tuke(Vector *a,int &n){\n\t\tregister int i;\n\t\tif(!n) return;\n\t\tsort(a+1,a+n+1,cmp);\n\t\tstk[top=1]=a[1];\n\t\tfor(i=2;i<=n;++i){\n\t\t\tif(a[i].x==a[i-1].x) continue;\n\t\t\twhile(top>1&&(stk[top]-stk[top-1])%(a[i]-stk[top-1])>=0) --top;\n\t\t\tstk[++top]=a[i];\n\t\t}\n\t\tfor(i=1;i<=top;++i) a[i]=stk[i];\n\t\tfor(i=top+1;i<=n;++i) a[i]=0;n=top;\n\t}\n\tVector s1[MAXN],s2[MAXN];\n\tinline void minkowski(Vector *a,int &n,Vector *b,int &m,Vector *c,int &s){\n\t\tint i,j;\n\t\tif(!n||!m) return void(s=n=m=0); \n\t\tfor(i=1;i<n;++i) s1[i]=a[i+1]-a[i];s1[n]=0;\n\t\tfor(i=1;i<m;++i) s2[i]=b[i+1]-b[i];s2[m]=0;\n\t\tc[s=1]=a[1]+b[1];i=j=1;\n\t\twhile(i<n&&j<m) ++s,c[s]=c[s-1]+(s1[i]%s2[j]<0?s1[i++]:s2[j++]);\n\t\twhile(i<n) ++s,c[s]=c[s-1]+s1[i++];\n\t\twhile(j<m) ++s,c[s]=c[s-1]+s2[j++];\n\t\tfor(i=1;i<=n;++i) a[i]=0;\n\t\tfor(i=1;i<=m;++i) b[i]=0;\n\t\tn=m=0;\n//\t\ttuke(c,s);\n\t}\n\tvoid work(int u,int fa,Vector len,bool c){\n\t\tif(u<=n){\n\t\t\tif(color[u]==0) c?Lw[++cntlw]=len:Rw[++cntrw]=len;\n\t\t\telse c?Lb[++cntlb]=len:Rb[++cntrb]=len;\n\t\t}\n\t\tfor(register int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa||vis[i>>1]) continue;\n\t\t\twork(v,u,len+(rev[u]!=rev[v]?val[v]:0),c);\n\t\t}\n\t}\n\tvoid solve(int b){\n\t\tregister int i;\n\t\tif(!b) return;vis[b>>1]=1;\n\t\tint u=e[b^1].to,v=e[b].to;\n\t\tif(u>v) swap(u,v);\n\t\twork(u,v,rev[u]!=v?val[u]:0,1);work(v,u,rev[v]!=rev[u]?val[v]:0,0);\n\t\ttuke(Lb,cntlb);tuke(Rw,cntrw);\n\t\tminkowski(Lb,cntlb,Rw,cntrw,C,cntc);\n\t\tfor(i=1;i<=cntc;++i) Ans[++cnta]=C[i];\n\t\ttuke(Lw,cntlw);tuke(Rb,cntrb);\n\t\tminkowski(Lw,cntlw,Rb,cntrb,C,cntc);\n\t\tfor(i=1;i<=cntc;++i) Ans[++cnta]=C[i];\n//\t\ttuke(Ans,cnta);\n\t\tint szeA=size[u]>size[v]?tot-size[v]:size[u],szeB=size[v]>size[u]?tot-size[u]:size[v];\n//\t\tassert(abs(szeA-szeB)<=1000);\n\t\ttot=szeA;edge=0;findedge(u,v);solve(edge);\n\t\ttot=szeB;edge=0;findedge(v,u);solve(edge);\n\t}\n\tint main(){\n\t\tmx[0]=MAXN<<1;edge=0;\n\t\tfindedge(1,0);solve(edge);\n\t\ttuke(Ans,cnta);\n//\t\tfor(register int i=1;i<=cnta;++i) Ans[i].print();\n\t\treturn 0;\n\t} \n}\nnamespace Tree1{\n\tint head[MAXN],trump;\n\tstruct Edge{\n\t\tint to,next;\n\t\tEdge(int u=0,int v=0):to(v),next(head[u]){};\n\t}e[MAXN<<1];\n\tinline void addedge(int u,int v){\n\t\te[++trump]=Edge(u,v);head[u]=trump;\n\t\te[++trump]=Edge(v,u);head[v]=trump;\n\t}\n\tvoid debug(int u,int fa){\n\t\tfor(register int i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa) continue;\n\t\t\tprintf(\"%d(%lld,%lld) %d(%lld,%lld)\\n\",u,val[u].x,val[u].y,v,val[v].x,val[v].y);\n\t\t\tdebug(v,u);\n\t\t}\n\t}\n\tint son[MAXN<<1],top,tot;\n\tvoid rebuild(int u,int fa){\n\t\tregister int i,last=u;top=0;\n\t\tfor(i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa) continue;\n\t\t\tson[++top]=e[i].to; \n\t\t}\n\t\tfor(i=1;i<=top-2;++i){\n\t\t\tTree2::addedge(last,son[i]);\n\t\t\tTree2::addedge(last,++tot);\n\t\t\trev[last=tot]=u;val[last]=val[u];\n\t\t}\n\t\tif(top>1) Tree2::addedge(last,son[top-1]);\n\t\tif(top>0) Tree2::addedge(last,son[top]);\n\t\tfor(i=head[u];i;i=e[i].next){\n\t\t\tint v=e[i].to;if(v==fa) continue;\n\t\t\trebuild(v,u);\n\t\t}\n\t}\n}\n\nstruct Query{\n\tint x,ord;\n\tQuery(int x=0,int ord=0):x(x),ord(ord){};\n\tbool operator <(const Query &tmp)const{\n\t\treturn x<tmp.x;\n\t}\n}Q[MAXN];\nlxl prt[MAXN];\n\nint main(){\n//\tfreopen(\"test.in\",\"r\",stdin);\n\tregister int i,j;\n\tn=read();m=read();\n\tfor(i=1;i<=n;++i) val[i].x=read(),rev[i]=i;\n\tfor(i=1;i<=n;++i) val[i].y=read();\n\tfor(i=1;i<=n;++i) color[i]=read();\n\tfor(i=1;i<n;++i) Tree1::addedge(read(),read());\n//\tputs(\"\");Tree1::debug(1,0);puts(\"\");\n\tTree1::tot=n;Tree1::rebuild(1,0);Tree2::tot=Tree1::tot;\n//\tputs(\"\");Tree2::debug(1,0);puts(\"\");\n\tTree2::main();\n\tfor(i=1;i<=m;++i) Q[i]=Query(read(),i);\n\tsort(Q+1,Q+m+1);j=1;\n\tfor(i=1;i<=m;++i){\n\t\twhile(j+1<=cnta&&1ll*Ans[j].x*Q[i].x+Ans[j].y<=1ll*Ans[j+1].x*Q[i].x+Ans[j+1].y) ++j;\n\t\tprt[Q[i].ord]=1ll*Ans[j].x*Q[i].x+Ans[j].y;\n\t}\n\tfor(i=1;i<=m;++i) printf(\"%lld\\n\",prt[i]);\n\treturn 0;\n}\n```",
        "postTime": 1617370705,
        "uid": 81566,
        "name": "final_trump",
        "ccfLevel": 0,
        "title": "P5114 \u516b\u6708\u8138"
    }
]