[
    {
        "content": "\u4e5f\u53ef\u4ee5\u770b\u770b\u535a\u5ba2\uff1a[\u5165\u95e8\u6811\u94fe\u5256\u5206\u8be6\u89e3](http://www.cnblogs.com/chinhhh/p/7965433.html)\r\n\r\n\uff08\u8bdd\u8bf4\u590d\u5236markdown\u662f\u771f\u7684\u9ebb\u70e6\uff09\r\n\r\n#\u5199\u5728\u524d\u9762\r\n\r\n\u9996\u5148\uff0c\u5728\u5b66\u6811\u94fe\u5256\u5206\u4e4b\u524d\u6700\u597d\u5148\u628a LCA\u3001\u6811\u5f62DP\u3001DFS\u5e8f \u8fd9\u4e09\u4e2a\u77e5\u8bc6\u70b9\u5b66\u4e86 \r\nemm\u8fd8\u6709\u5fc5\u5907\u7684 \u94fe\u5f0f\u524d\u5411\u661f\u3001\u7ebf\u6bb5\u6811 \u4e5f\u8981\u5148\u5b66\u4e86\u3002\r\n\r\n\u5982\u679c\u8fd9\u4e09\u4e2a\u77e5\u8bc6\u70b9\u6ca1\u638c\u63e1\u597d\u7684\u8bdd\uff0c\u6811\u94fe\u5256\u5206\u96be\u4ee5\u7406\u89e3\u4e5f\u662f\u5f53\u7136\u7684\u3002\r\n\r\n-------------------------\r\n\r\n#\u6811\u94fe\u5256\u5206\r\n\r\n\u6811\u94fe\u5256\u5206 \u5c31\u662f\u5bf9\u4e00\u68f5\u6811\u5206\u6210\u51e0\u6761\u94fe\uff0c\u628a\u6811\u5f62\u53d8\u4e3a\u7ebf\u6027\uff0c\u51cf\u5c11\u5904\u7406\u96be\u5ea6\r\n\r\n\u9700\u8981\u5904\u7406\u7684\u95ee\u9898\uff1a\r\n\r\n- \u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\r\n- \u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\r\n- \u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\r\n- \u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\r\n\r\n## \u6982\u5ff5\r\n\r\n- \u91cd\u513f\u5b50\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\uff0c\u5b83\u7684\u513f\u5b50\u4e2d \u513f\u5b50\u6570\u91cf\u6700\u591a\u7684\u90a3\u4e00\u4e2a\u513f\u5b50 \u4e3a\u8be5\u8282\u70b9\u7684\u91cd\u513f\u5b50\r\n- \u8f7b\u513f\u5b50\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\uff0c\u5b83\u7684\u513f\u5b50\u4e2d \u975e\u91cd\u513f\u5b50 \u7684\u5269\u4e0b\u6240\u6709\u513f\u5b50\u5373\u4e3a\u8f7b\u513f\u5b50\r\n- \u53f6\u5b50\u8282\u70b9\u6ca1\u6709\u91cd\u513f\u5b50\u4e5f\u6ca1\u6709\u8f7b\u513f\u5b50\uff08\u56e0\u4e3a\u5b83\u6ca1\u6709\u513f\u5b50\u3002\u3002\uff09\r\n- \u91cd\u8fb9\uff1a\u8fde\u63a5\u4efb\u610f\u4e24\u4e2a\u91cd\u513f\u5b50\u7684\u8fb9\u53eb\u505a\u91cd\u8fb9\r\n- \u8f7b\u8fb9\uff1a\u5269\u4e0b\u7684\u5373\u4e3a\u8f7b\u8fb9\r\n- \u91cd\u94fe\uff1a\u76f8\u90bb\u91cd\u8fb9\u8fde\u8d77\u6765\u7684 \u8fde\u63a5\u4e00\u6761\u91cd\u513f\u5b50 \u7684\u94fe\u53eb\u91cd\u94fe\r\n- \u5bf9\u4e8e\u53f6\u5b50\u8282\u70b9\uff0c\u82e5\u5176\u4e3a\u8f7b\u513f\u5b50\uff0c\u5219\u6709\u4e00\u6761\u4ee5\u81ea\u5df1\u4e3a\u8d77\u70b9\u7684\u957f\u5ea6\u4e3a1\u7684\u94fe\r\n- \u6bcf\u4e00\u6761\u91cd\u94fe\u4ee5\u8f7b\u513f\u5b50\u4e3a\u8d77\u70b9\r\n\r\n\r\n![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120143991-1630008815.png)\r\n\r\n## dfs1()\r\n\r\n\u8fd9\u4e2adfs\u8981\u5904\u7406\u51e0\u4ef6\u4e8b\u60c5\uff1a\r\n\r\n- \u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6dep[]\r\n- \u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2fa[]\r\n- \u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f(\u542b\u5b83\u81ea\u5df1)\r\n- \u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u91cd\u513f\u5b50\u7f16\u53f7son[]\r\n\r\n```\r\ninline void dfs1(int x,int f,int deep){//x\u5f53\u524d\u8282\u70b9\uff0cf\u7236\u4eb2\uff0cdeep\u6df1\u5ea6 \r\ndep[x]=deep;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6 \r\nfa[x]=f;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2 \r\nsiz[x]=1;//\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f \r\nint maxson=-1;//\u8bb0\u5f55\u91cd\u513f\u5b50\u7684\u513f\u5b50\u6570 \r\nfor(Rint i=beg[x];i;i=nex[i]){\r\n    int y=to[i];\r\n    if(y==f)continue;//\u82e5\u4e3a\u7236\u4eb2\u5219continue \r\n    dfs1(y,x,deep+1);//dfs\u5176\u513f\u5b50 \r\n    siz[x]+=siz[y];//\u628a\u5b83\u7684\u513f\u5b50\u6570\u52a0\u5230\u5b83\u8eab\u4e0a \r\n    if(siz[y]>maxson)son[x]=y,maxson=siz[y];//\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u91cd\u513f\u5b50\u7f16\u53f7 \r\n}\r\n}//\u53d8\u91cf\u89e3\u91ca\u89c1\u6700\u4e0b\u9762\r\n```\r\n## dfs2()\r\n\r\n\u8fd9\u4e2adfs2\u4e5f\u8981\u9884\u5904\u7406\u51e0\u4ef6\u4e8b\u60c5\r\n\r\n- \u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u65b0\u7f16\u53f7\r\n- \u8d4b\u503c\u6bcf\u4e2a\u70b9\u7684\u521d\u59cb\u503c\u5230\u65b0\u7f16\u53f7\u4e0a\r\n- \u5904\u7406\u6bcf\u4e2a\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aef\r\n- \u5904\u7406\u6bcf\u6761\u94fe\r\n\r\n\u987a\u5e8f\uff1a**\u5148\u5904\u7406\u91cd\u513f\u5b50\u518d\u5904\u7406\u8f7b\u513f\u5b50**\uff0c\u7406\u7531\u540e\u9762\u8bf4\r\n\r\n```\r\ninline void dfs2(int x,int topf){//x\u5f53\u524d\u8282\u70b9\uff0ctopf\u5f53\u524d\u94fe\u7684\u6700\u9876\u7aef\u7684\u8282\u70b9 \r\n    id[x]=++cnt;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u65b0\u7f16\u53f7 \r\n    wt[cnt]=w[x];//\u628a\u6bcf\u4e2a\u70b9\u7684\u521d\u59cb\u503c\u8d4b\u5230\u65b0\u7f16\u53f7\u4e0a\u6765 \r\n    top[x]=topf;//\u8fd9\u4e2a\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aef \r\n    if(!son[x])return;//\u5982\u679c\u6ca1\u6709\u513f\u5b50\u5219\u8fd4\u56de \r\n    dfs2(son[x],topf);//\u6309\u5148\u5904\u7406\u91cd\u513f\u5b50\uff0c\u518d\u5904\u7406\u8f7b\u513f\u5b50\u7684\u987a\u5e8f\u9012\u5f52\u5904\u7406 \r\n    for(Rint i=beg[x];i;i=nex[i]){\r\n        int y=to[i];\r\n        if(y==fa[x]||y==son[x])continue;\r\n        dfs2(y,y);//\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8f7b\u513f\u5b50\u90fd\u6709\u4e00\u6761\u4ece\u5b83\u81ea\u5df1\u5f00\u59cb\u7684\u94fe \r\n    }\r\n}//\u53d8\u91cf\u89e3\u91ca\u89c1\u6700\u4e0b\u9762\r\n```\r\n\r\n## \u5904\u7406\u95ee\u9898\r\n\r\n**Attention \u91cd\u8981\u7684\u6765\u4e86\uff01\uff01\uff01**\r\n\u524d\u9762\u8bf4\u5230dfs2\u7684\u987a\u5e8f\u662f\u5148\u5904\u7406\u91cd\u513f\u5b50\u518d\u5904\u7406\u8f7b\u513f\u5b50\r\n\u6211\u4eec\u6765\u6a21\u62df\u4e00\u4e0b\uff1a\r\n\r\n![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120207335-1162265491.png)\r\n\r\n\r\n- \u56e0\u4e3a\u987a\u5e8f\u662f\u5148\u91cd\u518d\u8f7b\uff0c\u6240\u4ee5\u6bcf\u4e00\u6761\u91cd\u94fe\u7684\u65b0\u7f16\u53f7\u662f\u8fde\u7eed\u7684\r\n- \u56e0\u4e3a\u662fdfs\uff0c\u6240\u4ee5\u6bcf\u4e00\u4e2a\u5b50\u6811\u7684\u65b0\u7f16\u53f7\u4e5f\u662f\u8fde\u7eed\u7684\r\n\r\n\u73b0\u5728\u56de\u987e\u4e00\u4e0b\u6211\u4eec\u8981\u5904\u7406\u7684\u95ee\u9898\r\n\r\n- \u5904\u7406\u4efb\u610f\u4e24\u70b9\u95f4\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\r\n- \u5904\u7406\u4e00\u70b9\u53ca\u5176\u5b50\u6811\u7684\u70b9\u6743\u548c\r\n- \u4fee\u6539\u4efb\u610f\u4e24\u70b9\u95f4\u8def\u5f84\u4e0a\u7684\u70b9\u6743\r\n- \u4fee\u6539\u4e00\u70b9\u53ca\u5176\u5b50\u6811\u7684\u70b9\u6743\r\n\r\n1\u3001\u5f53\u6211\u4eec\u8981\u5904\u7406\u4efb\u610f\u4e24\u70b9\u95f4\u8def\u5f84\u65f6\uff1a\r\n\u8bbe\u6240\u5728\u94fe\u9876\u7aef\u7684\u6df1\u5ea6\u66f4\u6df1\u7684\u90a3\u4e2a\u70b9\u4e3ax\u70b9\r\n\r\n- ans\u52a0\u4e0ax\u70b9\u5230x\u6240\u5728\u94fe\u9876\u7aef \u8fd9\u4e00\u6bb5\u533a\u95f4\u7684\u70b9\u6743\u548c\r\n- \u628ax\u8df3\u5230x\u6240\u5728\u94fe\u9876\u7aef\u7684\u90a3\u4e2a\u70b9\u7684\u4e0a\u9762\u4e00\u4e2a\u70b9\r\n\r\n\u4e0d\u505c\u6267\u884c\u8fd9\u4e24\u4e2a\u6b65\u9aa4\uff0c\u76f4\u5230\u4e24\u4e2a\u70b9\u5904\u4e8e\u4e00\u6761\u94fe\u4e0a\uff0c\u8fd9\u65f6\u518d\u52a0\u4e0a\u6b64\u65f6\u4e24\u4e2a\u70b9\u7684\u533a\u95f4\u548c\u5373\u53ef\r\n\r\n![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120221226-353167092.png)\r\n\r\n\u8fd9\u65f6\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u6211\u4eec\u6240\u8981\u5904\u7406\u7684\u6240\u6709\u533a\u95f4\u5747\u4e3a\u8fde\u7eed\u7f16\u53f7(\u65b0\u7f16\u53f7)\uff0c\u4e8e\u662f\u60f3\u5230\u7ebf\u6bb5\u6811\uff0c\u7528\u7ebf\u6bb5\u6811\u5904\u7406\u8fde\u7eed\u7f16\u53f7\u533a\u95f4\u548c\r\n\r\n\u6bcf\u6b21\u67e5\u8be2\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(log^2n)$\r\n\r\n```\r\ninline int qRange(int x,int y){\r\n    int ans=0;\r\n    while(top[x]!=top[y]){//\u5f53\u4e24\u4e2a\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u94fe\u4e0a \r\n        if(dep[top[x]]<dep[top[y]])swap(x,y);//\u628ax\u70b9\u6539\u4e3a\u6240\u5728\u94fe\u9876\u7aef\u7684\u6df1\u5ea6\u66f4\u6df1\u7684\u90a3\u4e2a\u70b9\r\n        res=0;\r\n        query(1,1,n,id[top[x]],id[x]);//ans\u52a0\u4e0ax\u70b9\u5230x\u6240\u5728\u94fe\u9876\u7aef \u8fd9\u4e00\u6bb5\u533a\u95f4\u7684\u70b9\u6743\u548c\r\n        ans+=res;\r\n        ans%=mod;//\u6309\u9898\u610f\u53d6\u6a21 \r\n        x=fa[top[x]];//\u628ax\u8df3\u5230x\u6240\u5728\u94fe\u9876\u7aef\u7684\u90a3\u4e2a\u70b9\u7684\u4e0a\u9762\u4e00\u4e2a\u70b9\r\n    }\r\n    //\u76f4\u5230\u4e24\u4e2a\u70b9\u5904\u4e8e\u4e00\u6761\u94fe\u4e0a\r\n    if(dep[x]>dep[y])swap(x,y);//\u628ax\u70b9\u6df1\u5ea6\u66f4\u6df1\u7684\u90a3\u4e2a\u70b9\r\n    res=0;\r\n    query(1,1,n,id[x],id[y]);//\u8fd9\u65f6\u518d\u52a0\u4e0a\u6b64\u65f6\u4e24\u4e2a\u70b9\u7684\u533a\u95f4\u548c\u5373\u53ef\r\n    ans+=res;\r\n    return ans%mod;\r\n}//\u53d8\u91cf\u89e3\u91ca\u89c1\u6700\u4e0b\u9762\r\n```\r\n\r\n2\u3001\u5904\u7406\u4e00\u70b9\u53ca\u5176\u5b50\u6811\u7684\u70b9\u6743\u548c\uff1a\r\n\r\n\u60f3\u5230\u8bb0\u5f55\u4e86\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f(\u542b\u5b83\u81ea\u5df1)\uff0c\u5e76\u4e14\u6bcf\u4e2a\u5b50\u6811\u7684\u65b0\u7f16\u53f7\u90fd\u662f\u8fde\u7eed\u7684\r\n\r\n\u4e8e\u662f\u76f4\u63a5\u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u8be2\u5373\u53ef\r\n\r\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(logn)$\r\n\r\n```\r\ninline int qSon(int x){\r\n    res=0;\r\n    query(1,1,n,id[x],id[x]+siz[x]-1);//\u5b50\u6811\u533a\u95f4\u53f3\u7aef\u70b9\u4e3aid[x]+siz[x]-1 \r\n    return res;\r\n}\r\n```\r\n\u5f53\u7136\uff0c\u533a\u95f4\u4fee\u6539\u5c31\u548c\u533a\u95f4\u67e5\u8be2\u4e00\u6837\u7684\u5566~~\r\n```\r\ninline void updRange(int x,int y,int k){\r\n    k%=mod;\r\n    while(top[x]!=top[y]){\r\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\r\n        update(1,1,n,id[top[x]],id[x],k);\r\n        x=fa[top[x]];\r\n    }\r\n    if(dep[x]>dep[y])swap(x,y);\r\n    update(1,1,n,id[x],id[y],k);\r\n}\r\n\r\ninline void updSon(int x,int k){\r\n    update(1,1,n,id[x],id[x]+siz[x]-1,k);\r\n}//\u53d8\u91cf\u89e3\u91ca\u89c1\u6700\u4e0b\u9762\r\n```\r\n\r\n\r\n## \u5efa\u6811\r\n\r\n\u65e2\u7136\u524d\u9762\u8bf4\u5230\u8981\u7528\u7ebf\u6bb5\u6811\uff0c\u90a3\u4e48\u6309\u9898\u610f\u5efa\u6811\u5c31\u53ef\u4ee5\u5566\uff01\r\n\u4e0d\u8fc7\uff0c\u5efa\u6811\u8fd9\u4e00\u6b65\u5f53\u7136\u662f\u5728\u5904\u7406\u95ee\u9898\u4e4b\u524d\u54e6~\r\n\r\n\r\nAC\u4ee3\u7801\uff1a\r\n\r\n```cpp\r\n#include<algorithm>\r\n#include<iostream>\r\n#include<cstdlib>\r\n#include<cstring>\r\n#include<cstdio>\r\n#define Rint register int\r\n#define mem(a,b) memset(a,(b),sizeof(a))\r\n#define Temp template<typename T>\r\nusing namespace std;\r\ntypedef long long LL;\r\nTemp inline void read(T &x){\r\n    x=0;T w=1,ch=getchar();\r\n    while(!isdigit(ch)&&ch!='-')ch=getchar();\r\n    if(ch=='-')w=-1,ch=getchar();\r\n    while(isdigit(ch))x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();\r\n    x=x*w;\r\n}\r\n\r\n#define mid ((l+r)>>1)\r\n#define lson rt<<1,l,mid\r\n#define rson rt<<1|1,mid+1,r\r\n#define len (r-l+1)\r\n\r\nconst int maxn=200000+10;\r\nint n,m,r,mod;\r\n//\u89c1\u9898\u610f \r\nint e,beg[maxn],nex[maxn],to[maxn],w[maxn],wt[maxn];\r\n//\u94fe\u5f0f\u524d\u5411\u661f\u6570\u7ec4\uff0cw[]\u3001wt[]\u521d\u59cb\u70b9\u6743\u6570\u7ec4 \r\nint a[maxn<<2],laz[maxn<<2];\r\n//\u7ebf\u6bb5\u6811\u6570\u7ec4\u3001lazy\u64cd\u4f5c \r\nint son[maxn],id[maxn],fa[maxn],cnt,dep[maxn],siz[maxn],top[maxn]; \r\n//son[]\u91cd\u513f\u5b50\u7f16\u53f7,id[]\u65b0\u7f16\u53f7,fa[]\u7236\u4eb2\u8282\u70b9,cnt dfs_clock/dfs\u5e8f,dep[]\u6df1\u5ea6,siz[]\u5b50\u6811\u5927\u5c0f,top[]\u5f53\u524d\u94fe\u9876\u7aef\u8282\u70b9 \r\nint res=0;\r\n//\u67e5\u8be2\u7b54\u6848 \r\n\r\ninline void add(int x,int y){//\u94fe\u5f0f\u524d\u5411\u661f\u52a0\u8fb9 \r\n    to[++e]=y;\r\n    nex[e]=beg[x];\r\n    beg[x]=e;\r\n}\r\n//-------------------------------------- \u4ee5\u4e0b\u4e3a\u7ebf\u6bb5\u6811 \r\ninline void pushdown(int rt,int lenn){\r\n    laz[rt<<1]+=laz[rt];\r\n    laz[rt<<1|1]+=laz[rt];\r\n    a[rt<<1]+=laz[rt]*(lenn-(lenn>>1));\r\n    a[rt<<1|1]+=laz[rt]*(lenn>>1);\r\n    a[rt<<1]%=mod;\r\n    a[rt<<1|1]%=mod;\r\n    laz[rt]=0;\r\n}\r\n\r\ninline void build(int rt,int l,int r){\r\n    if(l==r){\r\n        a[rt]=wt[l];\r\n        if(a[rt]>mod)a[rt]%=mod;\r\n        return;\r\n    }\r\n    build(lson);\r\n    build(rson);\r\n    a[rt]=(a[rt<<1]+a[rt<<1|1])%mod;\r\n}\r\n\r\ninline void query(int rt,int l,int r,int L,int R){\r\n    if(L<=l&&r<=R){res+=a[rt];res%=mod;return;}\r\n    else{\r\n        if(laz[rt])pushdown(rt,len);\r\n        if(L<=mid)query(lson,L,R);\r\n        if(R>mid)query(rson,L,R);\r\n    }\r\n}\r\n\r\ninline void update(int rt,int l,int r,int L,int R,int k){\r\n    if(L<=l&&r<=R){\r\n        laz[rt]+=k;\r\n        a[rt]+=k*len;\r\n    }\r\n    else{\r\n        if(laz[rt])pushdown(rt,len);\r\n        if(L<=mid)update(lson,L,R,k);\r\n        if(R>mid)update(rson,L,R,k);\r\n        a[rt]=(a[rt<<1]+a[rt<<1|1])%mod;\r\n    }\r\n}\r\n//---------------------------------\u4ee5\u4e0a\u4e3a\u7ebf\u6bb5\u6811 \r\ninline int qRange(int x,int y){\r\n    int ans=0;\r\n    while(top[x]!=top[y]){//\u5f53\u4e24\u4e2a\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u94fe\u4e0a \r\n        if(dep[top[x]]<dep[top[y]])swap(x,y);//\u628ax\u70b9\u6539\u4e3a\u6240\u5728\u94fe\u9876\u7aef\u7684\u6df1\u5ea6\u66f4\u6df1\u7684\u90a3\u4e2a\u70b9\r\n        res=0;\r\n        query(1,1,n,id[top[x]],id[x]);//ans\u52a0\u4e0ax\u70b9\u5230x\u6240\u5728\u94fe\u9876\u7aef \u8fd9\u4e00\u6bb5\u533a\u95f4\u7684\u70b9\u6743\u548c\r\n        ans+=res;\r\n        ans%=mod;//\u6309\u9898\u610f\u53d6\u6a21 \r\n        x=fa[top[x]];//\u628ax\u8df3\u5230x\u6240\u5728\u94fe\u9876\u7aef\u7684\u90a3\u4e2a\u70b9\u7684\u4e0a\u9762\u4e00\u4e2a\u70b9\r\n    }\r\n    //\u76f4\u5230\u4e24\u4e2a\u70b9\u5904\u4e8e\u4e00\u6761\u94fe\u4e0a\r\n    if(dep[x]>dep[y])swap(x,y);//\u628ax\u70b9\u6df1\u5ea6\u66f4\u6df1\u7684\u90a3\u4e2a\u70b9\r\n    res=0;\r\n    query(1,1,n,id[x],id[y]);//\u8fd9\u65f6\u518d\u52a0\u4e0a\u6b64\u65f6\u4e24\u4e2a\u70b9\u7684\u533a\u95f4\u548c\u5373\u53ef\r\n    ans+=res;\r\n    return ans%mod;\r\n}\r\n\r\ninline void updRange(int x,int y,int k){//\u540c\u4e0a \r\n    k%=mod;\r\n    while(top[x]!=top[y]){\r\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\r\n        update(1,1,n,id[top[x]],id[x],k);\r\n        x=fa[top[x]];\r\n    }\r\n    if(dep[x]>dep[y])swap(x,y);\r\n    update(1,1,n,id[x],id[y],k);\r\n}\r\n\r\ninline int qSon(int x){\r\n    res=0;\r\n    query(1,1,n,id[x],id[x]+siz[x]-1);//\u5b50\u6811\u533a\u95f4\u53f3\u7aef\u70b9\u4e3aid[x]+siz[x]-1 \r\n    return res;\r\n}\r\n\r\ninline void updSon(int x,int k){//\u540c\u4e0a \r\n    update(1,1,n,id[x],id[x]+siz[x]-1,k);\r\n}\r\n\r\ninline void dfs1(int x,int f,int deep){//x\u5f53\u524d\u8282\u70b9\uff0cf\u7236\u4eb2\uff0cdeep\u6df1\u5ea6 \r\n    dep[x]=deep;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6 \r\n    fa[x]=f;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2 \r\n    siz[x]=1;//\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f \r\n    int maxson=-1;//\u8bb0\u5f55\u91cd\u513f\u5b50\u7684\u513f\u5b50\u6570 \r\n    for(Rint i=beg[x];i;i=nex[i]){\r\n        int y=to[i];\r\n        if(y==f)continue;//\u82e5\u4e3a\u7236\u4eb2\u5219continue \r\n        dfs1(y,x,deep+1);//dfs\u5176\u513f\u5b50 \r\n        siz[x]+=siz[y];//\u628a\u5b83\u7684\u513f\u5b50\u6570\u52a0\u5230\u5b83\u8eab\u4e0a \r\n        if(siz[y]>maxson)son[x]=y,maxson=siz[y];//\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u91cd\u513f\u5b50\u7f16\u53f7 \r\n    }\r\n}\r\n\r\ninline void dfs2(int x,int topf){//x\u5f53\u524d\u8282\u70b9\uff0ctopf\u5f53\u524d\u94fe\u7684\u6700\u9876\u7aef\u7684\u8282\u70b9 \r\n    id[x]=++cnt;//\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u65b0\u7f16\u53f7 \r\n    wt[cnt]=w[x];//\u628a\u6bcf\u4e2a\u70b9\u7684\u521d\u59cb\u503c\u8d4b\u5230\u65b0\u7f16\u53f7\u4e0a\u6765 \r\n    top[x]=topf;//\u8fd9\u4e2a\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aef \r\n    if(!son[x])return;//\u5982\u679c\u6ca1\u6709\u513f\u5b50\u5219\u8fd4\u56de \r\n    dfs2(son[x],topf);//\u6309\u5148\u5904\u7406\u91cd\u513f\u5b50\uff0c\u518d\u5904\u7406\u8f7b\u513f\u5b50\u7684\u987a\u5e8f\u9012\u5f52\u5904\u7406 \r\n    for(Rint i=beg[x];i;i=nex[i]){\r\n        int y=to[i];\r\n        if(y==fa[x]||y==son[x])continue;\r\n        dfs2(y,y);//\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8f7b\u513f\u5b50\u90fd\u6709\u4e00\u6761\u4ece\u5b83\u81ea\u5df1\u5f00\u59cb\u7684\u94fe \r\n    }\r\n}\r\n\r\nint main(){\r\n    read(n);read(m);read(r);read(mod);\r\n    for(Rint i=1;i<=n;i++)read(w[i]);\r\n    for(Rint i=1;i<n;i++){\r\n        int a,b;\r\n        read(a);read(b);\r\n        add(a,b);add(b,a);\r\n    }\r\n    dfs1(r,0,1);\r\n    dfs2(r,r);\r\n    build(1,1,n);\r\n    while(m--){\r\n        int k,x,y,z;\r\n        read(k);\r\n        if(k==1){\r\n            read(x);read(y);read(z);\r\n            updRange(x,y,z);\r\n        }\r\n        else if(k==2){\r\n            read(x);read(y);\r\n            printf(\"%d\\n\",qRange(x,y));\r\n        }\r\n        else if(k==3){\r\n            read(x);read(y);\r\n            updSon(x,y);\r\n        }\r\n        else{\r\n            read(x);\r\n            printf(\"%d\\n\",qSon(x));\r\n        }\r\n    }\r\n}\r\n```",
        "postTime": 1512274294,
        "uid": 47062,
        "name": "zengqinyi",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\n[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u53ca\u4f8b\u9898\u70b9\u8fd9\u91cc](http://www.cnblogs.com/zwfymqz/p/8094500.html)\n\n\n## \u524d\u8a00\n\n\n- \u6811\u94fe\u5256\u5206\u662f\u4ec0\u4e48\uff1f\n\n\n\u6811\u94fe\u5256\u5206\uff0c\u8bf4\u767d\u4e86\u5c31\u662f\u4e00\u79cd\u8ba9\u4f60\u4ee3\u7801\u4e0d\u5f97\u4e0d\u5f3a\u884c\u589e\u52a01k\u7684\u6570\u636e\u7ed3\u6784-dms\n\n- \u6709\u4ec0\u4e48\u7528\uff1f\n\n~~\u8bc1\u660e\u51fa\u9898\u4eba\u975e\u5e38\u6bd2\u7624~~\n\n\u53ef\u4ee5\u975e\u5e38\u53cb(bao)\u597d(li)\u7684\u89e3\u51b3\u4e00\u4e9b\u6811\u4e0a\u95ee\u9898\n\n\n## \u6838\u5fc3\u601d\u60f3\n\n\u6811\u94fe\u5256\u5206\u7684\u601d\u60f3\u6bd4\u8f83\u795e\u5947\n\n\n\u5b83\u7684\u601d\u60f3\u662f\uff1a**\u628a\u4e00\u68f5\u6811\u62c6\u6210\u82e5\u5e72\u4e2a\u4e0d\u76f8\u4ea4\u7684\u94fe\uff0c\u7136\u540e\u7528\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u8fd9\u4e9b\u94fe**\n\n\n \n\n\u90a3\u4e48\u95ee\u9898\u6765\u4e86\n\n\n- \u5982\u4f55\u628a\u6811\u62c6\u6210\u94fe\uff1f\n\n\n\u9996\u5148\u660e\u786e\u4e00\u4e9b\u5b9a\u4e49\n\n**\u91cd\u513f\u5b50**\uff1a\u8be5\u8282\u70b9\u7684\u5b50\u6811\u4e2d,\u8282\u70b9\u4e2a\u6570\u6700\u591a\u7684\u5b50\u6811\u7684\u6839\u8282\u70b9(\u4e5f\u5c31\u662f\u548c\u8be5\u8282\u70b9\u76f8\u8fde\u7684\u70b9)\uff0c\u5373\u4e3a\u8be5\u8282\u70b9\u7684\u91cd\u513f\u5b50\n\n**\u91cd\u8fb9**\uff1a\u8fde\u63a5\u8be5\u8282\u70b9\u4e0e\u5b83\u7684\u91cd\u513f\u5b50\u7684\u8fb9\n\n**\u91cd\u94fe**\uff1a\u7531\u4e00\u7cfb\u5217\u91cd\u8fb9\u76f8\u8fde\u5f97\u5230\u7684\u94fe\n\n**\u8f7b\u94fe**\uff1a\u7531\u4e00\u7cfb\u5217\u975e\u91cd\u8fb9\u76f8\u8fde\u5f97\u5230\u7684\u94fe\n\n\n\u8fd9\u6837\u5c31\u4e0d\u96be\u5f97\u5230\u62c6\u6811\u7684\u65b9\u6cd5\n\n**\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u627e\u51fa\u5b83\u7684\u91cd\u513f\u5b50\uff0c\u90a3\u4e48\u8fd9\u68f5\u6811\u5c31\u81ea\u7136\u800c\u7136\u7684\u88ab\u62c6\u6210\u4e86\u8bb8\u591a\u91cd\u94fe\u4e0e\u8bb8\u591a\u8f7b\u94fe**\n\n\n-  \u5982\u4f55\u5bf9\u8fd9\u4e9b\u94fe\u8fdb\u884c\u7ef4\u62a4\uff1f\n\n\n\u9996\u5148\uff0c\u8981\u5bf9\u8fd9\u4e9b\u94fe\u8fdb\u884c\u7ef4\u62a4\uff0c\u5c31\u8981\u786e\u4fdd\u6bcf\u4e2a\u94fe\u4e0a\u7684\u8282\u70b9\u90fd\u662f\u8fde\u7eed\u7684\uff0c\n\n\u56e0\u6b64\u6211\u4eec\u9700\u8981\u5bf9\u6574\u68f5\u6811\u8fdb\u884c\u91cd\u65b0\u7f16\u53f7\uff0c\u7136\u540e\u5229\u7528dfs\u5e8f\u7684\u601d\u60f3\uff0c\u7528\u7ebf\u6bb5\u6811\u6216\u6811\u72b6\u6570\u7ec4\u7b49\u8fdb\u884c\u7ef4\u62a4\uff08\u5177\u4f53\u7528\u4ec0\u4e48\u9700\u8981\u770b\u9898\u76ee\u8981\u6c42\uff0c\u56e0\u4e3a\u7ebf\u6bb5\u6811\u7684\u529f\u80fd\u6bd4\u6811\u72b6\u6570\u7ec4\u5f3a\u5927\uff0c\u6240\u4ee5\u5728\u8fd9\u91cc\u6211\u5c31\u4e0d\u63d0\u4f9b\u6811\u72b6\u6570\u7ec4\u7684\u5199\u6cd5\u4e86\uff09\n\n\n\u6ce8\u610f\u5728\u8fdb\u884c\u91cd\u65b0\u7f16\u53f7\u7684\u65f6\u5019\u5148\u8bbf\u95ee\u91cd\u94fe\n\n\u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u91cd\u94fe\u5185\u7684\u8282\u70b9\u7f16\u53f7\u8fde\u7eed\n\n\u4e0a\u9762\u8bf4\u7684\u592a\u62bd\u8c61\u4e86\uff0c\u7ed3\u5408\u4e00\u5f20\u56fe\u6765\u7406\u89e3\u4e00\u4e0b\n\n![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224081845381-1133998892.png)\n\n\u5bf9\u4e8e\u4e00\u68f5\u6700\u57fa\u672c\u7684\u6811\n\n\u7ed9\u4ed6\u6807\u8bb0\u91cd\u513f\u5b50\uff0c\n\n![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224082406709-293882916.png)\n\n\u84dd\u8272\u4e3a\u91cd\u513f\u5b50\uff0c\u7ea2\u8272\u4e3a\u91cd\u8fb9\n\n\u7136\u540e\u5bf9\u6811\u8fdb\u884c\u91cd\u65b0\u7f16\u53f7\n\n![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224082851146-1417020317.png)\n\n\u6a59\u8272\u8868\u793a\u7684\u662f\u8be5\u8282\u70b9\u91cd\u65b0\u7f16\u53f7\u540e\u7684\u5e8f\u53f7\n\n\u4e0d\u96be\u770b\u51fa\u91cd\u94fe\u5185\u7684\u8282\u70b9\u7f16\u53f7\u662f\u8fde\u7eed\u7684\n\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u5728\u7ebf\u6bb5\u6811\u4e0a\u641e\u4e8b\u60c5\u5566\n\n\u50cf\u4ec0\u4e48\u533a\u95f4\u52a0\u533a\u95f4\u6c42\u548c\u4ec0\u4e48\u7684\n\n\u53e6\u5916\u6709\u4e00\u4e2a\u6027\u8d28\uff1a\u4ee5$i$\u4e3a\u6839\u7684\u5b50\u6811\u7684\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u7f16\u53f7\u4e3a$[i,i+\u5b50\u6811\u8282\u70b9\u6570-1]$\n\n\n\u63a5\u4e0b\u6765\u7ed3\u5408\u4e00\u9053\u4f8b\u9898\uff0c\u52a0\u6df1\u4e00\u4e0b\u5bf9\u4e8e\u4ee3\u7801\u7684\u7406\u89e3\n\n## \u4ee3\u7801\n\n\u9996\u5148\u6765\u4e00\u5768\u5b9a\u4e49\n\n```cpp\nint deep[MAXN];//\u8282\u70b9\u7684\u6df1\u5ea6 \nint fa[MAXN];//\u8282\u70b9\u7684\u7236\u4eb2 \nint son[MAXN];//\u8282\u70b9\u7684\u91cd\u513f\u5b50 \nint tot[MAXN];//\u8282\u70b9\u5b50\u6811\u7684\u5927\u5c0f \n```\n### \u7b2c\u4e00\u6b65\n\n\u6309\u7167\u6211\u4eec\u4e0a\u9762\u8bf4\u7684\uff0c\u6211\u4eec\u9996\u5148\u8981\u5bf9\u6574\u68f5\u6811dfs\u4e00\u904d\uff0c\u627e\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u91cd\u513f\u5b50\n\n\u987a\u4fbf\u5904\u7406\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6\uff0c\u4ee5\u53ca\u4ed6\u4eec\u7684\u7236\u4eb2\u8282\u70b9\n\n```cpp\nint dfs1(int now,int f,int dep)\n{\n    deep[now]=dep;\n    fa[now]=f;\n    tot[now]=1;\n    int maxson=-1;\n    for(int i=head[now];i!=-1;i=edge[i].nxt)\n    {\n        if(edge[i].v==f) continue;\n        tot[now]+=dfs1(edge[i].v,now,dep+1);\n        if(tot[edge[i].v]>maxson) maxson=tot[edge[i].v],son[now]=edge[i].v;\n    }\n    return tot[now];\n}\n```\n### \u7b2c\u4e8c\u6b65\n\u7136\u540e\u6211\u4eec\u9700\u8981\u5bf9\u6574\u68f5\u6811\u8fdb\u884c\u91cd\u65b0\u7f16\u53f7\n\n\u6211\u628a\u4e00\u5f00\u59cb\u7684\u6bcf\u4e2a\u8282\u70b9\u7684\u6743\u503c\u5b58\u5728\u4e86$b$\u6570\u7ec4\u5185\n\n```cpp\nvoid dfs2(int now,int topf)\n{\n    idx[now]=++cnt;\n    a[cnt]=b[now];\n    top[now]=topf;\n    if(!son[now]) return ;\n    dfs2(son[now],topf);\n    for(int i=head[now];i!=-1;i=edge[i].nxt)\n        if(!idx[edge[i].v])\n            dfs2(edge[i].v,edge[i].v);\n}\n```\n$idx$\u8868\u793a\u91cd\u65b0\u7f16\u53f7\u540e\u8be5\u8282\u70b9\u7684\u7f16\u53f7\u662f\u591a\u5c11\n\u53e6\u5916\uff0c\u8fd9\u91cc\u5f15\u5165\u4e86\u4e00\u4e2a$top$\u6570\u7ec4\uff0c\n\n$top[i]$\u8868\u793a$i$\u53f7\u8282\u70b9\u6240\u5728\u91cd\u94fe\u7684\u5934\u8282\u70b9(\u6700\u9876\u4e0a\u7684\u8282\u70b9)\n\n\u81f3\u4e8e\u8fd9\u4e2a\u6570\u7ec4\u6709\u5565\u7528\uff0c\u540e\u9762\u518d\u8bf4\n\n### \u7b2c\u4e09\u6b65\n\n\u6211\u4eec\u9700\u8981\u6839\u636e\u91cd\u65b0\u7f16\u5b8c\u53f7\u7684\u6811\uff0c\u628a\u8fd9\u68f5\u6811\u7684\u4e0a\u6bcf\u4e2a\u70b9\u6620\u5c04\u5230\u7ebf\u6bb5\u6811\u4e0a\uff0c\n\n```cpp\nstruct Tree\n{\n    int l,r,w,siz,f;\n}T[MAXN];\nvoid Build(int k,int ll,int rr)\n{\n    T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1;\n    if(ll==rr)\n    {\n        T[k].w=a[ll];\n        return ;\n    }\n    int mid=(ll+rr)>>1;\n    Build(ls,ll,mid);\n    Build(rs,mid+1,rr);\n    update(k);\n}\n```\n\u53e6\u5916\u7ebf\u6bb5\u6811\u7684\u57fa\u672c\u64cd\u4f5c\uff0c\n\u8fd9\u91cc\u5c31\u4e0d\u8be6\u7ec6\u89e3\u91ca\u4e86\n\n\u76f4\u63a5\u653e\u4ee3\u7801\n\n```cpp\nvoid update(int k)//\u66f4\u65b0\n{\n    T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;\n}\nvoid IntervalAdd(int k,int ll,int rr,int val)//\u533a\u95f4\u52a0\n{\n    if(ll<=T[k].l&&T[k].r<=rr)\n    {\n        T[k].w+=T[k].siz*val;\n        T[k].f+=val;\n        return ;\n    }\n    pushdown(k);\n    int mid=(T[k].l+T[k].r)>>1;\n    if(ll<=mid)    IntervalAdd(ls,ll,rr,val);\n    if(rr>mid)    IntervalAdd(rs,ll,rr,val);\n    update(k);\n}\nint IntervalSum(int k,int ll,int rr)//\u533a\u95f4\u6c42\u548c\n{\n    int ans=0;\n    if(ll<=T[k].l&&T[k].r<=rr)\n        return T[k].w;\n    pushdown(k);\n    int mid=(T[k].l+T[k].r)>>1;\n    if(ll<=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD;\n    if(rr>mid)  ans=(ans+IntervalSum(rs,ll,rr))%MOD;\n    return ans;\n}\nvoid pushdown(int k)//\u4e0b\u4f20\u6807\u8bb0\n{\n    if(!T[k].f) return ;\n    T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD;\n    T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD;\n    T[ls].f=(T[ls].f+T[k].f)%MOD;\n    T[rs].f=(T[rs].f+T[k].f)%MOD;\n    T[k].f=0;\n}\n```\n### \u7b2c\u56db\u6b65\n\u6211\u4eec\u8003\u8651\u5982\u4f55\u5b9e\u73b0\u5bf9\u4e8e\u6811\u4e0a\u7684\u64cd\u4f5c\n\n\u6811\u94fe\u5256\u5206\u7684\u601d\u60f3\u662f:\u5bf9\u4e8e\u4e24\u4e2a\u4e0d\u5728\u540c\u4e00\u91cd\u94fe\u5185\u7684\u8282\u70b9,\u8ba9\u4ed6\u4eec\u4e0d\u65ad\u5730\u8df3,\u4f7f\u5f97\u4ed6\u4eec\u5904\u4e8e\u540c\u4e00\u91cd\u94fe\u4e0a\n\n\u90a3\u4e48\u5982\u4f55\"\u8df3\u201d\u5462\uff1f\n\n\u8fd8\u8bb0\u5f97\u6211\u4eec\u5728\u7b2c\u4e8c\u6b21$dfs$\u4e2d\u8bb0\u5f55\u7684$top$\u6570\u7ec4\u4e48\uff1f\n\n\u6709\u4e00\u4e2a\u663e\u7136\u7684\u7ed3\u8bba\uff1a$x$\u5230$top[x]$\u4e2d\u7684\u8282\u70b9\u5728\u7ebf\u6bb5\u6811\u4e0a\u662f\u8fde\u7eed\u7684\uff0c\n\n\u7ed3\u5408$deep$\u6570\u7ec4\n\n\u5047\u8bbe\u4e24\u4e2a\u8282\u70b9\u4e3a$x$,$y$\n\n\u6211\u4eec\u6bcf\u6b21\u8ba9$deep[top[x]]$\u4e0e$deep[top[y]]$\u4e2d\u5927\u7684(\u5728\u4e0b\u9762\u7684)\u5f80\u4e0a\u8df3(\u6709\u70b9\u7c7b\u4f3c\u4e8e\u6811\u4e0a\u500d\u589e)\n\n\u8ba9x\u8282\u70b9\u76f4\u63a5\u8df3\u5230$top[x]$,\u7136\u540e\u5728\u7ebf\u6bb5\u6811\u4e0a\u66f4\u65b0\n\n\u6700\u540e\u4e24\u4e2a\u8282\u70b9\u4e00\u5b9a\u662f\u5904\u4e8e\u540c\u4e00\u6761\u91cd\u94fe\u7684\uff0c\u524d\u9762\u6211\u4eec\u63d0\u5230\u8fc7\u91cd\u94fe\u4e0a\u7684\u8282\u70b9\u90fd\u662f\u8fde\u7eed\u7684\uff0c\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u8fdb\u884c\u4e00\u6b21\u67e5\u8be2\u5c31\u597d\n\n```cpp\nvoid TreeSum(int x,int y)//x\u4e0ey\u8def\u5f84\u4e0a\u7684\u548c\n{\n    int ans=0;\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD;\n        x=fa[ top[x] ];\n    }\n    if(deep[x]>deep[y]) swap(x,y);\n    ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD;\n    printf(\"%d\\n\",ans);\n}\nvoid TreeAdd(int x,int y,int val)//\u5bf9\u4e8ex,y\u8def\u5f84\u4e0a\u7684\u70b9\u52a0val\u7684\u6743\u503c\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        IntervalAdd(1,idx[ top[x] ],idx[x],val);\n        x=fa[ top[x] ];\n    }\n    if(deep[x]>deep[y])    swap(x,y);\n    IntervalAdd(1,idx[x],idx[y],val);\n}\n```\n\u5728\u6811\u4e0a\u67e5\u8be2\u7684\u8fd9\u4e00\u6b65\u53ef\u80fd\u6709\u4e9b\u62bd\u8c61\uff0c\u6211\u4eec\u7ed3\u5408\u4e00\u4e2a\u4f8b\u5b50\u6765\u7406\u89e3\u4e00\u4e0b\n\n![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224083619412-395006861.png)\n\n\u8fd8\u662f\u4e0a\u9762\u90a3\u5f20\u56fe\uff0c\u5047\u8bbe\u6211\u4eec\u8981\u67e5\u8be2$3.6$\u8fd9\u4e24\u4e2a\u8282\u70b9\u7684\u4e4b\u95f4\u7684\u70b9\u6743\u5408\uff0c\u4e3a\u4e86\u65b9\u4fbf\u7406\u89e3\u6211\u4eec\u5047\u8bbe\u6bcf\u4e2a\u70b9\u7684\u70b9\u6743\u90fd\u662f$1$\n\n\u521a\u5f00\u59cb\u65f6\n\n$top[3]=2,top[6]=1$\n\n$deep[top[3]]=2,deep[top[6]]=1$\n\n\u6211\u4eec\u4f1a\u8ba9$3$\u5411\u4e0a\u8df3,\u8df3\u5230$top[3]$\u7684\u7238\u7238,\u4e5f\u5c31\u662f$1$\u53f7\u8282\u70b9\n\n![](http://images2017.cnblogs.com/blog/1101696/201712/1101696-20171224084036146-1852472774.png)\n\n\u8fd9\u65f6$1$\u53f7\u8282\u70b9\u548c$6$\u53f7\u8282\u70b9\u5df2\u7ecf\u5728\u540c\u4e00\u6761\u91cd\u94fe\u5185,\u6240\u4ee5\u76f4\u63a5\u5bf9\u7ebf\u6bb5\u6811\u8fdb\u884c\u4e00\u6b21\u67e5\u8be2\u5373\u53ef\n\n### \u5bf9\u4e8e\u5b50\u6811\u7684\u64cd\u4f5c\n\n\u8fd9\u4e2a\u5c31\u66f4\u7b80\u5355\u4e86\n\n\u56e0\u4e3a\u4e00\u68f5\u6811\u7684\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u662f\u8fde\u7eed\u7684\n\n\u6240\u4ee5\u4fee\u6539\u7684\u65f6\u5019\u76f4\u63a5\u8fd9\u6837\n\nIntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD);\n\n## \u65f6\u95f4\u590d\u6742\u5ea6\n\n### \u6027\u8d281\n\n\u5982\u679c\u8fb9$\\left( u,v\\right)$,\u4e3a\u8f7b\u8fb9,\u90a3\u4e48$Size\\left( v\\right) \\leq Size\\left( u\\right) /2$\u3002\n\n\u8bc1\u660e\uff1a\u663e\u7136\uff0c\u5426\u5219\u8be5\u8fb9\u4f1a\u6210\u4e3a\u91cd\u8fb9\n\n### \u6027\u8d282\n\n\u6811\u4e2d\u4efb\u610f\u4e24\u4e2a\u8282\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u4e2d\u8f7b\u8fb9\u7684\u6761\u6570\u4e0d\u4f1a\u8d85\u8fc7$\\log _{2}n$,\u91cd\u8def\u5f84\u7684\u6570\u76ee\u4e0d\u4f1a\u8d85\u8fc7$\\log _{2}n$\n\n\u8bc1\u660e\uff1a\u4e0d\u4f1a\n\n\u6709\u4e86\u4e0a\u9762\u4e24\u6761\u6027\u8d28\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u6765\u5206\u6790\u65f6\u95f4\u590d\u6742\u5ea6\u4e86\n\n\u7531\u4e8e\u91cd\u8def\u5f84\u7684\u6570\u91cf\u7684\u4e0a\u754c\u4e3a$\\log _{2}n$\uff0c\n\n\u7ebf\u6bb5\u6811\u4e2d\u67e5\u8be2/\u4fee\u6539\u7684\u590d\u6742\u5ea6\u4e3a$\\log _{2}n$\n\n\u90a3\u4e48\u603b\u7684\u590d\u6742\u5ea6\u5c31\u662f$\\left( \\log _{2}n\\right) ^{2}$\n\n## \u5b8c\u6574\u4ee3\u7801\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int MAXN=2*1e6+10;\n#define ls k<<1\n#define rs k<<1|1\ninline char nc()\n{\n    static char buf[MAXN],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,MAXN,stdin),p1==p2)?EOF:*p1++;\n}\ninline int read()\n{\n    char c=nc();int x=0,f=1;\n    while(c<'0'||c>'9'){if(c=='-')f=-1;c=nc();}\n    while(c>='0'&&c<='9'){x=x*10+c-'0',c=nc();}\n    return x*f;\n}\nstruct node\n{\n    int u,v,nxt;\n}edge[MAXN];\nint head[MAXN];\nint num=1;\nstruct Tree\n{\n    int l,r,w,siz,f;\n}T[MAXN];\nint N,M,root,MOD,cnt=0,a[MAXN],b[MAXN];\ninline void AddEdge(int x,int y)\n{\n    edge[num].u=x;\n    edge[num].v=y;\n    edge[num].nxt=head[x];\n    head[x]=num++;\n}\nint deep[MAXN],fa[MAXN],son[MAXN],tot[MAXN],top[MAXN],idx[MAXN];\nint dfs1(int now,int f,int dep)\n{\n    deep[now]=dep;\n    fa[now]=f;\n    tot[now]=1;\n    int maxson=-1;\n    for(int i=head[now];i!=-1;i=edge[i].nxt)\n    {\n        if(edge[i].v==f) continue;\n        tot[now]+=dfs1(edge[i].v,now,dep+1);\n        if(tot[edge[i].v]>maxson) maxson=tot[edge[i].v],son[now]=edge[i].v;\n    }\n    return tot[now];\n}\nvoid update(int k)\n{\n    T[k].w=(T[ls].w+T[rs].w+MOD)%MOD;\n}\nvoid Build(int k,int ll,int rr)\n{\n    T[k].l=ll;T[k].r=rr;T[k].siz=rr-ll+1;\n    if(ll==rr)\n    {\n        T[k].w=a[ll];\n        return ;\n    }\n    int mid=(ll+rr)>>1;\n    Build(ls,ll,mid);\n    Build(rs,mid+1,rr);\n    update(k);\n}\nvoid dfs2(int now,int topf)\n{\n    idx[now]=++cnt;\n    a[cnt]=b[now];\n    top[now]=topf;\n    if(!son[now]) return ;\n    dfs2(son[now],topf);\n    for(int i=head[now];i!=-1;i=edge[i].nxt)\n        if(!idx[edge[i].v])\n            dfs2(edge[i].v,edge[i].v);\n}\nvoid pushdown(int k)\n{\n    if(!T[k].f) return ;\n    T[ls].w=(T[ls].w+T[ls].siz*T[k].f)%MOD;\n    T[rs].w=(T[rs].w+T[rs].siz*T[k].f)%MOD;\n    T[ls].f=(T[ls].f+T[k].f)%MOD;\n    T[rs].f=(T[rs].f+T[k].f)%MOD;\n    T[k].f=0;\n}\nvoid IntervalAdd(int k,int ll,int rr,int val)\n{\n    if(ll<=T[k].l&&T[k].r<=rr)\n    {\n        T[k].w+=T[k].siz*val;\n        T[k].f+=val;\n        return ;\n    }\n    pushdown(k);\n    int mid=(T[k].l+T[k].r)>>1;\n    if(ll<=mid)    IntervalAdd(ls,ll,rr,val);\n    if(rr>mid)    IntervalAdd(rs,ll,rr,val);\n    update(k);\n}\nvoid TreeAdd(int x,int y,int val)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        IntervalAdd(1,idx[ top[x] ],idx[x],val);\n        x=fa[ top[x] ];\n    }\n    if(deep[x]>deep[y])    swap(x,y);\n    IntervalAdd(1,idx[x],idx[y],val);\n}\nint IntervalSum(int k,int ll,int rr)\n{\n    int ans=0;\n    if(ll<=T[k].l&&T[k].r<=rr)\n        return T[k].w;\n    pushdown(k);\n    int mid=(T[k].l+T[k].r)>>1;\n    if(ll<=mid) ans=(ans+IntervalSum(ls,ll,rr))%MOD;\n    if(rr>mid)  ans=(ans+IntervalSum(rs,ll,rr))%MOD;\n    return ans;\n}\nvoid TreeSum(int x,int y)\n{\n    int ans=0;\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        ans=(ans+IntervalSum(1,idx[ top[x] ],idx[x]))%MOD;\n        x=fa[ top[x] ];\n    }\n    if(deep[x]>deep[y]) swap(x,y);\n    ans=(ans+IntervalSum(1,idx[x],idx[y]))%MOD;\n    printf(\"%d\\n\",ans);\n}\nint main()\n{\n    #ifdef WIN32\n    freopen(\"a.in\",\"r\",stdin);\n    #else\n    #endif\n    memset(head,-1,sizeof(head));\n    N=read();M=read();root=read();MOD=read();\n    for(int i=1;i<=N;i++) b[i]=read();\n    for(int i=1;i<=N-1;i++)\n    {\n        int x=read(),y=read();\n        AddEdge(x,y);AddEdge(y,x);\n    }\n    dfs1(root,0,1);\n    dfs2(root,root);\n    Build(1,1,N);\n    while(M--)\n    {\n        int opt=read(),x,y,z;\n        if(opt==1)\n        {    \n            x=read();y=read();z=read();z=z%MOD;\n            TreeAdd(x,y,z);\n        }\n        else if(opt==2)\n        {\n            x=read();y=read();\n            TreeSum(x,y);\n        }\n        else if(opt==3)\n        {\n            x=read(),z=read();\n            IntervalAdd(1,idx[x],idx[x]+tot[x]-1,z%MOD);\n        }\n        else if(opt==4)\n        {\n            x=read();\n            printf(\"%d\\n\",IntervalSum(1,idx[x],idx[x]+tot[x]-1));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1514076991,
        "uid": 36984,
        "name": "attack",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": ">## \u6811\u4e0a\u8def\u5f84\uff0c\u5206\u6e05\u8fb9\u5b70\u8f7b\u5b70\u91cd\u3002  \n\n## \u2014\u2014\u300a\u6211\u7684\u4e00\u4e2aOIer\u670b\u53cb\u300b\n\n\u6811\u94fe\u5256\u5206\uff0c\u7b80\u79f0\u6811\u5256\u3002\u662f\u4e00\u79cd~~\u6bd2\u7624~~\u5de7\u5999\u7684\u7b97\u6cd5\uff0c\u53ef\u4ee5\u628a\u6811\u5212\u5206\u6210\u8bb8\u591a\u94fe\uff0c\u7b80\u4fbf\u5730\u5b9e\u73b0\u6811\u4e0a\u7684\u4fee\u6539\u4e0e\u67e5\u8be2\u64cd\u4f5c\u3002   \n(\u8fd9\u91cc\u8bf4\u7684 \u6811\u94fe\u5256\u5206 \u6307\u7684\u662f \u8f7b\u91cd\u94fe\u5256\u5206)  \n\u2191\u5982\u679c\u4f60\u521d\u5b66\u6811\u5256\u53ef\u4ee5\u65e0\u89c6\u8fd9\u53e5\u8bdd  \n\n\u6b64\u5904\u5148\u628a\u4f8b\u9898\u642c\u51fa\u6765\uff1a[\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.org/problemnew/show/P3384)  \n\n\u5728\u63a5\u4e0b\u6765\u7684\u8bb2\u89e3\u4e2d\uff0c\u60a8\u5c06**\u4e0d\u53ef\u907f\u514d**\u5730\u63a5\u89e6\u4ee5\u4e0b\u540d\u8bcd\uff1a  \n1\u3001\u91cd\u513f\u5b50\uff1a\u5bf9\u4e8e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9$u$\uff0c\u5b83\u4f1a\u6709\u8bb8\u591a\u513f\u5b50\u3002\u5176\u4e2d\u6709\u4e00\u4e2a\u513f\u5b50\u7684\u5b69\u5b50\u6700\u591a(\u4e5f\u5c31\u662f\u5b50\u6811\u6700\u5927)\uff0c\u90a3\u4e48\u8fd9\u4e2a\u513f\u5b50\u5c31\u53eb$u$\u7684\u91cd\u513f\u5b50\u3002  \n2\u3001\u8f7b\u513f\u5b50\uff1a\u4e0d\u662f\u91cd\u513f\u5b50\uff0c\u5c31\u662f\u8f7b\u513f\u5b50  \n3\u3001\u91cd\u94fe\uff1a\u4e00\u6761\u5168\u90e8\u4ee5\u91cd\u513f\u5b50\u4e3a\u8282\u70b9\u7684\u8def\u5f84\uff0c\u9664\u4e86\u9876\u90e8\u4e3a\u8f7b\u513f\u5b50   \n\n\u6b64\u5904\u540d\u8bcd\u89e3\u91ca\u76f8\u5bf9\u5176\u5b83\u5f88\u591ablog\u6709\u6240\u7b80\u5316\uff0c\u4e0d\u8fc7\u4e0d\u5f71\u54cd\u9605\u8bfb\u3002  \n\u7eaf\u6587\u5b57\u7684\u63cf\u8ff0\u597d\u50cf\u4e0d\u592a\u65b9\u4fbf\uff0c\u90a3\u6211\u4eec\u62ff\u5f20\u56fe\u6765\uff1a  \n![](https://cdn.luogu.com.cn/upload/pic/45367.png)   \n\n\u56fe\u4e2d\uff0c\u91cd\u513f\u5b50\u3001\u91cd\u94fe\u90fd\u7528\u7ea2\u8272\u6807\u51fa\u6765\u4e86\u3002  \n\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0c\u5bf9\u4e8e\u8282\u70b9$1$\u6765\u8bf4\uff0c\u5b83\u7684\u513f\u5b50$2$\u53f7\u8282\u70b9\u5b50\u6811\u6700\u5927\uff0c\u56e0\u6b64$2$\u662f$1$\u7684\u91cd\u513f\u5b50\u3002  \n\u5bf9\u4e8e$2$\u53f7\u70b9\uff0c\u5b83\u7684\u513f\u5b50$6$\u53f7\u8282\u70b9\u5b50\u6811\u6700\u5927\uff0c\u56e0\u6b64$6$\u662f$2$\u7684\u91cd\u513f\u5b50\u3002  \n\u5bf9\u4e8e\u5176\u5b83\u8282\u70b9\u540c\u7406\u3002\u5982\u679c\u60f3\u52a0\u6df1\u5370\u8c61\uff0c\u53ef\u4ee5\u8bd5\u7740\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\u3002   \n\n\u63a5\u7740\u5c31\u662f\u91cd\u5934\u620f\u4e86\uff1a\u5982\u4f55\u4ee3\u7801\u5b9e\u73b0\u6811\u5256\n\n\u6811\u5256\u7684\u5b9e\u9645\u4e0a\u5c31\u662f\u4e24\u904d\u9884\u5904\u7406\uff0c\u7b2c\u4e00\u6b65\u8981\u7b97\u51fa\u4ee5\u4e0b\u6570\u636e\uff1a  \n\u5bf9\u4e8e\u4efb\u610f\u8282\u70b9$u$\u7684`\u6df1\u5ea6`\u3001`\u5b50\u6811\u5927\u5c0f`\u3001`\u91cd\u513f\u5b50\u7f16\u53f7`\u3001`\u7236\u8282\u70b9\u7f16\u53f7`\uff1b\u5206\u522b\u8bb0\u4e3a\uff1a$\\text{depth , size , son , fa}$  \n\u8fd9\u70b9\u7528\u4e00\u4e2a\u7b80\u5355\u7684dfs\u5c31\u53ef\u4ee5\u5b9e\u73b0\uff0c\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n)$  \n```cpp\nvoid dfs1(int u,int f){ //u\u4e3a\u5f53\u524d\u8282\u70b9\uff0cf\u4e3a\u7236\u8282\u70b9\n    fa[u] = f;\n    size[u] = 1; //\u5b50\u6811\u5927\u5c0f\u8981\u7b97\u4e0a\u5b50\u6811\u7684\u6839\u8282\u70b9\uff0c\u4e5f\u5c31\u662fu\n    depth[u] = depth[f]+1; //\u6bd4\u7236\u4eb2\u6df1\u5ea6\u59271\n    int v,t = -1,l = adj[u].size(); //\u6b64\u5904\u4f7f\u7528vector\u5b58\u56fe\n    for(int i=0;i<l;++i){ //\u904d\u5386\u8fde\u63a5u\u7684\u70b9v\n        v = adj[u][i];\n        if(v==f) continue;\n        dfs1(v,u);\n        size[u] += size[v];\n        if(size[v]>t){ \n        \t//\u5982\u679c\u8fd9\u4e2a\u5b50\u6811\u5927\u5c0f\u6bd4\u5df2\u627e\u5230\u7684\u8fd8\u5927\uff0c\u90a3\u5c31\u66f4\u65b0\u5df2\u627e\u5230\u7684\uff0c\u540c\u65f6\u66f4\u65b0u\u7684\u91cd\u513f\u5b50\u4e3av\n            t = size[v];\n            son[u] = v;\n        }\n    }\n}\n```  \n\n\u7b2c\u4e8c\u904d\u9884\u5904\u7406\uff0c\u5219\u9700\u8981\u8ba1\u7b97\uff1a  \n\u5bf9\u4e8e\u4efb\u610f\u8282\u70b9$u$\u7684`\u6240\u5728\u91cd\u94fe\u9876\u70b9`\uff0c`\u7b2c\u51e0\u4e2a\u88ab\u904d\u5386`\uff0c\u5206\u522b\u8bb0\u4e3a$\\text{top , id}$  \n\u65f6\u95f4\u590d\u6742\u5ea6\u4e5f\u662f\u7ebf\u6027\u7684\n```cpp\nvoid dfs2(int u,int f){ //\u8fd9\u91ccf\u5c31\u4e0d\u662f\u6307\u7236\u4eb2\u4e86\uff0c\u662fu\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u8282\u70b9\n    top[u] = f;\n    id[u] = ++cnt;\n    if(w[u]!=0)\n        add(id[u],id[u],w[u]); //\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u533a\u95f4\u548c\uff0cw[u]\u4e3au\u7684\u521d\u59cb\u6743\u503c\n    if(son[u]==0) return; //\u91cd\u513f\u5b50\u7f16\u53f7\u4e3a0\u610f\u5473\u7740\u6ca1\u6709\u513f\u5b50\uff0c\u8fd4\u56de\n    dfs2(son[u],f); //\u5148\u4ece\u91cd\u513f\u5b50\u5f00\u59cbdfs\uff0c\u8fd9\u6837\u53ef\u4ee5\u4f7f\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u8282\u70b9id\u8fde\u7eed\uff0c\u4fbf\u4e8e\u533a\u95f4\u64cd\u4f5c\n    int v,l = adj[u].size();\n    for(int i=0;i<l;++i){\n        v = adj[u][i];\n        if(v==son[u]||v==fa[u]) continue;\n        dfs2(v,v); //\u7531\u4e8e\u662f\u8f7b\u513f\u5b50\uff0c\u6240\u4ee5\u5176\u6240\u5728\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u81ea\u7136\u662f\u81ea\u5df1\n    }\n}\n```   \n~~\u7136\u540e\u4f60\u5c31\u5b66\u4f1a\u4e86\u6811\u5256~~  \n\u5e76\u4e0d\u662f\uff0c\u4f60\u8fd8\u9700\u8981\u5b9e\u73b0\u4fee\u6539\u548c\u67e5\u8be2\u3002  \n\u5728\u8003\u8651\u8fd9\u4e2a\u95ee\u9898\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u6765\u770b\u4e00\u4e0b\u521a\u624d\u9884\u5904\u7406\u7684\u6210\u679c\u5427\uff1a   \n\u73b0\u5728\u628a\u524d\u9762\u8d34\u7684\u56fe\u6539\u4e86\u4e00\u4e0b\uff0c\u9017\u53f7\u540e\u9762\u7684\u6570\u8868\u793a\u8fd9\u4e2a\u8282\u70b9\u7684$\\text{id}$    \n![](https://cdn.luogu.com.cn/upload/pic/45373.png)   \n\u6765\u770b\u4e00\u4e0b\u5404\u70b9\u7684$\\text{id}$\uff0c\u4f60\u53ef\u4ee5\u53d1\u73b0\u4e24\u4e2a\u6027\u8d28\uff1a  \n1\u3001\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9$\\text{id}$\u8fde\u7eed  \n2\u3001\u4e00\u68f5\u5b50\u6811\u4e0a\u7684\u70b9$\\text{id}$\u4e5f\u8fde\u7eed   \n\u63a5\u4e0b\u6765\u5c31\u8981\u5229\u7528\u8fd9\u4e2a\u6027\u8d28\u641e\u5b9a\u90a34\u4e2a\u64cd\u4f5c\u5566\uff01  \n\u6765\u770b\u7b2c\u4e00\u4e2a\u64cd\u4f5c\uff1a  \n>\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\u6211\u4eec\u53ef\u4ee5\u56de\u60f3\u4e00\u4e0b\u5f53\u521d\u500d\u589e\u6c42LCA\u7684\u65f6\u5019\uff0c\u662f\u600e\u4e48\u529e\u7684\uff1f  \n\u5c31\u662f\u4e24\u4e2a\u8282\u70b9\uff0c\u6df1\u5ea6\u5927\u7684\u5f80\u4e0a\u8df3\uff0c\u4e00\u76f4\u8df3\u5230\u7236\u4eb2\u76f8\u540c\u3002  \n\u8fd9\u91cc\u7684\u601d\u60f3\u4e5f\u548c\u6c42LCA\u5f88\u76f8\u4f3c\u3002   \n\u7531\u4e8e\u6bcf\u6761\u91cd\u94fe\u4e0a\u7684\u70b9$\\text{id}$\u8fde\u7eed\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u641e  \n```cpp\nadd(id[top[u]],id[u],k);\n```  \n\u5c31\u53ef\u4ee5\u628a$u$\u5230\u5176\u91cd\u94fe\u9876\u70b9\u7684\u8282\u70b9\u503c\u90fd$+k$  \n(\u8fd9\u91ccadd\u5c31\u662f\u533a\u95f4\u52a0\u64cd\u4f5c)  \n\u52a0\u5b8c\u4e86\u4e4b\u540e\uff0c\u6211\u4eec\u518d  \n```cpp\nu = fa[top[u]];\n```  \n\u8fd9\u6837\u5c31$u$\u8df3\u5230\u5176\u91cd\u94fe\u9876\u4e0a\u53bb\u4e86\u3002\u4e24\u4e2a\u8282\u70b9\u6309\u8fd9\u6837\u7684\u65b9\u5f0f\u4e0d\u65ad\u5411\u4e0a\u8df3\uff0c\u76f4\u5230\u4e00\u6761\u91cd\u94fe\u4e0a\u3002  \n\u4e8e\u662f\u64cd\u4f5c1\u5c31\u5b8c\u6210\u4e86\u3002\n```cpp\nvoid addPath(int u,int v,int k){\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])  \n            swap(u,v); //\u6df1\u5ea6\u5927\u7684\u70b9\u5148\u8df3\uff0c\u4fdd\u8bc1\u80fd\u8df3\u5230\u4e00\u6761\u91cd\u94fe\u4e0a\n        add(id[top[u]],id[u],k);    \n        u = fa[top[u]];\n    }\n    if(depth[u]>depth[v]) swap(u,v);\n    add(id[u],id[v],k); //\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u76f4\u63a5\u52a0\n}\n\n```\n\u64cd\u4f5c2\u53ea\u662f\u5927\u540c\u5c0f\u5f02\uff0c\u533a\u95f4\u4fee\u6539\u53d8\u6210\u4e86\u533a\u95f4\u67e5\u8be2\u800c\u5df2\u3002  \n```cpp\nint queryPath(int u,int v){\n    int res = 0;\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])\n            swap(u,v);\n        res += query(id[top[u]],id[u]);\n        u = fa[top[u]];\n    }\n    if(depth[u]>depth[v]) swap(u,v);\n    res += query(id[u],id[v]);\n    return res;\n}\n```   \n\u63a5\u4e0b\u6765\u770b\u64cd\u4f5c3\uff1a  \n\n>\u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\n\n\u5173\u4e8e\u5b50\u6811\u7684\u64cd\u4f5c\u5176\u5b9e\u975e\u5e38\u7b80\u5355\u3002  \n\u9898\u76ee\u7684\u4fee\u6539\u548c\u67e5\u8be2\u90fd\u662f\u5bf9\u6574\u4e2a\u5b50\u6811\u7684\u3002\u53c8\u7531\u4e8e\u5b50\u6811\u7684\u8282\u70b9$\\text{id}$\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u8be5\u600e\u4e48\u529e\u5df2\u7ecf\u5f88\u6e05\u695a\u4e86\u5427\u3002  \n\u4fee\u6539\u548c\u67e5\u8be2\u4f9d\u7136\u5f88\u76f8\u4f3c\uff0c\u76f4\u63a5\u653e\u5728\u4e00\u8d77\u8d34\u51fa\u6765\uff1a\n```cpp\nint querySon(int u){\n    return query(id[u],id[u]+size[u]-1);\n    //id[u]\u5230id[u]+size[u]-1\u521a\u597d\u6db5\u76d6\u4e86u\u7684\u6240\u6709\u5b50\u8282\u70b9id\uff0c\u4e0b\u540c\n}\n\nvoid addSon(int u,int k){\n    add(id[u],id[u]+size[u]-1,k);\n}\n```   \n\n\u7136\u540e\u8fd9\u9898\u4ee3\u7801\u5c31\u51fa\u6765\u4e86\uff0c\u4f46\u662f\u9898\u76ee\u4e2d\u591a\u4e86\u4e2a\u53d6\u6a21\uff0c\u6ce8\u610f\u8981\u52a0\u4e0a\u3002  \n\u603b\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n\\log^2 n)$\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<queue>\n#define N 100003\n#define inf 0x3f3f3f3f\n#define ll long long\nusing namespace std;\n\nvector<int> adj[N];\nint n,m,r,p,cnt;\nint son[N],depth[N],fa[N],size[N];\nint id[N],top[N],w[N];\nll c1[N],c2[N];\n\n//\u4ee5\u4e0b\u4e3a\u6811\u72b6\u6570\u7ec4\ninline int lowbit(int x){\n    return x&(-x);\n}\n\ninline void add(int l,int r,int x){\n    x %= p;\n    int ad1 = (ll)(l-1)*x%p;\n    int ad2 = (ll)r*x%p;\n    for(int t=l;t<=n;t+=lowbit(t)){\n        c1[t] = (c1[t]+x)%p;\n        c2[t] = (c2[t]+ad1)%p;\n    }\n    for(int t=r+1;t<=n;t+=lowbit(t)){\n        c1[t] = (c1[t]-x)%p;\n        c1[t] = (c1[t]+p)%p;\n        c2[t] = (c2[t]-ad2)%p;\n        c2[t] = (c2[t]+p)%p;\n    }\n}\n\ninline int qwq(int i){ //qwq\n    int res = 0;\n    for(int t=i;t>0;t-=lowbit(t)){\n        res = (res+(ll)i*c1[t]%p)%p;\n        res = (res-c2[t])%p;\n        res = (res+p)%p;\n    }\n    return res;\n}\n\ninline int query(int l,int r){\n    int res = (qwq(r)-qwq(l-1))%p;\n    return (res+p)%p;\n}\n//\u4ee5\u4e0a\u6811\u72b6\u6570\u7ec4\n\ninline void read(int &x){\n    x = 0;\n    char c = getchar();\n    while(c<'0'||c>'9') c = getchar();\n    while(c>='0'&&c<='9'){\n        x = (x<<3)+(x<<1)+(c^48);\n        c = getchar();\n    }\n}\n\nvoid print(int x){\n    if(x>9) print(x/10);\n    putchar(x%10+'0');\n}\n\nvoid dfs1(int u,int f){\n    fa[u] = f;\n    size[u] = 1;\n    depth[u] = depth[f]+1;\n    int v,t = -1,l = adj[u].size();\n    for(int i=0;i<l;++i){\n        v = adj[u][i];\n        if(v==f) continue;\n        dfs1(v,u);\n        size[u] += size[v];\n        if(size[v]>t){\n            t = size[v];\n            son[u] = v;\n        }\n    }\n}\n\nvoid dfs2(int u,int f){\n    top[u] = f;\n    id[u] = ++cnt;\n    if(w[u]!=0)\n        add(id[u],id[u],w[u]);\n    if(son[u]==0) return;\n    dfs2(son[u],f);\n    int v,l = adj[u].size();\n    for(int i=0;i<l;++i){\n        v = adj[u][i];\n        if(v==son[u]||v==fa[u]) continue;\n        dfs2(v,v);\n    }\n}\n\nint queryPath(int u,int v){\n    int res = 0;\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])\n            swap(u,v);\n        res = (res+query(id[top[u]],id[u]))%p;\n        u = fa[top[u]];\n    }\n    if(depth[u]>depth[v]) swap(u,v);\n    res = (res+query(id[u],id[v]))%p;\n    return res;\n}\n\nvoid addPath(int u,int v,int k){\n    k %= p;\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])\n            swap(u,v);\n        add(id[top[u]],id[u],k);    \n        u = fa[top[u]];\n    }\n    if(depth[u]>depth[v]) swap(u,v);\n    add(id[u],id[v],k);\n}\n\nint querySon(int u){\n    return query(id[u],id[u]+size[u]-1);\n}\n\nvoid addSon(int u,int k){\n    k %= p;\n    add(id[u],id[u]+size[u]-1,k);\n}\n\nint main(){\n    int u,v;\n    read(n),read(m),read(r),read(p);\n    for(int i=1;i<=n;++i)\n        read(w[i]);\n    for(int i=1;i<n;++i){\n        read(u),read(v);\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }    \n    dfs1(r,0);\n    dfs2(r,r);\n    int ans,op,x,y,z;\n    while(m--){\n        read(op),read(x);\n        if(op==1){\n            read(y),read(z);\n            addPath(x,y,z);\n            continue;\n        }\n        if(op==2){\n            read(y);\n            ans = queryPath(x,y);\n            print(ans);\n            putchar('\\n');\n            continue;\n        }\n        if(op==3){\n            read(z);\n            addSon(x,z);\n            continue;\n        }\n        ans = querySon(x);\n        print(ans);\n        putchar('\\n');\n    }\n    return 0;\n}\n```   \n\u6b64\u5916\uff0c\u6811\u5256\u8fd8\u53ef\u4ee5\u7528\u6765\u6c42LCA\uff0c\u4ee3\u7801\u6bd4\u500d\u589e\u6cd5\u77ed\u5f88\u591a\uff1a  \n```cpp\ninline int lca(int u,int v){\n\twhile(top[u]!=top[v]){\n    \tif(depth[top[u]]<depth[top[v]])\n        \tswap(u,v);\n        u = fa[top[u]];    \n    }\n    if(depth[u]<depth[v]) return u;\n    return v;\n}\n```\n~~\u662f\u4e0d\u662f\u8d85\u7ea7\u7b80\u5355~~  ",
        "postTime": 1544021422,
        "uid": 115864,
        "name": "NaCly_Fish",
        "ccfLevel": 6,
        "title": "\u6811\u94fe\u5256\u5206\u826f\u5fc3\u8bb2\u89e3"
    },
    {
        "content": "** _\u8f6c\u8f7d\u8bf7\u6ce8\u660e\u51fa\u5904\uff0c\u90e8\u5206\u5185\u5bb9\u5f15\u81ea[banananana\u5927\u795e\u7684\u535a\u5ba2](https://www.cnblogs.com/George1994/p/7821357.html)_ **\n\n------------\n~~\u522b\u8bf4\u4f60\u4e0d\u77e5\u9053\u4ec0\u4e48\u662f\u6811~~\u256e(\u2500\u25bd\u2500)\u256d\uff08[\u5e2e\u4f60\u767e\u5ea6\u4e00\u4e0b](https://baike.baidu.com/item/%E6%A0%91/2699484?fr=aladdin)\uff09\n\n------------\n### \u5148\u6765\u56de\u987e\u4e24\u4e2a\u95ee\u9898\uff1a\n1\uff0c\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\u8fd9\u4e5f\u662f\u4e2a\u6a21\u677f\u9898\u4e86\u5427\n\n\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u6811\u4e0a\u5dee\u5206\u53ef\u4ee5\u4ee5O(n+m)\u7684\u4f18\u79c0\u590d\u6742\u5ea6\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\n\n2\uff0c\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\nlca\u5927\u6c34\u9898\uff0c\u6211\u4eec\u53c8\u5f88\u5bb9\u6613\u5730\u60f3\u5230\uff0cdfs O(n)\u9884\u5904\u7406\u6bcf\u4e2a\u8282\u70b9\u7684dis\uff08\u5373\u5230\u6839\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u957f\u5ea6\uff09\n\n\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u6c42\u51fax,y\u4e24\u70b9\u7684lca\uff0c\u5229\u7528lca\u7684\u6027\u8d28 **$distance ( x , y ) = dis ( x ) + dis ( y ) - 2 * dis ( lca )$** \u6c42\u51fa\u7ed3\u679c\n\n\u65f6\u95f4\u590d\u6742\u5ea6O(mlogn+n)\n#### \u73b0\u5728\u6765\u601d\u8003\u4e00\u4e2abug\uff1a\n\u5982\u679c\u521a\u624d\u7684\u4e24\u4e2a\u95ee\u9898\u7ed3\u5408\u8d77\u6765\uff0c\u6210\u4e3a\u4e00\u9053\u9898\u7684\u4e24\u79cd\u64cd\u4f5c\u5462\uff1f\n\n\u521a\u624d\u7684\u65b9\u6cd5\u663e\u7136\u5c31\u4e0d\u591f\u4f18\u79c0\u4e86\uff08\u6bcf\u6b21\u8be2\u95ee\u4e4b\u524d\u8981\u8dd1dfs\u66f4\u65b0dis\uff09\n\n------------\n### \u6811\u94fe\u5256\u5206\u534e\u4e3d\u767b\u573a\n\u6811\u5256\u662f\u901a\u8fc7\u8f7b\u91cd\u8fb9\u5256\u5206\u5c06\u6811\u5206\u5272\u6210\u591a\u6761\u94fe\uff0c\u7136\u540e\u5229\u7528\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4\u8fd9\u4e9b\u94fe\uff08\u672c\u8d28\u4e0a\u662f\u4e00\u79cd\u4f18\u5316\u66b4\u529b\uff09\n\n### \u9996\u5148\u660e\u786e\u6982\u5ff5\uff1a\n\n\u91cd\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u7684\u6240\u6709\u513f\u5b50\u4e2d\u5b50\u6811\u7ed3\u70b9\u6570\u76ee\u6700\u591a\uff08size\u6700\u5927\uff09\u7684\u7ed3\u70b9\uff1b\n\n\u8f7b\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u4e2d\u9664\u4e86\u91cd\u513f\u5b50\u4ee5\u5916\u7684\u513f\u5b50\uff1b\n\n\u91cd\u8fb9\uff1a\u7236\u4eb2\u7ed3\u70b9\u548c\u91cd\u513f\u5b50\u8fde\u6210\u7684\u8fb9\uff1b\n\n\u8f7b\u8fb9\uff1a\u7236\u4eb2\u8282\u70b9\u548c\u8f7b\u513f\u5b50\u8fde\u6210\u7684\u8fb9\uff1b\n\n\u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\uff1b\n\n\u8f7b\u94fe\uff1a\u7531\u591a\u6761\u8f7b\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\uff1b\n\n![](https://cdn.luogu.com.cn/upload/pic/18881.png )\n\n\u6bd4\u5982\u4e0a\u9762\u8fd9\u5e45\u56fe\u4e2d\uff0c\u7528\u9ed1\u7ebf\u8fde\u63a5\u7684\u7ed3\u70b9\u90fd\u662f\u91cd\u7ed3\u70b9\uff0c\u5176\u4f59\u5747\u662f\u8f7b\u7ed3\u70b9\uff0c\n\n2-11\u5c31\u662f\u91cd\u94fe\uff0c2-5\u5c31\u662f\u8f7b\u94fe\uff0c\u7528\u7ea2\u70b9\u6807\u8bb0\u7684\u5c31\u662f\u8be5\u7ed3\u70b9\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9\uff0c\u4e5f\u5c31\u662f\u4e0b\u6587\u63d0\u5230\u7684top\u7ed3\u70b9\uff0c\n\n\u8fd8\u6709\u6bcf\u6761\u8fb9\u7684\u503c\u5176\u5b9e\u662f\u8fdb\u884cdfs\u65f6\u7684\u6267\u884c\u5e8f\u53f7\u3002\n#### \u53d8\u91cf\u58f0\u660e\uff1a\n```\nconst int maxn=1e5+10;\nstruct edge{\n\tint next,to;\n}e[2*maxn];\nstruct Node{\n    int sum,lazy,l,r,ls,rs;\n}node[2*maxn];\nint rt,n,m,r,a[maxn],cnt,head[maxn],f[maxn],d[maxn],size[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];\n```\n|  |  |\n| :----------: | :----------: |\n| \u540d\u79f0 | \u89e3\u91ca |\n| $f[u]$ | \u4fdd\u5b58\u7ed3\u70b9u\u7684\u7236\u4eb2\u8282\u70b9 |\n| $d[u]$ | \u4fdd\u5b58\u7ed3\u70b9u\u7684\u6df1\u5ea6\u503c |\n| $size[u]$ | \u4fdd\u5b58\u4ee5u\u4e3a\u6839\u7684\u5b50\u6811\u8282\u70b9\u4e2a\u6570 |\n| $son[u]$ | \t\u4fdd\u5b58\u91cd\u513f\u5b50 |\n| $rk[u]$ | \u4fdd\u5b58\u5f53\u524ddfs\u6807\u53f7\u5728\u6811\u4e2d\u6240\u5bf9\u5e94\u7684\u8282\u70b9 |\n| $top[u]$ | \u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aef\u8282\u70b9 |\n| $id[u]$ | \u4fdd\u5b58\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9\u5256\u5206\u4ee5\u540e\u7684\u65b0\u7f16\u53f7\uff08DFS\u7684\u6267\u884c\u987a\u5e8f\uff09 |\n## \u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\uff08\u6811\u94fe\u5256\u5206\u7684\u5b9e\u73b0\uff09\uff1a\n### 1\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u6211\u4eec\u9996\u5148\u6c42\u51fa\u5b83\u6240\u5728\u7684\u5b50\u6811\u5927\u5c0f,\u627e\u5230\u5b83\u7684\u91cd\u513f\u5b50\uff08\u5373\u5904\u7406\u51fa$size,son$\u6570\u7ec4\uff09\uff0c\n\u89e3\u91ca:\u6bd4\u5982\u8bf4\u70b91\uff0c\u5b83\u6709\u4e09\u4e2a\u513f\u5b502\uff0c3\uff0c4\n\n2\u6240\u5728\u5b50\u6811\u7684\u5927\u5c0f\u662f5\n\n3\u6240\u5728\u5b50\u6811\u7684\u5927\u5c0f\u662f2\n\n4\u6240\u5728\u5b50\u6811\u7684\u5927\u5c0f\u662f6\n\n\u90a3\u4e481\u7684\u91cd\u513f\u5b50\u662f4\n\nps:\u5982\u679c\u4e00\u4e2a\u70b9\u7684\u591a\u4e2a\u513f\u5b50\u6240\u5728\u5b50\u6811\u5927\u5c0f\u76f8\u7b49\u4e14\u6700\u5927\n\n\u90a3\u968f\u4fbf\u627e\u4e00\u4e2a\u5f53\u505a\u5b83\u7684\u91cd\u513f\u5b50\u5c31\u597d\u4e86\n\n\u53f6\u8282\u70b9\u6ca1\u6709\u91cd\u513f\u5b50\uff0c\u975e\u53f6\u8282\u70b9\u6709\u4e14\u53ea\u6709\u4e00\u4e2a\u91cd\u513f\u5b50\n### 2\uff0c\u5728dfs\u8fc7\u7a0b\u4e2d\u987a\u4fbf\u8bb0\u5f55\u5176\u7236\u4eb2\u4ee5\u53ca\u6df1\u5ea6\uff08\u5373\u5904\u7406\u51fa$f,d$\u6570\u7ec4\uff09\uff0c\u64cd\u4f5c1,2\u53ef\u4ee5\u901a\u8fc7\u4e00\u904ddfs\u5b8c\u6210\n```\nvoid dfs1(int u,int fa,int depth)\t//\u5f53\u524d\u8282\u70b9\u3001\u7236\u8282\u70b9\u3001\u5c42\u6b21\u6df1\u5ea6\n{\n\tf[u]=fa;\n\td[u]=depth;\n\tsize[u]=1;\t//\u8fd9\u4e2a\u70b9\u672c\u8eabsize=1\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==fa)\n\t\t\tcontinue;\n\t\tdfs1(v,u,depth+1);\t//\u5c42\u6b21\u6df1\u5ea6+1\n\t\tsize[u]+=size[v];\t//\u5b50\u8282\u70b9\u7684size\u5df2\u88ab\u5904\u7406\uff0c\u7528\u5b83\u6765\u66f4\u65b0\u7236\u8282\u70b9\u7684size\n\t\tif(size[v]>size[son[u]])\n\t\t\tson[u]=v;\t//\u9009\u53d6size\u6700\u5927\u7684\u4f5c\u4e3a\u91cd\u513f\u5b50\n\t}\n}\n//\u8fdb\u5165\ndfs1(root,0,1);\n```\n![](https://cdn.luogu.com.cn/upload/pic/18890.png )\ndfs\u8dd1\u5b8c\u5927\u6982\u662f\u8fd9\u6837\u7684\uff0c\u5927\u5bb6\u53ef\u4ee5\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\n### 3\uff0c\u7b2c\u4e8c\u904ddfs\uff0c\u7136\u540e\u8fde\u63a5\u91cd\u94fe\uff0c\u540c\u65f6\u6807\u8bb0\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684dfs\u5e8f\uff0c\u5e76\u4e14\u4e3a\u4e86\u7528\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4\u91cd\u94fe\uff0c\u6211\u4eec\u5728dfs\u65f6\u4fdd\u8bc1\u4e00\u6761\u91cd\u94fe\u4e0a\u5404\u4e2a\u8282\u70b9dfs\u5e8f\u8fde\u7eed\uff08\u5373\u5904\u7406\u51fa\u6570\u7ec4$top,id,rk$\uff09\n```\nvoid dfs2(int u,int t)\t//\u5f53\u524d\u8282\u70b9\u3001\u91cd\u94fe\u9876\u7aef\n{\n\ttop[u]=t;\n\tid[u]=++cnt;\t//\u6807\u8bb0dfs\u5e8f\n\trk[cnt]=u;\t//\u5e8f\u53f7cnt\u5bf9\u5e94\u8282\u70b9u\n\tif(!son[u])\n\t\treturn;\n\tdfs2(son[u],t);\n/*\u6211\u4eec\u9009\u62e9\u4f18\u5148\u8fdb\u5165\u91cd\u513f\u5b50\u6765\u4fdd\u8bc1\u4e00\u6761\u91cd\u94fe\u4e0a\u5404\u4e2a\u8282\u70b9dfs\u5e8f\u8fde\u7eed\uff0c\n\u4e00\u4e2a\u70b9\u548c\u5b83\u7684\u91cd\u513f\u5b50\u5904\u4e8e\u540c\u4e00\u6761\u91cd\u94fe\uff0c\u6240\u4ee5\u91cd\u513f\u5b50\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u8fd8\u662ft*/\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v!=son[u]&&v!=f[u])\n\t\t\tdfs2(v,v);\t//\u4e00\u4e2a\u70b9\u4f4d\u4e8e\u8f7b\u94fe\u5e95\u7aef\uff0c\u90a3\u4e48\u5b83\u7684top\u5fc5\u7136\u662f\u5b83\u672c\u8eab\n\t}\n}\n```\n![](https://cdn.luogu.com.cn/upload/pic/18906.png )\ndfs\u8dd1\u5b8c\u5927\u6982\u662f\u8fd9\u6837\u7684\uff0c\u5927\u5bb6\u53ef\u4ee5\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\n### 4\uff0c\u4e24\u904ddfs\u5c31\u662f\u6811\u94fe\u5256\u5206\u7684\u4e3b\u8981\u5904\u7406\uff0c\u901a\u8fc7dfs\u6211\u4eec\u5df2\u7ecf\u4fdd\u8bc1\u4e00\u6761\u91cd\u94fe\u4e0a\u5404\u4e2a\u8282\u70b9dfs\u5e8f\u8fde\u7eed\uff0c\u90a3\u4e48\u53ef\u4ee5\u60f3\u5230\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6570\u636e\u7ed3\u6784\uff08\u4ee5\u7ebf\u6bb5\u6811\u4e3a\u4f8b\uff09\u6765\u7ef4\u62a4\u4e00\u6761\u91cd\u94fe\u7684\u4fe1\u606f\n#### \u56de\u987e\u4e0a\u6587\u7684\u90a3\u4e2a\u9898\u76ee\uff0c\u4fee\u6539\u548c\u67e5\u8be2\u64cd\u4f5c\u539f\u7406\u662f\u7c7b\u4f3c\u7684\uff0c\u4ee5\u67e5\u8be2\u64cd\u4f5c\u4e3a\u4f8b\uff0c\u5176\u5b9e\u5c31\u662f\u4e2aLCA\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u4f7f\u7528\u4e86top\u6765\u8fdb\u884c\u52a0\u901f\uff0c\u56e0\u4e3atop\u53ef\u4ee5\u76f4\u63a5\u8df3\u8f6c\u5230\u8be5\u91cd\u94fe\u7684\u8d77\u59cb\u7ed3\u70b9\uff0c\u8f7b\u94fe\u6ca1\u6709\u8d77\u59cb\u7ed3\u70b9\u4e4b\u8bf4\uff0c\u4ed6\u4eec\u7684top\u5c31\u662f\u81ea\u5df1\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u6b21\u5faa\u73af\u53ea\u80fd\u8df3\u4e00\u6b21\uff0c\u5e76\u4e14\u8ba9\u7ed3\u70b9\u6df1\u7684\u90a3\u4e2a\u6765\u8df3\u5230top\u7684\u4f4d\u7f6e\uff0c\u907f\u514d\u4e24\u4e2a\u4e00\u8d77\u8df3\u4ece\u800c\u64e6\u80a9\u800c\u8fc7\u3002\n```\nint sum(int x,int y)\n{\n\tint ans=0,fx=top[x],fy=top[y];\n\twhile(fx!=fy)\t//\u4e24\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\n\t{\n\t\tif(d[fx]>=d[fy])\n\t\t{\n\t\t\tans+=query(id[fx],id[x],rt);\t//\u7ebf\u6bb5\u6811\u533a\u95f4\u6c42\u548c\uff0c\u5904\u7406\u8fd9\u6761\u91cd\u94fe\u7684\u8d21\u732e\n\t\t\tx=f[fx],fx=top[x];\t//\u5c06x\u8bbe\u7f6e\u6210\u539f\u94fe\u5934\u7684\u7236\u4eb2\u7ed3\u70b9\uff0c\u8d70\u8f7b\u8fb9\uff0c\u7ee7\u7eed\u5faa\u73af\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=query(id[fy],id[y],rt);\n\t\t\ty=f[fy],fy=top[y];\n\t\t}\n\t}\n    //\u5faa\u73af\u7ed3\u675f\uff0c\u4e24\u70b9\u4f4d\u4e8e\u540c\u4e00\u91cd\u94fe\u4e0a\uff0c\u4f46\u4e24\u70b9\u4e0d\u4e00\u5b9a\u4e3a\u540c\u4e00\u70b9\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u8981\u7edf\u8ba1\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u8d21\u732e\n\tif(id[x]<=id[y])\n\t\tans+=query(id[x],id[y],rt);\n\telse\n\t\tans+=query(id[y],id[x],rt);\n\treturn ans;\n}\n```\n\u5927\u5bb6\u5982\u679c\u660e\u767d\u4e86\u6811\u94fe\u5256\u5206\uff0c\u4e5f\u5e94\u8be5\u6709\u4e3e\u4e00\u53cd\u4e09\u7684\u80fd\u529b~~\uff08\u53cd\u6b63\u6211\u6ca1\u6709\uff09~~\uff0c\u4fee\u6539\u548cLCA\u5c31\u7559\u7ed9\u5927\u5bb6\u81ea\u5df1\u5b8c\u6210\u4e86\n### 5\uff0c\u6811\u94fe\u5256\u5206\u7684\u65f6\u95f4\u590d\u6742\u5ea6\n\u6811\u94fe\u5256\u5206\u7684\u4e24\u4e2a\u6027\u8d28\uff1a\n\n1\uff0c\u5982\u679c$(u, v)$\u662f\u4e00\u6761\u8f7b\u8fb9\uff0c\u90a3\u4e48$size(v) < size(u)/2$\uff1b\n\n2\uff0c\u4ece\u6839\u7ed3\u70b9\u5230\u4efb\u610f\u7ed3\u70b9\u7684\u8def\u6240\u7ecf\u8fc7\u7684\u8f7b\u91cd\u94fe\u7684\u4e2a\u6570\u5fc5\u5b9a\u90fd\u5c0f\u4e8e$logn$\uff1b\n\n\u53ef\u4ee5\u8bc1\u660e\uff0c\u6811\u94fe\u5256\u5206\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$\\mathcal{O(nlogn)}$\n## \u51e0\u9053\u4f8b\u9898\uff1a\n### 1\uff0c[\u6811\u94fe\u5256\u5206\u6a21\u677f](https://www.luogu.org/problemnew/show/P3384)\n\u5c31\u662f\u521a\u624d\u8bb2\u7684\n\n#### \u4e0a\u4ee3\u7801\uff1a\n```\n#include<iostream>\n#include<cstdio>\n#define int long long\nusing namespace std;\nconst int maxn=1e5+10;\nstruct edge{\n    int next,to;\n}e[2*maxn];\nstruct Node{\n    int sum,lazy,l,r,ls,rs;\n}node[2*maxn];\nint rt,n,m,r,p,a[maxn],cnt,head[maxn],f[maxn],d[maxn],size[maxn],son[maxn],rk[maxn],top[maxn],id[maxn];\nint mod(int a,int b)\n{\n    return (a+b)%p;\n}\nvoid add_edge(int x,int y)\n{\n    e[++cnt].next=head[x];\n    e[cnt].to=y;\n    head[x]=cnt;\n}\nvoid dfs1(int u,int fa,int depth)\n{\n    f[u]=fa;\n    d[u]=depth;\n    size[u]=1;\n    for(int i=head[u];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v==fa)\n            continue;\n        dfs1(v,u,depth+1);\n        size[u]+=size[v];\n        if(size[v]>size[son[u]])\n            son[u]=v;\n    }\n}\nvoid dfs2(int u,int t)\n{\n    top[u]=t;\n    id[u]=++cnt;\n    rk[cnt]=u;\n    if(!son[u])\n        return;\n    dfs2(son[u],t);\n    for(int i=head[u];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v!=son[u]&&v!=f[u])\n            dfs2(v,v);\n    }\n}\nvoid pushup(int x)\n{\n    node[x].sum=(node[node[x].ls].sum+node[node[x].rs].sum+node[x].lazy*(node[x].r-node[x].l+1))%p;\n}\nvoid build(int li,int ri,int cur)\n{\n    if(li==ri)\n    {\n        node[cur].l=node[cur].r=li;\n        node[cur].sum=a[rk[li]];\n        return;\n    }\n    int mid=(li+ri)>>1;\n    node[cur].ls=cnt++;\n    node[cur].rs=cnt++;\n    build(li,mid,node[cur].ls);\n    build(mid+1,ri,node[cur].rs);\n    node[cur].l=node[node[cur].ls].l;\n    node[cur].r=node[node[cur].rs].r;\n    pushup(cur);\n}\nvoid update(int li,int ri,int c,int cur)\n{\n    if(li<=node[cur].l&&node[cur].r<=ri)\n    {\n        node[cur].sum=mod(node[cur].sum,c*(node[cur].r-node[cur].l+1));\n        node[cur].lazy=mod(node[cur].lazy,c);\n        return;\n    }\n    int mid=(node[cur].l+node[cur].r)>>1;\n    if(li<=mid)\n        update(li,ri,c,node[cur].ls);\n    if(mid<ri)\n        update(li,ri,c,node[cur].rs);\n    pushup(cur);\n}\nint query(int li,int ri,int cur)\n{\n    if(li<=node[cur].l&&node[cur].r<=ri)\n        return node[cur].sum;\n    int tot=node[cur].lazy*(min(node[cur].r,ri)-max(node[cur].l,li)+1)%p;\n    int mid=(node[cur].l+node[cur].r)>>1;\n    if(li<=mid)\n        tot=mod(tot,query(li,ri,node[cur].ls));\n    if(mid<ri)\n        tot=mod(tot,query(li,ri,node[cur].rs));\n    return tot%p;\n}\nint sum(int x,int y)\n{\n    int ans=0;\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(d[fx]>=d[fy])\n        {\n            ans=mod(ans,query(id[fx],id[x],rt));\n            x=f[fx],fx=top[x];\n        }\n        else\n        {\n            ans=mod(ans,query(id[fy],id[y],rt));\n            y=f[fy],fy=top[y];\n        }\n    }\n    if(id[x]<=id[y])\n        ans=mod(ans,query(id[x],id[y],rt));\n    else\n        ans=mod(ans,query(id[y],id[x],rt));\n    return ans%p;\n}\nvoid updates(int x,int y,int c)\n{\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(d[fx]>=d[fy])\n        {\n            update(id[fx],id[x],c,rt);\n            x=f[fx],fx=top[x];\n        }\n        else\n        {\n            update(id[fy],id[y],c,rt);\n            y=f[fy],fy=top[y];\n        }\n    }\n    if(id[x]<=id[y])\n        update(id[x],id[y],c,rt);\n    else\n        update(id[y],id[x],c,rt);\n}\nsigned main()\n{\n    scanf(\"%d%d%d%d\",&n,&m,&r,&p);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        add_edge(x,y);\n        add_edge(y,x);\n    }\n    cnt=0;\n    dfs1(r,0,1);\n    dfs2(r,r);\n    cnt=0;\n    rt=cnt++;\n    build(1,n,rt);\n    for(int i=1;i<=m;i++)\n    {\n        int op,x,y,z;\n        scanf(\"%lld\",&op);\n        if(op==1)\n        {\n            scanf(\"%lld%lld%lld\",&x,&y,&z);\n            updates(x,y,z);\n        }\n        else if(op==2)\n        {\n            scanf(\"%lld%lld\",&x,&y);\n            printf(\"%lld\\n\",sum(x,y));\n        }\n        else if(op==3)\n        {\n            scanf(\"%lld%lld\",&x,&z);\n            //\u5b50\u6811\u4e5f\u6709\u8fde\u7eed\u533a\u95f4\u7684\u6027\u8d28\n            update(id[x],id[x]+size[x]-1,z,rt);\n        }\n        else if(op==4)\n        {\n            scanf(\"%lld\",&x);\n            printf(\"%lld\\n\",query(id[x],id[x]+size[x]-1,rt));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1525857127,
        "uid": 57045,
        "name": "communist",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u6211\u4eec\u6240\u5e38\u8bf4\u7684\u6811\u94fe\u5256\u5206\u5176\u5b9e\u662f\u8f7b\u91cd\u94fe\u5256\u5206  \n\u6811\u94fe\u5256\u5206\u53ef\u4ee5\u5904\u7406\u6811\u4e0a\u7684\u4efb\u610f\u4e24\u70b9\u95f4\u8def\u5f84\u548c\u4efb\u610f\u4e00\u70b9\u5b50\u6811\u7684\u4fe1\u606f\u4fee\u6539\u4e0e\u67e5\u8be2(\u914d\u5408\u7ebf\u6bb5\u6811)  \n\n## 0.\u524d\u8a00\n\u8981\u5148\u5b66\u4f1a[\u7ebf\u6bb5\u6811](https://www.luogu.org/problem/P3372)\u548c[LCA](https://www.luogu.org/problem/P3379)  \n~~\u5426\u5219\u6709\u7684\u672f\u8bed\u770b\u4e0d\u61c2~~\n\n\u9996\u5148\u6ce8\u610f\u4e0b\u6587\u4e2d\u6743\u503c\u662f\u8d4b\u5728\u70b9\u4e0a\u7684 \u800c\u4e0d\u662f\u5728\u8fb9\u4e0a  \n\u5982\u679c\u9047\u5230\u6743\u503c\u5728\u8fb9\u4e0a\u7684\u60c5\u51b5 \u628a\u6743\u503c\u8d4b\u7ed9\u8fd9\u6761\u8fb9\u8fde\u63a5\u7684\u4e24\u70b9\u4e2d\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u70b9\u5373\u53ef  \n\n## 1.\u5f15\u5165  \n\u7ebf\u6bb5\u6811\u662f\u901a\u8fc7\u7ef4\u62a4\u4e00\u4e9b\u533a\u95f4 \u5e76\u4e14\u628a\u5f85\u5904\u7406\u533a\u95f4\u62c6\u5206\u6210\u4e00\u5b9a\u6570\u91cf\u4e2a\u7ef4\u62a4\u7684\u533a\u95f4  \n\u6811\u94fe\u5256\u5206\u601d\u60f3\u76f8\u4f3c \u5c06\u6811\u5256\u5206\u6210$logn$\u7ea7\u522b\u6761**\u4e92\u76f8\u4e0d\u76f8\u4ea4\u7684\u94fe** \u540c\u65f6\u4fdd\u8bc1\u6bcf\u4e00\u4e2a\u70b9\u90fd**\u5728\u4e14\u4ec5\u5728\u4e00\u6761\u94fe\u4e0a**(\u6240\u6709\u94fe\u53ef\u4ee5\u8986\u76d6\u6240\u6709\u70b9) \u5bf9\u4e8e\u6bcf\u4e00\u6761\u8def\u5f84\u53ef\u4ee5\u5c06\u5176\u62c6\u5206\u6210$logn$\u7ea7\u522b\u6761\u94fe\u5206\u522b\u7ef4\u62a4\u94fe\u4e0a\u70b9\u6743  \n\u94fe\u5c31\u662f\u4e00\u4e9b\u70b9 \u8fd9\u4e9b\u70b9\u9996\u5c3e\u76f8\u63a5 \u9664\u4e86\u4e24\u7aef\u7684\u70b9\u53ea\u6709\u4e00\u4e2a\u70b9\u4e0e\u4e4b\u76f8\u8fde \u5176\u4ed6\u7684\u70b9\u90fd\u6709\u4e24\u70b9\u4e0e\u4e4b\u6709\u8fb9\u76f8\u8fde   \n\u5728\u8fd9\u91cc\u7684\u94fe\u4e2d \u94fe\u7ef4\u62a4\u4e00\u4e9b\u6df1\u5ea6\u9012\u589e\u7684\u70b9 \u6ca1\u6709\u4efb\u610f\u4e24\u70b9\u5728\u6811\u4e2d\u6df1\u5ea6\u76f8\u540c  \n~~\u5b50\u6811\u7684\u95ee\u9898\u5728\u540e\u6587\u63d0\u5230~~  \n\n## 2.\u601d\u60f3  \n\u5982\u679c\u5c06\u4e00\u6761\u5f88\u957f\u7684\u94fe\u4e00\u8d77\u5904\u7406 \u53ef\u4ee5\u4f18\u5316\u6548\u7387  \n\u4e3a\u4e86\u4f7f\u5f97\u94fe\u4e0e\u94fe\u4e0d\u76f8\u4ea4 \u5fc5\u5b9a\u6709\u4e00\u4e9b\u8fb9\u4e0d\u80fd\u5728\u94fe\u4e2d \u6211\u4eec\u628a\u8fd9\u4e9b\u8fb9\u6210\u4e3a**\u8f7b\u8fb9** \u56e0\u4e3a\u8fd9\u6837\u7684\u8fb9\u4e0d\u4f1a\u5f88\u591a \u9047\u5230\u65f6\u76f4\u63a5\u5904\u7406\u5c31\u884c\u4e86  \n\u4e8e\u662f\u6211\u4eec\u901a\u8fc7\u4e00\u5b9a\u5f62\u5f0f\u5c06\u4e00\u68f5\u6811\u5206\u6210\u8f7b\u8fb9\u548c\u94fe \u6240\u6709\u7684\u94fe\u90fd\u4e00\u8d77\u5904\u7406 \u800c\u5bf9\u4e8e\u8f7b\u8fb9\u5219\u76f4\u63a5\u4e00\u6761\u4e00\u6761\u8fb9\u5904\u7406  \n\n\u5c31\u662f\u4e3a\u4e86\u628a$n$\u53d8\u6210$logn$\u554a  \n\n## 3.\u5b9e\u73b0  \n### 1.\u9884\u5904\u7406\n\u6211\u4eec\u628a\u94fe\u79f0\u4e3a**\u91cd\u94fe**  \n\u9996\u5148\u6211\u4eec\u8981\u8ba9\u91cd\u94fe\u7684\u53d6\u6cd5\u6700\u4f18  \n\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9 \u663e\u7136\u5b83\u5230\u5b83\u513f\u5b50(\u6211\u4eec\u5148\u968f\u4fbf\u6307\u5b9a\u4e00\u4e2a\u70b9\u5f53\u505a\u6839)\u7684\u6240\u6709\u51fa\u8fb9\u4e2d **\u53ea\u6709\u4e00\u6761\u8fb9\u80fd\u5728\u91cd\u94fe\u4e2d** \u5426\u5219\u94fe\u4f1a\u76f8\u4ea4  \n\u5728\u8fd9\u91cc\u6211\u4eec\u53d6**\u5b50\u6811\u5927\u5c0f\u6700\u5927**\u7684\u513f\u5b50\u4f5c\u4e3a\u91cd\u513f\u5b50 \u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u70b9\u8be5\u70b9\u548c\u5b83\u7684\u91cd\u513f\u5b50\u4f4d\u4e8e\u540c\u4e00\u6761\u91cd\u94fe\u4e0a \u5230\u5176\u4f59\u7684\u513f\u5b50\u7684\u8def\u5f84\u4f5c\u4e3a\u8f7b\u8fb9  \n\u8fd9\u6837\u5c31\u4f1a\u5f62\u6210\u4e00\u4e9b\u91cd\u94fe\u4e86 \u5982\u679c\u89c9\u5f97\u592a\u62bd\u8c61\u53ef\u4ee5\u770b\u770b\u4e0b\u9762\u7684\u56fe\u7247  \n\n\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u53d6**\u5b50\u6811\u5927\u5c0f\u6700\u5927**\u5728\u540e\u9762\u590d\u6742\u5ea6\u8bc1\u660e\u4e2d\u4f1a\u63d0\u5230  \n\n\u9996\u5148\u6211\u4eec\u8981\u901a\u8fc7dfs\u9884\u5904\u7406\u51fa\u6bcf\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u3001\u7236\u4eb2\u8282\u70b9\u7f16\u53f7\u3001\u6df1\u5ea6\u3001\u91cd\u513f\u5b50\u7f16\u53f7\u3002  \n\u8fd9\u4e9b\u90fd\u4e0d\u96be\u5904\u7406 \u5728\u4e0b\u9762\u7684\u4ee3\u7801\u4e2d\u7ed9\u51fa\u6ce8\u91ca\u4e86  \n\n\u8fd9\u65f6\u5019\u8fd9\u68f5\u6811\u5df2\u7ecf\u5256\u5206\u597d\u4e86 \u4f46\u662f\u4e3a\u4e86\u7ef4\u62a4\u94fe\u4e0a\u4fe1\u606f \u6211\u4eec\u8fd8\u8981\u518d\u5904\u7406\u4e00\u4e9b\u4fe1\u606f  \n\u9996\u5148\u6bcf\u4e00\u6761\u94fe\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u533a\u95f4 \u6211\u4eec\u53ef\u4ee5\u7528**\u7ebf\u6bb5\u6811**\u6765\u7ef4\u62a4\u94fe\u4fe1\u606f  \n\n\u56e0\u6b64 \u6211\u4eec\u9700\u8981\u7ed9\u6811\u4e0a\u6bcf\u4e00\u4e2a\u70b9\u7f16\u53f7 \u4ee3\u8868\u5b83\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7 \u56e0\u4e3a**\u6bcf\u4e00\u6761\u91cd\u94fe\u5728\u7ebf\u6bb5\u6811\u4e0a\u5fc5\u987b\u5bf9\u5e94\u4e00\u4e2a\u8fde\u7eed\u7684\u533a\u95f4** \u800c\u539f\u6765\u7684\u987a\u5e8f\u672a\u5fc5\u80fd\u6ee1\u8db3\u8fd9\u4e2a\u8981\u6c42  \n\u5176\u6b21\u518d\u5efa\u7acb\u4e00\u4e2a\u6570\u7ec4\u7ef4\u62a4\u7ebf\u6bb5\u6811\u4e0a\u7f16\u53f7\u4e3ai\u7684\u70b9\u5bf9\u5e94\u539f\u6811\u4e0a\u7684\u70b9\u7684\u7f16\u53f7 \u5728\u7ebf\u6bb5\u6811\u5efa\u6811\u65f6\u4f1a\u7528\u5230  \n\u6240\u4ee5\u6211\u4eec\u8981\u518ddfs\u4e00\u904d \u800c\u4e14\u8fd9\u4e2adfs\u7684\u904d\u5386\u987a\u5e8f\u8981\u7a0d\u5fae\u8c03\u6574\u4e00\u4e0b \u901a\u8fc7\u6bcf\u4e00\u6b21**\u5148\u904d\u5386\u70b9\u7684\u91cd\u513f\u5b50**\u518d\u904d\u5386\u5176\u4ed6\u513f\u5b50\u6765\u4fdd\u8bc1**\u6bcf\u4e00\u6761\u91cd\u94fe\u5728\u7ebf\u6bb5\u6811\u4e0a\u5fc5\u987b\u5bf9\u5e94\u4e00\u4e2a\u8fde\u7eed\u7684\u533a\u95f4**  \n\n\u7b49\u7b49 \u8fd8\u6ca1\u7ed3\u675f  \n\u73b0\u5728\u6211\u4eec\u662f\u4e0d\u77e5\u9053\u6bcf\u4e00\u6761\u91cd\u94fe\u5bf9\u5e94\u7684\u533a\u95f4\u7f16\u53f7  \n\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\u6211\u4eec\u8fd8\u8981\u5904\u7406\u51fa\u5b83\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u7684\u70b9(\u8be5\u94fe\u4e0a\u6df1\u5ea6\u6700\u5c0f\u7684\u70b9)\u7f16\u53f7  \n\n\u5982\u679c\u4e00\u4e2a\u70b9\u5728\u91cd\u94fe\u7684\u4e2d\u95f4 \u90a3\u4e48\u53ea\u7528\u5904\u7406\u8fd9\u6761\u91cd\u94fe\u7684\u4e00\u90e8\u5206\u5c31\u884c\u4e86(\u8be5\u70b9\u5230\u9876\u7aef\u7684\u90e8\u5206) \u94fe\u4e0a\u7684\u70b9**\u5bf9\u5e94\u7ebf\u6bb5\u6811\u4e2d\u7f16\u53f7\u662f\u968f\u6df1\u5ea6\u9012\u589e\u7684**  \n\u5982\u679c\u8def\u5f84\u4e0a\u7684\u4e24\u4e2a\u70b9\u90fd\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a \u53ea\u8981\u5904\u7406\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u7684\u90e8\u5206\u5c31\u884c\u4e86  \n\n\u6700\u540e\u653e\u5f20\u56fe\u65b9\u4fbf\u7406\u89e3 \u4ee3\u7801\u5728\u6700\u540e  \n\n![](https://cdn.luogu.com.cn/upload/pic/65702.png)\n\u56fe\u4e2d\u6bcf\u4e00\u6761\u84dd\u8272\u7684\u7ebf\u5c31\u4ee3\u8868\u4e00\u6761\u91cd\u94fe  \n1-2-6-7-8  \n5-13  \n3-10-11  \n4  \n9  \n12  \n\u6ce8\u610f\u540e\u9762\u4e09\u4e2a\u70b9\u662f\u4e00\u4e2a\u70b9\u7ec4\u6210\u4e00\u6761\u91cd\u94fe  \n\u7ea2\u8272\u6570\u5b57\u4ee3\u8868\u5b83\u5728\u7ebf\u6bb5\u6811\u4e2d\u5bf9\u5e94\u7f16\u53f7\n\n**code:**  \n```cpp\nvoid dfs1(int u,int f){\n\t// dfs1 \u4f20\u53c2 \u5f53\u524d\u70b9\u548c\u5b83\u7684\u7236\u4eb2\n\tint maxs = 0,v;\n   // maxs\u8bb0\u5f55\u5f53\u524d\u70b9\u7684\u6700\u5927\u5b50\u6570\u7684\u5927\u5c0f(\u5927\u5c0f\u4e3a\u5305\u542b\u70b9\u6570)\n\tsiz[u] = 1; dep[u] = dep[f] + 1; fa[u] = f;\n   // siz\u4e3a\u8be5\u70b9\u4e3a\u6839\u7684\u5b50\u6570\u5927\u5c0f \u5148\u52a0\u4e0a\u5b83\u81ea\u5df1\n   // dep\u4e3a\u8be5\u70b9\u6df1\u5ea6\n   // fa\u4e3a\u8be5\u70b9\u7236\u4eb2\n\tfor(int i = hed[u];i;i = nxt[i]){\n\t\tv = to[i]; if(v == f) continue;\n\t\tdfs1(v,u); // \u5148\u904d\u5386\u6bcf\u4e2a\u513f\u5b50\u8282\u70b9\n\t\tsiz[u] += siz[v]; // \u4fee\u6539\u81ea\u5df1\u7684\u5b50\u6811\u5927\u5c0f\n\t\tif(siz[v] > maxs){\n        // \u5982\u679c\u5f53\u524d\u513f\u5b50\u5b50\u6811\u5927\u5c0f\u6bd4\u76ee\u524d\u4fdd\u5b58\u7684\u503c\u5927 \u628a\u8be5\u70b9\u91cd\u513f\u5b50\u66f4\u65b0\u4e3a\u8be5\u70b9\n\t\t\tmaxs = siz[v];\n\t\t\tson[u] = v;\n\t\t}\n\t}\n}\n\ninline void dfs2(int u,int f){\n\t// dfs2\u4f20\u53c2 u\u662f\u5f53\u524d\u70b9 f\u548c\u4e0a\u9762\u4e0d\u4e00\u6837 f\u662f\u5f53\u524d\u70b9\u6240\u5728\u91cd\u94fe\u9876\u7aef\u7684\u7f16\u53f7\n\ttop[u] = f; // top\u4ee3\u8868u\u7684\u91cd\u94fe\u9876\u7aef\u7684\u7f16\u53f7\n\tid[u] = ++ cnt; // id\u4ee3\u8868\u8be5\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u5bf9\u5e94\u7684\u7f16\u53f7\n\trid[cnt] = u; // rid[cnt]=u\u4ee3\u8868\u7ebf\u6bb5\u6811\u4e2d\u7f16\u53f7\u4e3au\u7684\u70b9\u5bf9\u5e94\u6811\u4e0a\u7f16\u53f7\u4e3acnt\u7684\u70b9\n\tif(!son[u]) return; // \u53f6\u5b50\u8282\u70b9 \u4e0d\u80fd\u641c\u7d22\n\tdfs2(son[u],f); // \u5148\u904d\u5386\u91cd\u513f\u5b50 \u91cd\u513f\u5b50top\u662f\u81ea\u5df1\u7684top\n\tfor(int i = hed[u];i;i = nxt[i]){\n\t\tint v = to[i];\n\t\tif(v == fa[u] || v == son[u]) continue;\n\t\tdfs2(v,v); // \u904d\u5386\u8f7b\u513f\u5b50(\u4e0d\u662f\u91cd\u513f\u5b50\u7684\u513f\u5b50) \u8f7b\u513f\u5b50\u94fe\u9876\u662f\u5b83\u81ea\u5df1\n\t}\n}\ndfs1(s,0); dfs2(s,s);\n// s\u4e3a\u6839 \u6ce8\u610f\u6839\u8282\u70b9\u6240\u5728\u91cd\u94fe\u9876\u7aef\u662f\u5b83\u81ea\u5df1\n```\n\n\u5176\u5b9e\u8fd9\u624d\u662f\u6811\u94fe\u5256\u5206\u7684\u6838\u5fc3\n### 2.\u94fe\u4fee\u6539\u67e5\u8be2  \nx\u5230y\u7684\u6811\u4e0a\u8def\u5f84\u4e00\u5b9a\u4e3a$x->LCA(x,y)->y$  \n\u8fd9\u4e2a\u8fc7\u7a0b\u76f8\u5f53\u4e8e\u628a\u4e00\u4e2a\u70b9\u5148\u79fb\u52a8\u5230LCA \u5728\u628a\u53e6\u4e00\u4e2a\u70b9\u79fb\u52a8\u5230LCA\u6240\u5728\u91cd\u94fe\u4e0a \u518d\u5904\u7406\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u90e8\u5206  \n\u6211\u4eec\u7684**\u76ee\u6807\u72b6\u6001\u662f\u4e24\u4e2a\u70b9\u79fb\u52a8\u5230\u540c\u4e00\u6761\u91cd\u94fe\u4e0a**  \n\u6bcf\u4e00\u6b21\u6211\u4eec\u9009\u62e9**\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef \u6df1\u5ea6\u6700\u6d45\u7684\u70b9** \u4fee\u6539/\u67e5\u8be2\u8fd9\u4e2a\u70b9\u5230\u94fe\u9876\u7aef\u90e8\u5206\u6240\u6709\u70b9\u7684\u4fe1\u606f(\u8fd9\u4e00\u6bb5\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e00\u5b9a\u662f\u8fde\u7eed\u7684) \u5e76\u4e14\u628a\u8fd9\u4e2a\u70b9\u79fb\u52a8\u5230**\u5b83\u6240\u5728\u94fe\u9876\u7aef\u7684\u7236\u4eb2\u8282\u70b9**  \n\u76f4\u5230\u4e24\u70b9\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a  \n\u7136\u540e\u4fee\u6539/\u67e5\u8be2\u4e24\u70b9\u4e4b\u95f4\u7684\u90e8\u5206\u5373\u53ef  \n\n\u5982\u679c\u4e24\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a \u8fd9\u4e24\u70b9\u7684LCA\u7684\u6240\u6709\u513f\u5b50\u4e2d\u4e00\u5b9a\u6709**\u4e00\u4e2a\u91cd\u513f\u5b50\u548c\u5927\u4e8e\u7b49\u4e8e\u4e00\u4e2a\u975e\u91cd\u513f\u5b50\u7684\u5b50\u8282\u70b9** \u8fd9\u4e24\u4e2a\u70b9\u5728\u79fb\u52a8\u8fc7\u7a0b\u4e2d\u5fc5\u5b9a\u4f1a\u6709\u4e00\u4e2a\u70b9**\u79fb\u52a8\u5230\u91cd\u513f\u5b50\u6240\u5728\u94fe\u7684\u94fe\u4e0a** \u8fd9\u6837\u4ee5\u540e\u5c31\u4f1a\u79fb\u52a8\u53e6\u4e00\u4e2a\u70b9(\u4e4b\u524d\u90a3\u4e2a\u70b9\u6240\u5728\u94fe\u9876\u7aef\u6d45\u4e8e\u6216\u7b49\u4e8eLCA)\u5230\u67d0\u4e2a\u8f7b\u513f\u5b50\u7684\u7236\u4eb2\u4e0a \u4e5f\u5c31\u662f\u79fb\u52a8\u5230\u4e86LCA  \n\n**code:**\n```cpp\nvoid update_chain(LL x,LL y,LL v){\n\twhile(top[x] != top[y]){\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tupdate(1,1,n,id[top[x]],id[x],v);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\tupdate(1,1,n,id[x],id[y],v);\n}\n```\n\n### 3.\u5b50\u6811\u4fee\u6539\u67e5\u8be2\n\u4ed4\u7ec6\u60f3\u4e00\u60f3\u4e0a\u9762\u7b2c\u4e8c\u904ddfs\u7684\u8fc7\u7a0b \u4e0d\u96be\u53d1\u73b0\u5bf9\u4e8e\u4efb\u610f\u4e00\u4e2a\u70b9 \u5728\u904d\u5386\u8fd9\u4e2a\u70b9\u4e4b\u540e\u4f1a\u5148\u628a\u8fd9\u4e2a\u70b9\u6240\u5728\u7684\u6574\u68f5\u5b50\u6811\u904d\u5386\u5b8c \u518d\u53bb\u904d\u5386\u5176\u4ed6\u7684\u70b9  \n\u6240\u4ee5\u554a \u4e00\u4e2a\u70b9\u5bf9\u5e94\u7684\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u5bf9\u5e94\u7684\u662f\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\u554a \u8fd9\u8fd8\u4e0d\u597d\u5904\u7406\u5417  \n\n**code:**\n```cpp\nvoid update_son(LL x,LL v){\n\tupdate(1,1,n,id[x],id[x] + siz[x] - 1,v);\n    // \u6ce8\u610f\u7ec6\u8282 -1\n}\n```\n\n### 4.LCA\u67e5\u8be2  \n\u770b\u5b8c2\u5e94\u8be5\u5c31\u77e5\u9053\u4e86  \n\u4e00\u6837\u7684\u5904\u7406\u65b9\u5f0f \u6700\u540e\u4e24\u4e2a\u70b9\u79fb\u52a8\u5230\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u65f6\u8f83\u6d45\u7684\u70b9\u4e3aLCA  \n\n**code:**\n```cpp\nint lca(int x,int y){\n\twhile(1){\n\t\tif(top[x] == top[y]) break;\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tx = fa[top[x]];\n\t}\n\treturn (dep[x] > dep[y] ? y : x);\n}\n```\n## 4.\u590d\u6742\u5ea6\u8bc1\u660e  \n\u53d6**\u5b50\u6811\u5927\u5c0f\u6700\u5927**\u7684\u513f\u5b50\u4f5c\u4e3a\u91cd\u513f\u5b50  \n\u6240\u4ee5\u4ece\u4efb\u610f\u4e00\u70b9\u5f00\u59cb\u8d70 \u6bcf\u8d70\u4e00\u6761\u8f7b\u8fb9 \u8d70\u5b8c\u540e\u7684\u70b9\u5b50\u6811\u5927\u5c0f\u76f8\u5bf9\u4e8e\u539f\u6765\u7684\u70b9**\u81f3\u5c11\u51cf\u5c11\u5230\u539f\u6765\u4e00\u534a**  \n\u6240\u4ee5\u4e4b\u591a\u7ecf\u8fc7$logn$\u6761\u8f7b\u8fb9  \n\u7136\u540e\u7531\u4e8e\u91cd\u94fe\u662f\u4e00\u8d77\u5904\u7406\u7684 \u6bcf\u7ecf\u8fc7\u4e00\u6761\u91cd\u94fe\u540e\u4f1a\u518d\u7ecf\u8fc7\u4e00\u6761\u8f7b\u94fe \u7136\u540e\u518d\u7ecf\u8fc7\u4e0b\u4e00\u6761\u91cd\u94fe  \n\u76f8\u5f53\u4e8e\u6bcf\u4e00\u6761\u91cd\u94fe\u90fd\u662f\u5728\u4e24\u6761\u8f7b\u8fb9\u4e4b\u95f4\u7684 \u6240\u4ee5\u91cd\u94fe\u6761\u6570\u4e5f\u4e0d\u4f1a\u8d85\u8fc7$log_2n$\u6761  \n\u800c\u4e14 \u663e\u7136\u8fd9\u4e2a\u4e0a\u754c\u6bd4\u8f83\u677e \u8dd1\u4e0d\u6ee1\n\n\u52a0\u4e0a\u7ebf\u6bb5\u6811\u7684$logn$ \u6811\u94fe\u5256\u5206\u4e00\u6b21\u7684\u590d\u6742\u5ea6\u4e3a$log^2n$  \n\u6811\u5256\u5e38\u6570\u5f88\u5c0f ~~n<=100000\u7684\u65f6\u5019\u53ef\u4ee5\u540a\u6253\u5c11\u4e00\u4e2alog\u7684LCT~~  \n\n## 5.\u5b8c\u6574\u4ee3\u7801  \n[P3384\u6a21\u677f\u9898](https://www.luogu.org/problem/P3384)  \n~~\u53e4\u65f6\u5019\u7684\u4ee3\u7801\u4e86 \u73b0\u5728\u7801\u98ce\u90fd\u53d8\u4e86~~  \n```cpp\n#include <map>\n#include <list>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\n#define mid ((l + r) >> 1)\n#define lson (x << 1)\n#define rson ((x << 1) | 1)\nusing namespace std;\n\nLL n,q,r,N,a,b;\nLL w[200005] = {0};\nLL to[400005] = {0},hed[400005] = {0},nxt[400005] = {0},cnt = 0;\nLL fa[200005] = {0},dep[200005] = {0},siz[200005] = {0},son[200005] = {0},top[200005] = {0},id[200005] = {0},rid[200005] = {0};\n\ninline void add_edge(LL f,LL t){\n\t++ cnt;\n\tto[cnt] = t;\n\tnxt[cnt] = hed[f];\n\thed[f] = cnt;\n}\n\n//SEGMENT TREE +\nLL val[800005] = {0};\nLL add[800005] = {0};\nvoid build(int x,int l,int r){\n    if(l == r){\n        val[x] = w[rid[l]] % N;\n        return;\n    }\n    build(lson,l,mid);\n    build(rson,mid + 1,r);\n    val[x] = (val[lson] + val[rson]) % N;\n}\n\nvoid push(int x,int l,int r){\n    if(!add[x]) return;\n    add[lson] += add[x]; val[lson] += (LL)(mid - l + 1) * add[x];\n    add[rson] += add[x]; val[rson] += (LL)(r - mid) * add[x];\n    add[lson] %= N; add[rson] %= N;\n    val[lson] %= N; val[rson] %= N;\n    add[x] = 0;\n}\n\nvoid update(int x,int l,int r,int L,int R,LL k){\n    if(l >= L && r <= R){\n    \tadd[x] += k; add[x] %= N;\n    \tval[x] += (LL)(r - l + 1) * k; val[x] %= N;\n        return;\n    }\n    push(x,l,r);\n    if(L <= mid) update(lson,l,mid,L,R,k);\n    if(R > mid) update(rson,mid + 1,r,L,R,k);\n    val[x] = (val[lson] + val[rson]) % N;\n}\n\nLL query(int x,int l,int r,int L,int R){\n    LL sum = 0;\n    if(l >= L && r <= R){\n        return val[x];\n    }\n    push(x,l,r);\n    if(L <= mid) sum = (sum + query(lson,l,mid,L,R)) % N;\n    if(R > mid) sum = (sum + query(rson,mid + 1,r,L,R)) % N;\n    return sum;\n}\n//SEGMENT TREE\n\n//\ninline void dfs1(LL u,LL f){\n\tregister LL maxs = 0,v;\n\tsiz[u] = 1; dep[u] = dep[f] + 1; fa[u] = f;\n\tfor(register int i = hed[u];i;i = nxt[i]){\n\t\tv = to[i]; if(v == f) continue;\n\t\tdfs1(v,u);\n\t\tsiz[u] += siz[v];\n\t\tif(siz[v] > maxs){\n\t\t\tmaxs = siz[v];\n\t\t\tson[u] = v;\n\t\t}\n\t}\n}\n\ninline void dfs2(LL u,LL f){\n\ttop[u] = f;\n\tid[u] = ++ cnt;\n\trid[cnt] = u;\n\tif(!son[u]) return;\n\tdfs2(son[u],f);\n\tfor(register int i = hed[u];i;i = nxt[i]){\n\t\tregister LL v = to[i];\n\t\tif(v == fa[u] || v == son[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\n//\n\n//\ninline void update_son(LL x,LL v){\n\tupdate(1,1,n,id[x],id[x] + siz[x] - 1,v);\n}\n\ninline LL query_son(LL x){\n\treturn query(1,1,n,id[x],id[x] + siz[x] - 1);\n}\n\ninline void update_chain(LL x,LL y,LL v){\n\twhile(top[x] != top[y]){\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tupdate(1,1,n,id[top[x]],id[x],v);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\tupdate(1,1,n,id[x],id[y],v);\n}\n\ninline LL query_chain(LL x,LL y){\n\tregister LL ans = 0;\n\twhile(top[x] != top[y]){\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x,y);\n\t\tans += query(1,1,n,id[top[x]],id[x]);\n\t\tans %= N;\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x,y);\n\tans += query(1,1,n,id[x],id[y]);\n\tans %= N;\n\treturn ans;\n}\n//\n\nint main(){\n\tregister LL op,cz1,cz2,cz3;\n\tios::sync_with_stdio(false);\n\tcin >> n >> q >> r >> N;\n\tfor(register int i = 1;i <= n;i ++) cin >> w[i];\n\tfor(register int i = 1;i < n;i ++){\n\t\tcin >> a >> b;\n\t\tadd_edge(a,b);\n\t\tadd_edge(b,a);\n\t}\n\tcnt = 0;\n\tdfs1(r,0);\n\tdfs2(r,r);\n\tbuild(1,1,n);\n\twhile(q --){\n\t\tcin >> op;\n\t\tif(op == 1){ cin >> cz1 >> cz2 >> cz3; update_chain(cz1,cz2,cz3 % N); }\n\t\tif(op == 2){ cin >> cz1 >> cz2; cout << query_chain(cz1,cz2) % N << endl; }\n\t\tif(op == 3){ cin >> cz1 >> cz2; update_son(cz1,cz2 % N); }\n\t\tif(op == 4){ cin >> cz1; cout << query_son(cz1) % N << endl; }\n\t}\n\treturn 0;\n}\n```\n\n\u914d\u5408\u7ebf\u6bb5\u6811 \u6811\u94fe\u5256\u5206\u8fd8\u53ef\u4ee5\u5b9e\u73b0\u5f88\u591a\u64cd\u4f5c  \n\n\u6b64\u6587\u7ae0\u5b8c\u7ed3\u3002\u611f\u8c22\u9605\u8bfb\u3002",
        "postTime": 1563955457,
        "uid": 31440,
        "name": "installb",
        "ccfLevel": 8,
        "title": "[\u7b97\u6cd5\u7b14\u8bb0] \u6811\u94fe\u5256\u5206"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\uff1a\n\u6811\u94fe\u5256\u5206\u662f\u4e00\u79cd\u8f83\u590d\u6742\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5728\u5b66\u4e60\u7ebf\u6bb5\u6811\u4e4b\u524d\uff0c\u4f60\u53ef\u80fd\u9700\u8981\u4e86\u89e3\uff1a\n\n#### 1.\u6811\u7684\u57fa\u672c\u7ed3\u6784\u548c\u6027\u8d28\uff08\u6bd4\u5982\u548c\u8282\u70b9\u4e4b\u95f4\u7684\u5173\u7cfb\uff09\u3002\n#### 2.\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u4fee\u6539\u548c\u533a\u95f4\u6c42\u548c\u3002\n#### 3.DFS\u5e8f\u548cLCA\u7684\u57fa\u672c\u6982\u5ff5\u548c\u6c42\u6cd5\u3002\n#### 4.\u94fe\u5f0f\u524d\u5411\u661f\u7684\u8fd0\u7528\u3002\n\u7136\u540e\u6211\u5c31\u4f1a\u5c3d\u91cf\u7528\u80fd\u52a8\u7684\u65b9\u6cd5\u6765\u8ba9\u4f60\u4eec\u5f04\u61c2\u4ec0\u4e48\u662f\u6811\u94fe\u5256\u5206\u3002\u53ef\u80fd\u4f1a\u501f\u9274\u4e00\u4e9b\u4eba\u7684blog\uff0c\u5e0c\u671b\u4e0d\u8981\u4ecb\u610f\u3002\uff08\u56e0\u4e3a\u5199\u5f97\u597d\u624d\u4f1a\u88ab\u501f\u9274\uff09\u3002\n\n\u5728\u8fd9\u7ebf\u6bb5\u6811\u4f1a\u7528\u5230\u4e09\u79cd\u64cd\u4f5c\uff1a\n### 1.\u5efa\u6811\n```cpp\nvoid build(int root1,int l,int r)\n{\n\ttree[root1].l=l;\n\ttree[root1].r=r;\n\ttree[root1].flag=0;\n\tif(l==r)\n\t{\n\t\ttree[root1].ans=wnst[l];\n\t\ttree[root1].ans=tree[root1].ans%mod;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(root1*2,l,mid);\n\tbuild(root1*2+1,mid+1,r);\n\ttree[root1].ans=(tree[root1*2].ans+tree[root1*2+1].ans)%mod;\n}\n```\n\n### 2.\u66f4\u6539\n```cpp\nvoid add(int now0,int l,int r,int wns4)\n{\n\tif(l<=tree[now0].l && r>=tree[now0].r)\n\t{\n\t\ttree[now0].ans=(tree[now0].ans+wns4*(tree[now0].r-tree[now0].l+1))%mod;\n\t\ttree[now0].flag=(tree[now0].flag+wns4)%mod;\n\t\treturn;\n\t}\n\tif(tree[now0].flag)\n\tdown(now0);\n\tint mid=(tree[now0].l+tree[now0].r)/2;\n\tif(l<=mid)\n\t{\n\t\tadd(now0*2,l,r,wns4);\n\t}\t\n\tif(r>mid)\n\tadd(now0*2+1,l,r,wns4);\n\ttree[now0].ans=(tree[now0*2].ans+tree[now0*2+1].ans)%mod;\n}\n```\n\n### 3.\u67e5\u8be2\n```cpp\nint find(int now7,int l,int r)\n{\n\tint ans1=0;\n\tif(l<=tree[now7].l && r>=tree[now7].r)\n\t{\n    \ttree[now7].ans=tree[now7].ans%mod;\n    \treturn tree[now7].ans;\n\t}\n\tif(tree[now7].flag)\n\tdown(now7);\n\tint mid=(tree[now7].l+tree[now7].r)/2;\n\tif(l<=mid)\n\t{\n\t\tans1=(find(now7*2,l,r)+ans1)%mod;\n\t}\n\tif(r>mid)\n\t{\n\t\tans1=(find(now7*2+1,l,r)+ans1)%mod;\n\t}\n\treturn ans1;\n}\n```\n\u7136\u540e\u8bb0\u5f97\u61d2\u6807\u8bb0\u4e0b\u4f20\u5c31\u884c\n\n------------\n\n\u6811\u94fe\u5256\u5206\u662f\u5c5e\u4e8e\u6570\u636e\u7ed3\u6784\u7684\u4e00\u79cd\uff0c\u4ed6\u53ef\u4ee5\u5c06\u4e00\u68f5\u6811\u8f6c\u5316\u4e3a\u4e00\u6761\u94fe\u3002\u4ece\u800c\u53ef\u4ee5\u5b9e\u73b0\u6811\u4e0a\u7684\u4e00\u4e9b\u64cd\u4f5c\n\n#### 1.\u53ef\u4ee5\u7ed9\u6811\u4e0a\u7684\u3010l\uff0cr\u3011\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u503c\u52a0\u4e0a\u67d0\u4e2a\u6570\u3002\n#### 2.\u53ef\u4ee5\u6c42\u6811\u4e0a\u7684\u3010l\uff0cr\u3011\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u503c\u4e4b\u548c\u3002\n#### 3.\u53ef\u4ee5\u7ed9\u67d0\u4e00\u8282\u70b9\u4ee5\u53ca\u5176\u6240\u6709\u7684\u513f\u5b50\u6743\u503c\u52a0\u4e0a\u67d0\u4e2a\u6570\u3002\n#### 4.\u53ef\u4ee5\u6c42\u67d0\u4e00\u8282\u70b9\u4ee5\u53ca\u5176\u6240\u6709\u7684\u513f\u5b50\u6743\u503c\u4e4b\u548c\u3002\n\n\u4ee5\u4e0a\u7684\u56db\u4e2a\u64cd\u4f5c\u901a\u8fc7\u6811\u94fe\u5256\u5206\u53ef\u4ee5\u5feb\u901f\u89e3\u51b3\uff0c\u6811\u94fe\u5256\u5206\u521a\u5b66\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u6709\u4e00\u4e9b\u8ff7\u832b\uff0c\u4f46\u53ea\u8981\u4f60\u4ed4\u7ec6\u5206\u6790\uff0c\u4f1a\u53d1\u73b0\u6811\u94fe\u5256\u5206~~\u5176\u5b9e\u5f88\u6709\u8da3~~\u3002\u6811\u94fe\u5256\u5206\u5173\u952e\u5728\u4e8e\u5bf9\u4e8e\u8282\u70b9\u7684\u7f16\u53f7\u7684\u5feb\u901f\u5904\u7406\uff08\u7ebf\u6bb5\u6811\uff0c\u4e0b\u9762\u4f1a\u8bb2\uff09\n\n\u5373\u5bf9\u4e8e\u6811\u94fe\u5256\u5206\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\uff0c\u4ece\u800c\u4f7f\u5176\u7684\u590d\u6742\u5ea6\u964d\u4f4e\uff0c\u80fd\u591f\u5feb\u901f\u7684\u5f97\u5230\u4e00\u4e2a\u533a\u95f4\u5185\u7684\u503c\u3002\n\n##### \u7136\u540e\u95ee\u9898\u6765\u4e86:\n#### 1.\u7ebf\u6bb5\u6811\u5982\u4f55\u7ef4\u62a4\uff1f\n#### 2.\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff1f\n#### 3.\u5982\u4f55\u80fd\u591f\u5408\u7406\u5206\u914d\u6811\u4e2d\u7684\u5173\u7cfb\u548c\u8282\u70b9\u7684\u7f16\u53f7\uff1f\n#### 4.\u5982\u4f55\u4fdd\u8bc1\u8fd9\u6837\u7684\u6b63\u786e\u6027\uff1f\n\n\u9996\u5148\u6211\u4eec\u8981\u89e3\u51b3\u4ee5\u4e0b\u7684\u56db\u4e2a\u95ee\u9898\u3002\n\n\u5148\u6765\u4e86\u89e3\u4e00\u4e9b\u57fa\u672c\u6982\u5ff5\uff1a\n\n#### \u91cd\u513f\u5b50\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\uff0c\u5b83\u7684\u513f\u5b50\u4e2d\u4ee5\u90a3\u4e2a\u513f\u5b50\u4e3a\u6839\u7684\u5b50\u6811\u8282\u70b9\u6570\u6700\u5927\u7684\u513f\u5b50\u4e3a\u8be5\u8282\u70b9\u7684\u91cd\u513f\u5b50\u3002\n\n#### \u8f7b\u513f\u5b50\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\uff0c\u5b83\u7684\u513f\u5b50\u4e2d\u975e\u91cd\u513f\u5b50\u7684\u5269\u4e0b\u6240\u6709\u513f\u5b50\u5373\u4e3a\u8f7b\u513f\u5b50.\u53f6\u5b50\u8282\u70b9\u6ca1\u6709\u91cd\u513f\u5b50\u4e5f\u6ca1\u6709\u8f7b\u513f\u5b50.\n\n#### \u91cd\u8fb9\uff1a\u4e00\u4e2a\u7236\u4eb2\u8fde\u63a5\u4ed6\u7684\u91cd\u513f\u5b50\u7684\u8fb9\u79f0\u4e3a\u91cd\u8fb9.\n#### \u8f7b\u8fb9\uff1a\u5269\u4e0b\u7684\u5373\u4e3a\u8f7b\u8fb9\n#### \u91cd\u94fe\uff1a\u76f8\u90bb\u91cd\u8fb9\u8fde\u8d77\u6765\u7684\u8fde\u63a5\u4e00\u6761\u91cd\u513f\u5b50\u7684\u94fe\u53eb\u91cd\u94fe\u5bf9\u4e8e\u53f6\u5b50\u8282\u70b9\uff0c\u82e5\u5176\u4e3a\u8f7b\u513f\u5b50\u5219\u6709\u4e00\u6761\u4ee5\u81ea\u5df1\u4e3a\u8d77\u70b9\u7684\u957f\u5ea6\u4e3a1\u7684\u94fe.\u6bcf\u4e00\u6761\u91cd\u94fe\u4ee5\u8f7b\u513f\u5b50\u4e3a\u8d77\u70b9.\n\n\n![](https://images2018.cnblogs.com/blog/1256986/201712/1256986-20171203120143991-1630008815.png)\n\n\u4ee5\u4e0a\u6458\u81eaChinHhh's blog\uff08https://www.cnblogs.com/chinhhh/p/7965433.html#firstt\uff09\u3002\n\n\u6709\u4e86\u4ee5\u4e0a\u7684\u77e5\u8bc6\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u7ef4\u62a4\u4e00\u4e9b\u4e1c\u897f\u5566\uff01\n\n#### \u6211\u4eec\u9700\u8981\u5148\u9884\u5904\u7406\u51fa\u4e00\u4e9b\u503c\uff1a\n#### 1.\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u7236\u4eb2\u662f\u8c01f[]\u3002\n#### 2.\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u5f53\u524d\u6df1\u5ea6dep[]\u3002\n#### 3.\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u542b\u81ea\u5df1\u7684\u5b50\u6811\u5927\u5c0fsize[]\u3002\n#### 4.\u6807\u8bb0\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u91cd\u513f\u5b50\u7f16\u53f7son[]\u3002\n#### 5.\u6807\u8bb0\u6bcf\u4e2a\u70b9\u7684\u65b0\u7f16\u53f7id[]\u3002\n#### 6.\u8d4b\u503c\u6bcf\u4e2a\u70b9\u7684\u521d\u59cb\u503c\u5230\u65b0\u7f16\u53f7\u4e0awnst[]\u3002\n#### 7.\u5904\u7406\u6bcf\u4e2a\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aeftop[]\u3002\n\n\u6211\u4eec\u5206\u522b\u7528\u4e24\u4e2aDFS\u9884\u5904\u7406\u51fa\u6765\u3002\n## DFS1\n```cpp\nvoid dfs1(int now5,int fa,int depth)\n{\n\tdep[now5]=depth;\n\tf[now5]=fa;\n\tsize[now5]=1;\n\tint maxson=-1;\n\tfor(int i=head[now5];i;i=a[i].next)\n\t{\n\t\tif(a[i].to==fa)\n\t\tcontinue;\n\t\tdfs1(a[i].to,now5,depth+1);\n\t\tsize[now5]+=size[a[i].to];\n\t\tif(size[a[i].to]>maxson)\n\t\t{\n\t\t\tmaxson=size[a[i].to];\n\t\t\tson[now5]=a[i].to;\n\t\t}//\u6bcf\u6b21\u66f4\u65b0\u91cd\u513f\u5b50\n\t}\n}\n```\n\n## DFS2\u6ce8\u610f\uff1a\n\u5148\u5904\u7406\u91cd\u513f\u5b50\u5728\u5904\u7406\u8f7b\u513f\u5b50\u3002\n\n\n```cpp\nvoid dfs2(int now6,int root2)\n{\n\tid[now6]=++cnt;\n\twnst[cnt]=wns[now6];\n\ttop[now6]=root2;\n\tif(son[now6]==0)\n\treturn;\n\tdfs2(son[now6],root2);\n\tfor(int i=head[now6];i;i=a[i].next)\n\t{\n\t\tif(a[i].to==f[now6] || a[i].to==son[now6])\n\t\tcontinue;\n\t\tdfs2(a[i].to,a[i].to);\n\t}\n}\n```\n\u7ecf\u8fc7\u4ee5\u4e0a\u7684DFS\u540e\uff0c\u6211\u4eec\u53d1\u73b0\u6211\u4eec\u8bb0\u5f55\u4e0b\u6765\u7684\u8282\u70b9\uff0c\u6ee1\u8db3\u4ee5\u4e0b\u6027\u8d28\n#### 1.\u6bcf\u4e00\u6761\u91cd\u94fe\u7684\u65b0\u7f16\u53f7\u662f\u8fde\u7eed\u7684\u3002\uff08\u5148\u91cd\u540e\u8f7b\uff09\n#### 2.\u6bcf\u4e00\u4e2a\u5b50\u6811\u7684\u65b0\u7f16\u53f7\u4e5f\u662f\u8fde\u7eed\u7684\u3002\uff08DFS\uff09\n\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u5206\u4e24\u79cd\u95ee\u9898\u5904\u7406\uff1a\n#### 1.\u5bf9[l,r]\u7684\u8def\u5f84\u7684\u5904\u7406\uff1b\n#### 2.\u5bf9\u6811\u4e2d\u67d0\u4e00\u8282\u70b9\u53ca\u5176\u5b50\u6811\u7684\u5904\u7406\u3002\n\n\n### \u95ee\u98981:\n\u53d1\u73b0\u95ee\u98981\u6b63\u597d\u80fd\u5bf9\u5e94\u6027\u8d281\u548c\u6027\u8d282\uff0c\u4e4b\u524d\u6211\u4eec\u8bb0\u5f55\u8fc7\u6bcf\u4e2a\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aeftop[]\u3002\u5728\u8fd9\u53ef\u4ee5\u53d1\u6325\u7528\u573a\n```cpp\nvoid addpath(int x,int y,int wns1)\n{\n\twns1%=mod;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\tswap(x,y);\n\t\tadd(1,id[top[x]],id[x],wns1);\n\t\tx=f[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\tswap(x,y);\n\tadd(1,id[x],id[y],wns1);\n}\nint countpath(int x,int y)\n{\n\tint ans2=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\tswap(x,y);\n\t\tans2=find(1,id[top[x]],id[x])+ans2;\n\t\tans2%=mod;\n\t\tx=f[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\tswap(x,y);\n\tans2=find(1,id[x],id[y])+ans2;\n\tans2%=mod;\n\treturn ans2;\n}\n```\n\n### \u95ee\u98982\uff1a\n\u8bb0\u5f55\u4e86\u6bcf\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u6bcf\u4e2a\u5b50\u6811\u7684\u7f16\u53f7\u90fd\u8fde\u7eed\uff0c\u76f4\u63a5\u7ebf\u6bb5\u6811\u533a\u95f4\u67e5\u8be2\u5373\u53ef\u3002\n\n\u6ce8\u610f\u5230\u53f3\u533a\u95f4\u5c31\u662fid[root]+size[root]-1\uff1b\n\n\u4ee3\u7801\u6bd4\u8f83\u77ed\uff1a\n```cpp\nvoid addtree(int root3,int wns21)\n{\n\tadd(1,id[root3],id[root3]+size[root3]-1,wns21);\n}\nint counttree(int root4)\n{\n\tint ans3=0;\n\tans3=find(1,id[root4],id[root4]+size[root4]-1)%mod;\n\treturn ans3;\n}\n```\n\n\u4e8e\u662f\u6211\u4eec\u5c31\u6109\u5feb\u5730\u89e3\u51b3\u5566\uff01\uff01\uff01\n\n# AC\u4ee3\u7801\uff1a\n```cpp\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n,m,root,mod;\nint wns[400005];\nstruct vode1\n{\n\tint to;\n\tint next;\n}a[400005];\nint head[400005];\nint now8=0;\nint cnt=0;\nint size[400005];\nint son[400005];\nint top[400005];\nint dep[400005];\nint f[400005];\nint wnst[200005];\nint id[400005];\nstruct vode\n{\n\tint ans;\n\tint flag;\n\tint l;\n\tint r;\n}tree[400005];\nvoid down(int nowO)\n{\n\ttree[nowO*2].flag=(tree[nowO*2].flag+tree[nowO].flag)%mod;\n\ttree[nowO*2+1].flag=(tree[nowO*2+1].flag+tree[nowO].flag)%mod;\n\ttree[nowO*2].ans=(tree[nowO*2].ans+tree[nowO].flag*(tree[nowO*2].r-tree[nowO*2].l+1))%mod;\n\ttree[nowO*2+1].ans=(tree[nowO*2+1].ans+tree[nowO].flag*(tree[nowO*2+1].r-tree[nowO*2+1].l+1))%mod;\n\ttree[nowO].flag=0;\n}\nvoid add1(int x,int y)\n{\n\tnow8++;\n\ta[now8].to=y;\n\ta[now8].next=head[x];\n\thead[x]=now8;\n}\nvoid add(int now0,int l,int r,int wns4)\n{\n\tif(l<=tree[now0].l && r>=tree[now0].r)\n\t{\n\t\ttree[now0].ans=(tree[now0].ans+wns4*(tree[now0].r-tree[now0].l+1))%mod;\n\t\ttree[now0].flag=(tree[now0].flag+wns4)%mod;\n\t\treturn;\n\t}\n\tif(tree[now0].flag)\n\tdown(now0);\n\tint mid=(tree[now0].l+tree[now0].r)/2;\n\tif(l<=mid)\n\t{\n\t\tadd(now0*2,l,r,wns4);\n\t}\t\n\tif(r>mid)\n\tadd(now0*2+1,l,r,wns4);\n\ttree[now0].ans=(tree[now0*2].ans+tree[now0*2+1].ans)%mod;\n}\nint find(int now7,int l,int r)\n{\n\tint ans1=0;\n\tif(l<=tree[now7].l && r>=tree[now7].r)\n\t{\n    \ttree[now7].ans=tree[now7].ans%mod;\n    \treturn tree[now7].ans;\n\t}\n\tif(tree[now7].flag)\n\tdown(now7);\n\tint mid=(tree[now7].l+tree[now7].r)/2;\n\tif(l<=mid)\n\t{\n\t\tans1=(find(now7*2,l,r)+ans1)%mod;\n\t}\n\tif(r>mid)\n\t{\n\t\tans1=(find(now7*2+1,l,r)+ans1)%mod;\n\t}\n\treturn ans1;\n}\nvoid dfs1(int now5,int fa,int depth)\n{\n\tdep[now5]=depth;\n\tf[now5]=fa;\n\tsize[now5]=1;\n\tint maxson=-1;\n\tfor(int i=head[now5];i;i=a[i].next)\n\t{\n\t\tif(a[i].to==fa)\n\t\tcontinue;\n\t\tdfs1(a[i].to,now5,depth+1);\n\t\tsize[now5]+=size[a[i].to];\n\t\tif(size[a[i].to]>maxson)\n\t\t{\n\t\t\tmaxson=size[a[i].to];\n\t\t\tson[now5]=a[i].to;\n\t\t}\n\t}\n}\nvoid dfs2(int now6,int root2)\n{\n\tid[now6]=++cnt;\n\twnst[cnt]=wns[now6];\n\ttop[now6]=root2;\n\tif(son[now6]==0)\n\treturn;\n\tdfs2(son[now6],root2);\n\tfor(int i=head[now6];i;i=a[i].next)\n\t{\n\t\tif(a[i].to==f[now6] || a[i].to==son[now6])\n\t\tcontinue;\n\t\tdfs2(a[i].to,a[i].to);\n\t}\n}\nvoid build(int root1,int l,int r)\n{\n\ttree[root1].l=l;\n\ttree[root1].r=r;\n\ttree[root1].flag=0;\n\tif(l==r)\n\t{\n\t\ttree[root1].ans=wnst[l];\n\t\ttree[root1].ans=tree[root1].ans%mod;\n\t\treturn;\n\t}\n\tint mid=(l+r)/2;\n\tbuild(root1*2,l,mid);\n\tbuild(root1*2+1,mid+1,r);\n\ttree[root1].ans=(tree[root1*2].ans+tree[root1*2+1].ans)%mod;\n}\nvoid addpath(int x,int y,int wns1)\n{\n\twns1%=mod;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\tswap(x,y);\n\t\tadd(1,id[top[x]],id[x],wns1);\n\t\tx=f[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\tswap(x,y);\n\tadd(1,id[x],id[y],wns1);\n}\nint countpath(int x,int y)\n{\n\tint ans2=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\tswap(x,y);\n\t\tans2=find(1,id[top[x]],id[x])+ans2;\n\t\tans2%=mod;\n\t\tx=f[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\tswap(x,y);\n\tans2=find(1,id[x],id[y])+ans2;\n\tans2%=mod;\n\treturn ans2;\n}\nvoid addtree(int root3,int wns21)\n{\n\tadd(1,id[root3],id[root3]+size[root3]-1,wns21);\n}\nint counttree(int root4)\n{\n\tint ans3=0;\n\tans3=find(1,id[root4],id[root4]+size[root4]-1)%mod;\n\treturn ans3;\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&m,&root,&mod);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t    scanf(\"%d\",&wns[i]);\n\t    wns[i]%=mod;\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x1,y1;\n\t\tscanf(\"%d%d\",&x1,&y1);\n\t\tadd1(x1,y1);\n\t\tadd1(y1,x1);\n\t}\n\tdfs1(root,0,1);\n\tdfs2(root,root);\n\tbuild(1,1,n);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint a1,a2,a3,a4;\n\t\tscanf(\"%d\",&a1);\n\t\tif(a1==1)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a2,&a3,&a4);\n\t\t\taddpath(a2,a3,a4);\n\t\t}\n\t\telse\n\t\tif(a1==2)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a2,&a3);\n\t\t\tprintf(\"%d\\n\",countpath(a2,a3));\n\t\t}\n\t\telse\n\t\tif(a1==3)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a2,&a3);\n\t\t\taddtree(a2,a3);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d\",&a2);\n\t\t\tprintf(\"%d\\n\",counttree(a2));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u3002\u3002\u7801\u98ce\u53ef\u80fd\u6bd4\u8f83\u4e11\u3002\u3002\n\n",
        "postTime": 1565100385,
        "uid": 114514,
        "name": "zzr8178541919",
        "ccfLevel": 7,
        "title": "\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "P3384 \u6811\u94fe\u5256\u5206\n\n\u5199\u4e86\u597d\u957f\u65f6\u95f4\u7ec8\u4e8e\u8fc7\u4e86\u554a\u554a\u554a\u554a\u554aQAQ\n\n\u6811\u5256\u5c31\u662f\u5c06\u4e00\u68f5\u6811\u66b4\u529b\u62c6\u6210\u51e0\u6761\u94fe\uff0c\u7136\u540e\u5bf9\u4e8e\u8fd9\u6837\u4e00\u4e2a\u5e8f\u5217\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5957\u4e0a\u8d44\u74f7\u533a\u95f4\u5904\u7406\u7684\u4e00\u4e9b\u4e1c\u897fqwq\uff08\u6bd4\u5982\u8bf4\u7ebf\u6bb5\u6811\n\n\u5199\u4e86\u8fd9\u4e48\u957f\u65f6\u95f4\uff0c\u90a3\u4e48\u6811\u5256\u6709\u4ec0\u4e48\u7528\u5462\uff1f\n1. \u6c42lca\t\n\u6211\u4eec\u6240\u8bb0\u5f55\u7684top[]\u53ef\u4ee5\u5f88\u5feb\u7684\u8f85\u52a9\u6211\u4eec\u6c42\u6811\u4e0a\u4e24\u70b9\u7684lca,\u800c\u4e14\u8981\u6bd4\u500d\u589e\u8981\u5feb\n2. \u7ef4\u62a4\u6811\u4e0a\u64cd\u4f5c\t\nRT\uff0c\u6811\u4e0a\u4e24\u70b9\u8def\u5f84\u548c\u5b50\u6811\u7684\u4fee\u6539\u53ca\u8be2\u95ee\uff0c\u4e5f\u5c31\u662f\u53ef\u4ee5\u628a\u6811\u4e0a\u7684\u64cd\u4f5c\u653e\u5230\u4e00\u7ef4\u5e8f\u5217\u4e0a\u6765\u505a\n3. \u5b9e\u73b0\u6811\u4e0a\u5dee\u5206\t\n\u867d\u7136\u53ef\u4ee5\u76f4\u63a5\u7528\u6811\u4e0a\u5dee\u5206\u505a\uff0c\u4f46\u662f\u4e5f\u53ef\u4ee5\u6811\u5256\uff08\u4e2a\u4eba\u4e60\u60ef\u5566\n4. \u6811\u5957\u6811\t\n\u8fd9\u5c31\u591a\u4e86\u561b\uff0c\u4ec0\u4e48\u4e3b\u5e2d\u6811\uff0c\u5e73\u8861\u6811\uff0c\u7ebf\u6bb5\u6811\uff0c\u6811\u72b6\u6570\u7ec4balabala\uff0c\u8fd8\u6709\u4e00\u4e9b\u53ef\u6301\u4e45\u5316\u7684\u4e1c\u897f\uff08\u9003\n5. dalao\u8bf4\u8fd8\u53ef\u4ee5\u6709\u6811\u5256+dp\uff08\u9003\n\n\u4e0b\u9762\u662f\u91cd\u8981\u90e8\u5206\u4ee3\u7801\u5b9e\u73b0\uff0c\u5373\u4e24\u6b21\u9884\u5904\u7406\u90e8\u5206\uff1a\n\n\u9996\u5148\u7cfbdfs1\uff0c\u53d8\u91cf\u7684\u610f\u4e49dalao\u4eec\u90fd\u8bb2\u5f97\u5dee\u4e0d\u591a\u60f9\uff0c\u7b80\u5355\u6765\u8bf4\u5c31\u662f\u6c42\u5b83\u7684\u91cd\u513f\u5b50\u548c\u6df1\u5ea6\t\n\u7136\u540e\u7cfbdfs2\uff08\u5e9f\u8bdd\uff0cdfs2\u4e3b\u8981\u662f\u5229\u7528dfs1\u4e2d\u6c42\u51fa\u7684\u91cd\u513f\u5b50\u5e8f\u9012\u5f52\uff0c**\u7531\u4e8e\u6811\u4e0a\u64cd\u4f5c\u7684\u987a\u5e8f\u4e00\u5b9a\u4e3adfs\u5e8f**\uff0c\u6240\u4ee5\u91cd\u94fe\u4e0a\u7684\u8282\u70b9\u90fd\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u771f\u6b63\u610f\u4e49\u4e0a\u7684\u5728\u8fd9\u91cc\u5c06\u6811\u62c6\u5206\u6210\u94fe\uff0c\u5373\u6811\u94fe\u5256\u5206\u7684\u7cbe\u9ad3QWQ\uff0cseq[]\u5373\u4e3a\u6620\u5c04\u540e\u7684\u5e8f\u5217\uff0c\u8fd9\u91cc\u6709\u4e24\u79cd\u5199\u6cd5\uff1a\t\t\t\t\t\t\t\n\t\n    seq[cnt]=a[u];\u5bf9\u5e94sum(x)=seq[l];\n   \t\u8fd9\u65f6seq\u4e2d\u5b58\u7684\u662f\u6620\u5c04\u540e\u7684\u5e8f\u5217\n \n   \tseq[cnt]=u;\u5bf9\u5e94sum(x)=a[seq[l]];\n   \t\u8fd9\u65f6seq\u5b58\u7684\u662f\u5e8f\u5217\u7684\u4e0b\u6807\n\n\u7136\u540e\u672c\u9898\u5957\u7684\u662f\u7ebf\u6bb5\u6811\uff0c\u7ebf\u6bb5\u6811\u677f\u5b50\u5c31\u4e0d\u591a\u8bb2\u60f9qwq\n\n\u6700\u540e\u662f\u4e11\u964b\u7684\u4ee3\u7801\u5624\u5624\u5624\uff1a\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define l(x) t[x].l\n#define r(x) t[x].r\n#define sum(x) t[x].sum\n#define add(x) t[x].add\n//define\nconst int mxn=500005;\ntypedef long long ll;\nint pre[mxn],next[mxn],ver[mxn],tot;\nint f[mxn],son[mxn],size[mxn],dfn[mxn],dep[mxn],top[mxn],seq[mxn];\nint n,m,r,cnt,p;\nstruct tree {\n\tll sum;\n\tint l,r,add;\n} t[mxn*4];\nint a[mxn];\ninline ll read(){\n    ll pi=0,ff=1;char c=getchar();\n    while(c<'0'||c>'9'){if(c=='-')ff=-1;c=getchar();}\n    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}\n    return ff*pi;\n}\n------------\u7ebf\u6bb5\u6811------------\n\nvoid build(int x,int l,int r){\n\tl(x)=l,r(x)=r;\n\tif(l(x)==r(x)){\n\t\tsum(x)=seq[l];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(2*x,l,mid);\n\tbuild(2*x+1,mid+1,r);\n\tsum(x)=(sum(2*x)+sum(2*x+1))%p;\n}\nvoid update(int x){\n\tsum(2*x)=(sum(2*x)+(r(2*x)-l(2*x)+1)*add(x))%p;\n\tsum(2*x+1)=(sum(2*x+1)+(r(2*x+1)-l(2*x+1)+1)*add(x))%p;\n\tadd(2*x)=(add(2*x)+add(x))%p;\n\tadd(2*x+1)=(add(2*x+1)+add(x))%p;\n\tadd(x)=0;\n}\nvoid change(int x,int l,int r,int z){\n\tif (l(x)==l&&r(x)==r) {\n\t\tsum(x)=(sum(x)+(r(x)-l(x)+1)*z)%p;\n\t\tadd(x)+=z;\n\t\treturn;\n\t}\n\tif(add(x)) update(x);\n\tint mid=(l(x)+r(x))>>1;\n\tif(l>mid) change(2*x+1,l,r,z);\n\telse if(r<=mid) change(2*x,l,r,z);\n\telse {\n\t\tchange(2*x,l,mid,z);\n\t\tchange(2*x+1,mid+1,r,z);\n\t}\n\tsum(x)=(sum(2*x)+sum(2*x+1))%p;\n}\nll query(int x,int l,int r){\n\tif(l(x)==l&&r(x)==r) return sum(x);\n\tif(add(x)) update(x);\n\tll tem=0;\n\tint mid=(l(x)+r(x))>>1;\n\tif(l>mid) return query(2*x+1,l,r)%p;\n\telse if(r<=mid) return query(2*x,l,r)%p;\n\telse return (query(2*x,l,mid)+query(2*x+1,mid+1,r))%p;\n}\n------------\u52a0\u8fb9\u548c\u9884\u5904\u7406------------\nvoid addedge(int x,int y){\n\ttot++;\n\tver[tot]=y;\n\tnext[tot]=pre[x];\n\tpre[x]=tot;\n}\nint dfs1(int u,int fa,int depth){\n    f[u]=fa;size[u]=1;dep[u]=depth;\n\tfor(int i=pre[u];i;i=next[i]){\n\t\tint v=ver[i];\n\t\tif(v==fa)continue;\n\t\tdfs1(v,u,depth+1);\n\t\tsize[u]+=size[v];\n\t\tif(size[v]>size[son[u]])\n\t\tson[u]=v;\n\t}\n}\nvoid dfs2(int u,int t){\n\ttop[u]=t;dfn[u]=++cnt;seq[cnt]=a[u];\n\tif(!son[u])return ;\n\tdfs2(son[u],t);\n\tfor(int i=pre[u];i;i=next[i]){\n\t\tint v=ver[i];\n\t\tif(v!=son[u]&&v!=f[u])dfs2(v,v);\n\t}\n}\n\n------------\u6811\u4e0a\u52a0\u3001\u6811\u4e0a\u6c42\u548c------------\n\nint tadd(int x,int y,int k){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tchange(1,dfn[top[x]],dfn[x],k);\n\t\tx=f[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tchange(1,dfn[x],dfn[y],k);\n}\nvoid tsum(int x,int y){\n\tint ans=0;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tans=(ans+query(1,dfn[top[x]],dfn[x]))%p;\n\t\tx=f[top[x]];\t\t\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\tans=(ans+query(1,dfn[x],dfn[y]))%p;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tn=read(),m=read(),r=read(),p=read();\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tfor(int i=1;i<n;i++){\n\t\tint x,y;\n\t\tx=read(),y=read();\n\t\taddedge(x,y);addedge(y,x);\n\t}\n\tdfs1(r,0,1);dfs2(r,r);build(1,1,n);\n\tfor(int i=1;i<=m;i++){\n\t\tint opt,x,y,z;\n\t\tscanf(\"%d\",&opt);\n\t\tif(opt==1)x=read(),y=read(),z=read(),tadd(x,y,z%p);\n\t\tif(opt==2)x=read(),y=read(),tsum(x,y);\n\t\tif(opt==3)x=read(),z=read(),change(1,dfn[x],dfn[x]+size[x]-1,z%p);\t\n\t\tif(opt==4)x=read(),printf(\"%lld\\n\",query(1,dfn[x],dfn[x]+size[x]-1)%p);\n\t}\n\treturn 0;\t\n} \n```\n\u4ee3\u7801\u6709\u70b9\u957f\u4f46\u662f\u5927\u5bb6\u8981\u52a0\u6cb9\u8c03\u9e2dQwQ",
        "postTime": 1537187061,
        "uid": 61185,
        "name": "maniac\uff01",
        "ccfLevel": 4,
        "title": "P3384 \u6811\u94fe\u5256\u5206"
    },
    {
        "content": "\n\u4ee5\u4e0b\u5185\u5bb9\u5747\u6458\u81f3[\u535a\u5ba2\uff08\u66f4\u52a0\u8be6\u7ec6\uff09](https://www.cnblogs.com/hhh1109/p/9085447.html )\n\n\n-----\n\n#### \u8f7b\u91cd\u8fb9\n\n----\n\n\t\u5728\u6811\u94fe\u5256\u5206\u91cc\uff0c\u6211\u4eec\u5b9a\u4e49\u5982\u4e0b\u89c4\u5219\n\t1.\u91cd\u513f\u5b50:\u5f53\u524d\u8282\u70b9\u7684\u513f\u5b50\u8282\u70b9\u4e2d\u5b50\u6811\u5927\u5c0f\u6700\u5927\u7684\u90a3\u4e00\u4e2a \n\t2.\u8f7b\u513f\u5b50:\u5f53\u524d\u8282\u70b9\u9664\u4e86\u91cd\u513f\u5b50\u4ee5\u5916\u7684\u6240\u6709\u8282\u70b9\n\u90a3\u4e48\n\t\n\t\u91cd\u94fe\u5373\u4e3a\u91cd\u513f\u5b50\u8fde\u6210\u7684\u94fe\uff0c\u8f7b\u94fe\u5373\u4e3a\u8f7b\u513f\u5b50\u8fde\u6210\u7684\u94fe\u3002\n\n![](http://images.cnblogs.com/cnblogs_com/hhh1109/1222922/o_graph%20(1).png)\n \n \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8fd9\u5f20\u56fe\u770b\u5230\u5982\u4e0b\u5206\u94fe\u89e3\u91ca\n\t\t\n\t\t\u8282\u70b91\u7684\u513f\u5b50\uff082,3\uff09\u4e2d2\u7684\u5b50\u6811\u5927\u5c0f\u66f4\u5927\u6240\u4ee5\u9009\u53d62\u4e3a\u91cd\u513f\u5b50\u3002  \n\t\t\u8282\u70b96\u7684\u513f\u5b50\uff087,9\uff09\u4e2d7\u7684\u5b50\u6811\u5927\u5c0f\u66f4\u5927\u6240\u4ee5\u9009\u53d67\u4e3a\u91cd\u513f\u5b50\u3002\n\n\n\n```cpp\nvoid dfs1(int x) //\u8fd9\u4e2a\u662f\u7528\u6765\u6c42\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u7684,\u5373\u987a\u4fbf\u6c42\u51fa\u8f7b\u91cd\u513f\u5b50\n{ \n\tsize[x]=1; //\u5f53\u524d\u8fd9\u4e2a\u70b9\u672c\u8eab\u5927\u5c0f\u4e3a1\n\tfor(int i=head[x];i;i=e[i].next) \n\t{ \n\t\tint v=e[i].to; \n\t\tif(!dep[v]) \n\t\t//\u5176\u5b9e\u8fd9\u91cc\u7684if\u91cc\u9762\u4e5f\u53ef\u4ee5\u8fd9\u4e48\u5199if(v!=fa[x])\n\t\t{\t \t\n\t\t\tdep[v]=dep[x]+1; \n\t\t\tfa[v]=x;//\u4e00\u822c\u90fd\u662f\u53cc\u5411\u8fb9\uff0c\u7136\u540e\u662f\u4e3a\u4e86\u8df3lca\n\t\t\tdfs1(v);\n\t\t\tsize[x]+=size[v]; \n\t\t\tif(size[v]>size[son[x]])son[x]=v; //\u6c42\u51fa\u91cd\u513f\u5b50\n\t\t}\t \t\n\t} \n}\n```\n\n-----\n\n#### DFS\u5e8f\n\n-----\n\n\u849f\u84bb\u7684\u4e00\u53e5\u8bdd\u603b\u7ed3\n\t\t\n\t\t\u4ee5\u4e00\u4e2a\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u4e0d\u5f80\u56de\u8d70\uff0c\u4e00\u76f4\u641c\u5230\u5b83\u80fd\u5230\u8fbe\u7684\u6240\u6709\u70b9\uff0c\u4f18\u5148\u8d70\u91cd\u513f\u5b50\uff0c\u8f7b\u513f\u5b50\u7b49\u91cd\u513f\u5b50\u8d70\u5b8c\u4ee5\u540e\u56de\u6eaf\u4e0a\u6765\u518d\u5f80\u4e0b\u8d70\u3002\n\t\t\u800c\u6bcf\u4e2a\u70b9\u7684dfs\u5e8f\u5c31\u662f\u5b83\u6309\u987a\u5e8f\u88ab\u641c\u5230\u7684\u65f6\u95f4\u70b9\uff08\u524d\u9762\u6709\u591a\u5c11\u4e2a\u70b9\u5df2\u7ecf\u88ab\u641c\u8fc7\u4e86\uff09\u3002\n\n```cpp\nvoid dfs2(int x,int t)\n{\n\t//l[]\u8868\u793a\u8fd9\u4e2a\u70b9\u7684dfs\u5e8f\n\t//\u7136\u540ea[]\u662f\u4ee5dfs\u5e8f\u4e3a\u4e0b\u6807\uff08\u7ef4\u62a4\u94fe\uff09\u7684\u5f53\u524d\u70b9\u7684\u70b9\u503c\n\t//ch[]\u662f\u9898\u76ee\u7ed9\u51fa\u7684\u70b9\u503c\n\t//top[]\u8bb0\u5f55\u7684\u662f\u8fd9\u4e2a\u70b9\u6240\u5728\u7684\u94fe\u7684\u9876\u7aef\u7684\u90a3\u4e2a\u70b9\uff0c\u7528\u6765\u8df3lca\n\tl[x]=++tot;a[tot]=ch[x];top[x]=t; \n\tif(son[x])dfs2(son[x],t); //\u6709\u91cd\u513f\u5b50\u7ef4\u62a4\u91cd\u94fe\n\tfor(int i=head[x];i;i=e[i].next) \n\t{\n\t\tint v=e[i].to; \n\t\tif(v!=fa[x]&&v!=son[x]) \n\t\t//\u4e0d\u662f\u7236\u4eb2\u4e0d\u662f\u91cd\u513f\u5b50\uff0c\u4ee5\u8f7b\u513f\u5b50\u4e3a\u7aef\u70b9\u7684\u65b0\u94fedfs\u4e0b\u53bb\n\t\tdfs2(v,v); \n\t} \n}\n```\n\n---\n\n#### LCA\n\n----\n\n\n\u662f\u4e0d\u662f\u6211\u4eec\u5c31\u53ef\u4ee5\u8fd9\u4e48\u60f3\uff1a\n\t\t\n\t\t\u65e2\u7136\u4ee5x\u7684\u5b50\u6811\u4fe1\u606f\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff0c\u53c8x\u5230\u8fd9\u6761\u91cd\u94fe\u4e0a\u7684\u4efb\u4e00\u4e00\u70b9\u5728\u7ebf\u6bb5\u6811\u4e0a\u90fd\u662f\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\u3002\u90a3\u4e48x\u5230y\u7684\u8def\u5f84\u5c31\u662f\u901a\u8fc7x\u548cy\u4e0d\u65ad\u7684\u4ece\u81ea\u8eab\u7684\u94fe\u5f80\u4e0a\u8df3\uff0c\u4e00\u6b21\u8df3\u4e00\u6761\u91cd\u94fe\u56e0\u4e3a\u91cd\u94fe\u5728\u7ebf\u6bb5\u6811\u4e0a\u53ef\u4ee5\u76f4\u63a5\u7ef4\u62a4\u3002\u7136\u540e\u5c31\u662f\u8981\u6e05\u695a\u5f53\u524dx\u548cy\u8c01\u7684top\u8282\u70b9\u6df1\u5ea6\u66f4\u6df1\uff0c\u56e0\u4e3a\u8df3\u6df1\u5ea6\u4f4e\u7684\u53ef\u80fd\u4f1a\u9519\u8fc7lca\u3002\u90a3\u4e48\u8df3\u94fe\u7684\u65b9\u6cd5\u5c31\u51fa\u6765\u4e86\u3002\n\u8ba9\u6211\u4eec\u518d\u4ee5\u8fd9\u5f20\u56fe\u4e3a\u4f8b\n\n![](http://images.cnblogs.com/cnblogs_com/hhh1109/1222922/o_graph%20(1).png)\n\n \u6211\u4eec\u73b0\u5728\u8981\u8ba910\u548c5\u8df3lca\u3002\u5f88\u660e\u663e\u6211\u4eec\u8981\u4ece10\u8df3\u52304\uff0c\u56e0\u4e3a5\u4f1a\u76f4\u63a5\u8df3\u52301\u800c\u5b83\u4eec\u7684lca\u5f88\u660e\u663e\u662f2\u3002\n\u4e0b\u9762\u6211\u4eec\u8d34\u51fa\u4e00\u4e2a\u7ed9x\u5230y\u8def\u5f84\u52a0\u503c\u7684\u4ee3\u7801\n\n\n```cpp\nvoid cal2(int x,int y,int v) \n{\n\tint fx=top[x],fy=top[y]; \n\twhile(fx!=fy)//\u5982\u679c\u9876\u70b9\u76f8\u540c\u4e86\u5c31\u4e0d\u7528\u8df3\u4e86\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e0b\u653e \n\t{ \n\t\t//\u6309\u4e0a\u9762\u8bf4\u7684\u5224\u65adtop\u6df1\u5ea6\n\t\tif(dep[fx]<dep[fy])swap(x,y),swap(fx,fy); \n\t\tupdate(1,1,tot,l[fx],l[x],v); \n\t\tx=fa[fx],fx=top[x];\n\t\t//x\u6362\u5230\u53e6\u4e00\u6761\u94fe\u7ee7\u7eed\u5f80\u4e0a\u8df3 \n\t} \n\tif(l[x]>l[y])swap(x,y); \n\t//\u5728\u8fd9\u91ccdfs\u5e8f\u548cdep\u4e4b\u95f4\u662f\u6ca1\u6709\u533a\u522b\u7684\n\t//\u56e0\u4e3a\u6df1\u5ea6\u6df1\u7684\u70b9\u5728\u540c\u4e00\u6761\u91cd\u94fe\u91cc\u5f88\u660e\u663e\u662f\u540e\u88abdfs\u5230\u7684\n\tupdate(1,1,tot,l[x],l[y],v); \n}\n```\n\n\n\u4ee5\u4e0b\u4e3a\u9898\u89e3\u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#define ll long long \nusing namespace std;\nstruct node{\n    ll to,next;\n}e[500001];\nll rt,mod;\nll head[500001],dep[500001],sum[500001],a[500001];\nll tot,num,n,m,lazy[500001],fa[500001],l[500001];\nll ch[500001],top[500001],size[500001],son[500001];\nvoid build(int root,int l,int r)\n{\n    if(l==r){sum[root]=a[l];return ;}\n    int mid=(l+r)>>1;\n    build(root<<1,l,mid);\n    build(root<<1|1,mid+1,r);\n    sum[root]=sum[root<<1]+sum[root<<1|1];sum[root]%=mod;\n    return ;\n}\n\nvoid push(int root,int l,int r)\n{\n    int mid=(l+r)>>1;\n    lazy[root<<1]+=lazy[root];lazy[root<<1]%=mod;\n    lazy[root<<1|1]+=lazy[root];lazy[root<<1|1]%=mod;\n    sum[root<<1]+=lazy[root]*(mid-l+1);sum[root<<1]%=mod;\n    sum[root<<1|1]+=lazy[root]*(r-mid);sum[root<<1|1]%=mod;\n    lazy[root]=0;\n    return ;\n}\n\nvoid update(int root,int left,int right,int l,int r,ll k)\n{\n    if(l<=left&&r>=right)\n    {\n    sum[root]+=k*(right-left+1);sum[root]%=mod;\n    lazy[root]+=k;lazy[root]%=mod;\n    return;\n    }\n    if(left>r||right<l)return ;\n    int mid=(left+right)>>1;\n    if(lazy[root])push(root,left,right);\n    if(mid>=l)update(root<<1,left,mid,l,r,k);\n    if(mid<r) update(root<<1|1,mid+1,right,l,r,k);\n    sum[root]=(sum[root<<1|1]+sum[root<<1])%mod;\n    return;\n}\n\nll query(int root,int left,int right,int l,int r)\n{\n    if(l<=left&&r>=right)return sum[root]%mod;\n    if(left>r||right<l)return 0;\n    int mid=(left+right)>>1;\n    if(lazy[root])push(root,left,right);\n    ll a=0,b=0;\n    if(mid>=l) a=query(root<<1,left,mid,l,r);\n    if(mid<r)  b=query(root<<1|1,mid+1,right,l,r);\n    return (a%mod+b%mod)%mod;\n}\n\n--------------------\u4ee5\u4e0a\u662f\u7ebf\u6bb5\u6811\u5206\u5272\u7ebf-------------------------\n\nvoid dfs1(int x)\n{\n    size[x]=1;\n    for(int i=head[x];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(!dep[v])\n        {\n            dep[v]=dep[x]+1;\n            fa[v]=x;\n            dfs1(v);\n            size[x]+=size[v];\n            if(size[v]>size[son[x]])son[x]=v;\n        }\n    }\n}\n\nvoid dfs2(int x,int t)\n{\n    l[x]=++tot;a[tot]=ch[x];top[x]=t;\n    if(son[x])dfs2(son[x],t);\n    for(int i=head[x];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v!=fa[x]&&v!=son[x])\n        dfs2(v,v);\n    }\n    return ;\n}\n\nll cal1(int x,int y)//\u67e5\u8be2\u8def\u5f84\u503c\n{\n    ll maxx=0;\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n        maxx+=query(1,1,tot,l[fx],l[x]);\n        x=fa[fx];fx=top[x];\n    }\n    if(l[x]>l[y])swap(x,y);\n    maxx+=query(1,1,tot,l[x],l[y]);\n    return maxx;\n}\n\nvoid cal2(int x,int y,int v)//\u7ef4\u62a4\u8def\u5f84\u52a0\u503c\n{\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])swap(x,y),swap(fx,fy);\n        update(1,1,tot,l[fx],l[x],v);\n        x=fa[fx],fx=top[x];\n    }\n    if(l[x]>l[y])swap(x,y);\n    update(1,1,tot,l[x],l[y],v);\n}\n\nll read()\n{\n    ll x=0,w=1;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=x*10+ch-'0',ch=getchar();\n    return x*w;\n}\n\nvoid add(int from,int to)\n{\n    num++;\n    e[num].to=to;\n    e[num].next=head[from];\n    head[from]=num;\n}\nint main()\n{\n    n=read();m=read();rt=read();mod=read();\n    for(int i=1;i<=n;i++)ch[i]=read(),ch[i]%=mod;\n    for(int i=1;i<n;i++)\n    {\n        int x=read(),y=read();\n        add(x,y);add(y,x);\n    }\n    dep[rt]=1;fa[rt]=1;\n    dfs1(rt);dfs2(rt,rt);build(1,1,n);\n    while(m--)\n    {\n        int qwq=read();\n        if(qwq==1){int x=read(),y=read(),z=read();cal2(x,y,z%mod);}\n        if(qwq==2){int x=read(),y=read();printf(\"%lld\\n\",cal1(x,y)%mod);}\n        if(qwq==3){int x=read(),y=read();update(1,1,n,l[x],l[x]+size[x]-1,y%mod);}\n        if(qwq==4){int x=read();printf(\"%lld\\n\",query(1,1,n,l[x],l[x]+size[x]-1)%mod);}\n    //\u5b50\u6811\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\n    }\n    return 0;\n}\n```",
        "postTime": 1527320756,
        "uid": 45212,
        "name": "Epiphyllumthief",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3384 \u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u5f15\u7528\u697c\u4e0b\u7684\u4e00\u53e5\u8bdd\uff1a\n\n## \u8111\u5b50\u90fd\u5feb\u88ab\u5256\u70b8\u4e86\n\n\u867d\u7136\u662f\u9053\u6a21\u677f\u9898\uff0c\u4f46\u6211\u89c9\u5f97\u6811\u94fe\u5256\u5206\u5b66\u4e60\u8d77\u6765\u8fd8\u662f\u6709\u4e00\u5b9a\u56f0\u96be\u7684\u3002\n\n\u8fd9\u91cc\u7ed9\u5927\u5bb6\u63a8\u8350\u4e00\u4e2a[\u5165\u95e8\u6811\u94fe\u5256\u5206\u7684\u535a\u6587](http://blog.sina.com.cn/s/blog\\_6974c8b20100zc61.html)\uff0c\u4e00\u4e9b\u8be6\u7ec6\u7684\u6982\u5ff5\u53ef\u4ee5\u53c2\u7167\u91cc\u9762\u3002\n\n**\u4f46\u662f\u672c\u849f\u84bb\u8868\u793a\u770b\u5b8c\u8fd8\u662f\u4e0d\u592a\u660e\u767d**\n\n\u4e8e\u662f\u5728\u8fd9\u91cc\u5199\u4e00\u5199**\u6211\u5b66\u6811\u94fe\u5256\u5206\u65f6\u9047\u5230\u7684\u95ee\u9898**\uff1a\n\n\u9996\u5148\uff0c\u6211\u4ece\u79bbNOIP2017 100\u591a\u5929\u65f6\u5f00\u59cb\u5b66\u6811\u94fe\u5256\u5206\uff0c\u7136\u540e\u5728\u8ddd\u79bb\u6bd4\u8d5b\u7b2c\u4e5d\u5929\u65f6\u7ec8\u4e8e\u5b66\u5b8c\u4e86\u3002\u3002\u3002\uff08\u61d2\u764c\u665a\u671f\uff09\n\n**\u56de\u5f52\u6b63\u9898**\n\n\uff08\u8fd9\u91cc\u7684\u6982\u5ff5\u76f4\u63a5\u501f\u7528\u4e86\u521a\u521a\u7684\u535a\u6587\u4e2d\u7684\u540d\u79f0\uff09\n\n\uff08\u95ee\u7b54\u663e\u793a\u5c55\u73b0\uff09\n\n- 1\uff1a\n- Q\uff1a\u4e3a\u4ec0\u4e48\u6811\u94fe\u5256\u5206\u626f\u5230\u7ebf\u6bb5\u6811\u4e0a\u53bb\u4e86\uff1f\n\n- A\uff1a\u901a\u8fc7\u7ebf\u6bb5\u6811\u8fbe\u5230\u67e5\u8be2\uff0c\u7ef4\u62a4\u8fd9\u4e9b\u6811\u4e0a\u70b9\u548c\u8fb9\u7684\u5173\u7cfb\u3002\n\n- 2\uff1a\n- Q\uff1a\u4e3a\u4ec0\u4e48\u8981\u4f7f\u4e00\u6761\u91cd\u94fe\u5404\u8fb9\u5728\u7ebf\u6bb5\u6811\u4e2d\u8fde\u7eed\u5206\u5e03\uff1f\n\n- A\uff1a\u8fd9\u4e0e\u6211\u4eec\u5b9e\u73b0\u6211\u4eec\u7684\u6811\u94fe\u5256\u5206\u6240\u7528\u7684\u7ebf\u6bb5\u6811\u6709\u5173\u3002\u6211\u4eec\u4fee\u6539\u65f6\u4e00\u822c\u5bf9\u4e00\u4e2a\u5b50\u6811\u6216\u4e00\u6761\u94fe\u64cd\u4f5c\uff0c\u800c\u4f7f\u5f53\u524d\u5b50\u6811\u7684\u8fb9\u5728\u7ebf\u6bb5\u6811\u4e2d\u5206\u5e03\u5728\u8fde\u7eed\u533a\u95f4\u91cc\uff0c\u6211\u4eec\u5c31\u65b9\u4fbf\u901a\u8fc7\u7ebf\u6bb5\u6811\u8fdb\u884c\u64cd\u4f5c\u3002\n\n\n\u4ee5\u4e0a\u5c31\u662f\u6211\u5b66\u4e60\u9047\u5230\u7684\u95ee\u9898\u6240\u5728\u4e86\uff0c\u76f8\u4fe1\u5927\u90e8\u5206\u540c\u5fd7\u4e5f\u4f1a\u9047\u5230\u3002\n\n\u9644\u5e26\u4e00\u4e9b\u5b9e\u8df5\u7684\u5c0f\u7ec6\u8282\uff0c\u5728\u6211\u7684\u4ee3\u7801\u4e2d\u5c55\u73b0\uff1a\n\n**\uff08\u6e29\u99a8\u63d0\u793a\uff1a\u6ce8\u610f\u968f\u65f6\u53d6\u6a21\uff0c\u56e0\u6b64\u4f5c\u4e3aP\u9009\u624blongint\u5373\u53ef\uff08\u770b\u4e0d\u4e0b\u53bb\u697c\u4e0b\u4e00\u5806\u5199long long\u7684\uff09\uff09**\n\n```cpp\n//Luogu P3384\n\ntype\n     edgetype=record\n      point,next:longint;\n     end;\n\nvar\n    edge:array[0..200005]of edgetype;    //edge\u90bb\u63a5\u8868\u5b58\u8fb9\uff1b\u5f00\u53cc\u500d\u5927\u5c0f\uff08\u65e0\u5411\u56fe\u4e00\u6761\u8fb9\u8981\u5b58\u4e24\u4e2a\u65b9\u5411\u7684\uff09\n    tree,lazy:array[0..300005]of longint;    //tree\u662f\u7ebf\u6bb5\u6811\u8282\u70b9\u7684\u4fe1\u606f\uff1blazy\u662f\u6bcf\u4e2a\u8282\u70b9\u7684\u61d2\u6807\u8bb0\n    last,siz,fa,dep,son,top,id,a,real:array[0..100000]of longint;    \n    {last[v]\u8868\u793a\u90bb\u63a5\u8868\u4e2d\u4ee5v\u4e3a\u8d77\u70b9\u7684\u8fb9\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u4f4d\u7f6e\n     siz[v]\u8868\u793a\u4ee5\u8282\u70b9v\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f\uff0cfa[v]\u8868\u793a\u8282\u70b9v\u7684\u7236\u8282\u70b9\uff0cdep[v]\u8868\u793a\u8282\u70b9v\u7684\u6df1\u5ea6\uff0cson[v]\u8868\u793a\u8282\u70b9v\u7684\u91cd\u513f\u5b50\uff08\u6ca1\u6709\u5219\u662f-1\uff09\uff0c\n     top[v]\u8868\u793a\u8282\u70b9v\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u8282\u70b9\uff0cid[v]\u8868\u793av\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\uff0creal\u8868\u793a\u7ebf\u6bb5\u6811\u7684\u53f6\u5b50\u8282\u70b9\u5bf9\u5e94\u5b9e\u9645\u6811\u4e2d\u70b9\u7684\u7f16\u53f7\uff0c\n     a\u5219\u662f\u6bcf\u4e2a\u8282\u70b9\u7684\u521d\u59cb\u503c}\n    es,ps,n,m,i,r,p,x,y,z,ty:longint;\n\nprocedure ready;\n begin\n       es:=0; ps:=0;    //es\u8bb0\u5f55\u5b58\u5165\u8fb9\u65f6\u8fb9\u7684\u7f16\u53f7\uff0cps\u8bb0\u5f55\u5728DFS2\u8fc7\u7a0b\u65f6\u70b9\u5728\u7ebf\u6bb5\u6811\u5e95\u7aef\u7684\u7f16\u53f7\n       filldword(last,sizeof(last) div 4,0);\n       filldword(lazy,sizeof(lazy) div 4,0);    //last\u548clazy\u521d\u59cb\u5316\n end;\n\nprocedure swap(var x1,x2:longint);\n var temp:longint;\n begin\n       temp:=x1; x1:=x2; x2:=temp;\n end;\n\nprocedure addedge(u,v:longint);    //\u52a0\u8fb9\n begin\n       inc(es);\n       edge[es].point:=v;\n       edge[es].next:=last[u];\n       last[u]:=es;\n end;\n\n//Part. Sugment Tree \u7ebf\u6bb5\u6811\u57fa\u672c\u64cd\u4f5c\n\n{\nfunction max(n1,n2:longint):longint;\n begin\n       if (n1>n2) then exit(n1) else exit(n2);\n end;}\n\nprocedure pushup(rt:longint);\n begin\n       tree[rt]:=(tree[rt*2]+tree[rt*2+1]) mod p;\n end;\n\nprocedure pushdown(rt,l,r:longint);\n var mid,ls,rs,ll,lr:longint;\n begin\n       if (lazy[rt]>0) then\n       begin\n             mid:=(l+r) div 2; ls:=rt*2; rs:=ls+1; ll:=mid-l+1; lr:=r-mid;\n             tree[ls]:=(tree[ls]+lazy[rt]*ll mod p) mod p;\n             lazy[ls]:=(lazy[ls]+lazy[rt]) mod p;\n             tree[rs]:=(tree[rs]+lazy[rt]*lr mod p) mod p;\n             lazy[rs]:=(lazy[rs]+lazy[rt]) mod p;\n             lazy[rt]:=0;\n       end;\n end;\n\nprocedure build(rt,l,r:longint);    //\u666e\u901a\u7684\u5efa\u6811\n var mid:longint;\n begin\n       if (l=r) then\n       begin\n             tree[rt]:=a[real[l]] mod p;\n             exit;\n       end;\n       mid:=(l+r) div 2;\n       build(rt*2,l,mid);\n       build(rt*2+1,mid+1,r);\n       pushup(rt);\n end;\n\nprocedure updata(rt,l,r,ql,qr,w:longint);    //\u66f4\u65b0\n var mid:longint;\n begin\n       if ((ql<=l) and (r<=qr)) then\n       begin\n             tree[rt]:=(tree[rt]+(r-l+1)*w mod p) mod p;\n             lazy[rt]:=(lazy[rt]+w) mod p;\n             exit;\n       end;\n       mid:=(l+r) div 2;\n       pushdown(rt,l,r);\n       if (ql<=mid) then updata(rt*2,l,mid,ql,qr,w);\n       if (qr>mid) then updata(rt*2+1,mid+1,r,ql,qr,w);\n       pushup(rt);\n end;\n\nfunction query(rt,l,r,ql,qr:longint):longint;    //\u67e5\u8be2\n var mid:longint;\n begin\n       if ((ql<=l) and (r<=qr)) then exit(tree[rt]);\n       mid:=(l+r) div 2; query:=0;\n       pushdown(rt,l,r);\n       if (ql<=mid) then query:=(query+query(rt*2,l,mid,ql,qr)) mod p;\n       if (qr>mid) then query:=(query+query(rt*2+1,mid+1,r,ql,qr)) mod p;\n       pushup(rt);\n end;\n\n//Part. End\n\nprocedure dfs1(u,f:longint);    //\u5f97\u5230fa,dep,siz,son\u7684\u503c\n var now,v:longint;\n begin\n       fa[u]:=f; dep[u]:=dep[f]+1; siz[u]:=1; son[u]:=-1;\n       now:=last[u];\n       while (now>0) do\n       begin\n             v:=edge[now].point;\n             if (v<>f) then\n             begin\n                   dfs1(v,u);\n                   inc(siz[u],siz[v]);\n                   if ((son[u]=-1) or (siz[v]>siz[son[u]])) then son[u]:=v;\n             end;\n             now:=edge[now].next;\n       end;\n end;\n\nprocedure dfs2(u,tp:longint);    //\u5c06\u6811\u653e\u5165\u7ebf\u6bb5\u6811\uff0c\u540c\u65f6\u6c42\u51fatop\u548cid\n var now,v:longint;\n begin\n       inc(ps); id[u]:=ps; top[u]:=tp; real[ps]:=u;    //ps\u5c31\u662f\u7c7b\u4f3ces\u53d8\u91cf\u7684\u529f\u80fd\n       if (son[u]=-1) then exit;\n       dfs2(son[u],tp);\n       now:=last[u];\n       while (now>0) do\n       begin\n             v:=edge[now].point;\n             if ((v<>son[u]) and (v<>fa[u])) then dfs2(v,v);\n             now:=edge[now].next;\n       end;\n end;\n\nprocedure add(u,v,w:longint);    //\u5728\u6811\u4e0au\u5230v\u7684\u8def\u5f84\u4e0a\u52a0\u4e0aw\n var f1,f2:longint;\n begin\n       f1:=top[u]; f2:=top[v];\n       while (f1<>f2) do    //\u57fa\u672c\u7684\u6811\u94fe\u5256\u5206\u66f4\u65b0\u64cd\u4f5c\uff0c\u4e0d\u89e3\u91ca\uff08\u4e0d\u660e\u767d\u53ef\u4ee5\u770b\u90a3\u4efd\u535a\u6587\u91cc\u7684\u89e3\u91ca\uff09\n       begin\n             if (dep[f1]<dep[f2]) then\n             begin\n                   swap(f1,f2);\n                   swap(u,v);\n             end;\n             updata(1,1,n,id[f1],id[u],w);    //\u66f4\u65b0\u6811\u4e0au\u5230\u9876\u7aeff1\u8282\u70b9\u7684\u8def\u5f84\n             u:=fa[f1];\n             f1:=top[u];\n       end;\n       if (dep[u]>dep[v]) then swap(u,v);\n       updata(1,1,n,id[u],id[v],w);    //\u540c\u4e00\u94fe\u4e0a\u66f4\u65b0u\u5230v\u7684\u8def\u5f84\n end;\n\nfunction getsum(u,v:longint):longint;    //\u6811\u4e0a\u6c42\u548c\n var ans,f1,f2:longint;\n begin\n       ans:=0;\n       f1:=top[u]; f2:=top[v];\n       while (f1<>f2) do    //\u7c7b\u4f3cadd\u8fc7\u7a0b\u7684\u64cd\u4f5c\n       begin\n             if (dep[f1]<dep[f2]) then\n             begin\n                   swap(f1,f2);\n                   swap(u,v);\n             end;\n             ans:=(ans+query(1,1,n,id[f1],id[u])) mod p;\n             u:=fa[f1];\n             f1:=top[u];\n       end;\n       if (dep[u]>dep[v]) then swap(u,v);\n       ans:=(ans+query(1,1,n,id[u],id[v])) mod p;\n       exit(ans);\n end;\n\nbegin\n      ready;\n\n      read(n,m,r,p);\n      for i:=1 to n do read(a[i]);\n      for i:=1 to n-1 do\n      begin\n            read(x,y);\n            addedge(x,y);\n            addedge(y,x);\n      end;\n\n      dep[0]:=0;\n      dfs1(r,0);\n      dfs2(r,r);\n      build(1,1,n);\n\n      for i:=1 to m do\n      begin\n            read(ty);\n            case ty of\n             1:begin    //1\u64cd\u4f5c\n                     read(x,y,z);\n                     add(x,y,z);\n               end;\n             2:begin    //2\u64cd\u4f5c\n                     read(x,y);\n                     writeln(getsum(x,y));\n               end;\n             3:begin    //3\u64cd\u4f5c\n                     read(x,z);\n                     updata(1,1,n,id[x],id[x]+siz[x]-1,z);    \n                     //\u56e0\u4e3a\u662f\u5b50\u6811\u4e0a\u64cd\u4f5c\u6240\u4ee5\u76f4\u63a5\u7528updata\u5373\u53ef\uff0cid[x]~id[x]+siz[x]-1\u5373\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u533a\u95f4\n               end;\n             4:begin    //4\u64cd\u4f5c\n                     read(x);\n                     writeln(query(1,1,n,id[x],id[x]+siz[x]-1));    //\u56e0\u4e3a\u662f\u5b50\u6811\u4e0a\u67e5\u8be2\u6240\u4ee5\u76f4\u63a5\u7528query\u5373\u53ef\n               end;\n            end;\n      end;\nend.\n```\n\uff08\u6709\u95ee\u9898\u7684\u7ae5\u978b\u53ef\u4ee5\u79c1\u4fe1\u6211~\uff09\n",
        "postTime": 1509506325,
        "uid": 28022,
        "name": "CaptainSlow",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "[my blog](https://www.cnblogs.com/Isaunoya/p/11619823.html)\n\u535a\u5ba2\u5185\u9644\u56fe\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a\u7ebf\u6bb5\u6811\uff0c\u94fe\u5f0f\u524d\u5411\u661f\uff0cLCA\uff0cDFS\u5e8f\n\n\u597d\u4e86\u5c31\u5f53\u4f60\u90fd\u4f1a\u4e86\u3002\u4e0d\u4f1a\u4e5f\u6ca1\u5173\u7cfb\u3002\n\n\u6811\u94fe\u5256\u5206\u901a\u5e38\u7684\u64cd\u4f5c:\n1.x -> y \u7684\u8def\u5f84\u4e0a\u4fee\u6539 2.x -> y \u7684\u8def\u5f84\u4e0a\u67e5\u8be2 3. \u5bf9\u4e8e x \u7684\u5b50\u6811\u4fee\u6539 4.\u5bf9\u4e8e x \u7684\u5b50\u6811\u67e5\u8be2\u3002\n\n\u4e00\u822c\u8fd8\u6709\u6362\u6839\u64cd\u4f5c\u3002\u6811\u5256\u4e5f\u4e5f\u53ef\u4ee5\u505aLCA\u4ee5\u53ca\u5dee\u5206\u64cd\u4f5c\uff08\u4f46\u662f\u6811\u5256\u597d\u50cf\u5c31\u76f4\u63a5\u4fee\u6539\u4e86\u4e0d\u9700\u8981\u5dee\u5206\uff09\u3002\n\n\u6811\u94fe\u5256\u5206\u6709\u4e24\u4e2aDFS \u8fd9\u4e24\u4e2aDFS\u5c31\u662f\u628a\u4e00\u68f5\u6811\u53d8\u6210\u4e00\u4e2a\u5e8f\u5217\u3002 \u7136\u540e\u5c31\u53ef\u4ee5\u7528\u6570\u636e\u7ed3\u6784\u6765\u7ef4\u62a4\u4e86\u3002\n\n\n\u7b2c\u4e00\u4e2aDFS \u7528\u6765\u6c42 $fa$\uff08\u7956\u5148\u8282\u70b9\uff09 $size$\uff08\u5b50\u6811\u5927\u5c0f\uff09$son$\uff08\u91cd\u513f\u5b50\uff09 $d$\uff08\u6df1\u5ea6\uff09\n\u91cd\u513f\u5b50\u6307\u7684\u662f$size$\u8f83\u5927\u7684\u513f\u5b50\u8282\u70b9\u3002\n\u7b2c\u4e8c\u4e2aDFS \u7528\u6765\u6c42$top$\uff08\u8fd9\u6761\u94fe\u4e0a\u6700\u9876\u7aef\u7684\u70b9\uff09 $id$\uff08\u7f16\u53f7\uff09\u4ee5\u53ca\u5176\u4ed6\u7684\u8d4b\u503c\u64cd\u4f5c\u3002 \u4f46\u662f\u91cd\u513f\u5b50\u8981\u5148DFS\u3002\n\n```cpp\nconst int N = 1e5 + 10 ;\nstruct node { int v , nxt ; } ;\nnode e[N << 1] ;\nint head[N] , cnt = 0 ;\ninline void Add(int u , int v) { e[++ cnt].v = v ; e[cnt].nxt = head[u] ; head[u] = cnt ; }\nint size[N] , son[N] , d[N] ;\ninline void Dfs1(int u) { size[u] = 1 ;\n  for(register int i = head[u] ; i ; i = e[i].nxt) {\n    int v = e[i].v ; if(v == fa[u]) continue ; // \u9632\u6b62\u65e0\u9650\u9012\u5f52\u3002\n    d[v] = d[u] + 1 , fa[v] = u ,  // \u8bb0\u5f55\u6df1\u5ea6 \u4ee5\u53ca\u7236\u4eb2\u8282\u70b9\nDfs1(v) ; size[u] += size[v] ; //\u7b97\u51fa\u5b50\u6811\u5927\u5c0f\n    if(size[v] > size[son[u]]) son[u] = v ; //\u5f97\u51fau \u7684 \u91cd\u513f\u5b50\u662f son[u]\n  }\n}\nint top[N] , id[N] , tot = 0 ;\ninline void Dfs2(int u , int tp) { top[u] = tp , id[u] = ++ tot ;\n  if(! son[u]) return ; Dfs2(son[u] , tp) ;\n  for(register int i = head[u] ; i ; i = e[i].nxt) { int v = e[i].v ;\n    if(v ^ fa[u] && v ^ son[u]) Dfs2(v , v) ;\n  }\n}\n```\n\u8fd9\u6bb5\u4ee3\u7801\u6c42\u7684\u5c31\u662f\u4e0b\u56fe\u7684\u7ed3\u679c\u3002\n![](https://img2018.cnblogs.com/blog/1822694/201910/1822694-20191004153352152-318414229.png)\n\u5bf9\u4e8e\u8fd9\u5f20\u56fe $top$ \u6307\u7684\u662f\u91cd\u94fe\u4e0a\u6700\u9760\u4e0a\u7684\u4f4d\u7f6e\u3002\u5373\u94fe\u7684\u6700\u9ad8\u5904\u3002\n$Question:$ \u5982\u679c\u5bf9\u4e8e\u6700\u53f3\u4e0b\u7684\u90a3\u4e2a\u8282\u70b9 top \u662f\u81ea\u5df1 \u90a3\u4e48\u4e0d\u5c31\u6b7b\u5faa\u73af\u4e86\u5417 \uff1f\n\u8bf7\u8bfb\u8005\u4ed4\u7ec6\u601d\u8003\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\u5047\u88c5\u4f60\u4f1a\u7ebf\u6bb5\u6811\u4e86\u3002\n\u90a3\u4e48\u6211\u4eec\u60f3 \u600e\u4e48\u505a\u6811\u4e0a\u7684\u4fee\u6539\u5462\uff1f\n$id$ \u628a\u8fd9\u4e2a\u6811\u53d8\u6210\u4e00\u4e2a\u5e8f\u5217\u3002\n\u6ca1\u9519 \u5c31\u662f`\u8df3\u94fe`\u5bf9\u4e8e\u6bcf\u6761\u91cd\u94fe \u4f60\u53ef\u4ee5\u4e00\u4e0b\u5230\u9876\u7aef \u90a3\u4e48\u4f60\u76f4\u63a5\u4fee\u6539\u8fd9\u6761`\u91cd\u94fe`\u4e0a\u7684\u503c\u5c31\u53ef\u4ee5\u4e86\uff08\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\uff09\n\n\u4e07\u4e00 \u4e00\u6b21\u91cd\u94fe\u8df3\u4e0d\u5230\u90a3\u91cc\u600e\u4e48\u529e\uff1f\n\n\u90a3\u4e48\u8bf4\u660e\u4e86\u8fd9\u4e2a\u70b9\u5e76\u4e0d\u662f\u91cd\u513f\u5b50 \u6211\u4eec\u60f3\u529e\u6cd5\u8ba9\u5b83\u8df3\u4e0a\u53bb\u3002\n\n\u53cd\u590d\u5faa\u73af\u3002 DFS1\u4e2d\u8bb0\u5f55\u4e86\u7236\u4eb2\u8282\u70b9 \u4f60\u5c06\u5b83\u53d8\u6210\u5b83\u91cd\u94fe\u4e0a\u7684\u6700\u9ad8\u5904\u7684\u7236\u4eb2\u8282\u70b9\u3002\n\n\u56e0\u4e3a\u8fd9\u6761\u91cd\u94fe\u4fee\u6539\u8fc7\u4e86 \u6240\u4ee5\u4e0d\u7528\u7ba1\u91cd\u590d\u3002\u4e00\u76f4\u53cd\u590d\u8df3 \u5b83\u4f1a\u8df3\u5230 \u94fe\u7684 `LCA` \u5904 \u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u6c42`LCA`\u7684\u539f\u56e0\n\n\u5bf9\u4e8e\u4e0a\u9762\u7559\u4e0b\u7684\u95ee\u9898\u2026\u4e5f\u662f\u4e00\u4e2a\u5173\u4e8e\u590d\u6742\u5ea6\u7684\u8bc1\u660e\n\n\u5047\u8bbe\u6700\u574f\u60c5\u51b5 \u4f60\u7684\u4fee\u6539/\u67e5\u8be2\u7684\u70b9 \u6ca1\u6709\u4e00\u6761\u8fb9\u5728\u91cd\u94fe\u4e0a \u4f60\u6bcf\u6b21\u90fd\u8981 \u5f80\u4e0a `fa` \u4e00\u6b21\n\n\u4f46\u662f\u8fd9\u79cd\u60c5\u51b5 \u51fa\u73b0\u5728 \u6ee1\u591a\u53c9\u6811\u4e0a \u8fd9\u6837\u7684\u8bdd \u5c31\u662f\u6700\u574f\u7684\u590d\u6742\u5ea6 \u5373 $log\\ n$\n\u90a3\u4e48\u4e00\u822c\u8fd8\u8981\u5957\u4e00\u4e2a\u7ebf\u6bb5\u6811 \u6240\u4ee5 \u6700\u574f\u7684\u590d\u6742\u5ea6\u662f $n\\ log^2\\ n$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std ;\ninline int read() { register int res = 0 ; register char c ;\n#define gc c = getchar()\n    while(isspace(gc)) ;\n    while(res = (res << 1) + (res << 3) + (c & 15) , isdigit(gc)) ;\n    return res ;\n}\nint n , m , r , p ;\nconst int N = 1000000 + 5 ;\nstruct E{ int v ;int nxt ; } ;\nE edge[N << 1] ;\nint a[N] ; int fa[N] ; int w[N] ; int id[N] ; int son[N] ;\nint cnt = 0 ; int head[N] ; int Add[N << 2] , laz[N << 2] ;\nint dep[N] , siz[N] , t[N] ;\ninline void Add_Edge(register int u , register int v) { edge[++ cnt].v = v ; edge[cnt].nxt = head[u] ; head[u] = cnt ; return ; }//\u5efa\u8fb9\u3002\n#define l(x) x << 1\n#define r(x) x << 1 | 1\ninline void Push_down(register int x , register int len) {\n    laz[l(x)] += laz[x] ; laz[r(x)] += laz[x] ;\n    Add[l(x)] += laz[x] * (len - (len >> 1)) ; Add[r(x)] += laz[x] * (len >> 1) ;\n    Add[l(x)] %= p ; Add[r(x)] %= p ;\n    laz[x] = 0 ; return ;\n}\ninline void Build(register int l , register int r , register int rt) {//\u5efa\u6811\n    if(l == r) { Add[rt] = a[l] ;  return ; }\n    register int mid = l + r >> 1 ;\n    Build(l , mid , l(rt)) ; Build(mid + 1 , r , r(rt)) ;\n    Add[rt] = (Add[l(rt)] + Add[r(rt)]) % p ;\n}\ninline void Update(register int a , register int b , register int l  , register int r , register int rt , register int k) {//\u6b63\u5e38\u7684\u7ebf\u6bb5\u6811\u64cd\u4f5c\n    if(a <= l and r <= b) { laz[rt] += k ; Add[rt] += k * (r - l + 1) ; }\n    else {\n        if(laz[rt]) Push_down(rt , r - l + 1) ;\n        register int mid = l + r >> 1 ;\n        if(a <= mid) Update(a , b , l , mid , l(rt) , k) ;\n        if(b > mid) Update(a , b , mid + 1 , r , r(rt) , k) ;\n        Add[rt] = (Add[l(rt)] + Add[r(rt)]) % p ;\n    }\n}\nint res = 0 ;\ninline void query(register int a , register int b , register int  l , register int r , register int rt) {\n    if(a <= l and r <= b) { res = (res + Add[rt]) % p ; return ; }\n    else {\n        if(laz[rt]) Push_down(rt , r - l + 1) ;\n        register int mid = l + r >> 1 ;\n        if(a <= mid) query(a , b , l , mid , l(rt)) ;\n        if(b > mid) query(a , b , mid + 1 , r , r(rt)) ;\n    }\n}\ninline int Query(register int a , register int b , register int l , register int r , register int rt) {//\u6b63\u5e38\u7684\u7ebf\u6bb5\u6811\u64cd\u4f5c\n    res = 0 ; query(a , b , l , r , rt) ;\n    return res % p ;\n}\ninline void Upd_Range(register int x , register int y , register int k) {//\u94fe\u4e0a\u4fee\u6539\n    while(t[x] != t[y]) {\n        if(dep[t[x]] < dep[t[y]]) swap(x , y) ;\n         Update(id[t[x]] , id[x] , 1 , n , 1 , k) ;\n         x = fa[t[x]] ;\n    }\n    if(dep[x] > dep[y]) swap(x , y) ;\n    Update(id[x] , id[y] , 1 , n , 1 , k) ;\n}\ninline int Query_Range(register int x , register int y) {//\u94fe\u4e0a\u67e5\u8be2\n    int ans = 0 ;\n    while(t[x] != t[y]) {\n        if(dep[t[x]] < dep[t[y]]) swap(x , y) ;\n        ans += Query(id[t[x]] , id[x] , 1 , n , 1) ;\n        x = fa[t[x]] ;\n    }\n    if(dep[x] > dep[y]) swap(x , y) ;\n    ans += Query(id[x] , id[y] , 1 , n , 1) ;\n    return ans % p ;\n}\ninline int Qson(register int x) { return Query(id[x] , id[x] + siz[x] - 1 , 1 , n , 1) ; } // \u5b50\u6811\u67e5\u8be2\u3002\ninline void Updson(register int x , register int k) { Update(id[x] , id[x] + siz[x] - 1 , 1 , n , 1 , k) ; return ; }\ninline void Dfs1(register int x , register int f , register int deep) {\n    dep[x] = deep ; fa[x] = f ; siz[x] = 1 ;\n    int max_son = -1 ;\n    for(register int i = head[x] ; i ; i = edge[i].nxt) {\n        register int v = edge[i].v ;\n        if(v == f) continue ;\n        Dfs1(v , x , deep + 1) ;siz[x] += siz[v] ;\n        if(siz[v] > max_son) max_son = siz[v] , son[x] = v ;\n    }\n}\nint tot = 0 ;\ninline void Dfs2(register int x , register int tf) {\n    id[x] = ++ tot ; a[tot] = w[x] ; t[x] = tf ; // a \u6570\u7ec4\u91cd\u65b0\u8d4b\u503c\n    if(! son[x]) return ;\n    Dfs2(son[x] , tf) ;\n    for(register int i = head[x] ; i ; i = edge[i].nxt) {\n        int v = edge[i].v ;\n        if(v == fa[x] or v == son[x]) continue ;\n        Dfs2(v , v) ;\n    }\n}\nsigned main() {\n    n = read() ; m = read() ; r = read() ; p = read() ;\n    for(register int i = 1 ; i <= n ; i ++) w[i] = read() ;\n    for(register int i = 1 ; i <= n - 1 ; i ++) {\n        int u = read() , v = read() ;\n        Add_Edge(u , v) ;\n        Add_Edge(v , u) ;\n    }\n    Dfs1(r , 0 , 1) ; Dfs2(r , r) ; Build(1 , n , 1) ;\n    for( ; m -- ; ) {\n        register int opt = read() ;\n        if(opt == 1) {\n            register int x = read() , y = read() , k = read() ;\n            Upd_Range(x , y , k % p) ;\n        }\n        if(opt == 2) {\n            register int x = read() , y = read() ;\n            printf(\"%d\\n\" , Query_Range(x , y)) ;\n        }\n        if(opt == 3) {\n            register int x = read() , y = read() ;\n            Updson(x , y) ;\n        }\n        if(opt == 4) { printf(\"%d\\n\" , Qson(read())) ; }\n    }\n    return 0 ;\n}\n```\n\u8fd9\u5c31\u662f\u672c\u9898\u7684\u4ee3\u7801\n\n\u5982\u679c\u60f3\u77e5\u9053\u66f4\u591a\u5173\u4e8e\u6811\u5256 \u8bf7\u70b9\u51fb -> [$HERE$](https://www.cnblogs.com/Isaunoya/p/11619823.html)",
        "postTime": 1570176183,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "**\u849f\u84bb\u7684\u7b2c\u4e8c\u7bc7\u9898\u89e3**\n\n~~\u6211\u4e0d\u4f1a\u544a\u8bc9\u4f60\u4eec\u6211\u7b2c\u4e00\u7bc7\u5199\u7684\u662fa+b problem\u7684~~\n\n\u5173\u4e8e\u6811\u94fe\u5256\u5206\uff0c\u6211\u4eec\u4ece\u5206\u5c01\u5236\u8bf4\u8d77\u3002\n\n\u897f\u5468\u65f6\u671f\uff0c\u5929\u5b50\u5f88\u9ad8\u5174\uff0c\u4e8e\u662f\u5f88\u591a\u5f02\u59d3\u738b\uff0c\u5c01\u4faf\u8fdb\u7235\uff0c\u5f97\u5230\u4e86\u81ea\u5df1\u7684\u9886\u5730\u3002\u4f46\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\uff0c\u90a3\u4e9b\u4e71\u4e03\u516b\u7cdf\u5404\u79cd\u738b\u8d8a\u5206\u8d8a\u591a\uff0c\u6570\u91cf\u5448\u6307\u6570\u7ea7\u589e\u957f\u3002\u8fd9\u4e0b\u597d\u4e86\uff01\u9762\u5bf9\u8fd9\u4e48\u591a\u7684\u738b\uff0c\u5929\u5b50\u5bf9\u56fd\u5bb6\u8fdb\u884c\u7684\u4fee\u6539\u67e5\u8be2\u64cd\u4f5c\uff0c\u7eb7\u7eb7TLE\u3002\u540e\u6765\u5462\uff0c\u5f53\u6743\u8005\u7ec8\u4e8e\u5f00\u7a8d\u4e86\u3002\u4e8e\u662f\u5c31\u6709\u4e86\u957f\u5b50\u7ee7\u627f\u5236\u8fd9\u4e48\u4e2a\u4e1c\u897f\u3002\u957f\u5b50\u4e3a\u5927\u5b97\uff0c\u5176\u4ed6\u7684\u4e3a\u5c0f\u5b97\uff0c\u800c\u5c0f\u5b97\u5728\u81ea\u5df1\u7684\u9886\u5730\u53c8\u4e3a\u5927\u5b97\u3002\u8fd9\u6837\u4e00\u6765\uff0c\u4e16\u754c\u4fbf\u8d70\u4e0a\u4e86\u6b63\u8f68\u3002\n\n**\u76f8\u4fe1\u4f60\u4eec\u90fd\u770b\u51fa\u6765\u4e86\uff0c\u8fd9\u5c31\u662f\u6811\u3002**\n\n\u5728\u4e00\u68f5\u6811\u4e2d\uff0c\u4e00\u4e2a\u8282\u70b9\u4f1a\u6709\u5f88\u591a\u513f\u5b50\uff0c\u5728\u8fd9\u4f17\u591a\u7684\u513f\u5b50\u4e2d\uff0c\u90a3\u4e2a**\u552f\u4e00\u7684**\u7ee7\u627f\u5927\u7edf\u7684\u4eba\uff0c\u6211\u4eec\u53ef\u4ee5\u79f0\u4e4b\u4e3a\u201c\u5929\u547d\u4e4b\u5b50\u201d\uff0c\u5176\u4ed6\u4eba\u2026\u2026\u5c31\u53eb\u505a\u201c\u5e78\u8fd0E\u201d\u5427\u3002\n\n**\u5047\u8bbe**\uff1a\u5728\u4f17\u591a\u513f\u5b50\u4e2d\uff0c\u5982\u679c\u540e\u4ee3\u6700\u591a\u7684\u513f\u5b50\uff0c\u987a\u5929\u5e94\u4eba\uff0c\u7ee7\u627f\u5927\u7edf\u3002\u5728\u7b2c100\u4ee3\u7684\u540e\u4ee3\u91cc\uff0c\u627e\u4e00\u4e2a\u4eba\uff0c\u4ed6\u7684\u7956\u5148\u91cc\u9762\uff0c**\u901a\u5e38\u60c5\u51b5\u4e0b**\uff0c\u5929\u547d\u4e4b\u5b50\u591a\u5462\uff1f\u8fd8\u662f\u5e78\u8fd0E\u591a\u5462\uff1f\n\n\u7b54\u6848\u662f\uff0c\u5929\u547d\u4e4b\u5b50\u5c45\u591a\u3002\n\n**\u4e3a\u5565\uff1f**\n\n\u6bcf\u4e00\u4f4d\u5e78\u8fd0E\uff0c\u90fd\u4e00\u5b9a\u4e00\u5b9a\u4e00\u5b9a\u4f1a\u6709\u4e00\u4e2a\u4e0d\u8f93\u7ed9\u4ed6\u7684\u5144\u5f1f\uff01\u5982\u6b64\u4e00\u6765\uff0c\u8fd9\u4e2a\u5e78\u8fd0E\u7684\u7236\u4eb2\uff0c\u540e\u4ee3\u7684\u4eba\u6570\uff0c\u81f3\u5c11\u662f\u8fd9\u4f4d\u5e78\u8fd0E\u7684\u4e24\u500d\u3002\uff08\u90a3\u4e48\uff0c\u5982\u679c\u8fd9\u4e2a\u4eba\u7684\u7956\u5148\uff0c\u653e\u773c\u671b\u53bb\u5168\u662f\u5e78\u8fd0E\uff0c\u4eba\u53e3\u95ee\u9898\u5c31\u4f1a\u6210\u4e3a\u8fd9\u4e2a\u4e16\u754c\u7684\u4e3b\u8981\u95ee\u9898\u2026\u2026\uff09\u54b3\u54b3\uff0c\u56de\u5f52\u6b63\u9898\u3002\u6240\u4ee5\u5462\uff0c\u5f53\u4eba\u53e3\u5728$2^{50}$\u4ee5\u4e0b\u65f6\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u8ba4\u4e3a\u5929\u547d\u4e4b\u5b50\u5c45\u591a\u3002\n\n\u8fd9\u4e2a\u5047\u8bbe\u5c31\u7c7b\u4f3c\u4e8e**\u8f7b\u91cd\u94fe\u5256\u5206**\uff08heavy-light decomposition\uff09\n\n\u6545\u4e8b\u5c31\u544a\u4e00\u6bb5\u843d\u3002\u8bf4\u4e00\u4e0b\u6811\u94fe\u5256\u5206\u7684\u51e0\u4e2a\u6982\u5ff5\uff1a\n\n\u91cd\u513f\u5b50\uff1asize\u6700\u5927\u7684\u513f\u5b50\u3002\n\n\u8f7b\u513f\u5b50\uff1a\u4e0d\u662f\u91cd\u513f\u5b50\u7684\u513f\u5b50\u3002\n\n\u91cd\uff08zhong\uff09\u8fb9\uff1a\u7236\u4eb2\u8fde\u5230\u91cd\u513f\u5b50\u7684\u8fb9\u3002\n\n\u8f7b\u8fb9\uff1a\u7236\u4eb2\u8fde\u5230\u8f7b\u513f\u5b50\u7684\u8fb9\u3002\n\n\u91cd\u94fe\uff1a\u91cd\u8fb9\u7ec4\u6210\u7684\u94fe\u3002\n\n\u6811\u94fe\u5256\u5206\uff1a\u628a\u4e00\u68f5\u6811\u5206\u6210\u51e0\u4e2a\u91cd\u94fe\u3002\n\n\u6811\u94fe\u5256\u5206\u5927\u4f53\u601d\u8def\u4e3a\uff1a\n\n1.\u628a\u6811\u201c\u70b8\u201d\u6210\u51e0\u4e2a\u788e\u7247\uff0c\u6bcf\u4e2a\u788e\u7247\u4e3a\u91cd\u94fe\uff1b\n2.\u8def\u5f84\u4fee\u6539\uff1a\u6311\u51fa\u51e0\u5757\u80fd\u7ec4\u6210\u8fd9\u6761\u8def\u5f84\u7684\u788e\u7247\uff0c\u518d\u4fee\u6539\u788e\u7247\u3002\n3.\u8def\u7ecf\u67e5\u8be2\uff1a\u540c\uff082\uff09.\n\n\u5728\u89e3\u51b3\u51e0\u4e2a\u95ee\u9898\uff1a\n\n1.\u50a8\u5b58\u91cd\u94fe\uff1a\u6211\u4eec\u7528`top[u]`\u8bb0\u5f55\u70b9u\u6240\u5728\u91cd\u94fe\uff0c\u6df1\u5ea6\u6700\u4f4e\u7684\u8282\u70b9\u30022.\u9ad8\u6548\u67e5\u8be2\u4fee\u6539\uff1a\u6c42DFS\u5e8f\uff0c\u5148\u91cd\u513f\u5b50\u518d\u8f7b\u513f\u5b50\u30023.\u62c6\u8def\u5f84\u4e3a\u91cd\u94fe\uff1a\u5bf9\u4e8e\u8def\u5f84(u,v)\uff0c\u5982\u679cu\uff0cv\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u8fd4\u56de\uff1b\u5426\u5219\uff0c\u9009\u51fatop\u5bf9\u5e94\u7684\u8282\u70b9\u6df1\u5ea6\u66f4\u6df1\u7684\u70b9x\uff0c\u4ecex\u5230`top[x]`\u7684\u91cd\u94fe\u5c31\u662f\u6211\u4eec\u60f3\u8981\u7684\u788e\u7247\u4e4b\u4e00\uff0c\u5e76\u628a\u5b83\u79fb\u52a8\u5230`top[x]`\u7684\u7236\u4eb2\u3002\n\n\u4e24\u904dDFS\u518d\u5efa\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u4e0b\u9762\uff0c\u76f4\u63a5\u4e0aAC\u4ee3\u7801\uff1a\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 10;\nstruct edge {\n    int next, to;\n} e[maxn * 2];\nstruct node {\n    int l, r;\n    int ls, rs;\n    int sum, lazy;\n} a[maxn * 2];  //\u7ebf\u6bb5\u6811\nint n, m, r, rt, mod, cnt;\nint v[maxn], head[maxn];\nint f[maxn], d[maxn], son[maxn], size[maxn], top[maxn], id[maxn], rk[maxn];\nvoid add (int x,int y) {\n    e[++cnt].next = head[x];\n    e[cnt].to = y;\n    head[x] = cnt;\n}\nvoid dfs1 (int x) {\n    size[x] = 1, d[x] = d[f[x]] + 1;\n    for (int v, i = head[x]; i; i = e[i].next) if ((v = e[i].to) != f[x]) {\n        f[v] = x, dfs1(v), size[x] += size[v];\n    \tif (size[son[x]] < size[v]) son[x] = v;\n    }\n}\nvoid dfs2 (int x, int tp) {\n    top[x] = tp, id[x] = ++cnt, rk[cnt] = x;\n    if (son[x]) dfs2(son[x], tp);\n    for(int v, i = head[x]; i; i = e[i].next)\n        if((v = e[i].to) != f[x] && v != son[x]) dfs2(v, v);\n}\nvoid pushup (int x) {\n    a[x].sum = (a[a[x].ls].sum + a[a[x].rs].sum) % mod;\n}\nvoid build (int l, int r, int x) {\n    if (l == r) {\n        a[x].sum = v[rk[l]], a[x].l = a[x].r = l;\n        return;\n    }\n    int mid = l + r >> 1;\n    a[x].ls = cnt++, a[x].rs = cnt++;\n    build(l, mid, a[x].ls), build(mid + 1, r, a[x].rs);\n    a[x].l = a[a[x].ls].l, a[x].r = a[a[x].rs].r;\n    pushup (x);\n}\nint len (int x) {\n    return a[x].r - a[x].l + 1;\n}\nvoid pushdown (int x) {\n    if (a[x].lazy) {\n        int ls = a[x].ls, rs = a[x].rs, lz = a[x].lazy;\n        (a[ls].lazy += lz) %= mod, (a[rs].lazy += lz) %= mod;\n        (a[ls].sum += lz * len(ls)) %= mod, (a[rs].sum += lz * len(rs)) %= mod;\n        a[x].lazy = 0;\n    }\n}\nvoid update (int l, int r, int c, int x) {\n    if(a[x].l >= l && a[x].r <= r) {\n        (a[x].lazy += c) %= mod, (a[x].sum += len(x) * c) %= mod;\n        return;\n    }\n    pushdown (x);\n    int mid = a[x].l + a[x].r >> 1;\n    if(mid >= l) update(l, r, c, a[x].ls);\n    if(mid < r) update(l, r, c, a[x].rs);\n    pushup (x);\n}\nint query (int l, int r, int x) {\n    if(a[x].l >= l && a[x].r <= r) return a[x].sum;\n    pushdown (x);\n    int mid = a[x].l + a[x].r >> 1, tot=0;\n    if(mid >= l) tot += query(l, r, a[x].ls);\n    if(mid < r) tot += query(l, r, a[x].rs);\n    return tot % mod;\n}\nint sum (int x,int y) {\n    int ret = 0;\n    while (top[x] != top[y]) {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        (ret += query(id[top[x]], id[x], rt)) %= mod;\n        x = f[top[x]];\n    }\n    if(id[x] > id[y]) swap(x, y);\n    return (ret + query(id[x], id[y], rt)) % mod;\n}\nvoid updates (int x, int y, int c) {\n    while (top[x] != top[y]) {\n        if(d[top[x]] < d[top[y]]) swap(x, y);\n        update(id[top[x]], id[x], c, rt);\n        x = f[top[x]];\n    }\n    if(id[x] > id[y]) swap(x, y);\n    update(id[x], id[y], c, rt);\n}\nint main () {\n    scanf (\"%d %d %d %d\", &n, &m, &r, &mod);\n    for(int i = 1; i <= n; i++) scanf (\"%d\", &v[i]);\n    int op, x, y, k;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d %d\", &x, &y);\n        add (x, y), add (y, x);\n    }\n    cnt = 0, dfs1(r), dfs2(r, r);\n    cnt = 0, build(1, n, rt = cnt++);\n    for(int i = 1; i <= m; i++) {\n        scanf (\"%d\", &op);\n        if (op == 1) {\n            scanf(\"%d %d %d\", &x, &y, &k);\n            updates(x, y, k);\n        } else if (op == 2) {\n            scanf(\"%d %d\", &x, &y);\n            printf(\"%d\\n\", sum(x, y));\n        } else if (op == 3) {\n        \tscanf (\"%d %d\", &x, &y);\n        \tupdate (id[x], id[x] + size[x] - 1, y, rt);\n\t\t} else {\n\t\t\tscanf (\"%d\", &x);\n\t\t\tprintf (\"%d\\n\", query (id[x], id[x] + size[x] - 1, rt));\n\t\t}\n    }\n    return 0;\n}\n```\n\u6c42\u8fc7\n>\u5b66\u4e60\u4f7f\u6211\u5feb\u4e50\uff0c\u6211\u5b81\u613f\u4e0d\u5feb\u4e50",
        "postTime": 1565326289,
        "uid": 103120,
        "name": "54Teddy",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\n\n\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u8bf7[\u6233\u8fd9\u91cc](https://www.nerlci.ml/201812152.html)QwQ\n\n### 0.\u7b80\u4ecb\n\n\u6811\u94fe\u5256\u5206\u662f\u4e00\u79cd\u57fa\u4e8e\u7ebf\u6bb5\u6811\u7684\u4f18\u96c5\u7684\u6811\u4e0a\u70b9\u6743\uff08\u8fb9\u6743\uff09\u548c\u7ef4\u62a4\u7b97\u6cd5\u3002\u4f7f\u7528\u6811\u94fe\u5256\u5206\u6211\u4eec\u53ef\u4ee5\u5728$O(nlog^{2}n)$\u7684\u4f18\u79c0\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u5b9e\u73b0\u5bf9\u6811\u4e0a\u4e00\u6761\u94fe\u4e0a\u7684\u70b9\u6743\uff08\u8fb9\u6743\uff09\u7684\u67e5\u8be2\u4e0e\u4fee\u6539\u64cd\u4f5c\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6811\u94fe\u5256\u5206\u5bf9\u4e8e\u6811\u5f62\u6001\u7684\u53d8\u5316\u8f83\u96be\u4ee5\u7ef4\u62a4\u3002\u7531\u4e8e\u5f62\u6001\u53d8\u5316\u540e\u5fc5\u987b\u5bf9\u6811\u8fdb\u884c\u91cd\u65b0\u5256\u5206\uff0c\u624d\u80fd\u7ee7\u7eed\u4f7f\u7528\u7ebf\u6bb5\u6811\u5bf9\u6811\u4e0a\u4fe1\u606f\u8fdb\u884c\u7ef4\u62a4\u3002\u800c\u6bcf\u6b21\u5256\u5206\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n)$\uff0c\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u79cd\u60c5\u51b5\u6211\u4eec\u9700\u8981\u66f4\u6362\u6362\u5176\u4ed6\u7b97\u6cd5\uff0c\u5982\u52a8\u6001\u6811\u7b49\uff0c\u672c\u6587\u4e0d\u6d89\u53ca\u3002\n\n### 1.\u6982\u5ff5\n\n\u6811\u94fe\u5256\u5206\u5f15\u5165\u4e86\u51e0\u4e2a\u6982\u5ff5\uff1a\n\u91cd\u513f\u5b50\uff1a\u8be5\u7236\u4eb2\u6240\u6709\u513f\u5b50\u4e2d\u5b50\u6811\u5927\u5c0f\u6700\u5927\u7684\u513f\u5b50\n\u8f7b\u513f\u5b50\uff1a\u9664\u91cd\u513f\u5b50\u4ee5\u5916\u7684\u5176\u4ed6\u513f\u5b50\n\u91cd\u8fb9\uff1a\u7236\u4eb2\u4e0e\u91cd\u513f\u5b50\u4e4b\u95f4\u76f8\u8fde\u7684\u8fb9\n\u8f7b\u8fb9\uff1a\u7236\u4eb2\u4e0e\u8f7b\u513f\u5b50\u4e4b\u95f4\u76f8\u8fde\u7684\u8fb9\n\u91cd\u94fe\uff1a\u7531\u91cd\u513f\u5b50\u76f8\u8fde\u5f62\u6210\u7684\u4e00\u6761\u94fe\n\n\u4e0b\u56fe\u5373\u4e3a\u4e00\u68f5\u5256\u5206\u5b8c\u6210\u7684\u6811\uff1a\n\n![\u6811\u94fe\u5256\u5206](https://i.loli.net/2018/12/22/5c1e2fd1894fc.png)\n\n\u5982\u56fe\u6240\u793a\uff0c\u6240\u6709\u84dd\u8272\u7684\u8282\u70b9\u5747\u4e3a\u5176\u7236\u8282\u70b9\u7684\u91cd\u513f\u5b50\uff0c\u6240\u6709\u84dd\u8272\u7684\u8fb9\u5747\u4e3a\u91cd\u8fb9\uff0c\u84dd\u8272\u8fb9\u8fde\u6210\u7684\u94fe\u5373\u4e3a\u91cd\u94fe\uff0c\u4e0b\u540c\u3002\n\u6811\u94fe\u5256\u5206\u5219\u662f\u5229\u7528\u91cd\u94fe\uff0c\u5bf9\u6240\u6709\u91cd\u94fe\u4e0a\u7684\u503c\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5927\u5927\u52a0\u5feb\u67e5\u8be2\u548c\u7684\u901f\u5ea6\u3002\n\n### 2.\u5b9e\u73b0\n#### \u5256\u5206\n\n\u6811\u94fe\u5256\u5206\u7684\u5b9e\u73b0\u57fa\u4e8e\u4e24\u6b21DFS\u3002\n\n\u7b2c\u4e00\u6b21DFS\uff0c\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u5b50\u6811\u7684\u5927\u5c0f\u3001\u8282\u70b9\u7684\u6df1\u5ea6\u548c\u8fd9\u4e2a\u8282\u70b9\u7684\u91cd\u513f\u5b50\u3002\n\n\u7b2c\u4e8c\u6b21DFS\uff0c\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u6240\u5728\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u7684\u7f16\u53f7\u548cDFS\u5e8f\u3002\u6211\u4eec\u4ee4\u540c\u4e00\u6761\u91cd\u94fe\u7684DFS\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u8fd9\u6761\u94fe\u6216\u94fe\u4e0a\u67d0\u4e00\u6bb5\u7684\u70b9\u6743\uff08\u8fb9\u6743\uff09\u548c\u3002\n\n\u4e0b\u9762\u7ed3\u5408\u4ee3\u7801\u5206\u6790\u8fd9\u4e24\u6b21DFS\u7684\u8fc7\u7a0b\u3002\n\n\u4ee3\u7801\u4e2d\u51fa\u73b0\u7684\u53d8\u91cf\u540d\u53ca\u542b\u4e49\uff1a\n\n| \u53d8\u91cf\u540d | \u542b\u4e49 |\n| :------------: | :------------: |\n| p | \u7236\u4eb2 |\n| h | \u6df1\u5ea6 |\n| size | \u5b50\u6811\u5927\u5c0f |\n| hvy | \u91cd\u513f\u5b50\u7f16\u53f7 |\n| top | \u8be5\u8282\u70b9\u6240\u5728\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u7684\u7f16\u53f7 |\n| d | \u8be5\u8282\u70b9\u7684DFS\u5e8f |\n\n__\u7b2c\u4e00\u6b21DFS__\n\n```cpp\nvoid dfs(int s) {\n  for (int i = node[s].f_edge; i; i = e[i].n) {\n    if (e[i].to == node[s].p) { continue; } //\u9632\u6b62\u8bbf\u95ee\u5230\u7236\u8282\u70b9\n    node[e[i].to].p = s; //\u513f\u5b50\u7684\u7236\u8282\u70b9\u5373\u4e3a\u5f53\u524d\u8282\u70b9\n    node[e[i].to].h = node[s].h + 1; //\u513f\u5b50\u7684\u6df1\u5ea6\u4e3a\u7236\u8282\u70b9\u6df1\u5ea6\u52a0\u4e00\n    dfs(e[i].to); //\u8bbf\u95ee\u513f\u5b50\n    node[s].size += node[e[i].to].size; //\u7236\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u4e3a\u6240\u6709\u513f\u5b50\u8282\u70b9\u5b50\u6811\u5927\u5c0f\u4e4b\u548c\n    if (node[e[i].to].size > node[node[s].hvy].size) { //\u5982\u679c\u8be5\u513f\u5b50\u6bd4\u539f\u5148\u7684\u91cd\u513f\u5b50\u5b50\u6811\u5927\u5c0f\u66f4\u5927\u5219\n      node[s].hvy = e[i].to; //\u8be5\u513f\u5b50\u4e3a\u91cd\u513f\u5b50\n    }\n  }\n  node[s].size += 1; //\u5b50\u6811\u5927\u5c0f\u5305\u62ec\u5f53\u524d\u8282\u70b9\n}\n```\n\u7b2c\u4e00\u6b21DFS\u4e2d\u6211\u4eec\u6bcf\u8bbf\u95ee\u8fc7\u4e00\u4e2a\u513f\u5b50\uff0c\u5c31\u5c06\u8be5\u5b69\u5b50\u7684`size`\u4e0e\u5f53\u524d\u7684\u91cd\u513f\u5b50\u7684`size`\u6bd4\u8f83\uff0c\u82e5\u8be5\u513f\u5b50\u7684`size`\u6bd4\u91cd\u513f\u5b50\u5927\uff0c\u5219\u5c06\u91cd\u513f\u5b50\u53d8\u4e3a\u8be5\u513f\u5b50\u3002\n\u5728\u7b2c\u4e00\u6b21DFS\u8fd0\u884c\u5b8c\u6210\u4e4b\u540e\uff0c\u6211\u4eec\u5f97\u5230\u4ee5\u4e0b\u4fe1\u606f\u3002\n\n![graph.png](https://i.loli.net/2018/12/23/5c1f144e40a8e.png)\n\n| \u7f16\u53f7 | p | h | size | hvy |\n| :------------: | :------------: | :------------: | :------------: | :------------: |\n| 1 | 0 | 0 | 14 | 4 |\n| 2 | 1 | 1 | 5 | 6 |\n| 3 | 1 | 1 | 2 | 7 |\n| 4 | 1 | 1 | 6 | 9 |\n| 5 | 2 | 2 | 1 | 0 |\n| 6 | 2 | 2 | 3 | 11 |\n| 7 | 3 | 2 | 1 | 0 |\n| 8 | 4 | 2 | 1 | 0 |\n| 9 | 4 | 2 | 3 | 13 |\n| 10 | 4 | 2 | 1 | 0 |\n| 11 | 6 | 3 | 1 | 0 |\n| 12 | 6 | 3 | 1 | 0 |\n| 13 | 9 | 3 | 2 | 14 |\n| 14 | 13 | 4 | 1 | 0 |\n\n\u6b64\u65f6\u6240\u6709\u8282\u70b9\u7684\u91cd\u513f\u5b50\u90fd\u5df2\u88ab\u8ba1\u7b97\u51fa\u6765\u3002\u7b2c\u4e8c\u6b21DFS\u4e2d\uff0c\u6211\u4eec\u8ba1\u7b97\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684DFS\u5e8f\u548c\u6240\u5728\u91cd\u94fe\u9876\u7aef\u7684\u7f16\u53f7\uff08\u7528\u4e8e\u6c42LCA\u65f6\u52a0\u901f\uff09\u3002\n\n```cpp\nvoid subdiv(int s, int h) { //h\u4e3a\u5f53\u524d\u91cd\u94fe\u9876\u7aef\n  node[s].top = h; //\u5c06\u5f53\u524d\u8282\u70b9\u6240\u5728\u7684\u91cd\u94fe\u9876\u7aef\u7f16\u53f7\u8d4b\u503c\u4e3ah\n  node[s].d = cnt++; //\u8d4b\u503cDFS\u5e8f\n  sg.insert(1, node[s].d, node[s].d, node[s].v); //\u5c06\u5f53\u524d\u8282\u70b9\u70b9\u6743\u52a0\u5165\u7ebf\u6bb5\u6811\u7ef4\u62a4\n  if (!node[s].hvy) { return; } //\u65e0\u91cd\u513f\u5b50\u5219\u662f\u53f6\u8282\u70b9\uff0c\u65e0\u9700\u6267\u884c\u4e0b\u9762\u8bbf\u95ee\u8282\u70b9\u7684\u64cd\u4f5c\n  subdiv(node[s].hvy, h); //\u5148\u8bbf\u95ee\u91cd\u513f\u5b50\uff0c\u4fdd\u8bc1DFS\u5e8f\u8fde\u7eed\n  for (int i = node[s].f_edge; i; i = e[i].n) {\n    if (e[i].to == node[s].p || e[i].to == node[s].hvy) { continue; } //\u9632\u6b62\u8bbf\u95ee\u7236\u8282\u70b9\u548c\u91cd\u513f\u5b50\n    subdiv(e[i].to, e[i].to); //\u8f7b\u513f\u5b50\u6240\u5728\u7684\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u4e00\u5b9a\u662f\u4ed6\u672c\u8eab\n  }\n}\n```\n\u7b2c\u4e8c\u6b21DFS\u540e\u6211\u4eec\u5f97\u51fa\u6bcf\u4e2a\u8282\u70b9\u6240\u5728\u7684\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u7684\u7f16\u53f7\u548cDFS\u5e8f\uff0c\u5e76\u5c06\u6bcf\u4e2a\u8282\u70b9\u7684\u4fe1\u606f\u52a0\u5165\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n![\u6811\u94fe\u5256\u5206](https://i.loli.net/2018/12/22/5c1e2fd1894fc.png)\n\n| \u7f16\u53f7 | top | d |\n| :------------: | :------------: | :------------: |\n| 1 | 1 | 1 |\n| 2 | 2 | 8 |\n| 3 | 3 | 13 |\n| 4 | 1 | 2 |\n| 5 | 5 | 12 |\n| 6 | 2 | 9 |\n| 7 | 3 | 14 |\n| 8 | 8 | 6 |\n| 9 | 1 | 3 |\n| 10 | 10 | 7 |\n| 11 | 2 | 10 |\n| 12 | 12 | 11 |\n| 13 | 1 | 4 |\n| 14 | 1 | 5 |\n\n(\u6ce8\u610f\uff0cDFS\u5e8f\u56e0\u5efa\u8fb9\u987a\u5e8f\u4e0d\u540c\u53ef\u80fd\u6709\u53d8\u5316\uff0c\u4e0a\u8868\u53ea\u662f\u4e00\u79cd\u53ef\u80fd\u7684DFS\u5e8f)\n\n\u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u6811\u94fe\u5256\u5206\u7684\u91cd\u8981\u90e8\u5206\u2014\u2014\u5256\u5206\u3002\u7ecf\u8fc7\u4e24\u6b21DFS\uff0c\u6211\u4eec\u5c06\u6811\u5256\u5206\u6210\u4e86\u591a\u6761\u94fe\uff0c\u5e76\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u6761\u94fe\u4e0a\u7684\u4fe1\u606f\u3002\n\n#### \u67e5\u8be2\n\u6839\u636eDFS\u5e8f\u7684\u8fde\u7eed\u6027\uff0c\u540c\u4e00\u68f5\u5b50\u6811\u4e0a\u7684DFS\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u8f7b\u677e\u7684\u5199\u51fa\u67e5\u8be2\u67d0\u8282\u70b9\u5b50\u6811\u7684\u70b9\u6743\u548c\u7684\u64cd\u4f5c\uff1a\n\n```cpp\nint sum(int n) {\n  return sg.query(1, node[n].d, node[n].d + node[n].size - 1) % mod;\n}\n```\n\n\u662f\u7684\uff0c\u6781\u5176\u7b80\u5355\u7684\u4e00\u884c\u7ebf\u6bb5\u6811\u67e5\u8be2\u64cd\u4f5c\uff0c\u8fd9\u5c31\u662fDFS\u5e8f\u8fde\u7eed\u5e26\u6765\u7684\u4fbf\u5229\u3002\n\n\u90a3\u4e48\u5982\u4f55\u67e5\u8be2\u4e24\u70b9\u4e4b\u95f4\u7684\u5168\u90e8\u70b9\u6743\u4e4b\u548c\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u7ed3\u5408\u4ee3\u7801\u5206\u6790\uff1a\n\n```cpp\nint sum(int x, int y) {\n  int fx = node[x].top, fy = node[y].top, ans = 0;\n  while (fx != fy) { //\u5f53\u4e24\u8282\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u65f6\n    if (node[fx].h >= node[fy].h) { //\u4ece\u6df1\u5ea6\u5927\u7684\u4e00\u8fb9\u5f00\u59cb\u5f80\u4e0a\u8df3\n      ans = ans + sg.query(1, node[fx].d, node[x].d);  //\u52a0\u4e0a\u8fd9\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u6743\u548c\n      x = node[fx].p; //\u5411\u4e0a\u8df3\u4e00\u6b21\n      fx = node[x].top;\n    } else { //\u540c\u4e0a\n      ans = ans + sg.query(1, node[fy].d, node[y].d);\n      y = node[fy].p;\n      fy = node[y].top;\n    }\n  }\n  if (node[x].d <= node[y].d) { //\u4e24\u70b9\u8df3\u5230\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\u540e\n    ans = ans + sg.query(1, node[x].d, node[y].d); //\u52a0\u4e0a\u8fd9\u4e24\u70b9\u4e4b\u95f4\u7684\u70b9\u6743\u548c\n  } else {\n    ans = ans + sg.query(1, node[y].d, node[x].d);\n  }\n  return ans;\n}\n```\n\n\u6211\u4eec\u5229\u7528DFS\u5e8f\u7684\u8fde\u7eed\u6027\uff0c\u5728$O(logn)$\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u6c42\u51fa\u4e00\u6761\u94fe\u4e0a\u7684\u70b9\u6743\u548c\uff0c\u5927\u5927\u52a0\u5feb\u4e86\u7edf\u8ba1\u4e24\u70b9\u4e4b\u95f4\u70b9\u6743\u548c\u7684\u901f\u5ea6\u3002\n\n### \u4fee\u6539\n\n\u4fee\u6539\u548c\u67e5\u8be2\u540c\u7406\uff0c\u5c06\u7ebf\u6bb5\u6811\u67e5\u8be2\u6539\u4e3a\u4fee\u6539\u5373\u53ef\uff0c\u8fd9\u90e8\u5206\u5c31\u4ea4\u7ed9\u5404\u4f4d\u81ea\u5df1\u5b8c\u6210=v\n\n## 3.\u65f6\u95f4\u590d\u6742\u5ea6\n\u6811\u94fe\u5256\u5206\u7684\u4e24\u4e2a\u6027\u8d28\uff1a\n\n1. \u5982\u679c(u, v)\u662f\u4e00\u6761\u8f7b\u8fb9\uff0c\u90a3\u4e48size(v) < size(u)/2\uff1b\n2. \u4ece\u6839\u7ed3\u70b9\u5230\u4efb\u610f\u7ed3\u70b9\u7684\u8def\u6240\u7ecf\u8fc7\u7684\u8f7b\u91cd\u94fe\u7684\u4e2a\u6570\u5fc5\u5b9a\u90fd\u5c0f\u4e8elogn.\n\n\u53ef\u4ee5\u8bc1\u660e\uff0c\u6811\u94fe\u5256\u5206\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(nlog^2n)$\n\n## 4.\u4ee3\u7801\n\u4ee5\u4e0b\u4ee3\u7801\u4ee5[Luogu P3384](https://www.luogu.org/problemnew/show/P3384)\u4e3a\u4f8b\n\n```cpp\n#include <iostream>\n#include <cstdio>\nusing namespace std;\n\nint mod = 2147483647;\n\nstruct Segment {\n  int l, r, v, tag;\n  Segment() {\n    l = 0;\n    r = 0;\n    v = 0;\n    tag = 0;\n  }\n};\n\nstruct SegmentTree {\n  Segment node[4000010];\n\n  inline int lc(int n) { return (n << 1); }\n  inline int rc(int n) { return ((n << 1) | 1); } \n  inline int mid(int l, int r) { return ((l + r) >> 1); }\n\n  void push_up(int n) {\n    node[n].v = (node[lc(n)].v + node[rc(n)].v) % mod;\n  }\n\n  void build(int n, int l, int r) {\n    node[n].l = l;\n    node[n].r = r;\n    if (l == r) { return; }\n    build(lc(n), l, mid(l, r));\n    build(rc(n), mid(l, r) + 1, r);\n  }\n\n  void push_down(int n) {\n    node[lc(n)].v = (node[lc(n)].v + node[n].tag * (node[lc(n)].r - node[lc(n)].l + 1)) % mod;\n    node[rc(n)].v = (node[rc(n)].v + node[n].tag * (node[rc(n)].r - node[rc(n)].l + 1)) % mod;\n    node[lc(n)].tag = (node[lc(n)].tag + node[n].tag) % mod;\n    node[rc(n)].tag = (node[rc(n)].tag + node[n].tag) % mod;\n    node[n].tag = 0;\n  }\n\n  void insert(int n, int l, int r, int v) {\n    if (l <= node[n].l && r >= node[n].r) {\n      node[n].v = (node[n].v + (node[n].r - node[n].l + 1) * v) % mod;\n      node[n].tag = (node[n].tag + v) % mod;\n      return;\n    }\n    if (node[n].tag) { push_down(n); }\n    int m = mid(node[n].l, node[n].r);\n    if (l <= m) { insert(lc(n), l, r, v); }\n    if (r > m) { insert(rc(n), l, r, v); }\n    push_up(n);\n  }\n\n  int query(int n, int l, int r) {\n    if (l <= node[n].l && r >= node[n].r) {\n      return node[n].v % mod;\n    }\n    if (node[n].tag) { push_down(n); }\n    int m = mid(node[n].l, node[n].r);\n    int res = 0;\n    if (l <= m) { res = (res + query(lc(n), l, r)) % mod; }\n    if (r > m) {\n      res = (res + query(rc(n), l, r)) % mod;\n    }\n    return res % mod;\n  }\n};\n\nstruct Node {\n  int h, d, hvy, top, f_edge, l_edge, p, size, v;\n};\n\nstruct Edge {\n  int fr, to, n;\n};\n\nstruct Graph {\n  Node node[1000010];\n  Edge e[1000010];\n  SegmentTree sg;\n  int r, last, cnt, n;\n\n  Graph() {\n    last = 1;\n    cnt = 1;\n    n = 0;\n  }\n\n  void connect(int fr, int to) {\n    if (!node[fr].f_edge) {\n      node[fr].f_edge = last;\n      node[fr].l_edge = last;\n    } else {\n      e[node[fr].l_edge].n = last;\n      node[fr].l_edge = last;\n    }\n    e[last].fr = fr;\n    e[last].to = to;\n    ++last;\n  }\n\n  void dfs(int s) {\n    for (int i = node[s].f_edge; i; i = e[i].n) {\n      if (e[i].to == node[s].p) { continue; }\n      node[e[i].to].p = s;\n      node[e[i].to].h = node[s].h + 1;\n      dfs(e[i].to);\n      node[s].size += node[e[i].to].size;\n      if (node[e[i].to].size > node[node[s].hvy].size) {\n        node[s].hvy = e[i].to;\n      }\n    }\n    node[s].size += 1;\n  }\n\n  void subdiv(int s, int h) {\n    node[s].top = h;\n    node[s].d = cnt++;\n    sg.insert(1, node[s].d, node[s].d, node[s].v);\n    if (!node[s].hvy) { return; }\n    subdiv(node[s].hvy, h);\n    for (int i = node[s].f_edge; i; i = e[i].n) {\n      if (e[i].to == node[s].p || e[i].to == node[s].hvy) { continue; }\n      subdiv(e[i].to, e[i].to);\n    }\n  }\n\n  void subdiv() {\n    sg.build(1, 1, n);\n    node[r].h = 0;\n    dfs(r);\n    subdiv(r, r);\n  }\n\n  int sum(int n) {\n    return sg.query(1, node[n].d, node[n].d + node[n].size - 1) % mod;\n  }\n\n  int sum(int x, int y) {\n    int fx = node[x].top, fy = node[y].top, ans = 0;\n    while (fx != fy) {\n      if (node[fx].h >= node[fy].h) {\n        ans = (ans + sg.query(1, node[fx].d, node[x].d)) % mod;\n        x = node[fx].p;\n        fx = node[x].top;\n      } else {\n        ans = (ans + sg.query(1, node[fy].d, node[y].d)) % mod;\n        y = node[fy].p;\n        fy = node[y].top;\n      }\n    }\n    if (node[x].d <= node[y].d) {\n      ans = (ans + sg.query(1, node[x].d, node[y].d)) % mod;\n    } else {\n      ans = (ans + sg.query(1, node[y].d, node[x].d)) % mod;\n    }\n    return ans % mod;\n  }\n  void modify(int n, int v) {\n    sg.insert(1, node[n].d, node[n].d + node[n].size - 1, v);\n  }\n  void modify(int x, int y, int v) {\n    int fx = node[x].top, fy = node[y].top;\n    while (fx != fy) { if (node[fx].h >= node[fy].h) {\n        sg.insert(1, node[fx].d, node[x].d, v);\n        x = node[fx].p;\n        fx = node[x].top;\n      } else {\n        sg.insert(1, node[fy].d, node[y].d, v);\n        y = node[fy].p;\n        fy = node[y].top;\n      }\n    }\n    if (node[x].d <= node[y].d) {\n      sg.insert(1, node[x].d, node[y].d, v);\n    } else {\n      sg.insert(1, node[y].d, node[x].d, v);\n    }\n  }\n};\n\nint n, m;\nGraph g;\n\nint main() {\n  scanf(\"%d %d %d %d\", &n, &m, &g.r, &mod);\n  g.n = n;\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &g.node[i].v);\n  }\n  for (int i = 1; i < n; i++) {\n    int fr, to;\n    scanf(\"%d %d\", &fr, &to);\n    g.connect(fr, to);\n    g.connect(to, fr);\n  }\n  g.subdiv();\n  for (int i = 1; i <= m; i++) {\n    int cmd, x, y, z;\n    scanf(\"%d\", &cmd);\n    switch (cmd) {\n    case 1:\n      scanf(\"%d %d %d\", &x, &y, &z);\n      g.modify(x, y, z);\n      break;\n    case 2:\n      scanf(\"%d %d\", &x, &y);\n      printf(\"%d\\n\", g.sum(x, y) % mod);\n      break;\n    case 3:\n      scanf(\"%d %d\", &x, &z);\n      g.modify(x, z);\n      break;\n    case 4:\n      scanf(\"%d\", &x);\n      printf(\"%d\\n\", g.sum(x) % mod);\n      break;\n    }\n  }\n  return 0;\n}\n```",
        "postTime": 1553826571,
        "uid": 28430,
        "name": "Nerlci_",
        "ccfLevel": 6,
        "title": "\u7b14\u8bb0::\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "# \u95ee\u9898\u5f15\u5165\n\n### \u95ee\u9898$1$\n\n\u7ed9\u4f60\u4e00\u68f5$n$\u4e2a\u7ed3\u70b9\u7684\u6709\u6839\u6811\uff0c\u70b9\u6709\u70b9\u6743\uff0c\u8981\u6c42\u8fdb\u884c\u5982\u4e0b$m$\u6b21\u64cd\u4f5c\uff1a\n\n1.\u67e5\u8be2\u4ece$u$\u5230$v$\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\u3002\n\n2.\u628a\u4ece$u$\u5230$v$\u7684\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u5168\u90e8\u52a0\u4e0ax\n\n$1\\leq n \\leq 1000\\ ,\\ 1 \\leq m \\leq1000$\n\n\u6211\u4f1a\u66b4\u529b$O(mn)$\u505a\uff01\n\n\u601d\u8def\u5927\u6982\u5982\u4e0b\uff1a\n\n\u5148\u9884\u5904\u7406\u51fa\u6765\u6bcf\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\uff0c\u5373$fa[i]$\u6570\u7ec4\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5728$O(nlogn)$\u8fdb\u884c\u500d\u589e\u9884\u5904\u7406,$O(logn)$\u67e5\u8be2$lca$\n\n\u4e4b\u540e\u518d\u4ece$u$\u548c$v$\u66b4\u529b\u7684\u5411\u4e0a\u8df3$fa[u]$\u548c$fa[v]$,\u6cbf\u9014\u4fee\u6539\uff0c\u67e5\u8be2\u3002\n\n\u5982\u679c\u8fd9\u662f\u4e00\u9897\u968f\u673a\u6811\uff0c\u6211\u4eec\u671f\u671b\u7684\u6811\u9ad8$logn$\n\n\u6240\u4ee5\u67e5\u8be2\u590d\u6742\u5ea6\u662f$O(logn)$\u7684\u3002\n\n\u4e5f\u5373\u662f\u8bf4\u66b4\u529b\u7684\u671f\u671b\u590d\u6742\u5ea6\u662f$O(mlogn)$\n\n\u4f46\u662f\u5982\u679c\u6570\u636e\u662f\u4e00\u6761\u94fe\uff0c\u90a3\u4e48\u67e5\u8be2\u7684\u590d\u6742\u5ea6\u5c31\u4f1a\u88ab\u5361\u5230$O(n)$\n\n\u6709$m$\u6b21\u67e5\u8be2\uff0c\u5219\u603b\u590d\u6742\u5ea6\u4e3a$O(mn)$\n\n\u7136\u662f\u8fc7\u6389\u95ee\u9898$1$\u8fd8\u662f\u591f\u7684\u3002\n\n### \u95ee\u9898$2$\n\u8fd8\u662f\u95ee\u9898$1$\u7684\u9898\u9762\n\n$1 \\leq n \\ \\leq10^5\\ , \\ 1 \\leq m\\le10^5$\n\n\u6211\u4eec\u8003\u8651\u5982\u4f55\u7528\u4e00\u4e2a\u7a33\u5b9a\u5728$O(mlogn)$\u5de6\u53f3\u7684\u65b9\u6cd5\u7ef4\u62a4\u3002\n\n\u90a3\u4e48\u5c31\u8fdb\u5165\u4e86\u8fd9\u6b21\u7684\u6b63\u9898.\n\n# \u6811\u94fe\u5256\u5206\n\n\n> \u5b83\u5148\u901a\u8fc7\u8f7b\u91cd\u8fb9\u5256\u5206\u5c06\u6811\u5206\u4e3a\u591a\u6761\u94fe\uff0c\u4fdd\u8bc1\u6bcf\u4e2a\u70b9\u5c5e\u4e8e\u4e14\u53ea\u5c5e\u4e8e\u4e00\u6761\u94fe\uff0c\u7136\u540e\u518d\u901a\u8fc7\u6570\u636e\u7ed3\u6784\uff08\u6811\u72b6\u6570\u7ec4\u3001BST\u3001SPLAY\u3001\u7ebf\u6bb5\u6811\u7b49\uff09\u6765\u7ef4\u62a4\u6bcf\u4e00\u6761\u94fe\u3002\n\n\u663e\u7136\uff0c\u6811\u94fe\u5256\u5206\u7684\u601d\u60f3\u5c31\u662f\u5316\u6811\u4e3a\u94fe\uff0c\u628a\u5728\u6811\u4e0a\u7684\u64cd\u4f5c\u6539\u53d8\u4e3a\u5728\u94fe\u4e0a\u7684\u64cd\u4f5c\u3002\n\n\u800c\u94fe\u7684\u64cd\u4f5c\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u4e00\u4e9b\u81ea\u5df1\u719f\u6089\u7684\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u4e86\u3002\n\n\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u6811\u94fe\u5256\u5206\u4e2d\u7684\u4e00\u4e9b\u5c0f\u6982\u5ff5\u3002\n\n- \u91cd\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u7684\u6240\u6709\u513f\u5b50\u4e2d\u5b50\u6811\u7ed3\u70b9\u6570\u76ee\u6700\u591a\uff08size\u6700\u5927\uff09\u7684\u7ed3\u70b9\uff1b\n\n- \u8f7b\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u4e2d\u9664\u4e86\u91cd\u513f\u5b50\u4ee5\u5916\u7684\u513f\u5b50\uff1b\n\n- \u91cd\u8fb9\uff1a\u7236\u4eb2\u7ed3\u70b9\u548c\u91cd\u513f\u5b50\u8fde\u6210\u7684\u8fb9\uff1b\n\n- \u8f7b\u8fb9\uff1a\u7236\u4eb2\u8282\u70b9\u548c\u8f7b\u513f\u5b50\u8fde\u6210\u7684\u8fb9\uff1b\n\n- \u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\uff1b\n\n- \u8f7b\u94fe\uff1a\u7531\u591a\u6761\u8f7b\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\n\n\u6211\u4eec\u5256\u5206\u7684\u601d\u60f3\u5c31\u662f\u901a\u8fc7\u91cd\u94fe\u5bf9\u6811\u8fdb\u884c\u91cd\u6807\u53f7\uff0c\u7136\u540e\u5bf9\u8fd9\u4e9b\u91cd\u65b0\u6807\u53f7\u7684\u7ed3\u70b9\u8fdb\u884c\u94fe\u7684\u64cd\u4f5c\u3002\n\n\u53ef\u4ee5\u8bc1\u660e\u7684\u662f\uff0c\u6bcf\u4e2a\u7ed3\u70b9\u81f3\u5c11\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u3002\n\n\u6811\u94fe\u5256\u5206\u662f\u901a\u8fc7\u4e24\u904d$dfs$\u7684\u9884\u5904\u7406\u5b9e\u73b0\u7684\u3002\n\n$dfs1$\u5f53\u4e2d\uff0c\u9700\u8981\u6c42\u51fa\uff1a\n\n- \u4ee5\u6bcf\u4e2a\u7ed3\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u5373$size[i]$\n- \u6bcf\u4e2a\u7ed3\u70b9\u7684\u7236\u7ed3\u70b9\uff0c\u5373$fa[i]$\n- \u6bcf\u4e2a\u7ed3\u70b9\u7684\u6df1\u5ea6\uff0c\u5373$dep[i]$\n- \u6bcf\u4e2a\u7ed3\u70b9\u7684\u91cd\u513f\u5b50\uff0c\u5373$son[i]$\n\n\u4ee3\u7801\u5b9e\u73b0\u5176\u5b9e\u975e\u5e38\u7b80\u5355\uff0c\u53c2\u8003\u5982\u4e0b\n\n$Code:$\n```cpp\nvoid dfs1(int now , int f) \n{\n    fa[now] = f;\n    size[now] = 1;\n    dep[now] = dep[f] + 1;\n    for(int i = head[now] ; i ; i = e[i].nxt) {\n        int v = e[i].to;\n        if(v == f) continue;\n        dfs1(v,now);\n        size[now] += size[v];\n        if(size[v] > size[son[now]]) son[now] = v; \n    }\n}\n\n```\n\n$dfs2$\u5f53\u4e2d\uff0c\u9700\u8981\u6c42\u51fa\uff1a\n\n- $seg[i]$\u4ee3\u8868\u6811\u4e2d\u7684$i$\u7ed3\u70b9\uff0c\u5bf9\u5e94\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\u3002\n- $id[i]$\u4ee3\u8868\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684$i$\u7ed3\u70b9\uff0c\u5bf9\u5e94\u6811\u4e2d\u7684\u7f16\u53f7\u3002\n- $top[i]$\u4ee3\u8868\u6811\u4e2d\u7ed3\u70b9$i$\u6240\u5728\u91cd\u94fe\u9876\u7aef\u7684\u7ed3\u70b9\u7f16\u53f7\u3002\n\n\u4ee3\u7801\u4e5f\u662f\u5f88\u597d\u61c2(~~\u611f\u89c9\u6211\u5728\u88c5\u5f3a\uff1f~~)\n\n~~\u80fd\u7406\u89e3$dfs$\u5c31\u80fd\u770b\u61c2~~\n\n$Code:$\n```cpp\nvoid dfs2(int now , int s)\n{\n    seg[now] = ++ idx;\n    top[now] = s;\n    id[seg[now]] = now;\n    if(!son[now]) return;\n    dfs2(son[now] , s);\n    for(int i = head[now] ; i ; i = e[i].nxt) {\n        int v = e[i].to;\n        if(v == fa[now] || v == son[now]) continue;\n        dfs2(v , v);\n    }\n}\n```\n\n\u7136\u540e\u5c31\uff0c\u5904\u7406\u5b8c\u4e86\uff1f\n\n\u662f\u7684\uff0c\u6811\u94fe\u5256\u5206\u4ed6\u5c31\u771f\u7684\u5256\u5206\u5b8c\u4e86\u3002\n\n\u672c\u6765\u611f\u89c9\u5341\u5206\u9ad8\u5927\u4e0a\u7684\u4e00\u4e2a\u4e1c\u897f\uff0c\u539f\u6765\u5c31\u662f\u4e24\u904d\u66b4\u529b\u7684$dfs$\u5440\n\n\u771f\u7684\u662f\u8fd9\u6837\u561b?\u662f\u4e0d\u662f\u5fd8\u4e86\u4ec0\u4e48\u4e1c\u897f\uff1f\n\n\u6ca1\u9519\uff0c\u4ed6\u5c31\u662f\u2014\u2014\u6bd2\u7624\u6570\u636e\u7ed3\u6784\uff01\n\n\u6211\u4eec\u5728\u5256\u5206\u4e4b\u540e\u662f\u9700\u8981\u7528\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u8fd9\u4e2a\u5256\u5206\u5e8f\u5217\u7684\u3002\n\n\u5982\u679c\u662f\u5355\u7eaf\u7684\u7528\u66b4\u529b\u8fdb\u884c\u5e8f\u5217\u7684\u4fee\u6539\uff0c\u90a3\u4e48\u590d\u6742\u5ea6\u548c\u95ee\u9898$1$\u4e2d\u7684$solution$\u65e0\u5f02\u3002\n\n\u56e0\u6b64\uff0c\u6211\u4eec\u9700\u8981\u7528\uff1a(\u62a5\u83dc\u540d)\n\n\u7ebf\u6bb5\u6811\uff0c\u6811\u72b6\u6570\u7ec4\uff0c$splay$\uff0c$treap$\uff0c\u4e3b\u5e2d\u6811\uff0c$bst$\uff0c$lct......$\u4e00\u7cfb\u5217(~~\u6bd2\u7624~~)\u6570\u636e\u7ed3\u6784\u7ef4\u62a4.\n\n\u4e00\u822c\u5e38\u7528\u7684\u90fd\u662f\u7ebf\u6bb5\u6811\u5566\u3002\n\n\u65e2\u7136\u6570\u636e\u7ed3\u6784\u8fd9\u4e48\u590d\u6742\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u629b\u5f00\u4e0d\u8bf4\uff0c\u6211\u4eec\u5148\u6c42\u4e00\u4e2a\u6700\u7b80\u5355\u7684\u95ee\u9898\uff0c\u4e5f\u662f\u6811\u4e0a\u95ee\u9898\u4e2d\u5fc5\u987b\u4f1a\u7684\u95ee\u9898\u3002\n\n###  \u6700\u8fd1\u516c\u5171\u7956\u5148\u3002\n\n\u6211\u4eec\u8003\u8651\u4e24\u4e2a\u8282\u70b9\uff0c\u4ed6\u4eec\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u3002\n\n\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8ba9\u5176\u4e2d$top$\u503c\u8f83\u6df1\u7684\u4e00\u4e2a\u8df3\u5230\u4ed6\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u7684\u7236\u8282\u70b9\uff0c\u4e0d\u65ad\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u4ed6\u4eec\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u90a3\u4e48\u76f8\u5bf9\u6df1\u5ea6\u8f83\u5c0f\u7684\u90a3\u4e2a\u70b9\u5c31\u662f\u4ed6\u4eec\u7684$lca$\u3002\n\n\u4e3a\u4ec0\u4e48\uff1f\u6211\u4eec\u753b\u56fe\u7406\u89e3\u4e00\u4e0b.\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rc1boeww.png)\n\n\u6211\u4eec\u8003\u8651\u5bfb\u627e$u,v$\u8fd9\u4e24\u4e2a\u8282\u70b9\u7684$lca$\n\n\u9996\u5148$u$\u5148\u8df3\u5230\u4ed6\u7684\u7236\u8282\u70b9.\n\n\u8fd9\u65f6\u5019\u53d1\u73b0$v$\u7684$top$\u8f83\u5c0f\uff0c\u8ba9\u4ed6\u5411\u4e0a\u8df3\uff0c\u4ed6\u4f1a\u8df3\u5230\u6839\u8282\u70b9\u3002\n\n\u8fd9\u4e2a\u65f6\u5019\u53d1\u73b0$u,v$\u5df2\u7ecf\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u4e86\uff0c\u8f93\u51fa\u6df1\u5ea6\u8f83\u6d45\u7684$v$\uff0c\u4e8e\u662f\u4ed6\u4eec\u7684$lca$\u5c31\u662f\u6839\u8282\u70b9\u4e86\u3002\n\n\u4e3a\u4ec0\u4e48\u8fd9\u4e2a\u8df3\u7684\u8fc7\u7a0b\u4e0d\u4f1a\u8df3\u201c\u8fc7\u201d$lca$\uff1f\n\n\u7531\u4e8e\u6211\u4eec\u6bcf\u6b21\u8df3\u7684\u90fd\u662f$top$\u6df1\u5ea6\u8f83\u6df1\u7684\u90a3\u4e00\u4e2a\uff0c\u4e14$u,v$\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u5047\u8bbe\u8fd9\u4e2a\u8f83\u6df1\u7684$top$\u8d85\u8fc7\u4e86$lca$\uff0c\u90a3\u4e48\u663e\u7136\u90a3\u4e2a\u8f83\u6d45\u7684$top$\u66f4\u4f1a\u8d8a\u8fc7$lca$\uff0c\u8fd9\u6837\u7684\u8bdd\u8fd9\u4e24\u6761\u91cd\u94fe\u5c31\u91cd\u5408\u4e86\uff0c\u800c\u6839\u636e\u6211\u4eec\u5df2\u77e5\u7684\uff0c\u91cd\u94fe\u662f\u4e0d\u4f1a\u91cd\u5408\u5230\u4e00\u8d77\u7684\uff0c\u56e0\u6b64\u77db\u76fe\uff0c\u6240\u4ee5\u8bf4\u4e0d\u4f1a\u8df3\u7684\u8d85\u8fc7$lca$\uff0c\u8fd9\u6837\u7684\u8bdd\u5c31\u53ef\u4ee5\u987a\u5229\u627e\u5230$lca$\u4e86\u3002\n\n```cpp\nint lca(int u , int v) {\n\twhile(top[u] != top[v]) {\n    \t\tif(dep[top[u]] < dep[top[v]]) swap(u ,v);\n    \t\tu = fa[top[u]];\n\t}\n\tif(dep[u] > dep[v]) swap(u , v);\n    \treturn u;\n}\n```\n\n\u6ca1\u4e86\uff1f\u771f\u7684\u6ca1\u4e86\u3002\n\n\u4e0b\u9762\u5c31\u662f\u5bf9\u94fe\u7684\u57fa\u672c\u64cd\u4f5c\u3002\n\n### \u57fa\u672c\u64cd\u4f5c\n\n\u57fa\u672c\u64cd\u4f5c\u5f88\u591a\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e00\u6761\u94fe\u8fdb\u884c\u589e\u3001\u51cf\u3001\u6c42\u6700\u5927\u503c\u6700\u5c0f\u503c....\u4e00\u7cfb\u5217\u95ee\u9898\uff0c\u590d\u6742\u5ea6\u90fd\u662f\u4f18\u96c5\u7684$O(logn)$\u7684\u3002\n\n\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u6bd4\u8f83\u7b80\u5355\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e00\u6761\u94fe\u52a0\u4e0a\u4e00\u4e2a\u6570\u3002\n\n\u6211\u4eec\u4e0a\u9762\u5df2\u7ecf\u5b66\u5b8c\u4e86\u5982\u4f55\u6c42LCA\u4e86\uff0c\u81ea\u7136\u7684\u5c31\u53ef\u4ee5\u60f3\u5230\u5728\u6c42LCA\u7684\u8fc7\u7a0b\u4e2d\uff0c\u628a\u6d89\u53ca\u5230\u7684\u6240\u6709\u91cd\u94fe\u8fdb\u884c\u4e00\u4e0b\u4fee\u6539\uff0c\u5c31\u53ef\u4ee5\u8986\u76d6\u5230\u6240\u6709\u7684\u70b9\u4e86\u3002\n\n\u5982\u4f55\u5feb\u901f\u7684\u8fdb\u884c\u8fd9\u4e2a\u94fe\u7684\u64cd\u4f5c\uff1f\n\n\u2014\u2014\u7ebf\u6bb5\u6811\n\n\u6211\u4eec\u5728dfs2\u4e2d\u5df2\u7ecf\u6c42\u51fa\u4e86\u6811\u4e0a\u5bf9\u5e94\u7684\u7ebf\u6bb5\u6811\u4e0a\u7684\u8282\u70b9$seg_i$(\u597d\u7ed5)\n\n\u800c\u4e14\u5728\u6bcf\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c$seg_i$\u4e00\u5b9a\u662f\u8fde\u7eed\u7684\uff08\u4e3a\u4ec0\u4e48\uff1f\u4ed4\u7ec6\u770b\u770bdfs2\u7684\u8fc7\u7a0b\uff09\n\n\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u505a\u533a\u95f4\u4fee\u6539\u7684\u64cd\u4f5c\u4e86\u3002\n\n```cpp\nvoid modify (int u , int v ,int w) {\n    while(top[u] != top[v]) {\n    \tif(dep[top[u]] < dep[top[v]]) swap(u ,v);\n    \tupdata(1 , seg[top[u]] , seg[u] ,w);\n    \tu = fa[top[u]];\n    }\n\tif(dep[u] > dep[v]) swap(u , v);\n\tupdata(1 , seg[u] , seg[v] ,w); \n}\n\n```\n\n\u67e5\u8be2\uff1f\u548c\u4e0a\u9762\u7684\u4e00\u6837\uff0c\u5c31\u4e0d\u8d34\u4ee3\u7801\u4e86\u3002\n\n\u81f3\u6b64\uff0c\u6811\u94fe\u5256\u5206\u5c31\u7ed3\u675f\u4e86\u3002\uff08\u7b80\u5355\u7c97\u66b4\u4f46\u662f\u5341\u5206\u597d\u7528\u7684\u6570\u636e\u7ed3\u6784\u3002\uff09\n\n\u9644\u4e0a\u6811\u5256\u6a21\u677f\u7684\u4ee3\u7801\uff1a\n\n$Code:$\n\n```cpp\n// luogu-judger-enable-o2\n#include <bits/stdc++.h>\n#define lson(x) x<<1\n#define rson(x) x<<1|1\n\nusing namespace std;\n\nconst int maxn = 1e6 + 10;\nint n , m , root , p;\nint a[maxn], head[maxn] , cnt;\nint fa[maxn] , size[maxn] , son[maxn] , dep[maxn];\nint idx = 0 , seg[maxn] , id[maxn] , top[maxn];\n\nstruct Edge{\n    int to , nxt;\n    Edge () {\n        to = 0 , nxt = 0;\n    }\n}e[maxn];\n\nstruct tree {\n    int dis , add , l , r;\n    tree () {\n    \tdis = 0 , add = 0 , l = 0 , r = 0;\n\t} \n}t[maxn];\n\nvoid pushup(int x) {t[x].dis = (t[lson(x)].dis + t[rson(x)].dis) % p;}\n\nvoid built (int x ,int l ,int r) {\n    t[x].l = l , t[x].r = r;\n    if(l == r) {\n        t[x].dis = a[id[l]];\n        //printf(\"t[%d] = %d \\n\" , x , t[x].dis);\n        return;\n    }\n    int mid = (l + r) >> 1;\n    built(lson(x) , l , mid);\n    built(rson(x) , mid + 1, r);\n    pushup(x);\n}\n\nvoid pushdown(int x)\n{\n    if(t[x].add) {\n        int len1 = t[lson(x)].r - t[lson(x)].l + 1;\n        int len2 = t[rson(x)].r - t[rson(x)].l + 1;\n        t[lson(x)].dis = (t[lson(x)].dis + len1 * t[x].add) % p;\n        t[rson(x)].dis = (t[rson(x)].dis + len2 * t[x].add) % p;\n        t[lson(x)].add = (t[lson(x)].add + t[x].add) ;\n        t[rson(x)].add = (t[rson(x)].add + t[x].add) ;\n        t[x].add = 0;\n    }\n}\n\nvoid add(int u, int v) {\n    e[++cnt].to = v;\n    e[cnt].nxt = head[u];\n    head[u] = cnt;\n}\n\nvoid dfs1(int now , int f) \n{\n    fa[now] = f;\n    size[now] = 1;\n    dep[now] = dep[f] + 1;\n    for(int i = head[now] ; i ; i = e[i].nxt) {\n        int v = e[i].to;\n        if(v == f) continue;\n        dfs1(v,now);\n        size[now] += size[v];\n        if(size[v] > size[son[now]]) son[now] = v; \n    }\n}\n\nvoid dfs2(int now , int s)\n{\n    seg[now] = ++ idx;\n    top[now] = s;\n    id[seg[now]] = now;\n    if(!son[now]) return;\n    dfs2(son[now] , s);\n    for(int i = head[now] ; i ; i = e[i].nxt) {\n        int v = e[i].to;\n        if(v == fa[now] || v == son[now]) continue;\n        dfs2(v , v);\n    }\n}\n\nvoid updata (int x , int l , int r , int w) {\n    if(t[x].l >= l && t[x].r <= r) {\n        t[x].dis = (t[x].dis + w * (t[x].r - t[x].l + 1)) % p;\n        t[x].add += w;\n\t\t//printf(\"t[%d].dis = %d \\n\" , x ,t[x].dis);\n        return;\n    }\n    pushdown(x);\n    int mid  = (t[x].l + t[x].r) >> 1;\n    if(l <= mid) updata(lson(x) , l , r , w);\n    if(r > mid) updata(rson(x) , l , r , w);\n    pushup(x);\n}\n\nint query(int x , int l ,int r) {\n    if(t[x].l >= l && t[x].r <= r) {\n    \t//printf(\"t[%d].dis = %d \\n\" , x , t[x].dis);\n\t\treturn t[x].dis;\n\t}\n    pushdown(x);\n    int mid = (t[x].l + t[x].r ) >> 1;\n    int sum = 0;\n    if(l <= mid) sum = (sum + query(lson(x) , l , r) ) % p;\n    if(r > mid) sum = (sum + query(rson(x) , l , r) ) % p;\n   \tpushup(x);\n   // printf(\"return sum = %d \\n \" , sum); \n    return sum % p;\n    pushup(x);\n}\n\nvoid modify_1 (int u , int v ,int w) {\n    while(top[u] != top[v]) {\n    \tif(dep[top[u]] < dep[top[v]]) swap(u ,v);\n    \tupdata(1 , seg[top[u]] , seg[u] ,w);\n    \tu = fa[top[u]];\n\t}\n\tif(dep[u] > dep[v]) swap(u , v);\n\tupdata(1 , seg[u] , seg[v] ,w); \n}\n\nint found_1 (int u ,int v ) {\n    int ans = 0;\n    while(top[u] != top[v]) {\n    \tif(dep[top[u]] < dep[top[v]]) swap(u , v);\n    \tans = (ans + query(1 , seg[top[u]] , seg[u])) % p;\n    \t//printf(\"query [%d,%d]\\n\" ,seg[top[u]],seg[u]);\n    \tu = fa[top[u]];\n\t}\n\tif(dep[u] > dep[v]) swap(u , v);\n\tans = (ans + query(1 , seg[u] ,seg[v])) % p;\n\t//printf(\"query [%d,%d]\\n\" ,seg[v],seg[u]);\n\treturn ans % p;\n}\n\nvoid modify_2(int x ,int w) {\n    updata(1 , seg[x] , seg[x] + size[x] - 1 , w);\n}\n\nint found_2(int x) {\n    int ans = 0;\n    ans = query(1 , seg[x] , seg[x] + size[x] - 1);\n    //printf(\"query [%d,%d]\\n\" ,seg[x] , seg[x] + size[x] - 1);\n    return ans % p;\n}\n\nint main ()\n{\n//\tfreopen(\"dabiao.txt\",\"r\",stdin);\n    scanf(\"%d%d%d%d\",&n,&m,&root,&p);\n    for(int i = 1 ; i <= n ; ++ i) scanf(\"%d\" , a + i);\n    for(int i = 1 ; i < n ; ++ i) {\n        int u , v ;\n        scanf(\"%d%d\",&u,&v);\n        add(u , v);\n        add(v , u);\n    }\n    dep[root] = 1;\n    dfs1(root , 0);\n    dfs2(root , root);\n    built(1,1,n);\n    while(m --) {\n        int opt;\n        scanf(\"%d\",&opt);\n        if(opt == 1) {\n            int l , r , w;\n            scanf(\"%d%d%d\",&l,&r,&w);\n            modify_1(l,r,w);\n\n        } else if(opt == 2){\n            int l ,r;\n            scanf(\"%d%d\" ,&l ,&r);\n            printf(\"%d\\n\",found_1(l,r)%p);\n\n        } else if(opt == 3) {\n            int x , w;\n            scanf(\"%d%d\",&x,&w);\n            modify_2(x,w);\n        } else {\n            int x;\n            scanf(\"%d\",&x);\n            printf(\"%d\\n\",found_2(x)%p);\n        } \n    }\n    return 0;\n}\n```",
        "postTime": 1568042512,
        "uid": 134080,
        "name": "jins3599",
        "ccfLevel": 4,
        "title": "\u6811\u94fe\u5256\u5206\u7b14\u8bb0"
    },
    {
        "content": "\u4ed4\u7ec6\u770b\u4e86\u4e00\u4e0b\u53d1\u73b0\u9898\u89e3\u91cc\u53ea\u6709\u4e00\u4e2a\u4eba\u53d1\u6811\u72b6\u6570\u7ec4\u7684\u9898\u89e3\u4f46\u5e76\u6ca1\u6709\u89e3\u91ca\u6b64\u6811\u72b6\u6570\u7ec4\u7684\u539f\u7406, \u4e8e\u662f\u6765\u53d1\u4e00\u7bc7\u9898\u89e3\u3002\n\n~~PS:\u53e6\u4e00\u4e2a\u53d1\u6811\u72b6\u6570\u7ec4\u9898\u89e3\u7684\u4ee3\u7801\u662f\u7b2c\u4e00~~\n\n\u8bbe\u539f\u6570\u7ec4\u4e3a$a_n$, \u8003\u8651\u4e00\u4e2a\u5dee\u5206\u6570\u7ec4$b_n = a_n - a_{n - 1}$(\u7ea6\u5b9a$b_0 = 0$), \u53ef\u4ee5\u5f97\u5230\n\n$$\\sum_{i = 1}^n a_i = \\sum_{i = 1}^n \\sum_{j = 1}^i b_i = \\sum_{i = 1}^{n - i + 1} b_i = \\sum_{i = 1}^n (n + 1 - i)b_i = (n + 1)\\sum_{i = 1}^n b_i - \\sum_{i = 1}^n ib_i$$\n\n~~\u5b9e\u9524\u6d1b\u8c37\u4e0d\u652f\u6301\u516c\u5f0f\u6362\u884c~~\n\n\u5199\u7684\u901a\u4fd7\u6613\u61c2\u5c31\u662f\n\n```\n   a[1]+a[2]+...+ a[n - 1] + a[n]\n = b[1]+(b[1]+b[2])+...+(b[1]+b[2]+...+b[n-2]+b[n-1])+(b[1]+b[2]+...+b[n-1]+b[n])\n = n*b[1]+(n-1)*b[2]+...2*b[n-1]+1*b[n]\n = (n+1-1)*b[1]+(n+1-2)*b[2]+...+(n+1-(n-1))*b[n-1]+(n+1-n)*b[n]\n = (n+1)*sum(b[i])-sum(i*b[i])\n```\n\n\u8fd9\u6837, \u7528\u4e00\u68f5\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4`sum(b[i])`, \u53e6\u4e00\u68f5\u7528\u6765\u7ef4\u62a4`sum(i*b[i])`, \u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4e0a\u4ee3\u7801:\n\n```cpp\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nlong long fenwick_tree1[100010], fenwick_tree2[100010];\nstd::vector<int> adj[100010];\nint heavy[100010], size[100010], father[100010], top[100010], depth[100010];\nint new_index[100010];\nlong long original_value[100010], indexed_value[100010];\nint maxtop, n, m;\nlong long kMod;\nvoid Dfs1(const int &cur, const int &fathernode) {\n  father[cur] = fathernode,\n  depth[cur] = depth[fathernode] + 1,\n  size[cur] = 1;\n  for (auto i : adj[cur]) {\n    if (i != fathernode) {\n      Dfs1(i, cur),\n      size[cur] += size[i];\n      if (size[i] > size[heavy[cur]]) heavy[cur] = i;\n    }\n  }\n}\nvoid Dfs2(const int &cur, const int &topnode) {\n  static int index_count(0);\n  new_index[cur] = ++index_count,\n  indexed_value[index_count] = original_value[cur];\n  top[cur] = topnode;\n  if (heavy[cur]) {\n    Dfs2(heavy[cur], topnode);\n    for (auto i : adj[cur]) {\n      if (i != father[cur] && i != heavy[cur]) {\n        Dfs2(i, i);\n      }\n    }\n  }\n}\n#define LOWBIT(a) (a & -a)\ninline void Add(long long *fenwick_tree, int index, const long long &kDelta) {\n  while (index <= n) {\n    fenwick_tree[index] += kDelta;\n    index += LOWBIT(index);\n  }\n}\ninline long long Sum(long long *fenwick_tree, int index) {\n  long long ret(0ll);\n  while (index) {\n    ret += fenwick_tree[index];\n    index -= LOWBIT(index);\n  }\n  return ret;\n}\ninline void Modify(const int &l, const int &r, const long long &kDelta) {\n  Add(fenwick_tree1, l, kDelta),\n  Add(fenwick_tree1, r + 1, -kDelta),\n  Add(fenwick_tree2, l, kDelta * l),\n  Add(fenwick_tree2, r + 1, -kDelta * (r + 1));\n}\ninline long long GetSum(const int &l, const int &r) {\n  return (Sum(fenwick_tree1, r) * (r + 1) - Sum(fenwick_tree1, l - 1) * l - Sum(fenwick_tree2, r) + Sum(fenwick_tree2, l - 1)) % kMod;\n}\ninline void Build() {\n  for (int i(1); i <= n; ++i) {\n    Add(fenwick_tree1, i, (indexed_value[i] - indexed_value[i - 1])),\n    Add(fenwick_tree2, i, (indexed_value[i] - indexed_value[i - 1]) * i);\n  }\n}\n#undef LOWBIT\ninline void PathModify(const int &x, const int &y, const long long &kDelta) {\n  int a(x), b(y);\n  while (top[a] != top[b]) {\n    if (depth[top[a]] < depth[top[b]]) std::swap(a, b);\n    Modify(new_index[top[a]], new_index[a], kDelta);\n    a = father[top[a]];\n  }\n  if (depth[a] > depth[b]) std::swap(a, b);\n  Modify(new_index[a], new_index[b], kDelta);\n}\ninline long long PathGetSum(const int &x, const int &y) {\n  int a(x), b(y);\n  long long ret(0ll);\n  while (top[a] != top[b]) {\n    if (depth[top[a]] < depth[top[b]]) std::swap(a, b);\n    (ret += GetSum(new_index[top[a]], new_index[a])) %= kMod;\n    a = father[top[a]];\n  }\n  if (depth[a] > depth[b]) std::swap(a, b);\n  return (ret + GetSum(new_index[a], new_index[b])) % kMod;\n}\n\ninline void SubTreeModify(const int &x, const long long &kDelta) {\n  Modify(new_index[x], new_index[x] + size[x] - 1, kDelta);\n}\ninline long long SubTreeGetSum(const int &x) {\n  return GetSum(new_index[x], new_index[x] + size[x] - 1);\n}\nint main(int argc, char const *argv[]) {\n  scanf(\"%d %d %d %lld\", &n, &m, &maxtop, &kMod);\n  for (int i(1); i <= n; ++i) scanf(\"%lld\", &original_value[i]);\n  for (int i(1), u, v; i < n; ++i) {\n    scanf(\"%d %d\", &u, &v),\n    adj[u].push_back(v),\n    adj[v].push_back(u);\n  }\n  Dfs1(maxtop, maxtop), Dfs2(maxtop, maxtop);\n  Build();\n  long long z;\n  int opt, x, y;\n  while (m--) {\n    scanf(\"%d\", &opt);\n    switch (opt) {\n      case 1: {\n        scanf(\"%d %d %lld\", &x, &y, &z);\n        PathModify(x, y, z);\n        break;\n      }\n      case 2: {\n        scanf(\"%d %d\", &x, &y);\n        printf(\"%lld\\n\", PathGetSum(x, y));\n        break;\n      }\n      case 3: {\n        scanf(\"%d %lld\", &x, &z);\n        SubTreeModify(x, z);\n        break;\n      }\n      case 4: {\n        scanf(\"%d\", &x);\n        printf(\"%lld\\n\", SubTreeGetSum(x));\n        break;\n      }\n    }\n  }\n  return 0;\n}\n```",
        "postTime": 1538830899,
        "uid": 49231,
        "name": "Starduster",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u65b0\u5b66\u4e00\u79cd\u6811\u5256\u975e\u9012\u5f52\u521d\u59cb\u5316\uff0c\u597d\u50cf\u6bd4dfs\u66f4\u5feb\uff0c\u56e0\u4e3a\u53ea\u7528bfs\u4e00\u6b21\uff0c\u4e4b\u540e\u76f4\u63a5\u5229\u7528bfs\u5e8f\uff0c\u4e0d\u7528\u518d\u679a\u4e3e\u513f\u5b50\u3002\u6765\u5c55\u793a\u4e00\u4e0b\n\n```cpp\nint q[N],head,tail,x,y,i,deep,now,i0;\nvoid init()\n{\n    for (q[head=tail=1]=rt;head<=tail;++head)\n    {\n        x=q[head];T[x].sz=1;deep=T[x].deep+1;\n        for (i=t[x];i;i=l[i].next)\n        if (!T[y=l[i].to].sz)\n        {\n            T[y].deep=deep;T[y].f=x;\n            q[++tail]=y;\n             }\n    }\n    for (head=tail;head>1;--head)\n    {\n        y=T[x=q[head]].f;\n        T[y].sz+=T[x].sz;\n        if (T[x].sz>T[T[y].c].sz) T[y].c=x;\n    }\n    for (head=1;head<=tail;++head)\n    if (!T[x=q[head]].top)//\u627e\u5230\u6bcf\u6761\u94fe\u7684top,\u6211\u4eec\u76f4\u63a5\u8fde\u7eed\u52a0\u5165\u8fd9\u6761\u94fe\u3002\n    {\n        now=T[i0=T[x].f].out;\n        for (i=x;i;i0=i,i=T[i].c) \n        {\n          T[i].top=x;T[i].w=T[i].out=++now;//w\u8868\u793adfs\u8bbf\u95ee\u7684\u65f6\u95f4\uff0cout\u8868\u793adfs\u9000\u51fa\u7684\u65f6\u95f4\uff0c\u4e5f\u5c31\u662f\u6574\u4e2a\u5b50\u6811\u7684\u65f6\u95f4\n                                               //\u540c\u65f6\uff0c\u8fd9\u91cc\u6211\u4eec\u8fd8\u8981\u5229\u7528out\u8868\u793a\u5f53\u524d\u6700\u540e\u4e00\u4e2a\u513f\u5b50\u7684\u65f6\u95f4\n          T[i0].out+=T[i].sz;//\u8fd9\u662f\u6700\u5173\u952e\u7684\u5730\u65b9\uff0c\u9884\u7559\u51fa\u4f4d\u7f6e\n        }\n    }\n}\n```\n\u5982\u679c\u4e0d\u7528\u8ba9\u5b50\u6811\u8fde\u7eed\uff0c\u53ea\u7528\u8ba9\u6bcf\u6761\u94fe\u8fde\u7eed\uff0c\u5f97\u5230top,w\u90e8\u5206\u5c31\u66f4\u7b80\u5355\u3002\n\n```cpp\nfor (head=1;head<=tail;++head)\n    if (!T[x=q[head]].top)\n    for (i=x;i;i=T[i].c) \n    { T[i].top=x;T[i].w=++now;}\n```",
        "postTime": 1483496610,
        "uid": 9168,
        "name": "kczno1",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u521a\u521a\u5b66\u6811\u5256\u7684\u65f6\u5019\uff0c\u56e0\u4e3a\u6709\u4e00\u4e9b\u56fe\u8bba\u7684\u77e5\u8bc6\uff0c\u6240\u4ee5\u7406\u8bba\u77e5\u8bc6\u5f88\u5feb\u5c31\u660e\u767d\u4e86\uff0c\u4f46\u4ee3\u7801\u7801\u4e86\u5f88\u4e45\uff0c\u849f\u84bb\u7684\u4ee3\u7801\u80fd\u529b\u8fd8\u662f\u592a\u5783\u573e\u4e86\u3002\n\n\u5e9f\u8bdd\u5c31\u4e0d\u591a\u8bf4\uff0c\u5148\u5728\u6211\u5c31\u8c08\u8c08\u6811\u5256\uff1b\n\n\u5148\u4e0a\u4e00\u9053\u9898\u5427\uff08\u6d1b\u8c37P3384\uff09\uff08\u5927\u4f6c\u52ff\u55b7\uff09\n\u770b\u5230\u8fd9\u9053\u9898\u5927\u5bb6\u6709\u4ec0\u4e48\u60f3\u6cd5\u5462\uff1f\u66b4\u529b\uff1f(n<=10^5 )(\u4e00\u770b\u5c31\u77e5\u9053\u7528 logn \u7684\u7b97\u6cd5)a\u4e0d\u4e86\u5427\uff0c\u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u6b63\u5f0f\u8fdb\u5165\u6b63\u9898\u3002\n\u4ec0\u4e48\u662f\u6811\u5256\uff0c\u6811\u5256\u5c31\u662f\u5b83\u7684\u5b57\u9762\u610f\u601d\uff0c\u5c06\u6811\u5256\u6210\u5f88\u591a\u90e8\u5206\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u5728\u6211\u4eec\u6765\u8c08\u5982\u4f55\u8fdb\u884c\u5177\u4f53\u64cd\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u6765\u5b66\u4e60\u4e00\u4e0b\u4e00\u4e9b\u4e0e\u6811\u5256\u6709\u5173\u7684\u57fa\u7840\u6811\u7684\u77e5\u8bc6\u3002\n\n\u91cd\u513f\u5b50\uff1anum[u]\u4e3av\u7684\u5b50\u8282\u70b9\u4e2dnum\u503c\u6700\u5927\u7684\uff0c\u90a3\u4e48u\u5c31\u662fv\u7684\u91cd\u513f\u5b50\u3002\n\u8f7b\u513f\u5b50\uff1av\u7684\u5176\u5b83\u5b50\u8282\u70b9\u3002\n\u91cd\u8fb9\uff1a\u70b9v\u4e0e\u5176\u91cd\u513f\u5b50\u7684\u8fde\u8fb9\u3002\n\u8f7b\u8fb9\uff1a\u70b9v\u4e0e\u5176\u8f7b\u513f\u5b50\u7684\u8fde\u8fb9\u3002\n\u91cd\u94fe\uff1a\u7531\u91cd\u8fb9\u8fde\u6210\u7684\u8def\u5f84\u3002\n\n\u8f7b\u94fe\uff1a\u8f7b\u8fb9\u3002\n![](http://img.blog.csdn.net/20180213094604944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaW9paHl4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n\uff08\u672c\u56fe\u6458\u81ea\u6d1b\u8c37\uff09\n\n\u56fe\u4e2d\u9ed1\u8272\u7684\u8fb9\u662f\u91cd\u8fb9\uff0c\u7ea2\u8272\u7684\u70b9\u662f\u91cd\u513f\u5b50\uff1b\n\n\u5256\u5206\u540e\u7684\u6811\u6709\u5982\u4e0b\u6027\u8d28\uff1a\n    \u6027\u8d281\uff1a\u5982\u679c(v,u)\u4e3a\u8f7b\u8fb9\uff0c\u5219siz[u] * 2 < siz[v]\uff1b\n\n    \u6027\u8d282\uff1a\u4ece\u6839\u5230\u67d0\u4e00\u70b9\u7684\u8def\u5f84\u4e0a\u8f7b\u94fe\u3001\u91cd\u94fe\u7684\u4e2a\u6570\u90fd\u4e0d\u5927\u4e8elogn\u3002\n\n\u5927\u6982\u4e86\u89e3\u4e86\u4e9b\u57fa\u672c\u77e5\u8bc6\uff0c\u6211\u4eec\u5c31\u6765\u8c08\u8c08\u90a3\u9053\u9898\u5230\u5e95\u600e\u4e48\u6c42\u89e3\u5427\uff1b\n\n\u9996\u5148\uff0c\u6211\u4eec\u8981\u8fdb\u884c\u4e24\u6b21dfs\uff0c\u7b2c\u4e00\u6b21dfs\u5c06\u4ed6\u7684fa\u3001deep\u3001size\u3001son//\u6c42\u7684\u4fbf\u662f\u82f1\u6587\u5b57\u6bcd\u7684\u5b57\u9762\u610f\u601d\n\n\u8bdd\u4e0d\u591a\u8bf4\uff0c\u4e0a\u4ee3\u7801\uff1b\n```cpp\nvoid dfs1(long long x)//\u5f53\u524d\u6240\u5728\u8282\u70b9\uff0c\u5f00\u59cb\u53ca\u662f\u6839\n{\n    si[x]=1;//\u5c06\u8282\u70b9\u7684\u5b50\u6811\u5927\u5c0f\u521d\u59cb\u5316\u4e3a1\uff0c\u53ca\u81ea\u5df1\n    for(long long i=0;i<q[x].size();++i)//\u904d\u5386\u81ea\u5df1\u7684\u513f\u5b50\n    {\n        if(q[x][i]==fa[x])//\u4e0d\u4e3a\u7239\n            continue;\n        dep[q[x][i]]=dep[x]+1;//\u513f\u5b50\u6df1\u5ea6\u4e3a\u7238\u7238\u6df1\u5ea6\u52a01\n        fa[q[x][i]]=x;//\u628a\u513f\u5b50\u7684\u7238\u7238\u627e\u5230\n        dfs1(q[x][i]);//\u7ee7\u7eeddfs\u513f\u5b50\n        si[x]+=si[q[x][i]];//\u9012\u5f52\u56de\u6765x\u7684\u6811\u5927\u5c0f\u4fbf\u662f\u513f\u5b50\u7684\u6811\u5927\u5c0f\u76f8\u52a0\u518d\u52a0\u4e0a\u81ea\u5df1\u7684\u5927\u5c0f\uff08\n\u81ea\u5df1\u7684\u5927\u5c0f\u4fbf\u662f1\u554a\uff09}}\n```\ndfs1\u5b8c\u4e86\uff0c\u5c31\u8fdb\u884cdfs2\uff0cdfs2\u6709\u4ec0\u4e48\u7528\u5462\uff1f\n\n\u5373\u5c06\u6811\u6309\u7167\u91cd\u94fe\u91cd\u65b0\u7f16\u4e2a\u53f7\uff08\u6211\u4ee3\u7801\u5b9a\u4e49\u7684pos\uff09\uff0c\u8fd8\u8981\u4e0e\u6b64\u540c\u65f6\u627e\u5230\u6bcf\u4e00\u4e2a\u70b9\u7684\u94fe\u9876\uff08\u6211\u4ee3\u7801\u5b9a\u4e49\u7684top\uff09\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\nvoid dfs2(long long x,long long grfa)//x\u4e3a\u5f53\u524d\u8282\u70b9\uff0cgrfa\u53ca\u5f53\u524d\u8282\u70b9\u7684\u94fe\u9876\n{\n    long long k=0;//\u5224\u65ad\u91cd\u94fe\u7684\u8ba1\u6570\u5668\n    sz++;//\u5f53\u524d\u52a0\u5230\u7684\u8282\u53f7\n    pos[x]=sz;\n    top[x]=grfa;\n    for(long long i=0;i<q[x].size();++i)//\u904d\u5386\u513f\u5b50\n    {\n        if(dep[x]<dep[q[x][i]] and si[q[x][i]]>si[k])//\u627e\u91cd\u513f\u5b50\n        {\n            k=q[x][i];\n        }\n    }\n    if(k==0)//\u6ca1\u6709\u513f\u5b50\n        return;\n    dfs2(k,grfa);//\u5148\u9012\u5f52\u628a\u91cd\u94fe\u627e\u5230\n    for(long long i=0;i<q[x].size();++i)//\u904d\u5386\u4e0d\u662f\u91cd\u513f\u5b50\u7684\u5176\u5b83\u513f\u5b50\n    {\n        if(dep[x]<dep[q[x][i]] and k!=q[x][i])\n            dfs2(q[x][i],q[x][i]);\n    }\n}\n```\n\u6211\u4eec\u5c06\u9884\u5904\u7406\u641e\u597d\u4e86\uff0c\u63a5\u4e0b\u6765\u4fbf\u662f\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u8fd9\u4e00\u68f5\u6811\uff08\u4ee5\u4e0b\u662f\u7ebf\u6bb5\u6811\u7684\u6a21\u677f\uff0c\u6211\u5c31\u4e0d\u8be6\u7ec6\u8bb2\u4e86\uff09\uff1a\n```\nstruct node{long long l,r,ls,rs,c,f;}tr[maxn];\n//l,r\u4e3a\u533a\u95f4\uff0cls\u5de6\u8282\u70b9\uff0crs\u53f3\u8282\u70b9\uff0cc\u662fdata\uff0cf\u662flazy\u6807\u8bb0\nlong long nw(long long l,long long r)//\u849f\u84bb\u7684laji\u7ebf\u6bb5\u6811//\u65b0\u5f00\u533a\u95f4\u4e3al\u5230r\u7684\u8282\u70b9\n{\n    tr[++t]=(node){l,r,0,0,0,0};\n    return t;//\u8fd4\u56de\u8282\u70b9\u53f7\n}\nvoid xf(long long o)//\u4e0b\u653elazy\u6807\u8bb0\n{\n    long long l=tr[o].ls,r=tr[o].rs;\n    tr[o].c+=(tr[o].r-tr[o].l+1)*tr[o].f%mo;\n    tr[l].f+=tr[o].f;\n    tr[r].f+=tr[o].f;\n    tr[o].f=0;\n}\nvoid gx(long long o){//\u5c06\u8282\u70b9data\u9012\u5f52\u4f1a\u6765\n    long long l=tr[o].ls,r=tr[o].rs;\n    xf(l),xf(r);\n    tr[o].c=(tr[l].c+tr[r].c)%mo;\n}\nvoid xg(long long o,long long l,long long r,long long c)//\u5c06l\u5230r\u533a\u95f4\u52a0\u4e0ac\n{\n    xf(o);\n    if(tr[o].l==l&&tr[o].r==r)\n    {\n        tr[o].f+=c;\n        return;\n    }\n    long long mid=tr[o].l+tr[o].r>>1;\n    if(r<=mid)\n        xg(tr[o].ls?tr[o].ls:tr[o].ls=nw(tr[o].l,mid),l,r,c);\n    else\n    if(l>mid)\n        xg(tr[o].rs?tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r),l,r,c);\n    else\n        xg(tr[o].ls,l,mid,c),xg(tr[o].rs,mid+1,r,c);\n    gx(o);\n}\nlong long cx(long long o,long long l,long long r)//\u6c42l\u5230r\u7684\u503c\n{\n    xf(o);\n    if(tr[o].l==l&&tr[o].r==r)\n        return tr[o].c%mo;\n    long long mid=tr[o].l+tr[o].r>>1;\n    if(r<=mid)\n        return cx(tr[o].ls,l,r);\n    else\n    if(l>mid)\n        return cx(tr[o].rs,l,r);\n    else\n        return (cx(tr[o].ls,l,mid)+cx(tr[o].rs,mid+1,r))%mo;\n}\n```\n\u4e0b\u9762\u4ee3\u7801\u4fbf\u662f\u5982\u4f55\u5c06\u6811\u548c\u7ebf\u6bb5\u6811\u7ed3\u5408\u5176\u6765\uff1a\n```cpp\nlong long dianhe(long long x,long long y)//\u6c42\u4e24\u70b9\u95f4\u7684\u8ddd\u79bb\n{\n    long long ans=0;\n    while(top[x]!=top[y])//\u5982\u679c\u4e24\u70b9\u4e0d\u5728\u4e00\u6761\u94fe\u4e0a\n    {\n    \tif(dep[top[x]]<dep[top[y]])//\u4fdd\u8bc1x\u7684\u94fe\u9876\u6bd4y\u7684\u94fe\u9876\u6df1\n        swap(x,y);\n        ans+=cx(1,pos[top[x]],pos[x]);//\u76f4\u63a5\u5c06x\u5230x\u7684\u94fe\u9876\u7684\u8ddd\u79bb\u7528\u7ebf\u6bb5\u6811\u6c42\u548c\n        x=fa[top[x]];//\u5c06x\u8df3\u5230\u94fe\u9876\u7684\u7238\u7238\n    }\n    if(dep[x]<dep[y])//\u5f53\u5230\u4e00\u6761\u94fe\u4e0a\uff0c\u4fdd\u8bc1x\u7684\u6df1\u5ea6>y\n        swap(x,y);\n    ans+=cx(1,pos[y],pos[x]);//\u76f4\u63a5\u7528\u7ebf\u6bb5\u6811\u67e5\u8be2x\u5230y\u7684\u8ddd\u79bb\n    return ans%mo;\n}\nvoid dianchage(long long x,long long y,long long z)//\u5c06x\u548cy\u4e24\u70b9\u4e4b\u95f4\u52a0\u4e0az\n{\n    while(top[x]!=top[y])//\u5c31\u4e0d\u591a\u8bf4\u4e86\uff0c\u548c\u4e0a\u9762\u4e00\u6837\uff0c\u5c06cx\u6539\u4e3a\u4fee\u6539\u53ca\u53ef\n    {\n    \tif(dep[top[x]]<dep[top[y]])\n        swap(x,y);\n        xg(1,pos[top[x]],pos[x],z);\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])\n        swap(x,y);\n    xg(1,pos[y],pos[x],z);\n    return;\n}\nlong long shuhe(long long x)//\u6c42\u6811\u7684\u548c\n{\n    return cx(1,pos[x],pos[x]+si[x]-1);//\u56e0\u4e3a\u5728\u6811\u4e0a\u6811\u513f\u5b50\u7f16\u53f7\u662f\u8fde\u7eed\u7684\uff0c\u76f4\u63a5\u533a\u95f4\u6c42\u548c\u53ca\u53ef\n}\nvoid shuchage(long long x,long long y)//\u5c06\u5b50\u6811\u6bcf\u4e2a\u70b9\u52a0\u4e0ay\n{\n    xg(1,pos[x],pos[x]+si[x]-1,y);//\u540c\u4e0a\n    return;\n}\n```\n\u5982\u679c\u5c06\u4e0a\u9762\u7684\u770b\u660e\u767d\u4e86\uff0c\u6811\u5256\u5c31\u5dee\u4e0d\u591a\u5165\u95e8\u4e86\uff08\u849f\u84bb\u4e5f\u4e0d\u53ef\u80fd\u7ed9\u4f60\u4eec\u8bb2\u4ec0\u4e48\u9ad8\u7ea7\u7684\u4e1c\u897f\uff09\n\n\u4e0b\u9762\u6211\u5c31\u76f4\u63a5\u4e0a\u5b8c\u6574\u4ee3\u7801\u5427\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst long long maxn=400100;\nstruct node\n{\n    long long l,r,ls,rs,c,f;\n}tr[maxn];\nlong long n,m,root,mo,sz;\nlong long a[maxn],si[maxn],dep[maxn],fa[maxn],pos[maxn],top[maxn];\nvector<long long>q[maxn];\nlong long t;\nlong long nw(long long l,long long r)\n{\n    tr[++t]=(node){l,r,0,0,0,0};\n    return t;\n}\nvoid xf(long long o)\n{\n    long long l=tr[o].ls,r=tr[o].rs;\n    tr[o].c+=(tr[o].r-tr[o].l+1)*tr[o].f%mo;\n    tr[l].f+=tr[o].f;\n    tr[r].f+=tr[o].f;\n    tr[o].f=0;\n}\nvoid gx(long long o){\n    long long l=tr[o].ls,r=tr[o].rs;\n    xf(l),xf(r);\n    tr[o].c=(tr[l].c+tr[r].c)%mo;\n}\nvoid xg(long long o,long long l,long long r,long long c)\n{\n    xf(o);\n    if(tr[o].l==l&&tr[o].r==r)\n    {\n        tr[o].f+=c;\n        return;\n    }\n    long long mid=tr[o].l+tr[o].r>>1;\n    if(r<=mid)\n        xg(tr[o].ls?tr[o].ls:tr[o].ls=nw(tr[o].l,mid),l,r,c);\n    else\n    if(l>mid)\n        xg(tr[o].rs?tr[o].rs:tr[o].rs=nw(mid+1,tr[o].r),l,r,c);\n    else\n        xg(tr[o].ls,l,mid,c),xg(tr[o].rs,mid+1,r,c);\n    gx(o);\n}\nlong long cx(long long o,long long l,long long r)\n{\n    xf(o);\n    if(tr[o].l==l&&tr[o].r==r)\n        return tr[o].c%mo;\n    long long mid=tr[o].l+tr[o].r>>1;\n    if(r<=mid)\n        return cx(tr[o].ls,l,r);\n    else\n    if(l>mid)\n        return cx(tr[o].rs,l,r);\n    else\n        return (cx(tr[o].ls,l,mid)+cx(tr[o].rs,mid+1,r))%mo;\n}\nvoid dfs1(long long x)\n{\n    si[x]=1;\n    for(long long i=0;i<q[x].size();++i)\n    {\n        if(q[x][i]==fa[x])\n            continue;\n        dep[q[x][i]]=dep[x]+1;\n        fa[q[x][i]]=x;\n        dfs1(q[x][i]);\n        si[x]+=si[q[x][i]];\n    }\n}\nvoid dfs2(long long x,long long grfa)\n{\n    long long k=0;\n    sz++;\n    pos[x]=sz;\n    top[x]=grfa;\n    for(long long i=0;i<q[x].size();++i)\n    {\n        if(dep[x]<dep[q[x][i]] and si[q[x][i]]>si[k])\n        {\n            k=q[x][i];\n        }\n    }\n    if(k==0)\n        return;\n    dfs2(k,grfa);\n    for(long long i=0;i<q[x].size();++i)\n    {\n        if(dep[x]<dep[q[x][i]] and k!=q[x][i])\n            dfs2(q[x][i],q[x][i]);\n    }\n}\nlong long dianhe(long long x,long long y)\n{\n    long long ans=0;\n    while(top[x]!=top[y])\n    {\n    \tif(dep[top[x]]<dep[top[y]])\n        swap(x,y);\n        ans+=cx(1,pos[top[x]],pos[x]);\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])\n        swap(x,y);\n    ans+=cx(1,pos[y],pos[x]);\n    return ans%mo;\n}\nvoid dianchage(long long x,long long y,long long z)\n{\n    while(top[x]!=top[y])\n    {\n    \tif(dep[top[x]]<dep[top[y]])\n        swap(x,y);\n        xg(1,pos[top[x]],pos[x],z);\n        x=fa[top[x]];\n    }\n    if(dep[x]<dep[y])\n        swap(x,y);\n    xg(1,pos[y],pos[x],z);\n    return;\n}\nlong long shuhe(long long x)\n{\n    return cx(1,pos[x],pos[x]+si[x]-1);\n}\nvoid shuchage(long long x,long long y)\n{\n    xg(1,pos[x],pos[x]+si[x]-1,y);\n    return;\n}\nint main()\n{\n    scanf(\"%lld%lld%lld%lld\",&n,&m,&root,&mo);\n    for(long long i=1;i<=n;++i)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    long long x,y;\n    nw(1,n);//\u5efa\u8282\u70b9\n    for(long long i=1;i<n;++i)\n    {\n        scanf(\"%lld%lld\",&x,&y);\n        q[y].push_back(x);\n        q[x].push_back(y);\n    }\n    dfs1(root);//\u9884\u5904\u7406\n    dfs2(root,root);\n    for(long long i=1;i<=n;++i)\n    {\n        xg(1,pos[i],pos[i],a[i]);\n    }\n    long long k,h1,h2,h3;\n    while(m)\n    {\n        m--;\n        scanf(\"%lld\",&k);\n        if(k==1)\n        {\n            scanf(\"%lld%lld%lld\",&h1,&h2,&h3);\n            dianchage(h1,h2,h3);\n        }\n        if(k==2)\n        {\n            scanf(\"%lld%lld\",&h1,&h2);\n            printf(\"%lld\\n\",dianhe(h1,h2)%mo);\n        }\n        if(k==3)\n        {\n            scanf(\"%lld%lld\",&h1,&h2);\n            shuchage(h1,h2);\n        }\n        if(k==4)\n        {\n            scanf(\"%lld\",&h1);\n            printf(\"%lld\\n\",shuhe(h1)%mo);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1522904619,
        "uid": 60867,
        "name": "heyongxin",
        "ccfLevel": 6,
        "title": "\u6811\u5256"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u662f\u901a\u8fc7\u5c06\u4e00\u68f5\u6811\u5256\u6210\u591a\u6761\u94fe\uff0c\u7136\u540e\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u8fd9\u4e9b\u94fe\u6765\u5c06\u95ee\u9898\u7b80\u5316\u4e3a\u7ebf\u6027\u5904\u7406\uff0c\u4ece\u800c\u964d\u4f4e\u5904\u7406\u96be\u5ea6\u7684\u7b97\u6cd5\u3002\n\n\u9996\u5148\u8fdb\u884c\u4e00\u6b21$dfs$\uff0c\u6c42\u51fa\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\u3001\u5927\u5c0f\u548c\u91cd\u513f\u5b50\u7b49\u4fe1\u606f\u3002    \n\u518d\u6309\u7167\u91cd\u513f\u5b50\u4f18\u5148\u7684\u987a\u5e8f\u8fdb\u884c\u4e00\u6b21dfs\uff0c\u786e\u5b9a\u6bcf\u4e2a\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u7f16\u53f7\u53ca\u6240\u5728\u7684\u91cd\u94fe\u7684\u9876\u7aef\u7ed3\u70b9$top$\u3002\uff08\u5982\u679c\u662f\u8fb9\u4e0a\u7684\u4fe1\u606f\uff0c\u8ba9\u6bcf\u4e2a\u70b9\u8868\u793a\u5176\u7236\u8fb9\u5373\u53ef\uff09  \n\n\u6309\u7167\u91cd\u513f\u5b50\u4f18\u5148\u7684\u987a\u5e8f\u8fdb\u884cdfs\u5e76\u4f9d\u6b21\u7f16\u53f7\uff0c\u90a3\u4e48\u4e00\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u7f16\u53f7\u8fde\u7eed\u4e14\u968f\u6df1\u5ea6\u9012\u589e\u3002  \n\u6309\u7167dfs\u5e8f\u5efa\u7acb\u7ebf\u6bb5\u6811\u3002\u6811\u4e0a\u7684\u4efb\u4f55\u94fe\u5747\u53ef\u62c6\u5206\u6210$O(logn)$\u6761\u8f7b\u8fb9\u4e0e\u91cd\u94fe\u7684\u7ec4\u5408\uff0c\u5373\u5404\u79cd\u94fe\u4e0a\u7684\u67e5\u8be2\u548c\u4fee\u6539\u90fd\u53ea\u9700\u8981\u5728\u7ebf\u6bb5\u6811\u4e2d\u8fdb\u884c$O(logn)$\u6b21\u64cd\u4f5c\u3002  \n\u7531\u4e8e\u662fdfs\u5e8f\uff0c\u5bf9\u4e8e\u5b50\u6811\u64cd\u4f5c\u4e5f\u540c\u6837\u652f\u6301\u3002\n\n\u53ef\u4ee5\u8bc1\u660e\u4efb\u610f\u4e00\u4e2a\u70b9\u5230\u6839\u7684\u8def\u5f84\u4e0a\u6240\u7ecf\u8fc7\u7684\u91cd\u94fe\u548c\u8f7b\u8fb9\u6570\u91cf\u5747\u4e0d\u8d85\u8fc7$logn$\uff0c\u8fd9\u662f\u6574\u4e2a\u7b97\u6cd5\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u4fdd\u8bc1\u3002 \n\n\u6811\u94fe\u5256\u5206\u7531\u4e8e\u8f7b-\u91cd\u94fe\u5207\u6362$O( logn )$\u6b21\uff08\u6216\u8005\u8bf4\u6811\u7684\u542f\u53d1\u5f0f\u5408\u5e76\u6bcf\u6b21\u8bbf\u95ee$O( logn )$\u4e2a\u70b9\uff09\uff0c\u6bcf\u6b21\u8bbf\u95ee\u7684\u533a\u95f4\u4e0d\u8fde\u7eed\u5bfc\u81f4\u5b9e\u9645\u590d\u6742\u5ea6$O( log^2n )$\n\n\u786e\u5b9a\u4e00\u6761\u94fe\u5bf9\u5e94\u54ea\u4e9b\u91cd\u94fe\u548c\u8f7b\u8fb9\u65f6\uff0c\u6bcf\u6b21\u8ba9$top$\u6df1\u5ea6\u66f4\u5927\u7684\u70b9\uff08\u6ce8\u610f\u4e0d\u662f\u8be5\u70b9\u672c\u8eab\u6df1\u5ea6\u66f4\u5927\uff09\u5411\u4e0a\u8df3\uff0c\u5982\u679c\u5176\u662f\u8f7b\u513f\u5b50\u5219\u8df3\u4e00\u6761\u8f7b\u8fb9\uff0c\u5426\u5219\u8df3\u5230\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\uff0c\u6cbf\u9014\u901a\u8fc7\u7ebf\u6bb5\u6811\u8fdb\u884c\u4fee\u6539\u6216\u8005\u67e5\u8be2\u64cd\u4f5c\uff0c\u76f4\u5230\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u91cd\u94fe\u4e2d\u3002\u6700\u540e\u5904\u7406\u5269\u4e0b\u7684\u8fd9\u4e00\u6bb5\u3002\n\n\u8fd9\u91cc\u5728\u5b9e\u73b0\u65f6\u4f7f\u7528vector\u5b58\u56fe\u52a0zkw\u7ebf\u6bb5\u6811\u8fdb\u884c\u7ef4\u62a4\uff0c\u56e0\u6b64\u5e38\u6570\u8f83\u5c0f\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ninline int read()\n{\n\tint x=0;int f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\n\n#define fp(i,l,r) for(int i=l;i<=r;++i)\n#define fd(i,r,l) for(int i=r;i>=l;--i)\n\nconst int MAXN = 200005;\nstd::vector<int> G[MAXN];\nint size[MAXN],past[MAXN],dep[MAXN],fa[MAXN],dat[MAXN];\nint top[MAXN],ctr[MAXN],dfn[MAXN],son[MAXN];\nlong long tree[MAXN<<2],add[MAXN<<2];\nint n,m,root,len,cnt,p,N=1;\n\ninline void addedge(int u,int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\ninline void buildtree()\n{\n\tfor(;N<=n+1;N<<=1);\n\tfp(i,N+1,N+n) tree[i]=dat[past[i-N]];\n\tfd(i,N-1,1) tree[i]=tree[i<<1]+tree[i<<1|1];\n}\n\ninline void update(int s,int t,int k)\n{\n\tint l=0,r=0,num=1;\n\tfor(s=s+N-1,t=t+N+1;s^t^1;s>>=1,t>>=1,num<<=1)\n\t{\n\t\ttree[s]+=k*l;\n\t\ttree[t]+=k*r;\n\t\tif(~s&1) {add[s^1]+=k; tree[s^1]+=k*num; l+=num;}\n\t\tif(t&1)  {add[t^1]+=k; tree[t^1]+=k*num; r+=num;}\n\t}\n\tfor(;s;s>>=1,t>>=1)\n\t{\n\t\ttree[s]+=k*l;\n\t\ttree[t]+=k*r;\n\t}\n}\n\ninline long long query(int s,int t)\n{\n\tint l=0,r=0,num=1;\n\tlong long ans=0;\n\tfor(s=s+N-1,t=t+N+1;s^t^1;s>>=1,t>>=1,num<<=1)\n\t{\n\t\tif(add[s]) ans+=add[s]*l;\n\t\tif(add[t]) ans+=add[t]*r;\n\t\tif(~s&1) {ans+=tree[s^1]; l+=num;}\n\t\tif(t&1)  {ans+=tree[t^1]; r+=num;}\n\t}\n\tfor(;s;s>>=1,t>>=1)\n\t{\n\t\tans+=add[s]*l;\n\t\tans+=add[t]*r;\n\t}\n\treturn ans;\n}\n\nvoid dfs_getson(int x)\n{\n\tsize[x]=1;\n\tint sz=G[x].size();\n\tfor (int i = 0; i < sz; ++i)\n\t{\n\t\tint y=G[x][i];\n\t\tif(y==fa[x]) continue;\n\t\tdep[y]=dep[x]+1; fa[y]=x;\n\t\tdfs_getson(y);\n\t\tsize[x]+=size[y];\n\t\tif(size[y]>size[son[x]]) son[x]=y;\n\t}\n}\n\nvoid dfs_rewrite(int x,int tp)\n{\n\ttop[x]=tp; dfn[x]=++cnt; past[cnt]=x;\n\tif(son[x]) dfs_rewrite(son[x],tp);\n\tint sz=G[x].size();\n\tfor (int i = 0; i < sz; ++i)\n\t{\n\t\tint y=G[x][i];\n\t\tif(y!=fa[x] && y!=son[x])\n\t\t\tdfs_rewrite(y,y);\n\t}\n\tctr[x]=cnt;\n}\n\nvoid update_chain(int x,int y,int k)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tupdate(dfn[top[x]],dfn[x],k);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y]) swap(x,y);\n\tupdate(dfn[x],dfn[y],k);\n}\n\nlong long query_chain(int x,int y)\n{\n\tlong long ans=0;\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tans=(ans+query(dfn[top[x]],dfn[x]))%p;\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y]) swap(x,y);\n\t(ans+=query(dfn[x],dfn[y]))%=p;\n\treturn ans%p;\n}\n\ninline void update_subtree(int x,int k)\n{\n\tupdate(dfn[x],ctr[x],k);\n}\n\ninline long long query_subtree(int x)\n{\n\treturn query(dfn[x],ctr[x])%p;\n}\n\nint main(int argc, char const *argv[])\n{\n\tn=read(); m=read();\n\troot=read(); p=read();\n\tfor(int i=1;i<=n;++i) dat[i]=read();\n\tfor(int i = 1; i <= n - 1; ++i) addedge(read(),read());\n\tdfs_getson(root);\n\tdfs_rewrite(root,root);\n\tbuildtree();\n\tint opt,x,y;\n\tfor (int i = 0; i < m; ++i)\n\t{\n\t\topt=read(); x=read();\n\t\tif(opt==1) y=read(),update_chain(x,y,read());\n\t\tif(opt==2) printf(\"%lld\\n\", query_chain(x,read()));\n\t\tif(opt==3) update_subtree(x,read());\n\t\tif(opt==4) printf(\"%lld\\n\",query_subtree(x));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1573444191,
        "uid": 107735,
        "name": "shiroi",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "**[\u5728\u535a\u5ba2\u98df\u7528\u6548\u679c\u66f4\u4f73\uff08\u522b\u5fd8\u4e86\u70b9\u8d5e\u54e6\uff09]**(https://zhebeizizhiaicq.blog.luogu.org/)\n\n**\u9700\u8981\u89e3\u51b3\u7684\u95ee\u9898**\n    \n    \u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\t\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\t\u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\n\t\u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\n    \n\u6811\u94fe\u5256\u5206\uff1a\u5c31\u662f\u5c06\u6811\u5f62\u5256\u5206\u6210\u7ebf\u5f62\uff0c\u4ece\u800c\u964d\u4f4e\u5904\u7406\u96be\u5ea6\uff1b\n\n\u5bf9\u4e8e\u533a\u95f4\u52a0\u548c\u533a\u95f4\u6c42\u548c\uff0c\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u7ebf\u6bb5\u6811\uff0c\u5728\u6211\u4eec\u628a\u6811\u5256\u5206\u6210\u4e0d\u540c\u7684\u94fe\u65f6\uff0c\u5c31\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u53bb\u7ef4\u62a4\u4e0d\u540c\u7684\u94fe\u7684\u533a\u95f4\u548c\u3002\n\n\u9884\u5904\u7406\u90e8\u5206\uff1a\uff08\u4e24\u6b21\u641c\u7d22dfs\uff09\n\t\n\u7b2c\u4e00\u6b21\u641c\u7d22\uff1a\u76ee\u7684\u662f\u9884\u5904\u7406\u51fa\u6765\u6bcf\u4e2a\u8282\u70b9\u7684\uff1a\u6df1\u5ea6\uff0c\u7236\u4eb2\uff0c\u91cd\u513f\u5b50\u548c\u5b50\u6811\u5927\u5c0f\uff08size\uff09\uff1b\n\n\u89c1\u4ee3\u7801\n```cpp\nvoid dfs_a(int u,int f,int depth){\n\tdep[u]=depth;\n\tsize[u]=1;\n\tfa[u]=f;\n\tint maxson=-1;\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v==f||dep[v])continue;\n\t\tdfs_a(v,u,depth+1);\n\t\tsize[u]+=size[v];\n\t\tif(size[v]>maxson){\n\t\t\tson[u]=v;\n\t\t\tmaxson=size[v];\n\t\t}\n\t}\n}\n```\n\n\u7b2c\u4e8c\u6b21\u641c\u7d22\uff1a\u76ee\u7684\u662f\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684dfn\uff08\u641c\u7d22\u6b21\u5e8f\uff09\uff0c\u8fd9\u6837\u4fbf\u4e8e\u5bf9\u6574\u4e2a\u5b50\u6811\u548c\u94fe\u8fdb\u884c\u64cd\u4f5c\u3002\u9664\u6b64\u4e4b\u5916\u8fd8\u8981\u5904\u7406\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684top\u503c\uff0c\u5c31\u662f\u4ed6\u6240\u5728\u7684\u94fe\u7684\u9876\u7aef\uff08\u6df1\u5ea6\u6700\u5c0f\u7684\u8282\u70b9\u7684\u6743\u503c\uff09\uff1b\n\n\u8fd8\u5269\u4e0b\u4e00\u4e2a\u6bd4\u8f83\u96be\u7406\u89e3\u7684\u6570\u7ec4\u5728\u7b2c\u4e8c\u6b21dfs\u4e2d\u88ab\u5904\u7406\uff0c\n\u56e0\u4e3a\u4e0d\u7406\u89e3\uff0c\u6682\u4e14\u79f0\u5176\u4e3azz\u6570\u7ec4\uff1b\u4e4b\u540e\u5927\u4f6c\u4e00\u53e5\u8bdd\u70b9\u9192\u68a6\u4e2d\u4eba\u3002\n\n\u5728\u4ee3\u7801\u4e2d\u53ef\u4ee5\u53d1\u73b0\uff0czz\u6570\u7ec4\u53ea\u5728\u5efa\u6811\u65f6\u88ab\u4f7f\u7528\u8fc7\uff0c\u90a3\u4e48\u5f88\u5bb9\u6613\u53ef\u4ee5\u77e5\u9053\uff0czz\u6570\u7ec4\u662fdfn\u6570\u7ec4\u7684\u9006\uff08\u5373\u9006dfn\u6570\u7ec4\uff09\uff1b\u7528\u5904\u662f\u5728\u5efa\u6811\u65f6\uff0c\u901a\u8fc7\u6211\u4eec\u77e5\u9053\u7684l,r\uff08\u8fd9\u4e9b\u90fd\u662fdfn\u5e8f\uff09\uff0c\u63a8\u51fa\u8282\u70b9\u771f\u6b63\u7684\u7f16\u53f7\uff0c\u518d\u53bb\u5f15\u7528\u5176\u6743\u503c\u3002\n\n\u89c1\u4ee3\u7801\n```cpp\nvoid dfs_b(int u,int topf){\n\tdfn[u]=++tot;\n\ttop[u]=topf;\n\tzz[tot]=u;\n\tif(son[u])dfs_b(son[u],topf);\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v!=fa[u]&&v!=son[u]){\n\t\t\tdfs_b(v,v);\n\t\t}\n\t}\n}\n```\n\n\u597d\u4e86\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u9884\u5904\u7406\u3002\u5f53\u7136\uff0c\u5728\u6b63\u5f0f\u64cd\u4f5c\u4e4b\u524d\uff0c\u6211\u4eec\u8fd8\u6709\u4e00\u6b65\u8981\u505a\uff0c\u5f53\u7136\u5c31\u662f\u5efa\u6811\u5566\u3002\n\n\u8fd9\u91cc\u6ce8\u610f\u4e00\u4ef6\u4e8b\uff0c\u6211\u4eec\u5728\u5efa\u6811\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5411\u51fd\u6570\u4f20\u5165\u7684l,r\u90fd\u662fdfn\u5e8f\uff0c\u800c\u6211\u4eec\u5f15\u7528\u8be5\u70b9\u7684\u6743\u503c\uff0c\u9700\u8981\u7684\u662f\u521d\u59cb\u7684\u5e8f\u53f7\uff0c\u8fd9\u65f6\u6211\u4eec\u7684zz\u6570\u7ec4\u5c31\u8d77\u5230\u4e86\u4f5c\u7528\uff0c\u4ed6\u8bb0\u5f55\u7684\u5c31\u662f\u539f\u5e8f\u548cdfn\u5e8f\u7684\u5173\u7cfb\u3002\n\n\u89c1\u4ee3\u7801\n```cpp\nvoid build(int o,int l,int r){\n\n\tif(l==r){\n\t\ttag[o]=0;\n\t\tans[o]=a[zz[l]];\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(ls(o),l,mid);\n\tbuild(rs(o),mid+1,r);\n\tpush_up(o);\n}\n```\n\n\u540c\u4e0a\u6240\u8ff0\uff0c\u5bf9\u4e8e\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5728\u5efa\u6811\u64cd\u4f5c\u505a\u4e00\u70b9\u4fee\u6539\uff0c\u5c31\u662f\u5c06dfn\u5e8f\u8f6c\u5316\u4e3a\u539f\u5e8f\uff0c\u6211\u5c31\u662f\u5ffd\u7565\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u5199\u4e86\u597d\u4e45\u597d\u4e45\uff08\u5f53\u7136\u5e94\u9898\u76ee\u8981\u6c42\uff0c\u6211\u4eec\u5c3d\u53ef\u80fd\u5728\u7ebf\u6bb5\u6811\u64cd\u4f5c\u540e\u52a0\u4e0a\u53d6\u6a21\uff09\uff0c\u5176\u5b9e\u5c31\u662f\u7ebf\u6bb5\u6811\u533a\u95f4\u52a0\uff0c\u533a\u95f4\u6c42\u548c\u7684\u677f\u5b50\u4e86\u3002\n\n\u89c1\u7ebf\u6bb5\u6811\u4ee3\u7801\n```cpp\nvoid push_up(int o){\n\tans[o]=ans[ls(o)]+ans[rs(o)];\n\tans[o]%=mod;\n}\n\nvoid build(int o,int l,int r){\n\n\tif(l==r){\n\t\ttag[o]=0;\n\t\tans[o]=a[zz[l]];\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(ls(o),l,mid);\n\tbuild(rs(o),mid+1,r);\n\tpush_up(o);\n}\n\nvoid f(int o,int l,int r,int k){\n\ttag[o]+=k;\n\tans[o]+=k*(r-l+1);\n\tans[o]%=mod;\n}\n\nvoid down(int o,int l,int r){\n\tint mid=l+r>>1;\n\tf(ls(o),l,mid,tag[o]);\n\tf(rs(o),mid+1,r,tag[o]);\n\ttag[o]=0;\n\tpush_up(o);\n}\n\nint query_tree(int ql,int qr,int l,int r,int o){\n\tint sum=0;\n\tif(ql<=l&&qr>=r)return ans[o];\n\tint mid=l+r>>1;\n\tdown(o,l,r);\n\tif(ql<=mid)sum+=query_tree(ql,qr,l,mid,ls(o));\n\tif(qr>mid)sum+=query_tree(ql,qr,mid+1,r,rs(o));\n\treturn sum%mod;\n}\n\nvoid update_tree(int ql,int qr,int l,int r,int o,int k){\n\tif(ql<=l&&r<=qr){\n\t\ttag[o]+=k;\n\t\tans[o]+=k*(r-l+1);\n\t\tans[o]%=mod;\n\t\treturn ;\n\t}\n\tdown(o,l,r);\n\tint mid=l+r>>1;\n\tif(ql<=mid)update_tree(ql,qr,l,mid,ls(o),k);\n\tif(qr>mid)update_tree(ql,qr,mid+1,r,rs(o),k);\n\tpush_up(o);\n}\n```\n\n\u5b8c\u6210\u4e86\u90a3\u4e48\u591a\uff0c\u901a\u8fc7dfs\u5df2\u7ecf\u628a\u6811\u7684\u6bcf\u4e2a\u94fe\u5904\u7406\u51fa\u6765\u4e86\uff0c\u4e5f\u628a\u7ebf\u6bb5\u6811\u7801\u597d\u4e86\uff0c\u90a3\u4e48\u6211\u4eec\u63a5\u4e0b\u6765\u8981\u505a\u4ec0\u4e48\u5462\uff1f\n\n\u56de\u987e\u9898\u9762\uff0c\u53d1\u73b0\u524d\u4e24\u4e2a\u64cd\u4f5c\uff1a\n\n\u64cd\u4f5c1\uff1a \u683c\u5f0f\uff1a 1 x y z \u8868\u793a\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\n\u64cd\u4f5c2\uff1a \u683c\u5f0f\uff1a 2 x y \u8868\u793a\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\n\u6211\u4eec\u53ea\u9760\u73b0\u6709\u7684\u8d44\u6e90\u662f\u505a\u4e0d\u5230\u8fd9\u4e9b\u7684\u3002\u90a3\u4e48\u5c31\u9700\u8981\u505a\u4e9b\u4ec0\u4e48\u53bb\u89e3\u51b3\u8fd9\u4e24\u4e2a\u95ee\u9898\u3002\u518d\u60f3\u60f3\uff0c\u6211\u4eec\u628a\u6811\u5256\u5206\u7684\u76ee\u7684\u662f\u4ec0\u4e48\uff1f\u5c31\u662f\u5c06\u6811\u8f6c\u5316\u4e3a\u7ebf\u5f62\u6765\u8fdb\u884c\u64cd\u4f5c\u3002\n\n\u6211\u4eec\u53c8\u77e5\u9053\u91cd\u94fe\u548c\u8f7b\u94fe\u7684\u6027\u8d28\uff0c\u90a3\u4e48\u5f53\u7ed9\u51fax,y\u8ba9\u6211\u4eec\u5bf9x,y\u4e4b\u95f4\u8def\u5f84\u4e0a\u7684\u70b9\u8fdb\u884c\u64cd\u4f5c\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5c06\u8fd9\u4e00\u6761\u8def\u5f84\u770b\u6210\u597d\u51e0\u4e2a\u94fe\uff0c\u518d\u5206\u522b\u8fdb\u884c\u64cd\u4f5c\uff0c\u5c31\u53ef\u4ee5\u7b80\u5355\u6709\u6548\u7684\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\u5bf9\u4e8e\u8def\u5f84\u4e0a\u52a0\u503c\u548c\u8def\u5f84\u4e0a\u6c42\u548c\u8fd9\u4e24\u4e2a\u64cd\u4f5c\uff0c\u5176\u5b9e\u4ee3\u7801\u5927\u540c\u5c0f\u5f02\u3002\u9700\u8981\u5927\u5bb6\u638c\u63e1\u7684\uff0c\u662f\u5728\u6811\u4e0a\u8fdb\u884c\u64cd\u4f5c\u7684\u8fc7\u7a0b\u3002\u5e0c\u671b\u5927\u5bb6\u53ef\u4ee5\u591a\u753b\u753b\u56fe\uff0c\u5728\u601d\u60f3\u4e2d\u5f62\u6210\u5b8c\u6574\u7684\u8fc7\u7a0b\uff0c\u8fd9\u6837\u81ea\u7136\u53ef\u4ee5\u975e\u5e38\u987a\u5229\u7684\u7406\u89e3\u3002\n\n\u89c1\u4ee3\u7801\uff1a\n```cpp\nint query(int x,int y){\n\tlong long sum=0;\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy){\n\t\tif(dep[fx]>dep[fy]){\n\t\t\tsum+=query_tree(dfn[fx],dfn[x],1,n,1);//\u533a\u95f4\u6c42\u548c \u6a21\u4eff\u5728\u8f7b\u91cd\u94fe\u4e0a\u8df3\u7684\u8fc7\u7a0b \n\t\t\tx=fa[fx];\n\t\t}\n\t\telse{\n\t\t\tsum+=query_tree(dfn[fy],dfn[y],1,n,1);\n\t\t\ty=fa[fy];\n\t\t}\n\t\tfx=top[x];\n\t\tfy=top[y];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tsum+=query_tree(dfn[x],dfn[y],1,n,1);//\u6700\u540e\u8df3\u5230\u4e00\u6761\u91cd\u94fe\u4e0a\u5566\uff0c\u5c31\u8981\u5bf9\u8fd9\u6761\u91cd\u94fe\u4e0ax\u5230y\u6c42\u548c \n\tsum%=mod;\n\treturn sum;\n}\n\nvoid update(int x,int y,int k){\n\tint fx=top[x];\n\tint fy=top[y];\n\twhile(fx!=fy){\n\t\tif(dep[fx]>dep[fy]){\n\t\t\tupdate_tree(dfn[fx],dfn[x],1,n,1,k);\n\t\t\tx=fa[fx];\n\t\t}\n\t\telse{\n\t\t\tupdate_tree(dfn[fy],dfn[y],1,n,1,k);\n\t\t\ty=fa[fy];\n\t\t}\n\t\tfx=top[x];\n\t\tfy=top[y];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tupdate_tree(dfn[x],dfn[y],1,n,1,k);\n}\n```\n\u81f3\u6b64\uff0c\u6240\u6709\u7684\u51c6\u5907\u5de5\u4f5c\u5168\u90e8\u5b8c\u6210\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u5bf9\u9898\u76ee\u7ed9\u7684\u56db\u4e2a\u64cd\u4f5c\u641e\u4e8b\u60c5\u4e86\u3002\n\n\u64cd\u4f5c\u4e00\uff1a\u683c\u5f0f\uff1a 1 x y z \u8868\u793a\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\u5c31\u662f\u4e0a\u8ff0\u6211\u4eec\u89e3\u51b3\u7684\u8def\u5f84\u4e0a\u52a0\u7684\u95ee\u9898\u5566\u3002\n\n\u64cd\u4f5c\u4e8c\uff1a\u683c\u5f0f\uff1a 2 x y \u8868\u793a\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\n\u540c\u6837\uff0c\u6211\u4eec\u901a\u8fc7\u8def\u5f84\u4e0a\u6c42\u548c\u7684\u51fd\u6570\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\u64cd\u4f5c\u4e09\uff1a\u683c\u5f0f\uff1a 3 x z \u8868\u793a\u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\n\n\u8fd9\u4e2a\u66f4\u52a0\u7b80\u5355\uff0c\u901a\u8fc7dfs\u9884\u5904\u7406\uff0c\u6211\u4eec\u5df2\u7ecf\u77e5\u9053x\u8282\u70b9\u7684dfn\u5e8f\uff0c\u53c8\u56e0\u4e3adfn\u7684\u6027\u8d28\uff1a**\u4e00\u4e2a\u8282\u70b9\u53ca\u4ed6\u5b50\u6811\u7684df\u5e8f\u662f\u8fde\u7eed\u7684**\uff0c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0c\u76f4\u63a5\u5c06dfn\u5e8f\u4f20\u5165\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u52a0\uff0c\u5c31\u53ef\u4ee5\u89e3\u51b3\u6b64\u95ee\u9898\u3002\n\n\u64cd\u4f5c\u56db\uff1a\u683c\u5f0f\uff1a 4 x \u8868\u793a\u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\n\n\u6211\u4eec\u6cbf\u7528\u89e3\u51b3\u4e0a\u4e2a\u95ee\u9898\u7684\u601d\u8def\uff0c\u5c06\u8be5\u5b50\u6811\u7684dfn\u5e8f\u8303\u56f4\u4f20\u5165\u7ebf\u6bb5\u6811\u533a\u95f4\u6c42\u548c\u51fd\u6570\uff0c\u5c31\u5c06\u6b64\u95ee\u9898\u89e3\u51b3\uff1b\n\nAC\u4ee3\u7801\u5728\u8fd9\u91cc\uff1a\n```cpp\n#include<iostream>\n#include<cstdio>\n#define cq(i,s,n) for(int i=s;i<=n;i++)\n#define ls(o)\to<<1\n#define rs(o)\to<<1|1\nusing namespace std;\nstruct edge{\n\tint nxt,to;\n}edge[200005];\nint head[200005],vis[200005],fa[200005],size[200005],son[200005];\nint num,tot;\nint n,m,s,x,y,opt,mod;\nint dep[200005],a[200005];\nint dfn[200005],top[200005];\nint ans[400005],tag[400005];\nint zz[400005];\nint q1,q2,q3;\n\nvoid push_up(int o){\n\tans[o]=ans[ls(o)]+ans[rs(o)];\n\tans[o]%=mod;\n}\n\nvoid build(int o,int l,int r){\n\n\tif(l==r){\n\t\ttag[o]=0;\n\t\tans[o]=a[zz[l]];\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(ls(o),l,mid);\n\tbuild(rs(o),mid+1,r);\n\tpush_up(o);\n}\n\nvoid f(int o,int l,int r,int k){\n\ttag[o]+=k;\n\tans[o]+=k*(r-l+1);\n\tans[o]%=mod;\n}\n\nvoid down(int o,int l,int r){\n\tint mid=l+r>>1;\n\tf(ls(o),l,mid,tag[o]);\n\tf(rs(o),mid+1,r,tag[o]);\n\ttag[o]=0;\n\tpush_up(o);\n}\n\nint query_tree(int ql,int qr,int l,int r,int o){\n\tint sum=0;\n\tif(ql<=l&&qr>=r)return ans[o];\n\tint mid=l+r>>1;\n\tdown(o,l,r);\n\tif(ql<=mid)sum+=query_tree(ql,qr,l,mid,ls(o));\n\tif(qr>mid)sum+=query_tree(ql,qr,mid+1,r,rs(o));\n\treturn sum%mod;\n}\n\nvoid update_tree(int ql,int qr,int l,int r,int o,int k){\n\tif(ql<=l&&r<=qr){\n\t\ttag[o]+=k;\n\t\tans[o]+=k*(r-l+1);\n\t\tans[o]%=mod;\n\t\treturn ;\n\t}\n\tdown(o,l,r);\n\tint mid=l+r>>1;\n\tif(ql<=mid)update_tree(ql,qr,l,mid,ls(o),k);\n\tif(qr>mid)update_tree(ql,qr,mid+1,r,rs(o),k);\n\tpush_up(o);\n}\nvoid add(int from,int to){\n\tedge[++num].nxt=head[from];\n\tedge[num].to=to;\n\thead[from]=num;\n}\n\nvoid dfs_a(int u,int f,int depth){\n\tdep[u]=depth;\n\tsize[u]=1;\n\tfa[u]=f;\n\tint maxson=-1;\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v==f||dep[v])continue;\n\t\tdfs_a(v,u,depth+1);\n\t\tsize[u]+=size[v];\n\t\tif(size[v]>maxson){\n\t\t\tson[u]=v;\n\t\t\tmaxson=size[v];\n\t\t}\n\t}\n}\n\nvoid dfs_b(int u,int topf){\n\tdfn[u]=++tot;\n\ttop[u]=topf;\n\tzz[tot]=u;\n\tif(son[u])dfs_b(son[u],topf);\n\tfor(int i=head[u];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v!=fa[u]&&v!=son[u]){\n\t\t\tdfs_b(v,v);\n\t\t}\n\t}\n}\n\nint query(int x,int y){\n\tlong long sum=0;\n\tint fx=top[x],fy=top[y];\n\twhile(fx!=fy){\n\t\tif(dep[fx]>dep[fy]){\n\t\t\tsum+=query_tree(dfn[fx],dfn[x],1,n,1);//\u533a\u95f4\u6c42\u548c \u6a21\u4eff\u5728\u8f7b\u91cd\u94fe\u4e0a\u8df3\u7684\u8fc7\u7a0b \n\t\t\tx=fa[fx];\n\t\t}\n\t\telse{\n\t\t\tsum+=query_tree(dfn[fy],dfn[y],1,n,1);\n\t\t\ty=fa[fy];\n\t\t}\n\t\tfx=top[x];\n\t\tfy=top[y];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tsum+=query_tree(dfn[x],dfn[y],1,n,1);//\u6700\u540e\u8df3\u5230\u4e00\u6761\u91cd\u94fe\u4e0a\u5566\uff0c\u5c31\u8981\u5bf9\u8fd9\u6761\u91cd\u94fe\u4e0ax\u5230y\u6c42\u548c \n\tsum%=mod;\n\treturn sum;\n}\n\nvoid update(int x,int y,int k){\n\tint fx=top[x];\n\tint fy=top[y];\n\twhile(fx!=fy){\n\t\tif(dep[fx]>dep[fy]){\n\t\t\tupdate_tree(dfn[fx],dfn[x],1,n,1,k);\n\t\t\tx=fa[fx];\n\t\t}\n\t\telse{\n\t\t\tupdate_tree(dfn[fy],dfn[y],1,n,1,k);\n\t\t\ty=fa[fy];\n\t\t}\n\t\tfx=top[x];\n\t\tfy=top[y];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tupdate_tree(dfn[x],dfn[y],1,n,1,k);\n}\nint main(){\n\tscanf(\"%d%d%d%d\",&n,&m,&s,&mod);\n\tcq(i,1,n){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tcq(i,1,n-1){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs_a(s,0,1);\n\tdfs_b(s,s);\n\tbuild(1,1,n);\n\n\tcq(i,1,m){\n\t\tscanf(\"%d\",&opt);\n\t\tif(opt==1){\n\t\t\tscanf(\"%d%d%d\",&q1,&q2,&q3);\n\t\t\tupdate(q1,q2,q3);\n\t\t}\n\t\telse if(opt==2){\n\t\t\tscanf(\"%d%d\",&q1,&q2);\n\t\t\tprintf(\"%d\\n\",query(q1,q2));\n\t\t}\n\t\telse if(opt==3){\n\t\t\tscanf(\"%d%d\",&q1,&q2);\n\t\t\tupdate_tree(dfn[q1],dfn[q1]+size[q1]-1,1,n,1,q2);\n\t\t}\n\t\telse if(opt==4){\n\t\t\tscanf(\"%d\",&q1);\n\t\t\tprintf(\"%d\\n\",query_tree(dfn[q1],dfn[q1]+size[q1]-1,1,n,1));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n\u7efc\u4e0a\uff0c\u6811\u94fe\u5256\u5206\u6a21\u677f\u9898\u76ee\u6211\u4eec\u5df2\u7ecf\u89e3\u51b3\u3002\n\n\u90a3\u5c31\u8bf4\u4e00\u8bf4\u6211\u5728\u5b66\u4e60\u6811\u94fe\u5256\u5206\u8fc7\u7a0b\u4e2d\u9047\u5230\u7684\u95ee\u9898\u5427\u3002\n\n\u7b2c\u4e00\u6b21\u542c\u601d\u8def\u7684\u65f6\u5019\uff0c\u81ea\u8ba4\u4e3a\u8fd8\u662f\u5f88\u6e05\u695a\u7684\u3002\n\n\u5f53\u56de\u987e\u51e0\u904d\u4e4b\u540e\u53bb\u6572\u4ee3\u7801\uff0c\u5374\u9047\u5230\u4e86\u5927\u5927\u5c0f\u5c0f\u7684\u95ee\u9898\uff1b\n\n\u4e00\u3001\u5bf9\u4e8e\u89e3\u51b3\u5728\u8def\u5f84\u4e0a\u6c42\u548c\u548c\u52a0\u7684\u8fc7\u7a0b\uff0c\u4e0d\u77e5\u9053\u600e\u4e48\u5b9e\u73b0\u3002\u8fd9\u91cc\u9700\u8981\u5927\u5bb6\u7406\u89e3\u601d\u8def\uff0c\u5728x\u548cy\u4e0d\u5728\u540c\u4e00\u94fe\u4e0a\u65f6\uff0c\u6211\u4eec\u6a21\u4eff\u8282\u70b9\u5411\u4e0a\u8df3\uff0c\u5728\u8fd9\u4e00\u6761\u94fe\u4e0a\u64cd\u4f5c\u5b8c\u4e4b\u540e\uff0c\u4f7f\u8282\u70b9\u8df3\u5230\u5f53\u524d\u91cd\u94fe\u7684\u9876\u90e8\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u3002\n\n\u8fd8\u9700\u8981\u5927\u5bb6\u6e05\u695a\u4e00\u4e2a\u4e8b\u60c5\uff1a\u8f7b\u94fe\u7684\u4f5c\u7528\u662f\u8fde\u63a5\u91cd\u94fe\uff0c\u5373\u6211\u4eec\u4ece\u91cd\u94fe\u7684top\u8282\u70b9\u8df3\u5230\u5176\u7236\u4eb2\u8282\u70b9\uff0c\u76f8\u5f53\u4e8e\u8df3\u8fc7\u4e86\u4e00\u90e8\u5206\u8f7b\u94fe\u3002\n\n\u4e8c\u3001\u5728\u5efa\u6811\u8fc7\u7a0b\u4e2d\uff0c\u5ffd\u7565\u4e86\u9700\u8981\u5728dfn\u5e8f\u548c\u539f\u5e8f\u8f6c\u6362\u7684\u95ee\u9898\u3002\n\n\u53ef\u80fd\u6211\u7684\u601d\u8def\u4e0d\u751a\u6e05\u6670\uff0c\u4f46\u662f\u8fd8\u662f\u5e0c\u671b\u5bf9\u5927\u5bb6\u6709\u6240\u5e2e\u52a9\u3002",
        "postTime": 1534289983,
        "uid": 87942,
        "name": "w_x_c_q",
        "ccfLevel": 0,
        "title": "P3384 \u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\u697c\u4e0b\u8bb2\u5f97\u6bd4\u8f83\u6e05\u695a\u4e86\n\n\u53ea\u662f\u6211\u770b\u9898\u89e3\u6ca1\u6709\u6811\u72b6\u6570\u7ec4\u7684\n\n\u56e0\u4e3a\u8fd9\u9053\u9898\u662f\u53ea\u6709\u533a\u95f4\u4fee\u6539\u533a\u95f4\u6c42\u548c,\u4e8e\u662f\u6211\u4eec\u76f4\u63a5\u642c\u4e0a\u6811\u72b6\u6570\u7ec4\n\n\u539f\u7406\u770b\u8fd9\u91cchttp://www.cnblogs.com/lcf-2000/p/5866170.html\n\n\u8fd9\u91cc\u662f\u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#define re register int\n#ifdef ONLINE_JUDGE\nchar ss[1<<17],*A=ss,*B=ss;\ninline char gc(){if(A==B){B=(A=ss)+fread(ss,1,1<<17,stdin);if(A==B)return EOF;}return*A++;}\ntemplate<class T>inline void cin(T&x){\n    static char c;static int y;\n    for(c=gc(),x=0,y=1;c<48||57<c;c=gc())if(c=='-')y=-1;\n    for(;48<=c&&c<=57;c=gc())x=((x+(x<<2))<<1)+(c^'0');\n    x*=y;\n}\n#else\nvoid cin(int&x){scanf(\"%d\",&x);}\n#endif\nconst int N=5e5+5;\ntypedef int array[N];\ntypedef long long ll;\nstruct edges{int nx,to;}e[N<<1];\nint n,m,s,mod,tot,tmp;array a,b,depth,fa,son,size,top,id,real,fi;ll c1[N],c2[N];\nvoid dfs1(re u){\n    depth[u]=depth[fa[u]]+(size[u]=1);\n    for(re i=fi[u],v;i;i=e[i].nx)\n        if((v=e[i].to)!=fa[u]){\n            fa[v]=u;dfs1(v);size[u]+=size[v];\n            if(size[v]>size[son[u]])son[u]=v;\n        }\n}\nvoid dfs2(re u){\n    if(son[fa[u]]==u)top[u]=top[fa[u]];\n    else top[u]=u;\n    real[id[u]=++tmp]=u;\n    if(son[u])dfs2(son[u]);\n    for(re v,i=fi[u];i;i=e[i].nx)\n        if((v=e[i].to)!=fa[u]&&v!=son[u])\n            dfs2(v);\n}\ninline void insert(re x,ll w){for(re i=x;i<=n;i+=i&(-i))c1[i]+=w,c2[i]+=(ll)x*w;}\ninline ll sigma(re x){ll sum=0;for(re i=x;i;i-=i&(-i))sum+=(ll)(x+1)*c1[i]-c2[i];return sum;}\ninline void swap(re&x,re&y){re t=x;x=y;y=t;}\nvoid change(re u,re v,re w){\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])swap(u,v);\n        insert(id[top[u]],w);insert(id[u]+1,-w);\n        u=fa[top[u]];\n    }\n    if(depth[u]>depth[v])swap(u,v);\n    insert(id[u],w);insert(id[v]+1,-w);\n}\ninline ll sum(re u,re v){\n    ll sum=0;\n    while(top[u]!=top[v]){\n        if(depth[top[u]]<depth[top[v]])swap(u,v);\n        sum+=sigma(id[u])-sigma(id[top[u]]-1);\n        u=fa[top[u]];\n    }\n    if(depth[u]>depth[v])swap(u,v);\n    sum+=sigma(id[v])-sigma(id[u]-1);\n    return sum%mod;\n}\ninline void add(re u,re v){e[++tot]=(edges){fi[u],v};fi[u]=tot;}\nint main(){\n    cin(n);cin(m);cin(s);cin(mod);\n    for(re i=1;i<=n;++i)cin(a[i]);\n    for(re u,v,i=1;i<n;++i)cin(u),cin(v),add(u,v),add(v,u);\n    dfs1(s);dfs2(s);\n    for(re i=1;i<=n;i++)b[i]=a[real[i]];\n    for(re i=1;i<=n;i++)insert(i,b[i]-b[i-1]);\n    re op,x,y,z;\n    while(m--){\n        cin(op);cin(x);\n        if(op==1)cin(y),cin(z),change(x,y,z);\n        else if(op==2)cin(y),printf(\"%d\\n\",sum(x,y));\n        else if(op==3)cin(y),insert(id[x],y),insert(id[x]+size[x]-1+1,-y);\n        else printf(\"%d\\n\",(sigma(id[x]+size[x]-1)-sigma(id[x]-1))%mod);\n    }\nreturn 0;\n}\n```",
        "postTime": 1497161458,
        "uid": 20156,
        "name": "Kelin",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u4e00\u9053\u6a21\u677f\u9898\uff0c\u672c\u4eba\u6811\u5256\u5199\u6cd5\u6bd4\u8f83\u72ec\u7279\u3002\n\n\u53ef\u4ee5\u770b\u4e00\u770bQ\u548cE\u51fd\u6570\u90e8\u5206\uff0c\u4e00\u5b9a\u8bb0\u5f97\u6309\u7167**\u94fe\u9876**\u6df1\u5ea6\u64cd\u4f5c\u3002\n\n\n\n\n\n\n\n\n    \n    \n    \n    \n    \n\n\n\n\n\n    \n\n\n\n\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define MAXN 500000\n#define mx(x) t[x].mx\n#define lz(x) t[x].lz\n#define lc(x) (x<<1)\n#define rc(x) ((x<<1)|1)\n#define mid ((lef+rig)>>1) \nint N,M,R,P;\nstruct Node\n{\n    int lz,mx;    \n}; \nstruct Segment_Tree\n{\n    int dat[MAXN+5];\n    Node t[MAXN+5];\n    int top;\n    void Push(int p)\n    {\n        mx(p) = (mx(lc(p)) + mx(rc(p)))%P;\n        return;\n    }\n    void Lazy(int p, int lef, int rig)\n    {\n        if(lz(p))\n        {\n            (mx(lc(p)) += (mid-lef+1)*lz(p)) %= P;\n            (mx(rc(p)) += ( rig-mid )*lz(p)) %= P;\n            (lz(lc(p)) += lz(p)) %= P;\n            (lz(rc(p)) += lz(p)) %= P;\n            lz(p) = 0;\n        }\n        return;\n    }\n    void Build(int p, int lef, int rig)\n    {\n        lz(p) = 0;    \n        if(lef == rig)\n        {\n            mx(p) = dat[lef]%P;\n            return;\n        }\n        Build(lc(p),lef,mid);\n        Build(rc(p),mid+1,rig);\n        Push(p);\n        return;\n    }\n    int Query(int p, int lef, int rig, int L, int R)\n    {\n        Lazy(p,lef,rig);\n        if(L == lef && R == rig)\n            return mx(p);\n        if(R <= mid)\n            return Query(lc(p),lef,mid,L,R);\n        if(L >  mid)\n            return Query(rc(p),mid+1,rig,L,R);\n        return (Query(lc(p),lef,mid,L,mid)+Query(rc(p),mid+1,rig,mid+1,R))%P;        \n    }\n    void Edit(int p, int lef, int rig, int L, int R, int x)\n    {\n        Lazy(p,lef,rig);\n        if(L == lef && R == rig)\n        {\n            (mx(p) += x*(rig-lef+1)) %= P, (lz(p) += x) %= P;\n            return;\n        }\n        if(R <= mid)\n            Edit(lc(p),lef,mid,L,R,x);\n        else if(L > mid)\n            Edit(rc(p),mid+1,rig,L,R,x);\n        else\n            Edit(lc(p),lef,mid,L,mid,x),Edit(rc(p),mid+1,rig,mid+1,R,x);\n        Push(p);\n        return;    \n    }\n};\nstruct Edge\n{\n    int to,nex;\n    Edge(){}\n    Edge(int _to, int _nex):to(_to),nex(_nex){}\n};\nEdge e[MAXN*2+5];\nint first[MAXN+5], fa[MAXN+5], pos[MAXN+5], dep[MAXN+5], sz[MAXN+5], heavy[MAXN+5], top[MAXN+5], bound[MAXN+5], tot, dfn;\nvoid Add(int a, int b)\n{\n    e[tot] = Edge(b,first[a]);\n    first[a] = tot++;\n    return;\n}\nvoid DFS1(int p, int father)\n{\n    sz[p] = 1;\n    for(int u = first[p]; u != -1; u = e[u].nex)\n        if(e[u].to != father)\n        {\n            dep[e[u].to] = dep[p]+1, fa[e[u].to] = p, DFS1(e[u].to,p), sz[p] += sz[e[u].to];\n            if(!heavy[p] || sz[e[u].to] > sz[heavy[p]])\n                heavy[p] = e[u].to;\n        }\n    return;\n}\nvoid DFS2(int p)\n{\n    bound[p] = pos[p];\n    if(heavy[p])\n        pos[heavy[p]] = dfn++, top[heavy[p]] = top[p], DFS2(heavy[p]), bound[p] = max(bound[p],bound[heavy[p]]);\n    for(int u = first[p]; u != -1; u = e[u].nex)\n        if(e[u].to != heavy[p] && e[u].to != fa[p])\n            pos[e[u].to] = dfn++, top[e[u].to] = e[u].to, DFS2(e[u].to), bound[p] = max(bound[p],bound[e[u].to]);\n    return; \n}\nSegment_Tree T;\nint Q(int a, int b)\n{\n    int ans = 0;\n    while((a || b) && top[a] != top[b])\n    {\n        if(dep[top[a]] < dep[top[b]])\n            a^=b^=a^=b;\n        (ans += T.Query(1,1,N,pos[top[a]],pos[a])) %= P, a = fa[top[a]];\n    }\n    if(dep[a] < dep[b])\n        a^=b^=a^=b;\n    (ans += T.Query(1,1,N,pos[b],pos[a])) %= P;\n    return ans;\n}\nvoid E(int a, int b, int x)\n{\n    while((a || b) && top[a] != top[b])\n    {\n        if(dep[top[a]] < dep[top[b]])\n            a^=b^=a^=b;\n        T.Edit(1,1,N,pos[top[a]],pos[a],x%P), a = fa[top[a]];\n    }\n    if(dep[a] < dep[b])\n        a^=b^=a^=b;\n    T.Edit(1,1,N,pos[b],pos[a],x%P);    \n    return;\n}\nint v[MAXN+5];\nint main()\n{\n    scanf(\"%d%d%d%d\",&N,&M,&R,&P), memset(first,-1,sizeof(first));\n    for(int i = 1; i <= N; i++)\n        scanf(\"%d\",v+i);\n    for(int i = 1, a, b; i <  N; i++)\n        scanf(\"%d%d\",&a,&b), Add(a,b), Add(b,a);\n    fa[R] = 0, dep[R] = 1, top[R] = R, pos[R] = 1, dfn = 2, DFS1(R,0), DFS2(R);\n    for(int i = 1; i <= N; i++)\n        T.dat[pos[i]] = v[i];\n    T.Build(1,1,N);\n    for(int i = 1, x, a, b; i <= M; i++)\n        switch(scanf(\"%d\",&x),x)\n        {\n            case 1 :scanf(\"%d%d%d\",&a,&b,&x), E(a,b,x%P);\n                    break;\n            case 2 :scanf(\"%d%d\",&a,&b), printf(\"%d\\n\",Q(a,b));    \n                    break;\n            case 3 :scanf(\"%d%d\",&a,&x), T.Edit(1,1,N,pos[a],bound[a],x%P);\n                    break;\n            case 4 :scanf(\"%d\",&a), printf(\"%d\\n\",T.Query(1,1,N,pos[a],bound[a]));\n                    break;\n        }\n     return 0;\n}\n```",
        "postTime": 1484918222,
        "uid": 16528,
        "name": "magolor",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u8fd1\u4e9b\u5e74\u6765\uff0c\u8d8a\u6765\u8d8a\u591a\u7684\u6bd2\u7624\u51fa\u9898\u4eba\u559c\u6b22\u628a\u5e8f\u5217\u95ee\u9898\u5f3a\u884c\u4e0a\u6811\u3002\n\n\u6811\u94fe\u5256\u5206\u5c31\u662f\u4e00\u79cdHASH\u65b9\u5f0f\u3002\u80fd\u5c06\u6811\u4e0a\u7684\u4e00\u6761\u94fe\uff0c\u53d8\u6210\u6570\u7ec4\u4e2d\u4e0b\u6807\u8fde\u7eed\u7684\u533a\u95f4\u3002\u4f18\u70b9\u662f\u80fd\u5feb\u901f\u7ef4\u62a4\u8bb8\u591a\u6811\u4e0a\u64cd\u4f5c\uff0c\u7f3a\u70b9\u5219\u662f\u4ee3\u7801\u91cf\u6bd4\u8f83\u5927\uff0c\u5bb9\u6613\u5199\u6302\u3002\n\n\u5b66\u4f1a\u4e86\u6811\u94fe\u5256\u5206\u540e\u8fd8\u53ef\u4ee5\u6897\u5bb9\u6613\u7406\u89e3LCT\u3002\n\n\u6811\u94fe\u5256\u5206\u5177\u4f53\u64cd\u4f5c\uff0c\u6211\u7684\u535a\u5ba2\u4e0a\u6709\u5199\uff1a\nhttp://blog.csdn.net/fy_23forever/article/details/78888223\n\nAC\u4ee3\u7801\uff1a\n```cpp\n#prag\\\nma GCC optimize ( \"O3\" )\n#include <iostream>\n#include <cstdio>\n#include <cstring>\nconst int MAXN = 200000 ;\nconst int CH_TOP = 2e7;\nusing namespace std ;\n\nchar ch[CH_TOP] , *now_w = ch - 1 , *now_r = ch - 1 ;\n\ninline int read ( ) {\n    int w = 1 ; \n    while( *++now_r < '0' || *now_r > '9' ) if ( *now_r == '-' ) w = -1 ;\n    register int x = *now_r ^ 48 ;\n    while( *++now_r >= '0' && *now_r <= '9' )\tx = ( x << 1 ) + ( x << 3 ) + ( *now_r ^ 48 ) ;\n    return x * w ;\n}\n\ninline void write ( int x ) {\n    static char st[20] ; static int top ;\n    if ( x < 0 ) *++now_w = '-' , x *= -1 ;\n    while( st[++top] = x % 10 ^ 48 , x /= 10 ) ;\n    while( *++now_w = st[top] , --top );\n    *++now_w = '\\n' ;\n} \n\nint val[MAXN + 5] , cnt , MOD , root , w[MAXN + 5] , n , q ;\n\nclass SegmentTree {\n    struct Tree {\n      \tint delta , data ;\n        #define lson p << 1 \n        #define rson p << 1 | 1\n    };\n    public:\n        void Push_Up ( int p ) {\n            s[p].data = s[lson].data + s[rson].data , s[p].data %= MOD ;\n        }\n        void Push_Down ( int p , int len ) {\n            if ( s[p].delta ) {\n                s[lson].delta += s[p].delta , s[rson].delta += s[p].delta ;\n                s[lson].data += s[p].delta * ( len - len / 2 ) , s[rson].data += s[p].delta * ( len / 2 ) ;\n                s[lson].data %= MOD , s[rson].data %=  MOD ;\n                s[p].delta = 0 ;\n            }\n        }\n        void build ( int p , int l , int r ) ;\n        void update ( int p , int l , int r , int x , int y , int cnt ) ;\n        int query ( int p , int l , int r , int x ,int y ) ;\n    private:\n        Tree s[MAXN * 4 + 5] ;\n} S ; \n\nvoid SegmentTree :: build ( int p , int l , int r ) {\n    if ( l == r ) {\n        s[p].data = w[l] , s[p].delta = 0 ;\n        return ;\n    }\n    int mid = l + r >> 1 ;\n    build ( lson , l , mid ) , build ( rson , mid + 1 , r ) ;\n    Push_Up ( p ) ;\n}\n\nvoid SegmentTree :: update ( int p , int l , int r , int x , int y , int cnt ) {\t\n    if ( y < l || x > r )  return ;\n    if ( x <= l && y >= r ) {\n        s[p].data += cnt * ( r - l + 1 ) , s[p].delta += cnt ; \n        return  ;\n    }\n    Push_Down ( p , r - l + 1 ) ;\n    int mid = l + r >> 1 ; \n    update ( lson , l , mid , x , y , cnt ) , update ( rson , mid + 1 , r , x , y , cnt ) ;\n    Push_Up ( p ) ;\n}\n\nint SegmentTree :: query ( int p , int l , int r , int x , int y ) {\n    if ( y < l || x > r )  return 0 ;\n    if ( x <= l && y >= r ) return s[p].data ;\n    Push_Down ( p , r - l + 1 ) ;\n    int mid = l + r >> 1 ;\n    return ( query ( lson , l , mid , x , y ) + query ( rson , mid + 1 , r , x , y ) ) % MOD ; \t\n}\n\nstruct Node {\n\tint to , nxt ;\n} edge[MAXN + 5] ;\n\nclass Graph {\n\tpublic :\n\t\tGraph ( ) { memset ( head , -1 , sizeof ( head ) ) ; fa[root] = 0 ; depth[0] = -1 ; }\n\t\tvoid add ( int u , int v ) ;\n\t\tvoid BuildTree ( int u ) ; void BuildChain ( int u , int Top ) ;\n\t\tvoid UpPath( int u ,int v , int cnt ) ; int QuPath ( int u , int v ) ;\n\t\tvoid UpSubTree ( int x , int cnt ) ; int QuSubTree ( int x ) ; \n\tprivate :\n\t\tint head[MAXN + 5] , tot , fa[MAXN + 5] , size[MAXN + 5] , depth[MAXN + 5] , cnt , id[MAXN + 5] , \n\t\t   sz[MAXN + 5] , son[MAXN + 5] , top[MAXN + 5] ;\n} G ;\n\nvoid Graph :: add ( int u ,int v ) {\n\tedge[tot] = ( Node ) { v , head[u] } , head[u] = tot++ ;\n}\n\nvoid Graph :: BuildTree ( int u ) {\n\tdepth[u] = depth[fa[u]] + 1 , sz[u] = 1 ;\n\tfor ( int i = head[u] ; ~i ; i = edge[i].nxt ) {\n\t\tint v = edge[i].to ; \n\t\tif ( !fa[v] && v != fa[u] ) {\n\t\t\tfa[v] = u , BuildTree ( v ) , sz[u] += sz[v] ;\n\t\t\tif ( sz[son[u]] < sz[v] ) son[u] = v ; \n\t\t}\n\t}\n}\n\nvoid Graph :: BuildChain ( int u , int Top ) {\n\tid[u] = ++cnt , w[cnt] = val[u] ; top[u] = Top ;\n\tif ( !son[u] ) return ;\n\tBuildChain ( son[u] , Top ) ;\n\tfor ( int i = head[u] ; ~i ; i = edge[i].nxt ) {\n\t\tint v = edge[i].to ;\n\t\tif ( v != fa[u] && v != son[u] ) BuildChain ( v , v ) ;\n\t}\n}\n\nvoid Graph :: UpSubTree ( int x , int cnt ) {\n\tS.update ( 1 , 1 , n , id[x] , id[x] + sz[x] - 1 , cnt ) ;\n}\n\nint Graph :: QuSubTree ( int x ) {\n\treturn S.query ( 1 , 1 , n , id[x] , id[x] + sz[x] - 1 ) % MOD ;\n}\n\nvoid Graph :: UpPath ( int u , int v , int cnt ) {\n\twhile ( top[u] != top[v] )\n\t\tif ( depth[top[u]] > depth[top[v]] ) \n\t\t\tS.update ( 1 , 1 , n , id[top[u]] , id[u] , cnt ) , u = fa[top[u]] ;\n\t\telse\n\t\t\tS.update ( 1 , 1 , n , id[top[v]] , id[v] , cnt ) , v = fa[top[v]] ;\n\tif ( depth[u] < depth[v]) \n\t\tS.update ( 1 , 1 , n , id[u] , id[v] , cnt ) ;\n\telse\n\t\tS.update ( 1 , 1 , n , id[v] , id[u] , cnt ) ;\n}\n\nint Graph :: QuPath ( int u , int v ) {\n\tint ret = 0 ; \n\twhile ( top[u] != top[v] ) {\n\t\tif ( depth[top[u]] > depth[top[v]] ) \n\t\t\tret += S.query ( 1 , 1 , n , id[top[u]] , id[u] ) , u = fa[top[u]] ;\n\t\telse\n\t\t\tret += S.query ( 1 , 1 , n , id[top[v]] , id[v] ) , v = fa[top[v]] ;\n\t\tret %= MOD ;\n\t}\n\tif ( depth[u] < depth[v]) \n\t\tret += S.query ( 1 , 1 , n , id[u] , id[v] ) ;\n\telse\n\t\tret += S.query ( 1 , 1 , n , id[v] , id[u] ) ;\n\treturn ret % MOD ;\n}\n\nint main ( ) {\n    fread ( ch , 1 , CH_TOP , stdin ) ;\n    \n    n = read ( ) , q = read ( ) , root = read ( ) , MOD = read ( ) ;\n    \n    for ( int i = 1 ; i <= n ; ++i )\n    \tval[i] = read ( ) ; \n    \n    for ( int i = 1 ; i < n ; ++i ) {\n\t\tint u = read ( ) , v = read ( ) ;\n    \tG.add ( u , v ) , G.add ( v , u ) ;\n    }\n    \n    G.BuildTree ( root ) , G.BuildChain ( root , root ) , S.build ( 1 , 1 , n ) ;\n \n    while ( q-- ) {\n        int opt = read ( ) ;\n \t\tif ( opt == 1 ) {\n \t\t\tint u = read ( ) , v = read ( ) , w = read ( ) % MOD ;\n\t\t\tG.UpPath ( u , v , w ) ;\n        }\n        else if ( opt == 2 ) {\n            int u = read ( ) , v = read ( ) ;\n            write ( G.QuPath ( u , v ) );\n        }\n        else if ( opt == 3 ) {\n        \tint x = read ( ) , cnt = read ( ) ;\n        \tG.UpSubTree ( x , cnt ) ;\n\t\t}\n\t\telse {\n\t\t\tint x = read ( ) ;\n\t\t\twrite ( G.QuSubTree ( x ) ) ; \n \t\t}\n    }\n \t\n \tfwrite ( ch , 1 , now_w - ch , stdout ) ;\n \t\n \treturn 0 ;\n}\n```",
        "postTime": 1520043843,
        "uid": 53567,
        "name": "23forever",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u542c\u4e0a\u53bb\u50cf\u662f\u719f\u7ec3\u5256\u7caa\u3002\n\n\n\u7167\u7740\u5b50\u6811\u5927\u5c0f\u5c06\u6811\u5206\u4e3a\u91cd\u94fe\u548c\u8f7b\u94fe\uff0c\u4ece\u6839\u5f80\u4e0b\u8d70\uff0c\u6bcf\u6b21\u5148\u8d70\u91cd\u94fe\uff0c\u6309\u7167dfs\u5e8f\u5217\u5c31\u53ef\u4ee5\u5c06\u6811\u62c9\u6210\u4e00\u6761\u94fe\u4e86\u3002\u6ce8\u610f\u8bb0\u5f55\u4e00\u4e0b\u5bf9\u4e8e\u6bcf\u4e2a\u70b9x\uff0ctop(x)\u8868\u793ax\u6240\u5728\u91cd\u94fe\u7684\u6df1\u5ea6\u6700\u6d45\u7684\u70b9\u3002\n\n\n\u5bf9\u4e8e\u4e24\u4e2a\u70b9x\uff0cy\uff0c\u8981\u60f3\u5bf9\u5b83\u4eec\u4e4b\u95f4\u7684\u8def\u5f84\u8fdb\u884c\u64cd\u4f5c\uff0c\u5c31\u53ef\u4ee5\u64cd\u4f5c\u5b83\u4eec\u5230top(x),top(y)\u7684\u4e00\u6bb5\u3002\u7136\u540e\u518d\u8d70\u5230top(x),top(y)\u7684\u7236\u4eb2\uff0c\u518d\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u6bcf\u6b21\u5e94\u8be5\u8d70top\u6700\u6df1\u7684\u70b9\uff0c\u4ee5\u9632\u4e24\u4e2a\u70b9\u9519\u8fc7\u4e86\u3002\n\n\n\u67d0\u70b9\u7684\u5b50\u6811\u5728dfs\u5e8f\u5217\u4e2d\u80af\u5b9a\u662f\u8fde\u7eed\u7684\u4e00\u6bb5\uff0c\u6240\u4ee5\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u5b50\u6811\u64cd\u4f5c\u3002\n\n\n\u7a0d\u5fae\u8be6\u7ec6\u4e00\u4e9b\u7684\u89e3\u91ca\u2014\u2014>[\u5e76\u4e0d\u5bf9\u52b2\u7684\u6811\u94fe\u5256\u5206](http://www.cnblogs.com/xzyf/p/8367004.html)\n\n\n\u8bd5\u7740\u628a\u7ebf\u6bb5\u6811\u5199\u5f97\u90aa\u6559\u4e00\u4e9b\uff1a\n\n\n\n\n```cpp\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100010\n#define LL long long \nusing namespace std;\nLL n,m,r;\nLL fir[maxn],nxt[maxn*2],v[maxn*2],s[maxn],cnt;\nLL siz[maxn],fa[maxn],dep[maxn],top[maxn],son[maxn],mp[maxn],tim=0;\nLL read()\n{\n    LL xx=0,ff=1;\n    char ch=getchar();\n    while(isdigit(ch)==0 && ch!='-')ch=getchar();\n    if(ch=='-')ff=-1,ch=getchar();\n    while(isdigit(ch))xx=xx*10+ch-'0',ch=getchar();\n    return xx*ff;\n}\nLL tre[maxn*4],mark[maxn*4],p,a[maxn];\nvoid build(LL node,LL li,LL ri)\n{\n    if(li==ri)\n    {\n        tre[node]=a[li]%p;\n        return;\n    }\n    LL mid=(li+ri)>>1;\n    build((node<<1),li,mid);\n    build((node<<1)+1,mid+1,ri);\n    tre[node]=(tre[(node<<1)]+tre[(node<<1)+1])%p;\n}\nLL add(LL node,LL li,LL ri,LL xi,LL yi,LL k)\n{\n    if(li>=xi&&ri<=yi)\n     {\n        mark[node]+=k;\n        return (k*(ri-li+1))%p;\n    }\n    if(ri<xi||li>yi)\n        return 0;\n    LL mid=(li+ri)>>1;\n    LL tmp1=add((node<<1),li,mid,xi,yi,k);\n    LL tmp2=add((node<<1)+1,mid+1,ri,xi,yi,k);\n    tre[node]+=tmp1+tmp2;\n    tre[node]%=p;\n    return (tmp1+tmp2)%p;\n}\nLL ask(LL node,LL li,LL ri,LL xi,LL yi,LL tmp)\n{\n    if(li>=xi&&ri<=yi)\n    {\n        return (tre[node]+tmp*(ri-li+1))%p;\n    }\n    if(ri<xi||li>yi)return 0;\n    LL mid=(li+ri)>>1;\n    return (ask((node<<1),li,mid,xi,yi,tmp+mark[(node<<1)])+ask((node<<1)+1,mid+1,ri,xi,yi,tmp+mark[(node<<1)+1]))%p;\n}\nvoid getson(LL u)\n{\n    siz[u]=1;LL maxson=0;\n    for(LL k=fir[u];k!=-1;k=nxt[k])\n    {\n        LL vv=v[k];\n        if(vv!=fa[u])\n        {\n            fa[vv]=u,dep[vv]=dep[u]+1;\n            getson(vv);\n            maxson= siz[maxson]<siz[vv] ? vv : maxson;\n            siz[u]+=siz[vv];\n        }\n    }\n    son[u]=maxson;\n}\nvoid gettop(LL u,LL anc)\n{\n    mp[u]=++tim, a[tim]=s[u],top[u]=anc;\n    if(son[u]!=0)gettop(son[u],anc);\n    for(LL k=fir[u];k!=-1;k=nxt[k])\n    {\n        LL vv=v[k];\n        if(vv!=fa[u] && vv!=son[u])\n            gettop(vv,vv);\n    }\n}\nvoid get_num()\n{\n    LL x=read(),y=read(),tx=top[x],ty=top[y],ans=0;\n    while(tx!=ty)\n    {\n        if(dep[ty]>dep[tx])swap(x,y),swap(tx,ty);\n        ans+= ask(1,1,n,mp[tx],mp[x],mark[1]);\n        x=fa[tx],tx=top[x];\n    }\n    ans+=ask(1,1,n,min(mp[x],mp[y]),max(mp[x],mp[y]),23658756-23658756+mark[1]);\n    printf(\"%lld\\n\",ans%p);\n}\nvoid add_num()\n{\n    LL x=read(),y=read(),ad=read(),tx=top[x],ty=top[y],ans=0;\n    while(tx!=ty)\n    {\n        if(dep[ty]>dep[tx])swap(x,y),swap(tx,ty);\n         add(1,1,n,mp[tx],mp[x],ad);\n        x=fa[tx],tx=top[x];\n    }\n    /*while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        add(1,1,n,mp[top[x]],top[x],ad);\n        x=fa[top[x]];\n    }*/\n     add(1,1,n,min(mp[x],mp[y]),max(mp[x],mp[y]),ad);\n}\nvoid get_kid_num()\n{\n    LL x=read(),ans=ask(1,1,n,mp[x],mp[x]+siz[x]-1,0+mark[1]);\n    printf(\"%lld\\n\",ans%p);\n}\nvoid add_kid_num()\n{\n    LL x=read(),ad=read();\n     add(1,1,n,mp[x],mp[x]+siz[x]-1,ad);\n}\nint main()\n{\n    n=read(),m=read(),r=read(),p=read();\n    for(LL i=1;i<=n;i++)\n    {\n       s[i]=read();\n    }\n    memset(fir,-1,sizeof(fir));\n    for(LL i=1;i<n;i++)\n    {\n        LL u=read();\n        v[++cnt]=read();\n        nxt[cnt]=fir[u];\n        fir[u]=cnt;\n        v[++cnt]=u,u=v[cnt-1]; \n        nxt[cnt]=fir[u];\n        fir[u]=cnt;\n    }\n    dep[r]=1;\n    getson(r);\n    gettop(r,r);\n    build(1,1,n);\n    for(int i=1;i<=m;i++)\n    {\n        LL f=read();\n        if(f==1)add_num();\n        if(f==2)get_num();\n        if(f==3)add_kid_num();\n        if(f==4)get_kid_num();\n    }\n    return 0;\n}\n```\n\u8fd8\u53ef\u4ee5\u6539\u5f97\u54f2\u5b66\u4e00\u4e9b\uff1a\n\n\n\n```cpp\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define maxn 100010\n#define Philosophy long long\nusing namespace std;\nPhilosophy change,the_,boss,of[maxn*2],this_[maxn],gym[maxn*2];\nPhilosophy slaves[maxn],get[maxn],your[maxn],ass[maxn],back[maxn],here[maxn];\nPhilosophy billy[maxn*4],herrington[maxn*4];\nPhilosophy ass_[maxn],we,can;\nPhilosophy philosophy()\n{\n    Philosophy xx=0,ff=1;\n    char ch=getchar();\n    while(isdigit(ch)==0 && ch!='-')ch=getchar();\n    if(ch=='-')ff=-1,ch=getchar();\n    while(isdigit(ch))xx=xx*10+ch-'0',ch=getchar();\n    return xx*ff;\n}\nPhilosophy mark,wolves[maxn];\nvoid boy(Philosophy node,Philosophy li,Philosophy ri)\n{\n    if(li==ri)\n    {\n        billy[node]=wolves[li]%mark;\n        return;\n    }\n    Philosophy mid=(li+ri)>>1;\n    boy((node<<1),li,mid);\n    boy((node<<1)+1,mid+1,ri);\n    billy[node]=(billy[(node<<1)]+billy[(node<<1)+1])%mark;\n}\nPhilosophy next(Philosophy node,Philosophy li,Philosophy ri,Philosophy xi,Philosophy yi,Philosophy k)\n{\n    if(li>=xi&&ri<=yi)\n     {\n        herrington[node]+=k;\n        return (k*(ri-li+1))%mark;\n    }\n    if(ri<xi||li>yi)\n        return 0;\n    Philosophy mid=(li+ri)>>1;\n    Philosophy tmp1=next((node<<1),li,mid,xi,yi,k);\n    Philosophy tmp2=next((node<<1)+1,mid+1,ri,xi,yi,k);\n    billy[node]+=tmp1+tmp2;\n    billy[node]%=mark;\n    return (tmp1+tmp2)%mark;\n}\nPhilosophy door(Philosophy node,Philosophy li,Philosophy ri,Philosophy xi,Philosophy yi,Philosophy tmp)\n{\n    if(li>=xi&&ri<=yi)\n    {\n        return (billy[node]+tmp*(ri-li+1))%mark;\n    }\n    if(ri<xi||li>yi)return 0;\n    Philosophy mid=(li+ri)>>1;\n    return (door((node<<1),li,mid,xi,yi,tmp+herrington[(node<<1)])+door((node<<1)+1,mid+1,ri,xi,yi,tmp+herrington[(node<<1)+1]))%mark;\n}\nvoid Van(Philosophy performance)\n{\n    slaves[performance]=1;Philosophy maxson=0;\n    for(Philosophy k=this_[performance];k!=-1;k=gym[k])\n    {\n        Philosophy vv=of[k];\n        if(vv!=get[performance])\n        {\n            get[vv]=performance,your[vv]=your[performance]+1;\n            Van(vv);\n            maxson= slaves[maxson]<slaves[vv] ? vv : maxson;\n            slaves[performance]+=slaves[vv];\n        }\n    }\n    back[performance]=maxson;\n}\nvoid darkholme(Philosophy performance,Philosophy artist)\n{\n    here[performance]=++can, wolves[can]=ass_[performance],ass[performance]=artist;\n    if(back[performance]!=0)darkholme(back[performance],artist);\n    for(Philosophy k=this_[performance];k!=-1;k=gym[k])\n    {\n        Philosophy vv=of[k];\n        if(vv!=get[performance] && vv!=back[performance])\n            darkholme(vv,vv);\n    }\n}\nvoid the()\n{\n    Philosophy x=philosophy(),y=philosophy(),ad=philosophy(),tx=ass[x],ty=ass[y],ans=0;\n    while(tx!=ty)\n    {\n        if(your[ty]>your[tx])swap(x,y),swap(tx,ty);\n         next(1,1,change,here[tx],here[x],ad);\n        x=get[tx],tx=ass[x];\n    }\n    /*while(ass[x]!=ass[y])\n    {\n        if(deep[ass[x]]<deep[ass[y]])swap(x,y);\n        next(1,1,change,here[ass[x]],ass[x],ad);\n        x=get[ass[x]];\n    }*/\n     next(1,1,change,min(here[x],here[y]),max(here[x],here[y]),ad);\n}\nvoid deep()\n{\n    Philosophy x=philosophy(),y=philosophy(),tx=ass[x],ty=ass[y],ans=0;\n    while(tx!=ty)\n    {\n        if(your[ty]>your[tx])swap(x,y),swap(tx,ty);\n        ans+= door(1,1,change,here[tx],here[x],herrington[1]);\n        x=get[tx],tx=ass[x];\n    }\n    ans+=door(1,1,change,min(here[x],here[y]),max(here[x],here[y]),23658756-23658756+herrington[1]);\n    printf(\"%lld\\n\",ans%mark);\n}\nvoid dark()\n{\n    Philosophy x=philosophy(),ad=philosophy();\n     next(1,1,change,here[x],here[x]+slaves[x]-1,ad);\n}\nvoid fantasty()\n{\n    Philosophy x=philosophy(),ans=door(1,1,change,here[x],here[x]+slaves[x]-1,0+herrington[1]);\n    printf(\"%lld\\n\",ans%mark);\n}\nint main()\n{\n    change=philosophy(),the_=philosophy(),boss=philosophy(),mark=philosophy();\n    for(Philosophy i=1;i<=change;i++)\n    {\n       ass_[i]=philosophy();\n    }\n    memset(this_,-1,sizeof(this_));\n    for(Philosophy i=1;i<change;i++)\n    {\n        Philosophy performance=philosophy();\n        of[++we]=philosophy();\n        gym[we]=this_[performance];\n        this_[performance]=we;\n        of[++we]=performance,performance=of[we-1]; \n        gym[we]=this_[performance];\n        this_[performance]=we;\n    }\n    your[boss]=1;\n    Van(boss);\n    darkholme(boss,boss);\n    boy(1,1,change);\n    for(int i=1;i<=the_;i++)\n    {\n        Philosophy f=philosophy();\n        if(f==1)the();\n        if(f==2)deep();\n        if(f==3)dark();\n        if(f==4)fantasty();\n    }//the\u2642deep\u2642dark\u2642fantasty\n    return 0;\n}\n\n```\n\n\u8bd5\u7740\u538b\u884c\uff1a\n```cpp\n#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#define ls (n<<1)\n#define rs (n<<1|1)\n#define mi ((l+r)>>1)\n#define vv v[k]\n#define pushup(n) tr[n]=(tr[ls]+tr[rs])%p\n#define maxn 100010 \n#define add(a,b) a=((a)+(b))%p\nusing namespace std;\nstruct SegmentTree\n{\n\tint tr[maxn*4],mk[maxn*4],a[maxn],p;\n\tvoid pushdown(int n,int l,int r){\n\t\tif(l<r && mk[n]!=0){\n\t\t\tadd(tr[ls],mk[n]*(mi-l+1));\n\t\t\tadd(tr[rs],mk[n]*(r-mi));\n\t\t\tadd(mk[ls],mk[n]);add(mk[rs],mk[n]);\n\t\t\tmk[n]=0; \n\t\t}\n\t}\n\tvoid build(int n,int l,int r){\n\t\tif(l==r){tr[n]=a[l];return;}\n\t\tbuild(ls,l,mi);\n\t\tbuild(rs,mi+1,r);\n\t\tpushup(n); \n\t}\n\tint addask(int n,int l,int r,int x,int y,int k){\n\t\tpushdown(n,l,r);\n\t\tif(x<=l && r<=y){\n\t\t    add(tr[n],k*(r-l+1));\n\t\t    add(mk[n],k);\n\t\t    return tr[n];\n\t\t} \n\t\tif(y<l || r<x)return 0;\n\t\tint lans=addask(ls,l,mi,x,y,k);\n\t\tint rans=addask(rs,mi+1,r,x,y,k);\n\t\tpushup(n);\n\t\treturn (lans+rans)%p;\n\t}\n}t;\nint n,p,rt,q,w[maxn],fir[maxn],nxt[maxn*2],v[maxn*2],cnt;\nint fa[maxn],son[maxn],siz[maxn],mp[maxn],top[maxn],dep[maxn],tim;\nvoid addedge(int u1,int v1){\n    v[cnt]=v1,nxt[cnt]=fir[u1],fir[u1]=cnt++;\n    v[cnt]=u1,nxt[cnt]=fir[v1],fir[v1]=cnt++;\n}\nvoid getson(int u){\n\tsiz[u]=1;\n\tfor(int k=fir[u];k!=-1;k=nxt[k]){\n\t    if(vv==fa[u])continue;\n\t    fa[vv]=u;\n\t    dep[vv]=dep[u]+1;\n\t\tgetson(vv);\n\t\tsiz[u]+=siz[vv];\n\t\tif(son[u]==0 || siz[vv]>siz[son[u]])son[u]=vv; \n\t}\n}\nvoid gettop(int u,int anc){\n\tmp[u]=++tim,t.a[tim]=w[u],top[u]=anc;\n\tif(son[u])gettop(son[u],anc);\n\tfor(int k=fir[u];k!=-1;k=nxt[k]){\n\t    if(vv==fa[u] || vv==son[u])continue;\n\t\tgettop(vv,vv);\t\n\t}\n}\nvoid addaskroad(int f){\n    int x,y,ad=0,ans=0;scanf(\"%d%d\",&x,&y);\n\tint tx=top[x],ty=top[y];if(f)scanf(\"%d\",&ad);\n    while(tx!=ty){\n        if(dep[tx]<dep[ty])swap(tx,ty),swap(x,y);\n\t\tadd(ans,t.addask(1,1,n,min(mp[x],mp[tx]),max(mp[x],mp[tx]),ad));\n\t\tx=fa[tx];tx=top[x];\n    }\n\tadd(ans,t.addask(1,1,n,min(mp[x],mp[y]),max(mp[x],mp[y]),ad));\n\tif(!f)printf(\"%d\\n\",ans);\n}\nvoid addaskson(int f){\n\tint x,ad=0,ans=0;scanf(\"%d\",&x);if(f)scanf(\"%d\",&ad);\n\tadd(ans,t.addask(1,1,n,mp[x],mp[x]+siz[x]-1,ad));\n\tif(!f)printf(\"%d\\n\",ans);\n}\nint main(){\n    scanf(\"%d%d%d%d\",&n,&q,&rt,&p);t.p=p;\n    memset(fir,-1,sizeof(fir));\n    for(int i=1;i<=n;i++)scanf(\"%d\",&w[i]); \n\tint x,y;\n    for(int i=1;i<=n-1;i++){scanf(\"%d%d\",&x,&y);addedge(x,y);}\n\tgetson(rt);gettop(rt,rt);t.build(1,1,n);\n    while(q--){\n        int fff;scanf(\"%d\",&fff);\n\t\tif(fff<=2)addaskroad((fff-1)^1);\n\t\telse addaskson((fff-3)^1);\n    }return 0;\n}\n```",
        "postTime": 1517099788,
        "uid": 33242,
        "name": "echo6342",
        "ccfLevel": 0,
        "title": "\u5e76\u4e0d\u5bf9\u52b2\u7684\u6811\u94fe\u5256\u5206"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\u3002\n\n## \u5feb\u628a\u6211\u8111\u888b\u90fd\u8981\u5256\u5f00\u4e86\u3002\n\n\u8fd9\u662f\u4e00\u4e2a\u7701\u9009\u77e5\u8bc6\u7684\u6a21\u677f\u3002\u4f46\u662fNOIP2016\u5e74\u8fd8\u662f\u8003\u4e86\u5929\u5929\u7231\u8dd1\u6b65\u8fd9\u79cd\u7701\u9009\u96be\u5ea6\u7684\u9898\u3002\n\n~~\u4f46\u6211\u4e0d\u77e5\u9053\u4e3a\u5565\u8fd8\u662f\u6709\u4eba\u4f1aAK~~\n\n\u8fd9\u4e2a\u7b97\u6cd5\u5462\uff0c\u5c31\u662f\u9996\u5148**\u6df1\u641c**\u4e24\u904d\n\n\u7b2c\u4e00\u904d\u6df1\u641c\u662f\u4e3a\u4e86**\u5efa\u6811**\uff0c\u8bb0\u5f55\u7236\u4eb2\u8282\u70b9fa\u3001\u5b50\u6811\u7684\u91cd\u91cfsize\u3001\u6df1\u5ea6dep\u3001\u8fd8\u6709\u91cd\u513f\u5b50hson\u3002\n\n\u8fd9\u91cc\u63d0\u4e00\u4e0b\u91cd\u513f\u5b50\u7684\u6982\u5ff5\uff0c\u5c31\u662f\u4f60\u8fd9\u4e2a\u8282\u70b9\u6709\u5f88\u591a\u5b50\u6811\uff0c\u5176\u4e2d\u67d0\u4e2a\u5b50\u6811\u7684\u91cd\u91cf(\u5c31\u662f\u8be5\u5b50\u6811\u7684\u8282\u70b9\u6570)\u6700\u5927\uff0c\u6211\u4eec\u79f0\u4ed6\u4e3a\u91cd\u513f\u5b50\u3002\n\n\u7b2c\u4e8c\u904d\u6df1\u641c\u662f\u4e3a\u4e86**\u5206\u94fe**\uff0c\u91cd\u65b0\u7f16\u53f7id\uff0c\u8bb0\u5f55\u94fe\u9876top\u3002\n\n\u8fd9\u91cc\u5982\u4f55\u5206\u94fe\u5462\uff0c\u9996\u5148\u4f60\u8981\u4ece\u6839\u5f00\u59cb\u5c06\u91cd\u513f\u5b50\u627e\u51fa\u6765\uff0c\u7136\u540e\u91cd\u513f\u5b50\u7684\u91cd\u513f\u5b50\u627e\u51fa\u6765\uff0c\u7136\u540e...\uff0c\u7136\u540e\u627e\u51fa\u91cd\u513f\u5b50\u7684\u91cd\u513f\u5b50\u7684\u91cd\u513f\u5b50\u7684...\u7684\u91cd\u513f\u5b50\uff0c\u5c06\u5176\u7ed3\u6210\u4e00\u4e2a\u94fe\uff0c\u7136\u540e\u6839\u8282\u70b9\u5c31\u662f\u8be5\u94fe\u7684\u94fe\u9876\u3002\n\n\u7136\u540e\u5c06\u6839\u8282\u70b9\u4e0d\u662f\u91cd\u513f\u5b50\u7684\u513f\u5b50\u4f5c\u4e3a\u6839\u8282\u70b9\uff0c\u91cd\u590d\u4e0a\u4e24\u884c\u7684\u64cd\u4f5c\u3002\n\n\u8fd9\u6837\u6811\u94fe\u5256\u5206\u5c31\u5b8c\u6210\u4e86\u3002\n\n\u7136\u540e\u600e\u4e48\u67e5\u8be2&&\u4fee\u6539\u5462\u3002\n\n\u9996\u5148\u5bf9\u4e8e\u94fe\u7684\u4fee\u6539\uff0c\u6211\u4eec\u5bf9\u4e8e\u4e00\u6761\u94fe(u,v)\uff08\u5176\u4e2du\u7684\u6df1\u5ea6\u6bd4v\u6df1\u5373v\u5728u\u4e0a\u65b9\uff0c\u5e76\u4e14\u6bcf\u6b21\u64cd\u4f5c\u8981\u786e\u4fddu\u5728v\u7684\u4e0a\u65b9\uff09\n\n\u5982\u679cu,v\u7684top\u4e0d\u662f\u540c\u4e00\u4e2a\n\n\u8bc1\u660eu,v\u4e0d\u5728\u540c\u4e00\u6761\u94fe\u4e0a\n\n\u6211\u4eec\u5148\u5bf9\u6df1\u5ea6\u6df1\u7684u\u90a3\u6761\u94fe\u4fee\u6539(top[u],u)\n\n\u7136\u540eu\u91cd\u65b0\u5b9a\u4e49\u4e3atop[u]\u7684\u7236\u4eb2\u8282\u70b9\uff0c\u518d\u5224\u65adtop[u]\uff0ctop[v]\u7684\u6df1\u5ea6\n\n\u7136\u540e\u7ee7\u7eed\u4fee\u6539u\u7684\u90a3\u6761\u94fe\n\n\u76f4\u5230top[u]==top[v]\n\n\u8fd9\u65f6\u6211\u4eec\u5bf9(v,u)\u8fdb\u884c\u4fee\u6539\u5373\u53ef\u3002\n\n\u7136\u540e\u8be2\u95ee\u4e5f\u662f\u5dee\u4e0d\u591a\u7684\uff0c\u8fd9\u68371,2\u79cd\u64cd\u4f5c\u5c31\u5904\u7406\u5b8c\u4e86\u3002\n\n\u7136\u540e3,4\u64cd\u4f5c\u66f4\u7b80\u5355\u3002\n\n\u6211\u4eec\u56de\u987e\u6df1\u641c\u7b2c\u4e8c\u904d\uff0c\u6211\u4eec\u53d1\u73b0\u67d0\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u7684\u6240\u6709\u7f16\u53f7\u90fd\u662f\u6309\u7167\u987a\u5e8f\u6765\u7684\u3002\n\n\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u5bf9(id[x],id[x]+size[x]-1)\u8fdb\u884c\u4fee\u6539\u6216\u8be2\u95ee\u5373\u53ef\u3002\n\n\u6700\u540e\u8981\u6ce8\u610f\u7684\u5c31\u662f\u5feb\u8bfb\uff0c\u65e0\u5411\u8fb9\uff0c%\u6570\uff0c\u8fd8\u6709long long\uff0c\u5c31\u6ca1\u6709\u4ec0\u4e48\u597d\u8bf4\u7684\u4e86\u3002\n\n\u5982\u679c\u4f60\u7ebf\u6bb5\u6811\u8fd8\u6709\u95ee\u9898\uff0c\u8bf7\u5de6\u8f6c P3372 \u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u68111\n\n\n```cpp\n#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nstruct edge{\n    long long to,next;\n}e[200010];\nlong long n,m,root,mode,len,tot;\nlong long a[100010],tree[400010],lazy[400010];\nlong long head[100010],real[100010],id[100010],fa[100010],hson[100010],dep[100010],size[100010],top[100010];\n\nlong long v_in(){//\u5feb\u8bfb \n    long long sum=0;\n    char ch=getchar();\n    while (ch<'0'||ch>'9') ch=getchar();\n    while (ch>='0'&&ch<='9'){\n        sum=sum*10+ch-'0';\n        ch=getchar();\n    }\n    return sum;\n}\n\nvoid add(long long u,long long v){//\u52a0\u8fb9 \n    e[++len].to=v;\n    e[len].next=head[u];\n    head[u]=len;\n}\n\n/*\u7ebf\u6bb5\u6811(Segment Tree)*/ \n\nvoid pushup(long long rt){//\u4e0a\u63a8 \n    tree[rt]=tree[rt<<1]+tree[rt<<1|1];\n}\n\nvoid pushdown(long long rt,long long ln,long long rn){//\u4e0b\u63a8 \n    if (lazy[rt]){\n        tree[rt<<1]+=lazy[rt]*ln;\n        tree[rt<<1|1]+=lazy[rt]*rn;\n        lazy[rt<<1]+=lazy[rt];\n        lazy[rt<<1|1]+=lazy[rt];\n        lazy[rt]=0;\n    }\n}\n\nvoid build(long long l,long long r,long long rt){//\u5efa\u6811 \n    if (l==r){\n        tree[rt]=a[real[l]];\n        return;\n    }\n    long long mid=(l+r)>>1;\n    build(l,mid,rt<<1);\n    build(mid+1,r,rt<<1|1);\n    pushup(rt);\n}\n\nvoid update(long long l,long long r,long long rt,long long left,long long right,long long c){//\u4fee\u6539\u64cd\u4f5c \n    if (l>=left&&r<=right){\n        tree[rt]+=c*(r-l+1);\n        lazy[rt]+=c;\n        return;\n    }\n    long long mid=(l+r)>>1;\n    pushdown(rt,mid-l+1,r-mid);\n    if (mid>=left) update(l,mid,rt<<1,left,right,c);\n    if (mid+1<=right) update(mid+1,r,rt<<1|1,left,right,c);\n    pushup(rt);\n}\n\nlong long query(long long l,long long r,long long rt,long long left,long long right){//\u8be2\u95ee\u64cd\u4f5c \n    if (l>=left&&r<=right){\n        return tree[rt]%mode;\n    }\n    long long mid=(l+r)>>1,ans=0;\n    pushdown(rt,mid-l+1,r-mid);\n    if (mid>=left) ans=(ans+query(l,mid,rt<<1,left,right))%mode;\n    if (mid+1<=right) ans=(ans+query(mid+1,r,rt<<1|1,left,right))%mode;\n    pushup(rt);\n    return ans;\n}\n\n/*\u6811\u94fe\u5256\u5206*/\n\nvoid dfs1(long long u,long long f){//\u7b2c\u4e00\u904d\u6df1\u641c(\u5efa\u6811,\u8bb0\u5f55fa,size,dep,hson) \n    fa[u]=f;\n    size[u]=1;\n    for (long long i=head[u];i!=0;i=e[i].next){\n        long long v=e[i].to;\n        if (fa[u]!=v){\n            dep[v]=dep[u]+1;\n            dfs1(v,u);\n            if (hson[u]==0||size[hson[u]]<size[v]) hson[u]=v;\n            size[u]+=size[v];\n        }\n    }\n}\n\nvoid dfs2(long long u,long long anc){//\u7b2c\u4e8c\u904d\u6df1\u641c(\u5206\u94fe,\u91cd\u65b0\u7f16\u53f7,\u8bb0\u5f55top,id,real) \n    top[u]=anc;\n    id[u]=++tot;\n    real[tot]=u;\n    if (hson[u]==0) return;\n    dfs2(hson[u],anc);\n    for (long long i=head[u];i!=0;i=e[i].next){\n        long long v=e[i].to;\n        if (v!=fa[u]&&v!=hson[u]) dfs2(v,v);\n    }\n}\n\nvoid chain_add(){//1\u64cd\u4f5c \n    long long u=v_in(),v=v_in(),w=v_in();\n    long long tu=top[u],tv=top[v];\n    while (tu!=tv){\n        if (dep[tu]<dep[tv]){\n            swap(tu,tv);\n            swap(u,v);\n        }\n        update(1,n,1,id[tu],id[u],w);\n        u=fa[tu];\n        tu=top[u];\n    }\n    if (dep[u]<dep[v]) swap(u,v);\n    update(1,n,1,id[v],id[u],w);\n}\n\nvoid chain_query(){//2\u64cd\u4f5c \n    long long u=v_in(),v=v_in();\n    long long tu=top[u],tv=top[v],ans=0;\n    while (tu!=tv){\n        if (dep[tu]<dep[tv]){\n            swap(tu,tv);\n            swap(u,v);\n        }\n        ans=(ans+query(1,n,1,id[tu],id[u]))%mode;\n        u=fa[tu];\n        tu=top[u];\n    }\n    if (dep[u]<dep[v]) swap(u,v);\n    ans=(ans+query(1,n,1,id[v],id[u]))%mode;\n    printf(\"%lld\\n\",ans);\n}\n\nvoid tree_add(){//3\u64cd\u4f5c \n    long long x=v_in(),w=v_in();\n    update(1,n,1,id[x],id[x]+size[x]-1,w);\n}\n\nvoid tree_query(){//4\u64cd\u4f5c \n    long long x=v_in();\n    printf(\"%lld\\n\",query(1,n,1,id[x],id[x]+size[x]-1)%mode);\n}\n\nint main(){\n    n=v_in();\n    m=v_in();\n    root=v_in();\n    mode=v_in();\n    for (long long i=1;i<=n;i++) a[i]=v_in();\n    for (long long i=1;i<n;i++){\n        long long u=v_in(),v=v_in();\n        add(u,v);//\u65e0\u5411\u8fb9 \n        add(v,u);\n    }\n    dep[root]=1;\n    dfs1(root,0);\n    dfs2(root,root);\n    build(1,n,1);\n    for (long long i=1;i<=m;i++){\n        long long q=v_in();\n        if (q==1) chain_add();\n        else if (q==2) chain_query();\n        else if (q==3) tree_add();\n        else tree_query();\n    }\n    return 0;\n}\n```",
        "postTime": 1507786706,
        "uid": 37781,
        "name": "\u6211\u4e0d\u662f\u67f3\u6a59\u6c41",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u52a0\u6811\u5256\u7684\u6a21\u677f\u9898\u3002\u3002\u3002\u3002\u3002\n\n\u662f\u901a\u8fc7\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u6811\u7684dfs\u5e8f\u6765\u8fdb\u884c\u533a\u95f4\u64cd\u4f5c\u7684\u3002\n\n\u5176\u4e2d\u9700\u8981\u6ce8\u610f\u7684\u5c31\u662frank[x]\u8fd9\u4e2a\u6570\u7ec4\u662f\u7528\u6765\u5efa\u6811\u7684\uff0c\u5c31\u662f\u8bf4 \u628a\u6bcf\u4e2adfs\u5e8f\u6240\u5bf9\u5e94\u7684\u6811\u7684\u6743\u503c\u4e00\u4e00\u5bf9\u5e94\u8d77\u6765\u3002\n\n\u94fe\u64cd\u4f5c\u663e\u7136\u4f7f\u7528\u6811\u5256\uff0c\u5b50\u6811\u64cd\u4f5c\u4e5f\u662f\u53ea\u9700\u8981\u4f7f\u7528dfs\u5e8f\u5c31\u53ef\u4ee5\u7ef4\u62a4\u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define ll long long\n#define MAX 100050\nusing namespace std;\nll sum[MAX<<2],arr[MAX],rank[MAX],add[MAX<<2];     //\u7ebf\u6bb5\u6811\u6240\u7528\u53d8\u91cf\nint size[MAX],son[MAX],deep[MAX],fa[MAX],top[MAX];  //\u6811\u5256\u6240\u7528\u53d8\u91cf\nint m,n,r,mod,dfsx[MAX],endx[MAX],tot;                  //\u5176\u4ed6\u53d8\u91cf\n\nll read(){\n    ll x=0,w=1;\n    char chr = 0;\n    while(chr < '0' || chr > '9'){\n        if(chr == '-')\n            w =-1;\n        chr = getchar();\n    }\n    while(chr >= '0' && chr <= '9'){\n        x = (x<<3)+(x<<1)+chr-'0';\n        chr = getchar();\n    }\n    return x*w;\n}\n\nstruct node{\n    int to;\n    node *next;\n}*head[MAX];\n\nvoid addedge(int a,int b){              //\u52a0\u8fb9\n    node *t = new node;\n    t->next = head[a];\n    t->to = b;\n    head[a] = t;\n}\n\n/*\u7ebf\u6bb5\u6811\u64cd\u4f5c*/\nvoid pushup(int rt){\n    sum[rt] = sum[rt<<1]+sum[rt<<1|1];\n}\n\nvoid pushdown(int rt,int ln,int rn){\n    if(add[rt]){\n        add[rt<<1] += add[rt];\n        add[rt<<1|1] += add[rt];\n        sum[rt<<1] += add[rt]*ln;\n        sum[rt<<1|1] += add[rt]*rn;\n        add[rt] = 0;\n    }\n}\n\nvoid build(int l,int r,int rt){\n    if(l == r){\n        sum[rt] = rank[l];\n        return;\n    }\n    int m = (l+r)>>1;\n    build(l,m,rt<<1);\n    build(m+1,r,rt<<1|1);\n    pushup(rt);\n}\n\nvoid update(int L,int R,ll C,int l,int r,int rt){\n    if(L <= l && r <= R){\n        sum[rt] += C*(r-l+1);\n        add[rt] += C;\n        return;\n    }\n    int m = (l+r) >> 1;\n    pushdown(rt,m-l+1,r-m);\n    if(L <= m) update(L,R,C,l,m,rt<<1);\n    if(R > m) update(L,R,C,m+1,r,rt<<1|1);\n    pushup(rt);\n}\n\nll query(int L,int R,int l,int r,int rt){\n    if(L <= l && r <= R){\n        return sum[rt];\n    }\n    int m = (l+r)>>1;\n    pushdown(rt,m-l+1,r-m);\n    ll ans = 0;\n    if(L <= m){\n        ans += query(L,R,l,m,rt<<1);\n        ans %= mod;\n    }\n    if(R > m){\n        ans += query(L,R,m+1,r,rt<<1|1);\n        ans %= mod;\n    }\n    return ans%mod;\n}\n\n/*\u6811\u5256\u90e8\u5206*/\n\nvoid dfs1(int x){\n    size[x] = 1;\n    for(register node *t = head[x];t;t=t->next){\n        if(t->to == fa[x]) continue;\n        deep[t->to] = deep[x]+1;\n        fa[t->to] = x;\n        dfs1(t->to);\n        size[x] += size[t->to];\n        if(size[t->to] > size[ son[x] ]){\n            son[x] = t->to;\n        }\n    }\n}\n\nvoid dfs2(int x,int tp){\n    dfsx[x] = ++tot;\n    rank[tot] = arr[x];\n    top[x] = tp;\n    if(son[x]) dfs2(son[x],tp);\n    for(register node *t = head[x];t;t=t->next){\n        if(t->to == fa[x] || t->to == son[x]) continue;\n        dfs2(t->to,t->to);\n    }\n    endx[x] = tot;\n}\n\n/*\u6b63\u513f\u516b\u7ecf\u7684\u64cd\u4f5c*/\n\nvoid update_link(int a,int b,int c){\n    while(top[a] != top[b]){\n        if(deep[top[a]] < deep[top[b]])\n            swap(a,b);\n        update(dfsx[top[a]],dfsx[a],c,1,n,1);\n        a = fa[top[a]];\n    }\n    if(deep[a] > deep[b])\n        swap(a,b);\n    update(dfsx[a],dfsx[b],c,1,n,1);\n}\n\nvoid update_tree(int a,int c){\n    int s = dfsx[a];\n    int e = endx[a];\n    update(s,e,c,1,n,1);\n}\n\nll find_link(int a,int b){\n    ll ans = 0;\n    while(top[a] != top[b]){\n        if(deep[top[a]] < deep[top[b]])\n            swap(a,b);\n        ans += query(dfsx[top[a]],dfsx[a],1,n,1);\n        ans %= mod;\n        a = fa[top[a]];\n    }\n    if(deep[a] > deep[b])\n        swap(a,b);\n    ans += query(dfsx[a],dfsx[b],1,n,1);\n    return ans%mod;\n}\n\nll find_tree(int x){\n    int s = dfsx[x];\n    int e = endx[x];\n    return query(s,e,1,n,1);\n}\n\nint main(){\n    freopen(\"data.in\",\"r\",stdin);\n    n = read();\n    m = read();\n    r = read();\n    mod = read();\n    for(register int i=1;i<=n;i++){\n        arr[i] = read();\n    }\n    for(register int i=1;i<n;i++){\n        int x,y;\n        x = read();\n        y = read();\n        addedge(x,y);\n        addedge(y,x);\n    }\n    dfs1(r);\n    dfs2(r,r);\n    build(1,n,1);\n    while(m--){\n        int com;\n        com = read();\n        switch(com){\n            case 1:{\n                int x,y,z;\n                x = read();\n                y = read();\n                z = read();\n                update_link(x,y,z);\n                break;\n            }\n            case 2:{\n                int x,y;\n                x = read();\n                y = read();\n                cout << find_link(x,y) << endl;\n                break;\n            }\n            case 3:{\n                int x,y;\n                x = read();\n                y = read();\n                update_tree(x,y);\n                break;\n            }\n            case 4:{\n                int x;\n                x = read();\n                cout << find_tree(x) << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1507278291,
        "uid": 20788,
        "name": "DarkEyeR",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "//\u76f4\u63a5\u628a\u521a\u521a\u5199\u597d\u7684blog\u642c\u8fc7\u6765\u597d\u4e86(\u4e0d\u8981\u6253\u6211)\n\n\u8fdb\u5165\u6b63\u9898\uff1a\n\n\u6811\u5256\u662f\u5e72\u4ec0\u4e48\u7684\uff1f\n\n\u8003\u8651\u8fd9\u6837\u7684\u60c5\u51b5\uff1a\u6709\u4e00\u68f5\u6811\uff0c\u73b0\u5728\u8981\u5bf9\u5176\u8fdb\u884c\u8def\u5f84(\u4e24\u8282\u70b9\u95f4)\u64cd\u4f5c\u3001\u5b50\u6811\u64cd\u4f5c\uff0c\u4f8b\u5982\u5c06\u8def\u5f84\u4e0a(\u5b50\u6811\u4e0a)\u7684\u6240\u6709\u8282\u70b9\u5168\u90e8\u52a0\u4e0a\u4e00\u4e2a\u503c\u3001\u6c42\u548c\u7b49\u7b49\u3002\n\n\u76f4\u63a5\u66b4\u529b\u64cd\u4f5c\u56fa\u7136\u662f\u53ef\u884c\u7684\uff0c\u4f46\u65f6\u95f4\u80af\u5b9a\u662f\u4e2a\u95ee\u9898\u3002\n\n\u8fd9\u65f6\u6211\u4eec\u60f3\uff0c\u5982\u679c\u80fd\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u6811\u4e0a\u8282\u70b9\u5c31\u597d\u4e86\uff0c\u4f46\u662f\u6811\u7684\u201c\u5f20\u7259\u821e\u722a\u201d\u7684\u6837\u5b50\uff0c\u4f7f\u5f97\u8fd9\u4e2a\u64cd\u4f5c\u96be\u4ee5\u5b8c\u6210\u3002\n\n\u4e8e\u662f\uff0c\u6811\u5256\u5e94\u8fd0\u800c\u751f\u3002\u6811\u5256\u7684\u4f5c\u7528\u662f\uff0c\u628a\u6811\u62c6\u5206\u6210\u82e5\u5e72\u6761\u201c\u94fe\u201d\uff0c\u663e\u7136\uff0c\u201c\u94fe\u201d\u662f\u7ebf\u6027\u7684\uff0c\u65b9\u4fbf\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u3002\n\n\u5177\u4f53\u7684\u62c6\u5206\u65b9\u5f0f\u540d\u4e3a\u201c\u8f7b\u91cd\u94fe\u5256\u5206\u201d\u3002\u4f7f\u7528\u8fd9\u79cd\u62c6\u5206\u65b9\u5f0f\uff0c\u53ef\u4ee5\u4f7f\u4efb\u4e00\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u4e0a\uff0c\u7ecf\u8fc7\u7684\u91cd\u94fe\u548c\u8f7b\u8fb9\u6570\u91cf\u5747\u4e0d\u8d85\u8fc7logn\uff0c\u8fd9\u91cc\u7684n\u6307\u7684\u662f\u6811\u7684\u8282\u70b9\u603b\u6570\u3002\u5173\u4e8e\u5177\u4f53\u6982\u5ff5\u53ca\u590d\u6742\u5ea6\u8bc1\u660e\u8bf7\u81ea\u884c\u767e\u5ea6\uff0c\u6b64\u5904\u4e0d\u518d\u8d58\u8ff0\u3002\n\n\u6811\u5256\u8fc7\u7a0b\u9700\u8981\u6c42\u5f97\u7684\u4e00\u7cfb\u5217\u6570\u7ec4\u5982\u4e0b\uff1a\n\nfa[]\uff1a\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9(\u6839\u8282\u70b9\u4e3a\u65e0)\uff1b\n\ndep[]\uff1a\u8282\u70b9\u6df1\u5ea6\uff1b\n\nsize[]\uff1a\u4ee5\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u603b\u6570\uff1b\n\nson[]\uff1a\u8282\u70b9\u7684\u91cd\u513f\u5b50\u7f16\u53f7\uff1b\n\ntop[]\uff1a\u8282\u70b9\u6240\u5904\u91cd\u94fe\u7684\u9876\u7aef\u8282\u70b9\uff1b\n\ndfsx[]\uff1a\u6309\u7167\u91cd\u94fe\u4f18\u5148\u904d\u5386\u51fa\u7684DFS\u5e8f\uff1b\n\npos[]\uff1a\u8282\u70b9\u5728\u6570\u636e\u7ed3\u6784\u4e2d\u7684\u4f4d\u7f6e\u3002\n\n\u521d\u59cb\u5316\u8fc7\u7a0b\uff1a\n\n1.\u5b58\u56fe\uff1b\n\n2.\u8fdb\u884c\u7b2c\u4e00\u904dDFS\uff0c\u81ea\u6839\u5411\u4e0b\u904d\u5386(\u8fd9\u4e2a\u8fc7\u7a0b\u7c7b\u4f3c\u4e8e\u65e0\u6839\u6811\u8f6c\u6709\u6839\u6811)\uff0c\u6c42\u51fafa[]\u3001dep[]\u3001size[]\u3001son[]\uff1b\n\n3.\u8fdb\u884c\u7b2c\u4e8c\u904dDFS\uff0c\u6309\u7167\u91cd\u94fe\u4f18\u5148\u7684\u987a\u5e8f\u904d\u5386\uff0c\u6c42\u51fatop[]\u3001dfsx[]\uff0c\u8fd9\u65f6\u7684DFS\u5e8f\u6ee1\u8db3\uff1a\u540c\u4e00\u6761\u91cd\u94fe\u6216\u540c\u4e00\u68f5\u5b50\u6811\u4e0a\u7684\u8282\u70b9\u5728DFS\u5e8f\u4e2d\u662f\u8fde\u7eed\u7684\uff1b\n\n4.\u6839\u636eDFS\u5e8f\u8ba1\u7b97pos[]\uff0c\u7ec6\u8282\u8bf7\u89c1\u4ee3\u7801\uff0c\u6211\u628a\u8fd9\u4e2a\u8fc7\u7a0b\u53eb\u505a\u201c\u53cd\u5411\u6620\u5c04\u201d\uff1b\n\n5.\u6309\u7167DFS\u5e8f\uff0c\u5c06\u8282\u70b9\u503c\u5b58\u5165\u6570\u636e\u7ed3\u6784(\u6211\u7528\u7684\u662f\u7ebf\u6bb5\u6811)\u3002\n\n\u67e5\u8be2\u53ca\u4fee\u6539\uff1a\n\n1.\u8def\u5f84\u64cd\u4f5c\uff0c\u9700\u8981\u77e5\u9053\u4e24\u8282\u70b9\u7684LCA\uff0c\u4f46\u662f\u4e0d\u5fc5\u5355\u72ec\u53bb\u6c42\uff0c\u53ea\u9700\u6309\u7167\u91cd\u94fe\u548c\u8f7b\u8fb9\u5411\u4e0a\u8df3\u5373\u53ef\u5230\u8fbeLCA(\u8f7b\u8fb9\u8df3\u4e00\u4e0b\uff0c\u91cd\u94fe\u8df3\u5230top\u7684\u7236\u8282\u70b9\uff0c\u8bdd\u8bf4\u6211\u4e5f\u4e0d\u660e\u767d\u8fd9\u6837\u641e\u4e3a\u4ec0\u4e48\u662f\u5bf9\u7684)\uff0c\u6cbf\u8def\u4fee\u6539/\u67e5\u8be2\u5373\u53ef\uff0c\u590d\u6742\u5ea6log^2n\uff0c\u7ec6\u8282\u8bf7\u89c1\u4ee3\u7801\u3002\n\n2.\u5b50\u6811\u64cd\u4f5c\uff0c\u56e0\u4e3a\u540c\u4e00\u68f5\u5b50\u6811\u4e0a\u7684\u8282\u70b9\u5728\u6570\u636e\u7ed3\u6784\u4e2d\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u501f\u52a9size\u503c\uff0c\u4ec5\u4fee\u6539/\u67e5\u8be2\u4e00\u6b21\u5373\u53ef\uff0c\u590d\u6742\u5ea6logn\u3002\n\n\u6700\u540e\u63d0\u9192\u4e00\u53e5\uff0c\u9002\u5f53\u53d6\u6a21\uff0c\u53d6\u5c11\u4e86\u8ba1\u7b97\u7ed3\u679c\u4f1a\u6ea2\u51fa\uff0c\u53d6\u591a\u4e86\u4f1aTLE\u3002\u3002\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n\n\n\n\n    \n    \n    \n\n    \n    \n    \n\n\n\n\n\n\n\n    \n\n    \n\n\n\n    \n        \n            \n            \n    \n        \n        \n    \n            \n            \n            \n    \n            \n            \n            \n\n    \n    \n    \n    \n    \n    \n    \n    \n        \n    \n\n    \n        \n        \n        \n        \n\n    \n    \n    \n        \n        \n\n    \n    \n\n    \n    \n    \n\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#include<string>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#define ll long long\nusing namespace std;\ninline void readint(int &x){\n    x=0;\n    char t=getchar();\n    bool f=0;\n    while(t<'0' || t>'9'){\n        if(t=='-')f=1;\n        t=getchar();\n    }\n    while(t>='0' && t<='9'){\n        x=(x<<3)+(x<<1)+t-'0';\n        t=getchar();\n    }\n    if(f)x=-x;\n}\ninline void readll(ll &x){\n    x=0;\n    char t=getchar();\n    bool f=0;\n    while(t<'0' || t>'9'){\n        if(t=='-')f=1;\n        t=getchar();\n    }\n    while(t>='0' && t<='9'){\n        x=(x<<3)+(x<<1)+t-'0';\n        t=getchar();\n    }\n    if(f)x=-x;\n}\nll a[200010];  //\u70b9\u503c \nint v[200010];\nint first[200010];   \nint next[200010];\nint ord=0;  //\u90bb\u63a5\u8868 \nint fa[200010];\nint dep[200010];\nint size[200010];\nint son[200010];\nint top[200010];\nint dfsx[200010];\nint xu=0;\nint pos[200010];\nint n,m,root,mod,i;\nint f,x,y;\nll k;\ninline void setup(){\n    memset(first,0,sizeof(first));\n    memset(next,0,sizeof(next));\n    memset(son,0,sizeof(son));\n}\ninline void addedge(){\n    ord++;\n    v[ord]=y;\n    next[ord]=first[x];\n    first[x]=ord;\n    ord++;\n    v[ord]=x;\n    next[ord]=first[y];\n    first[y]=ord;\n}\nvoid dfs1(int);\nvoid dfs2(int);\ninline void path_update(int,int);\ninline ll path_query(int,int);\ninline void son_update(int);\ninline ll son_query(int);\nstruct sgt{\n    ll sum[800010];\n    ll addv[800010];\n    void build(int o,int l,int r){\n        addv[o]=0;\n        if(l==r)sum[o]=a[dfsx[l]];\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            build(lson,l,mid);\n            build(rson,mid+1,r);\n            sum[o]=(sum[lson]+sum[rson])%mod;\n        }\n    }\n    void pushdown(int o,int l,int r,int mid,int lson,int rson){\n        addv[lson]=(addv[lson]+addv[o])%mod;\n        addv[rson]=(addv[rson]+addv[o])%mod;\n        sum[lson]=(sum[lson]+addv[o]*(mid-l+1))%mod;\n        sum[rson]=(sum[rson]+addv[o]*(r-mid))%mod;\n        addv[o]=0;\n    }\n    void update(int o,int l,int r,int a,int b,int x){\n        if(l>=a && r<=b){\n            addv[o]=(addv[o]+x)%mod;\n            sum[o]=(sum[o]+x*(r-l+1))%mod;\n            return;\n        }\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            if(addv[o])pushdown(o,l,r,mid,lson,rson);\n            if(a<=mid)update(lson,l,mid,a,b,x);\n            if(b>mid)update(rson,mid+1,r,a,b,x);\n            sum[o]=(sum[lson]+sum[rson])%mod;\n        }\n    }\n    ll query(int o,int l,int r,int a,int b){\n        if(l>=a && r<=b)return sum[o];\n        else{\n            int mid=(l+r)>>1;\n            int lson=o<<1;\n            int rson=lson|1;\n            ll ans=0;\n            if(addv[o])pushdown(o,l,r,mid,lson,rson);\n            if(a<=mid)ans+=query(lson,l,mid,a,b);\n            if(b>mid)ans=(ans+query(rson,mid+1,r,a,b))%mod;\n            return ans;\n        }\n    }\n} tree;\nint main(){\n    setup();\n    readint(n);readint(m);readint(root);readint(mod);\n    for(register int i=1;i<=n;i++)readll(a[i]);\n    for(register int i=1;i<n;i++){\n        readint(x);readint(y);\n        addedge();\n    }\n    fa[root]=0;\n    dep[root]=1;\n    dfs1(root);\n    top[root]=root;\n    dfs2(root);\n    for(register int i=1;i<=n;i++)pos[dfsx[i]]=i;\n    tree.build(1,1,n);\n    while(m--){\n        readint(f);\n        switch(f){\n            case 1:{\n                readint(x);readint(y);readll(k);\n                path_update(x,y);\n                break;\n            }\n            case 2:{\n                readint(x);readint(y);\n                printf(\"%lld\\n\",path_query(x,y));\n                break;\n            }\n            case 3:{\n                readint(x);readll(k);\n                son_update(x);\n                break;\n            }\n            case 4:{\n                readint(x);\n                printf(\"%lld\\n\",son_query(x));\n                break;\n            }\n        }\n    }\n    return 0;\n}\nvoid dfs1(int x){  //fa,dep\u5728\u4e0a\u5c42\u5904\u7406 \n    size[x]=1;\n    int e=first[x],u=v[e],maxson=0;\n    while(e){\n        if(u==fa[x]){\n            e=next[e];\n            u=v[e];\n            continue;\n        }\n        fa[u]=x;\n        dep[u]=dep[x]+1;\n        dfs1(u);\n        size[x]+=size[u];\n        if(size[u]>maxson){\n            maxson=size[u];\n            son[x]=u;\n        }\n        e=next[e];\n        u=v[e];\n    }\n}\nvoid dfs2(int x){  //top\u5728\u4e0a\u5c42\u5904\u7406 \n    xu++;\n    dfsx[xu]=x;\n    if(son[x]){\n        top[son[x]]=top[x];\n        dfs2(son[x]);\n    }\n    int e=first[x],u=v[e];\n    while(e){\n        if(u==fa[x] || u==son[x]){\n            e=next[e];\n            u=v[e];\n            continue;\n        }\n        top[u]=u;\n        dfs2(u);\n        e=next[e];\n        u=v[e];\n    }\n}\ninline void path_update(int x,int y){\n    int tx=top[x],ty=top[y];\n    while(tx!=ty){\n        if(dep[tx]>dep[ty]){\n            tree.update(1,1,n,pos[tx],pos[x],k);\n            x=fa[tx];\n            tx=top[x];\n        }\n        else{\n            tree.update(1,1,n,pos[ty],pos[y],k);\n            y=fa[ty];\n            ty=top[y];\n        }\n    }\n    if(pos[x]<pos[y])tree.update(1,1,n,pos[x],pos[y],k);\n    else tree.update(1,1,n,pos[y],pos[x],k);\n}\ninline ll path_query(int x,int y){\n    ll ans=0;\n    int tx=top[x],ty=top[y];\n    while(tx!=ty){\n        if(dep[tx]>dep[ty]){\n            ans+=tree.query(1,1,n,pos[tx],pos[x]);\n            x=fa[tx];\n            tx=top[x];\n        }\n        else{\n            ans+=tree.query(1,1,n,pos[ty],pos[y]);\n            y=fa[ty];\n            ty=top[y];\n        }\n    }\n    if(pos[x]<pos[y])ans+=tree.query(1,1,n,pos[x],pos[y]);\n    else ans+=tree.query(1,1,n,pos[y],pos[x]);\n    return ans%mod;\n}\ninline void son_update(int root){\n    tree.update(1,1,n,pos[root],pos[root]+size[root]-1,k);\n}\ninline ll son_query(int root){\n    return tree.query(1,1,n,pos[root],pos[root]+size[root]-1);\n}\n```",
        "postTime": 1506867307,
        "uid": 22630,
        "name": "Running_Coder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "#\u6811\u94fe\u5256\u5206\u6709\u4e00\u68f5\u7ebf\u6bb5\u6811\u548c\u591a\u9897\u7684\u7248\u672c\n\n###\u8fd9\u91cc\u4e3a\u4e86\u7ef4\u62a4\u5b50\u6811\uff0c\u7528\u4e24\u904ddfs\u7684\u4e00\u68f5\u7248\u672c\n\n###\u53d1\u73b0\u597d\u591a\u8bb2\u89e3\u53ea\u6709dfs\u548c\u4fee\u6539\u7684\u64cd\u4f5c\n\n###\u800c\u6ca1\u6709\u5982\u4f55\u5c06\u94febiuld\u5230\u7ebf\u6bb5\u6811\u91cc\u7684\u8bb2\u89e3\n\n###\u5c31\u597d\u50cf\u4f60\u6709\u4e91\u670d\u52a1\u5668\u548c\u57df\u540d\uff0c\u4f46\u662f\u4e0d\u77e5\u9053\u600e\u4e48\u89e3\u6790DNS\uff0c\u6709\u6728\u6709\uff01\n\n\u770b\u4e0b\u8fb9\uff1a\n\n\u6811\u94fe\u662f\u6309\u7167\u91cd\u513f\u5b50\u4f18\u5148\u7684dfs\u5e8f\u5b58\u5165\u7ebf\u6bb5\u6811\u7684\n\n\u4e00\u4e2a\u8282\u70b9\u5728dfs\u5e8f\u4e2d\u7684\u987a\u5e8f\u5bf9\u5e94\u5176\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u533a\u95f4\u8282\u70b9\u987a\u5e8f\n\n\u6362\u53e5\u8bdd\uff1a\u5728dfs\u5e8f\u4e0a\u5efa\u7acb\u7ebf\u6bb5\u6811\n\n\u7136\u540e\u7528pos\u6570\u7ec4\u8bb0\u5f55\u4e0b\u6bcf\u4e2a\u8282\u70b9\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u4f4d\u7f6e\uff08\u533a\u95f4\uff09`\u76f8\u5f53\u4e8e\u57df\u540d`\n\n`\u90a3\u4e48biuld\u51fd\u6570\u5c31\u76f8\u5f53\u4e8e\u89e3\u6790\u7684\u8fc7\u7a0b\u5566`\n\n\u5176\u4ed6\u7684\u697c\u4e0b\u90fd\u6709\u8be6\u89e3\uff0c\n\n\u4ee3\u7801\u91cc\u4e5f\u6709\u5927\u91cf\u8bb2\u89e3\u5466\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#define maxn 100010\n#define ls l,m,rt<<1\n#define rs m+1,r,rt<<1|1\n#define LL long long \nusing namespace std;\nint a[maxn],n;\nLL sum[maxn<<2],add[maxn<<2],bui=1;//bui\u5efa\u6811\u7528\u7684\u8ba1\u6570\u5668 \nint h[maxn],v[maxn<<1],nt[maxn<<1],p=1;\nint size[maxn],son[maxn],top[maxn],end[maxn],fa[maxn],dep[maxn],pos[maxn],dfsx[maxn],xu=1;\n//size\u5b50\u8282\u70b9\u6570//son\u91cd\u513f\u5b50//top\u5f53\u524d\u8282\u70b9\u6240\u5c5e\u91cd\u94fe\u7684\u5934\u7ed3\u70b9\n//end[x]\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5728dfs\u5e8f\u4e2d\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u7684(dfs\u5e8f\u4e2d\u7684)\u5e8f\u53f7\n//pos[x]x\u5728dfs\u5e8f\u4e2d\u7684\u4f4d\u7f6e,\u4e5f\u662f\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\n//dfsx,dfs\u5e8f.xu,\u8ba1\u6570\u5668 \nvoid add_edge(int x,int y){\n    nt[p]=h[x];\n    h[x]=p;\n    v[p]=y;\n    p++;\n    nt[p]=h[y];\n    h[y]=p;\n    v[p]=x;\n    p++;\n}\nvoid getup(int rt){\n    sum[rt]=sum[rt<<1]+sum[rt<<1|1];\n}\nvoid pushdown(int rt,int len){\n    if (add[rt]!=0){\n        add[rt<<1]+=add[rt];\n        add[rt<<1|1]+=add[rt];\n        sum[rt<<1]+=add[rt]*(len-(len>>1));\n        sum[rt<<1|1]+=add[rt]*(len>>1);\n        add[rt]=0;\n    }\n}\n/******************************\n\u5efa\u6811\u662f\u6700\u91cd\u8981\u7684\u90e8\u5206\uff1a\n\u5c06\u6811\u6309(\u91cd\u513f\u5b50\u4f18\u5148\u7684)dfs\u5e8f\u4ee5\u94fe\u7684\u5f62\u5f0f\u5b58\u8fdb\u7ebf\u6bb5\u6811\n\u5e76\u7528pos\u8bb0\u5f55\u5176\u5728\u7ebf\u6bb5\u6811(dfs\u5e8f\u4e2d\u7684\u4f4d\u7f6e)\u4ee5\u4fbf\u4e8e\u4fee\u6539\u67e5\u8be2\n******************************/\nvoid build(int l,int r,int rt){\n    if (l==r){\n        sum[rt]=a[dfsx[bui++]];\n        return;\n    }\n    int m=(l+r)>>1;\n    build(ls);\n    build(rs);\n    getup(rt);\n}\nvoid update(int l,int r,int rt,int L,int R,int k){\n    if (L<=l&&r<=R){\n        add[rt]+=k;\n        sum[rt]+=(long long)k*(r-l+1);\n        return ;\n    }\n    int m=(l+r)>>1;\n    pushdown(rt,r-l+1);\n    if (L<=m) update(ls,L,R,k);\n    if (m+1<=R) update(rs,L,R,k);\n    getup(rt);\n}\nLL query(int l,int r,int rt,int L,int R){\n    if (L<=l&&r<=R){\n        return sum[rt];\n    } \n    pushdown(rt,r-l+1);\n    LL tot=0;\n    int m=(l+r)>>1;\n    if (L<=m) tot+=query(ls,L,R);\n    if (m+1<=R) tot+=query(rs,L,R);\n    return tot;\n}\nvoid dfs1(int x){//\u5904\u7406fa,dep,size,son \n    int j=h[x],u=v[j],maxsize=0;//\u5f53u\u4e3a\u53f6\u5b50\u8282\u70b9\uff0cson[u]=0 \n    while(j){\n        if (u!=fa[x]){\n            dep[u]=dep[x]+1;\n            fa[u]=x;//fa\u4e0d\u8981\u8d4b\u9519\u503c\uff0c\u4e0d\u7136\u6bb5\u9519\u8bef(\u9012\u5f52\u6b7b\u5faa\u73af\u7206\u6808)\n            size[x]++;\n            dfs1(u);\n            size[x]+=size[u];\n            if (size[u]>maxsize){\n                son[x]=u;\n                maxsize=size[u];\n            }\n        }\n        j=nt[j];\n        u=v[j];\n    }\n    return;\n}\nint dfs2(int x,int start){//\u91cd\u94fe\u4f18\u5148\u5904\u7406dfs\u5e8f,top,end \n    bool f=1;//\u7528\u6765SPJ\u53f6\u5b50\u8282\u70b9\u53ca(\u4e00\u4e2a\u8282\u70b9\u6709)\u591a\u4e2a\u53f6\u5b50\u8282\u70b9\u7684\u60c5\u51b5 \n    if (son[x]!=0){\n        f=0;\n        top[son[x]]=start;\n        dfsx[xu++]=son[x];\n        dfs2(son[x],start);\n    }\n    int j=h[x],u=v[j];\n    while (j){\n        if (u!=fa[x]&&u!=son[x]){\n            f?top[u]=start,f=0:top[u]=u;//\u56e0\u4e3a\u53f6\u5b50\u8282\u70b9\u4e0d\u4f1a\u518d\u5411\u4e0b\u9012\u5f52\uff0c\u6240\u4ee5\u4e0b\u9762\u5c31\u4e0d\u7528\u6539\u4e86\n            dfsx[xu++]=u;\n            dfs2(u,u); \n        }\n        j=nt[j];\n        u=v[j];\n    }\n    end[x]=xu-1;\n}\n/***********************************\n\u4e24\u70b9\u4e4b\u95f4\u4fee\u6539\uff1a\n\u5f53\u4e0d\u5728\u540c\u4e00\u94fe\u4e0a\u65f6\uff0c\u4fee\u6539top\u5927\u7684\u94fe\uff0c\u5e76\u8df3\u5230top[x]\u7684\u7236\u8282\u70b9\n\u8df3\u81f3\u540c\u4e00\u94fe\u4e4b\u540e\uff0c\u76f4\u63a5\u94fe\u4e0a\u4fee\u6539\u7136\u540ereturn\u5373\u53ef\n\u82e5\u4e3a\u540c\u4e00\u8282\u70b9\uff0c\u4fee\u6539\u540ereturn\n***********************************/\nvoid update_path(int x,int y,int z){\n    int fx=top[x],fy=top[y];\n    while (fx!=fy){\n        if (dep[fx]>=dep[fy]){\n            update(1,n,1,pos[fx],pos[x],z);\n            x=fa[fx];\n        }else{\n            update(1,n,1,pos[fy],pos[y],z);\n            y=fa[fy];\n        }        \n        fx=top[x],fy=top[y];//\u8fd9\u91cc\u4e0d\u8981\u5fd8\u4e86\u66f4\u65b0\uff0c\u4e0d\u7136\u6b7b\u5faa\u73af\uff0c\u5176\u5b9e\u76f4\u63a5\u7528top\u53ef\u4ee5\u907f\u514d\n    }\n    if (x!=y){//\u5176\u5b9e\u8fd9\u91cc\u4e0d\u7528if\u4ec5\u4fdd\u7559\u4e0b\u4e00\u884c\u5c31\u597d\uff0c\u4e0d\u8fc7\u4e3a\u4e86\u8b66\u793a\u8fd8\u662f\u5199\u5427\n        pos[x]<pos[y]?update(1,n,1,pos[x],pos[y],z):update(1,n,1,pos[y],pos[x],z);\n    }else{\n        update(1,n,1,pos[x],pos[y],z);\n    }\n}\nLL query_path(int x,int y){\n    LL ret=0;\n    int fx=top[x],fy=top[y];\n    while (fx!=fy){\n        if (dep[fx]>=dep[fy]){\n            ret+=query(1,n,1,pos[fx],pos[x]);\n            x=fa[fx];\n        }else{\n            ret+=query(1,n,1,pos[fy],pos[y]);\n            y=fa[fy];\n        }\n        fx=top[x],fy=top[y];        \n    }\n    if (x!=y){\n        pos[x]<pos[y]?ret+=query(1,n,1,pos[x],pos[y]):ret+=query(1,n,1,pos[y],pos[x]);\n    }else{\n        ret+=query(1,n,1,pos[x],pos[y]);\n    }\n    return ret;\n}\nvoid update_subtree(int x,int z){\n    update(1,n,1,pos[x],end[x],z);//\u56e0\u4e3a\u4e00\u68f5\u5b50\u6811\u7684dfs\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u8bb0\u5f55end\u540e\u76f4\u63a5\u4fee\u6539\u5373\u53ef\n}\nLL query_subtree(int x){\n    return query(1,n,1,pos[x],end[x]);\n}\nint main(){\n    int m,r,x,y,z,Q;\n    LL p;\n    cin>>n>>m>>r>>p;\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    for (int i=1;i<n;i++) {\n        scanf(\"%d%d\",&x,&y);\n        add_edge(x,y);\n    }\n    fa[r]=r;\n    dep[r]=0;\n    dfs1(r);\n    top[r]=r;\n    dfsx[xu++]=r;//\u521d\u59cb\u5316\u90e8\u5206\u8981\u770b\u597d\n    dfs2(r,r);\n    for (int i=1;i<xu;i++){\n        pos[dfsx[i]]=i;\n    }\n    build(1,n,1);\n    while (m--){\n        scanf(\"%d\",&Q);\n        if (Q==1){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            update_path(x,y,z);\n            continue;\n        }\n        if (Q==2){\n            scanf(\"%d%d\",&x,&y);\n            printf(\"%lld\\n\",query_path(x,y)%p);\n            continue;\n        }\n        if (Q==3){\n            scanf(\"%d%d\",&x,&z);\n            update_subtree(x,z);\n            continue;\n        }\n        if (Q==4){\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",query_subtree(x)%p);\n            continue;\n        }\n        \n    }\n    return 0;\n}\n\n```",
        "postTime": 1503499155,
        "uid": 19559,
        "name": "sun615",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u9898\u89e3\u5730\u5740\uff1a http://www.saruka.studio/2017/03/luogu-p3384/\n\n\n![](http://www.saruka.studio/wp-content/uploads/2017/03/23.jpg)\n\n\u8fd9\u662f\u4e00\u68f5\u6811\uff0c\u4e0d\u540c\u7684\u91cd\u94fe\u5df2\u7ecf\u7528\u4e0d\u540c\u7c97\u7ec6\u7684\u7ea2\u8fb9\u8fde\u597d\u3002\n\n\u5047\u8bbe\u6211\u4eec\u8ba9\u4ee53\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u6240\u6709\u8282\u70b9+3\u3002\u8fd9\u91cc\u6211\u4eec\u8981\u591a\u8bb0\u5f55\u4e00\u70b9\u4fe1\u606f: end[i]\u4ee3\u8868\u4ee5i\u5f00\u5934\u7684\u91cd\u94fe\u7ed3\u5c3e\u7684\u7f16\u53f7\u3002\n\n\u6211\u4eec\u77e5\u9053\uff0c3\u53f7\u8282\u70b9\u6240\u5c5e\u7684\u91cd\u94fe\u7684\u5f00\u5934\u662f1\u53f7\uff0c\u901a\u8fc7end[1]\u5f97\u77e5\u91cd\u94fe\u7ed3\u5c3e\u662f9\u53f7\uff0cid[9]  =  6\u3002\u6240\u4ee5\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u5bf9\u533a\u95f4id[3] ~ id[9]\u8fdb\u884c\u4fee\u6539\u64cd\u4f5c(+3)\uff0c\u4e5f\u5c31\u662f\u533a\u95f4[3, 6]\u3002\n\n\u64cd\u4f5c\u5b8c\u6211\u4eec\u53d1\u73b0\uff0c3\u53f7\u7684\u513f\u5b50(\u5148\u884c\u8bb0\u5f55\uff0c\u7b2c\u4e00\u4e2aDFS\u6216\u7b2c\u4e8c\u4e2a\u90fd\u53ef\u4ee5)\u67097\u4e2a(\u5305\u62ec3\u53f7\u81ea\u5df1)\uff0c\u6211\u4eec\u521a\u521a\u5904\u7406\u7684\u8282\u70b9\u4e2a\u6570\u662fid[9]-id[6] + 1 = 4\u4e2a\uff0c\u8fd9\u91cc\u662f\u8bf4\u660e\u6211\u4eec\u8fd8\u6ca1\u6709\u5904\u7406\u5b8c\u3002\u6211\u4eec\u8981\u5904\u7406\u7684\u4e0b\u4e00\u6761\u91cd\u94fe\u7684top\u53f7\u5c31\u662f\u6211\u4eec\u73b0\u5728\u5904\u7406\u7684\u91cd\u94fe\u7684end+1\u3002\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5904\u74067\u6240\u5728\u7684\u91cd\u94fe\uff1a\u533a\u95f4id[top[7]] ~ id[end[top[7]]] -> \u6ce8\u610fend[]\u7684\u5b9a\u4e49\u662f\u4ee3\u8868[\u4ee5i\u5f00\u5934]\u91cd\u94fe\u7ed3\u5c3e\u7684\u7f16\u53f7\uff0c\u4e5f\u5c31\u662f\u533a\u95f4[7, 7]\u3002\n\n\u4e3a\u4ec0\u4e48\u4f1a\u8fd9\u6837\uff1f\u56e0\u4e3a\u6211\u4eec\u7b2c\u4e8c\u6b21\u7684DFS\u5148\u641c\u91cd\u513f\u5b50\uff0c\u4fdd\u8bc1\u91cd\u94fe\u4e0aid\u7684\u8fde\u7eed\uff0c\u4f46\u662f\u4e4b\u540e\u641c\u7d22\u8f7b\u513f\u5b50\u4eec\u4fdd\u8bc1\u8f7b\u513f\u5b50\u5f00\u5934\u7684\u91cd\u94fe\u7d27\u7d27\u8fde\u5728\u5f53\u524d\u91cd\u94fe\u6700\u540e\u4e00\u4e2a\u8282\u70b9id\u7684\u540e\u9762\u3002\u7136\u540e\u5904\u7406\u5b8c7\u540e\uff0c\u5269\u4e0b\u7684\u513f\u5b50\u6570\u662f7 - 4(\u7b2c\u4e00\u6b21) - (id[7] - id[7] + 1)(\u8fd9\u4e00\u6b21\u7684) = 2\u3002\u8bf4\u660e\u8fd8\u6ca1\u5904\u7406\u5b8c\uff0c\u4e8e\u662f\u4eceend[top[7]] + 1\u5f00\u59cb\u7ee7\u7eed\u5904\u7406\uff0c\u4e5f\u5c31\u662f8\u53f7\u5f00\u5934\u7684\u91cd\u94fe\u3002\u7136\u540e\u5f80\u590d\u8fd9\u6837\uff0c\u76f4\u5230\u6ca1\u6709\u513f\u5b50\u53ef\u4ee5\u5904\u7406\u4e86\u3002\n\n\u5bf9\u4e8e4\u53f7\u64cd\u4f5c\uff1a\u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\u3002\u5c31\u662f3\u53f7\u64cd\u4f5c\u7684\u9006\u64cd\u4f5c\uff0c\u6211\u4eec\u53ea\u9700\u8981\u628a\u66f4\u65b0\u6539\u4e3a\u6c42\u548c\u5c31\u597d\u4e86\u3002\n\n\u603b\u7ed3\u4e00\u4e0b\u3002\n\n3\u53f7\u64cd\u4f5c\u76f4\u63a5\u4fee\u6539\u533a\u95f4id[root] ~ id[root] + son[id[root]]  (+1)\n\n4\u53f7\u64cd\u4f5c\u5c31\u662f\u53d6\u51fa\u533a\u95f4id[root] ~ id[root] + son[id[root]]  (+1)\u7684\u548c\n\n\u53e6\u5916\uff0c\u4e00\u9897\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u91cc\u5bf9\u5e94\u7740\u4e00\u6bb5\u8fde\u7eed\u7684\u533a\u95f4\uff0c\u90a3\u533a\u95f4\u7684end\u53ef\u4ee5\u7528begin+begin\u7684\u513f\u5b50\u6570\u6765\u8ba1\u7b97\n\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 500005;\ntypedef long long LL;\nint cnte; // the subscipt of current edge\nint n, m, r, temp;\nLL mod;\nint top[maxn], depth[maxn], father[maxn], id[maxn], head[maxn], son[maxn], heavy_son[maxn], a[maxn];\nint real[maxn]; // real subscipt -> real[id[i]] == i\nstruct Edge\n{\n    int to, next;    \n} edge[maxn];\nstruct Segment_Tree\n{\n    LL l, r, sum, tag;\n} tree[maxn];\ninline int getint()\n{\n    // input optimization\n    int r = 0, k = 1;\n    char c = getchar();\n    for(; c < '0' || c > '9'; c = getchar())\n        if(c == '-') k = -1;\n    for(; c >= '0' && c <= '9'; c = getchar())\n        r = r * 10 + c - '0';\n    return r * k;\n}\ninline LL getll()\n{\n    // input optimization\n    LL r = 0, k = 1;\n    char c = getchar();\n    for(; c < '0' || c > '9'; c = getchar())\n        if(c == '-') k = -1;\n    for(; c >= '0' && c <= '9'; c = getchar())\n        r = r * 10 + c - '0';\n    return r * k;\n}\nvoid add_edge(int u, int v)\n{\n    edge[++cnte].next = head[u];\n    edge[cnte].to = v;\n    head[u] = cnte;\n}\nvoid DFS_1(int now, int fa)\n{\n    //in order to calculate the father also the heavy_son of every nodes\n    father[now] = fa;\n    depth[now] = depth[father[now]] + 1;\n    // in case that the stack maybe crash\n    son[now] = 1;\n    for(int i = head[now]; i; i = edge[i].next)\n    {\n        if(edge[i].to != fa)\n        {\n            DFS_1(edge[i].to, now);\n            son[now] += son[edge[i].to];\n            if(!heavy_son[now] || son[edge[i].to] > son[heavy_son[now]])\n                heavy_son[now] = edge[i].to;\n        }\n    }\n}\nvoid DFS_2(int now, int first)\n{\n    //in order to map the nodes on the tree to the Segment Tree\n    top[now] = first; // maintain the head of heavy chain of node i\n    id[now] = ++temp; // map it to Segment Tree\n    real[id[now]] = now; // map it back\n    if(!heavy_son[now]) return;\n    DFS_2(heavy_son[now], first);\n    for(int i = head[now]; i; i = edge[i].next)\n    {\n        if(edge[i].to != heavy_son[now] && edge[i].to != father[now])\n            DFS_2(edge[i].to, edge[i].to);\n            // node edge[i].to makes itself a heavy chain\n    }\n}\nvoid push_up(int now)\n{\n    tree[now].sum = tree[now << 1].sum + tree[now << 1 | 1].sum;\n    return;\n}\nvoid push_down(int now)\n{\n    tree[now << 1].tag += tree[now].tag;\n    tree[now << 1].sum += tree[now].tag * (tree[now << 1].r - tree[now << 1].l + 1);\n    tree[now << 1 | 1].tag += tree[now].tag;\n    tree[now << 1 | 1].sum += tree[now].tag * (tree[now << 1 | 1].r - tree[now << 1 | 1].l + 1);\n    tree[now].tag = 0;\n    return;\n}\nvoid build(int now, int l, int r)\n{\n    // in order to build the Segment Tree\n    tree[now].l = l;\n    tree[now].r = r;\n    if(l == r)\n    {\n        tree[now].sum = a[real[l]];\n        return;\n    }\n    int mid = (tree[now].l + tree[now].r) >> 1;\n    build(now << 1, l, mid);\n    build(now << 1 | 1, mid + 1, r);\n    push_up(now);\n    return;\n}\nvoid update(int now, int ll, int rr, LL x)\n{\n    // in order to change a value of a certain interval\n    if(ll <= tree[now].l && tree[now].r <= rr)\n    {\n        tree[now].tag += x;\n        tree[now].sum += x * (tree[now].r - tree[now].l + 1);\n        return;\n    }\n    push_down(now);\n    int mid = (tree[now].l + tree[now].r) >> 1;\n    if(rr <= mid) update(now << 1, ll, rr, x);\n    else if(ll > mid) update(now << 1 | 1, ll, rr, x);\n    else \n    {\n        update(now << 1, ll, mid, x);\n        update(now << 1 | 1, mid + 1, rr, x);\n    }\n    push_up(now);\n    return;\n}\nLL query_sum(int now, int ll, int rr)\n{\n    // in order to calculate the summary of a certain interval\n    if(ll <= tree[now].l && tree[now].r <= rr)\n        return tree[now].sum;\n    push_down(now);\n    int mid = (tree[now].l + tree[now].r) >> 1;\n    if(rr <= mid) return query_sum(now << 1, ll, rr);\n    else if(ll > mid) return query_sum(now << 1 | 1, ll, rr);\n    else\n        return query_sum(now << 1, ll, mid) + query_sum(now << 1 | 1, mid + 1, rr);\n}\nvoid change(int u, int v, LL x)\n{\n    int tu = top[u];\n    int tv = top[v];\n    while(tu != tv)\n    {\n        // this ensure u and v is not at the same heavy chain\n        if(depth[tu] < depth[tv])\n        {\n            // ensure that heavy chain 1 is under heavy chain 2\n            swap(tu, tv);\n            swap(u, v);\n        }\n        update(1, id[tu], id[u], x);\n        u = father[tu];\n        tu = top[u];\n    }\n    if(depth[u] > depth[v]) swap(u, v);\n    update(1, id[u], id[v], x);\n}\nint find_sum(int u, int v)\n{\n    LL sum = 0;\n    int tu = top[u];\n    int tv = top[v];\n    while(tu != tv)\n    {\n        if(depth[tu] < depth[tv])\n        {\n            swap(tu, tv);\n            swap(u, v);\n        }\n        sum += query_sum(1, id[tu], id[u]);\n        sum %= mod;\n        u = father[tu];\n        tu = top[u];\n    }\n    if(depth[u] > depth[v]) swap(u, v);\n    sum += query_sum(1, id[u], id[v]);\n    return sum %= mod;\n}\nvoid root_add(int now, LL x)\n{\n    int begin = id[now];\n    int end = id[now] + son[now] - 1;\n    update(1, begin, end, x);\n}\nLL root_sum(int now)\n{\n    int begin = id[now];\n    int end = id[now] + son[now] - 1;\n    return query_sum(1, begin, end) % mod;\n}\nint main(int argc, char const *argv[])\n{\n    n = getint();\n    m = getint();\n    r = getint();\n    mod = getll();\n    for(int i = 1; i <= n; i++)\n        a[i] = getint();\n    for(int i = 1; i <= n - 1; i++)\n    {\n        int u = getint();\n        int v = getint();\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    DFS_1(r, 0);\n    DFS_2(r, r);\n    build(1, 1, temp);\n    for(int i = 0; i < m; i++)\n    {\n        int t, x, y, z;\n        t = getint();\n        if(t == 1)\n        {\n            x = getint();\n            y = getint();\n            z = getint();\n            change(x, y, z);\n        }\n        else if(t == 2)\n        {\n            x = getint();\n            y = getint();\n            printf(\"%lld\\n\", find_sum(x, y));\n        }\n        else if(t == 3)\n        {\n            x = getint();\n            y = getint();\n            root_add(x, y);\n        }\n        else if(t == 4)\n        {\n            x = getint();\n            printf(\"%lld\\n\", root_sum(x));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1492929525,
        "uid": 27189,
        "name": "saruka",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\n\n\u6811\u94fe\u5256\u5206\n\n\u5176\u5b9e\u627eLCA\u65f6\u53ef\u4ee5\u6839\u636e\u94fe\u4e0a\u7684\u6839\u8282\u70b9\u6765\u627e\n\n\u4e0d\u5fc5\u7279\u610f\u7528\u500d\u589e\u4e4b\u7c7b..\n\n\u4ee3\u7801\u91cc\u6709\u8f83\u8be6\u7ec6\u6ce8\u91ca\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n```cpp\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#define Max 100001\nusing namespace std;\ntypedef long long LL;\nvoid read (LL &now)\n{\n    now = 0;\n    bool temp = false;\n    char word = getchar ();\n    while (word < '0' || word > '9')\n    {\n        if (word == '-')\n            temp = true;\n        word = getchar ();\n    }\n    while (word >= '0' && word <= '9')\n    {\n        now = now * 10 + word - '0';\n        word = getchar ();\n    }\n    now = temp ? ~now + 1 : now;\n}\ninline void swap (LL &x, LL &y)\n{\n    LL now = x;\n    x = y;\n    y = now;\n}\nLL tree_dis[Max];\nLL N, M, Mod, Root;\nLL head[Max];\nstruct Edge \n{\n    LL to;\n    LL next;\n}edge[Max << 1];\nstruct Segment_Tree\n{\n    LL l;\n    LL r;\n    LL Sum;\n    LL Mid;\n    LL delta;\n}tree[Max << 2];\nstruct Point\n{\n    LL dis;\n    LL deep;\n    LL size;\n    LL chain;\n    LL father;\n    LL end;\n    LL flag;\n}point[Max];\nint Count;\ninline void AddEdge (LL from, LL to)\n{\n    Count++;\n    edge[Count].to = from;\n    edge[Count].next = head[to];\n    head[to] = Count;\n    Count++;\n    edge[Count].to = to;\n    edge[Count].next = head[from];\n    head[from] = Count;\n}\nvoid Dfs_1 (LL now, LL father)  // \u627e\u8282\u70b9\u7684size\u503c, \u7236\u4eb2\u8282\u70b9, \u6df1\u5ea6deep\n{\n    LL pos = Count++; // \u8bb0\u5f55\u5f53\u524d\u4f4d\u7f6e \n    point[now].deep = point[father].deep + 1; // \u5f53\u524d\u8282\u70b9\u6df1\u5ea6\u662f\u5f53\u524d\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u7684\u6df1\u5ea6 + 1 \n    point[now].father = father;// \u8bbe\u7f6e\u4e3a\u5f53\u524d\u70b9\u7684\u7236\u4eb2\u8282\u70b9 \n    for (LL i = head[now]; i; i = edge[i].next) // \u904d\u5386\u5f53\u524d\u70b9\u4e4b\u540e\u7684\u8fb9\n    {\n        if (edge[i].to == father) // \u907f\u514d\u5c06\u94fe\u8fde\u56de\u7236\u4eb2\u8282\u70b9 \n            continue;\n        Dfs_1 (edge[i].to, now); // \u7ee7\u7eed\u9012\u5f52 \n    }\n    point[now].size = Count - pos; // \u4ee5\u5f53\u524d\u70b9\u4f4d\u6839\u8282\u70b9\u7684\u5b50\u6811\u7684\u8282\u70b9\u6570\u4e3a\u5df2\u6269\u5c55\u70b9\u7684\u6570\u91cf\u51cf\u53bb\u5f53\u524d\u4f4d\u7f6e  \n}\nvoid Dfs_2 (LL now, LL chain) // \u8fde\u91cd\u94fe  (\u627e\u5230\u6bcf\u4e2a\u70b9\u6240\u5c5e\u54ea\u6761\u94fe, \u627e\u5230\u5f53\u524d\u70b9\u5728\u7ebf\u6bb5\u6811(\u6216\u5176\u4ed6\u6811\u4e2d\u7684\u4f4d\u7f6e), \u540c\u65f6\u5904\u7406\u51fa\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9\u4e0a\u7684\u503c)\n{\n    LL pos = 0; // \u521d\u59cb\u5316\u91cd\u513f\u5b50\u7684\u4f4d\u7f6e \n    point[now].chain = chain;// \u8bbe\u7f6e\u6240\u5c5e\u7684\u94fe \n    point[now].flag = ++Count;// \u8bbe\u7f6e\u5f53\u524d\u70b9\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e \n    tree_dis[Count] = point[now].dis;  // \u8bbe\u7f6e\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9\u4e0a\u7684\u503c \n    for (LL i = head[now]; i; i = edge[i].next)// \u904d\u5386\u8fb9 \n    {\n        if (point[edge[i].to].flag)// \u5982\u679c\u5f53\u524d\u70b9\u5df2\u88ab\u5904\u7406\u8fc7 \n            continue;\n        if (point[edge[i].to].size > point[pos].size)//\u627e\u91cd\u513f\u5b50, \u66f4\u65b0\u8981\u67e5\u627e\u7684\u4f4d\u7f6e \n            pos = edge[i].to;\n    }\n    if (pos) // \u5982\u679c\u627e\u5230\u4e86\u91cd\u513f\u5b50, \u5c31\u8fde\u5230\u5f53\u524d\u94fe\u4e0a, \u7ee7\u7eed\u5411\u4e0b\u627e \n        Dfs_2 (pos, chain);\n    for (LL i = head[now]; i; i = edge[i].next)\n    {\n        if (point[edge[i].to].flag)\n            continue;\n        Dfs_2 (edge[i].to, edge[i].to);  // \u5f00\u4e00\u6761\u65b0\u94fe \n    }\n    point[now].end = Count;\n}\n//\u4ee5\u4e0b\u4e3a\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c \ninline void Tree_Up (LL now)\n{\n    tree[now].Sum = tree[now << 1].Sum + tree[now << 1 | 1].Sum;\n}\ninline void Tree_Down (LL now)\n{\n    if (tree[now].l == tree[now].r)\n        return ;\n    tree[now << 1].Sum += tree[now].delta * (tree[now << 1].r - tree[now << 1].l + 1);\n    tree[now << 1].delta += tree[now].delta;\n    tree[now << 1 | 1].Sum += tree[now].delta * (tree[now << 1 | 1].r - tree[now << 1 | 1].l + 1);\n    tree[now << 1 | 1].delta += tree[now].delta;\n    tree[now].delta = 0;\n}\nvoid Tree_Build (LL l, LL r, LL now)\n{\n    tree[now].l = l;\n    tree[now].r = r;\n    if (l == r)\n    {\n        tree[now].Sum = tree_dis[++Count];\n        return ;\n    }\n    tree[now].Mid = (l + r) >> 1;\n    Tree_Build (l, tree[now].Mid, now << 1);\n    Tree_Build (tree[now].Mid + 1, r, now << 1 | 1);\n    Tree_Up (now);\n}\nvoid Tree_Change (LL l, LL r, LL now, LL to)\n{\n    if (tree[now].l == l && tree[now].r == r)\n    {\n        tree[now].Sum += to * (r - l + 1);\n        tree[now].delta += to;\n        return ;\n    }\n    if (tree[now].delta)\n        Tree_Down (now);\n    if (r <= tree[now].Mid)\n        Tree_Change (l, r, now << 1, to);\n    else if (l > tree[now].Mid)\n        Tree_Change (l, r, now << 1 | 1, to);\n    else \n    {\n        Tree_Change (l, tree[now].Mid, now << 1, to);\n        Tree_Change (tree[now].Mid + 1, r, now << 1 | 1, to);\n    }\n    Tree_Up (now);\n}\nLL Tree_Query (LL l, LL r, LL now)\n{\n    if (tree[now].l == l && tree[now].r == r)\n        return tree[now].Sum;\n    if (tree[now].delta)\n        Tree_Down (now);\n    Tree_Up (now);\n    if (r <= tree[now].Mid)\n        return Tree_Query (l, r, now << 1);\n    else if (l > tree[now].Mid)\n        return Tree_Query (l, r, now << 1 | 1);\n    else \n        return Tree_Query (l, tree[now].Mid, now << 1) + Tree_Query (tree[now].Mid + 1, r, now << 1 | 1);\n}\n// \u4ee5\u4e0b\u4e3a\u5bf9\u4e8e\u5b50\u6811\u7684\u64cd\u4f5c \nvoid Chain_Change (LL x, LL y, LL z)\n{\n    while (point[x].chain != point[y].chain)  // \u5f53\u5f53\u524d\u7684\u4e24\u4e2a\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u65f6, (\u5373\u627eLCA)  (\u53ef\u4ee5\u770b\u505a\u662f\u4e24\u4e2a\u70b9\u5411\u4e0a\u8df3 ^ _ ^ ) \n    {\n        if (point[point[x].chain].deep < point[point[y].chain].deep) //\u5982\u679c\u5f53\u524d\u4e24\u6761\u94fe\u7684\u6839\u8282\u70b9\u7684\u6df1\u5ea6\u4e0d\u540c, \u5c31\u7ee7\u7eed\u5f80\u4e0a\u8df3 \n            swap (x, y);                                            // \u6211\u8fd9\u91cc\u4e3a\u4e86\u7b80\u4fbf\u5199\u6cd5, \u76f4\u8df3\u5de6\u8fb9\u7684\u70b9, \u82e5\u9700\u8981\u8df3\u53e6\u4e00\u4e2a\u70b9\u65f6, \u628a\u4e24\u4e2a\u70b9\u4e00\u4ea4\u6362\u5373\u53ef \n        Tree_Change (point[point[x].chain].flag, point[x].flag, 1, z); // \u89c1\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\n        x = point[point[x].chain].father; //\u8df3\u5230\u4e0b\u4e00\u4e2a\u70b9 \n    }\n    if (point[x].deep < point[y].deep)\n        swap (x, y);\n    Tree_Change (point[y].flag, point[x].flag, 1, z); // \u4fee\u6539\u503c\n}\nLL Chain_Query (LL x, LL y) //\u540c\u5b50\u6811\u67e5\u8be2 \n{\n    LL Answer = 0;\n    while (point[x].chain != point[y].chain)\n    {\n        if (point[point[x].chain].deep < point[point[y].chain].deep)\n            swap (x, y);\n        Answer = (Answer + Tree_Query (point[point[x].chain].flag, point[x].flag, 1)) % Mod;\n        x = point[point[x].chain].father;\n    }\n    if (point[x].deep < point[y].deep)\n        swap (x, y);\n    Answer = (Answer + Tree_Query (point[y].flag, point[x].flag, 1)) % Mod;\n    return Answer;\n}\nint main (int argc, char *argv[])\n{\n    LL N;\n    read (N);\n    read (M);\n    read (Root);\n    read (Mod);\n    for (LL i = 1; i <= N; i++)\n        read (point[i].dis);\n    LL type, x, y, z;\n    for (LL i = 1; i < N; i++)\n    {\n        read (x);\n        read (y);\n        AddEdge (x, y);\n    }\n    Count = 0;\n    Dfs_1 (Root, 0);\n    Count = 0;\n    Dfs_2 (Root, Root);\n    Count = 0;\n    Tree_Build (1, N, 1);\n    for (LL i = 1; i <= M; i++)\n    {\n        read (type);\n        switch (type)\n        {\n            case 1:\n            {\n                read (x);\n                read (y);\n                read (z);\n                Chain_Change (x, y, z);\n                break;\n            }\n            case 2:\n            {\n                read (x);\n                read (y);\n                printf (\"%lld\\n\", Chain_Query (x, y) % Mod);\n                break;\n            }\n            case 3:\n            {\n                read (x);\n                read (y);\n                Tree_Change (point[x].flag, point[x].end, 1, y);\n                break;\n            }\n```\ndefault:\n```cpp\n            {\n                read (x);\n                printf (\"%lld\\n\", Tree_Query (point[x].flag, point[x].end, 1) % Mod);\n                break;\n            }\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1486648237,
        "uid": 21123,
        "name": "ZlycerQan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "# \u6811\u94fe\u5256\u5206\u6a21\u677f\n\n**~~\u5e7f\u544a~~** \u672c\u6587\u540c\u6b65\u53d1\u5e03\u5728\u6211\u7684\u535a\u5ba2\u4e0a\uff1a  https://www.cnblogs.com/Eroad/p/11856670.html\n\n\u6811\u94fe\u5256\u5206\u53ef\u4ee5\u628a\u6811\u4e0a\u7684\u70b9\u5212\u5206\u6210\u4e00\u6761\u6761**\u8fde\u7eed**\u7684\u201c\u94fe\u201d\uff0c\u201c\u94fe\u201d\u662f\u4e00\u6761\u7b80\u5355\u8def\u5f84\uff0c\u4e0a\u9762\u7684\u6bcf\u4e2a\u70b9\u6ee1\u8db3\u7956\u5148\u540e\u4ee3\u5173\u7cfb\uff0c\u4ece\u6839\u8282\u70b9\u5230\u6bcf\u4e2a\u70b9\u90fd\u53ea\u9700\u7ecf\u8fc7\u6700\u591a$\\log_2n$\u6761\u94fe\u3002  \u94fe\u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9 **dfs\u5e8f\u4e5f\u662f\u8fde\u7eed\u7684**\uff0c \u6545\u53ef\u4ee5\u914d\u5408\u5176\u4ed6\u6570\u636e\u7ed3\u6784\u89e3\u51b3\u5f88\u591a\u6811\u4e0a\u67e5\u8be2\u95ee\u9898\uff08\u8fd1\u4e4e\u6240\u6709\u9759\u6001\u6811\u95ee\u9898\uff09\n\n\u5148\u5b9a\u4e49`siz[u]`\u4e3a\u70b9`u`\u7684\u5b50\u6811\u5927\u5c0f\u3002  \n\n```\nint siz[MAXN]; //\u6bcf\u4e2a\u70b9\u7684\u5b50\u6811\u5927\u5c0f\nint dep[MAXN]; //\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\nint mxson[MAXN];//\u6bcf\u4e2a\u70b9\u7684\u91cd\u513f\u5b50\n```\n\n\n\n\u94fe\u5206\u4e3a**\u91cd\u94fe**\u548c**\u8f7b\u94fe**\u3002 \u8003\u8651\u6bcf\u4e2a\u70b9\uff0c\u5b83\u53ea\u4f1a\u548c\u5b83\u7684\u4e00\u4e2a\u513f\u5b50\u7ec4\u6210\u94fe\uff0c\u8fd9\u4e2a\u513f\u5b50\u53eb\u505a **\u91cd\u513f\u5b50**\uff0c \u5176\u4ed6\u513f\u5b50\u53eb\u505a **\u8f7b\u513f\u5b50**\u3002 \u91cd\u513f\u5b50\u6ee1\u8db3\uff1a `siz[mxson[u]] `\u6700\u5927. \n\n### \u7b2c\u4e00\u6b21dfs: \n\n> \u4efb\u52a1\u6e05\u5355\uff1a \n>\n> 1. \u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9 **u** \u7684 **siz[u]**, **dep[u]**, **fa[u]** \n> 2. \u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684**\u91cd\u513f\u5b50**\uff08\u6ce8\u610f\u53f6\u8282\u70b9\u6ca1\u6709\u91cd\u513f\u5b50\uff01\uff09\n\n``` cpp\nvoid dfs1(int u, int faa){\n    dep[u] = dep[faa] + 1;\n    siz[u] = 1;\n    fa[u] = faa;\n    int mxsiz = 0;\n    for(int e = h[u]; e; e = nxt[e]){\n        int v = ev[e];\n        if(v == faa) continue;\n        dfs1(v, u);\n        if(mxsiz < siz[v]) {\n            mxson[u] = v;\n            mxsiz = siz[v];\n        } \n        siz[u] += siz[v];\n    }\n}\n```\n\n\n\n### \u7b2c\u4e8c\u6b21dfs:  \u786e\u5b9adfs\u5e8f\u548c\u6574\u68f5\u6811\u7684\u5256\u5206\u60c5\u51b5. \n\n>  \u4efb\u52a1\u6e05\u5355\uff1a \n>\n> 1. \u6c42\u51fa\u6bcf\u4e2a\u70b9\u7684\u201c\u65b0\u7f16\u53f7\u201d\uff0c \u6240\u6709\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u64cd\u4f5c\u90fd\u8981\u4f7f\u7528 **\u65b0\u7f16\u53f7** \uff08\u56e0\u4e3a\u53ea\u6709\u4f7f\u7528\u65b0\u7f16\u53f7\uff0c\u6bcf\u6761\u94fe\u4e0a\u7684\u70b9$dfs$\u5e8f\u624d\u662f\u8fde\u7eed\u7684\u3002\n> 2. \u6c42\u51fa\u6bcf\u4e2a\u70b9`u`\u7684 `top[u]`(\u4e0b\u9762\u6709\u89e3\u91ca)\n\n``` \nint top[u]; //u\u6240\u5728\u7684\u94fe\u7684\u9876\u7aef\nint dfn[MAXN]; //\u6bcf\u4e2a\u70b9\u7684dfs\u5e8f(\u7b2c\u4e8c\u6b21dfs\u540e) \u4f5c\u4e3a\u6bcf\u4e2a\u70b9\u7684\u65b0\u7f16\u53f7\n```\n\n``` cpp\nint timestamp = 0;\nvoid dfs2(int u, int topf){\n    dfn[u] = ++timestamp;\n    top[u] = topf;\n    if(mxson[u] == 0) return; //VERY IMPORTANT!!!!\n    //\u4e0a\u9762\u8fd9\u53e5\u4ee3\u7801\u4e0d\u52a0\u4f1aRE! (\u6ca1\u6709\u513f\u5b50\u7684\u8282\u70b9\u4e0d\u53ef\u4ee5dfs!)\n    //\u6216\u8005\u52a0\u4e00\u53e5if(u == 0) return; \u4e5f\u53ef\u4ee5\n    dfs2(mxson[u], topf);\n    for(int e = h[u]; e; e = nxt[e]){\n        int v = ev[e];\n        if(v != fa[u] && v != mxson[u]) dfs2(v, v);\n    }\n}\n```\n\n\n\n\u4e24\u904d$dfs$\u540e, \u5bf9\u6574\u68f5\u6811\u7684\u5256\u5206\u5df2\u7ecf\u5b8c\u6210. \n\n\n\n### \u6613\u9519\u70b9\n\n**\u6ce8\u610f\uff01\uff01 \u6ce8\u610f\uff01\uff01 \u6ce8\u610f\uff01\uff01**\n\n`siz[u], top[u], fa[u], dep[u], mxson[u]` \u4e2d\u7684 $u$ \u662f\u6bcf\u4e2a\u70b9\u7684 **\u65e7\u7f16\u53f7\uff01\uff01\uff01**\n\n\n\n## \u6811\u94fe\u5256\u5206\u7684\u5e94\u7528\n\n\u4e3e\u4e2a\u4f8b\u5b50: \u901a\u8fc7\u6811\u94fe\u5256\u5206\u5b9e\u73b0\u94fe\u4e0a\u6c42\u548c\u7b49\u64cd\u4f5c. \n\n### \u94fe\u4e0a\u8be2\u95ee\n\n\u4e00\u8fb9\u6c42 $LCA$ \u4e00\u8fb9\u4f7f\u7528\u7ebf\u6bb5\u6811\u4fee\u6539/\u6c42\u548c. (\u56e0\u4e3a\u6bcf\u6761\u94fe\u4e0a\u7684\u70b9\u7684$dfs$\u5e8f\u8fde\u7eed)\n\n\u6240\u6709\u94fe\u4e0a\u64cd\u4f5c\u90fd\u53ef\u4ee5\u57fa\u4e8e\u8be5\u6a21\u677f\u3002 **\u77aa\u5927\u773c\u775b\uff0c\u6ce8\u91ca\u975e\u5e38\u91cd\u8981\uff01**\n\n```cpp\n#define swapdep(u, v) if(dep[top[u]] < dep[top[v]]) swap(u, v) //u\u6240\u5728\u94fe\u66f4\u6df1\nint qchain(int u, int v) {\n    ll ret = 0;\n    //\u548c\u500d\u589e\u6c42LCA\u4e00\u6837, \u8fd9\u91cc\u6c42LCA\u4e5f\u662f\u8ba9\u4e24\u4e2a\u8282\u70b9\u8f6e\u6d41\u5411\u4e0a\"\u8df3\"\u3002 \n    //\u6b64\u65f6\uff0c\u8981\u6c42\u8df3\u7684\u90a3\u4e2a\u70b9   \u6240\u5728\u94fe\u7684\u6df1\u5ea6   \u8f83\u5927(\u56e0\u4e3a\u8df3\u5b8c\u4e4b\u540e\uff0cu = fa[top[u]])\n    while(top[u] != top[v]) {\n        swapdep(u, v);\n        upd(ret, query(1, 1, n, dfn[top[u]], dfn[u]) );\n        u = fa[top[u]];\n    }\n    //\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u6761\u94fe\u4e0a\u4ee5\u540e, \u5c31\u8981\u6839\u636e  \u70b9\u81ea\u5df1\u7684\u6df1\u5ea6  \u6765\u5224\u65ad\u8c01\u5148\u8c01\u540e\u4e86\u3002(\u67e5\u8be2[l, r]\u533a\u95f4\u548c\u65f6, l <= r )\n    if(dep[u] < dep[v]) swap(u, v);\n    upd(ret, query(1, 1, n, dfn[v], dfn[u]) );\n    return ret;\n}\n```\n\n\u94fe\u4e0a\u4fee\u6539\u540c\u7406. \n\n### \u5b50\u6811\u8be2\u95ee\n\n\u6bcf\u4e2a\u70b9\u7684\u5b50\u6811$dfs$\u5e8f\u8fde\u7eed, \u540c\u6837\u4f7f\u7528\u7ebf\u6bb5\u6811\u4fee\u6539/\u6c42\u548c \n\n\u6ce8\u610f siz[u] \u4e2d\u7684u\u662f\u6bcf\u4e2a\u70b9\u7684 **\u521d\u59cb\u7f16\u53f7**\n\n```cpp\nint qsub(int u){\n    return query(1, 1, n, dfn[u], dfn[u] + siz[u] - 1);\n}\nvoid updsub(int u, int val){\n    update(1, 1, n, dfn[u], dfn[u] + siz[u] - 1, val);\n}\n```\n\n\n\n## CODE (luogu P3384)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\nvoid write(ll x) {\n    if(x < 0) {\n        putchar('-');\n        x = -x;\n    } \n    if(x > 9) write(x / 10);\n    putchar(x % 10 + '0');\n}\nll read(){\n    ll ret = 0, f = 1; char c = getchar();\n    for(; !isdigit(c); c = getchar()) if('-'==c) f = -1;\n    for(; isdigit(c); c = getchar()) ret = ret*10 + c - '0';\n    return ret * f;\n}\n#define nl puts(\"\")\n#define bs putchar(' ')\nconst int _maxn = 150005;\nint dep[_maxn], siz[_maxn], fa[_maxn], mxson[_maxn];\nint dfn[_maxn], top[_maxn];\nint n, m, r, p;\nint a[_maxn];\nint h[_maxn], nxt[_maxn*2], ev[_maxn*2], cnte;\nvoid adde(int u, int v){\n    cnte++;\n    ev[cnte] = v;\n    nxt[cnte] = h[u];\n    h[u] = cnte;\n}\nvoid dfs1(int u, int faa){\n    dep[u] = dep[faa] + 1;\n    siz[u] = 1;\n    fa[u] = faa;\n    int mxsiz = 0;\n    for(int e = h[u]; e; e = nxt[e]){\n        int v = ev[e];\n        if(v == faa) continue;\n        dfs1(v, u);\n        if(mxsiz < siz[v]) {\n            mxson[u] = v;\n            mxsiz = siz[v];\n        } \n        siz[u] += siz[v];\n    }\n}\nint timestamp = 0;\nvoid dfs2(int u, int topf){\n    dfn[u] = ++timestamp;\n    top[u] = topf;\n    if(mxson[u] == 0) return; //VERY IMPORTANT!!!!\n    dfs2(mxson[u], topf);\n    for(int e = h[u]; e; e = nxt[e]){\n        int v = ev[e];\n        if(v != fa[u] && v != mxson[u]) dfs2(v, v);\n    }\n}\n\n//segtree\n#define il inline\n    ll sum[_maxn*4], tag[_maxn*4];\n    il int ls(int o) {return o*2;}\n    il int rs(int o) {return o*2+1;}\n    void upd(ll &x, ll y) {\n        x = (p+x+y) % p;\n    }\n    void _op(int o, int l, int r, int x){\n        upd(tag[o], x);\n        upd(sum[o], (ll)(r-l+1) * x % p);\n    }\n    il void pushdown(int o, int l, int r) {\n        if(tag[o] == 0) return;\n        int mid = (l+r)>>1;\n        _op(ls(o), l, mid, tag[o]);\n        _op(rs(o), mid+1, r, tag[o]);\n        tag[o] = 0;\n    }\n    void update(int o, int l, int r, int ql, int qr, int v) {\n        pushdown(o, l, r);\n        if(ql <= l && r <= qr) {\n            upd(tag[o], v);\n            upd(sum[o], (ll)(r-l+1)*v%p);\n            return;\n        }\n        int mid = (l+r)>>1;\n        if(ql <= mid) update(ls(o), l, mid, ql, qr, v);\n        if(mid < qr) update(rs(o), mid+1, r, ql, qr, v);\n        sum[o] = (sum[ls(o)] + sum[rs(o)]) % p;\n    }\n    ll query(int o, int l, int r, int ql, int qr) {\n        pushdown(o, l, r);\n        if(ql <= l && r <= qr) {\n            return sum[o];\n        }\n        int mid = (l+r)>>1;\n        ll ret = 0;\n        if(ql <= mid) upd(ret, query(ls(o), l, mid, ql, qr) );\n        if(mid < qr) upd(ret, query(rs(o), mid+1, r, ql, qr) );\n        return ret;\n    }\n//segtree ends here.\n\n//\u4e0b\u9762\u4e00\u53e5\u8bdd\u975e\u5e38\u91cd\u8981\uff01\uff01\n#define swapdep(u, v) if(dep[top[u]] < dep[top[v]]) swap(u, v) //u\u6240\u5728\u94fe\u66f4\u6df1\nint qchain(int u, int v) {\n    ll ret = 0;\n    while(top[u] != top[v]) {\n        swapdep(u, v);\n        upd(ret, query(1, 1, n, dfn[top[u]], dfn[u]) );\n        u = fa[top[u]];\n    }\n    if(dep[u] < dep[v]) swap(u, v);\n    upd(ret, query(1, 1, n, dfn[v], dfn[u]) );\n    return ret;\n}\nvoid updchain(int u, int v, int val) {\n    while(top[u] != top[v]) {\n        swapdep(u, v);\n        update(1, 1, n, dfn[top[u]], dfn[u], val);\n        u = fa[top[u]];\n    }\n    if(dep[u] < dep[v]) swap(u, v);\n    update(1, 1, n, dfn[v], dfn[u], val);\n}\nint qsub(int u){\n    return query(1, 1, n, dfn[u], dfn[u] + siz[u] - 1);\n}\nvoid updsub(int u, int val){\n    update(1, 1, n, dfn[u], dfn[u] + siz[u] - 1, val);\n}\nsigned main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\".in\",\"r\",stdin);\n    freopen(\".out\", \"w\", stdout);\n    #endif\n    n = read(), m = read(), r = read(), p = read();\n    for(int i = 1; i <= n; i++) {\n        a[i] = read();\n    }\n    for(int i = 1; i < n; i++) {\n        int u = read(), v= read();\n        adde(u, v); adde(v, u);\n    }\n\n    dfs1(r, 0);\n    dfs2(r, r);\n// for(int i = 1; i <= n; i++) {\n//     printf(\"%d mxs=%d fa=%d siz=%d dfn=%d top=%d\\n\", i, mxson[i], fa[i],siz[i], dfn[i], top[i]);\n// }\n    for(int i = 1; i <= n; i++) {\n        update(1, 1, n, dfn[i], dfn[i], a[i]);\n        assert(top[i] != 0);\n    }\n    while(m--){\n        int cas, x, y, z;\n        cas = read(), x = read();\n        switch(cas){\n            case 1: \n                y = read(), z = read();\n                updchain(x, y, z);\n                break;\n            case 2:\n                y = read();\n                write(qchain(x, y)); nl;\n                break;\n            case 3:\n                z = read();\n                updsub(x, z);\n                break;\n            case 4:\n                write(qsub(x)); nl;\n        }\n    }\n    fclose(stdin), fclose(stdout);\n    return 0;\n}\n```\n\n",
        "postTime": 1573711556,
        "uid": 53000,
        "name": "hacker047",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u5982\u9898\uff0c\u8fd9\u4e2a\u9898\u89e3\u628a\u6811\u94fe\u5256\u5206\u7684\u6a21\u677f\u8fdb\u884c\u4e86\u7ed3\u6784\u4f53\u5c01\u88c5\uff0c\u4e3b\u8981\u76ee\u7684\u662f\u65b9\u4fbf\u505a\u5176\u4ed6\u9898\u76ee\u7684\u65f6\u5019\u76f4\u63a5\u4f7f\u7528\u3002\n\n\u4e0d\u8fc7\uff0c\u65e2\u7136\u5199\u4e86\u9898\u89e3\uff0c\u6211\u8fd8\u662f\u8bf4\u8bf4\u5bf9\u6811\u94fe\u5256\u5206\u7684\u4e00\u4e9b\u7406\u89e3\u3002\n\n\u8ba9\u6211\u4e00\u6b65\u4e00\u6b65\u8bb2\u3002\n\n\u6211\u4eec\u77e5\u9053\u6570\u7ec4\u662f\u4ec0\u4e48\uff1a\u4e00\u4e2a\u8282\u70b9\u542b\u6709\u4e00\u4e2a\u6570\u5b57\uff0c\u8bb8\u591a\u7ed3\u70b9\u7ebf\u6027\u5730\u5217\u6210\u4e00\u6392\u3002\n\n\u5f53\u6211\u4eec\u5bf9\u67d0\u4e00\u6bb5\u5b50\u6570\u7ec4\u7684\u6c42\u548c\u548c\u4fee\u6539\u64cd\u4f5c\u611f\u5174\u8da3\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u60f3\u51fa\u4e86\u7ebf\u6bb5\u6811\u3002\u7ebf\u6bb5\u6811\u867d\u7136\u8bf4\u662f\u4e00\u9897\u6811\uff0c\u4f46\u7ec8\u7a76\u662f\u4e3a\u201c\u7ebf\u6bb5\u201d\u2014\u2014\u7ebf\u6027\u6570\u7ec4\u670d\u52a1\u7684\u3002\n\n\u6709\u4e00\u5929\uff0c\u6240\u6709\u7684\u8282\u70b9\u90fd\u4e0d\u518d\u7ebf\u6027\u5730\u6392\u5217\uff0c\u800c\u6784\u6210\u4e86\u4e00\u9897\u6811\u3002\u5f53\u6211\u4eec\u53c8\u5bf9\u6811\u4e0a\u67d0\u4e9b\u8282\u70b9\u96c6\u5408\u7684\u6c42\u548c\u548c\u4fee\u6539\u611f\u5174\u8da3\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5e0c\u671b\u80fd\u5229\u7528\u5df2\u6709\u7684\u7ecf\u9a8c\uff0c\u6211\u4eec\u5e0c\u671b\u628a\u95ee\u9898\u5316\u5f52\u6210\u4ece\u524d\u7684\u60c5\u5f62\u3002\u662f\u7684\uff0c\u6211\u4eec\u60f3\u628a\u8fd9\u68f5\u6811\u53d8\u6210\u4e00\u6761\u94fe\uff0c\u53d8\u6210\u4e00\u4e2a\u6570\u7ec4\u3002\n\n\u4f3c\u4e4e\u4ec5\u4ec5\u662f\u628a\u6811\u53d8\u6210\u4e00\u4e2a\u6570\u7ec4\u5e76\u4e0d\u662f\u4ec0\u4e48\u56f0\u96be\u7684\u95ee\u9898\u3002\n\n\u5176\u5b9e\u6811\u4e0a\u8282\u70b9\u7684\u6743\u503c\u672c\u6765\u5c31\u50a8\u5b58\u5728\u6570\u7ec4\u91cc\u9762\u3002\u5f53\u904d\u5386\u6211\u4eec\u6240\u9700\u8981\u7684\u8282\u70b9\u96c6\u5408\u7684\u65f6\u5019\uff0c\u628a\u5bf9\u5e94\u7684\u6743\u503c\u4e00\u4e2a\u4e00\u4e2a\u52a0\u8d77\u6765\uff0c\u8fd9\u5c31\u662f\u6700\u7b80\u5355\uff0c\u6700\u66b4\u529b\u7684\u65b9\u6cd5\u3002\u663e\u7136\uff0c\u592a\u6162\u3002\u95ee\u9898\u5728\u4e8e\uff0c\u6211\u4eec\u6ca1\u6709\u5f88\u597d\u5730\u5229\u7528\u6211\u4eec\u5df2\u6709\u7684\u5feb\u901f\u7684\u6570\u636e\u7ed3\u6784\uff1a\u7ebf\u6bb5\u6811\u3002\n\n\u4e3a\u4e86\u5229\u7528\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u9700\u8981\u5c3d\u91cf\u628a\u9700\u8981\u6c42\u548c\u7684\u8282\u70b9\u8fde\u7eed\u5730\u6392\u5728\u4e00\u8d77\u3002\u6240\u4ee5\uff0c\u6211\u4eec\u9700\u8981\u91cd\u65b0\u8003\u8651\u6211\u4eec\u7684\u9700\u6c42\uff0c\u6211\u4eec\u9700\u8981\u8003\u8651\u6211\u4eec\u60f3\u53bb\u6c42\u548c\u548c\u4fee\u6539\u7684\u6811\u4e0a\u8282\u70b9\u7684\u96c6\u5408\u5177\u6709\u4ec0\u4e48\u6837\u7684\u7279\u5f81\u3002\u8bf7\u770b\u9898\u76ee\u8981\u6c42\uff0c\u6709\u4e24\u79cd\u9700\u8981\u7684\u8282\u70b9\u96c6\u5408\uff1a\n\n1. \u4e24\u4e2a\u8282\u70b9u, v\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8282\u70b9\n2. \u67d0\u4e2a\u8282\u70b9u\u7684\u5b50\u6811\n\n\u8bf7\u60f3\u4e00\u4e0b\uff0c\u5982\u679c\u53ea\u6709\u7b2c2\u4e2a\u8981\u6c42\u8be5\u591a\u597d\u554a\u3002\u76f4\u63a5\u5bf9\u6811\u4e0a\u7684\u8282\u70b9\u8fdb\u884c\u6df1\u641c\u6392\u5e8f\u5373\u53ef\u3002\u663e\u7136\uff0c\u6df1\u641c\u6392\u5e8f\u7684\u5e8f\u5217\u4e4b\u4e2d\uff0cu\u5b50\u6811\u4e0a\u8282\u70b9\u7684\u4f4d\u7f6e\u90fd\u8fde\u5728u\u7684\u4f4d\u7f6e\u540e\u9762\u3002\u7ed3\u5408\u7ebf\u6bb5\u6811\u7684\u529f\u80fd\uff0c\u6211\u4eec\u5b8c\u5168\u53ef\u4ee5\u89e3\u51b3\u7b2c2\u4e2a\u9700\u6c42\u3002\n\n\u4f46\u662f\u6211\u4eec\u9700\u8981\u4ed4\u7ec6\u8003\u8651\u9700\u6c421. \n\n\u5982\u679c\u76f4\u63a5\u5229\u7528\u6df1\u641c\u5e8f\uff0c\u7531\u4e8e\u5bf9\u5b50\u8282\u70b9\u904d\u5386\u987a\u5e8f\u7684\u968f\u610f\u6027\uff0c\u5728\u6df1\u641c\u8fc7\u7a0b\u4e2d\u5411\u4e0a\u56de\u6eaf\u7684\u6b21\u6570\u53ef\u80fd\u5f88\u591a\uff0c\u800c\u8fd9\u5c31\u5bfc\u81f4\u5728\u6df1\u641c\u5e8f\u5217\u4e2d\u53ef\u80fd\u4f1a\u6709\u5f88\u591a\u201c\u65ad\u70b9\u201d\uff1a\u67d0\u4e2a\u70b9\u5728\u5e8f\u5217\u4e2d\u7684\u4e0b\u4e00\u4e2a\u70b9\u4e0d\u662f\u5b83\u7684\u5b50\u8282\u70b9\u3002\n\n\u800c\u5982\u679c\u8981\u5b8c\u6210\u9700\u6c421\uff0c\u6211\u4eec\u5f53\u7136\u8981\uff08\u663e\u6027\u6216\u9690\u6027\u5730\uff09\u627e\u5230u\u548cv\u7684LCA\uff0c\u7136\u540e\u5bf9LCA\u5206\u522b\u5230u\u548cv\u7684\u4e24\u6761\u81ea\u9876\u5411\u4e0b\u7684\u94fe\u8fdb\u884c\u6c42\u548c\u3002\u6211\u4eec\u8c08\u8d77\u81ea\u9876\u5411\u4e0b\u7684\u94fe\u7684\u65f6\u5019\u5e94\u8be5\u662f\u9ad8\u5174\u7684\uff0c\u56e0\u4e3a\u6df1\u641c\u5e8f\u786e\u5b9e\u4e5f\u662f\u81ea\u9876\u5411\u4e0b\u4f9d\u6b21\u6392\u5f00\u7684\u3002\u95ee\u9898\u662f\uff0c\u521a\u521a\u8bf4\u4e86\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u592a\u591a\u7684\u65ad\u70b9\uff0c\u90a3\u6837\u4e00\u6765\u6211\u4eec\u9700\u8981\u66f4\u591a\u6b21\u6570\u5bf9\u7ebf\u6bb5\u6811\u8fdb\u884c\u67e5\u8be2\uff0c\u5e76\u4e14\u6bcf\u6b21\u67e5\u8be2\u7684\u533a\u95f4\u957f\u5ea6\u53d8\u5c0f\u3002\u663e\u7136\uff0c\u4e0d\u5212\u7b97\u3002\n\n\u6240\u4ee5\u6211\u4eec\u9700\u8981\u786e\u5b9a\u4e00\u4e2a\u66f4\u52a0\u5408\u7406\u7684\u904d\u5386\u5b50\u8282\u70b9\u7684\u987a\u5e8f\u3002\u5176\u5b9e\u8fd9\u4e2a\u65f6\u5019\u4f1a\u6709\u4e0d\u540c\u7684\u60f3\u6cd5\u3002\u4f60\u53ef\u80fd\u4f1a\u89c9\u5f97\uff0c\u6211\u4eec\u53ef\u4ee5\u4f18\u5148\u904d\u5386\u53f6\u5b50\u6df1\u5ea6\u6700\u5927\u7684\u90a3\u4e2a\u5b50\u8282\u70b9\u3002\u597d\uff0c\u4f46\u4e0d\u591f\u597d\u3002\u6709\u4e00\u4e2a\u66f4\u597d\u7684\u60f3\u6cd5\uff1a\u6bcf\u6b21\u4f18\u5148\u904d\u5386\u5b50\u6811\u5927\u5c0f\u6700\u5927\u7684\u90a3\u4e2a\u5b50\u8282\u70b9\u3002\u6211\u4eec\u73b0\u5728\u53ef\u4ee5\u628a\u8fd9\u4e2a\u5b50\u8282\u70b9\u53eb\u505a\u91cd\u5b50\u8282\u70b9\uff0c\u628a\u5176\u4ed6\u8282\u70b9\u53eb\u505a\u8f7b\u5b50\u8282\u70b9\u3002\n\n\u4e3a\u4ec0\u4e48\u8fd9\u4e2a\u60f3\u6cd5\u66f4\u597d\uff1f\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u8bc1\u660e\uff0c\u50cf\u8fd9\u6837\u4f18\u5148\u9009\u53d6\uff0c\u4ece\u4e00\u4e2a\u70b9\u8d70\u5230\u81ea\u5df1\u7684\u53f6\u5b50\u6700\u591a\u53ea\u9700\u7ecf\u8fc7log\u5b50\u6811\u5927\u5c0f\u7684\u4e2a\u6570\u7684\u94fe\u3002\u8fd9\u662f\u56e0\u4e3a\uff0c\u6700\u574f\u7684\u60c5\u5f62\u662f\uff0c\u6bcf\u4e00\u6b21\u90fd\u8d70\u5230\u4e00\u4e2a\u8f7b\u5b50\u8282\u70b9\u4e0a\u53bb\u3002\u4f46\u662f\uff0c\u8d70\u5230\u8f7b\u5b50\u8282\u70b9\uff0c\u4e5f\u610f\u5473\u7740\u5b50\u6811\u7684\u5927\u5c0f\u81f3\u5c11\u4f1a\u7f29\u5c0f\u4e00\u534a\uff08\u5426\u5219\u8fd9\u68f5\u5b50\u6811\u4e00\u5b9a\u4f1a\u53d8\u6210\u6700\u5927\u7684\u5b50\u6811\uff09\u3002\n\n\u597d\u4e86\u3002\u6211\u4eec\u5df2\u7ecf\u627e\u5230\u4e86\u60f3\u8981\u7684\u628a\u6811\u5256\u5206\u6210\u94fe\u7684\u65b9\u6cd5\u3002\u660e\u767d\u4e86\u8fd9\u4e9b\uff0c\u5b9e\u73b0\u8d77\u6765\u5c31\u4e0d\u518d\u56f0\u96be\u3002\u4e0b\u9762\u6211\u4eec\u9700\u8981\u8dd1\u4e24\u6b21\u6df1\u641c\uff1a\n\n- \u7b2c\u4e00\u6b21\u662f\u5efa\u6811\u7684\u8fc7\u7a0b\uff0c\n  - \u6211\u4eec\u5f53\u7136\u8981\u9996\u5148\u628a\u6bcf\u4e2a\u8282\u70b9\u7684\u7236\u4eb2`fa[N]`\u6807\u51fa\u6765\uff0c\n  - \u4e3a\u4e86\u786e\u5b9a\u91cd\u5b50\u8282\u70b9\u662f\u8c01\uff0c\u9700\u8981\u9996\u5148\u8bb0\u5f55\u6240\u6709\u8282\u70b9\u5b50\u6811\u7684\u5927\u5c0f`siz[N]`\uff0c\n  - \u628a\u91cd\u5b50\u8282\u70b9\u8bb0\u5f55\u5728`hson[N]`\u5185\uff0c\n  - \u518d\u8bb0\u5f55\u4e00\u4e0b\u6bcf\u4e2a\u8282\u70b9\u7684\u6df1\u5ea6`deep[N]`\uff0c\u540e\u9762\u4f1a\u7528\u5f97\u5230\u3002\n- \u7b2c\u4e8c\u6b21\u628a\u987a\u5e8f\u6392\u51fa\u6765\u3002\n  - `dfn[N]`\u5c31\u662f\u6211\u4eec\u7684\u91cd\u5b50\u8282\u70b9\u4f18\u5148\u7684\u6df1\u641c\u5e8f\uff0c\n  - `rnk[N]`\u53ef\u4ee5\u770b\u6210\u662f`dfn[N]`\u7684\u53cd\u51fd\u6570\uff0c\u4e5f\u5c31\u662f\u8bb0\u5f55\u67d0\u4e2a\u8282\u70b9\u88ab\u6392\u5728\u54ea\u4e2a\u4f4d\u7f6e\u4e86\uff0c\n  - \u5728\u6211\u4eec\u7684\u6df1\u641c\u5e8f\u7684\u5e8f\u5217\u91cc\uff0c\u6709\u82e5\u5e72\u6761\u81ea\u9876\u5411\u4e0b\u7684\u94fe\uff08\u6240\u8c13\u7684\u91cd\u94fe\uff09\u3002\u663e\u7136\u6211\u4eec\u7684\u6240\u6709\u64cd\u4f5c\u90fd\u5e94\u8be5\u5728\u67d0\u4e00\u4e2a\u94fe\u4e2d\u8fdb\u884c\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u5f53\u7136\u8981\u8bb0\u5f55\u4e00\u4e0b\u5e8f\u5217\u4e2d\u6bcf\u4e2a\u70b9\u6240\u5728\u7684\u90a3\u4e2a\u94fe\u6761\u662f\u4ece\u8c01\u5f00\u59cb\u7684\u3002\u8fd9\u5c31\u662f`top[N]`\u3002\n\n\u6210\u529f\u628a\u6811\u5256\u5206\u6210\u94fe\uff0c\u5c31\u53ef\u4ee5\u628a\u5b83\u6254\u8fdb\u7ebf\u6bb5\u6811\u4e2d\u4e86\u3002\n\n\u4e0b\u9762\u7684\u95ee\u9898\u662f\u600e\u4e48\u5229\u7528\u7ebf\u6bb5\u6811\u628a\u6211\u4eec\u7684\u95ee\u9898\u89e3\u51b3\u4e86\u3002\n\n\u5148\u8bf4\u521a\u521a\u7684\u7b2c2\u4e2a\u9700\u6c42\u3002\u8fd9\u4f9d\u7136\u662f\u6bd4\u8f83\u5bb9\u6613\u7684\u3002\u50cf\u521a\u521a\u8bf4\u7684\uff0c\u5982\u679c\u8981\u5bf9u\u7684\u5b50\u6811\u4e0a\u6240\u6709\u8282\u70b9\u8fdb\u884c\u67e5\u8be2\u548c\u4fee\u6539\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u4e9b\u8282\u70b9\u5728\u5bf9\u5e94\u7684\u6df1\u641c\u5e8f\u5217\u4e2d\u662f\u4ee5u\u4e3a\u9996\u9879\u7684\uff0c\u9879\u6570\u662f`siz[u]`\u7684\u4e00\u4e2a\u5b50\u5e8f\u5217\uff0c\u6240\u4ee5\u53ef\u4ee5\u5f88\u65b9\u4fbf\u5730\u8c03\u7528\u7ebf\u6bb5\u6811\u7684\u529f\u80fd\u4e86\u3002\n\n\u518d\u8003\u8651\u7b2c1\u4e2a\u9700\u6c42\u3002\u521a\u521a\u6211\u4eec\u4e5f\u63d0\u53ca\u4e86\u89e3\u51b3\u5b83\u7684\u601d\u8def\u3002\u6211\u4eec\u5bfb\u627eu\u548cv\u7684LCA\u7684\u8fc7\u7a0b\uff0c\u5176\u5b9e\u4e5f\u5c31\u662f\u8ba9u\u6216\u8005v\u5411\u4e0a\u8df3\u8dc3\uff0c\u6700\u540e\u4f1a\u548c\u7684\u8fc7\u7a0b\u3002\n\n\u6709\u4e00\u79cd\u5f88\u7b80\u5355\u7684\u60c5\u5f62\uff0c\u6211\u4eec\u53d1\u73b0`top[u] == top[v]`\uff0c\u8fd9\u5c31\u8868\u660eu\u548cv\u5728\u540c\u4e00\u6bb5\u94fe\u4e2d\uff0c\u90a3\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u6c42\u548c\u6216\u4fee\u6539\u4e86\u3002\n\n\u4f46\u4e8b\u60c5\u4e0d\u4f1a\u603b\u662f\u8fd9\u4e48\u51d1\u5de7\uff0c\u4e5f\u8bb8u\u6216\u8005v\u9700\u8981\u5148\u5404\u81ea\u8fdb\u884c\u51e0\u6b21\u8df3\u8dc3\uff0c\u624d\u80fd\u51fa\u73b0\u4e0a\u9762\u7684\u8fd9\u79cd\u60c5\u51b5\uff08\u8fd9\u79cd\u60c5\u51b5\u4e00\u5b9a\u4f1a\u51fa\u73b0\uff0c\u56e0\u4e3a\u8fd9\u68f5\u6811\u53ea\u6709\u4e00\u4e2a\u6839\u8282\u70b9\u561b\uff09\u3002\u90a3\u4e48\u5982\u4f55\u5904\u7406\u5404\u81ea\u8fdb\u884c\u7684\u8df3\u8dc3\uff1f\u60f3\u5229\u7528\u6211\u4eec\u5df2\u7ecf\u5b58\u50a8\u7684\u4fe1\u606f\uff0c\u4e5f\u60f3\u6700\u5927\u9650\u5ea6\u5730\u5229\u7528\u7ebf\u6bb5\u6811\u7684\u529f\u80fd\uff0c\u6211\u4eec\u5f53\u7136\u5e0c\u671b\u76f4\u63a5\u7b97\u51fau\u6216\u8005v\u5230\u5b83\u7684`top`\u7684\u8def\u5f84\u4e0a\u7684\u6240\u6709\u548c\uff0c\u7136\u540eu\u6216\u8005v\u8df3\u8dc3\u7684\u65f6\u5019\u76f4\u63a5\u8df3\u5230\u5b83\u7684`top`\u7684\u7236\u4eb2\u7684\u4f4d\u7f6e\u3002\u4f46\u5371\u9669\u7684\u662f\uff0c\u5982\u679c\u67d0\u4e00\u6b21\u4e0d\u614e\u8df3\u5230\u4e86LCA\u4e0a\u9762\u7684\u67d0\u4e2a\u8282\u70b9\uff0c\u7b54\u6848\u5c31\u4f1a\u51fa\u9519\u3002\u5982\u4f55\u907f\u514d\uff1f\u53ef\u4ee5\u6ce8\u610f\u5230\u4e00\u70b9\uff1a`top[u]`\u548c`top[v]`\u4e0d\u53ef\u80fd\u540c\u65f6\u5728LCA\u4e0a\u9762\u3002\u5426\u5219\uff0cu\u6240\u5728\u7684\u90a3\u6761\u94fe\u548cv\u6240\u5728\u7684\u90a3\u6761\u94fe\u5c31\u4f1a\u6709\u91cd\u5408\u7684\u5143\u7d20\uff08LCA\uff09\uff0c\u800c\u8003\u8651\u5230\u6211\u4eec\u6784\u9020\u94fe\u7684\u65b9\u6cd5\uff0c\u8fd9\u662f\u4e0d\u53ef\u80fd\u7684\u3002\u8fd9\u4e5f\u5c31\u662f\u8bf4\uff0c`top[u]`\u548c`top[v]`\u4e2d\u6df1\u5ea6\u8f83\u6df1\u7684\u90a3\u4e2a\uff0c\u4e00\u5b9a\u4e0d\u4f1a\u5728LCA\u7684\u4e0a\u9762\u3002\u660e\u767d\u4e86\u8fd9\u4e9b\uff0c\u5982\u4f55\u8fdb\u884c\u8df3\u8dc3\u5c31\u5341\u5206\u660e\u4e86\u4e86\uff1a\u6bcf\u6b21\u9009\u62e9`deep[top[u/v]]`\u8f83\u5927\u7684\u90a3\u4e2a\uff0c\u8df3\u8dc3\u5230`fa[top[u/v]]`\u5904\u5373\u53ef\u3002\n\n\u5269\u4e0b\u7684\uff0c\u5c31\u662f\u5177\u4f53\u5b9e\u73b0\u7684\u4e00\u4e9b\u5904\u7406\u4e86\u3002\u8bf7\u770b\u4ee3\u7801\uff1a\n\n\n```cpp\n#include<bits/stdc++.h>\n#define N 112345\nusing namespace std;\ninline int read(){int x=0; int sign=1; register char c=getchar();while(c>'9'||c<'0'){if(c=='-')sign=-1; c=getchar();}while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0'; c=getchar();}return x*sign;}\nlong long P; int n, m, r;\n\nstruct TREE{\n    vector<int> g[N]; int wght[N];\n    int fa[N], deep[N], siz[N], hson[N];\n    int top[N], dfn[N], rnk[N], tot;\n\n    void ini(){\n        for(int i = 1; i <= n; i++) wght[i] = read();\n        for(int i = 1; i <= n-1; i++){\n            int a = read(), b = read();\n            g[a].push_back(b); \n            g[b].push_back(a);\n        }\n    }\n\n    void build_tree(int u, int dep){\n        siz[u] = 1;\n        deep[u] = dep;\n        for(unsigned int i = 0; i < g[u].size(); ++i){\n            int v = g[u][i];\n            if (v == fa[u]) continue;\n            fa[v] = u;\n            build_tree(v, dep + 1);\n            siz[u] += siz[v];\n            if (siz[v] > siz[hson[u]]) hson[u] = v;\n        }\n    }\n\n    void tree_decom(int u, int t){\n        top[u] = t;\n        dfn[u] = ++tot; \n        rnk[tot] = u; \n        if (hson[u]){\n            tree_decom(hson[u], t);\n            for(unsigned int i = 0; i < g[u].size(); i++){\n                int v = g[u][i];\n                if (v == fa[u] || v == hson[u]) continue;\n                tree_decom(v, v);\n            }\n        }\n    }\n};\n\nstruct NODE{\n    int l, r; long long sum, add;\n};\n\n\nstruct SEGTREE{\n    NODE SegTree[N << 2];\n    long long a[N];\n\n    #define lft(u) SegTree[u].l\n    #define rgt(u) SegTree[u].r\n    #define len(u) (rgt(u)-lft(u)+1)\n    #define sum(p) SegTree[p].sum\n    #define add(p) SegTree[p].add\n    #define mid(p) ((lft(p)+rgt(p))>>1)\n    #define lson(p) (p<<1)\n    #define rson(p) (p<<1|1)\n\n    void build(int u, int l, int r){\n        lft(u) = l; rgt(u) = r; add(u) = 0;\n        if (l == r){\n            sum(u) = a[l];\n        } else {\n            build(lson(u), l, mid(u));\n            build(rson(u), mid(u)+1, r);\n            sum(u) = sum(lson(u)) + sum(rson(u));\n            sum(u) %= P;\n        }\n    }\n\n    void spread(int u){\n        if (!add(u)) return;\n        sum(lson(u)) += add(u) * len(lson(u)); sum(lson(u)) %= P;\n        sum(rson(u)) += add(u) * len(rson(u)); sum(rson(u)) %= P;\n        add(lson(u)) += add(u); add(lson(u)) %= P;\n        add(rson(u)) += add(u); add(rson(u)) %= P;\n        add(u) = 0;\n    }\n\n    void change(int u, int l, int r, long long d){\n        if (l <= lft(u) && rgt(u) <= r) {\n            sum(u) += d * len(u); sum(u) %= P;\n            add(u) += d; add(u) %= P;\n        } else {\n            spread(u);\n            if (l <= mid(u)) change(lson(u), l, r, d);\n            if (mid(u) + 1 <= r) change(rson(u), l, r, d);\n            sum(u) = sum(rson(u)) + sum(lson(u)); sum(u) %= P;\n        }\n    }\n\n    long long query(int u, int l, int r){\n        if (l <= lft(u) && rgt(u) <= r){\n            return sum(u) % P;\n        } else {\n            spread(u);\n            long long ans = 0;\n            if (l <= mid(u)) {ans += query(lson(u), l, r); ans %= P;}\n            if (mid(u) + 1 <= r) {ans += query(rson(u), l, r); ans %= P;}\n            return ans % P;\n        }\n    }\n};\n\nstruct TREECHAIN{\n    SEGTREE Sgt;\n    TREE Tree;\n\n    #define fa(u) Tree.fa[u]\n    #define deep(u) Tree.deep[u]\n    #define top(u) Tree.top[u]\n    #define dfn(u) Tree.dfn[u]\n    #define rnk(u) Tree.rnk[u]\n    #define btm(u) (Tree.dfn[u]+Tree.siz[u]-1)\n    #define wght(u) Tree.wght[u]\n    #define rnk(u) Tree.rnk[u]\n\n    void ini(){\n        Tree.ini();\n        Tree.build_tree(r, 1);\n        Tree.tree_decom(r, r);\n        for(int i = 1; i <= n; i++){\n            Sgt.a[i] = wght(rnk(i)) % P;\n        }\n        Sgt.build(1, 1, n);\n    }\n\n    void tree_path_change(int u, int v, long long d){\n        while(top(u) != top(v)){\n            if (deep(top(u)) < deep(top(v))) swap(u, v);\n            Sgt.change(1, dfn(top(u)), dfn(u), d);\n            u = fa(top(u));\n        }\n        if (dfn(u) > dfn(v)) swap(u, v);\n        Sgt.change(1, dfn(u), dfn(v), d);\n    }\n\n    long long tree_path_sum(int u, int v){\n        long long tot = 0;\n        while(top(u) !=  top(v)){\n            if (deep(top(u)) < deep(top(v))) swap(u, v);\n            tot += Sgt.query(1, dfn(top(u)), dfn(u)); tot %= P;\n            u = fa(top(u));\n        }\n        if (dfn(u) > dfn(v)) swap(u, v);\n        tot += Sgt.query(1, dfn(u), dfn(v)); tot %= P;\n        return tot;\n    }\n\n    void subtree_change(int u, long long d){\n        Sgt.change(1, dfn(u), btm(u), d);\n    }\n\n    long long subtree_sum(int u){\n        return Sgt.query(1, dfn(u), btm(u));\n    }\n\n    void work(){\n        while(m--){\n            int mode = read();\n\n            if (mode == 1){\n                int u = read(), v = read(); long long d = read();\n                tree_path_change(u, v, d);\n            }\n            \n            if (mode == 2){\n                int u = read(), v = read();\n                printf(\"%lld\\n\", tree_path_sum(u, v));\n            }\n\n            if (mode == 3){\n                int u = read(); long long d = read();\n                subtree_change(u, d);\n            }\n\n            if (mode == 4){\n                int u = read();\n                printf(\"%lld\\n\", subtree_sum(u));\n            }\n        }\n    }\n}Tc;\n\n\nint main(){\n    n = read(), m = read(), r = read(), P = read();\n    Tc.ini();\n    Tc.work();\n}\n```",
        "postTime": 1573553754,
        "uid": 81690,
        "name": "EricWay1024",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011\u7ed3\u6784\u4f53\u5c01\u88c5"
    },
    {
        "content": "[\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c\u548c\u4f8b\u9898\u8bf7\u524d\u5f80\u535a\u5ba2](https://listening-post-1379.blog.luogu.org/post-suan-fa-bi-ji-shu-lian-pou-fen)\n\n# P3384 \u9898\u89e3\n\n---\n\n*\u5f3a\u70c8\u5efa\u8bae\u5728\u9605\u8bfb\u672c\u6587\u4e4b\u524d\u5df2\u7ecf\u638c\u63e1\u524d\u7f6e\u77e5\u8bc6 **\u7ebf\u6bb5\u6811**\uff0c\u5982\u679c\u4f60\u6ca1\u6709\uff0c\u8bf7\u5148\u9605\u8bfb[\u8fd9\u7bc7\u6587\u7ae0](https://listening-post-1379.blog.luogu.org/post-shuo-ju-jie-gou-xian-duan-shu)*\n\n*\u4e0d\u77e5\u9053\u6811\u662f\u4ec0\u4e48\u7684\uff0c\u8bf7\u524d\u5f80[\u641c\u72d7\u767e\u79d1-\u6811](https://baike.sogou.com/v101597958.htm?fromTitle=\u6811)*\n\n\u6811\u94fe\u5256\u5206\uff0c\u53c8\u540d\u8f7b\u91cd\u8def\u5f84\u5256\u5206\u3001\u6811\u5256\uff0c\u662f\u4e00\u79cd ~~\u770b\u8d77\u6765\u5341\u5206\u9ad8\u5927\u4e0a\u5b9e\u9645\u5f88\u6c34\u7684\u80fd\u8ba9\u4f60\u4ee3\u7801\u5f3a\u884c\u589e\u52a0180\u884c\u7684\u4e0d\u90a3\u4e48\u5bb9\u6613\u7206\u70b8(\u5e76\u4e0d)\u7684~~\u7b97\u6cd5\uff0c\u672c\u8d28\u4e0a\u662f\u5c06\u6811\u8f6c\u5316\u4e3a\u4e00\u7cfb\u5217**\u91cd\u94fe**\u548c**\u8f7b\u8fb9**\uff08\u8fd9\u4e24\u4e2a\u4e1c\u897f\u7684\u5b9a\u4e49\u540e\u8fb9\u4f1a\u8bb2\uff09\uff0c\u7136\u540e\u7528**\u7ebf\u6bb5\u6811**\uff08\u6216\u4e00\u5207\u652f\u6301**\u533a\u95f4\u4fee\u6539\u548c\u67e5\u8be2**\u64cd\u4f5c\u7684\u6570\u636e\u7ed3\u6784\uff0c\u4f46\u5176\u4e2d\u7ebf\u6bb5\u6811\u80fd\u7ef4\u62a4\u7684\u4fe1\u606f\u6700\u5e7f\u6cdb\uff09\u8fdb\u884c\u5b58\u50a8\u3002\n\n\u6811\u94fe\u5256\u5206\u5341\u5206\u5b9e\u7528\uff08\u524d\u63d0\u662f\u4f60\u7ebf\u6bb5\u6811\u5199\u7684\u5f88\u719f\u7ec3\uff0c\u4e0d\u7136**\u6ee1\u5c4fRE**\u3002\u3002\u3002\uff09\uff0c\u80fd\u5c06\u590d\u6742\u7684\u6811\u4e0a\u7ef4\u62a4\u8f6c\u5316\u4e3a~~\u7b80\u5355~~\u76f8\u5bf9\u4e0d\u90a3\u4e48\u590d\u6742\u7684\u533a\u95f4\u7ef4\u62a4\u3002\n\n\u6811\u94fe\u5256\u5206\u7684\u4f5c\u7528\u6709\uff1a\n- ~~\u8bc1\u660e\u51fa\u9898\u4eba\u662f\u4e2a\u6bd2\u7624~~\n- \u4fee\u6539\u9759\u6001\u6811\u4e0a\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u6743\uff08\u8fb9\u6743\u53ef\u4ee5\u8fb9\u8f6c\u70b9\u89e3\u51b3\uff09\n- \u67e5\u8be2\u9759\u6001\u6811\u4e0a\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\u53ca\u6700\u503c\uff08\u6216\u4efb\u4f55\u4f60\u53ef\u4ee5\u60f3\u5230\u7684\u6ee1\u8db3\u533a\u95f4\u53ef\u52a0\u6027\u7684\u4fe1\u606f\uff09\n- \u4fee\u6539\u4e00\u4e2a\u70b9\u53ca\u5176\u5b50\u6811\u4e0a\u7684\u6240\u6709\u70b9\u6743\n- \u67e5\u8be2\u4e00\u4e2a\u70b9\u53ca\u5176\u5b50\u6811\u4e0a\u7684\u6240\u6709\u70b9\u6743\u548c\u53ca\u6700\u503c\uff08\u5176\u4ed6\u4fe1\u606f\u540c\u4e0a\uff09\n\n\u6811\u5256\u4e5f\u80fd\u89e3\u51b3\uff0c\u4f46\u4e00\u822c\u4e0d\u7528\u6811\u5256\u89e3\u51b3\u7684\u95ee\u9898\u6709\uff1a\n- \u6c42LCA\uff0860\u884c\u548c180\u884c\u4f60\u9009\u54ea\u4e2a\uff09\n- \u53ea\u7ef4\u62a4\u6811\u4e0a\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u6743\uff08\u6811\u4e0a\u5dee\u5206\u5c31\u53ef\u4ee5\uff09\n- \u53ea\u67e5\u8be2\u6811\u4e0a\u4e24\u70b9\u95f4\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\uff08\u4f9d\u7136\u662f\u6811\u4e0a\u5dee\u5206\uff09\n\n\u5b9e\u9645\u4e0a\uff0c\u6811\u5256\u548c\u6811\u4e0a\u5dee\u5206\u7684\u533a\u522b\u662f\u6811\u4e0a\u5dee\u5206**\u53ea\u80fd\u7ef4\u62a4\u548c**\uff0c\u800c\u6811\u5256\u53ef\u4ee5\u7ef4\u62a4**\u591a\u79cd\u4fe1\u606f**\u3002\n\n---\n\n## \u601d\u8def\n\u9996\u5148\u7ed9\u51fa\u51e0\u4e2a\u5b9a\u4e49\uff1a\n> - \u91cd\u513f\u5b50\uff1a\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u8282\u70b9\u6570\u6700\u591a\u7684\u5b50\u6811\u7684\u6839\uff08\u5982\u679c\u6709\u591a\u4e2a\u53ef\u4ee5\u53d6\u4efb\u610f\u4e00\u4e2a\uff09\n> - \u91cd\u94fe\uff1a\u7531\u91cd\u513f\u5b50\u8fde\u63a5\u5f62\u6210\u7684\u94fe\n> - \u8f7b\u8fb9\uff1a\u6811\u4e2d\u4e0d\u5c5e\u4e8e\u91cd\u94fe\u7684\u5176\u4ed6\u8fb9\n\n\u6811\u94fe\u5256\u5206\u793a\u610f\uff0c\u5176\u4e2d\u70b9\u4e0a\u7684\u6570\u662f\u7f16\u53f7\uff0c\u52a0\u7c97\u7684\u8fb9\u4e3a\u91cd\u8fb9\uff1a\n\n![5c24d0664c185.png](https://i.loli.net/2019/08/28/GrlkpRO7yzvbZAj.png)\n\n\u4e0a\u9762\u7684\u56fe\u4e2d\uff0c\u70b91,2,3,4,5,6\u6784\u6210\u4e00\u6761\u91cd\u94fe\uff0c\u70b97\uff0c8,9,11,13\u6784\u6210\u4e00\u6761\u91cd\u94fe\uff0c\u70b912\u300114\u5206\u522b\u6784\u6210\u4e24\u6761\u957f\u5ea6\u4e3a1\u7684\u91cd\u94fe\uff08\u81ea\u5df1\uff09\n\n\u6811\u94fe\u5256\u5206\u7684\u6027\u8d28\uff1a\n- \u6811\u4e0a\u7684\u6240\u6709\u70b9\u5c5e\u4e8e\u4e14\u4ec5\u5c5e\u4e8e\u4e00\u6761\u91cd\u8def\u5f84\n- \u8bbesize[x]\u4e3ax\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u5219\u5982\u679c(u,v)\u4e3a\u8f7b\u8fb9\uff0csize[u]<=size[u]/2(\u56e0\u4e3au\u5df2\u7ecf\u6709\u4e00\u4e2a\u91cd\u513f\u5b50\uff0c\u800c\u5982\u679cv\u7684\u5b50\u6811\u5927\u5c0f\u8d85\u8fc7u\u7684\u4e00\u534a\uff0c\u5219v\u5e94\u8be5\u662f\u91cd\u513f\u5b50)\n- \u56e0\u6b64\uff0c\u5bf9\u4e8e\u4efb\u4f55\u975e\u6839\u8282\u70b9u\uff0c\u5728u\u5230\u6839\u7684\u8def\u5f84\u4e0a\uff0c\u8f7b\u8fb9\u548c\u91cd\u94fe\u6700\u591a\u6709 $logn$\u6761\n\n---\n\n## \u5b9e\u73b0\n### \u9884\u5904\u7406\n\u4e3a\u4e86\u9884\u5904\u7406\u6811\u5256\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u8ba1\u7b97\u5982\u4e0b\u51e0\u4e2a\u503c\uff1a\n```\n\n\u5bf9\u6811\u4e2d\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9x\nfather[x]:x\u5728\u6811\u4e2d\u7684\u7236\u4eb2\ndep[x]:x\u7684\u6df1\u5ea6\nsize[x]:x\u7684\u5b50\u6811\u8282\u70b9\u6570\nhson[x]:x\u7684\u91cd\u513f\u5b50\ntop[x]:x\u6240\u5728\u91cd\u94fe\u7684\u9876\u90e8\u8282\u70b9\uff08\u6df1\u5ea6\u6700\u5c0f\uff09\nseg[x]:x\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u4f4d\u7f6e\uff08\u4e0b\u6807\uff09\nrev[x]:\u7ebf\u6bb5\u6811\u4e2d\u7b2cx\u4e2a\u4f4d\u7f6e\u5bf9\u5e94\u7684\u8282\u70b9\u7f16\u53f7\n\n```\n\u6211\u4eec\u9700\u8981\u4e24\u904ddfs\u6765\u8ba1\u7b97\u8fd9\u4e9b\u503c\uff0c\u7b2c\u4e00\u6b21DFS\u53ef\u4ee5\u8ba1\u7b97\u524d\u56db\u4e2a\u503c\uff0c\u7b2c\u4e8c\u6b21DFS\u53ef\u4ee5\u8ba1\u7b97\u540e\u4e09\u4e2a\u503c\u3002\u9884\u5904\u7406\u4ee3\u7801\uff1a\n```cpp\n\nvoid dfs1(int u,int f) {\n  size[u]=1; //\u5b50\u6811\u5927\u5c0f\u9ed8\u8ba4\u4e3a1\n  dep[u]=dep[f]+1; //\u6df1\u5ea6\n  father[u]=f; //\u8bb0\u5f55\u7236\u4eb2\n  for(int i=0;i<e[u].size();i++)\n  {\n    int v=e[u][i]; //\u4f7f\u7528vector\u5b58\u56fe\n    if(v!=f)//\u6392\u9664\u7236\u4eb2\n    {\n      dfs1(v,u);\n      size[u]+=size[v]; //\u7d2f\u52a0\u5b50\u6811\u5927\u5c0f\n      if(size[v]>size[hson[u]]) hson[u]=v; //\u5982\u679cv\u7684\u5b50\u6811\u5927\u5c0f\u6bd4\u5f53\u524d\u91cd\u513f\u5b50\u7684\u5927\u5c0f\u5927\u90a3\u4e48\u66f4\u65b0\u91cd\u513f\u5b50\n    }\n  }\n}\n\nvoid dfs2(int u,int f) {\n  if(hson[u]) //\u5148\u8d70\u91cd\u513f\u5b50\uff0c\u4f7f\u91cd\u513f\u5b50\u5728\u7ebf\u6bb5\u6811\u4e2d\u7684\u5e8f\u53f7\u8fde\u7eed,\u8fd9\u6837\u624d\u80fd\u7528\u533a\u95f4\u64cd\u4f5c\u7ef4\u62a4\u91cd\u94fe\u4fe1\u606f\n  {\n    seg[hson[u]]=++tot;//\u63d2\u5165\u70b9\n    top[hson[u]]=top[u];//u\u548c\u91cd\u513f\u5b50\u540c\u5c5e\u4e8e\u4e00\u6761\u91cd\u94fe\n    rev[tot]=hson[u]; //\u6b64\u65f6tot\u4e3a\u5f53\u524d\u70b9\n    dfs2(hson[u],u);\n    for(int i=0;i<e[u].size();i++)\n    {\n      int v=e[u][i];\n      if(v!=f && v!=hson[u]) //\u6392\u9664\u7236\u4eb2\u4e5f\u4e0d\u662f\u91cd\u513f\u5b50\n      {\n        seg[v]=++tot;\n        top[v]=v; //\u8f7b\u513f\u5b50\u4e00\u5b9a\u662f\u91cd\u94fe\u7684\u9876\u90e8\u8282\u70b9\n        rev[tot]=v;\n        dfs2(v,u);\n      }\n    }\n  }\n}\n\nint main() //\u4e3b\u51fd\u6570\n{\n  /*other codes*/\n  dfs1(root,0);\n  seg[root]=tot=1;\n  rev[1]=top[root]=root;\n  dfs2(root,0)\n  build(1,1,n);\n  /*other codes*/\n}\n\n```\n### \u64cd\u4f5c\n#### 1.\u8def\u5f84\u67e5\u8be2\n\u7ed9\u5b9a\u4e24\u4e2a\u70b9x,y\uff0c\u7edf\u8ba1x\u5230y\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u4fe1\u606f\uff1a\n\n- \u5982\u679cx\u3001y\u5c5e\u4e8e\u4e00\u6761\u91cd\u94fe\uff08\u5373top[x] $=$ top[y]\uff09\uff0c\u90a3\u4e48\u76f4\u63a5\u8fdb\u884c\u4e00\u6b21\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u67e5\u8be2\u5373\u53ef\n- \u5982\u679cx\u3001y\u5c5e\u4e8e\u4e24\u6761\u91cd\u94fe\uff08\u5373top[x] $\\ne$ top[y]\uff09\uff0c\u90a3\u4e48\u4e00\u5b9a\u662f\u7531x\u8d70\u5230 $LCA(x,y)$ \u518d\u8d70\u5230y\uff0c\u6b64\u65f6\n  - \u9996\u5148\u627e\u5230top\u6df1\u5ea6\u8f83\u5927\u7684\u70b9\uff08\u56e0\u4e3aLCA\u4e00\u5b9a\u4e0d\u53ef\u80fd\u5728\u9876\u90e8\u8282\u70b9\u6df1\u5ea6\u8f83\u5927\u7684\u91cd\u94fe\u4e0a\uff09\n  - \u5047\u8bbe\u8fd9\u4e2a\u70b9\u662fx\uff0c\u90a3x\u53ef\u4ee5\u76f4\u63a5\u8df3\u5230father[top[x]],\u5e76\u5728\u7ebf\u6bb5\u6811\u4e0a\u7edf\u8ba1[seg[x]~seg[top[x]]]\u7684\u4fe1\u606f\uff08\u8fd9\u4f1a\u4f7fx\u8df3\u5230\u4e00\u6761\u79bb\u6839\u66f4\u8fd1\u7684\u91cd\u94fe\u4e0a\uff09\n  - \u91cd\u590d\u4e0a\u9762\u7684\u64cd\u4f5c\u76f4\u5230top[x] $=$ top[y]\uff0c\u6b64\u65f6\u7528\u4e00\u6b21\u533a\u95f4\u67e5\u8be2\u7edf\u8ba1[x~y]\u7684\u4fe1\u606f\n\n\u4ee3\u7801(\u4ee5\u7edf\u8ba1\u548c\u4e3a\u4f8b)\uff1a\n```cpp\n\nint qrange(int x,int y)\n{\n  int ans=0;\n  while(top[x]!=top[y]) { //\u5f53x\u3001y\u5c5e\u4e8e\u4e24\u6761\u91cd\u94fe\n    if(dep[top[x]]<dep[top[y]]) //\u627e\u5230top\u6df1\u5ea6\u8f83\u5927\u7684\u70b9 swap(x,y);\n    ans+=query(1,seg[top[x]],seg[x]); //\u533a\u95f4\u67e5\u8be2\uff0c\u7edf\u8ba1[seg[x]~seg[top[x]]]\u7684\u4fe1\u606f\n    x=father[top[x]];\n  }\n  if(dep[x]>dep[y]) swap(x,y);\n  ans+=query(1,seg[x],seg[y]);//\u7edf\u8ba1[x~y]\u7684\u4fe1\u606f\n  return ans;\n}\n\n```\n\n#### 2.\u8def\u5f84\u4fee\u6539\n\u7ed9\u5b9a\u4e24\u4e2a\u70b9x,y\uff0c\u66f4\u65b0x\u5230y\u6700\u77ed\u8def\u5f84\u4e0a\u7684\u4fe1\u606f\uff1a\n\n\u65b9\u6cd5\u540c\u4e0a\uff0c\u53ea\u4e0d\u8fc7\u5c06\u533a\u95f4\u67e5\u8be2\u6362\u6210\u533a\u95f4\u4fee\u6539\u3002\n\u4ee3\u7801\uff1a\n```cpp\n\nvoid crange(int x,int y,int k)\n{\n  while(top[x]!=top[y]) { //\u5f53x\u3001y\u5c5e\u4e8e\u4e24\u6761\u91cd\u94fe\n    if(dep[top[x]]<dep[top[y]]) //\u627e\u5230top\u6df1\u5ea6\u8f83\u5927\u7684\u70b9 swap(x,y);\n    update(1,seg[top[x]],seg[x],k); //\u66f4\u65b0[seg[x]~seg[top[x]]]\u7684\u4fe1\u606f\n    x=father[top[x]];\n  }\n  if(dep[x]>dep[y]) swap(x,y);\n  update(1,seg[x],seg[y],k);//\u66f4\u65b0[x~y]\u7684\u4fe1\u606f\n}\n\n```\n#### 3.\u5b50\u6811\u67e5\u8be2\n\u7edf\u8ba1x\u53ca\u5176\u5b50\u6811\u4e0a\u7684\u4fe1\u606f\uff1a\n\n\u8fd9\u4e2a\u66f4\u7b80\u5355\u4e86\uff0c\u7531\u4e8ex\u7684\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u662f\u8fde\u7eed\u7684\uff0c\u540c\u65f6size[x]\u53c8\u50a8\u5b58\u4e86x\u7684\u5b50\u6811\u5927\u5c0f\uff0c\u56e0\u6b64\u76f4\u63a5\u7528\u4e00\u6b21\u533a\u95f4\u67e5\u8be2\u7edf\u8ba1[x~x+size[x]-1]\u4e0a\u7684\u4fe1\u606f\u5373\u53ef\n\n\u4ee3\u7801\uff1a\n```cpp\n\nint qson(int x)\n{\n  return query(1,seg[x],seg[x]+size[x]-1);\n}\n\n```\n#### 3.\u5b50\u6811\u4fee\u6539\n\u66f4\u65b0x\u53ca\u5176\u5b50\u6811\u4e0a\u7684\u4fe1\u606f\uff1a\n\n\u65b9\u6cd5\u540c\u4e0a\uff0c\u53ea\u4e0d\u8fc7\u5c06\u533a\u95f4\u67e5\u8be2\u6362\u6210\u533a\u95f4\u4fee\u6539\u3002\n\u4ee3\u7801\uff1a\n```cpp\n\nvoid cson(int x,int k)\n{\n  update(1,seg[x],seg[x]+size[x]-1,k);\n}\n\n```\n\n---\n\n## AC\u4ee3\u7801\uff1a\n\uff08\u64cd\u4f5c\u90fd\u5199\u5728\u524d\u9762\uff0c\u552f\u4e00\u8981\u52a0\u4e0a\u7684\u5c31\u662f\u53d6\u6a21\uff09\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconst int maxn=100005;\nint n,m,r,mod;\nvector<int> e[maxn];\nint father[maxn],dep[maxn],size[maxn],hson[maxn],top[maxn],seg[maxn],rev[maxn<<2],num[maxn],tot;\nstruct segmenttree{\n    int l,r,sum,add;\n    #define l(x) tree[x].l\n    #define r(x) tree[x].r\n    #define sum(x) tree[x].sum\n    #define add(x) tree[x].add\n};\nsegmenttree tree[maxn<<2];\ninline int read() {\n  int s=0,w=1;\n  char c=getchar();\n  while(c<'0' || c>'9'){\n    if(c=='-') w=-1;\n    c=getchar();\n  }\n  while(c>='0' && c<='9'){\n    s=(s<<3)+(s<<1)+(c^48);\n    c=getchar();\n  }\n  return s*w;\n}\nvoid addedge(int x,int y)\n{\n    e[x].push_back(y);\n    e[y].push_back(x);\n}\nvoid dfs1(int u,int f)\n{\n    size[u]=1;\n    father[u]=f;\n    dep[u]=dep[f]+1;\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(v!=f)\n        {\n            dfs1(v,u);\n            size[u]+=size[v];\n            if(size[v]>size[hson[u]]) hson[u]=v;\n        }\n    }\n}\nvoid dfs2(int u,int f)\n{\n    if(hson[u])\n    {\n        seg[hson[u]]=++tot;\n        top[hson[u]]=top[u];\n        rev[tot]=hson[u];\n        dfs2(hson[u],u);\n    }\n    for(int i=0;i<e[u].size();i++)\n    {\n        int v=e[u][i];\n        if(!top[v])\n        {\n            seg[v]=++tot;\n            rev[tot]=v;\n            top[v]=v;\n            dfs2(v,u);\n        }\n    }\n}\nvoid build(int p,int l,int r)\n{\n    int mid=(l+r)>>1;\n    l(p)=l;r(p)=r;\n    if(l==r){\n        sum(p)=num[rev[l]];\n        return;\n    }\n    build(p<<1,l,mid);\n    build(p<<1|1,mid+1,r);\n    sum(p)=(sum(p<<1)+sum(p<<1|1))%mod;\n    return;\n}\nvoid spread(int p)\n{\n\tif(add(p))\n\t{\n\t\tsum(p<<1)+=add(p)*(r(p<<1)-l(p<<1)+1);\n    sum(p<<1)%=mod;\n\t\tsum(p<<1|1)+=add(p)*(r(p<<1|1)-l(p<<1|1)+1);\n    sum(p<<1)%=mod;\n\t\tadd(p<<1)+=add(p);\n\t\tadd(p<<1|1)+=add(p);\n\t\tadd(p)=0;\n\t}\n}\nint query(int p,int l,int r)\n{\n  if(l>r) swap(l,r);\n  if(l<=l(p) && r>=r(p)) return sum(p)%mod;\n  spread(p);\n  int mid=((l(p)+r(p))>>1);\n  int ans=0;\n  if(l<=mid) ans=(ans+query(p<<1,l,r))%mod;\n  if(r>mid) ans=(ans+query(p<<1|1,l,r))%mod;\n  return ans;\n}\nvoid update(int p,int l,int r,int c) {\n  if(l>r) swap(l,r);\n  if(l<=l(p) && r>=r(p)) {\n\t\tsum(p)+=c*(r(p)-l(p)+1);\n    sum(p)%=mod;\n\t\tadd(p)+=c;\n\t\treturn;\n\t}\n\tspread(p);\n\tint mid=((l(p)+r(p))>>1);\n\tif(l<=mid) update(p<<1,l,r,c);\n\tif(r>mid) update(p<<1|1,l,r,c);\n\tsum(p)=(sum(p<<1)+sum(p<<1|1))%mod;\n}\nint qrange(int x,int y)\n{\n  int ans=0;\n  while(top[x]!=top[y]) {\n    if(dep[top[x]]<dep[top[y]]) swap(x,y);\n    ans+=query(1,seg[top[x]],seg[x]);\n    ans%=mod;\n    x=father[top[x]];\n  }\n  if(dep[x]>dep[y]) swap(x,y);\n  ans+=query(1,seg[x],seg[y]);\n  return ans%mod;\n}\nint qson(int x)\n{\n  return query(1,seg[x],seg[x]+size[x]-1);\n}\nvoid crange(int x,int y,int k)\n{\n  k%=mod;\n  while(top[x]!=top[y]) {\n    if(dep[top[x]]<dep[top[y]]) swap(x,y);\n    update(1,seg[top[x]],seg[x],k);\n    x=father[top[x]];\n  }\n  if(dep[x]>dep[y]) swap(x,y);\n  update(1,seg[x],seg[y],k);\n}\nvoid cson(int x,int k)\n{\n  k%=mod;\n  update(1,seg[x],seg[x]+size[x]-1,k);\n}\nint main()\n{\n  n=read(),m=read(),r=read(),mod=read();\n  for(int i=1;i<=n;i++) num[i]=read();\n  for(int i=1,x,y;i<n;i++)\n  {\n    x=read(),y=read();\n    addedge(x,y);\n  }\n  dfs1(r,0);\n  tot=seg[r]=1;\n  top[r]=rev[1]=r;\n  dfs2(r,0);\n  build(1,1,n);\n  for(int i=1,x,y,z,op;i<=m;i++)\n  {\n    op=read();\n    if (op==1) {\n      x=read(),y=read(),z=read();\n      crange(x,y,z);\n    }\n    else if (op==2) {\n      x=read(),y=read();\n      printf(\"%d\\n\",qrange(x,y));\n    }\n    else if (op==3) {\n      x=read(),z=read();\n      cson(x,z);\n    }\n    else if (op==4) {\n      x=read();\n      printf(\"%d\\n\",qson(x));\n    }\n  }\n  return 0;\n}\n```\n",
        "postTime": 1567605793,
        "uid": 155907,
        "name": "1379\u53f7\u76d1\u542c\u5458",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "## \u6811\u94fe\u5256\u5206\n\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff08\u6ca1\u6709\u7279\u522b\u8bf4\u660e\u65f6\uff09\uff0c\u201c\u6811\u94fe\u5256\u5206\u201d\u90fd\u6307\u201c\u91cd\u94fe\u5256\u5206\u201d\uff0c\u6211\u4eec\u6240\u8bb2\u7684\u4e5f\u662f\u201c\u91cd\u94fe\u5256\u5206\u201d\u3002\n\n\u91cd\u94fe\u5256\u5206\u53ef\u4ee5\u5c06\u6811\u4e0a\u7684\u4efb\u610f\u4e00\u6761\u8def\u5f84\u5212\u5206\u6210\u4e0d\u8d85\u8fc7O(logn)\u00a0\u6761\u8fde\u7eed\u7684\u94fe\uff0c\u6bcf\u6761\u94fe\u4e0a\u7684\u70b9\u6df1\u5ea6\u4e92\u4e0d\u76f8\u540c\uff08\u5373\u662f\u81ea\u5e95\u5411\u4e0a\u7684\u4e00\u6761\u94fe\uff0c\u94fe\u4e0a\u6240\u6709\u70b9\u7684lca\u4e3a\u94fe\u7684\u4e00\u4e2a\u7aef\u70b9\uff09\u3002\n\u91cd\u94fe\u5256\u5206\u8fd8\u80fd\u4fdd\u8bc1\u5212\u5206\u51fa\u7684\u6bcf\u6761\u94fe\u4e0a\u7684\u8282\u70b9 dfs \u5e8f\u8fde\u7eed\uff0c\u56e0\u6b64\u53ef\u4ee5\u65b9\u4fbf\u5730\u7528\u4e00\u4e9b\u7ef4\u62a4\u5e8f\u5217\u7684\u6570\u636e\u7ed3\u6784\uff08\u5982\u7ebf\u6bb5\u6811\uff09\u6765\u7ef4\u62a4\u6811\u4e0a\u8def\u5f84\u7684\u4fe1\u606f\u3002\n\n1.\u4fee\u6539\u00a0\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u4e0a\u00a0\u6240\u6709\u70b9\u7684\u503c\u3002\n2.\u67e5\u8be2\u00a0\u6811\u4e0a\u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u4e0a\u00a0\u8282\u70b9\u6743\u503c\u7684\u00a0\u548c/\u6781\u503c/\u5176\u5b83\uff08\u5728\u5e8f\u5217\u4e0a\u53ef\u4ee5\u7528\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\uff0c\u4fbf\u4e8e\u5408\u5e76\u7684\u4fe1\u606f\uff09\u00a0\u3002\n\n\n![https://cdn.luogu.com.cn/upload/pic/68759.png](https://cdn.luogu.com.cn/upload/pic/68759.png)\n\n  ### \u6c42LCA\n  \u5982\u679c\u4e24\u4e2a\u8282\u70b9\u4e0d\u5728\u540c\u4e00\u6761\u94fe\u4e0a\uff0c\u5c06\u6240\u5728\u94fe\u94fe\u9996\u6df1\u5ea6\u5927\u7684\u70b9\u8df3\u94fe\u3002\u5f53\u5728\u540c\u4e00\u6761\u94fe\u65f6\uff0c\u6df1\u5ea6\u5c0f\u7684\u70b9\u7684\u4f4d\u7f6e\u5c31\u662flca\u3002\n  \u4e00\u6b21\u8df3\u8fc7\u4e00\u6761\u94fe\uff0c\u901f\u5ea6\u6bd4\u500d\u589e\u5feb\u3002\n\n  ### \u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u503c\n  \u8003\u8651\u5230\u6811\u94fe\u5256\u5206\u540e\u6bcf\u4e00\u4e2a\u94fe\u7684\u5143\u7d20\u7684dfs\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u53d6\u7ef4\u62a4\u6811\u94fe\u5256\u5206\u540e\u7684\u5e8f\u5217\u3002\n  \u4f8b\u9898\uff1a\n  ZJOI2008 \u6811\u7684\u7edf\u8ba1\n  \u5bf9\u4e00\u68f5\u6709n\u4e2a\u8282\u70b9\uff0c\u8282\u70b9\u5e26\u6743\u503c\u7684\u9759\u6001\u6811\uff0c\u8fdb\u884c\u4e09\u79cd\u64cd\u4f5c\u5171q\u00a0\u6b21\uff1a\n  1. \u4fee\u6539\u5355\u4e2a\u8282\u70b9\u7684\u503c\uff1b \n  2. \u67e5\u8be2u\u5230u\u7684\u8def\u5f84\u4e0a\u7684\u6700\u5927\u503c\uff1b\n  3. \u67e5\u8be2v\u5230v\u7684\u8def\u5f84\u4e0a\u7684\u6743\u503c\u548c\u3002\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#define ll long long\n#define INF 0x7fffffff\n#define re register\n\nusing namespace std;\n\nint read()\n{\n\tregister int x = 0,f = 1;register char ch;\n\tch = getchar();\n\twhile(ch > '9' || ch < '0'){if(ch == '-') f = -f;ch = getchar();}\n\twhile(ch <= '9' && ch >= '0'){x = x * 10 + ch - 48;ch = getchar();}\n\treturn x * f;\n}\n\nint n,m,r,s,p,x,y,z,o,t,cnt,ans;\nint d[200005],siz[200005],fa[200005],dep[200005],son[200005],top[200005],seg[200005],rev[200005],bs[200005];\n\nstruct edge{\n\tint next,to;\n}e[300005];\n\nstruct tree{\n\tint sum,lazy;\n\ttree *lson,*rson;\n}*root = (tree*)malloc(sizeof(tree));\n\nvoid add(int x,int y)\n{\n\te[++cnt].to = y;\n\te[cnt].next = d[x];\n\td[x] = cnt;\n}\n\nvoid dfs1(int u,int f)\n{\n\tint a,v;\n\tsiz[u] = 1;\n\tfa[u] = f;\n\tdep[u] = dep[f] + 1;\n\tfor(int i = d[u]; i; i = e[i].next)\n\t{\n\t\tint j = e[i].to;\n\t\tif(j == f) continue;\n\t\tdfs1(j,u);\n\t\tsiz[u] = siz[u] + siz[j];\n\t\tif(siz[j] > siz[son[u]]) son[u] = j;\n\t}\n}\n\nvoid dfs2(int u,int f)\n{\n\tif(son[u])\n\t{\n\t\tseg[son[u]] = ++t;\n\t\ttop[son[u]] = top[u];\n\t\trev[t] = son[u];\n\t\tdfs2(son[u],u);\n\t}\n\tfor(int i = d[u]; i; i = e[i].next)\n\t{\n\t\tint j = e[i].to;\n\t\tif(!top[j])\n\t\t{\n\t\t\ttop[j] = j;\n\t\t\tseg[j] = ++t;\n\t\t\trev[t] = j;\n\t\t\tdfs2(j,u);\n\t\t}\n\t}\n}\n\nvoid build(tree *tre,int l,int r)\n{\n\ttre -> lazy = 0;\n\tif(l == r)\n\t{\n\t\ttre -> sum = bs[rev[l]];\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\ttree *son1 = (tree*)malloc(sizeof(tree));\n\ttree *son2 = (tree*)malloc(sizeof(tree));\n\ttre -> lson = son1;\n\ttre -> rson = son2;\n\tbuild(tre -> lson,l,mid);\n\tbuild(tre -> rson,mid + 1,r);\n\ttre -> sum = (tre -> lson -> sum + tre -> rson -> sum) % p;\n}\n\nvoid pushdown(tree *tre,int l,int r)\n{\n\tif(l == r || tre -> lazy == 0) return ;\n\tint mid = (l + r) >> 1;\n\ttre -> lson -> sum = (tre -> lson ->  sum + 1ll *(mid - l + 1) * tre  -> lazy) % p;\n\ttre -> rson -> sum = (tre -> rson ->  sum + 1LL *(r - mid) * tre -> lazy) % p;\n\ttre -> lson -> lazy = (tre -> lson -> lazy + tre -> lazy) % p;\n\ttre -> rson -> lazy = (tre -> rson -> lazy + tre -> lazy) % p;\n\ttre -> lazy = 0;\n}\n\nvoid change(tree *tre,int l,int r,int x,int y,int k)\n{\n\tif(l >= x && r <= y)\n\t{\n\t\ttre -> sum = (tre -> sum + 1LL * (r - l + 1) * k) % p;\n\t\ttre -> lazy = (tre -> lazy + k) % p;\n\t\treturn ;\n\t}\n\tpushdown(tre,l,r);\n\tint mid = (l + r) >> 1;\n\tif(x <= mid) change(tre -> lson,l,mid,x,y,k);\n\tif(y > mid) change(tre -> rson,mid + 1,r,x,y,k);\n\ttre -> sum = (tre -> lson -> sum + tre -> rson -> sum) % p;\n}\n\n\nint query(tree *tre,int l,int r,int x,int y)\n{\n\tif(l >= x && r <= y) return tre -> sum;\n\tpushdown(tre,l,r);\n\tint mid = (l + r) >> 1,t1 = 0,t2 = 0;\n\tif(x <= mid) t1 = query(tre -> lson,l,mid,x,y) % p;\n\tif(y >mid) t2 = query(tre -> rson,mid + 1,r,x,y) % p;\n\treturn (t1 + t2) % p;\n}\n\nvoid myswap()\n{\n\to = x;\n\tx = y;\n\ty = o;\n}\n\nint main()\n{\n\tn = read();\n\tm = read();\n\tr = read();\n\tp = read();\n\tfor(int i = 1; i <= n; i++) bs[i] = read();\n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tx = read();\n\t\ty = read();\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t}\n\tdfs1(r,0);\n\tseg[r] = ++t;\n\trev[t] = r;\n\ttop[r] = r;\n\tdfs2(r,0);\n\tbuild(root,1,n);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\ts = read();\n\t\tans = 0;\n\t\tif(s == 1)\n\t\t{\n\t\t\tx = read(); y = read(); z = read();\n\t\t\twhile(top[x] != top[y])\n\t\t\t{\n\t\t\t\tif(dep[top[x]] < dep[top[y]]) myswap();\n\t\t\t\tchange(root,1,n,seg[top[x]],seg[x],z);\n\t\t\t\tx = fa[top[x]];\n\t\t\t}\n\t\t\tif(seg[x] > seg[y]) myswap();\n\t\t\tchange(root,1,n,seg[x],seg[y],z);\n\t\t}\n\t\tif(s == 2)\n\t\t{\n\t\t\tx = read(); y = read();\n\t\t\twhile(top[x] != top[y])\n\t\t\t{\n\t\t\t\tif(dep[top[x]] < dep[top[y]]) myswap();\n\t\t\t\tans = (ans + query(root,1,n,seg[top[x]],seg[x])) % p;\n\t\t\t\tx = fa[top[x]];\n\t\t\t}\n\t\t\tif(seg[x] > seg[y]) myswap();\n\t\t\tans = (ans + query(root,1,n,seg[x],seg[y])) % p;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\tif(s == 3)\n\t\t{\n\t\t\tx = read(); z = read();\n\t\t\tchange(root,1,n,seg[x],seg[x] + siz[x] - 1,z);\n\t\t}\n\t\tif(s == 4)\n\t\t{\n\t\t\tx = read();\n\t\t\tans = query(root,1,n,seg[x],seg[x] + siz[x] - 1) % p;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n    return 0;\n}\n```",
        "postTime": 1564878201,
        "uid": 150821,
        "name": "Azuree",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "## \u5199\u5728\u524d\u9762\n- \u6709\u4e9b\u9898\u76ee\u53ef\u80fd\u4f1a\u8ba9\u6211\u4eec\u7ef4\u62a4\u4e00\u4e9b\u6811\u4e0a\u7684\u4fe1\u606f\u4f8b\u5982\uff1a\n\t1. \u5982\u9898\uff0c\u5df2\u77e5\u4e00\u68f5\u5305\u542bN\u4e2a\u7ed3\u70b9\u7684\u6811\uff08\u8fde\u901a\u4e14\u65e0\u73af\uff09\uff0c\u6bcf\u4e2a\u8282\u70b9\u4e0a\u5305\u542b\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u652f\u6301\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n\t2. \u64cd\u4f5c1\uff1a \u683c\u5f0f\uff1a 1 x y z \u8868\u793a\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\t3. \u64cd\u4f5c2\uff1a \u683c\u5f0f\uff1a 2 x y \u8868\u793a\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\n\t4. \u64cd\u4f5c3\uff1a \u683c\u5f0f\uff1a 3 x z \u8868\u793a\u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\n\n\t5. \u64cd\u4f5c4\uff1a \u683c\u5f0f\uff1a 4 x \u8868\u793a\u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\n- \u8fd9\u4e9b\u4e1c\u897f\u4e4d\u4e00\u770b\u597d\u50cf\u66b4\u529b\u53ef\u4ee5\u7ef4\u62a4\uff0c~~\u6bd2\u7624\u51fa\u9898\u4eba:\u4e0d\u4f60\u4e0d\u53ef\u4ee5~~\uff0c\u4f46\u662f\u6211\u4eec\u65e0\u7591\u9700\u8981\u66f4\u52a0\u4f18\u79c0\u7684\u590d\u6742\u5ea6\u6765\u7ef4\u62a4\uff0c\u8fd9\u5c31\u7528\u5230\u4e86\u6211\u4eec\u8981\u8bb2\u7684\u4e1c\u897f**\u6811\u94fe\u5256\u5206**\n\n## \u4e00\u4e9b\u5b9a\u4e49\n- \u91cd\u513f\u5b50\uff1a\u8be5\u8282\u70b9\u7684\u5b50\u6811\u4e2d,\u8282\u70b9\u4e2a\u6570\u6700\u591a\u7684\u5b50\u6811\u7684\u6839\u8282\u70b9\n\n- \u8f7b\u513f\u5b50\uff1a\u4e0d\u662f\u91cd\u513f\u5b50\u7684\u513f\u5b50\n \n- \u91cd\u8fb9\uff1a\u8fde\u63a5\u8be5\u8282\u70b9\u4e0e\u5b83\u7684\u91cd\u513f\u5b50\u7684\u8fb9\n\n- \u8f7b\u8fb9\uff1a\u4e0d\u662f\u91cd\u8fb9\u7684\u5176\u4f59\u8fb9\n\n- \u91cd\u94fe\uff1a\u7531\u4e00\u7cfb\u5217\u91cd\u8fb9\u76f8\u8fde\u5f97\u5230\u7684\u94fe\n\n- \u8f7b\u94fe\uff1a\u7531\u4e00\u7cfb\u5217\u8f7b\u8fb9\u76f8\u8fde\u5f97\u5230\u7684\u94fe\n\n## \u5f00\u59cb$bb$\n- \u4ee5\u4e0b\u5168\u4e3a\u849f\u84bb\u7684\u53e3\u80e1$yingyingying$\n- \u6811\u94fe\u5256\u5206\u7684\u6838\u5fc3\u5c31\u662f\u5c06\u4e00\u9897\u6811\u5206\u89e3\u4e3a\u82e5\u5e72\u8fb9\u518d\u7528\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u4fe1\u606f\u3002\n- \u6211\u4eec\u6765\u770b\u4e00\u68f5\u6811\n\n\n![\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0](https://img-blog.csdnimg.cn/20190715194103905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)\n- \u5927\u5bb6\u53ef\u4ee5\u6839\u636e\u5b9a\u4e49\u6807\u4e00\u4e0b\u91cd\u513f\u5b50\uff0c\u91cd\u8fb9$\\cdots$\n- \u6807\u597d\u7684\u56fe\u5927\u6982\u957f\u8fd9\u6837:\n\n![\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0](https://img-blog.csdnimg.cn/20190715194937451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)\n- ~~\u597d\u4e11\u554a~~\n- \u6211\u4eec\u6807\u8bb0\u8fd9\u68f5\u6811\u6709\u4ec0\u4e48\u7528\u5462\uff1f\n- \u9996\u5148\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u904d$dfs$\u6c42\u51fa\u4e0b\u5217\u4e1c\u897f:\n\t1. $dep[i]$\u8282\u70b9$i$\u7684\u6df1\u5ea6\n\t2. $fat[i]$\u8282\u70b9$i$\u7684\u7236\u4eb2\u8282\u70b9\n\t3. $siz[i]$\u8282\u70b9$i$\u7684\u5b50\u6811\u5927\u5c0f\n\t4. $son[i]$\u8282\u70b9$i$\u7684\u91cd\u513f\u5b50\n- \u8fd9\u4e2a$dfs$\u5927\u6982\u957f\u8fd9\u6837:\n```cpp\nvoid dfs1(int u, int fa, int depth) {\n\tsiz[u] = 1; \n\tfat[u] = fa; \n\tdep[u] = depth; \n\tint maxson = -1; \n\tfor (int i = lin[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to; \n\t\tif (v == fa) continue; \n\t\tdfs1(v, u, depth + 1); \n\t\tsiz[u] += siz[v]; \n\t\tif (siz[v] > maxson) {\n\t\t\tmaxson = siz[v]; \n\t\t\tson[u] = v; \n\t\t}\n\t}\n}\n```\n- \u6811\u94fe\u5256\u5206\u662f\u5bf9\u5c06\u6811\u62c6\u5206\u6210\u4e3a\u82e5\u5e72\u94fe\uff0c\u8fd9\u4e9b\u94fe\u62c6\u8fc7\u4e4b\u540e\u5462\uff1f\u5f53\u7136\u8981\u5bf9\u8282\u70b9\u91cd\u65b0\u7f16\u53f7\u4e86\uff0c\u5e94\u5148\u5bf9\u91cd\u94fe\u7f16\u53f7\uff0c\u56e0\u4e3a\u8fd9\u6837\u80fd\u4fdd\u8bc1\u91cd\u94fe\u4e2d\u8282\u70b9\u7684\u6807\u53f7\u662f\u8fde\u7eed\u7684\n- \u6807\u5b8c\u53f7\u7684\u56fe\u5927\u6982\u957f\u8fd9\u4e2a\u6837\u5b50\uff1a\n\n![\u5728\u8fd9\u91cc\u63d2\u5165\u56fe\u7247\u63cf\u8ff0](https://img-blog.csdnimg.cn/20190715195735720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0NDkzODQw,size_16,color_FFFFFF,t_70)\n- ~~\u5176\u5b9e\u5b83\u539f\u672c\u5c31\u662f\u4e00\u4e2a\u6309\u91cd\u94fe\u6807\u597d\u7684\u56fe\uff0c\u6211\u504f\u8981\u4ece\u53f3\u8fb9\u5f00\u59cb\u6807yyy~~\n- \u5b9a\u4e49\uff1a\n\t1. $idx[i]$\u4e3a\u539f\u672c\u7684$i$\u53f7\u8282\u70b9\u7684\u65b0\u7f16\u53f7\n\t2. $top[i]$\u4e3a\u7f16\u53f7\u4e3a$i$\u7684\u8282\u70b9\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\uff0c\u5373\u6df1\u5ea6\u6700\u5c0f\u7684\u90a3\u4e2a\u8282\u70b9\n\t3. $val[i]$\u4e3a\u8282\u70b9\u7684\u65b0\u7f16\u53f7\u5bf9\u5e94\u7684\u6743\u503c\uff0c$pre[i]$\u4e3a\u539f\u6765\u7684\u6743\u503c\n- \u8fd9\u4e9b\u4e1c\u897f\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528\u4e00\u4e2a$dfs$\u6765\u6c42\u51fa\n```cpp\nvoid dfs2(int u, int tp) {\n\tidx[u] = ++cnt; \n\tval[cnt] = pre[u]; \n\ttop[u] = tp; \n\tif (!son[u]) return ; \n\tdfs2(son[u], tp); \n\tfor (int i = lin[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to; \n\t\tif (!idx[v]) \n\t\t\tdfs2(v, v); \n\t}\n}\n```\n\n- \u5bf9\u4e8e\u6743\u503c\u7684\u52a0\u52a0\u51cf\u51cf\u6211\u4eec\u53ef\u4ee5\u5efa\u4e00\u68f5\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\n- \u53ef\u4ee5\u770b\u6211\u7684\u6a21\u677f\u54e6\n\n\t- [\u533a\u95f4\u4fee\u6539+\u533a\u95f4\u67e5\u8be2](https://blog.csdn.net/qq_34493840/article/details/88861829)\n\t- [\u5355\u70b9\u4fee\u6539+\u533a\u95f4\u67e5\u8be2](https://blog.csdn.net/qq_34493840/article/details/88861776)\n   \n```cpp\nvoid build(int p, int l, int r) {\n\tt[p].l = l, t[p].r = r; \n\tif (l == r) { t[p].sum = val[l]; return ; }\n\tint mid = (l + r) >> 1; \n\tbuild(p<<1, l, mid); \n\tbuild(p<<1|1, mid + 1, r); \n\tt[p].sum = (t[p<<1].sum + t[p<<1|1].sum) % mod; \n}\n\nvoid spread(int p) {\n\tif (t[p].add) {\n\t\tt[p<<1].sum += (t[p<<1].r - t[p<<1].l + 1) * t[p].add; \n\t\tt[p<<1|1].sum += (t[p<<1|1].r - t[p<<1|1].l + 1) * t[p].add; \n\t\tt[p<<1].add += t[p].add; \n\t\tt[p<<1|1].add += t[p].add; \n\t\tt[p].add = 0; \n\t}\n}\n\nvoid change(int p, int l, int r, int v) {\n\tif (l <= t[p].l && r >= t[p].r) {\n\t\tt[p].sum += (t[p].r - t[p].l + 1) * v; \n\t\tt[p].add += v; \n\t\treturn ; \n\t}\n\tspread(p); \n\tint mid = (t[p].l + t[p].r) >> 1; \n\tif (l <= mid) change(p<<1, l, r, v); \n\tif (r > mid) change(p<<1|1, l, r, v); \n\tt[p].sum = (t[p<<1].sum + t[p<<1|1].sum) % mod; \n}\n\nint query(int p, int l, int r) {\n\tif (l <= t[p].l && r >= t[p].r) return t[p].sum; \n\tspread(p); \n\tint sum = 0; \n\tint mid = (t[p].l + t[p].r) >> 1; \n\tif (l <= mid) sum = (sum + query(p<<1, l, r)) % mod; \n\tif (r > mid) sum = (sum + query(p<<1|1, l, r)) % mod; \n\treturn sum % mod;  \n}\n```\n\n- **\u91cd\u70b9\u6765\u4e86\uff01\uff01\uff01**\n- \u6211\u4eec\u5982\u4f55\u7ef4\u62a4\u6811\u4e0a\u7684\u64cd\u4f5c\u5462\uff1f\n- \u6811\u94fe\u5256\u5206\u7684\u65b9\u6cd5\u4e3a\uff1a**\u5bf9\u4e8e\u4e24\u4e2a\u4e0d\u5728\u540c\u4e00\u91cd\u94fe\u5185\u7684\u8282\u70b9\uff0c\u8ba9\u5b83\u4eec\u4e0d\u65ad\u5730\u8df3\uff0c\u4f7f\u5f97\u5b83\u4eec\u5904\u4e8e\u540c\u4e00\u91cd\u94fe\u4e0a**\n- \u5177\u4f53\u5b9e\u73b0\u4e3a\uff1a\n\t- \u5bf9\u4e8e\u4e24\u70b9\u8def\u5f84\u7684\u60c5\u51b5\uff1a\u5229\u7528\u521a\u624d\u6c42\u51fa\u7684$top$\u6570\u7ec4\uff0c\u53ef\u4ee5\u76f4\u63a5\u5c06$x$\u8df3\u5230\u94fe\u7684\u9876\u7aef(\u8bbe$dep[x]>dep[y]$)\uff0c\u5bf9\u4e8e\u8be5\u91cd\u94fe\u76f4\u63a5\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539/\u67e5\u8be2\u5373\u53ef\uff0c\u76f4\u5230$x$\uff0c$y$\u5c5e\u4e8e\u540c\u4e00\u91cd\u94fe\uff0c\u518d\u5bf9\u8be5\u91cd\u94fe\u533a\u95f4\u67e5\u8be2/\u4fee\u6539\u5373\u53ef\u3002\n    \n\n```cpp\nvoid AddPath(int x, int y, int z) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\tchange(1, idx[top[x]], idx[x], z); \n\t\tx = fat[top[x]]; \n\t}\n\tif (dep[x] > dep[y]) swap(x, y); \n\tchange(1, idx[x], idx[y], z); \n}\n\nint QueryPath(int x, int y) {\n\tint sum = 0; \n\twhile(top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\tsum = (sum + query(1, idx[top[x]], idx[x])) % mod; \n\t\tx = fat[top[x]]; \n\t}\n\tif (dep[x] > dep[y]) swap(x, y); \n\tsum = (sum + query(1, idx[x], idx[y])) % mod; \n\treturn sum; \n}\n ```\n \n- \u5bf9\u4e8e\u5b50\u6811\u4e2d\u7684\u64cd\u4f5c\uff1a\n \t- \u8bbe\u5b50\u6811\u7684\u6839\u8282\u70b9\u4e3a$x$\uff0c\u5219\u5b50\u6811\u5728\u65b0\u6807\u53f7\u540e\u5bf9\u5e94\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u8303\u56f4\u4e3a$[idx[x],idx[x]+siz[x]-1]$\n \t- \u5bf9\u5b50\u6811\u76f4\u63a5\u8fdb\u884c\u533a\u95f4\u4fee\u6539\u5373\u53ef\n\n\n```cpp\n void AddSubtree(int x, int v) {\n\tchange(1, idx[x], idx[x] + siz[x] - 1, v); \n}\nint QuerySubtree(int x) {\n\tint ans = 0; \n\tans = (ans + query(1, idx[x], idx[x] + siz[x] - 1)) % mod; \n\treturn ans; \n}\n ```\n\n\n- \u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(nlognlogn)$~~\u611f\u6027\u7406\u89e3\u4e0b\u5427\uff0c\u4e0d\u8bc1\u660e\u4e86~~\n\n## $code$\n\n[luogu 3384](https://www.luogu.org/problemnew/show/P3384)\n\n```cpp\n#include <bits/stdc++.h> \nusing namespace std; \nconst int maxn = 100000 + 100; \n\ntemplate <class T> \ninline void read(T &s) {\n\ts = 0; \n\tT w = 1, ch = getchar(); \n\twhile (!isdigit(ch)) { if (ch == '-') w = -1; ch = getchar(); }\n\twhile (isdigit(ch)) { s = (s << 1) + (s << 3) + (ch ^ 48); ch = getchar(); }\n\ts *= w; \n}\n\nint n, m, r, mod, tot, cnt; \nint pre[maxn], val[maxn], lin[maxn]; \nint siz[maxn], son[maxn], dep[maxn], fat[maxn]; \nint idx[maxn], top[maxn]; \nstruct node { int next, to; } edge[maxn * 2]; \nstruct tree { int l, r, add, sum; } t[maxn * 4]; \n\ninline void add(int from, int to) {\n\tedge[++tot].to = to; \n\tedge[tot].next = lin[from]; \n\tlin[from] = tot; \n}\n\nvoid dfs1(int u, int fa, int depth) {\n\tsiz[u] = 1; \n\tfat[u] = fa; \n\tdep[u] = depth; \n\tint maxson = -1; \n\tfor (int i = lin[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to; \n\t\tif (v == fa) continue; \n\t\tdfs1(v, u, depth + 1); \n\t\tsiz[u] += siz[v]; \n\t\tif (siz[v] > maxson) {\n\t\t\tmaxson = siz[v]; \n\t\t\tson[u] = v; \n\t\t}\n\t}\n}\n\nvoid dfs2(int u, int tp) {\n\tidx[u] = ++cnt; \n\tval[cnt] = pre[u]; \n\ttop[u] = tp; \n\tif (!son[u]) return ; \n\tdfs2(son[u], tp); \n\tfor (int i = lin[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to; \n\t\tif (!idx[v]) \n\t\t\tdfs2(v, v); \n\t}\n}\n\nvoid build(int p, int l, int r) {\n\tt[p].l = l, t[p].r = r; \n\tif (l == r) { t[p].sum = val[l]; return ; }\n\tint mid = (l + r) >> 1; \n\tbuild(p<<1, l, mid); \n\tbuild(p<<1|1, mid + 1, r); \n\tt[p].sum = (t[p<<1].sum + t[p<<1|1].sum) % mod; \n}\n\nvoid spread(int p) {\n\tif (t[p].add) {\n\t\tt[p<<1].sum += (t[p<<1].r - t[p<<1].l + 1) * t[p].add; \n\t\tt[p<<1|1].sum += (t[p<<1|1].r - t[p<<1|1].l + 1) * t[p].add; \n\t\tt[p<<1].add += t[p].add; \n\t\tt[p<<1|1].add += t[p].add; \n\t\tt[p].add = 0; \n\t}\n}\n\nvoid change(int p, int l, int r, int v) {\n\tif (l <= t[p].l && r >= t[p].r) {\n\t\tt[p].sum += (t[p].r - t[p].l + 1) * v; \n\t\tt[p].add += v; \n\t\treturn ; \n\t}\n\tspread(p); \n\tint mid = (t[p].l + t[p].r) >> 1; \n\tif (l <= mid) change(p<<1, l, r, v); \n\tif (r > mid) change(p<<1|1, l, r, v); \n\tt[p].sum = (t[p<<1].sum + t[p<<1|1].sum) % mod; \n}\n\nint query(int p, int l, int r) {\n\tif (l <= t[p].l && r >= t[p].r) return t[p].sum; \n\tspread(p); \n\tint sum = 0; \n\tint mid = (t[p].l + t[p].r) >> 1; \n\tif (l <= mid) sum = (sum + query(p<<1, l, r)) % mod; \n\tif (r > mid) sum = (sum + query(p<<1|1, l, r)) % mod; \n\treturn sum % mod;  \n}\n\nvoid AddPath(int x, int y, int z) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\tchange(1, idx[top[x]], idx[x], z); \n\t\tx = fat[top[x]]; \n\t}\n\tif (dep[x] > dep[y]) swap(x, y); \n\tchange(1, idx[x], idx[y], z); \n}\n\nint QueryPath(int x, int y) {\n\tint sum = 0; \n\twhile(top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y); \n\t\tsum = (sum + query(1, idx[top[x]], idx[x])) % mod; \n\t\tx = fat[top[x]]; \n\t}\n\tif (dep[x] > dep[y]) swap(x, y); \n\tsum = (sum + query(1, idx[x], idx[y])) % mod; \n\treturn sum; \n}\n\nvoid AddSubtree(int x, int v) {\n\tchange(1, idx[x], idx[x] + siz[x] - 1, v); \n}\n\nint QuerySubtree(int x) {\n\tint ans = 0; \n\tans = (ans + query(1, idx[x], idx[x] + siz[x] - 1)) % mod; \n\treturn ans; \n}\n\nint main() {\n\tread(n), read(m), read(r), read(mod); \n\tfor (int i = 1; i <= n; ++i) \n\t\tread(pre[i]); \n\tfor (int i = 1; i < n; ++i) {\n\t\tint u, v; read(u), read(v); \n\t\tadd(u, v), add(v, u); \n\t}\n\n\tdfs1(r, 0, 1); \n\tdfs2(r, r); \n\tbuild(1, 1, n); \n\n\twhile (m--) {\n\t\tint opt, x, y, z; \n\t\tread(opt); \n\t\tif (opt == 1) {\n\t\t\tread(x), read(y), read(z); \n\t\t\tz %= mod; \n\t\t\tAddPath(x, y, z); \n\t\t}\n\t\telse if (opt == 2) {\n\t\t\tread(x), read(y); \n\t\t\tprintf(\"%d\\n\", QueryPath(x, y)); \n\t\t}\n\t\telse if (opt == 3) {\n\t\t\tread(x), read(z); \n\t\t\tz %= mod; \n\t\t\tAddSubtree(x, z); \n\t\t}\n\t\telse if (opt == 4) {\n\t\t\tread(x); \n\t\t\tprintf(\"%d\\n\", QuerySubtree(x)); \n\t\t}\n\t}\n\treturn 0; \n}\n\n```",
        "postTime": 1563193158,
        "uid": 145352,
        "name": "MILLOPE",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u51c6\u5907\u8d34\u4e00\u4e2a\u5f88\u6c34\u7684\u9898\u89e3 ~~\uff08\u9003\uff09~~\n\n------------\n\u9996\u5148\u6211\u4eec\u5f15\u5165\u51e0\u4e2a\uff08\u5f62\u540c\u865a\u8bbe\uff09\u7684\u6982\u5ff5orz\n\n\u91cd\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u7684\u6240\u6709\u513f\u5b50\u4e2d\u5b50\u6811\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u7684\u7ed3\u70b9\n\n\u8f7b\u513f\u5b50\uff1a\u7236\u4eb2\u8282\u70b9\u4e2d\u9664\u4e86\u91cd\u513f\u5b50\u4ee5\u5916\u7684\u513f\u5b50\n\n\u91cd\u8fb9\uff1a\u7236\u4eb2\u7ed3\u70b9\u548c\u91cd\u513f\u5b50\u8fde\u6210\u7684\u8fb9\n\n\u8f7b\u8fb9\uff1a\u7236\u4eb2\u8282\u70b9\u548c\u8f7b\u513f\u5b50\u8fde\u6210\u7684\u8fb9\n\n\u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\n\n\u8f7b\u94fe\uff1a\u7531\u591a\u6761\u8f7b\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\n\n\n------------\n# \u6a21\u677f\u9898 lougu P3384\n\n### \u5148\u8d70\u4e24\u904ddfs\n\uff08\u53ef\u4ee5\u76f4\u63a5\u770b\u540e\u9762\u7684\u4ee3\u7801\uff09\n\n\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff1a\u4e00\u4e2a\u5b50\u6811\u4ee5\u4e0b\u7684\u6240\u6709\u7ed3\u70b9\u7684\u65b0\u7f16\u53f7\u7ec4\u6210\u7684\u5e8f\u5217\u90fd\u4f1a\u662f\u8fde\u7eed\u7684\uff0c\u4e14\u8be5\u5b50\u6811\u7684\u6240\u6709\u70b9\u65b0\u7f16\u53f7\u5f62\u6210\u7684\u533a\u95f4\u5c06\u4f1a\u662f[\u6839\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u65b0\u7f16\u53f7\uff0c\u6839\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u65b0\u7f16\u53f7+\u8fd9\u68f5\u6811\u7684\u7ed3\u70b9\u6570\u76ee-1]\u3002\n\n------------\n\n### \u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u90fd\u52a0\u4e0ad\n\n\u6211\u4eec\u8ba9x,y\u50cflca\u4e00\u6837\u5f80\u4e0a\u4e95\u7136\u6709\u5e8f\u5730\u4e71\u8df3\uff0c\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u7684\u533a\u95f4\u4fee\u6539\u5c31\u53ef\u4ee5\u4e86\n\u8bf4\u662f\u4e71\u8df3\uff0c\u4f46\u662f\u8fd9\u4e2a\u8df3\u8dc3\u8fd8\u662f\u5f88\u6709\u89c4\u5f8b\u7684......\n\n\u6211\u4eec\u8ba9x,y\u7684top\u6df1\u5ea6\u66f4\u6df1\u7684\u5148\u8df3\uff0c\u7136\u540e\u628a\u8df3\u7684\u8fd9\u4e00\u6761\u94fe\u4e0a\u7684\u6743\u503c\u533a\u95f4\u4fee\u6539d\uff08\u56e0\u4e3a\u91cd\u94fe\u4e0a\u7684\u7ed3\u70b9\u5e8f\u53f7\u5728\u65b0\u6811\u4e0a\u662f\u8fde\u7eed\u7684\u6240\u4ee5\u5f88\u597d\u4fee\u6539\uff09\uff0c\u7136\u540e\u628a\u8df3\u5b8c\u540e\u7684\u7ed3\u70b9\u66f4\u65b0\u4e3a\u5b83top\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9fa\uff0c\u7136\u540e\u518d\u7ee7\u7eed\u8df3...\u7136\u540e\u76f4\u5230\u6700\u540ex,y\u7ed3\u70b9\u7684top\u503c\u76f8\u7b49\uff0c\u4e5f\u5c31\u662fx\uff0cy\u5230\u4e86\u540c\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c\u56e0\u4e3a\u7ed3\u70b9\u5e8f\u53f7\u8fd8\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u4ecd\u7136\u7528\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\u90a3\u6761\u94fe\u4e0a\u7684\u6743\u503c\n\n\n\n------------\n### \u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u4e4b\u548c\n\n\u8fd9\u4e2a\u64cd\u4f5c\u548c\u524d\u9762\u90a3\u4e2a\u64cd\u4f5c\u57fa\u672c\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\uff0c\u5c31\u662f\u628a\u533a\u95f4\u4fee\u6539\u6539\u6210\u8ba1\u7b97\u533a\u95f4\u548c\u5c31\u53ef\u4ee5\u4e86...\n\n\n------------\n### \u5c06\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u90fd\u52a0\u4e0ad\n\n\u6211\u597d\u50cf\u8bb2\u8fc7\u7684\uff0c\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u7684\u6240\u6709\u7ed3\u70b9\u65b0\u7f16\u53f7\u6240\u5f62\u6210\u7684\u533a\u95f4\u4e3a[T[x].id,T[x].id+T[x].size-1]\uff0c\u7136\u540e\u76f4\u63a5\u533a\u95f4\u4fee\u6539\u5c31\u53ef\u4ee5\u4e86orz\n\n(\u524d\u60c5\u56de\u987e\uff1a\u4e00\u4e2a\u5b50\u6811\u4ee5\u4e0b\u7684\u6240\u6709\u7ed3\u70b9\u90fd\u4f1a\u662f\u8fde\u7eed\u7684\uff0c\u4e14\u8be5\u5b50\u6811\u7684\u6240\u6709\u70b9\u65b0\u7f16\u53f7\u5f62\u6210\u7684\u533a\u95f4\u5c06\u4f1a\u662f[\u6839\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u65b0\u7f16\u53f7\uff0c\u6839\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u65b0\u7f16\u53f7+\u8fd9\u68f5\u6811\u7684\u7ed3\u70b9\u6570\u76ee-1])\n\n------------\n\n### \u6c42\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u4e4b\u548c\n\n\u548c\u524d\u9762\u5dee\u4e0d\u591aorz\n\n------------\n\n\u597d\u7684\u8d34\u4e2a\u5b8c\u6574\u7684\u4ee3\u7801orz\n```cpp\n//\u6b64\u9898\u4e3aluogu 3384 \n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nint sum[400005];\nint lazytag[400005],P,cnt,ans;\nint newp;//\u7528\u6765\u94fe\u5f0f\u524d\u5411\u661f\u7684 \nint root;//\u6839\u7ed3\u70b9 \nstruct atree{\n\tint w;//\u7ed3\u70b9\u7684\u6743\u503c \n\tint id;//\u7ed3\u70b9\u5728\u65b0\u6811\u4e2d\u7684\u7f16\u53f7 \n\tint dep;//\u7ed3\u70b9\u7684\u6df1\u5ea6 \n\tint head;//\u7528\u6765\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u7684\u7b2c\u4e00\u6761\u8fb9\u7684\u4f4d\u7f6e \n\tint son;//\u7ed3\u70b9\u7684\u91cd\u513f\u5b50 \n\tint top;//\u7ed3\u70b9\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9 \n\tint fa;//\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9 \n\tint siz;//\u4ee5\u6b64\u7ed3\u70b9\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u7684\u7ed3\u70b9\u6570\u76ee \n}T[200005];\nstruct newtree{\n\tint w;//\u4e00\u9897\u65b0\u6811\u6240\u5bf9\u5e94\u7684\u7ed3\u70b9\u7684\u6743\u503c \n}newT[200005];\nstruct edges{\n\tint nxt,to;//\u7528\u6765\u94fe\u5f0f\u524d\u5411\u661f\u7684 \n}e[200005];\nvoid ad(int u,int v)//\u94fe\u5f0f\u524d\u5411\u661f\u8fde\u63a5u,v \n{\n\te[++newp].to=v;\n\te[newp].nxt=T[u].head;\n\tT[u].head=newp;\n}\n\n\n//\u5f00\u59cb\u6211\u4eec\u719f\u6089\u7684\u7ebf\u6bb5\u6811\u533a\u95f4\u64cd\u4f5corz \nvoid maketag(int k,int l,int r,int d)//\u7ed9\u7ebf\u6bb5\u6811\u4e2d\u6807\u53f7\u4e3ak\u7684\u7ed3\u70b9\u6253\u6807\u8bb0 \n{\n\tsum[k]+=d*(r-l+1);//\u66f4\u65b0\u7ebf\u6bb5\u6811\u7684sum \n\tlazytag[k]+=d;//\u66f4\u65b0k\u7ed3\u70b9\u7684lazytag \n}\nvoid pushdown(int k,int l,int r)//\u4f20\u6807\u8bb0 \n{\n\tif(!lazytag[k])return;\n\t//\u7ed9k\u7ed3\u70b9\u7684\u5b50\u6811\u6253\u6807\u8bb0 \n\tmaketag(k*2,l,(l+r)/2,lazytag[k]);\n\tmaketag(k*2+1,(l+r)/2+1,r,lazytag[k]);\n\tlazytag[k]=0;//\u628ak\u7ed3\u70b9\u7684lazytag\u6e05\u96f6 \n}\nvoid build(int k,int l,int r)//\u5efa\u9020\u6211\u4eec\u7684\u7ebf\u6bb5\u6811 \n{\n\tif(l==r){//\u904d\u5386\u5230[l,l]\u533a\u95f4\uff0c\u4e5f\u5c31\u662fnewT\u4e2d\u7684l\u7ed3\u70b9 \n\t\tsum[k]=newT[l].w;\n\t\tsum[k]%=P;\n\t\treturn;\n\t}\n\t//\u5efa\u5de6\u53f3\u5b50\u6811 \n\tint mid=(l+r)/2;\n\tbuild(k*2,l,mid);\n\tbuild(k*2+1,mid+1,r);\n\tsum[k]=sum[k*2]+sum[k*2+1];\n\tsum[k]%=P;\n\treturn;\n}\nvoid ad(int k,int l,int r,int x,int y,int d)//\u5728\u533a\u95f4[x,y]\u52a0\u503cd \n{\n\tif(r<=y&&l>=x)//\u5982\u679c[l,r]\u5728[x,y]\u4e2d\uff0c\u5c31\u76f4\u63a5\u6253\u6807\u8bb0 \n\t{\n\t\tmaketag(k,l,r,d);\n\t\treturn;\n\t}\n\tif(y<l||x>r)return;//\u5982\u679c[l,r]\u4e0e[x,y]\u5b8c\u5168\u4e0d\u76f8\u4ea4 \n\tpushdown(k,l,r);//\u4f20\u6807\u8bb0 \n\tint mid=(l+r)/2;\n\t//\u8ba1\u7b97\u5de6\u53f3\u5b50\u6811 \n\tad(k*2,l,mid,x,y,d);\n\tad(k*2+1,mid+1,r,x,y,d);\n\tsum[k]=sum[k*2]+sum[k*2+1];\n\tsum[k]%=P;\n}\nint fi(int k,int l,int r,int x,int y)//\u627e\u533a\u95f4\u548c[x,y] \n{\n\tif(y<l||x>r)return 0;//\u5982\u679c[l,r]\u4e0e[x,y]\u5b8c\u5168\u4e0d\u76f8\u4ea4 \n\tif(r<=y&&l>=x)//\u5982\u679c[l,r]\u5728[x,y]\u4e2d\uff0c\u5c31\u76f4\u63a5\u52a0\u4e0a\u8be5\u5b50\u6811\u7684\u503c \n\t{\n\t\treturn sum[k];\n\t}\n\tpushdown(k,l,r);\n\tint mid=(l+r)/2;\n\treturn (fi(k*2,l,mid,x,y)+fi(k*2+1,mid+1,r,x,y))%P;\n}\n//\u7ebf\u6bb5\u6811\u5b8c\u6210\uff01 \n\n\n//\u5f00\u59cb\u6811\u94fe\u5256\u5206orz\n\n//\u8fd9\u6b21dfs\u8bb0\u5f55\u5b50\u6811\u5927\u5c0fsiz,\u91cd\u513f\u5b50son\uff0c\u6df1\u5ea6dep\uff0c\u7236\u4eb2\u7ed3\u70b9fa\nvoid dfs1(int x)\n{\n\tT[x].siz=1;\n\tint maxson=0;\n\tfor(int i=T[x].head;i;i=e[i].nxt)\n\t{\n\t\tint y=e[i].to;//y\u662f\u4e0ex\u76f8\u8fde\u7684\u4e00\u4e2a\u7ed3\u70b9\n\t\tif(!T[y].dep)//\u5982\u679cy\u7ed3\u70b9\u6ca1\u6709\u88ab\u904d\u5386\u8fc7 \n\t\t{\n\t\t\tT[y].dep=T[x].dep+1;\n\t\t\tT[y].fa=x;\n\t\t\tdfs1(y);\n\t\t\tT[x].siz+=T[y].siz;\n\t\t\tif(T[y].siz>maxson)//\u5224\u65ady\u662f\u5426\u662fx\u7684\u91cd\u513f\u5b50 \n\t\t\t{\n\t\t\t\tT[x].son=y;\n\t\t\t\tmaxson=T[y].siz;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//\u8fd9\u6b21dfs\u8bb0\u5f55\u6240\u5728\u91cd\u94fe\u8d77\u70b9top,\u5bf9\u5e94\u65b0\u7f16\u53f7id\uff0c\u65b0\u7f16\u53f7\u7684\u6743\u503cnewT.w\nvoid dfs2(int x,int TOP)\n{\n\tT[x].id=++cnt;//\u5efa\u4e00\u68f5\u65b0\u6811\uff08\u5176\u5b9e\u5c31\u662f\u628a\u7ed3\u70b9\u91cd\u65b0\u7f16\u4e2a\u53f7\uff09 \n\tnewT[cnt].w=T[x].w;//\u66f4\u65b0\u65b0\u6811\u7684\u6743\u503c\n\tT[x].top=TOP;//\u8bb0\u5f55\u7ed3\u70b9\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9 \n\tif(T[x].siz==1)//\u5982\u679cx\u7ed3\u70b9\u662f\u53f6\u5b50\u7ed3\u70b9\u5c31\u4e0d\u7528\u5f80\u4e0b\u904d\u5386\u4e86 \n\treturn;\n\t//\u9996\u5148\u904d\u5386x\u7684\u91cd\u513f\u5b50\uff0c\u91cd\u513f\u5b50\u7684top\u662fx\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9TOP\n\tdfs2(T[x].son,TOP);\n\tfor(int i=T[x].head;i;i=e[i].nxt)//\u904d\u5386x\u7684\u8f7b\u513f\u5b50 \n\t{\n\t\tint y=e[i].to;\n\t\tif(T[x].son!=y&&T[x].fa!=y)\n\t\t{\n\t\t\tdfs2(y,y);\n\t\t}\n\t}\n}\n\nvoid adroad(int x,int y,int d)//\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u90fd\u52a0\u4e0ad \n{\n\twhile(T[x].top!=T[y].top)//\u5982\u679cx,y\u7ed3\u70b9\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9\u4e0d\u540c\n\t{\n\t\tif(T[T[x].top].dep<T[T[y].top].dep)//\u4f7fx\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u7684\u6df1\u5ea6\u4e0d\u5c0f\u4e8ey\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u6df1\u5ea6 \n\t\tswap(x,y);\n\t\tad(1,1,n,T[T[x].top].id,T[x].id,d);//\u628a\u7ed3\u70b9x\u5230\u5b83\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u8fd9\u6761\u8def\u52a0\u4e0ad\n\t\tx=T[T[x].top].fa;//x\u7ed3\u70b9\u8df3\u5230\u5b83\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9\u7684\u7236\u4eb2 \n\t}\n\tif(T[x].dep<T[y].dep)swap(x,y);//\u4f7fx\u7684\u6df1\u5ea6\u4e0d\u5c0f\u4e8ey\u7684\u6df1\u5ea6 \n\tad(1,1,n,T[y].id,T[x].id,d);//\u66f4\u65b0x->y\u7684\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u7684\u6743\u503c \n}\n\nvoid sumroad(int x,int y)//\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u4e4b\u548c \n{\n\tans=0;\n\twhile(T[x].top!=T[y].top)//\u5982\u679cx,y\u7ed3\u70b9\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9\u4e0d\u540c\n\t{\n\t\tif(T[T[x].top].dep<T[T[y].top].dep)//\u4f7fx\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u7684\u6df1\u5ea6\u4e0d\u5c0f\u4e8ey\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u6df1\u5ea6 \n\t\tswap(x,y);\n\t\tans+=fi(1,1,n,T[T[x].top].id,T[x].id);//\u628a\u7ed3\u70b9x\u5230\u5b83\u6240\u5728\u91cd\u94fe\u7684\u9876\u7aef\u8fd9\u6761\u8def\u7684\u533a\u95f4\u548c\u7d2f\u52a0 \n\t\tans%=P;\n\t\tx=T[T[x].top].fa;//x\u7ed3\u70b9\u8df3\u5230\u5b83\u6240\u5728\u91cd\u94fe\u7684\u8d77\u70b9\u7684\u7236\u4eb2 \n\t}\n\tif(T[x].dep<T[y].dep)swap(x,y);//\u4f7fx\u7684\u6df1\u5ea6\u4e0d\u5c0f\u4e8ey\u7684\u6df1\u5ea6 \n\tans+=fi(1,1,n,T[y].id,T[x].id);//\u52a0\u4e0ax->y\u7684\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u7684\u6743\u503c \n\tans%=P;\n}\n\nvoid adtree(int x,int d)//\u5c06\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u90fd\u52a0\u4e0ad \n{\n\tad(1,1,n,T[x].id,T[x].id+T[x].siz-1,d);\n}\n\nvoid sumtree(int x)//\u6c42\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u4e4b\u548c\n{\n\tans=fi(1,1,n,T[x].id,T[x].id+T[x].siz-1);\n}\n//\u6811\u94fe\u5256\u5206\u5b8c\u6210\uff01 \n\n\n\n//\u4ee5\u4e0b\u662f\u4e3b\u51fd\u6570orz \nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&m,&root,&P);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&T[i].w);\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tad(x,y);\n\t\tad(y,x);\n\t}\n\tT[root].dep=1;\n\tdfs1(root);\n\tdfs2(root,root);\n\tbuild(1,1,n);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint cmp,x,y,z;\n\t\tscanf(\"%d\",&cmp);\n\t\tif(cmp==1)//\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u90fd\u52a0\u4e0ad \n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\tz%=P;\n\t\t\tif(z)\n\t\t\tadroad(x,y,z);\n\t\t}\n\t\tif(cmp==2)//\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u7ed3\u70b9\u7684\u503c\u4e4b\u548c \n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tsumroad(x,y);\n\t\t\tans%=P;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\tif(cmp==3)//\u5c06\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u90fd\u52a0\u4e0ad \n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&z);\n\t\t\tz%=P;\n\t\t\tif(z)\n\t\t\tadtree(x,z);\n\t\t}\n\t\tif(cmp==4)//\u6c42\u4ee5x\u4e3a\u6839\u7ed3\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u7ed3\u70b9\u503c\u4e4b\u548c\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tsumtree(x);\n\t\t\tans%=P;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n//\u4ee3\u7801\u5b8c\u6210\uff01 \n```\n",
        "postTime": 1561630704,
        "uid": 91940,
        "name": "adog",
        "ccfLevel": 0,
        "title": "P3384\u9898\u89e3"
    },
    {
        "content": "## \u4e00\u6ce2\u7b80\u4ecb\n### \u6811\u94fe\u5256\u5206\u57fa\u672c\u5b9a\u4e49\n\u6811\u8def\u5f84\u4fe1\u606f\u7ef4\u62a4\u7b97\u6cd5\u3002\u5c06\u4e00\u68f5\u6811\u5212\u5206\u6210\u82e5\u5e72\u6761\u94fe\uff0c\u7528\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u6bcf\u6761\u94fe\uff0c\u590d\u6742\u5ea6\u4e3aO(logN)\u3002\u5176\u5b9e\u672c\u8d28\u662f\u4e00\u4e9b\u6570\u636e\u7ed3\u6784/\u7b97\u6cd5\u5728\u6811\u4e0a\u7684\u63a8\u5e7f\n### \u65b9\u6cd5\n\u5e38\u89c1\u7684\u8def\u5f84\u5256\u5206\u7684\u65b9\u6cd5\u662f\u8f7b\u91cd\u6811\u94fe\u5256\u5206\uff08\u542f\u53d1\u5f0f\u5256\u5206\uff09\n\n\u5c06\u6811\u4e2d\u7684\u8fb9\u5206\u4e3a\uff1a\u8f7b\u8fb9\u548c\u91cd\u8fb9 \u5b9a\u4e49size(X)\u4e3a\u4ee5X\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u4e2a\u6570\u3002 \u4ee4V\u4e3aU\u7684\u513f\u5b50\u8282\u70b9\u4e2dsize\u503c\u6700\u5927\u7684\u8282\u70b9\uff0c\u90a3\u4e48\u8fb9(U,V)\u88ab\u79f0\u4e3a\u91cd\u8fb9\uff0c\u6811\u4e2d\u91cd\u8fb9\u4e4b\u5916\u7684\u8fb9\u88ab\u79f0\u4e3a\u8f7b\u8fb9\u3002\n\u6027\u8d28\uff1a\u8f7b\u8fb9(U,V)\uff0csize(V)<=size(U)/2\u3002 \u4ece\u6839\u5230\u67d0\u4e00\u70b9\u7684\u8def\u5f84\u4e0a\uff0c\u4e0d\u8d85\u8fc7O(logN)\u6761\u8f7b\u8fb9\uff0c\u4e0d\u8d85\u8fc7O(logN)\u6761\u91cd\u8def\u5f84\u3002\n## \u5173\u4e8e\u672c\u9898  \n### \u9898\u76ee\u63cf\u8ff0\n\u5982\u9898\uff0c\u5df2\u77e5\u4e00\u68f5\u5305\u542bN\u4e2a\u7ed3\u70b9\u7684\u6811\uff08\u8fde\u901a\u4e14\u65e0\u73af\uff09\uff0c\u6bcf\u4e2a\u8282\u70b9\u4e0a\u5305\u542b\u4e00\u4e2a\u6570\u503c\uff0c\u9700\u8981\u652f\u6301\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n\u64cd\u4f5c1\uff1a \u683c\u5f0f\uff1a 1 x y z \u8868\u793a\u5c06\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u90fd\u52a0\u4e0az\n\n\u64cd\u4f5c2\uff1a \u683c\u5f0f\uff1a 2 x y \u8868\u793a\u6c42\u6811\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u4e4b\u548c\n\n\u64cd\u4f5c3\uff1a \u683c\u5f0f\uff1a 3 x z \u8868\u793a\u5c06\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u90fd\u52a0\u4e0az\n\n\u64cd\u4f5c4\uff1a \u683c\u5f0f\uff1a 4 x \u8868\u793a\u6c42\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u503c\u4e4b\u548c\n\n### \u8f93\u5165\u8f93\u51fa\u683c\u5f0f\n\u8f93\u5165\u683c\u5f0f\uff1a\n\u7b2c\u4e00\u884c\u5305\u542b4\u4e2a\u6b63\u6574\u6570N\u3001M\u3001R\u3001P\uff0c\u5206\u522b\u8868\u793a\u6811\u7684\u7ed3\u70b9\u4e2a\u6570\u3001\u64cd\u4f5c\u4e2a\u6570\u3001\u6839\u8282\u70b9\u5e8f\u53f7\u548c\u53d6\u6a21\u6570\uff08\u5373\u6240\u6709\u7684\u8f93\u51fa\u7ed3\u679c\u5747\u5bf9\u6b64\u53d6\u6a21\uff09\u3002\n\n\u63a5\u4e0b\u6765\u4e00\u884c\u5305\u542bN\u4e2a\u975e\u8d1f\u6574\u6570\uff0c\u5206\u522b\u4f9d\u6b21\u8868\u793a\u5404\u4e2a\u8282\u70b9\u4e0a\u521d\u59cb\u7684\u6570\u503c\u3002\n\n\u63a5\u4e0b\u6765N-1\u884c\u6bcf\u884c\u5305\u542b\u4e24\u4e2a\u6574\u6570x\u3001y\uff0c\u8868\u793a\u70b9x\u548c\u70b9y\u4e4b\u95f4\u8fde\u6709\u4e00\u6761\u8fb9\uff08\u4fdd\u8bc1\u65e0\u73af\u4e14\u8fde\u901a\uff09\n\n\u63a5\u4e0b\u6765M\u884c\u6bcf\u884c\u5305\u542b\u82e5\u5e72\u4e2a\u6b63\u6574\u6570\uff0c\u6bcf\u884c\u8868\u793a\u4e00\u4e2a\u64cd\u4f5c\uff0c\u683c\u5f0f\u5982\u4e0b\uff1a\n\n\u64cd\u4f5c1\uff1a 1 x y z\n\n\u64cd\u4f5c2\uff1a 2 x y\n\n\u64cd\u4f5c3\uff1a 3 x z\n\n\u64cd\u4f5c4\uff1a 4 x\n\n### \u8f93\u51fa\u683c\u5f0f\uff1a\n\u8f93\u51fa\u5305\u542b\u82e5\u5e72\u884c\uff0c\u5206\u522b\u4f9d\u6b21\u8868\u793a\u6bcf\u4e2a\u64cd\u4f5c2\u6216\u64cd\u4f5c4\u6240\u5f97\u7684\u7ed3\u679c\uff08\u5bf9P\u53d6\u6a21\uff09\n\n\u6811\u5256\u662f\u4e00\u79cd\u6781\u5176\u5f3a\u5927\u7684\u6811\u4e0a\u7b97\u6cd5\uff0c\u4e0d\u540c\u4e8e\u6811\u4e0a\u7684\u5176\u4ed6\u7c7b\u578b\u64cd\u4f5c\uff0c\u6811\u5256\u901a\u5e38\u4f9d\u636e\u5b50\u6811\u5927\u5c0f\uff08\u91cd\u91cf\uff09\u5c06\u6811\u63b0\u5f00\u6210\u4e3a\u4e00\u6761\u6761\u72ec\u7acb\u4e14\u5e73\u884c\u7684\u94fe\uff0c\u8fd9\u5c31\u8981\u6c42\u901a\u8fc7dfs\u7684\u65b9\u5f0f\u8fdb\u884c\u6240\u8c13\u201c\u5256\u201d\u7684\u90e8\u5206\u3002\n\n#### \u7b2c\u4e00\u904ddfs\n\u6c42\u51fa\u6811\u6bcf\u4e2a**\u7ed3\u70b9\u7684\u6df1\u5ea6**depth[x]\uff0c\u5176\u4e3a\u6839\u7684**\u5b50\u6811\u5927\u5c0f**weight[x]\u4ee5\u53ca**\u7956\u5148**\u7684\u4fe1\u606ffather[x]\n```cpp\nvoid dfs(int root,int f)\n{\n    depth[root]=depth[f]+1;\n    father[root]=f;\n    weight[root]++;\n    int maxnum=0;\n    for(int i=head[root];i;i=e[i].next)//\u6cbf\u8fb9\u5faa\u73af \n    {\n        int to=e[i].to;\n        if(to==f)\n        {\n            continue;\n        }\n        dfs(to,root);\n        weight[root]=weight[to]+weight[root];\n        if(weight[to]>maxnum)\n        {\n            maxnum=weight[to];\n            heaviestson[root]=to;\n        }\n    }\n}\n```\n#### \u7b2c\u4e8c\u904ddfs\n\u4ee5\u6839\u8282\u70b9\u4e3a\u8d77\u70b9\uff0c\u5411\u4e0b\u62d3\u5c55\u6784\u5efa\u91cd\u94fe\uff0c**\u9009\u62e9\u6700\u5927\u7684\u4e00\u4e2a\u5b50\u6811\u7684\u6839 _\u7ee7\u627f\u5f53\u524d\u91cd\u94fe_ **\u3002\u5176\u4f59\u8282\u70b9\uff0c\u90fd**\u4ee5\u8be5\u8282\u70b9\u4e3a\u8d77\u70b9\u5411\u4e0b _\u91cd\u65b0_ \u62c9\u4e00\u6761\u91cd\u94fe**\u3002\u7ed9\u6bcf\u4e2a\u7ed3\u70b9\u5206\u914d\u4e00\u4e2a\u4f4d\u7f6e\u7f16\u53f7\uff0c\u6bcf\u6761\u91cd\u94fe\u5c31\u76f8\u5f53\u4e8e\u4e00\u6bb5\u533a\u95f4\uff0c\u518d\u628a**\u6240\u6709\u7684\u91cd\u94fe\u9996\u5c3e\u76f8\u63a5\uff0c\u653e\u5230\u540c\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u4e0a**\n```cpp\nvoid dfs(int root,int topnode)\n{\n    segid++;//\u7ebf\u6bb5\u6811\u6570\u7ec4\u4e2d\u7684\u4f4d\u7f6e\u7f16\u53f7 \n    b[segid]=a[root];\n    pos[root]=segid;\n    top[root]=topnode;\n    if(weight[root]==1/*heaviestson[root]==0*/)//\u4e3a\u53f6\u8282\u70b9\n    {\n        return;\n    }\n    dfs(heaviestson[root],topnode);\n    for(int i=head[root];i;i=e[i].next)\n    {\n        int to=e[i].to;\n        if(to==father[root]||to==heaviestson[root])\n        {\n            continue;\n        }\n        dfs(to,to);\n    }\n}\n```\n\u7531\u6b64\u6211\u4eec\u5c31\u628a\u6811\u8fdb\u884c\u4e86\u4e00\u6ce2\u9ad8\u7ea7\u7684\u62c6\u5206\uff0c\u50cf\u8fd9\u6837\u7531\u539f\u56fe\uff1a\n![\u539f\u6765\u7684\u6811](https://cdn.luogu.com.cn/upload/pic/2319.png)\n\n\u53d8\u6210\u4e86\u7ebf\u6bb5\u6811\u7684\u539f\u59cb\u6570\u7ec4\uff1a2,1,3,4,5\n\n\u524d\u4e09\u4f4d\u4e3a\u91cd\u94fe1,4\u30015\u4e3a\u4e24\u6761\u8f7b\u94fe\uff0c\u6613\u89c1x\u53ca\u4e4b\u540eweight[x]-1\u4f4d\u5373\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u3002\n\n#### \u7ebf\u6bb5\u6811\n\u5c31\u662f\u666e\u901a\u7684\u7ebf\u6bb5\u6811\u4e94\u5927\u51fd\u6570\u4e24\u5927\u6570\u7ec4\uff08\u8fd8\u662f\u56db\u500d\u7a7a\u95f4\uff09\uff0c\u4f46**\u6ce8\u610f**\uff0c\u8bfb\u5165\u539f\u59cb\u6570\u636e\u65f6\u4f7f\u7528\u7684\u4e3aa\u6570\u7ec4\uff0c\u4e24\u6b21dfs\u4e4b\u540e\u5c06\u62c6\u5206\u8fc7\u540e\u7684\u6811\u5b58\u5165b\u6570\u7ec4\uff0c\u518d\u7528b\u6570\u7ec4\u8fdb\u884c\u7ebf\u6bb5\u6811\u7684\u5efa\u6811build()\u3002\n\n\u9664\u6b64\u4e4b\u5916\uff0c\u8fd8\u8981\u52a0\u4e0a\u4e00\u4e9b\u4e1c\u897f\uff0c\u56e0\u4e3a\u5728\u6811\u4e0a\u9664\u4e86\u5b50\u6811\u66f4\u65b0\u6c42\u548c\uff08\u8fde\u7eed\u533a\u95f4\uff0c\u7528\u539f\u7248\u7ebf\u6bb5\u6811\u89e3\u51b3\uff09\u4ee5\u5916\uff0c\u8fd8\u6709**\u8def\u5f84\u95ee\u9898\uff0c\u9700\u8981\u8df3\u94fe\u66f4\u65b0\u3001\u6c42\u548c**\uff0c\u9700\u8981\u7528\u53e6\u5916\u4e24\u4e2a\u51fd\u6570\u89e3\u51b3\uff1a\n\n#### \u8df3\u94fe\u66f4\u65b0 \u8df3\u94fe\u67e5\u548c\n\u601d\u8def\u7b80\u5355\uff0c\u76f4\u63a5\u4ece\u5f53\u524d\u4e24\u4e2a\u7aef\u70b9\u5411\u4e0a\u722c\u6811\u5c31\u884c\uff0c\u4f46\u4e0e\u679a\u4e3e\u3001\u500d\u589e\u7b49\u65b9\u6cd5\u4e0d\u540c\uff0c\u8fd9\u91cc\u4e00\u6b21\u722c\u8fc7\u4e00\u6761\u94fe\uff0c\u76f4\u63a5\u4e0a\u5230\u94fe\u9876\uff0c\u518d\u8fdb\u4e0b\u4e00\u6761\u94fe\uff0c\u76f4\u5230\u4e24\u70b9\u722c\u5230\u540c\u4e00\u6761\u94fe\u4e3a\u6b62\uff0c\u6b64\u65f6\u5373\u627e\u5230\u6700\u77ed\u8def\u5f84\uff0c\u722c\u8fc7\u7684\u94fe\u4e0e\u7aef\u70b9\u6240\u5728\u94fe\uff08\u7aef\u70b9\u4ee5\u4e0a\u7684\u90e8\u5206\uff09\u5373\u4e3a\u6700\u77ed\u8def\u5f84\uff0c\u8bb0\u5f55\u4e00\u4e0b\u5373\u53ef\uff0c\u518d\u5206\u6210\u533a\u95f4\u7528\u7ebf\u6bb5\u6811\u66f4\u65b0\u3001\u6c42\u548c\u3002\n\n```cpp\nvoid Tree_update(int x/*\u8282\u70b91*/,int y/*\u8282\u70b92*/,int v)//\u5256\u5206\u540e\u7684\u8df3\u94fe(\u5373\u4e0d\u540c\u94fe\u4e4b\u95f4)\u66f4\u65b0\n{\n    while(topnode[x]!=topnode[y])\n    {\n        if(depth[topnode[x]]<depth[topnode[y]])\n        {\n            swap(x,y);\n        }\n        update(1,1,n,position[topnode[x]],position[x],v);\n        x=father[topnode[x]];\n    }\n    if(depth[x]>depth[y])\n    {\n        swap(x,y);\n    }\n    update(1,1,n,position[x],position[y],v);\n}\nint Tree_query(int x/*\u8282\u70b91*/,int y/*\u8282\u70b92*/)//\u5256\u5206\u540e\u7684\u8df3\u94fe\u67e5\u548c\uff0c\u627e\u5230\u8de8\u94fe\u8def\u5f84\u7684\u548c\n{\n    int ans=0;\n    while(topnode[x]!=topnode[y])\n    {\n        if(depth[topnode[x]]<depth[topnode[y]])\n        {\n            swap(x,y);\n        }\n        ans+=query(1,1,n,position[topnode[x]],position[x]);\n        x=father[topnode[x]];\n    }\n    if(depth[x]>depth[y])\n    {\n        swap(x,y);\n    }\n    ans+=query(1,1,n,position[x],position[y]);\n    return ans;\n}\n```\n\u4e0d\u5f97\u4e0d\u8bf4\u7b97\u6cd5\u601d\u8def\u6781\u5176\u5de7\u5999\uff01\n\n\n### \u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\n```cpp\n#include <bits/stdc++.h>\n#define MAXN 100010\n#define int long long\nusing namespace std;\nint n,m,R,p;\nstruct edge\n{\n    int to,next;\n} e[MAXN<<1];\nint ei=0;\nint head[MAXN];\nvoid add(int x,int y)\n{\n    ei++;\n    e[ei].to=y;\n    e[ei].next=head[x];\n    head[x]=ei;\n}\nint dep[MAXN];//\u8282\u70b9\u6df1\u5ea6\nint fa[MAXN];//\u91cd,\u5373\u94fe\u957f \nint hson[MAXN];//\u91cd\u513f\u5b50\uff0c\u5373\u91cd\u6700\u5927\u7684\u513f\u5b50 \nint wei[MAXN];//\u9876\u70b9\u7236\u8282\u70b9\nvoid dfs1(int o,int f)\n{\n    dep[o]=dep[f]+1;\n    fa[o]=f;\n    wei[o]++;\n    int mx=0;\n    for(int i=head[o];i;i=e[i].next)\n    {\n        int t=e[i].to;\n        if(t==f)\n        {\n            continue;\n        }\n        dfs1(t,o);\n        wei[o]+=wei[t];\n        if(wei[t]>mx)\n        {\n            mx=wei[t];\n            hson[o]=t;\n        }\n    }\n}\n//\u627e\u5230\u94fe\u7684\u8282\u70b9\u6df1\u5ea6\uff0c\u91cd\uff0c\u9876\u70b9\u7236\u8282\u70b9\uff0c\u91cd\u513f\u5b50\n//dfs1(RT,RT);(\u7528\u6cd5)\uff0cRT\u4e3a\u6839\u8282\u70b9\nint a[MAXN];\nint b[MAXN];\nint top[MAXN];\nint pos[MAXN];\nint segid=0;\nint segtr[MAXN<<2];\nint Plus[MAXN<<2];\nvoid dfs2(int o,int tp)\n{\n    segid++;\n    b[segid]=a[o];\n    pos[o]=segid;\n    top[o]=tp;\n    if(wei[o]==1/*hson[o]==0*/)//\u4e3a\u53f6\u8282\u70b9\n    {\n        return;\n    }\n    dfs2(hson[o],tp);\n    for(int i=head[o];i;i=e[i].next)\n    {\n        int t=e[i].to;\n        if(t==fa[o]||t==hson[o])\n        {\n            continue;\n        }\n        dfs2(t,t);\n    }\n}\n//dfs2(RT,RT);(\u7528\u6cd5)\uff0cRT\u4e3a\u6839\u8282\u70b9\nvoid pushup(int o)//\u5e38\u89c4\u7ebf\u6bb5\u6811\n{\n    segtr[o]=segtr[o<<1]+segtr[o<<1|1];\n} \nvoid build(int o,int l,int r)\n{\n    if(l==r)\n    {\n        segtr[o]=b[l];\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(o<<1,l,mid);\n    build(o<<1|1,mid+1,r);\n    pushup(o);\n}\nvoid pushdown(int o,int l,int r)\n{\n    if(Plus[o]==0)\n    {\n        return;\n    }\n    int mid=(l+r)>>1;\n    segtr[o<<1]+=Plus[o]*(mid-l+1);\n    segtr[o<<1|1]+=Plus[o]*(r-mid);\n    Plus[o<<1]+=Plus[o];\n    Plus[o<<1|1]+=Plus[o];\n    Plus[o]=0;\n}\nvoid update(int o,int l,int r,int x,int y,int v)//\u66f4\u65b0\u5b50\u6811:x(\u5b50\u6811\u6839\u8282\u70b9)\u5230x+wei[x]-1(\u5b50\u6811\u7684\u91cd)\n{\n    if(x<=l&&y>=r)\n    {\n        Plus[o]+=v;\n        segtr[o]+=v*(r-l+1);\n        return;\n    }\n    pushdown(o,l,r);\n    int mid=(l+r)>>1;\t\t\n    if(x<=mid)\n    {\n        update(o<<1,l,mid,x,y,v);\n    }\n    if(y>mid)\n    {\n        update(o<<1|1,mid+1,r,x,y,v);\n    }\n    pushup(o);\n}\nint query(int o,int l,int r,int x,int y)//\u5b50\u6811\u67e5\u548c:x(\u5b50\u6811\u6839\u8282\u70b9)\u5230x+wei[x]-1(\u5b50\u6811\u7684\u91cd)\n{\n    if(x<=l&&y>=r)\n    {\n        return segtr[o];\n    }\n    pushdown(o,l,r);\n    int ans=0;\n    int mid=(l+r)>>1;\n    if(x<=mid)\n    {\n        ans+=query(o<<1,l,mid,x,y);\n        ans%=p;\n    }\n    if(y>mid)\n    {\n        ans+=query(o<<1|1,mid+1,r,x,y);\n        ans%=p;\n    }\n    return ans%p;\n}\nvoid Tree_update(int x/*\u8282\u70b91*/,int y/*\u8282\u70b92*/,int v)//\u5256\u5206\u540e\u7684\u8df3\u94fe(\u5373\u4e0d\u540c\u94fe\u4e4b\u95f4)\u66f4\u65b0\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])\n        {\n            swap(x,y);\n        }\n        update(1,1,n,pos[top[x]],pos[x],v);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])\n    {\n        swap(x,y);\n    }\n    update(1,1,n,pos[x],pos[y],v);\n}\nint Tree_query(int x/*\u8282\u70b91*/,int y/*\u8282\u70b92*/)//\u5256\u5206\u540e\u7684\u8df3\u94fe\u67e5\u548c\uff0c\u627e\u5230\u8de8\u94fe\u8def\u5f84\u7684\u548c\n{\n    int ans=0;\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])\n        {\n            swap(x,y);\n        }\n        ans+=query(1,1,n,pos[top[x]],pos[x]);\n        ans%=p;\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])\n    {\n        swap(x,y);\n    }\n    ans+=query(1,1,n,pos[x],pos[y]);\n    ans%=p;\n    return ans%p;\n}\nsigned main()\n{\n    scanf (\"%lld%lld%lld%lld\",&n,&m,&R,&p);\n    for(int i=1;i<=n;i++)\n    {\n        scanf (\"%lld\",&a[i]);\n    }\n    int x,y,z;\n    for(int i=1;i<n;i++)\n    {\n        scanf (\"%lld%lld\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }//\u5efa\u8fb9 \n    dfs1(R,R);\n    dfs2(R,R);\n    build(1,1,n);\n    int per;\n    for(int i=1;i<=m;i++)\n    {\n        scanf (\"%lld\",&per);\n        if(per==1)\n        {\n            scanf (\"%lld%lld%lld\",&x,&y,&z);\n            if(x>y)\n            {\n                swap(x,y);\n            }\n            Tree_update(x,y,z);\n        }\n        else if(per==2)\n        {\n            scanf (\"%lld%lld\",&x,&y);\n            if(x>y)\n            {\n                swap(x,y);\n            }\n            printf (\"%lld\\n\",Tree_query(x,y)%p);\n        }\n        else if(per==3)\n        {\n            scanf (\"%lld%lld\",&x,&z);\n            update(1,1,n,pos[x],pos[x]+wei[x]-1,z);\n        }\n        else if(per==4)\n        {\n            scanf (\"%lld\",&x);\n            printf (\"%lld\\n\",query(1,1,n,pos[x],pos[x]+wei[x]-1)%p);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1559031182,
        "uid": 108750,
        "name": "quotient_0",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "~~[\u535a\u5ba2](https://tle666.github.io/)\u98df\u7528\u66f4\u4f73~~\n\n# **Introduction**\n\n\u5f53\u6211\u4eec\u60f3\u8981\u540c\u65f6\u5b8c\u6210\n\n- \u6c42\u6811\u4e0a$u$\u5230$v$\u7684\u6743\u503c\u548c\n- \u5c06\u6811\u4e0a$u$\u5230$v$\u7684\u6743\u503c\u90fd\u52a0$d$\n\n\u8fd9\u4e24\u79cd\u64cd\u4f5c\u65f6\uff0c\u4f1a\u600e\u4e48\u505a\u5462\uff1f\n\n\u76f8\u4fe1\u6211\u4eec\u5bf9\u4e8e\u8fd9\u4e24\u79cd\u64cd\u4f5c\u5206\u522b\u90fd\u4f1a\u89e3\u51b3\uff0c\u4f46\u662f\u5982\u679c\u4e00\u65e6\u653e\u5230\u540c\u4e00\u9053\u9898\u91cc\uff0c\u6211\u4eec\u5c31\u4f1a\u675f\u624b\u65e0\u7b56\u4e86\u3002\n\n\u6811\u94fe\u5256\u5206\u4fbf\u7531\u6b64\u800c\u6765\u4e86\u3002\n\n\u524d\u7f6e\u6280\u80fd\uff1a\u7ebf\u6bb5\u6811\uff08\u91cd\u8981\uff09 & \u500d\u589e\u6c42 $LCA$\uff08\u4e0d\u5fc5\u987b\uff09\n\n# **Definition & Steps**\n\n> \u6811\u5256\u662f\u901a\u8fc7\u5c06\u4e00\u68f5\u6709\u6839\u6811\u5206\u6210\u591a\u4e2a\u94fe\uff0c\u7136\u540e\u5229\u7528\u5404\u79cd\u6570\u636e\u7ed3\u6784\uff08\u5982\u7ebf\u6bb5\u6811\u7b49\uff09\u6765\u7ef4\u62a4\u8fd9\u68f5\u94fe\uff0c\u4ece\u800c\u95f4\u63a5\u5730\u7ef4\u62a4\u8fd9\u68f5\u6811\u3002\n\n\u9996\u5148\uff0c\u4e3a\u4e86\u65b9\u4fbf\u6211\u4eec\u5bf9\u6811\u5256\u7684\u7406\u89e3\uff0c\u6211\u4eec\u9700\u8981\u77e5\u9053\u4e00\u4e9b\u5f88\u57fa\u7840\u5f88\u91cd\u8981\u7684\u6982\u5ff5\uff1a\n\n- $size_i$\uff1a\u4ee5$i$\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u7ed3\u70b9\u4e2a\u6570\n- $dfn_i$\uff1a$i$\u7ed3\u70b9\u7684$dfs$\u5e8f\uff0c\u5373\u5176\u65b0\u7f16\u53f7\n- $pre_i$\uff1a$dfn$\u7684\u53cd\u51fd\u6570\uff0c\u82e5$dfn_i\\ =\\ j$\uff0c\u5219$pre_j\\ =\\ i$\uff0c\u5373$dfn_{pre_i}\\ =\\ 1$\u3002\n- $fa_i$\uff1a$i$\u7ed3\u70b9\u7684\u7236\u4eb2\u7ed3\u70b9\uff08\u9664$dfn$\u548c$pre$\u5916\uff0c\u4e00\u5207\u7ed3\u70b9\u7f16\u53f7\u975e\u7279\u6b8a\u8bf4\u660e\u5747\u4e3a\u9ed8\u8ba4\u7f16\u53f7\uff09\n- $dep_i$\uff1a$i$\u7684\u6df1\u5ea6\uff0c\u9ed8\u8ba4\u6839\u7684\u6df1\u5ea6\u4e3a$1$\uff0c\u5373$dep_{root}\\ =\\ 1$\n- $w_i$\uff1a$i$\u7ed3\u70b9\u7684\u6743\u503c\n- \u91cd\u513f\u5b50\uff1a\u4e00\u4e2a\u7ed3\u70b9\u6240\u6709\u5b50\u7ed3\u70b9\u4e2d$size$\u6700\u5927\u7684\u5b50\u8282\u70b9\uff0c\u7528$wson[i]$\u8868\u793a\n- \u8f7b\u513f\u5b50\uff1a\u4e00\u4e2a\u7ed3\u70b9\u6240\u6709\u5b50\u7ed3\u70b9\u4e2d\u9664\u4e86\u91cd\u513f\u5b50\u7684\u5176\u5b83\u6240\u6709\u5b50\u7ed3\u70b9\n- \u91cd\u8fb9\uff1a\u4e00\u4e2a\u7ed3\u70b9\u548c\u5b83\u7684\u91cd\u513f\u5b50\u7684\u8fde\u8fb9\n- \u8f7b\u8fb9\uff1a\u4e00\u4e2a\u8282\u70b9\u548c\u5b83\u7684\u8f7b\u513f\u5b50\u7684\u8fde\u8fb9\n- \u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u9996\u5c3e\u987a\u6b21\u8fde\u63a5\u800c\u6210\u7684\u94fe\uff08\u8def\u5f84\uff09\n- \u8f7b\u94fe\uff1a\u6709\u591a\u6761\u8f7b\u8fb9\u9996\u5c3e\u987a\u6b21\u8fde\u63a5\u800c\u6210\u7684\u94fe\uff08\u8def\u5f84\uff09\n- $top_i$\uff1a$i$\u6240\u5728\u7684\u91cd\u94fe\u7684\u94fe\u9996\uff08\u53ef\u4ee5\u8bc1\u660e\u6bcf\u4e2a\u7ed3\u70b9\u90fd\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff09\n\n\u4e0a\u4e00\u5f20\u767e\u5ea6\u767e\u79d1\u7684\u56fe\uff1a\n\n![\u56fe\u7247\u6ca1\u4e86\u5417\uff1f\u53ef\u4ee5\u5230\u767e\u5ea6\u767e\u79d1\u4e0a\u770b](https://s2.ax1x.com/2019/02/02/k8LSfK.jpg)\n\n\u5982\u679c\u6211\u4eec\u60f3\u77e5\u9053$1$\u7684\u91cd\u513f\u5b50\u662f\u8c01\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u9012\u5f52\u5730\u6c42\u4e00\u4e0b\u5b83\u6bcf\u68f5\u5b50\u6811\u7684$size$\u5373\u53ef\uff1b\n\n\u540c\u65f6\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u987a\u4fbf\u7ef4\u62a4\u51fa\u6240\u6709\u7ed3\u70b9\u7684 $fa$ \u548c $dep$\n\n\u9012\u5f52\u4f2a\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nvoid dfs1(int u, int f) // u \u5f53\u524d\u7ed3\u70b9\uff0cf \u662f u \u7684\u7236\u4eb2\u7ed3\u70b9\n    size[u] = 1\n    for each v that connects to u : // u \u7684\u5b50\u7ed3\u70b9\n    \tif(v != f) // v \u4e0d\u662f u \u7684\u7236\u4eb2\n            fa[v] = u // \u8bf4\u660e v \u662f u \u7684\u5b50\u7ed3\u70b9\n            dep[v] = dep[u] + 1 // \u6df1\u5ea6\u7ef4\u62a4\n            dfs(v, u) // \u7ee7\u7eed\u9012\u5f52\n            size[u] += size[v] // \u5c06\u5b50\u6811\u7684 size \u52a0\u5230\u8fd9\u68f5\u6811\u7684 size \u4e0a\n            if(size[wson[u]] < size[v]) wson[u] = v // \u66f4\u65b0\u91cd\u513f\u5b50\n```\n\n\u53ef\u4ee5\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\n\n\u8fd9\u6837\uff0c\u6211\u4eec\u5c31\u6c42\u51fa\u4e86\u6bcf\u4e2a\u7ed3\u70b9\u7684\u91cd\u513f\u5b50 $wson$ \uff1b\n\n\u7279\u522b\u5730\uff0c\u6bcf\u4e2a\u53f6\u5b50\u7ed3\u70b9\u7684\u91cd\u513f\u5b50\u90fd\u4e3a $0$\n\n\u6bcf\u4e2a\u6807\u7ea2\u70b9\u7684\u7ed3\u70b9\u90fd\u662f\u4e00\u6761\u91cd\u94fe\u7684\u94fe\u9996\uff08$top$\uff09\uff0c\n\n\u800c\u52a0\u7c97\u7684\u8fb9\u5219\u662f\u91cd\u94fe\u3002\n\n\u6bd4\u5982\uff0c$1=>4=>9=>13=>14$ \u5c31\u662f\u4e00\u6761\u91cd\u94fe\uff0c\u800c $2=>6=>11$ \u4e5f\u662f\u53e6\u4e00\u6761\u91cd\u94fe\uff1b\n\n\u53e6\u5916\u6211\u4eec\u4f1a\u6ce8\u610f\u5230\uff0c\u9664\u4e86\u6839\u8282\u70b9\u4ee5\u5916\u7684\u6240\u6709\u91cd\u94fe\u94fe\u9996\u90fd\u662f\u8f7b\u513f\u5b50\uff0c\n\n\u4f8b\u5982 $top[3]\\ =\\ 3$\uff1b\n\n\n\n\u56de\u987e\u4e00\u4e0b\uff0c\u8fd8\u6709\u54ea\u4e9b\u4fe1\u606f\u6ca1\u6709\u7ef4\u62a4\u5462\uff1f\n\n$dfn,\\ pre,\\ top$ \n\n\u5176\u5b9e\uff0c\u8fd9\u4e09\u4e2a\u53ea\u9700\u8981\u53e6\u4e00\u4e2a\u9012\u5f52\u51fd\u6570\u5c31\u8db3\u591f\u5566\uff01\n\n```cpp\nvoid dfs2(int u, int tp) // u \u662f\u5f53\u524d\u7ed3\u70b9\uff0ctp \u662f u \u6240\u5728\u91cd\u94fe\u7684\u94fe\u9996\n    top[u] = tp\n    dfn[u] = ++tot // tot \u662f\u65f6\u95f4\u6233\n    pre[tot] = u // pre \u662f dfn \u7684\u53cd\u51fd\u6570\n    if(wson[u]) dfs2(wson[u], tp); // \u53ea\u8981 u \u6709\u91cd\u513f\u5b50\uff0c\u90a3\u5c31\u53ef\u4ee5\u7ee7\u7eed\u4e0b\u53bb\n    for each v that connects to u : \n\t\tif(v != fa[u] && v != wson[u]) // v \u662f u \u7684\u8f7b\u513f\u5b50\n            dfs2(v, v); // \u8f7b\u513f\u5b50\u662f\u91cd\u94fe\u7684\u94fe\u9996\n```\n\n\u56fe\u4e2d\u8fb9\u4e0a\u7684\u6570\u5b57\u5c31\u662f $dfs2$ \u9012\u5f52\u5730\u987a\u5e8f\uff0c\u4e0d\u660e\u767d\u7684\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u3002\n\n\u68c0\u6d4b\u4e00\u4e0b\u4f60\u6709\u6ca1\u6709\u660e\u767d\uff1a$2$ \u7684 $dfn$ \u662f\u51e0\uff1f$7$ \u7684 $pre$ \u662f\u51e0\uff1f\n\n$Answer:\\ 10,\\ 8$\u3002\n\n**\u597d\u4e86\uff0c\u6811\u94fe\u5256\u5206\u9636\u6bb5\u5230\u6b64\u7ed3\u675f\u3002**\n\n\u5c06\u8fd9\u68f5\u6811\u5256\u5206\u6210\u4e86\u8bb8\u591a\u94fe\uff0c\u73b0\u5728\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86~\n\n> \u5199\u4e0a\u4e86\u4e00\u6bb5\u5e26\u4fee\u6539\u67e5\u8be2\u7684\u7ebf\u6bb5\u6811\u6a21\u677f\u3002\u3002\u3002\n\n\u73b0\u5728\u8f6e\u5230\u5904\u7406\u95ee\u9898\u7684\u9636\u6bb5\u4e86\u3002\n\n\u4e3a\u4e86\u4fbf\u4e8e\u7406\u89e3\uff0c\u6211\u4eec\u5c31\u5148\u5b9e\u73b0\u4e24\u4e2a\u6700\u57fa\u7840\u7684\u64cd\u4f5c\u5427\uff1a\n\n\u8def\u5f84\u70b9\u6743\u6c42\u548c\u3001\u8def\u5f84\u70b9\u6743\u4fee\u6539\n\n\u5927\u4f53\u601d\u8def\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u628a\u8fd9\u6761\u8def\u5f84\u5206\u6210\u82e5\u5e72\u6761\u539f\u6765\u7684\u91cd\u94fe\uff0c\u7136\u540e\u4f9d\u6b21\u5b9e\u73b0\u3002\n\n\u4e3e\u4e2a\u6817\u5b50\uff1a\u6c42 $9$ \u5230 $11$ \u8def\u5f84\u4e0a\u7684\u70b9\u6743\u4e4b\u548c\uff08\u8fd8\u662f\u4e0a\u9762\u90a3\u5f20\u56fe\u3002\u3002\uff09\n\n![\u56fe\u7247\u6ca1\u4e86\u5417\uff1f\u53ef\u4ee5\u5230\u767e\u5ea6\u767e\u79d1\u4e0a\u770b](https://s2.ax1x.com/2019/02/02/k8LSfK.jpg)\n\n\u4e3a\u4e86\u7b80\u5355\u8d77\u89c1\uff0c\u6211\u4eec\u6682\u5b9a\u6bcf\u4e2a\u70b9\u7684\u70b9\u6743\u662f\u5b83\u7684\u7f16\u53f7\uff08\u4e0d\u662f $dfn$\uff09\u3002\n\n\u8fd9\u4e2a\u548c\u500d\u589e\u6c42 $LCA$ \u6709\u70b9\u50cf\u3002\n\n\u5148\u627e\u5230 $dep$ \u66f4\u6df1\u7684\u7ed3\u70b9\uff0c$11$\uff08$dep[11]\\ >\\ dep[9]$\uff09\n\n\u5c06\u7b54\u6848 $res$ \u52a0\u4e0a $11$ \u5230 $top[11]$ \u7684\u70b9\u6743\u548c\n\n\u6211\u4eec\u53ef\u4ee5\u7528\u4e8b\u5148\u7ef4\u62a4\u597d\u7684 $dfn$ \u6765\u5e2e\u52a9\n\n\u7531\u4e8e $top[11]\\ =\\ 2$\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u6c42 $2=>11$ \u7684\u548c\n\n\u6211\u4eec\u53d1\u73b0\u56e0\u4e3a\u8fd9\u662f\u4e00\u6761\u91cd\u94fe\uff0c\u6240\u4ee5\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u6bcf\u4e2a\u70b9\u7684 $dfn$ \u90fd\u662f\u8fde\u7eed\u7684\uff01\n\n\u7ebf\u6bb5\u6811\u6709\u7528\u4e86\uff0c\u6ce8\u610f $dfn[top[11]] < dfn[11]$\n\n`res += query(root, dfn[top[11]], dfn[11])`\n\n\u8fd9\u662f\uff0c\u64cd\u4f5c\u53d8\u6210\u4e86\u6c42 $res\\ +\\ 9=>11$ \u7684\u8def\u5f84\u70b9\u6743\u548c\u3002 \n\n\u6240\u4ee5\u6211\u4eec\u5c06 $11$ \u53d8\u4e3a $fa[top[11]]\\ =\\ 1$\n\n\u8fd9\u662f\uff0c\u6211\u4eec\u53d1\u73b0 $1$ \u548c $9$ \u5171\u94fe\u4e86\u3002\n\n\u6240\u4ee5\u50cf\u521a\u624d\u4e00\u6837\uff0c\n\n`res += query(root, dfn[1], dfn[9])`\n\n\u5373\u53ef\uff01\n\n\u5c06\u4e0a\u9762\u7684\u6b65\u9aa4\u8f6c\u5316\u6210\u4ee3\u7801\uff1a\n\n```cpp\nvoid Qsum(int u, int v) {\n    int left, right, res = 0;\n    while(top[u] != top[v]) { // \u53ea\u8981\u4e0d\u5171\u94fe\n        if(dep[top[u]] > dep[top[v]]) swap(u, v); // \u6bcf\u6b21\u90fd\u8981\u8ba9 top \u6df1\u4e00\u4e9b\u7684\u5f80\u4e0a\u8df3\n        res += query(root, dfn[top[v]], dfn[v]);\n        v = fa[top[v]];\n    } left = dfn[u], right = dfn[v];\n    if(left > right) swap(left, right); // \u6ce8\u610f\u5927\u5c0f\u5173\u7cfb\uff01\n    res += query(root, left, right);\n    return res;\n}\n```\n\n\u5f88\u7b80\u5355\u5427\uff01\n\n\u4fee\u6539\u64cd\u4f5c\u7c7b\u4f3c\uff0c\n\n```cpp\nvois Qchange(int u, int v, int d) { // u \u5230 v \u7684\u8def\u5f84\u4e0a\u70b9\u6743\u52a0 d\n    int left, right;\n    while(top[u] != top[v]) {\n        if(dep[top[u]] > dep[top[v]]) swap(u, v);\n        change(root, dfn[top[v]], dfn[v], d);\n        v = fa[top[v]];\n    } left = dfn[u], right = dfn[v];\n    if(left > right) swap(left, right);\n    change(root, left, right, d);\n}\n```\n\n\u9664\u4e86\u8fd9\u4e24\u4e2a\u57fa\u7840\u64cd\u4f5c\u4ee5\u5916\uff0c\u8fd8\u6709\u4e00\u7c7b\u6bd4\u8f83\u5e38\u89c1\u7684\u64cd\u4f5c\uff1a\u5b50\u6811\u3002\n\n\u5176\u5b9e\u8fd9\u79cd\u64cd\u4f5c\u6bd4\u521a\u624d\u4e24\u79cd\u8fd8\u7b80\u5355\u3002\n\n\u6211\u4eec\u8003\u8651\u4ee5 $2$ \u4e3a\u6839\u7684\u5b50\u6811\uff1a\n\n![\u56fe\u7247\u6ca1\u4e86\u5417\uff1f\u53ef\u4ee5\u5230\u767e\u5ea6\u767e\u79d1\u4e0a\u770b](https://s2.ax1x.com/2019/02/02/k8LSfK.jpg)\n\n\u4e0d\u96be\u53d1\u73b0\uff0c\u8fd9\u68f5\u5b50\u6811\u91cc\u6240\u6709\u7ed3\u70b9\u7684 $dfn$ \u662f\u8fde\u7eed\u7684\u3002\u4e3a\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3a $dfn$ \u662f\u901a\u8fc7 $dfs$ \u5f97\u5230\u7684\u3002\n\n\u56e0\u6b64\u5f88\u663e\u7136\u5728\u8fd9\u6574\u68f5\u5b50\u6811\u4e2d\uff0c $dfn$ \u6700\u5c0f\u7684\u90a3\u4e2a\u7ed3\u70b9\u5c31\u662f\u5b50\u6811\u7684\u6839\u3002\u800c\u6700\u5927\u7684\u5219\u662f $dfn + size - 1$ \u3002\n\n\uff08\u5176\u4e2d $size$ \u662f\u8fd9\u68f5\u5b50\u6811\u7684\u5927\u5c0f\uff09\n\n\u6240\u4ee5\u4ee3\u7801\u53ea\u9700\u8981\u4e00\u53e5\u8bdd\uff0c\n\n```cpp\ninline int Tsum(int u) { // \u8be2\u95ee\u4ee5 u \u4e3a\u6839\u7684\u5b50\u6811\n    return query(root, dfn[u], dfn[u] + size[u] - 1);\n}\n\ninline void Tchange(int u, int d) { // \u4fee\u6539\u4ee5 u \u4e3a\u6839\u7684\u5b50\u6811\n    change(root, dfn[u], dfn[u] + size[u] - 1, d);\n}\n```\n\n# **Code**\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\nusing namespace std;\n#define MAXN 100100\nint n, m, dep[MAXN], fa[MAXN], wson[MAXN], top[MAXN], dfn[MAXN], tot, size[MAXN], pre[MAXN], w[MAXN];\nstruct edge { // \u5b58\u56fe\n    int v;\n    edge *next;\n} epool[MAXN << 1], *h[MAXN], *ecnt = epool;\nstruct node { // \u5b58\u7ebf\u6bb5\u6811\n    int left, right, s, tag;\n    node *ls, *rs;\n    inline void seta(int x) { tag += x, s += (right - left + 1) * x;}\n    inline void upd() { s = ls->s + rs->s;}\n    inline void push() {\n        if(tag) {\n            if(ls) ls->seta(tag);\n            if(rs) rs->seta(tag);\n            tag = 0;\n        }\n    }\n} pool[MAXN << 3], *root, *cnt = pool;\ninline void addedge(int u, int v) { // \u52a0\u8fb9\n    edge *p = ++ecnt, *q = ++ecnt;\n    p->v = v, p->next = h[u], h[u] = p;\n    q->v = u, q->next = h[v], h[v] = q;\n}\ninline void dfs1(int u, int f) {\n    int v; size[u] = 1;\n    for(edge *p = h[u]; p; p = p->next)\n        if((v = p->v) != f) {\n            fa[v] = u,\n            dep[v] = dep[u] + 1;\n            dfs1(v, u);\n            size[u] += size[v];\n            if(size[v] > size[wson[u]]) wson[u] = v;\n        }\n}\ninline void dfs2(int u, int tp) {\n    int v; top[u] = tp;\n    dfn[u] = ++tot, pre[tot] = u;\n    if(wson[u]) dfs2(wson[u], tp);\n    for(edge *p = h[u]; p; p = p->next)\n        if((v = p->v) != wson[u] && v != fa[u])\n            dfs2(v, v);\n}\ninline void build(node *r, int left, int right) { // \u7ebf\u6bb5\u6811\u6a21\u677f\n    r->left = left, r->right = right;\n    if(left == right) {\n        r->s = w[pre[left]];\n        return ;\n    }\n    int mid = (left + right) >> 1;\n    node *ls = ++cnt, *rs = ++cnt;\n    r->ls = ls, r->rs = rs;\n    build(ls, left, mid), build(rs, mid + 1, right);\n    r->upd();\n}\ninline void change(node *r, int left, int right, int d) { // \u7ebf\u6bb5\u6811\u6a21\u677f\n    if(r->left == left && r->right == right) {\n        r->seta(d); return ;\n    } r->push();\n    if(r->ls->right >= right) change(r->ls, left, right, d);\n    else if(r->rs->left <= left) change(r->rs, left, right, d);\n    else change(r->ls, left, r->ls->right, d),\n         change(r->rs, r->rs->left, right, d);\n    r->upd();\n}\ninline int query(node *r, int left, int right) { // \u7ebf\u6bb5\u6811\u6a21\u677f\n    r->push();\n    if(r->left == left && r->right == right) return r->s;\n    if(r->ls->right >= right) return query(r->ls, left, right);\n    else if(r->rs->left <= left) return query(r->rs, left, right);\n    else return query(r->ls, left, r->ls->right) +\n                query(r->rs, r->rs->left, right);\n}\ninline int Qsum(int u, int v) {\n    int left, right, res = 0;\n    while(top[u] != top[v]) {\n        if(dep[top[u]] > dep[top[v]]) swap(u, v);\n        res += query(root, dfn[top[v]], dfn[v]);\n        v = fa[top[v]];\n    } left = dfn[u], right = dfn[v];\n    if(left > right) swap(left, right);\n    res += query(root, left, right);\n    return res;\n}\ninline void Qchange(int u, int v, int d) {\n    int left, right;\n    while(top[u] != top[v]) {\n        if(dep[top[u]] > dep[top[v]]) swap(u, v);\n        change(root, dfn[top[v]], dfn[v], d);\n        v = fa[top[v]];\n    } left = dfn[u], right = dfn[v];\n    if(left > right) swap(left, right);\n    change(root, left, right, d);\n}\nint main() {\n    int op, u, v, d;\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &w[i]); // \u8bfb\u5165\u70b9\u6743\n    for(int i = 1; i < n; i++) { // \u8bfb\u56fe\n        scanf(\"%d%d\", &u, &v);\n        addedge(u, v);\n    }\n    dep[1] = 1; // \u8fd9\u6b65\u4e0d\u80fd\u5fd8\uff0c\u5426\u5219 dfs1 \u6ca1\u7528\uff01\n    dfs1(1, 0), dfs2(1, 1);\n    build(root = cnt, 1, n);\n    while(m--) { // \u64cd\u4f5c\n        scanf(\"%d%d%d\", &op, &u, &v);\n        if(op == 1)\n            printf(\"%d\\n\", Qsum(u, v));\n        else {\n            scanf(\"%d\", &d);\n            Qchange(u, v, d);\n        }\n    }\n    return 0;\n}\n```\n\n**\u6700\u540e\u9644\u4e0a[\u6b64\u9898\u4ee3\u7801](https://paste.ubuntu.com/p/2HC462bQKs/)**",
        "postTime": 1550733148,
        "uid": 54628,
        "name": "eros1on",
        "ccfLevel": 0,
        "title": "\u6811\u94fe\u5256\u5206\u8be6\u89e3"
    },
    {
        "content": "# \u7b97\u6cd5\u540d\uff1a\u6811\u94fe\u5256\u5206/Heavy Path Decomposition\n\n\u6811\u94fe\u5256\u5206\uff0c\u662f\u4e00\u79cd\u5bf9\u6811\u8fdb\u884c\u5212\u5206\u7684\u7b97\u6cd5\uff0c\u76ee\u7684\u662f\u7ef4\u62a4\u6574\u68f5\u6811\uff08\u8282\u70b9\u6216\u6811\u8fb9\uff09\u3002\u4e00\u822c\u662f\u901a\u8fc7\u8f7b\u91cd\u8fb9\u5212\u5206\u5c06\u5176\u5206\u4e3a\u591a\u6761\u6811\u94fe\uff0c\u7136\u540e\u7528\u4e00\u4e9b\u590d\u6742\u5ea6\u8f83\u4f4e\u7684\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\n\n\u9996\u5148\u662f\u5efa\u6811\uff08\u65e0\u6743\uff09\uff1a\n\n```cpp\n#define MAX_N 100010\n// \u70b9\u6570\n#define MAX_M 200010\n// \u8fb9\u6570\uff0c\u7531\u4e8e\u662f\u65e0\u5411\u56fe\uff0c\u9700\u8981\u6b63\u53cd\u65b9\u5411\u5efa\u4e24\u6b21\u8fb9\uff0c\u56e0\u6b64\u5f00\u4e3a\u4e24\u500d\nint to[MAX_M], nex[MAX_M], tot = 0;\nint head[MAX_N];\ninline void Add(int u, int v) {\n  ++tot;\n  to[tot] = v;\n  nex[tot] = head[u];\n  head[u] = tot;\n}\n```\n\n\u7136\u540e\u6211\u4eec\u9700\u8981\u4e00\u4e9b\u57fa\u672c\u7684\u6570\u7ec4\uff1a\n\n```cpp\nint dep[MAX_N], siz[MAX_N], fa[MAX_N], son[MAX_N], f[MAX_N], ord[MAX_N];\n// dep[i]\u4e3a\u8282\u70b9i\u7684\u6df1\u5ea6\uff08\u6811\u6839\u6df1\u4e00\u822c\u8bbe\u4e3a0\uff09\n// siz[i]\u4e3a\u4ee5\u8282\u70b9i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8282\u70b9\u7684\u6570\u91cf\n// fa[i]\u4e3a\u8282\u70b9i\u7684\u7236\u7ed3\u70b9\u7f16\u53f7\n// \u540e\u9762\u4e09\u4e2a\u6570\u7ec4\u5f85\u4f1a\u4ecb\u7ecd\nint cnt = 0; // \u5f85\u4f1a\u8bf4\n```\n\n\u5728\u6574\u4e2a\u7b97\u6cd5\u4e2d\u9700\u8981\u4e24\u6b21DFS\n\n\u5176\u4e2d\u7b2c\u4e00\u904dDFS\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684dep\u3001siz\u3001fa\u4e09\u4e2a\u503c\n\n```cpp\nvoid Dfs1(int x, int y) { // x\u4e3a\u8282\u70b9\u7f16\u53f7\uff0cy\u4e3ax\u7684\u6df1\u5ea6\n  dep[x] = y, siz[x] = 1; // siz\u521d\u59cb\u5316\u4e3a1\uff0c\u4ee3\u8868\u4ee5x\u4e3a\u8ddf\u7684\u5b50\u6811\u4e2d\u53ea\u6709x\u8282\u70b9\n  for (register int i = head[x]; i; i = nex[i]) { // \u626b\u63cfx\u7684\u6240\u6709\u51fa\u8fb9\n    int v = to[i]; // \u4ee3\u8868(x, v)\u8fd9\u6761\u8fb9\n    if (v != fa[x]) { // \u4fdd\u8bc1v\u662fx\u7684\u513f\u5b50\n      fa[v] = x;\n      Dfs1(v, y + 1); // \u8282\u70b9v\u7684\u6df1\u5ea6\u4e3ay + 1\n      siz[x] += siz[v];\n    }\n  }\n}\n```\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u8981\u5bf9\u6811\u8fdb\u884c\u5212\u5206\u4e86\n\n\u600e\u4e48\u5212\u5206\u5462\uff1f\n\n\u5982\u56fe\uff0c\u5bf9\u4e8e\u8fd9\u6837\u4e00\u9897\u6811\n\n![\u6811\u94fe\u5256\u52061](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Heavy%20Path%20Decomposition_1.png)\n\n\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u6807\u51fa\u6bcf\u4e2a\u70b9\u7684siz\u503c\uff1a\n\n![\u6811\u94fe\u5256\u52062](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Heavy%20Path%20Decomposition_2.png)\n\n\u7136\u540e\u628a\u6bcf\u4e2a\u8282\u70b9\u7684\u6240\u6709\u513f\u5b50\u8282\u70b9\u4e2dsiz\u503c\u6700\u5927\u7684\u90a3\u4e2a\u6807\u51fa\u6765\uff08\u5982\u679c\u6709\u591a\u4e2a\u6700\u5927\u5219\u53ea\u6807\u4e00\u4e2a\uff09\uff1a\n\n![\u6811\u94fe\u5256\u52063](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Heavy%20Path%20Decomposition_3.png)\n\n\u6211\u4eec\u628a\u8fd9\u4e9b\u513f\u5b50\u8282\u70b9\u79f0\u4f5c\u201c\u91cd\u513f\u5b50\u201d\uff0c\u5176\u4ed6\u7684\u513f\u5b50\u8282\u70b9\u53eb\u505a\u201c\u8f7b\u513f\u5b50\u201d\n\n```cpp\nint dep[MAX_N], siz[MAX_N], fa[MAX_N], son[MAX_N], f[MAX_N], ord[MAX_N];\n// dep[i]\u4e3a\u8282\u70b9i\u7684\u6df1\u5ea6\uff08\u6811\u6839\u6df1\u4e00\u822c\u8bbe\u4e3a0\uff09\n// siz[i]\u4e3a\u4ee5\u8282\u70b9i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8282\u70b9\u7684\u6570\u91cf\n// fa[i]\u4e3a\u8282\u70b9i\u7684\u7236\u7ed3\u70b9\u7f16\u53f7\n// son[i]\u8868\u793a\u8282\u70b9i\u7684\u91cd\u513f\u5b50\n// \u540e\u9762\u4e24\u4e2a\u6570\u7ec4\u5f85\u4f1a\u4ecb\u7ecd\nint cnt = 0; // \u5f85\u4f1a\u8bf4\n```\n\n\u600e\u4e48\u66f4\u65b0son\u6570\u7ec4\u5462\uff1f\n\n```cpp\nvoid Dfs1(int x, int y) { // x\u4e3a\u8282\u70b9\u7f16\u53f7\uff0cy\u4e3ax\u7684\u6df1\u5ea6\n  dep[x] = y, siz[x] = 1; // siz\u4e3a1\uff0c\u4ee3\u8868\u4ee5x\u4e3a\u8ddf\u7684\u5b50\u6811\u4e2d\u53ea\u6709x\u8282\u70b9\n  for (register int i = head[x]; i; i = nex[i]) { // \u626b\u63cfx\u7684\u6240\u6709\u51fa\u8fb9\n    int v = to[i]; // \u4ee3\u8868(x, v)\u8fd9\u6761\u8fb9\n    if (v != fa[x]) { // \u4fdd\u8bc1v\u662fx\u7684\u513f\u5b50\n      fa[v] = x;\n      Dfs1(v, y + 1); // \u8282\u70b9v\u7684\u6df1\u5ea6\u4e3ay + 1\n      siz[x] += siz[v];\n      if (siz[v] > siz[son[x]]) son[x] = v;\n      // \u5982\u679c\u73b0\u5728\u6b63\u5728\u66f4\u65b0\u7684x\u7684\u5b50\u8282\u70b9v\u7684siz\u503c\u6bd4x\u7684\u91cd\u513f\u5b50\u7684siz\u503c\u5927\uff0c\u5219\u5c06x\u7684\u91cd\u513f\u5b50\u66f4\u65b0\u4e3av\n      // son\uff0csiz\u521d\u59cb\u5316\u4e3a0\uff0c\u4f7fx\u8282\u70b9\u5f00\u59cb\u6269\u5c55\u65f6son[x] == 0\uff0c\u4fdd\u8bc1\u7b2c\u4e00\u6b21\u66f4\u65b0v\u4e5f\u4f1a\u66f4\u65b0\u5230\n    }\n  }\n}\n```\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u628a\u6bcf\u4e2a\u91cd\u513f\u5b50\u4e0e\u5176\u7236\u8282\u70b9\u7684\u8fde\u8fb9\u8fdb\u884c\u6807\u8bb0\uff1a\n\n![\u6811\u94fe\u5256\u52064](https://accept-auto-machine-picture.oss-cn-hongkong.aliyuncs.com/picture/Heavy%20Path%20Decomposition_4.png)\n\n\u8fd9\u91cc\u88ab\u6807\u8bb0\u7684\u8fb9\u88ab\u79f0\u4e3a\u201c\u91cd\u8fb9\u201d\uff0c\u5176\u4f59\u7684\u8fb9\u53eb\u505a\u201c\u8f7b\u8fb9\u201d\uff0c\u8fde\u7eed\u7684\u91cd\u8fb9\u79f0\u4f5c\u201c\u91cd\u94fe\u201d\n\n\u63a5\u7740\u6211\u4eec\u518d\u6dfb\u52a0\u6ce8\u91ca\uff1a\n\n```cpp\nint dep[MAX_N], siz[MAX_N], fa[MAX_N], son[MAX_N], f[MAX_N], ord[MAX_N];\n// dep[i]\u4e3a\u8282\u70b9i\u7684\u6df1\u5ea6\uff08\u6811\u6839\u6df1\u4e00\u822c\u8bbe\u4e3a0\uff09\n// siz[i]\u4e3a\u4ee5\u8282\u70b9i\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u8282\u70b9\u7684\u6570\u91cf\n// fa[i]\u4e3a\u8282\u70b9i\u7684\u7236\u7ed3\u70b9\u7f16\u53f7\n// son[i]\u8868\u793a\u8282\u70b9i\u7684\u91cd\u513f\u5b50\n// f[i]\u8868\u793a\u8282\u70b9i\u6cbf\u7740\u91cd\u94fe\u5411\u4e0a\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u8282\u70b9\u7f16\u53f7\uff0c\u521d\u59cb\u5316\u4e3ai\n// ord[i]\u8868\u793a\u7b2c\u4e8c\u904dDFS\u65f6\u7684\u8282\u70b9i\u7684DFS\u5e8f\nint cnt = 0; // DFS\u5e8f\u8ba1\u6570\u5668\n```\n\n\u90a3\u4e48\u7b2c\u4e8c\u904dDFS\u600e\u4e48\u904d\u5386\u5462\uff1f\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9x\uff0c\u6211\u4eec\u5148DFS\u5b83\u7684\u91cd\u513f\u5b50son\\[x\\]\uff0c\u518dDFS\u5176\u4ed6\u7684\u8f7b\u513f\u5b50\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\nvoid Dfs2(int x) { // \u8282\u70b9\u7f16\u53f7\n  ord[x] = ++cnt; // \u66f4\u65b0DFS\u5e8f\n  int t = son[x]; // x\u7684\u91cd\u513f\u5b50\n  if (t != 0) { // \u5982\u679cx\u6709\u91cd\u513f\u5b50\uff0c\u5373\u82e5x\u4e0d\u662f\u53f6\u5b50\u8282\u70b9\n    f[t] = f[x]; // t\u6cbf\u7740\u91cd\u94fe\u5411\u4e0a\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u8282\u70b9\u5c31\u662fx\u6700\u8fdc\u80fd\u5230\u8fbe\u7684\u8282\u70b9\uff0c\u56e0\u4e3a\u8fb9(x, t)\u662f\u91cd\u8fb9\n    Dfs2(t);\n  }\n  for (register int i = head[x]; i; i = nex[i]) {\n    int v = to[i];\n    if (v != fa[x] && v != son[x]) Dfs2(v);\n    // \u5982\u679c\u904d\u5386\u5230\u7684\u8282\u70b9v\u662fx\u7684\u8f7b\u513f\u5b50\uff0c\u5219\u9012\u5f52\u8282\u70b9v\n  }\n}\n```\n\n\u8fd9\u91cc\u6709\u4e00\u4e9b\u663e\u7136\u7684\u6027\u8d28\uff1a\n\n\u4e00\u3001\u6bcf\u6761\u91cd\u94fe\u4e0a\u6240\u6709\u8282\u70b9\u7684DFS\u5e8f\u662f\u8fde\u7eed\u7684\n\n\u4e8c\u3001\u4ee5\u4efb\u4e00\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u7684DFS\u5e8f\u662f\u8fde\u7eed\u7684\n\n\u56e0\u6b64\uff0c\u5bf9\u4e8e\u6811\u4e0a\uff08\u8282\u70b9\u6216\u6811\u8fb9\uff09\u6743\u503c\u5c31\u53ef\u4ee5\u62ff\u533a\u95f4\u3002\u5355\u70b9\u64cd\u4f5c\u4ea4\u66ff\u5b8c\u6210\n\n\u64cd\u4f5c\u590d\u6742\u5ea6\u7a33\u5b9a\u5728$O(\\log{N})$\u7ea7\u522b\n\n\u7531\u4e8e\u6d89\u53ca\u533a\u95f4\u64cd\u4f5c\uff0c\u8fd9\u91cc\u6211\u4eec\u4e0a~~\u7b80\u5355\u7c97\u66b4\u7684~~\u7ebf\u6bb5\u6811\uff1a\n\n```cpp\nint sum[MAX_N * 4], ll[MAX_N * 4], rr[MAX_N * 4], tag[MAX_N * 4], cou = 0;\nvoid Update(int &root, int l, int r, int t, int x) {\n  if (root == 0) root = ++cou;\n  sum[root] += x, sum[root] %= p;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  if (t <= mid) Update(ll[root], l, mid, t, x);\n  else Update(rr[root], mid + 1, r, t, x);\n}\nvoid Down(int root, int l, int r) {\n  if (ll[root] == 0) ll[root] = ++cou;\n  if (rr[root] == 0) rr[root] = ++cou;\n  tag[ll[root]] += tag[root], tag[rr[root]] += tag[root];\n  tag[ll[root]] %= p, tag[rr[root]] %= p;\n  int mid = (l + r) >> 1;\n  sum[ll[root]] += tag[root] * (mid - l + 1) % p, sum[ll[root]] %= p;\n  sum[rr[root]] += tag[root] * (r - mid) % p, sum[rr[root]] %= p;\n  tag[root] = 0;\n}\nint Query(int root, int l, int r, int x, int y) {\n  if (l == x && r == y) return sum[root] % p;\n  Down(root, l, r);\n  int mid = (l + r) >> 1, suml = 0, sumr = 0;\n  if (x <= mid) suml = Query(ll[root], l, mid, x, min(mid, y)) % p;\n  if (y > mid) sumr = Query(rr[root], mid + 1, r, max(mid + 1, x), y) % p;\n  return (suml + sumr) % p;\n}\nvoid Update(int &root, int l, int r, int a, int b, int x) {\n  if (root == 0) root = ++cou;\n  sum[root] += x * (min(r, b) - max(l, a) + 1) % p, sum[root] %= p;\n  if (l == a && r == b) {\n    tag[root] += x;\n    tag[root] %= p;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (a <= mid) Update(ll[root], l, mid, a, min(mid, b), x);\n  if (b > mid) Update(rr[root], mid + 1, r, max(mid + 1, a), b, x);\n}\n```\n\n\u5bf9\u4e8e(x, y)\u95f4\u6700\u77ed\u8def\u5f84\u64cd\u4f5c\uff1a\n\n```cpp\nwhile (true) {\n  int a = f[x], b = f[y];\n  if (a == b) {\n    do_sth(min(ord[x], ord[y]), max(ord[x], ord[y]));\n    break;\n  }\n  if (dep[a] > dep[b]) { // \u8bf4\u660e\u5728\u8def\u5f84\u4e2d\uff0ca\u4e0a\u65b9\u8fd8\u6709\u8f7b\u8fb9\n    do_sth(ord[a], ord[x]);\n    // \u5982\u679c\u4e0a\u8ff0\u7684f, ord\u6570\u7ec4\u4fdd\u5b58\u7684\u662f\u8fb9\u5bf9\u8fb9\uff0c\u8981\u64cd\u4f5c\u7684\u5bf9\u8c61\u662f\u8fb9\uff0c\u5219\u6b64\u5904\u9700\u8981\u518d\u5bf9a\u4e0a\u65b9\u7684\u8f7b\u8fb9\u8fdb\u884c\u5355\u70b9\u64cd\u4f5c\n    x = fa[a];\n  } else {\n    do_sth(ord[b], ord[y]);\n    // \u5982\u679c\u4e0a\u8ff0\u7684f, ord\u6570\u7ec4\u4fdd\u5b58\u7684\u662f\u8fb9\u5bf9\u8fb9\uff0c\u8981\u64cd\u4f5c\u7684\u5bf9\u8c61\u662f\u8fb9\uff0c\u5219\u6b64\u5904\u9700\u8981\u518d\u5bf9b\u4e0a\u65b9\u7684\u8f7b\u8fb9\u8fdb\u884c\u5355\u70b9\u64cd\u4f5c\n    y = fa[b];\n  }\n}\n```\n\n## \u6d1b\u8c37 [P3384 \u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.org/problemnew/show/P3384)\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100010\n#define MAX_M 200010\nint to[MAX_M], nex[MAX_M], tot = 0;\nint head[MAX_N];\ninline void Add(int u, int v) {\n  ++tot;\n  to[tot] = v;\n  nex[tot] = head[u];\n  head[u] = tot;\n}\nint dep[MAX_N], siz[MAX_N], fa[MAX_N], son[MAX_N], f[MAX_N], ord[MAX_N];\nint cnt = 0, p;\nvoid Dfs1(int x, int y) {\n  dep[x] = y, siz[x] = 1;\n  for (register int i = head[x]; i; i = nex[i]) {\n    int v = to[i];\n    if (v != fa[x]) {\n      fa[v] = x;\n      Dfs1(v, y + 1);\n      siz[x] += siz[v];\n      if (siz[v] > siz[son[x]]) son[x] = v;\n    }\n  }\n}\nvoid Dfs2(int x) {\n  ord[x] = ++cnt;\n  int t = son[x];\n  if (t != 0) {\n    f[t] = f[x];\n    Dfs2(t);\n  }\n  for (register int i = head[x]; i; i = nex[i]) {\n    int v = to[i];\n    if (v != fa[x] && v != son[x]) Dfs2(v);\n  }\n}\nint val[MAX_N];\nint sum[MAX_N * 4], ll[MAX_N * 4], rr[MAX_N * 4], tag[MAX_N * 4], cou = 0;\nvoid Update(int &root, int l, int r, int t, int x) {\n  if (root == 0) root = ++cou;\n  sum[root] += x, sum[root] %= p;\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  if (t <= mid) Update(ll[root], l, mid, t, x);\n  else Update(rr[root], mid + 1, r, t, x);\n}\nvoid Down(int root, int l, int r) {\n  if (ll[root] == 0) ll[root] = ++cou;\n  if (rr[root] == 0) rr[root] = ++cou;\n  tag[ll[root]] += tag[root], tag[rr[root]] += tag[root];\n  tag[ll[root]] %= p, tag[rr[root]] %= p;\n  int mid = (l + r) >> 1;\n  sum[ll[root]] += tag[root] * (mid - l + 1) % p, sum[ll[root]] %= p;\n  sum[rr[root]] += tag[root] * (r - mid) % p, sum[rr[root]] %= p;\n  tag[root] = 0;\n}\nint Query(int root, int l, int r, int x, int y) {\n  if (l == x && r == y) return sum[root] % p;\n  Down(root, l, r);\n  int mid = (l + r) >> 1, suml = 0, sumr = 0;\n  if (x <= mid) suml = Query(ll[root], l, mid, x, min(mid, y)) % p;\n  if (y > mid) sumr = Query(rr[root], mid + 1, r, max(mid + 1, x), y) % p;\n  return (suml + sumr) % p;\n}\nvoid Update(int &root, int l, int r, int a, int b, int x) {\n  if (root == 0) root = ++cou;\n  sum[root] += x * (min(r, b) - max(l, a) + 1) % p, sum[root] %= p;\n  if (l == a && r == b) {\n    tag[root] += x;\n    tag[root] %= p;\n    return;\n  }\n  int mid = (l + r) >> 1;\n  if (a <= mid) Update(ll[root], l, mid, a, min(mid, b), x);\n  if (b > mid) Update(rr[root], mid + 1, r, max(mid + 1, a), b, x);\n}\nint main() {\n  int n, m, r;\n  scanf(\"%d%d%d%d\", &n, &m, &r, &p);\n  int root = 0;\n  for (register int i = 1; i <= n; ++i) {\n    scanf(\"%d\", &val[i]);\n    val[i] %= p;\n  }\n  for (register int i = 1; i < n; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    Add(u, v);\n    Add(v, u);\n  }\n  for (register int i = 1; i <= n; ++i) f[i] = i;\n  Dfs1(r, 0);\n  Dfs2(r);\n  for (register int i = 1; i <= n; ++i)\n    Update(root, 1, n, ord[i], val[i]);\n  for (register int i = 1; i <= m; ++i) {\n    int o;\n    scanf(\"%d\", &o);\n    switch (o) {\n      case 1: {\n        int x, y, z;\n        scanf(\"%d%d%d\", &x, &y, &z);\n        while (true) {\n          int a = f[x], b = f[y];\n          if (a == b) {\n            Update(root, 1, n, min(ord[x], ord[y]), max(ord[x], ord[y]), z);\n            break;\n          }\n          if (dep[a] > dep[b])\n            Update(root, 1, n, ord[a], ord[x], z), x = fa[a];\n          else\n            Update(root, 1, n, ord[b], ord[y], z), y = fa[b];\n        }\n        break;\n      }\n      case 2: {\n        int x, y, su = 0;\n        scanf(\"%d%d\", &x, &y);\n        while (true) {\n          int a = f[x], b = f[y];\n          if (a == b) {\n            su += Query(root, 1, n, min(ord[x], ord[y]), max(ord[x], ord[y]));\n            su %= p;\n            break;\n          }\n          if (dep[a] > dep[b]) {\n            su += Query(root, 1, n, ord[a], ord[x]), su %= p;\n            x = fa[a];\n          } else {\n            su += Query(root, 1, n, ord[b], ord[y]), su %= p;\n            y = fa[b];\n          }\n        }\n        printf(\"%d\\n\", su % p);\n        break;\n      }\n      case 3: {\n        int x, z;\n        scanf(\"%d%d\", &x, &z);\n        Update(root, 1, n, ord[x], ord[x] + siz[x] - 1, z);\n        break;\n      }\n      case 4: {\n        int x;\n        scanf(\"%d\", &x);\n        printf(\"%d\\n\", Query(root, 1, n, ord[x], ord[x] + siz[x] - 1) % p);\n        break;\n      }\n      default: {\n        break;\n      }\n    }\n  }\n  return 0;\n}\n```",
        "postTime": 1549514286,
        "uid": 102080,
        "name": "Jaanai",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\uff08\u8bf7\u5148\u5b66\u4f1a\u6811\u94fe\u5256\u5206\u6a21\u677f\uff09\n\u82e5\u662f\u521d\u5b66\u6811\u94fe\u5256\u5206\uff0c\u5efa\u8bae\u770b\u8be5\u9898\u7f6e\u9876\u7684\u9898\u89e3\u3002\n\u5728\u6b64\u53ea\u662f\u5bf9\u5176\u7ebf\u6bb5\u6811\u90e8\u5206\u8fdb\u884c\u4f18\u5316\u3002\n\n\u6211\u4eec\u90fd\u77e5\u9053\uff0c\u666e\u901a\u7ebf\u6bb5\u6811\u662f\u901a\u8fc7\u9012\u5f52\u5b9e\u73b0\u7684\u3002\n\u4f46\u662f\u6e05\u534e\u5927\u5b66\u5f20\u6606\u73ae\u5728\u300a\u7edf\u8ba1\u7684\u529b\u91cf\u300b\u4e2d\u63d0\u51fa\u4e86zkw\u7ebf\u6bb5\u6811\u3002\n\u5b83\u662f\u975e\u9012\u5f52\u5b9e\u73b0\u7684\uff0c\u5728\u8fd9\u4e2a\u4eba\u7684\u535a\u5ba2\uff08\u76f8\u5173\u94fe\u63a5\uff1ahttps://www.cnblogs.com/ZegWe/p/6139364.html\uff09\n\u8bb2\u7684\u5f88\u6e05\u695a\u3002\n\n\u5e9f\u8bdd\u4e0d\u591a\u8bf4\uff0c\u4e0a\u4ee3\u7801\u3002\n\n------------\n\n\t#include<bits/stdc++.h>\n\tusing namespace std;\n\tinline int read()\n\t{\n \t   \tunsigned int f=1,num=0;\n \t  \tchar ch=getchar();\n    \twhile(0==isdigit(ch)){if(ch=='-')f=-1;\t\t\t\tch=getchar();}\n    \twhile(0!=isdigit(ch)) num=(num<<1)+(num<<3)+ch-'0',ch=getchar();\n    \treturn num*f;\n\t}//\u5feb\u8bfb\n\tconst int N=200010;\n\tint tot,head[N],next[N],to[N];\n\tint size[N],son[N],dep[N],fa[N],top[N],now[N],past[N],ctr[N];\n\tint a[N];\n\tint n,m,root,p;\n\tint len;\n\tinline void add1(int x,int y)\n\t{\n\t\tnext[++tot]=head[x],head[x]=tot,to[tot]=y;\n\t}//\u52a0\u8fb9\n\tvoid dfs_getson(int x)\n\t{\n\t\tsize[x]=1;\n\t\tfor(register int i=head[x];i;i=next[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif(y==fa[x])continue;\n\t\t\tfa[y]=x;dep[y]=dep[x]+1;\n\t\t\tdfs_getson(y);\n\t\t\tsize[x]+=size[y];\n\t\t\tif(size[y]>size[son[x]])son[x]=y;\n\t\t}\n\t}\n\tvoid dfs_rewrite(int x,int tp)\n\t{\n\t\ttop[x]=tp;\n\t\tnow[x]=++tot;\n\t\tpast[tot]=x;\n\t\tif(son[x])dfs_rewrite(son[x],tp);\n\t\tfor(register int i=head[x];i;i=next[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif(y!=son[x]&&y!=fa[x])dfs_rewrite(y,y);\n\t\t}\n\t\tctr[x]=tot;//\u4ee5x\u4e3a\u6839\u7684\u5b57\u6811\u7684\u6700\u5927\u7f16\u53f7\n\t}//\u6a21\u677f\n\tlong long tr[N*8]={0};\n\tlong long add[N*8];\n\tlong long M=1;\n\n\n\tinline void buildtree()\n\t{\n\t\twhile(M<(n+2))M<<=1;\n\t\tfor(register int i=M+1;i<=M+n;i++)\n\t\t{\n\t\ttr[i]=a[past[i-M]];\n\t\tint x=i;\n\t\twhile(x>>=1)tr[x]=tr[x<<1]+tr[x<<1|1];\n\t\t}\n\t}\n\tinline void change(int l,int r,long long val)\n\t{\n\t\tl+=M-1,r+=M+1;\n    \tlong long L=0,R=0;\n    \tfor(register int i=1;l^r^1;i<<=1,l>>=1,r>>=1)\n    \t{\n    \t\ttr[l]+=L*val,tr[r]+=R*val;\n    \t\tif(~l&1)add[l^1]+=val,tr[l^1]+=i*val,L+=i;\n    \t\tif(r&1) add[r^1]+=val,tr[r^1]+=i*val,R+=i;\n\t\t}\n\t\ttr[l]+=L*val;tr[r]+=R*val;\n\t\twhile(l>>=1)tr[l]+=val*(L+R);\n\t}\n\tinline long long getsum(int l,int r)\n\t{\n\t\tl+=M-1;r+=M+1;\n\t\tlong long ans=0;\n\t\tlong long L=0,R=0;\n\t\tfor(register long long i=1;l^r^1;i<<=1,l>>=1,r>>=1)\n\t\t{\n\t\t\tans+=add[l]*L+add[r]*R;\n\t\t\tif(~l&1)ans+=tr[l^1],L+=i;\n\t\t\tif(r&1) ans+=tr[r^1],R+=i;\n\t\t}\n\t\tans+=add[l]*L+add[r]*R;\n\t\twhile(l>>=1)ans+=add[l]*(L+R);\n\t\treturn ans;\n\t}\n    //zkw\u7ebf\u6bb5\u6811\u4e3b\u4f53\uff08\u4ee3\u7801\u53c8\u77ed\u53c8\u5feb\uff09\n\tvoid change_xtoy()\n\t{\n\t\tint x,y,z;\n\t\tx=read();y=read();z=read();\n\t\twhile(top[x]!=top[y])\n\t\t{\n\t\t\tif(dep[top[x]]>dep[top[y]])swap(x,y);\n\t\t\tchange(now[top[y]],now[y],z);\n\t\t\ty=fa[top[y]];\n\t\t}\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\tchange(now[x],now[y],z);\n\t}//\u6539\u53d8x\u5230y\u8def\u5f84\u7684\u503c\n\tvoid getsum_xtoy()\n\t{\n\t\tint x,y;\n\t\tx=read();y=read();\n\t\tlong long ans=0;\n    \twhile(top[x]!=top[y])\n    \t{\n    \t\tif(dep[top[x]]>dep[top[y]])swap(x,y);\n    \t\tans=(ans+getsum(now[top[y]],now[y]))%p;\n   \t \t\ty=fa[top[y]];\n\t\t}\n\t\tif(dep[x]>dep[y])swap(x,y);\n\t\t(ans+=getsum(now[x],now[y]))%=p;\n\t\tprintf(\"%lld\\n\",ans%p);\n\t}//\u5bf9x\u5230y\u8def\u5f84\u7684\u503c\u6c42\u548c\n\tvoid change_sontree()\n\t{\n\t\tint x,y;\n\t\tx=read();y=read();\n\t\tchange(now[x],ctr[x],y);\n\t}//\u6539\u53d8\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u7684\u503c\n\tvoid getsum_sontree()\n\t{\n\t\tint x;\n\t\tx=read();\n\t\tprintf(\"%lld\\n\",getsum(now[x],ctr[x])%p);\n\t}//\u5bf9\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u7684\u503c\u6c42\u548c\n\tint main()\n\t{\n\t\tn=read();m=read();root=read();p=read();\n\t\tfor(register int i=1;i<=n;i++)a[i]=read();\n\t\tfor(register int i=1;i<=n-1;i++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tx=read();y=read();\n\t\t\tadd1(x,y);add1(y,x);\n\t\t}\n      tot=0;\n      dfs_getson(root);\n      dfs_rewrite(root,root);\n      len=0;\n      buildtree();\n      for(register int i=1;i<=m;i++)\n      {\n          int id;\n          id=read();\n          if(id==1)change_xtoy();\n          if(id==2)getsum_xtoy();\n          if(id==3)change_sontree();\n          if(id==4)getsum_sontree();\n      }\n      return 0;\n  } \n \n\n------------\n",
        "postTime": 1543641542,
        "uid": 110031,
        "name": "z1431346079",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u7b80\u5355\u6765\u8bf4\u6811\u94fe\u5256\u5206\u5c31\u662f\u628a\u6811\u4e0a\u95ee\u9898\u8f6c\u5316\u4e3a\u533a\u95f4\u95ee\u9898\u7684\u4e00\u79cd\u65b9\u6cd5,\u540c\u65f6\u53ef\u4ee5\u7528\u65f6\u95f4\u590d\u6742\u5ea6\u6765\u6362\u7a7a\u95f4\u590d\u6742\u5ea6\u3002\n\n\n### $LCA$\n\n\u9996\u5148\u6765\u8bf4\u4e00\u4e0b\u5982\u4f55\u6c42 $LCA$\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38243.png)\n\n\u5176\u4e2d\u6211\u4eec\u628a\u6bcf\u4e2a\u7236\u4eb2\u7684\u513f\u5b50\u4e2d $size$ (\u5b50\u6811\u4e2a\u6570) \u6700\u5927\u7684\u513f\u5b50\u79f0\u4e3a**\u91cd\u513f\u5b50**\u3002\u800c\u5176\u5b83\u5219\u4e3a **\u8f7b\u513f\u5b50**,\u8fd9\u6837\u5b50\u5c31\u628a\u6811\u5206\u4e3a\u4e86\u5f88\u591a\u6761\u94fe\u3002\u4e0b\u56fe\u4e2d\u7684 $H$ \u90fd\u662f\u91cd\u513f\u5b50\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38244.png)\n\n\u6211\u4eec\u518d\u8bb0\u5f55\u4e00\u4e0b\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684 $top$ (\u94fe\u9876) \u548c $dep$ (\u6df1\u5ea6)\u3002(\u56fe\u7684\u7f16\u53f7\u4e0d\u540c\u4e86,\u4e14\u53ea\u8bb0\u5f55\u4e86\u94fe\u9876)\n\n![](https://cdn.luogu.com.cn/upload/pic/38245.png)\n\n\u5047\u5982\u6211\u4eec\u5148\u6c42 $7$ \u53f7\u70b9\u548c $5$ \u53f7\u70b9\u7684 $LCA$\u3002\n\n\u6211\u4eec\u53d1\u73b0 $dep[top[5]] > dep[top[7]]$,\u6240\u4ee5\u4ece $5$ \u8282\u70b9\u8df3\u5230 $father[top[5]]$\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38246.png)\n\n\u7136\u540e\u73b0\u5728\u4e24\u4e2a\u70b9\u5728\u540c\u4e00\u4e2a\u94fe\u91cc\u9762\u4e86,\u6211\u4eec\u53d6 $dep$ \u6bd4\u8f83\u6d45\u7684\u90a3\u4e00\u4e2a\u4f5c\u4e3a $LCA$\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38247.png)\n\n\u524d\u9762\u9700\u8981\u4e24\u4e2a $Dfs$ \u9884\u5904\u7406\u3002\n\n```pascal\n// luogu-judger-enable-o2\nvar\n    cnt,size,dep,top,father,son:array[-1..510000] of longint;\n    next,reach:array[-1..1050000] of longint;\n    j,i,n,m,l,r,tot,root:longint;\n\nprocedure add(l,r:longint); // \u94fe\u5f0f\u524d\u5411\u661f\nbegin\n    inc(tot);\n    reach[tot]:=r;\n    next[tot]:=cnt[l];\n    cnt[l]:=tot;\nend;\n\nprocedure Dfs_1(x:longint); // \u9884\u5904\u7406 father \u548c size\nvar i:longint;\nbegin\n    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;\n    while i<>-1 do\n    begin\n        if dep[reach[i]]=0 then\n        begin\n            dep[reach[i]]:=dep[x]+1;\n            father[reach[i]]:=x;\n            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);\n            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];\n        end; \n        i:=next[i];\n    end;\nend;\n\nprocedure Dfs_2(x,centre:longint); // \u5df2\u77e5 father \u548c size \u6c42 top \u548c son(\u91cd\u513f\u5b50)\nvar i:longint;\nbegin\n    top[x]:=centre;\n    if son[x]=0 then exit; Dfs_2(son[x],centre);\n    i:=cnt[x];\n    while i<>-1 do\n    begin \n        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);\n        i:=next[i];\n    end;\nend;\n\nfunction Refer(x,y:longint):int64; // \u67e5\u627e LCA\nbegin\n    while top[x]<>top[y] do\n    begin\n        if dep[top[x]]<dep[top[y]] then y:=father[top[y]] else x:=father[top[x]]; // \u770b\u8c01\u7684 dep[top[]] \u6df1,\u8c01\u8df3\n    end;\n    if dep[x]<dep[y] then exit(x) else exit(y); // \u540c\u4e00\u6761\u94fe\nend;\n\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1); // \u521d\u503c\u4e3a -1\n    read(n,m,root);\n    for i:=1 to n-1 do begin read(l,r); add(l,r); add(r,l); end; // \u53cc\u5411\u8fb9\n    dep[root]:=1; father[root]:=1;\n    Dfs_1(root); Dfs_2(root,root);\n    for i:=1 to m do begin read(l,r); writeln(Refer(l,r)); end;\nend.\n```\n\n### \u6811\u4e0a\u4e24\u70b9\u6700\u8fd1\u8ddd\u79bb\u4e4b\u548c\n\n\u6811\u4e0a\u6c42\u503c\u4e5f\u5f88\u7b80\u5355\u3002\u4e0d\u540c\u7684\u662f\u6211\u4eec\u8981**\u8fd8\u8981**\u9884\u5904\u7406\u4ee5\u4e0b\u4fe1\u606f:\n\n- $dfn$ : $Dfs$\u5e8f, $Dfs$ **\u4e2d\u91cd\u513f\u5b50\u5148\u904d\u5386**\u3002\n- $val$ : \u6bcf\u4e00\u4e2a\u70b9\u7684\u70b9\u6743\n\n\u5176\u4e2d $dfn$ \u7684\u7528\u5904\u5c31\u662f\u628a\u6811\u53d8\u6210\u4e00\u4e2a\u533a\u95f4\u3002\u6ce8 : $val$ \u662f\u4e71\u7ed9\u7684\u3002\n\n![](https://cdn.luogu.com.cn/upload/pic/38248.png)\n\n![](https://cdn.luogu.com.cn/upload/pic/38282.png)\n\n\u5047\u8bbe\u6211\u4eec\u6c42 $2$ \u5230 $8$ \u7684\u548c\u3002\n\u7b2c\u4e00\u6b65,\u5148\u8ba9 $dep[top[]]$ \u5927\u7684\u8df3\u5230 $father[top[]]$,\u7ea2\u8272\u662f\u5230\u94fe\u9876,\u84dd\u8272\u662f\u5230\u7236\u4eb2 : ($ans+3+1+10=14$)\n\n![](https://cdn.luogu.com.cn/upload/pic/38287.png)\n\n\u7136\u540e\u6211\u4eec\u4f1a\u53d1\u73b0\u5b83\u4eec\u5728\u540c\u4e00\u6761\u94fe\u91cc\u9762\u4e86 (\u540c\u4e00\u4e2a\u94fe\u9876),\u5c31\u53ef\u4ee5\u76f4\u63a5\u641e\u3002($ans+2+1=17$)\n\n![](https://cdn.luogu.com.cn/upload/pic/38290.png)\n\n\u6811\u4e0a\u4fee\u6539\u548c\u6811\u4e0a\u67e5\u8be2\u662f\u540c\u7406\u7684\u3002\u67e5\u8be2\u7684\u65f6\u5019\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4,\u6253\u4e00\u4e2a\u61d2\u6807\u8bb0\u5c31\u597d\u4e86\u3002\n\n\u4e0b\u9762\u8bf4\u4e00\u4e0b\u5982\u4f55\u67e5\u5b50\u6811\u7684\u503c\u3002\u4e3e\u4e2a\u4f8b\u5b50:\n\n![](https://cdn.luogu.com.cn/upload/pic/38292.png)\n\n\u4e00\u773c\u5c31\u53ef\u4ee5\u770b\u51fa\u7684\u89c4\u5f8b\u3002\u56e0\u4e3a $Dfs$ \u5e8f\u7684\u539f\u56e0,\u6240\u4ee5\u53ea\u9700\u8981\u67e5\u8be2 $dfn[x] -> dfn[x]+size[x]-1$ \u8fd9\u4e2a\u533a\u95f4\u5c31\u53ef\u4ee5\u4e86\u3002\u5b50\u6811\u7684\u987a\u5e8f\u4e0d\u7528\u7ba1\u5b83\u3002\u4fee\u6539\u4e5f\u662f\u540c\u7406\u3002\n\n\n```pascal\n// luogu-judger-enable-o2\nvar\n    cnt,size,dfn,dep,top,num,father,son:array[-1..210000] of int64; // \u5206\u522b\u4e3a\u94fe\u5f0f\u524d\u5411\u661f\u7684 head,\u5b50\u6811\u5927\u5c0f,Dfs\u5e8f,\u94fe\u9876,\u70b9\u6743,\u7236\u4eb2,\u91cd\u513f\u5b50\n    next,reach:array[-1..450000] of longint; // \u94fe\u5f0f\u524d\u5411\u661f\n    left,right:array[-1..450000] of longint; // \u7ebf\u6bb5\u6811\u4e2d\u7684\u5de6\u53f3\u533a\u95f4,\u6211\u8fd9\u91cc\u7528\u6570\u7ec4\u8bb0\u5f55\n    tree,lazy:array[-1..450000] of int64; // \u7ebf\u6bb5\u6811\u548c\u61d2\u6807\u8bb0(tag)\n    val:array[-1..210000] of int64; // \u6811\u4e0a\u70b9\u6743\n    j,i,n,m,l,r,dfnum,tot,root,order:longint; // \u540e 4 \u4e2a\u5206\u522b\u662f Dfs\u5e8f,\u94fe\u5f0f\u524d\u5411\u661f\u7684 tot,\u6839\u548c\u547d\u4ee4\n    k,modn:int64; // \u53d6\u6a21\u6570\n\nfunction remainder(var num:int64):longint; begin num:=num mod modn; exit(num); end; // \u53d6\u6a21\n\nprocedure swap(var a,b:longint);var t:longint; begin t:=a; a:=b; b:=t; end; // \u4ea4\u6362\n\nprocedure add(l,r:longint); // \u8fde\u8fb9\nbegin\n    inc(tot);\n    reach[tot]:=r;\n    next[tot]:=cnt[l];\n    cnt[l]:=tot;\nend;\n\nprocedure Dfs_1(x:longint); // \u6c42 size,father,dep\nvar i:longint;\nbegin\n    size[x]:=1; i:=cnt[x]; size[0]:=-maxlongint div 843;\n    while i<>-1 do\n    begin\n        if dep[reach[i]]=0 then\n        begin\n            dep[reach[i]]:=dep[x]+1;\n            father[reach[i]]:=x;\n            Dfs_1(reach[i]); inc(size[x],size[reach[i]]);\n            if size[reach[i]]>size[son[x]] then son[x]:=reach[i];\n        end;\n        i:=next[i];\n    end;\nend;\n\nprocedure Dfs_2(x,centre:longint); // \u6c42 top,dfn,son\nvar i:longint;\nbegin\n    inc(dfnum); dfn[x]:=dfnum; val[dfnum]:=num[x]; top[x]:=centre;\n    if son[x]=0 then exit; Dfs_2(son[x],centre);\n    i:=cnt[x];\n    while i<>-1 do\n    begin\n        if (reach[i]<>father[x])and(reach[i]<>son[x]) then Dfs_2(reach[i],reach[i]);\n        i:=next[i];\n    end;\nend;\n\nprocedure SUC(k:longint); // \u61d2\u6807\u8bb0\nbegin\n    inc(lazy[k << 1],lazy[k]);\n    inc(lazy[k << 1+1],lazy[k]); \n    inc(tree[k << 1],lazy[k]*(right[k << 1]-left[k << 1]+1)); remainder(tree[k << 1]);\n    inc(tree[k << 1+1],lazy[k]*(right[k << 1+1]-left[k << 1+1]+1)); remainder(tree[k << 1+1]);\n    lazy[k]:=0;\nend;\n\nprocedure Build(k,l,r:longint); // \u5efa\u6811\nvar mid:longint;\nbegin\n    left[k]:=l; right[k]:=r;\n    if (l=r) then begin tree[k]:=val[l]; exit; end; // \u6ce8\u610f\u662f val[l]\n    mid:=(l+r) >> 1;\n    Build(k << 1,l,mid); Build(k << 1+1,mid+1,r);\n    tree[k]:=tree[k << 1]+tree[k << 1+1]; remainder(tree[k]);\nend;\n\nprocedure Change(k,x,y:longint;modify:int64); // \u7ebf\u6bb5\u6811\u4fee\u6539\nvar mid:longint;\nbegin\n    if (x<=left[k])and(right[k]<=y) then\n    begin\n        inc(tree[k],modify*(right[k]-left[k]+1)); remainder(tree[k]);\n        inc(lazy[k],modify); exit;\n    end;\n    mid:=(left[k]+right[k]) >> 1;\n    if lazy[k]>0 then SUC(k);\n    if mid>=y then Change(k << 1,x,y,modify) else\n    if mid<x then Change(k << 1+1,x,y,modify) else\n    begin\n        Change(k << 1,x,mid,modify);\n        Change(k << 1+1,mid+1,y,modify);\n    end;\n    tree[k]:=tree[k << 1]+tree[k << 1+1]; remainder(tree[k]);\nend;\n\nfunction Query(k,x,y:longint):int64; // \u7ebf\u6bb5\u6811\u67e5\u8be2\nvar mid:longint;\nbegin\n    Query:=0;\n    if (x<=left[k])and(right[k]<=y) then exit(remainder(tree[k]));\n    mid:=(left[k]+right[k]) >> 1;\n    if lazy[k]>0 then SUC(k);\n    if mid>=y then inc(Query,Query(k << 1,x,y)) else\n    if mid<x then inc(Query,Query(k << 1+1,x,y)) else\n    inc(Query,Query(k << 1,x,mid)+Query(k << 1+1,mid+1,y)); \n    exit(remainder(Query));\nend;\n\nfunction Refer(x,y:longint):int64; // \u6811\u4e0a\u67e5\u8be2\nbegin\n    Refer:=0;\n    while top[x]<>top[y] do\n    begin\n        if dep[top[x]]<dep[top[y]] then swap(x,y);\n        inc(Refer,Query(1,dfn[top[x]],dfn[x])); remainder(Refer);\n        x:=father[top[x]];\n    end;\n    if dep[x]>dep[y] then swap(x,y);\n    inc(Refer,Query(1,dfn[x],dfn[y])); remainder(Refer);\nend;\n\nprocedure Revise(x,y:longint;modify:int64); // \u6811\u4e0a\u4fee\u6539\nbegin\n    while top[x]<>top[y] do\n    begin\n        if dep[top[x]]<dep[top[y]] then swap(x,y);\n        Change(1,dfn[top[x]],dfn[x],modify);\n        x:=father[top[x]];\n    end;\n    if dep[x]>dep[y] then swap(x,y);\n    Change(1,dfn[x],dfn[y],modify);\nend;\n\nbegin\n    filldword(cnt,sizeof(cnt) div 4,maxlongint*2+1);\n    read(n,m,root,modn);\n    for i:=1 to n do begin read(num[i]); remainder(num[i]); end;\n    for i:=1 to n-1 do begin read(l,r); add(l,r); add(r,l); end;\n    dep[root]:=1; father[root]:=1;\n    Dfs_1(root); Dfs_2(root,root); Build(1,1,n);\n    for i:=1 to m do\n    begin\n        read(order);\n        if order=1 then begin read(l,r,k); Revise(l,r,remainder(k)); end;\n        if order=2 then begin read(l,r); writeln(Refer(l,r)); end;\n        if order=3 then begin read(l,k); Change(1,dfn[l],dfn[l]+size[l]-1,remainder(k)); end; // \u81ea\u5df1\u53ef\u4ee5\u8bd5\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u53ef\u4ee5\u8fd9\u6837\u5b50\u641e\n        if order=4 then begin read(l); writeln(Query(1,dfn[l],dfn[l]+size[l]-1)); end;\n    end;\nend.\n```\n\n#### \u6ce8\u610f :\n\n- \u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u662f $val[dfn[x]]$ !!!! (\u6539\u4e86\u597d\u51e0\u4e2a\u949f)\n- \u53ef\u4ee5\u7528\u5176\u5b83\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\n- \u8981\u53d6\u6a21,\u7a7a\u95f4\u5f00\u5927\u3002\n\n#### \u603b\u7ed3 : \n\n- \u628a\u6811\u4e0a\u95ee\u9898\u5f88\u597d\u7684\u8f6c\u5316\u6210\u4e86\u533a\u95f4\u95ee\u9898\n- \u5f88\u597d\u7684\u628a\u63e1\u4e86\u7a7a\u95f4\u590d\u6742\u5ea6\u4e0e\u65f6\u95f4\u590d\u6742\u5ea6\u7684 (\u76f8\u5bf9) \u5e73\u8861\u3002\n\n\n\n\n\n",
        "postTime": 1539666029,
        "uid": 77760,
        "name": "arfa",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "### \u3010\u4f8b\u9898\u3011\n![\u4f8b\u9898](https://cdn.luogu.com.cn/upload/pic/29840.png)\n\n### \u3010\u7b97\u6cd5\u76ee\u6807\u3011\n- \u5728$log$\u7ea7\u522b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\uff0c\u901a\u8fc7\u628a\u6811\u5206\u5272\u6210\u4e00\u6761\u6761\u94fe\uff0c\u5e76\u7528\u5404\u79cd\u6570\u636e\u7ed3\u6784\uff0c\u4ee5\u52a0\u901f\u89e3\u51b3\u5404\u79cd\u6811\u4e0a\u533a\u95f4\u95ee\u9898\u3002\n\n### \u3010\u7b97\u6cd5\u8fc7\u7a0b\u3011\n#### \u5b9a\u4e49\n- \u628a\u6bcf\u4e2a\u70b9\u8fde\u51fa\u7684\u4e24\u6761\u8fb9\u5206\u4e3a\u91cd\u8fb9\u548c\u8f7b\u8fb9\uff0c\u91cd\u8fb9\u8fde\u63a5\u5b50\u6811\u70b9\u6570\u8f83\u5927\u7684\u4e00\u8fb9\uff0c\u8f7b\u8fb9\u8fde\u5411\u53e6\u4e00\u8fb9\u3002\n- \u628a\u6bcf\u4e2a\u70b9\u7684\u4e24\u4e2a\u513f\u5b50\u5206\u4e3a\u91cd\u7ed3\u70b9\u548c\u8f7b\u7ed3\u70b9\uff0c\u91cd\u7ed3\u70b9\u7684\u5b50\u6811\u8f83\u5927\uff0c\u8f7b\u7ed3\u70b9\u5b50\u6811\u8f83\u5c0f\u3002\n\n#### \u9884\u5904\u7406\n- \u6c42\u51fa\u5b9a\u4e49\u5185\u7684\u53c2\u6570\uff1b\n- \u6bcf\u4e2a\u7ed3\u70b9\u6700\u9760\u8fd1\u5f53\u524d\u7ed3\u70b9\u7684\u91cd\u7ed3\u70b9top\uff0c\u5176\u4e2d\uff0c\u5bf9\u4e8e\u8f7b\u7ed3\u70b9\uff0ctop\u662f\u81ea\u5df1\u3002\u8fd9\u4e00\u6b65\u9aa4\u6709\u52a9\u4e8e\u8fdb\u884c\u201c\u8de8\u8d8a\u201d\uff0c\u4ee5\u63d0\u9ad8\u901f\u5ea6\u3002\n- **\u6bcf\u4e2a\u7ed3\u70b9\u5728DFS\u5e8f\u4e0b\u7684\u7f16\u53f7**\uff0c\u8fd9\u4e00\u6b65\u9aa4\u662f\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f18\u5316\u7684\u5173\u952e\u3002**\u6ce8\u610f**\uff1a\u8fd9\u91cc\u7684DFS\u5e8f\u5fc5\u987b\u5148\u641c\u5bfb\u91cd\u7ed3\u70b9\u3002\u56e0\u4e3a\u8fd9\u6837\u53ef\u4ee5\u4f7f\u91cd\u7ed3\u70b9\u90fd\u5728\u76f8\u90bb\u7684\u5730\u65b9\uff0c\u4fbf\u4e8e\u540e\u9762\u4f7f\u7528\u6570\u636e\u7ed3\u6784\u4f18\u5316\u3002\n- \u8fd9\u4e00\u6b65\u9aa4\u53ef\u4ee5\u7528\u4e24\u4e2aDFS\u6765\u5b9e\u73b0\u3002\n\n#### \u4fee\u6539\u4e0e\u67e5\u8be2\n- \u5bf9\u6811\u8fdb\u884c\u4ecex\u5230y\u7ed3\u70b9\u6700\u77ed\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u503c\u66f4\u65b0\u4e0e\u67e5\u8be2\uff1a\n\t- \u8dd1\u4e00\u6ce2\u7c7b\u4f3c\u4e8eLCA\u7684\u7b97\u6cd5\uff1b\n    - \u5bf9\u4e8e\u91cd\u7ed3\u70b9\uff0c\u628a\u7ebf\u6bb5\u6811\u4e2d\u5b83\u5230top\u7684\u533a\u95f4\u66f4\u65b0\uff1b\n    - \u5bf9\u4e8e\u8f7b\u7ed3\u70b9\uff0c\u4e3a\u4e86\u201c\u4fdd\u6301\u961f\u578b\u201d\uff0c\u5728\u7ebf\u6bb5\u6811\u4e2d\u81ea\u5df1\u7684\u4f4d\u7f6e\u66f4\u65b0\uff1b\n    - \u628ax\u6216y\u8df3\u5230\u5bf9\u5e94\u7684top\u3002\n    - \u76f4\u5230\u8df3\u5230\u76f8\u540c\u7684\u70b9\u3002\n    - \u540c\u7406\uff0c\u5bf9\u4e8e\u67e5\u8be2\u7528\u76f8\u4f3c\u7684\u64cd\u4f5c\u3002\n- \u5bf9\u4e8e\u4ee5x\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811\u5185\u6240\u6709\u8282\u70b9\u7684\u66f4\u65b0\u548c\u67e5\u8be2\uff1a\n\t- \u7531\u4e8eDFS\u5e8f\u91cc\u4e00\u4e2a\u5b50\u6811\u7684\u7ed3\u70b9\u662f\u6309\u987a\u5e8f\u76f8\u90bb\u7684\uff0c\u56e0\u6b64\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u7ebf\u6bb5\u6811\u8fdb\u884c\u66f4\u6539\u548c\u67e5\u8be2\u3002\n\n### \u3010\u65f6\u95f4\u590d\u6742\u5ea6\u3011\n- \u7531\u4e8e\u8f7b\u7ed3\u70b9\u7684\u4e2a\u6570\u4f1a\u968f\u7740\u5c42\u6570\u7684\u589e\u52a0\u800c/2\uff0c\u56e0\u6b64\u66b4\u529b\u8f7b\u7ed3\u70b9\u7684\u6b21\u6570\u662flogn\uff1b\u7531\u4e8e\u91cd\u7ed3\u70b9\u6709\u7ebf\u6bb5\u6811\u4f18\u5316\uff0c\u56e0\u6b64\u4e5f\u662flogn\uff1b\u7531\u4e8e\u6811\u7684\u6df1\u5ea6\u5e73\u644a\u8d77\u6765\u4e5f\u662flogn\uff0c\u56e0\u6b64\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f$O(Qlogn)$\u3002 \n\n### \u3010\u53c2\u8003\u7a0b\u5e8f\u3011\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nint n,Q,Mod,cnt,rt;\nstruct Tree{\n\tint sum,add;\n}tree[400005];\nstruct EDGE{\n\tint t,next;\n}e[400005];\nint cur,head[400005],\n\td[400005],dep[400005],top[400005],fa[400005],siz[400005],son[400005],\n\tid[400005],D[400005];\n\nvoid M(int &x)\n{\n\tx%=Mod;\n}\nint Mo(int x)\n{\n\treturn x%Mod;\n}\n\n\n\nvoid Wei_Hu(int x)\n{\n\tM(tree[x].sum=tree[x*2].sum+tree[x*2+1].sum);\n}\nvoid Down(int now,int l,int r)\n{\n\tint mid=((l+r)>>1);\n\ttree[now*2].add+=tree[now].add;\n\ttree[now*2+1].add+=tree[now].add;\n\tM(tree[now*2].sum+=tree[now].add*(mid-l+1));\n\tM(tree[now*2+1].sum+=tree[now].add*(r-mid));\n\ttree[now].add=0;\n}\nvoid Build(int now,int l,int r)\n{\n\tif (l==r)\n\t{\n\t\ttree[now].sum=d[l];\n\t\treturn;\n\t}\n\tint mid=((l+r)>>1);\n\tBuild(now*2,l,mid);\n\tBuild(now*2+1,mid+1,r);\n\tWei_Hu(now);\n}\nvoid Update(int now,int l,int r,int s,int t,int z)\n{\n\tif (l>t||r<s) return;\n\tif (s<=l&&r<=t)\n\t{\n\t\ttree[now].add+=z;\n\t\tM(tree[now].sum+=z*(r-l+1));\n\t\treturn;\n\t}\n\tint mid=((l+r)>>1);\n\tDown(now,l,r);\n\tUpdate(now*2,l,mid,s,t,z);\n\tUpdate(now*2+1,mid+1,r,s,t,z);\n\tWei_Hu(now);\n}\nint Query(int now,int l,int r,int s,int t)\n{\n\tif (l>t||r<s) return 0;\n\tif (s<=l&&r<=t)\n\t{\n\t\treturn tree[now].sum;\n\t}\n\tint mid=((l+r)>>1);\n\tDown(now,l,r);\n\treturn Mo(Query(now*2,l,mid,s,t)+Query(now*2+1,mid+1,r,s,t));\n}\n\n\n\nvoid add(int a,int b)\n{\n\tcur++;\n\te[cur].t=b;\n\te[cur].next=head[a];\n\thead[a]=cur;\n}\nvoid DFS1(int u,int f,int d)\n{\n\tdep[u]=d;\n\tfa[u]=f;\n\tsiz[u]=1;\n\tint hson=0;\n\tfor (int h=head[u];h!=-1;h=e[h].next)\n\t{\n\t\tint v=e[h].t;\n\t\tif (v==fa[u]) continue;\n\t\tDFS1(v,u,d+1);\n\t\tsiz[u]+=siz[v];\n\t\tif (siz[v]>hson)\n\t\t{\n\t\t\thson=siz[v];\n\t\t\tson[u]=v;\n\t\t}\n\t}\n}\nvoid DFS2(int u,int Top)\n{\n\tid[u]=++cnt;\n\td[cnt]=D[u];\n\ttop[u]=Top;\n\tif (!son[u])\n\t\treturn;\n\tDFS2(son[u],Top);\n\tfor (int h=head[u];h!=-1;h=e[h].next)\n\t{\n\t\tint v=e[h].t;\n\t\tif (v==fa[u]||v==son[u])\n\t\t\tcontinue;\n\t\tDFS2(v,v); \n\t}\n}\nvoid Update_Dis(int x,int y,int z)\n{\n\tM(z);\n\tfor (;top[x]!=top[y];x=fa[top[x]])\n\t{\n\t\tif (dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tUpdate(1,1,n,id[top[x]],id[x],z);\n\t}\n\tif (dep[x]>dep[y])\n\t\tswap(x,y);\n\tUpdate(1,1,n,id[x],id[y],z);\n}\nint Query_Dis(int x,int y)\n{\n\tint ans=0;\n\tfor (;top[x]!=top[y];x=fa[top[x]])\n\t{\n\t\t\n\t\tif (dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tM(ans+=Query(1,1,n,id[top[x]],id[x]));\n\t}\n\tif (dep[x]>dep[y])\n\t\tswap(x,y);\n\tM(ans+=Query(1,1,n,id[x],id[y]));\n\treturn ans;\n}\nvoid Update_Tree(int x,int z)\n{\n\tM(z);\n\tUpdate(1,1,n,id[x],id[x]+siz[x]-1,z);\n}\nint Query_Tree(int x)\n{\n\treturn Mo(Query(1,1,n,id[x],id[x]+siz[x]-1));\n}\nint main()\n{\n\tscanf(\"%d%d%d%d\",&n,&Q,&rt,&Mod);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&D[i]);\n\tmemset(head,-1,sizeof head);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tDFS1(rt,0,1);\n\tDFS2(rt,rt);\n\tBuild(1,1,n);\n\twhile (Q--)\n\t{\n\t\tint cmd,x,y,z;\n\t\tscanf(\"%d%d\",&cmd,&x);\n\t\tif (cmd==1)\n\t\t{\n\t\t\tscanf(\"%d%d\",&y,&z);\n\t\t\tUpdate_Dis(x,y,z);\n\t\t}\n\t\telse\n\t\tif (cmd==2)\n\t\t{\n\t\t\tscanf(\"%d\",&y);\n\t\t\tprintf(\"%d\\n\",Query_Dis(x,y));\n\t\t}\n\t\telse\n\t\tif (cmd==3)\n\t\t{\n\t\t\tscanf(\"%d\",&z);\n\t\t\tUpdate_Tree(x,z);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"%d\\n\",Query_Tree(x));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1534831198,
        "uid": 12349,
        "name": "FREEH",
        "ccfLevel": 6,
        "title": "\u6811\u94fe\u5256\u5206\u603b\u7ed3\u2014\u2014\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u89e3\u91ca\u5168\u90e8\u5728\u4ee3\u7801\u4e4b\u4e2d \u537f\u5b66\u59d0\u7684\u89c6\u9891\u5f88\u4e0d\u9519\n[\u4e00\u70b9\u5c31\u61c2\u7684 \u6811\u5256](https://www.bilibili.com/video/av4482146?from=search&seid=16528902309319633365)\n\u4ee5\u4e0b\u4ee3\u7801\u90e8\u5206\n```c\n#include<bits/stdc++.h>\nusing namespace std;\n#define maxn 500000+10\n#define LL long long\nLL no[maxn];      /// \u6240\u5c5e\u94fe\u7684\u7f16\u53f7\nLL top[maxn];     /// top\u8282\u70b9\nLL dee[maxn];     /// \u6df1\u5ea6\uff08\u7136\u800c\u6211\u5e76\u6ca1\u6709\u7528\u5230\uff09\nLL fa[maxn];      /// \u7236\u4eb2\u8282\u70b9\nLL zs[maxn];      /// \u91cd\u513f\u5b50\nLL sz[maxn];      /// \u5b50\u8282\u70b9\u4e2a\u6570\nLL dfn[maxn];     /// dfs\u7684\u7f16\u53f7\nLL tre[maxn];     /// \u5efa\u6811\nLL a[maxn],b[maxn]; /// \u50a8\u5b58\u8282\u70b9\u7684value\nbool vis[maxn];    /// \u7b2c\u4e00\u904d dfs \u7684\u6807\u8bb0\u6570\u7ec4\nlong long lz[maxn];///  \u61d2\u60f0\u6570\u7ec4\nvector<long long>q[maxn]; /// \u8bb0\u5f55\u8282\u70b9\u4fe1\u606f\nlong long n,m,r,P;\nlong long tot=0,z=1; /// dfs\u7684\u7f16\u53f7 \u548c\u94fe\u7684\u7f16\u53f7\n\nvoid dfs(long long u,long long y){   ///\u7b2c\u4e00\u904ddfs\u8bb0\u5f55 \u8282\u70b9\u7684\u6df1\u5ea6\uff0c\u91cd\u513f\u5b50\uff0c\u8282\u70b9\u4e2a\u6570\n   sz[u]=1;\n   dee[u]=y;\n   long long mx=-1;\n   for(long long j=0;j<q[u].size();j++){\n      long long v=q[u][j];\n      if(!vis[v]){\n         vis[v]=1;\n         fa[v]=u;\n         dfs(v,y+1);\n         sz[u]+=sz[v];\n         if(sz[v]>mx){\n            mx=sz[v];\n            zs[u]=v;\n         }\n      }\n   }\n}\n\nvoid dfs2(long long u,long long y){ ///\u7b2c\u4e8c\u904ddfs \u8bb0\u5f55 \u6bcf\u6761\u94fe\u7684\u7f16\u53f7\u4ee5\u53ca\u6bcf\u4e2a\u8282\u70b9\u7684\u7f16\u53f7\n     dfn[u]=++tot;\n     b[tot]=a[u];\n     top[u]=y;\n     no[u]=z;\n     if(zs[u]==0) return ;\n     if(zs[u]){\n       dfs2(zs[u],y);\n     }\n     for(long long j=0;j<q[u].size();j++){\n         long long v=q[u][j];\n         if(v!=zs[u]&&v!=fa[u]){\n           z++;\n           dfs2(v,v);\n         }\n     }\n}\n\n\nvoid lazy(long long in,long long rt){\n    if(lz[in]){\n       lz[in*2]+=lz[in];\n       lz[in*2+1]+=lz[in];\n       tre[in*2]+=lz[in]*(rt-rt/2);\n       tre[in*2+1]+=lz[in]*(rt/2);\n       lz[in]=0;\n    }\n}\nvoid build(long long l,long long r,long long in){\n   if(l==r){\n      tre[in]=b[l];\n      return ;\n   }\n   long long mid=(l+r)/2;\n   build(l,mid,in*2);\n   build(mid+1,r,in*2+1);\n   tre[in]=tre[in*2]+tre[in*2+1];\n}\nlong long query(long long l,long long r,long long x,long long y,long long in){\n   if(l==x&&r==y){\n      return tre[in]%P;\n   }\n   lazy(in,y-x+1);\n   long long mid=(x+y)/2;\n   if(r<=mid){\n      return query(l,r,x,mid,in*2)%P;\n   }else if(l>mid){\n      return query(l,r,mid+1,y,in*2+1)%P;\n   }\n   return (query(l,mid,x,mid,in*2)%P+query(mid+1,r,mid+1,y,in*2+1)%P)%P;\n}\nvoid updata(long long l,long long r,long long x,long long y,long long in,long long c){\n   if(l==x&&r==y){\n       tre[in]+=c*(y-x+1);\n       lz[in]+=c;\n       return ;\n   }\n   lazy(in,y-x+1);\n   long long mid=(x+y)/2;\n   if(r<=mid){\n      updata(l,r,x,mid,in*2,c);\n   }else if(l>mid){\n      updata(l,r,mid+1,y,in*2+1,c);\n   }\n   else{\n      updata(l,mid,x,mid,in*2,c);\n      updata(mid+1,r,mid+1,y,in*2+1,c);\n   }\n  tre[in]=tre[in*2]+tre[in*2+1];\n}\n/// \u4ee5\u4e0a\u6b63\u5e38\u7684\u7ebf\u6bb5\u6811\u64cd\u4f5c\n\nvoid xiugai1(long long x,long long y,long long z){\n   long long xx=no[x],yy=no[y];                /// \u5c5e\u4e8e\u90a3\u6761\u94fe\n   if(xx==yy){                                 /// \u5224\u65ad\u94fe\u7684\u7f16\u53f7\u5927\u5c0f\u7136\u540e\u505a\u51fa\u4fee\u6539\n      long long xxx=dfn[x],yyy=dfn[y];         /// \u76f8\u540c \u5c5e\u4e8e\u540c\u4e00\u6761\u94fe \u540c\u4e00\u6761\u94fe\u7684\u7f16\u53f7\u662f\u8fde\u7eed\u7684\n      if(xxx>yyy) swap(xxx,yyy);\n      updata(xxx,yyy,1,n,1,z);\n      return ;\n   }\n   if(xx>yy){                                 /// x>y \u4fee\u6539x\u6240\u5728\u94fe\u7684\u533a\u95f4 \n      updata(dfn[top[x]],dfn[x],1,n,1,z);\n      xiugai1(fa[top[x]],y,z);                /// \u9012\u5f52\u5bfb\u627e\u5176top\u8282\u70b9\u7684\u7236\u4eb2\u8282\u70b9\u7684\u94fe\u548cy\u6bd4\u8f83\n   }\n   if(xx<yy){\n      updata(dfn[top[y]],dfn[y],1,n,1,z);\n      xiugai1(x,fa[top[y]],z);\n   }\n}\n\nlong long chaxun1(long long x,long long y){   /// \u548c\u4fee\u6539\u64cd\u4f5c\u57fa\u672c\u4e00\u81f4\n\n   long long xx=no[x],yy=no[y];\n   if(xx==yy){\n      long long xxx=dfn[x],yyy=dfn[y];\n      if(xxx>yyy) swap(xxx,yyy);\n      return query(xxx,yyy,1,n,1)%P;\n   }\n   long long ans=0;\n   if(xx>yy){\n      ans+=query(dfn[top[x]],dfn[x],1,n,1)%P;\n      ans%=P;\n      ans+=chaxun1(fa[top[x]],y)%P;\n      ans%=P;\n   }\n   if(xx<yy){\n      ans+=query(dfn[top[y]],dfn[y],1,n,1)%P;\n      ans%=P;\n      ans+=chaxun1(x,fa[top[y]])%P;\n      ans%=P;\n   }\n   return ans%P;\n} \n\nlong long chaxun(long long x){                /// \u67d0\u4e00\u8282\u70b9\u7684\u5b50\u6811\u7684\u7f16\u53f7\u4e00\u5b9a\u8fde\u7eed \u53ea\u8981\u627e\u5230 \u8fd9\u4e2a\u8282\u70b9\u7684sz\u4e2a\u6570\u548c dfn \u7f16\u53f7\u5373\u53ef\n   return query(dfn[x],dfn[x]+sz[x]-1,1,n,1)%P;\n}\n\nvoid xiugai(long long x,long long y){         /// \u540c\u4e0a\n   updata(dfn[x],dfn[x]+sz[x]-1,1,n,1,y);\n}\n\n/// \u4ee5\u4e0b\u5c31\u662f\u5e38\u89c4\u7684\u64cd\u4f5c\nint main(){\n    cin>>n>>m>>r>>P;\n    memset(lz,0,sizeof(lz));\n    for(long long j=1;j<=n;j++){\n       cin>>a[j];\n    }\n    memset(vis,0,sizeof(vis));\n    for(long long j=1;j<n;j++){\n       long long x,y;\n       cin>>x>>y;\n       q[x].push_back(y);\n       q[y].push_back(x);\n    }\n    vis[r]=1;\n    dfs(r,1LL*1);\n    \n    memset(vis,0,sizeof(vis));\n    dfs2(r,r);\n    build(1,n,1);\n   \n    for(long long j=0;j<m;j++){\n        long long nu,x,y,z;\n        cin>>nu;\n        if(nu==1){\n           cin>>x>>y>>z;\n           xiugai1(x,y,z);\n        }\n        if(nu==2){\n           cin>>x>>y;\n           cout<<chaxun1(x,y)%P<<endl;;\n        }\n        if(nu==3){\n          cin>>x>>y;\n          xiugai(x,y);\n        }\n        if(nu==4){\n           cin>>x;\n           cout<<chaxun(x)%P<<endl;\n        }\n    }\n    \n    return 0\uff1b\n}\n\n```",
        "postTime": 1533926705,
        "uid": 36983,
        "name": "Dvelpro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u5b89\u5229\u4e00\u53d1\u81ea\u5df1\u535a\u5ba2\n\u5b66\u4e60\u4e4b\u524d\u5fc5\u987b\u8981\u638c\u63e1\u4e00\u4e9b\u77e5\u8bc6\uff0c\u4e0d\u7136\u4f60\u770b\u51e0\u5929\u90fd\u4e0d\u4f1a\u770b\u5f97\u61c2\uff1a\u7ebf\u6bb5\u6811\uff0cdfs\u5e8f\u3002\n\n\u5982\u679c\u638c\u63e1\u4e86\u5c31\u6765\u770b\u4e00\u4e0b\u8fd9\u51e0\u4e2a\u5b9a\u4e49\uff1a\n\n\u91cd\u7ed3\u70b9\uff1a\u5b50\u6811\u7ed3\u70b9\u6570\u76ee\u6700\u591a\u7684\u7ed3\u70b9\uff1b\n\u8f7b\u8282\u70b9\uff1a\u7236\u4eb2\u8282\u70b9\u4e2d\u9664\u4e86\u91cd\u7ed3\u70b9\u4ee5\u5916\u7684\u7ed3\u70b9\uff1b\n\u91cd\u8fb9\uff1a\u7236\u4eb2\u7ed3\u70b9\u548c\u91cd\u7ed3\u70b9\u8fde\u6210\u7684\u8fb9\uff1b\n\u8f7b\u8fb9\uff1a\u7236\u4eb2\u8282\u70b9\u548c\u8f7b\u8282\u70b9\u8fde\u6210\u7684\u8fb9\uff1b\n\u91cd\u94fe\uff1a\u7531\u591a\u6761\u91cd\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\uff1b\n\u8f7b\u94fe\uff1a\u7531\u591a\u6761\u8f7b\u8fb9\u8fde\u63a5\u800c\u6210\u7684\u8def\u5f84\uff1b\n\u5b9a\u4e49\u6ca1\u6709\u4ec0\u4e48\u597d\u8bf4\u7684\uff0c\u6211\u4eec\u5c31\u5f00\u59cb\u6b63\u5f0f\u8bb2\u6811\u94fe\u5256\u5206\u3002\n\n\u5b9e\u73b0\u8fd9\u4e2a\u7b97\u6cd5\u7684\u8f85\u52a9\u6570\u7ec4\n\nsize[x]\t\u4fdd\u5b58\u4ee5x\u4e3a\u6839\u7684\u5b50\u6811\u8282\u70b9\u4e2a\u6570\n\ntop[x]\t\u4fdd\u5b58\u5f53\u524d\u8282\u70b9\u6240\u5728\u94fe\u7684\u9876\u7aef\u8282\u70b9\n\nson[x]\t\u4fdd\u5b58\u91cd\u513f\u5b50\n\ndeep[x]       \t\u4fdd\u5b58\u7ed3\u70b9x\u7684\u6df1\u5ea6\u503c\n\nfa[x]\t\u4fdd\u5b58\u7ed3\u70b9u\u7684\u7236\u4eb2\u8282\u70b9\n\nid[x]\t\u4fdd\u5b58\u6811\u4e2d\u6bcf\u4e2a\u8282\u70b9\u5256\u5206\u4ee5\u540e\u7684\u65b0\u7f16\u53f7\uff08DFS\u7684\u6267\u884c\u987a\u5e8f\uff09\n \n\n\u6b64\u5916\u8fd8\u6709\u4e24\u6761\u6027\u8d28\n\n1.\u5982\u679c\uff08u\uff0cv\uff09\u662f\u8f7b\u8fb9\uff0c\u90a3\u4e48size[v]<size[u]/2\n\n2.\u4ece\u6839\u7ed3\u70b9\u5230\u4efb\u610f\u7ed3\u70b9\u7684\u8def\u6240\u7ecf\u8fc7\u7684\u8f7b\u91cd\u94fe\u7684\u4e2a\u6570\u5fc5\u5b9a\u90fd\u5c0f\u4e0eO(logn)\uff1b\n\n\u7136\u540e\u6211\u4eec\u8981\u5bf9\u8fd9\u68f5\u6811\u8fdb\u884c\u9884\u5904\u7406\n\n\u6211\u4eec\u7528\u5230\u4e86\u4e24\u4e2adfs\uff0cdfs1\u662f\u5904\u7406\u5b50\u6811\u5927\u5c0f\u548c\u7236\u5b50\u5173\u7cfb\u8fd8\u6709\u8282\u70b9\u6df1\u5ea6\u7684\uff0cdfs2\u662f\u7528\u6765\u5904\u7406\u7f16\u53f7\u548c\u91cd\u94fe\u4ee5\u53ca\u4e2d\u513f\u5b50\u7684\u3002\n\n\u7136\u540e\u8fd9\u4e24\u4e2adfs\u6bd4\u8f83\u597d\u7406\u89e3\uff0c\u8fd9\u91cc\u5c31\u53ea\u7c98\u4ee3\u7801\uff0c\u4ee3\u7801\u91cc\u9762\u6709\u6ce8\u91ca\uff0c\u53ef\u4ee5\u611f\u6027\u7406\u89e3\u4e00\u4e0b\u3002\n\n dfs1\n ```cpp\n void dfs1(int x,int f)\n{\n    fa[x]=f;//\u9996\u5148\u8bb0\u5f55\u7236\u4eb2 \n    size[x]=1;\n    for(int i=head[x]; i!=-1; i=e[i].next)\n    {\n        if(!deep[e[i].to] && e[i].to != f)\n        {\n            deep[e[i].to]=deep[x]+1;//\u6df1\u5ea6 \n            dfs1(e[i].to,x);\n            size[x]+=size[e[i].to];//\u5b50\u6811\u5927\u5c0f \n            if(size[e[i].to]>size[son[x]]) son[x]=e[i].to;//\u5982\u679c\u5f53\u524d\u5b50\u6811\u6bd4\u4e2d\u513f\u5b50\u7684\u5b50\u6811\u5927\uff0c\u90a3\u4e48\u5f53\u524d\u5b50\u6811\u7684\u6839\u4e3a\u91cd\u513f\u5b50 \n        }\n    }\n}\n ```\n dfs2\n ```cpp\n void dfs2(int x,int topf)//topf\u4e3a\u5f53\u524d\u91cd\u94fe\u7684\u9876\u90e8 \n{\n    idx[x] = ++cnt;//\u7f16\u53f7 \n    top[x] = topf;\n    if(!son[x]) return;//\u5c0f\u4f18\u5316 \n    dfs2(son[x],topf);\n    for(int i=head[x]; i!=-1; i=e[i].next)\n        if(!idx[e[i].to] && e[i].to!=fa[x]) dfs2(e[i].to,e[i].to);\n}\n\n ```\n\u7406\u89e3\u4e86\u4e24\u4e2adfs\uff0c\u6211\u4eec\u5c31\u597d\u8fdb\u884c\u4e86\uff01\n\n\u5176\u4f59\u7684\u4e8b\u60c5\u5c31\u662f\u7ebf\u6bb5\u6811\u505a\u7684\u4e8b\u4e86\uff0c\u533a\u95f4\u52a0\u548c\uff0c\u533a\u95f4\u67e5\u8be2\uff0cpushdown\u64cd\u4f5c\u4e00\u6837\u3002\u4f46\u662f\u6811\u94fe\u5256\u5206\u8fd8\u6709\u51e0\u4e2a\u5176\u4ed6\u7684\u64cd\u4f5c\u3002\n\n1.\u8282\u70b9\u8def\u5f84\u4fee\u6539\n\n2.\u8282\u70b9\u8def\u5f84\u67e5\u8be2\u548c\n\n3.\u5b50\u6811\u4fee\u6539\n\n4.\u5b50\u6811\u67e5\u8be2\n\n5.\u6362\u6839\n\n\u8282\u70b9\u8def\u5f84\u4fee\u6539\u8fd9\u4e2a\u64cd\u4f5c\u9700\u8981\u7528\u5230\u4e00\u4e2a\u51fd\u6570\uff1a\u6811\u4e0a\u4fee\u6539\uff08change_tree)\n\n\u8fd9\u4e2a\u601d\u60f3\u5c31\u662f\u7528\u5230\u4e86\u500d\u589e\uff0c\u8fd9\u6837\u8003\u8651\uff0c\u56e0\u4e3a\u4e24\u4e2a\u8282\u70b9\u5206\u522b\u5728\u4e24\u6761\u91cd\u94fe\u4e0a\uff0c\u7136\u540e\u4f60\u4e0d\u65ad\u7f29\u77ed\u91cd\u94fe\uff0c\u671f\u95f4\u4e0d\u65ad\u8fdb\u884c\u533a\u95f4\u4fee\u6539\uff0c\u7136\u540e\u8fd9\u4e24\u4e2a\u8282\u70b9\u6700\u540e\u4e00\u5b9a\u5728\u4e00\u4e2a\u91cd\u94fe\u4e0a\uff0c\u5728\u8fdb\u884c\u6700\u540e\u4e00\u6b65\u533a\u95f4\u4fee\u6539\uff0c\u5927\u529f\u544a\u6210\u3002\u6811\u4e0a\u67e5\u8be2\u4e5f\u662f\u8fd9\u6837\u7684\u3002\u7136\u540e\u5c31\u662f\u8fd9\u6bb5\u4ee3\u7801\u3002\n\n```cpp\nvoid add_tree(int x,int y,int val)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        add_interval(1,idx[top[x]],idx[x],val);\n        x=fa[top[x]];\n    }\n    if(deep[x]<deep[y]) swap(x,y);\n    add_interval(1,idx[y],idx[x],val);\n}\n```\n\n```cpp\nint asksum_tree(int x,int y)\n{\n    int ans=0;\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]]) swap(x,y);\n        ans=(ans+asksum_interval(1,idx[top[x]],idx[x]))%p;\n        x=fa[top[x]];\n    }\n    if(deep[x]<deep[y]) swap(x,y);\n    return (ans+asksum_interval(1,idx[y],idx[x]))%p;\n}\n\n\u5b50\u6811\u4fee\u6539\u548c\u5b50\u6811\u67e5\u8be2\u4e5f\u975e\u5e38\u7684\u7b80\u5355\u3002\u4f60\u53ef\u4ee5\u89c2\u5bdf\u4e00\u4e0b\u53d1\u73b0\uff0c\u56e0\u4e3a\u6811\u6620\u5c04\u5230\u7ebf\u6bb5\u6811\u4e0a\u7684\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u6240\u4ee5\u5b83\u7684\u5b50\u6811\u7684\u533a\u95f4\u4e3a[id[x],id[x]+size[x]-1]\uff0c\u6240\u4ee5\u4ee3\u7801\u5982\u4e0b\n```\n```cpp\n//\u5b50\u6811\u4fee\u6539\nchange_interval(1,id[x],id[x]+size[x]-1,val)\n//\u5b50\u6811\u67e5\u8be2\nask_interval(1,id[x],id[x]+size[x]-1)\n```\n \u4e4b\u540e\u5c31\u662f\u6211\u6240\u8bf4\u7684\u6362\u6839\u64cd\u4f5c\u3002\u8fd9\u4e2a\u64cd\u4f5c\u770b\u4f3c\u5f88\u9ebb\u70e6\uff0c\u5176\u5b9e\u4e0d\u7136\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u5206\u7c7b\u8ba8\u8bba\u7684\u601d\u60f3\uff1a\u8bbe\u67e5\u8be2\u70b9\u4e3aa\uff0c\u5f53\u524d\u6839\u8282\u70b9\u4e3aroot\n\n1.\u67e5\u8be2\u70b9\u4e0e\u6839\u8282\u70b9\u76f8\u540c\uff1a\u76f4\u63a5\u8fd4\u56de\u6839\u8282\u70b9\u7684\u503c\n\n2.LCA(a,root)!=a \u90a3\u4e48\u76f4\u63a5\u8fd4\u56dea\u7684\u5b50\u6811\u7684\u4fe1\u606f\n\n3.LCA(a,root)==a \uff0c\u6240\u4ee5a\u548croot\u5728\u4e00\u68f5\u5b50\u6811\uff0c\u56e0\u4e3a\u8fd9\u68f5\u6811\u5bf9\u5e94\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u533a\u95f4\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8bbf\u95ee\u9664root\u5b50\u6811\u4e4b\u5916\u7684\u6240\u6709\u7684\u533a\u95f4\uff0c\u5c31\u662f\u67e5\u8be2a\u7684\u5b50\u6811```[1,id[root]-1]&[id[root]+size[x],n]```\n\n\u6709\u4e9b\u9898\u6709\u53ef\u80fd\u4f60\u4f1a\u78b0\u4e0a\u6811\u5256\u6c42LCA\uff0c\u8fd9\u91cc\u5c31\u5949\u4e0a\u6811\u5256\u6c42LCA\u4ee3\u7801\uff0c\u4ee3\u7801\u5f88\u7b80\u5355\uff0c\u4f60\u4e00\u5b9a\u80fd\u770b\u61c2\uff0c\u800c\u4e14\u4f60\u4f1a\u53d1\u73b0\u8017\u65f6\u60ca\u7684\u4e00\u6279\n\n\n```cpp\nint LCA(int x,int y)\n{\n    while(top[x]!=top[y])\n    {\n        if(deep[top[x]]<deep[top[y]])swap(x,y);\n        x=fa[top[x]];\n    }\n    return deep[x]<=deep[y]? x:y;\n}\n```\n",
        "postTime": 1533680847,
        "uid": 78228,
        "name": "\u6211\u6ca1\u6709\u5c0f\u767d",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u4e00\u5f00\u59cb\u662f\u5728CSDN\u4e0a\u5199\u7684,\u672c\u6765\u60f3\u7740\"\u90fd\u662fmarkdown\u590d\u5236\u8fc7\u6765\u5e94\u8be5\u5c31\u884c\u4e86\u5427\",\u7ed3\u679c\u5e76\u4e0d\u884c,\u590d\u5236\u8fc7\u6765\u5c31\u53d8\u5f97\u4e71\u4e03\u516b\u7cdf,\u5b9e\u5728\u6ca1\u6cd5\u590d\u539f\u4e86,\u56e0\u6b64\u5728\u8fd9\u91cc\u5e72\u8106\u53ea\u7ed9\u51fa\u7b80\u5355\u6ce8\u91ca\u7684AC\u4ee3\u7801,\u5177\u4f53\u7ec6\u8282\u8bf7\u5230\u6211\u7684CSDN\u535a\u5ba2\u8e29\u6c34\u5427.\n\n[http://blog.csdn.net/snake52996/article/details/79284430](http://blog.csdn.net/snake52996/article/details/79284430)\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAX=100010;\nint count_edge=0;//\u8fb9\u6570\u7684\u5e8f\u53f7\nint Index=0;//\u7f16\u53f7\u7528\u7684\u5e8f\u53f7\nint n,pp;\nbool visited[MAX];\n\ntemplate<typename T>\nstruct sgtree\n{\n\tprivate:\n\tT tree[MAX<<2];\n\tT change[MAX<<2];\n\tT p;\n\t\n\tvoid updata(int t)\n\t{\n\t\ttree[t]=(tree[t<<1]+tree[t<<1|1])%p;\n\t\treturn;\n\t}\n\t\n\tvoid pushdown(int t,int l,int r)\n\t{\n\t\tif(!change[t]) return;\n\t\tint t1=t<<1;\n\t\tint t2=t<<1|1;\n\t\tint m=(l+r)>>1;\n\t\ttree[t1]=(tree[t1]+change[t]*(m-l))%p;\n\t\ttree[t2]=(tree[t2]+change[t]*(r-m))%p;\n\t\tchange[t1]=(change[t1]+change[t])%p;\n\t\tchange[t2]=(change[t2]+change[t])%p;\n\t\tchange[t]=0;\n\t\treturn;\n\t}\n\t\n\tpublic:\n\tvoid init(T mo)\n\t{\n\t\tp=mo;\n\t\treturn;\n\t}\n\t\n\tvoid build(T a[],int l,int r,int t)\n\t{\n\t\tif(l==r-1) tree[t]=a[l]%p;\n\t\telse{\n\t\t\tint m=(l+r)>>1;\n\t\t\tbuild(a,l,m,t<<1);\n\t\t\tbuild(a,m,r,t<<1|1);\n\t\t\tupdata(t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tvoid add(int t,int l,int r,int low,int high,T v)\n\t{\n\t\tif(low<=l && r<=high){\n\t\t\ttree[t]=(tree[t]+v*(r-l))%p;\n\t\t\tchange[t]=(change[t]+v)%p;\n\t\t}else{\n\t\t\tpushdown(t,l,r);\n\t\t\tint m=(l+r)>>1;\n\t\t\tif(low<m) add(t<<1,l,m,low,high,v);\n\t\t\tif(m<high) add(t<<1|1,m,r,low,high,v);\n\t\t\tupdata(t);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tT cal(int t,int l,int r,int low,int high)\n\t{\n\t\tif(low<=l && r<=high) return tree[t]%p;\n\t\tpushdown(t,l,r);\n\t\tint m=(l+r)>>1;\n\t\tT ans=0;\n\t\tif(low<m) ans+=cal(t<<1,l,m,low,high);\n\t\tif(m<high) ans+=cal(t<<1|1,m,r,low,high);\n\t\treturn ans;\n\t}\n};\nsgtree<int> sgt;\n\nstruct edge//\u4f7f\u7528\u94fe\u8868\u5b58\u50a8\u907f\u514d\u7206\u7a7a\u95f4\u548c\u88ab\u5361\n{\n\tint id;\n\tedge* next;\n\t\n\tedge()\n\t{\n\t\tid=0;\n\t\tnext=NULL;\n\t}\n}e[MAX<<1];//\u7531\u4e8e\u8981\u5b58\u53cc\u5411\u5f00\u53cc\u500d\u5927\u5c0f\n\nedge* temp[MAX];\n\nstruct node\n{\n\tint id;//\u7f16\u53f7\n\tint f;//\u7236\u8282\u70b9\n\tint hson;//\u91cd\u5b50\u8282\u70b9\n\tint val;\n\tint top;//\u94fe\u9876\u8282\u70b9\u7684\u5e8f\u53f7\n\tint dep;//\u6df1\u5ea6\n\tint size;\n\tedge* head;\n\t\n\tnode()\n\t{\n\t\tid=0;\n\t\tf=0;\n\t\thson=0;\n\t\tval=0;\n\t\ttop=0;\n\t\tdep=0;\n\t\tsize=0;\n\t\thead=NULL;\n\t}\n}a[MAX];\n\nint tempval[MAX];\n\nvoid link_constructor(int t)//\u7b2c\u4e00\u6b21DFS\n{\n\ta[t].size=1;\n\tvisited[t]=1;\n\t\n\tedge* tar=temp[t];\n\twhile(tar!=NULL)\n\t{\n\t\tedge* tt=tar->next;\n\t\tif(!visited[tar->id])\n\t\t{\n\t\t\ta[tar->id].f=t;\n\t\t\ta[tar->id].dep=a[t].dep+1;\n\t\t\tlink_constructor(tar->id);\n\t\t\tif(a[t].hson==0 || a[a[t].hson].size<a[tar->id].size) a[t].hson=tar->id;\n\t\t\ta[t].size+=a[tar->id].size;\n\t\t\ttar->next=a[t].head;\n\t\t\ta[t].head=tar;\n\t\t}\n\t\ttar=tt;\n\t}\n\treturn;\n}\n\nvoid split_constructor(int t)//\u7b2c\u4e8c\u6b21DFS\n{\n\ta[t].id=++Index;\n\tif(a[t].hson)\n\t{\n\t\ta[a[t].hson].top=a[t].top;\n\t\tsplit_constructor(a[t].hson);\n\t}\n\t\n\tedge* tar=a[t].head;\n\twhile(tar!=NULL)\n\t{\n\t\tif(tar->id!=a[t].hson)\n\t\t{\n\t\t\ta[tar->id].top=tar->id;\n\t\t\tsplit_constructor(tar->id);\n\t\t}\n\t\ttar=tar->next;\n\t}\n\treturn;\n}\n\nvoid sgtree_constructor(int p)//\u521d\u59cb\u5316\u7ebf\u6bb5\u6811\n{\n\tsgt.init(p);\n\tfor(int i=1;i<=n;i++) tempval[a[i].id]=a[i].val;\n\tsgt.build(tempval,1,n+1,1);\n\treturn;\n}\n\nvoid major_constructor(int r,int p)\n{\n\ta[r].dep=1;\n\tlink_constructor(r);\n\ta[r].top=r;\n\tsplit_constructor(r);\n\tsgtree_constructor(p);\n\treturn;\n}\n\nvoid mod_xtoy(int x,int y,int v)//\u4fee\u6539x\u5230y\u8def\u5f84\u4e0a\u7684\u6743\u503c\n{\n\twhile(a[x].top!=a[y].top)\n\t{\n\t\tif(a[a[x].top].dep<a[a[y].top].dep) swap(x,y);\n\t\tsgt.add(1,1,n+1,a[a[x].top].id,a[x].id+1,v);\n\t\tx=a[a[x].top].f;\n\t}\n\tsgt.add(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1,v);\n\treturn;\n}\n\nint cal_xtoy(int x,int y)//\u5bf9x\u5230y\u8def\u5f84\u4e0a\u7684\u6743\u503c\u6c42\u548c\n{\n\tint ans=0;\n\twhile(a[x].top!=a[y].top)\n\t{\n\t\tif(a[a[x].top].dep<a[a[y].top].dep) swap(x,y);\n\t\tans=(ans+sgt.cal(1,1,n+1,a[a[x].top].id,a[x].id+1))%pp;\n\t\tx=a[a[x].top].f;\n\t}\n\tans=(ans+sgt.cal(1,1,n+1,min(a[x].id,a[y].id),max(a[x].id,a[y].id)+1))%pp;\n\treturn ans;\n}\n\nint main()\n{\n\tint m,r,x,y;\n\tscanf(\"%d%d%d%d\",&n,&m,&r,&pp);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i].val);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\te[count_edge].id=y;\n\t\te[count_edge].next=temp[x];\n\t\ttemp[x]=&e[count_edge++];\n\t\t\n\t\te[count_edge].id=x;\n\t\te[count_edge].next=temp[y];\n\t\ttemp[y]=&e[count_edge++];\n\t}\n\t\n\tmajor_constructor(r,pp);\n\t\n\tint flag,z;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&flag,&x);\n\t\tif(flag==4) printf(\"%d\\n\",sgt.cal(1,1,n+1,a[x].id,a[x].id+a[x].size)%pp);//\u4e0d\u80fd\u5fd8\u8bb0\u53d6\u4f59\n\t\telse if(flag==3){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tsgt.add(1,1,n+1,a[x].id,a[x].id+a[x].size,z);\n\t\t}else if(flag==2){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tprintf(\"%d\\n\",cal_xtoy(x,y)%pp);//\u4e5f\u4e0d\u80fd\u5fd8\u8bb0\u53d6\u4f59\n\t\t}else{\n\t\t\tscanf(\"%d%d\",&y,&z);\n\t\t\tmod_xtoy(x,y,z);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u4ee3\u7801\u5f88\u4e11,\u8bf7\u51d1\u5408\u770b...",
        "postTime": 1518956280,
        "uid": 56568,
        "name": "hoetateyo",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u9898\u76ee\u94fe\u63a5\uff1ahttp://www.luogu.org/problemnew/show/3384\n\n\u7b80\u4ecb:\u4e00\u9053\u6811\u5256\u6a21\u677f\u9898\n\n\u5173\u4e8e\u6811\u5256\uff1a\n\n\u6b65\u9aa4\u4e00\uff1a\u7b2c\u4e00\u6b21dfs\n\n\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u91cd\u513f\u5b50\uff08\u6700\u91cd\u7684\u513f\u5b50\uff09\u548c\u6bcf\u4e2a\u8282\u70b9\u7684\u8d28\u91cf\n\nC++\uff1a\n```cpp\nvoid dfs1(int st)\n{\n    size[st]=1;\n    for(int i=head[st]; i; i=E[i].next)\n    {\n        int ed=E[i].ed;\n        if(fa[st]!=ed)\n        {\n            dep[ed]=dep[st]+1;\n            fa[ed]=st;\n            dfs1(ed);\n            if(hson[st]==0||size[hson[st]]<size[ed])    hson[st]=ed;\n            size[st]+=size[ed];\n        }\n    }\n}\n```\n\u4f2a\u4ee3\u7801\uff1a\n\n```cpp\nFunc dfs1(st)\n    Size[st]=1\n    For(every node ed connected to the current node)\n        If(is not father of node now)\n            Depth[ed]=depth[st]+1\n            Father[ed]=st\n```\nCheck whether ed is the heaviest\n\n            Size[st]+=size[ed]\n\n\u6b65\u9aa4\u4e8c\uff1a\u7b2c\u4e8c\u904d\u641c\u7d22\uff1a\u6c42\u51fa\u6bcf\u4e00\u6761\u91cd\u8fb9\u7684\u7956\u5148\uff0c\u5efa\u7acb\u9898\u76ee\u6240\u7ed9\u7684\u8282\u70b9\u5e8f\u53f7\u548c\u7ebf\u6bb5\u6811\u5b58\u50a8\u5e8f\u53f7\u7684\u6620\u5c04\n\n\u5728\u7ebf\u6bb5\u6811\u4e2d\uff0c\u5b58\u50a8\u7684\u662f\u91cd\u8282\u70b9\u4f18\u5148\u7684\u5148\u5e8f\u904d\u5386\uff0c\u597d\u5904\u6709\u4e8c\uff1a\n\n1\uff1a\u4ee5s\u4e3a\u6839\u7684\u5b50\u6811\u7684\u8282\u70b9\u662f\u8fde\u7eed\u7684\n\n2\uff1a\u6bcf\u4e00\u6761\u91cd\u8fb9\u90fd\u662f\u8fde\u7eed\u7684\n\nC++\u4ee3\u7801\uff1a\n\n```cpp\nvoid dfs2(int st,int anc)\n{\n    top[st]=anc;//\u6c42\u91cd\u8fb9\u7956\u5148\n    sid[st]=++tot;//\u5efa\u7acb\u6620\u5c04\n    real[tot]=st;//\u5efa\u7acb\u6620\u5c04\n    if(hson[st]==0) return;\n    dfs2(hson[st],anc);//\u91cd\u513f\u5b50\u4f18\u5148\n    for(int i=head[st]; i; i=E[i].next)\n    {\n        int ed=E[i].ed;\n        if(ed!=fa[st]&&ed!=hson[st])\n            dfs2(ed,ed);//\u5176\u4ed6\u513f\u5b50\u662f\u8f7b\u8fb9\n    }\n}\n```\n\u4f2a\u4ee3\u7801\uff1a\n\nFunc dfs2(int st,int ancester)\n\n    Top[st]=ancestor\n\n    Build\\_connection(st)\n\nIf exist heavy\\_son\n\n\n```cpp\n        Dfs2(heavy_son,ancestor)\nFor(every node ed connected to the current node)\n        If(is not father of node now  AND  is not the heavy_son)\n        Dfs2(ed,ed)\n```\n\u6b65\u9aa4\u4e09\uff0c\u5efa\u7acb\u4e00\u9897\u52a0\u6cd5\u7ebf\u6bb5\u6811\n\u8fd9\u91cc\u7684build\\_tree\u51fd\u6570\u6709\u4e00\u70b9\u4e0d\u4e00\u6837\uff1a\n\n```cpp\nvoid build_tree(int L,int R,int id)\n{\n    if(L==R)\n    {\n        T[id].sum=a[real[L]];//\uf0e7\u4e00\u5b9a\u8981\u8003\u8651\u9898\u76ee\u7f16\u53f7\u548c\u7ebf\u6bb5\u6811\u7f16\u53f7\u4e4b\u95f4\u7684\u6620\u5c04\uff01\uff01\uff01\n        return;\n    }\n    int mid=(L+R)/2;\n    build_tree(L,mid,id<<1);\n    build_tree(mid+1,R,id<<1|1);\n    pushup(id);\n}\n```\n\u4ee5\u4e0a\u662f\u9884\u5907\u5de5\u4f5c\uff0c\u4ee5\u4e0b\u8fd8\u6709\u4e24\u79cd\u4fee\u6539\uff0c\u4e24\u79cd\u67e5\u8be2\uff1a\n\n\u5b50\u6811\u4fee\u6539\uff1a\n\n\u7531\u4e8e\u662f\u5148\u5e8f\u904d\u5386\uff0c\u4ee5x\u4e3a\u6839\u7684\u5b50\u8282\u70b9\u80af\u5b9a\u5728\u7ebf\u6bb5\u6811\u533a\u95f4][ sid[x],sid[i]+size[x]-1 ]\u5185\n\n\u53ea\u6709\u4e00\u884c\u4ee3\u7801\uff1a\n\nmodify(sid[x],sid[x]+size[x]-1\uff0cnum\\_to\\_add);//\u8fd9\u662f\u4f2a\u4ee3\u7801\n\n\u5b50\u6811\u67e5\u8be2\uff1a\n\n\u53ea\u662f\u628a\u4fee\u6539\u6362\u6210\u4e86\u67e5\u8be2\u800c\u5df2\n\n    Query(sid[x],sid[x]+size[x]-1)\n\n\u91cd\u5934\u620f\uff1a\u94fe\u4fee\u6539 u to v\uff08\u9898\u76ee\u5e8f\u53f7\uff09\n\n1\uff1au\uff0cv\u5728\u4e00\u6761\u91cd\u8fb9\u4e0a\n\n\u4fdd\u6301\u5927\u5c0f\u5173\u7cfb\uff0c\u4e4b\u540emodify\uff08sid[u],sid[v],num\\_to\\_add\uff09\n\n2: u,v\u4e0d\u5728\u4e00\u6761\u91cd\u8fb9\u4e0a\uff1a\n\n\u90a3\u4e48u\u548cv\u4e0d\u505c\u5730\u5411\u4e0a\u8df3\uff0c\u4e00\u5b9a\u4f1a\u8df3\u5230\u4e00\u6761\u91cd\u8fb9\u4e0a\n\n\u6bcf\u6b21\u9009\u53d6\u6240\u5728\u94fe\u7684\u6240\u5728\u94fe\u5934\u7ed3\u70b9\u8f83\u4f4e\u7684\u90a3\u4e00\u6761\u94fe\u8fdb\u884c\u7edf\u8ba1\uff0c\u7edf\u8ba1\u5b8c\u4e86\u4e4b\u540e\u5728\u5411\u4e0a\u52a0\uff08\u8df3\uff09\n\n```cpp\nvoid chain_add()\n{\n    LL u,v,w,tu,tv;\n    scanf(\"%lld%lld%lld\",&u,&v,&w);\n    tu=top[u],tv=top[v];\n    while(tu!=tv)\n{\n        if(dep[tu]<dep[tv])\n            swap(tu,tv),swap(u,v);\n        modify(sid[tu],sid[u],w,1,N,1);\n        u=fa[tu];\n        tu=top[u];\n    }\n    if(dep[u]<dep[v])   swap(u,v);\n    modify(sid[v],sid[u],w,1,N,1);\n}\n```\n\u4f2a\u4ee3\u7801\uff1a\n\nFunc chain\\_add(u,v)\n\n    Tu=top[u]    tv=top[v]\n\nWhile(not in the same chain    =>     tu!=tv)\n\nMake u the deepest\n\n    modify(sid[tu],sid[u])\n\n    Jump                    =>  u=father[tu] tu=top[u]\n\nMake u the deepest\n\nModify(sid[v],sid[u])\n\n\u67e5\u8be2\uff1a\u628a\u7ebf\u6bb5\u6811\u4fee\u6539\u6362\u6210\u67e5\u8be2\n\n```cpp\nvoid chain_query()\n{\n    LL u,v,tu,tv,ret=0;\n    scanf(\"%lld%lld\",&u,&v);\n    tu=top[u],tv=top[v];\n    while(tu!=tv)\n    {\n        if(dep[tu]<dep[tv])\n        {\n            swap(tu,tv);\n            swap(u,v);\n        }\n        ret+=query(sid[tu],sid[u],1,N,1);\n        ret%=P;\n        u=fa[tu];\n        tu=top[u];\n    }\n    if(dep[u]<dep[v])   swap(u,v);\n    ret+=query(sid[v],sid[u],1,N,1);\n    printf(\"%lld\\n\",ret%P);\n}\n```\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n\n#include <algorithm>\n#include <queue>\n#include <stack>\n\nusing namespace std;\ntypedef long long LL;\nstruct edge\n{\n    int ed,next;\n} E[int(1e6)+10];\nint head[100100],Ecnt;\nint N,M,R,P;\nLL a[100100];\nstruct node\n{\n    LL sum,atag;\n} T[100100<<3];\nLL real[100010],sid[100010],hson[100010],fa[100010],dep[100010],size[100010],top[100010];\nLL tot;\n// code\nvoid addEdge(int st,int ed)\n{\n    E[++Ecnt].ed=ed;\n    E[Ecnt].next=head[st];\n    head[st]=Ecnt;\n}\n\nvoid dfs1(int st)\n{\n    size[st]=1;\n    for(int i=head[st]; i; i=E[i].next)\n    {\n        int ed=E[i].ed;\n        if(fa[st]!=ed)\n        {\n            dep[ed]=dep[st]+1;\n            fa[ed]=st;\n            dfs1(ed);\n            if(hson[st]==0||size[hson[st]]<size[ed])    hson[st]=ed;\n            size[st]+=size[ed];\n        }\n    }\n}\nvoid dfs2(int st,int anc)\n{\n    //printf(\"dfs2 st=%d anc=%d\\n\",st,anc);\n    top[st]=anc;\n    //printf(\"top[%d]=%d\\n\",st,top[st]);\n    sid[st]=++tot;\n    real[tot]=st;\n    if(hson[st]==0) return;\n    dfs2(hson[st],anc);\n    for(int i=head[st]; i; i=E[i].next)\n    {\n        int ed=E[i].ed;\n        if(ed!=fa[st]&&ed!=hson[st])\n            dfs2(ed,ed);\n    }\n}\n\n/// \u7ebf\u6bb5\u6811\nvoid pushup(int id)\n{\n    T[id].sum=T[id<<1].sum+T[id<<1|1].sum;\n}\nvoid pushdown(int L,int R,int id)\n{\n    if(T[id].atag)\n    {\n        if(L!=R)\n        {\n            T[id<<1].atag+=T[id].atag;\n            T[id<<1|1].atag+=T[id].atag;\n        }\n        T[id].sum+=(R-L+1)*T[id].atag;\n        T[id].atag=0;\n    }\n}\nvoid build_tree(int L,int R,int id)\n{\n    if(L==R)\n    {\n        T[id].sum=a[real[L]];\n        return;\n    }\n    int mid=(L+R)/2;\n    build_tree(L,mid,id<<1);\n    build_tree(mid+1,R,id<<1|1);\n    pushup(id);\n}\nvoid modify(int B,int E,int x,int L,int R,int id)\n{\n    if(L>E||R<B)    return;\n    pushdown(L,R,id);\n    if(L>=B&&R<=E)\n    {\n        T[id].atag+=x;\n        return;\n    }\n    int mid=(L+R)>>1;\n    modify(B,E,x,L,mid,id<<1);\n    modify(B,E,x,mid+1,R,id<<1|1);\n    pushdown(L,mid,id<<1);\n    pushdown(mid+1,R,id<<1|1);\n    pushup(id);\n}\nLL query(int B,int E,int L,int R,int id)\n{\n    if(L>E||R<B)    return 0ll;\n    pushdown(L,R,id);\n    if(L>=B&&R<=E)\n        return T[id].sum%P;\n    int mid=(L+R)>>1;\n    return query(B,E,L,mid,id<<1)+query(B,E,mid+1,R,id<<1|1);\n}\n///end of segment tree\nvoid tree_add()\n{\n    //cout<<__func__<<endl;\n    LL x,v;\n    scanf(\"%lld%lld\",&x,&v);\n    modify(sid[x],sid[x]+size[x]-1,v,1,N,1);\n}\nvoid tree_query()\n{\n    //cout<<__func__<<endl;\n    LL x;\n    scanf(\"%lld\",&x);\n    printf(\"%lld\\n\",query(sid[x],sid[x]+size[x]-1,1,N,1)%P);\n}\n\nvoid chain_add()\n{\n    //cout<<__func__<<endl;\n    LL u,v,w,tu,tv;\n    scanf(\"%lld%lld%lld\",&u,&v,&w);\n    //cout<<\"[\"<<u<<\",\"<<v<<\"]\"<<endl;\n    tu=top[u],tv=top[v];\n    //printf(\"%lld %lld\\n\",tu,tv);\n    while(tu!=tv)\n    {\n        //printf(\"dep[tu]=%lld,dep[tv]=%lld\\n\",dep[tu],dep[tv]);\n        if(dep[tu]<dep[tv])\n        {\n            swap(tu,tv);\n            swap(u,v);\n        }\n        modify(sid[tu],sid[u],w,1,N,1);\n        //printf(\"modifyed %lld to %lld\\n\",tu,u);\n        u=fa[tu];\n        tu=top[u];\n    }\n    if(dep[u]<dep[v])   swap(u,v);\n    modify(sid[v],sid[u],w,1,N,1);\n       // printf(\"modified %lld to %lld\\n\",v,u);\n}\n\nvoid chain_query()\n{\n    //printf(\"\\t%lld\\n\",query(sid[3],sid[3],1,N,1));\n    //cout<<__func__<<endl;\n    LL u,v,tu,tv,ret=0;\n    scanf(\"%lld%lld\",&u,&v);\n    tu=top[u],tv=top[v];\n    while(tu!=tv)\n    {\n        if(dep[tu]<dep[tv])\n        {\n            swap(tu,tv);\n            swap(u,v);\n        }\n\n        LL t=query(sid[tu],sid[u],1,N,1);\n        //printf(\"queryed %lld to %lld      == %lld\\n\",tu,u,t);\n        ret+=query(sid[tu],sid[u],1,N,1);\n        ret%=P;\n        //cout<<ret<<endl;\n        u=fa[tu];\n        tu=top[u];\n    }\n    if(dep[u]<dep[v])   swap(u,v);\n    LL t=query(sid[v],sid[u],1,N,1);\n        //printf(\"queryed %lld to %lld      == %lld\\n\",v,u,t);\n    ret+=t;\n    printf(\"%lld\\n\",ret%P);\n}\n///\nvoid init();\nint main()\n{\n    init();\n    //printf(\"\\t%lld\\n\",query(sid[3],sid[3],1,N,1));\n\n    for(int i=1;i<=M;++i)\n    {\n        int q;\n        scanf(\"%d\",&q);\n        switch(q)\n        {\n            case 4:tree_query();break;\n            case 3:tree_add();break;\n            case 2:chain_query();break;\n            case 1:chain_add();break;\n        }\n    }\n    return 0;\n}\nvoid init()\n{\n    scanf(\"%d%d%d%d\",&N,&M,&R,&P);\n    for(int i=1; i<=N; ++i)\n        scanf(\"%lld\",a+i);\n    for(int i=1; i<=N-1; ++i)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        addEdge(x,y);\n        addEdge(y,x);\n    }\n    dep[R]=1;\n    dfs1(R);\n    dfs2(R,R);\n    build_tree(1,N,1);\n}\n```\n",
        "postTime": 1509017617,
        "uid": 20565,
        "name": "wzj423",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "\u770b\u4e86\u51e0\u5929\u7684\u6811\u5256\u4e86\uff0c\u4e00\u76f4\u4e0d\u77e5\u9053\u600e\u4e48\u505a\uff0c\u53ea\u5230\u770b\u4e86\u697c\u4e0b\u5927\u4f6c\u7684\u4ee3\u7801\u624d\u7167\u6253\u4e86\u4e00\u4e2a\n\n\u697c\u4e0b\u5927\u4f6c\u7528\u4e86\u4e09\u76ee\u548c\u5b8f\u5b9a\u4e49\uff0c\u53ef\u60dc\u8eab\u4e3a\u849f\u84bb\u7684\u6211\u4e0d\u7406\u89e3\u4e8e\u662f\u5c31\u628a\u5927\u4f6c\u7684\u4ee3\u7801\u7ffb\u8bd1\u7684\u7b80\u5355\u4e86\u4e00\u70b9\uff0c\u7ed3\u679c\u6709241\u884c\n\n\u5927\u4f53\u5c31\u662f\u7ebf\u6bb5\u6811\u52a0\u6811\u5256\uff0c\u5177\u4f53\u6ce8\u91ca\u53d1\u5728\u9898\u89e3\u91cc\u5427\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#define ll long long\n#define maxn 100010//\u6570\u7ec4\u5343\u4e07\u4e0d\u8981\u5f00\u5927\u4e86\u6216\u8005\u5f00\u5c0f\u4e86\nusing namespace std;\nint a[maxn],n;\nint head[maxn],num;\nint size[maxn],son[maxn],top[maxn],end[maxn],fa[maxn],dep[maxn],pos[maxn];\nint dfsx[maxn],xu=1;\nll sum[maxn<<2],lazy[maxn<<2],bui=1;\nstruct node{\n    int to,from,next;\n}e[maxn<<1];\nll read()//\u8fd9\u4e2a\u5e76\u6ca1\u6709\u4ec0\u4e48\u7528\n{\n    int w=1,x=0;char ch=getchar();\n    while(ch>'9'||ch<'0'){if(ch=='-')w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n    return w*x;\n}\n//\u4ee5\u4e0b\u662f\u7ebf\u6bb5\u6811\u4ee3\u7801\nvoid add(int from,int to)//\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u8fb9\n{\n    num++;\n    e[num].to=to;\n    e[num].next=head[from];\n    head[from]=num;\n}\nvoid build(int root,int l,int r)//\u5efa\u7ebf\u6bb5\u6811\n{\n    if(l==r)\n    {\n        sum[root]=a[dfsx[bui++]];//a[dfsx]\u5b58\u7684\u662f\u5df2\u7ecf\u5904\u7406\u597d\u7684\u6811\u94fe\n        return ;\n    }\n    int mid=(l+r)/2;\n    build(root<<1,l,mid);\n    build(root<<1|1,mid+1,r);\n    sum[root]=sum[root<<1]+sum[root<<1|1];\n}\nvoid push(int root,int l,int r)\n{\n    int mid=(l+r)/2;\n    lazy[root<<1]+=lazy[root];\n    lazy[root<<1|1]+=lazy[root];\n    sum[root<<1]+=lazy[root]*(mid-l+1);\n    sum[root<<1|1]+=lazy[root]*(r-mid);\n    lazy[root]=0;\n    return;\n}\nvoid jia(int root,int left,int right,int l,int r,ll k)\n{\n    if(left>=l&&r>=right)\n    {\n        lazy[root]+=k;\n        sum[root]+=k*(right-left+1);\n        return ;\n    }\n    if(l>right||r<left)return ;\n    int mid=(left+right)/2;\n    if(lazy[root])push(root,left,right);\n    if(l<=mid)jia(root<<1,left,mid,l,r,k);\n    if(r>mid)jia(root<<1|1,mid+1,right,l,r,k);\n    sum[root]=sum[root<<1]+sum[root<<1|1];\n    return ;\n}\nll query(int root,int left,int right,int l,int r)\n{\n    if(left>=l&&right<=r)return sum[root];\n    if(l>right||left>r)return 0;\n    if(lazy[root])push(root,left,right);\n    int mid=(left+right)/2;\n    ll a=query(root<<1,left,mid,l,r);\n    ll b=query(root<<1|1,mid+1,right,l,r);\n    return a+b;\n}\n//\u4ee5\u4e0b\u662f\u6811\u5256\u4ee3\u7801\uff08\u4ee5\u8f7b\u91cd\u94fe\u4e3a\u57fa\u7840\uff09\nvoid dfs1(int x)//\u7b2c\u4e00\u4e2a\u6df1\u641c\uff0c\u7531\u7b2c\u4e00\u4e2a\u6df1\u641c\u6211\u4eec\u53ef\u4ee5\u5f97\u5230\u7684\u662f\u6bcf\u4e2a\u70b9\u7684\u6df1\u5ea6\uff0c\u5b83\u7684\u91cd\u513f\u5b50\uff0c\u4ee5\u5b83\u4e3a\u8282\u70b9\u7684\u5b50\u6811\u7684\u8282\u70b9\u4e2a\u6570\n{\n    int maxsize=0;//\u4e3a\u4e86\u5b58\u91cd\u513f\u5b50\n    for(int i=head[x];i;i=e[i].next)\n    {\n        int u=e[i].to;\n        if(u!=fa[x])//\u56e0\u4e3a\u662f\u53cc\u5411\u8fb9\uff0c\u6240\u4ee5\u4e0d\u80fd\u8d70\u7236\u4eb2\u8282\u70b9\n        {\n            dep[u]=dep[x]+1;\n            fa[u]=x;\n            size[x]++;\n            dfs1(u);\n            size[x]+=size[u];\n            if(size[u]>maxsize)\n            {\n                son[x]=u;\n                maxsize=size[u];\n            }\n        }\n    }\n    return ;\n}\nvoid dfs2(int x,int s)//\u7b2c\u4e8c\u4e2a\u6df1\u641c\u662f\u6784\u9020\u91cd\u94fe\uff0c\u6309\u987a\u5e8f\u5b58\u4e0b\u6811\u94fe\n{\n    bool f=1;//\u5224\u65ad\u662f\u5426\u6709\u91cd\u513f\u5b50\n    if(son[x])\n    {\n        f=0;\n        top[son[x]]=s;\n        dfsx[xu++]=son[x];//\u91cd\u94fe\u662f\u4ee5\u4f18\u5148\u6bcf\u4e2a\u91cd\u513f\u5b50\u76f8\u8fde\u7684\n        dfs2(son[x],s);//\u6df1\u641c\u5b83\u7684\u91cd\u513f\u5b50\n    }\n    for(int i=head[x];i;i=e[i].next)\n    {    \n        int u=e[i].to;\n        if(u!=fa[x]&&u!=son[x])\n        {\n            if(f)//\u5982\u679c\u5f53\u524d\u70b9\u65e2\u4e0d\u662f\u7236\u8282\u70b9\u53c8\u4e0d\u662f\u91cd\u513f\u5b50\u5c31\u5224\u65ad\u5b83\u662f\u5426\u662f\u53e6\u5916\u4e00\u6761\u91cd\u94fe\u7684\u5934\n            top[u]=s,f=0;\n            else top[u]=u;//\u6709\u91cd\u513f\u5b50\uff0c\u5b83\u5c31\u662f\u9876\u7aef\n            dfsx[xu++]=u;\n            dfs2(u,u);\n        }\n    }\n    end[x]=xu-1;//\u4ee5x\u5f00\u5934\u7684\u94fe\u6709\u591a\u957f\uff0c\u65b9\u4fbf\u7ebf\u6bb5\u6811\u7684\u7ef4\u62a4\n}\nvoid update_path(int x,int y,int z)//\u4e0elca\u76f8\u4f3c\uff0c\u76ee\u7684\u5c31\u662f\u7ef4\u62a4x\uff0cy\u7684\u6700\u77ed\u8def\u5f84\n{\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)//\u5c06x\uff0cy\u6240\u5728\u7684\u91cd\u94fe\u4e0d\u65ad\u5f80\u4e0a\u8df3\n    {\n        if(dep[fx]>=dep[fy])\n        {\n            jia(1,1,n,pos[fx],pos[x],z);\n            x=fa[fx];\n        }\n        else \n        {\n            jia(1,1,n,pos[fy],pos[y],z);\n            y=fa[fy];\n        }\n        fx=top[x],fy=top[y];\n```\n}//\u7ebf\u6bb5\u6811\u7ef4\u62a4\n```cpp\n    if(x!=y)//\u770b\u5f53\u524dx\uff0cy\u5728\u6811\u94fe\u4e2d\u7684\u4f4d\u7f6e\n    {\n        if(pos[x]<pos[y])\n        {\n            jia(1,1,n,pos[x],pos[y],z);\n        }\n        else jia(1,1,n,pos[y],pos[x],z);\n    }\n    else jia(1,1,n,pos[x],pos[y],z);\n}\nll query_path(int x,int y)//\u540c\u4e0a\uff0c\u53ea\u662f\u6c42\u503c\u800c\u5df2\n{\n    ll ret=0;\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(dep[fx]>=dep[fy])\n        {\n            ret+=query(1,1,n,pos[fx],pos[x]);\n            x=fa[fx];\n        }\n        else \n        {\n            ret+=query(1,1,n,pos[fy],pos[y]);\n            y=fa[fy];\n        }\n        fx=top[x],fy=top[y];\n    }\n    if(x!=y)\n    {\n        if(pos[x]<pos[y])\n        {\n            ret+=query(1,1,n,pos[x],pos[y]);\n        }\n        else ret+=query(1,1,n,pos[y],pos[x]);\n    }\n    else ret+=query(1,1,n,pos[x],pos[y]);\n    return ret;\n}\nvoid update_subtree(int x,int z)\n{\n    jia(1,1,n,pos[x],end[x],z);\n}\nll query_subtree(int x)\n{\n    return query(1,1,n,pos[x],end[x]);\n}\nint main()\n{\n    int m,r,x,y,z,t;\n    ll p;\n    cin>>n>>m>>r>>p;\n    for(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n    for(int i=1;i<n;i++)\n    {\n        scanf(\"%d%d\",&x,&y);\n        add(x,y);\n        add(y,x);\n    }\n    fa[r]=r;//\u5f00\u5934\u7684\u9884\u5904\u7406\n    dep[r]=0;\n    dfs1(r);\n    top[r]=r;//\u4ee5\u6839\u4e3a\u7b2c\u4e00\u6761\u94fe\n    dfsx[xu++]=r;//\u5165\u961f\n    dfs2(r,r);\n    for(int i=1;i<xu;i++)\n    {\n        pos[dfsx[i]]=i;//\u6309\u4f9d\u6b21\u6c42\u51fa\u94fe\u7684\u987a\u5e8f\u5165\u961f\n    }\n    build(1,1,n);\n    while(m--)\n    {\n        scanf(\"%d\",&t);\n            if(t==1)\n            {\n                scanf(\"%d%d%d\",&x,&y,&z);\n                update_path(x,y,z);\n                continue;\n            }\n            if(t==2)\n            {\n                scanf(\"%d%d\",&x,&y);\n                printf(\"%lld\\n\",query_path(x,y)%p);\n                continue;\n            }\n            if(t==3)\n            {\n                scanf(\"%d%d\",&x,&z);\n                update_subtree(x,z);\n                continue;\n            }\n            if(t==4)\n            {    \n                scanf(\"%d\",&x);\n                printf(\"%lld\\n\",query_subtree(x)%p);\n                continue;\n            }\n    }\n    return 0;\n}\n```",
        "postTime": 1507872837,
        "uid": 45212,
        "name": "Epiphyllumthief",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    },
    {
        "content": "###**\u672c\u9898\u6709\u5751\uff01\uff01\uff01\uff01\uff01\uff01\uff01\uff01**###\n\n\u5404\u4f4d\u6811\u5256+\u7ebf\u6bb5\u6811\u82e5\u662fRE\u5f3a\u70c8\u5efa\u8bae\u6570\u7ec4\u5f001000000\uff1b\n\n\u82e5\u662fMLE\u5efa\u8bae\u522b\u7528\u7ed3\u6784\u4f53\uff1b\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int N=1000010;\nint n,m,rt,p;\nint cnt,idx;\nint av[N],size[N],dep[N],fa[N],zl[N],son[N],pos[N],val[N];\nint to[N],nxt[N],head[N];\nint f,x,y,v;\nint ls[N],rs[N];\nlong long sum[N],add[N];\ninline int read(){\n    char c=',';int x=0;\n    while(c<'0'||c>'9')c=getchar();\n    while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n    return x;\n}\ninline void insert(int a,int b){\n    to[++cnt]=b,nxt[cnt]=head[a],head[a]=cnt;\n    to[++cnt]=a,nxt[cnt]=head[b],head[b]=cnt;\n}\nvoid dfs1(int u){\n    size[u]=1;\n    for(int i=head[u];i;i=nxt[i]){\n        int v=to[i];\n        if(v==fa[u])continue;\n        fa[v]=u;\n        dep[v]=dep[u]+1;\n        dfs1(v);\n        if(!son[u]||size[v]>size[son[u]])son[u]=v;\n        size[u]+=size[v];\n    }\n}\nvoid dfs2(int u,int chain){\n    pos[u]=++idx;val[idx]=u;zl[u]=chain;\n    if(!son[u])return;\n    dfs2(son[u],chain);\n    for(int i=head[u];i;i=nxt[i]){\n        int v=to[i];\n        if(dep[v]>dep[u]&&v!=son[u])dfs2(v,v);\n    }\n}\nvoid build(int k,int l,int r){\n    ls[k]=l,rs[k]=r,sum[k]=0,add[k]=0;\n    if(l==r){\n        sum[k]=av[val[l]];\n        return;\n    }\n    int mid=l+r>>1;\n    build(k<<1,l,mid);build(k<<1|1,mid+1,r);\n    sum[k]=(sum[k<<1]+sum[k<<1|1])%p;\n}\nvoid pd(int k){\n    if(add[k]){\n        long long ad=add[k];\n        add[k<<1]+=ad;\n        add[k<<1|1]+=ad;\n        sum[k<<1]+=(rs[k<<1]-ls[k<<1]+1)*ad;sum[k<<1]%=p;\n        sum[k<<1|1]+=(rs[k<<1|1]-ls[k<<1|1]+1)*ad;sum[k<<1|1]%=p;\n        add[k]=0;\n    }\n}\nvoid queryadd(int k,int x,int y,int v){\n    int l=ls[k],r=rs[k],mid=l+r>>1;\n    if(l==x&&r==y){\n        sum[k]+=(r-l+1)*v;\n        add[k]+=v;\n        pd(k);\n        return;\n    }\n    pd(k);\n    if(x>mid)queryadd(k<<1|1,x,y,v);\n    else if(y<=mid)queryadd(k<<1,x,y,v);\n    else queryadd(k<<1,x,mid,v),queryadd(k<<1|1,mid+1,y,v);\n    sum[k]=(sum[k<<1]+sum[k<<1|1])%p;\n}\nlong long querysum(int k,int x,int y){\n    int l=ls[k],r=rs[k],mid=l+r>>1;\n    if(l==x&&r==y){\n        return sum[k];\n    }\n    pd(k);\n    if(x>mid)return querysum(k<<1|1,x,y);\n    else if(y<=mid)return querysum(k<<1,x,y);\n    else return (querysum(k<<1,x,mid)+querysum(k<<1|1,mid+1,y))%p;\n}\nvoid solveadd1(int x,int y,int v){\n    while(zl[x]!=zl[y]){\n        if(dep[zl[x]]<dep[zl[y]])swap(x,y);\n        queryadd(1,pos[zl[x]],pos[x],v);\n        x=fa[zl[x]];\n    }\n    if(pos[x]>pos[y])swap(x,y);\n    queryadd(1,pos[x],pos[y],v);\n    return;\n}\nlong long solvesum1(int x,int y){\n    long long sum=0;\n    while(zl[x]!=zl[y]){\n        if(dep[zl[x]]<dep[zl[y]])swap(x,y);\n        sum+=querysum(1,pos[zl[x]],pos[x]);\n        sum%=p;\n        x=fa[zl[x]];\n    }\n    if(pos[x]>pos[y])swap(x,y);\n    sum+=querysum(1,pos[x],pos[y]);\n    sum%=p;\n    return sum;\n}\nint main(){\n    n=read();m=read();rt=read();p=read();\n    for(int i=1;i<=n;i++)av[i]=read();\n    for(int i=1;i<n;i++){\n        x=read();y=read();\n        insert(x,y);\n    }\n    dfs1(rt);dfs2(rt,rt);\n    build(1,1,n);\n    while(m--){\n        f=read();\n        if(f==1){\n            x=read();y=read();v=read();\n            solveadd1(x,y,v%p);\n        }\n        else if(f==2){\n            x=read();y=read();\n            printf(\"%lld\\n\",solvesum1(x,y));\n        }\n        else if(f==3){\n            x=read();v=read();\n            queryadd(1,pos[x],pos[x]+size[x]-1,v);\n        }\n        else if(f==4){\n            x=read();\n            printf(\"%lld\\n\",querysum(1,pos[x],pos[x]+size[x]-1)%p);\n        }\n    }\n    return 0;\n}\n\n```",
        "postTime": 1504970336,
        "uid": 34589,
        "name": "zhang9302002",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3384 \u3010\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206\u3011"
    }
]