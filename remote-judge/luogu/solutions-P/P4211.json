[
    {
        "content": "\u8fd9\u9898\u7edf\u8ba1l~r\u4e2d\u6240\u6709\u70b9\u4e0ez\u7684lca\u7684\u6df1\u5ea6\u4e4b\u548c\u3002\n\n\u66b4\u529b\u5c31\u662f\u628alca\u90fd\u6c42\u51fa\u6765\u3002\u3002\u3002\n\n**\u6240\u4ee5\u6b63\u89e3\u8981\u4e48\u662f\u4e00\u6b21\u6c42\u51fa\u591a\u4e2alca\uff0c\u8981\u4e48\u5c31\u662f\u7528\u7384\u5b66\u7684\u65b9\u6cd5\u628a\u8fd9\u4e2a\u6c42\u591a\u4e2adeep\u7684\u548c\u8f6c\u5316\u4e00\u4e0b\u3002**\n\n~~\u524d\u8005\u6211\u4e0d\u4f1a\u3002~~\n\n***\n\n\u6211\u4eec\u6765\u770b\u540e\u8005\uff1a\n\n$deep[i]$\u662f\u4ec0\u4e48\uff1f\u2014\u2014\u5c31\u662f\u4ece i \u70b9\u5230\u6839\u6709\u591a\u5c11\u4e2a\u70b9\uff08\u5305\u62ec i \uff09\u3002\n\n\u6211\u4eec\u4ece\u6574\u4f53\u4e0a\u8003\u8651\uff0c\u53d1\u73b0\u5bf9\u4e8e\u4e00\u4e2a\u8be2\u95ee\uff1al , r , z \u6765\u8bf4\uff0c\u6240\u6709\u7684 lca \u90fd\u5728 z \u5230\u6839\u7684\u8def\u5f84\u4e0a\u3002**\u4ece\u800c\u6709\u4e00\u4e9b\u70b9\uff0c\u5b83\u4eec\u5bf9\u5f88\u591a\u7684 lca \u7684\u6df1\u5ea6\u90fd\u6709\u8d21\u732e**\uff0c\u800c\u8fd9\u4e2a\u8d21\u732e\u7b49\u4e8e\u5728\u8fd9\u4e2a\u70b9\u4e0b\u9762\u7684 lca \u7684\u4e2a\u6570\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u628a\u6bcf\u4e2a lca \u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e2a\u70b9\u7684\u6743\u503c\u90fd\u52a0\u4e00\u3002\u7136\u540e\u4ece z \u5411\u4e0a\u8d70\u5230\u6839\uff0c\u6cbf\u8def\u7edf\u8ba1\u7684\u6743\u503c\u5c31\u662f\u7b54\u6848\u4e86\u3002\n\n**\u73b0\u5728\u7684\u95ee\u9898\u5c31\u662f\uff1a\u600e\u4e48\u627e\u5230\u8fd9\u4e9b lca \u5e76\u6253\u4e0a\u6807\u8bb0\uff1f**\n\n~~\u60f3\u60f3\u5f53\u521d\u6211\u4eec\u4e0d\u4f1a\u6c42 lca \u7684\u65f6\u5019\uff0c~~\u8981\u6c42lca\uff08x , y\uff09\u65f6\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u6839\u5230 x \u7684\u6240\u6709\u70b9\u67d3\u8272\uff0c\u7136\u540e\u4ece y \u5411\u4e0a\u722c\uff0c\u722c\u5230\u7684\u7b2c\u4e00\u4e2a\u6709\u989c\u8272\u7684\u70b9\u5c31\u662flca (x , y)\u4e86\uff0c\u6211\u4eec\u73b0\u5728\u4e5f\u53ef\u4ee5\u8fd9\u4e48\u505a\u3002\n\n\u5c31\u662f\uff1a\u5bf9\u4e8e\u4e00\u4e2a\u8be2\u95ee\uff1a l , r , z \uff0c\u6211\u4eec\u628a\u6bcf\u4e2a\u70b9 i \uff08 l <= i <= r \uff09 \u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9\u7684\u6743\u503c\u90fd\u52a0\u4e00\uff0c\u8bb0\u5f97\u4e0a\u6587\u6211\u5199\u5230\uff1a**\u6240\u6709\u7684 lca \u90fd\u5728 z \u5230\u6839\u7684\u8def\u5f84\u4e0a**\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ece z \u70b9\u5411\u4e0a\u722c\u5230\u6839\uff0c\u6cbf\u9014\u7edf\u8ba1\u7684\u70b9\u6743\u503c\u4e4b\u548c\uff0c\u5c31\u662f\u7b54\u6848\u4e86\u3002\n\n~~\u8fd9\u6837\u5c31\u6bd4\u66b4\u529b\u5feb\u4e0d\u4e86\u591a\u5c11\u4e86\u3002~~\n\n***\n\n\u662f\u65f6\u5019\u8003\u8651\u4f18\u5316\u7684\u95ee\u9898\u4e86\uff1a\u6211\u4eec\u6bcf\u6b21\u7684\u64cd\u4f5c\u90fd\u662f\u4ece\u67d0\u4e2a\u70b9\u5230\u6839\u7684\uff0c\u6240\u4ee5\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u5c31\u597d\u4e86\u3002\n\n\u4f46\u662f\u8003\u8651\u5230\u6bcf\u6b21\u7edf\u8ba1\u65f6\uff0c\u4e0d\u80fd\u5f88\u597d\u7684\u6392\u9664 l ~ r \u533a\u95f4\u4e4b\u5916\u7684\u70b9\u5bf9 z->\u6839 \u8fd9\u6761\u8def\u5f84\u7684\u8d21\u732e\uff0c\u6240\u4ee5\u6211\u4eec\u6bcf\u6b21\u90fd\u8981\u6e05\u7a7a\u7ebf\u6bb5\u6811\u3002\n\n\u6211\u4eec\u6bcf\u6b21\u6e05\u7a7a\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u4ece l ~ r \u518d\u6dfb\u52a0\u4e00\u904d\uff0c\u6811\u5256+\u7ebf\u6bb5\u6811\u7684\u590d\u6742\u5ea6\u5c31\u662f$O(n * logn * logn)$\u7684\uff0c\u8fd8\u8981\u505a q \u6b21\uff0c\u590d\u6742\u5ea6\u4f9d\u7136\u4e0d\u7406\u60f3\u3002\n\n***\n\n\u770b\u6570\u636e\u8303\u56f4\uff0c$O(n*logn*logn)$\u5e94\u8be5\u5c31\u662f\u6b63\u89e3\u4e86\uff0c\u73b0\u5728\u8981\u60f3\u529e\u6cd5\u4f18\u5316\u6389\u6700\u540e\u7684\u90a3\u4e2a q \u7684\u590d\u6742\u5ea6\u3002\n\n\u6211\u4eec\u770b\u5230\u533a\u95f4 l~r \uff0c~~\u603b\u8981\u60f3\u60f3\u5dee\u5206\u7684\u5bf9\u4e0d\u5bf9\uff0c~~\u60f3\u5230\u5dee\u5206\u53ef\u4ee5\u5c06\u8be2\u95ee\u62c6\u5f00\uff0c\u800c\u4e14\u6bcf\u4e2a\u62c6\u5f00\u7684\u533a\u95f4\u4e4b\u95f4\u662f\u6709\u91cd\u53e0\u7684\uff0c\u662f\u53ef\u4ee5\u8f6c\u79fb\u7684\uff0c\u800c\u4e0d\u7528\u6bcf\u6b21\u90fd\u6e05\u7a7a\u3002\n\n**\u800c\u4e14\u5dee\u5206\u540e\u7684\u6570\u7ec4\u53ea\u4e0e\u53f3\u7aef\u70b9\u6709\u5173\uff01**\n\n**\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u5dee\u5206\u540e\u7684\u533a\u95f4\u6309\u7167\u53f3\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff08\u5de6\u7aef\u70b9\u90fd\u662f\u6839\uff09\uff0c\u7136\u540e\u6309\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u6dfb\u52a0\u70b9\uff0c\u6bcf\u9047\u5230\u4e00\u4e2a\u8be2\u95ee\u5c31\u67e5\u8be2\u4e00\u6b21\uff0c\u4ece\u800c\u6392\u9664\u6389\u533a\u95f4\u4e4b\u5916\u7684\u70b9\u7684\u5f71\u54cd\uff0c\u4e5f\u5c31\u4f18\u5316\u6389\u4e00\u4e2a q \u7684\u590d\u6742\u5ea6\u3002**\n\n\u81f3\u6b64\uff0c\u601d\u8def\u5168\u90e8\u7ed3\u675f\u3002\n\n***\n\u7ec6\u8282\uff1a\n\n1.\u6811\u5256+\u7ebf\u6bb5\u6811\u7684\u7ec6\u8282\uff08\u8fd9\u91cc\u4e0d\u505a\u8d58\u8ff0\uff09\u3002\n\n2.\u5dee\u5206\u5f53\u7136\u8981\u6807\u8bb0\u4e00\u4e0b\u8fd9\u4e2a\u533a\u95f4\u662f 1 ~ l-1 \u8fd8\u662f 1~r \u3002\n\n3.\u9898\u76ee\u662f\u4ee50\u4e3a\u6839\uff0c\u4e0d\u4e60\u60ef\u7684\u670b\u53cb\u53ef\u4ee5\u6574\u4f53+1\u3002\u6574\u4f53+1\u4e5f\u8981\u6ce8\u610f\uff0c~~\u6211\u505a\u8fd9\u9898\u65f6\u5c31\u5fd8\u4e86\u8be2\u95ee\u4e5f\u52a0\u4e00\u4e86\uff0c~~\u8fd9\u4e5f\u662f\u4e2a\u7ec6\u8282\u3002\n\n4.\u4f3c\u4e4e\u6ca1\u4ec0\u4e48\u4e86\u3002\u3002\u3002\n\n***\n\nAC\u4ee3\u7801\uff08832ms\uff09\uff1a\n\n\u5173\u952e\u70b9\u7684\u6ce8\u91ca\u5df2\u7ecf\u5199\u5230\u4ee3\u7801\u91cc\u4e86\uff0c\u82e5\u8fd8\u6709\u4e0d\u61c2\u7684\u53ef\u4ee5\u79c1\u804a\u6211\u3002\n\n```cpp\n\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1 \nusing namespace std;\n\nconst int MAXN = 50005;\nconst int MOD = 201314;\n\nstruct Que {\n\tint ans1,ans2; // \u8be2\u95ee\u7684\u533a\u95f4\u7684\u7b54\u6848\u662fans1-ans2\u3002 \n\tQue() {ans1=ans2=0;}\n}que[MAXN];\nstruct Que_part { //\u7528\u6765\u505a\u5dee\u5206\u7684\u8be2\u95ee\u3002 \n\tint num,pos,z; // \u5c5e\u4e8e\u7b2c\u51e0\u4e2a\u8be2\u95ee\uff1b \u8be2\u95ee\u662f1~pos\u8fd9\u4e2a\u533a\u95f4\u7684\u548c\uff1b \u8be2\u95ee\u7684\u70b9\u662fz\u3002 \n\tbool flag; // \u7c7b\u578b\uff1a0\uff1a1~l-1 \uff1b 1\uff1a1~r\u3002\n\tQue_part() {num=pos=z=flag=0;} \n\tQue_part(int a,int b,int c,bool d) {\n\t\tnum=a; pos=b; z=c; flag=d;\n\t}\n\t\n\tinline bool operator < (const Que_part &a) const {\n\t\treturn this->pos<a.pos;\n\t}\n}que_p[MAXN<<1]; \n\ninline bool operator > (const Que_part &a,const Que_part &b) { // \u6211\u53ea\u662f\u60f3\u770b\u770boperator\u5b9a\u4e49\u5230\u5916\u9762\u4f1a\u600e\u4e48\u6837\u3002 \n\treturn a.pos>b.pos;\n}\n\nint n,q; // \u5982\u9898\u3002 \nint nex[MAXN],to[MAXN],en[MAXN]; // next; to; end; \u53d8\u91cf\u540d\u7b80\u964b\uff0c\u52ff\u55b7\u3002 \nint size[MAXN],fa[MAXN],dep[MAXN],son[MAXN]; // size; father; deep; heavy son(\u59d1\u4e14\u8fd9\u4e48\u53eb\u5427);  \nint top[MAXN],seq[MAXN],dfn[MAXN]; // seq\u662f\u70b9\u5230\u5e8f\u5217\u7684\u6620\u5c04\uff0cdfn\u662f\u5e8f\u5217\u5230\u70b9\u7684\u6620\u5c04\u3002 \nint sum[MAXN<<2],col[MAXN<<2],nowl,nowr; // \u7ebf\u6bb5\u6811\uff1bnowl,nowr\u8868\u793a\u5f53\u524d\u67e5\u8be2/\u4fee\u6539\u7684\u533a\u95f4\u7684\u5de6\u53f3\u7aef\u70b9\u3002 \n\n\nvoid update(int rt)\n{\n\tsum[rt]=(sum[rt<<1]+sum[rt<<1|1]) %MOD;\n}\n/*void build(int l,int r,int rt)\n{\n\tif(l==r) {\n\t\tsum[rt]=col[rt]=0;\n\t\treturn ;\n\t}\n\tcol[rt]=0;\n\tint mid=(l+r)>>1;\n\tbuild(lson);\n\tbuild(rson);\n\tupdate(rt);\n}*/\nvoid color(int l,int r,int rt,int co)\n{\n\tsum[rt]=(sum[rt]+(r-l+1)*co) %MOD;\n\tif(l<r) col[rt]=(col[rt]+co) %MOD;\n}\nvoid push_col(int l,int r,int rt)\n{\n\tif(col[rt] && l<r) {\n\t\tint mid=(l+r)>>1;\n\t\tcolor(lson,col[rt]);\n\t\tcolor(rson,col[rt]);\n\t}\n\tcol[rt]=0;\n}\nint query(int l,int r,int rt)\n{\n\tif(nowl<=l && r<=nowr) return sum[rt];\n\tpush_col(l,r,rt);\n\tint mid=(l+r)>>1,ans=0;\n\tif(nowl<=mid) ans+=query(lson);\n\tif(mid<nowr ) ans+=query(rson);\n\treturn ans %MOD;\n}\nvoid modify(int l,int r,int rt)\n{\n\tif(nowl<=l && r<=nowr) {\n\t\tcolor(l,r,rt,1);\n\t\treturn ;\n\t}\n\tpush_col(l,r,rt);\n\tint mid=(l+r)>>1;\n\tif(nowl<=mid) modify(lson);\n\tif(mid<nowr ) modify(rson);\n\tupdate(rt); \n}\n\nvoid dfs1(int x)\n{\n\tsize[x]=1;\n\tfor(int p=en[x];p;p=nex[p]) {\n\t\tif(to[p]!=fa[x]) { //\u5176\u5b9e\u7528\u4e0d\u7740\u5224\u65ad\u7684\uff0c\u4f46\u6211\u5199\u4e60\u60ef\u4e86\u3002 \n\t\t\tdep[to[p]]=dep[x]+1;\n\t\t\tdfs1(to[p]);\n\t\t\tif(size[son[x]]<size[to[p]]) son[x]=to[p];\n\t\t\tsize[x]+=size[to[p]];\n\t\t}\n\t}\n}\nvoid dfs2(int x,int anc)\n{\n\tstatic int t=0;\n\ttop[x]=anc;\n\tseq[x]=++t;\n\tdfn[t]=x;\n\tif(!son[x]) return ;\n\tdfs2(son[x],anc);\n\tfor(int p=en[x];p;p=nex[p]) {\n\t\tif(to[p]!=fa[x] && to[p]!=son[x])\n\t\t\tdfs2(to[p],to[p]);\n\t}\n}\nint query_chain(int x,int y)\n{\n\tint tx=top[x],ty=top[y],ans=0;\n\twhile(tx!=ty) {\n\t\tif(dep[tx]<dep[ty]) {\n\t\t\tx^=y^=x^=y;\n\t\t\ttx^=ty^=tx^=ty;\n\t\t}\n\t\tnowl=seq[tx];nowr=seq[x];\n\t\tans+=query(1,n,1);\n\t\tx=fa[tx];\n\t\ttx=top[x];\n\t}\n\tif(dep[x]>dep[y]) x^=y^=x^=y;\n\tnowl=seq[x];nowr=seq[y];\n\tans+=query(1,n,1);\n\treturn ans %MOD;\n}\nvoid modify_chain(int x,int y)\n{\n\tint tx=top[x],ty=top[y];\n\twhile(tx!=ty) {\n\t\tif(dep[tx]<dep[ty]) {\n\t\t\tx^=y^=x^=y;\n\t\t\ttx^=ty^=tx^=ty; \n\t\t}\n\t\tnowl=seq[tx];nowr=seq[x];\n\t\tmodify(1,n,1);\n\t\tx=fa[tx];\n\t\ttx=top[x];\n\t}\n\tif(dep[x]>dep[y]) x^=y^=x^=y;\n\tnowl=seq[x];nowr=seq[y];\n\tmodify(1,n,1);\n}\n\nint main()\n{\n\tint l,r,z,cnt=0,now=0; \n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i=2;i<=n;++i) { // \u6574\u4f53\u7f16\u53f7\u52a0\u4e00\u3002 \n\t\tscanf(\"%d\",&z);\n\t\tnex[++cnt]=en[fa[i]=++z];to[cnt]=i;en[z]=cnt; // \u52a0\u4e00\u6761 z->i \u7684\u6709\u5411\u8fb9\u3002\n\t}\n\tcnt=0; \n\tfor(int i=1;i<=q;++i) {\n\t\tscanf(\"%d %d %d\",&l,&r,&z);\n\t\t++r;++z; \n\t\tque_p[++cnt]=Que_part(i,l,z,0);\n\t\tque_p[++cnt]=Que_part(i,r,z,1);\n\t}\n\t\n\tdep[1]=1;\n\tdfs1(1);\n\tdfs2(1,1);\n\t//build(1,n,1);// \u6211\u4e3a\u4ec0\u4e48\u8981\u5efa\u6811\u3002\u3002\u3002 \n\t\n\tsort(que_p+1,que_p+cnt+1);\n\t\n\tfor(int i=1;i<=cnt;++i) {\n\t\twhile(now<que_p[i].pos) { // \u4e00\u4e2a\u70b9\u4e00\u4e2a\u70b9\u5f80\u8fd1\u6dfb\u52a0\u3002 now\u4e3a\u5f53\u524d\u6dfb\u52a0\u8fc7\u7684\u70b9\u3002 \n\t\t\tmodify_chain(1,++now);\n\t\t}\n\t\t\n\t\tl=que_p[i].num; // \u53cd\u6b63l\u6ca1\u7528\u4e86\u3002\u5c31\u4ee4l\u4e3a\u5f53\u524d\u5b50\u8be2\u95ee\u5bf9\u5e94\u7684\u6bcd\u8be2\u95ee\u7684\u5e8f\u53f7\u5427\u3002 \n\t\tif(que_p[i].flag) que[l].ans1=query_chain(1,que_p[i].z); // \u4e5f\u8bb8\u4e0d\u5199\u8fd9\u4e2a1\u4f1a\u8ba9\u5e38\u6570\u7a0d\u7a0d\u5c0f\u4e00\u70b9\u3002 \n\t\telse que[l].ans2=query_chain(1,que_p[i].z); \n\t}\n\t\n\tfor(int i=1;i<=q;++i) {\n\t\tprintf(\"%d\\n\",(que[i].ans1-que[i].ans2+MOD) %MOD); // \u8bb0\u5f97\u8981\u5224\u8d1f\u6570\u3002\u3002\u3002 \n\t}\n\treturn 0;\n} \n\n```",
        "postTime": 1519136885,
        "uid": 37839,
        "name": "\u7d2b\u94a6",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "# \u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\r\n\r\n\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u662f\u4e00\u79cd\u53ef\u4ee5\u5904\u7406\u6811\u4e0a\u94fe\u4fee\u6539/\u67e5\u8be2\u7684\u6570\u636e\u7ed3\u6784\uff0c\u53ef\u4ee5\u505a\u5230\uff1a\r\n- $O(\\log n)$ \u4e00\u6761\u94fe\u6574\u4f53\u4fee\u6539\r\n- $O(\\log n)$ \u4e00\u6761\u94fe\u6574\u4f53\u67e5\u8be2\r\n\r\n\u8fd8\u53ef\u4ee5 $O(\\log n)$ \u6c42\u6700\u8fd1\u516c\u5171\u7956\u5148\uff0c\u5b50\u6811\u4fee\u6539\uff0c\u5b50\u6811\u67e5\u8be2\u7b49\uff0c\u8fd9\u4e9b\u590d\u6742\u5ea6\u548c\u91cd\u94fe\u5256\u5206\u662f\u4e00\u6837\u7684\u3002\r\n\r\n\u7531\u4e8e\u6ca1\u6709\u4e13\u95e8\u7ed9\u8fd9\u73a9\u610f\u51c6\u5907\u7684\u6a21\u677f\uff0c\u6211\u5efa\u8bae\u4f7f\u7528 [P4211 [LNOI2014]LCA](https://www.luogu.com.cn/problem/P4211) \u4f5c\u4e3a\u6a21\u677f\u9898\u3002\u8fd9\u9053\u9898\u6d89\u53ca\u5230\u94fe\u52a0\u3001\u94fe\u6c42\u548c\u4e24\u79cd\u4f7f\u7528\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u590d\u6742\u5ea6\u4f18\u4e8e\u6734\u7d20\u91cd\u94fe\u5256\u5206\u7684\u64cd\u4f5c\uff0c\u4e5f\u6ca1\u6709\u5176\u4ed6\u7684\u64cd\u4f5c\uff0c\u9664\u6b64\u4e4b\u5916\u7684\u8f6c\u5316\u4e5f\u5f88\u7b80\u5355\u3002\r\n\r\n\u5176\u5b9e\u76f4\u63a5\u7528 [P3384 \u3010\u6a21\u677f\u3011\u8f7b\u91cd\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384) \u5f53\u6a21\u677f\u4e5f\u662f\u53ef\u4ee5\u7684\uff0c\u4e5f\u53ef\u4ee5\u505a\u5230\u5355\u6b21\u64cd\u4f5c $O(\\log n)$\uff0c\u4f46\u662f\u6d89\u53ca\u5230\u5b50\u6811\u4fee\u6539\u67e5\u8be2\uff0c\u6bd4\u8f83\u96be\u7801\uff08\r\n\r\n\u4e0b\u9762\u6211\u4eec\u7528P4211\u5f53\u4f8b\u9898\u8bb2\u89e3\u3002\u9996\u5148\u8fd9\u4e2a\u9898\u533a\u95f4 lca \u6df1\u5ea6\u548c\u53ef\u4ee5\u8f6c\u5316\u6210\u7ed9 $[l,r]$ \u5185\u7684\u6bcf\u4e2a\u70b9\u5230\u6839\u7684\u94fe\u6743\u503c\u6574\u4f53 $+1$\uff0c\u7136\u540e\u67e5\u8be2 $z$ \u70b9\u5230\u6839\u7684\u94fe\u7684\u6743\u503c\u548c\u3002\u7528\u5dee\u5206\u5c31\u53ef\u4ee5\u8f6c\u5316\u6210 $n$ \u6b21\u4fee\u6539 $2m$ \u6b21\u67e5\u8be2\u3002\u5176\u4ed6\u9898\u89e3\u4e5f\u8bb2\u7684\u5f88\u6e05\u695a\uff0c\u8fd9\u4e0d\u662f\u672c\u7bc7\u9898\u89e3\u91cd\u70b9\u3002\r\n\r\n\u4ee5\u4e0b\u6b63\u6587\u5f00\u59cb\r\n\r\n------\r\n\r\n\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u7684\u4e3b\u8981\u6027\u8d28\u5982\u4e0b\uff1a\r\n\r\n1.  \u5b83\u7531\u5f88\u591a\u68f5\u4e8c\u53c9\u6811\u901a\u8fc7\u8f7b\u8fb9\u8fde\u8d77\u6765\u7ec4\u6210\uff0c\u6bcf\u4e00\u68f5\u4e8c\u53c9\u6811\u7ef4\u62a4\u4e86\u539f\u6811\u7684\u4e00\u6761\u91cd\u94fe\uff0c\u5176\u4e2d\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u5c31\u662f\u8fd9\u6761\u91cd\u94fe\u6df1\u5ea6\u5355\u8c03\u9012\u589e\u7684\u987a\u5e8f\u3002\u6bcf\u4e2a\u8282\u70b9\u90fd\u4ec5\u51fa\u73b0\u5728\u4e00\u68f5\u4e8c\u53c9\u6811\u4e2d\u3002\r\n2. \u8fb9\u5206\u4e3a\u91cd\u8fb9\u548c\u8f7b\u8fb9\uff0c\u91cd\u8fb9\u662f\u5305\u542b\u5728\u4e8c\u53c9\u6811\u4e2d\u7684\u8fb9\uff0c\u7ef4\u62a4\u7684\u65f6\u5019\u5c31\u50cf\u6b63\u5e38\u7ef4\u62a4\u4e8c\u53c9\u6811\u4e00\u6837\uff0c\u8bb0\u5f55\u5de6\u53f3\u513f\u5b50\u548c\u7236\u8282\u70b9\u3002\u8f7b\u8fb9\u4ece\u4e00\u9897\u4e8c\u53c9\u6811\u7684\u6839\u8282\u70b9\u6307\u5411\u5b83\u6240\u5bf9\u5e94\u7684\u91cd\u94fe\u9876\u7aef\u8282\u70b9\u7684\u7236\u8282\u70b9\u3002\u8f7b\u8fb9\u7ef4\u62a4\u7684\u65f6\u5019\u201c\u8ba4\u7236\u4e0d\u8ba4\u5b50\u201d\uff0c\u5373\u53ea\u80fd\u4ece\u5b50\u8282\u70b9\u8bbf\u95ee\u5230\u7236\u8282\u70b9\uff0c\u4e0d\u80fd\u53cd\u8fc7\u6765\u3002\u6ce8\u610f\uff0c\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u4e2d\u7684\u8fb9\u548c\u539f\u6811\u4e2d\u7684\u8fb9\u6ca1\u6709\u5bf9\u5e94\u5173\u7cfb\u3002\r\n\r\n\u5982\u679c\u4f60\u5b66\u8fc7 LCT \u5c31\u80fd\u53d1\u73b0\u8fd9\u51e0\u6761\u6027\u8d28\u548c LCT \u975e\u5e38\u76f8\u4f3c\uff0c\u533a\u522b\u662f\u7528\u4e8c\u53c9\u6811\u66ff\u4ee3\u4e86 splay\uff0c\u7528\u91cd\u8fb9\u548c\u8f7b\u8fb9\u66ff\u4ee3\u4e86\u5b9e\u8fb9\u548c\u865a\u8fb9\u3002\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u5c31\u662f\u9759\u6001\u5316\u7684 LCT\u3002\r\n\r\n3. \u7b97\u4e0a\u91cd\u8fb9\u548c\u8f7b\u8fb9\uff0c\u8fd9\u68f5\u6811\u7684\u9ad8\u5ea6\u662f $O(\\log n)$ \u7ea7\u522b\u7684\u3002\u8fd9\u6761\u662f\u4fdd\u8bc1\u590d\u6742\u5ea6\u7684\u6027\u8d28\u3002\r\n\r\n\u849f\u84bb\u6df1\u77e5\u6ca1\u56fe\u7684\u75db\u82e6\uff0c\u6240\u4ee5\u753b\u4e86\u4e24\u5f20\u56fe\uff0c\u7b2c\u4e00\u5f20\u56fe\u662f\u539f\u6811\uff0c\u4ee5\u8282\u70b9 $1$ \u4e3a\u6839\u8282\u70b9\u3002\u7b2c\u4e8c\u5f20\u56fe\u662f\u5efa\u51fa\u6765\u7684\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\uff0c\u5176\u4e2d\u865a\u7ebf\u662f\u8f7b\u8fb9\uff0c\u5b9e\u7ebf\u662f\u91cd\u8fb9\uff0c\u4e00\u68f5\u4e8c\u53c9\u6811\u7528\u7ea2\u5708\u8868\u793a\u3002\r\n\r\n![](https://cdn.luogu.com.cn/upload/image_hosting/62uwjc1m.png)\r\n![](https://cdn.luogu.com.cn/upload/image_hosting/p1bdrmg8.png)\r\n\r\n\u5373\u4f7f\u4f60\u4e0d\u4f1a LCT \u4e5f\u6ca1\u5173\u7cfb\uff0c\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u6ca1\u6709\u50cf LCT \u90a3\u4e48\u591a\u64cd\u4f5c\uff08\u6bd5\u7adf\u90fd\u662f\u9759\u6001\u7684\uff0c\u53c8\u6ca1\u6cd5 splay \u548c access\uff09\u3002\u90a3\u4e48\u6211\u4eec\u600e\u4e48\u5efa\u6811\u5462\uff0c\u5176\u5b9e\u53ea\u8981\u5bf9\u7740\u6027\u8d28\u91cc\u6240\u8bf4\u7684\u6765\u5c31\u53ef\u4ee5\u4e86\u3002\u9996\u5148\u662f\u50cf\u666e\u901a\u91cd\u94fe\u5256\u5206\u4e00\u6837\uff0c\u4e00\u6b21 dfs \u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u91cd\u513f\u5b50\u3002\u7136\u540e\u4ece\u6839\u5f00\u59cb\uff0c\u627e\u5230\u6839\u8282\u70b9\u6240\u5728\u7684\u91cd\u94fe\uff0c\u5bf9\u4e8e\u8fd9\u4e9b\u70b9\u7684\u8f7b\u513f\u5b50\u9012\u5f52\u5efa\u6811\uff0c\u5e76\u8fde\u4e0a\u8f7b\u8fb9\u3002\u7136\u540e\u6211\u4eec\u9700\u8981\u7ed9\u91cd\u94fe\u4e0a\u7684\u70b9\u5efa\u4e00\u68f5\u4e8c\u53c9\u6811\u3002\u6211\u4eec\u5148\u628a\u91cd\u94fe\u4e0a\u7684\u70b9\u5b58\u5230\u6570\u7ec4\u91cc\uff0c\u6c42\u51fa\u6bcf\u4e2a\u70b9\u8f7b\u513f\u5b50\u7684 size \u548c $+1$\u3002\u7136\u540e\u6211\u4eec\u6309\u7167\u8fd9\u4e2a\u6c42\u51fa\u8fd9\u6761\u91cd\u94fe\u7684\u52a0\u6743\u4e2d\u70b9\uff0c\u628a\u5b83\u4f5c\u4e3a\u4e8c\u53c9\u6811\u7684\u6839\uff0c\u4e24\u8fb9\u9012\u5f52\u5efa\u6811\uff0c\u5e76\u8fde\u4e0a\u91cd\u8fb9\u3002\r\n\r\n\u53ef\u80fd\u4e0d\u662f\u5f88\u597d\u7406\u89e3\uff0c\u4ee3\u7801\u5982\u4e0b\uff1a\r\n\r\n```cpp\r\nstd::vector<int> G[N];\r\nint n, fa[N], son[N], sz[N];\r\nvoid dfsS(int u) {\r\n\tsz[u] = 1;\r\n\tfor (int v : G[u]) {\r\n\t\tdfsS(v);\r\n\t\tsz[u] += sz[v];\r\n\t\tif (sz[v] > sz[son[u]]) son[u] = v;\r\n\t}\r\n}\r\nint b[N], bs[N], l[N], r[N], f[N], ss[N];\r\n// \u7ed9b\u4e2d[bl,br)\u5185\u7684\u70b9\u5efa\u4e8c\u53c9\u6811\uff0c\u8fd4\u56de\u4e8c\u53c9\u6811\u7684\u6839\r\nint cbuild(int bl, int br) {\r\n\tint x = bl, y = br;\r\n\twhile (y-x > 1) {\r\n\t\tint mid = (x+y) >> 1;\r\n\t\tif (2*(bs[mid]-bs[bl]) <= bs[br]-bs[bl]) x = mid;\r\n\t\telse y = mid;\r\n\t}\r\n\t// \u4e8c\u5206\u6c42\u51fa\u6309bs\u52a0\u6743\u7684\u4e2d\u70b9\u3002\u4e0d\u4f7f\u7528\u4e8c\u5206\u800c\u662f\u76f4\u63a5\u626b\u4e00\u904d\u590d\u6742\u5ea6\u4e5f\u5bf9\r\n\ty = b[x];\r\n\tss[y] = br-bl; // ss\uff1a\u4e8c\u53c9\u6811\u4e2d\u91cd\u5b50\u6811\u7684\u5927\u5c0f\r\n\tif (bl < x) {l[y] = cbuild(bl, x); f[l[y]] = y; }\r\n\tif (x+1 < br) {r[y] = cbuild(x+1, br); f[r[y]] = y; }\r\n\treturn y;\r\n}\r\nint build(int x) {\r\n\tint y = x;\r\n\tdo for (int v : G[y])\r\n\t\tif (v != son[y])\r\n\t\t\tf[build(v)] = y; // \u9012\u5f52\u5efa\u6811\u5e76\u8fde\u8f7b\u8fb9\uff0c\u6ce8\u610f\u8981\u4ece\u4e8c\u53c9\u6811\u7684\u6839\u8fde\u8fb9\uff0c\u4e0d\u662f\u4ece\u513f\u5b50\u8fde\u8fb9\r\n\twhile (y = son[y]);\r\n\ty = 0;\r\n\tdo {\r\n\t\tb[y++] = x; // \u5b58\u653e\u91cd\u94fe\u4e2d\u7684\u70b9\r\n\t\tbs[y] = bs[y-1] + sz[x] - sz[son[x]]; // bs\uff1a\u8f7b\u513f\u5b50size\u548c+1\uff0c\u6c42\u524d\u7f00\u548c\r\n\t} while (x = son[x]);\r\n\treturn cbuild(0, y);\r\n}\r\n```\r\n\r\n\u7531\u4ee3\u7801\u53ef\u4ee5\u770b\u51fa\u5efa\u6811\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(n\\log n)$\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u53ef\u4ee5\u8bc1\u660e\u6811\u9ad8\u662f $O(\\log n)$ \u7684\uff1a\u8003\u8651\u4ece\u4efb\u610f\u4e00\u4e2a\u70b9\u8df3\u7236\u8282\u70b9\u5230\u6839\u3002\u8df3\u8f7b\u8fb9\u5c31\u76f8\u5f53\u4e8e\u5728\u539f\u6811\u4e2d\u8df3\u5230\u53e6\u4e00\u6761\u91cd\u94fe\uff0c\u7531\u91cd\u94fe\u5256\u5206\u7684\u6027\u8d28\u53ef\u5f97\u8df3\u8f7b\u8fb9\u6700\u591a $O(\\log n)$ \u6761\uff1b\u56e0\u4e3a\u5efa\u4e8c\u53c9\u6811\u7684\u65f6\u5019\u6839\u8282\u70b9\u627e\u7684\u662f\u7b97\u8f7b\u513f\u5b50\u7684\u52a0\u6743\u4e2d\u70b9\uff0c\u90a3\u4e48\u8df3\u4e00\u6b21\u91cd\u8fb9\u7b97\u4e0a\u8f7b\u513f\u5b50\u7684 size \u81f3\u5c11\u7ffb\u500d\uff0c\u6240\u4ee5\u8df3\u91cd\u8fb9\u6700\u591a\u4e5f\u662f $O(\\log n)$ \u6761\u3002\u6574\u4f53\u6811\u9ad8\u5c31\u662f $O(\\log n)$ \u7684\u3002\r\n\r\n\u5b9e\u9645\u4e0a\u5173\u4e8e\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u7684\u90e8\u5206\u5c31\u5df2\u7ecf\u8bb2\u5b8c\u4e86\uff0c\u5269\u4e0b\u7684\u94fe\u4fee\u6539\u3001\u94fe\u67e5\u8be2\u53ea\u9700\u8981\u4ece\u8981\u64cd\u4f5c\u7684\u70b9\u5f80\u6839\u8df3\uff0c\u8981\u64cd\u4f5c\u67d0\u4e2a\u70b9\u91cd\u94fe\u4e0a\u6bd4\u5b83\u6df1\u5ea6\u5c0f\u7684\u6240\u6709\u70b9\uff0c\u5c31\u76f8\u5f53\u4e8e\u5728\u8fd9\u6761\u91cd\u94fe\u7684\u4e8c\u53c9\u6811\u91cc\u64cd\u4f5c\u8fd9\u4e2a\u70b9\u5de6\u4fa7\u7684\u6240\u6709\u70b9\uff0c\u53ef\u4ee5\u62c6\u6210\u4e00\u7cfb\u5217\u5b50\u6811\u64cd\u4f5c\uff0c\u50cf\u7ef4\u62a4\u666e\u901a\u4e8c\u53c9\u6811\u4e00\u6837\u7ef4\u62a4\u5b50\u6811\u548c\uff0c\u6253\u5b50\u6811\u52a0\u6807\u8bb0\u5c31\u884c\u3002\u6211\u4f7f\u7528\u7684\u662f\u6807\u8bb0\u6c38\u4e45\u5316\uff0c\u5176\u5b9e\u4e5f\u662f\u53ef\u4ee5\u6807\u8bb0\u7528 pushdown\uff0c\u5b50\u6811\u548c\u7528 pushup \u7684\uff0c\u4e0d\u8fc7\u53ef\u80fd\u4e0d\u592a\u597d\u5199\uff08\u56e0\u4e3a\u5e73\u65f6\u5904\u7406\u4e8c\u53c9\u6811\u90fd\u662f\u81ea\u4e0a\u800c\u4e0b\uff0c\u8fd9\u91cc\u662f\u81ea\u4e0b\u800c\u4e0a\uff0c\u53ef\u80fd\u9700\u8981\u5148\u5904\u7406\u51fa\u8df3\u7684\u8def\u5f84\u7136\u540e\u4ece\u4e0a\u5f80\u4e0b pushdown \u4e00\u904d\uff0c\u5e38\u6570\u5927\u5927\u5927\uff09\u3002\u53cd\u6b63\u600e\u4e48\u5199\u7740\u987a\u624b\u600e\u4e48\u6765\uff0c\u4ee3\u7801\u5982\u4e0b\r\n\r\n```cpp\r\n// a\uff1a\u5b50\u6811\u52a0\u6807\u8bb0\r\n// s\uff1a\u5b50\u6811\u548c\uff08\u4e0d\u7b97\u52a0\u6807\u8bb0\u7684\uff09\r\nint a[N], s[N];\r\nvoid add(int x) {\r\n\tbool t = true; int z = 0;\r\n\twhile (x) {\r\n\t\ts[x] += z;\r\n\t\tif (t) {\r\n\t\t\ta[x]++; if (r[x]) a[r[x]]--;\r\n\t\t\tz += 1 + ss[l[x]];\r\n\t\t\ts[x] -= ss[r[x]];\r\n\t\t}\r\n\t\tt = (x != l[f[x]]);\r\n\t\tif (t && x != r[f[x]]) z = 0; // \u8df3\u8fc7\u8f7b\u8fb9\u8981\u6e05\u7a7a\r\n\t\tx = f[x];\r\n\t}\r\n}\r\nint query(int x) {\r\n\tint ret = 0;\r\n\tbool t = true; int z = 0;\r\n\twhile (x) {\r\n\t\tif (t) {\r\n\t\t\tret += s[x] - s[r[x]];\r\n\t\t\tret -= 1ll * ss[r[x]] * a[r[x]];\r\n\t\t\tz += 1 + ss[l[x]];\r\n\t\t}\r\n\t\tret += 1ll * z * a[x];\r\n\t\tt = (x != l[f[x]]);\r\n\t\tif (t && x != r[f[x]]) z = 0; // \u8df3\u8fc7\u8f7b\u8fb9\u8981\u6e05\u7a7a\r\n\t\tx = f[x];\r\n\t}\r\n\treturn ret;\r\n}\r\n```\r\n\r\n\u987a\u4fbf\u8bf4\u4e00\u53e5\uff0c\u5bf9\u4e8e\u5b50\u6811\u64cd\u4f5c\uff0c\u5c31\u662f\u8981\u8003\u8651\u8f7b\u513f\u5b50\u7684\uff0c\u9700\u8981\u518d\u7ef4\u62a4\u4e00\u4e2a\u5305\u62ec\u8f7b\u513f\u5b50\u7684\u5b50\u6811\u548c\u3001\u5b50\u6811\u6807\u8bb0\uff0c\u6709\u9700\u8981\u53ef\u4ee5\u53bb\u505a [P3384 \u3010\u6a21\u677f\u3011\u8f7b\u91cd\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384) \r\n\r\n[\u672c\u9898\u7684\u5b8c\u6574\u4ee3\u7801\u3002](https://www.luogu.com.cn/paste/3fbg3m9k) \u7531\u4e8e\u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811\u8fd9\u79cd\u79d1\u6280\u8fd8\u4e0d\u662f\u5f88\u666e\u53ca\uff0c\u4f1a\u7684\u4eba\u4e5f\u4e0d\u591a\uff0c\u8fd9\u9053\u9898\u7684\u9898\u89e3\u533a\u91cc\u5168\u662f~~\u88ab\u540a\u6253\u7684~~\u6811\u5256 $O(n\\log^2 n)$ \u505a\u6cd5\uff0c\u5199\u4e86\u4e00\u53d1 $O(n\\log n)$ \u6ca1\u7279\u610f\u5361\u5e38\u8f7b\u677e\u62ff\u5230 132ms rk1\uff08\u622a\u81f3\u5199\u8fd9\u7bc7\u9898\u89e3\u7684\u65f6\u5019\uff09\u3002\u5e76\u4e14\u4ee3\u7801\u6bd4\u5927\u90e8\u5206\u7684\u6811\u5256\u7ebf\u6bb5\u6811\u505a\u6cd5\u8fd8\u77ed\u3002",
        "postTime": 1601823529,
        "uid": 90893,
        "name": "\u93e1\u97f3\u30ea\u30f3",
        "ccfLevel": 10,
        "title": "P4211 [LNOI2014]LCA | \u5168\u5c40\u5e73\u8861\u4e8c\u53c9\u6811"
    },
    {
        "content": "\u5927\u5bb6\u90fd\u662f\u6811\u5256O($n*log^2_2n$)\u7684\u505a\u6cd5\uff0c\u90a3\u849f\u84bb\u6211\u5c31\u6765\u4e00\u4e2aO($n^{\\frac{3}{2}}$)\u7684\u505a\u6cd5.\n\n\u9996\u5148,\u4e00\u4e2a\u663e\u7136\u7684\u60f3\u6cd5:\u60f3\u8981\u67e5\u8be2\u4e00\u4e2a\u70b9\u548c\u67d0\u4e9b\u5176\u4ed6\u70b9\u7684LCA\u6df1\u5ea6\u548c\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u8be5\u8282\u70b9\u7684\u6bcf\u4e2a\u7956\u5148\u4e2d\u7684\u9700\u8981\u67e5\u8be2\u7684\u8282\u70b9\u4e2a\u6570\u3002\u4f46\u662f\u4f1a\u6709\u91cd\u590d\u7edf\u8ba1\uff0c\u6211\u4eec\u53d1\u73b0\u91cd\u590d\u7edf\u8ba1\u7684\u6b21\u6570\u5373\u4e3aLCA\u6df1\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u663e\u7136\u5730\u628a\u95ee\u9898\u8f6c\u5316\u6210\u628a\u6240\u6709\u8981\u67e5\u8be2\u7684\u8282\u70b9\u5230\u6839\u7684\u8def\u5f84\u8282\u70b9\u6743\u503c\u52a01\uff0c\u67e5\u8be2\u67d0\u4e2a\u8282\u70b9\u7684\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u6743\u503c\u548c.\n\n\u7136\u540e\u4e00\u4e2aO($n^{\\frac{3}{2}}*log^2_2n$)\u7684\u505a\u6cd5\u5c31\u51fa\u6765\u4e86\uff0c\u7528\u83ab\u961f\u7ef4\u62a4\u533a\u95f4\uff0c\u7528\u6811\u5256\u7ef4\u62a4\u6811\u4e0a\u6743\u503c\uff0c\u671f\u671b\u7684\u520620.\n\n\u8003\u8651\u4f18\u5316\uff0c\u7531\u4e8e\u83ab\u961f\u6bcf\u6b21\u66f4\u65b0\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3aO($log^2_2n$)\uff0c\u4f46\u6700\u591a\u53ea\u6709q\u6b21\u67e5\u8be2\uff0c\u53ef\u4ee5\u8003\u8651\u4f18\u5316\u6811\u5256\u7684\u4fee\u6539\u64cd\u4f5c\u53bb\u6389\u4e00\u4e2alog.\u4f46\u662f\u8fd9\u6837\u8fd8\u662f\u8fc7\u4e0d\u4e86.\n\n\u4ee5\u4e0a\u505a\u6cd5\u5c31\u8fbe\u5230\u83ab\u961f\u7684\u6781\u9650\u4e86(\u5927\u6982).\u56e0\u4e3a\u8f6c\u79fb\u65e0\u6cd5\u518d\u4f18\u5316\u4e86.\u7136\u540e\u6211\u4eec\u53d1\u73b0\u67d0\u4e2a\u9759\u6001\u7684\u533a\u95f4\u8d21\u732e\u7684\u5bf9\u4e8e2\u67d0\u4e2a\u67e5\u8be2\u8d21\u732e\u7684\u7b54\u6848\u662f\u4e00\u5b9a\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5206\u5757.\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u5757\u5dee\u5206\u4e00\u4e0b\u66b4\u529bdfs\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684\u7b54\u6848.\u7136\u540e\u8fb9\u89d2\u76f4\u63a5\u6c42LCA\u6df1\u5ea6\n\n\u7136\u540eLCA\u6df1\u5ea6\u7528\u500d\u589eRMQ\u9884\u5904\u7406\u5373\u53ef\u505a\u5230O(1)\u67e5\u8be2\n\n\u7136\u540e\u5c31\u505a\u5230\u6574\u4f53O($n^{\\frac{3}{2}}$)\u4e86.\n\n\u4ee3\u7801\u5982\u4e0b(\u5e38\u6570\u5de8\u5927):\n\n```\n#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 201314;\n\nint n,m;\nvector<int>to[50005];\nint deep  [50005];\n\nconst int size = 500;\nint belong[50005];\nint query [105][50005];\nint block [105];\n\nint first[100005];\nint st   [200005][18];\nint lg2  [100005];\nint cnt = 0;\n\nvoid dfs_init(int now){\n    st[ ++ cnt ][0] = deep[now];\n    first[now] = cnt;\n    for( auto next : to[now] ){\n        deep[next] = deep[now] + 1;\n        dfs_init( next );\n        st[ ++ cnt ][0] = deep[now];\n    }\n}\n\nint bin[50005];\nvoid dfs1(int now){ for( auto next : to[now] )dfs1( next ),bin[now] += bin[next]; }\nvoid dfs2(int now,int dist){ for( auto next : to[now] )dfs2( next,dist + bin[now] );bin[now] += dist; }\n\nvoid init(){\n    dfs_init(1);\n    for(int i = 1;i <= n;i ++){\n        belong[i] = i / size + 1;\n        if( belong[i] - belong[i - 1] )block[ belong[i] ] = i;\n    }\n    for(int i = 2;i <= (n << 1);i ++)lg2[i] = lg2[i >> 1] + 1;\n    for(int t = 1;t <= 17;t ++)for(int i = 1;i <= (n << 1) - (1 << t);i ++)\n        st[i][t] = min( st[i][t - 1],st[i + (1 << (t - 1))][t - 1] );\n}\n\nint LCA(int A,int B){\n    A = first[A];B = first[B];\n    if( A > B )swap( A,B );\n    int ln = lg2[ B - A + 1 ]; \n    return min( st[A][ln],st[B - (1 << ln) + 1][ln] );\n}\n\nint main(){\n    cin >> n >> m;deep[1] = 1;\n    for(int i = 2;i <= n;i ++){\n        int v;cin >> v;v ++;\n        to[v].push_back(i);\n    }\n    init();\n    belong[0] = 0;belong[n + 1] = belong[n] + 1;\n    block[0] = 0;block[ belong[n + 1] ] = n + 1;\n    for(int i = 1;i <= belong[n];i ++){\n        memset( bin,0,sizeof(bin) );\n        for( int j = block[i];belong[j] == i;j ++ )bin[j] ++;\n        dfs1(1);dfs2(1,0);\n        for( int j = 1;j <= n;j ++ )query[i][j] = bin[j];\n    }\n    while( m -- ){\n        int l,r,x;cin >> l >> r >> x;\n        l ++;r ++;x ++;\n        int bl = belong[l - 1] + 1;\n        int br = belong[r + 1] - 1;\n        long long ans = 0;\n        for( ;belong[l] != bl and l <= r ;l ++ )ans += LCA( l,x );\n        for( ;belong[r] != br and r >= l ;r -- )ans += LCA( r,x );\n        for( int i = bl;i <= br;i ++ )ans += query[i][x];\n        cout << ans % mod << \"\\n\";\n    }\n    return 0;\n}\n\n```",
        "postTime": 1540265802,
        "uid": 47240,
        "name": "bzy369258147",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u611f\u8c22hzwer\u5927\u4f6c\u7684\u535a\u5ba2\u6307\u793a......\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u95ee\u9898\u80fd\u591f\u8f6c\u5316\u4e3a\u4ece\u8be2\u95ee\u70b9\u5230\u6839\u90fd\u52a01\uff0c\u7136\u540e\u8be2\u95eel\u5230r\u7684\u70b9\u5230\u6839\u7684\u8def\u5f84\u4e0a\u6743\u503c\u4e4b\u548c\u3002\u7136\u540e\u8fd9\u4e2a\u95ee\u9898\u53c8\u548c\u201cl\u5230r\u7684\u70b9\u5230\u6839\u8def\u5f84\u4e0a\u6240\u6709\u70b9\u6743\u503c\u5206\u522b+1\uff0c\u6c42\u8be2\u95ee\u70b9\u5230\u6839\u8def\u5f84\u4e0a\u7684\u6743\u503c\u4e4b\u548c\u201d\u7b49\u4ef7\u3002\n\n\u7136\u540e\u5c31\u53ef\u505a\u4e86\u3002\u5c06\u8be2\u95ee\u5dee\u5206\u4e00\u4e0b\uff0c\u53d8\u6210\u67e5\u8be2$[1,r]-[1,l-1]$\u3002\u8fd9\u65f6\u5019\u53ea\u9700\u8981\u79bb\u7ebf\u8be2\u95ee\uff0c\u5728l-1\u548cr\u5904\u5206\u522b\u6253\u6807\u8bb0\uff0c\u5728\u4ece1~n\u4f9d\u6b21\u904d\u5386\uff0c\u626b\u5230\u6807\u8bb0\u5c31\u67e5\u8be2\uff0c\u7528\u6811\u94fe\u5256\u5206\u5957\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\u6700\u540e\u5c06\u7b54\u6848\u5168\u90e8\u8f93\u51fa\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6$O(n\\log_2^2n)$\u3002\n\n\u4ee3\u7801\uff1a(\u7b14\u8bb0\u672c\u6253\u7684\uff0c\u7f29\u8fdb\u6709\u70b9\u4e11)\n\n```cpp\n#include<bits/stdc++.h>\n#define For(i,a,b) for(i=(a);i<=(b);++i)\n#define Forward(i,a,b) for(i=(a);i>=(b);--i)\n#define Rep(i,a,b) for(register int i=(a),i##end=(b);i<=i##end;++i)\n#define Repe(i,a,b) for(register int i=(a),i##end=(b);i>=i##end;--i)\nusing namespace std;\ntemplate<typename T>inline void read(T &x)\n{\n\tT s=0,f=1;char k=getchar();\n\twhile(!isdigit(k)&&(k^'-'))k=getchar();\n\tif(!isdigit(k)){f=-1;k=getchar();}\n\twhile(isdigit(k)){s=s*10+(k^48);k=getchar();}\n\tx=s*f;\n}\nvoid file()\n{\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"test.in\",\"r\",stdin);\n\t\tfreopen(\"test.out\",\"w\",stdout);\n\t#endif\n}\n#define Chkmax(a,b) a=a>(b)?a:(b)\n#define Chkmin(a,b) a=a<(b)?a:(b)\nconst int MAXN=5e4+7;\nstatic struct edge\n{\n\tint v,nxt;\n}p[MAXN];\nstatic int n,m,e,head[MAXN],dep[MAXN];\nstatic int fa[MAXN],sz[MAXN],son[MAXN];\ninline void add(int u,int v)\n{p[++e].v=v;p[e].nxt=head[u];head[u]=e;}\nvoid dfs(int u)\n{\n\tsz[u]=1;dep[u]=dep[fa[u]]+1;\n\tfor(register int v=head[u];v;v=p[v].nxt)\n\t{\n\t\tdfs(p[v].v);sz[u]+=sz[p[v].v];\n\t\tif(!son[u]||sz[p[v].v]>sz[son[u]])\n\t\t\tson[u]=p[v].v;\n\t}\n}\nstatic int top[MAXN],dfn[MAXN],ri[MAXN];\nvoid dfs(int u,int tp)\n{\n\tri[dfn[u]=++e]=u;top[u]=tp;\n\tif(son[u])dfs(son[u],tp);\n\telse return;\n\tfor(register int v=head[u];v;v=p[v].nxt)\n\t\tif(p[v].v^son[u])dfs(p[v].v,p[v].v);\n}\nconst int mod=201314;\nstatic vector<int>pl[MAXN],mi[MAXN];\nstatic int ask[MAXN];\ninline void init()\n{\n\tread(n);read(m);\n\tRep(i,2,n)read(fa[i]),add(++fa[i],i);\n\tdfs(1);e=0;dfs(1,1);\n\tstatic int l,r;\n\tRep(i,1,m)read(l),read(r),read(ask[i])\n\t\t,mi[l].push_back(i),pl[r+1].push_back(i)\n\t\t,++ask[i];\n}\nstatic int sum[MAXN<<2],laz[MAXN<<2];\nstatic int ans[MAXN];\ninline void pushdown(int h,int l,int r)\n{\n\tif(laz[h])\n\t{\n\t\tstatic int mid;mid=(l+r)>>1;\n\t\tsum[h<<1]=(sum[h<<1]\n\t\t\t+1ll*laz[h]*(mid-l+1)%mod)%mod;\n\t\tsum[h<<1|1]=(sum[h<<1|1]\n\t\t\t+1ll*laz[h]*(r-mid)%mod)%mod;\n\t\tlaz[h<<1]+=laz[h];laz[h<<1|1]+=laz[h];\n\t\tlaz[h]=0;\n\t}\n}\nvoid modify(int h,int l,int r,int x,int y)\n{\n\tif(l>=x&&r<=y)\n\t{\n\t\tsum[h]=(sum[h]+r-l+1)%mod;\n\t\t++laz[h];return;\n\t}\n\tpushdown(h,l,r);\n\tint mid=(l+r)>>1;\n\tif(x<=mid)modify(h<<1,l,mid,x,y);\n\tif(y>mid)modify(h<<1|1,mid+1,r,x,y);\n\tsum[h]=(sum[h<<1]+sum[h<<1|1])%mod;\n}\ninline void modi(int x)\n{\n\twhile(x)\n\t{\n\t\tmodify(1,1,n,dfn[top[x]],dfn[x])\n\t\t,x=fa[top[x]];}\n}\nstatic vector<int>::iterator it;\ninline int query(int h,int l,int r,int x,int y)\n{\n\tif(l>=x&&r<=y)return sum[h];\n\tpushdown(h,l,r);\n\tint mid=(l+r)>>1,ans=0;\n\tif(x<=mid)ans=query(h<<1,l,mid,x,y);\n\tif(y>mid)ans=(ans+query(h<<1|1,mid+1,r,x,y))%mod;\n\treturn ans;\n}\ninline int qu(int x)\n{\n\tstatic int ans;ans=0;\n\twhile(x)\n\t{\n\t\tans=(ans+query(1,1,n,dfn[top[x]],dfn[x]));\n\t\tx=fa[top[x]];\n\t}\n\treturn ans;\n}\ninline void solve()\n{\n\tRep(i,1,n)\n\t{\n\t\tmodi(i);\n\t\tfor(it=pl[i].begin();it!=pl[i].end();++it)\n\t\t\tans[*it]+=qu(ask[*it]);\n\t\tfor(it=mi[i].begin();it!=mi[i].end();++it)\n\t\t\tans[*it]-=qu(ask[*it]);\n\t}\n\tRep(i,1,m)printf(\"%d\\n\",(ans[i]%mod+mod)%mod);\n}\nint main()\n{\n\tfile();\n\tinit();\n\tsolve();\n\treturn 0;\n}\n\n```\n\n~~\u5176\u5b9e\u8fd8\u80fd\u7528LCT\u4f18\u5316\u5230$O(n\\log_2n)$\uff0c\u4f46\u662f\u592a\u9ebb\u70e6\u4e86......$~~",
        "postTime": 1517906010,
        "uid": 7035,
        "name": "Great_Influence",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "[$$\\color{green}\\Large\\texttt{\u300e\u83dc\u9e21\u7684blog\u300f}$$](https://www.luogu.org/blog/zyxxs/)\n\n\u663e\u7136\u5730\uff0c\u4e24\u4e2a\u70b9$(u,v)$\u7684LCA\u7684\u6df1\u5ea6\uff0c\u5c31\u662f\u4ece\u6839\u5230$u,v$\u7684\u4e24\u6761\u8def\u5f84\u7684\u516c\u5171\u957f\u5ea6\uff08\u66f4\u51c6\u786e\u5730\u8bf4\uff0c\u662f\u516c\u5171\u70b9\u6570\uff09\u3002\n\n\u6240\u4ee5\u4f60\u53ef\u4ee5\u60f3\u8c61\uff0c\u628a$u$\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u5168\u90e8+1\uff0c\u6c42$v$\u5230\u6839\u7684\u8def\u5f84\u7684\u6743\u503c\u548c\uff08\u8fd9\u53ef\u4ee5\u4f7f\u7528\u6811\u5256\u5b9e\u73b0\uff09\uff0c\u5c31\u662f$(u,v)$\u7684LCA\u7684\u6df1\u5ea6\uff0c\u4e0b\u9762\u79f0\u4f5c$u$\u5bf9$v$\u7684\u8d21\u732e\u3002\n\n\u90a3\u4e48\u56de\u5230\u672c\u9898\u3002\u672c\u9898\u7684\u8be2\u95ee\u663e\u7136\u53ef\u4ee5\u62c6\u6210\u201c$[1,r]$\u5bf9$z$\u7684\u8d21\u732e\u201d\u51cf\u201c$[1,l-1]$\u5bf9$z$\u7684\u8d21\u732e\u201d\uff08\u4e0b\u9762\u5206\u522b\u8bb0\u4f5c$(r,z)$\u548c$(l-1,z)$\uff09\u3002\n\n\u90a3\u4e48\u73b0\u5728\u7684\u95ee\u9898\u5c31\u662f\uff1a\u5982\u4f55\u591a\u6b21\u6c42$[1,u]$\u5230$v$\u7684\u8d21\u732e\uff1f\n\n\u5f88sb\u7684\u60f3\u6cd5\u662f\u628a$1$\u5230$u$\u7684\u6240\u6709\u70b9\u90fd\u628a\u5b83\u5230\u6839\u8def\u5f84\u4e0a\u7684\u70b9+1\uff0c\u7136\u540e$v$\u76f4\u63a5\u4e00\u8d77\u67e5\u8be2\u3002\u8fd9\u662f\u4e00\u4e2a$O(N^2\\log^2N)$\u7684\u505a\u6cd5\uff0c\u975e\u5e38sb\u3002\n\n\u7136\u540e\u6211\u4eec\u6ce8\u610f\u5230$[1,u]$\u548c$[1,u+1]$\u662f\u6709\u5f88\u591a\u516c\u5171\u90e8\u5206\u7684\uff0c\u5982\u679c\u6211\u4eec\u67e5\u8be2\u5b8c\u4e86$(u,v_1)$\uff0c\u4e0d\u5fc5\u628a\u6807\u8bb0\u6e05\u7a7a\uff0c\u800c\u662f\u53ef\u4ee5\u76f4\u63a5\u5f80\u4e0a\u6253\u4e00\u4e2a$u+1$\u7684\u4fee\u6539\u7136\u540e\u76f4\u63a5\u67e5\u8be2$(u+1,v_2)$\u3002\n\n\u6240\u4ee5\u5f97\u5230\u4e0b\u9762\u7684\u6d41\u7a0b\uff1a\n\n- \u628a\u8be2\u95ee$(u,v)$\u79bb\u7ebf\u5e76\u6309$u$\u6392\u4e2a\u5e8f\n\n- \u5904\u7406\u5b8c\u6240\u6709\u7684$(u,v_1),(u,v_2),(u,v_3),\\dots$\u4e0d\u628a$u$\u7684\u6807\u8bb0\u64e6\u6389\uff08\u5f53\u7136\u4e5f\u4e0d\u628a\u5176\u4ed6\u7684\u6807\u8bb0\u64e6\u6389\uff09\uff0c\u76f4\u63a5\u5f80\u4e0a\u6253\u4e00\u4e2a$u+1$\u5bf9\u5e94\u7684\u4fee\u6539\uff0c\u7136\u540e\u5904\u7406$(u+1,v)$\n\n\u4e8e\u662f\u5c31\u5f97\u5230\u4e00\u4e2a$O(N\\log^2N)$\u7684\u505a\u6cd5\u4e86\u3002\u5982\u679c\u628a\u6811\u5256\u7684\u7ebf\u6bb5\u6811\u6362\u6210\u4e3b\u5e2d\u6811\u8fd8\u53ef\u4ee5\u5728\u7ebf\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nint lnk[50005];\nint pre[50005],tgt[50005],cnt;\nvoid add_E(int u,int v){\n\tpre[++cnt]=lnk[u],tgt[cnt]=v,lnk[u]=cnt;\n}\n\nint fa[50005],son[50005],s[50005],dep[50005];\nint top[50005],seg[50005],rev[50005],idx;\nvoid dfs1(int x){\n\ts[x]=1;dep[x]=dep[fa[x]]+1;\n\tfor(int e=lnk[x];e;e=pre[e]){\n\t\tdfs1(tgt[e]),s[x]+=s[tgt[e]];\n\t\tif(s[tgt[e]]>s[son[x]]) son[x]=tgt[e];\n\t}\n}\nvoid dfs2(int x){\n\tseg[x]=++idx;rev[idx]=x;\n\tif(son[x]) top[son[x]]=top[x],dfs2(son[x]);\n\tfor(int e=lnk[x];e;e=pre[e])if(tgt[e]!=son[x])\n\t\ttop[tgt[e]]=tgt[e],dfs2(tgt[e]);\n}\n\nint ANS[100005];\nstruct Qs{\n\tint u,v,pos;\n\tbool operator <(const Qs b)const{return u<b.u;}\n}Q[100005];\n\nint Sum[200005],Lzy[200005];\nvoid push_up(int x){Sum[x]=Sum[x<<1]+Sum[x<<1|1];}\nvoid push_down(int x,int l,int r){\n\tint mid=(l+r)>>1;\n\tSum[x<<1]+=1LL*(mid-l+1)*Lzy[x]%201314;\n\tLzy[x<<1]+=Lzy[x];\n\tSum[x<<1|1]+=1LL*(r-mid)*Lzy[x]%201314;\n\tLzy[x<<1|1]+=Lzy[x];\n\tLzy[x]=0;\n}\nvoid Update(int x,int l,int r,int L,int R){\n\tif(L<=l&&r<=R){Sum[x]+=r-l+1;Lzy[x]++;return;}\n\tpush_down(x,l,r);\n\tint mid=(l+r)>>1;\n\tif(L<=mid) Update(x<<1,l,mid,L,R);\n\tif(R>mid) Update(x<<1|1,mid+1,r,L,R);\n\tpush_up(x);\n}\nint Query(int x,int l,int r,int L,int R){\n\tif(L<=l&&r<=R) return Sum[x];\n\tpush_down(x,l,r);\n\tint mid=(l+r)>>1,ans=0;\n\tif(L<=mid) ans+=Query(x<<1,l,mid,L,R);\n\tif(R>mid) ans+=Query(x<<1|1,mid+1,r,L,R);\n\tpush_up(x);\n\treturn ans;\n}\n\nvoid Chain_Update(int x){\n\twhile(x){\n\t\tUpdate(1,1,N,seg[top[x]],seg[x]);\n\t\tx=fa[top[x]];\n\t}\n}\nint Chain_Query(int x){\n\tint ans=0;\n\twhile(x){\n\t\tans+=Query(1,1,N,seg[top[x]],seg[x]);\n\t\tx=fa[top[x]];\n\t}\n\treturn ans;\n}\n\nint now_id=1;\n\nint main(){\n\tscanf(\"%d%d\",&N,&M);\n\tfa[1]=0;\n\tfor(int i=2;i<=N;i++) scanf(\"%d\",&fa[i]),add_E(++fa[i],i);\n\tdfs1(1);top[1]=1;dfs2(1);\n\tfor(int i=1;i<=M;i++){\n\t\tint l,r,z;scanf(\"%d%d%d\",&l,&r,&z);\n\t\tl++;r++;z++;\n\t\tQ[2*i-1].u=r,Q[2*i-1].v=z,Q[2*i-1].pos=2*i-1;\n\t\tQ[2*i].u=l-1,Q[2*i].v=z,Q[2*i].pos=2*i;\n\t}\n\tsort(Q+1,Q+2*M+1);\n\twhile(Q[now_id].u==0&&now_id<=2*M){\n\t\tint tmp=Chain_Query(Q[now_id].v);\n\t\tif(Q[now_id].pos&1) ANS[(Q[now_id].pos+1)>>1]+=tmp;\n\t\telse ANS[(Q[now_id].pos+1)>>1]-=tmp;\n\t\tnow_id++;\n\t}\n\tfor(int i=1;i<=N;i++){\n\t\tChain_Update(i);\n\t\twhile(Q[now_id].u==i&&now_id<=2*M){\n\t\t\tint tmp=Chain_Query(Q[now_id].v);\n\t\t\tif(Q[now_id].pos&1) ANS[(Q[now_id].pos+1)>>1]+=tmp;\n\t\t\telse ANS[(Q[now_id].pos+1)>>1]-=tmp;\n\t\t\tnow_id++;\n\t\t}\n\t}\n\tfor(int i=1;i<=M;i++) printf(\"%d\\n\",(ANS[i]%201314+201314)%201314);\n\t\n\treturn 0;\n}\n\n```\n",
        "postTime": 1568033637,
        "uid": 58567,
        "name": "x\u4e49x",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "## \u9898\u89e3- $P4211\\ \\ [LNOI2014]LCA$\n\n* \u7a9d$tcl$\uff0c\u8c03\u4e86\u4e2a\u4e0a\u5348\u53d1\u73b0\u88ab\u50bb\u903c\u9519\u8bef\u56f0\u6270\uff0c\u603b\u7b97\u8c03\u51fa\u6765\u4e86\u3002$qwq$\n\n* **\u9898\u76ee\u610f\u601d**\n\t\n    \u9898\u9762\u5f88\u5c0f\u6e05\u65b0\uff1a\u5c31\u662f\u6c42$\\sum_{i=l}^{r} dep(LCA(i,z))$\n    \n* $sol$\n\n\t**\u524d\u7f6e\u77e5\u8bc6\uff1a\u6811\u94fe\u5256\u5206+\u5dee\u5206**\n    \n    \u8003\u8651\u79bb\u7ebf\u3002\n    \n    \u6211\u4eec\u9996\u5148\u53ef\u4ee5\u628a\u9898\u76ee\u610f\u601d\u8f6c\u6362\u4e3a\uff1a\u6bcf\u6b21\u628a\u8be2\u95ee\u533a\u95f4$[l,r]$\u91cc\u7684\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u503c\uff08\u5305\u62ec\u81ea\u5df1\uff09\u52a0\u4e00\uff0c\u6700\u540e\u8be2\u95ee$z$\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u548c\u3002\u6211\u4eec\u53ef\u4ee5\u753b\u5f20\u56fe\u6765\u7406\u89e3\u8fd9\u4e2a\u8f6c\u6362\u3002\n    \n    ![](https://cdn.luogu.com.cn/upload/image_hosting/pgjhqn4x.png?x-oss-process=image/resize,m_lfit,h_200,w_265)\n    \n    \u8fd9\u6837\u5c31\u548c\u597d\u7406\u89e3\u4e86\u3002\u90a3\u6211\u4eec\u5982\u4f55\u6765\u5904\u7406\u8fd9\u4e2a\u8be2\u95ee\u5462\u3002\u4e8e\u662f\u6211\u4eec\u5f88\u81ea\u7136\u5730\u4f1a\u60f3\u5230\u5dee\u5206\uff0c\u5373\u628a$[l,r]$\u62c6\u6210$[1,r],[1,l)$\u3002\u90a3\u6211\u4eec\u600e\u4e48\u5b9e\u73b0\u8fd9\u4e2a\u5dee\u5206\u5462\uff1f\u6211\u4eec\u53ea\u9700\u8981\u5728$l-1$\u70b9\u4e0a\u6253\u4e0a\u6807\u8bb0\uff08\u5373\u4ee3\u7801\u4e2d\u7684$flg$\uff09\uff0c\u53ea\u8981$[1,r]-[1,l)$\u5373\u53ef\u3002\u533a\u95f4\u52a0\u7b49\u64cd\u4f5c\u6211\u4eec\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206\u5957\u4e2a\u7ebf\u6bb5\u6811\u6765\u6c42\u89e3~~\uff08\u8fd9\u5f88\u5957\u8def\u7684\uff09~~\u3002\n    \n    \u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n \\log^2 n)$\u53ef\u4ee5\u8fc7\u5f97\u3002\n    \n\n* $Code$\n\n```cpp\n\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ninline int read()\n{\n\tint sum=0,ff=1; char ch=getchar();\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-') ff=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t\tsum=sum*10+(ch^48),ch=getchar();\n\treturn sum*ff;\n}\n\nconst int N=2e5+5;\nconst int mod=201314;\n\nint n,m,cnt,head[N],id[N],top[N];\nint son[N],laz[N<<2],tr[N<<2],res[N];\nint ans,tot,f[N],dep[N],siz[N],all;\n\nstruct nood\n{\n\tint nex,to;\n};\nnood e[N<<1];\n\nstruct question\n{\n\tint pos,z,id,flg;\n\tinline bool friend operator < (const question &b,const question &c)\n\t{\n\t\treturn b.pos<c.pos;\n\t}\n};\nquestion q[N<<1];\n\ninline void jia(int u,int v)\n{\n\te[++cnt].nex=head[u];\n\thead[u]=cnt;\n\te[cnt].to=v;\n}\n\ninline void dfs(int u,int fa)\n{\n\tdep[u]=dep[fa]+1;\n\tsiz[u]=1;\n\tf[u]=fa;\n\tfor ( int i=head[u];i;i=e[i].nex )\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==fa) continue;\n\t\tdfs(v,u);\n\t\tsiz[u]+=siz[v];\n\t\tif(siz[v]>siz[son[u]]) \n\t\t\tson[u]=v;\n\t}\n}\n\ninline void dfs2(int u,int tp)\n{\n\tid[u]=++tot;\n\ttop[u]=tp;\n\tif(son[u]) dfs2(son[u],tp);\n\tfor ( int i=head[u];i;i=e[i].nex )\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==f[u]||v==son[u]) continue;\n\t\tdfs2(v,v);\n\t}\n}\n\ninline void push_down(int rt,int l,int r)\n{\n    if(laz[rt])\n\t{\n\t\tlaz[rt<<1]+=laz[rt];\n\t\tlaz[rt<<1|1]+=laz[rt];\n\t\tint mid=(l+r)/2;\n\t\ttr[rt<<1]+=(mid-l+1)*laz[rt];\n\t\ttr[rt<<1|1]+=(r-mid)*laz[rt];\n        laz[rt]=0;\n    }\n}\n\ninline void update(int rt,int l,int r,int ll,int rr)\n{\n    if(ll<=l && rr>=r) \n    {\n    \tlaz[rt]+=1ll;\n    \ttr[rt]+=(r-l+1);\n    \treturn;\n    }\n    push_down(rt,l,r);\n    int mid=(l+r)/2;\n    if(ll<=mid) update(rt<<1,l,mid,ll,rr);\n    if(rr>mid) update(rt<<1|1,mid+1,r,ll,rr); \n    tr[rt]=(tr[rt<<1]+tr[rt<<1|1]);\n}\n\ninline int query(int rt,int l,int r,int ll,int rr)\n{\n    if(ll<=l && rr>=r) return tr[rt];\n    push_down(rt,l,r);\n    int mid=(l+r)/2;\n    int ans=0;\n    if(ll<=mid) ans+=query(rt<<1,l,mid,ll,rr);\n    if(rr>mid) ans+=query(rt<<1|1,mid+1,r,ll,rr); \n    return ans;\n}\n\n\ninline void modify(int u,int v)\n{\n    while(top[u]!=top[v])\n\t{\n        if(dep[top[u]]<dep[top[v]]) swap(u,v);\n        update(1,1,n,id[top[u]],id[u]);\n        u=f[top[u]];\n    }\n    if(dep[u]>dep[v]) swap(u,v);\n    update(1,1,n,id[u],id[v]);\n}\n\ninline int qsum(int u,int v)\n{\n    int ans=0 ;\n    while(top[u]!=top[v])\n\t{\n        if(dep[top[u]]<dep[top[v]]) swap(u,v);\n        ans+=query(1,1,n,id[top[u]],id[u]);\n        ans=(ans+mod)%mod;\n        u=f[top[u]];\n    }\n    if(dep[u]>dep[v]) swap(u,v);\n    ans=(ans+query(1,1,n,id[u],id[v]))%mod;\n    return ans;\n}\n//\u6811\u94fe\u5256\u5206\u5957\u7ebf\u6bb5\u6811\n\nsigned main()\n{\n//\tfreopen(\"mx.in\",\"r\",stdin);\n//\tfreopen(\"my.out\",\"w\",stdout);\n\tn=read();\n\tm=read();\n\tf[1]=1,dep[1]=0,siz[0]=0;\n\tfor ( int i=2;i<=n;++i )\n\t{\n\t\tint u=read()+1;\n        //+1\u66f4\u52a0\u597d\u5904\u7406\n        jia(u,i);\n        jia(i,u);\n    }\n\tdfs(1,0);\n\tdfs2(1,0);\n\tfor ( int i=1;i<=m;i++ )\n\t{\n\t\tint l=read()+1;\n\t\tint r=read()+1;\n\t\tint z=read()+1;\n        q[all++]=(question){l-1,z,i,0};\n        //\u5bf9l-1\u8fdb\u884c\u6807\u8bb0\n        q[all++]=(question){r,z,i,1};\n    }\n    sort(q,q+all);\n    int cur =1;\n    for( int i=0;i<all;++i)\n\t{\n        while(cur<=q[i].pos) modify(1,cur++);\n        if(q[i].flg) res[q[i].id]+=qsum(1,q[i].z);\n        else res[q[i].id]-=qsum(1,q[i].z);\n        res[q[i].id]+=mod;\n        res[q[i].id]%=mod;\n    }\n    for ( int i=1;i<=m;++i)\n        printf(\"%lld\\n\",res[i]);\n    return 0;\n}\n/*\n5 2\n0\n0\n1\n1\n1 4 3\n1 4 2\n*/ \n```\n\n    ",
        "postTime": 1583205603,
        "uid": 308464,
        "name": "\u5947\u7c73",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "~~\uff08\u542c\u8bf4\u53ea\u80fd\u79bb\u7ebf\uff09~~\u663e\u7136\u8fd9\u9053\u9898\u53ef\u4ee5\u505a\u5230\u5f3a\u5236\u5728\u7ebf\u2026\u2026\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O((n+q) \\log^2 n)$\n\n~~\u7531\u4e8e\u61d2\u5f97\u5206\u7c7b\u8ba8\u8bba\uff0c\u5728\u6b64\u53ea\u63d0\u4f9b\u79bb\u7ebf\u505a\u6cd5\uff0c\u5728\u7ebf\u505a\u6cd5\u7c7b\u4f3c\uff0c\u52a0\u4e0a\u4e86\u67e5\u8be2\u7684\u70b9\u548c\u67e5\u8be2\u533a\u95f4\u7684\u865a\u6811\u7684\u4f4d\u7f6e\u5173\u7cfb\u8ba8\u8bba~~\n\n\u4eca\u5929\u4e0a\u5348\u505a\u9898\u505a\u5230\u4e86\u4e00\u4e2a\u5947\u5947\u602a\u602a\u7684\u9898\uff1a[\u30102018 12\u6708\u96c6\u8bad Day2\u3011\u5c0f\u5947\u7684\u5371\u673a](https://www.cnblogs.com/KingSann/articles/10118697.html)\n\n\u5982\u679c\u53d1\u73b0\u8be2\u95ee\u67d0\u4e2a\u70b9\u4e0e\u7f16\u53f7\u5728\u67d0\u6bb5\u533a\u95f4\u5185\u7684\u70b9\u4ea7\u751f\u4e00\u4e9b\u5355\u72ec\u7684\u8d21\u732e\u540e\u7edf\u8ba1\u4e00\u4e9b\u4fe1\u606f\u7684\u8bdd\uff0c\u4e0d\u59a8\u8003\u8651\u7ebf\u6bb5\u6811\u5206\u6cbb\u5957\u865a\u6811\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u67e5\u8be2\u76f4\u63a5\u62c6\u5206\u6210 $O(\\log n)$ \u4e2a\u533a\u95f4\u8fdb\u884c\u67e5\u8be2\n\n\u4e5f\u5c31\u662f\u8bf4\u73b0\u5728\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u7ed9\u5b9a\u7f16\u53f7\u5728 $[L,R]$ \u7684\u70b9\uff08\u7279\u6b8a\u70b9\uff09\uff0c\u548c\u82e5\u5e72\u4e2a\u5173\u4e8e\u8fd9\u4e9b\u70b9\u7684\u8be2\u95ee\u70b9\uff0c\u6c42\u8fd9\u4e9b\u8be2\u95ee\u70b9\u4e0e\u8fd9\u4e9b\u7279\u6b8a\u70b9\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148\u7684\u6df1\u5ea6\u4e4b\u548c\n\n\u663e\u7136\u8fd9\u4e2a\u5c31\u662f\u5efa\u865a\u6811\u540e\u4e0a\u9762\u8dd1\u6811\u4e0a\u52a8\u89c4\uff0c\u7136\u540e\u5c31\u505a\u5b8c\u4e86\n\n~~\u5e38\u6570\u611f\u4eba~~\n\n``` cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \n\nconst int N = 100000 + 10;\n\nstruct FastIO {\n    static const int S = 1e7;\n    int wpos;\n    char wbuf[S];\n    FastIO() : wpos(0) {}\n    inline int xchar() {\n        static char buf[S];\n        static int len = 0, pos = 0;\n        if (pos == len)\n            pos = 0, len = fread(buf, 1, S, stdin);\n        if (pos == len) exit(0);\n        return buf[pos++];\n    }\n    inline int operator () () {\n        int c = xchar(), x = 0;\n        while (c <= 32) c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x;\n    }\n    inline ll operator ! () {\n        int c = xchar(); ll x = 0;\n        while (c <= 32) c = xchar();\n        for (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n        return x;\n    }\n    inline void wchar(int x) {\n        if (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;\n        wbuf[wpos++] = x;\n    }\n    inline void operator () (ll x) {\n        if (x < 0) wchar('-'), x = -x;\n        char s[24];\n        int n = 0;\n        while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n        while (n--) wchar(s[n]);\n        wchar('\\n');\n    }\n    inline void space(ll x) {\n        if (x < 0) wchar('-'), x = -x;\n        char s[24];\n        int n = 0;\n        while (x || !n) s[n++] = '0' + x % 10, x /= 10;\n        while (n--) wchar(s[n]);\n        wchar(' ');\n    }\n    inline void nextline() {\n        wchar('\\n');\n    }\n    ~FastIO()\n    {\n        if (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;\n    }\n} io;\n\nint n, q; \n\nint _head[N], _rest[N * 2], _to[N * 2];\nvoid lk(int u, int v) {\n    static int tot = 0;\n    _to[++ tot] = v, _rest[tot] = _head[u], _head[u] = tot;\n    _to[++ tot] = u, _rest[tot] = _head[v], _head[v] = tot;\n}\n\nstruct T {\n    int id, x;\n};\n\nvector<T> que[N * 10];\n\n#define lc (id << 1)\n#define rc (id << 1 | 1)\nvoid poi(int id, int l, int r, int ql, int qr, T t) {\n    int mid = (l + r) >> 1;\n    if(ql <= l && r <= qr) {\n        que[id].push_back(t);\n    } else if(qr <= mid) {\n        poi(lc, l, mid, ql, qr, t);\n    } else if(ql >= mid + 1) {\n        poi(rc, mid + 1, r, ql, qr, t);\n    } else {\n        poi(lc, l, mid, ql, mid, t);\n        poi(rc, mid + 1, r, mid + 1, qr, t);\n    }\n}\n\nint ans[N], beg_dfn[N], end_dfn[N], clk, dep[N], len[N];\nint fa[N][21];\n\nint getlca(int u, int v) {\n    if(dep[u] < dep[v]) swap(u, v);\n    for(int i = 20 ; ~ i ; -- i)\n        if(dep[fa[u][i]] >= dep[v])\n            u = fa[u][i];\n    if(u == v) return u;\n    for(int i = 20 ; ~ i ; -- i)\n        if(fa[u][i] != fa[v][i])\n            u = fa[u][i], v = fa[v][i];\n    return fa[u][0];\n}\n\nvoid getdfn(int u, int fa) {\n    :: fa[u][0] = fa;\n    for(int i = 1 ; i <= 20 ; ++ i)\n        :: fa[u][i] = :: fa[:: fa[u][i - 1]][i - 1];\n    \n    beg_dfn[u] = ++ clk;\n    dep[u] = dep[fa] + 1;\n    for(int i = _head[u] ; i ; i = _rest[i]) {\n        int v = _to[i];\n        if(v == fa) continue;\n        getdfn(v, u);\n    }\n    end_dfn[u] = clk;\n}\n\nint a[N * 10], top, root, spe[N];\nint cmp(int x, int y) { return beg_dfn[x] < beg_dfn[y]; }\n\nconst int inf = 0x3f3f3f3f;\n\nint head[N], rest[N * 2], to[N * 2], tot;\n\nint thev[N], the_top;\n\nll f[N], h[N], fafa[N];\n\nll cnt[N], sum[N], sz[N];\n\nnamespace TreeDP {\n    void dfs(int u, int fa) {\n        sz[u] = 0;\n        if(spe[u]) {\n            sz[u] ++;\n        }\n        for(int i = head[u] ; i ; i = rest[i]) {\n            int v = to[i];\n            if(v == fa) continue;\n            dfs(v, u);\n            sz[u] += sz[v];\n        }\n        fafa[u] += sz[u] * dep[u];\n    }\n    \n    void go(int u, int fa) {\n        \n        fafa[u] += f[u];\n        \n        int cnt = 0;\n        if(spe[u]) ++ cnt;\n        \n        the_top = 0;\n        for(int i = head[u] ; i ; i = rest[i]) {\n            int v = to[i];\n            if(v == fa) continue;\n            thev[++ the_top] = v;\n            cnt += sz[v];\n        }\n        \n        for(int i = 1 ; i <= the_top ; ++ i) {\n            int v = thev[i];\n            f[v] = f[u] + (ll) (cnt - sz[v]) * dep[u];\n        }\n        \n        for(int i = head[u] ; i ; i = rest[i]) {\n            int v = to[i];\n            if(v == fa) continue;\n            go(v, u);\n        }\n    }\n    \n    void sol(int root) {\n        dfs(root, 0);\n        go(root, 0);\n    }\n}\n\nvoid add(int u, int v) {\n    to[++ tot] = v, rest[tot] = head[u], head[u] = tot;\n    to[++ tot] = u, rest[tot] = head[v], head[v] = tot;\n}\n\nint sta[N], statop;\n\nvoid dfs(int id, int l, int r) {\n    int mid = (l + r) >> 1;\n    \n    if(que[id].size()) {\n        top = 0;\n        for(int i = l ; i <= r ; ++ i) {\n            a[++ top] = i;\n            spe[i] = 1;\n        }\n        for(T t: que[id]) {\n            a[++ top] = t.x;\n        }\n        sort(a + 1, a + 1 + top, cmp);\n        top = unique(a + 1, a + 1 + top) - a - 1;\n        \n        for(int i = top ; i >= 2 ; -- i)\n            a[++ top] = getlca(a[i], a[i - 1]);\n        sort(a + 1, a + 1 + top, cmp);\n        top = unique(a + 1, a + 1 + top) - a - 1;\n        \n        tot = 0;\n        for(int i = 1 ; i <= top ; ++ i) {\n            head[a[i]] = 0;\n            fafa[a[i]] = 0;\n            f[a[i]] = 0;\n        }\n        root = a[1];\n        \n        statop = 0;\n        for(int i = 1 ; i <= top ; ++ i) {\n            int u = a[i];\n            while(statop && end_dfn[sta[statop]] < beg_dfn[u]) -- statop;\n            if(statop) {\n                add(sta[statop], u);\n            }\n            sta[++ statop] = u;\n        }\n        \n        TreeDP :: sol(root);\n        \n        for(T t: que[id]) {\n            int ansid = t.id, u = t.x;\n            ans[ansid] += fafa[u];\n        }\n        \n        for(int i = l ; i <= r ; ++ i) spe[i] = 0;\n    }\n    if(l != r) dfs(lc, l, mid), dfs(rc, mid + 1, r);\n}\n\nint main() {\n    \n//    freopen(\"data.in\", \"r\", stdin);\n//    freopen(\"data.out\", \"w\", stdout);\n    \n    n = io(), q = io();\n    for(int i = 2 ; i <= n ; ++ i) {\n        lk(io() + 1, i);\n    }\n    getdfn(1, 0);\n    \n    for(int i = 1, l, r, x ; i <= q ; ++ i) {\n        l = io() + 1, r = io() + 1, x = io() + 1;\n        poi(1, 1, n, l, r, (T) { i, x });\n    }\n    \n    dfs(1, 1, n);\n    for(int i = 1 ; i <= q ; ++ i) {\n        io(ans[i] % 201314);\n    }\n}\n```",
        "postTime": 1544779168,
        "uid": 47111,
        "name": "nekko",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u4e3b\u6d41\u505a\u6cd5\u662f\u79bb\u7ebf\u6811\u5256\r\n\r\n\u4f46\u662f\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u6b64\u9898\u7684 dep \u53ef\u4ee5\u6362\u6210\u4ee5 LCA \u4e3a\u81ea\u53d8\u91cf\u7684\u4efb\u610f\u51fd\u6570\r\n\r\n\u5e76\u4e14\u5728\u7ebf\u56de\u7b54\r\n\r\n\u5177\u4f53\u60f3\u6cd5\u662f\u70b9\u5206\u6811\r\n\r\n\u7136\u540e\u8003\u8651\u7ecf\u8fc7 $u$ \u7684\u4e00\u6761\u8def\u5f84\r\n\r\n\u6211\u4eec\u6ce8\u610f\u5230\uff0c$u$ \u5e76\u4e0d\u4e00\u5b9a\u662f\u8fd9\u4e9b\u8def\u5f84\u7684 LCA\uff0c\u90a3\u4e48\u5206\u7c7b\u8ba8\u8bba\r\n\r\n\u82e5 $LCA(x, u) = u$\r\n\r\n\u8fd9\u4e2a\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u8ba4\u4e3a $x \\to u$ \u8fd9\u6761\u8def\u5f84\u662f\u4e0a\u5347\u7684\r\n\r\n\u90a3\u4e48 LCA \u4e00\u5b9a\u662f\u5728 $u \\to y$ \u8fd9\u6761\u8def\u5f84\u4e0a\r\n\r\n\u6211\u4eec\u5c31\u53ef\u4ee5\u5904\u7406\u51fa\u6240\u6709\u70b9\u5206\u6811\u5b50\u6811\u5185\u7684\u70b9\u5230\u5206\u6cbb\u4e2d\u5fc3\u7684 LCA\uff0c\u628a\u5b83\u4eec\u7684\u503c\u505a\u4e00\u4e2a\u524d\u7f00\u548c\uff0c\u67e5\u8be2\u65f6\u4e8c\u5206\r\n\r\n\u5426\u5219\r\n\r\nLCA \u88ab $x \\to u$ \u8fd9\u6761\u8def\u5f84\u53d6\u5230\u4e86\r\n\r\n\u6211\u4eec\u5c31\u770b\u5206\u6cbb\u4e2d\u5fc3\u5728\u70b9\u5206\u6811\u4e0a\u7684\u5b50\u6811\u5185\u6709\u591a\u5c11\u4e2a\u70b9\u5728\u8303\u56f4\u5185\uff0c\u518d\u4e58\u4ee5 $val[LCA(x,u)]$\r\n \r\n\u4ee3\u7801\r\n\r\n```\r\n#include <bits/stdc++.h>\r\n#define ri register int\r\n#define ll long long\r\nusing namespace std;\r\nconst int Maxn=5e4;\r\nconst int Mod=201314;\r\nstruct Node {\r\n\tint u,x;\r\n\tinline bool operator<(const Node b) const {\r\n\t\treturn u<b.u;\r\n\t}\r\n};\r\nvector<Node>node[2][2*Maxn+5];\r\nvector<int>sum[2][2*Maxn+5];\r\nint st[2*Maxn+5][25],dep[Maxn+5],lg[2*Maxn+5],pos[Maxn+5],vt;\r\nint father[Maxn+5],size[Maxn+5],mx[Maxn+5],vis[Maxn+5];\r\nint lt[Maxn+5],nt[2*Maxn+5],ed[2*Maxn+5],cnt;\r\nint n,m;\r\nint swaper;\r\ninline void myswap(int &x,int &y) {\r\n\tswaper=x,x=y,y=swaper;\r\n}\r\ninline int mymax(int x,int y) {return x>y?x:y;}\r\ninline int check(int x,int y) {return dep[x]<dep[y]?x:y;}\r\ninline void addedge(int x,int y) {\r\n\ted[++cnt]=y;nt[cnt]=lt[x];lt[x]=cnt;\r\n}\r\nvoid dfs_euler(int u,int fa) {\r\n\tdep[u]=dep[fa]+1,st[++vt][0]=u,pos[u]=vt;\r\n\tfor(ri i=lt[u];i;i=nt[i]) {\r\n\t\tint v=ed[i];\r\n\t\tif(v!=fa) {\r\n\t\t\tdfs_euler(v,u);\r\n\t\t\tst[++vt][0]=u;\r\n\t\t}\r\n\t}\r\n}\r\ninline int lca(int x,int y) {\r\n\tint l=pos[x],r=pos[y];\r\n\tif(l>r)myswap(l,r);\r\n\tint t=lg[r-l+1];\r\n\treturn check(st[l][t],st[r-(1<<t)+1][t]);\r\n}\r\nvoid calc_st() {\r\n\tlg[0]=-1;\r\n\tfor(ri i=1;i<=vt;i++)lg[i]=lg[i>>1]+1;\r\n\tfor(ri j=1;j<=lg[vt];j++)\r\n\t\tfor(ri i=1;i<=vt-(1<<j)+1;i++)st[i][j]=check(st[i][j-1],st[i+(1<<j-1)][j-1]);\r\n}\r\nint dfs1(int u,int fa) {\r\n\tint ret=1;\r\n\tfor(ri i=lt[u];i;i=nt[i]) {\r\n\t\tint v=ed[i];\r\n\t\tif(!vis[v]&&v!=fa) {\r\n\t\t\tret+=dfs1(v,u);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\nint dfs2(int u,int fa,int tot) {\r\n\tsize[u]=1;mx[u]=0;\r\n\tint ret=0;\r\n\tfor(ri i=lt[u];i;i=nt[i]) {\r\n\t\tint v=ed[i];\r\n\t\tif(!vis[v]&&v!=fa) {\r\n\t\t\tint x=dfs2(v,u,tot);\r\n\t\t\tif(mx[x]<mx[ret])ret=x;\r\n\t\t\tmx[u]=mymax(mx[u],size[v]); \r\n\t\t\tsize[u]+=size[v];\r\n\t\t}\r\n\t}\r\n\tmx[u]=mymax(mx[u],tot-size[u]);\r\n\tif(mx[u]<mx[ret])ret=u;\r\n\treturn ret;\r\n}\r\nvoid dfs3(int rt,int u,int fa) {\r\n\tnode[0][rt].push_back((Node){u,lca(u,rt)});\r\n\tsum[0][rt].push_back(0);\r\n\tif(father[rt]) {\r\n\t\tnode[1][rt].push_back((Node){u,lca(u,father[rt])});\r\n\t\tsum[1][rt].push_back(0);\r\n\t}\r\n\tfor(ri i=lt[u];i;i=nt[i]) {\r\n\t\tint v=ed[i];\r\n\t\tif(!vis[v]&&v!=fa)dfs3(rt,v,u);\r\n\t}\r\n}\r\ninline void newnode(int u) {\r\n\tnode[0][u].push_back((Node){0,0});\r\n\tnode[1][u].push_back((Node){0,0});\r\n\tsum[0][u].push_back(0);\r\n\tsum[1][u].push_back(0);\r\n}\r\ninline void calc(int u) {\r\n\tsort(node[0][u].begin(),node[0][u].end());\r\n\tfor(ri i=1;i<(int)node[0][u].size();i++) {\r\n\t\tsum[0][u][i]=(sum[0][u][i-1]+dep[node[0][u][i].x])%Mod;\r\n\t}\r\n\tsort(node[1][u].begin(),node[1][u].end());\r\n\tfor(ri i=1;i<(int)node[1][u].size();i++) {\r\n\t\tsum[1][u][i]=(sum[1][u][i-1]+dep[node[1][u][i].x])%Mod;\r\n\t}\r\n}\r\nvoid solve(int u,int fa) {\r\n\tint tot=dfs1(u,0);\r\n\tu=dfs2(u,0,tot);\r\n\tfather[u]=fa;\r\n\tnewnode(u);\r\n\tdfs3(u,u,0);\r\n\tcalc(u);\r\n\tvis[u]=1;\r\n\tfor(ri i=lt[u];i;i=nt[i]) {\r\n\t\tint v=ed[i];\r\n\t\tif(!vis[v])solve(v,u);\r\n\t}\r\n}\r\ninline int getpos(int op,int u,int x) {\r\n\tint l=1,r=(int)node[op][u].size()-1;\r\n\twhile(l<=r) {\r\n\t\tint mid=(l+r)>>1;\r\n\t\tif(node[op][u][mid].u>x)r=mid-1;\r\n\t\telse l=mid+1;\r\n\t}\r\n\treturn r;\r\n}\r\ninline int query_num(int op,int u,int l,int r) {\r\n\treturn getpos(op,u,r)-getpos(op,u,l-1);\r\n}\r\ninline int query_sum(int op,int u,int l,int r) {\r\n\treturn sum[op][u][getpos(op,u,r)]-sum[op][u][getpos(op,u,l-1)];\r\n}\r\ninline int query(int l,int r,int x) {\r\n\tint lst=0,ans=0;\r\n\tfor(ri i=x;i;i=father[i]) {\r\n\t\tint t=lca(x,i);\r\n\t\tif(t==i) {\r\n\t\t\tans+=query_sum(0,i,l,r),ans%=Mod;\r\n\t\t\tif(lst)ans-=query_sum(1,lst,l,r),ans=(ans+Mod)%Mod;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tans+=1ll*dep[t]*query_num(0,i,l,r)%Mod,ans%=Mod;\r\n\t\t\tif(lst)ans-=1ll*dep[t]*query_num(1,lst,l,r)%Mod,ans=(ans+Mod)%Mod;\r\n\t\t}\r\n\t\tlst=i;\r\n\t}\r\n\treturn ans;\r\n}\r\nint main() {\r\n\tscanf(\"%d%d\",&n,&m);\r\n\tfor(ri i=2;i<=n;i++) {\r\n\t\tint f;\r\n\t\tscanf(\"%d\",&f);\r\n\t\t++f;\r\n\t\taddedge(f,i);\r\n\t\taddedge(i,f);\r\n\t}\r\n\tdfs_euler(1,0);\r\n\tcalc_st();\r\n\tmx[0]=n+1;\r\n\tsolve(1,0);\r\n\twhile(m--) {\r\n\t\tint l,r,x;\r\n\t\tscanf(\"%d%d%d\",&l,&r,&x);\r\n\t\t++l,++r,++x;\r\n\t\tprintf(\"%d\\n\",query(l,r,x));\r\n\t}\r\n\treturn 0;\r\n}\r\n```\r\n",
        "postTime": 1645011612,
        "uid": 201278,
        "name": "xianggl",
        "ccfLevel": 0,
        "title": "LNOI2014 LCA \u9898\u89e3"
    },
    {
        "content": "# LCA\u9898\u89e3\n\n\u795e\u5947\u5316\u7b80\u9898\uff0c\u8c01\u770b\u5f97\u51fa\u8fd9\u662f\u6811\u5256\u3002\n\n\u9996\u5148\uff0c$lca$\u7684\u7956\u5b97\u5bf9$lca$\u90fd\u6709\u8d21\u732e\uff0c\u6211\u4eec\u4e0d\u59a8\u5c06$0$\u5230$lca$\u8def\u5f84\u7684\u6743\u503c\u90fd\u52a0$1$\uff0c\u5219$lca$\u7684$deep$\u5c31\u4e3a$0$\u5230$lca$\u7684\u8def\u5f84\u6743\u503c\u548c\n\n\u5219$\\sum_{i=l}^{r}deep[lca_{i}]=\\sum_{i=l}^{r}\\sum_{j=lca_{i}}^{j\\epsilon path(0,lca_{i})}w[j]$\n\n\u6211\u4eec\u60f3\u60f3\u5728\u4e0d\u4f1a$lca$\u7684\u65f6\u5019\u5982\u4f55\u66b4\u529b\u641e\u4e24\u4e2a\u70b9$x$\u548c$y$\u7684l$ca$\uff1f\n\n\u6211\u4eec\u53ef\u4ee5\u660e\u786e\u6df1\u5ea6\u5927\u4e8e$lca$\u7684\u70b9\u5bf9\u4e8e$lca$\u4e0d\u4f1a\u6709\u8d21\u732e,\u4e14$deep[x]>=deep[lca]$\n\n\u4e0d\u59a8\u5c06\u6211\u4eec\u4e0d\u59a8\u5c06$0$\u5230$x$\u8def\u5f84\u7684\u6743\u503c\u90fd\u52a0$1$\uff0c$deep[lca]=\\sum_{i=y}^{i\\epsilon path(0,y)}w[i]$\n\n~~\u611f\u6027\u7406\u89e3\u4e00\u4e0b\u5427~~\n\n\u5982\u6b64\u6211\u4eec\u9700\u8981\u679a\u4e3e$i$\u4ece$l$\u5230$r$,\u5c06$0$\u5230$i$\u8def\u5f84\u7684\u6743\u503c\u90fd\u52a0$1$,$\\sum_{i=l}^{r}deep[lca(i,z)]=\\sum_{i=z}^{i\\epsilon path(0,z)}w[i]$\n\n\u8fd9\u6837\u4e00\u6b21\u67e5\u8be2\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(n*logn*logn)$\n\n\u6709$q$\u6b21\u8be2\u95ee\u3002\n\n\u6211\u4eec\u60f3\uff0c\u6bcf\u4e00\u6b21\u8be2\u95ee\u90fd\u628a\u7ebf\u6bb5\u6811\u6e05\u7a7a\u592a\u6d6a\u8d39\u4e86\uff0c\u533a\u95f4$[l,r]$\u53ef\u4ee5\u5dee\u5206\u4e3a$[1,r]-[1,l-1]$\n\n\u5c06\u8be2\u95ee\u62c6\u6210$[1,l-1]$\u548c$[1,r]$\u4e24\u90e8\u5206,\u6309\u53f3\u7aef\u70b9\u6392\u5e8f\u5373\u53ef.\n\n###\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define lc (x<<1)\n#define rc (x<<1|1) \nusing namespace std;\nconst int N=60006,inf=1e9,mod=201314;\nint n,m,t1,t2,t3,cnt=0,dfn=0,tot=0,f[N],a[N],d[N],son[N],siz[N],num[N],top[N],lazy[N<<2],w[N<<2],head[N],ans[N];\nstruct xd{int i,flag,x,y;}q[N<<1];\nstruct edge{int nxt,to;}e[N<<1];\ninline void add(int u,int v){e[++cnt].nxt=head[u],e[cnt].to=v,head[u]=cnt;}\ninline int read(){\n   int T=0,F=1; char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}\n   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();\n   return F*T;\n}\nvoid dfs(int x){\n     d[x]=d[f[x]]+1,siz[x]=1; int maxt=0,maxa=-1;\n     for(int i=head[x];i;i=e[i].nxt){\n            dfs(e[i].to),siz[x]+=siz[e[i].to];\n            if(maxa<siz[e[i].to]) maxt=e[i].to,maxa=siz[maxt];\n         } \n     son[x]=maxt;\n}\nvoid dfs2(int x,int topx){\n     num[x]=++dfn,top[x]=topx; \n     if(son[x]) dfs2(son[x],topx);\n     for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f[x]&&e[i].to!=son[x]) dfs2(e[i].to,e[i].to); \n}\nvoid pushdown(int x,int len){if(lazy[x]) lazy[lc]=(lazy[lc]+lazy[x])%mod,lazy[rc]=(lazy[rc]+lazy[x])%mod,w[lc]=(w[lc]+lazy[x]*(len-(len>>1))%mod)%mod,w[rc]=(w[rc]+lazy[x]*(len>>1)%mod)%mod,lazy[x]=0;}\nvoid update(int l,int r,int p,int q,int x,int y){\n     if(p<=l&&r<=q){w[x]=(w[x]+(r-l+1)*y%mod)%mod,lazy[x]=(lazy[x]+y)%mod; return;}\n     pushdown(x,r-l+1);\n     int mid=l+r>>1;\n     if(p<=mid) update(l,mid,p,q,lc,y);\n     if(q>mid) update(mid+1,r,p,q,rc,y);\n     w[x]=(w[lc]+w[rc])%mod;\n}\nint query(int l,int r,int p,int q,int x){\n     if(p<=l&&r<=q) return w[x];\n     pushdown(x,r-l+1);\n     int mid=l+r>>1,ans=0;\n     if(p<=mid) ans=query(l,mid,p,q,lc);\n     if(q>mid) ans=(ans+query(mid+1,r,p,q,rc))%mod;\n     return ans;\n}\nvoid lj_update(int x,int y){\n    while(top[x]!=top[y]){\n         if(d[top[x]]<d[top[y]]) swap(x,y);\n         update(1,n,num[top[x]],num[x],1,1);\n         x=f[top[x]];\n    }\n    if(d[x]>d[y]) swap(x,y);\n    update(1,n,num[x],num[y],1,1); \n}\nint lj_query(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n         if(d[top[x]]<d[top[y]]) swap(x,y);\n         ans=(ans+query(1,n,num[top[x]],num[x],1))%mod;\n         x=f[top[x]];\n    }\n    if(d[x]>d[y]) swap(x,y);\n    ans=(ans+query(1,n,num[x],num[y],1))%mod; \n    return ans;\n}\nbool cmp(xd u,xd v){return u.x<v.x;}\nint main(){\n    n=read(),m=read();\n    for(int i=2;i<=n;++i) f[i]=read()+1,add(f[i],i);\n    dfs(1),dfs2(1,1);\n    for(int i=1;i<=m;++i){\n        t1=read(),t2=read()+1,t3=read()+1;\n        q[++tot].flag=0,q[tot].i=i,q[tot].x=t1,q[tot].y=t3;\n        q[++tot].flag=1,q[tot].i=i,q[tot].x=t2,q[tot].y=t3; \n    }\n    sort(q+1,q+tot+1,cmp),q[0].x=0;\n    for(int i=1;i<=tot;++i){\n        for(int j=q[i-1].x+1;j<=q[i].x;++j)\n            lj_update(1,j);\n        if(!q[i].flag) ans[q[i].i]=-lj_query(1,q[i].y);\n        else ans[q[i].i]=(ans[q[i].i]+lj_query(1,q[i].y)+mod)%mod;\n    }\n    for(int i=1;i<=m;++i) printf(\"%d\\n\",ans[i]);\n    return 0;\n}  \n```",
        "postTime": 1566645459,
        "uid": 44180,
        "name": "ljk123",
        "ccfLevel": 0,
        "title": "# LCA\u9898\u89e3"
    },
    {
        "content": "~~\u5341\u5206\u6fc0\u52a8\u554a,\u53c8\u8fc7\u4e86\u4e2a\u9ed1\u9898~~\n\n\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0,\u5f53\u6211\u4eec\u628al~r\u7684\u70b9\u5f80\u6839\u8282\u70b9\u7684\u6743\u503c+1\u540e,\u4e0ez\u7684lca\u6df1\u5ea6\u4e4b\u548c\u5c31\u662fz\u5230\u6839\u8282\u70b9\u7684\u6743\u503c\u4e4b\u548c.\u90a3\u4e48\u8fd9\u662f\u4e3a\u4ec0\u4e48\u5462?\n\n\u5bf9\u4e8el<=i<=r,\u6211\u4eec\u5047\u8bbelca\u662fi\u4e0ez\u7684lca,\u90a3\u4e48\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u5c31\u662flca\u7684\u6df1\u5ea6\u4e5f\u662flca\u5230\u6839\u8282\u70b9\u7684\u957f\u5ea6,\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u628a\u8fd9\u4e2a\u95ee\u9898\u8f6c\u5316\u4e3a\u6811\u5256+\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\n\n\u53ef\u662f\u5982\u679c\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u6211\u4eec\u5148\u628a\u6bcf\u4e2ai\u52a0\u5165\u7ebf\u6bb5\u6811\u6700\u540e\u6c42\u7b54\u6848\u65f6\u95f4\u590d\u6742\u5ea6\u662fO($N^2logn^2$),\u8fd9\u6837\u663e\u7136\u4e0d\u5bf9.\u4f46\u662f\u6211\u4eec\u53d1\u73b0\u5176\u5b9el~r\u5bf9\u4e8ez\u7684\u7b54\u6848\u663e\u7136\u6ee1\u8db3\u5dee\u5206\u7684\u6027\u8d28,\u4e8e\u662f\u5c31\u53ef\u4ee5\u628a\u5b83\u8f6c\u5316\u62101~r\u5bf9\u4e8ez\u7684\u7b54\u6848-1~(l-1)\u5bf9\u4e8ez\u7684\u7b54\u6848.\u6240\u4ee5\u5c31\u53ef\u4ee5\u89e3\u51b3\u4e86.\n\n\u4e0b\u9644\u4ee3\u7801:\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint tot,tim,n,q;\nint size[50005],head[50005],head2[50005],nex[200005],flag[200005],id[200005],go[200005],dfn[50005],maxson[50005],top[50005],t[2000005],lazy[2000005],fa[50005],x[50005],y[50005],z[50005],wri[50005];\nvoid add(int u,int v)//\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe\n{\n\ttot++;\n\tnex[tot]=head[u];\n\thead[u]=tot;\n\tgo[tot]=v;\n}\nvoid add2(int u,int v,int w,int p)//\u628ap\u7684\u8be2\u95ee\u4fe1\u606f\u52a0\u51651~u\u4e2d\n{\n\ttot++;\n\tnex[tot]=head2[u];\n\thead2[u]=tot;\n\tgo[tot]=v;\n\tflag[tot]=w;\n\tid[tot]=p;\n}\nvoid dfs1(int u)//\u6811\u5256\u6a21\u677f\n{\n\tsize[u]=1;\n\tfor (int i=head[u];i>0;i=nex[i])\n\t{\n\t\tint v=go[i];\n\t\tdfs1(v);\n\t\tsize[u]=size[u]+size[v];\n\t\tif (size[v]>size[maxson[u]]) maxson[u]=v;\n\t}\n}\nvoid dfs2(int u)\n{\n\ttim++;\n\tdfn[u]=tim;\n\tif (maxson[u]!=0)\n\t{\n\t\ttop[maxson[u]]=top[u];\n\t\tdfs2(maxson[u]);\n\t}\n\tfor (int i=head[u];i>0;i=nex[i])\n\t{\n\t\tint v=go[i];\n\t\tif (v!=maxson[u])\n\t\t{\n\t\t\ttop[v]=v;\n\t\t\tdfs2(v);\n\t\t}\n\t}\n}\nvoid add(int x,int y,int l,int r,int k)//\u533a\u95f4\u52a0\u7ebf\u6bb5\u6811\n{\n\tt[k]=t[k]+(y-x+1);\n\tif (t[k]>=201314) t[k]=t[k]-201314;\n\tif ((l==x)&&(r==y))\n\t{\n\t\tlazy[k]=lazy[k]+1;\n\t\tif (lazy[k]>=201314) lazy[k]=lazy[k]-201314;\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tif (y<=mid) add(x,y,l,mid,k<<1);\n\telse\n\tif (x>mid) add(x,y,mid+1,r,k<<1|1);\n\telse\n\t{\n\t\tadd(x,mid,l,mid,k<<1);\n\t\tadd(mid+1,y,mid+1,r,k<<1|1);\n\t}\n}\nvoid pushdown(int l,int r,int k)//\u61d2\u60f0\u6807\u8bb0\u4e0b\u653e\n{\n\tint mid=(l+r)>>1;\n\tt[k<<1]=(t[k<<1]+((long long)(mid-l+1)*lazy[k])%201314)%201314;\n\tt[k<<1|1]=(t[k<<1|1]+((long long)(r-mid)*lazy[k])%201314)%201314;\n\tlazy[k<<1]=lazy[k<<1]+lazy[k];\n\tif (lazy[k<<1]>=201314) lazy[k<<1]=lazy[k<<1]-201314;\n\tlazy[k<<1|1]=lazy[k<<1|1]+lazy[k];\n\tif (lazy[k<<1|1]>=201314) lazy[k<<1|1]=lazy[k<<1|1]-201314;\n\tlazy[k]=0;\n}\nint get(int x,int y,int l,int r,int k)//\u533a\u95f4\u6c42\u548c\u7ebf\u6bb5\u6811\n{\n\tif ((l==x)&&(r==y)) return t[k];\n\tpushdown(l,r,k);\n\tint mid=(l+r)>>1;\n\tif (y<=mid) return get(x,y,l,mid,k<<1);\n\telse\n\tif (x>mid) return get(x,y,mid+1,r,k<<1|1);\n\telse return (get(x,mid,l,mid,k<<1)+get(mid+1,y,mid+1,r,k<<1|1))%201314;\n}\nint main()\n{\n\tcin>>n>>q;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tcin>>fa[i];\n\t\tfa[i]++;\n\t\tadd(fa[i],i);\n\t}\n\tfor (int i=1;i<=q;i++)\n\t{\n\t\tcin>>x[i]>>y[i]>>z[i];\n\t\tx[i]++;\n\t\ty[i]++;\n\t\tz[i]++;\n\t\tadd2(x[i]-1,z[i],-1,i);\n\t\tadd2(y[i],z[i],1,i);\n\t}\n\tdfs1(1);\n\ttop[1]=1;\n\tdfs2(1);\n\tfor (int i=1;i<=n;i++)//\u7b97\u51fa1~i\u7684\u7b54\u6848\n\t{\n\t\tint p=i;\n\t\twhile (top[p]!=1)\n\t\t{\n\t\t\tadd(dfn[top[p]],dfn[p],1,n,1);\n\t\t\tp=fa[top[p]];\n\t\t}\n\t\tadd(1,dfn[p],1,n,1);\n\t\tfor (int j=head2[i];j>0;j=nex[j])//\u6c42\u51fa\u6240\u6709\u5bf9\u4e8e1~i\u7684\u95ee\u9898\n\t\t{\n\t\t\tint pp=go[j];\n\t\t\tint ans=0;\n\t\t\twhile (top[pp]!=1)\n\t\t\t{\n\t\t\t\tans=ans+get(dfn[top[pp]],dfn[pp],1,n,1);\n\t\t\t\tif (ans>=201314) ans=ans-201314;\n\t\t\t\tpp=fa[top[pp]];\n\t\t\t}\n\t\t\tans=ans+get(1,dfn[pp],1,n,1);\n\t\t\tif (ans>=201314) ans=ans-201314;\n\t\t\twri[id[j]]=((wri[id[j]]+flag[j]*ans)%201314+201314)%201314;\n\t\t}\n\t}\n\tfor (int i=1;i<=q;i++)\n\tcout<<wri[i]<<endl;\n}\n```",
        "postTime": 1542179907,
        "uid": 28810,
        "name": "King_of_gamers",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "~~\u63d0\u4f9b\u4e00\u79cd\u4e0d\u4f18\u7684\u5728\u7ebf\u7684\u505a\u6cd5~~\n\n\u597d\u5427\u6211\u4eec\u8fd8\u662f\u76f4\u63a5\u8bf4\u8bf4\u8fd9\u9053\u9898\u600e\u4e48\u505a\u5427\u3002\n\n\u9996\u5148\u8981\u53d1\u73b0\u4e00\u4e9b\u6027\u8d28\uff0c\u6bd4\u5982\u6c42\u4e00\u4e2a$LCA$\u7684$dep$\u5176\u5b9e\u662f\u8be2\u95ee\u8fd9\u4e2a$LCA$\u4e0a\u6709\u591a\u5c11\u4e2a\u70b9$+1$\uff0c\u6545\u4e00\u79cd\u6bd4\u8f83$naive$\u7684\u60f3\u6cd5\u4fbf\u51fa\u6765\u4e86 $QAQ$\u6211\u4eec\u53ef\u4ee5\u5148\u8fdb\u884c\u4e00\u4e2a**\u67d3\u8272** \u64cd\u4f5c\uff0c\u8ba9$l-r$\u7684\u6240\u6709\u70b9\u5230\u6839\u8282\u70b9\u8fd9\u4e00\u8def\u5f84\u4e0a\u6240\u6709\u70b9\u7684\u70b9\u6743\u90fd$+1$\n\n\u7136\u540e\u518d\u8be2\u95ee\u8fd9\u4e2a\u70b9$z$\u5230\u6839\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u6743\u548c\u5373\u53ef\u3002\n\n\u4f60\u53d1\u73b0\u8fd9\u6837\u505a\u8c8c\u4f3c\u590d\u6742\u5ea6\u4e0d\u4ec5\u4e0d\u4f18\uff0c\u5982\u679c\u7528\u6811\u5256\u6765\u5b9e\u73b0\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u590d\u6742\u5ea6\u6bd4\u7eaf\u66b4\u529b$O(n^2logn)$\u8fd8\u8981\u5dee$->O(n^2log^2n)$\n\n\u7136\u800c\u5982\u679c\u6211\u4eec\u79bb\u7ebf\u5730\u641e\u5462\uff1f\n\n\n---------------\n\n\u79bb\u7ebf\u505a\u6cd5$1.O(n\\sqrt n*log^2n)$\n\n\u6211\u4eec\u7c7b\u4f3c\u4e8e\u83ab\u961f\u7684\u641e\u6cd5\uff0c\u5176\u5b9e\u6839\u672c\u4e0d\u7528\u5173\u5fc3\u8be2\u95ee\u70b9\u662f\u90a3\u91cc\uff0c\u5b9e\u9645\u4e0a\u5bf9\u4e8e\u67d0\u6b21\u8be2\u95ee\u6211\u4eec\u53ea\u662f\u60f3\u77e5\u9053\u6811\u7684\u72b6\u6001\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u6811\u7684\u72b6\u6001\u662f\u600e\u4e48\u6539\u53d8\u7684\uff1f\u4f60\u53d1\u73b0\u4e4b\u524d\u7684\u66b4\u529b\u5b58\u5728\u4e00\u4e2a\u7279\u522b$naive$\u7684\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u5c06$l-r$\u4e2d\u6240\u6709\u70b9\u5230\u6839\u7684\u8def\u5f84$+1$\u540e\u5b58\u5728\u4e00\u4e2a\u6e05\u7a7a\u6811\u7684\u8fc7\u7a0b\u3002\u7136\u800c\u5b9e\u9645\u4e0a\u5e76\u4e0d\u9700\u8981\uff0c\u6211\u4eec\u5c06\u8be2\u95ee\u6309\u7167\u83ab\u961f\u7684\u65b9\u6cd5\u6392\u5e8f\uff0c\u6bcf\u6b21\u52a0\u70b9\u7684\u65f6\u5019\u5c06\u8fd9\u4e2a\u70b9$l/r$\u5230\u6839\u7684\u8def\u5f84$+1$\uff0c\u5220\u70b9\u5c31$-1$\n\n--------------------\n\n\u79bb\u7ebf\u505a\u6cd5$2.O(nlog^2n)$\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u5176\u5b9e\u662f\u53ef\u4ee5\u5dee\u5206\u7684\uff0c\u53ef\u4ee5\u8003\u8651\u5c06\u8be2\u95ee\u62c6\u5206\u6210\u4e24\u4e2a\u8be2\u95ee\n\n$>>l,r,z ->(1,r,z) - (1,l-1,z)$\n\n\u4e5f\u5c31\u662f$l-r$\u8fd9\u4e00\u7cfb\u5217\u64cd\u4f5c\uff08\u5b9e\u9645\u4e0a$l-r$\u8fd9\u4e2a\u533a\u95f4\u662f\u4e00\u4e2a$+1$\u64cd\u4f5c\uff09\u540e\u7684\u7b54\u6848\u53ef\u4ee5\u770b\u4f5c\u64cd\u4f5c$1-r$\u540e\u7684\u7b54\u6848\u548c$[1,l-1]$\u7684\u7b54\u6848\u7684\u5dee\u3002\n\n\u5b9e\u9645\u4e0a\u5982\u679c\u62c6\u540e\u6211\u4eec\u53d1\u73b0\u6839\u672c\u5c31\u4e0d\u9700\u8981\u5173\u6ce8\u5de6\u533a\u95f4\u4e86\uff08\u90fd\u662f1\uff09\u6240\u4ee5\u53ea\u9700\u8981\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\u540e\u5904\u7406\u5c31\u884c\u4e86\u3002\n\n-------------\n\n\u5728\u7ebf\u505a\u6cd5$O(nlog^2n)$\n\n\u7c7b\u4f3c\u4e8e\u79bb\u7ebf\u7684\u505a\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u628a$l-r$\u7684\u7b54\u6848\u62c6\u6210$1-(l-1)$\u7684\u7b54\u6848\u548c$1-r$\u7684\u7b54\u6848\u7684\u5dee\u3002\n\n\u90a3\u4e48\u6211\u4eec\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u5c31\u5728\u4e8e\u5982\u4f55\u5728\u7ebf\u7684\u5904\u7406\u51fa$1-r$\u7684\u7b54\u6848\u4e86\u3002\n\n\u4f60\u53d1\u73b0\u5904\u7406$1-r$\u64cd\u4f5c\u540e\u6811\u7684\u72b6\u6001\u662f\u901a\u8fc7\u8bb8\u591a\u94fe\u4fee\u6539\u64cd\u4f5c\u5f97\u5230\u7684\u3002\n\n\u7136\u800c\u6211\u4eec\u60f3\u8981\u67e5\u8be2\u7684\u5176\u5b9e\u662f\u67d0\u6b21\u64cd\u4f5c\u540e\u6811\u7684\u72b6\u6001\u3002\n\n\u4f60\u60f3\u8fd9\u4e0d\u5c31\u662f\u4e00\u4e2a\u56de\u6eaf\u5386\u53f2\u7248\u672c\u7684\u64cd\u4f5c\u5417\uff1f\u7528\u4e3b\u5e2d\u6811\u554a\u3002\n\n\u7136\u540e\u4f60\u60f3\u5e03\u661f\u554a\uff0c\u4fee\u6539\u4e0d\u662f\u4e00\u6761\u94fe\u7684\u4fee\u6539\u5417\uff0c\u5957\u4e0a\u4e2a\u6811\u5256\u540e\u5373\u4f7f\u5728\u4e3b\u5e2d\u6811\u4e0a\u4e5f\u662f\u8bb8\u591a\u7684\u533a\u95f4\u4fee\u6539\u554a $QAQ$\n\n\u4f60\u60f3\u4ec0\u4e48\u65f6\u5019\u4e3b\u5e2d\u6811\u4e5f\u80fd\u505a\u533a\u95f4\u4fee\u6539\u4e86\uff0c\u7136\u800c\u53ea\u9700\u8981\u6807\u8bb0\u6c38\u4e45\u5316\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u5982\u679c\u4e0d\u4f1a\u53ef\u4ee5\u70b9\u5f00\u8fd9\u4e2a\u94fe\u63a5\u770b\u770b\u7136\u540e\u505a\u4e00\u505a\u8fd9\u9053[\u548c$shi$\u853c$fen$\u53ef$gui$\u4eb2$chu$\u7684\u9898](https://www.luogu.org/problemnew/show/SP11470)\n\n\u56e0\u4e3a\u7528\u7684\u4e3b\u5e2d\u6811+\u6811\u5256\uff0c\u7a7a\u95f4\u4e0a\u6709\u70b9\u5c0f\u7d27 $O(nlog^2n)$ \n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint read() {\n\tchar cc = getchar(); int cn = 0, flus = 1;\n\twhile(cc < '0' || cc > '9') cc = getchar();\n\twhile(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();\n\treturn cn * flus;\n}\nconst int N = 50000 + 5 ;\nconst int mod = 201314 ;\n#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )\n#define Next( i, x ) for( register int i = head[x]; i; i = e[i].next )\nint n, q, head[N], root[N * 20], rt[N], ant, cnt ; \nstruct E {\n\tint to, next ; \n} e[N * 2];\nvoid add( int x, int y ) {\n\te[++ cnt] = (E){ y, head[x] }, head[x] = cnt ; \n}\nnamespace Tree {\n\tstruct tree {\n\t\tint fa, top, size, id, son, dep ;\n\t}t[N];\n\tstruct Tr {\n\t\tint l, r, val, add ; \n\t} tr[N * 300];\n\tint num, b[N * 2], Idnum ;\n\t#define ls(x) tr[x].l\n\t#define rs(x) tr[x].r\n\tinline void build( int &x, int l, int r ) {\n\t\tx = ++ num ;\n\t\tif( l == r ) return ; \n\t\tint mid = ( l + r ) >> 1 ; \n\t\tbuild( ls(x), l, mid ), build( rs(x), mid + 1, r ) ;\n\t}\n\tinline void Tr_modify( int &x, int u, int l, int r, int ll, int rr, int add ) {\n\t\tx = ++ num ; \n\t\ttr[x] = tr[u], tr[x].val += ( rr - ll + 1 ) * add % mod, tr[x].val %= mod ; \n\t\tif( l >= ll && r <= rr ) {\n\t\t\ttr[x].add += add ;\n\t\t\treturn ;  \n\t\t}\n\t\tint mid = ( l + r ) >> 1 ; \n\t\tif( mid >= rr ) Tr_modify( ls(x), ls(u), l, mid, ll, rr, add ) ;\n\t\telse if( mid < ll ) Tr_modify( rs(x), rs(u), mid + 1, r, ll, rr, add ) ;\n\t\telse Tr_modify( ls(x), ls(u), l, mid, ll, mid, add ), \n\t\tTr_modify( rs(x), rs(u), mid + 1, r, mid + 1, rr, add ) ;\n\t}\n\tinline int Tr_query( int x, int l, int r, int ll, int rr, int add ) {\n\t\tif( l > rr || r < ll ) return 0 ;\n\t\tif( l >= ll && r <= rr ) return ( tr[x].val + add * ( r - l + 1 ) % mod ) % mod ;\n\t\tint mid = ( l + r ) >> 1 ; \n\t\treturn ( Tr_query( ls(x), l, mid, ll, rr, add + tr[x].add ) + Tr_query( rs(x), mid + 1, r, ll, rr, add + tr[x].add ) ) % mod ;\n\t}\n\t//\u6811\u94fe\u5256\u5206 \n\tinline void dfs1( int x, int fa ) {\n\t\tt[x].fa = fa, t[x].size = 1; \n\t\tt[x].dep = t[fa].dep + 1 ; int s = 0 ;\n\t\tNext( i, x ) {\n\t\t\tint v = e[i].to ; \n\t\t\tif( v == fa ) continue ; \n\t\t\tdfs1( v, x ), t[x].size += t[v].size ; \n\t\t\tif( t[v].size > t[s].size ) s = v ; \n\t\t}\n\t\tt[x].son = s ; \n\t}\n\tinline void dfs2( int x, int high ) {\n\t\tt[x].top = high, t[x].id = ++ Idnum ; b[Idnum] = x ; \n\t\tif( !t[x].son ) return ;\n\t\tdfs2( t[x].son, high ) ;\n\t\tNext( i, x ) {\n\t\t\tint v = e[i].to ; \n\t\t\tif( t[v].id ) continue ; \n\t\t\tdfs2( v, v ) ;\n\t\t}\n\t}\n\tvoid modify( int x, int u ) {\n\t\twhile( t[u].top != 1 ) {\n\t\t\tTr_modify( root[++ ant], root[ant], 1, n, t[t[u].top].id, t[u].id, 1 ) ;\n\t\t\tu = t[t[u].top].fa ; \n\t\t}\n\t\tTr_modify( root[++ ant], root[ant], 1, n, 1, t[u].id, 1 ) ;\n\t\trt[x] = root[ant] ; \n\t}\n\tint query( int x, int u ) {\n\t\tint Ans = 0 ;\n\t\twhile( t[u].top != 1 ) {\n\t\t\tAns += Tr_query( rt[x], 1, n, t[t[u].top].id, t[u].id, 0 ) ;\n\t\t\tu = t[t[u].top].fa, Ans %= mod ;\n\t\t}\n\t\tAns += Tr_query( rt[x], 1, n, 1, t[u].id, 0 ) ;\n\t\treturn Ans % mod ; \n\t}\n\tvoid init() {\n\t\tdfs1( 1, 1 ), dfs2( 1, 1 ), build( root[0], 1, n ) ;\n\t\trep( i, 1, n ) {\n\t\t\tmodify( i, i ) ;\n\t\t}\n\t}\n\tint Answer( int x, int y, int u ) {\n\t\tint Ans = query( y, u ) - query( x, u ) ; \n\t\treturn ( Ans + mod ) % mod ; \n\t}\n}\nsigned main()\n{\n\tn = read(), q = read() ; \n\tint x, y, z ;  \n\trep( i, 2, n ) x = read() + 1, add( x, i ) ; \n\tTree :: init() ;\n\trep( i, 1, q ) {\n\t\tx = read(), y = read() + 1, z = read() + 1 ; \n\t\tprintf(\"%d\\n\", Tree::Answer( x, y, z ) ) ;\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1555660439,
        "uid": 30036,
        "name": "Soulist",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "[$My\\ blog$](https://ctz45562.github.io/2019/09/02/\u6d1b\u8c37-P4211-LNOI2014-LCA/)\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problem/P4211)\n\n\u590d\u4e60\u7269\u7406\u65f6\u7a81\u7136\u6709\u4e86\u8fd9\u4e2a\u9898\u7684\u505a\u6cd5\u3002\n\n~~\u6211\u4e5f\u4e0d\u77e5\u9053\u4e3a\u5565\u5b66\u7269\u7406\u4f1a\u60f3\u5230\u8fd9\u4e2a~~\n\n\u4e00\u4e2a\u4e0d\u7528\u8f6c\u5316\u3001\u4e0d\u7528\u626b\u63cf\u7ebf\u3001\u4e0d\u7528$LCT$\u6811\u5256\u7684$chuan$\u65b0\u505a\u6cd5\uff1a\u76f4\u63a5\u5206\u5757\uff01\n\n\u6bcf\u4e2a\u5757\u5f00\u4e2a$vector$\u8bb0\u5f55\u8be2\u95ee\u3002\n\n\u6563\u5757\u76f4\u63a5\u66b4\u529b\u3002\n\n\u6574\u5757\u628a\u8be5\u8be2\u95ee\u4e22\u8fdb$vector$\u91cc\u3002\n\n\u8be2\u95ee\u5904\u7406\u5b8c\u540e\u5904\u7406\u6bcf\u4e2a\u5757\uff1a\n\n\u8bb0$l,r$\u4e3a\u5757\u7684\u5de6\u53f3\u7aef\u70b9\uff0c\u5bf9\u6bcf\u4e2a\u70b9$x$\u7b97\u51fa$\\sum\\limits_{i=l}^rdeep[lca(i,x)]$\uff0c\u6700\u540e\u628a\u5c5e\u4e8e\u8be5\u5757\u7684\u6bcf\u4e2a\u8be2\u95ee\u70b9\u7684\u8d21\u732e\u52a0\u8fdb\u53bb\u5373\u53ef\u3002\n\n$dfs$\u4e00\u904d\u6811\u3002\u8003\u8651\u6bcf\u4e2a\u70b9\u4e3a$lca$\u7684\u8d21\u732e\u3002\u8bb0$siz(i)$\u4e3a$i$\u5b50\u6811\u4e2d\u7f16\u53f7\u5728$[l,r]$\u7684\u70b9\u7684\u4e2a\u6570\u3002\n\n\u70b9$i$\u4f1a\u5bf9\u5176\u6574\u68f5\u5b50\u6811\u6709$deep(i)\\times siz(i)$\u7684\u8d21\u732e\uff0c\u7136\u540e\u5bf9\u5176\u6bcf\u4e2a\u513f\u5b50$x$\uff0c\u8981\u5bb9\u65a5\u51cf\u53bb$deep(i)\\times siz(x)$\u7684\u4e0d\u5408\u6cd5\u8d21\u732e\u3002\n\n\u5b50\u6811\u52a0\uff0c$dfs$\u5e8f+\u5dee\u5206\u5373\u53ef\u3002\n\n\u7a7a\u95f4$O(n\\sqrt{n})$\uff0c\u7528$O(1)LCA$\u7684\u8bdd\u65f6\u95f4\u4e3a$O(n\\sqrt{n})$\u3002\n\n\u7528$Tarjan\\ LCA$\u88ab\u5361\u7a7a\u95f4\u4e86\u7528\u6811\u5256$LCA$\u88ab\u5361\u65f6\u95f4\u4e86\u88ab\u8feb\u73b0\u5b66\u7684$RMQ\\ LCA$\uff0c~~\u505aLCA\u9898\u5b66LCA\u6ca1\u6bdb\u75c5~~\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n\n#define maxn 50005\n#define inf 0x3f3f3f3f\n\nconst int mod = 201314;\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\nint siz[maxn],h[maxn],seg[maxn],pos[maxn],low[maxn],deep[maxn]={inf,1},num,cnt;\nint be[maxn],a[maxn],ans[maxn],f[maxn<<1][22],fir[maxn],lg[maxn<<1],all;\nstruct edge{\n\tint pre,to;\n}e[maxn];\ninline int cmp(int x,int y){return deep[x]<deep[y]?x:y;}\ninline void add(int from,int to){\n\te[++num].pre=h[from],h[from]=num,e[num].to=to;\n}\nvoid dfs(int node=1){\n\tf[fir[node]=++all][0]=pos[seg[node]=++cnt]=node;\n\tint x;\n\tfor(register int i=h[node];i;i=e[i].pre){\n\t\tx=e[i].to,deep[x]=deep[node]+1,dfs(x);\n\t\tf[++all][0]=node;\n\t}\n\tlow[node]=cnt;\n}\nvoid ST(){\n\tfor(register int i=2;i<=all;++i)lg[i]=lg[i>>1]+1;\n\tfor(register int j=1;j<=lg[all];++j)\n\t\tfor(register int i=1;i+(1<<(j-1))<=all;++i)\n\t\t\tf[i][j]=cmp(f[i][j-1],f[i+(1<<(j-1))][j-1]);\n}\ninline int query(int l,int r){\n\tif(l>r)swap(l,r);\n\tint len=lg[r-l+1];\n\treturn cmp(f[l][len],f[r-(1<<len)+1][len]);\n}\ninline int lca(int x,int y){\n\treturn query(fir[x],fir[y]);\n}\n#define modify(x,d) a[seg[x]]+=d,a[low[x]+1]-=d\n#define id(x) (x>=l&&x<=r)\nstruct BLOCK{\n\tint l,r;\n\tvector<pair<int,int> >q;\n\tvoid calc(int node=1){\n\t\tsiz[node]=id(node);\n\t\tint x;\n\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\tx=e[i].to;\n\t\t\tcalc(x),siz[node]+=siz[x];\n\t\t}\n\t\tmodify(node,deep[node]*siz[node]);\n\t\tfor(register int i=h[node];i;i=e[i].pre){\n\t\t\tx=e[i].to;\n\t\t\tmodify(x,(-deep[node]*siz[x]));\n\t\t}\n\t}\n\tvoid solve(){\n\t\tcalc();\n\t\tfor(register int i=1;i<=cnt;++i)a[i]+=a[i-1];\n\t\tfor(vector<pair<int,int> >::iterator iter=q.begin();iter!=q.end();++iter)\n\t\t\t(ans[iter->second]+=a[iter->first])%=mod;\n\t}\n}b[250];\ninline void odd(int l,int r,int x,int p){\n\tfor(register int i=l;i<=r;++i)ans[p]+=deep[lca(i,x)];\n}\nint main(){\n\tint n=read(),m=read(),l,r,x,sq=sqrt(n),len=n/sq+bool(n%sq);\n\tfor(register int i=2;i<=n;++i)add(read()+1,i);\n\tdfs(),ST();\n\tfor(register int i=1;i<=len;++i){\n\t\tb[i].l=b[i-1].r+1,b[i].r=min(b[i].l+sq-1,n);\n\t\tfor(register int j=b[i].l;j<=b[i].r;++j)\n\t\t\tbe[j]=i;\n\t}\n\tfor(register int i=1;i<=m;++i){\n\t\tl=read()+1,r=read()+1,x=read()+1;\n\t\tif(be[l]==be[r]){odd(l,r,x,i);}\n\t\telse {\n\t\t\todd(l,b[be[l]].r,x,i);\n\t\t\todd(b[be[r]].l,r,x,i);\n\t\t\tx=seg[x];\n\t\t\tfor(register int j=be[l]+1;j<be[r];++j)\n\t\t\t\tb[j].q.push_back((pair<int,int>){x,i});\n\t\t}\n\t}\n\tfor(register int i=1;i<=len;++i)memset(a,0,sizeof a),b[i].solve();\n\tfor(register int i=1;i<=m;++i)printf(\"%d\\n\",(ans[i]%mod+mod)%mod);\n}\n```\n\n\n\n\n\n\n",
        "postTime": 1567425938,
        "uid": 111762,
        "name": "_ctz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u53ef\u4ee5\u53d1\u73b0\u9898\u76ee\u53ef\u4ee5\u8f6c\u5316\u4e3a\u628a\u4ece$l$\u5230$r$\u8282\u70b9\u5230$1$\u7684\u8def\u5f84\u4e0a\u7684\u70b9\u7684\u70b9\u6743\u90fd\u52a0\u4e0a$1$\uff0c\u7136\u540e\u7edf\u8ba1$1$\u5230$z$\u8def\u5f84\u4e0a\u7684\u70b9\u6743\n\n\u7136\u540e\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u53ef\u4ee5\u5dee\u5206\u3002\u3002\u3002\n\n\u4e8e\u662f\u6211\u4eec\u5c31\u628a\u8be2\u95ee\u62c6\u6210$l-1$\u548c$r$,\u7136\u540e\u6309$r$\u6392\u5e8f\n\n\u4ece$1$\u5230$n$\u628a$1$\u5230$i$\u8def\u5f84\u70b9\u6743\u5168\u90e8$+1$\n\n\u8be2\u95ee\u65f6\u67e5\u8be2$1$\u5230$z$\u8def\u5f84\u70b9\u6743\u548c\n\n\u7136\u540e\u5c31\u505a\u5b8c\u4e86\u3002\u3002\u3002\n\n```cpp\n# include <bits/stdc++.h>\nconst int mod = 201314;\nconst int MaxN = 100010;\nstruct edge\n{\n    int next, to;\n};\nstruct node\n{\n    int l, r;\n    int sum, tag;\n};\nstruct query\n{\n    int r, z, id;\n};\nedge e[MaxN << 1];\nquery q[MaxN << 1];\nint n, m, cnt, dfsnum;\nint hson[MaxN], fa[MaxN], dfn[MaxN], ans[MaxN];\nint head[MaxN], size[MaxN], dep[MaxN], top[MaxN];\nstruct SegmentTree\n{\n    node t[MaxN << 2];\n    inline void pushup(int id){t[id].sum = t[id << 1].sum + t[id << 1 | 1].sum;}\n    inline void build(int id, int l, int r)\n    {\n        t[id].l = l, t[id].r = r;\n        if(l == r)\n            return;\n        int mid = (l + r) >> 1;\n        build(id << 1, l, mid);\n        build(id << 1 | 1, mid + 1, r);\n    }\n    inline void pushdown(int id)\n    {\n        if(t[id].tag)\n        {\n            t[id << 1].sum += t[id].tag * (t[id << 1].r - t[id << 1].l + 1);\n            t[id << 1 | 1].sum += t[id].tag * (t[id << 1 | 1].r - t[id << 1 | 1].l + 1);\n            \n            t[id << 1].tag += t[id].tag;\n            t[id << 1 | 1].tag += t[id].tag;\n            \n            t[id].tag = 0;\n        }\n    }\n    inline void modify(int id, int l, int r, int val)\n    {\n        if(t[id].l > r || t[id].r < l)\n            return;\n        if(l <= t[id].l && t[id].r <= r)\n        {\n            t[id].sum += val * (t[id].r - t[id].l + 1);\n            t[id].tag += val;\n            return;\n        }\n        pushdown(id);\n        modify(id << 1, l, r, val);\n        modify(id << 1 | 1, l, r, val);\n        pushup(id);\n    }\n    inline int query(int id, int l, int r)\n    {\n        if(t[id].l > r || t[id].r < l)\n            return 0;\n        if(l <= t[id].l && t[id].r <= r)\n            return t[id].sum;\n        pushdown(id);\n        return query(id << 1, l, r) + query(id << 1 | 1, l, r);\n    }\n}T;\ninline int cmp(query a, query b)\n{\n    return a.r < b.r;\n}\ninline void add_edge(int u, int v)\n{\n    ++cnt;\n    e[cnt].to = v;\n    e[cnt].next = head[u];\n    head[u] = cnt;\n}\ninline void dfs1(int u, int f)\n{\n    size[u] = 1;\n    for(int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if(v == f)\n            continue;\n        dep[v] = dep[u] + 1;\n        fa[v] = u;\n        dfs1(v, u);\n        size[u] += size[v];\n        if(size[v] > size[hson[u]])\n            hson[u] = v;\n    }\n}\ninline void dfs2(int u, int Top)\n{\n    ++dfsnum;\n    dfn[u] = dfsnum;\n    top[u] = Top;\n    if(hson[u])\n        dfs2(hson[u], Top);\n    for(int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if(v == fa[u] || v == hson[u])\n            continue;\n        dfs2(v, v);\n    }\n}\ninline void update_chain(int u, int v)\n{\n    while(top[u] != top[v])\n    {\n        if(dep[top[u]] < dep[top[v]])\n            std::swap(u, v);\n        T.modify(1, dfn[top[u]], dfn[u], 1);\n        u = fa[top[u]];\n    }\n    if(dep[u] < dep[v])\n        std::swap(u, v);\n    T.modify(1, dfn[v], dfn[u], 1);\n}\ninline int query_chain(int u, int v)\n{\n    int ans = 0;\n    while(top[u] != top[v])\n    {\n        if(dep[top[u]] < dep[top[v]])\n            std::swap(u, v);\n        ans += T.query(1, dfn[top[u]], dfn[u]);\n        u = fa[top[u]];\n    }\n    if(dep[u] < dep[v])\n        std::swap(u, v);\n    ans += T.query(1, dfn[v], dfn[u]);\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &m);\n    for(int i = 2; i <= n; i++)\n    {\n        int u;\n        scanf(\"%d\", &u);\n        ++u;\n        add_edge(i, u);\n        add_edge(u, i);\n    }\n    dep[1] = 1;\n    dfs1(1, 0), dfs2(1, 1);\n    T.build(1, 1, n);\n    for(int i = 1; i <= m; i++)\n    {\n        int l, r, z;\n        scanf(\"%d%d%d\", &l, &r, &z);\n        l++, r++, z++;\n        q[i * 2 - 1] = (query){l - 1, z, i * 2 - 1};\n        q[i * 2] = (query){r, z, i * 2};\n    }\n    int now = 1;\n    std::sort(q + 1, q + 2 * m + 1, cmp);\n    for(int i = 1; i <= n; i++)\n    {\n        update_chain(1, i);\n        while(q[now].r < i)\n            ++now;\n        while(q[now].r == i)\n        {\n            ans[q[now].id] = query_chain(1, q[now].z);\n            ++now;\n        }\n    }\n    for(int i = 1; i <= m; i++)\n        printf(\"%d\\n\", (ans[i * 2] - ans[i * 2 - 1]) % mod);\n    return 0; \n}\n```",
        "postTime": 1552470766,
        "uid": 61966,
        "name": "little_sun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u53d1\u73b0\u6ca1\u6709lct\u7684\u9898\u89e3\uff0c\u660e\u660elct\u4e5f\u53ef\u4ee5\u94fe\u4e0a\u4fee\u6539+\u94fe\u4e0a\u6c42\u548c\u554a\u2026\u2026\n\n\u539f\u7406\u548c\u6811\u5256\u662f\u4e00\u6837\u7684\uff0c\u4e5f\u662f\u5c06\u201c\u6c42x\u4e0ey\u7684lca\u6df1\u5ea6\u201d\u8f6c\u5316\u4e3a\u201c\u6839\u8282\u70b9\u5230x\u7684\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u6743\u503c+1\uff0c\u6c42\u6839\u8282\u70b9\u5230y\u7684\u8def\u5f84\u4e0a\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u4e4b\u548c\u201d\uff0c\u7136\u540e\u5c06\u8be2\u95ee\u79bb\u7ebf\uff0c\u628a\u6c42\"l\u5230r\"\u8f6c\u5316\u4e3a\u6c42\"\uff081\u5230r\uff09-\uff081\u5230l-1\uff09\"\uff0c\u4ece1\u5f00\u59cb\u9010\u4e2a\u4fee\u6539\u6743\u503c\uff0c\u5f53\u6709\u4e00\u4e2a\u8be2\u95ee\u51fa\u73b0\u65f6\u5c31\u5bf9\u5f53\u524d\u72b6\u6001\u4e0b\u7684\u6811\u8fdb\u884c\u67e5\u8be2\u3002\uff08\u5176\u4ed6\u7684\u9898\u89e3\u4e5f\u90fd\u8bf4\u7684\u5f88\u6e05\u695a\u4e86\uff09\n\n\u597d\u50cf\u8981\u662f\u5f3a\u5236\u5728\u7ebf\u5c31gg\u6389\u4e86\u2026\u2026\u5f3a\u5236\u5728\u7ebf\u7684\u8bdd\u6811\u5256\u4e5f\u8bb8\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\uff1f\n\n\u867d\u8bf4\u662fO(nlogn)\uff0c\u4f46\u662f\u7531\u4e8e\u5e38\u6570\u5de8\u5927\uff0c\u6548\u7387\u8ddf\u6811\u5256\u4e5f\u5dee\u4e0d\u591a\u3002\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define p 201314\nusing namespace std;\n\nint n,m,xi,yi;\nint fa[50010],ch[50010][2],val[50010],sum[50010],rev[50010],lazy[50010],size[50010],qz[50010];\nlong long ans[50010];\nstruct node{\n\tint pos,id,flag;\n\tbool operator <(const node d)const{return pos<d.pos;}\n}nd[100010];\n\ninline int isroot(int x){\n\treturn ch[fa[x]][0]==x || ch[fa[x]][1]==x;\n}\n\ninline void push_up(int x){\n\tsum[x]=sum[ch[x][0]]+sum[ch[x][1]]+val[x];\n\tsize[x]=size[ch[x][0]]+size[ch[x][1]]+1;\n}\n\ninline void push_down(int x){\n\tif(rev[x]){\n\t\trev[ch[x][0]]^=1;rev[ch[x][1]]^=1;swap(ch[x][0],ch[x][1]);rev[x]=0;\n\t}\n\tif(lazy[x]){\n\t\tif(ch[x][0]){\n\t\t\tlazy[ch[x][0]]+=lazy[x];sum[ch[x][0]]+=lazy[x]*size[ch[x][0]];val[ch[x][0]]+=lazy[x];\n\t\t}\n\t\tif(ch[x][1]){\n\t\t\tlazy[ch[x][1]]+=lazy[x];sum[ch[x][1]]+=lazy[x]*size[ch[x][1]];val[ch[x][1]]+=lazy[x];\n\t\t}\n\t\tlazy[x]=0;\n\t}\n}\n\nvoid push(int x){\n\tif(isroot(x))push(fa[x]);push_down(x);\n}\n\ninline void rotate(int x){\n\tint y=fa[x],z=fa[y],c=ch[y][1]==x;\n\tif(isroot(y))ch[z][ch[z][1]==y]=x;fa[x]=z;ch[y][c]=ch[x][c^1];\n\tif(ch[x][c^1])fa[ch[x][c^1]]=y;fa[y]=x;ch[x][c^1]=y;\n\tpush_up(y);\n}\n\ninline void splay(int x){\n\tpush(x);while(isroot(x)){\n\t\tint y=fa[x],z=fa[y];\n\t\tif(isroot(y)){\n\t\t\t(ch[y][1]==x)==(ch[z][1]==y)?rotate(y):rotate(x);\n\t\t}\n\t\trotate(x);\n\t}push_up(x);\n}\n\ninline void access(int x){\n\tfor(int y=0;x;x=fa[y=x]){\n\t\tsplay(x);ch[x][1]=y;push_up(x);\n\t}\n}\n\ninline void makeroot(int x){\n\taccess(x);splay(x);rev[x]^=1;\n} \n\ninline void split(int x,int y){\n\tmakeroot(x);access(y);splay(y);\n}\n\nint main(){\n\tscanf(\"%d %d\",&n,&m);size[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tscanf(\"%d\",&xi);fa[i]=xi+1;size[i]=1;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&nd[(i<<1)+1].pos);nd[(i<<1)+1].id=i+1;nd[(i<<1)+1].flag=-1;\n\t\tscanf(\"%d\",&nd[(i<<1)+2].pos);nd[(i<<1)+2].id=i+1;nd[(i<<1)+2].flag=1;scanf(\"%d\",&qz[i+1]);qz[i+1]++;nd[(i<<1)+2].pos++;\n\t}sort(nd+1,nd+(m<<1)+1);int id=0;\n\tfor(int i=1;i<=(m<<1);i++){\n\t\twhile(id<nd[i].pos){\n\t\t\tid++;\n\t\t\tsplit(1,id);val[id]++;sum[id]+=size[id];lazy[id]++;\n\t\t}\n\t\tsplit(1,qz[nd[i].id]);ans[nd[i].id]+=nd[i].flag*sum[qz[nd[i].id]];\n\t}for(int i=1;i<=m;i++)printf(\"%lld\\n\",((ans[i]%p)+p)%p);\n}\n```",
        "postTime": 1547906735,
        "uid": 82611,
        "name": "PurpleWonder",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "## \u89e3\u9898\u6784\u601d\n\n### \u6280\u80fd\u50a8\u5907\n1.\u6811\u94fe\u5256\u5206\n\n2.LCA\n\n### \u7ed3\u8bba\n\n\u2211 \nl\u2264i\u2264r\n\u200b\t dep[LCA(i,z)]\n\u7684\u503c\uff1a\n\nl<=i<=r\n\n\u5c06i\u5230\u6839\u8282\u70b9\u6240\u6709\u7684\u70b9\u6743\u503c\u52a01\n\n\u7ed3\u679c\u5c31\u662fz\u8282\u70b9\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84\u548c\n\n\u8bc1\u660e\uff1a\n\n\u5f88\u660e\u663e\uff0c\u5f53r=l+1\u65f6\uff0c\u53ef\u4ee5\u753b\u56fe\u8f7b\u677e\u8bc1\u660e\n\n\u63a5\u7740\u901a\u8fc7\u6570\u5b66\u5f52\u7eb3\u6cd5\uff0c\u53ef\u8bc1\u660e\u8be5\u7ed3\u8bba\n\n### \u89e3\u9898\u601d\u8def\n\n1.\u8bfb\u5165\u5efa\u6811\n\n2.\u8be2\u95ee\u79bb\u7ebf\n\n3.\u6839\u636e\u7aef\u70b9\u6392\u5e8f\n\n4.\u4f9d\u6b21\u52a0\u5165\u6bcf\u4e2a\u8282\u70b9\n\n5.\u901a\u8fc7\u5dee\u5206\u76f8\u51cf\u5f97\u51fa\u7ed3\u679c\n\n6.\u7ec4\u7ec7\u8f93\u51fa\n\n#### ps.\u6700\u597d\u628a\u8282\u70b9\u7f16\u53f7+1\uff0c\u8fd9\u6837\u53ef\u907f\u514d0\u8282\u70b9\u7684\u5b58\u5728\n\n\n\n------------\n\n## Code\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#define MAXN 50005\nusing namespace std;\n\nint const mod=201314;\nvector<int>G[MAXN];\n\n//dfs\nint dep[MAXN],fa[MAXN],size[MAXN],son[MAXN];\nint top[MAXN],idx[MAXN],dfn=0;\n\nvoid dfs1(int u,int father,int depth)\n{\n    dep[u]=depth;\n    fa[u]=father;\n    size[u]=1;\n    int maxs=-1;\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i];\n        if(v==fa[u])continue;\n        dfs1(v,u,depth+1);\n        size[u]+=size[v];\n        if(size[v]>maxs)maxs=size[v],son[u]=v;\n    }\n}\n\nvoid dfs2(int u,int chain)\n{\n    top[u]=chain;\n    idx[u]=++dfn;\n    if(!son[u])return;\n    dfs2(son[u],chain);\n    for(int i=0;i<G[u].size();i++)\n    {\n        int v=G[u][i];\n        if(v==fa[u]||v==son[u])continue;\n        dfs2(v,v);\n    }\n}\n\n//segment tree\nstruct tree{\n    int l,r;\n    tree *lson,*rson;\n    int sum;\n    int lazy;\n}pool[MAXN*2];\nint tot=0;\nvoid build(tree *node,int l,int r)\n{\n    node->l=l;\n    node->r=r;\n    node->sum=0;\n    node->lazy=0;\n    if(l==r)\n    {\n        return;\n    }\n    int m=(l+r)>>1;\n    node->lson=&pool[tot++];\n    node->rson=&pool[tot++];\n    build(node->lson,l,m);\n    build(node->rson,m+1,r);\n}\nvoid falazy(tree *node)\n{\n    if(node->lson)\n    {\n        node->lson->lazy+=node->lazy;\n        node->lson->sum+=node->lazy*(node->lson->r-node->lson->l+1);\n        node->lson->lazy%=mod;\n        node->lson->sum%=mod;\n    }\n    if(node->rson)\n    {\n        node->rson->lazy+=node->lazy;\n        node->rson->sum+=node->lazy*(node->rson->r-node->rson->l+1);\n        node->rson->lazy%=mod;\n        node->rson->sum%=mod;\n    }\n    node->lazy=0;\n    node->sum=(node->lson->sum+node->rson->sum)%mod;\n}\nvoid update(tree *node,int l,int r,int k)\n{\n    k%=mod;\n    if(l==node->l &&r==node->r)\n    {\n        node->lazy+=k;\n        node->sum+=(node->r-node->l+1)%mod*k;\n        node->sum%=mod;\n        node->lazy%=mod;\n        return;\n    }\n    falazy(node);\n    if(r<=node->lson->r)\n        update(node->lson,l,r,k);\n    else if(l>=node->rson->l)\n        update(node->rson,l,r,k);\n    else\n    {\n        update(node->lson,l,node->lson->r,k);\n        update(node->rson,node->rson->l,r,k);\n    }\n    node->sum=(node->lson->sum+node->rson->sum)%mod;\n}\nint query(tree *node,int l,int r)\n{\n    if(l==node->l && r==node->r)\n    {\n        return node->sum;\n    }\n    falazy(node);\n    if(r<=node->lson->r)\n        return query(node->lson,l,r);\n    if(l>=node->rson->l)\n        return query(node->rson,l,r);\n    return (query(node->lson,l,node->lson->r)+query(node->rson,node->rson->l,r))%mod;\n}\n\ntree *root=&pool[tot++];\n\n//dissection\nvoid add(int u,int v,int k)\n{\n    k%=mod;\n    while(top[u]!=top[v])\n    {\n        if(dep[top[u]]<dep[top[v]])swap(u,v);\n        update(root,idx[top[u]],idx[u],k);\n        u=fa[top[u]];\n    }\n    if(dep[u]>dep[v])swap(u,v);\n    update(root,idx[u],idx[v],k);\n}\n\nint ask(int u,int v)\n{\n    int res=0;\n    while(top[u]!=top[v])\n    {\n        if(dep[top[u]]<dep[top[v]])swap(u,v);\n        res+=query(root,idx[top[u]],idx[u]);\n        res%=mod;\n        u=fa[top[u]];\n    }\n    if(dep[u]>dep[v])swap(u,v);\n    res+=query(root,idx[u],idx[v]);\n    res%=mod;\n    return res;\n}\n\nstruct opt{\n    int id;\n    int z;\n    int f;\n    int pos;\n    bool operator<(const opt a)const\n    {\n        return this->pos<a.pos;\n    }\n};\n\nint main()\n{\n    //initialization\n    int n,q;\n    scanf(\"%d%d\",&n,&q);\n    for(int i=2;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        x++;\n        G[i].push_back(x);\n        G[x].push_back(i);\n    }\n    dfs1(1,-1,1);\n    dfs2(1,1);\n    build(root,1,n);\n\n    \n    //response\n    int cnt=0;\n    opt a[2*MAXN];\n    for(int i=1;i<=q;i++)\n    {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        z++;\n        a[++cnt].z=z;a[cnt].pos=x;a[cnt].id=i;a[cnt].f=-1;\n        a[++cnt].z=z;a[cnt].pos=y+1;a[cnt].id=i;a[cnt].f=1;\n    }\n    sort(a+1,a+cnt+1);\n    int j=1,i=1;\n    int ans[MAXN];\n    for(i=1;i<=cnt;i++)\n    {\n        while(j<=a[i].pos)\n            add(1,j++,1);\n        ans[a[i].id]+=ask(1,a[i].z)*a[i].f;\n    }\n    for(int i=1;i<=q;i++)\n        printf(\"%d\\n\",(ans[i]+mod)%mod);\n    return 0;\n}\n\n\n```\n",
        "postTime": 1528419530,
        "uid": 63925,
        "name": "joe19025",
        "ccfLevel": 0,
        "title": "\u6811\u94fe\u5256\u5206\u2014\u2014[LNOI2014]LCA"
    },
    {
        "content": "[BZOJ 4012 [HNOI2015]\u5f00\u5e97](https://blog.csdn.net/Ike940067893/article/details/88681935) \u7684\u5f31\u5316\u7248,\u79bb\u7ebf\u4e86,\u800c\u4e14\u6ca1\u6709\u8fb9\u6743(\u957f\u5ea6).\n\n\u4e24\u79cd\u505a\u6cd5(\u5728\u7ebf\u548c\u79bb\u7ebf)\n\u611f\u89c9\u6ca1\u6709\u4eba\u5199\u5728\u7ebf\u7684\u4e3b\u5e2d\u6811\u65b9\u6cd5\u554a...\u4e8e\u662f\u6211\u6765\u5199\u4e00\u5199\n\n# 1 \u6811\u5256+\u79bb\u7ebf+\u7ebf\u6bb5\u6811\n\u8fd9\u9053\u9898\u6c42\u7684\u662f\u4e00\u4e2a\u70b9$z$\u4e0e$[l,r]$\u5185\u6240\u6709\u70b9\u7684$lca$\u7684\u6df1\u5ea6\u4e4b\u548c.\u53ef\u4ee5\u53d1\u73b0,$dep[lca(u,v)]$\u5c31\u7b49\u4e8e**\u4ece$u$\u5230\u6839**\u4e0e**\u4ece$v$\u5230\u6839**\u7684\u8def\u5f84\u7684**\u4ea4\u96c6\u8def\u5f84**\u7684\u957f\u5ea6.\u90a3\u4e48\u53ea\u8981\u628a$[l,r]$\u6240\u6709\u70b9\u5230\u6839\u7684\u8def\u5f84\u6807\u8bb0\u4e86,\u7136\u540e\u7528$z$\u70b9\u5f80\u6839\u8dd1\u7edf\u8ba1\u7b54\u6848\u5c31\u884c\u4e86.\u8fd9\u6837\u7684\u8bdd\u5dee\u5206\u4e00\u4e0b,\u79bb\u7ebf\u5c31\u53ef\u4ee5\u5904\u7406\u4e86.\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(nlog^2n)$\n# CODE\n```cpp\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\n\ninline void read(int &num) {\n\tchar ch; int flg=1; while(!isdigit(ch=getchar()))if(ch=='-')flg=-flg;\n\tfor(num=0; isdigit(ch); num=num*10+ch-'0',ch=getchar()); num*=flg;\n}\nconst int MAXN = 50005;\nconst int mod = 201314;\n\nint n, tot, Q, dfn[MAXN], seq[MAXN], tmr, fir[MAXN], cnt;\nstruct edge { int to, nxt; }e[MAXN];\n\ninline void add(int u, int v) {\n\te[cnt] = (edge){ v, fir[u] }, fir[u] = cnt++;\n}\nint dep[MAXN], fa[MAXN], sz[MAXN], top[MAXN], son[MAXN];\nvoid dfs(int u) {\n\tdep[u] = dep[fa[u]] + (sz[u]=1);\n\tfor(int v, i = fir[u]; ~i; i = e[i].nxt) {\n\t\tdfs(v=e[i].to), sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\nvoid dfs2(int u, int tp) {\n\ttop[u] = tp; dfn[u] = ++tmr;\n\tif(son[u]) dfs2(son[u], tp);\n\tfor(int v, i = fir[u]; ~i; i = e[i].nxt)\n\t\tif((v=e[i].to) != son[u]) dfs2(v, v);\n}\n\nstruct node {\n\tint tim, x, id, flg;\n}q[MAXN<<1];\ninline bool cmp(const node &A, const node &B) { return A.tim < B.tim; }\nint ans[MAXN];\nint lz[MAXN<<2], sum[MAXN<<2];\ninline void upd(int i) { sum[i] = sum[i<<1] + sum[i<<1|1]; }\ninline void mt(int i, int l, int r, int mid) {\n\tif(lz[i]) {\n\t\t(lz[i<<1] += lz[i]) %= mod;\n\t\t(lz[i<<1|1] += lz[i]) %= mod;\n\t\t(sum[i<<1] += 1ll * lz[i] * (mid-l+1) % mod) %= mod;\n\t\t(sum[i<<1|1] += 1ll * lz[i] * (r-mid) % mod) %= mod;\n\t\tlz[i] = 0;\n\t}\n}\nvoid insert(int i, int l, int r, int x, int y) {\n\tif(l == x && r == y) {\n\t\t(lz[i] += 1) %= mod;\n\t\t(sum[i] += r-l+1) %= mod;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tmt(i, l, r, mid);\n\tif(y <= mid) insert(i<<1, l, mid, x, y);\n\telse if(x > mid) insert(i<<1|1, mid+1, r, x, y);\n\telse insert(i<<1, l, mid, x, mid), insert(i<<1|1, mid+1, r, mid+1, y);\n\tupd(i);\n}\nint query(int i, int l, int r, int x, int y) {\n\tif(l == x && r == y) return sum[i];\n\tint mid = (l + r) >> 1;\n\tmt(i, l, r, mid);\n\tint res = 0;\n\tif(y <= mid) res = query(i<<1, l, mid, x, y);\n\telse if(x > mid) res = query(i<<1|1, mid+1, r, x, y);\n\telse res = (query(i<<1, l, mid, x, mid) + query(i<<1|1, mid+1, r, mid+1, y)) % mod;\n\tupd(i);\n\treturn res;\n}\ninline void Modify(int x) {\n\twhile(x) insert(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]];\n}\ninline int Query(int x) {\n\tint res = 0;\n\twhile(x) (res += query(1, 1, n, dfn[top[x]], dfn[x])) %= mod, x = fa[top[x]];\n\treturn res;\n}\n\nint main() {\n\tread(n); read(Q);\n\tmemset(fir, -1, sizeof fir);\n\tfor(int i = 2; i <= n; ++i)\n\t\tread(fa[i]), ++fa[i], add(fa[i], i);\n\tdfs(1); dfs2(1, 1);\n\tfor(int i = 1, x, y, z; i <= Q; ++i) {\n\t\tread(x), read(y), read(z); ++x, ++y, ++z;\n\t\tq[++tot] = (node){ x-1, z, i, -1 }; //\u5dee\u5206\n\t\tq[++tot] = (node){  y , z, i,  1 };\n\t}\n\tsort(q + 1, q + tot + 1, cmp);\n\tint now = 0;\n\tfor(int i = 1; i <= tot; ++i) {\n\t\twhile(now < q[i].tim) Modify(++now);\n\t\t(ans[q[i].id] += q[i].flg * Query(q[i].x)) %= mod;\n\t}\n\tfor(int i = 1; i <= Q; ++i)\n\t\tprintf(\"%d\\n\", (ans[i]+mod)%mod);\n}\n```\n\n# 2 \u6811\u5256+\u5728\u7ebf+\u4e3b\u5e2d\u6811\n\u6cbf\u7528\u6cd51\u7684\u601d\u8def,\u76f4\u63a5\u5728\u4e3b\u5e2d\u6811\u4e0a\u627e$r$\u7684\u7ebf\u6bb5\u6811\u4e0e$l-1$\u7684\u7ebf\u6bb5\u6811\u76f8\u51cf\u5c31\u884c\u4e86.\u4f46\u662f\u4e3b\u5e2d\u6811\u4e0d\u80fd\u4e0b\u4f20\u6807\u8bb0,\u90a3\u4e48\u5c31\u628a\u6807\u8bb0\u6c38\u4e45\u5316.\u67e5\u8be2\u7684\u65f6\u5019\u5728\u4e3b\u5e2d\u6811\u4e0a\u4ece\u6839\u5f80\u4e0b\u8fb9\u8d70\u8fb9\u7edf\u8ba1.\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u540c\u6837\u662f$O(nlog^2n)$,\u5e38\u6570\u5de8\u5927...\u7a7a\u95f4\u590d\u6742\u5ea6\u4e5f\u662f$O(nlog^2n)$,\u5b9e\u6d4b\u5f00$100n$\u5c31\u80fd\u8fc7\u4e86\n# CODE\n```cpp\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long LL;\ntemplate<typename T>inline void read(T &num) {\n\tchar ch; int flg = 1;\n\twhile((ch=getchar())<'0'||ch>'9')if(ch=='-')flg=-flg;\n\tfor(num=0;ch>='0'&&ch<='9';num=num*10+ch-'0',ch=getchar());\n\tnum*=flg;\n}\nconst int MAXN = 50005;\nconst int mod = 201314;\nconst int MAXNN = MAXN*100;\nint n, q, A, fir[MAXN], cnt;\nstruct edge { int to, nxt; }e[MAXN];\ninline void add(int u, int v) {\n\te[cnt] = (edge){ v, fir[u] }, fir[u] = cnt++;\n}\n\nint son[MAXN], sz[MAXN], top[MAXN], tmr, dfn[MAXN], fa[MAXN];\nvoid dfs(int u) {\n\tsz[u] = 1;\n\tfor(int i = fir[u], v; ~i; i = e[i].nxt) {\n\t\tdfs(v=e[i].to), sz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\nvoid dfs2(int u, int tp) {\n\ttop[u] = tp; dfn[u] = ++tmr;\n\tif(son[u]) dfs2(son[u], tp);\n\tfor(int i = fir[u], v; ~i; i = e[i].nxt)\n\t\tif((v=e[i].to) != fa[u] && v != son[u])\n\t\t\tdfs2(v, v);\n}\nint ch[MAXNN][2], tim[MAXNN], tot, rt[MAXN], sum[MAXNN];\n\ninline void Newnode(int i, int p) { ch[i][0] = ch[p][0], ch[i][1] = ch[p][1], sum[i] = sum[p], tim[i] = tim[p]; }\n\nvoid modify(int &i, int l, int r, int L, int R) {\n\tNewnode(++tot, i);\n\tif(L == l && r == R) { (++tim[i = tot]) %= mod; return; }\n\t(sum[i = tot] += R-L+1) %= mod;\n\tint mid = (l + r) >> 1;\n\tif(R <= mid) modify(ch[i][0], l, mid, L, R);\n\telse if(L > mid) modify(ch[i][1], mid+1, r, L, R);\n\telse modify(ch[i][0], l, mid, L, mid), modify(ch[i][1], mid+1, r, mid+1, R);\n}\ninline void Modify(int &r, int x) { while(x) modify(r, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]; }\nint query(int i, int l, int r, int L, int R) {\n\tif(!i) return 0;\n\tint res = 1ll * (R-L+1) * tim[i] % mod;\n\tif(L == l && r == R) return (res + sum[i]) % mod;\n\tint mid = (l + r) >> 1;\n\tif(R <= mid) return (res + query(ch[i][0], l, mid, L, R)) % mod;\n\telse if(L > mid) return (res + query(ch[i][1], mid+1, r, L, R)) % mod;\n\treturn (res + query(ch[i][0], l, mid, L, mid) + query(ch[i][1], mid+1, r, mid+1, R)) % mod;\n}\nint Query(int r, int x) { int res = 0; while(x) (res += query(r, 1, n, dfn[top[x]], dfn[x])) %= mod, x = fa[top[x]]; return res; }\nint main () {\n\tread(n), read(q);\n\tmemset(fir, -1, sizeof fir);\n\tfor(int i = 2; i <= n; ++i)\n\t\tread(fa[i]), ++fa[i], add(fa[i], i);\n\tdfs(1), dfs2(1, 1);\n\tfor(int i = 1; i <= n; ++i) Modify(rt[i]=rt[i-1], i);\n\tint L, R, x;\n\twhile(q--) {\n\t\tread(L), read(R), read(x); ++L, ++R, ++x;\n\t\tprintf(\"%d\\n\", (Query(rt[R], x) - Query(rt[L-1], x) + mod) % mod);\n\t}\n}\n\n```\n",
        "postTime": 1553523296,
        "uid": 30433,
        "name": "Ark_",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011\u79bb\u7ebf\u7ebf\u6bb5\u6811/\u5728\u7ebf\u4e3b\u5e2d\u6811"
    },
    {
        "content": "\u8fa3\u9e21\u9898\u76ee\u5c45\u7136\u4e0d\u653e\u88f8\u7684\u5206\u5757\u8fc7\u53bb,\u8fd8\u597d\u6211\u6709 O2 \u4f18\u5316\u3002\n$dep[LCA(u,v)]=\\frac{dep[u]+dep[v]-dis(u,v)}{2}$\n\u628a\u5e8f\u5217\u5206\u5757 , \u6362\u6839dp\u9884\u5904\u7406\u6bcf\u4e00\u5757\u5230\u4efb\u610f\u4e00\u4e2a\u70b9\u7684\u8ddd\u79bb\u548c\u3002\n\u5c31\u6ca1\u4e86\u3002\n\u590d\u6742\u5ea6 $O(n\\sqrt n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<class T>inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}\ntypedef long long ll;\nconst int N=5e4+10;\nconst int mod=201314;\nstruct edge{int to,next;}a[N<<1];\nint head[N],cnt=0;\ninline void add(int x,int y){a[++cnt]=(edge){y,head[x]};head[x]=cnt;}\nint L,R;\ntemplate<class T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;}\ntemplate<class T>inline void Dec(T&x,int y){x-=y;if(x < 0 ) x+=mod;}\nll size[N],Sum[300][N],S[N],Sd[N];\nint bl[N];\nint n,m,block,now;\nnamespace LCA_WORK{\n\tint st[20][N<<1],I,dfn[N<<1],id[N],log[N<<1],dep[N];\n\tvoid dfs(int u,int fa){\n\t\tdfn[++I]=u;id[u]=I;st[0][I]=u;\n\t\tfor(int v,i=head[u];i;i=a[i].next){\n\t\t\tv=a[i].to;if(v==fa) continue;\n\t\t\tdep[v]=dep[u]+1;dfs(v,u);dfn[++I]=u;st[0][I]=u;\n\t\t}\n\t\treturn;\n\t}\n\tinline int CK(int u,int v){if(!u||!v) return u|v;return id[u]<id[v]? u:v;}\n\tvoid Pre_Work(){dep[1]=1;dfs(1,0);log[1]=0;\n\t\tfor(int i=2;i<=I;++i) if((1<<log[i-1])<i) log[i]=log[i-1]+1;else log[i]=log[i-1];\n\t\tfor(int k=1;k<=20;++k)\n\t\t\tfor(int i=1;i+(1<<k)-1<=I;++i)\n\t\t\t\tst[k][i]=CK(st[k-1][i],st[k-1][i+(1<<k-1)]);\n\t\treturn;\n\t}\n\tinline int LCA(int u,int v){\n\t\tif(u==v) return u;u=id[u],v=id[v];\n\t\tif(u>v) swap(u,v);int D=log[v-u+1]-1;\n\t\treturn CK(st[D][u],st[D][v-(1<<D)+1]);\n\t}\n\tinline int Dis(int u,int v){return (dep[u]+dep[v]-(dep[LCA(u,v)]<<1));}\n}using LCA_WORK::dep;using LCA_WORK::LCA;\nvoid dfs(int u,int fa){\n\tS[u]=0;if(u>=L&&u<=R) size[u]=1;else size[u]=0;\n\tfor(int v,i=head[u];i;i=a[i].next){\n\t\tv=a[i].to;if(v==fa) continue;\n\t\tdfs(v,u);size[u]+=size[v];S[u]+=S[v]+size[v];\n\t}\n\treturn;\n}\nvoid DP(int u,int fa){\n\tSum[now][u]=S[u];\n\tfor(int v,i=head[u];i;i=a[i].next){\n\t\tv=a[i].to;if(v==fa) continue;\n\t\tll SS=S[u],Si=size[u];SS-=size[v]+S[v];Si-=size[v];\n\t\tS[v]+=SS+Si;size[v]=size[u];DP(v,u);\n\t}\n\treturn;\n}\nvoid Solve(){dfs(1,0);DP(1,0);}\nint main()\n{\n\tinit(n),init(m);\n\tblock=500;bl[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tint f;init(f);++f;\n\t\tbl[i]=(i+block-1)/block;\n\t\tadd(f,i),add(i,f);\n\t}\n\tLCA_WORK::Pre_Work();for(int i=1;i<=n;++i) Sd[i]=Sd[i-1]+dep[i];\n\tfor(L=1,R=1;L<=n;L=R+1){while(bl[R+1]==bl[L]) ++R;now=bl[L];Solve();}\n\tfor(int i=1;i<=m;++i) {\n\t\tint l,r,z;ll ans=0;\n\t\tinit(l),init(r),init(z);++l,++r,++z;\n\t\tif(bl[l]==bl[r]) {while(l<=r) ans+=dep[LCA(l,z)],++l;printf(\"%lld\\n\",ans%mod);}\n\t\telse {\n\t\t\twhile(bl[l]==bl[l-1]) ans+=dep[LCA(l,z)],++l;\n\t\t\twhile(bl[r]==bl[r+1]) ans+=dep[LCA(r,z)],--r;\n\t\t\tif(l>r) {printf(\"%lld\\n\",ans%mod);continue;}\n\t\t\tll ret=Sd[r]-Sd[l-1];ret+=(ll)(r-l+1)*dep[z];l=bl[l],r=bl[r];\n\t\t\tfor(;l<=r;++l) ret-=Sum[l][z];ret>>=1;ans+=ret;\n\t\t\tprintf(\"%lld\\n\",ans%mod);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n```",
        "postTime": 1550580319,
        "uid": 47803,
        "name": "NeosKnight",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u7ecf\u5178\u7684\u8f6c\u5316\u6a21\u578b\u3002\n\n\u6c42lca\u6df1\u5ea6\u53ef\u4ee5\u8f6c\u5316\u4e3a\u70b9\u5230\u6839\u7684\u52a0\u6cd5\uff0c\u67e5\u8be2\u70b9\u5230\u6839\u7684\u503c\u3002\n\n\u79bb\u7ebf\u8be2\u95ee\uff0c\u7528\u524d\u7f00\u548c\u7684\u601d\u60f3\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\ninline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}\ninline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}\ninline void writeln(int x){write(x); puts(\"\");}\nconst int N=100005,mod=201314;\nstruct edge{\n\tint link,next;\n}e[N<<1];\nstruct qu{\n\tint flag,id,pos;\n}q[N];\nint n,tot,head[N],m,qq[N];\ninline void insert(int u,int v){\n\te[++tot]=(edge){v,head[u]}; head[u]=tot;\n}\ninline void init(){\n\tn=read(); m=read();\n\tfor (int i=2;i<=n;i++){\n\t\tint x=read()+1;\n\t\tif (x) insert(x,i);\n\t}\n\ttot=0;\n\tfor (int i=1;i<=m;i++){\n\t\tint l=read()+1,r=read()+1,x=read();\n\t\tqq[i]=x+1;\n\t\tq[++tot]=(qu){-1,i,l-1};\n\t\tq[++tot]=(qu){1,i,r};\n\t}\n} \nint top[N],num[N],tim,Pos[N],fa[N],size[N],heavy[N],dep[N];\nvoid dfs1(int u){\n\tdep[u]=dep[fa[u]]+1; size[u]=1;\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link;\n\t\tif (v!=fa[u]){\n\t\t\tfa[v]=u;\n\t\t\tdfs1(v);\n\t\t\tsize[u]+=size[v];\n\t\t\tif (!heavy[u]||size[v]>size[heavy[u]]){\n\t\t\t\theavy[u]=v;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs2(int u,int tp){\n\tnum[u]=++tim; Pos[tim]=u; top[u]=tp;\n\tif (heavy[u]){\n\t\tdfs2(heavy[u],tp);\n\t}\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link;\n\t\tif (v!=fa[u]&&v!=heavy[u]){\n\t\t\tdfs2(v,v);\n\t\t} \n\t}\n}\ninline bool cmp(qu A,qu B){\n\treturn A.pos<B.pos;\n}\nstruct node{\n\tint sum,lazy;\n}a[N<<2];\ninline void plus(int k,int x,int l,int r){\n\tint sz=r-l+1;\n\t(a[k].sum+=x*sz)%=mod;\n\t(a[k].lazy+=x)%=mod;\n}\ninline void pushdown(int k,int l,int mid,int r){\n\tif (a[k].lazy){\n\t\tplus(k<<1,a[k].lazy,l,mid); \n\t\tplus(k<<1|1,a[k].lazy,mid+1,r);\n\t\ta[k].lazy=0;\n\t}\n}\ninline void pushup(int k){a[k].sum=(a[k<<1].sum+a[k<<1|1].sum)%mod;}\nvoid update(int k,int l,int r,int x,int y){\n\tif (l==x&&r==y){\n\t\tplus(k,1,l,r);\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tpushdown(k,l,mid,r);\n\tif (mid>=y) update(k<<1,l,mid,x,y);\n\t\telse if (mid<x) update(k<<1|1,mid+1,r,x,y);\n\t\t\telse update(k<<1,l,mid,x,mid),update(k<<1|1,mid+1,r,mid+1,y);\n\tpushup(k);\n}\ninline void update(int x){\n\twhile (x){\n\t\tupdate(1,1,n,num[top[x]],num[x]);\n\t\tx=fa[top[x]];\n\t}\n}\ninline int query(int k,int l,int r,int x,int y){\n\tif (l==x&&r==y){\n\t\treturn a[k].sum;\n\t}\n\tint mid=(l+r)>>1;\n\tpushdown(k,l,mid,r);\n\tif (mid>=y) return query(k<<1,l,mid,x,y);\n\t\telse if (mid<x) return query(k<<1|1,mid+1,r,x,y);\n\t\t\telse return (query(k<<1,l,mid,x,mid)+query(k<<1|1,mid+1,r,mid+1,y))%mod;\n}\ninline int Qu(int x){\n\tint ans=0;\n\twhile (x){\n\t\t(ans+=query(1,1,n,num[top[x]],num[x]))%=mod;\n\t\tx=fa[top[x]];\n\t}\n\treturn ans;\n}\nint Ans[N];\t\ninline void solve(){\n\tdfs1(1);\n\tdfs2(1,1);\n\tsort(q+1,q+1+tot,cmp);\n\tint now=1;\n\twhile (!q[now].pos){\n\t\tnow++;\n\t}\n\tfor (int i=1;i<=n;i++){\n\t\tupdate(i); int ans;\n\t\twhile (q[now].pos==i){\n\t\t\t(Ans[q[now].id]+=Qu(qq[q[now].id])*q[now].flag+mod)%=mod;\n\t\t\tnow++;\n\t\t}\n\t}\n\tfor (int i=1;i<=m;i++){\n\t\twriteln(Ans[i]);\n\t}\n}\nint main(){\n\tinit();\n\tsolve();\n\treturn 0;\n}\n```",
        "postTime": 1531668917,
        "uid": 34444,
        "name": "\u5927\u83dc\u9e21fks",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "# P4211 [LNOI2014]LCA\n\n\u7ed9\u51fa\u4e00\u4e2an\u4e2a\u8282\u70b9\u7684\u6709\u6839\u6811\uff08\u7f16\u53f7\u4e3a0\u5230n-1\uff0c\u6839\u8282\u70b9\u4e3a0\uff09\u3002\u4e00\u4e2a\u70b9\u7684\u6df1\u5ea6\u5b9a\u4e49\u4e3a\u8fd9\u4e2a\u8282\u70b9\u5230\u6839\u7684\u8ddd\u79bb+1\u3002\n\u8bbedep[i]\u8868\u793a\u70b9i\u7684\u6df1\u5ea6\uff0cLCA(i,j)\u8868\u793ai\u4e0ej\u7684\u6700\u8fd1\u516c\u5171\u7956\u5148\u3002\n\u6709q\u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fal r z\uff0c\u6c42$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$\n\n------\n\n\u95ee\u9898\u53ef\u4ee5\u8f6c\u5316\u4e3a\u6c42\u70b9\u5230\u6839\u7684\u8ddd\u79bb+1\uff0c\u8be2\u95eel\u5230r\u7684\u7ed3\u70b9\u5230\u6839\u7684\u8ddd\u79bb\u548c\u3002\n\n\u8fd9\u76f8\u5f53\u4e8e\u662f\u5728\u6c42\u7ed3\u70b9\u5230\u6839\u7684\u70b9\u6743+1\u7684\u548c\u3002\n\n\u90a3\u4e48\u8be5\u600e\u4e48\u529e\u5462\uff1f\n\n\u663e\u7136\u6211\u4eec\u53ef\u4ee5\u79bb\u7ebf\u5f97\u5230\u6240\u6709\u7684\u8be2\u95ee\uff0c\u7136\u540e\u5c06\u5dee\u5206\u8be2\u95ee\uff0c\u4e5f\u5c31\u662f\u67e5\u8be2 $[1,r]-[1,l-1]$\n\n\u6211\u4eec\u53ef\u4ee5\u5728l-1\u548cr\u5904\u6253\u6807\u8bb0\uff0c\u7136\u540e\u904d\u5386\u6811\u7684\u7ed3\u70b9\u6709\u6807\u8bb0\u5c31\u6267\u884c\u67e5\u8be2\u64cd\u4f5c\u3002\n\n\u65b9\u4fbf\u8d77\u89c1\u6211\u4eec\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206\u6765\u7ef4\u62a4\uff0c\u65f6\u95f4\u590d\u6742\u5ea6n\u4e58\u4e0a\u4e00\u4e2aLog\u65b9n\u3002\n\n(\u5bf9\u4e86\u6211\u7684\u4ee3\u7801\u7279\u522b\u7384\u5b66\uff0c\u67e5\u8be2\u90e8\u5206\u5faa\u73af\u7248\u672c\u5728luogu\u4e0aT\u4e86\uff0c\u5728lojA\u4e86\uff0c\u9012\u5f52\u7248\u672c\u5728luoguA\u4e86\uff0c\u5728lojT\u4e86\uff01)\n\n(\u6211\u5bf9\u8fd9\u4efd\u4ee3\u7801\u9664\u4e86\u7f13\u7f13\u5730\u6253\u51fa\u4e00\u4e2a\u95ee\u53f7\u4e5f\u4e0d\u80fd\u8bf4\u4ec0\u4e48\u4e86)\n\n```cpp\n#pragma GCC diagnostic error \"-std=c++11\"\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#define IT vector < int >::iterator\n#define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i]\n#define CheckSize ((size[son[x]] < size[y]) && (son[x] = y))\n#define TCS TreeChainSplitting\n#define CFS ChainForwardStar\n#define PS ProblemSolver\n#define pii pair < int , int >\n#define pll pair < LL, LL >\n#define mid ((l + r) >> 1)\n#define mp make_pair\n#define fir first\n#define sec second\n#define pub push_back\n#define pob pop_back\n\nusing namespace std;\ntypedef long long LL;\n\n#define io_e '\\0'\n#define io_s ' '\n#define io_l '\\n'\n #define _DEBUG_ 1 // debug toggle\nnamespace Fast_IO {\n    #ifndef _DEBUG_\n        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n    #else\n        #define gc() getchar()\n    #endif\n    const int SIZ = 1 << 21 | 1;\n    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;\n    int fr;\n    inline void ioout() {\n        fwrite(obuff, 1, oS - obuff, stdout);\n        oS = obuff;\n    }\n    template <class Type>\n    inline void read(Type& x) {\n        x = 0;\n        Type y = 1;\n        for (c = gc(); (c > '9' || c < '0') && c ^ '-'; c = gc())\n            ;\n        c == '-' ? y = -1 : x = (c & 15);\n        for (c = gc(); c >= '0' && c <= '9'; c = gc()) x = x * 10 + (c & 15);\n        x *= y;\n    }\n    inline bool blank(char ch) { return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t'; }\n    inline void read(char* s) {\n        register char ch = gc();\n        for (; blank(ch); ch = gc())\n            ;\n        for (; !blank(ch); ch = gc()) *s++ = ch;\n        *s = 0;\n    }\n    inline void read(char& c) {\n        for (c = gc(); blank(c); c = gc())\n            ;\n    }\n    template <typename Type, typename... Args>\n    inline void read(Type& t, Args&... args) {\n        read(t), read(args...);\n    }\n    template <typename... Args>\n    inline void read(char* t, Args&... args) {\n        read(t), read(args...);\n    }\n    template <typename... Args>\n    inline void read(char& t, Args&... args) {\n        read(t), read(args...);\n    }\n    template <class Type>\n    inline void write(char lastChar, Type x) {\n        if (x < 0)\n            *oS++ = '-', x = -x;\n        if (x == 0)\n            *oS++ = '0';\n        while (x) fu[++fr] = x % 10 + '0', x /= 10;\n        while (fr) *oS++ = fu[fr--];\n        *oS++ = lastChar;\n        ioout();\n    }\n    inline void write(char lastChar, char x[]) {\n        for (register int i = 0; x[i]; ++i) *oS++ = x[i];\n        *oS++ = lastChar;\n        ioout();\n    }\n    inline void write(char lastChar, char x) {\n        *oS++ = x;\n        *oS++ = lastChar;\n        ioout();\n    }\n    template <typename Type, typename... Args>\n    inline void write(char midChar, Type t, Args... args) {\n        write(midChar, t), write(midChar, args...);\n    }\n}  // namespace Fast_IO\n\nusing Fast_IO::read;\nusing Fast_IO::write;\n\nconst int SIZE = 5e4 + 5;\nnamespace ChainForwardStar {\n\tconst int SIZE = ::SIZE;\n\tint tot_, Vert[SIZE];\n\tint Head[SIZE], Next[SIZE];\n\t\n\tvoid AddLine(int x, int y) {\n\t\tVert[++tot_] = y;\n\t\tNext[tot_] = Head[x];\n\t\tHead[x] = tot_;\n\t}\n} // namespace ChainForwardStar\n\nusing CFS::Head;\nusing CFS::Vert;\nusing CFS::Next;\nusing CFS::AddLine;\n\nnamespace TreeChainSplitting {\n\tconst int SIZE = ::SIZE;\n\tconst int MOD = 201314;\n\tint n, m, tot, d[SIZE];\n\tint fa[SIZE], size[SIZE];\n\tint son[SIZE], top[SIZE];\n\tint dfn[SIZE], rnk[SIZE];\n\tint ask[SIZE], ans[SIZE];\n\tvector < int > GFY[SIZE];\n\tvector < int > FI[SIZE];\n\tint sum[SIZE << 2], lf[SIZE << 2];\n\t\n\tvoid Prepare(int x) {\n\t\tsize[x] = 1, d[x] = d[fa[x]] + 1;\n\t\tfor (ForGraph)\n\t\t\tPrepare(y), size[x] += size[y], CheckSize;\n\t}\n\t\n\tvoid Prepare(int x, int tp) {\n\t\trnk[dfn[x] = ++tot] = x, top[x] = tp;\n\t\tif (son[x]) Prepare(son[x], tp);\n\t\tfor (ForGraph) if (y ^ son[x]) Prepare(y, y);\n\t}\n\t\n\t#define ls (k << 1)\n\t#define rs (k << 1 | 1)\n\t#define L_RECUR ls, l, mid, x, y\n\t#define R_RECUR rs, mid + 1, r, x, y\n\t#define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD,\t\t\t\t\t\\\n\t\t\t\t\t\t\t\tsum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k],\t\t\t\t\t\\\n\t\t\t\t\t\t\t\tlf[rs] += lf[k], lf[k] = 0\n\t#define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD\n\tvoid ModifyChain(int k, int l, int r, int x, int y) {\n\t\tif (l >= x && r <= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k];\n\t\telse {\n\t\t\tUpdateSons(k, l, r);\n\t\t\tif (mid >= x) ModifyChain(L_RECUR);\n\t\t\tif (mid < y) ModifyChain(R_RECUR);\n\t\t\tUpdateMessages(k);\n\t\t}\n\t}\n\t\n\tvoid ModifySubTree(int x) {\n\t\tif (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]);\n\t}\n\t\n\tint QueryChain(int k, int l, int r, int x, int y, int res = 0) {\n\t\tif (l >= x && r <= y) return sum[k];\n\t\tUpdateSons(k, l, r);\n\t\tif (mid >= x) res += QueryChain(L_RECUR, 0);\n\t\tif (mid < y) res += QueryChain(R_RECUR, 0);\n\t\treturn res;\n\t}\n\t\n\tint QuerySubTree(int x, int res = 0) { // luogu-only \n\t\tif (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res;\n\t}\n\t\n//\tint QuerySubTree(int x, int res = 0) { // loj-only\n//\t\twhile (x) {\n//\t\t\tres += QueryChain(1, 1, n, dfn[top[x]], dfn[x]);\n//\t\t\tx = fa[top[x]];\n//\t\t}\n//\t\treturn res;\n//\t}\n} // namespace TreeChainSplitting\n\nnamespace ProblemSolver {\n\tvoid main() {\n\t\tread(TCS::n), read(TCS::m);\n\t\tfor (int i = 2; i <= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i);\n\t\tTCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1);\n\t\tint L, R;\n\t\tfor (int i = 1; i <= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i];\n\t\tfor (int i = 1; i <= TCS::n; ++i) {\n\t\t\tTCS::ModifySubTree(i);\n\t\t\tfor (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]);\n\t\t\tfor (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]);\n\t\t}\n\t\tfor (int i = 1; i <= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD);\n\t}\n} // namespace ProblemSolver\n\nsigned main() {\n\tPS::main();\n}\n```",
        "postTime": 1580738793,
        "uid": 161849,
        "name": "cirnovsky",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "[Problem](https://www.luogu.org/problem/P4211)\n\nq\u4e2a\u8be2\u95ee\n\u7ed9\u51fa$l,r,z$\n\u6c42 $\\sum_{i=l}^{r} dep[Lca(i,z)]$\n\n$n,q \\leq 5*10^4$\n\n\u8fd9\u663e\u7136\u662f\u4e0d\u592a\u53ef\u505a\u7684 \u5982\u679c\u4f60\u8981\u7528 $nq \\log n$ \u7684\u505a\u6cd5\n\n\u8003\u8651\u79bb\u7ebf\u3002\n\n\u628a\u8be2\u95ee\u62c6\u6210 [$1,l-1$] , [$1,r$]\n\n\u6c42\u51fa\u6765\u7684\u7ed3\u679c\u81ea\u7136\u662f [$1,r$] - [$1,l-1$]\n\u6ca1\u6709\u56fa\u5b9a\u7684\u70b9\uff1f\u600e\u4e48\u529e\uff1f\n\n\u6211\u4eec\u60f3\u3002\u5047\u8bbe\u5f53\u524d\u8be2\u95ee\u70b9\u662f z \u9009\u5230 x \u8fd9\u4e2a\u70b9 ($l \\leq x \\leq r$)\n\n\u90a3\u4e48 `z \u548c x \u7684 LCA \u4e00\u5b9a\u5728 x \u548c 1 \u7684\u8def\u5f84\u4e0a`\n\u6240\u4ee5\u6bcf\u6b21 \u94fe\u4e0a\u4fee\u6539 \u628a x -> 1 \u7684\u8fd9\u6761\u94fe\u6574\u4f53\u52a01\n\n\u67e5\u8be2\u7684\u65f6\u5019 \u67e5\u8be2 1 ~ z \u7684\u94fe\u4e0a\u7684\u503c\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u81f3\u4e8e\u94fe\u4e0a\u6574\u4f53\u52a01 \u4ee5\u53ca\u94fe\u4e0a\u67e5\u8be2 \u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u89e3\u51b3\u3002\n\n\u5982\u679c\u6ca1\u80fd\u7406\u89e3 \u5f88\u62b1\u6b49\u6211\u83dc\u7684\u53ef\u601c\u53ea\u80fd\u653e\u4e00\u5f20~~\u6bd4\u8f83\u7279\u6b8a\u7684~~\u56fe \u8ba9\u8bfb\u8005\u81ea\u884c\u7406\u89e3\u4e86\u3002\u3002\n\n![](https://img2018.cnblogs.com/blog/1822694/201911/1822694-20191106123143670-1135375164.png)\n\u5982\u679c\u56fe\u51fa\u4e0d\u6765\u8bf7\u53bb [myblog](https://www.cnblogs.com/Isaunoya/p/11804422.html)\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std ;\nconst int MAXN = 5e4 + 10 ;\nstruct Query { int z , flg , id ; } ;\nvector < Query > v[MAXN] ;\nint n , Q ;\nstruct Edge { int v , nxt ; } e[MAXN << 1] ;\nint head[MAXN] , cnt = 0 ;\ninline void add(int u , int v) { e[++ cnt] = {v , head[u]} ; head[u] = cnt ; }\ntypedef int arr[MAXN] ;\narr sz , fa , d , son ;\ninline void dfs(int u) {\n  sz[u] = 1 ;\n  for(register int i = head[u] ; i ; i = e[i].nxt) {\n    int v = e[i].v ;\n    if(v == fa[u]) continue ;\n    fa[v] = u ;\n    d[v] = d[u] + 1 ;\n    dfs(v) ;\n    sz[u] += sz[v] ;\n    if(sz[v] > sz[son[u]]) son[u] = v ;\n  }\n}\narr top , id , seq ; int idx = 0 ;\ninline void dfs(int u , int t) {\n  top[u] = t ; id[u] = ++ idx ; seq[idx] = u ;\n  if(! son[u]) return ; dfs(son[u] , t) ;\n  for(register int i = head[u] ; i ; i = e[i].nxt) {\n    int v = e[i].v ;\n    if(v == fa[u] || v == son[u]) continue ;\n    dfs(v , v) ;\n  }\n}\nconst int Mod = 201314 ;\nint sum[MAXN << 2] , tag[MAXN << 2] ;\ninline void pushup(int rt) {\n  sum[rt] = sum[rt << 1] + sum[rt << 1 | 1] ;\n  if(sum[rt] >= Mod) sum[rt] -= Mod ;\n}\ninline void build(int l , int r , int rt) {\n  if(l == r) { sum[rt] = tag[rt] = 0 ; return ; }\n  int mid = l + r >> 1 ;\n  build(l , mid , rt << 1) ;\n  build(mid + 1 , r , rt << 1 | 1) ;\n  pushup(rt) ;\n}\ninline void pushdown(int rt , int l , int r) {\n  if(! tag[rt]) return ;\n  tag[rt << 1] += tag[rt] ;\n  tag[rt << 1 | 1] += tag[rt] ;\n  int mid = l + r >> 1 ;\n  sum[rt << 1] += tag[rt] * (mid - l + 1) ;\n  sum[rt << 1 | 1] += tag[rt] * (r - mid) ;\n  tag[rt] = 0 ;\n  return ;\n}\ninline void update(int a , int b , int l , int r , int rt) {\n  if(a <= l && r <= b) { sum[rt] += r - l + 1 ; tag[rt] ++ ; return ; }\n  pushdown(rt , l , r) ;\n  int mid = l + r >> 1 ;\n  if(a <= mid) update(a , b , l , mid , rt << 1) ;\n  if(b > mid) update(a , b , mid + 1 , r , rt << 1 | 1) ;\n  pushup(rt) ;\n}\ninline int query(int a , int b , int l , int r , int rt) {\n  if(a <= l && r <= b) { return sum[rt] ; }\n  pushdown(rt , l , r) ;\n  int mid = l + r >> 1 , ans = 0 ;\n  if(a <= mid) ans += query(a , b , l , mid , rt << 1) ;\n  if(b > mid) ans += query(a , b , mid + 1 , r , rt << 1 | 1) ;\n  return ans ;\n}\ninline void upd_range(int x , int y) {\n  int fx = top[x] , fy = top[y] ;\n  while(fx ^ fy) {\n    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n    update(id[fx] , id[x] , 1 , n , 1) ;\n    x = fa[fx] , fx = top[x] ;\n  }\n  if(d[x] > d[y]) swap(x , y) ;\n  update(id[x] , id[y] , 1 , n , 1) ;\n}\ninline int query_range(int x , int y) {\n  int fx = top[x] , fy = top[y] , ans = 0 ;\n  while(fx ^ fy) {\n    if(d[fx] < d[fy]) swap(x , y) , swap(fx , fy) ;\n    ans += query(id[fx] , id[x] , 1 , n , 1) ;\n    x = fa[fx] , fx = top[x] ;\n  }\n  if(d[x] > d[y]) swap(x , y) ;\n  return ans += query(id[x] , id[y] , 1 , n , 1) ;\n}\nint ans[MAXN] ;\nsigned main() {\n#ifdef _WIN64\n  freopen(\"0.in\" , \"r\" , stdin) ;\n#endif\n  ios_base :: sync_with_stdio(false) ;\n  cin.tie(nullptr) ;\n  cout.tie(nullptr) ;\n  cin >> n >> Q ;\n  for(int i = 2 ; i <= n ; i ++) { int fa ; cin >> fa ; add(i , ++ fa) ; add(fa , i) ; }\n  dfs(1) ; dfs(1 , 1) ; build(1 , n , 1) ;\n  for(int i = 1 ; i <= Q ; i ++) {\n    int l , r , z ;\n    cin >> l >> r >> z ; ++ l ; ++ r ; ++ z ;\n    v[l - 1].push_back({z , - 1 , i}) ; v[r].push_back({z , 1 , i}) ;\n  }\n  for(register int i = 1 ; i <= n ; i ++) {\n    upd_range(1 , i) ;\n    for( Query x : v[i] ) ans[x.id] = (ans[x.id] + x.flg * query_range(1 , x.z) + Mod) % Mod ;\n  }\n  for(register int i = 1 ; i <= Q ; i ++) cout << ans[i] << '\\n' ;\n  return 0 ;\n}\n```",
        "postTime": 1573014889,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    },
    {
        "content": "\u5176\u5b9e\u6ca1\u6709\u9ed1\u9898\u96be\u5ea6\uff1f~~\u9ed8\u9ed8\u70b9\u4e86\u9ed1\u8272\u6807\u7b7e~~ \u7801\u519c\u9898\uff01~~\u6811\u5256\u597d\u9898\uff01~~\n\n\u5f53\u7136\u601d\u7ef4\u4e0a\u4e5f\u662f\u86ee\u6e05\u65b0\u7684\n\n\u5c31\u662f\u8003\u8651\u6bcf\u4e2a\u6c42 LCA \u7684\u6df1\u5ea6\u6709\u4ec0\u4e48\u72ec\u7279\u7684\u65b9\u6cd5\n\n\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u4ee5\u4e0b\u7684\u53e6\u7c7b\u64cd\u4f5c\uff1a\n\n1. \u9996\u5148\u4ee4\u4e00\u4e2a\u70b9\u4e00\u8def\u8d70\u5230\u6839\u5e76\u6807\u8bb0\u6cbf\u8def\u7684\u70b9\uff08\u5176\u5b9e\u5c31\u662f\u6cbf\u8def\u7684\u70b9\u6743\u503c++\uff09\n\n2. \u7136\u540e\u53e6\u4e00\u4e2a\u70b9\u4e00\u8def\u8d70\u5230\u6839\uff0c\u7d2f\u52a0\u6cbf\u8def\u70b9\u7684\u6743\u503c\n\n\n\u8fd9\u6837\u7684\u64cd\u4f5c\u662f\u53ef\u4ee5\u652f\u6301 **\u591a\u4e2a\u70b9** \u4e0e **\u4e00\u4e2a\u70b9** \u4e4b\u95f4\u7684 LCA \u6df1\u5ea6\u6c42\u548c\u7684 \n\n>\u4f46\u662f\u7b97\u7b97\u590d\u6742\u5ea6\uff1f $O(n^2~\u00b7 q)$\uff0c\n\n>\u52a0\u4e0a\u7ebf\u6bb5\u6811\u4f18\u5316\uff1f $O(n~log~n~\u00b7 q)$\n\n\u90a3\u4e48\u6211\u4eec\u8003\u8651\u6c5f**\u6bcf\u4e2a\u8be2\u95ee\u62c6\u6210\u4e24\u4e2a\u8be2\u95ee**\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u8981\u6c42\u7684 $ANS$ \u5bf9\u4e8e\u540c\u4e00\u4e2a\u70b9 z \u6ee1\u8db3\u533a\u95f4\u52a0\u51cf\u7684\u6027\u8d28\uff0c\u5373\uff1a\n\n$$ANS=\\sum_{i=l}^r deep[LCA(i,z)]=\\sum_{i=1}^r deep[LCA(i,z)]-\\sum_{i=1}^{l-1} deep[LCA(i,z)]$$\n\n\u5176\u4e2d\u7684 $deep$ \u8868\u793a\u8282\u70b9\u6df1\u5ea6\n\n\n\u4e8e\u662f\u6211\u4eec\u7528\u7c7b\u4f3c\u524d\u7f00\u548c\uff08\u597d\u5427\u662f\u5dee\u5206\uff09\u7684\u601d\u8def\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a $O(n~ log~ n +~q~ log~ n)$ \u7684\u7b97\u6cd5\u5566\uff01 \uff08\u5f53\u7136\u662f\u7528\u4e86\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u6811\u5256\uff09\n\n\u7136\u540e\u5c31\u662f\u7801\u519c...\uff08\u6253\u4e86\u597d\u4e45...\uff09\n\n\u8fd8\u6709\u5c31\u662f\u4e0d\u8981\u5acc\u5f03\u538b\u884c\uff0c\u4ee3\u7801\u592a\u957f\u5b9e\u5728\u770b\u4e0d\u4e0b\u53bb\u7684...\uff08\u8fd9\u91cc\u53ea\u670980\u884c\u5427\uff09\n\n\u6bd5\u7adf\u538b\u884c\u7684\u90fd\u662f\u4e00\u4e9b\u7b80\u5355\u51fd\u6570\u4ee5\u53ca\u7ebf\u6bb5\u6811\u7684\u677f\u5b50\uff08\u90fd\u53ef\u4ee5\u81ea\u5df1\u6253\u7684QWQ\uff09\n\n```\n//by Judge\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int mod=201314;\nconst int M=5e4+3;\ntypedef int arr[M];\n#ifndef Judge\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n#endif\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline int read(){ int x=0,f=1; char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0'; return x*f;\n} char sr[1<<21],z[20];int C=-1,Z;\ninline void Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\ninline void print(int x,char chr='\\n'){\n    if(C>1<<20)Ot();if(x<0)sr[++C]=45,x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]=chr;\n} int n,Q,pat,cnt,tim,now; int sum[M<<2],col[M<<2];\narr head,siz,f,son,dep,top,dfn,ans1,ans2;\nstruct Edge{ int to,nxt; }e[M];\nstruct que{ int id,pos,z,flg;}q[M<<1];\ninline void add(int u,int v){e[++pat]={v,head[u]},head[u]=pat;}\ninline bool cmp(que& a,que& b){return a.pos<b.pos;}\ninline int Max(int a,int b){return siz[a]>siz[b]?a:b;}\n#define v e[i].to\nvoid dfs(int u){ dep[u]=dep[f[u]]+1,siz[u]=1;\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t\tdfs(v),siz[u]+=siz[v],son[u]=Max(son[u],v);\n}\nvoid dfs(int u,int tp){\n\tdfn[u]=++tim,top[u]=tp;\n\tif(son[u]) dfs(son[u],tp);\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t\tif(v^f[u]&&v^son[u]) dfs(v,v);\n}\n#undef v\n#define ls k<<1\n#define rs k<<1|1\n#define mid (l+r>>1)\n#define lson ls,l,mid\n#define rson rs,mid+1,r\ninline void color(int k,int l,int r,int co){sum[k]=(sum[k]+(r-l+1)*co)%mod,col[k]+=co;}\ninline void pushdown(int k,int l,int r){ if(!col[k]) return;color(lson,col[k]),color(rson,col[k]),col[k]=0;}\nvoid update(int k,int l,int r,int L,int R){ if(L>r||l>R) return;\n\tif(L<=l&&r<=R) return color(k,l,r,1); pushdown(k,l,r);\n\tupdate(lson,L,R),update(rson,L,R),sum[k]=(sum[ls]+sum[rs])%mod;\n}\nint query(int k,int l,int r,int L,int R){ if(L>r||l>R) return 0;\n\tif(L<=l&&r<=R) return sum[k]; pushdown(k,l,r);\n\treturn query(lson,L,R)+query(rson,L,R);\n}\ninline void update(int u,int v){\n\tfor(;top[u]^top[v];u=f[top[u]]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\tupdate(1,1,n,dfn[top[u]],dfn[u]);\n\t} if(dep[u]>dep[v]) swap(u,v);\n\tupdate(1,1,n,dfn[u],dfn[v]);\n}\ninline int query(int u,int v){ int s=0;\n\tfor(;top[u]^top[v];u=f[top[u]]){\n\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\ts+=query(1,1,n,dfn[top[u]],dfn[u]);\n\t} if(dep[u]>dep[v]) swap(u,v);\n\ts+=query(1,1,n,dfn[u],dfn[v]); return s%mod;\n}\nint main(){\n\tn=read(),Q=read();\n\tfor(int i=2;i<=n;++i)\n\t\tf[i]=read()+1,add(f[i],i);\n\t\n    for(int i=1,l,r,x;i<=Q;++i)\n\t\tl=read(),r=read()+1,x=read()+1,\n\t\tq[++cnt]={i,l,x,0},q[++cnt]={i,r,x,1};\n\tdfs(1),dfs(1,1),sort(q+1,q+1+cnt,cmp);\n    \n\tfor(int i=1;i<=cnt;++i){\n    \tfor(;now<q[i].pos;update(1,++now));\n\t\t(q[i].flg?ans1[q[i].id]:ans2[q[i].id])=query(1,q[i].z);\n\t}\n    for(int i=1;i<=Q;++i)\n    \tprint((ans1[i]-ans2[i]+mod)%mod);\n    return Ot(),0;\n}\n```",
        "postTime": 1552486837,
        "uid": 38576,
        "name": "J\u03bcdge",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4211 \u3010[LNOI2014]LCA\u3011"
    }
]