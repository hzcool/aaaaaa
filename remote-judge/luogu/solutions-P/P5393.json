[
    {
        "content": "\u600e\u4e48\u6e05\u4e00\u8272\u90fd\u5148\u60f3\u5230\u591a\u9879\u5f0f\u591a\u70b9\u6c42\u503c/\u5feb\u901f\u63d2\u503c\u5440\uff0c\u8fd9\u4e0d\u662f\u76f4\u63a5\u88f8\u7684\u5206\u6cbb NTT \u5417\uff08\u4e0d\u89e3\uff09\u3002  \n\u9996\u5148\uff0c\u6211\u4eec\u8981\u6c42\u7684\u662f\uff1a$\\displaystyle\\sum^{n-1}_{i=0} a_ix^{\\underline{i}}$\uff0c\u5176\u4e2d $x^{\\underline{i}}=\\displaystyle\\prod_{j=0}^{i-1}x-j\\ $\u3002  \n\u8bbe $g_{l,r}(x)=\\displaystyle\\prod_{i=l}^{r-1}x-i,f_{l,r}(x)=\\sum_{i=l}^{r-1}a_ig_{l,i}(x)$\uff0c\u663e\u7136\u7b54\u6848\u4e3a $f_{0,n}(x)\\ $\u3002  \n\u8bbe $mid\\in(l,r)$\uff0c\u5219 $g_{l,r}(x)=g_{l,mid}(x)g_{mid,r}(x),f_{l,r}(x)=f_{l,mid}(x)+f_{mid,r}(x)g_{l,mid}(x)\\ $\u3002  \n\n\u6700\u540e\uff0c$g_{i,i+1}=x-i,f_{i,i+1}(x)=a_i,g_{i,i}(x)=1,f_{i,i}(x)=0\\ $\u3002  \n\n\u76f4\u63a5\u5206\u6cbb\u5373\u53ef\uff0c\u590d\u6742\u5ea6 $\\Theta(n\\log^2n)$\u3002\n\n\u8fd8\u6709\u4e00\u4e2a\u5c0f\u4f18\u5316\uff1a$f_{l,r}(x),g_{l,r}(x)$ \u662f $r-l$ \u6b21\u7684\uff0c\u5728 $\\pmod {x^{2^k}}$ \u610f\u4e49\u4e0b\u4f1a\u521a\u597d\u591a\u4e00\u9879\u3002  \n\u8003\u8651\u5230\u5faa\u73af\u5377\u79ef\u7684\u6027\u8d28\uff0c\u591a\u51fa\u6765\u7684\u8fd9\u4e00\u9879\u5355\u72ec\u5904\u7406\uff0c\u4f1a\u5927\u5927\u964d\u4f4e\u5e38\u6570\u3002  \n\n\u8dd1\u5f97\u633a\u5feb\u7684\u4ee3\u7801\uff083.92s/10.57MB/3.55KB \uff09\n```cpp\n//this code is made by wangrx\n//2021.11.9 16:00\n#include<stdio.h>\n#include<string.h>\ntypedef unsigned long long ull;\ntypedef unsigned int word;\nconst word mod=998244353,nimod=29;\nconstexpr ull pow(word a,word b){//\u5feb\u901f\u5e42\n\tword ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1) ans=1ull*ans*a%mod;\n\t\ta=1ull*a*a%mod;\n\t}\n\treturn ans;\n}\n#define mx 18\n#define mx_ 17\nword root[1<<mx],inv[1<<mx],realid[1<<(mx+1)];\nword ni[nimod];\nstruct READ{\n\tchar c;\n\tinline READ(){//NTT \u9884\u5904\u7406\n\t\tconst ull num1=pow(3,(mod-1)>>mx);\n\t\tconst ull num2=pow(num1,mod-2);\n\t\troot[1<<mx_]=inv[1<<mx_]=ni[1]=1;\n\t\tni[2]=pow(2,mod-2),realid[1]=0;\n\t\tfor(word floor=1,i=2;floor<=mx;++floor){\n\t\t\tni[(1u<<floor)%nimod]=1ull*ni[(1u<<(floor-1))%nimod]*ni[2]%mod;\n\t\t\tfor(;i<1u<<(floor+1);++i)\n\t\t\t\trealid[i]=(i&1)<<(floor-1)|realid[i>>1];\n\t\t}\n\t\tfor(word i=(1<<mx_)+1;i<1<<mx;++i){\n\t\t\troot[i]=num1*root[i-1]%mod;\n\t\t\tinv[i]=num2*inv[i-1]%mod;\n\t\t}\n\t\tfor(word i=(1<<mx_)-1;i;--i)\n\t\t\troot[i]=root[i<<1],inv[i]=inv[i<<1];\n\t\tc=getchar();}\n\ttemplate<typename type>\n\tinline READ& operator >>(type& num){//\u5feb\u8bfb\n\t\twhile('0'>c||c>'9') c=getchar();\n\t\tfor(num=0;'0'<=c&&c<='9';c=getchar())\n\t\t\tnum=num*10+(c-'0');\n\t\treturn *this;\n\t}\n}cin;\n#define nttfor(size)\t\t\t\t\t\t\t\t\\\n\tfor(word floor=1;floor<(size);floor<<=1)\t\t\\\n\t\tfor(word head=0;head<(size);head+=floor<<1)\t\\\n\t\t\tfor(word i=0;i<floor;++i)//FFT \u5faa\u73af\n#define ntt(num,root) [&](){\t\t\t\t\t\t\t\\\n\tword num1=num[head|i],num2=num[head|i|floor];\t\t\\\n    num1+=(num2=1ull*num2*root[i|floor]%mod);   \t\t\\\n\tnum[head|i]=num1>=mod? num1-mod:num1;\t    \t\t\\\n\tnum1-=num2,num1+=mod-num2;                  \t\t\\\n\tnum[head|i|floor]=num1>=mod? num1-mod:num1;}()//\u8774\u8776\u53d8\u6362\n#define id(size,i) realid[(i)|(size)]//\u4e8c\u8fdb\u5236\u7ffb\u8f6c\u7684\u4e0b\u6807\n#define FOR(size) for(word i=0;i<(size);++i)\n\nword eax[1<<mx],ebx[1<<mx],ecx[1<<mx],edx[1<<mx];\nword ans[1<<mx],get[1<<mx];\nstruct poly{//\u591a\u9879\u5f0f\uff08\u5305\u542b\u5355\u72ec\u5904\u7406\u7684\u4f4d\u7f6e\uff09\n\tword *const num,end;\n\tinline poly(word *const in):\n\t\tnum(in),end(0){};\n\tinline poly(const poly &p):\n\t\tnum(p.num),end(p.end){}\n};\ninline void cdq(poly& ans,poly& get,const word size,const word id){\n\tif(size==1){\n\t\tans.end=0,get.end=1;\t//f_{i,i+1}(x)=a_i\n\t\tget.num[0]=id? mod-id:0;//g_{i,i+1}(x)=x-i\n\t\treturn;\n\t}\n\tpoly ans0=ans.num,ans1=ans.num+(size>>1);//f_{l,mid}(x),f_{mid,r}(x)\n\tpoly get0=get.num,get1=get.num+(size>>1);//g_{l,mid}(x),g_{mid,r}(x)\n\tcdq(ans0,get0,size>>1,id<<1);\n\tcdq(ans1,get1,size>>1,id<<1|1);\n\tmemcpy(edx,ans0.num,size<<1);\n\tFOR(size>>1){\n\t\tword head=id(size,i);\n\t\teax[head]=ans1.num[i];\n\t\tebx[head]=get0.num[i];\n\t\tecx[head]=get1.num[i];\n\t\thead=id(size,size>>1|i);\n\t\teax[head]=ebx[head]=ecx[head]=0;\n\t}\n\tconst word head=id(size,size>>1);\n\teax[head]=ans1.end;\n\tebx[head]=get0.end;\n\tecx[head]=get1.end;\n\tnttfor(size) ntt(eax,root),ntt(ebx,root),ntt(ecx,root);\n\tFOR(size){\n\t\tconst word head=id(size,i);\n\t\tans.num[head]=1ull*eax[i]*ebx[i]%mod;//f_{l,r}(x)=f_{l,mid}(x)+f_{mid,r}(x)g_{l,mid}(x)\n\t\tget.num[head]=1ull*ebx[i]*ecx[i]%mod;//g_{l,r}(x)=g_{l,mid}(x)g_{mid,r}(x)\n\t}\n\tnttfor(size) ntt(ans.num,inv),ntt(get.num,inv);\n\tword num1=ni[size%nimod],num2;\n\tFOR(size){\n\t\tans.num[i]=1ull*num1*ans.num[i]%mod;\n\t\tget.num[i]=1ull*num1*get.num[i]%mod;\n\t}\n\tans.end=1ull*ans1.end*get0.end%mod;\n\tget.end=1ull*get0.end*get1.end%mod;\n\tnum1=ans.end? mod-ans.end:0;\n\tnum2=get.end? mod-get.end:0;\n\tans.num[0]=(num1+ans.num[0])%mod;\n\tget.num[0]=(num2+get.num[0])%mod;//\u5355\u72ec\u5904\u7406\u672b\u9879\n\tFOR(size>>1) if((ans.num[i]+=edx[i])>=mod)\n\t\tans.num[i]-=mod;//+f_{l,mid}(x)\n\tif((ans.num[size>>1]+=ans0.end)>=mod)\n\t\tans.num[size>>1]-=mod;\n}\nint main(){\n\tword n,size;\n\tcin>>n;\n\tfor(word i=0;i<n;++i) cin>>ans[i];\n\tfor(size=1;size<n;size<<=1);\n\tpoly p0=ans,p1=get;\n\tcdq(p0,p1,size,0);\n\tfor(word i=0;i<n;++i) printf(\"%u \",ans[i]);\n\treturn 0;\n}\n\n```",
        "postTime": 1606361416,
        "uid": 104726,
        "name": "wangrx",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5393 \u3010\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f\u3011"
    },
    {
        "content": "# \u4e0b\u964d\u5e42\u591a\u9879\u5f0f\n\n*FFP, Falling Factorial Polynomial*\n\n## Poly to FFP\n\n~~ri\uff0c\u8fd9\u4e2a\u5361\u5e38~~\n\n\u5148\u5c06$x^i$\u7528$S_2$\u5c55\u5f00\u4e3a$x^{\\underline j}$\uff0c\u7136\u540e\u518d\u7528$x^i$\u5c55\u5f00$S_2$\uff0c\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u5377\u79ef\u5f0f\u5b50\uff0c\u5176\u4e2d\u6709\u4e00\u9879\u9700\u8981\u591a\u70b9\u6c42\u503c\u6765\u7b97\u3002\n\n```cpp\nil vector<int> PolytoFFP(const Poly &F)\n{\n\tint n=Size(F);\n\tvector<int> cha; cha.resize(n);\n\tfor(ri i=0; i<n; ++i) cha[i]=i;\n\tPoly R=Evaluation(F,cha),T(n);\n\tfor(ri i=0; i<n; ++i) R[i]=mul(R[i],ifac[i]);\n\tfor(ri i=0; i<n; ++i) T[i]=(i&1)?md-ifac[i]:ifac[i];\n\tMul(R,T);\n\treturn R.f;\n}\n```\n\n## FFP to Poly\n\n~~ri\uff0c\u8fd9\u4e2a\u66f4\u5361\u5e38~~\n\n\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u7684\u70b9\u503c\u5f88\u597d\u6c42\uff0c\u662f\u548c$e^x$\u5377\u79ef\u8d77\u6765\u7684\u5f62\u5f0f\uff0c\u6c42\u51fa$0-(n-1)$\u7684\u70b9\u503c\u540e\uff0c\u591a\u9879\u5f0f\u5feb\u901f\u63d2\u503c\u56de\u53bb\u5373\u53ef\u3002\n\n\u7531\u4e8e\u70b9\u503c\u662f\u8fde\u7eed\u7684\uff0c\u6240\u4ee5\u672c\u6765\u8981\u7528\u6d1b\u5fc5\u8fbe\u6cd5\u5219+\u591a\u70b9\u6c42\u503c\u5f97\u5230\u7684\u7b54\u6848\u53ef\u4ee5\u76f4\u63a5\u7528\u9636\u4e58\u6c42\u51fa\u6765\u3002\n\n```cpp\npair<Poly,Poly> Interpolation2(const int x,const int l,const int r,const vector<int> &Y)\n{\n\tif(l==r) return {{md-l,1},{mul(Y[l],mdinv(Eans[l]))}};\n\tgm;\n\tsolid ls=Interpolation2(x<<1,l,mid,Y),rs=Interpolation2(x<<1|1,mid+1,r,Y);\n\treturn {ls.fi*rs.fi,ls.fi *rs.se+ls.se*rs.fi};\n}\nil Poly FFPtoPoly(const vector<int> &F)\n{\n\tint n=Size(F);\n\tPoly G=ifac; Mul(G,F);\n\tfor(ri i=0; i<n; ++i) G[i]=mul(G[i],fac[i]);\n\tEans.resize(n);\n\tEans[0]=(n&1)?fac[n-1]:md-fac[n-1];\n\tfor(ri i=1; i<n; ++i) Eans[i]=mul(fac[i],((n-i)&1)?fac[n-i-1]:md-fac[n-i-1]);\n\treturn Interpolation2(1,0,n-1,G.f).se;\n}\n```",
        "postTime": 1559057934,
        "uid": 58302,
        "name": "i207M",
        "ccfLevel": 0,
        "title": "P5393 \u3010\u6a21\u677f\u3011\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f-\u89e3\u9898\u62a5\u544a"
    },
    {
        "content": "\u611f\u89c9\u5e73\u51e1\u3002\n\n\u6784\u9020 $n$ \u4e2a\u591a\u9879\u5f0f $g_{0\\dots n-1}$\uff0c$g_0=a_0,\\forall0<i<n,g_i=\\dfrac {a_i}{a_{i-1}}(x-i+1)$\u3002\n\n\u7b54\u6848\u5373\u4e3a $\\sum_{i=0}^{n-1}\\prod_{j=0}^i g_j$\u3002\u5206\u6cbb NTT \u5373\u53ef\u3002\n\n\u8bbe $f_{l\\dots r}$ \u4e3a $\\prod_{i=l}^r g_i$\uff0c$ans_{l\\dots r}$ \u4e3a\u533a\u95f4 $[l,r]$ \u7684\u7b54\u6848\u3002\n\n\u90a3\u4e48\u6709\n\n$$f_{l\\dots r}=f_{l\\dots mid}f_{mid+1\\dots r}$$\n\n$$ans_{l\\dots r}=f_{l\\dots mid}ans_{mid+1\\dots r}+ans_{l\\dots mid}$$\n\n```cpp\n#include<bits/stdc++.h>\n#define ull unsigned long long\n#define ll long long\n#define lll __int128\nusing namespace std;\nconst int G=3,mod=998244353;\nconst int inv2=mod+1>>1;\nconst int maxn=1e6;\null qpow(ull a,int p)\n{\n    ull mul=1;\n    for(;p;p>>=1)\n    {\n        if(p&1) mul=mul*a%mod;\n        a=a*a%mod;\n    }\n    return mul;\n}\null qpow(ull a,int p,int mod)\n{\n    ull mul=1;\n    for(;p;p>>=1)\n    {\n        if(p&1) mul=mul*a%mod;\n        a=a*a%mod;\n    }\n    return mul;\n}\nconst int inV=qpow(G,mod-2);\nvoid getmod(int &x)\n{\n    x+=(x<0)*mod,x-=(x>=mod)*mod;\n}\nvoid ntt(int a[],bool fl,int n)\n{\n    static ull f[maxn],w[maxn];\n    static int bt[maxn];\n    int i,j,p,l,t;\n    for(i=0;i<n;i++)\n        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);\n    ull po;\n    for(i=0;i<n;i++)\n        f[i]=a[bt[i]];\n    w[0]=1;\n    for(l=1;l<n;l*=2)\n    {\n        po=qpow(fl?inV:G,(mod-1)/(l*2));\n        for(i=1;i<l;i++)\n            w[i]=w[i-1]*po%mod;\n        for(i=0;i<n;i+=l*2)\n            for(j=0;j<l;j++)\n                t=w[j]*f[i|l|j]%mod,\n                f[i|l|j]=f[i|j]+mod-t,\n                f[i|j]+=t;\n        if(l==(1<<17))\n            for(i=0;i<n;i++)\n                f[i]%=mod;\n    }\n    if(fl)\n    {\n        po=qpow(n,mod-2);\n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod*po%mod;\n    }\n    else \n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod;\n}\nconst int mod2=104857601;\nvoid ntt2(int a[],bool fl,int n)\n{\n    static ull f[maxn],w[maxn];\n    static int bt[maxn];\n    int i,j,p,l,t,inV=qpow(G,mod2-2,mod2);\n    for(i=0;i<n;i++)\n        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);\n    ull po;\n    for(i=0;i<n;i++)\n        f[i]=a[bt[i]];\n    w[0]=1;\n    for(l=1;l<n;l*=2)\n    {\n        po=qpow(fl?inV:G,(mod2-1)/(l*2),mod2);\n        for(i=1;i<l;i++)\n            w[i]=w[i-1]*po%mod2;\n        for(i=0;i<n;i+=l*2)\n            for(j=0;j<l;j++)\n                t=w[j]*f[i|l|j]%mod2,\n                f[i|l|j]=f[i|j]+mod2-t,\n                f[i|j]+=t;\n        if(l==(1<<17))\n            for(i=0;i<n;i++)\n                f[i]%=mod2;\n    }\n    if(fl)\n    {\n        po=qpow(n,mod2-2,mod2);\n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod2*po%mod2;\n    }\n    else \n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod2;\n}\nconst int mod3=136314881;\nvoid ntt3(int a[],bool fl,int n)\n{\n    static ull f[maxn],w[maxn];\n    static int bt[maxn];\n    int i,j,p,l,t,inV=qpow(G,mod3-2,mod3);\n    for(i=0;i<n;i++)\n        bt[i]=(bt[i/2]/2)|((i&1)?n/2:0);\n    ull po;\n    for(i=0;i<n;i++)\n        f[i]=a[bt[i]];\n    w[0]=1;\n    for(l=1;l<n;l*=2)\n    {\n        po=qpow(fl?inV:G,(mod3-1)/(l*2),mod3);\n        for(i=1;i<l;i++)\n            w[i]=w[i-1]*po%mod3;\n        for(i=0;i<n;i+=l*2)\n            for(j=0;j<l;j++)\n                t=w[j]*f[i|l|j]%mod3,\n                f[i|l|j]=f[i|j]+mod3-t,\n                f[i|j]+=t;\n        if(l==(1<<17))\n            for(i=0;i<n;i++)\n                f[i]%=mod3;\n    }\n    if(fl)\n    {\n        po=qpow(n,mod3-2,mod3);\n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod3*po%mod3;\n    }\n    else \n        for(i=0;i<n;i++)\n            a[i]=f[i]%mod3;\n}\nvoid fkyou(int a[],int b[],int n)\n{\n    for(int i=0;i<n;i++)\n        a[i]=1ll*a[i]*b[i]%mod;\n}\nvoid mul(int a[],int b[],int l)\n{\n    static int cpy[maxn];\n    int n,i;\n    for(n=1;n<l;n*=2);\n    memcpy(cpy,b,n*4);\n    ntt(a,0,n),ntt(cpy,0,n);\n    for(i=0;i<n;i++)\n        a[i]=1ll*a[i]*cpy[i]%mod;\n    ntt(a,1,n);\n    memset(cpy,0,l*4);\n    memset(a+l,0,(n-l)*4);\n}\nvoid mul(int a[],int b[],int l,int m)\n{\n    static int cpy[maxn];\n    int n,i;\n    for(n=1;n<l*2;n*=2);\n    memcpy(cpy,b,m*4);\n    ntt(a,0,n),ntt(cpy,0,n);\n    for(i=0;i<n;i++)\n        a[i]=1ll*a[i]*cpy[i]%mod;\n    ntt(a,1,n);\n    memset(cpy,0,l*4);\n    memset(a+l,0,(n-l)*4);\n}\nvoid mul2(int a[],int b[],int l)\n{\n    static int cpy[maxn];\n    int n,i;\n    for(n=1;n<l;n*=2);\n    memcpy(cpy,b,n*4);\n    ntt2(a,0,n),ntt2(cpy,0,n);\n    for(i=0;i<n;i++)\n        a[i]=1ll*a[i]*cpy[i]%mod2;\n    ntt2(a,1,n);\n    memset(cpy,0,l*4);\n    memset(a+l,0,(n-l)*4);\n}\nvoid mul3(int a[],int b[],int l)\n{\n    static int cpy[maxn];\n    int n,i;\n    for(n=1;n<l;n*=2);\n    memcpy(cpy,b,n*4);\n    ntt3(a,0,n),ntt3(cpy,0,n);\n    for(i=0;i<n;i++)\n        a[i]=1ll*a[i]*cpy[i]%mod3;\n    ntt3(a,1,n);\n    memset(cpy,0,l*4);\n    memset(a+l,0,(n-l)*4);\n}\nint read()\n{\n    int s=0,w=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();\n    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n    return s*w;\n}\nvoid ginv(int a[],int l)\n{\n    static int b[maxn],b2[maxn],f[maxn];\n    int n,w,i;\n    for (n=1;n<l*2;n*=2);\n    b[0]=qpow(a[0],mod-2);\n    for(w=2;w<=n;w*=2)\n    { \n        memcpy(b2,b,w/2*4),memcpy(f,a,w*4);\n        ntt(b,0,w*2),fkyou(b,b,w*2);\n        ntt(f,0,w*2),fkyou(b,f,w*2);\n        ntt(b,1,w*2);\n        memset(b+w,0,w*4);\n        for(i=0;i<w;i++)\n            b[i]=(b2[i]*2-b[i]+mod)%mod;\n    }\n    memcpy(a,b,l*4);\n    memset(b,0,n*2*4);\n    memset(b2,0,n*2*4);\n    memset(f,0,n*2*4);\n}\nvoid der(int a[],int n)\n{\n    for(int i=1;i<n;i++)\n        a[i-1]=1ll*a[i]*i%mod;\n    a[n-1]=0;\n}\nvoid ber(int a[],int n)\n{\n    static int inv[maxn];\n    int i;\n    inv[1]=1;\n    for(i=2;i<=n;i++)\n        inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n    for(i=n;i;i--)\n        a[i]=1ll*a[i-1]*inv[i]%mod;\n    a[0]=0;\n}\nvoid gln(int a[],int l)\n{\n    static int b[maxn];\n    memcpy(b,a,l*4);\n    ginv(b,l);\n    der(a,l);\n    mul(a,b,l);\n    ber(a,l-1);\n    memset(b,0,l*4);\n}\nvoid gexp(int a[],int l)\n{\n    static int b[maxn],b2[maxn];\n    int n,w,i;\n    for(n=1;n<l;n*=2);\n    b[0]=1;\n    for(w=2;w<=n;w*=2)\n    {\n        memcpy(b2,b,w/2*4),gln(b2,w);\n        for(i=0;i<w;i++)\n            b2[i]=(a[i]-b2[i]+!i+mod)%mod;\n        mul(b,b2,w);\n    }\n    memcpy(a,b,l*4);\n    memset(b,0,n*4),memset(b2,0,n*4);\n}\nvoid gsqrt(int a[],int l)\n{\n    gln(a,l);\n    for(int i=0;i<l;i++)\n        a[i]=1ll*a[i]*inv2%mod;\n    gexp(a,l);\n}\nvoid gqpow(int a[],int l,int k)\n{\n    gln(a,l);\n    for(int i=0;i<l;i++)\n        a[i]=1ll*a[i]*k%mod;\n    gexp(a,l);\n}\nvoid gdiv(int a[],int b[],int n,int m)\n{\n    static int a2[maxn],b2[maxn];\n    int len=n-m+1,i;\n    reverse(b,b+m);\n    memcpy(b2,b,len*4);\n    reverse(b,b+m);\n    reverse(a,a+n);\n    memcpy(a2,a,len*4);\n    reverse(a,a+n);\n    ginv(b2,len);\n    mul(b2,a2,len);\n    reverse(b2,b2+len),\n    mul(b,b2,n);\n    for(i=0;i<m-1;i++)\n        b[i]=(a[i]-b[i]+mod)%mod;\n    memcpy(a,b2,len*4);\n    memset(a+len,0,n-len<<2);\n    memset(b+m-1,0,len*4); \n}\nint fac[maxn],inv[maxn];\nvoid init(int n)\n{\n    int i;\n    fac[0]=1;\n    for(i=1;i<=n;i++)\n        fac[i]=1ll*fac[i-1]*i%mod;\n    inv[n]=qpow(fac[n],mod-2);\n    for(i=n;i>=1;i--)\n        inv[i-1]=1ll*inv[i]*i%mod;\n}\nconst int modinv[]={590430925,656386,54835507};\nlll CRT(int a[],int mod[])\n{\n    int i;\n    lll mul=1,ans=0;\n    for(i=0;i<3;i++)\n        ans=(ans+mul/mod[i]*a[i]*modinv[i])%mul;\n    return ans;\n}\nvoid gmul(int a[],int b[],int n,int MOD)\n{\n    int mod[]={998244353,104857601,136314881},i,j,c[3];\n    static int res[3][maxn];\n    memcpy(res[0],a,n*4),\n    mul(res[0],b,n);\n    memcpy(res[1],a,n*4),\n    mul2(res[1],b,n);\n    memcpy(res[2],a,n*4),\n    mul3(res[2],b,n);\n    for(i=0;i<n;i++)\n    {\n        for(j=0;j<3;j++) c[j]=res[j][i];\n        a[i]=CRT(c,mod)%MOD;\n    }\n}\nint a[maxn];\nint t[maxn*20],*f[maxn],*top=t;\nint t2[maxn*20],*f2[maxn],*top2=t2;\n#define ls w<<1\n#define rs ls|1\nvoid solve(int w,int l,int r)\n{\n\tif(l==r) \n\t{\n\t\tf[w]=top,f2[w]=top2;\n\t\tif(l)\n\t\t\tf[w][1]=f2[w][1]=1ll*a[l]*qpow(a[l-1],mod-2)%mod,f[w][0]=f2[w][0]=(mod-f[w][1])*(l-1ll)%mod;\n\t\telse f[w][0]=f2[w][0]=a[0];\n\t\ttop+=3,top2+=3;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tsolve(ls,l,mid),solve(rs,mid+1,r);\n\tf[w]=top,f2[w]=top2;\n\tmemcpy(f[w],f[ls],(mid-l+2)*4);\n\tmul(f[w],f[rs],r-l+2,r-mid+1);\n\tmemcpy(f2[w],f[ls],(mid-l+2)*4);\n\tmul(f2[w],f2[rs],r-l+2,r-mid+1);\n\tfor(int i=0;i<mid-l+2;i++)\n\t\tgetmod(f2[w][i]+=f2[ls][i]);\n\ttop+=r-l+3,top2+=r-l+3;\n}\nint main()\n{\n\tint n=read(),i;\n\tfor(i=0;i<n;i++)\n\t\ta[i]=read();\n\tsolve(1,0,n-1);\n\tfor(i=0;i<n;i++)\n\t\tprintf(\"%d \",f2[1][i]);\n}\n```\n",
        "postTime": 1655272436,
        "uid": 203623,
        "name": "Ntokisq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5393 \u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P5393)\n# \u9898\u76ee\u5927\u610f\n\u7ed9\u51fa\u4e00\u4e2a\u4e0b\u964d\u5e42\u591a\u9879\u5f0f$F(x)=\\sum_{i=0}^{n-1} a_ix^{\\underline{i}}$\uff0c\u6c42\u4e00\u4e2a\u666e\u901a\u591a\u9879\u5f0f$G(x)$\u4f7f\u5f97$G(x)=F(x)$\u3002\n\n$n\\le 2\\times 10^5$\n# \u601d\u8def\n\u4e00\u4e2a\u975e\u5e38$\\texttt {naive}$\u7684\u60f3\u6cd5\u5c31\u662f\u6211\u4eec\u76f4\u63a5\u4e58\u4e0a$e^x$\u8f6c\u6362\u6210\u70b9\u503c$\\texttt{EGF}$\uff0c\u7136\u540e\u518d\u591a\u9879\u5f0f\u5feb\u901f\u63d2\u503c\u63d2\u56de\u53bb\u3002\n\n\u540c\u65f6\uff0c\u6211\u4eec\u53d1\u73b0\u70b9\u503c\u662f\u8fde\u7eed\u7684\uff0c\u4e8e\u662f\uff0c\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u591a\u9879\u5f0f\u591a\u70b9\u6c42\u503c\u548c\u591a\u9879\u5f0f\u53d6\u6a21\u4e86\u3002\n\n\u6700\u7ec8\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$\\Theta(n\\log^2n)$\u3002\n# $\\texttt{Code}$\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) ((int)x.size())\n#define Int register int\n#define mod 998244353\n#define ll long long\n#define MAXN 2000005\n\nint mul (int a,int b){return 1ll * a * b % mod;}\nint dec (int a,int b){return a >= b ? a - b : a + mod - b;}\nint add (int a,int b){return a + b >= mod ? a + b - mod : a + b;}\nint qkpow (int a,int k){\n\tint res = 1;for (;k;k >>= 1,a = 1ll * a * a % mod) if (k & 1) res = 1ll * res * a % mod;\n\treturn res;\n}\nint inv (int x){return qkpow (x,mod - 2);}\n\ntypedef vector <int> poly;\n\nint w[MAXN],rev[MAXN];\n\nvoid init_ntt (){\n\tint lim = 1 << 19;\n\tfor (Int i = 0;i < lim;++ i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << 18);\n\tint Wn = qkpow (3,(mod - 1) / lim);w[lim >> 1] = 1;\n\tfor (Int i = lim / 2 + 1;i < lim;++ i) w[i] = mul (w[i - 1],Wn);\n\tfor (Int i = lim / 2 - 1;i;-- i) w[i] = w[i << 1];\n}\n\nvoid ntt (poly &a,int lim,int type){\n#define G 3\n#define Gi 332748118\n\tstatic int d[MAXN];\n\tfor (Int i = 0,z = 19 - __builtin_ctz(lim);i < lim;++ i) d[rev[i] >> z] = a[i];\n\tfor (Int i = 1;i < lim;i <<= 1)\n\t\tfor (Int j = 0;j < lim;j += i << 1)\n\t\t\tfor (Int k = 0;k < i;++ k){\n\t\t\t\tint x = mul (w[i + k],d[i + j + k]);\n\t\t\t\td[i + j + k] = dec (d[j + k],x),d[j + k] = add (d[j + k],x);\n\t\t\t}\n\tfor (Int i = 0;i < lim;++ i) a[i] = d[i] % mod;\n\tif (type == -1){\n\t\treverse (a.begin() + 1,a.begin() + lim);\n\t\tfor (Int i = 0,Inv = inv (lim);i < lim;++ i) a[i] = mul (a[i],Inv);\n\t}\n#undef G\n#undef Gi \n}\n\npoly operator + (poly a,poly b){\n\ta.resize (max (SZ (a),SZ (b)));\n\tfor (Int i = 0;i < SZ (b);++ i) a[i] = add (a[i],b[i]);\n\treturn a;\n}\n\npoly operator * (poly a,poly b){\n\tint d = SZ (a) + SZ (b) - 1,lim = 1;while (lim < d) lim <<= 1;\n\ta.resize (lim),b.resize (lim);\n\tntt (a,lim,1),ntt (b,lim,1);\n\tfor (Int i = 0;i < lim;++ i) a[i] = mul (a[i],b[i]);\n\tntt (a,lim,-1),a.resize (d);\n\treturn a;\n}\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nint n,fac[MAXN],ifac[MAXN];\npoly fuck,III,D[MAXN << 2],DR[MAXN << 2];\n\nvoid divide (int i,int l,int r){\n\tif (l == r){\n\t\tDR[i].resize (2),DR[i][0] = mod - l,DR[i][1] = 1;\n\t\tD[i].resize (1),D[i][0] = (n - l) & 1 ? mod - mul (fuck[l],ifac[n - l]) : mul (fuck[l],ifac[n - l]);\n\t\treturn ;\n\t} \n\tint mid = (l + r) >> 1;divide (i << 1,l,mid),divide (i << 1 | 1,mid + 1,r);\n\tD[i] = DR[i << 1 | 1] * D[i << 1] + DR[i << 1] * D[i << 1 | 1];\n\tDR[i] = DR[i << 1] * DR[i << 1 | 1];\n}\n\nsigned main(){\n\tinit_ntt(),read (n),fuck.resize (n),III.resize (n + 1);\n\tfac[0] = 1;for (Int i = 1;i <= n;++ i) fac[i] = mul (fac[i - 1],i);\n\tifac[n] = inv (fac[n]);for (Int i = n;i;-- i) ifac[i - 1] = mul (ifac[i],i);\n\tfor (Int i = 0;i < n;++ i) read (fuck[i]),III[i] = ifac[i];III[n] = ifac[n];\n\tfuck = fuck * III,fuck.resize (n + 1);divide (1,0,n);\n\tfor (Int i = 0;i < n;++ i) write (D[1][i]),putchar (' ');putchar ('\\n');\n\treturn 0;\n}\n```",
        "postTime": 1595231194,
        "uid": 124781,
        "name": "Walking_Dead",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P5393 \u3010\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f\u3011"
    },
    {
        "content": "\u524d\u7f6e\uff1a[\u666e\u901a\u8f6c\u4e0b\u964d](https://www.luogu.com.cn/blog/220037/solution-p5383)\n\n\u4ece\u666e\u901a\u8f6c\u4e0b\u964d\u91cc\u9762\u5f97\u5230\u4e86\n\n$$b_k=\\sum_{t=0}^k\\frac{F(t)}{t!}\\frac{(-1)^{k-t}}{(k-t)!}$$\n\n\u8fd9\u663e\u7136\u662f\u4e00\u4e2a\u6807\u51c6\u7684\u5377\u79ef\uff0c\u4f46\u662f\u8fd9\u91cc\u9762\u6211\u4eec\u53ea\u6709 $b_k$\u3002\n\n\u5148\u6784\u9020 $\\frac{(-1)^{k-t}}{(k-t)!}$ \u5e8f\u5217\u4ee5\u53ca\u4e58\u6cd5\u9006\u5e42\u7ea7\u6570\uff0c\u628a $b_k$ \u548c\u9006\u5377\u79ef\u53ef\u4ee5\u5f97\u5230 $\\frac{F(t)}{t!}$ \u5bf9\u5e94\u5e8f\u5217\u3002\n\n\u5e8f\u5217\u6240\u6709\u5143\u7d20\u4e58 $t!$ \u5c31\u53ef\u4ee5\u5f97\u5230 $n+1$ \u4e2a $(t,F(t))$ \u6570\u5bf9\uff0c\u505a\u5feb\u901f\u63d2\u503c\u5373\u53ef\u3002\n\n\n\u4ee3\u7801\uff1a\n```cpp\n#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\",\"-ffast-math\")\n#pragma GCC optimize(\"-fno-math-errno\")\n#pragma GCC optimize(\"-funsafe-math-optimizations\")\n#pragma GCC optimize(\"-freciprocal-math\")\n#pragma GCC optimize(\"-fno-trapping-math\")\n#pragma GCC optimize(\"-ffinite-math-only\")\n#pragma GCC optimize(\"-fno-stack-protector\")\n#pragma GCC target (\"avx2\",\"sse4.2\",\"fma\")\n#include <immintrin.h>\n// writer: w33z8kqrqk8zzzx33\n#include <bits/stdc++.h>\nusing namespace std;\n\n// https://judge.yosupo.jp/submission/5253\n\nstruct IO {\n  static constexpr size_t buf_size = 1 << 18;\n  char buf_in[buf_size], buf_out[buf_size];\n  size_t pt_in = 0, pt_out = 0, tail_in = 0;\n  char strs[10000 * 4];\n  inline size_t num_digits(long long x) {\n    if (x >= (long long)1e9) {\n      if (x >= (long long)1e18) return 19;\n      if (x >= (long long)1e17) return 18;\n      if (x >= (long long)1e16) return 17;\n      if (x >= (long long)1e15) return 16;\n      if (x >= (long long)1e14) return 15;\n      if (x >= (long long)1e13) return 14;\n      if (x >= (long long)1e12) return 13;\n      if (x >= (long long)1e11) return 12;\n      if (x >= (long long)1e10) return 11;\n      return 10;\n    } else {\n      if (x >= (long long)1e8) return 9;\n      if (x >= (long long)1e7) return 8;\n      if (x >= (long long)1e6) return 7;\n      if (x >= (long long)1e5) return 6;\n      if (x >= (long long)1e4) return 5;\n      if (x >= (long long)1e3) return 4;\n      if (x >= (long long)1e2) return 3;\n      if (x >= (long long)1e1) return 2;\n      return 1;\n    }\n  }\n  IO() {\n    load();\n    for (int i = 0; i < 10000; ++i) {\n      int j = i;\n      for (int t = 3; t >= 0; --t) {\n        strs[i * 4 + t] = j % 10 + '0';\n        j /= 10;\n      }\n    }\n  }\n  ~IO() { flush(); }\n  inline void load() {\n    memcpy(buf_in, buf_in + pt_in, tail_in - pt_in);\n    size_t width = tail_in - pt_in;\n    tail_in = width + fread(buf_in + width, 1, buf_size - width, stdin);\n    pt_in = 0;\n  }\n  inline void flush() {\n    fwrite(buf_out, 1, pt_out, stdout);\n    pt_out = 0;\n  }\n  inline void read(char& c) { c = buf_in[pt_in++]; }\n  template <class T>\n  inline void read(T& x) {\n    if (pt_in + 32 > tail_in) load();\n    char c;\n    do {\n      read(c);\n    } while (c < '0');\n    bool minus = 0;\n    if (c == '-') {\n      minus = 1;\n      read(c);\n    }\n    x = 0;\n    while (c >= '0') {\n      x = x * 10 + (c & 15);\n      read(c);\n    }\n    if (minus) x = -x;\n  }\n  inline void write(char c) { buf_out[pt_out++] = c; }\n  template <class T>\n  inline void write(T x) {\n    if (pt_out > buf_size - 32) flush();\n    if (x < 0) {\n      write('-');\n      x = -x;\n    }\n    size_t digits = num_digits(x);\n    int i;\n    for (i = pt_out + digits - 4; i > (int)pt_out; i -= 4) {\n      memcpy(buf_out + i, strs + (x % 10000) * 4, 4);\n      x /= 10000;\n    }\n    memcpy(buf_out + pt_out, strs + x * 4 + (pt_out - i), 4 + i - pt_out);\n    pt_out += digits;\n  }\n  inline void write(const char* s) {\n    if (pt_out > buf_size - 32) flush();\n    for (int i = 0; s[i] != 0; ++i) write(s[i]);\n  }\n  template <class T>\n  inline void writeln(T x) {\n    write(x);\n    write('\\n');\n  }\n} io;\n\n#define iter(i, a, b) for(int i=(a); i<(b); i++)\n#define rep(i, a) iter(i, 0, (int)(a))\n#define rep1(i, a) iter(i, 1, (int)(a)+1)\n#define fi first\n#define se second\n#define pb push_back\n#define intsize (sizeof(int))\n \n#define ll long long\n#define pii pair<int, int>\n//#define int ll\nconst int MOD = 998244353;\n\ntypedef unsigned us;\ntypedef unsigned long long ull;\n\nstatic char buf[450 << 20];\nvoid* operator new(size_t s) {\n\tstatic size_t i = sizeof buf;\n\tassert(s < i);\n\treturn (void*)&buf[i -= s];\n}\nvoid operator delete(void*) {}\n\ntemplate<class T> struct ptr {\n\tunsigned ind;\n\tptr(T* p = 0) : ind(p ? unsigned((char*)p - buf) : 0) {\n\t\tassert(ind < sizeof buf);\n\t}\n\tT& operator*() const { return *(T*)(buf + ind); }\n\tT* get() const { return &**this; }\n\tT& operator[](int a) const { return (&**this)[a]; }\n\texplicit operator bool() const { return ind; }\n};\n\nnamespace poly {\n\tconst int MOD = 998244353;\n\tconst int IMAG = 86583718;\n\tconst int NTTG = 3;\n\t\n\tint qpow(int b, int e) {\n\t\tint re=1;\n\t\twhile(e){\n\t\t\tif(e&1)re=1ll*re*b%MOD;\n\t\t\tb=1ll*b*b%MOD;e>>=1;\n\t\t}\n\t\treturn re;\n\t}\n\t\n// https://www.luogu.com.cn/record/32153077\n// zzq orz\n#define SZ 524320\nll qp(ll a,ll b)\n{\n\tll ans=1;\n\twhile(b)\n\t{\n\t\tif(b&1) ans=ans*a%MOD;\n\t\ta=a*a%MOD; b>>=1;\n\t}\n\treturn ans;\n}\nint getK(int n)\n{int s=1; while(s<n) s<<=1; return s;}\nus pool[SZ*4] __attribute__ ((aligned(64))),*ptr=pool;\nus *p0[SZ],*p1[SZ],*q0[SZ],*q1[SZ];\n__attribute__((always_inline)) void bit_flip(us*p,int t)\n{\n\tfor(int i=0,j=0;i<t;++i)\n\t{\n\t\tif(i>j) swap(p[i],p[j]);\n\t\tfor(int l=t>>1;(j^=l)<l;l>>=1);\n\t}\n}\nvoid prep(int n)\n{\n\tstatic int t=1;\n\tfor(;t<n;t<<=1)\n\t{\n\t\tint g=qp(3,(MOD-1)/(t*2));\n\t\tus*p,*q;\n\t\tp=p0[t]=ptr; ptr+=max(t,16); p[0]=1;\n\t\tfor(int m=1;m<t;++m)\n\t\t\tp[m]=p[m-1]*(ull)g%us(MOD);\n\t\tbit_flip(p,t);\n\t\tq=q0[t]=ptr; ptr+=max(t,16);\n\t\tfor(int i=0;i<t;++i)\n\t\t\tq[i]=(ull(p[i])<<32)/MOD;\n\t\tg=qp(g,MOD-2);\n\t\tp=p1[t]=ptr; ptr+=max(t,16); p[0]=1;\n\t\tfor(int m=1;m<t;++m)\n\t\t\tp[m]=p[m-1]*(ull)g%us(MOD);\n\t\tbit_flip(p,t);\n\t\tq=q1[t]=ptr; ptr+=max(t,16);\n\t\tfor(int i=0;i<t;++i)\n\t\t\tq[i]=(ull(p[i])<<32)/MOD;\n\t}\n}\ntypedef unsigned long long ull;\n__attribute__((always_inline)) us my_mul(us a,us b,us c)\n{\n\treturn b*(ull)a-((ull(a)*c)>>32)*ull(998244353);\n}\n__attribute__((always_inline)) __m128i my_mullo_epu32(const __m128i&a, const __m128i& b)\n{\n\treturn _mm_mullo_epi32(a,b);\n\t/*\n\t__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)\n\t__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)\n\t__m128i prod02 = _mm_mul_epu32(a, b);                 // (-,a2*b2,-,a0*b0)\n\t__m128i prod13 = _mm_mul_epu32(a13, b13);             // (-,a3*b3,-,a1*b1)\n\t__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (-,-,a1*b1,a0*b0) \n\t__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (-,-,a3*b3,a2*b2) \n\t__m128i prod   = _mm_unpacklo_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)\n\treturn prod;\n\t*/\n}\n__attribute__((always_inline)) __m128i my_mulhi_epu32(const __m128i&a, const __m128i& b)\n{\n\t__m128i a13    = _mm_shuffle_epi32(a, 0xF5);          // (-,a3,-,a1)\n\t__m128i b13    = _mm_shuffle_epi32(b, 0xF5);          // (-,b3,-,b1)\n\t__m128i prod02 = _mm_mul_epu32(a, b);                 // (a2*b2,-,a0*b0,-)\n\t__m128i prod13 = _mm_mul_epu32(a13, b13);             // (a3*b3,-,a1*b1,-)\n\t__m128i prod01 = _mm_unpacklo_epi32(prod02,prod13);   // (a1*b1,a0*b0,-,-) \n\t__m128i prod23 = _mm_unpackhi_epi32(prod02,prod13);   // (a3*b3,a2*b2,-,-) \n\t__m128i prod   = _mm_unpackhi_epi64(prod01,prod23);   // (ab3,ab2,ab1,ab0)\n\treturn prod;\n}\nvoid ntt(us* __restrict__ x,int n)\n{\n\tint t=n;\n\tfor(int m=1;m<n;m<<=1)\n\t{\n\t\tt>>=1;\n\t\tus* __restrict__ p=p0[m];\n\t\tus* __restrict__ q=q0[m];\n\t\tif(t==1)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\tus v=my_mul(xb[j],p[i],q[i]);\n\t\t\t\t\txa[j]=u+v;\n\t\t\t\t\txb[j]=u-v+us(MOD+MOD);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==2)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j]-(xa[j]>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\tus v=my_mul(xb[j],p[i],q[i]);\n\t\t\t\t\txa[j]=u+v;\n\t\t\t\t\txb[j]=u-v+us(MOD+MOD);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==4)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\tfor(int j=0;j<t;j+=4)\n\t\t\t\t{\n\t\t\t\t\t__m128i u=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\tu=_mm_sub_epi32(u,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u)),mm));\n\t\t\t\t\t__m128i v=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\tv=_mm_sub_epi32(my_mullo_epu32(v,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v,q4),m1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u,v));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),_mm_add_epi32(_mm_sub_epi32(u,v),mm));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\t//unfold 2x\n\t\t\t\tfor(int j=0;j<t;j+=8)\n\t\t\t\t{\n\t\t\t\t\t__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));\n\t\t\t\t\t__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));\n\t\t\t\t\tu0=_mm_sub_epi32(u0,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u0,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u0)),mm));\n\t\t\t\t\tu1=_mm_sub_epi32(u1,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(u1,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,u1)),mm));\n\t\t\t\t\tv0=_mm_sub_epi32(my_mullo_epu32(v0,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v0,q4),m1));\n\t\t\t\t\tv1=_mm_sub_epi32(my_mullo_epu32(v1,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(v1,q4),m1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_add_epi32(u0,v0));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j+4),_mm_add_epi32(u1,v1));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_add_epi32(_mm_sub_epi32(u0,v0),mm));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j+4),\n\t\t\t\t\t_mm_add_epi32(_mm_sub_epi32(u1,v1),mm));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;++i)\n\t\tx[i]-=(x[i]>=us(MOD+MOD))*us(MOD+MOD),\n\t\tx[i]-=(x[i]>=us(MOD))*us(MOD);\n}\nvoid intt(us* __restrict__ x,int n)\n{\n\tint t=1;\n\tfor(int m=(n>>1);m;m>>=1)\n\t{\n\t\tus* __restrict__ p=p1[m];\n\t\tus* __restrict__ q=q1[m];\n\t\tif(t==1)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j],v=xb[j];\n\t\t\t\t\txa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\txb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==2)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t\tfor(int j=0;j<t;++j)\n\t\t\t\t{\n\t\t\t\t\tus u=xa[j],v=xb[j];\n\t\t\t\t\txa[j]=u+v-(u+v>=us(MOD+MOD))*us(MOD+MOD);\n\t\t\t\t\txb[j]=my_mul(u-v+us(MOD+MOD),p[i],q[i]);\n\t\t\t\t}\n\t\t}\n\t\telse if(t==4)\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\tfor(int j=0;j<t;j+=4)\n\t\t\t\t{\n\t\t\t\t\t__m128i u=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i v=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i uv=_mm_add_epi32(u,v);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv)),mm)));\n\t\t\t\t\tuv=_mm_add_epi32(_mm_sub_epi32(u,v),mm);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv,q4),m1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tus *xa=x,*xb=x+t;\n\t\t\tfor(int i=0;i<m;++i,xa+=t+t,xb+=t+t)\n\t\t\t{\n\t\t\t\tconst __m128i p4=_mm_set1_epi32(p[i]),\n\t\t\t\tq4=_mm_set1_epi32(q[i]),\n\t\t\t\tmm=_mm_set1_epi32(MOD+MOD),\n\t\t\t\tm0=_mm_set1_epi32(0),\n\t\t\t\tm1=_mm_set1_epi32(MOD);\n\t\t\t\t//unfold 2x\n\t\t\t\tfor(int j=0;j<t;j+=8)\n\t\t\t\t{\n\t\t\t\t\t__m128i u0=_mm_loadu_si128((__m128i*)(xa+j));\n\t\t\t\t\t__m128i u1=_mm_loadu_si128((__m128i*)(xa+j+4));\n\t\t\t\t\t__m128i v0=_mm_loadu_si128((__m128i*)(xb+j));\n\t\t\t\t\t__m128i v1=_mm_loadu_si128((__m128i*)(xb+j+4));\n\t\t\t\t\t__m128i uv0=_mm_add_epi32(u0,v0);\n\t\t\t\t\t__m128i uv1=_mm_add_epi32(u1,v1);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j),_mm_sub_epi32(uv0,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv0,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv0)),mm)));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xa+j+4),_mm_sub_epi32(uv1,\n\t\t\t\t\t_mm_and_si128(_mm_or_si128(_mm_cmpgt_epi32(uv1,mm),\n\t\t\t\t\t_mm_cmpgt_epi32(m0,uv1)),mm)));\n\t\t\t\t\tuv0=_mm_add_epi32(_mm_sub_epi32(u0,v0),mm);\n\t\t\t\t\tuv1=_mm_add_epi32(_mm_sub_epi32(u1,v1),mm);\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv0,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv0,q4),m1)));\n\t\t\t\t\t_mm_storeu_si128((__m128i*)(xb+j+4),\n\t\t\t\t\t_mm_sub_epi32(my_mullo_epu32(uv1,p4),\n\t\t\t\t\tmy_mullo_epu32(my_mulhi_epu32(uv1,q4),m1)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt<<=1;\n\t}\n\tus rn=qp(n,MOD-2);\n\tfor(int i=0;i<n;++i)\n\t\tx[i]=x[i]*(ull)rn%MOD;\n}\n\t\n\tvoid mult(us *a, us as, us *b, us bs, us *o, bool construct, bool clean = 0, us th = 100000000) {\n\t\tus n = as+bs-1;\n\t\tif(n >= 40) {\n    \t\twhile(n - (n & (-n))) n += (n & (-n));\n    \t\tassert(!construct);\n    \t\t//constructrev(n);\n    \t\tntt(a, n); ntt(b, n);\n    \t\trep(i, n) o[i] = 1ll*a[i]*b[i]%MOD;\n    \t\tintt(o, n);\n\t\t} else {\n\t\t    static ll tmp[41];\n\t\t    rep(i, as) rep(j, bs) tmp[i+j] += 1ll * a[i] * b[j];\n\t\t    rep(i, n) {\n\t\t        o[i] = tmp[i] % MOD;\n\t\t        tmp[i] = 0;\n\t\t    }\n\t\t}\n\t\titer(i, th, n) o[i] = 0;\n\t\tif(clean) rep(i, n) a[i] = b[i] = 0;\n\t}\n\n\tvoid cfn(us* a, us as, us *o) {\n\t\tstatic us tmp[524320];\n\t\tif(as == 1) { tmp[0] = a[0]; o[0] = qpow(a[0], MOD - 2); return; }\n\t\tcfn(a, (as+1)/2, o); us le = 0;\n\t\twhile((1 << le) < (as << 1)) le++;\n\t\t//constructrev(1 << le);\n\t\tmemcpy(tmp, a, as*intsize);\n\t\tmemset(tmp+as, 0, ((1<<le)-as)*intsize);\n\t\tntt(tmp, 1<<le); ntt(o, 1<<le);\n\t\trep(i, 1<<le) o[i] = 1ll * (MOD + (2 - 1ll * tmp[i] * o[i]) % MOD) * o[i] % MOD;\n\t\tintt(o, 1<<le);\n\t\tmemset(o+as, 0, ((1<<le)-as)*intsize);\n\t}\n\n\tvoid init(us n) { prep(n); }\n\t\n\tvoid divide(us *a, us as, us *b, us bs, us *q, us *r) {\n\t\tstatic us ar[524320], br[524320], bin[524320];\n\t\tus th = as, re = as-bs+1;\n\t\t//th = re+1;\n\t\trep(i, as) ar[i] = a[as-1-i];\n\t\trep(i, bs) br[i] = b[bs-1-i];\n\t\tcfn(br, th, bin);\n\t\tmult(ar, th, bin, th, q, 0, 1, re);\n\t\treverse(q, q+re);\n\t\tmult(q, re, b, bs, r, 0, 1, bs - 1);\n\t\trep(i, bs - 1) r[i] = (MOD + a[i] - r[i]) % MOD;\n\t}\n\t\n}\n\n#define array MY_FUCKING_ARRAY\n\nstruct array {\n    ptr<us> head; us sz;\n    array() : sz(0) { head = nullptr; }\n    array(us size) : sz(size) { head = new us[size]; }\n    us& operator[](const us idx) { return head[idx]; }\n    us* get() { return head.get(); }\n    const us size() { return sz; }\n};\n\narray pol[524320];\n\n\nnamespace Eval {\n    us points[524320];\n    us answer[524320];\n    \n    void init(us idx, us l, us r) {\n        // [l, r)\n        if(r - l == 0) {\n            pol[idx] = array(1);\n            pol[idx][0] = 1;\n            return;\n        }\n        if(r - l == 1) {\n            pol[idx] = array(2);\n            pol[idx][0] = (MOD - points[l]) % MOD;\n            pol[idx][1] = 1;\n            return;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320];\n        init(idx*2, l, (l+r)/2);\n        init(idx*2+1, (l+r)/2, r);\n        us n = pol[idx*2].size();\n        us m = pol[idx*2+1].size();\n        memcpy(tmp1, pol[idx*2].get(), n * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);\n        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);\n        pol[idx] = array(n+m-1);\n        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);\n        //assert(pol[idx] == Eval::pol[idx]);\n    }\n\n    void solve(us idx, us l, us r, array& polynomial) {\n        static us tmp[524320], tmp2[524320], tmp3[524320], BULLSHIT[524320];\n        //assert(polynomial.size() == r-l);\n        if(r - l == 0) return;\n        if(r - l == 1) {\n            answer[l] = polynomial[0];\n            return;\n        }\n        us m = (l+r)/2;\n        if(m - l) {\n            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);\n            memcpy(tmp2, pol[idx*2].get(), (m-l+1)*intsize);\n            poly::divide(tmp, polynomial.size(), tmp2, m-l+1, BULLSHIT, tmp3);\n            array p2(m-l); memcpy(p2.get(), tmp3, (m-l)*intsize);\n            solve(idx*2, l, m, p2);\n        }\n        if(r - m) { \n            memcpy(tmp, polynomial.get(), polynomial.size()*intsize);\n            memcpy(tmp2, pol[idx*2+1].get(), (r-m+1)*intsize);\n            poly::divide(tmp, polynomial.size(), tmp2, r-m+1, BULLSHIT, tmp3);\n            array p2(r-m); memcpy(p2.get(), tmp3, (r-m)*intsize);\n            solve(idx*2+1, m, r, p2);\n        }\n    }\nus p[524320];\nus dv[524320];\nus rp[524320];\nus BULLsHIT[524320];\n    array eval(array& po, array& v) {\n        us n = po.size(), m = v.size();\n        rep(i, m) {\n            points[i] = v[i];\n            if(!v[i]) v[i] = MOD;\n        }\n        init(1, 0, m);\n        static us tmp[524320];\n        array pp(m);\n        if(n >= m+1) {\n            rep(i, m+1) dv[i] = pol[1][i];\n            rep(i, n) p[i] = po[i];\n            poly::divide(p, n, dv, m+1, BULLsHIT, tmp);\n            memcpy(pp.get(), tmp, m*intsize);\n        } else pp = po;\n        solve(1, 0, m, pp);\n        array res(m); memcpy(res.get(), answer, m*intsize);\n        return res;\n    }\n}\n\nnamespace Inter {\n    us points[524320], values[524320];\n    \n    array drv, coeff;\n\n    void init(us idx, us l, us r) {\n        // [l, r)\n        if(r - l == 0) {\n            pol[idx] = array(1);\n            pol[idx][0] = 1;\n            return;\n        }\n        if(r - l == 1) {\n            pol[idx] = array(2);\n            pol[idx][0] = (MOD - points[l]) % MOD;\n            pol[idx][1] = 1;\n            return;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320];\n        init(idx*2, l, (l+r)/2);\n        init(idx*2+1, (l+r)/2, r);\n        us n = pol[idx*2].size();\n        us m = pol[idx*2+1].size();\n        memcpy(tmp1, pol[idx*2].get(), n * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), m * intsize);\n        poly::mult(tmp1, n, tmp2, m, tmp3, 0, 1);\n        pol[idx] = array(n+m-1);\n        memcpy(pol[idx].get(), tmp3, pol[idx].size() * intsize);\n        //assert(pol[idx] == Eval::pol[idx]);\n    }\n    \n    array solve(us idx, us l, us r) {\n        if(r - l == 0) {\n            array ans(1); ans[0] = 1;\n            return ans;\n        }\n        if(r - l == 1) {\n            array ans(1); ans[0] = 1ll * values[l] * poly::qpow(coeff[l], MOD-2) % MOD;\n            return ans;\n        }\n        static us tmp1[524320], tmp2[524320], tmp3[524320], tmp4[524320];\n        array tmp = solve(idx*2, l, (l+r)/2);\n        array tmpp = solve(idx*2+1, (l+r)/2, r);\n        memcpy(tmp1, tmp.get(), tmp.size() * intsize);\n        memcpy(tmp2, pol[idx*2+1].get(), pol[idx*2+1].size() * intsize);\n        us s1 = tmp.size() + pol[idx*2+1].size() - 1;\n        poly::mult(tmp1, tmp.size(), tmp2, pol[idx*2+1].size(), tmp3, 0, 1); \n        rep(i, tmpp.size()) tmp1[i] = tmpp[i];\n        memcpy(tmp1, tmpp.get(), tmpp.size() * intsize);\n        memcpy(tmp2, pol[idx*2].get(), pol[idx*2].size() * intsize);\n        us s2 = tmpp.size() + pol[idx*2].size() - 1;\n        poly::mult(tmp1, tmpp.size(), tmp2, pol[idx*2].size(), tmp4, 0, 1); \n        s2 = max(s2, s1); tmp = array(s2);\n        rep(i, s2) {\n            us p = tmp3[i] + tmp4[i]; p -= (p >= MOD ? MOD : 0);\n            tmp[i] = p;\n            //tmp3[i] = tmp4[i] = 0;\n        }\n        return tmp;\n    }\n\n    array inter(array& pt, array& vl) {\n        assert(pt.size() == vl.size());\n        us n = pt.size();\n        memcpy(points, pt.get(), n * intsize);\n        memcpy(values, vl.get(), n * intsize);\n        init(1, 0, n);\n        drv = array(n);\n        rep1(i, n) { drv[i-1] = 1ll * i * pol[1][i] % MOD; }\n        coeff = Eval::eval(drv, pt);\n        return solve(1, 0, n);\n    }\n}\n\n#define pol MY_FUCKING_pol\n\nus original_pol[524320];\n\narray pts, vls;\narray res;\n\nus fac[524300], ifac[524300], inv[524300];\nus ar1[524320], ar2[524320], f[524320];\nus ar2i[524320];\n\nus not_BULLSHIT[524320];\n\nsigned main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);\n    int n; io.read(n);\n    fac[0] = ifac[0] = fac[1] = ifac[1] = inv[0] = inv[1] = 1;\n    iter(i, 2, n+2) {\n    \tinv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD;\n    \tfac[i] = 1ll * fac[i-1] * i % MOD;\n    \tifac[i] = 1ll * ifac[i-1] * inv[i] % MOD;\n    }\n    pts = array(n+1);\n    rep(i, n+1) pts[i] = i;\n    rep(i, n) io.read(original_pol[i]);\n    int k = 1; while(k < ((n+2) << 1)) k <<= 1;\n    poly::init(k);\n    //tmp = Eval::eval(pol, pts);\n    //rep(i, n+1) ar1[i] = 1ll * tmp[i] * ifac[i] % MOD;\n    rep(i, n+1) ar2[i] = 1ll * ((i % 2) ? (MOD - 1) : 1) * ifac[i] % MOD;\n    poly::cfn(ar2, n+1, ar2i);\n    poly::mult(original_pol, n+1, ar2i, n+1, not_BULLSHIT, 0);\n    vls = array(n+1);\n    rep(i, n+1) vls[i] = 1ll * not_BULLSHIT[i] * fac[i] % MOD;\n    res = Inter::inter(pts, vls);\n    rep(i, n) io.write(res[i]), io.write(' ');\n}\n```",
        "postTime": 1594463945,
        "uid": 220037,
        "name": "w33z8kqrqk8zzzx33",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P5393 \u3010\u4e0b\u964d\u5e42\u591a\u9879\u5f0f\u8f6c\u666e\u901a\u591a\u9879\u5f0f\u3011"
    }
]