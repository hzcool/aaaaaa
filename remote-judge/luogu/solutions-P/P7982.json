[
    {
        "content": "\u53ef\u4ee5\u770b\u51fa\u94fe\u6c42\u548c\u8981\u5dee\u5206\u5427\u3002\u3002$x,y$ \u7684 LCA \u5c31\u662f\u4e24\u533a\u95f4\u53bb\u6389\u524d\u5bfc $0$ \u7684 LCP\u3002\n\n\u5148\u5bf9 $x,y$ \u53bb\u6389\u524d\u5bfc $0$\u3002\n\n\u7136\u540e\u5230\u6839\u7684\u548c\u5c31\u662f\u533a\u95f4\u7684\u6bcf\u4e2a\u524d\u7f00\u5bf9\u5e94\u7684\u7ed3\u70b9\u7684\u548c\u3002\n\n\u4e0d\u8fc7\u7ef4\u62a4\u533a\u95f4\u548c\u7ed3\u70b9\u7684\u5bf9\u5e94\u5173\u7cfb\u8fc7\u4e8e\u590d\u6742\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u7ef4\u62a4\u533a\u95f4\u5373\u53ef\u3002\u5373\u5b9e\u8d28\u4e0a\u7684\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u7ed3\u70b9\u52a0\uff0c\u5176\u5b9e\u662f\u628a\u5e8f\u5217\u4e0a\u6240\u6709\u7b49\u4ef7\u4e8e\u8fd9\u4e2a\u7ed3\u70b9\u7684\u533a\u95f4\u52a0\u3002\n\n\u5b50\u6811\u52a0\u7684\u8bdd\u9996\u5148\u8981\u627e\u5230 $x$ \u5728\u5e8f\u5217\u4e0a\u6240\u6709\u76f8\u540c\u7684\u533a\u95f4\u3002SA \u7684\u8bdd\u8981\u627e\u5230\u6240\u6709 $lcp(l_x,y)\\ge r_x-l_x+1$ \u7684\u540e\u7f00 $y$\u3002\u8fd9\u4e2a\u663e\u7136\u662f\u5728 height \u6570\u7ec4\u4e0a\u7684\u4e00\u4e2a\u533a\u95f4\u3002\n\n\u6709\u4e24\u4e2a\u7ebf\u6027\u7a7a\u95f4\u7684\u505a\u6cd5\uff1aheight \u6570\u7ec4\u7ebf\u6027\u7a7a\u95f4\uff0c$O(\\log n)$ \u65f6\u95f4\u7684 $O(n)-O(1)$ RMQ \u4e0a\u4e8c\u5206\u6216\u8005\u7ebf\u6bb5\u6811\u4e8c\u5206\uff0c\u548c\u79bb\u7ebf\u6392\u5e8f\uff0c\u6bcf\u6b21\u52a0\u5165\u6240\u6709 $\\ge r_x-l_x+1$ \u7684 $height_i$\uff0c\u7136\u540e\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u8fde\u7eed\u6bb5\uff08\u8fd9\u4e2a\u505a\u6cd5\u53ef\u4ee5\u7528\u7ebf\u6027\u6811\u4e0a\u5e76\u67e5\u96c6\u4f18\u5316\u5230\u7ebf\u6027\u65f6\u95f4\uff0c\u4e0d\u8fc7\u4e0d\u662f\u74f6\u9888\uff0c\u6240\u4ee5\u4e0d\u91cd\u8981\uff09\u3002\n\n\u5176\u5b9e\u6bcf\u4e2a\u540e\u7f00\u7684\u6240\u6709\u975e $0$ \u524d\u7f00\u90fd\u7ec4\u6210\u4e86\u4e00\u6761\u4ece\u6839\u5f80\u4e0b\u7684\u94fe\u3002\u6240\u4ee5\u5bf9\u6bcf\u4e2a\u540e\u7f00\u8fdb\u884c\u64cd\u4f5c\uff0c\u5c31\u662f\u5c06\u8fd9\u4e2a\u540e\u7f00\u7684\u6240\u6709\u957f\u5ea6 $\\ge r_x-l_x+1$ \u7684\u524d\u7f00\u52a0\u3002\n\n\u770b\u505a\u4e8c\u7ef4\u5e73\u9762\uff0c\u5c06\u6bcf\u4e2a\u540e\u7f00\u5e73\u79fb\u5230\u540c\u6837\u7684\u4f4d\u7f6e\uff08\u6216\u8005\u8bf4\u662f\u6bcf\u4e2a\u540e\u7f00\u7684\u524d\u7f00\u4ece\u90fd\u4ece $1$ \u5f00\u59cb\u7f16\u53f7\uff09\uff0c\u90a3\u4e48\u5c31\u662f\u4e00\u4e2a\u77e9\u5f62\u52a0\u3002\n\n\u8bbe\u4e8c\u5206\u51fa\u7684\u533a\u95f4\u4e3a $L,R$\uff0c\u4e8c\u7ef4\u5e73\u9762\u4e3a $a_{x,y}$\uff0c\u90a3\u4e48\u5c31\u662f $\\forall x\\in [L,R],y\\in [r_x-l_x+1,n],a_{x,y}$ \u52a0\u4e0a $v$\u3002\n\n\u81f3\u4e8e\u94fe\u6c42\u548c\uff0c\u5c31\u662f\u6c42\u8fd9\u4e2a\u540e\u7f00\u6240\u6709\u957f\u5ea6 $\\le r-l+1$ \u7684\u524d\u7f00\u7684\u548c\u3002\u8bbe\u8fd9\u4e2a\u533a\u95f4\u4e3a $[l,r]$\uff0c\u90a3\u4e48\u5c31\u662f\u6c42 $\\sum_{i=1}^{r-l+1} a_{rk_l,i}$\u3002\n\n\u8fd9\u4e2a CDQ+\u6811\u72b6\u6570\u7ec4\uff0c\u968f\u4fbf\u62c6\u4e00\u4e0b\u8d21\u732e\u5373\u53ef\uff0c$O(n\\log ^2n)$ \u65f6\u95f4\uff0c\u7ebf\u6027\u7a7a\u95f4\u3002\n\n\u4ee3\u7801\u53ef\u4ee5\u627e\u6211\u8981\u3002\n\n\u5e38\u6570\u7684\u8bdd\uff0c\u7ebf\u6bb5\u6811 $O(n\\log^2 n)$ \u627e\u533a\u95f4\u6709\u88ab\u5361\u5e38\u7684\u98ce\u9669\u3002\u7a7a\u95f4\u9700\u8981\u7cbe\u7ec6\u5b9e\u73b0\u3002\u5176\u4ed6\u5e94\u8be5\u8fd8\u597d\u3002",
        "postTime": 1635428769,
        "uid": 203623,
        "name": "Ntokisq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 \u7434\u7434\u7684\u6811"
    },
    {
        "content": "[\u539f\u9898\u94fe\u63a5](https://www.luogu.com.cn/problem/P7982)\n\n\u4fee\u6539\u7684\u4e32 $s$ \uff08\u53bb\u6389\u524d\u5bfc $0$\uff09\u53ea\u4f1a\u5bf9\u4ee5 $s$ \u4e3a\u524d\u7f00\u7684\u5b50\u4e32\u4ea7\u751f\u8d21\u732e\u3002\n\n\u628a\u539f\u4e32\u53cd\u8fc7\u6765\u5efa $\\text{SAM}$\uff0c\u90a3\u4fee\u6539\u5c31\u4f1a\u5bf9 $\\text{parent tree}$ \u5b50\u6811\u5185\u6240\u6709\u7b49\u4ef7\u7c7b\uff0c\u4ee5\u53ca\u5f53\u524d\u7b49\u4ef7\u7c7b\u4e2d\u957f\u5ea6 $\\geq |s|$ \u7684\u4e32\u4ea7\u751f\u8d21\u732e\u3002\n\n\u8fd9\u5927\u4f53\u662f\u4e2a\u5b50\u6811\u52a0\uff0c\u94fe\u6c42\u548c\u7684\u4e1c\u897f\uff0c\u7136\u540e\u628a\u94fe\u6c42\u548c\u5dee\u5206\uff0c\u5c31\u662f\u56db\u4e2a\u70b9\u5230\u6839\u7684\u67e5\u8be2\u3002\n\n\n\u5bf9\u957f\u4e3a $len$\uff0c\u7b49\u4ef7\u7c7b\u4e3a $x$ \u7684\u67e5\u8be2\u4e32\uff0c\u4e4b\u524d\u957f\u4e3a $len'$\uff0c\u7b49\u4ef7\u7c7b\u4e3a $y$ \u7684\u4fee\u6539\u4e32\uff0c\u5bf9\u5176\u7684\u8d21\u732e\u4e3a $[x\\in \\operatorname{subtree}_y](len'-len+1)\\times v$\u3002\n\n\u62cd\u5230 $dfs$ \u5e8f\u4e0a\uff0c\u4e00\u6b21\u4fee\u6539\u5c06\u5b50\u6811\u5185\u8282\u70b9 $w_x+=(len'+1)\\times v,c_x+=v$\u3002\u90a3\u67e5\u8be2\u7b54\u6848\u5c31\u662f $w_x-c_x\\times len$\uff0c\u4e24\u4e2a\u6811\u72b6\u6570\u7ec4\u5bb9\u6613\u5b9e\u73b0\u3002\n\n\u800c\u540c\u4e00\u4e2a\u7b49\u4ef7\u7c7b\u7684\u4f1a\u7b97\u591a\uff0c\u5bf9\u6bcf\u4e2a\u7b49\u4ef7\u7c7b\u79bb\u7ebf\u4e0b\u6765\uff0c\u6309\u957f\u5ea6\u9650\u5236\u7528\u6811\u72b6\u6570\u7ec4\u51cf\u6389\u591a\u4f59\u8d21\u732e\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log n)$\uff0c\u7a7a\u95f4 $\\text{64MB}$ \u6709\u70b9\u9ebb\uff08n\uff09\u70e6\uff08t\uff09\u3002\n\n\u4e3a\u4e86\u8ba9\u7a7a\u95f4\u7ebf\u6027\uff0c\u74f6\u9888\u5728\u4e8e\u5b9a\u4f4d\u7b49\u4ef7\u7c7b\u7684\u500d\u589e\u4e0e\u6c42 $\\operatorname{lca}$\u3002\n\n\u628a\u500d\u589e\u6362\u6210\u79bb\u7ebf\u4e8c\u5206\uff0c\u5177\u4f53\u7684\uff0c\u8981\u5b9a\u4f4d\u7684\u4e32\u79bb\u7ebf\u5230\u53f3\u7aef\u70b9\u6240\u5c5e\u8282\u70b9\uff0c$dfs$ \u65f6\u65f6\u7ef4\u62a4\u51fa\u5f53\u524d\u8282\u70b9\u5230\u6839\u7684\u94fe\uff0c\u7136\u540e\u5728\u94fe\u4e0a\u4e8c\u5206 $\\geq len$ \u7684 $mxlen$ \u6700\u5c0f\u7684\u70b9\u3002\n\n\u6c42 $\\operatorname{lca}$ \u6362\u6210 $\\text{Tarjan}$ \u6c42\uff0c\u4e8e\u662f\u7a7a\u95f4\u80fd\u7ebf\u6027\u4e86\u3002\n\n\u4f46\u8fd8\u662f\u5bb9\u6613\u7206\uff0c\u6bd5\u7adf\u6570\u7ec4\u8fc7\u591a\u3002\u91cd\u590d\u5229\u7528\u6570\u7ec4\uff08\u5982\u8f6c\u79fb\u8fb9\u4e0e\u4e24\u6b21\u6811\u72b6\u6570\u7ec4\uff09\uff0c\u79bb\u7ebf\u8fc7\u7a0b\u7528\u52a0\u8fb9\u4ee3\u66ff\uff0c\u5e76\u7cbe\u7ec6\u5b9e\u73b0\uff0c\u518d\u5f00 $\\text{C++98}$ \u5e94\u8be5\u80fd\u8fc7\u4e86\u3002\n\n~~\u7a7a\u95f4\u5f00\u8fd9\u4e48\u5c0f\u641e\u5565\u554a\uff0c\u8fd8\u4e0d\u5982\u7ed9\u5355 log \u653e\u5927\u70b9\u6570\u636e\u8303\u56f4\u6765\u7684\u5b9e\u5728\u3002~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e5+10;\nint x,y,xx,l,r;\nint last=1,tot=1,tmp;\nint mxlen[N<<1],link[N<<1];\nunsigned t[N<<1][2];\nvoid extend(bool a){\n\ty=last,tmp=++tot;\n\tmxlen[tmp]=mxlen[y]+1;\n\tfor(;!t[y][a];y=link[y])t[y][a]=tmp;\n\tif(!y)link[tmp]=1;\n\telse {\n\t\tx=t[y][a];\n\t\tif(mxlen[x]==mxlen[y]+1)link[tmp]=x;\n\t\telse {\n\t\t\txx=++tot;mxlen[xx]=mxlen[y]+1;\n\t\t\tmemcpy(t[xx],t[x],8);\n\t\t\tfor(;t[y][a]==x;y=link[y])t[y][a]=xx;\n\t\t\tlink[xx]=link[x];link[tmp]=link[x]=xx;\n\t\t}\n\t}\n\tlast=tmp;\n}\n#define lowbit(i) i&(-i)\nunsigned res_t,ress_t;int n_t;\ninline void update_t(int i,unsigned v,unsigned vv){\n\tfor(;i<=n_t;i+=lowbit(i))t[i][0]+=v,t[i][1]+=vv;\n}\ninline void inquiry_t(int i){\n\tfor(res_t=ress_t=0;i;i-=lowbit(i))\n\t\tres_t+=t[i][0],ress_t+=t[i][1]; \n}\nunsigned ans[N],res;\ninline void rupdate_t(int i,unsigned v){\n\tunsigned vv=v*i;\n\tfor(;i;i-=lowbit(i))t[i][0]+=v,t[i][1]+=vv;\n}\ninline void rinquiry_t(int x){\n\tres_t=ress_t=0;\n\tfor(int i=x+1;i<=n_t;i+=lowbit(i))\n\t\tres_t+=t[i][0],ress_t+=t[i][1];\n\tres=res_t*(x+1)-ress_t;\n}\ninline void rclear_t(int i){\n\tfor(;i;i-=lowbit(i))t[i][0]=t[i][1]=0;\n}\nbool a[N];\nint son[N<<1][2],dep[N<<1];\nint dfn[N<<1],dfnr[N<<1],ttime;\ninline void add(int x,int y){\n\tson[x][0]?son[x][1]=y:son[x][0]=y;\n}\nvoid init(int x){\n\tdfn[x]=++ttime;\n\tdep[x]=dep[link[x]]+1;\n\tif(son[x][0])init(son[x][0]);\n\tif(son[x][1])init(son[x][1]);\n\tdfnr[x]=ttime+1;\n}\nstruct inq{int lx,ly,x,y,z;}qq[N];\nint h[N<<1],nextn[N<<2],to[N<<2],edg;\nchar qb[N<<2];\ninline void addq(int x,int i,char bb){\n\tto[++edg]=i,nextn[edg]=h[x],h[x]=edg,qb[edg]=bb;\n}\ninline void update(int x,int lx,unsigned v){\n\tupdate_t(dfn[x],v,v*lx);\n\tupdate_t(dfnr[x],-v,-v*lx);\n}\ninline void inquiry(int x,int lx){\n\tinquiry_t(dfn[x]);\n\tres+=res_t*(lx+1)-ress_t;\n}\nint s[N<<2],sz;\nint L,R,Mid,Res;\nvoid find(int len){\n\tL=1,R=sz,Res=0;\n\twhile(L<=R){\n\t\tMid=(L+R)>>1;\n\t\tmxlen[s[Mid]]>=len?\n\t\tRes=Mid,R=Mid-1:L=Mid+1;\n\t}\n\tRes=s[Res];\n}\nint f[N<<1];\ninline int getf(int x){\n\twhile(x!=f[x])x=f[x]=f[f[x]];\n\treturn x;\n}\nvoid dfs(int x){\n\ts[++sz]=x;f[x]=x;\n\tfor(int i=h[x];i;i=nextn[i]){\n\t\tinq &q=qq[to[i]];qb[i]?\n\t\t(find(q.lx),q.x=Res):\n\t\t(find(q.ly),q.y=Res);\n\t\tif(q.x&&q.y){\n\t\t\tstatic int xx,yy;\n\t\t\txx=getf(q.x);\n\t\t\tyy=getf(q.y);\n\t\t\tq.z=dep[xx]<dep[yy]?xx:yy;\n\t\t}\n\t}\n\tif(son[x][0])dfs(son[x][0]);\n\tif(son[x][1])dfs(son[x][1]);\n\t--sz;f[x]=link[x];\n}\nchar ch;\ninline void read(int &x){\n\tx=0;ch=getchar();while(ch<48)ch=getchar();\n\twhile(ch>47)x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n}\ninline void read(bool &x){\n\tch=getchar();while(ch<48)ch=getchar();\n\tx=ch^50;\n}\nvoid write(unsigned x){if(x>9)write(x/10);putchar(48|x%10);}\nint main(){\n\tint n,m,i,x,y,z,lz;\n\tread(n),read(m);f[n+1]=n+1;\n\twhile(ch<48)ch=getchar();\n\tfor(i=1;i<=n;++i)a[i]=ch^48,ch=getchar();\n\tfor(i=n;i>=1;--i){\n\t\textend(a[i]),s[i]=tmp;\n\t\ta[i]?f[i]=i:f[i]=f[i+1]; \n\t}\n\tn_t=tot;\n\tmemset(t,0,sizeof(t));\n\tfor(i=2;i<=tot;++i)add(link[i],i);\n\tinit(1);\n\tfor(i=1;i<=m;++i){\n\t\tread(a[i]);\n\t\tread(l),read(r);l=f[l];\n\t\tif(l>r){\n\t\t\tread(l);\n\t\t\tif(!a[i])read(l);\n\t\t\tcontinue;\n\t\t}\n\t\tqq[i].lx=r-l+1;\n\t\taddq(s[l],i,1);\n\t\tif(a[i]){read(qq[i].z);continue;}\n\t\tread(l),read(r);l=f[l];\n\t\tif(l>r)continue;\n\t\tqq[i].ly=r-l+1;\n\t\taddq(s[l],i,0);\n\t}\n\tdfs(1);\n\tfor(i=1;i<=tot;++i)h[i]=0;edg=0;\n\tfor(i=1;i<=m;++i){\n\t\tif(a[i]&&qq[i].x){\n\t\t\tupdate(qq[i].x,qq[i].lx,qq[i].z);\n\t\t\taddq(qq[i].x,i,1);\n\t\t}\n\t\tif(!a[i]&&qq[i].x&&qq[i].y){\n\t\t\tx=qq[i].x,y=qq[i].y,z=qq[i].z;\n\t\t\tinquiry(x,qq[i].lx);\n\t\t\tinquiry(y,qq[i].ly);\n\t\t\taddq(x,i,1);addq(y,i,2);\n\t\t\tans[i]=res;res=0;\n\t\t\tif(z!=x&&z!=y)inquiry(z,lz=mxlen[z]);\n\t\t\telse if(z!=y)inquiry(z,lz=qq[i].lx);\n\t\t\telse if(z!=x)inquiry(z,lz=qq[i].ly);\n\t\t\telse inquiry(z,lz=min(qq[i].lx,qq[i].ly));\n\t\t\tqq[i].x=lz;addq(z,i,3);\n\t\t\tlz-1>mxlen[link[z]]?\n\t\t\t(inquiry(z,lz-1),addq(z,i,4)):\n\t\t\t(inquiry(link[z],lz-1),addq(link[z],i,4));\n\t\t\tqq[i].y=lz-1;ans[i]-=res;res=0;\n\t\t}\n\t}\n\tmemset(t,0,sizeof(t));\n\tfor(x=1;x<=tot;++x)if(h[x]){\n\t\tsz=0;n_t=mxlen[x];\n\t\tfor(i=h[x];i;i=nextn[i])\n\t\t\ts[++sz]=to[i],link[sz]=i;\n\t\tfor(i=sz;i;--i){\n\t\t\tinq &q=qq[s[i]];\n\t\t\tif(a[s[i]])rupdate_t(q.lx,q.z);\n\t\t\telse {\n\t\t\t\tswitch(qb[link[i]]){\n\t\t\t\t\tcase 1:{rinquiry_t(q.lx);break;}\n\t\t\t\t\tcase 2:{rinquiry_t(q.ly);break;}\n\t\t\t\t\tcase 3:{rinquiry_t(q.x);break;}\n\t\t\t\t\tcase 4:{rinquiry_t(q.y);break;}\n\t\t\t\t}\n\t\t\t\tans[s[i]]+=qb[link[i]]<3?-res:res;\n\t\t\t} \n\t\t}\n\t\tfor(i=sz;i;--i)if(a[s[i]])rclear_t(qq[s[i]].lx);\n\t}\n\tfor(i=1;i<=m;++i)if(!a[i])write(ans[i]),putchar('\\n');\n}\n```",
        "postTime": 1667484053,
        "uid": 334380,
        "name": "Y_B_X",
        "ccfLevel": 7,
        "title": "\u9898\u89e3[P7982 \u7434\u7434\u7684\u6811]"
    },
    {
        "content": "> [P7982 [JRKSJ R3] \u7434\u7434\u7684\u6811](https://www.luogu.com.cn/problem/P7982)\n\n\u4ee5\u4e0b\u4ec5\u8ba8\u8bba\u5b50\u4e32\u5f00\u5934\u5b57\u7b26\u4e3a $\\texttt 1$ \u7684\u60c5\u51b5\uff0c\u82e5\u975e\u5219\u4ee4\u5de6\u7aef\u70b9 $l\\gets rt_l$\uff0c\u5176\u4e2d $rt_i$ \u8868\u793a $i$ \u53f3\u8fb9\u7b2c\u4e00\u4e2a $\\texttt 1$ \u7684\u4f4d\u7f6e\u3002\n\n\u8bbe $L_x = r_x - l_x + 1$\uff0c$L_y = r_y - l_y + 1$\uff0c$s[l_x, r_x]$ \u5bf9\u5e94 SAM \u8282\u70b9 $x$\uff0c$y$ \u540c\u7406\u3002\n\n\u64cd\u4f5c\u4e00\u5c06\u6240\u6709\u4ee5 $s[l_x, r_x]$ \u4e3a\u524d\u7f00\u7684\u5b57\u7b26\u4e32\u7684\u6743\u503c\u589e\u52a0 $v$\uff0c\u64cd\u4f5c\u4e8c\u67e5\u8be2 $s[l_x, r_x]$ \u548c $s[l_y, r_y]$ \u7684\u6240\u6709\u957f\u5ea6\u4e0d\u5c0f\u4e8e $A = lcp(s[l_x, r_x], s[l_y, r_y])$ \u7684\u524d\u7f00\u7684\u6743\u503c\u4e4b\u548c\u3002\n\n\u8003\u8651\u5230\u6240\u6709\u6d89\u53ca\u5230\u7684\u5b57\u7b26\u4e32\u5747\u4e3a $s$ \u7684\u5b50\u4e32\uff0c\u5efa\u51fa $s$ \u7684 SAM\uff0c\u95ee\u9898\u76f8\u5f53\u4e8e\u88f8\u5b50\u6811\u52a0\u94fe\u6c42\u548c\u3002\u76f4\u63a5\u505a\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}(n + q\\log ^ 2 n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}(n + q)$\u3002\n\n\u56e0\u4e3a SAM link \u6811\u4e0a\u4e00\u4e2a\u8282\u70b9\u5bf9\u5e94\u591a\u4e2a\u5b50\u4e32\uff0c\u6240\u4ee5\u9700\u8981\u7279\u6b8a\u5904\u7406\u7aef\u70b9\u5904\u7684\u4fee\u6539\u548c\u8d21\u732e\uff1a\n\n- \u975e\u7aef\u70b9\u5904\u4fee\u6539\u5bf9\u975e\u7aef\u70b9\u5904\u67e5\u8be2\u7684\u8d21\u732e\uff1a\u5b50\u6811\u52a0\uff0c\u94fe\u6c42\u548c\uff0c\u6ce8\u610f\u4e00\u4e2a\u70b9\u7684\u6743\u503c $a_i$ \u52a0 $v$ \u5219\u5176\u8d21\u732e\u589e\u52a0 $vstr_i$\uff0c\u5176\u4e2d $str_i$ \u8868\u793a\u8282\u70b9 $i$ \u5b50\u4e32\u4e2a\u6570\u3002\u76f8\u5f53\u4e8e\u5bf9 $a_i$ \u533a\u95f4\u52a0\uff0c\u533a\u95f4\u6c42 $a_ib_i$ \u7684\u548c\u3002\u7528\u7ebf\u6bb5\u6811\u5199\u4f1a\u88ab\u5361\u5e38\u5361\u7a7a\u95f4\uff0c\u5bf9 $b_i$ \u505a\u524d\u7f00\u548c\u62c6\u8d21\u732e\u53ef\u4ee5\u7528\u4e24\u4e2a BIT \u7ef4\u62a4\uff0c\u7c7b\u4f3c BIT \u533a\u95f4\u52a0\u533a\u95f4\u6c42\u548c\u3002\n- \u975e\u7aef\u70b9\u5904\u4fee\u6539\u5bf9\u7aef\u70b9\u5904\u67e5\u8be2\u7684\u8d21\u732e\uff1a\u7ef4\u62a4 $c_i$ \u8868\u793a $i$ \u4f5c\u4e3a\u975e\u7aef\u70b9\u7684\u4fee\u6539\u503c\u4e4b\u548c\uff0c\u4fee\u6539\u65f6\u533a\u95f4\u4fee\u6539 $c$\u3002\u5bf9\u4e8e $x$ \u8d21\u732e\u52a0\u4e0a $(L_x - len(fa(x)))c_x$\uff0c\u5176\u4e2d $L_x - len(fa(x))$ \u8868\u793a\u672c\u6b21\u67e5\u8be2\u6d89\u53ca\u5230\u8282\u70b9 $x$ \u7684\u5b50\u4e32\u6570\u91cf\u3002\u5bf9\u4e8e $y$ \u540c\u7406\u3002\u6ce8\u610f\u7279\u5224 $x = y$ \u7684\u60c5\u51b5\uff0c\u6b64\u65f6\u8d21\u732e\u4e3a $(\\max(L_x, L_y) - \\min(L_x, L_y) + 1)c_x$\u3002\n- \u7aef\u70b9\u5904\u4fee\u6539\u5bf9\u975e\u7aef\u70b9\u5904\u67e5\u8be2\u7684\u8d21\u732e\uff1a\u7ef4\u62a4 $d_i$ \u8868\u793a $i$ \u4f5c\u4e3a\u7aef\u70b9\u7684\u4fee\u6539\u503c\u4e4b\u548c\uff0c\u6ce8\u610f\u4e58\u4ee5\u4ea7\u751f\u8d21\u732e\u7684\u5b50\u4e32\u6570\u91cf\u3002\u4fee\u6539\u7ed9 $d_x$ \u52a0\u4e0a $(len(x) - L_x + 1) v$\uff0c\u67e5\u8be2\u533a\u95f4\u67e5\u8be2\u3002\n- \u7aef\u70b9\u5904\u4fee\u6539\u5bf9\u7aef\u70b9\u5904\u67e5\u8be2\u7684\u8d21\u732e\uff1a\u4e3a\u6bcf\u4e2a $x$ \u5f00\u7ebf\u6bb5\u6811 $T_x$ \u7ef4\u62a4 $x$ \u5728\u4f5c\u4e3a\u7aef\u70b9\u88ab\u4fee\u6539\u65f6\u6bcf\u4e2a\u5b50\u4e32\u7684\u6743\u503c\uff0c\u4fee\u6539\u5bf9 $T_x$ \u533a\u95f4\u52a0\uff0c\u67e5\u8be2\u5bf9 $T_x$ \u533a\u95f4\u67e5\u8be2\u3002\u7a7a\u95f4\u590d\u6742\u5ea6\u65e0\u6cd5\u63a5\u53d7\uff0c\u79bb\u7ebf BIT \u5904\u7406\u3002\n\n\u6ce8\u610f\u5f53 $x, y$ \u4e0d\u4e3a\u7956\u5148\u540e\u4ee3\u5173\u7cfb\u65f6\uff0c\u5b83\u4eec\u7684 LCA $D$ \u4ec5\u6709\u6700\u957f\u4e32\u4ea7\u751f\u8d21\u732e\uff0c\u6240\u4ee5\u9700\u7ef4\u62a4 $e_i$ \u8868\u793a $i$ \u4f5c\u4e3a\u7aef\u70b9\u7684\u4fee\u6539\u503c\u4e4b\u548c\u4ee5\u5feb\u901f\u6c42\u51fa\u8d21\u732e\uff0c\u8fd9\u90e8\u5206\u662f\u5355\u70b9\u4fee\u6539\u5355\u70b9\u67e5\u8be2\u3002\n\n\u8fd9\u9898\u6700\u5927\u7684\u96be\u70b9\u5728\u4e8e\u53ea\u7ed9\u4e86 64MB\uff1a\n\n- SAM \u4e94\u4e2a\u6570\u7ec4\uff1a`son * 2, len, fa, ed`\u3002\n- \u6811\u5256\u516d\u4e2a\u6570\u7ec4\uff1a`sz, son, dep, dfn, rev, top`\uff0c`fa` \u7b97\u5728 SAM \u90e8\u5206\u3002\n- \u4e24\u4e2a\u5355\u70b9\u4fee\u6539\u533a\u95f4\u67e5\u8be2 / \u533a\u95f4\u4fee\u6539\u5355\u70b9\u67e5\u8be2 BIT\uff1a`c, d`\u3002\n- \u4e00\u4e2a\u533a\u95f4\u4fee\u6539\u533a\u95f4\u67e5\u8be2 BIT\uff0c\u4e09\u4e2a\u6570\u7ec4\uff1a`Sb, a1, a2`\uff0c\u5176\u4e2d $Sb$ \u8868\u793a $b$ \u524d\u7f00\u548c\u3002\n- \u5efa\u6811\u7684\u94fe\u5f0f\u524d\u5411\u661f `hd, nxt, to`\u3002\n- \u7b2c\u56db\u90e8\u5206\u79bb\u7ebf\u8be2\u95ee BIT \u7684\u94fe\u5f0f\u524d\u5411\u661f `hd, nxt, l, r, v` \u548c\u4e00\u4e2a\u5e03\u5c14\u6570\u7ec4 `type` \u8868\u793a\u4fee\u6539\u6216\u67e5\u8be2\u3002\u6ce8\u610f\u94fe\u5f0f\u524d\u5411\u661f\u662f\u53cd\u7740\u7684\uff0c\u6240\u4ee5\u4e3a\u6309\u65f6\u95f4\u987a\u5e8f\u5904\u7406\uff0c\u8bb0\u5f55 `pre` \u5b9e\u73b0\u53cc\u5411\u94fe\u8868\u3002BIT \u53ef\u76f4\u63a5\u7528\u4e4b\u524d\u7684\u533a\u95f4\u4fee\u6539\u533a\u95f4\u67e5\u8be2 BIT\u3002\n- \u4e00\u4e9b\u6742\u4e03\u6742\u516b\u7684\u6570\u7ec4\uff1a\u5b57\u7b26\u4e32 `s`\uff0c\u7aef\u70b9\u4fee\u6539\u503c `e`\uff0c\u79bb\u7ebf BIT \u7b54\u6848\u6570\u7ec4 `ans`\uff0c\u8fd8\u6709\u4e00\u5f00\u59cb\u7684 `rt`\u3002\n\n\u56e0\u4e3a SAM \u6709\u4e24\u500d\u8282\u70b9\uff0c\u6240\u4ee5\u4e00\u4e9b\u6570\u7ec4\u662f $2n$ \u7684\u3002\u7b97\u4e00\u4e0b\u7a7a\u95f4\u590d\u6742\u5ea6\u80af\u5b9a\u70b8\u4e86\uff0c\u9700\u8981\u6781\u5176\u7cbe\u7ec6\u5730\u5b9e\u73b0\u624d\u53ef\u901a\u8fc7\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u91cd\u590d\u5229\u7528\u4e0d\u4f1a\u540c\u65f6\u4f7f\u7528\u7684\u6570\u7ec4\uff0c\u5c06\u5927\u5c0f\u4e3a $X$ \u4e14\u503c\u57df $\\leq 10 ^ 6$ \u7684\u6570\u7ec4\u7528\u5927\u5c0f\u4e3a $\\dfrac {2X} 3$ \u7684\u6570\u7ec4\u4ee3\u66ff\uff08\u4f46\u662f\u4e0d\u80fd\u4ee3\u66ff\u592a\u591a\u5426\u5219\u8dd1\u5f97\u592a\u6162\uff09\uff0c\u7528 `bitset` \u4ee3\u66ff\u5e03\u5c14\u6570\u7ec4\u3002\n\n\u5361\u7a7a\u95f4 + \u5361\u5e38\u82b1\u4e86\u56db\u4e2a\u5c0f\u65f6\uff0c\u5efa\u8bae\u51fa\u9898\u4eba\u81ea\u88c1\uff0c\u6216\u8005\u65f6\u95f4\u5f00\u5230 2s\uff0c\u7a7a\u95f4\u5f00\u5230\u81f3\u5c11 128MB\u3002\n\n```cpp\n// \u5361\u4f60\u5988\u7a7a\u95f4\u554a\n// \u5361\u4f60\u5988\u5e38\u554a\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\nbool Mbe;\nchar buf[1 << 16], *p1 = buf, *p2 = buf;\n#define gc (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 16, stdin), p1 == p2) ? EOF : *p1++)\ninline int read() {\n  int x = 0;\n  char s = gc;\n  while(!isdigit(s)) s = gc;\n  while(isdigit(s)) x = x * 10 + s - '0', s = gc;\n  return x;\n}\nconstexpr int N = 8e5 + 5;\nconstexpr int M = 4e5 + 5;\nstruct ArrayM {\n  int val[M * 2 / 3];\n  ArrayM () {memset(val, 0, sizeof(val));}\n  void assign(int x, int v) {\n    int c = x / 3, r = x % 3;\n    if(r == 0) val[c << 1] |= v;\n    if(r == 1) val[c << 1] |= (v & 1023) << 20, val[c << 1 | 1] |= v >> 10;\n    if(r == 2) val[c << 1 | 1] |= v << 10;\n  }\n  int operator [] (int x) {\n    int c = x / 3, r = x % 3;\n    if(r == 0) return val[c << 1] & 1048575;\n    if(r == 1) return (val[c << 1] >> 20) | ((val[c << 1 | 1] & 1023) << 10);\n    if(r == 2) return val[c << 1 | 1] >> 10;\n  }\n} ed, suf;\nstruct ArrayN {\n  int val[N * 2 / 3];\n  ArrayN () {memset(val, 0, sizeof(val));}\n  void assign(int x, int v) {\n    int c = x / 3, r = x % 3;\n    if(r == 0) val[c << 1] |= v;\n    if(r == 1) val[c << 1] |= (v & 1023) << 20, val[c << 1 | 1] |= v >> 10;\n    if(r == 2) val[c << 1 | 1] |= v << 10;\n  }\n  int operator [] (int x) {\n    int c = x / 3, r = x % 3;\n    if(r == 0) return val[c << 1] & 1048575;\n    if(r == 1) return (val[c << 1] >> 20) | ((val[c << 1 | 1] & 1023) << 10);\n    if(r == 2) return val[c << 1 | 1] >> 10;\n  }\n} top;\nint cnt = 1, len[N], fa[N];\nnamespace SAM {\n  int las = 1, son[2][N];\n  void ins(int it) {\n    int cur = ++cnt, p = las;\n    ed.assign(len[cur] = len[p] + 1, cur);\n    las = cur;\n    while(!son[it][p]) son[it][p] = cur, p = fa[p];\n    if(!p) return fa[cur] = 1, void();\n    int q = son[it][p];\n    if(len[p] + 1 == len[q]) return fa[cur] = q, void();\n    int cl = ++cnt;\n    son[0][cl] = son[0][q], son[1][cl] = son[1][q];\n    len[cl] = len[p] + 1, fa[cl] = fa[q], fa[q] = fa[cur] = cl;\n    while(son[it][p] == q) son[it][p] = cl, p = fa[p];\n  }\n}\nchar s[M];\nint n, m, Q;\nuint ans[M], c[N];\nint *son = SAM::son[0], *sz = SAM::son[1], dep[N];\nint dn, dfn[N], *rev = son;\nuint E, hd[N], nxt[N], to[N];\nvoid add(int u, int v) {nxt[++E] = hd[u], hd[u] = E, to[E] = v;}\nbool isanc(int u, int v) {return dfn[u] <= dfn[v] && dfn[v] < dfn[u] + sz[u];}\nvoid dfs1(int id) {\n  sz[id] = 1, dep[id] = dep[fa[id]] + 1;\n  for(int i = hd[id]; i; i = nxt[i]) {\n    dfs1(to[i]), sz[id] += sz[to[i]];\n    if(sz[son[id]] < sz[to[i]]) son[id] = to[i];\n  }\n}\nvoid dfs2(int id, int tp) {\n  dfn[id] = ++dn, top.assign(id, tp);\n  if(son[id]) dfs2(son[id], tp);\n  for(int i = hd[id]; i; i = nxt[i]) if(to[i] != son[id]) dfs2(to[i], to[i]); \n}\nint locate(int l, int r) {\n  if(l > r) return 0;\n  int x = ed[r], L = r - l + 1;\n  while(1) {\n    int tp = top[x];\n    if(len[fa[tp]] >= L) {x = fa[tp]; continue;}\n    l = dfn[tp], r = dfn[x];\n    while(l < r) {\n      int m = l + r >> 1;\n      len[rev[m]] >= L ? r = m : l = m + 1;\n    }\n    return rev[l];\n  }\n}\nstruct BIT1 {\n  uint *c = hd, *c2 = nxt, *val = to;\n  void init(int type) {\n    memset(c, 0, N << 2);\n    memset(c2, 0, N << 2);\n    memset(val, 0, N << 2);\n    for(int i = 1; i <= cnt; i++) { // 2 -> 1\n      val[i] = val[i - 1];\n      if(type == 1) val[i] += len[rev[i]] - len[fa[rev[i]]];\n      else val[i] += 1;\n    }\n  }\n  void add(int x, uint v) {\n    uint v2 = v * val[x - 1];\n    while(x <= cnt) c[x] += v, c2[x] += v2, x += x & -x;\n  }\n  void add(int l, int r, int v) {add(l, v), add(r + 1, -v);}\n  uint query(int x) {\n    uint s = 0, s2 = 0, coef = val[x];\n    while(x) s += c[x], s2 += c2[x], x -= x & -x;\n    return coef * s - s2;\n  }\n  uint query(int l, int r) {return query(r) - query(l - 1);}\n} tr;\nstruct BIT2 {\n  uint c[N];\n  void add(int x, uint v) {while(x <= cnt) c[x] += v, x += x & -x;}\n  void add(int l, int r, uint v) {add(l, v), add(r + 1, -v);}\n  uint query(int x) {uint s = 0; while(x) s += c[x], x -= x & -x; return s;}\n  uint query(int l, int r) {return query(r) - query(l - 1);}\n} val, sumv;\nuint *pre = val.c;\nstruct OFFLINE {\n  int cnt, hd[N], v[N];\n  ArrayN nxt, l, r;\n  bitset<N> type;\n  void add(int u, bool _t, int _l, int _r, int _v) {\n    nxt.assign(++cnt, hd[u]), hd[u] = cnt;\n    type[cnt] = _t;\n    l.assign(cnt, _l);\n    r.assign(cnt, _r);\n    v[cnt] = _v;\n  }\n} e;\nbool Med;\nint main() {\n  fprintf(stderr, \"%.4lf MB\\n\", (&Mbe - &Med) / 1048576.0);\n  #ifdef ALEX_WEI\n    freopen(\"1.in\", \"r\", stdin);\n    freopen(\"1.out\", \"w\", stdout);\n  #endif\n  cin >> n >> m >> s + 1;\n  suf.assign(n + 1, n + 1); // add this line\n  for(int i = n; i; i--) suf.assign(i, s[i] == '0' ? suf[i + 1] : i);\n  for(int i = n; i; i--) SAM::ins(s[i] - '0');\n  for(int i = 2; i <= cnt; i++) add(fa[i], i);\n  memset(SAM::son, 0, N << 3); // add this line\n  dfs1(1), dfs2(1, 1);\n  for(int i = 1; i <= cnt; i++) rev[dfn[i]] = i;\n  tr.init(1);\n  for(int i = 1; i <= m; i++) {\n    int op, l, r, x, lx, y, ly;\n    op = read(), l = suf[read()], r = read();\n    Q += op == 2;\n    x = locate(n - r + 1, n - l + 1), lx = r - l + 1;\n    if(op == 1) {\n      y = read();\n      if(l > r) continue;\n      tr.add(dfn[x] + 1, dfn[x] + sz[x] - 1, y);\n      sumv.add(dfn[x], 1u * y * (len[x] - lx + 1)); // delete one dfn[x]\n      val.add(dfn[x] + 1, dfn[x] + sz[x] - 1, y), c[dfn[x]] += y;\n      e.add(x, 1, lx, len[x], y);\n    }\n    else {\n      l = suf[read()], r = read();\n      if(l > r || !x) continue;\n      y = locate(n - r + 1, n - l + 1), ly = r - l + 1;\n      if(dep[x] < dep[y]) swap(x, y), swap(lx, ly);\n      int u = x, v = y;\n      if(u == v) {\n        if(lx > ly) swap(x, y), swap(lx, ly);\n        ans[Q] += val.query(dfn[x]) * (ly - lx + 1); // add this line\n        e.add(x, 0, min(lx, ly), max(lx, ly), Q);\n        continue;\n      }\n      ans[Q] += val.query(dfn[x]) * (lx - len[fa[x]]);\n      e.add(x, 0, len[fa[x]] + 1, lx, Q), u = fa[u];\n      if(!isanc(y, x)) v = fa[v];\n      while(1) {\n        int tpu = top[u], tpv = top[v];\n        if(tpu == tpv) break;\n        if(dep[tpu] < dep[tpv]) swap(u, v), swap(tpu, tpv);\n        ans[Q] += tr.query(dfn[tpu], dfn[u]);\n        ans[Q] += sumv.query(dfn[tpu], dfn[u]);\n        u = fa[tpu];\n      }\n      if(dfn[u] > dfn[v]) swap(u, v);\n      ans[Q] += tr.query(dfn[u] + 1, dfn[v]);\n      ans[Q] += sumv.query(dfn[u] + 1, dfn[v]); // add this line\n      if(isanc(y, x)) {\n        e.add(y, 0, ly, len[y], Q);\n        ans[Q] += val.query(dfn[y]) * (len[y] - ly + 1);\n      }\n      else {\n        e.add(y, 0, len[fa[y]] + 1, ly, Q);\n        ans[Q] += val.query(dfn[u]); // v -> u\n        ans[Q] += c[dfn[u]]; // v -> u\n        ans[Q] += val.query(dfn[y]) * (ly - len[fa[y]]); // swap ly - len[fa[y]] and len[y] - ly + 1\n      }\n    }\n  }\n  tr.init(2);\n  memset(pre, 0, N << 2);\n  for(int i = 1; i <= cnt; i++) {\n    int lst = 0;\n    for(int j = e.hd[i]; j; j = e.nxt[j]) pre[j] = lst, lst = j;\n    for(int j = lst; j; j = pre[j]) {\n      int t = e.type[j], l = e.l[j], r = e.r[j], v = e.v[j];\n      if(t == 1) tr.add(l, r, v);\n      else ans[v] += tr.query(l, r);\n    }\n    for(int j = lst; j; j = pre[j]) {\n      int t = e.type[j], l = e.l[j], r = e.r[j], v = e.v[j];\n      if(t == 1) tr.add(l, r, -v);\n    }\n  }\n  for(int i = 1; i <= Q; i++) printf(\"%u\\n\", ans[i]);\n  return cerr << 1e3 * clock() / CLOCKS_PER_SEC << \" ms\\n\", 0;\n}\n/*\n2022/7/24\nstart coding at 11:48\nfinish debugging at ??:??\n*/\n```",
        "postTime": 1659879088,
        "uid": 123294,
        "name": "Alex_Wei",
        "ccfLevel": 10,
        "title": "P7982 [JRKSJ R3] \u7434\u7434\u7684\u6811"
    }
]