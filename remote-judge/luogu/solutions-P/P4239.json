[
    {
        "content": "\u8fd9\u79cd\u9898\u76ee\uff0c\u6ca1\u6709\u9898\u89e3\u53ea\u9760\u81ea\u5df1\u6539\u771f\u7684\u60f3\u6b7b\u3002\u3002\u3002\n\n\u591a\u9879\u5f0f\u600e\u4e48\u6c42\u9006\u8bf7\u51fa\u95e8\u5de6\u8f6c\u770b\u591a\u9879\u5f0f\u6c42\u9006\u7684\u6a21\u677f\n\n\u8fd9\u91cc\u7684\u6a21\u6570\u4e0d\u662f$998244353$\u4e86\u3002\n\n\u5bf9\u4e8e\u4efb\u610f\u6a21\u6570\u7684$FFT$\uff0c\u4e5f\u53ef\u4ee5\u51fa\u95e8\u53f3\u8f6c\u770b$MTT$\u7684\u6a21\u677f\u9898\n\n\u8fd9\u6837\u6211\u4eec\u5c31\u5f97\u5230\u4e86$MTT$+\u591a\u9879\u5f0f\u6c42\u9006\u7684\u6a21\u677f\u4e86\n\n\uff08\u771f\u7684\u5199\u6b7b\u4eba\uff09\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define RG register\n#define MAX 444444\n#define MOD (1000000007)\nconst double Pi=acos(-1);\nconst int m=sqrt(MOD);\ninline int read()\n{\n    RG int x=0,t=1;RG char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=-1,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return x*t;\n}\nint fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}\nstruct Complex{double a,b;}W[MAX],A[MAX],B[MAX],C[MAX],D[MAX];\nComplex operator+(Complex a,Complex b){return (Complex){a.a+b.a,a.b+b.b};}\nComplex operator-(Complex a,Complex b){return (Complex){a.a-b.a,a.b-b.b};}\nComplex operator*(Complex a,Complex b){return (Complex){a.a*b.a-a.b*b.b,a.a*b.b+a.b*b.a};}\nint r[MAX];\nvoid FFT(Complex *P,int N,int opt)\n{\n\tfor(int i=0;i<N;++i)if(i<r[i])swap(P[i],P[r[i]]);\n\tfor(int i=1;i<N;i<<=1)\n\t\tfor(int p=i<<1,j=0;j<N;j+=p)\n\t\t\tfor(int k=0;k<i;++k)\n\t\t\t{\n\t\t\t\tComplex w=(Complex){W[N/i*k].a,W[N/i*k].b*opt};\n\t\t\t\tComplex X=P[j+k],Y=P[i+j+k]*w;\n\t\t\t\tP[j+k]=X+Y;P[i+j+k]=X-Y;\n\t\t\t}\n\tif(opt==-1)for(int i=0;i<N;++i)P[i].a/=1.0*N;\n}\nvoid Multi(int *a,int *b,int len,int *ret)\n{\n\tfor(int i=0;i<(len<<1);++i)A[i]=B[i]=C[i]=D[i]=(Complex){0,0};\n\tfor(int i=0;i<len;++i)\n\t{\n\t\ta[i]%=MOD;b[i]%=MOD;\n\t\tA[i]=(Complex){(a[i]/m)*1.0,0};\n\t\tB[i]=(Complex){(a[i]%m)*1.0,0};\n\t\tC[i]=(Complex){(b[i]/m)*1.0,0};\n\t\tD[i]=(Complex){(b[i]%m)*1.0,0};\n\t}\n\tint N,l=0;\n\tfor(N=1;N<=len;N<<=1)++l;\n\tfor(int i=0;i<N;++i)r[i]=(r[i>>1]>>1)|((i&1)<<(l-1));\n\tfor(int i=1;i<N;i<<=1)\n\t\tfor(int k=0;k<i;++k)W[N/i*k]=(Complex){cos(k*Pi/i),sin(k*Pi/i)};\n\tFFT(A,N,1);FFT(B,N,1);FFT(C,N,1);FFT(D,N,1);\n\tfor(int i=0;i<N;++i)\n\t{\n\t\tComplex tmp=A[i]*C[i];\n\t\tC[i]=B[i]*C[i],B[i]=B[i]*D[i],D[i]=D[i]*A[i];\n\t\tA[i]=tmp;C[i]=C[i]+D[i];\n\t}\n\tFFT(A,N,-1);FFT(B,N,-1);FFT(C,N,-1);\n\tfor(int i=0;i<len;++i)\n\t{\n\t\tret[i]=0;\n\t\tret[i]=(ret[i]+1ll*(ll)(A[i].a+0.5)%MOD*m%MOD*m%MOD)%MOD;\n\t\tret[i]=(ret[i]+1ll*(ll)(C[i].a+0.5)%MOD*m%MOD)%MOD;\n\t\tret[i]=(ret[i]+1ll*(ll)(B[i].a+0.5)%MOD)%MOD;\n\t\tret[i]=(ret[i]+MOD)%MOD;\n\t}\n}\nint c[MAX],d[MAX];\nvoid Inv(int *a,int *b,int len)\n{\n\tif(len==1){b[0]=fpow(a[0],MOD-2);return;}\n\tInv(a,b,len>>1);\n\tMulti(a,b,len,c);\n\tMulti(c,b,len,d);\n\tfor(int i=0;i<len;++i)b[i]=(b[i]+b[i])%MOD;\n\tfor(int i=0;i<len;++i)b[i]=(b[i]+MOD-d[i])%MOD;\n}\nint n,a[MAX],b[MAX];\nint main()\n{\n\tn=read();int N;\n\tfor(int i=0;i<n;++i)a[i]=read();\n\tfor(N=1;N<n;N<<=1);\n\tInv(a,b,N);\n\tfor(int i=0;i<n;++i)printf(\"%d \",b[i]);\n\treturn 0;\n}\n\n```",
        "postTime": 1523433402,
        "uid": 21283,
        "name": "yybyyb",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4239 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6c42\u9006\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "\u6a21\u6570\u662f\u8d28\u6570\uff0c\u53ef\u4ee5\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u6700\u521d\u9879\u7684\u4e58\u6cd5\u9006\u5143\uff0c\u53ef\u8fd9\u4e0d\u6ee1\u8db3NTT\u7684\u6027\u8d28\uff0c\u4e0d\u80fd\u76f4\u63a5\u7528\u539f\u6839\u641e\uff0c\u8981MTT\u62163\u6a21NTT\uff0c\u7b14\u8005\u8fd9\u91cc\u91c7\u7528\u7684\u662f\u5229\u7528\u590d\u6570\u5171\u8f6d\u6027\u8d28\uff08\u4e09\u6b21\u53d8\u4e24\u6b21\u4f18\u5316\uff1f\uff09\u76845\u6b21FFT\uff0c\u6bd44\u6b21\u7684\u7a0d\u5fae\u6162\u4e00\u70b9\u4f46\u597d\u60f3\u3002\n\n\u4e0d\u59a8\u4ee4\uff1a\n$$a_1 = a / c$$\n$$a_0 = a - a_1$$\n\n\u540c\u7406\uff1a\n$$b_1 = b / c$$\n$$b_0 = b - b_1$$\n\n\u8fd9\u91cc\u53d6\n$$c = 32767 (2^{15} - 1)$$\n\n\u6211\u4eec\u5c31\u53ef\u4ee5\u62c6\u7cfb\u6570\u4fdd\u6301\u7cbe\u5ea6FFT\u8fa3~~~\n\n\u7136\u540e\uff0c\u6734\u7d20\u7b97\u6cd5\u662f\u9700\u8981\u8c03\u75287\u6b21FFT\u3002\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u6784\u9020\u590d\u6570\uff1a\n$$f = a_0 + a_1i$$\n$$h = a_0 - a_1i$$\n$$g = b_0 + b_1i$$\n\u6240\u4ee5\n$$f * g = a_0b_0 + (a_1b_0 + a_0b_1)i - a_1b_1$$\n$$h * g = a_0b_0 - (a_1b_0 - a_0b_1)i + a_1b_1$$\n\u6211\u4eec\u5c31\u53ef\u4ee5\u901a\u8fc7\u4e24\u5f0f\u52a0\u51cf\u6765\u5f97\u5230\n$$a_0b_0 \\ a_1b_1 \\ a_1b_0 \\ a_0b_1$$\n\u6211\u4eec\u5b9e\u9645\u4e0a\u53ea\u9700\u8981\u5148dft\u51fa  $f \\ h \\ g$ \u518d\u628a\u4e24\u4e2a\u7b54\u6848\u6570\u7ec4idft\u5373\u53ef\u3002\n\n\u53c2\u8003[command_block\u5927\u4f6c\u535a\u5ba2](https://www.luogu.com.cn/blog/command-block/solution-p4245)\n\n\u7136\u540e\u5c31\u662f\u500d\u589e\u6c42\u4e58\u6cd5\u9006\u3002\n\n\u6211\u4eec\u8981\u6c42 $F(x)$ \u7684\u4e58\u6cd5\u9006 $G(x)$ \u6ee1\u8db3\n\n$$F(x)G(x) \\equiv 1 \\pmod{x^n}$$\n\n\u8003\u8651\u91c7\u7528\u500d\u589e\u6c42\u89e3\u3002\u5f53\u591a\u9879\u5f0f\u53ea\u5269\u4e00\u9879\u65f6\u76f4\u63a5\u8d39\u9a6c\u5c0f\u5b9a\u7406\u6c42\u89e3\uff0c\u7136\u540e\u500d\u589e\uff0c\uff08\u6211\u662f\u9006\u7740\u9012\u5f52\u7684\uff09\u3002\n\n\u5047\u5982\u6211\u4eec\u5df2\u77e5:\n\n$$F(x)H(x) \\equiv 1 \\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$$\n\n\u540c\u65f6\uff1a\n\n$$F(x)G(x) \\equiv 1 \\pmod{x^{\\lceil \\frac{n}{2} \\rceil}}$$\n\n\u6240\u4ee5\uff1a\n$$G(x) - H(x)\\equiv 0\\pmod{x^{\\lceil \\frac{n}{2} \\rceil}} $$\n\n\u5e73\u65b9\uff1a\n$$G(x)^2+H(x)^2-2G(x)H(x) \\equiv 0 \\pmod{x^n}$$\n\n\u56e0\u4e3a\uff1a\n$$F(x)G(x) \\equiv 1 \\pmod{x^n}$$\n\n\u4e24\u5f0f\u76f8\u4e58\uff1a\n$$G(x) \\equiv 2H(x)-F(x)H(x)^2 \\pmod{x^n}$$\n\n\u63a8\u5bfc\u53c2\u8003[CSDN](https://blog.csdn.net/litble/article/details/79828428)\n\n\u6211\u8fd9\u91cc\u6ca1\u6709\u50cf\u522b\u4eba\u4e00\u6837\u8865\u62102\u6b21\u5e42\u505a\uff0c\u76f4\u63a5\u5f80\u4e0b\u9012\u5f52\u8fdb\u884c\uff0c\u4f46\u8981\u4fdd\u8bc1\u5b50\u533a\u95f4\u4e25\u683c\u5927\u4e8e $length / 2$\u3002\n\n\u5373\uff1a\u8c03\u7528 $Inv(length + 1 >> 1, a, b)$\n\n\u8bf7\u6ce8\u610f\u5e38\u6570\uff0c\u624b\u5199\u590d\u6570\u7c7b\u3002\n\n\u6211\u8ba4\u4e3a\u6ca1\u5fc5\u8981\u9884\u5904\u7406\u5355\u4f4d\u6839\uff0c\u56e0\u4e3a\u4f1a\u6d6a\u8d39\u7a7a\u95f4\uff0c\u6709\u65f6\u8fd8\u4f1a\u8d1f\u4f18\u5316\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\nenum {\n\tMaxn = 300005\n};\n\nnamespace _MTT {\n\tconst long double PI = acos(-1.0);\n\tconst Complex I = Complex(1, 0);\n\tconst int mod = 1e9 + 7;\n\tint lim = 1, rev[Maxn];\n\tComplex f[Maxn], g[Maxn], h[Maxn];\n\t\n\tinline void FFT(int limit, Complex *arr, int type) {\n\t\tfor (int i = 0; i < limit; i++)\n\t\t\tif (i < rev[i]) swap(arr[i], arr[rev[i]]);\n\t\tfor (int mid = 1; mid < limit; mid <<= 1) {\n\t\t\tComplex tmp(cos(PI / mid), type * sin(PI / mid));\n\t\t\tfor (int i = 0; i < limit; i += mid << 1) { Complex w(1, 0);\n\t\t\t\tfor (register int j = 0; j < mid; j++, w = w * tmp) {\n\t\t\t\t\tComplex x = arr[i + j], y = w * arr[i + j + mid];\n\t\t\t\t\tarr[i + j] = x + y, arr[i + j + mid] = x - y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tinline void MTT(int *a, int *b, int n, int m, int *ret) {\n\t\tint c = sqrt(mod) + 1; int v = 1ll * c * c % mod; ll a0b0, a1b1, a0b1, a1b0;\n\t\tfor (int i = 0; i < lim; i++) f[i] = g[i] = h[i] = Complex(0, 0);\n\t\tfor (int i = 0; i < n; i++) f[i] = Complex(a[i] % c, a[i] / c), h[i] = f[i].Vary();\n\t\tfor (int i = 0; i < m; i++) g[i] = Complex(b[i] % c, b[i] / c);\n\t\tFFT(lim, f, 1), FFT(lim, g, 1), FFT(lim, h, 1);\n\t\tfor (int i = 0; i < lim; i++)\n\t\t\tg[i] = g[i] / lim, f[i] = f[i] * g[i], h[i] = h[i] * g[i];\n\t\tFFT(lim, f, -1), FFT(lim, h, -1);\n\t\tfor (int i = 0; i < lim; i++) {\n    \t\ta0b0 = ll(round((f[i].x + h[i].x) / 2.0)) % mod;\n    \t\ta0b1 = ll(round((f[i].y + h[i].y) / 2.0)) % mod;\n    \t\ta1b0 = ll(round(f[i].y) - a0b1) % mod;\n    \t\ta1b1 = ll(round(h[i].x) - a0b0) % mod;\n    \t\tret[i] = ll(a0b0 + 1ll * c * (a0b1 + a1b0) % mod) % mod;\n    \t\tret[i] = ll(ret[i] + 1ll * v * a1b1 % mod) % mod;\n    \t\tret[i] = ll(ret[i] + mod) % mod;\n\t\t}\n\t}\n} using namespace _MTT;\n\nint n;\nint f0[Maxn], g0[Maxn], c[Maxn], d[Maxn];\n\ninline int qpow(int a, int k = mod - 2) {\n\tint ret = 1;\n\tfor (; k; k >>= 1, a = 1ll * a * a % mod)\n\t\tif (k & 1) ret = 1ll * ret * a % mod;\n\treturn ret;\n}\n\ninline void Inv(int length, int *a, int *b) {\n\tif (length == 1) { b[0] = qpow(a[0]); return; }\n\tInv(length + 1 >> 1, a, b);\n\twhile (lim < 2 * length) lim <<= 1;\n\tfor (int i = 0; i < lim; i++) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (lim >> 1) : 0);\n\tMTT(a, b, length, length, c);\n\tMTT(c, b, length, length, d);\n\tfor (int i = 0; i < length; i++) b[i] = (b[i] + b[i]) % mod;\n\tfor (int i = 0; i < length; i++) b[i] = (b[i] - d[i] + mod) % mod;\n}\n\nsigned main(void) {\n//\tfile(\"\");\n\tread(n);\n\tfor (int i = 0; i < n; i++) read(f0[i]);\n\tInv(n, f0, g0); for (int i = 0; i < n; i++) println(g0[i], ' ');\n\tfwrite(pf, 1, o1 - pf, stdout);\n\treturn 0;\n}\n```\n",
        "postTime": 1584409146,
        "uid": 50925,
        "name": "EternalEpic",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4239 \u3010\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\u3011"
    },
    {
        "content": "\u8868\u793a\u4e0d\u4f1aMTT\u3002\n\n\u4e8e\u662f\u679c\u65ad\u4e09\u6a21NTT\uff08\u8be6\u89c1\u4efb\u610f\u6a21\u6570NTT\u6a21\u677f\uff09\u3002\n\n\u7ed3\u679c\u53d1\u73b0\u8d1f\u6570\u5728\u6a21\u610f\u4e49\u4e0b\u7684\u540c\u4f59\u65b9\u7a0b\u7ec4\u76f4\u63a5\u5408\u5e76\u4f1a\u51fa\u9505o(\u2565\ufe4f\u2565)o\n\n\u6b63\u786e\u89e3\u6cd5\u662f\uff1a\u8fb9\u6c42\u9006\u8fb9CRT\uff0c\u6bcf\u6b21\u4e58\u5b8c\u4ee5\u540e\u9a6c\u4e0aCRT\u8f6c\u5316\u6210$\\bmod 10^9+7$\u610f\u4e49\u4e0b\uff0c\u5c31\u4e0d\u4f1a\u51fa\u9505\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(n\\log n)$\uff0c\u7136\u540e\u6bcf\u5c42\u9012\u5f52\u8981NTT18\u6b21\uff0c\u5e38\u6570\u53ef\u60f3\u800c\u77e5\uff08\u5438\u6c27\u80fd\u8fc7\uff09\u3002\n\n~~\u8d1f\u6570\u6bd2\u7624\u554ao(\u2565\ufe4f\u2565)o~~\n\n## Code\uff1a\n```cpp\n#include<iostream>\n#include<algorithm>\n#define toll static_cast<Love##Live>\nusing namespace std;\ntypedef long long LoveLive;\nconst int md1=998244353,md2=1004535809,md3=469762049,N=524288,md=1e9+7;\ninline LoveLive pow(LoveLive a,LoveLive b,const LoveLive&md){\n\tLoveLive ret=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ret=ret*a%md;\n\t\ta=a*a%md;\n\t}\n\treturn ret;\n}\nconst LoveLive M=toll(md1)*md2;\nconst int _=pow(md2%md1,md1-2,md1),__=pow(md1%md2,md2-2,md2),___=pow(M%md3,md3-2,md3);\nint n,lim,a[N],b1[N],b2[N],b3[N],rev[N],B[N];\nvoid init(int n){\n\tint l=-1;\n\tfor(lim=1;lim<=n;lim<<=1)++l;\n\tfor(int i=1;i<lim;++i)\n\trev[i]=(rev[i>>1]>>1)|((i&1)<<l);\n}\nvoid NTT(int*a,int f,const int&md){\n\tconst int gg=pow(3,md-2,md);\n\tfor(int i=1;i<lim;++i)if(i<rev[i])swap(a[i],a[rev[i]]);\n\tfor(int i=1;i<lim;i<<=1){\n\t\tconst int gi=pow(f?3:gg,(md-1)/(i<<1),md);\n\t\tfor(int j=0;j<lim;j+=i<<1){\n\t\t\tLoveLive g=1;\n\t\t\tfor(int k=0;k<i;++k){\n\t\t\t\tint x=a[j+k],y=g*a[j+k+i]%md;\n\t\t\t\ta[j+k]=(x+y)%md;\n\t\t\t\ta[j+k+i]=(x-y+md)%md;\n\t\t\t\tg=g*gi%md;\n\t\t\t}\n\t\t}\n\t}\n\tif(!f){\n\t\tconst LoveLive inv=pow(lim,md-2,md);\n\t\tfor(int i=0;i<lim;++i)a[i]=inv*a[i]%md;\n\t}\n}\ninline void mul(const int*A,const int*B,int*C,const int&md,const int&sz){\n\tstatic int a[N],b[N];\n\tfor(int i=0;i<sz;++i)a[i]=A[i];\n\tfor(int i=0;i<sz;++i)b[i]=B[i];\n\tfor(int i=sz;i<lim;++i)a[i]=b[i]=0;\n\tNTT(a,1,md),NTT(b,1,md);\n\tfor(int i=0;i<lim;++i)C[i]=toll(b[i])*a[i]%md;\n\tNTT(C,0,md);\n\tfor(int i=sz;i<lim;++i)C[i]=0;\n}\ninline LoveLive mul(LoveLive a,LoveLive b,const LoveLive&md){\n\tLoveLive ret=0;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ret=(ret+a)%md;\n\t\ta=(a<<1)%md;\n\t}\n\treturn ret;\n}\ninline LoveLive crt(int a,int b,int c){\n\tLoveLive A=(mul(toll(md2)*a%M,_,M)+mul(toll(md1)*b%M,__,M))%M;\n\tLoveLive k=(c-A%md3+md3)%md3*___%md3;\n\treturn (k%md*(M%md)%md+A%md)%md;\n}\nvoid INV(int n){\n\tif(n==1){\n\t\t*B=pow(*a,md-2,md);\n\t\treturn;\n\t}\n\tINV(n+1>>1);\n\tinit(n<<1);\n\tmul(a,B,b1,md1,n);\n\tmul(a,B,b2,md2,n);\n\tmul(a,B,b3,md3,n);\n\tfor(int i=1;i<n;++i)\n\tb1[i]=b2[i]=b3[i]=(md-crt(b1[i],b2[i],b3[i]))%md;\n\t*b1=*b2=*b3=1;\n\tmul(b1,B,b1,md1,n);\n\tmul(b2,B,b2,md2,n);\n\tmul(b3,B,b3,md3,n);\n\tfor(int i=0;i<n;++i)B[i]=crt(b1[i],b2[i],b3[i]);\n}\nint main(){\n\tios::sync_with_stdio(0),cin.tie(0);\n\tcin>>n;\n\tfor(int i=0;i<n;++i)(cin>>a[i]),a[i]%=md;\n\tINV(n);\n\tfor(int i=0;i<n;++i)cout<<B[i]<<\" \\n\"[i==n-1];\n\treturn 0;\n}\n```",
        "postTime": 1538046513,
        "uid": 6813,
        "name": "mrsrz",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P4239 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6c42\u9006\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "~~\u4f5c\u4e3a\u5168\u7ad9\u6700\u77ed\u4ee3\u7801\u5199\u4e2a\u9898\u89e3~~\n\n\u9996\u5148\u591a\u9879\u5f0f\u6c42\u9006\uff0c\u4e0d\u4f1a\u8bf7\u89c14938\u9898\u89e3\n\n\u7136\u540e\u8fd9\u9898\u6a21\u6570\u4e0d\u662fNTT\u6a21\u6570\uff0cMTT\u8bf7\u89c14245\u9898\u89e3\n\n\u6240\u4ee5\u4e24\u4e2a\u591a\u9879\u5f0f\u4e58\u8d77\u6765\u7528MTT\u5408\u5e76\n\n\u4f46\u662f\u6211\u8c03\u8bd5\u4e86\u4e24\u4e2a\u5c0f\u65f6\uff0c\u539f\u56e0\u5728\u4e8e\uff1a**FFT\u7531\u4e8e\u4e0d\u80fd\u53d6\u6a21\uff0c\u800cdouble\u7684\u4f4d\u6570\u6709\u9650\uff0c\u6240\u4ee5\u591a\u9879\u5f0f\u7b97$AB^2$\u7684\u65f6\u5019\uff0c\u4e0d\u80fd\u50cfNTT\u90a3\u6837\u4e09\u4e2a\u70b9\u503c\u76f4\u63a5\u4e58\u8d77\u6765\uff0c\u4f1a\u7206double\uff0c\u8981\u4e58\u5b8cAB\u4e4b\u540e\u518d\u4e58B\uff01**\n\n\u53e6\u5916\u6211\u7684MTT\u957f\u5f97\u548c\u5927\u5bb6\u7684\u4e0d\u4e00\u6837\uff0c\u5e38\u6570\u662f\u4ed6\u4eec\u7684$\\frac{8}{7}$\uff0c\u5c31\u662f\u7528\u65f6\u95f4\u957f\u4e00\u70b9\u6362\u4ee3\u7801\u77ed\u4e00\u70b9\u561b\n\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<complex>\nusing namespace std;\nconst double Pi=acos(-1);\nconst int N=800100;\nconst int M=30000;\nconst int mod=1e9+7;\nint n,F[N],G[N],l,r[N],tt,P1[N],P2[N];\ncomplex<double> A1[N],A2[N],B1[N],B2[N],w[N],U[N];\nint ksm(int x,int k)\n{\n\tint s=1;for(;k;k>>=1,x=1ll*x*x%mod)\n\tif(k&1) s=1ll*s*x%mod; return s;\t\t\t\n}\nvoid FFT(complex<double> *P,int op)\n{\n\tfor(int i=0;i<l;i++) if(i<r[i]) swap(P[i],P[r[i]]);\n\tfor(int i=1;i<l;i<<=1)\n\t\tfor(int j=0,p=i<<1;j<l;j+=p)\n\t\t\tfor(int k=0;k<i;k++)\n\t\t\t{\n\t\t\t\tcomplex<double> W=w[l/i*k];W.imag()*=op;\n\t\t\t\tcomplex<double> X=P[j+k],Y=P[j+k+i]*W;\n\t\t\t\tP[j+k]=X+Y;P[j+k+i]=X-Y;\n\t\t\t}\n}\nvoid Work(complex<double> *A,complex<double> *B,int b)\n{\n\tfor(int i=0;i<l;i++) U[i]=A[i]*B[i]; FFT(U,-1);\n\tfor(int i=0;i<l;i++) (P1[i]+=((long long)(U[i].real()/l+0.5)%mod*b%mod+mod)%mod)%=mod;\n}\nvoid MTT()\n{\n\tfor(int i=0;i<l;i++) A1[i].real()=P1[i]/M,B1[i].real()=P1[i]%M,A1[i].imag()=B1[i].imag()=0;\n\tfor(int i=0;i<l;i++) A2[i].real()=P2[i]/M,B2[i].real()=P2[i]%M,A2[i].imag()=B2[i].imag()=0;\n\tfor(int i=0;i<l;i++) P1[i]=0; FFT(A1,1);FFT(A2,1);FFT(B1,1);FFT(B2,1);\n\tWork(A1,A2,M*M);Work(A1,B2,M);Work(B1,A2,M);Work(B1,B2,1);\n}\nvoid GetInv(int *f,int *g,int n)\n{\n\tif(n==1) {g[0]=ksm(f[0],mod-2);return;}\n\tGetInv(f,g,n>>1);\n\tfor(tt=0,l=1;l<n*2;l<<=1) tt++;tt--;\n\tfor(int i=0;i<l;i++) r[i]=(r[i>>1]>>1)|((i&1)<<tt),P1[i]=P2[i]=0;\n\tfor(int i=0;i<l;i++) w[i].real()=cos(Pi/l*i),w[i].imag()=sin(Pi/l*i);\n\tfor(int i=0;i<n;i++) P1[i]=f[i],P2[i]=g[i]; MTT(); MTT();\n\tfor(int i=0;i<n;i++) g[i]=((2ll*g[i]%mod-P1[i])%mod+mod)%mod;\n}\nint main()\n{\n\tscanf(\"%d\",&n); for(int i=0;i<n;i++) scanf(\"%d\",&F[i]);\n\tint m; for(m=1;m<n;m<<=1); GetInv(F,G,m);\n\tfor(int i=0;i<n;i++) printf(\"%d \",G[i]);\n}\n\n```\n~~[\u6253\u4e2a\u5e7f\u544a\uff1a\u535a\u4e3b\u5c06\u4f1a\u51fa\u4e00\u4e2a\u591a\u9879\u5f0f/NTT\u7684\u603b\u7ed3\u4ee5\u53ca\u9898\u5355](https://www.cnblogs.com/xzyxzy/)~~",
        "postTime": 1530772564,
        "uid": 43628,
        "name": "xzyxzy",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P4239 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6c42\u9006\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "[P4239 \u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\u9006](https://www.luogu.com.cn/problem/P4239)\n\n\u6211\u7684\u505a\u6cd5\u4f7f\u7528 MTT \u7136\u540e\u518d\u5957\u7528\u4e4b\u524d\u7684\u5f0f\u5b50\u3002\n\n\u9898\u76ee\u8ba9\u6211\u4eec\u6c42\u8fd9\u4e2a $G$\uff0c\u4e5f\u5c31\u662f $F$ \u7684\u9006\u5143\u3002\n$$F(x)\\times G(x) \\equiv 1 \\pmod {x^n} $$\n\n> \u4e3a\u4e86\u4e66\u5199\u65b9\u4fbf\uff0c\u7b14\u8005\u7684 $\\frac{n}{2}$ \u7b49\u4ef7\u4e8e $\\lceil\\frac{n}{2}\\rceil$\u3002\n\n\u6211\u4eec\u8003\u8651\u901a\u8fc7\u5206\u6cbb\u8fdb\u884c\u89e3\u51b3\u95ee\u9898\uff0c\u5047\u8bbe\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u4e86 $x^{\\frac{n}{2}}$ \u7684\u7b54\u6848\u3002\u6211\u4eec\u5148\u8bb0\u4e00\u4e2a\u6570\u7ec4 $G_1$\uff0c\u8868\u793a $F(x)\\times G_1(x) \\equiv 1 \\pmod {x^\\frac{n}{2}} $\u3002\n\n\n$$\n\\begin{aligned}\nF(x)\\times G(x) &\\equiv 1 \\pmod {x^n} \\\\\nF(x) \\times G_1(x) &\\equiv 1 \\pmod {x^{\\frac{n}{2}}} \\\\\nF(x) \\times (G(x) - G_1(x)) &\\equiv 0 \\pmod {x^{\\frac{n}{2}}} \\\\\n\\tt\\text{\u6211\u4eec\u8003\u8651\u5230\u5bf9\u4e8e F(x) \u5176}&\\mod x^n \\text{  \u662f\u4e0d\u4e3a 0 \u7684} \\\\\nG(x) - G_1(x) &\\equiv 0 \\pmod {x^{\\frac{n}{2}}} \\\\\n\\text{\u4e3a\u4e86\u5c06\u5176\u53d8\u6210 } x^n& \\text{\u6211\u4eec\u9700\u8981\u505a\u4e00\u4e9b\u53d8\u6362} \\\\\n(G(x) - G_1(x)) ^ 2 &\\equiv 0 \\pmod {x^n} \\\\\nG^2(x) - G_1^2(x) - 2\\times G(x)G_1(x) &\\equiv 0 \\pmod {x^n} \\\\\nF(x)G^2(x) - F(x)G_1^2(x) - 2\\times G(x)G_1(x)\\times F(x) &\\equiv 0 \\pmod {x^n} \\\\\nG(x) - 2\\times G_1(x) - F(x)G_1^2(x) &\\equiv 0 \\pmod {x ^ n} \\\\\n\nG(x) &\\equiv 2 \\times G_1(x) + F(x) \\times G_1^2(x) \\pmod {x^n} \\\\\n\nG(x) & \\equiv G_1(x) \\times (2 - F(x)G_1(x))\n\n\\end{aligned}\n$$\n\n\u90a3\u4e48\u8fd9\u6837\u6211\u4eec\u5df2\u7ecf\u5c06\u95ee\u9898\u8f6c\u5316\u6210\u4e86\u9012\u5f52\u95ee\u9898\u3002\n\n\u5bf9\u4e8e\u5904\u7406\u4e24\u4e2a\u591a\u9879\u5f0f\u76f8\u4e58 MTT \u662f\u5f88\u5728\u884c\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u5c06\u5176\u5206\u6210\u51e0\u6b21\u8fdb\u884c\u8ba1\u7b97\u3002\n\n\u9996\u5148\u6211\u4eec\u8981\u5148\u8ba1\u7b97 $F \\times G_1$ \u4e4b\u540e\u518d\u5c06\u5176\u53d8\u6210 $2 - F \\times G_1$ \u7136\u540e\u4fdd\u5b58\u5230\u53e6\u5916\u4e00\u4e2a\u6570\u7ec4\u4e2d\uff0c\u8bb0\u4e3a $D$ \u6570\u7ec4\u3002\u4e4b\u540e\u518d\u5c06\u5176\u4e0e $G_1$ \u518d\u505a\u4e00\u6b21 MTT \u5c31\u53ef\u4ee5\u5f97\u5230\u7b54\u6848\u3002\n\n---\n\n\u7ec6\u8282\uff1a\n\n- \u6211\u4eec\u8fdb\u884c\u5b8c $F \\times G_1$ \u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u5148\u5c06\u5176\u53d6\u76f8\u53cd\u6570\uff0c\u518d\u5728 $x^0$ \u7684\u7cfb\u6570\u4e0a\u52a0\u4e0a 2 \u5373\u53ef\u3002\u7b14\u8005\u5199\u4ee3\u7801\u65f6\u76f4\u63a5\u5c06\u6240\u6709\u7684\u7cfb\u6570\u90fd\u52a0\u4e0a\u4e86 2 \u5bfc\u81f4\u5f88\u957f\u65f6\u95f4\u6ca1\u8c03\u51fa\u6765\u3002\n\n- \u6211\u4eec\u8bbe\u9879\u6570\u4e3a n \u6211\u4eec\u6bcf\u6b21\u8fdb\u884c\u9012\u5f52\u7684\u65f6\u5019 n \u4f1a\u9664\u4ee5 2\u3002\u4f46\u662f\u6211\u4eec\u8fdb\u884c MTT \u7684\u65f6\u5019\u9700\u8981\u53d6\u7684\u9879\u6570\u4e3a n\u3002\n\n> \u6211\u4eec\u5148\u8003\u8651 FFT \u7684\u672c\u8d28\uff0c\u4e5f\u5c31\u662f\u5377\u79ef\uff0c\u90a3\u4e48\u6211\u4eec\u6700\u540e\u7684\u7b54\u6848\u9700\u8981\u53d6 n \u4e2a\u9879\uff0c\u8fdb\u884c\u5377\u79ef\u7684\u65f6\u5019\u53ef\u80fd\u4f1a\u51fa\u73b0 $x^{n - 2} \\times x$ \u8fd9\u79cd\u60c5\u51b5\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7406\u89e3\u53d6 n \u4e2a\u9879\u7684\u539f\u56e0\u4e86\u5427\u3002\n\n---\n\n$Code$\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nvoid r1(T &x) {\n\tx = 0;\n\tchar c(getchar());\n\tint f(1);\n\tfor(; !isdigit(c); c = getchar()) if(c == '-') f = -1;\n\tfor(; isdigit(c);c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);\n\tx *= f;\n}\n#define int long long\nconst int maxn = 6e5 + 5;\nconst int maxm = maxn << 1;\n\ntypedef int room[maxn];\nconst int mod = 1e9 + 7/* 998244353*/;\nint n, m;\nstruct Complex {\n    double x, y;\n    Complex (double tx = 0, double ty = 0) {x = tx, y = ty;}\n    Complex operator + (const Complex &z) {return Complex (x + z.x, y + z.y);}\n    Complex operator - (const Complex &z) {return Complex (x - z.x, y - z.y);}\n    Complex operator * (const Complex &z) {return Complex (x * z.x - y * z.y, x * z.y + y * z.x);}\n    Complex operator ~ () const {return Complex(x, - y);}\n}w[maxn];\nint rev[maxn], lim, len;\nvoid fft(Complex *A) { // OK\n    for(int i = 0; i < lim; ++ i) if(i < rev[i]) swap(A[i], A[rev[i]]);\n    for(int mid = 1; mid < lim; mid <<= 1) {\n        for(int j = 0; j < lim; j += (mid << 1)) {\n            for(int k = 0; k < mid; ++ k)  {\n                Complex x = A[j + k], y = A[j + k + mid] * w[k + mid];\n                A[j + k] = x + y;\n                A[j + k + mid] = x - y;\n            }\n        }\n    }\n}\nComplex F[maxn], G[maxn];\nconst double pi = acos(-1.0);\nComplex A[maxn], B[maxn];\nvoid mtt(int *f, int *g, int *ans,int x) {\n    lim = 1, len = 0;\n    while(lim <= (x << 1)) lim <<= 1, ++ len;\n    for(int i = 0; i < lim; ++ i) rev[i] = rev[i >> 1] >> 1 |((i & 1) << (len - 1));\n    for(int i = 0; i < lim; ++ i) F[i] = G[i] = Complex(0, 0);\n\n\n    for(int i = 1; i < lim; i <<= 1) {\n        w[i] = Complex(1, 0);\n        for(int j = 1; j < i; ++ j)\n            if((j & 31) == 1) w[i + j] = Complex(cos(pi * j / i), sin(pi * j / i));\n            else w[i + j] = w[i + j - 1] * w[i + 1];\n    }\n//    for(int i = 1; i < lim; i <<= 1) {\n//        w[i] = Complex(1, 0);\n//        for(int j = 1; j < i; ++ j)\n//            if((j & 31) == 1) w[i + j] = Complex(cos(pi * j / i), sin(pi * j / i));\n//            else w[i + j] = w[i + j - 1] * w[i + 1];\n//    }\n\n    for(int i = 0; i < x; ++ i) F[i].x = (f[i] >> 15), F[i].y = (f[i] & 32767);\n    for(int i = 0; i < x; ++ i) G[i].x = (g[i] >> 15), G[i].y = (g[i] & 32767);\n\n    fft(F), fft(G);\n    for(int i = 0; i < lim; ++ i) {\n        Complex q, f0, g0, f1, g1;\n        q = ~F[i ?lim - i : 0], f0 = (F[i] - q) * Complex(0, -0.5), f1 = (F[i] + q) * Complex(0.5, 0);\n        q = ~G[i ?lim - i : 0], g0 = (G[i] - q) * Complex(0, -0.5), g1 = (G[i] + q) * Complex(0.5, 0);\n        A[i] = f1 * g1, B[i] = g0 * f1 + f0 * g1 + (f0 * g0) * Complex(0, 1);\n    } // \u8fd9\u91cc\u548c\u4e4b\u524d\u7684\u8868\u793a\u4e00\u6837\n    reverse(A + 1, A + lim), reverse(B + 1, B + lim);\n    fft(A), fft(B);\n//    for(int i = 0; i < lim; ++ i) {\n//        Complex q, f0, f1, g0, g1;\n//        q = ~F[i ? lim - i : 0], f0 = (F[i] - q) * Complex(0. -0.5), f1 = (F[i] + q) * Complex(0.5, 0);\n//        q = ~G[i ? lim - i : 0], g0 = (G[i] - q) * Complex(0. -0.5), f1 = (G[i] + q) * Complex(0.5, 0);\n//        A[i] = f1 * g1, B[i] = g0 * f1 + f0 * g1 + (f0 * g0) * Complex(0, 1);\n//    }\n//    reverse(A + 1, A + lim), reverse(B + 1, B + lim);\n//    fft(A), fft(B);\n    double Z = 1.0 / lim;\n    for(int i = 0; i < lim; ++ i) {\n        ans[i] = 0;\n        ans[i] = ((((int)(A[i].x * Z + 0.5) % mod << 30) + ((int)(B[i].x * Z + 0.5) % mod << 15) + ((int)(B[i].y * Z + 0.5) % mod)) % mod) % mod;\n//        ans[i] = (((int)(A[i].x * Z + 0.5) % mod << 30) % mod + ((int)(B[i].x * Z + 0.5) % mod << 15) % mod + ((int)(B[i].y * Z + 0.5) % mod) ) % mod;\n        ans[i] %= mod;\n    }\n}\n\nint ans[maxn], a[maxn];\nint ksm(int mi,int x) {\n    int res(1);\n    while(mi) {\n        if(mi & 1) res = res * x % mod;\n        x = x * x % mod;\n        mi >>= 1;\n    }\n    return res;\n}\nint d[maxn], z[maxn];\nvoid Inv(int *F,int *G,int x) { // \u6700\u9ad8\u9879\u662f \u7684\u6b21\u6570\u662f x - 1\n//    printf(\"x = %d\\n\", x);\n    if(x == 1) return G[0] = ksm(mod - 2, F[0]), void(); // ok\n\n    Inv(F, G, x >> 1); // last G \u662f\u5df2\u7ecf\u77e5\u9053\u7684\n//    for(int i = 0; i < x; ++ i) printf(\"%lld \", F[i]);\n//    for(int i = 0; i < x; ++ i) printf(\"%lld \", G[i]);\n    mtt(F, G, d, x);\n//    for(int i = 0; i <= x; ++ i) z[i] = 0;\n//    for(int i = 0; i < (x >> 1); ++ i) z[i] = (2 - d[i] + mod) % mod;\n    for(int i = 0; i < x; ++ i) z[i] = (mod - d[i]) % mod;\n    z[0] = (z[0] + 2) % mod;\n    mtt(G, z, d, x);\n    for(int i = 0; i < x; ++ i) G[i] = d[i];\n    for(int i = x; i < lim; ++ i) G[i] = 0;\n}\n\nsigned main() {\n\tint i, j;\n    r1(n);\n    for(i = 0; i < n; ++ i) r1(a[i]);\n    int z(1);\n    while(z <= n) z <<= 1;\n    Inv(a, ans, z);\n    for(i = 0; i < n; ++ i) printf(\"%lld \", (ans[i] + mod) % mod);\n\treturn 0;\n}\n\n```\n\n\n",
        "postTime": 1615374106,
        "uid": 151723,
        "name": "legendgod",
        "ccfLevel": 7,
        "title": "MTT \u4efb\u610f\u6a21\u6570\u6c42\u591a\u9879\u5f0f\u9006\u5143"
    },
    {
        "content": "\u867d\u7136\u65f6\u95f4\u4e0d\u4e00\u5b9a\u662f\u6700\u5feb\u7684\uff0c\u751a\u81f3\u6bd4\u8f83\u6162\uff083s \u5de6\u53f3\uff09\u3002\n\n\u867d\u7136\u957f\u5ea6\u4e0d\u4e00\u5b9a\u662f\u6700\u77ed\u7684\uff0c\u751a\u81f3\u975e\u5e38\u957f\u3002\n\n\u4f46\u7801\u98ce\u4e00\u5b9a\u662f\u5f88\u597d\u7684\uff0c\u7ed9\u4e00\u4e2a\u6bd4\u8f83\u597d\u7684\u6a21\u677f\u7ed9\u4e88\u53c2\u8003\u3002\n\n```cpp\n/* Header {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long readtype;\ntypedef long long var;\ntypedef long double let;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n\n#ifdef LOCAL_LOGGER\n#define logger(...) fprintf(stderr, __VA_ARGS__)\n#define abortif(v, ...) if (v) {logger(\"Error in Line %d, Function '%s()'.\\nInfo: \", __LINE__, __FUNCTION__); logger(__VA_ARGS__); exit(0);}\n#else\n#define logger(...);\n#define abortif(v, ...);\n#endif\n/* }}} */\n\nconst int N = 8e5 + 1;\nconst int MOD = 1e9 + 7;\nconst double Pi = acos(-1.0);\n\nstruct Node;\n\nstruct Node {\n  // {{{\n  double x, y;\n  Node operator + (Node t) { return (Node) {x + t.x, y + t.y}; }\n  Node operator - (Node t) { return (Node) {x - t.x, y - t.y}; }\n  Node operator * (Node t) { \n    return (Node) {x * t.x - y * t.y, x * t.y + y * t.x}; \n  }\n  Node operator * (double t) { return (Node) {x * t, y * t}; }\n  Node operator ~ () { return (Node) {x, -y}; }\n\n  void MTTinit(int t) { x = t >> 15, y = t & 32767; }\n  // }}}\n};\n\nconst Node Nullnode = (Node) {0, 0};\n\ninline int add(int a, int b) { return (a + b >= MOD) ? (a + b - MOD) : (a + b); }\ninline int mul(var a, int b) { return (a * b) % MOD; }\ninline int qpow(int x, var y) {\n  int res = 1;\n  while (y) {\n    if (y & 1) res = mul(res, x);\n    x = mul(x, x);\n    y >>= 1;\n  }\n  return res;\n}\ninline int inv(int t) { return qpow(t, MOD - 2); }\n\nint limit, rev[N];\nNode w[N];\nNode tmp_a[N], tmp_b[N], tmp_c[N];\n\nvoid InitLimit(const int need_len);\nvoid Transform(Node *val, const int type);\nvoid Mul(const int len_a, const int *a, const int len_b, const int *b,\n    int &len_c, int *c);\nvoid Inv(const int len, const int *a, int *b);\n\nint tmp_va[N], tmp_vb[N];\nNode tmp_d[N];\n\nint n, f[N], g[N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n  freopen(\"P4239.in\", \"r\", stdin);\n  freopen(\"P4239.out\", \"w\", stdout);\n#endif\n#ifdef LOCAL_LOGGER\n  freopen(\"P4239.log\", \"w\", stderr);\n#endif\n  n = read() - 1;\n  for (int i = 0; i <= n; ++i) f[i] = read();\n  Inv(n, f, g);\n  for (int i = 0; i <= n; ++i) printf(\"%d \", g[i]);\n  puts(\"\");\n  return 0;\n}\n\n/* ==== Makefile ==== {{{\nCompileAndRun:\nmake Compile\nmake Run\n\nCompile:\ng++ -o P4239 P4239.cpp -g -Wall -DLOCAL_LOGGER\n\nCompileUF:\ng++ -o P4239 P4239.cpp -g -Wall -DLOCAL_LOGGER -fsanitize=undefined\n\nRun:\n./P4239 < P4239.in > P4239.out\n==================\n}}} */\n\nvoid InitLimit(const int need_len) {\n  if (limit > need_len) return ;\n  for (limit = 1; limit <= need_len; limit <<= 1);\n  for (int i = 0; i < limit; ++i)\n    rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? (limit >> 1) : 0);\n  for (int mid = 1; mid < limit; mid <<= 1) {\n    w[mid] = (Node) {1, 0};\n    for (int i = 1; i < mid; ++i) {\n      if ((i & 31) == 1) \n        w[i + mid] = (Node) {cos(Pi * i / mid), sin(Pi * i / mid)};\n      else\n        w[i + mid] = w[i + mid - 1] * w[mid + 1];\n    }\n  }\n}\n\nvoid Transform(Node *val, const int type) {\n  if (type == -1) reverse(val + 1, val + limit);\n  for (int i = 0; i < limit; ++i) \n    if (i < rev[i]) swap(val[i], val[rev[i]]);\n  for (int mid = 1; mid < limit; mid <<= 1) {\n    int R = mid << 1;\n    for (int i = 0; i < limit; i += R) {\n      for (int j = 0; j < mid; ++j) {\n        Node v = w[mid + j] * val[i + mid + j];\n        val[i + mid + j] = val[i + j] - v;\n        val[i + j] = val[i + j] + v;\n      }\n    }\n  }\n}\n\nvoid Mul(const int len_a, const int *a, const int len_b, const int *b,\n    int &len_c, int *c) {\n  len_c = len_a + len_b;\n  InitLimit(len_c);\n  for (int i = 0; i <= len_a; ++i) tmp_a[i].MTTinit(a[i]);\n  for (int i = 0; i <= len_b; ++i) tmp_b[i].MTTinit(b[i]);\n\n  Transform(tmp_a, 1), Transform(tmp_b, 1);\n\n  for (int i = 0; i < limit; ++i) {\n    Node ft = ~tmp_a[i ? (limit - i) : 0], \n         f0 = (tmp_a[i] - ft) * (Node) {0, -0.5},\n         f1 = (tmp_a[i] + ft) * 0.5;\n    Node gt = ~tmp_b[i ? (limit - i) : 0],\n    g0 = (tmp_b[i] - gt) * (Node) {0, -0.5},\n    g1 = (tmp_b[i] + gt) * 0.5;\n    tmp_c[i] = f1 * g1, tmp_d[i] = f0 * g1 + f1 * g0 + f0 * g0 * (Node) {0, 1};\n  }\n  for (int i = 0; i < limit; ++i)\n    tmp_a[i] = Nullnode, tmp_b[i] = Nullnode;\n\n  Transform(tmp_c, -1), Transform(tmp_d, -1);\n\n  for (int i = 0; i <= len_c; ++i) {\n    var v1 = (var) (tmp_c[i].x / limit + 0.5) % MOD,\n        v2 = (var) (tmp_d[i].x / limit + 0.5) % MOD,\n        v3 = (var) (tmp_d[i].y / limit + 0.5) % MOD;\n    c[i] = ((v1 << 30) + (v2 << 15) + v3) % MOD;\n    tmp_c[i] = Nullnode, tmp_d[i] = Nullnode;\n  }\n}\n\nvoid Inv(const int len, const int *a, int *b) {\n  if (!len) {\n    b[0] = inv(a[0]);\n    return ;\n  }\n  Inv(len >> 1, a, b);\n  InitLimit(len << 1);\n  int len_va = 0, len_vb;\n  Mul(len, a, len, b, len_va, tmp_va);\n  Mul(len_va, tmp_va, len, b, len_vb, tmp_vb);\n\n  for (int i = 0; i <= len; ++i) {\n    b[i] = add(add(b[i], b[i]), MOD - tmp_vb[i]);\n    tmp_va[i] = 0, tmp_vb[i] = 0;\n  }\n}\n\n```",
        "postTime": 1595337024,
        "uid": 20522,
        "name": "ccviolett",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4239 \u3010\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\u3011"
    },
    {
        "content": "~~\u4f60\u8c37\u7adf\u7136\u6ca1\u6709vector\u591a\u9879\u5f0f\u515a\u7684\u9898\u89e3\u3002~~ \n\n\u90a3\u6211\u5c31\u6765\u63d0\u4f9b\u4e00\u4efd\u53c2\u8003\u4ee3\u7801\u597d\u4e86\u3002\n\n\u9996\u5148\u662f\u524d\u7f6e\u77e5\u8bc6\uff1a[P4245](https://www.luogu.com.cn/problem/P4245)\uff0c[P4238](https://www.luogu.com.cn/problem/P4238)\u3002\n\n\u8fd9\u91cc\u7684\u8bdd\u6211\u5199\u7684\u662f$\\mathrm{MTT}$\uff0c\u7b80\u5355\u6765\u8bf4\uff0c\u6211\u4eec\u53ef\u4ee5\u63a8\u51fa\u4e00\u4e2a\u591a\u9879\u5f0f\u7684$\\mathrm{DFT}$\u4e0e **\u5176\u5728\u590d\u6570\u57df\u4e0a\u6bcf\u4e00\u9879\u7cfb\u6570\u90fd\u5171\u8f6d\u7684\u591a\u9879\u5f0f** \u7684$\\mathrm{DFT}$\u6784\u6210\u7ffb\u8f6c\u5171\u8f6d\u7684\u5173\u7cfb\uff0c\u5373\uff1a\n\n$$P(x)=\\sum_{i=0}^{n-1}z_i x^i,Q(x)=\\sum_{i=0}^{n-1}\\overline{z_i}x^i$$\n\n\u53ef\u4ee5\u63a8\u51fa\uff1a\n\n$$(\\mathrm{DFT}\\ P)_i=\\overline{(\\mathrm{DFT}\\ Q)_{(n-i)\\bmod n}}$$\n\n\u81f3\u4e8e\u63a8\u5bfc\u8fc7\u7a0b\uff0c$2016$\u5e74\u56fd\u5bb6\u96c6\u8bad\u961f\u8bba\u6587\u4e0a\u6709\uff0c\u8bb8\u591a\u535a\u5ba2\u4e0a\u4e5f\u6709\uff0c\u6211\u5c31\u4e0d\u8d58\u8ff0\u4e86\u3002\n\n\u6709\u4e86\u4e0a\u9762\u7684\u7ed3\u8bba\u6211\u4eec\u5c31\u53ef\u4ee5\u628a\u4e24\u4e2a\u591a\u9879\u5f0f\u4e00\u4e2a\u653e\u5728\u5b9e\u90e8\uff0c\u4e00\u4e2a\u653e\u5728\u865a\u90e8\uff0c\u4e00\u6b21$\\mathrm{DFT}$\u6c42\u51fa\u4e24\u4e2a\u591a\u9879\u5f0f\u7684\u5355\u4f4d\u6839\u70b9\u503c\u3002\n\n\u90a3\u4e48\u8fd9\u4e2a\u5c31\u53ef\u4ee5\u7528\u6765\u4f18\u5316\u62c6\u4f4d$\\mathrm{FFT}$\uff0c\u5b9e\u73b0\u503c\u57df\u53ef\u8fbe$2^{30}\\times 10^{16}$\u5de6\u53f3\u7684\u591a\u9879\u5f0f\u4e58\u6cd5\uff0c\u4ec5\u9700$4$\u6b21$\\mathrm{DFT}$\uff0c\u4f46\u662f\u5e26\u6709\u4e00\u5b9a\u5e38\u6570\u3002\n\n\u5bf9\u4e8e\u672c\u9898\uff0c\u6211\u4eec\u53ea\u9700\u62c9\u4e00\u62c9\u591a\u9879\u5f0f\u6c42\u9006\u7684\u677f\u5b50\u5373\u53ef\u3002\n\n\u5173\u4e8e\u7cbe\u5ea6\u95ee\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u9884\u5904\u7406\u5355\u4f4d\u6839\u3002\u5bb9\u6613\u5f97\u77e5\u5355\u4f4d\u6839\u603b\u5171\u53ea\u6709$O(n)$\u4e2a\uff0c\u53ea\u8981\u6bcf$32$\u4e2a\u91cd\u7b97\u4e00\u6b21\u5c31\u53ef\u4ee5\u4e86\uff0c\u8fd9\u6837\u65e2\u4fdd\u8bc1\u65f6\u95f4\u5e38\u6570\u4e0d\u4f1a\u592a\u5927\uff0c\u53c8\u53ef\u4ee5\u4fdd\u8bc1\u7cbe\u5ea6\uff0c\u4e0d\u9700\u8981\u7528`long double`\u3002\n\n~~\u8fd9\u5927\u6982\u662fvector\u591a\u9879\u5f0f\u515a\u7684\u6625\u5929\u7684\u5427\uff0c\u53ea\u8981\u4f60\u5c01\u88c5\u5f97\u591f\u6f02\u4eae\uff0c\u5f3a\u884c\u4e8c\u5408\u4e00\u7684\u9898\u5c31\u5957\u4e0d\u6b7b\u4f60~~\n\n\u7531\u4e8e\u4f7f\u7528`vector`\u5c01\u88c5\u591a\u9879\u5f0f\uff0c\u4e0d\u5f00O2\u7684\u8bdd\u6548\u7387\u4e00\u822c\uff0c\u53ea\u80fd\u8dd1\u8fdb$20s$\uff0c\u5f00O2\u7684\u8bdd\u5c31\u5f88\u5feb\uff0c\u57fa\u672c\u4e0a\u53ef\u4ee5\u4fdd\u6301\u5728$2s$\u5de6\u53f3\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst long double Pi = acos(-1);\nconst int N = 1<<18 , Mod = 1e9 + 7;\ntypedef vector<int> Poly; typedef long long ll;\nstruct Complex\n{\n    double Re,Im; Complex (double R = 0,double I = 0) { Re = R , Im = I; }\n    friend Complex operator + (Complex a,Complex b) { return Complex( a.Re + b.Re , a.Im + b.Im ); }\n    friend Complex operator - (Complex a,Complex b) { return Complex( a.Re - b.Re , a.Im - b.Im ); }\n    friend Complex operator * (Complex a,Complex b) { return Complex( a.Re*b.Re - a.Im*b.Im , a.Re*b.Im + a.Im*b.Re ); }\n};\nPoly rev; Complex omega[N<<1];\ninline int inc(int a,int b) { return a + b >= Mod ? a + b - Mod : a + b; }\ninline int dec(int a,int b) { return a - b < 0 ? a - b + Mod : a - b; }\ninline int mul(int a,int b) { return 1LL * a * b % Mod; }\ninline void Inc(int &a,int b) { return void( a = inc( a , b ) ); }\ninline void Dec(int &a,int b) { return void( a = dec( a , b ) ); }\ninline void Mul(int &a,int b) { return void( a = mul( a , b ) ); }\ninline int fastpow(int a,int b) { int c = 1; for (; b; Mul(a,a) , b>>=1) if (1&b) Mul(c,a); return c; }\ninline int Inv(int x) { return fastpow( x , Mod - 2 ); }\ninline int Read(void)\n{\n    int x = 0 , w = 0; char ch = ' ';\n    while ( !isdigit(ch) ) w |= ch == '-' , ch = getchar();\n    while ( isdigit(ch) ) x = x * 10 + ch - 48 , ch = getchar();\n    return w ? -x : x;\n}\ninline Complex Conj(Complex z) { return Complex( z.Re , -z.Im ); }\ninline int Calc(int n) { int k = 1; while ( k < n ) k <<= 1; return k; }\ninline void Flip(int n)\n{\n    int k = 0; while ( 1<<k < n ) ++k;\n    rev.resize(n) , rev[0] = 0 , --k;\n    for (int i = 1; i < n; i++)\n        rev[i] = ( rev[i>>1] >> 1 ) | ( (i&1) << k );\n}\ninline void Init(void)\n{\n    for (int i = 1 , j; i < N; i <<= 1)\n        for (j = 1 , omega[i] = Complex(1,0); j < i; j++)\n            if ( (j&31) == 1 ) omega[i+j] = Complex( cos(Pi*j/i) , sin(Pi*j/i) );\n            else omega[i+j] = omega[i+j-1] * omega[i+1];\n}\ninline void FFT(vector<Complex> &p,int n,int op)\n{\n    p.resize(n); static Complex x,y;\n    for (int i = 0; i < n; i++) if ( rev[i] > i ) swap( p[rev[i]] , p[i] );\n    for (int i = 1; i < n; i <<= 1) for (int j = 0; j < n; j += i<<1)\n        for (int k = 0; x = p[j+k] , y = omega[i+k] * p[i+j+k] , k < i; k++)\n            p[j+k] = x + y , p[i+j+k] = x - y;\n    if ( op == 1 ) return void(); reverse( p.begin() + 1 , p.end() );\n    for (int i = 0; i < n; i++) p[i].Re /= n , p[i].Im /= n;\n}\ninline Poly MTT(Poly a,Poly b)\n{\n    if ( !a.size() || !b.size() ) return {};\n    int _n = a.size() + b.size() - 1 , n = Calc(_n); Flip(n);\n    static vector<Complex> A,B,P,Q; static Complex a0,a1,b0,b1;\n    A.resize(n) , B.resize(n) , P.resize(n) , Q.resize(n) , a.resize(n) , b.resize(n);\n    for (int i = 0; i < n; i++)\n        A[i] = Complex( a[i]>>15 , a[i] & ( (1<<15) - 1 ) ),\n        B[i] = Complex( b[i]>>15 , b[i] & ( (1<<15) - 1 ) );\n    FFT(A,n,1) , FFT(B,n,1) , P[0] = Conj(A[0]) , Q[0] = Conj(B[0]);\n    for (int i = 1; i < n; i++) P[i] = Conj(A[n-i]) , Q[i] = Conj(B[n-i]);\n    for (int i = 0; i < n; i++)\n        a0 = ( A[i] + P[i] ) * Complex(0.5,0) , a1 = ( P[i] - A[i] ) * Complex(0,0.5),\n        b0 = ( B[i] + Q[i] ) * Complex(0.5,0) , b1 = ( Q[i] - B[i] ) * Complex(0,0.5),\n        A[i] = a0 * b0 + Complex(0,1) * a0 * b1 , B[i] = b0 * a1 + Complex(0,1) * a1 * b1;\n    FFT(A,n,-1) , FFT(B,n,-1);\n    static Poly c; static long long x,y,z; c.resize(_n);\n    for (int i = 0; i < _n; i++)\n        x = (ll)( A[i].Re + 0.5 ) % Mod , z = (ll)( B[i].Im + 0.5 ) % Mod ,\n        y = (ll)( A[i].Im + B[i].Re + 0.5 ) % Mod , c[i] = ( (x<<30) + (y<<15) + z ) % Mod;\n    return c;\n}\ninline Poly Inverse(Poly f,int n)\n{\n    int _n = Calc(n) , Len; static Poly g(1),h;\n    f.resize(_n) , g[0] = Inv(f[0]);\n    for (int i = 2; i <= _n; i <<= 1)\n    {\n        h.resize(i); for (int j = 0; j < i; j++) h[j] = f[j];\n        h = MTT( g , MTT( g , h ) ) , g.resize(i);\n        for (int j = 0; j < i; j++)\n            g[j] = dec( mul( g[j] , 2 ) , h[j] );\n    }\n    return g.resize(n) , g;\n}\nint main(void)\n{\n    int n = Read(); Poly f(n),g; Init();\n    for (int i = 0; i < n; i++) f[i] = Read();\n    g = Inverse(f,n);\n    for (int i = 0; i < n; i++)\n        printf( \"%d%c\" , g[i] , \" \\n\"[i==n-1] );\n    return 0;\n}\n\n```\n",
        "postTime": 1585974006,
        "uid": 59327,
        "name": "Parsnip",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4239 \u3010\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\u3011"
    },
    {
        "content": "(mrsrz skip2004 orz)\n\n\u4e09\u6a21\u6700\u597d\u7528\u8fa3\n\n\u7531\u4e8e\u6211\u4e0d\u4f1a\u62c6\u7cfb\u6570\u6240\u4ee5\u6211\u6765\u5199\u4e09\u6a21\u4e86\n\n(\u4e0d\u4f1a\u4e09\u6a21\u8bf7\u51fa\u95e8\u53f3\u8f6c[\u4efb\u610f\u6a21\u6570NTT](https://www.luogu.org/problemnew/show/P4245))\n\n\u9996\u5148\u4f60\u4f1a\u53d1\u73b0\u8fd9\u9053\u9898\u76f4\u63a5\u7528\u4e09\u6a21\u4f1agg\n\n\u56e0\u4e3a\u5982\u679c\u4f60\u5728\u67d0\u4e00\u4e2a\u65f6\u523b\u5f97\u5230\u4e86\u4e00\u4e2a\u8d1f\u6570(\u6216\u8005\u8d85\u51fa\u4e86\u4e09\u4e2a\u6a21\u6570\u7684\u79ef)\u90a3\u4e48crt\u5408\u5e76\u4f1a\u6302\u6389\n\n\u4e3e\u4e2a\u6817\u5b50\u5047\u5982\u67d0\u4e00\u4e2a\u65f6\u523b\u5f97\u5230\u4e86$-1$\n\n\u90a3\u4e48\u5bf9\u4e8e\u4f60\u7684\u4e09\u4e2a\u6a21\u6570\u90fd\u4f1a\u53d8\u6210$(mod-1)$\u7684\u72b6\u6001\n\n\u7136\u800c\u8fd9\u4e2a\u65f6\u5019\u7684\u7b54\u6848\u5e94\u8be5\u662f$1000000006$, \u6a21\u4e09\u4e2a\u6a21\u6570\u663e\u7136\u4e0d\u53ef\u80fd\u53d8\u6210$(mod-1)$\n\n\u5e76\u4e14\uff08\u636e\u8bf4\uff09\u6c42\u9006\u7684\u65f6\u5019\u90a3\u4e2a\u4e09\u6b21\u9879\u53ef\u4ee5\u7206\u6a21\u6570\u4e58\u79ef\n\n\u6240\u4ee5\u5c31\u6709\u4e00\u4e2a\u5de7\u5999\u7684\u64cd\u4f5c\n\n\u6211\u4eec\u5f53\u524d\u6c42\u9006\u4e2d\u9700\u8981\u8ba1\u7b97\u7684\u5f0f\u5b50\u662f$-AB'^2$\n\n\u90a3\u4e48\u5148\u628a$AB'$\u7528\u4e09\u6a21\u7b97\u51fa\u6765\u7136\u540e$crt$\u5408\u5e76\u51fa\u6a21$1e9+7$\u4e0b\u7684\u503c\uff0c\u53d6\u8d1f\uff0c\u7136\u540e\u8f6c\u6362\u6210\u6a21\u4e09\u4e2a\u6a21\u6570\u4e0b\u7684\u503c\u518d\u548c$B'$\u5377\u4e00\u6b21\uff0c\u7136\u540e\u518d\u5408\u5e76\u6210\u6a21$1e9+7$\u7684\u503c\u7b49\u5f85\u4e0b\u4e00\u6b21\u8ba1\u7b97\n\n\u6362\u53e5\u8bdd\u8bf4\u53ea\u8981\u4f60\u5728\u64cd\u4f5c\u7684\u65f6\u5019\u6bcf\u6b21\u90fd\u53ea\u4f7f\u7528\u201c\u628a\u4e24\u4e2a\u6a21$1e9+7$\u7684\u591a\u9879\u5f0f\u5377\u6210\u65b0\u7684\u6a21$1e9+7$\u7684\u591a\u9879\u5f0f\u201c\u8fd9\u4e00\u4e2a\u64cd\u4f5c\u90a3\u4e48\u662f\u4e0d\u4f1a\u51fa\u9505\u7684\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u8fa3\uff01\n\n\uff08\u867d\u8bf4\u8fd8\u662f\u8dd1\u4e0d\u8fc7fft\u2026\u2026\u7a9d\u5e38\u6570\u592a\u5927\u4e86\uff09\n\n~~\uff08\u53e6\u5916\u6c42\u9006\u8fb9\u754c\u7684\u65f6\u5019\u5bf9\u771f\u6a21\u6570\u6c42\u9006\u4e0d\u8981\u5c1d\u8bd5\u4ec0\u4e48\u4e09\u6a21\u6c42\u9006\u5408\u5e76\uff09~~\n\n```cpp\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\n// io\n\nstruct istream {\n\tconst static int ri_top = 1e7;\n\tchar ri[ri_top], *rich = ri, *rr = ri;\n\tvoid rd() { *(rr = ri + fread(rich = ri, 1, ri_top, stdin)) = 0; }\n\tistream() { rd(); }\n\tchar nch() { if (++rich >= rr) rd(); return *rich; }\n\tistream& operator>>(int& x) {\n\t\twhile (!isdigit(*rich)) nch();\n\t\tfor (x = *rich - '0'; isdigit(nch()); x = x * 10 + *rich - '0');\n\t\treturn *this;\n\t}\n} cin;\nstruct ostream {\n\tconst static int wi_top = 1e7;\n\tchar wi[wi_top], *wich = wi, *wr = wi + wi_top;\n\tvoid wrt() { fwrite(wi, 1, wich - wi, stdout); wich = wi; }\n\t~ostream() { wrt(); }\n\tostream& nch(const char& ch) { if (wich >= wr) wrt(); *wich++ = ch; return *this; }\n\tostream& operator<<(int x) {\n\t\tstatic char buffer[233], *p; p = buffer;\n\t\tif (!x) return nch('0');\n\t\twhile (x) { *p++ = x % 10 ^ '0'; x /= 10; }\n\t\twhile (p-- != buffer) nch(*p);\n\t\treturn *this;\n\t}\n\tostream& operator<<(const char& ch) { return nch(ch); }\n} cout;\n\n// io\n\nconstexpr int Mod=1000000007;\nusing ll=long long;\nstruct Z {\n\tstatic constexpr int Mod1=645922817,Mod2=897581057,Mod3=998244353;\n\tint a,b,c;\n\tZ(const int& x=0) : a(x%Mod1),b(x%Mod2),c(x%Mod3) {}\n\tZ(const int& a,const int& b,const int& c) : a(a),b(b),c(c) {}\n\tZ& up() { a+=a>>31&Mod1; b+=b>>31&Mod2; c+=c>>31&Mod3; return *this; }\n\tZ& operator+=(const Z& rhs) { a+=rhs.a-Mod1; b+=rhs.b-Mod2; c+=rhs.c-Mod3; return up(); }\n\tZ operator-(const Z& rhs) const { return Z(a-rhs.a,b-rhs.b,c-rhs.c).up(); }\n\tZ operator*(const Z& rhs) const {\n\t\treturn Z(static_cast<ll>(a)*rhs.a%Mod1,static_cast<ll>(b)*rhs.b%Mod2,static_cast<ll>(c)*rhs.c%Mod3);\n\t\treturn *this;\n\t}\n\tint val(const int& Mod) {\n\t\tll _a=(b-a+Mod2)%Mod2*867661692ll%Mod2*Mod1+a;\n\t\treturn ((c-_a%Mod3+Mod3)%Mod3*13864533%Mod3*Mod1%Mod*Mod2+_a)%Mod;\n\t}\n};\ninline int qpow(int a,int p,int Mod,int s=1) {\n\tfor (;p;p>>=1,a=static_cast<ll>(a)*a%Mod) if (p&1) s=static_cast<ll>(s)*a%Mod;\n\treturn s;\n}\nint exgcd(int a,int b,int& x,int& y) {\n\tif (!b) return x=1,y=0,a;\n\tint d=exgcd(b,a%b,y,x); y-=a/b*x; return d;\n}\ninline int _inv(const int& a) { int x,_; exgcd(a,Mod,x,_); return x+=x>>31&Mod; }\ninline Z inv(const Z& rhs) {\n\tint x1,x2,x3,_; exgcd(rhs.a,Z::Mod1,x1,_); exgcd(rhs.b,Z::Mod2,x2,_); exgcd(rhs.c,Z::Mod3,x3,_);\n\treturn Z(x1,x2,x3).up();\n}\nconstexpr int mxlen=1<<18;\nint r[mxlen],d; Z w[mxlen];\nvoid fftinit(int len) {\n\tint _d=(d=__builtin_ctz(len))-1;\n\tfor (int i=1;i<len;++i) r[i]=r[i>>1]>>1|(i&1)<<_d;\n\tZ wn(qpow(3,Z::Mod1>>d,Z::Mod1),qpow(3,Z::Mod2>>d,Z::Mod2),qpow(3,Z::Mod3>>d,Z::Mod3)); w[len>>1]=1;\n\tfor (int i=(len>>1)+1;i<len;++i) w[i]=w[i-1]*wn;\n\tfor (int i=len>>1;--i;) w[i]=w[i<<1];\n}\nvoid dft(Z a[],int len) {\n\tint shift=d-__builtin_ctz(len);\n\tfor (int i=0;i<len;++i) if (i<r[i]>>shift) std::swap(a[i],a[r[i]>>shift]);\n\tfor (int l=1;l<len;l<<=1) for (int i=0;i<len;i+=l<<1) for (int j=0;j<l;++j) {\n\t\tZ tmp(a[i+j+l]*w[j+l]); a[i+j+l]=a[i+j]-tmp; a[i+j]+=tmp;\n\t}\n}\nvoid idft(Z a[],int len) {\n\tstd::reverse(a+1,a+len); dft(a,len);\n\tZ invn(inv(len)); for (int i=0;i<len;++i) a[i]=a[i]*invn;\n}\nvoid pinv(Z a[],Z b[],int n) {\n\tif (n==1) return void(*b=_inv(a->val(Mod)));\n\tpinv(a,b,(n+1)>>1);\n\tint len=1; while (len<=n*3/2) len<<=1;\n\tstatic Z c[mxlen],d[mxlen];\n\t__builtin_memcpy(c,a,sizeof(Z)*n); __builtin_memcpy(d,b,sizeof(Z)*n);\n\tfor (int i=n;i<len;++i) c[i]=d[i]=0;\n\tdft(c,len); dft(d,len);\n\tfor (int i=0;i<len;++i) c[i]=c[i]*d[i];\n\tidft(c,len);\n\tfor (int i=0;i<len;++i) c[i]=Mod-c[i].val(Mod);\n\tdft(c,len);\n\tfor (int i=0;i<len;++i) c[i]=c[i]*d[i];\n\tidft(c,len);\n\tfor (int i=(n+1)>>1;i<n;++i) b[i]=c[i].val(Mod);\n}\nZ A[mxlen],B[mxlen];\nint main() {\n\tint n; cin>>n;\n\tfor (int i=0;i<n;++i) { int x; cin>>x; A[i]=x; }\n\tint len=1; while (len<=n*3/2) len<<=1;\n\tfftinit(len); pinv(A,B,n);\n\tfor (int i=0;i<n;++i) cout<<B[i].val(Mod)<<\"\\n \"[i!=n-1];\n\treturn 0;\n}\n```",
        "postTime": 1550057216,
        "uid": 123502,
        "name": "starcy",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4239 \u3010\u3010\u6a21\u677f\u3011\u591a\u9879\u5f0f\u6c42\u9006\uff08\u52a0\u5f3a\u7248\uff09\u3011"
    },
    {
        "content": "[_\u4f20\u9001\u95e8_](https://www.luogu.com.cn/problem/P4239)\n\n\u677f\u5b50\u9898\u3002\n## \u9898\u610f\n\u7ed9\u5b9a $n-1$ \u6b21\u591a\u9879\u5f0f $F(x)$\uff0c\u6c42 $G(x)$ \u6ee1\u8db3 $F(x)G(x)\\equiv1(\\bmod x^n)$\u3002\n## \u601d\u8def\n\u65e2\u7136\u662f\u4efb\u610f\u6a21\u6570\uff0c\u5c06 FFT \u4e2d\u6c42\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\u7684\u591a\u9879\u5f0f\u4e58\u6cd5\u6539\u4e3a MTT \u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2n)$\u3002\n\n\u4e09\u6a21 NTT \u4f3c\u4e4e\u4e5f\u53ef\u4ee5\u505a\uff0c\u800c\u4e14\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a\u66f4\u4f18\u79c0\u7684 $O(n\\log n)$\uff0c\u4f46\u662f\u6bcf\u4e00\u6b21\u9012\u5f52\u8981 NTT 18 \u6b21\uff0c\u8fd8\u8dd1\u4e0d\u8fc7\u6bcf\u6b21\u9012\u5f52 FFT 8 \u6b21\u7684 $O(n\\log^2 n)$\u3002\n\n\u6700\u540e\u6ce8\u610f\u4e00\u4e2a\u7ec6\u8282\uff1a\u505a MTT \u65f6\u4e00\u5b9a\u8981\u5c06\u4e4b\u524d\u4f7f\u7528\u8fc7\u7684 complex \u6e05\u7a7a\uff0c\u4e0d\u7136\u4f1a\u6b7b\u5f97\u5f88\u60e8\u3002\n\nCode:\n```cpp\n#define ll long long\n#define ld double\nconst int N=4e5+10,mod=1e9+7;\nconst ld pi=acos(-1);\ninline int qpow(int x,int y,int mod){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=1ll*res*x%mod;\n\t\tx=1ll*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n#define complex comp\nstruct complex{\n\tld x,y;\n\tcomplex(ld a=0,ld b=0){x=a,y=b;}\n\tcomplex neg(){\n\t\treturn complex(x,-y);\n\t}\n\tfriend complex operator+(const complex &a,const complex &b){\n\t\treturn complex(a.x+b.x,a.y+b.y);\n\t}\n\tfriend complex operator-(const complex &a,const complex &b){\n\t\treturn complex(a.x-b.x,a.y-b.y);\n\t}\n\tfriend complex operator*(const complex &a,const complex &b){\n\t\treturn complex(a.x*b.x-a.y*b.y,a.y*b.x+a.x*b.y);\n\t}\n};\ninline void print(complex *a){\n\tfor(int i=0;a[i].x||a[i].y||a[i+1].x||a[i+1].y;i++){\n\t\tprintf(\"%.2Lf %.2Lf\\n\",a[i].x,a[i].y);\n\t}\n}\ninline void print(int *a){\n\tfor(int i=0;a[i]||a[i+1];i++){\n\t\tprintf(\"%d \",a[i]);\n\t}\n\tputs(\"\");\n}\nstruct Poly{\n\tint rev[N],lim;\n\tcomplex a[N],b[N],c[N],d[N],qp[N];\n\tint f[N],g[N],q[N],h[N],p[N];\n\tinline int qpow(int x,int y){\n\t\tint res=1;\n\t\twhile(y){\n\t\t\tif(y&1) res=1ll*res*x%mod;\n\t\t\tx=1ll*x*x%mod;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void mkrv(int lm){\n\t\tint l=0;\n\t\tlim=1;\n\t\twhile(lim<lm){\n\t\t\tlim<<=1;\n\t\t\tl++;\n\t\t}\n\t\tfor(int i=1;i<lim;i++){\n\t\t\trev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));\n\t\t}\n\t\tfor(int i=1;i<lim;i<<=1){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tqp[lim/i*j]=comp(cos(j*pi/i),sin(j*pi/i));\n\t\t\t}\n\t\t}\n\t}\n\tinline void FFT(comp *a,int tpe){\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tif(i<rev[i]){\n\t\t\t\tswap(a[i],a[rev[i]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<lim;i<<=1){\n\t\t\tfor(int j=0;j<lim;j+=(i<<1)){\n\t\t\t\tfor(int k=0;k<i;k++){\n\t\t\t\t\tcomp t=a[i+j+k]*(tpe==1?qp[lim/i*k]:qp[lim/i*k].neg());\n\t\t\t\t\ta[i+j+k]=a[j+k]-t;\n\t\t\t\t\ta[j+k]=a[j+k]+t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline void MTT(int *f,int *g,int *ans,int n){\n\t\tfor(int i=0;i<lim;i++){\n\t\t\ta[i].x=f[i]>>15,a[i].y=f[i]&32767;\n\t\t\tc[i].x=g[i]>>15,c[i].y=g[i]&32767;\n\t\t}\n\t\tfor(int i=n;i<lim;i++){\n\t\t\ta[i]=c[i]=complex();\n\t\t}\n\t\tFFT(a,1);\n\t\tFFT(c,1);\n\t\tfor(int i=1;i<lim;i++){\n\t\t\tb[i]=a[lim-i].neg();\n\t\t}\n\t\tb[0]=a[0].neg();\n\t\tfor(int i=1;i<lim;i++){\n\t\t\td[i]=c[lim-i].neg();\n\t\t}\n\t\td[0]=c[0].neg();\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tcomplex aa=(a[i]+b[i])*complex(0.5,0);\n\t\t\tcomplex bb=(a[i]-b[i])*complex(0,-0.5);\n\t\t\tcomplex cc=(c[i]+d[i])*complex(0.5,0);\n\t\t\tcomplex dd=(c[i]-d[i])*complex(0,-0.5);\n\t\t\ta[i]=aa*cc+complex(0,1)*(aa*dd+bb*cc);\n\t\t\tb[i]=bb*dd;\n\t\t}\n\t\tFFT(a,-1);\n\t\tFFT(b,-1);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tint aa=(ll)(a[i].x/lim+0.5)%mod;\n\t\t\tint bb=(ll)(a[i].y/lim+0.5)%mod;\n\t\t\tint cc=(ll)(b[i].x/lim+0.5)%mod;\n\t\t\tans[i]=((1ll*aa*(1<<30)+1ll*bb*(1<<15)+cc)%mod+mod)%mod;\n\t\t}\n\t}\n\tinline void Mul(int *f,int *g,int *ans,int n){\n\t\tmkrv(n<<1);\n\t\tfor(int i=0;i<lim;i++){\n\t\t\tans[i]=0;\n\t\t}\n\t\tMTT(f,g,ans,n);\n\t\tfor(int i=n;i<lim;i++){\n\t\t\tans[i]=0;\n\t\t}\n\t}\n\tinline void Inv(int *f,int *g,int n){\n\t\tif(n==1){\n\t\t\tg[0]=qpow(f[0],mod-2);\n\t\t\treturn ;\n\t\t}\n\t\tInv(f,g,n+1>>1);\n\t\tMul(f,g,h,n);\n\t\tMul(h,g,p,n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tg[i]=2ll*g[i]%mod;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tg[i]=(g[i]+mod-p[i])%mod;\n\t\t}\n\t}\n\tint n,m;\n\tinline void work(){\n\t\tn=read();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tf[i]=read();\n\t\t}\n\t\tInv(f,g,n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\twrite(g[i]);\n\t\t\tout[len++]=' ';\n\t\t}\n\t}\n}w;\n```\n\u518d\u89c1 qwq~",
        "postTime": 1614850597,
        "uid": 365127,
        "name": "cyffff",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4239 \u3010\u4efb\u610f\u6a21\u6570\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\u3011"
    },
    {
        "content": "\u5c0f\u849f\u84bb\u6765\u6295\u4e00\u4efd karatsuba \u7684\u9898\u89e3 qwq\n\nkaratsuba \u7684\u601d\u60f3\u5c31\u662f\u5c06 $F$ \u5206\u89e3\u6210 $Ax^{p}+B$\uff0c\u5c06 $G$ \u5206\u89e3\u6210 $Cx^{p}+D$\uff0c\u4e8e\u662f\u6211\u4eec\u6709\n\n$$\\begin{aligned}&FG\\\\=&(Ax^{p}+B)(Cx^{p}+D)\\\\=&ACx^{2p}+(AD+BC)x^{p}+BD\\\\=&ACx^{2p}+((A+B)(C+D)-AC-BD)x^{p}+BD\\end{aligned}$$\n\n\u8fd9\u6837\u6211\u4eec\u4e00\u5171\u9700\u8981\u8fdb\u884c $3$ \u6b21\u89c4\u6a21\u51cf\u534a\u7684\u591a\u9879\u5f0f\u4e58\u6cd5\u3002\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f\n\n$$T(n)=3T(\\frac{n}{2})+O(n)$$\n\n\u89e3\u5f97\n\n$$T(n)=O(n^{\\log_{2}3})\\approx O(n\\sqrt{n})$$\n\n\u90a3\u4e48\u672c\u9898\u6211\u4eec\u5982\u679c\u4e5f\u7528 karatsuba \u7b97\u6cd5\u7684\u8bdd\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u5c06\u4f1a\u662f\n\n$$\\begin{aligned}&T(n)\\\\=&O\\left(\\sum_{k=0}^{\\lfloor\\log_{2}n\\rfloor}2^{k\\log_{2}3}\\right)\\\\=&O\\left(\\sum_{k=0}^{\\lfloor\\log_{2}n\\rfloor}3^{k}\\right)\\\\\\approx&O\\left(3^{\\log_{2}n}\\right)\\\\=&O\\left(3^{\\tfrac{\\log_{3}n}{\\log_{3}2}}\\right)\\\\=&O\\left(n^{\\log_{2}3}\\right)\\end{aligned}$$\n\n\u7136\u800c\u5e38\u6570\u5de8\u5927\u5e76\u8dd1\u4e0d\u8fc7\u53bb :(\n\n\u5e0c\u671b\u54ea\u4f4d\u5e38\u6570\u5e26\u5e08\u80fd\u591f\u6559\u6559\u6211\u600e\u4e48\u5361\u5e38\uff0c\u5728\u6b64\u5148\u8c22\u8fc7\u4e86\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#pragma GCC optimize(2)\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<cstdio>\n#include<ctime>\n#define re register\n#define maxn 200000\n#define maxdep 20\n#define alpha 64\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define max(a,b) ((a)>=(b)?(a):(b))\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint A[maxdep+1][maxn+1],B[maxdep+1][maxn+1],C[maxdep+1][maxn+1],D[maxdep+1][maxn+1];\nint tmp1[maxdep+1][maxn+1],tmp2[maxdep+1][maxn+1],tmp3[maxdep+1][maxn+1];\n__int128 tmp[maxn+1];\nint n,mod=1000000007;\nint F[maxn+1],G[maxn+1];\n\ninline int cltpow(re int x,re int n){\n\tre int res=1;\n\tfor(;n;n>>=1,x=1LL*x*x%mod)\n\t\tif(n&1)\n\t\t\tres=1LL*res*x%mod;\n\treturn res;\n}\n\ninline int Mod(re int x){\n\treturn x>=mod?x-mod:x;\n}\n\ninline int Add(re int x,re int y){\n\treturn x+y<mod?x+y:x+y-mod;\n}\n\ninline int Sub(re int x,re int y){\n\treturn x-y>=0?x-y:x-y+mod;\n}\n\ninline void print(re int* F,re int N){\n\tputchar('{');\n\tfor(re int i=0;i<=N;++i)\n\t\tprintf(\"%d%c\",F[i],i<N?',':'}');\n}\n\nvoid polyMul(re int* F,re int* G,re int* H,re int N,re int dep){\n\tif(N<=alpha){\n\t\tfor(re int i=0;i<=2*N;++i)\n\t\t\ttmp[i]=0;\n\t\tfor(re int i=0;i<=N;++i)\n\t\t\tfor(re int j=0;j<=N;++j)\n\t\t\t\ttmp[i+j]+=1LL*F[i]*G[j];\n\t\tfor(re int i=0;i<=2*N;++i)\n\t\t\tH[i]=tmp[i]%mod;\n\t}\n\telse{\n\t\tfor(re int i=0;i<=2*N;++i){\n\t\t\tH[i]=A[dep][i]=B[dep][i]=C[dep][i]=D[dep][i]=0;\n\t\t\ttmp1[dep][i]=tmp2[dep][i]=tmp3[dep][i]=0;\n\t\t}\n\t\tre int M=N>>1;\n\t\tfor(re int i=0;i<=N-M;++i){\n\t\t\tA[dep][i]=F[i+M];\n\t\t\tC[dep][i]=G[i+M];\n\t\t}\n\t\tpolyMul(A[dep],C[dep],tmp1[dep],N-M,dep+1);\n\t\tfor(re int i=0;i<=M-1;++i){\n\t\t\tB[dep][i]=F[i];\n\t\t\tD[dep][i]=G[i];\n\t\t}\n\t\tpolyMul(B[dep],D[dep],tmp2[dep],M-1,dep+1);\n\t\tfor(re int i=0;i<=M-1;++i){\n\t\t\tA[dep][i]=Add(A[dep][i],B[dep][i]);\n\t\t\tC[dep][i]=Add(C[dep][i],D[dep][i]);\n\t\t}\n\t\tpolyMul(A[dep],C[dep],tmp3[dep],N-M,dep+1);\n\t\tfor(re int i=0;i<=2*(N-M);++i)\n\t\t\ttmp3[dep][i]=Sub(tmp3[dep][i],tmp1[dep][i]);\n\t\tfor(re int i=0;i<=2*(M-1);++i)\n\t\t\ttmp3[dep][i]=Sub(tmp3[dep][i],tmp2[dep][i]);\n\t\tfor(re int i=0;i<=2*(N-M);++i)\n\t\t\tH[i+2*M]=Add(H[i+2*M],tmp1[dep][i]);\n\t\tfor(re int i=0;i<=2*(M-1);++i)\n\t\t\tH[i]=Add(H[i],tmp2[dep][i]);\n\t\tfor(re int i=0;i<=2*(N-M);++i)\n\t\t\tH[i+M]=Add(H[i+M],tmp3[dep][i]);\n\t}\n}\n\nvoid polyInv(re int* F,re int* G,re int N){\n\tfor(re int i=0;i<=N;++i)\n\t\tG[i]=tmp1[0][i]=0;\n\tG[0]=cltpow(F[0],mod-2);\n\tfor(re int k=1;k<=N;k<<=1){\n\t\tfor(re int i=0;i<=2*k;++i)\n\t\t\ttmp1[0][i]=F[i];\n\t\tpolyMul(tmp1[0],G,tmp2[0],2*k,1);\n\t\tpolyMul(tmp2[0],G,tmp1[0],2*k,1);\n\t\tfor(re int i=0;i<=2*k;++i)\n\t\t\tG[i]=Sub(Mod(2*G[i]),tmp1[0][i]);\n\t}\n}\n\nint main(){\n\tcltstream::read(n);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::read(F[i]);\n\tpolyInv(F,G,n-1);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::write(G[i],32);\n\tclop();\n\treturn 0;\n}\n```\n",
        "postTime": 1581079367,
        "uid": 63352,
        "name": "rehtorbegnaro",
        "ccfLevel": 7,
        "title": "\u300c\u6a21\u677f\u300d\u591a\u9879\u5f0f\u4e58\u6cd5\u9006\uff08\u52a0\u5f3a\u7248\uff09"
    }
]