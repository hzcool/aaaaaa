[
    {
        "content": "\u9898\u76ee\u4e2d\u7684\u7ec4\u5408\u63a8\u5bfc\u5e76\u4e0d\u590d\u6742\uff0c\u4eff\u7167\u6709\u6807\u53f7\u6709\u6839\u6811\u8ba1\u6570\u7684\u65b9\u6cd5\uff0c\u8bbe $n!k![x^ny^k]F$ \u8868\u793a\u6240\u6709 $n$ \u4e2a\u70b9\u7684\u6709\u6807\u53f7\u6709\u6839\u4e8c\u53c9\u6811\u6743\u503c $k$ \u6b21\u65b9\u548c\uff0c\u53ef\u4ee5\u5217\u51fa\u65b9\u7a0b\n\n$$F=x\\text e^y+x\\text e^{dy}F + \\frac{1}{2}x\\text e^{dy}F^2$$\n\n\u5982\u679c\u4e0d\u80fd\u76f4\u63a5\u63a8\u51fa\u8fd9\u4e2a\u65b9\u7a0b\uff0c\u4e5f\u53ef\u4ee5\u5148\u53d1\u73b0\u6811\u7684\u6743\u503c\u53ea\u4e0e\u5176\u8282\u70b9\u6570\u548c\u53f6\u5b50\u6570\u91cf\u6709\u5173\u3002\u5148\u8ba1\u91cf $n$ \u4e2a\u70b9\u3001$m$ \u4e2a\u53f6\u5b50\u7684\u4e8c\u53c9\u6811\u4e2a\u6570\uff0c\u7ecf\u8fc7\u5904\u7406\u4e5f\u53ef\u4ee5\u5f97\u5230\u4e00\u6837\u7684\u7ed3\u679c\u3002\n\n\u5bf9 $x$ \u8fd9\u4e00\u7ef4\u4f7f\u7528\u62c9\u683c\u6717\u65e5\u53cd\u6f14\uff0c\u628a\u539f\u5f0f\u5148\u5316\u4e3a\n\n$$x=\\frac{F}{\\text e^y+\\text e^{dy}F+\\text e^{dy}F^2/2}$$\n\u5f97\u5230\n$$[x^ny^k]F=\\frac 1n[x^{n-1}y^k]\\left( \\text e^y+\\text e^{dy}x+\\frac{\\text e^{dy}x^2}{2}\\right)^n$$\n$$=\\frac 1n[y^k]\\sum_{i=0}^n \\binom ni \\text e^{(n-i+di)y}[x^{n-1}]\\left( x+\\frac{x^2}{2}\\right)^i$$\n\u8fd9\u4e2a $\\text e$ \u4e0a\u7684\u6307\u6570\u770b\u7740\u5f88\u96be\u53d7\uff0c\u8bbe $md\\equiv (n-1) \\pmod p$\uff0c\u5316\u4e3a\n\n$$\\frac{(d-1)^k}{n}[y^k]\\text e^{my}\\sum_{i=0}^n \\binom ni \\text e^{iy}[x^{n-1}]\\left( x+\\frac{x^2}{2}\\right)^i$$\n\u73b0\u5728\u8bbe\n$$g(z)=\\sum_{i=0}^n \\binom ni z^i[x^{n-1}] \\left( x+\\frac{x^2}{2}\\right)^i=[x^{n-1}]\\left( 1+zx+\\frac{zx^2}{2}\\right)^n$$\n\u6ce8\u610f $g(z)$ \u662f\u4e00\u4e2a\u8d85\u51e0\u4f55\u7ea7\u6570\uff0c\u5176\u7cfb\u6570\u6ee1\u8db3\u7b80\u5355\u7684\u4e00\u9636\u6574\u5f0f\u9012\u63a8\uff1a  \n\n$$(2i-n)(2i+1-n)g_i = 2(n-i+1)(n-i)g_{i-1}$$\n\u5199\u4e3a ODE \u5c31\u662f\n\n$$(4z^2-2z^3)g''+((6-4n)z+(-4+4n)z^2)g'+(n(n-1)+2n(1-n)z)g=0$$\n\u73b0\u5728\u6211\u4eec\u60f3\u6c42 $[z^k]\\text e^{mz}g(\\text e^z)$\uff0c\u53ef\u4ee5\u5e94\u7528 EI \u63d0\u51fa\u7684\u4e00\u5957\u65b9\u6cd5\u3002\u5728\u6b64\u4e4b\u524d\u9700\u8981\u5148\u77e5\u9053 $G(z)=z^mg(z)$ \u7684 ODE\u3002\u5bf9 $G$ \u6c42\u4e8c\u9636\u5bfc\u53ef\u5f97\n$$zG'=mG+z^{m+1}g'$$\n$$z^2G''=2mzG'-m(m+1)G+z^{m+2}g''$$\n\u518d\u628a $g''$ \u7528 $g',g$ \u8868\u793a\u5c31\u53ef\u4ee5\u4e86\uff1a\n$$z^2(4-2z)G''-((-6+4n+8m)z+4(1-n-m)z^2)G'$$   \n$$+(m (m + 1) (4 - 2 z) + m ((6 - 4 n) + (4 n - 4) z) + \n n (n - 1) (2 z - 1))G =0$$\n\u73b0\u5728\u8981\u6c42 $[z^k]G(\\text e^z)$\uff0c\u7b2c\u4e00\u6b65\u662f\u6c42 $H(z)=G(z+1)\\bmod z^{k+1}$ \u6ee1\u8db3\u7684 ODE\uff0c\u4f46\u8fd9\u53c8\u5fc5\u987b\u77e5\u9053 $H(z)$ \u7684\u524d\u4e24\u9879\uff1a\n$$[z^0]H=G(1)=g(1)=[x^{n-1}]\\left( 1+x+\\frac{x^2}{2}\\right)^n$$\n$$[z^1]H=H'(0)=mg'(1)+g(1)$$\n\u8fd9\u53ef\u4ee5\u7528 [\u6574\u5f0f\u9012\u63a8](https://www.luogu.com.cn/problem/P6115) \u7b97\u6cd5\u4ee5 $\\Theta(\\sqrt n \\log n)$ \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u6c42\u89e3\uff08\u7531\u4e8e\u6a21\u6570\u56fa\u5b9a\uff0c\u4e5f\u53ef\u4ee5\u5206\u5757\u6253\u8868\uff09\u3002\u5728\u6c42\u89e3\u8fc7\u7a0b\u4e2d\u53ef\u4ee5\u5bf9\u6574\u5f0f\u9012\u63a8\u6a21\u677f\u5fae\u8c03\u4e00\u4e0b\uff0c\u8ba9\u6700\u540e\u7b54\u6848\u4e0d\u7528\u518d\u4e58 $n!$\u3002\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u9012\u63a8\u6c42 $H(z)$ \u7684\u7cfb\u6570\uff0c\u4ee5\u5f97\u5230\u4e00\u4e2a\u591a\u9879\u5f0f $D(z)$ \u4f7f\u5f97\n$$P_0(z)H(z)+P_1(z)H'(z)+P_2(z)H''(z)=D(z)$$\n\u7b49\u5f0f\u5de6\u8fb9\u5c31\u662f $G$ \u7684 ODE \u4e2d\u76f4\u63a5\u628a $z$ \u6362\u4e3a $z+1$ \u5f97\u5230\u7684\uff0c\u591a\u9879\u5f0f\u5e73\u79fb\u53ef\u4ee5\u66b4\u529b\u5904\u7406\u3002\u53f3\u8fb9\u591a\u51fa\u7684\u8fd9\u4e2a $D(z)$ \u5c31\u662f\u56e0\u4e3a\u622a\u65ad\u4e86 $z^k$ \u4e4b\u540e\u7684\u9879\u4ea7\u751f\u7684\u6270\u52a8\uff0c\u5b83\u53ea\u6709\u5e38\u6570\u4e2a\u975e\u96f6\u9879\u3002\n\n\u6700\u540e\u6c42\u51fa $\\mathcal G(z)=H(z-1)$ \u7684\u7cfb\u6570\uff0c\u8fd9\u6837 $[z^k]\\mathcal G(\\text e^z)$ \u5c31\u662f\u7b54\u6848\uff0c\u7ebf\u6027\u7b5b\u6c42\u5e42\u5373\u53ef\u3002\u6ce8\u610f\u9012\u63a8\u8fc7\u7a0b\u4e2d $D(z-1)$ \u7684\u7cfb\u6570\u53ef\u4ee5\u76f4\u63a5\u63d0\u53d6\uff08\u51e0\u4e2a\u4e8c\u9879\u5f0f\u7cfb\u6570\u7684\u7ebf\u6027\u7ec4\u5408\uff09\uff0c\u4e0d\u9700\u8981\u5c55\u5f00\u3002\n\n\u53e6\u5916\u8fd9\u91cc\u53ef\u4ee5\u5728 $\\Theta(1)$ \u7684\u65f6\u95f4\u5185\u6c42\u51fa $\\mathcal G(z)$ \u6700\u9ad8\u6b21\u9879\uff0c\u7136\u540e\u5012\u7740\u63a8\u56de\u53bb\uff0c\u4f1a\u6709\u4e0d\u9519\u7684\u5e38\u6570\u4f18\u5316\u3002\u4e0d\u8fc7\u9700\u8981\u6ce8\u610f\u4e00\u70b9\uff1a\u82e5 $n+m<k$\uff0c$H(z)$ \u7684 $k$ \u6b21\u9879\u4e3a\u96f6\uff0c\u8fd9\u91cc\u5012\u7740\u63a8\u4f1a\u51fa\u9519\uff0c\u5f53\u7136\u4e5f\u6ca1\u5fc5\u8981\u505a\u524d\u9762\u90a3\u4e48\u590d\u6742\uff0c\u76f4\u63a5\u7ebf\u6027\u7b5b\u540e\u66b4\u529b $\\Theta(n+m)$ \u8ba1\u7b97\u5373\u53ef\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(k+\\sqrt n \\log n)$\u3002std \u51e0\u4e4e\u4e0d\u53ef\u8bfb\uff0c\u4e0d\u5efa\u8bae\u76f4\u63a5\u8d3a\uff08 \n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#define N 262147\n#define M 5000005\n#define ll long long\n#define reg register\n#define p 998244353\nusing namespace std;\n\nstruct Z{\n    int v;\n    inline Z(const int _v=0):v(_v){}\n};\n\ninline Z operator + (const Z& lhs,const Z& rhs){ return lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; }\ninline Z operator - (const Z& lhs,const Z& rhs){ return lhs.v<rhs.v ? lhs.v-rhs.v+p : lhs.v-rhs.v; }\ninline Z operator - (const Z& x){ return x.v?p-x:0; }\ninline Z operator * (const Z& lhs,const Z& rhs){ return (ll)lhs.v*rhs.v%p; }\ninline Z& operator += (Z& lhs,const Z& rhs){ lhs.v = lhs.v+rhs.v<p ? lhs.v+rhs.v : lhs.v+rhs.v-p; return lhs; }\ninline Z& operator -= (Z& lhs,const Z& rhs){ lhs.v = lhs.v<rhs.v ? lhs.v-rhs.v+p : lhs.v-rhs.v; return lhs; }\ninline Z& operator *= (Z& lhs,const Z& rhs){ lhs.v = (ll)lhs.v*rhs.v%p; return lhs; }\ninline bool operator ! (const Z& x){ return x.v==0; }\n\nstruct poly{\n    Z a[8];\n    int t;\n    inline Z operator [] (const int& x) const{ return a[x]; }\n    inline Z& operator [] (const int& x){ return a[x]; }\n\n    inline Z eval(const int& x){\n        Z res = a[t];\n        for(reg int i=t-1;~i;--i) res = a[i]+res*x;\n        return res;\n    }\n}P[8];\n\nstruct ode{\n    poly b[8];\n    int ord,deg;\n    inline poly operator [] (const int& x) const{ return b[x]; }\n    inline poly& operator [] (const int& x) { return b[x]; }\n\n    inline void update(){\n        for(int i=0;i<8;++i) b[i].t = deg;\n    }\n};\n\ninline Z check1(const Z* f,const ode& G,int n){\n    Z res = 0,rfac;\n    for(int j=0;j<=min(n,G.deg);++j){\n        rfac = 1;\n        for(int i=0;i<=G.ord;++i){\n            res += G[i][j]*rfac*f[n-j+i];\n            rfac *= (n-j+1+i);\n        }\n    }\n    return res;\n}\n\ninline Z power(Z a,int t){\n    Z res = 1;\n    while(t){\n        if(t&1) res *= a;\n        a *= a;\n        t >>= 1;\n    }\n    return res;\n}\n\nZ fpw[M];\nint pr[348515];\nbool vis[M];\n\nvoid sieve(int n,int k){\n    fpw[1] = 1;\n    int cnt = 0;\n    for(int i=2;i<=n;++i){\n        if(!vis[i]){\n            vis[i] = true;\n            pr[++cnt] = i;\n            fpw[i] = power(i,k);\n        }\n        for(int j=1;j<=cnt&&i*pr[j]<=n;++j){\n            fpw[i*pr[j]] = fpw[i]*fpw[pr[j]];\n            vis[i*pr[j]] = true;\n            if(i%pr[j]==0) break;\n        }\n    }\n}\n\nint ms,deg;\n\nstruct matrix{\n    Z a[2][2];\n    inline matrix(){ memset(a,0,sizeof(a)); }\n\n    inline matrix operator * (const matrix& b) const{\n        matrix res;\n        res.a[0][0] = a[0][0]*b.a[0][0]+a[0][1]*b.a[1][0]; \n        res.a[1][0] = a[1][0]*b.a[0][0]+a[1][1]*b.a[1][0];\n        res.a[0][1] = a[0][0]*b.a[0][1]+a[0][1]*b.a[1][1];\n        res.a[1][1] = a[1][0]*b.a[0][1]+a[1][1]*b.a[1][1];\n        return res;    \n    }\n}I;\n\ninline matrix getmat(int x){\n    matrix res = matrix();\n    Z p0 = P[0].eval(x+ms);\n    for(reg int i=0;i!=ms-1;++i) res.a[i+1][i] = p0;\n    for(reg int i=0;i!=ms;++i) res.a[i][ms-1] = -P[ms-i].eval(x+ms);\n    return res;\n}\n\nZ fac[N],ifac[N],rt[N],facm[N],inv[M];\nint rev[N];\nint siz;\n\ninline int getlen(int n){ return 1<<(32-__builtin_clz(n)); }\n\nvoid init(int n,int k){\n    int lim = 1;\n    while(lim<=n) lim <<= 1,++siz;\n    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));\n    Z w = power(3,(p-1)>>siz);\n    inv[1] = fac[0] = fac[1] = ifac[0] = ifac[1] = rt[lim>>1] = 1;\n    for(int i=lim>>1|1;i!=lim;++i) rt[i] = rt[i-1]*w;\n    for(int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];\n    for(int i=2;i<=n;++i) fac[i] = fac[i-1]*i;\n    ifac[n] = power(fac[n],p-2);\n    for(int i=n-1;i;--i) ifac[i] = ifac[i+1]*(i+1);\n    for(int i=2;i<=k;++i) inv[i] = inv[p%i]*(p-p/i);\n    I.a[0][0] = I.a[1][1] = 1;\n}\n\ninline void dft(Z *f,int lim){\n    static unsigned long long a[N];\n    reg int x,shift = siz-__builtin_ctz(lim);\n    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i].v;\n    for(reg int mid=1;mid!=lim;mid<<=1)\n    for(reg int j=0;j!=lim;j+=(mid<<1))\n    for(reg int k=0;k!=mid;++k){\n        x = a[j|k|mid]*rt[mid|k].v%p;\n        a[j|k|mid] = a[j|k]+p-x;\n        a[j|k] += x;\n    }\n    for(reg int i=0;i!=lim;++i) f[i] = a[i]%p;\n}\n\ninline void idft(Z *f,int lim){\n    reverse(f+1,f+lim);\n    dft(f,lim);\n    reg int x = p-((p-1)>>__builtin_ctz(lim));\n    for(reg int i=0;i!=lim;++i) f[i] *= x;\n}\n\ninline void lagrange(const matrix* F1,int n,Z m,matrix* R1){\n    static Z pre[N],suf[N],f1[N],f2[N],g[N],inv_[N],ifcm[N],mul;\n    int k = n<<1|1,lim = getlen(n<<1);\n    facm[0] = 1;\n    for(reg int i=0;i<=n;++i){\n        facm[0] *= m-n+i;\n        ifcm[i] = ifac[i]*ifac[n-i];\n    }\n    pre[0] = suf[k+1] = 1;\n    for(reg int i=1;i<=k;++i) pre[i] = pre[i-1]*(m-n+i-1);\n    for(reg int i=k;i;--i) suf[i] = suf[i+1]*(m-n+i-1);\n    mul = power(pre[k],p-2);\n    for(reg int i=1;i<=k;++i) inv_[i] = mul*pre[i-1]*suf[i+1];\n    for(reg int i=1;i<=n;++i) facm[i] = facm[i-1]*(m+i)*inv_[i];\n    for(reg int i=0;i!=k;++i) g[i] = inv_[i+1];\n    memset(g+k,0,(lim-k+1)<<2);\n    dft(g,lim);\n    for(reg int i=0;i!=ms;++i)\n    for(reg int j=0;j!=ms;++j){\n        for(reg int t=0;t<=n;++t) f1[t] = ifcm[t]*((n-t)&1?-F1[t].a[i][j]:F1[t].a[i][j]);\n        memset(f1+n+1,0,(lim-n)<<2);\n        dft(f1,lim);\n        for(reg int t=0;t!=lim;++t) f1[t] *= g[t];\n        idft(f1,lim);\n        for(reg int t=0;t<=n;++t) R1[t].a[i][j] = f1[t+n]*facm[t];\n    }\n}\n\ninline matrix ff(int d,int x){\n    matrix res = getmat(x);\n    for(reg int i=1;i!=d;++i) res = res*getmat(x+i);\n    return res;\n}\n\ninline Z gg(int d,int x){\n    Z res = P[0].eval(x);\n    for(reg int i=1;i!=d;++i) res *= P[0].eval(x+i);\n    return res;\n}\n\nint kk;\n\nmatrix magic(int s,int t){ \n    static Z invs = power(s,p-2);\n    static matrix f[N],fd[N];\n    int st[30],top = 0,x = s,d = 1,kd;\n    while(x){\n        st[++top] = x;\n        x >>= 1;\n    }\n    for(reg int i=0;i<=kk;++i){\n        x = i*s;\n        f[i] = getmat(x);\n    }\n    --top;\n    while(top--){\n        kd = kk*d;\n        lagrange(f,kd,kd+1,f+kd+1);\n        f[kd<<1|1] = matrix();\n        lagrange(f,kd<<1,d*invs,fd);\n        for(reg int i=0;i<=(kd<<1);++i) f[i] = f[i]*fd[i];\n        d <<= 1;\n        if(!(st[top+1]&1)) continue;\n        kd = kk*(d+1);\n        for(reg int i=kk*d+1;i<=kd;++i){\n            x = i*s;\n            f[i] = ff(d,x);\n        }\n        for(reg int i=0;i<=kd;++i){\n            x = i*s;\n            f[i] = f[i]*getmat(x+d);\n        }\n        ++d;\n    }\n    matrix r1 = I;\n    for(reg int i=0;i<=t;++i) r1 = r1*f[i];\n    return r1;\n}\n\nZ P_recursive(const Z *a,int n){\n    int tn = n-ms+1,s;\n    s = ceil(sqrt(tn*1.0/kk))+1;\n    matrix mul = magic(s,(tn-s)/s);\n    Z res = 0;\n    for(reg int i=(tn/s)*s;i!=tn;++i) mul = mul*getmat(i);\n    for(int i=0;i!=ms;++i) res += a[i]*mul.a[i][ms-1];\n    return res;\n}\n\ninline Z binom(int n,int m){\n    if(n<m) return Z(0);\n    return fac[n]*ifac[m]*ifac[n-m];\n}\n\nZ prepare(int k,int n){ \n    static Z a[N];\n    deg = kk = 1;\n    ms = 2;\n    P[0][1] = 1;\n    P[1][0] = p-(k+1),P[1][1] = 1;\n    P[2][0] = p-(k+1),P[2][1] = inv[2];\n    a[0] = 1,a[1] = k;\n    P[0].t = P[1].t = P[2].t = 1;\n    if(n<=1000){\n        for(int i=2;i<=n;++i){\n            Z res = P[1].eval(i)*a[i-1]+P[2].eval(i)*a[i-2];\n            a[i] = -res*power(P[0].eval(i),p-2);\n        }\n        return a[n]*fac[n];\n    }\n    return P_recursive(a,n);\n}\n\node G,H;\n\nvoid poly_shift(){\n    for(int i=0;i<=G.ord;++i)\n    for(int k=0;k<=G.deg;++k)\n    for(int j=k;j<=G.deg;++j)\n        H[i][k] += G[i][j]*binom(j,k);\n}\n\nint n,k,d,len,lim;\nZ g[M],h[M],pre[M],suf[M];\nZ ans,m,r1,r2,r3;\n\ninline Z check2(const int& n){\n    Z res = H[0][0]*h[n]+H[1][0]*h[n+1]*(n+1);\n    res += H[0][1]*h[n-1]+(H[1][1]*h[n]+H[2][1]*h[n+1]*(n+1))*n;\n    res += (H[1][2]*h[n-1]+H[2][2]*h[n]*n)*(n-1);\n    return res+H[2][3]*h[n-1]*(n-1)*(n-2);\n}\n\nint main(){ \n    scanf(\"%d%d%d\",&n,&k,&d);\n    m = power(d-1,p-2)*n;\n    init(131075,max(1000,k)+3); \n    if(n+m.v<k){\n        Z pw2 = power(2,p-n);\n        for(int i=0;i<=n;++i){\n            g[i] = fac[n-1]*binom(n,i)*binom(i,n-i-1)*pw2;\n            pw2 += pw2;\n        }\n        sieve(n+m.v,k);\n        for(int i=0;i<=n;++i) ans += fpw[m.v+i]*g[i];\n        ans *= power(d-1,k); \n        printf(\"%d\\n\",ans.v);\n        return 0;\n    }\n    Z _n = n,tmp;\n    G[0][0] = p-m*(m+1)*4+m*(6-4*_n)+_n*(1+p-_n);\n    G[0][1] = m*(m+1)*2+m*(4*_n-4)+2*_n*(_n-1);\n    G[1][1] = 4*_n+8*m-6,G[1][2] = 4*(1+p-_n-m);\n    G[2][2] = p-4,G[2][3] = 2;\n    G.ord = H.ord = 2,G.deg = H.deg = 3;\n    poly_shift();\n    G.update(),H.update();\n    h[0] = prepare(n,n-1);\n    if(k==0){\n        printf(\"%d\",h[0].v);\n        return 0;\n    }\n    h[1] = (h[0]-prepare(n-1,n-1))*n+h[0]*m;\n    Z invh0 = power(H[2][0],p-2);\n    for(int i=0;i<=min(k-2,2);++i) h[i+2] = -check1(h,H,i)*invh0*inv[i+1]*inv[i+2];\n    for(int i=3;i<=k-2;++i) h[i+2] = -check2(i)*invh0*inv[i+1]*inv[i+2];\n    r1 = check1(h,H,k-1),r2 = check1(h,H,k),r3 = check1(h,H,k+1);\n    g[k] = h[k],g[k-1] = h[k-1]-h[k]*k;\n    pre[0] = suf[k+1] = 1;\n    for(int j=1;j<=k;++j) pre[j] = G[0][1]+(G[1][2]+(j-2)*2)*(j-1);\n    for(int j=k;j;--j) suf[j] = suf[j+1]*pre[j];\n    for(int j=1;j<=k;++j) pre[j] *= pre[j-1]; \n    Z Inv = power(pre[k],p-2),c1 = r1,c2 = k*r2,c3 = inv[2]*(k+1)*k*r3,falfac = 1;\n    if(Inv.v==0){\n        return 1;\n    }\n    for(int j=k-1;j>1;--j){\n        Z tmp1 = (G[0][0]+j*(G[1][1]-(j-1)*4))*g[j];\n        Z tmp2 = (k-j)&1?(c1-c2+c3):(c2-c1-c3);\n        g[j-1] = (tmp2*falfac-tmp1)*Inv*pre[j-1]*suf[j+1];\n        c1 *= inv[k-j],c2 *= inv[k-j+1],c3 *= inv[k-j+2];\n        falfac *= j;\n    }\n    sieve(k,k);\n    for(int i=1;i<=k;++i) ans += fpw[i]*g[i];\n    ans *= power(d-1,k);\n    printf(\"%d\\n\",ans.v);\n    return 0;   \n}\n```",
        "postTime": 1665405119,
        "uid": 115864,
        "name": "NaCly_Fish",
        "ccfLevel": 6,
        "title": "P8560 \u7ea6\u5b9a\uff08Promise\uff09"
    }
]