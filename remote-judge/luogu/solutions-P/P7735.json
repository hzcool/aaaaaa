[
    {
        "content": "\u5927\u5bb6\u597d\u554a\uff01\u4f5c\u4e3a\u4e00\u4e2a\u849f\u84bb\uff0c\u80fd\u5728\u7ebf\u4e0a\u540c\u6b65\u8d5b\u7684\u65f6\u5019\u628a\u8fd9\u9898\u505a\u51fa\u6765\uff0c\u6211\u7684\u5fc3\u91cc\u53ef\u662f\u4e07\u5206\u6b23\u559c\u7684\u554a\uff01\uff08\u5927\u4f6c\u52ff\u5632\uff09\n\n\u597d\u4e86\uff0c\u8bdd\u4e0d\u591a\u8bf4\uff0c\u6211\u6765\u4e0e\u5927\u5bb6\u5206\u4eab\u4e00\u4e0b\u6211\u7684\u60f3\u6cd5\u3002\uff08\u53ef\u80fd\u6709\u70b9\u5570\u55e6\uff09\n\n\u770b\u5230\u8fd9\u4e2a\u9898\uff0c\u6811\u4e0a\u7684\u8def\u5f84\u64cd\u4f5c\u5e76\u67e5\u8be2\uff0c\u90a3\u4e0d\u5c31\u662f\u6811\u5256\u4e48\uff1f\u5fc3\u91cc\u987f\u65f6\u6709\u4e86\u5e95\u3002\u53ef\u662f\u4ed4\u7ec6\u8bfb\u9898\uff0c\u53d1\u73b0\u5e76\u4e0d\u662f\u5355\u7eaf\u5730\u8def\u5f84\u64cd\u4f5c\uff0c\u8fd8\u4f1a\u6d89\u53ca\u5230\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u90bb\u8fb9\u7684\u4fee\u6539\u3002\u8fd9\u600e\u4e48\u641e\uff1f\u8c8c\u4f3c\u5355\u7eaf\u76f4\u767d\u7684\u6811\u5256\u5e76\u4e0d\u80fd\u89e3\u51b3\u95ee\u9898\u3002\u8fd9\u6761\u8def\u80fd\u5426\u8d70\u901a\u5462\uff1f\n\n\u5176\u5b9e\u662f\u80fd\u7684\u3002\u6211\u4eec\u5bf9\u95ee\u9898\u8fdb\u884c\u4e00\u4e2a\u7b80\u5355\u800c\u5de7\u5999\u7684\u8f6c\u5316\uff0c\u5c31\u80fd\u89e3\u51b3\uff01\u5982\u679c\u6211\u4eec\u5728\u6bcf\u6b21\u64cd\u4f5c\u7684\u65f6\u5019\uff0c\u5c06\u4fee\u6539\u8def\u5f84\u4e0a\u7684\u70b9\u5168\u90e8\u67d3\u4e0a\u4e00\u79cd**\u72ec\u4e00\u65e0\u4e8c\u7684\u989c\u8272**\uff0c\u5224\u65ad\u91cd\u8fb9\u5c31\u53ea\u9700\u8981\u5224\u65ad\u4e24\u7aef\u70b9\u989c\u8272\u662f\u5426\u76f8\u540c\u5373\u53ef\u3002\u7aef\u70b9\u989c\u8272\u76f8\u540c\u4e3a\u91cd\u8fb9\uff0c\u5426\u5219\u4e3a\u8f7b\u8fb9\u3002\n\n\u5982\u679c\u60a8\u61c2\u4e86\uff0c\u5c31\u53ef\u4ee5\u8df3\u8fc7\u4e0b\u9762\u8fd9\u6bb5\u8bdd\u3002\n\n\u6ca1\u6709\u592a\u61c2\u7684\u8bdd\uff0c\u5177\u4f53\u7684\u8bb2\u4e00\u8bb2\uff0c\u56e0\u4e3a\u8981\u5c06\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u8fb9\u4fee\u6210\u91cd\u8fb9\uff0c\u90a3\u4e48\u8def\u5f84\u70b9\u67d3\u540c\u8272\u7684\u64cd\u4f5c\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u8fd9\u6761\u8def\u5f84\u4e0a**\u70b9\u540c\u8272\u4e14\u6240\u6709\u8fb9\u4e24\u7aef\u70b9\u540c\u8272**\uff0c\u8fd9\u6837\u8fd9\u4e9b\u8fb9\u5c31\u7b26\u5408\u91cd\u8fb9\u7684\u5224\u5b9a\u4e86\uff01\u800c\u4e14\u66f4\u5999\u7684\u662f\uff0c\u7531\u4e8e\u8fd9\u4e9b\u70b9\u88ab\u67d3\u6210\u7684\u662f\u4e00\u79cd**\u72ec\u4e00\u65e0\u4e8c\u7684\u989c\u8272**\uff0c\u662f\u4e00\u5b9a\u4e0d\u4e0e\u524d\u9762\u7684\u989c\u8272\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u6240\u6709\u67d3\u8272\u70b9\u8fde\u8fb9\u7684\u53e6\u4e00\u7aef\u4e00\u5b9a\u4e0e\u5b83\u7684\u989c\u8272\u4e0d\u540c\uff0c\u8fd9\u6837\u5b50\u8fd9\u4e9b\u8fb9\u5c31\u81ea\u7136\u800c\u7136\u7684\u53d8\u6210\u4e86\u8f7b\u8fb9\u3002\u8fd9\u4e2a\u8f6c\u5316\u4e0d\u5f97\u4e0d\u8bf4\u662f\u5f88\u7cbe\u5999\u7684\u3002\n\n\u4e8e\u662f\uff0c\u95ee\u9898\u53d8\u6210\u4e86\uff1a\n\n\u5982\u4f55\u7edf\u8ba1\u6811\u7684\u4e00\u6bb5\u8def\u5f84\u4e0a**\u540c\u8272\u76f8\u90bb**\u70b9\u5bf9\u7684\u6570\u91cf\uff1f\uff08\u76f8\u90bb\uff1a\u4fdd\u8bc1\u4e24\u70b9\u6709\u8fb9\uff1b\u540c\u8272\uff1a\u4fdd\u8bc1\u662f\u91cd\u8fb9\uff09\n\n\u8fd9\u91cc\u63d0\u4f9b\u4e00\u79cd\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u7ecf\u5178\u65b9\u6cd5\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u5efa\u7acb\u7ed3\u6784\u4f53\uff0c\u5206\u522b\u5b58\u50a8\u4e09\u4e2a\u4fe1\u606f\uff1a\u8be5\u533a\u95f4\u5de6\u7aef\u70b9\u989c\u8272\u3001\u8be5\u533a\u95f4\u53f3\u7aef\u70b9\u989c\u8272\u3001\u8be5\u533a\u95f4\u5185\u540c\u8272\u76f8\u90bb\u70b9\u5bf9\u6570\u91cf\u3002\u8fd9\u6837\u5728\u5408\u5e76\u7684\u65f6\u5019\uff0c\u901a\u8fc7\u6bd4\u8f83\u4e24\u533a\u95f4\u63a5\u5934\u5904\u989c\u8272\u7684\u60c5\u51b5\uff0c\u6765\u66f4\u65b0\u65b0\u7684\u533a\u95f4\u7b54\u6848\u3002\u5177\u4f53\u53ef\u4ee5\u770b\u770b\u4ee3\u7801\uff0c\u91cc\u9762\u6709\u8be6\u5c3d\u7684\u6ce8\u91ca\u548c\u9677\u9631\u7684\u63d0\u9192\uff08\u7801\u98ce\u5de8\u4e11\u4e0d\u559c\u53ef\u8c03\uff09\n\n\u54e6\u54e6\uff0c\u53e6\u5916\u8865\u5145\u4e00\u4e0b\uff0c\u8fd9\u4e2a\u9898\u7684\u4ee3\u7801\u4e2d\u6811\u5256\u533a\u95f4\u67e5\u8be2\u53ef\u4ee5\u8bf4\u662f\u4e00\u5927\u91cd\u96be\u70b9\u3002\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u67e5\u8be2\u533a\u95f4\u5de6\u53f3\u201c\u6709\u5e8f\u201d\uff0c\u6240\u4ee5\u6211\u4eec\u4f1a\u8bbe\u7f6e\u4e24\u4e2a\u7b54\u6848\u53d8\u91cf$ans1$\u548c$ans2$\uff0c\u5206\u522b\u4ee5\u4e0b\u56fe\u7684\u65b9\u5f0f\u4ece\u4e24\u5934\u7edf\u8ba1\u7b54\u6848\uff0c\u6700\u540e\u518d\u5408\u5e76\u3002\u8fd8\u662f\u770b\u4ee3\u7801\u5427\u5927\u5bb6~~\n\n![Pic](https://cdn.luogu.com.cn/upload/image_hosting/pvqm78vg.png?x-oss-process=image/resize,m_lfit,h_170,w_225)\n\n```\n#include <cstring>\n#include <cstdio>\nconst int MX=100005;\nint n,ind,fir[MX],deep[MX],idx[MX],topf[MX],son[MX],sz[MX],fa[MX];\nstruct Edge{int to,nxt;}e[MX<<1];\nstruct Node{int lc,rc,cnt;void cln(){lc=rc=cnt=0;}};\n//Node\u7ed3\u6784\u4f53\u4e2d\uff1alc\u5de6\u989c\u8272\uff0crc\u53f3\u989c\u8272\uff0ccnt\u4e2a\u6570 \nstruct Segtree{\n\tint lazy[MX<<2];Node tree[MX<<2];\n\tvoid cln(){\n\t\t//\u7ebf\u6bb5\u6811\u5185\u6e05\u7a7a \n\t    memset(lazy,0,sizeof lazy);\n\t\tfor(int i=0,h=MX<<2;i<h;i++)tree[i].cln();\t\n\t}\n\tvoid lazy_down(int k,int l,int r){\n\t\t//\u61d2\u6807\u8bb0\u4e0b\u4f20 \n\t\tif(!lazy[k])return;\n\t\tint x=lazy[k],mid=(l+r)>>1;lazy[k]=0;\n\t\tlazy[k<<1]=lazy[k<<1|1]=x;\n\t\ttree[k<<1]=(Node){x,x,mid-l};\n\t\t//\u4e3a\u4ec0\u4e48\u662fmid-l\uff1f\u56e0\u4e3a\u4e00\u5171\u6709mid-l+1\u4e2a\u70b9\u90fd\u88ab\u67d3\u6210\u989c\u8272x\uff0c\u6240\u4ee5\u8003\u8651\u95f4\u9694\u6709mid-l\u5bf9 \n\t\ttree[k<<1|1]=(Node){x,x,r-mid-1};\n\t\t//\u4e3a\u4ec0\u4e48\u662fr-mid-1\uff1f\u7406\u7531\u540c\u4e0a\u5566 \n\t}\n\tvoid update(int ul,int ur,int nl,int nr,int pos,int num){\n\t\tif(ul<=nl&&nr<=ur){\n\t\t\ttree[pos]=(Node){num,num,nr-nl};\n\t\t\t//\u4e3a\u4ec0\u4e48\u662fnr-nl\uff1f\u7406\u7531\u5728lazy_down\u51fd\u6570\u91cc\u5566 \n\t\t\tlazy[pos]=num;return;\n\t\t}\n\t\tlazy_down(pos,nl,nr);int mid=(nl+nr)>>1;\n\t\tif(ul<=mid)update(ul,ur,nl,mid,pos<<1,num);\n\t\tif(mid<ur)update(ul,ur,mid+1,nr,pos<<1|1,num);\n\t\tNode ls=tree[pos<<1],rs=tree[pos<<1|1];\n\t\ttree[pos]=(Node){\n\t\t\tls.lc,rs.rc,ls.cnt+rs.cnt+(ls.rc==rs.lc)\n\t\t};\n\t\t//\u5173\u952e\u2191\u533a\u95f4\u5408\u5e76\uff0c\u5e94\u8be5\u6bd4\u8f83\u597d\u61c2\uff0c\u5173\u952e\u5728\u4e8e\u5de6\u513f\u5b50\u7684\u53f3\u989c\u8272\n\t\t//\u548c\u53f3\u513f\u5b50\u7684\u5de6\u989c\u8272\u76f8\u540c\u65f6\uff0c\u9700\u8981\u5c06\u8ba1\u6570\u5668\u52a0\u4e00 \n\t}\n\tNode query(int al,int ar,int nl,int nr,int pos){\n\t\tif(al<=nl&&nr<=ar)return tree[pos];\n\t\tlazy_down(pos,nl,nr);int cnt=0,mid=(nl+nr)>>1;Node w1,w2;\n\t\t//cnt\u8d1f\u8d23\u63a7\u5236\u67e5\u8be2\u60c5\u51b5\u79cd\u7c7b\uff0c\u89c1\u4e0b\u2193 \n\t\tif(al<=mid){cnt++;w1=query(al,ar,nl,mid,pos<<1);}\n\t\tif(mid<ar){cnt+=2;w2=query(al,ar,mid+1,nr,pos<<1|1);}\n\t\tif(cnt==1)return w1;if(cnt==2)return w2;\n\t\treturn (Node){\n\t\t\tw1.lc,w2.rc,w1.cnt+w2.cnt+(w1.rc==w2.lc)\n\t\t};\n\t\t//\u540c\u6837\u662f\u5173\u952e\u7684\u5408\u5e76\uff0c\u540cupdate\u51fd\u6570\u64cd\u4f5c \n\t}\n}sgtree;\nvoid add(int a,int b,int pos){\n\te[pos]=(Edge){b,fir[a]};fir[a]=pos;\n}\n//\u5efa\u8fb9 \nvoid swp(int& a,int& b){int t=a;a=b;b=t;}\n//\u624b\u5199\u4ea4\u6362swap\u51fd\u6570 \nvoid all_cln(){\n\t//\u8fd9\u4e2a\u51fd\u6570\u662f\u638c\u7ba1\u6e05\u7a7a\u7684\uff0c\u591a\u7ec4\u6570\u636e\u4e00\u5b9a\u8981\u5c0f\u5fc3\uff01\n\t//\u5efa\u8bae\uff1a\u80fd\u6e05\u7684\u90fd\u6e05\u4e86\uff0c\u514d\u5f97\u51fa\u73b0\u4ec0\u4e48\u5947\u602a\u7684\u9519\u8bef \n\tind=0;sgtree.cln();\n\tmemset(sz,0,sizeof sz);\n\tmemset(fa,0,sizeof fa);\n\tmemset(idx,0,sizeof idx);\n\tmemset(fir,0,sizeof fir);\n\tmemset(son,0,sizeof son);\n\tmemset(topf,0,sizeof topf);\n\tmemset(deep,0,sizeof deep);\n}\nvoid dfs1(int x,int f,int d){\n\tdeep[x]=d;fa[x]=f;sz[x]=1;\n\tfor(int i=fir[x];i;i=e[i].nxt){\n\t\tint h=e[i].to;\n\t\tif(h!=f){\n\t\t\tdfs1(h,x,d+1);sz[x]+=sz[h];\n\t\t\tif(sz[h]>sz[son[x]])son[x]=h;\n\t\t}\n\t}\n}\n//\u6811\u5256\u5e38\u89c4\u7b2c\u4e00\u904ddfs \nvoid dfs2(int x,int tp){\n\tif(!x)return;topf[x]=tp;\n\tidx[x]=++ind;dfs2(son[x],tp);\n\tfor(int i=fir[x];i;i=e[i].nxt){\n\t\tint h=e[i].to;if(h!=son[x]&&h!=fa[x])dfs2(h,h);\n\t}\n}\n//\u6811\u5256\u5e38\u89c4\u7b2c\u4e8c\u904ddfs \nvoid range_update(int x,int y,int num){\n\twhile(topf[x]!=topf[y]){\n\t\tint tx=topf[x],ty=topf[y];\n\t\tif(deep[tx]<deep[ty]){swp(x,y);swp(tx,ty);}\n\t\tsgtree.update(idx[tx],idx[x],1,n,1,num);\n\t\tx=fa[tx];\n\t}\n\tif(deep[x]<deep[y])swp(x,y);\n\tsgtree.update(idx[y],idx[x],1,n,1,num);\n}\n//\u6811\u5256\u533a\u95f4\u4fee\u6539 \nint range_query(int x,int y){\n\t//\u6811\u5256\u7684\u533a\u95f4\u67e5\u8be2\uff0c\u53ef\u4ee5\u8bf4\u662f\u6574\u4e2a\u7a0b\u5e8f\u7684\u5927\u6838\u5fc3\uff0c\u4e00\u5b9a\u8981\u6df1\u523b\u7406\u89e3\n\t//\u5efa\u8bae\u753b\u56fe\u8f85\u52a9\u601d\u8003\uff0c\u4f1a\u6709\u4e00\u5b9a\u96be\u5ea6 \n\tbool flg=0;//flg\u8868\u793a\u5f53\u524d\u7b54\u6848\u5e94\u5f52\u5230\u54ea\u8fb9\uff0c0\u4e3aans1,1\u4e3aans2 \n\tNode h,ans1=(Node){0,0,0},ans2=(Node){0,0,0};\n\twhile(topf[x]!=topf[y]){\n\t\tint tx=topf[x],ty=topf[y];\n\t\tif(deep[tx]<deep[ty]){flg=!flg;swp(tx,ty);swp(x,y);}\n\t\t//\u8bb0\u5f97\u540c\u65f6\u53d6\u53cdflg \n\t\th=sgtree.query(idx[tx],idx[x],1,n,1);\n\t\t//\u4ee5\u4e0b\u662f\u6700\u6838\u5fc3\u90e8\u5206\u2193\n\t\t//\u8bf7\u5927\u5bb6\u4e00\u5b9a\u6ce8\u610f\uff1a\u6bcf\u6b21\u7684\u67e5\u8be2h\uff0c\u4e00\u5b9a\u662f\u5de6\u7aef\u70b9\u5728\u6df1\u5ea6\u5c0f\u7684\u5730\u65b9\uff0c\n\t\t//\u53f3\u7aef\u70b9\u5728\u6df1\u5ea6\u5927\u7684\u5730\u65b9\uff0c\u6240\u4ee5\u5343\u4e07\u4e0d\u80fd\u628a\u5de6\u53f3\u7aef\u70b9\u5408\u5e76\u9519 \n\t\tif(flg)\n\t\t    ans2=(Node){\n\t\t\t\th.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)\n\t\t\t};\n\t\t//ans2\u60c5\u51b5 \n\t\telse\n\t\t\tans1=(Node){\n\t\t\t\tans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)\n\t\t\t};\n\t\t//ans1\u60c5\u51b5 \n\t\tx=fa[tx];\n\t}\n\tif(deep[x]<deep[y]){swp(x,y);flg=!flg;}\n\th=sgtree.query(idx[y],idx[x],1,n,1);\n\tif(flg)\n\t    ans2=(Node){\n\t\t\th.lc,ans2.rc,ans2.cnt+h.cnt+(ans2.lc==h.rc)\n\t\t};\n\telse\n\t\tans1=(Node){\n\t\t\tans1.lc,h.lc,ans1.cnt+h.cnt+(ans1.rc==h.rc)\n\t\t};\n\t//\u672b\u5904\u7406 \n\treturn ans1.cnt+ans2.cnt+(ans1.rc==ans2.lc);\n}\nint main(){\n\t//freopen(\"edge.in\",\"r\",stdin);\n    //freopen(\"edge.out\",\"w\",stdout);\n\tint data;scanf(\"%d\",&data);\n\tfor(int i=1;i<=data;i++){\n\t\tall_cln();//\u522b\u5fd8\u4e86\u6e05\u7a7a\uff01\uff01 \n\t\tint m;scanf(\"%d%d\",&n,&m);\n\t\tfor(int j=1;j<n;j++){\n\t\t\tint a,b;scanf(\"%d%d\",&a,&b);\n\t\t\tadd(a,b,j);add(b,a,j+n-1);\n\t\t}\n\t\tdfs1(1,0,1);dfs2(1,1);\n\t\tfor(int j=1;j<=n;j++)sgtree.update(idx[j],idx[j],1,n,1,-idx[j]);\n\t\t//\u4e0a\u9762\u8fd9\u53e5\u4e5f\u5f88\u91cd\u8981\uff0c\u5148\u628a\u6bcf\u4e2a\u70b9\u8d77\u59cb\u8d4b\u4e00\u4e2a\u4e92\u4e0d\u76f8\u540c\u7684\u503c\uff0c\n\t\t//\u968f\u4fbf\u4f60\u8d4b\u5565 \n\t\tfor(int j=1;j<=m;j++){\n\t\t    int opt,a,b;\n\t\t\tscanf(\"%d%d%d\",&opt,&a,&b);\n\t\t\tif(opt&1)range_update(a,b,j);\n\t\t\t//\u4ee5\u8be2\u95ee\u7f16\u53f7j\u4f5c\u4e3a\u201c\u72ec\u4e00\u65e0\u4e8c\u7684\u989c\u8272\u201d \n\t\t\telse printf(\"%d\\n\",range_query(a,b));\n\t\t}\n\t}\n\t//fclose(stdin);\n    //fclose(stdout);\n\treturn 0;\n}\n```\n\n\n\u8fd9\u91cc\uff0c\u518d\u7ed9\u5927\u5bb6\u9001\u4e00\u9053\u9898\uff1a\n[P2486  \u67d3\u8272](https://www.luogu.com.cn/problem/P2486)\n\n\u8fd9\u9053\u9898\u4e5f\u662f\u7ebf\u6bb5\u6811\u4fe1\u606f\u7ef4\u62a4\u7684\u7ecf\u5178\u8fd0\u7528\uff0c\u548c\u672c\u9898\u8f6c\u5316\u540e\u57fa\u672c\u7c7b\u4f3c\uff0c\u5927\u5bb6\u53ef\u4ee5\u53bb\u8bd5\u8bd5\u54df\u3002\n\n\u8c22\u8c22\u5927\u5bb6\uff01",
        "postTime": 1627310311,
        "uid": 513404,
        "name": "\u5c0f\u6bd3",
        "ccfLevel": 0,
        "title": "P7735\u9898\u89e3"
    },
    {
        "content": "\u6211\u4eec\u53ef\u4ee5\u628a\u5bf9\u300c\u8fb9\u300d\u7684\u8be2\u95ee\u8f6c\u5230\u300c\u70b9\u300d\u4e0a\uff01\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5bf9\u4e8e\u4e00\u6761\u8fb9 $(u,v)$\uff0c\u6211\u4eec\u8ba4\u4e3a\uff1a\n\n- \u5f53 $\\text{val}(u)=\\text{val}(v)$ \u65f6\uff0c$(u,v)$ \u662f\u4e00\u6761**\u91cd\u8fb9**=w=\n- \u5426\u5219\uff0c$(u,v)$ \u5c31\u662f\u4e00\u6761**\u8f7b\u8fb9**>_<\n\n\u5176\u4e2d\uff0c$\\text{val}(x)$ \u8868\u793a\u70b9 $x$ \u7684\u6743\u503c\uff0c\u8fd9\u4e2a\u6743\u503c\u6211\u4eec\u53ef\u4ee5\u81ea\u5df1\u5b9a\u4e49\uff5e\n\n\u8fd9\u6837\u4e00\u6765\uff0c\u4fee\u6539\u64cd\u4f5c\u5c31\u53d8\u6210\u4e86\uff1a\n\n- \u8bbe $k$ \u6ee1\u8db3 $\\forall x,\\text{val}(x)\\neq k$\u3002\n- \u540c\u65f6\u5bf9\u4e8e\u6bcf\u4e2a\u5728\u8def\u5f84 $u\\rightsquigarrow v$ \u4e0a\u7684\u70b9 $x$\uff0c\u5c06 $\\text{val}(x)$ \u4fee\u6539\u4e3a $k$\u3002\n\n\u90a3\u4e48\u67e5\u8be2\u64cd\u4f5c\u5b9e\u9645\u4e0a\u4e5f\u5c31\u53d8\u6210\u4e86\uff1a\u67e5\u8be2\u533a\u95f4\u5185\u6709\u591a\u5c11\u4e2a\u76f8\u90bb\u7684\u70b9\u5bf9\uff0c\u6ee1\u8db3\u8fd9\u4e24\u4e2a\u70b9\u7684\u6743\u503c\u76f8\u540c\u3002\n\n\u56e0\u6b64\u6211\u4eec\u5148\u505a\u4e00\u6b21\u6811\u5256\u8f6c\u4e3a\u533a\u95f4\u95ee\u9898\uff0c\u7136\u540e\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef=w=\n\n\u5177\u4f53\u5730\uff0c\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u4e0a\u7684\u6bcf\u4e2a\u8282\u70b9\uff0c\u6211\u4eec\u7ef4\u62a4\u4e00\u4e0b\u8fd9\u4e2a\u8282\u70b9\u7684**\u5de6/\u53f3\u7aef\u7684\u6743\u503c**\u4ee5\u53ca**\u7b54\u6848**\uff0c\u5408\u5e76\u65f6\u53ea\u9700\u8981\u628a\u5de6\u53f3\u513f\u5b50\u7684\u7b54\u6848\u52a0\u8d77\u6765\uff0c\u7136\u540e\u7279\u5224\u4e00\u4e0b\u300c**\u5de6\u513f\u5b50\u7684\u53f3\u7aef\u70b9**\u300d\u4e0e\u300c**\u53f3\u513f\u5b50\u7684\u5de6\u7aef\u70b9**\u300d\u662f\u5426\u76f8\u540c\u5373\u53ef\u3002\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<vector>\n#include<cstdio>\n\n#define lson(o) (o<<1)\n#define rson(o) (o<<1|1)\nconst int MN=1e5+5;\n\nusing namespace std;\n\nint w[MN],val[MN],dfn[MN],sz[MN],fa[MN],top[MN],hson[MN],dep[MN];\nvector<int>G[MN];\n\ninline int read(){\n    int x=0,f=1;char c=getchar();\n    for(;(c<'0'||c>'9');c=getchar()){if(c=='-')f=-1;}\n    for(;(c>='0'&&c<='9');c=getchar())x=x*10+(c&15);\n    return x*f;\n}\n\nint dfs1(int u,int d){\n    dep[u]=d,sz[u]=1,hson[u]=0;\n    for(int i=0,s=G[u].size();i<s;i++){\n        int to=G[u][i];\n        if(to==fa[u])continue;\n        fa[to]=u;\n        sz[u]+=dfs1(to,d+1);\n        if(sz[to]>sz[hson[u]])hson[u]=to;\n    }\n    return sz[u];\n}\n\nint tot=0;\nvoid dfs2(int u,int tp){\n    dfn[u]=++tot,top[u]=tp,val[dfn[u]]=w[u];\n    if(hson[u])dfs2(hson[u],tp);\n    for(int i=0,s=G[u].size();i<s;i++){\n        int to=G[u][i];\n        if(to==fa[u]||to==hson[u])continue;\n        dfs2(to,to);\n    }\n}\n\nstruct SMT{\n    \n    int d[MN<<2],L[MN<<2],R[MN<<2],lz[MN<<2];//d \u4e3a\u6b64\u533a\u95f4\u7b54\u6848\uff0cL/R \u8868\u793a\u5de6\u53f3\u7aef\u70b9\uff0clz\u662f\u61d2\u6807\u8bb0\u3002\n\n    inline void pushup(int o){\n        d[o]=d[lson(o)]+d[rson(o)]+(L[rson(o)]==R[lson(o)]);\n        L[o]=L[lson(o)],R[o]=R[rson(o)];\n    }\n\n    inline void build(int l,int r,int o){\n        lz[o]=0;\n        if(l==r){\n            d[o]=0;\n            L[o]=R[o]=val[l];\n            return ;\n        }\n        int mid=(l+r)>>1;\n        build(l,mid,lson(o));\n        build(mid+1,r,rson(o));\n        pushup(o);\n    }\n\n    inline void pushdown(int ql,int qr,int o){\n        if(!lz[o])return ;\n        int mid=(ql+qr)>>1;\n        d[lson(o)]=mid-ql,d[rson(o)]=qr-mid-1;\n        lz[lson(o)]=lz[o],lz[rson(o)]=lz[o];\n        L[lson(o)]=R[lson(o)]=L[rson(o)]=R[rson(o)]=lz[o];\n        lz[o]=0;\n    }\n\n    inline int query(int l,int r,int ql,int qr,int o){\n        if(l<=ql&&qr<=r)return d[o];\n        pushdown(ql,qr,o);\n        int mid=(ql+qr)>>1,ans=0;\n        if(l<=mid)ans+=query(l,r,ql,mid,lson(o));\n        if(r>mid)ans+=query(l,r,mid+1,qr,rson(o));\n        if(l<=mid&&r>mid&&R[lson(o)]==L[rson(o)])ans++;\n        return ans;\n    }\n\n    inline void modify(int l,int r,int k,int ql,int qr,int o){\n        if(l<=ql&&qr<=r){\n            L[o]=R[o]=lz[o]=k;\n            d[o]=qr-ql;\n            return ;\n        }\n        pushdown(ql,qr,o);\n        int mid=(ql+qr)>>1;\n        if(l<=mid)modify(l,r,k,ql,mid,lson(o));\n        if(r>mid)modify(l,r,k,mid+1,qr,rson(o));\n        pushup(o);\n    }\n\n    inline int kwii(int pos,int ql,int qr,int o){\n        if(ql==qr)return L[o];\n        pushdown(ql,qr,o);\n        int mid=(ql+qr)>>1;\n        if(pos<=mid)return kwii(pos,ql,mid,lson(o));\n        else return kwii(pos,mid+1,qr,rson(o));\n    }\n\n};\n\nSMT tree;\nint n,m;\n\nint cnt=0;\nvoid change(int x,int y){\n    ++cnt;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\ttree.modify(dfn[top[x]],dfn[x],cnt,1,n,1);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\ttree.modify(dfn[x],dfn[y],cnt,1,n,1);\n}\n\nint queryans(int x,int y){\n    int res=0;\n    while(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        res+=tree.query(dfn[top[x]],dfn[x],1,n,1);\n        if(tree.kwii(dfn[fa[top[x]]],1,n,1)==tree.kwii(dfn[top[x]],1,n,1))res++;//\u8fd9\u91cc\u9700\u8981\u7279\u5224\u4e00\u4e0b\u94fe\u9876\u5143\u7d20\u4e0e\u5176\u7236\u4eb2\u662f\u5426\u76f8\u540c\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])swap(x,y);\n    res+=tree.query(dfn[x],dfn[y],1,n,1);\n    return res;\n}\n \nvoid solve(){\n    cnt=tot=0;\n    n=read(),m=read();\n    for(int i=1;i<=n;i++)w[i]=++cnt;//\u7531\u4e8e\u521d\u59cb\u5747\u4e3a\u8f7b\u8fb9\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u4fdd\u8bc1 w[i]!=w[j]\uff0c\u90a3\u4e48\u76f4\u63a5\u8d4b\u503c\u6210 1~n \u5c31\u884c\u4e86qwq\n\n    for(int i=1;i<n;i++){\n        int u=read(),v=read();\n        G[u].push_back(v),G[v].push_back(u);\n    }\n\n    dfs1(1,1);\n    dfs2(1,1);\n\n    tree.build(1,n,1);\n\n    while(m--){\n        int op=read(),x=read(),y=read();\n        if(op==1)change(x,y);\n        if(op==2)cout<<queryans(x,y)<<endl;\n    }\n\n    for(int i=1;i<=n;i++)G[i].clear();\n}\n\nint _;\n\nsigned main(void){\n\n    // freopen(\"edge.in\",\"r\",stdin);\n    // freopen(\"edge.out\",\"w\",stdout);\n    \n    cin>>_;\n    while(_--)solve();\n \n    return 0;\n}\n```\n\n\u90a3\u4e48\u5c31\u8fd9\u6837=w=",
        "postTime": 1627300021,
        "uid": 307453,
        "name": "\u4e91\u6d45\u77e5\u5904",
        "ccfLevel": 6,
        "title": "NOI2021 d1t1"
    },
    {
        "content": "\u8fd1\u4e94\u5e74 NOI \u6700\u96be\u7684 D1T1\u3002\n\n\u6b64\u524d\u9898\u89e3\u7684\u505a\u6cd5\u6709\u4e24\u79cd\uff1aLCT \u4ee5\u53ca\u8f6c\u5316\u4e3a\u989c\u8272\u6bb5\uff0c\u4f46\u8fd9\u4e24\u79cd\u505a\u6cd5\u90fd\u4e0d\u662f\u6211\u9996\u5148\u60f3\u5230\u7684\u3002\n\n\u5c06\u9898\u76ee\u91cc\u7684\u201c\u91cd\u513f\u5b50\u201d\u79f0\u4e3a\u5173\u952e\u513f\u5b50\u3002\n\n\u7531\u4e8e\u8fd9\u9898\u770b\u8d77\u6765\u5c31\u662f\u7b7e\u5230\u9898\uff0c\u76f4\u63a5\u4e0a\u4e2a\u6811\u5256\u66b4\u529b\u7ef4\u62a4\uff0c\u8003\u8651\u4fee\u6539\u65f6\u6bcf\u6761\u91cd\u94fe\u4e0a\u505a\u4e86\u4ec0\u4e48\uff1a\n\n\u94fe\u9876\u5230\u5f53\u524d\u70b9\u4e4b\u95f4\u7684\u90e8\u5206\uff08\u4e0d\u5305\u62ec\u5f53\u524d\u70b9\uff09\u7684\u5173\u952e\u513f\u5b50\u6709\u4e14\u4ec5\u6709\u91cd\u513f\u5b50\u3002\n\n\u5f53\u524d\u70b9\uff1a\u5173\u952e\u513f\u5b50\u4ec5\u6709\u4e0a\u4e00\u6b21\u7684\u94fe\u9876\uff08\u4e00\u4e2a\u8f7b\u513f\u5b50\uff09\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5bf9\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e24\u4e2a\u4fe1\u606f\uff1a\n\n1. \u91cd\u513f\u5b50\u662f\u5426\u662f\u5173\u952e\u513f\u5b50\u3002\n\n2. \u662f\u5426\u5b58\u5728\u8f7b\u513f\u5b50\u662f\u5173\u952e\u513f\u5b50\uff0c\u5982\u679c\u5b58\u5728\u5219\u8bb0\u5f55\u3002\n\n\u4e00\u4e2a\u70b9\u6700\u591a\u6709\u4e24\u4e2a\u5173\u952e\u513f\u5b50\uff0c\u6240\u4ee5 2. \u4e2d\u53ea\u9700\u8981\u8bb0\u5f55\u4e24\u4e2a\u3002\n\n\u7136\u540e\u4fee\u6539\u548c\u67e5\u8be2\u5c31\u662f\u4e00\u4e9b\u7b80\u5355\u7684\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u64cd\u4f5c\uff0c\u76f8\u4fe1\u4e0d\u7528\u591a\u8bf4\u3002\n\n\u6ce8\u610f LCA \u7236\u4eb2\u5904\u7684\u7ec6\u8282\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n\\log^2 n)$\u3002",
        "postTime": 1627349513,
        "uid": 113546,
        "name": "ix35",
        "ccfLevel": 10,
        "title": "NOI 2021 D1T1 \u9898\u89e3"
    },
    {
        "content": "\u641e\u4e00\u4e2a\u975e\u5e38\u89c4\u7684\u505a\u6cd5\uff0c\u7528 LCT \u7684\u7ed3\u6784\u76f4\u63a5\u8868\u793a\u8f7b\u91cd\u8fb9\u3002\n\n- \u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u9898\u76ee\u7ed9\u51fa\u7684\u64cd\u4f5c\u5341\u5206\u50cf LCT \u7684 access \u64cd\u4f5c\uff0c\u6240\u4ee5\u4e0d\u514d\u76f4\u63a5\u5f80\u8fd9\u65b9\u9762\u60f3\u3002\n- \u6211\u4eec\u8981\u5c06\u4e00\u6761\u94fe\u53d8\u4e3a\u5b9e\u94fe\uff0c\u5e38\u89c4\u7684\u5199\u6cd5\u662f\u6362\u6839\u5230\u4e00\u4e2a\u7aef\u70b9\uff0c\u518d access \u53e6\u4e00\u4e2a\u7aef\u70b9\u3002\u8fd9\u6837\u53ef\u4ee5\u53d6\u51fa\u6211\u4eec\u7684\u8fd9\u6761\u94fe\u6765\u3002\n- \u4f46\u662f\u663e\u7136\uff0c\u5728\u6362\u6839\u7684\u65f6\u5019\u6211\u4eec\u8c03\u7528\u4e86 access \u4e00\u6b21\uff0c\u8fd9\u6b21\u8c03\u7528\u4f1a\u76f4\u63a5\u8ba9\u6574\u4e2a LCT \u4e0e\u7ef4\u62a4\u7684\u8f7b\u91cd\u4e4b\u95f4\u6df7\u4e71\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528\u6362\u6839\u64cd\u4f5c\u3002\n- \u8003\u8651\u5b9a\u6839\uff0c\u5982\u679c\u8981\u6253\u901a\u7684\u4e00\u6761\u94fe\u4e24\u4e2a\u7aef\u70b9\u6709\u7236\u5b50\u5173\u7cfb\uff0c\u90a3\u662f\u5341\u5206\u5bb9\u6613\u7684\u3002\n- \u8003\u8651\u666e\u904d\u60c5\u51b5\uff0c\u4e0d\u59a8\u8bbe\u4e24\u4e2a\u7aef\u70b9\u4e3a x \u548c y \u6c42\u51fa\u5176 lca \uff0c\u90a3\u4e48 lca \u7684\u4e24\u6761\u91cd\u8fb9\u90fd\u662f\u8fde\u5411\u513f\u5b50\u7684\u3002\u8fd9\u4e5f\u5c31\u662f\u8bf4 lca \u4e00\u5b9a\u6ca1\u6709\u8fde\u5411\u7236\u4eb2\u7684\u91cd\u8fb9\uff0c\u5373 lca \u4e00\u5b9a\u662f\u4e00\u6761\u5b9e\u94fe\u7684\u94fe\u9876\u3002\n- \u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u4e2a\u201c\u989d\u5916\u94fe\u201d extra \u8868\u793a\u5b83\u9664\u4e86\u81ea\u5df1\u7684\u5b9e\u513f\u5b50\u662f\u5426\u6709\u53e6\u5916\u7684\u5411\u4e0b\u7684\u91cd\u8fb9\u3002\u8fd9\u4e2a extra\uff0c\u5bb9\u6613\u53d1\u73b0\u53ea\u6709\u6bcf\u6761\u5b9e\u94fe\u7684\u94fe\u9876\u7684 extra \u4f1a\u6709\u503c\u3002\u5728 access \u7684\u65f6\u5019\u76f4\u63a5\u6e05\u7a7a\u5c31\u884c\u4e86\u3002\n- \u90a3\u4e48\u5269\u4f59\u90e8\u5206\u7684\u7b97\u6cd5\u4e5f\u5927\u6982\u51fa\u6765\u4e86\u3002\u6211\u4eec\u6bcf\u6b21\u6253\u901a\u4e00\u6761\u5b9e\u94fe\uff0c\u5c31\u662f\u5bf9\u4e8e\u4e24\u4e2a\u8282\u70b9 lca \u9996\u5148\u4ece\u5b9e\u94fe\u5206\u79bb\uff0c\u7136\u540e\u5c06\u4e24\u4e2a\u513f\u5b50\u5206\u522b\u5411\u4e0a\u63d2\u5b9e\u94fe\u76f4\u5230\u6700\u8fd1\u516c\u5171\u7956\u5148\uff0c\u8bb0\u4e00\u8fb9\u4e3a\u5b9e\u513f\u5b50\uff0c\u53e6\u4e00\u8fb9\u8bb0\u4e3a\u989d\u5916\u94fe\uff0c\u5c06\u6bcf\u4e2a\u8282\u70b9\u5230\u6839\u7684\u91cd\u8fb9\u6570\u91cf\u6309\u7167 LCT \u7684\u7ed3\u6784\u6539\u53d8\u76f4\u63a5\u7ef4\u62a4\u51fa\u6765\u3002\u67e5\u8be2\u5c31\u662f\u548c LCA \u505a\u5dee\u5206\u5373\u53ef\u3002\u53ef\u4ee5\u53d1\u73b0\u5b83\u6ca1\u6709\u7834\u574f\u5747\u644a\u5206\u6790\u3002\n- \u7136\u540e\u5c31\u662f\u4e00\u4e9b\u7ec6\u8282\u7684\u7279\u5224\u548c\u5b9e\u73b0\u7ec6\u8282\uff0c\u53ef\u4ee5\u76f4\u63a5\u770b\u4ee3\u7801\u3002\n\n\n```\n//ayame\u4fdd\u4f51\uff0c\u5938\u54e5\u4fdd\u4f51\uff0c\u72d7\u5988\u4fdd\u4f51\uff0cMDR\u4fdd\u4f51\uff0c\u9509\u5200\u602a\u4fdd\u4f51\uff0cM99\u4fdd\u4f51\uff0c\u514b\u7239\u4fdd\u4f51\n#include<bits/stdc++.h>\nusing namespace std;\nint p1=1000000,p2=0;\nchar buf[1000005],wb[1000005];\nint gc() {\n\tif(p1>=1000000)fread(buf,1,1000000,stdin),p1=0;\n\treturn buf[p1++];\n}\n#define gc getchar\n#define Loli true\n#define Kon xor true\nlong long getint() {\n\tlong long ret=0,flag=1;\n\tchar c=gc();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-')flag=-1;\n\t\tc=gc();\n\t}\n\twhile(c<='9'&&c>='0') {\n\t\tret=(ret<<3)+(ret<<1)+c-'0';\n\t\tc=gc();\n\t}\n\treturn ret*flag;\n}\nvoid pc(char x) {\n\tif(p2>=1000000)fwrite(wb,1,1000000,stdout),p2=0;\n\twb[p2++]=x;\n}\nvoid wrt(long long x) {\n\tif(x<0)pc('-'),x=-x;\n\tint c[24]= {0};\n\tif(!x)return pc('0'),void();\n\twhile(x)c[++c[0]]=x%10,x/=10;\n\twhile(c[0])pc(c[c[0]--]+'0');\n}\nint n,m;\nvector<int> vec[100005];\nint fa[100005],dep[100005];\nint son[100005],sz[100005];\nint tp[100005],rd[100005],cd[100005],sign;\nint LCA(int x,int y){\n\twhile(tp[x]^tp[y]){\n\t\tif(dep[tp[x]]<dep[tp[y]])swap(x,y);\n\t\tx=fa[tp[x]];\n\t}\n\tif(dep[x]>dep[y])swap(x,y);\n\treturn x;\n}\nnamespace T{\n\t#define lowbit(i) (i&(-i))\n\tint c[100005];\n\tvoid clear(){\n\t\tmemset(c,0,sizeof(c));\n\t}\n\tvoid add(int pl,int val){\n\t\tfor(int i=pl;i<=100000;i+=lowbit(i))c[i]+=val;\n\t}\n\tvoid add(int l,int r,int val){\n\t\tadd(l,val),add(r+1,-val);\n\t}\n\tint ask(int pl){\n\t\tint ret=0;\n\t\tfor(int i=pl;i;i-=lowbit(i))ret+=c[i];\n\t\treturn ret;\n\t}\n};\nnamespace LCT{\n\tstruct node{\n\t\tint ch[2],fa,pre,suf,extra;\n\t}v[100005];\n\tbool isroot(int x){\n\t\treturn v[v[x].fa].ch[0]!=x&&v[v[x].fa].ch[1]!=x;\n\t}\n\tvoid push_up(int rt){\n\t\tv[rt].pre=v[rt].ch[0]?v[v[rt].ch[0]].pre:rt;\n\t\tv[rt].suf=v[rt].ch[1]?v[v[rt].ch[1]].suf:rt;\n\t}\n\tvoid init(){\n\t\tT::clear();\n\t\tfor(int i=1;i<=100000;i++)v[i].ch[0]=v[i].ch[1]=v[i].fa=v[i].pre=v[i].suf=v[i].extra=0,push_up(i);\n\t}\n\tvoid rot(int x){\n\t\tint p=v[x].fa,g=v[p].fa;\n\t\tbool d=v[p].ch[1]==x;\n\t\tif(!isroot(p))v[g].ch[v[g].ch[1]==p]=x;\n\t\tv[p].ch[d]=v[x].ch[d^1];\n\t\tv[v[x].ch[d^1]].fa=p;\n\t\tv[x].ch[d^1]=p;\n\t\tv[x].fa=g,v[p].fa=x;\n\t\tpush_up(p),push_up(x);\n\t}\n\tvoid splay(int x){\n\t\twhile(!isroot(x)){\n\t\t\tint p=v[x].fa,g=v[p].fa;\n\t\t\tif(!isroot(p))rot(v[g].ch[0]==p^v[p].ch[0]==x?x:p);\n\t\t\trot(x);\n\t\t}\n\t}\n\tvoid ins(int x,int y){\n\t\tif(!y)return;\n\t\tT::add(rd[v[y].pre],cd[v[y].pre],-1);\n\t}\n\tvoid del(int x,int y){\n\t\tif(!y)return;\n\t\tT::add(rd[v[y].pre],cd[v[y].pre],1);\n\t\tif(v[v[y].pre].extra)T::add(rd[v[v[y].pre].extra],cd[v[v[y].pre].extra],-1),v[v[y].pre].extra=0;\n\t}\n\tvoid split(int x){\n\t\tsplay(x);\n\t\tif(v[fa[x]].extra==x)T::add(rd[x],cd[x],-1),v[fa[x]].extra=0;\n\t\tif(v[x].extra)T::add(rd[v[x].extra],cd[v[x].extra],-1),v[x].extra=0;\n\t\tif(!v[x].ch[0])return;\n\t\tint y=v[v[x].ch[0]].suf;\n\t\tsplay(y),v[y].ch[1]=0,push_up(y);\n\t\tT::add(rd[x],cd[x],-1);\n\t}\n\tvoid limit_access(int x,int Dep){\n\t\tfor(int y=0;x;y=x,x=v[x].fa){\n\t\t\tsplay(x),del(x,y),ins(x,v[x].ch[1]),v[x].ch[1]=y,push_up(x);\n\t\t\tif(dep[v[x].pre]==Dep)return;\n\t\t}\n\t}\n\tvoid expose(int x,int y){\n\t\tif(dep[x]<dep[y])swap(x,y);\n\t\tint lca=LCA(x,y);\n\t\tsplit(lca),limit_access(x,dep[lca]);\n\t\tif(y!=lca){\n\t\t\tsplay(lca);int son=v[v[lca].ch[1]].pre;\n\t\t\tlimit_access(y,dep[lca]),v[lca].extra=son,T::add(rd[son],cd[son],1);\n\t\t}\n\t}\n\tint ask(int x,int y){\n\t\tint lca=LCA(x,y);\n\t\treturn T::ask(rd[x])+T::ask(rd[y])-2*T::ask(rd[lca]);\n\t}\n}\nvoid dfs1(int x,int prt){\n\tfa[x]=prt,dep[x]=dep[prt]+1,sz[x]=1;\n\tfor(int y:vec[x])if(y!=prt)dfs1(y,x),sz[x]+=sz[y],son[x]=(sz[y]>sz[son[x]]?y:son[x]);\n\tLCT::v[x].fa=prt;\n}\nvoid dfs2(int x,int prt,int top){\n\ttp[x]=top,rd[x]=++sign;\n\tif(son[x])dfs2(son[x],x,top);\n\tfor(int y:vec[x])if(y!=prt&&y!=son[x])dfs2(y,x,y);\n\tcd[x]=sign;\n}\nint main() {\n//\tsystem(\"fc edge.out edge5.ans\");\n\tfreopen(\"edge.in\",\"r\",stdin);\n\tfreopen(\"edge.out\",\"w\",stdout);\n\tint Ti=getint();\n\twhile(Ti--){\n\t\tfor(int i=1;i<=n;i++)vec[i].clear();\n\t\tsign=0;\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(sz,0,sizeof(sz)),memset(son,0,sizeof(son));\n\t\tLCT::init();\n\t\tn=getint(),m=getint();\n\t\tfor(int i=1;i<n;i++){\n\t\t\tint u=getint(),v=getint();\n\t\t\tvec[u].push_back(v),vec[v].push_back(u);\n\t\t}\n\t\tdfs1(1,0),dfs2(1,0,1);\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint opt=getint(),x=getint(),y=getint();\n\t\t\tif(opt==1)LCT::expose(x,y);\n\t\t\tif(opt==2)wrt(LCT::ask(x,y)),pc('\\n');\n\t\t}\n\t}\n\tfwrite(wb,1,p2,stdout);\n\treturn Loli Kon;\n}\n\n```\n\n\n- \u867d\u7136\u505a\u6cd5\u8fe5\u5f02\uff0c\u4f46\u5bf9\u4e8e\u6bcf\u4e2a\u4eba\u6765\u8bf4\u8003\u573a\u4e0a\u8fd8\u662f\u64c5\u957f\u5565\u5199\u5565\uff0c\u4e0d\u8981\u5c1d\u8bd5\u5251\u8d70\u504f\u950b\u3002\uff08",
        "postTime": 1627298715,
        "uid": 27338,
        "name": "jerry3128",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P7735 \u3010[NOI2021] \u8f7b\u91cd\u8fb9\u3011"
    },
    {
        "content": "\u4e5f\u8bb8\u662f\u8fd1\u51e0\u5e74\u6700\u7b80\u5355\u7684 NOI \u9898\u3002\n\n\u6211\u4eec\u8003\u8651\u8f6c\u6362\u4e00\u4e0b\u9898\u9762\uff0c\u628a $1$ \u64cd\u4f5c\u770b\u6210\u94fe\u4e0a\u67d3\u8272\uff0c\u90a3\u4e48\u4e0d\u96be\u53d1\u73b0\u4e00\u6761\u8fb9\u53d8\u91cd\u4ee5\u540e\u4e24\u4e2a\u7aef\u70b9\u7684\u70b9\u6743\u662f\u76f8\u540c\u7684\u3002\u540c\u65f6\u8fd9\u4e5f\u662f\u5145\u8981\u6761\u4ef6\u3002\n\n\u90a3\u4e48\u9898\u610f\u8f6c\u5316\u4e3a\uff1a\u4e00\u68f5\u6811\uff0c\u652f\u6301\u94fe\u67d3\u8272\uff0c\u67e5\u8be2\u94fe\u4e0a\u76f8\u90bb\u70b9\u989c\u8272\u76f8\u540c\u7684\u4e2a\u6570\u3002\n\n\u4e0d\u96be\u53d1\u73b0\u8981\u67e5\u8be2\u7684\u5185\u5bb9\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u53ea\u8981\u8bb0\u5f55\u533a\u95f4\u7b54\u6848\u548c\u5de6\u53f3\u7aef\u70b9\u7684\u989c\u8272\u5373\u53ef\u5408\u5e76\u3002\n\n\u4fee\u6539\u662f\u533a\u95f4\u7684\uff0c\u6211\u4eec\u8003\u8651\u600e\u6837\u4e0b\u4f20\u6807\u8bb0\u3002\u663e\u7136\u533a\u95f4\u63a8\u5e73\u540e\u533a\u95f4\u7b54\u6848\u662f $len-1$\uff08$len$ \u662f\u533a\u95f4\u957f\u5ea6\uff09\uff0c\u5de6\u53f3\u7aef\u70b9\u4fee\u6539\u6210\u5f53\u524d\u989c\u8272\u5373\u53ef\u3002\n\n\u6709\u4e86\u8fd9\u4e9b\u5c31\u662f\u4e00\u4e2a\u6811\u5256\u677f\u5b50\u9898\u4e86\u3002\n\n\u590d\u6742\u5ea6 $O(n\\log^2n)$\u3002\n\n~~\u522b\u5fd8\u4e86\u5361\u5e38\u3002~~\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nstruct edge\n{\n    int nxt,to;\n}e[100001<<1];\nstruct tree\n{\n    int ans,l,r,tag,len;\n    tree()\n    {\n        ans=l=r=tag=len=0;\n    }\n}t[100001<<2];\nint T,n,m,tot,h[100001],dep[100001],fa[100001],s[100001],son[100001],id[100001],cnt,top[100001];\ninline int read()\n{\n    register int x=0;\n    register char c=getchar();\n    while(c<'0'||c>'9')\n        c=getchar();\n    while(c>='0'&&c<='9')\n    {\n        x=(x<<1)+(x<<3)+(c^48);\n        c=getchar();\n    }\n    return x;\n}\nvoid print(register int x)\n{\n    if(x>=10)\n        print(x/10);\n    putchar(x%10+'0');\n}\ninline void add(register int x,register int y)\n{\n    e[++tot].nxt=h[x];\n    h[x]=tot;\n    e[tot].to=y;\n}\ninline int ls(register int k)\n{\n    return k<<1;\n}\ninline int rs(register int k)\n{\n    return k<<1|1;\n}\ninline tree merge(register tree x,register tree y)\n{\n    tree res;\n    res.ans=x.ans+y.ans;\n    res.len=x.len+y.len;\n    if(x.r==y.l)\n        ++res.ans;\n    res.l=x.l;\n    res.r=y.r;\n    return res;\n}\ninline void push_up(register int k)\n{\n    t[k]=merge(t[ls(k)],t[rs(k)]);\n}\ninline void push_down(register int k)\n{\n    if(t[k].tag)\n    {\n        t[ls(k)].ans=t[ls(k)].len-1;\n        t[rs(k)].ans=t[rs(k)].len-1;\n        t[ls(k)].l=t[ls(k)].r=t[rs(k)].l=t[rs(k)].r=t[ls(k)].tag=t[rs(k)].tag=t[k].tag;\n        t[k].tag=0;\n    }\n}\nvoid build(register int k,register int l,register int r)\n{\n    t[k].len=r-l+1;\n    t[k].tag=t[k].ans=0;\n    if(l==r)\n    {\n        t[k].l=t[k].r=l;\n        return;\n    }\n    int mid=(l+r)>>1;\n    build(ls(k),l,mid);\n    build(rs(k),mid+1,r);\n    push_up(k);\n}\nvoid update(register int nl,register int nr,register int l,register int r,register int k,register int p)\n{\n    if(l>=nl&&r<=nr)\n    {\n        t[k].ans=t[k].len-1;\n        t[k].l=t[k].r=t[k].tag=p;\n        return;\n    }\n    push_down(k);\n    register int mid=(l+r)>>1;\n    if(nl<=mid)\n        update(nl,nr,l,mid,ls(k),p);\n    if(nr>mid)\n        update(nl,nr,mid+1,r,rs(k),p);\n    push_up(k);\n}\ntree query(register int nl,register int nr,register int l,register int r,register int k)\n{\n    if(l>=nl&&r<=nr)\n        return t[k];\n    push_down(k);\n    register int mid=(l+r)>>1;\n    if(nr<=mid)\n        return query(nl,nr,l,mid,ls(k));\n    if(nl>mid)\n        return query(nl,nr,mid+1,r,rs(k));\n    return merge(query(nl,nr,l,mid,ls(k)),query(nl,nr,mid+1,r,rs(k)));\n}\nvoid dfs1(register int k,register int f,register int deep)\n{\n    dep[k]=deep;\n    fa[k]=f;\n    s[k]=1;\n    son[k]=0;\n    int maxson=-1;\n    for(register int i=h[k];i;i=e[i].nxt)\n    {\n        if(e[i].to==f)\n            continue;\n        dfs1(e[i].to,k,deep+1);\n        s[k]+=s[e[i].to];\n        if(s[e[i].to]>maxson)\n        {\n            maxson=s[e[i].to];\n            son[k]=e[i].to;\n        }\n    }\n}\nvoid dfs2(register int k,register int t)\n{\n    id[k]=++cnt;\n    top[k]=t;\n    if(!son[k])\n        return;\n    dfs2(son[k],t);\n    for(register int i=h[k];i;i=e[i].nxt)\n    {\n        if(e[i].to==fa[k]||e[i].to==son[k])\n            continue;\n        dfs2(e[i].to,e[i].to);\n    }\n}\ninline void up(register int x,register int y,register int p)\n{\n    while(top[x]^top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])\n            x^=y^=x^=y;\n        update(id[top[x]],id[x],1,n,1,p);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])\n        x^=y^=x^=y;\n    update(id[x],id[y],1,n,1,p);\n}\ninline int LCA(register int x,register int y)\n{\n    while(top[x]^top[y])\n    {\n        if(dep[top[x]]<dep[top[y]])\n            x^=y^=x^=y;\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])\n        x^=y^=x^=y;\n    return x;\n}\ninline int q(register int x,register int y)\n{\n    register tree res1,res2;\n    register int lca=LCA(x,y);\n    while(top[x]^top[lca])\n    {\n        res1=merge(query(id[top[x]],id[x],1,n,1),res1);\n        x=fa[top[x]];\n    }\n    res1=merge(query(id[lca],id[x],1,n,1),res1);\n    while(top[y]^top[lca])\n    {\n        res2=merge(query(id[top[y]],id[y],1,n,1),res2);\n        y=fa[top[y]];\n    }\n    res2=merge(query(id[lca],id[y],1,n,1),res2);\n    return res1.ans+res2.ans;\n}\nint main()\n{\n    freopen(\"edge.in\",\"r\",stdin);\n    freopen(\"edge.out\",\"w\",stdout);\n    T=read();\n    while(T--)\n    {\n        n=read(),m=read();\n        memset(e,0,sizeof e);\n        memset(h,0,sizeof h);\n        cnt=tot=0;\n        for(register int i=1;i<n;++i)\n        {\n            register int x=read(),y=read();\n            add(x,y);\n            add(y,x);\n        }\n        dfs1(1,0,1);\n        dfs2(1,1);\n        build(1,1,n);\n        for(register int i=1;i<=m;++i)\n        {\n            register int opt=read(),x=read(),y=read();\n            if(opt==1)\n                up(x,y,i+n);\n            if(opt==2)\n            {\n                print(q(x,y));\n                putchar('\\n');\n            }\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1627293398,
        "uid": 85682,
        "name": "\u7edd\u9876\u6211\u4e3a\u5cf0",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P7735 \u3010[NOI2021] \u8f7b\u91cd\u8fb9\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u5c31\u5dee\u6ca1\u628a \u201cLCT\u201d \u5199\u5230\u9898\u9762\u4e2d\u53bb\u4e86\u3002\n\n\u5f88\u5bb9\u6613\u60f3\u5230\uff0c\u5bf9\u4e8e\u64cd\u4f5c 1 \u4f7f\u7528 LCT \u7ef4\u62a4\u3002  \n\u7531\u52bf\u80fd\u5206\u6790\u5f97\u51fa\uff0cLCT\uff08\u5b9e\u94fe\u5256\u5206\uff09\u662f\u5300\u644a $\\Theta(\\log n)$ \u7684\uff0c\u56e0\u6b64\u590d\u6742\u5ea6\u6b63\u786e\u3002\n\n\u4f46\u6709\u5982\u4e0b\u4e24\u4e2a\u95ee\u9898\uff1a\n- 2 \u64cd\u4f5c\u6ca1\u6709\u5207\u6362\u8fb9\u7684\u865a\u5b9e\uff0c\u66b4\u529b\u8df3\u94fe\u7684\u8bdd\u590d\u6742\u5ea6\u4f1a\u8d85\u3002  \n  \u56e0\u6b64\u5728 LCT \u57fa\u7840\u4e0a\u518d\u505a\u4e00\u6b21\u91cd\u94fe\u5256\u5206\u7528\u4ee5\u56de\u7b54\u8be2\u95ee\u3002\n- \u4e00\u822c\u7684 LCT \u6253\u901a\u5b9e\u94fe\u4f9d\u8d56\u6362\u6839\u64cd\u4f5c\uff1a\u5148\u6253\u901a\u5230\u6839\u7684\u5b9e\u94fe\uff0c\u7136\u540e\u6574\u6761\u94fe\u4f5c\u533a\u95f4\u7ffb\u8f6c\u3002  \n  \u5176\u4e2d\u201c\u6253\u901a\u5230\u6839\u7684\u5b9e\u94fe\u201d\u662f 1 \u64cd\u4f5c\u6240\u4e0d\u5141\u8bb8\u7684\uff0c\u6211\u4eec\u9700\u8981\u53e6\u8f9f\u8e4a\u5f84\u3002  \n  \u5177\u4f53\u5730\uff0c\u901a\u8fc7\u91cd\u94fe\u5256\u5206\u6c42\u51fa LCA\uff0c\u7136\u540e\u518d\u6253\u901a\u8def\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u5230 LCA \u7684\u5b9e\u94fe\u5373\u53ef\u3002  \n  Q\uff1a\u90a3\u8fd9\u6837\u7684\u8bdd\u5c31\u6709\u4e24\u6761\u5b9e\u94fe\u8fc7 LCA \u54af\uff1f  \n  A\uff1a\u65e2\u7136\u6709\u4e24\u6761\u5b9e\u94fe\uff0c\u5bf9\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e24\u4e2a splay \u7ed3\u70b9\u5373\u53ef\u3002\n\n\u7ec6\u8282\u5f88\u591a\uff0c\u5177\u4f53\u770b\u4ee3\u7801\u3002\n\n```cpp\n/*\nthis code is made by wangrx\n2021-7-27 8:34\n*/\n#include<stdio.h>\n#include<string.h>\ntypedef unsigned int word;\nstruct READ{//\u5feb\u8bfb\u5feb\u5199\n    char c;\n    inline READ(){c=getchar();}\n    template<typename type>\n    inline READ& operator >>(register type& num){\n        for(;'0'>c||c>'9';c=getchar());\n        for(num=0;'0'<=c&&c<='9';c=getchar())\n            num=num*10+(c-'0');\n        return *this;\n    }\n}cin;\nword case_,n,m;\nword head[100010],to[200010],next[200010];\nword fa[100010],son[100010];\nword floor[100010],size[100010];\nword newid[100010],step;\ninline void dfs1(word id){//\u91cd\u94fe\u5256\u5206\uff08\u627e\u91cd\u513f\u5b50\uff09\n    size[id]=1,son[id]=0;\n    for(register word i=head[id];i;i=next[i])\n        if(to[i]!=fa[id]){\n            floor[to[i]]=floor[id]+1;\n            fa[to[i]]=id,dfs1(to[i]);\n            size[id]+=size[to[i]];\n            if(size[son[id]]<size[to[i]]) son[id]=to[i];\n        }\n}\ninline void dfs2(word id){//\u91cd\u94fe\u5256\u5206\uff08\u91cd\u6807\u53f7\uff09\n    newid[id]=++step;\n    if(son[id]) size[son[id]]=size[id],dfs2(son[id]);\n    for(register word i=head[id];i;i=next[i])\n        if(to[i]!=fa[id]&&to[i]!=son[id])\n            size[to[i]]=to[i],dfs2(to[i]);\n}\nstruct BIT{//\u6811\u72b6\u6811\u7ec4\n    int sum[100010];\n    inline void operator()(){\n        memset(sum,0,sizeof(sum));}\n    #define lowbit(x) ((x)&-(x))\n    inline void operator()(\n        register int id,register int num){\n        for(;id<=n;id+=lowbit(id)) sum[id]+=num;}\n    inline int operator()(register int id){\n        register int ans=0;\n        for(;id;id&=~lowbit(id)) ans+=sum[id];\n        return ans;\n    }\n}tree;\nstruct splay{\n    splay *l,*r,*fa;\n}p[200010];\n#define cyc(root,l,r) do{       \\\n    register splay *rt=root;    \\\n    register splay *l=rt->l;    \\\n    register splay *l##r=l->r;  \\\n    l->fa=rt->fa,(root)=l;      \\\n    l->r=rt,rt->fa=l;           \\\n    if(rt->l=l##r) l##r->fa=rt; \\\n}while(0)//splay \u65cb\u8f6c\n#define lcyc(root) cyc(root,l,r)\n#define rcyc(root) cyc(root,r,l)\n#define lsp(root)                           \\\n    if(rff->l==root->fa){                   \\\n        if(root->fa->l==root) lcyc(rff);    \\\n        else rcyc(rff->l);                  \\\n        lcyc(rff);                          \\\n    }else{                                  \\\n        if(root->fa->r==root) rcyc(rff);    \\\n        else lcyc(rff->r);                  \\\n        rcyc(rff);                          \\\n    }\n#define pos(p) ((p)->fa->l==(p)? (p)->fa->l:(p)->fa->r)\ninline void Splay(register splay *root){//splay \u4f38\u5c55\u64cd\u4f5c\n    while(root->fa)\n        if(root->fa->fa)\n            if(root->fa->fa->fa){\n                register splay *&rff=pos(root->fa->fa);\n                lsp(root);\n            }else{\n                register splay *rff=root->fa->fa;\n                lsp(root);\n            }\n        else if(root->fa->l==root){\n            root=root->fa;lcyc(root);}\n        else{root=root->fa;rcyc(root);}\n}\ninline void eraser(word id){//\u62b9\u53bb\u6307\u5b9a splay \u7684\u5b9e\u513f\u5b50\n    if(Splay(p+id),p[id].r){\n        register splay *top=p[id].r;\n        for(;top->l;top=top->l);\n        tree(newid[(top-p)>>1],-1);//\u7b54\u6848 -1\uff0c\u8ba1\u5165\u6811\u72b6\u6811\u7ec4\n        p[id].r->fa=0,p[id].r=0;\n    }\n}\ninline void erase(word id){//\u62b9\u53bb\u6307\u5b9a\u7ed3\u70b9\u7684\u6240\u6709\u5b9e\u8fb9\n    word u=id<<1,v=id<<1|1;\n    eraser(u),eraser(v);\n    if(p[u].l) tree(newid[id],-1),p[u].l->fa=0,p[u].l=0;\n    if(p[v].l) tree(newid[id],-1),p[v].l->fa=0,p[v].l=0;\n\t//\u7b54\u6848 -1,\u8ba1\u5165\u6811\u72b6\u6811\u7ec4\n}\ninline void makeline(word id,word lca){\n\t//\u6253\u901a id \u5230 lca \u7684\u5b9e\u94fe\uff08id!=lca\uff09\uff08\u6838\u5fc3\uff09\n    eraser(id<<1),eraser(id<<1|1);//\u5207\u6389\u6240\u6709\u7684\u5b9e\u513f\u5b50\n    register splay *root=p+(p[id<<1].l? id<<1:id<<1|1),*top;\n\t//\u8981\u6ce8\u610f\u9009\u62e9\u5411\u4e0a\u6709\u5b9e\u94fe\u7684\u90a3\u6761 splay\n    for(top=root;top->l;top=top->l);\n    while(eraser((id=top-p)^1),//\u8df3\u865a\u8fb9\u524d\u8981\u5207\u6389\u5176\u4ed6\u7684\u5b9e\u513f\u5b50\n        tree(newid[id>>=1],1),(id=fa[id])!=lca){//\u7b54\u6848 +1\uff0c\u8ba1\u5165\u6811\u72b6\u6811\u7ec4\n        eraser(id<<1),eraser(id<<1|1);//\u5207\u6389\u6240\u6709\u7684\u5b9e\u513f\u5b50\n        register splay *next=p+(p[id<<1].l? id<<1:id<<1|1);\n\t\t//\u8981\u6ce8\u610f\u9009\u62e9\u5411\u4e0a\u6709\u5b9e\u94fe\u7684\u90a3\u6761 splay\n        next->r=root,root->fa=next;\n        for(top=root=next;top->l;top=top->l);\n    }\n    root->fa=p+(p[id<<1].r? id<<1|1:id<<1);\n\t//\u5bf9\u4e8e lca \u7684\u4e24\u4e2a splay\uff0c\u9009\u62e9\u6ca1\u6709\u5b9e\u513f\u5b50\u7684\u90a3\u4e2a\n    root->fa->r=root;\n}\nint main(){\n    for(cin>>case_;case_;--case_){\n        cin>>n>>m;\n        memset(head,0,sizeof(head));\n        for(register word i=1;i<n;++i){\n            cin>>to[i<<1]>>to[i<<1|1];\n            next[i<<1]=head[to[i<<1|1]];\n            next[i<<1|1]=head[to[i<<1]];\n            head[to[i<<1]]=i<<1|1;\n            head[to[i<<1|1]]=i<<1;\n        }\n        dfs1(1),size[1]=1,step=0,dfs2(1);\n        tree(),memset(p,0,sizeof(p));\n        for(word opt,u,v;m;--m){\n            cin>>opt>>u>>v;\n            if(--opt){//\u91cd\u94fe\u5256\u5206\u8ba1\u7b97\u7b54\u6848\n                register word ans=0;\n                while(size[u]!=size[v])\n                    if(floor[size[u]]>floor[size[v]]){\n                        ans+=tree(newid[u])-tree(newid[size[u]]-1);\n                        u=fa[size[u]];\n                    }else{\n                        ans+=tree(newid[v])-tree(newid[size[v]]-1);\n                        v=fa[size[v]];\n                    }\n                if(floor[u]>floor[v]) ans+=tree(newid[u])-tree(newid[v]);\n                else ans+=tree(newid[v])-tree(newid[u]);\n                printf(\"%u\\n\",ans);\n            }else if(u==v) erase(u);\n            else{\n                word x=u,y=v;\n                while(size[u]!=size[v])\n                    if(floor[size[u]]>floor[size[v]]) u=fa[size[u]];\n                    else v=fa[size[v]];\n                word lca=floor[u]<floor[v]? u:v;\n\t\t\t\t//\u91cd\u94fe\u5256\u5206\u6c42 lca\n                erase(lca);\n                if(x!=lca) makeline(x,lca);\n                if(y!=lca) makeline(y,lca);\n\t\t\t\t//\u6253\u901a\u4e24\u7aef\u70b9\u5230 lca \u7684\u5b9e\u94fe\n            }\n        }\n    }\n    return 0;\n}\n```\n\u9664\u4e86 LCT \u4ee5\u5916\uff0c\u672c\u9898\u8fd8\u6709\u4e00\u79cd \u91cd\u94fe\u5256\u5206 + \u7ebf\u6bb5\u6811\u533a\u95f4\u8d4b\u503c \u7ef4\u62a4 \u5b9e\u94fe\u5256\u5206 \u7684\u89e3\u6cd5\uff0c\u4e0d\u8fc7\u5c31\u4e0d\u8bb2\u4e86\u3002",
        "postTime": 1627346143,
        "uid": 104726,
        "name": "wangrx",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "\u8003\u573a\u6012\u521a 4h+ \u624d\u641e\u51fa\u6765\uff0c\u601d\u8def\u7b80\u5355\u5c31\u6ca1\u591a\u60f3\uff0c~~\u5c31\u662f\u6211\u81ea\u5df1\u6bd2\u7624\u81ea\u5df1~~\u3002\n\n\u9996\u5148\u6211\u4eec\u628a 1 \u5b9a\u4e3a\u6839\uff0c\u628a\u6bcf\u6761\u8fb9\u770b\u4f5c\u513f\u5b50\u5230\u7236\u4eb2\u7684\u8fb9\uff0c\u7136\u540e\u653e\u5728\u513f\u5b50\u4e0a\u3002\n\n\u64cd\u4f5c 1 \u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u662f\u513f\u5b50\u6743\u503c\u6e05\u7a7a\uff0c\u4e00\u90e8\u5206\u662f\u94fe\u8d4b\u503c\u3002\n\n\u94fe\u8d4b\u503c\u4e0d\u591a\u8bf4\uff0c\u513f\u5b50\u6e05\u96f6\u6bd4\u8f83\u96be\u505a\uff0c~~\u4f46 jerry3128 \u968f\u624b\u5c31\u80fd\u53e3\u80e1\u51fa\u6bdb\u6bdb\u866b\u4fee\u6539\u505a\u6cd5~~\u3002\n\n\u6211\u7684\u505a\u6cd5\u5c31\u5341\u5206 naive\uff0c\u628a\u6811\u76f4\u63a5\u4e22\u5230 LCT \u91cc\u9762\uff0c\u94fe\u8d4b\u503c\u5c31\u662f Splay \u5b50\u6811\u8d4b\u503c\uff0c\u513f\u5b50\u6e05\u7a7a\u7684\u8bdd\u6253\u4e2a\u6807\u8bb0\u5c31\u884c\u3002\n\n\u53ea\u9700\u8003\u8651\u865a\u513f\u5b50\u88ab\u6e05\u6389\u7684\u60c5\u51b5\uff0c\u5982\u679c\u662f\u5b9e\u513f\u5b50\u4e00\u5b9a\u662f\u4e00\u6761\u94fe\u4e0a\u88ab\u8d4b\u503c\u4e86\u800c\u4e14\u6ca1\u88ab\u6539\u8fc7\u3002\n\n\u4e8e\u662f\u5728 Access \u7684\u65f6\u5019\u5224\u4e00\u4e0b\u548c\u4e0a\u6b21\u7684\u6807\u8bb0\u662f\u5426\u76f8\u540c\uff0c\u518d\u628a\u8fd9\u6b21\u7684\u6807\u8bb0\u6253\u4e0b\u53bb\u5373\u53ef\u3002\n\n\u4e3a\u4e86\u5b9e\u9645\u610f\u4e49\uff0c\u540c\u65f6\u4e5f\u4e3a\u4e86\u597d\u5199\uff0c\u6211\u52a8\u7528\u4e86\u4e0d\u6362\u6839\u7684 LCT\uff0c~~\u7136\u800c\u66f4 TM \u96be\u5199\u4e86~~\u3002\n\n\u53ea\u6709\u5e73\u51e1\u7684 LCT\uff0c\u6211\u7684\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2{n})$\uff0c\u4f46\u662f\u52a0\u4e2a\u6807\u8bb0\u5c31\u53ef\u4ee5\u8f7b\u6613\u505a\u5230 $O(n\\log{n})$\u3002\n\n\u53ea\u653e LCT \u4e86\uff0c\u4e3b\u51fd\u6570\u5565\u90fd\u6ca1\u6709\uff0c\u8003\u573a\u4ee3\u7801\uff0c\u614e\u770b\uff1a\n\n```\nnamespace LCT\n{\n\tint tot,sn[2][Mx+5],pr[Mx+5],sm[Mx+5],sz[Mx+5],vl[Mx+5],tg[Mx+5],cg[Mx+5],ft[Mx+5];\n\tint lc[Mx+5];\n\t#define ls(x) sn[0][x]\n\t#define rs(x) sn[1][x]\n\tinline void Clr(int x)\n\t{\n\t\tint i;\n\t\tfor(i=0;i<=x;i++)\n\t\t{\n\t\t\tls(i)=rs(i)=pr[i]=sm[i]=sz[i]=vl[i]=tg[i]=cg[i]=ft[i]=0;\n\t\t\tlc[i]=0;\n\t\t}\n\t\ttot=0;\n\t}\n\tinline void Up(int x)\n\t{\n\t\tsm[x]=sm[ls(x)]+sm[rs(x)]+vl[x];\n\t\tsz[x]=sz[ls(x)]+sz[rs(x)]+1;\n\t\tlc[x]=ls(x)?lc[ls(x)]:x;\n\t}\n\tinline void cng(int x,int t)\n\t{\n\t\tif(!x)return;\n\t\tcg[x]=vl[x]=1;tg[x]=t;\n\t\tsm[x]=sz[x];\n\t}\n\tinline void Dn(int x)\n\t{\n\t\tif(cg[x])\n\t\t{\n\t\t\tcng(ls(x),tg[x]);cng(rs(x),tg[x]);\n\t\t\tcg[x]=0;\n\t\t}\n\t}\n\tinline int Sn(int x)\n\t{\n\t\treturn rs(pr[x])==x;\n\t}\n\tinline int Ck(int x)\n\t{\n\t\treturn ls(pr[x])==x||Sn(x);\n\t}\n\tinline void Rtt(int x)\n\t{\n\t\tint y=pr[x],z=pr[y],l=Sn(x),r=l^1,p=sn[r][x],ch=Sn(y);\n\t\tif(Ck(y))\n\t\t{\n\t\t\tsn[ch][z]=x;\n\t\t}sn[r][x]=y;sn[l][y]=p;\n\t\tif(p)\n\t\t{\n\t\t\tpr[p]=y;\n\t\t}pr[y]=x;pr[x]=z;\n\t\tUp(y);Up(x);\n\t}\n\tint top,stk[Mx+5];\n\tinline void Pre_Dn(int x)\n\t{\n\t\tfor(;Ck(x);stk[++top]=x,x=pr[x])if(top>Mx)exit(666);\n\t\tfor(stk[++top]=x;top;Dn(stk[top--]));\n\t}\n\tinline void Spy(int x)\n\t{\n\t\tint y;\n\t\tfor(Pre_Dn(x);Ck(x);Rtt(x))\n\t\t{\n\t\t\tif(Ck(y=pr[x]))\n\t\t\t{\n\t\t\t\tRtt(Sn(x)==Sn(y)?y:x);\n\t\t\t}\n\t\t}\n\t}\n\tinline void Acs(int x)\n\t{\n\t\tint y;\n\t\tfor(y=0;x;x=pr[y=x])\n\t\t{\n\t\t\tSpy(x);\n\t\t\tint tp=rs(x);\n\t\t\tif(y)\n\t\t\t{\n\t\t\t\tif(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);\n\t\t\t}\n\t\t\trs(x)=y;\n\t\t\tif(tp)ft[lc[tp]]=tg[x];\n\t\t\tUp(x);\n\t\t}\n\t}\n\tinline void Cng_Acs(int x)\n\t{\n\t\tint y;++tot;\n\t\tfor(y=0;x;x=pr[y=x])\n\t\t{\n\t\t\tSpy(x);\n\t\t\tint tp=rs(x);\n\t\t\tif(!pr[x])ft[lc[rs(x)]]=tot,cng(rs(x),tot);\n\t\t\tif(y)\n\t\t\t{\n\t\t\t\tif(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);\n\t\t\t}\n\t\t\trs(x)=y;\n\t\t\tif(tp&&pr[x])ft[lc[tp]]=tg[x];\n\t\t\tUp(x);\n\t\t}\n\t\ttg[y]=tot;\n\t\tcng(rs(y),tot);\n\t\tvl[y]=0;Up(y);\n\t}\n\tinline void Cng(int x,int y)\n\t{\n\t\tAcs(x);Cng_Acs(y);\n\t}\n\tinline int Ask_Acs(int x)\n\t{\n\t\tint y,s=0;\n\t\tfor(y=0;x;x=pr[y=x])\n\t\t{\n\t\t\tSpy(x);\n\t\t\tint tp=rs(x);\n\t\t\ts=sm[rs(x)];\n\t\t\tif(y)\n\t\t\t{\n\t\t\t\tif(ft[lc[y]]<tg[x])Spy(y=lc[y]),vl[y]=0,ft[y]=tg[x],Up(y);\n\t\t\t}\n\t\t\trs(x)=y;\n\t\t\tif(tp)ft[lc[tp]]=tg[x];\n\t\t\tUp(x);\n\t\t}\n\t\treturn s+sm[rs(y)];\n\t}\n\tinline int Ask(int x,int y)\n\t{\n\t\tAcs(x);\n\t\treturn Ask_Acs(y);\n\t}\n}\n```\n\nUpd:jerry3128 \u628a\u6211\u590d\u6742\u5ea6\u5047\u6389\u4e86\uff0c\u539f\u56e0\u662f\u6211\u5077\u61d2\u628a\u865a\u513f\u5b50\u6e05\u7a7a\u65f6 Splay \u4e86\u4e00\u4e0b\uff0c\u9700\u8981\u7528\u6807\u8bb0\u4e0b\u4f20\uff0c\u590d\u6742\u5ea6\u624d\u5bf9\u3002jerry3128 \u73b0\u8eab\u8bf4\u6cd5\u5f88\u597d\u6539\uff01\u6211\u5c31\u61d2\u5f97\u6539\u4e86\u3002\u3002\u3002\n\nUpd:\u590d\u6742\u5ea6\u8bc1\u51fa\u6765\u4e86\uff0c\u5c31\u662f $O(n\\log^2{n})$ \u6ca1\u8dd1\u4e86\u3002\u3002\u3002~~\u800c\u4e14\u600e\u4e48\u8fd8\u6ca1\u5ba1\u554a~~",
        "postTime": 1627292774,
        "uid": 158948,
        "name": "\u7ea6\u745f\u592b\u7528\u8111\u73a9",
        "ccfLevel": 0,
        "title": "P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "#### \u9898\u610f\n\nNOI2021 Day 1 T1\n\n\u5c0f W \u6709\u4e00\u68f5 $n$ \u4e2a\u7ed3\u70b9\u7684\u6811\uff0c\u6811\u4e0a\u7684\u6bcf\u4e00\u6761\u8fb9\u53ef\u80fd\u662f\u8f7b\u8fb9\u6216\u8005\u91cd\u8fb9\u3002\u63a5\u4e0b\u6765\u4f60\u9700\u8981\u5bf9\u6811\u8fdb\u884c $m$ \u6b21\u64cd\u4f5c\uff0c\u5728\u6240\u6709\u64cd\u4f5c\u5f00\u59cb\u524d\uff0c\u6811\u4e0a\u6240\u6709\u8fb9\u90fd\u662f\u8f7b\u8fb9\u3002\n\n\u64cd\u4f5c\u6709\u4ee5\u4e0b\u4e24\u79cd\uff1a\n\n+ 1.\u7ed9\u5b9a\u4e24\u4e2a\u70b9 $a$ \u548c $b$\uff0c\u9996\u5148\u5bf9\u4e8e $a$ \u5230 $b$ \u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9 $x$\uff08\u5305\u542b $a$ \u548c $b$\uff09\uff0c\u4f60\u8981\u5c06\u4e0e $x$ \u76f8\u8fde\u7684\u6240\u6709\u8fb9\u53d8\u4e3a\u8f7b\u8fb9\u3002\u7136\u540e\u518d\u5c06 $a$ \u5230 $b$ \u8def\u5f84\u4e0a\u5305\u542b\u7684\u6240\u6709\u8fb9\u53d8\u4e3a\u91cd\u8fb9\u3002\n\n+ 2.\u7ed9\u5b9a\u4e24\u4e2a\u70b9 $a$ \u548c $b$\uff0c\u4f60\u9700\u8981\u8ba1\u7b97\u5f53\u524d $a$ \u5230 $b$ \u7684\u8def\u5f84\u4e0a\u4e00\u5171\u5305\u542b\u591a\u5c11\u6761\u91cd\u8fb9\u3002\n\n#### Solution\n\n\u91cd\u632f\u6811\u5256\u7cfb\u5217\uff08 \u4e0d\u8981 LCT \u4e0d\u8981 LCT\n\n\u5982\u679c\u6211\u4eec\u628a\u64cd\u4f5c\u4e00\u770b\u6210\u5bf9\u70b9\u67d3\u8272\uff0c\u6bcf\u6b21\u67d3\u8272\u7684\u989c\u8272\u90fd\u4e0d\u540c\u3002\n\n+ \u4e00\u6761\u8fb9\u662f\u91cd\u8fb9\u5f53\u4e14\u4ec5\u5f53\u5b83\u7684\u4e24\u4e2a\u7aef\u70b9\u90fd\u6709\u989c\u8272\u5e76\u4e14\u989c\u8272\u76f8\u540c\u3002\u7a0d\u5fae\u753b\u4e2a\u56fe\u5c31\u80fd\u7406\u89e3\u3002\u8bc1\u660e\u5f88\u5bb9\u6613\u3002\n\n\u6709\u4e86\u4e0a\u9762\u7684\u6027\u8d28\uff0c\u53ef\u4ee5\u8003\u8651\u7528\u6811\u5256\u6765\u5904\u7406\u8fd9\u4e2a\u95ee\u9898\u4e86\uff08\u5927\u4f6c\u4eec\u770b\u5230\u8fd9\u91cc\u5c31\u53ef\u4ee5\u4e0d\u7528\u770b\u4e86\uff09\u3002\n\n\u5bf9\u4e8e\u6811\u5256\u5904\u7406\u8def\u5f84\u7684\u65f6\u5019\uff0c\u63d0\u51fa\u6765\u7684\u6bcf\u4e00\u4e2a\u8fde\u7eed dfn \u6bb5\u4e00\u5b9a\u662f\u5bf9\u5e94\u4e86\u539f\u6811\u4e0a\u7684\u4e00\u6761\u94fe\uff08\u8fd9\u4e2a\u5728\u6211\u4eec\u6700\u540e\u5408\u5e76\u7b54\u6848\u7684\u65f6\u5019\u8981\u7528\uff0cmark \u4e00\u4e0b\uff09\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e2a dfn \u533a\u95f4\u7684\u7b54\u6848\uff0c\u8fd9\u4e2a\u53ea\u9700\u8981\u5728\u5408\u5e76\u5de6\u53f3\u513f\u5b50\u7684\u65f6\u5019\u5224\u65ad**\u5de6\u513f\u5b50**\u4ee3\u8868\u7684\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u548c**\u53f3\u513f\u5b50**\u4ee3\u8868\u7684\u533a\u95f4\u5de6\u7aef\u70b9\u989c\u8272\u662f\u5426\u76f8\u540c\u7136\u540e\u52a0\u4e0a\u5de6\u53f3\u513f\u5b50\u7684\u7b54\u6848\u5373\u53ef\u8f7b\u677e\u7ef4\u62a4\u3002\n\n\u6bcf\u6b21\u4fee\u6539\u76f8\u5f53\u4e8e\u533a\u95f4\u8986\u76d6\u67d3\u8272\uff0c\u5bf9\u5e94\u7684\u53ef\u4ee5\u7b80\u5355\u7ef4\u62a4\u3002\n\n#### \u5904\u7406\u8be2\u95ee\uff1a\n\n\u56e0\u4e3a\u6bcf\u6b21\u6211\u4eec\u7684\u6811\u5256\u4f1a\u5c06\u4e00\u6761\u94fe dfn \u5e8f\u5206\u6210 $O(\\log)$ \u6bb5\uff0c\u540c\u65f6\u6bcf\u4e00\u6bb5\u6211\u4eec\u53ef\u4ee5\u50cf\u524d\u9762\u7ef4\u62a4\u7ebf\u6bb5\u6811\u4e00\u6837\u83b7\u5f97\u7b54\u6848\uff0c\u5982\u6cd5\u70ae\u5236\u5373\u53ef\uff0c\u590d\u6742\u5ea6 $O(\\log n)$\uff0c\u5904\u7406 $O(\\log n)$ \u6bb5\u7684\u590d\u6742\u5ea6\u5c31\u662f $O(\\log^2n)$\u3002\n\n\u7136\u540e\u8fd9 $O(\\log n)$ \u6bb5 dfn \u5e8f\u8fde\u7eed\u6bb5\u4ee3\u8868\u7684\u4e0d\u540c\u94fe\u7684\u7aef\u70b9\u80af\u5b9a\u4f1a\u5b58\u5728\u6709\u7236\u5b50\u5173\u7cfb\uff0c\u7136\u540e\u5c31\u66b4\u529b\u679a\u4e3e\u5224\u65ad\u7236\u5b50\u5173\u7cfb\u5224\u65ad\u5373\u53ef\u505a\u5230 $O(\\log^2n)$\uff0c\u7528 sort \u662f\u4e0d\u662f\u53ef\u4ee5\u505a\u5230 $O(\\log n \\log \\log n)$ \uff1f\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6:$O(q \\log^2 n)$\uff0c\u7a7a\u95f4\u590d\u6742\u5ea6 $O(4 \\times n)$\n\n\u8fd9\u4e2a\u505a\u6cd5\u4e3b\u8981\u96be\u5ea6\u5728\u4e8e\u53d1\u73b0\u4e0a\u9762\u91cd\u8fb9\u7684\u6027\u8d28\u3002\uff08\u60f3\u4e86 20 min\uff0c\u8c03\u4e86 3 h\uff0c\u6211\u592a\u83dc\u4e86\uff09\n\n#### \u6076\u81ed\u7684Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ninline int read() {\n    int x = 0, flag = 1;\n    char ch = getchar();\n    for( ; ch > '9' || ch < '0' ; ch = getchar()) if(ch == '-') flag = -1;\n    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';\n    return x * flag;\n}\nconst int MAXN = 1e5 + 50;\nint n, m, start[MAXN], tot, Nowid;\nint siz[MAXN], dep[MAXN], fa[MAXN][20];\nint tp[MAXN], son[MAXN], dfn[MAXN], dfn_id[MAXN], lst = 0;\nint tack[MAXN][2], CL[MAXN][2], Cnt = 0;\nstruct SegmentTree {\n    int ls, rs, l, r, sum, tag;\n} T[MAXN << 2];\nstruct Edge {\n    int next, to;\n} edge[MAXN << 1];\nvoid add(int from, int to) {\n    edge[++ tot] = (Edge) { start[from], to } ;\n    start[from] = tot;\n}\nvoid DFS(int x, int from) {\n    fa[x][0] = from, dep[x] = dep[from] + 1;\n    siz[x] = 1, son[x] = 0;\n    for(int i = start[x] ; i ; i = edge[i].next) {\n        int to = edge[i].to;\n        if(to == from) continue;\n        DFS(to, x); siz[x] += siz[to];\n        if(siz[to] > siz[son[x]]) son[x] = to;\n    }\n    return ;\n}\nvoid DFS2(int x, int top) {\n    tp[x] = top, dfn[x] = ++ Nowid, dfn_id[Nowid] = x;\n    if(son[x]) DFS2(son[x], top);\n    for(int i = start[x] ; i ; i = edge[i].next) {\n        int to = edge[i].to;\n        if(to == fa[x][0] || to == son[x]) continue;\n        DFS2(to, to);\n    }\n    return ;\n}\ninline void update(int x) {\n    T[x].sum = T[x << 1].sum + T[x << 1 | 1].sum;\n    if(T[x << 1].rs == T[x << 1 | 1].ls && T[x << 1].rs != 0) T[x].sum ++;\n    T[x].ls = T[x << 1].ls;\n    T[x].rs = T[x << 1 | 1].rs;\n    return ;\n}\ninline void build(int x, int l, int r) {\n    T[x].l = l, T[x].r = r;\n    T[x].ls = T[x].rs = T[x].sum = T[x].tag = 0;\n    int mid = (l + r) >> 1;\n    if(l == r) return ;\n    build(x << 1, l, mid);\n    build(x << 1 | 1, mid + 1, r);\n    return ;\n}\ninline void ad(int x, int col) {\n    T[x].tag = T[x].ls = T[x].rs = col;\n    T[x].sum = T[x].r - T[x].l;\n    return ;\n}\ninline void pushdown(int x) {\n    if(!T[x].tag) return ;\n    ad(x << 1, T[x].tag), ad(x << 1 | 1, T[x].tag);\n    T[x].tag = 0; return ;\n}\ninline void change(int x, int l, int r, int id) {\n    int mid = (T[x].l + T[x].r) >> 1;\n    if(T[x].l >= l && T[x].r <= r) { ad(x, id); return ; }\n    pushdown(x);\n    if(l <= mid) change(x << 1, l, r, id);\n    if(r  > mid) change(x << 1 | 1, l, r, id);\n    update(x);\n    return ;\n}\ninline void ChangeR(int u, int v, int id) {\n    int x = u, y = v;\n    while(tp[x] != tp[y]) {\n        if(dep[tp[x]] < dep[tp[y]]) swap(x, y);\n        change(1, dfn[tp[x]], dfn[x], id);\n        x = fa[tp[x]][0];\n    }\n    int Min = min(dfn[x], dfn[y]), Max = max(dfn[x], dfn[y]);\n    change(1, Min, Max, id);\n    return ;\n}\ninline int Get(int x, int l, int r) {\n    if(T[x].l >= l && T[x].r <= r) {\n        int res = T[x].sum + (lst == T[x].ls && lst != 0);\n        lst = T[x].rs;\n        return res;\n    }\n    pushdown(x);\n    int mid = (T[x].l + T[x].r) >> 1, res = 0;\n    if(l <= mid) res += Get(x << 1, l, r);\n    if(r  > mid) res += Get(x << 1 | 1, l, r);\n    update(x);\n    return res;\n}\ninline int Getcol(int x, int pos) {\n    if(T[x].l == pos && T[x].r == pos) return T[x].tag;\n    pushdown(x);\n    int mid = (T[x].l + T[x].r) >> 1;\n    if(pos <= mid) return Getcol(x << 1, pos);\n    else return Getcol(x << 1 | 1, pos);\n}\ninline void GetR(int u, int v) {\n    int x = u, y = v, Ans = 0; Cnt = 0;\n    while(tp[x] != tp[y]) {\n        if(dep[tp[x]] < dep[tp[y]]) swap(x, y);\n        tack[++ Cnt][0] = dfn[tp[x]];\n        tack[Cnt][1] = dfn[x];\n        x = fa[tp[x]][0];\n    }\n    int Min = min(dfn[x], dfn[y]), Max = max(dfn[x], dfn[y]);\n    tack[++ Cnt][0] = Min, tack[Cnt][1] = Max;\n    for(int i = 1 ; i <= Cnt ; i ++) {\n        lst = 0;\n        int res = Get(1, tack[i][0], tack[i][1]);\n        Ans += res;\n    }\n    for(int i = 1 ; i <= Cnt ; i ++) {\n        CL[i][0] = Getcol(1, tack[i][0]);\n        CL[i][1] = Getcol(1, tack[i][1]);\n    }\n    for(int i = 1 ; i <= Cnt ; i ++) {\n        for(int j = 1 ; j <= Cnt ; j ++) {\n            if(i == j) continue;\n            if(fa[dfn_id[tack[j][0]]][0] == dfn_id[tack[i][1]]) {\n                Ans += (CL[j][0] == CL[i][1] && CL[j][0] != 0);\n                continue;\n            }\n            if(fa[dfn_id[tack[j][0]]][0] == dfn_id[tack[i][0]])\n                Ans += (CL[j][0] == CL[i][0] && CL[j][0] != 0);\n        }\n    }\n    printf(\"%d\\n\", Ans);\n    return ;\n}\n\nint main() {\n    int TestCases = read();\n    while(TestCases --){\n        n = read(), m = read(), tot = 0, Nowid = 0;\n        for(int i = 1 ; i <= n ; i ++) start[i] = 0;\n        for(int i = 2 ; i <= n ; i ++) {\n            int u = read(), v = read();\n            add(u, v), add(v, u);\n        }\n        DFS(1, 0), DFS2(1, 1), build(1, 1, n);\n        for(int i = 1 ; i <= m ; i ++) {\n            int op = read(), u = read(), v = read();\n            if(op == 1) ChangeR(u, v, i);\n            else GetR(u, v);\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1627291608,
        "uid": 67817,
        "name": "MuYC",
        "ccfLevel": 6,
        "title": "NOI 2021 Day1 T1 \u9898\u89e3"
    },
    {
        "content": "\u540c\u6b65\u53d1\u8868\u4e8e [$\\texttt{Cnblogs}$](https://www.cnblogs.com/VCLS01/p/15063614.html)\u3002\n\n\u5927\u5bb6\u597d\uff0c\u6211\u662f $\\texttt{NOI2020 D1T3}$ \u7684\u9898\u76ee\u3002\n## \u9898\u76ee\u63cf\u8ff0\n\n\u7ed9\u51fa\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\u3002\u6811\u4e0a\u7684\u8fb9\u6709\u8f7b\u91cd\u4e4b\u5206\uff0c\u5f00\u59cb\u65f6\uff0c\u6240\u6709\u8fb9\u5747\u4e3a\u8f7b\u8fb9\u3002\n\n\u6709 $m$ \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u7ed9\u5b9a $op,a,b$\uff1a\n\n - $op=1$\uff0c\u5c06 $a,b$ \u6700\u77ed\u8def\u5f84\u4e0a\u7684\u8fb9\u8d4b\u4e3a\u91cd\u8fb9\uff0c\u4e0e $a,b$ \u6700\u77ed\u8def\u5f84\u4e0a\u7684\u70b9\u76f8\u8fde\u7684\u5176\u4ed6\u8fb9\u8d4b\u4e3a\u8f7b\u8fb9\u3002\n - $op=2$\uff0c\u6c42 $a,b$ \u6700\u77ed\u8def\u5f84\u4e0a\u91cd\u8fb9\u7684\u4e2a\u6570\u3002\n\n\u4fdd\u8bc1 $a\\neq b$\u3002\n\n**\u6570\u636e\u8303\u56f4\uff1a**$n,m\\le 10^5$\u3002\n\n**\u65f6\u95f4\u9650\u5236\uff1a**$1000\\text{ms}$\u3002\n\n## Solution 1\n\n\u5bb9\u6613\u60f3\u5230\u4e00\u4e2a\u975e\u5e38\u7ecf\u5178\u7684\u505a\u6cd5\u3002\n\n\u7528\u6811\u5256\u6216 $\\texttt{Link-Cut-Tree}$ \u7ef4\u62a4\u65f6\u95f4\u6233\uff0c\u65f6\u95f4\u6233\u76f8\u540c\u4e3a\u91cd\u8fb9\uff0c\u4e0d\u540c\u4e3a\u8f7b\u8fb9\uff0c\u53ef\u4ee5\u8f6c\u5316\u4e3a\u7edf\u8ba1\u989c\u8272\u6bb5\u6570\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003 [$\\texttt{SDOI 2011}$ \u67d3\u8272](https://www.luogu.com.cn/problem/P2486)\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(Tn\\log^2 n)$ \u6216 $O(Tn\\log n)$\uff0c~~\u4f46\u6ca1\u5199~~\u3002\n\n## Solution 2\n\n\u76f4\u63a5\u6811\u5256\u66b4\u529b\u4fee\u6539\uff0c\u6bcf\u6b21\u4fee\u6539\u65f6\u6ce8\u610f\u7edf\u8ba1\u94fe\u4e0a\u4e0b\u90e8\u5206\u7684\u8f7b\u91cd\u5212\u5206\uff0c\u67e5\u8be2\u65f6\u7279\u5224\u94fe\u4e0a\u4e0b\u7aef\u7684\u503c\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(Tn\\log^2 n)$\uff0c\u53ef\u80fd\u9700\u8981\u5361\u5e38\uff0c~~\u5199\u4e86\u4e5f\u6ca1\u8c03\u51fa\u6765~~\u3002\n\n## Code\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define lc (u<<1)\n#define rc (u<<1|1)\nusing namespace std;\nconst int maxn=100010;\nint Fir[maxn],Nxt[maxn<<1],Too[maxn<<1],tot=1;\nint son[maxn],fa[maxn],dep[maxn],top[maxn],n,m,dfn[maxn],Times,siz[maxn];\ntemplate<class T>inline void read(T &x){\n\tx=0;char c;\n\tdo c=getchar();while(c<'0'||c>'9');\n\twhile(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n}\nint wrt[100],wrtop;\ntemplate<class T>inline void write(T x,char c){\n\tif(!x)putchar('0');\n\twrtop=0;while(x)wrt[++wrtop]=x%10,x/=10;\n\twhile(wrtop)putchar(wrt[wrtop--]+'0');\n\tputchar(c);\n}\ninline void add(int a,int b){\n\tToo[++tot]=b;Nxt[tot]=Fir[a];Fir[a]=tot;\n}\ninline void Init(){\n\tmemset(Fir,0,sizeof(Fir));tot=1;\n\tmemset(son,0,sizeof(son));Times=0;\n}\nstruct SegmentTree{\n\tint l,r,v,tag,tim;\n}tr[maxn<<2];\ninline void change(int u,int d,int tim){\n\tif(d)tr[u].tag=d;\n\tif(d==1)tr[u].v=tr[u].r-tr[u].l+1;\n\telse if(d==-1)tr[u].v=0;\n\tif(tim)tr[u].tim=tim;\n}\ninline void pushdown(int u){\n\tchange(lc,tr[u].tag,tr[u].tim);change(rc,tr[u].tag,tr[u].tim);tr[u].tag=tr[u].tim=0;\n}\ninline void pushup(int u){\n\ttr[u].v=tr[lc].v+tr[rc].v;\n}\ninline void build(int u,int l,int r){\n\ttr[u].l=l;tr[u].r=r;tr[u].tim=tr[u].tag=tr[u].v=0;if(l==r)return;\n\tint mid=(l+r)>>1;build(lc,l,mid);build(rc,mid+1,r);\n}\ninline void modify(int u,int l,int r,int d,int tim){\n\tif(l<=tr[u].l&&tr[u].r<=r){change(u,d,tim);return;}\n\tpushdown(u);\n\tint mid=(tr[u].l+tr[u].r)>>1;\n\tif(l<=mid)modify(lc,l,r,d,tim);\n\tif(mid<r) modify(rc,l,r,d,tim);\n\tpushup(u);\n}\ninline int query(int u,int l,int r){\n\tif(l<=tr[u].l&&tr[u].r<=r)return tr[u].v;\n\tpushdown(u);\n\tint mid=(tr[u].l+tr[u].r)>>1,ans=0;\n\tif(l<=mid)ans=query(lc,l,r);\n\tif(mid<r)ans+=query(rc,l,r);\n\treturn ans;\n}\ninline int querytim(int u,int x){\n\tif(tr[u].l==tr[u].r)return tr[u].tim;\n\tpushdown(u);\n\tint mid=(tr[u].l+tr[u].r)>>1;\n\tif(x<=mid)return querytim(lc,x);\n\telse return querytim(rc,x);\n}\ninline void dfs1(int u,int f){\n\tfa[u]=f;dep[u]=dep[f]+1;siz[u]=1;\n\tfor(int i=Fir[u];i;i=Nxt[i]){\n\t\tint v=Too[i];\n\t\tif(v!=f){\n\t\t\tdfs1(v,u);\n\t\t\tsiz[u]+=siz[v];\n\t\t\tif(siz[v]>siz[son[u]])son[u]=v;\n\t\t}\n\t}\n}\ninline void dfs2(int u,int tp){\n\tdfn[u]=++Times;top[u]=tp;\n\tif(son[u])dfs2(son[u],tp);\n\tfor(int i=Fir[u];i;i=Nxt[i]){\n\t\tint v=Too[i];\n\t\tif(v!=fa[u]&&v!=son[u])dfs2(v,v);\n\t}\n}\ninline void add(int x,int y,int tim){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tif(son[x])modify(1,dfn[son[x]],dfn[son[x]],-1,0);\n\t\tmodify(1,dfn[top[x]],dfn[x],1,tim);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]<dep[y])swap(x,y);\n\tif(son[y]&&dep[son[y]]<=dep[x])modify(1,dfn[son[y]],dfn[x],1,tim);\n\tmodify(1,dfn[y],dfn[y],-1,tim);\n\tif(son[x])modify(1,dfn[son[x]],dfn[son[x]],-1,0);\n}\ninline int ask(int x,int y,int tim){\n\tint ans=0;\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\tif(fa[top[x]]){\n\t\t\tint ft=querytim(1,dfn[fa[top[x]]]);\n\t\t\tint tt=querytim(1,dfn[top[x]]);\n\t\t\tif(tt&&ft&&tt<ft)modify(1,dfn[top[x]],dfn[top[x]],-1,0);\n\t\t}\n\t\tans+=query(1,dfn[top[x]],dfn[x]);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]<dep[y])swap(x,y);\n\tif(son[y]&&dep[son[y]]<=dep[x])ans+=query(1,dfn[son[y]],dfn[x]);\n\treturn ans;\n}\ninline void solve(){\n\tdfs1(1,1);dfs2(1,1);build(1,1,n);\n\tfor(int i=1;i<=m;++i){\n\t\tint op,a,b;read(op);read(a);read(b);\n\t\tif(op==1)add(a,b,i);\n\t\telse write(ask(a,b,i),'\\n');\n\t}\n}\nint main(){\n\tint T;read(T);\n\twhile(T--){\n\t\tread(n);read(m);\n\t\tInit();\n\t\tfor(int i=1;i<n;++i){int u,v;read(u);read(v);add(u,v);add(v,u);}\n\t\tsolve();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1627309790,
        "uid": 375785,
        "name": "x7103",
        "ccfLevel": 9,
        "title": "NOI2021 \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u79cd\u9b54\u6539\u6811\u94fe\u5256\u5206\u7684\u505a\u6cd5\u3002\n\n### \u5206\u6790\n\n\u628a\u9898\u4e2d\u7684\u91cd\u8fb9\u770b\u6210\u8fb9\u6743 $1$\uff0c\u8f7b\u8fb9\u770b\u6210\u8fb9\u6743 $0$\u3002\u8fb9\u6743\u663e\u7136\u4e0d\u592a\u597d\u5904\u7406\uff0c\u6240\u4ee5\u628a\u6bcf\u6761\u8fb9\u7684\u8fb9\u6743\u53d8\u6210\u513f\u5b50\u8282\u70b9\u7684\u70b9\u6743\u3002\u8fd9\u65f6\uff0c\u4e00\u6b21\u4fee\u6539\u76f8\u5f53\u4e8e\u628a\u8def\u5f84\u4e0a**\u6240\u6709\u7684\u70b9\u4ee5\u53ca\u5b83\u4eec\u7684\u513f\u5b50**\u8d4b\u503c\u4e3a $0$\uff0c\u518d\u628a\u8def\u5f84\u4e0a**\u9664** **LCA** **\u5916\u7684\u70b9**\u8d4b\u503c\u4e3a $1$\u3002\u4e00\u6b21\u8be2\u95ee\u5c31\u662f\u95ee\u8def\u5f84\u4e0a**\u9664** **LCA** **\u5916\u7684\u70b9**\u7684\u6743\u503c\u548c\u3002\n\n\u5bb9\u6613\u60f3\u5230\u6811\u94fe\u5256\u5206\u3002\u4f46\u4f20\u7edf\u7684\u6811\u94fe\u5256\u5206\u7684\u7f16\u53f7\u539f\u5219\u662f\u300c\u91cd\u94fe\u7f16\u53f7\u8fde\u7eed\u3001\u5b50\u6811\u7f16\u53f7\u8fde\u7eed\u300d\uff0c\u6211\u4eec\u8fd9\u91cc\u4e0d\u9700\u8981\u7ef4\u62a4\u5b50\u6811\u4fe1\u606f\uff0c\u9700\u8981\u77e5\u9053\u513f\u5b50\u7684\u4fe1\u606f\uff0c\u6240\u4ee5\u6bd4\u8f83\u81ea\u7136\u60f3\u5230\uff0c\u7528\u67d0\u79cd\u65b9\u5f0f\u4f7f\u5f97\u300c\u91cd\u94fe\u4e0a\u6240\u6709\u70b9\u7684\u513f\u5b50\u7f16\u53f7\u8fde\u7eed\u300d\u3002\n\n\u5982\u4f55\u5b9e\u73b0\u5462\uff1f\u6211\u7684\u65b9\u6cd5\u662f\uff0c\u5148\u6309\u4f20\u7edf\u7684\u65b9\u6cd5\u628a\u91cd\u94fe\u90fd\u5206\u51fa\u6765\uff0c\u7136\u540e\u7c7b\u4f3c\u4e8e BFS\uff0c\u5efa\u7acb\u4e00\u4e2a\u961f\u5217\uff0c\u628a\u4ee5\u6839\u8282\u70b9\u4e3a $top$ \u7684\u91cd\u94fe\u585e\u8fdb\u53bb\u3002\u6bcf\u6b21\u53d6\u51fa\u961f\u5934\u7684\u91cd\u94fe\uff0c\u628a\u8fd9\u6761\u91cd\u94fe\u4e0a\u7684\u70b9\u7684\u513f\u5b50\u4f9d\u6b21\u7f16\u53f7\uff0c\u7136\u540e\u628a\u4ee5\u8fd9\u4e9b\u513f\u5b50\u4e3a $top$ \u7684\u91cd\u94fe\u585e\u8fdb\u961f\u5217\u3002\n\n\u6b64\u5916\uff0c\u5bf9\u6bcf\u4e2a\u70b9 $x$\uff0c\u518d\u9884\u5904\u7406\u51fa\u5176\u6240\u5728\u7684\u91cd\u94fe\u4e2d\uff0c\u7531 $x$ \u5411\u4e0a/\u5411\u4e0b\u8d70\u80fd\u78b0\u5230\u7684\u8282\u70b9\u7684\u513f\u5b50\u7684\u7f16\u53f7\u6700\u5927/\u5c0f\u503c\uff0c\u5c31\u53ef\u4ee5\u5bb9\u6613\u8c03\u7528\u7ebf\u6bb5\u6811\u7684\u64cd\u4f5c\u6765\u5b9e\u73b0\u513f\u5b50\u7684\u8d4b\u503c\u3002\n\n\u4e0a\u8ff0\u65b9\u6848\u552f\u4e00\u7684\u7f8e\u4e2d\u4e0d\u8db3\u662f\uff0c\u4e00\u6761\u91cd\u94fe\u7684 $top$ \u4e0e $top$ \u7684\u91cd\u513f\u5b50\u7f16\u53f7\u53ef\u80fd\u4e0d\u8fde\u7eed\uff0c\u6240\u4ee5\u5bf9\u4e8e\u94fe\u7684\u64cd\u4f5c\uff0c\u6bcf\u6b21\u53ea\u80fd\u53d6\u51fa $top$ \u7684\u91cd\u513f\u5b50\u5f80\u4e0b\u7684\u4e00\u6bb5\u8fdb\u884c\u64cd\u4f5c\uff0c\u518d\u5355\u72ec\u64cd\u4f5c $top$ \u81ea\u5df1\u3002\u8fd9\u4f1a\u5bfc\u81f4\u5e38\u6570\u6bd4\u8f83\u5927\uff0c\u5927\u6982\u662f\u4f20\u7edf\u6811\u5256\u7684 $4-5$ \u500d\u3002\n\n\u663e\u7136\uff0c\u4e0e\u4f20\u7edf\u6811\u5256\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e00\u6837\uff0c\u4e3a $O(n \\log^2 n)$\u3002\n\n\u8003\u573a\u4e0a\u8dd1\u81ea\u5df1\u811a\u9020\u7684\u6570\u636e\u4f1a\u8d85 $0.2s$ \u5de6\u53f3\uff0c\u611f\u89c9\u5e38\u6570\u5de8\u5927\u6ca1\u5e0c\u671b\u4e86\uff0c\u4f46 CCF \u7684\u5de8\u725b\u903c\u673a\u5b50\u6700\u5927\u7684\u70b9\u53ea\u8dd1\u4e86 $0.8s$\uff0c\u8d85\u8d5e\u3002\n\n### \u4ee3\u7801\n\n\u5177\u4f53\u5b9e\u73b0\u7684\u65f6\u5019\u53ef\u4ee5\u4e0d\u628a\u94fe\u5148\u8d4b\u503c\u4e3a $0$\uff0c\u4ee5\u51cf\u5c0f\u5e38\u6570\u3002\n\n\u8003\u573a\u4e0a\u7684\u6838\u5fc3\u4ee3\u7801\uff0c\u7a0d\u5fae\u4fee\u5f97\u597d\u770b\u4e86\u4e00\u70b9\uff1a\n\n```cpp\nstruct SegT {\n\tint l, r, sum, tg;\n\t#define ls (p << 1)\n\t#define rs (p << 1 | 1)\n} t[N<<2];\nvoid build(int p, int l, int r) {\n\tt[p].l = l, t[p].r = r, t[p].sum = 0, t[p].tg = -1;\n\tif (l == r) return;\n\tint mid = (l + r) >> 1;\n\tbuild(ls, l, mid), build(rs, mid + 1, r);\n}\ninline void push_up(int p) { t[p].sum = t[ls].sum + t[rs].sum; }\ninline void push_down(int p) {\n\tif (t[p].tg != -1) {\n\t\tt[ls].sum = t[p].tg * (t[ls].r - t[ls].l + 1), t[ls].tg = t[p].tg;\n\t\tt[rs].sum = t[p].tg * (t[rs].r - t[rs].l + 1), t[rs].tg = t[p].tg;\n\t\tt[p].tg = -1;\n\t}\n}\nvoid upd(int p, int l, int r, int v) {\n\tif (l <= t[p].l && t[p].r <= r) return t[p].sum = v * (t[p].r - t[p].l + 1), t[p].tg = v, void();\n\tint mid = (t[p].l + t[p].r) >> 1;\n\tpush_down(p);\n\tif (l <= mid) upd(ls, l, r, v);\n\tif (r > mid) upd(rs, l, r, v);\n\tpush_up(p);\n}\nint qry(int p, int l, int r) {\n\tif (l <= t[p].l && t[p].r <= r) return t[p].sum;\n\tint mid = (t[p].l + t[p].r) >> 1, res = 0;\n\tpush_down(p);\n\tif (l <= mid) res += qry(ls, l, r);\n\tif (r > mid) res += qry(rs, l, r);\n\treturn res;\n}\n\nint fa[N], siz[N], son[N], dep[N], tp[N];\nint dfn[N], rk[N], sec;\nint upmx[N], upmn[N], dwmx[N], dwmn[N];\nvector<int> V[N];\nint q[N], hd, tl;\n\nvoid dfs1(int x, int ff, int dpt) {\n\tfa[x] = ff, dep[x] = dpt;\n\tsiz[x] = 1, son[x] = 0;\n\tfor (int i = g[x]; i; i = nxt[i]) {\n\t\tint y = v[i];\n\t\tif (y == fa[x]) continue;\n\t\tdfs1(y, x, dep[x] + 1);\n\t\tif (!son[x] || siz[y] > siz[son[x]]) son[x] = y;\n\t\tsiz[x] += siz[y];\n\t}\n}\n\nvoid dfs2(int x) {\n\tif (!tp[x]) tp[x] = x;\n\tV[tp[x]].pb(x);\n\tfor (int i = g[x]; i; i = nxt[i]) {\n\t\tint y = v[i];\n\t\tif (y == fa[x]) continue;\n\t\tif (y == son[x]) tp[y] = tp[x];\n\t\tdfs2(y);\n\t}\n}\n\ninline void upd0(int x, int y) {\n\twhile (tp[x] != tp[y]) {\n\t\tif (dep[tp[x]] < dep[tp[y]]) swap(x, y);\n\t\tif (son[x]) upd(1, dfn[son[x]], dfn[son[x]], 0);\n\t\tif (dwmn[tp[x]] <= upmx[x]) upd(1, dwmn[tp[x]], upmx[x], 0);\n\t\tx = fa[tp[x]];\n\t}\n\tif (dep[x] < dep[y]) swap(x, y);\n\tif (son[x]) upd(1, dfn[son[x]], dfn[son[x]], 0);\n\tif (dwmn[y] <= upmx[x]) upd(1, dwmn[y], upmx[x], 0);\n\tupd(1, dfn[y], dfn[y], 0);\n}\n\ninline void upd1(int x, int y) {\n\twhile (tp[x] != tp[y]) {\n\t\tif (dep[tp[x]] < dep[tp[y]]) swap(x, y);\n\t\tif (tp[x] != x) upd(1, dfn[son[tp[x]]], dfn[x], 1);\n\t\tupd(1, dfn[tp[x]], dfn[tp[x]], 1);\n\t\tx = fa[tp[x]];\n\t}\n\tif (dep[x] < dep[y]) swap(x, y);\n\tif (x != y) upd(1, dfn[son[y]], dfn[x], 1);\n}\n\ninline int qry(int x, int y) {\n\tint res = 0;\n\twhile (tp[x] != tp[y]) {\n\t\tif (dep[tp[x]] < dep[tp[y]]) swap(x, y);\n\t\tif (tp[x] != x) res += qry(1, dfn[son[tp[x]]], dfn[x]);\n\t\tres += qry(1, dfn[tp[x]], dfn[tp[x]]);\n\t\tx = fa[tp[x]];\n\t}\n\tif (dep[x] < dep[y]) swap(x, y);\n\tif (x != y) res += qry(1, dfn[son[y]], dfn[x]);\n\treturn res;\n}\n\ninline void init() {\n\tmemset(g, 0, sizeof(g)), tot = 0;\n\tmemset(tp, 0, sizeof(tp)), sec = 0;\n\tfor (int i = 1; i <= n; i++) V[i].clear();\n}\n\ninline void solve() {\n\tn = rd(), m = rd();\n\tinit();\n\tfor (int i = 1; i < n; i++) {\n\t\tint x = rd(), y = rd();\n\t\tadd(x, y), add(y, x);\n\t}\n\tfor (int i = 1; i <= m; i++) {\n\t\tqs[i].op = rd(), qs[i].x = rd(), qs[i].y = rd();\n\t}\n\tif (n <= 5000 && m <= 5000) {\n\t\tsub1::main();\n\t\treturn;\n\t}\n\tdfs1(1, 0, 0);\n\tdfs2(1);\n\thd = tl = 0;\n\tq[tl++] = 1, dfn[1] = ++sec, rk[sec] = 1;\n\twhile (hd != tl) {\n\t\tint x = q[hd++], len = V[x].size();\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tint y = V[x][i];\n\t\t\tdfn[y] = ++sec, rk[sec] = y;\n\t\t}\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint y = V[x][i];\n\t\t\tupmx[y] = -inf, upmn[y] = inf;\n\t\t\tfor (int j = g[y]; j; j = nxt[j]) {\n\t\t\t\tint z = v[j];\n\t\t\t\tif (z == fa[y]) continue;\n\t\t\t\tif (z == son[y]) continue;\n\t\t\t\tdfn[z] = ++sec, rk[sec] = z;\n\t\t\t\tq[tl++] = z;\n\t\t\t\tchkmax(upmx[y], dfn[z]);\n\t\t\t\tchkmin(upmn[y], dfn[z]);\n\t\t\t}\n\t\t\tdwmx[y] = upmx[y], dwmn[y] = upmn[y];\n\t\t}\n\t\tfor (int i = 1; i < len; i++) {\n\t\t\tchkmax(upmx[V[x][i]], upmx[V[x][i-1]]);\n\t\t\tchkmin(upmn[V[x][i]], upmn[V[x][i-1]]);\n\t\t}\n\t\tfor (int i = len - 2; i >= 0; i--) {\n\t\t\tchkmax(dwmx[V[x][i]], dwmx[V[x][i+1]]);\n\t\t\tchkmin(dwmn[V[x][i]], dwmn[V[x][i+1]]);\n\t\t}\n\t}\n\tbuild(1, 1, n);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint op = qs[i].op, x = qs[i].x, y = qs[i].y;\n\t\tif (op == 1) upd0(x, y), upd1(x, y);\n\t\telse printf(\"%d\\n\", qry(x, y));\n\t}\n}\n```",
        "postTime": 1627308277,
        "uid": 138041,
        "name": "cyh_toby",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P7735\u3010[NOI2021] \u8f7b\u91cd\u8fb9\u3011"
    },
    {
        "content": "\u5199\u4e2a\u9898\u89e3\u7eaa\u5ff5\u4e00\u4e0b\u6211\u5728\u8fd9\u573a noi \u552f\u4e00\u8fc7\u6389\u7684\u4e00\u9898\u5427\uff08\u5927\u6982\u7387\u662f\uff09\u3002\n\n~~\u9996\u5148\u770b\u8fd9\u4e2a\u4fee\u6539\u975e\u5e38 lct\uff0c\u7136\u800c\u6211\u4e0d\u4f1a lct \u6240\u4ee5\u518d\u89c1\u5427\u3002~~\n\n\u65e2\u7136 lct \u4e0d\u884c\u90a3\u4e48\u5c31\u8003\u8651\u6811\u94fe\u5256\u5206\u3002\n\n\u6811\u5256\u4e0d\u597d\u7ef4\u62a4\u8fb9\u6743\uff0c\u4e0d\u59a8\u628a $(u,v)$ \u7684\u6743\u503c\u4e0b\u653e\u5230\u6df1\u5ea6\u66f4\u5927\u7684\u70b9\u4e0a\u3002\n\n\u8fd9\u65f6\uff0c\u5bf9\u4e8e\u91cd\u94fe\u4e0a\u7684\u8fb9\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u7ebf\u6bb5\u6811\u6765\u652f\u6301\u533a\u95f4\u8d4b\u503c\u533a\u95f4\u6c42\u548c\u3002\u8003\u8651\u8f7b\u8fb9\u600e\u4e48\u505a\u3002\n\n\u8003\u8651\u62c6\u5206\u64cd\u4f5c\uff0c\u5bf9\u4e8e $u,v$\uff0c\u53ef\u4ee5\u62c6\u4e3a\u5982\u4e0b\u4e24\u4e2a\u64cd\u4f5c\uff1a\n\n- \u5bf9 $(u,v)$ \u4e0a\u6240\u6709\u70b9\uff0c\u5c06\u6240\u6709\u76f8\u90bb\u7684\u8fb9\u53d8\u8f7b\u3002\n- \u5bf9 $(u,v)$ \u4e0a\u6240\u6709\u70b9\uff0c\u5c06\u5176\u8fde\u5411\u7236\u4eb2\u7684\u8fb9\u53d8\u91cd\u3002\n\n\u5230\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\uff0c\u5176\u6743\u503c\u6539\u53d8\u6709\u53ef\u80fd\u7531\u5982\u4e0b\u4e09\u79cd\u4fee\u6539\u51b3\u5b9a\uff1a\n\n- \u4e00\u4e2a\u7aef\u70b9\u88ab\u8fdb\u884c\u4e86\u201c\u5c06\u6240\u6709\u76f8\u90bb\u7684\u8fb9\u53d8\u8f7b\u201d\u64cd\u4f5c\u3002\n- \u6df1\u5ea6\u8f83\u6df1\u7684\u70b9\u88ab\u8fdb\u884c\u4e86\u201c\u5c06\u8fde\u5411\u7236\u4eb2\u7684\u8fb9\u53d8\u91cd\u201d\u64cd\u4f5c\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u70b9\uff0c\u7ef4\u62a4\u4e00\u4e2a $t_{u,0}$ \u8868\u793a **\u8fd9\u4e2a\u70b9\u6700\u540e\u4e00\u6b21\u88ab\u8fdb\u884c\u64cd\u4f5c\u201c\u5c06\u6240\u6709\u76f8\u90bb\u7684\u8fb9\u53d8\u8f7b\u201d\u7684\u65f6\u95f4**\uff0c\u548c\u4e00\u4e2a $t_{u,1}$ \u8868\u793a **\u8fd9\u4e2a\u70b9\u6700\u540e\u4e00\u6b21\u88ab\u8fdb\u884c\u64cd\u4f5c\u201c\u5c06\u8fde\u5411\u7236\u4eb2\u7684\u8fb9\u53d8\u91cd\u201d\u7684\u65f6\u95f4**\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u4e0d\u662f\u94fe\u5934\u7684\u70b9 $u$\uff0c\u5176 $t_{u,1}$ \u7684\u503c\u4e0d\u4f1a\u88ab\u7528\u5230\uff0c\u4f46\u662f $t_{u,0}$ \u53ef\u80fd\u88ab\u7528\u5230\uff0c\u6240\u4ee5 $t_{u,0}$ \u9700\u8981\u4f7f\u7528\u7ebf\u6bb5\u6811\u652f\u6301\u533a\u95f4\u5bf9\u4e00\u4e2a\u6570\u53d6 max \u4ee5\u53ca\u5355\u70b9\u6c42\u503c\uff0c\u800c $t_{u,1}$ \u76f4\u63a5\u7528\u6570\u7ec4\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u603b\u590d\u6742\u5ea6 $O(Tq\\log^2n)$\uff0c\u5e38\u6570\u4e00\u822c\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[(1<<21)+5], *p1 = buf, *p2 = buf;\n\ninline int qread() {\n\tchar c = getchar();\n\tint x = 0, f = 1;\n\twhile (c < '0' || c > '9') {\n\t\tif (c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = x * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\nconst int N = 100005;\nstruct Edge {\n\tint to, nxt;\n\tEdge() {\n\t\tnxt = -1;\n\t}\n};\nEdge e[N << 1];\nint n, hd[N], pnt, siz[N], son[N], top[N], dfn[N], fa[N], dep[N], _time, tag1[N], q;\n\nstruct Segtree_tag0 {\n\tint tag[N << 2];\n\tinline void Modify(int p, int pl, int pr, int l, int r, int v) {\n\t\tif (l > r) return;\n\t\tif (pl == l && pr == r) {\n\t\t\ttag[p] = max(tag[p], v);\n\t\t\treturn;\n\t\t}\n\t\tint mid = pl + pr >> 1;\n\t\tif (mid >= r) Modify(p << 1, pl, mid, l, r, v);\n\t\telse if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);\n\t\telse {\n\t\t\tModify(p << 1, pl, mid, l, mid, v);\n\t\t\tModify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);\n\t\t}\n\t}\n\tinline int Query(int p, int pl, int pr, int idx) {\n\t\tif (pl == pr) return tag[p];\n\t\tint mid = pl + pr >> 1;\n\t\tif (idx <= mid) return max(tag[p], Query(p << 1, pl, mid, idx));\n\t\telse return max(tag[p], Query(p << 1 | 1, mid + 1, pr, idx));\n\t}\n\tinline void Clear() {\n\t\tmemset(tag, 0, sizeof(tag));\n\t}\n};\nSegtree_tag0 sgt1;\n\nstruct Segtree_Edge {\n\tint sum[N << 2], tag[N << 2];\n\tinline void Clear() {\n\t\tmemset(sum, 0, sizeof(sum));\n\t\tmemset(tag, -1, sizeof(tag));\n\t}\n\tinline void Pushdown(int p, int pl, int pr) {\n\t\tif (tag[p] < 0) return;\n\t\tint mid = pl + pr >> 1;\n\t\tsum[p << 1] = tag[p] * (mid - pl + 1);\n\t\ttag[p << 1] = tag[p];\n\t\tsum[p << 1 | 1] = tag[p] * (pr - mid);\n\t\ttag[p << 1 | 1] = tag[p];\n\t\ttag[p] = -1;\n\t}\n\tinline void Modify(int p, int pl, int pr, int l, int r, int v) {\n\t\tif (l > r) return;\n\t\t//if (p == 1) printf(\"[%d,%d] %d\\n\", l, r, v);\n\t\tif (pl == l && pr == r) {\n\t\t\ttag[p] = v;\n\t\t\tsum[p] = (pr - pl + 1) * v;\n\t\t\treturn;\n\t\t}\n\t\tPushdown(p, pl, pr);\n\t\tint mid = pl + pr >> 1;\n\t\tif (mid >= r) Modify(p << 1, pl, mid, l, r, v);\n\t\telse if (mid + 1 <= l) Modify(p << 1 | 1, mid + 1, pr, l, r, v);\n\t\telse {\n\t\t\tModify(p << 1, pl, mid, l, mid, v);\n\t\t\tModify(p << 1 | 1, mid + 1, pr, mid + 1, r, v);\n\t\t}\n\t\tsum[p] = sum[p << 1] + sum[p << 1 | 1];\n\t}\n\tinline int Query(int p, int pl, int pr, int l, int r) {\n\t\tif (l > r) return 0;\n\t\tif (pl == l && pr == r) return sum[p];\n\t\tPushdown(p, pl, pr);\n\t\tint mid = pl + pr >> 1;\n\t\tif (mid >= r) return Query(p << 1, pl, mid, l, r);\n\t\telse if (mid + 1 <= l) return Query(p << 1 | 1, mid + 1, pr, l, r);\n\t\telse return Query(p << 1, pl, mid, l, mid) + Query(p << 1 | 1, mid + 1, pr, mid + 1, r);\n\t}\n};\nSegtree_Edge sgt2;\n\ninline void Clear() {\n\tmemset(hd, -1, sizeof(hd));\n\tpnt = 0;\n\tsgt1.Clear();\n\tsgt2.Clear();\n\tmemset(tag1, -1, sizeof(tag1));\n\tn = 0; q = 0;\n\tmemset(siz, 0, sizeof(siz));\n\tmemset(son, 0, sizeof(son));\n\tmemset(top, 0, sizeof(top));\n\tmemset(dfn, 0, sizeof(dfn));\n\tmemset(fa, 0, sizeof(fa));\n\tmemset(dep, 0, sizeof(dep));\n\t_time = 0;\n}\n\ninline void AddEdge(int u, int v) {\n\te[++pnt].to = v;\n\te[pnt].nxt = hd[u];\n\thd[u] = pnt;\n}\n\ninline void Read() {\n\tn = qread(); q = qread();\n\tfor (int i = 1;i < n;i++) {\n\t\tint u = qread(), v = qread();\n\t\tAddEdge(u, v);\n\t\tAddEdge(v, u);\n\t}\n}\n\ninline void Dfs1(int u) {\n\tsiz[u] = 1;\n\tfor (int i = hd[u];~i;i = e[i].nxt) {\n\t\tif (e[i].to != fa[u]) {\n\t\t\tfa[e[i].to] = u;\n\t\t\tdep[e[i].to] = dep[u] + 1;\n\t\t\tDfs1(e[i].to);\n\t\t\tsiz[u] += siz[e[i].to];\n\t\t\tif (siz[e[i].to] > siz[son[u]]) son[u] = e[i].to; \n\t\t}\n\t}\n}\n\ninline void Dfs2(int u, int tp) {\n\ttop[u] = tp;\n\tdfn[u] = ++_time;\n\tif (son[u]) Dfs2(son[u], tp);\n\tfor (int i = hd[u];~i;i = e[i].nxt) {\n\t\tif (e[i].to != fa[u] && e[i].to != son[u]) Dfs2(e[i].to, e[i].to);\n\t}\n}\n\ninline void Modify0(int u, int v, int modidx) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tsgt1.Modify(1, 1, n, dfn[top[u]], dfn[u], modidx);\n\t\tif (son[u]) sgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u] + 1, 0);\n\t\telse sgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u], 0);\n\t\tu = fa[top[u]];\n\t}\n\tif (dfn[u] > dfn[v]) swap(u, v);\n\tsgt1.Modify(1, 1, n, dfn[u], dfn[v], modidx);\n\tif (top[u] == u) {\n\t\tif (son[v]) sgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v] + 1, 0);\n\t\telse sgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v], 0);\n\t} else {\n\t\tif (son[v]) sgt2.Modify(1, 1, n, dfn[u], dfn[v] + 1, 0);\n\t\telse sgt2.Modify(1, 1, n, dfn[u], dfn[v], 0);\n\t}\n}\n\ninline void Modify1(int u, int v, int modidx) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tsgt2.Modify(1, 1, n, dfn[top[u]] + 1, dfn[u], 1);\n\t\ttag1[top[u]] = modidx;\n\t\tu = fa[top[u]];\n\t}\n\tif (dfn[u] > dfn[v]) swap(u, v);\n\t//if (top[u] != u) sgt2.Modify(1, 1, n, dfn[u], dfn[v], 1);\n\t//else {\n\t\tsgt2.Modify(1, 1, n, dfn[u] + 1, dfn[v], 1);\n\t//\ttag1[u] = modidx;\n\t//}\n}\n\ninline int Query(int u, int v) {\n\tint ans = 0;\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tans += sgt2.Query(1, 1, n, dfn[top[u]] + 1, dfn[u]);\n\t\tint t0 = max(sgt1.Query(1, 1, n, dfn[top[u]]), sgt1.Query(1, 1, n, dfn[fa[top[u]]]));\n\t\tint t1 = tag1[top[u]];\n\t\tif (t1 > t0) ans++;\n\t\tu = fa[top[u]];\n\t}\n\t//printf(\"u=%d v=%d ans=%d\\n\", u, v, ans);\n\tif (dfn[u] > dfn[v]) swap(u, v);\n\tans += sgt2.Query(1, 1, n, dfn[u] + 1, dfn[v]);\n\treturn ans;\n}\n\ninline void Solve() {\n\tfor (int i = 1;i <= q;i++) {\n\t\tint opt = qread(), u = qread(), v = qread();\n\t\tif (opt == 1) {\n\t\t\tModify0(u, v, 2 * i - 1);\n\t\t\tModify1(u, v, 2 * i);\n\t\t} else printf(\"%d\\n\", Query(u, v));\n\t}\n}\n\nint main() {\n\tint t = qread();\n\twhile (t--) {\n\t\tClear();\n\t\tRead();\n\t\tdep[1] = 1;\n\t\tDfs1(1);\n\t\tDfs2(1, 1);\n\t\t//for (int i = 1;i <= n;i++) printf(\"%d \", dfn[i]); puts(\"\");\n\t\tSolve();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1627304461,
        "uid": 61088,
        "name": "Solystic",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 P7735 \u3010[NOI2021] \u8f7b\u91cd\u8fb9\u3011"
    },
    {
        "content": "[P7735 [NOI2021] \u8f7b\u91cd\u8fb9](https://www.luogu.com.cn/problem/P7735)\n### \u9898\u610f\n\u4e00\u9897\u6709 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u8fb9\u5206\u6210\u8f7b\u8fb9\u548c\u91cd\u8fb9\u3002\u5f00\u59cb\u65f6\u6240\u6709\u8fb9\u90fd\u4e3a\u8f7b\u8fb9\u3002\u7136\u540e\u5bf9\u6811\u8fdb\u884c $m$ \u6b21\u64cd\u4f5c\uff1a\n\n\u64cd\u4f5c $1$\uff1a\u8f93\u5165 $a$\u3001$b$\uff0c\u5bf9\u8def\u5f84 $(a,b)$ \u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9 $x$\uff0c\u5c06\u4e0e $x$ \u76f8\u8fde\u7684\u6240\u6709\u8fb9\u53d8\u6210\u8f7b\u8fb9\uff1b\u7136\u540e\u518d\u5c06\u8def\u5f84 $(a,b)$ \u4e0a\u7684\u6240\u6709\u8fb9\u53d8\u6210\u91cd\u8fb9\u3002\n\n\u64cd\u4f5c $2$\uff1a\u8f93\u5165 $a$\u3001$b$\uff0c\u6c42\u8def\u5f84 $(a,b)$ \u4e0a\u91cd\u8fb9\u7684\u6570\u91cf\u3002\n\n\u672c\u9898\u4e3a\u591a\u7ec4\u6570\u636e\uff0c\u7ec4\u6570\u4e3a $T$\u3002\n\n###### \u6570\u636e\u8303\u56f4\uff1a\n$T \\leq 3,1\\leq n,m\\leq 10^5$\uff0c\u4fdd\u8bc1\u8f93\u5165\u64cd\u4f5c\u65f6 $a\\neq b$\u3002\n\n###### \u5173\u952e\u8bcd\uff1a\u6811\u94fe\u5256\u5206\uff0c\u6700\u8fd1\u516c\u5171\u7956\u5148 LCA\n\n------------\n### \u89e3\u9898\u601d\u8def\n##### 30\u5206\uff1a$1\\leq n,m\\leq 5000$\uff0c\u65e0\u7279\u6b8a\u6027\u8d28\u3002\n\u5bf9\u4e8e $30$ \u5206\u7684\u6570\u636e\uff0c\u53ef\u4ee5\u76f4\u63a5\u5bf9\u9898\u76ee\u4e2d\u7684\u64cd\u4f5c\u8fdb\u884c\u6a21\u62df\u3002\u82e5\u64cd\u4f5c\u6570\u4e3a $1$\uff0c\u5148\u6c42\u51fa\u70b9 $a$ \u548c $b$ \u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 $L$\uff0c\u7136\u540e\u5206\u522b\u628a\u8def\u5f84 $(a,L)$ \u548c $(b,L)$ \u4e0a\u6240\u6709\u70b9\u8fde\u63a5\u7684\u8fb9\u6807\u8bb0\u4e3a\u8f7b\u8fb9\uff0c\u518d\u628a\u4e24\u6761\u8def\u5f84\u4e0a\u7684\u8fb9\u6807\u8bb0\u4e3a\u91cd\u8fb9\u3002\n\n\u6807\u8bb0\u53ef\u4ee5\u76f4\u63a5\u8bb0\u5f55\u5728\u8fb9\u4e0a\uff0c\u4e5f\u53ef\u4ee5\u628a $1$ \u53f7\u70b9\u4f5c\u4e3a\u6839\uff0c\u5c06\u6574\u68f5\u6811\u53d8\u6210\u6709\u6839\u6811\uff0c\u7136\u540e\u5c06\u6807\u8bb0\u8bb0\u5f55\u5728\u6df1\u5ea6\u8f83\u6df1\u7684\u8282\u70b9\u4e0a\u3002\n\n\u67e5\u8be2\u65f6\uff0c\u540c\u6837\u5148\u6c42\u51fa\u70b9 $a$ \u548c $b$ \u7684\u6700\u8fd1\u516c\u5171\u7956\u5148 $L$\uff0c\u7136\u540e\u7edf\u8ba1\u8def\u5f84 $(a,L)$ \u548c $(b,L)$ \u4e0a\u7684\u91cd\u8fb9\u6570\u5373\u53ef\u3002\n\n\u8fd9\u79cd\u6a21\u62df\u7b97\u6cd5\uff0c\u5bf9\u6bcf\u4e00\u6b21\u64cd\u4f5c\uff0c\u90fd\u9700\u8981 $O(n)$ \u7684\u65f6\u95f4\u8fdb\u884c\u4fee\u6539/\u67e5\u8be2\uff0c\u56e0\u6b64\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(Tmn)$\u3002\n\n##### 50\u5206\uff1a$1\\leq n,m \\leq10^5$\uff0c\u6811\u7684\u5f62\u6001\u662f\u4e00\u6761\u94fe\u3002\n\u5bf9\u4e8e\u8fd9\u4e2a\u8303\u56f4\u7684\u90e8\u5206\u5206\uff0c\u53ef\u4ee5\u53d1\u73b0\u6240\u6709\u64cd\u4f5c\u5176\u5b9e\u662f\u5728\u5e8f\u5217\u4e0a\u8fdb\u884c\u7684\uff0c\u5177\u4f53\u5730\u8bf4\u5c31\u662f\u5e8f\u5217\u4e0a\u7684\u533a\u95f4\u4fee\u6539\u548c\u533a\u95f4\u67e5\u8be2\u3002\u65e2\u7136\u5982\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5f88\u8f7b\u677e\u5730\u4f7f\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u6bcf\u4e00\u4e2a\u70b9\u4e0a\u7684\u6807\u8bb0\uff0c\u7136\u540e\u5728\u8be2\u95ee\u65f6\u67e5\u8be2\u533a\u95f4\u548c\u5373\u53ef\u3002\n\n\u6709\u4e00\u70b9\u9700\u8981\u6ce8\u610f\uff0c\u5c31\u662f\u5728\u66f4\u65b0\u6807\u8bb0\u65f6\uff0c\u56e0\u4e3a\u9700\u8981\u5c06\u8def\u5f84 $(a,b)$ \u4e24\u4fa7\u7684\u8fb9\u8bbe\u7f6e\u4e3a\u8f7b\u8fb9\uff0c\u6240\u4ee5\u5e94\u8be5\u5148\u66f4\u65b0\u8f7b\u8fb9\u6807\u8bb0\uff0c\u518d\u66f4\u65b0\u91cd\u8fb9\u6807\u8bb0\u3002\n\n\u5bf9\u6bcf\u4e00\u6b21\u64cd\u4f5c\uff0c\u7ebf\u6bb5\u6811\u4e0a\u7684\u66f4\u65b0\u6216\u67e5\u8be2\u90fd\u9700\u8981 $O(\\log n)$ \u7684\u65f6\u95f4\uff0c\u56e0\u6b64\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(Tm\\log n)$\u3002\n\n##### 100\u5206\uff1a$1\\leq n,m \\leq10^5$\uff0c\u65e0\u7279\u6b8a\u6027\u8d28\u3002\n\u65e2\u7136\u4e00\u6761\u94fe\u4e0a\u7684\u4fe1\u606f\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\uff0c\u90a3\u6211\u4eec\u662f\u5426\u53ef\u4ee5\u5bf9\u6811\u8fdb\u884c\u6811\u94fe\u5256\u5206\uff0c\u4ece\u800c\u7ef4\u62a4\u6811\u4e0a\u7684\u4fe1\u606f\u5462\uff1f\n\n\u7b54\u6848\u662f\u80af\u5b9a\u7684\uff0c\u4f46\u662f\u5e76\u4e0d\u80fd\u76f4\u63a5\u5957\u7528\u4e4b\u524d\u7684\u7ebf\u6bb5\u6811\u7684\u66f4\u65b0\u65b9\u6cd5\u3002\n\n\u7531\u4e8e\u6bcf\u6b21\u66f4\u65b0\u9700\u8981\u5c06\u4e0e\u8def\u5f84 $(a,b)$ \u76f8\u90bb\u7684\u8fb9\u53d8\u4e3a\u8f7b\u8fb9\uff0c\u800c\u8fdb\u884c\u6811\u94fe\u5256\u5206\u540e\u7ebf\u6bb5\u6811\u53ea\u80fd\u6709\u6548\u7ef4\u62a4\u94fe\u4e0a\u7684\u4fe1\u606f\uff0c\u56e0\u6b64\u6bcf\u6b21\u6539\u53d8\u6240\u6709\u8fb9\u7684\u6807\u8bb0\u662f\u4e0d\u73b0\u5b9e\u7684\u3002\u6211\u4eec\u9700\u8981\u5c3d\u91cf\u505a\u5230\u6bcf\u6b21\u64cd\u4f5c\u53ea\u7ef4\u62a4\u8def\u5f84\u4e0a\u7684\u4fe1\u606f\u3002\n\n\u4e4b\u524d\u63d0\u5230\u53ef\u4ee5\u628a\u8fb9\u7684\u6807\u8bb0\u8f6c\u79fb\u5230\u70b9\u4e0a\u3002\u90a3\u6211\u4eec\u8003\u8651\u662f\u5426\u53ef\u4ee5\u53ea\u6807\u8bb0\u70b9\uff0c\u901a\u8fc7\u70b9\u4e0a\u7684\u4fe1\u606f\u6765\u8ba1\u7b97\u7b54\u6848\u3002\u8981\u5b9e\u73b0\u8fd9\u6837\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u5f55\u7684\u662f\u6bcf\u4e2a\u70b9\u88ab\u4fee\u6539\u7684\u65f6\u95f4\u6233\u3002\u5982\u679c\u4e00\u6761\u8fb9\u662f\u91cd\u8fb9\uff0c\u90a3\u5b83\u7684\u4e24\u4e2a\u7aef\u70b9\u5fc5\u987b\u540c\u4e00\u6b21\u88ab\u4fee\u6539\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e24\u4e2a\u7aef\u70b9\u7684\u65f6\u95f4\u6233\u76f8\u540c\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u9700\u8981\u7edf\u8ba1\u7684\u5c31\u662f\u8def\u5f84\u4e0a\u6781\u957f\u7684\u8fde\u7eed\u65f6\u95f4\u6233\u7684\u6bb5\u6570 $cnt$\u3002\u7b54\u6848\u5c31\u662f\u8def\u5f84\u957f\u5ea6\u51cf\u53bb $(cnt-1)$\u3002\n\n\u7531\u4e8e\u9700\u8981\u7edf\u8ba1\u8def\u5f84\u4e2d\u8fde\u7eed\u65f6\u95f4\u6233\u7684\u6bb5\u6570\uff0c\u6211\u4eec\u9700\u8981\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u6bb5\u6570 $cnt$\uff0c\u5de6\u7aef\u70b9\u7684\u65f6\u95f4\u6233 $ltm$ \u548c\u53f3\u7aef\u70b9\u7684\u65f6\u95f4\u6233 $rtm$\uff08\u7528\u4e8e\u533a\u95f4\u5408\u5e76\u65f6\u5224\u65ad\u662f\u5426\u91cd\u590d\u8ba1\u7b97\uff09\u3002\u540c\u65f6\uff0c\u4f7f\u7528\u61d2\u6807\u8bb0 $tag$ \u6765\u8bb0\u5f55\u4e00\u4e2a\u533a\u95f4\u5185\u5168\u90e8\u76f8\u540c\u7684\u65f6\u95f4\u6233\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u64cd\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u5728\u8ba1\u7b97\u70b9 $a$ \u548c\u70b9 $b$ \u6700\u8fd1\u516c\u5171\u7956\u5148\u7684\u540c\u65f6\u8fdb\u884c\u7ef4\u62a4\u548c\u67e5\u8be2\u64cd\u4f5c\u3002\n\n\u6bcf\u6b21\u64cd\u4f5c\u65f6\uff0c\u4f7f\u7528\u6811\u94fe\u5256\u5206\u8ba1\u7b97\u6700\u8fd1\u516c\u5171\u7956\u5148\u9700\u8981 $O(\\log n)$ \u7684\u65f6\u95f4\uff0c\u540c\u65f6\u5728\u7ebf\u6bb5\u6811\u4e0a\u8fdb\u884c\u7ef4\u62a4/\u67e5\u8be2\u53c8\u9700\u8981 $O(\\log n)$ \u7684\u65f6\u95f4\uff0c\u56e0\u6b64\u4e00\u6b21\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(\\log^2 n)$\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(Tm\\log^2 n)$\u3002\n\n\u7531\u4e8e\u672c\u9898\u5361\u5e38\uff0c\u4f7f\u7528\u8fd9\u4e2a\u65b9\u6cd5\u53ef\u80fd\u9700\u8981\u4e00\u4e9b\u901f\u5ea6\u4e0a\u7684\u4f18\u5316\u624d\u53ef\u4ee5\u901a\u8fc7\u3002\n\n[\u5b8c\u6574\u4ee3\u7801](https://www.luogu.com.cn/paste/b7hcnf50)\n\n\n\n",
        "postTime": 1627461197,
        "uid": 362761,
        "name": "Mr_HY43205",
        "ccfLevel": 6,
        "title": "P7735 \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "\u7b80\u5355\u6811\u5256\u9898\u3002\n\n\u9898\u610f\u7ecf\u8fc7\u7b80\u5355\u8f6c\u6362\uff1a\n\n\u7ed9\u4e00\u68f5\u6811\uff0c\u521d\u59cb\u6240\u6709\u70b9\u989c\u8272\u5747\u4e3a $0$\u3002\n\n\u7ed9\u5b9a\u4e24\u79cd\u64cd\u4f5c\u3002\n\n\u7b2c $i$ \u6b21\u64cd\u4f5c\u4e3a\n\n1. \u5c06 $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u70b9\u989c\u8272\u8bbe\u4e3a $i$\u3002\n2. \u8be2\u95ee $u$ \u5230 $v$ \u7684\u8def\u5f84\u6709\u591a\u5c11\u6761\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u989c\u8272\u76f8\u540c\uff08\u4e0d\u80fd\u662f $0$\uff09\u3002\n\n\u5f88\u660e\u663e\u8981\u6811\u5256\u3002\u3002\u4f46\u662f\u5177\u4f53\u600e\u4e48\u641e\u5462\uff1f\n\n\u7ef4\u62a4\u4e24\u4e2a\u7ebf\u6bb5\u6811\uff0c\u7b2c\u4e00\u4e2a\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u7684\u989c\u8272\u3002\n\n\u7b2c\u4e8c\u4e2a\u8981\u7ef4\u62a4\u8f7b\u91cd\u8fb9\uff0c\n\n\u4f46\u662f\u8fd9\u4e1c\u897f\u6bd4\u8f83\u5947\u602a\u3002\u6211\u4eec\u5148\u6765\u7814\u7a76\u4e00\u4e0b\u8fd9\u4e2a\u5947\u602a\u7684\u95ee\u9898\u3002\n\n\u4e00\u4e2a\u5f88 naive \u7684\u60f3\u6cd5\u662f\u628a\u8fd9\u6761\u94fe\u7528\u6811\u5256\u7ef4\u62a4\u597d\uff0c\u518d\u628a\u8fde\u5728\u94fe\u4e0a\u7684\u8fb9\u53d8\u6210\u8f7b\u7684\u3002\n\n\u4f46\u662f\u8fd9\u968f\u4fbf\u90fd\u80fd\u5361\u6389\u3002\n\n\u5047\u5982\u8bf4\u6211\u5728\u68d5\u8272\u91cd\u94fe\u4e0a\u9009\u4e00\u573a\u6bb5\uff0c\u90a3\u4e48\u6709\u5927\u91cf\u7684\u5730\u65b9\u8981\u4fee\u6539\u7b54\u6848\u3002\n\n\u8fd9\u73a9\u610f\u5728\u7ef4\u62a4\u7684\u65f6\u5019\u5f88\u96be\u5904\u7406\u3002\n\n\u6240\u4ee5\u5c31\u4e0d\u5904\u7406\uff01\n\n\u6211\u4eec\u53d1\u73b0 \n\n![](https://cdn.luogu.com.cn/upload/image_hosting/rk4550sq.png)\n\n\u5f53\u6211\u8986\u76d6\u4e00\u6761\u94fe\u7684\u65f6\u5019\uff0c\u6709\u8fd9\u4e48\u51e0\u4e2a\u5730\u65b9\u8981\u53d8\u6210\u8f7b\u7684\uff1a\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/svtrcx92.png)\n\n\uff08\u7ea2\u8272\u4e3a\u53d8\u8f7b\u7684\uff09\n\nABC \u90fd\u53ef\u4ee5\u5728\u4fee\u6539\u5bf9\u5e94\u94fe\u7684\u65f6\u5019\u4fee\u6539\uff0c\u4f46\u662f D \u5f88\u96be\u5904\u7406\uff0c\u56e0\u4e3a D \u8fd9\u6837\u7684\u4fee\u6539\u53ef\u80fd\u6709\u5f88\u591a\u3002\n\n\u6240\u4ee5\u6211\u4eec\u4e0d\u7ba1 D \u7c7b\u8fb9\uff0c\u53ea\u5728\u67e5\u8be2\u7684\u65f6\u5019\u7279\u5224\u6389\u3002\n\n\u5177\u4f53\u6765\u8bf4\u5c31\u662f\u6bcf\u6b21\u8df3\u5206\u4e24\u90e8\u5206\u8d21\u732e\uff0c\u94fe\u5185\u7684\u548c\u94fe\u95f4\u7684\uff08\u4e5f\u5c31\u662f D \u7c7b\u8fb9\uff09\u5c31\u53ef\u4ee5\u89e3\u51b3\u4e86\u3002\n\n[Code here](https://paste.ubuntu.com/p/N7tXhpw5P3/)",
        "postTime": 1627302393,
        "uid": 171487,
        "name": "cmll02",
        "ccfLevel": 8,
        "title": "mo"
    },
    {
        "content": "\u8fd9\u662f\u4e00\u4e2a\u6709\u70b9\u90aa\u6559\u7684\u4e24 $\\log$ \u505a\u6cd5\uff0c\u5e76\u4e14\u5e38\u6570\u5927\uff0c\u8fc7\u9898\u9700\u8981\u5361\u3002\n\n\u770b\u5230\u64cd\u4f5c\u548c\u9898\u76ee\u540d\u79f0\uff0c\u4e0d\u96be\u60f3\u5230\u6811\u5256\u3002\n\n\u4e0d\u59a8\u8bbe\u4ee5 $1$ \u4e3a\u6839\uff0c\u4e00\u6761\u8fb9\u7684\u8d21\u732e\u7531\u5176\u6df1\u5ea6\u8f83\u5927\u7684\u90a3\u4e2a\u7aef\u70b9\u8ba1\u7b97\u3002\u96be\u70b9\u5728\u4e8e\u5982\u4f55\u5b89\u6392 dfn \u5e8f\uff0c\u4f7f\u5f97\u4e00\u6761\u94fe\u548c\u4e0e\u4e00\u6761\u94fe\u4e0a\u7684\u70b9\u76f4\u63a5\u76f8\u8fde\u7684\u70b9\u7684 dfn \u662f\u8fde\u7eed\u7684\u3002\u91cd\u94fe\u5256\u5206\u540e\u5bf9\u4e8e\u6bcf\u6761\u91cd\u94fe\u5904\u7406 dfn \u5e8f\u3002\u8003\u8651\u628a\u5904\u7406 dfn \u5e8f\u7684 dfs \u6539\u4e3a bfs\uff0c\u7528\u961f\u5217\u8bb0\u5f55\u5f85\u5904\u7406\u91cd\u94fe\u7684\u9876\u7aef\u7ed3\u70b9\u3002\u9996\u5148\u8ba9 $1$ \u5165\u961f\uff0c\u5bf9\u4e8e\u961f\u9996 $u$\uff0c**\u9996\u5148\u4e3a $u$ \u6240\u5728\u7684\u91cd\u94fe\u5b89\u6392\u8fde\u7eed\u7684 dfn \u5e8f\uff0c\u7136\u540e\u4e3a\u8fd9\u6761\u91cd\u94fe\u4e0a\u6240\u6709\u70b9\u7684\u6240\u6709\u8f7b\u513f\u5b50\u5b89\u6392\u8fde\u7eed\u7684 dfn \u5e8f**\uff0c\u518d\u5c06\u8fd9\u6761\u91cd\u94fe\u4e0a\u6240\u6709\u70b9\u7684\u6240\u6709\u8f7b\u513f\u5b50\u5165\u961f\u3002\u53d1\u73b0\u91cd\u94fe\u9876\u7aef\u7ed3\u70b9\u7684 dfn \u5e8f\u548c\u5176\u4ed6\u7ed3\u70b9\u5e76\u4e0d\u8fde\u7eed\uff0c\u4e0d\u8fc7\u4e0d\u5f71\u54cd\u590d\u6742\u5ea6\u3002\n\n\u4e8e\u662f\u4fee\u6539\u548c\u67e5\u8be2\u7684\u65f6\u5019\u62c6\u6210\u4e24\u6761\u8def\u5f84\u5c31\u53ef\u4ee5\u8df3\u91cd\u94fe\u505a\u4e86\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u4fee\u6539\u7b2c\u4e8c\u6761\u8def\u5f84\u4f1a\u5bf9\u5f71\u54cd\u7b2c\u4e00\u6761\u7684\u4fee\u6539\uff08\u7b2c\u4e00\u6761\u8def\u5f84\u4e2d LCA \u7684\u513f\u5b50\u4ee3\u8868\u7684\u8fb9\u4f1a\u88ab\u4fee\u6539\u4e3a\u8f7b\u8fb9\uff09\uff0c\u66b4\u529b\u6539\u56de\u6765\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}(n \\log^2 n)$\uff0c\u5b9e\u73b0\u8d77\u6765\u8f83\u4e3a\u9ebb\u70e6\uff0c\u4e14\u9700\u8981\u5361\u5e38\uff08\u4f8b\u5982\u6211\u7684\u4ee3\u7801\u4e2d\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\u548c\u5355\u70b9\u4fee\u6539\u62c6\u5f00\u4e86\uff09\u3002\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define il inline\n#define re register\n#define rep(i, s, e) for (re int i = s; i <= e; ++i)\n#define drep(i, s, e) for (re int i = s; i >= e; --i)\n#define file(a) freopen(#a\".in\", \"r\", stdin), freopen(#a\".out\", \"w\", stdout)\n\nconst int N = 1000000 + 10;\n\nil int read() {\n    int x = 0; bool f = true; char c = getchar();\n    while (!isdigit(c)) {if (c == '-') f = false; c = getchar();}\n    while (isdigit(c)) x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n    return f ? x : -x;\n}\n\nint n, m;\nvector <int> e[N];\n\nint dat[N << 2], tag[N << 2];\n\n#define ls (u << 1)\n#define rs (u << 1 | 1)\n#define mid (l + r >> 1)\n\nvoid reset(int u, int l, int r) {\n    dat[u] = 0, tag[u] = -1;\n    if (l == r) return;\n    reset(ls, l, mid), reset(rs, mid + 1, r);\n}\n\nil void pushdown(int u, int l, int r) {\n    if (tag[u] == -1) return;\n    dat[ls] = tag[u] * (mid - l + 1), dat[rs] = tag[u] * (r - mid);\n    tag[ls] = tag[u], tag[rs] = tag[u], tag[u] = -1;\n}\n\nvoid modify(int ml, int mr, int k, int u, int l, int r) {\n    if (ml <= l && r <= mr) { dat[u] = k * (r - l + 1), tag[u] = k; return; }\n    pushdown(u, l, r);\n    if (ml <= mid) modify(ml, mr, k, ls, l, mid);\n    if (mr > mid) modify(ml, mr, k, rs, mid + 1, r);\n    dat[u] = dat[ls] + dat[rs];\n}\n\nvoid single_modify(int p, int k, int u, int l, int r) {\n    if (l == r) { dat[u] = tag[u] = k; return; }\n    pushdown(u, l, r);\n    if (p <= mid) single_modify(p, k, ls, l, mid);\n    else single_modify(p, k, rs, mid + 1, r);\n    dat[u] = dat[ls] + dat[rs];\n}\n\nint query(int ql, int qr, int u, int l, int r) {\n    if (ql <= l && r <= qr) return dat[u];\n    pushdown(u, l, r);\n    int res = 0;\n    if (ql <= mid) res += query(ql, qr, ls, l, mid);\n    if (qr > mid) res += query(ql, qr, rs, mid + 1, r);\n    return res;\n}\n\nint sz[N], mson[N], dep[N], fr[N];\nvoid dfs1(int u, int fa) {\n    sz[u] = 1, mson[u] = 0, fr[u] = fa;\n    for (int v : e[u]) {\n        if (v == fa) continue;\n        dep[v] = dep[u] + 1, dfs1(v, u), sz[u] += sz[v];\n        if (sz[v] > sz[mson[u]]) mson[u] = v;\n    }\n}\n\nint top[N], dfn[N], dcnt, lef[N], rig[N];\nvoid dfs2(int u, int fa, int tp) {\n    top[u] = tp;\n    if (mson[u]) dfs2(mson[u], u, tp);\n    for (int v : e[u]) {\n        if (v != fa && v != mson[u]) dfs2(v, u, v);\n    }\n}\n\nvoid make_dfn() {\n    queue <int> q;\n    q.push(1);\n    while (q.size()) {\n        int u = q.front(); q.pop();\n        for (int v = mson[u]; v; v = mson[v]) dfn[v] = ++ dcnt;\n        for (int v = u; v; v = mson[v]) {\n            lef[v] = dcnt + 1;\n            for (int w : e[v]) if (w != fr[v] && w != mson[v]) dfn[w] = ++ dcnt, q.push(w);\n            rig[v] = dcnt;\n        }\n    }\n}\n\nint LCA(int u, int v) {\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        u = fr[top[u]];\n    }\n    return (dep[u] < dep[v]) ? u : v;\n}\n\nvoid doit(int u, int lca) {\n    int v = 0;\n    while (dep[lca] < dep[top[u]]) {\n        if (mson[u]) single_modify(dfn[mson[u]], 0, 1, 1, n);\n        if (lef[top[u]] <= rig[u]) modify(lef[top[u]], rig[u], 0, 1, 1, n);\n        if (u != top[u]) modify(dfn[mson[top[u]]], dfn[u], 1, 1, 1, n);\n        if (v) single_modify(dfn[v], 1, 1, 1, n);\n        u = top[u], v = u, single_modify(dfn[u], 1, 1, 1, n), u = fr[u];\n    }\n    if (dfn[lca]) single_modify(dfn[lca], 0, 1, 1, n);\n    if (mson[u]) single_modify(dfn[mson[u]], 0, 1, 1, n);\n    if (lef[lca] <= rig[u]) modify(lef[lca], rig[u], 0, 1, 1, n);\n    if (u != lca) modify(dfn[mson[lca]], dfn[u], 1, 1, 1, n);\n    if (v) single_modify(dfn[v], 1, 1, 1, n);\n}\n\nvoid change(int u, int v) {\n    int lca = LCA(u, v);\n    if (u == lca) doit(v, u);\n    else if (v == lca) doit(u, v);\n    else {\n        doit(u, lca), doit(v, lca);\n        int w;\n        for (w = u; dep[top[w]] > dep[lca]; w = fr[top[w]]) {\n            w = top[w];\n            if (fr[w] == lca) single_modify(dfn[w], 1, 1, 1, n);\n        }\n        if (w != lca) single_modify(dfn[mson[lca]], 1, 1, 1, n);\n    }\n}\n\nint askit(int u, int lca) {\n    int res = 0;\n    while (dep[lca] < dep[top[u]]) {\n        if (u != top[u]) res += query(dfn[mson[top[u]]], dfn[u], 1, 1, n);\n        u = top[u], res += query(dfn[u], dfn[u], 1, 1, n), u = fr[u];\n    }\n    if (u != lca) res += query(dfn[mson[lca]], dfn[u], 1, 1, n);\n    return res;\n}\n\nint ask(int u, int v) {\n    int lca = LCA(u, v);\n    return askit(u, lca) + askit(v, lca);\n}\n\nint main() {\n    int tc = read();\n    while (tc --) {\n        n = read(), m = read(), dcnt = 0;\n        reset(1, 1, n);\n        rep(i, 1, n) e[i].clear();\n        rep(i, 1, n - 1) {\n            int u = read(), v = read();\n            e[u].push_back(v), e[v].push_back(u);\n        }\n        dfs1(1, 0);\n        dfs2(1, 0, 1);\n        make_dfn();\n        while (m --) {\n            int op = read(), u = read(), v = read();\n            if (op == 1) change(u, v);\n            else printf(\"%d\\n\", ask(u, v));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1627298741,
        "uid": 126582,
        "name": "Scintilla",
        "ccfLevel": 9,
        "title": "NOI2021 \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "## \u524d\u8a00\n\u591a\u6d4b\u4e0d\u6e05\u7a7a\u8c03\u4e86\u4e00\u4e2a\u5c0f\u65f6\uff0c\u7ed3\u679c\u6ca1\u65f6\u95f4\u5199 T3 \u4e86\u3002\n## \u66b4\u529b\n\u9996\u5148\u8003\u8651\u4e00\u4e2a\u66b4\u529b\uff0c\u76f4\u63a5\u5bf9\u6bcf\u4e00\u6761\u8fb9\u8fdb\u884c\u4fee\u6539\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n)$\u3002\n\n\u8003\u8651\u4e00\u79cd\u5b9e\u73b0\uff1a\u5bf9\u4e8e\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\uff0c\u5c06\u5176\u6240\u6709\u513f\u5b50\u5168\u90e8\u53d8\u6210 $0$\uff0c\u7136\u540e\u5c06\u8fd9\u4e2a\u8def\u5f84\u4e0a\u7684\u6240\u6709\u8fb9\u53d8\u4e3a $1$\u3002\n\n\u7136\u540e\u6211\u4eec\u628a\u4e00\u6761\u8def\u5f84\u7684\u6743\u503c\u6254\u5230\u5b83\u7684\u5b69\u5b50\u4e0a\uff0c\u53ef\u4ee5\u5199\u51fa\u4e00\u4e2a\u975e\u5e38\u9ad8\u6548\u7684\u66b4\u529b\u3002\n\n\u5bf9\u4e8e\u5c06 $x$ \u7684\u513f\u5b50\u53d8 $0$ \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u8003\u8651\u5728 $x$ \u4e0a\u6253 tag\uff0c\u548c\u53d8 $1$ \u7684\u64cd\u4f5c\u4e00\u8d77\u8bb0\u5f55\u65f6\u95f4\u6233\uff0c\u5373\u8fd9\u4e2a\u64cd\u4f5c\u6700\u540e\u4e00\u6b21\u88ab\u6267\u884c\u7684\u65f6\u95f4\u3002\n\n\u7136\u540e\u5728\u67e5\u8be2\u7684\u65f6\u5019\u76f4\u63a5\u5bf9\u4e8e\u6240\u6709\u8def\u5f84\u4e0a\u7684\u8fb9\uff0c\u5982\u679c\u5b83\u6700\u540e\u4e00\u6b21\u53d8\u6210 $1$ \u7684\u65f6\u95f4\u6bd4\u6700\u540e\u4e00\u6b21\u53d8\u6210 $0$ \u7684\u65f6\u95f4\u66f4\u665a\u5c31\u5c06\u7b54\u6848\u52a0 $1$\u3002\n\n\u8bbe\u64cd\u4f5c\u7684\u8def\u5f84\u603b\u957f\u4e3a $\\sum d$\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 $O(n\\log n+\\sum d)$ \u7684\u65f6\u95f4\u5185\u89e3\u51b3\u95ee\u9898\u3002\n## \u4f18\u5316\n\u6ce8\u610f\u5230\u8fd9\u4e2a\u4e1c\u897f\u4e00\u8138\u53ef\u4ee5\u5feb\u901f\u7ef4\u62a4\u7684\u6837\u5b50\uff0c\u6211\u4eec\u8003\u8651\u76f4\u63a5\u6811\u5256\u3002\n\n\u6811\u5256\u540e\uff0c\u6211\u4eec\u5bf9\u4e8e\u6240\u6709\u8f7b\u8fb9\u4ecd\u7136\u6309\u7167\u4e0a\u8ff0\u65b9\u6cd5\u7ef4\u62a4\uff0c\u7531\u4e8e\u4fee\u6539\u65f6\u95f4\u6233\u53ef\u4ee5\u5728 $O(\\log^2n)$ \u7684\u65f6\u95f4\u5185\u8fdb\u884c\uff0c\u800c\u67e5\u8be2\u65f6\u6700\u591a\u53ea\u6709 $O(\\log n)$ \u6761\u8f7b\u8fb9\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n\\log^2 n)$\u3002\n\n\u5bf9\u4e8e\u91cd\u8fb9\uff0c\u539f\u95ee\u9898\u7b49\u4ef7\u4e8e\u4e00\u6761\u94fe\u3002\u8bbe\u7b2c $[l,r]$ \u6761\u8fb9\u5728\u8def\u5f84\u4e0a\uff0c\u6211\u4eec\u76f4\u63a5\u5c06\u8fd9\u4e9b\u8fb9\u8bbe\u4e3a $1$\uff0c$l-1$ \u548c $r+1$ \u8bbe\u4e3a $0$ \u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4ecd\u7136\u662f $O(n\\log^2 n)$\u3002\n\n\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u5728 $O(Tn\\log^2n)$ \u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5185\u89e3\u51b3\u95ee\u9898\u3002\n## \u4ee3\u7801\n```cpp\n//And in that light,I find deliverance.\n#include<bits/stdc++.h>\nusing namespace std;\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();\n   return s*w;\n}\nint n,m;\nvector<int> e[100003];\nint sz[100003],fa[100003],dep[100003],son[100003],top[100003];\nint dfn[100003],inv[100003],lst[100003],tot;\ninline void dfs1(int x)\n{\n    sz[x]=1;\n    for(int y:e[x]) if(y!=fa[x])\n    {\n        if(y==fa[x])continue;\n        fa[y]=x,dep[y]=dep[x]+1,dfs1(y),sz[x]+=sz[y];\n        (sz[y]>sz[son[x]])&&(son[x]=y);\n    }\n}\ninline void dfs2(int x,int tp)\n{\n    top[x]=tp,dfn[x]=++tot,inv[tot]=x;\n    if(son[x]) dfs2(son[x],tp);\n    for(int y:e[x])\n        if(y!=son[x]&&y!=fa[x])dfs2(y,y);\n    lst[x]=tot;\n}\nint val[410003],add[100003];\ninline void update(int nl,int nr,int l,int r,int i,int v)\n{\n\tif(r<nl||nr<l) return ;\n\tif(l<=nl&&nr<=r) return (void)(val[i]=v);\n\tint mid=(nl+nr)>>1;\n\tupdate(nl,mid,l,r,i<<1,v),\n\tupdate(mid+1,nr,l,r,(i<<1)+1,v);\n\treturn ;\n}\ninline int getmax(int nl,int nr,int x,int i)\n{\n\tif(nl==nr) return val[i];\n\tint mid=(nl+nr)>>1;\n\tint v=(x<=mid)?getmax(nl,mid,x,i<<1):getmax(mid+1,nr,x,(i<<1)+1);\n\treturn max(val[i],v);\n}\nint tag[410003],sum[410003];\ninline void upd1(int nl,int nr,int l,int r,int i)\n{\n\tif(r<nl||nr<l||tag[i]) return ;\n\tif(l<=nl&&nr<=r) return (void)(tag[i]=1,sum[i]=nr-nl+1);\n\tint mid=(nl+nr)>>1;\n\tupd1(nl,mid,l,r,i<<1),upd1(mid+1,nr,l,r,(i<<1)+1),\n\tsum[i]=sum[i<<1]+sum[(i<<1)+1];\n\treturn ;\n}\ninline void upd0(int nl,int nr,int x,int i)\n{\n\tif(nl==nr) return (void)(tag[i]=0,sum[i]=0);\n\tint mid=(nl+nr)>>1;\n\t(tag[i])&&(sum[i<<1]=mid-nl+1,sum[(i<<1)+1]=nr-mid,tag[i<<1]=tag[(i<<1)+1]=1,tag[i]=0),\n\t(x<=mid?upd0(nl,mid,x,i<<1):upd0(mid+1,nr,x,(i<<1)+1)),\n\tsum[i]=sum[i<<1]+sum[(i<<1)+1];\n\treturn ;\n}\ninline int query(int nl,int nr,int l,int r,int i)\n{\n\tif(r<nl||nr<l) return 0;\n\tif(tag[i]) return min(r,nr)-max(l,nl)+1;\n\tif(l<=nl&&nr<=r) return sum[i];\n\tint mid=(nl+nr)>>1;\n\treturn query(nl,mid,l,r,i<<1)+query(mid+1,nr,l,r,(i<<1)+1);\n}\ninline int Q(int x)\n{\n\treturn add[x]>=getmax(1,n,dfn[fa[x]],1);\n}\nvoid solve()\n{\n\tmemset(val,0,sizeof(val)),\n\tmemset(add,-1,sizeof(add)),\n\tmemset(sum,0,sizeof(sum)),\n\tmemset(tag,0,sizeof(tag));\n\tn=read(),m=read(),tot=0;\n\tfor(int i=1; i<=n; ++i) e[i].clear(),son[i]=0,fa[i]=0;\n\tfor(int i=1,u,v; i<n; ++i)\t\n\t\tu=read(),v=read(),e[u].push_back(v),e[v].push_back(u);\n\tdfs1(1),dfs2(1,1);\n\tfor(int op,u,v,T=1; T<=m; ++T)\n\t{\n\t\top=read(),u=read(),v=read();\n\t\tif(op==1)\n\t\t{\n\t\t\twhile(top[u]!=top[v])\n\t\t\t{\n\t\t\t\tif(dep[top[v]]>dep[top[u]])swap(u,v);\n\t\t\t        (u!=top[u])&&(\n\t\t        \tupd1(1,n,dfn[top[u]]+1,dfn[u],1),1),\n\t\t        \t//update val 1\n\t\t        \t((int)e[u].size()>1)&&(\n\t\t        \tupd0(1,n,dfn[u]+1,1),1),\n\t\t        \t//update val 0\n\t\t        \tadd[top[u]]=T,\n\t\t        \t//update add tag\n\t\t        \tupdate(1,n,dfn[top[u]],dfn[u],1,T);\n\t\t        \t//update del tag\n\t\t        u=fa[top[u]];\n\t\t\t}\n\t\t\t\tif(dfn[u]>dfn[v]) swap(u,v);\n\t\t\t\tint x=dfn[u],y=dfn[v];\n\t\t        (u!=v)&&(upd1(1,n,x+1,y,1),1),\n\t\t        //update val 1\n\t\t        (u!=top[u])&&(\n\t\t        upd0(1,n,x,1),1),\n\t\t        ((int)e[v].size()>1)&&(\n\t\t        upd0(1,n,y+1,1),1),\n\t\t        //update val 0\n\t\t        (u==top[u])&&(add[u]=-1),\n\t\t        update(1,n,x,y,1,T);\n\t\t        //update del tag\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ans=0;\n\t\t\twhile(top[u]!=top[v])\n\t\t\t{\n\t\t        if(dep[top[v]]>dep[top[u]]) swap(u,v);\n\t\t        if(u!=top[u]) \n\t\t        \tans+=query(1,n,dfn[top[u]]+1,dfn[u],1);\n\t\t        ans+=Q(top[u]),u=fa[top[u]];\n\t\t\t}\n\t\t\tif(u!=v)\n\t\t\t{\n\t\t\t\tint x=dfn[u],y=dfn[v];\n\t\t\t\tif(x>y) swap(x,y);\n\t\t\t\tans+=query(1,n,x+1,y,1);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn ;\n}\nsigned main()\n{\n\tfor(int T=read();T--;) solve();\n\treturn 0;\n}\n```",
        "postTime": 1627297733,
        "uid": 111055,
        "name": "dead_X",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P7735"
    },
    {
        "content": "**\u5bb9\u6613** \u53d1\u73b0\uff1a\u6bcf\u6b21\u64cd\u4f5c\u67d3\u4e0a\u7684\u90a3\u4e00\u6761\u94fe\u4e0a\u7684\u70b9\uff0c\u548c\u5176\u4ed6\u65f6\u523b\u67d3\u4e0a\u7684\u90a3\u4e9b\u70b9\u7684\u8fb9\u662f\u4e0d\u7b26\u5408\u6761\u4ef6\u7684\u3002\n\n\u6240\u4ee5\u6211\u4eec\u8ba9\u6bcf\u4e2a\u70b9\u67d3\u4e0a\u4e00\u4e2a\u65f6\u95f4\u6233\uff0c\u8fd9\u6837\u539f\u95ee\u9898\u5c31\u8f6c\u5316\u6210\u4e86\u94fe\u4e0a\u7edf\u8ba1\u76f8\u90bb\u7684\u70b9\u7684\u989c\u8272\u76f8\u540c\u5bf9\u6570\u3002\u8fd9\u4e2a\u663e\u7136\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5957\u4e00\u4e2a\u6811\u94fe\u5256\u5206\u5c31\u505a\u5b8c\u4e86\u3002\uff08\u6bcf\u6b21\u8986\u76d6\u7684\u65f6\u5019\u7b54\u6848\u81ea\u7136\u662f\u6bb5\u957f\u51cf\u4e00\uff09\n\n\u7136\u540e\u662f\u4e00\u4e2a\u521d\u59cb\u7684\u95ee\u9898\u3002\u6211\u4eec\u8ba9\u6bcf\u4e2a\u70b9\u90fd\u662f\u4e0d\u540c\u989c\u8272\uff0c\u7136\u540e\u6bcf\u6b21\u67d3\u8272\u7684\u7f16\u53f7\u4ece $\\text{n}$ \u5f00\u59cb\u3002\n\n\u7801\u91cf\u8f83\u5927\uff0c\u5e38\u6570\u8f83\u5927\u3002\n\n\n```cpp\n#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i < y; i++)\n#define all(v) begin(v), end(v)\n#ifdef LOCAL\n#include \"tmp.hpp\"\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<class T>\nistream &operator>> (istream &in, vector<T> &v) {\n for (auto &x : v) {\n  in >> x;\n }\n return in;\n}\nint n, m;\nstruct Data {\n int l, r, len, tag, ans;\n Data() {\n  l = r = len = tag = ans = 0;\n }\n Data(int L, int R, int Len, int Tag, int Ans) {\n  tie(l, r, len, tag, ans) = make_tuple(L, R, Len, Tag, Ans);\n }\n};\nbool operator ==(const Data &a, const Data &b) {\n return a.l == b.l && a.r == b.r && a.len == b.len && a.tag == b.tag && a.ans == b.ans;\n}\nconst Data null = Data(-1, -1, -1, -1, -1);\nData operator +(const Data &a, const Data &b) {\n if (a == null) {\n  return b;\n } else if (b == null) {\n  return a;\n } else {\n  Data c;\n  c.ans = a.ans + b.ans;\n  c.len = a.len + b.len;\n  if (a.r == b.l) {\n   c.ans += 1;\n  }\n  c.l = a.l;\n  c.r = b.r;\n  return c;\n }\n}\nstruct segment_tree {\n void pushv(int p, int v) {\n  t[p].ans = t[p].len - 1;\n  t[p].l = t[p].r = t[p].tag = v;\n }\n void pushdown(int p) {\n  if (t[p].tag) {\n   pushv(p * 2, t[p].tag);\n   pushv(p * 2 + 1, t[p].tag);\n   t[p].tag = 0;\n  }\n }\n vector<Data> t;\n int n;\n segment_tree(const int &N) {\n  n = N;\n  t.resize(n * 4);\n  build(0, n, 1);\n }\n void build(int l, int r, int p) {\n  t[p].l = l;\n  t[p].r = r - 1;\n  t[p].len = r - l;\n  t[p].ans = 0;\n  t[p].tag = 0;\n  if (r - l == 1) {\n   return;\n  }\n  int mid = (l + r) / 2;\n  build(l, mid, p * 2);\n  build(mid, r, p * 2 + 1);\n }\n void update(int ql, int qr, int l, int r, int p, int v) { // [ql, qr)\n  if (ql <= l && r <= qr) {\n   pushv(p, v);\n   return;\n  }\n  pushdown(p);\n  int mid = (l + r) / 2;\n  if (ql < mid) {\n   update(ql, qr, l, mid, p * 2, v);\n  }\n  if (qr > mid) {\n   update(ql, qr, mid, r, p * 2 + 1, v);\n  }\n  t[p] = t[p * 2] + t[p * 2 + 1];\n }\n Data query(int ql, int qr, int l, int r, int p) { // [ql, qr)\n  if (ql <= l && r <= qr) {\n   return t[p];\n  }\n  pushdown(p);\n  int mid = (l + r) / 2;\n  if (ql < mid && qr > mid) {\n   return query(ql, qr, l, mid, p * 2) + query(ql, qr, mid, r, p * 2 + 1);\n  } else if (ql < mid) {\n   return query(ql, qr, l, mid, p * 2);\n  } else if (qr > mid) {\n   return query(ql, qr, mid, r, p * 2 + 1);\n  }\n }\n void update(int ql, int qr, int v) {\n  return update(ql, qr, 0, n, 1, v);\n }\n Data query(int ql, int qr) {\n  return query(ql, qr, 0, n, 1);\n }\n};\nvoid solve() {\n cin >> n >> m;\n vector<vector<int>> e(n);\n rep (i, 0, n - 1) {\n  int u, v;\n  cin >> u >> v;\n  --u;\n  --v;\n  e[u].emplace_back(v);\n  e[v].emplace_back(u);\n }\n vector<int> sz(n);\n vector<int> son(n, -1);\n vector<int> fa(n);\n vector<int> dep(n);\n function<void(int, int)> dfs = [&](int u, int p) {\n  sz[u] = 1;\n  for (auto v : e[u]) {\n   if (v == p) {\n    continue;\n   }\n   dep[v] = dep[u] + 1;\n   dfs(v, fa[v] = u);\n   sz[u] += sz[v];\n   if (son[u] == -1) {\n    son[u] = v;\n   } else if (sz[v] > sz[son[u]]) {\n    son[u] = v;\n   }\n  }\n };\n dfs(0, -1);\n vector<int> dfn(n);\n vector<int> top(n, -1);\n int idx = 0;\n function<void(int, int)> dfs0 = [&](int u, int t) {\n  dfn[u] = idx++;\n  top[u] = t;\n  if (son[u] != -1) {\n   dfs0(son[u], t);\n  }\n  for (auto v : e[u]) {\n   if (top[v] == -1) {\n    dfs0(v, v);\n   }\n  }\n };\n dfs0(0, 0);\n segment_tree t(n);\n auto get_lca = [&](int u, int v) {\n  while (top[u] != top[v]) {\n   if (dep[top[u]] < dep[top[v]]) {\n    swap(u, v);\n   }\n   u = fa[top[u]];\n  }\n  if (dep[u] < dep[v]) {\n   return u;\n  } else {\n   return v;\n  }\n };\n auto update_chain = [&](int u, int v, int val) {\n  while (top[u] != top[v]) {\n   if (dep[top[u]] < dep[top[v]]) {\n    swap(u, v);\n   }\n   t.update(dfn[top[u]], dfn[u] + 1, val);\n   u = fa[top[u]];\n  }\n  auto range = minmax(dfn[u], dfn[v]);\n  t.update(range.first, range.second + 1, val);\n };\n auto query_chain = [&](int u, int v) {\n  int lca = get_lca(u, v);\n  auto res0 = null;\n  while (top[u] != top[lca]) {\n   res0 = t.query(dfn[top[u]], dfn[u] + 1) + res0;\n   u = fa[top[u]];\n  }\n  res0 = t.query(dfn[lca], dfn[u] + 1) + res0;\n  auto res1 = null;\n  while (top[v] != top[lca]) {\n   res1 = t.query(dfn[top[v]], dfn[v] + 1) + res1;\n   v = fa[top[v]];\n  }\n  res1 = t.query(dfn[lca], dfn[v] + 1) + res1;\n  return res0.ans + res1.ans;\n };\n rep (i, 0, m) {\n  int op, x, y;\n  cin >> op >> x >> y;\n  --x;\n  --y;\n  if (op == 1) {\n   update_chain(x, y, i + n);\n  } else {\n   cout << query_chain(x, y) << \"\\n\";\n  }\n }\n}\nint main() {\n cin.tie(nullptr)->sync_with_stdio(false);\n int tt;\n cin >> tt;\n while (tt--) {\n  solve();\n }\n}\n```",
        "postTime": 1627462010,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "NOI 2021 D1T1"
    },
    {
        "content": "\u6ce8\uff1a\u672c\u9898\u4e3a NOI2021 D1T1\u3002\n\n## \u5206\u6790\n\n\u4fee\u6539\u64cd\u4f5c\uff08\u5373\u64cd\u4f5c 1\uff09\u4e2d\u6709\u4e09\u79cd\u8fb9\uff0c\u4e00\u79cd\u662f\u5728 $a$ \u5230 $b$ \u8def\u5f84\u4e0a\u7684\u8fb9\uff08\u8d4b\u4e3a\u9ed1\u8fb9\uff09\uff0c\u53e6\u4e00\u79cd\u662f\u4e0d\u5728 $a$ \u5230 $b$ \u8def\u5f84\u4e0a\uff0c\u4f46\u4e0e\u8be5\u8def\u5f84\u76f8\u90bb\u7684\u8fb9\uff08\u8d4b\u4e3a\u767d\u8fb9\uff09\uff0c\u8fd8\u6709\u4e00\u79cd\u662f\u4e0e\u8def\u5f84\u4e0d\u76f8\u90bb\u7684\u8fb9\uff08\u4e0d\u53d8\uff09\u3002\n\n------------\n\nP.S. \u63a5\u4e0b\u6765\u8fd9\u4e00\u6bb5\u5e76\u975e\u6b63\u89e3\uff0c\u4f46\u6216\u8bb8\u53ef\u4ee5\u4f5c\u4e3a\u4e00\u79cd\u5f15\u5165\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u7ed9\u70b9\u548c\u8fb9\u5206\u522b\u6253\u4e0a\u6807\u8bb0\uff0c\u8bb0\u5f55\u5176\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u5728 $a$ \u5230 $b$ \u8def\u5f84\u4e0a\u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u4e00\u6761\u8fb9\u662f\u9ed1\u8fb9\u5f53\u4e14\u4ec5\u5f53\uff1a\u6b64\u8fb9\u8bb0\u5f55\u7684\u65f6\u95f4\u5927\u4e8e\u7b49\u4e8e\u4e24\u4e2a\u7aef\u70b9\u8bb0\u5f55\u7684\u65f6\u95f4\u3002\u8fd9\u6837\u5c3d\u7ba1\u53ef\u4ee5\u7528\u6811\u5256\u7ef4\u62a4\uff0c\u4f46\u662f\u7531\u4e8e\u662f\u4e24\u79cd\u4fe1\u606f\uff0c\u4f3c\u4e4e\u53ea\u80fd\u4fdd\u8bc1\u4fee\u6539\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u3002\uff08\u800c\u67e5\u8be2\u4e0d\u6ee1\u8db3\u533a\u95f4\u8fde\u7eed\u6027\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u6761\u8fb9\u4e00\u6761\u8fb9\u5730\u67e5\uff09\n\n------------\n\n\u8003\u8651\u5176\u7279\u5f81\u80fd\u4e0d\u80fd\u53ea\u7528\u70b9\u7684\u4fe1\u606f\u8868\u793a\uff0c\u5c31\u4f1a\u53d1\u73b0\u4e0a\u8ff0\u8fb9\u5176\u5b9e\u5c31\u662f\u5206\u522b\u6709 2/1/0 \u4e2a\u7aef\u70b9\u5728\u7ed9\u5b9a\u8def\u5f84\u4e0a\u7684\u8fb9\u3002\n\n\u90a3\u4e48\u6211\u4eec\u5176\u5b9e\u4e0d\u9700\u8981\u8bb0\u5f55\u8fb9\u7684\u4fe1\u606f\uff0c\u76f4\u63a5\u901a\u8fc7\u70b9\u7684\u4fe1\u606f\u5c31\u53ef\u4ee5\u5224\u65ad\u2014\u2014\n\n**\u82e5\u4e00\u6761\u8fb9\u4e24\u4e2a\u7aef\u70b9\u90fd\u51fa\u73b0\u8fc7\uff08\u6307\u51fa\u73b0\u5728\u4e4b\u524d\u7684\u67d0\u6761\u8def\u5f84\u4e2d\uff09\uff0c\u90a3\u4e48\u6b64\u8fb9\u662f\u9ed1\u8fb9\u5f53\u4e14\u4ec5\u5f53\u8fd9\u4e24\u4e2a\u70b9\u6700\u540e\u4e00\u6b21\u51fa\u73b0\u7684\u65f6\u95f4\u76f8\u540c\u3002**\n\n## \u9898\u89e3\n\n\u4e3a\u4e86\u65b9\u4fbf\u89e3\u51b3\u201c\u70b9\u51fa\u73b0\u8fc7\u201d\u7684\u9650\u5236\uff0c\u6211\u4eec\u4ee4\u7b2c $k$ \u4e2a\u64cd\u4f5c\u7684\u65f6\u95f4\u4e3a $n+k$\uff0c\u521d\u59cb\u65f6 $i$ \u53f7\u70b9\u7684\u65f6\u95f4\u4e3a $i$\u3002\n\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ea\u9700\u652f\u6301\u4ee5\u4e0b\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n1. \u5c06\u4e00\u6761\u8def\u5f84\u4e0a\u7684\u70b9\u5168\u90e8\u8d4b\u6210\u67d0\u4e2a\u989c\u8272\u3002\n2. \u67e5\u8be2\u4e00\u6761\u8def\u5f84\u4e0a\u989c\u8272\u76f8\u540c\u7684\u76f8\u90bb\u5bf9\u6709\u591a\u5c11\u4e2a\u3002\n\n\uff08\u989c\u8272\u5373\u6307\u4e0a\u6587\u4e2d\u7684\u201c\u65f6\u95f4\u201d\uff09\n\n**\u6811\u5256 + \u7ebf\u6bb5\u6811**\u5373\u53ef\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5de6\u7aef\u70b9\u989c\u8272\u3001\u53f3\u7aef\u70b9\u989c\u8272\uff0c\u4ee5\u53ca\u533a\u95f4\u5185\u989c\u8272\u76f8\u540c\u7684\u76f8\u90bb\u5bf9\u7684\u6570\u91cf\u3002\u67e5\u8be2\u65f6\uff0c\u6811\u5256\u5256\u5206\u51fa\u6765\u7684\u94fe\u76f4\u63a5\u533a\u95f4\u67e5\u8be2\uff0c\u76f8\u90bb\u94fe\u4e4b\u95f4\u7684\u90e8\u5206\u7528\u5355\u70b9\u67e5\u8be2\u8fdb\u884c\u5224\u65ad\u5373\u53ef\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(Tm\\log^2{n})$\u3002\n\n## \u4ee3\u7801\n\n``` cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint n,m;\nconst int max_n=1e5+5;\nint End[max_n<<1],Last[max_n],Next[max_n<<1],e;\ninline void add_edge(int x,int y)\n{\n\tEnd[++e]=y,Next[e]=Last[x],Last[x]=e;\n\tEnd[++e]=x,Next[e]=Last[y],Last[y]=e;\n}\nint dep[max_n],sz[max_n],son[max_n],fath[max_n];\nvoid dfs1(int x,int fa)\n{\n\tdep[x]=dep[fa]+1;\n\tsz[x]=1;\n\tfath[x]=fa;\n\tfor(int i=Last[x];i;i=Next[i])\n\t{\n\t\tint y=End[i];\n\t\tif(y!=fa)\n\t\t{\n\t\t\tdfs1(y,x);\n\t\t\tif(sz[y]>sz[son[x]])\n\t\t\t\tson[x]=y;\n\t\t\tsz[x]+=sz[y];\n\t\t}\n\t}\n}\nint top[max_n],dfn[max_n],Time;\nvoid dfs2(int x,int top_now)\n{\n\ttop[x]=top_now;\n\tdfn[x]=++Time;\n\tif(son[x])\n\t\tdfs2(son[x],top_now);\n\tfor(int i=Last[x];i;i=Next[i])\n\t{\n\t\tint y=End[i];\n\t\tif(y!=son[x]&&y!=fath[x])\n\t\t\tdfs2(y,y);\n\t}\n}\nnamespace SegmentTree\n{\n\tstruct Node\n\t{\n\t\tint lc,rc,val,lazy;\n\t}node[max_n<<2],res;\n\t#define ls(p) ((p)<<1)\n\t#define rs(p) ((p)<<1|1)\n\t#define lc(p) node[p].lc\n\t#define rc(p) node[p].rc\n\t#define val(p) node[p].val\n\t#define lazy(p) node[p].lazy\n\tvoid build(int p,int l,int r)\n\t{\n\t\tlc(p)=l,rc(p)=r,val(p)=lazy(p)=0;\n\t\tif(l<r)\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tbuild(ls(p),l,mid);\n\t\t\tbuild(rs(p),mid+1,r);\n\t\t}\n\t}\n\tinline void push_up(int p)\n\t{\n\t\tlc(p)=lc(ls(p)),rc(p)=rc(rs(p));\n\t\tval(p)=val(ls(p))+val(rs(p))+(rc(ls(p))==lc(rs(p)));\n\t}\n\tinline void push_down(int p,int l,int r,int mid)\n\t{\n\t\tlc(ls(p))=rc(ls(p))=lazy(ls(p))=lc(rs(p))=rc(rs(p))=lazy(rs(p))=lazy(p);\n\t\tval(ls(p))=mid-l,val(rs(p))=r-mid-1;\n\t\tlazy(p)=0;\n\t}\n\tvoid cover(int p,int l,int r,int a,int b,int v)\n\t{\n\t\tif(a<=l&&r<=b)\n\t\t{\n\t\t\tlc(p)=rc(p)=lazy(p)=v;\n\t\t\tval(p)=r-l;\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(lazy(p))\n\t\t\tpush_down(p,l,r,mid);\n\t\tif(a<=mid)\n\t\t\tcover(ls(p),l,mid,a,b,v);\n\t\tif(b>mid)\n\t\t\tcover(rs(p),mid+1,r,a,b,v);\n\t\tpush_up(p);\n\t}\n\tvoid query(int p,int l,int r,int a,int b)\n\t{\n\t\tif(a<=l&&r<=b)\n\t\t{\n\t\t\tres.val+=val(p)+(res.rc==lc(p));\n\t\t\tres.rc=rc(p);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(lazy(p))\n\t\t\tpush_down(p,l,r,mid);\n\t\tif(a<=mid)\n\t\t\tquery(ls(p),l,mid,a,b);\n\t\tif(b>mid)\n\t\t\tquery(rs(p),mid+1,r,a,b); \n\t}\n\tinline int query(int a,int b)\n\t{\n\t\tres.rc=res.val=0;\n\t\tquery(1,1,n,a,b);\n\t\treturn res.val;\n\t}\n\tvoid query(int p,int l,int r,int k)\n\t{\n\t\tif(l==r)\n\t\t{\n\t\t\tres.lc=lc(p);\n\t\t\treturn;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(lazy(p))\n\t\t\tpush_down(p,l,r,mid);\n\t\tif(k<=mid)\n\t\t\tquery(ls(p),l,mid,k);\n\t\telse\n\t\t\tquery(rs(p),mid+1,r,k);\n\t}\n\tinline int query(int k)\n\t{\n\t\tquery(1,1,n,k);\n\t\treturn res.lc;\n\t}\n}\ninline void modify(int x,int y,int v)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tSegmentTree::cover(1,1,n,dfn[top[x]],dfn[x],v);\n\t\tx=fath[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\t\tswap(x,y);\n\tSegmentTree::cover(1,1,n,dfn[x],dfn[y],v);\n}\ninline int query(int x,int y)\n{\n\tint res=0; \n\twhile(top[x]!=top[y])\n\t{\n\t\tif(dep[top[x]]<dep[top[y]])\n\t\t\tswap(x,y);\n\t\tres+=SegmentTree::query(dfn[top[x]],dfn[x]);\n\t\tres+=SegmentTree::query(dfn[top[x]])==SegmentTree::query(dfn[fath[top[x]]]);\n\t\tx=fath[top[x]];\n\t}\n\tif(dep[x]>dep[y])\n\t\tswap(x,y);\n\tres+=SegmentTree::query(dfn[x],dfn[y]);\n\treturn res;\n}\nint main()\n{\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(int i=1;i<=n-1;++i)\n\t\t{\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tadd_edge(u,v);\n\t\t}\n\t\tdfs1(1,0),dfs2(1,1);\n\t\tSegmentTree::build(1,1,n);\n\t\tfor(int i=1;i<=m;++i) \n\t\t{\n\t\t\tint op,a,b;\n\t\t\tscanf(\"%d%d%d\",&op,&a,&b);\n\t\t\tif(op==1)\n\t\t\t\tmodify(a,b,n+i);\n\t\t\telse\n\t\t\t\tprintf(\"%d\\n\",query(a,b));\n\t\t}\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tLast[i]=son[i]=0;\n\t\te=Time=0;\n\t}\n    return 0;\n}\n```",
        "postTime": 1627364319,
        "uid": 145355,
        "name": "wsyhb",
        "ccfLevel": 0,
        "title": "\u3010\u9898\u89e3\u3011\u6d1b\u8c37 P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "\u795e\u5fc5\u4e86 114514 \u4e0b\uff0c\u7136\u540e\u5c31\u7206\u70b8\u4e86\u3002                     \n\n\u9996\u5148\u4e00\u4e2a\u6bd4\u8f83\u663e\u7136\u7684\u8f6c\u5316\u662f\u6211\u4eec\u8003\u8651\u4e00\u6761\u8fb9\u662f\u91cd\u8fb9\u5f53\u4e14\u4ec5\u5f53\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u6700\u540e\u4e00\u6b21\u6267\u884c\u64cd\u4f5c $1$ \u90fd\u5728\u540c\u4e00\u4e2a\u65f6\u95f4\uff0c\u5426\u5219\u5c31\u8bf4\u660e\u5f53\u524d\u8fd9\u4e2a\u8fb9\u4e00\u5b9a\u88ab\u7f6e\u4e3a\u4e86\u8f7b\u8fb9\uff0c\u6240\u4ee5\u6211\u4eec\u8003\u8651\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u6700\u540e\u4e00\u6b21\u505a\u64cd\u4f5c $1$ \u7684\u65f6\u95f4\u3002                  \n\n\u4ee4 $Tim_i$ \u4e3a\u7b2c $i$ \u4e2a\u70b9\u6700\u540e\u6267\u884c\u64cd\u4f5c $1$ \u7684\u65f6\u95f4\uff0c\u90a3\u4e48\u6211\u4eec\u73b0\u5728\u5c31\u662f\u6c42\u94fe\u4e0a\u6240\u6709\u9664 LCA \u4ee5\u5916\u7684\u6240\u6709 $Tim_i = Tim_{fa_i}$ \u7684\u70b9\u7684\u4e2a\u6570\u3002                      \n\n\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4\u53ef\u4ee5\u76f4\u63a5\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u6211\u4eec\u6bcf\u6b21\u5408\u5e76\u4e24\u4e2a\u5b50\u6811\u7684\u65f6\u5019\u8003\u8651\u4e00\u4e0b\u4e2d\u95f4\u4e24\u4e2a\u70b9\u662f\u5426\u8981\u591a\u4e00\u4e2a\u8d21\u732e\u5373\u53ef\uff0c\u7136\u540e\u6811\u5256\u628a\u5b83\u5256\u6210 $\\log n$ \u4e2a\u533a\u95f4\u5373\u53ef\u3002\u4f46\u65e0\u5948\u81ea\u5df1\u662f\u795e\u5fc5\u8003\u573a\u4e0a\u5c45\u7136\u6ca1\u60f3\u51fa\u6765\u8fd9\u4e48\u7ef4\u62a4\u3002                 \n\n\u521d\u59cb\u5316\u7684\u65f6\u5019\u76f4\u63a5\u628a\u6240\u6709\u70b9\u7684 $Tim_i$ \u7f6e\u4e3a $i$ \uff0c\u65f6\u95f4\u6233\u4ece $n + 1$ \u5f00\u59cb\u5c31\u597d\u4e86\u3002                 \n\n```cpp\n#include \"bits/stdc++.h\"\nusing namespace std;\nconst int Len = 1e5 + 5;\nchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<23],*O=obuf;\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ninline int rd() {\n\tint x=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n\twhile(isdigit(ch)) x=x*10+(ch^48),ch=getchar();\n\treturn x*f;\n}\nvoid print(long long x) {\n    if(x>9) print(x/10);\n    *O++=x%10+'0';\n}\n\nint n,m,cnt,head[Len],dep[Len],fa[Len],top[Len],id[Len],tot,siz[Len],son[Len],Tim,Id[Len];\nstruct node\n{\n\tint next,to;\n}edge[Len << 1];\nvoid add(int from,int to)\n{\n\tedge[++ cnt].to = to;\n\tedge[cnt].next = head[from];\n\thead[from] = cnt;\n}\nvoid dfs1(int x,int f)\n{\n\tdep[x] = dep[f] + 1;\n\tfa[x] = f;\n\tsiz[x] = 1;\n\tint maxson = -1;\n\tfor(int e = head[x] ; e ; e = edge[e].next)\n\t{\n\t\tint to = edge[e].to;\n\t\tif(to == f) continue;\n\t\tdfs1(to , x);\n\t\tsiz[x] += siz[to];\n\t\tif(siz[to] > maxson) maxson = siz[to] , son[x] = to;\n\t}\n}\nvoid dfs2(int x,int topf)\n{\n\tid[x] = ++ tot;\n\tId[tot] = x;\n\ttop[x] = topf;\n\tif(!son[x]) return;\n\tdfs2(son[x] , topf);\n\tfor(int e = head[x] ; e ; e = edge[e].next)\n\t{\n\t\tint to = edge[e].to;\n\t\tif(to == fa[x] || to == son[x]) continue;\n\t\tdfs2(to , to);\n\t}\n}\nstruct Node\n{\n\tint L,R,sum,tag;\n\tNode(){L = R = sum = tag = 0;}\n\tNode(int l,int r,int SUM,int TAG){L = l , R = r , sum = SUM , tag = TAG;}\n}ans[Len << 2];\nint ls(int x){return x << 1;}\nint rs(int x){return x << 1 | 1;}\nvoid push_up(int x)\n{\n\t//if(x == 2 || x == 4)  printf(\"%d %d %d %d %d %d\\n\",ans[ls(x)].sum,ans[rs(x)].sum,ans[ls(x)].L,ans[ls(x)].R,ans[rs(x)].L,ans[rs(x)].R);\n\tans[x].sum = ans[ls(x)].sum + ans[rs(x)].sum;\n\tif(ans[ls(x)].R == ans[rs(x)].L) ans[x].sum ++;\n\tans[x].R = ans[rs(x)].R;\n\tans[x].L = ans[ls(x)].L;\n}\nvoid push_down(int p,int l,int r)\n{\n\tif(ans[p].tag) \n\t{\n\t\tint mid = (l + r) >> 1;\n\t\tans[ls(p)].sum = mid - l , ans[rs(p)].sum = (r - mid - 1);\n\t\tans[ls(p)].tag = ans[ls(p)].L = ans[ls(p)].R = ans[rs(p)].L = ans[rs(p)].R = ans[rs(p)].tag = ans[p].tag;\n\t}\n\tans[p].tag = 0;\n}\nvoid build(int p,int l,int r)\n{\n\tans[p].sum = ans[p].tag = ans[p].L = ans[p].R = 0;\n\tif(l == r)\n\t{\n\t\tans[p].L = ans[p].R = ans[p].tag = l;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(p) , l , mid);\n\tbuild(rs(p) , mid + 1 , r);\n\tpush_up(p);\n}\nvoid update(int p,int l,int r,int nl,int nr,int w)\n{\n\t//printf(\"%d %d %d %d %d\\n\",p,l,r,nl,nr);\n\tif(nl <= l && nr >= r)\n\t{\n\t\tans[p].sum = (r - l);\n\t\tans[p].tag = ans[p].L = ans[p].R = w;\n\t\treturn;\n\t}\n\tpush_down(p , l , r);\n\tint mid = (l + r) >> 1;\n\tif(nl <= mid) update(ls(p) , l , mid , nl , nr , w);\n\tif(nr > mid) update(rs(p) , mid + 1 , r , nl , nr , w);\n\tpush_up(p);\n\t//printf(\"%d %d %d %d %d %d\\n\",p,l,r,nl,nr,ans[p].sum);\n\t//printf(\"###%d %d %d %d\\n\",p,l,r,ans[p].sum);\n\t//printf(\"###%d %d %d %d\\n\",p,Id[l],Id[r],ans[p].sum);\n}\nNode query(int p,int l,int r,int nl,int nr)\n{\n//\tprintf(\"%d %d %d %d %d\\n\",p,l,r,nl,nr);\n\tif(nl <= l && nr >= r) return ans[p];\n\tpush_down(p , l , r);\n\tint mid = (l + r) >> 1;\n\tif(nl <= mid && nr > mid) \n\t{\n\t\tNode res,Ls,Rs;\n\t\tLs = query(ls(p) , l , mid , nl , nr);\n\t\tRs = query(rs(p) , mid + 1 , r , nl , nr);\n\t\tres.sum = Ls.sum + Rs.sum;\n\t\tif(Ls.R == Rs.L) res.sum ++;\n\t\tres.L = Ls.L;\n\t\tres.R = Rs.R;\n\t\treturn res;\n\t}\n\tif(nl <= mid) return query(ls(p) , l , mid , nl , nr);\n\tif(nr > mid) return query(rs(p) , mid + 1 , r , nl , nr);\n}\nint qPoint(int p,int l,int r,int idx)\n{\n\tif(l == r) return ans[p].tag;\n\tpush_down(p , l , r);\n\tint mid = (l + r) >> 1;\n\tif(idx <= mid) return qPoint(ls(p) , l , mid , idx);\n\telse return qPoint(rs(p) , mid + 1 , r , idx);\t\n} \nvoid updRange(int x,int y,int w)\n{\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x , y);\n\t\tupdate(1 , 1 , n , id[top[x]] , id[x] , w);\n\t\tx = fa[top[x]];\n \t}\n \tif(dep[x] > dep[y]) swap(x , y);\n\tupdate(1 , 1 , n , id[x] , id[y] , w);\n}\nint LCA(int x,int y)\n{\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x , y);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x , y);\n\treturn x;\n} \nint qRange(int x,int y)\n{\n\tint res = 0 , LLCA = LCA(x , y);\n\twhile(top[x] != top[y]) \n\t{\n\t\tif(dep[top[x]] < dep[top[y]]) swap(x , y);\n\t\tint nums = query(1 , 1 , n , id[top[x]] , id[x]).sum;\n\t \t//printf(\"%d %d %d %d %d\\n\",top[x],x,id[top[x]],id[x],nums);\n\t\tres += nums;\n\t\tif(dep[top[x]] > dep[LLCA])\n\t\t{\n\t\t\tif(qPoint(1 , 1 , n , id[top[x]]) == qPoint(1 , 1 , n , id[fa[top[x]]])) res ++;\n\t\t}\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] > dep[y]) swap(x , y);int nums = query(1 , 1 , n , id[x] , id[y]).sum;\n\tres += nums;\n\t//printf(\"%d %d %d %d %d\\n\",x,y,id[x],id[y],nums);\n\treturn res;\n}\nint main()\n{\n\t//freopen(\"edge3.in\",\"r\",stdin);\n\t//freopen(\"ljNOI.out\",\"w\",stdout);\n\tint t;scanf(\"%d\",&t);\n\twhile(t --)\n\t{\n\t\tmemset(head , 0 , sizeof head);cnt = tot = 0;\n\t\tn = rd() , m = rd();Tim = n;\n\t\tfor(int i = 1 ; i <= n ; i ++) dep[i] = fa[i] = top[i] = id[i] = siz[i] = son[i] = 0;\n\t\tfor(int i = 1 ; i < n ; i ++) \n\t\t{\n\t\t\tint x,y;x = rd() , y = rd();\n\t\t\tadd(x , y) , add(y , x);\n\t\t}\n\t\tdfs1(1 , 0);\n\t\tdfs2(1 , 1);\n\t\tbuild(1 , 1 , n);\n\t\tfor(int i = 1 ; i <= m ; i ++) \n\t\t{\n\t\t\tint op,a,b;op = rd() , a = rd() , b = rd();\n\t\t\tif(op == 1) \n\t\t\t{\n\t\t\t\tTim ++;\n\t\t\t\tupdRange(a , b , Tim);\n\t\t\t}\n\t\t\telse print(qRange(a , b)) , *O ++ = '\\n';\n\t\t}\n\t}\n\tfwrite(obuf,O-obuf,1,stdout);\n\treturn 0;\n}\n```",
        "postTime": 1627298073,
        "uid": 132533,
        "name": "Hakuoro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "[\u9898\u4f20](https://www.luogu.com.cn/problem/P7735)\n\n\u6811\u5256\u4e0d\u597d\u7ef4\u62a4\u8fb9\u6743\uff0c\u8003\u8651\u4e0b\u653e\u5230\u6df1\u5ea6\u6df1\u7684\u7ed3\u70b9\u4e0a\u3002\n\n\u64cd\u4f5c\u4e00\u6539\u6210\uff1a\n\n>\u5bf9\u4e8e\u8def\u5f84 $(a, b)$ \u4e0a\u7684\u6240\u6709\u7ed3\u70b9\uff0c\u5c06\u5176\u5b50\u8282\u70b9\u67d3\u6210\u8f7b\u70b9\uff0c\u968f\u540e\u5c06\u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u67d3\u6210\u91cd\u70b9\uff0c\u7279\u522b\u5730\uff0c$\\text{LCA}(a, b)$ \u4e3a\u8f7b\u70b9\u3002\n\n\u62c6\u6210\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n3. \u8def\u5f84\u67d3\u91cd/\u8f7b\uff1b\n\n4. \u5b50\u8282\u70b9\u67d3\u8f7b\u3002\n\n\u64cd\u4f5c\u987a\u5e8f\u4e3a $3(a, b)--4(a, b) -- 3(\\text{LCA}(a, b))$\u3002\n\n\u64cd\u4f5c\u4e09\u4e00\u8138\u6811\u5256\u7684\u6837\u5b50\uff0c\u64cd\u4f5c\u56db\u3002\u3002\n\n\u6211\u4eec\u8003\u8651\u518d\u8f6c\u5316\u4e00\u4e0b\u9898\u610f\uff0c\u6211\u4eec\u53d1\u73b0\uff0c\u64cd\u4f5c 3/4 \u4e2d\u5904\u7406\u7684\u5173\u952e\u662f $\\text {LCA}$ \u4e0e \u5b50\u8282\u70b9\uff0c\u60f3\u4e00\u4e0b\uff0c\u5982\u679c\u53ea\u64cd\u4f5c\u4e00\u6b21\uff0c\u90a3\u4e48\u95ee\u9898\u53d8\u4e3a\uff1f\n\n>\u627e\u5230\u94fe\u4e0a\u6709\u591a\u5c11\u989c\u8272\u76f8\u540c\u7684\u70b9\uff01\uff011\n\n\u65e2\u7136\u4e00\u6b21\u64cd\u4f5c\u662f 0/1 \u67d3\u8272\uff0c\u4e0d\u59a8\u6539\u4e3a\u67d3 **\u65f6\u95f4\u6233** $i$ \u5230\u6bcf\u4e2a\u8282\u70b9\u4e0a\u3002\n\n\u64cd\u4f5c 1 \u53d8\u6210\u533a\u95f4\u8986\u76d6\u3002\n\n\u64cd\u4f5c 2 \u8ba9\u6211\u4eec\u7edf\u8ba1\u76f8\u90bb\u76f8\u7b49\u7684\u6570\u91cf\uff0c\u4f46\u662f $\\text{dfs}$\n \u5e8f\u4e0a\u4e0d\u4e00\u5b9a\u76f8\u90bb\uff0c\u600e\u4e48\u529e\uff1f\n \n\u4e0d\u96be\u53d1\u73b0\uff0c\u6211\u4eec\u6bcf\u6b21\u67e5\u8be2\u7684\u533a\u95f4\u4e3a $(\\text{top}(x), x)$\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u67e5\u8be2\u7684\u533a\u95f4\u6700\u5de6\u7aef\u5c31\u662f\u67d0\u9897\u5b50\u6811\u7684\u6839\u8282\u70b9\uff01\uff011\uff08\u8fd9\u5176\u5b9e\u5c31\u662f $\\text{dfs}$ \u5e8f\u7684\u6027\u8d28\uff09\u6211\u4eec\u53ea\u8981\u5728\u67e5\u8be2\u7684\u65f6\u5019\u6ce8\u610f\u987a\u5e8f\uff0c\u628a\u5bf9\u5e94\u7684\u533a\u95f4\u8fde\u4e0a\uff0c\u5c31\u73c2\u4ee5\u7edf\u8ba1\u4e2d\u95f4\u88ab\u8fde\u4e0a\u7684\u70b9\u662f\u5426\u76f8\u540c\u4e86\u3002\n\n\u6ce8\u610f\u591a\u6d4b\u6e05\u7a7a ![qq_emoji: kk](https://xn--9zr.tk/kk)\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u5361\u4e86\u597d\u4e45\u3002\n\n### Code\uff1a\n\n```cpp\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=0x3f3f3f3f;\nconst int mo=19940417;\nconst int R=20;\ninline int read(){\n\tchar ch=getchar();int x=0, f=1;\n\twhile(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nnamespace Solution{\n\tconst int N=2e5+5;\n\tint n, m;\n\tstruct node{\n\t\tnode(){st=ed=len=tag=ans=0;}\n\t\tint st, ed, len, tag, ans;\n\t}d[N*4];\n\tnode add(node a, node b){\n\t\tnode c;\n\t\tc.len=a.len+b.len;\n\t\tc.ans=a.ans+b.ans+(a.ed==b.st);\n\t\tc.st=a.st, c.ed=b.ed;\n\t\treturn c;\n\t}\n\tint tot, h[N], dfn[N], cnt, top[N], son[N], fa[N], siz[N], dep[N];\n\tstruct Edge{\n\t\tint to, nxt;\n\t}edge[N*2];\n\tvoid add(int x, int y){\n\t\tedge[++tot].to=y, edge[tot].nxt=h[x];\n\t\th[x]=tot;return ;\n\t}\n\tvoid dfs1(int x, int f){\n\t\tsiz[x]=1;\n\t\tfor(int i=h[x]; i; i=edge[i].nxt){\n\t\t\tint to=edge[i].to;if(to==f) continue;\n\t\t\tdep[to]=dep[x]+1, fa[to]=x, dfs1(to, x);\n\t\t\tsiz[x]+=siz[to];if(siz[son[x]]<siz[to]) son[x]=to;\n\t\t}\n\t\treturn ;\n\t}\n\tvoid dfs2(int x, int root){\n//\t\tprintf(\"`````%d %d\\n\", x, root);\n\t\ttop[x]=root, dfn[x]=++cnt;\n\t\tif(son[x]) dfs2(son[x], root);\n\t\tfor(int i=h[x]; i; i=edge[i].nxt){\n\t\t\tint to=edge[i].to;\n\t\t\tif(top[to]) continue;\n\t\t\tdfs2(to, to);\n\t\t}\n\t\treturn ;\n\t}\n\tstruct SegmentTree{\n\t\t#define ls k<<1\n\t\t#define rs k<<1|1\n\t\t#define mid (l+r>>1)\n\t\tvoid pushup(int k){d[k]=add(d[ls], d[rs]);return ;}\n\t\tvoid upd(int k, int v){\n\t\t\td[k].ans=d[k].len-1, d[k].st=d[k].ed=v;\n\t\t\td[k].tag=v;return ;\n\t\t}\n\t\tvoid pushdown(int k){\n\t\t\tif(!d[k].tag) return ;\n\t\t\tupd(ls, d[k].tag), upd(rs, d[k].tag);\n\t\t\td[k].tag=0;\n\t\t\treturn ;\n\t\t}\n\t\tvoid build(int k, int l, int r){\n\t\t\td[k].len=r-l+1, d[k].tag=d[k].ans=0;\n\t\t\tif(l==r){d[k].st=d[k].ed=l&r;return ;}\n\t\t\tbuild(ls, l, mid), build(rs, mid+1, r);\n\t\t\treturn pushup(k);\n\t\t}\n\t\tvoid change(int k, int l, int r, int x, int y, int v){\n\t\t\tif(x<=l&&r<=y) return upd(k, v);pushdown(k);\n\t\t\tif(x<=mid) change(ls, l, mid, x, y, v);\n\t\t\tif(mid<y) change(rs, mid+1, r, x, y, v);\n\t\t\treturn pushup(k);\n\t\t}\n\t\tnode query(int k, int l, int r, int x, int y){\n//\t\t\tprintf(\"%d %d %d %d %d\\n\", k, l, r, x, y);\n\t\t\tif(x<=l&&r<=y) return d[k];pushdown(k);\n\t\t\tif(y<=mid) return query(ls, l, mid, x, y);\n\t\t\tif(x>mid) return query(rs, mid+1, r, x, y);\n\t\t\treturn add(query(ls, l, mid, x, y), query(rs, mid+1, r, x, y));\n\t\t}\n\t\t#undef ls\n\t\t#undef rs\n\t\t#undef mid\n\t}Chtholly;\n\tvoid change(int x, int y, int v){\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x, y);\n\t\t\tChtholly.change(1, 1, n, dfn[top[x]], dfn[x], v);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(dep[x]>dep[y]) swap(x, y);\n\t\tChtholly.change(1, 1, n, dfn[x], dfn[y], v);\n\t\treturn ;\n\t}\n\tint LCA(int x, int y){\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x, y);\n//\t\t\tprintf(\">>>%d %d\\n\", x, y);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn dep[x]>dep[y]?y:x;\n\t}\n\tint query(int x, int f){\n\t\tnode ret;\n\t\twhile(top[x]!=top[f]){\n\t\t\tret=add(Chtholly.query(1, 1, n, dfn[top[x]], dfn[x]), ret);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\treturn add(Chtholly.query(1, 1, n, dfn[f], dfn[x]), ret).ans;\n\t}\n\tint ask(int x, int y){\n\t\tint lca=LCA(x, y);//printf(\"----%d\\n\", lca);\n\t\treturn query(x, lca)+query(y, lca);\n\t}\n\tsigned work(){\n\t\tmemset(h, 0, sizeof(h)), tot=cnt=0;\n\t\tmemset(fa, 0, sizeof(fa));\n\t\tmemset(son, 0, sizeof(son));\n\t\tmemset(top, 0, sizeof(top));\n\t\tmemset(dep, 0, sizeof(dep));\n\t\tmemset(dfn, 0, sizeof(dfn));\n\t\tmemset(siz, 0, sizeof(siz));\n\t\tn=read(), m=read();\n\t\tfor(int i=1, a, b; i<n; i++)\n\t\t\ta=read(), b=read(), add(a, b), add(b, a);\n\t\tdfs1(dep[1]=1, 0), dfs2(1, 1);\n\t\tChtholly.build(1, 1, n);//Chtholly.debug();\n//\t\tfor(int i=1; i<=n; i++)\n//\t\t\tprintf(\"->%d %d\\n\", dep[i], fa[i]); \n\t\tfor(int i=1; i<=m; i++){\n\t\t\tint opt=read(), x=read(), y=read();\n\t\t\tif(opt&1) change(x, y, i+n);\n\t\t\telse printf(\"%d\\n\", ask(x, y));\n\t\t}\n\t\treturn 0;\n\t}\n}\nsigned main(){\n\tint T=read();\n\twhile(T--)\n\t\tSolution :: work();\n\treturn 0;\n}\n\n```\n",
        "postTime": 1627376251,
        "uid": 341102,
        "name": "ReKoJ",
        "ccfLevel": 0,
        "title": "P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "## [\u8f7b\u91cd\u8fb9](https://www.luogu.com.cn/problem/P7735)\n\n\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u4efb\u610f\u65f6\u523b\u4e00\u5b9a\u662f\u5728\u6811\u4e0a\u6709\u82e5\u5e72\u6761\u91cd\u94fe\uff0c\u662f\u56e0\u4e3a\u6bcf\u6b21\u5c06\u4e00\u6761\u94fe\u4e0a\u7684\u8fb9\u8d4b\u4e3a\u91cd\u8fb9\u65f6\u4f1a\u65ad\u5f00\u5468\u56f4\u7684\u8f7b\u8fb9\n\n\u82e5\u662f\u6211\u4eec\u53ef\u4ee5\u5feb\u901f\u5730\u627e\u5230\u4e00\u6761\u8def\u5f84\u4e0a\u6240\u6709\u7684\u91cd\u94fe\uff0c\u4fbf\u53ef\u4ee5\u5728\u5747\u644a $ O(1) $ \u7684\u65f6\u95f4\u5185\u8fdb\u884c\u94fe\u7684\u5206\u89e3\u4e0e\u201c\u63a8\u5e73\u201d\n\n\u4e0a\u9762\u7684\u8bc1\u660e\u5219\u662f\u5bf9\u4e8e\u5355\u6761\u5411\u4e0b\u7684\u94fe\uff0c\u5b83\u8981\u4e48\u662f\u5728\u4f5c\u4e3a\u63d2\u5165\u94fe\u7684\u6bb5\u70b9\u65f6\u8d21\u732e 1 \uff0c\u8981\u4e48\u662f\u5728\u88ab\u541e\u6389\u65f6\u8d21\u732e\uff0c\u800c\u6bcf\u6b21\u63d2\u5165\u81f3\u591a\u589e\u52a0 2 \u6761\u5411\u4e0b\u7684\u94fe\uff0c\u6545\u603b\u6b21\u6570\u4e3a $ O(n) $\n\n\u82e5\u662f\u6211\u4eec\u60f3\u6253 $\\tt LCT $ ,\u90a3\u4fbf\u53ef\u4ee5\u5728 $ \\log n $\u7684\u65f6\u95f4\u5185\u627e\u5230\u6bcf\u4e00\u6761\u91cd\u94fe\u6bb5\uff0c\u518d $ O(\\log n) $ \u5730\u63d2\u5165\u5230\u7edf\u8ba1\u7b54\u6848\u7684\u7ebf\u6bb5\u6811\u4e2d\uff08\u7531\u4e8e\u6bcf\u6b21\u53ea\u8be2\u95ee\u8def\u5f84\u548c\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e0d\u7528\u6811\u5256\uff0c\u800c\u7528\u62ec\u53f7\u5e8f\uff09\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $ O(n\\log n) $\n\n\u4f46\u4e0d\u7528\u8fd9\u6837\u9ebb\u70e6\n\n\u6211\u4eec\u4f7f\u7528\u6811\u5256\uff0c\u6bcf\u6761\u91cd\u94fe\u4e0a\u4f7f\u7528**\u73c2\u6735\u8389\u6811**\u7ef4\u62a4\u91cd\u94fe\u4fe1\u606f\u4ee5\u53ca\u6bcf\u4e2a\u8282\u70b9\u4f38\u51fa\u53bb\u7684\u91cd\u8fb9\u60c5\u51b5\uff0c\u6cbf\u7528\u52bf\u80fd\u5206\u6790\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$\n\n\u8003\u573a\u4e0a\u61d2\u5f97\u6253LCT,\u6240\u4ee5\u5c31\u6253\u4e86\u4e2a\u6811\u5256\uff0c\uff08\u9003\n\n\u5f53\u7136\u4f1a\u88ab\u5361\u5e38\uff0c\u52c9\u5f3a\u80fd\u8fc7\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n# define ll long long\n# define read read1<int>()\n# define Type template<typename T>\nType T read1(){\n\tT t=0;\n\tchar k;\n\tbool vis=0;\n\tdo (k=getchar())=='-'&&(vis=1);while('0'>k||k>'9');\n\twhile('0'<=k&&k<='9')t=(t<<3)+(t<<1)+(k^'0'),k=getchar();\n\treturn vis?-t:t;\n}\n# define fre(k) freopen(k\".in\",\"r\",stdin);freopen(k\".out\",\"w\",stdout)\n# define ll long long\nint s,son[100005],sz[100005],top[100005],f[100005],h[100005],dfn[100005],m,rk[100005];\nint va[400005];bool mark[400005];\nvector<int>G[100005];\nvoid dfs(int n,int fa){\n\tsz[n]=1;f[n]=fa;h[n]=h[fa]+1;son[n]=0;\n\tfor(int i:G[n])\n\t\tif(i!=fa){\n\t\t\tdfs(i,n);\n\t\t\tif(sz[i]>=sz[son[n]])son[n]=i;\n\t\t\tsz[n]+=sz[i];\n\t\t}\n}void dfs1(int n,int tp){\n\ttop[n]=tp;rk[dfn[n]=++*dfn]=n;\n\tif(son[n])dfs1(son[n],tp);\n\tfor(int i:G[n])\n\t\tif(i!=f[n]&&i!=son[n])\n\t\t\tdfs1(i,i);\n}set<pair<int,int> >se[100005],to[100005];\nvoid recover(int w,int l,int r,int d){\n\tif(l==r){va[d]=0;return;}\n\tint mid=l+r>>1;\n\tif(mark[d]){\n\t\tmark[d<<1]=mark[d<<1|1]=1;\n\t\tva[d<<1]=mid-l+1;va[d<<1|1]=r-mid;\n\t\tmark[d]=0;\n\t}if(w<=mid)recover(w,l,mid,d<<1);\n\telse recover(w,mid+1,r,d<<1|1);\n\tva[d]=va[d<<1]+va[d<<1|1];\n}\nvoid cover(int l,int r,int tl,int tr,int d){\n\tif(l>r)return;\n\tif(l==tl&&r==tr){\n\t\tva[d]=r-l+1;mark[d]=1;\n\t\treturn;\n\t}\n\tint mid=tl+tr>>1;\n\tif(mark[d])return;\n\tif(r<=mid)cover(l,r,tl,mid,d<<1);\n\telse if(mid<l)cover(l,r,mid+1,tr,d<<1|1);\n\telse cover(l,mid,tl,mid,d<<1),cover(mid+1,r,mid+1,tr,d<<1|1);\n\tva[d]=va[d<<1]+va[d<<1|1];\n}\nint query(int l,int r,int tl,int tr,int d){\n\tif(l>r)return 0;\n\tif(l==tl&&r==tr)return va[d];\n\tint mid=tl+tr>>1;\n\tif(mark[d])return r-l+1;\n\tif(r<=mid)return query(l,r,tl,mid,d<<1);\n\tif(mid<l)return query(l,r,mid+1,tr,d<<1|1);\n\treturn query(l,mid,tl,mid,d<<1)+query(mid+1,r,mid+1,tr,d<<1|1);\n}\nvoid cover(int l,int r){\n\tint tl=top[l],tr=top[r];\n\tvector<pair<int,int> >ins,ins2;\n\twhile(tl!=tr){\n\t\tif(h[tl]<h[tr])swap(l,r),swap(tl,tr);\n\t\tauto i=to[tl].begin();\n\t\twhile(i!=to[tl].end()&&i->first<=dfn[l]){\n\t\t\trecover(max(i->first,i->second),1,s,1);\n\t\t\tto[tl].erase(i);i=to[tl].begin();\n\t\t}auto j=se[tl].begin();\n\t\twhile(j!=se[tl].end()&&j->first<=dfn[l]){\n\t\t\tif(j->second>dfn[l]){\n\t\t\t\trecover(dfn[l]+1,1,s,1);\n\t\t\t\tif(dfn[l]+1<j->second){\n\t\t\t\t\tauto w=make_pair(dfn[l]+1,j->second);\n\t\t\t\t\tse[tl].erase(j);\n\t\t\t\t\tse[tl].insert(w);\n\t\t\t\t}else se[tl].erase(j);\n\t\t\t}else se[tl].erase(j);\n\t\t\tj=se[tl].begin();\n\t\t}\n\t\tins.push_back(make_pair(tl,f[tl]));\n\t\tins2.push_back(make_pair(dfn[tl],dfn[l]));\n\t\ttl=top[l=f[tl]];\n\t}\n\tif(h[l]<h[r])swap(l,r);\n\tauto i=to[tl].lower_bound(make_pair(dfn[r],0));\n\twhile(i!=to[tl].end()&&i->first<=dfn[l]){\n\t\trecover(max(i->first,i->second),1,s,1);\n\t\tto[tl].erase(i);i=to[tl].lower_bound(make_pair(dfn[r],0));\n\t}\n\tauto j=se[tl].lower_bound(make_pair(dfn[r],0));if(j!=se[tl].begin())--j;\n\twhile(j!=se[tl].end()&&j->first<=dfn[l]){\n\t\tif(j->second<dfn[r]){++j;continue;}\n\t\tif(j->first<dfn[r]){\n\t\t\trecover(dfn[r],1,s,1);\n\t\t\tif(j->first<dfn[r]-1)\n\t\t\t\tse[tl].insert(make_pair(j->first,dfn[r]-1));\n\t\t}if(j->second>dfn[l]){\n\t\t\trecover(dfn[l]+1,1,s,1);\n\t\t\tif(dfn[l]+1<j->second)\n\t\t\t\tse[tl].insert(make_pair(dfn[l]+1,j->second));\n\t\t}se[tl].erase(j);\n\t\tj=se[tl].lower_bound(make_pair(dfn[r],0));\n\t}\n\tcover(dfn[r]+1,dfn[l],1,s,1);\n\tif(l!=r)se[tl].insert(make_pair(dfn[r],dfn[l]));\n\tfor(auto i:ins){\n\t\tto[i.first].insert(make_pair(dfn[i.first],dfn[i.second]));\n\t\tto[top[i.second]].insert(make_pair(dfn[i.second],dfn[i.first]));\n\t}for(auto i:ins2){\n\t\tcover(i.first,i.second,1,s,1);\n\t\tse[rk[i.first]].insert(i);\n\t}\n}\nint query(int l,int r){\n\tint tl=top[l],tr=top[r],t=0;\n\twhile(tl!=tr){\n\t\tif(h[tl]<h[tr])swap(l,r),swap(tl,tr);\n\t\tt+=query(dfn[tl],dfn[l],1,s,1);\n\t\ttl=top[l=f[tl]];\n\t}if(l==r)return t;\n\tif(h[l]<h[r])swap(l,r);\n\treturn query(dfn[r]+1,dfn[l],1,s,1)+t;\n}\nint main(){\n\t//fre(\"edge\");\n\tfor(int T=read;T--;){\n\t\ts=read;m=read;\n\t\tfor(int i=1;i<=s;++i)G[i].clear(),se[i].clear(),to[i].clear();\n\t\tmemset(mark,0,s+1<<2);\n\t\tmemset(va,0,s+1<<4);\n\t\tfor(int i=1;i<s;++i){\n\t\t\tint u=read,v=read;\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}dfs(1,0);dfs1(1,1);*dfn=0;\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tint opt=read,l=read,r=read;\n\t\t\tif(opt&1)cover(l,r);\n\t\t\telse printf(\"%d\\n\",query(l,r));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1627355043,
        "uid": 108067,
        "name": "\u4e1b\u96e8",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P7735 [NOI2021] \u8f7b\u91cd\u8fb9"
    },
    {
        "content": "\u8003\u8651\u8fd9\u6837\u4e00\u4e2a\u8f6c\u5316\uff1a\n\n\u5bf9\u4e8e\u6bcf\u6b21\u4fee\u6539\u64cd\u4f5c\uff0c\u5c06 $x \\rightarrow y$ \u8def\u5f84\u4e0a\u7684\u6240\u6709\u70b9\u7684\u989c\u8272\u67d3\u6210\u4e00\u79cd\u65b0\u989c\u8272\uff08\u5047\u8bbe\u521d\u59cb\u65f6\u6240\u6709\u70b9\u989c\u8272\u4e24\u4e24\u4e0d\u540c\uff09\uff0c\u90a3\u4e48\u5728\u67d0\u4e00\u4e2a\u65f6\u523b\uff0c\u4e24\u7aef\u7684\u70b9\u989c\u8272\u76f8\u540c\u7684\u8fb9\u5c31\u662f\u4e00\u6761\u91cd\u8fb9\u3002\n\n\u5bf9\u539f\u6811\u8fdb\u884c\u91cd\u94fe\u5256\u5206\u5e76\u7ef4\u62a4\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u6bcf\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9\u7ef4\u62a4\u5f53\u524d\u533a\u95f4\u6700\u5de6\u8fb9\u70b9\u548c\u6700\u53f3\u8fb9\u70b9\u7684\u989c\u8272\uff0c\u4ee5\u53ca\u533a\u95f4\u5185\u6709\u591a\u5c11\u5bf9\u76f8\u90bb\u4e14\u989c\u8272\u76f8\u540c\u7684\u70b9\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u76f4\u63a5\u5c06\u94fe\u4e0a\u7684\u6240\u6709\u70b9\u8d4b\u503c\u6210\u65b0\u989c\u8272\uff0c\u53ef\u4ee5\u76f4\u63a5\u6253\u61d2\u6807\u8bb0\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee\u64cd\u4f5c\uff0c\u5728\u91cd\u94fe\u4e0a\u8df3\u7684\u540c\u65f6\u8bb0\u5f55\u4e00\u4e0b\u4e0a\u4e00\u6b21\u8bbf\u95ee\u7684\u91cd\u94fe\u7684\u9876\u7aef\u7684\u70b9\u7684\u989c\u8272\uff0c\u6765\u5224\u65ad\u8fd9\u6b21\u8df3\u5230\u7684\u91cd\u94fe\u7684\u5e95\u7aef\u70b9\u989c\u8272\u662f\u5426\u548c\u90a3\u4e2a\u91cd\u94fe\u7684\u9876\u7aef\u70b9\u989c\u8272\u76f8\u540c\uff0c\u5982\u679c\u76f8\u540c\u8ba9\u7b54\u6848+1\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$ \uff0c\u53ef\u4ee5\u901a\u8fc7",
        "postTime": 1627296819,
        "uid": 153123,
        "name": "AK_Dream",
        "ccfLevel": 9,
        "title": "[NOI2021]\u8f7b\u91cd\u8fb9"
    }
]