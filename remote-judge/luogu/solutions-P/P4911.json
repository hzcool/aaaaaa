[
    {
        "content": "\u5b8c\u6574\u7684\u9605\u8bfb\u4f53\u9a8c\u89c1 [https://blog.edgaru089.ml/index.php/oi/problem/luogu-p4911-ktx-65-solution/](https://blog.edgaru089.ml/index.php/oi/problem/luogu-p4911-ktx-65-solution/)\n\n#### \u4f5c\u4e3a\u51fa\u9898\u4eba\uff0c\u6211\u6709\u8d23\u4efb\u5199\u4e00\u7bc7\u9898\u89e3\uff08\u9003\n\n\u8fd9\u9898\u7684\u521d\u8877\u5c31\u662f\u4e00\u4e2a\u5e9e\u5927\u7684\u5927\u6a21\u62df\uff0c\u521a\u521a\u89c1\u5230\u672a\u6765\u7a0b\u5e8f\u6539\u8fd9\u9053\u9898\u6709\u7740\u4e00\u79cd\u81ea\u7136\u7684\u719f\u6089\u611f\u5462\uff08\u7b11\uff09\n\n\u4f46\u662f\u4e0d\u50cf\u90a3\u9053\u9898\uff0c\u8fd9\u9053\u9898\u6ca1\u6709\u4ec0\u4e48\u8bed\u4e49\u6811\u4e4b\u7c7b\u7684\u9ad8\u6df1\u7684\u4e1c\u897f\u5462\uff0c\u53ea\u6709\u5bf9\u4ee3\u7801\u80fd\u529b\u7684\u8003\u5bdf\uff0c\u50cf\u6211\u8fd9\u79cd\u521d\u4e2d\u4e09\u5e74\u8352\u5e9f\u5728\u641e\u9879\u76ee\u7684\u4eba\uff0c\u4ee3\u7801\u529f\u5e95\u8fd8\u53ef\u4ee5\u8bf4\u662f\u5341\u5206\u624e\u5b9e\u7684\u5462\uff08\u7b11\uff09\n\n#### \u5173\u5fc3\u4e00\u4e0b\u6ce8\u91ca\u7684\u683c\u5f0f\uff1a\n\n\u6ce8\u91ca\u662f\u53ef\u4ee5\u5d4c\u5957\u7684\uff0c\u50cf ```[[] putchar 65; ]``` \u8fd9\u6837\u7684\u6839\u672c\u4e0d\u4f1a\u6709\u4ec0\u4e48\u8f93\u51fa\u5462\n\n\u6807\u7a0b\u4e2d\uff0c\u6211\u662f\u7528std::function\u5b58\u4e0b\u6bcf\u4e00\u4e2a\u6307\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7136\u540e\u89e3\u91ca\u8c03\u7528\n\n\u7b2c\u4e00\u6b65\uff0c\u5148\u628a\u7a0b\u5e8f\u5206\u62c6\u6210tokens\uff0c\u53bb\u6389\u6ce8\u91ca\uff0c\u8bb0\u5f55\u884c\u53f7\u548cfunction\u5b9a\u4e49\u4f4d\u7f6e\uff0c\u66ff\u6362\u4e3aset\u6307\u4ee4\n\u7b2c\u4e8c\u6b65\uff0c\u628atokens\u8f6c\u6362\u6210\u6307\u4ee4\u548c\u6570\u636e\u6e90\uff0c\u540c\u65f6\u66ff\u6362callfunc\u4e3acall\u6307\u4ee4\n\n\u6700\u540e\u522b\u5fd8\u4e86\uff0ccall\u548cret\u65f6\u6808\u4e2d\u8981\u538b\u5165\u8c03\u7528\u5904\u6307\u4ee4\u5730\u5740\u548c\u5f53\u524d\u7684%line\u5bc4\u5b58\u5668\u7684\u503c\u8fd9\u4e24\u4e2a\u503c\u5462\n\n\u4ee5\u4e0b\u662f\u6807\u7a0b\uff08\u516b\u6708\u5c31\u5b9a\u7a3f\u4e86\n\n```cpp\n/* Ktx-65 Assembly Language Interpreter */\n/* Ktx-65 \u6c47\u7f16\u8bed\u8a00\u89e3\u91ca\u5668 */\n/* Copyright (c) Kawasiro Nitori & Moriya Suwano of Kappa Heavy Industries Co.,Ltd. */\n/* \u7248\u6743\u6240\u6709 \u6cb3\u7ae5\u91cd\u5de5\u4e1a\u4f1a\u793e \u6cb3\u57ce\u8377\u53d6 \u6d29\u77e2\u8bf9\u8bbf\u5b50 */\n\n/* \u7248\u672c\uff1a\u5ba1\u8bae\u7a3f */\n/* \u5e73\u6210\u4e09\u5341\u5e74 \u516b\u6708 \u5341\u4e00\u65e5 */\n\n\n#include <cstdlib>\n#include <iostream>\n#include <stack>\n#include <functional>\n#include <map>\n#include <vector>\n#include <initializer_list>\n#include <string>\n#include <fstream>\n#include <cstring>\nusing namespace std;\n\n\nbool compileErrorLevel = false;\nvoid compileError(int line, string message) {\n    // TODO Compile Error\n    cout << \"[ERROR] Interpreter encountered a Compile Error on line \" << line << endl;\n    cout << \"    Message: \" << message << endl;\n    compileErrorLevel = true;\n}\n\n#define compileAssert(line, statement, message) \\\n(!!(statement) || [](int l, string state, string m)->bool {compileError(l, \"Compile Assertation Failed: \" + m + \", Statement: \" + state); return false; }(line, #statement, message))\n\nvoid toupper(string& str) { for (char& c : str)c = toupper(c); }\nstring touppers(const string& str) { string a = str; toupper(a); return a; }\n\nclass AssemblyProgram {\npublic:\n\n    enum Command {\n        Undefined = 0,  // Undefined\n        Halt = 1,       // Stops the program\n        NoOp,           // Does nothing\n        // Memory Access\n        Set,            // Read value from <0> into <1>\n        // Streamline control\n        Jump,           // Jump to <0>(absolute line number, begins from 1)\n        JumpIf,         // Jump to <0> if <1> is not zero (takes rFlag if <1> doesn't exist)\n        Call,           // push current linenum+1 to sAddr and jump to <0>(begins from 1)\n        Return,         // jump to sAddr.top() and sAddr.pop()\n        // Arithmetic operations\n        // rVal if not exist\u2193\n        Inverse,        // <1> = -<0>\n        Add,            // <2> = <0> + <1>\n        Minus,          // <2> = <0> - <1>\n        Multiply,       // <2> = <0> * <1>\n        IntDivide,      // <2> = <0> / <1>\n        Modulo,         // <2> = <0> % <1>\n        LeftShift,      // <2> = <0> << <1>\n        RightShift,     // <2> = <0> >> <1>\n        BitAnd,         // <2> = <0> & <1>\n        BitOr,          // <2> = <0> | <1>\n        BitXor,         // <2> = <0> ^ <1>\n        // Logical Operations\n        // rFlag if not exist\u2193\n        Greater,        //  <2> = <0> > <1>\n        Less,           //  <2> = <0> < <1>\n        GreaterEqual,   //  <2> = <0> >= <1>\n        LessEqual,      //  <2> = <0> <= <1>\n        Equal,          //  <2> = <0> == <1>\n        LogicalAnd,     //  <2> = <0> && <1>\n        LogicalOr,      //  <2> = <0> || <1>\n        // Console I/O\n        //        rVal if not exist \u00a1\u00fd\n        ReadInt,        //  cin >> <0>\n        ReadChar,       // getchar(<0>)\n        WriteInt,       // cout << <0>\n        WriteChar,      // putchar(<0>)\n        // Keep at last - command count\n        CommandCount\n    };\n\n    enum VariableType {\n        Constant,\n        Pointer,\n        Memory\n    };\n\n    struct DataSource {\n        int* valptr;\n        int valconst;\n        int* valmemidptr;\n        AssemblyProgram* prog;\n        VariableType type;\n        int& operator ()() {\n            if (type == Constant)\n                return valconst;\n            else if (type == Pointer)\n                return *valptr;\n            else {\n                int id = *valmemidptr;\n                if (id >= memsize || id < 0) {\n                    prog->runtimeError(\"Memory acess out of range\");\n                    valconst = 0;\n                    return valconst;\n                }\n                return prog->mem[id];\n            }\n        }\n    };\n\n    void halt() {\n        // TODO Halt\n        running = false;\n    }\n\n    void runtimeError(string message) {\n        // TODO Runtime Error\n        cout << \"[ERROR] Interpreter encountered a Runtime Error on instruction \" << nextptr + 1 << \", clock cycle \" << clockCounter << endl;\n        cout << \"    Message: \" << message << endl;\n        running = false;\n    }\n\nprivate:\n    // Exception-Safe Wrappers\n    void pushAddr(int val) { if (sAddr.size() >= stackSize)runtimeError(\"sAddr Stack Overflow\"); sAddr.push(val); }\n    int topAddr() { if (sAddr.size() <= 0) { runtimeError(\"sAddr Access Error(size = 0)\"); return 0; } else return sAddr.top(); }\n    void popAddr() { if (sAddr.size() <= 0)runtimeError(\"sAddr Stack Underflow\"); else sAddr.pop(); }\n    int popAddrRet() { if (sAddr.size() <= 0) { runtimeError(\"sAddr Stack Underflow\"); return 0; } else { int val = sAddr.top(); sAddr.pop(); return val; } }\n    int readMem(int id) { if (id >= memsize || id < 0) { runtimeError(\"Memory Access Error(Read)\"); return 0; } else return mem[id]; }\n    void writeMem(int id, int val) { if (id >= memsize || id < 0)runtimeError(\"Memory Access Error(Write)\"); else mem[id] = val; }\n    int lineProgramId(int line) { auto i = commandLines.find(line); if (i == commandLines.end()) { runtimeError(\"Jump Line Number Invalid\"); return 0; } else return i->second; }\n\nprivate:\n    // Command Handlers\n    void funcSet(vector<DataSource>& l) { l[1]() = l[0](); nextptr++; }\n    void funcJmp(vector<DataSource>& l) { nextptr = lineProgramId(l[0]() + rLine); }\n    void funcJIf(vector<DataSource>& l) { if (l.size() <= 1) { if (rFlag)nextptr = l[0]() + lineProgramId(rLine); else nextptr++; } else { if (l[1]())nextptr = l[0]() + lineProgramId(rLine); else nextptr++; } }\n    void funcCall(vector<DataSource>& l) { pushAddr(rLine); pushAddr(nextptr + 1); nextptr = lineProgramId(l[0]()); }\n    void funcRet(vector<DataSource>& l) { if (l.size() > 0)rRet = l[0](); nextptr = popAddrRet(); rLine = popAddrRet(); }\n    void funcInv(vector<DataSource>& l) { int* p;  if (l.size() <= 1)p = &rVal; else p = &l[1](); (*p) = -l[0](); nextptr++; }\n    void funcAdd(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() + l[1](); nextptr++; }\n    void funcSub(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() - l[1](); nextptr++; }\n    void funcMult(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() * l[1](); nextptr++; }\n    void funcIDiv(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() / l[1](); nextptr++; }\n    void funcMod(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() % l[1](); nextptr++; }\n    void funcLSft(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() << l[1](); nextptr++; }\n    void funcRSft(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() >> l[1](); nextptr++; }\n    void funcBAnd(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() & l[1](); nextptr++; }\n    void funcBOr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() | l[1](); nextptr++; }\n    void funcBXor(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rVal; else p = &l[2](); (*p) = l[0]() ^ l[1](); nextptr++; }\n    void funcLGr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() > l[1](); nextptr++; }\n    void funcLLs(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() < l[1](); nextptr++; }\n    void funcLGE(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() >= l[1](); nextptr++; }\n    void funcLLE(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() <= l[1](); nextptr++; }\n    void funcLEql(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() == l[1](); nextptr++; }\n    void funcLAnd(vector<DataSource>& l) { int* p; if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() && l[1](); nextptr++; }\n    void funcLOr(vector<DataSource>& l) { int* p;  if (l.size() <= 2)p = &rFlag; else p = &l[2](); (*p) = l[0]() || l[1](); nextptr++; }\n    void funcRInt(vector<DataSource>& l) { if (l.size() <= 0)cin >> rVal; else cin >> l[0](); nextptr++; }\n    void funcRCh(vector<DataSource>& l) { if (l.size() <= 0)rVal = getchar(); else l[0]() = getchar(); nextptr++; }\n    void funcWInt(vector<DataSource>& l) { if (l.size() <= 0)cout << rVal; else cout << l[0](); nextptr++; }\n    void funcWCh(vector<DataSource>& l) { if (l.size() <= 0)putchar(rVal); else putchar(l[0]()); nextptr++; }\n\npublic:\n    void initalaize() {\n#define REGISTER_RAW(command, name) \\\ncommands[name] = command; names[command] = name\n#define REGISTER_HANDLER(command, handler, minParamCount, name)    \\\nhandlers[command] = [this](vector<DataSource>& l) {if (l.size() < minParamCount)runtimeError(\"Paramater Count Mismatch\"); else handler(l); }; \\\n/*handlers[command] = bind(&AssemblyProgram::handler, this, placeholders::_1);*/ \\\ncommands[name] = command; names[command] = name\n        REGISTER_RAW(Undefined, \"UDEF\");\n        handlers[Undefined] = [this](vector<DataSource>&) { runtimeError(\"Undefined Command Called\"); };\n        REGISTER_RAW(Halt, \"HLT\");\n        handlers[Halt] = [this](vector<DataSource>&) { halt(); };\n        REGISTER_RAW(NoOp, \"NOP\");\n        handlers[NoOp] = [this](vector<DataSource>&) {};\n        REGISTER_HANDLER(Set, funcSet, 2, \"SET\");\n        REGISTER_HANDLER(Jump, funcJmp, 1, \"JMP\");\n        REGISTER_HANDLER(JumpIf, funcJIf, 1, \"JIF\");\n        REGISTER_HANDLER(Call, funcCall, 1, \"CALL\");\n        REGISTER_HANDLER(Return, funcRet, 0, \"RET\");\n        REGISTER_HANDLER(Inverse, funcInv, 1, \"INV\");\n        REGISTER_HANDLER(Add, funcAdd, 2, \"ADD\");\n        REGISTER_HANDLER(Minus, funcSub, 2, \"SUB\");\n        REGISTER_HANDLER(Multiply, funcMult, 2, \"MULT\");\n        REGISTER_HANDLER(IntDivide, funcIDiv, 2, \"IDIV\");\n        REGISTER_HANDLER(Modulo, funcMod, 2, \"MOD\");\n        REGISTER_HANDLER(LeftShift, funcLSft, 2, \"LSFT\");\n        REGISTER_HANDLER(RightShift, funcRSft, 2, \"RSFT\");\n        REGISTER_HANDLER(BitAnd, funcBAnd, 2, \"BAND\");\n        REGISTER_HANDLER(BitOr, funcBOr, 2, \"BOR\");\n        REGISTER_HANDLER(BitXor, funcBXor, 2, \"BXOR\");\n        REGISTER_HANDLER(Greater, funcLGr, 2, \"LGR\");\n        REGISTER_HANDLER(Less, funcLLs, 2, \"LLS\");\n        REGISTER_HANDLER(GreaterEqual, funcLGE, 2, \"LGE\");\n        REGISTER_HANDLER(LessEqual, funcLLE, 2, \"LLE\");\n        REGISTER_HANDLER(Equal, funcLEql, 2, \"LEQL\");\n        REGISTER_HANDLER(LogicalAnd, funcLAnd, 2, \"LAND\");\n        REGISTER_HANDLER(LogicalOr, funcLOr, 2, \"LOR\");\n        REGISTER_HANDLER(ReadInt, funcRInt, 0, \"RINT\");\n        REGISTER_HANDLER(ReadChar, funcRCh, 0, \"RCH\");\n        REGISTER_HANDLER(WriteInt, funcWInt, 0, \"WINT\");\n        REGISTER_HANDLER(WriteChar, funcWCh, 0, \"WCH\");\n#undef REGISTER_RAW\n#undef REGISTER_HANDLER\n        program.clear();\n        nextptr = 0;\n    }\n\n    bool pushCommand(int fileline, string name, vector<DataSource> param) {\n        toupper(name);\n        auto i = commands.find(name);\n        if (i == commands.end()) {\n            compileError(fileline, \"Invaild command \\\"\" + name + \"\\\"\");\n            return false;\n        }\n        else {\n            program.push_back(make_pair(i->second, param));\n            if (commandLines.find(fileline) == commandLines.end())\n                commandLines[fileline] = program.size() - 1;\n            return true;\n        }\n    }\n\n    int* getRegister(int fileline, string name) {\n        toupper(name);\n        if (name == \"R1\")\n            return &rR1;\n        else if (name == \"R2\")\n            return &rR2;\n        else if (name == \"R3\")\n            return &rR3;\n        else if (name == \"R4\")\n            return &rR4;\n        else if (name == \"E1\")\n            return &rE1;\n        else if (name == \"E2\")\n            return &rE2;\n        else if (name == \"E3\")\n            return &rE3;\n        else if (name == \"E4\")\n            return &rE4;\n        else if (name == \"FLAG\")\n            return &rFlag;\n        else if (name == \"VAL\")\n            return &rVal;\n        else if (name == \"RET\")\n            return &rRet;\n        else if (name == \"LINE\")\n            return &rLine;\n        else {\n            compileError(fileline, \"Invaild register name \\\"\" + name + '\\\"');\n            return nullptr;\n        }\n    }\n\n    int* getMemory(int fileline, int id) {\n        if (id >= memsize || id < 0) {\n            compileError(fileline, \"Memory access statically out of range\");\n            return 0;\n        }\n        else return mem + id;\n    }\n\n    void run() {\n        rR1 = rR2 = rR3 = rR4 = rE1 = rE2 = rE3 = rE4 = rFlag = rVal = rRet = rLine = 0;\n        memset(mem, 0, sizeof(mem));\n        while (!sAddr.empty())\n            sAddr.pop();\n\n        clockCounter = 0;\n        nextptr = 0;\n        running = true;\n        while (running) {\n            if (nextptr >= program.size() || nextptr < 0)\n                runtimeError(\"Program Pointer Invaild\");\n            else\n                handlers[program[nextptr].first](program[nextptr].second);\n            clockCounter++;\n        }\n    }\n\n    int getClock() { return clockCounter; }\n\n    bool valid;\nprivate:\n\n    friend class Compiler;\n\n    int rR1, rR2, rR3, rR4;\n    int rE1, rE2, rE3, rE4;\n    int rFlag, rVal, rRet, rLine;\n    static constexpr int stackSize = 512 * 1024;\n    stack<int> /*sVal,*/ sAddr;\n\n    vector<pair<Command, vector<DataSource>>> program;\n    int nextptr;\n    static constexpr int memsize = 16 * 1024 * 1024;\n    int mem[memsize];\n\n    int clockCounter;\n    bool running;\n\n    function<void(vector<DataSource>&)> handlers[CommandCount];\n    map<int, int> commandLines;\n    map<string, Command> commands;\n    string names[CommandCount];\n};\n\n\nclass Tokenizer {\npublic:\n    enum Type {\n        Unknown,\n        Identifier,\n        Number,\n        Symbol\n    };\n\n    struct Token {\n        Type type;\n        string word;\n        int line;\n    };\n\n    static vector<Token> parse(const string& str) {\n        vector<Token> tokens;\n        Token buffer{ Unknown, \"\", 1 };\n        int commentLayers = 0;\n        int curline = 1;\n        for (char c : str) {\n            if (c == '[')\n                commentLayers++;\n            else if (c == ']') {\n                if (commentLayers > 0)\n                    commentLayers--;\n            }\n            else if (commentLayers <= 0) {\n                if (!(isblank(c) || iscntrl(c) || c == ',')) {\n                    if ((buffer.type == Number && !isdigit(c)) ||\n                        (buffer.type == Identifier && (!isalnum(c) && c != '_')) ||\n                        (buffer.type == Symbol && (isalnum(c) || c == '_' || c == '-'))) {\n                        buffer.line = curline;\n                        tokens.push_back(buffer);\n                        buffer = Token{ Unknown, \"\" };\n                    }\n                    if (buffer.type == Unknown) {\n                        // Check new object type\n                        if (isalpha(c) || c == '_')\n                            buffer.type = Identifier;\n                        else if (isdigit(c) || c == '-')\n                            buffer.type = Number;\n                        else\n                            buffer.type = Symbol;\n                    }\n                    buffer.word.push_back(c);\n                }\n                else {\n                    if (buffer.type != Unknown) {\n                        buffer.line = curline;\n                        tokens.push_back(buffer);\n                        buffer = Token{ Unknown, \"\" };\n                    }\n                }\n            }\n            if (c == '\\n')\n                curline++;\n        }\n        if (buffer.type != Unknown) {\n            buffer.line = curline;\n            tokens.push_back(buffer);\n            buffer = Token{ Unknown, \"\" };\n        }\n        return tokens;\n    }\n\n    void parseTotal(string total) {\n        tokens = parse(total);\n        nextid = 0;\n    }\n\n    void parse(istream& in) {\n        int c;\n        string str;\n        while (c = in.get()) {\n            if (in.eof())\n                break;\n            str.push_back(c);\n        }\n        parseTotal(str);\n    }\n\n    Token next() {\n        if (nextid >= tokens.size())\n            return Token{ Unknown, \"\" };\n        else\n            return tokens[nextid++];\n    }\n\n    Token offset(int offset) {\n        int id = nextid - 1 + offset;\n        if (id >= tokens.size() || id < 1)\n            return Token{ Unknown };\n        else\n            return tokens[id];\n    }\n\nprivate:\n    vector<Token> tokens;\n    int nextid;\n};\n\n/*\nBasic Syntax\nCOMMAND %Register @Address Value @%AddrAtRegister;\n*/\nclass Compiler {\npublic:\n\n    struct Command {\n        int line;\n        string command;\n        vector<Tokenizer::Token> sources;\n    };\n\n\n    void compile(Tokenizer& tokens) {\n        valid = false;\n        bool ok = true;\n        while (ok) {\n            Tokenizer::Token commt;\n            while (ok && (commt = tokens.next()).type != Tokenizer::Identifier)\n                if (commt.type == Tokenizer::Unknown)\n                    ok = false;\n            string command = commt.word;\n            vector<Tokenizer::Token> sources;\n            Tokenizer::Token cur;\n            bool pushCommand = true;\n            while (ok && (cur = tokens.next()).word != \";\") {\n                if (cur.type == Tokenizer::Unknown)\n                    ok = false;\n                //if (cur.type == Tokenizer::Identifier&&tokens.offset(-1).type != Tokenizer::Symbol)\n                //    compileError(cur.line, \"\\\";\\\" expected before a new identifier\");\n                else if (cur.type == Tokenizer::Symbol&&cur.word == \"$\"&&touppers(command) == \"FUNCTION\") {\n                    Tokenizer::Token func = tokens.next();\n                    compileAssert(func.line, func.type == Tokenizer::Identifier, \"\\\"function $\\\" not followed by a identifier as function name\");\n                    compileAssert(func.line, funcStartLines.find(func.word) == funcStartLines.end(), \"Redefinition of function \\\"\" + func.word + \"\\\"\");\n                    funcStartLines.insert(make_pair(func.word, commt.line));\n\n                    auto vec = Tokenizer::parse(\"#LINE %LINE\");\n                    for (auto& i : vec) { i.line = commt.line; }\n                    commands.push_back(Command{ commt.line, \"SET\", vec });\n                    pushCommand = false;\n                }\n                sources.push_back(cur);\n            }\n            if (compileErrorLevel)\n                break;\n            if (ok&&pushCommand)\n                commands.push_back(Command{ commt.line, command, sources });\n        }\n        if (compileErrorLevel) {\n            compileErrorLevel = false;\n            valid = false;\n        }\n        else\n            valid = true;\n    }\n\n    void generateCode(AssemblyProgram& prog) {\n        if (!valid)\n            return;\n        prog.initalaize();\n        prog.valid = false;\n\n        bool ok = true;\n\n        for (auto i = commands.begin(); ok&&i != commands.end(); i++) {\n            string& command = i->command;\n            vector<AssemblyProgram::DataSource> sources;\n            bool pushCommand = true;\n\n            auto j = i->sources.begin();\n            auto nextToken = [&]()->Tokenizer::Token {\n                j++;\n                if (j == i->sources.end())\n                    return Tokenizer::Token{ Tokenizer::Unknown };\n                else\n                    return *j;\n            };\n            for (; ok&&j != i->sources.end(); nextToken()) {\n                auto& cur = *j;\n                if (cur.type == Tokenizer::Number)\n                    sources.push_back(AssemblyProgram::DataSource{ nullptr, atoi(cur.word.c_str()), nullptr, nullptr, AssemblyProgram::Constant });\n                else if (cur.type == Tokenizer::Symbol) {\n                    if (cur.word == \"%\") {\n                        Tokenizer::Token reg = nextToken();\n                        compileAssert(reg.line, reg.type == Tokenizer::Identifier, \"% not followed by identifier\");\n                        sources.push_back(AssemblyProgram::DataSource{ prog.getRegister(reg.line, reg.word), 0, nullptr, nullptr, AssemblyProgram::Pointer });\n                    }\n                    else if (cur.word == \"@\") {\n                        Tokenizer::Token val = nextToken();\n                        compileAssert(val.line, val.type == Tokenizer::Number, \"@ not followed by a number\");\n                        sources.push_back(AssemblyProgram::DataSource{ prog.getMemory(val.line, atoi(val.word.c_str())), 0, nullptr, nullptr, AssemblyProgram::Pointer });\n                    }\n                    else if (cur.word == \"@%\") {\n                        Tokenizer::Token reg = nextToken();\n                        compileAssert(reg.line, reg.type == Tokenizer::Identifier, \"@% not followed by identifier\");\n                        sources.push_back(AssemblyProgram::DataSource{ nullptr, 0, prog.getRegister(reg.line, reg.word), &prog, AssemblyProgram::Memory });\n                    }\n                    else if (cur.word == \"#\") {\n                        Tokenizer::Token def = nextToken();\n                        compileAssert(def.line, def.type == Tokenizer::Identifier, \"# not followed by identifier\");\n                        toupper(def.word);\n                        if (def.word == \"LINE\")\n                            sources.push_back(AssemblyProgram::DataSource{ nullptr, def.line, nullptr, nullptr, AssemblyProgram::Constant });\n                        else\n                            compileError(def.line, \"Compile-time constant identifier \\\"\" + def.word + \"\\\" undefined\");\n                    }\n                    else if (cur.word == \"$\") {\n                        if (command == \"callfunc\") {\n                            Tokenizer::Token func = nextToken();\n                            compileAssert(func.line, func.type == Tokenizer::Identifier, \"\\\"callfunc $\\\" not followed by a identifier as function name\");\n                            auto it = funcStartLines.find(func.word);\n                            if (it == funcStartLines.end())\n                                compileError(func.line, \"Function \\\"\" + func.word + \"\\\" undefined\");\n                            else {\n                                prog.pushCommand(i->line, \"CALL\", {\n                                    AssemblyProgram::DataSource{ nullptr, it->second, nullptr, nullptr, AssemblyProgram::Constant }\n                                                 });\n                            }\n                            pushCommand = false;\n                        }\n                        else\n                            compileError(cur.line, \"$ not preceeded by keyword \\\"function\\\" or \\\"callfunc\\\"\");\n\n                    }\n                }\n                if (compileErrorLevel)\n                    ok = false;\n            }\n            if (ok&&pushCommand)\n                prog.pushCommand(i->line, i->command, sources);\n        }\n\n        if (compileErrorLevel) {\n            compileErrorLevel = false;\n            prog.valid = false;\n        }\n        else\n            prog.valid = true;\n    }\n\nprivate:\n\n    vector<Command> commands;\n    map<string, int> funcStartLines;\n    bool valid;\n\n\n};\n\n\nAssemblyProgram prog;\nTokenizer tokens;\nCompiler compiler;\n\n\nint main(int argc, char* argv[]) {\n\n    int n;\n    cin >> n;\n\n    string str;\n    string total;\n    while (n > 0 && getline(cin, str)) {\n        if (str == \"\")\n            continue;\n        n--;\n        total += str + '\\n';\n    }\n\n    tokens.parseTotal(total);\n    compiler.compile(tokens);\n    compiler.generateCode(prog);\n    prog.run();\n\n    return 0;\n}\n```\n\n\u8bdd\u53c8\u8bf4\u56de\u6765\uff0c\u8981\u662f\u50cf\u672a\u6765\u7a0b\u5e8f\u6539\u90a3\u6837\u7684\u9898\u771f\u7684\u51fa\u73b0\u5728\u4e86\u7701\u9009\u91cc\uff0c\u53c8\u6709\u591a\u5c11\u4eba\u4f1a\u505a\u51fa\u6765\u5462\u2026\u2026\n",
        "postTime": 1538700242,
        "uid": 53151,
        "name": "\u6d29\u77e2\u8bf9\u8bbf\u5b50",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "### Mixture(224 lines, 10.00kb code, lambda function)\n\n\u4ee3\u7801\u82b1\u4e862\u5c0f\u65f6\u7f16\u5199\uff0c\u8c03\u8bd5\u603b\u5171\u6539\u4e86\u4e00\u4e2a\u6570\u7ec4\u5927\u5c0f\u3002~~\u5927\u6a21\u62df\u5199\u4e45\u4e86\u5199\u4ec0\u4e48\u90fd\u987a\u5230\u4e0d\u884c~~\n\n### \u4f7f\u7528\u77e5\u8bc6\n\n`lambda`\u51fd\u6570\uff08\u533f\u540d\u51fd\u6570\uff09\uff0c\u4e0d\u7528\u53d6\u540d\u5c31\u80fd\u7528\u7684\u51fd\u6570\uff0c\u76f4\u63a5\u653e\u5728\u4ee3\u7801\u91cc\u9762\u4f1a\u7b80\u6d01\u5f88\u591a\uff08E.g. `std::sort`\u51fd\u6570\u4e2d\u7684\u6bd4\u8f83\u51fd\u6570\uff09\n\n`functional`\u5934\u6587\u4ef6\u63d0\u4f9b\u4e86\u51fd\u6570\u50a8\u5b58\u7c7b:`std::function<[ReturnType](argc)>`\uff0c\u53ef\u4ee5\u76f4\u63a5\u5c06 lambda \u51fd\u6570\u50a8\u5b58\u3002\n\n\u4e00\u5b9a\u7684\u4ee3\u7801\u62c6\u89e3\u80fd\u529b\u3002\n\n### \u505a\u6cd5\n\n\u5c06\u64cd\u4f5c\u4e0e`lambda`\u51fd\u6570\u8fde\u63a5\u3002\u8bfb\u53d6\u6570\u636e\u5b57\u7b26\u4e32\u5e76\u7528\u7a7a\u683c\u5206\u79bb\uff0c\u540c\u65f6\u627e\u5230\u5206\u53f7\u5c06\u8bed\u53e5\u5206\u5f00\u3002\u6309\u7167\u9898\u76ee\u8981\u6c42\u6a21\u62df\u3002\n\n\u662f\u7684\u3002\u5c31\u662f\u8fd9\u4e48\u7b80\u5355 qwq \u4f46\u4f17\u6240\u5468\u77e5\u5927\u6a21\u62df\u7ec6\u8282\u8d85\u591a\uff0c\u6240\u4ee5\u2026\u2026\n\n### \u63d0\u793a\n\n\u6570\u636e\u633a\u6c34\u7684\u3002\u4e00\u884c\u4e00\u4e2a\u8bed\u53e5\uff08\u8be5\u4ee3\u7801\u5229\u7528\u4e86\u8fd9\u4e2a\u7279\u6027\uff09\u3002\u597d\u50cf\u6ca1\u6709\u6ce8\u91ca\u3002\u65f6\u9650\u5bbd\u677e\u7684\u5f88\u3002\n\n\u53d8\u91cf\u90a3\u4e00\u5757\u7740\u91cd\u8bb2\u4e00\u4e0b\u3002\n\n\u5e38\u91cf = \u6570\u5b57\uff08\u81ea\u7136\u6570\uff0c\u4e0d\u5224\u8d1f\u53f7\u80fdAC\uff09\n\n@\u56fa\u5b9a\u4f4d\u7f6e\u7684\u5185\u5b58 -> `@0`\u4e3a0\u53f7\u5185\u5b58\uff0c`@1`\u4e3a1\u53f7\u5185\u5b58\uff0c\u5185\u5b58\u8bf4\u767d\u4e86\u5c31\u662f\u6570\u7ec4\n\n%\u5bc4\u5b58\u5668\u540d\u79f0 -> \u90a312\u4e2a\u5bc4\u5b58\u5668\u554a\n\n@%\u5728\u5bc4\u5b58\u5668\u503c\u4f4d\u7f6e\u7684\u51fd\u6570 -> \u5bc4\u5b58\u5668\u91cc\u9762\u90a3\u4e2a\u503c\u53d6\u51fa\u6765\u4e4b\u540e\u53bb\u6570\u7ec4\u91cc\u770b\u770b\u8fd9\u4e2a\u7f16\u53f7\u4e0b\u7684\u503c\u662f\u4ec0\u4e48\n\n`#`\u7f16\u8bd1\u65f6\u5e38\u91cf -> \u5c31`#Line`\uff0c\u548c`%Line`\u4e00\u6837\n\n### \u5173\u4e8e\u4ee3\u7801\n\n\u4e2a\u4eba\u7f16\u7a0b\u65f6\u4e60\u60ef\u4e86\u4f7f\u7528\u5177\u4f53\u542b\u4e49\u8868\u793a\u53d8\u91cf\uff0c\u589e\u52a0\u4e86\u4ee3\u7801\u957f\u4f46\u8bfb\u7684\u975e\u5e38\u987a\u3002\u540c\u65f6\u8bf7\u4e0d\u8981\u5728\u610f`Statement`\u7c7b\u7684`argc`\u53c2\u6570\u3002\u53e6\u5916\uff0c\u8bfb\u5165\u5206\u5272`Token`\u7684\u90e8\u5206\u975e\u5e38\u7b80\u964b\uff0c\u56e0\u4e3a\u6211\u5728\u9650\u65f6(2h)\u5185\u65e0\u6cd5\u60f3\u5230\u6e05\u6670\u7684\u5206\u5272\u4ee3\u7801\u601d\u8def\u3002\n\n~~\u6253\u7b97\u56de\u5934\u6709\u65f6\u95f4\u9650\u65f6\u628a\u672a\u6765\u7a0b\u5e8f\u6539\u5207\u4e86~~\n\n### Code\n\n`{user:\"tiger2005\", lang:\"C++11\", length:\"10.00kb\", line:\"224\", timeUsed:{max:\"159ms\",min:\"111ms\",sum:\"1.43s\"}, memoryUsed:\"5.86MB\", id:\"33545912\"}`\n\n\u4ee3\u7801\u76f4\u63a5\u6302\u7740\u5f88\u4e11\uff0c\u653e\u4e2a\u526a\u8d34\u677f\u5427\u3002\n\n[Code](https://www.luogu.com.cn/paste/5utdjgt1)",
        "postTime": 1589261420,
        "uid": 60864,
        "name": "tiger2005",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u51fa\u9898\u4eba\u5728\u6bd4\u8d5b\u8fc7\u7a0b\u4e2d\u7ed9\u6211\u4eec\u7684\u89e3\u7b54\uff1a\n\n1. \u6bcf\u884c\u4e0d\u4f1a\u8d85\u8fc72000\u5b57\u7b26\n\n2. \u6bcf\u884c\u53ea\u6709\u4e00\u6761\u8bed\u53e5\n\n3. @\u5e38\u91cf\u6570 \u8868\u793a\u5728\u8fd9\u4e2a\u5e38\u91cf\u4f4d\u7f6e\u7684\u5185\u5b58\n\n4. @%\u5bc4\u5b58\u5668 \u8868\u793a\u5728\u8fd9\u4e2a\u5bc4\u5b58\u5668\u7684\u503c\u7684\u4f4d\u7f6e\u7684\u5185\u5b58\n\n5. \u4ee3\u7801\u91cc\u6ca1\u6709#LINE\uff0c\u53ea\u6709\u51fd\u6570\u8c03\u7528\uff08\u8bf4\u767d\u4e86LINE\u53ea\u662f\u7528\u6765\u89e3\u91ca\u51fd\u6570\u8c03\u7528\u673a\u5236\u7684\uff09\n\n6. \u5173\u952e\u5b57\u5168\u90fd\u662f\u5c0f\u5199\uff08\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff09\n\n7. \u51fd\u6570\u540d\u533a\u5206\u5927\u5c0f\u5199\n\n8. \u4e00\u884c\u53ea\u6709\u4e00\u6761\u6307\u4ee4\uff08\u867d\u7136\u51fa\u9898\u4eba\u7684\u6807\u7a0b\u53ef\u4ee5\u5904\u7406\u591a\u6761\n \n9. \u5185\u5b58\u4ece0\u5f00\u59cb\n\n```\nQ:\n\n\u7b97\u6570\u64cd\u4f5c\u7ed3\u679c\u5c06\u4f1a\u653e\u5165\u7b2c<\u64cd\u4f5c\u6570\u52a0\u4e00>\u4e2a\u53c2\u6570\uff0c\u5982\u679c\u4e0d\u5b58\u5728\u5219\u4f1a\u653e\u5165`%Val`\u5bc4\u5b58\u5668\u3002\n\n\u201c\u64cd\u4f5c\u6570\u52a0\u4e00\u201d \u662f\u4ec0\u4e48\u4e1c\u897f\n\n\u662f\u6307`add %r1 %r2;`\u4f1a\u8ba1\u7b97`%r1 + %r2`\u653e\u5165`%Val`\u4f46\u662f`add %r1 %r2 %r3;`\u4f1a\u8ba1\u7b97`%r1 + %r2`\u653e\u5165`%r3`\u5417\n\n\n\n\u8bf4\u7684\u5f88\u5bf9\u5462\n\u8003\u8651\u4e00\u4e0b\n\nadd %r1 %r2;\npint;\n\n\u4f1a\u8ba1\u7b97%r1\u52a0\u4e0a%r2\uff0c\u653e\u5230%val\u91cc\u7136\u540e\u8f93\u51fa\n\n\u53e6\uff1a%val\u548c%flag\u7684\u540d\u5b57\u4e5f\u4e0d\u533a\u5206\u5927\u5c0f\u5199\uff08\u6570\u636e\u91cc\u90fd\u662f\u5c0f\u5199\uff09\n```\n\n\n\n\n```\nQ:\n\nT5 \u5185\u5b58\u5177\u4f53\u662f\u6307\u4ec0\u4e48\u3002\u5982\u679c\u8f93\u51fa\u5185\u5b58\u6211\u8981\u8f93\u51fa\u4ec0\u4e48\uff1f\n\nA:\n\n\u8f93\u51fa\u547d\u4ee4\u6709\u4e24\u79cd\n\nwint\u662f\u8f93\u51fa\u8fd9\u4e2a\u6570\uff08cout<<%r1;\uff09\n\nwch\u662f\u8f93\u51fa\u8fd9\u4e2a\u5b57\u7b26\uff08putchar(%r1);\uff09\uff08\u4fdd\u8bc1\u6570\u503c\u572832~126\u4e4b\u95f4\uff09\n\n\u5185\u5b58\u672c\u8d28\u662f\u4e00\u4e2a\u6781\u5927\u7684\u6570\u7ec4\uff0c\u6211\u4eec\u5b9a\u4e49\u8fd9\u6837\u7684\u4e00\u4e2a\u6570\u7ec4\u5b58\u7684\u662f32\u4f4d\u6709\u7b26\u53f7int\n\n\uff08\u7535\u8111\u7684\u5185\u5b58\u5728\u6ca1\u6709\u88ab\u64cd\u4f5c\u7cfb\u7edf\u5206\u9875\u7ed9\u4f60\u7528\u7684\u65f6\u5019\u5c31\u662f\u8fd9\u6837\uff0c\u53ea\u4e0d\u8fc7\u5b58\u7684\u662f\u5b57\u8282byte/octet\uff09\n}\n\n```\n\n\n\u7136\u540e\uff0c\u6211\u4eec\u518d\u6765\u8c34\u8d23\u4e00\u4e0b\u51fa\u9898\u4eba\uff1a\n\n## \u6570\u636e\u6709\u9505\uff01\uff01\uff01\n\n\u5411\u51fa\u9898\u4eba\u8981\u4e86\u6570\u636e\uff0c\u53d1\u73b0\u6240\u6709\u7684`ret <0>;`\u64cd\u4f5c\u7684`<0>`\u4e2d\u7684`%`\u90fd\u7f3a\u5931\u4e86\uff0c\u7136\u540e\u6807\u7a0b\u5c31\u628a\u5b83\u5f53\u4f5c`ret;`\u5904\u7406\u4e86\u3002\n\n\u5728\u8fd9\u91cc\u62b1\u6028\u4e00\u4e0b\uff1a\u4e00\u4e2a\u56e2\u961f\u7684\u53ef\u80fd\u77e5\u9053\u6211\u4ece\u6bd4\u8d5b\u5f00\u59cb\u5c31\u5728\u809d\u8fd9\u9053\u9898\uff0c\u5230\u7b2c\u4e8c\u5929\u51cc\u666812:30\u7531\u4e8e\u8981\u51c6\u5907\u7b2c\u4e8c\u5929\u7684\u6d3b\u52a8\u6240\u4ee5\u5fc5\u987b\u7761\u89c9\u4e86\u3002\u8d77\u5e8a\u540e\u7ee7\u7eed\u809d\u5230\u665a\u4e0a\u516d\u70b9\u534a\uff08\u4e2d\u9014\u62ff\u5230\u4e86\u51fa\u9898\u4eba\u53d1\u7ed9\u6211\u7684\u6570\u636e\uff0c\u4f46\u662f\u4e00\u76f4\u628a\u6570\u636e\u5f53\u6b63\u786e\u7684\u7528\uff09\uff0c\u7136\u540e\u53d1\u73b0\u6570\u636e\u51fa\u9505\u4e86\u3002\u4e0d\u7136\u6211\u53ef\u80fd\u5c31\u4e00\u904dA\u4e86QwQ\u3002\n\n\u8bf4\u4e86\u8fd9\u4e48\u591a\uff0c\u6211\u4eec\u6765\u8bb2\u8fd9\u4e2a\u9898\uff1a\n\n\u8fd9\u662f\u4e2a\u8003\u5bdf\u8bbe\u8ba1\u6a21\u5f0f\uff08\uff1f\uff09\u7684\u9898\uff0c\u6240\u4ee5\u6284\u9898\u89e3\u88ab\u53d1\u73b0\u7684\u6982\u7387\u6781\u5927\n\n12\u4e2a\u5bc4\u5b58\u5668\u5c31\u662f12\u4e2a\u53d8\u91cf\n\n\u5185\u5b58\u5c31\u662f\u4e00\u4e2a\u5927\u6570\u7ec4\n\n\u7a0b\u5e8f\u5b58\u5728char[][]\u91cc\n\n\u8bb0\u5f55\u5f53\u524d\u884c\u53f7\n\n\u6709\u51fd\u6570\u8c03\u7528\u5c31\u538b\u6808\uff08\u6309\u7167\u6587\u6863\u6240\u8bf4\u4fbf\u53ef\uff09\n\n\u5c06\u7a0b\u5e8f\u8bfb\u5165\u7684\u65f6\u5019\u53bb\u6389\u591a\u4f59\u7684\u7a7a\u683c\n\n\u7136\u540e\u5220\u6389\u6ce8\u91ca\n\n> \u5173\u4e8e\u6ce8\u91ca\u7684\u5d4c\u5957`[[]abb]`\u5982\u4f55\u5904\u7406\uff1a\u6ca1\u6709\u8fd9\u6837\u7684\u6570\u636e\n\n\u5177\u4f53\u53c2\u8003\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n\ntypedef unsigned long long hash_t;\nconst hash_t HASH_MODE = 131;\n\nclass StringHasher {\n private:\n  bool inHash(char ch) {\n    if(ch == ';') return false;\n    if(ch == ' ') return false;\n    if(ch == '\\0') return false;\n    if(ch == '\\r') return false;\n    if(ch == '\\n') return false;\n    return true;\n  }\n public:\n  hash_t getHash(char str[]) {\n    hash_t res = 0;\n    for(char *ptr = str; inHash(*ptr); ++ptr) {\n      res = res * HASH_MODE + *ptr;\n    }\n    return res;\n  }\n};\n\nclass Calculate {\n private:\n  int *Val;\n public:\n  Calculate(int *Val) : Val(Val) {  }\n  void inv(int *a, int *b) {\n    *b = -*a;\n  }\n  void inv(int *a) {\n    *Val = -*a;\n  }\n  void add(int *a, int *b, int *c) {\n    *c = (*a + *b);\n  }\n  void add(int *a, int *b) {\n    *Val = (*a + *b);\n  }\n  ...\n};\n\nclass Logic {\n  ...\n};\n\nclass IO {\n   ...\n};\n\nclass Control {//\u63a7\u5236\u547d\u4ee4\u6bd4\u8f83\u7e41\u7410\uff0c\u91cd\u70b9\u5c55\u73b0\u4e00\u4e0b\n private:\n  int *Flag;\n  int *Line;\n  int *Ret;\n  int *sAddr;\n  int *top;\n  int *row;\n  int *column;\n public:\n  Control(int *Flag, int *Line, int *Ret, int *sAddr, int *top, int *row, int *column) : \n        Flag(Flag), Line(Line), Ret(Ret), sAddr(sAddr), top(top), row(row), column(column) {  }\n  void udef() {  }\n  void hlt() {\n    fflush(stdin);\n    exit(0);\n  }\n  void nop() {  }\n  void set(int *a, int *b) {\n    *b = *a;\n  }\n  void jmp(int *a) {\n    *row = *Line + *a;\n    *column = 0;\n  }  \n  void jif(int *a, int *b) {\n    if(*b) {\n      *row = *Line + *a;\n    } else {\n      ++*row;\n    }\n    *column = 0;\n  }\n  void jif(int *a) { \n    if(*Flag) {\n      *row = *Line + *a;\n    } else {\n      ++*row;\n    }\n    *column = 0;\n  }\n  void call(int *a) {\n    sAddr[++(*top)] = *row + 1;\n    sAddr[++(*top)] = *Line;\n    *row = *a;\n    *column = 0;\n  }\n  void ret(int *a) {\n    *Line = sAddr[(*top)--];\n    *row = sAddr[(*top)--];\n    *column = 0;\n    *Ret = *a;\n  }\n  void ret() {\n    *Line = sAddr[(*top)--];\n    *row = sAddr[(*top)--];\n    *column = 0;\n  }\n};\n\nclass ProgramManager {\n private:\n  char program[50005][2005];\n  int ram[16 * 1024 * 1024];\n  int sAddr[1024 * 1024];\n  int top;\n  int R[4];\n  int E[4];\n  int Flag;\n  int Val;\n  int Ret;\n  int Line;\n  int row;\n  int column;//\u4f60\u4f1a\u53d1\u73b0\u6211\u4ee3\u7801\u4e2d\u7684column\u59cb\u7ec8\u4fdd\u63010\u3002\u5b9e\u9645\u4e0a\u8fd9\u53ea\u662f\u6211\u61d2\u5f97\u5220\u6389\u8fd9\u4e2a\u53d8\u91cf\n  Calculate *calculate;\n  Logic *logic;\n  IO *io;\n  Control *control;\n  int maxLine;\n  void noComment() {//\u53bb\u9664\u6ce8\u91ca\n    int ignore = 0;\n    int i = 0;\n    int j = 0;\n    while(i < maxLine) {\n      if(program[i][j] == '\\0') {\n        ++i;\n        j = 0;\n        continue;\n      }\n      if(program[i][j] == '[') {\n        ++ignore;\n      }\n      if(program[i][j] == ']') {\n        program[i][j] = ' ';\n        --ignore;\n        if(ignore < 0) ignore = 0;\n      }\n      if(ignore > 0 && program[i][j] != '\\0') {\n        program[i][j] = ' ';\n      }\n      ++j;\n    }\n    for(i = 0; i < maxLine; ++i) {//\u6807\u51c6\u5316\u4ee3\u7801\n      int p = 0;\n      int j = 0;\n      while(program[i][j] != '\\0') {\n        program[i][p++] = program[i][j++];\n        if(program[i][j] == ' ' && program[i][p - 1] == ' ') --p;\n        if(p == 1 && program[i][0] == ' ') --p;\n      }\n      if(p > 0 && program[i][p - 1] == ' ') {\n        program[i][p - 1] = '\\0';\n      }\n      program[i][p] = '\\0';\n      if(program[i][0] == '\\0') {\n        sprintf(program[i], \"nop;\");\n      }\n    }\n  }\n  void setFunction() {//\u5c06function\u548ccallfunc\u53d8\u6210set\u548ccall\n    std::map<hash_t, int> func;\n    StringHasher hasher;\n    hash_t goal = hasher.getHash(\"function\");\n    for(int i = 0; i < maxLine; ++i) {\n      hash_t oper = hasher.getHash(program[i]);\n      if(oper == goal) {\n        func[hasher.getHash(&program[i][9])] = i;\n        sprintf(program[i], \"set %d %%line;\", i);\n      }\n    }\n    goal = hasher.getHash(\"callfunc\");\n    for(int i = 0; i < maxLine; ++i) {\n      hash_t oper = hasher.getHash(program[i]);\n      if(oper == goal) {\n        sprintf(program[i], \"call %d;\", func[hasher.getHash(&program[i][9])]);\n      }\n    }\n  }\n  int toNumber(char *str) {//\u5b57\u7b26\u4e32\u8f6c\u6570\u5b57\n    int ope = 1;\n    if(*str == '-') {\n      ope == -1;\n      ++str;\n    }\n    int res = 0;\n    while('0' <= *str && *str <= '9') {\n      res = res * 10 + *str - '0';\n      ++str;\n    }\n    return res * ope;\n  }\n  int *getVar(char *str, int *ori) {//\u5f97\u5230\u5b57\u7b26\u4e32\u4e2d\u53c2\u6570\u7684\u5730\u5740\n    if(str[0] == '%') {\n      if(str[1] == 'r') {\n        if(str[2] == 'e') {\n          return &Ret;\n        }\n        return R + str[2] - '1';\n      } else if(str[1] == 'e') {\n        return E + str[2] - '1';\n      } else if(str[1] == 'f') {\n        return &Flag;\n      } else if(str[1] == 'v') {\n        return &Val;\n      } else if(str[1] == 'l') {\n        return &Line;\n      }\n    } else if(str[0] == '@') {\n      if(str[1] == '%') {\n        if(str[1] == 'r') {\n          if(str[2] == 'e') {\n            return ram + Ret;\n          }\n          return ram + R[str[2] - '1'];\n        } else if(str[1] == 'e') {\n          return ram + E[str[2] - '1'];\n        } else if(str[1] == 'f') {\n          return ram + Flag;\n        } else if(str[1] == 'v') {\n          return ram + Val;\n        } else if(str[1] == 'l') {\n          return ram + Line;\n        }\n      } else {\n        return ram + toNumber(str + 1);\n      }\n    } else {\n      *ori = toNumber(str);\n      return ori;\n    }\n  }\n public:\n  ProgramManager(int maxLine) : maxLine(maxLine) {\n    memset(ram, 0, sizeof(ram));\n    memset(sAddr, 0, sizeof(sAddr));\n    top = -1;\n    memset(R, 0, sizeof(R));\n    memset(E, 0, sizeof(E));\n    Flag = 0;\n    Val = 0;\n    Ret = 0;\n    Line = 0;\n    calculate = new Calculate(&Val);\n    logic = new Logic(&Flag);\n    io = new IO(&Val);\n    control = new Control(&Flag, &Line, &Ret, sAddr, &top, &row, &column);\n  }\n  void init() {\n    for(int i = 0; i < maxLine; ++i) {//\u8bfb\u5165\u7a0b\u5e8f\n      char ch = getchar();\n      while(ch == ' ') ch = getchar();\n      int p = 0;\n      while(ch != '\\n') {\n        program[i][p++] = ch;\n        ch = getchar();\n      }\n      program[i][p] = '\\0';\n    }\n    noComment();\n    setFunction();\n  }\n  void start() {\n    static char oper[2005];\n    while(true) {\n      sscanf(&program[row][column], \"%s\", oper);\n      switch(oper[0]) {\n        case 'a': {\n          //add\n          //\u8bf7\u6ce8\u610f\u4ee5add\u4e3a\u4f8b\u7684\u8bfb\u5165\u64cd\u4f5c\u6280\u5de7\n          char A[2005];\n          char B[2005];\n          sscanf(&program[row][column], \"%*s%s%s\", A, B);\n          int tempa;\n          int tempb;\n          int *a = getVar(A, &tempa);\n          int *b = getVar(B, &tempb);\n          if(B[strlen(B) - 1] == ';') {\n            calculate->add(a, b);\n          } else {\n            sscanf(&program[row][column], \"%*s%*s%*s%s\", A);\n            int tempc;\n            int *c = getVar(A, &tempc);\n            calculate->add(a, b, c);\n          }\n          ++row;\n          column = 0;\n          break;\n        }\n        case 'b': {\n          ...\n        }\n      }\n      ...\n    }\n  }\n};\n\nint main() {\n  int lines;\n  scanf(\"%d\\n\", &lines);\n  ProgramManager &manager = *new ProgramManager(lines);//\u6211\u7684Windows\u4e0d\u8fd9\u6837\u5199\u4f1a\u70b8\u6389\n  manager.init();\n  manager.start();\n  return 0;\n}\n\n\n```\n\n\u5982\u679c\u4e0d\u63d0\u540e5\u4e2a\u70b9\u6570\u636e\u7684\u9505\u7684\u8bdd\uff0c\u5176\u5b9e\u8fd9\u9898\u51fa\u9898\u4eba\u5f88\u826f\u5fc3\u4e86\uff0c\u6570\u636e\u5f88\u6c34\u4e86\uff0c\u4f46\u662f\u5177\u4f53\u600e\u4e48\u6c34\u6211\u4e0d\u80fd\u544a\u8bc9\u4f60\u4eec\uff08\u3002\n\n\u5982\u679c\u4f60\u4eec\u771f\u7684\u5fcd\u4e0d\u4f4f\u60f3\u770b\u5b8c\u6574\u4ee3\u7801\u53ef\u4ee5\u67e5\u770b\u6211\u7684\u535a\u5ba2\uff1a\n\nhttps://vcode28629.coding.me/code/problem/luoguP4911",
        "postTime": 1538738444,
        "uid": 50165,
        "name": "VCode",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "\u76f4\u63a5\u6a21\u62df\u5373\u53ef\uff0c\u51e0\u4e4e\u6ca1\u6709\u601d\u7ef4\u96be\u5ea6\uff0c\u4f46\u7ec6\u8282\u5f88\u591a\n\n\u5176\u4e2d\u6307\u4ee4\u53c2\u6570\u53ef\u4ee5\u662f\u5e38\u6570\u3001\u5bc4\u5b58\u5668\u3001\u5185\u5b58\u503c\u53ca\u5bc4\u5b58\u5668\u5904\u5185\u5b58\u503c\uff0c\u8003\u8651\u6bcf\u6761\u6307\u4ee4\u7684\u53c2\u6570\u4f7f\u7528\u6307\u9488\u8868\u793a\u3002\n\u5982\u679c\u53c2\u6570\u4e3a\u5e38\u6570\uff0c\u5c06\u5176\u5b58\u5165\u6570\u7ec4\u5e76\u53d6\u6570\u7ec4\u8be5\u5904\u5730\u5740\uff1b\u5982\u679c\u53c2\u6570\u4e3a\u5bc4\u5b58\u5668\uff0c\u53d6\u5bc4\u5b58\u5668\u53d8\u91cf\u7684\u5730\u5740\uff1b\u5185\u5b58\u56fa\u5b9a\u4f4d\u7f6e\u5219\u53d6\u5185\u5b58\u6570\u7ec4\u5185\u76f8\u5e94\u4f4d\u7f6e\u7684\u5730\u5740\u3002\n\u6bd4\u8f83\u9ebb\u70e6\u7684\u662f\u95f4\u63a5\u5bfb\u5740(\u5373@%+\u5bc4\u5b58\u5668)\uff0c\u6b64\u65f6\u5bf9\u53c2\u6570\u6253\u4e0a\u6807\u8bb0\uff0c\u6bcf\u6b21\u6267\u884c\u5230\u8be5\u6307\u4ee4\u65f6\u6839\u636e\u6b64\u65f6\u5bf9\u5e94\u5bc4\u5b58\u5668\u7684\u503c\u66f4\u65b0\u9700\u8bbf\u95ee\u7684\u5185\u5b58\u5730\u5740\u5373\u53ef\n\n\u5904\u7406\u51fd\u6570\u65f6\uff0c\u5f53\u9047\u5230\u4e00\u4e2a\u65b0\u51fd\u6570\uff0c\u4e3a\u5176\u5206\u914d\u7f16\u53f7\u5e76\u5b58\u5165trie\uff0c\u9047\u5230function\u65f6\u987a\u4fbf\u8bb0\u4e0b\u8be5\u7f16\u53f7\u4e0b\u51fd\u6570\u6240\u5728\u7684\u884c\u3002\ncallfunc\u8f6c\u4e3acall+\u7f16\u53f7,function\u8f6c\u4e3a set+\u7f16\u53f7+%line\n\u7f16\u8bd1\u5b8c\u6210\u540e\u626b\u4e00\u904d\u751f\u6210\u7684\u6307\u4ee4\uff0c\u9047\u5230\u7f16\u53f7\u7684\u5c06\u5176\u8f6c\u4e3a\u5e38\u91cf\u884c\u53f7\u5373\u53ef\n\n\u8be6\u89c1\u4ee3\u7801(\u53ef\u80fd\u662f\u901a\u8fc7\u8bb0\u5f55\u4e2d\u6700\u77ed\u7684\uff0c\u624d400\u884c\u4e0d\u5230)\n\n```cpp\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#define intptr long long\n\ninline char *strlwr(char *s) {\n\tchar *sp=s;\n\twhile(*s!='\\0') {\n\t\tif(*s>='A'&&*s<='Z')*s=*s-'A'+'a';\n\t\ts++;\n\t}\n\treturn sp;\n} //\u5927\u5199\u8f6c\u5c0f\u5199 c++98\u4e2d\u81ea\u5e26\u4f46luogu\u4e0a\u597d\u50cf\u6ca1\u6709 \n\nint constant_pool[4194306];//\u5e38\u91cf\u6c60 \nint cp;//\u5e38\u91cf\u6c60\u503c\u4e2a\u6570 \n\ntypedef enum {\n    none,hlt,set,jmp,jif,call,ret,inv,add,sub,mul,idiv,mod,lsft,rsft,band,bor,bxor,gr,ls,ge,le,eq,land,lor,wint,rint,wc,rc,nop\n} oper;//\u6307\u4ee4\u96c6 \n\ntypedef struct {\n\toper op;\n\tint *opr1;\n\tbool pre1;\n\tint *opr2;\n\tbool pre2;\n\tint *opr3;\n\tbool pre3;\n} inst;//\u6307\u4ee4 \n\nint ptr_memory[17*1024*1024]; //\u5185\u5b58 \ninst compiled_program[1000000];\nint inst_count;\n\nnamespace vm {\n\t//%line,%val,%ret,%flag,%r1-%r4,%e1-%e4\n\tint regs[12];\n\tint callst[4194306];//\u8c03\u7528\u6808\uff0c\u5b58ret\u540e\u4e0b\u4e00\u6761\u6307\u4ee4 \n\tint linest[4194306];//\u8c03\u7528\u6808\uff0c\u5b58ret\u540e%line\u503c \n\n\tint pc,sp;//pc\u662f\u6307\u4ee4\u8ba1\u6570\u5668\uff0csp\u662f\u8c03\u7528\u6808\u6808\u9876\u6307\u9488 \n\tbool halted; \n\t\n\t//\u63a5\u4e0b\u6765\u662f\u5404\u79cd\u6307\u4ee4\u7684\u5b9e\u73b0 \n\ttypedef void (*pfn_impl)(inst &ptr_inst);\n\tvoid imp_nop(inst &ptr_inst) {}\n\tvoid imp_hlt(inst &ptr_inst) {\n\t\thalted=1;\n\t}\n\tvoid imp_set(inst &ptr_inst) {\n\t\t*ptr_inst.opr2=*ptr_inst.opr1;\n\t}\n\tvoid imp_jmp(inst &ptr_inst) {\n\t\tpc=regs[0]+*ptr_inst.opr1;\n\t}\n\tvoid imp_jif(inst &ptr_inst) {\n\t\tif(*ptr_inst.opr2)pc=regs[0]+*ptr_inst.opr1;\n\t}\n\tvoid imp_call(inst &ptr_inst) {\n\t\tsp++;\n\t\tcallst[sp]=pc;\n\t\tlinest[sp]=regs[0];\n\t\tpc=*ptr_inst.opr1;\n\t}\n\tvoid imp_ret(inst &ptr_inst) {\n\t\tpc=callst[sp];\n\t\tregs[0]=linest[sp];\n\t\tsp--;\n\t\tregs[2]=*ptr_inst.opr1;\n\t}\n\tvoid imp_inv(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=-(*ptr_inst.opr1);\n\t}\n\tvoid imp_add(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1+(*ptr_inst.opr2);\n\t}\n\tvoid imp_sub(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1-(*ptr_inst.opr2);\n\t}\n\tvoid imp_mul(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1*(*ptr_inst.opr2);\n\t}\n\tvoid imp_idiv(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1/(*ptr_inst.opr2);\n\t}\n\tvoid imp_mod(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1%(*ptr_inst.opr2);\n\t}\n\tvoid imp_lsft(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1<<(*ptr_inst.opr2);\n\t}\n\tvoid imp_rsft(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1>>(*ptr_inst.opr2);\n\t}\n\tvoid imp_band(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1&(*ptr_inst.opr2);\n\t}\n\tvoid imp_bor(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1|(*ptr_inst.opr2);\n\t}\n\tvoid imp_bxor(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=*ptr_inst.opr1^(*ptr_inst.opr2);\n\t}\n\tvoid imp_gr(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)>(*ptr_inst.opr2);\n\t}\n\tvoid imp_ls(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)<(*ptr_inst.opr2);\n\t}\n\tvoid imp_ge(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)>=(*ptr_inst.opr2);\n\t}\n\tvoid imp_le(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)<=(*ptr_inst.opr2);\n\t}\n\tvoid imp_eq(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)==(*ptr_inst.opr2);\n\t}\n\tvoid imp_land(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)&&(*ptr_inst.opr2);\n\t}\n\tvoid imp_lor(inst &ptr_inst) {\n\t\t*ptr_inst.opr3=(*ptr_inst.opr1)||(*ptr_inst.opr2);\n\t}\n\tvoid imp_rint(inst &ptr_inst) {\n\t\tscanf(\"%d\",ptr_inst.opr1);\n\t}\n\tvoid imp_wint(inst &ptr_inst) {\n\t\tprintf(\"%d\",*ptr_inst.opr1);\n\t}\n\tvoid imp_rc(inst &ptr_inst) {\n\t\t*ptr_inst.opr1=getchar();\n\t}\n\tvoid imp_wc(inst &ptr_inst) {\n\t\tprintf(\"%c\",*ptr_inst.opr1);\n\t}\n\tpfn_impl calling_vector[]= {&imp_nop,\n\t                            &imp_hlt,&imp_set,&imp_jmp,&imp_jif,&imp_call,&imp_ret,\n\t                            &imp_inv,&imp_add,&imp_sub,&imp_mul,&imp_idiv,&imp_mod,&imp_lsft,&imp_rsft,&imp_band,&imp_bor,&imp_bxor,\n\t                            &imp_gr,&imp_ls,&imp_ge,&imp_le,&imp_eq,&imp_land,&imp_lor,\n\t                            &imp_wint,&imp_rint,&imp_wc,&imp_rc,&imp_nop,\n\t                           };\n\tvoid vm_execute(inst *ptr_inst) {\n\t\tpc=1;\n\t\twhile(!halted) {//\u4e3b\u5faa\u73af \n\t\t\tinst curr=compiled_program[pc];\n\t\t\tpc++;\n\t\t\t//\u5bf9\u4e8c\u7ea7\u5bfb\u5740\u7684\u9884\u5904\u7406 \n\t\t\tif(curr.pre1)curr.opr1=(int*)(*((intptr*)curr.opr1)+ptr_memory);\n\t\t\tif(curr.pre2)curr.opr2=(int*)(*((intptr*)curr.opr2)+ptr_memory);\n\t\t\tif(curr.pre3)curr.opr3=(int*)(*((intptr*)curr.opr3)+ptr_memory);\n\t\t\tcalling_vector[curr.op](curr);//\u901a\u8fc7\u67e5\u8868\u8df3\u8f6c\u5230\u6307\u4ee4\u5177\u4f53\u5b9e\u73b0 \n\t\t}\n\t}\n\n\tint *get_reg_ptr(const char *p_str) {\n\t\tif(p_str[2]>='0'&&p_str[2]<='9') {//%r1-%r4,%e1-%e4 \n\t\t\treturn regs+(p_str[1]=='e'?4:0)+(p_str[2]-'0')+3;\n\t\t} else { //%val,%ret,%flag,%line\n\t\t\treturn regs+(p_str[1]=='v'?1:(p_str[1]=='r'?2:(p_str[1]=='f'?3:0)));\n\t\t}\n\t}\n}\n\nstruct trie {//trie\u6811 \n\tint toval(char c) {\n\t\tif(c>='a'&&c<='z')return c-'a';\n\t\tif(c>='A'&&c<='Z')return c-'A'+26;\n\t\treturn c-'0'+52;\n\t}\n\tint ch[9999][63];\n\tint nc;\n\tvoid insert(const char *p,int val) {\n\t\tint root=0;\n\t\twhile(*p!='\\0') {\n\t\t\tint nxt=toval(*p);\n\t\t\tif(!ch[root][nxt]) {\n\t\t\t\tch[root][nxt]=++nc;\n\t\t\t}\n\t\t\troot=ch[root][nxt];\n\t\t\tp++;\n\t\t}\n\t\tch[root][62]=val;\n\t}\n\tint match(char *s) {\n\t\tint root=0;\n\t\twhile((*s>='a'&&*s<='z')||(*s>='A'&&*s<='Z')||(*s>='0'&&*s<='9')) {\n\t\t\tint nxt=toval(*s);\n\t\t\troot=ch[root][nxt];\n\t\t\ts++;\n\t\t}\n\t\treturn ch[root][62];\n\t}\n};\n\nnamespace compiler {\n\tint fix_map[100000];//\u5b58\u653e\u51fd\u6570\u8d77\u59cb\u70b9\u884c\u53f7 \n\ttrie fix_list;//\u8bb0\u5f55\u4f7f\u7528\u8fc7\u7684\u51fd\u6570 \n\tint fix_count;\n\tchar operation[10],arg1[30],arg2[12],arg3[12];//\u6307\u4ee4\u53ca\u4e09\u4e2a\u53c2\u6570 \n\ttrie keywd;//\u5339\u914d\u6307\u4ee4\u7684trie \n\n\tint *alloc_constant(int val) {//\u5411\u5e38\u91cf\u6c60\u4e2d\u6dfb\u52a0\u5e38\u91cf \n\t\tcp++;\n\t\tconstant_pool[cp]=val;\n\t\treturn &constant_pool[cp];\n\t}\n\tvoid process_arg(char *p_buf,int *&oper,bool &pre,int ln) {//\u5904\u7406\u6307\u4ee4\u7684\u53c2\u6570 \n\t\tif(p_buf[0]=='#') {//#line\n\t\t\toper=alloc_constant(ln);\n\t\t\treturn;\n\t\t}\n\t\tif((p_buf[0]>='0'&&p_buf[0]<='9')||p_buf[0]=='-') {//\u6570\u5b57 \n\t\t\tint val;\n\t\t\tsscanf(p_buf,\"%d\",&val);\n\t\t\toper=alloc_constant(val);\n\t\t\treturn;\n\t\t}\n\t\tif(p_buf[0]=='%') {//%+\u5bc4\u5b58\u5668 \n\t\t\toper=vm::get_reg_ptr(p_buf);\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(p_buf[0]=='@') {\n\t\t\t\tif(p_buf[1]=='%') {//@%+\u5bc4\u5b58\u5668 \n\t\t\t\t\tp_buf+=1;\n\t\t\t\t\toper=vm::get_reg_ptr(p_buf);\n\t\t\t\t\tpre=1;//\u6807\u8bb0\u4e8c\u7ea7\u5bfb\u5740\u9700\u7279\u522b\u5904\u7406 \n\t\t\t\t\treturn;\n\t\t\t\t} else { //@\u56fa\u5b9a\u5185\u5b58\u5730\u5740 \n\t\t\t\t\tint val;\n\t\t\t\t\tp_buf+=1;\n\t\t\t\t\tsscanf(p_buf,\"%d\",&val);\n\t\t\t\t\toper=ptr_memory+val;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid init() {//\u6dfb\u52a0\u6307\u4ee4\uff0c\u4e0d\u89e3\u91ca \n\t\tkeywd.insert(\"hlt\",hlt);\n\t\tkeywd.insert(\"set\",set);\n\t\tkeywd.insert(\"jmp\",jmp);\n\t\tkeywd.insert(\"jif\",jif);\n\t\tkeywd.insert(\"call\",call);\n\t\tkeywd.insert(\"ret\",ret);\n\t\tkeywd.insert(\"inv\",inv);\n\t\tkeywd.insert(\"add\",add);\n\t\tkeywd.insert(\"sub\",sub);\n\t\tkeywd.insert(\"mult\",mul);\n\t\tkeywd.insert(\"idiv\",idiv);\n\t\tkeywd.insert(\"mod\",mod);\n\t\tkeywd.insert(\"lsft\",lsft);\n\t\tkeywd.insert(\"rsft\",rsft);\n\t\tkeywd.insert(\"band\",band);\n\t\tkeywd.insert(\"bor\",bor);\n\t\tkeywd.insert(\"bxor\",bxor);\n\t\tkeywd.insert(\"lgr\",gr);\n\t\tkeywd.insert(\"lls\",ls);\n\t\tkeywd.insert(\"lge\",ge);\n\t\tkeywd.insert(\"lle\",le);\n\t\tkeywd.insert(\"leql\",eq);\n\t\tkeywd.insert(\"land\",land);\n\t\tkeywd.insert(\"lor\",lor);\n\t\tkeywd.insert(\"wint\",wint);\n\t\tkeywd.insert(\"rint\",rint);\n\t\tkeywd.insert(\"wch\",wc);\n\t\tkeywd.insert(\"rch\",rc);\n\t\tkeywd.insert(\"callfunc\",-1);\n\t\tkeywd.insert(\"function\",-2);\n\t\tkeywd.insert(\"nop\",nop);\n\t\tkeywd.insert(\"udef\",nop);\n\t}\n\tvoid process_statement(int ln) {//\u5904\u7406\u8bed\u53e5 \n\t\tint id=keywd.match(strlwr(operation));\n\t\tif(id==0) {\n\t\t\treturn;\n\t\t}\n\t\tif(id<0) {//callfunc \u6216 function \n\t\t\tint exist=fix_list.match(arg1+1);\n\t\t\tif(!exist) {//\u7b2c\u4e00\u6b21\u51fa\u73b0\u65f6\u5206\u914d\u51fd\u6570\u7f16\u53f7 \n\t\t\t\tfix_list.insert(arg1+1,++fix_count);\n\t\t\t\texist=fix_count;\n\t\t\t}\n\t\t\tif(id==-1) {//\u586b\u5165\u7f16\u53f7 \n\t\t\t\tcompiled_program[++inst_count]=(inst) {\n\t\t\t\t\tcall,(int*)(long long)exist \n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tcompiled_program[++inst_count]=(inst) {\n\t\t\t\t\tset,(int*)(long long)exist,0,vm::get_reg_ptr(\"%line\")\n\t\t\t\t};\n\t\t\t\tfix_map[exist]=ln;\n\t\t\t}\n\t\t} else {\n\t\t\tcompiled_program[++inst_count].op=(oper)id;\n\t\t\tif(id==inv) {\n\t\t\t\tstrcpy(arg3,arg2);//inv \u6700\u591a\u4e24\u4e2a\u53c2\u6570 \u5c06\u5176\u7edf\u4e00\u4e3a\u7b2c\u4e09\u4e2a\u53c2\u6570\u8fd4\u56de\u7ed3\u679c \n\t\t\t}\n\t\t\t//\u8865\u5145\u53ef\u7701\u7565\u7684\u53c2\u6570 \n\t\t\tif(id>=inv&&id<=bxor) {\n\t\t\t\tif(arg3[0]=='\\0')strcpy(arg3,\"%val\");\n\t\t\t}\n\t\t\tif(id>=gr&&id<=lor) {\n\t\t\t\tif(arg3[0]=='\\0')strcpy(arg3,\"%flag\");\n\t\t\t}\n\t\t\tif(id>=wint&&id<=rc) {\n\t\t\t\tif(arg1[0]=='\\0')strcpy(arg1,\"%val\");\n\t\t\t}\n\t\t\tif(id==jif) {\n\t\t\t\tif(arg2[0]=='\\0')strcpy(arg2,\"%flag\");\n\t\t\t}\n\t\t\tif(id==ret) {\n\t\t\t\tif(arg1[0]=='\\0')strcpy(arg1,\"%ret\");\n\t\t\t}\n\t\t\t//\u5c06\u53c2\u6570\u586b\u5165\u6307\u4ee4 \n\t\t\tif(arg1[0]!='\\0')process_arg(strlwr(arg1),compiled_program[inst_count].opr1,compiled_program[inst_count].pre1,ln);\n\t\t\tif(arg2[0]!='\\0')process_arg(strlwr(arg2),compiled_program[inst_count].opr2,compiled_program[inst_count].pre2,ln);\n\t\t\tif(arg3[0]!='\\0')process_arg(strlwr(arg3),compiled_program[inst_count].opr3,compiled_program[inst_count].pre3,ln);\n\t\t}\n\t}\n\tvoid reloc() {//\u51fd\u6570\u91cd\u5b9a\u4f4d \n\t\tfor(int i=1; i<=inst_count; i++) {\n\t\t\tif((long long)compiled_program[i].opr1<=fix_count) {//\u6b63\u5e38\u503c\u4e3a\u6307\u9488\uff0c\u82e5\u503c\u8fc7\u5c0f\u5219\u4e3a\u51fd\u6570\u7f16\u53f7 \n\t\t\t\tint fix_id=(long long)compiled_program[i].opr1;\n\t\t\t\tint *ln=alloc_constant(fix_map[fix_id]);//\u67e5\u8868\u5e76\u66ff\u6362 \n\t\t\t\tcompiled_program[i].opr1=ln;\n\t\t\t}\n\t\t}\n\t}\n\tchar line_buf[1000];\n\tint line_count;\n\tvoid compile() {\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tmemset(line_buf,0,sizeof(line_buf));\n\t\t\tchar c;\n\t\t\tline_count=0;\n\t\t\tint flag=0;\n\t\t\twhile((c=getchar())=='\\n');\n\t\t\tdo {\n\t\t\t\tif(c=='[')flag++;\n\t\t\t\tif(c==']'&&flag)flag--;\n\t\t\t\tif(!flag&&c!=']')line_buf[++line_count]=c;\n\t\t\t} while((c=getchar())!='\\n'&&(!feof(stdin)));//\u8bfb\u5165\u884c\u5e76\u5ffd\u7565\u6ce8\u91ca \n\t\t\tchar *p_tokens=strtok(line_buf+1,\";\");//\u6309\u5206\u53f7\u5206\u9694 \n\t\t\twhile(*p_tokens) {\n\t\t\t\twhile(*p_tokens==' ')p_tokens++;//\u53bb\u524d\u5bfc\u7a7a\u683c \n\t\t\t\t\n\t\t\t\tmemset(operation,0,sizeof(operation));\n\t\t\t\tmemset(arg1,0,sizeof(arg1));\n\t\t\t\tmemset(arg2,0,sizeof(arg2));\n\t\t\t\tmemset(arg3,0,sizeof(arg3));\n\t\t\t\tsscanf(p_tokens,\"%s%s%s%s\",operation,arg1,arg2,arg3); \n\t\t\t\tprocess_statement(i);\n\t\t\t\t\n\t\t\t\twhile(*p_tokens)p_tokens++;//\u8df3\u81f3\u4e0b\u4e00\u6761\u8bed\u53e5 \n\t\t\t\tp_tokens++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc,char **argv) {\n\tcompiler::init();\n\tcompiler::compile();\n\tcompiler::reloc();\n\tvm::vm_execute(&compiled_program[1]);\n\treturn 0;\n}\n```",
        "postTime": 1541331503,
        "uid": 59259,
        "name": "cicuvc",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "# P4911 \u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\n\n\u672c\u9898\u89e3\u672a\u4f7f\u7528\u4efb\u4f55\u5de5\u7a0b\u7a0b\u5e8f\u8bbe\u8ba1\u65b9\u6cd5 qwq\n\n\u6781\u5176\u7b80\u5355\u6613\u61c2 qwq\n\n## \u601d\u8def\n\n\u9996\u5148 \u5bf9\u4e8e\u6ce8\u91ca \u6211\u4eec\u901a\u8fc7\u9884\u5904\u7406\u5220\u9664\u6389\u3002\n\n\u5bf9\u4e8e\u5e38\u91cf\u6c60\u548c\u5185\u5b58\u5bfb\u5740 \u6211\u4eec\u5f00\u4e00\u4e2a\u5927\u6570\u7ec4\u3002\n\n\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\u672c\u9898\u6570\u636e\u4e2d\u6ca1\u6709\u6ce8\u91ca,\u5e38\u91cf\u6c60,\u5185\u5b58\u5bfb\u5740\u3002\n\n\uff08\u4e8b\u5b9e\u4e0a\u5f88\u591a\u9898\u89e3\u6709\u5173\u8fd9\u90e8\u5206\u7684\u5185\u5bb9\u90fd\u6709\u4e9b\u95ee\u9898 \u6240\u4ee5\u672c\u9898\u89e3\u7684\u4ee3\u7801\u5220\u9664\u4e86\u8fd9\u4e9b\u5185\u5bb9\u3002\n\n12 \u4e2a\u5bc4\u5b58\u5668\u5c31\u5f00 12 \u4e2a\u53d8\u91cf\u3002\n\n\u6211\u4eec\u9700\u8981\u4e24\u4e2a\u91cd\u8981\u51fd\u6570 \u4e00\u4e2a\u7528\u6765\u8fd4\u56de\u5b57\u7b26\u4e32\u6240\u4ee3\u8868\u7684\u5bc4\u5b58\u5668\u7684\u6307\u9488\u3002\n\n\u53e6\u4e00\u4e2a\u8fd4\u56de\u5b57\u7b26\u4e32\u6240\u4ee3\u8868\u7684\u503c \u4e0d\u8bba\u8fd9\u4e2a\u5b57\u7b26\u4e32\u4e2d\u5185\u5bb9\u662f\u5bc4\u5b58\u5668\u8fd8\u662f\u6570\u5b57\u3002\n\n\u5bf9\u4e8e\u7a0b\u5e8f \u6211\u4eec\u4ece\u7b2c\u4e00\u884c\u5f00\u59cb\u5faa\u73af\u8fd0\u884c\u5b83\u3002\n\n\u7279\u5224\u64cd\u4f5c\u7b26 30 \u4e2a\u7279\u5224\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u51fd\u6570\u8fd4\u56de\u6307\u4ee4\u548c\u8df3\u8f6c\u6307\u4ee4\u5f00\u6808\u7ef4\u62a4\u5373\u53ef \u5176\u4e2d\u9700\u8981\u5bf9\u8fd4\u56de\u7684\u884c\u6570\u8fdb\u884c\u4e00\u4e9b\u5fae\u64cd\u3002\n\n\uff08\u4e2d\u9014\u8bed\u53e5\u8df3\u8f6c\u548c\u51fd\u6570\u8fd4\u56de\u6211\u786e\u5b9e\u8c03\u4e86\u633a\u4e45 u1s1 \u4e0d\u8981\u5728\u7a0b\u5e8f\u4e2d\u4f7f\u7528 goto \u8bed\u53e5 qwq \uff09\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<map>\nusing namespace std;\nint n;\nint r1,r2,r3,r4,e1,e2,e3,e4,flag,val,ret,line;\nstack<pair<int,int> > saddr;\nstring mp[50005][100];\nmap<string,int> func;\nint get_num(string lock)\n{\n    if(lock[0]=='%')\n    {\n        if(lock[1]=='r')\n        {\n            if(lock[2]=='1')\n                return r1;\n            if(lock[2]=='2')\n                return r2;\n            if(lock[2]=='3')\n                return r3;\n            if(lock[2]=='4')\n                return r4;\n        }\n        if(lock[1]=='e')\n        {\n            if(lock[2]=='1')\n                return e1;\n            if(lock[2]=='2')\n                return e2;\n            if(lock[2]=='3')\n                return e3;\n            if(lock[2]=='4')\n                return e4;\n        }\n        if(lock[1]=='v')\n            return val;\n        if(lock[1]=='f')\n            return flag;\n        if(lock[1]=='r')\n            return ret;\n        if(lock[1]=='l')\n            return line;\n    }\n    else\n    {\n        int ans=0;\n        for(int i=0;i<=lock.length()-1;i++)\n            if(lock[i]!=';')\n                ans*=10,ans+=lock[i]-'0';\n        return ans;\n    }\n}\nint *get_adrs(string lock)\n{\n    if(lock[1]=='r')\n    {\n        if(lock[2]=='1')\n            return &r1;\n        if(lock[2]=='2')\n            return &r2;\n        if(lock[2]=='3')\n            return &r3;\n        if(lock[2]=='4')\n            return &r4;\n    }\n    if(lock[1]=='e')\n    {\n        if(lock[2]=='1')\n            return &e1;\n        if(lock[2]=='2')\n            return &e2;\n        if(lock[2]=='3')\n            return &e3;\n        if(lock[2]=='4')\n            return &e4;\n    }\n    if(lock[1]=='v')\n        return &val;\n    if(lock[1]=='f')\n        return &flag;\n    if(lock[1]=='r')\n        return &ret;\n    if(lock[1]=='l')\n        return &line;\n}\nint main()\n{\n   // freopen(\"data.06.in\",\"r\",stdin);\n   // freopen(\"data.out\",\"w\",stdout);\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        for(int j=1;mp[i][j-1][mp[i][j-1].length()-1]!=';';j++)\n            cin>>mp[i][j];\n    for(int i=1;i<=n;i++)\n    {\n        if(mp[i][1]==\"function\")\n        {\n            line=i;\n            func[mp[i][2].substr(1,mp[i][2].length()-2)]=i+1;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(mp[i][1]==\"hlt;\") return 0;\n        if(mp[i][1]==\"nop;\") continue;\n        if(mp[i][1]==\"udef;\") continue;\n        if(mp[i][1]==\"set\")\n            if(mp[i][3][0]=='%') \n                *(get_adrs(mp[i][3]))+=get_num(mp[i][2]);\n        if(mp[i][1]==\"jmp\") \n        {\n            i=get_num(mp[i][2])-1;\n            continue;\n        }\n        if(mp[i][1]==\"jif\")\n            if(flag||get_num(mp[i][3])&&mp[i][3].length())\n            {\n                i=get_num(mp[i][2])-1;\n                continue;\n            }\n        if(mp[i][1]==\"call\")\n        {\n            saddr.push(make_pair(i+1,line));\n            i=get_num(mp[i][2])-1;\n            continue;\n        }\n        if(mp[i][1]==\"ret\"||mp[i][1]==\"ret;\")\n        {\n            pair<int,int> kkk=saddr.top();\n            if(mp[i][2].length())\n                ret=get_num(mp[i][2]);\n            saddr.pop();\n            i=kkk.first-1;\n            line=kkk.second;\n            continue;\n        }\n        if(mp[i][1]==\"callfunc\")\n        {\n            saddr.push(make_pair(i+1,line));\n            i=func[mp[i][2].substr(1,mp[i][2].length()-2)]-1;\n            continue;\n        }\n        if(mp[i][1]==\"inv\")\n        {\n            if(mp[i][3].length())\n                *(get_adrs(mp[i][3]))=-get_num(mp[i][2]);\n            else\n                val=-get_num(mp[i][2]);\n        }\n        if(mp[i][1]==\"add\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][3])+get_num(mp[i][2]);\n            else\n                val=get_num(mp[i][3])+get_num(mp[i][2]);\n        }\n        if(mp[i][1]==\"sub\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])-get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])-get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"mult\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])*get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])*get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"idiv\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])/get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])/get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"mod\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])%get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])%get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lsft\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])<<get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])<<get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"rsft\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])>>get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])>>get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"band\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])&get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])&get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"bor\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])|get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])|get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"bxor\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])^get_num(mp[i][3]);\n            else\n                val=get_num(mp[i][2])^get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lgr\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])>get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])>get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lls\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])<get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])<get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lge\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])>=get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])>=get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lle\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])<=get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])<=get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"leql\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])==get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])==get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"land\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])&&get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])&&get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"lor\")\n        {\n            if(mp[i][4].length())\n                *(get_adrs(mp[i][4]))=get_num(mp[i][2])||get_num(mp[i][3]);\n            else\n                flag=get_num(mp[i][2])||get_num(mp[i][3]);\n        }\n        if(mp[i][1]==\"rint\")\n        {\n            int srt;\n            if(mp[i][2].length())\n            {\n                scanf(\"%d\",&srt);\n                *(get_adrs(mp[i][2]))=srt;\n            }\n            else\n            {\n                scanf(\"%d\",&srt);\n                *(get_adrs(mp[i][2]))=srt;\n            }\n        }\n        if(mp[i][1]==\"rch\")\n        {\n            char srt;\n            if(mp[i][2].length())\n            {\n                scanf(\"%c\",&srt);\n                *(get_adrs(mp[i][2]))=srt;\n            }\n            else\n            {\n                scanf(\"%c\",&srt);\n                *(get_adrs(mp[i][2]))=srt;\n            }\n        }\n        if(mp[i][1]==\"wint\"||mp[i][1]==\"wint;\")\n        {\n            if(mp[i][2].length())\n                printf(\"%d\",get_num(mp[i][2]));\n            else\n                printf(\"%d\",val);\n        }\n        if(mp[i][1]==\"wch\"||mp[i][1]==\"wch;\")\n        {\n            if(mp[i][2].length())\n                printf(\"%c\",(char)get_num(mp[i][2]));\n            else\n                printf(\"%c\",(char)val);\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1622884331,
        "uid": 150467,
        "name": "never_turn_right",
        "ccfLevel": 7,
        "title": "\u9898\u89e3\uff1a\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a"
    },
    {
        "content": "## \u9898\u76ee\u5927\u610f\n\n- \u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684\u6c47\u7f16\u8bed\u8a00\u89e3\u91ca\u5668\u3002\n\n## \u9898\u89e3\n\n- \u5199\u4e86\u4e00\u4e2a\u622a\u6b62\u5230\u5f53\u524d\u4e3a\u6b62 $(2020.10.24)$  \u6700\u77ed\u7684\u4ee3\u7801 $\\text{(4.70KB)}$ \u3002\u770b\u770b\u6709\u6ca1\u6709\u4eba\u80fd\u6253\u7834\u5427\u3002\n\n- \u4ee3\u7801\u7ecf\u8fc7\u4e86\u4e00\u4e9b\u538b\u884c\uff0c\u538b\u5230\u4e86 $98$ \u884c\uff0c\u4f46\u5c3d\u91cf\u4fdd\u6301\u4e86\u53ef\u8bfb\u6027\uff0c\u6bcf\u884c\u5927\u7ea6 $80$ \u4e2a\u5b57\u7b26\uff0c\u4e5f\u6ca1\u6709\u523b\u610f\u538b\u7f29\u53d8\u91cf\u540d\u3002\n\n\u8bf4\u4e86\u4e00\u4e9b\u95f2\u8bdd\uff0c\u8ba9\u6211\u4eec\u8fdb\u5165\u6b63\u9898\u5427\u3002\n\n### \u6982\u51b5\n\n\u8fd9\u6761\u5927\u6a21\u62df\u9898\u8981\u6c42\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684**\u6c47\u7f16\u8bed\u8a00\u89e3\u91ca\u5668**\u3002\u663e\u7136\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u9605\u8bfb\u9644\u4ef6\u4e2d\u7684\u8bed\u8a00\u89c4\u8303\u3002\u7ecf\u8fc7\u9605\u8bfb\u540e\uff0c\u6211\u4eec\u80fd\u83b7\u5f97\u4ee5\u4e0b\u4fe1\u606f\uff1a\n\n- \u6bcf\u6761\u6c47\u7f16\u7a0b\u5e8f\u4ec5\u4ec5\u4f1a\u5bf9 $12$ \u4e2a\u5bc4\u5b58\u5668\u3001\u4e00\u5757\u5185\u5b58\u6761\u3001\u4e00\u4e2a\u7cfb\u7edf\u6808\u8fdb\u884c\u64cd\u4f5c\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5f00\u4e0b\u8fd9\u4e48\u5927\u7684\u7a7a\u95f4\u3002\n\n- \u5b9e\u73b0\u7684\u64cd\u4f5c\u90fd\u8f83\u4e3a\u7b80\u5355\uff0c\u6ca1\u6709\u9ebb\u70e6\u7684\u4e2d\u7f00\u8868\u8fbe\u5f0f\u6c42\u77e5\u7b49\u95ee\u9898\u3002\u6bcf\u4e2a\u6307\u4ee4\u53c2\u6570\u90fd\u5f88\u7b80\u5355\u3002\n\n- \u76f4\u63a5\u66b4\u529b\u6a21\u62df\u4e0d\u4f1a\u8d85\u65f6\u3002\n\n\u51fa\u9898\u4eba\u5728\u6587\u6863\u4e2d\u6709\u4e9b\u7ec6\u8282\u6ca1\u6709\u8bf4\u660e\u5230\u4f4d\uff0c\u8fd9\u91cc\u8865\u5145\u4e00\u4e0b\uff1a\n\n- \u6ce8\u91ca\u4e2d\u7684\u65b9\u62ec\u53f7\u4fdd\u8bc1\u4e24\u4e24\u914d\u5bf9\uff1b\u5f62\u5982 $\\texttt{[[haha]wch(65);]}$ \u7684\u4ee3\u7801\u5e76\u4e0d\u4f1a\u6267\u884c $\\texttt{wch(65);}$ \u3002\n\n- \u5f62\u5982 $\\texttt{@\\%ret}$ \u7684\u4ee3\u7801\u7684\u542b\u4e49\u662f\uff0c\u5185\u5b58\u6761\u4e2d\u7b2c $ret$ \u4e2a\u5143\u7d20\u3002\n\n### \u8f93\u5165\u683c\u5f0f\u5316\n\n\u9996\u5148\u6211\u4eec\u5220\u9664\u6240\u6709\u7684\u6ce8\u91ca\u548c\u6362\u884c\u3002\u8fd9\u90e8\u5206\u5f88\u5bb9\u6613\u5b9e\u73b0\uff0c\u4e0d\u518d\u8d58\u8ff0\u3002\n\n\u89c2\u5bdf\u5230\u6bcf\u6761\u8bed\u53e5\u90fd\u4ee5 $\\texttt{;}$ \u7ed3\u5c3e\uff0c\u6240\u4ee5\u6211\u4eec\u80fd\u7528\u5b83\u5206\u5272\u6bcf\u6761\u72ec\u7acb\u7684\u4ee3\u7801\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u4ee3\u7801\uff0c\u6211\u4eec\u8fdb\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a\n\n- $1.$ \u5c06\u6240\u6709\u7684\u9017\u53f7\u66ff\u6362\u6210\u7a7a\u683c\u3002\n\n- $2.$ \u5220\u9664\u591a\u4f59\u7684\u7a7a\u683c\u3002\u8fde\u7eed\u7684\u7a7a\u683c\u53ea\u4fdd\u7559\u4e00\u4e2a\u3002\u5220\u9664\u524d\u5bfc\u7a7a\u683c\u548c\u540e\u7f00\u7a7a\u683c\u3002\n\n- $3.$ \u5c06\u5904\u7406\u5b8c\u7684\u8bed\u53e5\u653e\u5728\u5b57\u7b26\u6570\u7ec4\u91cc\u5907\u7528\u3002\n\n\u8fd9\u90e8\u5206\u64cd\u4f5c\u76f8\u5f53\u7b80\u5355\uff0c\u4f46\u4e3a\u6211\u4eec\u7cbe\u51c6\u8bc6\u522b\u6bcf\u6761\u6307\u4ee4\u5f88\u6709\u5e2e\u52a9\u3002\n\n### \u6846\u67b6\n\n\u5176\u5b9e\u8fd9\u6761\u9898\u76ee\u5e76\u4e0d\u662f\u5f88\u96be\uff0c\u4e3b\u8981\u8003\u67e5\u4e86\u9009\u624b\u5bf9\u7a0b\u5e8f\u7684\u8bbe\u8ba1\u80fd\u529b\u4ee5\u53ca\u7f16\u5199\u80fd\u529b\u3002\n\n#### \u6307\u4ee4\u7684\u5b58\u50a8\n\n\u8003\u8651\u5c06\u6bcf\u6761\u6307\u4ee4\u7528\u4e00\u4e2a\u7ed3\u6784\u4f53\u8fdb\u884c\u5b58\u50a8\u3002\u5177\u4f53\u800c\u8a00\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7ed3\u6784\u4f53 $\\text{Opt}$ \uff0c\u91cc\u9762\u5b58\u50a8\uff1a\u8fd9\u662f\u4ec0\u4e48\u6307\u4ee4\u3001\u8fd9\u4e2a\u6307\u4ee4\u7684\u53c2\u6570\u3002\u7531\u4e8e\u8fd9\u9898\u7684\u6307\u4ee4\u90fd\u53ea\u548c\u5168\u5c40\u53d8\u91cf\uff08\u5bc4\u5b58\u5668\u4e4b\u7c7b\uff09\u6709\u5173\uff0c\u56e0\u6b64\u5b9e\u9645\u8bbe\u8ba1\u7684\u65f6\u5019\uff0c\u53c2\u6570\u53ea\u9700\u8981\u4f20\u5165\u6307\u9488\u5c31\u884c\u4e86\u3002\u540c\u65f6\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528\u51fd\u6570\u6307\u9488\u6307\u5411\u5f53\u524d\u6307\u4ee4\u6240\u4ee3\u8868\u7684\u542b\u4e49\u3002\n\n```cpp\nstruct Opt{\n    void (*fun)(int,int**); int agc,**agv;\n}O[MAXN];\n```\n\n\u6211\u4eec\u5c06\u6bcf\u6761\u6307\u4ee4\u6240\u5bf9\u5e94\u7684\u51fd\u6570\u5265\u79bb\u51fa\u6765\uff1a\n\n```cpp\nvoid add (int agc,int **agv){*agv[2]=(*agv[0])+(*agv[1]);}\nvoid sub (int agc,int **agv){*agv[2]=(*agv[0])-(*agv[1]);}\n...\u4ee5\u4e0b\u7701\u7565\u5176\u4ed6\u51fd\u6570\n```\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u5b58\u50a8\u67d0\u4e2a\u6307\u4ee4\u65f6\uff0c\u53ef\u4ee5\u8fd9\u4e48\u5199\uff1a\n\n```cpp\nO[1].fun=add;\nO[1].agc=2;\nO[1].agv[0]=&r1;\nO[1].agv[1]=&r2;\n```\n\n\u5f53\u6211\u4eec\u6267\u884c\u8fd9\u4e2a\u64cd\u4f5c\u65f6\uff0c\u53ea\u9700\u8981\u8c03\u7528 $\\texttt{O[1].fun(O[1].agc,O[1].agv);}$ \u5c31\u884c\u4e86\u3002\n\n#### \u540d\u79f0\u7684\u8bc6\u522b\n\n\u8003\u8651\u5199\u4e00\u4e2a\u7b80\u5355\u7684\u54c8\u5e0c\u51fd\u6570\u3002\n\n```cpp\nunsigned int hsh(const char *s){\n    unsigned int h=0;\n    for(int p=0;s[p]!=' '&&s[p]&&s[p]!='\\r'&&s[p]!='\\n';++p)\n    h=h*13331+s[p];\n    return h;\n}\n```\n\n\u5b83\u7684\u542b\u4e49\u662f\uff0c\u5c06\u4e00\u4e2a $\\text{C}$ \u98ce\u683c\u5b57\u7b26\u4e32\u6620\u5c04\u5230\u4e00\u4e2a $32$ \u4f4d\u65e0\u7b26\u53f7\u6574\u578b\u3002\u8fd9\u6837\u5b50\u4fbf\u4e8e\u6211\u4eec\u8bc6\u522b\u8f93\u5165\u7684\u51fd\u6570\u540d\u79f0\u3001\u5bc4\u5b58\u5668\u540d\u79f0\u3002\n\n\u4e3a\u4e86\u65b9\u4fbf\u8bc6\u522b\uff0c\u53ef\u4ee5\u8003\u8651\u5199\u4e00\u4e2a\u6ce8\u518c\u51fd\u6570\uff0c\u5c06\u6211\u4eec\u4f1a\u7528\u5230\u7684\u6307\u4ee4\u540d\u63d0\u524d\u6620\u5c04\u5230\u76f8\u5e94\u7684\u51fd\u6570\u3002\n\n```cpp\nvoid (*FN[MAXV])(int,int**);\nvoid rgf(const char *s,void(*fn)(int,int**)){\n    unsigned int h=hsh(s)%MAXV;\n    FN[h]=fn;\n}\n```\n\n\u5f53\u6211\u4eec\u8c03\u7528 $\\texttt{rgf(\"add\",add)}$ \u65f6\uff0c\u6211\u4eec\u5c31\u201c\u6ce8\u518c\u201d\u4e86\u4e00\u4e2a\u540d\u4e3a $\\text{add}$ \u7684\u6307\u4ee4\u3002\n\n\u5bf9\u4e8e\u5bc4\u5b58\u5668\u7684\u6620\u5c04\uff0c\u5982\u6cd5\u70ae\u5236\u5373\u53ef\u3002\u8fd9\u79cd\u65b9\u6cd5\u540c\u6837\u53ef\u4ee5\u7528\u6765\u5904\u7406\u81ea\u5b9a\u4e49\u7684\u51fd\u6570\u540d\u79f0 $\\texttt{function \\text{\\textdollar} xxx}$ \u3002\n\n#### \u51fd\u6570\u53c2\u6570\u5904\u7406\n\n\u5728\u8fd9\u4e2a\u6c47\u7f16\u7a0b\u5e8f\u4e2d\uff0c\u6709\u79cd\u6bd4\u8f83\u7279\u6b8a\u7684\u6570\u636e\u683c\u5f0f $\\texttt{@\\%p}$ \u3002\u5b83\u7684\u542b\u4e49\u662f\u5185\u5b58\u6761\u4e2d\u7b2c $p$ \u4e2a\u6570\u636e\u3002\u5176\u4e2d $p$ \u662f\u4e00\u4e2a\u5bc4\u5b58\u5668\uff08\u5982 $e_1,e_2,val\\cdots$\uff09\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u53c2\u6570\u6240\u5bf9\u5e94\u7684**\u5730\u5740\u4e0d\u662f\u56fa\u5b9a\u7684**\u3002\n\n\u5f53\u7136\uff0c\u8fd9\u4e2a\u95ee\u9898\u4e5f\u5f88\u5bb9\u6613\u89e3\u51b3\u3002\u6211\u4eec\u8bbe $p'$ \u4e3a\u5185\u5b58\u6761\u4e2d\u7b2c $p$ \u4e2a\u5143\u7d20\u7684\u503c\uff0c\u7136\u540e\u8ba9\u51fd\u6570\u7684\u53c2\u6570\u6307\u5411 $p'$ \u5c31\u884c\u4e86\u3002\u4e0d\u8fc7\uff0c\u6bcf\u6267\u884c\u4e00\u6b21\u6307\u4ee4\uff0c\u90fd\u9700\u8981\u66f4\u65b0\u4e00\u904d $p'$ \uff1b\u6267\u884c\u5b8c\u6307\u4ee4\u540e\uff0c\u8fd8\u8981\u6839\u636e $p'$ \u662f\u5426\u88ab\u66f4\u6539\u6765\u66f4\u65b0\u5185\u5b58\u6761\u4e2d\u7b2c $p$ \u4e2a\u5143\u7d20\u3002\n\n\u8fd9\u5176\u4e2d\u8fd8\u6709\u5176\u4ed6\u7ec6\u8282\uff0c\u8bf8\u5982 $p$ \u5e76\u4e0d\u662f\u4e00\u4e2a\u5408\u6cd5\u7684\u5185\u5b58\u4e0b\u6807\u3002\u540c\u65f6\uff0c\u7531\u4e8e $p$ \u53ef\u80fd\u5728\u6307\u4ee4\u4e2d\u88ab\u66f4\u6539\uff0c\u6211\u4eec\u9700\u8981\u63d0\u524d\u8bb0\u5f55\u6267\u884c\u6307\u4ee4\u524d\u7684 $p$ \u7684\u503c\u3002\u5f53\u7136\uff0c\u8fd9\u4e9b\u90fd\u662f\u5c0f\u95ee\u9898\uff0c\u7279\u5224\u5c31\u884c\u4e86\u3002\n\n#### \u5e38\u91cf\n\n\u8fd9\u90e8\u5206\u5185\u5bb9\u4e5f\u5f88\u7b80\u5355\u3002\u7531\u4e8e\u6211\u4eec\u7684\u51fd\u6570\u53c2\u6570\u662f\u6307\u9488\uff0c\u64cd\u4f5c\u7684\u662f\u6307\u9488\u6307\u5411\u7684\u503c\uff0c\u6240\u4ee5\u6211\u4eec\u53e6\u5f00\u4e00\u4e2a\u6570\u7ec4 $C$ \uff0c\u5e38\u91cf\u5b58\u50a8\u5728 $C$ \u4e2d\uff0c\u7136\u540e\u6307\u9488\u6307\u5411\u5bf9\u5e94\u7684\u5185\u5b58\u5c31\u884c\u4e86\u3002\n\n### \u5176\u4ed6\u7ec6\u8282\n\n- $1.$ \u5c3d\u7ba1\u5bc4\u5b58\u5668\u6570\u91cf\u4f17\u591a\uff0c\u4f46\u6211\u4eec\u80fd\u591f\u53d1\u73b0\uff0c\u6bcf\u4e2a\u5bc4\u5b58\u5668\u5b9e\u73b0\u7684\u64cd\u4f5c\u7c7b\u4f3c\u3002\u4e8e\u662f\uff0c\u53ea\u8981\u5f00\u4e00\u4e2a\u6570\u7ec4 $L$ \u7edf\u4e00\u5b58\u50a8\u603b\u5171 $12$ \u4e2a\u5bc4\u5b58\u5668\u5c31\u884c\u4e86\u3002\n\n- $2.$ \u89c4\u8303\u6587\u4ef6\u4e2d\u51fa\u73b0\u4e86\u591a\u6b21\u5f62\u5982\u201c\u6ca1\u6709 $\\texttt{<2>}$ \u53c2\u6570\u5c31\u5b58\u5165 $val$ \u5185\u201d\u7684\u8bed\u53e5\u3002\u6211\u4eec\u53ef\u4ee5\u7528\u5b8f\u5b9a\u4e49\u7b80\u5316\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u7c7b\u4f3c\u4e8e $\\texttt{\\#define a2 (agc>=2?(*agv[2]):val)}$ \u3002\n\n- $3.$ \u6307\u4ee4\u90e8\u5206\u7684\u603b\u957f\u5ea6\u53ef\u80fd\u8d85\u8fc7 $\\text{500KB}$ \uff0c\u6ce8\u610f\u5f00\u5927\u6570\u7ec4\uff0c\u9632\u6b62 $\\texttt{RE}$ \u3002\n\n- $4.$ \u6211\u592a\u61d2\u4e86\u6ca1\u5199\u54c8\u5e0c\u78b0\u649e\u7684\u5904\u7406\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u54c8\u5e0c\u78b0\u649e\u7136\u540e $\\text{WA}$ \u3002\n\n- $5.$ \u6362\u884c\u7b26\u8fd9\u79cd\u4e1c\u897f\uff0c $\\text{Windows}$ \u4e0b\u662f $\\verb!\\r\\n!$ \uff0c $\\text{Linux}$ \u4e0b\u662f $\\verb!\\n!$ \u3002\u4f46\u53ea\u8981\u63d0\u5347\u7a0b\u5e8f\u7684\u9c81\u68d2\u6027\uff0c\u8fd9\u90fd\u4e0d\u662f\u95ee\u9898\u3002\n\n## \u5176\u4ed6\n\n\u5f53\u6211\u7b2c\u4e00\u6b21\u5199\u5b8c\u8fd9\u4efd\u4ee3\u7801\u65f6\uff0c\u4e00\u5171\u5199\u4e86 $\\text{8KB}$ \u5de6\u53f3\uff0c\u5927\u7ea6 $200$ \u884c\u3002\u540e\u6765\u8fdb\u884c\u4e86\u4e00\u4e9b\u4f18\u5316\u538b\u7f29\u5230\u4e86\u73b0\u5728\u7684\u72b6\u6001\u3002\n\n\u6211\u60f3\u5410\u69fd\u4e00\u4e0b $\\texttt{callfunc}$ \u51fd\u6570\u3002\u8bed\u8a00\u89c4\u8303\u4e2d\u5b83\u8f6c\u5230\u7684\u662f\u5bf9\u5e94\u7684\u51fd\u6570\u540d\u7684\u6240\u5728\u884c\uff0c\u800c\u5e76\u975e\u5bf9\u5e94\u7684\u51fd\u6570\u540d\u6240\u5728\u7684 $\\texttt{function}$ \u51fd\u6570\u4f4d\u7f6e\u3002\u8fd9\u53ef\u80fd\u5bfc\u81f4\u4e00\u884c\u5199\u591a\u6761\u4ee3\u7801\u51fa\u9519\uff0c\u5c3d\u7ba1\u6d4b\u8bd5\u6570\u636e\u4e2d\u5e76\u4e0d\u5b58\u5728\u8fd9\u6837\u7684\u6570\u636e\u3002\n\n\u53e6\u5916\uff0c\u8fd9\u4e2a\u6d4b\u8bd5\u6570\u636e\u597d\u6c34\uff0c\u57fa\u672c\u4e0a\u662f\u968f\u673a\u751f\u6210\u7684\uff1b\u4f3c\u4e4e\u6ca1\u6709 $\\text{jmp}$ \u6307\u4ee4\u548c $\\text{jif}$ \u6307\u4ee4\uff1b\u6bcf\u884c\u53ea\u6709\u4e00\u4e2a\u4ee3\u7801\uff0c\u6ca1\u6709\u6ce8\u91ca\uff0c~~\u6bcf\u4e2a\u4ee3\u7801\u8fc7\u4e8e\u89c4\u8303\u4ee5\u81f3\u4e8e\u6211\u5199\u7684\u683c\u5f0f\u5316\u90e8\u5206\u6ca1\u5565\u5375\u7528~~\u3002\n\n\u4f46\u65e0\u8bba\u5982\u4f55\uff0c\u8fd9\u662f\u7f16\u5199\u9ad8\u7ea7\u8bed\u8a00\u89e3\u91ca\u5668\u7684\u7b2c\u4e00\u6b65\u3002~~\u624b\u5203\u672a\u6765\u7a0b\u5e8f\u6539\u6307\u65e5\u53ef\u5f85~~\u3002\n\n\u6700\u540e\u8bf4\u4e00\u53e5\uff0c$\\Large\\text{\u6211\u5927\u6cb3\u7ae5\u79d1\u6280\u4e16\u754c\u7b2c\u4e00\uff01}$\n\n## \u53c2\u8003\u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)\n#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)\ntypedef long long i64;\n#define ag (int agc,int **agv)\nusing namespace std;\nconst int MAXN =5e4+3,MAXM=5e5+3,MAXT=11+3,MAXV=999997;\nconst int MAXR=1e6+3,MAXK=1024*1024*16+3,MAXS=1024*512+3;\nint n,m,rp,op,mc,len,s,pp,ll,tp;\nint LL[MAXT],RR[MAXT],WW[MAXT],VV[MAXT],L[MAXN],R[MAXN],S[MAXS],C[MAXN*5],M[MAXK];\nchar RD[MAXR],TP[MAXM],IN[MAXM],OT[MAXM];\nint* put(int w){C[++mc]=w; return &C[mc];}\nint rdi(){\n    int w=1,c,r;\n    while((c=IN[rp++])> '9'||c< '0') w=(c=='-'?-1:1); r=c-'0';\n    while((c=IN[rp++])>='0'&&c<='9') r=r*10+c-'0';\n    return r*w;\n}\nint rdc(){char c; while((c=IN[rp++])=='\\n'||c=='\\r'||c==' '); return c;}\nvoid wti(int x){i64 xx=x;if(xx<0) OT[op++]='-',xx=-xx; if(xx>9) wti(xx/10); OT[op++]=xx%10+'0';}\n#define a0 (*agv[0])\n#define a1 (*agv[1])\n#define av2 (agc>2?(*agv[2]):LL[8])\n#define af2 (agc>2?(*agv[2]):LL[9])\n#define av0 (agc>0?(*agv[0]):LL[8])\nvoid fnc ag{return;} void udf ag{return;} void nop ag{return;}   void hlt ag{return;}\nvoid sst ag{a1=a0;}  void jmp ag{pp=L[a0+LL[11]]-1;} void jif ag{if(a1) pp=L[a0+LL[11]]-1;}\nvoid cal ag{S[s++]=pp,pp=L[a0]-1;} void ret ag{if(agc>0)LL[10]=a0;pp=S[--s];}\nvoid add ag{av2=a0+ a1;} void sub ag{av2=a0- a1;} void mlt ag{av2=a0* a1;}\nvoid div ag{av2=a0/ a1;} void mod ag{av2=a0% a1;} void lst ag{av2=a0<<a1;}\nvoid rst ag{av2=a0>>a1;} void bnd ag{av2=a0& a1;} void bor ag{av2=a0| a1;}\nvoid bxr ag{av2=a0^ a1;} void lgr ag{af2=a0> a1;} void lls ag{af2=a0< a1;}\nvoid lge ag{af2=a0>=a1;} void lle ag{af2=a0<=a1;} void leq ag{af2=a0==a1;}\nvoid lnd ag{af2=a0& a1;} void lor ag{af2=a0| a1;} void inv ag{(agc>1?a1:LL[8])=-a0;}\nvoid rnt ag{av0=rdi();} void rch ag{av0=rdc();}\nvoid wnt ag{wti(av0);} void wch ag{OT[op++]=a0;}\nstruct Opt{void (*fun)(int,int**);int agc,**agv;}O[MAXN];\nunsigned int hsh(const char *s){\n    unsigned int h=0; for(int p=0;s[p]!=' '&&s[p]&&s[p]!='\\r'&&s[p]!='\\n';++p)\n    h=h*13331+s[p]; return h;\n}\nvoid (*FN[MAXV])(int,int**); int N[MAXV],V[MAXV];\nvoid rgf(const char *s,void(*fn)(int,int**)){unsigned int h=hsh(s)%MAXV; FN[h]=fn;}\nvoid rgv(const char *s,int vl){unsigned int h=hsh(s)%MAXV; N[h]=vl;}\nint main(){\n    int c,t=0,w=0,f=0; LL[11]=1;\n    rgf(\"function\",fnc),rgf(\"callfunc\",cal);\n    rgf(\"udef\",udf),rgf(\"hlt\" ,hlt),rgf(\"nop\" ,nop),rgf(\"set\" ,sst);\n    rgf(\"jmp\" ,jmp),rgf(\"jif\" ,jif),rgf(\"call\",cal),rgf(\"ret\" ,ret);\n    rgf(\"inv\" ,inv),rgf(\"add\" ,add),rgf(\"sub\" ,sub),rgf(\"mult\",mlt);\n    rgf(\"idiv\",div),rgf(\"mod\" ,mod),rgf(\"lsft\",lst),rgf(\"rsft\",rst);\n    rgf(\"band\",bnd),rgf(\"bor\" ,bor),rgf(\"bxor\",bxr),rgf(\"lgr\" ,lgr);\n    rgf(\"lls\" ,lls),rgf(\"lge\" ,lge),rgf(\"lle\" ,lle),rgf(\"leql\",leq);\n    rgf(\"land\",lnd),rgf(\"lor\" ,lor),rgf(\"rint\",rnt),rgf(\"rch\" ,rch);\n    rgf(\"wint\",wnt),rgf(\"wch\" ,wch);\n    rgv(\"r1\",0),rgv(\"r2\",1),rgv(\"r3\",2),rgv(\"r4\",3);\n    rgv(\"e1\",4),rgv(\"e2\",5),rgv(\"e3\",6),rgv(\"e4\",7);\n    rgv(\"r1\",0),rgv(\"r2\",1),rgv(\"r3\",2),rgv(\"r4\",3);\n    rgv(\"val\",8),rgv(\"flag\",9),rgv(\"ret\",10),rgv(\"line\",11);\n    scanf(\"%d\",&n); up(1,n,i){\n        while((c=getchar())=='\\r'||c=='\\n'); RD[len++]=c;\n        while((c=getchar())!='\\r'&&c!='\\n')  RD[len++]=c;\n        RD[len++]='!';\n    }\n    up(0,len-1,i){\n        if(RD[i]==',') RD[i]=' '; else if(RD[i]=='!'){++ll,L[ll]=m+1;continue;}\n        if(RD[i]=='[') ++f; else if(RD[i]==']') {--f;continue;} if(f) continue;\n        if(RD[i]==';'){\n            if(TP[t-1]==' ') --t,TP[t]=0;\n            O[++m].fun=FN[hsh(TP)%MAXV],R[m]=ll;\n            up(0,t-1,j) if(TP[j]==' ') ++O[m].agc; O[m].agv=new int*[O[m].agc];\n            up(0,t-1,j){\n                if(TP[j]!=' ') continue;\n                if(TP[j+1]=='%') O[m].agv[w++]=LL+N[hsh(TP+j+2)%MAXV];\n                else if(TP[j+1]=='#') O[m].agv[w++]=put(ll);\n                else if(TP[j+1]=='@'){\n                    if(TP[j+2]=='%') O[m].agv[w++]=RR+N[hsh(TP+j+2)%MAXV];\n                    else sscanf(TP+j+3,\"%d\",&tp),O[m].agv[w++]=M+tp;\n                } else if(TP[j+1]=='$'){\n                    unsigned int h=hsh(TP+j+2)%MAXV;\n                    if(O[m].fun==fnc) V[h]=ll; O[m].agv[w++]=V+h;\n                } else sscanf(TP+j,\"%d\",&tp),O[m].agv[w++]=put(tp);\n            }\n            memset(TP,0,t+3),t=w=0;\n        } else if(RD[i]!=' '||(RD[i]==' '&&t>0&&TP[t-1]!=' ')) TP[t++]=RD[i];\n        \n    }\n    pp=1,fread(IN,1,MAXM,stdin);\n    while(pp<=m&&O[pp].fun!=hlt){\n        LL[11]=R[pp],memcpy(WW,LL,sizeof(LL));\n        up(0,11,i) if(LL[i]>=0&&LL[i]<MAXM) RR[i]=M[LL[i]],VV[i]=RR[i];\n        O[pp].fun(O[pp].agc,O[pp].agv);\n        up(0,11,i) if(WW[i]>=0&&WW[i]<MAXM) if(RR[i]!=VV[i]) M[WW[i]]=RR[i];\n        ++pp;\n    }\n    fwrite(OT,1,op,stdout);\n    return 0;\n}\n```",
        "postTime": 1603548043,
        "uid": 330759,
        "name": "\u56e7\u4ed9",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "- \u5199\u4e86\u4e00\u4e2a\u622a\u6b62\u5230\u5f53\u524d\u4e3a\u6b62 ( 2022.1.28 ) \u6700\u77ed\u7684\u4ee3\u7801 $\\text{(2.63KB)}$ \u3002\u770b\u770b\u6709\u6ca1\u6709\u4eba\u80fd\u6253\u7834\u5427\u3002\n\n- \u8fd8\u80fd\u518d\u5c11\u4e00\u70b9\uff0c\u4f46\u90a3\u5c31\u592a\u538b\u4e86\u3002\n## \u89c2\u5bdf\n- \u9996\u5148\uff0c\u89c2\u5bdf\u5230 function \u8bed\u53e5\u548c callfunc \u8bed\u53e5\u90fd\u53ef\u4ee5\u7b80\u5355\u5730\u7528 set \u548c call \u8bed\u53e5\u66ff\u4ee3\u3002\n\n- \u7136\u540e\uff0c\u518d\u6ce8\u610f\u5230\u201c\u5982\u679c\u6ca1\u6709...\u90a3\u4e48\u5c31\u5b58\u5230...\u201d\u7684\u4e1c\u897f\u53ef\u4ee5\u5728\u6ca1\u6709\u67d0\u53c2\u6570\u65f6\u76f4\u63a5\u5728\u7f16\u8bd1\u65f6\u7528\u5bc4\u5b58\u5668\u503c\u66ff\u6362\u3002\n\n- \u63a5\u7740\uff0c\u4f60\u8981\u77e5\u9053\u6570\u636e\u4e2d\u662f\u6ca1\u6709\u4e00\u884c\u591a\u8bed\u53e5\u7684\u3002\n\n- \u5982\u679c\u53c8\u770b\u61c2 %Line \u5230\u5e95\u662f\u4ec0\u4e48\uff08\u5c31\u662f\u4e00\u4e2a\u4f1a\u88ab\u8df3\u884c\u8fd0\u7b97\u8bbf\u95ee\u5230\u7684\u666e\u901a\u5bc4\u5b58\u5668\uff09\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5f00\u5199\u4e86\u3002\n\n## \u6d41\u7a0b\n\n### \u7f16\u8bd1\u73af\u8282\n\n1. \u8bfb\u5165\u4e00\u884c\u6307\u4ee4\uff0c\u987a\u4fbf\u53bb\u6389\u6ce8\u91ca\u6254\u5230\u53e6\u4e00\u4e2a\u5b57\u7b26\u4e32\u91cc\u3002\n\n2. sscanf \u8bfb\u5165\u56db\u4e2a\u5b57\u7b26\u4e32\uff08\u6ce8\u610f\u5b57\u7b26\u4e32\u592a\u5c11\u65f6\u540e\u9762\u7684\u4e1c\u897f\u4e0d\u4f1a\u88ab\u6ce2\u53ca\u5230\uff09\n\n3. \u8fdb\u884c\u5bc4\u5b58\u5668\u503c\u7684\u66ff\u6362\u3002\n\n4. \u8fdb\u884c function \u548c callfunc \u7684\u66ff\u6362\n\n### \u8fd0\u884c\u73af\u8282\n\n\u5c31\u7b80\u5355\u5730\u8fd0\u884c\u3002\n\n### \u5982\u4f55\u51cf\u5c11\u7a0b\u5e8f\u957f\u5ea6\uff08\u4f7f\u4f60\u8c03\u8d77\u6765\u4e5f\u7b80\u5355\uff09\n1. \u9002\u5f53\u7528\u4e00\u4e9b\u5b8f\u5b9a\u4e49\u53bb\u6389\u91cd\u590d\u8bed\u53e5\n\n2. \u4e0d\u8981\u7528\u51fd\u6570\u8868\uff0c\u76f4\u63a5\u5728 switch \u8bed\u53e5\u4e2d\u5b8c\u6210\uff0c\u51fd\u6570\u5b9a\u4e49\u5f88\u8d39\u5b57\u6570\uff08\u8fd4\u56de\u503c\u3001\u5f62\u53c2\u5217\u8868\u3001\u4e00\u5bf9\u82b1\u62ec\u53f7\u3001\u51fd\u6570\u540d\uff09\n## \u4ee3\u7801\n```cpp\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<map>\nchar a[2007];\nchar b[50007][2007];\nchar c[50007][17];\nchar d[50007][17];\nchar cach[2007];\nchar typ[50007];\nint fnum[50007];\nint mem[1<<24];\nint sAddr[1<<20],*top=sAddr;\nint r[4],e[4],flg,vl,rt,ln;\ntypedef std::string str;\nstd::map<str,int> mp;\nstd::map<str,char> ls={{\"udef\",0},{\"hlt\",1},{\"nop\",2},{\"set\",3},{\"jmp\",4},{\"jif\",5},{\"call\",6},{\"ret\",7},{\"inv\",8},{\"add\",9},{\"sub\",10},{\n\"mult\",11},{\"idiv\",12},{\"mod\",13},{\"lsft\",14},{\"rsft\",15},{\"band\",16},{\"bor\",17},{\"bxor\",18},{\"lgr\",19},{\"lls\",20},\n{\"lge\",21},{\"lle\",22},{\"leql\",23},{\"land\",24},{\"lor\",25},{\"rint\",26},{\"rch\",27},{\"wint\",28},{\"wch\",29},{\"function\",30},{\"callfunc\",31}};\nint& gvl(const char* x)\n{\n\tif(*x=='@')return mem[gvl(x+1)];\n\tif(*x=='%')switch(x[1])\n\t{\n\t\tcase 'r':return x[2]=='e'?rt:r[x[2]-'1'];\n\t\tcase 'e':return e[x[2]-'1'];\n\t\tcase 'f':return flg;\n\t\tcase 'v':return vl;\n\t\tcase 'l':return ln;\n\t}\n\treturn *(new int(atoi(x)));\n}\nint main()\n{\n\tint n,ct=0,C=1;\n\tchar* l;\n\tscanf(\"%d\",&n);getchar(); \n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%[^\\n]\",a+1);\n\t\tgetchar();l=cach;\n\t\tfor(int j=1;a[j];++j)\n\t\t\tif(a[j]=='[')++ct;\n\t\t\telse if(a[j]==']')ct=ct?ct-1:0;\n\t\t\telse if(!ct)*l++=a[j];\n\t\twhile(*--l==' ');*l='\\0';\n\t\tsscanf(cach,\"%s%s%s%s\",a,b[i],c[i],d[i]);typ[i]=ls[str(a)];\n\t\tif(typ[i]==5&&!*c[i])strcpy(c[i],\"%flag\");\n\t\tif(typ[i]==7&&!*b[i])strcpy(b[i],\"%ret\");\n\t\tif(typ[i]==8&&!*c[i])strcpy(c[i],\"%val\");\n\t\tif(typ[i]>=9&&typ[i]<=18&&!*d[i])strcpy(d[i],\"%val\");\n\t\tif(typ[i]>=19&&typ[i]<=25&&!*d[i])strcpy(d[i],\"%flag\");\n\t\tif(typ[i]>=26&&typ[i]<=29&&!*b[i])strcpy(b[i],\"%val\");\n\t\tif(typ[i]==30)mp[b[i]]=i,typ[i]=3,sprintf(b[i],\"%d\",i),strcpy(c[i],\"%line\");\n\t}\n\tfor(int i=1;i<=n;++i)if(typ[i]==31)sprintf(b[i],\"%d\",mp[b[i]]),typ[i]=6;\n#define ts gvl(d[C])\n#define ls gvl(b[C])\n#define rs gvl(c[C])\n#define gt ++C;break;\n\twhile(1)switch(typ[C])\n\t{\ncase 1:return 0;\ncase 3:gvl(c[C])=gvl(b[C]);gt;\ncase 4:C=ln+gvl(b[C]);break;\ncase 5:C=(gvl(c[C]))?ln+gvl(b[C]):C+1;break;\ncase 6:*top++=ln;*top++=C+1;C=gvl(b[C]);break;\ncase 7:rt=gvl(b[C]);C=*--top;ln=*--top;break;\ncase 8:rs=-ls;gt\ncase 9: ts=ls+rs;gt\ncase 10:ts=ls-rs;gt\ncase 11:ts=ls*rs;gt\ncase 12:ts=ls/rs;gt\ncase 13:ts=ls%rs;gt\ncase 14:ts=ls<<rs;gt\ncase 15:ts=ls>>rs;gt\ncase 16:ts=ls&rs;gt\ncase 17:ts=ls|rs;gt\ncase 18:ts=ls^rs;gt\ncase 19:ts=ls>rs;gt\ncase 20:ts=ls<rs;gt\ncase 21:ts=ls>=rs;gt\ncase 22:ts=ls<=rs;gt\ncase 23:ts=ls==rs;gt\ncase 24:ts=ls&&rs;gt\ncase 25:ts=ls||rs;gt\ncase 26:scanf(\"%d\",&ls);gt\ncase 27:scanf(\"%c\",&ls);gt\ncase 28:printf(\"%d\",ls);gt\ncase 29:printf(\"%c\",ls);gt\ndefault:gt\n\t}\n}\n```\n",
        "postTime": 1643377430,
        "uid": 151415,
        "name": "Edward1002001",
        "ccfLevel": 7,
        "title": "\u9898\u89e3\uff1aLGOJT4911 \u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a"
    },
    {
        "content": "\u554a\u8fd9\uff0c\u8c8c\u4f3c\u662f\u7b2c\u4e00\u4efd JavaAC \u6b38\u3002\n\n\u4e00\u904d\u8fc7\uff08\u662f\u6570\u636e\u592a\u6c34\u4e86\u5927\u6982\u54b3\u54b3\uff09\n\n\u867d\u7136\u597d\u50cf\u8bc4\u8bba\u533a\u8bf4\u6570\u636e\u6709\u4e9b\u6307\u4ee4\u6ca1\u6709\u7136\u800c\u8fd8\u662f\u90fd\u5199\u4e86\uff0c\u6ca1\u770b\u5230\u6ca1\u7a7a\u884c\u6240\u4ee5\u7a7a\u884c\u4e5f\u5904\u7406\u4e86\u4e00\u4e0b\u3002\n\n\u6211\u6000\u7591\u6709 bug \u4f46\u6570\u636e\u6d4b\u8bd5\u4e0d\u51fa\u6765\uff08\u5c0f\u58f0\n\n\uff08\u55ef\uff0c\u8fd9\u6b21 O2 \u53c8\u662f\u4f1a\u9006\u5411\u4f18\u5316\uff09\n\n\u662f\u521a\u5b66\u4e86 Java \u7528\u6765\u5de9\u56fa\u5199\u7684 emm \uff0c\u6240\u4ee5\u4e5f\u505a\u4e86\u5947\u602a\u7684\u5c01\u88c5\u4ec0\u4e48\u7684\uff0c\u4e5f\u6ca1\u6709\u6ce8\u91cd\u4ee3\u7801\u957f\u5ea6\u548c\u6548\u7387\uff0c\u5199\u957f\u70b9\u591a\u723d\u554a\uff08\u66b4\u8bba\n\n\u540e\u534a\u90e8\u5206\u5199\u5f97\u6bd4\u8f83\u80bf\uff0c\u4e3b\u8981\u662f\u770b\u4e0d\u6e05\u4e86\u8981\u3002\n\n------------\n\n\u5177\u4f53\u561b\u5c31\u662f\u5047\u88c5\u8bcd\u6cd5\u5206\u6790\u4e00\u4e0b\uff08\u89c1 ```public void Compiler.Lexer()```\n \uff09\u3002\u8fd9\u91cc\u9762\u662f\u5148\u5272\u8bcd\uff0c\u7136\u540e\u8bc6\u522b\u5230\u6807\u8bc6\u7b26\u518d\u5411\u524d\u5f52\u7eb3\u548c\u53ef\u80fd\u5b58\u5728\u7684 ```%, @``` \u4e4b\u7c7b\u7684\u5408\u5e76\u8d77\u6765\u53d8\u6210\u53d8\u91cf\u3002\n\n\u6309\u8bcd\u5206\u597d\uff0c\u6309\u884c\u5206\u597d\uff0c\u7136\u540e\u6267\u884c\uff08\u89c1 ```public void Interpreter.run()``` \uff09\u3002\n\n\u8fd0\u884c\u524d\u8fd8\u8981\u5904\u7406\u4e00\u4e0b\u51fd\u6570\u5730\u5740\uff08\u89c1 ```public void Interpreter.loadup()``` \uff09\u3002\n\n\u4e3a\u4e86\u4f53\u73b0\u9762\u5411\u5bf9\u8c61\u5404\u79cd\u7ed3\u6784\u90fd\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u7c7b\uff08 ```CPU, Memory, Compiler, Interpreter, Stream, IStream, OStream``` \uff09\u3002\n\n ```sAddr``` \u6808\u548c\u5404\u79cd\u5bc4\u5b58\u5668\u5728 ```CPU``` \u7c7b\u91cc\uff0c\u5185\u5b58\u5c31\u662f\u5185\u5b58\u3002\n\n```class IStream extends Stream``` \u548c ```class OStream extends Stream``` \u5206\u522b\u6a21\u62df\u8f93\u5165\u8f93\u51fa\u6d41\u3002\n\n\u5404\u81ea\u6210\u5458\u53d8\u91cf\u90fd\u8bbe\u4e3a ```private``` \u505a\u4e86\u5c01\u88c5\uff08\u81ea\u8650\uff09\u3002\n\n\u6240\u4ee5 ```main``` \u51fd\u6570\u770b\u8d77\u6765\u5f88\u8212\u670d\u54b3\u54b3\u3002\n\n\u6240\u4ee5\u5168\u6536\u8d77\u6765\u4e4b\u540e\u6bd4\u8f83\u6e05\u6670\uff1a\n\n```java\nimport java.util.*;\n\n// \u5185\u5b58\nclass Memory {...}\n\n// \u5904\u7406\u5668\nclass CPU {...}\n\n// \u6d41\nclass Stream {...}\n\n// \u8f93\u5165\u6d41 extends \u6d41\nclass IStream extends Stream {...}\n\n// \u8f93\u51fa\u6d41 extends \u6d41\nclass OStream extends Stream {...}\n\n// \u7f16\u8bd1\u5668\uff08\u4f2a\nclass Compiler {...}\n\n// \u89e3\u91ca\u5668\uff08\u4f2a\nclass Interpreter {...}\n\npublic class Main {\n    public static void main(String[] args) {...}\n}\n```\n\n------------\n\n\u6700\u540e\u8d34\u4e0a\u4ee3\u7801\uff0c\u5199\u4e86\u4e0d\u5c11\u6ce8\u91ca\uff1a\n\n```java\nimport java.util.*;\n\n// \u5185\u5b58\nclass Memory {\n    // 0 - 1677216\n    private int[] data = new int[16777300];\n\n    // \u6784\u9020\u51fd\u6570\n    Memory() {\n        Arrays.fill(data, 0);\n    }\n\n    // \u8c03\u53d6\u548c\u8bbe\u7f6e\u65b9\u6cd5\n    public int getAddr(int _a) {\n        return data[_a];\n    }\n    public void setAddr(int _a, int _d) {\n        data[_a] = _d;\n    }\n}\n\n// \u5904\u7406\u5668\nclass CPU {\n    // \u6808\u5143\u7d20\n    private class Tsta {\n        int next;\n        int line;\n\n        Tsta(int next, int line) {\n            this.next = next;\n            this.line = line;\n        }\n    }\n\n    // \u6808\n    private Stack<Tsta> sAddr = new Stack<>();\n\n    // \u5bc4\u5b58\u5668\n    private int R1 = 0, R2 = 0, R3 = 0, R4 = 0;\n    private int E1 = 0, E2 = 0, E3 = 0, E4 = 0;\n    private int Flag = 0, Val = 0, Ret = 0, Line = 0;\n\n    // \u8c03\u53d6\u548c\u8bbe\u7f6e\u65b9\u6cd5\n    public int Get(String name) {\n        switch (name) {\n            case \"r1\": return R1;\n            case \"r2\": return R2;\n            case \"r3\": return R3;\n            case \"r4\": return R4;\n            case \"e1\": return E1;\n            case \"e2\": return E2;\n            case \"e3\": return E3;\n            case \"e4\": return E4;\n            case \"flag\": return Flag;\n            case \"val\": return Val;\n            case \"ret\": return Ret;\n            case \"line\": return Line;\n        }\n        return 0;\n    }\n    public void Set(String name, int t) {\n        switch (name) {\n            case \"r1\": R1 = t; break;\n            case \"r2\": R2 = t; break;\n            case \"r3\": R3 = t; break;\n            case \"r4\": R4 = t; break;\n            case \"e1\": E1 = t; break;\n            case \"e2\": E2 = t; break;\n            case \"e3\": E3 = t; break;\n            case \"e4\": E4 = t; break;\n            case \"flag\": Flag = t; break;\n            case \"val\": Val = t; break;\n            case \"ret\": Ret = t; break;\n            case \"line\": Line = t; break;\n        }\n    }\n    public void push(int next, int line) {\n        sAddr.push(new Tsta(next, line));\n    }\n    public int pop() {\n        // \u5f39\u6808\u8fd4\u56de\u76ee\u6807\u884c\uff0c\u5e76\u590d\u4f4d%Line\n        Tsta t = sAddr.pop();\n        Line = t.line;\n        return t.next;\n    }\n}\n\n// \u6d41\nclass Stream {\n    // \u6570\u636e\n    private ArrayList<String> data = new ArrayList<>();\n\n    // \u8c03\u53d6\u548c\u8bbe\u7f6e\u65b9\u6cd5\n    public ArrayList<String> get() {\n        return data;\n    }\n    public void add(String s) {\n        data.add(s);\n    }\n}\n\n// \u8f93\u5165\u6d41 extends \u6d41\nclass IStream extends Stream {\n    // \u6307\u9488\n    private int current = 0;\n\n    // \u662f\u5426\u4e3a\u7a7a\u767d\u7b26\n    private boolean isWhite(char _peek) {\n        return _peek == ' ' || _peek == '\\t';\n    }\n\n    // \u6784\u9020\u51fd\u6570\uff0c\u6309\u7a7a\u767d\u7b26\u5212\u8bcd\n    IStream() {}\n    IStream(Stream _in) {\n        for (String _line : _in.get()) {\n            int len = _line.length();\n            int j = 0;\n            for (int i = 1; i < len; i++) {\n                // \u8bcd\u5c3e\n                if (isWhite(_line.charAt(i)) && !isWhite(_line.charAt(i - 1))) {\n                    add(_line.substring(j, i));\n                }\n                // \u8bcd\u5934\uff0c\u5934\u6307\u9488\u66f4\u65b0\n                if (!isWhite(_line.charAt(i)) && isWhite(_line.charAt(i - 1))) {\n                    j = i;\n                }\n            }\n            // \u884c\u672b -> \u8bcd\u5c3e\n            add(_line.substring(j));\n        }\n    }\n\n    // \u6309\u5e8f\u8bfb\u53d6\n    public String getNext() {\n        return get().get(current++);\n    }\n}\n\n// \u8f93\u51fa\u6d41 extends \u6d41\nclass OStream extends Stream {\n    // \u8f93\u51fa\n    public void output() {\n        for (String _l : get()) {\n            System.out.print(_l);\n        }\n    }\n}\n\n// \u7f16\u8bd1\u5668\uff08\u4f2a\nclass Compiler {\n    // \u8bcd\n    private class Ttoken {\n        // \u8bcd\u7c7b\u578b\n        private int type = 0;\n\n        // \u8bcd\u5c5e\u6027\n        private String property;\n\n        // \u6784\u8bcd\u6cd5\n        Ttoken(int type, String property) {\n            this.type = type;\n            this.property = property;\n        }\n\n        // \u8c03\u53d6\u548c\u8bbe\u7f6e\u65b9\u6cd5\n        public int getT() {\n            return type;\n        }\n        public void setT(int type) {\n            this.type = type;\n        }\n        public String getP() {\n            return property;\n        }\n        public void setP(String property) {\n            this.property = property;\n        }\n    }\n\n    // \u8bcd\u8868\n    private ArrayList<Ttoken> tokens = new ArrayList<>();\n\n    // \u53e5\u9996\u8bcd\u8868\n    private ArrayList<Integer> cmds = new ArrayList<>();\n\n    // \u662f\u5426\u4e3a\u7a7a\u767d\u7b26\n    private boolean isWhite(char _peek) {\n        return _peek == ' ' || _peek == '\\t';\n    }\n\n    // \u662f\u5426\u4e3a\u6807\u8bc6\u7b26\u5b57\u7b26\n    private boolean isLetter(char _peek) {\n        return _peek >= 'A' && _peek <= 'z' || _peek >= '0' && _peek <= '9';\n    }\n\n    // \u8bcd\u6cd5\u5206\u6790\uff0c\u5e76\u8bb0\u5f55\u53e5\u9996\u8bcd\n    public void Lexer(Stream _code) {\n        int anno = 0;\n        cmds.add(0); // \u884c\u53f7\u4ece1\u5f00\u59cb\u6807\u8bb0\n        for (String _line : _code.get()) {\n            cmds.add(tokens.size());\n            int len = _line.length();\n            for (int i = 0; i < len; i++) {\n                char _peek = _line.charAt(i);\n                // \u7a7a\u767d\u3001\u6ce8\u91ca\u5904\u7406\n                if (_peek == '[') {\n                    anno++;\n                    continue;\n                }\n                if (_peek == ']') {\n                    anno--;\n                    continue;\n                }\n                if (anno != 0 || isWhite(_peek)) continue;\n\n                // \u7279\u6b8a\u7b26\u53f7\n                if (_peek == '%') {\n                    tokens.add(new Ttoken(-1, \"\"));\n                    continue;\n                }\n                if (_peek == '@') {\n                    tokens.add(new Ttoken(-2, \"\"));\n                    continue;\n                }\n                if (_peek == '#') {\n                    tokens.add(new Ttoken(-3, \"\"));\n                    continue;\n                }\n                if (_peek == '$') {\n                    tokens.add(new Ttoken(-4, \"\"));\n                    continue;\n                }\n                if (_peek == ';') {\n                    tokens.add(new Ttoken(-5, \"\"));\n                    continue;\n                }\n\n                // \u6807\u8bc6\u7b26\n                tokens.add(new Ttoken(1,\"\" + _peek));\n                if (i < len - 1) {\n                    _peek = _line.charAt(++i);\n                    while (i < len && isLetter(_peek)) {\n                        tokens.get(tokens.size() - 1).property += _peek;\n                        _peek = _line.charAt(++i);\n                    }\n                    i--;\n                }\n\n                // \u6807\u8bc6\u7b26\u5411\u524d\u5f52\u7eb3\n                if (tokens.size() <= 2) continue;\n                Ttoken A = tokens.get(tokens.size() - 3);\n                Ttoken B = tokens.get(tokens.size() - 2);\n                Ttoken C = tokens.get(tokens.size() - 1);\n                if (A.type == -2 && B.type == -1) {\n                    A.type = 4;\n                    A.property = C.property;\n                    tokens.remove(tokens.size() - 1);\n                    tokens.remove(tokens.size() - 1);\n                    continue;\n                } // @%... -> 4\n                if (B.type == -1) {\n                    B.type = 2;\n                    B.property = C.property;\n                    tokens.remove(tokens.size() - 1);\n                    continue;\n                } // %... -> 2\n                if (B.type == -2) {\n                    B.type = 3;\n                    B.property = C.property;\n                    tokens.remove(tokens.size() - 1);\n                    continue;\n                } // @... -> 3\n                if (B.type == -3) {\n                    B.type = 5;\n                    B.property = C.property;\n                    tokens.remove(tokens.size() - 1);\n                    continue;\n                } // #... -> 5\n                if (B.type == -4) {\n                    B.type = 6;\n                    B.property = C.property;\n                    tokens.remove(tokens.size() - 1);\n                    // continue;\n                } // $... -> 6\n            }\n        }\n        cmds.add(cmds.get(cmds.size() - 1) + 1); // \u7ed3\u5c3e\u52a0\u7a7a\u884c\u9632\u6b62ptr+1\u6ea2\u51fa\n    }\n\n    // \u83b7\u53d6\u7b2c_n\u884c\u53e5\u9996\u8bcd\u7f16\u53f7\n    public Integer getCmd(int _n) {\n        return cmds.get(_n);\n    }\n\n    // \u83b7\u53d6\u7b2c_n\u4e2a\u8bcd\n    public int GetT(int _n) {\n        return tokens.get(_n).type;\n    }\n    public String GetP(int _n) {\n        return tokens.get(_n).property;\n    }\n}\n\n// \u89e3\u91ca\u5668\uff08\u4f2a\nclass Interpreter {\n    // \u5904\u7406\u5668\n    private CPU cpu = new CPU();\n\n    // \u5185\u5b58\n    private Memory mem = new Memory();\n\n    // \u5f53\u524d\u6267\u884c\u884c\u53f7\uff0c\u5373#Line\n    private int ptr;\n\n    // \u51fd\u6570\u5934\u884c\u53f7\u8bb0\u5f55\n    private HashMap<String, Integer> func = new HashMap<>();\n\n    // \u51fd\u6570\u52a0\u8f7d\u5668\n    public void loadup(int _n, Compiler com) {\n        for (int i = 1; i <= _n; i++) {\n            if (com.getCmd(i + 1).equals(com.getCmd(i))) continue;\n            int num = com.getCmd(i);\n            if (com.GetP(num).contains(\"function\")) {\n                func.put(com.GetP(num + 1), i); // \u5173\u8054\u51fd\u6570\u540d\u4e0e\u884c\u53f7\n            }\n        }\n    }\n\n    // \u83b7\u53d6\u53d8\u91cf\u503c\n    public int FET(int ty0, String pr0) {\n        switch (ty0) {\n            case -1: return (int)pr0.charAt(0);\n            case 1: return Integer.parseInt(pr0);\n            case 2: return cpu.Get(pr0);\n            case 3: return mem.getAddr(Integer.parseInt(pr0));\n            case 4: return mem.getAddr(cpu.Get(pr0));\n            case 5: return ptr;\n            case 6: return func.get(pr0);\n        }\n        return 0;\n    }\n\n    // SET\u64cd\u4f5c\n    public void SET(int ty0, String pr0, int ty1, String pr1) {\n        int arg0 = FET(ty0, pr0);\n        switch (ty1) {\n            case 2: cpu.Set(pr1, arg0); break;\n            case 3: mem.setAddr(Integer.parseInt(pr1), arg0); break;\n            case 4: mem.setAddr(cpu.Get(pr1), arg0); break;\n        }\n    }\n\n    // \u8fd0\u884c\n    public void run(Compiler com, IStream in, OStream out) {\n        ptr = 1;\n        while (true) {\n            if (com.getCmd(ptr + 1).equals(com.getCmd(ptr))) {\n                ptr++;\n                continue;\n            }\n            if (com.GetP(com.getCmd(ptr)).contains(\"hlt\")) {\n                break;\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"set\")) {\n                SET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1),\n                    com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"jmp\")) {\n                ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                    + cpu.Get(\"line\");\n                continue;\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"jif\")) {\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {\n                    if (cpu.Get(\"flag\") == 1) {\n                        ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                                + cpu.Get(\"line\");\n                        continue;\n                    }\n                } else {\n                    if (FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) != 0) {\n                        ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                                + cpu.Get(\"line\");\n                        continue;\n                    }\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"call\")) {\n                cpu.push(ptr + 1, cpu.Get(\"line\")); // \u538b\u6808\n                ptr = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)); // \u8df3\u8f6c\u81f3\u51fd\u6570\n                cpu.Set(\"line\", ptr); // \u8bbe\u7f6e\u5f53\u524d\u51fd\u6570\u5934\n                continue;\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"ret\")) {\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {\n                    cpu.Set(\"ret\", FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))); // \u8fd4\u56de\u503c\n                }\n                ptr = cpu.pop(); // \u5f39\u6808\u5e76\u8df3\u56de\uff0c\u540c\u65f6\u590d\u4f4d%Line\n                continue;\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"inv\")) {\n                int t = - FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 3) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"add\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        + FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"sub\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        - FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"mult\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        * FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"idiv\")) {\n                int t = (int)Math.floor(1.0d * FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        / FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"mod\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        % FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lsft\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        << FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"rsft\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        >> FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"band\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        & FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"bor\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        | FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"bxor\")) {\n                int t = FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        ^ FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2));\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"val\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lgr\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        > FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lls\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        < FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lge\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        >= FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lle\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        <= FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"leql\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))\n                        == FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)))?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"land\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)) == 1\n                        && FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) == 1)?1:0;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"lor\")) {\n                int t = (FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)) == 0\n                        && FET(com.GetT(com.getCmd(ptr) + 2), com.GetP(com.getCmd(ptr) + 2)) == 0)?0:1;\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 4) {\n                    cpu.Set(\"flag\", t);\n                } else {\n                    SET(1, ((Integer)t).toString(), com.GetT(com.getCmd(ptr) + 3), com.GetP(com.getCmd(ptr) + 3));\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"rint\")) {\n                SET(1, in.getNext(), com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"rch\")) {\n                SET(-1, in.getNext(), com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1));\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"wint\")) {\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 2) {\n                    out.add(((Integer) cpu.Get(\"val\")).toString());\n                } else {\n                    out.add(((Integer) FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1))).toString());\n                }\n            } else if (com.GetP(com.getCmd(ptr)).contains(\"wch\")) {\n                if (com.getCmd(ptr + 1) - com.getCmd(ptr) == 2) {\n                    out.add(\"\" + (char)cpu.Get(\"val\"));\n                } else {\n                    out.add(\"\" + (char)FET(com.GetT(com.getCmd(ptr) + 1), com.GetP(com.getCmd(ptr) + 1)));\n                }\n            }\n            ptr++; // \u9664\u8df3\u8f6c\u8bed\u53e5\u5916\uff0c\u884c\u53f7\u6307\u9488\u9ed8\u8ba4+1\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        // \u521b\u5efaScanner\u5bf9\u8c61\n        Scanner scanner = new Scanner(System.in);\n\n        // \u8bfb\u5165\u7a0b\u5e8f\n        Stream code = new Stream();\n        int totalLines = scanner.nextInt();\n        scanner.nextLine();\n        for (int i = 0; i < totalLines; i++) {\n            code.add(scanner.nextLine());\n        }\n\n        // \u8bfb\u5165\u8f93\u5165\u5e76\u52a0\u8f7d\u81f3\u8f93\u5165\u6d41\n        Stream input = new Stream();\n        while (scanner.hasNextLine()) {\n            input.add(scanner.nextLine());\n        }\n        IStream in = new IStream(input);\n\n        // \u7f16\u8bd1\uff0c\u6570\u636e\u4fdd\u8bc1\u65e0\u7f16\u8bd1\u9519\u8bef\n        Compiler compiler = new Compiler();\n        compiler.Lexer(code);\n\n        // \u89e3\u91ca\uff0c\u6570\u636e\u4fdd\u8bc1\u65e0\u8fd0\u884c\u65f6\u9519\u8bef\n        Interpreter interpreter = new Interpreter();\n        OStream out = new OStream();\n        interpreter.loadup(totalLines, compiler);\n        interpreter.run(compiler, in, out);\n\n        // \u8f93\u51fa\n        out.output();\n    }\n}\n```\n",
        "postTime": 1626495342,
        "uid": 30153,
        "name": "Gralerfics",
        "ccfLevel": 0,
        "title": "\u3010P4911\u3011Java\u9898\u89e3"
    },
    {
        "content": "Update at June 30th\n\n\u8fd9\u9053\u9898\u76ee\u6700\u91cd\u8981\u7684\u5c31\u662f**\u5b9e\u73b0\u6307\u4ee4\u7684\u64cd\u4f5c**\n\n\u7136\u540e\u5b9e\u73b0\u64cd\u4f5c\u79bb\u4e0d\u5f00**\u53d8\u91cf\u4e0e\u5185\u5b58\u7cfb\u7edf**\u3002\n\n\u6240\u4ee5\u6211\u4eec\u5fc5\u987b\u5148\u5b9e\u73b0**\u5185\u5b58\u7cfb\u7edf**\uff0c\u7136\u540e\u624d\u80fd\u591f\u8fdb\u884c\u4e0b\u4e00\u6b65\u7684\u5de5\u4f5c\u3002\n\n=====\u6b63\u6587\u5206\u5272\u7ebf=====\n\n## 1.\u5185\u5b58\u7cfb\u7edf\n\n\u5185\u5b58\u7cfb\u7edf\u4e2d\u5305\u542b\u5bc4\u5b58\u5668\uff0c\u8fd9\u4e2a\u76f8\u5bf9\u597d\u6a21\u62df\uff0c\u76f4\u63a5**\u4f7f\u7528\u53d8\u91cf**\u4fdd\u5b58\u5373\u53ef\n\n\u8fd8\u5305\u542b\u8bb8\u591a\u5185\u5b58\u5355\u5143\uff0c\u800c\u4e14\u6709\u5730\u5740\uff0c\u8fd9\u65f6\u6211\u4eec\u7528\u4e00\u4e2a**\u6570\u7ec4**\u6765\u5145\u5f53\u5c31\u884c\u4e86\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5728\u8bbf\u95ee\u53d8\u91cf\u65f6\u6211\u4eec\u8981\u5224\u65ad\u662f\u4ec0\u4e48\u7c7b\u578b\u7684\u53d8\u91cf\uff1a\n\n- \u5982\u679c\u662f**\u5e38\u91cf**\u5c31\u76f4\u63a5\u8fd4\u56de\uff1b\n\n- \u5982\u679c\u662f**\u5185\u5b58\u5730\u5740**\u5c31\u53bb\u6570\u7ec4\u91cc\u627e\u5bf9\u5e94\u7684\u503c\uff1b\n\n- \u5982\u679c\u662f**\u5bc4\u5b58\u5668**\u5c31\u53bb\u53d6\u5bf9\u5e94\u7684\u53d8\u91cf\uff0c\u8fd9\u91cc\u6211\u7528\u4e86 12 \u4e2a ```if``` \u8bed\u53e5\u53bb\u9010\u4e00\u5224\u65ad\uff1b\n\n- \u5982\u679c\u662f ```@%``` \u5f00\u5934\u7684\uff0c\u5c31\u5206\u6b65\u8ba1\u7b97\uff1a\u5148\u627e\u5bc4\u5b58\u5668\uff0c\u518d\u627e\u5185\u5b58\u3002\n\n\u6709\u4e00\u4e9b\u7ec6\u8282\uff08\u6bd4\u5982\u7f16\u8bd1\u671f\u5e38\u91cf ```#line```\uff09\u9700\u8981\u6ce8\u610f\u53bb\u5b9e\u73b0\uff0c\u53ef\u53c2\u89c1\u4ee3\u7801\u3002\n\n## 2.\u6307\u4ee4\u7cfb\u7edf\n\n\u6307\u4ee4\u8fd8\u884c\uff0c\u6309\u7167\u9898\u76ee\u610f\u601d\u53bb\u6a21\u62df\u5373\u53ef\uff0c\u7b97\u672f\u6307\u4ee4\u4ee3\u7801\u91cf\u5927\uff0c\u597d\u5728\u601d\u7ef4\u96be\u5ea6\u4e0d\u9ad8\n\n**\u5224\u65ad\u7b2c\u4e00\u4e2a\u5b57\u7b26\u4e32**\u5c31\u53ef\u4ee5\u77e5\u9053\u662f\u4ec0\u4e48\u7c7b\u578b\u7684\u6307\u4ee4\u4e86\uff0c\u7136\u540e\u6309\u7167\u4e0a\u9762\u6240\u8bf4\u7684\u65b9\u5f0f\u53bb\u83b7\u53d6\u64cd\u4f5c\u6570\n\n\u53e6\u5916\uff1a\n\n\u6ce8\u610f\u5224\u65ad\u64cd\u4f5c\u6570\u4e2a\u6570\n\n\u6ce8\u610f\u5224\u65ad\u64cd\u4f5c\u6570\u4e2a\u6570\uff01\n\n**\u6ce8\u610f\u5224\u65ad\u64cd\u4f5c\u6570\u4e2a\u6570\uff01\uff01\uff01**\n\n\u5f88\u5bb9\u6613\u5728\u8fd9\u91cc\u5361\u4f4f\uff08\u4e8b\u5b9e\u4e0a\u6211\u5c31\u662f\u8fd9\u6837\uff09\uff0c\u56e0\u4e3a\u5982\u679c\u64cd\u4f5c\u6570\u4e0d\u591f\u8981\u628a\u8fd0\u884c\u7ed3\u679c\u653e\u5230 ```%val``` \u5bc4\u5b58\u5668\u5f53\u4e2d\u3002\n\n\u7136\u540e\u6bd4\u8f83\u96be\u7684\u5c31\u662f**\u8c03\u7528** ```call``` \u548c**\u8df3\u8f6c** ```jmp``` \u6307\u4ee4\n\n\u600e\u4e48\u529e\u5462\uff1f\n\n\u5176\u5b9e\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u989d\u5916\u7684\u53d8\u91cf ```line``` \u6765\u4ee3\u8868\u201c\u5f53\u524d\u8fd0\u884c\u5230\u7a0b\u5e8f\u7684\u54ea\u4e00\u884c\u201d\uff0c\u8fd9\u6837\u5c31\u987a\u624b\u89e3\u51b3\u4e86 ```#line``` \u5e38\u91cf\u7684\u95ee\u9898\u3002\n\n```call``` \u6307\u4ee4\u8fd8\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a**\u8c03\u7528\u6808**\n\n**\u4ec0\u4e48\uff1f\u4e0d\u77e5\u9053\u4ec0\u4e48\u662f\u8c03\u7528\u6808\uff1f\uff1f\uff1f**\n\n\u3002\u3002\u3002\u3002\u3002\u3002\u770b\u8fc7\u6765\uff0c\u4e0b\u9762\u662f\u7b80\u5355\u7684\u89e3\u91ca\uff1a\n\n\u5728\u4e00\u4e2a\u7ebf\u7a0b\u4e2d\uff08\u53ef\u80fd\u4e0d\u662f\u5f88\u4e25\u8c28\uff0c\u671b\u5305\u6db5\uff09\uff0c\u540c\u4e00\u65f6\u523b\u53ea\u80fd\u6709\u4e00\u4e2a\u51fd\u6570\u5728\u8fd0\u884c\n\n\u4e5f\u5c31\u662f CPU \u63a7\u5236\u6743\u662f\u5728\u8fd9\u4e2a\u51fd\u6570\u7684\u6808\u5e27\u4e0a\u7684\uff0c\n\n\u7136\u540e\u5462\uff0c\u8fd9\u4e2a\u51fd\u6570\u8fd0\u884c\u5b8c\u4e4b\u540e\uff0cCPU \u63a7\u5236\u6743\u4f1a\u56de\u5230\u8fd9\u4e2a\u51fd\u6570\u7684\u8c03\u7528\u8005\u8eab\u4e0a\n\n\u6240\u4ee5\u8bf4\uff0c\u6bcf\u8c03\u7528\u4e00\u5c42\u51fd\u6570\uff0c\u63a7\u5236\u6743\u5c31\u4f1a\u5230\u8fd9\u4e2a\u51fd\u6570\u8eab\u4e0a\uff1b\n\n\u7136\u540e\u8c03\u7528\u5b8c\uff0c\u56de\u5230\u8c03\u7528\u8005\u8eab\u4e0a\n\n**\u8fd9\u4e0d\u5c31\u662f\u4e00\u4e2a\u5148\u8fdb\u540e\u51fa\u7684\u6808\u5417\uff1f**\n\n\u5728\u672c\u9053\u9898\u4e2d\u5c31\u662f\u4f7f\u7528\u6808\u4fdd\u5b58\u5f53\u524d ```line``` \u7684\u503c\n\n\u6bcf\u6b21\u8fd4\u56de\u90fd\u5f39\u51fa\u6808\u9876\n\n\u603b\u4e4b\uff0c\u8c03\u7528 ```call``` \u65f6\u8c03\u7528\u6808 push\uff1b\u8fd4\u56de\u65f6\u8c03\u7528\u6808 pop\uff0c\u89e3\u51b3\u3002\n\n## 3. \u8bfb\u53d6\u7cfb\u7edf\n\n\u8bfb\u53d6\u65f6\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u5ffd\u7565\u6ce8\u91ca\n\n\u5f53\u68c0\u6d4b\u5230**\u6ca1\u6709\u95ed\u5408\u7684\u4e2d\u62ec\u53f7** ```[]``` \u65f6\u5c31**\u53ea\u8bfb\u5165\u5b57\u7b26\u4e0d\u9001\u8fdb\u6307\u4ee4\u6d41**\n\n\u5728\u4e13\u4e1a\u7684\u4ee3\u7801\u7f16\u8bd1 / \u89e3\u91ca\u5668\u4e2d\uff08\u6bd4\u5982\u6d4f\u89c8\u5668\u7684 HTML \u89e3\u6790\uff09\uff0c\u8fd0\u884c\u65b9\u5f0f\u5982\u4e0b\uff1a\n\n- \u5148\u628a\u4ee3\u7801\u8bcd\u6cd5\u5206\u6790\uff08tokenize\uff09\u6210\u8bb8\u591a\u7684 token\n\n- \u7136\u540e\u9001\u8fdb\u4e00\u4e2a token \u6d41\uff08token stream\uff09\n\n- \u7136\u540e\u5efa\u7acb\u8bed\u6cd5\u6811\uff0c\u53eb\u505a\u8bed\u6cd5\u5206\u6790\n\n- \u6700\u540e\u9001\u7ed9\u7f16\u8bd1\u5668\u7f16\u8bd1 / \u865a\u62df\u673a\u6267\u884c\n\n\u672c\u9053\u9898\u6211\u4eec\u5b9e\u73b0\u7684\u5c31\u662f\u4e00\u4e2a\u865a\u62df\u673a\uff0c\u6267\u884c\u5b57\u8282\u7801\uff08bytecode\uff09\n\n\u6211\u4eec\u5ffd\u7565\u6240\u6709\u7684\u7a7a\u767d\uff0c\u5305\u62ec\u6ce8\u91ca\u5728\u5185\uff0c\u8fd0\u884c\u65f6\u5c31\u4e0d\u7528\u53bb\u7279\u5224\u4e86\n\n\u5176\u5b9e\u5982\u679c\u5f00\u53d1\u8fc7\u8bed\u8a00\u89e3\u91ca\u5668\u6216\u8005\u7f16\u8bd1\u5668\u7684\u8bdd\uff0c\u76f8\u5bf9\u6bd4\u8f83\u5bb9\u6613\u7406\u89e3\u3002\n\n _\uff08\u4f46\u662f\u5f00\u53d1\u89e3\u91ca\u5668\u771f\u7684\u5f88\u4e0d\u5bb9\u6613\u2026\u2026\u4eb2\u8eab\u7ecf\u5386\uff09_ \n \n =====\u5206\u5272\u7ebf=====\n \n**\u5173\u952e\u4ee3\u7801\u5982\u4e0b**\uff0c\u60f3\u627e\u5b8c\u6574\u6e90\u4ee3\u7801\u53ef\u4ee5\u6233[\u526a\u8d34\u677f\u4f20\u9001\u95e8](https://www.luogu.com.cn/paste/b2oa1k2z)\n \n \n```\n//\u8fd9\u662f\u4e00\u4e2a\u8fd0\u884c\u6307\u4ee4\u7684\u51fd\u6570\n...\n\tString type = tokens[0];\n\tif(type == \"set\") {\n\t\tsetval(tokens[1], expression(tokens[2]));\n\t\tline++;\n\t}\n\telse if(type == \"rint\") {\n\t\tint x;\n\t\tcin >> x;\n\t\tif(opcnt == 1) setval(\"%val\", x);\n\t\telse setval(tokens[1], x);\n\t\tline++;\n\t}\n\telse if(type == \"rch\") {\n\t\tchar x;\n\t\tcin >> x;\n\t\tif(opcnt == 1) setval(\"%val\", x);\n\t\telse setval(tokens[1], x);\n\t\tline++;\n\t}\n\telse if(type == \"wint\") {\n\t\tif(opcnt == 1) cout << expression(\"%val\");\n\t\telse cout << expression(tokens[1]);\n\t\tline++;\n\t}\n\telse if(type == \"wch\") {\n\t\tif(opcnt == 1) cout << (char)expression(\"%val\");\n\t\telse cout << (char)expression(tokens[1]);\n\t\tline++;\n\t}\n\telse if(type == \"Warfarin\") {\n\t\tcout << \"\u3063\uff01\u304a\u3044\uff01\u4f55\u3092\u3057\u3066\u3044\u308b\u2026\u2026\" << endl;\n\t\tline++;\n\t}\n\telse if(type == \"Ptilopsis\") {\n\t\tcout << \"\u30a8\u30e9\u30fc\u767a\u751f\u3002\" << endl;\n\t\tline++;\n\t}\n\telse if(type == \"inv\") {\n\t\tint ans = !expression(tokens[1]); \n\t\tif(opcnt == 2) setval(\"%val\", ans);\n\t\telse setval(tokens[2], ans);\n\t\tline++;\n\t}\n\telse if(type == \"add\") {\n\t\tint ans = expression(tokens[1]) + expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"sub\") {\n\t\tint ans = expression(tokens[1]) - expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"mult\") {\n\t\tint ans = expression(tokens[1]) * expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"idiv\") {\n\t\tint ans = expression(tokens[1]) / expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"mod\") {\n\t\tint ans = expression(tokens[1]) % expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lsft\") {\n\t\tint ans = expression(tokens[1]) << expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"rsft\") {\n\t\tint ans = expression(tokens[1]) >> expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"band\") {\n\t\tint ans = expression(tokens[1]) & expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"bor\") {\n\t\tint ans = expression(tokens[1]) | expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"bxor\") {\n\t\tint ans = expression(tokens[1]) xor expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%val\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lgr\") {\n\t\tint ans = expression(tokens[1]) > expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lls\") {\n\t\tint ans = expression(tokens[1]) < expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lge\") {\n\t\tint ans = expression(tokens[1]) >= expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lle\") {\n\t\tint ans = expression(tokens[1]) <= expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"leql\") {\n\t\tint ans = expression(tokens[1]) == expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"land\") {\n\t\tint ans = expression(tokens[1]) && expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"lor\") {\n\t\tint ans = expression(tokens[1]) || expression(tokens[2]); \n\t\tif(opcnt == 3) setval(\"%flag\", ans);\n\t\telse setval(tokens[3], ans);\n\t\tline++;\n\t}\n\telse if(type == \"callfunc\") {\n\t\tString func = CUT(tokens[1]);\n\t\tcallFunc(func);\n\t}\n\telse if(type == \"jmp\") {\n\t\tline = funcline[callstack.top()];\n\t\tline = line + expression(tokens[1]);\n\t}\n\telse if(type == \"jif\") {\n\t\tbool condition;\n\t\tif(opcnt == 2) condition = getval(\"%flag\");\n\t\telse condition = expression(tokens[2]);\n\t\tif(condition) {\n\t\t\tline = funcline[callstack.top()];\n\t\t\tline = line + expression(tokens[1]);\n\t\t}\n\t\telse line++;\n\t}\n\telse if(type == \"ret\") {\n\t\tif(opcnt == 2) setval(\"%ret\", expression(tokens[1]));\n\t\treturn false;\n\t} \n\telse if(type == \"hlt\") {\n\t\texit(0);\n\t\tline++;\n\t}\n\telse line++;\n...\n```\n\u6700\u540e\uff0c\u7ed9\u90a3\u4e9b\u60f3\u4e86\u89e3\u89e3\u91ca\u5668\u3001\u7f16\u8bd1\u5668\u3001\u865a\u62df\u673a\u7b49\u7684oier\u4eec\u5b89\u5229\u4e00\u4e0b[WarfarinBloodanger \u535a\u5ba2](https://www.luogu.com.cn/blog/Warfarin/#)\u54e6\n\n\u6c42\u901a\u8fc7~",
        "postTime": 1625055679,
        "uid": 188950,
        "name": "UruhaRushia",
        "ccfLevel": 6,
        "title": "P4911 \u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a \u9898\u89e3"
    },
    {
        "content": "## \u9898\u9762\n\n[P4911 \u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a](https://www.luogu.com.cn/problem/P4911)\n\n## \u6e29\u99a8\u63d0\u793a\n\n\u4e3a\u4e86\u60a8\u7684\u9605\u8bfb\u4f53\u9a8c, \u8bf7\u79fb\u6b65[\u6211\u7684\u535a\u5ba2](https://jiafeimiao.top/2021/04/02/%E9%A2%98%E8%A7%A3-%E3%80%90P4911%E3%80%91-%E6%B2%B3%E7%AB%A5%E9%87%8D%E5%B7%A5%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA/)\n\n## \u53e6\u5916\u4e00\u7ec4\u6837\u4f8b\n\n\u6837\u4f8b\u6765\u81ea\u9898\u9762\u4e2d\u7684\u6c47\u7f16\u6559\u7a0b\u9644\u5e26\u793a\u4f8b, \u5220\u53bb\u4e86\u7a7a\u884c, \u61d2\u5f97\u7f16\u6570\u636e\u4e86, \u6240\u4ee5\u5c31\u6ca1\u6709\u5199\u8bfb\u5165\u6570\u636e\u90e8\u5206.\n\n```\n26\n[ progfunc.asm ]\n[ Shows the function functionailties of the KTX-65 ALI ]\n[main]\nwint #line;    [output the current physical line number]\nwch 13;        [putchar \\r]\nwch 10;        [putchar \\n]\ncallfunc $Function1;\ncallfunc $Function2;\nhlt;           [halt]\nfunction $Function1;\nrint %r1;      [read int]\nadd %r2 1 %r2; [loop contents]\nlle %r2 %r1;   [loop conditions]\njif 2;         [end loop conditional jump]\nwint %r2;      [output int]\nwch 13;        [putchar \\r]\nwch 10;        [putchar \\n]\nret;           [return]\nfunction $Function2;\nrint %r1;      [read int]\nrint %r2;      [read int]\nadd %r1, %r2;  [add]\nwint %val;     [output value]\nwch 13;        [putchar \\r]\nwch 10;        [putchar \\n]\nret;           [return]\n```\n\n\u6837\u4f8b\u770b\u4e0d\u61c2\u4e5f\u6ca1\u5173\u7cfb, \u4e0b\u9762\u662f\u7528C++\u7684\u8bed\u53e5\u8f6c\u6362\u7684\u7a0b\u5e8f, \u4e3a\u4e86\u65b9\u4fbf\u5bf9\u5e94\u884c\u53f7, \u8f6c\u6362\u540e\u7684\u6837\u4f8b\u5220\u53bb\u4e86\u7b2c\u4e00\u4e2a\u7a7a\u884c, \u540c\u65f6\u6bcf\u6761\u8bed\u53e5\u524d\u52a0\u4e0a\u4e86\u64cd\u4f5c\u7801.\n\n```\n\n\n28 cout << line;\n29 cout << '\\r';\n29 cout << '\\n';\n31 fun1();\n31 fun2();\n1 exit();\n30 fun1(){\n26    cin >> r1;\n9    r2++;\n22    flag = r2 <= r1;\n5    if (flag) goto Line 11;\n28    cout << r2;\n29    cout << '\\r';\n29    cout << '\\n';\n7    return;}\n30 fun2(){\n26    cin >> r1;\n26    cin >> r2;\n9    val = r1 + r2;\n28    cout << val;\n29    cout << '\\r';\n29    cout << '\\n';\n7    return;}\n```\n\n## \u67b6\u6784\u8bbe\u8ba1\n\n\u5199\u5927\u6a21\u62df\u5e94\u8be5\u505a\u4ec0\u4e48?\n\n~~\u5f53\u7136\u662f\u8dd1\u8def\u554a, \u4e0d\u8dd1\u8def\u8fd8\u7559\u4e0b\u6765\u79c3\u5934\u5417?~~\n\n\u5f53\u7136\u662f\u5148\u5206\u6790\u9700\u6c42, \u8bbe\u8ba1\u57fa\u672c\u67b6\u6784\u554a.\n\n\u9996\u5148\u89c2\u5bdf\u6307\u4ee4\u683c\u5f0f, \u53ef\u4ee5\u53d1\u73b0\u4e00\u4e2a\u64cd\u4f5c\u81f3\u591a\u53ea\u6709\u4e09\u4e2a\u53d8\u91cf(\u5f00\u4e2a\u6570\u7ec4\u5c31\u5b8c\u4e8b\u4e86).\n\n\u518d\u6765\u89c2\u5bdf\u53d8\u91cf, \u4e00\u4e9b\u7c7b\u578b\u7684\u53d8\u91cf\u9700\u8981\u8bfb\u5199\u5bc4\u5b58\u5668\u6216\u8005\u5185\u5b58, \u5b58\u4e2a\u6307\u9488\u5c31\u53ef\u4ee5\u4e86, \u53e6\u4e00\u4e9b\u53d8\u91cf\u662f\u5e38\u91cf, \u6807\u8bb0\u4e00\u4e0b\u5373\u53ef.\n\n\u63a5\u4e0b\u6765\u89c2\u5bdf\u5185\u5b58\u548c\u6808, \u6839\u636e\u6587\u6863\u53ef\u77e5, \u76f4\u63a5\u5f00\u4e2a\u6570\u7ec4\u6a21\u62df\u5373\u53ef.\n\n\u5982\u4f55\u5c06\u6307\u4ee4\u4e0e\u64cd\u4f5c\u8054\u7cfb\u8d77\u6765\u5462? \u6211\u4eec\u53ea\u8981\u7ed9\u6bcf\u79cd\u6307\u4ee4\u7f16\u53f7, \u7528\u7f16\u53f7\u53bb\u8bbf\u95ee\u4e0d\u540c\u7684\u51fd\u6570\u5c31\u53ef\u4ee5\u4e86, \u5f00\u4e2amap<string, int> \u5c31\u53ef\u4ee5\u4e86.\n\n## \u8bfb\u5165\u9884\u5904\u7406\n\n\u9996\u5148\u6211\u4eec\u5148\u9884\u5904\u7406\u4e00\u4e0b\u6240\u6709\u6307\u4ee4, \u7edf\u4e00\u8f6c\u6362\u6210\u5c0f\u5199\u5b57\u6bcd.\n\n```cpp\ntransform(line.begin(), line.end(), line.begin(), ::tolower);\n```\n\n\u63a5\u4e0b\u6765\u6211\u4eec\u5904\u7406\u6ce8\u91ca, \u5e76\u4e14\u7ed9\u8bed\u53e5\u5206\u884c(\u5e94\u5bf9\u4e00\u884c\u591a\u6761\u8bed\u53e5\u7684\u60c5\u51b5, \u867d\u7136\u6d4b\u8bd5\u6570\u636e\u4e2d\u8c8c\u4f3c\u5e76\u6ca1\u6709\u8fd9\u79cd\u60c5\u51b5), \u987a\u4fbf\u8fd8\u80fd\u5904\u7406\u4e00\u4e0b\u53d8\u91cf\u95f4\u53ef\u80fd\u51fa\u73b0\u7684\u9017\u53f7.\n\n\u5bf9\u4e8e\u6ce8\u91ca\u5f88\u7b80\u5355, \u6839\u636e\u672a\u914d\u5bf9\u7684\u4e2d\u62ec\u53f7\u4e2a\u6570\u5c31\u80fd\u5f88\u5bb9\u6613\u7684\u5224\u65ad\u5728\u4e0d\u5728\u6ce8\u91ca\u91cc, \u7528erase()\u5220\u9664\u5373\u53ef, \u9700\u8981\u6ce8\u610f\u7684\u662f\u5220\u9664\u4e4b\u540e\u8fed\u4ee3\u5668\u8981\u51cf\u4e00, \u5426\u5219\u65e0\u6cd5\u904d\u5386\u6240\u6709\u5b57\u7b26.\n\n\u5206\u53f7\u4ee3\u8868\u8bed\u53e5\u7684\u7ed3\u675f, \u5229\u7528stringstream\u7684\u7279\u6027, \u8fd9\u91cc\u6211\u4eec\u628a\u5b83\u6362\u6210'\\n'.\n\n\u9017\u53f7\u5f88\u7b80\u5355, \u6362\u6210\u7a7a\u683c\u5373\u53ef.\n\n## \u8bfb\u5165\u6307\u4ee4\n\n\u9884\u5904\u7406\u5b8c\u4e4b\u540e, \u6211\u4eec\u5c31\u83b7\u5f97\u4e00\u4e2a\u4fbf\u4e8e\u5904\u7406\u7684string\u4e86, \u9996\u5148\u5b58\u5165stringstream, \u7136\u540e\u6bcf\u6b21\u8bfb\u53d6\u4e00\u884c, \u5c31\u83b7\u5f97\u4e86\u4e00\u6761\u6307\u4ee4, \u9700\u8981\u6ce8\u610f\u7684\u662f\u8fd9\u91cc\u53ef\u80fd\u83b7\u5f97\u7a7a\u884c, \u5e94\u8be5\u52a0\u4ee5\u5224\u65ad.\n\n\u5bf9\u4e8e\u6bcf\u6761\u6307\u4ee4, \u64cd\u4f5c\u662f\u5fc5\u7136\u5b58\u5728\u7684, \u76f4\u63a5\u65e0\u8111\u8bfb\u5373\u53ef, \u4f46\u662f\u53d8\u91cf\u4e2a\u6570\u53ef\u80fd\u662f\u4e0d\u786e\u5b9a\u7684, \u8fd9\u91cc\u7ee7\u7eed\u5229\u7528stringstream\u7684\u7279\u6027\u6765\u5904\u7406.\n\n\u5bf9\u4e8e\u4e00\u4e2a\u53d8\u91cf, \u5982\u679c\u5b83\u4e0d\u662f\u5e38\u91cf, \u6211\u4eec\u76f4\u63a5\u50a8\u5b58\u5bf9\u5e94\u6307\u9488, \u5982\u679c\u662f\u5e38\u91cf, \u5b58\u50a8\u5b83\u7684\u503c. \u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u5728data\u7ed3\u6784\u4f53\u4e2d\u7684init()\u51fd\u6570\u4e2d.\n\n\u56e0\u4e3a\u4ee3\u7801\u592a\u957f\u4e86, \u6240\u4ee5\u8bf7\u770b\u5b8c\u6574\u4ee3\u7801\u4e2d\u7684\u5bf9\u5e94\u90e8\u5206.\n\n## \u51fd\u6570\u6307\u9488\u6570\u7ec4\n\n\u628a\u64cd\u4f5c\u7801\u5f53\u4f5c\u4e0b\u6807\u8bbf\u95ee\u5bf9\u5e94\u7684\u51fd\u6570\u5373\u53ef.\n\n```cpp\nvoid (*fun[])(const op &a, int &index) = {\n\tfun0, fun1, fun2, fun3, fun4, fun5, fun6, fun7, fun8, fun9, \n\tfun10, fun11, fun12, fun13, fun14, fun15, fun16, fun17, fun18, fun19, \n\tfun20, fun21, fun22, fun23, fun24, fun25, fun26, fun27, fun28, fun29, \n\tfun30, fun31\n};\n//example\nfun[ops[i].op](ops[i], i);\n```\n\n## \u5bf9\u5e94\u51fd\u6570\n\n\u6309\u7167\u9898\u610f\u6a21\u62df\u5373\u53ef\n\n## \u5b8c\u6574\u4ee3\u7801\n\n```cpp\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#ifdef LOCAL\n#define debug(format, args...) \\\nprintf(format, ##args)\n#else\n#define debug(format, args...)\n#endif\n\nusing namespace std;\n\ntypedef map<string, int> msi;\ntypedef map<int, int> mii;\ntypedef stringstream SS;\n\nmsi op2fun = {{\"udef\", 0}, {\"hlt\", 1}, {\"nop\", 2}, {\"set\", 3}, {\"jmp\", 4},\n{\"jif\", 5}, {\"call\", 6}, {\"ret\", 7}, {\"inv\", 8}, {\"add\", 9}, {\"sub\", 10},\n{\"mult\", 11}, {\"idiv\", 12}, {\"mod\", 13}, {\"lsft\", 14}, {\"rsft\", 15},\n{\"band\", 16}, {\"bor\", 17}, {\"bxor\", 18}, {\"lgr\", 19}, {\"lls\", 20},\n{\"lge\", 21}, {\"lle\", 22}, {\"leql\", 23}, {\"land\", 24}, {\"lor\", 25},\n{\"rint\", 26}, {\"rch\", 27}, {\"wint\", 28}, {\"wch\", 29}, {\"function\", 30}, {\"callfunc\", 31}};\n\nmsi reg2pointer = {{\"r1\", 0}, {\"r2\", 1}, {\"r3\", 2}, {\"r4\", 3}, {\"e1\", 4},\n{\"e2\", 5}, {\"e3\", 6}, {\"e4\", 7}, {\"flag\", 8}, {\"val\", 9}, {\"ret\", 10}, {\"line\", 11}};\n\n//funLine for the line of the first statement of function\n//funIndex for the index in vecor of the first statement of function\n//funNum for the Num of the function \n//line2index for transform line to index in vector\nmii funLine;\nmii funIndex;\nmsi funNum;\nmii line2index;\n\nint r1, r2, r3, r4, e1, e2, e3, e4, flag, val, ret, line, falseVar, funCnt = 0, statementCnt = 0;\n\nint *reg[] = {&r1, &r2, &r3, &r4, &e1, &e2, &e3, &e4, &flag, &val, &ret, &line};\n\nint ram[(1 << 23) + 9];\nint sAddr[(1 << 19) + 9];\n\nstruct data{\n\tint* a;\n\tint value;\n\t//0 for register, 1 for constant, 2 for adress, 3 for adress in register\n\t//4 for Line, 5 for inputInt, 6 for inputChar, 7 for outputInt, 8 for outputChar \n\t//9 for initFunction, 10 for callFunction\n\tint type;\n\tvoid out(){\n\t\tdebug(\"\\t%d %d\\n\", value, type);\n\t}\n\tdata (int *A = &falseVar, int v = 0, int t = -1): a(A), value(v), type(t){\t\n\t}\n\tvoid init(string &s, int L){\n\t\tauto it = s.begin();\n\t\tif (s[0] == '%'){\n\t\t\ttype = 0;\n\t\t\ts.erase(it);\n\t\t\ta = reg[reg2pointer[s]];\n\t\t}\n\t\telse if (s[0] == '@'){\n\t\t\tif (s[1] == '%'){\n\t\t\t\ttype = 3;\n\t\t\t\ts.erase(it);\n\t\t\t\ts.erase(it);\n\t\t\t\ta = reg[reg2pointer[s]];\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttype = 2;\n\t\t\t\ts.erase(it);\n\t\t\t\tvalue = stoi(s);\n\t\t\t\ta = &ram[value];\n\t\t\t}\n\t\t}\n\t\telse if (s[0] == '#'){\n\t\t\ta = &falseVar;\n\t\t\tvalue = L;\n\t\t\ttype = 4;\n\t\t}\n\t\telse{\n\t\t\ttype = 1;\n\t\t\ta = &falseVar;\n\t\t\tvalue = stoi(s);\n\t\t}\n\t}\n};\n\nstruct op{\n\tint op;\n\tdata d[3];\n\t//line for the number of current statement\n\t//funLine for the number in function of current statement\n\tint line, funLine;\n};\n\nint getValue(const op &a, int index){\n\tint b = 0;\n\tswitch (a.d[index].type){\n\t\tcase 0:{\n\t\t}\n\t\tcase 2:{\n\t\t\tb = *(a.d[index].a);\n\t\t\tbreak;\n\t\t}\n\t\tcase 3:{\n\t\t\tb = ram[*(a.d[index].a)];\n\t\t\tbreak;\n\t\t}\n\t\tcase 1:{\n\t\t\tb = a.d[index].value;\n\t\t\tbreak;\n\t\t}\n\t\tcase 4:{\n\t\t\tb = a.line;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn b;\n}\n\nvoid fun0(const op &a, int &index){\n}\nvoid fun1(const op &a, int &index){\n}\nvoid fun2(const op &a, int &index){\n}\nvoid fun3(const op &a, int &index){\n\tint b = getValue(a, 0);\n\t*(a.d[1].a) = b;\n\tdebug(\"\\nFun3: b: %d line: %X %X;\\n\", b, *(a.d[1].a), &line);\n}\nvoid fun4(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tindex = line2index[line + b];\n}\nvoid fun5(const op &a, int &index){\n\tint Flag = getValue(a, 1);\n\tint b = getValue(a, 0);\n\tif (Flag){\n\t\tindex = line2index[line + b] - 1; \n\t}\n}\nvoid fun6(const op &a, int &index){\n\tint &top = sAddr[0];\n\ttop++;\n\tsAddr[top] = index;\n\tdebug(\"PushIndex: %d\\n\", index + 1);\n\ttop++;\n\tsAddr[top] = line;\n\tint b = getValue(a, 0);\n\tindex = line2index[b] - 1;\n}\nvoid fun7(const op &a, int &index){\n\tint &top = sAddr[0];\n\tint Line = sAddr[top];\n\tline = Line;\n\ttop--;\n\tint next = sAddr[top];\n\ttop--;\n\tindex = next;\n\tdebug(\"NextIndex: %d\\n\", next);\n\tif (a.d[0].value != -1){\n\t\tint b = getValue(a, 0);\n\t\tret = b;\n\t}\n}\nvoid fun8(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tb = -b;\n\t*(a.d[1].a) = b;\n}\nvoid fun9(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b + c;\n\tdebug(\"\\nFun9: b: %d c: %d ans: %d;\\n\", b, c, *(a.d[1].a));\n}\nvoid fun10(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b - c;\n}\nvoid fun11(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b * c;\n}\nvoid fun12(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b / c;\n}\nvoid fun13(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b % c;\n}\nvoid fun14(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b << c;\n}\nvoid fun15(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b >> c;\n}\nvoid fun16(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b & c;\n}\nvoid fun17(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b | c;\n}\nvoid fun18(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b ^ c;\n}\nvoid fun19(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = (b > c);\n}\nvoid fun20(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = (b < c);\n}\nvoid fun21(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = (b >= c);\n}\nvoid fun22(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = (b <= c);\n}\nvoid fun23(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = (b == c);\n}\nvoid fun24(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b && c;\n}\nvoid fun25(const op &a, int &index){\n\tint b = getValue(a, 0);\n\tint c = getValue(a, 1);\n\t*(a.d[2].a) = b || c;\n}\nvoid fun26(const op &a, int &index){\n\tcin >> *(a.d[0].a);\n}\nvoid fun27(const op &a, int &index){\n\tcin >> *(a.d[0].a);\n}\nvoid fun28(const op &a, int &index){\n\tcout << getValue(a, 0);\n}\nvoid fun29(const op &a, int &index){\n\tcout << (char)getValue(a, 0);\n}\nvoid fun30(const op &a, int &index){\n\tline = a.line;\n\tdebug(\"Line: %d\\n\", line);\n}\nvoid fun31(const op &a, int &index){\n\tint b = funIndex[a.d[0].value];\n\tdebug(\"b: %d\\n\", b);\n\tint &top = sAddr[0];\n\ttop++;\n\tsAddr[top] = index;\n\tdebug(\"PushIndex: %d\\n\", index + 1);\n\ttop++;\n\tsAddr[top] = line;\n\tindex = b - 1;\n}\n\nvoid (*fun[])(const op &a, int &index) = {\n\tfun0, fun1, fun2, fun3, fun4, fun5, fun6, fun7, fun8, fun9, \n\tfun10, fun11, fun12, fun13, fun14, fun15, fun16, fun17, fun18, fun19, \n\tfun20, fun21, fun22, fun23, fun24, fun25, fun26, fun27, fun28, fun29, \n\tfun30, fun31\n};\n\ntypedef vector<op> vo;\n\nint main(){\n\t#ifndef LOCAL\n\t\tios::sync_with_stdio(0);\n\t\tcin.tie(0);\n\t\tcout.tie(0);\n\t#endif \n\tint n;\n\tcin >> n;\n\tcin.get();\n\tvo ops;\n\tint funFlag = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tstring line;\n\t\tgetline(cin, line, '\\n');\n\t\ttransform(line.begin(), line.end(), line.begin(), ::tolower);\n\t\tauto it = line.begin();\n\t\tint zkh = 0;\n\t\tfor (; it < line.end(); it++){\n\t\t\tif (zkh){\n\t\t\t\tif (*it == ']'){\n\t\t\t\t\tzkh--;\n\t\t\t\t}\n\t\t\t\tline.erase(it);\n\t\t\t\tit--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif (*it == ','){\n\t\t\t\t\t*it = ' ';\n\t\t\t\t}\n\t\t\t\telse if (*it == ';'){\n\t\t\t\t\t*it = '\\n';\n\t\t\t\t}\n\t\t\t\telse if (*it == '['){\n\t\t\t\t\tzkh++;\n\t\t\t\t\tline.erase(it);\n\t\t\t\t\tit--;\n\t\t\t\t}\n\t\t\t\t//position is wrong\n\t\t\t\t/*else if (*it == ']'){\n\t\t\t\t\tzkh--;\n\t\t\t\t\tline.erase(it);\n\t\t\t\t\tit--;\n\t\t\t\t}*/\n\t\t\t}\n\t\t}\n\t\tSS ss(line);\n\t\tstring s;\n\t\twhile (getline(ss, s, '\\n')){\n\t\t\tSS ssTemp(s);\n\t\t\tstring command;\n\t\t\tssTemp >> command;\n\t\t\tif (command.empty()){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tstring sTemp;\n\t\t\tint cmd = op2fun[command];\n\t\t\tif (!line2index.count(i)){\n\t\t\t\tline2index[i] = statementCnt;\n\t\t\t}\n\t\t\tswitch (cmd){\n\t\t\t\tcase 0:{\n\t\t\t\t}\n\t\t\t\tcase 1:{\n\t\t\t\t}\n\t\t\t\tcase 2:{\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 5:{\n\t\t\t\t\tstring a, b;\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tssTemp >> a;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tif (!(ssTemp >> b) || b.empty()){\n\t\t\t\t\t\tstring fake = \"%flag\";\n\t\t\t\t\t\tT.d[1].init(fake, i);\n\t\t\t\t\t}\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\t\t\n\t\t\t\tcase 7:{\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tstring a;\n\t\t\t\t\tif (ssTemp >> a && !a.empty()){\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = \"%ret\";\n\t\t\t\t\t}\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 4:{\n\t\t\t\t}\n\t\t\t\tcase 6:{\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tstring a;\n\t\t\t\t\tssTemp >> a;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 8:{\n\t\t\t\t\tstring a, b;\n\t\t\t\t\tssTemp >> a;\n\t\t\t\t\tif (ssTemp >> b && !b.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tb = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[1].init(b, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 3:{\n\t\t\t\t\tstring a, b;\n\t\t\t\t\tssTemp >> a >> b;\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[1].init(b, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 9:{\n\t\t\t\t}\n\t\t\t\tcase 10:{\n\t\t\t\t}\n\t\t\t\tcase 11:{\n\t\t\t\t}\n\t\t\t\tcase 12:{\n\t\t\t\t}\n\t\t\t\tcase 13:{\n\t\t\t\t}\n\t\t\t\tcase 14:{\n\t\t\t\t}\n\t\t\t\tcase 15:{\n\t\t\t\t}\n\t\t\t\tcase 16:{\n\t\t\t\t}\n\t\t\t\tcase 17:{\n\t\t\t\t}\n\t\t\t\tcase 18:{\n\t\t\t\t\tstring a, b, c;\n\t\t\t\t\tssTemp >> a >> b;\n\t\t\t\t\tif (ssTemp >> c && !c.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[1].init(b, i);\n\t\t\t\t\tT.d[2].init(c, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 19:{\n\t\t\t\t}\n\t\t\t\tcase 20:{\n\t\t\t\t}\n\t\t\t\tcase 21:{\n\t\t\t\t}\n\t\t\t\tcase 22:{\n\t\t\t\t}\n\t\t\t\tcase 23:{\n\t\t\t\t}\n\t\t\t\tcase 24:{\n\t\t\t\t}\n\t\t\t\tcase 25:{\n\t\t\t\t\tstring a, b, c;\n\t\t\t\t\tssTemp >> a >> b;\n\t\t\t\t\tif (ssTemp >> c){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tc = \"%flag\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[1].init(b, i);\n\t\t\t\t\tT.d[2].init(c, i);\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 26:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tif (ssTemp >> a && !a.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[0].type = 5;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 27:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tif (ssTemp >> a && !a.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\tT.d[0].type = 6;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 28:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tif (ssTemp >> a && !a.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\t//T.d[0].type = 7;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 29:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tif (ssTemp >> a && !a.empty()){\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\ta = \"%val\";\n\t\t\t\t\t}\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tT.d[0].init(a, i);\n\t\t\t\t\t//T.d[0].type = 8;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 30:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tssTemp >> a;\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (!funNum.count(a)){\n\t\t\t\t\t\tnum = funNum[a] = funCnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tnum = funNum[a];\n\t\t\t\t\t}\n\t\t\t\t\tfunIndex[num] = ops.size();\n\t\t\t\t\tfunFlag = 1;\n\t\t\t\t\tT.d[0].value = i;\n\t\t\t\t\tT.d[0].type = 10;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 31:{\n\t\t\t\t\tstring a;\n\t\t\t\t\tssTemp >> a;\n\t\t\t\t\top T;\n\t\t\t\t\tT.op = cmd;\n\t\t\t\t\tT.line = i;\n\t\t\t\t\tint num = 0;\n\t\t\t\t\tif (!funNum.count(a)){\n\t\t\t\t\t\tfunNum[a] = funCnt++;\n\t\t\t\t\t}\n\t\t\t\t\tnum = funNum[a];\n\t\t\t\t\tT.d[0].value = num;\n\t\t\t\t\tT.d[0].type = 1;\n\t\t\t\t\tops.push_back(T);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatementCnt++;\n\t\t}\n\t}\n\t/*int cnt = 0;\n\tfor (auto x : ops){\n\t\tcout << cnt << \": \" << x.op << '\\n';\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tx.d[i].out();\n\t\t}\n\t\tcnt++;\n\t}*/\n\tline = ops[0].line;\n\tfor (int i = 0; i < statementCnt; i++){\n\t\tif (ops[i].op == 1){\n\t\t\treturn 0;\n\t\t}\n\t\telse{\n\t\t\tfun[ops[i].op](ops[i], i);\n\t\t\tdebug(\"\\n| op: %d; r1: %d; r2: %d; val: %d; line: %d; %%line: %d; index: %d; |\\n\", \n\t\t\t\tops[i].op, r1, r2, val, ops[i].line, line, i);\n\t\t\t//fun[ops[i].op](ops[i], i);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1617419142,
        "uid": 130640,
        "name": "\u94be\u80a5",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P4911 \u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "(C\u8bed\u8a00\uff0c -O2 101ms)\n\n\n------------\n\n- ##  \u5904\u7406\u8f93\u5165\n\n### \u5b58\u50a8\uff1a\n\n\u5c06\u6240\u6709\u64cd\u4f5c\u6309\u5b57\u5178\u5e8f\u7f16\u53f7\u5e76\u5b58\u50a8\uff0c\u7528\u4e00\u4e2a struct \u5b58\u50a8\u8f93\u5165\u7684\u6bcf\u884c\u547d\u4ee4\u5bf9\u5e94\u7684\u7f16\u53f7\u548c\u53c2\u6570\u3002\n```cpp\nenum CommandType\n{\n    add, band, bor, bxor, call, callfunc, function, hlt, idiv, jif, jmp, land, leql, lge, lgr, lle, lls, lor, lsft, mod, mult, nop, rch, ret, rint, rsft, set, sub, udef, wch, wint\n};\nconst char CommandArr[][10] = {\"add\\0\", \"band\\0\", \"bor\\0\", \"bxor\\0\", \"call\\0\", \"callfunc\\0\", \"function\\0\", \"hlt\\0\", \"idiv\\0\", \"jif\\0\", \"jmp\\0\", \"land\\0\", \"leql\\0\", \"lge\\0\", \"lgr\\0\", \"lle\\0\", \"lls\\0\", \"lor\\0\", \"lsft\\0\", \"mod\\0\", \"mult\\0\", \"nop\\0\", \"rch\\0\", \"ret\\0\", \"rint\\0\", \"rsft\\0\", \"set\\0\", \"sub\\0\", \"udef\\0\", \"wch\\0\", \"wint\\0\"};\n```\n\n```cpp\nstruct Command  \n{\n    enum CommandType operId;\n    int cntArg;\n    int *args[3];\n}program[50005];\n```\n\u56e0\u4e3a\u6240\u6709\u53c2\u6570\u90fd\u662f ```int *``` \u7c7b\u578b\uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u6570\u7ec4\u5b58\u50a8\u5e38\u91cf\uff0c\u7136\u540e\u5c06\u5bf9\u5e94\u7684\u6307\u9488\u653e\u8fdb\u53c2\u6570\u91cc\uff08\u5177\u4f53\u4ee3\u7801\u89c1\u6587\u7ae0\u6700\u540e\u7684\u526a\u8d34\u677f\uff09\u3002\n\n### \u5904\u7406\uff1a\n\n\u5148\u5904\u7406\u6ce8\u91ca\uff0c\u6ca1\u7528\u7684\u76f4\u63a5\u8df3\u8fc7\u3002\n\n\u4e4b\u540e\u5c06\u8f93\u5165\u62c6\u5206\uff0c\u7136\u540e\u8f6c\u6362\u6210\u76f8\u5e94\u64cd\u4f5c\u7f16\u53f7\u4e0e\u53c2\u6570\u653e\u5165\u7ed3\u6784\u4f53\u4e2d\u3002\n\n\u5355\u72ec\u5904\u7406 ```function``` \u548c ```callfunc``` \uff0c\u5168\u90e8\u8f93\u5165\u5b8c\u540e\u5c06 ```callfunc``` \u8f6c\u6362\u6210 ```call``` \u3002\n\n```cpp\nvoid processInput()\n{\n    int cntBracket = 0; //\u6570\u4e2d\u62ec\u53f7\n    bool readCommand = true;    //\u8bfb\u64cd\u4f5cor\u8bfb\u53c2\u6570\uff0c\u6bcf\u884c\u5f00\u59cb\u65f6\u8bbe\u7f6e\u4e3a\u8bfb\u53d6\u64cd\u4f5c\n    int sumInputLine;\n    scanf(\"%d\", &sumInputLine);\n    fgets(inputLineBuf, 1000, stdin);\t//\u8f93\u5165\u7684\u7b2c\u4e00\u884c\u8fd8\u5269\\n\uff0c\u6e05\u6389\n    for (int nowInputLine = 1; nowInputLine <= sumInputLine; nowInputLine++) {\n        memset(inputLineBuf, 0, sizeof(inputLineBuf));\n        fgets(inputLineBuf, 1000, stdin);\n        readCommand = true;\n        for (char *i = inputLineBuf; *i != '\\0'; i++) {\n            //\u6ce8\u91ca\u3001\u7a7a\u683c\u3001\u6362\u884c\u8df3\u8fc7\n            if (*i == '[') {\n                cntBracket++;\n                continue;\n            }\n            if (*i == ']') { \n                cntBracket--;\n                continue;\n            }\n            if (cntBracket != 0 || *i == ' ' || *i == ']' ||*i == '\\r' || *i == '\\n' || *i == '\\t' || *i == ';')\n                continue;\n            //\u63d0\u53d6\u8bcd\uff08\u62c6\u5206\uff09\n            memset(word, 0, sizeof(word));\n            for (char *j = word; *i != ';' && *i != ' ' && *i != '\\r' && *i != '\\n' && *i != '[' && *i != '\\t' && *i != '\\0'; i++, j++)\n                *j = *i;\n            i--;    //\u524d\u79fb\u4e00\u4e2a\uff0c\u8fc7\u4f1a++\n            if (readCommand) {\n                readCommand = false;\n                program[nowInputLine].operId = (enum CommandType)SearchCommand(0, SumCommand - 1, word);\n            } else {\n                if (program[nowInputLine].operId == callfunc) { //\u8bb0\u5f55callfunc\n                    callfuncCmds[cntCallfunc] = nowInputLine;\n                    strcpy(callfuncName[cntCallfunc], word);\n                    cntCallfunc++;\n                }\n                if (program[nowInputLine].operId == function) { //\u8bb0\u5f55function\n                    strcpy(func[cntFunc].name, word);\n                    func[cntFunc].stLine = nowInputLine;\n                    cntFunc++;\n                } else if (word[0] == '%') { //\u5bc4\u5b58\u5668\n\n                    //......\uff08\u89c1\u6e90\u4ee3\u7801\uff09\n\n                } else if (word[0] == '@') {\n                    if(word[1] == '%') {    //@%\n\n                        //......\uff08\u89c1\u6e90\u4ee3\u7801\uff09\n                        \n                    } else     //@\u4e00\u4e2a\u6570\n                        program[nowInputLine].args[program[nowInputLine].cntArg] = &mem[readNum(&word[1])];\n                } else {    //\u5904\u7406\u5e38\u91cf\n                    constPool[cntConst] = readNum(&word[0]);\n                    program[nowInputLine].args[program[nowInputLine].cntArg] = &constPool[cntConst];\n                    cntConst++;\n                }\n                program[nowInputLine].cntArg++;\n            }\n        }\n    }\n    FuncSort(func, cntFunc);\n    for (int i = 0; i < cntCallfunc; i++) { //\u628acallfunc\u53d8\u6210call\n        program[callfuncCmds[i]].operId = call;\n        constPool[cntConst] = SearchFunc(0, cntCallfunc - 1, callfuncName[i]);\n        program[callfuncCmds[i]].args[0] = &constPool[cntConst];\n        cntConst++;\n    }\n    \n}\n```\n\n\n------------\n- ## \u8fd0\u884c\n\u6309\u64cd\u4f5c\u7684\u7f16\u53f7\u5efa\u7acb\u51fd\u6570\u6307\u9488\u6570\u7ec4\uff0c\u5199\u597d\u76f8\u5e94\u7684\u51fd\u6570\u653e\u8fdb\u53bb\u3002\n\n```cpp\n//\u6bcf\u4e2a\u64cd\u4f5c\u5bf9\u5e94\u7684\u51fd\u6570\nvoid UDEF(int sParam, int *par0, int *par1, int *par2) {nowRunLine++;}\nvoid HLT(int sParam, int *par0, int *par1, int *par2) {exit(0);}\nvoid NOP(int sParam, int *par0, int *par1, int *par2) {nowRunLine++;}\nvoid SET(int sParam, int *par0, int *par1, int *par2) {*par1 = *par0; nowRunLine++;}\nvoid JMP(int sParam, int *par0, int *par1, int *par2) {nowRunLine = Line + *par0;}\nvoid JIF(int sParam, int *par0, int *par1, int *par2) {\n    if (sParam == 1) {if (Flag) nowRunLine = Line + *par0; else nowRunLine++;}\n    else {if (*par1) nowRunLine = Line + *par0; else nowRunLine++;}\n}\nvoid CALL(int sParam, int *par0, int *par1, int *par2) {\n    push((struct Addr){Line, nowRunLine});\n    Line = *par0;\n    nowRunLine = *par0;\n}\nvoid CALLFUNC(int sParam, int *par0, int *par1, int *par2) {printf(\"ERROR:CALLFUNC while running\");}\nvoid FUNCTION(int sParam, int *par0, int *par1, int *par2) {nowRunLine++;}\nvoid RET(int sParam, int *par0, int *par1, int *par2) {\n    Line = getTop().Line;\n    nowRunLine = getTop().nowLine + 1;\n    pop();\n    if (sParam == 1)    Ret = *par0;\n}\n//......\n\nvoid (*operation[32])(int, int *, int *, int *) = {ADD, BAND, BOR, BXOR, CALL, CALLFUNC, FUNCTION, HLT, IDIV, JIF, JMP, LAND, LEQL, LGE, LGR, LLE, LLS, LOR, LSFT, MOD, MULT, NOP, RCH, RET, RINT, RSFT, SET, SUB, UDEF, WCH, WINT};\n```\n\n\u4e4b\u540e\u6309\u987a\u5e8f\u6267\u884c\u7f16\u53f7\u5bf9\u5e94\u7684\u51fd\u6570\u5c31\u884c\u4e86\uff0c\u9047\u5230 ```hlt``` \u76f4\u63a5\u7ed3\u675f\u7a0b\u5e8f\u3002\n```cpp\nvoid run()\n{\n    nowRunLine = 1;\n    for(;;)\n        (*operation[program[nowRunLine].operId])(program[nowRunLine].cntArg, program[nowRunLine].args[0], program[nowRunLine].args[1], program[nowRunLine].args[2]);\n}\n```\n\n\n------------\n[\u6e90\u4ee3\u7801\u526a\u8d34\u677f](https://www.luogu.com.cn/paste/dpelq5b8)\n\n\n",
        "postTime": 1656314084,
        "uid": 402255,
        "name": "Untitled10032",
        "ccfLevel": 4,
        "title": "P4911 \u9898\u89e3"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/P4911)\n\n## \u9898\u610f\u7b80\u8ff0\n\n* \u7ed9\u51fa\u4e00\u6bb5\u6c47\u7f16\u8bed\u8a00\u3002\n* \u7ed9\u51fa\u8f93\u5165\u3002\n* \u6c42\u8fd9\u6bb5\u6c47\u7f16\u8bed\u8a00\u7684\u8f93\u51fa\u3002\n\n\u4ee5\u4e0b\u8fd8\u6709\u4e00\u4e9b\u9898\u9762\u4e2d\u6ca1\u6709\u5f3a\u8c03\u7684\u8981\u70b9\uff1a\n\n1. \u6bcf\u884c\u53ea\u6709\u4e00\u6761\u8bed\u53e5\uff1b\n1. `call <0>;` \u547d\u4ee4\u4f1a\u5c06\u4e0b\u4e00\u884c\u7684\u5e8f\u53f7 $nxt$ \u4e0e\u5f53\u524d\u7684\u5bc4\u5b58\u5668 `%Line` \u7684\u503c $line$ \u538b\u5165\u6808\u4e2d\uff1b\n1. `ret <0>;` \u547d\u4ee4\u4f1a\u4ece\u6808\u4e2d\u53d6\u51fa $nxt$ \u548c $line$\uff0c\u5e76\u4f7f\u7a0b\u5e8f\u8df3\u8f6c\u5230\u7b2c $nxt$ \u884c\uff0c\u540c\u65f6\u5c06\u5f53\u524d\u7684 `%Line` \u8d4b\u503c\u4e3a $line$\uff1b\n1. \u9017\u53f7\u7b49\u4e8e\u7a7a\u683c\uff1b\n1. \u5185\u5b58\u7684\u5730\u5740\u662f\u4e00\u4e2a\u5341\u8fdb\u5236\u7684\u6570\u5b57\uff0c\u4ece0\u5f00\u59cb\uff1b\n1. \u5173\u952e\u5b57\u5168\u662f\u5c0f\u5199\uff0c\u4f46\u51fd\u6570\u540d\u4e0d\u4e00\u5b9a\uff1b\n1. \u6ce8\u91ca\u53ef\u4ee5\u5d4c\u5957\uff1b\n1. \u6570\u636e**\u975e\u5e38\u7b80\u5355**\uff0c\u4e0d\u7528\u8003\u8651\u90a3\u4e9b\u5947\u5947\u602a\u602a\u7684\u60c5\u51b5\u3002\n\n\n## \u9898\u76ee\u5206\u6790\n\n\u663e\u800c\u6613\u89c1\u7684\uff0c\u672c\u9898\u662f\u4e2a\u5927\u6a21\u62df\u9898\u3002\n\n\u5148\u94fa\u57ab c++ \u7684\u51e0\u4e2a\u4e0d\u5e38\u7528\uff08\uff1f\uff09\u7684\u7279\u6027\uff1a\n\n* \u5728\u5b9a\u4e49\u51fd\u6570\u65f6\uff0c\u5982 `int function(int f=1)`\uff0c\u8fd9\u91cc\u7684 `f=1` \u8868\u793a\u300c\u9ed8\u8ba4\u300d\u3002\u5f53\u6211\u7ed9\u8be5\u51fd\u6570\u53c2\u6570\u65f6\uff0c`f` \u7684\u9ed8\u8ba4\u53d6\u503c `1` \u4f1a\u88ab\u8986\u76d6\uff0c\u82e5\u6211\u4e0d\u7ed9\u53c2\u6570\uff0c\u5219 `f` \u4f1a\u53d6\u9ed8\u8ba4\u503c\u3002\n* \u5982\u679c\u5b9a\u4e49\u4e86\u53d8\u91cf `a` \uff0c\u5219 `*a` \u53ef\u4ee5\u7406\u89e3\u4e3a\u300c\u6307\u5411 `a` \u7684\u6307\u9488\u300d\u3002\n* `sscanf()` \u53ef\u4ee5\u4ece\u5b57\u7b26\u4e32\u4e2d\u8bfb\u53d6\u6570\u636e\u3002\n\n\u672c\u9898\u601d\u7ef4\u96be\u5ea6\u4e0d\u5927\uff0c\u5176\u96be\u5ea6\u4e3b\u8981\u4f53\u73b0\u5728\u5b9e\u73b0\u4ee5\u53ca\u7801\u91cf\u4e0a\u3002\n\n\u8bfb\u61c2\u4e86\u9898\u76ee\uff0c\u90a3\u4e48\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u53ef\u4ee5\u5feb\u4e50\u5730\u7ed9\u6c47\u7f16\u8bed\u8a00\u5199\u89e3\u91ca\u5668\u4e86\u3002\n\n\u9898\u9762\u4e2d\u63d0\u5230\u4e86\u4e00\u5957\u5b8c\u6574\u7684\u5185\u5b58\u7cfb\u7edf\uff0c\u552f\u6709\u5148\u5c06\u5b83\u5b9e\u73b0\u597d\u4e86\uff0c\u624d\u80fd\u7ee7\u7eed\u8fdb\u884c\u5de5\u4f5c\u3002\n\n### \u5730\u5740\u7cfb\u7edf\n\n\u8003\u8651\u5982\u4f55\u5b9e\u73b0\u5bc4\u5b58\u5668\u548c\u5185\u5b58\u2026\u554a\u4e0d\u7528\u8003\u8651\uff0c\u592a\u7b80\u5355\u4e86\uff0c\u76f4\u63a5\u5f00\u51e0\u4e2a\u53d8\u91cf\u548c\u4e00\u4e2a\u6570\u7ec4\u5c31\u884c\u4e86\u3002\n\n\u4f46\u662f\u5185\u5b58\u7cfb\u7edf\u7684\u96be\u70b9\u5c31\u5728\u5904\u7406\u90a3\u4e9b\u5b57\u7b26\u4e32\u4e0a\u3002\n\n\u65e2\u7136\u9898\u5e72\u4e2d\u6307\u4ee4\u4f1a\u5bf9\u5185\u5b58\u751a\u81f3\u662f\u5e38\u91cf\u8fdb\u884c\u8bfb\u5199\uff0c\u90a3\u6211\u4eec\u76f4\u63a5\u83b7\u53d6\u6307\u9488\u5c31\u597d\u4e86\u3002\n\n\u56e0\u6b64\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5b9e\u73b0\u4e00\u4e2a\u51fd\u6570 `int*get_address(string address)`\u3002\n\n* \u5bf9\u4e8e\u5bc4\u5b58\u5668\u548c\u56fa\u5b9a\u4f4d\u7f6e\u7684\u5185\u5b58\uff08\u201c%\u201d \u4e0e \u201c@\u201d\uff09\uff0c\u6211\u4eec\u76f4\u63a5\u8fd4\u56de\u5176\u6307\u9488\u3002\n* \u5bf9\u4e8e\u5728\u5bc4\u5b58\u5668\u503c\u4f4d\u7f6e\u7684\u5185\u5b58\uff08\u201c@%\u201d\uff09\uff0c\u6211\u4eec\u5148\u83b7\u53d6\u8be5\u5bc4\u5b58\u5668\u7684\u503c\uff0c\u518d\u8fd4\u56de\u5bf9\u5e94\u4f4d\u7f6e\u5185\u5b58\u7684\u6307\u9488\u3002\n* \u5bf9\u4e8e\u7f16\u8bd1\u65f6\u5e38\u91cf\u4e0e\u666e\u901a\u5e38\u91cf\uff08\u201c#\u201d \u4e0e\u6570\u5b57\uff09\uff0c\u8003\u8651\u5230\u547d\u4ee4\u4f1a\u5bf9\u5e38\u91cf\u8fdb\u884c\u4fee\u6539\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8d4b\u4e0a\u5e38\u91cf\u7684\u503c\uff0c\u7136\u540e\u8fd4\u56de\u8be5\u53d8\u91cf\u7684\u6307\u9488\u3002\n\n\u7136\u540e\u5c31\u5199\u597d\u4e86\uff1a\n\n```cpp\nint R1,R2,R3,R4; //\u5bc4\u5b58\u5668\nint E1,E2,E3,E4; //\u5bc4\u5b58\u5668\nint Flag,Val,Ret,Line; //\u5bc4\u5b58\u5668 \nint memory[20000000]; //\u5185\u5b58 \nint undefine; //\u5bf9\u5e38\u91cf\u7684\u4fee\u6539 \nstruct node{\n    int nxtline,Line;\n    node(int nn,int ll){\n        nxtline=nn,Line=ll;\n    }\n};\nstack<node> sAddr; //\u7cfb\u7edf\u6808 \nstring code[50005]; //\u6c47\u7f16 \nint nowline; //\u5f53\u524d\u6267\u884c\u5230\u7684\u884c\u6570 \n\nint get_int(string s,bool ch){ //\u5c06 \u5b57\u7b26\u4e32/\u5b57\u7b26 \u8f6c\u5316\u4e3a\u6570\u5b57\n    if(ch) return s[0];\n    int res=0;bool neg=0; \n    if(s[0] == '-') neg=1;\n    for(int i=(neg?1:0);i<(int)s.size();i++) res=(res<<1)+(res<<3)+(s[i]^48);\n    return (neg?-res:res);\n}\n\nstring get_str(int x){ //\u5c06\u6570\u5b57\u8f6c\u5316\u4e3a\u5b57\u7b26\u4e32\n    string res=\"\";\n    bool neg=0;\n    if(x<0) neg=1,x=-x;\n    while(x>0){\n        res+=((x%10)^48);\n        x/=10;\n    }\n    reverse(res.begin(),res.end());\n    if(neg) return \"-\"+res;\n    return res;\n}\n\nint*get_address(string address){\n    if(address[0] == '%'){ //\u5bc4\u5b58\u5668 \n        address = address.substr(1);\n        if(address == \"r1\") return&R1;\n        if(address == \"r2\") return&R2;\n        if(address == \"r3\") return&R3;\n        if(address == \"r4\") return&R4;\n        if(address == \"e1\") return&E1;\n        if(address == \"e2\") return&E2;\n        if(address == \"e3\") return&E3;\n        if(address == \"e4\") return&E4;\n        if(address == \"flag\") return&Flag;\n        if(address == \"val\" ) return&Val ;\n        if(address == \"ret\" ) return&Ret ;\n        if(address == \"line\") return&Line;\n    }\n    if(address[0] == '@'){ //\u5185\u5b58 \n        if(address.substr(0,2) == \"@%\") return&memory[*get_address(address.substr(1)  )];\n        else                            return&memory[ get_int    (address.substr(1),0)];\n        //\u8fd9\u79cd\u7801\u98ce\u53ef\u80fd\u6709\u4eba\u770b\u4e0d\u60ef...\u51d1\u5408\u7740\u770b\u770b\u5427qaq\n    }\n    if(address[0] == '#'){ //\u7f16\u8bd1\u65f6\u5e38\u91cf \n        address = address.substr(1);\n        if(address == \"line\"){\n            undefine = nowline;\n            return&undefine;\n        }\n    }\n    \n    if(address[0] == '-' || isdigit(address[0])){//\u5e38\u91cf \n        undefine=get_int(address,0);\n        return&undefine;\n    }\n    \n    return NULL;\n}\n\n```\n### \u8f93\u5165\u8f93\u51fa\n\n\u663e\u800c\u6613\u89c1\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8bfb\u5b8c\u6c47\u7f16\u540e\u505c\u4e0b\uff0c\u5728\u6c47\u7f16\u8fd0\u884c\u65f6\u518d\u53bb\u8bfb\u8f93\u5165\u8f93\u51fa\u3002\n\n\u5e76\u6ca1\u6709\u96be\u5ea6\u3002\n\n\uff08`read()` \u5c31\u662f\u666e\u901a\u7684\u5feb\u8bfb\uff09\n\n```cpp\nnamespace output{\n    void wint(string address=\"%val\"){\n        printf(\"%d\",*get_address(address));\n    }\n    void wch(string address=\"%val\"){\n        printf(\"%c\",*get_address(address));\n    }\n}\n\nnamespace input{\n    void rint(string address=\"%val\"){\n        *get_address(address)=read(); \n    }\n    void rch(string address=\"%val\"){\n        string s;cin>>s;\n        *get_address(address)=get_int(s,1);\n    }\n}\n```\n### \u8fd0\u7b97\u547d\u4ee4\n\n\u5bf9\u7740\u89c4\u8303\u6587\u4ef6\u6253\u5c31\u884c\u4e86\uff0c\u8fd9\u4e00\u90e8\u5206\u76f8\u5bf9\u91cd\u590d\u3002\n\n```cpp\nnamespace arithmetic{\n    void inv (string a0,          string address=\"%val\" ){*get_address(address) = -(*get_address(a0))                    ;}\n    void add (string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) +  *get_address(a1));}\n    void sub (string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) -  *get_address(a1));}\n    void mult(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) *  *get_address(a1));}\n    void idiv(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) /  *get_address(a1));}\n    void mod (string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) %  *get_address(a1));}\n    void lsft(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) << *get_address(a1));}\n    void rsft(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) >> *get_address(a1));}\n    void band(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) &  *get_address(a1));}\n    void bor (string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) |  *get_address(a1));}\n    void bxor(string a0,string a1,string address=\"%val\" ){*get_address(address) =  (*get_address(a0) ^  *get_address(a1));}\n}\n\nnamespace logic{\n    void lgr (string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) >  *get_address(a1));}\n    void lls (string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) <  *get_address(a1));}\n    void lge (string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) >= *get_address(a1));}\n    void lle (string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) <= *get_address(a1));}\n    void leql(string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) == *get_address(a1));}\n    void land(string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) && *get_address(a1));}\n    void lor (string a0,string a1,string address=\"%flag\"){*get_address(address) = (bool)(*get_address(a0) || *get_address(a1));}\n} \n```\n### \u63a7\u5236\u547d\u4ee4\n\n\u63a7\u5236\u547d\u4ee4\u57fa\u672c\u4e5f\u662f\u5bf9\u7740\u89c4\u8303\u6587\u4ef6\u6253\u5c31\u884c\u4e86\uff0c\u4f46\u662f\u8981\u6ce8\u610f\u89c4\u8303\u6587\u4ef6\u4e2d\u7684\u90a3\u884c\u5c0f\u5b57\uff1a  \n\u6ce8\uff1a`JMP`\u3001`JIF` \u547d\u4ee4\u4f1a\u4ee5 `%Line` \u5bc4\u5b58\u5668\u4e3a\u504f\u79fb\u8df3\u8f6c\uff08\u8df3\u8f6c\u5230\u76f8\u52a0\u4f4d\u7f6e\uff09\uff0c`CALL` \u547d\u4ee4\u5219\u4e0d\u4f1a\u3002\n\n\u8003\u8651\u5230\u6211\u7684\u4ee3\u7801\u7684\u540e\u7eed\u5b9e\u73b0\uff0c\u8fd9\u91cc\u6211\u5f80\u7cfb\u7edf\u6808 `sAddr` \u4e2d\u538b\u7684\u662f\u5f53\u524d\u7684 `%Line` \u548c\u5f53\u524d\u884c\u7684\u5e8f\u53f7\uff0c\u5982\u679c\u540e\u7eed\u5b9e\u73b0\u548c\u6211\u4e0d\u4e00\u6837\u4e00\u5b9a\u8981\u770b\u6e05\u4e86\u3002\n\n```cpp\nnamespace control{\n    void udef(){;}\n    void hlt(){exit(0);}\n    void nop(){;}\n    void set(string a0,string address){\n        *get_address(address) = (*get_address(a0));\n    }\n    void jmp (string a0){\n        nowline = (*get_address(a0) + *get_address(\"%line\"));\n    }\n    void jif (string a0,string a1=\"%flag\"){\n        if(*get_address(a1)){\n            nowline = (*get_address(a0) + *get_address(\"%line\"));\n        }\n    }\n    void call(string a0){\n        sAddr.push(node(nowline,*get_address(\"%line\"))); //\u8df3\u8f6c\u4e4b\u540e\u8fd8\u4f1a\u8fdb\u5165\u4e0b\u4e00\u884c\uff0c\u6240\u4ee5\u8fd9\u91cc\u5b58\u50a8\u5f53\u524d\u884c\u53f7\u5c31\u884c\u4e86\n        nowline = (*get_address(a0));\n    }\n    void ret(string a0=\"%ret\"){\n        *get_address(\"%line\") = sAddr.top().Line;\n        *get_address(\"%ret\") = (*get_address(a0));\n        nowline = sAddr.top().nxtline;\n        sAddr.pop();\n    }\n}\n```\n### \u9884\u5904\u7406\n\n\u8fd9\u91cc\u7684\u9884\u5904\u7406\u662f\u6307\u5220\u9664\u6240\u6709\u6ce8\u91ca\u4ee5\u53ca\u66ff\u6362 `FUNCTION` \u547d\u4ee4\u548c `CALLFUNC` \u547d\u4ee4\u3002\n\n\u5bf9\u4e8e\u6ce8\u91ca\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u4e00\u4e9b\u57fa\u672c\u5b57\u7b26\u4e32\u64cd\u4f5c\u5e72\u6389\u3002\n\n\u5bf9\u4e8e `FUNCTION` \u547d\u4ee4\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528 `map` \u5b58\u4e0b\u8be5\u51fd\u6570\u7684\u5bf9\u5e94\u884c\u6570\uff0c\u7136\u540e\u5c06\u539f\u53e5\u66ff\u6362\u4e3a `set #line %line;`\u3002\n\n\u5bf9\u4e8e `CALLFUNC` \u547d\u4ee4\uff0c\u76f4\u63a5\u5728\u90a3\u4e2a `map` \u91cc\u9762\u67e5\u5230\u8be5\u51fd\u6570\u7684\u5bf9\u5e94\u884c\u6570\uff0c\u7136\u540e\u5c06\u539f\u53e5\u66ff\u6362\u4e3a `call <\u5bf9\u5e94\u884c\u6570>;`\u3002\n\n```cpp\nnamespace special{\n    map<string,int> end;\n    void function(string a0){\n        end[a0]=nowline;\n    }\n    int callfunc(string a0){\n        return end[a0];\n    }\n}\n\nvoid init(){\n    int notes=0;\n    for(int i=1;i<=N;i++){ //\u53bb\u6ce8\u91ca\n        for(string::iterator j=code[i].begin();j!=code[i].end();){\n            if((*j) == '[') notes++;\n            if((*j) == ']' && notes > 0) notes--;\n            \n            if((*j) == '[' || (*j) == ']' || notes > 0) code[i].erase(j);\n            else j++;\n        }\n    }\n    for(nowline=1;nowline<=N;nowline++){\n        int posf=code[nowline].find(\"function $\");\n        if(posf != (int)code[nowline].npos){ //\u6ca1\u67e5\u5230\n            sscanf(code[nowline].substr(posf+10).c_str(),\"%[^;]\",subcode); //\u8bfb\u53d6\u51fd\u6570\u540d\uff0c\u76f4\u5230\u9047\u5230\u5206\u53f7\n            special::function(subcode); //\u8bb0\u5f55\u8be5\u51fd\u6570\u7684\u884c\u6570\n            code[nowline].erase(posf,10+strlen(subcode)); //\u5220\u9664\u8be5\u8bed\u53e5\n            code[nowline].insert(posf,\"set #line %line\");\n        }\n    }\n    for(nowline=1;nowline<=N;nowline++){\n        int posr=code[nowline].find(\"callfunc $\");\n        if(posr != (int)code[nowline].npos){ //\u6ca1\u67e5\u5230\n            sscanf(code[nowline].substr(posr+10).c_str(),\"%[^;]\",subcode); //\u8bfb\u53d6\u51fd\u6570\u540d\uff0c\u76f4\u5230\u9047\u5230\u5206\u53f7\n            code[nowline].erase(posr,10+strlen(subcode)); //\u5220\u9664\u8be5\u8bed\u53e5\n            code[nowline].insert(posr,\"call \"+get_str(special::callfunc(subcode)));\n        }\n    }\n    return;\n}\n```\n### \u8fd0\u884c\n\n\u53ef\u4ee5\u8003\u8651\u5c06\u4e00\u6761\u547d\u4ee4\u5206\u4e3a\u547d\u4ee4\u540d\u79f0\u548c\u53c2\u6570\u4e24\u4e2a\u90e8\u5206\uff0c\u4f7f\u7528 `sscanf()` \u76f4\u63a5\u8bfb\u53d6\u540d\u79f0\uff0c\u7136\u540e\u5faa\u73af\u8bfb\u53c2\u6570\uff0c\u76f4\u5230\u8bfb\u5230\u5206\u53f7\u4e3a\u6b62\u3002\n\n\u7136\u540e\u518d\u6839\u636e\u547d\u4ee4\u540d\u79f0\u53bb\u6267\u884c\u3002\n\n\u4ecd\u7136\u76f8\u5f53\u7e41\u7410\u3002\n```cpp\nvoid getcode(){\n    for(int i=1;i<=N;i++) getline(cin,code[i]);\n    return;\n}\n\nchar subcode[10005]; //\u547d\u4ee4\u540d\u79f0\nchar pm[5][10005]; //\u53c2\u6570\nint pmcnt; //\u53c2\u6570\u4e2a\u6570\n\nvoid run(){\n//    printf(\"\\\"%s\\\" %d\\n\",subcode,pmcnt);\n    /*if(nowline == 8){\n        printf(\"\\\"%s\\\" %d:\",subcode,pmcnt);\n        for(int i=1;i<=pmcnt;i++){\n            printf(\"\\\"%s\\\" \",pm[i]);\n        }\n        puts(\"\");\n    }*/\n    \n    if(subcode==(string)\"udef\") control::udef();\n    if(subcode==(string)\"hlt\") control ::hlt();\n    if(subcode==(string)\"nop\") control ::nop();\n    if(subcode==(string)\"set\") control::set(pm[1],pm[2]);\n    if(subcode==(string)\"jmp\") control::jmp(pm[1]);\n    if(subcode==(string)\"jif\"){\n        if(pmcnt == 1) control::jif(pm[1]);\n        if(pmcnt == 2) control::jif(pm[1],pm[2]);\n    }\n    if(subcode==(string)\"call\") control::call(pm[1]);\n    if(subcode==(string)\"ret\"){\n        if(pmcnt == 0) control::ret();\n        if(pmcnt == 1) control::ret(pm[1]);\n    }\n    \n    \n    \n    if(subcode==(string)\"inv\"){\n        if(pmcnt == 1) arithmetic::inv(pm[1]);\n        if(pmcnt == 2) arithmetic::inv(pm[1],pm[2]);\n    }\n    if(subcode==(string)\"add\"){\n        if(pmcnt == 2) arithmetic::add(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::add(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"sub\"){\n        if(pmcnt == 2) arithmetic::sub(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::sub(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"mult\"){\n        if(pmcnt == 2) arithmetic::mult(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::mult(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"idiv\"){\n        if(pmcnt == 2) arithmetic::idiv(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::idiv(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"mod\"){\n        if(pmcnt == 2) arithmetic::mod(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::mod(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"lsft\"){\n        if(pmcnt == 2) arithmetic::lsft(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::lsft(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"rsft\"){\n        if(pmcnt == 2) arithmetic::rsft(pm[1],pm[2]);      \n        if(pmcnt == 3) arithmetic::rsft(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"band\"){\n        if(pmcnt == 2) arithmetic::band(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::band(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"bor\"){\n        if(pmcnt == 2) arithmetic::bor(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::bor(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"bxor\"){\n        if(pmcnt == 2) arithmetic::bxor(pm[1],pm[2]);\n        if(pmcnt == 3) arithmetic::bxor(pm[1],pm[2],pm[3]);\n    }\n    \n    \n    if(subcode==(string)\"lgr\"){\n        if(pmcnt == 2) logic::lgr(pm[1],pm[2]);\n        if(pmcnt == 3) logic::lgr(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"lls\"){\n        if(pmcnt == 2) logic::lls(pm[1],pm[2]);\n        if(pmcnt == 3) logic::lls(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"lge\"){\n        if(pmcnt == 2) logic::lge(pm[1],pm[2]);\n        if(pmcnt == 3) logic::lge(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"lle\"){\n        if(pmcnt == 2) logic::lle(pm[1],pm[2]);\n        if(pmcnt == 3) logic::lle(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"leql\"){\n        if(pmcnt == 2) logic::leql(pm[1],pm[2]);\n        if(pmcnt == 3) logic::leql(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"land\"){\n        if(pmcnt == 2) logic::land(pm[1],pm[2]);\n        if(pmcnt == 3) logic::land(pm[1],pm[2],pm[3]);\n    }\n    if(subcode==(string)\"lor\"){\n        if(pmcnt == 2) logic::lor(pm[1],pm[2]);\n        if(pmcnt == 3) logic::lor(pm[1],pm[2],pm[3]);\n    }\n    \n    if(subcode==(string)\"rint\"){\n        if(pmcnt == 0) input::rint();\n        if(pmcnt == 1) input::rint(pm[1]);\n    }\n    if(subcode==(string)\"rch\"){\n        if(pmcnt == 0) input::rch();\n        if(pmcnt == 1) input::rch(pm[1]);\n    }\n    if(subcode==(string)\"wint\"){\n        if(pmcnt == 0) output::wint();\n        if(pmcnt == 1) output::wint(pm[1]);\n    }\n    if(subcode==(string)\"wch\"){\n        if(pmcnt == 0) output::wch();\n        if(pmcnt == 1) output::wch(pm[1]);\n    }\n    return;\n}\n\nsigned main(){\n    N=read();\n    getcode();\n    init();\n    \n    for(nowline=1;nowline<=N;nowline++){\n        int pos=0;\n        while(pos<code[nowline].size() && code[nowline][pos] == ' ') pos++; //\u8df3\u8fc7\u5f00\u5934\u6240\u6709\u7684\u9017\u53f7\u548c\u7a7a\u683c\n        if(pos == code[nowline].size()) continue; //\u5982\u679c\u662f\u7a7a\u884c\u5c31\u8df3\u8fc7\n        sscanf(code[nowline].substr(pos).c_str(),\"%[^ ,;]\",subcode); //\u8bfb\u53d6\u547d\u4ee4\u540d\u79f0\uff0c\u76f4\u5230\u5206\u53f7\u3001\u9017\u53f7\u3001\u7a7a\u683c\u3001\u4e09\u8005\u4e4b\u4e00\n        pos+=strlen(subcode);\n        \n        \n        while(code[nowline][pos] == ' ' || code[nowline][pos] == ',') pos++; //\u8df3\u8fc7\u6240\u6709\u7684\u9017\u53f7\u548c\u7a7a\u683c\n        \n        pmcnt=0;\n        while(code[nowline][pos] != ';'){ //\u8bfb\u53d6\u53c2\u6570\n            pmcnt++;\n            sscanf(code[nowline].substr(pos).c_str(),\"%[^ ,;]\",pm[pmcnt]); //\u8bfb\u53d6\u5230\u5206\u53f7\u3001\u9017\u53f7\u3001\u7a7a\u683c\u3001\u4e09\u8005\u4e4b\u4e00\u4e3a\u6b62\n            pos+=strlen(pm[pmcnt]);\n            \n            while(code[nowline][pos] == ' ' || code[nowline][pos] == ',') pos++; //\u8df3\u8fc7\u6240\u6709\u7684\u9017\u53f7\u548c\u7a7a\u683c\n        }\n        run();\n    }\n    /*\n    for(int i=1;i<=N;i++){\n        cout<<code[i]<<endl;\n    }\n    */\n    return 0;\n}\n```\n\n\u505a\u5b8c\u4e86\u4ee5\u4e0a\u5de5\u4f5c\uff0c\u672c\u9898\u4fbf\u53ef\u4ee5\u6210\u529fAC\u4e86\u3002",
        "postTime": 1627290424,
        "uid": 178480,
        "name": "hjxhjx",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 P4911\u3010\u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a\u3011"
    },
    {
        "content": "### \u9898\u76ee\u94fe\u63a5  [P4911 \u6cb3\u7ae5\u91cd\u5de5\u7684\u8ba1\u7b97\u673a](https://www.luogu.com.cn/problem/P4911)  \n\u5c31\u662f\u9053\u6a21\u62df\u9898\uff0c\u628a\u6240\u6709\u7684\u51fd\u6570\u548c\u5bc4\u5b58\u5668\u4e00\u4e00\u7528 ```map``` \u6620\u5c04\uff0c\u5bf9\u5e94\u5230\u51fd\u6570\u6570\u7ec4\uff0c\u4f46\u662f\u7ec6\u8282\u5f88\u591a\uff0c\u4ee3\u7801\u6bd4\u8f83\u957f\u3002\u6709\u5b9e\u73b0\u4e0a\u7684\u7ec6\u8282\u770b\u770b\u4ee3\u7801\u5c31\u80fd\u89e3\u51b3\u3002\u6ce8\u610f\u4ee3\u7801\u53ef\u7ef4\u62a4\u6027\uff0c\u4f7f\u7528 ```assert``` \u68c0\u67e5\u53c2\u6570\uff0c\u65b9\u4fbf\u8c03\u8bd5\u3002\n\n\u7b2c\u4e00\u90e8\u5206\u662f ```Command``` \u7c7b\uff0c\u4fdd\u5b58\u51fd\u6570\u4e0e\u51fd\u6570\u540d\u79f0\u7684\u6620\u5c04\uff0c\u7528 ```enum``` \u679a\u4e3e\u6bcf\u4e2a\u6307\u4ee4\u7684\u7f16\u53f7\uff0c\u7528 ```lambda``` \u8868\u8fbe\u5f0f\u5bf9\u51fd\u6570\u6570\u7ec4\u8d4b\u503c\u3002\n\n\u7b2c\u4e8c\u90e8\u5206\u662f ```Function``` \u7c7b\uff0c\u4fdd\u5b58\u6c47\u7f16\u4ee3\u7801\u5b9a\u4e49\u7684\u51fd\u6570\u5730\u5740\uff0c\u8c03\u7528\u65f6\u76f4\u63a5\u67e5\u8be2 ```mapping```\u3002\n\n\u7b2c\u4e09\u90e8\u5206\u662f ```Console``` \u7c7b\uff0c\u628a\u8f93\u5165\u7684\u6307\u4ee4\u5728\u8fd9\u91cc\u5206\u884c\uff0c\u5206\u8bcd\uff0c\u8bc6\u522b\u64cd\u4f5c\u540d\u548c\u53c2\u6570\uff0c\u987a\u4fbf\u8fd8\u7ba1\u7406\u8f93\u5165\u8f93\u51fa\u3002\n\n```cpp\n#ifdef ONLINE_JUDGE\n#define NDEBUG\n#endif  // ONLINE_JUDGE\n\n#include <assert.h>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nvoid __itoa(int value, char* buffer) {\n    vector<int> buf;\n    while (value) {\n        buf.push_back(value % 10);\n        value /= 10;\n    }\n    for (int i = buf.size() - 1, j = 0; ~i; j++, i--) {\n        buffer[j] = buf[i] + '0';\n    }\n}\n\nstruct Memory {\n    int r[5], e[5], flag, val, ret, line;\n    int memory[67108864 + 1024];\n    stack<pair<int, int> > sAddr;\n    unordered_map<string, int*> mapping;\n    Memory();\n} memory;\n\nclass Command {\npublic:\n    enum commands {\n        UDEF, HLT, NOP,\n        SET, JMP, JIF,\n        CALL, RET, INV,\n        ADD, SUB, MULT,\n        IDIV, MOD, LSFT,\n        RSFT, BAND, BOR,\n        BXOR, LGR, LLS,\n        LGE, LLE, LEQL,\n        LAND, LOR, RINT,\n        RCH, WINT, WCH,\n        commandsCount, a2123228, PleaseDontCopyTheSolution\n    };\n    Command();\n    void proccess(const string& cmd, vector<int*>& num);\n\nprivate:\n    unordered_map<string, int> mapping;\n    vector<void (*)(vector<int*>&)> command;\n    void initMapping();\n    void initCommands();\n} command;\n\nclass Function {\npublic:\n    void addFunction(string& name, int line);\n    int getFunction(string& name);\nprivate:\n    unordered_map<string, int> mapping;\n} func;\n\nclass Console {\npublic:\n    char ReadChar();\n    int ReadInt();\n    void WriteInt(int val);\n    void WriteChar(char val);\n    void rawPossess(vector<string>& raw);\n    void linePossess(string& line);\n    void funcPossess(string& line);\n    void setLine(int val);\n    int getLine();\n\nprivate:\n    int line;\n    vector<int> temp;\n} console;\n\nvector<string> raw;\nint main() {\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    string line;\n    getline(cin, line);\n    while (n--) {\n        getline(cin, line);\n        raw.push_back(line);\n    }\n    console.rawPossess(raw);\n    return 0;\n}\n\nCommand::Command() {\n    initMapping();\n    initCommands();\n}\n\ninline void Command::proccess(const string& cmd, vector<int*>& num) {\n    if (cmd.empty())\n        return;\n    const auto it = mapping.find(cmd);\n    assert(it != mapping.end());\n    command[it->second](num);\n}\n\ninline void Command::initMapping() {\n    mapping.insert({ \"udef\", UDEF });\n    mapping.insert({ \"hlt\", HLT });\n    mapping.insert({ \"nop\", NOP });\n    mapping.insert({ \"set\", SET });\n    mapping.insert({ \"jmp\", JMP });\n    mapping.insert({ \"jif\", JIF });\n    mapping.insert({ \"call\", CALL });\n    mapping.insert({ \"ret\", RET });\n    mapping.insert({ \"inv\", INV });\n    mapping.insert({ \"add\", ADD });\n    mapping.insert({ \"sub\", SUB });\n    mapping.insert({ \"mult\", MULT });\n    mapping.insert({ \"idiv\", IDIV });\n    mapping.insert({ \"mod\", MOD });\n    mapping.insert({ \"lsft\", LSFT });\n    mapping.insert({ \"rsft\", RSFT });\n    mapping.insert({ \"band\", BAND });\n    mapping.insert({ \"bor\", BOR });\n    mapping.insert({ \"bxor\", BXOR });\n    mapping.insert({ \"lgr\", LGR });\n    mapping.insert({ \"lls\", LLS });\n    mapping.insert({ \"lge\", LGE });\n    mapping.insert({ \"lle\", LLE });\n    mapping.insert({ \"leql\", LEQL });\n    mapping.insert({ \"land\", LAND });\n    mapping.insert({ \"lor\", LOR });\n    mapping.insert({ \"rint\", RINT });\n    mapping.insert({ \"rch\", RCH });\n    mapping.insert({ \"wint\", WINT });\n    mapping.insert({ \"wch\", WCH });\n}\n\ninline void Command::initCommands() {\n    command.resize(commandsCount);\n    command[0] = [](vector<int*>& val) {\n        assert(val.size() == 0);\n    };  // UDEF\n    command[1] = [](vector<int*>& val) {\n        assert(val.size() == 0);\n        cout.flush();\n        console.setLine(0x3f3f3f3f);\n    };  // HLT\n    command[2] = [](vector<int*>& val) {\n        assert(val.size() == 0);\n    };  // NOP\n    command[3] = [](vector<int*>& val) {\n        assert(val.size() == 2);\n        *val[1] = *val[0];\n    };  // SET\n    command[4] = [](vector<int*>& val) {\n        assert(val.size() == 1);\n        console.setLine(memory.line + *val[0]);\n    };  // JMP\n    command[5] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 1);\n        if (val.size() == 2 && val[1]) {\n            console.setLine(memory.line + *val[0]);\n        }\n        else if (memory.flag) {\n            console.setLine(memory.line + *val[0]);\n        }\n    };  // JIF\n    command[6] = [](vector<int*>& val) {\n        assert(val.size() == 1);\n        memory.sAddr.push({ console.getLine() + 1, memory.line });\n        console.setLine(*val[0]);\n    };  // CALL\n    command[7] = [](vector<int*>& val) {\n        assert(val.size() == 1 || val.size() == 0);\n        const pair<int, int> temp = memory.sAddr.top();\n        memory.sAddr.pop();\n        memory.line = temp.second;\n        console.setLine(temp.first);\n        if (!val.empty())\n            memory.ret = *val[0];\n    };  // RET\n    command[8] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 1);\n        ((val.size() == 1) ? memory.val : *val[1]) = -*val[0];\n    };  // INV\n    command[9] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] + *val[1];\n    };  // ADD\n    command[10] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] - *val[1];\n    };  // SUB\n    command[11] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] * *val[1];\n    };  // MULT\n    command[12] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] / *val[1];\n    };  // IDIV\n    command[13] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] % *val[1];\n    };  // MOD\n    command[14] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] << *val[1];\n    };  // LSFT\n    command[15] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] >> *val[1];\n    };  // RSFT\n    command[16] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] & *val[1];\n    };  // BAND\n    command[17] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] | *val[1];\n    };  // BOR\n    command[18] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.val : *val[2]) = *val[0] ^ *val[1];\n    };  // BXOR\n    command[19] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] > *val[1]);\n    };  // LGR\n    command[20] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] < *val[1]);\n    };  // LLS\n    command[21] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] >= *val[1]);\n    };  // LGE\n    command[22] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] <= *val[1]);\n    };  // LLE\n    command[23] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] == *val[1]);\n    };  // LEQL\n    command[24] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] && *val[1]);\n    };  // LAND\n    command[25] = [](vector<int*>& val) {\n        assert(val.size() == 2 || val.size() == 3);\n        ((val.size() == 2) ? memory.flag : *val[2]) = (*val[0] || *val[1]);\n    };  // LOR\n    command[26] = [](vector<int*>& val) {\n        assert(val.size() == 1 || val.size() == 0);\n        ((val.empty()) ? memory.val : *val[0]) = console.ReadInt();\n    };  // RINT\n    command[27] = [](vector<int*>& val) {\n        assert(val.size() == 1 || val.size() == 0);\n        ((val.empty()) ? memory.val : *val[0]) = console.ReadChar();\n    };  // RCH\n    command[28] = [](vector<int*>& val) {\n        assert(val.size() == 1 || val.size() == 0);\n        console.WriteInt((val.empty()) ? memory.val : *val[0]);\n    };  // WINT\n    command[29] = [](vector<int*>& val) {\n        assert(val.size() == 1 || val.size() == 0);\n        console.WriteChar((val.empty()) ? memory.val : *val[0]);\n    };  // WCH\n}\n\ninline char Console::ReadChar() {\n    string ret;\n    cin >> ret;\n    return ret[0];\n}\n\ninline int Console::ReadInt() {\n    int ret;\n    cin >> ret;\n    return ret;\n}\n\ninline void Console::WriteInt(int val) {\n    cout << val;\n}\n\ninline void Console::WriteChar(char val) {\n    cout << val;\n}\n\nvoid Console::rawPossess(vector<string>& raw) {\n    for (line = 0; line < raw.size(); line++) {\n        funcPossess(raw[line]);\n    }\n    for (line = 0; line < raw.size(); line++) {\n        linePossess(raw[line]);\n    }\n}\n\nvoid Console::linePossess(string& line) {\n    vector<string> sub;\n    int mess = 0;\n    string tmp;\n    for (const char& c : line) {\n        if (c == '[') { ++mess; continue; }\n        if (c == ']') { --mess; continue; }\n        if (mess) { continue; }\n        if (isalnum(c) || c == '%' || c == '@' || c == '#' || c == '$') tmp += c;\n        else if (!tmp.empty()) sub.push_back(tmp), tmp.clear();\n    }\n    string commandname, functionname;\n    vector<int*> num;\n    for (const string& str : sub) {\n        if (isalpha(str[0])) commandname = str;\n        else if (isdigit(str[0])) {\n            temp.push_back(atoi(str.c_str()));\n            num.push_back(&temp[temp.size() - 1]);\n        }\n        else if (str[0] == '%') {\n            const auto it = memory.mapping.find(str.substr(1));\n            assert(it != memory.mapping.end());\n            num.push_back(it->second);\n        }\n        else if (str[0] == '@') {\n            if (str[1] == '%') {\n                const auto it = memory.mapping.find(str.substr(1));\n                assert(it != memory.mapping.end());\n                num.push_back(&memory.memory[*(it->second)]);\n            }\n            else {\n                num.push_back(&memory.memory[atoi(str.substr(1).c_str())]);\n            }\n        }\n        else if (str[0] == '$') {\n            functionname = str.substr(1);\n        }\n        else {\n            temp.push_back(this->line + 1);\n            num.push_back(&temp[temp.size() - 1]);\n        }\n    }\n    if (commandname == \"callfunc\") {\n        temp.push_back(func.getFunction(functionname));\n        num.push_back(&temp[temp.size() - 1]);\n        commandname = \"call\";\n    }\n    command.proccess(commandname, num);\n    temp.clear();\n}\n\nvoid Console::funcPossess(string& line) {\n    vector<string> sub;\n    int mess = 0;\n    string tmp;\n    for (const char& c : line) {\n        if (c == '[') {\n            ++mess;\n            continue;\n        }\n        if (c == ']') {\n            --mess;\n            continue;\n        }\n        if (mess) {\n            continue;\n        }\n        if (isalnum(c) || c == '$')\n            tmp += c;\n        else if (!tmp.empty())\n            sub.push_back(tmp), tmp.clear();\n    }\n    string commandname, functionname;\n    for (const string& str : sub) {\n        if (isalpha(str[0])) {\n            commandname = str;\n            if (commandname != \"function\")\n                return;\n        }\n        else if (str[0] == '$') {\n            functionname = str.substr(1);\n        }\n    }\n    if (commandname == \"function\") {\n        static char linenum[64];\n        memset(linenum, 0, sizeof(linenum));\n        __itoa(getLine(), linenum);\n        line = \"set \" + string(linenum) + \" %line;\";\n        func.addFunction(functionname, getLine());\n    }\n}\n\ninline void Console::setLine(int val) {\n    line = val - 2;\n}\n\ninline int Console::getLine() {\n    return line + 1;\n}\n\nMemory::Memory() {\n    mapping.insert({ \"r1\", &r[1] });\n    mapping.insert({ \"r2\", &r[2] });\n    mapping.insert({ \"r3\", &r[3] });\n    mapping.insert({ \"r4\", &r[4] });\n    mapping.insert({ \"e1\", &e[1] });\n    mapping.insert({ \"e2\", &e[2] });\n    mapping.insert({ \"e3\", &e[3] });\n    mapping.insert({ \"e4\", &e[4] });\n    mapping.insert({ \"flag\", &flag });\n    mapping.insert({ \"val\", &val });\n    mapping.insert({ \"ret\", &ret });\n    mapping.insert({ \"line\", &line });\n}\n\nvoid Function::addFunction(string& name, int line) {\n    mapping.insert({ name, line });\n}\n\nint Function::getFunction(string& name) {\n    const auto it = mapping.find(name);\n    assert(it != mapping.end());\n    return it->second;\n}\n```\n",
        "postTime": 1657881419,
        "uid": 304242,
        "name": "a2123228",
        "ccfLevel": 6,
        "title": "P4911 \u9898\u89e3"
    }
]