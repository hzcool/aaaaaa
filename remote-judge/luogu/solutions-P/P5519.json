[
    {
        "content": "upd\uff1a\u4e4b\u524d\u5f0f\u5b50\u6709\u4e00\u70b9\u9505\uff0c\u73b0\u5df2\u4fee\u590d\u3002\n\n\u8fd9\u5176\u5b9e\u662f\u4e00\u4e2a\u5f88\u6c34\u7684\u5957\u8def\u9898\u3002\u3002\n\n\u9996\u5148\u5bb9\u6613\u770b\u51fa\u6765 $f(x,0)$ \u662f\u4e2a\u7ebf\u6027\u9012\u63a8\u7684\u5f62\u5f0f\uff0c\u8981\u6c42\u7684\u662f\u5176 $k$ \u9636\u524d\u7f00\u79ef\u3002  \n\u8981\u6c42\u4e58\u79ef\u4e0d\u592a\u597d\u641e\uff0c\u53ef\u4ee5\u5bf9 $2$ \u53d6\u4e00\u4e0b\u5bf9\u6570\uff0c\u5316\u4e58\u4e3a\u52a0\u3002  \n\n\u4e8e\u662f\u95ee\u9898\u8f6c\u5316\u4e3a\uff1a\n\n\u4e00\u4e2a\u6570\u5217 $a$\uff1a\n$$a_n=n\\space(n\\le42)$$  \n$$a_n=\\sum\\limits_{i=1}^{42}ia_{n-i}\\space(n\\ge 43)$$\n\u6c42\u5b83 $k$ \u9636\u524d\u7f00\u548c\u7684\u7b2c $n$ \u9879\u3002\n****\n\u5173\u4e8e\u7ebf\u6027\u9012\u63a8\u5f0f\u7684\u9ad8\u9636\u524d\u7f00\u548c\u6709\u4e00\u4e2a\u4f18\u7f8e\u7684\u6027\u8d28\u3002\n\n\u8bbe\u6570\u5217 $a$ \u7684\u9012\u63a8\u7cfb\u6570\u4e3a $f$\uff0c\u90a3\u4e48\u5728 $f$ \u524d\u9762\u52a0\u4e2a $-1$ \uff0c\u7136\u540e\u505a $k$ \u9636\u5dee\u5206\u5f97\u5230\u7684\u5e8f\u5217\u5373 $a$ \u7684 $k$ \u9636\u524d\u7f00\u548c\u7684\u9012\u63a8\u5f0f\u3002( \u5f53\u7136\u8981\u5728\u540e\u9762\u6269\u5c55 $k$ \u9879\uff0c\u540c\u65f6\u6700\u540e\u53bb\u6389 $-1$ )\n\n\u5728\u6b64\u7b80\u77ed\u8bc1\u660e\u4e00\u4e0b\uff0c\u8bbe\uff1a  \n$$a_n=\\sum\\limits_{i=1}^kf_ia_{n-i}$$\n$$b_n=\\sum\\limits_{i=1}^na_i$$\n$$b_n=b_{n-1}+a_n=b_{n-1}+\\sum\\limits_{i=1}^kf_ia_{n-i}$$\n$$= b_{n-1}+\\sum\\limits_{i=1}^kf_i(b_{n-i}-b_{n-i-1})$$\n\u540e\u9762\u7684\u90a3\u4e2a\u6c42\u548c\u5c55\u5f00\uff0c\u53ef\u4ee5\u5f97\u5230\u5f88\u591a\u5f62\u5982 $(f_i-f_{i-1})b_{n-i}$ \u7684\u5f0f\u5b50\uff0c\u8fd9\u5c31\u662f\u4e00\u4e2a\u5f88\u660e\u663e\u7684\u5dee\u5206\u5f62\u5f0f\uff0c\u63a5\u4e0b\u6765\u7684\u8bc1\u660e\u5c31\u5f88\u5bb9\u6613\u4e86\u3002\n\n\u5f97\u5230 $k$ \u9636\u524d\u7f00\u548c\u7684\u9012\u63a8\u5f0f\u540e\uff0c\u628a $a$ \u7684 $k$ \u9636\u524d\u7f00\u548c\u7684\u524d\u51e0\u9879\u4e5f\u6c42\u51fa\u6765\uff0c\u7136\u540e\u76f4\u63a5\u4e0a\u7ebf\u6027\u9012\u63a8\u677f\u5b50\u5373\u53ef\u3002\n\n\u4e0d\u8fc7\u8981\u6ce8\u610f\u7684\u662f\u6211\u4eec\u521a\u624d\u53d6\u4e86\u4e2a $\\log$\uff0c\u6240\u4ee5\u4ee5\u4e0a\u8fd0\u7b97\u90fd\u8981\u5bf9 $\\color{red} 998244352$ \u53d6\u6a21\uff0c\u8fd9\u9700\u8981\u7528\u5230\u4efb\u610f\u6a21\u6570\u3002$7$ \u6b21 FFT \u7684\u505a\u6cd5\u5e38\u6570\u8fc7\u5927\uff0c\u4e0d\u80fd\u901a\u8fc7\uff1b\u9700\u8981\u4f7f\u7528 $4$ \u6b21 FFT \u7684\u505a\u6cd5\u3002\n\n\u8fd8\u6709\u5c31\u662f\u6a21\u6570\u4e0d\u662f\u7d20\u6570\u65f6\uff0c\u7b97\u7ec4\u5408\u6570\u5f88\u9ebb\u70e6\uff0c\u6240\u4ee5\u76f4\u63a5\u7528\u500d\u589e\u591a\u9879\u5f0f\u5feb\u901f\u5e42\u8ba1\u7b97\u9ad8\u9636\u5dee\u5206\u6216\u524d\u7f00\u548c\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\Theta(k\\log^2 k+k\\log k\\log n)$\u3002\n\nstd:\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define N 65539\n#define ll long long\n#define reg register\n#define p 998244352\n#define pi 3.141592653589793\nusing namespace std;\n\nstruct complex{\n    double x,y;\n    inline complex(double x=0,double y=0):x(x),y(y){}\n    \n    inline complex operator + (const complex& b) const{ return complex(x+b.x,y+b.y); }\n    inline complex operator - (const complex& b) const{ return complex(x-b.x,y-b.y); }\n    inline complex operator * (const complex& b) const{ return complex(x*b.x-y*b.y,x*b.y+y*b.x); }\n    inline complex operator / (const int& b) const{ return complex(x/b,y/b); }\n    inline complex operator ~ () const{ return complex(x,-y); }\n}rt[N];\n\nstruct matrix{\n    int a[43][43];\n    int siz;\n    inline matrix(int _siz=0):siz(_siz){ memset(a,0,sizeof(a)); }\n    \n    inline matrix operator * (const matrix& b) const{\n        matrix res = matrix(siz);\n        for(reg int i=0;i!=siz;++i)\n        for(reg int j=0;j!=siz;++j)\n        for(reg int k=0;k!=siz;++k)\n            res.a[i][j] = (res.a[i][j]+(ll)a[i][k]*b.a[k][j])%p;\n        return res;    \n    }\n};\n\ninline matrix mat_pow(matrix a,ll t){\n    matrix res = matrix(a.siz);\n    for(reg int i=0;i!=a.siz;++i) res.a[i][i] = 1;\n    while(1){\n        if(t&1) res = res*a;\n        t >>= 1;\n        if(t==0) break;\n        a = a*a;\n    }\n    return res;\n}\n\nint rev[N];\nint siz;\n\ninline int add(int a,int b){ return a+b>=p?a+b-p:a+b; }\ninline int dec(int a,int b){ return a<b?a-b+p:a-b; }\ninline int getlen(int n){ return 1<<(32-__builtin_clz(n)); }\n\ninline void init(int n){\n    int lim = 1;\n    while(lim<=n) lim <<= 1,++siz;\n    for(reg int i=1;i!=lim;++i) rev[i] = (rev[i>>1]>>1)|((i&1)<<(siz-1));\n    rt[lim>>1] = complex(1,0);\n    for(reg int i=1;i!=(lim>>1);++i) rt[i+(lim>>1)] = complex(cos(pi*2/lim*i),sin(pi*2/lim*i));\n    for(reg int i=(lim>>1)-1;i;--i) rt[i] = rt[i<<1];\n}\n\ninline void dft(complex *f,int lim){\n    static complex a[N];\n    int shift = siz-__builtin_ctz(lim);\n    for(reg int i=0;i!=lim;++i) a[rev[i]>>shift] = f[i];\n    for(reg int mid=1;mid!=lim;mid<<=1)\n    for(reg int j=0;j!=lim;j+=(mid<<1))\n    for(reg int k=0;k!=mid;++k){\n        complex x = a[j|k|mid]*rt[mid|k];\n        a[j|k|mid] = a[j|k]-x;\n        a[j|k] = a[j|k]+x;\n    }\n    for(reg int i=0;i!=lim;++i) f[i] = a[i];\n}\n\ninline void idft(complex *f,int lim){\n    reverse(f+1,f+lim);\n    dft(f,lim);\n    for(reg int i=0;i!=lim;++i) f[i] = f[i]/lim;\n}\n\ninline void multiply(const int *A,const int *B,int n,int m,int *R,int len,bool flag){\n    static complex f[N],g[N],h[N],q[N];\n    complex t,f0,f1,g0,g1;\n    ll x,y,z;\n    int lim = getlen(n+m);\n    for(reg int i=0;i!=lim;++i){\n        f[i] = complex(A[i]>>15,A[i]&32767);\n        g[i] = complex(B[i]>>15,B[i]&32767);\n    }\n    dft(f,lim);\n    if(flag) for(reg int i=0;i!=lim;++i) g[i] = f[i];\n    else dft(g,lim);\n    for(reg int i=0;i!=lim;++i){\n        t = ~f[i?lim-i:0];\n        f0 = (f[i]-t)*complex(0,-0.5),f1 = (f[i]+t)*0.5;\n        t = ~g[i?lim-i:0];\n        g0 = (g[i]-t)*complex(0,-0.5),g1 = (g[i]+t)*0.5;\n        h[i] = f1*g1;\n        q[i] = f1*g0 + f0*g1 + f0*g0*complex(0,1);\n    }\n    idft(h,lim),idft(q,lim);\n    for(reg int i=0;i<=len;++i){\n        x = (ll)(h[i].x+0.5)%p<<30;\n        y = (ll)(q[i].x+0.5)<<15;\n        z = q[i].y+0.5;\n        R[i] = (x+y+z)%p;\n    }\n    memset(R+len+1,0,(lim-len)<<2);\n}\n\ninline void inverse(const int *f,int n,int *R){ \n    static int g[N],h[N],st[30];\n    memset(g,0,getlen(n<<1)<<2);\n    int top = 0,lim =1 ;\n    while(n){\n        st[++top] = n;\n        n >>= 1;\n    }\n    g[0] = 1;\n    while(top--){\n        n = st[top+1];\n        while(lim<=(n<<1)) lim <<= 1;\n        memcpy(h,f,(n+1)<<2);\n        memset(h+n+1,0,(lim-n)<<2);\n        multiply(h,g,n,n>>1,h,n,false);\n        multiply(h,g,n,n>>1,h,n,false);\n        for(reg int i=(n>>1);i<=n;++i) g[i] = dec(add(g[i],g[i]),h[i]);\n    }\n    memcpy(R,g,(n+1)<<2);\n}\n\ninline void divide(const int *f,const int *ig,int n,int m,int *R){\n    static int A[N],B[N];\n    memcpy(A,f,(n+1)<<2),memcpy(B,ig,(m+1)<<2);\n    reverse(A,A+n+1);\n    int tt = n-m,lim = getlen((n-m)<<1);\n    memset(A+tt+1,0,(lim-tt)<<2);\n    for(reg int i=min(m,tt)+1;i!=lim;++i) B[i] = 0;\n    multiply(A,B,tt,tt,R,n-m,false);\n    reverse(R,R+tt+1);\n}\n\ninline void mod(const int *f,const int *g,const int *ig,int n,int m,int *R){\n    if(n<m) return;\n    static int A[N],B[N];\n    memcpy(B,f,(n+1)<<2);\n    int lim = getlen(n);\n\tdivide(f,ig,n,m,R);\n\tmemcpy(A,g,(m+1)<<2);\n\tmemset(A+m+1,0,(lim-m+2)<<2);\n\tmemset(R+n-m+1,0,(lim-n+m+1)<<2);\n\tmultiply(A,R,m,n-m,R,m-1,false);\n\tfor(reg int i=0;i!=m;++i) R[i] = dec(B[i],R[i]);\n}\n\nvoid mod_power(const int *G,int k,ll t,int *R){\n    int f[N],g[N],ig[N];\n    memset(f,0,sizeof(f));\n    memset(g,0,sizeof(g));\n    memset(ig,0,sizeof(ig));\n    memcpy(ig,G,(k+1)<<2);\n    reverse(ig,ig+k+1);\n    inverse(ig,k,ig);\n    int n = 1,m = 0;\n    f[1] = g[0] = 1;\n    while(1){\n        if(t&1){\n            multiply(f,g,n,m,g,n+m,false);\n            mod(g,G,ig,n+m,k,g);\n            m = min(n+m,k-1);\n        }\n        t >>= 1;\n        if(t==0) break;\n        multiply(f,f,n,n,f,n<<1,true);\n        mod(f,G,ig,n<<1,k,f);\n        n = min(n<<1,k-1);\n    }\n    memcpy(R,g,k<<2);\n}\n\nvoid poly_pow(const int *f,int n,int k,int *R){\n    static int g[N],h[N];\n    memset(g,0,sizeof(g)),memset(h,0,sizeof(h));\n    memcpy(g,f,(n+1)<<2);\n    h[0] = 1;\n    int m = 0;\n    while(1){\n        if(k&1){\n            multiply(h,g,n,m,h,n+m,false);\n            m += n;\n        }\n        k >>= 1;\n        if(k==0) break;\n        multiply(g,g,n,n,g,n<<1,true);\n        n <<= 1;\n    }\n    memcpy(R,h,(m+1)<<2);\n}\n\ninline int poww(int a,int t,int m){\n    int res = 1;\n    while(t){\n        if(t&1) res = (ll)res*a%m;\n        a = (ll)a*a%m;\n        t >>= 1;\n    }\n    return res;\n}\n\nint k,lim;\nint a[N],f[N],c[N],F[N],G[N];\nll n;\n\nint special(){\n    if(k==1){\n        for(int i=1;i<=42;++i) a[42] += a[42-i]*i;\n        for(int i=1;i<=42;++i) a[i] = add(a[i],a[i-1]);\n        for(int i=43;i;--i) f[i] = dec(f[i],f[i-1]);\n    }\n    int siz = 42+k;\n    matrix A = matrix(siz);\n    for(reg int i=0;i!=siz;++i) A.a[i][0] = f[i+1];\n    for(reg int i=1;i!=siz;++i) A.a[i-1][i] = 1;\n    A = mat_pow(A,n-1);\n    int res = 0;\n    for(reg int i=0;i!=siz;++i) res = (res+(ll)a[siz-1-i]*A.a[i][siz-1])%p;\n    return poww(2,res,p+1);\n}\n\nint main(){\n    int ans = 0;\n    scanf(\"%lld%d\",&n,&k);\n    if(n==1){\n    \tputchar('2');\n    \treturn 0;\n\t}\n    f[0] = p-1;\n    for(reg int i=1;i<=42;++i) a[i-1] = f[i] = i;\n    if(k<=1){\n        printf(\"%d\",special());\n        return 0;\n    }\n    init((k+42)<<1);\n    c[0] = 1,c[1] = p-1;\n    poly_pow(c,1,k,c);\n    lim = k+42; \n    for(reg int i=0;i<=42;++i)\n    for(reg int j=0;j<=k;++j)\n        G[i+j] = (G[i+j]+(ll)f[i]*c[j])%p;\n    inverse(c,lim-1,c);\n    for(reg int i=42;i!=lim;++i)\n    for(reg int j=1;j<=42;++j)\n        a[i] = (a[i]+(ll)a[i-j]*j)%p; \n    multiply(a,c,lim-1,lim-1,a,lim-1,false); \n    reverse(G,G+lim+1);\n    for(reg int i=0;i<=lim;++i) G[i] = G[i]?p-G[i]:0;\n    mod_power(G,lim,n-1,F);\n    for(reg int i=0;i!=lim;++i) ans = (ans+(ll)F[i]*a[i])%p;   \n    printf(\"%d\",poww(2,ans,p+1));\n    return 0;\n}\n```\nps\uff1a\u5176\u5b9e\u53ef\u4ee5\u505a\u5230 $\\Theta(k\\log k + \\log n)$\uff0c\u9700\u8981\u5e26\u4e2a\u51e0\u767e\u500d\u7684\u5e38\u6570\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5199\u4e86\uff08\u9003",
        "postTime": 1566632940,
        "uid": 115864,
        "name": "NaCly_Fish",
        "ccfLevel": 6,
        "title": "[MtOI2019] T6 Solution"
    },
    {
        "content": "\u5982\u4f55\u4e0d\u8fdb\u884c\u591a\u9879\u5f0f\u6c42\u9006\uff1a\n\n\u5df2\u77e5\u9012\u63a8\u591a\u9879\u5f0f\u4e3a $R(x)=(1-\\sum_{j=1}^{42} jx^j)(1-x)^k$\uff0c\u6211\u4eec\u53ea\u9700\u7b97\u51fa $(1-x)^k$ \u7684\u8868\u8fbe\u5f0f\u7136\u540e\u4e0e\u524d\u5f0f\u66b4\u529b\u5377\u79ef\u3002\n\n\u8ba1\u7b97\u4e2d\u8fd8\u9700\u8981 $\\frac1R$\uff0c\u53ea\u9700\u6ce8\u610f\u5230 $\\frac 1{(1-x)^k} = \\sum \\binom{n+k-1}{k-1} x^n$\uff0c\u6211\u4eec\u8fd8\u662f\u9700\u8981\u7b97\u51fa\u7ec4\u5408\u6570\u3002\u7136\u540e\u66b4\u529b\u9664\u4ee5\u4e00\u4e2a\u77ed\u591a\u9879\u5f0f\u4f9d\u7136\u662f\u5bb9\u6613\u7684\u3002\n\n\u6ce8\u610f\u5230 $998244352 = 2^{23} \\times 7\\times 17$\uff0c\u901a\u5e38\u5927\u5bb6\u4f7f\u7528\u7684 exLucas \u8ba1\u7b97\u65f6\u4e0d\u591f\u8fc5\u901f\uff0c\u5c24\u5176\u662f $\\bmod 2^{23}$ \u8fd9\u4e00\u90e8\u5206\u3002\n\n\u4f46\u662f\u8fd9\u91cc\u7684\u74f6\u9888\u662f\u591a\u7ec4\u8be2\u95ee\uff0c\u6211\u4eec\u9884\u5904\u7406\u524d\u7f00\u5947\u6570\u79ef\u4e0e\u5176\u9006\u5143\u5373\u53ef\u3002\u5355\u6b21\u8ba1\u7b97\u7684\u590d\u6742\u5ea6\u5373\u53ef\u964d\u4f4e\u81f3 $\\Theta(\\log k)$\u3002\n\ncode:\n\n```cpp\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nstruct Cd {\n  double re, im;\n\n  Cd(double re = 0, double im = 0) : re(re), im(im) {}\n\n  inline double real() const { return re; }\n  inline double imag() const { return im; }\n\n  inline void real(double re) { this->re = re; }\n  inline void imag(double im) { this->im = im; }\n\n  inline Cd operator+(const Cd& rhs) const { return Cd(re + rhs.re, im + rhs.im); }\n  inline Cd operator-(const Cd& rhs) const { return Cd(re - rhs.re, im - rhs.im); }\n  inline Cd operator-() const { return Cd(-re, -im); }\n  inline Cd operator*(const Cd& rhs) const { return Cd(re * rhs.re - im * rhs.im, re * rhs.im + im * rhs.re); }\n\n  inline void operator+=(const Cd& rhs) { re += rhs.re; im += rhs.im; }\n  inline void operator/=(double x) { re /= x; im /= x; }\n\n  inline friend Cd conj(const Cd& z) { return Cd(z.re, -z.im); }\n};\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int L = 16, N = 1 << L, B = 1 << 15, Q = 998244353, P = 499122176;\nconst double PI = acos(-1);\n\nstruct ExLucas {\n\n  int inv2[1 << 22], prd[1 << 22];\n\n  void exGcd(int a, int b, int& x, int& y) {\n    if (!b) {\n      x = 1;\n      y = 0;\n      return;\n    }\n    exGcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n\n  int inv(int a, int m) {\n    int x, y;\n    exGcd(a, m, x, y);\n    if (x < 0)\n      x += m;\n    return x;\n  }\n\n  int crt(const vector<pair<int, int>>& group) {\n    int m = 1, r = 0;\n    for (const auto& pr : group) {\n      int m1, r1;\n      tie(m1, r1) = pr;\n      int mm = m * m1, i, i1;\n      i = m * (ll)inv(m, m1) % mm;\n      i1 = m1 * (ll)inv(m1, m) % mm;\n      r = (r * (ll)i1 + r1 * (ll)i) % mm;\n      m = mm;\n    }\n    return r;\n  }\n\n  vector<pair<int, int>> factorize(int m) {\n    vector<pair<int, int>> ret;\n    for (int x = 2; x * x <= m; ++x)\n      if (m % x == 0) {\n        int c = 0;\n        while (m % x == 0) {\n          m /= x;\n          ++c;\n        }\n        ret.emplace_back(x, c);\n      }\n    if (m != 1)\n      ret.emplace_back(m, 1);\n    return ret;\n  };\n\n  int mpow(int x, ll k, int m) {\n    int ret = 1;\n    while (k) {\n      if (k & 1)\n        ret = ret * (ll)x % m;\n      x = x * (ll)x % m;\n      k >>= 1;\n    }\n    return ret;\n  }\n\n  int binom2(int n, int m, int k) {\n    int p = 2, pk = 1 << k, ret = 1;\n    ll coe0 = 0;\n    function<void(ll, int)> apply = [&](ll n, int sign) {\n      while (n) {\n        ret = (ret * (ll)(sign == 1 ? prd[(n + 1) / 2] : inv2[(n + 1) / 2])) & ((1 << 22) - 1);\n        coe0 += sign * (n >>= 1);\n      }\n    };\n    apply(n, 1);\n    apply(m, -1);\n    apply(n - m, -1);\n    if (coe0 >= 22) return 0;\n    ret = ((ll)ret << coe0) & ((1 << 22) - 1);\n    return ret;\n  }\n\n  int binom(ll n, ll m, int p, int k) {\n    int pk = 1;\n    for (int rep = 0; rep < k; ++rep)\n      pk *= p;\n    vector<ll> coe(pk);\n    function<void(ll, int)> apply = [&](ll n, int sign) {\n      while (n) {\n        for (int i = 1; i < pk && i <= n; ++i)\n          if (i % p)\n            coe[i] += sign * ((n - i) / pk + 1);\n        coe[0] += sign * (n /= p);\n      }\n    };\n    apply(n, 1);\n    apply(m, -1);\n    apply(n - m, -1);\n    if (coe[0] >= k) return 0;\n    int ret = mpow(p, coe[0], pk);\n    for (int i = 1; i < pk; ++i)\n      if (coe[i] >= 0)\n        ret = ret * (ll)mpow(i, coe[i], pk) % pk;\n      else\n        ret = ret * (ll)mpow(i, pk / p * (p - 1) + coe[i], pk) % pk;\n    return ret;\n  }\n\n  int mod;\n  vector<pair<int, int>> factors;\n\n  ExLucas(int mod) : mod(mod), factors(factorize(mod)) {\n    const int M = 1 << 22;\n    prd[0] = 1;\n    for (int i = 1; i < (1 << 22); ++i)\n      prd[i] = (prd[i - 1] * (ll)(i * 2 - 1)) & (M - 1);\n    inv2[(1 << 22) - 1] = inv(prd[(1 << 22) - 1], M);\n    for (int i = (1 << 22) - 2; i >= 0; --i)\n      inv2[i] = (inv2[i + 1] * (ll)(i * 2 + 1)) & (M - 1);\n  }\n\n  int get(int n, int m) {\n    vector<pair<int, int>> remainder;\n    remainder.reserve(factors.size());\n    for (const auto& factor: factors) {\n      int p, k;\n      tie(p, k) = factor;\n      int pk = 1;\n      for (int rep = 0; rep < k; ++rep)\n        pk *= p;\n      remainder.emplace_back(pk, p == 2 ? binom2(n, m, k) : binom(n, m, p, k));\n    }\n    return crt(remainder);\n  }\n\n} binomP(P);\n\nint k, lgk;\nint brev[N], irec[N], rec[N], f[N], a[N];\nCd w[N];\n\nint mpow(int x, int k, int P) {\n  int ret = 1;\n  while (k) {\n    if (k & 1)\n      ret = ret * (ll)x % P;\n    x = x * (ll)x % P;\n    k >>= 1;\n  }\n  return ret;\n}\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P) x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0) x += P;\n}\n\nvoid preparefft(int lgn) {\n  for (int i = 1; i < (1 << lgn); ++i) brev[i] = (brev[i >> 1] >> 1) | ((i & 1) << (lgn - 1));\n  for (int i = 0; i < (1 << lgn); ++i)\n    w[i] = Cd(cos(2 * PI * i / (1 << lgn)), sin(2 * PI * i / (1 << lgn)));\n}\n\nvoid fft(Cd* a, int lgn, int sgn) {\n  int n = 1 << lgn;\n  int k = L;\n  for (int i = 0; i < n; ++i) {\n    int brv = brev[i] >> (L - lgn);\n    if (brv > i)\n      swap(a[i], a[brv]);\n  }\n  for (int t = 1; t < n; t <<= 1) {\n    --k;\n    for (int i = 0; i < n; i += t << 1) {\n      Cd *p = a + i, *q = a + i + t;\n      for (int j = 0; j < t; ++j) {\n        Cd x = w[j << k] * q[j];\n        q[j] = p[j] - x;\n        p[j] += x;\n      }\n    }\n  }\n  if (sgn == -1) {\n    reverse(a + 1, a + n);\n    for (int i = 0; i < n; ++i) a[i] /= n;\n  }\n}\n\nvoid dft(Cd* a, Cd* b, int lgn, int d) {\n  int n = 1 << lgn;\n  for (int i = 0; i < n; ++i) a[i].imag(b[i].real());\n  fft(a, lgn, d);\n  b[0] = conj(a[0]);\n  for (int i = 1; i < n; ++i) b[i] = conj(a[n - i]);\n\n  for (int i = 0; i < n; ++i) {\n    Cd x = a[i], y = b[i];\n    a[i] = (x + y) * 0.5;\n    b[i] = (x - y) * Cd(0, -0.5);\n  }\n}\n\ntypedef Cd DFT[2][N];\n\nvoid tDFT(int* a, int lgn, DFT& va) {\n  for (int i = 0; i < 2; ++i)\n    memset(va[i], 0, sizeof(Cd) << lgn);\n  for (int i = 0; i < (1 << (lgn - 1)); ++i) {\n    va[0][i].real(a[i] & (B - 1));\n    va[1][i].real(a[i] >> 15);\n  }\n  dft(va[0], va[1], lgn, 1);\n}\n\nvoid mult(int* a, int lgk, DFT& vb, int* c) {\n  static DFT va;\n  static Cd vc[3][N];\n\n  tDFT(a, lgk + 1, va);\n\n  for (int bi = 0; bi <= 2; ++bi)\n    memset(vc[bi], 0, sizeof(Cd) << (lgk + 1));\n  for (int bi = 0; bi < 2; ++bi)\n    for (int bj = 0; bj < 2; ++bj)\n      for (int i = 0; i < (1 << (lgk + 1)); ++i) vc[bi + bj][i] += va[bi][i] * vb[bj][i];\n  memset(c, 0, sizeof(int) << (lgk + 1));\n  for (int bi = 2; bi >= 0; --bi) {\n    fft(vc[bi], lgk + 1, -1);\n    for (int i = 0; i < (1 << (lgk + 1)); ++i) c[i] = (((ll)c[i] << 15) + ll(vc[bi][i].real() + 0.5)) % P;\n  }\n}\n\nvoid sqr(int* a, int n) {\n  static Cd va[2][N], vc[3][N];\n\n  int lgn = 0;\n  while ((1 << lgn) <= n * 2) ++lgn;\n\n  for (int i = 0; i < 2; ++i)\n    memset(va[i], 0, sizeof(Cd) << lgn);\n  for (int i = 0; i <= n; ++i) {\n    va[0][i].real(a[i] & (B - 1));\n    va[1][i].real(a[i] >> 15);\n  }\n  dft(va[0], va[1], lgn, 1);\n\n  for (int bi = 0; bi <= 2; ++bi)\n    memset(vc[bi], 0, sizeof(Cd) << lgn);\n  for (int bi = 0; bi < 2; ++bi)\n    for (int bj = 0; bj < 2; ++bj)\n      for (int i = 0; i < (1 << lgn); ++i) vc[bi + bj][i] += va[bi][i] * va[bj][i];\n  memset(a, 0, sizeof(int) * (n * 2 + 1));\n  for (int bi = 2; bi >= 0; --bi) {\n    fft(vc[bi], lgn, -1);\n    for (int i = 0; i <= n * 2; ++i) a[i] = (((ll)a[i] << 15) + ll(vc[bi][i].real() + 0.5)) % P;\n  }\n}\n\nDFT irecf, recf;\n\nvoid div(int* a) {\n  static int b[N];\n\n  int m = k * 2 + 85;\n\n  for (int i = k + 42; i <= m; ++i)\n    b[m - i] = a[i];\n  mult(b, lgk - 1, irecf, b);\n\n  reverse(b, b + k + 43 + 1);\n  for (int i = k + 44; i < (1 << lgk); ++i) b[i] = 0;\n\n  mult(b, lgk - 1, recf, b);\n  for (int i = 0; i <= m; ++i)\n    sub(a[i], b[i]);\n\n}\n\nint solve(ll n) {\n  n += k;\n\n  while ((1 << lgk) <= k * 2 + 85) ++lgk;\n\n  tDFT(rec, lgk, recf);\n  tDFT(irec, lgk, irecf);\n\n  a[0] = 1;\n  int lgn = 0;\n  while ((1LL << (lgn + 1)) <= n) ++lgn;\n  while (lgn >= 0) {\n    sqr(a, k + 42);\n    if ((n >> lgn) & 1) {\n      for (int i = k * 2 + 85; i; --i)\n        a[i] = a[i - 1];\n      a[0] = 0;\n    }\n    div(a);\n\n    --lgn;\n  }\n\n  int ret = 0;\n  for (int i = 0; i <= 42; ++i)\n    ret = (ret + f[i] * (ll)a[i + k]) % P;\n  return ret;\n}\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n\n  preparefft(L);\n  ll n;\n  scanf(\"%lld%d\", &n, &k);\n  if (k) {\n    for (int i = 0; i <= k + 42; ++i)\n      irec[i] = binomP.get(i + k - 1, k - 1);\n  } else\n    irec[0] = 1;\n  for (int i = 1; i <= k + 42; ++i)\n    for (int j = 1; j <= min(i, 42); ++j)\n      irec[i] = (irec[i] + irec[i - j] * (ll)j) % P;\n  for (int i = 0; i <= k; ++i)\n    rec[i] = (i & 1) ? (P - binomP.get(k, i)) : binomP.get(k, i);\n  for (int i = k + 42; i; --i)\n    for (int j = 1; j <= min(i, 42); ++j)\n      rec[i] = (rec[i] + (P - rec[i - j]) * (ll)j) % P;\n  reverse(rec, rec + k + 42 + 1);\n  for (int i = 0; i <= 42; ++i)\n    f[i] = i + 1;\n  for (int rep = 0; rep < k; ++rep) {\n    for (int i = 1; i <= 42; ++i)\n      add(f[i], f[i - 1]);\n  }\n  printf(\"%d\\n\", mpow(2, solve(n - 1), Q));\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int((clock() - nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n```",
        "postTime": 1566636004,
        "uid": 21423,
        "name": "Elegia",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 P5519 \u3010[MtOI2019]\u57cb\u9aa8\u4e8e\u5f18\u5ddd\u3011"
    }
]