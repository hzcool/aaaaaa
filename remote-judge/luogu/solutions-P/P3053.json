[
    {
        "content": "## \u8fd9\u9053\u9898\u7684 x \u548c y \u4e0e\u4e00\u822c\u7684\u7f51\u683c\u56fe\u4e0d\u4e00\u6837\uff0c\u8fd9\u662f\u6570\u5b66\u6982\u5ff5\u4e0a\u7684\u5750\u6807\u7cfb\uff01\uff01\uff01\uff01\r\n\r\n~~\u4f60\u8fd9\u4ee3\u7801\u4fddAC\u5417~~  \r\n~~\u90a3\u5f53\u7136~~\r\n\r\n#### \u9898\u610f\r\n\r\n\u5c31\u662f\u7ed9\u4f60\u4e09\u4e2a\u62fc\u56fe\u4e0a\uff0c\u6bcf\u4e00\u4e2a\u65b9\u683c\u6240\u5bf9\u5e94\u7684\u5750\u6807\u3002\u8981\u6c42\u4f60\u6c42\u51fa\u8ba9\u4e09\u4e2a\u62fc\u56fe\u5206\u5f00\u7684\u6700\u5c0f\u6b65\u6570\u3002\u800c\u76f8\u4e92\u79bb\u5f00\u4e5f\u5c31\u662f\u6210\u529f\u7684\u6761\u4ef6\u662f\u4e09\u4e2a\u62fc\u56fe\u6240\u5bf9\u5e94\u7684\u77e9\u5f62\u4e92\u4e0d\u91cd\u5408\u3002\r\n\u4f8b\u5982\u4e0b\u56fe\u62fc\u56fe\uff1a\r\n\r\n![5Kg63t.png](https://z3.ax1x.com/2021/10/13/5Kg63t.png)\r\n\r\n\u5176\u5bf9\u5e94\u7684\u77e9\u5f62\u5c31\u662f\u7ea2\u8272\u6846\u6240\u5305\u62ec\u7684\u8303\u56f4\uff08\u539f\u8c05\u6211\u7684\u56fe\u753b\u7684\u4e11\uff09\r\n\r\n\u6ca1\u9519\u8fd9\u5176\u5b9e\u5c31\u662f\u4e00\u9053 `BFS` \u7684\u66b4\u529b\u641c\u7d22\u3002\u5bf9\u4e8e\u6bcf\u4e00\u6b65\u7684\u72b6\u6001\u8f6c\u79fb\u5224\u65ad\u7a0d\u5fae\u6709\u70b9\u70b9\u9ebb\u70e6\u800c\u5df2\u3002\r\n\r\n\u9996\u5148\u8003\u8651\u8fd9\u9053\u9898\u76ee\u7684\u72b6\u6001\u8bbe\u8ba1\uff0c\u6216\u8bb8\u6709\u4eba\u4f1a\u8003\u8651\u7528 $(x_1, y_1, x_2, y_2, x_3, y_3, cost)$ \u6765\u8868\u793a\u4e09\u4e2a\u62fc\u56fe\u5750\u6807\u504f\u79fb\u91cf\u4e0e\u64cd\u4f5c\u6b21\u6570\u3002\u4e0d\u8fc7\u9700\u8981\u8003\u8651\uff0c\u504f\u79fb\u91cf\u53ef\u80fd\u4e3a __\u8d1f\u6570__ \u4e14\u81f3\u591a\u4e3a __$|10|$__ \uff0c\u6240\u4ee5\u9700\u8981\u4e00\u4e2a\u504f\u79fb\u91cf\u6765\u9632\u6b62\u8d1f\u6570\u4e0b\u6807\r\n\u5176\u65f6\u95f4\u590d\u6742\u5ea6\u548c\u7a7a\u95f4\u590d\u6742\u5ea6\u76f4\u63a5\u7206\u70b8\u5230 $O(46656000000)$\r\n~~(\u8ba1\u7b97\u673a\uff1a\u770b\u770b\u8fd9\u662f\u4eba\u6de6\u7684\u561b)~~\uff0c\u4f46\u662f\u4e0d\u96be\u60f3\u5230\uff0c\u6211\u4eec\u53ef\u4ee5\u56fa\u5b9a\u5176\u4e2d\u4e00\u4e2a\u62fc\u56fe\u7684\u4f4d\u7f6e\uff0c\u53ea\u5bf9\u53e6\u5916\u4e24\u4e2a\u62fc\u56fe\u5750\u6807\u504f\u79fb\u91cf\u8fdb\u884c\u8f6c\u79fb\u3002\r\n\r\n\u5bf9\u4e8e\u90a3\u4e2a\u56fa\u5b9a\u7684\u62fc\u56fe\u7684\u79fb\u52a8\uff0c\u6211\u4eec\u53ef\u4ee5\u540c\u65f6\u64cd\u4f5c\u53e6\u5916\u4e24\u4e2a\u62fc\u56fe\u8fdb\u884c\u53cd\u65b9\u5411\u7684\u79fb\u52a8\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u72b6\u6001 $(x_1, y_1, x_2, y_2, cost)$\uff0c\u9700\u8981\u540c\u65f6\u8f6c\u79fb\u81f3\r\n$(x_1 + fy_i, y_1 + fx_i, x_2, y_2, cost + 1)$ \u4e0e\r\n$(x_1, y_1, x_2 + fx_i, y_2 + fy_i, cost + 1)$\uff0c \u8fd8\u6709 $(x_1 - fx_i, y_1 - fy_i, x_2 - fx_i, y_2 - fy_i, cost + 1)$ (\u5176\u5b9e\u4f60\u628a `+` \u6539\u6210 `-` \u4e5f\u4e0d\u4f1a\u6709\u4e8b)\r\n\r\n\r\ncode:\r\n\r\n``` cpp\r\n#include <iostream>\r\n#include <cstring>\r\n#include <vector>\r\n#include <cstdio>\r\n#include <queue>\r\n#include <climits>\r\n// #define int long long \r\n\r\nusing namespace std;\r\n\r\n// \u9632\u8d1f\u6570\u4e0b\u6807\r\nconst int P = 30;\r\nconst int fx[4] = {1, -1, 0, 0}, fy[4] = {0, 0, 1, -1};\r\n\r\ninline int read() {\r\n    char ch = getchar();\r\n    int num = 0, w = 1;\r\n    while (ch < '0' || ch > '9') w = ch == '-' ? -1 : 1, ch = getchar();\r\n    while (ch >= '0' && ch <= '9') num = num * 10 + ch - '0', ch = getchar();\r\n    return num * w;\r\n};\r\n\r\nstruct node {\r\n    int x, y;\r\n    node() : x(0), y(0) { };\r\n    node(int x_, int y_) : x(x_), y(y_) { };\r\n};\r\n\r\nstruct box_t {\r\n    int top = -INT_MAX, left = INT_MAX, down = INT_MAX, right = -INT_MAX;\r\n    vector<node> c;\r\n};\r\n\r\nint n1, n2, n3;\r\nbox_t box[4];\r\nint d[65][65][65][65];\r\nbool has[65][65];\r\nbool box3[65][65];\r\nqueue<node> q1, q2;\r\n\r\n// \u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426ok\r\nbool ok(int x1, int y1, int x2, int y2) {\r\n    for (int i = 1; i <= 3; i++) {\r\n        for (int j = 1; j <= 3; j++) {\r\n            if (i == j) continue;\r\n            int top = box[j].top, right = box[j].right, down = box[j].down, left = box[j].left;\r\n            if (j == 1) top += y1, right += x1, down += y1, left += x1;\r\n            if (j == 2) top += y2, right += x2, down += y2, left += x2;\r\n            for (node n : box[i].c) {\r\n                if (i == 1) n.x += x1, n.y += y1;\r\n                if (i == 2) n.x += x2, n.y += y2;\r\n                if (top >= n.y && n.y >= down && left <= n.x && n.x <= right) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// \u5224\u65ad\u8fd9\u6837\u7684\u504f\u79fb\u91cf\u662f\u5426\u53ef\u4ee5\r\nbool check(int x1, int y1, int x2, int y2) {\r\n    int x, y;\r\n    memset(has, false, sizeof(has));\r\n    for (node i : box[1].c) {\r\n        x = i.x + x1 + P, y = i.y + y1 + P;\r\n        if (x < 1 || x > 60 || y < 1 || y > 60) return false;\r\n        if (box3[y][x] || has[y][x]) {\r\n            return false;\r\n        }\r\n        has[y][x] = true;\r\n    }\r\n    for (node i : box[2].c) {\r\n        x = i.x + x2 + P, y = i.y + y2 + P;\r\n        if (x < 1 || x > 60 || y < 1 || y > 60) return false;\r\n        if (box3[y][x] || has[y][x]) {\r\n            return false;\r\n        }\r\n        has[y][x] = true;\r\n    }\r\n    return true;\r\n}\r\n\r\n// \u6b64\u5904 x y \u5b58\u50a8\u7684\u662f\u504f\u79fb\u91cf\r\nvoid Record(int x1, int y1, int x2, int y2, int d_) {\r\n    if (!check(x1, y1, x2, y2) || ~d[y1 + P][x1 + P][y2 + P][x2 + P]) {\r\n        return ;\r\n    }\r\n    d[y1 + P][x1 + P][y2 + P][x2 + P] = d_;\r\n    q1.push({x1, y1}), q2.push({x2, y2});\r\n}\r\n\r\nint bfs() {\r\n    for (node i : box[3].c) {\r\n        box3[i.y + P][i.x + P] = true;\r\n    }\r\n    Record(0, 0, 0, 0, 0);\r\n    while (!q1.empty()) {\r\n        int x1 = q1.front().x, y1 = q1.front().y,\r\n            x2 = q2.front().x, y2 = q2.front().y;\r\n        if (ok(x1, y1, x2, y2)) {\r\n            return d[y1 + P][x1 + P][y2 + P][x2 + P];\r\n        }\r\n        for (int i = 0; i < 4; i++) {\r\n            Record(x1 + fx[i], y1 + fy[i], x2, y2, d[y1 + P][x1 + P][y2 + P][x2 + P] + 1);\r\n            Record(x1, y1, x2 + fx[i], y2 + fy[i], d[y1 + P][x1 + P][y2 + P][x2 + P] + 1);\r\n            Record(x1 + fx[i], y1 + fy[i], x2 + fx[i], y2 + fy[i], d[y1 + P][x1 + P][y2 + P][x2 + P] + 1);\r\n        }\r\n        q1.pop(), q2.pop();\r\n    }\r\n    return -1;\r\n}\r\n\r\nint main() {\r\n    int n[4];\r\n    memset(d, -1, sizeof(d));\r\n    n[1] = read(), n[2] = read(), n[3] = read();\r\n    for (int i = 1; i <= 3; i++) {\r\n        for (int j = 1; j <= n[i]; j++) {\r\n            int x = read(), y = read();\r\n            box[i].c.push_back({x, y});\r\n            box[i].top  = max(box[i].top, y);\r\n            box[i].left = min(box[i].left, x);\r\n            box[i].right= max(box[i].right, x);\r\n            box[i].down = min(box[i].down, y);\r\n        }\r\n    }\r\n    cout << bfs();\r\n    return 0;\r\n}\r\n```\r\n\r\n~~\u7ba1\u7406\u8f9b\u82e6\u4e86~~",
        "postTime": 1633330943,
        "uid": 311721,
        "name": "YCSluogu",
        "ccfLevel": 6,
        "title": "P3053"
    },
    {
        "content": "## Sol ##\n\n[blog\u98df\u7528](http://www.caolaoshi.men/index.php/archives/usaco12open-ub.html)\n\n\u771f\u7684\u53ea\u662f\u4e00\u4e2a$BFS$\uff01\uff01\uff01~~\u4e00\u4e2a\u6c27\u6c14\u90fd\u6551\u4e0d\u4e86\u7684\u7a0b\u5e8f\uff08\u5feb\u8bfb+\u5feb\u5199\u8fd8$TLE$\u4e86\u4e00\u4e2a\u70b9\uff09~~\n\n\u5927\u4f53\u601d\u8def\uff1a\u5bf9\u4e8e\u6bcf\u4e00\u79cd\u72b6\u6001\uff0c\u6211\u4eec\u679a\u4e3e\u4e09\u4e2a\u6a21\u5757\u662f\u5426\u53ef\u4ee5\u5411\u5de6\u5411\u53f3\u5411\u4e0a\u5411\u4e0b\u79fb\u52a8\uff0c\u5982\u679c\u53ef\u4ee5\u79fb\u52a8\uff0c\u5165\u961f\uff0c\u7ee7\u7eed\u641c\u7d22\uff0c\u961f\u5217\u4e2d\u5b58\u6574\u5f20\u56fe\u3002**\u5904\u7406\u65b9\u6cd5\uff1a\u5bf9\u4e8e\u961f\u5217\u4e2d\u7684\u56fe\uff0c\u4e0d\u9700\u8981\u6bcf\u4e00\u4e2a\u70b9\u90fd\u5b58\u50a8\u3002\u5728\u8f93\u5165\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u70b9\u4e4b\u95f4\u7684\u76f8\u5bf9\u4f4d\u7f6e\u6c42\u51fa\u8fd9\u4e2a\u6a21\u5757\u7684\u5f62\u72b6\uff0c\u5b58\u8d77\u6765\uff0c\u8fd9\u6837\u961f\u5217\u4e2d\u53ea\u9700\u8981\u5bf9\u6bcf\u4e00\u4e2a\u6a21\u5757\u5b58\u4e00\u4e2a\u4f4d\u7f6e\u5c31\u53ef\u4ee5\uff0c\u6211\u4eec\u628a\u8fd9\u4e2a\u4f4d\u7f6e\u53eb\u505a\u6a21\u5757\u7684\u4ee3\u8868\u70b9\uff0c\u8fd9\u6837\u5c31\u80fd\u63a8\u51fa\u5176\u4ed6\u7684\u4f4d\u7f6e\u3002**\n\n\u5173\u952e\u7684\u5730\u65b9\u5728\u4e8e**\u5982\u4f55\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5165\u8fc7\u961f\u3002**\u7528\u96c6\u5408\u914d\u5408\u7c7b\u4f3c\u54c8\u5e0c\u6765\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u5b58\u50a8\u7684\u53ea\u6709\u4e09\u4e2a\u70b9\uff0c\u516d\u4e2a\u503c\uff0c\u7b2c\u4e00\u611f\u89c9\u5c31\u662f\u516d\u7ef4\u6570\u7ec4\uff0c\u7136\u800c\u516d\u7ef4\u6570\u7ec4\u4f1a$MLE$\u3002\u4e3a\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3a\u6211\u4eec\u5b58\u50a8\u7684\u4e0d\u53ea\u662f\u4e00\u4e2a$10\u00d710$\u7684\u77e9\u9635\uff0c\u800c\u662f$30\u00d730$\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u628a\u770b\u4e0d\u5230\u7684\u5730\u65b9\u5b58\u8d77\u6765\uff0c\u8fd9\u6837\u7684\u516d\u7ef4\u6570\u7ec4\u4f1a\u53d8\u5f97\u5f88\u5927\uff0c\u56e0\u6b64\u4f1a$MLE$\u3002\n\n\u56e0\u4e3a\u6211\u4eec\u53ea\u662f\u5b58\u4e86\u516d\u4e2a\u6570\uff0c\u5373\u4e09\u4e2a\u6a21\u5757\u7684\u4ee3\u8868\u70b9\u7684\u6a2a\u7eb5\u5750\u6807\uff0c\u6240\u4ee5\u5c31\u53ef\u4ee5\u5c06\u8fd9\u516d\u4e2a\u503c\u54c8\u5e0c\u4e3a\u4e00\u4e2a\u516d\u4f4d\u6570\u7684\u503c\uff0c\u653e\u5165\u96c6\u5408\uff0c\uff08\u7a81\u7136\u60f3\u5230\u8fd9\u91cc\u597d\u50cf\u53ef\u4ee5\u7528\u4e00\u4f4d\u6570\u7ec4\uff0c\u8bf7\u81ea\u884c\u5c1d\u8bd5\uff09\u3002\n\n\u8fd8\u9700\u8981\u4e24\u4e2a\u5f88\u957f\u5f88\u957f\u7684\u5224\u65ad\uff0c**\u4e00\u4e2a\u662f\u5224\u65ad\u5f53\u524d\u72b6\u6001\u662f\u5426\u5c31\u662f\u7b54\u6848\uff0c\u53e6\u4e00\u4e2a\u662f\u6bcf\u4e00\u4e2a\u6a21\u5757\u7684\u6bcf\u4e00\u4e2a\u65b9\u5411\u662f\u5426\u53ef\u4ee5\u79fb\u52a8\u3002**\u8fd9\u4e24\u4e2a\u5224\u65ad\u8fd8\u662f\u5f88\u597d\u5199\u7684\uff0c\u4e0d\u591a\u8bf4\u4e86\u3002\n\n## Code ##\n\n```\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<set>\n#include<cstring>\nusing namespace std;\n\nstruct Node {\n    int x , y;\n};\nNode shape[5][105] , sta[5];\nstruct Que {\n    Node n[4];\n    int cnt;\n    Que(){};\n    Que(Node nn1 , Node nn2 , Node nn3 , int ccnt) {\n        n[1] = nn1 , n[2] = nn2 , n[3] = nn3 , cnt = ccnt;\n    }\n};\nset<int>s;\nqueue<Que>q;\nint n[4] , dx[4] = {0,0,-1,1} , dy[4] = {1,-1,0,0};\ninline int mymin(int a , int b) { return a<b?a:b; }\ninline int mymax(int a , int b) { return a>b?a:b; }\n\nvoid read(int &x)\n{\n    char c = getchar(); x = 0;\n    while(c < '0' || c > '9') c = getchar();\n    while(c <= '9' && c >= '0') x = x*10+c-48, c = getchar();\n}\n\nvoid put(int x)  \n{  \n    int num = 0; char c[15];\n    while(x) c[++num] = (x%10)+48, x /= 10;\n    while(num) putchar(c[num--]);\n    putchar('\\n'); \n}\n\nint jud(Que x) {\n    int hin[4] , hax[4] , zin[4] , zax[4] , map[35][35];\n    memset(map , 0 , sizeof(map));\n    for(int i=1; i<=3; i++) {\n        hin[i] = zin[i] = 0x3f;\n        hax[i] = zax[i] = 0;\t\t\n    }\n    for(int i=1; i<=3; i++)\n        for(int j=1; j<=n[i]; j++) {\n            int xx , yy;\n            xx = x.n[i].x + shape[i][j].x;\n            yy = x.n[i].y + shape[i][j].y;\n            hin[i] = mymin(hin[i] , xx);\n            hax[i] = mymax(hax[i] , xx);\n            zin[i] = mymin(zin[i] , yy);\n            zax[i] = mymax(zax[i] , yy);\n        }\n    for(int i=1; i<=3; i++)\n        for(int j=zin[i]; j<=zax[i]; j++)\n            for(int k=hin[i]; k<=hax[i]; k++) {\n                if(map[j+10][k+10])\n                    return 0;\n                map[j+10][k+10] = 1;\t\n            }\n    return 1;\n}\n\nint mov(int x , int d , Que t) {\n    int map[35][35];\n    memset(map , 0 , sizeof(map));\n    for(int i=1; i<=3; i++) {\n        if(i == x) {\n            t.n[i].x += dx[d];\n            t.n[i].y += dy[d];\n        }\n        for(int j=1; j<=n[i]; j++) {\n            int xx , yy;\n            xx = t.n[i].x + shape[i][j].x;\n            yy = t.n[i].y + shape[i][j].y;\n            if(map[xx+10][yy+10])\n                return 0;\n            map[xx+10][yy+10] = 1;\n        }\n    }\n    return 1;\n}\n\nvoid update(int &a , Que b) {\n\ta = b.n[1].x*100000+b.n[1].y*10000+b.n[2].x*1000+b.n[2].y*100+b.n[3].x*10+b.n[3].y;\n}\n\nint main() {\n\tread(n[1]) , read(n[2]) , read(n[3]); \n    for(int i=1; i<=3; i++) {\n        Node a;\n        read(a.x) , read(a.y);\n        sta[i] = a;\n        shape[i][1] = (Node){0,0};\n        for(int j=2; j<=n[i]; j++) {\n            int x , y;\n            read(x) , read(y);\n            shape[i][j] = (Node){x-a.x,y-a.y};\n        }\n    }\n    q.push(Que(sta[1],sta[2],sta[3],0));\n    s.insert(sta[1].x*100000+sta[1].y*10000+sta[2].x*1000+sta[2].y*100+sta[3].x*10+sta[3].y);\n    while(!q.empty()) {\n        Que u = q.front() , v;\n        q.pop();\n        if(jud(u)) {\n        \tput(u.cnt);\n            return 0;\n        }\n        u.cnt++;\n        for(int i=0; i<4; i++)\n            for(int j=1; j<=3; j++)\n                if(mov(j,i,u)) {\n                    v = u;\n                    Node t;\n                    int m;\n                    t.x = v.n[j].x + dx[i];\n                    t.y = v.n[j].y + dy[i];\n                    v.n[j] = t;\n\t\t\t\t\tupdate(m,v);\n\t\t\t\t\tif(s.find(m)==s.end()) {\n\t\t\t\t\t\ts.insert(m);\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n                }\n    }\n    printf(\"-1\");\n    return 0;\n}\n```\n\n\n  [1]: https://www.luogu.org/problemnew/show/P3053",
        "postTime": 1536136150,
        "uid": 37427,
        "name": "\u66f9\u8001\u5e08",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P3053 \u3010[USACO12OPEN]\u89e3\u9501\u5757\uff08\u94f6\uff09Unlocking Bloc\u2026\u3011"
    }
]