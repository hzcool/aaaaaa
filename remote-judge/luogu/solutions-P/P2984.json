[
    {
        "content": "# ~~\u5173\u4e8eFloyd\uff0c\u5b83\u592a\u6162\u4e86~~\n# ~~\u5173\u4e8espfa,\u5b83\u6b7b\u4e86~~\n# \u5173\u4e8edijkstra\uff0c\u8fd8\u662f\u7528\u5b83\u5427\n\n**\u6b65\u5165\u6b63\u9898\uff1a**\n\n\u8fd9\u9053\u9898\uff0c\u5343\u4e07\u4e0d\u8981\u88ab\u9898\u9762\u6240\u8bef\u5bfc\n\n\u9898\u76ee\u5927\u610f\uff1a\u70b9u\u5230\u70b91\u7684\u6700\u77ed\u8def+\u70b91\u5230\u70b9v\u7684\u6700\u77ed\u8def\n\n**\u4f46\u662f**\uff0c\u60a8\u8981\u662f\u7167\u7740\u8fd9\u4e2a\u601d\u8def\u5199\u4ee3\u7801\u7684\u8bdd\uff0c\u53ea\u80fd\u62ff\u523050\u5206\uff0cT\u4e865\u4e2a\u70b9\n\n\u663e\u7136\uff0c\u8fd9\u4e2a\u505a\u6cd5\u4e0d\u591f\u4f18\u79c0\n\n\u8fdb\u4e00\u6b65\uff0c\u6211\u4eec\u53d1\u73b0\uff0c**\u5728\u7b2ci\u5934\u5976\u725b\u7684\u884c\u52a8\u4e2d\uff0c\u80af\u5b9a\u4f1a\u7ecf\u8fc71\u53f7\u70b9**\n\n\u6240\u4ee5\uff0c\u53ea\u8981\u8dd1\u4e00\u8fb9dijkstra\u5c31\u597d\u4e86\uff0c\u628a\u8d77\u70b9\u8bbe\u4e3a1\n\n\u6bcf\u5f53\u8fdb\u884c\u4e00\u6b21\u8be2\u95ee\uff0c\u5c31\u8f93\u51fad[u]+d[v] \uff08d[]\u8bb0\u5f55\u6700\u77ed\u8ddd\u79bb\uff09\n\n//\u6ce8\u91ca\u90fd\u5728\u4ee3\u7801\u91cc\u4e86\n\n**\u4e0a\u4ee3\u7801\uff1a\uff08vector\u5b58\u56fe+dijkstra+\u5806\u4f18\u5316\uff09**\n```cpp\n//\u4ee3\u7801\u91cd\u5728\u5b9e\u7528\uff0c\u4e0d\u5728\u534e\u4e3d\u7684\u64cd\u4f5c \n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,t,d[50010],ans;\n//n\u4e2a\u8282\u70b9\uff0cm\u6761\u8fb9\uff0ct\u6b21\u8be2\u95ee\uff0cd[]\u5b58\u6700\u77ed\u8ddd\u79bb\uff0cans\u4e3a\u6bcf\u6b21\u8be2\u95ee\u7684\u7b54\u6848 \nstruct edge\n{\n\tint to,cost;\n};\nvector<edge>G[50010];//vector\u5b58\u56fe \ntypedef pair<int,int>P;//\u5b9a\u4e49\u4e00\u4e2apair\u7c7b\u578b\u7684P\uff08\u53ea\u662f\u4e3a\u4e86\u5199\u8d77\u6765\u7b80\u5355\u4e00\u70b9\uff09 \nvoid dijkstra(int s)//s\u4e3a\u8d77\u70b9\uff0c\u5728\u8fd9\u9053\u9898\u91cc\u5c31\u662f1 \n{\n\tpriority_queue<P,vector<P>,greater<P> >q;\n\t//\u4e00\u4e2aP\u7c7b\u578b\uff08pair\uff09\u7c7b\u578b\u7684\u4f18\u5148\u961f\u5217  \n\tfor(int i=1;i<=n;i++) d[i]=1e9;//\u8d4b\u521d\u503c1e9 \n\td[s]=0;//\u81ea\u5df1\u5230\u81ea\u5df1\u7684\u8ddd\u79bb\u662f0 \n\tq.push(P{0,s});//\u52a0\u5165\u961f\u5217\u7b49\u5f85\u5904\u7406 \n\twhile(!q.empty())\n\t{\n\t\tP p=q.top();//\u53d6\u961f\u9996 \n\t\tq.pop();\n\t\t//\u58f0\u660e\u4e00\u4e0b\uff1ap.first\u4ee3\u8868\u7684\u662f\u4e00\u4e2a\u8ddd\u79bb\uff0c\u800cp.second\u4ee3\u8868\u7684\u662f\u4e00\u4e2a\u70b9\uff0c \n\t\t//Tell\u4e00\u4e2a\u4e0d\u4e3a\u4eba\u77e5\u7684\u79d8\u5bc6\uff0c \n\t\t//\u82e5\u628ap.first\u8bbe\u4e3a\u4e00\u4e2a\u70b9\uff0c\u800c\u628ap.second\u8bbe\u4e3a\u4e00\u4e2a\u8ddd\u79bb\uff0c\n\t\t//\u7a0b\u5e8f\u7684\u901f\u5ea6\u5c31\u6ca1\u6709\u7b2c\u4e00\u4e2a\u4f18\u79c0\uff08\u4eb2\u6d4b\uff09 \n\t\tint v=p.second;//\u4e5f\u662f\u4e3a\u4e86\u5199\u8d77\u6765\u7b80\u4fbf\u4e00\u70b9\uff0c \n\t\tif(d[v]<p.first) continue;//\u5982\u679c\u5df2\u7ecf\u662f\u4e00\u4e2a\u6700\u77ed\u8ddd\u79bb\u4e86\uff0ccontinue\uff1b \n\t\tfor(int i=0;i<G[v].size();i++)//\u5faa\u73af\u70b9v\u8fde\u63a5\u7684\u6240\u6709\u70b9 \n\t\t{\n\t\t\tedge e=G[v][i]; \n\t\t\tif(d[e.to]>d[v]+e.cost)//\u677e\u5f1b\u64cd\u4f5c\uff0c\u8d2a\u5fc3\u601d\u60f3 \n\t\t\t{\n\t\t\t\td[e.to]=d[v]+e.cost;//\u66f4\u65b0d[e.to]\u7684\u503c \n\t\t\t\tq.push(P{d[e.to],e.to});//\u91cd\u65b0\u52a0\u5165\u5230\u961f\u5217\u7b49\u5f85\u5904\u7406 \n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&t);\n\twhile(m--)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tG[u].push_back(edge{v,w});//\u6ce8\u610f\uff0c\u8fd9\u4e2a\u56fe\u662f\u4e00\u4e2a\u65e0\u5411\u56fe \n\t\tG[v].push_back(edge{u,w});\n\t}\n\tdijkstra(1);\n\t//\u4ee51\u53f7\u70b9\u4e3a\u8d77\u70b9\u8fdb\u884cdijkstra()\uff0c\u4fbf\u53ef\u83b7\u5f971\u53f7\u70b9\u5230\u5176\u5b83\u4efb\u610f\u4e00\u70b9\u7684\u6700\u77ed\u8ddd\u79bb \n\twhile(t--)\n\t{\n\t\tans=0;\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tans=d[u]+d[v];//\u76f4\u63a5\u8f93\u51fa\u7b54\u6848 \n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;//\u517b\u6210\u826f\u597d\u4e60\u60ef \n}\n```\n\u8fd9\u4e16\u754c\u4e0a\u4e0d\u7f3a\u5c11\u4ec0\u4e48\u6c34\u9898\uff0c\u800c\u662f\u7f3a\u5c11\u53d1\u73b0\u6c34\u9898\u7684\u773c\u775b\n\n\u770b\u6211\u5199\u7684\u8fd9\u4e48\u8ba4\u771f\uff0c\u662f\u5426\u53ef\u4ee5\u70b9\u4e2a\u8d5e\u518d\u8d70\u5462\uff1f",
        "postTime": 1583131380,
        "uid": 174303,
        "name": "_NaCly_Fish",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]Chocolate Giving S\u3011"
    },
    {
        "content": "\u4ea4\u4e86\u4e5d\u4e5d\u516b\u5341\u4e00\u904d\uff0c\u6700\u540e\u7ec8\u4e8e\u8fc7\u4e86\uff01\u8fd9\u9053\u9898\u552f\u4e00\u7684\u96be\u70b9\u5c31\u662f\u5f00\u7684\u6570\u636e\u89c4\u6a21\uff0c\u7136\u540e\u5c31\u662f\u4e00\u4e2a\u88f8\u7684~~spfa~~\u6700\u77ed\u8def\uff0c\u4e0b\u9762\u89c1\u6211\u8fd981\u6b21~~(\u5176\u5b9e\u6ca1\u8fd9\u4e48\u591a)~~\u4ea4\u7684\u4ee3\u7801\n------------\n\n\n------------\n```cpp\n1. \u5177\u4f53\u601d\u8def\u5c31\u662f\uff1a\u8ba9\u4e00\u53ea\u5976\u725b\u8dd1\u5230FJ\u90a3\u8fb9\uff0c\u7136\u540e\u518d\u8dd1\u56dep_i\u90a3\u91cc\u3002\n\u7ec6\u5fc3\u7684\u670b\u53cb\u90fd\u53d1\u73b0\u4e86\uff0c\u8fd9\u6837\u592a\u6162\uff01\uff01\uff01\u800c\u4e14\u5e38\u91cf\u5f00\u8fd9\u4e48\u5927\u8dd1\u4e24\u904d\u786e\u5b9e\u975e\u5e38\u52c9\u5f3a\n\u4e8e\u662f\u5c31\u7206\u96f6\u4e86\uff01\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<algorithm>\n\nusing namespace std ;\nconst int inf = 0x7fffffff;\nconst int maxn = 30000001 ;//\u8fd9\u91cc\u662f\u4e0d\u662f\u592a\u5927\u4e86\uff01\uff01\nint n,m,t,k,s,e;\nint dis[maxn] , vis[maxn] , head[maxn] ;\nstruct dy{\n    int x , y , z ,next;\n}a[maxn];\nvoid add(int x , int y , int z)//\u52a0\u8fb9\n{\n    a[t].x = x ;\n    a[t].y = y ;\n    a[t].z = z ;\n    a[t].next = head[x] ;\n    head[x] = t ++ ;\n}\nvoid spfa(int s)\n{\n    queue<int>q ;\n    for(int i = 1 ; i <= n ; i ++) dis[i] = inf ;\n    memset(vis , false , sizeof(vis)) ;\n    q.push(s) ;\n    dis[s] = 0 ;\n    while(!q.empty())\n    {\n        int u = q.front() ;\n        q.pop() ;\n        vis[u] = 0 ;\n        for(int i = head[u] ; i != -1 ; i = a[i].next )\n        {\n            int v = a[i].y ;\n            if(dis[v] > dis[u] + a[i].z)\n            {\n                dis[v] = dis[u] + a[i].z ;\n                if(!vis[v])\n                {\n                    vis[v] = true ;\n                    q.push(v) ;\n                }\n            }\n        }\n    }\n}\nint p ;\nint main()\n{\n    cin >> n >> m >> p ;\n    memset(head , -1 , sizeof(head)) ;\n    while(m --)//\u5efa\u56fe\n    {\n        int x , y , z ;\n        cin >> x >> y >> z ;\n        add(x , y , z ) ;\n        add(y , x , z) ;\n    }\n    while( p --)//\u4e24\u904dSPFA\n    {\n        cin >> s >> e ;\n        spfa(s) ;\n        int w = dis[1] ;//\u5148\u8dd1\u5230FJ\u90a3\u91cc\n        spfa(1) ;\n        cout << w + dis[e] <<\"\\n\";//\u518d\u8dd1\u56deP_I\n    }\n } \n```\n\n\n------------\n```cpp\n2.\u53d1\u73b0\u95ee\u9898\u5c31\u8981\u89e3\u51b3\u95ee\u9898\uff1a\u4e0a\u9762\u8bf4\u5230\u5e38\u6570\u592a\u5927\u7684\u95ee\u9898\uff0c\u4e8e\u662f\u4fbf\u6539\u5427\uff01\u7565\u5fae\u7684\u8d85\u8fc7\u4e00\u70b9\u6570\u636e\u8303\u56f4\uff0c\u4f46\u662f\u672c\u849f\u84bb\u6709\u5ffd\u89c6\u4e86\u4e00\u4e2a\u5e38\u8bc6\u6027\u95ee\u9898\uff1a\u8fd9\u662f\u4e00\u4e2a\u65e0\u5411\u56fe\uff01\u6570\u7ec4\u662f\u8981\u5f00\u4e24\u500d\u591a\u4e00\u70b9\u7684\uff01\n50\u5206\uff01\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<algorithm>\n\nusing namespace std ;\nconst int inf = 0x7ffffff;\nconst int maxn = 50010 ;//\u66f4\u6539\u5728\u6b64\u5904\uff01\nint n,m,t,k,s,e;\nint dis[maxn] , vis[maxn] , head[maxn] ;//\u6ce8\u610f\u8fd9\u91cc\uff01\u5e94\u4f18\u5316\u4e3amaxn*2+1\nstruct dy{\n    int x , y , z ,next;\n}a[maxn];\nvoid add(int x , int y , int z)//\u52a0\u8fb9\n{\n    a[t].x = x ;\n    a[t].y = y ;\n    a[t].z = z ;\n    a[t].next = head[x] ;\n    head[x] = t ++ ;\n}\nvoid spfa(int s)\n{\n    queue<int>q ;\n    for(int i = 1 ; i <= n ; i ++) dis[i] = inf ;\n    memset(vis , false , sizeof(vis)) ;\n    q.push(s) ;\n    dis[s] = 0 ;\n    while(!q.empty())\n    {\n        int u = q.front() ;\n        q.pop() ;\n        vis[u] = 0 ;\n        for(int i = head[u] ; i != -1 ; i = a[i].next )\n        {\n            int v = a[i].y ;\n            if(dis[v] > dis[u] + a[i].z)\n            {\n                dis[v] = dis[u] + a[i].z ;\n                if(!vis[v])\n                {\n                    vis[v] = true ;\n                    q.push(v) ;\n                }\n            }\n        }\n    }\n}\nint p ;\nint main()\n{\n    cin >> n >> m >> p ;\n    memset(head , -1 , sizeof(head)) ;\n    while(m --)\n    {\n        int x , y , z ;\n        cin >> x >> y >> z ;\n        add(x , y , z ) ;\n        add(y , x , z) ;\n    }\n    while( p --)//\u6253\u6b7b\u4e0d\u6539\u7684\u4e24\u904dspfa\n    {\n        cin >> s >> e ;\n        spfa(s) ;\n        int w = dis[1] ;\n        spfa(1) ;\n        cout << w + dis[e] <<\"\\n\";\n    }\n } \n```\n\n\n------------\n```cpp\n3.\u6539\u8fdb\uff1aconst \u5f00\u5927\u4e86\u4e00\u70b9\uff0c\u4e14maxn*2+1\u4e86\uff0c\u4f46\u662f\u8fd8\u662fRE\u4e86\u4e00\u4e2a\u70b9(\u800c\u4e14\u5438\u6c27\u8fd8\u6ca1\u7528\u5462\uff01)\u52a0\u4e0a\u6539\u8fdb\u4e86\u7b97\u6cd5\uff1a\u4ece\u5976\u725b\u5230FJ\u7684\u8ddd\u79bb\u5176\u5b9e\u5c31\u548c\u4eceFJ\u5230\u5976\u725b\u7684\u8ddd\u79bb\u76f8\u7b49\n\u6240\u4ee5\u53ea\u8981\u6c42FJ\u5230P_I\u548cQ_I\u7684\u8ddd\u79bb\u4e4b\u548c\u5c31\u597d\u4e86\uff01\uff01\n90\u5206\uff01\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<algorithm>\n\nusing namespace std ;\nconst int inf = 0x7ffffff;\nconst int maxn = 60010 ;\nint n,m,t,k,s,e;\nint dis[maxn*2+1] , vis[maxn*2+1] , head[maxn*2+1] ;\nstruct dy{\n    int x , y , z ,next;\n}a[maxn*2+1];\nvoid add(int x , int y , int z)\n{\n    a[t].x = x ;\n    a[t].y = y ;\n    a[t].z = z ;\n    a[t].next = head[x] ;\n    head[x] = t ++ ;\n}\nvoid spfa(int s)\n{\n    queue<int>q ;\n    for(int i = 1 ; i <= n ; i ++) dis[i] = inf ;\n    memset(vis , false , sizeof(vis)) ;\n    q.push(s) ;\n    dis[s] = 0 ;\n    while(!q.empty())\n    {\n        int u = q.front() ;\n        q.pop() ;\n        vis[u] = 0 ;\n        for(int i = head[u] ; i != -1 ; i = a[i].next )\n        {\n            int v = a[i].y ;\n            if(dis[v] > dis[u] + a[i].z)\n            {\n                dis[v] = dis[u] + a[i].z ;\n                if(!vis[v])\n                {\n                    vis[v] = true ;\n                    q.push(v) ;\n                }\n            }\n        }\n    }\n}\nint p ;\nint main()\n{\n    cin >> n >> m >> p ;\n    memset(head , -1 , sizeof(head)) ;\n    while(m --)\n    {\n        int x , y , z ;\n        cin >> x >> y >> z ;\n        add(x , y , z ) ;\n        add(y , x , z) ;\n    } \n    spfa(1) ;\n    while( p --)//\u6539\u4e3a\u4e00\u904dspfa\n    {\n        cin >> s >> e ;\n        cout <<dis[s] + dis[e] <<\"\\n\";\n    }\n } \n```\n\n\n------------\n```cpp\n4.AC\uff01\n\u8fd9\u4e48\u4e45\u4e86\u7ec8\u4e8e\u8fc7\u4e86\u5417\uff01long long \u5417\uff1f\u6211\u611f\u89c9\u548c\u8fd9\u4e2a\u6ca1\u4ec0\u4e48\u5927\u5173\u7cfb\uff1b\u6211\u4e2a\u4eba\u8ba4\u4e3a\u662f\u6211\u53c8\u628a\u5e38\u6570\u6269\u5927\u4e8610\u500d\u7684\u539f\u56e0\uff1b\n#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<algorithm>\n\nusing namespace std ;\n#define ll long long \nconst ll inf = 0x7ffffff;\nconst ll maxn = 1000010 ;//\u8fd9\u91cc\u6269\u5927\u4e8610\u500d\nll n,m,t,k,s,e;\nll dis[maxn] , vis[maxn] , head[maxn] ;\nstruct dy{\n    ll x , y , z ,next;\n}a[maxn];\nvoid add(ll x , ll y , ll z)\n{\n    a[t].x = x ;\n    a[t].y = y ;\n    a[t].z = z ;\n    a[t].next = head[x] ;\n    head[x] = t ++ ;\n}\nvoid spfa(ll s)\n{\n    queue<ll>q ;\n    for(ll i = 1 ; i <= n ; i ++) dis[i] = inf ;\n    memset(vis , false , sizeof(vis)) ;\n    q.push(s) ;\n    dis[s] = 0 ;\n    while(!q.empty())\n    {\n        ll u = q.front() ;\n        q.pop() ;\n        vis[u] = 0 ;\n        for(ll i = head[u] ; i != -1 ; i = a[i].next )\n        {\n            ll v = a[i].y ;\n            if(dis[v] > dis[u] + a[i].z)\n            {\n                dis[v] = dis[u] + a[i].z ;\n                if(!vis[v])\n                {\n                    vis[v] = true ;\n                    q.push(v) ;\n                }\n            }\n        }\n    }\n}\nint p ;\nint main()\n{\n    cin >> n >> m >> p ;\n    memset(head , -1 , sizeof(head)) ;\n    while(m --)\n    {\n        ll x , y , z ;\n        cin >> x >> y >> z ;\n        add(x , y , z ) ;\n        add(y , x , z) ;\n    } \n    spfa(1) ;\n    while( p --)//\u6539\u4e3a\u4e00\u904dspfa\n    {\n        cin >> s >> e ;\n        cout <<dis[s] + dis[e] <<\"\\n\";\n    }\n } \n```\n",
        "postTime": 1527985754,
        "uid": 54752,
        "name": "L_Y_T",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u8fd9\u662f\u4e00\u7bc7\u6bd4\u8f83\u7384\u5b66\u7684\u9898\u4e86\u2026\u2026\u5f00\u59cb\u770b\u89c1\u8fd9\u4e2a\u9898\uff0c\u6211\u7684\u60f3\u6cd5\uff1a\n\n### \u54ce\u5440\uff01\u4e0d\u5c31\u662f\u4e00\u9053\u6700\u77ed\u8def\u6a21\u677f\u6c34\u9898\u5417\uff01\n\n\u4e8e\u662f\u4e4e\u5174\u51b2\u51b2\u7684\u7528Dijskra\u5199\u4e86\u4e00\u4e0b\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <queue>\n#include <cstring>\nusing namespace std;\nconst int N = 1e5 + 1;\nint n, m, b, dis[N], cnt, hed[N], rdis[N], rhed[N];\nbool vis[N], rvis[N];\nstruct edge\n{\n    int to, next, dis;\n\n};\nedge a[N], ra[N];\nstruct node\n{\n    int dis, pos;\n    bool operator<(const node &a) const\n    {\n        return a.dis < dis;\n\n    }\n};\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        x = (x << 3) + (x << 1) + (ch ^ 48);\n        ch = getchar();\n    }\n    return x * f;\n}\nvoid bud(int u, int v, int d)\n{\n    a[++cnt].to = v;\n    a[cnt].next = hed[u];\n    a[cnt].dis = d;\n    hed[u] = cnt;\n}\nvoid stl()\n{\n    priority_queue<node> q;\n    memset(dis, 0x3f, sizeof(dis));\n\n    dis[1] = 0;\n    q.push((node){0, 1});\n    while (!q.empty())\n    {\n        node tmp = q.top();\n        q.pop();\n        int x = tmp.pos, d = tmp.dis;\n\n        if (vis[x])\n            continue;\n        vis[x] = 0;\n        for (int i = hed[x]; i; i = a[i].next)\n        {\n            int y = a[i].to;\n            if (dis[y] > dis[x] + a[i].dis)\n\n            {\n                dis[y] = dis[x] + a[i].dis;\n\n                if (!vis[y])\n                    q.push((node){vis[y], y});\n            }\n        }\n    }\n}\nint main()\n{\n    n = read();\n    m = read();\n    b = read();\n    for (int i = 1; i <= m; ++i)\n    {\n        int u, v, d;\n        u = read();\n        v = read();\n        d = read();\n        bud(u, v, d);\n        bud(v, u, d);\n    }\n    stl();\n    for (int i = 1; i <= b; ++i)\n    {\n        int ai, bi;\n\n        ai = read();\n        bi = read();\n        printf(\"%d\\n\", dis[ai] + dis[bi]);\n\n    }\n    return 0;\n}\n```\n\u7136\u540e\u4ea4\u4e0a\u53bb,90\u5206\u3002\u6700\u540e\u4e00\u4e2a\u70b9\u6210\u529f\u7684TLE\u3002\n\n\u4e8e\u662f\u4e4e\uff0c\u672c\u849f\u84bb\u5c31\u6e05\u9192\u7684\u610f\u8bc6\u5230\uff1a\u672c\u9898\u5f00\u59cb\u5361\u5e38\u4e86\u3002\n\n\u4e8e\u662f\u5c31\u5f00\u59cb\u778e\u80e1\u4e86\uff0c\u5148\u5199\u4e86\u4e2a\u5feb\u901f\u8f93\u51fa\uff0c\u4ea4\u4e0a\u53bb\uff0cTLE\u2026\u2026\n\n\u7136\u540e~~\u5438\u6c27\u6c14~~\uff0cTLE\u2026\u2026\n\n\u4e8e\u662f\u849f\u84bb\u60f3\u5230\uff1a\n\nDijkstra\u8fd9\u9053\u9898\u4e0d\u592a\u884c\u5f97\u901a\u3002\n\n\u7136\u540e\u5c31\u60f3\u8d77\u4e86\u4e00\u4e2a\u53eb\u505a\u914d\u5bf9\u5806\uff08Pairing Heap\uff09\u7684\u7384\u5b66\u6570\u636e\u7ed3\u6784\u2026\u2026\n\n\u4ee5\u4e0b\u662f\u4e24\u8005\u7b97\u6cd5\u7684\u8fd0\u884c\u65f6\u95f4\u6bd4\u8f83\uff08\u4ee5[P4779](https://www.luogu.org/problem/P4779)\u4e3a\u4f8b\uff09\uff1a\n\nDijkstra\uff1a\n\n![](http://a3.qpic.cn/psb?/V11FgVVT0cwLk0/SmsF4Ty3aOuQm6qxybXboH*ZraVHPF04S.QF8klHQ3s!/c/dL4AAAAAAAAA&ek=1&kp=1&pt=0&bo=DAOXAAAAAAADF6o!&tl=1&vuin=1750562553&tm=1571824800&sce=60-2-2&rf=0-0)\n\nPairing Heap\n\n![](http://a3.qpic.cn/psb?/V11FgVVT0cwLk0/hp0BqcMrncIILb9cNIn8xC.Kmkk7SVtRxPC*qyBYz1U!/c/dL4AAAAAAAAA&ek=1&kp=1&pt=0&bo=4QKxAAAAAAADF2A!&tl=1&vuin=1750562553&tm=1571824800&sce=60-2-2&rf=0-0)\n\n\u660e\u663e\u5feb\u4e86\u4e00\u4e9b\u662f\u4e0d\u662f\uff1f\uff08~~\u4e0d\u662f~~\uff09\n\n\u5982\u679c\u8fd8\u89c9\u5f97\u4e0d\u660e\u663e\u7684\u8bdd\uff0c\u9047\u5230[P2984](https://www.luogu.org/problem/P2984)\u8fd9\u79cd~~\u6bd2\u7624~~\u5c31\u4f18\u5316\u7684\u975e\u5e38\u660e\u663e\u4e86\uff0c\u57fa\u672c\u4e0a\u90fd\u662f120ms\u5185\u8fc7\u7684\u2026\u2026\n\n\u5e9f\u8bdd\u4e0d\u591a\u8bf4\u4e86\uff0c\u653e\u4ee3\u7801\uff01\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\n//#define nullptr 0\n\nclass UnderflowException\n{\n};\n\nclass IllegalArgumentException\n{\n};\n\ntemplate <typename T>\nclass PairingHeap\n{\nprivate:\n    struct PairNode\n    {\n        T element;\n        PairNode *leftChild, *nextSibling, *prev;\n\n        PairNode(const T &elm)\n        {\n            element = elm;\n            leftChild = nextSibling = prev = nullptr;\n        }\n    };\n\n    PairNode *root;\n\n    void reclaimMemory(PairNode *t)\n    {\n        if (t != nullptr)\n        {\n            reclaimMemory(t->leftChild);\n            reclaimMemory(t->nextSibling);\n            delete t;\n        }\n    }\n\n    void compareAndLink(PairNode *&first, PairNode *second)\n    {\n        if (second == nullptr)\n        {\n            return;\n        }\n        if (second->element < first->element)\n        {\n            second->prev = first->prev;\n            first->prev = second;\n            first->nextSibling = second->leftChild;\n            if (first->nextSibling != nullptr)\n            {\n                first->nextSibling->prev = first;\n            }\n            second->leftChild = first;\n            first = second;\n        }\n        else\n        {\n            second->prev = first;\n            first->nextSibling = second->nextSibling;\n            if (first->nextSibling != nullptr)\n            {\n                first->nextSibling->prev = first;\n            }\n            second->nextSibling = first->leftChild;\n            if (second->nextSibling != nullptr)\n            {\n                second->nextSibling->prev = second;\n            }\n            first->leftChild = second;\n        }\n    }\n\n    PairNode *combineSiblings(PairNode *firstSibling)\n    {\n        if (firstSibling->nextSibling == nullptr)\n        {\n            return firstSibling;\n        }\n        static std::vector<PairNode *> treeArray(5);\n        long long numSiblings = 0;\n        for (; firstSibling != nullptr; ++numSiblings)\n        {\n            if (numSiblings == treeArray.size())\n            {\n                treeArray.resize(numSiblings * 2);\n            }\n            treeArray[numSiblings] = firstSibling;\n            firstSibling->prev->nextSibling = nullptr;\n            firstSibling = firstSibling->nextSibling;\n        }\n        if (numSiblings == treeArray.size())\n        {\n            treeArray.resize(numSiblings + 1);\n        }\n        treeArray[numSiblings] = nullptr;\n        long long i = 0;\n        for (; i + 1 < numSiblings; i += 2)\n        {\n            compareAndLink(treeArray[i], treeArray[i + 1]);\n        }\n        long long j = i - 2;\n        if (j == numSiblings - 3)\n        {\n            compareAndLink(treeArray[j], treeArray[j + 2]);\n        }\n        for (; j >= 2; j -= 2)\n        {\n            compareAndLink(treeArray[j - 2], treeArray[j]);\n        }\n        return treeArray[0];\n    }\n\npublic:\n    PairingHeap() { root = nullptr; }\n\n    void makeEmpty()\n    {\n        reclaimMemory(root);\n        root = nullptr;\n    }\n\n    ~PairingHeap() { makeEmpty(); }\n\n    bool isEmpty() const { return root == nullptr; }\n\n    const T &findMin() const\n    {\n        if (isEmpty())\n        {\n            throw UnderflowException{};\n        }\n        return root->element;\n    }\n\n    typedef PairNode *Position;\n\n    Position insert(const T &x)\n    {\n        PairNode *newNode = new PairNode{x};\n        if (root == nullptr)\n        {\n            root = newNode;\n        }\n        else\n        {\n            compareAndLink(root, newNode);\n        }\n        return newNode;\n    }\n\n    void deleteMin()\n    {\n        if (isEmpty())\n        {\n            throw UnderflowException{};\n        }\n        PairNode *oldRoot = root;\n        if (root->leftChild == nullptr)\n        {\n            root = nullptr;\n        }\n        else\n        {\n            root = combineSiblings(root->leftChild);\n        }\n        delete oldRoot;\n    }\n\n    void deleteMin(T &minItem)\n    {\n        minItem = findMin();\n        deleteMin();\n    }\n    void decreaseKey(Position p, const T &newVal)\n    {\n        if (p->element < newVal)\n        {\n            throw IllegalArgumentException{};\n        }\n        p->element = newVal;\n        if (p != root)\n        {\n            if (p->nextSibling != nullptr)\n            {\n                p->nextSibling->prev = p->prev;\n            }\n            if (p->prev->leftChild == p)\n            {\n                p->prev->leftChild = p->nextSibling;\n            }\n            else\n            {\n                p->prev->nextSibling = p->nextSibling;\n            }\n            p->nextSibling = nullptr;\n            compareAndLink(root, p);\n        }\n    }\n};\n\ninline int read()\n{\n    int x = 0, f = 1;\n    char ch = getchar();\n    while (ch < '0' || ch > '9')\n    {\n        if (ch == '-')\n            f = -1;\n        ch = getchar();\n    }\n    while (ch >= '0' && ch <= '9')\n    {\n        x = (x << 3) + (x << 1) + (ch ^ 48);\n        ch = getchar();\n    }\n    return x * f;\n}\n\nusing namespace std;\n\nlong long n, m, s, d[100001], b;\n\nstruct Edge\n{\n    long long v, w;\n};\n\nstruct State\n{\n    long long dis, nid;\n\n    bool operator<(const State &b) const { return dis < b.dis; }\n};\n\nvector<Edge> g[100001];\n\nPairingHeap<State>::Position nps[100001];\n\nvoid dijkstra()\n{\n    PairingHeap<State> ph;\n    for (long long i = 1; i <= n; ++i)\n    {\n        d[i] = 2147483647;\n    }\n    d[s] = 0;\n    for (long long i = 1; i <= n; ++i)\n    {\n        nps[i] = ph.insert(State{d[i], i});\n    }\n    while (!ph.isEmpty())\n    {\n        State ts;\n        ph.deleteMin(ts);\n        long long u = ts.nid;\n        d[u] = ts.dis;\n        nps[u] = nullptr;\n        for (long long i = 0; i < g[u].size(); ++i)\n        {\n            long long v = g[u][i].v, w = g[u][i].w;\n            if (d[v] > d[u] + w && nps[v] != nullptr)\n            {\n                d[v] = d[u] + w;\n                ph.decreaseKey(nps[v], State{d[v], v});\n            }\n        }\n    }\n}\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    n = read();\n    m = read();\n    s = 1;\n    b = read();\n    while (m--)\n    {\n        long long u, v, w;\n        u = read();\n        v = read();\n        w = read();\n        g[u].push_back(Edge{v, w});\n        g[v].push_back(Edge{u, w});\n    }\n    dijkstra();\n    while (b--)\n    {\n        long long p = read(), q = read();\n        cout << d[p] + d[q] << endl;\n    }\n}\n```\n\n\u6839\u636e Data Structures and Algorithm Analysis in C++ (Fourth Edition) \u4e2d\u7684\u914d\u5bf9\u5806\u6574\u7406\u5f97\u51fa\uff0c\u5728\u6b64\u611f\u8c22\u3002\n\n\u7136\u540e\u5c31\u6109\u5feb\u7684AC\u5566~\n\n\u7b2c\u4e00\u6b21\u5199\u9898\u89e3\uff0c\u4ee3\u7801\u6ce8\u91ca\u8fd8\u6ca1\u6765\u5f97\u53ca\u641e\uff0c\u7b49\u7701\u8d5b\u5b8c\u4e86\u518d\u6765\u586b\u5751\uff0c~~\u9003~~",
        "postTime": 1571817680,
        "uid": 152341,
        "name": "\u5c0f\u7cef\u7c73",
        "ccfLevel": 0,
        "title": "P2984"
    },
    {
        "content": "\u8bbe$s$\u4e3a\u8d77\u70b9\uff0c\u8981\u4ece$s$\u70b9\u5148\u8d70\u5230$a$,\u518d\u8d70\u5230$b$\u3002\n\n\u663e\u7136\u53ef\u4ee5\u770b\u51fa\uff0c\u6700\u77ed\u8def\u662f\u4ece$s$\u5230$a$\u8dd1\u4e00\u904d,\u518d\u4ece$a$\u8dd1\u5230$b$\u3002\u5f00\u59cb\u6211\u9677\u5165\u4e86\u4e00\u4e2a\u83ab\u540d\u5176\u5999\u7684\u95ee\u9898\uff0c\u4e0d\u77e5\u8def\u7ebf\u600e\u4e48\u89c4\u5212\u3002\u4f46\u540e\u6765\u53d1\u73b0\u7531\u4e8e\u662f\u53cc\u5411\u8fb9\uff0c\u65e0\u8bba\u600e\u4e48\u89c4\u5212\u8def\u7ebf\uff0c\u4ece$s$\u5230$a$\u518d\u5230$b$\u7684\u6700\u77ed\u8def\u90fd\u7b49\u4ef7\u4e8e$dis[s][a]+dis[s][b]$,\u56e0\u4e3a\u4ece$s$\u5230$a$\u7684\u6700\u77ed\u8def\u7b49\u4e8e\u4ece$a$\u5230$s$\u3002\u6545\u4e0d\u7528\u6a21\u62df\u9898\u610f\u771f\u7684\u90a3\u4e48\u53bb\u8dd1\u6700\u77ed\u8def\uff0c\u4e00\u904d$SPFA$\u5c31\u591f\u4e86\u3002\n\n\u53ea\u8981\u601d\u8def\u6b63\u786e\uff0c\u4e0d\u8dd1\u51a4\u6789\u8def\uff0c\u65f6\u95f4\u8fd8\u662f\u5145\u88d5\u7684\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nlong long n,m,s,num,head[20000000],to[20000000],len[20000000],next[20000000],book[20000000],dis[20000000],b[20000000];\nvoid add(long long u,long long v,long long w)\n{\n    to[++num]=v;\n    len[num]=w;\n    next[num]=head[u];\n    head[u]=num;\n}\n\nvoid spfa(long long s)\n{\n    long long h=1,t=1;\n    for(long long i=1;i<=n;i++)\n        dis[i]=2147483647;\n    dis[s]=0;\n    book[s]=1;\n    b[t++]=s;\n    while(h<t)\n    {\n        long long x=b[h++];\n        book[x]=0;\n        for(long long i=head[x];i;i=next[i])\n            if(dis[to[i]]>dis[x]+len[i])\n            {\n                dis[to[i]]=dis[x]+len[i];\n                if(!book[to[i]])\n                {\n                    b[t++]=to[i];\n                    book[to[i]]=1;\n                }\n            }\n    }\n}\n\nint main()\n{\n    cin>>n>>m>>s;\n    for(long long i=1;i<=m;i++)\n    {\n        long long u,v,w;\n        cin>>u>>v>>w;\n        add(u,v,w);\n        add(v,u,w);//\u5efa\u56fe\n    }\n    \n    spfa(1);//\u4ecefj\u5bb6\u51fa\u53d1\u8dd1\u4e00\u904d\n\tfor(int i=1;i<=s;i++)\n\t{\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tcout<<dis[u]+dis[v]<<endl;//\u8f93\u51fa\u7b54\u6848\n\t}\n\t\n    return 0;\n}\n\n```",
        "postTime": 1569586455,
        "uid": 143841,
        "name": "Star1_3st",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "## \u9898\u89e3 P2984 \u3010[USACO10FEB\u3011Chocolate Giving\n \n\u8fd9\u5176\u5b9e\u662f\u53bb\u5e74\u5199\u7684\u9898\u89e3\n\n\u4e0d\u5c31\u662f\u4e2a\u88f8\u7684Dijkstra\u5417\uff1f\n\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#include<map>\n#define sf scanf\n#define pf printf\nusing namespace std;\ntypedef pair<int,int>T;\nint n,m,b;\nint st,ed,len;\nint lover1,lover2;\nint lsr,first[1000010];\nint dist[50001],vis[50001];\nstruct node{\n\tint u,v,w,nxt;\n}e[1000010];\nvoid add(int u,int v,int w){\n    e[++lsr].u=u;e[lsr].v=v;e[lsr].w=w;\n    e[lsr].nxt=first[u];first[u]=lsr;\n}\n\nvoid dijkstra(int s){\n    memset(vis,0,sizeof(vis));\n    memset(dist,0x3f,sizeof(dist));\n    dist[s]=0;\n    priority_queue<T,vector<T>,greater<T>  >q;\n    q.push(make_pair(dist[s],s));\n    while(!q.empty()){\n\t\tpair<int,int>t=q.top();\n        q.pop();\n        int d=t.first,u=t.second;\n        if(vis[u])continue;\n        vis[u]=1;\n        for(int i=first[u];i;i=e[i].nxt){\n\t\t\tint v=e[i].v;\n            if(d+e[i].w<dist[v]){\n                dist[v]=d+e[i].w;\n                q.push(make_pair(dist[v],v));\n            }\n        }\n    }\n}\nint main(){\n    cin>>n>>m>>b;\n    for(int i=1;i<=m;i++){\n        cin>>st>>ed>>len;\n        add(st,ed,len);add(ed,st,len);\n\t}\n    dijkstra(1);\n    for(int i=1;i<=b;i++){\n        int ans=0;\n        cin>>lover1>>lover2;\n        ans+=dist[lover1]; \n        ans+=dist[lover2];\n        cout<<ans<<endl;\n      }\n}",
        "postTime": 1538836319,
        "uid": 117629,
        "name": "VulcanStig",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "# \u9898\u89e3[P2984](https://www.luogu.com.cn/problem/P2984)\n\n### \u9898\u610f\n\u8f93\u5165\u519c\u573a\u4e2a\u6570n\uff0cm\u6761\u8def\u5f84\u548cb\u6b21\u8be2\u95eeP_i\u548cQ_i\uff0c\u8f93\u51fa\u4eceP_i\u53f7\u519c\u573a\u52301\u53f7\u519c\u573a\u5230Q_i\u53f7\u519c\u573a\u7684\u6700\u77ed\u8def\u5f84\n\n### \u65b9\u6cd5\n\u76f4\u63a5\u6309\u7167\u9898\u610f\uff0c\u5148\u627e\u4eceP_i\u52301\u7684\u6700\u77ed\u8def\uff0c\u518d\u627e1\u5230Q_i\u7684\u6700\u77ed\u8def\uff0c\u8dd1\u4e24\u904dDijkstra\uff0c\u4e24\u904d\u5f97\u51fa\u7684\u7ed3\u679c\u76f8\u52a0\u5f97\u51fa\u7b54\u6848\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u8fd9\u4e48\u505a\u4f1aTLE\u3002\u90a3\u6211\u4eec\u5e94\u8be5\u600e\u4e48\u505a\u5462\uff1f\n\n\u6839\u636e\u9898\u610f\uff0c\u53ef\u4ee5\u53d1\u73b0\u4e24\u6b21\u7684\u8def\u5f84\u90fd\u8981\u7ecf\u8fc71\u53f7\u519c\u573a\uff0c\u800c\u4e14**\u6bcf\u6761\u8fb9\u90fd\u662f\u53cc\u5411\u8fb9**\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c**\u6bcf\u4e2a\u70b9\u52301\u53f7\u519c\u573a\u7684\u6700\u77ed\u8def\u5f84\u7b49\u4e8e1\u53f7\u519c\u573a\u5230\u6bcf\u4e2a\u70b9\u7684\u6700\u77ed\u8def\u5f84**\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u628a\u8d77\u70b9\u8bbe\u7f6e\u4e3a1\u53f7\u519c\u573a\uff0c\u8dd11\u904dDijkstra\uff0c\u8f93\u51fa\u65f6\u76f4\u63a5\u8f93\u51fadist[P_i]+dist[Q_i]\u5373\u53ef\n\n### Code\uff1a\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nconst int Max = 1000010, INF = 1e9;\nint n, m, b, cnt = 0, first[Max], dist[Max];\nbool vis[Max] = { false };\n\nstruct Node\n{\n\tint u, step;\n\tNode(int a, int sp)\n\t{\n\t\tu = a; step = sp;\n\t}\n\tbool operator<(const Node& a)const\n\t{\n\t\treturn step > a.step;\n\t}\n};\n\nstruct edge\n{\n\tint to, dis, next;\n}e[Max];//\u5b58\u8def\u5f84\n\nvoid add_edge(int u, int v, int w)//\u63d2\u5165\u65b0\u8def\u5f84\n{\n\te[++cnt].to = v;\n\te[cnt].dis = w;\n\te[cnt].next = first[u];\n\tfirst[u] = cnt;\n}\n\nvoid add(int u, int v, int w)//\u53cc\u5411\u8fb9\u4e24\u4e2a\u65b9\u5411\u90fd\u63d2\u4e00\u6b21\n{\n\tadd_edge(u, v, w);\n\tadd_edge(v, u, w);\n}\n\nvoid Dijkstra(int st)\n{\n\tpriority_queue<Node>Q;//\u5806\u4f18\u5316\n\tQ.push(Node(st, 0));//\u8d77\u70b9\u8ddd\u79bb\u4e3a0\n\tdist[st] = 0;//\u8d77\u70b9\u8ddd\u79bb\u4e3a0\n\twhile (!Q.empty())\n\t{\n\t\tNode it = Q.top(); Q.pop();\n\t\tint u = it.u;\n\t\tif (vis[u]) continue;//\u5df2\u7ecf\u627e\u5230\u6700\u77ed\u8ddd\u79bb\n\t\tvis[u] = true;\n\t\tfor (int i = first[u]; i; i = e[i].next)\n\t\t{\n\t\t\tint to = e[i].to, d = e[i].dis;\n\t\t\tif (d + dist[u] < dist[to] && !vis[to])//\u677e\u5f1b\u64cd\u4f5c\n\t\t\t{\n\t\t\t\tdist[to] = d + dist[u];\n\t\t\t\tQ.push(Node(to, dist[to]));//\u4e0b\u4e00\u4e2a\u70b9\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint u, v, w, p, q;\n\tscanf(\"%d%d%d\", &n, &m, &b);\n\tfor (int i = 1; i <= n; i++) dist[i] = INF;\n\tfor (int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &u, &v, &w);\n\t\tadd(u, v, w);//\u63d2\u65b0\u8def\u5f84\n\t}\n\tDijkstra(1);\n\twhile (b--)\n\t{\n\t\tscanf(\"%d%d\", &p, &q);\n\t\tprintf(\"%d\\n\", dist[p] + dist[q]);//\u76f4\u63a5\u8f93\u51fa\u4e24\u6761\u6700\u77ed\u8def\u5f84\u4e4b\u548c\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1584276141,
        "uid": 201425,
        "name": "lzxhdxx",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]Chocolate Giving S\u3011"
    },
    {
        "content": "**\u770b\u5230\u8fd9\u9898\u9996\u5148\u7b2c\u4e00\u4e2a\u60f3\u6cd5\u5c31\u662f\u8dd1\u4e24\u904d\uff0c\u4ecePi\u8dd1\u4e00\u6b21Qi\u8dd1\u4e00\u6b21\uff0c\u4f46\u65f6\u95f4\u590d\u6742\u5ea6\n~~GG~~**\n\n\u6211\u4eec\u53ef\u4ee5\u6362\u4e00\u79cd\u601d\u7ef4\u65b9\u5f0f\uff0c\u56e0\u4e3a\u65e0\u5411\uff0c\u5976\u725b\u4ece**Pi\u8dd1\u52301\u70b9\u7b49\u540c\u4e8e\u4ece1\u70b9\u8dd1\u5230Q\u70b9**\uff0c\n\n\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u4ece**1\u70b9\u5f00\u59cbSPFA\u904d\u5386****\u4e00\u904d(\u662f\u7684\uff0c\u4f60\u6ca1\u770b\u9519\uff0c\u4e00\u904d\u5c31\u884c)**\u3002\u7136\u540e\u5bf9\u5e94\u7684Pi\u5728\u56fe\u4e2d\u7684\u6570\u636e+Qi\u5373\u53ef\u3002\n\u65f6\u95f4\u6bd4\u8f83\u8d76\uff0c\u4ee3\u7801\u4e24\u4e09\u5929\u540e\u8865\u3002\n\n\u8fd9\u9898\u53ea\u8981\u8111\u5b50\u8f6c\u5f97\u8fc7\u5f2f\u6765\u5176\u5b9e\u5f88\u6c34\u3002\n\n```cpp\n#include<stdio.h>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nstruct node\n{\n    int to;\n    int walk;\n};//\u5b58\u56fe\nbool vis[100005]={};//\u662f\u5426\u8bbf\u95ee\nlong long int out[100005];//\u56fe\u4e2d\u6700\u77ed\u8def\u6570\u636e\nvector<node> line[100005];\nint cow1,cow2;\nqueue<int> que;\ninline int read(){\n    int res=0;char c=getchar();\n    while(c>'9'||c<'0'){c=getchar();};\n    while(c>='0'&&c<='9'){res=(res<<1)+(res<<3)+c-'0';c=getchar();};\n    return res;\n}//\u5feb\u8bfb\nint main(void){\n    memset(out,0x3f,sizeof(out));\n    int n=read(),m=read(),b=read(),u,v,w;\n    for (int i = 0; i < m; i++)\n    {\n        u=read();v=read();w=read();\n        line[u].push_back((node){v,w});\n        line[v].push_back((node){u,w});\n    }//\u5efa\u56fe\n    vis[1]=1;\n    out[1]=0;\n    que.push(1);//\u6253\u6807\u8bb0\n    while (!que.empty())\n    {\n        int now=que.front();\n        que.pop();\n        vis[now]=0;\n        for (int i = 0; i < line[now].size(); i++)\n        {\n            if (out[now]+line[now][i].walk<out[line[now][i].to])\n            {\n                out[line[now][i].to]=out[now]+line[now][i].walk;\n                if (!vis[line[now][i].to])\n                {\n                    vis[line[now][i].to]=1;//\u8bb0\u4f4f\u8fd9\u4e2a\u6807\u8bb0\u4e0d\u80fd\u5fd8\uff0c\u5426\u521980\uff0c90\u5206\u3002\n                    que.push(line[now][i].to);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < b; i++)\n    {\n        cow1=read();cow2=read();//\u8f93\u51fa\n        printf(\"%lli\\n\",out[cow1]+out[cow2]);//\u7b2c\u4e00\u4e2a\u6570\u4e3aPi\u52301\u53f7\u70b9\u6700\u77ed\u8def\uff0c\u7b2c\u4e8c\u4e2a\u6570\u4e3a1\u53f7\u70b9\u5230Qi\u70b9\u7684\u6700\u77ed\u8def\u3002\n    }\n    return 0;\n}\n```\n",
        "postTime": 1573360075,
        "uid": 225285,
        "name": "Most_Goodlooking",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u7531\u4e8e\u9898\u76ee\u4e2d\u8bf4\u70b9\u6570N\u8fbe\u523025000\uff0c\u6240\u4ee5\u7528\u90bb\u63a5\u77e9\u9635\u80af\u5b9a\u5b58\u4e0d\u4e0b\uff0c\u8981\u7528\u90bb\u63a5\u8868(\u94fe\u5f0f\u524d\u5411\u661f)\u3002\n\u9898\u76ee\u7684\u76ee\u7684\u662f\u6c42A\u52301\u518d\u5230B\u7684\u6700\u77ed\u8def\u3002\u56e0\u4e3a\u662f\u65e0\u5411\u56fe\uff0c\u6240\u4ee5\u53ea\u8981\u8d70\u4e00\u904dSPFA\u5c31\u77e5\u90531\u5230i(1<=i<=n)\u7684\u6700\u77ed\u8def\u4e86\u3002\u5982\u679c\u662f\u6709\u5411\u56fe\uff0c\u5219\u8981\u5efa\u53cd\u5411\u56fe\uff0c\u8dd1\u4e24\u6b21SPFA\uff0c\u663e\u7136\u8fd9\u91cc\u4e0d\u9700\u8981\u3002\n\u63a5\u4e0b\u6765\u4ecb\u7ecdSPFA\u4e0e\u90bb\u63a5\u8868\u3002\n\n\n------------\n**SPFA\uff1a**\n\n\u5373\u7528\u961f\u5217\u4f18\u5316\u5bf9Bellman Ford\u7b97\u6cd5\u7684\u4f18\u5316\u3002\u65f6\u95f4\u590d\u6742\u5ea6O(VE)\u3002\n\u8bbe\u7acb\u4e00\u4e2a\u5148\u8fdb\u5148\u51fa\u7684\u961f\u5217\u7528\u6765\u4fdd\u5b58\u5f85\u4f18\u5316\u7684\u7ed3\u70b9\uff0c\u4f18\u5316\u65f6\u6bcf\u6b21\u53d6\u51fa\u961f\u9996\u7ed3\u70b9u\uff0c\u5e76\u4e14\u7528u\u70b9\u5f53\u524d\u7684\u6700\u77ed\u8def\u5f84\u4f30\u8ba1\u503c\u5bf9\u79bb\u5f00u\u70b9\u6240\u6307\u5411\u7684\u7ed3\u70b9v\u8fdb\u884c\u677e\u5f1b\u64cd\u4f5c\uff0c\u5982\u679cv\u70b9\u7684\u6700\u77ed\u8def\u5f84\u4f30\u8ba1\u503c\u6709\u6240\u8c03\u6574\uff0c\u4e14v\u70b9\u4e0d\u5728\u5f53\u524d\u7684\u961f\u5217\u4e2d\uff0c\u5c31\u5c06v\u70b9\u653e\u5165\u961f\u5c3e\u3002\u8fd9\u6837\u4e0d\u65ad\u4ece\u961f\u5217\u4e2d\u53d6\u51fa\u7ed3\u70b9\u6765\u8fdb\u884c\u677e\u5f1b\u64cd\u4f5c\uff0c\u76f4\u81f3\u961f\u5217\u7a7a\u4e3a\u6b62\u3002\n\u5b9a\u7406\uff1a\u53ea\u8981\u6700\u77ed\u8def\u5f84\u5b58\u5728\uff0c\u4e0a\u8ff0SPFA\u7b97\u6cd5\u5fc5\u5b9a\u80fd\u6c42\u51fa\u6700\u5c0f\u503c\u3002\u8bc1\u660e\uff1a\u6bcf\u6b21\u5c06\u70b9\u653e\u5165\u961f\u5c3e\uff0c\u90fd\u662f\u7ecf\u8fc7\u677e\u5f1b\u64cd\u4f5c\u8fbe\u5230\u7684\u3002\u6362\u8a00\u4e4b\uff0c\u6bcf\u6b21\u7684\u4f18\u5316\u5c06\u4f1a\u6709\u67d0\u4e2a\u70b9v\u7684\u6700\u77ed\u8def\u5f84\u4f30\u8ba1\u503cdis[v]\u53d8\u5c0f\u3002\u6240\u4ee5\u7b97\u6cd5\u7684\u6267\u884c\u4f1a\u4f7fdis\u8d8a\u6765\u8d8a\u5c0f\u3002\u7531\u4e8e\u6211\u4eec\u5047\u5b9a\u56fe\u4e2d\u4e0d\u5b58\u5728\u8d1f\u6743\u56de\u8def\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7ed3\u70b9\u90fd\u6709\u6700\u77ed\u8def\u5f84\u503c\u3002\u56e0\u6b64\uff0c\u7b97\u6cd5\u4e0d\u4f1a\u65e0\u9650\u6267\u884c\u4e0b\u53bb\uff0c\u968f\u7740dis\u503c\u7684\u9010\u6e10\u53d8\u5c0f\uff0c\u76f4\u5230\u5230\u8fbe\u6700\u77ed\u8def\u5f84\u503c\u65f6\uff0c\u7b97\u6cd5\u7ed3\u675f\uff0c\u8fd9\u65f6\u7684\u6700\u77ed\u8def\u5f84\u4f30\u8ba1\u503c\u5c31\u662f\u5bf9\u5e94\u7ed3\u70b9\u7684\u6700\u77ed\u8def\u5f84\u503c\u3002\n\n\n------------\n**\u90bb\u63a5\u8868\uff1a**\n\n\u90bb\u63a5\u8868\uff0c\u5b58\u50a8\u65b9\u6cd5\u8ddf\u6811\u7684\u5b69\u5b50\u94fe\u8868\u793a\u6cd5\u76f8\u7c7b\u4f3c\uff0c\u662f\u4e00\u79cd\u987a\u5e8f\u5206\u914d\u548c\u94fe\u5f0f\u5206\u914d\u76f8\u7ed3\u5408\u7684\u5b58\u50a8\u7ed3\u6784\u3002\u5982\u8fd9\u4e2a\u8868\u5934\u7ed3\u70b9\u6240\u5bf9\u5e94\u7684\u9876\u70b9\u5b58\u5728\u76f8\u90bb\u9876\u70b9\uff0c\u5219\u628a\u76f8\u90bb\u9876\u70b9\u4f9d\u6b21\u5b58\u653e\u4e8e\u8868\u5934\u7ed3\u70b9\u6240\u6307\u5411\u7684\u5355\u5411\u94fe\u8868\u4e2d\u3002\n\u90bb\u63a5\u8868\u662f\u56fe\u7684\u4e00\u79cd\u6700\u4e3b\u8981\u5b58\u50a8\u7ed3\u6784,\u7528\u6765\u63cf\u8ff0\u56fe\u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9\u3002\u5bf9\u56fe\u7684\u6bcf\u4e2a\u9876\u70b9\u5efa\u7acb\u4e00\u4e2a\u5bb9\u5668\uff08n\u4e2a\u9876\u70b9\u5efa\u7acbn\u4e2a\u5bb9\u5668\uff09\uff0c\u7b2ci\u4e2a\u5bb9\u5668\u4e2d\u7684\u7ed3\u70b9\u5305\u542b\u9876\u70b9Vi\u7684\u6240\u6709\u90bb\u63a5\u9876\u70b9\u3002\u5b9e\u9645\u4e0a\u6211\u4eec\u5e38\u7528\u7684\u90bb\u63a5\u77e9\u9635\u5c31\u662f\u4e00\u79cd\u672a\u79bb\u6563\u5316\u6bcf\u4e2a\u70b9\u7684\u8fb9\u96c6\u7684\u90bb\u63a5\u8868\u3002\n\u5728\u6709\u5411\u56fe\u4e2d\uff0c\u63cf\u8ff0\u6bcf\u4e2a\u70b9\u5411\u522b\u7684\u8282\u70b9\u8fde\u7684\u8fb9\uff08\u70b9a->\u70b9b\u8fd9\u79cd\u60c5\u51b5\uff09\u3002\n\u5728\u65e0\u5411\u56fe\u4e2d\uff0c\u63cf\u8ff0\u6bcf\u4e2a\u70b9\u6240\u6709\u7684\u8fb9(\u70b9a-\u70b9b\u8fd9\u79cd\u60c5\u51b5)\n\n\n------------\n**\u603b\u7b97\u8bf4\u5b8c\u4e86\uff0c\u63a5\u4e0b\u6765\u4e0acode\uff1a**\n\n\n------------\n```\n#include<bits/stdc++.h>\n#define N       1000001\t//\u6570\u636e\u8303\u56f4\n#define inf       1e8+1 //\u8bbe\u6700\u5927\u503c\n#define re register int \n#define read(x) scanf(\"%d\",&x) //\u7b80\u5199\u8bfb\u5165\nusing namespace std;\nstruct Edge{\n\tint to,next,w;\n}e[N];\t\t\t\t\t//\u90bb\u63a5\u8868\u7ed3\u6784\u4f53,next\u662f\u7b2ci\u8fb9\u7684\u4e0b\u6761\u8fb9\u7684\u7f16\u53f7i'\nint first[N],dis[N],vis[N];  //first\u5b58\u7b2ci\u4e2a\u70b9\u7684\u7b2c\u4e00\u6761\u8fb9\nint n,m,b,u,v,w,x,y,tot;\t//tot\u6307\u5b58\u5165\u4e86tot\u6761\u8fb9\nvoid add(int,int,int);\t\t//\u52a0\u8fb9\u51fd\u6570\nvoid Spfa();\t\t\t\t//SFPA\u51fd\u6570\nint main(){\n\tread(n);read(m);read(b);\n\tfor(re i=0;i<m;++i){\n\t\tread(u);read(v);read(w);\n\t\tadd(u,v,w);add(v,u,w);\n\t}\n\tSpfa();\n\tfor(re i=0;i<b;++i){\n\t\tread(x);read(y);\n\t\tprintf(\"%d\\n\",dis[x]+dis[y]);\n\t}\n\treturn 0;\n}\nvoid add(int u,int v,int w){\n\te[++tot].to=v;\n\te[tot].w=w;\n\te[tot].next=first[u];\n\tfirst[u]=tot;\n}\nvoid Spfa(){\n\tqueue<int> q;\n\tfor(re i=1;i<=n;++i) dis[i]=inf;\n\tdis[1]=0,q.push(1),vis[1]=1;\n\twhile(!q.empty()){\n\t\tint k=q.front();\n\t\tq.pop(),vis[k]=0;\n\t\tfor(re i=first[k];i;i=e[i].next)\n\t\t\tif(dis[e[i].to]>dis[k]+e[i].w){\n\t\t\t\tdis[e[i].to]=dis[k]+e[i].w;\n\t\t\t\tif(!vis[e[i].to]){\n\t\t\t\t\tq.push(e[i].to);\n\t\t\t\t\tvis[e[i].to]=1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n```\n",
        "postTime": 1571378510,
        "uid": 220571,
        "name": "Invisible_Blade",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 \u2014\u2014\u2014\u2014\u7528SPFA\u6c42\u6700\u77ed\u8def"
    },
    {
        "content": "\u672c\u849f\u84bb\u7ec3\u6700\u77ed\u8def\u65f6\u505a\u5230\u6b64\u9898\uff0c\u4e8e\u662f\u6765\u5199\u4e00\u4e0b\u9898\u89e3\uff08\u6781\u4e3a\u7275\u5f3a\uff09\n\n\u672c\u849f\u84bb\u7684\u601d\u8def\uff1a\n\n\u65e2\u7136\u8981\u5148\u4eceA\u70b9\u56de1\u70b9\u518d\u5230B\u70b9\n\n\u5c31\u76f8\u5f53\u4e8e\u6c421\u70b9\u5230A\u70b9\u548cB\u70b9\u6700\u77ed\u8def\n\n\u601d\u8def\u5c31\u6781\u5176\u7b80\u5355\u4e86\n\n\u6ce8\u610f\u5b58\u53cc\u5411\u8fb9\uff01\uff01\uff01\n\n\u672c\u849f\u84bb\u7528\u7684\u5806\u4f18\u5316\u7684Dijkstra\n\n~~SPFA\u88ab\u5361\u6015\u4e86~~\n\n\u8d34\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int to,w;\n};\nvector<node>g[200010];//\u672c\u849f\u84bb\u53ea\u4f1avector\u5b58\u56fe\nstruct point//\u8fd0\u7b97\u7b26\u91cd\u8f7d\n{\n    int d,dis;\n    bool operator<(const point b)const {\n        return dis>b.dis;\n    }\n};\nint n,m,b;\nint dis[200010];\nvoid pri_dij(int s)//\u5806\u4f18\u5316\u7684Dijkstra\u6a21\u677f\n{\n    priority_queue<point>q;\n    bool vis[200010]={0};\n    memset(dis,0x3f,sizeof(dis));\n    dis[s]=0;\n    q.push({s,0});\n    while(!q.empty())\n    {\n        point p=q.top();\n        q.pop();\n        int u=p.d;\n        if(vis[u])\n        {\n            continue;\n        }\n        vis[u]=1;\n        for(int j=0; j<g[u].size();j++)\n        {\n            int v=g[u][j].to,w=g[u][j].w;\n            if(!vis[v]&&dis[v]>dis[u]+w)\n            {\n                dis[v]=dis[u]+w;\n                q.push({v,dis[v]});\n            }\n        }\n    }\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&b);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tnode tmp;\n\t\ttmp.to=v;\n\t\ttmp.w=w;\n\t\tg[u].push_back(tmp);//\n\t\ttmp.to=u;\n\t\tg[v].push_back(tmp);//\u5b58\u53cc\u5411\u8fb9\uff01\uff01\uff01\n\t}\n\tpri_dij(1);//\u4ece1\u5f00\u59cb\uff08\u5206\u522b\u5230x\u5230y\uff09\n\tfor(int i=1;i<=b;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tprintf(\"%d\\n\",dis[x]+dis[y]);//\u4ecex\u52301\u518d\u5230y\u5c31\u7b49\u4e8e\u4ece1\u5206\u522b\u5230x\u548cy\n\t}\n\treturn 0;\n}\n```\n\n\u63d0\u4ea4\u8bb0\u5f55\uff1a\n[325ms 9.11KB](https://www.luogu.org/record/23482359)",
        "postTime": 1567949108,
        "uid": 116067,
        "name": "Create_Random",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]Chocolate Giving S\u3011"
    },
    {
        "content": "### \u672c\u849f\u84bb\u5c31\u662f\u559c\u6b22DIJKSTRA\u5806\u4f18\u5316\n\n\u7b2c\u4e00\u6b21\u63d0\u4ea4 TLE\n```cpp\nll u,v;read(u);read(v);\nDIJKSTRA(u);ll ans=dis[1];\nDIJKSTRA(1);\nprintf(\"%lld\\n\",ans+dis[v])\uff1b\n```\n\u8dd1\u4e86\u4e24\u6b21DIJ\n\n\u540e\u6765\u7ecf\u697c\u4e0bdalao\u63d0\u9192 \u56e0\u4e3a\u662f\u65e0\u5411\u56fe \n\n\u6240\u4ee5 dis[i][j]=dis[i][j]\n\u4ec5\u9700\u8981\u8ba1\u7b97 \u4ece\u4e00\u5230\u5176\u4ed6\u8282\u70b9\u7684\u6700\u77ed\u8def\u5f84\u5373\u53ef\n\n\u7b2c\u4e8c\u6b21\u63d0\u4ea4 \u518d\u6b21TLE\n\n```cpp\nll u,v;read(u);read(v);\nDIJKSTRA(1);\nprintf(\"%lld\\n\",dis[u]+dis[v]);\n```\n\n\u7741\u5927\u773c\u775b\u4e00\u770b \u53ea\u8981\u6c42\u4e00\u6b21\u5c31\u884c\u4e86 \u95ee\u4e00\u6b21\u6c42\u4e00\u6b21 \u95f9\u7740\u73a9\u5440\uff1f\n\n~~\u6211\u8fd8\u662f\u592a\u849f\u84bb\u4e86~~\n\n\u7b2c\u4e09\u6b21 AC\n\n# CODE\uff1a\n\n```cpp\n#pragma GCC optimize(3)\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n#include<queue>\n#include<map>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<vector>\n#include<ctime>\n#define ll long long\n#define inf 0x3f3f3f3f\n#define N 500008\n#define IL inline\n#define M 1008611\n#define D double\n#define ull unsigned long long\n#define R register\nusing namespace std;\ntemplate<typename T>void read(T &a)\n{\n    T x=0,f=1;char ch=getchar();\n    while(!isdigit(ch))\n    {\n        if(ch=='-')f=0;ch=getchar();\n    }\n    while(isdigit(ch))\n    {\n        x=(x<<1)+(x<<3)+ch-'0';ch=getchar();\n    }\n    a=f?x:-x;\n}\n/*-------------OI\u4f7f\u6211\u5feb\u4e50-------------*/\nstruct Node{\n    ll nex,to,wi;\n}e[N>>1];\nll n,m,b,tot;\nll dis[N>>1],vis[N>>1],head[N>>1];\nIL void add(ll ai,ll bi,ll ci){\n    e[++tot].to=bi;\n    e[tot].wi=ci;\n    e[tot].nex=head[ai];\n    head[ai]=tot;\n}\npriority_queue<pair<ll,ll>,vector<pair<ll,ll> >,greater<pair<ll,ll> > > Q;\nIL void DIJKSTRA(ll now){//DIJKSTRA\u5806\u4f18\u5316 \u6a21\u677f\n    while(!Q.empty()) Q.pop();\n    for(R ll i=1;i<=n;++i) dis[i]=inf,vis[i]=0;\n    Q.push(make_pair(0,now));dis[now]=0;\n    while(!Q.empty())\n    {\n        ll u=Q.top().second;Q.pop();\n        if(vis[u]) continue;\n        vis[u]=1;\n        for(R ll i=head[u];i;i=e[i].nex)\n        {\n            ll v=e[i].to;\n            if(dis[v]>dis[u]+e[i].wi)\n            {\n                dis[v]=dis[u]+e[i].wi;\n                Q.push(make_pair(dis[v],v));\n            }\n        }\n    }\n}\nsigned main()\n{\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n    read(n);read(m);read(b);\n    for(R ll i=1;i<=m;++i)\n    {\n    \tll xi,yi,zi;read(xi);read(yi);read(zi);\n    \tadd(xi,yi,zi);add(yi,xi,zi); \n    }\n    DIJKSTRA(1);\n    for(R ll i=1;i<=b;++i)\n    {\n        ll u,v;read(u);read(v);\n        \n        printf(\"%lld\\n\",dis[u]+dis[v]);\n    }\n//\tfclose(stdin);\n//\tfclose(stdout);\n    return 0;\n}\n\n```\n\nNOIP 2018 \u5373\u5c06\u5230\u6765\n\n\u795d\u613f\u5404\u4f4d RP++",
        "postTime": 1536020838,
        "uid": 87931,
        "name": "tcswuzb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "## \u6700\u597dSPFA\uff0c\u4f46\u6211\u4efb\u6027\uff0c\u7528Dijkstra\uff0c\u548b\u5730\uff1f\n\n\u8fd9\u9898\u4e00\u5f00\u59cb\u6211\u5f88\u7b28\u7684\u6a21\u62df\u9898\u76ee\uff0c\u8ba9\u5976\u725b\u5148\u53bbFJ\u90a3\u91cc\u518d\u53bb\u9001\u793c\u7269\u3002\uff0c\u7136\u540eTLE\u4e86\u3002\n\n\u7136\u540e\u6211\u5f00\u59cb\u6b7b\u547d\u5361\uff0c\u4ec0\u4e48\u5feb\u8bfb\uff0c\u8bb0\u5fc6\u5316\uff0c\u526a\u679d\u4f18\u5316\uff0c\u90fd\u7528\u4e0a\u4e86\uff0c\u8fd8\u662f\u8fc7\u4e0d\u53bb\uff0c\u6b63\u5728\u6211\u4e07\u5206\u65e0\u5948\u7684\u65f6\u5019\uff0c\u7a81\u7136\u60f3\u5230\u4e86\u4e00\u4e2a\u529e\u6cd5\uff1a~~\u5176\u5b9e\u662f\u522b\u4eba\u544a\u8bc9\u6211\u7684~~\n\n\u4ed4\u7ec6\u60f3\u60f3\uff0c\u5c31\u4f1a\u53d1\u73b0\uff1a**\u5176\u5b9e\u4ece\u67d0\u4e00\u4e2a\u725b\u68da\u5230FJ\u90a3\u91cc\u5176\u5b9e\u5c31\u662f\u4eceFJ\u90a3\u91cc\u5230\u725b\u68da\u90a3\u91cc\uff0c\u6240\u4ee5\u53ea\u7528\u4eceFJ\u51fa\u53d1\uff0c\u7528\u4e00\u4e2a$dis$\u6570\u7ec4\u628aFJ\u5230\u6240\u6709\u70b9\u7684\u6700\u77ed\u8def\u90fd\u8bb0\u4e0a\uff0c\u7136\u540e\u6bd4\u5982\uff0c\u725b\u68da$i$\u7684\u725b\u8981\u9001\u7ed9\u725b\u68da$j$\u7684\u725b\u793c\u7269\uff0c\u90a3\u4e48\u76f4\u63a5\u8f93\u51fa$dis[i]+dis[j]$\u5c31\u53ef\u4ee5\u4e86\uff0c\u4e0d\u7136\u5c31\u4f1a\u88ab\u5361\u7206\uff08like me\uff09\u3002**\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n \nusing namespace std;\n \nint m,n,b,r,s,l,p,j,start_,end_;\nlong long dis[50005];\nbool vis[50005];\n \nstruct data {\n    int u,s;\n    bool operator < (const data &e) const {//\u91cd\u8f7d\u8fd0\u7b97\u7b26\n        return s>e.s;\n    }\n} now;\n \npriority_queue<data>q;//\u4f18\u5148\u961f\u5217\nvector<int>a[50005],g[50005];//\u8bb0\u5f55\u8fb9\u548c\u8fd9\u6761\u8fb9\u7684\u8def\u7a0b\n \nvoid bfs() {\n    for(int i=1; i<=n; i++) {//\u521d\u59cb\u5316\n        dis[i]=0x7fffffff;\n    }\n    q.push((data) {1,0});\n    while(!q.empty()) {\n        now=q.top();\n        q.pop();\n        if(vis[now.u]) {//\u5df2\u7ecf\u8d70\u8fc7\u5c31continue\u3002\n            continue;\n        }\n        vis[now.u]=true;//\u6807\u8bb0\u5df2\u8d70\u8fc7\n        dis[now.u]=now.s;//\u66f4\u65b0dis\u6570\u7ec4\uff08\u56e0\u4e3a\u8fd9\u662f\u4f18\u5148\u961f\u5217\uff0c\u6240\u4ee5\u8fd9\u4e00\u5b9a\u662f\u6700\u77ed\u8def\uff09\n        for(int i=0; i<(int)a[now.u].size(); i++) {\n            int u=a[now.u][i];\n            int s=g[now.u][i];\n            if(!vis[u]&&now.s+s<dis[u]) {//\u5224\u65ad\u8d70\u6ca1\u8d70\u8fc7\u548c\u662f\u5426\u66f4\u4f18\n                q.push((data) {u,s+now.s});\n            }\n        }\n    }\n}\n \nvoid dfs(int u) {//dfs\u521d\u59cb\u5316\n    vis[u]=false;\n    for(int i=0; i<(int)a[u].size(); i++) {\n        if(vis[a[u][i]]) {\n            dfs(a[u][i]);\n        }\n    }\n}\n \nint main() {\n    scanf(\"%d%d%d\",&n,&m,&b);\n    for(int i=1; i<=m; i++) {\n        scanf(\"%d%d%d\",&r,&s,&l);\n        a[r].push_back(s);//\u5b58\u8fb9\n        a[s].push_back(r);\n        g[r].push_back(l);//\u5b58\u8def\u7a0b\n        g[s].push_back(l);\n    }\n    bfs();\n    dfs(1);\n    while(!q.empty()) {//\u521d\u59cb\u5316\u961f\u5217\uff08\u867d\u7136\u6ca1\u4ec0\u4e48\u5375\u7528\uff09\n        q.pop();\n    }\n    for(int i=1; i<=b; i++) {\n        scanf(\"%d%d\",&p,&j);\n        printf(\"%d\\n\",dis[p]+dis[j]);//\u8f93\u51fa\n    }\n    return 0;\n}\n```",
        "postTime": 1533812617,
        "uid": 118318,
        "name": "ez_lcw",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u53d1\u73b0\u697c\u4e0a\u5168\u662fspfa\u6ca1\u6709dijkstra\u8d76\u7d27\u5199\u4e00\u6ce2\u9898\u89e3233\n\n\u5176\u5b9e\u8fd9\u9898\u548c\u6700\u77ed\u8def\u7684\u6a21\u677f\u6ca1\u6709\u591a\u5c11\u5dee\u522b\uff1f\n\n\u8fd9\u91cc\u7528\u7684\u662f\u5806\u4f18\u5316\u7684dijkstra\u3002\n\n\n\u601d\u8def\uff1a\n\n\u8bfb\u5165\uff0c\u5f88\u660e\u663e\u90bb\u63a5\u77e9\u9635\u4f1a\u70b8\uff0c\u90a3\u4e48\u7528\u8fb9\u8868\u5b58\u6bcf\u4e00\u6761\u8fb9\u7684\u4fe1\u606f\u3002\n\n\u7136\u540e\u57fa\u672c\u548c\u6700\u77ed\u8def\u6a21\u677f\u4e00\u6837\u3002\n\n\u7531\u4e8e\u9898\u76ee\u8bf4\u5230a\u5fc5\u987b\u5148\u52301\u518d\u5230b\uff0c\u90a3\u4e48\u5176\u5b9e\u8fd9\u7b49\u4e8e\uff081\u5230A\u7684\u6700\u77ed\u8def+1\u5230B\u7684\u6700\u77ed\u8def\uff09\u3002\n\n\u6240\u4ee5\uff0c\u628a1\u5f53\u4f5c\u5f00\u59cb\u7684\u70b9\u6765dijkstra\uff0c\u5bf9\u6bcf\u4e00\u4e2a\u70b9\u627e\u6700\u77ed\u8def\uff0c\u5c061\u5230\u6bcf\u4e00\u4e2a\u70b9\u7684\u6700\u77ed\u8def\u5b58\u5230dis[]\u6570\u7ec4\u91cc\u3002\n\n\u7136\u540e\u6bcf\u6b21\u8f93\u5165a,b\u65f6\u76f4\u63a5\u8f93\u51fadis[a]+dis[b]\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=500005,MAXM=1000005;\nint n,m,b,i,f,t,d,head[MAXN],dis[MAXN],st,e,j,tot,vis[MAXN];\nstruct point\n{\n    int nm;\n    int dis;\n    bool operator <(const point & other) const\n    {\n        return this->dis<other.dis;\n     } \n};\nmultiset<point> s;\nstruct ed\n{\n    int v;\n    int w;\n    int next;\n} edge[MAXM];\nvoid add(int u,int v,int w)\n{\n    tot++;\n    edge[tot]=(ed){v,w,head[u]};\n    head[u]=tot;\n}\nvoid Dijkstra(int start)\n{\n    dis[start]=0;\n    s.insert((point){start,0});\n    while (!s.empty())\n    {\n        int now=s.begin()->nm;\n        s.erase(s.begin());\n        if (vis[now]) continue;\n        vis[now]=1;\n        for (j=head[now];j!=-1;j=edge[j].next)\n        {\n            int temp=edge[j].v;\n            if (dis[temp]>dis[now]+edge[j].w && !vis[temp])\n            {\n                dis[temp]=dis[now]+edge[j].w;\n                s.insert((point){temp,dis[temp]});\n            }\n        }\n     } \n}\nint main()\n{\n    memset(head,-1,sizeof(head));\n    memset(dis,999999,sizeof(dis));\n    cin>>n>>m>>b;\n    for (i=1;i<=m;i++)\n    {\n        cin>>f>>t>>d;\n        add(f,t,d);\n        add(t,f,d);\n    }\n    Dijkstra(1);\n    for (i=1;i<=b;i++)\n    {\n        cin>>st>>e;\n        cout<<dis[st]+dis[e]<<endl;\n    }\n}\n```",
        "postTime": 1498741103,
        "uid": 12613,
        "name": "PTC06",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u601d\u8def\u5f88\u660e\u663e,spfa\u6c42\u6700\u77ed\u8def,\u4f46\n\n##\u6ce8\u610f\n\n1.\u4e0d\u80fd\u7528\u90bb\u63a5\u77e9\u9635,\u4f1a\u70b8\u7a7a\u95f4,\u7528\u6307\u9488\u3002\n\n2.\u961f\u5217\u957f\u5ea6\u8981\u52a0\u957f\u3002\n\n3.\u8d34\u4ee3\u7801...\n\n```cpp\ntype pp=^node;\n      node=record\n      dot,v:longint;\n      next:pp;\n      end;\nconst maxn=50040;\nvar dis:array[0..maxn]of longint;\n    q:array[0..4*maxn]of longint;\n    a:array[0..maxn]of pp;\n    f:array[0..maxn]of boolean;\n    n,m,b,head,tail,u,v,x,y,i,j,l,w:longint;\n    p:pp;\nbegin\n    //assign(input,'cgiving.in');assign(output,'cgiving.out');\n    //reset(input);rewrite(output);\n    readln(n,m,b);\n    for i:=1 to n do\n    begin\n       new(a[i]);\n       a[i]^.next:=nil;\n    end;\n    for i:=1 to n do dis[i]:=maxlongint div 3;\n    for i:=1 to m do\n    begin\n        readln(x,y,l);\n        new(p);p^.next:=a[x]^.next;\n        p^.dot:=y;p^.v:=l;a[x]^.next:=p;\n        new(p);p^.next:=a[y]^.next;\n        p^.dot:=x;p^.v:=l;a[y]^.next:=p;\n    end;\n    fillchar(q,sizeof(q),0);fillchar(f,sizeof(f),false);\n    f[1]:=true;q[1]:=1;head:=0;dis[1]:=0;head:=0;tail:=1;\n    repeat\n       inc(head);u:=q[head];p:=a[u];\n       while p^.next<>nil do\n       begin\n           p:=p^.next;\n           v:=p^.dot;w:=p^.v;\n           if dis[v]>dis[u]+w then\n           begin\n               dis[v]:=dis[u]+w;\n               if not f[v] then\n               begin\n                   inc(tail);q[tail]:=v;\n                   f[v]:=true;\n               end;\n           end;\n       end;\n       f[u]:=false;\n    until head>=tail;\n    for i:=1 to b do\n    begin\n        readln(x,y);\n        writeln(dis[x]+dis[y]);\n    end;\n    //close(input);close(output);\nend.\n```",
        "postTime": 1490363463,
        "uid": 28038,
        "name": "Jian_Lee",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u7528SPFA\u6c42\u6700\u77ed\u8def\u3002\n\n\u770b\u4e86\u770b\u697c\u4e0a\u7684\u4ee3\u7801\uff0c\u53d1\u73b0\u662f\u7528\u524d\u5411\u661f\u505a\u7684\uff0c\u6211\u5c31\u76f4\u63a5\u4f7f\u7528\u90bb\u63a5\u77e9\u9635\u5b58\u4e86= =\n\n\u4e0a\u4ee3\u7801\u5427\uff1a\n\n```cpp\n// \u5148\u5c1d\u8bd5\u4f7f\u7528 spfa \u6765\u6c42\u6700\u77ed\u8def \n#include <cstdio>\n#include <queue>\n#include <vector>\n\nusing namespace std; \n\n// \u7531\u4e8e n \u8f83\u5927\uff0c\u90bb\u63a5\u77e9\u9635\u5bb9\u6613\u70b8\u5185\u5b58\uff0c\u91c7\u7528 spfa \u6c42\u6700\u77ed\u8def \n\nconst int size = 50005, inf = 1 << 26;\nint dis[size], inq[size];\nvector< pair<int, int> > vi[size];\nqueue<int> q;\nint n, m, b;\n\n#define pb push_back\n#define mp make_pair\n\nvoid init() {\n    for(int i = 0; i < size; i++) vi[i].clear();\n    for(int i = 0; i < size; i++) dis[i] = inf;\n    for(int i = 0; i < size; i++) inq[i] = 0;\n}\n\nvoid SPFA() { \n    q.push(1);\n    inq[1] = 1;\n    dis[1] = 0;\n    \n    while(!q.empty()) {\n        int now = q.front();\n        q.pop();\n        inq[now] = 0;\n        \n        for( int i = 0; i < vi[now].size(); i++) {\n            int v = vi[now][i].first;\n            \n            if(dis[v] > dis[now]+vi[now][i].second){\n                dis[v] = dis[now]+vi[now][i].second;\n                \n                if(inq[v] == 1) continue;\n                inq[v] = 1;\n                q.push(v); \n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &b);\n    init();\n    \n    for(int i = 0; i < m; i++) {\n        int x, y, z;\n        scanf(\"%d %d %d\", &x, &y, &z);\n        vi[x].pb( mp(y, z) );\n        vi[y].pb( mp(x, z) ); \n    }\n    \n    SPFA();\n    for(int i = 0; i < b; i++) {\n        int x1, x2;\n        scanf(\"%d %d\", &x1, &x2);\n        printf(\"%d\\n\", dis[x1]+dis[x2]);\n    }\n    \n    return 0;\n}\n```",
        "postTime": 1480767903,
        "uid": 17170,
        "name": "Deny_\u5c0f\u7530",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "0. \u88f8SPFA\n\n0. \u770b\u4ee3\u7801\n\n- \u987a\u4fbf\u8111\u8865\u4e00\u4e0bSPFA\n\n```cpp\n#include<iostream>\n#include<cstring>\nusing namespace std;\nstruct Edge\n{\n    int next;    //\u4e0b\u4e00\u6761\u8fb9\u7684\u7f16\u53f7 \n    int to;     //\u8fd9\u6761\u8fb9\u5230\u8fbe\u7684\u70b9 \n    int cost;   //\u8fd9\u6761\u8fb9\u7684\u957f\u5ea6 \n}edge[100001];    //\u6570\u7ec4\u6a21\u62df\u90bb\u63a5\u8868 \nint head[100001],cnt,n,m,u,v,d;\nint vis[100001],dis[100001];    //dis[]\u8bb0\u5f55\u4ece\u8d77\u70b9s\u5230i\u7684\u6700\u77ed\u8def\u5f84 \uff0cvis[]\u8bb0\u5f55\u4e00\u4e2a\u70b9\u662f\u5426\u73b0\u5728\u5b58\u5728\u961f\u5217\u4e2d \nint team[100001];   //\u961f\u5217 \nvoid add(int from,int go,int l)  //\u52a0\u5165\u4e00\u6761\u4ecefrom\u5230to\u8ddd\u79bb\u4e3adis\u7684\u5355\u5411\u8fb9 \n{\n    edge[++cnt].next=head[from];\n    edge[cnt].to=go;\n    edge[cnt].cost=l;\n    head[from]=cnt;\n}\nvoid spfa()\n{\n    memset(vis,0,sizeof(vis));\n    memset(dis,0x7f,sizeof(dis));\n    int h=0,t=1;\n    dis[1]=0;\n    vis[1]=1;\n    team[1]=1;//\u521d\u59cb\u53167\u6761 \n    while(h<t)\n    { \n        h++;         //\u5934\u6307\u9488\u5411\u4e0b\u79fb\u4e00\u4f4d\uff0c\u53d6\u51fa\u6307\u5411\u7684\u70b9U \n        u=team[h];    \n        vis[u]=0;  //\u5df2\u88ab\u53d6\u51fa\u4e86\u961f\u5217 \n        for(int i=head[u];i!=0;i=edge[i].next)  //\u7528\u6570\u7ec4\u6a21\u62df\u90bb\u63a5\u8868 \uff0cfor\u4e0eu\u76f8\u8fde\u7684\u6240\u6709\u70b9v \n        {\n            int to=edge[i].to;          \n            if(dis[to]>dis[u]+edge[i].cost)\n            {\n                dis[to]=dis[u]+edge[i].cost;\n                if(vis[to]==0)      //\u961f\u5217\u4e2d\u4e0d\u5b58\u5728v\u70b9\uff0cv\u5165\u961f \n                {\n                    t++; //\u6307\u9488\u4e0b\u79fb\u4e00\u4f4d\uff0cv\u5165\u961f \n                    team[t]=to;\n                    vis[to]=1;\n                }\n            }\n        }\n    }\n}\nint N,M,B;\nint main()\n{\n    cin>>N>>M>>B;     //\u8bfb\u5165\u70b9\u6570\u548c\u8fb9\u6570 \n    for(int i=1;i<=M;i++)    \n    {\n        int x,y,k;     //x\uff0cy\u4e4b\u95f4\u6709\u4e00\u6761\u957f\u5ea6\u4e3ad\u7684\u8fb9 \n        cin>>x>>y>>k;  \n        add(x,y,k);  \n        add(y,x,k);\n    }\n    spfa();\n    for(int i=1;i<=B;i++)\n    {\n        int x,y;\n        cin>>x>>y;\n        cout<<dis[x]+dis[y]<<endl;\n    }\n    return 0;\n}\n```",
        "postTime": 1479088290,
        "uid": 18441,
        "name": "Drug__Lover",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "# \u9898\u76ee\u63cf\u8ff0\n---\nFarmer John\u6709$B$\u5934\u5976\u725b$(1 \\leq B \\leq 25000)$\uff0c\u6709$N(2*B \\leq N \\leq 50000)$\u4e2a\u519c\u573a\uff0c\u7f16\u53f7$1 \\sim N$\uff0c\u6709$M(N-1 \\leq M \\leq 100000)$\u6761\u53cc\u5411\u8fb9,\u7b2c$i$\u6761\u8fb9\u8fde\u63a5\u519c\u573a$R_i$\u548c$S_i$ $(1 \\leq R_i \\leq N;1 \\leq S_i \\leq N)$\uff0c\u8be5\u8fb9\u7684\u957f\u5ea6\u662f$L_i$ $(1 \\leq L_i \\leq 2000)$\u3002  \n\u5c45\u4f4f\u5728\u519c\u573a$P_i$\u7684\u5976\u725b$A$ $(1 \\leq P_i \\leq N)$\uff0c\u5b83\u60f3\u9001\u4e00\u4efd\u65b0\u5e74\u793c\u7269\u7ed9\u5c45\u4f4f\u5728\u519c\u573a$Q_i$ $(1 \\leq Q_i \\leq N)$\u7684\u5976\u725b$B$\uff0c\u4f46\u662f\u5976\u725b$A$\u5fc5\u987b\u5148\u5230FJ(\u5c45\u4f4f\u5728\u7f16\u53f7$1$\u7684\u519c\u573a)\u90a3\u91cc\u53d6\u793c\u7269\uff0c\u7136\u540e\u518d\u9001\u7ed9\u5976\u725b$B$\u3002\u4f60\u7684\u4efb\u52a1\u662f\uff1a\u5976\u725b$A$\u81f3\u5c11\u9700\u8981\u8d70\u591a\u8fdc\u7684\u8def\u7a0b\uff1f\n\n# \u601d\u8def\n---\n1. $Floyd$(\u590d\u6742\u5ea6\u592a\u9ad8, \u820d)\n2. \u4e24\u904d$SPFA$\uff0c\u8ba9\u725b$A$\u53bb\u5230FJ\u662f\u4e00\u6b21\uff0c\u4eceFJ\u5230\u725b$B$\u518d\u8dd1\u4e00\u6b21\n\u4e8e\u662f\u5c31\u6709\u4e86\u4e0b\u9762\u8fd9\u4efd\u4ee3\u7801\n``` cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint N,M,B;\nvector<pair<int,int> > G[50001];//first\u662f\u957f\u5ea6\uff0csecond\u662f\u7ec8\u70b9\nqueue<int> q;\nbool inq[50001];\nint d[50001];\nvoid SPFA(int from){//SPFA\n\tmemset(d,0x3f,sizeof(d));\n\tq.push(from);\n\tinq[from]=true;\n\td[from]=0;\n\twhile(!q.empty()){\n\t\tint t=q.front();\n\t\tq.pop();\n\t\tinq[t]=false;\n\t\tfor(int i=0;i<G[t].size();i++){\n\t\t\tpair<int,int> t1=G[t][i]\n\t\t\tif(d[t]+t1.c<d[t1.second]){\n\t\t\t\td[t1.second]=d[t]+t1.first;\n\t\t\t\tif(!inq[t1.second]){\n\t\t\t\t\tq.push(t1.second);\n\t\t\t\t\tinq[t1.second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\tscanf(\"%d%d%d\",&N,&M,&B);\n    for(int i=1;i<=M;i++){\n    \tint u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        G[u].push_back(make_pair(w,v));\n        G[v].push_back(make_pair(w,u));//\u53cc\u5411\u8fb9\n    }\n    for(int i=1;i<=B;i++){\n    \tint ca,cb;\n        scanf(\"%d%d\",&ca,&cb);\n        SPFA(ca);//\u4ece\u519c\u573a\u5230FJ\n        int ans=d[1];\n        SPFA(1);//\u4eceFJ\u5230\u519c\u573a\n        ans+=d[cb];\n        printf(\"%d\\n\",ans);\n    }\n\treturn 0;\n}\n```\n\u63a5\u7740\u4f60\u4f1a\u53d1\u73b0   \n![congratulation_TLE.jpg](https://i.loli.net/2019/07/26/5d3a99ea2574128399.jpg)   \n\u4f60\u53ea\u670960\u5206   \n\n3. \u4f60\u4f1a\u53d1\u73b0\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u519c\u573a$A$,\u4ece\u519c\u573a$A$\u5230FJ\u7684\u8ddd\u79bb\u548c\u4eceFJ\u5230\u519c\u573a$A$\u7684\u8ddd\u79bb\u662f\u4e00\u6837\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u7528\u4e00\u6b21SPFA\u5c31\u53ef\u4ee5\u3002\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint B,N,M;\nvector<pair<int,int> > G[50001];\nint d[50001];\nbool inq[50001];\nqueue<int> q;\nvoid spfa(int start){\n    memset(d,0x3f,sizeof(d));\n    memset(inq,false,sizeof(inq));\n    q.push(start);\n    d[start]=0;\n    while(!q.empty()){\n        int t=q.front();\n        q.pop();\n        inq[t]=false;\n        for(int i=0;i<G[t].size();i++){\n            int t1=G[t][i].first,t2=G[t][i].second;\n            if(d[t1]>d[t]+t2){\n            \td[t1]=d[t]+t2;\n            \tif(!inq[t1]){\n            \t\tq.push(t1);\n            \t\tinq[t1]=true;\n            \t}\n            }\n        }\n    }\n}\nint main() {\n\tscanf(\"%d%d%d\",&N,&M,&B);\n\tfor(int i=1;i<=M;i++){\n\t\tint t1,t2,t3;\n\t\tscanf(\"%d%d%d\",&t1,&t2,&t3);\n\t\tG[t1].push_back(make_pair(t2,t3));\n\t\tG[t2].push_back(make_pair(t1,t3));\n\t}\n\tspfa(1);//\u4ee5FJ\u4e3a\u8d77\u70b9SPFA\n\tfor(int i=1;i<=B;i++){\n\t\tint t1,t2;\n\t\tscanf(\"%d%d\",&t1,&t2);\n\t\tprintf(\"%d\\n\",d[t1]+d[t2]);\n\t}\n    return 0;\n}\n```\n#### \u5f53\u7136\u628aSPFA\u6539\u6210Dijkstra\u7167\u6837\u80fd\u8fc7\n---\n",
        "postTime": 1564120919,
        "uid": 55812,
        "name": "_lcy_",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2984\u3010[USACO10FEB]Chocolate Giving S\u3011"
    },
    {
        "content": "\u770b\u5b8c\u4e86\u6709\u4e9b\u5927\u4f6c\u7684\u9898\u89e3\uff0c\u8bf4\u5b9e\u8bdd\uff0c\u6709\u70b9\u6162\uff0c\u8fd8\u662f\u770b\u6211\u7684SPFA\u5427\uff0c\u66b4\u529b\u53c8\u5feb\u901f\uff0c\u4f18\u5316\u4e86\u53cd\u800c\u66f4\u6162\n#\u601d\u8def\uff1a\u5373\u6211\u4eec\u5728\u8bfb\u5b8c\u9898\u540e\u53d1\u73b0\u51e0\u4e2a\u6027\u8d28\uff1a1\uff0c\u6b64\u56fe\u4e3a\u65e0\u5411\u56fe\u30022\uff0c\u5976\u725b\u4ecep\u70b9\u5148\u5230\u4e00\u53f7\u70b9\u53d6\u793c\u7269\uff0c\u7136\u540e\u518d\u5230q\u70b9\u53bb\u9001\u793c\u7269\uff0c\u4e5f\u5c31\u662f\u6c42p\u5230\u4e00\u53f7\u70b9\u7684\u6700\u77ed\u8def\uff0c\u518d\u6c42\u4e00\u53f7\u70b9\u5230q\u53f7\u70b9\u7684\u6700\u77ed\u8def\uff0c\u76f8\u52a0\u5373\u53ef\u30023\uff0c\u4ece1,2\uff0c\u4e24\u4e2a\u6027\u8d28\u770b\u6765\uff0cp\u5230\u4e00\u53f7\u70b9\u7684\u6700\u77ed\u8def\u5c31\u7b49\u4e8e\u4e00\u5230p\u7684\u6700\u77ed\u8def\uff0c\u5219\u6b64\u9898\u53d8\u4e3a\u6c421\u53f7\u70b9\u5230p\uff0cq\u4e24\u4e2a\u70b9\u7684\u6700\u77ed\u8def\u4e4b\u548c\u30024\uff0c\u4ee5\u6b64\u7c7b\u63a8\uff0c\u4e0d\u8bba\u6709\u51e0\u7ec4\u8be2\u95ee\uff0c\u53ea\u4ece\u4e00\u53f7\u70b9\u4e3a\u8d77\u70b9\u8dd1\u4e00\u904d\u6700\u77ed\u8def\u5373\u53ef\n#\u4ee3\u7801\u5982\u4e0b\n```\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\nconst int maxn=50100;\nconst int maxm=100100;\n\nstruct Edge\n{\n    int to;\n    int val;\n    int next;\n}edge[maxm*2];//\u90bb\u63a5\u8868\n\nqueue<int> q;//spfa\u6240\u7528\n  \nint N,M,B;\n\nint dis[maxn],head[maxn];\n\nbool flag[maxn];\n\nint edgenum;\n\nint r,s,l;\n\nint pp,qq;//\u8fd9\u5c31\u662f\u9898\u76ee\u4e2d\u7684p\uff0cq\n\nvoid add(int u,int v,int w)//\u524d\u5411\u661f\u5b58\u56fe\uff0c\u52a0\u8fb9\uff0c\u65e0\u5411\u56fe\u8bb0\u5f97\u52a0\u4e24\u6b21\n\n{\n\n    edge[++edgenum].val=w;\n    edge[edgenum].to=v;\n    edge[edgenum].next=head[u];\n    head[u]=edgenum;\n}\n\nvoid SPFA()//SPFA\u677f\u5b50\n\n{\n\n    memset(flag,0,sizeof(flag));\n    memset(dis,0x7f,sizeof(dis));\n    q.push(1);\n    flag[1]=1;\n    dis[1]=0;\n    while(!q.empty())\n    {\n        int st=q.front();\n        q.pop();\n        flag[st]=0;\n        for(int i=head[st];i;i=edge[i].next)\n        {\n            int en=edge[i].to;\n            if(dis[en]>dis[st]+edge[i].val)//\u8dd1\u6700\u77ed\u8def\uff0c\u4e0d\u65ad\u66f4\u65b0\n            {\n                dis[en]=dis[st]+edge[i].val;\n                if(!flag[en])//\u4e0d\u5728\u66f4\u65b0\u6570\u7ec4\u4e2d\u5c31\u52a0\u8fdb\u53bb\n                {\n                    flag[en]=1;\n                    q.push(en);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n\n    scanf(\"%d%d%d\",&N,&M,&B);\n    for(int i=1;i<=M;i++)\n    {\n        scanf(\"%d%d%d\",&r,&s,&l);\n        add(r,s,l);\n        add(s,r,l); \n    }\n    SPFA();\n    while(B--)//\u6b64\u5904\u4e3a\u91cd\u70b9\uff0c\u65e0\u5411\u56fe\uff0c\u4e00\u904d\u8ba1\u7b97\u52a0\u8fb9\u5373\u53ef\n    {\n        scanf(\"%d%d\",&pp,&qq);\n        printf(\"%d\\n\",dis[pp]+dis[qq]);//\u6838\u5fc3\u601d\u8def\uff0c\u5229\u7528\u65e0\u5411\u56fe\u7684\u6027\u8d28\uff0c\u8dd1\u4e00\u904d\u6700\u77ed\u8def\u7684\u6210\u679c\n    }\n    return 0;\n}\n```\n\u5982\u4e0a\uff0c\u8c22\u8c22",
        "postTime": 1527997013,
        "uid": 55949,
        "name": "\u8046\u96e8\u6ce3",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 P2984 \u3010Chocolate Giving\u3011"
    },
    {
        "content": "\u88f8\u7684spfa\u3002\u3002\u3002\n\n\u6c421\u5230\u4e24\u70b9\u7684\u8ddd\u79bb\u4e4b\u548c\n\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#define maxn 50001\n#define mm 1000010\n#define inf 99999999\nusing namespace std;\nint head[maxn],dis[maxn],vis[maxn];\nqueue<int> q;\nstruct edge{\n    int next,to,cost;\n}e[mm];\nint n,m,cnt=0,Q;\nvoid add(int u,int v,int z){\n    e[++cnt].next=head[u];\n    e[cnt].to=v;\n    e[cnt].cost=z;\n    head[u]=cnt;\n}\nvoid spfa(){\n    memset(vis,0,sizeof(vis));\n    for (int i=1;i<=n;i++)\n    dis[i]=inf;\n    q.push(1);\n    vis[1]=1;\n    dis[1]=0;\n    while (!q.empty()){\n        int tmp=q.front();\n        q.pop();\n        vis[tmp]=0;\n        for (int i=head[tmp];i;i=e[i].next){\n            int to=e[i].to;\n            if (dis[to]>dis[tmp]+e[i].cost){\n                dis[to]=dis[tmp]+e[i].cost;\n                if (!vis[to]){\n                    q.push(to);\n                    vis[to]=1;\n                }\n            }\n        }\n    }\n}\nint main(){\n    memset(head,0,sizeof(head));\n    scanf(\"%d%d%d\",&n,&m,&Q);\n    for (int i=1;i<=m;i++)\n    {\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        add(x,y,z);\n        add(y,x,z);\n    }\n    spfa();\n    for (int i=1;i<=Q;i++){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        printf(\"%d\\n\",dis[x]+dis[y]);\n    }\n    return 0;\n}\n```",
        "postTime": 1478437202,
        "uid": 8629,
        "name": "ws_fuweidong",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    },
    {
        "content": "\u7b2c\u4e00\u9762\u7684\u9898\u89e3\u5199\u4e86\u4efd\u6700\u77ed\u8def\u4e5f\u592a\u7d2f\u4e86\u5427  \n\u9996\u5148\u770b\u9898\u76ee\u662f\u53cc\u5411\u8fb9\uff0c\u5c31\u4e0d\u7528\u8003\u8651\u5efa\u53cd\u8fb9\u4e86  \n\u90a3\u4e48\u8ddd\u79bb\u5f88\u660e\u663e\u5c31\u662fd[u]+d[v]  \n\u6700\u77ed\u8def\u6c42d\u6570\u7ec4 \n\u4e0a\u4ee3\u7801  //93ms  \n```cpp\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#define N 51010\n#define M 200010\nusing namespace std;\nint n,m,tot,head[N],d[N],s,t,b;\nbool vis[N];\nstruct Edge{\n\tint v,u,next,val;\n}edge[M];\ninline int read(){\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();\n\t}while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();\n\t}return  x*f;\n}\ninline void add(int x,int y ,int z){edge[++tot].v=y;edge[tot].next=head[x];head[x]=tot;edge[tot].val=z;edge[tot].u=x;}\nvoid spfa(int x){\n\tqueue<int>q;\n\tmemset(d,0x3f,sizeof(d));\n\tq.push(x);d[x]=0;vis[x]=1;\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();vis[u]=0;\n\t\tfor(int i=head[u];i;i=edge[i].next){\n\t\t\tint v=edge[i].v,z=edge[i].val;\n\t\t\tif(d[v]>d[u]+z){\n\t\t\t\td[v]=d[u]+z; \n\t\t\t\tif(!vis[v])vis[v]=1,q.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();m=read();b=read();\n\tfor(int i=1;i<=m;i++){\n\t\tint x=read(),y=read(),z=read();\n\t\tadd(x,y,z);add(y,x,z); \n\t}\n\tspfa(1);\n\tfor(int i=1;i<=b;i++){\n\t\tint x=read(),y=read();\n\t\tprintf(\"%d\\n\",d[x]+d[y]);\n\t}\n\treturn 0;\n}\n\n```\n",
        "postTime": 1555043777,
        "uid": 88733,
        "name": "Zekrom",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 P2984 \u3010[USACO10FEB]\u7ed9\u5de7\u514b\u529bChocolate Giving\u3011"
    }
]