{
    "description": "Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.\n\nCombinator expression in BCKI basis is a string, corresponding to the following grammar:\n\n```plain\n\u27e8Expression\u27e9 ::= \u27e8Expression\u27e9 \u27e8Term\u27e9 | \u27e8Term\u27e9\n\u27e8Term\u27e9 ::= \u2018(\u2019\u27e8Expression\u27e9\u2018)\u2019 | \u2018B\u2019 | \u2018C\u2019 | \u2018K\u2019 | \u2018I\u2019\n```\n\nAs we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.\n\nFor the sake of the explanation we will use lowercase English letters $(a \\cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\\underbrace { I }_{ x }C)$, $x(\\underbrace {BIC}_{ x })$, $xy(\\underbrace {BI}_{ x } \\underbrace { C }_{ y })$, $Bxy (B\\underbrace { I }_{ x }\\underbrace { C }_{ y })$, but not by $Bx$.\n\nWe say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation \u2014 instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.\n\nTo evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below \u2014 that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.\n\n| Pattern | Reduction result |                   Description                   |\n| :-----: | :--------------: | :---------------------------------------------: |\n| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |\n| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |\n|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |\n|  $Ix$   |       $x$        |     Identity function (Identit\u00e4tsfunktion)      |\n\nAfter the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment\n\n$$\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace {(CB)}_{ z }I$$\n\nand see that $CIC(CB)I \u2261 (((CI)C)(CB))I \u2261 (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I \u2261 I(CB)CI:$\n\n$$(\\underbrace { C }_{ C }\\underbrace { I }_{ x }\\underbrace { C }_{ y }\\underbrace { (CB) }_{ Z })I \\rightarrow (\\underbrace { I }_{ x } \\underbrace {(CB)}_{ z }\\underbrace { C }_{ y })I$$\n\nOne more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$\n\n$$(\\underbrace { B }_{ B }\\underbrace { ((CK)I) }_{ x }\\underbrace { I }_{ y }\\underbrace { C }_{ z } \\rightarrow \\underbrace { ((CK)I) }_{ x } (\\underbrace { I }_{ y }\\underbrace { C }_{ z })$$\n\nNow, let's reduce the last $I:$\n\n$$((CK)I)(\\underbrace { I }_{ I } \\underbrace { C }_{ x }) \\rightarrow ((CK)I)C$$\n\nAnd now we finish evaluation with two more reductions:\n\n$$((\\underbrace { C }_{ C }\\underbrace { K }_{ x }) \\underbrace { I }_{ y }) \\underbrace { C }_{ z } \\rightarrow (\\underbrace { K }_{ K }\\underbrace { C }_{ x }) \\underbrace { I }_{ y } \\rightarrow C$$\n\nIt is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:\n\n$$C(K(II)(\\underbrace { I }_{ I }\\underbrace { C }_{ x })) \\rightarrow C(K(\\underbrace { I }_{ I }\\underbrace {  I}_{ x })(C)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x }) \\underbrace { C }_{ y }) \\rightarrow CI$$\n\nleads to the same result as \n\n$$C(K(\\underbrace {I}_{ I }\\underbrace { I }_{ x })(IC)) \\rightarrow C((\\underbrace { K }_{ K }\\underbrace { I }_{ x })\\underbrace { (IC)}_{ y }) \\rightarrow CI$$\n\nHowever, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.\n\nYour task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.",
    "inputFormat": "\n\nThe only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.\n\n",
    "outputFormat": "\n\nOutput a single integer \u2014 the minimal number of reductions required for the given formula to evaluate it to normal form.\n\n",
    "samples": [
        [
            "C(K(II)(IC))\n",
            "2\n"
        ],
        [
            "CIBI\n",
            "3\n"
        ],
        [
            "BBBBBCCCCCKKKKKIIIII\n",
            "15\n"
        ]
    ],
    "hint": "Time limit: 1 s, Memory limit: 256 MB. \n\n"
}