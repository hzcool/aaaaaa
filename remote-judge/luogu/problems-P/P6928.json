{
    "description": "Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.\n\nIn this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:\n\ncompute \u2013 perform a computation for one\u00a0microsecond\n\nlock $k$ \u2013 lock resource $k$ (which takes no processor time)\n\nunlock $k$ \u2013 unlock resource $k$ (which takes no processor time)\n\nAfter locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.\n\nEach resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.\n\nThere is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:\n\n  Step 1.\n\nIdentify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.\n\n  Step 2.\n\nDetermine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource\u00a0$k$ and either resource\u00a0$k$ is already owned or at least one other task owns a resource\u00a0$\\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\\ell $. The current priority of a task $T$ is the maximum of $T$\u2019s base priority and the current priorities of all tasks that $T$ blocks.\n\n  Step 3.\n\nExecute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one\u00a0microsecond. If a lock or unlock instruction was executed, do not increment the clock.\n\nThe Priority Ceiling Protocol defined above has the following properties:\n\nCurrent priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.\n\nAll tasks will eventually complete.\n\nThere will never be a tie in step\u00a03.",
    "inputFormat": "The first line of the input contains two integers $t$ $(1 \\leq t \\leq 20)$, which is the number of tasks, and $r$ ($1 \\leq r \\leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task\u2019s start time $s$ ($1 \\leq s \\leq 10\\, 000$), its base priority $b$ ($1 \\leq b \\leq t$), and an integer $a$ ($1 \\leq a \\leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \\leq n \\leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \\leq k \\leq r$) indicate instructions locking and unlocking resource $k$ respectively.\n\nNo two tasks have the same base priority.",
    "outputFormat": "For each task, display the time it completes execution, in the same order that the tasks are given in the input.",
    "samples": [
        [
            "3 1\n50 2 5 C1 L1 C1 U1 C1\n1 1 5 C1 L1 C100 U1 C1\n70 3 1 C1\n",
            "106\n107\n71\n"
        ],
        [
            "3 3\n5 3 5 C1 L1 C1 U1 C1\n3 2 9 C1 L2 C1 L3 C1 U3 C1 U2 C1\n1 1 9 C1 L3 C3 L2 C1 U2 C1 U3 C1\n",
            "8\n15\n16\n"
        ]
    ],
    "hint": "Time limit: 1000 ms, Memory limit: 1048576 kB. \n\n International Collegiate Programming Contest (ACM-ICPC) World Finals 2016"
}