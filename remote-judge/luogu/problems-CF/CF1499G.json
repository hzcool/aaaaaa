{
    "description": "You are given a bipartite graph consisting of $ n_1 $ vertices in the first part, $ n_2 $ vertices in the second part, and $ m $ edges, numbered from $ 1 $ to $ m $ . You have to color each edge into one of two colors, red and blue. You have to minimize the following value: $ \\sum \\limits_{v \\in V} |r(v) - b(v)| $ , where $ V $ is the set of vertices of the graph, $ r(v) $ is the number of red edges incident to $ v $ , and $ b(v) $ is the number of blue edges incident to $ v $ .\n\nSounds classical and easy, right? Well, you have to process $ q $ queries of the following format:\n\n- $ 1 $ $ v_1 $ $ v_2 $ \u2014 add a new edge connecting the vertex $ v_1 $ of the first part with the vertex $ v_2 $ of the second part. This edge gets a new index as follows: the first added edge gets the index $ m + 1 $ , the second \u2014 $ m + 2 $ , and so on. After adding the edge, you have to print the hash of the current optimal coloring (if there are multiple optimal colorings, print the hash of any of them). Actually, this hash won't be verified, you may print any number as the answer to this query, but you may be asked to produce the coloring having this hash;\n- $ 2 $ \u2014 print the optimal coloring of the graph with the same hash you printed while processing the previous query. The query of this type will only be asked after a query of type $ 1 $ , and there will be at most $ 10 $ queries of this type. If there are multiple optimal colorings corresponding to this hash, print any of them.\n\nNote that if an edge was red or blue in some coloring, it may change its color in next colorings.\n\nThe hash of the coloring is calculated as follows: let $ R $ be the set of indices of red edges, then the hash is $ (\\sum \\limits_{i \\in R} 2^i) \\bmod 998244353 $ .\n\nNote that you should solve the problem in online mode. It means that you can't read the whole input at once. You can read each query only after writing the answer for the last query. Use functions fflush in C++ and BufferedWriter.flush in Java languages after each writing in your program.",
    "inputFormat": "The first line contains three integers $ n_1 $ , $ n_2 $ and $ m $ ( $ 1 \\le n_1, n_2, m \\le 2 \\cdot 10^5 $ ).\n\nThen $ m $ lines follow, the $ i $ -th of them contains two integers $ x_i $ and $ y_i $ ( $ 1 \\le x_i \\le n_1 $ ; $ 1 \\le y_i \\le n_2 $ ) meaning that the $ i $ -th edge connects the vertex $ x_i $ from the first part and the vertex $ y_i $ from the second part.\n\nThe next line contains one integer $ q $ ( $ 1 \\le q \\le 2 \\cdot 10^5 $ ) \u2014 the number of queries you have to process.\n\nThe next $ q $ lines contain the queries in the format introduced in the statement.\n\nAdditional constraints on the input:\n\n- at any moment, the graph won't contain any multiple edges;\n- the queries of type $ 2 $ are only asked if the previous query had type $ 1 $ ;\n- there are at most $ 10 $ queries of type $ 2 $ .",
    "outputFormat": "To answer a query of type $ 1 $ , print one integer \u2014 the hash of the optimal coloring.\n\nTo answer a query of type $ 2 $ , print one line. It should begin with the integer $ k $ \u2014 the number of red edges. Then, $ k $ distinct integer should follow \u2014 the indices of red edges in your coloring, in any order. Each index should correspond to an existing edge, and the hash of the coloring you produce should be equal to the hash you printed as the answer to the previous query.\n\nIf there are multiple answers to a query, you may print any of them.",
    "samples": [
        [
            "3 4 2\n1 2\n3 4\n10\n1 1 3\n1 2 3\n2\n1 3 3\n2\n1 2 4\n2\n1 2 1\n1 1 1\n2",
            "8\n8\n1 3\n40\n2 3 5\n104\n3 5 6 3\n104\n360\n4 5 6 3 8"
        ]
    ],
    "hint": "",
    "translation": "\u6709\u4e00\u4e2a\u4e8c\u5206\u56fe\uff0c\u4e00\u8fb9\u6709 $n_1$ \u4e2a\u9876\u70b9\uff0c\u53e6\u4e00\u8fb9\u6709 $n_2$ \u4e2a\u9876\u70b9\u3002\u4e2d\u95f4\u6709 $m$ \u6761\u8fb9\uff0c\u7f16\u53f7\u4ece $1$ \u5230 $m$\u3002\u9700\u8981\u7ed9\u6bcf\u6761\u8fb9\u6d82\u4e0a\u7ea2\u84dd\u4e24\u8272\u4e4b\u4e00\uff0c\u4f7f $\\sum\\limits_{v\\in V}|r(v)-b(v)|$ \u7684\u503c\u6700\u5c0f\uff0c\u5176\u4e2d $V$ \u8868\u793a\u9876\u70b9\u96c6\uff0c $r(v)$ \u548c $b(v)$ \u5206\u522b\u8868\u793a\u4e0e\u9876\u70b9 $v$ \u76f8\u8fde\u7684\u7ea2\u8fb9\u548c\u84dd\u8fb9\u7684\u6570\u91cf\u3002\n\n\u4f60\u8981\u5904\u7406\u7684\u662f $q$ \u4e2a\u8be2\u95ee\uff1a\n\n-  $1\\ v_1\\ v_2$\uff1a\u8868\u793a\u5728\u7b2c\u4e00\u90e8\u5206\u7684 $v_1$ \u53f7\u9876\u70b9\u548c\u7b2c\u4e8c\u90e8\u5206\u7684 $v_2$ \u53f7\u9876\u70b9\u4e4b\u95f4\u8fde\u4e00\u6761\u8fb9\uff0c\u7136\u540e\u8f93\u51fa\u6b64\u65f6\u56fe\u7684\u6700\u4f18\u5316\u6d82\u8272\u65b9\u6848\u7684\u54c8\u5e0c\u503c\uff08\u5b9a\u4e49\u89c1\u4e0b\uff09\u3002\u6709\u591a\u89e3\u7684\u8bdd\u8f93\u51fa\u4efb\u610f\u4e00\u4e2a\u5373\u53ef\u3002\n- $2$\uff1a\u5bf9\u4e8e\u4e0a\u4e00\u4e2a\u8be2\u95ee $1$\uff0c\u8f93\u51fa\u4f60\u7ed9\u51fa\u7684\u54c8\u5e0c\u503c\u6240\u5bf9\u5e94\u7684\u67d3\u8272\u65b9\u6848\u3002\u82e5\u54c8\u5e0c\u503c\u5bf9\u5e94\u591a\u79cd\u65b9\u6848\u5219\u8f93\u51fa\u4efb\u610f\u4e00\u79cd\u3002\u4fdd\u8bc1\u4e0a\u4e00\u4e2a\u8be2\u95ee\u662f\u8be2\u95ee $1$\uff0c\u4e14\u8be2\u95ee $2$ \u7684\u6b21\u6570\u4e0d\u8d85\u8fc7 $10$ \u4e2a\u3002\n\n\u4e00\u79cd\u6d82\u8272\u65b9\u6848\u7684\u54c8\u5e0c\u503c\u5b9a\u4e49\u4e3a $(\\sum\\limits_{i\\in R}2^i)\\bmod{998244353}$\uff0c\u5176\u4e2d $R$ \u662f\u6240\u6709\u6d82\u7ea2\u8272\u7684\u8fb9\u7684\u7f16\u53f7\u96c6\u5408\u3002\n\n\u8f93\u5165\u5f3a\u5236\u5728\u7ebf\u3002"
}