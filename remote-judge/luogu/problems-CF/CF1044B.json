{
    "description": "You are playing a strange game with Li Chen. You have a tree with $ n $ nodes drawn on a piece of paper. All nodes are unlabeled and distinguishable. Each of you independently labeled the vertices from $ 1 $ to $ n $ . Neither of you know the other's labelling of the tree.\n\nYou and Li Chen each chose a subtree (i.e., a connected subgraph) in that tree. Your subtree consists of the vertices labeled $ x_1, x_2, \\ldots, x_{k_1} $ in your labeling, Li Chen's subtree consists of the vertices labeled $ y_1, y_2, \\ldots, y_{k_2} $ in his labeling. The values of $ x_1, x_2, \\ldots, x_{k_1} $ and $ y_1, y_2, \\ldots, y_{k_2} $ are known to both of you.\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1044B/f8d6eab9a505e94e56f3fbc02db7e9ddfae952fb.png) The picture shows two labelings of a possible tree: yours on the left and Li Chen's on the right. The selected trees are highlighted. There are two common nodes.You want to determine whether your subtrees have at least one common vertex. Luckily, your friend Andrew knows both labelings of the tree. You can ask Andrew at most $ 5 $ questions, each of which is in one of the following two forms:\n\n- A x: Andrew will look at vertex $ x $ in your labeling and tell you the number of this vertex in Li Chen's labeling.\n- B y: Andrew will look at vertex $ y $ in Li Chen's labeling and tell you the number of this vertex in your labeling.\n\nDetermine whether the two subtrees have at least one common vertex after asking some questions. If there is at least one common vertex, determine one of your labels for any of the common vertices.",
    "inputFormat": "",
    "outputFormat": "Each test consists of several test cases.\n\nThe first line of input contains a single integer $ t $ ( $ 1 \\leq t \\leq 100 $ ) \u2014 the number of test cases.\n\nFor each testcase, your program should interact in the following format.\n\nThe first line contains a single integer $ n $ ( $ 1 \\leq n \\leq 1\\,000 $ ) \u2014 the number of nodes in the tree.\n\nEach of the next $ n-1 $ lines contains two integers $ a_i $ and $ b_i $ ( $ 1\\leq a_i, b_i\\leq n $ ) \u2014 the edges of the tree, indicating an edge between node $ a_i $ and $ b_i $ according to your labeling of the nodes.\n\nThe next line contains a single integer $ k_1 $ ( $ 1 \\leq k_1 \\leq n $ ) \u2014 the number of nodes in your subtree.\n\nThe next line contains $ k_1 $ distinct integers $ x_1,x_2,\\ldots,x_{k_1} $ ( $ 1 \\leq x_i \\leq n $ ) \u2014 the indices of the nodes in your subtree, according to your labeling. It is guaranteed that these vertices form a subtree.\n\nThe next line contains a single integer $ k_2 $ ( $ 1 \\leq k_2 \\leq n $ ) \u2014 the number of nodes in Li Chen's subtree.\n\nThe next line contains $ k_2 $ distinct integers $ y_1, y_2, \\ldots, y_{k_2} $ ( $ 1 \\leq y_i \\leq n $ ) \u2014 the indices (according to Li Chen's labeling) of the nodes in Li Chen's subtree. It is guaranteed that these vertices form a subtree according to Li Chen's labelling of the tree's nodes.\n\nTest cases will be provided one by one, so you must complete interacting with the previous test (i.e. by printing out a common node or $ -1 $ if there is not such node) to start receiving the next one.\n\nYou can ask the Andrew two different types of questions.\n\n- You can print \"A x\" ( $ 1 \\leq x \\leq n $ ). Andrew will look at vertex $ x $ in your labeling and respond to you with the number of this vertex in Li Chen's labeling.\n- You can print \"B y\" ( $ 1 \\leq y \\leq n $ ). Andrew will look at vertex $ y $ in Li Chen's labeling and respond to you with the number of this vertex in your labeling.\n\nYou may only ask at most $ 5 $ questions per tree.\n\nWhen you are ready to answer, print \"C s\", where $ s $ is your label of a vertex that is common to both subtrees, or $ -1 $ , if no such vertex exists. Printing the answer does not count as a question. Remember to flush your answer to start receiving the next test case.\n\nAfter printing a question do not forget to print end of line and flush the output. Otherwise, you will get Idleness limit exceeded. To do this, use:\n\n- fflush(stdout) or cout.flush() in C++;\n- System.out.flush() in Java;\n- flush(output) in Pascal;\n- stdout.flush() in Python;\n- see documentation for other languages.\n\nIf the judge responds with $ -1 $ , it means that you asked more queries than allowed, or asked an invalid query. Your program should immediately terminate (for example, by calling exit(0)). You will receive Wrong Answer; it means that you asked more queries than allowed, or asked an invalid query. If you ignore this, you can get other verdicts since your program will continue to read from a closed stream.\n\nHack Format\n\nTo hack, use the following format. Note that you can only hack with one test case.\n\nThe first line should contain a single integer $ t $ ( $ t=1 $ ).\n\nThe second line should contain a single integer $ n $ ( $ 1 \\leq n \\leq 1\\,000 $ ).\n\nThe third line should contain $ n $ integers $ p_1, p_2, \\ldots, p_n $ ( $ 1\\leq p_i\\leq n $ ) \u2014 a permutation of $ 1 $ to $ n $ . This encodes the labels that Li Chen chose for his tree. In particular, Li Chen chose label $ p_i $ for the node you labeled $ i $ .\n\nEach of the next $ n-1 $ lines should contain two integers $ a_i $ and $ b_i $ ( $ 1\\leq a_i, b_i\\leq n $ ). These edges should form a tree.\n\nThe next line should contain a single integer $ k_1 $ ( $ 1 \\leq k_1 \\leq n $ ).\n\nThe next line should contain $ k_1 $ distinct integers $ x_1,x_2,\\ldots,x_{k_1} $ ( $ 1 \\leq x_i \\leq n $ ). These vertices should form a subtree.\n\nThe next line should contain a single integer $ k_2 $ ( $ 1 \\leq k_2 \\leq n $ ).\n\nThe next line should contain $ k_2 $ distinct integers $ y_1, y_2, \\ldots, y_{k_2} $ ( $ 1 \\leq y_i \\leq n $ ). These vertices should form a subtree in Li Chen's tree according to the permutation above.",
    "samples": [
        [
            "1\n3\n1 2\n2 3\n1\n1\n1\n2\n2\n1\n",
            "A 1\nB 2\nC 1\n"
        ],
        [
            "2\n6\n1 2\n1 3\n1 4\n4 5\n4 6\n4\n1 3 4 5\n3\n3 5 2\n3\n6\n1 2\n1 3\n1 4\n4 5\n4 6\n3\n1 2 3\n3\n4 1 6\n5\n",
            "B 2\nC 1\nA 1\nC -1\n"
        ]
    ],
    "hint": "For the first sample, Li Chen's hidden permutation is $ [2, 3, 1] $ , and for the second, his hidden permutation is $ [5, 3, 2, 4, 1, 6] $ for both cases.\n\nIn the first sample, there is a tree with three nodes in a line. On the top, is how you labeled the tree and the subtree you chose, and the bottom is how Li Chen labeled the tree and the subtree he chose:\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1044B/20da1d3951c06c9ea90b744aab9f3033dac72c43.png)In the first question, you ask Andrew to look at node $ 1 $ in your labelling and tell you the label of it in Li Chen's labelling. Andrew responds with $ 2 $ . At this point, you know that both of your subtrees contain the same node (i.e. node $ 1 $ according to your labeling), so you can output \"C 1\" and finish. However, you can also ask Andrew to look at node $ 2 $ in Li Chen's labelling and tell you the label of it in your labelling. Andrew responds with $ 1 $ (this step was given with the only reason \u2014 to show you how to ask questions).\n\nFor the second sample, there are two test cases. The first looks is the one from the statement:\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1044B/f8d6eab9a505e94e56f3fbc02db7e9ddfae952fb.png)We first ask \"B 2\", and Andrew will tell us $ 3 $ . In this case, we know $ 3 $ is a common vertex, and moreover, any subtree with size $ 3 $ that contains node $ 3 $ must contain node $ 1 $ as well, so we can output either \"C 1\" or \"C 3\" as our answer.\n\nIn the second case in the second sample, the situation looks as follows:\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1044B/90d5b00e08570be05b2931735d98bbcd805bf31f.png)In this case, you know that the only subtree of size $ 3 $ that doesn't contain node $ 1 $ is subtree $ 4,5,6 $ . You ask Andrew for the label of node $ 1 $ in Li Chen's labelling and Andrew says $ 5 $ . In this case, you know that Li Chen's subtree doesn't contain node $ 1 $ , so his subtree must be consist of the nodes $ 4,5,6 $ (in your labelling), thus the two subtrees have no common nodes.",
    "translation": "### \u9898\u76ee\u63cf\u8ff0\n\n\u8fd9\u662f\u4e00\u9053\u4ea4\u4e92\u9898\n\n\u4f60\u548c$Li\\ Chen$\u6b63\u5728\u73a9\u4e00\u4e2a\u5947\u602a\u7684\u6e38\u620f\u3002\u7ed9\u51fa\u4e00\u68f5$N$\u4e2a\u70b9\u7684\u6811\uff0c\u53cc\u65b9\u5206\u522b\u7ed9\u9876\u70b9\u7f16\u53f7\u4e3a$1$\u5230$N$\uff0c\u53cc\u65b9\u90fd\u4e0d\u77e5\u9053\u5bf9\u65b9\u7ed9\u6811\u7f16\u53f7\u7684\u65b9\u5f0f\u3002\n\n\u63a5\u7740\u53cc\u65b9\u5728\u81ea\u5df1\u5bf9\u5e94\u7684\u6811\u4e0a\u9009\u62e9\u4e00\u4e2a\u8054\u901a\u5b50\u56fe\uff0c\u5728**\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u5bf9\u5e94\u7684\u6811\u4e0a**\u4f60\u9009\u62e9\u4e86$x_1,x_2,...,x_{k_1}$\uff0c**\u5728$Li\\ Chen$\u7684\u7f16\u53f7\u65b9\u5f0f\u5bf9\u5e94\u7684\u6811\u4e0a**$Li\\ Chen$\u9009\u62e9\u4e86$y_1,y_2,...,y_{k_2}$\uff0c\u53cc\u65b9\u90fd\u77e5\u9053$x_1,...,x_{k_1}$\u4e0e$y_1,...,y_{k_2}$\u7684\u503c\n\n\u73b0\u5728\u4f60\u60f3\u77e5\u9053\u4e24\u4e2a\u5b50\u56fe\u662f\u5426\u5b58\u5728\u81f3\u5c11\u4e00\u4e2a\u516c\u5171\u70b9\u3002\u4f60\u53ef\u4ee5\u8fdb\u884c\u8be2\u95ee\uff0c\u95ee\u9898\u6709\u4ee5\u4e0b\u4e24\u79cd\uff1a\n\n$A \\ x$\uff1a\u5f97\u5230\u5728\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684$x$\u53f7\u70b9\u5728$Li\\ Chen$\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684\u503c\n\n$B \\ x$\uff1a\u5f97\u5230\u5728$Li\\ Chen$\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684$x$\u53f7\u70b9\u5728\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684\u503c\n\n\u73b0\u5728\u8bf7\u4f60\u4f7f\u7528**\u4e0d\u591a\u4e8e$5$\u6b21**\u8be2\u95ee\u5f97\u51fa\u662f\u5426\u5b58\u5728\u516c\u5171\u70b9\uff0c\u6216\u8005\u786e\u5b9a\u4e24\u68f5\u5b50\u6811\u6ca1\u6709\u516c\u5171\u70b9\u3002\n\n### \u8f93\u5165\u6570\u636e\n\n\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570$t(1 \\leq t \\leq 100)$\u8868\u793a\u6570\u636e\u7ec4\u6570\n\n\u5728\u6bcf\u4e00\u7ec4\u6570\u636e\u4ea4\u4e92\u5f00\u59cb\u4e4b\u524d\uff0c\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570$n(1 \\leq n \\leq 1000)$\u8868\u793a\u6811\u4e0a\u7684\u70b9\u6570\uff0c\u63a5\u7740$n-1$\u884c\u6bcf\u884c\u4e24\u4e2a\u6b63\u6574\u6570$u,v(1 \\leq u,v \\leq n)$\u8868\u793a**\u5728\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b**\u7f16\u53f7\u4e3a$u,v$\u7684\u4e24\u4e2a\u70b9\u4e4b\u95f4\u6709\u4e00\u6761\u8fb9\u3002\n\n\u63a5\u4e0b\u6765\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570$k_1(1 \\leq k_1 \\leq n)$\u8868\u793a\u4f60\u9009\u51fa\u6765\u7684\u70b9\u7684\u4e2a\u6570\uff0c\u4e0b\u4e00\u884c$k_1$\u4e2a\u6574\u6570$x_1,...,x_{k_1}(1 \\leq x_i \\leq n)$\u63cf\u8ff0\u4f60\u9009\u51fa\u6765\u7684\u70b9\u5728\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684\u7f16\u53f7\u3002\n\n\u63a5\u4e0b\u6765\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570$k_2(1 \\leq k_2 \\leq n)$\u8868\u793a$Li\\ Chen$\u9009\u51fa\u6765\u7684\u70b9\u7684\u4e2a\u6570\uff0c\u4e0b\u4e00\u884c$k_2$\u4e2a\u6574\u6570$y_1,...,y_{k_2}(1 \\leq y_i \\leq n)$\u63cf\u8ff0$Li\\ Chen$\u9009\u51fa\u6765\u7684\u70b9\u5728$Li\\ Chen$\u7684\u7f16\u53f7\u65b9\u5f0f\u4e0b\u7684\u7f16\u53f7\u3002\n\n\u6570\u636e\u4f1a\u4e00\u7ec4\u4e00\u7ec4\u7ed9\u51fa\uff0c\u6240\u4ee5\u8bf7\u5728\u4e0a\u4e00\u7ec4\u6570\u636e\u5b8c\u6210\u4ea4\u4e92\u4e4b\u540e\uff0c\u518d\u8fdb\u884c\u4e0b\u4e00\u7ec4\u6570\u636e\u7684\u8bfb\u5165\u3002\n\n### \u4ea4\u4e92\u5b9e\u73b0\n\n\u5728\u6807\u51c6\u8f93\u5165\u8f93\u51fa\u4e2d\u8fdb\u884c\u8be2\u95ee\u548c\u56de\u7b54\u3002\u6bcf\u4e00\u7ec4\u6570\u636e\u53ef\u4ee5\u63d0\u51fa\u4e0d\u591a\u4e8e$5$\u4e2a\u95ee\u9898\uff0c\u5f62\u5f0f\u5982\u201c\u9898\u76ee\u63cf\u8ff0\u201d\u6240\u8ff0\u3002\n\n\u8f93\u51fa\u7b54\u6848\u7684\u683c\u5f0f\u4e3a$C\\ x$\uff0c\u5176\u4e2d$x$\u4e3a\u4f60\u8ba4\u4e3a\u7684\u516c\u5171\u7684\u70b9**\u5728\u4f60\u7684\u7f16\u53f7\u65b9\u5f0f\u5bf9\u5e94\u7684\u6811\u4e0a**\u7684\u7f16\u53f7\u3002\u5982\u679c\u4f60\u8ba4\u4e3a\u6ca1\u6709\u516c\u5171\u70b9\uff0c\u90a3\u4e48$x=-1$\u3002\n\n\u6bcf\u8f93\u51fa\u4e00\u884c\uff0c\u8bf7$flush$\u4f60\u7684\u8f93\u51fa\uff0c\u5426\u5219\u4f1a\u8fd4\u56de$Idleness\\ limit\\ exceeded$\u3002$flush$\u8f93\u51fa\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u51fd\u6570\uff1a\n\n$C++:$fflush(stdout);\n\n$Java:$System.out.flush();\n\n$Python:$stdout.flush();\n\n$Pascal:$flush(output);\n\n\u5176\u4ed6\u8bed\u8a00\u89c1\u5bf9\u5e94\u8bed\u8a00\u7684\u51fd\u6570\u58f0\u660e\n\n\u5728\u4efb\u4f55\u65f6\u5019\u5982\u679c\u8f93\u5165\u4e86$-1$\uff0c\u8868\u660e\u51fa\u73b0\u4e86\u9519\u8bef\uff0c\u8bf7\u7acb\u5373\u7ed3\u675f\u7a0b\u5e8f\uff0c\u6b64\u65f6\u4f1a\u8fd4\u56de$Wrong\\ answer$\u3002\u5982\u679c\u4f60\u5ffd\u7565\u4e86\u8fd9\u4e2a\u4fe1\u606f\uff0c\u7531\u4e8e\u4f60\u5728\u4e00\u4e2a\u5173\u95ed\u4e86\u7684\u8f93\u5165\u6d41\u4e2d\u8f93\u5165\u4fe1\u606f\uff0c\u53ef\u80fd\u4f1a\u51fa\u73b0\u4e0d\u53ef\u9884\u6599\u7684\u9519\u8bef\u3002"
}