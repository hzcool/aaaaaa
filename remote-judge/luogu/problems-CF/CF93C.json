{
    "description": "After the Search Ultimate program that searched for strings in a text failed, Igor K. got to think: \"Why on Earth does my program work so slowly?\" As he double-checked his code, he said: \"My code contains no errors, yet I know how we will improve Search Ultimate!\" and took a large book from the shelves. The book read \"Azembler. Principally New Approach\".\n\nHaving carefully thumbed through the book, Igor K. realised that, as it turns out, you can multiply the numbers dozens of times faster. \"Search Ultimate will be faster than it has ever been!\" \u2014 the fellow shouted happily and set to work.\n\nLet us now clarify what Igor's idea was. The thing is that the code that was generated by a compiler was far from perfect. Standard multiplying does work slower than with the trick the book mentioned.\n\nThe Azembler language operates with 26 registers (eax, ebx, ..., ezx) and two commands:\n\n- \\[ $ x $ \\] \u2014 returns the value located in the address $ x $ . For example, \\[eax\\] returns the value that was located in the address, equal to the value in the register eax.\n- lea $ x $ , $ y $ \u2014 assigns to the register $ x $ , indicated as the first operand, the second operand's address. Thus, for example, the \"lea ebx, \\[eax\\]\" command will write in the ebx register the content of the eax register: first the \\[eax\\] operation will be fulfilled, the result of it will be some value that lies in the address written in eax. But we do not need the value \u2014 the next operation will be lea, that will take the \\[eax\\] address, i.e., the value in the eax register, and will write it in ebx.\n\nOn the first thought the second operation seems meaningless, but as it turns out, it is acceptable to write the operation as\n\nlea ecx, \\[eax + ebx\\],\n\nlea ecx, \\[k\\*eax\\]\n\nor even\n\nlea ecx, \\[ebx + k\\*eax\\],\n\nwhere k = 1, 2, 4 or 8.\n\nAs a result, the register ecx will be equal to the numbers eax + ebx, k\\*eax and ebx + k\\*eax correspondingly. However, such operation is fulfilled many times, dozens of times faster that the usual multiplying of numbers. And using several such operations, one can very quickly multiply some number by some other one. Of course, instead of eax, ebx and ecx you are allowed to use any registers.\n\nFor example, let the eax register contain some number that we should multiply by 41. It takes us 2 lines:\n\nlea ebx, \\[eax + 4\\*eax\\] // now ebx = 5\\*eax\n\nlea eax, \\[eax + 8\\*ebx\\] // now eax = eax + 8\\*ebx = 41\\*eax\n\nIgor K. got interested in the following question: what is the minimum number of lea operations needed to multiply by the given number $ n $ and how to do it? Your task is to help him.\n\nConsider that at the initial moment of time eax contains a number that Igor K. was about to multiply by $ n $ , and the registers from ebx to ezx contain number 0. At the final moment of time the result can be located in any register.",
    "inputFormat": "The input data contain the only integer $ n $ ( $ 1<=n<=255 $ ), which Igor K. is about to multiply.",
    "outputFormat": "On the first line print number $ p $ , which represents the minimum number of lea operations, needed to do that. Then print the program consisting of $ p $ commands, performing the operations. It is guaranteed that such program exists for any $ n $ from 1 to 255.\n\nUse precisely the following format of commands (here $ k $ is equal to 1, 2, 4 or 8, and $ x $ , $ y $ and $ z $ are any, even coinciding registers):\n\nlea x, \\[y\\]\n\nlea x, \\[y + z\\]\n\nlea x, \\[k\\*y\\]\n\nlea x, \\[y + k\\*z\\]\n\nPlease note that extra spaces at the end of a command are unacceptable.",
    "samples": [
        [
            "41\n",
            "2\nlea ebx, [eax + 4*eax]\nlea ecx, [eax + 8*ebx]\n"
        ],
        [
            "2\n",
            "1\nlea ebx, [eax + eax]\n"
        ],
        [
            "4\n",
            "1\nlea ebx, [4*eax]\n"
        ]
    ],
    "hint": "",
    "translation": "\u4f60\u6709 `eax,ebx,ecx,...,ezx` \u8fd926\u4e2a\u5bc4\u5b58\u5668\uff0c\u521d\u59cb `eax` \u4e2d\u4f1a\u6709\u4e00\u4e2a\u6570\uff0c\u5176\u4f59\u4e3a $0$\u3002\n\n\u5b9a\u4e49\u4e00\u4e2a\u6307\u4ee4\u5e8f\u5217\u5305\u542b\u4ee5\u4e0b\u56db\u7c7b\u6307\u4ee4\uff1a\n\n- `lea x, [y]` \u5c06\u5bc4\u5b58\u5668 $y$ \u4e2d\u7684\u503c\u8d4b\u7ed9\u5bc4\u5b58\u5668 $x$\u3002\n- `lea x, [y + z]` \u5c06\u5bc4\u5b58\u5668 $y$ \u4e0e $z$ \u4e2d\u7684\u503c\u4e4b\u548c\u8d4b\u7ed9\u5bc4\u5b58\u5668 $x$\u3002\n- `lea x, [k*y]` \u5c06\u5bc4\u5b58\u5668 $y$ \u4e2d\u7684\u503c\u7684 $k$ \u500d\u8d4b\u7ed9\u5bc4\u5b58\u5668 $x$\u3002\n- `lea x, [y + k*z]` \u5c06\u5bc4\u5b58\u5668 $y$ \u4e2d\u7684\u503c\u7684 $k$ \u500d\u4e0e\u5bc4\u5b58\u5668 $z$ \u4e2d\u7684\u503c\u4e4b\u548c\u8d4b\u7ed9\u5bc4\u5b58\u5668 $x$\u3002\n\n\u6ce8\u610f\uff0c\u8fd9\u91cc\u7684 `k=1,2,4,8`\uff0c`x,y,z` \u53ef\u4ee5\u4e3a\u4efb\u610f\u5bc4\u5b58\u5668\u3002\n\n\u8f93\u5165\u4e00\u4e2a\u6570 $n$ \u6ee1\u8db3 $1\u2009\u2264\u2009n\u2009\u2264\u2009255$ \u3002\u8868\u793a\u9700\u8981\u5c06\u5bc4\u5b58\u5668 `eax` \u4e2d\u7684\u6570\u53d8\u6210\u539f\u6765\u7684 $n$ \u500d\uff08\u53ea\u8981\u672b\u72b6\u6001\u5b58\u5728\u4e00\u4e2a\u5bc4\u5b58\u5668\uff0c\u5176\u4e2d\u7684\u503c\u4e3a\u6b64\u503c\u5373\u53ef\uff09\n\n\u8f93\u51fa\u884c\u6570\u6700\u5c11\u7684\u4efb\u610f\u7684\u6307\u4ee4\u5e8f\u5217\uff0c\u4e0d\u80fd\u6709\u884c\u672b\u7a7a\u683c\u3002"
}