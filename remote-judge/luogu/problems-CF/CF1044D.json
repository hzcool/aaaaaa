{
    "description": "There is an array $ a $ of $ 2^{30} $ integers, indexed from $ 0 $ to $ 2^{30}-1 $ . Initially, you know that $ 0 \\leq a_i < 2^{30} $ ( $ 0 \\leq i < 2^{30} $ ), but you do not know any of the values. Your task is to process queries of two types:\n\n- 1 l r x: You are informed that the bitwise xor of the subarray $ [l, r] $ (ends inclusive) is equal to $ x $ . That is, $ a_l \\oplus a_{l+1} \\oplus \\ldots \\oplus a_{r-1} \\oplus a_r = x $ , where $ \\oplus $ is the bitwise xor operator. In some cases, the received update contradicts past updates. In this case, you should ignore the contradicting update (the current update).\n- 2 l r: You are asked to output the bitwise xor of the subarray $ [l, r] $ (ends inclusive). If it is still impossible to know this value, considering all past updates, then output  $ -1 $ .\n\nNote that the queries are encoded. That is, you need to write an online solution.",
    "inputFormat": "The first line contains a single integer $ q $ ( $ 1 \\leq q \\leq 2 \\cdot 10^5 $ ) \u2014 the number of queries.\n\nEach of the next $ q $ lines describes a query. It contains one integer $ t $ ( $ 1 \\leq t \\leq 2 $ ) \u2014 the type of query.\n\nThe given queries will be encoded in the following way: let $ last $ be the answer to the last query of the second type that you have answered (initially, $ last = 0 $ ). If the last answer was $ -1 $ , set $ last = 1 $ .\n\n- If $ t = 1 $ , three integers follow, $ l' $ , $ r' $ , and $ x' $ ( $ 0 \\leq l', r', x' < 2^{30} $ ), meaning that you got an update. First, do the following: $ l = l' \\oplus last $ , $ r = r' \\oplus last $ , $ x = x' \\oplus last $ and, if $ l > r $ , swap $ l $ and $ r $ .\n  \n  This means you got an update that the bitwise xor of the subarray $ [l, r] $ is equal to $ x $ (notice that you need to ignore updates that contradict previous updates).\n- If $ t = 2 $ , two integers follow, $ l' $ and $ r' $ ( $ 0 \\leq l', r' < 2^{30} $ ), meaning that you got a query. First, do the following: $ l = l' \\oplus last $ , $ r = r' \\oplus last $ and, if $ l > r $ , swap $ l $ and $ r $ .\n  \n  For the given query, you need to print the bitwise xor of the subarray $ [l, r] $ . If it is impossible to know, print  $ -1 $ . Don't forget to change the value of $ last $ .\n\nIt is guaranteed there will be at least one query of the second type.",
    "outputFormat": "After every query of the second type, output the bitwise xor of the given subarray or  $ -1 $  if it is still impossible to know.",
    "samples": [
        [
            "12\n2 1 2\n2 1 1073741822\n1 0 3 4\n2 0 0\n2 3 3\n2 0 3\n1 6 7 3\n2 4 4\n1 0 2 1\n2 0 0\n2 4 4\n2 0 0\n",
            "-1\n-1\n-1\n-1\n5\n-1\n6\n3\n5\n"
        ],
        [
            "4\n1 5 5 9\n1 6 6 5\n1 6 5 10\n2 6 5\n",
            "12\n"
        ]
    ],
    "hint": "In the first example, the real queries (without being encoded) are:\n\n- 12\n- 2 1 2\n- 2 0 1073741823\n- 1 1 2 5\n- 2 1 1\n- 2 2 2\n- 2 1 2\n- 1 2 3 6\n- 2 1 1\n- 1 1 3 0\n- 2 1 1\n- 2 2 2\n- 2 3 3\n\n- The answers for the first two queries are $ -1 $ because we don't have any such information on the array initially.\n- The first update tells us $ a_1 \\oplus a_2 = 5 $ . Note that we still can't be certain about the values $ a_1 $ or $ a_2 $ independently (for example, it could be that $ a_1 = 1, a_2 = 4 $ , and also $ a_1 = 3, a_2 = 6 $ ).\n- After we receive all three updates, we have enough information to deduce $ a_1, a_2, a_3 $ independently.\n\nIn the second example, notice that after the first two updates we already know that $ a_5 \\oplus a_6 = 12 $ , so the third update is contradicting, and we ignore it.",
    "translation": "q\u6b64\u64cd\u4f5c$(1 \\leq q \\leq 2 \\times 10^5)$\uff0c\u4e24\u79cd\u64cd\u4f5c\u7c7b\u578b\uff1a\n\n1,l,r,x\uff1a\u8868\u793al\u5230r\u7684\u5f02\u6216\u548c\u4e3ax\uff1b\n\n2,l,r\uff1a\u8868\u793a\u8be2\u95eel\u5230r\u7684\u5f02\u6216\u548c\u3002\n\n\u5f3a\u5236\u5728\u7ebf\u3002$(0 \\leq l,r,x \\leq 2^{30})$"
}