{
    "description": "This is an interactive problem. In the interaction section below you will find the information about flushing the output.\n\nThe New Year tree of height $ h $ is a perfect binary tree with vertices numbered $ 1 $ through $ 2^{h}-1 $ in some order. In this problem we assume that $ h $ is at least $ 2 $ . The drawing below shows one example New Year tree of height $ 3 $ :\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF750F/07e9d5dc31cdb2b80679f5c4cff966cd8a5e5ddf.png)Polar bears love decorating the New Year tree and Limak is no exception. To decorate the tree, he must first find its root, i.e. a vertex with exactly two neighbours (assuming that $ h>=2 $ ). It won't be easy because Limak is a little bear and he doesn't even see the whole tree. Can you help him?\n\nThere are $ t $ testcases. In each testcase, you should first read $ h $ from the input. Then you can ask at most $ 16 $ questions of format \"? x\" (without quotes), where $ x $ is an integer between $ 1 $ and $ 2^{h}-1 $ , inclusive. As a reply you will get the list of neighbours of vertex $ x $ (more details in the \"Interaction\" section below). For example, for a tree on the drawing above after asking \"? 1\" you would get a response with $ 3 $ neighbours: $ 4 $ , $ 5 $ and $ 7 $ . Your goal is to find the index of the root $ y $ and print it in the format \"! y\". You will be able to read $ h $ for a next testcase only after printing the answer in a previous testcase and flushing the output.\n\nEach tree is fixed from the beginning and it doesn't change during your questions.",
    "inputFormat": "The first line of the input contains a single integer $ t $ ( $ 1<=t<=500 $ ) \u2014 the number of testcases.\n\nAt the beginning of each testcase you should read from the input a single integer $ h $ ( $ 2<=h<=7 $ ) \u2014 the height of the tree. You can't read the value of $ h $ in a next testcase until you answer a previous testcase.",
    "outputFormat": "To ask a question about neighbours of vertex $ x $ , print \"? x\" (without quotes) on a separate line. Note, you must print an end-of-line character after the last character of the line and flush your output to get a response.\n\nThe response will consist of two lines. The first line will contain a single integer $ k $ ( $ 1<=k<=3 $ ) \u2014 the number of neighbours of vertex $ x $ . The second line will contain $ k $ distinct integers $ t_{1},...,t_{k} $ ( $ 1<=t_{1}&lt;...&lt;t_{k}<=2^{h}-1 $ ) \u2014 indices of neighbours of vertex $ x $ , gives in the increasing order.\n\nAfter asking at most $ 16 $ questions you have to say $ y $ \u2014 the index of the root. Print \"! y\" (without quotes) and an end-of-line character, and flush the output.\n\nEach tree is fixed from the beginning and it doesn't change during your questions.\n\nYou can get Idleness Limit Exceeded if you don't print anything or if you forget to flush the output.\n\nTo flush you can use (just printing a query/answer and end-of-line):\n\n- fflush(stdout) in C++;\n- System.out.flush() in Java;\n- stdout.flush() in Python;\n- flush(output) in Pascal;\n- See the documentation for other languages.\n\nIn any moment if the program reads $ h=0 $ or $ k=0 $ it should immediately terminate normally (for example, calling exit(0)). It means that the system detected incorrect request/output from your program and printed 0 because if can't process your requests anymore. In this case you'll receive verdict \"Wrong Answer\", but if you ignore case $ h=0 $ or $ k=0 $ it could lead to \"Runtime Error\", \"Time/Memory limit exceeded\" or any other verdict because your program could read a trash from the closed input stream.\n\nHacking. To hack someone, use the following format:\n\nThe first line should contain a single integer $ t $ equal to $ 1 $ (only one testcase is allowed in hacks). The second line should contain a single integer $ h $ . Each of next $ 2^{h}-2 $ lines should contain two distinct integers $ a_{i} $ and $ b_{i} $ ( $ 1<=a_{i},b_{i}<=2^{h}-1 $ ), denoting two nodes connected with an edge. The printed edges must form a perfect binary tree of height $ h $ .\n\nOf course, contestant programs will not be able to see this input.",
    "samples": [
        [
            "1\n3\n3\n4 5 7\n2\n1 2\n1\n2\n",
            "? 1\n? 5\n? 6\n! 5\n"
        ],
        [
            "2\n2\n1\n3\n2\n1 2\n2\n1 2\n4\n3\n3 12 13\n",
            "? 1\n? 3\n? 3\n! 3\n? 6\n! 1\n"
        ]
    ],
    "hint": "In the first sample, a tree corresponds to the drawing from the statement.\n\nIn the second sample, there are two two testcases. A tree in the first testcase has height $ 2 $ and thus $ 3 $ vertices. A tree in the second testcase has height $ 4 $ and thus $ 15 $ vertices. You can see both trees on the drawing below.\n\n ![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF750F/eab1b64f9987e2e235a925fc7e8de8558c5d1462.png)",
    "translation": "\u9898\u76ee\u63cf\u8ff0\n\n\u8fd9\u662f\u4e00\u9053\u4ea4\u4e92\u9898\n\n\u6709\u4e00\u68f5\u9ad8\u5ea6\u4e3a$h$\u7684\u6709\u6839\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u70b9\u7684\u7f16\u53f7\u4ece$1$\u5230$2^h-1$\u3002\u6bcf\u4e00\u6b21\u4f60\u53ef\u4ee5\u8be2\u95ee\u67d0\u4e00\u4e2a\u70b9\u5728\u6811\u4e0a\u7684\u90bb\u5c45\uff0c\u73b0\u5728\u8bf7\u4f60\u4f7f\u7528\u4e0d\u8d85\u8fc7$16$\u6b21\u8be2\u95ee\u627e\u5230\u6811\u6839\u3002\n\n\u8f93\u5165\u6570\u636e\n\n\u7b2c\u4e00\u884c\u4e00\u4e2a\u6b63\u6574\u6570$t(1 \\leq t \\leq 500)$\u8868\u793a\u6570\u636e\u7ec4\u6570\n\n\u63a5\u4e0b\u6765\u5728\u6bcf\u4e00\u7ec4\u6570\u636e\u7684\u4ea4\u4e92\u5f00\u59cb\u4e4b\u524d\u4f1a\u7ed9\u51fa\u6811\u9ad8$h(2 \\leq h \\leq 7)$\n\n\u4ea4\u4e92\u5b9e\u73b0\n\n\u6bcf\u4e00\u4e2a\u8be2\u95ee\u8f93\u51fa\u683c\u5f0f\u4e3a\uff1a\u201c\uff1f $x$\u201d\uff08\u4e0d\u5e26\u5f15\u53f7\uff09\u8868\u793a\u8be2\u95ee\u70b9$x$\u7684\u90bb\u5c45\u3002\u8f93\u51fa\u4e4b\u540e$flush$\u4f60\u7684\u8f93\u51fa\u5e76\u4ece\u6807\u51c6\u8f93\u5165\u4e2d\u8f93\u5165\u8be2\u95ee\u7684\u7b54\u6848\n\n\u8be2\u95ee\u7684\u7b54\u6848\u5305\u62ec\u4e24\u884c\uff1a\u7b2c\u4e00\u884c\u4e00\u4e2a\u6574\u6570$k(1 \\leq k \\leq 3)$\u8868\u793a\u70b9$x$\u7684\u90bb\u5c45\u4e2a\u6570\uff0c\u7b2c\u4e8c\u884c$k$\u4e2a\u6574\u6570\u8868\u793a$x$\u7684\u90bb\u5c45\u3002\n\n\u5728\u4e0d\u8d85\u8fc7$16$\u6b21\u8be2\u95ee\u4e4b\u540e\uff0c\u4f60\u9700\u8981\u8f93\u51fa\"! $y$\"\uff08\u4e0d\u5305\u542b\u5f15\u53f7\uff09\u8868\u793a\u4f60\u627e\u5230\u7684\u6811\u6839\u4e3a$y$\u53f7\u8282\u70b9\uff0c\u8f93\u51fa\u4e00\u4e2a\u6362\u884c\uff0c\u7136\u540e$flush$\u4f60\u7684\u8f93\u51fa\u3002\n\n\u5982\u679c\u4f60\u9700\u8981$flush$\u8f93\u51fa\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u51fd\u6570\uff1a\n\n\u5bf9\u4e8eC++\uff0c\u4f7f\u7528fflush(stdout);\n\n\u5bf9\u4e8eJava\uff0c\u4f7f\u7528System.out.flush();\n\n\u5bf9\u4e8ePython\u4f7f\u7528stdout.flush();\n\n\u5bf9\u4e8ePascal\u4f7f\u7528flush(output);\n\n\u5bf9\u4e8e\u5176\u4ed6\u8bed\u8a00\u53c2\u89c1\u5bf9\u5e94\u8bed\u8a00\u7684\u51fd\u6570\u58f0\u660e\n\n\u5982\u679c\u8f93\u5165\u4e2d\u51fa\u73b0\u4e86$h=0$\u6216\u8005$k=0$\u7684\u60c5\u51b5\uff0c\u8868\u793a\u4ea4\u4e92\u7a0b\u5e8f\u8f93\u5165\u4e86\u975e\u6cd5\u6570\u636e\uff0c\u5df2\u7ecf\u65e0\u6cd5\u7ee7\u7eed\u8fdb\u884c\u4ea4\u4e92\uff0c\u6b64\u65f6\u8bf7\u7acb\u5373\u7ed3\u675f\u7a0b\u5e8f\uff0c\u5426\u5219\u4f60\u7684\u7a0b\u5e8f\u7ed3\u679c\u4f1a\u662f\u4e0d\u53ef\u9884\u6599\u7684\u7ed3\u679c\uff08\u53cd\u6b63\u4e0d\u4f1a\u662fAC\uff09\u3002\n\n"
}