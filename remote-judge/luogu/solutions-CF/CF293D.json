[
    {
        "content": "# \u9898\u76ee\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[$luogu$](https://www.luogu.org/problem/CF293D).\n# \u9898\u89e3\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~\u5b8c\u5168\u4e0d\u4f1a\u8ba1\u7b97\u51e0\u4f55\u7684\u83dc\u9e21\u5728\u7ebf\u778e\u641e\u659c\u7387.~~\n## \u9898\u610f\n>\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5728\u4e00\u4e2a\u51f8\u5305\u5185\u9009\u62e9\u4e24\u4e2a\u70b9, \u6c42\u4ee5\u4e24\u70b9\u8fde\u7ebf\u4e3a\u5bf9\u89d2\u7ebf\u7684\u6b63\u65b9\u5f62\u7684\u671f\u671b\u9762\u79ef.\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5b9e\u9645\u4e0a, \u53d6\u5230\u6bcf\u4e00\u4e2a\u65e0\u5e8f\u70b9\u5bf9\u7684\u6982\u7387\u90fd\u662f\u76f8\u7b49\u7684, \u6211\u4eec\u7684\u76ee\u6807\u5c31\u53d8\u6210\u4e86**\u6c42\u6240\u6709\u8fd9\u6837\u7684\u6b63\u65b9\u5f62\u7684\u9762\u79ef\u603b\u548c**. \u4f46\u663e\u7136, \u6211\u4eec\u4e0d\u80fd\u679a\u4e3e\u70b9\u5bf9, \u9700\u8981\u5bf9\u5176\u4f18\u5316.\n## \u4f18\u5316\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u9996\u5148, \u5bf9\u4e8e\u4e00\u4e2a\u5bf9\u89d2\u7ebf\u957f\u5ea6\u4e3a$d$\u7684\u6b63\u65b9\u5f62, \u5176\u9762\u79ef$S=\\frac{d^2}2$. \u518d\u5728\u5750\u6807\u7cfb\u4e0a\u8003\u8651\u4e24\u70b9$A(x_1,y_1),B(x_2,y_2)$, \u4ee5$AB$\u4e3a\u5bf9\u89d2\u7ebf\u7684\u6b63\u65b9\u5f62\u9762\u79ef:  \n$$S=\\frac{dist(A,B)}2=\\frac{1}2[(x_1-x_2)^2+(y_1-y_2)^2]$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8bbe\u51f8\u5305\u5185\u6574\u70b9\u96c6\u5408$S$, \u6211\u4eec\u5c31\u9700\u8981\u6c42:  \n$$Ans=\\frac{1}2\\sum_{A(x_1,y_1),B(x_2,y_2)\\in S}(x_1-x_2)^2+(y_1-y_2)^2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u663e\u7136, \u6211\u4eec\u53ef\u4ee5\u5c06\u548c\u5f0f\u4e2d\u7684\u524d\u540e\u4e24\u9879\u5206\u522b\u8ba1\u7b97. \u5728\u6b64\u53ea\u8003\u8651\u5bf9\u524d\u4e00\u9879\u7684\u6c42\u548c, \u8bbe\u4e3a$A$, \u5373:\n$$A=\\sum_{(x_1,x_2)}(x_1-x_2)^2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5c55\u5f00\u5e73\u65b9:\n$$A=\\sum_{(x_1,x_2)}x_1^2-2x_1x_2+x_2^2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5728\u6c42\u548c\u610f\u4e49\u4e0b, \u4e00\u4e09\u9879\u662f\u7b49\u4ef7\u7684, \u6240\u4ee5:\n$$A=2\\sum_{(x_1,x_2)}x^2-2\\sum_{(x_1,x_2)}x_1x_2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u5728\u51f8\u5305\u5185, \u5b58\u5728\u8bb8\u591a\u5728\u4e00\u5217\u4e0a\u7684\u6574\u70b9, \u5b83\u4eec\u7684$x$\u662f\u76f8\u7b49\u7684, \u6211\u4eec\u53ef\u4ee5\u501f\u6b64\u4f18\u5316. \u5bf9\u4e8e\u6bcf\u4e2a$x_0$, \u7ef4\u62a4$cntx(x_0)$\u8868\u793a**\u5728\u7ad6\u76f4\u76f4\u7ebf$y=x_0$\u4e0a\u7684\u6574\u70b9\u4e2a\u6570**. \u4e8e\u662f:\n$$A=2|S|\\sum_xcntx(x)x^2-2(\\sum_xcntx(x)x)^2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u540c\u7406, \u8bbe$B$\u4e3a\u540e\u4e00\u9879\u6c42\u548c, \u5219\u5e94\u6709:\n$$B=2|S|\\sum_ycnty(y)y^2-2(\\sum_ycnty(y)y)^2$$\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u679a\u4e3e$x$\u6216$y$, $O(2\\times10^6)$\u662f\u80fd\u591f\u63a5\u53d7\u7684, \u63a5\u4e0b\u6765\u6211\u4eec\u8ba8\u8bba\u5982\u4f55\u6c42$cntx$\u4e0e$cnty$.\n### $cnty(y)$:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8981\u6c42\u51f8\u5305\u5185\u7eb5\u5750\u6807\u4e3a$y$\u7684\u6574\u70b9\u4e2a\u6570, \u53ea\u9700\u8981\u6c42\u51fa\u5de6\u53f3\u4e24\u4fa7\u7684\u70b9\u7684\u6a2a\u5750\u6807\u5373\u53ef. \u8003\u8651\u628a\u4e00\u4e2a\u51f8\u5305\u6309\u6700\u9ad8\u70b9\u4e0e\u6700\u4f4e\u70b9\u7684\u8fde\u7ebf\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206, \u5982\u56fe:  \n![tmp1.png](https://i.loli.net/2019/10/25/ojOKpCDm4zsx8cE.png)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4f9d\u6b21\u679a\u4e3e$y$, \u5e76\u7ef4\u62a4$y$\u503c\u6240\u4ea4\u5de6\u4fa7\u51f8\u5305\u7684\u8fb9\u7684\u4e0a\u4e0b\u4e24\u70b9, \u6240\u4ea4\u53f3\u4fa7\u51f8\u5305\u7684\u4e0a\u4e0b\u4e24\u70b9, \u66b4\u529b\u89e3\u89e3\u65b9\u7a0b, \u5f97\u5230\u4ea4\u70b9\u548c\u5750\u6807, \u5728\u68c0\u67e5\u8be5\u70b9\u9644\u8fd1\u7684\u6574\u70b9\u5373\u53ef. ( \u6ce8\u610f\u8fd9\u91cc\u4e0d\u80fd\u76f4\u63a5\u4e0a\u53d6\u6574\u6216\u8005\u4e0b\u53d6\u6574, \u65e0\u826f$CF$\u4f1a\u5361\u7cbe\u5ea6. )\n### $cntx(x)$:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u540c\u7406, \u6309\u6700\u5de6\u4fa7\u70b9\u4e0e\u6700\u53f3\u4fa7\u70b9\u5c06\u51f8\u5305\u5206\u4e3a\u4e0a\u4e0b\u4e24\u90e8\u5206, \u679a\u4e3e$x$, \u7ef4\u62a4$x$\u503c\u6240\u4ea4\u4e0a\u4fa7\u51f8\u5305\u7684\u8fb9\u7684\u5de6\u53f3\u4e24\u70b9, \u6240\u4ea4\u4e0b\u4fa7\u51f8\u5305\u7684\u5de6\u53f3\u4e24\u70b9, \u89e3\u65b9\u7a0b, \u68c0\u67e5\u9644\u8fd1\u7684\u6574\u70b9\u5373\u53ef.\n## \u4ee3\u7801\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;~~\u53c8\u81ed\u53c8\u957f\u53c8\u6162\u7684\u5178\u8303.~~  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u4e0d\u8fc7\u5929\u751f\u52b1\u5fd7\u9632\u6284\u88ad ( \u6ed1\u7a3d ).\n```cpp\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n\n#define Int register int\n\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n\tPoint () {}\n\tPoint ( const int _x, const int _y ): x ( _x ), y ( _y ) {}\n\tinline void Input () { scanf ( \"%d %d\", &x, &y ); }\n\tinline void Print () { printf ( \"( %d, %d )\", x, y ); }\n\tinline Point Symmetric () { return { y, x }; }\n\tfriend inline bool operator != ( const Point p, const Point q ) { return p.x ^ q.x || p.y ^ q.y; }\n};\n\nconst int MAXN = 1e5, INF = 0x3f3f3f3f, MAXX = 1e6, EPS = 1e-7;\nint n, Cntri, Cntle, Cnthi, Cntlo, Cnty[2 * MAXX + 5] = {}, Cntx[2 * MAXX + 5] = {};\nPoint p[MAXN + 5] = {}, Highest ( 0, -INF ), Lowest ( 0, INF ), Leftest ( INF, 0 ), Rightest ( -INF, 0 );\nPoint LeftP[MAXN + 5] = {}, RightP[MAXN + 5] = {}, HighP[MAXN + 5] = {}, LowP[MAXN + 5] = {};\n\ninline bool Cmp1 ( const Point p, const Point q ) {\n\treturn p.x < q.x;\n}\n\ninline bool Cmp2 ( const Point p, const Point q ) {\n\treturn p.y > q.y;\n}\n\ninline bool Collinear ( const Point p, const Point q, const Point r ) {\n\tif ( p.x == q.x ) return p.x == r.x;\n\tif ( p.x == r.x ) return p.x == q.x;\n\treturn 1LL * ( p.y - q.y ) * ( p.x - r.x ) == 1LL * ( p.y - r.y ) * ( p.x - q.x );\n}\n\ntemplate<typename _T>\ninline _T Abs ( const _T x ) { return x < 0 ? -x : x; }\n\ntemplate<class _T>\ninline void Swap ( _T& a, _T& b ) { _T t = a; a = b, b = t; }\n\ninline int Indx ( const int x ) { return x + MAXX; }\n\ninline bool LeftCheck ( const Point p, Point _up, Point _dn ) {\n\tif ( _up.y < _dn.y ) Swap ( _up, _dn );\n\tif ( _up.x == _dn.x ) return p.x < _up.x;\n\tif ( p.x == _dn.x ) return ! ( ( _up.y - _dn.y >= 0 ) ^ ( _up.x - _dn.x >= 0 ) );\n\tif ( p.x == _up.x ) return ( _up.y - _dn.y >= 0 ) ^ ( _up.x - _dn.x >= 0 );\n\tif ( ( _up.y - _dn.y >= 0 ) ^ ( _up.x - _dn.x >= 0 ) ) {\n\t\treturn 1LL * ( p.y - _dn.y ) * ( _up.x - _dn.x ) > 1LL * ( _up.y - _dn.y ) * ( p.x - _dn.x );\n\t} else {\n\t\treturn ( ( p.y - _dn.y >= 0 ) ^ ( p.x - _dn.x >= 0 ) )\n\t\t\t|| 1LL * ( p.y - _dn.y ) * ( _up.x - _dn.x ) > 1LL * ( _up.y - _dn.y ) * ( p.x - _dn.x );\n\t}\n}\n\ninline void PrepareX () {\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tif ( p[i] != Highest && p[i] != Lowest ) {\n\t\t\tif ( ! LeftCheck ( p[i], Highest, Lowest ) ) {\n\t\t\t\tRightP[++ Cntri] = p[i];\n\t\t\t} else {\n\t\t\t\tLeftP[++ Cntle] = p[i];\n\t\t\t}\n\t\t}\n\t}\n\tint rupper = 1, lupper = 1;\n\tsort ( RightP + 1, RightP + Cntri + 1, Cmp2 ), sort ( LeftP + 1, LeftP + Cntle + 1, Cmp2 );\n\tif ( ! Cntri || RightP[1].y ^ Highest.y ) RightP[-- rupper] = Highest;\n\tif ( ! Cntle || LeftP[1].y ^ Highest.y ) LeftP[-- lupper] = Highest;\n\tif ( RightP[Cntri].y ^ Lowest.y ) RightP[++ Cntri] = Lowest;\n\tif ( LeftP[Cntle].y ^ Lowest.y ) LeftP[++ Cntle] = Lowest;\n\tfor ( Int y = Highest.y - 1; y > Lowest.y; -- y ) {\n\t\tif ( y < RightP[rupper + 1].y ) ++ rupper;\n\t\tif ( y < LeftP[lupper + 1].y ) ++ lupper;\n\t\tPoint _up = LeftP[lupper], _dn = LeftP[lupper + 1];\n\t\tint lx, rx, Choice[5] = {}; double JuncX;\n\t\tif ( _up.x == _dn.x ) {\n\t\t\tlx = ceil ( _up.x );\n\t\t} else if ( y == _dn.y ) {\n\t\t\tlx = _dn.x;\n\t\t} else {\n\t\t\tJuncX = 1.0 * ( _up.x - _dn.x )\n\t\t\t\t\t\t* ( y - _dn.y + 1.0 * ( _up.y - _dn.y ) * _dn.x / ( _up.x - _dn.x ) ) / ( _up.y - _dn.y );\n\t\t\tChoice[2] = ( Choice[1] = floor ( JuncX ) - 1 ) + 1, Choice[4] = ( Choice[3] = ceil ( JuncX ) ) + 1;\n\t\t\tfor ( Int i = 1; i <= 4; ++ i ) {\n\t\t\t\tif ( Collinear ( { Choice[i], y }, _up, _dn ) ) {\n\t\t\t\t\tlx = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( ! LeftCheck ( { Choice[i], y }, _up, _dn ) ) {\n\t\t\t\t\tlx = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_up = RightP[rupper], _dn = RightP[rupper + 1];\n\t\tif ( _up.x == _dn.x ) {\n\t\t\trx = floor ( _up.x );\n\t\t} else if ( y == _dn.y ) {\n\t\t\trx = _dn.x;\n\t\t} else {\n\t\t\tJuncX = 1.0 * ( _up.x - _dn.x )\n\t\t\t\t\t\t* ( y - _dn.y + 1.0 * ( _up.y - _dn.y ) * _dn.x / ( _up.x - _dn.x ) ) / ( _up.y - _dn.y );\n\t\t\tChoice[2] = ( Choice[1] = ceil ( JuncX ) + 1 ) - 1, Choice[4] = ( Choice[3] = floor ( JuncX ) ) - 1;\n\t\t\tfor ( Int i = 1; i <= 4; ++ i ) {\n\t\t\t\tif ( Collinear ( { Choice[i], y }, _up, _dn ) ) {\n\t\t\t\t\trx = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( LeftCheck ( { Choice[i], y }, _up, _dn ) ) {\n\t\t\t\t\trx = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCnty[Indx ( y )] = rx - lx + 1;\n\t}\n}\n\ninline void PrepareY () {\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tif ( p[i] != Leftest && p[i] != Rightest ) {\n\t\t\tif ( LeftCheck ( p[i].Symmetric (), Rightest.Symmetric (), Leftest.Symmetric () ) ) {\n\t\t\t\tLowP[++ Cntlo] = p[i];\n\t\t\t} else {\n\t\t\t\tHighP[++ Cnthi] = p[i];\n\t\t\t}\n\t\t}\n\t}\n\tint uleft = 1, dleft = 1;\n\tsort ( HighP + 1, HighP + Cnthi + 1, Cmp1 ), sort ( LowP + 1, LowP + Cntlo + 1, Cmp1 );\n\tif ( ! Cnthi || HighP[1].x ^ Leftest.x ) HighP[-- uleft] = Leftest;\n\tif ( ! Cntlo || LowP[1].x ^ Leftest.x ) LowP[-- dleft] = Leftest;\n\tif ( HighP[Cnthi].x ^ Rightest.x ) HighP[++ Cnthi] = Rightest;\n\tif ( LowP[Cntlo].x ^ Rightest.x ) LowP[++ Cntlo] = Rightest;\n\tfor ( Int x = Leftest.x + 1; x < Rightest.x; ++ x ) {\n\t\tif ( x > HighP[uleft + 1].x ) ++ uleft;\n\t\tif ( x > LowP[dleft + 1].x ) ++ dleft;\n\t\tPoint _le = HighP[uleft], _ri = HighP[uleft + 1];\n\t\tint uy = 0, dy = 0, Choice[5] = {}; double JuncY;\n\t\tif ( _le.y == _ri.y ) {\n\t\t\tuy = floor ( _le.y );\n\t\t} else if ( x == _ri.x ) {\n\t\t\tuy = _ri.y;\n\t\t} else {\n\t\t\tJuncY = _le.y + 1.0 * ( _ri.y - _le.y ) / ( _ri.x - _le.x ) * ( x - _le.x );\n\t\t\tChoice[2] = ( Choice[1] = ceil ( JuncY ) + 1 ) - 1, Choice[4] = ( Choice[3] = floor ( JuncY ) ) - 1;\n\t\t\tfor ( Int i = 1; i <= 4; ++ i ) {\n\t\t\t\tif ( Collinear ( { x, Choice[i] }, _le, _ri ) ) {\n\t\t\t\t\tuy = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( LeftCheck ( Point ( x, Choice[i] ).Symmetric (), _le.Symmetric (), _ri.Symmetric () ) ) {\n\t\t\t\t\tuy = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_le = LowP[dleft], _ri = LowP[dleft + 1];\n\t\tif ( _le.y == _ri.y ) {\n\t\t\tdy = ceil ( _le.y );\n\t\t} else if ( x == _ri.x ) {\n\t\t\tdy = _ri.y;\n\t\t} else {\n\t\t\tJuncY = _le.y + 1.0 * ( _ri.y - _le.y ) / ( _ri.x - _le.x ) * ( x - _le.x );\n\t\t\tChoice[2] = ( Choice[1] = floor ( JuncY ) - 1 ) + 1, Choice[4] = ( Choice[3] = ceil ( JuncY ) ) + 1;\n\t\t\tfor ( Int i = 1; i <= 4; ++ i ) {\n\t\t\t\tif ( Collinear ( { x, Choice[i] }, _le, _ri ) ) {\n\t\t\t\t\tdy = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t} else if ( ! LeftCheck ( Point ( x, Choice[i] ).Symmetric (), _le.Symmetric (), _ri.Symmetric () ) ) {\n\t\t\t\t\tdy = Choice[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tCntx[Indx ( x )] = uy - dy + 1;\n\t}\n}\n\ninline void Work () {\n\tscanf ( \"%d\", &n );\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tp[i].Input ();\n\t\tif ( p[i].y > Highest.y ) {\n\t\t\tCnty[Indx ( p[i].y )] = 1;\n\t\t\tHighest = p[i];\n\t\t} else if ( p[i].y == Highest.y ) {\n\t\t\tCnty[Indx ( p[i].y )] = Abs ( p[i].x - Highest.x ) + 1;\n\t\t}\n\t\tif ( p[i].y < Lowest.y ) {\n\t\t\tCnty[Indx ( p[i].y )] = 1;\n\t\t\tLowest = p[i];\n\t\t} else if ( p[i].y == Lowest.y ) {\n\t\t\tCnty[Indx ( p[i].y )] = Abs ( p[i].x - Lowest.x ) + 1;\n\t\t}\n\t\tif ( p[i].x < Leftest.x ) {\n\t\t\tCntx[Indx ( p[i].x )] = 1;\n\t\t\tLeftest = p[i];\n\t\t} else if ( p[i].x == Leftest.x ) {\n\t\t\tCntx[Indx ( p[i].x )] = Abs ( p[i].y - Leftest.y ) + 1;\n\t\t}\n\t\tif ( p[i].x > Rightest.x ) {\n\t\t\tCntx[Indx ( p[i].x )] = 1;\n\t\t\tRightest = p[i];\n\t\t} else if ( p[i].x == Rightest.x ) {\n\t\t\tCntx[Indx ( p[i].x )] = Abs ( p[i].y - Rightest.y ) + 1;\n\t\t}\n\t}\n\tPrepareX ();\n\tPrepareY ();\n\tdouble ResX = 0.0, ResY = 0.0, PointCnt = 0.0;\n\tdouble Sqrx = 0.0, Sumx = 0.0;\n\tfor ( Int x = Leftest.x; x <= Rightest.x; ++ x ) {\n\t\tPointCnt += Cntx[Indx ( x )];\n\t}\n\tfor ( Int x = Leftest.x; x <= Rightest.x; ++ x ) {\n\t\tSqrx += 0.5 * Cntx[Indx ( x )] * x * x;\n\t\tSumx += 0.5 * Cntx[Indx ( x )] * x;\n\t}\n\tResX = Sqrx * PointCnt - Sumx * Sumx * 2.0;\n\tdouble Sqry = 0.0, Sumy = 0.0;\n\tfor ( Int y = Highest.y; y >= Lowest.y; -- y ) {\n\t\tSqry += 0.5 * Cnty[Indx ( y )] * y * y;\n\t\tSumy += 0.5 * Cnty[Indx ( y )] * y;\n\t}\n\tResY = Sqry * PointCnt - Sumy * Sumy * 2.0;\n\tprintf ( \"%.10lf\\n\", ( ResX + ResY ) / PointCnt / ( PointCnt - 1.0 ) * 2.0 );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n```",
        "postTime": 1571981341,
        "uid": 123807,
        "name": "Rainybunny",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF293D \u3010Ksusha and Square\u3011"
    }
]