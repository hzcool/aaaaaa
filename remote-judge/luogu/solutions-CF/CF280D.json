[
    {
        "content": "\u56e0\u4e3a$k$\u6bd4\u8f83\u5c0f\uff0c\u53ef\u4ee5\u8003\u8651\u4f7f\u7528\u8d39\u7528\u6d41\u7684\u6a21\u578b\u3002\u6e90\u70b9$S$\u5411\u6bcf\u4e2a\u70b9$i$\u8fde\u4e00\u6761\u6d41\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\uff1b$i$\u5411$i+1$\u8fde\u4e00\u6761\u8d39\u7528\u4e3a$a_i$\uff0c\u6d41\u91cf\u4e3a$1$\u7684\u8fb9\uff1b$i$\u5411\u6c47\u70b9$T$\u8fde\u6d41\u91cf\u4e3a$1$\uff0c\u8d39\u7528\u4e3a$0$\u7684\u8fb9\u3002\u90a3\u4e48\uff0c\u4e00\u6ef4\u4ece$S>i>j>T$\u7684\u6d41\uff0c\u4ee3\u8868\u9009\u53d6\u533a\u95f4$[i,j-1]$\u3002\u53ef\u4ee5\u53d1\u73b0\u7684\u662f\uff0c\u6bcf\u591a\u6d41\u4e00\u6ef4\u6d41\u91cf\uff0c\u5c31\u591a\u4e00\u4e2a\u533a\u95f4\u3002\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u4f7f\u7528\u4e0d\u591a\u4e8e$k$\u6ef4\u6d41\u91cf\uff0c\u80fd\u5f97\u5230\u7684\u6700\u5927\u8d39\u7528\u3002\u56e0\u4e3a\u6bcf\u6b21\u589e\u5e7f\u53ea\u4f1a\u591a\u4e00\u70b9\u6d41\u91cf\uff0c\u800c\u6bcf\u6b21\u8981\u67e5\u8be2\u7684\u6700\u957f\u8def\u5c31\u662f\u6bcf\u6b21\u589e\u5e7f\u7684\u8d21\u732e\uff0c\u8fd9\u4e2a\u8d21\u732e\u662f\u7531\u4e00\u6bb5\u533a\u95f4\u6784\u6210\u3002\n\n**\u6240\u4ee5\uff0c\u6bcf\u6b21\u589e\u5e7f\u76f8\u5f53\u4e8e\u627e\u5230\u8be2\u95ee\u533a\u95f4\u7684\u6700\u5927\u5b50\u533a\u95f4\u548c\uff0c\u7136\u540e\u518d\u628a\u8be5\u533a\u95f4\u53d6\u53cd\uff08\u53cd\u5411\u5f27\u7684\u8d39\u7528\u662f\u6b63\u5411\u5f27\u7684\u76f8\u53cd\u6570\uff09\u3002**\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u5982\u679c\u7b2c\u4e00\u6b21\u9009\u4e86\u533a\u95f4$[1,4]$\uff0c\u7136\u540e\u53d6\u53cd\u540e\u53d6\u4e86\u533a\u95f4$[3,6]$\uff0c\u6b64\u65f6\u76f8\u5f53\u4e8e\u53d6\u4e86\u533a\u95f4$[1,2]$\u548c$[5,6]$\u3002**\u589e\u5e7f\u5b8c$k$\u6b21\uff0c\u6216\u8005\u589e\u5e7f\u8d21\u732e\u5c0f\u4e8e$0$\u65f6\uff0c\u5c31\u5f97\u5230\u4e86\u7b54\u6848\u3002**\n\n\u56e0\u4e3a\u4e0d\u53ef\u80fd\u540c\u65f6\u9009\u5171\u8d77\u70b9\u6216\u5171\u7ec8\u70b9\u7684\u533a\u95f4\uff0c\u5047\u5982\u6211\u4eec\u7b2c\u4e00\u6b21\u53d6\u4e86$[1,4]$\uff0c\u90a3\u4e48\u4e00\u5b9a\u4e0d\u53ef\u80fd\u53d6\u53cd\u7b2c\u4e8c\u6b21\u540e\u4f1a\u53d6$[1,5]$\uff0c\u8fd9\u6837\u5f97\u5230\u7684\u533a\u95f4\u662f$[4,5]$\uff0c\u56e0\u4e3a\u6211\u4eec\u4fdd\u8bc1\u6bcf\u6b21\u589e\u5e7f\u7684\u8d21\u732e\u5927\u4e8e\u7b49\u4e8e$0$\uff0c\u8fd9\u4e2a\u533a\u95f4\u662f\u6bd4$[1,4]$\u5927\u7684\uff0c\u4e0e\u4e00\u5f00\u59cb\u5c31\u53d6\u6700\u5927\u5b50\u533a\u95f4\u77db\u76fe\u3002\u6240\u4ee5\u6bcf\u6b21\u589e\u5e7f\u5fc5\u7136\u4f1a\u589e\u52a0\u4e00\u4e2a\u533a\u95f4\u3002\n\n\u73b0\u5728\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\uff0c\u76f8\u5f53\u4e8e\u7ef4\u62a4\u4e00\u4e2a\u6700\u5927\u5b50\u533a\u95f4\u503c\uff0c\u5f53\u7136\uff0c\u540c\u65f6\u80af\u5b9a\u8981\u7ef4\u62a4\u6700\u5927\u5de6\u533a\u95f4\u548c\u4e0e\u6700\u5927\u53f3\u533a\u95f4\u548c\u533a\u95f4\u548c\uff0c\u5355\u70b9\u4fee\u6539\u5c31\u4e0d\u7528$lazy$\u4e86\uff0c\u4e0d\u7136\u771f\u7684\u592a\u6bd2\u7624\u4e86\u3002\u5f53\u7136\uff0c\u7531\u4e8e\u6709\u53cd\u8f6c\u64cd\u4f5c\uff0c\u8fd8\u9700\u8981\u7ef4\u62a4\u6700\u5c0f\u7684\u5b50\u533a\u95f4\u548c\uff0c\u53cd\u8f6c\u65f6$swap$\u4e00\u4e0b\u5c31\u597d\uff0c\u6253\u4e0a\u53cd\u8f6c\u6807\u8bb0\u3002\n\u5b9a\u4e49\u4e00\u4e2a\u533a\u95f4\u7c7b\u578b\u53ca\u4f7f\u7528\u91cd\u8f7d\u8fd0\u7b97\u7b26\u6765\u5904\u7406\u533a\u95f4\u52a0\u53ef\u4ee5\u51cf\u5c11\u4ee3\u7801\u91cf\u3002\n\n\u4ee3\u7801\uff1a\n```\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n\nconst int maxn=1e5+7;\n\nusing namespace std;\n\nint n,m,x,op,y,k;\n\nstruct rec{\n    int l,r,s;\n};\n\nrec operator + (rec x,rec y)\n{\n    return (rec){x.l,y.r,x.s+y.s};\n}\n\nbool operator < (rec x,rec y)\n{\n    return x.s<y.s;\n}\n\nstruct node{\n    rec smax,smin,lmax,rmax,lmin,rmin,sum;\n    int rev;\n}t[maxn*4];\n\nqueue <node> q;\n\nvoid neww(int p,int l,int k)\n{\n    t[p].smax=(rec){l,l,k};\n    t[p].lmax=(rec){l,l,k};\n    t[p].rmax=(rec){l,l,k};\n    t[p].smin=(rec){l,l,k};\n    t[p].lmin=(rec){l,l,k};\n    t[p].rmin=(rec){l,l,k};\n    t[p].sum=(rec){l,l,k};\n}\n\nnode merge(node x,node y)\n{\n    node z;\n    z.smax=max(x.smax,y.smax);\n    z.smax=max(z.smax,x.rmax+y.lmax);\n    z.smin=min(x.smin,y.smin);\n    z.smin=min(z.smin,x.rmin+y.lmin);\n    z.lmax=max(x.lmax,x.sum+y.lmax);\n    z.rmax=max(y.rmax,x.rmax+y.sum);\n    z.lmin=min(x.lmin,x.sum+y.lmin);\n    z.rmin=min(y.rmin,x.rmin+y.sum);\n    z.sum=x.sum+y.sum;\n    z.rev=0;\n    return z;\n}\n\nvoid clean(int p)\n{\n    swap(t[p].smax,t[p].smin);\n    swap(t[p].lmax,t[p].lmin);\n    swap(t[p].rmax,t[p].rmin);\n    t[p].smax.s*=-1;\n    t[p].smin.s*=-1;\n    t[p].lmax.s*=-1;\n    t[p].lmin.s*=-1;\n    t[p].rmax.s*=-1;\n    t[p].rmin.s*=-1;\n    t[p].sum.s*=-1;\n    t[p].rev^=1;\n}\n\nvoid change(int p,int l,int r,int x,int k)\n{\t\n    if (l==r)\n    {\n        neww(p,l,k);\n        return;\n    }\n    int mid=(l+r)/2;\n    if (t[p].rev)\n    {\n        clean(p*2);\n        clean(p*2+1);\n        t[p].rev^=1;\n    }\n    if (x<=mid) change(p*2,l,mid,x,k);\n           else change(p*2+1,mid+1,r,x,k);\n    t[p]=merge(t[p*2],t[p*2+1]);\n}\n\nvoid rev(int p,int l,int r,int x,int y)\n{\n    if ((l==x) && (r==y))\n    {\n        clean(p);\n        return;\n    }\n    int mid=(l+r)/2;\n    if (t[p].rev)\n    {\n        clean(p*2);\n        clean(p*2+1);\n        t[p].rev^=1;\n    }\n    if (y<=mid) rev(p*2,l,mid,x,y);\n    else if (x>mid) rev(p*2+1,mid+1,r,x,y);\n    else\n    {\n        rev(p*2,l,mid,x,mid);\n        rev(p*2+1,mid+1,r,mid+1,y);\n    }\n    t[p]=merge(t[p*2],t[p*2+1]);\n}\n\nnode query(int p,int l,int r,int x,int y)\n{\n    if ((l==x) && (r==y)) return t[p];\n    int mid=(l+r)/2;\n    if (t[p].rev)\n    {\n        clean(p*2);\n        clean(p*2+1);\n        t[p].rev^=1;\n    }\n    if (y<=mid) return query(p*2,l,mid,x,y);\n    else if (x>mid) return query(p*2+1,mid+1,r,x,y);\n    else\n    {\n        return merge(query(p*2,l,mid,x,mid),query(p*2+1,mid+1,r,mid+1,y));\n    }\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\t\t\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&x);\n        change(1,1,n,i,x);\n    }\t\n    scanf(\"%d\",&m);\t\t\n    for (int i=1;i<=m;i++)\n    {\n        scanf(\"%d\",&op);\t\t\n        if (op==0)\n        {\n            scanf(\"%d%d\",&x,&k);\n            change(1,1,n,x,k);\n        }\n        else\n        {\n            scanf(\"%d%d%d\",&x,&y,&k);\t\t\t\n            int ans=0;\t\t\t\n            while (k--)\n            {\t\t\t\n                node d=query(1,1,n,x,y);\n                if (d.smax.s<0) break;\n                ans+=d.smax.s;\n                rev(1,1,n,d.smax.l,d.smax.r);\n                q.push(d);\n            }\n            printf(\"%d\\n\",ans);\n            while (!q.empty())\n            {\n                node d=q.front();\n                q.pop();\n                rev(1,1,n,d.smax.l,d.smax.r);\n            }\n        }\n    }\n} \n```",
        "postTime": 1533196860,
        "uid": 18895,
        "name": "liangzihao",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "## \u9898\u610f\uff1a\n\u957f\u5ea6\u4e3a$n$\u7684\u6570\u5217\uff0c\u652f\u6301\u4e24\u79cd\u64cd\u4f5c\uff1a\n\n1.\u4fee\u6539\u67d0\u4e2a\u4f4d\u7f6e\u7684\u503c\n\n2.\u8be2\u95ee\u533a\u95f4$[l,r]$\u91cc\u9009\u51fa\u81f3\u591a$k$\u4e2a\u4e0d\u76f8\u4ea4\u7684\n\u5b50\u6bb5\u548c\u7684\u6700\u5927\u503c\u3002\n\n\u4e00\u5171\u6709$m$\u4e2a\u64cd\u4f5c\n\n## \u9898\u89e3\uff1a\u7ebf\u6bb5\u6811+\u5806\n\n\u5f53k=1\u662f\u7b54\u6848\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\n\n\u5f53k=2\u662f\u7b54\u6848\u5c31\u6709\u4e24\u79cd\u60c5\u51b5\u4e86\uff1a\n\n1:\u6700\u5927\u5b50\u6bb5\u548c+\u4e0d\u76f8\u4ea4\u7684\u6b21\u5927\u5b50\u6bb5\u548c\n\n2:\u6700\u5927\u5b50\u6bb5\u548c-\u6700\u5927\u5b50\u6bb5\u548c\u533a\u95f4\u7684\u6700\u5c0f\u5b50\u6bb5\u548c\n\uff08\u5176\u5b9e\u5c31\u662f\u628a\u6700\u5927\u5b50\u6bb5\u548c\u5206\u6210\u4e24\u90e8\u5206\uff09\n\n\u6211\u4eec\u5c31\u60f3\u5230\u50cf\u8d85\u7ea7\u94a2\u7434\u4e00\u6837\uff0c\u9009\u51fa\u4e00\u6bb5$[l,r]$,\u5c31\u52a0\u5165$[L,l-1]$,$[r+1,R]$\n\n\u6bd4\u5982\u6211\u4eec\u5728\u533a\u95f4$[L,R]$\u4e2d\u627e\u5230\u6700\u5927\u5b50\u6bb5\u548c$[l,r]$,\u90a3\u4e48\u6211\u4eec\u5c31\u8981\u628a$[L,l-1]$,$[r+1,R]$\u7684\u6700\u5927\u5b50\u6bb5\u548c\u5df2\u4ee5\u53ca$[l,r]$\u7684\u6700\u5c0f\u5b50\u6bb5\u548c\u52a0\u5165\u5806\u4e2d\n\n\u5982\u679c\u662f\u6700\u5c0f\u5b50\u6bb5\u548c\u4e5f\u5dee\u4e0d\u591a\u3002\u5728\u533a\u95f4$[L,R]$\u4e2d\u627e\u5230\u6700\u5c0f\u5b50\u6bb5\u548c$[l,r]$,\u90a3\u4e48\u6211\u4eec\u5c31\u8981\u628a$[L,l-1]$,$[r+1,R]$\u7684\u6700\u5c0f\u5b50\u6bb5\u548c\u5df2\u4ee5\u53ca$[l,r]$\u7684\u6700\u5927\u5b50\u6bb5\u548c\u52a0\u5165\u5806\u4e2d\n\n## \u4ee3\u7801\uff1a\n```cpp\n//#pragma GCC optimize(2)\n//#pragma GCC optimize(3)\n#include<bits/stdc++.h>\nusing namespace std;\n#define next Next\n//#define int long long\nchar buf[1<<21],*p1=buf,*p2=buf;\ninline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}\ninline int read()\n{\n    int ret=0,f=0;char c=gc();\n    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n    if(f)return -ret;return ret;\n}\nvoid write(int x)\n{\n    if(x<10)\n    {\n        putchar('0'+x);\n        return;\n    }\n    write(x/10);\n    putchar('0'+x%10);\n}\n#define mid (l+r)/2\nconst int N=1e5+5;\nint n,m,opt,x,y,a[N]; \nstruct node{\n    int sum,ans,l,r,ansl,ansr,ql,qr;\n}tree[N*4],tree2[N*4];\nstruct Node{\n    int val,l,r,ql,qr,opt;\n};\nbool operator < (Node a,Node b)\n{\n    return a.val<b.val;\n}\nvoid pushup(int nod,int l,int r)\n{\n    tree[nod].sum=tree[nod*2].sum+tree[nod*2+1].sum;\n    if(tree[nod*2].sum+tree[nod*2+1].l>tree[nod*2].l)\n    {\n        tree[nod].l=tree[nod*2].sum+tree[nod*2+1].l;\n        tree[nod].qr=tree[nod*2+1].qr;\n    }\n    else{\n        tree[nod].l=tree[nod*2].l;\n        tree[nod].qr=tree[nod*2].qr;\n    }\n    if(tree[nod*2+1].sum+tree[nod*2].r>tree[nod*2+1].r)\n    {\n        tree[nod].r=tree[nod*2+1].sum+tree[nod*2].r;\n        tree[nod].ql=tree[nod*2].ql;\n    }\n    else{\n        tree[nod].r=tree[nod*2+1].r;\n        tree[nod].ql=tree[nod*2+1].ql;\n    }\n    tree[nod].ans=tree[nod*2].ans;\n    tree[nod].ansl=tree[nod*2].ansl;\n    tree[nod].ansr=tree[nod*2].ansr;\n    if(tree[nod*2+1].ans>tree[nod].ans)\n    {\n        tree[nod].ans=tree[nod*2+1].ans;\n        tree[nod].ansl=tree[nod*2+1].ansl;\n        tree[nod].ansr=tree[nod*2+1].ansr;\t\n    }\n    if(tree[nod*2].r+tree[nod*2+1].l>tree[nod].ans)\n    {\n        tree[nod].ans=tree[nod*2].r+tree[nod*2+1].l;\n        tree[nod].ansl=tree[nod*2].ql;\n        tree[nod].ansr=tree[nod*2+1].qr;\t\t\t\n    }\n}\nvoid build(int nod,int l,int r)\n{\n    if(l==r)\n    {\n        tree[nod]=(node){a[l],a[l],a[l],a[l],l,r,l,r};\n        return;\n    }\n    build(nod*2,l,mid);\n    build(nod*2+1,mid+1,r);\n    pushup(nod,l,r);\n}\nvoid change(int nod,int l,int r,int x,int y)\n{\n    if(l==r)\n    {\n        tree[nod]=(node){y,y,y,y,l,r,l,r};\n        return;\n    }\n    if(x<=mid)change(nod*2,l,mid,x,y);\n    else change(nod*2+1,mid+1,r,x,y);\n    pushup(nod,l,r);\n}\nnode find(int nod,int l,int r,int L,int R)\n{\n    if(l==L&&r==R)return tree[nod];\n    if(R<=mid)return find(nod*2,l,mid,L,R);\n    else if(L>mid)return find(nod*2+1,mid+1,r,L,R);\n    node x=find(nod*2,l,mid,L,mid),y=find(nod*2+1,mid+1,r,mid+1,R),res;\n    res.sum=x.sum+y.sum;\n    if(x.sum+y.l>x.l)\n    {\n        res.l=x.sum+y.l;\n        res.qr=y.qr;\n    }\n    else{\n        res.l=x.l;\n        res.qr=x.qr;\n    }\n    if(y.sum+x.r>y.r)\n    {\n        res.r=y.sum+x.r;\n        res.ql=x.ql;\n    }\n    else{\n        res.r=y.r;\n        res.ql=y.ql;\n    }\n    res.ans=x.ans;\n    res.ansl=x.ansl;\n    res.ansr=x.ansr;\n    if(y.ans>res.ans)\n    {\n        res.ans=y.ans;\n        res.ansl=y.ansl;\n        res.ansr=y.ansr;\t\n    }\n    if(x.r+y.l>res.ans)\n    {\n        res.ans=x.r+y.l;\n        res.ansl=x.ql;\n        res.ansr=y.qr;\t\t\t\n    }\n    return res;\n}\n\nvoid pushup2(int nod,int l,int r)\n{\n    tree2[nod].sum=tree2[nod*2].sum+tree2[nod*2+1].sum;\n    if(tree2[nod*2].sum+tree2[nod*2+1].l>tree2[nod*2].l)\n    {\n        tree2[nod].l=tree2[nod*2].sum+tree2[nod*2+1].l;\n        tree2[nod].qr=tree2[nod*2+1].qr;\n    }\n    else{\n        tree2[nod].l=tree2[nod*2].l;\n        tree2[nod].qr=tree2[nod*2].qr;\n    }\n    if(tree2[nod*2+1].sum+tree2[nod*2].r>tree2[nod*2+1].r)\n    {\n        tree2[nod].r=tree2[nod*2+1].sum+tree2[nod*2].r;\n        tree2[nod].ql=tree2[nod*2].ql;\n    }\n    else{\n        tree2[nod].r=tree2[nod*2+1].r;\n        tree2[nod].ql=tree2[nod*2+1].ql;\n    }\n    tree2[nod].ans=tree2[nod*2].ans;\n    tree2[nod].ansl=tree2[nod*2].ansl;\n    tree2[nod].ansr=tree2[nod*2].ansr;\n    if(tree2[nod*2+1].ans>tree2[nod].ans)\n    {\n        tree2[nod].ans=tree2[nod*2+1].ans;\n        tree2[nod].ansl=tree2[nod*2+1].ansl;\n        tree2[nod].ansr=tree2[nod*2+1].ansr;\t\n    }\n    if(tree2[nod*2].r+tree2[nod*2+1].l>tree2[nod].ans)\n    {\n        tree2[nod].ans=tree2[nod*2].r+tree2[nod*2+1].l;\n        tree2[nod].ansl=tree2[nod*2].ql;\n        tree2[nod].ansr=tree2[nod*2+1].qr;\t\t\t\n    }\n}\nvoid build2(int nod,int l,int r)\n{\n    if(l==r)\n    {\n        tree2[nod]=(node){-a[l],-a[l],-a[l],-a[l],l,r,l,r};\n        return;\n    }\n    build2(nod*2,l,mid);\n    build2(nod*2+1,mid+1,r);\n    pushup2(nod,l,r);\n}\nvoid change2(int nod,int l,int r,int x,int y)\n{\n    if(l==r)\n    {\n        tree2[nod]=(node){-y,-y,-y,-y,l,r,l,r};\n        return;\n    }\n    if(x<=mid)change2(nod*2,l,mid,x,y);\n    else change2(nod*2+1,mid+1,r,x,y);\n    pushup2(nod,l,r);\n}\nnode find2(int nod,int l,int r,int L,int R)\n{\n    if(l==L&&r==R)return tree2[nod];\n    if(R<=mid)return find2(nod*2,l,mid,L,R);\n    else if(L>mid)return find2(nod*2+1,mid+1,r,L,R);\n    node x=find2(nod*2,l,mid,L,mid),y=find2(nod*2+1,mid+1,r,mid+1,R),res;\n    res.sum=x.sum+y.sum;\n    if(x.sum+y.l>x.l)\n    {\n        res.l=x.sum+y.l;\n        res.qr=y.qr;\n    }\n    else{\n        res.l=x.l;\n        res.qr=x.qr;\n    }\n    if(y.sum+x.r>y.r)\n    {\n        res.r=y.sum+x.r;\n        res.ql=x.ql;\n    }\n    else{\n        res.r=y.r;\n        res.ql=y.ql;\n    }\n    res.ans=x.ans;\n    res.ansl=x.ansl;\n    res.ansr=x.ansr;\n    if(y.ans>res.ans)\n    {\n        res.ans=y.ans;\n        res.ansl=y.ansl;\n        res.ansr=y.ansr;\t\n    }\n    if(x.r+y.l>res.ans)\n    {\n        res.ans=x.r+y.l;\n        res.ansl=x.ql;\n        res.ansr=y.qr;\t\t\t\n    }\n    return res;\n}\nsigned main()\n{\n// \tfreopen(\"easy.in\",\"r\",stdin);\n// \tfreopen(\"easy.out\",\"w\",stdout);\n    n=read();\n    for(int i=1;i<=n;i++)a[i]=read();\n    build(1,1,n);\n    build2(1,1,n);\n    m=read();\n    for(int i=1;i<=m;i++)\n    {\n        int opt=read();\n        if(opt==0)\n        {\n            int x=read(),y=read();\n            a[x]=y;\n            change(1,1,n,x,y);\n            change2(1,1,n,x,y);\n        }\n        else{\n            int l=read(),r=read(),k=read(),ma=0;\n            priority_queue<Node>q;\n            node xu=find(1,1,n,l,r);\n            q.push((Node){xu.ans,l,r,xu.ansl,xu.ansr,1});\n            for(int i=1;i<=k;i++)\n            {\n                Node u=q.top();q.pop();\n                if(u.val<0)break;\n                ma+=u.val;\n                if(u.opt==1)\n                {\n                    node xu=find2(1,1,n,u.ql,u.qr);\n                    if(xu.ans>0)\n                    {\n                        q.push((Node){xu.ans,u.ql,u.qr,xu.ansl,xu.ansr,0});\n                    }\n                    if(u.ql>u.l)\n                    {\n                        node xu=find(1,1,n,u.l,u.ql-1);\n                        if(xu.ans>0)\n                        {\n                            q.push((Node){xu.ans,u.l,u.ql-1,xu.ansl,xu.ansr,1});\n                        }\n                    }\n                    if(u.qr<u.r)\n                    {\n                        node xu=find(1,1,n,u.qr+1,u.r);\n                        if(xu.ans>0)\n                        {\n                            q.push((Node){xu.ans,u.qr+1,u.r,xu.ansl,xu.ansr,1});\n                        }\n                    }\n                }\n                else{\n                    node xu=find(1,1,n,u.ql,u.qr);\n                    if(xu.ans>0)\n                    {\n                        q.push((Node){xu.ans,u.ql,u.qr,xu.ansl,xu.ansr,1});\n                    }\n                    if(u.ql>u.l)\n                    {\n                        node xu=find2(1,1,n,u.l,u.ql-1);\n                        if(xu.ans>0)\n                        {\n                            q.push((Node){xu.ans,u.l,u.ql-1,xu.ansl,xu.ansr,0});\n                        }\n                    }\n                    if(u.qr<u.r)\n                    {\n                        node xu=find2(1,1,n,u.qr+1,u.r);\n                        if(xu.ans>0)\n                        {\n                            q.push((Node){xu.ans,u.qr+1,u.r,xu.ansl,xu.ansr,0});\n                        }\n                    }\t\t\n                }\n                if(q.empty())break;\n            }\n            write(ma);\n            putchar('\\n');\n        }\n    }\n    return 0;\n}\n/*\n15\n-4 8 -3 -10 10 4 -7 -7 0 -6 3 8 -10 7 2\n1\n1 3 9 2\n*/\n```\n",
        "postTime": 1562679072,
        "uid": 39484,
        "name": "\u7c73\u5947",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "\u4f5c\u4e3a\u672c\u9898rk2\u6c34\u4e00\u6ce2\u9898\u89e3\u2026\u2026%%%stO AThousandMoon Orz%%%\n\n\u4e3a\u4ec0\u4e48\u5927\u4f6c\u4eec\u4f1a\u8ba4\u4e3a\u8fd9\u662f\u6a21\u62df\u8d39\u7528\u6d41\u554a\u2026\u2026\u6b63\u89e3\u770b\u8d77\u6765\u8ddf\u8d39\u7528\u6d41\u5b8c\u5168\u6ca1\u5173\u7cfb\u597d\u5417\u2026\u2026\n\n\u8fd9\u53d6\u53cd\u4e0d\u5c31\u76f8\u5f53\u4e8e\u64a4\u9500\u9009\u8fd9\u6bb5\u5417\u2026\u2026~~\uff08\u6b64\u65f6\u6b63\u5728\u88ab\u65c1\u8fb9\u7684AThousandMoon\u5632\u8bbd\u8fd9\u5c31\u662f\u8d39\u7528\u6d41\uff0c\u597d\u50cf\u771f\u7684\u53ef\u4ee5\u8fd9\u4e48\u8bf4\u2026\u2026\uff09~~\n\n\u968f\u4fbf\u968f\u4fbf\uff0c\u8fd9\u91cc\u53ea\u662f\u7ed9\u50cf\u6211\u8fd9\u6837\u7684\u849f\u84bb\u4e00\u4e9b\u4fe1\u5fc3\uff0c\u4e0d\u8981\u88abdalao\u4eec\u8bf4\u662f\u6a21\u62df\u8d39\u7528\u6d41\u5c31\u5413\u9000\u4e86\u3002\n\n---\n\u8003\u8651\u8d2a\u5fc3\uff0c\u6bcf\u6b21\u90fd\u9009\u62e9\u6700\u5927\u5b50\u6bb5\u548c\u3002\u7136\u800c\u53ef\u80fd\u5df2\u7ecf\u9009\u7684\u4e00\u4e9b\u6570\u4e2d\u4e00\u90e8\u5206\u4e0d\u5c5e\u4e8e\u6700\u4f18\u89e3\uff0c\u4e8e\u662f\u5c31\u6709\u4e86\u4e2a\u7c7b\u4f3c\u7f51\u7edc\u6d41\u7684\u201c\u64a4\u9500\u201d\u64cd\u4f5c\u3002\n\n\u5bb9\u6613\u53d1\u73b0\u52a0\u4e0a\u76f8\u53cd\u6570\u5c31\u662f\u64a4\u9500\u4e86\u9009\u8fd9\u4e9b\u6570\u3002\u90a3\u4e48\u6bcf\u6b21\u628a\u6700\u5927\u5b50\u6bb5\u548c\u4e2d\u7684\u6570\u53d6\u53cd\u5373\u53ef\u3002\u4e4b\u540e\u6c42\u7684\u6700\u5927\u5b50\u6bb5\u548c\u5982\u679c\u5305\u62ec\u8fd9\u4e9b\u88ab\u53d6\u53cd\u7684\u6570\uff0c\u5c31\u76f8\u5f53\u4e8e\u64a4\u9500\u4e86\u8fd9\u4e9b\u65b9\u6848\u3002\u90a3\u4e48\u8fd9\u6837\u7684\u5f97\u5230\u7684\u4e00\u5b9a\u662f\u6700\u4f18\u89e3\u3002\n\n\u753b\u4e2a\u56fe\u5bb9\u6613\u77e5\u9053\uff0c\u8fdb\u884c $k$ \u6b21\u64cd\u4f5c\u4f1a\u53d6\u5230\u6240\u6709\u6bb5\u6570 $\\le k$ \u7684\u65b9\u6848\u7684\u6700\u5927\u503c\uff0c\u90a3\u4e48\u76f4\u63a5 $k$ \u6b21\u64cd\u4f5c\u5373\u53ef\u3002\n\n~~AThousandMoon\uff1a\u8fd9tm\u4e0d\u5c31\u662f\u8d39\u7528\u6d41\u2026\u2026~~\n\n\u5177\u4f53\u5b9e\u73b0\uff0c\u7531\u4e8e\u9700\u8981\u53d6\u53cd\u4e00\u4e2a\u5177\u4f53\u533a\u95f4\uff0c\u6240\u4ee5\u8981\u8bb0\u5f55\u4e0b\u6700\u5927\u5b50\u6bb5\u548c\u7684\u5de6\u53f3\u7aef\u70b9\u3002\u7136\u540e\u53d6\u53cd\u540e\u6700\u5927\u503c\u4f1a\u53d8\u6210\u539f\u6765\u6700\u5c0f\u503c\u7684\u76f8\u53cd\u6570\uff0c\u6240\u4ee5\u8fd8\u8981\u6709\u6700\u5c0f\u5b50\u6bb5\u548c\u3002\n\n\u5177\u4f53\u89c1\u4ee3\u7801\u3002\u9b3c\u77e5\u9053\u6211\u6253\u4e86\u591a\u4e45\u2026\u2026\u7531\u4e8e\u60f3\u8c61\u529b\u532e\u4e4f\u5bfc\u81f4\u7684\u53d8\u91cf\u540d\u96be\u770b\uff0c\u8bf7\u89c1\u8c05\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(mk\\log n)$\u3002\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=100010,mod=998244353;\n#define lson o<<1,l,mid\n#define rson o<<1|1,mid+1,r\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define ROF(i,a,b) for(int i=(a);i>=(b);i--)\n#define MEM(x,v) memset(x,v,sizeof(x))\ninline int read(){\n\tint x=0,f=0;char ch=getchar();\n\twhile(ch<'0' || ch>'9') f|=ch=='-',ch=getchar();\n\twhile(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn f?-x:x;\n}\nint n,m,a[maxn],ls[maxn],rs[maxn],tp;\ninline bool chkmax(int &x,int y){\n\tif(y>x) return x=y,true;\n\treturn false;\n}\ninline bool chkmin(int &x,int y){\n\tif(y<x) return x=y,true;\n\treturn false;\n}\nstruct node{\n\tint l,r,sum,lmax,rmax,amax,lx,rx,llx,rrx,lmin,rmin,amin,ln,rn,lln,rrn;\n\tnode operator+(const node &nd)const{\n\t\tnode ans;\n\t\tans.l=l;ans.r=nd.r;\n\t\tans.sum=sum+nd.sum;\n\t\tans.lmax=lmax;ans.llx=llx;\n\t\tif(chkmax(ans.lmax,sum+nd.lmax)) ans.llx=nd.llx;\n\t\tans.rmax=nd.rmax;ans.rrx=nd.rrx;\n\t\tif(chkmax(ans.rmax,nd.sum+rmax)) ans.rrx=rrx;\n\t\tans.amax=amax;ans.lx=lx;ans.rx=rx;\n\t\tif(chkmax(ans.amax,nd.amax)) ans.lx=nd.lx,ans.rx=nd.rx;\n\t\tif(chkmax(ans.amax,rmax+nd.lmax)) ans.lx=rrx,ans.rx=nd.llx;\n\t\tans.lmin=lmin;ans.lln=lln;\n\t\tif(chkmin(ans.lmin,sum+nd.lmin)) ans.lln=nd.lln;\n\t\tans.rmin=nd.rmin;ans.rrn=nd.rrn;\n\t\tif(chkmin(ans.rmin,nd.sum+rmin)) ans.rrn=rrn;\n\t\tans.amin=amin;ans.ln=ln;ans.rn=rn;\n\t\tif(chkmin(ans.amin,nd.amin)) ans.ln=nd.ln,ans.rn=nd.rn;\n\t\tif(chkmin(ans.amin,rmin+nd.lmin)) ans.ln=rrn,ans.rn=nd.lln;\n\t\treturn ans;\n\t}\n}seg[maxn*4];\nbool rev[maxn*4];\ninline void setrev(int o){\n\trev[o]^=1;\n\tseg[o].sum*=-1;\n\tint tlmax=seg[o].lmax,trmax=seg[o].rmax,tamax=seg[o].amax;\n\tint tlx=seg[o].lx,trx=seg[o].rx,tllx=seg[o].llx,trrx=seg[o].rrx;\n\tseg[o].lmax=-seg[o].lmin;seg[o].rmax=-seg[o].rmin;seg[o].amax=-seg[o].amin;\n\tseg[o].lmin=-tlmax;seg[o].rmin=-trmax;seg[o].amin=-tamax;\n\tswap(seg[o].lx,seg[o].ln);swap(seg[o].rx,seg[o].rn);\n\tswap(seg[o].llx,seg[o].lln);swap(seg[o].rrx,seg[o].rrn);\n}\ninline void pushdown(int o){\n\tif(rev[o]){\n\t\tsetrev(o<<1);\n\t\tsetrev(o<<1|1);\n\t\trev[o]=0;\n\t}\n}\nvoid build(int o,int l,int r){\n\tif(l==r) return void(seg[o]=(node){l,l,a[l],a[l],a[l],a[l],l,l,l,l,a[l],a[l],a[l],l,l,l,l});\n\tint mid=(l+r)>>1;\n\tbuild(lson);build(rson);\n\tseg[o]=seg[o<<1]+seg[o<<1|1];\n}\nvoid update(int o,int l,int r,int p,int v){\n\tif(l==r) return void(seg[o]=(node){l,l,v,v,v,v,l,l,l,l,v,v,v,l,l,l,l});\n\tpushdown(o);\n\tint mid=(l+r)>>1;\n\tif(mid>=p) update(lson,p,v);\n\telse update(rson,p,v);\n\tseg[o]=seg[o<<1]+seg[o<<1|1];\n}\nvoid reverse(int o,int l,int r,int ql,int qr){\n\tif(l>=ql && r<=qr) return setrev(o);\n\tpushdown(o);\n\tint mid=(l+r)>>1;\n\tif(mid>=ql) reverse(lson,ql,qr);\n\tif(mid<qr) reverse(rson,ql,qr);\n\tseg[o]=seg[o<<1]+seg[o<<1|1];\n}\nnode query(int o,int l,int r,int ql,int qr){\n\tif(l>=ql && r<=qr) return seg[o];\n\tpushdown(o);\n\tint mid=(l+r)>>1;\n\tif(mid<ql) return query(rson,ql,qr);\n\tif(mid>=qr) return query(lson,ql,qr);\n\treturn query(lson,ql,qr)+query(rson,ql,qr);\n}\nint main(){\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tbuild(1,1,n);\n\tm=read();\n\twhile(m--){\n\t\tint op=read(),x=read(),y=read();\n\t\tif(op){\n\t\t\tint k=read(),s=0,ans=0;\n\t\t\ttp=0;\n\t\t\twhile(k--){\n\t\t\t\tnode nd=query(1,1,n,x,y);\n\t\t\t\tls[++tp]=nd.lx;rs[tp]=nd.rx;\n\t\t\t\tchkmax(ans,s+=nd.amax);\n\t\t\t\treverse(1,1,n,nd.lx,nd.rx);\n\t\t\t}\n\t\t\twhile(tp) reverse(1,1,n,ls[tp],rs[tp]),tp--;\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t\telse update(1,1,n,x,y);\n\t}\n}\n```",
        "postTime": 1556362578,
        "uid": 72118,
        "name": "AThousandSuns",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "~~\u5f00\u59cb\u4e4b\u524d\u5410\u69fd\u4e00\u53e5\uff0c\u8fd9\u9898\u601d\u7ef4\u96be\u5ea6\u53ef\u80fd\u7d2b\uff0c\u4f46\u7801\u91cf\u662f\u771f\u6ef4\u9ed1\u554a~~\n\n\n------------\n\n## \u9898\u610f\u7b80\u8ff0\n\u7ed9\u5b9a\u4e00\u4e2a\u957f\u4e3a $n$ \u7684\u5e8f\u5217 {$a_i$} \uff0c\u6709 $Q$ \u6b21\u64cd\u4f5c\uff1a\n- \u5355\u70b9\u4fee\u6539\u3002\n- \u7ed9\u5b9a\u4e00\u4e2a\u533a\u95f4 $[l,r]$ \uff0c\u5728 $[l,r]$ \u5185\u9009\u62e9\u81f3\u591a $k$ \u4e2a\u4e0d\u76f8\u4ea4\u7684\u8fde\u7eed\u5b50\u6bb5\u8ba9\u5176\u548c\u6700\u5927\u3002\n- $n,Q\\leq10^5,k\\leq20$\n\n------------\n## \u57fa\u672c\u601d\u8def\n\u9996\u5148\u8003\u8651 $k=1$ \u7684\u7279\u6b8a\u60c5\u51b5\uff1a\u7ef4\u62a4\u67d0\u4e00\u533a\u95f4\u7684\u6700\u5927\u5b50\u6bb5\u548c\u3002\u8fd9\u662f\u7ecf\u5178\u7684\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u95ee\u9898\u4e86\uff0c\u5373\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4 $[l,r]$ \u7684\u6700\u5927\u5b50\u6bb5\u548c $ms$\uff0c$l$ \u5f00\u5934\u7684\u6700\u5927\u5b50\u6bb5\u548c $ls$\uff0c$r$ \u7ed3\u5c3e\u7684\u6700\u5927\u5b50\u6bb5\u548c $rs$ \uff0c\u548c\u533a\u95f4\u548c $sum$\u3002\u6562\u70b9\u5f00\u8fd9\u4e2a\u9898\u7684\u795e\u5e94\u8be5\u90fd\u77e5\u9053 pushup \u548c pushdown \u7684\u5199\u6cd5\uff0c~~\u6240\u4ee5\u5c31\u7565\u8fc7~~\uff08\u5728\u4ee3\u7801\u91cc\u63d0\u4e00\u4e0b\uff09\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651 $k>1$ \u7684\u60c5\u51b5\uff0c\u6ce8\u610f\u5230 $k$ \u7684\u8303\u56f4\u672c\u8eab\u4e0d\u5927\uff0c\u518d\u52a0\u4e0a\u6bcf\u6b21**\u589e\u5e7f**\u4e00\u4e2a\u5b50\u6bb5\u548c\u7684\u8be2\u95ee\uff0c\u53ef\u4ee5~~\u5f88\u81ea\u7136~~\u8054\u60f3\u5230\u4e0eEK\u7b97\u6cd5\u7c7b\u4f3c\u7684\u601d\u8def\uff0c\u5373\u8fed\u4ee3 $k$ \u6b21\uff0c\u6bcf\u6b21\u591a\u5bfb\u627e\u4e00\u4e2a\u5b50\u6bb5\u548c\u3002\n\n\u53ef\u4ee5\u53c2\u8003\u6700\u5927\u6d41/\u8d39\u7528\u6d41\u7684\u5b9e\u73b0\u65b9\u5f0f\u4e4b\u4e00\u2014\u2014\u5f15\u5165\u53cd\u6d41\uff0c\u5373\u4fdd\u7559\u53cd\u6094\u7684\u53ef\u80fd\u3002\u5904\u7406\u5b8c $k=1$ \u7684\u8be2\u95ee\u540e\uff0c\u5c06\u548c\u6700\u5927\u7684\u5b50\u6bb5 $[l,r]$ \u5168\u90e8\u4e58\u4e0a $-1$ \u3002\u8fd9\u6837\uff0c\u5728\u5904\u7406\u4e0b\u4e00\u6b21\u8be2\u95ee\u65f6\uff0c\u5982\u679c\u6240\u5f97\u7684\u5b50\u6bb5 $[x,y]$ \u4e0e $[l,r]$ \u65e0\u4ea4\u96c6\uff0c\u81ea\u7136\u7b26\u5408\u9898\u610f\uff1b\u5982\u679c\u6709\u4ea4\u96c6\uff0c\u4f46\u4e0d\u5b8c\u5168\u8986\u76d6\uff0c\u8bf4\u660e\u8986\u76d6\u7684\u90e8\u5206\u88ab\u53cd\u6094\u6389\u4e86\uff0c\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u65b0\u7684\u4e0d\u60f3\u4ea4\u7684\u6700\u5927\u5b50\u6bb5\u548c\uff08\u56e0\u4e3a\u8fd9\u4fe9\u90fd\u662f\u6c42\u7684\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u6240\u4ee5\u53ef\u4ee5\u4fdd\u8bc1\u662f**\u5f53\u524d**k\u503c\u7684\u6700\u5927\u503c\uff09\uff1b\u6613\u5f97 $[l,r]$\uff0c$[x,y]$ \u4e0d\u53ef\u80fd\u5b8c\u5168\u76f8\u4ea4\u3002\u6240\u4ee5\u6309\u7167\u4e0a\u8ff0\u8fc7\u7a0b\u8fed\u4ee3 $k$ \u6b21\u5373\u5f97 $k$ \u4e2a\u6700\u5927\u5b50\u6bb5\u3002\\\n**\u6ce8\u610f\u9898\u76ee\u8bf4\u81f3\u591a $k$ \u4e2a\uff0c\u6240\u4ee5\u5e94\u53d6 $k=0,1..k$ \u65f6\u7684\u6700\u5927\u5b50\u6bb5\u548c\u4e2d\u7684\u6700\u5927\u503c\u3002**\n\n\u4e3a\u4e86\u5b9e\u73b0\u4e0a\u8ff0\u8fc7\u7a0b\uff0c\u8003\u8651\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u4ec0\u4e48 \u3002\n- \u539f\u6765\u5c31\u9700\u8981\u7ef4\u62a4\u7684\u533a\u95f4 $[l,r]$ \u7684\u6700\u5927\u5b50\u6bb5\u548c $ms$\uff0c$l$ \u5f00\u5934\u7684\u6700\u5927\u5b50\u6bb5\u548c $ls$\uff0c $r$ \u7ed3\u5c3e\u7684\u6700\u5927\u5b50\u6bb5\u548c $rs$ \uff0c\u548c\u533a\u95f4\u548c $sum$\u3002\n- \u4e3a\u4e86\u4e58 $-1$ \u65f6\u80fd\u6b63\u786e\u7ef4\u62a4\u4e0a\u8ff0\u4fe1\u606f\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u7ef4\u62a4\u533a\u95f4 $[l,r]$ \u7684\u6700\u5c0f\u5b50\u6bb5\u548c $as$ \uff0c $l$ \u5f00\u5934\u7684\u6700\u5c0f\u5b50\u6bb5\u548c $ml$\uff0c$r$ \u7ed3\u5c3e\u7684\u6700\u5c0f\u5b50\u6bb5\u548c $mr$\u3002\uff08\u4e58 $-1$ \u540e\u6700\u5927\u6700\u5c0f\u4ea4\u6362\u5373\u53ef\uff09\u3002\n- \u4e3a\u4e86\u6267\u884c\u4e58 $-1$ \u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u61d2\u6807\u8bb0 $lazy$\u3002\n- \u4e3a\u4e86\u4e86\u89e3\u5728\u54ea\u91cc\u4e58 $-1$\uff0c\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u533a\u95f4 $[l,r]$ \u7684\u6700\u5927\u5b50\u6bb5\u548c\u7684\u5f00\u5934\u7ed3\u5c3e $li,ri$\uff0c\u6700\u5c0f\u5b50\u6bb5\u548c\u7684\u5f00\u5934\u7ed3\u5c3e $u,v$\uff0c$l$ \u5f00\u5934\u7684\u6700\u5927\u5b50\u6bb5\u548c\u7684\u7ed3\u5c3e $rr$\uff0c$r$ \u7ed3\u5c3e\u7684\u6700\u5927\u5b50\u6bb5\u548c\u7684\u5f00\u5934$ll$\uff0c$l$\u5f00\u5934\u7684\u6700\u5c0f\u5b50\u6bb5\u548c\u7684\u7ed3\u5c3e $vv$\uff0c$r$ \u7ed3\u5c3e\u7684\u6700\u5c0f\u5b50\u6bb5\u548c\u7684\u5f00\u5934 $uu$\u3002\n\n\u770b\u8d77\u6765\u5c31\u5f88\u9ebb\u70e6qwq\uff0c\u5177\u4f53\u7ec6\u8282\u770b\u4ee3\u7801\u5427\uff0c\u9b3c\u77e5\u9053\u6211\u8c03\u4e86\u591a\u4e45\uff08ps. \u5c01\u88c5\u4e00\u4e9b\u7ed3\u6784\u4f53\u4f1a\u66f4\u597d\u770b\uff09qwq\u3002\n## \u4ee3\u7801\n```cpp\n#include <cstdio>\n#define Ls(x) (x << 1)\n#define Rs(x) (x << 1 | 1)\ninline void swap(int& a1, int& a2) { int t = a1; a1 = a2; a2 = t; }\ninline int max(const int& a1, const int& a2) { return a1 > a2 ? a1 : a2; }\nconst int N = 1e5 + 10, inf = 2e9; int a[N]; int L[30], R[30];\nstruct segTree{ int ms, ls, rs, sum, li, ri, lazy, rr, ll, as, u, v, ml, mr, uu, vv; }h[N << 2];\ninline void pushup(int k)\n{\n\t//\u5de6 \u53f3\u8fd8\u662f\u6a2a\u8de8\n\tif (h[Ls(k)].ms > h[Rs(k)].ms) h[k].ms = h[Ls(k)].ms, h[k].li = h[Ls(k)].li, h[k].ri = h[Ls(k)].ri;\n\telse h[k].ms = h[Rs(k)].ms, h[k].li = h[Rs(k)].li, h[k].ri = h[Rs(k)].ri;\n\tif (h[Ls(k)].rs + h[Rs(k)].ls > h[k].ms) h[k].ms = h[Ls(k)].rs + h[Rs(k)].ls, h[k].li = h[Ls(k)].ll, h[k].ri = h[Rs(k)].rr;\n\t\n\t//\u5de6 \u8fd8\u662f\u6a2a\u8de8 \n\tif (h[Ls(k)].ls > h[Ls(k)].sum + h[Rs(k)].ls) h[k].ls = h[Ls(k)].ls, h[k].rr = h[Ls(k)].rr;\n\telse h[k].ls = h[Ls(k)].sum + h[Rs(k)].ls, h[k].rr = h[Rs(k)].rr;\n\t\n\t//\u53f3 \u8fd8\u662f\u6a2a\u8de8\n\tif (h[Rs(k)].rs > h[Rs(k)].sum + h[Ls(k)].rs) h[k].rs = h[Rs(k)].rs, h[k].ll = h[Rs(k)].ll;\n\telse h[k].rs = h[Rs(k)].sum + h[Ls(k)].rs, h[k].ll = h[Ls(k)].ll;\n\t\n\th[k].sum = h[Ls(k)].sum + h[Rs(k)].sum;\n\t\n\t\n\t//\u7c7b\u4f3c\u6700\u5927\u503c\u64cd\u4f5c\n\tif (h[Ls(k)].as < h[Rs(k)].as) h[k].as = h[Ls(k)].as, h[k].u = h[Ls(k)].u, h[k].v = h[Ls(k)].v;\n\telse h[k].as = h[Rs(k)].as, h[k].u = h[Rs(k)].u, h[k].v = h[Rs(k)].v;\n\tif (h[Ls(k)].mr + h[Rs(k)].ml < h[k].as) h[k].as = h[Ls(k)].mr + h[Rs(k)].ml, h[k].u = h[Ls(k)].uu, h[k].v = h[Rs(k)].vv;\n\t\n\tif (h[Ls(k)].ml < h[Ls(k)].sum + h[Rs(k)].ml) h[k].ml = h[Ls(k)].ml, h[k].vv = h[Ls(k)].vv;\n\telse h[k].ml = h[Ls(k)].sum + h[Rs(k)].ml, h[k].vv = h[Rs(k)].vv;\n\t\n\tif (h[Rs(k)].mr < h[Rs(k)].sum + h[Ls(k)].mr) h[k].mr = h[Rs(k)].mr, h[k].uu = h[Rs(k)].uu;\n\telse h[k].mr = h[Rs(k)].sum + h[Ls(k)].mr, h[k].uu = h[Ls(k)].uu;\n}\ninline void pushdown(int k, int l, int r, int mid)\n{\n\tif (h[k].lazy)\n\t{\n\t\t//\u4ea4\u6362\u6700\u5927\u503c\u4e0e\u6700\u5c0f\u503c\u7684\u6240\u6709\u4fe1\u606f\uff08\u53ef\u4ee5\u5c01\u88c5\u7ed3\u6784\u4f53\uff0c\u8fd9\u6837\u76f4\u63a5swap\u7ed3\u6784\u4f53\uff09\n\t\tswap(h[Ls(k)].u, h[Ls(k)].li); swap(h[Ls(k)].v, h[Ls(k)].ri); swap(h[Ls(k)].ms, h[Ls(k)].as);\n\t\tswap(h[Ls(k)].ml, h[Ls(k)].ls); swap(h[Ls(k)].mr, h[Ls(k)].rs); swap(h[Ls(k)].ll, h[Ls(k)].uu); swap(h[Ls(k)].rr, h[Ls(k)].vv);\n\t\th[Ls(k)].ms *= -1; h[Ls(k)].as *= -1; h[Ls(k)].ls *= -1; h[Ls(k)].rs *= -1; h[Ls(k)].ml *= -1; h[Ls(k)].mr *= -1; h[Ls(k)].sum *= -1;\n\t\t\n\t\tswap(h[Rs(k)].u, h[Rs(k)].li); swap(h[Rs(k)].v, h[Rs(k)].ri); swap(h[Rs(k)].ms, h[Rs(k)].as);\n\t\tswap(h[Rs(k)].ml, h[Rs(k)].ls); swap(h[Rs(k)].mr, h[Rs(k)].rs); swap(h[Rs(k)].ll, h[Rs(k)].uu); swap(h[Rs(k)].rr, h[Rs(k)].vv);\n\t\th[Rs(k)].ms *= -1; h[Rs(k)].as *= -1; h[Rs(k)].ls *= -1; h[Rs(k)].rs *= -1; h[Rs(k)].ml *= -1; h[Rs(k)].mr *= -1; h[Rs(k)].sum *= -1;\n\t\t\n\t\t//\u7c7b\u4f3c\u533a\u95f4\u7ffb\u8f6c\uff0c*-1\u7684\u64cd\u4f5c\u4e5f\u4e3a\u5f02\u6216\u5408\u5e76\n\t\th[Ls(k)].lazy ^= 1; h[Rs(k)].lazy ^= 1; h[k].lazy = 0;\n\t}\n}\nvoid build(int k, int l, int r)\n{\n\tif (l == r) { h[k].as = h[k].sum = h[k].ml = h[k].mr = h[k].rs = h[k].ls = h[k].ms = a[l]; h[k].u = h[k].v = h[k].li = h[k].ll = h[k].ri = h[k].rr = h[k].uu = h[k].vv = l; return ; }\n\tint mid = l + r >> 1; \n\tbuild(Ls(k), l, mid); build(Rs(k), mid + 1, r);\n\tpushup(k);\n}\nvoid change(int k, int l, int r, int x, int v)\n{\n\tif (l == r) { h[k].as = h[k].sum = h[k].ml = h[k].mr = h[k].rs = h[k].ls = h[k].ms = a[l]; return ; }\n\tint mid = l + r >> 1; pushdown(k, l, r, mid);\n\tif (x <= mid) change(Ls(k), l, mid, x, v);\n\telse change(Rs(k), mid + 1, r, x, v);\n\tpushup(k);\n}\nvoid mul(int k, int l, int r, int x, int y)\n{\n\tif (x <= l && r <= y)\n\t{\n\t\t//\u7c7b\u4f3cpushdown\u7684\u64cd\u4f5c\n\t\tswap(h[k].u, h[k].li); swap(h[k].v, h[k].ri); swap(h[k].ms, h[k].as);\n\t\tswap(h[k].ml, h[k].ls); swap(h[k].mr, h[k].rs); swap(h[k].ll, h[k].uu); swap(h[k].rr, h[k].vv);\n\t\th[k].ms *= -1; h[k].as *= -1; h[k].ls *= -1; h[k].rs *= -1; h[k].ml *= -1; h[k].mr *= -1; h[k].sum *= -1;\n\t\th[k].lazy ^= 1; return ;\n\t}\n\tint mid = l + r >> 1; pushdown(k, l, r, mid);\n\tif (x <= mid) mul(Ls(k), l, mid, x, y);\n\tif (mid < y) mul(Rs(k), mid + 1, r, x, y);\n\tpushup(k);\n}\n//\u56e0\u4e3a\u9700\u8981\u7528\u5230\u7684\u4fe1\u606f\u8f83\u591a\uff0c\u6240\u4ee5\u76f4\u63a5\u8fd4\u56de\u4e00\u4e2a\u8282\u70b9\nsegTree query(int k, int l, int r, int x, int y)\n{\n\tif (x <= l && r <= y) return h[k];\n\tint mid = l + r >> 1; pushdown(k, l, r, mid); segTree ret, lef, rig;\n\t//\u6a2a\u8de8\u5c31\u5408\u5e76\n\tif (x <= mid && mid < y)\n\t{\n\t\tlef = query(Ls(k), l, mid, x, y); rig = query(Rs(k), mid + 1, r, x, y);\n\t\t//\u7c7b\u4f3cpushup\u7684\u64cd\u4f5c\n\t\tif (lef.ms > rig.ms) ret.ms = lef.ms, ret.li = lef.li, ret.ri = lef.ri;\n\t\telse ret.ms = rig.ms, ret.li = rig.li, ret.ri = rig.ri;\n\t\tif (lef.rs + rig.ls > ret.ms) ret.ms = lef.rs + rig.ls, ret.li = lef.ll, ret.ri = rig.rr;\n\t\t\n\t\tif (lef.ls > lef.sum + rig.ls) ret.ls = lef.ls, ret.rr = lef.rr;\n\t\telse ret.ls = lef.sum + rig.ls, ret.rr = rig.rr;\n\t\t\n\t\tif (rig.rs > rig.sum + lef.rs) ret.rs = rig.rs, ret.ll = rig.ll;\n\t\telse ret.rs = rig.sum + lef.rs, ret.ll = lef.ll;\n\t\t\n\t\tret.sum = lef.sum + rig.sum;\n\t\treturn ret;\n\t}\n\t//\u5426\u5219\u76f4\u63a5\u8fd4\u56de\u5de6\u6216\u53f3\n\tif (x <= mid) return query(Ls(k), l, mid, x, y);\n\tif (mid < y) return query(Rs(k), mid + 1, r, x, y);\n}\nint main()\n{\n\tint n, m; scanf(\"%d\", &n); segTree t;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tbuild(1, 1, n); scanf(\"%d\", &m);\n\tfor (int i = 1, opt, l, r, k, ret = 0, tt, ans = 0/*ans\u8fd9\u91cc\u4ee3\u8868k=0\u7684\u60c5\u51b5*/; i <= m; i++)\n\t{\n\t\tscanf(\"%d%d%d\", &opt, &l, &r);\n\t\tif (opt == 0) a[l] = r, change(1, 1, n, l, r);\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d\", &k); tt = k;\n\t\t\twhile (k)\n\t\t\t{\n\t\t\t\tt = query(1, 1, n, l, r);\n\t\t\t\tret += t.ms; ans = max(ans, ret);\n\t\t\t\tmul(1, 1, n, t.li, t.ri);\n\t\t\t\t//\u8bb0\u5f55\u4e00\u4e0b\u6bcf\u6b21*-1\u7684\u60c5\u51b5\uff0c\u65b9\u4fbf\u4ee5\u540e\u4e58\u56de\u6765\n\t\t\t\tL[k] = t.li; R[k] = t.ri; k--;\n\t\t\t}\n\t\t\tfor (int j = 1; j <= tt; j++) mul(1, 1, n, L[j], R[j]);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t\tret = 0; ans = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1625665128,
        "uid": 137603,
        "name": "zhiyangfan",
        "ccfLevel": 9,
        "title": "CF280D k-Maximum Subsequence Sum \u9898\u89e3"
    },
    {
        "content": "[\u53bb\u535a\u5ba2\u56ed\u98df\u7528\u66f4\u4f73](https://www.cnblogs.com/AThousandMoons/p/10623871.html)\n\n\u9996\u5148\uff0c\u76f8\u4fe1\u5927\u5bb6\u4e00\u5f00\u59cb\u90fd\u662f\u60f3\u53bb\u76f4\u63a5dp\uff0c\u4f46\u662f\u53d1\u73b0\u590d\u6742\u5ea6\u4e0d\u5bf9\u3002\n\n\u4e8e\u662f\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u9ed1\u79d1\u6280\uff1a\u6a21\u62df\u8d39\u7528\u6d41\uff08\u76f8\u4fe1\u5927\u90e8\u5206\u4eba\u770b\u89c1\u6570\u636e\u8303\u56f4\u5c31\u7edd\u5bf9\u4e0d\u4f1a\u60f3\u5230\u8d39\u7528\u6d41\uff09\n\n\u6211\u4eec\u8003\u8651\u8fdb\u884c\u62c6\u70b9\uff0c\u8bbei->i':(1,a[i]),i'->i+1:(1,0)\uff0c\u800c\u4e14\u603b\u6d41\u91cf$\\leq k$\uff0c\u7136\u540e\u5c31\u8dd1\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u3002\n\n\u8fd9\u663e\u7136\u4f1aT\u6210sb\uff0c\u4e0d\u8fc7\u8fd9\u4e2a\u56fe\u6bd4\u8f83\u7b80\u5355\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u624b\u73a9\u4e00\u4e0b\u3002\n\n\u7136\u540e\u5c31\u53d1\u73b0\u6bcf\u6b21\u7684\u589e\u5e7f\u8def\u5c31\u662f\u8fd9\u4e2a\u533a\u95f4\u91cc\u7684\u6700\u5927\u548c\u7684\u5b50\u6bb5\u5bf9\u5e94\u7684\u8def\u5f84\uff0c\u7136\u540e\u518d\u628a\u8fd9\u4e2a\u6700\u5927\u548c\u7684\u5b50\u6bb5\u91cc\u9762\u6240\u6709\u6570\u53d6\u76f8\u53cd\u6570\uff08\u53cd\u5411\u8fb9\uff09\u3002\n\n\u7136\u540e\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u8fd9\u4e2a\u7ebf\u6bb5\u6811\u9700\u8981\u4ee5\u4e0b\u64cd\u4f5c\u3002\n\n1.\u5355\u70b9\u4fee\u6539\n\n2.\u5bf9\u4e8e\u533a\u95f4$[l,r]$\uff0c\u5148\u627e\u51fa\u8fd9\u4e2a\u533a\u95f4\u7684\u6700\u5927\u548c\u7684\u5b50\u6bb5\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u5b50\u6bb5\u53d6\u76f8\u53cd\u6570\u3002\n\n\u4e0d\u8fc7\u7801\u91cf\u8ba9\u4eba\u60f3\u54ed\u3002\u3002\u3002\uff08\u597d\u4e0d\u5bb9\u6613\u8c03\u51fa\u6765\uff0c\u7eaa\u5ff5\u4e00\u4e0b\u3002\n```cpp\n#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 100003;\nstruct Node {\n    int L, R, sum, maxv, maxl, maxr, minv, minl, minr, lmax, lmaxid, lmin, lminid, rmax, rmaxid, rmin, rminid;\n    bool rev;\n    inline Node(int pos = 0, int val = 0){\n        L = R = maxl = maxr = minl = minr = lmaxid = lminid = rmaxid = rminid = pos;\n        sum = maxv = minv = lmax = lmin = rmax = rmin = val;\n        rev = false;\n    }\n} seg[N << 2], q[22];\ninline Node merge(const Node &a, const Node &b){\n    Node now;\n    now.L = a.L; now.R = b.R;\n    now.sum = a.sum + b.sum;\n    if(a.lmax >= a.sum + b.lmax) now.lmax = a.lmax, now.lmaxid = a.lmaxid;\n    else now.lmax = a.sum + b.lmax, now.lmaxid = b.lmaxid;\n    if(a.lmin <= a.sum + b.lmin) now.lmin = a.lmin, now.lminid = a.lminid;\n    else now.lmin = a.sum + b.lmin, now.lminid = b.lminid;\n    if(b.rmax >= b.sum + a.rmax) now.rmax = b.rmax, now.rmaxid = b.rmaxid;\n    else now.rmax = b.sum + a.rmax, now.rmaxid = a.rmaxid;\n    if(b.rmin <= b.sum + a.rmin) now.rmin = b.rmin, now.rminid = b.rminid;\n    else now.rmin = b.sum + a.rmin, now.rminid = a.rminid;\n    now.maxv = a.rmax + b.lmax; now.maxl = a.rmaxid; now.maxr = b.lmaxid;\n    if(now.maxv < a.maxv) now.maxv = a.maxv, now.maxl = a.maxl, now.maxr = a.maxr;\n    if(now.maxv < b.maxv) now.maxv = b.maxv, now.maxl = b.maxl, now.maxr = b.maxr;\n    now.minv = a.rmin + b.lmin; now.minl = a.rminid; now.minr = b.lminid;\n    if(now.minv > a.minv) now.minv = a.minv, now.minl = a.minl, now.minr = a.minr;\n    if(now.minv > b.minv) now.minv = b.minv, now.minl = b.minl, now.minr = b.minr;\n    now.rev = false;\n    return now;\n}\ninline void pushup(int x){seg[x] = merge(seg[x << 1], seg[x << 1 | 1]);}\ninline void rev(Node &a){\n    a.rev ^= 1;\n    a.sum = -a.sum;\n    swap(a.lmax, a.lmin); swap(a.lmaxid, a.lminid);\n    a.lmax = -a.lmax; a.lmin = -a.lmin;\n    swap(a.rmax, a.rmin); swap(a.rmaxid, a.rminid);\n    a.rmax = -a.rmax; a.rmin = -a.rmin;\n    swap(a.maxv, a.minv); swap(a.maxl, a.minl); swap(a.maxr, a.minr);\n    a.maxv = -a.maxv; a.minv = -a.minv;\n}\ninline void pushdown(int x){\n    if(seg[x].rev){\n        rev(seg[x << 1]);\n        rev(seg[x << 1 | 1]);\n        seg[x].rev = false;\n    }\n}\nint n, m, a[N];\ninline void build(int x, int L, int R){\n    if(L == R){\n        seg[x] = Node(L, a[L]);\n        return;\n    }\n    int mid = L + R >> 1;\n    build(x << 1, L, mid);\n    build(x << 1 | 1, mid + 1, R);\n    pushup(x);\n}\ninline void change(int x, int L, int R, int pos, int val){\n    if(L == R){\n        seg[x] = Node(L, val);\n        return;\n    }\n    int mid = L + R >> 1;\n    pushdown(x);\n    if(pos <= mid) change(x << 1, L, mid, pos, val);\n    else change(x << 1 | 1, mid + 1, R, pos, val);\n    pushup(x);\n}\ninline void modify(int x, int L, int R, int l, int r){\n    if(l <= L && R <= r){\n        rev(seg[x]);\n        return;\n    }\n    int mid = L + R >> 1;\n    pushdown(x);\n    if(l <= mid) modify(x << 1, L, mid, l, r);\n    if(mid < r) modify(x << 1 | 1, mid + 1, R, l, r);\n    pushup(x);\n}\ninline Node query(int x, int L, int R, int l, int r){\n    if(l <= L && R <= r) return seg[x];\n    int mid = L + R >> 1;\n    pushdown(x);\n    if(r <= mid) return query(x << 1, L, mid, l, r);\n    else if(mid < l) return query(x << 1 | 1, mid + 1, R, l, r);\n    else return merge(query(x << 1, L, mid, l, r), query(x << 1 | 1, mid + 1, R, l, r));\n}\n//inline void dfs(int x, int L, int R){\n//    if(L == R){\n//        printf(\"%d \", seg[x].maxv);\n//        return;\n//    }\n//    int mid = L + R >> 1;\n//    pushdown(x);\n//    dfs(x << 1, L, mid);\n//    dfs(x << 1 | 1, mid + 1, R);\n//}\nint main(){\n    scanf(\"%d\", &n);\n    for(Rint i = 1;i <= n;i ++) scanf(\"%d\", a + i);\n    build(1, 1, n);\n    scanf(\"%d\", &m);\n    while(m --){\n        int opt, x, y, k;\n        scanf(\"%d%d%d\", &opt, &x, &y);\n        if(opt == 0)\n            change(1, 1, n, x, y);\n        else {\n            scanf(\"%d\", &k);\n            int ans = 0, pos = k;\n            for(Rint i = 1;i <= k;i ++){\n                q[i] = query(1, 1, n, x, y);\n                if(q[i].maxv <= 0){pos = i - 1; break;}\n                modify(1, 1, n, q[i].maxl, q[i].maxr);\n//                dfs(1, 1, n); puts(\"\");\n                ans += q[i].maxv;\n            }\n            for(Rint i = 1;i <= pos;i ++) modify(1, 1, n, q[i].maxl, q[i].maxr);\n            printf(\"%d\\n\", ans);\n        }\n    }\n}\n```",
        "postTime": 1553865202,
        "uid": 68148,
        "name": "watermoon",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "\u8fd9\u9898\u6709\u4e24\u4e2a\u5207\u5165\u70b9\uff1a\n\n- \u7ecf\u5178\u7684\u7f51\u7edc\u6d41\u6a21\u578b\n\n- \u53cd\u6094\u8d2a\u5fc3\n\n\u4f46\u6211\u4eec\u6700\u7ec8\u4f1a\u53d1\u73b0\u8fd9\u4e24\u4e2a\u5207\u5165\u70b9\u6b8a\u9014\u540c\u5f52\u3002\n\n\u5bf9\u4e8e\u7ecf\u5178\u7684\u7f51\u7edc\u6d41\u6a21\u578b\uff0c\u6211\u4eec\u60f3\u5230\u53d6\u4e0d\u8d85\u8fc7 $k$ \u4e2a\u5b50\u6bb5\uff0c\u8fd9\u4e00\u9650\u5236\u662f\u6d41\u91cf\u7684\u9650\u5236\uff0c\u800c\u603b\u548c\u6700\u5927\uff0c\u5219\u662f\u4ee4\u8d39\u7528\u6700\u5927\uff0c\u6240\u4ee5\u5efa\u56fe\u8dd1\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u3002$\\forall i$\uff0c\u4ece $S\\to i$ \u8fde\u4e00\u6761\u6d41\u91cf\u4e3a $1$\uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\uff0c\u4ece $i\\to i+1$ \u8fde\u4e00\u6761\u6d41\u91cf\u4e3a $0$\uff0c\u8d39\u7528\u4e3a $a_i$ \u7684\u8fb9\uff0c\u4ece $i\\to T$ \u8fde\u4e00\u6761\u6d41\u91cf\u4e3a $1$\uff0c\u8d39\u7528\u4e3a $0$ \u7684\u8fb9\u3002\u5c06 $S$ \u7684\u521d\u59cb\u6d41\u91cf\u8bbe\u4e3a $k$\u3002\u8fd9\u6837\u5f88\u660e\u663e\u4f1a $\\text{TLE}$\u3002\u4e8e\u662f\u8003\u8651\u6a21\u62df\u8d39\u7528\u6d41\u3002\u6211\u4eec\u89c2\u5bdf\u5230\u6bcf\u6b21\u589e\u5e7f\u51fa\u7684\u4e00\u6761\u8def\u5f84 $S\\to L\\to R\\to T$\uff0c\u90fd\u662f\u5728\u5e8f\u5217\u4e0a\u53d6 $[L,R-1]$ \u8fd9\u4e00\u6bb5\uff0c\u7136\u540e\u5c06\u8fd9\u4e00\u6bb5\u5728\u7f51\u7edc\u4e0a\u5efa\u5bf9\u5e94\u7684\u53cd\u5411\u5f27\u3002\u4e8b\u5b9e\u4e0a\u5c31\u662f\u53d6\u51fa\u5f53\u524d\u7684\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u7136\u540e\u5c06\u8fd9\u4e00\u6bb5 $\\times -1$\u3002\n\n\u800c\u53cd\u6094\u8d2a\u5fc3\uff0c\u5219\u662f\u5148\u8003\u8651\u53d6\u5f53\u524d\u6700\u4f18\uff0c\u7136\u540e\u5c06\u53d6\u8fc7\u7684 $\\times -1$\uff0c\u5982\u679c\u540e\u7eed\u53d6\u5230\u4e86\u8fd9\u4e9b $\\times -1$ \u7684\u70b9\u5219\u610f\u5473\u7740\u6211\u4eec\u53cd\u6094\u4e86\uff0c\u4e0d\u518d\u53d6\u8fd9\u4e9b\u70b9\u3002\u901a\u8fc7\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u53cd\u6094\u7684\u64cd\u4f5c\uff0c\u4ee5\u786e\u4fdd\u8d2a\u5fc3\u7684\u6b63\u786e\u6027\u3002\n\n\u4e3a\u4ec0\u4e48\u8fd9\u4e24\u4e2a\u5207\u5165\u70b9\u7684\u6700\u7ec8\u89e3\u51b3\u65b9\u6848\u90fd\u662f\u4e00\u6837\u7684\u5462\uff1f\u539f\u6765\u662f\u56e0\u4e3a\u7f51\u7edc\u6d41\u6c42\u89e3\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u65f6\uff0c\u672c\u8d28\u9075\u5faa\u7684\u5c31\u662f\u4e00\u4e2a\u53cd\u6094\u8d2a\u5fc3\u7b56\u7565\uff1a\u53d6\u5f53\u524d\u589e\u5e7f\u8def\uff0c\u5e76\u5c06\u589e\u5e7f\u8fc7\u7684\u8fb9\u5efa\u53cd\u5411\u5f27\u3002\u8fd9\u4e5f\u5c31\u63ed\u793a\u4e86\uff0c\u6a21\u62df\u7f51\u7edc\u6d41\u4e0e\u53cd\u6094\u8d2a\u5fc3\u7684\u4e00\u4e9b\u5171\u901a\u4e4b\u5904\u3002\n\n\u90a3\u4e48\u6211\u4eec\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u652f\u6301\u533a\u95f4\u53d6\u53cd\uff0c\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u533a\u95f4\u6700\u5c0f\u5b50\u6bb5\u548c\u7684\u5bf9\u5e94\u4fe1\u606f\u5373\u53ef\u3002\u6ce8\u610f\u4e0b\u653e\u6807\u8bb0\u3002\n\n\u6700\u540e\u7ebf\u6bb5\u6811\u7684\u5b9e\u73b0\u53cd\u5012\u6ca1\u6709\u90a3\u4e48\u91cd\u8981\uff0c\u5927\u529b\u7801\u4ee3\u7801\u5c31\u662f\u4e86\uff0c\u53cd\u6b63\u4e5f\u5c31\u624d $\\text{180}$ \u884c\u662f\u5427\uff08\u5149\u901f\u9003\n\n$\\text{tips}$\uff1a\u5899\u88c2\u63a8\u8350\u5199\u7801\u519c\u9898\u65f6\u4f7f\u7528\u5e26\u4ee3\u7801\u8865\u5168\u7684\u7f16\u8f91\u5668\uff0c\u50cf $\\text{VSCode}$ \u4e4b\u7c7b\u7684\u3002\u53d8\u91cf\u540d\u4e00\u5b9a\u8981\u60f3\u597d\uff0c\u7f3a\u4e4f\u60f3\u8c61\u529b\u4f1a\u5bfc\u81f4\u4f60\u6ca1\u6709\u8db3\u591f\u7684\u53d8\u91cf\u540d\u6765\u63cf\u8ff0\u7ed3\u6784\u4f53\u4e2d\u591a\u8fbe\u81f3\u5c11 $14$ \u4e2a\u91cf\uff08\u5212\u6389\n\n```cpp\n/*\nEditor:VSCode- for more quickly coding.\nWriter:tommy0103\nMotto:Karry5307 yyds!\n*/\n#include<cstdio>\n#include<functional>\n#define ls p<<1\n#define rs p<<1|1\ntypedef long long ll;\nint a[100005];\nstd::pair<int,int> st[35];\nstruct Segment {\n    int rev,sum,l,r;\n    int maxLen,maxLval,maxRval,maxL,maxR,maxLenL,maxLenR;\n    int minLen,minLval,minRval,minL,minR,minLenL,minLenR;\n}t[400005];\ninline int read() {\n    register int x=0,f=1;register char s=getchar();\n    while(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}\n    while(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}\n    return x*f;\n}\ninline void swap(int &x,int &y) {int tmp=x;x=y;y=tmp;}\ninline void work(Segment &x,int v1,int v2) {//v1=pos,v2=val\n    x.sum=v2; x.rev=0;\n    x.maxLen=x.maxLval=x.maxRval=v2;\n    x.maxL=x.maxR=x.maxLenL=x.maxLenR=v1;\n    x.minLen=x.minLval=x.minRval=v2;\n    x.minL=x.minR=x.minLenL=x.minLenR=v1;\n}\ninline void work(Segment &x) {\n    x.sum*=-1;\n    swap(x.maxLen,x.minLen); x.minLen*=-1; x.maxLen*=-1;\n    swap(x.maxLval,x.minLval); x.maxLval*=-1; x.minLval*=-1;\n    swap(x.maxRval,x.minRval); x.maxRval*=-1; x.minRval*=-1;\n    swap(x.maxL,x.minL); swap(x.maxR,x.minR);\n    swap(x.maxLenL,x.minLenL); swap(x.maxLenR,x.minLenR);\n}\ninline void spread(int p) {\n    if(t[p].rev) {\n        t[ls].rev^=1; work(t[ls]);\n        t[rs].rev^=1; work(t[rs]);\n        t[p].rev=0;\n    }\n}\ninline Segment merge(const Segment &x,const Segment &y) {\n    Segment res=(Segment){0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\n    int l=x.l,r=y.r; res.sum=x.sum+y.sum; res.l=l; res.r=r;\n    if(x.maxLval<y.maxLval+x.sum) {\n        res.maxLval=y.maxLval+x.sum;\n        res.maxL=y.maxL; \n    }\n    else {\n        res.maxLval=x.maxLval;\n        res.maxL=x.maxL;\n    }\n    if(y.maxRval<x.maxRval+y.sum) {\n        res.maxRval=x.maxRval+y.sum;\n        res.maxR=x.maxR;\n    }\n    else {\n        res.maxRval=y.maxRval;\n        res.maxR=y.maxR;\n    }\n\n    if(x.maxLen>y.maxLen) {\n        res.maxLen=x.maxLen;\n        res.maxLenL=x.maxLenL;\n        res.maxLenR=x.maxLenR;\n    }\n    else {\n        res.maxLen=y.maxLen;\n        res.maxLenL=y.maxLenL;\n        res.maxLenR=y.maxLenR;\n    }\n    if(x.maxRval+y.maxLval>res.maxLen) {\n        res.maxLen=x.maxRval+y.maxLval;\n        res.maxLenL=x.maxR; \n        res.maxLenR=y.maxL;\n    }\n    if(res.maxRval>res.maxLen) {\n        res.maxLen=res.maxRval;\n        res.maxLenL=res.maxR;\n        res.maxLenR=r;\n    }\n    if(res.maxLval>res.maxLen) {\n        res.maxLen=res.maxLval;\n        res.maxLenL=l;\n        res.maxLenR=res.maxL;\n    }\n\n    if(x.minLval>y.minLval+x.sum) {\n        res.minLval=y.minLval+x.sum;\n        res.minL=y.minL; \n    }\n    else {\n        res.minLval=x.minLval;\n        res.minL=x.minL;\n    }\n    if(y.minRval>x.minRval+y.sum) {\n        res.minRval=x.minRval+y.sum;\n        res.minR=x.minR;\n    }\n    else {\n        res.minRval=y.minRval;\n        res.minR=y.minR;\n    }\n\n    if(x.minLen<y.minLen) {\n        res.minLen=x.minLen;\n        res.minLenL=x.minLenL;\n        res.minLenR=x.minLenR;\n    }\n    else {\n        res.minLen=y.minLen;\n        res.minLenL=y.minLenL;\n        res.minLenR=y.minLenR;\n    }\n    if(x.minRval+y.minLval<res.minLen) {\n        res.minLen=x.minRval+y.minLval;\n        res.minLenL=x.minR; \n        res.minLenR=y.minL;\n    }\n    if(res.minRval<res.minLen) {\n        res.minLen=res.minRval;\n        res.minLenL=res.minR;\n        res.minLenR=r;\n    }\n    if(res.minLval<res.minLen) {\n        res.minLen=res.minLval;\n        res.minLenL=l;\n        res.minLenR=res.minL;\n    }\n    return res;\n}\ninline void pushup(int p) {t[p]=merge(t[ls],t[rs]);}\ninline void build(int p,int l,int r) {\n    t[p].l=l; t[p].r=r;\n    if(l==r) {work(t[p],l,a[l]); return;}\n    int mid=l+r>>1; build(ls,l,mid); build(rs,mid+1,r);\n    pushup(p);\n}\ninline void change_cov(int p,int l,int r,int x,int val) {\n    if(l==r) {work(t[p],l,val); return;}\n    int mid=l+r>>1; spread(p);\n    if(x<=mid) change_cov(ls,l,mid,x,val);\n    else change_cov(rs,mid+1,r,x,val);\n    pushup(p);\n}\ninline void change_rev(int p,int l,int r,int L,int R) {\n    if(L<=l&&r<=R) {t[p].rev^=1; work(t[p]); return;}\n    int mid=l+r>>1; spread(p);\n    if(L<=mid) change_rev(ls,l,mid,L,R);\n    if(R>mid) change_rev(rs,mid+1,r,L,R);\n    pushup(p);\n} \ninline Segment ask(int p,int l,int r,int L,int R) {\n    if(L<=l&&r<=R) return t[p];\n    int mid=l+r>>1; spread(p);\n    if(L>mid) return ask(rs,mid+1,r,L,R);\n    if(R<=mid) return ask(ls,l,mid,L,R);\n    return merge(ask(ls,l,mid,L,mid),ask(rs,mid+1,r,mid+1,R));//L<=mid&&R>mid\n}\nint main() {\n    int n=read();\n    for(register int i=1;i<=n;++i) a[i]=read();\n    build(1,1,n); int Q=read();\n    while(Q--) {\n        int op=read();\n        if(op==0) {int x=read(),val=read();change_cov(1,1,n,x,val);}\n        else {\n            int l=read(),r=read(),k=read(),top=0; ll ans=0;\n            for(register int round=1;round<=k;++round) {\n                Segment res=ask(1,1,n,l,r); if(res.maxLen<=0) break; ans+=res.maxLen;  \n                change_rev(1,1,n,res.maxLenL,res.maxLenR); \n                st[++top]=std::make_pair(res.maxLenL,res.maxLenR);\n            }\n            while(top) {change_rev(1,1,n,st[top].first,st[top].second); --top;}\n            printf(\"%lld\\n\",ans);\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1603432357,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "# \u9898\u76ee\u5927\u6982\u7684\u610f\u601d\n> \u7ed9\u4e00\u5217\u6570\uff0c\u8981\u6c42\u652f\u6301\u64cd\u4f5c\uff1a \n>\n> 1.\u4fee\u6539\u67d0\u4e2a\u6570\u7684\u503c \n>\n> 2.\u8bfb\u5165l,r,k\uff0c\u8be2\u95ee\u5728[l,r]\u5185\u9009\u4e0d\u76f8\u4ea4\u7684\u4e0d\u8d85\u8fc7k\u4e2a\u5b50\u6bb5\uff0c\u6700\u5927\u7684\u548c\u662f\u591a\u5c11\u3002\n\n# \u89e3\u6cd5\n\u6211\u662f\u6c42\u6700\u5927\u5b57\u6bb5\u548c\uff0c\u518d\u7528\u4e0a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u6709\u4e24\u79cd\u60c5\u51b5\uff1a\n\n1. \u6c42\u6700\u5927\u5b57\u6bb5\u548c \n1. \u2460\u6c42\u6700\u5927\u5b57\u6bb5\u548c+\u53e6\u4e00\u90e8\u5206\u7684\u7b2c\u4e8c\u5927\u7684\u5b57\u6bb5\u548c\n\n\t\u2461 \u6700\u5927\u5b57\u6bb5\u548c-\u6700\u5927\u5b57\u6bb5\u548c\u91cc\u9762\u7684\u6700\u5927\u5b57\u6bb5\u548c\n\n# \u4e0a\u4ee3\u7801\nPS:\u7ba1\u7406\u5927\u5927\uff0cnamespace\u662f\u5feb\u8bfb\u548ctypedef\uff0c\u4e0d\u8981\u8ba4\u4e3a\u662f\u9884\u5904\u7406\u554aQwQ\n\n```cpp\n//#pragma GCC optimize(2)\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n\nnamespace tydef {\n\ttypedef double db;\n\ttypedef long long LL;\n\ttypedef unsigned long long ULL;\n}\n\nnamespace io {//\u5feb\u8bfb\n#define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)\n\tconst int SIZ = 1 << 21 | 1;\n\tchar* iS, * iT, ibuff[SIZ], obuff[SIZ], * oS = obuff, * oT = oS + SIZ - 1, fu[110], c;\n\tint fr;\n\tinline void out() {\n\t\tfwrite(obuff, 1, oS - obuff, stdout);\n\t\toS = obuff;\n\t}\n\ttemplate<class Type>\n\tinline void read(Type& x) {\n\t\tx = 0;\n\t\tType y = 1;\n\t\tfor (c = gc(); (c > '9' || c < '0') && c != '-'; c = gc());\n\t\tc == '-' ? y = -1 : x = (c & 15);\n\t\tfor (c = gc(); c >= '0' && c <= '9'; c = gc())\n\t\t\tx = x * 10 + (c & 15);\n\t\tx *= y;\n\t}\n}\n\nusing namespace tydef;\nusing namespace io;\nusing namespace std;\n\n//\u4e3a\u4e86\u65b9\u4fbf\uff0c\u628afor\u5199\u5230define\u91cc\u4e86\n#define rep(q,a,b) for(int q=a,q##_end_=b;q<=q##_end_;++q)\n#define dep(q,a,b) for(int q=a,q##_end_=b;q>=q##_end_;--q)\n#define mem(a,b) memset(a,b,sizeof a )\n\nconst int mn = 100005;\nint val[mn];\nbool mark[mn << 2];\nstruct node {\n\tint Max_l, l, Max_r, r, Max, L, R, Sum;\n}Mx[mn << 2];\nnode meg(node l, node r) {\n\tnode now = { l.Max_l,l.l,r.Max_r,r.r };\n\tif (l.Max > r.Max)now.Max = l.Max, now.L = l.L, now.R = l.R;\n\telse now.Max = r.Max, now.L = r.L, now.R = r.R;\n\tif (l.Sum + r.Max_l > now.Max_l) {\n\t\tnow.Max_l = l.Sum + r.Max_l;\n\t\tnow.l = r.l;\n\t}\n\tif (r.Sum + l.Max_r > now.Max_r) {\n\t\tnow.Max_r = r.Sum + l.Max_r;\n\t\tnow.r = l.r;\n\t}\n\tif (l.Max_r + r.Max_l > now.Max) {\n\t\tnow.Max = l.Max_r + r.Max_l;\n\t\tnow.L = l.r, now.R = r.l;\n\t}\n\tnow.Sum = l.Sum + r.Sum;\n\treturn now;\n}\n//\u7ebf\u6bb5\u6811\u7684\u4e00\u7cfb\u5217\u64cd\u4f5c\nstruct node1 {\n\tint Min_l, l, Min_r, r, Min, L, R, Sum;\n}Mi[mn << 2];\nnode res(node1 a) {\n\treturn { -a.Min_l,a.l,-a.Min_r,a.r,-a.Min,a.L,a.R,-a.Sum };\n}\nnode1 res(node a) {\n\treturn { -a.Max_l,a.l,-a.Max_r,a.r,-a.Max,a.L,a.R,-a.Sum };\n}\n\nvoid max_up(int o) {\n\tnode l = mark[o << 1] ? res(Mi[o << 1]) : Mx[o << 1];\n\tnode r = mark[o << 1 | 1] ? res(Mi[o << 1 | 1]) : Mx[o << 1 | 1];\n\tMx[o] = meg(l, r);\n}\nnode1 meg(node1 l, node1 r) {\n\tnode1 now = { l.Min_l,l.l,r.Min_r,r.r };\n\tif (l.Min < r.Min)now.Min = l.Min, now.L = l.L, now.R = l.R;\n\telse now.Min = r.Min, now.L = r.L, now.R = r.R;\n\tif (l.Sum + r.Min_l < now.Min_l) {\n\t\tnow.Min_l = r.Min_l + l.Sum;\n\t\tnow.l = r.l;\n\t}\n\tif (r.Sum + l.Min_r < now.Min_r) {\n\t\tnow.Min_r = l.Min_r + r.Sum;\n\t\tnow.r = l.r;\n\t}\n\tif (r.Min_l + l.Min_r < now.Min) {\n\t\tnow.Min = l.Min_r + r.Min_l;\n\t\tnow.L = l.r, now.R = r.l;\n\t}\n\tnow.Sum = l.Sum + r.Sum;\n\treturn now;\n}\nvoid min_up(int o) {\n\tnode1 l = mark[o << 1] ? res(Mx[o << 1]) : Mi[o << 1];\n\tnode1 r = mark[o << 1 | 1] ? res(Mx[o << 1 | 1]) : Mi[o << 1 | 1];\n\tMi[o] = meg(l, r);\n}\nvoid up(int o) {\n\tmin_up(o);\n\tmax_up(o);\n}\nvoid build(int o, int l, int r) {\n\tif (l == r) {\n\t\tMx[o] = { val[l],l,val[l],l,val[l],l,l,val[l] };\n\t\tMi[o] = { val[l],l,val[l],l,val[l],l,l,val[l] };\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(o << 1, l, mid);\n\tbuild(o << 1 | 1, mid + 1, r);\n\tup(o);\n}\n\nint y_1, y_2, ad_v;\nvoid change(int o, int l, int r) {\n\tif (l == r) {\n\t\tMx[o] = { ad_v,l,ad_v,l,ad_v,l,l,ad_v };\n\t\tMi[o] = { ad_v,l,ad_v,l,ad_v,l,l,ad_v };\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tif (y_1 <= mid)change(o << 1, l, mid);\n\telse change(o << 1 | 1, mid + 1, r);\n\tup(o);\n}\nvoid Mark(int o, int l, int r) {\n\tif (y_1 <= l && r <= y_2)mark[o] ^= 1;\n\telse {\n\t\tint mid = l + r >> 1;\n\t\tif (y_1 <= mid)Mark(o << 1, l, mid);\n\t\tif (y_2 > mid)Mark(o << 1 | 1, mid + 1, r);\n\t\tup(o);\n\t}\n}\nnode query(int o, int l, int r, bool mk) {\n\tmk ^= mark[o];\n\tif (y_1 <= l && r <= y_2)return mk ? res(Mi[o]) : Mx[o];\n\telse {\n\t\tint mid = l + r >> 1;\n\t\tif (y_2 <= mid)return query(o << 1, l, mid, mk);\n\t\tif (y_1 > mid)return query(o << 1 | 1, mid + 1, r, mk);\n\t\treturn meg(query(o << 1, l, mid, mk), query(o << 1 | 1, mid + 1, r, mk));\n\t}\n}\nint n, m;\nvoid change(int x, int k) {\n\ty_1 = x, ad_v = k;\n\tchange(1, 1, n);\n}\n\n\npair<int, int> que[100];\nint ask(int l, int r, int k) {\n\tint td = 0, ans = 0;\n\twhile (k--) {\n\t\ty_1 = l, y_2 = r;\n\t\tnode now = query(1, 1, n, 0);\n\t\tif (now.Max < 0)break;\n\t\tans += now.Max;\n\t\ty_1 = now.L, y_2 = now.R;\n\t\tMark(1, 1, n);\n\t\tque[++td] = { now.L,now.R };\n\t}\n\tdep(q, td, 1) {\n\t\ty_1 = que[q].first, y_2 = que[q].second;\n\t\tMark(1, 1, n);\n\t}\n\treturn ans;\n}\nint main() {\n\tread(n);\n\trep(q, 1, n) read(val[q]);\n\tbuild(1, 1, n);\n\tread(m);\n\tint ty, l, r, k;\n\twhile (m--) {\n\t\tread(ty);\n\t\tif (!ty) {\n\t\t\tread(l), read(k);\n\t\t\tchange(l, k);\n\t\t}\n\t\telse {\n\t\t\tread(l), read(r), read(k);\n\t\t\tprintf(\"%d\\n\", ask(l, r, k));\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1574172604,
        "uid": 144417,
        "name": "bradfordzhang",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "[\u672c\u849f\u84bb\u7684Blog](https://www.chnxuzhiyuan.cn/2019/07/10/%E3%80%8CCF280D%E3%80%8Dk-Maximum-Subsequence-Sum-Solution/)\n\n### \u9898\u89e3\n\n\u9996\u5148\u53ef\u4ee5\u8003\u8651\u4e00\u4e2a\u8d2a\u5fc3\uff0c\u6bcf\u6b21\u53d6\u8be2\u95ee\u533a\u95f4\u5185\u6743\u503c\u548c\u6700\u5927\u7684\u5b50\u6bb5\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u5b50\u6bb5\u6807\u8bb0\u4e0a\uff0c\u8be5\u6b21\u8be2\u95ee\u4e2d\u4e0d\u80fd\u518d\u53d6\u3002\n\n\u4f46\u662f\u8fd9\u4e2a\u60f3\u6cd5\u5e76\u4e0d\u5bf9\uff0c\u6bd4\u5982\u5e8f\u5217$3,-1,3$\uff0c\u53ef\u4ee5\u53d6\u81f3\u591a2\u4e2a\u5b50\u6bb5\u3002\u7531\u4e8e\u7b2c\u4e00\u6b21\u4f1a\u53d6\u6743\u503c\u6700\u5927\u7684\u5b50\u6bb5$[1,3]$\uff0c\u7136\u540e\u5c31\u6ca1\u6709\u5b50\u6bb5\u53ef\u4ee5\u53d6\u4e86\u3002\u800c\u5b9e\u9645\u4e0a\u53d6$[1,1]$\u548c$[3,3]$\u7684\u8bdd\u7b54\u6848\u4f1a\u66f4\u4f18\u3002\n\n\u7136\u540e\u4e0d\u96be\u8054\u60f3\u5230\uff0c\u5728\u6c42\u6700\u5927\u6d41\u7684\u65f6\u5019\uff0c\u6211\u4eec\u901a\u8fc7\u5efa\u53cd\u5411\u5f27\u7684\u65b9\u5f0f\u6765\u4fdd\u8bc1\u4e86\u6b63\u786e\u6027\u3002\n\n\u6240\u4ee5\u5bf9\u4e8e\u8fd9\u9898\uff0c\u53ef\u4ee5\u5728\u53d6\u4e86\u4e00\u4e2a\u5b50\u6bb5\u4e4b\u540e\uff0c\u5c06\u6539\u5b50\u6bb5\u53d6\u53cd\uff0c\u4e4b\u540e\u8fd8\u80fd\u518d\u53d6\uff0c\u6765\u4fdd\u8bc1\u6b63\u786e\u6027\u3002\n\n\u800c\u53d6\u53cd\u548c\u53d6\u6700\u5927\u503c\u7684\u64cd\u4f5c\u90fd\u53ef\u4ee5\u901a\u8fc7\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(n\\log n+mk\\log n)$\u3002\n\n### \u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxn=100005;\nint n,Q,A[maxn];\ninline int read()\n{\n\tint ret=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){ret=ret*10+ch-'0';ch=getchar();}\n\treturn ret*f;\n}\nstruct Range\n{\n\tint L,R,Sum;\n\tinline bool operator < (const Range& b)const{return Sum<b.Sum;}\n\tinline Range operator + (const Range& b)const{return (Range){L,b.R,Sum+b.Sum};}\n}Ra[25];\nstruct SegmentTree\n{\n\tstruct Node{Range Lmax,Rmax,Max,Lmin,Rmin,Min,All;bool Tag;}Tree[maxn*4];\n\tinline void Merge(Node& a,Node b,Node c)\n\t{\n\t\ta.All=b.All+c.All;\n\t\ta.Lmin=min(b.Lmin,b.All+c.Lmin);a.Rmin=min(c.Rmin,b.Rmin+c.All);\n\t\ta.Lmax=max(b.Lmax,b.All+c.Lmax);a.Rmax=max(c.Rmax,b.Rmax+c.All);\n\t\ta.Max=max(max(b.Max,c.Max),b.Rmax+c.Lmax);a.Min=min(min(b.Min,c.Min),b.Rmin+c.Lmin);\n\t}\n\tinline void PushUp(int rt){Merge(Tree[rt],Tree[rt*2],Tree[rt*2+1]);}\n\tinline void Reverse(int rt)\n\t{\n\t\tTree[rt].Lmin.Sum*=-1;Tree[rt].Lmax.Sum*=-1;\n\t\tTree[rt].Rmin.Sum*=-1;Tree[rt].Rmax.Sum*=-1;\n\t\tTree[rt].Min.Sum*=-1;Tree[rt].Max.Sum*=-1;Tree[rt].All.Sum*=-1;\n\t\tswap(Tree[rt].Min,Tree[rt].Max);swap(Tree[rt].Lmax,Tree[rt].Lmin);swap(Tree[rt].Rmax,Tree[rt].Rmin);\n\t}\n\tinline void PushDown(int rt)\n\t{\n\t\tif(Tree[rt].Tag)\n\t\t{\n\t\t\tReverse(rt*2);Reverse(rt*2+1);\n\t\t\tTree[rt*2].Tag^=1;Tree[rt*2+1].Tag^=1;Tree[rt].Tag^=1;\n\t\t}\n\t}\n\tinline void Build(int L=1,int R=n,int rt=1)\n\t{ \n\t\tif(L==R){Tree[rt].All=Tree[rt].Lmax=Tree[rt].Lmin=Tree[rt].Max=Tree[rt].Min=Tree[rt].Rmax=Tree[rt].Rmin=(Range){L,R,A[L]};return;}\n\t\tint M=(L+R)>>1;\n\t\tBuild(L,M,rt*2);\n\t\tBuild(M+1,R,rt*2+1);\n\t\tPushUp(rt);\n\t}\n\tinline void UpdatePoint(int P,int V,int L=1,int R=n,int rt=1)\n\t{\n\t\tif(L==R){Tree[rt].All.Sum=Tree[rt].Lmax.Sum=Tree[rt].Lmin.Sum=Tree[rt].Max.Sum=Tree[rt].Min.Sum=Tree[rt].Rmax.Sum=Tree[rt].Rmin.Sum=V;return;}\n\t\tint M=(L+R)>>1;PushDown(rt);\n\t\tif(P<=M) UpdatePoint(P,V,L,M,rt*2);\n\t\tif(M<P) UpdatePoint(P,V,M+1,R,rt*2+1);\n\t\tPushUp(rt);\n\t}\n\tinline Node QueryMax(int LL,int RR,int L=1,int R=n,int rt=1)\n\t{\n\t\tif(LL<=L&&R<=RR) return Tree[rt];\n\t\tint M=(L+R)>>1;Node ret;PushDown(rt);\n\t\tif(LL<=M) ret=QueryMax(LL,RR,L,M,rt*2);\n\t\tif(M<RR)\n\t\t{\n\t\t\tif(LL>M) ret=QueryMax(LL,RR,M+1,R,rt*2+1);\n\t\t\telse Merge(ret,ret,QueryMax(LL,RR,M+1,R,rt*2+1));\n\t\t}\n\t\treturn ret;\n\t}\n\tinline void UpdateRange(int LL,int RR,int L=1,int R=n,int rt=1)\n\t{\n\t\tif(LL<=L&&R<=RR){Reverse(rt);Tree[rt].Tag^=1;return;}\n\t\tint M=(L+R)>>1;PushDown(rt);\n\t\tif(LL<=M) UpdateRange(LL,RR,L,M,rt*2);\n\t\tif(M<RR) UpdateRange(LL,RR,M+1,R,rt*2+1);\n\t\tPushUp(rt);\n\t}\n}S;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) A[i]=read();\n\tQ=read();S.Build();\n\twhile(Q--)\n\t{\n\t\tif(read()==0)\n\t\t{\n\t\t\tint P=read(),V=read();\n\t\t\tS.UpdatePoint(P,V);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint L=read(),R=read(),K=read(),cnt,ans=0;\n\t\t\tfor(cnt=0;cnt<K;cnt++)\n\t\t\t{\n\t\t\t\tSegmentTree::Node tep=S.QueryMax(L,R);\n\t\t\t\tif(tep.Max.Sum<=0) break;\n\t\t\t\tans+=tep.Max.Sum;\n\t\t\t\tS.UpdateRange(tep.Max.L,tep.Max.R);\n\t\t\t\tRa[cnt]=tep.Max;\n\t\t\t}\n\t\t\tfor(int i=0;i<cnt;i++)\n\t\t\t\tS.UpdateRange(Ra[i].L,Ra[i].R);\n\t\t\tprintf(\"%d\\n\",ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1566105052,
        "uid": 42392,
        "name": "\u5f90\u81f4\u8fdc",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "[\u9898\u4f20](https://www.luogu.com.cn/problem/CF280D)\n\n\u53d1\u73b0 $k$ \u5f88\u5c0f\uff0c\u5728\u4e0a\u9762\u505a\u6587\u7ae0\u3002\n\n\u5982\u679c $k=1$\uff0c\u90a3\u4e48\u5c31\u662f\u4e00\u7ebf\u6bb5\u6811\u677f\u5b50\uff0c\u987a\u5e26\u80fd\u8d44\u74f7\u5355\u70b9\u4fee\u6539\u3002\n\n\u8003\u8651\u53cd\u6094\u8d2a\u5fc3\uff0c\u5f53\u6211\u4eec\u9009\u4e86\u4e00\u6bb5\u6781\u957f\u7684\u6bb5\uff0c\u5b83\u4e0d\u4e00\u5b9a\u662f\u6700\u4f18\u7684\uff0c\u6211\u4eec\u53ef\u80fd\u4e0d\u9700\u8981\u5176\u4e2d\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u5176\u672c\u8d28\u4e0a\u662f\u65b0\u52a0\u7684\u4e00\u6bb5\u9009\u53d6\u4e86\u8fd9\u4e00\u90e8\u5206\uff0c\u540c\u65f6\u4e22\u6389\u4e86\u67d0\u4e00\u90e8\u5206\uff0c\u76f8\u5f53\u4e8e\u201c\u501f\u201d\u4e00\u6bb5\u7ed9\u65b0\u7684\uff0c\u9700\u8981\u6d88\u6389\u8fd9\u4e00\u90e8\u5206\u5728\u539f\u4e32\u7684\u8d21\u732e\uff0c\u4e8e\u662f\u60f3\u5230\u5c06\u9009\u53d6\u7684\u4e00\u6bb5\u4e58\u4e0a -1\uff0c\u518d\u53d6\u6700\u5927\u8fde\u7eed\u6bb5\u3002\n\n\n\u90a3\u4e48\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u53ea\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u53d6\u53cd\u7684\u64cd\u4f5c\uff0c\u76f8\u5f53\u4e8e\u8fd9\u4e00\u6574\u6bb5\u7684\u5927\u503c\u53d8\u5c0f\uff0c\u5c0f\u503c\u53d8\u5927\uff0c\u6240\u4ee5\u518d\u7ef4\u62a4\u4e00\u4e2a\u5168\u5c40\u6700\u5c0f\u5b50\u6bb5\u548c\uff0c\u53d6\u53cd\u65f6\u5c06 \u6700\u5927/\u6700\u5c0f \u7684\u4e92\u6362\u5373\u53ef\u3002\n\n\u6ce8\u610f\u6bcf\u4e2a\u8be2\u95ee\u4e92\u4e0d\u5f71\u54cd\uff0c\u6240\u4ee5\u8bb0\u5f97\u5c06\u6240\u6709\u53d6\u8fc7\u7684\u90fd\u6d88\u56de\u53bb\u3002~~\u7136\u540e\u5bfc\u81f4\u7801\u91cf\u5927\u5e45\u589e\u52a0~~\n\n\u590d\u6742\u5ea6 $O(nk \\log n)$\uff0c\u633a\u597d\u5199\u7684\u3002\n\n### Code\uff1a\n\n```cpp\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\nusing namespace std;\ninline int read(){\n\tchar ch=getchar();int x=0, f=1;\n\twhile(!isdigit(ch)) f=(ch=='-'?-1:f), ch=getchar();\n\twhile(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0', ch=getchar();\n\treturn x*f;\n}\ninline void Swp(int &a, int &b){int t=a;a=b, b=t;return ;}\nconst int N=1e5+5;\nstruct node{\n\tint L, R, sum, tag;\n\tint lmax, rmax, Mx, Rx, Lx, LXans, RXans;\n\tint lmin, rmin, Mn, Rn, Ln, LNans, RNans;\n\tvoid spread(){\n\t\tsum=-sum;tag^=1;\n\t\tswap(lmax, lmin), swap(rmax, rmin), swap(Mx, Mn);\n\t\tswap(Rx, Rn), swap(Lx, Ln), swap(LXans, LNans), swap(RXans, RNans);\n\t\tlmax=-lmax, lmin=-lmin;\n\t\trmax=-rmax, rmin=-rmin;\n\t\tMx=-Mx, Mn=-Mn;\n\t\treturn ;\n\t}\n}tree[N*4];\nnode Newnode(int pos, int val){\n\treturn (node){pos, pos, val, 0, val, val, val, pos, pos, pos, pos, val, val, val, pos, pos, pos, pos};\n}\nnode operator + (node A, node B){\n\tnode C;C.sum=A.sum+B.sum, C.L=A.L, C.R=B.R;C.tag=0;\n\t\n\tif(A.sum+B.lmax>A.lmax) C.lmax=A.sum+B.lmax, C.Rx=B.Rx;\n\telse C.lmax=A.lmax, C.Rx=A.Rx;\n\tif(B.sum+A.rmax>B.rmax) C.rmax=B.sum+A.rmax, C.Lx=A.Lx;\n\telse C.rmax=B.rmax, C.Lx=B.Lx;\n\tif(A.sum+B.lmin<A.lmin) C.lmin=A.sum+B.lmin, C.Rn=B.Rn;\n\telse C.lmin=A.lmin, C.Rn=A.Rn;\n\tif(B.sum+A.rmin<B.rmin) C.rmin=B.sum+A.rmin, C.Ln=A.Ln;\n\telse C.rmin=B.rmin, C.Ln=B.Ln;\n\t\n\tint Maxi=max(max(max(C.lmax, C.rmax), A.rmax+B.lmax), max(A.Mx, B.Mx));\n\tif(Maxi==C.lmax) C.LXans=C.L, C.RXans=C.Rx;\n\telse if(Maxi==C.rmax) C.LXans=C.Lx, C.RXans=C.R;\n\telse if(Maxi==A.rmax+B.lmax) C.LXans=A.Lx, C.RXans=B.Rx;\n\telse if(Maxi==A.Mx) C.LXans=A.LXans, C.RXans=A.RXans;\n\telse if(Maxi==B.Mx) C.LXans=B.LXans, C.RXans=B.RXans;\n\tC.Mx=Maxi;\n\t\n\tint Mini=min(min(min(C.lmin, C.rmin), A.rmin+B.lmin), min(A.Mn, B.Mn));\n\tif(Mini==C.lmin) C.LNans=C.L, C.RNans=C.Rn;\n\telse if(Mini==C.rmin) C.LNans=C.Ln, C.RNans=C.R;\n\telse if(Mini==A.rmin+B.lmin) C.LNans=A.Ln, C.RNans=B.Rn;\n\telse if(Mini==A.Mn) C.LNans=A.LNans, C.RNans=A.RNans;\n\telse if(Mini==B.Mn) C.LNans=B.LNans, C.RNans=B.RNans;\n\tC.Mn=Mini;\n\t\n\treturn C;\n}\nint n, m, a[N];\n#define ls k<<1\n#define rs k<<1|1\n#define mid (tree[k].L+tree[k].R>>1)\nvoid pushup(int k){tree[k]=tree[ls]+tree[rs];}\nvoid pushdown(int k){\n\tif(!tree[k].tag) return ;\n\ttree[ls].spread(), tree[rs].spread();tree[k].tag=0;\n\treturn ;\n}\nvoid build(int k, int l, int r){\n\ttree[k].L=l, tree[k].R=r, tree[k].tag=0;\n\tif(l==r){tree[k]=Newnode(l&r, a[l&r]);return;}\n\tbuild(ls, l, mid), build(rs, mid+1, r);\n\tpushup(k);\n}\nvoid modify(int k, int x, int v){\n\tif(tree[k].L==tree[k].R){tree[k]=Newnode(x, v);return ;}pushdown(k);\n\tif(x<=mid) modify(ls, x, v);\n\telse modify(rs, x, v);\n\treturn pushup(k);\n}\nvoid change(int k, int x, int y){\n\tif(x<=tree[k].L&&tree[k].R<=y) return tree[k].spread();pushdown(k);\n\tif(x<=mid) change(ls, x, y);\n\tif(mid<y) change(rs, x, y);\n\treturn pushup(k);\n}\nnode query(int k, int x, int y){\n\tif(x<=tree[k].L&&tree[k].R<=y) return tree[k];pushdown(k);\n\tif(y<=mid) return query(ls, x, y);\n\tif(x>mid) return query(rs, x, y);\n\tnode Ll=query(ls, x, y);node Rr=query(rs, x, y);\n\treturn Ll+Rr; \n}\n#undef ls\n#undef rs \n#undef mid\nvoid doit(int dep, int sum, int &res, int x, int y){\n\tif(!dep) return ;\n\tnode ans=query(1, x, y);\n\tres=max(res, sum+=ans.Mx);\n\tchange(1, ans.LXans, ans.RXans);\n\tdoit(dep-1, sum, res, x, y);\n\tchange(1, ans.LXans, ans.RXans);\n\treturn ;\n}\nsigned main(){\n\tn=read();\n\tfor(int i=1; i<=n; i++) a[i]=read();\n\tbuild(1, 1, n);\n\tm=read();\n\tfor(int i=1, opt, x, y, k; i<=m; i++){\n\t\topt=read();\n\t\tif(!opt) x=read(), y=read(), modify(1, x, y);\n\t\telse{\n\t\t\tx=read(), y=read(), k=read();\n\t\t\tint ans=0;\n\t\t\tdoit(k, 0, ans, x, y);\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1631344077,
        "uid": 341102,
        "name": "ReKoJ",
        "ccfLevel": 0,
        "title": "CF280D k-Maximum Subsequence Sum"
    },
    {
        "content": "\u5bf9\u4e8e\u8fd9\u6837\u7684\u95ee\u9898\uff0c\u5206\u64cd\u4f5c\u8003\u8651\u3002\u7b2c\u4e00\u4e2a\u64cd\u4f5c\uff0c\u663e\u7136\u53ef\u4ee5\u76f4\u63a5\u5355\u70b9\u4fee\u6539\uff0c\u4fee\u6539\u7684\u8fc7\u7a0b\u4e0e\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u7684\u4fe1\u606f\u6709\u5173\uff0c\u6682\u5148\u4e0d\u7ba1\uff1b\u6ce8\u610f\u5230\u95ee\u9898\u7684\u6838\u5fc3\u5728\u4e8e\u7b2c\u4e8c\u4e2a\u64cd\u4f5c\u600e\u4e48\u89e3\u51b3\u3002\n\n\u9996\u5148\u5c06\u8fd9\u4e2a\u8be2\u95ee\u62c6\u51fa\u6765\uff0c\u7b80\u5316\u6210\u4e3a\u8fd9\u6837\u4e00\u4e2a\u95ee\u9898\uff1a\n\n> \u5bf9\u4e8e\u4e00\u4e2a\u5e8f\u5217 $a$\uff0c\u9009 $k$ \u4e2a\u4e0d\u76f8\u4ea4\u7684\u5b50\u6bb5\u548c\u7684\u6700\u5927\u503c\u662f\u591a\u5c11\uff1f\n\n\u5047\u8bbe\u73b0\u5728\u6211\u4eec\u8d2a\u5fc3\u9009\u4e86\u6700\u5927\u7684\u5b50\u6bb5\uff0c\u8fd9\u4e00\u6bb5\u9700\u8981\u88ab\u62ff\u51fa\u53bb\u3002\u4f46\u662f\u663e\u7136\u6211\u4eec\u53ef\u4ee5\u4e0d\u9009\u4e24\u4e2a\u6b63\u6570\u6bb5\u91cc\u9762\u7684\u8d1f\u6570\u7b97\uff0c\u8fd9\u6837\u7684\u8d2a\u5fc3\u663e\u7136\u662f\u9519\u8bef\u7684\u3002\n\n\u8003\u8651\u53cd\u6094\u8d2a\u5fc3\u3002\u6211\u4eec\u9700\u8981\u4e00\u4e2a\u65b9\u6cd5\u5c06\u8fd9\u4e2a\u53d6\u8d70\u7684\u6570\u7684\u8d21\u732e\u901a\u8fc7\u53e6\u4e00\u79cd\u65b9\u6cd5\u53bb\u6389\u3002\u65e2\u7136\u4e4b\u524d\u662f\u6b63\u8d21\u732e\uff0c\u90a3\u4e48\u663e\u7136\u8fd9\u91cc\u5c31\u8981\u53d8\u6210\u8d1f\u8d21\u732e\u3002\u4e8e\u662f\u8fd9\u91cc\u9009\u51fa\u6765\u7684\u5b50\u6bb5\u548c\u5168\u90e8\u4e58\u4e0a $-1$\uff0c\u7136\u540e\u7ee7\u7eed\u627e\u3002\u53d1\u73b0\u8fd9\u6837\u5982\u679c\u518d\u9009\u5230\u53d6\u8d1f\u7684\u503c\uff0c\u76f8\u5f53\u4e8e\u6ca1\u6709\u9009\uff0c\u6bcf\u6b21\u62d3\u5c55\u8fd8\u53ef\u4ee5\u4f7f\u9009\u51fa\u6765\u7684\u6bb5\u6570\u589e\u52a0 $1$\uff08\u5982\u679c\u9009\u76f8\u4ea4\u4e86\uff0c\u53d1\u73b0\u521a\u597d\u53ef\u4ee5\u62c6\u5f00\u6210\u4e3a\u4e24\u6bb5\uff1b\u5426\u5219\u4e0d\u76f8\u4ea4\u4f7f\u76f4\u63a5\u4e24\u6bb5\uff09\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\u53ea\u9700\u8981\u62d3\u5c55 $k$ \u6b21\u5373\u53ef\u3002\u6ce8\u610f\u53ef\u4ee5\u4e0d\u9009\uff0c\u6240\u4ee5\u8bf4\u5f53\u5df2\u7ecf\u4e0d\u80fd\u4f7f\u8d21\u732e\u589e\u52a0\u65f6\u5c31\u53ef\u4ee5\u4e0d\u9009\u4e86\u3002\n\n\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u6700\u5c0f\u5b50\u6bb5\u548c\uff08\u6700\u5c0f\u5b50\u6bb5\u548c\u53ef\u4ee5\u7406\u89e3\u6210\u4e58 $-1$ \u4e4b\u540e\u4e24\u8005\u4ea4\u6362\uff09\uff0c\u663e\u7136\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u53bb\u7ef4\u62a4\u3002\u5f53\u8fd9\u4e2a\u6bb5\u88ab\u9009\u6389\u4e4b\u540e\u4e58\u4e0a $-1$ \u53ef\u4ee5\u5c06\u6700\u5927\u6700\u5c0f\u5b50\u6bb5\u548c\u53d6\u8d1f\u4ea4\u6362\u5373\u53ef\u3002\u64cd\u4f5c\u7684\u65f6\u5019\u8fd8\u9700\u8981\u989d\u5916\u7ef4\u62a4\u6700\u5927\u6700\u5c0f\u5b50\u6bb5\u548c\uff0c\u5de6\u8fb9\u754c\u6700\u5927\u6700\u5c0f\u5b50\u6bb5\u548c\uff0c\u53f3\u8fb9\u754c\u6700\u5927\u6700\u5c0f\u5b50\u6bb5\u548c\u7684\u533a\u95f4\u7f16\u53f7\u4fe1\u606f\u3002\n\n\u81f3\u4e8e\u5c06\u7ebf\u6bb5\u6811\u8fd8\u539f\uff0c\u53ef\u4ee5\u8bb0\u5f55\u4fee\u6539\u4e86\u54ea\u4e9b\u6bb5\uff0c\u518d\u66b4\u529b\u4fee\u6539\u56de\u6765\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $O(mk \\log n)$\u3002\u7ec6\u8282\u5f88\u591a\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nchar buf[1<<21],*p1=buf,*p2=buf;\n#define getchar() (p1==p2 && (p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\n#define lc(x) (x<<1)\n#define rc(x) ((x<<1)|1)\n#define Mm int mid=(l+r)>>1\nint n;\nLL a[100005];\nstruct node{\n\tLL lmax,rmax,maxn,sum;\n\tint l,r,ll,lr,rl,rr;\n\tnode(LL LM=0,LL RM=0,LL M=0,LL S=0,int L=0,int R=0,int Ll=0,int LR=0,int RL=0,int RR=0){lmax=LM,rmax=RM,maxn=M,sum=S,l=L,r=R,ll=Ll,lr=LR,rl=RL,rr=RR;}\n}tr[400005],minn[400005];\nbool tag[400005];\nLL read()\n{\n\tLL x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0' || c>'9')\n\t{\n\t\tif(c=='-')\tf=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0' && c<='9')\tx=(x<<1)+(x<<3)+(c^'0'),c=getchar();\n\treturn x*f;\n}\nvoid push_up(int now)\n{\n\ttr[now].sum=tr[lc(now)].sum+tr[rc(now)].sum;\n\ttr[now].lmax=max(tr[lc(now)].lmax,tr[lc(now)].sum+tr[rc(now)].lmax);\n\tif(tr[now].lmax==tr[lc(now)].lmax)\ttr[now].ll=tr[lc(now)].ll,tr[now].lr=tr[lc(now)].lr;\n\telse\ttr[now].ll=tr[lc(now)].ll,tr[now].lr=tr[rc(now)].lr;\n\ttr[now].rmax=max(tr[rc(now)].rmax,tr[rc(now)].sum+tr[lc(now)].rmax);\n\tif(tr[now].rmax==tr[rc(now)].rmax)\ttr[now].rl=tr[rc(now)].rl,tr[now].rr=tr[rc(now)].rr;\n\telse\ttr[now].rl=tr[lc(now)].rl,tr[now].rr=tr[rc(now)].rr;\n\ttr[now].maxn=max(max(tr[lc(now)].maxn,tr[rc(now)].maxn),tr[lc(now)].rmax+tr[rc(now)].lmax);\n\tif(tr[now].maxn==tr[lc(now)].maxn)\ttr[now].l=tr[lc(now)].l,tr[now].r=tr[lc(now)].r;\n\telse if(tr[now].maxn==tr[rc(now)].maxn)\ttr[now].l=tr[rc(now)].l,tr[now].r=tr[rc(now)].r;\n\telse\ttr[now].l=tr[lc(now)].rl,tr[now].r=tr[rc(now)].lr;\n\tminn[now].sum=minn[lc(now)].sum+minn[rc(now)].sum;\n\tminn[now].lmax=min(minn[lc(now)].lmax,minn[lc(now)].sum+minn[rc(now)].lmax);\n\tif(minn[now].lmax==minn[lc(now)].lmax)\tminn[now].ll=minn[lc(now)].ll,minn[now].lr=minn[lc(now)].lr;\n\telse\tminn[now].ll=minn[lc(now)].ll,minn[now].lr=minn[rc(now)].lr;\n\tminn[now].rmax=min(minn[rc(now)].rmax,minn[rc(now)].sum+minn[lc(now)].rmax);\n\tif(minn[now].rmax==minn[rc(now)].rmax)\tminn[now].rl=minn[rc(now)].rl,minn[now].rr=minn[rc(now)].rr;\n\telse\tminn[now].rl=minn[lc(now)].rl,minn[now].rr=minn[rc(now)].rr;\n\tminn[now].maxn=min(min(minn[lc(now)].maxn,minn[rc(now)].maxn),minn[lc(now)].rmax+minn[rc(now)].lmax);\n\tif(minn[now].maxn==minn[lc(now)].maxn)\tminn[now].l=minn[lc(now)].l,minn[now].r=minn[lc(now)].r;\n\telse if(minn[now].maxn==minn[rc(now)].maxn)\tminn[now].l=minn[rc(now)].l,minn[now].r=minn[rc(now)].r;\n\telse\tminn[now].l=minn[lc(now)].rl,minn[now].r=minn[rc(now)].lr;\n}\nvoid build(int l,int r,int now)\n{\n\tif(l==r)\n\t{\n\t\tminn[now]=tr[now]=node(a[l],a[l],a[l],a[l],l,l,l,l,l,l);\n\t\treturn ;\n\t}\n\tMm;\n\tbuild(l,mid,lc(now));\n\tbuild(mid+1,r,rc(now));\n\tpush_up(now);\n}\nvoid changeNode(int now)\n{\n\ttr[now].lmax=-tr[now].lmax;\n\ttr[now].rmax=-tr[now].rmax;\n\ttr[now].maxn=-tr[now].maxn;\n\ttr[now].sum=-tr[now].sum;\n\tminn[now].lmax=-minn[now].lmax;\n\tminn[now].rmax=-minn[now].rmax;\n\tminn[now].maxn=-minn[now].maxn;\n\tminn[now].sum=-minn[now].sum;\n\tswap(tr[now],minn[now]);\n}\nvoid push_down(int now)\n{\n\tif(tag[now])\n\t{\n\t\ttag[lc(now)]=!tag[lc(now)];\n\t\ttag[rc(now)]=!tag[rc(now)];\n\t\tchangeNode(lc(now));\n\t\tchangeNode(rc(now));\n\t\ttag[now]=false;\n\t}\n}\nvoid modify(int l,int r,int x,int y,int now)\n{\n\tif(x<=l && r<=y)\n\t{\n\t\ttag[now]=!tag[now];\n\t\tchangeNode(now);\n\t\treturn ;\n\t}\n\tpush_down(now);\n\tMm;\n\tif(x<=mid)\tmodify(l,mid,x,y,lc(now));\n\tif(mid<y)\tmodify(mid+1,r,x,y,rc(now));\n\tpush_up(now);\n}\nvoid modifyPoint(int l,int r,int x,int now,int val)\n{\n\tif(l==r)\n\t{\n\t\tminn[now]=tr[now]=node(val,val,val,val,l,l,l,l,l,l);\n\t\treturn ;\n\t}\n\tpush_down(now);\n\tMm;\n\tif(x<=mid)\tmodifyPoint(l,mid,x,lc(now),val);\n\telse\tmodifyPoint(mid+1,r,x,rc(now),val);\n\tpush_up(now);\n}\nnode query(int l,int r,int now,int x,int y)\n{\n\tif(x<=l && r<=y)\treturn tr[now];\n\tMm;\n\tpush_down(now);\n\tif(x<=mid && mid>=y)\treturn query(l,mid,lc(now),x,y);\n\tif(mid<y && x>mid)\treturn query(mid+1,r,rc(now),x,y);\n\tnode que1=query(l,mid,lc(now),x,y),que2=query(mid+1,r,rc(now),x,y),que3;\n\tque3.sum=que1.sum+que2.sum;\n\tque3.lmax=max(que1.lmax,que1.sum+que2.lmax);\n\tque3.rmax=max(que2.rmax,que2.sum+que1.rmax);\n\tque3.maxn=max(max(que1.maxn,que2.maxn),que1.rmax+que2.lmax);\n\tif(que3.lmax==que1.lmax)\tque3.ll=que1.ll,que3.lr=que1.lr;\n\telse\tque3.ll=que1.ll,que3.lr=que2.lr;\n\tif(que3.rmax==que2.rmax)\tque3.rl=que2.rl,que3.rr=que2.rr;\n\telse\tque3.rl=que1.rl,que3.rr=que2.rr;\n\tif(que3.maxn==que1.maxn)\tque3.l=que1.l,que3.r=que1.r;\n\telse if(que3.maxn==que2.maxn)\tque3.l=que2.l,que3.r=que2.r;\n\telse\tque3.l=que1.rl,que3.r=que2.lr;\n\treturn que3;\n}\nint st[25],su[25],top;\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;++i)\ta[i]=read();\n\tbuild(1,n,1);\n\tint m=read();\n\twhile(m-->0)\n\t{\n\t\tint op=read();\n\t\tif(!op)\n\t\t{\n\t\t\tint x=read(),val=read();\n\t\t\tmodifyPoint(1,n,x,1,val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l=read(),r=read(),k=read();\n\t\t\tLL ans=0;\n\t\t\tfor(int i=1;i<=k;++i)\n\t\t\t{\n\t\t\t\tnode s=query(1,n,1,l,r);\n\t\t\t\tif(s.maxn<=0)\tbreak;\n\t\t\t\tans+=s.maxn;\n\t\t\t\t++top;\n\t\t\t\tst[top]=s.l;\n\t\t\t\tsu[top]=s.r;\n\t\t\t\tmodify(1,n,s.l,s.r,1);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",ans);\n\t\t\twhile(top)\tmodify(1,n,st[top],su[top],1),--top;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1606551744,
        "uid": 184977,
        "name": "pomelo_nene",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "# \u6a21\u62df\u8d39\u7528\u6d41\uff08\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff09\n\n## Part I\n\n\u5148\u8003\u8651\u4e00\u4e2a\u8d39\u7528\u6d41\u505a\u6cd5\uff1a\n\n- \u539f\u70b9\u5411\u6bcf\u4e2a\u70b9\u8fde\u6d41\u91cf\u4e3a$1$\u8d39\u7528\u4e3a$0$\u7684\u8fb9\n\n- \u6bcf\u4e2a\u70b9\u5411\u4e0b\u4e00\u4e2a\u70b9\u8fde\u6d41\u91cf\u4e3a\u70b9\u503c\u7684\u8fb9\n\n- \u6bcf\u4e2a\u70b9\u5411\u6c47\u70b9\u8fde\u6d41\u91cf\u4e3a$1$\u8d39\u7528\u4e3a$0$\u7684\u8fb9\n\n\u7136\u540e\u8dd1\u4e00\u4e2a\u6d41\u91cf\u4e3a$k$\u7684\u8d39\u7528\u6d41\u5373\u53ef\u3002\n\n## Part II\n\n\u770b\u4e00\u773c\u6570\u636e\u8303\u56f4\u3002\u3002\u3002what the f\\*\\*k!!!\n\n\u8d39\u7528\u6d41TLE\u81f3\u6b7b\u3002\u4e8e\u662f\uff0c\u6211\u4eec\u8003\u8651\u4f18\u5316\u8fd9\u4e2a\u8fc7\u7a0b\u3002\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u6bcf\u6b21\u8d39\u7528\u6d41\u589e\u5e7f\u7684\u8fc7\u7a0b\u5c31\u662f\u627e\u5230\u6700\u957f\u7684\u8def\u5f84\u4e00\u6761\u8def\u5f84\uff0c\u7136\u540e\u628a\u7b54\u6848\u52a0\u4e0a\u8fd9\u4e2a\u503c\uff0c\u7136\u540e\u628a\u8fb9\u53cd\u5411\u3002\n\n\u6211\u4eec\u53c8\u53d1\u73b0\u8fd9\u4e9b\u8def\u5f84\u662f\u4e00\u6761\u94fe\u7684\u5f62\u5f0f\uff0c\u4e8e\u662f\u6bcf\u6b21\u627e\u5230\u7684\u8def\u5f84\u5c31\u662f\u6700\u5927\u5b50\u6bb5\u548c\u3002\n\n\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6570\u5217\u6765\u6a21\u62df\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u9700\u8981\u652f\u6301\u7684\u64cd\u4f5c\u6709\uff1a\n\n- \u5355\u70b9\u4fee\u6539\n\n- \u533a\u95f4\u53d6\u76f8\u53cd\u6570\n\n- \u8be2\u95ee\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\n\n\u6bcf\u6b21\u5bf9\u4e8e\u4e00\u4e2a\u8be2\u95ee\uff0c\u6211\u4eec\u67e5\u8be2$k$\u6b21\u6700\u5927\u5b50\u6bb5\u548c\u5e76\u5c06\u8fd9\u4e00\u6bb5\u5b50\u6bb5\u53d6\u76f8\u53cd\u6570\u3002\u7136\u540e\u7edf\u8ba1\u6240\u6709\u6700\u5927\u5b50\u6bb5\u548c\u76f8\u52a0\u7684\u548c\u5c31\u662f\u5355\u6b21\u8be2\u95ee\u7684\u7b54\u6848\u3002\n\n\u8981\u6ce8\u610f\u53ef\u4ee5\u4e0d\u9009\uff0c\u6240\u4ee5\u5f53\u6700\u5927\u5b50\u6bb5\u548c$s\\le0$\u65f6\u5c31\u9000\u51fa\u3002\n\n\u53e6\u5916\uff0c\u6bcf\u6b21\u8be2\u95ee\u9700\u8981\u77e5\u9053\u6700\u5927\u5b50\u6bb5\u548c\u5bf9\u5e94\u7684\u5177\u4f53\u533a\u95f4\uff0c\u56e0\u6b64\u9700\u8981\u7ef4\u62a4\u6bcf\u4e2a\u503c\u7684$l,r$\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u53ef\u4ee5\u770b\u4ee3\u7801\u4e86\uff0c\u81ea\u6211\u611f\u89c9\u6211\u7684\u5b9e\u73b0\u633a\u7b80\u6d01\u7684\u3002\n\n\u795d\u7f16\u7801\u6109\u5feb\u3002\n\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf=0x3f3f3f3f;\n\nstruct Node\n{\n    struct Tuple\n    {\n        int l,r,val;\n\n        Tuple(int val):l(inf),r(-inf),val(val){}\n        Tuple(int l,int r,int val):l(l),r(r),val(val){}\n\n        Tuple operator+(const Tuple &other)const\n        {\n            return Tuple(min(l,other.l),max(r,other.r),val+other.val);\n        }\n\n        bool operator<(const Tuple &other)const\n        {\n            return val<other.val;\n        }\n    };\n    Tuple maxright,maxleft,maxmid;\n    Tuple minright,minleft,minmid;\n    Tuple sum;\n    bool rev;\n\n    Node():\n        maxright(-inf),\n        maxleft(-inf),\n        maxmid(-inf),\n        minright(inf),\n        minleft(inf),\n        minmid(inf),\n        sum(0),\n        rev(0){}\n\n    Node operator+(const Node &other)const\n    {\n        Node res;\n        \n        res.sum=sum+other.sum;\n\n        res.maxright=max(other.maxright,maxright+other.sum);\n        res.maxleft=max(maxleft,sum+other.maxleft);\n        res.maxmid=max(maxmid,max(other.maxmid,maxright+other.maxleft));\n\n        res.minright=min(other.minright,minright+other.sum);\n        res.minleft=min(minleft,sum+other.minleft);\n        res.minmid=min(minmid,min(other.minmid,minright+other.minleft));\n\n        return res;\n    }\n};\n\n\nstruct SEG\n{\n    Node nd[100010<<2];\n\n    void update(int x)\n    {\n        nd[x]=nd[x<<1]+nd[x<<1|1];\n    }\n\n    void reverse(int x)\n    {\n        swap(nd[x].maxright,nd[x].minright);\n        swap(nd[x].maxleft,nd[x].minleft);\n        swap(nd[x].maxmid,nd[x].minmid);\n        nd[x].maxright.val*=-1;\n        nd[x].maxleft.val*=-1;\n        nd[x].maxmid.val*=-1;\n        nd[x].minright.val*=-1;\n        nd[x].minleft.val*=-1;\n        nd[x].minmid.val*=-1;\n        nd[x].sum.val*=-1;\n    }\n\n    void pushdown(int x)\n    {\n        if(nd[x].rev)\n        {\n            nd[x<<1].rev^=1;\n            reverse(x<<1);\n            nd[x<<1|1].rev^=1;\n            reverse(x<<1|1);\n            nd[x].rev=0;\n        }\n    }\n\n    void modifynode(int now,int nl,int nr,int pos,int val)\n    {\n        if(nl==nr)\n        {\n            nd[now].sum=Node::Tuple(nl,nr,val);\n            nd[now].maxright=nd[now].maxleft=nd[now].maxmid=Node::Tuple(nl,nr,val);\n            nd[now].minright=nd[now].minleft=nd[now].minmid=Node::Tuple(nl,nr,val);\n            return;\n        }\n        pushdown(now);\n        int mid=nl+nr>>1;\n        if(pos<=mid) modifynode(now<<1,nl,mid,pos,val);\n        else modifynode(now<<1|1,mid+1,nr,pos,val);\n        update(now);\n    }\n\n    void modifyrange(int now,int nl,int nr,int ql,int qr)\n    {\n        if(nl>qr||nr<ql) return;\n        if(nl>=ql&&nr<=qr) \n        {\n            reverse(now);\n            nd[now].rev^=1;\n            return;\n        }\n        pushdown(now);\n        int mid=nl+nr>>1;\n        modifyrange(now<<1,nl,mid,ql,qr);\n        modifyrange(now<<1|1,mid+1,nr,ql,qr);\n        update(now);\n    }\n\n//    Node queryrangemax(int now,int nl,int nr,int ql,int qr)\n//    {\n//        if(nl>qr||nr<ql) return Node();\n//        if(nl>=ql&&nr<=qr) return nd[now];\n//        pushdown(now);\n//        int mid=nl+nr>>1;\n//        return queryrangemax(now<<1,nl,mid,ql,qr)+queryrangemax(now<<1|1,mid+1,nr,ql,qr);\n//    }\n    Node queryrangemax(int now,int nl,int nr,int ql,int qr)\n    {\n        if(nl>=ql&&nr<=qr)\n        {\n            return nd[now];\n        }\n        pushdown(now);\n        int mid=nl+nr>>1;\n        if(ql>mid) return queryrangemax(now<<1|1,mid+1,nr,ql,qr);\n        else if(qr<=mid) return queryrangemax(now<<1,nl,mid,ql,qr);\n        else return queryrangemax(now<<1,nl,mid,ql,mid)+queryrangemax(now<<1|1,mid+1,nr,mid+1,qr);\n    }\n}seg;\n\nqueue<Node>q;\n\nint main()\n{\n    int n,m;\n    cin>>n;\n    for(int i=1;i<=n;i++) \n    {\n        int tmp;\n        cin>>tmp;\n        seg.modifynode(1,1,n,i,tmp);\n    }\n    cin>>m;\n    for(int i=1;i<=m;i++)\n    {\n        int opt,x,y;\n        cin>>opt>>x>>y;\n        if(opt)\n        {\n            int ans=0;\n            int k;\n            cin>>k;\n            while(k--)\n            {\n                Node tmp=seg.queryrangemax(1,1,n,x,y);\n                if(tmp.maxmid.val>0)\n                {\n                    ans+=tmp.maxmid.val;\n                    seg.modifyrange(1,1,n,tmp.maxmid.l,tmp.maxmid.r);\n                    q.push(tmp);\n                }\n                else break;\n            }\n            cout<<ans<<'\\n';\n            while(!q.empty())\n            {\n                seg.modifyrange(1,1,n,q.front().maxmid.l,q.front().maxmid.r);\n                q.pop();\n            }\n        }\n        else\n        {\n            seg.modifynode(1,1,n,x,y);\n        }\n    }\n}\n```",
        "postTime": 1550806330,
        "uid": 53241,
        "name": "partychicken",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF280D \u3010k-Maximum Subsequence Sum\u3011"
    },
    {
        "content": "~~\u8fd9\u54ea\u6709\u9ed1\u554a~~\n\n\u8003\u8651\u5230\u672c\u9898\u5df2\u7ecf\u6709\u8bf8\u591a\u9898\u89e3\uff0c\u6211\u4e3b\u8981\u8bb2\u8bb2\u5b9e\u73b0\uff0c\u5e0c\u671b\u5bf9\u5927\u5bb6 NOIP \u5907\u8003\u6709\u6240\u5e2e\u52a9\uff0c\u8ba9\u5927\u5bb6\u8003\u573a\u4e0a\u66f4\u5feb\u5730\u5199\u51fa\u51c6\u786e\u7684\u4ee3\u7801\uff0c\u5e76\u80fd\u66f4\u5feb\u5730\u8c03\u8bd5\u3002\n\n## \u6570\u636e\u7ec4\u7ec7\n\n\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u7ecf\u5178\u505a\u6cd5\u662f\u5f00\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u533a\u95f4\u524d\u7f00\u548c\u3001\u533a\u95f4\u540e\u7f00\u548c\u3001\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u3001\u533a\u95f4\u603b\u548c\u3002\u4f46\u662f\u8fd9\u9898\u6211\u4eec\u8fd8\u9700\u8981\u77e5\u9053\u8fd9\u4e9b\u548c\u6765\u81ea\u54ea\u91cc\u3002\n\n\u6211\u4eec\u6ce8\u610f\u5230\uff0c\u6bcf\u4e2a\u6570\u7684\u6765\u6e90\u548c\u503c\u603b\u662f\u6346\u7ed1\u5728\u4e00\u8d77\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5199\u4e00\u4e2a `struct`\u3002\u540c\u65f6\uff0c\u7531\u4e8e\u6211\u4eec\u6709\u533a\u95f4\u53d6\u76f8\u53cd\u6570\u64cd\u4f5c\uff0c\u6211\u4eec\u8fd8\u8981\u7ef4\u62a4\u53e6\u4e00\u4e2a `struct`\u3002\n\n\u6211\u4eec\u53d1\u73b0\u8fd9\u6784\u6210\u4e86\u4e24\u7ea7 `struct`\u3002\u6211\u4eec\u5199\u67d0\u4e00\u7ea7 `struct` \u65f6\u603b\u662f\u5e0c\u671b\u4e0a\u4e00\u7ea7 `struct` \u5df2\u7ecf\u5c01\u88c5\u5b8c\u6210\uff0c\u53ef\u4ee5\u65b9\u4fbf\u5730\u8c03\u7528\u5404\u7c7b\u51fd\u6570\u3002\n\n## \u7c7b\u578b\u68c0\u67e5\n\n\u6709\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f1a\u4e0d\u81ea\u89c9\u5730\u5199\u9519\u4e00\u4e9b\u4e1c\u897f\uff0c\u4f8b\u5982\u5c06\u533a\u95f4\u524d\u7f00\u548c\u548c\u53e6\u4e00\u4fa7\u533a\u95f4\u524d\u7f00\u548c\u76f8\u52a0\uff0c\u6216\u8005\u533a\u95f4\u524d\u7f00\u548c\u548c\u533a\u95f4\u540e\u7f00\u548c\u6c42 `max` \u7b49\u3002\u4e3a\u4e86\u907f\u514d\u8fd9\u79cd\u95ee\u9898\uff0c\u6211\u76f4\u63a5\u5c06\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\u5b9a\u4e49\u4e3a\u4e24\u79cd\u4e0d\u540c\u7684\u7ed3\u6784\u4f53\uff0c\u5c31\u53ef\u4ee5\u81ea\u52a8\u5b8c\u6210\u7c7b\u578b\u68c0\u67e5\u3002\n\n\u5b9e\u9645\u4e0a\u6211\u7684\u4ee3\u7801\u6709\u4e00\u5904\u4e0d\u592a\u597d\u7684\u5730\u65b9\u2014\u2014`Rmax` \u548c `Rmin` \u4f7f\u7528 `auto` \u4f5c\u53c2\u6570\uff0c\u8fd9\u5bfc\u81f4\u6211\u540e\u6765\u6709\u4e00\u6b21\u5c06\u4e24\u4e2a `node` \u6c42 `Rmax`\uff08`node` \u7684\u5408\u5e76\u5e94\u5199\u6210 `+`\uff09\u4e86\u6211\u5374\u6ca1\u53d1\u73b0\u3002\n\n\u66f4\u597d\u7684\u5199\u6cd5\u5e94\u8be5\u662f `template<typename T> T Rmax(T x,T y)`\uff0c\u7136\u540e\u624b\u52a8\u628a `node` \u6790\u6784\u6389\uff0c\u6216\u8005 `node` \u7684\u5168\u5c40\u548c\u6362\u4e2a\u540d\u5b57\u3002\n\n## \u90e8\u5206\u8f93\u51fa\n\n\u5982\u679c\u8981\u8f93\u51fa\u6574\u68f5\u7ebf\u6bb5\u6811\uff0c\u54ea\u6015\u662f\u9898\u76ee\u7ed9\u7684\u5c0f\u6837\u4f8b\uff0c\u7531\u4e8e\u6bcf\u4e2a\u7ed3\u70b9\u8981\u5b58\u50a8 $15$ \u4e2a\u6570\uff0c\u5bf9\u5e94\u7684\u8f93\u51fa\u4e5f\u662f\u76f8\u5f53\u5de8\u5927\uff0c\u4e0d\u65b9\u4fbf\u8c03\u8bd5\u7684\u3002\n\n**\u518d\u6b21\u63d0\u9192\uff1a\u4f60\u89c9\u5f97\u5bb9\u6613\u9519\u7684\u5730\u65b9\uff0c\u53ef\u80fd\u8fd8\u771f\u4e0d\u662f\u4f60\u9519\u7684\u5730\u65b9\u3002**\n\n\u5f53\u6211\u4eec\u53d1\u73b0 RE \u6216 WA \u65f6\uff0c\u6211\u4eec\u53ef\u4ee5**\u5148\u68c0\u67e5\u597d\u68c0\u67e5\u7684**\uff0c\u518d\u6df1\u5165\u7a0b\u5e8f\u5185\u90e8\u68c0\u67e5\u5404\u4e2a\u90e8\u5206\u662f\u5426\u7b26\u5408\u9884\u671f\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e\u672c\u9898\uff0c\u4f60\u5bf9\u4e8e\u8be2\u95ee 2 WA \u53ef\u4ee5\u8003\u8651\u5982\u4e0b\u6b65\u9aa4\uff1a\n- \u5148\u89c2\u5bdf\u6bcf\u4e00\u6b65\u6c42\u51fa\u7684\u6700\u5927\u5b50\u6bb5\u548c\u53ca\u6765\u6e90\u662f\u5426\u6b63\u786e\u3002\n- \u89c2\u5bdf\u5408\u5e76\u662f\u5426\u6b63\u786e\u3002\n- \u5bf9\u4e8e\u6bcf\u6b21\u9012\u5f52\uff0c\u89c2\u5bdf lazytag \u548c\u6839\uff0c\u53ef\u4ee5\u7c97\u67e5\u4e0a\u4e00\u6b21\u53d6\u76f8\u53cd\u6570\u662f\u5426\u6b63\u786e\u3002\n- \u786e\u8ba4 lazytag \u4e0b\u653e\u6b63\u786e\u3002\n\n\u6ce8\u610f\uff0c\u5982\u679c\u4f60\u7b2c\u4e00\u6b21\u6c42\u6700\u5927\u5b50\u6bb5\u548c\u5c31\u9519\uff0c\u4f60\u8f93\u51fa\u65f6\u53ea\u8981\u8f93\u51fa\u6700\u5927\u548c\uff0c\u5e76\u4e0d\u7528\u7ba1\u6700\u5c0f\u4ee5\u53ca\u6700\u5927\u548c\u7684\u6765\u6e90\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u5f71\u54cd\u4f60\u7b2c\u4e00\u6b21\u6c42\u6700\u5927\u5b50\u6bb5\u548c\u3002\u5176\u4ed6\u60c5\u51b5\u540c\u7406\u3002\n\n## \u53c2\u8003\u5b9e\u73b0\n\n3KB\uff0c\u5728\u672c\u9898\u4ee3\u7801\u4e2d\u7b97\u4e2d\u7b49\u504f\u77ed\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nint occupy(int n){int y=1;for(n--;n;n>>=1)y<<=1;return y;}\nstruct lR{long long sum;int l;};//\u540e\u7f00\u548c\nstruct rR{long long sum;int r;};//\u524d\u7f00\u548c\nstruct R{long long sum;int l,r;};//\u6700\u5927\u5b50\u6bb5\u548c\nlR operator + (lR x,long long y){return {x.sum+y,x.l};}//\u56e0\u4e3a\u540e\u7f00\u548c\u5728\u4e00\u4e2a\u533a\u95f4\u7684\u524d\u9762\uff0c\u6240\u4ee5\u5c06\u5b83\u5199\u5728\u52a0\u53f7\u524d\u9762\u3002\nrR operator + (long long x,rR y){return {x+y.sum,y.r};}//\u540c\u7406\uff0c\u540c\u65f6\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u7c7b\u578b\u68c0\u67e5\u3002\nR  operator + (lR x,rR y){return {x.sum+y.sum,x.l,y.r};}\nauto Rmax(auto x,auto y){if(x.sum>y.sum)return x;return y;}//\u521a\u63d0\u5230\u7684\u4e00\u70b9\u7455\u75b5\uff0c\u6ca1\u6709\u7c7b\u578b\u68c0\u67e5\nauto Rmin(auto x,auto y){if(x.sum<y.sum)return x;return y;}\nauto _n(auto x){x.sum=-x.sum;return x;}//\u533a\u95f4\u6c42\u53cd\uff0c\u662f\u5185\u90e8\u51fd\u6570\uff0c\u7528\u4e0b\u5212\u7ebf\nstruct node{long long sum;lR lmx,lmn;rR rmx,rmn;R mx,mn;};\nnode operator - (node x){return {-x.sum,_n(x.lmn),_n(x.lmx),_n(x.rmn),_n(x.rmx),_n(x.mn),_n(x.mx)};}//\u8282\u70b9\u6c42\u53cd\nnode make_node(int x,int id)\n{\n\tif(x>=0)return {x,{x,id},{0,id+1},{x,id},{0,id-1},{x,id,id},{0,id+1,id-1}};\n\treturn -make_node(-x,id);\n}//\u5c06\u5b9e\u6570\u8f6c\u5316\u6210 node\uff0c\u8fd9\u91cc\u8d1f\u6570\u6211\u53ef\u4ee5\u76f4\u63a5\u8c03\u7528\uff0c\u4e0d\u91cd\u590d\u9020\u8f6e\u5b50\nnode operator + (node x,node y)//\u5408\u5e76\u4e24\u4e2a node\n{\n\tnode res;res.sum=x.sum+y.sum;\n\tres.lmx=Rmax(x.lmx+y.sum,y.lmx);\n\tres.lmn=Rmin(x.lmn+y.sum,y.lmn);\n\tres.rmx=Rmax(x.sum+y.rmx,x.rmx);\n\tres.rmn=Rmin(x.sum+y.rmn,x.rmn);\n\tres.mx=Rmax(Rmax(x.mx,y.mx),x.lmx+y.rmx);\n\tres.mn=Rmin(Rmin(x.mn,y.mn),x.lmn+y.rmn);\n\treturn res;\n}\nint n,m,rn;\nbool rev[262144];\nnode tr[262144];//\u56e0\u4e3a\u6211\u4e00\u822c lazytag \u4e0d\u5199\u8fdb\u7ed3\u6784\u4f53\uff0c\u56e0\u6b64\u8fd9\u91cc\u4e5f\u4e0d\u5199\u8fdb\u53bb\nvoid psdn(int rt)//push_down\n{\n\trev[rt]=0;\n\trev[rt*2]^=1;tr[rt*2]=-tr[rt*2];\n\trev[rt*2+1]^=1;tr[rt*2+1]=-tr[rt*2+1];\n\ttr[rt]=tr[rt*2]+tr[rt*2+1];\n}\n//\u5168\u90e8\u5b9a\u4e49\u597d\u540e\uff0c\u4e0b\u9762\u7684\u4e1c\u897f\u548c\u7ebf\u6bb5\u6811\u5b8c\u5168\u4e00\u81f4\nnode query(int x,int y,int l,int r,int rt)\n{\n\tif(x==l and y==r){return tr[rt];}\n\tint mid=(l+r)/2;\n\tnode res=make_node(-0x3f3f3f3f,-1);\n\tif(rev[rt])psdn(rt);\n\tif(x<=mid)res=query(x,min(y,mid),l,mid,rt*2);\n\tif(y>mid)res=res+query(max(x,mid+1),y,mid+1,r,rt*2+1);\n\treturn res;\n}\nvoid neg(int x,int y,int l,int r,int rt)\n{\n\tif(x==l and y==r){rev[rt]^=1;tr[rt]=-tr[rt];return;}\n\tint mid=(l+r)/2;\n\tif(rev[rt])psdn(rt);\n\tif(x<=mid)neg(x,min(y,mid),l,mid,rt*2);\n\tif(y>mid)neg(max(x,mid+1),y,mid+1,r,rt*2+1);\n\ttr[rt]=tr[rt*2]+tr[rt*2+1];\n}\nvoid update(int x,int l,int r,int rt,int up)\n{\n\tif(l==r){tr[rt]=make_node(up,x);return;}\n\tif(rev[rt])psdn(rt);\n\tint mid=(l+r)/2;\n\tif(x<=mid)update(x,l,mid,rt*2,up);\n\telse update(x,mid+1,r,rt*2+1,up);\n\ttr[rt]=tr[rt*2]+tr[rt*2+1];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trn=occupy(n);\n\tint op,l,r,k;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&op);\n\t\ttr[rn+i]=make_node(op,i+1);\n\t}\n\tfor(int i=rn-1;i;i--)\n\t{\n\t\ttr[i]=tr[i*2]+tr[i*2+1];\n        //\u56e0\u4e3a\u5f53\u65f6\u7b2c\u4e00\u4e2a\u5c31\u51fa\u9519\uff0c\u56e0\u6b64\u6211\u4eec\u53ea\u68c0\u67e5 sum\uff0c\u7136\u540e\u53d1\u73b0\u5199\u6210\u4e86 tr[i]=Rmax(tr[i*2],tr[i*2+1]);\n\t\t//printf(\"i=%d (%d,%d,%d,%d)\\n\",i,tr[i].sum,tr[i].lmx.sum,tr[i].rmx.sum,tr[i].mx.sum);\n\t}\n\tfor(scanf(\"%d\",&m);m;m--)\n\t{\n\t\tscanf(\"%d\",&op);\n\t\tif(op==0)\n\t\t{\n\t\t\tscanf(\"%d%d\",&l,&k);\n\t\t\tupdate(l,1,rn,1,k);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&l,&r,&k);\n\t\t\tlong long tot=0;\n\t\t\tvector<pair<int,int> > rgs;\n\t\t\tfor(int i=1;i<=k;i++)\n\t\t\t{\n\t\t\t\tR tmp=query(l,r,1,rn,1).mx;\n\t\t\t\tif(tmp.l<1)tmp.l=1;//\u6837\u4f8b 2 RE \u4e4b\u540e\u6211\u53d1\u73b0\u524d\u7f00\u6709\u53ef\u80fd\u5230 0\n\t\t\t\tif(tmp.r>rn)tmp.r=rn;\n\t\t\t\t//printf(\"%d from [%d,%d]\\n\",tmp.sum,tmp.l,tmp.r);\n\t\t\t\tif(tmp.sum<=0)break;\n\t\t\t\ttot+=tmp.sum;\n\t\t\t\trgs.push_back({tmp.l,tmp.r});\n\t\t\t\tneg(tmp.l,tmp.r,1,rn,1);\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\",tot);\n\t\t\tfor(auto i:rgs)\n\t\t\t\tneg(i.first,i.second,1,rn,1);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1669041335,
        "uid": 101694,
        "name": "yummy",
        "ccfLevel": 7,
        "title": "\u5982\u4f55\u5728\u5199\u6a21\u62df\u65f6\u5fc3\u60c5\u4e0d\u70e6\u8e81"
    },
    {
        "content": "\u600e\u4e48\u505a\u76f8\u4fe1\u5927\u5bb6\u90fd\u4f1a\uff08\u53ef\u4ee5\u770b\u5176\u4ed6\u9898\u89e3\uff09\uff0c\u8fd9\u91cc\u63d0\u4f9b\u4e00\u79cd\u66f4\u597d\u5199\u7684\u5b9e\u73b0\u65b9\u6cd5\uff1a\n\n\u8fd9\u9898\u6bd4\u8f83\u6076\u5fc3\u7684\u662f\u533a\u95f4\u4e58\u4e0a $-1$\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u7ef4\u62a4\u4e24\u9897 `fhq-treap`\uff0c\u4e00\u68f5\u662f\u6b63\u7684\u4e00\u68f5\u662f\u8d1f\u7684\uff0c\u7136\u540e\u5206\u522b\u7ef4\u62a4\u6700\u5927\u5b50\u6bb5\u548c\u4fe1\u606f\uff0c\u7136\u540e\u533a\u95f4\u4e58\u4e0a $-1$ \u7684\u65f6\u5019\u76f4\u63a5\u628a\u4e24\u68f5\u6811\u7684\u533a\u95f4 `split` \u51fa\u6765\u4ea4\u6362\u540e `merge` \u56de\u53bb\u5c31\u597d\u4e86\uff0c\u8d85\u7ea7\u597d\u5199\u3002\n\n```cpp\n// This code wrote by chtholly_micromaker(Myukiyomekya)\n#include <bits/stdc++.h>\n#define int long long \n#define ALL(x) (x).begin(),(x).end()\n#define ln putchar('\\n')\n#define pb push_back\n#define MP std::make_pair\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\ntypedef std::pair<int,int> pii;\ntemplate <class t> inline void read(t &s){s=0;\nsigned f=1;char c=getchar();while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\nwhile(isdigit(c))s=(s<<3)+(s<<1)+(c^48),c=getchar();;s*=f;}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){read(x);read(a...);}\ntemplate <class t> inline void write(t x){if(x<0)putchar('-'),x=-x;\nstatic int buf[50],top=0;while(x)buf[++top]=x%10,x/=10;if(!top)buf[++top]=0;\nwhile(top)putchar(buf[top--]^'0');}\ntemplate <class t>inline bool ckmax(t&x,t y){if(x<y){x=y;return 1;}return 0;}\nconst int MaxN=2e5+50;\nconst int inf=1e18L+114514;\nstruct Node\n{\n\tint ans,sum,lmx,rmx,vl,vr,dl,dr;\n\tNode(){ans=sum=lmx=rmx=-inf;}\n\tNode(int x,int y){sum=ans=lmx=rmx=y,vl=vr=dl=dr=x;}\n\tinline Node operator + (const Node &nt) const\n\t{\n\t\tif(ans==-inf)return nt;\n\t\tif(nt.ans==-inf)return *this;\n\t\tNode ret;ret.sum=sum+nt.sum;\n\t\tret.ans=ans,ret.vl=vl,ret.vr=vr;\n\t\tif(ckmax(ret.ans,nt.ans))ret.vl=nt.vl,ret.vr=nt.vr;\n\t\tret.lmx=lmx,ret.dl=dl;\n\t\tif(ckmax(ret.lmx,sum+nt.lmx))ret.dl=nt.dl;\n\t\tret.rmx=nt.rmx,ret.dr=nt.dr;\n\t\tif(ckmax(ret.rmx,nt.sum+rmx))ret.dr=dr;\n\t\tif(ckmax(ret.ans,rmx+nt.lmx))ret.vl=dr,ret.vr=nt.dl;\n\t\treturn ret;\n\t}\n}v[MaxN],s[MaxN];\n#define lson ch[u][0]\n#define rson ch[u][1]\nstd::mt19937 rnd(time(0));\nint ch[MaxN][2],siz[MaxN],A[MaxN],ndn,rt1,rt2;\ninline void pushup(int u)\n{s[u]=s[lson]+v[u]+s[rson],siz[u]=siz[lson]+siz[rson]+1;}\ninline void split(int u,int &x,int &y,int k)\n{\n\tif(!u)return x=y=0,void();\n\tif(k>siz[lson])x=u,split(rson,rson,y,k-siz[lson]-1);\n\telse y=u,split(lson,x,lson,k);\n\tpushup(u);\n}\ninline int merge(int u,int v)\n{\n\tif(!u||!v)return u|v;\n\tif(rnd()%(siz[u]+siz[v])<siz[u])return rson=merge(rson,v),pushup(u),u;\n\treturn ch[v][0]=merge(u,ch[v][0]),pushup(v),v;\n}\ninline void Swap(int &rt1,int &rt2,int x,int y)\n{\n\tint l1,mid1,r1,l2,mid2,r2;\n\tsplit(rt1,mid1,r1,y),split(mid1,l1,mid1,x-1);\n\tsplit(rt2,mid2,r2,y),split(mid2,l2,mid2,x-1);\n\trt1=merge(merge(l1,mid2),r1),rt2=merge(merge(l2,mid1),r2);\n}\ninline void upd(int x,int y)\n{\n\tint l,mid,r;\n\tsplit(rt1,mid,r,x+1),split(mid,l,mid,x);\n\tv[mid]=Node(x,y),pushup(mid),rt1=merge(merge(l,mid),r);\n\tsplit(rt2,mid,r,x+1),split(mid,l,mid,x);\n\tv[mid]=Node(x,-y),pushup(mid),rt2=merge(merge(l,mid),r);\n}\ninline int buildtr(int l,int r)\n{\n\tif(l>r)return 0;\n\tint u=++ndn,mid=(l+r)>>1;v[u]=Node(mid,A[mid]),pushup(u);\n\treturn lson=buildtr(l,mid-1),rson=buildtr(mid+1,r),pushup(u),u;\n}\nsigned main(void)\n{\n\tint n;read(n);\n\trep(i,1,n)read(A[i]);\n\trt1=buildtr(0,n+1);\n\trep(i,1,n)A[i]=-A[i];\n\trt2=buildtr(0,n+1);\n\tint opt,x,y,z,q;read(q);\n\twhile(q--)\n\t{\n\t\tread(opt,x,y);\n\t\tif(!opt)upd(x,y);\n\t\telse\n\t\t{\n\t\t\tint l1,mid1,r1,l2,mid2,r2;\n\t\t\tsplit(rt1,mid1,r1,y+1),split(mid1,l1,mid1,x);\n\t\t\tsplit(rt2,mid2,r2,y+1),split(mid2,l2,mid2,x);\n\t\t\tread(z);\n\t\t\tint ret=0;\n\t\t\tstd::vector<pii > dr;\n\t\t\twhile(z--&&s[mid1].ans>0)\n\t\t\t{\n\t\t\t\tint l=s[mid1].vl-x+1,r=s[mid1].vr-x+1;\n\t\t\t\tret+=s[mid1].ans;\n\t\t\t\tdr.pb(MP(l,r)),Swap(mid1,mid2,l,r);\n\t\t\t}\n\t\t\twrite(ret),ln;\n\t\t\tstd::reverse(ALL(dr));\n\t\t\tfor(auto i:dr)Swap(mid1,mid2,i.first,i.second);\n\t\t\trt1=merge(merge(l1,mid1),r1);\n\t\t\trt2=merge(merge(l2,mid2),r2);\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n```\n\n",
        "postTime": 1638887518,
        "uid": 51376,
        "name": "MyukiyoMekya",
        "ccfLevel": 9,
        "title": "CF280D k-Maximum Subsequence Sum \u9898\u89e3"
    },
    {
        "content": "\u6a21\u62df\u8d39\u7528\u6d41\u7684\u5165\u95e8\u597d\u9898\u3002\n\n\u6240\u8c13 **\u6a21\u62df\u8d39\u7528\u6d41** \uff0c\u5c31\u662f\u5728\u95ee\u9898\u53ef\u4ee5\u7528\u8d39\u7528\u6d41\u7684\u601d\u60f3\u89e3\u51b3\uff0c\u4f46\u5374\u4e0d\u9002\u7528\u8d39\u7528\u6d41\u7684\u590d\u6742\u5ea6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u7528\u4e00\u4e9b\u65b9\u6cd5\uff08\u5927\u90e8\u5206\u65f6\u5019\u662f\u6570\u636e\u7ed3\u6784\uff09\u6765\u6a21\u62df\u8d39\u7528\u6d41\u8fdb\u884c\u7684\u8fc7\u7a0b\uff0c\u4ece\u800c\u964d\u4f4e\u590d\u6742\u5ea6\uff0c\u901a\u8fc7\u9898\u76ee\u7684\u7b97\u6cd5\u3002\n\n\u8003\u8651\u5148\u5bf9\u9898\u76ee\u6784\u5efa\u8d39\u7528\u6d41\u6a21\u578b\uff0c\u5c06\u70b9\u7684\u6743\u503c\u8f6c\u6362\u5230\u8fb9\u4e0a\uff0c\u5373\u6784\u9020 $n+1$ \u4e2a\u70b9\uff0c\u70b9 $i$ \u548c\u70b9 $i+1$ \u4e4b\u95f4\u7684\u8fb9\u7684\u6743\u503c\u4e3a $a_i$ \uff0c\u4ece\u6e90\u70b9\u5411\u6bcf\u4e2a\u70b9\u8fde\u8fb9\uff0c\u4ece\u6bcf\u4e2a\u70b9\u5411\u6c47\u70b9\u8fde\u8fb9\uff0c\u4ece $i$ \u70b9\u6d41\u5230 $j$ \u70b9\u8bf4\u660e\u53d6\u4e86 $a_i \\sim a_{j-1}$ \u8fd9\u4e00\u6bb5\u7684\u503c\uff0c\u6c42\u6700\u5927\u8d39\u7528\u6d41\u3002\n\n\u8003\u8651\u76f4\u63a5\u6a21\u62df\u8d39\u7528\u6d41\u7684\u8fc7\u7a0b\uff0c\u6700\u5927\u8d39\u7528\u6d41\u6bcf\u6b21\u9009\u62e9\u8d39\u7528\u6700\u5927\u7684\u4e00\u6761\u8def\u5f84\u589e\u5e7f\uff0c\u7531\u4e8e\u6211\u4eec\u8fde\u8fb9\u7684\u9650\u5236\uff0c\u6700\u5927\u8def\u5f84\u4e00\u5b9a\u662f\u5e8f\u5217\u91cc\u7684\u4e00\u4e2a\u533a\u95f4\u3002\u7531\u4e8e\u662f\u4e00\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u76f4\u63a5\u7ef4\u62a4\u6700\u5927\u7684\u533a\u95f4\uff0c\u76f4\u63a5\u52a0\u4e0a\u8fd9\u4e2a\u533a\u95f4\u7684\u8d21\u732e\uff0c\u7136\u540e\u518d\u6309\u7167\u8d39\u7528\u6d41\u7684\u6b65\u9aa4\u5c06\u533a\u95f4\u5185\u7684\u8d39\u7528\u53d6\u53cd\u3002\n\n\u6bcf\u4e00\u6b21\u6d41\u52a8\u5982\u679c\u6d41\u7684\u4f4d\u7f6e\u6ca1\u53d6\u8fc7\u5219\u76f8\u5f53\u4e8e\u53d6\u4e86\u8fd9\u4e00\u6bb5\u533a\u95f4\uff0c\u5982\u679c\u53d6\u8fc7\u4e86\u5219\u76f8\u5f53\u4e8e\u5c06\u8fd9\u4e00\u6bb5\u533a\u95f4\u6d88\u9664\uff08\u5373\u53cd\u6094\uff09\u3002\u6bcf\u6b21\u6d41\u4e4b\u540e\u5b9e\u8d28\u4e0a\u53d6\u5230\u7684\u533a\u95f4\u4e00\u5b9a\u4f1a\u589e\u52a0\u4e00\u4e2a\uff0c\u5426\u5219\u76f8\u5f53\u4e8e\u5b83\u5c06\u4e00\u6b21\u53d6\u5f97\u533a\u95f4\u5b8c\u5168\u6d88\u9664\uff0c\u800c\u589e\u5e7f\u7684\u6bcf\u4e00\u6b21\u90fd\u662f\u6709\u610f\u4e49\u7684\uff0c\u4e0d\u53ef\u80fd\u88ab\u5b8c\u5168\u6d88\u9664\u8d21\u732e\u3002\n\n\u56e0\u6b64\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u6bcf\u6b21\u53d6\u6700\u5927\u533a\u95f4\uff0c\u53d6\u5b8c\u540e\u53d6\u53cd\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u8fdb\u884c $k$ \u6b21\uff0c\u53d6\u5230\u7684\u6700\u5927\u6743\u503c\u5c31\u662f\u7b54\u6848\u3002\n\n\u8d39\u7528\u6d41\u7684\u672c\u8d28\u5c31\u662f\u53ef\u4ee5\u53cd\u6094\u7684\u8d2a\u5fc3\uff0c\u6a21\u62df\u8d39\u7528\u6d41\u4e5f\u7ee7\u627f\u4e86\u8fd9\u4e00\u70b9\u3002\n\n\u5176\u4ed6\u4f8b\u9898\uff1a\n\n[P6122 [NEERC2016]Mole Tunnels](https://www.luogu.com.cn/problem/P6122)\n\n[\u3010UER #8\u3011\u96ea\u707e\u4e0e\u5916\u5356](https://uoj.ac/problem/455)\n\n[P5470 [NOI2019] \u5e8f\u5217](https://www.luogu.com.cn/problem/P5470)\n\n[P6943 [ICPC2018 WF]Conquer The World](https://www.luogu.com.cn/problem/P6943)",
        "postTime": 1646620914,
        "uid": 124918,
        "name": "LinkyChristian",
        "ccfLevel": 6,
        "title": "\u3010\u9898\u89e3\u3011CF280D k-Maximum Subsequence Sum"
    }
]