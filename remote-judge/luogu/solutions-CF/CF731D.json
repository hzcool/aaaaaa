[
    {
        "content": "[blog][blog]\n\n[blog]:https://blog.csdn.net/Diogenes_/article/details/79898713\n\n### \u9898\u76ee\u89e3\u91ca\uff1a\n\n\u6709n\u4e2a\u6570\u5217\uff0c\u6bcf\u4e2a\u6570\u5217\u957f\u5ea6\u53ef\u80fd\u4e0d\u4e00\u6837\uff0c\u540c\u65f6\u6709\u4e00\u4e2ac\uff0c\u4f60\u6709\u4e00\u79cd\u64cd\u4f5c\uff0c\u8ba9\u8fd9n\u4e2a\u6570\u5217\u4e2d\u6240\u6709\u5c0f\u4e8ec\u7684\u6570\u90fd\u52a01\uff0c\u6240\u6709\u7b49\u4e8ec\u7684\u6570\u53d8\u62100.\u95ee\u4f60\u6700\u5c11\u53ef\u4ee5\u64cd\u4f5c\u51e0\u6b21\u53ef\u4ee5\u8ba9\u8fd9n\u4e2a\u6570\u5217\u6ee1\u8db3\u5b57\u5178\u5e8f\n\n\u6211\u4eec\u53ef\u4ee5\u53d1\u73b0\uff0c\u5bf9\u4e8e\u4efb\u610f\u4e24\u4e2a\u76f8\u90bb\u7684\u6570\u5217\uff0c\u64cd\u4f5c\u6570k\u6709\u4e00\u4e2a\u7b26\u5408\u7684\u533a\u95f4\uff0c\u4e14k\u4e00\u5b9a\u5c0f\u4e8ec\uff0c\u56e0\u4e3a\u8fdb\u884cc\u6b21\u64cd\u4f5c\u4e4b\u540e\u7684\u6570\u5217\u4e0e\u539f\u6570\u5217\u76f8\u540c\uff0c\u76f8\u5f53\u4e8e\u6709\u4e00\u4e2a\u5faa\u73af\u7684\u8fc7\u7a0b\u3002\u53ea\u8981\u64cd\u4f5c\u6570k\u5728\u8fd9\u4e2a\u533a\u95f4\u91cc\u9762\uff0c\u4e0a\u9762\u7684\u6570\u5217\u5b57\u5178\u5e8f\u603b\u5c0f\u4e8e\u4e0b\u9762\u7684\u6570\u5217\u3002\u8bf4\u5f97\u901a\u4fd7\u4e00\u70b9\uff0c\u6709n-1\u4e2a\u533a\u95f4\uff08\u6709\u7279\u6b8a\u60c5\u51b5\uff0c\u770b\u4ee3\u7801\uff09\uff0c\u8981\u6c42\u8fd9n-1\u4e2a\u533a\u95f4\u7684\u4ea4\u3002\n\n\u600e\u4e48\u505a\u8fd9\u4e2a\u95ee\u9898\u5462\uff0c\u6211\u4eec\u53ef\u4ee5\u91c7\u53d6\u5dee\u5206+\u524d\u7f00\u548c\u7684\u65b9\u5f0f\u8fdb\u884c\u5904\u7406\uff0c\u5177\u4f53\u65b9\u6cd5\u5c31\u662f\u533a\u95f4\u4e24\u7aef\u4f4d\u7f6e\u653e\u4e2a++\u548c--\uff0c\u7edf\u8ba1\u65f6\u4ece\u524d\u5230\u540e\u52a0\u8d77\u6765\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u4e0b\u9762\u6765\u8ba8\u8bba\u4e00\u4e0b\u6bcf\u79cd\u60c5\u51b5\uff1a\n\n\u9996\u5148\u5047\u8bbe\u6709\u4e24\u4e2aword\uff0c\u5206\u522b\u53eb\u505aa\u548cb\uff0c\u5e76\u4e14\u6211\u4eec\u5b9a\u4e49\u4e24\u4e2aword\u7684\u5931\u914d\u4f4d\u7f6e\u4e3a\u4e24\u4e2aword\u4ece\u524d\u5f80\u540e\u9010\u4f4d\u6bd4\u8f83\uff0c\u6240\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u6709\u4e0d\u76f8\u540c\u5b57\u7b26\u7684\u4f4d\u7f6e\u3002\n\u5177\u4f53\u60c5\u51b5\u6709\u4e00\u4e0b\u56db\u79cd\uff1a\n\n1.\u5931\u914d\u4f4d\u7f6e\u5728a\uff0cb\u4e2d\uff08\u8868\u793a\u6ca1\u6709\u4e00\u4e2aword\u662f\u53e6\u4e00\u4e2aword\u7684\u524d\u7f00\uff09\uff0c\u4e14\u5931\u914d\u4f4d\u7f6e\u4e0a\u7684\u6570a\u6bd4b\u5c0f\u3002\n\n\u4e3e\u4e2a\u6817\u5b50 `a=13`  `b=15` `c=7`\u660e\u663e\u5730\uff0c\u5931\u914d\u4f4d\u7f6e\u5728\u7b2c\u4e8c\u4f4d\uff0c\u5931\u914d\u4f4d\u7f6e\u4e0a\u7684\u6570\u6ee1\u8db3a\u6bd4b\u5c0f\u3002\u753b\u4e2a\u8868\u683c\u6a21\u62df\u4e00\u4e0b\uff1a\n\n| \u64cd\u4f5c\u6b21\u6570 | a | b  |\n| -\n| 0  | 13 | 15 |\n| 1  | 24 | 26 |\n| 2  | 35 | 37 |  \n| 3  | 46 | 40 |\n| 4  | 57 | 51 |\n| 5  | 60 | 62 |\n| 6  | 71 | 73 |\n\n\u53ef\u4ee5\u770b\u51fa\uff0c\u5931\u914d\u4f4d\u7f6e\u524d\u7684\u6570\u5b57\u5bf9\u7ed3\u679c\u4e0d\u4ea7\u751f\u5f71\u54cd\uff08\u56e0\u4e3a\u59cb\u7ec8\u76f8\u540c\uff0c\u65e0\u6cd5\u6bd4\u8f83\u5b57\u5178\u5e8f\uff09\uff0c\u7531\u8868\u683c\u6613\u77e5\u5f53\u64cd\u4f5c\u6570\u5728$[0, 2] \\cup [5, 6]$\u7684\u60c5\u51b5\u4e0b\u662f\u53ef\u884c\u7684\u3002\u8fd9\u4e2a\u60c5\u51b5\u6bd4\u8f83\u590d\u6742\uff0c\u56e0\u4e3a\u4e3e\u5176\u4ed6\u4f8b\u5b50\u65f6\u6709\u53ef\u80fd\u7b2c\u4e8c\u4e2a\u533a\u95f4\u9000\u5316\u6210\u4e00\u4e2a\u6570\u751a\u81f3\u6d88\u5931\uff0c\u8fd9\u4f1a\u4e0d\u4f1a\u5bf9\u6211\u4eec\u7684\u7a0b\u5e8f\u4ea7\u751f\u4ec0\u4e48\u5f71\u54cd\u5462\uff08\u6bd4\u5982\u8bf4\u8981\u7279\u5224\u4e4b\u7c7b\u7684\uff09\uff1f\u7b54\u6848\u662f\u4e0d\u4f1a\u3002\u56e0\u4e3a\u5047\u8bbe\u7b2c\u4e8c\u4e2a\u533a\u95f4\u7684\u5f62\u5f0f\u662f$[p, q]$\uff0c\u7b2c\u4e8c\u4e2a\u533a\u95f4\u6d88\u5931\u65f6\u4e00\u5b9a\u6ee1\u8db3$p = q + 1$(\u8fd9\u4e2a\u5f88\u91cd\u8981\uff0c\u8981\u81ea\u5df1\u591a\u4e3e\u51e0\u4e2a\u4f8b\u5b50\u7406\u89e3\u4e00\u4e0b\uff0c\u6211\u8fd9\u91cc\u5c31\u4e0d\u8bc1\u660e\u4e86)\uff0c\u800c\u6211\u4eec\u7684\u7a0b\u5e8f\u4f1a\u5728$p$\u7684\u4f4d\u7f6e+1\uff0c\u5728$q + 1$\u7684\u4f4d\u7f6e-1\uff0c\u4e24\u4e2a\u52a0\u4e00\u51cf\u4e00\u76f8\u4e92\u62b5\u6d88\u4e86\uff0c\u56e0\u6b64\u5bf9\u6211\u4eec\u7684\u7a0b\u5e8f\u4e0d\u4ea7\u751f\u5f71\u54cd\u3002\n\n2.\u5931\u914d\u4f4d\u7f6e\u5728a\uff0cb\u4e2d\uff08\u8868\u793a\u6ca1\u6709\u4e00\u4e2aword\u662f\u53e6\u4e00\u4e2aword\u7684\u524d\u7f00\uff09\uff0c\u4e14\u5931\u914d\u4f4d\u7f6e\u4e0a\u7684\u6570a\u6bd4b\u5927\u3002\n\n\u4ecd\u7136\u4e3e\u4e2a\u6817\u5b50 `a=14` `b=12` `c=7`\uff0c\u8fd9\u4e2a\u76f8\u5bf9\u8f83\u6613\uff0c\u6211\u5c31\u4e0d\u753b\u8868\u683c\u6a21\u62df\u4e86\uff0c\u64cd\u4f5c\u6570\u7684\u533a\u95f4\u4e3a$[4, 5]$\n3.\u5931\u914d\u4f4d\u7f6e\u5728a\u7684\u672b\u5c3e\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff08a\u662fb\u7684\u524d\u7f00\uff09\uff0c\u8fd9\u4e2a\u5f88\u7b80\u5355\u4e0d\u7ba1\u4f60\u600e\u4e48\u64cd\u4f5ca\u59cb\u7ec8\u6bd4b\u5c0f\uff0c\u64cd\u4f5c\u533a\u95f4$[0, c - 1]$\n\n4.\u5931\u914d\u4f4d\u7f6e\u5728b\u7684\u672b\u5c3e\u7684\u540e\u4e00\u4e2a\u4f4d\u7f6e\uff08b\u662fa\u7684\u524d\u7f00\uff09\uff0c\u8fd9\u4e2a\u4e5f\u5f88\u7b80\u5355\uff0c\u76f4\u63a5\u5c31\u662f\u65e0\u89e3\uff0c\u4e0d\u9700\u8981\u8fdb\u884c\u4efb\u4f55\u64cd\u4f5c\uff0c\u76f4\u63a5\u8f93\u51fa\u65e0\u89e3\u53ef\u4ee5\uff0ccontinue\u4e5f\u53ef\u4ee5\uff08\u7f3a\u5c11\u4e00\u4e2a\u533a\u95f4\u5c31\u6c38\u8fdc\u65e0\u6cd5\u8ba9k\u6ee1\u8db3n-1\u4e2a\u533a\u95f4\uff09\u3002\n\n\u56db\u79cd\u60c5\u51b5\u8ba8\u8bba\u5b8c\u4e86\uff0c\u5177\u4f53\u8be6\u60c5\u770b\u4ee3\u7801\u5427\u3002\n\n### Codes\n```\n#include<cstdio>\n#include<vector>\n#include<cstring>\nusing namespace std;\nconst int MAXN = 1e6 + 10;\nconst int MAXC = 1e7 + 10;\nvector<int> words[MAXN];\nint cnt[MAXC], n, c;\nvoid calc(int a, int b)\n{\n    int index = 0;\n    while (index < words[a].size() && index < words[b].size()) //\u5931\u914d\u4f4d\u7f6e\u67e5\u8be2\n    {\n        if (words[a][index] != words[b][index]) break;\n        index++;\n    }\n    if (index < words[a].size() && index < words[b].size()) // \u5931\u914d\u4f4d\u7f6e\u5728a, b\u4e2d\n    {\n        if (words[a][index] < words[b][index]) // \u5931\u914d\u4f4d\u7f6ea\u5c0f\u4e8eb\n        {\n            cnt[0]++;\n            cnt[c - words[b][index] + 1]--;\n            cnt[c - words[a][index] + 1]++;\n            cnt[c]--;\n        }\n        else\n        {\n            cnt[c - words[a][index] + 1]++;\n            cnt[c - words[b][index] + 1]--;\n        }\n    }\n    else if (index == words[a].size() && index != words[b].size()) //a\u6bd4b\u77ed\n    {\n        cnt[0]++;                                   \n        cnt[c]--;                                  \n    }\n    else if (index != words[a].size() && index == words[b].size()); // a\u6bd4b\u957f\uff0c\u65e0\u89e3\n    else //a\u548cb\u4e00\u6837\u957f\n    {\n        cnt[0]++;\n        cnt[c]--;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\", &n, &c); \n    for (int i = 1;i <= n;i++)\n    {\n        int len, w;\n        scanf(\"%d\", &len);\n        while (len--)\n        {\n            scanf(\"%d\", &w);\n            words[i].push_back(w);\n        }\n    }\n    for (int i = 1;i <= n - 1;i++) calc(i, i + 1);\n    bool flag = false;\n    int sum = 0;\n    for (int i = 0;i < c;i++)\n    {\n        sum += cnt[i];\n        if (sum == n - 1)\n        {\n            flag = true;\n            printf(\"%d\\n\", i);\n            return 0;\n        }\n    }\n    if (!flag) printf(\"-1\\n\");\n    return 0;\n}\n\n```",
        "postTime": 1526949813,
        "uid": 12472,
        "name": "Nekroz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF731D \u301080-th Level Archeology\u3011"
    },
    {
        "content": "[For a better experience please click here.](https://www.cnblogs.com/BrianPeng/p/16928706.html)\n\n## Solution: CF731D 80-th Level Archeology -- Letter, Interval, and Reverse Thinking\n\nLink to the question: [CF](https://codeforces.com/problemset/problem/731/D) [Luogu](https://www.luogu.com.cn/problem/CF731D)\n\n### Preface\n\n*Assertion: \"STL `set` is the most 'powerful' tool throughout C++.\"*\n\n~~\"Not because it is capable of various tasks, but because we don't need to code it ourselves.\"~~\n\n### What is lexicographical order?\n\nLexicographical order is an ordering of strings based on the ordering of characters. A string is less than another string when, at the first position of difference, the letter in the first string is less than the corresponding letter in the second.\n\nIt is the ordering of words in a dictionary.\n\nE.g. In the normal alphabet, 'abceb'<'abdca' since 'c'<'d' at their third position, the first position of difference. Note that we only consider the first position of difference. Even though 'e' is greater than 'c' at the fourth position and 'b' is greater than 'a' at the fifth, they cannot affect our comparison.\n\nP.s. We let the 'empty character' be the smallest. E.g. To compare 'an' and 'and', we may consider the third position of 'an' as the empty character, then 'an'<'and' as the empty character is less than 'd'.\n\n### Back to the question\n\n\"One operation replaces each letter with the next letter in the alphabet.\"\n\nWe try to find the number of operations to make all the words in lexicographical order.\n\nReverse Thinking: One operation replaces each letter **in the alphabet** with its previous one.\n\nE.g. Consider the first example (We use letters to make it more intuitive). The strings are\n\n```\ncb\na\nbca\nbcab\n```\n\nand the alphabet is `a<b<c`.\n\nAfter one operation, the strings become\n\n```\nac\nb\ncab\ncabc\n```\n\nwhich are in lexicographical order.\n\nReverse Thinking: after one operation, we 'rotate the alphabet' to `c<a<b`. And now, the strings are in lexicographical order **based on our new alphabet.**\n\n**The solution is to find a reordering of the alphabet to make the strings in lexicographical order.**\n\n### How to reorder the alphabet?\n\n\"From the order of characters, we develop an order of strings.\"\n\nReverse Thinking: From the order of strings, we deduce the order of characters.\n\nE.g. Given that 'ace'<'abd' in some alphabet, we know that 'c'<'b' in that alphabet (and this is the only information we can extract).\n\nThe method is: **Find the first position of difference, then the character in the first string at that position is less than the corresponding character in the second string.**\n\nP.s. As we know that the empty character is invariantly the smallest, there is no alphabet satisfying 'and'<'an'.\n\nTo deal with this question, we assume that the strings are in lexicographical order in some alphabet, and by comparing strings, we know some orders between characters in that alphabet. At last, we check whether a rotation of the switch results in an alphabet satisfying all conditions.\n\nWe know that after rotation, the new alphabet must be in the form of\n\n$a,a+1,\\cdots,n-1,n,1,2,\\cdots,a-1$\n\nfor some $a\\in\\{1,\\cdots, n\\},$ which is the smallest character (except empty character).\n\n*In the following text, we use '$<$' to denote the normal comparison between numbers, and '$\\prec$' to denote the comparison in alphabetical order.*\n\n##### Case 1:\n\nBy comparing two strings, we know that $u\\prec v,$ while $u<v.$\n\nE.g. If the strings `1 2 3` < `1 3 2`, then we know that $2\\prec 3$ in this alphabet, while $2<3$ in number order.\n\nWe may use $u$ and $v$ to restrict the range of $a,$ the smallest character in the new alphabet.\n\nThe restriction is: $a\\notin [u+1,v]$ because contrarily, if $a$ is in the range, the alphabet is\n\n$a,a+1,\\cdots,v,\\cdots,n,1,\\cdots,u,\\cdots,a-1,$ where $v\\prec u$ in the alphabet, a contradiction.\n\nWe may check that $a$ outside the interval satisfies $u\\prec v.$\n\n##### Case 2:\n\nBy comparing two strings, we know that $u\\prec v,$ while $u>v.$\n\nE.g. If the strings `1 3 2` < `1 2 3`, then we know that $3\\prec 2$ in this alphabet, while $3>2$ in number order.\n\nThe restriction now is: $a\\in [v+1,u].$ (Why?)\n\n### Implementation\n\nTo combine all the restrictions, $a$ is\n\n1. not in the **union** of all the intervals of case 1;\n2. in the **intersection** of all the intervals of case 2.\n\nFor case 2, maintaining the intersection of intervals is easy. Suppose the current interval is $[l,r],$ then its intersection with $[u,v]$ is just $[\\max(l,u),\\min(r,v)].$ (If the right boundary is less than the left, then we regard it as the empty interval.)\n\nFor case 1, maintaining the union of intervals is not so easy. One offline method is to sort all the intervals by left boundaries, and then combine them if they have non-empty intersections.\n\nHowever, I'd like to introduce an online method of maintaining unions of intervals, which is, sometimes, even easier to implement than the offline method.\n\n#### Use STL `set` to maintain the union of intervals.\n\n~~That's why it is the most powerful tool in C++~~\n\nWe let the set store disjoint intervals (i.e. intervals that don't intersect) in order. Whenever we try to add a new interval, we combine it with the existing intervals that intersect with it.\n\nOur data structure:\n\n```cpp\nstruct T{int l,r;\n\tbool operator<(T b)const{return r<b.l;}\n};\nset<T>//our data structure\n```\n\nNote the way we define the order between intervals (which is necessary when using `set`). We define an interval to be less than another only when the first is on the left of the second and they are **disjoint**. Thus, if two intervals intersect, the `set` considers them equal (more exactly, neither less than nor greater than).\n\nAnother important feature of `set` is its `find()` function, which returns the iterator (the pointer) to the first element that is 'equal' to our input.\n\nNow, suppose we have a set with intervals $\\{[1,3],[5,5],[7,9],[10,11]\\}$ and we want to add the interval $[2,8]$. What should we do?\n\n1. We use `find()` to search for the first interval that intersects with $[2,8],$ which is $[1,3].$ Combine them to get $[1,8].$ Erase $[1,3]$ in the set. Now, our task becomes \"adding $[1,8]$ to the set $\\{[5,5],[7,9],[10,11]\\}$\".\n2. We find $[5,5]$ in the set. As it is already contained in $[1,8]$ we erase it from the set. Now, our task becomes \"adding $[1,8]$ to the set $\\{[7,9],[10,11]\\}$\".\n3. We find $[7,9]$ in the set. Combine it with $[1,8]$ to get $[1,9]$. Now, our task becomes \"adding $[1,9]$ to the set $\\{[10,11]\\}$\".\n4. As there is no interval in the set that interests with $[1,9],$ we add it to the set. The set becomes $\\{[1,9],[10,11]\\}.$ Terminate.\n\nThe general procedure is: When adding an interval $[u,v]$ to the set $S$,\n\n1. if no interval in $S$ intersects with $[u,v],$ then add it by `insert()` method.\n2. otherwise, find the interval $[l,r]\\in S$ that intersects with $[u,v].$\n3. combine them to get $[\\min(u,l),\\max(v,r)]$ and make it the new $[u,v].$\n4. remove $[l,r]$ from $S.$ Repeat step 1.\n\n#### Derive the answer\n\n* Let $[l,r]$ be the intersection of intervals from case 2, then $a\\in[l,r].$\n\n* Let $S$ be the union of intervals from case 1, then $a$ is not contained by any interval in $S$.\n\nWe may reformulate the second point: \"$[a,a]$ does not intersect with any interval in $S.$\" This makes our lives easier as we may use `find()` method to check if there is an interval in $S$ that is 'equal' to $[a,a],$ which means there is an interval that intersects with $[a,a].$\n\nLastly, if $a$ really exists, the number of operations is $(c+1-a)\\bmod c.$ (Why?)\n\n#### Complexity\n\nTime: as there are $n$ strings, there are $O(n)$ restrictions (every comparison between adjacent strings gives at most one restriction). Each restriction in case 1 is an interval, which can only be inserted into the `set`, found by `find()`, and erased once. The `set` operations above take $O(\\log n)$ times each (as the set has $O(n)$ elements), so overall the time complexity is $O(n\\log n).$\n\nMemory: $O(n).$\n\n#### Code\n\nIn the following code, we use $[pl,pr]$ as the interval of 'possibility' (case 2). The `set` for case 1 is named `ip` for 'impossiblilty'.\n\n```cpp\n//This program is written by Brian Peng.\n#include<bits/stdc++.h>\nusing namespace std;\n#define Rd(a) (a=rd())\n#define Gc(a) (a=getchar())\n#define Pc(a) putchar(a)\nint rd(){\n\tint x;char c(getchar());bool k;\n\twhile(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);\n\tc^'-'?(k=1,x=c&15):k=x=0;\n\twhile(isdigit(Gc(c)))x=x*10+(c&15);\n\treturn k?x:-x;\n}\nvoid wr(int a){\n\tif(a<0)Pc('-'),a=-a;\n\tif(a<=9)Pc(a|'0');\n\telse wr(a/10),Pc((a%10)|'0');\n}\nsigned const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);\nlong long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);\n#define Ps Pc(' ')\n#define Pe Pc('\\n')\n#define Frn0(i,a,b) for(int i(a);i<(b);++i)\n#define Frn1(i,a,b) for(int i(a);i<=(b);++i)\n#define Frn_(i,a,b) for(int i(a);i>=(b);--i)\n#define Mst(a,b) memset(a,b,sizeof(a))\n#define File(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\n#define N (1000010)\nint n,c,w[2][N],l[2],pl(1),pr;\nbool t;\nstruct T{int l,r;\n\tbool operator<(T b)const{return r<b.l;}\n};\nset<T>ip;//set of case 1\nset<T>::iterator it;\nvoid mdf(int u,int v);//adding a restriction \"u is less than v in the alphabet\"\nsigned main(){\n\tRd(n),pr=Rd(c);//the possibility interval is originally set as [1,c]\n\tRd(l[t]);\n\tFrn1(i,1,l[t])Rd(w[t][i]);\n\tFrn1(i,2,n){\n\t\tt^=1,cin>>l[t];\n\t\tFrn1(i,1,l[t])Rd(w[t][i]);\n\t\tw[t][l[t]+1]=0;//set the empty character\n\t\tFrn1(i,1,l[t^1])if(w[t][i]!=w[t^1][i]){\n\t\t\tif(!w[t][i])wr(-1),exit(0);//the case when the empty character\n\t\t\t//is greater than another character, which is impossible\n\t\t\tmdf(w[t^1][i],w[t][i]);//add restriction\n\t\t\tbreak;\n\t\t}\n\t}\n\tFrn1(i,pl,pr)if(ip.find({i,i})==ip.end())wr((c+1-i)%c),exit(0);\n\t//check whether i is in the interval [pl,pr] for case 2\n\t//while not contained in the set for case 1\n\twr(-1),exit(0);\n}\nvoid mdf(int u,int v){\n\tif(u<v){//case 1\n\t\t++u;//the interval added is [u+1,v]\n\t\twhile((it=ip.find({u,v}))!=ip.end())//find the interval in the set\n\t\t//that intersects with it\n\t\t\tu=min(u,it->l),v=max(u,it->r),ip.erase(it);//combine and remove\n\t\tip.insert({u,v});//insert the combined interval\n\t}else pl=max(pl,v+1),pr=min(pr,u);//case 2\n}\n\n```\n\n### Extension\n\nWhat if the question becomes that you can reorder the alphabet to any permutation of $\\{1,\\cdots,c\\}$?\n\nWe still need to find the restriction between characters. But now, as we don't have a specific reordering pattern, we may treat each restriction $u\\prec v$ as a directed edge $u\\to v$ in a graph with vertices $\\{1,\\cdots, c\\}.$ Then, we may find the reordering of the alphabet as a topological ordering of the vertices, if it exists (i.e. the graph is a DAG).\n\nDo you want to ask me why I thought about this? Because I originally thought this is the solution, but I found it too difficult to find a topological order being a cycle of $(1,2,\\cdots,n).$ Eventually, I came up with this solution, making use of the reordering being a cycle.\n\n*A slight change in question leading to a totally different method,* ~~maybe this is just why algorithms are so intriguing...~~\n\n#### Thanks for your reading. \u3042\u308a\u304c\u3068\u3046\uff01\n",
        "postTime": 1669479884,
        "uid": 66199,
        "name": "Bring",
        "ccfLevel": 5,
        "title": "Solution: CF731D 80-th Level Archeology -- Letter, Interval, and Reverse Thinking"
    },
    {
        "content": "\u9898\u610f\u5f88\u597d\u7406\u89e3\uff0c\u4f46\u5173\u952e\u662f\u7528\u4ec0\u4e48\u65b9\u6cd5\u53bb\u505a\u8fd9\u4e2a\u95ee\u9898\u3002\n\n\n\n\u8bbe\uff1a\u524d\u4e00\u4e2a\u6570\u5217\u4e3aa[i],\u540e\u4e00\u4e2a\u4e3ab[j],\u53ea\u8981i=j,a[i]>b[j],\u5c31\u8981\u8fdb\u884c+1\u64cd\u4f5c\u3002\n\n\u540c\u65f6\u4e3e\u4e00\u4e0b\u53cd\u4f8b\uff0c\u6bd4\u5982a[i],b[j],i>j,\u4f46\u662f\u524d\u9762\u7684\u5143\u7d20\u90fd\u662f\u76f8\u540c\u7684\uff0c\u90a3\u4e48\u524d\u8005\u7684\u5b57\u5178\u5e8f\u80af\u5b9a\u6bd4\u540e\u8005\u7684\u5927\uff0c\u6216\u8005\u8fd8\u6709\u5c31\u662f\u50cf\u6837\u4f8b3\u8fd9\u6837\u7684\u3002\n\n\u5173\u4e8e\u8fd9\u9053\u9898\u7684\u601d\u8def\uff0c\u9996\u5148\u6211\u4eec\u8981\u660e\u786e\u4e00\u70b9\u6211\u4eec\u65e0\u6cd5\u77e5\u9053\u6211\u4eec\u8981\u52a0\u591a\u5c11\u6b211\uff0c\u4f46\u6211\u4eec\u77e5\u9053\u6211\u4eec\u53ef\u4ee5\u52a0\u591a\u5c11\u6b211\uff0c\u5373\u52a0\u591a\u5c11\u6b211\u5c31\u53ef\u4ee5\u6ee1\u8db3\u524d\u5c0f\u540e\u5927\u7684\u6761\u4ef6\uff08\u5982\u679c\u6570\u5217\u7684\u5b57\u5178\u5e8f\u76f8\u540c\uff0c\u90a3\u4e48\u6211\u4eec\u662f\u53ef\u4ee5\u968f\u4fbf\u52a0\u7684\uff09\u3002\n\n\u4f8b1\uff1a\ni=j,a[i]<b[j],\u8fd9\u4e2a\u60c5\u51b5\uff0c\u6211\u4eec\u53ea\u8981\u5904\u7406\u5b89\u6392a[i],\u4f7f\u4e4b\u7ee7\u7eed\u6210\u7acb\u5373\u53ef\u3002\n\n\u4f8b2\uff1a\n1-9 a[i]=2 a[j]=5,[1,4]\u6216\u8005[8,9],a[i]\uff0cb[j]\u540c\u65f6\u52a0\u4e0a\u8fd9\u4e9b\u503c\u4e5f\u662f\u6210\u7acb\u3002\n\n\u4f8b3\uff1a\ni=j, a[i]>b[j],\u6211\u4eec\u8fd8\u662f\u5904\u7406\u554aa[i]\uff0c\u4f7f\u4e4b\u6210\u7acb\u5373\u53ef\uff0c\u4e3e\u4f8b\u8bf4\u660e\uff0c1-9 5 2\uff0c[5,7],a[i]\uff0cb[j]\u540c\u65f6\u52a0\u4e0a\u8fd9\u4e9b\u503c\u5c31\u662f\u6210\u7acb\u3002\n\n\u4f8b4\uff1a\n\u5982\u679c\u76f8\u540c\uff0c[1,m],\u65e0\u8bba\u540c\u65f6\u52a0\u4e0a\u8fd9\u4e9b\u503c\u4e2d\u7684\u54ea\u4e2a\u4e5f\u90fd\u662f\u6210\u7acb\u7684\u3002\u4f46\u5982\u679c\u51fa\u73b0\u524d\u9762\u7684\u60c5\u51b5\uff0c\u5c31\u4e0d\u884c\u4e86\u3002\n\n\u600e\u4e48\u4f7f\u5f97\u533a\u95f4\u4fee\u6539\u5462\uff1f\u6811\u72b6\u6570\u7ec4\uff0c\u5dee\u5206\u65b9\u6cd5\uff0c[l,r],\u7ed9\u4ecec[l]+1,c[r+1]-1\uff0c\u5373\u53ef\u3002\n\n\u6211\u4eec\u8981\u6ce8\u610f\u4e00\u70b9\uff0c\u73b0\u5728\u6811\u72b6\u6570\u7ec4\u91cc\u7684\u6570\u503c\u4e0d\u662f\u6570\u5217\u7684\u503c\uff0c\u800c\u662f\u8bb0\u5f55\u4e86\u4fee\u6539\u7684\u6b21\u6570\uff0c\u4e24\u8005\u76f8\u4f3c\uff0c\u5207\u83ab\u641e\u6df7\uff08\u76f8\u4f3c\u7684\u539f\u56e0\u662f\u6570\u5217\u6700\u591a\u4fee\u6539m\u6b21\uff09\u3002\n\n\u6700\u540e\u8bb0\u5f55\u4e00\u4e0b\u54ea\u4e2a\u64cd\u4f5c\u51fa\u73b0\u4e86n-1\u6b21\u5c31\u662f\u7b54\u6848\uff08\u6ce8\u610f\u6811\u72b6\u6570\u7ec4\u4e0d\u5f00\u4e0b\u68070\uff0c\u6240\n\u4ee51\u51fa\u73b0\u4e86n-1\uff0c\u4ee3\u8868\u4e860\u6b21\u64cd\u4f5c\u51fa\u73b0n-1\u6b21\uff09\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <bits/stdc++.h>\n#define ll long long\n#define mem(a,b) memset(a,b,sizeof(a))\n#define fo1(a,b) for(int a=0;a<b;++a)\n#define fo2(a,b) for(int a=1;a<=b;++a)\n#define lowbit(a) a&(-a)\nusing namespace std;\nconst int maxn=1e6+5;\nconst int mod=1e9+7;\nint c[maxn];\nint num[2][maxn];\nvoid update(int x,int y,int n)\n{\n    while(x<=n)\n    {\n        c[x]+=y;\n        x+=lowbit(x);\n    }\n}\nvoid two_update(int x,int y,int n)\n{\n    update(x,1,n);\n    update(y+1,-1,n);\n}\nint query(int x)\n{\n    int ans=0;\n    while(x)\n    {\n        ans+=c[x];\n        x-=lowbit(x);\n    }\n    return ans;\n}\nint main()\n{\n    int n,m,cnt,tecnt,cnr=0;\n    bool flag=1;\n    cin>>n>>m;\n    scanf(\"%d\",&cnt);\n    fo1(i,cnt)\n    scanf(\"%d\",&num[cnr][i]);\n    tecnt=cnt;\n    cnr^=1; //\u8fd9\u91cc\u5f02\u62161\u53ef\u4ee5\u57280 1\u4e4b\u95f4\u5207\u6362\uff0c\u6a21\u62df\u524d\u540e\u6570\u5217\u6bd4\u8f83\n    fo2(k,n-1)\n    {\n        scanf(\"%d\",&cnt);\n        fo1(i,cnt)\n        scanf(\"%d\",&num[cnr][i]);\n        if(flag)\n        {\n            bool flag1=0;\n            fo1(i,min(cnt,tecnt))\n            {\n                if(num[cnr][i]>num[cnr^1][i])\n                {\n                    flag1=1;\n                    two_update(1,m-num[cnr][i]+1,m+5);\n                    two_update(m-num[cnr^1][i]+2,m,m+5);\n                    break;\n                }\n                else if(num[cnr][i]<num[cnr^1][i])\n                {\n                    flag1=1;\n                    two_update(m-num[cnr^1][i]+2,m-num[cnr][i]+1,m+5);\n                    break;\n                }\n            }\n            if(!flag1)\n            {\n                if(tecnt>cnt)\n                    flag=0;\n                else\n                    two_update(1,m,m+5);\n            }\n            tecnt=cnt;\n            cnr^=1;\n        }\n    }\n    int ans=-1;\n    if(flag)\n    {\n        fo2(i,m)\n        {\n            if(query(i)==n-1)\n            {\n                ans=i-1;\n                break;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n\n```",
        "postTime": 1583828149,
        "uid": 265539,
        "name": "Mint_Flipped",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF731D \u301080-th Level Archeology\u3011"
    }
]