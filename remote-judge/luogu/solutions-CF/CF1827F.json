[
    {
        "content": "\u4e0d\u59a8\u5148\u8003\u8651\u4e00\u4e2a\u5f31\u5316\u7248\u7684\u95ee\u9898\uff0c\u8fd9\u4e2a\u95ee\u9898\u548c\u539f\u6765\u7684\u95ee\u9898\u4ec5\u6709\u4e00\u4e2a\u533a\u522b\uff1a$k$ \u662f\u7ed9\u5b9a\u6574\u6570\u3002  \n\u79f0\u6700\u540e $n-k$ \u4e2a\u6570\u662f\u201c\u7279\u6b8a\u7684\u201d\u3002\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u6ce8\u610f\u5230\uff0c\u6bcf\u4e2a\u7279\u6b8a\u7684\u6570\u5b57\u7684\u6781\u5927\u6bb5\u5fc5\u7136\u9012\u589e\u653e\u7f6e\u6216\u8005\u9012\u51cf\u653e\u7f6e\u3002\u4f8b\u5982\u6211\u4eec\u6709\u6392\u5217 $[7,5,8,1,4,2,6,3]$ \u800c\u4e14 $k=2$\uff0c\u90a3\u4e48\u6781\u5927\u6bb5\u7684\u4e0b\u6807\u5e94\u8be5\u662f $[1,4],[6,6],[8,8]$\u3002  \n\u6211\u4eec\u628a\u6240\u6709\u7684\u597d\u5b50\u4e32\u5206\u6210\u4e09\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u662f\u524d\u7f00\uff0c\u4e00\u90e8\u5206\u662f\u540e\u7f00\uff0c\u5269\u4e0b\u7684\u662f\u7b2c\u4e09\u90e8\u5206\u3002\u5bf9\u4e8e\u524d\u4e24\u79cd\u5b50\u4e32\uff0c\u7528 CF526F \u7684\u7b97\u6cd5\u5c31\u53ef\u4ee5\u987a\u5229\u89e3\u51b3\uff0c\u8fd9\u91cc\u7565\u53bb\u8bb2\u89e3\u3002  \n\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u4f18\u96c5\u7684\u6570\u7ec4 $ele$ \u6ee1\u8db3 $\\forall i,ele_i<ele_{i+1}$ \u4e14 $p[ele_i,k]$ \u5305\u62ec\u4e86\u8fde\u7eed\u975e\u7279\u6b8a\u6570\u5b57\u3002  \n\u63a5\u4e0b\u6765\uff0c\u6211\u4eec\u5c1d\u8bd5\u7740\u5411\u5df2\u6709\u7684\u6392\u5217\uff08\u5373\u6392\u5217\u7684\u4e00\u90e8\u5206\uff09\u4e2d\u6dfb\u52a0\u7279\u6b8a\u6570\u5b57\u3002  \n\u5bf9\u4e8e\u8fd9\u4e2a\u4f18\u96c5\u6570\u7ec4\uff0c\u6211\u4eec\u4ece\u53f3\u5411\u5de6\u7684\u5904\u7406\uff0c\u800c\u7279\u6b8a\u7684\u6570\u5b57\u5219\u4ece\u5de6\u5411\u53f3\u52a0\u3002\u90a3\u4e48\u5bf9\u4e8e\u4e00\u4e2a\u6570\u7ec4\u4e2d\u7684\u5143\u7d20 $ele_i$\uff0c\u5148\u628a\u7279\u6b8a\u6570\u5b57\u653e\u8fdb\u53bb\u4ee5\u8ba9\u7b54\u6848\u52a0\u4e00\uff0c\u7136\u540e\u8003\u8651\u4e24\u4e2a\u6781\u5927\u6bb5\uff0c\u4ed6\u4eec\u5206\u522b\u5305\u542b $mn_i-1$ \u548c $mx_i+1$\uff0c\u5176\u4e2d $mn,mx$ \u5206\u522b\u4e3a $p[ele_i,k]$\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u8fd9\u4fe9\u6bb5\u653e\u4e0a\u4ee5\u589e\u5927\u7b54\u6848\u3002  \n\u53e6\u4e00\u65b9\u9762\uff0c\u6ce8\u610f\u5230 $mx_i=mx_{i+1}=\\dots=mx_{j}$ \u7684\u65f6\u5019\uff0c\u5982\u679c $\\forall i\\le x<j, p[ele_x,ele_{x+1}]$ \u662f\u597d\u7684\uff0c\u90a3\u4e48\u4ed6\u4eec\u90fd\u53ef\u4ee5\u83b7\u5f97\u8d21\u732e\u3002  \n\u5bf9\u6bcf\u4e2a\u6709\u76f8\u540c $mn$ \u7684\u4f18\u96c5\u4f4d\u7f6e\u5206\u522b\u8ba1\u7b97\u5373\u53ef\u3002  \n\n\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u4e2a $k$\uff0c\u6211\u4eec\u9884\u5904\u7406 $mn,mx$ \u7b49\u4ef7\u4f4d\u7f6e\u7684\u524d\u7f00\u3002\u8f6c\u79fb\u65f6\u6211\u4eec\u53ea\u9700\u8981\u8003\u8651\u4e24\u4e2a\u4f18\u96c5\u4f4d\u7f6e\uff1a\u4e00\u4e2a\u662f $k$\uff08\u6b64\u65f6\uff0c\u82e5 $p_{k-1}<p_k$\uff0c\u76f4\u63a5\u4ee4 $j=lst(p_j>p_k)$\uff0c\u53cd\u4e4b\u4ea6\u7136\uff09\uff0c\u4e0b\u4e00\u4e2a\u5f53\u7136\u5c31\u662f $j$ \u7684\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u800c\u663e\u7136\u5b83\u5177\u6709\u6027\u8d28\uff1a\u5b83\u5fc5\u7136\u662f\u6700\u540e\u4e00\u4e2a $mn,mx$ \u7b49\u4ef7\u4f4d\u7f6e\u3002\u90a3\u4e48\u5904\u7406\u8fd9\u4e9b\u4f4d\u7f6e\u4e0d\u4f1a\u5f71\u54cd\u540e\u9762\u7684\u4f4d\u7f6e\u3002\u590d\u6742\u5ea6\u663e\u7136\u662f $O(n\\log n)$ \u7684\u3002  \n\n\u6838\u5fc3\u4ee3\u7801\u5927\u81f4\u5982\u4e0b\uff1a \n\n```cpp\nvoid work(int i, int j, bool recalc) {\n    int imin = calc_min(i), imax = calc_max(i), jmin = calc_min(j), jmax = calc_max(j);\n    int type;\n    if (recalc) {\n        mid -= 1ll * lmax[j].maxx * (rr[jmax] - jmax - 1);\n        mid -= 1ll * lmin[j].maxx * (jmin - ll[jmin] - 1);\n    }\n\n    if (imax == jmax) {\n        if (!recalc)\n            mid -= 1ll * lmax[i].maxx * (rr[imax] - imax - 1);\n\n        if (jmin - imin == j - i)\n            type = 0;\n        else {\n            type = 2 - (imin + j - i == ll[jmin] + 1);\n        }\n        if (type == 2)\n            lmax[j] = cop(1, lmax[i].maxx, type);\n        else if (lmax[i].type == 0)\n            lmax[j] = cop(lmax[i].curr + 1, lmax[i].maxx, type);\n        else\n            lmax[j] = cop(2, lmax[i].maxx, type);\n\n    } else\n        lmax[j] = {1, 1, 3};\n    if (imin == jmin) {\n        if (!recalc)\n            mid -= 1ll * lmin[i].maxx * (imin - ll[imin] - 1);\n\n        if (imax - jmax == j - i)\n            type = 0;\n        else if (imax + i - j == rr[jmax] - 1)\n            type = 1;\n        else\n            type = 2;\n\n        if (type == 2)\n            lmin[j] = cop(1, lmin[i].maxx, type);\n        else if (lmin[i].type == 0)\n            lmin[j] = cop(lmin[i].curr + 1, lmin[i].maxx, type);\n        else\n            lmin[j] = cop(2, lmin[i].maxx, type);\n\n    } else\n        lmin[j] = {1, 1, 3};\n\n    mid += 1ll * lmax[j].maxx * (rr[jmax] - jmax - 1);\n    mid += 1ll * lmin[j].maxx * (jmin - ll[jmin] - 1);\n}\n\nvoid solve() {\n    elem.clear();\n    minn.assign(1, 0), maxx.assign(1, 0);\n    set<int> ss;\n    ss.insert(0), ss.insert(n + 1);\n    pre = 0, suf = 1ll * n * (n + 1) / 2, mid = 0;\n    cout << suf << ' ';\n    ll[n] = 0, rr[0] = n;\n    seg1.build(1, 1, n);\n    init();\n    for (int i = 1; i <= n; i++) {\n        while (elem.size()) {\n            int j = elem.back();\n            int jmin = calc_min(j), jmax = calc_max(j);\n            if (get_min_pos(min(jmin, a[i]), max(jmax, a[i])) < j) {\n                mid -= 1ll * lmax[j].maxx * (rr[jmax] - jmax - 1);\n                mid -= 1ll * lmin[j].maxx * (jmin - ll[jmin] - 1);\n                elem.pop_back();\n                if (elem.size()) {\n                    if (lmax[j].type < 3)\n                        mid += 1ll * lmax[elem.back()].maxx * (rr[jmax] - jmax - 1);\n                    if (lmin[j].type < 3)\n                        mid += 1ll * lmin[elem.back()].maxx * (jmin - ll[jmin] - 1);\n                }\n            } else\n                break;\n        }\n        if (elem.size()) {\n            int j = elem.back();\n            int jmin = calc_min(j), jmax = calc_max(j);\n            mid -= 1ll * lmax[j].maxx * (rr[jmax] - jmax - 1);\n            mid -= 1ll * lmin[j].maxx * (jmin - ll[jmin] - 1);\n        }\n        auto it = ss.upper_bound(a[i]);\n        suf -= 1ll * (*it - a[i]) * (a[i] - *prev(it));\n        connect(*prev(it), a[i]), connect(a[i], *it);\n        ss.insert(a[i]);\n        while (maxx.size() > 1 && a[maxx.back()] < a[i]) {\n            seg1.easy_update(maxx[maxx.size() - 2] + 1,\n                             maxx.back(), a[i] - a[maxx.back()]);\n            maxx.pop_back();\n        }\n        while (minn.size() > 1 && a[minn.back()] > a[i]) {\n            seg1.easy_update(minn[minn.size() - 2] + 1,\n                             minn.back(), a[minn.back()] - a[i]);\n            minn.pop_back();\n        }\n        maxx.push_back(i), minn.push_back(i);\n        if (elem.size()) {\n            int j = elem.back();\n            int jmin = calc_min(j), jmax = calc_max(j);\n            mid += 1ll * lmax[j].maxx * (rr[jmax] - jmax - 1) + 1ll * lmin[j].maxx * (jmin - ll[jmin] - 1);\n            work(j, i, 0);\n        } else {\n            lmax[i] = lmin[i] = {1, 1, 3};\n            mid += rr[a[i]] - ll[a[i]] - 2;\n        }\n        elem.push_back(i);\n        if (minn.size() >= 2) {\n            int k = search(minn[minn.size() - 2]);\n            if (k > 0 && k < elem.size())\n                work(elem[k - 1], elem[k], 1);\n        }\n        if (maxx.size() >= 2) {\n            int k = search(maxx[maxx.size() - 2]);\n            if (k > 0 && k < elem.size())\n                work(elem[k - 1], elem[k], 1);\n        }\n        cout << pre + elem.size() + mid + suf << ' ';\n\n        pre += seg1.nodes[1].cnt;\n    }\n    cout << '\\n';\n}\n```\n",
        "postTime": 1684905960,
        "uid": 762646,
        "name": "Piggy424008",
        "ccfLevel": 6,
        "title": "CF1827F \u9898\u89e3"
    }
]