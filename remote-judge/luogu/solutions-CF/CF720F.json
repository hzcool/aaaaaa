[
    {
        "content": "\u5982\u679c\u6211\u4eec\u5047\u5b9a\u7b54\u6848\u5173\u4e8e $k$ \u6ee1\u8db3\u51f8\u6027\u8d28\u7684\u8bdd\uff0c\u6b64\u9898\u5176\u5b9e\u5b58\u5728\u5b8c\u5168\u9633\u95f4\u7684\u89e3\u6cd5\u3002\n\n\u4e4b\u6240\u4ee5\u8bf4\u201c\u5047\u5b9a\u201d\uff0c\u662f\u56e0\u4e3a\u6211\u5176\u5b9e\u6ca1\u529e\u6cd5\u7ed9\u51fa\u8fd9\u4e00\u70b9\u7684\u8bc1\u660e\uff0c\u6240\u4ee5\u6b22\u8fce\u5404\u4f4d\u6765\u505a\u4e00\u4e9b\u8865\u5145\u3002\n\n---\n\n\u4e0d\u59a8\u4ece\u8fd9\u6837\u7684\u4e00\u4e2a DP \u5165\u624b\uff1a\u8bbe\u72b6\u6001 $f_{i,k}$ \u8868\u793a\u5f53\u524d\u8986\u76d6 $[1,i]$ \uff0c\u4f7f\u7528\u4e86 $k$ \u4e2a\u533a\u95f4\uff0c\u6240\u80fd\u5f97\u5230\u7684\u6700\u5927\u7684\u548c\u3002\u8fd9\u4e2a DP \u6709 $O(n^3)$ \u4e2a\u72b6\u6001\uff0c\u5e76\u4e14\u8f6c\u79fb\u7684\u590d\u6742\u5ea6\u5f00\u9500\u4e5f\u4e0d\u5c0f\uff0c\u56e0\u6b64\u6211\u4eec\u8003\u8651\u6765\u505a\u4e00\u4e9b\u4f18\u5316\u3002\n\n\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 wqs \u4e8c\u5206\u6765\u53bb\u6389 $k$ \u8fd9\u4e00\u7ef4\u7684\u9650\u5236\uff0c\u7136\u540e\u6211\u4eec\u628a\u6b64\u65f6\u6240\u6709\u8d21\u732e\u4e0d\u4e3a\u8d1f\u7684\u533a\u95f4\u90fd\u9009\u4e0a\uff0c\u5e76\u4e14\u8bb0 $Lf_i$ \u8868\u793a\u88ab\u9009\u4e2d\u7684\u53f3\u7aef\u70b9\u4e3a $i$ \u7684\u533a\u95f4\u7684\u6700\u5c0f\u7684\u5de6\u7aef\u70b9\u3002\u90a3\u4e48\u5bf9\u4e8e $f_i$ \uff0c\u5982\u679c\u5176\u4ece $f_j\\mid j\\ge Lf_i-1$ \u8f6c\u79fb\u8fc7\u6765\uff0c\u6211\u4eec\u76f4\u63a5\u53d6\u6700\u5927\u503c\u5373\u53ef\uff1b\u5426\u5219\u6211\u4eec\u8fd8\u9700\u8981\u591a\u53d6\u4e00\u4e2a\u8d21\u732e\u4e3a\u8d1f\u7684\u533a\u95f4\uff0c\u4f7f\u5f97\u4e0d\u5b58\u5728\u7a7a\u9699\u3002\u6574\u4e2a\u8fc7\u7a0b\u53ea\u9700\u8981\u7528\u5230\u6811\u72b6\u6570\u7ec4\uff0c\u4e00\u6b21 DP \u7684\u590d\u6742\u5ea6\u4e3a $O(n\\log n)$ \u3002\n\n\u8fd9\u6837\u6211\u4eec\u7684\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f $O(n\\log^2 n)$ \uff0c\u4ee3\u7801\u5b9e\u73b0\u5e76\u4e0d\u9ebb\u70e6\uff1a\n\n```cpp\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define endl putchar('\\n')\nconst int N=500005;\nconst long long inf=0x3f3f3f3f3f3f3f3f;\n#define int long long\nusing namespace std;\n\nint n,k,a[N],ans,sm[N],p[N],Lf[N];\nstruct sta {\n\tint f,c;\n\tsta operator + (const sta &x) { return {f+x.f,c+x.c}; }\n\tfriend sta max(const sta &x,const sta &y) {\n\t\tif(x.f!=y.f) return x.f>y.f?x:y;\n\t\telse return x.c>y.c?x:y;\n\t}\n} f[N],g[N];\nstruct sub {\n\tint v,id;\n\tbool operator < (const sub &x) const { return v<x.v; }\n} b[N];\n\nstruct SUM {\n\tint sm[N];\n\tint lowbit(int x) { return x&-x; }\n\tvoid add(int x,int v) { for(int i=x;i<=n;i+=lowbit(i)) sm[i]+=v; }\n\tint sum(int x) { int res=0; for(int i=x;i>=1;i-=lowbit(i)) res+=sm[i]; return res; }\n\tvoid clear() { rep(i,1,n) sm[i]=0; }\n} b1,b2;\nstruct MIN {\n\tint mn[N];\n\tint lowbit(int x) { return x&-x; }\n\tvoid insert(int x,int v) { for(int i=x;i<=n;i+=lowbit(i)) mn[i]=min(mn[i],v); }\n\tint get(int x) { int res=inf; for(int i=x;i>=1;i-=lowbit(i)) res=min(res,mn[i]); return res; }\n\tvoid clear() { rep(i,1,n) mn[i]=inf; }\n} b3;\nstruct MAX {\n\tsta mx[N];\n\tint lowbit(int x) { return x&-x; }\n\tvoid insert(int x,sta v) { for(int i=x;i<=n;i+=lowbit(i)) mx[i]=max(mx[i],v); }\n\tsta get(int x) { sta res={-inf,-inf}; for(int i=x;i>=1;i-=lowbit(i)) res=max(res,mx[i]); return res; }\n\tvoid clear() { rep(i,1,n) mx[i]={-inf,-inf}; }\n} b4,b5;\n\nvoid init() {\n\trep(i,1,n) sm[i]=sm[i-1]+a[i],b[i]={sm[i],i};\n\tsort(b+1,b+n+1);\n}\n\nsta calc(int mid) {\n\tint j=1;\n\tb1.clear(),b2.clear(),b3.clear();\n\tsta tot={0,0};\n\trep(i,1,n) {\n\t\twhile(j<=n&&b[j].v<=b[i].v-mid) {\n\t\t\tb1.add(b[j].id,b[j].v),b2.add(b[j].id,1);\n\t\t\tb3.insert(b[j].id,b[j].id),j++;\n\t\t}\n\t\tint x=b[i].id;\n\t\tg[x].c=b2.sum(x-1);\n\t\tg[x].f=(b[i].v-mid)*g[x].c-b1.sum(x-1),Lf[x]=b3.get(x-1)+1;\n\t\tif(b[i].v-mid>=0) g[x].f+=b[i].v-mid,Lf[x]=1,g[x].c++;\n\t\tLf[x]=min(Lf[x],x+1);\n\t\ttot=tot+g[x];\n\t}\n\tb4.clear(),b5.clear();\n\tint mn=0;\n\trep(i,1,n) {\n\t\tsta t1=b4.get(max(Lf[i]-2,0ll)),t2=b5.get(min(n,n-(Lf[i]-1)+1));\n\t\tif(Lf[i]==1) t2=max(t2,{0,0});\n\t\telse t2=max(t2,{sm[i]-mid,1});\n\t\tt1.f+=sm[i]-mid,t1.c++;\n\t\tf[i]=max(t1,t2);\n\t\tmn=min(mn,sm[i]);\n\t\tb4.insert(i,{f[i].f-mn,f[i].c}),b5.insert(n-i+1,f[i]);\n\t}\n\treturn f[n]+tot;\n}\n\nvoid solve() {\n\tint l=-1e12,r=1e12,res=0;\n\twhile(l<=r) {\n\t\tint mid=(l+r)>>1;\n\t\tsta nw=calc(mid);\n\t\tif(nw.c>=k) res=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\tsta nw=calc(res);\n\tans=nw.f+res*k;\n}\n\nsigned main() {\n\tscanf(\"%lld%lld\",&n,&k);\n\trep(i,1,n) scanf(\"%lld\",&a[i]);\n\tinit();\n\tsolve();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n\n```\n\n",
        "postTime": 1644893412,
        "uid": 91736,
        "name": "RPChe_",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF720F Array Covering"
    },
    {
        "content": "\u9996\u5148\uff0c\u4e0d\u8981\u770b\u5230\u6807\u7b7e\u91cc\u7684 `*3100` \u5c31\u4ee5\u4e3a\u8fd9\u662f\u4e00\u9053\u6c34\u9898\u3002\n\n\u8fd9\u9898\u7834\u4e86\u6211\u5355\u9898\u4ee3\u7801\u6700\u957f\u7eaa\u5f55\uff08\u6253\u8868\u9664\u5916\uff09\uff1a$10.49K$\u3002\n\n\u7ed3\u8bba $1$\uff1a\u5982\u679c\u5df2\u7ecf\u6709\u4e00\u79cd\u65b9\u6848\uff0c\u90a3\u4e48\u6211\u4eec\u628a\u5176\u4e2d\u7684\u6bcf\u4e2a\u5b50\u5e8f\u5217 $[l_i, r_i]$ \u5411\u5de6\u53f3\u6269\u5c55\u81f3\u6743\u503c\u6700\u5927\u7684\u4f4d\u7f6e\uff0c\u663e\u7136\u8fd8\u662f\u4e00\u79cd\u5408\u6cd5\u7684\u65b9\u6848\u3002\n\n\u7ed3\u8bba $2$\uff1a\u6743\u503c\u524d $\\max(0, k-n)$ \u5927\u7684\u5b50\u5e8f\u5217\u4e00\u5b9a\u4f1a\u88ab\u9009\u3002\n\n\u8bc1\u660e\uff1a$k\\leq n$ \u663e\u7136\u3002$k > n$ \u7684\u60c5\u51b5\u4e0b\uff0c$k-\\max(0, k-n)\\geq n$\uff0c\u6240\u4ee5\u6211\u4eec\u5269\u4e0b\u4e86\u4e0d\u5c11\u4e8e $n$ \u4e2a\u5b50\u5e8f\u5217\u3002\u5982\u679c\u5728\u8fd9\u4e9b\u4e0d\u4f18\u7684\u5b50\u5e8f\u5217\u4e2d\uff0c\u6709\u4e00\u4e2a\u5e8f\u5217\u6ca1\u6709\u8d77\u5230\u5c06\u5e76\u96c6\u6269\u5927\u7684\u4f5c\u7528\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5b50\u5e8f\u5217\u662f\u201c\u81ea\u7531\u201d\u7684\uff0c\u6211\u4eec\u628a\u5b83\u66ff\u6362\u6210\u6700\u4f18\u7684\u5b50\u5e8f\u5217\uff0c\u663e\u7136\u65b9\u6848\u4ecd\u7136\u662f\u5408\u6cd5\u7684\uff0c\u5168\u96c6\u5927\u5c0f\u4e3a $n$\uff0c\u6240\u4ee5\u6211\u4eec\u7559\u4e0b\u591a\u4e8e $n$ \u4e2a\u4e0d\u4f18\u7684\u5b50\u5e8f\u5217\u663e\u7136\u662f\u4e0d\u597d\u7684\u3002\n\n\u6211\u4eec\u4ece $\\max(0, k-n)$ \u5230 $k$ \u679a\u4e3e\u4f7f\u7528\u4e86\u591a\u5c11\u4e2a\u6700\u5927\u7684\u5b50\u5e8f\u5217\uff0c\u8bbe\u5176\u4e3a $x$\uff0c\u5b83\u4eec\u7684\u5e76\u96c6\u4e3a $S$\u3002\n\n\u7ed3\u8bba $3$\uff1a\u5b58\u5728\u4e00\u79cd\u6700\u4f18\u65b9\u6848\uff0c\u4f7f\u5f97\u5bf9\u4e8e\u67d0\u4e2a $x$\uff0c\u5269\u4e0b\u7684 $k-x$ \u4e2a\u4e0d\u4f18\u7684\u5b50\u5e8f\u5217\u7684\u4ea4\u96c6 $\\subset S$\u3002 \n\n\u8bc1\u660e\uff1a\u53cd\u8bc1\u6cd5\uff1a\u5047\u8bbe\u4ea4\u96c6 $\\not\\subset S$\u3002\u5047\u5982\u4e24\u4e2a\u5b50\u5e8f\u5217\u4e0d\u4e3a\u5305\u542b\u5173\u7cfb\uff0c\u8bbe\u4ed6\u4eec\u4e3a $[l_1, r_1], [l_2, r_2]$\uff08$l_1\\leq l_2\\leq r_1 \\leq r_2$\uff09\uff0c\u82e5\u5b83\u4eec\u7684\u4ea4\u4e3a $[l_u, r_u]$\uff0c\u5219\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u53d8\u4e3a $[l_1, r_2]$ \u548c $[l_u, r_u]$ \u4e24\u4e2a\u5b50\u5e8f\u5217\uff0c\u8f6c\u5316\u4e3a\u5305\u542b\u5173\u7cfb\u3002\u82e5\u4e3a\u5305\u542b\u5173\u7cfb\uff0c\u5219 $[l_u, r_u]$ \u662f\u201c\u81ea\u7531\u201d\u7684\u3002\u7531\u4e8e\u4ea4\u96c6 $\\not\\subset S$\uff0c\u8bf4\u660e $[l_u, r_u]$ \u4e0d\u4e3a\u6700\u4f18\u7684\u5b50\u5e8f\u5217\u4e4b\u4e00\u3002\u90a3\u6211\u4eec\u628a $[l_u, r_u]$ \u8f6c\u5316\u4e3a\u6700\u4f18\u7684\u5b50\u5e8f\u5217\uff08\u5373 `x++` \uff09\uff0c\u663e\u7136\u66f4\u4f18\u3002\n\n\u4e8e\u662f\u6211\u4eec\u5148\u9009\u51fa $\\max(0, k-n)$ \u4e2a\u6700\u5927\u7684\u5b50\u5e8f\u5217\u3002\u6211\u4eec\u4e8c\u5206\u8fd9\u4e2a\u6743\u503c\uff0c\u518d\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u4e24\u7ef4\u9650\u5236\u5373\u53ef\u3002\n\n\u4e4b\u540e\u6211\u4eec\u679a\u4e3e $x$\uff0c\u7ef4\u62a4 $S$\uff0c\u7528 $k-x$ \u4e2a\u4ea4\u96c6 $\\in S$ \u7684\u533a\u95f4\u8986\u76d6\u6ca1\u6709\u88ab\u8986\u76d6\u7684\u4f4d\u7f6e\u3002\n\n\u6211\u4eec\u7528 `set` \u7ef4\u62a4 $S$ \u548c $S$ \u7684\u8865\u96c6\u3002\u518d\u628a $S$ \u8fde\u7eed\u7684\u4e00\u6bb5\u4f5c\u4e3a\u4e00\u4e2a\u5143\u7d20\u653e\u5230\u5806\u4e2d\uff0c\u8d21\u732e\u4e3a\uff08\u8fd9\u4e00\u6bb5\u7684\u548c - \u8fd9\u4e00\u6bb5\u7684\u524d\u7f00\u6700\u5927\u503c - \u8fd9\u4e00\u6bb5\u7684\u540e\u7f00\u6700\u5927\u503c\uff09\uff0c\u8fd9\u4e48\u7b97\u7684\u539f\u56e0\u662f\u7ed3\u8bba $1$\u3002\u4e8e\u662f\u6211\u4eec\u9700\u8981\u4e24\u68f5\u4e3b\u5e2d\u6811\u3002\n\n\u518d\u7528\u5806\u7ef4\u62a4\u4e00\u4e0b\u4e0b\u4e00\u4e2a\u6700\u5927\u7684\u5b50\u6bb5\u548c\u3002\n\n\u6240\u4ee5\u6211\u4eec\u603b\u5171\u6709 $4$ \u4e2a\u5806\uff0c$2$ \u68f5\u4e3b\u5e2d\u6811\uff0c$2$ \u4e2a set\u3002\n\n\u66f4\u591a\u7ec6\u8282\u7559\u7ed9\u8bfb\u8005\u7ec3\u4e60\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n\\log^2 n)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int Maxn = 200005;\nint n, tree_ct, vis[Maxn], ord[Maxn], a[Maxn], Head[Maxn], P[Maxn], rk[Maxn], nxt_pos[Maxn], Mini[Maxn];\nint rev_tree_ct, rev_a[Maxn], rev_Head[Maxn], rev_rk[Maxn], rev_ord[Maxn];\nlong long k, ans, maxi = -0x7fffffffffffffffLL, sum[Maxn], tmp[Maxn], las_ans[Maxn], suf_maxi[Maxn], pre_maxi[Maxn], rev_sum[Maxn];\nset <int> Se;\nstruct Tree\n{\n\tint lson, rson, cnt, mini, maxi;\n\tlong long sum;\n} tree[12 * Maxn], rev_tree[12 * Maxn];\nvoid build_first(Tree tree[], int & tree_ct, int root, int lt, int rt)\n{\n\ttree[root].mini = 0x3f3f3f3f;\n\tif (lt + 1 != rt)\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\ttree[root] = (Tree){++tree_ct, ++tree_ct, 0, 0x3f3f3f3f};\n\t\tbuild_first(tree, tree_ct, tree[root].lson, lt, mid);\n\t\tbuild_first(tree, tree_ct, tree[root].rson, mid, rt);\n\t}\n}\nvoid build(int now, int las, int lt, int rt, int pos)\n{\n\tif (lt + 1 == rt)\n\t{\n\t\ttree[now].cnt = tree[las].cnt + 1;\n\t\ttree[now].sum = tree[las].sum + sum[ord[pos]];\n\t\ttree[now].mini = min(tree[las].mini, ord[pos]);\n\t\ttree[now].maxi = max(tree[las].maxi, ord[pos]);\n\t}\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (pos >= mid)\n\t\t{\n\t\t\ttree[now].rson = ++tree_ct;\n\t\t\ttree[now].lson = tree[las].lson;\n\t\t\tbuild(tree[now].rson, tree[las].rson, mid, rt, pos);\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttree[now].lson = ++tree_ct;\n\t\t\ttree[now].rson = tree[las].rson;\n\t\t\tbuild(tree[now].lson, tree[las].lson, lt, mid, pos);\n\t\t}\n\t\ttree[now].cnt = tree[tree[now].lson].cnt + tree[tree[now].rson].cnt;\n\t\ttree[now].sum = tree[tree[now].lson].sum + tree[tree[now].rson].sum;\n\t\ttree[now].mini = min(tree[tree[now].lson].mini, tree[tree[now].rson].mini);\n\t\ttree[now].maxi = max(tree[tree[now].lson].maxi, tree[tree[now].rson].maxi);\n\t}\n}\nvoid rev_build(int now, int las, int lt, int rt, int pos)\n{\n\tif (lt + 1 == rt)\n\t{\n\t\trev_tree[now].cnt = rev_tree[las].cnt + 1;\n\t\trev_tree[now].sum = rev_tree[las].sum + rev_sum[rev_ord[pos]];\n\t\trev_tree[now].mini = min(rev_tree[las].mini, rev_ord[pos]);\n\t\trev_tree[now].maxi = max(rev_tree[las].maxi, rev_ord[pos]);\n\t}\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (pos >= mid)\n\t\t{\n\t\t\trev_tree[now].rson = ++rev_tree_ct;\n\t\t\trev_tree[now].lson = rev_tree[las].lson;\n\t\t\trev_build(rev_tree[now].rson, rev_tree[las].rson, mid, rt, pos);\n\t\t}\n\t\telse\n\t\t{\n\t\t\trev_tree[now].lson = ++rev_tree_ct;\n\t\t\trev_tree[now].rson = rev_tree[las].rson;\n\t\t\trev_build(rev_tree[now].lson, rev_tree[las].lson, lt, mid, pos);\n\t\t}\n\t\trev_tree[now].cnt = rev_tree[rev_tree[now].lson].cnt + rev_tree[rev_tree[now].rson].cnt;\n\t\trev_tree[now].sum = rev_tree[rev_tree[now].lson].sum + rev_tree[rev_tree[now].rson].sum;\n\t\trev_tree[now].mini = min(rev_tree[rev_tree[now].lson].mini, rev_tree[rev_tree[now].rson].mini);\n\t\trev_tree[now].maxi = max(rev_tree[rev_tree[now].lson].maxi, rev_tree[rev_tree[now].rson].maxi);\n\t}\n}\nint ask_cnt(int root, int lt, int rt, int L, int R)\n{\n\tif (L >= R) return 0;\n\tif (lt == L && rt == R) return tree[root].cnt;\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (L >= mid) return ask_cnt(tree[root].rson, mid, rt, L, R);\n\t\telse if (R <= mid) return ask_cnt(tree[root].lson, lt, mid, L, R);\n\t\telse return ask_cnt(tree[root].lson, lt, mid, L, mid) + ask_cnt(tree[root].rson, mid, rt, mid, R);\n\t}\n}\nlong long ask_sum(int root, int lt, int rt, int L, int R)\n{\n\tif (L >= R) return 0;\n\tif (lt == L && rt == R) return tree[root].sum;\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (L >= mid) return ask_sum(tree[root].rson, mid, rt, L, R);\n\t\telse if (R <= mid) return ask_sum(tree[root].lson, lt, mid, L, R);\n\t\telse return ask_sum(tree[root].lson, lt, mid, L, mid) + ask_sum(tree[root].rson, mid, rt, mid, R);\n\t}\n}\nint ask_mini(int root, int lt, int rt, int L, int R)\n{\n\tif (L >= R) return 0x3f3f3f3f;\n\tif (lt == L && rt == R) return tree[root].mini;\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (L >= mid) return ask_mini(tree[root].rson, mid, rt, L, R);\n\t\telse if (R <= mid) return ask_mini(tree[root].lson, lt, mid, L, R);\n\t\telse return min(ask_mini(tree[root].lson, lt, mid, L, mid), ask_mini(tree[root].rson, mid, rt, mid, R));\n\t}\n}\nint get_pos(int root, int lt, int rt, int val)\n{\n\tif (lt + 1 == rt) return lt;\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (tree[tree[root].lson].cnt < val) return get_pos(tree[root].rson, mid, rt, val - tree[tree[root].lson].cnt);\n\t\telse return get_pos(tree[root].lson, lt, mid, val);\n\t}\n}\nlong long cal(int rt, long long val)\n{\n\tint pos = upper_bound(tmp, tmp + n, sum[rt] - val) - tmp;\n\treturn ask_cnt(Head[rt], 0, n, 0, pos);\n}\nstruct cmp\n{\n\tbool operator () (const int x, const int y)\n\t{\n\t\treturn sum[x] - sum[ord[nxt_pos[x]]] < sum[y] - sum[ord[nxt_pos[y]]];\n\t}\n};\nint get_first(Tree tree[], int root, int lt, int rt, int val)\n{\n\tif (lt + 1 == rt) return lt;\n\telse\n\t{\n\t\tint mid = (lt + rt) >> 1;\n\t\tif (tree[tree[root].lson].maxi >= val) return get_first(tree, tree[root].lson, lt, mid, val);\n\t\treturn get_first(tree, tree[root].rson, mid, rt, val);\n\t}\n}\nlong long cost(pair <int, int> x)\n{\n\treturn (sum[x.second] - sum[ord[get_first(tree, Head[x.second + 1], 0, n, x.first - 1)]]) + (rev_sum[n - x.first + 1] - rev_sum[rev_ord[get_first(rev_tree, rev_Head[n - x.first + 2], 0, n, n - x.second)]]);\n}\nlong long cost2(pair <int, int> x)\n{\n\treturn sum[x.second] - sum[x.first - 1] - cost(x);\n}\nstruct sta\n{\n\tpair <int, int> x;\n\tlong long cost;\n\tsta(const pair <int, int> _x)\n\t{\n\t\tx = _x, cost = cost2(_x);\n\t}\n\tbool operator < (const sta &tmp) const\n\t{\n\t\treturn make_pair(cost, x) < make_pair(tmp.cost, tmp.x);\n\t}\n};\npriority_queue <int, vector <int>, cmp> Pr;\nset <sta> In, Out;\nvoid work(long long t)\n{\n\tlong long l = -50000LL * n, r = 50000LL * n;\n\twhile (l + 1 <= r)\n\t{\n\t\tlong long mid = (l + r + 1) >> 1, now = 0;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tnow += cal(i, mid);\n\t\tif (now >= t) l = mid;\n\t\telse r = mid - 1;\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (t && cal(i, l + 1))\n\t\t{\n\t\t\tvis[i + 1]--;\n\t\t\tint pos1 = upper_bound(tmp, tmp + n, sum[i] - l - 1) - tmp;\n\t\t\tint pos2 = get_pos(Head[i], 0, n, min((long long) i, t));\n\t\t\tvis[Mini[i] = ask_mini(Head[i], 0, n, 0, min(pos1, pos2 + 1)) + 1]++;\n\t\t\tt -= (P[i] = ask_cnt(Head[i], 0, n, 0, min(pos1, pos2 + 1)));\n\t\t\tans += (las_ans[i] = P[i] * sum[i] - ask_sum(Head[i], 0, n, 0, min(pos1, pos2 + 1)));\n\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (t && cal(i, l))\n\t\t{\n\t\t\tint pos1 = upper_bound(tmp, tmp + n, sum[i] - l) - tmp;\n\t\t\tint pos2 = get_pos(Head[i], 0, n, min((long long) i, t + P[i]));\n\t\t\tint c = ask_cnt(Head[i], 0, n, 0, min(pos1, pos2 + 1));\n\t\t\tif (c == P[i]) continue;\n\t\t\tif (Mini[i]) vis[Mini[i]]--;\n\t\t\telse vis[i + 1]--;\n\t\t\tvis[ask_mini(Head[i], 0, n, 0, min(pos1, pos2 + 1)) + 1]++;\n\t\t\tt -= c - P[i], P[i] = c;\n\t\t\tans -= las_ans[i];\n\t\t\tans += P[i] * sum[i] - ask_sum(Head[i], 0, n, 0, min(pos1, pos2 + 1));\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tvis[i] += vis[i - 1];\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tans += a[i];\n\t\t\tSe.insert(i);\n\t\t}\n\tfor (set <int> :: iterator it = Se.begin(); it != Se.end(); it++)\n\t{\n\t\tset <int> :: iterator it2 = it;\n\t\tit2++;\n\t\tif (it2 != Se.end())\n\t\t\tOut.insert(make_pair(*it + 1, *it2 - 1)), ans += cost(make_pair(*it + 1, *it2 - 1));\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (P[i] < i)\n\t\t{\n\t\t\tnxt_pos[i] = get_pos(Head[i], 0, n, P[i] + 1);\n\t\t\tPr.push(i);\n\t\t}\n}\nvoid erase(pair <int, int> now)\n{\n\tif (In.find(now) != In.end())\n\t\tans -= sum[now.second] - sum[now.first - 1], In.erase(now);\n\telse Out.erase(now), ans -= cost(now);\n}\nvoid assign(int lt, int rt)\n{\n\tif (Se.empty()) return ;\n\tset <int> :: iterator it_r = Se.upper_bound(rt), it_l = Se.lower_bound(lt);\n\tfor (set <int> :: iterator it = it_l; it != it_r; it++)\n\t{\n\t\tans -= a[*it];\n\t\tset <int> :: iterator it2 = it;\n\t\tit2++;\n\t\tif (it2 != Se.end())\n\t\t\terase(make_pair(*it + 1, *it2 - 1));\n\t}\n\tif (it_l != Se.begin() && it_l != it_r)\n\t{\n\t\tset <int> :: iterator tmp_it = it_l;\n\t\ttmp_it--;\n\t\terase(make_pair(*tmp_it + 1, *it_l - 1));\n\t\tif (it_r != Se.end())\n\t\t{\n\t\t\tOut.insert(make_pair(*tmp_it + 1, *it_r - 1));\n\t\t\tans += cost(make_pair(*tmp_it + 1, *it_r - 1));\n\t\t}\n\t}\n\tSe.erase(it_l, it_r);\n}\nvoid add_top(void)\n{\n\tint u = Pr.top();\n\tPr.pop();\n\tans += sum[u] - sum[ord[nxt_pos[u]]];\n\tassign(ord[nxt_pos[u]] + 1, u);\n\tP[u]++;\n\tif (P[u] < u)\n\t{\n\t\tnxt_pos[u] = get_pos(Head[u], 0, n, P[u] + 1);\n\t\tPr.push(u);\n\t}\n}\nint main()\n{\n\tscanf(\"%d%lld\", &n, &k);\n\tfor (int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", &a[i]), rev_a[i] = a[i];\n\treverse(rev_a + 1, rev_a + 1 + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tsum[i] = sum[i - 1] + a[i], rev_sum[i] = rev_sum[i - 1] + rev_a[i], pre_maxi[i] = max(pre_maxi[i - 1] + a[i], 0LL);\n\tfor (int i = n; i >= 1; i--)\n\t\tsuf_maxi[i] = max(suf_maxi[i + 1] + a[i], 0LL);\n\tfor (int i = 0; i < n; i++)\n\t\ttmp[i] = sum[i], ord[i] = rev_ord[i] = i;\n\tsort(tmp, tmp + n);\n\tsort(ord, ord + n, [](int x, int y){return sum[x] < sum[y];});\n\tsort(rev_ord, rev_ord + n, [](int x, int y){return rev_sum[x] < rev_sum[y];});\n\tfor (int i = 0; i < n; i++) rk[ord[i]] = i, rev_rk[rev_ord[i]] = i;\n\tbuild_first(tree, tree_ct, Head[0] = ++tree_ct, 0, n);\n\tfor (int i = 0; i < n; i++)\n\t\tbuild(Head[i + 1] = ++tree_ct, Head[i], 0, n, rk[i]);\n\tbuild_first(rev_tree, rev_tree_ct, rev_Head[0] = ++rev_tree_ct, 0, n);\n\tfor (int i = 0; i < n; i++)\n\t\trev_build(rev_Head[i + 1] = ++rev_tree_ct, rev_Head[i], 0, n, rev_rk[i]);\n\tlong long t = max(0LL, k - n);\n\twork(t);\n\tfor (long long i = t; i <= k; i++)\n\t{\n\t\tif ((bool) Se.size() + i <= k && (int) Se.size() + i >= k)\n\t\t{\n\t\t\twhile ((int) (Se.size() - In.size()) + i < k)\n\t\t\t{\n\t\t\t\tans -= In.begin() -> cost;\n\t\t\t\tOut.insert(*In.begin());\n\t\t\t\tIn.erase(*In.begin());\n\t\t\t}\n\t\t\twhile ((int) (Se.size() - In.size()) + i > k)\n\t\t\t{\n\t\t\t\tans += Out.rbegin() -> cost;\n\t\t\t\tIn.insert(*Out.rbegin());\n\t\t\t\tOut.erase(*Out.rbegin());\n\t\t\t}\n\t\t\twhile (In.size() && Out.size() && Out.rbegin() -> cost > In.begin() -> cost)\n\t\t\t{\n\t\t\t\tsta tmp1 = *In.begin(), tmp2 = *Out.rbegin();\n\t\t\t\tOut.erase(tmp2);\n\t\t\t\tOut.insert(tmp1);\n\t\t\t\tIn.erase(tmp1);\n\t\t\t\tIn.insert(tmp2);\n\t\t\t\tans -= tmp1.cost;\n\t\t\t\tans += tmp2.cost;\n\t\t\t}\n\t\t\tmaxi = max(maxi, ans + (Se.size() ? (max(0LL, pre_maxi[*Se.begin() - 1]) + max(0LL, suf_maxi[*Se.rbegin() + 1])) : 0));\n\t\t}\n\t\tadd_top();\n\t}\n\tprintf(\"%lld\", maxi);\n\treturn 0;\n}\n```",
        "postTime": 1606731249,
        "uid": 49093,
        "name": "_sys",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF720F \u3010Array Covering\u3011"
    },
    {
        "content": "[\u9898\u4f20](https://www.luogu.com.cn/problem/CF720F)\n\n\u4ee5\u4e0b  $sum_{x}$ \u8868\u793a $\\sum_{i=1}^{x}a_{i}$\uff0c\u5373\u524d\u7f00\u548c\u3002\n\n\u6070\u597d $k$ \u4e2a\uff0c\u9996\u5148\u8003\u8651 wqs \u4e8c\u5206\uff0c\u6839\u636e\u8d2a\u5fc3\u4e0d\u96be\u5f97\u5176\u4e8c\u9636\u5bfc\u975e\u6b63\uff0c\u5373\u659c\u7387\u5355\u8c03\u4e0d\u589e\u3002\n\n\u4e8c\u5206\u659c\u7387\u4ee3\u4ef7 $C$ \u540e\uff0c\u5bf9\u4e8e\u6240\u6709 $[l, r]=sum_{r}-sum_{l-1}-C \\ge 0$ \u7684\u533a\u95f4\u662f\u53ef\u4ee5\u4efb\u610f\u9009\u7684\uff0c\u79bb\u6563\u5316 $sum$ \u540e\u4e0d\u96be\u505a\u5230 $O(n\\log n)$\u3002\n\n\u628a\u6240\u6709\u672a\u88ab\u4e0a\u8ff0\u533a\u95f4\u8986\u76d6\u5230\u7684\u4f4d\u7f6e\u627e\u51fa\u6765\uff0c\u8bbe\u4e3a $x_{p}$\uff08\u7279\u522b\u5730\uff0c$x_{0}=1, x_{end}=n+1$\uff09\uff0c\u8bbe $f_{p}$ \u4e3a\u8986\u76d6\u4e86 $[1, x_{p}]$ \u7684\u6700\u5927\u6743\u503c\u548c\u3002\n\n\u5bf9\u4e8e $q<p$\uff0c$f_{q}$ \u8f6c\u79fb $f_{p}$ \u9700\u8981\u989d\u5916\u9009\u62e9\u4e00\u4e2a\u533a\u95f4 $[l, r](l<x_{q+1}\\le r<x_{p+1})$\uff0c\u4ee3\u4ef7\u4e3a $sum_{r}-sum_{l-1}-C$\uff0c\u6ce8\u610f\u5230 $l, r$ \u76f8\u4e92\u72ec\u7acb\u4e0d\u4f1a\u5f71\u54cd\uff0c\u5bf9\u4e8e\u6bcf\u4e2a $x_{q}$\uff0c $l-1$ \u5373\u4e3a $sum_{[1, x_{q+1})}$ \u6700\u5c0f\u503c\u7684\u4f4d\u7f6e\u3002\u76f4\u63a5\u679a\u4e3e $r$ \u5e76\u7ef4\u62a4 $f_{q}-sum_{l-1}$ \u7684\u6700\u5c0f\u503c\u8f6c\u79fb $f_{p}$ \u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6 $O(n\\log n\\log w)$\u3002\n\n### Code\n\n```cpp\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <cctype>\n#include <vector>\n#include <queue>\n#include <bitset>\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define st first\n#define nd second\nusing namespace std;\ntypedef long long ll;\ntypedef pair <int, int> Pii;\ntypedef pair <ll, ll> Pll;\nconst int INF=0x3f3f3f3f;\nconst int cp=998244353;\ninline int mod(int x){if(x>=cp) x-=cp;if(x<0) x+=cp;return x;}\ninline void plust(int &x, int y){x=mod(x+y);return ;}\ninline void minut(int &x, int y){x=mod(x-y);return ;}\ninline int read(){\n\tchar ch=getchar();int x=0, f=1;\n\twhile(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'), x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline int ksm(int a, int b=cp-2){\n\tint ret=1;\n\tfor(; b; b>>=1, a=1ll*a*a%cp)\n\t\tif(b&1) ret=1ll*ret*a%cp;\n\treturn ret;\n}\nPll INFp={-1e18, -1e18};\nPll O={0, 0};\nPll operator += (Pll &x, Pll y){x.st+=y.st, x.nd+=y.nd;return x;}\nconst int N=1e5+5;\nint n, m, xp[N];ll K, sum[N], p[N], f[N], g[N];\n#define lowbit(x) (x&-x)\nint cnt[N], mnl[N];Pll bit[N];\nPll operator + (Pll a, Pll b){return {a.st+b.st, a.nd+b.nd};}\nvoid add(int x, int v){for(int i=x; i<=n; i+=lowbit(i)) cnt[i]+=v;}\nint viscnt(int x, int v=0){for(int i=x; i; i-=lowbit(i)) v+=cnt[i];return v;}\nvoid add(int x, Pll v, int p){for(int i=x; i<=m; i+=lowbit(i)) bit[i]+=v, mnl[i]=min(mnl[i], p);}\nPll query(int x, Pll res={0, 0}){for(int i=x; i; i-=lowbit(i)) res+=bit[i];return res;}\nint find(int x, int res=n+1){for(int i=x; i; i-=lowbit(i)) res=min(res, mnl[i]);return res;}\n#undef lowbit\nint X[N];\nPll check(ll C){\n\tfor(int i=1; i<=n+1; ++i) \n\t\tf[i]=g[i]=cnt[i]=0, mnl[i]=n+1, bit[i]=O;\n\tPll S=O;\n\tfor(int i=1; i<=n; ++i){\n\t\tint pos=lower_bound(p+1, p+m+1, sum[i-1])-p;\n\t\tadd(pos, {-sum[i-1], 1ll}, i-1);\n\t\tpos=upper_bound(p+1, p+m+1, sum[i]-C)-p-1;\n\t\tPll T=query(pos);T.st+=T.nd*(sum[i]-C);\n\t\tpos=find(pos), S+=T;\n\t\tif(pos<n) add(pos+1, 1), add(i+1, -1);\n\t}\n\tint Q=0;\n\tfor(int i=1; i<=n; ++i) if(!viscnt(i)) X[++Q]=i;\n\tX[++Q]=n+1;\n\tPll dp={0, 0};dp=max(dp, {-xp[X[1]-1], 0ll});\n\tfor(int i=1; i<Q; ++i){\n\t\tPll mx=INFp;\n\t\tfor(int j=X[i]; j<X[i+1]; ++j) mx=max(mx, mp(sum[j]-C, 1ll)+dp);\n\t\tf[i]=mx.st, g[i]=mx.nd;dp=max(dp, mp(f[i]-xp[X[i+1]-1], g[i]));\n\t}\n\treturn mp(f[Q-1], g[Q-1])+S;\n}\nsigned main(){\n\tn=read();scanf(\"%lld\", &K);\n\tp[m=1]=0;\n\tfor(int i=1; i<=n; ++i) \n\t\tsum[i]=sum[i-1]+read(), p[++m]=sum[i];\n\tsort(p+1, p+m+1);m=unique(p+1, p+m+1)-p-1;\n\tll l=-1e10, r=1e10, ans=0, mn=0;\n\tfor(int i=1; i<=n; ++i) mn=min(mn, sum[i]), xp[i]=mn;\n\twhile(l<=r){\n\t\tll mid=l+r>>1;\n\t\tPll pd=check(mid);\n\t\tif(pd.nd<K) r=mid-1;\n\t\telse l=mid+1, ans=mid;\n\t}\n\tPll res=check(ans);ans=res.st+K*ans;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n```\n",
        "postTime": 1678953821,
        "uid": 341102,
        "name": "ReKoJ",
        "ccfLevel": 0,
        "title": "CF720F Array Covering"
    },
    {
        "content": "\u6765\u53d1\u4e00\u4efd\u6bd4\u8f83\u597d\u5199\u7684\u505a\u6cd5\u3002\n\n\u5bf9\u4e8e\u8fd9\u7c7b\u8981\u6c42\u6070\u597d\u9009 $K$ \u4e2a\u7684\u95ee\u9898\uff0c\u8003\u8651 WQS \u4e8c\u5206\uff0c\u6bcf\u6b21\u4e8c\u5206\u6bcf\u6b21\u9009\u4e00\u4e2a\u533a\u95f4\u9700\u8981\u7684\u989d\u5916\u6743\u503c $C$\uff0c\u53ef\u4ee5\u9009\u62e9\u4efb\u610f\u4e2a\u533a\u95f4\uff0c\u8ba1\u7b97\u8986\u76d6\u6240\u6709\u4f4d\u7f6e\u7684\u6700\u5927\u6743\u503c\u3002\n\n\u5148\u9884\u5904\u7406\u51fa\u524d\u7f00\u548c\uff0c\u8bb0\u4e3a$s(i)$\u3002\n\n\u8003\u8651 dp\uff0c\u7528 $f(i,j)$ \u8868\u793a\u8003\u8651\u524d $i$ \u4e2a\u5143\u7d20\uff0c\u6700\u65e9\u7684\u4e00\u4e2a\u6ca1\u88ab\u8986\u76d6\u7684\u5143\u7d20\u4f4d\u7f6e\u5728 $j$ \u7684\u6700\u5927\u6743\u503c\u3002\u7528 $g(i)$ \u8868\u793a\u6240\u6709\u5143\u7d20\u90fd\u88ab\u8986\u76d6\u7684\u6700\u5927\u6743\u503c\u3002\n\n\u8003\u8651\u4ece $i$ \u5230 $i+1$ \u7684\u8f6c\u79fb\uff0c\u9996\u5148\u6240\u6709\u4ee5 $i+1$ \u4e3a\u53f3\u7aef\u70b9\uff0c\u5e76\u4e14\u6743\u503c\u4e3a\u6b63\u7684\u533a\u95f4\u662f\u4e00\u5b9a\u8981\u9009\u7684\uff0c\u8bbe\u8fd9\u4e9b\u6b63\u533a\u95f4\u5de6\u7aef\u70b9\u6700\u5c0f\u503c\u4e3a $p$\u3002\u90a3\u4e48\u6240\u6709 $f(i,k) (k\\ge p)$ \u4ee5\u53ca $g(i)$ \u90fd\u80fd\u8f6c\u79fb\u5230 $g(i+1)$ \u3002\u540c\u65f6\uff0c\u6240\u6709 $f(i,k)(k<p)$ \u7684\u6743\u503c\u90fd\u4f1a\u52a0\u4e0a\u8fd9\u4e9b\u6b63\u533a\u95f4\u7684\u6743\u503c\u3002\n\n\u8003\u8651 $f(i,k)(k<p)$ \u8981\u8f6c\u79fb\u5230 $g(i+1)$ \u7684\u6761\u4ef6\uff0c\u5047\u8bbe\u6211\u4eec\u9009\u62e9\u4e86 $x(x\\le k)$ \u5230 $i+1$ \u7684\u533a\u95f4\u6765\u8986\u76d6\u6574\u4e2a\u70b9\uff0c\u4ee3\u4ef7\u4e3a $s(i+1)-s(x-1)-C$\uff0c\u663e\u7136\u5e94\u8be5\u9009\u62e9\u524d\u7f00\u548c\u7684\u524d\u7f00\u6700\u5c0f\u503c\u8fdb\u884c\u8f6c\u79fb\u3002\n\n\u7b2c\u4e00\u79cd\u8f6c\u79fb\u53ef\u4ee5\u770b\u6210\u533a\u95f4\u52a0\uff0c\u7b2c\u4e8c\u79cd\u8f6c\u79fb\u53ef\u4ee5\u89c6\u4e3a\u67e5\u8be2\u533a\u95f4\u6700\u5927\u503c\u64cd\u4f5c\u3002\u4f7f\u7528\u7ebf\u6bb5\u6811\u6216\u8005\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4 dp \u503c\uff0c\u5373\u53ef\u5728 $O(n\\log n)$ \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u4e00\u6b21\u4e8c\u5206\u3002\n\n\u7ed3\u5408 WQS \u4e8c\u5206\uff0c\u603b\u590d\u6742\u5ea6\u4e3a $O(n\\log^2 n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=100005;\nconst long long inf=1e12;\nint n,a[N],rk[N],sq[N];\nll k,s[N],v[N],pm[N];\npair<ll,ll>tr[N<<2],tg[N<<2],mx[N<<2];\npair<ll,ll>operator+(pair<ll,ll>a,pair<ll,ll>b){return {a.first+b.first,a.second+b.second};}\nstruct bit\n{\n\tll b[N];\n\tvoid init()\n\t{\n\t\tfor(int i=0;i<=n+1;i++)\n\t\t\tb[i]=0;\n\t}\n\tvoid add(int x,ll v)\n\t{\n\t\tx++;\n\t\tfor(int i=x;i<=n+1;i+=i&(-i))\n\t\t\tb[i]+=v;\n\t}\n\tll ask(int x)\n\t{\n\t\tx++;\n\t\tll v=0;\n\t\tfor(int i=x;i;i-=i&(-i))\n\t\t\tv+=b[i];\n\t\treturn v;\n\t}\n}t1,t2;\nstruct rmq\n{\n\tint st[N][20],lg[N];\n\tvoid init()\n\t{\n\t\tfor(int i=2;i<=n+1;i++)\n\t\t\tlg[i]=lg[i>>1]+1;\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tst[i][0]=sq[i];\n\t\tfor(int j=1;(1<<j)<=n+1;j++)\n\t\t\tfor(int i=0;i+(1<<j)-1<=n;i++)\n\t\t\t\tst[i][j]=min(st[i][j-1],st[i+(1<<j-1)][j-1]);\n\t}\n\tint ask(int l,int r)\n\t{\n\t\tif(l>r) return -1;\n\t\tint d=lg[r-l+1];\n\t\treturn min(st[l][d],st[r-(1<<d)+1][d]);\n\t}\n}st;\nvoid build(int k,int l,int r)\n{\n\ttr[k]=mx[k]={0-inf,0},tg[k]={0,0};\n\tif(l==r)\n\t\treturn;\n\tint mid=l+r>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n}\nvoid pd(int k)\n{\n\ttr[k<<1]=tr[k<<1]+tg[k];\n\tmx[k<<1]=mx[k<<1]+tg[k];\n\ttg[k<<1]=tg[k<<1]+tg[k];\n\ttr[k<<1|1]=tr[k<<1|1]+tg[k];\n\tmx[k<<1|1]=mx[k<<1|1]+tg[k];\n\ttg[k<<1|1]=tg[k<<1|1]+tg[k];\n\ttg[k]={0,0};\n}\nvoid upd(int k,int l,int r,int x,pair<ll,ll> v)\n{\n\tif(l==r)\n\t{\n\t\tmx[k]=tr[k]=v;\n\t\tif(l) tr[k].first-=pm[l-1];\n\t\treturn;\n\t}\n\tpd(k);\n\tint mid=l+r>>1;\n\tif(x<=mid) upd(k<<1,l,mid,x,v);\n\telse upd(k<<1|1,mid+1,r,x,v);\n\ttr[k]=max(tr[k<<1],tr[k<<1|1]);\n\tmx[k]=max(mx[k<<1],mx[k<<1|1]);\n}\nvoid add(int k,int l,int r,int a,int b,pair<ll,ll> v)\n{\n\tif(l==a&&r==b)\n\t{\n\t\ttr[k]=tr[k]+v;\n\t\tmx[k]=mx[k]+v;\n\t\ttg[k]=tg[k]+v;\n\t\treturn;\n\t}\n\tpd(k);\n\tint mid=l+r>>1;\n\tif(b<=mid) add(k<<1,l,mid,a,b,v);\n\telse if(a>mid) add(k<<1|1,mid+1,r,a,b,v);\n\telse add(k<<1,l,mid,a,mid,v),add(k<<1|1,mid+1,r,mid+1,b,v);\n\ttr[k]=max(tr[k<<1],tr[k<<1|1]);\n\tmx[k]=max(mx[k<<1],mx[k<<1|1]);\n}\npair<ll,ll>ask(int k,int l,int r,int a,int b)\n{\n\tif(a>b) return {-inf,0};\n\tif(l==a&&r==b)\n\t\treturn tr[k];\n\tpd(k);\n\tint mid=l+r>>1;\n\tif(b<=mid) return ask(k<<1,l,mid,a,b);\n\telse if(a>mid) return ask(k<<1|1,mid+1,r,a,b);\n\telse return max(ask(k<<1,l,mid,a,mid),ask(k<<1|1,mid+1,r,mid+1,b));\n}\npair<ll,ll>askv(int k,int l,int r,int a,int b)\n{\n\tif(a>b) return {-inf,0};\n\tif(l==a&&r==b)\n\t\treturn mx[k];\n\tpd(k);\n\tint mid=l+r>>1;\n\tif(b<=mid) return askv(k<<1,l,mid,a,b);\n\telse if(a>mid) return askv(k<<1|1,mid+1,r,a,b);\n\telse return max(askv(k<<1,l,mid,a,mid),askv(k<<1|1,mid+1,r,mid+1,b));\n}\npair<ll,ll>sol(ll x)\n{\n\tbuild(1,0,n);\n\tt1.init(),t2.init();\n\tpair<ll,ll>dp={0,0};\n\tupd(1,0,n,0,{0,0});\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tt1.add(rk[i-1],1),t2.add(rk[i-1],s[i-1]);\n\t\tint z=upper_bound(v,v+n+1,s[i]-x)-v-1;\n\t\tll z1=t1.ask(z),z2=t2.ask(z);\n\t\tz2=z1*s[i]-z2-z1*x;\n\t\tadd(1,0,n,0,i,{z2,z1});\n\t\tdp=dp+make_pair(z2,z1);\n\t\tif(z1==i)\n\t\t\tcontinue;\n\t\tint b=(z1?st.ask(0,z):i);\n\t\tif(b==0&&s[i]>=x)\n\t\t\tb--;\n\t\tauto d=askv(1,0,n,b+1,i);\n\t\tdp=max(dp,d);\n\t\tif(!z1)\n\t\t{\n\t\t\tupd(1,0,n,i,dp);\n\t\t\tdp={-inf,0};\n\t\t}\n\t\tauto c=ask(1,0,n,0,b);\n\t\tc.first+=s[i]-x;\n\t\tc.second++;\n\t\tdp=max(dp,c);\n\t}\n\treturn dp;\n}\nint main()\n{\n\tscanf(\"%d%lld\",&n,&k);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]),s[i]=s[i-1]+a[i],sq[i]=i;\n\tfor(int i=1;i<=n;i++)\n\t\tpm[i]=min(pm[i-1],s[i]);\n\tsort(sq,sq+n+1,[&](int x,int y){return s[x]<s[y];});\n\tfor(int i=0;i<=n;i++)\n\t\trk[sq[i]]=i,v[i]=s[sq[i]];\n\tfor(int i=1;i<=n;i++)\n\t\tif(s[i]==s[i-1])\n\t\t\trk[i]=min(rk[i],rk[i-1]);\n\tfor(int i=n-1;i>=0;i--)\n\t\tif(s[i]==s[i+1])\n\t\t\trk[i]=min(rk[i],rk[i+1]);\n\tst.init();\n\tll l=-5e9,r=5e9;\n\twhile(l<r)\n\t{\n\t\tll mid=(l+r+1)/2;\n\t\tif(sol(mid).second>=k)\n\t\t\tl=mid;\n\t\telse\n\t\t\tr=mid-1;\n\t}\n\tll ans=sol(l).first;\n\tans+=l*k;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1644641481,
        "uid": 237660,
        "name": "RinkaSnow",
        "ccfLevel": 9,
        "title": "CF720F\u9898\u89e3"
    }
]