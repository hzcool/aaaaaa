[
    {
        "content": "\u9898\u610f\uff1a\n\n\u7ed9\u5b9a\u4e00\u4e2a\u70b9\u6570\u4e3a n\uff0c\u8fb9\u6570\u4e3a m\uff0c\u6743\u503c\u4e0d\u8d85\u8fc7 $10^9$ \u7684\u5e26\u6743\u8fde\u901a\u56fe\uff0c\u6ca1\u6709\u81ea\u73af\u4e0e\u91cd\u8fb9\u3002 \u73b0\u5728\u8981\u6c42\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u6c42\u51fa\uff0c\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u6700\u5927\u4e3a\u591a\u5c11\u65f6\uff0c\u5b83\u8fd8\u80fd\u51fa\u73b0\u5728\u6240\u6709\u53ef\u80fd\u7684\u6700\u5c0f\u751f\u6210\u6811\u4e0a\uff0c\u5982\u679c\u5bf9\u4e8e\u4efb\u610f\u8fb9\u6743\u90fd\u51fa\u73b0\uff0c\u5219\u8f93\u51fa $-1$\u3002\n\n\u8fd9\u91cc\u5199\u4e00\u4e2a\u7528\u500d\u589e\u7684$O(nlogn)$\u505a\u6cd5\u3002\n\n\u5148\u6c42\u51fa\u4e00\u4e2a\u6700\u5c0f\u751f\u6210\u6811\u3002\n\n1\u3001\u82e5x\u5230y\u5728\u6811\u4e0a\uff0c\u90a3\u4e48\u5bf9\u4e8e\u4efb\u610f\u4e00\u6761\u975e\u6811\u8fb9$e(a,b)$\uff0c\u82e5\u6ee1\u8db3a\u5230b\u7684\u6811\u4e0a\u8def\u5f84\u7ecf\u8fc7$e(x,y)$\uff0c\n\n\u90a3\u4e48\uff0c\u6839\u636e\u6700\u5c0f\u751f\u6210\u6811\u7684\u6027\u8d28\uff0c\u6dfb\u52a0$e(a,b)$\u540e\u751f\u6210\u7684\u73af\u4e0a\u7684\u6700\u5927\u8fb9\u5fc5\u987b\u662f\u552f\u4e00\u7684$e(a,b)$\u3002\n\n\u56e0\u6b64\uff0c$e(x,y)$\u7684\u6743\u503c\u5e94\u5f53\u7b49\u4e8e\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684$e(a,b)$\u7684\u6700\u5c0f\u6743\u503c\u51cf1\u3002\n\n2\u3001\u82e5x\u5230y\u4e0d\u5728\u6811\u4e0a\uff0c\u90a3\u4e48\uff0c\u6839\u636e\u6700\u5c0f\u751f\u6210\u6811\u7684\u6027\u8d28\uff0c\u6dfb\u52a0$e(x,y)$\u540e\u751f\u6210\u7684\u73af\u4e0a\u7684\u6700\u5927\u8fb9\u5982\u679c\u4e0d\u662f$e(x,y)$\uff0c\u5b83\u5c31\u80fd\u51fa\u73b0\u3002\n\n\u56e0\u6b64\uff0c$e(x,y)$\u7684\u6743\u503c\u5e94\u5f53\u7b49\u4e8ex\u5230y\u8def\u5f84\u4e0a\u7684\u6700\u5927\u503c\u51cf1\u3002\n\n2\u53ef\u4ee5\u4f7f\u7528\u500d\u589e\uff0c$O(nlogn)$\u3002\n\n\u5bf9\u4e8e1\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u975e\u6811\u8fb9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u518d\u4f9d\u6b21\u505a\u94fe\u4e0a\u8986\u76d6\uff0c\u4fdd\u8bc1\u6bcf\u6761\u6811\u8fb9\u53ea\u88ab\u5176\u7b2c\u4e00\u6b21\u8986\u76d6\u3002\n\n\u53ef\u4ee5\u628a\u88ab\u8986\u76d6\u7684\u8fde\u7eed\u8fb9\u5b58\u6210\u4e00\u4e2a\u96c6\u5408\uff0c\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5e76\u67e5\u96c6\u7684\u6839\u8282\u70b9\u4ee3\u8868\u6b64\u70b9\u5411\u4e0a\u7b2c\u4e00\u4e2a\u672a\u88ab\u8986\u76d6\u7684\u70b9\uff08\u5305\u62ec\u81ea\u8eab\uff09\u3002\n\n\u5728\u8fd9\u4e2a\u70b9\u88ab\u8986\u76d6\u540e\uff0c\u628a\u5b83\u4e0e\u5b83\u7684\u7236\u8282\u70b9\u7684\u96c6\u5408\u5408\u5e76\u3002\n\n\u6bcf\u4e2a\u70b9\u53ea\u4f1a\u88ab\u8003\u8651\u4e00\u6b21\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u662f\u5bf9\u7684\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(nlogn)$\uff0c\u5f88\u597d\u5199\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <stdio.h> \n#include <stdlib.h> \nstruct SBi {\n\tint x,\ty,\tz;\n\tSBi() {}\n\tSBi(int X, int Y, int Z) {\n\t\tx = X; y = Y; z = Z;\n\t}\n};\nSBi bi[200010],px[200010];\nint cmp(const void * a, const void * b) {\n\treturn ((SBi * ) a) ->z - ((SBi * ) b) ->z;\n}\nint fu[200010],fr[200010],ne[400010],v[400010],w[400010],bs = 0;\nint getv(int x) {\n\tif (fu[x] == x) return x;\n\tfu[x] = getv(fu[x]);\n\treturn fu[x];\n}\nvoid addb(int a, int b, int c) {\n\tv[bs] = b;\n\tw[bs] = c;\n\tne[bs] = fr[a];\n\tfr[a] = bs++;\n}\nvoid kru(int n, int m) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tfu[i] = i;\n\t\tfr[i] = -1;\n\t}\n\tqsort(bi, m, sizeof(SBi), cmp);\n\tfor (int i = 0; i < m; i++) {\n\t\tint x = getv(bi[i].x),y = getv(bi[i].y);\n\t\tif (x == y) continue;\n\t\tfu[x] = y;\n\t\taddb(bi[i].x, bi[i].y, bi[i].z);\n\t\taddb(bi[i].y, bi[i].x, bi[i].z);\n\t}\n}\nint fa[200010],sd[200010],fb[200010],fg[200010];\nvoid dfs1(int u, int f) {\n\tfa[u] = f;sd[u] = sd[f] + 1;\n\tfor (int i = fr[u]; i != -1; i = ne[i]) {\n\t\tif (v[i] != f) {\n\t\t\tfb[v[i]] = w[i];\n\t\t\tdfs1(v[i], u);\n\t\t}\n\t}\n}\nint x[200010],y[200010],z[200010],bz[18][200010],zd[18][200010];\nvoid yucl(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tbz[0][i] = fa[i];\n\t\tzd[0][i] = fb[i];\n\t}\n\tfor (int i = 1; i <= 17; i++) {\n\t\tfor (int x = 1; x <= n; x++) {\n\t\t\tbz[i][x] = bz[i - 1][bz[i - 1][x]];\n\t\t\tzd[i][x] = zd[i - 1][bz[i - 1][x]];\n\t\t\tif (zd[i - 1][x] > zd[i][x]) zd[i][x] = zd[i - 1][x];\n\t\t}\n\t}\n}\nint getlca(int a, int b) {\n\tif (sd[a] < sd[b]) {\n\t\tint t = a;\n\t\ta = b;b = t;\n\t}\n\tfor (int i = 17; i >= 0; i--) {\n\t\tif (sd[bz[i][a]] >= sd[b]) a = bz[i][a];\n\t}\n\tif (a == b) return a;\n\tint rt;\n\tfor (int i = 17; i >= 0; i--) {\n\t\tif (bz[i][a] == bz[i][b]) rt = bz[i][a];\n\t\telse {\n\t\t\ta = bz[i][a];\n\t\t\tb = bz[i][b];\n\t\t}\n\t}\n\treturn rt;\n}\nint getmax(int a, int b) {\n\tint lc = getlca(a, b),ma = -1;\n\tfor (int i = 17; i >= 0; i--) {\n\t\tif (sd[bz[i][a]] >= sd[lc]) {\n\t\t\tif (zd[i][a] > ma) ma = zd[i][a];\n\t\t\ta = bz[i][a];\n\t\t}\n\t}\n\tfor (int i = 17; i >= 0; i--) {\n\t\tif (sd[bz[i][b]] >= sd[lc]) {\n\t\t\tif (zd[i][b] > ma) ma = zd[i][b];\n\t\t\tb = bz[i][b];\n\t\t}\n\t}\n\treturn ma;\n}\nvoid fugai(int a, int b, int c) {\n\twhile (sd[a = getv(a)] > sd[b]) {\n\t\tfg[a] = c;\n\t\tfu[a] = getv(fa[a]);\n\t}\n}\nint main() {\n\tint n,m,k = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d%d\", &x[i], &y[i], &z[i]);\n\t\tbi[i] = SBi(x[i], y[i], z[i]);\n\t}\n\tkru(n, m);dfs1(1, 0);yucl(n);\n\tfor (int i = 1; i <= n; i++) fu[i] = i;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = x[i],b = y[i];\n\t\tif (fa[a] != b && fa[b] != a) bi[k++] = SBi(a, b, z[i]);\n\t}\n\tqsort(bi, k, sizeof(SBi), cmp);\n\tfor (int i = 0; i < k; i++) {\n\t\tint a = bi[i].x,b = bi[i].y,c = bi[i].z;\n\t\tint lc = getlca(a, b);\n\t\tfugai(a, lc, c);fugai(b, lc, c);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint a = x[i],b = y[i];\n\t\tif (fa[b] == a) {\n\t\t\ta = y[i];\n\t\t\tb = x[i];\n\t\t}\n\t\tif (fa[a] != b) printf(\"%d \", getmax(a, b) - 1);\n\t\telse printf(\"%d \", fg[a] - 1);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1572008382,
        "uid": 58367,
        "name": "0____",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF827D \u3010Best Edge Weight\u3011"
    },
    {
        "content": "~~\u8c28\u4ee5\u6b64\u9898\u89e3\u7eaa\u5ff5\u5199\u8fc7\u7684\u6700\u957f\u7684codeforces\u7684\u4ee3\u7801~~\n\n### \u9898\u76ee\u7ffb\u8bd1\uff1a\n\n\u7ed9\u5b9a\u4e00\u4e2a\u70b9\u6570\u4e3a$n$\uff0c\u8fb9\u6570\u4e3a$m$\uff0c\u6743\u503c\u4e0d\u8d85\u8fc7$10^9$\u7684\u5e26\u6743\u8fde\u901a\u56fe\uff0c\u6ca1\u6709\u81ea\u73af\u4e0e\u91cd\u8fb9\u3002 \u73b0\u5728\u8981\u6c42\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u6c42\u51fa\uff0c\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u6700\u5927\u4e3a\u591a\u5c11\u65f6\uff0c\u5b83\u8fd8\u80fd\u51fa\u73b0\u5728\u6240\u6709\u53ef\u80fd\u7684\u6700\u5c0f\u751f\u6210\u6811\u4e0a\uff0c\u5982\u679c\u5bf9\u4e8e\u4efb\u610f\u8fb9\u6743\u90fd\u51fa\u73b0\uff0c\u5219\u8f93\u51fa $-1$\u3002 \n$2 \\le n \\le 2 \\times 10^5,,n - 1 \\le m \\le 2 \\times 10^5 $\n\n### \u9898\u89e3\n\n\n------------\n\u6211\u4eec\u5148\u7528kurskal/prim\u6c42\u51fa\u539f\u56fe\u7684MST\n\n\u6211\u4eec\u628aMST\u4e0a\u7684\u8fb9\u548c\u4e0d\u5728MST\u4e0a\u7684\u8fb9\u5206\u5f00\u8003\u8651\n\n1. \u5bf9\u4e8e\u4e0d\u5728MST\u4e0a\u7684\u8fb9\uff0c\u8981\u6210\u4e3aMST\u4e0a\u7684\u8fb9\uff0c\u8fb9\u6743\u5fc5\u987b\u6bd4\u5b83\u7684\u4e24\u4e2a\u7aef\u70b9\u5728\u6811\u4e0a\u7684\u8def\u5f84\u4e0a\u6700\u957f\u7684\u90a3\u6761\u8fb9\u5c0f\uff0c\u8fd9\u6837\u624d\u80fd\u4ee3\u66ff\u90a3\u6761\u8fb9\u6210\u4e3aMST\u4e0a\u7684\u8fb9\u3002\n\n\u6211\u4eec\u5982\u679c\u628a\u8fb9\u6743\u4e0b\u653e\u6210\u70b9\u6743\uff0c\u8fd9\u91cc\u5c31\u6210\u4e86\u4e00\u4e2a\u6811\u4e0a\u8def\u5f84\u53d6max\u64cd\u4f5c\n\n2. \u5bf9\u4e8eMST\u4e0a\u7684\u8fb9\uff0c\u4ed6\u5982\u679c\u88ab\u4ee3\u66ff\uff0c\u90a3\u4e48\u5b83dep\u5927\u7684\u7aef\u70b9\u7684\u5b50\u6811\u5185\u4e00\u5b9a\u6709\u4e00\u6761\u8fb9\u6743\u6bd4\u5b83\u5c0f\u7684\u8fb9\u8fde\u5411\u5b83\u7684\u5b50\u6811\u5916\u3002  \u90a3\u4e48\u5bf9\u4e8e\u4e00\u6761\u975e\u6811\u8fb9$(u,v)$ \u6bcf\u4e00\u4e2a$u->lca,v->lca$\u4e24\u6bb5\u8def\u5f84\u4e0a\u7684\u70b9$p$,\u8fb9$(p,fa[p])$\u5c31\u6709\u53ef\u80fd\u88ab\u7528\u8fd9\u6761\u8fb9\u4ee3\u66ff\u3002\u540c\u6837\u7684\u6211\u4eec\u53ef\u4ee5\u6811\u4e0a\u8def\u5f84\u53d6min\uff0c\u6700\u540e\u5355\u70b9\u67e5\u8be2\n\n\u8981\u5b9e\u73b0\u8fd9\u4e24\u4e2a\u64cd\u4f5c\uff0c\u6bd4\u8f83\u5bb9\u6613\u60f3\u5230\u6811\u5256\uff0c\u590d\u6742\u5ea6$O(nlog_2^2n)$~~\uff08\u5728CF\u795e\u673a\u4e0a\u8dd12e5\u6beb\u65e0\u538b\u529b\uff09~~\n\n\u4f46LCT\u540c\u6837\u53ef\u4ee5\u5b9e\u73b0\u8fd9\u4e9b\u64cd\u4f5c\uff0c\u590d\u6742\u5ea6$O(nlog_2n)$~~\u4f46\u662f\u5e38\u6570\u5de8\u5927~~\n\n\n\u6211\u5728\u5b9e\u73b0\u7684\u65f6\u5019\u7528\u4e86\u6811\u5256+kruskal\u7684\u505a\u6cd5\uff0c\u5982\u679c\u8ffd\u6c42\u66f4\u4f18\u590d\u6742\u5ea6\u7684\u8bdd\u8bf7\u81ea\u884c\u7528LCT\u4ee3\u66ff\u6811\u5256\n\n~~\u4ee3\u7801\u53c8\u81ed\u53c8\u957f\uff0c\u5982\u6709\u4e0d\u9002\u8bf7\u89c1\u8c05~~\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n#define PII pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') { if(c=='-') f=-1; c=getchar();}\n\twhile(c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar();}\n\treturn f==1?x:-x;\n}\ninline void print(int x){\n\tif(x<0) x=~x+1,putchar('-');\n\tif(x>=10) print(x/10);\n\tputchar((x%10)|48);\n}\nint n,m;\nint ans[200010];\nPII edg[200010];\nint len[200010];\nbool tre[200010];\nnamespace tree{\n\tvector<PII>vec[200010];\n\tint maxn[800010],ano[800010],tag[800010];\n\tint siz[200010],son[200010],fa[200010],dfn[200010],top[200010],val[200010],dep[200010];\n\tint id;\n\tvoid add(int u,int v,int w){\n\t\tvec[u].pb(mp(v,w));vec[v].pb(mp(u,w));\n\t}\n\tvoid pushup(int p){\n\t\tmaxn[p]=max(maxn[p<<1],maxn[p<<1|1]);\n\t\tano[p]=min(ano[p<<1],ano[p<<1|1]);\n\t}\n\tvoid pushdown(int p){\n\t\tif(tag[p]!=-1){\n\t\t\tif(tag[p]<ano[p<<1]){\n\t\t\t\tano[p<<1]=tag[p];\n\t\t\t}\n\t\t\tif(tag[p]<ano[p<<1|1]){\n\t\t\t\tano[p<<1|1]=tag[p];\n\t\t\t}\n\t\t\ttag[p<<1]=(tag[p<<1]==-1?tag[p]:min(tag[p<<1],tag[p]));\n\t\t\ttag[p<<1|1]=(tag[p<<1|1]==-1?tag[p]:min(tag[p<<1|1],tag[p]));\n\t\t\ttag[p]=-1;\n\t\t}\n\t}\n\tvoid update(int p,int l,int r,int L,int R,int k){\n\t\tif(l>=L&&r<=R){\n\t\t\tif(k<ano[p]){\n\t\t\t\tano[p]=k;\n\t\t\t}tag[p]=(tag[p]==-1?k:min(tag[p],k));\n\t\t\treturn ;\n\t\t}\n\t\tpushdown(p);\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid) update(p<<1,l,mid,L,R,k);\n\t\tif(R>mid) update(p<<1|1,mid+1,r,L,R,k);\n\t\tpushup(p);\n\t}\n\tint qano(int p,int l,int r,int L,int R){\n\t\tif(l>=L&&r<=R){\n\t\t\treturn ano[p];\n\t\t}\n\t\tpushdown(p);\n\t\tpushup(p);\n\t\tint mid=l+r>>1;\n\t\tint res=0x3f3f3f3f;\n\t\tif(L<=mid) res=min(res,qano(p<<1,l,mid,L,R));\n\t\tif(R>mid) res=min(res,qano(p<<1|1,mid+1,r,L,R));\n\t\treturn res;\n\t}\n\tvoid build(int p,int l,int r){\n\t\ttag[p]=-1;\n\t\tif(l==r){\n\t\t\tmaxn[p]=val[l];ano[p]=0x3f3f3f3f;return ;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(p<<1,l,mid);\n\t\tbuild(p<<1|1,mid+1,r);\n\t\tpushup(p);\n\t}\n\tint query(int p,int l,int r,int L,int R){\n\t\tif(l>=L&&r<=R) return maxn[p];\n\t\tint mid=l+r>>1;\n\t\tint res=0;\n\t\tif(L<=mid) res=max(res,query(p<<1,l,mid,L,R));\n\t\tif(R>mid) res=max(res,query(p<<1|1,mid+1,r,L,R));\n\t\treturn res;\n\t}\n\tint Query(int u,int v){\n\t\tint res=0;\n\t\twhile(top[u]!=top[v]){\n\t\t\tif(dep[top[u]]<dep[top[v]]) swap(u,v);\n\t\t\tres=max(res,query(1,1,id,dfn[top[u]],dfn[u]));\n\t\t\tu=fa[top[u]];\n\t\t}\n\t\tif(u==v) return res;\n\t\tif(dep[u]>dep[v]) swap(u,v);\n\t\tres=max(res,query(1,1,id,dfn[u]+1,dfn[v]));\n\t\treturn res;\n\t}\n\tvoid dfs1(int x,int f){ \n\t\tfa[x]=f,dep[x]=dep[f]+1,siz[x]=1;\n\t\tfor(auto i:vec[x]){\n\t\t\tint v=i.fi;\n\t\t\tif(v==f) continue ;\n\t\t\tdfs1(v,x);\n\t\t\tsiz[x]+=siz[v];\n\t\t\tif(siz[v]>siz[son[x]]) son[x]=v;\n\t\t}\n\t}\n\tvoid dfs2(int x,int topf,int va){\n\t\tdfn[x]=++id;val[id]=va;top[x]=topf;\n\t\tif(!son[x]) return ;\n\t\tfor(auto i:vec[x]){\n\t\t\tint v=i.fi;\n\t\t\tif(v==son[x]){\n\t\t\t\tdfs2(v,topf,i.se);\n\t\t\t}\n\t\t}\n\t\tfor(auto i:vec[x]){\n\t\t\tint v=i.fi;\n\t\t\tif(v==fa[x]||v==son[x]) continue ;\n\t\t\tdfs2(v,v,i.se);\n\t\t}\n\t}\n\tvoid UPD(int x,int y,int k){\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\t\tupdate(1,1,id,dfn[top[x]],dfn[x],k);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(x==y) return ;\n\t\tif(dep[x]>dep[y]) swap(x,y);\n\t\tupdate(1,1,id,dfn[x]+1,dfn[y],k);\n\t}\n\tint another(int x,int y){\n\t\tif(dep[x]<dep[y]) swap(x,y);\n\t\treturn qano(1,1,id,dfn[x],dfn[x]);\n\t}\n\tvoid solve(){\n\t\tmemset(ano,0x3f,sizeof(ano));\n\t\tdfs1(1,0);\n\t\tdfs2(1,1,0);\n\t\tbuild(1,1,id);\n\t}\n}\nnamespace MST{\n\tint cnt;\n\tint fa[200010];\n\tstruct edge{\n\t\tint u,v,w,id;\n\t}e[200010];\n\tvoid add(int u,int v,int w,int id){\n\t\te[++cnt]=edge{u,v,w,id};\n\t}\n\tbool cmp(edge x,edge y){\n\t\treturn x.w<y.w;\n\t}\n\tint find(int x){\n\t\tif(fa[x]==x) return x;\n\t\treturn fa[x]=find(fa[x]);\n\t}\n\tvoid kruskal(){\n\t\tint t=1;\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tint fx=find(e[i].u);\n\t\t\tint fy=find(e[i].v);\n\t\t\tif(fx==fy){\n\t\t\t\tcontinue ;\n\t\t\t}\n\t\t\t++t;tree::add(e[i].u,e[i].v,e[i].w);tre[e[i].id]=1;\n\t\t\tfa[fx]=fy;if(t==n) break ;\n\t\t}\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<=n;++i) fa[i]=i;\n\t\tsort(e+1,e+m+1,cmp);\n\t\tkruskal();\n\t}\n}\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<=m;++i){\n\t\tint u=read(),v=read(),w=read();\n\t\tedg[i].fi=u,edg[i].se=v,len[i]=w;\n\t\tMST::add(u,v,w,i);\n\t}\n\tMST::solve();\n\ttree::solve();\n\tfor(int i=1;i<=m;++i){\n\t\tif(!tre[i]){\n\t\t\ttree::UPD(edg[i].fi,edg[i].se,len[i]);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tif(ans[i]==-1) continue ;\n\t\tif(tre[i]){\n\t\t\tans[i]=tree::another(edg[i].fi,edg[i].se)-1;\n\t\t\tif(ans[i]>0x3f3f3f15) ans[i]=-1;continue ;\n\t\t}\n\t\tint maxn=tree::Query(edg[i].fi,edg[i].se);\n\t\tans[i]=maxn-1;\n\t}\n\tfor(int i=1;i<=m;++i) print(ans[i]),putchar(' ');\n\treturn 0;\n}\n```\n",
        "postTime": 1599656197,
        "uid": 131933,
        "name": "sunzh",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF827D"
    },
    {
        "content": "~~CF \u4e0a\u552f\u4e00\u4e00\u9053\u6709 LCT tag \u7684\u9898\u3002~~\n\n\u9898\u76ee\u8981\u6c42\u6bcf\u6761\u8fb9\u7684\u6743\u503c\u6700\u5927\u503c\u4f7f\u5f97\u5176\u5fc5\u5b9a\u51fa\u73b0\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e0a\u3002\n\n\u90a3\u4e48\u53ef\u4ee5\u5148\u6a21\u62df\u4e00\u904d Kruskal\uff0c\u53ef\u4ee5\u770b\u5230\u6709\u4e00\u6761\u8fb9\uff0c\u7aef\u70b9\u4e3a $x,y$\uff0c\u5982\u679c\uff1a\n\n1. $x,y$ \u5df2\u7ecf\u5728\u4e00\u4e2a\u8fde\u901a\u5757\u5185\uff0c\u90a3\u4e48\u53ea\u6709\u5b83\u7684\u8fb9\u6743\u5c0f\u4e8e $x-y$ \u8def\u5f84\u4e0a\u67d0\u4e00\u6761\u8fb9\u624d\u80fd\u52a0\u5165\u3002\n\n2. $x,y$ \u4e0d\u5728\u4e00\u4e2a\u8fde\u901a\u5757\u5185\uff0c\u90a3\u4e48\u76f4\u63a5\u52a0\u5165\u751f\u6210\u6811\u5373\u53ef\u3002\n\n\u5bf9\u4e8e 1\uff0c\u4e5f\u5c31\u662f\u975e\u6811\u8fb9\uff0c\u5f88\u660e\u663e\u5b83\u7684\u7b54\u6848\u662f $x-y$ \u8def\u5f84\u4e0a\u8fb9\u6743\u6700\u5927\u503c -1\u3002\u53ef\u4ee5\u7528 LCT \u7ef4\u62a4\uff0c\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u5148\u628a MST \u5efa\u51fa\u6765\uff0c\u7136\u540e\u6811\u5256\u6216\u500d\u589e\u3002\n\n\u975e\u6811\u8fb9\u5904\u7406\u4e86\uff0c\u90a3\u4e48\u6811\u8fb9\u5462\uff1f\n\n\u5bf9\u4e8e\u4e00\u6761\u975e\u6811\u8fb9\uff0c\u5176\u8fde\u63a5\u4e86 $x,y$\uff0c\u8fb9\u6743\u4e3a $w$\uff0c\u90a3\u4e48 $x-y$ \u8def\u5f84\u4e0a\u6240\u6709\u7684\u8fb9\u6743\u5e94\u90fd\u5c0f\u4e8e $w$\uff0c\u9632\u6b62\u8fd9\u6761\u975e\u6811\u8fb9~~\u4e0a\u4f4d~~\u66ff\u6362\u5b83\u3002\n\n\u90a3\u4e48\u53ef\u4ee5\u6811\u5256\uff0c\u7528\u7ebf\u6bb5\u6811\u67e5\u8be2\u4e00\u4e2a\u533a\u95f4 min\u3002\n\n\u6211\u7528\u7684\u662f\u4e00\u79cd\u7c7b\u4f3c\u5dee\u5206\u7684\u505a\u6cd5\u3002\n\n\u8fd8\u662f\u8fd9\u6761\u8fde\u63a5\u4e86 $x,y$ \u7684\u975e\u6811\u8fb9\uff0c\u6c42\u51fa\u5b83\u4eec\u7684 $lca$\uff0c\u7136\u540e\u641e $n$ \u4e2a\u4f18\u5148\u961f\u5217\uff0c\u628a $w-1$ \u548c $lca$ \u63d2\u5165 $q_x$ \u548c $q_y$ \u4e2d\uff0c\u8dd1\u4e00\u8fb9 dfs\uff0c\u5408\u5e76\u6bcf\u4e2a\u70b9\u7684\u513f\u5b50\u7684\u4f18\u5148\u961f\u5217\uff0c\u987a\u4fbf\u628a $lca$ \u5728\u8be5\u70b9\u4e0b\u65b9\u7684\u8e22\u51fa\uff08\u8bb0\u5f97\u7528\u542f\u53d1\u5f0f\uff0c\u4e0d\u7136\u4f1a T \u7206\uff09\u3002\u90a3\u4e48\u5904\u7406\u5b8c\u540e\u7684\u961f\u9996\u5373\u4e3a\u7b54\u6848\u3002\n\n\u6700\u540e\u8fd8\u8981\u6ce8\u610f\u4e0b\u961f\u5217\u662f\u5426\u4e3a\u7a7a\u3002\n\n~~\u5e38\u6570\u5de8\u5927\uff0c\u6210\u529f\u540d\u5217\u6700\u52a3\u89e3\u3002~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+500;\n\nint v[N],a[N],ch[N][2],rev[N],f[N],ans[N],dep[N],head[N],cnt,top,fa[N][20],opt[N][3];\n\nstruct node\n{\n\tint u,v,w,id,nxt;\n\t\n\tfriend bool operator<(node a,node b)\n\t{\n\t\treturn a.w<b.w;\n\t}\n}edge[N],e[N<<1];\n\n#define ls ch[x][0]\n#define rs ch[x][1]\n\nint isroot(int x){return ch[f[x]][0]==x|ch[f[x]][1]==x;}\nvoid up(int x){v[x]=max(max(v[ls],v[rs]),a[x]);}\nvoid reversal(int x){swap(ls,rs);rev[x]^=1;}\nvoid down(int x){if(!rev[x])return;reversal(ls),reversal(rs);rev[x]=0;}\nvoid rotate(int x)\n{\n\tint y=f[x],z=f[y],k=(ch[y][1]==x),w=(ch[z][1]==y),an=ch[x][k^1];\n\tif(isroot(y))ch[z][w]=x;ch[x][k^1]=y;ch[y][k]=an;\n\tif(an)f[an]=y;f[y]=x,f[x]=z;\n\tup(y);up(x);\n}\n\nint st[N];\n\nvoid splay(int x)\n{\n\tint y=x,z=0;\n\tst[++z]=x;\n\twhile(isroot(y))st[++z]=y=f[y];\n\twhile(z)down(st[z--]);\n\twhile(isroot(x))\n\t{\n\t\ty=f[x],z=f[y];\n\t\tif(isroot(y))rotate((ch[y][1]==x)^(ch[z][1]==y)?x:y);\n\t\trotate(x);\n\t}\n\tup(x);\n}\n\nvoid access(int x){for(int y=0;x;x=f[y=x])splay(x),rs=y,up(x);}\nvoid make_root(int x){access(x);splay(x);reversal(x);}\nint find_root(int x){access(x);splay(x);while(ls)down(x),x=ls;splay(x);return x;}\nvoid split(int x,int y){make_root(x);access(y);splay(y);}\nvoid link(int x,int y){make_root(x);if(find_root(y)!=x)f[x]=y;}\nvoid cut(int x,int y){make_root(x);if(find_root(y)==x&&f[y]==x&&!ch[y][0])f[y]=rs=0,up(x);}\n\nint n,m;\n\nchar cch,B0[1<<15],*S=B0,*T=B0;\n#define getc() (S==T&&(T=(S=B0)+fread(B0,1,1<<15,stdin),S==T)?0:*S++)\nint aa;int read(){\n\twhile(cch=getc(),cch<'0'||cch>'9');aa=cch-'0';\n\twhile(cch=getc(),cch>='0'&&cch<='9')aa=((aa<<3)+(aa<<1))+cch-'0';return aa;\n}\n\nvoid add(int u,int v)\n{\n\te[++cnt].u=u;\n\te[cnt].v=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n}\n\nvoid dfs(int x,int ff)\n{\n\tfa[x][0]=ff;dep[x]=dep[ff]+1;\n\tfor(int i=1;i<=19;i++)\n\t{\n\t\tif(!fa[fa[x][i-1]][i-1])break;\n\t\tfa[x][i]=fa[fa[x][i-1]][i-1];\n\t}\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==ff)continue;\n\t\tdfs(v,x);\n\t}\n}\n\nint LCA(int x,int y)\n{\n\tif(dep[y]>dep[x])swap(x,y);\n\tfor(int i=19;i>=0;i--)if(dep[x]-(1<<i)>=dep[y])x=fa[x][i];\n\tif(y==x)return x;\n\tfor(int i=19;i>=0;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\treturn fa[x][0];\n}\n\nstruct priority\n{\n\tint v,p;\n\t\n\tfriend bool operator<(priority a,priority b)\n\t{\n\t\treturn a.v>b.v;\n\t}\n};\n\npriority_queue<priority>q[N];\n\nvoid dfs2(int x)\n{\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa[x][0])continue;\n\t\tdfs2(v);\n\t\tif(q[v].size()>q[x].size())swap(q[v],q[x]);\n\t\twhile(!q[v].empty())\n\t\t{\n\t\t\tif(dep[q[v].top().p]<=dep[x])q[x].push(q[v].top());\n\t\t\tq[v].pop();\n\t\t}\n\t}\n\twhile(q[x].size()&&dep[q[x].top().p]>dep[x])q[x].pop();\n\tif(x>n&&q[x].size())ans[x-n]=q[x].top().v;\n}\n\nmain()\n{\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++)cin>>edge[i].u>>edge[i].v>>edge[i].w,edge[i].id=i,ans[i]=-1;\n\tsort(edge+1,edge+1+m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=edge[i].u,y=edge[i].v;a[edge[i].id+n]=edge[i].w;\n\t\tif(find_root(x)==find_root(y))\n\t\t{\n\t\t\tsplit(x,y);\n\t\t\tans[edge[i].id]=v[y]-1;\n\t\t\topt[++top][0]=x;opt[top][1]=y;opt[top][2]=edge[i].w-1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlink(x,edge[i].id+n);\n\t\t\tlink(y,edge[i].id+n);\n\t\t\tadd(x,edge[i].id+n);add(edge[i].id+n,x);\n\t\t\tadd(y,edge[i].id+n);add(edge[i].id+n,y);\n\t\t}\n\t}\n\tdfs(1,0);\n\tfor(int i=1;i<=top;i++)\n\t{\n\t\tint x=opt[i][0],y=opt[i][1],lca=LCA(x,y);\n\t\tif(x!=lca)q[x].push((priority){opt[i][2],lca});\n\t\tif(y!=lca)q[y].push((priority){opt[i][2],lca});\n\t}\n\tdfs2(1);\n\tfor(int i=1;i<=m;i++)cout<<ans[i]<<' ';\n}\n```\n\n~~\u5199\u7684\u53ef\u80fd\u6709\u4e9b\u81ed\uff1f~~",
        "postTime": 1651822778,
        "uid": 344416,
        "name": "zsq147258369",
        "ccfLevel": 7,
        "title": "CF827D Best Edge Weight \u9898\u89e3"
    },
    {
        "content": "\u63d0\u4f9b\u849f\u84bb\u7684\u4e00\u4e2a $\\log$ \u6811\u5256\u505a\u6cd5\u3002\n\n\u5148\u8dd1\u4e00\u904d kruskal\uff0c\u6c42\u51fa\u4e00\u9897 MST\uff0c\u628a\u6811\u663e\u5f0f\u5730\u5efa\u51fa\u6765\uff0c\u7136\u540e\u5206\u522b\u8ba8\u8bba\u6811\u8fb9\u548c\u975e\u6811\u8fb9\u3002\n\n\u5bf9\u4e8e\u975e\u6811\u8fb9 $(u,v)$\uff0c\u5982\u679c\u8981\u4f7f\u5b83\u4e00\u5b9a\u5728 MST \u4e0a\uff0c\u90a3\u4e48\u5b83\u53ea\u8981\u53d6\u4ee3\u4efb\u610f\u4e00\u6761\u6811\u8fb9\u5373\u53ef\u3002\u6240\u4ee5\u5b83\u7684\u8fb9\u6743\u4e25\u683c\u5c0f\u4e8e\u6811\u4e0a $u,v$ \u4e24\u70b9\u4e4b\u95f4\u7684\u8def\u5f84\u7684\u8fb9\u6743\u6700\u5927\u503c\uff0c\u53ef\u4ee5\u500d\u589e\u3002\n\n\u5bf9\u4e8e\u6811\u8fb9$(x,y)$\uff0c\u5b83\u4e0d\u80fd\u88ab\u4efb\u4f55\u4e00\u6761\u975e\u6811\u8fb9\u53d6\u4ee3\uff0c\u800c\u4e00\u6761\u975e\u6811\u8fb9 $(u,v)$ \u53d6\u4ee3\u5b83\u7684\u60c5\u51b5\u548c\u4e0a\u6587\u7c7b\u4f3c\uff0c\u5373 $(x,y)$ \u5728 $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\uff0c\u4e14\u8fd9\u6761\u975e\u6811\u8fb9\u7684\u957f\u5ea6\u5c0f\u4e8e\u7b49\u4e8e\u6811\u8fb9\u7684\u957f\u5ea6\u3002\n\n\u6240\u4ee5\u5bf9\u4e8e\u6bcf\u6761\u957f\u5ea6\u4e3a $z$ \u7684\u975e\u6811\u8fb9 $(x,y)$\uff0c$x$ \u5230 $y$ \u7684\u8def\u5f84\u4e0a\u6240\u6709\u6811\u8fb9\u8fb9\u6743\u90fd\u5fc5\u987b\u4e25\u683c\u5c0f\u4e8e $z$\u3002\u8fd9\u91cc\u53ef\u4ee5\u65b9\u4fbf\u7684\u6811\u5256+\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2 n)$\u3002\n\n---\n\n\u4e8b\u5b9e\u4e0a\uff0c\u6811\u5256\u53ef\u4ee5\u505a\u5230 $O(n\\log n)$\uff0c\u53ea\u4e0d\u8fc7\u6211\u4eec\u4e0d\u80fd\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u9700\u8981\u6539\u6210 st \u8868\u3002\n\n\u89c2\u5bdf\u4e0a\u9762\u7684\u7ebf\u6bb5\u6811\uff0c\u53d1\u73b0\u53ea\u9700\u8981\u652f\u6301\u5c06\u533a\u95f4\u5185\u5927\u4e8e $x$ \u7684\u6570\u5168\u90e8\u6539\u4e3a $x$\uff0c\u4ee5\u53ca\u5355\u70b9\u67e5\u8be2\uff0c\u4e14\u4fee\u6539\u5168\u90e8\u5728\u67e5\u8be2\u4e4b\u524d\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u641e\u4e2a st \u8868\uff0c\u4fee\u6539\u5b8c\u540e\u4e0d\u662f\u4ece\u4e0b\u5f80\u4e0a\u9012\u63a8\u800c\u662f\u4ece\u4e0a\u5f80\u4e0b\uff0c\u90a3\u4e48\u4fee\u6539\u548c\u67e5\u8be2\u90fd\u662f $O(1)$ \u7684\uff0c\u4ece\u4e0a\u5f80\u4e0b\u9012\u63a8\u662f $O(n\\log n)$ \u7684\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u964d\u4e3a $O(n\\log n)$\u3002\n\n\u7ebf\u6bb5\u6811\u4ee3\u7801\uff1a\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nconst int INF = 0x3fffffff;\ninline int min(const int x, const int y) {return x < y ? x : y;}\ninline int max(const int x, const int y) {return x > y ? x : y;}\nstruct Line {\n\tint u, v, w, id;\n\tinline bool operator < (const Line a) const {return w < a.w;}\n} edge[200005];\nstruct Edge {\n\tint to, nxt, w;\n} e[400005];\nint n, m, f[200005], top[200005], dfn[200005],cnt, tot, fa[200005][20], Ans[200005];\nint sze[200005], son[200005], dep[200005], head[200005], dist[200005][20];\nbool mark[200005];\ninline void AddEdge(int u, int v, int w) {\n\te[++ tot].to = v, e[tot].nxt = head[u], e[tot].w = w, head[u] = tot;\n}\nint find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}\nvoid merge(int u, int v, int w) {\n\tint fx = find(u), fy = find(v);\n\tAddEdge(u, v, w), AddEdge(v, u, w);\n\tf[fx] = fy;\n}\n\nvoid dfs1(int u) {\n\tsze[u] = 1, dep[u] = dep[fa[u][0]] + 1;\n\tfor (int i = 1; i < 20; ++ i) {\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\t\tdist[u][i] = max(dist[u][i - 1], dist[fa[u][i - 1]][i - 1]);\n\t}\n\tfor (int i = head[u]; i; i = e[i].nxt)\n\t\tif (e[i].to != fa[u][0]) {\n\t\t\tint v = e[i].to;\n\t\t\tfa[v][0] = u, dist[v][0] = e[i].w, dfs1(v), sze[u] += sze[v];\n\t\t\tif (sze[v] > sze[son[u]]) son[u] = v;\n\t\t}\n}\nvoid dfs2(int u) {\n\tdfn[u] = ++ cnt;\n\tif (son[u]) top[son[u]] = top[u], dfs2(son[u]);\n\tfor (int i = head[u]; i; i = e[i].nxt)\n\t\tif (e[i].to != fa[u][0] && e[i].to != son[u])\n\t\t\ttop[e[i].to] = e[i].to, dfs2(e[i].to);\n}\n\nstruct Node {\n\tint l, r, v, Lazy;\n} tree[800005];\nvoid make_tree(int O, int L, int R) {\n\ttree[O].l = L, tree[O].r = R, tree[O].v = INF, tree[O].Lazy = INF;\n\tif (L != R) {\n\t\tmake_tree(O << 1, L, L + R >> 1);\n\t\tmake_tree(O << 1 | 1, (L + R >> 1) + 1, R);\n\t}\n}\ninline void pushdown(int O) {\n\tif (tree[O].Lazy == INF) return;\n\ttree[O << 1].v = min(tree[O << 1].v, tree[O].Lazy);\n\ttree[O << 1].Lazy = min(tree[O << 1].Lazy, tree[O].Lazy);\n\ttree[O << 1 | 1].v = min(tree[O << 1 | 1].v, tree[O].Lazy);\n\ttree[O << 1 | 1].Lazy = min(tree[O << 1 | 1].Lazy, tree[O].Lazy);\n\ttree[O].Lazy = INF;\n}\nvoid update(int O, int L, int R, int v) {\n\tif (L <= tree[O].l && tree[O].r <= R) {\n\t\ttree[O].v = min(tree[O].v, v), tree[O].Lazy = min(tree[O].Lazy, v);\n\t\treturn;\n\t}\n\tint mid = tree[O].l + tree[O].r >> 1;\n\tpushdown(O);\n\tif (L <= mid) update(O << 1, L, R, v);\n\tif (mid < R) update(O << 1 | 1, L, R, v);\n\ttree[O].v = min(tree[O << 1].v, tree[O << 1 | 1].v);\n}\nint query(int O, int p) {\n\tif (tree[O].l == tree[O].r) return tree[O].v;\n\tint mid = tree[O].l + tree[O].r >> 1;\n\tpushdown(O);\n\treturn p <= mid ? query(O << 1, p) : query(O << 1 | 1, p);\n}\nvoid change(int u, int v, int d) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;\n\t\tupdate(1, dfn[top[u]], dfn[u], d);\n\t\tu = fa[top[u]][0];\n\t}\n\tif (dep[u] > dep[v]) u ^= v ^= u ^= v;\n\tif (dfn[u] < dfn[v]) update(1, dfn[u] + 1, dfn[v], d);\n}\nint LCA(int u, int v) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;\n\t\tu = fa[top[u]][0];\n\t}\n\treturn dep[u] < dep[v] ? u : v;\n}\nint ask(int u, int v) {\n\tint p = LCA(u, v), t1 = dep[u] - dep[p], t2 = dep[v] - dep[p], ans = 0;\n\tfor (int i = 19; i >= 0; -- i)\n\t\tif (t1 & 1 << i) ans = max(ans, dist[u][i]), u = fa[u][i];\n\tfor (int i = 19; i >= 0; -- i)\n\t\tif (t2 & 1 << i) ans = max(ans, dist[v][i]), v = fa[v][i];\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tmake_tree(1, 1, n);\n\tfor (int i = 1; i <= n; ++ i) f[i] = i;\n\tfor (int i = 1; i <= m; ++ i)\n\t\tscanf(\"%d%d%d\", &edge[i].u, &edge[i].v, &edge[i].w), edge[i].id = i;\n\tstd::sort(edge + 1, edge + m + 1);\n\tfor (int i = 1, cnt = 0; cnt < n - 1; ++ i)\n\t\tif (find(edge[i].u) != find(edge[i].v))\n\t\t\tmerge(edge[i].u, edge[i].v, edge[i].w), mark[i] = true, ++ cnt;\n\tdfs1(1), top[1] = 1, dfs2(1);\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (!mark[i]) change(edge[i].u, edge[i].v, edge[i].w);\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (mark[i]) {\n\t\t\tint ans = query(1, max(dfn[edge[i].u], dfn[edge[i].v]));\n\t\t\tAns[edge[i].id] = (ans < INF ? ans - 1 : -1);\n\t\t} else {\n\t\t\tint ans = ask(edge[i].u, edge[i].v);\n\t\t\tAns[edge[i].id] = ans - 1;\n\t\t}\n\tfor (int i = 1; i <= m; ++ i) printf(\"%d \", Ans[i]);\n\treturn 0;\n}\n```\n\nst \u8868\u4ee3\u7801\uff1a\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n\nconst int INF = 0x3fffffff;\ninline int min(const int x, const int y) {return x < y ? x : y;}\ninline int max(const int x, const int y) {return x > y ? x : y;}\nstruct Line {\n\tint u, v, w, id;\n\tinline bool operator < (const Line a) const {return w < a.w;}\n} edge[200005];\nstruct Edge {\n\tint to, nxt, w;\n} e[400005];\nint n, m, f[200005], top[200005], dfn[200005],cnt, tot, fa[200005][20], Ans[200005];\nint sze[200005], son[200005], dep[200005], head[200005], dist[200005][20];\nbool mark[200005];\ninline void AddEdge(int u, int v, int w) {\n\te[++ tot].to = v, e[tot].nxt = head[u], e[tot].w = w, head[u] = tot;\n}\nint find(int x) {return f[x] == x ? x : f[x] = find(f[x]);}\nvoid merge(int u, int v, int w) {\n\tint fx = find(u), fy = find(v);\n\tAddEdge(u, v, w), AddEdge(v, u, w);\n\tf[fx] = fy;\n}\n\nvoid dfs1(int u) {\n\tsze[u] = 1, dep[u] = dep[fa[u][0]] + 1;\n\tfor (int i = 1; i < 20; ++ i) {\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\t\tdist[u][i] = max(dist[u][i - 1], dist[fa[u][i - 1]][i - 1]);\n\t}\n\tfor (int i = head[u]; i; i = e[i].nxt)\n\t\tif (e[i].to != fa[u][0]) {\n\t\t\tint v = e[i].to;\n\t\t\tfa[v][0] = u, dist[v][0] = e[i].w, dfs1(v), sze[u] += sze[v];\n\t\t\tif (sze[v] > sze[son[u]]) son[u] = v;\n\t\t}\n}\nvoid dfs2(int u) {\n\tdfn[u] = ++ cnt;\n\tif (son[u]) top[son[u]] = top[u], dfs2(son[u]);\n\tfor (int i = head[u]; i; i = e[i].nxt)\n\t\tif (e[i].to != fa[u][0] && e[i].to != son[u])\n\t\t\ttop[e[i].to] = e[i].to, dfs2(e[i].to);\n}\n\nint st[20][500005], Log[500005];\nvoid update(int l, int r, int d) {\n\tint k = Log[r - l + 1];\n\tst[k][l] = min(st[k][l], d);\n\tst[k][r - (1 << k) + 1] = min(st[k][r - (1 << k) + 1], d);\n}\nvoid change(int u, int v, int d) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;\n\t\tupdate(dfn[top[u]], dfn[u], d);\n\t\tu = fa[top[u]][0];\n\t}\n\tif (dep[u] > dep[v]) u ^= v ^= u ^= v;\n\tif (dfn[u] < dfn[v]) update(dfn[u] + 1, dfn[v], d);\n}\nint LCA(int u, int v) {\n\twhile (top[u] != top[v]) {\n\t\tif (dep[top[u]] < dep[top[v]]) u ^= v ^= u ^= v;\n\t\tu = fa[top[u]][0];\n\t}\n\treturn dep[u] < dep[v] ? u : v;\n}\nint ask(int u, int v) {\n\tint p = LCA(u, v), t1 = dep[u] - dep[p], t2 = dep[v] - dep[p], ans = 0;\n\tfor (int i = 19; i >= 0; -- i)\n\t\tif (t1 & 1 << i) ans = max(ans, dist[u][i]), u = fa[u][i];\n\tfor (int i = 19; i >= 0; -- i)\n\t\tif (t2 & 1 << i) ans = max(ans, dist[v][i]), v = fa[v][i];\n\treturn ans;\n}\n\nint main() {\n\tfor (int i = 0; i <= 19; ++ i)\n\tfor (int j = 1; j <= 500000; ++ j) st[i][j] = INF;\n\tscanf(\"%d%d\", &n, &m);\n\tf[1] = 1;\n\tfor (int i = 2; i <= n; ++ i) f[i] = i, Log[i] = Log[i >> 1] + 1;\n\tfor (int i = 1; i <= m; ++ i)\n\t\tscanf(\"%d%d%d\", &edge[i].u, &edge[i].v, &edge[i].w), edge[i].id = i;\n\tstd::sort(edge + 1, edge + m + 1);\n\tfor (int i = 1, cnt = 0; cnt < n - 1; ++ i)\n\t\tif (find(edge[i].u) != find(edge[i].v))\n\t\t\tmerge(edge[i].u, edge[i].v, edge[i].w), mark[i] = true, ++ cnt;\n\tdfs1(1), top[1] = 1, dfs2(1);\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (!mark[i]) change(edge[i].u, edge[i].v, edge[i].w);\n\tfor (int i = 19; i; -- i)\n\t\tfor (int j = 1; j + (1 << i) - 1 <= n; ++ j) {\n\t\t\tst[i - 1][j] = min(st[i - 1][j], st[i][j]);\n\t\t\tst[i - 1][j + (1 << i - 1)] = min(st[i - 1][j + (1 << i - 1)], st[i][j]);\n\t\t}\n\tfor (int i = 1; i <= m; ++ i)\n\t\tif (mark[i]) {\n\t\t\tint ans = st[0][max(dfn[edge[i].u], dfn[edge[i].v])];\n\t\t\tAns[edge[i].id] = (ans < INF ? ans - 1 : -1);\n\t\t} else Ans[edge[i].id] = ask(edge[i].u, edge[i].v) - 1;\n\tfor (int i = 1; i <= m; ++ i) printf(\"%d \", Ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1629866382,
        "uid": 361308,
        "name": "Stinger",
        "ccfLevel": 0,
        "title": "CF827D Best Edge Weight"
    },
    {
        "content": "[CF827D Best Edge Weight](https://www.luogu.com.cn/problem/CF827D) \n\norz\u7ed9\u6211\u8bb2\u8fd9\u9898\u7684 zyt \u5b66\u957f\u3002\u672c\u7bc7\u9898\u89e3\u5f88\u5927\u7a0b\u5ea6\u4e0a\u53c2\u8003\u4e86[\u4ed6\u7684\u535a\u5ba2](https://www.cnblogs.com/zyt1253679098/p/9852648.html)\n\n* \u9996\u5148\u968f\u4fbf\u6c42\u51fa\u4e00\u68f5\u6700\u5c0f\u751f\u6210\u6811\uff0c\u628a\u6811\u8fb9\u548c\u975e\u6811\u8fb9\u5206\u5f00\u5904\u7406\u3002\n\n* \u5bf9\u4e8e\u975e\u6811\u8fb9 $(u,v)$ \uff0c\u5b83\u5fc5\u5b9a\u6210\u4e3a\u6811\u8fb9\u7684\u5145\u8981\u6761\u4ef6\u662f\u5b83\u7684\u6743\u503c\u5c0f\u4e8e\u6811\u4e0a $u$ \u5230 $v$ \u4e4b\u95f4\u7684\u8def\u5f84\u4e0a\u7684\u67d0\u6761\u8fb9 $e$ \u3002\u56e0\u6b64\uff0c\u975e\u6811\u8fb9\u7684\u7b54\u6848\u5c31\u662f\u5b83\u4e24\u7aef\u70b9\u4e4b\u95f4\u6811\u4e0a\u8def\u5f84\u4e0a\u6700\u5927\u8fb9\u7684\u6743\u503c\u51cf 1\uff08\u5982\u679c\u76f8\u7b49\u5219\u4e24\u6761\u8fb9\u90fd\u53ef\u4ee5\u9009\uff0c\u4e0d\u7b26\u5408\u201c\u5fc5\u5b9a\u6210\u4e3a\u6811\u8fb9\u201d\uff09\u3002\n\n* \u5bf9\u4e8e\u6811\u8fb9 $(u,v)$ \uff0c\u5982\u679c\u6709\u4e00\u6761\u975e\u6811\u8fb9 $(a,b)$ \uff0c\u6811\u4e0a $a$ \u548c $b$ \u7684\u8def\u5f84\u8981\u7ecf\u8fc7 $(u,v)$ \uff0c\u90a3\u4e48\u53ea\u6709\u5f53\u4efb\u610f\u8fd9\u6837\u7684 $(a,b)$ \u7684\u6743\u503c\u90fd\u5927\u4e8e $(u,v)$ \u65f6\uff0c$(u,v)$ \u624d\u5fc5\u5b9a\u4e0d\u4f1a\u88ab\u522b\u7684\u8fb9\u66ff\u6362\u4e0b\u6765\uff0c\u4e5f\u5c31\u662f\u5fc5\u5b9a\u6210\u4e3a\u6811\u8fb9\u3002\u56e0\u6b64\uff0c\u6811\u8fb9\u7684\u7b54\u6848\u5c31\u662f\u6240\u6709\u4e0a\u8ff0 $(a,b)$ \u4e2d\u6743\u503c\u6700\u5c0f\u7684\u8fb9\u7684\u6743\u503c\u51cf1\u3002\n\n* \u90a3\u4e48\uff0c\u5bf9\u4e8e\u975e\u6811\u8fb9 $(u,v,w)$ \uff0c\u6211\u4eec\u8981\u67e5\u8be2 $(u,v)$ \u95f4\u8def\u5f84\u4e0a\u7684\u6700\u5927\u8fb9\u6743\uff0c\u5e76\u4e14\u9700\u8981\u7528 $w$ \u6765\u66f4\u65b0\u8fd9\u6bb5\u8def\u5f84\u4e0a\u6240\u6709\u6811\u8fb9\u7684\u7b54\u6848\uff08\u5373\u628a\u8fd9\u4e9b\u8fb9\u7684\u7b54\u6848\u4e0e $w$ \u53d6\u6700\u5c0f\u503c\uff09\u3002\n\n* \u53ef\u4ee5\u7528\u6811\u5256+\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u4f46\u8fd9\u91cc\u4e3b\u8981\u4ecb\u7ecd**\u500d\u589e\u5199\u6cd5**\u3002\u4ee3\u7801\u77ed\uff0c\u8fd8\u5c11\u4e2a log \u3002\n\n* \u533a\u95f4\u67e5\u6700\u5927\u5c31\u6309\u666e\u901a\u7684\u500d\u589e\u5199\u6cd5\u66f4\u65b0\u3001\u67e5\u8be2\u5373\u53ef\u3002\u533a\u95f4\u53d6\u6700\u5c0f\u662f\u8fd9\u4e2a\u7b97\u6cd5\u6700\u7cbe\u5999\u4e4b\u5904\u3002\u8003\u8651\u7528 $mi[a][i]$ \u8868\u793a\u6240\u6709\u4e00\u7aef\u662f $a$ \u53ca\u5176\u5b50\u6811\uff0c\u53e6\u4e00\u7aef\u662f $fa[a][i]$ \u53ca\u5176\u7956\u5148\u7684\u975e\u6811\u8fb9\u7684\u6700\u5c0f\u6743\u503c\u3002$mi[a ][0]$ \u5c31\u662f $a$ \u548c $a$ \u7684\u7236\u4eb2\u4e4b\u95f4\u7684\u8fb9\u7684\u7b54\u6848\u3002 \n\n* \u56e0\u4e3a $mi[a][i]$ \u53ea\u4f1a\u53d8\u5c0f\u4e0d\u4f1a\u53d8\u5927\uff0c\u4e14\u5168\u90e8\u975e\u6811\u8fb9\u8003\u8651\u5b8c\u540e\u624d\u4f1a\u67e5\u8be2\u3002\u6211\u4eec\u53ef\u4ee5\u5168\u90e8\u4fee\u6539\u5c3d\u53ef\u80fd\u5927\u7684\u533a\u95f4\uff0c\u6700\u540e\u518d\u4e00\u8d77\u4ece\u5927\u533a\u95f4\u5411\u5c0f\u533a\u95f4\u5012\u63a8\u3002\u7528 $mi[a][i]$ \u66f4\u65b0 $mi[a][i\u22121]$ \u548c $mi [fa[a][i\u22121]][i\u22121]$ \uff08\u8986\u76d6\u4e86\u5927\u533a\u95f4\u7684\u975e\u6811\u8fb9\u4e00\u5b9a\u4f1a\u8986\u76d6\u8be5\u533a\u95f4\u7684\u5b50\u533a\u95f4\uff09\u3002\u8fd9\u4e2a\u64cd\u4f5c\u7c7b\u4f3c\u4e8e\u7ebf\u6bb5\u6811\u7684pushdown\u3002\n\n\u6211\u7684\u4ee3\u7801\u6709\u70b9\u957f\u5927\u6982\u662f\u56e0\u4e3a\u5199\u7684\u592a\u677e\u6563\u4e86QAQ\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N=2e5+5;\nstruct EDG{\n\tint fro,to,id;\n\tll w;\n\tbool ist; \n}ed[N];\nstruct edg{\n\tint to,nxt,id;\n\tll w;\n}e[N<<1];\nbool cmp(EDG a,EDG b)\n{\n\treturn a.w<b.w;\n}\nint fath[N],fa[N][25],mi[N][25],mx[N][25],dep[N],pre[N],ans[N];\nint cnt,head[N],n,m;\nint find(int x)\n{\n\treturn x==fath[x]? x:fath[x]=find(fath[x]);\n}\nvoid add(int u,int v,int w,int id)\n{\n\tcnt++;\n\te[cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt;\n\te[cnt].w=w;\n\te[cnt].id=id;\n}\nvoid dfs(int u)\n{\n\tfor(int i=head[u];i;i=e[i].nxt)\n\t{\n\t\tint v=e[i].to;\n\t\tif(v==fa[u][0])continue;\n\t\tdep[v]=dep[u]+1;\n\t\tpre[v]=e[i].id;\n\t\tmx[v][0]=e[i].w;\n\t\tfa[v][0]=u;\n\t\tdfs(v);\n\t}\n}\nint querymx(int u,int v)\n{\n\tint s=0;\n\tif(dep[u]<dep[v])swap(u,v);\n\tint d=dep[u]-dep[v];\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(d&(1<<i))\n\t\t{\n\t\t\ts=max(s,mx[u][i]);\n\t\t\tu=fa[u][i];\n\t\t}\n\t}\n\tif(u==v)return s;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[u][i]!=fa[v][i])\n\t\t{\n\t\t\ts=max(s,max(mx[u][i],mx[v][i]));\n\t\t\tu=fa[u][i];\n\t\t\tv=fa[v][i];\n\t\t}\n\t}\n\ts=max(s,max(mx[u][0],mx[v][0]));\n\treturn s;\n}\nvoid changemi(int u,int v,int w)\n{\n\tif(dep[u]<dep[v])swap(u,v);\n\tint d=dep[u]-dep[v];\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(d&(1<<i))\n\t\t{\n\t\t\tmi[u][i]=min(mi[u][i],w);\n\t\t\tu=fa[u][i];\n\t\t}\n\t}\n\tif(u==v)return;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[u][i]!=fa[v][i])\n\t\t{\n\t\t\tmi[u][i]=min(mi[u][i],w);\n\t\t\tmi[v][i]=min(mi[v][i],w);\n\t\t\tu=fa[u][i];\n\t\t\tv=fa[v][i];\n\t\t}\n\t}\n\tmi[u][0]=min(mi[u][0],w),mi[v][0]=min(mi[v][0],w);\n}\nint main() \n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&ed[i].fro,&ed[i].to,&ed[i].w);\n\t\ted[i].id=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfath[i]=i;\n\tsort(ed+1,ed+m+1,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint fu=find(ed[i].fro);\n\t\tint fv=find(ed[i].to);\n\t\tif(fu!=fv)\n\t\t{\n\t\t\tfath[fu]=fv;\n\t\t\tadd(ed[i].fro,ed[i].to,ed[i].w,ed[i].id);\n\t\t\tadd(ed[i].to,ed[i].fro,ed[i].w,ed[i].id);\n\t\t\ted[i].ist=1;\n\t\t}\n\t}\n\tdfs(1);\n\tfor(int j=1;j<=20;j++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tfa[i][j]=fa[fa[i][j-1]][j-1];\n\t\t\tmx[i][j]=max(mx[i][j-1],mx[fa[i][j-1]][j-1]);\n\t\t}\n\tmemset(mi,0x3f,sizeof(mi)); \n\tfor(int i=1;i<=m;i++)\n\t\tif(!ed[i].ist)\n\t\t{\n\t\t\tans[ed[i].id]=querymx(ed[i].fro,ed[i].to)-1;\n\t\t\tchangemi(ed[i].fro,ed[i].to,ed[i].w);\n\t\t}\n\tfor(int j=20;j;j--)\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tmi[i][j-1]=min(mi[i][j-1],mi[i][j]);\n\t\t\tmi[fa[i][j-1]][j-1]=min(mi[fa[i][j-1]][j-1],mi[i][j]);\n\t\t}\n\tfor(int i=2;i<=n;i++)\n\t\tans[pre[i]]=mi[i][0]-1;\n\tfor(int i=1;i<=m;i++)\n\t\tif(ans[i]<0x3f3f3f3f-1)\n\t\t\tprintf(\"%d \",ans[i]);\n\t\t\telse printf(\"-1 \");\n\treturn 0;\n}\n```",
        "postTime": 1606036611,
        "uid": 224403,
        "name": "\u6728xx\u6728\u5927",
        "ccfLevel": 9,
        "title": "CF827D Best Edge Weight \uff08\u6700\u5c0f\u751f\u6210\u6811+\u500d\u589e\uff09"
    },
    {
        "content": "\u9996\u5148$kruskal$\u8dd1\u51fa\u6700\u5c0f\u751f\u6210\u6811\n\n\u5bf9\u56fe\u4e2d\u6bcf\u6761\u8fb9\u8fdb\u884c\u8ba8\u8bba\uff08\u8bbe\u8fd9\u6761\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u4e3a$u,v$\uff09\n\n - \u975e\u6811\u8fb9\uff0c\u8981\u4f7f\u8fd9\u6761\u8fb9\u6210\u4e3a\u6811\u8fb9\uff0c\u628a\u8fd9\u6761\u8fb9\u7684\u6743\u503c\u6700\u5927\u6539\u4e3a$u->v$\u8def\u5f84\u4e0a\u8fb9\u6743\u6700\u5927\u503c-1\u5373\u53ef\n - \u6811\u8fb9\uff0c\u6700\u5927\u8fb9\u6743\u4f7f\u5f97\u8fd9\u6761\u8fb9\u4f9d\u7136\u662f\u6811\u8fb9\uff0c\u6700\u5927\u80fd\u8fbe\u5230\u6240\u6709\u8fde\u63a5\u7684\u70b9\u7684\u8def\u5f84\u7ecf\u8fc7\u8fd9\u6761\u8fb9\u7684\u975e\u6811\u8fb9\u7684\u8fb9\u6743\u6700\u5c0f\u503c-1\n\n\u5982\u4f55\u505a\uff1f\u975e\u6811\u8fb9\u548c\u6811\u8fb9\u5206\u522b\u505a\u4e00\u4e0b\n\n\u9700\u8981\u7ef4\u62a4\u8def\u5f84\u6700\u503c\uff0c\u8def\u5f84\u4fee\u6539\u6700\u503c\u3002\u8f6c\u5316\u6210\u88f8\u6811\u5256\u4e86\u3002\u3002\u3002\n\n$20W$\u7684\u8303\u56f4\u4e24\u53ea$log$\u95ee\u9898\u4e0d\u5927\u3002\u7801\u91cf\u8f83\u5927\uff0c\u8c03\u534a\u5929\u3002\u3002\u3002\n\nCode\uff1a\n\n```cpp\n#include <bits/stdc++.h>\n#define maxn 200010\n#define inf 0x3f3f3f3f\n#define ls rt << 1\n#define rs rt << 1 | 1\nusing namespace std;\nstruct Edge{\n\tint to, next, len, id;\n}edge[maxn << 1];\nstruct Line{\n\tint x, y, z, flag, id;\n}line[maxn << 1];\nstruct Seg{\n\tint l, r, Max, Min, tag;\n}seg[maxn << 2];\nint n, m, num, head[maxn], fa[maxn], f[maxn], d[maxn], size[maxn], son[maxn], id[maxn], Index;\nint pre[maxn], prelen[maxn], wt[maxn], top[maxn], ans[maxn];\n\ninline int read(){\n\tint s = 0, w = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') w = -1;\n\tfor (; isdigit(c); c = getchar()) s = (s << 1) + (s << 3) + (c ^ 48);\n\treturn s * w;\n}\n\nvoid addedge(int x, int y, int z, int id){ edge[++num] = (Edge){ y, head[x], z, id }; head[x] = num; }\nbool cmp(Line x, Line y){ return x.z < y.z; }\nint get(int k){ return k == f[k] ? k : f[k] = get(f[k]); }\n\nvoid kruskal(){\n\tfor (int i = 1; i <= n; ++i) f[i] = i;\n\tfor (int i = 1; i <= m; ++i){\n\t\tint s1 = get(line[i].x), s2 = get(line[i].y);\n\t\tif (s1 != s2){\n\t\t\tf[s1] = s2, line[i].flag = 1;\n\t\t\taddedge(line[i].x, line[i].y, line[i].z, line[i].id);\n\t\t\taddedge(line[i].y, line[i].x, line[i].z, line[i].id);\n\t\t}\n\t}\n}\n\nvoid dfs(int u){\n\tsize[u] = 1, son[u] = -1;\n\tfor (int i = head[u]; i; i = edge[i].next){\n\t\tint v = edge[i].to;\n\t\tif (v != fa[u]){\n\t\t\td[v] = d[u] + 1, fa[v] = u, pre[v] = edge[i].id, prelen[v] = edge[i].len;\n\t\t\tdfs(v);\n\t\t\tsize[u] += size[v];\n\t\t\tif (son[u] == -1 || son[u] != -1 && size[son[u]] < size[v]) son[u] = v;\n\t\t}\n\t}\n}\n\nvoid dfs(int u, int x){\n\twt[id[u] = ++Index] = prelen[u], top[u] = x;\n\tif (son[u] == -1) return;\n\tdfs(son[u], x);\n\tfor (int i = head[u]; i; i = edge[i].next){\n\t\tint v = edge[i].to;\n\t\tif (v != fa[u] && v != son[u]) dfs(v, v);\n\t}\n}\n\nvoid updmax(int &x, int y){ if (x < y) x = y; }\nvoid updmin(int &x, int y){ if (x > y) x = y; }\n\nvoid pushup(int rt){\n\tseg[rt].Max = max(seg[ls].Max, seg[rs].Max);\n\tseg[rt].Min = min(seg[ls].Min, seg[rs].Min);\n}\n\nvoid pushdown(int rt){\n\tupdmin(seg[ls].Min, seg[rt].tag);\n\tupdmin(seg[ls].tag, seg[rt].tag);\n\tupdmin(seg[rs].Min, seg[rt].tag);\n\tupdmin(seg[rs].tag, seg[rt].tag);\n\tseg[rt].tag = inf;\n}\n\nvoid build(int rt, int l, int r){\n\tseg[rt].Min = seg[rt].tag = inf;\n\tseg[rt].l = l, seg[rt].r = r;\n\tif (l == r){ seg[rt].Max = wt[l]; return; }\n\tint mid = (l + r) >> 1;\n\tbuild(ls, l, mid); build(rs, mid + 1, r);\n\tpushup(rt);\n}\n\nvoid update(int rt, int l, int r, int k){\n\tif (seg[rt].l > r || seg[rt].r < l) return;\n\tif (seg[rt].l >= l && seg[rt].r <= r){\n\t\tupdmin(seg[rt].Min, k);\n\t\tupdmin(seg[rt].tag, k);\n\t\treturn;\n\t}\n\tpushdown(rt);\n\tupdate(ls, l, r, k); update(rs, l, r, k);\n\tpushup(rt);\n}\n\nint querymax(int rt, int l, int r){\n\tif (seg[rt].l > r || seg[rt].r < l) return 0;\n\tif (seg[rt].l >= l && seg[rt].r <= r) return seg[rt].Max;\n\tpushdown(rt);\n\treturn max(querymax(ls, l, r), querymax(rs, l, r));\n}\n\nint querymin(int rt, int pos){\n\tif (seg[rt].l == seg[rt].r) return seg[rt].Min;\n\tpushdown(rt);\n\tif (seg[ls].r >= pos) return querymin(ls, pos); else\n\treturn querymin(rs, pos);\n}\n\nint qrymax(int u, int v){\n\tint sum = 0;\n\twhile (top[u] != top[v]){\n\t\tif (d[top[u]] < d[top[v]]) swap(u, v);\n\t\tupdmax(sum, querymax(1, id[top[u]], id[u]));\n\t\tu = fa[top[u]];\n\t}\n\tif (d[u] > d[v]) swap(u, v);\n\treturn max(sum, querymax(1, id[u] + 1, id[v]));\n}\n\nvoid updatemin(int u, int v, int k){\n\twhile (top[u] != top[v]){\n\t\tif (d[top[u]] < d[top[v]]) swap(u, v);\n\t\tupdate(1, id[top[u]], id[u], k);\n\t\tu = fa[top[u]];\n\t}\n\tif (d[u] > d[v]) swap(u, v);\n\tupdate(1, id[u] + 1, id[v], k);\n}\n\nint main(){\n\tn = read(), m = read();\n\tfor (int i = 1; i <= m; ++i) line[i].x = read(), line[i].y = read(), line[i].z = read(), line[i].id = i;\n\tsort(line + 1, line + 1 + m, cmp);\n\tkruskal();\n\tdfs(1); dfs(1, 1);\n\tbuild(1, 1, n);\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (!line[i].flag){\n\t\t\tans[line[i].id] = qrymax(line[i].x, line[i].y) - 1;\n\t\t\tupdatemin(line[i].x, line[i].y, line[i].z);\n\t\t}\n\tfor (int i = 2; i <= n; ++i) ans[pre[i]] = querymin(1, id[i]) - 1;\n\tfor (int i = 1; i <= m; ++i) printf(\"%d \", ans[i] < inf - 1 ? ans[i] : -1);\n\treturn 0;\n}\n```\n",
        "postTime": 1564480108,
        "uid": 51719,
        "name": "ModestCoder_",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF827D \u3010Best Edge Weight\u3011"
    },
    {
        "content": "[$\\Large \\color{blue}{Bl}\\color{orange}{og}$](http://geiz-revive.github.io/)\n\n\u9898\u610f\u662f\u8981\u6c42\u51fa\u4e00\u6761\u8fb9\u7684\u8fb9\u6743\u4e3a\u591a\u5927\u65f6\uff0c\u80fd\u51fa\u73b0\u5728\u6240\u6709\u7684\u6700\u5c0f\u751f\u6210\u6811\u4e2d\uff0c\u56e0\u6b64\u6211\u4eec\u5148\u968f\u4fbf\u9020\u4e00\u68f5\u6700\u5c0f\u751f\u6210\u6811\uff0c\u8fdb\u884c\u5206\u7c7b\u8ba8\u8bba\u3002\n\n- \u5bf9\u4e8e\u975e\u6811\u8fb9\uff0c\u5b83\u7684\u7b54\u6848\u662f\u5b83\u94fe\u63a5\u7684\u8fd9\u4e24\u4e2a\u70b9\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e0a\u7684\u94fe\u7684\u6700\u5927\u503c\u518d-1\uff0c\u8fd9\u6837\u5b83\u624d\u80fd\u66ff\u6362\u6389\u6811\u8fb9\u3002\n- \u5bf9\u4e8e\u6811\u8fb9\uff0c\u5b83\u7684\u7b54\u6848\u662f\u80fd\u591f\u8ba9\u5b83\u6240\u94fe\u63a5\u7684\u4e24\u4e2a\u70b9\u8054\u901a\u7684\u975e\u6811\u8fb9\u7684\u6700\u5c0f\u503c\u518d\u51cf\u4e00\uff0c\u5426\u5219\u5b83\u4f1a\u88ab\u66ff\u6362\u6389\u3002\n\n\u4e4b\u540e\u53ef\u4ee5\u53d1\u73b0\uff0c\u6211\u4eec\u9700\u8981\u7684\u53ea\u4e0d\u8fc7\u662f\u4e00\u4e2a\u80fd\u67e5\u8be2\u94fe\u4e0a\u6700\u5927\u503c\u3001\u94fe\u4e0a\u53d6\u6700\u5c0f\u503c\u7684\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u56e0\u6b64\u6811\u5256$\\Theta(nlog^2_n)$\uff0cLCT$\\Theta(nlog_n)$\n\n$\\large Code:$\n\n```cpp\n#pragma region revive\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <unordered_map>\n#define inl inline\n#define re register int\n#define fa(x) t[x].fa\n#define son(x,y) t[x].child[y]\n#define ls(x) t[x].child[0]\n#define rs(x) t[x].child[1]\n#define ll long long\nconst int inf = 0x3f3f3f3f;\n#define lowbit(x) ((x) & (-x))\nusing namespace std;\n#ifndef _DEBUG\n#define getchar() (*(IOB.in.p++))\n#define putchar(c) (*(IOB.out.p++)=(c))\n#define io_eof() (IOB.in.p>=IOB.in.pend)\nstruct IOBUF { struct { char buff[1 << 26], *p, *pend; }in; struct { char buff[1 << 26], *p; }out; IOBUF() { in.p = in.buff; out.p = out.buff; in.pend = in.buff + fread(in.buff, 1, 1 << 26, stdin); }~IOBUF() { fwrite(out.buff, 1, out.p - out.buff, stdout); } }IOB;\n#endif\ntemplate<typename IO>\ninl void write(IO x) {\n\tif (x == 0) return (void)putchar('0');\n\tif (x < 0)putchar('-'), x = -x;\n\tstatic char buf[30];\n\tchar* p = buf;\n\twhile (x) {\n\t\t*(p++) = x % 10 + '0';\n\t\tx /= 10;\n\t}\n\twhile (p > buf)putchar(*(--p));\n}\ninl void writestr(const char *s) { while (*s != 0)putchar(*(s++)); }\ntemplate<typename IO>inl void writeln(IO x) { write(x), putchar('\\n'); }\ntemplate<typename IO>inl void writesp(IO x) { write(x), putchar(' '); }\ninl int readstr(char *s) {\n\tchar *begin = s, c = getchar();\n\twhile (c < 33 || c>127) {\n\t\tc = getchar();\n\t}\n\twhile (c >= 33 && c <= 127) {\n\t\t*(s++) = c;\n\t\tc = getchar();\n\t}\n\t*s = 0;\n\treturn s - begin;\n}\ntemplate<typename IO>\ninl IO read() {\n\tIO x = 0;\n\tregister bool w = 0;\n\tregister char c = getchar();\n\twhile (c > '9' || c < '0') {\n\t\tif (c == '-') w = 1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + (c ^ 48);\n\t\tc = getchar();\n\t}\n\treturn w ? -x : x;\n}\n#pragma endregion\nint fa[1000001], ans[1000001];\nbool vis[1000001];\nstruct node {\n\tint child[2], fa, w, max, tag;\n\tbool filp;\n}t[1000001];\ninl void maintain(int x) {\n\tt[x].max = max({ t[ls(x)].max, t[rs(x)].max, t[x].w });\n}\ninl bool poi(int x) { return rs(fa(x)) == x; }\ninl bool nroot(int x) { return ls(fa(x)) == x || rs(fa(x)) == x; }\ninl void reverse(int x) { swap(ls(x), rs(x)), t[x].filp ^= 1; }\ninl void change(int x, int w) { ans[x] = min(ans[x], w), t[x].tag = min(t[x].tag, w); }\ninl void rotate(int x) {\n\tre f = fa(x), gf = fa(f), fs = poi(x), gfs = poi(f), s = t[x].child[fs ^ 1];\n\tif (nroot(f))t[gf].child[gfs] = x;\n\tt[x].child[fs ^ 1] = f, t[f].child[fs] = s;\n\tif (s)fa(s) = f;\n\tfa(f) = x, fa(x) = gf, maintain(f);\n}\ninl void pushdown(int x) {\n\tif (t[x].filp) {\n\t\tif (ls(x))reverse(ls(x));\n\t\tif (rs(x))reverse(rs(x));\n\t\tt[x].filp = 0;\n\t}\n\tif (t[x].tag != inf) {\n\t\tif (ls(x))change(ls(x), t[x].tag);\n\t\tif (rs(x))change(rs(x), t[x].tag);\n\t\tt[x].tag = inf;\n\t}\n}\ninl void push(int x) {\n\tif (nroot(x))push(fa(x));\n\tpushdown(x);\n}\ninl void splay(int x) {\n\tpush(x);\n\twhile (nroot(x)) {\n\t\tif (nroot(fa(x)))poi(x) == poi(fa(x)) ? rotate(fa(x)) : rotate(x);\n\t\trotate(x);\n\t}\n\tmaintain(x);\n}\ninl void access(int x) {\n\tfor (re i = 0; x; x = fa(i = x)) splay(x), rs(x) = i, maintain(x);\n}\ninl void makeroot(int x) {\n\taccess(x), splay(x), reverse(x);\n}\ninl void split(int x, int y) {\n\tmakeroot(y), access(x), splay(x);\n}\ninl void link(int x, int y) {\n\tsplit(x, y), fa(y) = x;\n}\nstruct edge {\n\tint u, v, w, id;\n\tbool operator <(const edge &fff)const {\n\t\treturn w < fff.w;\n\t}\n}e[1000001];\ninl int find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }\nsigned main() {\n\tre n = read<int>(), m = read<int>(), u, v, w = n + m, now;\n\tfor (re i = 1; i <= w; i++)t[i].tag = ans[i] = inf;\n\tfor (re i = 1; i <= m; i++) u = read<int>(), v = read<int>(), w = read<int>(), e[i] = edge{ u,v,w }, e[i].id = i;\n\tsort(e + 1, e + 1 + m);\n\tfor (re i = 1; i <= m; i++) {\n\t\tu = e[i].u, v = e[i].v, w = e[i].w, now = e[i].id + n;\n\t\tif (find(u) != find(v)) {\n\t\t\tfa[find(v)] = u;\n\t\t\tt[now].w = t[now].max = w;\n\t\t\tlink(u, now), link(v, now), vis[now] = 1;\n\t\t}\n\t\telse {\n\t\t\tsplit(u, v);\n\t\t\tans[now] = t[u].max - 1;\n\t\t\tchange(u, w);\n\t\t}\n\t}\n\tfor (re i = n + 1, k = n + m; i <= k; i++) {\n\t\tif (vis[i]) {\n\t\t\taccess(i), splay(i), writesp(ans[i] == inf ? -1 : ans[i] - 1);\n\t\t}\n\t\telse {\n\t\t\twritesp(ans[i]);\n\t\t}\n\t}\n}\n```\n\n",
        "postTime": 1561012445,
        "uid": 110271,
        "name": "Genius_Z",
        "ccfLevel": 0,
        "title": "CF827D Best Edge Weight"
    },
    {
        "content": "> \u7ed9\u5b9a\u4e00\u4e2a\u70b9\u6570\u4e3a $n$\uff0c\u8fb9\u6570\u4e3a $m$\uff0c\u6743\u503c\u4e0d\u8d85\u8fc7 $10^9$ \u7684\u5e26\u6743\u8fde\u901a\u56fe\uff0c\u6ca1\u6709\u81ea\u73af\u4e0e\u91cd\u8fb9\u3002\n> \u73b0\u5728\u8981\u6c42\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u6c42\u51fa\uff0c\u8fd9\u6761\u8fb9\u7684\u8fb9\u6743\u6700\u5927\u4e3a\u591a\u5c11\u65f6\uff0c\u5b83\u8fd8\u80fd\u51fa\u73b0\u5728\u6240\u6709\u53ef\u80fd\u7684\u6700\u5c0f\u751f\u6210\u6811\u4e0a\uff0c\u5982\u679c\u5bf9\u4e8e\u4efb\u610f\u8fb9\u6743\u90fd\u51fa\u73b0\uff0c\u5219\u8f93\u51fa $-1$\u3002\n> ($2 \\le n \\le 2 \\times 10^5, n-1 \\le m \\le 2 \\times 10^5$)\n\n\u7531\u4e8e\u5077\u61d2\uff0c\u6211\u53ea\u5199\u4e86 $O(n\\log^2 n)$ \u7684\u505a\u6cd5\u3002\n\n\u5206 $2$ \u79cd\u60c5\u51b5\u8003\u8651\uff1a\n\n - **\u4e00\u6761\u8fb9 $e(u,v)$ \u4e0d\u5728\u4efb\u610f\u7684\u6700\u5c0f\u751f\u6210\u6811\u4e0a**\uff1a\n\t -  \u5219\u4e00\u5b9a\u8981\u4f7f $w_e$ \u5c0f\u4e8e\u6700\u5c0f\u751f\u6210\u6811\u7684\u4e0a $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u6700\u5927\u6743\u503c\u3002\n\t - \u8bc1\u660e\uff1a\u8003\u8651 $\\mathrm{Kruskal}$ \u7684\u8ba1\u7b97\u8fc7\u7a0b\uff0c\u5148\u5c06\u8fb9\u6309\u7167\u8fb9\u6743\u6392\u5e8f\uff0c\u5982\u679c $w_e$ \u8981\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e0a\uff0c\u90a3\u4e48\u53ea\u9700\u8981\u4ee4\u5176\u5728 $u,v$ \u5404\u81ea\u6240\u5728\u8054\u901a\u5757\u88ab\u8fde\u63a5\u5728\u4e00\u8d77\u524d\uff0c\u52a0\u5165 $e(u,v)$ \u5373\u53ef\uff0c\u6240\u4ee5\u53ea\u8981\u4f7f $w_e$ \u5c0f\u4e8e\u6700\u5c0f\u751f\u6210\u6811\u7684\u4e0a $u$ \u5230 $v$ \u7684\u8def\u5f84\u4e0a\u7684\u6700\u5927\u6743\u503c\u3002 \n - **\u4e00\u6761\u8fb9 $e(u,v)$ \u5728\u5176\u4e2d\u4e00\u4e2a\u6700\u5c0f\u751f\u6210\u6811\u4e0a**\uff1a\n\t - \u5219\u5176\u6743\u503c\u7b49\u4e8e\u4e0d\u5728\u6700\u5c0f\u751f\u6210\u6811\u4e0a\u7684\u8fb9 $e'(u',v')$\uff0c\u4e14 $u',v'$ \u7684\u8def\u5f84\u7ecf\u8fc7\u8fb9 $e(u,v)$ \u7684\u6743\u503c $w_{e'} - 1$\uff1b\n\t - \u8bc1\u660e\uff1a\u7531\u524d\u4e00\u4e2a\u8bc1\u660e\u53ef\u77e5\uff0c$e(u,v)$ \u5728\u6700\u5c0f\u751f\u6210\u6811\uff0c\u53ea\u9700\u8981\u6ee1\u8db3 $e'(u',v')$ \u7684\u6743\u503c\u90fd\u6bd4\u5b83\u5927\u5373\u53ef\u3002\n\t\n\u6240\u4ee5\u6709\u4e86\u4e0a\u8ff0\u60f3\u6cd5\uff0c\u6211\u4eec\u5c31\u80fd\u81ea\u7136\u800c\u7136\u60f3\u51fa\u4e00\u4e2a\u975e\u5e38 simple \u4e14 naive \u7684\u505a\u6cd5\u3002\n\n\u53ea\u9700\u8981\u4efb\u610f\u7684\u6c42\u51fa\u4e00\u4e2a\u6700\u5c0f\u751f\u6210\u6811\uff0c\u7528**\u6811\u94fe\u5256\u5206\u7ebf\u6bb5\u6811**\u7ef4\u62a4\u6811\u4e0a\u4e24\u70b9\u95f4\u8def\u5f84\u7684\u533a\u95f4\u67e5\u8be2\u548c\u533a\u95f4\u53d6 $\\min$ \u5373\u53ef\uff0c$O(n \\log^2 n)$\u3002\n\n\u590d\u6742\u5ea6\u66f4\u4f4e\u7684\u505a\u6cd5\uff08\u6742\u8c08\uff09\uff1a\n\u66f4\u591a\u505a\u6cd5\u5c3d\u5728 http://blog.csdn.net/Steaunk/article/details/79504451\n\u5e7f\u544a\n\n```\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define R register\n#define Min(_A, _B) (_A < _B ? _A : _B)\n#define Max(_A, _B) (_A > _B ? _A : _B)\ntemplate <class TT>  void Swap(R TT &A, R TT &B){ R TT t = A; A = B; B = t; }\nint F()\n{\n\tR int x; R char ch;\n\twhile(ch = getchar(), ch < '0'|| ch > '9'); x = ch - '0';\n\twhile(ch = getchar(), ch >= '0' && ch <= '9') x = ch - '0' + x * 10;\n\treturn x;\n}\nconst int Size = 200010, Inf = 2147483647;\nint n, m, Point[Size], Next[Size << 1], To[Size << 1], W1[Size << 1], W2[Size << 1], q;\nstruct Edge{ int u, v, c, Ans; } e[Size], *p[Size];\nvoid Add(R Edge *t)\n{\n\tNext[++q] = Point[t->u]; Point[t->u] = q; To[q] = t->v; W1[q] = t->c, W2[q] = t - e;\n\tNext[++q] = Point[t->v]; Point[t->v] = q; To[q] = t->u; W1[q] = t->c, W2[q] = t - e;\n}\nbool cmp(R Edge *i, R Edge *j){ return i->c < j->c; }\nint Sum[Size], Most[Size], dfn[Size], dfn_index, Pre[Size], A[Size], Who[Size];\nint fa[Size], dep[Size], last[Size];\nint Find(R int now){ return last[now] == now ? now : last[now] = Find(last[now]); }\nvoid DFS1(R int u, R int from)\n{\n\tSum[u] = 1;\n\tdep[u] = dep[fa[u] = from] + 1;\n\tfor(R int j = Point[u]; j; j = Next[j])\n\t\tif(To[j] != from)\n\t\t{\n\t\t\tDFS1(To[j], u);\n\t\t\tSum[u] += Sum[To[j]];\n\t\t\tif(Sum[Most[u]] < Sum[To[j]]) Most[u] = To[j];\n\t\t}\n}\nvoid DFS2(R int u, R int from, R int Grand, R int j)\n{\n\tA[dfn[u] = ++dfn_index] = W1[j]; Who[u] = W2[j];\n\tPre[u] = Grand;\n\tfor(R int j = Point[u]; j; j = Next[j]) if(Most[u] == To[j]) \n\t\tDFS2(Most[u], u, Grand, j);\n\tfor(R int j = Point[u]; j; j = Next[j])\n\t\tif(To[j] != from && To[j] != Most[u])\n\t\t\tDFS2(To[j], u, To[j], j);\n}\nint S0[1 << 19], Lazy[1 << 19], S1[1 << 19];\nvoid Pushdown(R int node)\n{\n\tif(Lazy[node] < Inf)\n\t{\n\t\tLazy[node << 1] = Min(Lazy[node << 1], Lazy[node]);\n\t\tLazy[node << 1 | 1] = Min(Lazy[node << 1 | 1], Lazy[node]);\n\t\tS0[node << 1] = Min(S0[node << 1], Lazy[node]);\n\t\tS0[node << 1 | 1] = Min(S0[node << 1 | 1], Lazy[node]);\n\t\tLazy[node] = Inf;\n\t}\n}\nvoid Modify0(R int node, R int begin, R int end, R int l, R int r, R int val)\n{\n\tif(l <= begin && end <= r)\n\t{\n\t\tS0[node] = Min(S0[node], val);\n\t\tLazy[node] = Min(Lazy[node], val);\n\t\treturn ;\n\t}\n\tPushdown(node);\n\tR int mid = begin + end >> 1;\n\tif(l <= mid) Modify0(node << 1, begin, mid, l, r, val);\n\tif(r > mid) Modify0(node << 1 | 1, mid + 1, end, l, r, val);\n}\nint Query0(R int node, R int begin, R int end, R int l, R int r)\n{\n\tif(l > r) return S0[node];\n\tif(l <= begin && end <= r) return S0[node];\n\tPushdown(node);\n\tR int mid = begin + end >> 1, t1 = Inf, t2 = Inf;\n\tif(l <= mid) t1 = Query0(node << 1, begin, mid, l, r);\n\tif(r > mid) t2 = Query0(node << 1 | 1, mid + 1, end, l, r);\n\treturn Min(t1, t2);\n}\nint Query1(R int node, R int begin, R int end, R int l, R int r)\n{\n\tif(l > r) return S1[node];\n\tif(l <= begin && end <= r) return S1[node];\n\tR int mid = begin + end >> 1, t1 = 0, t2 = 0;\n\tif(l <= mid) t1 = Query1(node << 1, begin, mid, l, r);\n\tif(r > mid) t2 = Query1(node << 1 | 1, mid + 1, end, l, r);\n\treturn Max(t1, t2);\n}\nvoid Build1(R int node, R int begin, R int end)\n{\n\tif(begin == end)\n\t{\n\t\tS1[node] = A[begin];\n\t\treturn ;\n\t}\n\tR int mid = begin + end >> 1;\n\tBuild1(node << 1, begin, mid);\n\tBuild1(node << 1 | 1, mid + 1, end);\n\tS1[node] = Max(S1[node << 1], S1[node << 1 | 1]);\n}\nvoid Build0(R int node, R int begin, R int end)\n{\n\tS0[node] = Lazy[node] = Inf;\n\tif(begin == end) return ;\n\tR int mid = begin + end >> 1;\n\tBuild0(node << 1, begin, mid);\n\tBuild0(node << 1 | 1, mid + 1, end);\n}\nvoid Work(R Edge *i)\n{\n\tR int A = i->u, B = i->v;\n\twhile(Pre[A] != Pre[B])\n\t{\n\t\tif(dep[Pre[A]] < dep[Pre[B]]) Swap(A, B);\n\t\tModify0(1, 1, n, dfn[Pre[A]], dfn[A], i->c);\n\t\tR int t = Query1(1, 1, n, dfn[Pre[A]], dfn[A]);\n\t\ti->Ans = Max(i->Ans, t);\n\t\tA = fa[Pre[A]];\n\t}\n\tif(A == B) return ;\n\tif(dep[A] < dep[B]) Swap(A, B);\n\tModify0(1, 1, n, dfn[B] + 1, dfn[A], i->c);\n\tR int t = Query1(1, 1, n, dfn[B] + 1, dfn[A]);\n\ti->Ans = Max(i->Ans, t);\n}\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor(R int i = 1; i <= m; i++) e[i] = (Edge){F(), F(), F(), -1};\n\tfor(R int i = 1; i <= m; i++){ last[i] = i; p[i] = e + i; }\n\tstd::sort(p + 1, p + 1 + m, cmp);\n\tfor(R int i = 1; i <= m; i++)\n\t{\n\t\tR int X = Find(p[i]->u), Y = Find(p[i]->v);\n\t\tif(X != Y){ last[X] = Y; Add(p[i]); }\n\t}\n\tDFS1(1, 0); DFS2(1, 0, 0, 0);\n\tBuild0(1, 1, n); Build1(1, 1, n);\n\tfor(R int i = 1; i <= n; i++) last[i] = i;\n\tfor(R int i = 1; i <= m; i++)\n\t{\n\t\tR int X = Find(p[i]->u), Y = Find(p[i]->v);\n\t\tif(X != Y) last[X] = Y;\n\t\telse Work(p[i]);\n\t}\n\tfor(R int i = 1; i <= n; i++) e[Who[i]].Ans = Query0(1, 1, n, dfn[i], dfn[i]);\n\tfor(R Edge *i = e + 1; i <= e + m; i++)\n\t\tif(i->Ans == Inf) printf(\"-1 \");\n\t\telse printf(\"%d \", i->Ans - 1);\n\treturn 0;\n}\n```",
        "postTime": 1520610454,
        "uid": 20224,
        "name": "WJiannan",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF827D \u3010Best Edge Weight\u3011"
    },
    {
        "content": "\u7b2c\u4e00\u5c4a\u7c89\u5154\u676f\u88ab\u7c89\u5154\u7528\u8fd9\u9053\u9898\u6dd8\u6c70~~\u8bdd\u8bf4\u7c89\u5154\u676f\u600e\u4e48\u51fa\u539f\u9898\u554a~~\u3002\n\n\u5148\u968f\u4fbf\u627e\u51fa\u4e00\u68f5\u751f\u6210\u6811\uff0c\u5bf9\u4e8e\u6811\u8fb9\u548c\u975e\u6811\u8fb9\u5206\u522b\u8ba1\u7b97\u7b54\u6848\u3002\n\n\u975e\u6811\u8fb9 $(u,v)$ \u7684\u7b54\u6848\u4e3a $u,v$ \u5728\u6811\u4e0a\u8def\u5f84\u6743\u503c $\\max-1$\uff0c\u8fd9\u91cc\u6211\u4f7f\u7528\u500d\u589e\u6c42\u3002\n\n\u6811\u8fb9\u7684\u7b54\u6848\u4e3a\u6240\u6709\u8986\u76d6\u5176\u7684\u975e\u6811\u8fb9\u7684\u6743\u503c $\\min-1$\uff08\u6ca1\u88ab\u8986\u76d6\u8fc7\u5219\u7b54\u6848\u4e3a $-1$\uff09\uff0c\u8fd9\u91cc\u5c06\u975e\u6811\u8fb9\u6309\u8fb9\u6743\u5347\u5e8f\u6392\u5e8f\uff0c\u4e00\u6761\u94fe\u8986\u76d6\u524d\u9762\u8986\u76d6\u8fc7\u7684\u6811\u8fb9\u662f\u65e0\u610f\u4e49\u7684\uff0c\u6240\u4ee5\u4f7f\u7528\u6811\u4e0a\u5e76\u67e5\u96c6\u7ef4\u62a4\u6ca1\u6709\u88ab\u8986\u76d6\u8fc7\u7684\u8fb9\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6\u7ebf\u6027\u5bf9\u6570\u3002\n\n[\u4ee3\u7801](https://codeforces.com/contest/827/submission/208043680) \u633a\u77ed\u7684\u3002",
        "postTime": 1685456907,
        "uid": 101868,
        "name": "I_am_Accepted",
        "ccfLevel": 0,
        "title": "CF827D Best Edge Weight\uff08MST/\u500d\u589e/\u6811\u4e0a\u5e76\u67e5\u96c6\uff09"
    },
    {
        "content": "~~\u8003\u8bd5\u8003\u5230\u539f\u9898\u4e86\u3002~~\n\n\u8003\u8651\u628a\u6700\u5f00\u59cb\u7684\u6700\u5c0f\u751f\u6210\u6811\u7ed9\u627e\u5230\uff0c\u7136\u540e\u66ff\u6362\u8fb9\u3002\u6bcf\u4e00\u6b21\u4f1a\u6dfb\u52a0\u4e00\u6761\u8fb9\uff0c\u7136\u540e\u5f62\u6210\u4e00\u4e2a\u73af\uff0c\u540c\u6837\u7684\uff0c\u5bf9\u4e8e\u6211\u4eec\u6dfb\u52a0\u7684\u8fd9\u4e00\u6761\u8fb9\uff0c\u80fd\u591f\u5f71\u54cd\u7684\u4e5f\u53ea\u6709\u5f53\u524d\u8fd9\u4e00\u4e2a\u73af\u3002\n\n\u5bf9\u4e8e\u6811\u8fb9\uff08\u4ece\u4e00\u5f00\u59cb\u5c31\u5b58\u5728\u5728\u6700\u5c0f\u751f\u6210\u6811\u91cc\u7684\u8fb9\uff09\uff0c\u5982\u679c\u5176\u4e0d\u662f\u6240\u6784\u6210\u73af\u4e0a\u7684\u9664\u5f00\u5176\u5b83\u6811\u8fb9\u7684\u6700\u5c0f\u8fb9\u4e86\uff0c\u5c31\u4f1a\u88ab\u53e6\u5916\u4e00\u6761\u975e\u6811\u8fb9\u6240\u4ee3\u66ff\uff1b\u5bf9\u4e8e\u975e\u6811\u8fb9\uff0c\u5982\u679c\u8fd9\u6761\u8fb9\u6bd4\u73af\u4e0a\u6240\u6709\u6811\u8fb9\u7684\u6743\u503c\u90fd\u8981\u5927\u4e86\uff0c\u5c31\u4e0d\u53ef\u80fd\u6210\u4e3a\u751f\u6210\u6811\u7684\u8fb9\u3002\n\n\u6240\u4ee5\u8003\u8651\u6811\u5256\u7ef4\u62a4\u8fb9\u6743\uff0c\u5bf9\u4e8e\u6811\u8fb9\uff0c\u5728\u8fb9\u4e0a\u8d4b\u4e0a\u6743\u503c\u540e\u8ba9\u975e\u6811\u8fb9\u53bb\u67e5\u8be2\uff0c\u5f97\u5230\u975e\u6811\u8fb9\u7b54\u6848\uff0c\u5bf9\u4e8e\u975e\u6811\u8fb9\uff0c\u5728\u8def\u5f84\u4e0a\u8fdb\u884c `checkMin` \u64cd\u4f5c\uff0c\u7136\u540e\u8ba9\u6811\u8fb9\u53bb\u67e5\u8be2\u5373\u53ef\u3002\n\n``` c++\n\n#include<bits/stdc++.h>\n#define re register\ntypedef long long ll;\ntypedef long double ld;\ntemplate<class T>\ninline void read(T &x)\n{\n    x=0;\n    char ch=getchar(),t=0;\n    while(ch<'0'||ch>'9') t|=ch=='-',ch=getchar();\n    while(ch>='0'&&ch<='9') x=(x<<3)+(x<<1)+(ch^48),ch=getchar();\n    if(t) x=-x;\n}\ntemplate<class T,class ...Arc>\ninline void read(T &x,Arc &...arc){ read(x),read(arc...); }\ntemplate<class T>\ninline void write(T x)\n{\n    if(x<0) putchar('-'),x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+48);\n}\ntemplate<>\ninline void write(bool x){ putchar(x?'1':'0'); }\ntemplate<>\ninline void write(char c){ putchar(c); }\ntemplate<>\ninline void write(char *s){ while(*s!='\\0') putchar(*s++); }\ntemplate<>\ninline void write(const char *s){ while(*s!='\\0') putchar(*s++); }\ntemplate<class T,class ...Arc>\ninline void write(T x,Arc ...arc){ write(x),write(arc...); }\ntemplate<class T>\ninline bool checkMax(T &x,T y){ return x<y?x=y,1:0; }\ntemplate<class T>\ninline bool checkMin(T &x,T y){ return x>y?x=y,1:0; }\ntemplate<class T>\ninline T abs(T x){ return x>0?x:-x; }\nconst int MAXN=1e6+10;\nconst ll INF=1ll<<60;\nstruct Node\n{ int x,y,id;ll val; }Ed[MAXN];\nstruct G\n{ int next,to;ll val; }Edge[MAXN<<1];\nint Head[MAXN],Total;\nbool Vis[MAXN];\nint N,M,Cnt,Pos[MAXN];\nll ans[MAXN];\nint Rt[MAXN],Dep[MAXN],Fa[MAXN],Dfn[MAXN],Top[MAXN],Son[MAXN],Siz[MAXN];\ninline void addEdge(int u,int v,ll w)\n{\n    Edge[++Total]=(G){Head[u],v,w};Head[u]=Total;\n    Edge[++Total]=(G){Head[v],u,w};Head[v]=Total;\n}\nvoid dfsTree(int x,int last)\n{\n    Fa[x]=last,Dep[x]=Dep[last]+1,Siz[x]=1;\n    for(int e=Head[x],v;e;e=Edge[e].next)\n    {\n        if((v=Edge[e].to)==last) continue;\n        dfsTree(v,x);\n        Siz[x]+=Siz[v];\n        if(!Son[x]||Siz[v]>Siz[Son[x]]) Son[x]=v;\n    }\n}\nvoid dfsChain(int x,int topf)\n{\n    Top[x]=topf,Dfn[x]=++Cnt;\n    if(!Son[x]) return ;\n    dfsChain(Son[x],topf);\n    for(int e=Head[x],v;e;e=Edge[e].next)\n    {\n        if((v=Edge[e].to)==Fa[x]||v==Son[x]) continue;\n        dfsChain(v,v);\n    }\n}\ninline bool cmp(const Node &x,const Node &y){ return x.val<y.val; }\ninline int getRt(int x)\n{ return Rt[x]==x?x:Rt[x]=getRt(Rt[x]); }\n#define ls (p<<1)\n#define rs (p<<1|1)\nstruct Seg\n{\n    int l,r;\n    ll val,tag,mx,sec;\n}Tr[MAXN<<2];\ninline void pushUp(int p)\n{\n    if(Tr[ls].mx==INF&&Tr[rs].mx==INF)\n    {\n        Tr[p].mx=INF,Tr[p].sec=-INF;\n        return ;\n    }\n    if(checkMax(Tr[p].mx,Tr[ls].mx)) Tr[p].sec=std::max(Tr[ls].sec,Tr[rs].mx);\n    if(checkMax(Tr[p].mx,Tr[rs].mx)) Tr[p].sec=std::max(Tr[rs].sec,Tr[ls].mx);\n}\ninline void pushDown(int p)\n{\n    if(Tr[p].tag==INF) return ;\n    if(checkMin(Tr[ls].mx,Tr[p].tag)) checkMin(Tr[ls].tag,Tr[p].tag);\n    if(checkMin(Tr[rs].mx,Tr[p].tag)) checkMin(Tr[rs].tag,Tr[p].tag);\n    Tr[p].tag=INF;\n    return ;\n}\nvoid build(int p,int l,int r)\n{\n    Tr[p].l=l,Tr[p].r=r,Tr[p].tag=Tr[p].mx=INF;\n    Tr[p].sec=-INF;\n    if(l==r) return ;\n    int mid=(l+r)>>1;\n    build(ls,l,mid),build(rs,mid+1,r);\n}\nvoid modifyX(int p,int x,ll v)\n{\n    if(Tr[p].l==Tr[p].r) return Tr[p].val+=v,void();\n    int mid=(Tr[p].l+Tr[p].r)>>1;\n    x<=mid?modifyX(ls,x,v):modifyX(rs,x,v);\n    Tr[p].val=std::max(Tr[ls].val,Tr[rs].val);\n}\nll queryMax(int p,int l,int r)\n{\n    if(Tr[p].l==l&&Tr[p].r==r) return Tr[p].val;\n    int mid=(Tr[p].l+Tr[p].r)>>1;\n    if(r<=mid) return queryMax(ls,l,r);\n    else if(l>mid) return queryMax(rs,l,r);\n    else return std::max(queryMax(ls,l,mid),queryMax(rs,mid+1,r));\n}\nvoid modifyMin(int p,int l,int r,ll v)\n{\n    if(Tr[p].mx<=v) return ;\n    if(l<=Tr[p].l&&Tr[p].r<=r)\n        if(Tr[p].sec<=v)\n        {\n            Tr[p].mx=v,checkMin(Tr[p].tag,v);\n            return ;\n        }\n    pushDown(p);\n    int mid=(Tr[p].l+Tr[p].r)>>1;\n    if(l<=mid) modifyMin(ls,l,std::min(r,mid),v);\n    if(mid<r) modifyMin(rs,std::max(l,mid+1),r,v);\n    pushUp(p);\n}\nll querySec(int p,int x)\n{\n    if(Tr[p].l==Tr[p].r) return Tr[p].mx;\n    pushDown(p);\n    int mid=(Tr[p].l+Tr[p].r)>>1;\n    return x<=mid?querySec(ls,x):querySec(rs,x);\n}\ninline ll Path(int x,int y,ll v)\n{\n    if(!x||!y) return 0;\n    ll res=0;\n    while(Top[x]!=Top[y])\n    {\n        if(Dep[Top[x]]<Dep[Top[y]]) std::swap(x,y);\n        checkMax(res,queryMax(1,Dfn[Top[x]],Dfn[x]));\n        modifyMin(1,Dfn[Top[x]],Dfn[x],v);\n        x=Fa[Top[x]];\n    }\n    if(Dep[x]>Dep[y]) std::swap(x,y);\n    if(x==y) return res;\n    checkMax(res,queryMax(1,Dfn[Son[x]],Dfn[y]));\n    modifyMin(1,Dfn[Son[x]],Dfn[y],v);\n    return res;\n}\nint main()\n{\n    // freopen(\"easy.in\",\"r\",stdin);\n    // freopen(\"easy.out\",\"w\",stdout);\n    read(N,M);\n    for(int i=1;i<=M;++i) read(Ed[i].x,Ed[i].y,Ed[i].val),Ed[i].id=i;\n    std::sort(Ed+1,Ed+M+1,cmp);\n    for(int i=1;i<=N;++i) Rt[i]=i;\n    int res=0;\n    for(int i=1;i<=M;++i)\n    {\n        int p=getRt(Ed[i].x),q=getRt(Ed[i].y);\n        if(p!=q)\n        {\n            Rt[q]=p;\n            Vis[i]=1;++res;\n            addEdge(Ed[i].x,Ed[i].y,Ed[i].val);\n        }\n        if(res==N-1) break;\n    }\n    dfsTree(1,0),dfsChain(1,1);\n    build(1,1,N);\n    for(int i=1;i<=M;++i) if(Vis[i])\n    {\n        if(Fa[Ed[i].x]==Ed[i].y) modifyX(1,Dfn[Ed[i].x],Ed[i].val),Pos[i]=Ed[i].x;\n        else modifyX(1,Dfn[Ed[i].y],Ed[i].val),Pos[i]=Ed[i].y;\n    }\n    for(int i=1;i<=M;++i) if(!Vis[i]) ans[Ed[i].id]=Path(Ed[i].x,Ed[i].y,Ed[i].val);\n    for(int i=1;i<=M;++i) if(Vis[i]) ans[Ed[i].id]=querySec(1,Dfn[Pos[i]]);\n    for(int i=1;i<=M;++i) write(std::min(ans[i],(ll)1e9),'\\n');\n    return 0;\n}\n/*\n \n*/\n\n```\n\u4ee3\u7801\u8fc7\u4e0d\u4e86\uff0c\u8981\u6539\u4e00\u4e0b\u8f93\u51fa\uff08~~\u61d2\u5f97\u6539\u4e86~~\uff09\u3002\n\n\u8fd9\u4e2a\u662f $\\mathcal O(n\\log^2 n)$ \u7684\u5199\u6cd5\uff0c\u597d\u50cf\u6709\u4e00\u652f $\\log$ \u7684\uff0c\u6392\u5e8f\u540e\u7528\u5e76\u67e5\u96c6\u7ef4\u62a4\uff0c\u4e0d\u592a\u597d\u60f3\u3002\u628a\u6bcf\u4e2a\u975e\u6811\u8fb9\u6392\u4e86\u5e8f\u540e\uff0c\u90a3\u5f53\u524d\u975e\u6811\u8fb9\u6240\u80fd\u505a\u8d21\u732e\u7684\u8fb9\u5373\u662f\u5f53\u524d\u5176\u4ed6\u6ca1\u6709\u88ab\u5f71\u54cd\u5230\u7684\u6811\u8fb9\uff08\u663e\u7136\uff09\u3002\u90a3\u4e48\u8bf4\u6211\u4eec\u5c31\u53ef\u4ee5\u7528\u5e76\u67e5\u96c6\u6765\u7ef4\u62a4\u8fd9\u4e2a\u4e1c\u897f\uff0c$f_i$ \u8868\u793a $i$ \u8fd9\u6761\u8fb9\u4e0a\u9762\u7b2c\u4e00\u4e2a\u6ca1\u6709\u88ab\u8986\u76d6\u7684\u8fb9\u5728\u54ea\u91cc\uff0c\u6bcf\u6b21\u4fee\u6539\u5c31\u53ea\u7528\u7528\u5e76\u67e5\u96c6\u8df3\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002\u7531\u4e8e\u6bcf\u4e00\u4e2a\u8fb9\u53ea\u4f1a\u8986\u76d6 $1$ \u6b21\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u662f $\\mathcal O(m\\alpha (m))$ \u8dd1\u5f97\u8d85\u5feb\u3002",
        "postTime": 1681048945,
        "uid": 444040,
        "name": "_Eternal_",
        "ccfLevel": 0,
        "title": "CF827D Best Edge Weight \u9898\u89e3"
    },
    {
        "content": "\u6211\u6709\u4e00\u4e2a\u5f88\u5999\uff08 cao \uff09\u7684\u601d\u8def\uff0c\u5b83\u6709\u4e09\u53ea $log$ \u3002\u3002\u3002\n\n\u5927\u6982\u662f\u6211\u4eec\u628a\u8fb9\u6309\u7167\u6743\u503c\u6392\u5e8f\uff0c\u7136\u540e\u5bf9\u4e8e\u4e00\u4e2a\u8be2\u95ee $(u,v)$ \uff0c\u6211\u4eec\u53ef\u4ee5\u4e8c\u5206\u7b54\u6848 $x$ \uff0c\u627e\u5230\u6700\u5c0f\u7684 $x$ \u6ee1\u8db3\u628a\u8fb9\u6743 $\\leq x$ \u4f46\u4e0d\u662f $(u,v)$ \u7684\u8fb9\u52a0\u5165\u540e\uff0c $(u,v)$ \u4e4b\u95f4\u4e0d\u6210\u73af\uff0c\u7b54\u6848\u5c31\u662f $x_{min}-1$ \u3002\n\n\u4e00\u4e2a\u4e00\u4e2a\u8be2\u95ee\u505a\u592a\u6162\u4e86\uff0c\u4e8e\u662f\u6211\u4eec\u8003\u8651\u6574\u4f53\u4e8c\u5206+\u5e76\u67e5\u96c6\u7ef4\u62a4\uff0c ```solve(V,l,r)``` \u8868\u793a $V$ \u4e2d\u7684\u8be2\u95ee\u7684\u7b54\u6848\u5728 $(l,r)$ \u4e2d\uff0c\u7ef4\u62a4\u7684\u65f6\u5019\u6211\u4eec\u4fdd\u8bc1 $(1,l-1)$ \u7684\u8fb9\u5728\u5e76\u67e5\u96c6\u91cc\uff0c\u8fd9\u6837\u53ef\u4ee5\u4fdd\u8bc1\u8f6c\u79fb\u65f6\u7684\u4fee\u6539\u4e2a\u6570\u662f $O(r-l+1)+O(V.size())$ \u7ea7\u522b\u7684\u3002\n\n\u5269\u4e0b\u7684\u5c31\u662f\u5982\u4f55\u5feb\u901f\u5bf9\u4e8e\u4e00\u4e2a\u8fb9\u7684\u524d\u7f00 Mid \u53bb\u6389 $(u,v)$ \u8fd9\u6761\u8fb9\uff0c\u518d\u5224\u65ad $(u,v)$ \u662f\u5426\u8fde\u901a\u3002\u8fd9\u4e2a\u53ef\u4ee5\u7528\u7f3a\u4e00\u80cc\u5305\u7684\u601d\u60f3\uff0c\u518d\u4e0a\u4e00\u4e2a\u5206\u6cbb\u89e3\u51b3\u3002\n\n\u4e8e\u662f\u6211\u4eec\u5f97\u5230\u4e86\u4e00\u4e2a\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n\\log^3 n)$ \u7684\u6574\u4f53\u4e8c\u5206\u5957\u5206\u6cbb\u5957\u5e76\u67e5\u96c6\u505a\u6cd5\u3002\u5b83\u53ea\u7528\u5230\u4e86\u7b54\u6848\u7684\u4e8c\u5206\u6027\uff0c\u6ca1\u8003\u8651\u5176\u4ed6\u6027\u8d28\u3002~~\u56e0\u6b64\u8fd9\u4e2a\u505a\u6cd5\u601d\u60f3naive\uff0c\u5b9e\u73b0\u7b80\u5355\uff0c\u662f\u4e00\u4e2a\u4e0d\u53ef\u591a\u5f97\u7684\u597d\u505a\u6cd5\uff01~~\n\n## Code\n```cpp\nPR stk[MAXN * 20];\nvector<int> V;\nint f[MAXN], Ans[MAXN], flag[MAXN], c[MAXN], cnt[MAXN], top = 0, n, m;\nstruct Enode{ int u, v, c, id; } E[MAXN];\n\nint find(int x) { return f[x] == x ? f[x] : find(f[x]); }\nvoid add(int x) {\n\tint u = find(E[x].u), v = find(E[x].v);\n\tif (u == v) { stk[++ top] = MP(-1, -1); return; }\n\tif (cnt[u] > cnt[v]) swap(u, v);\n\tf[u] = v, cnt[v] += cnt[u], stk[++ top] = MP(u, v);\n}\nvoid und() {\n\tif (stk[top].fi != -1) cnt[stk[top].se] -= cnt[stk[top].fi], f[stk[top].fi] = stk[top].fi;\n\t-- top;\n}\nvoid Solve(vector<int> &V, int l, int r, int t) {\n\tif (l == r) {\n\t\tc[V[l]] = (find(E[V[l]].u) == find(E[V[l]].v));\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\n\tfor (int i = mid + 1; i <= r ; ++ i) if (V[i] <= t) add(V[i]);\n\tSolve(V, l, mid, t);\n\tfor (int i = mid + 1; i <= r ; ++ i) if (V[i] <= t) und();\n\n\tfor (int i = l; i <= mid ; ++ i) if (V[i] <= t) add(V[i]);\n\tSolve(V, mid + 1, r, t);\n\tfor (int i = l; i <= mid ; ++ i) if (V[i] <= t) und();\n}\nvoid solve(vector<int> &V, int L, int R) {\n\tif (!V.size()) return;\n\n\tif (L == R) {\n\t\tfor (auto v : V) Ans[E[v].id] = E[L].c - 1;\n\t\treturn;\n\t}\n\n\tint Mid = (L + R) >> 1;\n\tfor (int i = L; i <= Mid ; ++ i) \n\t\tif (!flag[i]) add(i);\n\tSolve(V, 0, (int)V.size() - 1, Mid);\n\tfor (int i = L; i <= Mid ; ++ i) \n\t\tif (!flag[i]) und();\n\n\tvector<int> lv, rv;\n\tlv.clear(), rv.clear();\n\tfor (auto v : V) \n\t\tif (c[v]) lv.PB(v); \n\t\telse rv.PB(v);\n\n\tfor (auto v : rv) {\n\t\tflag[v] = 0;\n\t\tif (v < L) add(v); \n\t}\n\tsolve(lv, L, Mid);\n\tfor (auto v : rv) {\n\t\tflag[v] = 1;\n\t\tif (v < L) und();\n\t}\n\n\tfor (auto v : lv) {\n\t\tflag[v] = 0;\n\t\tif (v <= Mid) add(v);\n\t}\n\tfor (int i = L; i <= Mid + 1 ; ++ i) if (!flag[i]) add(i);\n\tsolve(rv, Mid + 1, R);\n\tfor (int i = L; i <= Mid + 1 ; ++ i) if (!flag[i]) und();\n\tfor (auto v : lv) {\n\t\tflag[v] = 1;\n\t\tif (v <= Mid) und();\n\t}\n}\nsigned main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\tread(n), read(m);\n\tfor (int i = 1, u, v, c; i <= m ; ++ i) read(u), read(v), read(c), E[i] = (Enode){u, v, c, i};\n\tsort(E + 1, E + m + 1, [&](Enode a, Enode b) { return a.c < b.c; });\n\tfor (int i = 1; i <= n ; ++ i) f[i] = i, cnt[i] = 1;\n\tfor (int i = 1; i <= m ; ++ i) flag[i] = 1, V.PB(i);\n\tsolve(V, 1, m + 1);\n\tfor (int i = 1; i <= m ; ++ i) print(Ans[i]), putc(' ');\n\treturn 0;\n}\n```\n",
        "postTime": 1623735568,
        "uid": 32063,
        "name": "fade_away",
        "ccfLevel": 0,
        "title": "CF827D Best Edge Weight"
    }
]