[
    {
        "content": "> [CF504E Misha and LCP on Tree](https://codeforces.com/contest/504/problem/E)\n\n## \u9898\u610f\n\n- \u7ed9\u5b9a\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u6709\u4e00\u4e2a\u5c0f\u5199\u5b57\u6bcd\u3002\n- \u6709 $m$ \u7ec4\u8be2\u95ee\uff0c\u6bcf\u7ec4\u8be2\u95ee\u4e3a\u6811\u4e0a $a \\to b$ \u548c $c \\to d$ \u7ec4\u6210\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00\u3002\n- $n \\le 3 \\times 10^5$\uff0c$m \\le 10^6$\u3002\n\n## \u9898\u89e3\n\n\u9996\u5148\uff0c\u6839\u636e hash \u503c\u5177\u6709\u53ef\u51cf\u6027\uff0c\u53ef\u4ee5\u901a\u8fc7\u9884\u5904\u7406\u6bcf\u4e2a\u70b9\u5230\u6839\u4ee5\u53ca\u6839\u5230\u6bcf\u4e2a\u70b9\u7684 hash \u503c\uff0c$\\mathcal O(1)$ \u6c42\u51fa\u4efb\u610f\u4e00\u6761\u6ca1\u6709\u62d0\u70b9\u7684\u8def\u5f84\u7684 hash \u503c\u3002\n\n\u8003\u8651\u6811\u5256\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06 $a \\to b$ \u548c $c \\to d$ \u7684\u8def\u5f84\u5206\u522b\u62c6\u6210 $\\mathcal O(\\log n)$ \u4e2a\u533a\u95f4\uff0c\u7136\u540e\u6bcf\u6b21\u6d88\u6389\u4e00\u4e2a\u533a\u95f4\u3002\n\n\u5982\u679c\u6d88\u4e0d\u6389\u8fd9\u4e2a\u533a\u95f4\uff0c\u5219\u5728\u8fd9\u4e2a\u533a\u95f4\u4e0a\u4e8c\u5206\u627e\u5230\u7b54\u6848\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n + m \\log n)$\u3002\n\n\u53e6\u5916\uff0c\u5728 CF \u4e0a\u6700\u597d\u5199\u53cc hash\uff0c\u4e14\u4e0d\u80fd\u91c7\u7528\u81ea\u7136\u6ea2\u51fa\uff0c\u5426\u5219\u5927\u6982\u7387\u88ab\u5361\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#define Hash pair <modint, modint>\n\nconst int N = 3e5 + 7, mod = 1e9 + 7;\nconst Hash B = mp((modint)131, (modint)13331);\nint n, m, d[N], f[N], s[N], son[N], dfn[N], rnk[N], top[N], num;\nHash p[N], h1[N], h2[N];\nchar c[N];\nvi e[N];\n\ninline Hash operator + (Hash a, Hash b) {\n\treturn mp(a.fi + b.fi, a.se + b.se);\n}\n\ninline Hash operator - (Hash a, Hash b) {\n\treturn mp(a.fi - b.fi, a.se - b.se);\n}\n\ninline Hash operator * (Hash a, Hash b) {\n\treturn mp(a.fi * b.fi, a.se * b.se);\n}\n\ninline Hash H(bool o, int x, int k) {\n\tif (o) return h2[x-k+1] - h2[x+1] * p[k];\n\treturn h1[x+k-1] - h1[x-1] * p[k];\n}\n\nvoid dfs(int x) {\n\ts[x] = 1;\n\tfor (auto y : e[x])\n\t\tif (y != f[x]) {\n\t\t\tf[y] = x, d[y] = d[x] + 1, dfs(y), s[x] += s[y];\n\t\t\tif (s[y] > s[son[x]]) son[x] = y;\n\t\t}\n}\n\nvoid dfs(int x, int p) {\n\ttop[x] = p, dfn[x] = ++num, rnk[num] = x;\n\tif (son[x]) dfs(son[x], p);\n\tfor (auto y : e[x]) if (y != f[x] && y != son[x]) dfs(y, y);\n}\n\ninline int lca(int x, int y) {\n\twhile (top[x] != top[y]) {\n\t\tif (d[top[x]] > d[top[y]]) swap(x, y);\n\t\ty = f[top[y]];\n\t}\n\tif (d[x] > d[y]) swap(x, y);\n\treturn x;\n}\n\ninline vector <pi> get(int x, int y) {\n\tint z = lca(x, y);\n\tvector <pi> o, w;\n\twhile (d[top[x]] > d[z]) o.pb(mp(x, top[x])), x = f[top[x]];\n\to.pb(mp(x, z));\n\twhile (d[top[y]] > d[z]) w.pb(mp(top[y], y)), y = f[top[y]];\n\tif (y != z) w.pb(mp(son[z], y));\n\twhile (w.size()) o.pb(w.back()), w.pop_back();\n\treturn o;\n}\n\nint main() {\n\trd(n), rds(c, n), p[0] = mp(1, 1), p[1] = B;\n\tfor (int i = 1, x, y; i < n; i++)\n\t\trd(x), rd(y), e[x].pb(y), e[y].pb(x), p[i+1] = p[i] * B;\n\td[1] = 1, dfs(1), dfs(1, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\th1[i] = h1[i-1] * B + mp(c[rnk[i]], c[rnk[i]]),\n\t\th2[n+1-i] = h2[n+2-i] * B + mp(c[rnk[n+1-i]], c[rnk[n+1-i]]);\n\trd(m);\n\twhile (m--) {\n\t\tint a, b, c, d, ans = 0;\n\t\tui s = 0, t = 0;\n\t\trd(a), rd(b), rd(c), rd(d);\n\t\tvector <pi> f = get(a, b), g = get(c, d);\n\t\twhile (s < f.size() && t < g.size()) {\n\t\t\tint df1 = dfn[f[s].fi], df2 = dfn[f[s].se];\n\t\t\tint dg1 = dfn[g[t].fi], dg2 = dfn[g[t].se];\n\t\t\tbool of = df1 > df2, og = dg1 > dg2;\n\t\t\tint lf = (of ? df1 - df2 : df2 - df1) + 1;\n\t\t\tint lg = (og ? dg1 - dg2 : dg2 - dg1) + 1;\n\t\t\tint len = min(lf, lg);\n\t\t\tHash hf = H(of, df1, len);\n\t\t\tHash hg = H(og, dg1, len);\n\t\t\tif (hf == hg) {\n\t\t\t\tif (len == lf) ++s;\n\t\t\t\telse f[s].fi = rnk[df1+(of?-1:1)*len];\n\t\t\t\tif (len == lg) ++t;\n\t\t\t\telse g[t].fi = rnk[dg1+(og?-1:1)*len];\n\t\t\t\tans += len;\n\t\t\t} else {\n\t\t\t\tint l = 1, r = len;\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tint mid = (l + r) >> 1;\n\t\t\t\t\thf = H(of, df1, mid);\n\t\t\t\t\thg = H(og, dg1, mid);\n\t\t\t\t\tif (hf == hg) l = mid + 1;\n\t\t\t\t\telse r = mid;\n\t\t\t\t}\n\t\t\t\tans += l - 1; break;\n\t\t\t}\n\t\t}\n\t\tprint(ans);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1579178336,
        "uid": 100544,
        "name": "xht",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF504E \u3010Misha and LCP on Tree\u3011"
    },
    {
        "content": "[\u53ef\u80fd\u66f4\u597d\u7684\u4f53\u9a8c](https://mrsrz.github.io/2019/12/17/CF504E/)\n\n\u5e8f\u5217\u4e0a\u7684\u95ee\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u4e8c\u5206+\u54c8\u5e0c\u7684\u65b9\u6cd5\uff0c\u5728 $O(n+m\\log n)$ \u7684\u65f6\u95f4\u5185\u89e3\u51b3\u95ee\u9898\u3002\u5728\u77e5\u9053\u4e24\u4e2a\u4f4d\u7f6e\u7684\u524d\u7f00\u6216\u540e\u7f00\u54c8\u5e0c\u503c\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ef\u4ee5 $O(1)$ \u8ba1\u7b97\u4e2d\u95f4\u8fd9\u4e00\u6bb5\u7684\u54c8\u5e0c\u503c\u3002\n\n\u73b0\u5728\u95ee\u9898\u642c\u5230\u4e86\u6811\u4e0a\uff0c\u4f46\u5bf9\u4e8e\u6811\u4e0a\u7684\u4e00\u6761\u8def\u5f84\uff0c\u6211\u4eec\u4ecd\u7136\u53ef\u4ee5 $O(1)$ \u5f97\u5230\u5b83\u7684\u54c8\u5e0c\u503c\u3002\u5177\u4f53\u5c31\u662f\u5206\u522b\u7ef4\u62a4\u5230\u6839\u8def\u5f84\u7684\u6b63\u4e32\u54c8\u5e0c\u503c\u548c\u53cd\u4e32\u54c8\u5e0c\u503c\uff08$O(n)$ \u9884\u5904\u7406\uff09\uff0c\u7136\u540e\u53ef\u4ee5\u901a\u8fc7\u5230\u6839\u7684\u524d\u7f00/\u540e\u7f00 $O(1)$ \u8ba1\u7b97\u4e00\u6761\u5411\u6839\u8def\u5f84\u7684\u54c8\u5e0c\u503c\u3002\u6211\u4eec\u5728 LCA \u5904\u65ad\u5f00\uff0c\u8ba1\u7b97\u4e24\u6bb5\u54c8\u5e0c\u503c\u7136\u540e $O(1)$ \u5408\u5e76\u5c31\u662f\u8be5\u8def\u5f84\u7684\u54c8\u5e0c\u503c\u3002\n\n\u5728\u6811\u4e0a\u6c42\u54c8\u5e0c\u503c\u7684\u590d\u6742\u5ea6\u5e76\u6ca1\u6709\u53d8\u5dee\uff0c\u6240\u4ee5\u4ecd\u7136\u53ef\u4ee5 $O(\\log n)$ \u56de\u7b54\u4e00\u6b21\u8be2\u95ee\u3002\n\n\u7531\u4e8e\u6211\u4eec\u8981\u4e8c\u5206 LCP \u957f\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u77e5\u9053\u5bf9\u6bcf\u4e2a\u957f\u5ea6\uff0c\u5176\u7ed3\u5c3e\u7684\u70b9\u7684\u4f4d\u7f6e\uff0c\u76f8\u5f53\u4e8e\u4e00\u4e2a\u6c42 $k$ \u7ea7\u7956\u5148\u7684\u95ee\u9898\u3002\u8fd9\u91cc\u8981\u6c42 $m\\log n$ \u6b21\uff0c\u6240\u4ee5\u7528\u500d\u589e\u7684\u8bdd\u590d\u6742\u5ea6\u5c31\u4f1a\u591a $\\log n$\u3002\n\n\u4e0d\u96be\u60f3\u5230\u7528\u957f\u94fe\u5256\u5206\u505a\u5230 $O(n\\log n)$ \u9884\u5904\u7406\uff0c$O(1)$ \u67e5\u8be2 $k$ \u7ea7\u7956\u5148\u3002\n\n\u8fd9\u6837\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O((n+m)\\log n)$\u3002\n\n\u9700\u8981\u6ce8\u610f\u5e38\u6570\u8fd8\u6709\u4e0d\u8981\u88ab\u5361\u54c8\u5e0c\uff0c\u53cc\u54c8\u5e0c\u6bd4\u8f83\u7a33\u3002\u8fd9\u91cc\u7531\u4e8e $m>n$\uff0c\u6240\u4ee5\u4f7f\u7528 ST \u8868\u7684 $O(n\\log n)$ \u9884\u5904\u7406 $O(1)$ \u67e5\u8be2\uff0c\u5e38\u6570\u4f1a\u66f4\u5c0f\u3002~~\u4e0d\u8981\u7528\u500d\u589e\u6c42 LCA \u90a3\u4e2a\u6162\u6b7b\u4e86~~\u3002\n\n## Code\uff1a\n\n```cpp\n#include<cstdio>\n#include<ctime>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\n#define lg2(x)(31-__builtin_clz(x))\nconst int md1=1004535809,md2=167772161,N=3e5+5;\nint base1,base2;\nint _1[N],_2[N],n,m;\nint i1[N],i2[N];\nchar s[N];\nint head[N],cnt;\nint mxd[N],toph[N],tail[N],sonh[N],len[N],fa[N],F[19][N],dep[N],idx,dfn[N];\nint*up[N],*down[N];\nint st[20][N<<1];\ninline int Inv(int a,const int&md){\n\tint ret=1,b=md-2;\n\tfor(;b;b>>=1,a=(LL)a*a%md)if(b&1)ret=(LL)ret*a%md;\n\treturn ret;\n}\nstruct edge{\n\tint to,nxt;\n}e[N<<1];\nstruct data{\n\tint s1,s2;\n\tint len;\n\tinline void push_front(char c){s1=(s1+(LL)c*_1[len])%md1,s2=(s2+(LL)c*_2[len++])%md2;}\n\tinline void push_back(char c){s1=((LL)s1*base1+c)%md1,s2=((LL)s2*base2+c)%md2,++len;}\n\tinline data operator+(const data&rhs)const{return(data){((LL)s1*_1[rhs.len]+rhs.s1)%md1,((LL)s2*_2[rhs.len]+rhs.s2)%md2,len+rhs.len};}\n\tinline bool operator==(const data&rhs)const{return s1==rhs.s1&&s2==rhs.s2&&len==rhs.len;}\n}a[N],b[N];\nvoid dfs(int now){\n\tst[0][dfn[now]=++idx]=now;\n\tsonh[now]=0,mxd[now]=dep[now];\n\ta[now]=a[fa[now]],b[now]=b[fa[now]];\n\ta[now].push_back(s[now]),b[now].push_front(s[now]);\n\tfor(int i=head[now];i;i=e[i].nxt)\n\tif(!dep[e[i].to]){\n\t\tdep[e[i].to]=dep[now]+1;\n\t\tfa[e[i].to]=F[0][e[i].to]=now;\n\t\tdfs(e[i].to);\n\t\tst[0][++idx]=now;\n\t\tif(mxd[e[i].to]>mxd[now])mxd[now]=mxd[e[i].to],sonh[now]=e[i].to;\n\t}\n}\nvoid dfs2(int now){\n\ttail[toph[now]]=now,len[toph[now]]=dep[now]-dep[toph[now]]+1;\n\tif(sonh[now])toph[sonh[now]]=toph[now],dfs2(sonh[now]);\n\tfor(int i=head[now];i;i=e[i].nxt)\n\tif(dep[e[i].to]>dep[now]&&e[i].to!=sonh[now])dfs2(toph[e[i].to]=e[i].to);\n}\ninline int kfa(int x,int k){\n\tif(dep[x]<=k)return 0;\n\tif(k==0)return x;\n\tconst int lg=lg2(k);\n\tx=F[lg][x],k-=1<<lg;\n\tif(!k)return x;\n\tconst int dlt=dep[x]-dep[toph[x]];\n\tif(dlt>=k)\n\treturn down[toph[x]][dlt-k];\n\treturn up[toph[x]][k-dlt];\n}\ninline int LCA(int x,int y){\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tx=dfn[x],y=dfn[y];\n\tint lg=lg2(y-x+1);\n\tint a=st[lg][x],b=st[lg][y-(1<<lg)+1];\n\treturn(dep[a]<dep[b])?a:b;\n}\nvoid init(){\n\tfor(int i=1;i<19;++i)\n\tfor(int j=1;j<=n;++j)\n\tF[i][j]=F[i-1][F[i-1][j]];\n\tfor(int i=1;i<=n;++i)\n\tif(toph[i]==i){\n\t\tint h=len[i];\n\t\tup[i]=new int[h+2];\n\t\tdown[i]=new int[h+2];\n\t\t*up[i]=*down[i]=i;\n\t\tfor(int j=1,nw=fa[i];j<=h&&nw;++j,nw=fa[nw])\n\t\tup[i][j]=nw;\n\t\tfor(int j=1,nw=sonh[i];j<=h&&nw;++j,nw=sonh[nw])\n\t\tdown[i][j]=nw;\n\t}\n\tfor(int i=1;i<20;++i)\n\tfor(int j=1;j<=2*n;++j){\n\t\tint x=st[i-1][j],y=st[i-1][j+(1<<i-1)];\n\t\tst[i][j]=(dep[x]<dep[y])?x:y;\n\t}\n}\ninline data get(int u,int v){\n\tconst data&x=b[u],&y=b[v];\n\treturn(data){(LL)(x.s1-y.s1+md1)*i1[y.len]%md1,(LL)(x.s2-y.s2+md2)*i2[y.len]%md2,x.len-y.len};\n}\ninline data get_(int u,int v){\n\tconst data&x=a[u],&y=a[v];\n\treturn(data){(y.s1-(LL)x.s1*_1[y.len-x.len]%md1+md1)%md1,(y.s2-(LL)x.s2*_2[y.len-x.len]%md2+md2)%md2,y.len-x.len};\n}\nint main(){\n\tsrand(time(0));\n\tbase1=rand()%100+200,base2=rand()%300+400;\n\tscanf(\"%d%s\",&n,s+1);\n\t_1[0]=_2[0]=i1[0]=i2[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t_1[i]=(LL)_1[i-1]*base1%md1,_2[i]=(LL)_2[i-1]*base2%md2;\n\ti1[1]=Inv(base1,md1),i2[1]=Inv(base2,md2);\n\tfor(int i=2;i<=n;++i)\n\ti1[i]=(LL)i1[i-1]*i1[1]%md1,i2[i]=(LL)i2[i-1]*i2[1]%md2;\n\tfor(int i=1;i<n;++i){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\te[++cnt]=(edge){v,head[u]},head[u]=cnt;\n\t\te[++cnt]=(edge){u,head[v]},head[v]=cnt;\n\t}\n\tdfs(dep[1]=1),dfs2(toph[1]=1);\n\tinit();\n\tfor(scanf(\"%d\",&m);m--;){\n\t\tint u1,v1,u2,v2;\n\t\tscanf(\"%d%d%d%d\",&u1,&v1,&u2,&v2);\n\t\tint L1=LCA(u1,v1),L2=LCA(u2,v2);\n\t\tconst int D1=dep[u1]+dep[v1]-2*dep[L1]+1,D2=dep[u2]+dep[v2]-2*dep[L2]+1;\n\t\tint l=1,r=min(D1,D2),ans=0;\n\t\twhile(l<=r){\n\t\t\tconst int mid=l+r>>1;\n\t\t\tconst data _x=dep[u1]-mid+1>=dep[L1]?get(u1,kfa(u1,mid)):get(u1,L1)+get_(fa[L1],kfa(v1,D1-mid));\n\t\t\tconst data _y=dep[u2]-mid+1>=dep[L2]?get(u2,kfa(u2,mid)):get(u2,L2)+get_(fa[L2],kfa(v2,D2-mid));\n\t\t\tif(_x==_y)l=(ans=mid)+1;else r=mid-1;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1576596275,
        "uid": 6813,
        "name": "mrsrz",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF504E \u3010Misha and LCP on Tree\u3011"
    },
    {
        "content": "~~1A\u771f\u8212\u670d\u3002~~  \n\u559c\u95fb\u4e50\u89c1\u7684\u6811\u94fe\u5256\u5206+SA\u3002  \n\u4e00\u4e2a\u521d\u6b65\u7684\u60f3\u6cd5\u5c31\u662f\u7528\u6811\u94fe\u5256\u5206\uff0c\u628a\u4e24\u4e2a\u5b57\u7b26\u4e32\u6c42\u51fa\u7136\u540ehash+\u4e8c\u5206\u6c42lcp\u3002\u3002\u3002\u4e0d\u5b58\u5728\u7684\u3002  \n\u56e0\u4e3a\u8003\u8651\u5230\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u6709\u5e8f\u7684\uff0c\u6211\u4eec\u9700\u8981\u628a\u6bcf\u4e00\u6761\u91cd\u94fe\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u548c\u8fd9\u4e2a\u91cd\u94fe\u53cd\u8fc7\u6765\u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u62fc\u8d77\u6765\u6784\u6210\u4e00\u4e2a\u65b0\u7684\u5b57\u7b26\u4e32\u3002\u6211\u4eec\u7528\u6811\u94fe\u5256\u5206\u62fc\u51fa\u4e24\u4e2a\u5b57\u7b26\u4e32\u3002\u7528\u6811\u5256\u62fc\u51fa\u7684\u8fd9\u4e24\u4e2a\u5b57\u7b26\u4e32\uff0c\u4e00\u5b9a\u662f\u91cd\u94fe\u62fc\u6210\u7684\u5b57\u7b26\u4e32\u4e0a\u4e00\u4e2a\u4e00\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u8bb0\u5f55\u8fd9\u4e9b\u533a\u95f4\u7684\u5de6\u53f3\u7aef\u70b9\u3002\u7136\u540e\u6211\u4eec\u5c31\u662f\u8981\u4e00\u4e2a\u4e00\u4e2a\u5904\u7406\u533a\u95f4\u3002\u6c42\u4e24\u4e2a\u533a\u95f4\u5bf9\u5e94\u5b57\u7b26\u4e32\u7684lcp\uff0c\u6211\u4eec\u76f4\u63a5\u4e0aSA+ST\u8868\u5c31\u884c\uff0c\u6c42\u51falcp\u4e4b\u540e\u5c31\u5728\u8fd9\u4e9b\u533a\u95f4\u4e0a\u5206\u60c5\u51b5\u8ba8\u8bba\uff0c\u7136\u540e\u5c31\u7ed3\u675f\u4e86\u3002  \n\u5177\u4f53\u770b\u4ee3\u7801\uff0c~~\u592a\u4e11\u4e86\u4e5f\u770b\u4e0d\u51fa\u6765\u4ec0\u4e48\u3002~~\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=601000;\nint cnt,head[N];\nint size[N],fa[N],dep[N],dfn[N],top[N],tot,son[N];\nint s[N],id[N][2],cn,Top[N];\nint sa[N],x[N],y[N],len,rk[N],height[N],m,mn[N][20],c[N];\nint L[N][2],R[N][2],NUM[N],Num[N],n;\nchar S[N];\nstruct edge{\n\tint to,nxt;\n}e[N];\nvoid add(int u,int v){\n\tcnt++;\n\te[cnt].nxt=head[u];\n\te[cnt].to=v;\n\thead[u]=cnt;\n}\nvoid dfs1(int u,int f){\n\tsize[u]=1;\n\tfa[u]=f;\n\tdep[u]=dep[f]+1;\n\tint maxson=-1;\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==f)continue;\n\t\tdfs1(v,u);\n\t\tif(size[v]>maxson){\n\t\t\tmaxson=size[v];\n\t\t\tson[u]=v;\n\t\t}\n\t\tsize[u]+=size[v];\n\t}\n}\nvoid dfs2(int u,int tp){\n\tdfn[u]=++tot;\n\ttop[u]=tp;\n\tif(son[u])dfs2(son[u],tp);\n\tfor(int i=head[u];i;i=e[i].nxt){\n\t\tint v=e[i].to;\n\t\tif(v==fa[u]||v==son[u])continue;\n\t\tTop[++cn]=v;\n\t\tdfs2(v,v);\n\t}\n}\nvoid build(int u){\n\ts[++len]=S[u];\n\tid[dfn[u]][0]=len;\n\tif(son[u]==0){\n\t\tid[dfn[u]][0]=len;\n\t\ts[++len]=S[u];\n\t\tid[dfn[u]][1]=len;\n\t\treturn;\n\t}\n\tbuild(son[u]);\n\ts[++len]=S[u];\n\tid[dfn[u]][1]=len;\n}\nvoid get_sa(){\n\tfor(int i=1;i<=len;i++)c[x[i]=s[i]]++;\n\tfor(int i=1;i<=m;i++)c[i]+=c[i-1];\n\tfor(int i=len;i>=1;i--)sa[c[x[i]]--]=i;\n\tfor(int k=1;k<=len;k<<=1){\n\t\tint num=0;\n\t\tfor(int i=len-k+1;i<=len;i++)y[++num]=i;\n\t\tfor(int i=1;i<=len;i++)if(sa[i]>k)y[++num]=sa[i]-k;\n\t\tfor(int i=1;i<=m;i++)c[i]=0;\n\t\tfor(int i=1;i<=len;i++)c[x[i]]++;\n\t\tfor(int i=1;i<=m;i++)c[i]+=c[i-1];\n\t\tfor(int i=len;i>=1;i--)sa[c[x[y[i]]]--]=y[i],y[i]=0;\n\t\tfor(int i=1;i<=len;i++)swap(x[i],y[i]);\n\t\tx[sa[1]]=1;num=1;\n\t\tfor(int i=2;i<=len;i++)\n\t\t\tx[sa[i]]=(y[sa[i]]==y[sa[i-1]]&&y[sa[i]+k]==y[sa[i-1]+k])?num:++num;\n\t\tif(num==len)break;\n\t\tm=num;\n\t}\n}\nvoid get_height(){\n\tint k=0;\n\tfor(int i=1;i<=len;i++)rk[sa[i]]=i;\n\tfor(int i=1;i<=len;i++){\n\t\tif(rk[i]==1)continue;\n\t\tif(k)k--;\n\t\tint j=sa[rk[i]-1];\n\t\twhile(i+k<=len&&j+k<=len&&s[i+k]==s[j+k])k++;\n\t\theight[rk[i]]=k;\n\t}\n}\nvoid pre_work(){\n\tfor(int i=1;i<=len;i++)mn[i][0]=height[i];\n\tint Len=log2(len);\n\tfor(int j=1;j<=Len;j++)\n\t\tfor(int i=1;i+(1<<j)-1<=len;i++)\n\t\t\tmn[i][j]=min(mn[i][j-1],mn[i+(1<<j-1)][j-1]); \n}\nint get_lcp(int l,int r){\n\tif(l>r)swap(l,r);\n\tl++;\n\tif(l>r)return 1e9;\n\tint Len=log2(r-l+1);\n\treturn min(mn[l][Len],mn[r-(1<<Len)+1][Len]);\n}\nvoid work(int x,int y,int k){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]>dep[top[y]]){\n\t\t\tNum[k]++;\n\t\t\tL[Num[k]][k]=id[dfn[x]][1];\n\t\t\tR[Num[k]][k]=id[dfn[top[x]]][1];\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\telse{\n\t\t\tNUM[k]--;\n\t\t\tL[NUM[k]][k]=id[dfn[top[y]]][0];\n\t\t\tR[NUM[k]][k]=id[dfn[y]][0];\n\t\t\ty=fa[top[y]];\n\t\t}\n\t}\n\tif(dep[x]>dep[y]){\n\t\tNum[k]++;\n\t\tL[Num[k]][k]=id[dfn[x]][1];\n\t\tR[Num[k]][k]=id[dfn[y]][1];\n\t}\n\telse{\n\t\tNUM[k]--;\n\t\tL[NUM[k]][k]=id[dfn[x]][0];\n\t\tR[NUM[k]][k]=id[dfn[y]][0];\n\t}\n}\nvoid calc(){\n\tint now0=1,now1=1;\n\tint tmp=0;\n\twhile(now0<=n&&now1<=n){\n\t\tif(now0>Num[0]&&now0<NUM[0])now0=NUM[0];\n\t\tif(now1>Num[1]&&now1<NUM[1])now1=NUM[1];\n\t\tif(now0>n||now1>n)break;\n\t\tint LL=min(min(R[now0][0]-L[now0][0]+1,R[now1][1]-L[now1][1]+1),get_lcp(rk[L[now0][0]],rk[L[now1][1]]));\n\t\tL[now0][0]=L[now0][0]+LL;\n\t\tL[now1][1]=L[now1][1]+LL;\n\t\ttmp+=LL;\n\t\tif(L[now0][0]<=R[now0][0]&&L[now1][1]<=R[now1][1])break;\n\t\tif(L[now0][0]>R[now0][0])now0++;\n\t\tif(L[now1][1]>R[now1][1])now1++;\n\t}\n\tprintf(\"%d\\n\",tmp);\n}\nint read(){\n\tint sum=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){sum=sum*10+ch-'0';ch=getchar();}\n\treturn sum*f;\n}\nint main(){\n\tn=read();\n\tscanf(\"%s\",S+1);\n\tfor(int i=1;i<n;i++){\n\t\tint u=read(),v=read();\n\t\tadd(u,v);add(v,u);\n\t}\n\tdfs1(1,0);cn=1;Top[1]=1;dfs2(1,1);\n\tfor(int i=1;i<=cn;i++)build(Top[i]);\n\tm=122;\n\tget_sa();get_height();pre_work();\n\tm=read();\n\tint a,b,c,d;\n\twhile(m--){\n\t\ta=read();b=read();\n\t\tc=read();d=read();\n\t\tNum[0]=Num[1]=0;\n\t\tNUM[0]=NUM[1]=n+1;\n\t\twork(a,b,0);work(c,d,1);\n\t\tcalc();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1546510811,
        "uid": 52173,
        "name": "xudaxia",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF504E \u3010Misha and LCP on Tree\u3011"
    },
    {
        "content": "\u8fd9\u9898\u7684\u601d\u7ef4\u96be\u5ea6\u5176\u5b9e\u4e0d\u7b97\u592a\u9ad8\uff0c\u8bc4\u4e86\u4e2a \\*3000 \u53ef\u80fd\u662f\u56e0\u4e3a\u6bd4\u8f83\u96be\u5199\u4ee5\u53ca\u5361\u5e38\u5427\u3002\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a\u5b57\u7b26\u4e32\u54c8\u5e0c\u3001$O(n\\log n)-O(1)$ LCA\u3001\u957f\u94fe\u5256\u5206\u3001\u6811\u4e0a\u5dee\u5206\u3002\n\n\u56de\u60f3\u4e00\u4e0b\uff0c\u5728\u6c42\u5e8f\u5217 LCP \u7684\u65f6\u5019\u6211\u4eec\u91c7\u7528\u4e86\u4e8c\u5206\u7684\u65b9\u6cd5\uff0c\u8fd9\u91cc\u4e5f\u53ef\u4ee5\u5e94\u7528\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u6211\u4eec\u4e8c\u5206 LCP \u7684\u957f\u5ea6 $k$\uff0c\u7136\u540e\u5728\u4e24\u6761\u8def\u5f84\u4e0a\u5206\u522b\u53d6\u51fa\u524d $k$ \u4e2a\u8282\u70b9\u8fde\u6210\u7684\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c $h_{ab}$ \u548c $h_{cd}$\uff0c\u7136\u540e\u6bd4\u8f83\u4e24\u8005\u662f\u5426\u76f8\u540c\u5373\u53ef\u3002\n\n\u7136\u540e\u6211\u4eec\u5c31\u8981\u5728 $O(1)$ \u65f6\u95f4\u5185\u5b8c\u6210\u4e0a\u8ff0\u8fc7\u7a0b\u3002\n\n\u9996\u5148\uff0c\u63d0\u53d6\u4e00\u6bb5\u8def\u5f84\u8fde\u6210\u7684\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u6811\u4e0a\u5dee\u5206\u5b8c\u6210\u3002\u5177\u4f53\u6765\u8bb2\uff0c\u6211\u4eec\u5bf9\u4e00\u4e2a\u8282\u70b9 $v$ \u7ef4\u62a4\u4e24\u4e2a\u54c8\u5e0c\u503c $u_v$ \u548c $d_v$\uff0c\u5206\u522b\u8868\u793a\u8def\u5f84 $v\\rightarrow 1$ \u8fde\u6210\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c\u548c $1\\rightarrow v$ \u8fde\u6210\u5b57\u7b26\u4e32\u7684\u54c8\u5e0c\u503c\u3002\u7136\u540e\u63d0\u53d6\u8def\u5f84 $x\\rightarrow y$ \u7684\u65f6\u5019\u5206\u4e3a $x\\rightarrow \\operatorname{lca}(x,y)$ \u548c $\\operatorname{lca}(x,y)\\rightarrow y$\u3002\u7b2c\u4e00\u6bb5\u7684\u54c8\u5e0c\u503c $h_1=\\dfrac{u_{x}-u_{f_{\\operatorname{lca}(x,y)}}}{B^{dep_{\\operatorname{lca}(x,y)}-1}}$\uff0c\u7b2c\u4e8c\u6bb5\u7684\u54c8\u5e0c\u503c $h_2=d_y-d_{\\operatorname{lca}(x,y)}\\cdot B^{\\operatorname{dist}(y,\\operatorname{lca}(x,y))}$\uff0c\u8def\u5f84\u54c8\u5e0c\u503c\u5c31\u662f $h_1\\cdot B^{\\operatorname{dist}(y,\\operatorname{lca}(x,y))}+h_2$\u3002\u901a\u8fc7\u63d0\u524d\u9884\u5904\u7406 $B^x$ \u548c $B^{-x}$ \u7684\u503c\uff0c\u8fbe\u5230\u590d\u6742\u5ea6 $O(1)$\u3002\n\n\u5176\u4e2d $\\operatorname{dist}(x,y)$ \u8868\u793a $x,y$ \u4e24\u70b9\u4e4b\u95f4\u7684\u8ddd\u79bb\u3002\n\n\u5f53\u7136\u8fd9\u662f $x,y$ \u6ca1\u6709\u4efb\u4f55\u4e00\u4e2a\u5c5e\u4e8e\u53e6\u4e00\u4e2a\u7684\u5b50\u6811\u7684\u60c5\u51b5\u3002\u5982\u679c\u6709\u8fd9\u79cd\u60c5\u51b5\uff0c\u5904\u7406\u65b9\u6cd5\u4e5f\u662f\u7c7b\u4f3c\u7684\uff0c\u76f4\u63a5\u8fd4\u56de $h_1$ \u6216 $h_2$ \u5373\u53ef\u3002\n\n\u7136\u540e\u6211\u4eec\u6765\u8003\u8651\u600e\u4e48\u63d0\u53d6\u8def\u5f84\u3002\n\n\u9996\u5148\u6211\u4eec\u5224\u65ad\u524d $k$ \u4e2a\u70b9\u4f1a\u4e0d\u4f1a\u8de8\u8d8a $\\operatorname{lca}$\u3002\u5982\u679c\u4f1a\uff0c\u5219\u8def\u5f84\u4e3a $x\\rightarrow f(y,\\operatorname{dist}(x,y)-k)$\uff1b\u5426\u5219\u8def\u5f84\u4e3a $x\\rightarrow f(x,k-1)$\u3002\u5176\u4e2d $f(x,k)$ \u8868\u793a $x$ \u7684 $k$ \u7ea7\u7956\u5148\u3002\n\n\u6240\u4ee5\u73b0\u5728\u53ea\u8981\u957f\u94fe\u5256\u5206\u6c42 $k$ \u7ea7\u7956\u5148\u5c31\u53ef\u4ee5\u505a\u5230 $O(1)$\uff0c\u5728\u5916\u9762\u5148\u6c42\u597d $\\operatorname{lca}$ \u662f $O(\\log n)$ \u7684\uff0c\u4f46\u662f\u5e76\u4e0d\u4f1a\u548c\u4e8c\u5206\u7684 $\\log$ \u4e58\u5230\u4e00\u8d77\uff0c\u6240\u4ee5\u603b\u590d\u6742\u5ea6\u5c31\u662f $O((n+m)\\log n)$ \u7684\u3002\n\n\u6240\u4ee5\u8fd9\u9898\u5c31\u505a\u5b8c\u4e86\u2014\u2014\u5417\uff1f\n\n\u4f60\u5199\u597d\u4e86\u4ea4\u4e0a\u53bb\uff0c\u5c31\u6109\u5feb\u5730\u88ab\u5361 T \u4e86 QAQ\n\n\u6211\u4eec\u5206\u51fa\u6765\u6d4b\u4e00\u4e0b\uff0c\u5c31\u4f1a\u53d1\u73b0\u5149\u662f\u6c42 $10^6$ \u6b21 lca \u7684\u8017\u65f6\u5c31\u4f1a\u8fbe\u5230\u6050\u6016\u7684 3.5s\u2026\u2026\n\n\u4e8e\u662f\u6211\u4eec\u62ff\u6389\u500d\u589e lca\uff0c\u6362\u4e0a ST \u8868\u7684 $O(n\\log n)-O(1)$ lca\uff0c\u7136\u540e\u52a0\u4e0a\u53d6\u6a21\u4f18\u5316\uff08\u8fd9\u9898\u91cc\u9762\u53d6\u6a21\u4f18\u5316\u6548\u679c\u6781\u4e3a\u660e\u663e\uff0c\u52a0\u4e0a\u4e4b\u540e\u53ef\u4ee5\u8fbe\u5230 6.5s\uff09\uff0c\u5c31\u53ef\u4ee5\u8fc7\u8fd9\u9898\u4e86\u3002\n\n\u6ce8\u610f\u5b9e\u73b0\u7684\u65f6\u5019\u4f7f\u7528\u53cc\u54c8\u5e0c\uff0c\u907f\u514d\u88ab\u53c9\u3002\n\n\u5176\u5b9e\u53cc\u54c8\u5e0c\u7528 $10^9+7$ \u548c $10^9+9$ \u4e5f\u662f\u5f88\u5371\u9669\u7684\u2026\u2026\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e9b\u5c0f\u4f17\u4e00\u70b9\u7684\u6a21\u6570\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1 << 21], *p1 = buf, *p2 = buf;\n\ninline int qread() {\n\tregister char c = getchar();\n\tregister int x = 0, f = 1;\n\twhile (c < '0' || c > '9') {\n\t\tif (c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9') {\n\t\tx = (x << 3) + (x << 1) + c - 48;\n\t\tc = getchar();\n\t}\n\treturn x * f;\n}\n\ninline int Abs(const int& x) {return (x > 0 ? x : -x);}\ninline int Max(const int& x, const int& y) {return (x > y ? x : y);}\ninline int Min(const int& x, const int& y) {return (x < y ? x : y);}\n\nconst int N = 300005;\nconst long long mod[2] = {1000000007, 1000000009};\nstruct Edge {\n\tint to, nxt;\n\tEdge() {\n\t\tnxt = -1;\n\t}\n};\nEdge e[N << 1];\nint n, m, hd[N], pnt, fa[N][25], dep[N], maxdep[N], son[N], top[N], highbit[N], st[1000005][25], dfn[N], _time, _log[1000005];\nlong long uphash[N][2], dnhash[N][2], pow26[N][2], powInv26[N][2];\nvector <int> up[N], dn[N];\nchar s[N];\n\ninline long long Power(long long x, long long y, long long mod) {\n\tregister long long ans = 1;\n\twhile (y) {\n\t\tif (y & 1) ans = ans * x % mod;\n\t\tx = x * x % mod;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\ninline void AddEdge(int u, int v) {\n\te[++pnt].to = v;\n\te[pnt].nxt = hd[u];\n\thd[u] = pnt;\n}\n\ninline void Read() {\n\tn = qread();\n\thighbit[0] = -1;\n\tfor (register int i = 1;i <= n;i++) {\n\t\ts[i] = getchar();\n\t\twhile (s[i] < 'a' || s[i] > 'z') s[i] = getchar();\n\t\thighbit[i] = highbit[i >> 1] + 1;\n\t}\n\tfor (register int i = 1;i < n;i++) {\n\t\tregister int u = qread(), v = qread();\n\t\tAddEdge(u, v);\n\t\tAddEdge(v, u);\n\t}\n}\n\ninline void Calc26() {\n\tpow26[0][0] = pow26[0][1] = 1;\n\tpowInv26[0][0] = powInv26[0][1] = 1;\n\tpowInv26[1][0] = Power(26ll, mod[0] - 2, mod[0]);\n\tpowInv26[1][1] = Power(26ll, mod[1] - 2, mod[1]);\n\tpow26[1][0] = pow26[1][1] = 26;\n\tfor (register int i = 2;i <= n;i++) {\n\t\tfor (register int j = 0;j < 2;j++) {\n\t\t\tpow26[i][j] = pow26[i - 1][j] * 26ll % mod[j];\n\t\t\tpowInv26[i][j] = powInv26[i - 1][j] * powInv26[1][j] % mod[j];\n\t\t}\n\t}\n}\n\ninline long long Add(long long x, long long y, long long mod) {\n\treturn (x + y < mod ? x + y : x + y - mod);\n}\n\ninline long long Minus(long long x, long long y, long long mod) {\n\treturn (x < y ? x - y + mod : x - y);\n}\n\ninline void Dfs1(int u) {\n\t_time++;\n\tst[_time][0] = u;\n\tdfn[u] = _time;\n\tfor (register int j = 0;j < 2;j++) {\n\t\tuphash[u][j] = Add(uphash[fa[u][0]][j], pow26[dep[u] - 1][j] * (s[u] - 'a') % mod[j], mod[j]);\n\t\tdnhash[u][j] = Add(dnhash[fa[u][0]][j] * 26ll % mod[j], s[u] - 'a', mod[j]);\n\t}\n\tfor (register int i = hd[u];~i;i = e[i].nxt) {\n\t\tif (e[i].to != fa[u][0]) {\n\t\t\tfa[e[i].to][0] = u;\n\t\t\tdep[e[i].to] = dep[u] + 1;\n\t\t\tDfs1(e[i].to);\n\t\t\t_time++;\n\t\t\tst[_time][0] = u;\n\t\t\tif (maxdep[e[i].to] > maxdep[u]) {\n\t\t\t\tmaxdep[u] = maxdep[e[i].to];\n\t\t\t\tson[u] = e[i].to;\n\t\t\t}\n\t\t}\n\t}\n\tmaxdep[u]++;\n}\n\ninline void Dfs2(int u, int tp) {\n\ttop[u] = tp;\n\tdn[tp].push_back(u);\n\tif (son[u]) Dfs2(son[u], tp);\n\tfor (register int i = hd[u];~i;i = e[i].nxt) {\n\t\tif (e[i].to != fa[u][0] && e[i].to != son[u]) Dfs2(e[i].to, e[i].to);\n\t}\n}\n\ninline void Prefix() {\n\tfor (register int j = 1;j <= 20;j++) {\n\t\tfor (register int i = 1;i <= n;i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n\t}\n\tfor (register int i = 1;i <= n;i++) {\n\t\tregister int siz = dn[i].size(), u = i;\n\t\tfor (register int j = 0;j < siz;j++) {\n\t\t\tup[i].push_back(u);\n\t\t\tu = fa[u][0];\n\t\t}\n\t}\n\t//printf(\"_time=%d\\n\", _time);\n\tfor (register int j = 1;j <= 20;j++) {\n\t\tfor (register int i = 1;i <= _time;i++) {\n\t\t\tif (i + (1 << j) - 1 > _time) break;\n\t\t\tif (dep[st[i][j - 1]] < dep[st[i + (1 << j - 1)][j - 1]]) st[i][j] = st[i][j - 1];\n\t\t\telse st[i][j] = st[i + (1 << j - 1)][j - 1];\n\t\t\t//printf(\"%d %d %d\\n\", i, j, st[i][j]);\n\t\t}\n\t}\n\tfor (register int i = 2;i <= _time;i++) _log[i] = _log[i >> 1] + 1;\n}\n\ninline int Up(int u, int k) {\n\tif (!k) return u;\n\tu = fa[u][highbit[k]];\n\tk -= 1 << highbit[k];\n\tif (k >= dep[u] - dep[top[u]]) return up[top[u]][k - dep[u] + dep[top[u]]];\n\telse return dn[top[u]][dep[u] - dep[top[u]] - k];\n}\n\ninline int Lca(int u, int v) {\n\tif (dfn[u] > dfn[v]) swap(u, v);\n\tregister int k = _log[dfn[v] - dfn[u] + 1];\n\tif (dep[st[dfn[u]][k]] < dep[st[dfn[v] - (1 << k) + 1][k]]) return st[dfn[u]][k];\n\telse return st[dfn[v] - (1 << k) + 1][k];\n}\n\ninline pair <pair <int, int>, int> Path(int u, int v, int l, int k) {\n\tif (dep[u] - dep[l] + 1 >= k) {\n\t\tregister int tmp = Up(u, k - 1);\n\t\treturn make_pair(make_pair(u, tmp), tmp);\n\t} else return make_pair(make_pair(u, Up(v, dep[u] + dep[v] - (dep[l] << 1) + 1 - k)), l);\n}\n\n//u -> v\ninline long long Hashval(int u, int v, int l, int id) {\n\tif (v == l) return Minus(uphash[u][id], uphash[fa[l][0]][id], mod[id]) * powInv26[dep[fa[l][0]]][id] % mod[id];\n\telse if (u == l) return Minus(dnhash[v][id], dnhash[fa[l][0]][id] * pow26[dep[v] - dep[l] + 1][id] % mod[id], mod[id]);\n\tregister long long lhash = Minus(uphash[u][id], uphash[fa[l][0]][id], mod[id]) * powInv26[dep[fa[l][0]]][id] % mod[id];\n\tregister long long rhash = Minus(dnhash[v][id], dnhash[l][id] * pow26[dep[v] - dep[l]][id] % mod[id], mod[id]);\n\treturn Add(lhash * pow26[dep[v] - dep[l]][id] % mod[id], rhash, mod[id]);\n}\n\ninline int Query(int a, int b, int c, int d) {\n\tregister int lab = Lca(a, b), lcd = Lca(c, d);\n\t//printf(\"lab=%d lcd=%d\\n\", lab, lcd);\n\tregister int l = 0, r = Min(dep[a] + dep[b] - (dep[lab] << 1) + 1, dep[c] + dep[d] - (dep[lcd] << 1) + 1) + 1;\n\t//printf(\"l=%d r=%d\\n\", l, r);\n\twhile (l < r - 1) {\n\t\tregister int mid = l + r >> 1;\n\t\tregister bool flag = 1;\n\t\tregister pair <pair <int, int>, int> p1 = Path(a, b, lab, mid), p2 = Path(c, d, lcd, mid);\n\t\t//printf(\"mid=%d %d->%d %d->%d\\n\", mid, p1.first.first, p1.first.second, p2.first.first, p2.first.second);\n\t\tfor (register int j = 0;j < 2;j++) {\n\t\t\tif (Hashval(p1.first.first, p1.first.second, p1.second, j) != Hashval(p2.first.first, p2.first.second, p2.second, j)) {\n\t\t\t\tflag = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag) l = mid;\n\t\telse r = mid;\n\t}\n\treturn l;\n}\n\ninline void Solve() {\n\t//printf(\"%lld\\n\", uphash[2][0]);\n\t//printf(\"%d\\n\", Hashval(2, 2, 2, 0));\n\tm = qread();\n\twhile (m--) {\n\t\tregister int a = qread(), b = qread(), c = qread(), d = qread();\n\t\tprintf(\"%d\\n\", Query(a, b, c, d));\n\t}\n}\n\nint main() {\n\tmemset(hd, -1, sizeof(hd));\n\tRead();\n\tCalc26();\n\tdep[1] = 1;\n\tDfs1(1);\n\tDfs2(1, 1);\n\tPrefix();\n\tSolve();\n\t#ifndef ONLINE_JUDGE\n\twhile (1);\n\t#endif\n\treturn 0;\n}\n```",
        "postTime": 1595429928,
        "uid": 61088,
        "name": "Solystic",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF504E \u3010Misha and LCP on Tree\u3011"
    },
    {
        "content": "\u9898\u610f\u8981\u6c42\u6811\u4e0a\u4e24\u6761\u8def\u5f84\u6240\u8868\u793a\u7684\u5b57\u7b26\u4e32\u7684 LCP\uff0c\u6709\u4e00\u4e2a\u5f88 basic \u7684\u505a\u6cd5\u5c31\u662f\u7ef4\u62a4\u94fe\u4e0a\u7684\u5b57\u7b26\u4e32\u54c8\u5e0c\u503c\uff0c\u4f18\u70b9\u5728\u4e8e\u652f\u6301 link/cut\uff0c\u94fe\u5b57\u7b26\u52a0\u6216\u8d4b\u503c\u7b49\u64cd\u4f5c\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $q\\log_2^2n$\uff0c\u5176\u5b9e\u5f88\u4f18\u79c0\uff0c\u7136\u800c\u7f3a\u70b9\u5728\u4e8e\u5bb9\u6613\u88ab\u5361\uff0c\u5e38\u6570\u5927\uff0c\u5f53\u7136\u53ef\u4ee5\u9009\u62e9\u591a\u54c8\u5e0c\uff0c\u4f46\u6709\u4e00\u79cd\u66f4\u597d\u7684 $O(q\\log_2n)$ \u7684\u505a\u6cd5\u3002\n\n\u8003\u8651\u5c06\u6811\u91cd\u94fe\u5256\u5206\uff0c\u5c06\u4e24\u6761\u8def\u5f84\u8868\u793a\u6210\u8def\u5f84\u533a\u95f4\u5e76\u914d\u5bf9\uff08\u4f7f\u6240\u6709\u533a\u95f4\u4e00\u4e00\u5bf9\u5e94\uff09\uff0c\u8fd9\u6837\u80fd\u5c06\u5b83\u4eec\u5206\u6210 $O(\\log_2n)$ \u6bb5\u5728\u91cd\u5256\u5e8f\u4e2d\u7684\u533a\u95f4\uff08\u6ce8\u610f\u6709\u53ef\u80fd\u662f\u53cd\u91cd\u5256\u5e8f\uff0c\u6240\u4ee5\u9884\u5904\u7406\u9700\u8981\u540c\u65f6\u8bb0\u91cd\u5256\u5e8f\u7684\u6b63\u4e32\u53cd\u4e32\uff09\u3002\n\n\u4e8e\u662f\u95ee\u9898\u53d8\u6210\u4e86\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6c42\u5176\u4e24\u4e2a\u540e\u7f00\u7684 LCP\u3002\n\n\u6211\u4eec\u53d1\u73b0 SAM \u662f\u7ef4\u62a4\u540e\u7f00\u7684\uff0c\u66f4\u9002\u5408\u6c42\u6700\u957f\u516c\u5171\u540e\u7f00\uff0c\u6240\u4ee5\u9700\u8981\u5c06\u5b57\u7b26\u4e32\u53cd\u8fc7\u6765\u6c42\u4e24\u4e2a\u524d\u7f00\u7684\u6700\u957f\u516c\u5171\u540e\u7f00\u3002\n\n\u8003\u8651 parent \u6811\u4e2d\uff0c\u4e00\u4e2a\u8282\u70b9\u7684\u7236\u4eb2\u662f\u5b83\u7684\u6700\u957f\u771f\u540e\u7f00\uff0c\u6240\u4ee5\u4e24\u4e2a\u8282\u70b9\u7684 lca \u5c31\u662f\u5b83\u4eec\u7684\u6700\u957f\u771f\u540e\u7f00\uff0c\u53ef\u4ee5\u6253 ST \u8868 $O(1)$ \u6c42\u3002\n\n\u63a5\u4e0b\u6765\u5c31\u662f\u5e73\u51e1\u7684\u4e86\uff0c\u5982\u679c\u4e0a\u4e00\u6bb5\u7684 LCP \u7b49\u4e8e\u957f\u5ea6\uff0c\u5c31\u7ee7\u7eed\u7b97\u4e0b\u4e00\u6bb5\uff0c\u5426\u5219\u5c31\u505c\u6b62\uff0c\u65f6\u95f4 $O(n(|\\sum|+\\log_2n)+q\\log_2n)$\uff0c\u7a7a\u95f4 $O(n(|\\sum|+\\log_2n))$\uff0c\u5b9e\u6d4b ST \u8868\u4f1a\u88ab\u5361\u7a7a\u95f4\uff0c\u6240\u4ee5\u8981\u7528\u7ebf\u6bb5\u6811\u6c42\u6700\u503c\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u79bb\u7ebf\u4e0b\u6765 tarjan\uff08\u4f3c\u4e4e\u4f1a\u53d8\u9ebb\u70e6\uff1f\uff09\uff0c\u53cd\u6b63\u5c31\u662f\u7528\u65f6\u95f4\u8fd8\u7a7a\u95f4\uff0c\u7136\u800c\u56e0\u4e3a zkw \u7ebf\u6bb5\u6811\u5e38\u6570\u592a\u5c0f\u4e86\uff0c\u6240\u4ee5\u5e76\u4e0d\u4f1a\u88ab\u5361\u5e38\u3002\n\n[CF \u4e0a\u7684 AC \u8bb0\u5f55](https://codeforces.com/contest/504/submission/191650086)",
        "postTime": 1675864484,
        "uid": 502410,
        "name": "EnofTaiPeople",
        "ccfLevel": 0,
        "title": "[CF504E] SAM \u7ef4\u62a4\u540e\u7f00 LCP"
    },
    {
        "content": "# Solution\n\u8fd9\u91cc\u600e\u4e48\u6ca1\u6709\u8dd1\u5f97\u98de\u5feb\u7684SAM + \u6811\u94fe\u5256\u5206\u7684\u9898\u89e3\u554a\uff0c\u6211\u6765\u8865\u4e00\u53d1\u3002\n\n\u5927\u6982\u5c31\u662f\u4f60\u53d1\u73b0\u66b4\u529b\u5339\u914d\u5f88\u6162\uff0c\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u4e00\u4e2a\u5339\u914d\u7684\uff0c\u590d\u6742\u5ea6\u4e3a$O(len)$\uff0c\u56e0\u6b64\u6211\u4eec\u8003\u8651\u4e00\u4e32\u4e00\u4e32\u5730\u5339\u914d\u3002\n\n## Part one\n\u5148\u601d\u8003\u4e00\u4e2a\u66f4\u7b80\u5355\u7684\u95ee\u9898\uff1a\u7ed9\u4f60\u4e00\u4e2a\u4e32\uff0c\u6c42\u4e24\u4e2a\u540e\u7f00\u7684LCP\u3002\n\u8fd9\u662f\u4e00\u4e2a\u7ecf\u5178\u95ee\u9898\uff0c\u6211\u4eec\u53ef\u4ee5\u5bf9\u53cd\u4e32\u5efa\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u8fd9\u6837\u539f\u4e32\u4e0a\u540e\u7f00LCP\u8f6c\u5316\u4e3a\u53cd\u4e32\u4e0a\u524d\u7f00\u7684\u6700\u957f\u516c\u5171\u540e\u7f00\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f\u4e24\u4e2a\u539f\u4e32\u4e0a\u524d\u7f00\u5728SAM\u4e0a\u7684\u5bf9\u5e94\u7ed3\u70b9\u7684LCA\u7684maxlen\u3002\n\n\u8fd9\u6837\u5355\u6b21\u8be2\u95ee\u53ef\u4ee5\u505a\u5230$O(logn)$\u6216\u8005$O(1)$\uff08RMQ\u6c42LCA\uff09\u3002\n## Part two\n\u518d\u8003\u8651\u6811\u4e0a\u7684\u95ee\u9898\uff0c\u6211\u4eec\u53d1\u73b0\u6811\u7684\u7ed3\u6784\u5e76\u4e0d\u4f18\u7f8e\uff0c\u5f88\u96be\u652f\u6301\u76f4\u63a5\u8be2\u95ee\u4e24\u4e2a\u94fe\u7684LCP\uff0c\u4e8e\u662f\u6211\u4eec\u8003\u8651\u6811\u94fe\u5256\u5206\uff0c\u9884\u5904\u7406\u91cd\u94fe\u7684\u4fe1\u606f\uff0c\u5efa\u51fa\u6bcf\u4e2a\u91cd\u94fe\u5bf9\u5e94\u7684\u4e32\u548c\u53cd\u4e32\u7684SAM\uff08\u76f8\u5f53\u4e8e\u7ef4\u62a4\u4e86\u6240\u6709\u94fe\u9876\u5230$x$\u7684\u4e32\u548c\u94fe\u5e95\u5230$x$\u7684\u4e32\uff0c\u4ee5\u5e94\u5bf9\u81ea\u4e0a\u800c\u4e0b\u4ee5\u53ca\u81ea\u4e0b\u800c\u4e0a\u7684\u4e24\u79cd\u94fe\uff09\uff0c\u8fd9\u6837\u4e24\u4e2a\u94fe\u7684LCP\u5c31\u80fd\u591f\u901a\u8fc7\u6c42LCA\u5feb\u901f\u5f97\u5230\u3002\u4e8e\u662f\u6211\u4eec\u628a\u6811\u4e0a\u95ee\u9898\u8f6c\u5316\u4e3a\u5355\u4e2a\u5b57\u7b26\u4e32\u7684\u95ee\u9898\u3002\n\n\u73b0\u5728\u95ee\u9898\u76f8\u5f53\u4e8e\u6709\u4e24\u4e2a\u5206\u522b\u6709$O(logn)$\u4e2a\u6bb5\u7684\u5b57\u7b26\u4e32\uff0c\u6c42\u5b83\u4eec\u7684LCP\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7b80\u5355\u5730\u4ece\u524d\u5230\u540e\u6309\u6bb5\u4f9d\u6b21\u5339\u914d\u5b8c\u6210\uff0c\u6bcf\u6b21\u8be2\u95ee\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(logn)$\u3002\u6ce8\u610f\u5982\u679c\u6211\u4eec\u5199\u7684\u662f$O(logn)$\u7684LCA\uff0c\u8fd9\u91cc\u6211\u4eec\u5339\u914d\u7684\u65f6\u5019\u53ea\u9700\u8981\u5148\u7279\u5224\u662f\u5426\u662f\u5b8c\u5168\u5305\u542b\uff0c\u4e0d\u662f\u5b8c\u5168\u5305\u542b\u518d\u8dd1LCA\uff0c\u8fd9\u6837\u603b\u590d\u6742\u5ea6\u8fd8\u662f$O(logn)$\u3002\n\n\u56e0\u6b64\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(mlog^2n)$/$O(mlogn)$\u3002\n\n\u5b9e\u73b0\u65f6\u7ec6\u8282\u8f83\u591a\uff0c\u4ee3\u7801\u6bd4\u8f83\u590d\u6742\u3002\n\n\u867d\u7136\u5199\u7684\u662f\u66b4\u529b$O(mlog^2n)$\uff08\u56e0\u4e3a\u5728\u5339\u914d\u7684\u65f6\u5019\u7528\u4e86vector\u7684erase\uff09\uff0c\u4f46\u76ee\u524d\u8fd8\u662fCF Execution Time rank1\uff08\u8fbe\u6210\u6210\u5c31\n\n## Code\n```cpp\n#include <bits/stdc++.h>\n \nusing namespace std;\n//\u957f\u957f\u7684\u5feb\u8bfb\u548c\u5934\n\nint id[MAXN << 1], n, m;\nvector<int> e[MAXN];\nstruct SAM {\n\tint sz = 2, lst = 1, t[MAXN << 1][26], len[MAXN << 1], fa[MAXN << 1];\n\tint dfn[MAXN << 1], fns[MAXN << 1], SZ[MAXN << 1], head[MAXN << 1], top[MAXN << 1], mx[MAXN << 1], dep[MAXN << 1], DFN = 0, edgenum = 0;\n\tstruct enode{ int to, nxt; } e[MAXN << 1];\n\n\tvoid add(int u, int v) {\n\t\te[++ edgenum] = (enode){v, head[u]}, head[u] = edgenum;\n\t}\n\tvoid Init() {\n\t\tmemset(t, 0, (sz + 10) * sizeof t[0]);\n\t\tsz = 2, lst = 1;\n\t}\n\tvoid insert(int c) {\n\t\tint p = lst, np = lst = sz ++;\n\t\tlen[np] = len[p] + 1;\n\t\tfor (; p && !t[p][c] ; p = fa[p]) t[p][c] = np;\n\t\tif (!p) { fa[np] = 1; return; }\n\t\tint q = t[p][c];\n\t\tif (len[q] == len[p] + 1) fa[np] = q;\n\t\telse {\n\t\t\tint nq = sz ++;\n\t\t\tlen[nq] = len[p] + 1;\n\t\t\tfa[nq] = fa[q];\n\t\t\tfa[np] = fa[q] = nq;\n\t\t\tmemcpy(t[nq], t[q], sizeof t[0]);\n\t\t\tfor (; p && t[p][c] == q ; p = fa[p]) t[p][c] = nq;\n\t\t}\n\t}\n\tvoid dfs1(int x) {\n\t\tSZ[x] = 1, dep[x] = dep[fa[x]] + 1;\n\t\tfor (int i = head[x]; i ; i = e[i].nxt) {\n\t\t\tint v = e[i].to;\n\t\t\tdfs1(v);\n\t\t\tSZ[x] += SZ[v];\n\t\t\tif (SZ[v] > SZ[mx[x]]) mx[x] = v;\n\t\t}\n\t}\n\tvoid dfs2(int x, int Top) {\n\t\tdfn[x] = ++ DFN, top[x] = Top;\n\t\tif (mx[x]) dfs2(mx[x], Top);\n\t\tfor (int i = head[x]; i ; i = e[i].nxt) if (e[i].to != mx[x]) dfs2(e[i].to, e[i].to);\n\t\tfns[x] = DFN;\n\t}\n\tvoid work() {\n\t\tfor (int i = 2; i < sz ; ++ i) add(fa[i], i);\n\t\tdfs1(1), dfs2(1, 1);\n\t}\n\tint getLCA(int x, int y) {\n\t\twhile (top[x] != top[y]) {\n\t\t\tif (dep[top[x]] < dep[top[y]]) swap(x, y);\n\t\t\tx = fa[top[x]];\n\t\t}\n\t\treturn dep[x] < dep[y] ? len[x] : len[y];\n\t}\n\tint getLCP(int x, int y) {\n\t\tif (dfn[x] <= dfn[y] && fns[y] <= fns[x]) return len[x];\n\t\tif (dfn[y] <= dfn[x] && fns[x] <= fns[y]) return len[y];\n\t\treturn getLCA(x, y);\n\t}\n} sam;\n\nstruct Trie_Tree{\n\tvector<int> V[MAXN << 1];\n\tqueue<int> que;\n\tint ch[MAXN][26], Lst[MAXN << 1], nodenum = 1;\n\tvoid insert(char *st, int *a, int len) {\n\t\tint nw = 1;\n\t\tfor (int i = 0; i < len ; ++ i) {\n\t\t\tif (!ch[nw][st[i] - 'a']) ch[nw][st[i] - 'a'] = ++ nodenum;\n\t\t\tnw = ch[nw][st[i] - 'a'];\n\t\t\tV[nw].PB(a[i]);\n\t\t}\n\t}\n\tvoid build_SAM(int x) {\n\t\tLst[1] = 1, que.push(1);\n\t\twhile (!que.empty()) {\n\t\t\tint q = que.front(); que.pop();\n\t\t\tfor (auto t : V[q]) id[t] = Lst[q];\n\t\t\tfor (int i = 0; i < 26 ; ++ i) {\n\t\t\t\tint v = ch[q][i];\n\t\t\t\tif (!v) continue;\n\t\t\t\tsam.lst = Lst[q];\n\t\t\t\tsam.insert(i);\n\t\t\t\tLst[v] = sam.lst;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n} trie;\n\n\n\nint LEN = 0, a[MAXN << 1];\nchar ST[MAXN], st[MAXN];\nint sz[MAXN], dep[MAXN], fa[MAXN], mx[MAXN], dfn[MAXN], fns[MAXN], top[MAXN], DFN = 0;\nvoid dfs1(int x, int father) {\n\tsz[x] = 1, dep[x] = dep[father] + 1, fa[x] = father;\n\tfor (auto v : e[x]) {\n\t\tif (v == father) continue;\n\t\tdfs1(v, x);\n\t\tsz[x] += sz[v];\n\t\tif (sz[v] > sz[mx[x]]) mx[x] = v;\n\t}\n}\nvoid dfs2(int x, int Top) {\n\tdfn[x] = ++ DFN, top[x] = Top;\n\tif (mx[x]) dfs2(mx[x], Top);\n\tfor (auto v : e[x]) {\n\t\tif (v == fa[x] || v == mx[x]) continue;\n\t\tdfs2(v, v);\n\t}\n\tfns[x] = DFN;\n}\n\nvoid build_trie(int x) {\n\tST[LEN] = st[x], a[LEN] = dfn[x], ++ LEN;\n\tif (!mx[x]) {\n\t\ttrie.insert(ST, a, LEN);\n\t\treverse(ST, ST + LEN);\n\t\treverse(a, a + LEN);\n\t\tfor (int i = 0; i < LEN ; ++ i) a[i] += n;\n\t\ttrie.insert(ST, a, LEN);\n\t\tLEN = 0;\n\t}\n\telse build_trie(mx[x]);\n\n\tfor (auto v : e[x]) {\n\t\tif (v == fa[x] || v == mx[x]) continue;\n\t\tbuild_trie(v);\n\t}\n}\n\n\nvector<PR> stk, P, Q;\nvoid getpath(vector<PR> &P, int A, int B) {\n\tP.clear(), stk.clear();\n\twhile (top[A] != top[B]) {\n\t\tif (dep[top[A]] < dep[top[B]]) stk.PB(MP(dfn[top[B]], dfn[B])), B = fa[top[B]];\n\t\telse P.PB(MP(dfn[A], dfn[top[A]])), A = fa[top[A]];\t\n\t}\n\tP.PB(MP(dfn[A], dfn[B]));\n\t\n\treverse(stk.begin(), stk.end());\n\tP.insert(P.end(), stk.begin(), stk.end());\n}\n\nint solve() {\n\tint ans = 0;\n\tPR x = *P.begin(), y = *Q.begin();\n\tint fx = (x.fi < x.se), fy = (y.fi < y.se);\n\twhile (P.size() && Q.size()) {\n\t\tint X, Y;\n\t\tif (fx) X = x.fi + n; else X = x.fi; \n\t\tif (fy) Y = y.fi + n; else Y = y.fi;\n\t\t\n\t\tint len = min(sam.getLCP(id[X], id[Y]), min(abs(x.se - x.fi), abs(y.se - y.fi)) + 1);\n\t\tans += len;\n\t\t\n\t\tif (fx) x.fi += len; else x.fi -= len;\n\t\tif (fy) y.fi += len; else y.fi -= len;\n\t\t\n\t\tint flag = 0;\n\t\tif ((fx && x.fi > x.se) || (!fx && x.fi < x.se)) flag = 1, P.erase(P.begin()), x = *P.begin(), fx = (x.fi < x.se);\n\t\tif ((fy && y.fi > y.se) || (!fy && y.fi < y.se)) flag = 1, Q.erase(Q.begin()), y = *Q.begin(), fy = (y.fi < y.se);\n\t\tif (!flag) break;\n\t}\n\treturn ans;\n}\n\nsigned main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"a.in\", \"r\", stdin);\n\tfreopen(\"a.out\", \"w\", stdout);\n#endif\n\tread(n), reads(st + 1);\n\tfor (int i = 1, u, v; i < n ; ++ i) read(u), read(v), e[u].PB(v), e[v].PB(u);\n\tread(m);\n\n\tdfs1(1, 0);\n\tdfs2(1, 1);   \n\tbuild_trie(1);\n\ttrie.build_SAM(1);\n\tsam.work();\n\tfor (int i = 1, A, B, C, D; i <= m ; ++ i) {\n\t\tread(A), read(B), read(C), read(D);\n\t\tgetpath(P, A, B);\n\t\tgetpath(Q, C, D);\n\t\tprint(solve());\n\t\tputc('\\n');\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1615536556,
        "uid": 32063,
        "name": "fade_away",
        "ccfLevel": 0,
        "title": "CF504E.Misha and LCP on Tree"
    },
    {
        "content": "### \u9898\u76ee\u5927\u610f\n\n\u7ed9\u4f60\u4e00\u68f5\u6709$n$\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u4e0a\u6709\u4e00\u4e2a\u5b57\u7b26$c$\u3002\n\n\u6709$m$\u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee$a\\sim b$\u8def\u5f84\u4e0a\u7684\u5b57\u7b26\u4e32\u548c$c \\sim d$\u8def\u5f84\u4e0a\u7684\u5b57\u7b26\u4e32\u7684\u6700\u957f\u516c\u5171\u524d\u7f00$\\texttt{(LCP)}$\n\n$n \\leq 3 \\times 10^5,\\; m \\leq 10^6$\n\n### \u5206\u6790\n\n\u53d1\u73b0\u666e\u901a\u7684$\\texttt{LCP}$\u53ef\u4ee5\u901a\u8fc7\u4e8c\u5206$+$\u54c8\u5e0c\u6c42\u51fa\uff0c\u6211\u4eec\u8003\u8651\u628a\u8fd9\u4e2a\u505a\u6cd5\u62d3\u5c55\u5230\u6811\u4e0a\u3002\n\n\u7ef4\u62a4$\\texttt{h[u]}$\u8868\u793a\u6839\u5230$u$\u8def\u5f84\u4e0a\u7684\u5b57\u7b26\u4e32\u54c8\u5e0c\u503c\uff0c$\\texttt{revh[u]}$\u8868\u793a$u$\u5230\u6839\u8def\u5f84\u4e0a\u7684\u54c8\u5e0c\u503c\uff0c\u5219$u \\sim v$\u8def\u5f84\u4e0a\u7684\u54c8\u5e0c\u503c\u53ef\u4ee5\u8868\u73b0\u4e3a$\\texttt{revh[u, lca]} \\times \\texttt{base}^{dv} + \\texttt{h(lca,v])}$\uff0c\u5176\u4e2d$\\texttt{dv}$\u8868\u793a$\\texttt{v}$\u5230$\\texttt{lca}$\u7684\u8ddd\u79bb\uff1b\u800c\u8be2\u95ee$u$\u548c$v$\u5230$\\texttt{lca}$\u7684\u54c8\u5e0c\u503c\u53ef\u4ee5\u89c6\u4e3a\u4e00\u4e2a\u5e8f\u5217\u95ee\u9898\u89e3\u51b3\u3002\n\n\u56de\u5230\u539f\u95ee\u9898\uff0c\u6211\u4eec\u4e8c\u5206$\\texttt{LCP}$\u7684\u957f\u5ea6$\\texttt{k}$\uff0c\u5e76\u627e\u5230$\\texttt{(a, b), (c, d)}$\u8def\u5f84\u4e0a\u7b2c$\\texttt{k}$\u4e2a\u8282\u70b9\uff08\u8bb0\u4e3a$v_1, v_2$\uff09\uff0c\u5224\u65ad$\\texttt{(a,v1)}$\u4e0e$\\texttt{(c,v2)}$\u94fe\u4e0a\u7684\u54c8\u5e0c\u503c\u662f\u5426\u76f8\u7b49\uff0c\u5e76\u8c03\u6574\u4e8c\u5206\u533a\u95f4\uff0c\u6700\u540e\u7684$l$\u5c31\u662f\u7b54\u6848\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\mathcal{O}\\texttt{((n + m) log n)}$\uff0c\u8be6\u7ec6\u5b9e\u73b0\u53c2\u89c1\u4ee3\u7801\n\n### \u4ee3\u7801\n\n``` cpp\n#include <bits/stdc++.h>\n\n#define R register\n#define ll long long\n#define sum(a, b, mod) (((a) + (b)) % mod)\n\nconst int MaxN = 1e6 + 10;\nconst int mod = 998244853;\n\nstruct edge\n{\n    int next, to;\n};\n\nstruct mod_t\n{\n    static int norm(int x) { return x + (x >> 31 & mod); }\n    int x;\n    mod_t() {}\n    mod_t(int v) : x(v) {}\n    mod_t(long long v) : x(v) {}\n    mod_t(char v) : x(v) {}\n    mod_t operator+(const mod_t &rhs) const { return norm(x + rhs.x - mod); }\n    mod_t operator-(const mod_t &rhs) const { return norm(x - rhs.x); }\n    mod_t operator*(const mod_t &rhs) const { return (ll)x * rhs.x % mod; }\n};\n\nedge e[MaxN << 1];\nstd::vector<int> up[MaxN], down[MaxN];\n\nchar s[MaxN];\nint n, m, cnt;\nmod_t h[MaxN], revh[MaxN], powm[MaxN], invp[MaxN], base, inv;\nint son[MaxN], fa[MaxN][24], f[MaxN][24], Dep[MaxN], pos[MaxN];\nint head[MaxN], dep[MaxN], maxd[MaxN], fir[MaxN], lg2[MaxN], top[MaxN];\n\nvoid add_edge(int u, int v)\n{\n    ++cnt;\n    e[cnt].to = v;\n    e[cnt].next = head[u];\n    head[u] = cnt;\n}\n\nint querykth(int u, int k)\n{\n    if (!k) return u;\n    u = fa[u][lg2[k]], k -= (1 << lg2[k]);\n    k -= dep[u] - dep[top[u]], u = top[u];\n    return ((k >= 0) ? up[u][k] : down[u][-k]);\n}\n\nint querylca(int u, int v)\n{\n    int l = fir[u], r = fir[v], k;\n    if (l > r) std::swap(l, r);\n    k = lg2[r - l + 1];\n    return (Dep[f[l][k]] <= Dep[f[r - (1 << k) + 1][k]]) ? pos[f[l][k]] : pos[f[r - (1 << k) + 1][k]];\n}\n\nmod_t fast_pow(mod_t a, int b)\n{\n    mod_t ret = 1;\n    while (b)\n    {\n        if (b & 1)\n            ret = ret * a;\n        a = a * a, b >>= 1;\n    }\n    return ret;\n}\n\nvoid init()\n{\n    srand(time(NULL));\n    powm[0] = invp[0] = 1, base = (rand() % 2000) + 1001;\n    inv = fast_pow(base, mod - 2);\n    for (int i = 1; i <= n; i++)\n    {\n        powm[i] = (powm[i - 1] * 1ll * base);\n        invp[i] = (invp[i - 1] * 1ll * inv);\n    }\n}\n\nvoid prework()\n{\n    lg2[0] = -1;\n    for (int i = 1; i <= cnt; i++)\n        lg2[i] = lg2[i >> 1] + 1, f[i][0] = i;\n    for (int j = 1; (1 << j) <= cnt; j++)\n    {\n        for (int i = 1; i <= cnt - (1 << j) + 1; i++)\n            f[i][j] = (Dep[f[i][j - 1]] <= Dep[f[i + (1 << (j - 1))][j - 1]]) ? f[i][j - 1] : f[i + (1 << (j - 1))][j - 1];\n    }\n}\n\ninline int read()\n{\n    int x = 0;\n    char ch = getchar();\n    while (ch > '9' || ch < '0')\n        ch = getchar();\n    while (ch <= '9' && ch >= '0')\n        x = (x << 1) + (x << 3) + (ch - 48), ch = getchar();\n    return x;\n}\n\nvoid dfs(int u, int fa)\n{\n    Dep[++cnt] = maxd[u] = dep[u] = dep[fa] + 1, ::fa[u][0] = fa;\n    pos[cnt] = u, h[u] = h[fa] * 1ll * base + s[u];\n    fir[u] = cnt, revh[u] = revh[fa] + powm[dep[fa]] * s[u];\n    for (int i = 1; i <= 20; i++)\n        ::fa[u][i] = ::fa[::fa[u][i - 1]][i - 1];\n    for (int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if (v == fa) continue;\n        dfs(v, u), pos[++cnt] = u, Dep[cnt] = dep[u];\n        if (maxd[v] > maxd[u])\n            maxd[u] = maxd[v], son[u] = v;\n    }\n}\n\nvoid dfs1(int u, int top)\n{\n    ::top[u] = top;\n    if (u == top)\n    {\n        int x = u;\n        for (int i = 0; i <= maxd[u] - dep[u]; i++)\n            up[u].push_back(x), x = fa[x][0];\n        x = u;\n        for (int i = 0; i <= maxd[u] - dep[u]; i++)\n            down[u].push_back(x), x = son[x];\n    }\n    if (son[u]) dfs1(son[u], top);\n    for (int i = head[u]; i; i = e[i].next)\n    {\n        int v = e[i].to;\n        if (v != son[u] && v != fa[u][0]) dfs1(v, v);\n    }\n}\n\nint qhash(int u, int v, int lca, int flca)\n{\n    int dv = dep[v] - dep[lca];\n    mod_t h1 = (revh[u] - revh[flca] + mod) * invp[dep[flca]], h2, H;\n    h2 = (h[v] - h[lca] * powm[dv]), H = h1 * powm[dv] + h2;\n    return H.x;\n}\n\nint get(int u, int v, int k)\n{\n    int lca = querylca(u, v), d = dep[u] + dep[v] - 2 * dep[lca] + 1;\n    return (k <= dep[u] - dep[lca]) ? 1 : 0;\n}\n\nint path(int u, int v, int k)\n{\n    int lca = querylca(u, v), d = dep[u] + dep[v] - 2 * dep[lca] + 1;\n    if (k <= dep[u] - dep[lca])\n        return querykth(u, k - 1);\n    else\n        return querykth(v, d - k);\n}\n\nint query(int a, int b, int c, int d)\n{\n    if (s[a] != s[c]) return 0;\n    int lca1 = querylca(a, b), flca1 = fa[lca1][0], d1 = dep[a] + dep[b] - 2 * dep[lca1] + 1;\n    int lca2 = querylca(c, d), flca2 = fa[lca2][0], d2 = dep[c] + dep[d] - 2 * dep[lca2] + 1;\n    int l = 1, r = std::min(d1, d2);\n    // printf(\"debug: a = %d, b = %d, c = %d, d = %d, lca(a, b) = %d, lca(c, d) = %d\\n\", a, b, c, d, lca1, lca2);\n    while (l < r)\n    {\n        int mid = (l + r + 1) >> 1;\n        int x1 = get(a, b, mid), x2 = get(c, d, mid);\n        int v1 = path(a, b, mid), v2 = path(c, d, mid);\n        // printf(\"Debug: l = %d, r = %d, mid = %d, v1 = %d, v2 = %d\\n\", l, r, mid, v1, v2);\n        if (qhash(a, v1, (x1 ? v1 : lca1), (x1 ? fa[v1][0] : flca1)) == qhash(c, v2, (x2 ? v2 : lca2), (x2 ? fa[v2][0] : flca2)))\n            l = mid;\n        else\n            r = mid - 1;\n    }\n    return l;\n}\n\nint main()\n{\n    scanf(\"%d\\n%s\", &n, s + 1), init();\n    for (int i = 1; i < n; i++)\n    {\n        int u = read(), v = read();\n        add_edge(u, v), add_edge(v, u);\n    }\n    m = read(), cnt = 0, dfs(1, 0), dfs1(1, 1), prework();\n    for (int i = 1; i <= m; i++)\n    {\n        int a = read(), b = read(), c = read(), d = read();\n        printf(\"%d\\n\", query(a, b, c, d));\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1584269530,
        "uid": 61966,
        "name": "little_sun",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF504E \u3010Misha and LCP on Tree\u3011"
    },
    {
        "content": "[$\\tt Link$](/problem/CF504E)\u3002\n\n\u5e8f\u5217\u4e0a\u7684\u539f\u95ee\u9898\u6709\u4e2a trick\uff1a\u4e8c\u5206 LCP \u957f\u5ea6\uff0c\u518d\u7528\u54c8\u5e0c\u5224\u65ad\u4e24\u6761\u8def\u5f84\u662f\u5426\u5b8c\u5168\u76f8\u7b49\u3002\n\n\u4e8c\u5206\u5360\u53bb\u4e00\u4e2a $\\log$\uff0c\u53c8\u6709 $m\\le10^6$\uff0c\u90a3\u6211\u4eec\u53ea\u80fd\u5728 $O(1)$ \u7684\u65f6\u95f4\u6c42\u54c8\u5e0c\u503c\u4e86\u3002\n\n\u8003\u8651\u8def\u5f84\u54c8\u5e0c\u503c\u600e\u4e48\u6c42\u3002\u6211\u662f\u628a\u8def\u5f84\u60f3\u8c61\u4e3a $k$ \u8fdb\u5236\u6570\uff08$k\\gt26$\uff0c\u4e3a\u4e86\u65b9\u4fbf\u9006\u5143 $k$ \u4e3a\u8d28\u6570\uff09\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u70b9 $p$ \u9884\u5904\u7406 $p\\to1$ \u7684\u8def\u5f84\u7684\u7b54\u6848 $f$ \u548c $1\\to p$ \u7684\u8def\u5f84\u7684\u7b54\u6848 $g$\uff08$1$ \u662f\u6839\uff09\u3002\n\n\u6c42\u8def\u5f84 $u\\to v$ \u7684\u7b54\u6848\u5c31\u5148 $O(1)$ \u6c42\u5b83\u4eec\u7684 LCA $p$\uff0c\u5206\u522b\u4f7f\u7528 $f$ \u548c $g$ \u5f97\u5230 $p\\to v$ \u548c $u\\to p$ \u7684\u503c\uff0c\u5408\u5e76\u5373\u53ef\u3002\n\n\u4f46\u662f\u3002\u600e\u4e48\u77e5\u9053\u4e8c\u5206\u65f6\u8df3\u4e86 $mid$ \u6b65\u7684\u4e24\u4e2a\u5de6\u7aef\u70b9\u53bb\u5230\u4e86\u54ea\u91cc\uff1f\u8fd9\u91cc\u9700\u8981\u957f\u5256\u6811\u4e0a $k$ \u7ea7\u7956\u5148\u5e76\u5206\u7c7b\u8ba8\u8bba\u6709\u6ca1\u6709\u8df3\u8fc7 $\\tt lca$\u3002\n\n\u9700\u8981\u53cc\u54c8\u5e0c\u3002\n\n\u786e\u5b9e\u633a\u7b80\u5355\u7684\uff0c\u4f46\u662f\u6709\u4e86\u957f\u5256\uff0c$O(1)$ LCA\uff0c\u5de8\u5927\u53cc\u54c8\u5e0c\u4e4b\u540e\u5199\u8d77\u6765\u548c\u5927\u6a21\u62df\u4e00\u6837\u3002\n\n\u4ee3\u7801\uff1a<https://www.luogu.com.cn/paste/314zxi88>",
        "postTime": 1668994663,
        "uid": 368107,
        "name": "xfrvq",
        "ccfLevel": 7,
        "title": "20 min \u7684\u8bfe\u95f4/cy"
    },
    {
        "content": "# Misha and LCP on Tree \u9898\u89e3\n\n## solution\n\n\u8003\u8651\u6c42 $2$ \u4e2a\u4e32\u7684 $\\text{LCP}$ \u7684\u4e00\u4e2a\u7ecf\u5178\u65b9\u6cd5\uff1a\u4e8c\u5206 + \u5b50\u4e32\u54c8\u5e0c\u3002\n\n\u8fd9\u9053\u9898\u76ee\u4e5f\u662f\u7528\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5148\u4e8c\u5206\u7b54\u6848\uff0c\u7136\u540e\u5728\u6811\u4e0a\u627e\u5230\u5bf9\u5e94\u8def\u5f84\u7684\u5b57\u7b26\u4e32\u54c8\u5e0c\u503c\u3002\n\n\u627e\u54c8\u5e0c\u503c\u53ef\u4ee5\u7528\u6811\u4e0a $k$ \u7ea7\u7956\u5148 + \u6811\u4e0a\u5dee\u5206\u7684\u505a\u6cd5\uff0c\u5177\u4f53\u6765\u8bf4\uff0c\u5c31\u662f\u7ef4\u62a4 $2$ \u79cd\u54c8\u5e0c\u503c\uff0c\u5206\u522b\u662f $hash_i = hash_{fa_i} \\times X + str_i$ \u548c $hash_i = hash_{fa_i} + str_i \\times X ^ {dep_i - 1}$\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u5bf9 $\\text{lca}$ \u5206\u7c7b\u8ba8\u8bba\u6765\u7b97\u51fa\u5bf9\u5e94\u8def\u5f84\u7684\u5b57\u7b26\u4e32\u54c8\u5e0c\u3002\n\n\u8bb2\u8d77\u6765\u53ef\u80fd\u6bd4\u8f83\u62bd\u8c61\uff0c\u8d34\u4e00\u53d1\u4ee3\u7801\uff1a\uff08$\\text{val}$ \u8868\u793a\u7b2c $1$ \u79cd\u54c8\u5e0c\uff1b$\\text{trival}$ \u8868\u793a\u7b2c $2$ \u79cd\u54c8\u5e0c\uff1b$\\operatorname{query}(x,k)$\u8868\u793a $x$ \u7684\u6811\u4e0a $k$ \u7ea7\u7956\u5148\uff1b$l$ \u8868\u793a $\\text{lca}$\uff09\n\n```cpp\ninline unsigned long long get(int u, int v, int l, int len) {\n    if (dep[u] - dep[l] + 1 >= len) return (val[u] - val[query(u, len)] * g[len] % P + P) % P;\n    unsigned long long a = (val[u] - val[fa[l]] * g[dep[u] - dep[l] + 1] % P + P) % P;\n    int x = query(v, dep[v] - dep[l] - (len - (dep[u] - dep[l] + 1)));\n    unsigned long long b = (trival[x] - trival[l] + P) * rg[dep[l]] % P * g[dep[u] - dep[l] + 1] % P;\n    return ((a + b) % P + P) % P;\n}\n```\n\n\u7136\u540e\u662f\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff0c\u4e8c\u5206\u590d\u6742\u5ea6\u662f $O(\\log n)$ \u7684\uff0c$\\text{lca}$ \u7684\u590d\u6742\u5ea6\u662f $O(\\log n)$ \u7684\uff0c\u9898\u89e3\u4e2d\u7684\u6811\u4e0a $k$ \u7ea7\u7956\u5148\u6c42\u6cd5\u662f $O(n \\log \\log n)- O(\\log \\log n)$ \u7684\uff08\u91cd\u94fe\u5256\u5206\uff09\uff0c\u5f53\u7136\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528\u957f\u5256\u4f18\u5316\u5230 $O(1)$\u3002\u6240\u4ee5\u603b\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(\\log n \\log \\log n)$\uff0c\u663e\u7136\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"Ofast\")\nusing namespace std;\nconst int N = 5e5 + 10, S = 6;\nconst unsigned long long G = 257, P = 998244353;\nint root = 1, top[N], to[S][N], dis[S][N], dfn[N], h[N], dfncnt, cnt, lg[N], n, m, fa[N], dep[N], siz[N], son[N];\nlong long val[N], trival[N], g[N], rg[N];\ninline long long qpw(long long x, long long y) {\n    long long ans = 1;\n    while(y) {\n        if (y & 1) ans = ans * x % P;\n        x = x * x % P, y >>= 1;\n    }\n    return ans;\n}\nstruct Edge {\n    int next, v;\n} edge[N << 1];\ninline void addedge(int u, int v) { edge[++cnt] = {h[u], v}, h[u] = cnt; }\nchar str[N];\nvector<int> vec[N];\nvoid dfs(int u) {\n    int v;\n    siz[u] = 1, val[u] = (val[fa[u]] * G + str[u]) % P;\n    trival[u] = (trival[fa[u]] + g[dep[u] - 1] * str[u]) % P;\n    for (int i = h[u]; i; i = edge[i].next) {\n        v = edge[i].v;\n        if (v == fa[u]) continue;\n        dep[v] = dep[u] + 1, fa[v] = u, dfs(v), siz[u] += siz[v];\n        if (siz[v] > siz[son[u]]) son[u] = v;\n    }\n}\nvoid dfs2(int u) {\n    dfn[u] = ++cnt;\n    vec[top[u]].push_back(u);\n    if (son[u]) top[son[u]] = top[u], to[0][son[u]] = fa[top[u]], dis[0][son[u]] = dis[0][u] + 1, dfs2(son[u]);\n    int v;\n    for (int i = h[u]; i; i = edge[i].next) {\n        v = edge[i].v;\n        if (v == fa[u] || v == son[u]) continue;\n        top[v] = v, to[0][v] = fa[top[v]], dis[0][v] = 1, dfs2(v);\n    }\n}\ninline int query(int x, int k) {\n    if (k == dep[x]) return 0;\n    if (dis[4][x] <= k) k -= dis[4][x], x = to[4][x];\n    if (dis[3][x] <= k) k -= dis[3][x], x = to[3][x];\n    if (dis[2][x] <= k) k -= dis[2][x], x = to[2][x];\n    if (dis[1][x] <= k) k -= dis[1][x], x = to[1][x];\n    if (dis[0][x] <= k) k -= dis[0][x], x = to[0][x];\n    return vec[top[x]][dep[x] - dep[top[x]] - k];\n}\ninline int lca(int u, int v) {\n    while (top[u] != top[v]) {\n        if (dep[top[u]] < dep[top[v]]) swap(u, v);\n        u = fa[top[u]];\n    }\n    return dep[u] < dep[v] ? u : v;\n}\nvoid read() {\n    cin >> n, scanf(\"%s\", str + 1);\n    for (int i = 2; i <= n; i++) lg[i] = lg[i >> 1] + 1;\n    int u, v;\n    for (int i = 1; i < n; i++) {\n        scanf(\"%d %d\", &u, &v);\n        addedge(u, v), addedge(v, u);\n    }\n    cin >> m;\n}\ninline unsigned long long get(int u, int v, int l, int len) {\n    if (dep[u] - dep[l] + 1 >= len) return (val[u] - val[query(u, len)] * g[len] % P + P) % P;\n    unsigned long long a = (val[u] - val[fa[l]] * g[dep[u] - dep[l] + 1] % P + P) % P;\n    // cout << \"k=\" << dep[v] - dep[l] - (len - (dep[u] - dep[l] + 1)) << endl, sleep(1);\n    int x = query(v, dep[v] - dep[l] - (len - (dep[u] - dep[l] + 1)));\n    unsigned long long b = (trival[x] - trival[l] + P) * rg[dep[l]] % P * g[dep[u] - dep[l] + 1] % P;\n    // cout << l << ' ' << (a + b) % P << endl;\n    return ((a + b) % P + P) % P;\n}\nint main() {\n    read();\n    g[0] = 1;\n    for (int i = 1; i <= n; i++) g[i] = g[i - 1] * G % P;\n    rg[0] = 1, rg[1] = qpw(g[1], P - 2);\n    for (int i = 2; i <= n; i++) rg[i] = rg[i - 1] * rg[1] % P;\n    to[0][root] = 0, dis[0][root] = dep[root] = 1, top[root] = root, dfs(root), dfs2(root);\n    for (int i = 1; i < S; i++)\n        for (int j = 1; j <= n; j++) {\n            to[i][j] = to[i - 1][to[i - 1][j]];\n            dis[i][j] = dis[i - 1][j] + dis[i - 1][to[i - 1][j]];\n        }\n    int x, y, lxy, lab, a, b, l, r;\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d %d %d %d\", &x, &y, &a, &b), lxy = lca(x, y), lab = lca(a, b);\n        l = 1, r = min(dep[x] - dep[lxy] + dep[y] - dep[lxy] + 1, dep[a] - dep[lab] + dep[b] - dep[lab] + 1);\n        int ans = 0, mid;\n        while (l <= r) {\n            mid = l + r >> 1;\n            if (get(x, y, lxy, mid) == get(a, b, lab, mid))\n                ans = mid, l = mid + 1;\n            else\n                r = mid - 1;\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```",
        "postTime": 1668595212,
        "uid": 615348,
        "name": "zhouershan",
        "ccfLevel": 7,
        "title": "Misha and LCP on Tree"
    }
]