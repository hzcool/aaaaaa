[
    {
        "content": "## \u6807\u7b7e\uff1a\n\n$LCT$ , \u7ebf\u6bb5\u6811\uff0c$Two \\ point$\n\n## \u6765\u6e90\uff1a\n\n$CF1109F$\n\n## \u9898\u610f\uff1a\n\n\u7ed9\u5b9a\u4e00\u4e2a$n*m$\u7684\u7f51\u683c\u3002\u6bcf\u4e2a\u683c\u5b50\u6709\u4e00\u4e2a\u70b9\u6743$f_{ij}$,\u6709\u591a\n\n\u5c11\u4e2a\u8fde\u7eed\u7684\u503c\u57df\u4f7f\u5f97\u8fd9\u4e9b\u70b9\u6240\u5e26\u8868\u7684\u8fde\u901a\u5757\u5f62\u6210\u4e00\u68f5\u6811\u3002\n\n\u6c42\u65b9\u6848\u6570\u3002($n \\leq 2000 , m \\leq2000$ , $nm\\leq 200000$)\n\n# $solution\uff1a$\n\n\u6211\u4eec\u8003\u8651\u5f62\u6210\u4e00\u68f5\u6811\uff0c\u9996\u5148\u4e00\u5b9a\u4e0d\u4f1a\u5f62\u6210\u73af\uff0c\u7531\u4e8e\u5305\u62ec\u4e00\u4e2a\n\n\u4f1a\u5f62\u6210\u73af\u7684\u533a\u95f4\u4e5f\u4e00\u5b9a\u4f1a\u6709\u73af\u3002\u6240\u4ee5\u663e\u7136\u8fd9\u662f\u6ee1\u8db3\u5355\u8c03\u6027\n\n\u7684\uff0c\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u7528$Two \\ point$\u6765\u7ef4\u62a4\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u5de6\u7aef\n\n\u70b9\uff0c\u627e\u5230\u4e00\u4e2a\u6700\u5927\u7684\u53f3\u7aef\u70b9\uff0c\u4f7f\u5f97\u5176\u6ee1\u8db3\u6761\u4ef6\u3002\u5bf9\u4e8e\u6bcf\u6b21\u8fde\n\n\u8fb9\u548c\u65ad\u8fb9\uff0c\u6211\u4eec\u53ef\u4ee5\u7528$LCT$\u7ef4\u62a4\u3002\u4e8e\u662f\u63a5\u4e0b\u6765\u7684\u95ee\u9898\u53d8\u6210\u4e86\n\n\u8981\u5224\u65ad\u5bf9\u4e8e\u4e00\u4e2a\u5de6\u7aef\u70b9$l$\uff0c\u6709\u591a\u5c11\u4e2a\u53f3\u7aef\u70b9$r$\u6ee1\u8db3\u8fb9\u6570$m=r-l$\n\n\u4e5f\u5c31\u662f\u70b9\u6570\u51cf$1$\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u70b9\u6570$-$\u8fb9\u6570\u4e3a$1$\n\n\u7684\u4e2a\u6570\uff0c\u5c31\u662f\u7b54\u6848\u3002\n\n```cpp\n\n#include<bits/stdc++.h>\nusing namespace std ;\nstruct LCT{\n    #define ls ch[x][0]\n    #define rs ch[x][1]\n    #define N 1000000\n    int ch[N][3] , fa[N] , turn[N] ;\n    int Get(int x){ return ch[fa[x]][1] == x ; }\n    int nroot(int x){ return ch[fa[x]][1] == x || ch[fa[x]][0] == x ; }\n    void pushr(int x){ if( !x ) return ; swap( ls , rs ) ; turn[x] ^= 1 ;}\n    void pushdown(int x){ if( turn[x] ){ pushr( ls ) , pushr( rs ) ; turn[x] = 0 ; } }\n    void pushall(int x){ if( nroot(x) ) pushall( fa[x] ) ; pushdown( x ) ; }\n    void rotate(int x){\n        int y = fa[x] , z = fa[y] , w = Get( x ) ;\n        if( nroot( y ) ) ch[z][ch[z][1] == y] = x ;\n        ch[y][w] = ch[x][w ^ 1] ;\n        if( ch[y][w] ) fa[ch[y][w]] = y ;\n        ch[x][w ^ 1] = y ;\n        fa[y] = x ; fa[x] = z ;\n    }\n    void splay(int x){\n        pushall( x ) ;\n        while( nroot( x ) ){\n            int y = fa[x] ;\n            if( nroot( y ) )\n                Get(x) ^ Get(y)?rotate( x ):rotate( y ) ;\n            rotate( x ) ;\n        }\n    }\n    void access(int x){\n        for(int y = 0 ; x ; x = fa[y = x] ){\n            splay( x ) ; rs = y ; \n        }\n    }\n    int findroot(int x){\n        access( x ) ; splay( x ) ;\n        while( ls ) x = ls ;\n        splay( x ) ; return x ;\n    }\n    void makeroot(int x){\n        access( x ) ; splay( x ) ;\n        pushr( x ) ; return ;\n    }\n    int link(int x , int y){\n        makeroot( x ) ;\n        if( findroot( y ) == x ) return false ;\n        fa[x] = y ; return true ;\n    }\n    void cut(int x , int y){\n        makeroot( x ) ;\n        if( findroot( y ) == x && fa[y] == x && !ch[y][0] ){\n            fa[y] = ch[x][1] = 0 ;\n        } return ;\n    }\n}T;\nstruct segment_tree{\n    #define ls x<<1\n    #define rs x<<1|1\n    #define N 1000000\n    int Min[4*N] , Num[4*N] , lazy[4*N] ;\n    void pushdown(int x){\n        if( lazy[x] ){\n            lazy[ls] += lazy[x] ;\n            lazy[rs] += lazy[x] ;\n            Min[ls] += lazy[x] , Min[rs] += lazy[x] ;\n            lazy[x] = 0 ;\n        }\n    }\n    void pushup(int x){\n        if( Min[ls] < Min[rs] ) Min[x] = Min[ls] , Num[x] = Num[ls] ;\n        if( Min[ls] > Min[rs] ) Min[x] = Min[rs] , Num[x] = Num[rs] ;\n        if( Min[ls] == Min[rs] ) Min[x] = Min[ls] , Num[x] = Num[ls] + Num[rs] ;\n    }\n    void build(int x , int l , int r){\n        if( l == r ){ Min[x] = 0 , Num[x] = 1 ; return ; }\n        int mid = l + r >> 1 ;\n        build( ls , l , mid ) ; build( rs , mid + 1 , r ) ;\n        pushup( x ) ;\n    }\n    void modify(int x , int l , int r , int ll , int rr , int k ){\n        if( l == ll && r == rr ){\n            lazy[x] += k ; Min[x] += k ;\n            return ;\n        }\n        pushdown( x ) ;\n        int mid = l + r >> 1 ;\n        if( rr <= mid ) modify( ls , l , mid , ll , rr , k ) ;\n        else if( ll > mid ) modify( rs , mid + 1 , r , ll , rr , k ) ;\n        else modify( ls , l , mid , ll , mid , k ) , modify( rs , mid + 1 , r , mid + 1 , rr , k ) ;\n        pushup( x ) ;\n    }\n    int query(int x , int l , int r , int ll , int rr ){\n        if( l == ll && r == rr ){\n            if( Min[x] == 1 ) return Num[x] ;\n            else return 0 ;\n        } int mid = l + r >> 1 ;\n        pushdown( x ) ;\n        if( rr <= mid ) return query( ls , l , mid , ll , rr ) ;\n        else if( ll > mid ) return query( rs , mid + 1 , r , ll , rr ) ;\n        else return query( ls , l , mid , ll , mid ) + query( rs , mid + 1 , r , mid + 1 , rr ) ;\n    }\n}S;\n#define N 1000000\n#define M 3000\n#define LL long long\nvector<int> V[N] ;\nint dx[10] = {1 , 0 , -1 , 0 } ;\nint dy[10] = {0 , 1 , 0 , -1 } ;\nint n , m , w[M][M] ;\nLL ans = 0 ;\nint main()\n{\n    scanf(\"%d%d\" , &n , &m ) ;\n    for(int i = 1 ; i <= n ; i++ ) for(int j = 1 ; j <= m ; j++ ) scanf(\"%d\" , &w[i][j] ) ;\n    for(int i = 1 ; i <= n ; i++ ){\n        for(int j = 1 ; j <= m ; j++ ){\n            for(int d = 0 ; d < 4 ; d++ ){\n                int x = i + dx[d] , y = j + dy[d] ;\n                if( x < 1 || y < 1 || x > n || y > m ) continue ;\n                if( w[x][y] > w[i][j] ) continue ;\n                V[w[x][y]].push_back( w[i][j] ) ;\n                V[w[i][j]].push_back( w[x][y] ) ;\n            }\n        }\n    } int R = 0 ; LL t = n * m ;\n    S.build( 1 , 1 , t ) ;\n    for(int i = 1 ; i <= t ; i++ ){\n        for(int j = R + 1 ; j <= t ; j++ ){\n            int now = j , flag = 0 ;\n            for(int d = 0 ; d < V[now].size() ; d++ ){\n                int now1 = V[now][d] ;\n                if( now1 < now && now1 >= i )\n                if( !T.link( now1 , now ) ){ flag = 1 ; break ;}\n            }\n            for(int d = 0 ; d < V[now].size() ; d++ ) T.cut( now , V[now][d] ) ;\n            if( flag == 1 ) break ;\n            R = j ; int tot = 0 ;\n            for(int d = 0 ; d < V[now].size() ; d++ ){\n                int now1 = V[now][d] ;\n                if( now1 < j && now1 >= i ) T.link( now1 , now ) ;\n                if( now1 < j && now1 >= i ) tot++ ;\n            }\n            S.modify( 1 , 1 , t , R , R , R - i + 1 ) ;\n            S.modify( 1 , 1 , t , R , t , -tot ) ;\n        }\n        ans += 1ll * S.query( 1 , 1 , t , i , R ) ;\n        int tot = 0 ;\n        for(int d = 0 ; d < V[i].size() ; d++ ){\n            if( V[i][d] <= R && V[i][d] > i ){ \n                T.cut( V[i][d] , i ) ; \n                S.modify( 1 , 1 , t , V[i][d] , t , 1 ) ;\n            }\n        }\n        S.modify( 1 , 1 , t , i , R , -1 ) ;\n    }\n    printf(\"%lld\\n\" , ans ) ;\n    return 0 ;\n}\n\n```\n\n",
        "postTime": 1571932369,
        "uid": 119610,
        "name": "Regimes",
        "ccfLevel": 7,
        "title": "CF1109F Sasha and Algorithm of Silence's Sounds"
    },
    {
        "content": "~~\u5b9a\u4e49\u4e0d\u4e25\u8c28\uff0c\u72060\u4e24\u884c\u6cea~~\n\n\u6211\u4e00\u5f00\u59cb\u7684\u65f6\u5019\u89c9\u5f97\u53ea\u8981\u6709$n-1$\u6761\u8fb9\u90a3\u4e0d\u5c31\u662f\u6811\u4e86\u5417\uff1f\u7136\u540e\u5c31\u628a\u6240\u6709\u8fb9\u63d0\u51fa\u6765\u53bb\u641e\u6210\u533a\u95f4\u7ef4\u62a4\u7684\u7ecf\u5178\u95ee\u9898\uff0c\u7ed3\u679c\u5199\u5b8c\u4e4b\u540e\u53d1\u73b0\u8fde\u6837\u4f8b\u90fd\u8fc7\u4e0d\u53bb\u2026\u2026\n\n\u56e0\u4e3a\u5b9e\u9645\u4e0a\u6811\u7684\u4e25\u8c28\u5b9a\u4e49\u662f\u7531$n-1$\u6761\u8fb9\u6784\u6210\u7684**\u8fde\u901a\u56fe**\u2026\u2026\u5982\u679c\u56fe\u4e0d\u8fde\u901a\u7684\u8bdd\u4f1a\u53d1\u751f\u4e00\u4e9b\u6709\u8da3\u7684\u4e8b\u60c5\uff1a\n\n![](https://cdn.luogu.com.cn/upload/pic/59265.png)\n\n\u6bd4\u5982\u8fd9\u4e2a\u5c31\u67096\u4e2a\u70b9\uff0c5\u6761\u8fb9\uff0c\u4f46\u662f\u5b83\u6709\u73af\uff0c\u5b83\u8fd8\u4e0d\u8fde\u901a\u2026\u2026\n\n\u4f46\u662f\u4f60\u5982\u679c\u8981\u52a0\u4e0a\u201c\u53ea\u7edf\u8ba1\u4e0e\u4e4b\u8fde\u901a\u7684\u90e8\u5206\u201d\u8fd9\u4e2a\u9650\u5236\u7684\u8bdd\u90a3\u53ef\u80fd\u4f1a\u975e\u5e38\u56f0\u96be\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u6ca1\u6709\u4efb\u4f55\u5355\u8c03\u6027\u4e4b\u7c7b\u7684\u53ef\u8a00\uff0c\u6240\u4ee5\u6211\u4eec\u8981\u60f3\u529e\u6cd5\u4ece\u4e00\u4e9b\u522b\u7684\u89d2\u5ea6\u4fee\u9505\u3002\n\n\u6211\u4eec\u53d1\u73b0\u51fa\u73b0\u8fd9\u79cd\u60c5\u51b5\u7684\u539f\u56e0\u4e0d\u4ec5\u662f\u5b83\u4e0d\u8fde\u901a\uff0c\u8fd8\u56e0\u4e3a\u5b83\u6709\u73af\u3002\u800c**\u6709\u73af**\u8fd9\u4e2a\u4e1c\u897f\u662f\u5177\u6709\u5355\u8c03\u6027\u7684\uff0c\u56e0\u4e3a\u5f80\u4e00\u4e2a\u6709\u73af\u7684\u56fe\u91cc\u9762\u518d\u52a0\u8fb9\u8fd8\u662f\u6709\u73af\u7684\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u4e0d\u59a8\u5c31\u679a\u4e3e$l$\uff08\u5982\u679c\u679a\u4e3e\u7684\u662f$r$\u53ef\u80fd\u4f1a\u975e\u5e38\u9ebb\u70e6\uff09\uff0c\u53f3\u7aef\u70b9$r$\u7528\u5355\u8c03\u4e0d\u964d\u7684\u53cc\u6307\u9488\u7ef4\u62a4\uff0c\u8fd9\u6837\u5c31\u77e5\u9053\u4e86$[l,r]$\u5185\u7684\u4f5c\u4e3a\u53f3\u7aef\u70b9\u90fd\u662f\u65e0\u73af\u7684\u3002$l$\u5728\u5f80\u53f3\u79fb\u52a8\u7684\u65f6\u5019\u662f\u8981\u5220\u8fb9\u7684\uff08\u5220\u53bb\u7684\u4e00\u5b9a\u662f\u6811\u8fb9\uff09\uff0c$r$\u5728\u5f80\u53f3\u79fb\u52a8\u7684\u65f6\u5019\u662f\u8981\u52a0\u8fb9\u5e76\u4e14\u5224\u65ad\u662f\u5426\u6709\u73af\u7684\uff0c\u8fd9\u4e2a\u7528$LCT$\u7ef4\u62a4\u5c31\u597d\u4e86\u3002\n\n\u8fd9\u6837\u7684\u8bdd\uff0c\u6211\u4eec\u77e5\u9053\u73b0\u5728\u7684\u533a\u95f4\u91cc\u80af\u5b9a\u662f\u6ca1\u73af\u7684\uff0c\u7136\u540e\u6211\u4eec\u627e\u6709\u591a\u5c11\u533a\u95f4\u5185\u7684\u8fb9\u662f\u70b9\u6570-1\u7684\u5c31\u6ca1\u6709\u4efb\u4f55\u95ee\u9898\u4e86\u3002\u5176\u5b9e\u8fd9\u4e2a\u53ef\u4ee5\u8f6c\u5316\u6210**\u70b9\u6570-\u8fb9\u6570=1**\u7136\u540e\u7ef4\u62a4\u70b9\u6570-\u8fb9\u6570\uff0c\u8fd9\u4e2a\u6700\u5c0f\u503c\u672c\u6765\u5c31\u662f1\u6240\u4ee5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6700\u5c0f\u503c\u4e2a\u6570\u5373\u53ef\u3002\n\n\u4e0a\u4ee3\u7801~\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define ll long long\n#define ls(_o) (_o << 1)\n#define rs(_o) ((_o << 1) | 1)\n#define isroot(_o) (_o != ch[fa[_o]][0] && _o != ch[fa[_o]][1])\n#define opp(_o) (_o == ch[fa[_o]][1])\n#define up(_o) data[_o] = data[ls(_o)] + data[rs(_o)]\nusing namespace std;\nnamespace ywy {\n\tinline int get() {\n\t    int n = 0;\n\t    char c;\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            break;\n\t        if (c == '-')\n\t            goto s;\n\t    }\n\t    n = c - '0';\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 + c - '0';\n\t        else\n\t            return (n);\n\t    }\n\ts:\n\t    while ((c = getchar()) || 23333) {\n\t        if (c >= '0' && c <= '9')\n\t            n = n * 10 - c + '0';\n\t        else\n\t            return (n);\n\t    }\n\t}\n\tvector<int> vec[200001];\n\tint v[2001][2001], lx[4] = { 1, -1, 0, 0 }, ly[4] = { 0, 0, 1, -1 };\n\tint ch[200001][2], fa[200001], stk[200001];\n\tunsigned char bj[200001];\n\ttypedef struct _n {\n\t    int minn;\n\t    int cnt;\n\t    friend _n operator+(const _n &a, const _n &b) {\n\t        _n c;\n\t        c.minn = min(a.minn, b.minn);\n\t        c.cnt = 0;\n\t        if (a.minn == c.minn)\n\t            c.cnt = a.cnt;\n\t        if (b.minn == c.minn)\n\t            c.cnt += b.cnt;\n\t        return (c);\n\t    }\n\t} node;\n\tnode data[1000001];\n\tint adds[1000001];\n\tinline void down(int tree) {\n\t    if (bj[tree])\n\t        bj[tree] = 0, bj[ch[tree][0]] ^= 1, bj[ch[tree][1]] ^= 1, swap(ch[tree][0], ch[tree][1]);\n\t}\n\tinline void pushdown(int tree) {\n\t    if (!adds[tree])\n\t        return;\n\t    adds[ls(tree)] += adds[tree];\n\t    adds[rs(tree)] += adds[tree];\n\t    data[ls(tree)].minn += adds[tree];\n\t    data[rs(tree)].minn += adds[tree];\n\t    adds[tree] = 0;\n\t}\n\tinline void xuan(int me) {\n\t    int tree = fa[me], cjr = fa[tree];\n\t    down(cjr);\n\t    down(tree);\n\t    down(me);\n\t    int op = opp(me), ls = ch[me][op ^ 1];\n\t    ch[tree][op] = ls;\n\t    fa[ls] = tree;\n\t    ch[me][op ^ 1] = tree;\n\t    if (!isroot(tree))\n\t        ch[cjr][opp(tree)] = me;\n\t    fa[tree] = me;\n\t    fa[me] = cjr;\n\t}\n\tinline void splay(int tree) {\n\t    if (isroot(tree)) {\n\t        down(tree);\n\t        return;\n\t    }\n\t    int sp = 0, tmp = tree;\n\t    while (!isroot(tmp)) stk[sp] = tmp, sp++, tmp = fa[tmp];\n\t    down(tmp);\n\t    while (sp) sp--, down(stk[sp]);\n\t    while (!isroot(tree)) {\n\t        int cjr = fa[tree];\n\t        if (!isroot(cjr))\n\t            xuan((opp(cjr) == opp(tree)) ? cjr : tree);\n\t        xuan(tree);\n\t    }\n\t}\n\tinline void access(int tree) {\n\t    splay(tree);\n\t    down(tree);\n\t    ch[tree][1] = 0;\n\t    while (fa[tree]) {\n\t        int cjr = fa[tree];\n\t        splay(cjr);\n\t        down(cjr);\n\t        ch[cjr][1] = tree;\n\t        splay(tree);\n\t    }\n\t}\n\tinline void makeroot(int tree) {\n\t    access(tree);\n\t    splay(tree);\n\t    bj[tree] ^= 1;\n\t}\n\tinline int findroot(int tree) {\n\t    access(tree);\n\t    splay(tree);\n\t    down(tree);\n\t    while (ch[tree][0]) tree = ch[tree][0], down(tree);\n\t    splay(tree);\n\t    return (tree);\n\t}\n\tinline void link(int a, int b) {\n\t    makeroot(a);\n\t    fa[a] = b;\n\t}\n\tinline void cut(int a, int b) {\n\t    makeroot(a);\n\t    access(b);\n\t    splay(a);\n\t    down(a);\n\t    fa[b] = ch[a][1] = 0;\n\t}\n\tnode query(int rl, int rr, int l, int r, int tree) {\n\t    if (rl == l && rr == r)\n\t        return (data[tree]);\n\t    int mid = (l + r) >> 1;\n\t    pushdown(tree);\n\t    if (rl > mid)\n\t        return (query(rl, rr, mid + 1, r, rs(tree)));\n\t    if (rr <= mid)\n\t        return (query(rl, rr, l, mid, ls(tree)));\n\t    return (query(rl, mid, l, mid, ls(tree)) + query(mid + 1, rr, mid + 1, r, rs(tree)));\n\t}\n\tvoid add(int rl, int rr, int l, int r, int tree, int x) {\n\t    if (rl == l && rr == r) {\n\t        adds[tree] += x;\n\t        data[tree].minn += x;\n\t        return;\n\t    }\n\t    int mid = (l + r) >> 1;\n\t    pushdown(tree);\n\t    if (rl > mid)\n\t        add(rl, rr, mid + 1, r, rs(tree), x);\n\t    else {\n\t        if (rr <= mid)\n\t            add(rl, rr, l, mid, ls(tree), x);\n\t        else {\n\t            add(rl, mid, l, mid, ls(tree), x);\n\t            add(mid + 1, rr, mid + 1, r, rs(tree), x);\n\t        }\n\t    }\n\t    up(tree);\n\t}\n\tint links[200001];\n\tvoid build(int l, int r, int tree) {\n\t    if (l == r) {\n\t        data[tree].minn = 0;\n\t        data[tree].cnt = 1;\n\t        return;\n\t    }\n\t    int mid = (l + r) >> 1;\n\t    build(l, mid, ls(tree));\n\t    build(mid + 1, r, rs(tree));\n\t    up(tree);\n\t}\n\tvoid ywymain() {\n\t    int n = get(), m = get();\n\t    for (register int i = 1; i <= n; i++) {\n\t        for (register int j = 1; j <= m; j++) v[i][j] = get();\n\t    }\n\t    for (register int i = 1; i <= n; i++) {\n\t        for (register int j = 1; j <= m; j++) {\n\t            for (register int k = 0; k < 4; k++) {\n\t                int ix = j + lx[k], iy = i + ly[k];\n\t                if (ix < 1 || iy < 1 || ix > m || iy > n)\n\t                    continue;\n\t                if (v[i][j] > v[iy][ix])\n\t                    vec[v[i][j]].push_back(v[iy][ix]), vec[v[iy][ix]].push_back(v[i][j]);\n\t            }\n\t        }\n\t    }\n\t    n *= m;\n\t    build(1, n, 1);\n\t    add(1, n, 1, n, 1, 1);\n\t    int ptr = 1;\n\t    ll ans = 0;\n\t    for (register int i = 1; i <= n; i++) {\n\t        while (ptr < n) {\n\t            int sp = 0;\n\t            for (register int j = 0; j < vec[ptr + 1].size(); j++) {\n\t                if (vec[ptr + 1][j] < i || vec[ptr + 1][j] > ptr + 1)\n\t                    continue;\n\t                makeroot(ptr + 1);\n\t                if (findroot(vec[ptr + 1][j]) == ptr + 1) {\n\t                    while (sp) sp--, cut(ptr + 1, links[sp]);\n\t                    goto s;\n\t                }\n\t                link(ptr + 1, vec[ptr + 1][j]);\n\t                links[sp] = vec[ptr + 1][j], sp++;\n\t            }\n\t            ptr++;\n\t            for (register int j = 0; j < vec[ptr].size(); j++) {\n\t                if (vec[ptr][j] >= i && vec[ptr][j] < ptr)\n\t                    add(ptr, n, 1, n, 1, -1);\n\t            }\n\t            add(ptr, n, 1, n, 1, 1);\n\t        }\n\t    s:;\n\t        node cjr = query(i, ptr, 1, n, 1);\n\t        if (cjr.minn == 1)\n\t            ans += cjr.cnt;\n\t        add(i, n, 1, n, 1, -1);\n\t        for (register int j = 0; j < vec[i].size(); j++) {\n\t            if (vec[i][j] >= i && vec[i][j] <= ptr) {\n\t                add(vec[i][j], n, 1, n, 1, 1);\n\t                cut(i, vec[i][j]);\n\t            }\n\t        }\n\t    }\n\t    cout << ans << endl;\n\t}\n}\nint main() {\n    ywy::ywymain();\n    return (0);\n}\n```",
        "postTime": 1558573517,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF1109F \u3010Sasha and Algorithm of Silence's Sounds\u3011"
    },
    {
        "content": "### Solutions\n\n\u6211\u4eec\u5148\u56fa\u5b9a\u5de6\u7aef\u70b9\uff0c\u7136\u540e\u5bf9\u6bcf\u4e00\u4e2a\u5de6\u7aef\u70b9\u90fd\u627e\u5230\u53ef\u4ee5\u6ee1\u8db3\u6761\u4ef6\u7684\u6700\u5927\u7684\u53f3\u7aef\u70b9\u3002\u663e\u7136\u8fd9\u662f\u6709\u5355\u8c03\u6027\u7684\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4\u5982\u679c\u5305\u542b\u4e86\u53ef\u4ee5\u5f62\u6210\u73af\u7684\u5b50\u533a\u95f4\uff0c\u90a3\u8fd9\u4e2a\u533a\u95f4\u4e5f\u4e00\u5b9a\u6709\u73af\u3002\n\n\u8fde\u8fb9\u548c\u65ad\u8fb9\u53ef\u4ee5\u7528 LCT \u89e3\u51b3\uff0c\u4e4b\u540e\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u5185\u80fd\u6784\u6210\u6811\u7684\u5b50\u533a\u95f4\u7684\u4e2a\u6570\uff0c\u5373\u70b9\u6570\u4e0e\u8fb9\u6570\u4e4b\u5dee\u4e3a $1$ \u7684\u5b50\u533a\u95f4\u3002\n\n\u6700\u540e\u5c06\u6bcf\u4e00\u79cd\u60c5\u51b5\u7684\u7b54\u6848\u7d2f\u8ba1\u8d77\u6765\u5c31\u662f\u6700\u7ec8\u7b54\u6848\u3002\n\n### Code\n\n```cpp\n#include<bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define ls k<<1\n#define rs k<<1|1\nusing namespace std;\nconst int N=4e5+5;\nconst int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nstruct Link_Cut_Tree{\n\tint ch[N][2],fa[N],tag[N];\n\tbool isroot(int x){\n\t\treturn ch[fa[x]][1]!=x && ch[fa[x]][0]!=x;\n\t}\n\tvoid pushr(int x){\n\t\tif(!x) return;\n\t\tswap(ch[x][0],ch[x][1]);\n\t\ttag[x]^=1;\n\t}\n\tvoid push_down(int x){\n\t\tif(!tag[x]) return;\n\t\tpushr(ch[x][0]);\n\t\tpushr(ch[x][1]);\n\t\ttag[x]=0;\n\t}\n\tvoid push_all(int x){\n\t\tif(!isroot(x)) push_all(fa[x]);\n\t\tpush_down(x);\n\t}\n\tvoid rotate(int x){\n\t\tint y=fa[x],z=fa[y],k=(ch[y][0]==x);\n\t\tif(!isroot(y)) ch[z][ch[z][1]==y]=x;\n\t\tfa[x]=z;\n\t\tfa[y]=x,fa[ch[x][k]]=y;\n\t\tch[y][k^1]=ch[x][k],ch[x][k]=y;\n\t}\n\tvoid splay(int x){\n\t\tpush_all(x);\n\t\twhile(!isroot(x)){\n\t\t\tint y=fa[x],z=fa[y];\n\t\t\tif(!isroot(y)) rotate((ch[y][1]==x)^(ch[z][1]==y)?x:y);\n\t\t\trotate(x);\n\t\t}\n\t}\n\tvoid access(int x){\n\t\tfor(int y=0;x;y=x,x=fa[x]){\n\t\t\tsplay(x);\n\t\t\tch[x][1]=y;\n\t\t}\n\t}\n\tvoid makeroot(int x){\n\t\taccess(x),splay(x),pushr(x);\n\t}\n\tint findroot(int x){\n\t\taccess(x),splay(x);\n\t\twhile(ch[x][0]) x=ch[x][0];\n\t\tsplay(x);\n\t\treturn x;\n\t}\n\tbool link(int x,int y){\n\t\tmakeroot(x);\n\t\tif(findroot(y)==x) return 0;\n\t\tfa[x]=y;\n\t\treturn 1;\n\t}\n\tvoid cut(int x,int y){\n\t\tmakeroot(x);\n\t\tif(findroot(y)!=x || fa[y]!=x || ch[y][0]) return;\n\t\tfa[y]=ch[x][1]=0;\n\t}\n}lct;\nstruct Segment_Tree{\n\tstruct tree{\n\t\tint l,r,sum,mn,add;\n\t}tr[N<<2];\n\tvoid pushdown(int k){\n\t\tif(!tr[k].add) return;\n\t\ttr[ls].add+=tr[k].add,tr[rs].add+=tr[k].add;\n\t\ttr[ls].mn+=tr[k].add,tr[rs].mn+=tr[k].add;\n\t\ttr[k].add=0;\n\t}\n\tvoid pushup(int k){\n\t\tif(tr[ls].mn<tr[rs].mn) tr[k].mn=tr[ls].mn,tr[k].sum=tr[ls].sum;\n\t\telse if(tr[ls].mn>tr[rs].mn) tr[k].mn=tr[rs].mn,tr[k].sum=tr[rs].sum;\n\t\telse tr[k].mn=tr[ls].mn,tr[k].sum=tr[ls].sum+tr[rs].sum;\n\t}\n\tvoid build(int k,int l,int r){\n\t\ttr[k].l=l,tr[k].r=r;\n\t\tif(l==r){\n\t\t\ttr[k].mn=0,tr[k].sum=1;\n\t\t\treturn;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tbuild(ls,l,mid);\n\t\tbuild(rs,mid+1,r);\n\t\tpushup(k);\n\t}\n\tvoid update(int k,int l,int r,int v){\n\t\tif(tr[k].l>=l && tr[k].r<=r){\n\t\t\ttr[k].add+=v,tr[k].mn+=v;\n\t\t\treturn;\n\t\t}\n\t\tpushdown(k);\n\t\tint mid=tr[k].l+tr[k].r>>1;\n\t\tif(l<=mid) update(ls,l,r,v);\n\t\tif(r>mid) update(rs,l,r,v);\n\t\tpushup(k);\n\t}\n\tint query(int k,int l,int r){\n\t\tif(tr[k].l>=l && tr[k].r<=r){\n\t\t\tif(tr[k].mn==1) return tr[k].sum;\n\t\t\treturn 0;\n\t\t}\n\t\tpushdown(k);\n\t\tint mid=tr[k].l+tr[k].r>>1,res=0;\n\t\tif(l<=mid) res+=query(ls,l,r);\n\t\tif(r>mid) res+=query(rs,l,r);\n\t\treturn res;\n\t}\n}T;\nvector<int>g[N];\nint n,m,a[3005][3005],ans;\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0),cout.tie(0);\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j) cin>>a[i][j];\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=m;++j)\n\t\t\tfor(int k=0;k<4;++k){\n\t\t\t\tint x=i+dx[k],y=j+dy[k];\n\t\t\t\tif(x<1 || x>n || y<1 || y>m) continue;\n\t\t\t\tif(a[x][y]>a[i][j]) continue;\n\t\t\t\tg[a[x][y]].push_back(a[i][j]);\n\t\t\t\tg[a[i][j]].push_back(a[x][y]);\n\t\t\t}\n\tint r=0,lst=n*m;\n\tT.build(1,1,lst);\n\tfor(int i=1;i<=lst;++i){\n\t\tfor(int j=r+1;j<=lst;++j){\n\t\t\tint cur=j,flg=0;\n\t\t\tfor(int k=0;k<g[cur].size();++k){\n\t\t\t\tint tmp=g[cur][k];\n\t\t\t\tif(tmp<cur && tmp>=i && !lct.link(tmp,cur)){\n\t\t\t\t\tflg=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<g[cur].size();++k) lct.cut(cur,g[cur][k]);\n\t\t\tif(flg) break;\n\t\t\tr=j;\n\t\t\tint eja=0;\n\t\t\tfor(int k=0;k<g[cur].size();++k){\n\t\t\t\tint tmp=g[cur][k];\n\t\t\t\tif(tmp<j && tmp>=i) lct.link(tmp,cur);\n\t\t\t\tif(tmp<j && tmp>=i) eja++;\n\t\t\t}\n\t\t\tT.update(1,r,r,r-i+1);\n\t\t\tT.update(1,r,lst,-eja);\n\t\t}\n\t\tans+=T.query(1,i,r);\n\t\tint eja=0;\n\t\tfor(int j=0;j<g[i].size();++j)\n\t\t\tif(g[i][j]<=r && g[i][j]>i){\n\t\t\t\tlct.cut(g[i][j],i);\n\t\t\t\tT.update(1,g[i][j],lst,1);\n\t\t\t}\n\t\tT.update(1,i,r,-1);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n```\n",
        "postTime": 1683291864,
        "uid": 491321,
        "name": "Erotate",
        "ccfLevel": 0,
        "title": "Sasha and Algorithm of Silence's Sounds \u9898\u89e3"
    },
    {
        "content": "# \u9898\u610f\n\n\u7ed9\u5b9a $n*m$ \u7684\u7f51\u683c\u56fe\uff0c\u6bcf\u683c\u6709\u4e00\u4e2a\u503c\u5728 $[1, n*m]$ \u8303\u56f4\u5185\u4e14\u4e0d\u91cd\u590d\u3002\u73b0\u95ee\u6709\u591a\u5c11\u4e2a\u503c\u57df $[l, r]$ \u4f7f\u7531\u6240\u6709\u6709\u8be5\u503c\u57df\u8303\u56f4\u4e2d\u7684\u503c\u7684\u65b9\u683c\u4e0a\u4e0b\u5de6\u53f3\u8fde\u63a5\u5f62\u6210\u7684\u56fe\u4e3a\u4e00\u9897\u6811\u3002\n\n\n# \u4e00\u4e9b\u5e9f\u8bdd\n\n\u7f51\u4e0a\u51e0\u7bc7\u5927\u4f6c\u9898\u89e3\u90fd\u662f\u7b80\u5355\u63d0\u4e00\u4e0b\u601d\u8def\u5c31\u7b80\u5355\u5e26\u8fc7\uff0c\u4f46\u6211\u8fd9\u79cd\u521a\u5b66\u5b8clct\u60f3\u62ff\u9053\u6bd4\u8d5b\u9898\u8bd5\u8bd5\u624b\u7684\u849f\u84bb\u5b8c\u5168\u4e0d\u61c2a\uff08\n\n\u4e8e\u662f\u4e0b\u9762\u6211\u4f1a\u8be6\u7ec6\u8bb2\u4e0b\u601d\u8003\u8fc7\u7a0b\u53ca\u5b9e\u73b0\uff0c\u4e0d\u60f3\u770b\u6211\u7684\u5e9f\u8bdd\u7684\u8bdd\u53ef\u4ee5\u770b\u770b\u5176\u4ed6\u4e24\u7bc7\u7b80\u6d01\u7684\u9898\u89e3\n\n\u4ee5\u53ca\u56e0\u4e3a\u5b9e\u5728\u770b\u4e0d\u61c2\u7f51\u4e0a\u51e0\u7bc7\u9898\u89e3\u7684\u4ee3\u7801\uff0c\u8fd9\u91cc\u5bf9\u7b54\u6848\u7684\u7ef4\u62a4\u53ef\u80fd\u4f1a\u6bd4\u8f83\u7e41\u7410\uff08\u5206\u7c7b\u8ba8\u8bba\uff09\u3002\u8c01\u80fd\u770b\u61c2\u53e6\u5916\u51e0\u7bc7\u7b80\u5316\u7684\u4ee3\u7801\u662f\u4ec0\u4e48\u610f\u601d\u8bf7\u52a1\u5fc5\u544a\u8bc9\u6211\uff01\n\n# \u89e3\u6cd5\n\n\u9898\u76ee\u8ba9\u6211\u4eec\u6c42\u533a\u95f4\u6570\uff0c\u53ef\u4ee5\u66b4\u529b\u5730\u60f3\u5230\u679a\u4e3e $l, r$ \u3002\u4e8e\u662f\u6211\u4eec\u56fa\u5b9a $l$\uff0c\u53ef\u4ee5\u53d1\u73b0\u82e5\u56fe\u4e2d\u6709\u73af\uff0c\u7ee7\u7eed\u589e\u52a0\u8282\u70b9\uff08\u589e\u5927 $r$\uff09\u73af\u4f9d\u7136\u5b58\u5728\uff1b\u7136\u540e\u53c8\u53d1\u73b0\u968f\u7740 $l$ \u7684\u589e\u5927 $r$ \u662f\u4e0d\u51cf\u7684\uff1a\u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u6709\u4e00\u79cd $O(n)$ \u7684\u7edf\u8ba1\u7b54\u6848\u53ef\u80fd\u5b58\u5728\u7684\u533a\u95f4\u7684\u65b9\u6cd5\u3002\n\n\u90a3\u4e48\u73b0\u5728\u7684\u95ee\u9898\u5c31\u662f\u5982\u4f55\u68c0\u67e5\u73af\u548c\u7ef4\u62a4\u7b54\u6848\uff08\u8bf4\u5b9e\u8bdd\u6211\u4e5f\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u8fd9\u4e2a\u601d\u8003\u65b9\u5411\u5c31\u4e00\u5b9a\u662f\u5bf9\u7684...\u5b8c\u5168\u662f\u770b\u6807\u7a0b\u63a8\u51fa\u8fd9\u4e2a\u65b9\u5411\u7684 \uff09\u3002\u7ef4\u62a4\u56fe\u6211\u4eec\u9700\u8981\u7528\u5230 LCT \uff08\u7ef4\u62a4\u6811\u8fb9\uff0c\u52a8\u6001\u8fb9\u64cd\u4f5c\uff09\uff1b\u800c\u7ef4\u62a4\u7b54\u6848\u53ef\u4ee5\u8003\u8651\u7528\u7ebf\u6bb5\u6811\uff1a\n\n\u6211\u4eec\u8bbe\u533a\u95f4 $[1, m*n]$ \u4e3a\u4ee5 **\u5f53\u524d$l$** \u4e3a\u5de6\u8fb9\u754c\u65f6 \u53f3\u8fb9\u754c $r$ \u4e3a\u5bf9\u5e94\u503c\u65f6\u7684\u6811\u6570\u76ee\uff08\u72b6\u6001\uff09\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u7edf\u8ba1\u533a\u95f4\u6700\u5c0f\u503c\u6570\u91cf\uff0c\u67e5\u8be2\u65f6\u82e5\u6700\u5c0f\u503c\u975e $1$ \u8fd4\u56de $0$ \u5373\u53ef\u3002\n\n\u53d1\u73b0 \u5bf9\u4e8e$r_2=r_1+1$\uff0c$r_2$\u7b54\u6848\u662f\u53ef\u4ee5\u7531$r_1$\u9012\u63a8\u51fa\u6765\u7684\uff08\u589e\u52a0\u4e00\u4e2a\u70b9\uff09\u3002\u4e8e\u662f\u5982\u4f55**\u5728\u589e\u5927 $r$ \u65f6\u5bf9\u7b54\u6848\u8fdb\u884c\u7ef4\u62a4**\u5c31\u663e\u800c\u6613\u89c1\uff1a\u6bcf\u6b21\u589e\u52a0\u65b0\u7684\u70b9\uff08\u589e\u5927 r\uff09\u5c31\u5224\u65ad\u662f\u5426\u5408\u5e76\u4e86\u6811\u5e76\u5728\u7ebf\u6bb5\u6811\u4e2d\u4fee\u6539\u5bf9\u5e94\u7684\u70b9\u7684\u7b54\u6848\uff08\u7a0b\u5e8f\u4e2d\u4e3a\u4e86\u907f\u514d\u591a\u6b21\u8bbf\u95ee\u4e0a\u4e00\u4e2a r \u7684\u7b54\u6848\u76f4\u63a5\u589e\u51cf\u4e86\u533a\u95f4 $[r, m*n]$\uff09\u3002\n\n\u5f53 $l$ \u589e\u5927\u65f6\uff08\u5220\u9664\u70b9\uff09\uff0c\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff1a\n\n1. \u4e0d\u65ad\u5f00\u8fb9\n2. \u65ad\u5f00\u4e00\u6761\u8fb9\n3. \u65ad\u5f00\u591a\u6761\u8fb9\n\n\n\u8fd9\u4e09\u79cd\u60c5\u51b5\u6211\u4eec\u8981\u5bf9\u7b54\u6848\u505a\u4e0d\u540c\u7684\u4fee\u6539\u3002\u6ce8\u610f\uff1a\u5bf9\u4e8e\u6b63\u7ef4\u62a4\u7684\u4e0d\u540c\u7684\u7ebf\u6bb5\u6811\u70b9\u72b6\u6001\u4e0d\u540c\uff08\u533a\u95f4-\u72b6\u6001\u96c6\uff09\uff0c\u53ef\u80fd\u5206\u522b\u5bf9\u5e94\u4e0d\u540c\u7684\u60c5\u51b5\u3002\u4f53\u73b0\u5230\u5b9e\u73b0\u5c31\u662f**\u5bf9\u7ebf\u6bb5\u6811\u7684\u51e0\u6bb5\u533a\u95f4\u505a\u4e0d\u540c\u7684\u64cd\u4f5c**\u3002\n\n\u6211\u4eec\u8bb0\u5f55\u65ad\u5f00\u7684\u8fb9\u8fde\u63a5\u7684\u65b9\u683c\u5e76\u5c06\u503c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u8bbe\u4e3a $[v1, v2, v3, v4]$\u3002\u53ef\u4ee5\u53d1\u73b0\uff1a\n\n1. \u5bf9\u4e8e $[l+1, v1-1]$\uff0c\u5220\u53bb\u8be5\u70b9\uff08$l$\uff09\u4f1a\u4f7f\u6811\u6570\u76ee\u51cf\u5c11$1$\n2. \u5bf9\u4e8e$[v1, v2-1]$\uff0c\u5220\u53bb\u8be5\u70b9\u4e0d\u4f1a\u6709\u4efb\u4f55\u5f71\u54cd\n3. \u5bf9\u4e8e$[v2, v3-1]$\uff0c$[v3, v4-1]$\uff0c$[v4, m*n]$\uff0c\u5220\u53bb\u8be5\u70b9\u4f1a\u589e\u52a0\u6811\u7684\u6570\u76ee\uff0c\u6bcf\u7ecf\u8fc7\u4e00\u6bb5\uff08\u72b6\u6001\uff09\u533a\u95f4\u5c31\u591a\u589e\u52a0\u4e00\u68f5\u6811\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7528\u7c7b\u4f3c\u7ef4\u62a4 r \u7684\u65b9\u6cd5\u53bb\u4fee\u6539\u5b83\n\n\n![1](https://cdn.luogu.com.cn/upload/image_hosting/w8fwtla2.png)\n\n\uff08 $7$ \u4e3a\u5220\u53bb\u7684\u70b9\uff0c\u6ca1\u6709\u533a\u95f4$-1$\uff0c$[8, 16]$\u4e0d\u53d8\uff0c$[17, 18]$$+1$\uff0c$[19, m*n]$$+2$\u3002\u6ce8\u610f\u7ef4\u62a4 $l$ \u65f6 $r$ \u662f\u4e0d\u52a8\u7684\uff0c\u5373\u53ef\u4ee5\u77e5\u9053\u9664\u4e86 $7$ \u4e0d\u53ef\u80fd\u6709\u8282\u70b9\u5c06 $17, 19, 8$ \u5206\u522b\u8fde\u8d77\u6765\uff08\u4fdd\u8bc1\u65e0\u73af\uff09\uff09 \n\n\u82e5\u8bb0\u5f55\u7684\u70b9\u6570\u76ee\u4e0d\u591f\u5c31\u4fee\u6539\u81f3 $m*n$ \u5c31\u53ef\u4ee5\u4e86\uff1a\n\n\u4e3e\u4f8b\uff0c\u53ea\u627e\u5230 v1 \u5c31\u4ec5\u4fee\u6539 $[l+1, v1-1]$ \u51cf\u4e00\u3001 $[v1, m*n]$ \u4e0d\u4fee\u6539\u3002\n\n# Code\n\n\u4ee3\u7801\u7684\u7ed3\u6784\u548c\u4e0a\u6587\u5206\u6790\u7684\u90fd\u5dee\u4e0d\u591a\n\n\u51e0\u4e2a\u5c0f\u7ec6\u8282\u662f\uff1a\n1. \u8bbe\u7f6e r2 \u7b80\u5355\u5730\u907f\u514d r \u8d8a\u754c\n2. \u53f3\u79fb r \u65f6\"\u6a21\u62df\u8fde\u8fb9\"\u4ee5\u5224\u73af\uff0c\u82e5\u627e\u5230\u73af\u65ad\u8fb9\n3. \u53f3\u79fb l \u5e76\u7ef4\u62a4\u7b54\u6848\u65f6\u4e3a\u907f\u514d\u64cd\u4f5c\u8d8a\u754c\uff08$l>r$\uff09\uff0c\u5b9e\u9645\u4fee\u6539\u7684\u533a\u95f4\u5de6\u8fb9\u754c\u4e3a $[l, $\n\n```cpp\n#include <cstdio>\n#include <algorithm>\nusing std::sort;\n\nconst int MAXN =2*1e5+50;\n\nint c[2][MAXN], f[MAXN];\nbool rev[MAXN];\n\ninline void pushdown(int x){\n\tif(rev[x]){\n\t\trev[c[0][x]] ^=1, rev[c[1][x]] ^=1;\n\t\tc[0][x] ^=c[1][x] ^=c[0][x] ^=c[1][x];\n\t\trev[x] =0;\n\t}\n}\n\ninline bool isroot(int x){ return (!(c[0][f[x]] == x || c[1][f[x]] == x) || f[x] == 0/*\u907f\u514d\u672a\u77e5\u9519\u8bef*/); }\n\ninline bool get(int x){ return c[1][f[x]] == x; }\n\ninline void rotate(int x){\n\tbool r =get(x), rf =get(f[x]);\n\tint y =f[x], z =f[y], a =c[!r][x];\n\tf[x] =z; if(!isroot(y)) c[rf][z] =x;\n\tf[y] =x, c[!r][x] =y;\n\tf[a] =y, c[r][y] =a;\n}\n\ninline void pushall(int x){\n\tif(!isroot(x)) pushall(f[x]);\n\tpushdown(x);\n}\n\ninline void splay(int x){\n\tpushall(x);\n\tfor(; !isroot(x); rotate(x))\n\t\tif(!isroot(f[x])) rotate((get(f[x]) == get(x)) ? f[x] : x);\n}\n\ninline void access(int x){\n\tfor(int pre =0; x; pre =x, x =f[x]){\n\t\tsplay(x);/*\u8fd9\u91cc\u7684x\u4e0d\u4e00\u5b9a\u662f\u521d\u59cb\u7684*/\n\t\tc[1][x] =pre;\n\t}\n}\n\ninline void setroot(int x){\n\taccess(x), splay(x);\n\trev[x] =1;\n}\n\ninline bool connected(int x, int y){\n\tif(x == y) return 1;\n\taccess(x), splay(x);\n\taccess(y), splay(y)/*\u53ef\u80fd\u6839splay\u5c31x\uff0cx\u672c\u5c31\u662f\u6839*/;\n\treturn f[x] != 0;\n}\n\ninline void cut(int x, int y){\n\t/*\u53ef\u80fd\u4e0d\u5fc5\u8981\u5730\u6539\u53d8 x\u6811\u7684\u6839*/\n\tsetroot(x), access(y), splay(x)/*access\u524d x,y\u53ef\u80fd\u5728\u540c\u4e00splay*/;\n\t//if(c[1][x] != y) return 0;\n\tc[1][x] =f[y] =0;\n}\n\ninline void link(int x, int y){\n\t//if(connected(x, y)) return 0;\n\tsetroot(x); f[x] =y;\n}\n\nint N =1, min[3*MAXN], cnt[3*MAXN], det[3*MAXN];\nbool lazy[3*MAXN];\n\ninline void pushupSeg(int v){\n\tif(min[v<<1] == min[(v<<1)|1]){\n\t\tmin[v] =min[v<<1];\n\t\tcnt[v] =cnt[v<<1]+cnt[(v<<1)|1];\n\t}\n\telse if(min[v<<1] < min[(v<<1)|1]) min[v] =min[v<<1], cnt[v] =cnt[v<<1];\n\telse min[v] =min[(v<<1)|1], cnt[v] =cnt[(v<<1)|1];\n}\n\ninline void pushdownSeg(int v){\n\tif(lazy[v]){\n\t\tmin[v<<1] +=det[v], min[(v<<1)|1] +=det[v];\n\t\tdet[v<<1] +=det[v], det[(v<<1)|1] +=det[v];\n\t\tlazy[v<<1] =lazy[(v<<1)|1] =1;\n\t\tlazy[v] =0;\n\t\tdet[v] =0;/**/\n\t}\n}\n\ninline void updata(int l, int r, int d, int v =1, int nl =1, int nr =N){\n\tif(l > r) return;\n\tif(l == nl && r == nr){\n\t\tmin[v] +=d;\n\t\tdet[v] +=d;\n\t\tlazy[v] =1;\n\t\treturn;\n\t}\n\tpushdownSeg(v);\n\tint mid =(nl+nr)>>1;\n\tif(r <= mid) updata(l, r, d, v<<1, nl, mid);\n\telse if(l > mid) updata(l, r, d, (v<<1)|1, mid+1, nr);\n\telse updata(l, mid, d, v<<1, nl, mid), updata(mid+1, r, d, (v<<1)|1, mid+1, nr);\n\tpushupSeg(v);\n}\n\ninline int query(int l, int r, int v =1, int nl =1, int nr =N){\n\tif(l == nl && r == nr){\n\t\t//printf(\"[%d]\\n\", min[v]);\n\t\tif(min[v] != 1/*!*/) return 0;\n\t\telse return cnt[v];\n\t}\n\tpushdownSeg(v);\n\tint mid =(nl+nr)>>1;\n\tif(r <= mid) return query(l, r, v<<1, nl, mid);\n\telse if(l > mid) return query(l, r, (v<<1)|1, mid+1, nr);\n\telse return query(l, mid, v<<1, nl, mid) + query(mid+1, r, (v<<1)|1, mid+1, nr);\n}\n\nint posx[MAXN], posy[MAXN], dx[4] ={0, 1, 0, -1}, dy[4] ={1, 0, -1, 0};\nint map[2000][2000], n, m;\n\ninline int read(){\n\tint x =0; char cc =getchar();\n\twhile(cc < '0' || cc > '9') cc =getchar();\n\twhile(cc >= '0' && cc <= '9') x =(x<<3)+(x<<1)+(48^cc), cc =getchar();\n\treturn x; \n}\n\ninline int outmap(int x, int y){\n\tif(x < 0 || x >= n) return -1;\n\tif(y < 0 || y >= m) return -1;\n\treturn map[x][y];\n}\n\nint main(){\n\tn =read(), m =read();\n\twhile(N < n*m) N <<=1;\n\tfor(int i =0; i < n; ++i) for(int j =0; j < m; ++j){\n\t\tmap[i][j] =read();\n\t\tposx[map[i][j]] =i, posy[map[i][j]] =j;\n\t}\n\t/*preseg(SegmentTree)*/\n\tfor(int k =1, count =N, d =1; k <= N; d +=k, k <<=1, count >>=1)\n\t\tfor(int i =0; i < k; ++i)\n\t\t\tcnt[d+i] =count;\n\tlong long ans =0;\n\tfor(int l =1, r =0/*\u5230 r\u4e3a\u6b62\u65e0\u73af*/; l <= n*m; ++l){\n\t\tfor(int r2 =r+1/*\u907f\u514d\u8d8a\u754c*/; r2 <= n*m; ++r2){\n\t\t\tint lnk[4], tot =0, count =0;\n\t\t\tbool brek =0;\n\t\t\tfor(int d =0; d < 4; ++d){\n\t\t\t\tint to =outmap(posx[r2]+dx[d], posy[r2]+dy[d]);\n\t\t\t\tif(to == -1 || to > r2 || to < l) continue;\n\t\t\t\tif(!connected(r2, to)) link(r2, to)/*\u5148\u6a21\u62df\u8fde*/, lnk[tot++] =to, ++count;\n\t\t\t\telse{\n\t\t\t\t\tbrek =1;\n\t\t\t\t\tbreak;/*\u4e0d\u4e00\u5b9a\u8981*/\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(brek){\n\t\t\t\tfor(int i =0; i < tot; ++i) cut(r2, lnk[i]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tupdata(r2, n*m, 1-count);\n\t\t\tr =r2;\n\t\t}\n\t\tans +=query(l, r);\n\t\tint lnk[4], tot =0;\n\t\tfor(int d =0; d < 4; ++d){\n\t\t\tint to =outmap(posx[l]+dx[d], posy[l]+dy[d]);\n\t\t\tif(to == -1) continue;\n\t\t\tif(connected(l, to)) cut(l, to), lnk[tot++] =to;\n\t\t}\n\t\tsort(lnk, lnk+tot);\n\t\tif(tot > 0) updata(l, lnk[0]-1, -1);/*l\u907f\u514d\u8d8a\u754c*/\n\t\telse updata(l, m*n, -1);/*!*/\n\t\tfor(int i =1; i < tot; ++i){\n\t\t\tif(!connected(lnk[i-1], lnk[i])) updata(lnk[i], n*m, 1);\n\t\t}\n\t}\n\tprintf(\"%lld\", ans);\n}\n```\n",
        "postTime": 1589155576,
        "uid": 105254,
        "name": "Piwry",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF1109F \u3010Sasha and Algorithm of Silence's Sounds\u3011"
    }
]