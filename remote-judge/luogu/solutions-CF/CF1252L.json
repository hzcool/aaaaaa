[
    {
        "content": "(\u8fd9\u4e2a\u9898\u597d\u50cf\u5728luogu\u4e0a\u4ea4\u4e0d\u4e0a\u53bb\uff1f\u53ef\u4ee5\u76f4\u63a5\u53bbcf\u4e0a\u4ea4[\u9898\u76ee\u94fe\u63a5](https://codeforces.ml/contest/1252/problem/L))\n\n[csdn\u98df\u7528\u5730\u5740](https://blog.csdn.net/wmhtxdy/article/details/104171990)\n\n\u89e3\u6cd5\n\u6709\u6e90\u6c47\u4e0a\u4e0b\u754c\u6700\u5927\u6d41\n\n\u8003\u8651\u5982\u679c\u9700\u8981\u8fde\u6240\u6709\u8fb9\u7684\u5efa\u56fe\uff0c\u6bcf\u4e2a\u5de5\u4eba\u5411\u53ef\u4ee5\u5efa\u7684\u8def\u8fde\u8fb9\uff0c\u76f4\u63a5\u8dd1\u5c31\u597d\u4e86\u3002\u73b0\u5728\u53ea\u9700\u8981\u56fe\u8054\u901a\uff0c\u8003\u8651\u539f\u56fe\u662f\u4e00\u4e2a\u57fa\u73af\u6811\uff0c\u6240\u4ee5\u6811\u8fb9\u4e00\u5b9a\u8981\u8fde\uff0c\u73af\u8fb9\u4e0d\u4e00\u5b9a\u8981\u8fde\uff0c\u5c31\u8dd1\u6709\u6e90\u6c47\u4e0a\u4e0b\u754c\u53ef\u884c\u6d41,\u5224\u65ad\u80fd\u5426\u6ee1\u8db3\u6811\u8fb9\u7684\u8981\u6c42\uff0c\u7136\u540e\u518d\u8dd1\u51fa\u6700\u5927\u6d41\uff0c\u770b\u6700\u5927\u6d41\u662f\u5426>=n-1\uff0c\u8fd9\u6837\u56fe\u624d\u80fd\u8054\u901a\uff0c\u56e0\u4e3a\u53ea\u8dd1\u53ef\u884c\u6d41\uff0c\u73af\u4e0a\u7684\u4e0d\u4e00\u5b9a\u80fd\u8054\u901a\u3002\u8f93\u51fa\u65b9\u6848\u7684\u65f6\u5019bfs\u6ee1\u6d41\u7684\u8fb9\u3002\n\n\u7136\u540e\u76f4\u63a5\u5efa\u56fe\u4f1aT\uff0c\u8003\u8651\u4f18\u5316\u5efa\u56fe\uff0c\u5c06\u6750\u6599\u7f16\u53f7\u79bb\u6563\u5316\u4ee5\u540e\uff0c\u6bcf\u4e2a\u5de5\u4eba\u5411\u5bf9\u5e94\u6750\u6599\u8fde\u8fb9\uff0c\u8def\u4e5f\u5411\u5bf9\u5e94\u6750\u6599\u8fde\u8fb9\uff0c\u6ce8\u610f\u5904\u7406\u597d\u6ca1\u6709\u5339\u914d\u4e0a\u7684\u60c5\u51b5\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int maxn=1e5+5;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile(isdigit(c)&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,k;\nvector<int> g[maxn];\nvector<int> col[maxn];\nint alfa[maxn];\nint vis[maxn<<2],st[maxn],top,flag[maxn],bt,s,t,ss,tt;\nvoid dfs(int u,int fa){\n\tst[++top]=u;vis[u]=1;\n\tfor(int i=0;i<g[u].size();i++){\n\t\tint v=g[u][i];\n\t\tif(v==fa)continue;\n\t\tif(vis[v]){\n\t\t\tint tmp=st[top];\n\t\t\twhile(tmp!=v&&top){\n\t\t\t\tflag[tmp]=1;\n\t\t\t\ttop--;\n\t\t\t\ttmp=st[top];\n\t\t\t}\n\t\t\ttop--;\n\t\t\tflag[v]=1;\n\t\t\tbt=1;\n\t\t\treturn ;\n\t\t}\n\t\tdfs(v,u);\n\t\tif(bt)return ;\n\t}\n\ttop--;\n}\nstruct edge{\n\tint v,p,w;\n}e[maxn<<2];\nint h[maxn<<1],cnt=1,tot,val[maxn<<2];\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\tval[cnt]=c;\n\th[a]=cnt;\n}\nint dis[maxn<<2],out[maxn],a[maxn];\nbool bfs(){\n\tqueue<int> q;\n\tmemset(dis,0,sizeof(dis));\n\twhile(!q.empty())q.pop();\n\tq.push(ss);\n\tdis[ss]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\t//printf(\"%d\\n\",u);\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&(!dis[v])){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[tt]!=0;\n}\nint ht[maxn<<2];\nint df(int u,int rest){\n\tif(rest==0||u==tt){\n\t\treturn rest;\n\t}\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(dis[v]==dis[u]+1&&e[i].w){\n\t\t\tint di=df(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\ttot+=di;rest-=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\t//puts(\"!\");\n\t\tfor(int i=0;i<=tt;i++)ht[i]=h[i];\n\t\tint di=0;\n\t\twhile(di=df(ss,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint in[maxn];\nint ls[maxn<<2],num;\nvoid get(){\n\tqueue<int> q;\n\tmemset(vis,0,sizeof(vis));\n\twhile(!q.empty())q.pop();\n\tq.push(ss);\n\tvis[ss]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tvis[u]=1;\n\t\t//printf(\"%d\\n\",u);\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(vis[v])continue;\n\t\t\tif((!e[i].w)){\n\t\t\t\tif(u<=k&&v>n+k&&v<=n+k+num){\n\t\t\t\t\tif(!out[u])\n\t\t\t\t\tout[u]=v-n-k;\n\t\t\t\t}\n\t\t\t\tif(u>n+k&&u<=n+k+num&&v>k&&v<=n+k){\n\t\t\t\t\tif(!in[v-k])in[v-k]=u-n-k;\n\t\t\t\t}\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid find(){\n\th[ss]=0;h[tt]=0;\n\tss=s;tt=t;\n\tint ans=dinic();\n\t//printf(\"%d\\n\",ans+tot);\n\tget();\n}\nint alf[maxn],bet[maxn];\nint main(){\n\t//freopen(\"1252L.in\",\"r\",stdin);\n\t//freopen(\"1252L.out\",\"w\",stdout);\n\tn=read(),k=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t\tg[a[i]].push_back(i);\n\t\tg[i].push_back(a[i]);\n\t\tint m=read();\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tint c=read();\n\t\t\tls[++num]=c;\n\t\t\tcol[i].push_back(c);\n\t\t}\n\t}\n\tfor(int i=1;i<=k;i++){\n\t\talfa[i]=read();\n\t\tls[++num]=alfa[i];\n\t}\n\tsort(ls+1,ls+1+num);\n\tnum=unique(ls+1,ls+1+num)-ls-1;\n\tdfs(1,0);\n\ts=0,t=n+k+num+1,ss=t+1,tt=ss+1;\n\tfor(int i=1;i<=k;i++){\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(flag[i]){\n\t\t\t//printf(\"%d\\n\",i);\n\t\t\tadd(i+k,t,1);\n\t\t\tadd(t,i+k,0);\n\t\t}\n\t\tif(!flag[i]){\n\t\t\ttot++;\n\t\t//\tprintf(\"%d\\n\",i);\n\t\t\tadd(ss,t,1);\n\t\t\tadd(t,ss,0);\n\t\t\tadd(i+k,tt,1);\n\t\t\tadd(tt,i+k,0);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint l=col[i].size();\n\t\tfor(int j=0;j<l;j++){\n\t\t\tcol[i][j]=lower_bound(ls+1,ls+1+num,col[i][j])-ls;\n\t\t\tadd(n+k+col[i][j],i+k,1);\n\t\t\tadd(i+k,n+k+col[i][j],0);\n\t\t} \n\t}\n\tfor(int i=1;i<=k;i++){\n\t\talfa[i]=lower_bound(ls+1,ls+1+num,alfa[i])-ls;\n\t\tadd(i,n+k+alfa[i],1);\n\t\tadd(n+k+alfa[i],i,0);\n\t}\n\tadd(t,s,inf);add(s,t,0);\n\tint tmp=dinic();\n\t//printf(\"%d\\n\",tmp);\n\tif(tmp==tot){\n\t\tfind();\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ans=0;\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tint flag=0;\n\t\t\tif(out[i]==0)continue;\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif((out[i]==in[j])&&(!vis[j])){\n\t\t\t\t\tflag=1;ans++;\n\t\t\t\t\talf[i]=j;bet[i]=a[j];\n\t\t\t\t\tvis[j]=1;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans<n-1){puts(\"-1\");return 0;}\n\t\tfor(int i=1;i<=k;i++){\n\t\t\tprintf(\"%d %d\\n\",alf[i],bet[i]);\n\t\t}\n\t\treturn 0;\n\t}\n\telse{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1582876748,
        "uid": 29006,
        "name": "xiayuyang",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF1252L \u3010Road Construction\u3011"
    },
    {
        "content": "\u56e0\u4e3a\u539f\u56fe\u7ed9\u51fa\u4e86\u4e00\u4e2a\u57fa\u73af\u6811\uff0c\u800c\u8981\u8ba9\u56fe\u8054\u901a\u5219\u5728\u73af\u4e0a\u81f3\u591a\u6709\u4e00\u6761\u8fb9\u4e0d\u9009\uff0c\u6240\u6709\u6811\u8fb9\u5fc5\u987b\u9009\u62e9\uff0c\u800c\u5982\u679c\u5168\u90e8\u8fb9\u90fd\u9009\u62e9\u6709\u89e3\u90a3\u4e48\u73af\u4e0a\u6709\u4e00\u6761\u8fb9\u4e0d\u9009\u4e5f\u4e00\u5b9a\u6709\u89e3\uff08\u4efb\u610f\u53bb\u73af\u4e0a\u7684\u4e00\u6761\u8fb9\u90fd\u53ef\u4ee5\u5c06\u5176\u53d8\u6210\u4e00\u68f5\u6811\uff09\uff0c\u90a3\u4e48\u6211\u4eec\u76f4\u63a5\u8ba9\u73af\u4e0a\u5fc5\u987b\u8981\u6709\u4e00\u6761\u8fb9\u4e0d\u9009\uff0c\u4e8e\u662f\u5c31\u6709\u4e2a\u5efa\u56fe\u65b9\u6cd5\uff1a\n\n- \u4ece\u539f\u70b9\u5411\u5c06\u6240\u6709\u5de5\u4eba\u8fde\u6d41\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u4ee3\u8868\u4ed6\u53ea\u80fd\u5efa\u4e00\u6761\u8fb9\u3002\n\n- \u4ece\u6240\u6709\u5de5\u4eba\u5411\u4ed6\u80fd\u5efa\u9020\u7684\u8fb9\u8fde\u6d41\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u4ee3\u8868\u4ed6\u80fd\u5efa\u9020\u8fd9\u4e9b\u8fb9\u3002\n\n- \u6240\u6709\u6811\u8fb9\u5411\u6c47\u70b9\u8fde\u6d41\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u4ee3\u8868\u8fd9\u6761\u8fb9\u5fc5\u987b\u9009\u3002\n\n- \u6240\u6709\u73af\u8fb9\u5411\u4e00\u4e2a\u65b0\u8282\u70b9\u8fde\u6d41\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u8fd9\u4e2a\u65b0\u8282\u70b9\u5411\u6c47\u70b9\u8fde\u73af\u957f $-1$\u7684\u8fb9\uff0c\u4ee3\u8868\u8fd9\u4e9b\u8fb9\u8981\u6709\u4e00\u6761\u4e0d\u9009\u3002\n\n\u6700\u540e\u5f97\u5230\u7684\u6700\u5927\u6d41\u5047\u5982\u7ed3\u679c\u662f $n-1$ \u5219\u6709\u4e00\u7ec4\u73af\u4e0a\u5fc5\u987b\u6709\u4e00\u6761\u8fb9\u4e0d\u9009\u7684\u89e3\uff0c\u5426\u5219\u80af\u5b9a\u65e0\u89e3\u3002\n\n\u70b9\u6570 $O(n)$\uff0c\u56e0\u4e3a\u5dee\u4e0d\u591a\u50cf\u4e2a\u4e8c\u5206\u56fe\u6240\u4ee5\u8dd1\u7684\u98de\u5feb\u3002\n\n\u65b9\u6848\u76f4\u63a5\u6839\u636e\u6b8b\u4f59\u7f51\u7edc\u6784\u9020\u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\nconst int N = 2010;\nstruct bian\n{\n\tint from, to, w;\n}eg[N * N * 2 + N * 10];\nint front[N << 2], num;\nvector<int>cir;\nmap<int, int>metal[N];\nstruct tree\n{\n\tbian eg[N << 1];\n\tint front[N], num;\n\tvoid add(int x, int y)\n\t{\n\t\teg[++ num].to = y;\n\t\teg[num].from = front[x];\n\t\tfront[x] = num;\n\t}\n\tint fa[N], vis[N], dep[N];\n\tvoid dfs(int o, int from)\n\t{\n\t\tvis[o] = 1;\n\t\tfa[o] = from;\n\t\tdep[o] = dep[from] + 1;\n\t\tfor (int i = front[o]; i; i = eg[i].from)\n\t\t{\n\t\t\tint to = eg[i].to;\n\t\t\tif(to == from)continue;\n\t\t\tif(vis[to] && dep[to] < dep[o])\n\t\t\t{\n\t\t\t\tint now = o;\n\t\t\t\tcir.push_back(now);\n\t\t\t\twhile(now != to)\n\t\t\t\t{\n\t\t\t\t\tnow = fa[now];\n\t\t\t\t\tcir.push_back(now);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(vis[to])continue;\n\t\t\tdfs(to, o);\n\t\t}\n\t}\n}T;\nvoid add(int x, int y, int w)\n{\n\teg[++ num].to = y;\n\teg[num].from = front[x];\n\tfront[x] = num;\n\teg[num].w = w;\n\tswap(x, y);\n\teg[++ num].to = y;\n\teg[num].from = front[x];\n\tfront[x] = num;\n}\nint _front[N << 1], dis[N << 1];\nint sf[N];\nint n, m, s, t;\nbool bfs()\n{\n\tmemset(dis, 0, sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s] = 1;\n\twhile(!q.empty())\n\t{\n\t\tint o = q.front();\n\t\tq.pop();\n\t\tfor (int i = front[o]; i; i = eg[i].from)\n\t\t{\n\t\t\tint to = eg[i].to;\n\t\t\tif(eg[i].w && dis[to] == 0)\n\t\t\t{\n\t\t\t\tdis[to] = dis[o] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != 0;\n}\nint dfs(int o, int lim)\n{\n\tif(o == t)return lim;\n\tint now = 0;\n\tfor (int &i = _front[o]; i; i = eg[i].from)\n\t{\n\t\tint to = eg[i].to;\n\t\tif(eg[i].w == 0 || dis[to] != dis[o] + 1)continue;\n\t\tint del = dfs(to, min(lim, eg[i].w));\n\t\teg[i].w -= del;\n\t\teg[((i - 1) ^ 1) + 1].w += del;\n\t\tnow += del;\n\t\tif(now == lim)break;\t\n\t}\n\treturn now;\n}\nint dinic()\n{\n\tint re = 0;\n\twhile(bfs())\n\t{\n\t\tmemcpy(_front, front, sizeof(front));\n\t\tre += dfs(s, 1e9);\n\t}\n\treturn re;\n}\nint x[N];\nint main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tint m;\n\t\tscanf(\"%d%d\", &x[i], &m);\n\t\tT.add(i, x[i]);\n\t\tT.add(x[i], i);\n\t\twhile(m --)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tmetal[i][x] = 1;\n\t\t}\n\t}\n\tT.dfs(1, 0);\n\ts = n + m + 2;\n\tt = s + 1;\n\tfor (int i = 1; i <= m; ++ i)\n\t{\n\t\tint has;\n\t\tscanf(\"%d\", &has);\n\t\tadd(s, i, 1);\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t{\n\t\t\tif(metal[j][has])\n\t\t\tadd(i, j + m, 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < cir.size(); ++ i)\n\tsf[cir[i]] = 1;\n\tfor (int i = 1; i <= n; ++ i)\n\t{\n\t\tif(sf[i])\n\t\tadd(i + m, n + m + 1, 1);\n\t\telse\n\t\tadd(i + m, t, 1);\n\t}\n\tadd(n + m + 1, t, cir.size() - 1);\n\tif(dinic() != n - 1)return printf(\"-1\"), 0;\n\tfor (int i = 1; i <= m; ++ i)\n\t{\n\t\tfor (int j = front[i]; j; j = eg[j].from)\n\t\t{\n\t\t\tint to = eg[j].to;\n\t\t\tif(to == s && eg[j].w == 0)\n\t\t\t{\n\t\t\t\tprintf(\"0 0\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(to > m && to <= n + m && eg[j].w == 0)\n\t\t\tprintf(\"%d %d\\n\", to - m, x[to - m]);\n\t\t}\n\t}\n}\n```\n",
        "postTime": 1632455325,
        "uid": 111728,
        "name": "\u5e7b\u5f71\u661f\u575a\u5f3a",
        "ccfLevel": 7,
        "title": "CF1252L"
    }
]