[
    {
        "content": "\u849f\u84bb\u7684\u7b2c\u4e00\u7bc7\u9898\u89e3\n\n~~\u8c03\u4e862h+\u7684\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u88ab\u8d5b\u540e10min\u5199\u5b8c\u7684set\u778e\u641e\u505a\u6cd5\u7ed9\u540a\u6253\u4e86~~\n\n\n------------\n\n\n# Description\n\n\u7ef4\u62a4\u4e00\u4e2a\u96c6\u5408 $S$ \uff0c\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\u63d2\u5165\u4e00\u4e2a\u6570\u3001\u5220\u9664\u4e00\u4e2a\u6570\u3001\u67e5\u8be2 $k$ \u7684\u500d\u6570\u4e2d\u6ca1\u51fa\u73b0\u8fc7\u7684\u6700\u5c0f\u7684\u6570\u3002\n\n# Solution\n\n\n\u672c\u6765\u60f3\u5199\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u540e\u6765\u53d1\u73b0\u7528 set \u778e\u641e\u5c31\u80fd\u89e3\u51b3\u3002\n\n\u5bf9\u4e8e\u4e00\u4e2a\u4fee\u6539\u64cd\u4f5c $x$ ,\u5b83\u6709\u53ef\u80fd\u5f71\u54cd\u5230\u54ea\u4e9b\u8be2\u95ee $k$ \u5462\uff1f\u663e\u7136\u5f53 $k$ \u662f $x$ \u7684\u56e0\u6570\u65f6\u5c31\u6709\u53ef\u80fd\u5f71\u54cd\u5230\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7ef4\u62a4\u4ee5\u4e0b\u4e09\u4e2a\u96c6\u5408\uff1a\n\n1. \u96c6\u5408 $S$ \u5c31\u662f\u9898\u76ee\u4e2d\u7684\u96c6\u5408\u3002\n\n2. \u96c6\u5408 $S1[k]$ \u7ef4\u62a4\u5bf9\u4e8e\u6bcf\u4e2a $k$ \uff0c $k$ \u7684\u500d\u6570\u4e2d\u201c\u53ef\u80fd\u201d\u5728\u96c6\u5408 $S$ \u4e2d\u6ca1\u51fa\u73b0\u7684\u6570\u7684\u96c6\u5408\uff08\u5c31\u662f\u6709\u53ef\u80fd\u6210\u4e3a\u7b54\u6848\u7684\u96c6\u5408\uff09\u3002\n\n3. \u96c6\u5408 $S2[k]$ \u7ef4\u62a4\u6bcf\u4e00\u4e2a\u6570\u7684\u56e0\u5b50\u7684\u96c6\u5408\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5c0f\u6280\u5de7\uff0c\u5982\u679c\u6211\u4eec\u5982\u679c\u7ef4\u62a4\u6bcf\u4e2a\u6570\u7684\u6240\u6709\u56e0\u5b50\u7684\u8bdd\u65f6\u95f4\u80af\u5b9a\u4f1a\u70b8\uff0c\u4f46\u6211\u4eec\u53ea\u8981\u7ef4\u62a4\u90a3\u4e9b\u6709\u53ef\u80fd\u8be2\u95ee\u5230\u7684\u56e0\u5b50\u5c31\u884c\u4e86\uff0c\u4e00\u8fb9\u8be2\u95ee\u4e00\u8fb9\u7ef4\u62a4 $S2$ \u5373\u53ef\n\n \n\n\u5177\u4f53\u5730\uff0c\u5bf9\u4e8e\u63d2\u5165\u64cd\u4f5c\uff0c\u76f4\u63a5\u5728 $S$ \u4e2d\u63d2\u5165\u5373\u53ef\uff1b\n\n\u5bf9\u4e8e\u5220\u9664\u64cd\u4f5c\uff0c\u5148\u5728 $S$ \u4e2d\u628a\u8fd9\u4e2a\u6570 $x$ \u5220\u6389\uff0c\u7136\u540e\u518d\u5728 $x$ \u7684\u6240\u6709\u56e0\u5b50\u7684 $S1$ \u4e2d\u63d2\u5165 $x$ \uff1b\n\n\u5bf9\u4e8e\u8be2\u95ee $k$ \uff0c \u76f4\u63a5\u5728 $k$ \u7684 $S1$ \u4e2d\u66b4\u529b\u8df3\uff0c\u76f4\u5230\u6709\u4e00\u4e2a\u6570\u6ee1\u8db3\u5728 $S$ \u4e2d\u6ca1\u6709\u51fa\u73b0\u7136\u540e\u8f93\u51fa\u5c31\u884c\u4e86,\u987a\u4fbf\u5728\u8fd9\u4e2a\u8fc7\u7a0b\u4e2d\u7ef4\u62a4\u4e00\u4e0b $S2$\n\n\u8fd8\u6709\u4e00\u4e2a\u7ec6\u8282\uff0c\u56e0\u4e3a\u6570\u636e\u8303\u56f4\u5f88\u5927\uff0c\u6240\u4ee5\u8981\u7528 $map$ \u4ee3\u66ff\u666e\u901a\u7684\u6570\u7ec4\n\n\u5177\u4f53\u5b9e\u73b0\u770b\u4ee3\u7801\u5427 \uff08\u5176\u5b9e\u8fd8\u633a\u77ed\u7684\uff09\n\n# Code\n\n```cpp\n#define int long long\n\nint q;\nset <int> S;//\u9898\u76ee\u4e2d\u7684\u96c6\u5408s\nmap <int,set<int> >disapr,factor;\n//disapr\u7ef4\u62a4\u5bf9\u6bcf\u4e2ak,k\u7684\u500d\u6570\u4e2d\"\u53ef\u80fd\"\u6ca1\u51fa\u73b0\u8fc7\u7684\u6570\n//factor\u7ef4\u62a4\u6bcf\u4e2ax\u7684\u56e0\u6570\uff0c\u4e00\u8fb9\u4fee\u6539\u4e00\u8fb9\u7ef4\u62a4\uff0c\u53ea\u8bb0\u5f55\u6709\u7528\u7684\u5c31\u884c\nsigned main(){\n\tcin>>q;\n\twhile(q--){\n\t\tchar opt;int x;\n\t\tcin>>opt>>x;\n\t\tif(opt=='+') S.insert(x);\n\t\telse if(opt=='-'){\n\t\t\tS.erase(x);\n\t\t\tset <int> ::iterator it=factor[x].begin();\n\t\t\twhile(it!=factor[x].end()) disapr[*it].insert(x),it++;\n\t\t}else{\n\t\t\tdisapr[x].insert(x);\n\t\t\tint u=*disapr[x].begin();\n\t\t\tfactor[u].insert(x);\n\t\t\twhile(S.count(u)){\n\t\t\t\tdisapr[x].erase(u);\n\t\t\t\tif(disapr[x].empty()) disapr[x].insert(u+x);\n\t\t\t\tu=*disapr[x].begin(),factor[u].insert(x);\n\t\t\t}\n\t\t\tcout<<*disapr[x].begin()<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\u66b4\u529b\u8df3\u7684\u590d\u6742\u5ea6\u672c\u849f\u84bb\u4e5f\u4e0d\u4f1a\u7b97\uff0c\u53ef\u80fd\u662f\u5012\u6570\u4e4b\u548c\u5747\u644a\u4e00\u4e0b\u5c31\u53d8\u6210 $O(qlogX)$ \u4e86\uff1f\u53cd\u6b63\u80fd\u8fc7",
        "postTime": 1666596398,
        "uid": 85656,
        "name": "BigJ2333",
        "ccfLevel": 6,
        "title": "\u3010\u9898\u89e3\u3011 CF1732 D2"
    },
    {
        "content": "##### [For better experience please click here.](https://www.cnblogs.com/BrianPeng/p/16827008.html)\n\nFirst CF round at Cambridge. Solved A,B,D1 in the round. Dropped from purple to blue...\n\nStill a long way to go...\n\n# Solution: CF Round #830 (Div. 2) D1&D2 Balance\n\n## Easy Version\n\n### Brute-force\n\nEvidently the most brute-force way is to create a set to collect the $x$ added. Then for all query with $k,$ check $k,2k,3k,\\cdots$ till the first multiple of $k$ that is not contained in the set. Output it.\n\nObviously it is doomed to TLE, especially when you are queried by the same $k$ multiple times with very large $k\\text{-mex}$.\n\n### Becoming Elegant\n\nWe try to optimize the brute-force by reducing the time cost if queried by the same $k.$ As there is no remove, if you are queried by $k$ and you find the $k\\text{-mex},$ it is obvious that the next time if you are queried by the same $k,$ the answer must be greater than or equal to the previous one.\n\nTherefore, we can memorize all the \"previous answers.\" If $k$ that has a memorized answer is queried, we start checking the set from its previous answer instead of from $1\\cdot k.$\n\nWait, do we avoid TLE just by this \"subtle\" optimization?\n\n#### Calculation of time complexity (not rigorous):\n\nFor queries with the same $k,$ every multiples of $k$ in the set is checked at most once. So the time complexity is the same as if every query is moved to the end of the operations, and every $k$ is queried at most once.\n\nThen, the worst case happens (intuitively) when the first $q/2$ operations fill the set with numbers between $1$ and $q/2,$ and the next $q/2$ operations query for $k=1,2,\\cdots,q/2.$ In this case, the number of times checking the set is $O(\\sum_{k=1}^{q/2} \\frac{q}{2k})=O(q\\log q)$ by harmonic series. As every check of the set takes $O(\\log q)$ of time, the overall time complexity is $O(q\\log^2 q).$\n\n##### Code (795 ms / 12600 KB)\n\nWe use a map to memorize the previous answers. The function $\\mathtt{srch(x,fs)}$ takes $\\mathtt x$ as queried $k$ and $\\mathtt{fs}$ its starting number.\n\n```cpp\n//This program is written by Brian Peng.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rd(a) (a=rd())\n#define Gc(a) (a=getchar())\n#define Pc(a) putchar(a)\nint rd(){\n\tint x;char c(getchar());bool k;\n\twhile(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);\n\tc^'-'?(k=1,x=c&15):k=x=0;\n\twhile(isdigit(Gc(c)))x=x*10+(c&15);\n\treturn k?x:-x;\n}\nvoid wr(int a){\n\tif(a<0)Pc('-'),a=-a;\n\tif(a<=9)Pc(a|'0');\n\telse wr(a/10),Pc((a%10)|'0');\n}\nsigned const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);\nlong long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);\n#define Ps Pc(' ')\n#define Pe Pc('\\n')\n#define Frn0(i,a,b) for(int i(a);i<(b);++i)\n#define Frn1(i,a,b) for(int i(a);i<=(b);++i)\n#define Frn_(i,a,b) for(int i(a);i>=(b);--i)\n#define Mst(a,b) memset(a,b,sizeof(a))\n#define File(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\nint q,x;\nchar opt;\nset<int>s;\nmap<int,int>ans; //Memorization\nint srch(int x,int fs);\nsigned main(){\n\tRd(q);\n\twhile(q--){\n\t\tcin>>opt,Rd(x);\n\t\tif(opt=='+')s.insert(x);\n\t\telse{\n\t\t\tif(ans.find(x)!=ans.end())ans[x]=srch(x,ans[x]);\n\t\t\telse ans[x]=srch(x,x);\n\t\t\twr(ans[x]),Pe;\n\t\t}\n\t}\n\texit(0);\n}\nint srch(int x,int fs){\n\twhile(s.find(fs)!=s.end())fs+=x;\n\treturn fs;\n}\n```\n\n## Hard Version\n\nNow the \"remove\" operation is added, and we can no longer memorize the previous answers simply.\n\nMaybe we can use something more powerful, which is able to record \"removed\" $x$'s?\n\nThe most useful tool to record and query the existence of numbers in a given range is\n\n##### Segment Tree\n\nFor every queried $k,$ instead of memorizing the previous $k\\text{-mex}$, we build a segment tree of $k$ recording the **checked and not removed** multiples of $k.$ In the following text, we let $\\text{St}_k$ denote the \"SegTree of $k$\", and use $x\\in \\text{St}_k$ to denote that $x$ is recorded in the SegTree of $k.$\n\nFor a query with $k$, if $\\text{St}_k$ is not set up yet (i.e. $\\text{St}_k$ is empty), we go through the multiples of $k$ in the set, which are $k,2k,3k,\\cdots$ till the first multiple of $k$ (say $nk$) that is not in the set. Then, the SegTree of $k$ is built with the entries from $1$ to $n-1$ set as $1,$ meaning that $k,2k,\\cdots,(n-1)k\\in\\text{St}_k.$ **(As we only insert multiples of $k$ into $\\text{St}_k,$ we let the $i$ th entry of $\\text{St}_k$ represent the number $ik$ to make the tree more compact.)**\n\nThus, **if a number is recorded in a SegTree, it is in the set**.\n\nThen, for removal of $x$, we need to remove $x$ from not only the set, but also from every SegTree that records it. To achieve this, we create a list of $x$ (say $\\text{Tk}_x$) that consists of all the $k$'s such that $x\\in\\text{St}_k.$ In other words, if a certain $x$ is recorded in the SegTree of $k$, we add $k$ into the list $\\text{Tk}_x$ so that when $x$ is removed from the set, we remove $x$ from all SegTrees recording it by going through every $k$ in $\\text{Tk}_x$ and setting the $x/k$ th entry in $\\text{St}_k$ to be $0.$ We clear $\\text{Tk}_x$ at the end of the process as $x$ is no longer recorded in any SegTree.\n\nNow, if a $k$ is queried a second time, we **find the least entry in $\\text{St}_k$ that is $0.$** (This is why we need to use a SegTree instead of an array, as we may **check whether a sub-interval is set all $1$ by checking if the sum of the interval is equal to its length.**) Say this entry is the $n$ th. If $nk$ is not in the set, we output $nk$ as $k\\text{-mex}.$ Otherwise, if $nk$ is in the set, we update the $n$ th entry in $\\text{St}_k$ to be $1,$ add $k$ into the list $\\text{Tk}_{nk},$ and repeat the process of seeking the least entry in $\\text{St}_k$ that is $0.$\n\n### Code Implementation\n\nAs the range of $k$ and $x$ in the input is very large, I use `#define int long long` ~~(a wicked trick)~~ for convenience and `signed` is used in place of `int` if such a large range is not needed.\n\n#### Lazy Created Segment Tree\n\nWe may see that most of the entries in a SegTree are $0,$ and most of the $k$'s even do not have a SegTree if they are never queried. Thus, we need Lazy Created SegTree to reduce time and memory complexity.\n\nThe following is the structure of a node in a lazy created SegTree:\n\n```cpp\nstruct SgT{signed ls,rs,v;}t[10000000];\n```\n\nHere, $\\mathtt {ls,rs}$ represent the ids of left/right-son respectively, and $\\mathtt v$ represents the sum of the interval the node represents. (The interval is not stored in the nodes explicitly, but they will be clear in functions.)\n\n##### How lazy creation is achieved\n\n1. We use a counter $\\mathtt{tn}$ (initial value $0$) to record the highest id of the SegTree nodes. Then whenever a new node is created, we add $1$ to $\\mathtt{tn}$ and use it as the id of the new node.\n\n2. Particularly, the **node with id $0$** represents an interval with entries all $0,$ and at the beginning every SegTree has only node $0.$ If a son of a node is $0,$ it means that its half-interval is filled with $0.$\n\n3. We use a map `map<int,signed>rt` to store the root of $\\text{St}_k$ (`rt[k]`). For every SegTree, we set its root interval be $[1,q]$ as any number greater than or equal $(q+1)k$ can never be $k\\text{-mex}.$ (Why?)\n\n4. We also use a map `map<int,list<int>>tk` to store the lists $\\text{Tk}_x$ (`tk[x]`).\n\nNote: apart from the SegTree, the use of **$\\mathtt{map}$** for roots and lists are also **Lazy Creation.**\n\n\nFor convenience, we use $\\mathtt u$ as the id of the node we are dealing with in a function, and we use `#define` to simplify the id of its two sons:\n\n```cpp\n#define Ls (t[u].ls)\n#define Rs (t[u].rs)\n```\n\nHow let's look at how these operations are implemented.\n\n#### Query: Lazy Creation, Updating, and Query in one function\n\nSuppose we are dealing with the SegTree $\\text{St}_k.$ The qry function $\\mathtt{qry(u,k,l,r)}$ returns the least $n$ in the interval $[l,r]$ such that $nk$ is not in the set. If the interval is all filled with $1,$ return $0$ as the default value.\n\n```cpp\nint qry(signed&u,int k,int l,int r){\n\tif(!u)u=++tn;\n\t//Lazy Creation happen's here. !!!IMPORTANT: Pass u by Reference!!!\n\tif(t[u].v==r-l+1)return 0;\n\t//If the sum is equal to length, then every entry is 1.\n\tif(l==r){\n\t\t//Check if l*k is in the set.\n\t\tif(st.find(l*k)!=st.end()){\n\t\t\tt[u].v=1,tk[l*k].push_back(k);\n\t\t\t//l*k is in the set. Update the SegTree and add k into the list tk[l*k].\n\t\t\treturn 0;\n\t\t}\n\t\telse return l;\n\t\t//l*k is not in the set, return l (meaning the current k-mex is l*k).\n\t}\n\tint md((l+r)/2),ql(qry(Ls,k,l,md));\n\t//Query the left half-interval first\n\tif(ql){\n\t\t//Found the k-mex, update the SegTree and return.\n\t\tt[u].v=t[Ls].v+t[Rs].v;\n\t\treturn ql;\n\t}\n\t//Left half-interval filled with 1. Query the right-interval.\n\tint qr(qry(Rs,k,md+1,r));\n\tt[u].v=t[Ls].v+t[Rs].v;\n\treturn qr;\n}\n```\n\n\n#### Removal\n\nThe modification function $\\mathtt{mdf(u,l,r,x)}$ set the **$\\mathtt x$ th entry** (Note that the $\\mathtt x$ th entry represents the number $\\mathtt xk$ recorded in $\\text{St}_k$) to be $0$ in the SegTree with root $\\mathtt u.$ For the SegTree $\\text{St}_k,$ if we want to remove the number $x,$ we implement `mdf(rt[k],1,q,x/k)`.\n\n```cpp\n// When implementing, always set l=1 and r=q.\nvoid mdf(signed u,int l,int r,int x){\n\twhile(1){\n\t\t//Descending from the root to the leaf.\n\t\t--t[u].v;\n\t\tif(l==r)return;\n\t\tint md((l+r)/2);\n\t\tx<=md?(r=md,u=Ls):(l=md+1,u=Rs);\n\t\t//Direction chosen by x.\n\t}\n}\n```\n\n#### Time complexity Calculation (Not rigorous)\n\nAs every checking of set ($O(\\log q)$) is accompanied by a SegTree search ($O(\\log q)$ as the SegTree interval is $[1,q]$) and possibly a SegTree modification (also $O(\\log q)$) for a \"remove\" later, the time complexity is the same as the easy version: $O(q\\log^2 q).$\n\n##### Code (1200 ms / 162500 KB)\n\n```cpp\n//This program is written by Brian Peng.\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define Rd(a) (a=rd())\n#define Gc(a) (a=getchar())\n#define Pc(a) putchar(a)\nint rd(){\n\tint x;char c(getchar());bool k;\n\twhile(!isdigit(c)&&c^'-')if(Gc(c)==EOF)exit(0);\n\tc^'-'?(k=1,x=c&15):k=x=0;\n\twhile(isdigit(Gc(c)))x=x*10+(c&15);\n\treturn k?x:-x;\n}\nvoid wr(int a){\n\tif(a<0)Pc('-'),a=-a;\n\tif(a<=9)Pc(a|'0');\n\telse wr(a/10),Pc((a%10)|'0');\n}\nsigned const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);\nlong long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);\n#define Ps Pc(' ')\n#define Pe Pc('\\n')\n#define Frn0(i,a,b) for(int i(a);i<(b);++i)\n#define Frn1(i,a,b) for(int i(a);i<=(b);++i)\n#define Frn_(i,a,b) for(int i(a);i>=(b);--i)\n#define Mst(a,b) memset(a,b,sizeof(a))\n#define File(a) freopen(a\".in\",\"r\",stdin),freopen(a\".out\",\"w\",stdout)\n#define Ls (t[u].ls)\n#define Rs (t[u].rs)\nint q,x,tn;\nchar opt;\nmap<int,signed>rt;\nmap<int,list<int>>tk;\nset<int>st;\nstruct SgT{signed ls,rs,v;}t[10000000];\nint qry(signed&u,int k,int l,int r);\nvoid mdf(signed u,int l,int r,int x);\nsigned main(){\n\tRd(q);\n\tFrn1(i,1,q){\n\t\tcin>>opt,Rd(x);\n\t\tif(opt=='+')st.insert(x);\n\t\telse if(opt=='-'){\n\t\t\tst.erase(x);\n\t\t\t//Remove x from the set, and go through the list tk[x] if exists.\n\t\t\tif(tk.find(x)!=tk.end()){\n\t\t\t\tfor(int k:tk[x])mdf(rt[k],1,q,x/k);\n\t\t\t\ttk.erase(x);\n\t\t\t\t//Remove the list tk[x].\n\t\t\t}\n\t\t}else{\n\t\t\tsigned tmp(rt[x]?rt[x]:(rt[x]=++tn));\n\t\t\t//As Pass by Reference cannot be used with map,\n\t\t\t//we do lazy creation manually\n\t\t\twr(qry(tmp,x,1,q)*x),Pe;\n\t\t}\n\t}\n\texit(0);\n}\nint qry(signed&u,int k,int l,int r){\n\tif(!u)u=++tn;\n\tif(t[u].v==r-l+1)return 0;\n\tif(l==r){\n\t\tif(st.find(l*k)!=st.end()){\n\t\t\tt[u].v=1,tk[l*k].push_back(k);\n\t\t\treturn 0;\n\t\t}\n\t\telse return l;\n\t}\n\tint md((l+r)/2),ql(qry(Ls,k,l,md));\n\tif(ql){\n\t\tt[u].v=t[Ls].v+t[Rs].v;\n\t\treturn ql;\n\t}\n\tint qr(qry(Rs,k,md+1,r));\n\tt[u].v=t[Ls].v+t[Rs].v;\n\treturn qr;\n}\nvoid mdf(signed u,int l,int r,int x){\n\twhile(1){\n\t\t--t[u].v;\n\t\tif(l==r)return;\n\t\tint md((l+r)/2);\n\t\tx<=md?(r=md,u=Ls):(l=md+1,u=Rs);\n\t}\n}\n```\n\n### Conclusion\n\nWhy is Lazy Created SegTree effective in the hard version problem? An intuitive explanation:\n\nIn the easy version of the problem, there is no remove, so the non-decresing nature of $k\\text{-mex}$ with time for a fixed $k$ leads us to the idea of storing answers, so that we can \"move up\" from the previous answer in a later query of the same $k$.\n\nIn the hard problem, the non-decresing nature of $k\\text{-mex}$ is destroyed by the remove operation, and we can no longer record previous answer only. Recording the \"checked numbers\" in a SegTree, on the other hand, provides us with an efficient way to \"move back\" to a removed $x,$ and \"jump up\" if the removed $x$ is inserted into the set again.\n\nLast but not least, the idea of Lazy Creation speeds our code up by creating the data structure only when they are to be used. This idea is extremely useful when **the data range** ($1\\leqslant x,k\\leqslant 10^{18}$) **is a lot larger than the number of operations** ($1\\leqslant q\\leqslant 2\\cdot 10^5$).\n\n#### Thanks for reading! See you next round!\n",
        "postTime": 1668775322,
        "uid": 66199,
        "name": "Bring",
        "ccfLevel": 5,
        "title": "Solution: CF Round #830 (Div. 2) D1&D2 Balance"
    }
]