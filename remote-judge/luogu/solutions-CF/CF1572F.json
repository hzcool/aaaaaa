[
    {
        "content": "\u76f4\u63a5\u7ef4\u62a4 $b_i$ \u975e\u5e38\u56f0\u96be\uff0c\u8003\u8651\u8ba1\u7b97\u6bcf\u4e00\u4e2a\u5e7f\u64ad\u7ad9\u7684\u8d21\u732e\u3002\u8bbe $r_i$ \u8868\u793a $i$ \u6700\u8fdc\u53ef\u4ee5\u4f20\u9012\u5230\u54ea\u4e00\u4e2a\u5e7f\u64ad\u7ad9\uff0c\u90a3\u4e48\u521d\u59cb $r_i=i,b_i=1$\u3002$r_i$ \u5c31\u8868\u793a\u5bf9 $b_i,\\ldots,b_{r_i}$ \u6709 $1$ \u7684\u8d21\u732e\u3002\u6bcf\u4e00\u6b21\u4fee\u6539\uff0c$c_i$ \u53d8\u6210\u6700\u9ad8\u7684\uff0c\u56e0\u6b64 $r_{c_i}=g_i$\u3002\u5bf9\u4e8e $c_i$ \u5de6\u8fb9\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e $j$\uff0c\u4e00\u5b9a\u4e0d\u80fd\u8de8\u8fc7 $i$\uff0c\u56e0\u6b64 $r_j\\gets\\min(r_j,i-1)$\u3002\u53ef\u4ee5\u53d1\u73b0\u53ea\u6709\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u53d6 min\uff0c\u53ef\u4ee5\u4f7f\u7528\u5409\u53f8\u673a\u7ebf\u6bb5\u6811\u7ef4\u62a4 $r_i$\u3002  \n\u63a5\u4e0b\u6765\u8003\u8651 $r_i$ \u7684\u53d8\u5316\u5bf9 $b$ \u7684\u5f71\u54cd\u3002\u5355\u70b9\u4fee\u6539\u76f4\u63a5\u51cf\u53bb\u539f\u6765\u7684\u503c\u7136\u540e\u52a0\u4e0a\u65b0\u7684\u8d21\u732e\u3002\u6ce8\u610f\u5230\u5728\u5409\u53f8\u673a\u7ebf\u6bb5\u6811\u4e0a\uff0c\u533a\u95f4\u64cd\u4f5c\u90fd\u662f\u628a\u6240\u6709\u6700\u5927\u503c $\\mathit{max}$ \u53d8\u6210 $v$\uff0c\u5373\u4fee\u6539 $\\mathit{cnt}_{\\mathit{max}}$ \u4e2a\u503c\u76f8\u7b49\u7684\u4f4d\u7f6e\u3002\u4e5f\u5c31\u662f\u8bf4\u6bcf\u4e00\u6b21\u6253 tag \u5c06 $\\mathit{max}$ \u6539\u6210 $v$ \u7684\u8fc7\u7a0b\uff0c\u5bf9\u5e94\u4e86 $b$ \u4e0a $[v+1,\\mathit{max}]$ \u8fd9\u4e2a\u533a\u95f4\u51cf\u53bb $\\mathit{cnt}_{\\mathit{max}}$\u3002\u56e0\u6b64\u518d\u7528\u4e00\u4e2a\u7ebf\u6bb5\u6811\u7ef4\u62a4 $b$ \u5373\u53ef\u3002\u7531\u4e8e\u5409\u53f8\u673a\u7ebf\u6bb5\u6811\u6ca1\u6709\u533a\u95f4\u52a0\uff0c\u56e0\u6b64\u662f\u4e25\u683c $O(n\\log n)$ \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u9700\u8981 $O(\\log n)$ \u65f6\u95f4\u5728\u7b2c\u4e8c\u68f5\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u4fee\u6539\uff0c\u56e0\u6b64\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log^2n)$\u3002\n\n\u867d\u7136\u6709\u4e24\u68f5\u7ebf\u6bb5\u6811\uff0c\u4f46\u662f\u4ee3\u7801\u96be\u5ea6\u5e76\u4e0d\u5927\uff0c\u56e0\u4e3a\u90fd\u662f\u57fa\u672c\u64cd\u4f5c\uff0c\u6ca1\u6709\u7279\u522b\u7684\u7ec6\u8282\u3002\n```cpp\n#include <cstring>\n#include <iostream>\ntemplate <typename T>\nvoid checkmax(T &x, T y) {\n  if (x < y) x = y;\n}\ntemplate <typename T>\nvoid checkmin(T &x, T y) {\n  if (x > y) x = y;\n}\nint n, q;\nclass SegmentTree {\n private:\n  long long sum_[800001], tag_[800001];\n  void Pushup(int x) { sum_[x] = sum_[x + x] + sum_[x + x + 1]; }\n  void Add(int l, int r, int v, int x) {\n    sum_[x] += static_cast<long long>(r - l + 1) * v, tag_[x] += v;\n  }\n  void Pushdown(int l, int r, int x) {\n    if (tag_[x]) {\n      int mid = (l + r) >> 1;\n      Add(l, mid, tag_[x], x + x), Add(mid + 1, r, tag_[x], x + x + 1);\n      tag_[x] = 0LL;\n    }\n  }\n\n public:\n  void Build(int l, int r, int x) {\n    if (l == r) {\n      sum_[x] = 1LL;\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build(l, mid, x + x), Build(mid + 1, r, x + x + 1);\n    Pushup(x);\n  }\n  void Modify(int L, int R, int l, int r, int v, int x) {\n    if (L <= l && r <= R) return Add(l, r, v, x);\n    int mid = (l + r) >> 1;\n    Pushdown(l, r, x);\n    if (L <= mid) Modify(L, R, l, mid, v, x + x);\n    if (R > mid) Modify(L, R, mid + 1, r, v, x + x + 1);\n    Pushup(x);\n  }\n  long long Query(int L, int R, int l, int r, int x) {\n    if (L <= l && r <= R) return sum_[x];\n    Pushdown(l, r, x);\n    int mid = (l + r) >> 1;\n    long long ans = 0LL;\n    if (L <= mid) ans += Query(L, R, l, mid, x + x);\n    if (R > mid) ans += Query(L, R, mid + 1, r, x + x + 1);\n    return ans;\n  }\n} sgt;\nclass SegmentTreeBeats {\n private:\n  struct Node {\n    int max, smax, cnt, tag;\n  } t_[800001];\n  void Pushup(int x) {\n    if (t_[x + x].max == t_[x + x + 1].max) {\n      t_[x].max = t_[x + x].max;\n      t_[x].smax = std::max(t_[x + x].smax, t_[x + x + 1].smax);\n      t_[x].cnt = t_[x + x].cnt + t_[x + x + 1].cnt;\n    } else if (t_[x + x].max > t_[x + x + 1].max) {\n      t_[x].max = t_[x + x].max;\n      t_[x].smax = std::max(t_[x + x].smax, t_[x + x + 1].max);\n      t_[x].cnt = t_[x + x].cnt;\n    } else {\n      t_[x].max = t_[x + x + 1].max;\n      t_[x].smax = std::max(t_[x + x].max, t_[x + x + 1].smax);\n      t_[x].cnt = t_[x + x + 1].cnt;\n    }\n  }\n  void Min(int v, int x) { t_[x].max = t_[x].tag = v; }\n  void Pushdown(int x) {\n    if (t_[x].tag != -1) {\n      if (t_[x].tag < t_[x + x].max) Min(t_[x].tag, x + x);\n      if (t_[x].tag < t_[x + x + 1].max) Min(t_[x].tag, x + x + 1);\n      t_[x].tag = -1;\n    }\n  }\n\n public:\n  void Build(int l, int r, int x) {\n    t_[x].tag = -1;\n    if (l == r) {\n      t_[x] = {l, -0x3f3f3f3f, 1, -1};\n      return;\n    }\n    int mid = (l + r) >> 1;\n    Build(l, mid, x + x), Build(mid + 1, r, x + x + 1);\n    Pushup(x);\n  }\n  void Modify(int l, int r, int p, int v, int x) {\n    if (l == r) {\n      t_[x] = {v, -0x3f3f3f3f, 1, -1};\n      return;\n    }\n    Pushdown(x);\n    int mid = (l + r) >> 1;\n    if (p <= mid)\n      Modify(l, mid, p, v, x + x);\n    else\n      Modify(mid + 1, r, p, v, x + x + 1);\n    Pushup(x);\n  }\n  void Min(int L, int R, int l, int r, int v, int x) {\n    if (L <= l && r <= R) {\n      if (v >= t_[x].max) return;\n      if (v > t_[x].smax) {\n        sgt.Modify(v + 1, t_[x].max, 1, n, -t_[x].cnt, 1);\n        return Min(v, x);\n      }\n    }\n    Pushdown(x);\n    int mid = (l + r) >> 1;\n    if (L <= mid) Min(L, R, l, mid, v, x + x);\n    if (R > mid) Min(L, R, mid + 1, r, v, x + x + 1);\n    Pushup(x);\n  }\n  int Query(int l, int r, int p, int x) {\n    if (l == r) return t_[x].max;\n    Pushdown(x);\n    int mid = (l + r) >> 1;\n    if (p <= mid)\n      return Query(l, mid, p, x + x);\n    else\n      return Query(mid + 1, r, p, x + x + 1);\n  }\n} sgtb;\nint main(int argc, char const *argv[]) {\n  std::ios_base::sync_with_stdio(false);\n  std::cin.tie(nullptr), std::cout.tie(nullptr);\n  std::cin >> n >> q;\n  sgtb.Build(1, n, 1), sgt.Build(1, n, 1);\n  while (q--) {\n    int op, x, y;\n    std::cin >> op >> x >> y;\n    if (op == 1) {\n      if (x > 1) sgtb.Min(1, x - 1, 1, n, x - 1, 1);\n      int r = sgtb.Query(1, n, x, 1);\n      sgt.Modify(x, r, 1, n, -1, 1);\n      sgtb.Modify(1, n, x, y, 1), sgt.Modify(x, y, 1, n, 1, 1);\n    } else {\n      std::cout << sgt.Query(x, y, 1, n, 1) << '\\n';\n    }\n  }\n  return 0;\n}\n```",
        "postTime": 1640057928,
        "uid": 68273,
        "name": "xyf007",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1572F \u3010Stations\u3011"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u4e2a\u65e0\u8111\u505a\u6cd5\u3002\n\n\u8003\u8651\u7ef4\u62a4 $a_i$ \u8868\u793a\u7ad9\u70b9 $i$ \u80fd\u8986\u76d6\u5230\u7684\u6700\u53f3\u7aef\u7684\u4f4d\u7f6e\u3002\n\n\u90a3\u4e48\u6bcf\u6b21\u4fee\u6539 $(x,w)$ \u76f8\u5f53\u4e8e\uff1a\n\n- $\\forall i\\in[1,x),a_i\\leftarrow\\min\\{a_i,x-1\\}$\n\n- $a_x\\leftarrow w$\n\n\u4f7f\u7528 Segment Tree Beats\uff08\u5409\u53f8\u673a\u7ebf\u6bb5\u6811\uff09\u7ef4\u62a4 $a$\u3002\n\n\u7531\u4e8e\u8fd9\u79cd\u6570\u636e\u7ed3\u6784\u7684\u6027\u8d28\uff0c\u6211\u4eec\u6bcf\u6b21\u4f1a\u628a\u4e00\u4e2a\u7ebf\u6bb5\u4e2d\u7684\u6240\u6709\u6700\u5927\u503c\u6539\u4e3a $x-1$\u3002\u6240\u4ee5\u53ef\u4ee5\u5728\u7ef4\u62a4 $a$ \u7684\u540c\u65f6\u7528\u53e6\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u7ef4\u62a4 $b$\u3002\n\n\u6700\u7ec8\u5bf9 $b$ \u6709 $O(n\\log^2n)$ \u4e2a\u533a\u95f4\u4fee\u6539\u64cd\u4f5c\u548c $O(n)$ \u4e2a\u533a\u95f4\u6c42\u548c\u64cd\u4f5c\uff0c\u53ef\u4ee5\u4f7f\u7528\u5206\u5757\u5e73\u8861\u4e00\u4e0b\u590d\u6742\u5ea6\u3002\u603b\u590d\u6742\u5ea6 $O(n(\\log^2n+\\sqrt{n}))$\u3002\n\nupd\uff1a\u5728\u6ca1\u6709\u533a\u95f4\u52a0\u51cf\u64cd\u4f5c\u65f6 Segment Tree Beats \u7684\u590d\u6742\u5ea6\u662f $n\\log n$ \u7684\uff0c\u6240\u4ee5\u5176\u5b9e\u4e0d\u7528\u5206\u5757\uff0c\u76f4\u63a5\u6811\u72b6\u6570\u7ec4\u5373\u53ef\u3002\n\n\u53c2\u8003\u4ee3\u7801\uff08\u5206\u5757\uff09\uff1a\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define N 200005\n#define ll long long\n#define mid ((l+r)/2)\nconst int B=450,INF=1e9;\nint n,m;struct Seg {int tg,cnt,mx[2];}sg[N*4];\nint bl[N];ll s11[N],s12[N],s21[N],s22[N];\nvoid pu(int p)\n{\n\tsg[p].mx[0]=max(sg[p*2].mx[0],sg[p*2+1].mx[0]);\n\tsg[p].mx[1]=max(sg[p*2].mx[1],sg[p*2+1].mx[1]);sg[p].cnt=0;\n\tif(sg[p].mx[0]==sg[p*2].mx[0]) sg[p].cnt=sg[p*2].cnt;\n\telse sg[p].mx[1]=max(sg[p].mx[1],sg[p*2].mx[0]);\n\tif(sg[p].mx[0]==sg[p*2+1].mx[0]) sg[p].cnt+=sg[p*2+1].cnt;\n\telse sg[p].mx[1]=max(sg[p].mx[1],sg[p*2+1].mx[0]);\n}\nvoid upd2(int x,int vl)\n{\n\tif(x>n) return;s11[x]+=vl;s12[bl[x]]+=vl;\n\ts21[x]+=1ll*vl*x;s22[bl[x]]+=1ll*vl*x;\n}\nll qSm(int x)\n{\n\tif(!x) return 0;ll s1=0,s2=0;\n\tfor(int i=1;i<bl[x];++i) s1+=s12[i],s2+=s22[i];\n\tfor(int i=x;i>(bl[x]-1)*B;--i) s1+=s11[i],s2+=s21[i];return s1*(x+1)-s2;\n}\nvoid mdf(int p,int vl,bool fl=0)\n{\n\tif(fl) upd2(vl+1,-sg[p].cnt),upd2(sg[p].mx[0]+1,sg[p].cnt);\n\tsg[p].mx[0]=vl;sg[p].tg=min(sg[p].tg,vl);\n}\nvoid pd(int p)\n{\n\tif(sg[p].tg<INF)\n\t{\n\t\tif(sg[p*2].mx[0]>sg[p].tg) mdf(p*2,sg[p].tg);\n\t\tif(sg[p*2+1].mx[0]>sg[p].tg) mdf(p*2+1,sg[p].tg);sg[p].tg=INF;\n\t}\n}\nvoid build(int p,int l,int r)\n{\n\tsg[p].tg=INF;if(l==r) {sg[p]=(Seg) {INF,1,{l,0}};return;}\n\tbuild(p*2,l,mid);build(p*2+1,mid+1,r);pu(p);\n}\nvoid upd(int p,int l,int r,int qL,int qR,int vl)\n{\n\tif(qL>qR || sg[p].mx[0]<=vl) return;\n\tif(l>=qL && r<=qR && sg[p].mx[1]<vl) {mdf(p,vl,1);return;}\n\tpd(p);if(qL<=mid) upd(p*2,l,mid,qL,qR,vl);\n\tif(qR>mid) upd(p*2+1,mid+1,r,qL,qR,vl);pu(p);\n}\nvoid upd1(int p,int l,int r,int x,int vl)\n{\n\tif(l==r) {upd2(sg[p].mx[0]+1,1);upd2(vl+1,-1);sg[p].mx[0]=vl;return;}\n\tpd(p);if(x<=mid) upd1(p*2,l,mid,x,vl);else upd1(p*2+1,mid+1,r,x,vl);pu(p);\n}\nint qry(int p,int l,int r,int x)\n{\n\tif(l==r) return sg[p].mx[0];pd(p);\n\tif(x<=mid) return qry(p*2,l,mid,x);return qry(p*2+1,mid+1,r,x);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=n;++i) bl[i]=(i-1)/B+1;upd2(1,1);build(1,1,n);\n\tfor(int i=1,F[3];i<=m;++i)\n\t{\n\t\tscanf(\"%d %d %d\",&F[0],&F[1],&F[2]);\n\t\tif(F[0]==1) upd1(1,1,n,F[1],F[2]),upd(1,1,n,1,F[1]-1,F[1]-1);\n\t\tif(F[0]==2) printf(\"%lld\\n\",qSm(F[2])-qSm(F[1]-1));\n\t}return 0;\n}\n```",
        "postTime": 1639900839,
        "uid": 119621,
        "name": "Kubic",
        "ccfLevel": 10,
        "title": "CF1572F Stations"
    }
]