[
    {
        "content": "\u9898\u610f\u7565\u3002\n\n\u9996\u5148\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5982\u679c\u6811\u7684\u8fb9\u6743\u76f4\u63a5\u7ed9\u51fa\u7684\u5c31\u662f $0/1$\uff0c\u8fd9\u4e2a\u95ee\u9898\u662f\u5426\u53ef\u505a\u3002\n\n\u53ef\u4ee5\u3002\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 $\\text{sum, pre, suf, num}$\uff0c\u5206\u522b\u8868\u793a\u533a\u95f4\u7b54\u6848\uff0c\u533a\u95f4\u524d\u7f00 $1$ \u7684\u4e2a\u6570\uff0c\u533a\u95f4\u540e\u7f00 $1$ \u7684\u4e2a\u6570\uff0c\u533a\u95f4 $1$ \u7684\u4e2a\u6570\u3002\u518d\u5957\u4e00\u4e2a\u6811\u5256\u5c31\u53ef\u4ee5\u7ef4\u62a4\u6811\u4e0a\u8def\u5f84\u3002\n\n\u4f46\u73b0\u5728\u8fd9\u4e2a $0/1$ \u5e76\u4e0d\u662f\u4e00\u5f00\u59cb\u7ed9\u51fa\u7684\uff0c\u800c\u662f\u6839\u636e\u6bcf\u6b21\u8be2\u95ee\u7684 $l$ \u548c\u8fb9\u6743\u7684\u5173\u7cfb\u6765\u786e\u5b9a\u7684\u3002\u4f46\u8fd9\u4e2a\u95ee\u9898\u4e5f\u5f88\u597d\u5904\u7406\uff0c\u5c06\u8be2\u95ee\u79bb\u7ebf\uff0c\u4ee5 $l$ \u4e3a\u5173\u952e\u5b57\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\u3002\u4e00\u5f00\u59cb\u6811\u4e0a\u7684\u6240\u6709\u8fb9\u90fd\u662f $1$\uff0c\u968f\u7740 $l$ \u7684\u53d8\u5927\u4e00\u4e9b\u8fb9\u4ece $1$ \u53d8\u6210 $0$\uff0c\u800c\u4e14\u518d\u4e5f\u4e0d\u4f1a\u53d8\u6210 $1$\u3002\u6240\u4ee5\u6bcf\u6761\u8fb9\u6700\u591a\u53ea\u4f1a\u88ab\u4fee\u6539\u4e00\u6b21\uff0c\u4fdd\u8bc1\u4e86\u590d\u6742\u5ea6\u7684\u6b63\u786e\u3002\n\n\u6d41\u7a0b\u7efc\u8ff0\uff1a\u5c06\u8be2\u95ee\u6392\u5e8f\u3002\u6bcf\u6b21\u627e\u51fa\u6ee1\u8db3 $w \\ge l_{i - 1} \\land w < l_i$ \u7684\u8fb9\u5e76\u5728\u7ebf\u6bb5\u6811\u4e0a\u4fee\u6539\u5b83\u4eec\u7684\u503c\uff0c\u56de\u7b54\u8be2\u95ee\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n \\log^2 n)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define lc(u) (u << 1)\n#define rc(u) (u << 1 | 1)\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, Q, f[N];\nint tot;\nstruct Edge{\n\tint id, w;\n\tbool operator < (const Edge &k) const {\n\t\treturn w < k.w;\n\t}\n}a[N];\nstruct query{\n\tint u, v, l, id;\n\tbool operator < (const query &k) const {\n\t\treturn l < k.l;\n\t}\n}q[N];\nint head[N], cnt;\nstruct edge{\n\tint nxt, to, w, id;\n}e[N << 1];\nvoid add(int u, int v, int w, int id){\n\te[++cnt].nxt = head[u], e[cnt].to = v, e[cnt].w = w, e[cnt].id = id, head[u] = cnt;\n}\nint fa[N][19], dep[N], sz[N], son[N], dot[N];\nvoid dfs(int u){\n\tfor(int i = 1; i <= 17; i++) fa[u][i] = fa[fa[u][i - 1]][i - 1];\n\tsz[u] = 1;\n\tfor(int i = head[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to, id = e[i].id;\n\t\tif(v == fa[u][0]) continue;\n\t\tfa[v][0] = u, dep[v] = dep[u] + 1, dot[id] = v;\n\t\tdfs(v);\n\t\tsz[u] += sz[v];\n\t\tif(sz[v] > sz[son[u]]) son[u] = v;\n\t}\n}\nint dfn[N], pdfn, top[N];\nvoid dfs2(int u, int t){\n\tdfn[u] = ++pdfn, top[u] = t;\n\tif(son[u]) dfs2(son[u], t);\n\tfor(int i = head[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(top[v]) continue;\n\t\tdfs2(v, v);\n\t}\n}\nint lca(int u, int v){\n\twhile(top[u] != top[v]){\n\t\tif(dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tu = fa[top[u]][0];\n\t}\n\treturn dep[u] < dep[v] ? u : v;\n}\nint jump(int u, int d){\n\tfor(int i = 17; i >= 0; i--) if(dep[fa[u][i]] >= d) u = fa[u][i];\n\treturn u;\n}\nstruct node{\n\tint sum, pre, suf, num, len;\n\tnode(){\n\t\tsum = pre = suf = num = len = 0;\n\t}\n\tnode(int a, int b, int c, int d, int e){\n\t\tsum = a, pre = b, suf = c, num = d, len = e;\n\t}\n}t[N << 2];\nnode merge(node x, node y){\n\tnode z;\n\tz.sum = x.sum + y.sum - f[x.suf] - f[y.pre] + f[x.suf + y.pre];\n\tif(x.num == x.len) z.pre = x.num + y.pre;\n\telse z.pre = x.pre;\n\tif(y.num == y.len) z.suf = y.num + x.suf;\n\telse z.suf = y.suf;\n\tz.num = x.num + y.num, z.len = x.len + y.len;\n\treturn z;\n}\nvoid pushup(int u){\n\tt[u] = merge(t[lc(u)], t[rc(u)]);\n}\nvoid build(int u, int l, int r){\n\tif(l == r){\n\t\tt[u].sum = f[1], t[u].pre = t[u].suf = t[u].num = t[u].len = 1; return;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(lc(u), l, mid), build(rc(u), mid + 1, r);\n\tpushup(u);\n}\nvoid modify(int u, int l, int r, int x){\n\tif(l == r){\n\t\tt[u].sum = t[u].pre = t[u].suf = t[u].num = 0, t[u].len = 1; return;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(x <= mid) modify(lc(u), l, mid, x);\n\telse modify(rc(u), mid + 1, r, x);\n\tpushup(u);\n}\nnode query(int u, int l, int r, int x, int y){\n\tif(x > y) return node(0, 0, 0, 0, 0);\n\tif(l >= x && r <= y) return t[u];\n\tint mid = (l + r) >> 1;\n\tif(y <= mid) return query(lc(u), l, mid, x, y);\n\tif(x > mid) return query(rc(u), mid + 1, r, x, y);\n\treturn merge(query(lc(u), l, mid, x, y), query(rc(u), mid + 1, r, x, y)); \n}\nnode ask(int u, int v, int op){\n\tif(dep[u] < dep[v]) swap(u, v);\n\tint x = lca(u, v);\n\tif(x == v){\n\t\tnode res;\n\t\twhile(top[u] != top[v]){\n\t\t\tif(dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\t\tres = merge(query(1, 2, n, dfn[top[u]], dfn[u]), res);\n\t\t\tu = fa[top[u]][0];\n\t\t}\n\t\tif(dep[u] < dep[v]) swap(u, v);\n\t\tres = merge(query(1, 2, n, dfn[v] + op, dfn[u]), res);\n\t\treturn res;\n\t}\n\tnode tl = ask(u, x, 1), tr = ask(jump(v, dep[x] + 1), v, 0);\n\tswap(tl.pre, tl.suf);\n\treturn merge(tl, tr);\n}\nint ans[N];\nint main(){\n\tscanf(\"%d%d\", &n, &Q);\n\tfor(int i = 1; i < n; i++) scanf(\"%d\", &f[i]);\n\tfor(int i = 1, u, v, w; i < n; i++) scanf(\"%d%d%d\", &u, &v, &w), add(u, v, w, i), add(v, u, w, i), a[++tot] = {i, w};\n\tdep[1] = 1, dfs(1), dfs2(1, 1), build(1, 2, n);\n\tfor(int i = 1; i <= Q; i++) scanf(\"%d%d%d\", &q[i].u, &q[i].v, &q[i].l), q[i].id = i;\n\tsort(a + 1, a + tot + 1), sort(q + 1, q + Q + 1);\n\tint last = 0;\n\tfor(int i = 1; i <= Q; i++){\n\t\tint l = last + 1, r = tot, mid;\n\t\tbool flag = false;\n\t\twhile(l < r){\n\t\t\tmid = (l + r + 1) >> 1;\n\t\t\tif(a[mid].w < q[i].l) flag = true, l = mid;\n\t\t\telse r = mid - 1;\n\t\t}\n\t\tif(a[l].w < q[i].l) flag = true;\n\t\tif(flag){\n\t\t\tfor(int j = last + 1; j <= l; j++) modify(1, 2, n, dfn[dot[a[j].id]]);\n\t\t\tlast = l;\n\t\t}\n\t\tans[q[i].id] = ask(q[i].u, q[i].v, 1).sum;\n\t}\n\tfor(int i = 1; i <= Q; i++) printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1665817312,
        "uid": 385093,
        "name": "uniqueharry",
        "ccfLevel": 0,
        "title": "CF536E Tavas on the Path \u9898\u89e3"
    },
    {
        "content": "\u5206\u6790\u8be2\u95ee\u7684\u6027\u8d28\uff1a\u7ed9\u51fa $(u,v,l)$\uff0c$u\\to v$ \u8def\u5f84\u4e0a\u8fb9\u6743 $w_i\\ge l$ \u8bb0\u4e3a $1$\uff0c\u5426\u5219\u8bb0\u4e3a $0$\uff0c\u6c42\u8fde\u7eed $1$ \u6bb5\u7684\u6743\u503c\u4e4b\u548c\u3002\n\n\u9996\u5148\u5c06\u8fb9\u6743\u4e0b\u653e\u5230\u70b9\u6743\u3002\n\n\u53d1\u73b0\u4e0d\u597d\u5dee\u5206\u4f18\u5316 $u,v$\uff0c\u90a3\u6211\u4eec\u4ece $l$ \u4e0b\u624b\u3002\u7531\u4e8e $l$ \u6807\u8bb0\u7684\u662f\u4e00\u6bb5\u540e\u7f00\uff0c\u8fd9\u662f\u53ef\u4ee5\u626b\u7684\u3002\u79bb\u7ebf\u8be2\u95ee\uff0c\u5c06 $w_i$ \u548c $l$ \u90fd\u9012\u51cf\u6392\u5e8f\uff0c\u626b\u63cf $l$ \u8fd9\u4e00\u7ef4\u5ea6\uff0c\u6bcf\u6b21\u53ea\u9700\u8981\u5c06 $w_i\\ge l$ \u7684 $w_i$ \u5728\u6811\u4e0a\u7684\u6743\u503c\u4ece $0$ \u4fee\u6539\u4e3a $1$\uff0c\u7136\u540e\u6811\u5256\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7ef4\u62a4\u94fe\u6743\u503c\u5373\u53ef\u3002\n\n\u7ec6\u8282\u53ef\u89c1\u4ee3\u7801\uff08\u5982\u679c WA \u5f88\u5927\u53ef\u80fd\u662f\u6811\u5256\u5411\u4e0a\u8df3\u5199\u9519\u4e86\uff09\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c<='9'&&c>='0'){\n\t\tx=(x<<1)+(x<<3)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\n\nvoid print(int x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)print(x/10);\n\tputchar(x%10^48);\n}\n\nconst int N=1e5+5;\nint n,m,head[N],cnt,f[N];\nint fa[N],dfn[N],cnt1,dep[N],top[N],hson[N],siz[N],w[N];\nstruct G{\n\tint next,to,w;\n}e[N<<1];\n\nvoid add(int from,int to,int w){\n\te[++cnt]=(G){head[from],to,w};\n\thead[from]=cnt;\n} \n\nstruct SGT{\n\tstruct node{\n\t\tint val,pre,suf,len;\n\t}t[N<<2];\n\t\n\tnode R(node x){\n\t\tswap(x.pre,x.suf);\n\t\treturn x;\n\t}\n\t\n\tnode push_up(node ls,node rs){\n\t\tnode ans;\n\t\tans.val=ls.val+rs.val-f[ls.suf]-f[rs.pre]+f[ls.suf+rs.pre];\n\t\tans.pre=ls.pre+(ls.pre==ls.len?rs.pre:0);\n\t\tans.suf=rs.suf+(rs.suf==rs.len?ls.suf:0);\n\t\tans.len=ls.len+rs.len;\n\t\treturn ans;\n\t}\n\t\n\tvoid build(int l,int r,int p){\n\t\tif(l==r){t[p].len=1;return;}\n\t\tint mid=(l+r)>>1;\n\t\tbuild(l,mid,p<<1),build(mid+1,r,p<<1|1);\n\t\tt[p]=push_up(t[p<<1],t[p<<1|1]);\n\t}\n\t\n\tvoid modify(int l,int r,int pos,int p){\n\t\tif(l==r){\n\t\t\tt[p].val=f[1],t[p].pre=t[p].suf=1;return;\n\t\t}\n\t\tint mid=(l+r)>>1;\n\t\tif(pos<=mid)modify(l,mid,pos,p<<1);\n\t\telse modify(mid+1,r,pos,p<<1|1);\n\t\tt[p]=push_up(t[p<<1],t[p<<1|1]);\n\t}\n\t\n\tnode qry(int l,int r,int lq,int rq,int p){\n\t\tif(lq>rq||lq>r||rq<l)return (node){0,0,0,0};\n\t\tif(lq<=l&&r<=rq)return t[p];\n\t\tint mid=(l+r)>>1;node ans=(node){0,0,0,0};\n\t\tif(lq<=mid)ans=push_up(ans,qry(l,mid,lq,rq,p<<1));\n\t\tif(mid<rq)ans=push_up(ans,qry(mid+1,r,lq,rq,p<<1|1));\n\t\treturn ans;\n\t}\n}T;\n\nstruct HLD{\n\tvoid dfs1(int x){\n\t\tsiz[x]=1,dep[x]=dep[fa[x]]+1;\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint y=e[i].to;\n\t\t\tif(y==fa[x])continue;\n\t\t\tfa[y]=x,w[y]=e[i].w,dfs1(y),siz[x]+=siz[y];\n\t\t\tif(siz[y]>siz[hson[x]])hson[x]=y;\n\t\t}\n\t}\n\t\n\tvoid dfs2(int x,int topx){\n\t\ttop[x]=topx,dfn[x]=++cnt1;\n\t\tif(!hson[x])return;\n\t\tdfs2(hson[x],topx);\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint y=e[i].to;\n\t\t\tif(y==fa[x]||y==hson[x])continue;\n\t\t\tdfs2(y,y);\n\t\t}\n\t}\n\t\n\tint qry(int x,int y){\n\t\tSGT::node ansx=(SGT::node){0,0,0,0},ansy=(SGT::node){0,0,0,0};\n\t\twhile(top[x]!=top[y]){\n\t\t\tif(dep[top[x]]<dep[top[y]]){\n\t\t\t\tansy=T.push_up(T.qry(1,n,dfn[top[y]],dfn[y],1),ansy);\n\t\t\t\ty=fa[top[y]];\n\t\t\t}else{\n\t\t\t\tansx=T.push_up(ansx,T.R(T.qry(1,n,dfn[top[x]],dfn[x],1)));\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t}\n\t\tif(dep[x]>dep[y])return T.push_up(T.push_up(ansx,T.R(T.qry(1,n,dfn[y]+1,dfn[x],1))),ansy).val;\n\t\treturn T.push_up(T.push_up(ansx,T.qry(1,n,dfn[x]+1,dfn[y],1)),ansy).val;\n\t}\n}L;\n\nstruct NODE{\n\tint val,x;\n\tbool operator<(const NODE &P)const{return val>P.val;}\n}p[N];\nstruct Q{\n\tint u,v,l,id;\n\tbool operator<(const Q &P)const{return l>P.l;}\n}que[N];\nint ans[N],num;\n\nint main(){\n\tn=read(),m=read();\n\tfor(int i=1;i<n;++i)f[i]=read();\n\tfor(int i=1;i<n;++i){\n\t\tint u=read(),v=read(),w=read();\n\t\tadd(u,v,w),add(v,u,w);\n\t}\n\tL.dfs1(1),L.dfs2(1,1),T.build(1,n,1);\n\tfor(int i=2;i<=n;++i)p[i-1]=(NODE){w[i],i};\n\tsort(p+1,p+n);\n\tfor(int i=1;i<=m;++i)que[i].u=read(),que[i].v=read(),que[i].l=read(),que[i].id=i;\n\tsort(que+1,que+m+1);\n\tfor(int i=1,t=1;i<=m;++i){\n\t\twhile(t<n&&p[t].val>=que[i].l){\n\t\t\tT.modify(1,n,dfn[p[t].x],1);++t;\n\t\t}\n\t\tans[que[i].id]=L.qry(que[i].u,que[i].v);\n\t}\n\tfor(int i=1;i<=m;++i)print(ans[i]),puts(\"\");\n\treturn 0;\n}\n```",
        "postTime": 1676507464,
        "uid": 271736,
        "name": "Daidly",
        "ccfLevel": 6,
        "title": "CF536E Tavas on the Path \u9898\u89e3"
    },
    {
        "content": "\u5c0f\u6e05\u65b0\u6811\u5256\u9898\u3002\r\n\r\n\u663e\u7136\u4e0d\u597d\u76f4\u63a5\u505a\uff0c\u79bb\u7ebf\u4e0b\u6765\u5bf9 $l$ \u626b\u63cf\u7ebf\u3002\r\n\r\n\u65f6\u523b\u4fdd\u8bc1 $\\forall x_i\\ge l,s_i=1$\uff0c\u7136\u540e\u6bcf\u6761\u8fb9\u7684 $s_i$ \u53ea\u4f1a\u53d8\u5316\u4e00\u6b21\u3002\r\n\r\n\u53d1\u73b0\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u989c\u8272\u6bb5\u4fe1\u606f\uff0c\u8003\u8651\u6811\u5256\u5957\u7ebf\u6bb5\u6811\u3002\r\n\r\n\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9\u4e0a\u7ef4\u62a4\u524d\u7f00 $1$ \u7684\u4e2a\u6570\uff0c\u540e\u7f00 $1$ \u7684\u4e2a\u6570\uff0c$1$ \u7684\u4e2a\u6570\u548c\u7b54\u6848\u3002\r\n\r\n\u6ce8\u610f push up \u65f6\u5de6\u5b69\u5b50\u7684\u540e\u7f00 $1$ \u548c\u53f3\u5b69\u5b50\u7684\u524d\u7f00 $1$ \u5f62\u6210\u65b0\u6bb5\u3002\r\n```cpp\r\n#include <cstdio>\r\n#include <algorithm>\r\n#define G int m = p->s + p->t >> 1\r\nusing namespace std;\r\nstruct E\r\n{\r\n    int v, w, t;\r\n} e[200050];\r\nstruct S\r\n{\r\n    int u, v, l, i;\r\n} k[100050];\r\npair<int, int> g[100050];\r\nint n, m, c, p, F[100050], K[100050], z[100050], d[100050],\r\n    f[100050], s[100050], t[100050], b[100050], h[100050];\r\nbool C(S a, S b) { return a.l < b.l; }\r\nvoid A(int u, int v, int w)\r\n{\r\n    e[++c] = {v, w, h[u]};\r\n    h[u] = c;\r\n}\r\nvoid X(int u)\r\n{\r\n    s[u] = 1;\r\n    for (int i = h[u], v; i; i = e[i].t)\r\n        if (!d[v = e[i].v])\r\n        {\r\n            f[v] = u;\r\n            d[v] = d[u] + 1;\r\n            g[v] = {e[i].w, v};\r\n            X(v);\r\n            s[u] += s[v];\r\n            if (s[v] > s[z[u]])\r\n                z[u] = v;\r\n        }\r\n}\r\nvoid Y(int u, int g)\r\n{\r\n    t[u] = g;\r\n    b[u] = ++p;\r\n    if (z[u])\r\n        Y(z[u], g);\r\n    for (int i = h[u], v; i; i = e[i].t)\r\n        if ((v = e[i].v) != z[u] && v != f[u])\r\n            Y(v, v);\r\n}\r\nstruct T\r\n{\r\n    T *l, *r;\r\n    int s, t, q, x, y, v;\r\n    T(int s, int t) : s(s), t(t) {}\r\n    void u()\r\n    {\r\n        v = l->v + r->v;\r\n        x = l->v == l->t - l->s + 1 ? l->v + r->x : l->x;\r\n        y = r->v == r->t - r->s + 1 ? r->v + l->y : r->y;\r\n        q = l->q + r->q - F[l->y] - F[r->x] + F[l->y + r->x];\r\n    }\r\n} * r;\r\nT *U(T *x, T *y)\r\n{\r\n    if (!x)\r\n        return y;\r\n    if (!y)\r\n        return x;\r\n    T *p = new T(x->s, y->t);\r\n    p->l = x;\r\n    p->r = y;\r\n    p->u();\r\n    return p;\r\n}\r\nvoid B(int s, int t, T *&p)\r\n{\r\n    p = new T(s, t);\r\n    if (s == t)\r\n        return void(p->q = F[p->x = p->y = p->v = 1]);\r\n    G;\r\n    B(s, m, p->l);\r\n    B(m + 1, t, p->r);\r\n    p->u();\r\n}\r\nvoid M(int l, T *p)\r\n{\r\n    if (p->s == p->t)\r\n        return void(p->q = p->x = p->y = p->v = 0);\r\n    G;\r\n    if (l <= m)\r\n        M(l, p->l);\r\n    else\r\n        M(l, p->r);\r\n    p->u();\r\n}\r\nT *Q(int l, int r, T *p)\r\n{\r\n    if (l <= p->s && p->t <= r)\r\n        return p;\r\n    G;\r\n    if (l <= m && r > m)\r\n        return U(Q(l, r, p->l), Q(l, r, p->r));\r\n    if (l <= m)\r\n        return Q(l, r, p->l);\r\n    if (r > m)\r\n        return Q(l, r, p->r);\r\n}\r\nint main()\r\n{\r\n    scanf(\"%d%d\", &n, &m);\r\n    for (int i = 1; i < n; ++i)\r\n        scanf(\"%d\", F + i);\r\n    for (int i = 1, u, v, w; i < n; ++i)\r\n        scanf(\"%d%d%d\", &u, &v, &w), A(u, v, w), A(v, u, w);\r\n    X(d[1] = 1);\r\n    Y(1, 1);\r\n    B(1, n, r);\r\n    sort(g + 2, g + n + 1);\r\n    for (int i = 0; i < m; ++i)\r\n        scanf(\"%d%d%d\", &k[i].u, &k[i].v, &k[i].l), k[i].i = i;\r\n    sort(k, k + m, C);\r\n    for (int i = 0, j = 1, u, v; i < m; ++i)\r\n    {\r\n        while (j < n && g[j + 1].first < k[i].l)\r\n            M(b[g[++j].second], r);\r\n        u = k[i].u;\r\n        v = k[i].v;\r\n        T *p = 0, *q = 0;\r\n        while (t[u] != t[v])\r\n        {\r\n            if (d[t[u]] > d[t[v]])\r\n                p = U(Q(b[t[u]], b[u], r), p), u = f[t[u]];\r\n            else\r\n                q = U(Q(b[t[v]], b[v], r), q), v = f[t[v]];\r\n        }\r\n        if (u != v)\r\n        {\r\n            if (d[u] > d[v])\r\n                p = U(Q(b[v] + 1, b[u], r), p);\r\n            else\r\n                q = U(Q(b[u] + 1, b[v], r), q);\r\n        }\r\n        if (p)\r\n            p = new T(*p), swap(p->x, p->y);\r\n        K[k[i].i] = U(p, q)->q;\r\n    }\r\n    for (int i = 0; i < m; ++i)\r\n        printf(\"%d\\n\", K[i]);\r\n    return 0;\r\n}\r\n```\r\n",
        "postTime": 1677456633,
        "uid": 388651,
        "name": "5k_sync_closer",
        "ccfLevel": 7,
        "title": "CF536E Tavas on the Path \u9898\u89e3"
    }
]