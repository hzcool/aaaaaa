[
    {
        "content": "\u9996\u5148\u4ee4 $a_i=\\operatorname{lcp}(s_i,s_{i+1})$\uff0c\u539f\u95ee\u9898\u8f6c\u5316\u6210\u6c42 $[l,r]$ \u5185  $\\min\\limits_{L\\le i< R}\\{s_i\\}\\times(R-L+1)$ \u7684\u6700\u5927\u503c\uff0c\u5355\u70b9\u4fee\u6539\u3002\u5bf9\u4e8e $L=R$ \u7684\u90e8\u5206\u5c31\u662f\u6c42\u6700\u5927\u957f\u5ea6\uff0c\u663e\u7136\u7ebf\u6bb5\u6811\u53ef\u4ee5\u89e3\u51b3\u3002\u5269\u4e0b\u7684\u5c31\u662f\u6c42 $\\min\\limits_{L\\le i\\le R}\\{s_i\\}\\times(R-L+2)$ \u7684\u6700\u5927\u503c\uff0c$l\\le L\\le R<r$\u3002\n\n\u6ce8\u610f\u5230\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u6027\u8d28\uff1a\u5b57\u7b26\u4e32\u957f\u5ea6\u603b\u548c\u4e0d\u8d85\u8fc7 $10^5$\uff0c\u5373 $\\sum a_i\\le 10^5$\u3002\u6240\u4ee5\u8003\u8651\u6839\u53f7\u5206\u6cbb\u3002\u8bbe\u5b9a\u9608\u503c $T$\uff0c\u628a\u7b54\u6848\u6309\u7167\u533a\u95f4\u6700\u5c0f\u503c\u7684\u5927\u5c0f\u5206\u6210\u4e24\u7c7b\u3002\n\n1. \u533a\u95f4\u6700\u5c0f\u503c $\\le T$\u3002\u5047\u8bbe\u5df2\u7ecf\u77e5\u9053\u6700\u5c0f\u503c\u4e3a $x$\uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u67d0\u4e2a\u6570\u662f\u5426\u5927\u4e8e\u7b49\u4e8e $x$\u3002\u90a3\u4e48\u628a\u5927\u4e8e\u7b49\u4e8e $x$ \u7684\u6570\u6807\u4e3a $1$\uff0c\u5269\u4e0b\u7684\u6807\u4e3a $0$\uff0c\u53ea\u9700\u8981\u6c42\u51fa\u533a\u95f4 $[l,r-1]$ \u5185\u7684\u6700\u957f\u7684\u53ea\u5305\u542b $1$ \u7684\u8fde\u7eed\u6bb5\u3002\u7528 $T$ \u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n2. \u533a\u95f4\u6700\u5c0f\u503c $>T$\u3002\u8fd9\u6837\u7684\u4f4d\u7f6e\u6700\u591a $\\dfrac{10^5}{T}$ \u4e2a\u3002\u5047\u8bbe\u5176\u4e2d\u5b58\u5728\u4e00\u4e2a\u8fde\u7eed\u533a\u95f4 $[p,q]$ \u5e76\u4e14\u662f $[L,R]$ \u7684\u5b50\u533a\u95f4\uff0c\u5bf9\u4e8e\u5176\u4e2d\u7684\u6bcf\u4e00\u4e2a $i$\uff0c\u7528\u5355\u8c03\u6808\u6c42\u51fa $lp_i,rp_i$\uff0c\u5206\u522b\u8868\u793a $i$ \u5f80\u5de6 / \u5f80\u53f3\u7b2c\u4e00\u4e2a\u5c0f\u4e8e $a_i$ \u7684\u4f4d\u7f6e\u3002\u90a3\u4e48\u4ee5 $a_i$ \u4e3a\u6700\u5c0f\u503c\u7684\u533a\u95f4\u7684\u7b54\u6848\u5c31\u662f $a_i\\times(rp_i-lp_i)$\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $O(q(\\dfrac{\\sum|s_i|}{T}+T\\log n))$\uff0c\u53d6 $T=\\sqrt{\\dfrac{\\sum|s_i|}{\\log n}}$ \u65f6\u6700\u4f18\uff0c\u4e3a $O(q\\sqrt{(\\sum|s_i|)\\log n})$\u3002\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n#define ci const int\ninline int max(ci &x, ci &y) { return x > y ? x : y; }\ninline int min(ci &x, ci &y) { return x < y ? x : y; }\ninline void swap(int &x, int &y) { x ^= y ^= x ^= y; }\ninline void chmax(ll &x, ll y) { if(x < y) x = y; }\ninline void chmax(int &x, int y) { if(x < y) x = y; }\n#define rei register int\n#define rep(i, l, r) for(rei i = l, i##end = r; i <= i##end; ++ i)\n#define per(i, r, l) for(rei i = r, i##end = l; i >= i##end; -- i)\nconst int N = 1e5 + 15, T = 30;\nstring s[N];\nint lch[N * 2], rch[N * 2], sgtt;\nint pos[N], L[N], R[N], tot;\nint stk[N];\nint a[N], n, q;\n\ninline int lcp(string &a, string &b) {\n\tint len = 0, n = min(a.size(), b.size());\n\tfor(; len < n && a[len] == b[len]; ++ len) ;\n\treturn len;\n}\n\nstruct node {\n\tint mx, cl, cr;\n\tbool a1;\n\tnode(int _mx = 0, int _cl = 0, int _cr = 0, bool _a1 = 0)\n\t\t: mx(_mx), cl(_cl), cr(_cr), a1(_a1) { }\n} ;\n\nnode merge(const node &x, const node &y) {\n\treturn node(max(max(x.mx, y.mx), x.cr + y.cl),\n\t\tx.cl + (x.a1 ? y.cl : 0), y.cr + (y.a1 ? x.cr : 0), x.a1 && y.a1);\n}\n\nint build(int l, int r) {\n\tint p = ++ sgtt;\n\tif(l == r) return p;\n\tint mid = l + r >> 1;\n\tlch[p] = build(l, mid);\n\trch[p] = build(mid + 1, r);\n\treturn p;\n}\n\n#define lc lch[p]\n#define rc rch[p]\n\nstruct SSGT {\n\tint t[N * 2];\n\n\tinline void update(int p) {\n\t\tt[p] = max(t[lc], t[rc]);\n\t}\n\n\tvoid build(int p, int l, int r) {\n\t\tif(l == r) {\n\t\t\tt[p] = s[l].size();\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tbuild(lc, l, mid);\n\t\tbuild(rc, mid + 1, r);\n\t\tupdate(p);\n\t}\n\n\tvoid modify(int p, int l, int r, ci &tt) {\n\t\tif(l == r) {\n\t\t\tt[p] = s[l].size();\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tif(tt <= mid) modify(lc, l, mid, tt);\n\t\telse modify(rc, mid + 1, r, tt);\n\t\tupdate(p);\n\t}\n\n\tint query(int p, int l, int r, ci &tl, ci &tr) {\n\t\tif(tl <= l && r <= tr) return t[p];\n\t\tint mid = l + r >> 1, res = 0;\n\t\tif(tl <= mid) chmax(res, query(lc, l, mid, tl, tr));\n\t\tif(mid < tr) chmax(res, query(rc, mid + 1, r, tl, tr));\n\t\treturn res;\n\t}\n\n} t2;\n\nstruct SGT {\n\tint val;\n\tnode t[N * 2];\n\n\tinline void update(int p) {\n\t\tt[p] = merge(t[lc], t[rc]);\n\t}\n\n\tvoid build(int p, int l, int r) {\n\t\tif(l == r) {\n\t\t\tt[p].mx = t[p].cl = t[p].cr = t[p].a1 = a[l] >= val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tbuild(lc, l, mid);\n\t\tbuild(rc, mid + 1, r);\n\t\tupdate(p);\n\t}\n\n\tvoid modify(int p, int l, int r, ci &tt) {\n\t\tif(l == r) {\n\t\t\tt[p].mx = t[p].cl = t[p].cr = t[p].a1 = a[l] >= val;\n\t\t\treturn ;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tif(tt <= mid) modify(lc, l, mid, tt);\n\t\telse modify(rc, mid + 1, r, tt);\n\t\tupdate(p);\n\t}\n\n\tnode query(int p, int l, int r, ci &tl, ci &tr) {\n\t\tif(tl <= l && r <= tr) return t[p];\n\t\tint mid = l + r >> 1;\n\t\tif(tr <= mid) return query(lc, l, mid, tl, tr);\n\t\telse if(mid < tl) return query(rc, mid + 1, r, tl, tr);\n\t\telse return merge(query(lc, l, mid, tl, tr), query(rc, mid + 1, r, tl, tr));\n\t}\n\n} rt[T + 1];\n\nvoid init() {\n\tint res = build(1, n);\n\tt2.build(1, 1, n);\n\trep(i, 1, T) {\n\t\trt[i].val = i;\n\t\trt[i].build(1, 1, n);\n\t}\n\trep(i, 1, n) if(a[i] > T) pos[++ tot] = i;\n}\n\nvoid modify(int i) {\n\tint nv = lcp(s[i], s[i + 1]), x;\n\tif(a[i] > T && nv <= T) {\n\t\tx = lower_bound(pos + 1, pos + tot + 1, i) - pos;\n\t\trep(j, x, tot - 1) pos[j] = pos[j + 1];\n\t\ttot -- ;\n\t}\n\tif(a[i] <= T && nv > T) {\n\t\tx = lower_bound(pos + 1, pos + tot + 1, i) - pos;\n\t\ttot ++ ;\n\t\tper(j, tot, x + 1) pos[j] = pos[j - 1];\n\t\tpos[x] = i;\n\t}\n\tswap(a[i], nv);\n\trep(v, 1, min(T, max(a[i], nv))) rt[v].modify(1, 1, n, i);\n}\n\nll solve(int l, int r) {\n\tll res = 0;\n\tint top;\n\trep(i, l, r) R[i] = r + 1;\n\tstk[top = 1] = l;\n\trep(i, l + 1, r) {\n\t\tfor(; top && a[stk[top]] > a[i]; -- top)\n\t\t\tR[stk[top]] = i;\n\t\tstk[++ top] = i;\n\t}\n\trep(i, l, r) L[i] = l - 1;\n\tstk[top = 1] = r;\n\tper(i, r - 1, l) {\n\t\tfor(; top && a[stk[top]] > a[i]; -- top)\n\t\t\tL[stk[top]] = i;\n\t\tstk[++ top] = i;\n\t}\n\trep(i, l, r) chmax(res, 1ll * a[i] * (R[i] - L[i]));\n\treturn res;\n}\n\nll query(int l, int r) {\n\tll res = 0, x;\n\trep(v, 1, T) {\n\t\tx = rt[v].query(1, 1, n, l, r - 1).mx;\n\t\tif(x) chmax(res, 1ll * v * (x + 1));\n\t\telse break;\n\t}\n\tfor(rei L = lower_bound(pos + 1, pos + tot + 1, l) - pos, R; L <= tot && pos[L] < r; L = R + 1) {\n\t\tfor(R = L; R < tot && pos[R + 1] < r && pos[R] + 1 == pos[R + 1]; ++ R) ;\n\t\tchmax(res, solve(pos[L], pos[R]));\n\t}\n\tchmax(res, t2.query(1, 1, n, l, r));\n\treturn res;\n}\n\nsigned main() {\n\tint opt, l, r;\n\tios :: sync_with_stdio(0);\n\tcin.tie(nullptr);\n\tcin >> n >> q;\n\trep(i, 1, n) cin >> s[i];\n\trep(i, 1, n - 1) a[i] = lcp(s[i], s[i + 1]);\n\tinit();\n\tfor(; q; -- q) {\n\t\tcin >> opt >> l;\n\t\tif(opt == 1) {\n\t\t\tcin >> r;\n\t\t\tif(l == r) printf(\"%d\\n\", s[l].size());\n\t\t\telse printf(\"%lld\\n\", query(l, r));\n\t\t} else {\n\t\t\tcin >> s[l];\n\t\t\tt2.modify(1, 1, n, l);\n\t\t\tif(l > 1) modify(l - 1);\n\t\t\tif(l < n) modify(l);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1630567361,
        "uid": 214437,
        "name": "IntrepidStrayer",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF862F Mahmoud and Ehab and the final stage"
    },
    {
        "content": "\u8fd9\u9898\u7a0d\u5fae\u6709\u70b9\u8003\u9a8c\u7801\u529b\u5440QwQ  \n\u6709\u4e24\u79cd\u65b9\u6cd5\u3002  \n\u65b9\u6cd5\u4e00\uff1a  \n\u9996\u5148\u770b\u5230lcp\uff0c\u5199\u8fc7\u540e\u7f00\u6570\u7ec4\u7684\u540c\u5b66\u80af\u5b9a\u90fd\u77e5\u9053\u628a\u5b83\u5316\u4e3a\u533a\u95f4\u6700\u5c0f\u503c\u67e5\u8be2\u3002\u4e8e\u662f\u9898\u76ee\u5c31\u53d8\u6210\u4e86\u6700\u5927\u5316$min(x_i,i\\in[l,r])\\cdot (r-l+1+1)$\u3002  \n\u63a5\u7740\u770b\u5230\u533a\u95f4\u67e5\u8be2\uff0c\u6211\u4eec\u60f3\u5230\u7ebf\u6bb5\u6811\u3002\u518d\u7531\u6700\u5927\u5316\u67d0\u5b50\u6bb5\u7684\u67d0\u4e2a\u503c\u60f3\u5230\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u3002\u6309\u7167\u533a\u95f4\u6700\u5927\u5b50\u6bb5\u548c\u7684\u65b9\u6cd5\uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u7684\u67d0\u7ed3\u70b9\u7ef4\u62a4\u672c\u533a\u95f4\u6700\u5927\u503c\u548c\u533a\u95f4\u4e24\u7aef\u7684\u67d0\u4e9b\u4fe1\u606f\u3002\u4f46\u662f\u600e\u6837\u7ef4\u62a4\u4fe1\u606f\u624d\u53ef\u4ee5\u652f\u6301\u5feb\u901f\u8ba1\u7b97\u51fa \u6a2a\u8de8\u4e24\u533a\u95f4\u7684\u5b50\u6bb5\u7684\u6700\u5927\u503c\u4ece\u800c\u5feb\u901f\u5408\u5e76\u5462\uff1f  \n\u63a5\u7740\u6211\u4eec\u53d1\u73b0\uff0c\u7531\u4e8e\u5b57\u7b26\u4e32\u603b\u957f\u5ea6\u4e3a$n$\uff0c\u8fd9\u5c31\u4fdd\u8bc1\u4e86\u6240\u6709lcp\u7684\u4e0d\u540c\u7684\u503c\u4e0d\u4f1a\u592a\u591a\uff0c\u4e8b\u5b9e\u4e0a\uff0c\u4e0d\u540c\u503c\u7684\u6570\u91cf\u4e0d\u4f1a\u8d85\u8fc7$\\sqrt{n}$\u3002\u5229\u7528\u8fd9\u4e00\u70b9\uff0c\u6211\u4eec\u53ef\u4ee5\u60f3\u4e00\u4e9b\u5de7\u5999\u7684\u529e\u6cd5\u3002\u4e8e\u662f\u60f3\u5230\uff0c\u5728\u533a\u95f4\u7684\u4e00\u7aef\u7ef4\u62a4\u4ece\u7aef\u70b9\u51fa\u53d1\uff0c\u6700\u5c0f\u503c\u4e3a$k$\u7684\u5b50\u6bb5\u7684\u6700\u5927\u957f\u5ea6$b$\u3002\u7531\u4e8e\u4e0a\u9762\u7684\u6027\u8d28\uff0c\u6bcf\u4e2a\u533a\u95f4\u6211\u4eec\u6700\u591a\u7ef4\u62a4\u6839\u53f7\u4e2a$k$\u548c\u5bf9\u5e94\u7684$b$\u3002\u4e3a\u4e86\u65b9\u4fbf\uff0c\u6211\u4eec\u628a\u8fd9\u6837\u4e00\u7ec4\u4fe1\u606f\u8bb0\u4f5c$(k,b)$\u3002  \n\u5982\u4f55\u5229\u7528\u8fd9\u4e9b\u4fe1\u606f\u5408\u5e76\u5462\uff1f\u7531\u6700\u5927\u5b50\u6bb5\u548c\uff0c\u6211\u4eec\u60f3\u5230\u4e86lxl\u548c\u4ed6\u7684\u67d0\u4e2a~~\u6bd2\u7624\u7684~~\u53ef\u7231\u7684\u5206\u5757\u9898\u3002\u4e8e\u662f\u6211\u4eec\u60f3\u5230\u4e86\u7ef4\u62a4\u51f8\u58f3\uff08\u534a\u5e73\u9762\u4ea4\uff09\u3002\u5408\u5e76\u65b9\u6cd5\u5982\u4e0b\uff1a\u6211\u4eec\u679a\u4e3e\u5de6\u5b50\u533a\u95f4\u7684\u53f3\u7aef\u70b9\u7684\u6bcf\u7ec4$(lk,lb)$\uff0c\u5728\u53f3\u5b50\u533a\u95f4\u7684\u5de6\u7aef\u70b9\u7684\u6240\u6709$(rk,rb)$\u4e2d\uff0c\u6211\u4eec\u5bfb\u627e\u4e00\u7ec4\u4f7f\u5f97\u5f53\u524d\u679a\u4e3e\u7684$(lk,lb)$\u4e0e\u5b83\u5408\u5e76\u540e\u6700\u5927\u3002\u4e5f\u5c31\u662f\u8981\u6700\u5927\u5316$min(lk,rk)\\cdot(lb+rb+1)$\u3002\u4e3a\u4e86\u53bb\u6389min\uff0c\u6211\u4eec\u628a$rb$\u5206\u4e3a\u5927\u4e8e\u7b49\u4e8e$lb$\u548c\u5c0f\u4e8e$lb$\u4e24\u7ec4\u3002\u5bf9\u4e8e\u7b2c\u4e00\u7ec4\uff0c\u6211\u4eec\u53ea\u9700\u4ee4$rb$\u6700\u5927\u3002\u5bf9\u4e8e\u7b2c\u4e8c\u7ec4\uff0c\u6211\u4eec\u628a\u6bcf\u4e00\u7ec4$(rk,rb)$\u770b\u4f5c\u4e00\u6761\u76f4\u7ebf$f(x)=rk\\cdot x+(rb+1)rk$\u3002\u4e8e\u662f\u5b83\u4e0e\u5f53\u524d\u7684$(lk,lb)$\u7ed3\u5408\u540e\u4ea7\u751f\u7684\u503c\u5c31\u662f$f(lb)$\u3002\u8fd9\u65f6\u5bf9\u7b2c\u4e8c\u7ec4\u6240\u6709\u76f4\u7ebf\u7ef4\u62a4\u4e00\u4e2a\u51f8\u58f3\u5c31\u53ef\u4ee5\u5feb\u901f$O(logn)$\u627e\u5230\u7b54\u6848\u4e86\u3002  \n\u4f46\u662f\u8fd8\u53ef\u4ee5\u4f18\u5316\u3002\u6211\u4eec\u6309\u7167$lk$\u4ece\u5c0f\u5230\u5927\u7684\u987a\u5e8f\u679a\u4e3e$(lk,lb)$,\u4e00\u4e2a\u4e2a\u628a$(rk,rb)$\u52a0\u5165\u51f8\u58f3\u3002\u540c\u65f6\u7ef4\u62a4\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4f7f\u5f53\u524d$lb$\u6700\u5927\u7684\u76f4\u7ebf\uff0c\u6bcf\u6b21\u52a0\u5165\u65b0\u76f4\u7ebf\u540e\u5de6\u53f3\u79fb\u52a8\u6307\u9488\u5373\u53ef\u3002\u7531\u4e8e$lb$\u7684\u5355\u8c03\u6027\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u603b\u5171\u662f$O(n)$\u7684\uff08n\u6307\u5f53\u524d\u533a\u95f4\u4e2d$(k,b)$\u5bf9\u7684\u6570\u91cf\uff09\u3002  \n\u4e5f\u5c31\u662f\u8bf4\uff0c\u6211\u4eec\u505a\u5230\u4e86$O(\\sqrt{n})$\u5408\u5e76\u7ebf\u6bb5\u6811\u7ed3\u70b9\u7684\u4fe1\u606f\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u666e\u901a\u7ebf\u6bb5\u6811\u64cd\u4f5c\u4e86\u3002\u6240\u4ee5\u8bf4\u4e00\u6b21\u64cd\u4f5c$O(\\sqrt{n}logn)$\uff0c\u603b\u590d\u6742\u5ea6$O(n\\sqrt{n}logn)$\u3002\u4f46\u4e8b\u5b9e\u4e0a\u8be5\u65b9\u6cd5\u7684\u5e38\u6570\u6781\u5176\u5c0f\uff0c\u6700\u6162\u7684\u70b9\u7528\u65f6\u4e5f\u4e0d\u8fc71s\u6574QwQ  \n\u65b9\u6cd5\u4e8c\uff1a  \n[http://codeforces.com/blog/entry/54590](http://codeforces.com/blog/entry/54590)  \nCF\u5b98\u65b9\u9898\u89e3\u3002\u540c\u6837\u96be\u5199\u554aQAQ  \n\nPS:\u5199\u9898\u89e3\u7684\u65f6\u5019\u5ffd\u7136\u53d1\u73b0\u6211\u7684\u4ee3\u7801\u5728\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4fe1\u606f\u7684\u90e8\u5206\u6709\u4e00\u70b9~~\u5fae\u4e0d\u8db3\u9053\u7684~~\u5c0f\u95ee\u9898\uff0c\u7136\u800c\u5b83\u901a\u8fc7\u4e86\u90a3\u516b\u5341\u591a\u4e2a\u6d4b\u8bd5\u70b9\uff0c\u6ca1\u6709\u88abhack\u6389qwq  \nPS2:\u672c\u6765\u8fd8\u60f3\u5199\u65b9\u6cd5\u4e8c\u7684\uff0c\u4f46\u6211\u81ea\u5df1\u592a\u83dc~~\u592a\u61d2~~\uff0c\u7b2c\u4e94\u4e2a\u70b9\u5c31MLE\u4e86QAQ  \nPS3:\u5f53\u521d\u63d0\u4ea4\u65f6\u51fa\u73b0\u8be1\u5f02\u8f93\u51fa\u95ee\u9898\uff0c\u628aprintf\u6539\u6210cout\u5c31\u8fc7\u4e86\uff1f\u597d\u5947\u602a\u5440\u3002\u3002\n\n\u4ee3\u7801\uff08\u65b9\u6cd5\u4e00\uff09\uff1a  \n```\n#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <cstring>\n#include <time.h>\n#include <complex>\n#include <algorithm>\n#include <queue>\n#include <stack>\n\n#pragma warning(disable:4996)\n#define lowbit(a) ((a)&-(a))\n\ntemplate<typename T> T min(T x, T y)\n{\n    return x < y ? x : y;\n}\ntemplate<typename T> T max(T x, T y)\n{\n    return x > y ? x : y;\n};\n\nconst int MAXN = 100005;\n\nstruct tree1 {\nprivate:\n    int mx;\n    int l;\n    int r;\n    tree1 *lson;\n    tree1 *rson;\npublic:\n    tree1()\n    {\n        mx = 0;\n        lson = rson = NULL;\n    }\n    void build(int L, int R)\n    {\n        l = L;\n        r = R;\n        if (l == r)\n            return;\n        lson = new tree1;\n        rson = new tree1;\n        int mid = (l + r) / 2;\n        lson->build(l, mid);\n        rson->build(mid + 1, r);\n    }\n    void modify(int id, int k)\n    {\n        if (l == r)\n        {\n            mx = k;\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (id <= mid)\n            lson->modify(id, k);\n        else\n            rson->modify(id, k);\n        mx = max(lson->mx, rson->mx);\n    }\n    int query(int L, int R)\n    {\n        if (l >= L && r <= R)\n            return mx;\n        int mid = (l + r) / 2;\n        if (R <= mid)\n            return lson->query(L, R);\n        if (L > mid)\n            return rson->query(L, R);\n        return max(lson->query(L, R), rson->query(L, R));\n    }\n};\n\nstruct line {\n    int k;\n    int b;\n    line(int K = 0, int B = 0)\n    {\n        k = K;\n        b = B;\n    }\n    int calc(int x)\n    {\n        return k*x + b;\n    }\n    double cross(line t)\n    {\n        return (double)(t.b - b) / (k - t.k);\n    }\n};\n\nstruct tree {\n    bool tag;\n\n    int l;\n    int r;\n    line *L;\n    int cnt;\n    line *R;\n    int rcnt;\n    int mx;\n    tree *lson;\n    tree *rson;\n\n    tree()\n    {\n        tag = false;\n        L = R = NULL;\n        cnt = rcnt = mx = 0;\n        lson = rson = NULL;\n    }\n    void fixup()\n    {\n        static line tmp[MAXN];\n\n        l = lson->l;\n        r = rson->r;\n\n        if (L)\n            delete L;\n        L = new line[lson->cnt + rson->cnt];\n        cnt = lson->cnt;\n        for (int i = 0; i < cnt; i++)\n            L[i] = lson->L[i];\n        for (int i = 0; i < rson->cnt; i++)\n        {\n            if (rson->L[i].k >= L[cnt - 1].k)\n                L[cnt - 1].b = (lson->r - lson->l + 1) + rson->L[i].b;\n            else\n            {\n                L[cnt++] = rson->L[i];\n                L[cnt - 1].b += (lson->r - lson->l + 1);\n            }\n        }\n\n        if (R)\n            delete R;\n        R = new line[lson->rcnt + rson->rcnt];\n        rcnt = rson->rcnt;\n        for (int i = 0; i < rcnt; i++)\n            R[i] = rson->R[i];\n        for (int i = 0; i < lson->rcnt; i++)\n        {\n            if (lson->R[i].k >= R[rcnt - 1].k)\n                R[rcnt - 1].b = (rson->r - rson->l + 1) + lson->R[i].b;\n            else\n            {\n                R[rcnt++] = lson->R[i];\n                R[rcnt - 1].b += (rson->r - rson->l + 1);\n            }\n        }\n\n        mx = max(lson->mx, rson->mx);\n        int cur = 0, p = 0, s = 0;\n        memset(tmp, 0, sizeof(line)*rson->cnt);\n        std::reverse(lson->R, lson->R + lson->rcnt);\n        std::reverse(rson->L, rson->L + rson->cnt);\n\n        for (int i = 0; i < lson->rcnt; i++)\n        {\n            while (cur < rson->cnt && rson->L[cur].k < lson->R[i].k)\n            {\n                line t = rson->L[cur++];\n                t.b = (t.b + 1) * t.k;\n                while (s > 1 && tmp[s - 2].cross(t) < tmp[s - 2].cross(tmp[s - 1]))\n                    s--;\n                if (p >= s)\n                    p = max(s - 1, 0);\n                tmp[s++] = t;\n            }\n            while (p < s - 1 && tmp[p].calc(lson->R[i].b) < tmp[p + 1].calc(lson->R[i].b))\n                p++;\n            while (p && tmp[p].calc(lson->R[i].b) < tmp[p - 1].calc(lson->R[i].b))\n                p--;\n            if (cur < rson->cnt)\n                mx = max(mx, (lson->R[i].b + rson->L[cur].b + 1) * lson->R[i].k);\n            mx = max(mx, tmp[p].calc(lson->R[i].b));\n        }\n        std::reverse(lson->R, lson->R + lson->rcnt);\n        std::reverse(rson->L, rson->L + rson->cnt);\n    }\n    void build(int rL, int rR, int *a)\n    {\n        tag = true;\n        l = rL;\n        r = rR;\n        if (l == r)\n        {\n            mx = a[l] * 2;\n            L = new line[1];\n            R = new line[1];\n            cnt = rcnt = 1;\n            L[0] = R[0] = line(a[l], 1);\n            return;\n        }\n        int mid = (l + r) / 2;\n        lson = new tree;\n        rson = new tree;\n        lson->build(l, mid, a);\n        rson->build(mid + 1, r, a);\n        fixup();\n    }\n    void modify(int id, int k)\n    {\n        if (l == r)\n        {\n            mx = k * 2;\n            L[0] = R[0] = line(k, 1);\n            return;\n        }\n        int mid = (l + r) / 2;\n        if (id <= mid)\n            lson->modify(id, k);\n        else\n            rson->modify(id, k);\n        fixup();\n    }\n    tree *query(int rL, int rR)\n    {\n        if (l >= rL && r <= rR)\n            return this;\n        int mid = (l + r) / 2;\n        if (rR <= mid)\n            return lson->query(rL, rR);\n        if (rL > mid)\n            return rson->query(rL, rR);\n        tree *temp = new tree;\n        temp->lson = lson->query(rL, rR);\n        temp->rson = rson->query(rL, rR);\n        temp->fixup();\n        return temp;\n    }\n    void query_clear()\n    {\n        if (tag)\n            return;\n        lson->query_clear();\n        rson->query_clear();\n        if (L)\n            delete L;\n        if (R)\n            delete R;\n    }\n};\n\nvoid print(int *a, int n)\n{\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", a[i]);\n    printf(\"\\n\");\n}\n\nint N, q;\ntree1 T1;\ntree T;\n\nchar *s[MAXN], str[MAXN];\nint len[MAXN], lcp[MAXN];\n\nvoid init()\n{\n    scanf(\"%d %d\", &N, &q);\n    T1.build(1, N);\n\n    for (int i = 1; i <= N; i++)\n    {\n        scanf(\"%s\", str);\n        len[i] = strlen(str);\n        s[i] = new char[len[i]];\n        memcpy(s[i], str, sizeof(char)*len[i]);\n        T1.modify(i, len[i]);\n    }\n    for (int i = 1; i < N; i++)\n    {\n        int t = 0;\n        while (t < len[i] && t < len[i + 1] && s[i][t] == s[i + 1][t])\n            t++;\n        lcp[i] = t;\n    }\n    if (N > 1)\n        T.build(1, N - 1, lcp);\n}\n\nint main()\n{\n    int ty, x, y;\n\n    init();\n\n    for (int i = 0; i < q; i++)\n    {\n        scanf(\"%d %d\", &ty, &x);\n        if (ty == 1)\n        {\n            scanf(\"%d\", &y);\n            int ans = T1.query(x, y);\n            if (x == y)\n            {\n                printf(\"%d\\n\", ans);\n                continue;\n            }\n            tree *p = T.query(x, y - 1);\n            ans = max(ans, p->mx);\n            p->query_clear();\n            if (!p->l && !p->r)\n                delete p;\n            std::cout << ans << std::endl;\n        }\n        else\n        {\n            scanf(\"%s\", str);\n            len[x] = strlen(str);\n            s[x] = new char[len[x]];\n            memcpy(s[x], str, sizeof(char)*len[x]);\n            T1.modify(x, len[x]);\n\n            int t = 0;\n            if (x > 1)\n            {\n                for (t = 0; t < len[x - 1] && t < len[x] && s[x - 1][t] == s[x][t]; t++);\n                lcp[x - 1] = t;\n                T.modify(x - 1, t);\n            }\n            if (x < N)\n            {\n                for (t = 0; t < len[x] && t < len[x + 1] && s[x][t] == s[x + 1][t]; t++);\n                lcp[x] = t;\n                T.modify(x, t);\n            }\n        }\n    }\n\n    return 0;\n}\n```",
        "postTime": 1551502948,
        "uid": 64366,
        "name": "ddwqwq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF862F \u3010Mahmoud and Ehab and the final stage\u3011"
    }
]