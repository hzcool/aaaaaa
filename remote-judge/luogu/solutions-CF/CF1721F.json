[
    {
        "content": "> [CF1721F Matching Reduction](https://codeforces.com/problemset/problem/1721/F) *2800\n\n\u5220\u70b9\u7f51\u7edc\u6d41\u770b\u8d77\u6765\u5f88\u79bb\u8c31\uff0c\u8003\u8651\u5012\u8fc7\u6765\u52a0\u70b9\u3002\u63a2\u7a76\u6700\u7ec8\u6001\u7684\u5f62\u6001\uff0c\u5373\u5220\u70b9\u4f7f\u5f97\u4e0d\u5b58\u5728\u5339\u914d\uff0c\u5f62\u6210 **\u72ec\u7acb\u96c6**\u3002\u90a3\u6211\u4eec\u8003\u8651\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u7ed3\u5408\u6700\u5927\u72ec\u7acb\u96c6 $I$ \u7b49\u4e8e $V$ \u51cf\u53bb\u6700\u5927\u5339\u914d $M$ \u7684\u6027\u8d28\uff1a\n\n- \u6bcf\u5220\u53bb\u4e00\u4e2a\u70b9\uff0c\u6700\u5927\u5339\u914d\u81f3\u591a\u51cf\u5c11 $1$\u3002\n- \u5220\u53bb\u6070\u597d $|M|$ \u4e2a\u70b9\u4e4b\u540e\uff0c\u5f97\u5230\u539f\u56fe\u6700\u5927\u72ec\u7acb\u96c6\uff0c\u6700\u5927\u5339\u914d\u4e3a $0$\u3002\n\n\u7efc\u5408\u4e0a\u8ff0\u4e24\u70b9\uff0c\u6700\u4f18\u65b9\u6848\u4e2d\u6bcf\u6b21\u53ea\u9700\u5220\u53bb\u4e00\u4e2a\u70b9\u5373\u53ef\u4f7f\u5f97\u5339\u914d\u5927\u5c0f\u51cf\u5c11 $1$\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651\u6784\u9020\u65b9\u6848\u3002\u6bcf\u6b21\u5220\u53bb\u539f\u56fe\u975e\u6700\u5927\u72ec\u7acb\u96c6\u7684\u4e00\u4e2a\u8282\u70b9\uff0c\u6839\u636e $|I| + |M| = |V|$\uff0c$|I|$ \u4e0d\u53d8\uff0c$|V|$ \u51cf $1$\uff0c\u5219 $|M|$ \u51cf $1$\uff0c\u5408\u6cd5\uff0c\u8fd9\u6837\u8282\u70b9\u7684\u65b9\u6848\u5c31\u641e\u5b9a\u4e86\u3002\n\n\u81f3\u4e8e\u5177\u4f53\u5339\u914d\u8fb9\u7684\u65b9\u6848\uff0c\u6c42\u51fa\u975e\u6700\u5927\u72ec\u7acb\u96c6\u8282\u70b9\u4e0e\u6700\u5927\u72ec\u7acb\u96c6\u4e4b\u95f4\u7684\u6700\u5927\u5339\u914d\uff0c\u53ef\u77e5\u6bcf\u4e2a\u975e\u6700\u5927\u72ec\u7acb\u96c6\u8282\u70b9\u5747\u4e0e\u67d0\u4e2a\u6700\u5927\u72ec\u7acb\u96c6\u8282\u70b9\u5339\u914d\uff0c\u8fd9\u6837\u5bb9\u6613\u77e5\u9053\u5220\u53bb\u6bcf\u4e2a\u70b9\u4e4b\u540e\u5bf9\u5e94\u5220\u53bb\u4e86\u54ea\u6761\u5339\u914d\u8fb9\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}(m\\sqrt n)$\u3002\n\n\u8fdb\u4e00\u6b65\u5730\uff0c\u7b14\u8005\u770b\u4e86 jiangly \u7684\u4ee3\u7801\u4e4b\u540e\u53d1\u73b0\uff0c\u5176\u5b9e\u6c42\u6700\u5927\u72ec\u7acb\u96c6\u65f6\u5f97\u5230\u7684\u6700\u5927\u5339\u914d $M$ \u5c31\u662f\u4e00\u4e2a\u5408\u6cd5\u7684 $V\\backslash I$ \u4e0e $I$ \u4e4b\u95f4\u7684\u5339\u914d\uff0c\u4e0d\u9700\u8981\u91cd\u65b0\u6c42\u4e86\uff0c\u56e0\u4e3a\u6bcf\u6761\u5339\u914d\u8fb9\u81f3\u5c11\u6709\u4e00\u4e2a\u7aef\u70b9\u4e0d\u5c5e\u4e8e $I$\uff0c\u800c $|M| = |V\\backslash I|$\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 4e5 + 5;\nconstexpr int M = 6e5 + 5;\nstruct flow {\n  int cnt = 1, hd[N], nxt[M << 1], to[M << 1], limit[M << 1];\n  void add(int u, int v, int w) {\n    nxt[++cnt] = hd[u], hd[u] = cnt, to[cnt] = v, limit[cnt] = w;\n    nxt[++cnt] = hd[v], hd[v] = cnt, to[cnt] = u, limit[cnt] = 0;\n  }\n  int dis[N], cur[N], T;\n  int dfs(int id, int res) {\n    if(id == T) return res;\n    int flow = 0;\n    for(int i = cur[id]; i && res; i = nxt[i]) {\n      cur[id] = i;\n      int it = to[i], c = min(limit[i], res);\n      if(dis[id] + 1 == dis[it] && c) {\n        int k = dfs(it, c);\n        flow += k, res -= k, limit[i] -= k, limit[i ^ 1] += k;\n      }\n    }\n    if(!flow) dis[id] = -1;\n    return flow;\n  }\n  int maxflow(int s, int t) {\n    int flow = 0;\n    T = t;\n    while(1) {\n      queue<int> q;\n      memset(dis, -1, sizeof(dis));\n      memcpy(cur, hd, sizeof(cur));\n      q.push(s), dis[s] = 0;\n      while(!q.empty()) {\n        int t = q.front();\n        q.pop();\n        for(int i = hd[t]; i; i = nxt[i])\n          if(dis[to[i]] == -1 && limit[i])\n            dis[to[i]] = dis[t] + 1, q.push(to[i]);\n      }\n      if(dis[t] == -1) return flow;\n      flow += dfs(s, 1e9);\n    }\n  }\n} g, h;\nlong long sum[N];\nint n1, n2, m, q, I, IC, u[N], v[N], bel[N], L[N], R[N], eid[N];\nmap<pair<int, int>, int> mp;\nint sgn(int id) {return id > 0;}\nint main() {\n  #ifdef ALEX_WEI\n    FILE* IN = freopen(\"1.in\", \"r\", stdin);\n    FILE* OUT = freopen(\"1.out\", \"w\", stdout);\n  #endif\n  cin >> n1 >> n2 >> m >> q;\n  int t = n1 + n2 + 1;\n  for(int i = 1; i <= m; i++) cin >> u[i] >> v[i], v[i] += n1;\n  for(int i = 1; i <= n1; i++) g.add(0, i, 1);\n  for(int i = 1; i <= n2; i++) g.add(n1 + i, t, 1);\n  for(int i = 1; i <= m; i++) g.add(u[i], v[i], 1e9);\n  int J = g.maxflow(0, t);\n  for(int i = 1; i <= n1; i++) \n    if(g.dis[i] != -1) R[++I] = i, bel[i] = -I;\n    else L[++IC] = i, bel[i] = IC;\n  for(int i = 1; i <= n2; i++)\n    if(g.dis[n1 + i] == -1) R[++I] = -i, bel[n1 + i] = -I;\n    else L[++IC] = -i, bel[n1 + i] = IC;\n  assert(IC == J);\n  for(int i = 1; i <= IC; i++) h.add(0, i, 1);\n  for(int i = 1; i <= I; i++) h.add(IC + i, t, 1);\n  for(int i = 1; i <= m; i++) {\n    if(sgn(bel[u[i]]) == sgn(bel[v[i]])) continue;\n    u[i] = bel[u[i]], v[i] = bel[v[i]];\n    if(u[i] < 0) swap(u[i], v[i]);\n    mp[{u[i], IC - v[i]}] = i;\n    h.add(u[i], IC - v[i], 1);\n  }\n  assert(h.maxflow(0, t) == J);\n  for(int i = 1; i <= IC; i++)\n    for(int j = h.hd[i]; j; j = h.nxt[j]) {\n      int it = h.to[j];\n      if(it <= IC || h.limit[j]) continue;\n      assert(!eid[i]);\n      eid[i] = mp[{i, it}];\n      sum[i] = sum[i - 1] + eid[i];\n    }\n  int curflow = J;\n  for(int i = 1; i <= q; i++) {\n    int type;\n    cin >> type;\n    if(type == 1) {\n      cout << \"1\\n\";\n      cout << L[curflow] << \"\\n\";\n      cout << sum[--curflow] << \"\\n\";\n    }\n    else {\n      cout << curflow << \"\\n\";\n      for(int j = 1; j <= curflow; j++) cout << eid[j] << \" \";\n      cout << \"\\n\";\n    }\n    fflush(stdout);\n  }\n  return 0;\n}\n```",
        "postTime": 1661918754,
        "uid": 123294,
        "name": "Alex_Wei",
        "ccfLevel": 10,
        "title": "CF1721F Matching Reduction"
    },
    {
        "content": "\u524d\u7f6e\u829d\u58eb\uff1a[\u4e8c\u5206\u56fe](https://oi-wiki.org/graph/bi-graph/)\u3001[\u6700\u5927\u6d41](https://oi-wiki.org/graph/flow/max-flow/)\n\n\u6ce8\u610f\u5230\u9898\u76ee\u4e2d\u8ba8\u8bba\u7684\u662f\u5220\u70b9\u800c\u975e\u5220\u8fb9\uff0c\u8003\u8651\u5c06\u6700\u5927\u5339\u914d\u8f6c\u5316\u4e3a\u70b9\u6570\u51cf\u53bb\u6700\u5927\u72ec\u7acb\u96c6\u3002\n\n\u4e3a\u4e86\u5c06\u6700\u5927\u5339\u914d\u51cf\u5c11 $1$\uff0c\u6211\u4eec\u663e\u7136\u53ef\u4ee5\u53ea\u5220\u9664\u4e00\u4e2a\u4e0d\u5728\u6700\u5927\u72ec\u7acb\u96c6\u4e2d\u7684\u70b9\u3002\n\n\u6211\u4eec\u5df2\u77e5\u6700\u5927\u72ec\u7acb\u96c6\u7684\u8865\u96c6\u4e3a\u6700\u5c0f\u70b9\u8986\u76d6\uff0c\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6c42\u6700\u5927\u5339\u914d\u95f4\u63a5\u6c42\u51fa\u6700\u5927\u72ec\u7acb\u96c6\u3002\u5177\u4f53\u5730\uff0c\u6211\u4eec\u5728\u672c\u9898\u4e2d\u4f7f\u7528\u6700\u5927\u6d41\u6c42\u6700\u5927\u5339\u914d\uff0c\u5728\u6b8b\u91cf\u7f51\u7edc\u4e0a\u4ece $S$ \u5f00\u59cb dfs \u5e76\u6807\u8bb0\u8bbf\u95ee\u8fc7\u7684\u70b9\uff0c\u6700\u7ec8\u5de6\u90e8\u70b9\u4e2d\u672a\u88ab\u8bbf\u95ee\u7684\u70b9\u548c\u53f3\u90e8\u70b9\u4e2d\u88ab\u8bbf\u95ee\u7684\u70b9\u5728\u6700\u5927\u72ec\u7acb\u96c6\u4e2d\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c $1$\uff0c\u968f\u610f\u9009\u62e9\u6700\u5927\u72ec\u7acb\u96c6\u4e2d\u7684\u4e00\u4e2a\u70b9\u5220\u9664\u5e76\u5220\u9664\u4e0e\u4e4b\u76f8\u8fde\u7684\u5339\u914d\u8fb9\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c $2$\uff0c\u6570\u4e00\u4e0b\u8fd8\u6709\u591a\u5c11\u6761\u5339\u914d\u8fb9\u5e76\u76f4\u63a5\u8f93\u51fa\u5339\u914d\u8fb9\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n1 + n2 + m \\sqrt{n1 + n2} + q)$\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef struct {\n\tint nxt;\n\tint start;\n\tint end;\n\tint dis;\n} Edge;\n\nint cnt = 1;\nint head[400007], id[200007], dis[400007], cur_edge[400007], dis_cnt[400007], candiate[400007], link[400007];\nbool vis[400007], mark[200007];\nEdge edge[1200007];\nqueue<int> q;\n\ninline void init(int n){\n\tfor (register int i = 0; i <= n; i++){\n\t\tdis[i] = 0x7fffffff;\n\t\tcur_edge[i] = head[i];\n\t}\n}\n\ninline void add_edge(int start, int end, int dis){\n\tcnt++;\n\tedge[cnt].nxt = head[start];\n\thead[start] = cnt;\n\tedge[cnt].start = start;\n\tedge[cnt].end = end;\n\tedge[cnt].dis = dis;\n}\n\ninline void bfs(int start){\n\tdis[start] = 0;\n\tq.push(start);\n\twhile (!q.empty()){\n\t\tint cur = q.front(), dis_i = dis[cur] + 1;\n\t\tq.pop();\n\t\tdis_cnt[dis[cur]]++;\n\t\tfor (register int i = head[cur]; i != 0; i = edge[i].nxt){\n\t\t\tint x = edge[i].end;\n\t\t\tif (dis[x] == 0x7fffffff){\n\t\t\t\tdis[x] = dis_i;\n\t\t\t\tq.push(x);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs1(int u, int flow, int start, int end, int n){\n\tif (u == end) return flow;\n\tint ans = 0;\n\tfor (register int i = cur_edge[u]; i != 0; i = edge[i].nxt){\n\t\tcur_edge[u] = i;\n\t\tif (edge[i].dis != 0){\n\t\t\tint x = edge[i].end;\n\t\t\tif (dis[u] == dis[x] + 1){\n\t\t\t\tint t = dfs1(x, min(flow - ans, edge[i].dis), start, end, n);\n\t\t\t\tedge[i].dis -= t;\n\t\t\t\tedge[i ^ 1].dis += t;\n\t\t\t\tans += t;\n\t\t\t\tif (ans == flow) return ans;\n\t\t\t}\n\t\t}\n\t}\n\tcur_edge[u] = head[u];\n\tif (--dis_cnt[dis[u]] == 0) dis[start] = n;\n\tdis_cnt[++dis[u]]++;\n\treturn ans;\n}\n\ninline int isap(int start, int end, int n){\n\tint ans = 0;\n\tbfs(end);\n\twhile (dis[start] < n) ans += dfs1(start, 0x7fffffff, start, end, n);\n\treturn ans;\n}\n\nvoid dfs2(int u){\n\tvis[u] = true;\n\tfor (register int i = head[u]; i != 0; i = edge[i].nxt){\n\t\tif (edge[i].dis != 0){\n\t\t\tint x = edge[i].end;\n\t\t\tif (!vis[x]) dfs2(x);\n\t\t}\n\t}\n}\n\nint main(){\n\tint n1, n2, m, q, end, candiate_cnt = 0;\n\tll sum = 0;\n\tscanf(\"%d %d %d %d\", &n1, &n2, &m, &q);\n\tend = n1 + n2 + 1;\n\tfor (register int i = 1; i <= m; i++){\n\t\tint x, y, y_;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ty_ = y + n1;\n\t\tadd_edge(x, y_, 1);\n\t\tid[i] = cnt;\n\t\tadd_edge(y_, x, 0);\n\t}\n\tfor (register int i = 1; i <= n1; i++){\n\t\tadd_edge(0, i, 1);\n\t\tadd_edge(i, 0, 0);\n\t}\n\tfor (register int i = 1; i <= n2; i++){\n\t\tint i_ = i + n1;\n\t\tadd_edge(i_, end, 1);\n\t\tadd_edge(end, i_, 0);\n\t}\n\tinit(end);\n\tisap(0, end, end + 1);\n\tdfs2(0);\n\tfor (register int i = 1; i <= n1; i++){\n\t\tif (!vis[i]) candiate[++candiate_cnt] = i;\n\t}\n\tfor (register int i = 1; i <= n2; i++){\n\t\tint i_ = i + n1;\n\t\tif (vis[i_]) candiate[++candiate_cnt] = i_;\n\t}\n\tfor (register int i = 1; i <= m; i++){\n\t\tif (edge[id[i]].dis == 0){\n\t\t\tsum += i;\n\t\t\tlink[edge[id[i]].start] = link[edge[id[i]].end] = i;\n\t\t\tmark[i] = true;\n\t\t}\n\t}\n\tfor (register int i = 1, j = 0; i <= q; i++){\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif (op == 1){\n\t\t\tint u = candiate[++j];\n\t\t\tprintf(\"1\\n\");\n\t\t\tif (u <= n1){\n\t\t\t\tprintf(\"%d\\n\", u);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d\\n\", -(u - n1));\n\t\t\t}\n\t\t\tif (mark[link[u]]){\n\t\t\t\tmark[link[u]] = false;\n\t\t\t\tsum -= link[u];\n\t\t\t}\n\t\t\tprintf(\"%lld\\n\", sum);\n\t\t} else {\n\t\t\tint size = 0;\n\t\t\tfor (register int k = 1; k <= m; k++){\n\t\t\t\tif (mark[k]) size++;\n\t\t\t}\n\t\t\tprintf(\"%d\\n\", size);\n\t\t\tfor (register int k = 1; k <= m; k++){\n\t\t\t\tif (mark[k]) printf(\"%d \", k);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tfflush(stdout);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1661758325,
        "uid": 201007,
        "name": "Leasier",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF1721F \u3010Matching Reduction\u3011"
    },
    {
        "content": "\u4e0d\u5f31\u4e8e\u4e8c\u5206\u56fe\u6700\u5927\u5339\u914d\uff0c\u90a3\u8dd1\u4e2a\u7f51\u7edc\u6d41\u5148\u3002\n\n\u76f4\u63a5\u8003\u8651\u5220\u70b9\u4f7f\u5f97\u6700\u5927\u5339\u914d\u6070\u597d $-1$ \u4f3c\u4e4e\u6709\u4e9b\u56f0\u96be\uff0c\u8003\u8651\u5229\u7528 K\u00f6nig \u5b9a\u7406\uff1a\u4e8c\u5206\u56fe\u6700\u5c0f\u70b9\u8986\u76d6\u5927\u5c0f\u7b49\u4e8e\u6700\u5927\u5339\u914d\u5927\u5c0f\uff0c\u5220\u70b9\u4f7f\u5f97\u6700\u5c0f\u70b9\u8986\u76d6\u6070\u597d $-1$\uff0e\n\n\u5148\u6c42\u51fa\u8fd9\u4e2a\u6700\u5c0f\u70b9\u8986\u76d6\u3002\u53ef\u4ee5\u76f4\u63a5\u5957\u7528 K\u00f6nig \u5b9a\u7406\u7684\u6784\u9020\u6027\u8bc1\u660e\uff1a\u5bf9\u4e8e\u6bcf\u4e2a\u53f3\u8fb9\u6bcf\u4e2a\u5931\u914d\u70b9\uff0c\u5c1d\u8bd5\u8d70\u201c\u4e00\u6761\u5339\u914d\uff0c\u4e00\u6761\u6ca1\u5339\u914d...\u201d\u8fd9\u6837\u4ea4\u66ff\u51fa\u73b0\u7684\u8def\u5f84\uff0c\u7136\u540e\u5c06\u6240\u6709\u8d70\u5230\u7684\u70b9\u90fd\u6253\u4e0a\u6807\u8bb0\uff0c\u79f0\u4e4b\u4e3a\u6807\u8bb0\u70b9\u3002\u5219\u5de6\u4fa7\u7684\u6807\u8bb0\u70b9\u548c\u53f3\u4fa7\u7684\u672a\u6807\u8bb0\u70b9\u7ec4\u6210\u4e86\u6700\u5c0f\u70b9\u8986\u76d6\u3002\n\n\u6c42\u51fa\u6700\u5c0f\u70b9\u8986\u76d6\u4e4b\u540e\uff0c\u53d1\u73b0\u4efb\u610f\u5220\u6389\u4e00\u4e2a\u6700\u5c0f\u70b9\u8986\u76d6\u4e2d\u7684\u70b9\u5373\u53ef\u4f7f\u5f97\u6700\u5c0f\u70b9\u8986\u76d6\u6070\u597d $-1$\uff1a\n\n- \u8bbe\u539f\u5148\u6700\u5c0f\u70b9\u8986\u76d6\u5927\u5c0f\u4e3a $s$\uff0c\u5220\u53bb\u70b9 $x$ \u540e\uff0c\u539f\u5148\u6700\u5c0f\u70b9\u8986\u76d6\u65b9\u6848\u4e2d\u53bb\u6389 $x$ \u5373\u4e3a\u4e00\u4e2a\u5408\u6cd5\u7684\u70b9\u8986\u76d6\uff0c\u6240\u4ee5\u5220\u70b9\u540e\u6700\u5c0f\u70b9\u8986\u76d6 $\\leq s-1$\uff1b\n- \u5220\u70b9\u540e\u6700\u5c0f\u70b9\u8986\u76d6\u4e0d\u4f1a $<s-1$\uff0c\u5426\u5219\u5c06 $x$ \u52a0\u5165\u8fd9\u4e2a\u70b9\u8986\u76d6\u65b9\u6848\uff0c\u662f\u5220\u70b9\u524d\u7684\u4e00\u7ec4\u5408\u6cd5\u70b9\u8986\u76d6\uff0c\u5176\u5927\u5c0f $<s$\uff0c\u4e0e $s$ \u662f\u6700\u5c0f\u70b9\u8986\u76d6\u5927\u5c0f\u77db\u76fe\u3002\n\n\u6240\u4ee5\u9047\u5230\u4e00\u64cd\u4f5c\u76f4\u63a5\u5220\u6389\u6700\u5c0f\u70b9\u8986\u76d6\u4e2d\u7684\u4efb\u610f\u4e00\u4e2a\u70b9\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}(m\\sqrt n+q)$\n\n```cpp\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<ctime>\n#include<random>\n#include<assert.h>\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define dbg(x) cerr<<\"In Line \"<< __LINE__<<\" the \"<<#x<<\" = \"<<x<<'\\n';\n#define dpi(x,y) cerr<<\"In Line \"<<__LINE__<<\" the \"<<#x<<\" = \"<<x<<\" ; \"<<\"the \"<<#y<<\" = \"<<y<<'\\n';\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef pair<ll,int>pli;\ntypedef pair<ll,ll>pll;\ntypedef pair<int,ll>pil;\ntypedef vector<int>vi;\ntypedef vector<ll>vll;\ntypedef vector<pii>vpii;\ntypedef vector<pil>vpil;\ntemplate<typename T>T cmax(T &x, T y){return x=x>y?x:y;}\ntemplate<typename T>T cmin(T &x, T y){return x=x<y?x:y;}\ntemplate<typename T>\nT &read(T &r){\n\tr=0;bool w=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9')w=ch=='-'?1:0,ch=getchar();\n\twhile(ch>='0'&&ch<='9')r=r*10+(ch^48),ch=getchar();\n\treturn r=w?-r:r;\n}\ntemplate<typename T1,typename... T2>\nvoid read(T1 &x,T2& ...y){read(x);read(y...);}\n#define flh fflush(stdout)\nconst int N=1000010;\nconst int inf=0x7fffffff;\nint n1,n2,m,q;\nint ent=1,tot,S,T;\nint dis[N],head[N],cur[N];\nint eu[N],ev[N],eid[N];\nint blo[N],evis[N];\nll sum=0;\nint vis[N];\nstruct Edge{\n\tint nxt,to,fl;\n}e[N<<1];\ninline void add(int x,int y,int z){\n\te[++ent]={head[x],y,z};head[x]=ent;\n\te[++ent]={head[y],x,0};head[y]=ent;\n}\nint bfs(){\n\tfor(int i=1;i<=tot;i++)cur[i]=head[i],dis[i]=0;\n\tqueue<int>q;q.push(S);dis[S]=1;\n\twhile(!q.empty()){\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=head[x];i;i=e[i].nxt){\n\t\t\tint v=e[i].to,fl=e[i].fl;\n\t\t\tif(fl){\n\t\t\t\tif(!dis[v]){\n\t\t\t\t\tdis[v]=dis[x]+1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[T]>0;\n}\nint dfs(int x,int mxfl){\n\tif(x==T)return mxfl;\n\tint flow=0;\n\tfor(int i=cur[x];i&&flow<mxfl;i=e[i].nxt){\n\t\tcur[x]=i;\n\t\tint v=e[i].to;\n\t\tif(dis[v]==dis[x]+1){\n\t\t\tint fl=dfs(v,min(e[i].fl,mxfl-flow));\n\t\t\tflow+=fl;e[i].fl-=fl;e[i^1].fl+=fl;\n\t\t}\n\t}\n\treturn flow;\n}\nint dinic(){\n\tint mxfl=0;\n\twhile(bfs())mxfl+=dfs(S,inf);\n\treturn mxfl;\n}\nvoid dfs(int x){\n\tif(vis[x])return ;\n\tvis[x]=1;\n\tfor(int i=head[x];i;i=e[i].nxt)if(!e[i].fl)dfs(e[i].to);\n}\nsigned main(){\n\t#ifdef do_while_true\n//\t\tassert(freopen(\"data.in\",\"r\",stdin));\n//\t\tassert(freopen(\"data.out\",\"w\",stdout));\n\t#endif\n\tread(n1);read(n2);read(m);read(q);\n\tS=n1+n2+1;tot=T=S+1;\n\tfor(int i=1;i<=n1;i++)add(S,i,1);\n\tfor(int i=1;i<=n2;i++)add(i+n1,T,1);\n\tfor(int i=1;i<=m;i++){\n\t\tint x,y;read(x,y);\n\t\teu[i]=x;ev[i]=n1+y;eid[i]=ent+1;\n\t\tadd(x,n1+y,1);\n\t}\n\tdinic();\n\tfor(int i=1;i<=m;i++){\n\t\tif(!e[eid[i]].fl){\n\t\t\tblo[eu[i]]=blo[ev[i]]=i;\n\t\t\tsum+=i;\n\t\t\tevis[i]=1;\n\t\t}\n\t}\n\tfor(int i=n1+1;i<=n1+n2;i++)\n\t\tif(!blo[i])\n\t\t\tdfs(i);\n\tvi vec;\n\tfor(int i=1;i<=n1;i++)if(vis[i])vec.pb(i);\n\tfor(int i=n1+1;i<=n1+n2;i++)if(!vis[i])vec.pb(i);\n\twhile(q--){\n\t\tint op;read(op);\n\t\tif(op==1){\n\t\t\tputs(\"1\");\n\t\t\tint x=vec.back();vec.pop_back();\n\t\t\tif(x<=n1)cout << x << '\\n';\n\t\t\telse cout << -(x-n1) << '\\n';\n\t\t\tevis[blo[x]]=0;\n\t\t\tsum-=blo[x];\n\t\t\tcout << sum << '\\n';\n\t\t}\n\t\telse{\n\t\t\tvi eg;\n\t\t\tfor(int i=1;i<=m;i++)if(evis[i])eg.pb(i);\n\t\t\tcout << eg.size() << '\\n';\n\t\t\tfor(auto i:eg)cout << i << ' ';\n\t\t\tputs(\"\");\n\t\t}\n\t\tflh;\n\t}\n    #ifdef do_while_true\n\t\tcerr<<'\\n'<<\"Time:\"<<1.0*clock()/CLOCKS_PER_SEC*1000<<\" ms\"<<'\\n';\n\t#endif\n\treturn 0;\n}\n```",
        "postTime": 1664434038,
        "uid": 223298,
        "name": "do_while_true",
        "ccfLevel": 8,
        "title": "\u300c\u9898\u89e3\u300dCodeforces 1721F Matching Reduction"
    }
]