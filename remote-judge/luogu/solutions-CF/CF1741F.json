[
    {
        "content": "\u4e3a\u5565\u73b0\u5728\u7684\u9898\u89e3\u90fd\u611f\u89c9\u8fd9\u4e48\u590d\u6742\u3002\u6211\u6765\u4e2a\u5bb9\u6613\u7406\u89e3\u7684\u3002\n\n\u7ef4\u62a4\u4e00\u4e2a\u5e8f\u5217 $a$\uff0c\u8868\u793a\u5f53\u524d\u70b9\u88ab\u51e0\u4e2a\u7ebf\u6bb5\u8986\u76d6\u3002\u5982\u679c\u5f53\u524d\u9009\u51fa\u4e86\u989c\u8272 $x$\uff0c\u90a3\u4e48 $\\forall i,c_i=x$\uff0c$[l_i,r_i]$ \u5185\u6240\u6709 $a_i\\leftarrow a_i-1$\u3002\u8fd9\u6837\u5c31\u53ea\u6709 $c_i\\not=x$ \u7684 $i$ \u4f1a\u4ea7\u751f\u8d21\u732e\u4e86\u3002\u6b64\u65f6\u53ea\u8981\u627e\u5230\u6700\u8fd1\u7684\u4e00\u4e2a $a_i>0$\uff0c\u5373\u4e3a\u7b54\u6848\u4f4d\u7f6e\u3002\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u7ef4\u62a4\u3002\n\n\u518d\u7279\u5224\u4e00\u4e0b\u7ebf\u6bb5\u6709\u4ea4\u96c6\uff0c\u5c31\u662f\u7b80\u5355\u533a\u95f4\u67e5\u8be2\u3002\n\n\u6700\u540e\u53d1\u73b0 $1\\leq l_i\\leq r_i\\leq 10^9$\u3002\u79bb\u6563\u5316\u4e00\u4e0b\u5373\u53ef\u3002\n\ncode\uff1a\n\n```cpp\nint n,m,d[N],L[N],R[N],c[N],ans[N];\nvector<int> col[N];\nll tr[N<<2],tag[N<<2];\ninline void pushup(int o){\n\ttr[o]=tr[o<<1]+tr[o<<1|1];\n}\ninline void pushdown(int l,int r,int o){\n\tint mid=(l+r)>>1;\n\ttr[o<<1]+=(mid-l+1)*tag[o],tr[o<<1|1]+=(r-mid)*tag[o];\n\ttag[o<<1]+=tag[o],tag[o<<1|1]+=tag[o];\n\ttag[o]=0;\n}\nvoid update(int l,int r,int o,int x,int y,int k){\n\tif(l>=x&&r<=y){\n\t\ttr[o]+=(r-l+1)*k;\n\t\ttag[o]+=k;\n\t\treturn;\n\t}\n\tpushdown(l,r,o);\n\tint mid=(l+r)>>1;\n\tif(x<=mid)\n\t\tupdate(l,mid,o<<1,x,y,k);\n\tif(y>mid)\n\t\tupdate(mid+1,r,o<<1|1,x,y,k);\n\tpushup(o);\n}\nbool query(int l,int r,int o,int x,int y){\n\tif(l>=x&&r<=y)\n\t\treturn tr[o];\n\tpushdown(l,r,o);\n\tint mid=(l+r)>>1;\n\tif(x<=mid&&y>mid)\n\t\treturn query(l,mid,o<<1,x,y)|query(mid+1,r,o<<1|1,x,y);\n\tif(x<=mid)\n\t\treturn query(l,mid,o<<1,x,y);\n\treturn query(mid+1,r,o<<1|1,x,y);\n}\nint query_l(int l,int r,int o,int x){\n\tif(l>x||!tr[o])\n\t\treturn 0;\n\tif(l==r){\n\t\tif(tr[o])\n\t\t\treturn l;\n\t\treturn 0;\n\t}\n\tpushdown(l,r,o);\n\tint mid=(l+r)>>1;\n\tif(x>mid){\n\t\tint ret=query_l(mid+1,r,o<<1|1,x);\n\t\tif(ret>=1)\n\t\t\treturn ret;\n\t}\n\treturn query_l(l,mid,o<<1,x);\n}\nint query_r(int l,int r,int o,int x){\n\tif(r<x||!tr[o])\n\t\treturn m+1;\n\tif(l==r){\n\t\tif(tr[o])\n\t\t\treturn l;\n\t\treturn m+1;\n\t}\n\tpushdown(l,r,o);\n\tint mid=(l+r)>>1;\n\tif(x<=mid){\n\t\tint ret=query_r(l,mid,o<<1,x);\n\t\tif(ret<=m)\n\t\t\treturn ret;\n\t}\n\treturn query_r(mid+1,r,o<<1|1,x);\n}\nvoid solve(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tcol[i].clear();\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d\",&L[i],&R[i],&c[i]);\n\t\td[i]=L[i],d[i+n]=R[i];\n\t\tcol[c[i]].eb(i);\n\t}\n\tsort(d+1,d+n*2+1);\n\tm=unique(d+1,d+n*2+1)-d-1;\n\tfor(int i=1;i<=m*4;i++)\n\t\ttr[i]=tag[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tL[i]=lower_bound(d+1,d+m+1,L[i])-d;\n\t\tR[i]=lower_bound(d+1,d+m+1,R[i])-d;\n\t\tupdate(1,m,1,L[i],R[i],1);\n\t}\n\td[0]=-inf,d[m+1]=inf;\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j:col[i])\n\t\t\tupdate(1,m,1,L[j],R[j],-1);\n\t\tfor(int j:col[i]){\n\t\t\tif(query(1,m,1,L[j],R[j]))\n\t\t\t\tans[j]=0;\n\t\t\telse{\n\t\t\t\tint pl=query_l(1,m,1,L[j]),pr=query_r(1,m,1,R[j]);\n\t\t\t\tans[j]=min(1ll*d[L[j]]-d[pl],1ll*d[pr]-d[R[j]]);\n\t\t\t}\n\t\t}\n\t\tfor(int j:col[i])\n\t\t\tupdate(1,m,1,L[j],R[j],1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tputs(\"\");\n}\nsigned main(){\n//\tfreopen(\"ex_data1.in\",\"r\",stdin);\n\tint t=1;\n\t\tscanf(\"%d\",&t);\n\twhile(t--)\n\t\tsolve();\n}\n```",
        "postTime": 1683958215,
        "uid": 740322,
        "name": "_Ritsu_",
        "ccfLevel": 0,
        "title": "CF1741F"
    },
    {
        "content": "\u5bf9\u4e8e\u6bcf\u6761\u7ebf\u6bb5\uff0c\u7b54\u6848\u662f $0$ \u5f53\u4e14\u4ec5\u5f53\u5b58\u5728\u4e0e\u5176\u5f02\u8272\u7684\u7ebf\u6bb5\u6709\u4ea4\uff0c\u5426\u5219\u7b54\u6848\u662f\u4e0e\u5176\u5f02\u8272\u7684\u7ebf\u6bb5\u548c\u5b83\u6700\u63a5\u8fd1\u7684\uff0c\u8fd9\u91cc\u5206\u4e3a\u5b8c\u5168\u5728\u8be5\u7ebf\u6bb5\u5de6\u8fb9\u6216\u5728\u53f3\u8fb9\u3002\n\n\u9996\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u4e0e\u5176\u5f02\u8272\u7684\u7ebf\u6bb5\u6709\u4ea4\u3002\n\n\u8bb0\u4e0e\u5176\u4e0d\u76f8\u4ea4\u7684\u5f02\u8272\u7ebf\u6bb5\u6570\u91cf\u4e3a $cnt1$\uff0c\u6240\u6709\u7ebf\u6bb5\u4e2d\u4e0e\u5176\u4e0d\u76f8\u4ea4\u7684\u7ebf\u6bb5\u6570\u91cf\u4e3a $cnt2$\uff0c\u8be5\u7ebf\u6bb5\u7684\u989c\u8272\u5728\u6240\u6709\u7ebf\u6bb5\u4e2d\u7684\u603b\u6b21\u6570\u4e3a $cnt3$\u3002$cnt1,cnt2,cnt3$ \u90fd\u53ef\u4ee5\u7b80\u5355\u4e8c\u5206\u6c42\u51fa\u3002\u5219\u4e0e\u5176\u5f02\u8272\u4e14\u76f8\u4ea4\u7684\u7ebf\u6bb5\u6570\u91cf\u5c31\u662f $n-cnt3-cnt2+cnt1$\uff0c\u5982\u679c\u8fd9\u4e2a\u503c\u975e $0$ \u5219\u5b58\u5728\u4e0e\u5176\u5f02\u8272\u7684\u7ebf\u6bb5\u6709\u4ea4\uff0c\u7b54\u6848\u4e3a $0$\u3002\n\n\u5426\u5219\u6c42\u89e3\u51fa\u6bcf\u4e2a\u7ebf\u6bb5\u5de6\u8fb9\u79bb\u5b83\u6700\u8fd1\u7684\u4e0e\u5176\u5f02\u8272\u7684\u7ebf\u6bb5\u4e4b\u95f4\u7684\u8ddd\u79bb\uff08\u53f3\u8fb9\u5219\u53ef\u4ee5\u7ffb\u8f6c\u7ebf\u6bb5\u540e\u540c\u7406\uff09\u3002\u5148\u6309\u53f3\u7aef\u70b9\u6392\u5e8f\u7136\u540e\u4f9d\u6b21\u626b\u8fc7\u53bb\uff0c\u540c\u65f6\u7ef4\u62a4\u51fa\u6bcf\u4e2a\u989c\u8272\u53f3\u7aef\u70b9\u6700\u9760\u53f3\u7684\u7ebf\u6bb5\uff0c\u7ef4\u62a4\u4e00\u4e2a\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\u7684 set \u7ef4\u62a4\u6bcf\u4e2a\u989c\u8272\uff0c\u5373\u6bcf\u4e2a\u989c\u8272\u53ea\u4f1a\u8ba9\u8be5\u989c\u8272\u5f53\u524d\u53f3\u7aef\u70b9\u6700\u5927\u7684\u4e00\u6761\u7ebf\u6bb5\u8fdb\u5165 set\u3002\u67e5\u8be2\u4e00\u6761\u7ebf\u6bb5\u65f6\uff0c\u8bb0\u5176\u989c\u8272\u4e3a $c$\uff0c\u5219\u627e\u51fa set \u4e2d\u53f3\u7aef\u70b9\u6700\u5927\u7684\u7ebf\u6bb5\uff0c\u82e5\u5176\u989c\u8272\u4e0e $c$ \u4e0d\u540c\u5219\u5b83\u5c31\u662f\u7b54\u6848\uff0c\u5426\u5219\u662f set \u4e2d\u53f3\u7aef\u70b9\u6b21\u5927\u7684\u7ebf\u6bb5\u3002\u8fd9\u662f\u56e0\u4e3a\u6211\u4eec\u4fdd\u8bc1\u4e86 set \u4e2d\u6240\u6709\u7ebf\u6bb5\u989c\u8272\u4e0d\u540c\uff0c\u6240\u6709\u7b54\u6848\u5fc5\u7136\u662f\u53f3\u7aef\u70b9\u6700\u5927\u548c\u6b21\u5927\u7ebf\u6bb5\u5176\u4e2d\u7684\u4e00\u4e2a\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log n)$\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nvoid work() {\n int n;\n cin >> n;\n vector<array<int, 4>> a(n);\n for (int i = 0; i < n; ++i) {\n  auto &[l, r, c, id] = a[i];\n  cin >> l >> r >> c, --c, id = i;\n }\n vector<int> ans(n, 2e9);\n auto solve = [&] () { // \u6c42\u51fa\u6bcf\u4e2a\u7ebf\u6bb5\u5de6\u8fb9\u79bb\u4ed6\u6700\u8fd1\u7684\u5f02\u8272\u7ebf\u6bb5\n  sort(a.begin(), a.end(), [] (auto p, auto q) { return get<1>(p) < get<1>(q); });\n  set<tuple<int, int, int>> s;\n  vector<decltype(s.end())> mx(n);\n  vector<bool> st(n);\n  for (auto [l, r, c, id]: a) {\n   auto it = s.end();\n   if (it != s.begin()) {\n    --it;\n    if (get<1>(*it) == c && it != s.begin()) --it;\n   }\n   if (it != s.end() && get<1>(*it) != c) ans[id] = min(ans[id], max(0, l - get<0>(*it))); // \u627e\u5230\u5de6\u8fb9\u4e0e\u5176\u5f02\u8272\u7684\u53f3\u7aef\u70b9\u6700\u5927\u7684\u7ebf\u6bb5\u66f4\u65b0\u7b54\u6848\n   if (st[c]) s.erase(mx[c]);\n   st[c] = 1, mx[c] = s.insert(make_tuple(r, c, l)).first;\n  }\n };\n auto solve0 = [&] () { // \u5224\u65ad\u6bcf\u4e2a\u7ebf\u6bb5\u662f\u5426\u5b58\u5728\u4e0e\u5176\u6709\u4ea4\u7684\u5f02\u8272\u7ebf\u6bb5\n  vector<pair<int, int>> sl, sr;\n  for (auto [l, r, c, id]: a)\n   sl.emplace_back(l, 1), sr.emplace_back(r, 1);\n  sort(sl.begin(), sl.end()), sort(sr.begin(), sr.end());\n  for (int i = 1; i < sr.size(); ++i) sr[i].second += sr[i - 1].second;\n  for (int i = (int) sl.size() - 2; i >= 0; --i) sl[i].second += sl[i + 1].second;\n  vector<vector<pair<int, int>>> vl(n), vr(n);\n  for (auto [l, r, c, id]: a) vl[c].emplace_back(l, 1), vr[c].emplace_back(r, 1);\n  for (auto &v: vl) {\n   sort(v.begin(), v.end());\n   for (int i = (int) v.size() - 2; i >= 0; --i) v[i].second += v[i + 1].second;\n  }\n  for (auto &v: vr) {\n   sort(v.begin(), v.end());\n   for (int i = 1; i < v.size(); ++i) v[i].second += v[i - 1].second;\n  } // \u6c42\u51fa\u524d\u7f00\u548c\u4e0e\u540e\u7f00\u548c\n  vector<int> cc(n);\n  for (auto it: a) cc[get<2>(it)]++;\n  for (auto [l, r, c, id]: a) {\n   int cnt = cc[c];\n   auto it = lower_bound(sr.begin(), sr.end(), make_pair(l, 0));\n   if (it != sr.begin()) --it, cnt += it->second;\n   it = lower_bound(sl.begin(), sl.end(), make_pair(r + 1, 0));\n   if (it != sl.end()) cnt += it->second;\n   it = lower_bound(vr[c].begin(), vr[c].end(), make_pair(l, 0));\n   if (it != vr[c].begin()) --it, cnt -= it->second;\n   it = lower_bound(vl[c].begin(), vl[c].end(), make_pair(r + 1, 0));\n   if (it != vl[c].end()) cnt -= it->second;\n   if (cnt != n) ans[id] = 0;\n  }\n };\n solve0();\n solve();\n for (auto &[l, r, c, id]: a)\n  l = 1e9 - l, r = 1e9 - r, swap(l, r); // \u7ffb\u8f6c\u6240\u6709\u7ebf\u6bb5\uff0c\u91cd\u65b0\u505a\u4e00\u904d\n solve();\n for (int x: ans) cout << x << ' ';\n cout << '\\n';\n}\nsigned main() {\n int t;\n cin >> t;\n while (t--) work();\n}\n```",
        "postTime": 1666140042,
        "uid": 127284,
        "name": "ieeqwq",
        "ccfLevel": 7,
        "title": "CF1741F Multi-Colored Segments \u9898\u89e3"
    },
    {
        "content": "\u4e00\u79cd\u4e0d\u7528\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u7684\u505a\u6cd5\u3002\n\n---\n\n\u9996\u5148\u8003\u8651\u600e\u4e48\u6c42\u51fa\u79bb\u4e00\u6761\u7ebf\u6bb5\u6700\u8fd1\u7684\u7ebf\u6bb5\u3002\n\n\u5982\u679c\u6ca1\u6709\u989c\u8272\u7684\u533a\u522b\u3002\u90a3\u4e48\u5148\u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d\uff0c\u5982\u679c\u627e\u5230\u4e86\u4e00\u4e2a\u53f3\u7aef\u70b9\uff0c\u5219\u628a $dis$ \u8bbe\u4e3a $0$\uff1b\u5bf9\u4e8e\u6bcf\u4e2a\u7aef\u70b9\uff0c\u627e\u5230\u65f6\u90fd\u52a0\u4e0a\u5b83\u5230\u5b83\u4e4b\u524d\u7684\u7b2c\u4e00\u4e2a\u7aef\u70b9\u7684\u8ddd\u79bb\uff1b\u5982\u679c\u627e\u5230\u4e86\u4e00\u4e2a\u5de6\u7aef\u70b9\uff0c\u5219\u7528 $dis$ \u66f4\u65b0\u7b54\u6848\u3002\u7136\u540e\u518d\u4ece\u53f3\u5230\u5de6\u626b\u4e00\u904d\u3002\n\n\u90a3\u4e48\u8003\u8651\u52a0\u4e0a\u989c\u8272\u600e\u4e48\u505a\u3002\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u989c\u8272\u90fd\u5f00\u4e00\u4e2a $dis$\uff0c\u66f4\u65b0\u64cd\u4f5c\u76f8\u540c\uff0c\u4f46\u67e5\u8be2\u7684\u65f6\u5019\u7528**\u5168\u5c40\u9664\u8fd9\u4e2a\u989c\u8272\u4e4b\u5916\u7684\u6240\u6709\u989c\u8272\u7684\u6700\u5c0f\u8ddd\u79bb**\u66f4\u65b0\u7b54\u6848\u3002\u90a3\u4e48\u8fd9\u662f\u4e00\u4e2a\u5168\u5c40\u52a0\uff0c\u533a\u95f4\u8d4b\u503c\uff0c\u533a\u95f4\u6c42 $\\min$ \u7684\u95ee\u9898\uff0c\u6734\u7d20\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u590d\u6742\u5ea6 $O(n\\log n)$\u3002\n\n\u7136\u540e\u53d1\u73b0\u6837\u4f8b\u90fd\u8fc7\u4e0d\u4e86\uff0c\u56e0\u4e3a\u8fd8\u6709\u76f8\u4ea4\u7684\u60c5\u51b5\n\n\u90a3\u4e48\u5148\u5bf9\u5750\u6807\u79bb\u6563\u5316\u3002\u6211\u4eec\u53d1\u73b0\u53ef\u4ee5\u5148\u628a\u6240\u6709\u7ebf\u6bb5\u8986\u76d6\u7684\u70b9\u52a0\u4e00\uff0c\u7136\u540e\u679a\u4e3e\u6bcf\u79cd\u989c\u8272\u3002\u5148\u628a\u8fd9\u79cd\u989c\u8272\u7684\u6240\u6709\u7ebf\u6bb5\u5206\u79bb\u51fa\u6765\uff0c\u5373\u5168\u90e8\u51cf\u4e00\uff1b\u68c0\u9a8c\u6bcf\u6761\u7ebf\u6bb5\u8986\u76d6\u7684\u533a\u95f4\u662f\u5426\u5b58\u5728\u975e $0$ \u503c\uff0c\u82e5\u5b58\u5728\uff0c\u5219\u5c06\u5bf9\u5e94\u7684\u7b54\u6848\u6807\u4e3a $0$\uff1b\u6700\u540e\u628a\u62ff\u51fa\u6765\u7684\u7ebf\u6bb5\u653e\u56de\u53bb\uff0c\u5373\u5168\u90e8\u52a0\u4e00\u3002\n\n\u4e8e\u662f\u518d\u6574\u4e00\u53ea\u7ebf\u6bb5\u6811\uff0c\u533a\u95f4\u52a0\uff0c\u533a\u95f4\u67e5\u8be2 $\\max$\u3002\u56e0\u4e3a\u6bcf\u4e2a\u7ebf\u6bb5\u53ea\u4f1a\u52a0\u5165 $2$ \u6b21\uff0c\u5220\u9664 $1$ \u6b21\uff0c\u6240\u4ee5\u8fd9\u4e00\u90e8\u5206\u7684\u590d\u6742\u5ea6\u4ecd\u7136\u662f $O(n\\log n)$\u3002\n\n\u7136\u800c\u56e0\u4e3a\u6709\u4e24\u53ea\u7ebf\u6bb5\u6811\uff0c\u6240\u4ee5\u8dd1\u5f97\u7a0d\u5fae\u6162\u4e8e\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u7684\u5199\u6cd5\u3002\n\n```cpp\n#include<algorithm> \n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ninline int max(int x,int y){return x>y?x:y;}\ninline void chkmax(int&x,int y){x=x>y?x:y;}\ninline void chkmin(int&x,int y){x=x<y?x:y;}\ntypedef long long ll;\nconst int MAXN=2e5+5,INF=0x3f3f3f3f;\nint n,m=0,l[MAXN],r[MAXN],c[MAXN],ans[MAXN];\n\nnamespace Solve1{\t\t\t// \u8ba1\u7b97\u79bb\u6bcf\u6761\u7ebf\u6bb5\u6700\u8fd1\u7684\u5f02\u8272\u7ebf\u6bb5\u8ddd\u79bb\uff08\u4e0d\u76f8\u4ea4\uff09\n\tnamespace SegmentTree{\n\t\tstruct segtree{int value,lazy;}tr[MAXN<<2];\n\t\t#define ls p<<1\n\t\t#define rs p<<1|1\n\t\t#define Ls ls,l,mid\n\t\t#define Rs rs,mid+1,r\n\t\t#define all 1,1,m\n\t\t#define val(p) tr[p].value\n\t\t#define tag(p) tr[p].lazy\n\t\tinline void push_up(int p){val(p)=min(val(ls),val(rs));}\n\t\tinline void change(int p,int k){val(p)+=k,tag(p)+=k;}\n\t\tinline void push_down(int p){\n\t\t\tif(!tag(p))return;\n\t\t\tchange(ls,tag(p));change(rs,tag(p));\n\t\t\ttag(p)=0;\n\t\t}\n\t\tvoid build(int p,int l,int r){tag(p)=0;val(p)=INF;if(l==r)return;int mid=l+r>>1;build(Ls);build(Rs);}\n\t\tvoid update(int p,int l,int r,int P){\n\t\t\tif(l==r){val(p)=0;return;}\n\t\t\tint mid=l+r>>1;push_down(p);\n\t\t\tP<=mid?update(Ls,P):update(Rs,P);\n\t\t\tpush_up(p);\n\t\t}\n\t\tinline void update(int k){change(1,k);}\n\t\tint query(int p,int l,int r,int L,int R){\n\t\t\tif(L<=l&&r<=R)return val(p);\n\t\t\tint mid=l+r>>1;push_down(p);\n\t\t\tif(L>mid)return query(Rs,L,R);if(R<=mid)return query(Ls,L,R);\n\t\t\treturn min(query(Ls,L,R),query(Rs,L,R));\n\t\t}\n\t}using namespace SegmentTree;\n\tint tot=0;\n\tstruct node{\n\t\tint p,pos,col;bool flag;node(){}\n\t\tnode(int p,int pos,int col,bool flag):p(p),pos(pos),col(col),flag(flag){}\n\t\tinline bool operator<(const node&b)const{return p<b.p;}\n\t}a[MAXN<<1];\n\tinline void solve1(){\n\t\ttot=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\ta[++tot]=node(l[i],i,c[i],false);\n\t\t\ta[++tot]=node(r[i],i,c[i],true);\n\t\t}\n\t\tsort(a+1,a+tot+1);\n\t\tbuild(all);if(a[1].flag)update(all,a[1].col);\t\t// \u4ece\u5de6\u5230\u53f3\u626b\u4e00\u904d\n\t\tfor(int i=2;i<=tot;i++){\n\t\t\tupdate(a[i].p-a[i-1].p);\n\t\t\tif(a[i].flag)update(all,a[i].col);\n\t\t\telse{\n\t\t\t\tif(1<=a[i].col-1)chkmin(ans[a[i].pos],query(all,1,a[i].col-1));\n\t\t\t\tif(a[i].col+1<=m)chkmin(ans[a[i].pos],query(all,a[i].col+1,m));\n\t\t\t}\n\t\t}\n\t\tbuild(all);if(!a[tot].flag)update(all,a[tot].col);\t// \u4ece\u53f3\u5230\u5de6\u626b\u4e00\u904d\n\t\tfor(int i=tot-1;i>=1;i--){\n\t\t\tupdate(a[i+1].p-a[i].p);\n\t\t\tif(!a[i].flag)update(all,a[i].col);\n\t\t\telse{\n\t\t\t\tif(1<=a[i].col-1)chkmin(ans[a[i].pos],query(all,1,a[i].col-1));\n\t\t\t\tif(a[i].col+1<=m)chkmin(ans[a[i].pos],query(all,a[i].col+1,m));\n\t\t\t}\n\t\t}\n\t}\n\t#undef ls\n\t#undef rs\n\t#undef Ls\n\t#undef Rs\n\t#undef all\n\t#undef val\n\t#undef tag\n}using Solve1::solve1;\nnamespace Solve2{\t\t\t// \u5224\u662f\u5426\u6709\u5f02\u8272\u7ebf\u6bb5\u548c\u6bcf\u6761\u7ebf\u76f8\u4ea4\n\tnamespace SegmentTree{\n\t\tstruct segtree{int value,lazy;}tr[MAXN<<3];\n\t\t#define ls p<<1\n\t\t#define rs p<<1|1\n\t\t#define Ls ls,l,mid\n\t\t#define Rs rs,mid+1,r\n\t\t#define all 1,1,tot\n\t\t#define val(p) tr[p].value\n\t\t#define tag(p) tr[p].lazy\n\t\tinline void push_up(int p){val(p)=max(val(ls),val(rs));}\n\t\tinline void change(int p,int k){val(p)+=k;tag(p)+=k;}\n\t\tinline void push_down(int p){\n\t\t\tif(!tag(p))return;\n\t\t\tchange(ls,tag(p));change(rs,tag(p));\n\t\t\ttag(p)=0;\n\t\t}\n\t\tvoid build(int p,int l,int r){tag(p)=val(p)=0;if(l==r)return;int mid=l+r>>1;build(Ls);build(Rs);}\n\t\tvoid update(int p,int l,int r,int L,int R,int k){\n\t\t\tif(L<=l&&r<=R)return change(p,k);\n\t\t\tint mid=l+r>>1;push_down(p);\n\t\t\tif(L<=mid)update(Ls,L,R,k);if(R>mid)update(Rs,L,R,k);\n\t\t\tpush_up(p);\n\t\t}\n\t\tint query(int p,int l,int r,int L,int R){\n\t\t\tif(L<=l&&r<=R)return val(p);\n\t\t\tint mid=l+r>>1;push_down(p);\n\t\t\tif(L>mid)return query(Rs,L,R);if(R<=mid)return query(Ls,L,R);\n\t\t\treturn max(query(Ls,L,R),query(Rs,L,R));\n\t\t}\n\t}using namespace SegmentTree;\n\t\n\tstruct node{\n\t\tint l,r,c,pos;node(){}\n\t\tnode(int l,int r,int c,int pos):l(l),r(r),c(c),pos(pos){}\n\t\tinline bool operator<(const node&b)const{return c<b.c;}\n\t}a[MAXN];\n\tint tot,d[MAXN<<1];\n\tinline void solve2(){\n\t\ttot=0;\n\t\tfor(int i=1;i<=n;i++)d[++tot]=l[i],d[++tot]=r[i];\n\t\tsort(d+1,d+tot+1);tot=unique(d+1,d+tot+1)-d-1;\n\t\tfor(int i=1;i<=n;i++){\t\t\t\t\t\t\t\t// \u79bb\u6563\u5316\n\t\t\tl[i]=lower_bound(d+1,d+tot+1,l[i])-d,\n\t\t\tr[i]=lower_bound(d+1,d+tot+1,r[i])-d,\n\t\t\ta[i]=node(l[i],r[i],c[i],i);\n\t\t}\n\t\tsort(a+1,a+n+1);\n\t\tbuild(all);\n\t\tfor(int i=1;i<=n;i++)update(all,l[i],r[i],1);\n\t\tint lst=1;\n\t\ta[n+1].c=1919810;\n\t\tfor(int i=2;i<=n+1;i++)\n\t\t\tif(a[i].c^a[lst].c){\t\t\t\t\t\t\t// \u628a\u540c\u8272\u6bb5\u63d0\u53d6\u51fa\u6765\n\t\t\t\tfor(int j=lst;j<i;j++)update(all,a[j].l,a[j].r,-1);\n\t\t\t\tfor(int j=lst;j<i;j++){\n\t\t\t\t\tif(query(all,a[j].l,a[j].r))ans[a[j].pos]=0;\n\t\t\t\t}\n\t\t\t\tfor(int j=lst;j<i;j++)update(all,a[j].l,a[j].r,1);\n\t\t\t\tlst=i;\n\t\t\t}\n\t}\n\t#undef ls\n\t#undef rs\n\t#undef Ls\n\t#undef Rs\n\t#undef all\n\t#undef val\n\t#undef tag\n}using Solve2::solve2;\nconst int LIMIT=5e7;\ninline void solve(){\n\tscanf(\"%d\",&n);m=0;\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d%d\",&l[i],&r[i],&c[i]),ans[i]=INF,chkmax(m,c[i]);\n\tsolve1();solve2();\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n}\nint main(){\n\tint T;scanf(\"%d\",&T);\n\twhile(T--)solve();\n\treturn 0;\n}\n```",
        "postTime": 1685109882,
        "uid": 350297,
        "name": "_maojun_",
        "ccfLevel": 6,
        "title": "CF1741F \u9898\u89e3"
    },
    {
        "content": "> \u667a\u5546\u4e0d\u591f\uff0cDS\u6765\u51d1\u3002\n\n\u9996\u5148\u79bb\u6563\u5316\u6389\u5de6\u53f3\u7aef\u70b9\uff0c\u7528 $idx$ \u8868\u793a\u79bb\u6563\u5316\u540e\u6700\u5927\u503c\u3002\n\n\u7528 $tr_i$ \u8868\u793a\u88ab\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7684\u70b9\u3002\n\n\u8003\u8651\u5230\u7b2c $i$ \u6761\u7ebf\u6bb5\u65f6\uff0c\u5c06\u4e8e $c_i$ \u989c\u8272\u4e0d\u540c\u7684\u6240\u6709\u7ebf\u6bb5\u63d2\u5165\u7ebf\u6bb5\u6811\u91cc\uff0c\u63d2\u5165\u7ebf\u6bb5 $j$ \u7684\u65b9\u5f0f\u5c31\u662f $\\forall k\\in [l_j,r_j],tr_k$ \u66b4\u529b\u52a0\u4e00\u3002\n\n\u4e8e\u662f\u95ee\u9898\u5c31\u53d8\u6210\u4e86\uff1a\n\n- \u5982\u679c\u7ebf\u6bb5\u6811\u4e0a $\\exists j\\in[l_i,r_i],tr_j \\ne 0$\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f $0$\uff08\u4e5f\u5c31\u662f\u6709\u4ea4\u70b9\uff09\u3002\n\n- \u5426\u5219\uff0c\u627e\u5230 $\\max_{j\\in [1,l_i),tr_j \\ne 0},j$ \u548c $\\min_{j\\in (r_i,idx],tr_j \\ne 0},j$\uff0c\u8f93\u51fa\u4e24\u8005\u4e4b\u95f4\u5bf9\u4e8e $l_i$ \u548c $r_i$ \u6700\u77ed\u7684\u8ddd\u79bb\u5373\u53ef\u3002\n\n\u90a3\u4e48\u600e\u4e48\u627e\u5230\u4e0a\u9762\u90a3\u4e00\u5927\u6bb5\u5f0f\u5b50\u7684\u503c\u5462\uff1f\u4f7f\u7528\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6 $O(n\\log ^2 n)$\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <algorithm>\n\n#define N 400010\n\nint n;\nstd::map <int,int> mp;\nint fmp[N << 1];\nint mpidx;\n\nstruct Tree\n{\n\tint l,r;\n\tint sum;\n\tint mx;\n\tint lazy;\n\tvoid push(int z)\n\t{\n\t\tsum += (r - l + 1) * z;\n\t\tmx += z;\n\t\tlazy += z;\n\t}\n}tr[N << 2];\n\n#define lson k << 1\n#define rson k << 1 | 1\n\nvoid pushup(int k)\n{\n\ttr[k].sum = tr[lson].sum + tr[rson].sum;\n\ttr[k].mx = std::max(tr[lson].mx,tr[rson].mx);\n}\n\nvoid pushdown(int k)\n{\n\tif(tr[k].lazy)\n\t{\n\t\ttr[lson].push(tr[k].lazy);\n\t\ttr[rson].push(tr[k].lazy);\n\t\ttr[k].lazy = 0;\n\t}\n}\n\nvoid build(int k,int l,int r)\n{\n\ttr[k].l = l,tr[k].r = r;\n\ttr[k].mx = tr[k].sum = 0;\n\ttr[k].lazy = 0;\n\tif(l == r)\n\t\treturn;\n\tint mid = l + r >> 1;\n\tbuild(lson,l,mid);\n\tbuild(rson,mid + 1,r);\n}\n\nvoid change(int k,int ql,int qr,int z)\n{\n\tint l = tr[k].l,r = tr[k].r;\n\tif(ql <= l && r <= qr)\n\t{\n\t\ttr[k].push(z);\n\t\treturn;\n\t}\n\tpushdown(k);\n\tint mid = l + r >> 1;\n\tif(ql <= mid)\n\t\tchange(lson,ql,qr,z);\n\tif(mid < qr)\n\t\tchange(rson,ql,qr,z);\n\tpushup(k);\n}\n\nint query_sum(int k,int ql,int qr)\n{\n\tint res = 0;\n\tint l = tr[k].l,r = tr[k].r;\n\tif(ql <= l && r <= qr)\n\t\treturn tr[k].sum;\n\tpushdown(k);\n\tint mid = l + r >> 1;\n\tif(ql <= mid)\n\t\tres += query_sum(lson,ql,qr);\n\tif(mid < qr)\n\t\tres += query_sum(rson,ql,qr);\n\treturn res;\n}\n\nint query_last(int k)\n{\n\tif(tr[k].l == tr[k].r)\n\t{\n\t\tif(tr[k].mx != 0)\n\t\t\treturn tr[k].l;\n\t\treturn 1;\n\t}\n\tpushdown(k);\n\tif(tr[rson].mx != 0)\n\t\treturn query_last(rson);\n\tif(tr[lson].mx != 0)\n\t\treturn query_last(lson);\n\treturn 1;\n}\n\nint query_first(int k)\n{\n\tif(tr[k].l == tr[k].r)\n\t{\n\t\tif(tr[k].mx != 0)\n\t\t\treturn tr[k].l;\n\t\treturn mpidx;\n\t}\n\tpushdown(k);\n\tif(tr[lson].mx != 0)\n\t\treturn query_first(lson);\n\tif(tr[rson].mx != 0)\n\t\treturn query_first(rson);\n\treturn mpidx;\n}\n\nint query_last_um_nik(int k,int ql,int qr)\n{\n\tint l = tr[k].l,r = tr[k].r;\n\tif(ql <= l && r <= qr)\n\t\treturn query_last(k);\n\tint res = 1,mid = l + r >> 1;\n\tif(ql <= mid)\n\t\tres = std::max(res,query_last_um_nik(lson,ql,qr));\n\tif(mid < qr)\n\t\tres = std::max(res,query_last_um_nik(rson,ql,qr));\n\treturn res;\n}\n\nint query_first_um_nik(int k,int ql,int qr)\n{\n\tint l = tr[k].l,r = tr[k].r;\n\tif(ql <= l && r <= qr)\n\t\treturn query_first(k);\n\tint res = mpidx,mid = l + r >> 1;\n\tif(ql <= mid)\n\t\tres = std::min(res,query_first_um_nik(lson,ql,qr));\n\tif(mid < qr)\n\t\tres = std::min(res,query_first_um_nik(rson,ql,qr));\n\treturn res;\n}\n\nstruct node\n{\n\tint l,r,c,id;\n\tbool operator < (const node &B)const\n\t{\n\t\treturn c < B.c;\n\t}\n}a[N];\n\nint ans[N];\n\nint T;\nint sta[N << 2],top;\n\nint main()\n{\n\tscanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tmp.clear();\n\t\ttop = 0;\n\t\tmpidx = 0;\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&a[i].l,&a[i].r,&a[i].c);\n\t\t\tsta[++top] = a[i].l;\n\t\t\tsta[++top] = a[i].r;\n\t\t\ta[i].id = i;\n\t\t}\n\t\tsta[++top] = 0;\n\t\tsta[++top] = 0x3f3f3f3f;\n\t\tstd::sort(sta + 1,sta + 1 + top);\n\t\tfor(int i = 1;i <= top;i++)\n\t\t{\n\t\t\tif(!mp[sta[i]])\n\t\t\t{\n\t\t\t\tmp[sta[i]] = ++mpidx;\n\t\t\t\tfmp[mpidx] = sta[i];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\ta[i].l = mp[a[i].l];\n\t\t\ta[i].r = mp[a[i].r];\n\t\t}\n\t\tstd::sort(a + 1,a + 1 + n);\n\t\tint last = 0;\n\t\tbuild(1,1,mpidx);\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tchange(1,a[i].l,a[i].r,1);\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tif(last != a[i].c)\n\t\t\t{\n\t\t\t\tint p = i - 1;\n\t\t\t\twhile(p >= 1 && a[p].c == last)\n\t\t\t\t{\n\t\t\t\t\tchange(1,a[p].l,a[p].r,1);\n\t\t\t\t\tp--;\n\t\t\t\t}\n\t\t\t\tlast = a[i].c;\n\t\t\t\tp = i;\n\t\t\t\twhile(p <= n && a[p].c == last)\n\t\t\t\t{\n\t\t\t\t\tchange(1,a[p].l,a[p].r,-1);\n\t\t\t\t\tp++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(query_sum(1,a[i].l,a[i].r))\n\t\t\t{\n\t\t\t\tans[a[i].id] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint left = query_last_um_nik(1,1,a[i].l - 1);\n\t\t\t\tint right = query_first_um_nik(1,a[i].r + 1,mpidx);\n\t\t\t\tint res = 0x3f3f3f3f;\n\t\t\t\tif(left != 1)\n\t\t\t\t\tres = std::min(res,fmp[a[i].l] - fmp[left]);\n\t\t\t\tif(right != mpidx)\n\t\t\t\t\tres = std::min(res,fmp[right] - fmp[a[i].r]);\n\t\t\t\tans[a[i].id] = res;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)\n\t\t\tprintf(\"%d \",ans[i]);\n\t\tputchar('\\n');\n\t\tbuild(1,1,mpidx);\n\t\tfor(int i = 1;i <= mpidx;i++)\n\t\t\tfmp[mp[i]] = 0;\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1666168820,
        "uid": 371968,
        "name": "ningago",
        "ccfLevel": 4,
        "title": "CF1741F"
    },
    {
        "content": "$\\text{F. Multi-Colored Segments}$\n\n\u9898\u610f\u7b80\u5316\uff1a\u5bf9\u4e8e\u6bcf\u6761\u7ebf\u6bb5\u6c42\u79bb\u5b83\u6700\u8fd1\u7684\u4e0d\u540c\u989c\u8272\u7684\u7ebf\u6bb5\u7684\u8ddd\u79bb\u3002\n\n\u9996\u5148\uff0c\u8fd9\u9898\u8fd9\u548c\u76f8\u5bf9\u4f4d\u7f6e\u6709\u5173\uff0c\u6240\u4ee5\u53ef\u4ee5\u79bb\u6563\u5316\uff0c\u6c42\u8ddd\u79bb\u7528\u5b58\u4e00\u4e2a\u79bb\u6563\u5316\u4e4b\u540e\u6570\u636e\u7684\u539f\u6570\u636e\u5373\u53ef\u3002\n\n\u7136\u540e\u5c31\u5206\u7c7b\u8ba8\u8bba\uff1a\n- \u88ab\u5176\u4ed6\u7ebf\u6bb5\u5b8c\u5168\u8986\u76d6\n- \u8986\u76d6\u5176\u4ed6\u7ebf\u6bb5\n- \u7aef\u70b9\u6709\u8986\u76d6\n- \u5728\u7ebf\u6bb5\u4e24\u7aef\n\n\u5176\u4e2d\u7b2c\u4e09\u7c7b\u5206\u4e09\u5c0f\u7c7b\uff1a\u5de6\u4ea4\u70b9\u8986\u76d6\uff0c\u53f3\u4ea4\u70b9\u8986\u76d6\uff0c\u5de6\u53f3\u4ea4\u70b9\u90fd\u8986\u76d6\u3002\n\n\u5176\u4e2d\u7b2c\u56db\u7c7b\u5206\u4e24\u5c0f\u7c7b\uff1a\u7ebf\u6bb5\u5de6\u4fa7\uff0c\u7ebf\u6bb5\u53f3\u4fa7\u3002\n\n\u6211\u4eec\u5148\u8003\u8651\u5728\u7ebf\u6bb5\u5de6\u53f3\u4e24\u7aef\u7684\u60c5\u51b5\uff1a\u5de6\u53f3\u540c\u7406\uff0c\u6240\u4ee5\u4e0b\u9762\u53ea\u8ba8\u8bba\u53f3\u4fa7\u3002\u56e0\u4e3a\u6570\u636e\u5b8c\u6210\u4e86\u79bb\u6563\u5316\uff08\u53ea\u5269\u4e0b\u4e86\u7aef\u70b9\uff09\uff0c\u6240\u4ee5\u5f53\u524d\u7ebf\u6bb5\u548c\u79bb\u5b83\u6700\u8fd1\u7684\u4e0d\u540c\u989c\u8272\u7684\u7ebf\u6bb5\u4e4b\u95f4\u53ea\u5b58\u5728\u548c\u5b83\u76f8\u540c\u989c\u8272\u7684\u70b9\u3002\u4e5f\u5c31\u662f\u8981\u627e\u5230\u8be5\u7ebf\u6bb5\u53f3\u7aef\u70b9\u53f3\u4fa7\u7b2c\u4e00\u4e2a\u989c\u8272\u4e0d\u540c\u7684\u70b9\u7136\u540e\u5bf9\u6620\u5c04\u7684\u503c\u6c42\u5dee\u5373\u53ef\u3002\u8fd9\u4e2a\u8fc7\u7a0b\u53ef\u4ee5\u5bf9\u8be5\u989c\u8272\u7684\u4f4d\u7f6e\u8fdb\u884c\u4e00\u904d\u904d\u5386\uff0c\u6c42\u6700\u957f\u8fde\u7eed\u5373\u53ef\u3002\n\n\u7136\u540e\u8003\u8651\u7aef\u70b9\u6709\u8986\u76d6\u7684\u60c5\u51b5\uff0c\u53ea\u8981\u5224\u65ad\u4e24\u4e2a\u7aef\u70b9\u4e0a\u662f\u5426\u53ea\u6709\u4e00\u79cd\u989c\u8272\u5373\u53ef\u3002\n\n\u518d\u8003\u8651\u8986\u76d6\u5176\u4ed6\u7ebf\u6bb5\u7684\u60c5\u51b5\uff0c\u5982\u679c\u7ebf\u6bb5\u5185\u90e8\u4e0d\u5b58\u5728\u5176\u4ed6\u7ebf\u6bb5\u5219\uff0c\u7ebf\u6bb5\u5185\u90e8\u90fd\u4e3a\u8be5\u7ebf\u6bb5\u7684\u989c\u8272\uff0c\u4e14\u989c\u8272\u79cd\u6570\u4e3a $1$\u3002\n\n\u6700\u540e\u8003\u8651\u88ab\u5176\u4ed6\u7ebf\u6bb5\u5b8c\u5168\u8986\u76d6\u7684\u60c5\u51b5\uff0c\u6b64\u65f6\u53ef\u4ee5\u628a\u6240\u6709\u7ebf\u6bb5\u5148\u6309\u5de6\u7aef\u70b9\u5347\u5e8f\u6392\u5e8f\uff0c\u7136\u540e\u904d\u5386\u6bcf\u6761\u7ebf\u6bb5\uff0c\u7ef4\u62a4\u6bcf\u4e00\u79cd\u989c\u8272\u7684\u53f3\u7aef\u70b9\u7684\u6700\u5927\u503c\uff0c\u518d\u7ef4\u62a4\u4e00\u4e2a\u6240\u6709\u989c\u8272\u7684\u53f3\u7aef\u70b9\u7684\u6700\u5927\u503c\u7684\u6700\u5927\u503c\u548c\u6b21\u5927\u503c\uff0c\u5bf9\u4e8e\u6bcf\u6761\u7ebf\u6bb5\u9700\u8981\u5224\u65ad\u8fd9\u4e2a\u6700\u5927\u503c\u662f\u5426\u662f\u8be5\u7ebf\u6bb5\u7684\u989c\u8272\u7684\u6700\u5927\u503c\uff0c\u5982\u679c\u662f\uff0c\u518d\u5224\u65ad\u662f\u5426\u8fd9\u4e2a\u6700\u5927\u503c\u53ea\u6709\u4e00\u4e2a\u3002\u5982\u679c\u53ea\u6709\u4e00\u4e2a\uff0c\u5c31\u7528\u6b21\u5927\u503c\u6bd4\u8f83\u3002\u5982\u679c\u4e0d\u662f\u8be5\u7ebf\u6bb5\u7684\u989c\u8272\u7684\u6700\u5927\u503c\u5c31\u8bf4\u660e\u8be5\u7ebf\u6bb5\u80fd\u88ab\u5176\u4ed6\u7ebf\u6bb5\u5b8c\u5168\u8986\u76d6\u3002\n\n\u603b\u8fc7\u7a0b\u4f7f\u7528 $\\text{set}$\uff0c$\\text{map}$\uff0c\u79bb\u6563\u5316\uff0c\u4e8c\u5206\u67e5\u627e\u3002$O(n\\log n)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e5+10;\nstruct node{\n\tint l,r,c,d;\n}q[N],Q[N];\nstruct a{\n\tint num,col;\n\ta(){num=-1;col=0;}\n};\nint n,maxc,pm[N],max_r[N],Sum[N];\nbool contain[N];\nvector<int> p,seat[N],rnex[N],lnex[N];\nunordered_map<int,int> mp,nummaxr;\nset<int> col[N],S[N];\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nbool cmp(node x,node y){\n\treturn x.l<y.l;\n}\nvoid init(){\n\tint i;\n\ta maxr,cmaxr;\n\tfor(i=1;i<=n;i++) Q[i]=q[i];\n\tfor(i=1;i<=n;i++) Q[i].d=i;\n\tfor(i=1;i<=maxc;i++) max_r[i]=-1;\n\tsort(Q+1,Q+1+n,cmp);\n\tfor(i=1;i<=n;i++){\n\t\tif(maxr.num>=Q[i].r){\n\t\t\tif(maxr.num==max_r[Q[i].c]){\n\t\t\t\tif(nummaxr[maxr.num]==1&&cmaxr.num>Q[i].r) contain[Q[i].d]=1;\n\t\t\t\tif(nummaxr[maxr.num]>1) contain[Q[i].d]=1; \n\t\t\t}\n\t\t\telse contain[Q[i].d]=1;\n\t\t}\n\t\tnummaxr[max_r[Q[i].c]]--;\n\t\tmax_r[Q[i].c]=max(max_r[Q[i].c],Q[i].r);\n\t\tnummaxr[max_r[Q[i].c]]++;\n\t\tif(max_r[Q[i].c]>maxr.num){\n\t\t\tif(Q[i].c!=maxr.col) cmaxr=maxr;\n\t\t\tmaxr.num=max_r[Q[i].c];\n\t\t\tmaxr.col=Q[i].c;\n\t\t}\n\t\telse if(max_r[Q[i].c]==maxr.num&&nummaxr[maxr.num]>1){\n\t\t\tif(Q[i].c!=maxr.col) cmaxr.num=max_r[Q[i].c],cmaxr.col=Q[i].c;\n\t\t}\n\t\telse if(max_r[Q[i].c]<maxr.num){\n\t\t\tif(Q[i].c!=maxr.col){\n\t\t\t\tif(max_r[Q[i].c]>cmaxr.num){\n\t\t\t\t\tcmaxr.num=max_r[Q[i].c];\n\t\t\t\t\tcmaxr.col=Q[i].c;\n\t\t\t\t}\n\t\t\t}\n\t\t} \n\t}\n}\nint SUM(int x){\n\tif(x==-1) return 0;\n\treturn Sum[x];\n}\nbool check(int l,int r,int c){\n\tint L_pos,R_pos;\n\tL_pos=lower_bound(seat[c].begin(),seat[c].end(),l)-seat[c].begin();\n\tR_pos=lower_bound(seat[c].begin(),seat[c].end(),r)-seat[c].begin();\n\tif(R_pos-L_pos==r-l&&SUM(r)-SUM(l-1)==r-l+1) return 1;\n\treturn 0;\n}\nvoid solve(){\n\tint i,j,maxn,L,R,L_pos,R_pos,nexl,nexr,ansl,ansr,ans;\n\tsort(p.begin(),p.end());\n\tmp[p[0]]=0;\n\tpm[0]=p[0];\n\tpm[N-5]=2e9+10;\n\tfor(i=1;i<p.size();i++){\n\t\tif(p[i]==p[i-1]) continue;\n\t\tmp[p[i]]=mp[p[i-1]]+1;\n\t\tpm[mp[p[i]]]=p[i];\n\t}\n\tmaxn=mp[p[p.size()-1]];\n\tfor(i=1;i<=n;i++){\n\t\tif(!S[q[i].c].count(mp[q[i].l])){\n\t\t\tseat[q[i].c].push_back(mp[q[i].l]);\n\t\t\tS[q[i].c].insert(mp[q[i].l]);\n\t\t}\n\t\tif(!S[q[i].c].count(mp[q[i].r])){\n\t\t\tseat[q[i].c].push_back(mp[q[i].r]);\n\t\t\tS[q[i].c].insert(mp[q[i].r]);\n\t\t}\n\t}\n\tfor(i=1;i<=maxc;i++) sort(seat[i].begin(),seat[i].end());\n\tfor(i=1;i<=maxc;i++){\n\t\trnex[i].resize(seat[i].size());\n\t\tlnex[i].resize(seat[i].size());\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tcol[mp[q[i].l]].insert(q[i].c);\n\t\tcol[mp[q[i].r]].insert(q[i].c);\n\t}\n\tSum[0]=col[0].size();\n\tfor(i=1;i<=maxn;i++){\n\t\tSum[i]=Sum[i-1]+col[i].size();\n\t}\n\tfor(i=1;i<=maxc;i++){\n\t\tfor(j=seat[i].size()-1;~j;j--){\n\t\t\tif(j==seat[i].size()-1){\n\t\t\t\tif(col[seat[i][j]].size()>1) rnex[i][j]=seat[i][j];\n\t\t\t\telse if(seat[i][j]==maxn) rnex[i][j]=N-5;\n\t\t\t\telse rnex[i][j]=seat[i][j]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(col[seat[i][j]].size()>1) rnex[i][j]=seat[i][j];\n\t\t\t\telse if(seat[i][j+1]-seat[i][j]>1) rnex[i][j]=seat[i][j]+1;\n\t\t\t\telse rnex[i][j]=rnex[i][j+1];\n\t\t\t}\n\t\t}\n\t\tfor(j=0;j<seat[i].size();j++){\n\t\t\tif(j==0){\n\t\t\t\tif(col[seat[i][j]].size()>1) lnex[i][j]=seat[i][j];\n\t\t\t\telse if(seat[i][j]==0) lnex[i][j]=N-5;\n\t\t\t\telse lnex[i][j]=seat[i][j]-1;\n\t\t\t} \n\t\t\telse{\n\t\t\t\tif(col[seat[i][j]].size()>1) lnex[i][j]=seat[i][j];\n\t\t\t\telse if(seat[i][j]-seat[i][j-1]>1) lnex[i][j]=seat[i][j]-1;\n\t\t\t\telse lnex[i][j]=lnex[i][j-1];\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tL=mp[q[i].l];\n\t\tR=mp[q[i].r];\n\t\tif(!check(L,R,q[i].c)) printf(\"0 \");\n\t\telse if(col[L].size()>1||col[R].size()>1) printf(\"0 \");\n\t\telse if(contain[i]) printf(\"0 \"); \n\t\telse{\n\t\t\tL_pos=lower_bound(seat[q[i].c].begin(),seat[q[i].c].end(),L)-seat[q[i].c].begin();\n\t\t\tR_pos=lower_bound(seat[q[i].c].begin(),seat[q[i].c].end(),R)-seat[q[i].c].begin();\n\t\t\tnexl=lnex[q[i].c][L_pos];\n\t\t\tnexr=rnex[q[i].c][R_pos];\n\t\t\tansl=abs(pm[nexl]-pm[L]);\n\t\t\tansr=abs(pm[nexr]-pm[R]);\n\t\t\tans=min(ansl,ansr);\n\t\t\tprintf(\"%d \",ans);\n\t\t}\n\t}\n\tputs(\"\");\n\tfor(i=1;i<=maxc;i++) seat[i].clear(),lnex[i].clear(),rnex[i].clear();\n\tfor(i=1;i<=maxc;i++) S[i].clear();\n\tfor(i=0;i<=maxn;i++) col[i].clear(),Sum[i]=0;\n\tfor(i=0;i<=maxn;i++) pm[i]=0;\n\tfor(i=1;i<=n;i++) contain[i]=0;\n\tp.clear();\n\tmp.clear();\n\tnummaxr.clear();\n}\nint main(){\n//\tfreopen(\"data.out\",\"w\",stdout);\n\tint t,i,j;\n\tt=read();\n\twhile(t--){\n\t\tn=read();\n\t\tmaxc=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tq[i].l=read();\n\t\t\tq[i].r=read();\n\t\t\tq[i].c=read();\n\t\t\tp.push_back(q[i].l);\n\t\t\tp.push_back(q[i].r);\n\t\t\tmaxc=max(maxc,q[i].c);\n\t\t}\n\t\tinit();\n\t\tsolve();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1665737359,
        "uid": 225100,
        "name": "ice_in_sky",
        "ccfLevel": 0,
        "title": "CF1741F Multi-Colored Segments"
    }
]