[
    {
        "content": "### \u9898\u610f:\n\n\u7ed9\u51fa\u4e00\u4e2a\u4e32 $S$\uff0c\u518d\u7ed9\u51fa $n$ \u4e2a\u4e32 $T_i$\uff0c $q$ \u6b21\u8be2\u95ee $S[pl,pr]$ \u5728 $ T_{[l,r]}$\u54ea\u4e2a\u4e32\u51fa\u73b0\u6b21\u6570\u6700\u591a\u3002\n\n### solution:\n\n\u4e0d\u96be\u60f3\u5230\u6211\u4eec\u627e $S[pl,pr]$ \u662f\u53ef\u4ee5\u8bb0\u5f55 $ed_{pr}$ \u7136\u540e\u500d\u589e\u4e0a\u53bb\u627e\u5230\u8fd9\u4e2a\u533a\u95f4\u6240\u5bf9\u5e94\u7684 SAM \u8282\u70b9\u3002\n\n\u6211\u4eec\u628a $T_i$ \u63d2\u5165 SAM \u91cc\uff0c\u5e76\u4e14\u5bf9\u5e94\u8282\u70b9\u641e\u4e0a $i$\uff0c\u7136\u540e\u5408\u5e76\u5c31\u597d\u4e86qwq\u3002\n\nSAM \u67d0\u4e2a\u5b50\u6811\u90e8\u5206\u90fd\u662f\u5305\u542b\u4ed6\u81ea\u5df1\u7684\u4e32\uff0c\u6240\u4ee5\u7ebf\u6bb5\u6811\u5408\u5e76\u4e00\u4e0b\u5c31\u53d8\u6210\u4e86\u5b50\u6811\u6570\u989c\u8272\u4ee5\u53ca\u627e\u5230\u6700\u591a\u989c\u8272\u7684\u95ee\u9898\u4e86\u3002\n\n### code:\n\n```cpp\n// powered by c++11\n// by Isaunoya\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb emplace_back\nint n;\nconst int maxn = 1e6 + 61;\nchar s[maxn], buf[maxn];\n\nstruct PII {\n  int x, y;\n  bool operator<(const PII o) const { return x == o.x ? y > o.y : x < o.x; }\n};\n\nint rt[maxn];\nstruct SegMentTree {\n  int ls[maxn << 5], rs[maxn << 5], cnt = 0;\n  PII mx[maxn << 5], zero;\n\n  SegMentTree() { zero.x = zero.y = 0; }\n\n  void ins(int& p, int l, int r, int x) {\n    if (!p) p = ++cnt;\n    if (l == r) {\n      mx[p].x++, mx[p].y = l;\n      return;\n    }\n    int mid = l + r >> 1;\n    if (x <= mid)\n      ins(ls[p], l, mid, x);\n    else\n      ins(rs[p], mid + 1, r, x);\n    mx[p] = max(mx[ls[p]], mx[rs[p]]);\n  }\n\n  int merge(int x, int y, int l, int r) {\n    if (!x || !y) return x | y;\n    int qwq = ++ cnt;\n    if (l == r) {\n    \tmx[qwq] = mx[x];\n      mx[qwq].x += mx[y].x;\n      return qwq;\n    }\n    int mid = l + r >> 1;\n    ls[qwq] = merge(ls[x], ls[y], l, mid);\n    rs[qwq] = merge(rs[x], rs[y], mid + 1, r);\n    mx[qwq] = max(mx[ls[qwq]], mx[rs[qwq]]);\n    return qwq;\n  }\n\n  PII qry(int p, int a, int b, int l, int r) {\n    if (!p) return zero;\n    if (a <= l && r <= b) return mx[p];\n    int mid = l + r >> 1;\n    PII ans = zero;\n    if (a <= mid) ans = max(ans, qry(ls[p], a, b, l, mid));\n    if (b > mid) ans = max(ans, qry(rs[p], a, b, mid + 1, r));\n    return ans;\n  }\n} smt;\n\nvector<int> g[maxn];\nint ed[maxn], mxl[maxn];\n\nstruct SAM {\n  int ch[maxn][26], fa[maxn], len[maxn];\n  int las, cnt;\n  SAM() { las = cnt = 1; }\n\n  void ins(int c, int id) {\n    int p = las, np = las = ++cnt;\n    smt.ins(rt[np], 1, n, id);\n    len[np] = len[p] + 1;\n    for (; p && !ch[p][c]; p = fa[p]) ch[p][c] = np;\n    if (!p) {\n      fa[np] = 1;\n    } else {\n      int q = ch[p][c];\n      if (len[q] == len[p] + 1) {\n        fa[np] = q;\n      } else {\n        int nq = ++cnt;\n        memcpy(ch[nq], ch[q], sizeof(ch[q]));\n        fa[nq] = fa[q], fa[q] = fa[np] = nq, len[nq] = len[p] + 1;\n        for (; p && ch[p][c] == q; p = fa[p]) ch[p][c] = nq;\n      }\n    }\n  }\n\n  void build() {\n    for (int i = 2; i <= cnt; i++) g[fa[i]].pb(i);\n  }\n\n  void init() {\n    int p = 1, l = 0, now = 0;\n    char* cur = s;\n    while (*cur) {\n      ++now;\n      int c = (*cur++) - 'a';\n      while (p && !ch[p][c]) p = fa[p], l = len[p];\n      if (ch[p][c]) {\n        p = ch[p][c], ++l;\n      } else {\n        p = 1, l = 0;\n      }\n      ed[now] = p, mxl[now] = l;\n    }\n  }\n} sam;\n\nint fa[maxn][18];\nvoid dfs(int u) {\n  for (int v : g[u]) {\n    fa[v][0] = u;\n    dfs(v);\n    rt[u] = smt.merge(rt[u], rt[v], 1, n);\n  }\n}\n\nPII qry(int l, int r, int pl, int pr) {\n  if (pr - pl + 1 > mxl[pr]) return { l, 0 };\n  int p = ed[pr];\n  for (int i = 17; ~i; i--)\n    if (fa[p][i] && sam.len[fa[p][i]] >= pr - pl + 1) p = fa[p][i];\n  PII ans = smt.qry(rt[p], l, r, 1, n);\n  if (!ans.x) ans.y = l;\n  return { ans.y, ans.x };\n}\n\nsigned main() {\n  // code begin.\n  scanf(\"%s\", s), scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    sam.las = 1, scanf(\"%s\", buf);\n    char* cur = buf;\n    while (*cur) sam.ins((*cur++) - 'a', i);\n  }\n  sam.build(), sam.init(), dfs(1);\n  for (int j = 1; j <= 17; j++)\n    for (int i = 1; i <= sam.cnt; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1];\n  int _;\n  scanf(\"%d\", &_);\n  while (_--) {\n    int l, r, pl, pr;\n    scanf(\"%d %d %d %d\", &l, &r, &pl, &pr);\n    PII ans = qry(l, r, pl, pr);\n    printf(\"%d %d\\n\", ans.x, ans.y);\n  }\n  return 0;\n  // code end.\n}\n\n```",
        "postTime": 1584842371,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "\u76ee\u6807\u662f\u67e5\u8be2S\u7684\u5b50\u4e32\u5728\u6a21\u677f\u4e32\u533a\u95f4\u7684\u54ea\u4e2a\u4e32\u91cc\u51fa\u73b0\u6b21\u6570\u6700\u591a\n\n\u5148\u5bf9\u6240\u6709\u7684\u6a21\u677f\u4e32\u5efa\u4e00\u4e2a\u5e7f\u4e49SAM(\u5173\u4e8e\u5e7f\u4e49SAM\uff0c\u5982\u679c\u4e0d\u77e5\u9053\uff0c\u53ef\u4ee5\u53bb\u505a\u505a[P4081](https://www.luogu.org/problemnew/show/P4081)\uff0c[P2336](https://www.luogu.org/problemnew/show/P2336))\n\n\u56e0\u4e3a\u67e5\u8be2\u7684\u662f\u6a21\u677f\u4e32\u7684\u533a\u95f4\uff0c\u6211\u4eec\u4f7f\u7528\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u4e0b\u6807\u662f\u4e32\u7684id\n\n\u6211\u4eec\u4e3aSAM\u4e0a\u6bcf\u4e2a\u8282\u70b9\u5efa\u7acb\u4e00\u4e2a\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff0c\u8bb0\u5f55\u533a\u95f4\u7684\u6700\u5927\u503c\uff0c\u4ee5\u53ca\u6700\u5927\u503c\u6240\u5728\u7684\u4e0b\u6807\n\n\u5efa\u5b8c\u5e7f\u4e49SAM\u540e\u8dd1\u4e00\u4e2a\u7ebf\u6bb5\u6811\u5408\u5e76\n\n\u9884\u5904\u7406\u51faS\u7684\u524d\u7f00$S[1..r]$\u5728SAM\u91cc\u80fd\u5339\u914d\u4e0a\u7684\u6700\u957f\u540e\u7f00\u7684\u957f\u5ea6\u4ee5\u53ca\u5b83\u5339\u914d\u5230\u7684\u4f4d\u7f6e\uff08\u8fd9\u4e2a\u548c[\u6700\u957f\u516c\u5171\u5b50\u4e32](https://www.luogu.org/problemnew/show/SP1811)\u7684\u505a\u6cd5\u7c7b\u4f3c\uff0c\u6ce8\u610f\u5931\u914d\u7684\u65f6\u5019\u8981\u66f4\u65b0\u957f\u5ea6\u503c\uff09\n\n\u6bcf\u6b21\u67e5\u8be2\u7684\u65f6\u5019\u4ece\u540e\u7f00$S[1..r]$\u5339\u914d\u5230\u7684\u4f4d\u7f6e\u5f00\u59cb\uff0c\u5728parent\u6811\u4e0a\u500d\u589e\uff0c\u627e\u5230$R$\u6700\u5c0f\u7684\u8282\u70b9\uff0c\u4f7f\u5f97$R_u \\geqslant r - l + 1 $\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u500d\u589e\u5230\u7684\u70b9\u6b63\u597d\u5305\u542b\u4e86$S[l..r]$\u8fd9\u4e2a\u72b6\u6001\uff0c\u5728\u8fd9\u4e2a\u8282\u70b9\u7684\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2$p_l .. p_r$\u4e4b\u95f4\u7684\u6700\u5927\u503c\uff0c\u5c31\u662f\u7b54\u6848\n\n\u6ce8\u610f\u4e00\u4e9b\u7ec6\u8282\uff1a\n1. \u4e0a\u9762\u63d0\u5230\uff0c\u5728\u9884\u5904\u7406\u65f6\uff0c\u5931\u914d\u7684\u65f6\u5019\u8981\u66f4\u65b0\u957f\u5ea6\n2. \u5f53\u6700\u5c0f\u503c\u4e0d\u5b58\u5728\u7684\u65f6\u5019\u8981\u8f93\u51fa\"$p_l$ 0\"\n3. \u5f53\u4e32\u7684\u957f\u5ea6\u5927\u4e8e\u9884\u5904\u7406\u65f6\u6700\u5927\u5339\u914d\u5230\u7684\u957f\u5ea6\uff0c\u4e5f\u662f\u6700\u5c0f\u503c\u4e0d\u5b58\u5728\u7684\u4e00\u79cd\u60c5\u51b5\n\n\u7136\u800c\u4f5c\u4e3a\u849f\u84bb\u6211\u7206\u4e86\u597d\u591a\u53d1\u63d0\u4ea4\u2026\u2026\n\n\u4e0b\u9762\u662f\u4ee3\u7801\uff08\u5ffd\u7565\u4ee3\u7801\u4e2d\u7684fail\uff0c\u5f53\u505aparent\u5c31\u597d\uff09\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <assert.h>\n\nconst int MAXN = 100010;\nstruct PII {\n    int first, second;\n    explicit PII(int f = 0, int s = 0) { first = f, second = s; }\n    inline bool operator < (const PII & b) const {\n        return first == b.first ? second > b.second : first < b.first;\n    }\n} ;\n\nint n, Q, t1, t2, t3, t4;\nnamespace SGT {\n    const int MAXNODE = MAXN * 160;\n    int ls[MAXNODE], rs[MAXNODE], tot, rt[MAXN];\n    PII tree[MAXNODE];\n    void insert(int & u, int l, int r, int tar) {\n        if (!u) u = ++tot;\n        if (l == r) return static_cast<void> (tree[u].second = l, ++tree[u].first);\n        int mid = l + r >> 1;\n        if (tar <= mid) insert(ls[u], l, mid, tar);\n        else insert(rs[u], mid + 1, r, tar);\n        tree[u] = std::max(tree[ls[u]], tree[rs[u]]);\n    }\n    int merge(int x, int y, int l, int r) {\n        if (!x || !y) return x | y;\n        int now = ++tot;\n        if (l == r) {\n            tree[now] = tree[x];\n            tree[now].first += tree[y].first;\n            return now;\n        }\n        const int mid = l + r >> 1;\n        ls[now] = merge(ls[x], ls[y], l, mid);\n        rs[now] = merge(rs[x], rs[y], mid + 1, r);\n        tree[now] = std::max(tree[ls[now]], tree[rs[now]]);\n        return now;\n    }\n    PII query(int u, int l, int r, int L, int R) {\n        if (!u) return PII();\n        if (L <= l && r <= R) return tree[u];\n        int mid = l + r >> 1; PII res;\n        if (L <= mid) res = std::max(res, query(ls[u], l, mid, L, R));\n        if (mid < R) res = std::max(res, query(rs[u], mid + 1, r, L, R));\n        return res;\n    }\n}\nint nxt[MAXN][26], fail[MAXN], tot, lst, R[MAXN], v, p, now, t, fa[17][MAXN];\nvoid insert(int x, int bel) {\n    R[now = ++tot] = R[p = lst] + 1; lst = now;\n    SGT::insert(SGT::rt[now], 1, n, bel);\n    for (; p && !nxt[p][x]; p = fail[p]) nxt[p][x] = now;\n    if (!p) fail[now] = 1;\n    else {\n        t = nxt[p][x];\n        if (R[t] == R[p] + 1) fail[now] = t;\n        else {\n            R[v = ++tot] = R[p] + 1;\n            memcpy(nxt[v], nxt[t], sizeof(int) * 26);\n            fail[v] = fail[t]; fail[t] = fail[now] = v;\n            for (; p && nxt[p][x] == t; p = fail[p]) nxt[p][x] = v;\n        }\n    }\n}\nint at[MAXN * 10], L, Lx[MAXN * 10];\nchar buf[MAXN], * cur, qry[MAXN * 10];\nnamespace G {\n    int head[MAXN], nxt[MAXN], to[MAXN], t0t;\n    inline void addedge(int b, int e) {\n        nxt[++t0t] = head[b]; head[b] = t0t; to[t0t] = e;\n    }\n    void dfs(int u) {\n        for (int i = head[u]; i; i = nxt[i]) {\n            fa[0][to[i]] = u;\n            dfs(to[i]);\n            SGT::rt[u] = SGT::merge(SGT::rt[u], SGT::rt[to[i]], 1, n);\n        }\n    }\n}\nint main() {\n    tot = 1;\n    scanf(\"%s%d\", qry + 1, &n);\n    L = strlen(qry + 1);\n    for (int i = 1; i <= n; ++i) {\n        scanf(\"%s\", cur = buf); lst = 1;\n        while (*cur) insert(*cur++ - 'a', i);\n    }\n    for (int i = 2; i <= tot; ++i) G::addedge(fail[i], i); G::dfs(1);\n    assert(SGT::tot <= SGT::MAXNODE);\n    for (int i = 1; i != 17; ++i)\n        for (int j = 1; j <= tot; ++j)\n            fa[i][j] = fa[i - 1][fa[i - 1][j]];\n    int now = 1;\n    int nowl = 0;\n    for (int i = 1; i <= L; ++i) {\n        const int ch = qry[i] - 'a';\n        if (nxt[now][ch]) now = nxt[now][ch], ++nowl;\n        else {\n            while (now && !nxt[now][ch]) now = fail[now];\n            if (!now) now = 1, nowl = 0;\n            else nowl = R[now] + 1, now = nxt[now][ch];\n        }\n        at[i] = now; Lx[i] = nowl;\n    }\n    scanf(\"%d\", &Q);\n    while (Q --> 0) {\n        scanf(\"%d%d%d%d\", &t1, &t2, &t3, &t4);\n        const int L = t4 - t3 + 1;\n        if (L > Lx[t4]) {\n            printf(\"%d 0\\n\", t1);\n            continue;\n        }\n        int u = at[t4];\n        for (int i = 16; ~i; --i)\n            if (R[fa[i][u]] >= L)\n                u = fa[i][u];\n        PII ret = SGT::query(SGT::rt[u], 1, n, t1, t2);\n        if (ret.first == 0) ret.second = t1;\n        printf(\"%d %d\\n\", ret.second, ret.first);\n    }\n    return 0;\n}\n```",
        "postTime": 1545472275,
        "uid": 22066,
        "name": "daklqw",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "[$\\text{Link}$](https://www.luogu.com.cn/problem/CF666E)\n## \u9898\u610f\n\u7ed9 $m$ \u4e2a\u6587\u672c\u4e32 $T_{1,2,...,m}$ \u548c\u4e00\u4e2a\u957f\u5ea6\u4e3a $n$ \u7684\u5b57\u7b26\u4e32 $S$\uff0c$q$ \u6b21\u8be2\u95ee\uff0c\u8bbe $\\text{app}(s,t)$ \u8868\u793a $s$ \u5728 $t$ \u4e2d\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u6c42 $\\max_{i=pl}^{pr}\\text{app}(S[l,r],T_i)$\u3002\n\n$1\\le n,q\\le 5\\times 10^5,1\\le m,\\sum|T|\\le 5\\times 10^4$\u3002\n## \u601d\u8def\n$\\text{Update }2022.4.26$\uff1a\u589e\u52a0\u4e86\u90e8\u5206\u8bf4\u660e\u3002\n\n\u6ce8\uff1a\u672c\u9898\u89e3\u4e2d\u7684 $l,r$ \u548c $pl,pr$\u7684\u610f\u4e49\u4e0e\u9898\u76ee\u4e2d\u76f8\u53cd\u3002\n\n\u8003\u8651\u5bf9\u4e8e $m$ \u4e2a\u4e32\u5efa\u51fa\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u4e2a\u52a8\u6001\u5f00\u70b9\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u4e0b\u6807\u4e3a\u6240\u5c5e\u4e32\u7684\u7f16\u53f7\uff0c\u8bb0\u5f55\u533a\u95f4\u6700\u5927\u503c\u548c\u4e0b\u6807\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u524d\u7f00\u7ed3\u70b9\uff0c\u5c06\u5176\u6240\u5c5e\u7684\u5b57\u7b26\u4e32\u7684\u4f4d\u7f6e $+1$\u3002\n\n\u7136\u540e\u5efa\u7acb $\\text{parent}$ \u6811\uff0c\u5bf9\u5176\u8dd1\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u5373\u53ef\u5f97\u51fa\u6bcf\u4e2a\u7ed3\u70b9\u5bf9\u5e94\u7684\u5728\u6bcf\u4e2a\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002\n\n\u9884\u5904\u7406\u51fa $S$ \u7684\u6bcf\u4e2a\u524d\u7f00 $S[1,i]$ \u5728\u5e7f\u4e49 $\\text{SAM}$ \u4e2d\u80fd\u5339\u914d\u4e0a\u7684\u6700\u957f\u540e\u7f00\u7684\u957f\u5ea6\u4ee5\u53ca\u5b83\u5339\u914d\u5230\u7684\u4f4d\u7f6e\uff0c\u8bb0\u4e3a $ansi_i$ \u548c $pos_i$\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u82e5\u5230\u4e0b\u4e00\u4e2a\u5b57\u7b26\u53ef\u8f6c\u79fb\u5219\u8f6c\u79fb\uff0c\u4ee4 $ansi_{i+1}=ansi_i+1$\uff0c\u5426\u5219\u8df3 $\\text{link}$ \u76f4\u5230\u6709\u8f6c\u79fb\u6216\u8005\u5230\u6839\u3002\n\n\u5bf9\u4e8e\u4e00\u6b21\u67e5\u8be2\uff0c\u5148\u5224\u6389 $r-l+1>ansi_r$ \u7684\u65e0\u89e3\u60c5\u51b5\uff0c\u518d\u8003\u8651\u4ece $cur=pos_r$ \u7684\u4f4d\u7f6e\u5f97\u5230 $S[l,r]$ \u5bf9\u5e94\u7684\u7ed3\u70b9\u3002\u56e0\u4e3a $\\text{parent}$ \u6811\u4e0a\u7684\u7956\u5148\u90fd\u662f\u5b83\u7684\u540e\u7f00\uff0c\u6240\u4ee5\u6211\u4eec\u5728 $\\text{parent}$ \u6811\u4e0a\u500d\u589e\u5230 $len_{cur}\\ge r-l+1$\uff0c\u6b64\u65f6\u8282\u70b9 $cur$ \u4fbf\u5305\u542b\u4e32 $S[l,r]$\uff0c\u76f4\u63a5\u5728 $cur$ \u7684\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2 $[pl,pr]$ \u7684\u6781\u503c\u5373\u53ef\u3002\n\n\u6ce8\u610f\u7ebf\u6bb5\u6811\u5408\u5e76\u65f6\u9700\u8981\u91c7\u53d6\u65b0\u5efa\u8282\u70b9\u7684\u65b9\u6cd5\u800c\u4e0d\u662f\u76f4\u63a5\u66f4\u6539\uff0c\u56e0\u4e3a\u5408\u5e76\u5b8c\u4e4b\u540e\u9700\u8981\u67e5\u8be2\u4efb\u610f\u8282\u70b9\u7684\u7b54\u6848\u3002\n\n\u8fd9\u91cc\u7684\u500d\u589e\u662f\u4e2a\u5f88\u7ecf\u5178\u7684\u6280\u5de7\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(\\sum |T|\\log|T|+q\\log n)$\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace IO{//by cyffff\n\t\n}\nconst int N=1e6+10;\nstruct node{\n\tint val,cnt;\n\tinline friend bool operator<(const node &a,const node &b){\n\t\treturn a.cnt==b.cnt?a.val>b.val:a.cnt<b.cnt;\n\t}\n\tinline friend node operator+(const node &a, const node &b){\n\t\treturn (node){a.val,a.cnt+b.cnt};\n\t}\n\tnode(int x=0,int y=0){val=x,cnt=y;}\n};\nstruct Edge{\n\tint to,next;\n};\nint n,m,q;\nEdge a[N<<1];\nint head[N],dep[N],f[20][N],cnt;\nint pos[N],ansi[N];\nchar str[N];\ninline void add(int u,int v){\n    cnt++;\n    a[cnt].to=v;\n    a[cnt].next=head[u];\n    head[u]=cnt;\n}\nstruct Segument_Tree{\n\tint son[2][N*20],root[N],cnt;\n\tnode val[N*20];\n\t#define ls (son[0][rt])\n\t#define rs (son[1][rt])\n\tinline void insert(int &rt,int l,int r,int p){\n\t\tif(!rt){\n\t\t\trt=++cnt;\n\t\t}\n\t\tif(l==r){\n\t\t\tval[rt].cnt++;\n\t\t\tval[rt].val=l;\n\t\t\treturn ;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tif(p<=mid){\n\t\t\tinsert(ls,l,mid,p);\n\t\t}else{\n\t\t\tinsert(rs,mid+1,r,p);\n\t\t}\n\t\tval[rt]=max(val[ls],val[rs]);\n\t}\n\tinline int merge(int a,int b,int l,int r){\n\t\tif(!a||!b) return a+b;\n\t\tint rt=++cnt;\n\t\tif(l==r){\n\t\t\tval[rt]=val[a]+val[b];\n\t\t\treturn rt;\n\t\t}\n\t\tint mid=l+r>>1;\n\t\tls=merge(son[0][a],son[0][b],l,mid);\n\t\trs=merge(son[1][a],son[1][b],mid+1,r);\n\t\tval[rt]=max(val[ls],val[rs]);\n\t\treturn rt;\n\t}\n\tinline node query(int rt,int l,int r,int L,int R){\n\t\tif(!rt) return node();\n\t\tif(L<=l&&r<=R) return val[rt];\n\t\tnode ans;\n\t\tint mid=l+r>>1;\n\t\tif(L<=mid) ans=max(ans,query(ls,l,mid,L,R));\n\t\tif(R>mid) ans=max(ans,query(rs,mid+1,r,L,R));\n\t\treturn ans;\n\t}\n\tinline void dfs(int rt){\n\t\tfor(int i=head[rt];i;i=a[i].next){\n\t\t\tif(a[i].to!=f[0][rt]){\n\t\t\t\tf[0][a[i].to]=rt;\n\t\t\t\tdfs(a[i].to);\n\t\t\t\troot[rt]=merge(root[rt],root[a[i].to],1,m);\n\t\t\t}\n\t\t}\n\t}\n}t;\nstruct SAM{\n\tstruct statu{\n\t\tint len,link;\n\t\tint ch[26];\n\t}a[N];\n\tint siz,last;\n\tSAM(){\n\t\ta[0].len=0;\n\t\ta[0].link=-1;\n\t\tlast=0;\n\t}\n\tinline void insert(int c,int x){\n\t\tint cur=++siz;\n\t\ta[cur].len=a[last].len+1;\n\t\tt.insert(t.root[cur],1,m,x);\n\t\tint p=last;\n\t\twhile(p!=-1&&!a[p].ch[c]){\n\t\t\ta[p].ch[c]=cur;\n\t\t\tp=a[p].link;\n\t\t}\n\t\tif(~p){\n\t\t\tint q=a[p].ch[c];\n\t\t\tif(a[p].len+1==a[q].len){\n\t\t\t\ta[cur].link=q;\n\t\t\t}else{\n\t\t\t\tint clone=++siz;\n\t\t\t\ta[clone]=a[q];\n\t\t\t\ta[clone].len=a[p].len+1;\n\t\t\t\twhile(p!=-1&&a[p].ch[c]==q){\n\t\t\t\t\ta[p].ch[c]=clone;\n\t\t\t\t\tp=a[p].link;\n\t\t\t\t}\n\t\t\t\ta[q].link=a[cur].link=clone;\n\t\t\t}\n\t\t}else{\n\t\t\ta[cur].link=0;\n\t\t}\n\t\tlast=cur;\n\t}\n\tinline int insert(){\n\t\tstatic char str[N];\n\t\tint T=read();\n\t\tm=T;\n\t\tfor(int k=1;k<=T;k++){\n\t\t\treadstr(str);\n\t\t\tint len=strlen(str+1);\n\t\t\tlast=0;\n\t\t\tfor(int i=1;i<=len;i++){\n\t\t\t\tinsert(str[i]-'a',k);\n\t\t\t}\n\t\t}\n\t\treturn T;\n\t}\n\tinline void build(){\n\t\tfor(int i=1;i<=siz;i++){\n\t\t\tadd(a[i].link,i);\n\t\t}\n\t}\n\tinline void calc(){\n\t\tint anss=0;\n\t\tint p=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tint c=str[i]-'a';\n\t\t\tif(a[p].ch[c]){\n\t\t\t\tanss++;\n\t\t\t\tp=a[p].ch[c];\n\t\t\t}else{\n\t\t\t\twhile(p!=-1&&!a[p].ch[c]){\n\t\t\t\t\tp=a[p].link;\n\t\t\t\t}\n\t\t\t\tif(~p){\n\t\t\t\t\tanss=a[p].len+1;\n\t\t\t\t\tp=a[p].ch[c];\n\t\t\t\t}else{\n\t\t\t\t\tanss=0;\n\t\t\t\t\tp=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tansi[i]=anss;\n\t\t\tpos[i]=p;\n\t\t}\n\t}\n}sam;\nint main(){\n\tn=readstr(str);\n\tm=sam.insert();\n\tsam.build();\n\tt.dfs(0);\n\tfor(int i=1;i<=18;i++){\n\t\tfor(int j=1;j<=sam.siz;j++){\n\t\t\tf[i][j]=f[i-1][f[i-1][j]];\n\t\t}\n\t}\n\tsam.calc();\n\tq=read();\n\twhile(q--){\n\t\tint pl=read(),pr=read(),l=read(),r=read();\n\t\tint len=r-l+1;\n\t\tif(len>ansi[r]){\n\t\t\twrite(pl),putc(' '),write(0),putc('\\n');\n\t\t\tcontinue;\n\t\t}\n\t\tint cur=pos[r];\n\t\tfor(int i=18;~i;i--){\n\t\t\tif(sam.a[f[i][cur]].len>=len){\n\t\t\t\tcur=f[i][cur];\n\t\t\t}\n\t\t}\n\t\tnode ans=t.query(t.root[cur],1,m,pl,pr);\n\t\tif(ans.cnt==0) ans.val=pl;\n\t\twrite(ans.val),putc(' '),write(ans.cnt),putc('\\n');\n\t}\n\tflush();\n\treturn 0;\n}\n```\n\u518d\u89c1 qwq~\n",
        "postTime": 1622446939,
        "uid": 365127,
        "name": "cyffff",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF666E\u3010Forensic Examination\u3011"
    },
    {
        "content": "> [CF666E Forensic Examination](https://codeforces.com/contest/666/problem/E)\n\n## \u9898\u610f\n\n- \u7ed9\u5b9a\u4e00\u4e2a\u5b57\u7b26\u4e32 $s$\uff0c\u4ee5\u53ca $m$ \u4e2a\u5b57\u7b26\u4e32 $t_{1 \\dots m}$\u3002\n- $q$ \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee $s[p_l:p_r]$ \u5728\u5b57\u7b26\u4e32 $t_{l\\dots r}$ \u4e2d\u7684\u54ea\u4e2a\u4e32\u91cc\u4f5c\u4e3a\u5b50\u4e32\u51fa\u73b0\u7684\u6b21\u6570\u6700\u591a\uff0c\u5982\u679c\u6709\u591a\u4e2a\u7b54\u6848\uff0c\u8f93\u51fa\u6700\u5c0f\u7684\u4e00\u4e2a\u3002\n- $|s|,q \\le 5 \\times 10^5$\uff0c$m,\\sum_{i=1}^m |t_i| \\le 5 \\times 10^4$\u3002\n\n## \u9898\u89e3\n\n\u5c06 $s$ \u548c $t_{1\\dots m}$ \u5408\u6210\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u4e2d\u95f4\u7528\u4e00\u4e2a\u5176\u5b83\u7684\u5206\u9694\u7b26\u9694\u5f00\u3002\n\n\u8bbe\u8fd9\u4e2a\u65b0\u5b57\u7b26\u4e32\u4e3a $s^\\prime$\uff0c\u6709 $|s^\\prime| = |s| + \\sum_{i=1}^{m}|t_i| + m$\u3002\n\n\u5bf9\u8fd9\u4e2a\u5b57\u7b26\u4e32\u6c42 SA\uff0c\u5219\u4e00\u6b21\u8be2\u95ee $(p_l,p_r,l,r)$ \u7684\u7b54\u6848\u4e3a\uff1a\n\nSA \u4e2d $p_l$ \u6240\u5728\u7684\u4f4d\u7f6e\u524d\u540e $\\operatorname{height}$ \u4e0d\u5c0f\u4e8e $p_r - p_l + 1$ \u7684\u533a\u95f4\u4e2d\uff0c\u6bcf\u4e2a\u540e\u7f00\u5bf9\u5e94 $t_i$ \u7684 $i$ \u5728 $[l,r]$ \u4e2d\u7684\u4f17\u6570\u3002\n\n\u5982\u679c\u6211\u4eec\u6309\u7167 $\\operatorname{height}$ \u7531\u5927\u5230\u5c0f\u5408\u5e76\uff0c\u5e76\u5efa\u51fa kruskal \u91cd\u6784\u6811\u3002\n\n\u90a3\u4e00\u6b21\u8be2\u95ee\u5c31\u7b49\u4ef7\u4e8e\u67e5\u8be2\u4e00\u68f5\u5b50\u6811\u5185\u989c\u8272\u5728 $[l,r]$ \u4e2d\u7684\u4f17\u6570\uff0c\u500d\u589e\u627e\u5230\u5b50\u6811\u7684\u6839\u540e\uff0c\u7ebf\u6bb5\u6811\u5408\u5e76\u5373\u53ef\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(|s^\\prime| \\log |s^\\prime| + q (\\log |s^\\prime| + \\log m))$\u3002\n\n## \u4ee3\u7801\n\n```cpp\nconst int N = 6e5 + 7, M = 21;\nint n, m, len[N], q;\nchar s[N], ss[N];\nstruct SA {\n\tint n, m = 127, sa[N], rk[N<<1], tp[N<<1], tx[N], he[N];\n\tchar s[N];\n\tinline void sort() {\n\t\tfor (int i = 1; i <= m; i++) tx[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) ++tx[rk[i]];\n\t\tfor (int i = 1; i <= m; i++) tx[i] += tx[i-1];\n\t\tfor (int i = n; i; i--) sa[tx[rk[tp[i]]]--] = tp[i];\n\t}\n\tinline bool pd(int i, int j, int k) {\n\t\treturn tp[i] == tp[j] && tp[i+k] == tp[j+k];\n\t}\n\tinline void main() {\n\t\tfor (int i = 1; i <= n; i++) rk[i] = s[i], tp[i] = i;\n\t\tsort();\n\t\tfor (int k = 1, p; p < n; k <<= 1, m = p) {\n\t\t\tp = 0;\n\t\t\tfor (int i = 1; i <= k; i++) tp[++p] = n - k + i;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tif (sa[i] > k) tp[++p] = sa[i] - k;\n\t\t\tsort(), swap(rk, tp), rk[sa[1]] = p = 1;\n\t\t\tfor (int i = 2; i <= n; i++)\n\t\t\t\trk[sa[i]] = p += !pd(sa[i], sa[i-1], k);\n\t\t}\n\t}\n\tinline void height() {\n\t\tfor (int i = 1, p = 0; i <= n; i++) {\n\t\t\tif (p) --p;\n\t\t\tint j = sa[rk[i]-1];\n\t\t\twhile (s[i+p] == s[j+p]) ++p;\n\t\t\the[rk[i]] = p;\n\t\t}\n\t}\n} sa;\nstruct T {\n\tint l, r;\n\tpi x;\n} t[N<<6|1];\nint p[N], rt[N<<1], tot, d[N<<1], num, f[N<<1][M], u[N<<1];\n\nint get(int x) {\n\treturn x == u[x] ? x : (u[x] = get(u[x]));\n}\n\ninline pi operator + (pi x, pi y) {\n\treturn x.se < y.se ? y : x;\n}\n\nint ins(int l, int r, int x) {\n\tint p = ++tot;\n\tif (l == r) return t[p].x = mp(x, 1), p;\n\tint mid = (l + r) >> 1;\n\tif (x <= mid) t[p].l = ins(l, mid, x);\n\telse t[p].r = ins(mid + 1, r, x);\n\tt[p].x = t[t[p].l].x + t[t[p].r].x;\n\treturn p;\n}\n\nint merge(int p, int q, int l, int r) {\n\tif (!p || !q) return p | q;\n\tint o = ++tot;\n\tif (l == r) return t[o].x = t[p].x, t[o].x.se += t[q].x.se, o;\n\tint mid = (l + r) >> 1;\n\tt[o].l = merge(t[p].l, t[q].l, l, mid);\n\tt[o].r = merge(t[p].r, t[q].r, mid + 1, r);\n\tt[o].x = t[t[o].l].x + t[t[o].r].x;\n\treturn o;\n}\n\npi ask(int p, int l, int r, int L, int R) {\n\tif (l >= L && r <= R) return t[p].x;\n\tint mid = (l + r) >> 1;\n\tpi o = mp(0, 0);\n\tif (L <= mid) o = ask(t[p].l, l, mid, L, R);\n\tif (R > mid) o = o + ask(t[p].r, mid + 1, r, L, R);\n\treturn o;\n}\n\nint main() {\n\trds(s, n), rd(m);\n\tfor (int i = 1; i <= m; i++) {\n\t\trds(ss, len[i]);\n\t\tfor (int j = 1; j <= len[i]; j++) sa.s[++sa.n] = ss[j];\n\t\tsa.s[++sa.n] = sa.m, len[i] += len[i-1] + 1;\n\t}\n\tfor (int i = 1; i <= n; i++) sa.s[++sa.n] = s[i];\n\tsa.main(), sa.height();\n\tfor (int i = 1; i <= m; i++)\n\t\tfor (int j = len[i-1] + 1; j < len[i]; j++)\n\t\t\trt[sa.rk[j]] = ins(1, m, i);\n\tfor (int i = 1; i <= sa.n; i++) p[i] = u[i] = i;\n\tsort(p + 2, p + sa.n + 1, [](int i, int j) {\n\t\treturn sa.he[i] > sa.he[j];\n\t});\n\tnum = sa.n;\n\tfor (int i = 2; i <= sa.n; i++) {\n\t\td[++num] = sa.he[p[i]];\n\t\tint x = get(p[i]), y = get(p[i] - 1);\n\t\tf[x][0] = f[y][0] = u[x] = u[y] = u[num] = num;\n\t\trt[num] = merge(rt[x], rt[y], 1, m);\n\t}\n\tfor (int j = 1; j < M; j++)\n\t\tfor (int i = 1; i <= num; i++)\n\t\t\tf[i][j] = f[f[i][j-1]][j-1];\n\trd(q);\n\tfor (int i = 1, l, r, pl, pr; i <= q; i++) {\n\t\trd(l), rd(r), rd(pl), rd(pr);\n\t\tint x = sa.rk[pl+len[m]], k = pr - pl + 1;\n\t\tfor (int j = M - 1; ~j; j--)\n\t\t\tif (d[f[x][j]] >= k) x = f[x][j];\n\t\tpi ans = ask(rt[x], 1, m, l, r);\n\t\tprint(ans.fi ? ans.fi : l, ' '), print(ans.se);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1584270662,
        "uid": 100544,
        "name": "xht",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "\uff08\u5927\u6982\u662f$AFO$\u4e4b\u524d\u6700\u540e\u4e00\u7bc7\u9898\u89e3\u4e86\u5427\u2026\u2026\u660e\u5929$noip$\u51fa\u6210\u7ee9\u4e4b\u540e\u5927\u6982\u5c31\u771f\u7684\u9000\u5f79\u4e86\u5462\u2026\u2026\uff09\n\n\u8fd9\u9898\u9700\u8981\u6211\u4eec\u5bf9\u6a21\u677f\u4e32\u5efa\u4e00\u4e2a\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u7136\u540e\u6211\u4eec\u628a$S$\u653e\u5230$SAM$\u4e0a\u8fd0\u884c\uff0c\u8003\u8651\u5f53\u524d$i$\u4f4d\u7f6e\u8dd1\u5230\u7684\u8282\u70b9$p$\uff0c\u6211\u4eec\u77e5\u9053\uff0c$p$\u7684$Parent$\u7956\u5148\u662f$p$\u7684\u5b57\u7b26\u4e32\u7684\u540e\u7f00\uff0c\u8d8a\u5f80\u4e0a\u8d70\uff0c\u5b57\u7b26\u4e32\u7684\u957f\u5ea6\u8d8a\u5c0f\uff0c\u4ed6\u7ed9\u6211\u4eec\u4e86\u4e00\u4e2a\u5728$S$\u5185\u7684\u533a\u95f4$[p_l,p_r]$\uff0c\u5047\u5982$p$\u5c31\u662f$[1,p_r]$\u8fd9\u4e00\u6bb5$S$\u7684\u524d\u7f00\u5728$SAM$\u4e0a\u8fd0\u884c\u5f97\u5230\u7684\u70b9\uff0c\u5982\u679c$p$\u7684\u6700\u5927\u957f\u5ea6\u6bd4\u8fd9\u4e2a\u533a\u95f4\u7684\u957f\u5ea6\u8fd8\u8981\u5c0f\u90a3\u4e48\u663e\u7136\u662f\u4e0d\u80fd\u8fdb\u884c\u5339\u914d\u7684\uff0c\u7136\u540e\u6211\u4eec\u5c31\u53ef\u4ee5\u8ba9$p$\u5728$Parent$\u6811\u4e0a\u5f80\u4e0a\u8df3\u627e\u5230\u4e00\u4e2a\u70b9\u4f7f\u5f97\u5b83\u7684\u957f\u5ea6\u533a\u95f4\u521a\u597d\u5bf9\u5e94\u8fd9\u4e2a\u5b50\u4e32\uff0c\u4e5f\u5c31\u662f\u8bf4\u8fd9\u4e2a\u5b57\u4e32\u662f\u8fd9\u4e2a\u8282\u70b9\u7684\u5b57\u7b26\u4e32\uff0c\u663e\u7136\u5411\u4e0a\u8df3\u7684\u8fc7\u7a0b\u5728\u957f\u5ea6\u4e0a\u6ee1\u8db3\u5355\u8c03\u6027\uff0c\u53ef\u4ee5\u7528\u6811\u4e0a\u500d\u589e\u6c42\u51fa\u3002\u7136\u540e\u6211\u4eec\u63a5\u7740\u5c31\u8981\u89e3\u51b3\u5b50\u6811\u91cc\u5c5e\u4e8e\u6a21\u677f\u4e32\u533a\u95f4$[l,r]$\u7684\u54ea\u4e2a\u4e32\u7684\u70b9\u51fa\u73b0\u7684\u6700\u591a\uff0c\u6211\u4eec\u77e5\u9053$SAM$\u7684\u5957\u8def\u4e4b\u4e00\u5c31\u662f\u6bcf\u4e2a\u70b9\u7684\u51fa\u73b0\u4f4d\u7f6e\u96c6\u5408$Right$\u662f\u53ef\u4ee5\u901a\u8fc7\u5bf9$Parent$\u6811\u7684\u5b50\u6811\u8fdb\u884c\u7ebf\u6bb5\u6811\u5408\u5e76\u505a\u5230$O(nlogn)$\uff0c\u6211\u4eec\u4e0d\u59a8\u7528\u4ee5\u6a21\u677f\u4e32\u7f16\u53f7\u4e3a\u4e0b\u6807\u7684\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5b50\u6811\u5185\u51fa\u73b0\u6700\u591a\u7684\u6a21\u677f\u4e32\u7f16\u53f7\uff0c\u7136\u540e\u6211\u4eec\u628a\u8fd9\u4e2a\u8fdb\u884c\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u7136\u540e\u5c31\u80fd\u5728\u7ebf\u6bb5\u6811\u4e0a\u8fdb\u884c\u533a\u95f4\u67e5\u8be2\u4e86\u3002\n\n\u7136\u540e\u8fd9\u91cc\u6709\u4e2a\u7ec6\u8282\uff0c\u5c31\u662f\u6211\u4eec\u5728\u628a$S$\u653e\u5230\u540e\u7f00\u81ea\u52a8\u673a\u4e0a\u8fd0\u884c\u7684\u65f6\u5019\u4f1a\u5f88\u81ea\u7136\u7684\u8bb0\u5f55\u6bcf\u4e2a\u4f4d\u7f6e\u5230\u8fbe\u7684\u8282\u70b9\uff0c\u4f46\u662f\u4e0d\u8981\u5fd8\u4e86\u8fd9\u4e2a\u53ef\u662f\u540e\u7f00\u81ea\u52a8\u673a\u800c\u4e0d\u662f$AC$\u81ea\u52a8\u673a\uff0c\u5e76\u4e0d\u80fd\u5149\u8bb0\u5f55\u4e2a\u8282\u70b9\u7136\u540e\u5c31\u4e86\u4e8b\u4e86\uff0c\u56e0\u4e3a\u6211\u4eec\u5728\u8fd0\u884c\u7684\u65f6\u5019\u5e76\u4e0d\u662f\u603b\u80fd\u591f\u987a\u5229\u5339\u914d\u7684\uff0c\u80af\u5b9a\u4f1a\u6709\u8df3$Parent$\u7684\u8fc7\u7a0b\uff0c\u6240\u4ee5\u5f53\u524d\u8282\u70b9\u7684$len$\u5e76\u4e0d\u4ee3\u8868$S$\u771f\u6b63\u5728\u4e0a\u9762\u5339\u914d\u7684\u957f\u5ea6\uff0c\u6240\u4ee5\u6211\u4eec\u8fd8\u8981\u628a$S$\u7684\u5339\u914d\u957f\u5ea6\u7ef4\u62a4\u4e00\u4e0b\uff0c\u7136\u540e\u6211\u4eec\u5728\u5224\u65ad$p_r$\u7684\u8fd9\u4e2a\u524d\u7f00\u7684\u70b9\u80fd\u5426\u5339\u914d\u7684\u65f6\u5019\u5c31\u4e0d\u4f1a\u51fa\u95ee\u9898\u4e86\u3002\n\n\u4e0a\u4ee3\u7801\uff08\u5199\u7684\u7565\u5fae\u96be\u770b\u2026\u2026~~\u56e0\u4e3a\u6211\u7684$dev$\u7a81\u7136\u4e0d\u80fd\u683c\u5f0f\u5316\u4ee3\u7801\u4e86\u2026\u2026~~\uff09~\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nnamespace ywy{\n    inline int get(char *str){\n        register int ptr=1;char c;while((c=getchar())||23333)if(c>='a'&&c<='z')break;\n        str[ptr]=c;ptr++;while((c=getchar())||23333){\n            if(c>='a'&&c<='z')str[ptr]=c,ptr++;else return(ptr-1);\n        }\n    }char s[500002],str[50002];int sam[100001][26],root[100001];\n    int len[100001],heads[100001],fa[100001],ance[100001][17];\n    int maxn[10000001],maxpos[10000001],lef[10000001],rgh[10000001];\n    typedef struct _b{\n        int dest;int nxt;\n    }bian;bian memchi[100001];int gnn=1;int gseg=1,pt;\n    inline void add(int s,int t){\n        memchi[gnn].dest=t;memchi[gnn].nxt=heads[s];heads[s]=gnn;gnn++;\n    }int gn=2;int m\uff1b\n    inline void up(int tree){\n        if(maxn[lef[tree]]>=maxn[rgh[tree]]){\n            maxn[tree]=maxn[lef[tree]];maxpos[tree]=maxpos[lef[tree]];\n        }else{\n            maxn[tree]=maxn[rgh[tree]];maxpos[tree]=maxpos[rgh[tree]];\n        }\n    }\n    void insert(int l,int r,int &tree){\n        if(!tree)tree=gseg,gseg++;if(l==r){\n            maxpos[tree]=l;maxn[tree]++;return;\n        }int mid=(l+r)>>1;if(pt<=mid)insert(l,mid,lef[tree]);else insert(mid+1,r,rgh[tree]);up(tree);\n    }\n    int united(int l,int r,int a,int b){\n        if(!(a&&b))return(a|b);int tree=gseg;gseg++;if(l==r){\n            maxn[tree]=maxn[a]+maxn[b];maxpos[tree]=l;return(tree);\n        }int mid=(l+r)>>1;lef[tree]=united(l,mid,lef[a],lef[b]);rgh[tree]=united(mid+1,r,rgh[a],rgh[b]);\n        up(tree);return(tree);\n    }\n    inline int zhuanyi(int p,int x,int cjr){\n        int me=gn;gn++;len[me]=len[p]+1;pt=cjr;insert(1,m,root[me]);\n        while(p&&!sam[p][x])sam[p][x]=me,p=fa[p];\n        if(!p){fa[me]=1;return(me);}int q=sam[p][x];if(len[q]==len[p]+1){fa[me]=q;return(me);}\n        int nq=gn;gn++;len[nq]=len[p]+1;fa[nq]=fa[q];fa[q]=fa[me]=nq;\n        for(register int i=0;i<26;i++)sam[nq][i]=sam[q][i];\n        while(p&&sam[p][x]==q)sam[p][x]=nq,p=fa[p];return(me);\n    }int deep[100001];\n    void dfs(int pt){\n        for(register int i=heads[pt];i;i=memchi[i].nxt){deep[memchi[i].dest]=deep[pt]+1;\n            dfs(memchi[i].dest);root[pt]=united(1,m,root[pt],root[memchi[i].dest]);\n        }\n    }int pot[500002];\n    inline int get(){\n        int n=0;char c;while((c=getchar())||23333){\n            if(c>='0'&&c<='9')break;if(c=='-')goto s;\n        }n=c-'0';while((c=getchar())||23333){\n            if(c>='0'&&c<='9')n=n*10+c-'0';else return(n);\n        }s:while((c=getchar())||23333){\n            if(c>='0'&&c<='9')n=n*10-c+'0';else return(n);\n        }\n    }\n    void print(int num){\n        if(num>=10)print(num/10);putchar(num%10+'0');\n    }\n    typedef struct _n{\n        int maxn;int maxpos;_n(int a,int b){maxn=a;maxpos=b;}\n        friend bool operator <(const _n &a,const _n &b){\n            if(a.maxn==b.maxn)return(a.maxpos>b.maxpos);return(a.maxn<b.maxn);\n        }\n    }node;\n    node query(int rl,int rr,int l,int r,int tree){\n        if(!maxn[tree])return(_n(0,rl));if(rl==l&&rr==r)return(_n(maxn[tree],maxpos[tree]));\n        int mid=(l+r)>>1;if(rl>mid)return(query(rl,rr,mid+1,r,rgh[tree]));\n        if(rr<=mid)return(query(rl,rr,l,mid,lef[tree]));return(max(query(rl,mid,l,mid,lef[tree]),query(mid+1,rr,mid+1,r,rgh[tree])));\n    }int ls[500001];\n    void ywymain(){\n        int n=get(s);cin>>m;for(register int i=1;i<=m;i++){\n            int p=1;int ln=get(str);for(register int j=1;j<=ln;j++)p=zhuanyi(p,str[j]-'a',i);\n        }for(register int i=2;i<gn;i++)add(ance[i][0]=fa[i],i);dfs(1);for(register int i=1;i<=16;i++){\n            for(register int j=1;j<gn;j++){\n                if(deep[j]<(1<<i))continue;ance[j][i]=ance[ance[j][i-1]][i-1];\n            }\n        }int cur=1;int ln=0;for(register int i=1;i<=n;i++){\n            if(sam[cur][s[i]-'a']){\n            \tln++;cur=sam[cur][s[i]-'a'];pot[i]=cur;ls[i]=ln;continue;\n            }while(cur&&!sam[cur][s[i]-'a'])cur=fa[cur],ln=len[cur]+1;if(!cur){\n                cur=1;ln=0;pot[i]=cur;ls[i]=0;continue;\n            }cur=sam[cur][s[i]-'a'];pot[i]=cur;ls[i]=ln;\n        }int q=get();while(q){\n            q--;int l=get(),r=get(),pl=get(),pr=get();int nd=pot[pr];\n            if(ls[pr]<(pr-pl+1)){\n                printf(\"%d 0\\n\",l);continue;\n            }for(register int i=16;i>=0;i--){\n                if(!ance[nd][i])continue;if(len[ance[nd][i]]>=(pr-pl+1))nd=ance[nd][i];\n            }node cjr=query(l,r,1,m,root[nd]);print(cjr.maxpos);putchar(' ');print(cjr.maxn);putchar('\\n');\n        }\n    }\n}\nint main(){\n    ywy::ywymain();\n    return(0);\n}\n```",
        "postTime": 1542550931,
        "uid": 125124,
        "name": "ywy_c_asm",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "# [CF666E Forensic Examination](https://www.luogu.com.cn/problem/CF666E)\n\n\u8fd9\u91cc\u662f\u4e00\u79cd\u540e\u7f00\u6570\u7ec4+\u83ab\u961f\u7684\u5947\u5999\u89e3\u6cd5~~~\n\n\u9996\u5148\uff0c\u5e38\u89c4\u5957\u8def\u5c31\u662f\u5c06\u6240\u6709\u4e32\u4e2d\u95f4\u63d2\u4e0a\u4e00\u4e2a\u5b57\u7b26\u7136\u540e\u5e76\u4e00\u8d77\u8dd1\u540e\u7f00\u6392\u5e8f\u3002\u8fd9\u6837\u8dd1\u5b8c\u4e4b\u540e\u6211\u4eec\u53d1\u73b0\uff0c\u5982\u679c\u6211\u4eec\u8981\u6c42\u82f1\u6587\u9898\u9762\u4e2d\u201c\u7981\u5fcc\u4e32\u201d\u4e2d\u4e00\u6bb5\u5b50\u4e32 $[p_l,p_r]$ \u7684\u51fa\u73b0\u4f4d\u7f6e\uff0c\u5c31\u53ef\u4ee5\u7b49\u4ef7\u4e8e\u6240\u6709\u540e\u7f00 $i$\uff0c\u4f7f\u5f97 $\\operatorname{LCP}(i,p_l)\\geq p_r-p_l+1$\u3002\u4f9d\u636e $\\text{LCP Lemma}$\uff0c\u8fd9\u662f\u540e\u7f00\u6570\u7ec4\u4e2d\uff0c$rk_{p_l}$ \u5de6\u53f3\u4e24\u4fa7\u7684\u4e00\u6bb5\u533a\u95f4\u3002\u4e8e\u662f\u6211\u4eec\u5efa\u51faST\u8868\uff0c\u5728\u540e\u7f00\u6570\u7ec4\u4e0a\u4e8c\u5206\u5c31\u80fd\u627e\u51fa\u8fd9\u6bb5\u533a\u95f4\u3002\n\n\u8fd9\u6837\u641e\u5b8c\u4e4b\u540e\uff0c\u6211\u4eec\u53d1\u73b0\u95ee\u9898\u5c31\u88ab\u8f6c\u5316\u4e3a\uff1a\u5728\u540e\u7f00\u6570\u7ec4\u4e2d\u7684\u4e00\u6bb5\u533a\u95f4\u91cc\uff0c\u6765\u81ea\u54ea\u672c\u82f1\u6587\u9898\u9762\u4e2d\u201c\u5c0f\u518c\u5b50\u201d\u7684\u540e\u7f00\u662f\u51fa\u73b0\u6700\u591a\u7684\uff1f\n\n\u663e\u7136\u8fd9\u662f\u4e00\u4e2a\u533a\u95f4\u4f17\u6570\u95ee\u9898\uff0c\u5e38\u89c4\u89e3\u6cd5\u662f\u5206\u5757\uff08[\u8fd9\u9898](https://www.luogu.com.cn/problem/P5048)\uff09\u6216\u8005\u83ab\u961f\u3002\u4f46\u662f\u56e0\u4e3a\u8fd9\u9898\u5e76\u6ca1\u6709\u5f3a\u5236\u5728\u7ebf\uff0c\u5e76\u4e14\u5bf9\u4f17\u6570\u7684\u503c\u57df\u662f\u6709\u9650\u5236\u7684\uff08\u53ea\u6709\u6765\u81ea $[l,r]$ \u533a\u95f4\u91cc\u7684\u5c0f\u518c\u5b50\u624d\u4f1a\u88ab\u8003\u8651\uff09\uff0c\u6211\u4eec\u53ea\u80fd\u8003\u8651\u83ab\u961f\u3002\n\n\u56e0\u4e3a\u5bf9\u503c\u57df\u6709\u8981\u6c42\uff0c\u6211\u4eec\u8003\u8651\u518d**\u5173\u4e8e\u503c\u57df\u5206\u5757**\u3002\u5bf9\u4e8e\u6bcf\u4e2a\u5757\uff0c\u6211\u4eec\u9700\u8981\u8bb0\u5f55\u5757\u5185\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u90a3\u672c\u5c0f\u518c\u5b50\u51fa\u73b0\u4e86\u591a\u5c11\u6b21\u3002\u663e\u7136\u5f53\u83ab\u961f\u5f80\u533a\u95f4\u91cc\u52a0\u5165\u5143\u7d20\u65f6\u5f88\u597d\u5904\u7406\uff0c\u76f4\u63a5\u53d6 $\\max$ \u5373\u53ef\u3002\u4f46\u662f\u5982\u679c\u8981\u5220\u9664\u5143\u7d20\u5462\uff1f\n\n\u663e\u7136\u5220\u9664\u4e00\u4e2a\u5143\u7d20\u65f6\uff0c\u4f17\u6570\u51fa\u73b0\u6b21\u6570\u6700\u591a\u51cf\u4e00\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u9488\u5bf9\u6bcf\u4e2a\u5757\u5f00\u4e00\u4e2a\u6876\uff0c\u8bb0\u5f55\u5757\u4e2d\u6709\u591a\u5c11\u5143\u7d20\u7684\u51fa\u73b0\u6b21\u6570\u4e3a $i$\u3002\u5f53\u4e00\u6b21\u5220\u9664\u540e\uff0c\u5982\u679c\u6211\u4eec\u53d1\u73b0\u4f17\u6570\u6b21\u6570\u5bf9\u5e94\u7684\u90a3\u4e2a\u6876\u5df2\u7ecf\u7a7a\u4e86\uff0c\u5c31\u4ee4\u4f17\u6570\u51cf\u4e00\u5373\u53ef\u3002\n\n\u7136\u540e\u6700\u7ec8\u7edf\u8ba1\u7b54\u6848\u65f6\uff0c\u5c31\u662f\u4e00\u4e2a\u5e38\u89c4\u7684\u5206\u5757\uff0c\u6574\u5757\u76f4\u63a5\u8c03\u7528\u5757\u4e2d\u4f17\u6570\uff0c\u6563\u5757\u66b4\u529b\u626b\u8fc7\u5373\u53ef\u3002\n\n\u6211\u4eec\u4e0b\u9762\u6765\u5206\u6790\u590d\u6742\u5ea6\u3002\u6309\u7167\u6211\u4eec\u4ee3\u7801\u4e2d\u7684\u5199\u6cd5\uff0c\u6211\u4eec\u8bbe $n$ \u8868\u793a\u6240\u6709\u4e32\u5e76\u4e00\u8d77\u7684\u957f\u5ea6\uff0c$A$ \u8868\u793a\u5c0f\u518c\u5b50\u7684\u6570\u91cf\uff0c$m$ \u8868\u793a\u8be2\u95ee\u6570\u3002\u663e\u7136\uff0c\u5e94\u7528\u6211\u4eec\u521a\u624d\u7684\u65b9\u6cd5\uff0c\u83ab\u961f\u5355\u6b21\u7aef\u70b9\u79fb\u52a8\u662f $O(1)$ \u7684\uff0c\u83ab\u961f\u7edf\u8ba1\u4e00\u6b21\u7b54\u6848\u662f $O(\\sqrt{A})$ \u7684\u3002\u5b83\u4e00\u5171\u6700\u591a\u79fb\u52a8 $m\\sqrt{n}$ \u6b21\u7aef\u70b9\uff0c\u7edf\u8ba1 $m$ \u6b21\u7b54\u6848\uff0c\u6545\u8be5\u90e8\u5206\u590d\u6742\u5ea6\u4e3a $O\\Big(m(\\sqrt{n}+\\sqrt{A})\\Big)$\u3002\u7136\u540e\u7b97\u4e0a\u540e\u7f00\u6570\u7ec4\u7684 $O(n\\log n)$ \u500d\u589e\u6392\u5e8f\u4e0eST\u8868\uff0c\u4ee5\u53ca $m\\log n$ \u7684\u4e8c\u5206\uff0c\u56e0\u6b64\u603b\u590d\u6742\u5ea6\u4e3a $O\\Big((m+n)\\log n+m(\\sqrt{n}+\\sqrt{A})\\Big)$\u3002\n\n\u7136\u540e\u662f\u7a7a\u95f4\u90e8\u5206\u3002\u6211\u4eec\u6709ST\u8868\u7684 $n\\log n$ \u548c\u6876\u7684\u5927\u5c0f\u3002\u56e0\u4e3a\u6211\u4eec\u5bf9\u4e8e\u6bcf\u4e2a\u5757\u90fd\u5f00\u4e86\u4e00\u4e2a\u6876\uff0c\u6240\u4ee5\u6876\u7684\u5927\u5c0f\u662f $O(A\\sqrt{A})$ \u7684\u3002\u4f46\u662f\u56e0\u4e3a $A$ \u5f88\u5c0f\uff08$5\\times 10^4$\uff09\uff0c\u6240\u4ee5\u5f00\u7684\u4e0b\u3002\n\n\u5982\u679c\u4f60\u662f\u7a7a\u95f4\u5927\u5c0f\u7684\u72c2\u70ed\u8ffd\u6c42\u8005\u7684\u8bdd\uff0c\u6211\u4eec\u8fd8\u6709\u4e00\u79cd\u4f18\u5316\u81f3 $O(A)$ \u7684\u65b9\u6cd5\uff0c\u5373\u56e0\u4e3a\u4f17\u6570\u4e2a\u6570\u53d8\u5316\u5e45\u5ea6\u4e00\u6b21\u53ea\u6709 $\\pm1$\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 ```std::vector<int>``` \u6765\u7ef4\u62a4\u6876\uff0c\u6bcf\u6b21\u5728\u7ed3\u5c3e ```pop``` \u6216 ```push``` \u5373\u53ef\u3002\u56e0\u4e3a\u6240\u6709\u201c\u5c0f\u518c\u5b50\u201d\u7684\u603b\u957f\u53ea\u6709 $5\\times10^4$\uff0c\u6240\u4ee5\u8be5\u65b9\u6cd5\u7a7a\u95f4\u6d88\u8017\u5373\u4e3a $5\\times 10^4$\uff0c\u5373 $O(A)$\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=600100;\nint A,B,id[N];\nstruct Node{\n\tint id,val;\n\tNode(int x=0x3f3f3f3f,int y=0){id=x,val=y;}\n\tfriend bool operator <(const Node &x,const Node &y){\n\t\treturn x.val!=y.val?x.val<y.val:x.id>y.id;\n\t}\n}res[N];\nnamespace Suffix_Array{\n\tint x[N],y[N],buc[N],sa[N],ht[N],rk[N],s[N],n,m,LG[N],mn[N][20];\n\tchar str[N];\n\tbool mat(int a,int b,int k){\n\t\tif(y[a]!=y[b])return false;\n\t\tif((a+k<n)^(b+k<n))return false;\n\t\tif((a+k<n)&&(b+k<n))return y[a+k]==y[b+k];\n\t\treturn true;\n\t}\n\tvoid SA(){\n\t\tfor(int i=0;i<n;i++)buc[x[i]=s[i]]++;\n\t\tfor(int i=1;i<=m;i++)buc[i]+=buc[i-1];\n\t\tfor(int i=n-1;i>=0;i--)sa[--buc[x[i]]]=i;\n\t\tfor(int k=1;k<n;k<<=1){\n\t\t\tint num=0;\n\t\t\tfor(int i=n-k;i<n;i++)y[num++]=i;\n\t\t\tfor(int i=0;i<n;i++)if(sa[i]>=k)y[num++]=sa[i]-k;\n\t\t\tfor(int i=0;i<=m;i++)buc[i]=0;\n\t\t\tfor(int i=0;i<n;i++)buc[x[y[i]]]++;\n\t\t\tfor(int i=1;i<=m;i++)buc[i]+=buc[i-1];\n\t\t\tfor(int i=n-1;i>=0;i--)sa[--buc[x[y[i]]]]=y[i];\n\t\t\tswap(x,y);\n\t\t\tx[sa[0]]=num=0;\n\t\t\tfor(int i=1;i<n;i++)x[sa[i]]=mat(sa[i],sa[i-1],k)?num:++num;\n\t\t\tif(num>=n-1)break;\n\t\t\tm=num;\n\t\t}\n\t\tfor(int i=0;i<n;i++)rk[sa[i]]=i;\n\t\tfor(int i=0,k=0;i<n;i++){\n\t\t\tif(!rk[i])continue;\n\t\t\tif(k)k--;\n\t\t\tint j=sa[rk[i]-1];\n\t\t\twhile(i+k<n&&j+k<n&&s[i+k]==s[j+k])k++;\n\t\t\tht[rk[i]]=k;\n\t\t}\n\t\tfor(int i=2;i<N;i++)LG[i]=LG[i>>1]+1;\n\t\tfor(int i=1;i<N;i++)mn[i][0]=ht[i];\n\t\tfor(int j=1;j<=LG[N-1];j++)for(int i=1;i+(1<<j)-1<N;i++)mn[i][j]=min(mn[i][j-1],mn[i+(1<<(j-1))][j-1]);\n\t}\n\tint LCP(int x,int y){\n\t\tif(x>y)swap(x,y);\n\t\tx++;\n\t\tint k=LG[y-x+1];\n\t\treturn min(mn[x][k],mn[y-(1<<k)+1][k]);\n\t}\n\tvoid Range(int x,int k,int &L,int &R){\n\t\tint l,r;\n\t\tx=rk[x];\n\t\tl=0,r=x;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(LCP(mid,x)>=k)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tL=r;\n\t\tl=x,r=n-1;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r+1)>>1;\n\t\t\tif(LCP(mid,x)>=k)l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\tR=l;\n\t}\n}\nusing namespace Suffix_Array;\nconst int BBB=800;\nconst int CCC=300;\nint BLK[50100],lp[50100];\nstruct Query{\n\tint l,r,ql,qr,id;\n\tfriend bool operator <(const Query &x,const Query &y){\n\t\tif(x.r/BBB!=y.r/BBB)return x.r<y.r;\n\t\treturn (x.r/BBB)&1?x.l<y.l:x.l>y.l;\n\t}\n}q[500100];\nint cnt[50100],occ[200][50100],lim[200];\nvoid Push(int x){\n\tx=id[sa[x]];\n\tif(x==-1)return;\n\tocc[BLK[x]][cnt[x]]--;\n\tcnt[x]++;\n\tocc[BLK[x]][cnt[x]]++;\n\tlim[BLK[x]]=max(lim[BLK[x]],cnt[x]);\n}\nvoid Pop(int x){\n\tx=id[sa[x]];\n\tif(x==-1)return;\n\tocc[BLK[x]][cnt[x]]--;\n\tcnt[x]--;\n\tocc[BLK[x]][cnt[x]]++;\n\tif(!occ[BLK[x]][lim[BLK[x]]])lim[BLK[x]]--;\n}\nvoid Ask(int l,int r,Node &ans){\n\tr++;\n\tif(BLK[l]==BLK[r]){for(int i=l;i<r;i++)ans=max(ans,Node(i,cnt[i]));return;}\n\tint pos=BLK[A];\n\tfor(int i=BLK[l]+1;i<BLK[r];i++)if(lim[i]>lim[pos])pos=i;\n\tif(pos!=BLK[A])for(int i=lp[pos];i<lp[pos+1];i++)ans=max(ans,Node(i,cnt[i]));\n\tfor(int i=l;i<lp[BLK[l]+1];i++)ans=max(ans,Node(i,cnt[i]));\n\tfor(int i=lp[BLK[r]];i<r;i++)ans=max(ans,Node(i,cnt[i]));\n}\nint main(){\n\tscanf(\"%s\",str),m=strlen(str);for(int i=0;i<m;i++)s[n]=str[i]-'a'+1,id[n]=-1,n++;\n\tscanf(\"%d\",&A);\n\tfor(int i=0;i<A;i++){\n\t\ts[n]=i+26,id[n]=-1,n++;\n\t\tscanf(\"%s\",str),m=strlen(str);\n\t\tfor(int j=0;j<m;j++)s[n]=str[j]-'a'+1,id[n]=i,n++;\n\t}\n//\tfor(int i=0;i<n;i++)printf(\"%d \",s[i]);puts(\"\");\n\tm=A+26;\n\tSA();\n\tscanf(\"%d\",&m);\n\tfor(int i=1,a,b,c,d;i<=m;i++){\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tRange(c-1,d-c+1,q[i].l,q[i].r);\n\t\tq[i].ql=a-1,q[i].qr=b-1;\n\t\tq[i].id=i;\n\t}\n\tfor(int i=0;i<A;i++)BLK[i]=i/CCC;\n\tfor(int i=0;i<=BLK[A-1];i++)lp[i]=i*CCC;\n\tBLK[A]=BLK[A-1]+1;\n\tlp[BLK[A]]=A;\n\tsort(q+1,q+m+1);\n\tPush(0);\n\tfor(int i=1,L=0,R=0;i<=m;i++){\n\t\twhile(L>q[i].l)Push(--L);\n\t\twhile(R<q[i].r)Push(++R);\n\t\twhile(L<q[i].l)Pop(L++);\n\t\twhile(R>q[i].r)Pop(R--);\n\t\tAsk(q[i].ql,q[i].qr,res[q[i].id]);\n\t}\n\tfor(int i=1;i<=m;i++)printf(\"%d %d\\n\",res[i].id+1,res[i].val);\n\treturn 0;\n}\n```\n",
        "postTime": 1596763117,
        "uid": 123369,
        "name": "xtx1092515503",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "## CF666E\n\n\u9898\u610f\uff1a\u7ed9\u5b9a\u4e32$S$\u4e0e$m$\u4e2a\u5b57\u7b26\u4e32$T_i$.$Q$\u6b21\u8be2\u95ee$S[pl,pr]$\u5728$T_{l...r}$\u4e2d\u7684\u6700\u591a\u51fa\u73b0\u6b21\u6570\u4e0e\u5176\u4f4d\u7f6e\uff08\u591a\u89e3\u8f93\u51fa\u7f16\u53f7\u6700\u5c0f\u7684\uff09\n\n$|S|,Q\\le 5\\times 10^5;m\\le \\sum|T_i|\\le 5\\times 10^4$\n\n\u89e3\uff1a\n\n\u5efa\u5e7f\u4e49SAM\uff0c\u4f9d\u6b21\u63d2\u5165$T_i$.\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\uff0c\u627e\u5230\u5305\u542b$S[pl,pr]$\u4e14$len$\u6700\u5c0f\u7684\u8282\u70b9\u3002\u4e00\u79cd\u65b9\u6cd5\u5982\u4e0b\uff1a\n\n\u200b\t\t\u5728\u5e7f\u4e49SAM\u4e0a\u5339\u914d$S$,\u8bb0\u5f55$[1,i]$\u8fd9\u4e2a\u524d\u7f00\u80fd\u5339\u914d\u7684\u6700\u540e\u540e\u7f00$mxl_i$\u4e0e\u5bf9\u5e94\u8282\u70b9$ed_i$.\u627e\u5305\u542b$S[pl,pr]$\u4e14$len$\u6700\u5c0f\u7684\u8282\u70b9\u65f6\uff0c\u4ece$ed_{pr}$\u5f00\u59cb\u5f80\u4e0a\u500d\u589e\u5373\u53ef\u3002\uff08\u6ce8\u610f\u5224\u65ad$mxl<pr-pl+1$\u7684\u60c5\u51b5\uff09\n\n\u8bb0\u8be5\u8282\u70b9\u4e3a$pos$.\u5219\u8be5\u8282\u70b9\u4ee3\u8868\u7684\u5b50\u4e32\u5728$T_{l...r}$\u4e2d\u7684\u6700\u591a\u51fa\u73b0\u6b21\u6570\u5373\u4e3a\u7b54\u6848\u3002\u5c06\u8be2\u95ee\u79bb\u7ebf\uff0c\u5e7f\u4e49SAM\u4e0a\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e00\u4e2avector,\u5728$pos$\u5904\u63d2\u5165\u8be5\u8be2\u95ee\uff0c\u6700\u540e\u5728\u5e7f\u4e49sam\u4e0a\u8dd1\u4e00\u6b21\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u5373\u53ef\u56de\u7b54\u6240\u6709\u8be2\u95ee\u3002\n\n\u590d\u6742\u5ea6\u5206\u6790\uff1a\u8bb0$L=\\sum|T_i|$.\u5efa\u5e7f\u4e49SAM\uff0c\u5339\u914d$S$\u7684\u590d\u6742\u5ea6\u4e0e\u8dd1\u7ebf\u6bb5\u6811\u5408\u5e76\u7684\u65f6\u7a7a\u590d\u6742\u5ea6\u4e3a$\\mathcal O(|S|+L\\log L)$\n\n\u500d\u589e\u6c42$pos$\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f$\\mathcal O((Q+L)\\log L)$,\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a$\\mathcal O(L\\log L)$\n\n```cpp\n#define MAXN 200011//\u8fd9\u91ccMAXN\u662fL\u7684\u6700\u5927\u503c*2\n#define MAXL 500011//\u8fd9\u91cc\u7684MAXL\u662f|S|,Q\u7684\u6700\u5927\u503c\nstruct node\n{\n\tint lson,rson;\n\tint val,pos;\n\tnode(){}\n\tnode(int _val,int _pos){val=_val,pos=_pos,lson=rson=0;}\n}t[MAXN*22+1];//\u5176\u5b9e\u8fd8\u53ef\u4ee5\u66f4\u5c0f\uff0c\u53ea\u8981L log L\u5c31\u597d\n#define rt t[num]\npii max(pii a,pii b)\n{\n\treturn a.first>b.first||(a.first==b.first&&a.second<b.second)?a:b;\n}\nvoid pushup(int num)\n{\n\tif(t[rt.lson].val>t[rt.rson].val||(t[rt.lson].val==t[rt.rson].val&&t[rt.lson].pos<t[rt.rson].pos))\n\t\trt.val=t[rt.lson].val,rt.pos=t[rt.lson].pos;\n\telse rt.val=t[rt.rson].val,rt.pos=t[rt.rson].pos;\n}\nint root[MAXN],cnt=0;\nvoid insert(int& num,int pos,un l=1,un r=50000)\n{\n\tif(!num)num=++cnt;\n\tif(l==r){++rt.val,rt.pos=l;return;}\n\tun mid=(l+r)>>1;\n\tif(pos<=mid)insert(rt.lson,pos,l,mid);\n\telse insert(rt.rson,pos,mid+1,r);\n\tpushup(num);\n\t//printf(\"mxval[%d]=%d\\n\",num,rt.val);\n}\npii query(int num,un ql,un qr,un l=1,un r=50000)\n{\n\tif(!num)return pii(0,0);\n\tif(ql<=l&&r<=qr)return pii(rt.val,rt.pos);\n\tun mid=(l+r)>>1;pii res(0,0);\n\tif(ql<=mid)res=max(res,query(rt.lson,ql,qr,l,mid));\n\tif(qr>mid)res=max(res,query(rt.rson,ql,qr,mid+1,r));\n\treturn res;\n}\nint merge(int num,int p,un l=1,un r=50000)\n{\n    if(!num||!p)return num|p;\n    if(l==r){rt.val+=t[p].val;return num;}\n    un mid=(l+r)>>1;\n    rt.lson=merge(rt.lson,t[p].lson,l,mid);\n    rt.rson=merge(rt.rson,t[p].rson,mid+1,r);\n    pushup(num);\n    return num;\n}\nint ed[MAXL],mxl[MAXL],L[MAXL];\nchar ss[MAXL],st[MAXL];\nstruct one\n{\n    int l,r,dex;\n    //one(){}\n    one(int _l,int _r,int _dex){l=_l,r=_r,dex=_dex;}\n};\nstd::vector<one>q[MAXL];\npii ans[MAXL];\nstruct SAM\n{\n\tint t[MAXN][26],pre[MAXN],len[MAXN];\n\tint tot,last,ecnt;\n\tSAM(){tot=last=1,ecnt=0;}\n\tvoid insert(int w)\n\t{\n\t\tif(t[last][w])\n\t\t{\n\t\t\tint nxt=t[last][w];\n\t\t\tif(len[nxt]==len[last]+1)last=nxt;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint tmp=++tot;\n\t\t\t\tlen[tmp]=len[last]+1;\n\t\t\t\tmemcpy(t[tmp],t[nxt],sizeof t[nxt]);\n\t\t\t\tpre[tmp]=pre[nxt],pre[nxt]=tmp;\n\t\t\t\twhile(last&&t[last][w]==nxt)t[last][w]=tmp,last=pre[last];\n\t\t\t\tlast=tmp;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tint pos=last,cur=++tot;\n\t\tlen[cur]=len[pos]+1,last=cur;\n\t\twhile(pos&&!t[pos][w])t[pos][w]=cur,pos=pre[pos];\n\t\tif(!pos){pre[cur]=1;return;}\n\t\tint nxt=t[pos][w];\n\t\tif(len[nxt]==len[pos]+1)pre[cur]=nxt;\n\t\telse\n\t\t{\n\t\t\tint tmp=++tot;\n\t\t\tlen[tmp]=len[pos]+1;\n\t\t\tmemcpy(t[tmp],t[nxt],sizeof t[nxt]);\n\t\t\tpre[tmp]=pre[nxt],pre[nxt]=pre[cur]=tmp;\n\t\t\twhile(pos&&t[pos][w]==nxt)t[pos][w]=tmp,pos=pre[pos];\n\t\t}\n\t}\n\tvoid match(char* s)\n\t{\n\t\tint n=strlen(s+1),u=1,nowlen=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t{\n\t\t\tint c=s[i]-'a';\n\t\t\twhile(u&&!t[u][c])u=pre[u],nowlen=len[u];\n\t\t\tif(t[u][c])++nowlen,u=t[u][c];\n\t\t\telse nowlen=0,u=1;\n\t\t\ted[i]=u,mxl[i]=nowlen;\n\t\t}\n\t}\n\tstruct edge{int v,nxt;}e[MAXN];\n\tint head[MAXN];\n\tvoid adde(int u,int v){e[++ecnt].v=v,e[ecnt].nxt=head[u],head[u]=ecnt;}\n\tint fa[18][MAXN];\n\tvoid dfs(int u)\n\t{\n\t\tfa[0][u]=pre[u];\n\t\tfor(int i=1;i<18;++i)fa[i][u]=fa[i-1][fa[i-1][u]];\n\t\tfor(int i=head[u];i;i=e[i].nxt)dfs(e[i].v);\n\t}\n\tvoid build()\n\t{\n\t\tfor(int i=2;i<=tot;++i)adde(pre[i],i);\n\t\tdfs(1);\n\t}\n\tint get_pos(int dex,int l)\n\t{\n\t\tif(mxl[dex]<l)return -1;\n\t\tint u=ed[dex];\n\t\tfor(int i=17;i>=0;--i)\n\t\t\tif(fa[i][u]&& len[fa[i][u]]>=l)u=fa[i][u];\n\t\treturn u;\n\t}\n\tvoid solve(int u)\n\t{\n\t\tfa[0][u]=pre[u];\n\t\tfor(int i=1;i<18;++i)fa[i][u]=fa[i-1][fa[i-1][u]];\n\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t{\n\t\t\tsolve(e[i].v);\n\t\t\troot[u]=merge(root[u],root[e[i].v]);\n\t\t}\n        for(one x:q[u])ans[x.dex]=query(root[u],x.l,x.r);\n\t}\n}sam;\nint len[MAXN];\nint main()\n{\n\tscanf(\"%s\",ss+1);\n\tint n=strlen(ss+1),m=read();\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tscanf(\"%s\",st+len[i-1]);\n\t\tlen[i]=len[i-1]+strlen(st+len[i-1]);\n\t\tsam.last=1;\n\t\tfor(int j=len[i-1];j<len[i];++j)sam.insert(st[j]-'a');\n\t}\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tint u=1;\n\t\tfor(int j=len[i-1];j<len[i];++j)u=sam.t[u][st[j]-'a'],insert(root[u],i);\n\t}\n    sam.match(ss),sam.build();\n\tint Q=read();\n\tfor(int i=1;i<=Q;++i)\n\t{\n\t\tint l=read(),r=read(),pl=read(),pr=read();\n        L[i]=l;\n\t\tint u=sam.get_pos(pr,pr-pl+1);\n        if(u>0)q[u].push_back(one(l,r,i));\n\t}\n    sam.solve(1);\n    for(int i=1;i<=Q;++i)\n        if(ans[i].first)printf(\"%d %d\\n\",ans[i].second,ans[i].first);\n        else printf(\"%d 0\\n\",L[i]);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1596374211,
        "uid": 73142,
        "name": "\u4e07\u5f18",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "\u8003\u8651\u7ed9 $T$ \u5efa\u4e00\u4e2a\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\u3002\u6211\u4eec\u8003\u8651\u7ed9 $T[i]$ \u7684\u6240\u6709\u8282\u70b9\u5168\u90e8\u6253\u4e0a $i$ \u7684\u6807\u8bb0\u540e\uff0c\u8003\u8651\u4e00\u6b21\u8be2\u95ee\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u500d\u589e\u786e\u5b9a $s[p_l\\dots p_r]$ \u6240\u5728\u7684\u8282\u70b9 $u$ \uff0c\u4e8e\u662f\u5c31\u662f\u6c42 $u$ \u5b50\u6811\u5185\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u6807\u8bb0\u662f\u8c01\u3002\n\n\u8003\u8651\u6bcf\u4e2a\u70b9\u5f00\u4e2a\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff0c\u7ed9 $T[i]$ \u6240\u5728\u7684\u8282\u70b9\u628a $i$ \u8fd9\u4e2a\u4f4d\u7f6e\u52a0\u4e00\uff0c\u79bb\u7ebf\u8be2\u95ee\uff0c\u7136\u540e\u76f4\u63a5 `dfs` \u7684\u65f6\u5019\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u5728\u6bcf\u4e2a\u70b9\u4e0a\u8be2\u95ee\u533a\u95f4\u5185\u6700\u5927\u503c\u5373\u53ef\u3002\n\n```cpp\n#include \"iostream\"\n#include \"algorithm\"\n#include \"cstring\"\n#include \"cstdio\"\n#include \"cmath\"\n#include \"vector\"\n#include \"map\"\n#include \"set\"\n#include \"queue\"\nusing namespace std;\n#define MAXN 2000006\n//#define int long long\n#define rep(i, a, b) for (int i = (a), i##end = (b); i <= i##end; ++i)\n#define per(i, a, b) for (int i = (a), i##end = (b); i >= i##end; --i)\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define all(x) (x).begin() , (x).end()\n#define mem( a ) memset( a , 0 , sizeof a )\ntypedef long long ll;\nint n , m , q;\nint A[MAXN];\n\nvi G[MAXN];\nvoid ade( int u , int v ) {\n//\tprintf(\"%d %d\\n\",u,v);\n\tG[u].pb( v );\n}\n\nstruct SAM {\n\tint son[MAXN][26] , par[MAXN] , len[MAXN];\n\tint lst , cnt;\n\tvoid init( ) { lst = cnt = 1; }\n\tvoid addall( ) {\n\t\trep( i , 2 , cnt ) ade( par[i] , i ); \n\t}\n\tvoid ins( int x ) {\n        int cur = ++ cnt;\n        len[cur] = len[lst] + 1;\n        int p = lst;\n        while( p && !son[p][x] ) son[p][x] = cur , p = par[p];\n        if( !p ) par[cur] = 1;\n        else {\n            int q = son[p][x];\n            if( len[q] == len[p] + 1 ) par[cur] = q;\n            else {\n                int ct = ++ cnt;\n                len[ct] = len[p] + 1 , par[ct] = par[q];\n                memcpy( son[ct] , son[q] , sizeof son[q] );\n                par[q] = par[cur] = ct;\n                for( ; son[p][x] == q ; p = par[p] ) son[p][x] = ct;\n            }\n        }\n        lst = cur;\n    }\n} S ;\n\nchar s[MAXN] , ch[MAXN];\nint brk[MAXN];\nint en[MAXN];\n\npii T[MAXN << 2];\nint ls[MAXN << 2] , rs[MAXN << 2] , cnt , rt[MAXN];\nvoid pu( int rt ) {\n\tT[rt] = max( T[ls[rt]] , T[rs[rt]] );\n}\nvoid add( int& rt , int l , int r , int p , int c ) {\n//\tif( l == 1 && r == m ) printf(\"%d %d\\n\",p,c);\n\tif( !rt ) rt = ++ cnt;\n\tif( l == r ) { T[rt] = mp( T[rt].fi + c , -l ); return; }\n\tint m = l + r >> 1;\n\tif( p <= m ) add( ls[rt] , l , m , p , c );\n\telse add( rs[rt] , m + 1 , r , p , c );\n\tpu( rt );\n}\nint merge( int u , int v , int l , int r ) {\n\tif( !u || !v ) return u ^ v;\n\tint cur = ++ cnt;\n\tif( l == r ) {\n\t\tT[cur] = T[u];\n\t\tT[cur].fi += T[v].fi;\n\t\treturn cur;\n\t}\n\tint m = l + r >> 1;\n\tls[cur] = merge( ls[u] , ls[v] , l , m ) , rs[cur] = merge( rs[u] , rs[v] , m + 1 , r );\n\tT[cur] = max( T[ls[cur]] , T[rs[cur]] );\n\treturn cur;\n}\npii que( int rt , int l , int r , int L , int R ) {\n\tif( !rt ) return pii( 0 , 0 );\n\tif( L <= l && R >= r ) return T[rt];\n\tint m = l + r >> 1; pii ret(0,0);\n\tif( L <= m ) ret = max( ret , que( ls[rt] , l , m , L , R ) );\n\tif( R > m ) ret = max( ret , que( rs[rt] , m + 1 , r , L , R ) );\n\treturn ret;\n}\n\nstruct poi {\n\tint l , r , idx;\n};\nvector<poi> Q[MAXN];\npii ans[MAXN];\nvoid dfs( int u ) {\n\tfor( int& v : G[u] ) {\n\t\tdfs( v );\n\t\trt[u] = merge( rt[u] , rt[v] , 1 , m );\n\t}\n\tfor( auto& t : Q[u] ) \n\t\tans[t.idx] = que( rt[u] , 1 , m , t.l , t.r );\n}\n\nint g[MAXN][20];\nvoid afs( int u ) {\n\tfor( int& v : G[u] ) {\n\t\tg[v][0] = u;\n\t\trep( k , 1 , 19 ) if( g[g[v][k - 1]][k - 1] ) g[v][k] = g[g[v][k - 1]][k - 1]; else break;\n\t\tafs( v );\n\t}\n}\nint getit( int u , int l ) {\n\tfor( int k = 19 ; k >= 0 ; -- k ) \n\t\tif( S.len[g[u][k]] >= l ) u = g[u][k];\n\treturn u;\n}\n\nint lll[MAXN];\nvoid solve() {\n\tS.init();\n\tscanf(\"%s\",s + 1);\n\tn = strlen( s + 1 );\n\trep( i , 1 , n ) S.ins( s[i] - 'a' );\n\tcin >> m;\n\tint len;\n\tbrk[0] = 1;\n\trep( i , 1 , m ) {\n\t\tscanf(\"%s\",ch + brk[i - 1]);\n\t\tlen = strlen( ch + brk[i - 1] );\n\t\tbrk[i] = brk[i - 1] + len;\n\t\tS.lst = 1;\n\t\trep( j , brk[i - 1] , brk[i - 1] + len - 1 ) \n\t\t\tS.ins( ch[j] - 'a' );\n\t}\n\tint cur = 1;\n\trep( i , 1 , n ) \n\t\tcur = S.son[cur][s[i] - 'a'] , en[i] = cur;\n\trep( i , 1 , m ) {\n\t\tcur = 1;\n\t\trep( j , brk[i - 1] , brk[i] - 1 ) \n\t\t\tcur = S.son[cur][ch[j] - 'a'] , add( rt[cur] , 1 , m , i , 1 );\n\t}\n\tcin >> q;\n\tint l , r , L , R , u;\n\tS.addall( );\n\tafs( 1 );\n\trep( i , 1 , q ) {\n\t\tscanf(\"%d%d%d%d\",&l,&r,&L,&R); lll[i] = l;\n\t\tu = getit( en[R] , R - L + 1 );\n\t\tQ[u].eb( (poi) { l , r , i } );\n\t}\n\tdfs( 1 );\n\trep( i , 1 , q ) {\n\t\tif( !ans[i].se ) printf(\"%d %d\\n\",lll[i] , 0);\n\t\telse printf(\"%d %d\\n\",-ans[i].se , ans[i].fi);\n\t}\n//\tcout << S.len[87] << endl;\n//\tcout << S.son[52]['e' - 'a'] << endl;\n}\n\nsigned main() {\n//    int T;cin >> T;while( T-- ) solve();\n    solve();\n    return 0;\n}\n\n\n```\n\n",
        "postTime": 1587969153,
        "uid": 63398,
        "name": "yijan",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "~~\u9898\u53f7\u597d\u8bc4~~\n\n**description**\n\n\u7ed9\u4e00\u4e2a\u4e32 $s$ \u548c $m$ \u4e2a\u4e32 $t_i$\uff0c\u6bcf\u6b21\u8be2\u95ee $l,r,pl,pr$ \u6c42 $s[pl\\cdots pr]$ \u5728 $t_l\\sim t_r$ \u4e2d\u7684\u54ea\u4e2a\u51fa\u73b0\u7684\u6700\u591a\uff0c\u5e76\u6c42\u51fa\u73b0\u6b21\u6570\n\n$|s|\\leq 5\\times 10^5,m\\leq 5\\times 10^4,\\sum|t_i|\\leq 5\\times 10^4,q\\leq 5\\times 10^5$\n\n**solution**\n\nSAM+\u7ebf\u6bb5\u6811\u5408\u5e76\n\n\u9996\u5148\u5bf9\u4e8e\u6240\u6709\u7684 $t_i$ \u5efa\u51fa\u4e00\u68f5\u5e7f\u4e49SAM\n\n\u6211\u4eec\u77e5\u9053\uff0c\u5bf9\u4e8e SAM \u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9\uff0c\u4ed6\u7684 parent tree \u7684\u5b50\u6811\u91cc\u9762\u7684\u6240\u6709\u4e3b\u4e32\u4e0a\u7684\u70b9\u7684\u4e2a\u6570\u5c31\u662f\u8fd9\u4e2a\u70b9\u5bf9\u5e94\u7684\u72b6\u6001\u7684\u51fa\u73b0\u6b21\u6570\uff0c\u5373\u6240\u8c13\u7684 right \u6570\u7ec4\n\n\u540c\u6837\u7684\uff0c\u5bf9\u4e8e\u5e7f\u4e49 SAM \u4e0a\u7684\u6bcf\u4e00\u4e2a\u70b9\uff0c\u6211\u4eec\u7528\u4e00\u68f5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u8fd9\u4e2a\u5b50\u6811\u4e2d\u6bcf\u4e2a\u4e0d\u540c\u7684\u4e32\u7684\u70b9\u6570\uff0c\u5229\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u77e5\u9053\u8fd9\u4e2a\u72b6\u6001\u5728\u4efb\u610f\u7684 $t_l\\sim t_r$ \u7684\u51fa\u73b0\u6b21\u6570\u3002\n\n\u4f46\u662f SAM \u4e0a\u6bcf\u4e00\u4e2a\u72b6\u6001\u786e\u5b9a\u7684\u662f $s$ \u4e0a\u7684\u4e00\u4e2a\u5b50\u4e32\uff0c\u5982\u4f55\u786e\u5b9a $s[pl\\cdots pr]$ \u5bf9\u5e94\u7684\u70b9\u5462\uff1f\n \n\u6211\u4eec\u9996\u5148\u53ef\u4ee5\u5bf9\u4e8e $s[1\\cdots i]$ \u786e\u5b9a\u6bcf\u4e2a\u70b9\u7684\u5339\u914d\u4f4d\u7f6e\u548c\u5339\u914d\u957f\u5ea6\uff0c\u4e5f\u5c31\u662f [SP1811 LCS - Longest Common Substring](https://www.luogu.com.cn/problem/SP1811)\n\n\u5f53\u8be2\u95ee $s[pl\\cdots pr]$ \u65f6\uff0c\u5148\u627e\u5230 $s[1\\cdots pr]$ \u7684\u5339\u914d\u4f4d\u7f6e\uff0c\u7136\u540e\u4ece\u8fd9\u4e2a\u70b9\u5728 parent tree \u4e0a\u500d\u589e\uff0c\u627e\u5230\u6700\u9760\u4e0a\u7684 $maxlen\\leq pr-pl+1$ \u7684\u70b9\uff0c\u8fd9\u4e2a\u70b9\u5c31\u5305\u542b\u4e86 $s[pl\\cdots pr]$ \u7684\u5168\u90e8\u51fa\u73b0\u60c5\u51b5\uff0c\u5728\u8fd9\u4e2a\u70b9\u7684\u7ebf\u6bb5\u6811\u4e0a\u8fdb\u884c\u533a\u95f4\u67e5\u8be2\u5c31\u53ef\u4ee5\u4e86\n\n\u590d\u6742\u5ea6 $\\mathcal O(|s|+\\sum |t|\\log \\sum |t|)$\n\n\u6ce8\u610f\u4e00\u4e9b\u7ec6\u8282\uff1a\n\n- \u5f53 $t_l\\sim t_r$ \u4e2d\u4e0d\u5b58\u5728 $s[pl\\cdots pr]$ \u65f6\uff0c\u5e94\u5f53\u8f93\u51fa `l 0`\n\n- \u5982\u679c $s[1\\cdots pr]$ \u7684\u5339\u914d\u957f\u5ea6\u5c0f\u4e8e $pr-pl+1$ \u65f6\uff0c\u4e5f\u5e94\u8be5\u7b97\u4f5c\u4e0d\u5b58\u5728\n\n**code**\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n# define Rep(i,a,b) for(int i=a;i<=b;i++)\n# define _Rep(i,a,b) for(int i=a;i>=b;i--)\n# define RepG(i,u) for(int i=head[u];~i;i=e[i].next)\n\ntypedef long long ll;\n\nconst int N=5e5+5;\n\ntemplate<typename T> void read(T &x){\n   x=0;int f=1;\n   char c=getchar();\n   for(;!isdigit(c);c=getchar())if(c=='-')f=-1;\n   for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+c-'0';\n    x*=f;\n}\n\nint n,m,q;\nchar s[N],t[N];\nint link[N<<1],sam[N<<1][26],maxlen[N<<1];\nint inde[N<<1],tpx[N<<1],topoxu;\nint f[N<<1][21];\nint p[N],l[N];\nint samtot=1,lst;\nvector<int> T[N<<1];\n\nstruct texas{\n\tint lc,rc;\n\tint max,pos;\t\n}seg[N*2*20];\n\nint root[N<<1],segtot;\n\nvoid insert(int x,int id){\n\tif(sam[lst][x]){\n\t\tint p=lst,q=sam[lst][x];\n\t\tif(maxlen[q]==maxlen[p]+1){\n\t\t\tlst=q;\n\t\t\tT[q].push_back(id);\t\n\t\t}\n\t\telse{\n\t\t\tint clone=++samtot;\n\t\t\tmaxlen[clone]=maxlen[p]+1;\n\t\t\tlink[clone]=link[q];\n\t\t\tT[clone].push_back(id);\n\t\t\tmemcpy(sam[clone],sam[q],sizeof(sam[q]));\n\t\t\tfor(;p&&sam[p][x]==q;p=link[p])sam[p][x]=clone;\n\t\t\tlink[q]=clone;\n\t\t\tlst=clone;\t\n\t\t}\n\t\treturn;\n\t}\n\tint now=++samtot,p;\n\tmaxlen[now]=maxlen[lst]+1;\n\tT[now].push_back(id);\n\tfor(p=lst;p&&!sam[p][x];p=link[p])sam[p][x]=now;\n\tif(!p)link[now]=1;\n\telse{\n\t\tint q=sam[p][x];\n\t\tif(maxlen[q]==maxlen[p]+1)link[now]=q;\n\t\telse{\n\t\t\tint clone=++samtot;\n\t\t\tmaxlen[clone]=maxlen[p]+1;\n\t\t\tlink[clone]=link[q];\n\t\t\tmemcpy(sam[clone],sam[q],sizeof(sam[q]));\n\t\t\tfor(;p&&sam[p][x]==q;p=link[p])sam[p][x]=clone;\n\t\t\tlink[now]=link[q]=clone;\n\t\t}\n\t}\n\tlst=now;\n}\n\nvoid pushup(int u){\n\tif(seg[seg[u].lc].max>=seg[seg[u].rc].max)seg[u].max=seg[seg[u].lc].max,seg[u].pos=seg[seg[u].lc].pos;\n\telse seg[u].max=seg[seg[u].rc].max,seg[u].pos=seg[seg[u].rc].pos;\t\n}\n\nvoid update(int &u,int l,int r,int x,int k){\n\tif(!u)u=++segtot;\n\tif(l==r){\n\t\tseg[u].max+=k;\n\t\tseg[u].pos=l;\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tif(x<=mid)update(seg[u].lc,l,mid,x,k);\n\telse update(seg[u].rc,mid+1,r,x,k);\n\tpushup(u);\n}\n\nint merge(int u,int v,int l,int r){\n\tif(!u||!v)return u|v;\n\tint o=++segtot;\n\tif(l==r){\n\t\tseg[o].max=seg[u].max+seg[v].max;\n\t\tseg[o].pos=l;\n\t\treturn o;\n\t}\n\tint mid=l+r>>1;\n\tseg[o].lc=merge(seg[u].lc,seg[v].lc,l,mid);\n\tseg[o].rc=merge(seg[u].rc,seg[v].rc,mid+1,r);\n\tpushup(o);\n\treturn o;\n}\n\ntexas query(int u,int l,int r,int ql,int qr){\n\tif(l>=ql&&r<=qr)return seg[u];\n\tint mid=l+r>>1;\n\tif(qr<=mid)return query(seg[u].lc,l,mid,ql,qr);\n\tif(ql>mid)return query(seg[u].rc,mid+1,r,ql,qr);\n\ttexas L=query(seg[u].lc,l,mid,ql,qr);\n\ttexas R=query(seg[u].rc,mid+1,r,ql,qr);\n\tif(L.max>=R.max)return L;\n\telse return R;\t\n}\n\nvoid topo(){\n\tqueue<int> q;\n\tRep(i,2,samtot)inde[link[i]]++;\n\tRep(i,1,samtot)if(!inde[i])q.push(i);\n\tRep(i,1,samtot)\n\t\tfor(int j=0;j<T[i].size();j++)\n\t\t\tupdate(root[i],1,m,T[i][j],1);\t\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\ttpx[++topoxu]=u;\n\t\tif(u==1)continue;\n\t\tint v=link[u];\n\t\troot[v]=merge(root[v],root[u],1,m);\n\t\tinde[v]--;\n\t\tif(!inde[v])q.push(v);\t\n\t} \n\t_Rep(i,samtot,1){\n\t\tint u=tpx[i];\n\t\tf[u][0]=link[u];\n\t\tRep(j,1,20)f[u][j]=f[f[u][j-1]][j-1];\t\n\t}\n}\n\nint main()\n{\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tread(m);\n\tRep(i,1,m){\n\t\tscanf(\"%s\",t+1);\n\t\tint len=strlen(t+1);\n\t\tlst=1;\n\t\tRep(j,1,len)insert(t[j]-'a',i); \n\t}\t\n\ttopo();\n\tp[0]=1,l[0]=0;\n\tRep(i,1,n){\n\t\tint x=s[i]-'a';\n\t\tif(sam[p[i-1]][x])p[i]=sam[p[i-1]][x],l[i]=l[i-1]+1;\n\t\telse{\n\t\t\tfor(p[i]=p[i-1];p[i]&&!sam[p[i]][x];p[i]=link[p[i]]);\n\t\t\tif(!p[i]){\n\t\t\t\tp[i]=1;\n\t\t\t\tl[i]=0;\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tl[i]=maxlen[p[i]]+1;\n\t\t\t\tp[i]=sam[p[i]][x];\t\n\t\t\t}\n\t\t}\n\t}\n\tread(q);\n\twhile(q--){\n\t\tint pl,pr,ql,qr;\n\t\tread(ql),read(qr),read(pl),read(pr);\n\t\tint x=p[pr];\n\t\tif(l[pr]<pr-pl+1){\n\t\t\tprintf(\"%d 0\\n\",ql);\n\t\t\tcontinue;\n\t\t}\n\t\t_Rep(i,20,0)\n\t\t\tif(maxlen[f[x][i]]>=pr-pl+1)x=f[x][i];\n\t\ttexas u=query(root[x],1,m,ql,qr);\n\t\tif(!u.max)printf(\"%d 0\\n\",ql);\n\t\telse printf(\"%d %d\\n\",u.pos,u.max);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1609039131,
        "uid": 97344,
        "name": "devout",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "\u8fd9\u9053\u9898\u53ef\u4ee5\u5148\u5bf9$T$\u5efa\u7acb\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a(\u4e5f\u53ef\u4ee5\u5c06$T$\u62fc\u6210\u4e00\u4e2a\u5927\u7684\u4e32\uff0c\u6bcf\u6b21$last$\u8bbe\u4e3a$1$)\uff0c\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5b50\u6811\u4e2d\u6bcf\u4e2a\u4e32\u7684\u51fa\u73b0\u6b21\u6570\u4ee5\u53ca\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u4e32\u3002\n\n\u8fdb\u884c\u7ebf\u6bb5\u6811\u5408\u5e76\u3002\n\n\u5bf9\u4e8e\u539f\u4e32$s$\uff0c\u53ef\u4ee5\u5728$T$\u7684\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\u4e0a\u8dd1\u4e00\u4e0b\uff0c\u627e\u5230\u6240\u6709\u4ee5$s_i$\u7ed3\u5c3e\u7684\u4e32\u7684\u4f4d\u7f6e\uff0c$ed_i$\u3002\n\n\u5bf9\u4e8e\u8be2\u95ee$l \\quad r$\u5148\u627e\u5230$ed_r$,\u518d\u5224\u65ad\u6700\u957f\u7684\u957f\u5ea6\u662f\u5426\u6ee1\u8db3\uff0c\u6ee1\u8db3\u540e\u5728\u500d\u589e\u627e\u5230\u76f8\u5e94\u4f4d\u7f6e\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(n\\log n)$\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define ll long long\n#define ull unsigned long long\nusing namespace std;\nconst int maxn=120005,maxm=5e5+5;\ninline int getint()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9')\n\t{\n\t\tif(ch=='-')f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9')\n\t{\n\t\tx=(x<<3)+(x<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn f?x:-x;\n}\nint fa[maxn][20],tot=1,last=1,rt[maxn],n,m,id[maxn],p[maxn],sz,pre[maxn],dep[maxn],len[maxn];\nstruct edge\n{\n\tint v,nxt;\n\tedge(){}\n\tedge(int vv,int nn){v=vv,nxt=nn;}\n}e[maxn];\nstruct SAM\n{\n\tint son[maxn][26];\n\tinline void insert(int c)\n\t{\n\t\tint np=++tot,p=last;\n\t\tlast=np,len[np]=len[p]+1;\n\t\twhile(p&&!son[p][c])son[p][c]=np,p=fa[p][0];\n\t\tif(!p)fa[np][0]=1;\n\t\telse\n\t\t{\n\t\t\tint q=son[p][c];\n\t\t\tif(len[q]==len[p]+1)fa[np][0]=q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nq=++tot;\n\t\t\t\tlen[nq]=len[p]+1;\n\t\t\t\tmemcpy(son[nq],son[q],sizeof(son[q]));\n\t\t\t\tfa[nq][0]=fa[q][0];\n\t\t\t\tfa[np][0]=fa[q][0]=nq;\n\t\t\t\twhile(p&&son[p][c]==q)son[p][c]=nq,p=fa[p][0];\n\t\t\t}\n\t\t}\n\t}\n}sam;\nstruct segmentree\n{\n\tint tot;\n\tint ls[maxn*20],rs[maxn*20],maxv[maxn*20],maxbh[maxn*20];\n\tinline void pushup(int u)\n\t{\n\t\tif(maxv[ls[u]]>maxv[rs[u]])\n\t\t{\n\t\t\tmaxv[u]=maxv[ls[u]];\n\t\t\tmaxbh[u]=maxbh[ls[u]];\n\t\t}\n\t\telse if(maxv[ls[u]]<maxv[rs[u]])\n\t\t{\n\t\t\tmaxv[u]=maxv[rs[u]];\n\t\t\tmaxbh[u]=maxbh[rs[u]];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmaxv[u]=maxv[ls[u]];\n\t\t\tmaxbh[u]=min(maxbh[ls[u]],maxbh[rs[u]]);\n\t\t}\n\t}\n\tinline void update(int &u,int l,int r,int x,int v)\n\t{\n\t\tif(!u)u=++tot;\n\t\tif(l==r)\n\t\t{\n\t\t\tmaxv[u]+=v;\n\t\t\tmaxbh[u]=l;\n\t\t\treturn ;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(x<=mid)update(ls[u],l,mid,x,v);\n\t\t\telse update(rs[u],mid+1,r,x,v);\n\t\t\tpushup(u);\n\t\t}\n\t}\n\tinline int merge(int x,int y,int l,int r)\n\t{\n\t\tif(!x||!y)return x+y;\n\t\tint u=++tot;\n\t\tif(l==r)\n\t\t{\n\t\t\tmaxv[u]=maxv[x]+maxv[y];\n\t\t\tmaxbh[u]=l;\n\t\t\treturn u;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tls[u]=merge(ls[x],ls[y],l,mid);\n\t\t\trs[u]=merge(rs[x],rs[y],mid+1,r);\n\t\t\tpushup(u);\n\t\t\treturn u;\n\t\t}\n\t}\n\tinline pair<int,int>query(int u,int l,int r,int x,int y)\n\t{\n\t\tif(!u)return pair<int,int>(0,0);\n\t\tif(x<=l&&y>=r)\n\t\t{\n\t\t\treturn pair<int,int>(maxv[u],maxbh[u]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint mid=(l+r)>>1;\n\t\t\tpair<int,int>ret=pair<int,int>(0,0);\n\t\t\tif(x<=mid)ret=query(ls[u],l,mid,x,y);\n\t\t\tif(y>mid)\n\t\t\t{\n\t\t\t\tpair<int,int>temp=query(rs[u],mid+1,r,x,y);\n\t\t\t\ttemp.second=-temp.second;\n\t\t\t\tret.second=-ret.second; \n\t\t\t\tret=max(ret,temp);\n\t\t\t\tret.second=-ret.second; \n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n}tree;\ninline void add(int u,int v)\n{\n\te[++sz]=edge(v,p[u]);\n\tp[u]=sz;\n}\ninline void dfs(int u)\n{\n\tdep[u]=dep[fa[u][0]]+1;\n\tfor(int i=1;i<=pre[dep[u]];++i)fa[u][i]=fa[fa[u][i-1]][i-1];\n\tfor(int i=p[u];i!=-1;i=e[i].nxt)\n\t{\n\t\tint v=e[i].v;\n\t\tdfs(v);\n\t\trt[u]=tree.merge(rt[u],rt[v],1,m);\n\t}\n}\ninline int beizeng(int u,int lens)\n{\n\tfor(int i=pre[dep[u]];i>=0;--i)\n\t{\n\t\tif(len[fa[u][i]]>=lens)u=fa[u][i];\n\t}\n\treturn u;\n}\nint q,ls,rs,l,r;\nchar s[maxm],t[maxm];\nint poss[maxm],maxl[maxm];\nint main()\n{\n\tmemset(p,-1,sizeof(p));\n\tscanf(\"%s\",s+1);\n\tfor(int i=2;i<=(int)(1e5);++i)pre[i]=pre[i>>1]+1;\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tlast=1;\n\t\tscanf(\"%s\",t+1);\n\t\tn=strlen(t+1);\n\t\tfor(int j=1;j<=n;++j)\n\t\t{\n\t\t\tsam.insert(t[j]-'a');\n\t\t\ttree.update(rt[last],1,m,i,1);\n\t\t}\n\t}\n\tfor(int i=2;i<=tot;++i)add(fa[i][0],i);\n\tdfs(1);\n\tn=strlen(s+1);\n\tint pos=1,nowlen=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint c=s[i]-'a';\n\t\twhile(pos&&!sam.son[pos][c]){pos=fa[pos][0];nowlen=len[pos];}\n\t\tif(sam.son[pos][c])\n\t\t{\n\t\t\tnowlen++;\n\t\t\tpos=sam.son[pos][c];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnowlen=0;\n\t\t\tpos=1;\n\t\t}\n\t\tposs[i]=pos;\n\t\tmaxl[i]=nowlen;\n\t}\n\tscanf(\"%d\",&q);\n\tfor(int i=1;i<=q;++i)\n\t{\n\t\tscanf(\"%d%d%d%d\",&l,&r,&ls,&rs);\n\t\tif(rs-ls+1>maxl[rs]){printf(\"%d 0\\n\",l);continue;}///\u786e\u5b9a\u6700\u957f\u7684\u957f\u5ea6<=maxl[rs] \n\t\tint now=beizeng(poss[rs],rs-ls+1);\n\t\tpair<int,int>ans=tree.query(rt[now],1,m,l,r);\n\t\tif(ans.first==0)printf(\"%d %d\\n\",l,0);\n\t\telse printf(\"%d %d\\n\",ans.second,ans.first);\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1588688125,
        "uid": 333789,
        "name": "lory1608",
        "ccfLevel": 9,
        "title": "\u9898\u89e3  CF666E \u3010Forensic Examination \u3011"
    },
    {
        "content": "\u5bf9\u6240\u6709\u7684T\u4e32\u5efa\u51fa\u5e7f\u4e49SAM\uff0c\u628a\u8be2\u95ee\u79bb\u7ebf\u4e0b\u6765\u6309pr\u6392\u5e8f\u5728S\u4e2d\u8dd1\u5339\u914d\u3002\u90a3\u4e48\u5b50\u4e32$[pl,pr]$\u4f1a\u5728SAM\u4e2d\u5339\u914d\u5230\u5b50\u4e32$[1,pr]$\u7684\u8282\u70b9\u3002\u6309$parent$\u6811\u7684\u5b9a\u4e49\uff0c\u5982\u679cSAM\u4e2d\u6709\u5b50\u4e32$[pl,pr]$\uff0c\u5b83\u4f1a\u5c5e\u4e8e\u5f53\u524d\u8282\u70b9\u7684\u4e00\u4e2a\u7956\u5148$fa$\uff0c\u6ee1\u8db3$len[fa]>=pr-pl+1$\u4e14\u6df1\u5ea6\u6700\u5c0f\u3002\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u500d\u589e\u627e\u5230$fa$\u3002\n\n\u73b0\u5728\u6211\u4eec\u77e5\u9053\u6bcf\u4e2a\u8be2\u95ee\u6240\u5bf9\u5e94\u7684\u8282\u70b9\u4e86\uff0c\u9700\u8981\u77e5\u9053\u4ed6\u5728\u6bcf\u4e2a\u4e32\u4e2d\u7684\u51fa\u73b0\u6b21\u6570\u3002\n\n\u90a3\u4e48\u6bcf\u4e2a\u8282\u70b9\u5f00\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u5b83\u51fa\u73b0\u6700\u591a\u7684\u7684\u4e32\u548c\u51fa\u73b0\u6b21\u6570\uff0c\u4e00\u5f00\u59cb\u53ea\u6709\u53f6\u5b50\u7684\u7ebf\u6bb5\u6811\u6709\u503c\uff0c\u6240\u4ee5\u8981\u628a\u53f6\u5b50\u7684\u7ebf\u6bb5\u6811\u5408\u5e76\u5230\u7236\u4eb2\u3002\n\n\u4ee5\u53ca\u8d85\u7ea7\u591a\u7684\u7ec6\u8282\uff0c\u6bd4\u5982\u8bf4\u6211\u73b0\u5728\u53c8\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u6309\u4e32\u957f\u4ece\u5927\u5230\u5c0f\u5408\u5e76\u5230\u7236\u4eb2\u4f1aWA\u3002\n\n```c++\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct SAM{\n\tint ch[26],fa,len;\n}t1[100001];\nstruct sgt{\n\tint ch[2],size,maxn;\n}t2[100001*40];\nstruct que{\n\tint pl,pr,l,r,h;\n}q[500001];\nstruct edge{\n\tint next,to;\n}w[100001];\nstruct node{int size,maxn;}ans[500001],e;\nint n,tot_s=1,root[100001],fa[100001][19],last,now;\nint m,tot_t,head[100001],cnt;\nchar ch[50001],s[500001];\ninline bool cmp(que c,que d){return c.pr<d.pr;}\ninline void add(int x,int y){\n\tw[++cnt].next=head[x];\n\tw[cnt].to=y; head[x]=cnt;\n}\ninline void pushup(int x){\n\tif (t2[t2[x].ch[0]].size>=t2[t2[x].ch[1]].size)\n\t\tt2[x].size=t2[t2[x].ch[0]].size,t2[x].maxn=t2[t2[x].ch[0]].maxn;\n\telse t2[x].size=t2[t2[x].ch[1]].size,t2[x].maxn=t2[t2[x].ch[1]].maxn;\n}\nint update(int rt,int l,int r,int x){\n\tif (!rt) rt=++tot_t;\n\tif (l==r){\n\t\tt2[rt].size++; t2[rt].maxn=x;\n\t\treturn rt;\n\t}\n\tint mid=(l+r)>>1;\n\tif (x<=mid) t2[rt].ch[0]=update(t2[rt].ch[0],l,mid,x);\n\telse t2[rt].ch[1]=update(t2[rt].ch[1],mid+1,r,x);\n\tpushup(rt);\n\treturn rt;\n}\nint merge(int c,int d,int l,int r){\n\tif (!c||!d) return c|d;\n\tint u=++tot_t;\n\tif (l==r){\n\t\tt2[u]=t2[c];\n\t\tt2[u].size+=t2[d].size;\n\t\treturn u;\n\t}\n\tint mid=(l+r)>>1;\n\tt2[u].ch[0]=merge(t2[c].ch[0],t2[d].ch[0],l,mid);\n\tt2[u].ch[1]=merge(t2[c].ch[1],t2[d].ch[1],mid+1,r);\n\tpushup(u); return u;\n}\nnode query(int rt,int l,int r,int x,int y){\n\tif (!rt) return e;\n\tnode v=e,u=e;\n\tif (x<=l&&r<=y){\n\t\tv.size=t2[rt].size,v.maxn=t2[rt].maxn;\n\t\treturn v;\n\t}\n\tint mid=(l+r)>>1;\n\tif (x<=mid) v=query(t2[rt].ch[0],l,mid,x,y);\n\tif (y>mid) u=query(t2[rt].ch[1],mid+1,r,x,y);\n\tif (u.size<=v.size) return v;\n\treturn u;\n}\nvoid dfs(int x){\n\tfor (int i=head[x]; i; i=w[i].next){\n\t\tfa[w[i].to][0]=x; dfs(w[i].to);\n\t\troot[x]=merge(root[x],root[w[i].to],1,n);\n\t}\n}\ninline void extend(int x){\n\tint np=++tot_s,p=last;\n\tlast=np; root[np]=update(root[np],1,n,now);\n\tt1[np].len=t1[p].len+1;\n\twhile (p&&!t1[p].ch[x]) t1[p].ch[x]=np,p=t1[p].fa;\n\tif (!p) t1[np].fa=1;\n\telse{\n\t\tint q=t1[p].ch[x];\n\t\tif (t1[q].len==t1[p].len+1) t1[np].fa=q;\n\t\telse{\n\t\t\tint cp=++tot_s; t1[cp]=t1[q];\n\t\t\tt1[cp].len=t1[p].len+1; t1[q].fa=t1[np].fa=cp;\n\t\t\twhile (p&&t1[p].ch[x]==q) t1[p].ch[x]=cp,p=t1[p].fa;\n\t\t}\n\t}\n}\nint main(){\n\tint len;\n\tscanf(\"%s\",s+1); scanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%s\",ch+1);\n\t\tlen=strlen(ch+1); last=1,now=i;\n\t\tfor (int j=1; j<=len; j++) extend(ch[j]-'a');\n\t}\n\tfor (int i=1; i<=tot_s; i++) add(t1[i].fa,i);\n\tdfs(1);\n\tfor (int i=1; i<=18; i++)\n\t\tfor (int j=1; j<=tot_s; j++)\n\t\t\tfa[j][i]=fa[fa[j][i-1]][i-1];\n\tscanf(\"%d\",&m);\n\tfor (int i=1; i<=m; i++)\n\t\tscanf(\"%d%d%d%d\",&q[i].l,&q[i].r,&q[i].pl,&q[i].pr),q[i].h=i;\n\tsort(q+1,q+m+1,cmp);\n\tint k=0,l=0,jp,u=1;\n\tfor (int i=1; i<=m; i++){\n\t\twhile (k<q[i].pr){\n\t\t\tk++;\n\t\t\tif (t1[u].ch[s[k]-'a']) u=t1[u].ch[s[k]-'a'],l++;\n\t\t\telse{\n\t\t\t\twhile (u&&!t1[u].ch[s[k]-'a']) u=t1[u].fa,l--;\n\t\t\t\tif (!u) u=1,l=0;\n\t\t\t\telse l=t1[u].len+1,u=t1[u].ch[s[k]-'a'];\n\t\t\t}\n\t\t}\n\t\tif (l<q[i].pr-q[i].pl+1){ans[q[i].h].maxn=q[i].l; continue;}\n\t\tjp=u;\n\t\tfor (int j=18; j>=0; j--)\n\t\t\tif (t1[fa[jp][j]].len>=q[i].pr-q[i].pl+1)\n\t\t\t\tjp=fa[jp][j];\n\t\tans[q[i].h]=query(root[jp],1,n,q[i].l,q[i].r);\n\t\tif (!ans[q[i].h].size) ans[q[i].h].maxn=q[i].l;\n\t}\n\tfor (int i=1; i<=m; i++) printf(\"%d %d\\n\",ans[i].maxn,ans[i].size);\n\treturn 0;\n}\n```\n",
        "postTime": 1556420255,
        "uid": 63661,
        "name": "Taduro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF666E \u3010Forensic Examination\u3011"
    },
    {
        "content": "> [\u9898\u9762\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/CF666E)\u3002\n\n> \u9898\u610f\u7b80\u8ff0\uff1a\u7ed9\u51fa\u5b57\u7b26\u4e32 $s$ \u4e0e $t_{1,2,\\cdots,m}$\uff0c$q$ \u6b21\u8be2\u95ee\uff0c\u6c42\u51fa $t_{[l,r]}$ \u4e2d\u51fa\u73b0 $s[pl:pr]$ \u6b21\u6570\u6700\u591a\u7684\u5b57\u7b26\u4e32\u7f16\u53f7\u6700\u5c0f\u503c\u4e0e\u6b21\u6570\u3002\n\n[\u6211\u7684 SAM \u5b66\u4e60\u7b14\u8bb0 \u2014\u2014 cnblogs](https://www.cnblogs.com/alex-wei/p/Suffix_Automaton.html)\u3002\n\n---\n\nupdate\uff1a**\u591a\u4e32 SAM \u5982\u679c\u76f4\u63a5 $las=1$ \u4e0d\u80fd\u5224\u91cd\uff01\u4f1a\u6302\u6389\uff01\uff01**\n\n~~\u7801\u9898\u5341\u5206\u949f\uff0cdebug de \u4e00\u5e74\u3002~~\n\n\u663e\u7136\uff0c\u5bf9\u4e8e\u8fd9\u79cd\u5b57\u7b26\u4e32\u9898\u76ee\uff0c\u6700\u597d\u7684\u89e3\u51b3\u65b9\u6cd5\u5c31\u662f SAM\u3002\n\n\u9996\u5148\u6709\u8fd9\u6837\u4e00\u4e2a\u6280\u5de7\uff1a\n\n> **trick**\uff1a\u627e\u5230 $s[l:r]$ \u5728\u4e00\u4e2a SAM \u4e2d\u7684\u72b6\u6001\uff0c\u53ef\u4ee5\u8bb0\u5f55 $s[1:r]$ \u5728 SAM \u4e2d\u5339\u914d\u7684\u7684\u72b6\u6001\uff0c\u7136\u540e\u5728 $fail$ \u6811\u4e0a\u500d\u589e\u3002\u9700\u8981\u7279\u5224 $s[1:r]$ \u5728 SAM \u4e2d\u5339\u914d\u957f\u5ea6\u5c0f\u4e8e $r-l+1$ \u7684\u60c5\u51b5\uff0c\u8fd9\u65f6 $s[l:r]$ \u5728 SAM \u91cc\u9762\u662f\u6ca1\u6709\u7684 **\uff08\u5982\u679c $s$ \u4e5f\u5728 SAM \u4e2d\u5c31\u4e0d\u9700\u8981\u4e86\uff0c\u56e0\u4e3a\u4e00\u5b9a\u5b58\u5728\u8fd9\u4e2a\u72b6\u6001\uff09**\u3002\n\n\u5c06\u6240\u6709 $t_i$ \u5efa\u51fa\u4e00\u4e2a\u5e7f\u4e49 SAM\uff0c~~\u7136\u800c\u6211\u4e0d\u4f1a\u5e7f\u4e49 SAM~~\uff0c\u90a3\u4e48\u6bcf\u6b21\u6dfb\u52a0\u4e00\u4e2a\u65b0\u5b57\u7b26\u4e32\u65f6\uff0c\u5c06 $las$ \u8bbe\u4e3a $1$ \u5373\u53ef\u3002\n\n\u9664\u6b64\u4ee5\u5916\uff0c\u5047\u8bbe\u8df3\u5230\u4e86\u8868\u793a $s[pl:pr]$ \u7684\u72b6\u6001 $p$\uff0c\u90a3\u6211\u4eec\u8fd8\u9700\u627e\u5230\u4e00\u4e2a\u6700\u5c0f\u7684 $i\\in[l,r]$ \u4f7f\u5f97 $p$ \u53ca $p$ \u7684\u5b50\u6811\u4e2d $t_i$ \u7684\u7ed3\u675f\u72b6\u6001\u7684\u4e2a\u6570\u6700\u5927\uff0c\u663e\u7136\u8981\u7ebf\u6bb5\u6811\u5408\u5e76\u7ef4\u62a4\u4e00\u4e2a\u72b6\u6001\u7684 $endpos$ \u96c6\u5408\u4e2d\u51fa\u73b0\u5728\u6bcf\u4e2a $t_i$ \u4e2d\u7684\u4f4d\u7f6e\u4e2a\u6570\uff0c\u7136\u540e\u76f4\u63a5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u6700\u5927\u503c\u548c\u533a\u95f4\u6700\u5927\u503c\u7684\u7f16\u53f7\u6700\u5c0f\u503c\u5373\u53ef\u3002\n\n**\u6ce8\u610f\u70b9**\uff1a\u5982\u679c\u591a\u4e32 SAM \u76f4\u63a5\u5c06 $las$ \u8bbe\u4e3a $1$ \u5e76\u4e14\u4e0d**\u5224\u91cd**\uff08\u5373\u76f4\u63a5 $cur=las+1$ \u800c\u4e0d\u5224\u65ad\u662f\u5426 $las$ \u5df2\u7ecf\u6709\u5f53\u524d\u5b57\u7b26\u7684\u8f6c\u79fb\uff09\uff08upd\uff1a**\u53ea\u80fd\u4e0d\u5224\u91cd\uff01\u5426\u5219\u4f1a\u7834\u574f\u539f\u6709 SAM \u7684\u7ed3\u6784\uff01**\uff09\uff0c\u90a3\u4e48\u5982\u679c\u4e24\u4e2a\u5b57\u7b26\u4e32\u7684**\u5f00\u5934\u5b57\u7b26\u76f8\u540c**\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u8282\u70b9**\u6210\u4e86\u7a7a\u8282\u70b9**\uff08\u5373\u6ca1\u6709\u5165\u8fb9\uff0c\u4e0d\u5305\u542b\u4efb\u4f55\u5b57\u7b26\u4e32\uff09\uff0c\u4ece\u800c\u4f7f $len(link(i))=len(i)$\u3002\u8fd9\u65f6\u5c31**\u4e0d\u80fd\u7528\u6876\u6392\u6c42\u62d3\u6251\u5e8f\u4e86**\uff0c\u5fc5\u987b\u7528 dfs\u3002\n\n~~\u8fd9\u73a9\u610f\u8c03\u4e86 1.5h\uff0c\u523b\u9aa8\u94ed\u5fc3\u3002~~\n\n\u5f53\u7136\u5982\u679c\u76f4\u63a5\u628a $s$ \u4e5f\u585e\u8fdb SAM \u4e5f\u53ef\u4ee5\uff0c\u4e0d\u8fc7\u4f1a\u6162\u4e00\u4e9b\uff08\u5176\u5b9e\u662f\u4e24\u500d\uff09\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal{O}((|s|+\\sum|t_i|+q)\\log \\sum|t_i|)$\u3002\n\n\n\n```cpp\n/*\n\tPowered by C++11.\n\tAuthor : Alex_Wei.\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n//#pragma GCC optimize(3)\n\n//using int = long long\n//using i128 = __int128;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nusing db = double;\nusing ld = long double;\nusing pii = pair <int,int>;\nusing pll = pair <ll,ll>;\nusing pdd = pair <double,double>;\nusing vint = vector <int>;\nusing vpii = vector <pii>;\n\n#define fi first\n#define se second\n#define pb emplace_back\n#define mpi make_pair\n#define all(x) x.begin(),x.end()\n#define sor(x) sort(all(x))\n#define rev(x) reverse(all(x))\n#define mem(x,v) memset(x,v,sizeof(x))\n#define mcpy(x,y) memcpy(x,y,sizeof(y))\n#define Time 1.0*clock()/CLOCKS_PER_SEC\n\npii operator + (pii a,pii b){return {a.fi+b.fi,a.se+b.se};}\npll operator + (pll a,pll b){return {a.fi+b.fi,a.se+b.se};}\n\nnamespace IO{\n\tchar buf[1<<23],*p1=buf,*p2=buf,obuf[1<<24],*O=obuf;\n\t#ifdef __WIN32\n\t\t#define gc getchar()\n\t#else\n\t\t#define gc (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<22,stdin),p1==p2)?EOF:*p1++)\n\t#endif\n\t#define pc(x) (*O++=x)\n\t#define flush() fwrite(obuf,O-obuf,1,stdout)\n\tinline ll read(){\n\t\tll x=0; bool sign=0; char s=gc;\n\t\twhile(!isdigit(s))sign|=s=='-',s=gc;\n\t\twhile(isdigit(s))x=(x<<1)+(x<<3)+(s-'0'),s=gc;\n\t\treturn sign?-x:x;\n\t}\n\tinline void print(ll x){\n\t\tif(x<0)pc('-'),print(-x);\n\t\telse{\n\t\t\tif(x>9)print(x/10);\n\t\t\tpc(x%10+'0');\n\t\t}\n\t}\n} using namespace IO;\n\n// \u4ee5\u4e0a\u662f\u677f\u5b50\n\nconst int N=2e6+5;\nconst int M=5e4+5;\nconst int S=26;\n\nint node,rt[N],ls[M<<6],rs[M<<6];\npii val[M<<6];\npii merge(pii x,pii y){\n\tint z=max(x.fi,y.fi);\n\tif(x.se>y.se)swap(x,y);\n\treturn {z,x.fi==z?x.se:y.se};\n} void ins(int l,int r,int p,int &x){\n\tif(!x)x=++node;\n\tif(l==r)return val[x].fi++,val[x].se=p,void();\n\tint m=l+r>>1;\n\tif(p<=m)ins(l,m,p,ls[x]);\n\telse ins(m+1,r,p,rs[x]);\n\tval[x]=merge(val[ls[x]],val[rs[x]]);\n} int merge(int l,int r,int x,int y){\n\tif(!x||!y)return x|y;\n\tint z=++node,m=l+r>>1;\n\tif(l==r){\n\t\tval[z].fi=val[x].fi+val[y].fi;\n\t\tval[z].se=min(val[x].se,val[y].se);\n\t\treturn z;\n\t} ls[z]=merge(l,m,ls[x],ls[y]),rs[z]=merge(m+1,r,rs[x],rs[y]);\n\treturn val[z]=merge(val[ls[z]],val[rs[z]]),z;\n} pii query(int l,int r,int ql,int qr,int x){\n\tif(!x)return {0,0};\n\tif(ql<=l&&r<=qr)return val[x];\n\tint m=l+r>>1; pii ans={0,0};\n\tif(ql<=m)ans=query(l,m,ql,qr,ls[x]);\n\tif(m<qr)ans=merge(ans,query(m+1,r,ql,qr,rs[x]));\n\treturn ans;\n}\n\nint n,m,cnt,las;\nint son[N][S],fa[N],len[N];\nint buc[N],id[N],f[N][S],ed[N],mxl[N];\nvector <int> e[N];\nvoid ins(char s,int id){\n\tint p=las,it=s-'a',cur=++cnt;\n\tlen[cur]=len[las]+1,las=cur,ins(1,m,id,rt[cur]);\n\twhile(p&&!son[p][it])son[p][it]=cur,p=fa[p];\n\tif(!p)return fa[cur]=1,void();\n\tint q=son[p][it];\n\tif(len[p]+1==len[q])return fa[cur]=q,void();\n\tint c=++cnt;\n\tfa[c]=fa[q],fa[q]=fa[cur]=c,len[c]=len[p]+1;\n\tfor(int i=0;i<26;i++)son[c][i]=son[q][i];\n\twhile(p&&son[p][it]==q)son[p][it]=c,p=fa[p];\n} void build(char *s,int id){\n\tint n=strlen(s+1); las=1;\n\tif(id==1)cnt=1;\n\tfor(int i=1;i<=n;i++)ins(s[i],id);\n} void dfs(int id){\n\tfor(int it:e[id])dfs(it),rt[id]=merge(1,m,rt[id],rt[it]);\n}\n\nint p,q,pl,pr,l,r;\nchar s[N],t[N];\nint main(){\n\tscanf(\"%s\",s+1),cin>>m;\n\tn=strlen(s+1);\n\tfor(int i=1;i<=m;i++)scanf(\"%s\",t+1),build(t,i);\n\tfor(int i=1,p=1,l=0;i<=n;i++){\n\t\twhile(p&&!son[p][s[i]-'a'])p=fa[p],l=len[p];\n\t\tif(!p)p=1,l=0; else p=son[p][s[i]-'a'],l++;\n\t\ted[i]=p,mxl[i]=l;\n\t}\n\tfor(int j=0;1<<j<=cnt;j++)for(int i=1;i<=cnt;i++)f[i][j]=j?f[f[i][j-1]][j-1]:fa[i];\n\tfor(int i=2;i<=cnt;i++)e[fa[i]].pb(i); dfs(1);\n\tcin>>q; while(q--){\n\t\tl=read(),r=read(),pl=read(),pr=read(),p=ed[pr];\n\t\tif(mxl[pr]<pr-pl+1){\n\t\t\tcout<<l<<\" 0\\n\";\n\t\t\tcontinue;\n\t\t} for(int i=log2(cnt);~i;i--)if(pr-len[f[p][i]]+1<=pl)p=f[p][i];\n\t\tpii ans=query(1,m,l,r,rt[p]);\n\t\tcout<<max(l,ans.se)<<\" \"<<ans.fi<<\"\\n\";\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1613835346,
        "uid": 123294,
        "name": "Alex_Wei",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF666E Forensic Examination"
    },
    {
        "content": "# \u9898\u76ee\n&emsp;&emsp;[\u70b9\u8fd9\u91cc](https://www.luogu.com.cn/problem/CF666E)\u770b\u9898\u76ee\u3002  \n# \u5206\u6790\n&emsp;&emsp;\u5148\u5bf9\u6240\u6709\u7684\u6a21\u5f0f\u4e32\u5efa\u7acb\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\u3002  \n&emsp;&emsp;\u6211\u4eec\u9700\u8981\u6c42\u51fa\u6bcf\u4e2a\u8282\u70b9\u7684$end-pos$\u96c6\u5408\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u5728 $fail$ \u6811\u4e0a\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u5feb\u901f\u9884\u5904\u7406\u3002  \n&emsp;&emsp;\u8003\u8651\u8be2\u95ee\u3002\u7531\u4e8e\u5b57\u7b26\u4e32\u7684\u5b50\u4e32\u5c31\u662f**\u524d\u7f00\u7684\u540e\u7f00**\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u524d\u7f00\uff0c\u5904\u7406\u51fa\u5b83\u5728\u81ea\u52a8\u673a\u4e0a\u7684$LCS$\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u90a3\u4e48\u4e00\u4e2a\u5b50\u4e32\u5728\u81ea\u52a8\u673a\u4e0a\u7684\u4f4d\u7f6e\uff0c\u4e00\u5b9a\u662f**\u5bf9\u5e94\u5b83\u7684\u524d\u7f00 \u7684\u5bf9\u5e94\u8282\u70b9 \u7684 $fail$ \u7956\u5148**\u3002\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5728 $fail$ \u4e0a\u9762\u500d\u589e\uff0c\u8fdb\u800c\u53ef\u4ee5\u5728\u9884\u5904\u7406\u540e$O(\\log_2n)$\u5730\u6c42\u51fa\u4e00\u4e2a\u5b50\u4e32\u7684\u5bf9\u5e94\u8282\u70b9\u3002  \n&emsp;&emsp;\u77e5\u9053\u4e86\u8fd9\u4e9b\uff0c\u518d\u5957\u7528\u7ebf\u6bb5\u6811\u5206\u6cbb\u5f97\u5230\u7684\u4fe1\u606f\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u56de\u7b54\u8be2\u95ee\u4e86\u3002  \n# \u4ee3\u7801\n```cpp\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n\nconst int MAXN = 5e5 + 5, MAXM = 5e4 + 5, MAXL = 1e5 + 5, MAXS = MAXL * 100;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0; char s = getchar();int f = 1;\n\twhile( s < '0' || '9' < s ) { f = 1; if( s == '-' ) f = -1; s = getchar(); }\n\twhile( '0' <= s && s <= '9' ) { x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ) { putchar( '-' ), x = -x; }\n\tif( 9 < x ) { write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\ntemplate<typename _T>\n_T MAX( const _T a, const _T b )\n{\n\treturn a > b ? a : b;\n}\n\nstruct edge\n{\n\tint to, nxt;\n}Graph[MAXL << 1];\n\nstruct pii\n{\n\tint mx, indx;\n\tpii() { mx = 0, indx = 1e6; }\n\tpii( const int M, const int I ) { mx = M, indx = I; }\n\tbool operator > ( const pii &b ) const { return mx == b.mx ? indx < b.indx : mx > b.mx; }\n};\n\npii bst[MAXS]; \nint lch[MAXS], rch[MAXS];\nint ed[MAXN], mxl[MAXN];\nint ch[MAXL][26], fa[MAXL][18], mx[MAXL], rot[MAXL], head[MAXL];\nint N, M, Q, lg2, rt, lst, tot, cnt, siz;\nchar S[MAXN], T[MAXL];\n\nvoid upt( const int x ) { bst[x] = MAX( bst[lch[x]], bst[rch[x]] ); }\nvoid copy( int a, int b ) { fa[a][0] = fa[b][0], mx[a] = mx[b], memcpy( ch[a], ch[b], sizeof ch[b] ); }\n\nvoid addEdge( const int from, const int to )\n{\n\tGraph[++ cnt].to = to, Graph[cnt].nxt = head[from];\n\thead[from] = cnt;\n}\n\nvoid expand( const char c )\n{\n\tint x = c - 'a';\n\tif( ch[lst][x] && mx[ch[lst][x]] == mx[lst] + 1 ) { lst = ch[lst][x]; return ; }\n\tint p = lst, cur = ++ tot;\n\tmx[cur] = mx[lst] + 1, lst = cur;\n\twhile( p && ! ch[p][x] ) ch[p][x] = cur, p = fa[p][0];\n\tif( ! p ) { fa[cur][0] = rt; return ; }\n\tint q = ch[p][x];\n\tif( mx[q] == mx[p] + 1 ) { fa[cur][0] = q; return ; }\n\tint nq = ++ tot; copy( nq, q );\n\tmx[nq] = mx[p] + 1, fa[q][0] = fa[cur][0] = nq;\n\tif( mx[p] + 1 == mx[cur] ) lst = nq;\n\twhile( p && ch[p][x] == q ) ch[p][x] = nq, p = fa[p][0];\n}\n\nvoid update( int &u, const int l, const int r, const int pos )\n{\n\tif( ! u ) u = ++ siz; int mid = l + r >> 1;\n\tif( l == r ) { bst[u].mx ++, bst[u].indx = l; return ; }\n\tif( pos <= mid ) update( lch[u], l, mid, pos );\n\telse update( rch[u], mid + 1, r, pos );\n\tupt( u );\n}\n\npii query( const int u, const int l, const int r, const int segL, const int segR )\n{\n\tif( ! u ) return pii();\n\tif( segL <= l && r <= segR ) return bst[u];\n\tif( l == r ) return pii();\n\tint mid = l + r >> 1; pii ret = pii();\n\tif( segL <= mid ) ret = MAX( ret, query( lch[u], l, mid, segL, segR ) );\n\tif( mid < segR ) ret = MAX( ret, query( rch[u], mid + 1, r, segL, segR ) );\n\treturn ret;\n}\n\nint merg( int lrt, int rrt, int l, int r )\n{\n\tif( ! lrt || ! rrt ) return lrt | rrt;\n\tint cur = ++ siz, mid = l + r >> 1;\n\tif( l == r )\n\t{\n\t\tbst[cur] = bst[lrt], bst[cur].mx += bst[rrt].mx;\n\t\treturn cur;\n\t}\n\tlch[cur] = merg( lch[lrt], lch[rrt], l, mid ); \n\trch[cur] = merg( rch[lrt], rch[rrt], mid + 1, r );\n\tupt( cur );\n\treturn cur;\n}\n\nvoid DFS( const int u )\n{\n\tfor( int i = head[u], v ; i ; i = Graph[i].nxt )\n\t{\n\t\tDFS( v = Graph[i].to );\n\t\trot[u] = merg( rot[u], rot[v], 1, M );\n\t}\n}\n\nint main()\n{\n\trt = ++ tot;\n\tscanf( \"%s\", S + 1 ), N = strlen( S + 1 );\n\tread( M );\n\tfor( int i = 1 ; i <= M ; i ++ )\n\t{\n\t\tlst = rt, scanf( \"%s\", T + 1 );\n\t\tfor( int j = 1 ; T[j] ; j ++ ) \n\t\t\texpand( T[j] ), update( rot[lst], 1, M, i );\t\n\t}\n\tfor( int i = 2 ; i <= tot ; i ++ ) addEdge( fa[i][0], i );\n\tDFS( rt );\n\tlg2 = log2( tot );\n\tfor( int j = 1 ; j <= lg2 ; j ++ )\n\t\tfor( int i = 1 ; i <= tot ; i ++ )\n\t\t\tfa[i][j] = fa[fa[i][j - 1]][j - 1];\n\tint p = rt, len;\n\tfor( int i = 1, x ; i <= N ; i ++ )\n\t{\n\t\tx = S[i] - 'a';\n\t\twhile( p && ! ch[p][x] ) p = fa[p][0], len = mx[p];\n\t\tif( ! p ) p = rt, len = 0;\n\t\telse len ++, p = ch[p][x];\n\t\ted[i] = p, mxl[i] = len;\n\t}\n\tread( Q );\n\tint lef, rig, L, R;\n\twhile( Q -- )\n\t{\n\t\tread( lef ), read( rig ), read( L ), read( R );\n\t\tif( mxl[R] < R - L + 1 ) { printf( \"%d 0\\n\", lef ); continue; }\n\t\tp = ed[R];\n\t\tfor( int j = lg2 ; ~ j ; j -- )\n\t\t\tif( fa[p][j] && mx[fa[p][j]] >= R - L + 1 )\n\t\t\t\tp = fa[p][j];\n\t\tpii ans = query( rot[p], 1, M, lef, rig );\n\t\tif( ans.mx == 0 ) ans.indx = lef;\n\t\twrite( ans.indx ), putchar( ' ' ), write( ans.mx ), putchar( '\\n' );\n\t}\n\treturn 0;\n}\n```  ",
        "postTime": 1590730375,
        "uid": 123809,
        "name": "crashed",
        "ccfLevel": 0,
        "title": "[CF666E]Forensic Examination"
    },
    {
        "content": "## [\u9898\u610f](https://www.luogu.com.cn/problem/CF666E)\n------------\n\n\u4eca\u5929\u53d1\u751f\u4e86\u4e00\u4e2a\u53ebnofind\u7684\u849f\u84bb\u56e0\u4e3awhile\u5199\u6210if\u8c03\u4e86\u4e00\u4e0b\u5348\u7684\u6545\u4e8b\u3002\n\n------------\n\n\u9996\u5148\u8003\u8651\u8fd9\u4e24\u4e2a\u9650\u5236\uff1a\n\n1.$S[sl...sr]$\u8fd9\u4e2a\u5b50\u4e32\u3002 \n2.\u5728$T[ql..qr]$\u8fd9\u4e9b\u5b57\u7b26\u4e32\u4e2d\u3002\n\n\u6211\u4eec\u5148\u5bf9\u6240\u6709\u7684$T_i$\u5efa\u51fa\u4e00\u4e2a\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u4e0d\u4f1a\u5e7f\u4e49\u540e\u7f00\u81ea\u52a8\u673a\u7684\u51fa\u95e8\u5de6\u8f6c[\u8fd9\u9053\u9898](https://www.luogu.com.cn/problem/P3346)\u3002\n\n\u5148\u8003\u8651\u7b2c\u4e8c\u4e2a\u9650\u5236\uff1a\n\n\u4e4b\u540e\u6211\u4eec\u5bf9$SAM$\u4e0a\u7684\u6bcf\u4e2a\u70b9\u7528\u4e00\u4e2a\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u7ef4\u62a4\u7b54\u6848\uff0c\u7ebf\u6bb5\u6811\u4ee5$[1,m]$\u4e3a\u4e0b\u6807\uff0c\u53f6\u5b50\u7ed3\u70b9$[l,l]$\u653e\u7684\u662f\u8be5\u8282\u70b9\u5728$T_l$\u4e2d\u51fa\u73b0\u7684\u6b21\u6570\uff0c\u4e4b\u540e\u6211\u4eec\u5411\u4e0a\u5408\u5e76\u5e76\u4e14\u7ef4\u62a4\u6700\u5927\u503c\u7684\u4f4d\u7f6e\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7528\u7ecf\u5178\u7684\u540e\u7f00\u81ea\u52a8\u673a+\u7ebf\u6bb5\u6811\u5408\u5e76\u7684\u5957\u8def\u505a\u3002\n\n\u5728\u5b9e\u73b0\u65f6\u6211\u7528\u4e86$STL$\u7684$pair$\uff0c\u7b2c\u4e00\u5173\u952e\u5b57\u662f\u51fa\u73b0\u6b21\u6570\uff0c\u7b2c\u4e8c\u5173\u952e\u5b57\u662f\u4f4d\u7f6e\uff0c\u540c\u65f6\u7b2c\u4e8c\u5173\u952e\u5b57\u53d6\u4e86\u8d1f\u6570\uff0c\u8fd9\u6837\u53ef\u4ee5\u76f4\u63a5\u4e24\u4e2a$pair$\u53d6$max$\u3002\n\n\u518d\u8003\u8651\u7b2c\u4e00\u4e2a\u9650\u5236\uff1a\n\n\u6211\u4eec\u53ea\u8981\u627e\u5230\u5b50\u4e32$S[sl...sr]$\u6240\u5728\u7684\u8282\u70b9\uff0c\u4e4b\u540e\u7ebf\u6bb5\u6811\u4e0a\u76f4\u63a5\u67e5\u8be2\u5373\u53ef\u3002\u90a3\u4e48\u63a5\u4e0b\u6765\u5c31\u8981\u627e\u5230$S[sl...sr]$\u6240\u5728\u8282\u70b9\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5148\u627e\u5230$S[1...sr]$\uff0c\u4e4b\u540e\u500d\u589e\u8df3\u5230\u6700\u540e\u4e00\u4e2a\u4e00\u4e2a\u70b9$x$\uff0c$x$\u6ee1\u8db3$len_x\\geqslant (sr-sl+1)$\uff0c\u90a3\u4e48$x$\u5373\u4e3a\u6240\u6c42\u3002\n\n\u4f46\u662f\u663e\u7136\u6211\u4eec\u4e0d\u80fd\u6bcf\u6b21\u8be2\u95ee\u90fd\u66b4\u529b\u627e\uff0c\u4e8e\u662f\u6211\u4eec\u5c06\u8be2\u95ee\u79bb\u7ebf\uff0c\u5bf9$S$\u7684\u6bcf\u4e2a\u4f4d\u7f6e\u5f00\u4e00\u4e2a$vector$\uff0c\u5c06\u8be2\u95ee$(sl,sr)$\u653e\u5728$sr$\u7684$vector$\u4e2d\u3002\u4e4b\u540e\u5728$SAM$\u4e0a\u5bf9$S$\u8fdb\u884c\u5339\u914d\uff0c\u5230\u4e86\u7b2c$i$\u4e2a\u4f4d\u7f6e\u65f6\uff0c\u6240\u6709\u4ee5$i$\u4e3a\u7ed3\u5c3e\u7684\u5b50\u4e32\u5fc5\u5b9a\u662f\u5f53\u524d\u8282\u70b9\u7684\u7956\u5148\uff0c\u6211\u4eec\u8fd9\u65f6\u500d\u589e\u5904\u7406\u6240\u6709\u4ee5$i$\u4e3a\u7ed3\u5c3e\u7684\u8be2\u95ee\u5373\u53ef\u3002\n\ncode:\n```\n#include<bits/stdc++.h>\nusing namespace std;\n#define pii pair<int,int>\n#define mkp make_pair\n#define fir first\n#define sec second\nconst int maxn=1e6+10;\nconst int maxQ=5*1e5+10;\nint n,m,Q,cnt_edge,tot,lg;\nint head[maxn],root[maxn];\nint f[maxn][18];\nchar s[maxn],t[maxn];\npii ans[maxQ];\nvector<int>qr_id[maxn];\nstruct edge{int to,nxt;}e[maxn];\ninline void add_edge(int u,int v)\n{\n\te[++cnt_edge].nxt=head[u];\n\thead[u]=cnt_edge;\n\te[cnt_edge].to=v;\n}\nstruct Query{int l1,r1,l2,r2,id;}qr[maxQ];\nstruct Seg\n{\n\t#define lc(p) seg[p].lc\n\t#define rc(p) seg[p].rc\n\t#define data(p) seg[p].data\t\n\tint lc,rc;\n\tpii data;\n}seg[maxn*35];\ninline void up(int p){data(p)=max(data(lc(p)),data(rc(p)));}\nvoid add(int& p,int l,int r,int pos)\n{\n\tif(!p)p=++tot;\n\tif(l==r){data(p).fir++,data(p).sec=-l;return;}\n\tint mid=(l+r)>>1;\n\tif(pos<=mid)add(lc(p),l,mid,pos);\n\telse add(rc(p),mid+1,r,pos);\n\tup(p);\n}\nint merge(int p,int q,int l,int r)\n{\n\tif(!p||!q)\n\t{\n\t\tint x=++tot;\n\t\tseg[x]=seg[p+q];\n\t\treturn x;\n\t}\n\tint mid=(l+r)>>1,x=++tot;\n\tif(l==r){data(x).fir=data(p).fir+data(q).fir;data(x).sec=-l;return x;}\n\tlc(x)=merge(lc(p),lc(q),l,mid);\n\trc(x)=merge(rc(p),rc(q),mid+1,r);\n\tup(x);\n\treturn x;\n}\npii query(int p,int l,int r,int ql,int qr)\n{\n\tif(!p)return mkp(0,-ql);\n\tif(l>=ql&&r<=qr)return data(p);\n\tint mid=(l+r)>>1;pii res=mkp(0,-ql);\n\tif(ql<=mid)res=max(res,query(lc(p),l,mid,ql,qr));\n\tif(qr>mid)res=max(res,query(rc(p),mid+1,r,ql,qr));\n\treturn res;\n}\nstruct SAM\n{\n\tint last,tot;\n\tint fa[maxn],len[maxn];\n\tint ch[maxn][26];\n\tSAM(){last=tot=1;}\n\tinline void add(int c)\n\t{\n\t\tif(ch[last][c]&&len[ch[last][c]]==len[last]+1){last=ch[last][c];return;}\n\t\tint now=++tot;len[now]=len[last]+1;\n\t\tint p=last;\n\t\twhile(p&&!ch[p][c])ch[p][c]=now,p=fa[p];\n\t\tif(!p){fa[now]=1;last=now;return;}\n\t\tint q=ch[p][c];\n\t\tbool flag=0;\n\t\tif(len[q]==len[p]+1)fa[now]=q;\n\t\telse\n\t\t{\n\t\t\tif(p==last)flag=1;\n\t\t\tint nowq=++tot;len[nowq]=len[p]+1;\n\t\t\tmemcpy(ch[nowq],ch[q],sizeof(ch[q]));\n\t\t\twhile(p&&ch[p][c]==q)ch[p][c]=nowq,p=fa[p];\n\t\t\tfa[nowq]=fa[q],fa[q]=fa[now]=nowq;\n\t\t\tif(flag)last=nowq;\n\t\t}\n\t\tif(!flag)last=now;\n\t}\n}sam;\nvoid dfs(int x)\n{\n\tfor(int i=1;i<=lg;i++)f[x][i]=f[f[x][i-1]][i-1];\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t{\n\t\tint y=e[i].to;\n\t\tf[y][0]=x;dfs(y);\n\t\troot[x]=merge(root[x],root[y],1,m);\n\t}\n}\ninline int find(int x,int len)\n{\n\tfor(int i=lg;~i;i--)if(f[x][i]&&sam.len[f[x][i]]>=len)x=f[x][i];\n\treturn x;\n}\ninline void solve()\n{\n\tint now=1,nowl=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint c=s[i]-'a';\n\t\twhile(now&&!sam.ch[now][c])now=sam.fa[now],nowl=sam.len[now];\n\t\tif(!now){now=1;nowl=0;continue;}\n\t\tnow=sam.ch[now][c];nowl++;\n\t\tfor(unsigned int j=0;j<qr_id[i].size();j++)\n\t\t{\n\t\t\tint id=qr_id[i][j];\n\t\t\tif(qr[id].r1-qr[id].l1+1>nowl)continue;\n\t\t\tint tmp=find(now,i-qr[id].l1+1);\n\t\t\tans[id]=query(root[tmp],1,m,qr[id].l2,qr[id].r2);\n\t\t}\n\t}\n}\nint main()\n{\n\t//freopen(\"test.in\",\"r\",stdin);\n\t//freopen(\"test.out\",\"w\",stdout);\n\tscanf(\"%s\",s+1);n=strlen(s+1);\n\tscanf(\"%d\",&m);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tsam.last=1;\n\t\tscanf(\"%s\",t+1);\n\t\tint len=strlen(t+1);\n\t\tfor(int j=1;j<=len;j++)sam.add(t[j]-'a'),add(root[sam.last],1,m,i);\n\t}\n\tscanf(\"%d\",&Q);\n\tfor(int i=1;i<=Q;i++)scanf(\"%d%d%d%d\",&qr[i].l2,&qr[i].r2,&qr[i].l1,&qr[i].r1);\n\tfor(int i=1;i<=Q;i++)qr_id[qr[i].r1].push_back(i);\n\tfor(int i=2;i<=sam.tot;i++)add_edge(sam.fa[i],i);\n\tlg=(int)log2(sam.tot)+1;dfs(1);\n\tsolve();\n\tfor(int i=1;i<=Q;i++)if(!ans[i].fir)ans[i].sec=-qr[i].l2;\n\tfor(int i=1;i<=Q;i++)printf(\"%d %d\\n\",-ans[i].sec,ans[i].fir);\n\treturn 0;\n}\n```\n",
        "postTime": 1577098528,
        "uid": 145441,
        "name": "nofind",
        "ccfLevel": 6,
        "title": "CF666E Forensic Examination(\u540e\u7f00\u81ea\u52a8\u673a+\u7ebf\u6bb5\u6811\u5408\u5e76)"
    }
]