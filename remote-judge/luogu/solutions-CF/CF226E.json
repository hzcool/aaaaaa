[
    {
        "content": "# \u601d\u8def\n\n\u603b\u4f53\u601d\u8def\uff1a\u4e3b\u5e2d\u6811 + \u7ebf\u6bb5\u6811\u3002\n\n- \u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u65f6\u95f4\uff0c\u5f00\u4e00\u68f5\u4e3b\u5e2d\u6811\uff0c\u4e0b\u6807\u4ece $1$ \u5f00\u59cb\uff0c\u8868\u793a $i$ \u662f\u5426\u88ab\u6bc1\u574f\n\n- \u5bf9\u4e8e\u8be2\u95ee\uff0c\u5148\u4ece\u4e24\u8fb9\u8df3\u94fe\uff0c\u627e\u5230 `LCA` \uff0c\u5e76\u627e\u51fa\u4e24\u70b9\u8def\u5f84\u95f4\u6ca1\u6709\u88ab\u653b\u51fb\u7684\u57ce\u5821\u6570\u3002\u5982\u679c\u8fd9\u4e00\u6570\u91cf\u5c0f\u4e8e\u8be2\u95ee\uff0c\u76f4\u63a5\u8f93\u51fa $-1$ \u3002\n\n# \u505a\u6cd5\n\n- $y$ \u5e74\u540e\u6ca1\u6709\u88ab\u653b\u51fb\u8fc7\u7684\u57ce\u5821\u6570\u91cf = \u603b\u6570 - \u88ab\u653b\u51fb\u8fc7\u7684\u57ce\u5821\u6570\u91cf + $y$ \u5e74\u524d\u88ab\u653b\u51fb\u8fc7\u7684\u57ce\u5821\u6570\u91cf \u3002\u53ef\u4ee5\u7528\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n- \u5c06\u6811\u94fe\u5256\u5206\uff0c\u7136\u540e\u5efa\u51fa\u4e3b\u5e2d\u6811, \u518d\u8f6c\u5316\u4e3a\u533a\u95f4\u95ee\u9898\u3002\n\n- \u4e3b\u5e2d\u6811\u4e00\u7ef4\u7ef4\u62a4\u7684\u662f\u65f6\u95f4\uff0c\u6bcf\u4e00\u68f5\u4e3b\u5e2d\u6811\u5185\u90e8\u7ef4\u62a4\u7684\u662f\u6811\u5256\u5256\u51fa\u6765\u7684\u7ed3\u679c\u3002\n\n- \u5982\u679c\u88ab\u635f\u574f\uff0c\u90a3\u4e48\u5c31\u4e0d\u80fd\u4f4f\u3002\n\n- \u6c42\u7b2c $k$ \u5927\u5c31\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u6ce8\u610f\u4e8c\u5206\u7684\u5199\u6cd5\n\n# \u7ec6\u8282\n- $b$ \u5230 $lca$ \u7684\u8ddd\u79bb $>$ $top-k+1$\n\n- *a\u3001b* \u4e5f\u4e0d\u80fd\u4f4f\u3002\n\n\n\n------------\n\u8fd9\u9053\u9898\u5168\u662f\u7ebf\u6bb5\u6811\u4e0e\u4e3b\u5e2d\u6811\u7684\u57fa\u672c\u64cd\u4f5c\uff0c\u96be\u7684\u662f\u5c06\u4e8c\u8005\u7684\u64cd\u4f5c\u5408\u4e3a\u4e00\u4f53\u3002\n\n\u5269\u4e0b\u7684\u770b\u4ee3\u7801\u5427\n\n\n# \u4ee3\u7801\n\n```cpp\n#include <bits/stdc++.h>\n#define maxn 100005\n\nusing namespace std; \n\nint n, m;\nint head[maxn], root[maxn], dy[maxn], dfn[maxn], dep[maxn], son[maxn], size[maxn], top[maxn], fa[maxn];\nint sc, cnt, t1, t2, tot, op, t, a, b, lca, a1, b1, li, ri, rk, las, rak, num1, num2, ff;\n\nstruct node{ int v, nxt; } e[maxn * 2];\nstruct no { int l, r, x; }tree[maxn * 30];\n\ninline void add(int &u, int &v){ ++cnt; e[cnt].v = v; e[cnt].nxt = head[u]; head[u] = cnt; }\n\nvoid dfs1(int k, int fath){\n    fa[k] = fath; dep[k] = dep[fath] + 1;\n    int gp = -1, sz = 0;\n    for(int i = head[k] ;i ;i = e[i].nxt) {\n        if(e[i].v != fath){\n            dfs1(e[i].v, k);\n            if(gp == -1) gp = e[i].v;\n            if(size[e[i].v] > size[gp]) gp = e[i].v;\n            sz += size[e[i].v];\n        }\n    }\n\n    size[k] = sz + 1; son[k] = gp;\n}\nvoid dfs2(int k){\n    dfn[k] = ++sc; dy[sc] = k;\n    if(son[k] != -1){\n        top[son[k]] = top[k];\n        dfs2(son[k]);\n    }\n    for(int i = head[k] ;i ;i = e[i].nxt) {\n        if(e[i].v != fa[k] && e[i].v != son[k]) {\n            top[e[i].v] = e[i].v;\n            dfs2(e[i].v);\n        }\n    }\n}\n\ninline void wh(int k){ tree[k].x = tree[tree[k].l].x + tree[tree[k].r].x; }\n\nvoid dfs(int &k, int la, int l, int r, int pl){\n    k = ++tot;\n    if(l == r){ return (void)(tree[k].x=tree[la].x+1); }\n    tree[k].l = tree[la].l; tree[k].r = tree[la].r;\n    int mid = (l + r) >> 1;\n    if(pl <= mid) dfs(tree[k].l, tree[la].l, l, mid, pl);\n    else dfs(tree[k].r, tree[la].r, mid+1, r, pl);\n    wh(k);\n}\nint ch(int k,int la,int l,int r){\n    if(l >= li && r <= ri){\n        int tmp=(r - l + 1) - (tree[k].x - tree[la].x);\n        return tmp;\n    }\n\n    int mid=l+r>>1;\n    int su=0;\n    if(li <= mid) su += ch(tree[k].l, tree[la].l, l, mid);\n    if(ri > mid) su += ch(tree[k].r, tree[la].r, mid + 1, r);\n    return su;\n}\n\nint ask(int k, int la, int l, int r, int fs) {\n    if(l == r) return dy[l];\n    int mid = (l+r) >> 1;\n    if(ri > mid){\n        int hh = ch(tree[k].r, tree[la].r, mid + 1, r);\n        if(hh >= fs) return ask(tree[k].r, tree[la].r, mid+1, r, fs);\n        else return ask(tree[k].l, tree[la].l, l, mid, fs - hh);\n    }\n    else return ask(tree[k].l, tree[la].l, l, mid, fs);\n}\n\nint main() {\n    cin >> n;\n    for(int i = 1 ;i <= n ;++i){\n        scanf(\"%d\", &t1);\n        if(!t1) continue;\n        add(i, t1); add(t1, i);\n    }\n    dfs1(1, 0); top[1] = 1; dfs2(1);\n     \n    cin >> m;\n    for(int i = 1 ;i <= m ;++i){\n        scanf(\"%d\", &op);\n        if(op == 1){\n            scanf(\"%d\", &t);\n            dfs(root[i], root[i - 1], 1, n, dfn[t]);\n        }\n        else {\n            root[i] = root[i - 1];\n            int num = 0;\n            scanf(\"%d %d %d %d\", &a, &b, &rk, &las);\n            li = ri = dfn[a]; ff = rk;\n            rk += ch(root[i], root[las], 1, n);\n            li = ri = dfn[b];\n            int fsy =  0;\n            fsy = ch(root[i], root[las], 1, n);\n            t1 = top[a]; t2=top[b];\n            a1 = a; b1 = b;\n\n            while(t1 != t2){\n                if(dep[t1] < dep[t2]) { swap(t1, t2); swap(a,b); }\n                li = dfn[t1]; ri = dfn[a];\n                num += ch(root[i], root[las], 1, n);\n                a = fa[t1]; t1 = top[a];\n            }\n\n            if(dep[a] < dep[b]) swap(a, b);\n            lca=b;\n            li=dfn[b],ri=dfn[a];\n            num += ch(root[i], root[las], 1, n);\n            if(num - fsy < rk) { puts(\"-1\"); continue; }\n             \n            rak = num - rk + 1;\n             \n            a = a1; t1 = top[a];\n            bool fl = 0;\n\n            while(t1 != top[lca]) {\n                li = dfn[t1]; ri = dfn[a];\n                num = ch(root[i], root[las], 1, n);\n                if(num >= rk){\n                    printf(\"%d\\n\", ask(root[i], root[las], 1, n, rk));\n                    fl = 1;\n                    break;\n                }\n                else rk -= num;\n                a = fa[t1]; t1 = top[a];\n            }\n\n            if(fl) continue;\n\n            li = dfn[lca]; ri = dfn[a];\n            num = ch(root[i], root[las], 1, n);\n\n            if(num >= rk){\n                int ans = ask(root[i], root[las], 1, n, rk);\n                if(ans == b1) puts(\"-1\");\n                else printf(\"%d\\n\", ans);\n                continue;\n            }\n\n            fl = 0; rk = rak;\n            b = b1; t2 = top[b];\n\n            while(t2 != top[lca]) {\n                li = dfn[t2]; ri = dfn[b];\n                num = ch(root[i], root[las], 1, n);\n\n                if(num >= rk){\n                    printf(\"%d\\n\", ask(root[i], root[las], 1, n, rk));\n                    fl = 1;\n                    break;\n                }\n                else rk -= num;\n\n                b = fa[t2]; t2 = top[b];\n            }\n\n            if(fl) continue;\n\n            li = dfn[lca]; ri = dfn[b];\n            num = ch(root[i], root[las], 1, n);\n            if(num >= rk){\n                int ans = ask(root[i], root[las], 1, n, rk);\n                if(ans == a1) puts(\"-1\");\n                else printf(\"%d\\n\",ans);\n                continue;\n            }\n        }\n    }\n    \n    return 0;\n}\n```\n\n- \u65f6\u95f4\u590d\u6742\u5ea6: $O(nlog^2n)$\n\n- \u7a7a\u95f4\u590d\u6742\u5ea6\uff1a$O(n)$",
        "postTime": 1633489753,
        "uid": 397282,
        "name": "_NTT_",
        "ccfLevel": 5,
        "title": "CF226E Noble Knight's Path \u9898\u89e3"
    },
    {
        "content": "\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u4e00\u4e2a\u70b9\u4e0d\u80fd\u88ab\u9009\u4e2d\u5f53\u4e14\u8fdb\u5f53\u8fd9\u4e2a\u70b9\u5728\u7b2cy+1\u5e74\u5230\u73b0\u5728\u8fd9\u4e00\u6bb5\u65f6\u95f4\u5185\u53d7\u5230\u653b\u51fb\uff0c\u5176\u4f59\u7684\u70b9\u90fd\u53ef\u4ee5\u88ab\u9009\n\n\u7136\u540e...\u5176\u5b9e\u8fd9\u9898\u7684\u91cd\u70b9\u5728\u4e8e...\u7801\n\n\u601d\u60f3\u5f88\u7b80\u5355\uff0c\u5148\u6811\u94fe\u5256\u5206\uff0c\u7136\u540e\u5efa\u8d77\u4e00\u68f5\u4e3b\u5e2d\u6811\u7ef4\u62a4\uff0c\u6bcf\u6b21\u4fee\u6539\u5c31\u751f\u6210\u4e00\u4e2a\u65b0\u7248\u672c\uff0c\u8fd9\u6837\u7684\u8bdd\u7528\u73b0\u5728\u7684\u7248\u672c-\u65f6\u523by\u7684\u7248\u672c\u5c31\u53ef\u4ee5\u7b97\u51fa\u8fd9\u6bb5\u65f6\u95f4\u4e0d\u80fd\u7528\u7684\u70b9\u7684\u4e2a\u6570\uff0c\u518d\u7528\u603b\u70b9\u6570\u53bb\u51cf\u5c31\u662f\u53ef\u4ee5\u7528\u7684\u4e2a\u6570\u4e86\n\n\u7136\u540e\u5728\u67e5\u8be2\u65f6\u67e5\u5230\u4e00\u4e2a\u786e\u5b9a\u7684\u91cd\u94fe\u4e0a\u5c31\u53ef\u4ee5\u4e8c\u5206\u7b54\u6848\u4e86\uff08\u4e0d\u5efa\u8bae\u5199\u500d\u589e\uff0c\u56e0\u4e3a\u500d\u589e\u7684\u8bdd\u8fb9\u754c\u60c5\u51b5\u4e0d\u597d\u5904\u7406\uff09\n\n\u5176\u5b9e\u8fd9\u79cd\u9898\u91cd\u70b9\u5e94\u8be5\u662f\u770b\u4ee3\u7801\u5566...\n\n\u6ce8\u610f\u51e0\u4e2a\u7ec6\u8282\uff1a\n\n\u9898\u76ee\u8981\u6c42\u8d77\u70b9\u548c\u7ec8\u70b9\u4e0d\u7b97\uff0c\u56e0\u6b64\u6211\u5728\u4ee3\u7801\u4e2d\u5904\u7406\u6389\u4e86\u8fd9\u4e24\u4e2a\u70b9\uff0c\u628a\u4ed6\u4eec\u4e0a\u79fb\u6216\u4e0b\u79fb\u4e86\u4e00\u4e2a\u4f4d\u7f6e\n\n\u5176\u6b21\uff0c\u6ce8\u610fLCA\u4e0d\u8981\u88ab\u91cd\u590d\u7edf\u8ba1\n\n\u800c\u4e14\uff0c\u4e00\u5b9a\u8981\u6ce8\u610f\u8df3\u7684\u987a\u5e8f\u662f\u8d77\u70b9-LCA-\u7ec8\u70b9\uff0c\u4e0d\u8981\u50cf\u666e\u901a\u7684\u6811\u5256\u90a3\u6837\u8d77\u70b9\u7ec8\u70b9\u4e00\u8d77\u8df3\uff01\n\n\u5269\u4e0b\u770b\u4ee3\u7801\u5427\n\n```cpp\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <vector>\n#define ls tree[rt].lson\n#define rs tree[rt].rson\nusing namespace std;\nstruct Per_Seg_Tree\n{\n    int lson,rson;\n    int siz;\n}tree[8000005];\nint rot[100005];\nint RT=0;\nvector <int> v[100005];\nint siz[100005];\nint son[100005];\nint w[100005];\nint f[100005][25];\nint nnum[100005];\nint ttop[100005];\nint onum[100005];\nint dep[100005];\nint vis[100005];\nint tot=0,cnt=0,ts=0;\nint n,m;\nvoid dfs(int x,int fx)\n{\n    siz[x]=1,f[x][0]=fx,dep[x]=dep[fx]+1;\n    int maxh=0;\n    for(int i=1;i<=20;i++)f[x][i]=f[f[x][i-1]][i-1];\n    for(int i=0;i<v[x].size();i++)\n    {\n        int to=v[x][i];\n        if(to==fx)continue;\n        dfs(to,x);\n        siz[x]+=siz[to];\n        if(siz[to]>maxh)maxh=siz[to],son[x]=to;\n    }\n}\nvoid redfs(int x,int fx,int topx)\n{\n    ttop[x]=topx;\n    nnum[x]=++ts,onum[ts]=x;\n    if(son[x])redfs(son[x],x,topx);\n    for(int i=0;i<v[x].size();i++)\n    {\n        int to=v[x][i];\n        if(to==son[x]||to==fx)continue;\n        redfs(to,x,to);\n    }\n}\nvoid pushup(int rt)\n{\n    tree[rt].siz=tree[ls].siz+tree[rs].siz;\n}\nvoid buildtree(int &rt,int l,int r)\n{\n    rt=++tot;\n    if(l==r){tree[rt].siz=0;return;}\n    int mid=(l+r)>>1;\n    buildtree(ls,l,mid),buildtree(rs,mid+1,r);\n    pushup(rt);\n}\nvoid update(int &rt,int lrt,int l,int r,int pos)\n{\n    rt=++tot;\n    if(l==r){tree[rt].siz=1;return;}\n    int mid=(l+r)>>1;\n    if(pos<=mid)rs=tree[lrt].rson,update(ls,tree[lrt].lson,l,mid,pos);\n    else ls=tree[lrt].lson,update(rs,tree[lrt].rson,mid+1,r,pos);\n    pushup(rt);\n}\nint query(int rt1,int rt2,int l,int r,int lq,int rq)\n{\n    if(l>=lq&&r<=rq)return tree[rt2].siz-tree[rt1].siz;\n    int mid=(l+r)>>1;\n    int s=0;\n    if(lq<=mid)s+=query(tree[rt1].lson,tree[rt2].lson,l,mid,lq,rq);\n    if(rq>mid)s+=query(tree[rt1].rson,tree[rt2].rson,mid+1,r,lq,rq);\n    return s;\n}\nint LCA(int x,int y)\n{\n    while(ttop[x]!=ttop[y])\n    {\n        if(dep[ttop[x]]<dep[ttop[y]])swap(x,y);\n        x=f[ttop[x]][0];\n    }\n    return dep[x]<dep[y]?x:y;\n}\nint Jump(int x,int ed)\n{\n    for(int i=20;i>=0;i--)if(dep[f[x][i]]>dep[ed])x=f[x][i];\n    return x;\n}\nint upsolve(int fr,int to,int qy,int k)\n{\n    int l=nnum[to],r=nnum[fr],ans=to;\n    while(l<=r)\n    {\n        int mid=(l+r)>>1;\n        int num=dep[fr]-dep[onum[mid]]+1;\n        int delt=query(rot[qy],rot[cnt],1,n,mid,nnum[fr]);\n        if(num-delt>=k)ans=onum[mid],l=mid+1;\n        else r=mid-1;\n    }\n    return ans;\n}\nint dosolve(int fr,int to,int qy,int k)\n{\n    int l=nnum[to],r=nnum[fr],ans=to;\n    while(l<=r)\n    {\n        int mid=(l+r)>>1;\n        int num=dep[onum[mid]]-dep[to]+1;\n        int delt=query(rot[qy],rot[cnt],1,n,nnum[to],mid);\n        if(num-delt>=k)ans=onum[mid],r=mid-1;\n        else l=mid+1;\n    }\n    return ans;\n}\nint goup(int st,int ed,int qy,int &k)\n{\n    while(ttop[st]!=ttop[ed])\n    {\n        int num=dep[st]-dep[ttop[st]]+1;\n        int delt=query(rot[qy],rot[cnt],1,n,nnum[ttop[st]],nnum[st]);\n        if(num-delt>=k)\n        {\n            return upsolve(st,ttop[st],qy,k);\n        }else k-=num-delt,st=f[ttop[st]][0];\n    }\n    int num=dep[st]-dep[ed]+1;\n    int delt=query(rot[qy],rot[cnt],1,n,nnum[ed],nnum[st]);\n    if(num-delt>=k)\n    {\n        return upsolve(st,ed,qy,k);\n    }else {k-=num-delt;return 0;}\n}\nint godown(int st,int ed,int qy,int k)\n{\n    if(st==ed)\n    {\n        if(k==1&&vis[st]<=qy)return st;\n        else return 0;\n    }\n    stack <int> S;\n    while(ttop[st]!=ttop[ed])S.push(st),S.push(ttop[st]),st=f[ttop[st]][0];\n    if(st!=ed)S.push(st);\n    else \n    {\n        if(vis[ed]<=qy)\n        {\n            if(k==1)return ed;\n            else k--;\n        }\n        ed=S.top();S.pop();\n    }\n    while(!S.empty())\n    {\n        int u=S.top();\n        S.pop();\n        int num=dep[u]-dep[ed]+1;\n        int delt=query(rot[qy],rot[cnt],1,n,nnum[ed],nnum[u]);\n        if(num-delt>=k)\n        {\n            return dosolve(u,ed,qy,k);\n        }else \n        {\n            k-=num-delt;\n            if(!S.empty()){ed=S.top();S.pop();}\n        }\n    }\n    return 0;\n}\n/*inline int read()\n{\n    int f=1,x=0;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}*/\nint main()\n{\n    //n=read();\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&f[i][0]);\n        if(f[i][0])v[f[i][0]].push_back(i);\n        else RT=i;\n    }    \n    dfs(RT,RT);\n    redfs(RT,RT,RT);\n    buildtree(rot[0],1,n);\n    scanf(\"%d\",&m);\n    for(int i=1;i<=m;i++)\n    {\n        int typ;\n        scanf(\"%d\",&typ);\n        if(typ==1)\n        {\n            int p;\n            w[i]=++cnt;\n            scanf(\"%d\",&p);\n            update(rot[cnt],rot[cnt-1],1,n,nnum[p]),vis[p]=cnt;\n        }else\n        {\n            w[i]=w[i-1];\n            int st,ed,k,y;\n            scanf(\"%d%d%d%d\",&st,&ed,&k,&y);\n            if(f[st][0]==ed||f[ed][0]==st){printf(\"-1\\n\");continue;}\n            y=w[y];\n            int fa=LCA(st,ed);\n            if(fa==st)\n            {\n                st=Jump(ed,fa),ed=f[ed][0];\n                int t=godown(ed,st,y,k);\n                if(!t)printf(\"-1\\n\");\n                else printf(\"%d\\n\",t);\n            }else if(fa==ed)\n            {\n                ed=Jump(st,fa),st=f[st][0];\n                int t=goup(st,ed,y,k);\n                if(!t)printf(\"-1\\n\");\n                else printf(\"%d\\n\",t);\n            }else \n            {\n                st=f[st][0],ed=f[ed][0];\n                int t=goup(st,fa,y,k);\n                if(t)printf(\"%d\\n\",t);\n                else if(ed==fa){printf(\"-1\\n\");continue;}\n                else \n                {\n                    fa=Jump(ed,fa);\n                    t=godown(ed,fa,y,k);\n                    if(t)printf(\"%d\\n\",t);\n                    else printf(\"-1\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1561517315,
        "uid": 66905,
        "name": "leozhang",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF226E \u3010Noble Knight's Path\u3011"
    },
    {
        "content": "\u9898\u610f\u662f\u6c42\u4e00\u6761\u94fe\u4e0a\u7684\u7b2c $k$ \u4e2a\u5728\u7b2c $t$ \u4e2a\u64cd\u4f5c\u524d\u6ca1\u53d8\u9ed1\u7684\u70b9\u3002\n\n\u663e\u7136\u9700\u8981\u53ef\u6301\u4e45\u5316\uff0c\u56e0\u6b64\u53ea\u80fd\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u3002\n\n\u7b80\u5355\u601d\u8003\u53ef\u4ee5\u53d1\u73b0\uff0c\u53ea\u80fd\u5148\u4ece $a \\to lca$ \u627e\u7b54\u6848\u518d $lca \\to b$ \u627e\u7b54\u6848\uff0c\u6ce8\u610f\u8fd9\u91cc $a$ \u548c $b$ \u4e0d\u80fd\u778e\u6362\uff0c\u7136\u540e\u9700\u8981\u6ce8\u610f $a, b$ \u6ca1\u6709\u8d21\u732e\uff0c\u540c\u65f6 $lca$ \u7684\u8d21\u732e\u4e0d\u8981\u7b97\u4e24\u6b21\u3002\n\n\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8fd9\u4e48\u505a\uff0c\u5148\u5c06\u5256\u51fa\u6765\u7684\u533a\u95f4\u6254\u5230\u4e00\u4e2a `vector` \u91cc\u5b58\u7740\uff08\u653e `vector` \u91cc\u662f\u4e3a\u4e86\u65b9\u4fbf\u4e4b\u540e\u56e0\u4e3a\u64cd\u4f5c\u987a\u5e8f\u9700\u8981 `reverse`\uff0c\u7136\u540e\u6309\u7167\u6b63\u786e\u7684\u987a\u5e8f\u626b `vector`\uff0c\u76f4\u5230\u5f53\u524d\u6ee1\u8db3\u6761\u4ef6\u7684\u70b9\u7684\u6570\u91cf\u8d85\u8fc7\u4e86\u8981\u6c42\u7684\u6570\u91cf\uff0c\u7136\u540e\u518d\u628a\u5f53\u524d\u8d85\u7684\u8fd9\u4e2a\u533a\u95f4\u62ce\u51fa\u6765\uff0c\u5728\u4e0a\u9762\u5212\u5206\u6210\u6574\u533a\u95f4\u540e\u4e5f\u5b58\u5230\u4e00\u4e2a `vector` \u91cc\uff08\u540c\u6837\u4e3a\u4e86\u65b9\u4fbf `reverse`\uff09\uff0c\u7136\u540e\u518d\u6309\u7167\u6b63\u786e\u7684\u987a\u5e8f\u626b\u4e00\u904d\u76f4\u5230\u8d85\u4e86\u8981\u6c42\u7684\u6570\u91cf\u5c31\u53ef\u4ee5\u76f4\u63a5\u5728\u8fd9\u4e2a\u6574\u533a\u95f4\u4e0a\u4e3b\u5e2d\u6811\u4e8c\u5206\u4e86\u3002\n\n\u90a3\u600e\u4e48\u8ba1\u7b97\u533a\u95f4\u5185\u6ee1\u8db3\u8981\u6c42\u7684\u70b9\u7684\u6570\u91cf\u6709\u591a\u5c11\u4e2a\uff1f\u6211\u4eec\u5148\u628a\u6240\u6709\u57ce\u5821\u7684\u503c\u8bbe\u4e3a $1$\uff0c\u7136\u540e\u5982\u679c\u6709\u91ce\u86ee\u4eba\u5165\u4fb5\u5c31\u628a\u5b83\u7684\u503c\u8bbe\u4e3a $0$\u3002\u5047\u8bbe\u5f53\u524d\u65f6\u95f4\u662f $t$\uff0c\u9a91\u58eb\u51fa\u53d1\u65f6\u95f4\u662f $y$\uff0c\u90a3\u4e48\u7b54\u6848\u5c31\u662f $t$ \u7248\u672c\u7684\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4 $1$ \u7684\u6570\u91cf $+$ $y$ \u7248\u672c\u7684\u7ebf\u6bb5\u6811\u533a\u95f4 $0$ \u7684\u6570\u91cf\uff0c\u8fd9\u4e2a\u4e5f\u4e0d\u96be\u6c42\u3002\n\n\u4e3b\u8981\u5c31\u662f\u9009\u70b9\u987a\u5e8f\u548c\u91cd\u590d\u8d21\u732e\u90a3\u91cc\u6709\u4e00\u4e9b\u4ee3\u7801\u5b9e\u73b0\u7ec6\u8282\uff0c\u5176\u5b9e\u4e0d\u662f\u5f88\u96be\u5199\u3002\n\n\u4ee3\u7801\u5c31\u522b\u770b\u4e86\uff0c\u6253\u4e86\u4e00\u5806\u8865\u4e01\uff1a[https://codeforces.com/problemset/submission/226/197171854](https://codeforces.com/problemset/submission/226/197171854)",
        "postTime": 1678670633,
        "uid": 202791,
        "name": "louis_11",
        "ccfLevel": 0,
        "title": "CF226E \u9898\u89e3"
    },
    {
        "content": "\u5206\u6790:\n\n\u8fd9\u9898\u5206\u4e3a\u5728\u7ebf\u548c\u79bb\u7ebf\u4e24\u79cd\u505a\u6cd5\u7136\u800c\u6211\u53ea\u4f1a\u5728\u7ebf\n\n\u5728\u7ebf\u7684\u601d\u8def\u5f88\u7b80\u5355\uff0c\u5373\u5148\u6811\u5256\uff0c\u7136\u540e\u5efa\u51fa\u4e3b\u5e2d\u6811\u3002\u4e3b\u5e2d\u6811\u4e00\u7ef4\u7ef4\u62a4\u7684\u662f\u65f6\u95f4\uff0c\u6bcf\u4e00\u68f5\u4e3b\u5e2d\u6811\u5185\u90e8\u7ef4\u62a4\u7684\u662f\u6811\u5256\u5256\u51fa\u6765\u7684\u7ed3\u679c\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e00\u6b21\u8be2\u95ee\uff1a\n\n\u9996\u5148\u5148\u4ece\u4e24\u8fb9\u8df3\u94fe\uff0c\u627e\u5230 LCA\uff0c\u5e76\u627e\u51fa\u4e24\u70b9\u8def\u5f84\u95f4\u6ca1\u6709\u88ab\u201c\u4eb5\u6e0e\u201d\u7684\u57ce\u5821\u6570\u3002\u5982\u679c\u8fd9\u4e00\u6570\u91cf\u5c0f\u4e8e\u8be2\u95ee\uff0c\u76f4\u63a5\u8f93\u51fa \u22121\u3002\n\n\u5426\u5219\uff0c\u5148\u4ece $x$ \u5f80\u4e0a\u4e00\u76f4\u8df3\u5230 LCA\uff0c\u5982\u679c\u8fd9\u4e00\u6bb5\u4e2d\u672a\u88ab\u201c\u4eb5\u6e0e\u201d\u7684\u57ce\u5821\u6570\u5df2\u7ecf\u8db3\u591f\u4e86\uff0c\u5c31\u76f4\u63a5\u8f93\u51fa\uff1b\u5426\u5219\uff0c\u4ece $y$ \u70b9\u5411\u4e0a\u8df3\uff0c\u7c7b\u4f3c\u5730\u627e\u672a\u88ab\u4eb5\u6e0e\u7684\u57ce\u5821\u3002\n\n\u90a3\u600e\u4e48\u8f93\u51fa\u5462\uff1f\u8fd9\u5c31\u8981\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u4e86\u3002\u5f53\u7136\uff0c\u53cd\u6b63\u603b\u590d\u6742\u5ea6\u5df2\u7ecf\u662f $\\log^2$ \u4e86\uff0c\u4f60\u8981\u5acc\u9ebb\u70e6\u76f4\u63a5\u5199 $\\log^2$ \u7684\u4e8c\u5206\u5957\u7ebf\u6bb5\u6811\u4e5f\u6ca1\u6709\u95ee\u9898\uff0c\u6bd5\u7adf\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5199\u8d77\u6765\u786e\u5b9e\u633a\u6076\u5fc3\u7684\u3002\u4e0d\u8fc7\u8fd9\u91cc\u5199\u7684\u8fd8\u662f\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u3002\n\n\u4ee3\u7801\uff1a\n```c\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100100;\nint n,m,des[N];\nint dfn[N],rev[N],fa[N],dep[N],son[N],top[N],sz[N],head[N],cnt,tot;\nstruct node{\n\tint to,next;\n}edge[200100];\nvoid ae(int u,int v){\n\tedge[cnt].next=head[u],edge[cnt].to=v,head[u]=cnt++;\n\tedge[cnt].next=head[v],edge[cnt].to=u,head[v]=cnt++;\n}\nvoid dfs1(int x,int Fa){\n\tfa[x]=Fa,dep[x]=dep[Fa]+1,sz[x]=1;\n\tfor(int i=head[x],y;i!=-1;i=edge[i].next){\n\t\tif((y=edge[i].to)==fa[x])continue;\n\t\tdfs1(y,x),sz[x]+=sz[y];\n\t\tif(sz[son[x]]<sz[y])son[x]=y;\n\t}\n}\nvoid dfs2(int x){\n\tif(son[x])top[son[x]]=top[x],dfn[son[x]]=++tot,rev[tot]=son[x],dfs2(son[x]);\n\tfor(int i=head[x],y;i!=-1;i=edge[i].next){\n\t\ty=edge[i].to;\n\t\tif(y==fa[x]||y==son[x])continue;\n\t\ttop[y]=y,dfn[y]=++tot,rev[tot]=y,dfs2(y);\n\t}\n}\n\n#define mid ((l+r)>>1)\nint rt[N],newid;\nstruct SegTree{\n\tint lson,rson,sum;\n}seg[20001000];\nvoid build(int &x,int l,int r){\n\tx=++newid;\n\tif(l!=r)build(seg[x].lson,l,mid),build(seg[x].rson,mid+1,r);\n}\nvoid modify(int &x,int y,int l,int r,int P){\n\tif(l>P||r<P)return;\n\tseg[x=++newid]=seg[y],seg[x].sum++;\n\tif(l!=r)modify(seg[x].lson,seg[y].lson,l,mid,P),modify(seg[x].rson,seg[y].rson,mid+1,r,P);\n}\nint asksize(int x,int l,int r,int L,int R){\n\tif(l>R||r<L)return 0;\n\tif(L<=l&&r<=R)return seg[x].sum;\n\treturn asksize(seg[x].lson,l,mid,L,R)+asksize(seg[x].rson,mid+1,r,L,R);\n}\nint rangeask(int x,int y,int l,int r,int k){\n\tif(l==r)return rev[l];\n\tif((mid-l+1)-(seg[seg[y].lson].sum-seg[seg[x].lson].sum)>=k)return rangeask(seg[x].lson,seg[y].lson,l,mid,k);\n\telse return rangeask(seg[x].rson,seg[y].rson,mid+1,r,k-((mid-l+1)-(seg[seg[y].lson].sum-seg[seg[x].lson].sum)));\n}\nint askkth(int x,int y,int l,int r,int L,int R,int &k,bool &findans){\n\tif(l>R||r<L)return 0;\n\tif(L<=l&&r<=R){\n\t\tif((r-l+1)-(seg[y].sum-seg[x].sum)>=k){findans=true;return rangeask(x,y,l,r,k);}\n\t\telse{k-=(r-l+1)-(seg[y].sum-seg[x].sum);return 0;};\n\t}\n\tint tmp=askkth(seg[x].lson,seg[y].lson,l,mid,L,R,k,findans);\n\tif(findans)return tmp;\n\treturn askkth(seg[x].rson,seg[y].rson,mid+1,r,L,R,k,findans);\n}\n#define AS(A,B,L,R) (R-L+1)-(asksize(rt[B],1,n,L,R)-asksize(rt[A],1,n,L,R))\nint main(){\n\tscanf(\"%d\",&n),memset(head,-1,sizeof(head));\n\tfor(int i=1,x;i<=n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tif(x)ae(x,i);\n\t}\n\tdfs1(1,0),top[1]=dfn[1]=rev[1]=tot=1,dfs2(1);\n\tbuild(rt[0],1,n);\n\tscanf(\"%d\",&m);\n\tfor(int i=1,a,b,c,d,tp,res;i<=m;i++){\n\t\tscanf(\"%d\",&tp);\n\t\tif(tp==1)scanf(\"%d\",&a),des[a]=i,modify(rt[i],rt[i-1],1,n,dfn[a]);\n\t\telse{\n\t\t\trt[i]=rt[i-1],res=0;\n\t\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\t\tif(des[a]<=d)c++;\n\t\t\tint x=a,y=b,len=0;\n\t\t\twhile(top[x]!=top[y]){\n\t\t\t\tif(dep[top[x]]<dep[top[y]])swap(x,y);\n\t\t\t\tlen+=AS(d,i,dfn[top[x]],dfn[x]),x=fa[top[x]];\n\t\t\t}\n\t\t\tif(dep[x]>dep[y])swap(x,y);\n\t\t\tlen+=AS(d,i,dfn[x],dfn[y]);\n\t\t\tlen-=(des[b]<=d);\n\t\t\tif(len<c){puts(\"-1\");continue;}\t\t\n\t\t\tint LCA=x;\n\t\t\tx=a;\n\t\t\tbool getans=false;\n\t\t\twhile(dep[x]>=dep[LCA]){\n\t\t\t\tint anc=(dep[top[x]]<dep[LCA]?LCA:top[x]);\n\t\t\t\tint tmp=AS(d,i,dfn[anc],dfn[x]);\n\t\t\t\tif(c>tmp)c-=tmp,len-=tmp;\n\t\t\t\telse{c=tmp-c+1;res=askkth(rt[d],rt[i],1,n,dfn[anc],dfn[x],c,getans);break;}\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t\tif(getans){printf(\"%d\\n\",res);continue;}\n\t\t\ty=b;\n\t\t\tc=len-c+1;\n\t\t\tif(des[b]<=d)c++;\n\t\t\twhile(true){\n\t\t\t\tint dfntop=dfn[top[y]];\n\t\t\t\tif(dep[top[y]]<=dep[LCA])dfntop=dfn[LCA]+1;\n\t\t\t\tint tmp=AS(d,i,dfntop,dfn[y]);\n\t\t\t\tif(c>tmp)c-=tmp;\n\t\t\t\telse{c=tmp-c+1;res=askkth(rt[d],rt[i],1,n,dfntop,dfn[y],c,getans);break;}\n\t\t\t\ty=fa[top[y]];\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",res);\n\t\t}\n\t}\n\treturn 0;\n} \n```\n",
        "postTime": 1668176159,
        "uid": 616872,
        "name": "A_better_world",
        "ccfLevel": 3,
        "title": "CF226E"
    }
]