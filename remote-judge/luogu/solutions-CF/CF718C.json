[
    {
        "content": "~~\u54e6\u6211\u8fd9\u4efd\u4ee3\u7801\u597d\u50cf\u80fd\u8fc7QWQ~~\n\n\u9898\u89e3\u5728\u535a\u5ba2[\u98df\u7528](https://www.cnblogs.com/YoungNeal/p/9113761.html)\u6548\u679c\u66f4\u4f73\u54e6~\n\n## Description\n\n\u7ed9\u5b9a\u4e00\u4e2a\u6570\u5217\uff0c\u7ef4\u62a4\u4e24\u79cd\u64cd\u4f5c\n\n\u64cd\u4f5c $1$\uff0c\u5c06\u533a\u95f4 $[l,r]$ \u7684\u6570\u5b57\u7edf\u4e00\u52a0 $x$\u3002\n\n\u64cd\u4f5c $2$\uff0c\u6c42 $\\sum \\limits_{i=l}^r f(val[i])$\uff0c\u5176\u4e2d $f(i)$ \u8868\u793a\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2c $i$ \u9879\u3002\u2018\n\n\u7b54\u6848\u5bf9 $10^9+7$ \u53d6\u6a21\u3002\n\n## Solution\n\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u3002\n\n\u56e0\u4e3a\u662f\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff0c\u5bb9\u6613\u60f3\u5230\u7528\u77e9\u9635\u5feb\u901f\u5e42\u6765\u6c42\u8fd9\u4e2a\u4e1c\u897f\u3002\n\n\u60f3\u8fd9\u6837\u505a\u7684\u8bdd\uff0c\u8981\u60f3\u6e05\u695a\u4e24\u4e2a\u95ee\u9898\uff1a\n\n1. \u56e0\u4e3a\u9898\u76ee\u4e2d\u6c42\u7684\u662f\u548c\uff0c\u90a3\u4e48\u77e5\u9053 $[l,mid]$ \u548c$[mid+1,r]$ \u7684\u7b54\u6848\u80fd\u5426\u5feb\u901f\u5408\u5e76\u51fa $[l,r]$ \u7684\u7b54\u6848\u5462\uff1f\n2. \u5982\u679c\u77e5\u9053\u4e86 $[l,r]$ \u7684\u7b54\u6848\uff0c\u5bf9\u4e8e\u533a\u95f4\u52a0 $x$ \u64cd\u4f5c\uff0c\u80fd\u5426\u5feb\u901f\u5f97\u77e5\u64cd\u4f5c\u540e\u7684\u7b54\u6848\u5462\uff1f\n\n\u5bf9\u4e8e\u7b2c\u4e00\u4e2a\u95ee\u9898\uff0c\u7531\u4e8e\u77e9\u9635\u5177\u6709\u5206\u914d\u5f8b\uff0c\u5373 $a\\times b+a\\times c=a\\times(b+c)$\uff0c\u6240\u4ee5\u5bf9\u4e8e\u4e00\u6bb5\u533a\u95f4\u7684\u77e9\u9635\u53ef\u4ee5\u76f8\u52a0\u7ef4\u62a4\u3002\n\n\u5bf9\u4e8e\u7b2c\u4e8c\u4e2a\u95ee\u9898\uff0c\u663e\u7136\u5c06 $[l,r]$ \u7684\u77e9\u9635\u4e58\u4e0a\u8f6c\u79fb\u77e9\u9635\u7684 $x$ \u6b21\u65b9\u5373\u53ef\u3002\n\n\u7efc\u4e0a\uff0c\u4e24\u4e2a\u95ee\u9898\u60f3\u6e05\u695a\u4e4b\u540e\uff0c\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u533a\u95f4\u4e2d\u7684\u77e9\u9635\u3002\n\n## Code\n\n```cpp\n// By YoungNeal\n#include<cstdio>\n#include<cctype>\n#define N 100005\n#define int long long\nconst int mod=1e9+7;\n\nint n,m;\nint val[N];\n\nstruct Matrix{\n\tint m[4][4];\n\n\tvoid clear(){\n\t\tfor(int i=0;i<4;i++){\n\t\t\tfor(int j=0;j<4;j++)\n\t\t\t\tm[i][j]=0;\n\t\t}\n\t}\n\n\tvoid init(){\n\t\tfor(int i=0;i<4;i++)\n\t\t\tm[i][i]=1;\n\t}\n\n\tvoid print(){\n\t\tfor(int i=1;i<=2;i++){\n\t\t\tfor(int j=1;j<=2;j++)\n\t\t\t\tprintf(\"i=%I64d,j=%I64d,m=%I64d\\n\",i,j,m[i][j]);\n\t\t}\n\t}\n\n\tbool empty(){\n\t\tif(m[1][1]!=1) return 0;\n\t\tif(m[1][2]!=0) return 0;\n\t\tif(m[2][1]!=0) return 0;\n\t\tif(m[2][2]!=1) return 0;\n\t\treturn 1;\n\t}\n\n\tMatrix operator*(const Matrix &y) const {\n\t\tMatrix z; z.clear();\n\t\tfor(int i=1;i<=2;i++){\n\t\t\tfor(int k=1;k<=2;k++){\n\t\t\t\tfor(int j=1;j<=2;j++)\n\t\t\t\t\tz.m[i][j]=(z.m[i][j]+m[i][k]*y.m[k][j])%mod;\n\t\t\t}\n\t\t}\n\t\treturn z;\n\t}\n\n\tfriend Matrix operator+(Matrix a,Matrix b){\n\t\tMatrix c;c.clear();\n\t\tfor(int i=1;i<=2;i++){\n\t\t\tfor(int j=1;j<=2;j++)\n\t\t\t\tc.m[i][j]=(a.m[i][j]+b.m[i][j])%mod;\n\t\t}\n\t\treturn c;\n\t}\n\n};\n\nMatrix dw,fir;\nMatrix mat[N<<2],lazy[N<<2];\n\nint getint(){\n\tint x=0;char ch=getchar();\n\twhile(!isdigit(ch)) ch=getchar();\n\twhile(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\n\nMatrix ksm(Matrix a,int b){\n\tMatrix ret; ret.clear(); ret.init();\n\twhile(b){\n\t\tif(b&1) ret=ret*a;\n\t\ta=a*a;\n\t\tb>>=1;\n\t}\n\treturn ret;\n}\n\nvoid pushup(int cur){\n\tmat[cur]=mat[cur<<1]+mat[cur<<1|1];\n}\n\nvoid build(int cur,int l,int r){\n\tmat[cur].clear();\n\tlazy[cur].clear();\n\tlazy[cur].init();\n\tif(l==r){\n\t\tmat[cur]=fir*ksm(dw,val[l]-1);\n\t\treturn;\n\t}\n\tint mid=l+r>>1;\n\tbuild(cur<<1,l,mid);\n\tbuild(cur<<1|1,mid+1,r);\n\tpushup(cur);\n}\n\nvoid pushdown(int cur,int l,int r){\n\tif(lazy[cur].empty()) return;\n\tmat[cur<<1]=mat[cur<<1]*lazy[cur];\n\tlazy[cur<<1]=lazy[cur<<1]*lazy[cur];\n\tmat[cur<<1|1]=mat[cur<<1|1]*lazy[cur];\n\tlazy[cur<<1|1]=lazy[cur<<1|1]*lazy[cur];\n\tlazy[cur].clear();\n\tlazy[cur].init();\n}\n\nvoid modify(int cur,int ql,int qr,int l,int r,Matrix x){\n\tif(ql<=l and r<=qr){\n\t\tmat[cur]=mat[cur]*x;\n\t\tlazy[cur]=lazy[cur]*x;\n\t\treturn;\n\t}\n\tpushdown(cur,l,r);\n\tint mid=l+r>>1;\n\tif(ql<=mid)\n\t\tmodify(cur<<1,ql,qr,l,mid,x);\n\tif(mid<qr)\n\t\tmodify(cur<<1|1,ql,qr,mid+1,r,x);\n\tpushup(cur);\n}\n\nMatrix query(int cur,int ql,int qr,int l,int r){\n\tif(ql<=l and r<=qr)\n\t\treturn mat[cur];\n\tpushdown(cur,l,r);\n\tMatrix ret;ret.clear();\n\tint mid=l+r>>1;\n\tif(ql<=mid)\n\t\tret=ret+query(cur<<1,ql,qr,l,mid);\n\tif(mid<qr)\n\t\tret=ret+query(cur<<1|1,ql,qr,mid+1,r);\n\treturn ret;\n}\n\nsigned main(){\n\tdw.clear(); fir.clear();\n\tdw.m[1][1]=1;fir.m[1][1]=1;\n\tdw.m[1][2]=1;fir.m[1][2]=1;\n\tdw.m[2][1]=1;fir.m[2][1]=0;\n\tdw.m[2][2]=0;fir.m[2][2]=0;\n\tn=getint(),m=getint();\n\tfor(int i=1;i<=n;i++)\n\t\tval[i]=getint();\n\tbuild(1,1,n);\n\twhile(m--){\n\t\tif(getint()==1){\n\t\t\tint l=getint(),r=getint(),x=getint();\n\t\t\tmodify(1,l,r,1,n,ksm(dw,x));\n\t\t}\n\t\telse{\n\t\t\tint l=getint(),r=getint();\n\t\t\tprintf(\"%I64d\\n\",query(1,l,r,1,n).m[1][2]%mod);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1527688116,
        "uid": 56778,
        "name": "YoungNeal",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF718C \u3010Sasha and Array\u3011"
    },
    {
        "content": "\u600e\u4e48\u5168\u662f\u77e9\u9635\u554aemmm\u6765\u4e2a\u4e0d\u4e00\u6837\u7684\u505a\u6cd5\n\n\u9996\u5148\u6211\u4eec\u6709\u7ed3\u8bba$f_{n+m}=f_nf_{m-1}+f_{n+1}f_m=f_nf_{m+1}+f_{n+1}f_m-f_nf_m$\n\n\u8bc1\u660e\u53ef\u4ee5\u901a\u8fc7\u5c55\u5f00$f_n$\u5f97\u5230:\n\n$\\begin{aligned}f_n&=f_2f_{n-1}+f_1f_{n-2}\\\\&=f_3f_{n-2}+f_2f_{n-3}\\\\&=f_4f_{n-3}+f_3f_{n-4}\\\\&\\cdots\\\\&=f_{m+1}f_{n-m}+f_{m}f_{n-m-1}\\end{aligned}$\n\n\u7c7b\u4f3c\u5730\u6709$f_{n+1+m}=f_nf_m+f_{n+1}f_{m+1}$\n\n\u4e8e\u662f\u6211\u4eec\u53ea\u8981\u7ef4\u62a4\u533a\u95f4$f_n$\u7684\u548c\u4ee5\u53ca$f_{n+1}$\u7684\u548c\u5c31\u597d\u4e86.\u5bf9\u4e8e\u6807\u8bb0\uff0c\u6211\u4eec\u4e5f\u7ef4\u62a4$f_m$\u548c$f_{m+1}$\uff0c\u7136\u540e\u548c\u533a\u95f4\u548c\u4e00\u6837\u4fee\u6539\n\n\u5269\u4e0b\u7684\u95ee\u9898\u5c31\u662f\u5feb\u901f\u8ba1\u7b97$f_n$\u7684\u503c\u4e86.\u9898\u89e3\u90fd\u662f\u77e9\u9635\u5feb\u901f\u5e42\uff0c\u7136\u800c\u6211\u4eec\u6709\u66f4\u5feb\u7684\u505a\u6cd5\n\n\u4f17\u6240\u5468\u77e5$f_n=\\frac{1}{\\sqrt{5}}\\left((\\tfrac{1+\\sqrt{5}}{2})^n-(\\tfrac{1-\\sqrt{5}}{2})^n\\right)$\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u76f4\u63a5\u6309\u7167\u8fd9\u4e2a\u5f0f\u5b50\u8ba1\u7b97.\u7136\u800c$\\sqrt{5}$\u5728\u6a21$1e9+7$\u4e0b\u4e0d\u5b58\u5728\uff0c\u6240\u4ee5\u6211\u4eec\u624b\u5199\u4e00\u4e2a$a+b\\sqrt{5}$\u7c7b\u578b\uff0c\u91cd\u8f7d\u52a0\u51cf\u4e58\u6cd5\u8fd0\u7b97\n\n\u53e6\u4e00\u70b9\u662f\u5feb\u901f\u5e42\u8fd8\u6709$log$\u7684\u590d\u6742\u5ea6\u6bd4\u8f83\u70e6\uff0c\u6211\u4eec\u4f7f\u7528\u5149\u901f\u5e42\uff0c\u5177\u4f53\u5730\uff0c\u6709\n\n$a^b=a^{32768x+y}=(a^{32768})^xa^y$\uff0c\u9884\u5904\u7406$a$\u548c$a^{32768}$\u7684$0$\u5230$32767$\u6b21\u5e42\u5373\u53ef$O(1)$\u6c42\u5e42.\n\n\u7136\u540e\u5c31\u4ee5\u540a\u6253\u5f53\u524drank2 10s\u7684\u901f\u5ea6A\u6389\u4e86\u8fd9\u9053\u9898233\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int LIM=32768,inv2=500000004,inv5=400000003,mod=1e9+7,N=2e6;\nstruct comp\n{\n    int a,b;\n    comp operator +(const comp &t)const{return (comp){(a+t.a)%mod,(b+t.b)%mod};}\n    comp operator -(const comp &t)const{return (comp){(a-t.a)%mod,(b-t.b)%mod};}\n    comp operator *(const comp &t)const{return (comp){(1ll*a*t.a+5ll*b*t.b)%mod,(1ll*a*t.b+1ll*b*t.a)%mod};}\n}pw0[2][LIM+100],pw1[2][LIM+100];\nconst comp F0={inv2,inv2},F1={inv2,mod-inv2};\nstruct Node\n{\n    int s1,s2;\n    Node operator +(const Node &a)const{return (Node){(s1+a.s1)%mod,(s2+a.s2)%mod};}\n    Node operator *(const Node &a)const{return (Node){(1ll*s1*a.s2+1ll*(s2-s1)*a.s1)%mod,(1ll*s1*a.s1+1ll*s2*a.s2)%mod};}\n}a[N],tag[N];\nint w[N],n,m;\nvoid make()\n{\n    pw0[0][0]=pw1[0][0]=pw0[1][0]=pw1[1][0]=(comp){1,0};\n    for(int i=1;i<=LIM;i++)pw0[0][i]=pw0[0][i-1]*F0,pw0[1][i]=pw0[1][i-1]*F1;\n    comp t0=pw0[0][LIM],t1=pw0[1][LIM];\n    for(int i=1;i<=LIM;i++)pw1[0][i]=pw1[0][i-1]*t0,pw1[1][i]=pw1[1][i-1]*t1;\n}\ncomp qpower(int n,int f){return pw1[f][(n>>15)&32767]*pw0[f][n&32767];}\nint F(int n){return ((comp){0,inv5}*(qpower(n,0)-qpower(n,1))).a;}\nvoid build(int rot,int lt,int rt)\n{\n    tag[rot]=(Node){0,1};\n    if(lt==rt){a[rot]=(Node){F(w[lt]),F(w[lt]+1)};return;}\n    int mid=(lt+rt)>>1;\n    build(rot<<1,lt,mid),build(rot<<1|1,mid+1,rt);\n    a[rot]=a[rot<<1]+a[rot<<1|1];\n}\nvoid upd(int rot,Node x){a[rot]=a[rot]*x,tag[rot]=tag[rot]*x;}\nvoid pushdown(int rot)\n{\n    if(tag[rot].s1!=0||tag[rot].s2!=1)\n    {\n        Node t=tag[rot];tag[rot]=(Node){0,1};\n        upd(rot<<1,t),upd(rot<<1|1,t);\n    }\n}\nvoid update(int rot,int lt,int rt,int lq,int rq,Node x)\n{\n    if(lt>=lq&&rt<=rq){upd(rot,x);return;}\n    int mid=(lt+rt)>>1;pushdown(rot);\n    if(lq<=mid)update(rot<<1,lt,mid,lq,rq,x);\n    if(rq>mid)update(rot<<1|1,mid+1,rt,lq,rq,x);\n    a[rot]=a[rot<<1]+a[rot<<1|1];\n}\nint query(int rot,int lt,int rt,int lq,int rq)\n{\n    if(lt>=lq&&rt<=rq)return a[rot].s1;\n    int mid=(lt+rt)>>1;pushdown(rot);\n    if(rq<=mid)return query(rot<<1,lt,mid,lq,rq);\n    else if(lq>mid)return query(rot<<1|1,mid+1,rt,lq,rq);\n    else return (query(rot<<1,lt,mid,lq,mid)+query(rot<<1|1,mid+1,rt,mid+1,rq))%mod;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);make();\n    for(int i=1;i<=n;i++)scanf(\"%d\",w+i);\n    build(1,1,n);\n    for(int i=1;i<=m;i++)\n    {\n        int opt,l,r,x;\n        scanf(\"%d%d%d\",&opt,&l,&r);\n        if(opt==1)scanf(\"%d\",&x),update(1,1,n,l,r,(Node){F(x),F(x+1)});\n        else printf(\"%d\\n\",(query(1,1,n,l,r)+mod)%mod);\n    }\n}\n```",
        "postTime": 1566094587,
        "uid": 22136,
        "name": "qwaszx",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF718C \u3010Sasha and Array\u3011"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u3002\n\n\u672c\u4ee5\u4e3a\u4f1a\u8c03\u4e0d\u77e5\u9053\u591a\u957f\u65f6\u95f4\uff0c\u7ed3\u679c\u4e0d\u5230 50 mins \u5c31\u5b8c\u6210\u4e86\u3002\n\n\u521d\u59cb\u60f3\u6cd5\u662f\u7ef4\u62a4\u539f\u5e8f\u5217\uff0c\u5728\u6c42\u503c\u7684\u65f6\u5019\u518d\u6c42\u6590\u6ce2\u90a3\u5951\u6570\u3002\u4f46\u662f\u611f\u89c9\u8dd1\u7684\u6162\u3002\n\n\u7136\u540e\u51b3\u5b9a\u7ef4\u62a4\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff08\u975e\u77e9\u9635\uff09\uff0c\u4f46\u662f\u53d1\u73b0\u6bcf\u6b21 `update` \u65f6\u6784\u9020\u65b0\u77e9\u9635\u6bd4\u8f83\u9ebb\u70e6\u3002\n\n\u6700\u540e\u624d\u60f3\u5230\u628a\u77e9\u9635\u5f53\u6210\u70b9\u6765\u7ef4\u62a4\u3002\n\n\u6d4b\u5b8c\u8dd1\u4e86 1.1min\uff0c\u770b\u4e86\u4e0b\u9898\u89e3\u533a\u53d1\u73b0\u601d\u8def\u4e5f\u5dee\u4e0d\u592a\u591a\uff1f\n\n## Solution\n\n\u6211\u4eec\u5728\u6bcf\u4e2a\u70b9\u7ef4\u62a4 $\\begin{bmatrix}\nf_i & f_{i-1}      \\\\\n\\end{bmatrix}$ \u8fd9\u6837\u4e00\u4e2a\u77e9\u9635\u3002\n\n\u5bf9\u4e8e\u5efa\u6811\uff0c\u6211\u4eec\u76f4\u63a5\u77e9\u9635\u5feb\u901f\u5e42\u5904\u7406\u51fa\u5f53\u524d $f_{a_i}$ \u6240\u5728\u7684\u77e9\u9635\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u53d6\u548c\u64cd\u4f5c\uff0c\u548c\u7ef4\u62a4\u6574\u6570\u65f6\u4e00\u6837\uff0c\u6bcf\u6b21\u7edf\u8ba1\u77e9\u9635 `sum.z[1][1]` \u7684\u503c\u5373\u53ef\u3002\n\n\u5269\u4e0b\u7684\u64cd\u4f5c\u624d\u662f\u91cd\u70b9\u3002\n\n\u5bf9\u4e8e\u4fee\u6539\u64cd\u4f5c\uff0c\u5728\u539f\u6570\u5217\u4e0a\u662f $a_i \\to a_i +k$\uff0c\u6362\u5230\u6590\u6ce2\u90a3\u5951\u6570\u5c31\u662f $f_{a_i}\\to f_{a_i+k}$\uff0c\u4e5f\u5c31\u662f\u5411\u540e\u79fb $k$ \u9879\u3002\n\n\u6839\u636e\u77e9\u9635\u6c42\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u5f0f\u5b50\uff0c\u6211\u4eec\u5728\u5f53\u524d\u70b9\u7ef4\u62a4\u7684\u77e9\u9635\u4e0a\u4e58\u4e00\u4e2a $\\begin{bmatrix}\n1 & 1      \\\\\n1 & 0\t\n\\end{bmatrix}^{k-1}$ \u5373\u53ef\u3002\u800c\u8fd9\u4e2a\u77e9\u9635\u7528\u77e9\u9635\u5feb\u901f\u5e42\u73b0\u6c42\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u8282\u70b9\u4fe1\u606f\u7684\u4e0a\u4f20\u548c\u61d2\u6807\u8bb0\u7684\u4e0b\u4f20\uff0c\u6211\u4eec\u76f4\u63a5\u76f8\u52a0\u3002\u4e0b\u4f20\u7684\u61d2\u6807\u8bb0\u5c31\u662f\u4e0a\u9762\u7684 $k-1$ \u6b21\u65b9\u77e9\u9635\u3002\n\n\u56e0\u4e3a\u77e9\u9635\u7684\u4e58\u6cd5\u6ee1\u8db3\u5206\u914d\u5f8b\uff0c\u6240\u4ee5\u6211\u4eec\u5148\u5c06\u77e9\u9635\u76f8\u52a0\u518d\u76f8\u4e58\u5bf9\u7b54\u6848\u65e0\u5f71\u54cd\u3002\n\n\u81f3\u4e8e\u91cd\u8f7d\u52a0\u6cd5\u4e58\u6cd5\u8fd0\u7b97\u7b26\u4ec0\u4e48\u7684\u5c31\u4e0d\u8d58\u8ff0\u4e86\u3002\n\n### \u51e0\u4e2a\u95ee\u9898\n\n- \u6ce8\u610f\u53d6\u6a21\u5e76\u5f00 `long long`\u3002\n\n- \u6ce8\u610f\u6bcf\u6b21\u77e9\u9635\u5feb\u901f\u5e42\u65f6\u8981\u5c06 $\\begin{bmatrix}\n1 & 1      \\\\\n1 & 0\t\n\\end{bmatrix}$ \u8fd9\u4e2a\u77e9\u9635\u91cd\u7f6e\u3002\n\n- \u6ce8\u610f\u61d2\u6807\u8bb0\u521d\u59cb\u662f\u5355\u4f4d\u77e9\u9635\u800c\u4e0d\u662f\u96f6\u77e9\u9635\u3002\n\n- \u5efa\u6811\u65f6\u8bb0\u5f97\u7279\u5224\u4e00\u4e0b $a[i]=1\\ \\texttt{or} \\ 2$ \u7684\u60c5\u51b5\u3002\n\n## Code\n\n\u5199\u7684\u6bd4\u8f83\u4e11\uff0c\u5927\u5bb6\u5c06\u5c31\u770b\u5427\u3002\n\n```cpp\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define maxn 400010\n#define INF 0x3f3f3f3f\n#define Mod 1000000007\n#define int long long\n\nusing namespace std;\n\nint n,m,a[maxn];\n\nint read(){\n  int s=0,w=1;char ch=getchar();\n  while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n  while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n  return s*w;\n}\n\nstruct Matrix{\n  int z[4][4];\n  Matrix(){memset(z,0,sizeof z);}\n  Matrix operator * (const Matrix &b) const{\n    Matrix res;\n    for(int i=1;i<=2;i++)\n      for(int j=1;j<=2;j++)\n        for(int k=1;k<=2;k++)\n          res.z[i][k]=(res.z[i][k]+z[i][j]*b.z[j][k])%Mod;\n    return res;\n  }\n  \n  Matrix operator + (const Matrix &b) const{\n    Matrix res;\n    res.z[1][1]=(z[1][1]+b.z[1][1])%Mod;\n    res.z[1][2]=(z[1][2]+b.z[1][2])%Mod;\n    res.z[2][1]=(z[2][1]+b.z[2][1])%Mod;\n    res.z[2][2]=(z[2][2]+b.z[2][2])%Mod;\n    return res;\n  }\n}ans,X;\n\nMatrix quickpow(Matrix Now,int y){\n  while(y){\n    if(y&1) Now=Now*X;\n    X=X*X;y>>=1;\n  }\n  return Now;\n}\n\nnamespace Seg{\n  #define ls x<<1\n  #define rs x<<1|1\n\n  Matrix sum[maxn],lazy[maxn];\n  void pushup(int x){\n    sum[x]=sum[ls]+sum[rs];\n  }\n  \n  void pushdown(int x){\n    if(lazy[x].z[1][1]==1&&lazy[x].z[2][2]==1&&!lazy[x].z[1][2]&&!lazy[x].z[2][1]) return;\n    sum[ls]=sum[ls]*lazy[x];sum[rs]=sum[rs]*lazy[x];\n    lazy[ls]=lazy[ls]*lazy[x];lazy[rs]=lazy[rs]*lazy[x];\n    lazy[x].z[1][1]=lazy[x].z[2][2]=1;lazy[x].z[1][2]=lazy[x].z[2][1]=0;\n  }\n  \n  void build(int x,int l,int r){\n    lazy[x].z[1][1]=lazy[x].z[2][2]=1;\n    if(l==r){\n      X.z[2][2]=0;\n      ans.z[1][1]=ans.z[1][2]=1;\n      X.z[1][1]=X.z[1][2]=X.z[2][1]=1;\n      if(a[l]==1) sum[x].z[1][1]=1;\n      else if(a[l]==2) sum[x].z[1][1]=sum[x].z[1][2]=1;\n      else sum[x]=quickpow(ans,a[l]-2);\n      return;\n    }\n    int mid=l+r>>1;\n    build(ls,l,mid);build(rs,mid+1,r);\n    pushup(x);\n  }\n  \n  void update(int x,int l,int r,int L,int R,Matrix k){\n    if(L<=l&&R>=r){\n      sum[x]=sum[x]*k;\n      lazy[x]=lazy[x]*k;\n      return;\n    }\n    int mid=l+r>>1;pushdown(x);\n    if(L<=mid) update(ls,l,mid,L,R,k);\n    if(R>=mid+1) update(rs,mid+1,r,L,R,k);\n    pushup(x);\n  }\n  \n  int query(int x,int l,int r,int L,int R){\n    int ans=0;\n    if(L<=l&&R>=r)\n      return sum[x].z[1][1]%Mod;\n    int mid=l+r>>1;pushdown(x);\n    if(L<=mid) ans=(ans+query(ls,l,mid,L,R))%Mod;\n    if(R>=mid+1) ans=(ans+query(rs,mid+1,r,L,R))%Mod;\n    return ans;\n  }\n}\n\nsigned main(){\n  n=read();m=read();\n  for(int i=1;i<=n;i++) a[i]=read();\n  Seg::build(1,1,n);\n  for(int i=1,opt,x,y,k;i<=m;i++){\n    opt=read();x=read();y=read();\n    if(opt==1){\n      k=read();X.z[2][2]=0;\n      X.z[1][1]=X.z[1][2]=X.z[2][1]=1;\n      Matrix Base=quickpow(X,k-1);\n      Seg::update(1,1,n,x,y,Base);\n    }\n    else printf(\"%lld\\n\",Seg::query(1,1,n,x,y)%Mod);\n  }\n  return 0;\n}\n```",
        "postTime": 1623939665,
        "uid": 281497,
        "name": "KEBrantily",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF718C  \u3010Sasha and Array\u3011"
    },
    {
        "content": "### \u9898\u76ee\u5927\u610f\n\n$f_i$ \u8868\u793a\u7b2c $i$ \u4e2a\u6590\u6ce2\u90a3\u5951\u6570\u3002\n\n\u7ed9\u5b9a\u957f\u5ea6\u4e3a $n$ \u7684\u5e8f\u5217 $\\{a\\}$ \u548c $m$ \u6b21\u64cd\u4f5c\uff0c\u6bcf\u6b21\u64cd\u4f5c\u5982\u4e0b\uff1a\n\n 1. ```1 l r x``` \u8868\u793a\u5c06 $a_l \\sim a_r$ \u4e2d\u7684\u6bcf\u4e00\u4e2a\u6570\u52a0\u4e0a $x$ \u3002\n \n 2. ```2 l r``` \u8868\u793a\u8be2\u95ee $(\\sum_{i = l}^{r} f_{a_i}) \\mod{10 ^ 9 + 7}$ \u3002\n \n### \u9898\u76ee\u5206\u6790\n\n\u8fd9\u9053\u9898\u662f\u4e0a\u8bfe\u7684\u65f6\u5019 djh \u51fa\u7ed9\u6211\u4eec\u7684\u3002~~\u5f53\u65f6\u4e00\u773c\u79d2\u51fa\u6b63\u89e3~~\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u9996\u5148\u60f3\u60f3\u4e0b\u9762\u51e0\u4e2a\u95ee\u9898\uff1a\n\n1. \u6c42\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7b2c $n$ \u9879 $(n \\leq 10 ^ {18})$ \u3002\n\t\n   \u6b63\u89e3\uff1a\u77e9\u9635\u5feb\u901f\u5e42\u3002\n    \n2. \u6c42\u6590\u6ce2\u90a3\u5951\u6570\u5217\u524d $n$ \u9879\u548c$(n \\leq 10 ^ {5})$ \u3002\n\t\n   Dalao1\uff1a\u8fd8\u662f\u5feb\u901f\u5e42\u554a\uff01\n   \n   Dalao2\uff1a\u524d\u7f00\u548c\u554a\uff01\n   \n3. \u5728\u7b2c\u4e8c\u9898\u4e0a\u518d\u52a0\u4e0a\u4fee\u6539\u5462\uff1f\n\n\t\u6b63\u89e3\uff1a\u7ebf\u6bb5\u6811\u3002\n    \n\u5c06\u77e9\u9635\u5f53\u505a\u70b9\u653e\u5230\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\uff0c\u88ab\u79f0\u4e3a\u77e9\u9635\u7ebf\u6bb5\u6811\u3002\n\n\u5728\u7ebf\u6bb5\u6811\u4e0a\u64cd\u4f5c\uff0c\u9700\u8981\u6ee1\u8db3\u5206\u914d\u5f8b\u548c\u7ed3\u5408\u5f8b\uff0c\u800c\u8fd9\u4e24\u70b9\u77e9\u9635\u5168\u90fd\u6ee1\u8db3\u3002\n\n\u56e0\u6b64\u6211\u4eec\u5c31\u53ef\u4ee5\u5728 $O(m \\log {n})$ \u590d\u6742\u5ea6\u5185\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u4e86\u3002\n\n\n---------\n\n\u8003\u8651\u77e9\u9635 $\\begin{bmatrix}\n f_{n} & f_{n - 1}\\\\\n 0 & 0\n\\end{bmatrix}$\n\uff0c\u5f53\u5b83\u4e58 $\\begin{bmatrix}\n 1 & 1\\\\\n 1 & 0\n\\end{bmatrix}$ \u65f6\uff0c\u5c31\u53ef\u4ee5\u5f97\u5230 $\\begin{bmatrix}\n f_{n + 1} & f_{n}\\\\\n 0 & 0\n\\end{bmatrix}$\uff0c\u5b8c\u6210\u6c42\u6590\u6ce2\u90a3\u5951\u7b2c $n$ \u9879\u3002\n\n\u6211\u4eec\u5c06\u77e9\u9635 $\\begin{bmatrix}\n 1 & 1\\\\\n 1 & 0\n\\end{bmatrix}$ \u79f0\u4e3a\u8f6c\u79fb\u77e9\u9635\u3002\u7528 $A$ \u6765\u8868\u793a\u3002\n\n\u5c06\u6bcf\u4e00\u4e2a $f_{a_i}$ \u7528\u77e9\u9635\u5feb\u901f\u5e42\u6c42\u51fa\u6765\u6254\u5230\u6811\u4e0a\uff0c\u9700\u8981 $O(n \\log{n})$ \u5de6\u53f3\u7684\u590d\u6742\u5ea6\u3002\n\n\u8003\u8651\u64cd\u4f5c\u4e00\u3002\n\n\u5c06 $l \\sim r$ \u4e2d\u6bcf\u4e00\u4e2a\u6590\u6ce2\u90a3\u5951\u6570\u7684\u4e0b\u6807\u589e\u52a0 $x$\uff0c\u76f8\u5f53\u4e8e\u5c06\u6bcf\u4e00\u4e2a\u6570\u6574\u4f53\u53f3\u79fb\u8d8a\u8fc7\u4e86 $x$ \u4e2a\u6590\u6ce2\u90a3\u5951\u6570\u3002\u4e5f\u5c31\u662f\u5c06\u6bcf\u4e00\u4e2a\u6570\u4e58\u4ee5 $x$ \u4e2a\u8f6c\u79fb\u77e9\u9635\u3002\u7531\u4e8e\u77e9\u9635\u4e58\u6cd5\u5177\u6709\u7ed3\u5408\u5f8b\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5c06\u6bcf\u4e00\u4e2a\u6570\u4e58\u4ee5 $A^x$ \u3002\n\n\u7528\u516c\u5f0f\u8868\u793a\u4e00\u4e0b\u5c31\u662f\uff1a\n\n$$ {\\forall } i \\in [l, r], f_i = f_i \\times A ^ x$$\n\n\u8003\u8651\u64cd\u4f5c\u4e8c\u3002\n\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c\u5373\u53ef\u3002\n\n-----------\n\n### \u4ee3\u7801\n\n```\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#define int long long\n\nusing namespace std;\n\nconst int N = 100010, mod = 1e9 + 7;\nint a[N], n, m;\nstruct Matrix\n{\n\tint a[2][2];\n\tvoid clear(int x) {memset(a, x, sizeof a);}\n\tvoid makeI() { a[0][0] = 1; a[0][1] = 0; a[1][0] = 0; a[1][1] = 1; }\n\tbool empty() {return ((a[0][0] == 1) and (a[0][1] == 0) and (a[1][0] == 0) and (a[1][1] == 1));}\n}Turn, st;\n\nMatrix operator + (const Matrix& A, const Matrix& B) {\n\tMatrix res;\n\tres.clear(0);\n\tfor (int i = 0; i <= 1; i ++ )\n\t\tfor (int j = 0; j <= 1; j ++ )\n\t\t\tres.a[i][j] = (A.a[i][j] + B.a[i][j]) % mod;\n\treturn res;\n}\nMatrix operator * (const Matrix& A, const Matrix& B) {\n\tMatrix res;\n\tres.clear(0);\n\tfor (int i = 0; i <= 1; i ++ )\n\t\tfor (int j = 0; j <= 1; j ++ )\n\t\t\tfor (int k = 0; k <= 1; k ++ )\n\t\t\t\t(res.a[i][j] += (A.a[i][k] * B.a[k][j])) %= mod;\n\treturn res;\n}\nMatrix operator ^ (Matrix A, int b) {\n\tMatrix res;\n\tres.makeI();\n\twhile (b) {\n\t\tif (b & 1) res = res * A;\n\t\tA = A * A;//, A = A % mod;\n\t\tb >>= 1;\n\t}\n\treturn res;\n}\n\nnamespace Segment_Tree\n{\n\tstruct Tree\n\t{\n\t\tint l, r;\n\t\tMatrix sum, add;\n\t\t#define ls u << 1\n\t\t#define rs u << 1 | 1\n\t}tr[N << 2];\n\t\n\tvoid pushup(int u) {\n\t\ttr[u].sum = tr[ls].sum + tr[rs].sum;\n\t}\n\tvoid pushdown(int u) {\n\t\tif (!tr[u].add.empty()) {\n\t\t\ttr[ls].add = tr[ls].add * tr[u].add;\n\t\t\ttr[rs].add = tr[rs].add * tr[u].add;\n\t\t\ttr[ls].sum = tr[ls].sum * tr[u].add;\n\t\t\ttr[rs].sum = tr[rs].sum * tr[u].add;\n\t\t\ttr[u].add.makeI();\n\t\t}\n\t}\n\tvoid build(int u, int l, int r) {\n\t\ttr[u] = {l, r};\n\t\ttr[u].add.a[0][0] = tr[u].add.a[1][1] = 1;\n\t\tif (l == r) {\n\t\t\tif (a[l] == 1) tr[u].sum.a[0][0] = 1;\n\t\t\telse tr[u].sum.a[0][0] = tr[u].sum.a[0][1] = 1;\n\t\t\tif(a[l] > 2) tr[u].sum = tr[u].sum * (Turn ^ (a[l] - 2));\n\t\t\treturn;\n\t\t}\n\t\tint mid = l + r >> 1;\n\t\tbuild(ls, l, mid), build(rs, mid + 1, r);\n\t\tpushup(u);\n\t}\n\tvoid modify(int u, int l, int r, Matrix v) {\n\t\tif (tr[u].l >= l && tr[u].r <= r) {\n\t\t\ttr[u].add = tr[u].add * v, tr[u].sum = tr[u].sum * v;\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid = tr[u].l + tr[u].r >> 1;\n\t\tif (l <= mid) modify(ls, l, r, v);\n\t\tif (r > mid) modify(rs, l, r, v);\n\t\tpushup(u);\n\t}\n\tint query(int u, int l, int r) {\n\t\tif (tr[u]. l >= l && tr[u].r <= r) return tr[u].sum.a[0][0];\n\t\tpushdown(u);\n\t\tint mid = tr[u].l + tr[u].r >> 1, res = 0;\n\t\tif (l <= mid) res = (res + query(ls, l, r)) % mod;\n\t\tif (r > mid) res = (res + query(rs, l, r)) % mod;\n\t\treturn res;\n\t}\n}\nusing namespace Segment_Tree;\n\nsigned main()\n{\n\t// Init\n\t{\n\t\tTurn.a[0][0] = Turn.a[0][1] = Turn.a[1][0] = 1;\n\t}\n\t\n\t// Input\n\tscanf(\"%lld%lld\", &n, &m);\n\tfor (int i = 1; i <= n; i ++ )\n\t\tscanf(\"%lld\", &a[i]);\n\tbuild(1, 1, n);\n\t\n\t// Methods\n\twhile (m -- )\n\t{\n\t\tint op, l, r, v;\n\t\tscanf(\"%lld%lld%lld\", &op, &l, &r);\n\t\tif (op == 1) {\n\t\t\tscanf(\"%lld\", &v);\n\t\t\tmodify(1, l, r, Turn ^ v);\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%lld\\n\", query(1, l, r) % mod);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1658718959,
        "uid": 519384,
        "name": "Link_Cut_Y",
        "ccfLevel": 0,
        "title": "\u3010CF718C\u3011 Sasha and Array"
    },
    {
        "content": "## \u601d\u8def\n\n\u8003\u8651\u7528\u77e9\u9635\u8868\u793a\u6590\u6ce2\u90a3\u5951\u6570\u3002\n\n\u5bb9\u6613\u5f97\u77e5\uff0c$f _ 0 = 0$\uff0c$f _ 1 = 1$\uff0c\u4ee4 $2 \\leq k$\uff0c$\\begin {bmatrix} f _ k \\\\ f _ {k - 1} \\end {bmatrix} = \\begin {bmatrix} 1 & 1 \\\\ 1 & 0 \\end {bmatrix} \\times \\begin {bmatrix} f _ {k - 1} \\\\ f _ {k - 2} \\end {bmatrix}$\u3002\n\n\u90a3\u4e48\uff0c\u4ee4 $1 \\leq k$\uff0c$\\begin {bmatrix} f _ k \\\\ f _ {k - 1} \\end {bmatrix} = \\begin {bmatrix} 1 & 1 \\\\ 1 & 0 \\end {bmatrix} ^ {k - 1} \\times \\begin {bmatrix} 1 \\\\ 0 \\end {bmatrix}$\u3002\n\n\u6240\u4ee5\uff0c\u5bf9\u4e8e\u5e8f\u5217\u4e0a\u7684\u6bcf\u4e00\u4e2a\u4f4d\u7f6e $i$\uff0c\u9700\u8981\u7ef4\u62a4 $\\begin {bmatrix} 1 & 1 \\\\ 1 & 0 \\end {bmatrix} ^ {a _ i - 1}$\u3002\u4ee4 $b _ i = \\begin {bmatrix} 1 & 1 \\\\ 1 & 0 \\end {bmatrix} ^ {a _ i - 1}$\uff0c\u5219\u9898\u76ee\u4e2d\u7684\u64cd\u4f5c\u53ef\u4ee5\u8f6c\u5316\u4e3a\u5982\u4e0b\u64cd\u4f5c\uff1a\n\n- \u64cd\u4f5c $1$\uff08\u4fee\u6539\uff09\uff1a\u5bf9\u4e8e\u6240\u6709\u7684 $l \\leq i \\leq r$\uff0c$b _ i \\leftarrow b _ i \\times \\begin {bmatrix} 1 & 1 \\\\ 1 & 0 \\end {bmatrix} ^ x$\u3002\n- \u64cd\u4f5c $2$\uff08\u67e5\u8be2\uff09\uff1a\u6c42 $(\\sum ^ r _ {i = l} b _ i) \\times \\begin {bmatrix} 1 \\\\ 0 \\end {bmatrix}$\u3002\n\n\u5148\u5c01\u88c5\u77e9\u9635\u7c7b\uff0c\u518d\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u5373\u53ef\u3002\u6ce8\u610f\u7ebf\u6bb5\u6811\u4e0a\u7684\u61d2\u6807\u8bb0\u4e5f\u8981\u7528\u77e9\u9635\u8868\u793a\u3002\n\n\u4ee4 $v = 10 ^ 9$\uff0c\u5219\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n \\log v + m ( \\log n + \\log v))$\u3002\n\n## \u4ee3\u7801\n\n```cpp\n#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define LL long long\n#define RI register int\n#define RLL register long long\nusing namespace std;\nnamespace IO\n{\n\tinline int read()\n\t{\n\t\tint f = 1, x = 0;\n\t\tchar c = getchar();\n\t\twhile(c < '0' || c > '9'){\n\t\t\tif(c == '-') f = -1;\n\t\t\tc = getchar();\n\t\t}\n\t\twhile(c >= '0' && c <= '9'){\n\t\t\tx = x * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t\treturn f * x;\n\t}\n\tinline LL read_LL()\n\t{\n\t\tLL f = 1, x = 0;\n\t\tchar c = getchar();\n\t\twhile(c < '0' || c > '9'){\n\t\t\tif(c == '-') f = -1;\n\t\t\tc = getchar();\n\t\t}\n\t\twhile(c >= '0' && c <= '9'){\n\t\t\tx = x * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t\treturn f * x;\n\t}\n\tinline void write(int x)\n\t{\n\t\tif(x < 0){\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tif(x > 9) write(x / 10);\n\t\tputchar(x % 10 + '0');\n\t}\n\tinline void write_LL(LL x)\n\t{\n\t\tif(x < 0){\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tif(x > 9) write(x / 10);\n\t\tputchar(x % 10 + '0');\n\t}\n}\nusing namespace IO;\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\nconst int MAXN = 1e5;\nconst int N = 2;\nconst LL MOD = 1e9 + 7;\nstruct Matrix{\n\tLL a[N + 1][N + 1];\n\tMatrix()\n\t{\n\t\tmemset(a, 0, sizeof a);\n\t}\n\tvoid Build()\n\t{\n\t\tmemset(a, 0, sizeof a);\n\t\tfor(int i = 1; i <= N; i ++) a[i][i] = 1;\n\t}\n\tvoid Initialize_1()\n\t{\n\t\ta[2][2] = 0;\n\t\ta[1][1] = a[1][2] = a[2][1] = 1;\n\t}\n\tvoid Initialize_2()\n\t{\n\t\ta[1][2] = a[2][1] = a[2][2] = 0;\n\t\ta[1][1] = 1;\n\t}\n};\nMatrix operator + (Matrix &x, Matrix &y)\n{\n\tMatrix z = Matrix();\n\tfor(int i = 1; i <= N; i ++){\n\t\tfor(int j = 1; j <= N; j ++){\n\t\t\tz.a[i][j] = (x.a[i][j] + y.a[i][j]) % MOD;\n\t\t}\n\t}\n\treturn z;\n}\nMatrix operator * (Matrix &x, Matrix &y)\n{\n\tMatrix z = Matrix();\n\tfor(int k = 1; k <= N; k ++){\n\t\tfor(int i = 1; i <= N; i ++){\n\t\t\tfor(int j = 1; j <= N; j ++){\n\t\t\t\tz.a[i][j] = (z.a[i][j] + x.a[i][k] * y.a[k][j] % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\treturn z;\n}\nMatrix operator ^ (Matrix x, LL p)\n{\n\tMatrix y = Matrix();\n\ty.Build();\n\twhile(p > 0){\n\t\tif(p % 2 == 1) y = y * x;\n\t\tx = x * x;\n\t\tp = p / 2;\n\t}\n\treturn y;\n}\nstruct Segment_Tree{\n\tstruct Node{\n\t\tMatrix sum;\n\t\tMatrix tag;\n\t\tNode()\n\t\t{\n\t\t\tsum = Matrix();\n\t\t\ttag = Matrix();\n\t\t\ttag.Build();\n\t\t}\n\t};\n\tvector < Node > tree;\n\tvoid Initialize(int n)\n\t{\n\t\ttree.clear();\n\t\tfor(int i = 1; i <= (n << 2); i ++) tree.push_back(Node());\n\t}\n\tvoid Add_Tag(int u, Matrix tag)\n\t{\n\t\ttree[u].sum = tree[u].sum * tag;\n\t\ttree[u].tag = tree[u].tag * tag;\n\t}\n\tvoid Push_Up(int u)\n\t{\n\t\ttree[u].sum = tree[u << 1].sum + tree[u << 1 | 1].sum;\n\t}\n\tvoid Push_Down(int u)\n\t{\n\t\tAdd_Tag(u << 1, tree[u].tag);\n\t\tAdd_Tag(u << 1 | 1, tree[u].tag);\n\t\ttree[u].tag.Build();\n\t}\n\tvoid Build(int u, int l, int r, Matrix a[])\n\t{\n\t\tif(l > r) return;\n\t\tif(l == r){\n\t\t\ttree[u].sum = a[l];\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tBuild(u << 1, l, mid, a);\n\t\tBuild(u << 1 | 1, mid + 1, r, a);\n\t\tPush_Up(u);\n\t}\n\tvoid Multiply(int u, int l, int r, int L, int R, Matrix V)\n\t{\n\t\tif(l > r || l > R || r < L) return;\n\t\tif(l >= L && r <= R){\n\t\t\tAdd_Tag(u, V);\n\t\t\treturn;\n\t\t}\n\t\tint mid = (l + r) >> 1;\n\t\tPush_Down(u);\n\t\tMultiply(u << 1, l, mid, L, R, V);\n\t\tMultiply(u << 1 | 1, mid + 1, r, L, R, V);\n\t\tPush_Up(u);\n\t}\n\tMatrix Query_Sum(int u, int l, int r, int L, int R)\n\t{\n\t\tif(l > r || l > R || r < L) return Matrix();\n\t\tif(l >= L && r <= R) return tree[u].sum;\n\t\tint mid = (l + r) >> 1;\n\t\tPush_Down(u);\n\t\tMatrix res_1 = Query_Sum(u << 1, l, mid, L, R);\n\t\tMatrix res_2 = Query_Sum(u << 1 | 1, mid + 1, r, L, R);\n\t\treturn res_1 + res_2;\n\t}\n};\nint n, m;\nint type, l, r, x;\nint a[MAXN + 5];\nMatrix b[MAXN + 5];\nMatrix tmp_1, tmp_2;\nSegment_Tree tree;\nvoid solve()\n{\n\tn = read(), m = read();\n\tfor(int i = 1; i <= n; i ++){\n\t\ta[i] = read();\n\t\tb[i].Initialize_1();\n\t\tb[i] = b[i] ^ (a[i] - 1);\n\t}\n\ttree.Initialize(n);\n\ttree.Build(1, 1, n, b);\n\twhile(m --){\n\t\ttype = read(), l = read(), r = read();\n\t\tif(type == 1){\n\t\t\tx = read();\n\t\t\ttmp_1.Initialize_1();\n\t\t\ttmp_1 = tmp_1 ^ x;\n\t\t\ttree.Multiply(1, 1, n, l, r, tmp_1);\n\t\t}\n\t\tif(type == 2){\n\t\t\ttmp_1 = tree.Query_Sum(1, 1, n, l, r);\n\t\t\ttmp_2.Initialize_2();\n\t\t\ttmp_2 = tmp_1 * tmp_2;\n\t\t\twrite(tmp_2.a[1][1]), putchar('\\n');\n\t\t}\n\t}\n}\n```\n\n## \u95f2\u8bdd\n\n\u6211\u968f\u624b\u628a\u77e9\u9635\u5927\u5c0f\u5f00\u4e86 $7 \\times 7$\uff0c\u7ed3\u679c\u6536\u83b7\u4e86\u4e00\u5806 MLE\u3002\n\n2022.5.25",
        "postTime": 1653446929,
        "uid": 232838,
        "name": "huangkx",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF718C Sasha and Array"
    },
    {
        "content": "\u9700\u8981\u638c\u63e1\u7ebf\u6bb5\u6811\u548c\u4e00\u70b9\u7ebf\u6027\u4ee3\u6570\u7684\u57fa\u7840\u3002\n\n\u6839\u636e\u6590\u6ce2\u90a3\u5951\u6570\u5217\u5b9a\u4e49 $F_n=F_{n-1}+F_{n-2}$\uff0c\u6709 $\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}\\begin{bmatrix}F_{n-1}\\\\F_{n-2}\\end{bmatrix}=\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}$\u3002\u6545\u53ef\u4ee5\u4f7f\u7528\u77e9\u9635\u63cf\u8ff0\u8f6c\u79fb\uff0c\u5feb\u901f\u6c42\u51fa $F_n$\u3002\n\n\u82e5\u521d\u59cb\u5411\u91cf\u8bbe\u4e3a $\\begin{bmatrix}F_2\\\\F_1\\end{bmatrix}$ \u5219 $\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}=\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^{n-2}\\begin{bmatrix}F_2\\\\F_1\\end{bmatrix}$\uff0c\u53ef\u80fd\u51fa\u73b0\u6307\u6570 $n-2\\leqslant0$ \u7684\u60c5\u51b5\u3002\u4e0d\u59a8\u62d3\u5bbd\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u5b9a\u4e49\uff0c\u6309\u7167 $F_n=F_{n-1}+F_{n-2}$ \u63a8\u51fa $F_{-1}=1,F_0=0$ \u5e76\u628a\u521d\u59cb\u5411\u91cf\u8bbe\u4e3a $\\begin{bmatrix}F_0\\\\F_{-1}\\end{bmatrix}$\uff0c\u6b64\u65f6 $\\begin{bmatrix}F_{n}\\\\F_{n-1}\\end{bmatrix}=\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^n\\begin{bmatrix}F_0\\\\F_{-1}\\end{bmatrix}$\uff0c\u65e0\u9700\u8003\u8651\u6307\u6570\u4e3a\u8d1f\u7684\u60c5\u51b5\u3002\u540c\u65f6\u7531\u4e8e\u521d\u59cb\u5411\u91cf\u4e3a $\\begin{bmatrix}F_0\\\\F_{-1}\\end{bmatrix}=\\begin{bmatrix}0\\\\1\\end{bmatrix}$\uff0c\u4e8c\u9636\u77e9\u9635\u4e58\u5176\u7b49\u4ef7\u4e8e\u53d6\u4e8c\u9636\u77e9\u9635\u7684 $(1,2)$ \u5143\u3002\n\n\u8981\u6c42\u533a\u95f4\u548c\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u7ef4\u62a4\u7684\u8282\u70b9\u4e3a\u7531\u521d\u59cb\u5411\u91cf\u8f6c\u79fb\u5230\u6240\u6c42\u533a\u95f4\u548c\u7684\u77e9\u9635\u3002\u8003\u8651\u533a\u95f4\u5408\u5e76\u7684\u64cd\u4f5c\n\n$\\begin{bmatrix}F_a+F_b\\\\F_{a-1}+F_{b-1}\\end{bmatrix}$\n\n$=\\begin{bmatrix}F_a\\\\F_{a-1}\\end{bmatrix}+\\begin{bmatrix}F_b\\\\F_{b-1}\\end{bmatrix}$\n\n$=\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^a\\begin{bmatrix}F_{0}\\\\F_{-1}\\end{bmatrix}+\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^b\\begin{bmatrix}F_{0}\\\\F_{-1}\\end{bmatrix}$\n\n$=(\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^a+\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^b)\\begin{bmatrix}F_{0}\\\\F_{-1}\\end{bmatrix}$\n\n\u5373\u4f7f\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u6590\u6ce2\u90a3\u5951\u6570\u5217\u533a\u95f4\u548c\u65f6\u53ef\u4ee5\u76f4\u63a5\u628a\u8f6c\u79fb\u77e9\u9635\u76f8\u52a0\u3002\n\n\u800c\u628a $[l,r]$ \u533a\u95f4\u52a0\u4e0a $x$ \u7684\u64cd\u4f5c\u76f8\u5f53\u4e8e\u628a\u533a\u95f4\u5185\u7684\u6590\u6ce2\u90a3\u5951\u6570\u90fd\u5411\u540e\u8f6c\u79fb $x$ \u9879\uff0c\u6545\u628a\u533a\u95f4\u5185\u7684\u8282\u70b9\u4e58\u4e0a\u8f6c\u79fb\u77e9\u9635\u7684 $x$ \u6b21\u65b9 $\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}^x$\u5373\u53ef\u3002\n\n\u5230\u6b64\uff0c\u5f97\u51fa\u4e86\u6b64\u9898\u7684\u601d\u8def\u3002\n\n```\n#include <iostream>\n#include <cstdio>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\nll n,m;\nstruct matrix\n{\n\tll a[3][3];\n\tmatrix(ll a11=0,ll a12=0,ll a21=0,ll a22=0)\n\t{\n\t\ta[1][1]=a11;\n\t\ta[1][2]=a12;\n\t\ta[2][1]=a21;\n\t\ta[2][2]=a22;\n\t}\n\tfriend bool operator!=(matrix a,matrix b)\n\t{\n\t\treturn (a.a[1][1]!=b.a[1][1])|(a.a[1][2]!=b.a[1][2])|(a.a[2][1]!=b.a[2][1])|(a.a[2][2]!=b.a[2][2]);\n\t}\n\tfriend matrix operator+(matrix a,matrix b)\n\t{\n\t\treturn matrix((a.a[1][1]+b.a[1][1])%mod,(a.a[1][2]+b.a[1][2])%mod,(a.a[2][1]+b.a[2][1])%mod,(a.a[2][2]+b.a[2][2])%mod);\n\t}\n\tfriend matrix operator*(matrix a,matrix b)\n\t{\n\t\treturn matrix((a.a[1][1]*b.a[1][1]+a.a[1][2]*b.a[2][1])%mod,(a.a[1][1]*b.a[1][2]+a.a[1][2]*b.a[2][2])%mod,(a.a[2][1]*b.a[1][1]+a.a[2][2]*b.a[2][1])%mod,(a.a[2][1]*b.a[1][2]+a.a[2][2]*b.a[2][2])%mod);//\u77e9\u9635\u9636\u6570\u56fa\u5b9a\uff0c\u4e58\u6cd5\u53ef\u4ee5\u628a\u5faa\u73af\u5c55\u5f00 \n\t}\n\tfriend matrix operator^(matrix x,ll y)\n\t{\n\t\tmatrix res(1,0,0,1);//\u77e9\u9635\u4e58\u6cd5\u5355\u4f4d\u5143\uff0c\u5373\u77e9\u9635\u76840\u6b21\u65b9\n\t\twhile(y)\n\t\t{\n\t\t\tif(y&1) res=res*x;\n\t\t\tx=x*x;\n\t\t\ty>>=1;\n\t\t}\n\t\treturn res;\n\t}\n}zero,unit(1,0,0,1),base(1,1,1,0),val[400001],lazy[400001];\nvoid pushup(ll rt)\n{\n\tval[rt]=val[rt<<1]+val[rt<<1|1];\n}\nvoid pushdown(ll rt)\n{\n\tlazy[rt<<1]=lazy[rt<<1]*lazy[rt];\n\tlazy[rt<<1|1]=lazy[rt<<1|1]*lazy[rt];\n\tval[rt<<1]=val[rt<<1]*lazy[rt];\n\tval[rt<<1|1]=val[rt<<1|1]*lazy[rt];\n\tlazy[rt]=unit; \n}\nvoid build(ll rt,ll l,ll r)\n{\n\tif(l>r) return;\n\tlazy[rt]=unit;\n\tif(l==r)\n\t{\n\t\tll x;\n\t\tscanf(\"%lld\",&x);\n\t\tval[rt]=base^x;\n\t\treturn;\n\t}\n\tll mid=l+r>>1;\n\tbuild(rt<<1,l,mid);\n\tbuild(rt<<1|1,mid+1,r);\n\tpushup(rt);\n}\nvoid upd(ll rt,ll l,ll r,ll L,ll R,matrix m)//\u53c2\u6570\u4f20\u9012\u7684\u662f\u77e9\u9635\u7684\u5e42\u800c\u4e0d\u662f\u77e9\u9635\u7684\u6307\u6570\uff0c\u9632\u6b62\u8d85\u65f6 \n{\n\tif(l>R||r<L) return;\n\tif(L<=l&&r<=R)\n\t{\n\t\tlazy[rt]=m*lazy[rt];\n\t\tval[rt]=m*val[rt];\n\t\treturn;\n\t}\n\tif(lazy[rt]!=unit) pushdown(rt);\n\tll mid=l+r>>1;\n\tupd(rt<<1,l,mid,L,R,m);\n\tupd(rt<<1|1,mid+1,r,L,R,m);\n\tpushup(rt);\n}\nmatrix query(ll rt,ll l,ll r,ll L,ll R)\n{\n\tif(l>R||r<L) return zero;\n\tif(L<=l&&r<=R) return val[rt];\n\tif(lazy[rt]!=unit) pushdown(rt);\n\tll mid=l+r>>1;\n\treturn query(rt<<1,l,mid,L,R)+query(rt<<1|1,mid+1,r,L,R);\n}\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&m);\n\tbuild(1,1,n);\n\tfor(int i=1;i<=m;++i)\n\t{\n\t\tll op;\n\t\tscanf(\"%lld\",&op);\n\t\tif(op==1)\n\t\t{\n\t\t\tll l,r,x;\n\t\t\tscanf(\"%lld%lld%lld\",&l,&r,&x);\n\t\t\tupd(1,1,n,l,r,base^x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tll l,r;\n\t\t\tscanf(\"%lld%lld\",&l,&r);\n\t\t\tprintf(\"%lld\\n\",query(1,1,n,l,r).a[1][2]);//\u53d6\u77e9\u9635\u7684(1,2)\u5143\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1657691375,
        "uid": 244009,
        "name": "TianTian2008",
        "ccfLevel": 0,
        "title": "CF718C \u9898\u89e3"
    },
    {
        "content": "~~\u6211\u4eec\u8003\u8651\u7ebf\u6027\u4ee3\u6570\u4e0a\u9762\u7684\u77e9\u9635\u77e5\u8bc6~~\n\n\u554a\u5478\uff0c\u662f\u57fa\u7840\u6570\u5b66\n\n\u6590\u6ce2\u90a3\u5951\u7684\u77e9\u9635\u5c31\u4e0d\u8bb2\u4e86\n\n\u5b9a\u4e49\u77e9\u9635 $f_x$ \u662f\u7b2c $x$ \u9879\u7684\u6590\u6ce2\u90a3\u5951\u77e9\u9635\n\n\u56e0\u4e3a\n$f_i * f_j = f_{i+j}$\n\n\u7136\u540e\u53c8\u56e0\u4e3a $\\texttt{AB+AC=A(B+C)}$\n\n\u6240\u4ee5 $\\sum_{i=l}^{r} f(a_i+x) = f(x)\\sum_{i=l}^{r} f(a_i)$\n\n\u7ebf\u6bb5\u6811\u677f\u5b50\u9898\uff0c\u7ef4\u62a4\u4e00\u4e2a\u77e9\u9635\uff0c\u8fd9\u9898\u6ca1\u4e86\n\n```cpp\n// by Isaunoya\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, x, y) for (register int i = (x); i <= (y); ++i)\n#define Rep(i, x, y) for (register int i = (x); i >= (y); --i)\n#define int long long\n\nconst int _ = 1 << 21;\nstruct I {\n\tchar fin[_], *p1 = fin, *p2 = fin;\n\tinline char gc() {\n\t\treturn (p1 == p2) && (p2 = (p1 = fin) + fread(fin, 1, _, stdin), p1 == p2) ? EOF : *p1++;\n\t}\n\tinline I& operator>>(int& x) {\n\t\tbool sign = 1;\n\t\tchar c = 0;\n\t\twhile (c < 48) ((c = gc()) == 45) && (sign = 0);\n\t\tx = (c & 15);\n\t\twhile ((c = gc()) > 47) x = (x << 1) + (x << 3) + (c & 15);\n\t\tx = sign ? x : -x;\n\t\treturn *this;\n\t}\n\tinline I& operator>>(double& x) {\n\t\tbool sign = 1;\n\t\tchar c = 0;\n\t\twhile (c < 48) ((c = gc()) == 45) && (sign = 0);\n\t\tx = (c - 48);\n\t\twhile ((c = gc()) > 47) x = x * 10 + (c - 48);\n\t\tif (c == '.') {\n\t\t\tdouble d = 1.0;\n\t\t\twhile ((c = gc()) > 47) d = d * 0.1, x = x + (d * (c - 48));\n\t\t}\n\t\tx = sign ? x : -x;\n\t\treturn *this;\n\t}\n\tinline I& operator>>(char& x) {\n\t\tdo\n\t\t\tx = gc();\n\t\twhile (isspace(x));\n\t\treturn *this;\n\t}\n\tinline I& operator>>(string& s) {\n\t\ts = \"\";\n\t\tchar c = gc();\n\t\twhile (isspace(c)) c = gc();\n\t\twhile (!isspace(c) && c != EOF) s += c, c = gc();\n\t\treturn *this;\n\t}\n} in;\nstruct O {\n\tchar st[100], fout[_];\n\tsigned stk = 0, top = 0;\n\tinline void flush() {\n\t\tfwrite(fout, 1, top, stdout), fflush(stdout), top = 0;\n\t}\n\tinline O& operator<<(int x) {\n\t\tif (top > (1 << 20)) flush();\n\t\tif (x < 0) fout[top++] = 45, x = -x;\n\t\tdo\n\t\t\tst[++stk] = x % 10 ^ 48, x /= 10;\n\t\twhile (x);\n\t\twhile (stk) fout[top++] = st[stk--];\n\t\treturn *this;\n\t}\n\tinline O& operator<<(char x) {\n\t\tfout[top++] = x;\n\t\treturn *this;\n\t}\n\tinline O& operator<<(string s) {\n\t\tif (top > (1 << 20)) flush();\n\t\tfor (char x : s) fout[top++] = x;\n\t\treturn *this;\n\t}\n} out;\n#define pb emplace_back\n#define fir first\n#define sec second\n\ntemplate < class T > inline void cmax(T & x , const T & y) {\n\t(x < y) && (x = y) ;\n}\ntemplate < class T > inline void cmin(T & x , const T & y) {\n\t(x > y) && (x = y) ;\n}\n\nconst int mod = 1e9 + 7 ;\nconst int maxn = 1e5 + 51 ;\nstruct matrix {\n\tint a[3][3] ;\n\tmatrix () {\n\t\trep(i , 1 , 2) rep(j , 1 , 2) a[i][j] = 0 ;\n\t}\n\tvoid clr() {\n\t\trep(i , 1 , 2) rep(j , 1 , 2) a[i][j] = 0 ;\n\t\trep(i , 1 , 2) a[i][i] = 1 ;\n\t}\n\tbool empty() {\n\t\tif(a[1][1] ^ 1) return false ;\n\t\tif(a[1][2] || a[2][1]) return false ;\n\t\tif(a[2][2] ^ 1) return false ;\n\t\treturn true ;\n\t}\n\tmatrix operator * (const matrix & other) const {\n\t\tmatrix res ;\n\t\trep(i , 1 , 2) rep(j , 1 , 2) {\n\t\t\tres.a[i][j] = 0 ;\n\t\t\trep(k , 1 , 2) res.a[i][j] = (res.a[i][j] + a[i][k] * other.a[k][j]) % mod ;\n\t\t}\n\t\treturn res ;\n\t}\n\tmatrix operator + (const matrix & other) const {\n\t\tmatrix res ;\n\t\trep(i , 1 , 2) rep(j , 1 , 2) res.a[i][j] = (a[i][j] + other.a[i][j] >= mod) ? a[i][j] + other.a[i][j] - mod : a[i][j] + other.a[i][j] ;\n\t\treturn res ; \n\t}\n} ;\nmatrix qwq ;\nmatrix qpow(matrix a , int k) {\n\tmatrix res = a ; -- k ;\n\tfor( ; k ; a = a * a , k >>= 1)\n\t\tif(k & 1) res = res * a ;\n\treturn res ;\n}\nint n , m ;\nint a[maxn] ;\nmatrix s[maxn << 2] , tag[maxn << 2] ;\nvoid build(int l , int r , int o) {\n\ttag[o].clr() ;\n\tif(l == r) {\n\t\ts[o] = qpow(qwq , a[l]) ;\n\t\treturn ;\n\t}\n\tint mid = l + r >> 1 ;\n\tbuild(l , mid , o << 1) ;\n\tbuild(mid + 1 , r , o << 1 | 1) ;\n\ts[o] = s[o << 1] + s[o << 1 | 1] ;\n}\nvoid psd(int o) {\n\tif(tag[o].empty()) return ;\n\ttag[o << 1] = tag[o << 1] * tag[o] ;\n\ttag[o << 1 | 1] = tag[o << 1 | 1] * tag[o] ;\n\ts[o << 1] = s[o << 1] * tag[o] ;\n\ts[o << 1 | 1] = s[o << 1 | 1] * tag[o] ;\n\ttag[o].clr() ;\n}\nvoid upd(int a , int b , int l , int r , matrix x , int o) {\n\tif(a <= l && r <= b) {\n\t\ts[o] = s[o] * x ;\n\t\ttag[o] = tag[o] * x ;\n\t\treturn ;\n\t}\n\tpsd(o) ;\n\tint mid = l + r >> 1 ;\n\tif(a <= mid) upd(a , b , l , mid , x , o << 1) ;\n\tif(b > mid) upd(a , b , mid + 1 , r , x , o << 1 | 1) ;\n\ts[o] = s[o << 1] + s[o << 1 | 1] ;\n}\nmatrix qry(int a , int b , int l , int r , int o) {\n\tif(a <= l && r <= b) {\n\t\treturn s[o] ;\n\t} psd(o) ;\n\tint mid = l + r >> 1 ;\n\tmatrix res ;\n\tif(a <= mid) res = res + qry(a , b , l , mid , o << 1) ;\n\tif(b > mid) res = res + qry(a , b , mid + 1 , r , o << 1 | 1) ;\n\treturn res ;\n}\nsigned main() {\n#ifdef _WIN64\n\tfreopen(\"testdata.in\" , \"r\" , stdin) ;\n#endif\n\tqwq.a[1][1] = qwq.a[1][2] = qwq.a[2][1] = 1 ;\n\tqwq.a[2][2] = 0 ;\n\tin >> n >> m ;\n\trep(i , 1 , n) in >> a[i] ;\n\tbuild(1 , n , 1) ;\n\twhile(m --) {\n\t\tint opt ;\n\t\tin >> opt ;\n\t\tif(opt == 1) {\n\t\t\tint l , r , v ;\n\t\t\tin >> l >> r >> v ;\n\t\t\tupd(l , r , 1 , n , qpow(qwq , v) , 1) ;\n\t\t}\n\t\telse {\n\t\t\tint l , r ;\n\t\t\tin >> l >> r ;\n\t\t\tout << qry(l , r , 1 , n , 1).a[1][2] << '\\n' ;\n\t\t}\n\t}\n\treturn out.flush(), 0;\n}\n```",
        "postTime": 1579952668,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF718C \u3010Sasha and Array\u3011"
    },
    {
        "content": "## \u9898\u9762\n\n\u5b9a\u4e49 $F_i$ \u4e3a \u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u7b2c $i$ \u9879\u7684\u6570\u3002\u4f60\u9700\u8981\u5b9e\u73b0\u4e00\u4e2a\u6570\u636e\u7ed3\u6784 $a[]$\uff0c\u652f\u6301\uff1a\n\n`1 l r x`\uff1a\u5c06 $[l,r]$ \u7684\u6570\u52a0\u4e0a $x$\u3002\n\n`2 l r`\uff1a\u6c42 $\\sum\\limits_{i=l}^{r}{F_{a[i]}}$\u3002\n\n$1 \\le n,m \\le 10^{5},1 \\le a[i] \\le 10^{9}$\n\n## \u601d\u8def\n\n\u4e0d\u96be\u770b\u51fa\u662f\u7ebf\u6bb5\u6811\uff0c\u4f46\u662f\u600e\u4e48\u8ba1\u7b97 $F_i$ \u5462\uff1f\n\n\u5982\u679c\u66b4\u529b\u53bb\u8ba1\u7b97 $F_i$\uff0c\u663e\u7136\u662f\u4e0d\u9760\u8c31\u7684\uff08\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(i)$\uff09\u3002\n\n\u5982\u679c\u4f7f\u7528\u6590\u6ce2\u90a3\u5951\u672b\u9879\u8ba1\u7b97\u516c\u5f0f\uff08\u53c2\u89c1 [P1720 \u6708\u843d\u4e4c\u557c\u7b97\u94b1\uff08\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff09](https://www.luogu.com.cn/problem/P1720)\uff09\u4e5f\u4e0d\u9760\u8c31\uff0c\u4e0d\u5bb9\u6613\u7ef4\u62a4\u3002\n\n\u5982\u679c\u505a\u8fc7 [P1962 \u6590\u6ce2\u90a3\u5951\u6570\u5217](https://www.luogu.com.cn/problem/P1962) \u7684\u540c\u5b66\u53ef\u80fd\u77e5\u9053\uff0c\u53ef\u4ee5\u7528\u77e9\u9635\u5feb\u901f\u5e42\u8ba1\u7b97\u3002\n\n\u5927\u81f4\u516c\u5f0f\u5982\u4e0b\uff1a\n\n$$([1\\ 1] \\times \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}^{i-1})_{1,2} = F_i$$\n\n[OI-Wiki](https://oi-wiki.org/math/matrix/#_9) \u4e0a\u6709\u8bc1\u660e\u3002\n\n\u7136\u540e\u5c31\u662f\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u4fee\u6539\u533a\u95f4\u67e5\u8be2\u7ebf\u6bb5\u6811\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u662f $O(n\\log^2n)$\u3002\n\n## \u4ee3\u7801\n\n\u4ee3\u7801\u91cc\u9762\u6709\u5c01\u88c5\u597d\u4e86\u7684\u77e9\u9635\u6a21\u677f\uff0c\u4f9b\u5927\u5bb6\u968f\u610f\u4f7f\u7528\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define ls (i<<1)\n#define rs (i<<1|1)\n#define mid ((l+r)>>1)\n#define int long long\nusing namespace std;\n\nconst int MOD = 1e9+7;\n\nstruct Matrix{\n\tint a[3][3];\n\tconst int size = 2;\n\tMatrix(){\n\t\tmemset(a,0,sizeof(a));\n\t}\n\tMatrix(int aba){\n\t\ta[aba][aba]=1;\n\t\ta[aba][aba+1]=0;\n\t\ta[aba+1][aba]=0;\n\t\ta[aba+1][aba+1]=1;\n\t}\n\tMatrix(int A,int b,int c,int d){\n\t\ta[1][1]=A;\n\t\ta[1][2]=b;\n\t\ta[2][1]=c;\n\t\ta[2][2]=d;\n\t}\n\tMatrix operator*(const Matrix &ano) const {\n\t\tMatrix ans;\n\t\tfor(int i=1;i<=size;i++){\n\t\t\tfor(int k=1;k<=size;k++){\n\t\t\t\tfor(int j=1;j<=size;j++){\n\t\t\t\t\tans.a[i][k]=(ans.a[i][k]+a[i][j]*ano.a[j][k])%MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\t\n\tMatrix operator+(const Matrix aa){\n\t\tMatrix res;\n\t\tfor(int i=1;i<=size;i++){\n\t\t\tfor(int j=1;j<=size;j++){\n\t\t\t\tres.a[i][j]=a[i][j]+aa.a[i][j];\n\t\t\t\tres.a[i][j]%=MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid operator=(const Matrix A){\n\t\tfor(int i=1;i<=size;i++){\n\t\t\tfor(int j=1;j<=size;j++){\n\t\t\t\ta[i][j]=A.a[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tbool empty(){\n\t\treturn (a[1][1]==0)&&(a[1][2]==0)&&(a[2][1]==0)&&(a[2][2]==0);\n\t}\n\tMatrix operator^(int power){\n\t\tMatrix res(1);\n\t\tMatrix base = (*this);\n\t\twhile(power){\n\t\t\tif(power&1){\n\t\t\t\tres=res*base;\n\t\t\t}\n\t\t\tbase=base*base;\n\t\t\tpower>>=1;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\n\nconst int SIZE = 1e5+5;\nMatrix t[SIZE<<2],tag[SIZE<<2];\nint v[SIZE];\nconst Matrix unit(1);\nint n,m;\n\ninline void pushup(int i){\n\tt[i]=t[ls]+t[rs];\n}\n\nvoid build(int i,int l,int r){\n\ttag[i]=unit;\n\tif(l==r){\n\t\tt[i]=Matrix(1,1,0,0)*(Matrix(1,1,1,0)^(v[l]-1));\n\t\treturn;\n\t}\n\tbuild(ls,l,mid);\n\tbuild(rs,mid+1,r);\n\tpushup(i);\n}\n\nvoid pushdown(int i){\n\tif(tag[i].empty()){\n\t\treturn;\n\t}\n\tt[ls]=t[ls]*tag[i];\n\ttag[ls]=tag[ls]*tag[i];\n\tt[rs]=t[rs]*tag[i];\n\ttag[rs]=tag[rs]*tag[i];\n\ttag[i]=unit;\n}\n\nvoid update(int i,int ql,int qr,int l,int r,Matrix x){\n\tif(ql<=l && qr>=r){\n\t\tt[i]=t[i]*x;\n\t\ttag[i]=tag[i]*x;\n\t\treturn;\n\t}\n\tpushdown(i);\n\tif(ql<=mid){\n\t\tupdate(ls,ql,qr,l,mid,x);\n\t}\n\tif(qr>mid){\n\t\tupdate(rs,ql,qr,mid+1,r,x);\n\t}\n\tpushup(i);\n}\n\nMatrix query(int i,int ql,int qr,int l,int r){\n\tif(ql<=l && qr>=r){\n\t\treturn t[i];\n\t}\n\tpushdown(i);\n\tMatrix res;\n\tif(ql<=mid){\n\t\tres = res + query(ls,ql,qr,l,mid);\n\t}\n\tif(qr > mid){\n\t\tres = res+query(rs,ql,qr,mid+1,r);\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>v[i];\n\t}\n\tbuild(1,1,n);\n\twhile(m--){\n\t\tint op,l,r,x;\n\t\tcin>>op;\n\t\tif(op==1){\n\t\t\tcin>>l>>r>>x;\n\t\t\tupdate(1,l,r,1,n,Matrix(1,1,1,0)^x);\n\t\t}\n\t\telse{\n\t\t\tcin>>l>>r;\n\t\t\tcout<<(query(1,l,r,1,n).a[1][2]%MOD)<<'\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n\n```\n",
        "postTime": 1651543926,
        "uid": 413065,
        "name": "xiezheyuan",
        "ccfLevel": 5,
        "title": "CF718C Sasha and Array"
    },
    {
        "content": "\u7b2c\u4e00\u6b21\u5199\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u4e58\u554a\u2026\u2026\u7ed3\u679c\u76f4\u63a5\u5199\u7206\u4e86\u3002              \n\n\u89c2\u5bdf\u5230\u7b54\u6848\u5c31\u662f\u6590\u6ce2\u90a3\u5951\u6570\u5217\u6c42\u548c\uff0c\u6211\u4eec\u4e0d\u59a8\u7528\u77e9\u9635\u4e58\u6cd5\u7ef4\u62a4\u7b54\u6848\uff1a       \n\n\u8bb0\u77e9\u9635 \n\n$$Base =  \n\\begin{bmatrix}\n1&1\\\\\n1&0\\\\\n\\end{bmatrix}\n$$\n\n\u800c\u77e9\u9635 \n$$Init = \n\\begin{bmatrix}\n1&0\n\\end{bmatrix}\n$$\n\n\u6211\u4eec\u53ef\u77e5\uff1a        \n\n$f_{x} = Init \\times Base ^ {x - 1}$              \n\n\u8003\u8651\u533a\u95f4\u52a0 $w$\uff0c\u90a3\u4e48\u8fd9\u4e2a\u5f0f\u5b50\u5e94\u8be5\u53d8\u6210\uff1a      \n\n$f_{x + w} = Init \\times Base ^ {x + w - 1}$          \n\n\u7531\u4e8e\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u7684\u662f\u4e00\u4e2a\u548c\u7684\u5f62\u5f0f\uff1a          \n\n$\\sum_{i = l}^r f_{a_i + w} = \\sum_{i = l}^r Init \\times Base ^ {a_i + w - 1}$\u3002           \n\n\u7531\u4e8e\u6211\u4eec\u5148\u524d\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u7684\u662f $\\sum_{i = l} ^ r Init \\times Base ^ {a_i - 1}$\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u9700\u8981\u5728\u6b64\u65f6\u5bf9\u4e8e\u6574\u4f53\u4e58\u4e0a\u4e00\u4e2a $Base ^ w$ \u5373\u53ef\u3002      \n\n\u4e0b\u4f20\u7684\u6807\u8bb0\u6700\u597d\u4e5f\u8981\u5199\u6210\u77e9\u9635\uff0c\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u81ea\u5df1\u76f4\u63a5\u4e0b\u4f20\u533a\u95f4\u52a0\u7684\u503c\u5c31\u6302\u4e86\u800c\u76f4\u63a5\u4e0b\u4f20\u77e9\u9635\u5c31\u6ca1\u95ee\u9898\u2026\u2026\u800c\u4e14\u8fd9\u4e5f\u4f1a\u5feb\u4e00\u53ea $\\log x$\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(8n \\log n)$\u3002\n\n```cpp\n#include \"bits/stdc++.h\"\nusing namespace std;\nconst int Len = 1e5 + 5 , MOD = 1e9 + 7;\nint a[Len],n,q;\nstruct node\n{\n\tint a[3][3];\n\tnode(){memset(a , 0 , sizeof a);}\n\tinline void build(){for(int i = 1 ; i <= 2 ; i ++) a[i][i] = 1;}\n\tinline void clear(){memset(a , 0 , sizeof a);}\n\tinline bool empty()\n\t{\n\t\tfor(int i = 1 ; i <= 2 ; i ++)\n\t\t\tfor(int j = 1 ; j <= 2 ; j ++) if(a[i][j]) return false;\n\t\treturn true;\n\t}\n\tnode operator + (const node &B)\n\t{\n\t\tnode C;\n\t\tfor(int i = 1 ; i <= 2 ; i ++)\n\t\t\tfor(int j = 1 ; j <= 2 ; j ++) \t\n\t\t\t\tC.a[i][j] = (a[i][j] + B.a[i][j]) % MOD;\n\t\treturn C; \n\t}\n\tnode operator * (const node &y)\n\t{\n\t\tnode z;\n\t\tfor(int i = 1 ; i <= 2 ; i ++)\n\t\t\tfor(int j = 1 ; j <= 2 ; j ++) \n\t\t\t\tfor(int k = 1 ; k <= 2 ; k ++)\n\t\t\t\t\tz.a[i][j] = (z.a[i][j] + 1ll * a[i][k] * y.a[k][j] % MOD) % MOD;\n\t\treturn z;\n\t}\n}tree[Len << 2],tag[Len << 2],Base,Mul,BBase,ADD,upd;\nnode qpow(node qk,int b)\n{\n\tnode res;res.build();\n\twhile(b)\n\t{\n\t\tif(b & 1) res = res * qk;\n\t\tqk = qk * qk;\n\t\tb = b >> 1;\n\t}\n\treturn res;\n}\n#define ls(p) p << 1\n#define rs(p) p << 1 | 1\ninline void Mod(int &x){if(x > MOD) x -= MOD;}\nvoid push_up(int x){tree[x] = tree[ls(x)] + tree[rs(x)];}\nvoid push_down(int p)\n{\n\tif(!tag[p].empty())\n\t{\n\t\ttag[ls(p)] = tag[ls(p)] * tag[p] , tag[rs(p)] = tag[rs(p)] * tag[p];\n\t\ttree[ls(p)] = tree[ls(p)] * tag[p];\n\t\ttree[rs(p)] = tree[rs(p)] * tag[p];\n\t\ttag[p].clear();\n\t\ttag[p].build();\n\t}\n}\nvoid build(int p,int l,int r)\n{\n\ttree[p].clear();\n\ttag[p].clear();\n\ttag[p].build();\n\tif(l == r)\n\t{\n\t\ttree[p] = BBase * qpow(Base , a[l] - 1);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(ls(p) , l , mid);\n\tbuild(rs(p) , mid + 1 , r);\n\tpush_up(p);\n}\nvoid update(int p,int l,int r,int nl,int nr)\n{\n\tif(nl <= l && nr >= r)\n\t{\n\t\ttag[p] = tag[p] * upd;\n\t\ttree[p] = tree[p] * upd;\n\t\treturn;\n\t}\n\tpush_down(p);\n\tint mid = (l + r) >> 1;\n\tif(nl <= mid) update(ls(p) , l , mid , nl , nr);\n\tif(nr > mid) update(rs(p) , mid + 1 , r , nl , nr);\n\tpush_up(p);\n}\nvoid query(int p,int l,int r,int nl,int nr)\n{\n\tif(nl <= l && nr >= r){ADD = ADD + tree[p];return;}\n\tpush_down(p);\n\tint mid = (l + r) >> 1;\n\tif(nl <= mid) query(ls(p) , l , mid , nl , nr);\n\tif(nr > mid) query(rs(p) , mid + 1 , r , nl , nr);\n}\nint opt,l,r,w;\nint main()\n{\n\tBBase.a[1][1] = 1 , BBase.a[1][2] = 0;\n\tBase.a[1][1] = 1 , Base.a[1][2] = 1 , Base.a[2][1] = 1 , Base.a[2][2] = 0;\n\tscanf(\"%d %d\",&n,&q);\n\tfor(int i = 1 ; i <= n ; i ++) scanf(\"%d\",&a[i]);\n\tbuild(1 , 1 , n);\n\twhile(q --)\n\t{\n\t\tscanf(\"%d %d %d\",&opt,&l,&r);\n\t\tif(opt == 1) \n\t\t{\n\t\t\tscanf(\"%d\",&w);\n\t\t\tupd = qpow(Base , w);\n\t\t\tupdate(1 , 1 , n , l , r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tADD.clear();\n\t\t\tquery(1 , 1 , n , l , r);\n\t\t\tprintf(\"%d\\n\",ADD.a[1][1]);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1636899037,
        "uid": 132533,
        "name": "Hakuoro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF718C Sasha and Array"
    },
    {
        "content": "### \u9898\u76ee\u5927\u610f\n\n\u5728\u672c\u9898\u4e2d\uff0c\u6211\u4eec\u7528 $f_i$ \u6765\u8868\u793a\u7b2c $i$ \u4e2a\u6590\u6ce2\u90a3\u5951\u6570 $f_1=f_2=1,f_i=f_{i-1}+f_{i-2}(i\\ge 3)$\u3002\n\n\u7ed9\u5b9a\u4e00\u4e2a $n$ \u4e2a\u6570\u7684\u5e8f\u5217 $a$\u3002\n\n\u6709 $m$ \u6b21\u64cd\u4f5c\uff0c\u64cd\u4f5c\u6709\u4e24\u79cd\uff1a\n\n* \u5c06 $a_l\\sim a_r$ \u52a0\u4e0a $x$\u3002\n\n* \u6c42 $\\displaystyle\\left(\\sum_{i=l}^r f_{a_i}\\right)\\bmod (10^9+7)$\u3002\n\n$1\\le n,m\\le 10^5$\uff0c$1\\le a_i\\le 10^9$\u3002\n\n### \u89e3\u9898\u601d\u8def\n\n\u4e24\u4e2a\u64cd\u4f5c\uff0c\u533a\u95f4\u52a0\uff0c\u533a\u95f4\u6c42\u548c\u3002\n\n\u663e\u7136\u7ebf\u6bb5\u6811\u3002\n\n\u6590\u6ce2\u90a3\u5951\u6570\u600e\u4e48\u641e\uff1f\n\n$\\mathcal O(n)$ \u9884\u5904\u7406\u663e\u7136\u7206\u3002\n\n\u663e\u7136\u7528 $\\mathcal O(\\log n)$ \u7684\u77e9\u9635\u5feb\u901f\u5e42\u6765\u6c42\u3002\n\n\u8bbe $base=\\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}$\uff0c\u5219\u6709 $\\begin{bmatrix} f_n && f_{n-1} \\\\ f_{n-1} && f_{n-2}\\end{bmatrix}=\\begin{pmatrix}1&0\\\\0&1\\end{pmatrix} * base^{n-1}$\u3002\n\n\u7531\u4e8e\u77e9\u9635\u5177\u6709\u5206\u914d\u5f8b\uff0c\u5373 $a\\times b+a\\times c=a\\times(b+c)$\uff0c\u6240\u4ee5\u5bf9\u4e8e\u4e00\u6bb5\u533a\u95f4\u7684\u77e9\u9635\u53ef\u4ee5\u76f8\u52a0\u7ef4\u62a4\uff0c\u6240\u4ee5 $\\sum\\limits_{i=l}^{r}f(a_i+x)=f_x*\\sum\\limits_{i=l}^{r}(a_i)$\u3002\n\n\u7ebf\u6bb5\u6811\u6ee1\u8db3\u6240\u6709\u6761\u4ef6\uff01\uff01\uff01\n\n\u7ebf\u6bb5\u6811\u4e0a\u6bcf\u4e2a\u70b9\u90fd\u641e\u6210\u4e00\u4e2a\u77e9\u9635\u5373\u53ef\u3002\n\n\u5177\u4f53\u8bf7\u770b\u4ee3\u7801\u3002\n\n### CODE\n\n```cpp\n#include <bits/stdc++.h>\n\n#define int long long\n\ninline int read()\n{\n    int s = 0, f = 0;\n    char ch = getchar();\n    while (!isdigit(ch))\n        f |= (ch == '-'), ch = getchar();\n    while (isdigit(ch))\n        s = (s << 1) + (s << 3) + ch - '0', ch = getchar();\n    return f ? -s : s;\n}\n\nusing namespace std;\n\nconst int _ = 1e5 + 5;\n\nconst int INF = 1e9 + 7;\n\nconst int mod = 1e9 + 7;\n\nstruct Matrix\n{\n    int a[3][3];\n    Matrix() { memset(a, false, sizeof a); }\n    void Init() { a[1][1] = a[2][2] = 1, a[1][2] = a[2][1] = 0; }\n    bool pd() { return a[1][1] == 1 && a[2][2] == 1 && a[1][2] == 0 && a[2][1] == 0; }\n    Matrix operator+(const Matrix b)\n    {\n        Matrix res;\n        for (int i = 1; i <= 2; ++i)\n            for (int j = 1; j <= 2; ++j)\n                res.a[i][j] = (a[i][j] + b.a[i][j]) % mod;\n        return res;\n    }\n    Matrix operator*(const Matrix b)\n    {\n        Matrix res;\n        for (int k = 1; k <= 2; ++k)\n            for (int i = 1; i <= 2; ++i)\n                for (int j = 1; j <= 2; ++j)\n                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;\n        return res;\n    }\n    Matrix operator^(int b)\n    {\n        Matrix res, Base;\n        for (int i = 1; i <= 2; ++i)\n            res.a[i][i] = 1;\n        for (int i = 1; i <= 2; ++i)\n            for (int j = 1; j <= 2; ++j)\n                Base.a[i][j] = a[i][j];\n        while (b)\n        {\n            if (b & 1)\n                res = res * Base;\n            Base = Base * Base;\n            b >>= 1;\n        }\n        return res;\n    }\n} base, ans;\n\nint n, m, a[_];\n\nnamespace Seg_tree\n{\n#define lson i << 1\n#define rson i << 1 | 1\n    struct Tree\n    {\n        Matrix sum, lazy;\n    } tree[_ << 2];\n    void Push_up(int i) { tree[i].sum = tree[lson].sum + tree[rson].sum; }\n    void Build(int i, int l, int r)\n    {\n        tree[i].lazy.Init();\n        if (l == r)\n        {\n            if (a[l] == 1)\n                tree[i].sum.a[1][1] = 1;\n            else if (a[l] == 2)\n                tree[i].sum.a[1][1] = tree[i].sum.a[1][2] = 1;\n            else\n                tree[i].sum = ans * (base ^ (a[l] - 2));\n            return;\n        }\n        int mid = (l + r) >> 1;\n        Build(lson, l, mid), Build(rson, mid + 1, r);\n        Push_up(i);\n    }\n    void Push_down(int i)\n    {\n        if (tree[i].lazy.pd())\n            return;\n        tree[lson].lazy = tree[lson].lazy * tree[i].lazy;\n        tree[rson].lazy = tree[rson].lazy * tree[i].lazy;\n        tree[lson].sum = tree[lson].sum * tree[i].lazy;\n        tree[rson].sum = tree[rson].sum * tree[i].lazy;\n        tree[i].lazy.Init();\n    }\n    void Modify(int i, int l, int r, int L, int R, Matrix k)\n    {\n        if (L <= l && r <= R)\n        {\n            tree[i].lazy = tree[i].lazy * k, tree[i].sum = tree[i].sum * k;\n            return;\n        }\n        Push_down(i);\n        int mid = (l + r) >> 1;\n        if (mid >= L)\n            Modify(lson, l, mid, L, R, k);\n        if (mid < R)\n            Modify(rson, mid + 1, r, L, R, k);\n        Push_up(i);\n    }\n    int Query(int i, int l, int r, int L, int R)\n    {\n        if (L <= l && r <= R)\n            return tree[i].sum.a[1][1];\n        Push_down(i);\n        int mid = (l + r) >> 1, ans = 0;\n        if (mid >= L)\n            ans = (ans + Query(lson, l, mid, L, R)) % mod;\n        if (mid < R)\n            ans = (ans + Query(rson, mid + 1, r, L, R)) % mod;\n        return ans;\n    }\n}\n\nsigned main()\n{\n    base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;\n    ans.a[1][1] = ans.a[1][2] = 1;\n    n = read(), m = read();\n    for (int i = 1; i <= n; ++i)\n        a[i] = read();\n    Seg_tree::Build(1, 1, n);\n    for (int i = 1, opt, l, r, k; i <= m; ++i)\n    {\n        opt = read(), l = read(), r = read();\n        if (opt == 1)\n        {\n            k = read();\n            Seg_tree::Modify(1, 1, n, l, r, base ^ k);\n        }\n        else\n        {\n            printf(\"%lld\\n\", Seg_tree::Query(1, 1, n, l, r));\n        }\n    }\n    return 0;\n}\n```\n\n",
        "postTime": 1636214872,
        "uid": 257146,
        "name": "orz_z",
        "ccfLevel": 0,
        "title": "CF718C Sasha and Array"
    },
    {
        "content": "\u8fd9\u9053\u9898\u8c8c\u4f3c\u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\n\n~~\u795eTM\u52a8\u6001dp\u677f\u5b50\uff0c\u6211\u89c9\u5f97\u8ddfdp\u534a\u6bdb\u94b1\u5173\u7cfb\u90fd\u6ca1\u6709\u554a~~\n\n\u6590\u6ce2\u90a3\u5951\u7528\u77e9\u9635\u4f18\u5316\u4e00\u4e0b\uff0c\u7136\u540e\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\u5c31\u80fd\u8fc7\u4e86\uff0c\u7801\u91cf\u4e0d\u5927\uff0c\u5c01\u88c5\u5b8c\u4e86\u6781\u5176\u597d\u5199\n\n$$f[i]=f[i-1]+f[i-2]$$\n\n$$f[n]=\\begin{bmatrix}0&1\\\\1&1\\\\ \\end{bmatrix}^{n-1}\\times \\begin{bmatrix}0\\\\1\\\\ \\end{bmatrix}$$\n\n\u7136\u540e\uff0c\u521d\u59cb\u503c\u90fd\u8bbe\u4e3a$\\begin{bmatrix}1&0\\\\0&1\\\\ \\end{bmatrix}$,\u7136\u540e\u505a\u533a\u95f4\u4e58\uff0c\u533a\u95f4\u6c42\u548c\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e00\u4e0b\u5c31\u597d\u4e86\u3002\n\n\u5177\u4f53\u7ec6\u8282\u770b\u4ee3\u7801\u5427\uff0c\u81ea\u6211\u611f\u89c9\u7801\u98ce\u826f\u597d:-D\n\n```\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nstruct Matrix\n{\n    int a[3][3];\n\n    Matrix()\n    {\n        memset(a,0,sizeof(a));\n    }\n\n    Matrix(bool I)\n    {\n        memset(a,0,sizeof(a));\n        for(int i=1;i<=2;i++)\n        {\n            a[i][i]=1;\n        }\n    }\n\n    Matrix operator*(const Matrix &other)const\n    {\n        Matrix res;\n        for(int i=1;i<=2;i++)\n        {\n            for(int j=1;j<=2;j++)\n            {\n                for(int k=1;k<=2;k++)\n                {\n                    res.a[i][j]+=1ll*a[i][k]*other.a[k][j]%mod;\n                    res.a[i][j]%=mod;\n                }\n            }\n        }\n        return res;\n    }\n\n    Matrix operator*=(const Matrix &other)\n    {\n        return *this=*this*other;\n    }\n\n    Matrix operator+(const Matrix &other)const\n    {\n        Matrix res;\n        for(int i=1;i<=2;i++)\n        {\n            for(int j=1;j<=2;j++)\n            {\n                res.a[i][j]=a[i][j]+other.a[i][j];\n                res.a[i][j]%=mod;\n            }\n        }\n        return res;\n    }\n};\n\nint n,m;\n\nclass SEG\n{\n    private:\n        struct Node\n        {\n            Matrix sum,mul;\n\n            Node():sum(1),mul(1){}\n        }nd[400010];\n\n        void pushdown(int x)\n        {\n            nd[x<<1].sum*=nd[x].mul;\n            nd[x<<1].mul*=nd[x].mul;\n            nd[x<<1|1].sum*=nd[x].mul;\n            nd[x<<1|1].mul*=nd[x].mul;\n            nd[x].mul=Matrix(1);\n        }\n\n        void update(int x)\n        {\n            nd[x].sum=nd[x<<1].sum+nd[x<<1|1].sum;\n        }\n\n        void modify(int x,int nl,int nr,int ql,int qr,Matrix val)\n        {\n            if(nl>qr||nr<ql) return;\n            if(nl>=ql&&nr<=qr)\n            {\n                nd[x].sum*=val;\n                nd[x].mul*=val;\n                return;\n            }\n            pushdown(x);\n            int mid=nl+nr>>1;\n            modify(x<<1,nl,mid,ql,qr,val);\n            modify(x<<1|1,mid+1,nr,ql,qr,val);\n            update(x);\n        }\n\n        Matrix query(int x,int nl,int nr,int ql,int qr)\n        {\n            if(nl>qr||nr<ql) return Matrix(); \n            if(nl>=ql&&nr<=qr) return nd[x].sum;\n            pushdown(x);\n            int mid=nl+nr>>1;\n            return query(x<<1,nl,mid,ql,qr)+query(x<<1|1,mid+1,nr,ql,qr);\n        }\n\n    public:\n        void modify(int l,int r,Matrix val)\n        {\n            modify(1,1,n,l,r,val);\n        }\n\n        Matrix query(int l,int r)\n        {\n            return query(1,1,n,l,r);\n        }\n}seg;\n\nint sec[100010];\n\nMatrix qpow(Matrix a,int b)\n{\n    Matrix res(1);\n    for(;b;b>>=1)\n    {\n        if(b&1)\n        {\n            res=res*a;\n        }\n        a=a*a;\n    }\n    return res;\n}\n\nint main()\n{\n    Matrix bas;\n    bas.a[1][2]=bas.a[2][2]=bas.a[2][1]=1;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        cin>>sec[i];\n        seg.modify(i,i,qpow(bas,sec[i]-1));\n    }\n    for(int i=1;i<=m;i++)\n    {\n        int opt,l,r;\n        cin>>opt>>l>>r;\n        if(opt==1)\n        {\n            int tmp;\n            cin>>tmp;\n            seg.modify(l,r,qpow(bas,tmp));\n        }\n        else\n        {\n            cout<<seg.query(l,r).a[2][2]<<'\\n';\n        }\n    }\n}\n```",
        "postTime": 1547865192,
        "uid": 53241,
        "name": "partychicken",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF718C \u3010Sasha and Array\u3011"
    },
    {
        "content": "# \u9898\u76ee\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[\u70b9\u8fd9\u91cc](https://www.luogu.com.cn/problem/CF718C)\u770b\u9898\u76ee\u3002  \n# \u5206\u6790\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u770b\u5230\u533a\u95f4\u4fee\u6539\u548c\u67e5\u8be2\uff0c\u4e0d\u96be\u60f3\u5230\u4f7f\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u8003\u8651\u5230\u521d\u59cb\u7684$a$\u548c\u589e\u52a0\u7684$x$\u603b\u662f\u6b63\u6570\uff0c\u6211\u4eec\u4fbf\u4e0d\u96be\u60f3\u5230\u4f7f\u7528\u77e9\u9635\u548c\u5411\u91cf\u6765\u5b9e\u73b0\u52a8\u6001\u7ef4\u62a4\u6bcf\u4e00\u4e2a\u4f4d\u7f6e\u4e0a\u9762\u7684$f(a_i)$\u3002\u8bbe\u8f6c\u79fb\u77e9\u9635\u4e3a$T$\uff0c\u521d\u59cb\u5411\u91cf$\\boldsymbol p$\u4e3a$\\begin{bmatrix}f(1)&f(0)\\end{bmatrix}$\uff08$f(0)=0$\uff09\u3002\u5219\u4f4d\u7f6e$i$\u4e0a\u7684\u521d\u59cb\u503c\u4e3a$\\boldsymbol p\\times T^{a_i}$\u3002\u6bcf\u6b21\u5c06\u533a\u95f4$[l,r]$\u7684$a$\u52a0\u4e0a$x$\uff0c\u5c31\u76f8\u5f53\u4e8e\u5728\u533a\u95f4$[l,r]$\u4e58\u4e0a$T^x$\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u67e5\u8be2\u5c31\u628a\u533a\u95f4\u7684\u5411\u91cf\u6c42\u548c\uff0c\u518d\u53d6\u7b2c\u4e00\u9879\u5c31\u597d\u4e86\u3002  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$O(2^3m\\log_2n)$\n# \u4ee3\u7801\n```cpp\n#include <cstdio>\n#include <cstring>\n\nconst int mod = 1e9 + 7;\nconst int MAXN = 1e5 + 5, MAXSIZ = 3;\n\ntemplate<typename _T>\nvoid read( _T &x )\n{\n\tx = 0;char s = getchar(); int f = 1;\n\twhile( s < '0' || '9' < s ){ f = 1; if( s == '-' ) f = -1; s = getchar(); }\n\twhile( '0' <= s && s <= '9' ){ x = ( x << 3 ) + ( x << 1 ) + s - '0', s = getchar(); }\n\tx *= f;\n}\n\ntemplate<typename _T>\nvoid write( _T x )\n{\n\tif( x < 0 ){ putchar( '-' ), x = -x; }\n\tif( 9 < x ){ write( x / 10 ); }\n\tputchar( x % 10 + '0' );\n}\n\nstruct matrix\n{\n    int mat[MAXSIZ][MAXSIZ], n, m;\n    matrix(){ n = m = 0, memset( mat, 0, sizeof mat ); }\n    matrix( const int N, const int M ) { n = N, m = M, memset( mat, 0, sizeof mat ); }\n    int* operator [] ( const int indx ) { return mat[indx]; }\n    matrix operator * ( matrix other ) const \n    {\n        matrix ret = matrix( n, other.m );\n        for( int i = 1 ; i <= n ; i ++ )\n            for( int j = 1 ; j <= m ; j ++ )\n                if( mat[i][j] )\n                    for( int k = 1 ; k <= ret.m ; k ++ ) \n                    {\n                        ret[i][k] += 1ll * mat[i][j] * other[j][k] % mod;\n                        if( ret[i][k] > mod ) ret[i][k] -= mod;\n                    }\n        return ret;\n    }\n    bool operator == ( matrix other ) const\n    {\n        if( n ^ other.n || m ^ other.m ) return false;\n        for( int i = 1 ; i <= n ; i ++ )\n            for( int j = 1 ; j <= m ; j ++ )\n                if( mat[i][j] ^ other[i][j] ) return false;\n        return true;\n    }\n    bool operator != ( matrix other ) const { return ! ( *this == other ); }\n    void operator *= ( matrix other ) { *this = *this * other; }\n};\n\nstruct vector\n{\n    int vec[MAXSIZ], n;\n    vector(){ n = 0, memset( vec, 0, sizeof vec ); }\n    vector( const int N ) { n = N, memset( vec, 0, sizeof vec ); }\n    int& operator [] ( const int indx ) { return vec[indx]; }\n    vector operator * ( matrix other ) const\n    {\n        vector ret = vector( n );\n        for( int i = 1 ; i <= n ; i ++ )\n            for( int j = 1 ; j <= ret.n ; j ++ ) \n            {\n                ret[i] += 1ll * vec[j] * other[j][i] % mod;\n                if( ret[i] > mod ) ret[i] -= mod;\n            }\n        return ret;\n    }\n    vector operator + ( vector other ) const \n    {\n        vector ret = *this;\n        for( int i = 1 ; i <= n ; i ++ ) \n        {\n            ret[i] += other[i];\n            if( ret[i] > mod ) ret[i] -= mod;\n        }\n        return ret;\n    }\n    void operator *= ( matrix other ) { *this = *this * other; }\n    void operator += ( vector other ) { *this = *this + other; }\n};\n\nstruct segmentTreeNode\n{\n\tvector s; matrix tag;\n\t#define s( a ) ( segTree[a].s )\n\t#define tag( a ) ( segTree[a].tag )\n}segTree[MAXN << 2];\n\nmatrix I, B;\nvector A;\n\nint a[MAXN];\nint N, M;\n\nvoid upt( const int x ) { s( x ) = s( x << 1 ) + s( x << 1 | 1 ); }\nvoid prod( const int x, const matrix v ) { s( x ) *= v, tag( x ) *= v; }\nvoid normalize( const int x ) { if( tag( x ) != I ) prod( x << 1, tag( x ) ), prod( x << 1 | 1, tag( x ) ), tag( x ) = I; }\n\nvoid init()\n{ \n\tI = matrix( 2, 2 ); for( int i = 1 ; i <= 2 ; i ++ ) I[i][i] = 1; \n\tB = matrix( 2, 2 ); B[1][1] = B[2][1] = B[1][2] = 1;\n\tA = vector( 2 ); A[1] = 1;\n}\n\nmatrix qkpow( matrix base, int indx )\n{\n\tif( indx < 0 ) return I;\n\tmatrix ret = I;\n\twhile( indx )\n\t{\n\t\tif( indx & 1 ) ret *= base;\n\t\tbase *= base, indx >>= 1;\n\t}\n\treturn ret;\n}\n\nvoid build( const int u, const int l, const int r )\n{\n\tif( l > r ) return ;\n\ttag( u ) = I; int mid = l + r >> 1;\n\tif( l == r ) { s( u ) = A * qkpow( B, a[l] - 1 ); return; }\n\tbuild( u << 1, l, mid ), build( u << 1 | 1, mid + 1, r );\n\tupt( u );\n}\n\nvoid update( const int x, const int l, const int r, const int segL, const int segR, const matrix v )\n{\n\tint mid = l + r >> 1;\n\tif( segL <= l && r <= segR ) { prod( x, v ); return; }\n\tif( l == r ) return; normalize( x );\n\tif( segL <= mid ) update( x << 1, l, mid, segL, segR, v );\n\tif( segR > mid ) update( x << 1 | 1, mid + 1, r, segL, segR, v );\n\tupt( x ); \n}\n\nint query( const int x, const int l, const int r, const int segL, const int segR )\n{\n\tint mid = l + r >> 1, ret = 0;\n\tif( segL <= l && r <= segR ) return s( x )[1];\n\tif( l == r ) return 0; normalize( x );\n\tif( segL <= mid ) ( ret += query( x << 1, l, mid, segL, segR ) ) %= mod;\n\tif( segR > mid ) ( ret += query( x << 1 | 1, mid + 1, r, segL, segR ) ) %= mod;\n\treturn ret;\n}\n\nint main()\n{\n\tmatrix tmp;\n\tint opt, optL, optR, optV;\n\tinit();\n\tread( N ), read( M );\n\tfor( int i = 1 ; i <= N ; i ++ ) read( a[i] );\n\tbuild( 1, 1, N );\n\twhile( M -- )\n\t{\n\t\tread( opt ), read( optL ), read( optR );\n\t\tif( opt == 1 ) \n\t\t{\n\t\t\tread( optV );\n\t\t\ttmp = qkpow( B, optV );\n\t\t\tupdate( 1, 1, N, optL, optR, tmp );\n\t\t}\n\t\telse write( query( 1, 1, N, optL, optR ) ), putchar( '\\n' );\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1578290994,
        "uid": 123809,
        "name": "crashed",
        "ccfLevel": 0,
        "title": "[CF718C]Sasha and Array"
    },
    {
        "content": "## \u9898\u76ee\u603b\u7ed3\n\n![](https://cdn.luogu.com.cn/upload/pic/20451.png )\n\n## \u6570\u636e\u8303\u56f4\n\n$ 1<=n<=100000 , 1<=m<=100000 $\n\n## \u89e3\u9898\u601d\u8def\n\n\u8003\u8651\u5230\u5feb\u901f\u6c42\u51fa\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u503c\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u77e9\u9635\u4e58\u6cd5\uff0c\u800c\u6b64\u9898\u8be2\u95ee\u7684\u65f6\u533a\u95f4\u548c\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff1b\n\n![](https://cdn.luogu.com.cn/upload/pic/20454.png )\n\n![](https://cdn.luogu.com.cn/upload/pic/20455.png )\n\n\u5bf9\u4e8e\u533a\u95f4\uff0c$ [l,r] $\uff0c\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u5b58\u653e\u7684\u662f\u6b64\u533a\u95f4\u5185\u7684\u548c\uff0c\u4ee5\u53calazy\u6807\u8bb0\uff1b\n\n\u5176\u5b9e\u6211\u7684\u505a\u6cd5\u548c\u4e0a\u9762\u6709\u4e00\u70b9\u4e0d\u4e00\u6837\uff1b\u521d\u59cb\u5316\u65f6\uff0c\u6bcf\u4e2a\u8282\u70b9\u7684\u503c\u4e3abase\u77e9\u9635\u7684X\u6b21\u65b9\uff08\u4e0d\u662fX-1\uff09\uff0c\u4ee5\u4e3a\u6211\u8ba1\u7b97\u7b54\u6848\u65f6\uff0c\u4e58\u4ee5\u7684\u77e9\u9635\u662f$[f[0],f[-1]]$\uff0c\u5373$[0,1]$\uff0c\u6240\u4ee5\u6211\u7684\u7b54\u6848\u5c31\u662f$m[2][1]$\uff1b\u7136\u540e\u4e00\u5c42\u5c42\u7684pushup\uff0c\u5373\u6c42\u51fa\u5de6\u53f3\u5b50\u533a\u95f4\u7684\u77e9\u9635\u7684\u548c\uff08\u77e9\u9635\u5177\u6709\u7ed3\u5408\u5f8b\uff09\n\n\u4fee\u6539\u65f6\u627e\u5230\u5bf9\u5e94\u533a\u95f4\uff0c\u7136\u540e\u6253\u6807\u8bb0\uff0cpushup\u5373\u53ef\uff1b\n\n\u6bcf\u6b21\u67e5\u8be2\u65f6\u6c42\u51fa\u5bf9\u5e94\u533a\u95f4\u7684\u77e9\u9635\u548c\u5373\u53ef\uff0c\u8bb0\u5f97pushdown\uff1b\n\n## \u6613\u9519\u8bef\u533a\n\n\u522b\u5fd8\u4e86\u521d\u59cb\u5316sz\uff1b\n\n\u8bb0\u5f97\u53ca\u65f6\u4e0b\u653e\u6807\u8bb0\uff01\u6211\u4f1a\u53e6\u5f00\u4e00\u7bc7\u6765\u5199\uff1b\n\n**\u6700\u91cd\u8981\u7684\uff1a\u6b64\u9898\u5361\u5e38\uff01\u4f18\u5316\u4e86\u534a\u5929~~\u8fd8\u662f\u5f88\u6162~~**\n\n\u4e00\u4e9b\u7ec6\u8282\u4f18\u5316\u4e00\u4e0b\uff0c\u5feb\u8bfb\u5feb\u8f93\uff0cinline\uff0cdefine\uff1b\n\n\u6bd4\u8f83\u91cd\u8981\u7684\u662fpushdown\u64cd\u4f5c\uff0c\u5728pushdown\u65f6\u8981\u7279\u5224lazy\u6807\u8bb0\u662f\u5426\u4e3a\u5355\u4f4d\u5143\uff0c\u8fd9\u6837\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\uff0c\u8fd9\u6837\u4f18\u5316\u5f88\u5927\uff1b\n\n## \u4ee3\u7801\u5c55\u793a\n\n```cpp\n%:pragma GCC optimize(2)\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<deque>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define inf 0x3f3f3f3f\n#define ri register int\n#define il inline\n#define fi first\n#define se second\n#define mp make_pair\n#define pi pair<int,int>\n#define mem0(x) memset((x),0,sizeof (x))\n#define mem1(x) memset((x),0x3f,sizeof (x))\n#define int ll\nil char gc() {\n\tstatic const int BS = 1 << 22;\n\tstatic unsigned char buf[BS], *st, *ed;\n\tif (st == ed) ed = buf + fread(st = buf, 1, BS, stdin);\n\treturn st == ed ? EOF : *st++;\n}\n#define gc getchar\ntemplate<class T>void in(T &x)\n{\n\tx = 0; bool f = 0; char c = gc();\n\twhile (c < '0' || c > '9') {if (c == '-') f = 1; c = gc();}\n\twhile (isdigit(c)) {x = (x << 3) + (x << 1) + (c ^ 48); c = gc();}\n\tif (f) x = -x;\n}\n//#undef gc\nvoid out(int x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x > 9) out(x / 10);\n\tputchar(x % 10 + '0');\n}\n#define N 100010<<3\n#define Maxsz 4\n#define md 1000000007\nil void mod(int &x) {\n\twhile (x > md) x -= md;\n\twhile (x < 0) x += md;\n}\nstruct Mat {\n\tint sz;\n\tint m[Maxsz][Maxsz];\n\til void clear() {mem0(m);}\n\tMat () {sz = 2; clear();}\n\tMat operator*(const Mat &x)const {\n\t\tMat res; res.sz = sz;\n\t\tfor (ri i = 1; i <= sz; ++i) {\n\t\t\tfor (ri k = 1; k <= sz; ++k) {\n\t\t\t\tfor (ri j = 1; j <= sz; ++j) {\n\t\t\t\t\tmod(res.m[i][j] += m[i][k] * x.m[k][j] % md);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid operator*=(const Mat &x) {\n\t\t*this = (*this) * x;\n\t}\n\tMat operator+(const Mat &x)const {\n\t\tMat res = *this;\n\t\tfor (ri i = 1; i <= sz; ++i) {\n\t\t\tfor (ri j = 1; j <= sz; ++j) {\n\t\t\t\tmod(res.m[i][j] += x.m[i][j]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tvoid operator+=(const Mat &x) {\n\t\tfor (ri i = 1; i <= sz; ++i) {\n\t\t\tfor (ri j = 1; j <= sz; ++j) {\n\t\t\t\tmod(m[i][j] += x.m[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid toe() {\n\t\tclear();\n\t\tfor (ri i = 1; i <= sz; ++i)\n\t\t\tm[i][i] = 1;\n\t}\n\til bool empty() {\n\t\treturn (m[1][1] == 1 && m[2][2] == 1 && m[1][2] == 0 && m[2][1] == 0);\n\t}\n\tvoid print() {\n\t\tfor (ri i = 1; i <= sz; ++i) {\n\t\t\tfor (ri j = 1; j <= sz; ++j)\n\t\t\t\tprintf(\"%lld \", m[i][j]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\tMat qpow(int x) {\n\t\tMat res = *this, mul = res; --x;\n\t\tfor (; x; x >>= 1, mul *= mul) if (x & 1) res *= mul;\n\t\treturn res;\n\t}\n};\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define gm int mid=(l+r)>>1\n#define now tre[x]\nMat tre[N];\nMat bs;\nint n, m, a[N], rt;\nMat lz[N];\nil void up(int x) {\n\ttre[x] = tre[ls] + tre[rs];\n}\nvoid build(int x, int l, int r) {\n\tlz[x].toe();\n\tif (l == r) {\n\t\tnow = bs.qpow(a[l]);\n\t\treturn;\n\t}\n\tgm;\n\tbuild(ls, l, mid);\n\tbuild(rs, mid + 1, r);\n\tup(x);\n}\nil void down(int x) {\n\tif (!lz[x].empty()) {\n\t\tnow *= lz[x];\n\t\tlz[ls] *= lz[x], lz[rs] *= lz[x], lz[x].toe();\n\t}\n}\nvoid update(int x, int l, int r, int ql, int qr, const Mat &k) {\n\tif (ql <= l && r <= qr) {\n\t\tlz[x] *= k;\n\t\tdown(x);\n\t\treturn;\n\t}\n\tdown(x);\n\tgm;\n\tif (ql <= mid) update(ls, l, mid, ql, qr, k);\n\telse down(ls);\n\tif (mid < qr) update(rs, mid + 1, r, ql, qr, k);\n\telse down(rs);\n\tup(x);\n}\nMat query(int x, int l, int r, int ql, int qr) {\n\tdown(x);\n\tif (ql <= l && r <= qr) {\n\t\treturn tre[x];\n\t}\n\tgm;\n\tMat ret;\n\tif (ql <= mid) ret = query(ls, l, mid, ql, qr);\n\tif (mid < qr) ret += query(rs, mid + 1, r, ql, qr);\n\treturn ret;\n}\nsigned main() {\n\tbs.m[1][1] = bs.m[1][2] = bs.m[2][1] = 1;\n\tin(n), in(m);\n\tfor (ri i = 1; i <= n; ++i) in(a[i]);\n\tbuild(rt = 1, 1, n);\n\tint op, l, r, x; Mat t;\n\twhile (m--) {\n\t\tin(op), in(l), in(r);\n\t\tif (op == 1) {\n\t\t\tin(x);\n\t\t\tt = bs.qpow(x);\n\t\t\tupdate(rt, 1, n, l, r, t);\n\t\t}\n\t\telse {\n\t\t\tout(query(rt, 1, n, l, r).m[2][1]);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1527867169,
        "uid": 58302,
        "name": "i207M",
        "ccfLevel": 0,
        "title": "\u89e3\u9898\u62a5\u544a-\u7ebf\u6bb5\u6811-CF718C Sasha and Array"
    },
    {
        "content": "\u77e9\u9635\u5feb\u901f\u5e42+\u7ebf\u6bb5\u6811\n\n\u8003\u8651F(i)=A^i, \u5176\u4e2dA\u662f\u6590\u6ce2\u90a3\u5951\u77e9\u9635\u5feb\u901f\u5e42\u4e2d\u7684\u77e9\u9635\u3002\n\n\u6ce8\u610f\u5230F(i+x)= A^i$\\times$A^x\n\n\u6545$\\Sigma_l^r$ F(i+x)=$\\Sigma_l^r$ F(i)$\\times$A^x\n\n\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n[\u6211\u7684\u4ee3\u7801\u672c\u5730\u80fd\u8fc7\u4ea4\u4e0a\u53bb\u4e0d\u80fd\u8fc7\uff0c\u771f\u662f\u6709\u6bd2]\n\n[\u4e0d\u8fc7\u65e2\u7136luogu\u5141\u8bb8\u975e\u6b63\u89e3\u6211\u5c31\u4e0d\u8981\u8138\u5730\u4ea4\u4e86]\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<cstdlib>\n#include<algorithm>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<map>\n#define size 400010\n#define ll long long\n#define db double\n#define il inline\n#define rint register int\n#define gc getchar()\n#define rep(i,s,n) for (register int i=s;i<=n;i++)\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1 \n#define mmid int mid=(l+r)>>1;\nconst ll mod=1e9+7;\n\nusing namespace std;\n\nil ll r()\n{\n\tchar c; ll x,f=1;\n\tfor (c=gc;!isdigit(c);c=gc) if (c=='-') f=-1; x=c-'0';\n\tfor (c=gc;isdigit(c);c=gc) x=x*10+c-'0'; return x;\n}\n\nstruct jz {ll a[3][3];} matr;\nvoid clear(jz &x) {memset(x.a,0,sizeof(x.a));}\nvoid setone(jz &x) {clear(x); rep(i,1,2) x.a[i][i]=1;}\nvoid setfib(jz &x) { clear(x);x.a[1][1]=x.a[2][1]=x.a[1][2]=1;}\nvoid turn(jz from,jz &to) {rep(i,1,2) rep(j,1,2) to.a[i][j]=from.a[i][j];}\nbool notone(jz x) {if (x.a[1][1]==1&&x.a[2][2]==1&&x.a[1][2]==0&&x.a[2][1]==0) return 0; return 1;} \njz plu(jz a,jz b)\n{\n\tjz c; clear(c);\n\trep(i,1,2) rep(j,1,2) c.a[i][j]=(ll)(a.a[i][j]+b.a[i][j])%mod;\n\treturn c;\n}\n\njz mul(jz a,jz b)\n{\n\tjz c; clear(c);\n\trep(k,1,2) rep(i,1,2) rep(j,1,2)\n\t\tc.a[i][j]= (c.a[i][j]+(ll)a.a[i][k]*b.a[k][j]%mod)%mod; \n\treturn c;\n}\n\njz ksm(jz x,ll y)\n{\n\tjz res; setone(res);\n\tif (y<=0) return res;\n\twhile (y)\n\t{\n\t\tif (y&1) turn(mul(res,x),res);\n\t\tturn (mul(x,x),x);\n\t\ty>>=1;\n\t}\n}\n\njz tree[size],col[size],A[size];\nll a[size],n,m;\n\nvoid update(int rt) {turn(plu(tree[rt<<1],tree[rt<<1|1]),tree[rt]);}\n\nvoid build(int l,int r,int rt)\n{\n\tif (l==r) \n\t{\n\t\tturn(A[l],tree[rt]); setone(col[rt]); return ;\n\t}\n\tmmid; build(lson);build(rson); update(rt);\n}\n\nvoid color(int l,int r,int rt,jz tmp1) \n{\n\t turn(mul(tmp1,col[rt]),col[rt]);\n\tturn(mul(tmp1,tree[rt]),tree[rt]);\n}\n\nvoid pushc(int l,int r,int rt)\n{\n\tif (notone(col[rt]))\n\t{\n\t\tmmid; color(lson,col[rt]); color(rson,col[rt]);\n\t}\n\tsetone(col[rt]);\n}\n\nvoid modify(int l,int r,int rt,int nowl,int nowr, jz v)\n{\n\tif (nowl<=l&&r<=nowr) {color(l,r,rt,v); return;}\n\tpushc(l,r,rt); mmid;\n\tif (nowl<=mid) modify(lson,nowl,nowr,v);\n\tif (mid<nowr) modify(rson,nowl,nowr,v); update(rt);\n}\n\njz query(int l,int r,int rt,int nowl,int nowr)\n{\n\tif (nowl<=l&&r<=nowr) return tree[rt];\n\tpushc(l,r,rt); mmid; jz ans; clear(ans);\n\tif (nowl<=mid) turn(plu(query(lson,nowl,nowr),ans),ans);\n\tif (mid<nowr) turn(plu(query(rson,nowl,nowr),ans),ans);\n \treturn ans;\n\t\n}\n\n\nint main()\n{\n\tfreopen(\"01.in\",\"r\",stdin);\n\tfreopen(\"02.out\",\"w\",stdout);\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n) scanf(\"%d\",&a[i]),setfib(A[i]);\n\trep(i,1,n) turn (ksm(A[i],a[i]),A[i]);\n\trep(i,1,n<<2) setone(col[i]);\n\tbuild(1,n,1);\n\trep(i,1,m)\n\t{\n\t\tint dir,x,y,z;\n\t\tscanf(\"%d%d%d\",&dir,&x,&y);\n\t\tif (dir==1)\n\t\t{\n\t\t\tscanf(\"%d\",&z); jz tmp; setfib(tmp); turn(ksm(tmp,z),tmp);\n\t\t\tmodify(1,n,1,x,y,tmp);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tjz tmp; clear(tmp); turn (query(1,n,1,x,y),tmp);\n\t\t\tcout<<tmp.a[1][2]%mod<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\n```",
        "postTime": 1517926198,
        "uid": 44273,
        "name": "\u786b\u4ee3\u786b\u9178\u94a0",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF718C \u3010Sasha and Array\u3011"
    },
    {
        "content": "\u9898\u610f\uff1a\u7ef4\u62a4\u4e00\u6bb5\u5e8f\u5217\uff0c\u652f\u6301\u533a\u95f4\u52a0\u548c\u533a\u95f4\u6590\u6ce2\u90a3\u5951\u6570\u5217\u548c\u3002\n\n## \u89e3\u9898\u601d\u8def\n\n\u663e\u7136\u8fd9\u9898\u7684\u74f6\u9888\u5c31\u5728\u4e8e\u533a\u95f4\u52a0\uff0c\u56e0\u4e3a\uff0c\u4e00\u5806\u6590\u6ce2\u90a3\u5951\u6570\u7684\u4e0b\u6807\u540c\u65f6\u52a0\u591a\u5c11\u4f3c\u4e4e\u5e76\u6ca1\u6709\u4ec0\u4e48\u516c\u5f0f\u6216\u8005\u6027\u8d28\u2026\u2026\n\n\u4e8e\u662f\u6211\u5f00\u59cb\u4e86\u80e1\u4e71\u601d\u8003\uff08\n\n\u6211\u4eec\u77e5\u9053\u6590\u6ce2\u90a3\u5951\u6570\u5217\u7684\u901a\u9879\u516c\u5f0f\uff1a\n\n$$\nf_n=\\frac{1}{\\sqrt5}\\left(\\left(\\frac{1+\\sqrt5}{2}\\right)^n-\\left(\\frac{1-\\sqrt5}{2}\\right)^n\\right)\n$$\n\n\u7136\u540e\u8fd9\u91cc\u9762\u4e0b\u6807\u90fd\u53d8\u6210\u4e86\u6307\u6570\uff0c\u90a3\u4e48\u53ea\u7528\u7ef4\u62a4\u4e24\u4e09\u4e2a\u91cf\uff0c\u533a\u95f4\u52a0\u5c31\u53d8\u6210\u4e86\u533a\u95f4\u4e58\u2026\u2026\u624b\u5199\u4e00\u4e0b\u65e0\u7406\u6570\u8fd0\u7b97\u2026\u2026\u8c8c\u4f3c\u4e5f\u53ef\u4ee5\u505a\u3002\u3002\u3002\n\n\u6b63\u89e3\u663e\u7136\u4e0d\u662f\u8fd9\u6837\uff0c\u4f46\u786e\u5b9e\u9700\u8981\u628a\u533a\u95f4\u52a0\u53d8\u6210\u533a\u95f4\u4e58\u3002\u6709\u4ec0\u4e48\u4e1c\u897f\u53ef\u4ee5\u901a\u8fc7\u4e58\u6cd5\u65b9\u4fbf\u5730\u7ef4\u62a4\u4e00\u4e2a\u9012\u63a8\u6570\u5217\u5462\uff1f\n\n\uff08\u597d\u50cf\u771f\u6709\u4eba\u8fd9\u4e48\u505a\uff0c\u8fd8\u8dd1\u5f97\u5f88\u5feb\uff1f\uff09\n\n## \u4f7f\u7528\u77e9\u9635\n\n\u4f60\u80af\u5b9a\u5df2\u7ecf\u5b66\u8fc7\u4e86[\u77e9\u9635\u4e58\u6cd5](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/5446029)\u548c[\u77e9\u9635\u5feb\u901f\u5e42](https://zhuanlan.zhihu.com/p/137677246)\u3002\n\n\u60f3\u60f3\u4f60\u505a\u8fc7\u7684\u7b2c\u4e00\u9053\u77e9\u9635\u5feb\u901f\u5e42\u9898\uff1a\u6c42 $f_i\\ (1\\le i\\le 10^{18})$\u3002\n\n\u6211\u4eec\u6709\uff1a\n\n$$\n\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}\\begin{bmatrix}f_i\\\\f_{i-1}\\end{bmatrix}=\\begin{bmatrix}f_{i+1}\\\\f_i\\end{bmatrix}\n$$\n\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u7528**\u7ebf\u6bb5\u6811**\u5728\u5e8f\u5217\u4e0a\u6bcf\u4e00\u4e2a\u4f4d\u7f6e**\u7ef4\u62a4\u4e00\u4e2a\u77e9\u9635** $A_i$\uff0c\u5047\u8bbe\u539f\u6570\u5217\u4e3a $\\{a_i\\}$\uff0c\u5219\n\n$$\nA_i=\\begin{bmatrix}f_{a_i}\\\\f_{a_i-1}\\end{bmatrix}\n$$\n\n\u7ebf\u6bb5\u6811\u5408\u5e76\u533a\u95f4\u65f6\u53ef\u4ee5\u76f4\u63a5\u628a\u4e24\u4e2a\u77e9\u9635\u76f8\u52a0\u3002\n\n\u533a\u95f4\u4fee\u6539\u7684\u65f6\u5019\uff0c\u7531\u4e8e\u77e9\u9635\u4e58\u6cd5**\u6ee1\u8db3\u5206\u914d\u5f8b**\uff0c\u6240\u4ee5\u533a\u95f4\u52a0\u7684\u65f6\u5019\u53ef\u4ee5\u76f4\u63a5\u4e58\u4e0a $\\displaystyle{\\begin{bmatrix}1&1\\\\1&0\\end{bmatrix}}^x$\uff0c$x$\u4e3a\u9700\u8981\u52a0\u7684\u6570\u3002\n\n\u81f3\u4e8e\u67e5\u8be2\u65f6\u5c31\u5c06\u5305\u542b\u7684\u533a\u95f4\u7684\u77e9\u9635\u4e2d\u4fe1\u606f\u52a0\u8d77\u6765\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u5b9e\u73b0\u7ec6\u8282\u89c1\u4ee3\u7801\uff1a\n\n## \u4ee3\u7801\u5b9e\u73b0\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=1e9+7;\nint n,m;\nclass Matrix22 //\u5b9e\u73b0\u77e9\u9635\u7c7b\n{\n private:\n    LL a[2][2]; //\u77e9\u9635\u75282*2\u7684\u6570\u7ec4\u50a8\u5b58\n public:\n    Matrix22(LL a00=0,LL a01=0,LL a10=0,LL a11=0) //\u6784\u9020\u51fd\u6570\n        { a[0][0]=a00,a[0][1]=a01,a[1][0]=a10,a[1][1]=a11; }\n    inline LL &operator ()(int i,int j) //\u66f4\u52a0\u65b9\u4fbf\u5730\u83b7\u53d6\u5143\u7d20\n        { return a[i][j]; }\n    //\u91cd\u8f7d\u52a0\u6cd5\u548c\u4e58\u6cd5\n    //\u56e0\u4e3a\u77e9\u9635\u5927\u5c0f\u662f\u56fa\u5b9a\u7684\u6240\u4ee5\u6ca1\u6709\u4f7f\u7528for\u5faa\u73af\n    //\u800c\u4e14\u8fd9\u6837\u5e38\u6570\u8fd8\u6bd4\u8f83\u5c0f\uff08\uff1f\uff09\n    friend inline Matrix22 operator +(const Matrix22 &x,const Matrix22 &y)\n    {\n        return Matrix22((x.a[0][0]+y.a[0][0])%MOD,\n                        (x.a[0][1]+y.a[0][1])%MOD,\n                        (x.a[1][0]+y.a[1][0])%MOD,\n                        (x.a[1][1]+y.a[1][1])%MOD);\n        //\u5bf9\u5e94\u9879\u76f8\u52a0\n    }\n    friend inline Matrix22 operator *(const Matrix22 &x,const Matrix22 &y)\n    {\n        return Matrix22((x.a[0][0]*y.a[0][0]+x.a[0][1]*y.a[1][0])%MOD,\n                        (x.a[0][0]*y.a[0][1]+x.a[0][1]*y.a[1][1])%MOD,\n                        (x.a[1][0]*y.a[0][0]+x.a[1][1]*y.a[1][0])%MOD,\n                        (x.a[1][0]*y.a[0][1]+x.a[1][1]*y.a[1][1])%MOD);\n        //\u7528\u77e9\u9635\u4e58\u6cd5\u6cd5\u5219\u63a8\u4e00\u4e0b\u5c31\u53ef\u4ee5\u5f97\u5230\u4e86\n    }\n}base,trans,a[100005];\ntemplate<typename T>\nT quickPow(T a,LL b) //\u5feb\u901f\u5e42\n{\n    T res=a;b--;\n    while(b)\n    {\n        if(b&1)\tres=res*a;\n        a=a*a,b>>=1;\n    }\n    return res;\n}\nstruct TreeNode //\u7ebf\u6bb5\u6811\u8282\u70b9\uff0c\u6211\u7528\u4e86\u6307\u9488\u5199\u6cd5\n{\n    Matrix22 val,tag;\n    TreeNode *lc,*rc;\n    TreeNode(): val(),tag(1,0,0,1) //tag\u9700\u8981\u521d\u59cb\u5316\u4e3a\u5355\u4f4d\u77e9\u9635 \n        { lc=rc=nullptr; }\n}*rt;\ntypedef TreeNode *pNode;\nvoid build(int l,int r,pNode &i=rt) //\u5efa\u6811\n{\n    i=new TreeNode;\n    if(l==r)\ti->val=a[l];\n    else\n    {\n        int mid=(l+r)>>1;\n        build(l,mid,i->lc),build(mid+1,r,i->rc);\n        i->val=i->lc->val+i->rc->val;\n    }\n}\ninline void addTag(pNode &i,const Matrix22 &tg) //\u6253tag\n    { i->val=tg*i->val,i->tag=tg*i->tag; } //\u6ce8\u610f\u8fd9\u91cc\u7684tg\u9700\u8981\u5de6\u4e58\n                                           //\u77e9\u9635\u4e58\u6cd5\u6ca1\u6709\u4ea4\u6362\u5f8b\uff0c\u53cd\u8fc7\u6765\u5c31\u9519\u4e86\ninline void pushdown(pNode &i) //\u4e0b\u4f20\u6807\u8bb0\n{\n    addTag(i->lc,i->tag),addTag(i->rc,i->tag);\n    i->tag=Matrix22(1,0,0,1); //\u81ea\u5df1\u7684\u6807\u8bb0\u91cd\u65b0\u8d4b\u4e3a\u5355\u4f4d\u77e9\u9635\n}\nvoid modify(int lq,int rq,const Matrix22 &x,int l=1,int r=n,pNode i=rt)\n// \u533a\u95f4\u4fee\u6539\uff0c\u548c\u677f\u5b50\u4e00\u6a21\u4e00\u6837\n{\n    if(l>=lq && r<=rq)\taddTag(i,x);\n    else\n    {\n        int mid=(l+r)>>1;\n        pushdown(i);\n        if(mid>=lq) modify(lq,rq,x,l,mid,i->lc);\n        if(mid<rq)  modify(lq,rq,x,mid+1,r,i->rc);\n        i->val=i->lc->val+i->rc->val;\n    }\n}\nLL query(int lq,int rq,int l=1,int r=n,pNode &i=rt)\n// \u533a\u95f4\u67e5\u8be2\n{\n    if(l>=lq && r<=rq)\treturn i->val(0,0); //\u8fd9\u91cc\u77e9\u9635\u7684(0,0)\u4f4d\u7f6e\u662f\u7b54\u6848\n    LL mid=(l+r)>>1,ans=0;\n    pushdown(i);\n    if(mid>=lq) ans+=query(lq,rq,l,mid,i->lc);\n    if(mid<rq)  ans+=query(lq,rq,mid+1,r,i->rc);\n    return ans%MOD;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    base(1,0)=trans(0,0)=trans(0,1)=trans(1,0)=1;\n    // \u4f60\u770b\uff0c\u5f88\u65b9\u4fbf\u5427\uff08\n    for(int i=1;i<=n;i++)\n    {\n        int x;\n        scanf(\"%d\",&x);\n        a[i]=quickPow(trans,x)*base; //\u6570\u7ec4a\u521d\u59cb\u5316\n    }\n    build(1,n);\n    while(m--) // \u5e94\u8be5\u4e0d\u7528\u6ce8\u91ca\u4e86\n    {\n        int opt,l,r,x;\n        scanf(\"%d%d%d\",&opt,&l,&r);\n        if(opt==1)\n            scanf(\"%d\",&x),modify(l,r,quickPow(trans,x));\n        else\n            printf(\"%lld\\n\",query(l,r));\n    }\n    return 0;\n}\n```\n\n\u8fd9\u9898\u670950\u591a\u4e2a\u6d4b\u8bd5\u70b9\uff0c\u6bcf\u4e2a\u6d4b\u8bd5\u70b95s\u65f6\u9650\uff0c\u56e0\u6b64\u8bc4\u6d4b\u5f02\u5e38\u8270\u8f9b\uff08\n\n\u8c03\u5b8c\u6837\u4f8b\u540e\u5c45\u7136\u4e00\u904d\u8fc7\u4e86\uff0c\u800c\u4e14\u603b\u65f6\u95f434s\u611f\u89c9\u8fd8\u884c",
        "postTime": 1627438774,
        "uid": 279800,
        "name": "ExplodingKonjac",
        "ccfLevel": 7,
        "title": "\u3010\u9898\u89e3\u3011CF718C Sasha and Array"
    },
    {
        "content": "\u8fd9\u9053\u9898\u592a\u91ce\u86ee\u4e86\uff01\n\n[\u9898\u76ee\u4f20\u9001](https://www.luogu.com.cn/problem/CF718C)\n\n[\u66f4~~\u597d~~\u5dee\u7684\u9605\u8bfb\u4f53\u9a8c\uff1f](https://www.cnblogs.com/Silymtics/p/14898122.html)\n\n## Solution\n\n\u9700\u8981\u7ef4\u62a4\u4e24\u4e2a\u64cd\u4f5c\uff0c\u533a\u95f4\u52a0\u548c\u533a\u95f4\u6c42\u548c\u3002\n\n\u8003\u8651\u7ebf\u6bb5\u6811\u3002\n\n\u4f46\u662f\u6590\u6ce2\u90a3\u5951\u6570\u600e\u4e48\u641e\uff1f\n\n$O(n)$ \u9884\u5904\u7406\uff1f\u663e\u7136\u4f1a\u7206\u6389\u3002\n\n\u6211\u4eec\u77e5\u9053\u77e9\u9635\u5feb\u901f\u5e42\u53ef\u4ee5\u5728 $\\log x$ \u7684\u65f6\u95f4\u5185\u6c42\u51fa\u4e00\u4e2a\u6590\u6ce2\u90a3\u5951\u6570\u3002\n\n\u8003\u8651\u4e00\u4e2a\u53ca\u5176\u91ce\u86ee\u7684\u64cd\u4f5c\uff0c\u628a\u7ebf\u6bb5\u6811\u5185\u7ef4\u62a4\u7684\u70b9\u6362\u6210\u77e9\u9635\u3002\n\n\u6211\u4eec\u77e5\u9053\uff0c\u5bf9\u4e8e\u7b2c $n - 1$ \u9879\uff0c\u6709\uff1a\n\n$$\\begin{bmatrix}\nf_{n - 1} & f_{n - 2}      \\\\\n\\end{bmatrix} \\times \\begin{bmatrix}\n1 & 1      \\\\\n1 & 0 \n\\end{bmatrix} = \\begin{bmatrix}\nf_{n} & f_{n - 1}      \\\\\n\\end{bmatrix}$$\n\n\u8bbe $base = \\begin{bmatrix}\n1 & 1      \\\\\n1 & 0 \n\\end{bmatrix}$\n\n\u5047\u8bbe\u6211\u4eec\u6709\u77e9\u9635 $ z = \\begin{bmatrix} f_{a_i} & f_{a_i-1} \\end {bmatrix}$ \uff0c\u5982\u679c\u5bf9\u5176\u52a0\u4e0a $x$ \uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u8fd9\u4e48\u4e00\u6b65\u64cd\u4f5c\uff1a\n\n$$\\begin{bmatrix} f_{a_i+x} & f_{a_i-1+x} \\end {bmatrix} = z \\times base^x$$\n\n\u6ce8\u610f\u8fd9\u91cc\u7684\u4e58\u6cd5\u6307\u7684\u662f\u77e9\u9635\u4e58\u6cd5\u3002\n\n\u600e\u4e48\u533a\u95f4\u5408\u5e76\uff1f\u76f4\u63a5\u76f8\u52a0\u5c31\u884c\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u624b\u6a21\u4e00\u4e0b\uff0c\u53d1\u73b0\u5b83\u6ee1\u8db3\u5206\u914d\u5f8b\uff0c\u5373\uff1a\n\n$$\\begin{bmatrix} f_a & f_{a-1} \\end{bmatrix} \\times base + \\begin{bmatrix} f_b & f_{b-1} \\end{bmatrix} \\times base = \\begin{bmatrix} f_a+f_b & f_{a-1} + f_{b-1} \\end{bmatrix} \\times base$$\n\n\u6240\u4ee5\u5c31\u53ef\u4ee5\u76f4\u63a5\u8fdb\u884c\u5408\u5e76\u4e86\uff01\n\n\u53ea\u8981\u6211\u4eec\u628a\u77e9\u9635\u5f53\u6210\u70b9\u6765\u770b\uff0c\u90a3\u4e48\u533a\u95f4\u4fee\u6539\u67e5\u8be2\u7b49\u64cd\u4f5c\u5c31\u548c\u666e\u901a\u7684\u7ebf\u6bb5\u6811\u6ca1\u6709\u4ec0\u4e48\u533a\u522b\u4e86\u3002\n\n\u9884\u5904\u7406\u590d\u6742\u5ea6 $O(\\sum_{i=1}^n \\log a_i)$\uff0c\u5355\u6b21\u4fee\u6539\u548c\u67e5\u8be2\u90fd\u662f $O(\\log x)$\uff0c\u53ef\u80fd\u4f1a\u5e26\u4e00\u4e2a $8$ \u7684\u5e38\u6570\u3002\u6240\u4ee5\u590d\u6742\u5ea6\u662f\u6b63\u786e\u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u3002\n\n\u9898\u89e3\u533a\u597d\u50cf\u6709\u7528\u901a\u9879\u516c\u5f0f\u76f4\u63a5\u7b97\u7684\uff0c\u901a\u8fc7\u9884\u5904\u7406\u67d0\u4e9b\u4e1c\u897f\u540e\u8dd1\u8d77\u6765\u4e5f\u662f\u98de\u5feb\u3002\n\n### Tips\n\n- lazy \u8981\u521d\u59cb\u5316\u4e3a\u5355\u4f4d\u77e9\u9635\uff0cpush_down \u65f6\u76f8\u5173\u5224\u65ad\u4e5f\u5e94\u8fdb\u884c\u4fee\u6539\u3002\n- \u6ce8\u610f\u53d6\u6a21\u3002\n- $a_i <= 2$ \u65f6\u8981\u5355\u72ec\u6784\u9020\uff0c\u5176\u4ed6\u60c5\u51b5\u4f7f\u7528\u5feb\u901f\u5e42\u5373\u53ef\u3002\n- \u4fee\u6539\u7684\u65f6\u5019\u53ef\u4ee5\u76f4\u63a5\u628a $base^x$ \u8fd9\u4e2a\u77e9\u9635\u4f20\u8fdb\u53bb\uff0c\u51cf\u5c11\u8ba1\u7b97\u91cf\u3002\n\n\u5b9e\u73b0\u7ec6\u8282\u770b\u4ee3\u7801\u5427\uff0c~~\u81ea\u4ee5\u4e3a\u81ea\u5df1\u7684\u9a6c\u8702\u5f88\u597d\u770b~~\n\n## Code \n\n```cpp\n/*\nWork by: Suzt_ilymics\nProblem: \u4e0d\u77e5\u540d\u5c51\u9898\nKnowledge: \u5783\u573e\u7b97\u6cd5\nTime: O(\u80fd\u8fc7)\n*/\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define int long long\n#define LL long long\n#define orz cout<<\"lkp AK IOI!\"<<endl\n\nusing namespace std;\nconst int MAXN = 1e5+5;\nconst int INF = 1e9+7;\nconst int mod = 1e9+7;\n\nstruct Matrix {\n    int a[3][3];\n    Matrix () { memset(a, false, sizeof a); }\n    void Init() { a[1][1] = a[2][2] = 1, a[1][2] = a[2][1] = 0; }\n    bool pd() { return a[1][1] == 1 && a[2][2] == 1 && a[1][2] == 0 && a[2][1] == 0; }\n    Matrix operator + (const Matrix b) {\n        Matrix res;\n        for(int i = 1; i <= 2; ++i) \n            for(int j = 1; j <= 2; ++j) \n                res.a[i][j] = (a[i][j] + b.a[i][j]) % mod;\n        return res;\n    }\n    Matrix operator * (const Matrix b) {\n        Matrix res;\n        for(int k = 1; k <= 2; ++k) \n            for(int i = 1; i <= 2; ++i) \n                for(int j = 1; j <= 2; ++j) \n                    res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;\n        return res;\n    }\n    Matrix operator ^ (int b) { \n        Matrix res, Base;\n        for(int i = 1; i <= 2; ++i) res.a[i][i] = 1;\n        for(int i = 1; i <= 2; ++i) for(int j = 1; j <= 2; ++j) Base.a[i][j] = a[i][j];\n        while(b) {\n            if(b & 1) res = res * Base;\n            Base = Base * Base;\n            b >>= 1;\n        }\n        return res;\n    }\n}base, ans;\n\nint n, m, a[MAXN];\n\nint read(){\n    int s = 0, f = 0;\n    char ch = getchar();\n    while(!isdigit(ch))  f |= (ch == '-'), ch = getchar();\n    while(isdigit(ch)) s = (s << 1) + (s << 3) + ch - '0' , ch = getchar();\n    return f ? -s : s;\n}\n\nnamespace Seg {\n    #define lson i << 1\n    #define rson i << 1 | 1\n    struct Tree {\n        Matrix sum, lazy;\n    }tree[MAXN << 2];\n    void Push_up(int i) { tree[i].sum = tree[lson].sum + tree[rson].sum; }\n    void Build(int i, int l, int r) {\n        tree[i].lazy.Init();\n        if(l == r) {\n            if(a[l] == 1) tree[i].sum.a[1][1] = 1;\n            else if(a[l] == 2) tree[i].sum.a[1][1] = tree[i].sum.a[1][2] = 1;\n            else tree[i].sum = ans * (base ^ (a[l] - 2));\n            return ;\n        }\n        int mid = (l + r) >> 1;\n        Build(lson, l, mid), Build(rson, mid + 1, r);\n        Push_up(i);\n    }\n    void Push_down(int i) {\n        if(tree[i].lazy.pd()) return ;\n        tree[lson].lazy = tree[lson].lazy * tree[i].lazy;\n        tree[rson].lazy = tree[rson].lazy * tree[i].lazy;\n        tree[lson].sum = tree[lson].sum * tree[i].lazy;\n        tree[rson].sum = tree[rson].sum * tree[i].lazy;\n        tree[i].lazy.Init();\n    }\n    void Modify(int i, int l, int r, int L, int R, Matrix k) {\n        if(L <= l && r <= R) {\n            tree[i].lazy = tree[i].lazy * k, tree[i].sum = tree[i].sum * k;\n            return ;\n        }\n        Push_down(i);\n        int mid = (l + r) >> 1;\n        if(mid >= L) Modify(lson, l, mid, L, R, k);\n        if(mid < R) Modify(rson, mid + 1, r, L, R, k);\n        Push_up(i);\n    }\n    int Query(int i, int l, int r, int L, int R) {\n        if(L <= l && r <= R) return tree[i].sum.a[1][1];\n        Push_down(i);\n        int mid = (l + r) >> 1, ans = 0;\n        if(mid >= L) ans = (ans + Query(lson, l, mid, L, R)) % mod;\n        if(mid < R) ans = (ans + Query(rson, mid + 1, r, L, R)) % mod;\n        return ans;\n    }\n}\n\nsigned main()\n{\n    base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;\n    ans.a[1][1] = ans.a[1][2] = 1;\n    n = read(), m = read();\n    for(int i = 1; i <= n; ++i) a[i] = read();\n    Seg::Build(1, 1, n);\n    for(int i = 1, opt, l, r, k; i <= m; ++i) {\n        opt = read(), l = read(), r = read();\n        if(opt == 1) {\n            k = read();\n            Seg::Modify(1, 1, n, l, r, base^k);\n        } else {\n            printf(\"%lld\\n\", Seg::Query(1, 1, n, l, r));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1623978304,
        "uid": 230580,
        "name": "Suzt_ilymtics",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF718C Sasha and Array"
    }
]