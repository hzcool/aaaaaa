[
    {
        "content": "## \u9898\u610f\n\u7ed9\u51fa\u4e00\u68f5\u6811\u548c\u4e00\u4e2a\u53c2\u6570 $k$\uff0c\u53f6\u5b50\u6709\u84dd\u8272\u548c\u7ea2\u8272\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9 $u$\uff0c\u5982\u679c $\\text{\u84dd\u8272\u513f\u5b50}-\\text{\u7ea2\u8272\u513f\u5b50}\\ge k$ \u90a3\u4e48\u8fd9\u4e2a\u8282\u70b9\u4e3a\u84dd\u8272\u5426\u5219\u4e3a\u7ea2\u8272\u3002\u9700\u8981\u7ef4\u62a4\u4e09\u4e2a\u64cd\u4f5c\uff1a\n\n1. \u8be2\u95ee\u4e00\u4e2a\u8282\u70b9\u989c\u8272\n1. \u66f4\u6539\u53f6\u5b50\u989c\u8272\n1. \u66f4\u6539 $k$\n\n## \u9898\u89e3\n\u867d\u7136\u662f $*3500$ \u4f46\u662f\u4e0d\u662f\u7279\u522b\u7ed5\uff0c\u53ea\u662f\u4ee3\u7801\u6709\u4e00\u70b9\u96be\u5199\uff0c\u849f\u84bb\u5199\u4e86 $114514$ \u5206\u949f\u624d\u5199\u5b8c\u3002\n\n\u8003\u8651\u5982\u679c\u6ca1\u6709\u53f6\u5b50\u989c\u8272\u7684\u53d8\u5316\uff0c\u90a3\u4e48\u968f\u7740 $k$ \u7684\u589e\u52a0\uff0c\u611f\u6027\u7406\u89e3\u4e00\u4e0b\u53d1\u73b0\u4e00\u4e2a\u8282\u70b9\u53d8\u7ea2\u66f4\u52a0\u5bb9\u6613\u3002\u56e0\u6b64\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u8282\u70b9 $u$\uff0c\u6211\u4eec\u53ef\u4ee5\u5904\u7406\u51fa\u521a\u521a\u597d\u53d8\u6210\u7ea2\u8272\u7684\u65f6\u7684 $k_u$\uff0c\u7136\u540e\u53ea\u9700\u8981\u7528\u5f53\u524d\u7684 $k$ \u4e0e $k_u$ \u6bd4\u8f83\u5927\u5c0f\u5c31\u53ef\u4ee5\u5f97\u5230\u989c\u8272\u4e86\u3002\n\n\u6c42 $k_u$ \u6709\u4e00\u4e2a\u6bd4\u8f83 $\\rm Naive$ \u7684\u505a\u6cd5\u662f\u4e8c\u5206\uff0c\u7136\u540e\u770b $|son_u|-2\\sum_{v\\in son_u}[k_v\\le k_u]<k_u$ \u4e5f\u5c31\u662f  $k_u+2\\sum_{v\\in son_u}[k_v\\le k_u]>|son_u|$ \u80fd\u5426\u6ee1\u8db3\uff0c\u4f46\u662f\u6c42\u4e00\u6b21\u662f $\\mathcal O(n\\log n)$ \u7684\uff0c\u5e76\u4e14\u66f4\u6539\u4e4b\u540e\u4e0d\u5bb9\u6613\u65b9\u4fbf\u5730\u7ef4\u62a4\u3002\u8003\u8651\u5f00\u4e00\u68f5\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u518d\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u5c31\u53ef\u4ee5 $\\mathcal O(\\log n)$ \u7684\u65f6\u95f4\u66f4\u6539\u4e00\u4e2a $k_v$\uff0c$\\mathcal O(\\log n)$ \u8ba1\u7b97\u73b0\u5728\u7684 $k_u$\u3002\n\n\u7136\u540e\u518d\u52a0\u4e0a\u66f4\u6539\u64cd\u4f5c\uff0c\u770b\u4e0a\u53bb\u611f\u89c9\u5f88\u50cf $\\rm DDP$\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u6811\u94fe\u5256\u5206\u518d\u8bf4\u3002\u4e8e\u662f\u4e00\u4e2a\u70b9\u6709\u4e86\u8f7b\u513f\u5b50\u548c\u91cd\u513f\u5b50\uff0c\u8003\u8651\u5982\u4f55\u5c06\u4fe1\u606f\u5408\u5e76\u3002\u9996\u5148\u6211\u4eec\u4e0d\u8003\u8651\u91cd\u513f\u5b50\u5f97\u5230\u4e00\u4e2a $k$\uff0c\u7136\u540e\u8003\u8651\u91cd\u513f\u5b50\u7684\u6743\u503c\u662f $x$ \u60f3\u8981\u52a0\u5165\uff0c\u6b64\u65f6 $\\rm{LHS}-\\rm{RHS}=\\Delta>0$\uff0c$\\sum_{v\\in lightson_u}[k_v=k]=cnt_0$\uff0c\u60c5\u51b5\u975e\u5e38\u6709\u9650\uff1a\n\n- $x>k$\n  - $\\Delta=1$\uff0c\u90a3\u4e48\u53f3\u8fb9\u589e\u52a0 $1$ \u4e4b\u540e $\\Delta'=0$\uff0c\u4e3a\u4e86\u4ecd\u7136\u6ee1\u8db3\u7b49\u5f0f $k' = k+1$\n  - $\\Delta>1$\uff0c\u90a3\u4e48\u53f3\u8fb9\u589e\u52a0 $1$ \u540e\u5927\u4e8e\u53f7\u4ecd\u7136\u6210\u7acb\uff0c\u5e76\u4e14 $k$ \u4e0d\u53ef\u80fd\u51cf\u5c0f\uff0c\u6240\u4ee5 $k'=k$\n\n- $x=k$\n  - \u663e\u7136 $k'=k$ \u662f\u53ef\u884c\u7684\uff0c\u5de6\u8fb9\u52a0 $2$ \u53f3\u8fb9\u52a0 $1$ \u662f\u6ee1\u8db3\u7684\u3002\u7136\u540e\u518d\u5206\u6790\u4e00\u4e0b\u5982\u679c $k'<k$\uff0c\u90a3\u4e48\u539f\u6765\u5c31\u4e0d\u884c\uff0c\u73b0\u5728\u53f3\u8fb9\u53d8\u5927\u4e86\u5c31\u66f4\u4e0d\u884c\n- $x<k$\n  - \u8fd9\u4e2a\u5c31\u6bd4\u8f83\u9ebb\u70e6\u4e86\u3002\u9996\u5148\u5206\u6790\u4e00\u4e0b\u53d1\u73b0 $k'<k-1$ \u662f\u4e00\u5b9a\u4e0d\u884c\u7684\uff0c\u8003\u8651\u52a0\u5165\u91cd\u513f\u5b50\u5982\u679c $k-2$ \u53ef\u884c\u90a3\u4e48\u4e0d\u8003\u8651\u91cd\u513f\u5b50\u5c31\u76f4\u63a5\u9009 $k-1$ \u4e86\uff0c\u63a8\u51fa\u4e86\u77db\u76fe\u3002\u90a3\u4e48 $k'=k-1$ \u53ef\u884c\u7684\u6761\u4ef6\u5c31\u662f $\\Delta-1-2cnt_0+2>1$\n  - \u5982\u679c\u90a3\u4e2a\u6761\u4ef6\u4e0d\u6ee1\u8db3\u5c31 $k'=k$\n\n\u4e8e\u662f\u8fd9\u4e2a\u51fd\u6570\u53ea\u6709\u4e09\u6bb5\u533a\u95f4\uff0c\u6211\u4eec\u628a\u8fd9\u4e2a\u8f6c\u79fb\u5199\u6210 $k'_u=f_u(heavyson_u)$\uff0c\u8fd9\u4e2a\u51fd\u6570\u53ef\u4ee5\u6bd4\u8f83\u65b9\u4fbf\u5730\u5408\u5e76\uff0c\u4e8e\u662f\u5199\u4e00\u68f5\u5e73\u8861\u6811\u6216\u7ebf\u6bb5\u6811\u5c31\u53ef\u4ee5\u8f83\u5feb\u5730\u8f6c\u79fb\u4e86\u3002\u51fd\u6570 $f_u(x)$ \u5c31\u76f4\u63a5\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u6a21\u62df\u4e0a\u9762\u7684\u8fc7\u7a0b\u5c31\u597d\u4e86\u3002\n\n\u53d1\u73b0\u66f4\u6539\u8f7b\u513f\u5b50\u7684\u590d\u6742\u5ea6\u662f $\\mathcal O(\\log n)$ \u7684\uff0c\u6bcf\u4e00\u6b21\u6700\u591a\u66f4\u6539 $\\mathcal O(\\log n)$ \u4e2a\u8f7b\u513f\u5b50\uff0c\u4e00\u6761\u91cd\u94fe\u66f4\u6539\u5e73\u8861\u6811\u7684\u590d\u6742\u5ea6\u662f $\\mathcal O(\\log n)$ \u7684\uff0c\u6700\u591a\u66f4\u6539 $\\mathcal O(\\log n)$ \u6761\uff0c\u6240\u4ee5\u590d\u6742\u5ea6\u662f $\\mathcal O(q\\log^2n)$ \u7684\u3002\n\n## \u4ee3\u7801\n```cpp\n#include<bits/stdc++.h>\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define pc putchar\n#define chkmx(a,b) (a)=max((a),(b))\n#define chkmn(a,b) (a)=min((a),(b))\n#define fi first\n#define se second\nusing namespace std;\ntemplate<class T>\nvoid read(T&x){x=0;char c=getchar();bool f=0;for(;!isdigit(c);c=getchar())f^=c=='-';for(;isdigit(c);c=getchar())x=x*10+c-'0';if(f)x=-x;}\ntemplate<class T,class ...ARK>void read(T&x,ARK&...ark){read(x);read(ark...);}\ntemplate<class T>void write(T x){if(x<0)pc('-'),x=-x;if(x>=10)write(x/10);pc(x%10+'0');}\ntemplate<class T,class ...ARK>void write(T x,ARK...ark){write(x);pc(' ');write(ark...);}\ntemplate<class ...ARK>void writeln(ARK...ark){write(ark...);pc('\\n');}\ntypedef long long ll;\n#define lowbit(x) ((x)&-(x))\n#define mid ((l+r)>>1)\nconst int N=1e5+100;\nint n,q,nowk,col[N];//0=red 1=blue\nvector<int>e[N];\nstruct dtkdSGT{\n\t/*\n\t\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\n\t\u652f\u6301\uff1a \n\t(1)\u5355\u70b9\u52a0\u51cf\n\t(2)\u533a\u95f4\u67e5\u8be2\n\t(2)\u67e5\u8be2\u6700\u5c0f\u7684k\u6ee1\u8db3 k + 2 sum [k_i<=k] > m   \n\t*/\n\tint cnt,sum[N<<6],lc[N<<6],rc[N<<6];\n\tvoid pushup(int x){sum[x]=sum[lc[x]]+sum[rc[x]];}\n\tvoid upd(int&x,int l,int r,int pos,int val){\n\t\tif(!x)x=++cnt;\n\t\tif(l==r)return sum[x]+=val,void();\n\t\tif(pos<=mid)upd(lc[x],l,mid,pos,val);\n\t\telse upd(rc[x],mid+1,r,pos,val);\n\t\tpushup(x);\n\t}\n\tint qry(int x,int l,int r,int pre,int m){\n\t\tif(l==r)return l;\n\t\tif(mid+2*(pre+sum[lc[x]])>m)return qry(lc[x],l,mid,pre,m);\n\t\telse return qry(rc[x],mid+1,r,pre+sum[lc[x]],m);\n\t}\n\tint ct(int x,int l,int r,int ql,int qr){\n\t\tif(!x)return 0;\n\t\tif(ql<=l&&r<=qr)return sum[x];\n\t\tif(r<ql||qr<l)return 0;\n\t\treturn ct(lc[x],l,mid,ql,qr)+ct(rc[x],mid+1,r,ql,qr);\n\t}\n}T;\nint fa[N],son[N],sz[N],top[N],dep[N],lcnt[N],lrt[N];\nvoid dfs1(int u){\n\tdep[u]=dep[fa[u]]+1;sz[u]=1;\n\tfor(auto v:e[u])if(v!=fa[u])\n\t\tfa[v]=u,dfs1(v),sz[u]+=sz[v],lcnt[u]++;\n\tif(lcnt[u])lcnt[u]--;\n}\nvoid dfs2(int u){\n\tif(!top[u])top[u]=u;\n\tif(~col[u])return;\n\tpair<int,int>mx=mp(0,0);\n\tfor(auto v:e[u])if(v!=fa[u])chkmx(mx,mp(sz[v],v));\n\ttop[son[u]=mx.se]=top[u];\n\tfor(auto v:e[u])if(v!=fa[u])dfs2(v);\n}\n\nint root[N],pa[N],ch[N][2];//\u4e8c\u53c9\u6811\nbool isroot(int x){return ch[pa[x]][0]!=x&&ch[pa[x]][1]!=x;}\nstruct node{\n\t//\u7ef4\u62a4\u7684\u4e1c\u897f\n\tint k,a,b,c;\n\t// x>k a   x=k b   x<k-1 c\n\tnode(int x=0){k=a=b=c=x;}\n\tint operator()(int x)const{\n\t\tif(x>k)return a;\n\t\tif(x==k)return b;\n\t\tif(x<k)return c;\n\t}\n\tfriend node operator+(const node&f,const node&g){\n\t\t//\u8fd4\u56de f(g(x))\n\t\tnode res=g;\n\t\tres.a=f(g.a);res.b=f(g.b);res.c=f(g.c);\n\t\treturn res;\n\t}\n}f[N],mul[N];\n//f\u662f\u8fd9\u4e2a\u70b9\uff0cmul\u662f\u8fd9\u6bb5\u533a\u95f4\u590d\u5408\nvoid pushup(int x){\n\tmul[x]=f[x];\n\tif(ch[x][1])mul[x]=mul[x]+mul[ch[x][1]];\n\tif(ch[x][0])mul[x]=mul[ch[x][0]]+mul[x];\n}\nvoid upd(int x){\n\t//\u8ba1\u7b97 f\n\tint k=T.qry(lrt[x],-n-1,n+1,0,lcnt[x]);\n\tint delta=k+2*T.ct(lrt[x],-n-1,n+1,-n-1,k)-lcnt[x];\n\tassert(delta>0);\n\tint cnt0=T.ct(lrt[x],-n-1,n+1,k,k);\n\tf[x].k=k;\n\tif(delta==1)f[x].a=k+1;else f[x].a=k;\n\tf[x].b=k;\n\tif(delta-1-2*cnt0+2>1)f[x].c=k-1;\n\telse f[x].c=k;\n}\nint build(int l,int r,vector<int>&arr){\n\tif(l>r)return 0;\n\tint x=arr[mid];\n\tch[x][0]=build(l,mid-1,arr);if(ch[x][0])pa[ch[x][0]]=x;\n\tch[x][1]=build(mid+1,r,arr);if(ch[x][1])pa[ch[x][1]]=x;\n\tpushup(x);\n\treturn x;\n}\nvoid dfs3(int u){\n\t//\u5904\u7406\u91cd\u94fe\n\tvector<int>now;\n\tfor(int x=u;x;x=son[x])now.pb(x);\n\tfor(auto x:now)\n\t\tfor(auto y:e[x])if(y!=fa[x]&&y!=son[x])\n\t\t\tdfs3(y),T.upd(lrt[x],-n-1,n+1,mul[root[y]](0),1),pa[root[y]]=x;\n\tfor(auto x:now){\n\t\tif(son[x])upd(x);\n\t\telse{\n\t\t\tassert(sz[x]==1);\n\t\t\tif(col[x]==0)f[x]=node(-n-1);\n\t\t\telse f[x]=node(n+1);\n\t\t}\n\t}\n\troot[u]=build(0,now.size()-1,now);\n}\nvoid mdf(int x){\n\t//\u73b0\u5728\u6539\u4e86x\u7684\u989c\u8272\n\tif(col[x]==0)f[x]=node(-n-1);\n\telse f[x]=node(n+1);\n\tfor(;x;x=pa[x])\n\t\tif(isroot(x)){\n\t\t\tT.upd(lrt[pa[x]],-n-1,n+1,mul[x](0),-1);\n\t\t\tpushup(x);\n\t\t\tT.upd(lrt[pa[x]],-n-1,n+1,mul[x](0),1);\n\t\t\tupd(pa[x]);\n\t\t}else pushup(x);\n}\nnode qry(int x){\n\t//\u8be2\u95ee\u8fd9\u4e00\u6761\u91cd\u94fe\n\tnode res=f[x];\n\tif(ch[x][1])res=res+mul[ch[x][1]];\n\twhile(!isroot(x)){\n\t\tif(x==ch[pa[x]][0]){\n\t\t\tx=pa[x];res=res+f[x];\n\t\t\tif(ch[x][1])res=res+mul[ch[x][1]];\n\t\t}\n\t\telse x=pa[x];\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tread(n,nowk);\n\tfor(int i=1,u,v;i<n;i++)read(u,v),e[u].pb(v),e[v].pb(u);\n\tfor(int i=1;i<=n;i++)read(col[i]);\n\tdfs1(1);\n\tdfs2(1);\n\tdfs3(1);\n\tread(q);while(q--){\n\t\tint op;read(op);\n\t\tif(op==1){\n\t\t\tint v;read(v);node res=qry(v);\n\t\t\tassert(res.a==res.b&&res.b==res.c);\n\t\t\twrite((int)(nowk<res(0)));pc('\\n');\n\t\t}else if(op==2){\n\t\t\tint v;read(v);read(col[v]);\n\t\t\tmdf(v);\n\t\t}else read(nowk);\n\t}\n}\n```",
        "postTime": 1643442075,
        "uid": 174304,
        "name": "jun\u5934\u5409\u5409",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF1208H \u3010Red Blue Tree\u3011"
    },
    {
        "content": "\u8fd9\u662f\u4e00\u4e2a $\\mathcal{O}(n\\sqrt{n\\log n})$ \u7684\u505a\u6cd5\u3002\n\n\u66b4\u529b\u6bcf\u6b21\u6c42\u4e00\u904d\u53ef\u4ee5\u505a\u5230 $\\mathcal{O}(n^2)$\uff0c\u6bd4\u8f83\u56f0\u96be\u7684\u70b9\u662f\u4e00\u6b21 $3$ \u64cd\u4f5c\u5bf9\u4fe1\u606f\u7684\u6539\u53d8\u91cf\u662f\u53ef\u4ee5\u8fbe\u5230 $\\mathcal{O}(n)$ \u7ea7\u522b\u7684\uff0c\u800c\u4e14\u9012\u5f52\u5b9a\u4e49\u4e5f\u6bd4\u8f83\u70e6\u4eba\u3002\n\n\u8003\u8651\u6ca1\u6709 $3$ \u64cd\u4f5c\u600e\u4e48\u505a\uff0c\u53d1\u73b0\u4e00\u4e2a\u70b9\u7684\u5f71\u54cd\u662f\u4e00\u6761\u8fde\u7eed\u7684\u94fe\uff0c\u94fe\u4e0a\u6240\u6709\u70b9\u6ee1\u8db3\u540c\u8272\u4e14 $b_i-r_i$ \u7684\u503c\u662f\u76f8\u7b49\u7684\uff0c\u76f4\u63a5\u4f7f\u7528\u6811\u5256\u5927\u529b\u7ef4\u62a4\u94fe min \u7136\u540e\u94fe\u4e0a\u4e8c\u5206\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a $\\mathcal{O}(n\\log^2n)$ \u505a\u6cd5\u3002\n\n\u63a5\u4e0b\u6765\u6211\u5c1d\u8bd5\u5bfb\u627e $3$ \u64cd\u4f5c\u7684\u6027\u8d28\uff0c\u552f\u4e00\u53d1\u73b0\u7684\u6027\u8d28\u662f\uff0c\u5f53 $k$ \u589e\u5927\u7684\u65f6\u5019\u53ea\u4f1a\u5b58\u5728\u7531\u84dd\u53d8\u7ea2\u7684\u70b9\uff0c\u5f52\u7eb3\u4e0d\u96be\u8bc1\u660e\u3002\u6211\u4e00\u76f4\u5728\u5c1d\u8bd5\u89e3\u6790\u8fd9\u4e2a\u7ea2\u84dd\u70b9\u7684\u9012\u5f52\u5b9a\u4e49\uff0c\u4f46\u662f\u6ca1\u6709\u627e\u5230\u5f88\u597d\u7684\u89e3\u91ca\u65b9\u5f0f\u3002\n\n\u8003\u8651\u53ea\u6709 $3$ \u64cd\u4f5c\u600e\u4e48\u505a\uff0c\u53d1\u73b0\u968f\u7740 $k$ \u7684\u9012\u589e\uff0c\u4e00\u4e2a\u70b9\u53ea\u4f1a\u4ece\u84dd\u70b9\u53d8\u6210\u7ea2\u70b9\u4e00\u6b21\uff0c\u4ece\u53f6\u5b50\u5230\u6839\u4e8c\u5206\u53ef\u4ee5\u6c42\u51fa\u6bcf\u4e2a\u70b9\u53d8\u7ea2\u7684\u65f6\u523b\uff0c\u8fd9\u662f\u4e00\u4e2a $\\mathcal{O}(n\\log n)$ \u7684\u505a\u6cd5\u3002\n\n\u53ea\u6709\u64cd\u4f5c $3$ \u7684\u505a\u6cd5\u5f15\u5bfc\u6211\u8003\u8651\u8be2\u95ee\u5206\u5757\uff0c\u5bf9\u4e8e\u8fde\u7eed\u7684 $B$ \u4e2a\u64cd\u4f5c\uff0c\u8003\u8651\u6bcf\u6b21\u90fd\u628a\u524d\u7f00\u7684\u53f6\u5b50\u4fee\u6539\u64cd\u4f5c\u90fd\u8fdb\u884c\u4e00\u6b21\uff0c\u90a3\u4e48\u4e00\u4e2a\u53f6\u5b50\u4f1a\u5f71\u54cd\u5b83\u6240\u6709\u7684\u7956\u5148\u7ed3\u70b9\uff0c\u5f71\u54cd\u7684\u5f62\u6001\u548c\u865a\u6811\u975e\u5e38\u7c7b\u4f3c\u3002\u6240\u4ee5\u53ef\u4ee5\u628a\u53f6\u5b50\u7ed3\u70b9\u53ef\u4ee5\u8be2\u95ee\u7ed3\u70b9\u90fd\u62c9\u51fa\u6765\u5efa\u7acb\u4e00\u68f5\u865a\u6811\uff0c\u4e8e\u662f\u6bcf\u6b21\u8003\u8651\u64cd\u4f5c\u7684\u65f6\u5019\u53ea\u9700\u8981\u8003\u8651\u865a\u6811\u4e0a\u4e00\u6761\u94fe\u7684\u5f71\u54cd\uff0c\u5173\u952e\u70b9\u7684\u989c\u8272\u53ef\u4ee5\u5229\u7528\u66b4\u529b\u505a\u6cd5\u76f4\u63a5\u6c42\u51fa\u3002\u5957\u7528\u6811\u5256\u505a\u6cd5\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a $2\\log$ \u505a\u6cd5\u3002\u89c2\u5bdf\u53ef\u4ee5\u53d1\u73b0\uff0c\u5982\u679c\u8981\u8ba9\u4e00\u6761\u94fe\u6574\u4f53\u53cd\u8272\u7684\u6761\u4ef6\u975e\u5e38\u4e25\u82db\uff0c\u4ee5\u84dd\u8272\u53d8\u6210\u7ea2\u8272\u4e3a\u4f8b\uff0c\u9700\u8981\u6ee1\u8db3 $b_i-r_i\\geq k$ \u4e14 $b_i-r_i-2<k$\uff08\u56e0\u4e3a\u589e\u52a0\u4e00\u4e2a\u7ea2\u8272\u70b9\u4f1a\u8ba9 $b_i\\gets b_i-1,r_i\\gets r_i+1$\uff09\uff0c\u800c\u4e14\u5bb9\u6613\u53d1\u73b0\u4e00\u4e2a\u70b9\u7684 $b_i-r_i$ \u5947\u5076\u6027\u662f\u4e0d\u53d8\u7684\uff0c\u4e14\u968f\u7740 $k$ \u53d8\u5927\uff0c$b_i-r_i$ \u7684\u503c\u9012\u51cf\u3002\u6240\u4ee5\u53ef\u4ee5\u7ef4\u62a4\u4e00\u6761\u94fe\u4e0a $b_i-r_i$ \u7684\u5947\u6570\u6700\u5c0f\u503c\u548c\u5076\u6570\u6700\u5c0f\u503c\uff0c\u5957\u7528\u6761\u4ef6\u5c31\u53ef\u4ee5\u5f97\u5230 $\\mathcal{O}(1)$ \u5224\u65ad\u6574\u6761\u94fe\u80fd\u5426\u53cd\u8272\u7684\u65b9\u6cd5\u3002\n\n\u8fd9\u6837\u6211\u4eec\u5728 $\\mathcal{O}(n\\log n)$ \u9884\u5904\u7406\u548c\u603b\u5171 $\\mathcal{O}(B^2+n)$ \u7684\u65f6\u95f4\u5185\u89e3\u51b3\u4e86\u8fde\u7eed $B$ \u4e2a\u64cd\u4f5c\uff0c\u9009\u53d6\u5408\u9002\u7684 $B$ \u503c\u53ef\u4ee5\u505a\u5230\u7406\u8bba $\\mathcal{O}(n\\sqrt{n\\log n})$\u3002\u53d6 $B=3000$ \u53ef\u4ee5\u901a\u8fc7\u672c\u9898\u3002\n\n\u4ee3\u7801\uff08\u6ca1\u6709\u5199\u4efb\u4f55\u6570\u636e\u7ed3\u6784\u4f46\u662f\u8fd8\u662f\u8fbe\u5230\u4e86 206 \u884c/jk\uff09\n\n```cpp\n#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define ldb long double\n#define pb push_back\n#define mp make_pair\n#define pii pair<int, int>\n#define FR first\n#define SE second\nusing namespace std;\ninline int read() {\n    int x = 0; bool op = 0;\n    char c = getchar();\n    while(!isdigit(c))op |= (c == '-'), c = getchar();\n    while(isdigit(c))x = (x << 1) + (x << 3) + (c ^ 48), c = getchar();\n    return op ? -x : x;\n}\nconst int N = 2e5 + 10;\nconst int B = 3000;\nconst int INF = 1e9;\nint n, Q, cnt;\nint a[N], dfn[N], lf[N];\nvector<int> G[N], H[N];\nstruct Node {\n    int t, x, y;\n    Node() {}\n    Node(int t, int x, int y):t(t), x(x), y(y) {}\n}q[N];\nint F[N][25], dep[N];\nvoid pre(int u, int fa) {\n    dfn[u] = ++cnt; F[u][0] = fa; dep[u] = dep[fa] + 1;\n    for(int i = 1; i <= 20; i++)F[u][i] = F[F[u][i - 1]][i - 1];\n    for(int v : G[u])if(v != fa)pre(v, u);\n    return ;\n}\nint lca(int a, int b) {\n    if(dep[a] > dep[b])swap(a, b);\n    for(int i = 20; ~i; i--)if(dep[F[b][i]] >= dep[a])b = F[b][i];\n    if(a == b)return a;\n    for(int i = 20; ~i; i--)if(F[b][i] != F[a][i])a = F[a][i], b = F[b][i];\n    return F[a][0];\n}\nint top;\nint vis[N], s[N], f[N];\nvoid addedge(int u, int v) { \n    H[u].pb(v); H[v].pb(u); f[v] = u;\n    return ;\n}\nvoid build(vector<int> A) {\n    sort(A.begin(), A.end(), [&](int x, int y) {\n        return dfn[x] < dfn[y];\n    });\n    s[top = 1] = 1; vis[1] = true; H[1].clear();\n    for(int x : A) {\n        if(vis[x])continue;\n        int l = lca(x, s[top]);\n        if(l != s[top]) {\n            while(dfn[l] < dfn[s[top - 1]]) {\n                addedge(s[top - 1], s[top]);\n                top--;\n            }\n            if(l == s[top - 1])addedge(l, s[top--]);\n            else {\n                vis[l] = true; H[l].clear();\n                addedge(s[top - 1], s[top]); s[top] = l;\n            }\n        }\n        vis[x] = true; H[x].clear(); s[++top] = x;\n    }\n    for(int i = 1; i < top; i++)addedge(s[i], s[i + 1]);\n    return ;\n}\nint tot;\nint h[N], idl[N], g[N], b[N];\npii mn[N][2];\nvector<int> d[N];\nvoid update(int x, int y) {\n    pii &now = mn[x][y & 1];\n    if(y < now.FR)now.FR = y, now.SE = 1;\n    else if(y == now.FR)now.SE++;\n    return ;\n}\nvoid calc(int u, int fa) {\n    vector<int> A;\n    int now = 0;\n    for(int v : G[u]) {\n        if(v == fa)continue;\n        calc(v, u); A.pb(v);\n        if(lf[v] && a[v] == 0)now -= 2;\n        idl[u] = max(idl[u], idl[v]);\n    }\n    now += A.size();\n    if(vis[u]) {\n        idl[u] = ++tot;\n        mn[tot][0] = mn[tot][1] = mp(INF, 0);\n    }\n    if(lf[u])return h[u] = INF, void();\n    g[u] = now; a[u] = 1;\n    if(vis[u] == false)update(idl[u], now);\n    sort(A.begin(), A.end(), [&](int x, int y) {\n        return h[x] < h[y];\n    });\n    A.pb(n + 1);\n    if(now < h[A[0]])h[u] = now + 1;\n    else {\n        for(int i = 0; i + 1 < A.size(); i++) {\n            now -= 2;\n            if(now < h[A[i + 1]]) {\n                h[u] = max(h[A[i]], now + 1);\n                break;\n            }\n        }\n    }\n    d[h[u] + n].pb(u);\n    return ;\n}\nint query(int u, int fa, int k) {\n    if(lf[u])return (b[u] != -1 ? b[u] : a[u]);\n    int now = g[u];\n    for(int v : H[u]) {\n        if(v == fa)continue;\n        int t = query(v, u, k), l = dep[v] - dep[u] - 1;\n        pii c[2] = {mn[idl[v]][0], mn[idl[v]][1]};\n        int ok = (c[0].SE + c[1].SE == l);\n        int x = min(c[0].FR, c[1].FR), y = max(c[0].FR, c[1].FR);\n        if(y == INF)y = x;\n        if(t == 1 && a[v] == 0) {\n            if(l == 0 || (ok && y < k && x + 2 >= k)) {\n                now += 2;\n            }\n        }\n        if(t == 0 && a[v] == 1) {\n            if(l == 0 || (ok && x >= k && y - 2 < k)) {\n                now -= 2;\n            }\n        }\n    }\n    return now >= k;\n}\nint ans[N];\nint main() { \n    freopen(\"in.txt\", \"r\", stdin);\n    freopen(\"out.txt\", \"w\", stdout);\n    n = read();\n    int curk = read();\n    for(int i = 1; i < n; i++) {\n        int u = read(), v = read();\n        G[u].pb(v); G[v].pb(u);\n    }\n    for(int i = 1; i <= n; i++) {\n        a[i] = read(); lf[i] = (a[i] != -1);\n    }\n    pre(1, 0); h[n + 1] = INF;\n    Q = read();\n    for(int i = 1; i <= Q; i++) {\n        int op = read();\n        if(op == 1) {\n            int x = read();\n            q[i] = Node(1, x, curk);\n        }\n        else if(op == 2) {\n            int x = read(), y = read();\n            q[i] = Node(2, x, y);\n        }\n        else curk = read();\n    }   \n    for(int i = 1; i <= n; i++)b[i] = -1;\n    for(int i = 1; i <= Q; i += B) {\n        vector<int> A;\n        int l = i, r = min(i + B - 1, Q);\n        for(int j = l; j <= r; j++)if(q[j].x)A.pb(q[j].x);\n        build(A); tot = 0; calc(1, 0);\n        vector<int> pt;\n        for(int j = l; j <= r; j++)pt.pb(j);\n        sort(pt.begin(), pt.end(), [&](int x, int y) {\n            return q[x].y < q[y].y;\n        });\n        int now = -n;\n        for(int x : pt) {\n            if(q[x].t != 1)continue;\n            for(; now <= q[x].y; now++) {\n                for(int y : d[now + n]) {\n                    a[y] = 0; g[F[y][0]] -= 2;\n                    if(vis[F[y][0]] == false) {\n                        update(idl[F[y][0]], g[F[y][0]]);\n                    }\n                }\n            }\n            for(int j = l; j <= x; j++) {\n                if(q[j].t == 2)b[q[j].x] = q[j].y;\n            }\n            ans[x] = query(q[x].x, f[q[x].x], q[x].y);\n            for(int j = l; j <= x; j++) {\n                if(q[j].t == 2)b[q[j].x] = -1;\n            }\n        }\n        for(int j = 1; j <= n; j++)idl[j] = vis[j] = 0;\n        for(int j = l; j <= r; j++) {\n            if(q[j].t == 2)a[q[j].x] = q[j].y;\n        }\n        for(int i = 0; i <= (n << 1); i++)d[i].clear();\n    }\n    for(int i = 1; i <= Q; i++)if(q[i].t == 1)printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```\n\n\n",
        "postTime": 1672647686,
        "uid": 682934,
        "name": "yllcm",
        "ccfLevel": 0,
        "title": "Solution-CF1208H"
    },
    {
        "content": "# CF1208H Red Blue Tree\n\n\u539f\u672c\u5e94\u8be5\u653e\u5728[\u8fd9\u91cc](https://www.cnblogs.com/yijan/p/cf1208.html)\u4f46\u662f\u8fd9\u9898\u8fc7\u4e8e\u6bd2\u7624\u3002\u3002\u5355\u72ec\u5f00\u4e86\u7bc7blog\n\n\u9996\u5148\u8003\u8651\u5982\u679c $ k $ \u65e0\u9650\u5c0f\uff0c\u90a3\u4e48\u663e\u7136\u6574\u4e2a\u6811\u90fd\u662f\u84dd\u8272\u7684\u3002\u968f\u7740 $ k $ \u9010\u6e10\u589e\u5927\uff0c\u6bcf\u4e2a\u70b9\u90fd\u4f1a\u6709\u4e14\u4ec5\u6709\u4e00\u6b21\u53d8\u8272\uff0c\u6211\u4eec\u8003\u8651\u7ef4\u62a4\u8fd9\u4e2a\u53d8\u8272\u7684\u65f6\u95f4 $ t $ \u3002\u5982\u679c\u6bcf\u4e2a\u70b9\u7684\u53d8\u8272\u65f6\u95f4\u90fd\u5df2\u7ecf\u88ab\u7b97\u51fa\u6765\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u8f7b\u6613\u89e3\u51b3\u9898\u76ee\u7684\u67e5\u8be2\u64cd\u4f5c\u548c\u4fee\u6539 $ k $ \uff0c \u4e5f\u5c31\u662f\u8bf4\u4fee\u6539 $ k $ \u672c\u8eab\u5c31\u662f\u4e2a\u5047\u64cd\u4f5c\u3002\u3002\u53ea\u9700\u8981\u8003\u8651\u7684\u662f\u4fee\u6539\u5355\u70b9\u989c\u8272\u3002\n\n\u4fee\u6539\u5355\u70b9\u989c\u8272\uff0c\u770b\u8d77\u6765\u5c31\u5f88 $ ddp $ \u3002\u6811\u94fe\u5256\u5206\u540e\uff0c\u7528$ f(x) = \\{a,b\\} $ \u8868\u793a\u70b9 $ x $ \u91cd\u513f\u5b50\u662f `R` \u65f6\u7684\u4e34\u754c\u503c\u662f $ a $ \uff0c\u91cd\u513f\u5b50\u662f `B` \u65f6\u4e34\u754c\u503c\u662f $ b $ \u3002\n\n\u53d1\u73b0 $ f $ \u8fd9\u4e2a\u4e1c\u897f\u662f\u53ef\u4ee5\u5408\u5e76\u7684\uff01\u4e8e\u662f\u53ef\u4ee5\u6109\u5feb\u5730\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e86\u5462~\n\n\u4f46\u662f\u9664\u5f00\u91cd\u513f\u5b50\u600e\u4e48\u505a\u5462\uff0c\u8003\u8651\u6bcf\u4e2a\u70b9\u518d\u5f00\u4e00\u4e2a `BST` \u7ef4\u62a4\u8f7b\u513f\u5b50\u5f53\u524d\u7684\u8fb9\u754c\u503c\u3002\u8fd9\u4e2a\u53ef\u4ee5\u9884\u5904\u7406\u7684\u65f6\u5019\u5b9e\u73b0\u3002\u540c\u65f6\u6211\u4eec\u610f\u8bc6\u5230 $ \\sum x $ ( $ x $ \u662f\u8fb9\u754c\u503c ) \u662f $ n $ \u7ea7\u522b\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\u66b4\u529b\u51fa\u6700\u5f00\u59cb\u7684\u8fb9\u754c\u3002\u5177\u4f53\u7684\u66b4\u529b\u65b9\u6cd5\u662f\u5728build\u94fe\u5256\u540e\u7684\u7ebf\u6bb5\u6811\u65f6\u5148\u5904\u7406\u53f3\u5b50\u6811\uff0c\u8fd9\u6837\u603b\u53ef\u4ee5\u4fdd\u8bc1\u5904\u7406\u5230\u4e00\u4e2a\u70b9\u65f6\u5b83\u7684\u8f7b\u513f\u5b50\u90fd\u5df2\u7ecf\u88ab\u63d2\u5165\u5230\u4e86\u5b83\u81ea\u5df1\u7684\u5e73\u8861\u6811\uff0c\u7136\u540e\u76f4\u63a5\u679a\u4e3e\u8fb9\u754c\u503c\u5728\u5e73\u8861\u6811\u5224\u65ad\u5c31\u597d\u4e86\u3002\n\n\u7531\u4e8e\u6bcf\u6b21\u4fee\u6539\u4e00\u4e2a\u53f6\u5b50\uff0c\u5b83\u7684\u7956\u5148\u7684\u8fb9\u754c\u53d8\u5316\u91cf\u662f $ O(1) $ \u7684\uff0c\u6240\u4ee5\u4fee\u6539\u7684\u590d\u6742\u5ea6\u662f $ O(log^2n) $\n\n~~\u53ea\u662f\u5f88\u96be\u5199~~\n\nOrz LJZ_C \u540a\u8e29\u6807\u7b97\n\n```cpp\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200006\nint n , k;\n\n#define Update( cur ) if( cur -> left -> size ) cur -> size = cur -> left -> size + cur -> right -> size , cur -> value = cur -> right -> value\n#define new_Node( s , v , a , b ) ( & ( * st[ cnt++ ] = Node( s , v , a , b ) ) )\n#define Merge( a , b ) new_Node( a -> size + b -> size , b -> value , a , b )\n#define ratio 4\nnamespace BST {\n\tint cnt , s , a;\n\tstruct Node {\n\t    int size , value;\n\t    Node * left , * right;\n\t    Node( int s , int v , Node * a , Node * b ) : size( s ) , value( v ) , left( a ) , right( b ) {}\n\t    Node() {}\n\t} * root[1000000] , * father , * st[1000000] , t[1000000] , * null;\n\t\n\tinline void maintain( register Node * cur ) {\n\t    if( cur -> left -> size > cur -> right -> size * ratio ) cur -> right = Merge( cur -> left -> right , cur -> right ) , st[ --cnt ] = cur -> left , cur -> left = cur -> left -> left;\n\t    if( cur -> right -> size > cur -> left -> size * ratio ) cur -> left = Merge( cur -> left , cur -> right -> left ) , st[ --cnt ] = cur -> right , cur -> right = cur -> right -> right;\n\t}\n\t\n\tint find( int x , Node * cur ) {\n\t    if( cur -> size == 1 ) return cur -> value;\n\t    return x > cur -> left -> size ? find( x - cur -> left -> size , cur -> right ) : find( x , cur -> left );\n\t}\n\t\n\tint Rank( int x , Node * cur ) {\n\t    if( cur -> size == 1 ) return 1;\n\t    return x > cur -> left -> value ? Rank( x , cur -> right ) + cur -> left -> size : Rank( x , cur -> left );\n\t}\n\t\n\tvoid insert( int x , Node * cur ) {\n\t    if( cur -> size == 1 ) cur -> left = new_Node( 1 , min( cur -> value , x ) , null , null ) , cur -> right = new_Node( 1 , max( cur -> value , x ) , null , null );\n\t    else insert( x , x > cur -> left -> value ? cur -> right : cur -> left );\n\t    Update( cur );\n\t    maintain( cur );\n\t}\n\t\n\tvoid erase( int x , Node * cur ) {\n\t    if( cur -> size == 1 ) * father = cur == father -> left ? * father -> right : * father -> left;\n\t    else father = cur , erase( x , x > cur -> left -> value ? cur -> right : cur -> left );\n\t    Update( cur );\n\t    maintain( cur );\n\t}\n\t\n\tvoid init( ) {\n\t\tnull = new Node( 0 , 0 , 0 , 0 );\n\t\tfor( int i = 0 ; i < 1000000 ; ++ i ) st[i] = & t[i] , root[i] = new Node( 1 , 0x7f7f7f7f , null , null );\n\t}\n\t\n}\n\nint head[MAXN] , nex[MAXN << 1] , to[MAXN << 1] , ecn = 0;\nvoid ade( int u , int v ) {\n\tnex[++ecn] = head[u] , to[ecn] = v , head[u] = ecn; \n}\nint fa[MAXN] , siz[MAXN] , hea[MAXN] , dep[MAXN] , top[MAXN] , tig[MAXN] , bac[MAXN] , en[MAXN] , clo;\nvoid dfs( int u , int faa ) {\n\tsiz[u] = 1 , dep[u] = dep[faa] + 1;\n\tfor( int i = head[u] ; i ; i = nex[i] ) {\n\t\tint v = to[i];\n\t\tif( v == faa ) continue;\n\t\tfa[v] = u;\n\t\tdfs( v , u );\n\t\tsiz[u] += siz[v];\n\t\tif( !hea[u] || siz[v] > siz[hea[u]] ) hea[u] = v;\n\t}\n}\nvoid dfss( int u , int too ) {\n\ttig[u] = ++ clo , bac[clo] = u , en[too] = u , top[u] = too;\n\tif( !hea[u] ) return;\n\tdfss( hea[u] , too );\n\tfor( int i = head[u] ; i ; i = nex[i] ) {\n\t\tint v = to[i];\n\t\tif( v == fa[u] || v == hea[u] ) continue;\n\t\tdfss( v , v );\n\t}\n}\n\nint col[MAXN];\n\nstruct node{\n\tint l , r;\n\tnode( int L = 0 , int R = 0 ) : l(L) , r(R) { }\n} T[MAXN << 2] , red( 0x3f3f3f3f , 0x3f3f3f3f ) , blu( -0x3f3f3f3f , -0x3f3f3f3f ) ;\nint rec[MAXN];\n// T[rt].l : if rt's heavy son is red , the value k to satisfy that this node is red\n// T[rt].r : if rt's heavy son is blu , the value k to satisfy that this node is red\n// b : 0 , r : 1\nbool judge( int u , int k , int d ) { \n\t// return we add d red nodes to its son if the node is red.\n\tint B = BST :: Rank( k + 1 , BST :: root[u] ) - 1;\n\tint R = BST :: Rank( 0x7f7f7f7f , BST :: root[u] ) - 1 - B;\n\treturn k >= R - B - d;\n}\nvoid update( int u , int& k , int d ) {\n\twhile( !judge( u , k , d ) ) ++ k;\n\twhile( judge( u , k - 1 , d ) ) -- k;\n}\nvoid work( int rt , int u ) {\n\tif( col[u] == 0 ) {\n\t\tT[rt] = red;\n\t} else if( col[u] == 1 ) {\n\t\tT[rt] = blu;\n\t} else {\n\t\tupdate( u , T[rt].l , 1 );\n\t\tupdate( u , T[rt].r , -1 );\n\t}\n}\nnode merge( node a , node b ) {\n\tnode ret;\n\tret.l = min( max( b.l , a.l ) , a.r );\n\tret.r = min( max( b.r , a.l ) , a.r );\n\treturn ret;\n}\nvoid pushup( int rt ) {\n\tT[rt] = merge( T[rt << 1] , T[rt << 1 | 1] );\n}\nnode query( int rt , int l , int r , int L , int R ) {\n\tif( l == L && r == R ) return T[rt];\n\tint m = l + r >> 1;\n\tif( R <= m ) return query( rt << 1 , l , m , L , R );\n\tif( L > m ) return query( rt << 1 | 1 , m + 1 , r , L , R );\n\treturn merge( query( rt << 1 , l , m , L , m ) , query( rt << 1 | 1 , m + 1 , r , m + 1 , R ) );\n}\nvoid build( int rt , int l , int r ) {\n\tif( l == r ) {\n\t\tint u = bac[l];\n\t\twork( rt , u );\n\t\tif( u == top[u] && fa[u] ) \n\t\t\tBST :: insert( ( rec[u] = ( query( 1 , 1 , n , l , tig[en[u]] ) ).l ) , BST :: root[fa[u]] );\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild( rt << 1 | 1 , mid + 1 , r ) , build( rt << 1 , l , mid );\n\tpushup( rt );\n}\nvoid mdfy( int rt , int l , int r , int p ) {\n\tif( l == r ) { work( rt , bac[l] ); return; }\n\tint m = l + r >> 1;\n\tif( p <= m ) mdfy( rt << 1 , l , m , p );\n\telse mdfy( rt << 1 | 1 , m + 1 , r , p );\n\tpushup( rt );\n}\nvoid modify( int x , int c ) {\n\tcol[x] = c;\n\twhile( x ) {\n\t\tmdfy( 1 , 1 , n , tig[x] );\n\t\tx = top[x];\n\t\tif( fa[x] != 0 ) {\n\t\t\tBST :: erase( rec[x] , BST :: root[fa[x]] );\n\t\t\tBST :: insert( rec[x] = (query( 1 , 1 , n , tig[x] , tig[en[x]] ).l ) , BST :: root[fa[x]] );\n\t\t}\n\t\tx = fa[x];\n\t}\n}\n\nint main() {\n\tBST :: init( );\n\tcin >> n >> k;\n\tfor( int i = 1 , u , v ; i < n ; ++ i ) {\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tade( u , v ) , ade( v , u );\n\t}\n\tfor( int i = 1 ; i <= n ; ++ i ) scanf(\"%d\",&col[i]);\n\tdfs( 1 , 1 );\n\tdfss( 1 , 1 );\n\tbuild( 1 , 1 , n );\n\tint q , opt , v , c; cin >> q;\n\twhile( q-- ) {\n\t\tscanf(\"%d\",&opt);\n\t\tif( opt == 1 ) {\n\t\t\tscanf(\"%d\",&v);\n\t\t\tprintf(\"%d\\n\",( query( 1 , 1 , n , tig[v] , tig[en[top[v]]] ).l ) <= -k);\n\t\t} else if( opt == 2 ) {\n\t\t\tscanf(\"%d%d\",&v,&c);\n\t\t\tmodify( v , c );\n\t\t} else {\n\t\t\tscanf(\"%d\",&c);\n\t\t\tk = c;\n\t\t}\n\t\t\n\t}\n}\n```\n\n",
        "postTime": 1568729458,
        "uid": 63398,
        "name": "yijan",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF1208H \u3010Red Blue Tree\u3011"
    },
    {
        "content": "[\u63a8\u9500\u535a\u5ba2](https://foreverlasting1202.github.io/2019/08/27/CF1208%E9%A2%98%E8%A7%A3/)\n\n### H Red Blue Tree\n\n\u9898\u610f\uff1a\u6709\u4e00\u4e2a$n$\u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u53f6\u5b50\u4e0a\u90fd\u6709\u4e00\u4e2a\u56fa\u5b9a\u7684\u989c\u8272\uff08\u7ea2\u6216\u84dd\uff09\uff0c\u5bf9\u4e8e\u975e\u53f6\u5b50\u7684\u70b9\uff0c\u5b83\u7684\u989c\u8272\u662f\u7531\u5b83\u513f\u5b50\u4eec\u7684\u989c\u8272\u786e\u5b9a\u7684\u3002\u82e5\u5b83\u513f\u5b50\u7684\u84dd\u8272\u6570$-$\u7ea2\u8272\u6570\u5927\u4e8e\u7b49\u4e8e\u4e00\u4e2a\u56fa\u5b9a\u7684\u503c$k$\uff0c\u5219\u5b83\u4e5f\u662f\u84dd\u8272\u7684\u3002\u73b0\u6709\u4e09\u79cd\u64cd\u4f5c\uff1a\n\n\u4e00\u3001\u8be2\u95ee\u4e00\u4e2a\u70b9$x$\u7684\u989c\u8272\u3002\n\n\u4e8c\u3001\u5c06\u53f6\u5b50$x$\u7684\u989c\u8272\u6539\u6210$c$\u3002\n\n\u4e09\u3001\u5c06$k$\u6539\u6210$h$\u3002\n\n$1\\leq n,Q\\leq 10^5,-10^5\\leq k\\leq 10^5$\u3002\n\n\u505a\u6cd5\uff1a\u6ce8\u610f\u5230\u4e00\u4ef6\u4e8b\uff0c\u968f\u7740$k$\u7684\u9012\u589e\uff0c\u7ea2\u7684\u4e2a\u6570\u4e0d\u964d\uff0c\u53ef\u4ee5\u53d1\u73b0\u5728\u6811\u7684\u5f62\u6001\u56fa\u5b9a\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e2a\u70b9\u662f\u5426\u53d8\u7ea2\u662f\u6709\u4e00\u4e2a\u786e\u754c$k$\u3002\u8003\u8651\u5982\u4f55\u53bb\u7ef4\u62a4\u8fd9\u4e2a\u786e\u754c$k$\u3002\u53ef\u4ee5\u53d1\u73b0\u5bf9\u4e8e\u4e00\u4e2a\u70b9\u7684\u786e\u754c$k$\u53ef\u4ee5\u4ece\u5b83\u513f\u5b50\u7ee7\u627f\u4e0b\u6765\uff0c\u5373\u5047\u8bbe\u5b83\u513f\u5b50\u7684\u786e\u754c\u5206\u522b\u4e3a$k_1,k_2,...,k_m$\uff0c\u5b83\u7684\u786e\u754c\u5927\u4e8e\u7b49\u4e8e$k$\u5f53\u4e14\u4ec5\u5f53$m-2\\ast \\sum_{i=1,k_i<=k}^m 1>=k$\u3002\u8fd9\u4e2a\u4e1c\u897f\u5982\u679c\u66b4\u529b\u505a\uff0c\u5219\u53ef\u4ee5\u6bcf\u6b21\u5229\u7528\u5e73\u8861\u6811\u7ef4\u62a4\u513f\u5b50\u4fe1\u606f\u7136\u540e\u66b4\u529b\u8df3$k$\u3002\u4f46\u5982\u679c\u8fd9\u91cc\u66b4\u529b\u505a\u4e86\uff0c\u90a3\u53d8\u8272\u64cd\u4f5c\u5c31\u4e0d\u597d\u529e\u4e86\uff0c\u56e0\u4e3a\u4f60\u8981\u91cd\u65b0\u7ef4\u62a4\u8be5\u53f6\u5b50\u5230\u6839\u7684\u8def\u5f84\u4e0a\u6240\u6709\u7684\u786e\u754c$k$\uff0c\u4f46\u7406\u6027\u611f\u89c9\u4e00\u4e0b\uff0c\u5e73\u8861\u6811\u91cc\u4e00\u6b21\u53ea\u53d8\u5316\u4e86\u4e00\u4e2a\u70b9\uff0c$k$\u5927\u6982\u4e0d\u4f1a\u8df3\u5f88\u591a\u6b21\uff0c\u7136\u800c\u8fd9\u4e2a\u754c\u6211\u5e76\u4e0d\u4f1a\u4f30\uff0c\u611f\u89c9\u4e00\u4e0b\u662f$O(1)$\u7684\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u6bcf\u6b21\u66f4\u65b0\u4e00\u4e2a\u70b9\u7684\u786e\u754c$k$\u7684\u590d\u6742\u5ea6\u662f$O(logn)$\u4e86\u3002\u6240\u4ee5\u73b0\u5728\u7684\u95ee\u9898\u6240\u5728\u5c31\u662f\u5982\u4f55\u7ef4\u62a4\u66b4\u529b\u8df3\u7236\u4eb2\u8fd9\u4e2a\u64cd\u4f5c\u3002\n\n\u4e00\u822c\u9047\u5230\u8fd9\u79cd\u60c5\u51b5\uff0c\u6709\u4e2a\u663e\u7136\u7684\u60f3\u6cd5\u5c31\u662f\u7c7b\u4f3c$DDP$\u7684\u601d\u8def\u91cd\u94fe\u5256\u5206\uff0c\u53ea\u7ef4\u62a4\u8f7b\u513f\u5b50\u7684\u4fe1\u606f\uff0c\u91cd\u513f\u5b50\u5355\u72ec\u8003\u8651\u3002\u4e8e\u662f\u6211\u4eec\u53d1\u73b0\u8fd9\u9053\u9898\u4e5f\u53ef\u4ee5\u8fd9\u6837\u505a\u3002\u4e00\u4e2a\u7ed3\u70b9\u7ef4\u62a4\u7684\u5e73\u8861\u6811\u91cc\u53ea\u5305\u542b\u8f7b\u513f\u5b50\uff0c\u4e00\u6761\u91cd\u94fe\u5219\u5229\u7528\u7ebf\u6bb5\u6811\u53bb\u7ef4\u62a4\u8fd9\u6761\u91cd\u94fe\u548c\u5b83\u7684\u5e73\u8861\u6811\u4e0a\u7684\u4fe1\u606f\uff08\u8fd9\u91cc\u7684\u4fe1\u606f\u662f\u4ec0\u4e48\u53ef\u4ee5\u81ea\u5df1\u8003\u8651\u4e00\u4e0b\uff09\u3002\u8fd9\u6837\u7684\u8bdd\u4f60\u6bcf\u6b21\u66f4\u65b0\u7684\u590d\u6742\u5ea6\u5c31\u964d\u5230\u4e86$O(log^3n)$\uff08\u4e00\u4e2a$log$\u662f\u8df3\u91cd\u94fe\uff0c\u4e00\u4e2a$log$\u662f\u7ebf\u6bb5\u6811\u5355\u70b9\u4fee\u6539\uff0c\u4e00\u4e2a$log$\u662f\u66f4\u65b0\u786e\u754c$k$\uff09\uff0c\u67e5\u8be2\u662f$O(logn)$\u7684\u3002\u603b\u590d\u6742\u5ea6\u662f$O(nlog^3n)$\u3002\n\ncode\uff08\u4ee3\u7801\u770b\u7684$Benq$\u7684\uff0c\u7528\u4e86$pbds$\u51cf\u5c11\u7801\u91cf\uff0c\u6ce8\u610f\u4e00\u4e9b\u7ec6\u8282\uff09:\n```cpp\n//2019.8.28 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\n//#define pc(x) __builtin_popcountll(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\ntemplate <class T>using Tree=tree<T,null_type,less<T>,rb_tree_tag,tree_order_statistics_node_update>;\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\n//inline int read() {\n//    res s=0,ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\ninline int read() {\n    res s=0,ch=gc(),w=1;\n    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s*w;\n}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=2e5+10;\nnamespace MAIN{\n    int n,k;\n    vector<int> G[N];\n    int col[N],sz[N],du[N],fa[N],son[N],top[N],dfn[N],idx,pos[N],low[N];\n    Pair tr[N<<2];\n    inline Pair operator + (const RG Pair &x,const RG Pair &y){\n        return mp(min(x.se,max(x.fi,y.fi)),min(x.se,max(x.fi,y.se)));\n    }\n    Tree<Pair> T[N];\n    decltype(begin(T[0])) D[N];\n    inline int rankget(const RG Tree<Pair> &A,const res &x){\n        return A.order_of_key(mp(x,inf));\n    }\n    inline bool ck(const res &x,const res &val,const RG bool &fl){\n        res r=rankget(T[x],val)+fl,b=int(T[x].size())+1-r;\n        return b-r<val;\n    }\n    inline void change(const res &x,res &val,const RG bool &fl){\n        while(ck(x,val-1,fl))val--;\n        while(!ck(x,val,fl))val++;\n    }\n    void modify(res rt,res l,res r,const res &p){\n        if(l==r){\n            res x=pos[l];\n            if(du[x]==1&&x!=1)tr[rt]=(col[x]?mp(inf,inf):mp(-inf,-inf));\n            else change(x,tr[rt].fi,1),change(x,tr[rt].se,0);\n            return;\n        }\n        res mid=(l+r)>>1;\n        if(p<=mid)modify(rt<<1,l,mid,p);\n        else modify(rt<<1|1,mid+1,r,p);\n        tr[rt]=tr[rt<<1]+tr[rt<<1|1];\n    }\n    Pair query(res rt,res l,res r,const res &L,const res &R){\n        if(L<=l&&r<=R)return tr[rt];\n        res mid=(l+r)>>1;\n        if(L<=mid&&R>mid)return query(rt<<1,l,mid,L,R)+query(rt<<1|1,mid+1,r,L,R);\n        if(L<=mid)return query(rt<<1,l,mid,L,R);\n        return query(rt<<1|1,mid+1,r,L,R);\n    }\n    void dfs(res x,res fax){\n        sz[x]=1;\n        for(auto tox:G[x]){\n            if(tox==fax)continue;\n            dfs(tox,x),sz[x]+=sz[tox];\n            if(sz[tox]>sz[son[x]])son[x]=tox;\n        }\n    }\n    void dfs(res x,res fax,res topx){\n        fa[x]=fax,top[x]=topx,dfn[x]=++idx,pos[idx]=x;\n        if(son[x])dfs(son[x],x,topx),low[x]=low[son[x]];\n        else low[x]=dfn[x];\n        for(auto tox:G[x]){\n            if(tox==fa[x]||tox==son[x])continue;\n            dfs(tox,x,tox),D[tox]=T[x].insert(mp(query(1,1,n,dfn[tox],low[tox]).fi,x)).fi;\n        }\n        modify(1,1,n,dfn[x]);\n    }\n    inline void MAIN(){\n        n=read(),k=read();\n        for(res i=1;i<n;i++){\n            res u=read(),v=read();\n            G[u].pb(v),G[v].pb(u),du[u]++,du[v]++;\n        }\n        for(res i=1;i<=n;i++)col[i]=read();\n        dfs(1,0),dfs(1,0,1);\n        res Q=read();\n        while(Q--){\n            res opt=read();\n            if(opt==1){\n                res x=read();\n                puts(k>=query(1,1,n,dfn[x],low[x]).fi?\"0\":\"1\");\n            }\n            else if(opt==2){\n                res x=read(),c=read();\n                col[x]=c;\n                while(233){\n                    modify(1,1,n,dfn[x]),x=top[x];\n                    if(x==1)break;\n                    res Fa=fa[x];\n                    T[Fa].erase(D[x]),D[x]=T[Fa].insert(mp(query(1,1,n,dfn[x],low[x]).fi,x)).fi,x=Fa;\n                }\n            }\n            else k=read();\n        }\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}\n```",
        "postTime": 1567156011,
        "uid": 32878,
        "name": "foreverlasting",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF1208H \u3010Red Blue Tree\u3011"
    }
]