[
    {
        "content": "[\u535a\u5ba2\u5185\u89c2\u770b](https://www.cnblogs.com/Hs-black/p/12394644.html)\n\n\u665a\u4e0a\u6253cf\u4e00\u5f00\u59cb\u633a\u987a\u5229, \u8003\u8bd5\u7ed3\u675f\u524d\u4e09\u5206\u949f\u7b2c\u4e00\u9898\u88abhack(\u4e0d\u8fc7\u6211\u628a\u6570\u7ec4\u5f00\u5927\u4e9b\u91cd\u65b0\u4ea4\u4e00\u904d\u5c31\u8fc7\u4e86, \u4f46\u5206\u6570\u6389\u4e86\u4e00\u5927\u5806), e\u9898\u60f3\u51fa\u6765\u4e86\u4f46\u6ca1\u6709\u5199\u5b8c.... \u6211\u592a\u96be\u4e86\n\n---\n\n\u597d\u5427, \u8a00\u5f52\u6b63\u4f20\n\n### \u9898\u76ee\u5927\u610f\n\n\u4f60\u73b0\u5728\u6709\u4e00\u68f5\u8fb9\u6743\u90fd\u4e3a1\u6811, \u6bcf\u4e2a\u70b9\u90fd\u662f\u4e00\u4e2a\u57ce\u5e02, \u6709q\u6b21\u8be2\u95ee, \u6bcf\u6b21\u8baf\u95ee\u4e2d\u6709$k_i$\u4e2a\u57ce\u5e02\u611f\u67d3\u4e0d\u540c\u7684\u75c5\u6bd2, \u75c5\u6bd2\u4e00\u65e6\u611f\u67d3\u5c31\u4e0d\u4f1a\u6062\u590d\u5e76\u4e14\u611f\u67d3\u75c5\u6bd2\u7684\u57ce\u5e02\u4e0d\u4f1a\u518d\u88ab\u5176\u4ed6\u75c5\u6bd2\u611f\u67d3, \u6bcf\u4e2a\u75c5\u6bd2\u6709\u4f20\u64ad\u901f\u5ea6$s_i$, \u4f20\u64ad\u65b9\u5f0f\u6bd4\u8f83\u5947\u602a, \u6bcf\u4e00\u56de\u5408\u5185, \u4e00\u53f7\u75c5\u6bd2\u5f00\u59cb\u4f20\u64ad(\u4ece\u5b83\u5df2\u7ecf\u611f\u67d3\u7684\u57ce\u5e02x), \u8ddd\u79bbx\u5c0f\u4e8e$s_i$\u7684\u5c06\u5168\u90e8\u88ab\u611f\u67d3(\u4ee5\u524d\u611f\u67d3\u8fc7\u7684\u4e0d\u7b97), \u7136\u540e\u662f\u4e8c\u53f7\u4e09\u53f7...\u4e5f\u5c31\u662f\u8bf4\u4f20\u67d3\u8fc7\u7a0b\u4e0d\u662f\u540c\u65f6\u8fdb\u884c\u7684, \u800c\u662f\u4e00\u8f6e\u4e00\u8f6e\u7684, \u63a5\u4e0b\u6765\u4f60\u6709$m_i$\u4e2a\u91cd\u8981\u57ce\u5e02, \u95ee\u8fd9$m_i$\u4e2a\u57ce\u5e02\u88ab\u54ea\u79cd\u75c5\u6bd2\u611f\u67d3\n\n### \u6570\u636e\u8303\u56f4\n\n$1 \\le n, q, \\sum k_i, \\sum m_i \\le 200000$\n\n\n\n\u8fd9\u9898\u5173\u952e\u8bcd\"\u91cd\u8981\u7684\u57ce\u5e02\"\u548c$\\sum$\u7684\u6570\u636e\u8303\u56f4\u5df2\u7ecf\u66b4\u9732\u4e86\u5b83\u5c31\u662f\u4e2a\u865a\u6811, \u56e0\u4e3a\u5176\u4ed6\u70b9\u5bf9\u6211\u4eec\u6765\u8bf4\u662f\u4e0d\u91cd\u8981\u7684, \u9996\u5148\u6211\u4eec\u628a\u865a\u6811\u5efa\u51fa\u6765, \u6a21\u677f\u4e0d\u591a\u8bf4. \u7136\u540e\u5c31\u662f\u4ee5\u4e0b\u95ee\u9898:\n\n\u4f60\u6709\u4e00\u68f5\u6811, \u6709\u4e00\u4e9b\u70b9\u5df2\u7ecf\u88ab\u611f\u67d3\u4e86, \u6bcf\u6761\u8fb9\u6709\u8fb9\u6743, \u6c42\u8fd9\u68f5\u6811\u6240\u6709\u7684\u70b9\u88ab\u54ea\u79cd\u75c5\u6bd2\u611f\u67d3 ~~\u95ee\u9898\u5c31\u7b80\u5355\u591a\u4e86\u5427~~\n\n#### \u6211\u4f1abfs!\n\n\u4e0d\u96be\u53d1\u73b0\u6bcf\u79cd\u75c5\u6bd2\u7684\u611f\u67d3\u533a\u57df\u662f\u4e00\u4e2a\u8fde\u901a\u5757, \u76f4\u63a5\u4ece\u6bcf\u4e2a\u70b9bfs\u5c31\u884c\u4e86\u561b, \u4e8b\u5b9e\u4e0a\u4e0d\u597dbfs, \u56e0\u4e3a\u9898\u76ee\u4e2d\u6309\u65f6\u95f4\u8f6c\u79fb\u7684\u6027\u8d28\u4f7fbfs\u5728\u5904\u7406\u8fb9\u6743\u65f6\u4e0d\u592a\u597d\u505a, \u6709\u7cbe\u529b\u7684\u540c\u5b66\u53ef\u4ee5\u4e00\u8bd5, \u4e0d\u8fc7\u6211\u6302\u4e86\n\n#### \u6211\u4f1aspfa!\n\n\u8bbe\u6bcf\u4e2a\u70b9\u7684\u72b6\u6001\u662f{\u611f\u67d3\u65f6\u95f4, \u75c5\u6bd2\u79cd\u7c7b, \u75c5\u6bd2\u5230\u8fbe\u8be5\u70b9\u65f6\u7684\u56de\u5408\u4e2d\u4ece\u8be5\u70b9\u8fd8\u53ef\u4ee5\u8d70\u51e0\u6b65} \u6700\u540e\u8d70\u51e0\u6b65\u7684\u610f\u601d\u5c31\u662f\u60a8\u5728\u4e00\u4e2a\u56de\u5408\u5185\u611f\u67d3\u5230\u4e00\u4e2a\u70b9, \u7136\u800c\u56e0\u4e3a\u662f\u865a\u6811\u6709\u8fb9\u6743, \u6240\u4ee5\u53ef\u80fd\u505c\u5728\u67d0\u4e2a\u70b9\u8fd8\u5269\u7740\u4e00\u4e9b\u6b65\u6570. \u6240\u4ee5\u60a8\u4e0b\u4e00\u6b21\u4ece\u65b0\u611f\u67d3\u70b9\u6269\u5c55\u65f6, \u8303\u56f4\u53ef\u4ee5\u52a0\u4e0a\u4e0a\u56de\u6ca1\u8d70\u5b8c\u7684\u6b65\u6570.\n\n\u8fd9\u6837\u7684\u8bdd, \u6839\u636e\u9898\u610f, \u4f18\u5148\u7ea7\u662f\u611f\u67d3\u65f6\u95f4\u8d8a\u65e9\u8d8a\u597d, \u79cd\u7c7b\u6700\u5c0f\u8d8a\u597d, \u6b65\u6570\u8d8a\u591a\u8d8a\u597d. \u5982\u679c\u7528spfa\u8f6c\u79fb\u5e94\u8be5\u6ca1\u5565\u95ee\u9898.\n\n\u7136\u800c\u8fd8\u662f\u6709\u4e00\u4e9b\u5c0f\u95ee\u9898\u5c31\u662f\u5148\u611f\u67d3\u7684\u75c5\u6bd2\u4f1a\u6321\u4f4f\u522b\u7684\u75c5\u6bd2\u611f\u67d3\u7684\u53bb\u8def, \u800cspfa\u662f\u6ca1\u6709\u987a\u5e8f\u7684, \u7ed3\u679c\u5c31\u662f\u7f16\u53f7\u5927\u7684\u75c5\u6bd2\u5148\u611f\u67d3\u4ee5\u540e, \u7f16\u53f7\u5c0f\u7684\u672c\u53ef\u4ee5\u6321\u4f4f\u5b83, \u53ef\u56e0\u4e3a\u901f\u5ea6\u6162\u4e00\u4e9b, \u56e0\u65f6\u95f4\u65e0\u6cd5\u5c06\u4ed6\u66f4\u65b0.\n\n#### \u771f\u2022\u6b63\u89e3\n\n\u6839\u636e\u4ee5\u4e0a\u5206\u6790\u4e0d\u96be\u60f3\u5230\u6b63\u89e3, spfa\u4e0d\u884c\u5c31\u7528diji\u5457(\u6ed1\u7a3d\n\n\u6211\u4eec\u53ef\u4ee5\u7528\u4f18\u5148\u961f\u5217\u6765bfs, \u8fd9\u6837\u6bcf\u6b21\u66f4\u65b0\u8fdb\u6765\u7684\u70b9\u90fd\u662f\u8f83\u4f18\u7684, \u4ece\u961f\u5217\u4e2d\u53d6\u51fa\u6765\u7684\u65f6\u5019\u5c31\u662f\u6700\u4f18\u89e3\u4e86, ~~\u8fd9\u4e48\u7b80\u5355\u6211\u600e\u4e48\u4e00\u5f00\u59cb\u6ca1\u60f3\u5230QAQ~~\n\n\u4ee3\u7801:\n\n```cpp\n#pragma GCC optimize(3)\n#pragma GCC optimize(\"inline\")\n#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include <queue>\n#define ll long long\nusing namespace std;\nconst int N = 1005000;\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=(x<<3)+(x<<1)+(c^48);\n    if (f) x=-x;\n}\nint n, m;\nint h[N], ne[N], to[N];\nint dep[N], tot;\ninline void add(int x, int y) {\n    ne[++tot] = h[x], to[h[x] = tot] = y;\n}\nint siz[N], f[N], son[N];\nint Top[N], a[N], s[N], top;\nvoid dfs1(int x, int fa) {\n    siz[x] = 1, f[x] = fa, dep[x] = dep[fa] + 1;\n    for (int i = h[x]; i; i = ne[i]) {\n        int y = to[i]; if (y == fa) continue;\n        dfs1(y, x), siz[x] += siz[y];\n        if (siz[y] > siz[son[x]]) son[x] = y;\n    }\n}\n\nint dfn[N], num;\nvoid dfs2(int x, int topf) {\n    Top[x] = topf, dfn[x] = ++num;\n    if (!son[x]) return;\n    dfs2(son[x], topf);\n    for (int i = h[x]; i; i = ne[i]) \n        if (!dfn[to[i]]) dfs2(to[i], to[i]);\n}\n\nint Lca(int x, int y) {\n    while (Top[x] != Top[y]) {\n        if (dep[Top[x]] < dep[Top[y]]) swap(x, y);\n        x = f[Top[x]];\n    }\n    return dep[x] < dep[y] ? x : y;\n}\n\nbool cmp(int a, int b) {\n    return dfn[a] < dfn[b];\n}\n\nvector <int> v[N];\ninline void add_e(int x,int y) {\n    v[x].push_back(y); v[y].push_back(x);\n}\n\nvoid ins(int x) {\n    if (top == 1) return (void)(s[++top] = x);\n    int lca = Lca(x, s[top]); \n    if (lca == s[top]) return (void)(s[++top] = x);\n    while (top > 1 && dfn[s[top-1]] >= dfn[lca]) add_e(s[top-1], s[top]), top--;\n    if (lca != s[top]) add_e(lca, s[top]), s[top] = lca;\n    s[++top] = x;\n}\n\n\nint ask[N], vis[N];\n\nstruct node {\n\tint col, v, di, ti;\n\tbool operator < (const node &j) const{\n\t\tif (ti != j.ti) return ti < j.ti;\n\t\tif (col != j.col) return col < j.col;\n\t\treturn di > j.di;\n\t}\n}qaq[N], I;\n\ninline int Dis(int x, int y) {\n\treturn dep[x] + dep[y] - 2 * dep[Lca(x, y)];\n}\nnode To(int x, int y) {\n\tint dis = Dis(x, y);\n\tnode tmp = qaq[x]; \n\tif (dis <= qaq[x].di) {\n\t\ttmp.di -= dis; return tmp;\n\t}\n\tdis -= qaq[x].di;\n\tint t = (dis - 1) / qaq[x].v + 1;\n\ttmp.di = t * qaq[x].v - dis, tmp.ti += t;\n\treturn tmp;\n}\n\nstruct QWQ {\n\tnode p; int x;\n\tbool operator < (const QWQ &j) const { return j.p < p; }\n};\n\npriority_queue<QWQ> q;\n\nint T;\n\ninline bool Cmp(node a, QWQ b) { return a < b.p; }\n\nvoid diji(void) {\n\twhile (q.size()) {\n\t\tQWQ x = q.top(); q.pop();\n\t\tif (Cmp(qaq[x.x], x)) continue;\n\t\tfor (auto y: v[x.x]) {\n\t\t\tnode t = To(x.x, y);\n\t\t\tif (t < qaq[y]) {\n\t\t\t\tqaq[y] = t; q.push((QWQ){qaq[y], y});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid refresh(int x, int f) {\n\tfor (auto i: v[x]) {\n\t\tif (i == f) continue;\n\t\trefresh(i, x);\n\t}\n\tv[x].clear(); qaq[x] = I;\n}\n\nvoid init(int m, int k) {\t\n    int cnt = m;\n    for (int i = 1;i <= m; i++) {\n    \tread(a[i]), qaq[a[i]].col = i, read(qaq[a[i]].v);\n    \tqaq[a[i]].ti = 0; q.push((QWQ){qaq[a[i]], a[i]}); \n    }\n    for (int i = 1;i <= k; i++) \n    \tread(ask[i]), a[++cnt] = ask[i];\n    sort(a + 1, a + cnt + 1, cmp);\n    s[top = 1] = a[0] = 1;\n    for (int i = 1;i <= cnt; i++) {\n    \tif (a[i] == a[i-1]) continue;\n\t\tins(a[i]);\n\t}\n    while (top > 0) add_e(s[top - 1], s[top]), top--;\n}\n\nint main() {\n//\tfreopen (\"hs.in\",\"r\",stdin);\n//\tfreopen (\"hs.out\",\"w\",stdout);\n    read(n);\n    for (int i = 1;i < n; i++) {\n        int x, y; read(x), read(y);\n        add(x, y); add(y, x);\n    }\n    dfs1(1, 0), dfs2(1, 1);\n    I.col = n + 1, I.ti = n + 1;\n    for (int i = 1;i <= n; i++) qaq[i] = I;\n    int ww; read(ww);\n    while (ww--) {\n        int k, m; read(m), read(k);\n        init(m, k), diji();\n        for (int i = 1;i <= k; i++) printf (\"%d \", qaq[ask[i]].col);\n        putchar('\\n'); refresh(1, 0);\n    }\n    return 0;\n}\n```\n",
        "postTime": 1583219597,
        "uid": 122144,
        "name": "hs_black",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1320E \u3010Treeland and Viruses\u3011"
    },
    {
        "content": "[CF \u4f20\u9001\u95e8\uff1aCF1320E](https://codeforces.com/problemset/problem/1320/e)\n\n\u865a\u6811 + dijkstra\u3002\n\n\u89e3\u6cd5\u6765\u81ea @[hs_black](https://www.luogu.com.cn/user/122144)\u3002\n\n## Solution\n\n### 1\n\n\u53d1\u73b0 $m$ \u7684\u603b\u548c\u4e0e $n$ \u540c\u7ea7\u3002\u53c8\u56e0\u4e3a\u6bcf\u6b21\u8be2\u95ee\u53ea\u6d89\u53ca\u5230\u5c11\u6570\u8282\u70b9\uff0c\u6545\u77e5\u9053\u4f7f\u7528\u865a\u6811\u53bb\u4f18\u5316\u3002\n\n\u5efa\u865a\u6811\u4f18\u5316\u4ec0\u4e48\uff1f\u52a8\u6001\u89c4\u5212\u4f3c\u4e4e\u4e0d\u592a\u53ef\u505a\uff0c\u800c\u75c5\u6bd2\u611f\u67d3\u7684\u8fc7\u7a0b\u6709\u4e9b\u50cf\u6700\u77ed\u8def\u3002\n\n\u6700\u77ed\u8def\uff0c\u4f7f\u7528 $\\text{spfa}$\uff1f\u4f46 $\\text{spfa}$ \u662f\u65e0\u5e8f\u7684\uff0c\u800c\u75c5\u6bd2\u611f\u67d3\u662f\u6709\u5e8f\u7684\uff0c\u4e5f\u5373\u662f\u8bf4\uff0c\u4f7f\u7528 $\\text{spfa}$ \u53ef\u80fd\u4f1a\u8ba9\u67d0\u4e9b\u8282\u70b9\u6321\u4f4f\u75c5\u6bd2\u8fc7\u4e0d\u53bb\uff0c\u4f46\u5b9e\u9645\u4e0a\u75c5\u6bd2\u53ef\u4ee5\u7ee7\u7eed\u611f\u67d3\u3002\n\n$\\text{spfa}$ \u56e0\u4e3a\u65e0\u5e8f\u800c\u4e0d\u80fd\u4f7f\u7528\uff0c\u90a3\u5c31\u81ea\u7136\u60f3\u5230\u4f7f\u7528 $\\text{dijkstra}$\u3002\u5b83\u6709\u4f18\u5148\u961f\u5217\u7ef4\u62a4\uff0c\u6545\u6211\u4eec\u53ef\u4ee5\u81ea\u5b9a\u4e49\u4f18\u5148\u7ea7\u3002\n\n### 2\n\n\u663e\u7136\uff0c\u5f53\u524d\u8fdb\u884c\u7684\u8f6e\u6570\u662f\u7b2c\u4e00\u5173\u952e\u5b57\u3002\u8f6e\u6570\u5c0f\u7684\u80af\u5b9a\u4f18\u5148\u88ab\u9009\u53d6\u3002\u7136\u540e\u5728\u540c\u4e00\u8f6e\u4e2d\uff0c\u75c5\u6bd2\u611f\u67d3\u7684\u4f18\u5148\u7ea7\u53d7\u75c5\u6bd2\u5e8f\u53f7\u5927\u5c0f\u7684\u5f71\u54cd\u3002\u6545\u75c5\u6bd2\u5e8f\u53f7\u662f\u7b2c\u4e8c\u5173\u952e\u5b57\u3002\n\n\u90a3\u5982\u679c\u4e24\u4e2a\u8282\u70b9\u7684\u8f6e\u6570\u76f8\u540c\u3001\u67d3\u4e0a\u7684\u75c5\u6bd2\u4e5f\u76f8\u540c\uff0c\u6211\u4eec\u8be5\u4f18\u5148\u9009\u62e9\u54ea\u4e2a\uff1f\u6211\u4eec\u73b0\u5728\u5728\u8dd1\u6700\u77ed\u8def\uff0c\u800c\u75c5\u6bd2\u611f\u67d3\u53c8\u53d7\u4e24\u70b9\u95f4\u8def\u5f84\u957f\u5ea6\u7684\u5f71\u54cd\uff08\u6bcf\u4e2a\u75c5\u6bd2\u6709\u4e2a\u53c2\u6570 $s_i$\uff09\uff0c\u6545\u7b2c\u4e09\u5173\u952e\u5b57\u662f\u75c5\u6bd2\u5728\u6b64\u8f6e\u4e2d\u8fd8\u80fd\u4f20\u67d3\u7684\u8def\u5f84\u957f\u5ea6\u3002\n\n\u6709\u4e86\u8fd9\u4e09\u4e2a\u5173\u952e\u5b57\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u8dd1\u6700\u77ed\u8def\u4e86\u3002\n\n### 3\n\n\u8bb2\u4e00\u4e9b\u5b9e\u73b0\u7684\u7ec6\u8282\u3002\n\n\u56e0\u4e3a\u865a\u6811\u6d89\u53ca\u5230\u4e24\u70b9 $\\text{LCA}$ \u4ee5\u53ca\u6bcf\u70b9\u7684\u65f6\u95f4\u6233\uff0c\u800c\u4e14\u6700\u77ed\u8def\u4e2d\u8fd8\u8981\u6c42\u6811\u4e0a\u4e24\u70b9\u95f4\u8ddd\u79bb\uff0c\u6240\u4ee5\u4f7f\u7528\u6811\u94fe\u5256\u5206\u5b9e\u73b0\u3002\n\n\u5728\u5efa\u865a\u6811\u7684\u65f6\u5019\u4f1a\u5148\u6254\u4e00\u4e2a $1$ \u53f7\u8282\u70b9\u8fdb\u53bb\uff0c\u5c3d\u7ba1\u9898\u76ee\u4e2d\u5e76\u6ca1\u8bf4 $1$ \u53f7\u8282\u70b9\u662f\u4ec0\u4e48\u5173\u952e\u8282\u70b9\u6216\u8005\u6839\u8282\u70b9\u3002\u539f\u56e0\u662f $1$ \u53f7\u8282\u70b9\u662f\u6211\u4eec\u5047\u5b9a\u7684\u4e00\u4e2a\u6839\uff0c\u4ece\u5b83\u5f00\u59cb\u5efa\u865a\u6811\uff0c\u8fd9\u5bf9\u6700\u7ec8\u7b54\u6848\u5e76\u4e0d\u5f71\u54cd\uff0c\u4e0d\u8fc7\u6211\u4eec\u5728\u8ba1\u7b97\u5b8c\u7b54\u6848\u521d\u59cb\u5316\u7684\u65f6\u5019\u80fd\u56e0\u6b64\u7b80\u5316\u5f88\u591a\u7e41\u7410\u7684\u7279\u5224\u3002\n\n## Code\n\n\u9119\u4eba\u4e0d\u624d\uff0c\u5199\u7684\u65f6\u5019\u5c06\u51fd\u6570\u5f52\u7c7b\u4e86\u4e00\u4e0b\uff0c\u770b\u8d77\u6765\u6574\u9f50\u7b80\u6d01\u4e86\u70b9\uff0c\u5e0c\u671b\u80fd\u8ba9\u5b83\u65b9\u4fbf\u7406\u89e3\u4e9b\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define rep(i, a, b) for(register int i = a; i <= b; ++i)\nconst int maxn = 2e5 + 5;\nint n, qst;\nint hd[maxn], cnt;\nstruct edge{int to, nxt;}oe[maxn << 1];\nint sz[maxn], mxs[maxn], fa[maxn], dep[maxn];\nint tp[maxn], dfn[maxn], tot;\nint a[maxn], st[maxn], top;\nvector <int> ve[maxn];\nint ask[maxn];\nstruct pnts{\n    int col, v, di, ti;\n    bool operator <(const pnts &y) const{ return (ti != y.ti ? (ti < y.ti) : (col != y.col ? (col < y.col) : (di > y.di)));}\n}vr[maxn], I;\nstruct que{\n    pnts p; int x;\n    bool operator <(const que &j) const { return j.p < p; }\n}; priority_queue <que> q;\n//-----------------------------------------------\ninline void addo(int u, int v){oe[++cnt] = (edge){v, hd[u]}; hd[u] = cnt;}\ninline void dfs1(int u, int f){\n    fa[u] = f, dep[u] = dep[f] + 1, sz[u] = 1;\n    for(int v, i = hd[u]; i; i = oe[i].nxt){\n        if((v = oe[i].to) == f) continue;\n        dfs1(v, u), sz[u] += sz[v];\n        if(sz[mxs[u]] < sz[v]) mxs[u] = v;\n    }\n}\ninline void dfs2(int u, int anc){\n    tp[u] = anc, dfn[u] = ++tot;\n    if(!mxs[u]) return; dfs2(mxs[u], anc);\n    for(int v, i = hd[u]; i; i = oe[i].nxt)\n        if((v = oe[i].to) ^ fa[u] and v ^ mxs[u]) dfs2(v, v);\n}\ninline int LCA(int x, int y){\n    while(tp[x] != tp[y]){\n        if(dep[tp[x]] < dep[tp[y]]) swap(x, y);\n        x = fa[tp[x]];\n    } return dep[x] < dep[y] ? x : y;\n}\n//----------------Tree_Chain---------------------\ninline bool cmp(int x, int y){return dfn[x] < dfn[y];}\ninline void addv(int u, int v){ve[u].push_back(v), ve[v].push_back(u);}\ninline void insrt(int x){\n    int lca = LCA(x, st[top]);\n    if(top == 1 or lca == st[top]){st[++top] = x; return;}\n    while(top > 1 and dfn[st[top - 1]] >= dfn[lca]) addv(st[top - 1], st[top]), top -= 1;\n    if(lca ^ st[top]) addv(st[top], lca), st[top] = lca;\n    st[++top] = x;\n}\ninline void build(int tm, int k){\n    rep(i, 1, tm)\n        scanf(\"%d\", &a[i]), scanf(\"%d\", &vr[a[i]].v),\n        vr[a[i]].col = i, vr[a[i]].ti = 0, q.push((que){vr[a[i]], a[i]});\n    rep(i, 1, k) scanf(\"%d\", &ask[i]), a[++tm] = ask[i];\n    sort(a + 1, a + tm + 1, cmp); \n    st[top = 1] = a[0] = 1;\n    rep(i, 1, tm) if(a[i] != a[i - 1]) insrt(a[i]);\n    while(top > 0) addv(st[top - 1], st[top]), top -= 1;  \n}\ninline void init(int x, int f){\n    for(auto nxt : ve[x]) \n        if(nxt ^ f) init(nxt, x);\n    ve[x].clear(), vr[x] = I;\n}\n//----------------Virtual_Tree-------------------\ninline int dis(int x, int y){return dep[x] + dep[y] - 2 * dep[LCA(x, y)];}\ninline pnts updt(int lst, int nw){\n    int d = dis(lst, nw); pnts rec = vr[lst];\n    if(d <= vr[lst].di){rec.di -= d; return rec;}\n    d -= vr[lst].di; int dt =  (d - 1) / vr[lst].v + 1;\n    rec.di = dt * vr[lst].v - d, rec.ti += dt;\n    return rec;\n}\ninline void dijkstra(){\n    while(!q.empty()){\n        que nw = q.top(); q.pop();\n        if(vr[nw.x] < nw.p) continue;\n        for(auto nxt : ve[nw.x]){\n            pnts tmp = updt(nw.x, nxt); \n            if(tmp < vr[nxt])\n                vr[nxt] = tmp, q.push((que){vr[nxt], nxt});\n        }\n    }\n}\n//----------------Dijkstra-----------------------\nint main(){\n    scanf(\"%d\", &n); \n    rep(i, 2, n){\n        int x, y; scanf(\"%d%d\", &x, &y);\n        addo(x, y), addo(y, x);\n    } dfs1(1, 0), dfs2(1, 1);   \n    I.col = I.ti = n + 1; rep(i, 1, n) vr[i] = I;\n    scanf(\"%d\", &qst);\n    while(qst--){\n        int k, m; scanf(\"%d%d\", &m, &k);\n        build(m, k), dijkstra();\n        rep(i, 1, k) printf(\"%d \", vr[ask[i]].col);\n        printf(\"\\n\"), init(1, 0);\n    }\n    return 0;\n}\n```\n\n------------\n\u611f\u8c22\u9605\u8bfb\u3002\n",
        "postTime": 1658559233,
        "uid": 469672,
        "name": "\u4f0d\u53c1\u58f9",
        "ccfLevel": 7,
        "title": "\u3010CF1320E\u3011 Treeland and Viruses \u9898\u89e3"
    },
    {
        "content": "\u8fd9\u4e00\u9053\u9898\u4e00\u770b\u5c31\u50cf\u662f\u5efa\u865a\u6811\uff0c\u5148\u8003\u8651\u628a\u865a\u6811\u5efa\u51fa\u6765\uff0c\u7531\u4e8e\u67d0\u4e9b\u989c\u8272\u4f1a\u88ab\u963b\u65ad\uff0c\u6240\u4ee5\u4e0d\u80fd\u591f\u76f4\u63a5\u7528\u6811\u4e0a\u8def\u5f84\u957f\u5ea6\u6c42\u51fa\uff0c\u6240\u4ee5\u6bcf\u4e00\u4e2a\u70b9\u53ea\u80fd\u66f4\u65b0\u4e0e\u5b83\u76f8\u90bb\u7684\u70b9\uff0c\u6240\u4ee5\uff0c\u5148\u7528\u5b69\u5b50\u66f4\u65b0\u7236\u4eb2\uff0c\u7136\u540e\u518d\u7528\u7236\u4eb2\u66f4\u65b0\u5b69\u5b50\uff0c\u8fd9\u6837\u505a\u4e24\u904d\u4e4b\u540e\u5c31\u53ef\u4ee5\u5f97\u51fa\u7b54\u6848\u3002\u81f3\u4e8e\u4f9d\u6b21\u67d3\u8272\u7684\u9650\u5236\uff0c\u53ef\u4ee5\u76f4\u63a5\u7528\u4f18\u5148\u7ea7\u89e3\u51b3\u6389\uff08\u4ee5\u5230\u8fbe\u65f6\u95f4\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u989c\u8272\u79cd\u7c7b\u4e3a\u7b2c\u4e8c\u5173\u952e\u8bcd\uff09\u3002\u601d\u8def\u8fd8\u662f\u633a\u7b80\u6d01\u660e\u4e86\u7684\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6$O(n\\text{log}n)$\uff0c\u4e0d\u8fc7\u6211\u7684\u4ee3\u7801\u5e94\u8be5\u5e26\u4e0a\u4e86\u4e00\u4e2a\u5f88\u5927\u7684\u5e38\u6570\uff0c\u5982\u679c\u7528\u6811\u94fe\u5256\u5206\u6c42LCA\u5e94\u8be5\u4f1a\u5feb\u4e0d\u5c11\u3002\n\n\u611f\u89c9\u81ea\u5df1\u7684\u8bed\u6587\u6c34\u5e73\u4e0d\u592a\u591f\u554a\uff0c\u5982\u679c\u771f\u7684\u770b\u4e0d\u61c2\u5c31\u770b\u4ee3\u7801\u5427\uff0c\u4ee3\u7801\u5e94\u8be5\u4e5f\u4e0d\u96be\u7406\u89e3\u3002\n\n\u4ee3\u7801\u53ef\u4ee5\u53bb\u6211\u7684\u535a\u5ba2\u770b\uff1a[Codeforces 1320E. Treeland and Viruses \u9898\u89e3](https://www.cnblogs.com/withhope/p/12394858.html)",
        "postTime": 1583205325,
        "uid": 33362,
        "name": "Suiseiseki",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF1320E \u3010Treeland and Viruses\u3011"
    },
    {
        "content": "#### CF1320E Treeland and Viruses\n\n\u7531\u4e8e\u8be2\u95ee\u76f8\u4e92\u72ec\u7acb\u5e76\u4e14\u8be2\u95ee\u6d89\u53ca\u5230\u70b9\u7684\u603b\u6570\u5e76\u4e0d\u591a\uff0c\u56e0\u6b64\u8003\u8651\u865a\u6811\u3002\n\n\u5bf9\u4e8e\u4e00\u6b21\u8be2\u95ee\u6211\u4eec\u5148\u5efa\u51fa\u865a\u6811\uff0c\u90a3\u4e48\u5269\u4e0b\u7684\u95ee\u9898\u5c31\u662f\u5982\u4f55\u6c42\u51fa\u8fd9\u68f5\u865a\u6811\u4e0a\u6bcf\u4e2a\u70b9\u7684\u989c\u8272\u4e86\u3002\n\n\u90a3\u4e48\u95ee\u9898\u5c31\u53d8\u6210\u4e86\u4ee5\u8f6e\u6570\u4e3a\u7b2c\u4e00\u5173\u952e\u5b57\uff0c\u4ee5\u70b9\u51fa\u73b0\u7684\u65f6\u95f4\u4e3a\u7b2c\u4e8c\u5173\u952e\u5b57\u7684\u6811\u4e0a\u591a\u6e90\u6700\u77ed\u8def\uff0c\u5927\u529b$dijkstra$\u5373\u53ef\u3002\n\n\uff08\u7801\u91cf\u5de8\u5927\uff09\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#define N 200005\n#define mp make_pair\n#define pb push_back\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\nint n,q,v[N*2],head[N*2],nxt[N*2],cnt,dep[N],fa[N][25],dfn[N],dfstime,stk[N],top,p[N],tot,speed[N],key[N],vis[N],point[N],ip[N];\nvector<int>G[N],vec;\nvoid add(int a,int b)\n{\n\tv[++cnt]=b;\n\tnxt[cnt]=head[a];\n\thead[a]=cnt;\n}\nvoid dfs(int x,int f)\n{\n\tdep[x]=dep[f]+1;\n\tdfn[x]=++dfstime;\n\tfor(int i=0;i<=19;i++)fa[x][i+1]=fa[fa[x][i]][i];\n\tfor(int i=head[x];i;i=nxt[i])\n\t{\n\t\tif(v[i]==f)continue;\n\t\tfa[v[i]][0]=x;\n\t\tdfs(v[i],x);\n\t}\n}\nint lca(int x,int y)\n{\n\tif(dep[x]<dep[y])swap(x,y);\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(dep[fa[x][i]]>=dep[y])x=fa[x][i];\n\t}\n\tif(x==y)return x;\n\tfor(int i=20;i>=0;i--)\n\t{\n\t\tif(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i];\n\t}\n\treturn fa[x][0];\n}\nstruct node\n{\n\tint dist,tim,pre,id;\n\tbool operator<(const node a)const\n\t{\n        return a.tim==tim?ip[a.pre]<ip[pre]:a.tim<tim;\n    }\n}dis[N];\nint get(int dist,int pre){return (dist-1)/speed[pre]+1;}\nint cmp(int a,int b){return dfn[a]<dfn[b];}\nvoid build()\n{\n\tsort(p+1,p+1+tot,cmp);\n\ttot=unique(p+1,p+1+tot)-p-1;\n\tstk[top=1]=1;\n\tfor(int i=1;i<=tot;i++)\n\t{\n\t\tif(p[i]==1)continue;\n\t\tint LCA=lca(p[i],stk[top]);\n\t\t//cout<<p[i]<<\" \"<<stk[top]<<\" \"<<LCA<<endl;\n\t\tif(LCA!=stk[top])\n\t\t{\n\t\t\twhile(top>1&&dfn[stk[top-1]]>=dfn[LCA])G[stk[top-1]].pb(stk[top]),G[stk[top]].pb(stk[top-1]),--top;\n\t\t\tif(stk[top]!=LCA)G[LCA].pb(stk[top]),G[stk[top]].pb(LCA),stk[top]=LCA;\n\t\t}\n\t\tstk[++top]=p[i];\n\t}\n\tfor(int i=1;i<top;i++)G[stk[i+1]].pb(stk[i]),G[stk[i]].pb(stk[i+1]);\n}\nvoid dfss(int x,int f)\n{\n\t//cout<<x<<endl;\n\tint siz=G[x].size();\n\tvec.push_back(x);\n\tfor(int i=0;i<siz;i++)if(G[x][i]!=f)dfss(G[x][i],x);\n}\nvoid dij(int k)\n{\n\tpriority_queue<node>q;\n\t//for(int i=1;i<=tot;i++)dis[p[i]].dist=n+1,dis[p[i]].id=p[i],dis[p[i]].pre=0,dis[p[i]].tim=n+1,vis[p[i]]=0;\n\tvec.clear();dfss(1,0);int sizz=vec.size();\n\t//cout<<sizz<<endl;\n\tfor(int i=0;i<sizz;i++)dis[vec[i]].dist=n+1,dis[vec[i]].id=vec[i],dis[vec[i]].pre=0,dis[vec[i]].tim=n+1,vis[vec[i]]=0;\n\tfor(int i=1;i<=k;i++)dis[point[i]].dist=0,dis[point[i]].pre=point[i],dis[point[i]].tim=0,q.push(dis[point[i]]);\n\twhile(!q.empty())\n\t{\n\t\tnode c=q.top();int u=c.id;\n\t\tq.pop();\n\t\tif(vis[u])continue;\n\t\tvis[u]=1;\n\t\tint siz=G[u].size();\n\t\tfor(int i=0;i<siz;i++)\n\t\t{\n\t\t\tnode ff;ff.dist=dis[u].dist+abs(dep[u]-dep[G[u][i]]);ff.id=G[u][i];ff.pre=dis[u].pre;ff.tim=get(ff.dist,ff.pre);\n\t\t\tif(!(ff<dis[G[u][i]]))\n\t\t\t{\n\t\t\t\tdis[G[u][i]]=ff;\n\t\t\t\tq.push(ff);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve()\n{\n\tint k=read(),m=read();tot=0;\n\tfor(int i=1;i<=k;i++)\n\t{\n\t\tpoint[i]=read();speed[point[i]]=read();\n\t\tp[++tot]=point[i];ip[point[i]]=i;\n\t}\n\tfor(int i=1;i<=m;i++)key[i]=read(),p[++tot]=key[i];\n\tbuild();dij(k);\n//\tputs(\"------------------------\");\n//\tprintf(\"%d\\n\",tot);\n//\tfor(int i=1;i<=tot;i++)\n//\t{\n//\t\tprintf(\"%d %d \",p[i],G[p[i]].size());\n//\t\tfor(int j=0;j<G[p[i]].size();j++)printf(\"%d \",G[p[i]][j]);\n//\t\tputs(\"\");\n//\t}\n//\tputs(\"********************\");\n//\tfor(int i=1;i<=tot;i++)\n//\t{\n//\t\tprintf(\"%d %d %d %d\\n\",dis[p[i]].dist,dis[p[i]].id,dis[p[i]].pre,dis[p[i]].tim);\n//\t}\n//\tputs(\"!!!!!!!!!!!!!!!!!!!!\");\n\tfor(int i=1;i<=m;i++)printf(\"%d \",ip[dis[key[i]].pre]);\n\tputs(\"\");\n//\tputs(\"------------------------\");\n\tint sizz=vec.size();\n\tfor(int i=0;i<sizz;i++)G[vec[i]].clear();\n}\nint main()\n{\n\t//freopen(\"A.out\",\"w\",stdout);\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read(),y=read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs(1,0);\n\tq=read();\n\twhile(q--)solve();\n\treturn 0;\n}\n\n```\n\n",
        "postTime": 1611583848,
        "uid": 179600,
        "name": "shao0320",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF1320E \u3010Treeland and Viruses\u3011"
    },
    {
        "content": "\u6811\u4e0a\u6570\u636e\u7ed3\u6784\u95ee\u9898\uff0c\u591a\u7ec4\u8be2\u95ee\uff0c\u6240\u6709\u8be2\u95ee\u6d89\u53ca\u7684\u603b\u70b9\u6570\u4e0e\u6811\u7684\u5927\u5c0f\u540c\u9636\u3002\n\n\u8fd9\u73a9\u610f\u513f\u5c31\u662f\u5728\u660e\u793a\u865a\u6811\u561b......\n\n\u865a\u6811\u5efa\u51fa\u6765\u540e\uff0c\u95ee\u9898\u76f8\u5f53\u4e8e**\u6811\u4e0a\u591a\u6e90\u6700\u77ed\u8def**\uff0cdijkstra \u5373\u53ef\u3002\n\n```cpp\nconst int N = 2e5 + 7;\nint n, q, dfn[N], tot, f[N][21], d[N], s[N], t;\nvi e[N], g[N];\n\nvoid dfs(int x) {\n\tdfn[x] = ++tot;\n\tfor (int y : e[x]) \n\t\tif (y != f[x][0]) {\n\t\t\td[y] = d[x] + 1, f[y][0] = x;\n\t\t\tfor (int i = 1; f[y][i-1]; i++)\n\t\t\t\tf[y][i] = f[f[y][i-1]][i-1];\n\t\t\tdfs(y);\n\t\t}\n}\n\ninline int lca(int x, int y) {\n\tif (d[x] > d[y]) swap(x, y);\n\tfor (int i = 20; ~i; i--)\n\t\tif (d[f[y][i]] >= d[x]) y = f[y][i];\n\tif (x == y) return x;\n\tfor (int i = 20; ~i; i--)\n\t\tif (f[x][i] != f[y][i])\n\t\t\tx = f[x][i], y = f[y][i];\n\treturn f[x][0];\n}\n\ninline void virtual_tree(vi &p) {\n\tsort(p.begin(), p.end(), [](int x, int y) { return dfn[x] < dfn[y]; });\n\tp.erase(unique(p.begin(), p.end()), p.end());\n\tvi q = p;\n\tfor (int x : p) {\n\t\tint lca = ::lca(x, s[t]);\n\t\tif (lca != s[t]) {\n\t\t\twhile (t && d[s[t-1]] >= d[lca])\n\t\t\t\tg[s[t]].pb(s[t-1]), g[s[t-1]].pb(s[t]), --t;\n\t\t\tif (s[t] != lca)\n\t\t\t\tg[s[t]].pb(lca), g[lca].pb(s[t]), s[t] = lca, q.pb(lca);\n\t\t}\n\t\ts[++t] = x;\n\t}\n\tif (t) while (--t) g[s[t]].pb(s[t+1]), g[s[t+1]].pb(s[t]);\n\tp = q;\n}\n\nint w[N];\nbool v[N];\nstruct P {\n\tint d, i, x, r;\n\tinline P() {}\n\tinline P(int d, int i, int x) : d(d), i(i), x(x) {\n\t\tr = d ? (d - 1) / w[x] : -1;\n\t}\n\tinline bool operator < (const P o) const {\n\t\treturn r == o.r ? i < o.i : r < o.r;\n\t}\n\tinline P operator - () const {\n\t\tP o = *this;\n\t\to.r *= -1, o.i *= -1;\n\t\treturn o;\n\t}\n} u[N];\n\ninline void dijkstra(vi a, vi b, vi p) {\n\tpq<pair<P, int>> q;\n\tfor (int x : p) u[x].r = u[x].i = n, v[x] = 0;\n\tfor (ui i = 0; i < a.size(); i++)\n\t\tu[a[i]] = P(0, i, a[i]), q.push(mp(-u[a[i]], a[i]));\n\twhile (q.size()) {\n\t\tint x = q.top().se;\n\t\tq.pop();\n\t\tif (v[x]) continue;\n\t\tv[x] = 1;\n\t\tfor (int y : g[x]) {\n\t\t\tP o = P(u[x].d + abs(d[x] - d[y]), u[x].i, u[x].x);\n\t\t\tif (o < u[y]) u[y] = o, q.push(mp(-u[y], y));\n\t\t}\n\t}\n\tfor (int x : b) print(u[x].i + 1, ' ');\n\tprints(\"\");\n}\n\nint main() {\n\trd(n);\n\tfor (int i = 1, x, y; i < n; i++)\n\t\trd(x), rd(y), e[x].pb(y), e[y].pb(x);\n\td[1] = 1, dfs(1);\n\trd(q);\n\twhile (q--) {\n\t\tint A, B;\n\t\trd(A), rd(B);\n\t\tvi a, b, p;\n\t\tfor (int i = 1, x, y; i <= A; i++)\n\t\t\trd(x), rd(y), a.pb(x), p.pb(x), w[x] = y;\n\t\tfor (int i = 1, x; i <= B; i++)\n\t\t\trd(x), b.pb(x), p.pb(x);\n\t\tvirtual_tree(p);\n\t\tdijkstra(a, b, p);\n\t\tfor (int x : p) g[x].clear();\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1583219605,
        "uid": 100544,
        "name": "xht",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF1320E \u3010Treeland and Viruses\u3011"
    },
    {
        "content": "## $\\text{Description}$\n\u6709\u4e00\u68f5\u6709 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c$q$ \u6b21\u8be2\u95ee\uff08\u8be2\u95ee\u4e92\u76f8\u72ec\u7acb\uff09.  \n\u6bcf\u6b21\u7ed9\u5b9a $k_i$ \u4e2a\u989c\u8272\uff0c\u6bcf\u4e2a\u989c\u8272\u6709\u4e00\u4e2a\u8d77\u59cb\u70b9 $v_j$ \u548c\u79fb\u52a8\u901f\u5ea6 $s_j$\uff0c\u6bcf\u4e00\u4e2a\u989c\u8272\u5728\u6bcf\u4e00\u6b21\u64cd\u4f5c\u4e2d\u4f1a\u4f7f\u5b83\u5468\u56f4\u6ca1\u6709\u88ab\u67d3\u8272\u7684\u8fde\u901a\u5757\u4e0a\u4e0e\u5b83\u7684\u8ddd\u79bb\u4e0d\u8d85\u8fc7 $s_j$ \u7684\u70b9\u5168\u90e8\u67d3\u4e3a\u8fd9\u4e00\u4e2a\u989c\u8272.  \n\u6bcf\u4e00\u8f6e\u4e2d\uff0c\u989c\u8272\u4ece $1$ \u5230 $k_i$ \u4f9d\u6b21\u5f00\u59cb\u64cd\u4f5c\uff0c\u4e00\u76f4\u5230\u6240\u6709\u70b9\u5168\u90e8\u88ab\u67d3\u8272\u4e3a\u6b62\uff0c\u518d\u8be2\u95ee $m_i$ \u4e2a\u5173\u952e\u70b9\u7684\u989c\u8272.  \n$\\sum k_i \\le 2\\times 10^5,\\sum q_i \\le 2\\times 10^5$.\n## $\\text{Solution}$\n\u8bc4\u7ea7\u6709\u4e9b\u865a\u9ad8\u7684\u4e00\u9053\u9898.  \n\u6570\u636e\u8303\u56f4\u628a\u865a\u6811\u5199\u5728\u4e86\u8138\u4e0a.  \n\u6bcf\u6b21\u5efa\u51fa\u865a\u6811\uff0c\u5199\u4e00\u4e2a\u5165\u95e8\u7ea7\u7684\u6362\u6839 $\\text{dp}$ \u5373\u53ef.  \n\u6bd4\u4e00\u4e9b\u4e3b\u9898\u5e93\u7684\u7d2b\u8272\u865a\u6811\u9898\u597d\u5199\u591a\u4e86.  \n\u5b9e\u73b0\u4e0a\uff0c\u7531\u4e8e\u524d\u9762\u6392\u5e8f\u4e5f\u6302\u4e86 $\\log$\uff0c\u6211\u5c31\u5077\u61d2 $\\text{dp}$ \u6bcf\u4e2a\u5730\u65b9\u66f4\u65b0\u90fd\u91cd\u65b0\u6c42\u8ddd\u79bb\u4e86\uff0c\u4f46\u5b9e\u9645\u4e0a\u8fde\u5e26\u6743\u7684\u8fb9\u53ef\u4ee5 $O(1)$ \u8f6c\u79fb.\n## $\\text{Code}$\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nconst int N=3e5+100;\nconst double eps=1e-9;\ninline ll read(){\n  ll x(0),f(1);char c=getchar();\n  while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\n  while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n  return x*f;\n}\n\nint n,m,k;\n\nstruct node{\n  int to,nxt;\n}p[N<<1];\nint fi[N],cnt;\ninline void addline(int x,int y){\n  p[++cnt]=(node){y,fi[x]};fi[x]=cnt;\n  return;\n}\ninline void add(int x,int y){\n  addline(x,y);addline(y,x);return;\n}\n\nint pl[N][20],dep[N],pos[N],siz[N],tim;\nvoid dfs(int x,int f){\n  pl[x][0]=f;\n  dep[x]=dep[f]+1;pos[x]=++tim;\n  siz[x]=1;\n  for(int k=1;pl[x][k-1];k++) pl[x][k]=pl[pl[x][k-1]][k-1];\n  for(int i=fi[x];~i;i=p[i].nxt){\n    int to=p[i].to;\n    if(to==f) continue;\n    dfs(to,x);\n    siz[x]+=siz[to];\n  }\n  fi[x]=-1;\n  return;\n}\ninline int Lca(int x,int y){\n  if(pos[x]<=pos[y]&&pos[y]<=pos[x]+siz[x]-1) return x;\n  for(int k=18;k>=0;k--){\n    int o=pl[x][k];\n    if(!o||(pos[o]<=pos[y]&&pos[y]<=pos[o]+siz[o]-1)) continue;\n    x=o;\n  }\n  return pl[x][0];\n}\ninline int dis(int x,int y){\n  int lca=Lca(x,y);\n  return dep[x]+dep[y]-2*dep[lca];\n}\n\nint v[N],zhan[N],top,ask[N],tot;\nbool cmp(int x,int y){return pos[x]<pos[y];}\nint col[N],d[N],id[N];\nint bel[N],up[N],down[N],tt[N];\nvoid solve1(int x){\n  down[x]=up[x]=bel[x]=0;\n  for(int i=fi[x];~i;i=p[i].nxt){\n    int to=p[i].to;\n    solve1(to);\n    int o=down[to];\n    if(o){\n      int t=(dis(id[o],x)+d[o]-1)/d[o];\n      if(!down[x]||t<tt[x]||(t==tt[x]&&o<down[x])){\n\tdown[x]=o;tt[x]=t;\n      }\n    }\n  }\n  if(col[x]) down[x]=col[x],tt[x]=0;\n  //printf(\"solve1: x=%d down=%d tt=%d\\n\",)\n}\nvoid solve2(int x,int f){\n  if(f){\n    int o=bel[f];\n    if(!down[x]) bel[x]=o;\n    else{\n      int t=(dis(id[o],x)+d[o]-1)/d[o];\n      //printf(\"solve2:x=%d f=%d o=%d t=%d tt=%d down=%d\\n\",x,f,o,t,tt[x],down[x]);\n      if(t<tt[x]||(t==tt[x]&&o<down[x])){\n\tbel[x]=o;\n      }\n      else bel[x]=down[x];\n    }\n  }\n  else bel[x]=down[x];\n  for(int i=fi[x];~i;i=p[i].nxt){\n    int to=p[i].to;\n    solve2(to,x);\n  }\n  fi[x]=-1;\n}\nbool vis[N];\nint main(){\n#ifndef ONLINE_JUDGE\n  freopen(\"a.in\",\"r\",stdin);\n  freopen(\"a.out\",\"w\",stdout);\n#endif\n  memset(fi,-1,sizeof(fi));\n  n=read();\n  for(int i=1;i<n;i++){\n    int x=read(),y=read();add(x,y);\n  }\n  dfs(1,0);\n  int q=read();\n  for(int t=1;t<=q;t++){\n    cnt=-1;\n    int k=read(),m=read();\n    for(int i=1;i<=k;i++){\n      id[i]=v[i]=read();d[i]=read();\n      col[v[i]]=i;\n      vis[v[i]]=1;\n    }\n    tot=k;\n    for(int i=1;i<=m;i++){\n      ask[i]=read();\n      if(!vis[ask[i]]){\n\tv[++tot]=ask[i];vis[ask[i]]=1;\n      }\n    }\n    \n    sort(v+1,v+1+tot,cmp);\n    //printf(\"v: \");for(int i=1;i<=tot;i++) printf(\"%d \",v[i]);\n    //putchar('\\n');\n    zhan[top=1]=v[1];\n    for(int i=2;i<=tot;i++){\n      int x=v[i],lca=Lca(x,zhan[top]);\n      //printf(\"i=%d x=%d lca=%d\\n\",i,x,lca);\n      while(top>1&&dep[lca]<=dep[zhan[top-1]]){\n\taddline(zhan[top-1],zhan[top]);\n\t//printf(\"%d->%d\\n\",zhan[top-1],zhan[top]);\n\t--top;\n      }\n      if(zhan[top]!=lca){\n\taddline(lca,zhan[top]);\n\t//printf(\"%d->%d\\n\",lca,zhan[top]);\n\tzhan[top]=lca;\n      }\n      zhan[++top]=x;\n    }\n    while(top>1){\n      addline(zhan[top-1],zhan[top]);\n      //printf(\"%d->%d\\n\",zhan[top-1],zhan[top]);\n      --top;\n    }\n\n    int rt=zhan[1];\n    solve1(rt);solve2(rt,0);\n    for(int i=1;i<=m;i++) printf(\"%d \",bel[ask[i]]);\n    putchar('\\n');\n    \n    for(int i=1;i<=tot;i++) col[v[i]]=0,vis[v[i]]=0;\n  }\n  return 0;\n}\n/*\n*/\n\n```\n",
        "postTime": 1639120884,
        "uid": 449265,
        "name": "wind_whisper",
        "ccfLevel": 10,
        "title": "CF1320E Treeland and Viruses"
    },
    {
        "content": "### CF1320E Treeland and Viruses\n\n\u4ed4\u7ec6\u89c2\u5bdf\u9898\u76ee\uff0c\u76f4\u63a5\u4e0a\u865a\u6811\u3002\n\n\u518d\u8003\u8651\u5957\u8def `dp`\uff0c\u53d1\u73b0\u6709\u8bb8\u591a\u4f18\u5148\u7ea7\u4e0d\u592a\u597d\u505a\u3002\n\n\u8003\u8651 `spfa`\uff0c\u53d1\u73b0\u4e00\u4e2a\u70b9\u88ab\u611f\u67d3\u540e\uff0c\u53e6\u5916\u7684\u75c5\u6bd2\u4e0d\u80fd\u8d70\u8fd9\u4e2a\u70b9\uff0c\u4e0d\u592a\u597d\u505a\u3002\n\n\u8003\u8651\u4f18\u5148\u961f\u5217\uff0c\u6bcf\u6b21\u53d6\u6700\u4f18\u7684\u70b9\u66f4\u65b0\uff0c\u663e\u7136\u6b63\u89e3\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n \\log n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n#define ha putchar(' ')\n#define he putchar('\\n')\n\ninline int read()\n{\n\tint x = 0, f = 1;\n\tchar c = getchar();\n\twhile (c < '0' || c > '9')\n\t{\n\t\tif (c == '-')\n\t\t\tf = -1;\n\t\tc = getchar();\n\t}\n\twhile (c >= '0' && c <= '9')\n\t\tx = x * 10 + c - '0', c = getchar();\n\treturn x * f;\n}\n\ninline void write(int x)\n{\n\tif(x < 0)\n\t{\n\t\tputchar('-');\n\t\tx = -x;\n\t}\n\tif(x > 9)\n\t\twrite(x / 10);\n\tputchar(x % 10 + '0');\n}\n\nconst int _ = 2e5 + 10;\n\nint n, Q, k, m, t, s[_], w[_];\n\nbool vis[_];\n\nint cnt, dfn[_], fa[_], siz[_], hson[_], top[_], dep[_];\n \nvector<int> d[_], v, p, q, a, b, g[_];\n\nbool cmp(int u, int v)\n{\n\treturn dfn[u] < dfn[v];\n}\n\nvoid dfs1(int u, int D = 1)\n{\n\tdep[u] = D, siz[u] = 1, dfn[u] = ++cnt;\n\tfor(int v : d[u])\n\t{\n\t\tif(siz[v]) continue;\n\t\tfa[v] = u;\n\t\tdfs1(v, D + 1);\n\t\tsiz[u] += siz[v];\n\t\tif(siz[hson[u]] < siz[v]) hson[u] = v;\n\t}\n}\n\nvoid dfs2(int u, int tf)\n{\n\ttop[u] = tf;\n\tif(hson[u]) dfs2(hson[u], tf);\n\tfor(int v : d[u])\n\t{\n\t\tif(top[v]) continue;\n\t\tdfs2(v, v);\n\t}\n}\n\nint LCA(int u, int v)\n{\n//\tcout << \"1\\n\";\n\twhile(top[u] != top[v])\n\t{\n//\t\tcout << \"2\\n\";\n\t\tif(dep[top[u]] < dep[top[v]]) swap(u, v);\n\t\tu = fa[top[u]];\n\t}\n//\tcout << \"3\\n\";\n\treturn dep[u] > dep[v] ? v : u;\n}\n\nint Dis(int x, int y)\n{\n\treturn dep[x] + dep[y] - 2 * dep[LCA(x, y)];\n}\n\nvoid build()\n{\n\tq = p;\n\tfor(int x : p)\n\t{\n\t\tint lca = LCA(x, s[t]);\n\t\tif(lca != s[t])\n\t\t{\n\t\t\twhile(t && dep[s[t - 1]] >= dep[lca])\n\t\t\t{\n\t\t\t\tg[s[t]].push_back(s[t - 1]), g[s[t - 1]].push_back(s[t]);\n\t\t\t\t--t;\n\t\t\t}\n\t\t\tif(s[t] != lca)\n\t\t\t{\n\t\t\t\tg[s[t]].push_back(lca), g[lca].push_back(s[t]);\n\t\t\t\ts[t] = lca;\n\t\t\t\tq.push_back(lca);\n\t\t\t}\n\t\t}\n\t\ts[++t] = x;\n\t}\n\tif(t)\n\t\twhile (--t) g[s[t]].push_back(s[t + 1]), g[s[t + 1]].push_back(s[t]);\n\tp = q;\n}\n\nstruct abc\n{\n\tint d, i, x, r;\n\tabc()\n\t{\n\t\t\n\t}\n\tabc(int d, int i, int x) : d(d), i(i), x(x)\n\t{\n//\t\tif(!w[x])\n//\t\t{\n////\t\t\tcout << x << \"\\n\";\n////\t\t\tcout << \"!!!!!!!!!\\n\";\n//\t\t\texit(0);\n//\t\t}\n\t\tr = d ? (d - 1) / w[x] : -1;\n\t}\n\tbool operator < (const abc o) const\n\t{\n\t\treturn r == o.r ? i < o.i : r < o.r;\n\t}\n} dis[_];\n\nstruct Node\n{\n\tabc a; int id;\n\tbool operator < (const Node &t) const\n\t{\n\t\treturn a.r == t.a.r ? a.i > t.a.i : a.r > t.a.r;\n\t}\n};\n\nvoid dij()\n{\n\tpriority_queue<Node> q;\n\tfor(int x : p)\n\t{\n\t\tdis[x].r = dis[x].i = n;\n\t\tvis[x] = 0;\n\t}\n\tfor(int i = 0; i < a.size(); i++)\n\t{\n\t\tdis[a[i]] = abc(0, i + 1, a[i]);\n\t\tq.push({dis[a[i]], a[i]});\n\t}\n\twhile(!q.empty()) {\n\t\tint x = q.top().id;\n\t\tq.pop();\n\t\tif (vis[x]) continue;\n\t\tvis[x] = 1;\n//\t\tcout <<x << \"\\n\";\n\t\tfor (int y : g[x])\n\t\t{\n//\t\t\tcout << \": \" << y << \"\\n\";\n\t\t\tabc nw = abc(dis[x].d + Dis(x, y), dis[x].i, dis[x].x);\n\t\t\tif (nw < dis[y])\n\t\t\t{\n\t\t\t\tdis[y] = nw;\n\t\t\t\tq.push({dis[y], y});\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x : b) write(dis[x].i), ha;\n\the;\n}\n\nsigned main()\n{\n\tn = read();\n\tfor(int i = 1, u, v; i < n; ++i)\n\t{\n\t\tu = read(), v = read();\n\t\td[u].push_back(v);\n\t\td[v].push_back(u);\n\t}\n\tdfs1(1), dfs2(1, 1);\n\tQ = read();\n\twhile(Q--)\n\t{\n\t\tk = read(), m = read();\n\t\tv.clear(), p.clear(), a.clear(), q.clear(), b.clear();\n\t\tfor(int i = 1, x, y; i <= k; ++i)\n\t\t{\n\t\t\tx = read(), y = read();\n\t\t\ta.push_back(x);\n\t\t\tv.push_back(x), w[x] = y;\n\t\t}\n\t\tfor(int i = 1, x; i <= m; ++i)\n\t\t{\n\t\t\tx = read();\n\t\t\tb.push_back(x);\n\t\t\tv.push_back(x);\n\t\t}\n\t\tsort(v.begin(), v.end(), cmp);\n\t\tfor(int i = 0; i < v.size() - 1; ++i)\n\t\t\tif(v[i] != v[i + 1]) p.push_back(v[i]);\n\t\tp.push_back(v[v.size() - 1]);\n\t\tbuild();\n//\t\tfor(int x : p) cout << x <<\" \";\n//\t\tcout << \"!!\\n\";\n\t\tdij();\n\t\tfor(int x : p) g[x].clear();\n\t}\n}\n\n/*\n7\n1 2\n1 3\n2 4\n2 5\n3 6\n3 7\n\n3\n2 2\n4 1\n7 1\n\n1 3\n\n2 2\n4 3\n7 1\n\n1 3\n\n3 3\n1 1\n4 100\n7 100\n\n1 2 3\n*/\n\n```",
        "postTime": 1658474426,
        "uid": 257146,
        "name": "orz_z",
        "ccfLevel": 0,
        "title": "CF1320E Treeland and Viruses"
    }
]