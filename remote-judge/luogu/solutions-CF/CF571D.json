[
    {
        "content": "# CF571D Campus\n\n[blog](https://www.cnblogs.com/Hs-black/p/12549222.html)\u5185\u83b7\u5f97\u66f4\u4f73\u4f53\u9a8c\n\n\u4e00\u7ffb\u9898\u89e3, \u90fd\u662f\u5efa\u865a\u70b9\u7684\u79bb\u7ebf\u505a\u6cd5, \u8fd9\u91cc\u63d0\u4f9b\u4e00\u4e2a\u66f4\u597d\u60f3\u4e5f\u66f4\u597d\u5199\u7684\u5728\u7ebf\u505a\u6cd5(\u96fe\n\n\u4e00\u770b\u6d89\u53ca\u5230\u5408\u5e76, \u5c31\u60f3\u5230\u4e86\u5e76\u67e5\u96c6, \u4f46\u6709\u4e00\u4e9b\u52a0\u554a, \u8d4b\u503c\u554a, \u6240\u4ee5\u4e0d\u53ef\u8def\u5f84\u538b\u7f29, \u90a3\u5c31\u6309\u79e9\u5408\u5e76\u5457\n\n\u6309\u79e9\u5408\u5e76\u5c31\u662f\u901a\u8fc7\u5408\u5e76\u65f6\u628a\u8f83\u5c0f\u7684\u8054\u901a\u5757\u53eb\u8f83\u5927\u7684\u8fde\u901a\u5757\u7238\u7238\u83b1\u4fdd\u8bc1\u4e25\u683clog\u7684\u65f6\u95f4\u590d\u6742\u5ea6, \u540c\u65f6, \u4e00\u4e2a\u8fde\u901a\u5757\u7684\u9ad8\u5ea6\u4e5f\u662flog\u7684\n\n\u6309\u79e9\u5408\u5e76\u7684\u597d\u5904\u5c31\u662f\u5b83\u7684\u5185\u90e8\u5f62\u6001\u4e0d\u4f1a\u53d8, \u5982\u679c\u6253\u6807\u8bb0\u56de\u6bd4\u8f83\u65b9\u4fbf\n\n\u56de\u5230\u672c\u9898, \u5efa\u7acb\u4e24\u9897\u6309\u79e9\u5408\u5e76\u7684\u5e76\u67e5\u96c6$f\uff0cg$\uff0c $f$\u6bcf\u4e2a\u70b9\u7ef4\u62a4\u4e00\u4e2a$vector$<$pair$<$t, add$>>\u8868\u793a\u5728$t$\u65f6\u95f4\u5185\u52a0\u4e86$add$\u7684\u4e09\u64cd\u4f5c\u6807\u8bb0\uff0c\u8fd9\u91cc\u662f\u524d\u7f00\u548c\u7684\u5f62\u5f0f\uff0c\u65b9\u4fbf\u540e\u9762\u4e8c\u5206\u67e5\u627e\u65f6\u95f4$t$\u4ee5\u540e\u7684$add$\u503c\u4e4b\u548c\n\n* \u4e00\u4e8c\u64cd\u4f5c\uff1a\u9664\u4e86\u6b63\u5e38\u5408\u5e76\u8fd8\u8981\u7ef4\u62a4\u5408\u5e76\u7684\u65f6\u95f4\n* \u4e09\u64cd\u4f5c\uff1a\u76f4\u63a5\u628a\u6811\u6839$push\\_back$(\u65f6\u95f4\uff0c $siz + sum$)\n* \u56db\u64cd\u4f5c\uff1a\u76f4\u63a5\u628a\u6811\u6839\u6e05\u9664\u65f6\u95f4\u66f4\u6539\u4e3a$t$\n\n**\u8f83\u4e3a\u56f0\u96be\u7684\u4e94\u64cd\u4f5c**\n\n\u4e4b\u524d\u7ef4\u62a4\u7684\u90a3\u4e48\u591a\u90fd\u662f\u4e3a\u4e94\u64cd\u4f5c\u670d\u52a1\u7684\uff08\u5e9f\u8bdd\n\n\u6811\u9ad8\u662f$log$\u7684\uff0c \u6240\u4ee5\u53ef\u4ee5\u4ece\u4e00\u4e2a\u70b9\u66b4\u529b\u5411\u4e0a\u8df3\uff0c\u5148\u53bb\u8df3$g$\uff0c\u627e\u51fax\u70b9\u6700\u8fd1\u4e00\u6b21\u6e05\u96f6\u7684\u65f6\u523bt\uff0c\u6ce8\u610f\u4e00\u4e2a\u7ec6\u8282\uff1a\u5982\u679c$x$\u7684\u7236\u4eb2\u548c$x$\u76f8\u8fde\u65f6\u523b\u6bd4\u6807\u8bb0\u7684\u65f6\u95f4\u5927\uff0c\u5219\u6807\u8bb0\u5bf9$x$\u662f\u65e0\u6548\u7684\uff0c \u8fd9\u70b9\u5bf9$add$\u6807\u8bb0\u540c\u7406\n\n\u7136\u540e\u8df3$f$\uff0c\u5728\u4ece$x$\u5230\u6839\u7684\u6bcf\u4e2a\u70b9\u4e0a\u4e8c\u5206\u67e5\u627e\u5927\u4e8e\u6e05\u96f6\u65f6\u95f4\u548c\u76f8\u8fde\u65f6\u95f4\u7684\u6807\u8bb0\u548c\uff0c \u6700\u540e\u52a0\u8d77\u6765\u5c31\u662f\u7b54\u6848\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\Theta(nlog^2n)$\uff0c\u4e8c\u5206\u5728\u968f\u673a\u60c5\u51b5\u4e0b\u8dd1\u4e0d\u6ee1\uff0c\u4e8b\u5b9e\u4e0a\u8dd1\u7684\u633a\u5feb\u7684\n\n```cpp\nconst int N = 500500;\nint gs[N], fs[N], n, m;\nint f[N], g[N], ft[N], gt[N];\nchar opt[5];\n\nint find(int *f, int x) { while (x ^ f[x]) x = f[x]; return x; }\ninline void merge(int *f, int *siz, int *t, int x, int y, int k) {\n\tx = find(f, x), y = find(f, y);\n\tif (siz[x] < siz[y]) swap(x, y);\n\tsiz[x] += siz[y], f[y] = x, t[y] = k;\n}\n\nint cls[N];\nvector<pair<int, ll> > add[N];\n#define MP make_pair\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1;i <= n; i++) fs[f[i] = g[i] = i] = gs[i] = 1, add[i].push_back(MP(-1, 0));\n\tfor (int i = 1;i <= m; i++) {\n\t\tscanf (\"%s\", opt); int x, y; read(x);\n\t\tswitch (opt[0]) {\n\t\t\tcase 'U' : read(y), merge(f, fs, ft, x, y, i); break;\n\t\t\tcase 'M' : read(y), merge(g, gs, gt, x, y, i); break;\n\t\t\tcase 'A' : { int k = find(f, x); add[k].push_back(MP(i, fs[k] + add[k].back().second)); break; }\n\t\t\tcase 'Z' : { int k = find(g, x); cls[k] = i; break; }\n\t\t\tcase 'Q' : {\n\t\t\t\tint fx = x, tag = cls[x];\n\t\t\t\twhile (g[fx] != fx) {\n\t\t\t\t\tif (cls[g[fx]] > gt[fx]) tag = max(tag, cls[g[fx]]);\n\t\t\t\t\tfx = g[fx];\n\t\t\t\t}\n\t\t\t\tfx = x;  int l = lower_bound(add[x].begin(), add[x].end(), MP(tag, 0ll)) - add[x].begin();\n\t\t\t\tll ans = add[x].back().second - add[x][l-1].second;\n\t\t\t\twhile (f[fx] != fx) {\n\t\t\t\t\tint tf = f[fx];\n\t\t\t\t\tl = lower_bound(add[tf].begin(), add[tf].end(), MP(max(tag, ft[fx]), 0ll)) - add[tf].begin();\n\t\t\t\t\tans += add[tf].back().second - add[tf][l-1].second; fx = f[fx];\n\t\t\t\t}\n\t\t\t\tprintf (\"%lld\\n\", ans);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1584889963,
        "uid": 122144,
        "name": "hs_black",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF571D \u3010Campus\u3011"
    },
    {
        "content": "#### \u9898\u610f\n\n\u7ef4\u62a4\u4e24\u4e2a\u5927\u5c0f\u4e3a $n$ \u7684\u68ee\u6797\uff0c\u521d\u59cb\u65f6\u6240\u6709\u8282\u70b9\u5355\u72ec\u4e3a\u4e00\u68f5\u6811\uff0c\u652f\u6301\u5408\u5e76\u4e24\u68f5\u6811\u3001\u7b2c\u4e00\u4e2a\u68ee\u6797\u5b50\u6811\u52a0\u3001\u7b2c\u4e8c\u4e2a\u68ee\u6797\u5b50\u6811\u8d4b $0$ \u548c\u67e5\u8be2\u4e00\u4e2a\u70b9\u7684\u503c\uff08\u4e24\u4e2a\u68ee\u6797\u4e2d\u7f16\u53f7\u76f8\u540c\u7684\u4e3a\u540c\u4e00\u4e2a\u70b9\uff09\uff0c\u5171 $m$ \u6b21\u64cd\u4f5c\u3002\n\n#### \u9650\u5236\n\n$1\\le n,m\\le 5\\cdot10^5$\u3002\n\n#### \u9898\u89e3\n\n\u5408\u5e76\u65f6\u65b0\u5efa\u4e00\u4e2a\u865a\u70b9\uff0c\u5148\u79bb\u7ebf\u628a\u68ee\u6797\u5efa\u51fa\u6765\uff0c\u95ee\u9898\u5c31\u8f6c\u5316\u4e3a\u4e86\u4e24\u4e2a\u68ee\u6797\u5206\u522b\u7684\u5b50\u6811\u52a0\u3001\u5b50\u6811\u8d4b\u503c\u3002\u800c\u5982\u679c\u6211\u4eec\u6c42\u51fa\u4e86\u6bcf\u6b21\u8be2\u95ee\u524d\u6700\u540e\u4e00\u6b21\u8d4b\u503c\u7684\u65f6\u95f4\uff0c\u8be2\u95ee\u7684\u7b54\u6848\u5c31\u53d8\u6210\u4e86\u533a\u95f4\u6c42\u548c\u3002\n\n\u4e8e\u662f\u5148\u540e\u5bf9\u4e24\u4e2a\u68ee\u6797\u8fdb\u884c DFS\uff0c\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\uff1a$O(n + m\\log m)$\u3002\n\n#### \u4ee3\u7801\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 500000;\nstruct Tree {\n    int n;\n    vector<int> parent, lc, rc, id;\n    vector<vector<int>> mod;\n    Tree(int n) {\n        parent.assign(2 * n - 1, -1);\n        lc.assign(2 * n - 1, -1);\n        rc.assign(2 * n - 1, -1);\n        id.resize(n);\n        iota(id.begin(), id.end(), 0);\n        mod.resize(2 * n - 1);\n    }\n};\nlong long fen[N + 1];\nvoid add(int x, int y) {\n    for (int i = x + 1; i <= N; i += i & -i)\n        fen[i] += y;\n}\nlong long sum(int x) {\n    long long res = 0;\n    for (int i = x; i > 0; i -= i & -i)\n        res += fen[i];\n    return res;\n}\nlong long sum(int l, int r) {return sum(r) - sum(l);}\nint getLeft(int x) {\n    int s = sum(x);\n    x = 0;\n    for (int i = 1 << 18; i > 0; i /= 2) {\n        if (x + i <= N && fen[x + i] < s) {\n            x += i;\n            s -= fen[x];\n        }\n    }\n    return x;\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n, m;\n    cin >> n >> m;\n    Tree t1(n), t2(n);\n    vector<vector<int>> query(n);\n    vector<int> lb(m), sz(2 * n - 1, 1);\n    vector<long long> ans(m, -1);\n    int c1 = 0, c2 = 0;\n    for (int i = 0; i < m; ++i) {\n        char op;\n        cin >> op;\n        if (op == 'U') {\n            int a, b;\n            cin >> a >> b;\n            --a;\n            --b;\n            int p = n + (c1++);\n            t1.parent[t1.id[a]] = t1.parent[t1.id[b]] = p;\n            t1.lc[p] = t1.id[a];\n            t1.rc[p] = t1.id[b];\n            t1.id[a] = p;\n            sz[p] = sz[t1.lc[p]] + sz[t1.rc[p]];\n        } else if (op == 'M') {\n            int a, b;\n            cin >> a >> b;\n            --a;\n            --b;\n            int p = n + (c2++);\n            t2.parent[t2.id[a]] = t2.parent[t2.id[b]] = p;\n            t2.lc[p] = t2.id[a];\n            t2.rc[p] = t2.id[b];\n            t2.id[a] = p;\n        } else if (op == 'A') {\n            int x;\n            cin >> x;\n            --x;\n            t1.mod[t1.id[x]].push_back(i);\n        } else if (op == 'Z') {\n            int x;\n            cin >> x;\n            --x;\n            t2.mod[t2.id[x]].push_back(i);\n        } else {\n            int x;\n            cin >> x;\n            --x;\n            query[x].push_back(i);\n        }\n    }\n    function<void(int)> dfs1 = [&](int u) {\n        for (int i : t2.mod[u])\n            add(i, 1);\n        if (u < n) {\n            for (int i : query[u])\n                lb[i] = getLeft(i);\n        } else {\n            dfs1(t2.lc[u]);\n            dfs1(t2.rc[u]);\n        }\n        for (int i : t2.mod[u])\n            add(i, -1);\n    };\n    function<void(int)> dfs2 = [&](int u) {\n        for (int i : t1.mod[u])\n            add(i, sz[u]);\n        if (u < n) {\n            for (int i : query[u])\n                ans[i] = sum(lb[i], i);\n        } else {\n            dfs2(t1.lc[u]);\n            dfs2(t1.rc[u]);\n        }\n        for (int i : t1.mod[u])\n            add(i, -sz[u]);\n    };\n    for (int i = 0; i < n + c2; ++i)\n        if (t2.parent[i] == -1)\n            dfs1(i);\n    for (int i = 0; i < n + c1; ++i)\n        if (t1.parent[i] == -1)\n            dfs2(i);\n    for (int i = 0; i < m; ++i)\n        if (ans[i] != -1)\n            cout << ans[i] << \"\\n\";\n    return 0;\n}\n```\n\n",
        "postTime": 1574911665,
        "uid": 149656,
        "name": "jiangly",
        "ccfLevel": 10,
        "title": "CF571D Campus \u9898\u89e3"
    },
    {
        "content": "\u5b89\u5229\u4e2a\u4eba blog\uff1ahttps://www.cnblogs.com/ET2006/\n\n[Codeforces \u9898\u76ee\u4f20\u9001\u95e8](https://codeforces.com/contest/571/problem/D) & [\u6d1b\u8c37\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/CF571D)\n\n\u770b\u5230\u96c6\u5408\u7684\u5408\u5e76\uff0c\u53ef\u4ee5\u672c\u80fd\u5730\u60f3\u5230\u5e76\u67e5\u96c6\u3002\n\n\u4e0d\u8fc7\u8fd9\u9898\u7684\u64cd\u4f5c\u4e0e\u4f20\u7edf\u610f\u4e49\u4e0a\u7684\u5e76\u67e5\u96c6\u4e0d\u592a\u4e00\u6837\uff0c\u4f20\u7edf\u610f\u4e49\u4e0a\u7684\u5e76\u67e5\u96c6\u4e00\u822c\u662f\u7528\u6765\u5224\u65ad\u8fde\u901a\u6027\u7684\uff0c\u800c\u6b64\u9898\u8fd8\u9700\u652f\u6301\u8d4b\u503c\u3001\u96c6\u5408\u5185\u6574\u4f53\u52a0\u7b49\u64cd\u4f5c\uff0c\u4f3c\u4e4e\u5c31\u6709\u4e9b\u96be\u5904\u7406\u3002\n\n\u6211\u4eec\u4e0d\u59a8\u8003\u8651\u6b64\u9898\u7684\u5f31\u5316\u7248\uff1a\u6ca1\u6709\u7b2c\u4e8c\u7c7b\u96c6\u5408\u7684\u7248\u672c\u3002\u4e5f\u5c31\u662f\u8981\u6c42\u652f\u6301\u5408\u5e76\u4e24\u4e2a\u96c6\u5408\uff0c\u96c6\u5408\u6574\u4f53\u52a0\u67d0\u4e2a\u6570 $x$\uff0c\u5355\u70b9\u67e5\u8be2\u4e09\u4e2a\u64cd\u4f5c\u3002\n\n\u5f88\u660e\u663e\u96c6\u5408\u6574\u4f53\u52a0\u67d0\u4e2a\u6570 $x$ \u5c31\u76f8\u5f53\u4e8e\u5728\u5e76\u67e5\u96c6\u6839\u8282\u70b9\u5904\u6253\u4e00\u4e2a $+x$ \u7684\u6807\u8bb0\uff0c\u67e5\u8be2\u5c31\u66b4\u529b\u8df3\u7236\u4eb2\u6c42\u51fa\u5f85\u8be2\u95ee\u70b9\u5230\u6839\u8282\u70b9\u8def\u5f84\u4e0a\u6240\u6709\u70b9\u7684\u6807\u8bb0\u4e4b\u548c\u3002\u4e0d\u8fc7\u7a0d\u5fae\u60f3\u60f3\u5c31\u77e5\u9053\u8fd9\u4e2a\u505a\u6cd5\u662f\u5047\u7684\uff0c\u56e0\u4e3a\u5982\u679c\u76f4\u63a5\u91c7\u7528\u6309\u79e9\u5408\u5e76\u4f1a\u5bfc\u81f4\u6807\u8bb0\u52a0\u7684\u70b9\u96c6\u51fa\u73b0\u95ee\u9898\uff0c\u4e3e\u4e2a\u4f8b\u5b50\uff0c\u6bd4\u65b9\u8bf4\u6211\u4eec\u8981\u5408\u5e76 $x,y$ \u4e24\u4e2a\u96c6\u5408\uff0c\u5176\u4e2d $x$ \u4e3a\u7236\u4eb2\uff0c\u6211\u4eec\u5047\u8bbe\u539f\u672c $x$ \u70b9\u4e0a\u6709\u4e00\u4e2a $+v$ \u7684\u6807\u8bb0\uff0c\u663e\u7136\u8fd9\u4e2a\u6807\u8bb0\u6240\u7ba1\u8f96\u7684\u70b9\u7684\u96c6\u5408\u662f\u539f\u672c $x$ \u6240\u5728\u7684\u8fde\u901a\u5757\uff0c\u4f46\u7ecf\u8fc7\u6211\u4eec\u8fd9\u4e48\u4e00\u5408\u5e76\uff0c\u6211\u4eec\u9ed8\u8ba4\u6bcf\u4e2a\u6807\u8bb0\u7ba1\u8f96\u7684\u70b9\u7684\u96c6\u5408\u662f\u5176\u5b50\u6811\uff0c\u8fd9\u4e5f\u5c31\u610f\u5473\u7740\u539f\u672c $y$ \u6240\u5728\u7684\u96c6\u5408\u4e5f\u88ab\u9519\u8bef\u5730\u6253\u4e0a\u4e86 $+v$ \u7684\u6807\u8bb0\uff0c\u8fd9\u6837\u663e\u7136\u4f1a\u51fa\u95ee\u9898\u3002\u6211\u4eec\u8003\u8651\u6362\u4e2a\u5408\u5e76\u7684\u601d\u8def\uff0c\u6bcf\u6b21\u5408\u5e76\u5efa\u7acb\u4e00\u4e2a\u865a\u70b9 $z$\uff0c\u5e76\u8ba9 $x,y$ \u7684\u7236\u4eb2\u90fd\u4e3a $z$\uff0c\u8fd9\u6837\u5c31\u80fd\u4fdd\u8bc1\u6bcf\u6b21\u6807\u8bb0\u7ba1\u8f96\u7684\u70b9\u96c6\u662f\u6b63\u786e\u7684\u4e86\u3002\u4f46\u8fd9\u6837\u8fd8\u4f1a\u5bfc\u81f4\u4e00\u4e2a\u95ee\u9898\uff0c\u90a3\u5c31\u662f\u6811\u7684\u6df1\u5ea6\u53ef\u80fd\u5f88\u5927\uff0c\u66b4\u529b\u6761\u7236\u4eb2\u4f1a TLE\u3002\u6545\u8003\u8651\u628a\u64cd\u4f5c\u79bb\u7ebf\u4e0b\u6765\uff0c\u5148\u5efa\u51fa\u6700\u540e\u7684\u68ee\u6797\u51fa\u6765\u5e76\u6c42\u51fa DFS \u5e8f\uff0c\u6bcf\u6b21\u4fee\u6539\u7528\u7ebf\u6bb5\u6811\u5728\u5f85\u4fee\u6539\u70b9\u7684\u5b50\u6811\u5185\u6574\u4f53\u52a0 $v$\uff0c\u67e5\u8be2\u5c31\u6267\u884c\u4e00\u6b21\u7ebf\u6bb5\u6811\u4e0a\u7684\u5355\u70b9\u67e5\u8be2\u5373\u53ef\uff0c\u5f88\u660e\u663e\u68ee\u6797\u91cc\u7684\u70b9\u6570\u6700\u591a\u4e3a $n+q$\uff0c\u6545\u603b\u590d\u6742\u5ea6 $(n+q)\\log(n+q)$\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651\u6709\u7b2c\u4e8c\u7c7b\u96c6\u5408\u7684\u7248\u672c\uff0c\u8fd9\u4e2a\u5b50\u6811\u6e05\u7a7a\u8c8c\u4f3c\u7ef4\u62a4\u8d77\u6765\u6709\u4e9b\u56f0\u96be\uff0c\u4e0d\u8fc7\u6211\u4eec\u8003\u8651\u6362\u4e2a\u601d\u8def\uff0c\u4f7f\u7528\u5dee\u5206\u7684\u601d\u60f3\uff0c\u8be2\u95ee\u67d0\u4e2a\u70b9 $x$ \u7684\u503c\u53ef\u4ee5\u8f6c\u5316\u4e3a\u6b64\u65f6 $x$ \u70b9\u7684\u6743\u503c\u51cf\u53bb\u4e0a\u4e00\u6b21 $x$ \u70b9\u88ab\u6e05\u7a7a\u524d $x$ \u70b9\u7684\u6743\u503c\u3002\u6545\u6211\u4eec\u53ea\u7528\u6c42\u51fa\u6bcf\u6b21\u8be2\u95ee\uff0c\u5e26\u8be2\u95ee\u70b9\u4e0a\u4e00\u6b21\u88ab\u6e05\u7a7a\u7684\u65f6\u95f4\u5373\u53ef\u3002\u90a3\u4e48\u8fd9\u4e2a\u4e1c\u897f\u600e\u4e48\u6c42\u5462\uff1f\u5176\u5b9e\u4e0e\u5f31\u5316\u7248\u7ef4\u62a4\u7684\u601d\u8def\u5927\u540c\u5c0f\u5f02\uff0c\u5148\u79bb\u7ebf\u5efa\u51fa\u7b2c\u4e8c\u7c7b\u96c6\u5408\u7684\u68ee\u6797\u51fa\u6765\uff0c\u6bcf\u6b21\u6e05\u7a7a\u4e00\u4e2a\u8282\u70b9 $x$ \u5c31\u76f8\u5f53\u4e8e\u5728 $x$ \u5b50\u6811\u5185\u6240\u6709\u70b9\u8d4b\u503c $t$\uff08\u5176\u4e2d $t$ \u4e3a\u6b64\u6b21\u64cd\u4f5c\u7684\u65f6\u95f4\uff09\uff0c\u8868\u793a\u8fd9\u4e9b\u70b9\u4e0a\u4e00\u6b21\u88ab\u6e05\u7a7a\u662f\u65f6\u95f4 $t$\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7528\u533a\u95f4\u8d4b\u503c\u3001\u5355\u70b9\u67e5\u8be2\u7684\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u5230\u8fd9\u91cc\u9898\u76ee\u57fa\u672c\u4e0a\u5df2\u7ecf\u505a\u5b8c\u4e86\uff0c\u4e0d\u59a8\u7406\u7406\u601d\u8def\u3002\u6211\u4eec\u5148\u5c06\u8be2\u95ee\u79bb\u7ebf\u4e0b\u6765\uff0c\u5efa\u51fa\u4e24\u7c7b\u96c6\u5408\u5e76\u67e5\u96c6\u6240\u5f62\u6210\u7684\u68ee\u6797\uff0c\u5e76\u5bf9\u4e24\u4e2a\u68ee\u6797\u5404\u8fdb\u884c\u4e00\u904d DFS \u6c42\u51fa\u6bcf\u4e2a\u70b9\u7684 DFS \u5e8f\uff0c\u7b2c\u4e8c\u6b21\u626b\u63cf\u5168\u90e8\u4e0e\u7b2c\u4e8c\u7c7b\u96c6\u5408\u6709\u5173\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u533a\u95f4\u6e05\u7a7a\u7684\u64cd\u4f5c\u5c31\u5728\u5b50\u6811\u5bf9\u5e94 DFS \u5e8f\u7684\u533a\u95f4\u5185\u6267\u884c\u533a\u95f4\u8d4b\u503c\u64cd\u4f5c\uff0c\u5982\u679c\u9047\u5230\u8be2\u95ee\u5c31\u8fdb\u884c\u4e00\u904d\u7ebf\u6bb5\u6811\u4e0a\u7684\u5355\u70b9\u67e5\u8be2\uff0c\u8bb0\u5f55\u4e0b\u5f85\u8be2\u95ee\u70b9\u4e0a\u4e00\u6b21\u88ab\u6e05\u7a7a\u7684\u65f6\u95f4\u3002\u7b2c\u4e09\u6b21\u626b\u63cf\u5168\u90e8\u4e0e\u7b2c\u4e00\u7c7b\u96c6\u5408\u6709\u5173\u7684\u64cd\u4f5c\uff0c\u5bf9\u4e8e\u533a\u95f4\u52a0\u7684\u64cd\u4f5c\u5c31\u5728\u5b50\u6811\u5bf9\u5e94 DFS \u5e8f\u7684\u533a\u95f4\u5185\u6267\u884c\u533a\u95f4\u52a0\u64cd\u4f5c\uff0c\u5982\u679c\u9047\u5230\u8be2\u95ee\u5c31\u8fdb\u884c\u4e00\u904d\u7ebf\u6bb5\u6811\u4e0a\u7684\u5355\u70b9\u67e5\u8be2\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u6c42\u51fa\u7b54\u6848\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $(n+q)\\log(n+q)$\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define fill0(a) memset(a,0,sizeof(a))\n#define fill1(a) memset(a,-1,sizeof(a))\n#define fillbig(a) memset(a,63,sizeof(a))\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\ntemplate<typename T1,typename T2> void chkmin(T1 &x,T2 y){if(x>y) x=y;}\ntemplate<typename T1,typename T2> void chkmax(T1 &x,T2 y){if(x<y) x=y;}\ntypedef pair<int,int> pii;\ntypedef long long ll;\nnamespace fastio{\n\t#define FILE_SIZE 1<<23\n\tchar rbuf[FILE_SIZE],*p1=rbuf,*p2=rbuf,wbuf[FILE_SIZE],*p3=wbuf;\n\tinline char getc(){return p1==p2&&(p2=(p1=rbuf)+fread(rbuf,1,FILE_SIZE,stdin),p1==p2)?-1:*p1++;}\n\tinline void putc(char x){(*p3++=x);}\n\ttemplate<typename T> void read(T &x){\n\t\tx=0;char c=getchar();T neg=0;\n\t\twhile(!isdigit(c)) neg|=!(c^'-'),c=getchar();\n\t\twhile(isdigit(c)) x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\t\tif(neg) x=(~x)+1;\n\t}\n\ttemplate<typename T> void recursive_print(T x){if(!x) return;recursive_print(x/10);putc(x%10^48);}\n\ttemplate<typename T> void print(T x){if(!x) putc('0');if(x<0) putc('-'),x=~x+1;recursive_print(x);}\n\tvoid print_final(){fwrite(wbuf,1,p3-wbuf,stdout);}\n}\nconst int MAXN=5e5;\nint n,qu;\nstruct solver{\n\tint bel[MAXN+5],siz[MAXN*2+5],tot;\n\tvoid init(){\n\t\tfor(int i=1;i<=n;i++) bel[i]=i,siz[i]=1;\n\t\ttot=n;\n\t}\n\tint hd[MAXN*2+5],nxt[MAXN*2+5],to[MAXN*2+5],ec=0;\n\tvoid adde(int u,int v){to[++ec]=v;nxt[ec]=hd[u];hd[u]=ec;}\n\tvoid merge(int x,int y){\n\t\ttot++;adde(tot,bel[x]);adde(tot,bel[y]);\n\t\tsiz[x]+=siz[y];siz[y]=0;bel[y]=0;bel[x]=tot;\n\t}\n\tint dfn[MAXN*2+5],sz[MAXN*2+5],tim=0;\n\tvoid dfs(int x){\n\t\tdfn[x]=++tim;sz[x]=1;\n\t\tfor(int e=hd[x];e;e=nxt[e]) dfs(to[e]),sz[x]+=sz[to[e]];\n\t}\n} s1,s2;\nstruct event{int opt,x,y;} q[MAXN+5];\nvector<int> clr[MAXN+5];\nll res[MAXN+5];\nstruct seg1{\n\tstruct node{int l,r;ll v,lz;} s[MAXN*8+5];\n\tvoid build(int k,int l,int r){\n\t\ts[k].l=l;s[k].r=r;if(l==r) return;\n\t\tint mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);\n\t}\n\tvoid pushdown(int k){\n\t\tif(s[k].lz){\n\t\t\ts[k<<1].v+=s[k].lz*(s[k<<1].r-s[k<<1].l+1);\n\t\t\ts[k<<1].lz+=s[k].lz;\n\t\t\ts[k<<1|1].v+=s[k].lz*(s[k<<1|1].r-s[k<<1|1].l+1);\n\t\t\ts[k<<1|1].lz+=s[k].lz;\n\t\t\ts[k].lz=0;\n\t\t}\n\t}\n\tvoid modify(int k,int l,int r,int x){\n\t\tif(l<=s[k].l&&s[k].r<=r){\n\t\t\ts[k].v+=1ll*x*(s[k].r-s[k].l+1);s[k].lz+=x;\n\t\t\treturn;\n\t\t} pushdown(k);int mid=s[k].l+s[k].r>>1;\n\t\tif(r<=mid) modify(k<<1,l,r,x);\n\t\telse if(l>mid) modify(k<<1|1,l,r,x);\n\t\telse modify(k<<1,l,mid,x),modify(k<<1|1,mid+1,r,x);\n\t\ts[k].v=s[k<<1].v+s[k<<1|1].v;\n\t}\n\tll query(int k,int x){\n\t\tif(s[k].l==s[k].r) return s[k].v;\n\t\tpushdown(k);int mid=s[k].l+s[k].r>>1;\n\t\tif(x<=mid) return query(k<<1,x);\n\t\telse return query(k<<1|1,x);\n\t}\n} st1;\nstruct seg2{\n\tstruct node{int l,r,tag;} s[MAXN*8+5];\n\tvoid build(int k,int l,int r){\n\t\ts[k].l=l;s[k].r=r;if(l==r) return;\n\t\tint mid=l+r>>1;build(k<<1,l,mid);build(k<<1|1,mid+1,r);\n\t}\n\tvoid pushdown(int k){\n\t\tif(s[k].tag){\n\t\t\ts[k<<1].tag=s[k].tag;s[k<<1|1].tag=s[k].tag;\n\t\t\ts[k].tag=0;\n\t\t}\n\t}\n\tvoid modify(int k,int l,int r,int x){\n\t\tif(l<=s[k].l&&s[k].r<=r){s[k].tag=x;return;}\n\t\tpushdown(k);int mid=s[k].l+s[k].r>>1;\n\t\tif(r<=mid) modify(k<<1,l,r,x);\n\t\telse if(l>mid) modify(k<<1|1,l,r,x);\n\t\telse modify(k<<1,l,mid,x),modify(k<<1|1,mid+1,r,x);\n\t}\n\tint query(int k,int x){\n\t\tif(s[k].l==s[k].r) return s[k].tag;\n\t\tpushdown(k);int mid=s[k].l+s[k].r>>1;\n\t\tif(x<=mid) return query(k<<1,x);\n\t\telse return query(k<<1|1,x);\n\t}\n} st2;\nint main(){\n\tscanf(\"%d%d\",&n,&qu);s1.init();s2.init();\n\tfor(int i=1;i<=qu;i++){\n\t\tchar opt[5];scanf(\"%s\",opt+1);\n\t\tif(opt[1]=='U'){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);s1.merge(x,y);\n\t\t\tq[i].opt=1;q[i].x=x;q[i].y=y;\n\t\t} else if(opt[1]=='M'){\n\t\t\tint x,y;scanf(\"%d%d\",&x,&y);s2.merge(x,y);\n\t\t\tq[i].opt=2;q[i].x=x;q[i].y=y;\n\t\t} else if(opt[1]=='A'){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tq[i].opt=3;q[i].x=s1.bel[x];q[i].y=s1.siz[x];\n\t\t} else if(opt[1]=='Z'){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tq[i].opt=4;q[i].x=s2.bel[x];\n\t\t} else{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tq[i].opt=5;q[i].x=x;\n\t\t}\n\t}\n\ts1.tot++;for(int i=1;i<=n;i++) if(s1.siz[i]) s1.adde(s1.tot,s1.bel[i]);\n\ts2.tot++;for(int i=1;i<=n;i++) if(s2.siz[i]) s2.adde(s2.tot,s2.bel[i]);\n\ts1.dfs(s1.tot);s2.dfs(s2.tot);\n\tst1.build(1,1,s1.tot);st2.build(1,1,s2.tot);\n\tfor(int i=1;i<=qu;i++){\n\t\tif(q[i].opt==4) st2.modify(1,s2.dfn[q[i].x],s2.dfn[q[i].x]+s2.sz[q[i].x]-1,i);\n\t\tif(q[i].opt==5){\n\t\t\tint tmp=st2.query(1,s2.dfn[q[i].x]);\n\t\t\tif(tmp) clr[tmp].pb(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=qu;i++){\n\t\tif(q[i].opt==3) st1.modify(1,s1.dfn[q[i].x],s1.dfn[q[i].x]+s1.sz[q[i].x]-1,q[i].y);\n\t\tif(q[i].opt==4){\n\t\t\tfor(int j=0;j<clr[i].size();j++){\n\t\t\t\tint id=clr[i][j];\n\t\t\t\tres[id]-=st1.query(1,s1.dfn[q[id].x]);\n\t\t\t}\n\t\t}\n\t\tif(q[i].opt==5){\n\t\t\tres[i]+=st1.query(1,s1.dfn[q[i].x]);\n\t\t\tprintf(\"%lld\\n\",res[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1614403615,
        "uid": 115194,
        "name": "lTgMFePRoeZ",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF571D\u3010Campus\u3011"
    },
    {
        "content": "> [CF571D Campus](https://codeforces.com/contest/571/problem/D)\n\n## \u9898\u610f\n\n- \u6709\u4e00\u4e2a\u957f\u5ea6\u4e3a $n$ \u7684\u5e8f\u5217\uff0c\u521d\u59cb\u5168\u4e3a $0$\u3002\n- \u6709\u4e24\u7c7b\u5bf9\u4e0b\u6807\u7684\u96c6\u5408\uff0c\u521d\u59cb\u65f6\u6bcf\u4e00\u7c7b\u5404\u6709 $n$ \u4e2a\u96c6\u5408\uff0c\u7f16\u53f7\u4e3a $i$ \u7684\u96c6\u5408\u91cc\u6709\u4e0b\u6807 $i$\u3002\n- \u4e00\u5171\u6709 $m$ \u4e2a\u64cd\u4f5c\uff0c\u64cd\u4f5c\u6709\u4e94\u79cd\uff1a\n  1. `U x y` \u5c06\u7b2c\u4e00\u7c7b\u7f16\u53f7\u4e3a $y$ \u7684\u96c6\u5408\u5408\u5e76\u5230\u7f16\u53f7\u4e3a $x$ \u7684\u96c6\u5408\u91cc\u3002\n  2. `M x y` \u5c06\u7b2c\u4e8c\u7c7b\u7f16\u53f7\u4e3a $y$ \u7684\u96c6\u5408\u5408\u5e76\u5230\u7f16\u53f7\u4e3a $x$ \u7684\u96c6\u5408\u91cc\u3002\n  3. `A x` \u5c06\u7b2c\u4e00\u7c7b\u7f16\u53f7\u4e3a $x$ \u7684\u96c6\u5408\u4e2d\u7684\u6240\u6709\u4e0b\u6807\u5728\u5e8f\u5217\u4e2d\u5bf9\u5e94\u7684\u6570\u52a0\u4e0a $x$ \u7684\u96c6\u5408\u5927\u5c0f\u3002\n  4. `Z x` \u5c06\u7b2c\u4e8c\u7c7b\u7f16\u53f7\u4e3a $x$ \u7684\u96c6\u5408\u4e2d\u7684\u6240\u6709\u4e0b\u6807\u5728\u5e8f\u5217\u4e2d\u5bf9\u5e94\u7684\u6570\u8bbe\u4e3a $0$\u3002\n  5. `Q x` \u8be2\u95ee\u5e8f\u5217\u4e2d\u4e0b\u6807\u4e3a $x$ \u7684\u4f4d\u7f6e\u4e0a\u7684\u6570\u3002\n- $n,m \\le 5 \\times 10^5$\u3002\n\n## \u9898\u89e3\n\n\u5982\u679c\u6211\u4eec\u80fd\u591f\u5229\u7528 `M` \u548c `Z` \u64cd\u4f5c\u6c42\u51fa\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u7684\u4f4d\u7f6e\u4e0a\u6b21\u6e05\u96f6\u7684\u65f6\u523b $t$\uff0c\u90a3\u4e48\u8fd9\u4e2a\u8be2\u95ee\u7684\u7b54\u6848\u5c31\u5e94\u8be5\u662f\u53ea\u4fdd\u7559 `U` \u548c `A` \u64cd\u4f5c\u7684\u60c5\u51b5\u4e0b\u6b64\u65f6\u7684\u503c\u51cf\u53bb $t$ \u65f6\u523b\u7684\u503c\u3002\n\n\u90a3\u4e48\u6211\u4eec\u8981\u89e3\u51b3\u7684\u95ee\u9898\u53ef\u4ee5\u5206\u4e3a\u4e24\u6b65\uff1a\n\n1. \u5229\u7528 `M` \u548c `Z` \u64cd\u4f5c\u6c42\u51fa\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u7684\u4f4d\u7f6e\u4e0a\u6b21\u6e05\u96f6\u7684\u65f6\u523b $t$\u3002\n2. \u5229\u7528 `U` \u548c `A` \u64cd\u4f5c\u6c42\u51fa\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u7684\u4f4d\u7f6e\u5f53\u524d\u548c\u65f6\u523b $t$ \u7684\u503c\u3002\n\n\u5c06\u8be2\u95ee\u79bb\u7ebf\u540e\uff0c\u5efa\u7acb kruskal \u91cd\u6784\u6811\uff0c\u90a3\u4e48\u8fd9\u4e24\u6b65\u5c31\u5206\u522b\u76f8\u5f53\u4e8e\u5728 dfs \u5e8f\u4e0a\u8fdb\u884c\u533a\u95f4\u8d4b\u503c\u548c\u533a\u95f4\u52a0\uff0c\u8be2\u95ee\u5219\u76f8\u5f53\u4e8e\u5355\u70b9\u67e5\u8be2\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\n\n\u8bbe $n,m$ \u540c\u9636\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\mathcal O(n \\log n)$\u3002\n\n## \u4ee3\u7801\n\n```cpp\nconst int N = 5e5 + 7;\nint n, m, a[N];\nchar s[N], c[3];\nvector<pi> q[N];\nll ans[N];\n\nstruct kruskal0 {\n\tint f[N*2], l[N*2], r[N*2], num, tot;\n\tvi e[N*2];\n\tstruct T {\n\t\tint l, r, s;\n\t} t[N*8];\n\tinline void init() {\n\t\tfor (int i = 1; i <= n; i++) f[i] = i;\n\t\ttot = n;\n\t}\n\tint get(int x) {\n\t\treturn x == f[x] ? x : (f[x] = get(f[x]));\n\t}\n\tinline int add(int x, int y) {\n\t\te[++tot].pb(x = get(x)), e[tot].pb(y = get(y));\n\t\treturn f[x] = f[y] = f[tot] = tot;\n\t}\n\tvoid dfs(int x) {\n\t\tl[x] = ++num;\n\t\tfor (auto y : e[x]) dfs(y);\n\t\tr[x] = num;\n\t}\n\tvoid build(int p, int l, int r) {\n\t\tt[p].l = l, t[p].r = r;\n\t\tif (l == r) return;\n\t\tbuild(ls, l, md), build(rs, md + 1, r);\n\t}\n\tinline void prework() {\n\t\tfor (int i = 1; i <= tot; i++) if (get(i) == i) dfs(i);\n\t\tbuild(1, 1, tot);\n\t}\n\tinline void spd(int p) {\n\t\tif (t[p].s) t[ls].s = t[rs].s = t[p].s, t[p].s = 0;\n\t}\n\tvoid set(int p, int l, int r, int x) {\n\t\tif (t[p].l >= l && t[p].r <= r) return t[p].s = x, void();\n\t\tspd(p);\n\t\tif (l <= md) set(ls, l, r, x);\n\t\tif (r > md) set(rs, l, r, x);\n\t}\n\tinline void set(int i) {\n\t\tset(1, l[a[i]], r[a[i]], i);\n\t}\n\tint asks(int p, int x) {\n\t\tif (t[p].l == t[p].r) return t[p].s;\n\t\tspd(p);\n\t\treturn asks(x <= md ? ls : rs, x);\n\t}\n\tinline int asks(int i) {\n\t\treturn asks(1, l[a[i]]);\n\t}\n} t0;\n\nstruct kruskal1 {\n\tint f[N*2], s[N*2], l[N*2], r[N*2], num, tot;\n\tvi e[N*2];\n\tstruct T {\n\t\tint l, r;\n\t\tll a;\n\t} t[N*8];\n\tinline void init() {\n\t\tfor (int i = 1; i <= n; i++) f[i] = i;\n\t\ttot = n;\n\t}\n\tint get(int x) {\n\t\treturn x == f[x] ? x : (f[x] = get(f[x]));\n\t}\n\tinline int add(int x, int y) {\n\t\te[++tot].pb(x = get(x)), e[tot].pb(y = get(y));\n\t\treturn f[x] = f[y] = f[tot] = tot;\n\t}\n\tvoid dfs(int x) {\n\t\tl[x] = ++num, s[x] = x <= n;\n\t\tfor (auto y : e[x]) dfs(y), s[x] += s[y];\n\t\tr[x] = num;\n\t}\n\tvoid build(int p, int l, int r) {\n\t\tt[p].l = l, t[p].r = r;\n\t\tif (l == r) return;\n\t\tbuild(ls, l, md), build(rs, md + 1, r);\n\t}\n\tinline void prework() {\n\t\tfor (int i = 1; i <= tot; i++) if (get(i) == i) dfs(i);\n\t\tbuild(1, 1, tot);\n\t}\n\tinline void spd(int p) {\n\t\tif (t[p].a) t[ls].a += t[p].a, t[rs].a += t[p].a, t[p].a = 0;\n\t}\n\tvoid add(int p, int l, int r, int x) {\n\t\tif (t[p].l >= l && t[p].r <= r) return t[p].a += x, void();\n\t\tspd(p);\n\t\tif (l <= md) add(ls, l, r, x);\n\t\tif (r > md) add(rs, l, r, x);\n\t}\n\tinline void add(int x) {\n\t\tadd(1, l[x], r[x], s[x]);\n\t}\n\tll aska(int p, int x) {\n\t\tif (t[p].l == t[p].r) return t[p].a;\n\t\tspd(p);\n\t\treturn aska(x <= md ? ls : rs, x);\n\t}\n\tinline ll aska(int x) {\n\t\treturn aska(1, l[x]);\n\t}\n} t1;\n\nint main() {\n\trd(n), rd(m), t1.init(), t0.init();\n\tfor (int i = 1, x; i <= m; i++) {\n\t\trds(c, x), s[i] = c[1], rd(a[i]);\n\t\tswitch (s[i]) {\n\t\t\tcase 'U' : rd(x), a[i] = t1.add(a[i], x); break;\n\t\t\tcase 'M' : rd(x), a[i] = t0.add(a[i], x); break;\n\t\t\tcase 'A' : a[i] = t1.get(a[i]); break;\n\t\t\tcase 'Z' : a[i] = t0.get(a[i]); break;\n\t\t}\n\t}\n\tt1.prework(), t0.prework();\n\tfor (int i = 1; i <= m; i++)\n\t\tswitch (s[i]) {\n\t\t\tcase 'Z' : t0.set(i); break;\n\t\t\tcase 'Q' : q[t0.asks(i)].pb(mp(a[i], i)); break;\n\t\t}\n\tfor (int i = 1; i <= m; i++)\n\t\tswitch (s[i]) {\n\t\t\tcase 'A' : t1.add(a[i]); break;\n\t\t\tcase 'Z' : for (pi o : q[i]) ans[o.se] -= t1.aska(o.fi); break;\n\t\t\tcase 'Q' : ans[i] += t1.aska(a[i]); break;\n\t\t}\n\tfor (int i = 1; i <= m; i++) if (s[i] == 'Q') print(ans[i]);\n\treturn 0;\n}\n```",
        "postTime": 1580894026,
        "uid": 100544,
        "name": "xht",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF571D \u3010Campus\u3011"
    },
    {
        "content": "\u5047\u5982\u6ca1\u6709\u7b2c\u4e8c\u4e2a\u548c\u7b2c\u56db\u4e2a\u64cd\u4f5c\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u79bb\u7ebf\u5c06\u6700\u540e\u7684\u5408\u5e76\u6811\u6c42\u51fa\uff0c\u628a\u64cd\u4f5c\u770b\u6210\u5728\u5bf9\u5e94\u7684\u6811\u4e0a\u7684dfn\u5e8f\u8fdb\u884c\u52a0\u64cd\u4f5c\u76f4\u63a5\u4f7f\u7528\u7ebf\u6bb5\u6811\u3002\n\n\u52a0\u4e0a\u4e8c\u548c\u56db\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u53ef\u4ee5\u4e0d\u628a\u5b83\u5f53\u6210\u6e05\u96f6\u64cd\u4f5c\uff0c\u800c\u662f\u8ba9\u8fd9\u4e9b\u8282\u70b9\u4ee5\u540e\u7684\u7b54\u6848\u90fd\u51cf\u53bb\u5f53\u524d\u8282\u70b9\u7684\u7b54\u6848\u3002\u56e0\u4e3a\u53ea\u6709\u5355\u70b9\u67e5\u8be2\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u5c06\u524d\u9762\u7684\u7ebf\u6bb5\u6811\u6539\u6210\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\uff0c\u5e76\u7528\u65b0\u7684\u4e00\u68f5\u7ebf\u6bb5\u6811\u6765\u8bb0\u5f55\u8fd9\u4e9b\u8282\u70b9\u9700\u8981\u51cf\u53bb\u7684\u65f6\u95f4\uff0c\u67e5\u8be2\u65f6\u76f4\u63a5\u67e5\u8be2\u51fa\u9700\u8981\u51cf\u53bb\u7684\u65f6\u95f4\uff0c\u7528\u5f53\u524d\u7b54\u6848\u51cf\u53bb\u67e5\u8be2\u5f97\u5230\u7684\u65f6\u95f4\u6240\u5bf9\u5e94\u7684\u7b54\u6848\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(nlogn)$ \u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst long long N = 5e5 + 10;\nlong long n, m;\nstruct bian\n{\n\tlong long from, to;\n};\nstruct tree\n{\n\tbian eg[N << 2];\n\tlong long num, front[N << 1];\n\tlong long zong;\n\tlong long fa[N << 1], siz[N << 1];\n\tvoid add(long long x, long long y)\n\t{\n\t\teg[++ num].to = y;\n\t\teg[num].from = front[x];\n\t\tfront[x] = num;\n\t}\n\tvoid init()\n\t{\n\t\tzong = n;\n\t\tfor (long long i = 1; i <= zong; ++ i)\n\t\tfa[i] = i, siz[i] = 1;\n\t}\n\tlong long find(long long x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\tlong long tot, now;\n\tlong long son[N << 4][2];\n\tunsigned long long tag[N << 4];\n\tlong long root[N];\n\tvoid merge(long long x, long long y)\n\t{\n\t\tlong long d1 = find(x), d2 = find(y);\n\t\tfa[++ zong] = zong;\n\t\tadd(zong, d1);\n\t\tadd(zong, d2);\n\t\tsiz[zong] = siz[find(x)] + siz[find(y)];\n\t\tfa[d1] = zong;\n\t\tfa[d2] = zong;\n\t}\n\tlong long ll[N << 1], rr[N << 1], ids[N], p;\n\tvoid dfs(long long o)\n\t{\n\t\tif(o <= n)\n\t\t{\n\t\t\tids[o] = ++ p;\n\t\t\tll[o] = rr[o] = ids[o];\n\t\t\treturn;\n\t\t}\n\t\tll[o] = 1e9;\n\t\tfor (long long i = front[o]; i; i = eg[i].from)\n\t\t{\n\t\t\tlong long to = eg[i].to;\n\t\t\tdfs(to);\n\t\t\tll[o] = min(ll[o], ll[to]);\n\t\t\trr[o] = max(rr[o], rr[to]);\n\t\t}\n\t}\n\tvoid opt1(long long be, long long &o, long long l, long long r, long long L, long long R, long long w)\n\t{\n\t\tif(o == 0)o = ++ tot;\n\t\ttag[o] = tag[be]; \n\t\tif(L <= l && r <= R)\n\t\t{\n\t\t\ttag[o] += w;\n\t\t\tson[o][0] = son[be][0];\n\t\t\tson[o][1] = son[be][1];\n\t\t\treturn;\n\t\t}\n\t\tlong long mid = (l + r) >> 1;\n\t\tif(mid >= L)opt1(son[be][0], son[o][0], l, mid, L, R, w);else son[o][0] = son[be][0];\n\t\tif(mid < R)opt1(son[be][1], son[o][1], mid + 1, r, L, R, w);else son[o][1] = son[be][1];\n\t}\n\tunsigned long long opt2(long long o, long long l, long long r, long long i, unsigned long long now)\n\t{\n\t\tif(o == 0)return now;\n\t\tif(l == r)\n\t\t\treturn now + tag[o];\n\t\tlong long mid = (l + r) >> 1;\n\t\tif(mid >= i)return opt2(son[o][0], l, mid, i, now + tag[o]);\n\t\telse return opt2(son[o][1], mid + 1, r, i, now + tag[o]);\n\t}\n}T1;\nstruct tree_\n{\n\tbian eg[N << 2];\n\tlong long num, front[N << 1];\n\tlong long zong;\n\tlong long fa[N << 1];\n\tvoid add(long long x, long long y)\n\t{\n\t\teg[++ num].to = y;\n\t\teg[num].from = front[x];\n\t\tfront[x] = num;\n\t}\n\tvoid init()\n\t{\n\t\tzong = n;\n\t\tfor (long long i = 1; i <= zong; ++ i)\n\t\tfa[i] = i;\n\t}\n\tlong long find(long long x)\n\t{\n\t\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n\t}\n\tvoid merge(long long x, long long y)\n\t{\n\t\tlong long d1 = find(x), d2 = find(y);\n\t\tfa[++ zong] = zong;\n\t\tadd(zong, d1);\n\t\tadd(zong, d2);\n\t\tfa[d1] = zong;\n\t\tfa[d2] = zong;\n\t}\n\tlong long ll[N << 1], rr[N << 1], ids[N], p;\n\tvoid dfs(long long o)\n\t{\n\t\tif(o <= n)\n\t\t{\n\t\t\tids[o] = ++ p;\n\t\t\tll[o] = rr[o] = ids[o];\n\t\t\treturn;\n\t\t}\n\t\tll[o] = 1e9;\n\t\tfor (long long i = front[o]; i; i = eg[i].from)\n\t\t{\n\t\t\tlong long to = eg[i].to;\n\t\t\tdfs(to);\n\t\t\tll[o] = min(ll[o], ll[to]);\n\t\t\trr[o] = max(rr[o], rr[to]);\n\t\t}\n\t}\n\tlong long col[N << 2];\n\tvoid opt3(long long o, long long l, long long r, long long L, long long R, long long w)\n\t{\n\t\tif(L <= l && r <= R)\n\t\t{\n\t\t\tcol[o] = w;\n\t\t\treturn;\n\t\t}\n\t\tlong long mid = (l + r) >> 1;\n\t\tif(col[o])\n\t\t{\n\t\t\tcol[o << 1] = col[o << 1 | 1] = col[o];\n\t\t\tcol[o] = 0;\n\t\t}\n\t\tif(mid >= L) opt3(o << 1, l, mid, L, R, w);\n\t\tif(mid < R) opt3(o << 1 | 1, mid + 1, r, L, R, w);\n\t}\n\tlong long opt4(long long o, long long l, long long r, long long i)\n\t{\n\t\tif(l == r)\n\t\treturn col[o];\n\t\tlong long mid = (l + r) >> 1;\n\t\tif(col[o])\n\t\t{\n\t\t\tcol[o << 1] = col[o << 1 | 1] = col[o];\n\t\t\tcol[o] = 0;\n\t\t}\n\t\tif(mid >= i)return opt4(o << 1, l, mid, i);\n\t\telse return opt4(o << 1 | 1, mid + 1, r, i);\n\t}\n\t\n}T2;\nlong long que[N][3];\nstruct b\n{\n\tlong long fa[N << 1], zong;\n\tvoid init()\n\t{\n\t\tzong = n;\n\t\tfor (long long i = 1; i <= n; ++ i)\n\t\tfa[i] = i;\n\t}\n\tlong long find(long long o)\n\t{\n\t\treturn fa[o] == o ? o : fa[o] = find(fa[o]);\n\t}\n\tvoid merge(long long x, long long y)\n\t{\n\t\tlong long d1 = find(x), d2 = find(y);\n\t\tfa[++ zong] = zong;\n\t\tfa[d1] = zong;\n\t\tfa[d2] = zong;\n\t}\n}B1, B2;\nlong long main()\n{\n\tscanf(\"%d%d\", &n, &m);\n\tT1.init();\n\tT2.init();\n\tfor (long long i = 1; i <= m; ++ i)\n\t{\n\t\tchar s[10];\n\t\tscanf(\"%s\", s);\n\t\tif(s[0] == 'U')\n\t\t{\n\t\t\tlong long x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tque[i][0] = 1;\n\t\t\tque[i][1] = x;\n\t\t\tque[i][2] = y;\n\t\t\tT1.merge(x, y);\n\t\t}\n\t\tif(s[0] == 'M')\n\t\t{\n\t\t\tlong long x, y;\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tque[i][0] = 2;\n\t\t\tque[i][1] = x;\n\t\t\tque[i][2] = y;\n\t\t\tT2.merge(x, y);\n\t\t}\n\t\tif(s[0] == 'A')\n\t\t{\n\t\t\tlong long x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tque[i][0] = 3;\n\t\t\tque[i][1] = x;\n\t\t}\n\t\tif(s[0] == 'Z')\n\t\t{\n\t\t\tlong long x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tque[i][0] = 4;\n\t\t\tque[i][1] = x;\n\t\t}\n\t\tif(s[0] == 'Q')\n\t\t{\n\t\t\tlong long x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tque[i][0] = 5;\n\t\t\tque[i][1] = x;\n\t\t}\n\t}\n\tfor (long long i = 1; i <= T1.zong; ++ i)\n\tif(T1.find(i) == i)\n\tT1.dfs(i);\n\tfor (long long i = 1; i <= T2.zong; ++ i)\n\tif(T2.find(i) == i)\n\tT2.dfs(i);\n\tB1.init();\n\tB2.init();\n\tfor (long long i = 1; i <= m; ++ i)\n\t{\n\t\tif(que[i][0] == 1)\n\t\t{\n\t\t\tB1.merge(que[i][1], que[i][2]);\n\t\t}\n\t\tif(que[i][0] == 2)\n\t\t{\n\t\t\tB2.merge(que[i][1], que[i][2]);\n\t\t}\n\t\tif(que[i][0] == 3)\n\t\t{\n\t\t\t++ T1.now;\n\t\t\tT1.opt1(T1.root[T1.now - 1], T1.root[T1.now], 1, n, T1.ll[B1.find(que[i][1])], T1.rr[B1.find(que[i][1])], T1.siz[B1.find(que[i][1])]);\n\t\t}\n\t\tif(que[i][0] == 4)\n\t\t{\n//\t\t\tprintf(\"%d %d %d %d\\n\", B2.find(que[i][1]), T2.ll[B2.find(que[i][1])], T2.rr[B2.find(que[i][1])], T1.now);\n\t\t\tT2.opt3(1, 1, n, T2.ll[B2.find(que[i][1])], T2.rr[B2.find(que[i][1])], T1.now);\n\t\t}\n\t\tif(que[i][0] == 5)\n\t\t{\n//\t\t\tprintf(\"%d\\n\", T1.ids[que[i][1]]);\n\t\t\tprintf(\"%lld\\n\", T1.opt2(T1.root[T1.now], 1, n, T1.ids[que[i][1]], 0) - T1.opt2(T1.root[T2.opt4(1, 1, n, T2.ids[que[i][1]])], 1, n, T1.ids[que[i][1]], 0));\n\t\t}\n\t}\n}\n```\n",
        "postTime": 1615263310,
        "uid": 111728,
        "name": "\u5e7b\u5f71\u661f\u575a\u5f3a",
        "ccfLevel": 7,
        "title": "CF571D"
    },
    {
        "content": "~~\u51ac\u4ee4\u8425\uff0c\u6ca1\u542c\u61c2\uff0c\u6c34\u9898\u89e3~~\n\n\u8fd9\u4e2a\u4e2d\u6587\u7ffb\u8bd1\u5341\u5206\u7cbe\u5999\uff0c\u4f7f\u7528\u7684\u662f**\u96c6\u5408**\u7684**\u5408\u5e76**\u8fd9\u79cd\u8868\u8fbe\u3002\n\n\u96c6\u5408\u7684\u5408\u5e76\u8981\u7528\u4ec0\u4e48\uff1f**~~\u51b0\u8336\u59ec~~\u5e76\u67e5\u96c6**\u3002\n\n\u6211\u4eec\u5c1d\u8bd5\u5207\u6362\u5230\u51b0\u8336\u59ec\u7684\u89c6\u89d2\u770b\u4e00\u4e0b\u5404\u4e2a\u64cd\u4f5c\u7684\u5177\u4f53\u6548\u679c\uff1a\n\n```U x y```\uff1a\u5728\u96c6\u5408$A$\u4e2d\u5c06$y$\u5e76\u5165$x$\uff1b\n\n```M x y```\uff1a\u5728\u96c6\u5408$B$\u4e2d\u5c06$y$\u5e76\u5165$x$\uff1b\n\n```A x```\uff1a\u5728\u96c6\u5408$A$\u4e2d\u8fdb\u884c**\u5b50\u6811\u52a0**\uff1b\n\n```Z x```\uff1a\u5728\u96c6\u5408$B$\u4e2d\u8fdb\u884c**\u5b50\u6811\u6e05\u7a7a**\uff1b\n\n```Q x```\uff1a\u8be2\u95ee\u3002\n\n```A```\u64cd\u4f5c\uff0c\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u6253\u5b50\u6811\u52a0\u7684tag\uff1b```Z```\u64cd\u4f5c\uff0c\u53ef\u4ee5\u88ab\u770b\u4f5c\u662f\u6253\u5b50\u6811\u6e05\u7a7a\u7684tag\u3002\n\n\u8003\u8651**\u626b\u63cf\u7ebf/\u4e8c\u7ef4\u6570\u70b9**\u7b49\u7b49\u4e1c\u897f\u7684\u601d\u60f3\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u518d\u771f\u5b9e\u5730\u6267\u884c\u6e05\u7a7a\u5b50\u6811\u7684\u64cd\u4f5c\uff0c\u8f6c\u800c\u5c06\u7b54\u6848\u770b\u4f5c\u662f\uff1a\u5f53\u524d\u8fd9\u4e2a\u8282\u70b9\u7684\u503c\uff0c\u51cf\u53bb\u5b83\u4e0a\u4e00\u6b21\u88ab\u6e05\u7a7a\u65f6\u8fd9\u4e2a\u8282\u70b9\u7684\u503c\u3002\n\n\u5177\u4f53\u7684\u505a\u6cd5\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u64cd\u4f5c\u79bb\u6563\u4e0b\u6765\uff0c\u7b2c\u4e00\u904d\u5efa\u51fa\u5408\u5e76\u7684\u6811\u51fa\u6765\uff08\u51b0\u8336\u59ec\u7684\u6811\u5f62\u7ed3\u6784\uff09\uff0c\u7136\u540e\u7528dfs\u5e8f\u5c06\u5b50\u6811\u64cd\u4f5c\u62cd\u6241\uff1b\n\n\u7b2c\u4e8c\u904d\u5173\u4e8e\u6bcf\u6b21\u8be2\u95ee\uff0c\u627e\u5230\u4e0a\u4e00\u6b21\u6e05\u7a7a\u7684\u65f6\u95f4\uff08\u5177\u4f53\u64cd\u4f5c\u662f\uff0c\u5728\u6e05\u7a7a\u65f6\uff0c\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u7ed9\u5b50\u6811\u6253\u4e0a\u6b64\u6b21\u6e05\u7a7a\u7684tag\uff1b\u7136\u540e\u5728\u8be2\u95ee\u65f6\uff0c\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u8be2\u95ee\uff09\u3002\n\n\u7b2c\u4e09\u904d\u7ef4\u62a4\u5b50\u6811\u52a0\u7684\u64cd\u4f5c\uff0c\u4eff\u7167\u4e8c\u7ef4\u6570\u70b9\u7b49\u7b49\u505a\u6cd5\uff0c\u540c\u65f6\u7edf\u8ba1\u7b54\u6848\u5e76\u8f93\u51fa\u3002\n\n\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u9898\u5173\u4e8e\u64cd\u4f5c\u6211\u4eec\u8981\u5efa\u51fa\u865a\u70b9\uff0c\u7136\u540e\u628a\u4e24\u4e2a\u96c6\u5408\u5168\u90fd\u5e76\u5230\u865a\u70b9\u4e0a\uff08\u800c\u4e0d\u662f\u4f20\u7edf\u51b0\u8336\u59ec\u610f\u4e49\u4e0a\u7684\u76f4\u63a5\u5408\u5e76\uff09\u3002\u5e76\u4e14\uff0c\u56e0\u4e3a\u8fd9\u9898\u6211\u4eec\u8981\u7684\u4e3b\u8981\u662f\u90a3\u68f5\u6811\uff0c\u56e0\u6b64\u751a\u81f3\u8fde\u51b0\u8336\u59ec\u90fd\u4e0d\u9700\u8981\uff0c\u76f4\u63a5\u5efa\u51fa\u64cd\u4f5c\u6811\u5c31\u884c\u4e86\u3002\u81f3\u4e8e\u4e3a\u4ec0\u4e48\u8981\u5efa\u865a\u70b9\uff0c\u662f\u4e3a\u4e86\u786e\u4fdd\u5728\u6bcf\u6b21\u5b50\u6811\u52a0\u65f6\u52a0\u7684\u4f4d\u7f6e\u6b63\u786e\uff08\u6709\u53ef\u80fd\u4e00\u4e9b\u5b50\u6811\u662f\u5728\u5b50\u6811\u52a0\u540e\u518d\u5e76\u8fdb\u6765\u7684\uff0c\u4f46\u5b50\u6811\u52a0\u662f\u79bb\u7ebf\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u5fc5\u987b\u786e\u4fdd\u6bcf\u6b21\u5b50\u6811\u52a0\u53ea\u52a0\u5230\u4e86\u5f53\u524d\u5728\u5b50\u6811\u5185\u7684\u70b9\u4e0a\uff09\u3002\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define lson x<<1\n#define rson x<<1|1\n#define mid ((l+r)>>1)\nint n,m,lim1,lim2;\nll res[500100];\nstruct qwq{\n\tint head[1001000],cnt,dfn[1001000],sz[1001000],bel[500100],tot,cmp,bsz[5001000];\n\tstruct node{\n\t\tint to,next;\n\t}edge[2001000];\n\tvoid ae(int u,int v){\n\t\tedge[cnt].next=head[u],edge[cnt].to=v,head[u]=cnt++;\n\t}\n\tvoid merge1(int x,int y){//merge x into y\n\t\ttot++,bsz[y]+=bsz[x],bsz[x]=0;\n\t\tae(tot,bel[x]),ae(tot,bel[y]),bel[y]=tot;\n\t}\n\tvoid merge2(int x,int y){bsz[y]+=bsz[x],bsz[x]=0,bel[y]=++tot;}\n\tvoid dfs(int x){\n\t\tsz[x]=1,dfn[x]=++cmp;\n\t\tfor(int i=head[x];i!=-1;i=edge[i].next)dfs(edge[i].to),sz[x]+=sz[edge[i].to];\n\t}\n\tvoid ini(){\n\t\ttot=n;\n\t\tfor(int i=1;i<=n;i++)bel[i]=i,bsz[i]=1;\n\t}\n}cam,pol;\nstruct st1{\n\tll tag[4001000];\n\tvoid pushdown(int x){\n\t\ttag[lson]+=tag[x],tag[rson]+=tag[x],tag[x]=0;\n\t}\n\tvoid add(int x,int l,int r,int L,int R,int val){\n\t\tif(l>R||r<L)return;\n\t\tif(L<=l&&r<=R){tag[x]+=val;return;}\n\t\tpushdown(x),add(lson,l,mid,L,R,val),add(rson,mid+1,r,L,R,val);\n\t}\n\tll query(int x,int l,int r,int P){\n\t\tif(l>P||r<P)return 0;\n\t\tif(l==r)return tag[x];\n\t\tpushdown(x);\n\t\treturn query(lson,l,mid,P)+query(rson,mid+1,r,P);\n\t}\n}s1;\nstruct st2{\n\tll tag[4001000];\n\tvoid pushdown(int x){\n\t\tif(tag[x])tag[lson]=tag[x],tag[rson]=tag[x],tag[x]=0;\n\t}\n\tvoid cg(int x,int l,int r,int L,int R,int val){\n\t\tif(l>R||r<L)return;\n\t\tif(L<=l&&r<=R){tag[x]=val;return;}\n\t\tpushdown(x),cg(lson,l,mid,L,R,val),cg(rson,mid+1,r,L,R,val);\n\t}\n\tll query(int x,int l,int r,int P){\n\t\tif(l>P||r<P)return 0;\n\t\tif(l==r)return tag[x];\n\t\tpushdown(x);\n\t\treturn query(lson,l,mid,P)+query(rson,mid+1,r,P);\n\t}\n}s2;\nstruct opt{\n\tint tp,a,b;\n\tvector<int>v;\n}q[500100];\nint main(){\n\tscanf(\"%d%d\",&n,&m),memset(cam.head,-1,sizeof(cam.head)),memset(pol.head,-1,sizeof(pol.head));\n\tcam.ini(),pol.ini();\n\tfor(int i=1;i<=m;i++){\n\t\tchar s[10];\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='U')q[i].tp=1,scanf(\"%d%d\",&q[i].b,&q[i].a),cam.merge1(q[i].a,q[i].b);\n\t\tif(s[0]=='M')q[i].tp=2,scanf(\"%d%d\",&q[i].b,&q[i].a),pol.merge1(q[i].a,q[i].b);\n\t\tif(s[0]=='A')q[i].tp=3,scanf(\"%d\",&q[i].a);\n\t\tif(s[0]=='Z')q[i].tp=4,scanf(\"%d\",&q[i].a);\n\t\tif(s[0]=='Q')q[i].tp=5,scanf(\"%d\",&q[i].a);\n\t}\n\tcam.tot++,pol.tot++;\n\tfor(int i=1;i<=n;i++){\n\t\tif(cam.bsz[i])cam.ae(cam.tot,cam.bel[i]);\n\t\tif(pol.bsz[i])pol.ae(pol.tot,pol.bel[i]);\n\t}\n\tcam.dfs(cam.tot),pol.dfs(pol.tot);\n\tlim1=cam.tot,lim2=pol.tot;\n\tcam.ini(),pol.ini();\n//\tfor(int i=1;i<=lim1;i++)printf(\"A:%d %d\\n\",cam.dfn[i],cam.sz[i]);\n//\tfor(int i=1;i<=lim2;i++)printf(\"B:%d %d\\n\",pol.dfn[i],pol.sz[i]);\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].tp==2)pol.merge2(q[i].a,q[i].b);\n\t\tif(q[i].tp==4)s2.cg(1,1,lim2,pol.dfn[pol.bel[q[i].a]],pol.dfn[pol.bel[q[i].a]]+pol.sz[pol.bel[q[i].a]]-1,i);\n\t\tif(q[i].tp==5){\n\t\t\tint tmp=s2.query(1,1,lim2,pol.dfn[q[i].a]);\n\t\t\tq[tmp].v.push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tif(q[i].tp==1)cam.merge2(q[i].a,q[i].b);\n\t\tif(q[i].tp==3)s1.add(1,1,lim1,cam.dfn[cam.bel[q[i].a]],cam.dfn[cam.bel[q[i].a]]+cam.sz[cam.bel[q[i].a]]-1,cam.bsz[q[i].a]);\n\t\tif(q[i].tp==4)for(int j=0;j<q[i].v.size();j++)res[q[i].v[j]]-=s1.query(1,1,lim1,cam.dfn[q[q[i].v[j]].a]);\n\t\tif(q[i].tp==5)res[i]+=s1.query(1,1,lim1,cam.dfn[q[i].a]),printf(\"%lld\\n\",res[i]);\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1584015750,
        "uid": 123369,
        "name": "xtx1092515503",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF571D \u3010Campus\u3011"
    },
    {
        "content": "\u53d1\u73b0\u6709\u4e24\u7c7b\u72ec\u7acb\u7684\u64cd\u4f5c\uff0c\u63d0\u51fa\u6765\u5206\u5f00\u7ef4\u62a4\u3002           \n\n\u6839\u636e\u9898\u76ee\u7279\u6027\u6309\u7167\u65f6\u95f4\u5206\u522b\u5efa\u7acb\u4e24\u68f5 Kruskal \u91cd\u6784\u6811\u7ef4\u62a4\u64cd\u4f5c $1,3$ \u548c\u64cd\u4f5c $2,4$\uff0c\u7531\u4e8e $n$ \u7684\u89c4\u6a21\u8fbe\u5230 $5 \\times 10 ^ 5$ \u6240\u4ee5\u5c1d\u8bd5\u4e00\u53ea $\\log$ \u7684\u505a\u6cd5\u3002             \n\n\u6211\u4eec\u4e0d\u96be\u53d1\u73b0\u5bf9\u4e8e $1,2$ \u64cd\u4f5c\u90fd\u662f\u5e73\u51e1\u7684\u5408\u5e76\u4e24\u68f5\u6811\uff0c\u8fd9\u4e2a\u5c31\u76f4\u63a5\u7ef4\u62a4\u597d\u4e86\u3002    \n\n\u5bf9\u4e8e $3,4$ \u64cd\u4f5c\u6211\u4eec\u4e0d\u96be\u53d1\u73b0\u76f8\u5f53\u4e8e\u5168\u90fd\u662f\u5f53\u524d\u7684\u5b50\u6811\u5185\u505a\u4e00\u6b21\u76f8\u5173\u64cd\u4f5c\uff0c\u6211\u4eec\u76f4\u63a5\u5c06\u65f6\u95f4\u5f53\u4f5c\u7ef4\u5ea6\u5168\u90e8\u79bb\u7ebf\u4e0b\u6765\uff0c$3$ \u64cd\u4f5c\u6302\u5230\u7b2c\u4e00\u7c7b\u6811\u7684\u5b50\u6811\u7684\u6839\u8282\u70b9\u4e0a\uff0c$4$ \u64cd\u4f5c\u6302\u5230\u7b2c\u4e8c\u7c7b\u6811\u7684\u5b50\u6811\u7684\u6839\u8282\u70b9\u4e0a\u3002          \n\n\u5bf9\u4e8e $5$ \u7684\u67e5\u8be2\u6211\u4eec\u6709\u4e00\u79cd\u663e\u7136\u7684\u601d\u8def\uff1a\u5373\u627e\u5230\u6700\u540e\u4e00\u6b21\u53d8 $0$ \u7684\u65f6\u95f4\u7136\u540e\u7b97\u51fa\u4ece\u6700\u540e\u4e00\u6b21\u53d8 $0$ \u540e\u4e2d\u95f4\u65f6\u95f4\u6bb5\u5bf9\u5b83\u80fd\u4ea7\u751f\u7684\u589e\u52a0\u91cf\uff0c\u5c31\u662f\u4e00\u6b21\u67e5\u8be2\u7684\u7b54\u6848\uff0c\u7531\u4e8e\u64cd\u4f5c\u5df2\u7ecf\u79bb\u7ebf\u5c31\u5c1d\u8bd5\u628a\u67e5\u8be2\u79bb\u7ebf\u4e0b\u6765\u3002                \n\n\u7136\u540e\u5c31\u6bd4\u8f83\u5957\u8def\u4e86\uff1a\u5148\u5bf9\u7b2c\u4e8c\u7c7b\u6811 dfs \u4e00\u904d\u7136\u540e\u628a\u8def\u4e0a\u7684\u6240\u6709 $4$ \u64cd\u4f5c\u6d89\u53ca\u5230\u7684\u65f6\u95f4 $t$ \u5168\u90e8\u5b58\u4e0b\u6765\uff0c\u904d\u5386\u5230\u53f6\u5b50\u8282\u70b9\u65f6\uff0c\u5f53\u524d\u6302\u5728\u5f53\u524d\u53f6\u5b50\u8282\u70b9\u7684\u6240\u6709\u67e5\u8be2\u90fd\u62ff\u51fa\u6765\u95ee\u4e00\u904d\u81ea\u5df1\u65f6\u95f4\u7684\u524d\u9a71\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u5f97\u5230\u8be5\u8be2\u95ee\u4e4b\u524d\u6700\u540e\u4e00\u6b21\u53d8 $0$ \u7684\u65f6\u95f4\u3002\u7ed3\u675f dfs \u65f6\u5c31\u76f4\u63a5\u6254\u6389\u4e0d\u80fd\u7528\u7684 $t$ \u5c31\u884c\u4e86\u3002         \n\n\u63a5\u7740\u518d\u5bf9\u7b2c\u4e00\u7c7b\u6811 dfs \u4e00\u904d\uff0c\u628a\u65f6\u95f4\u8f74\u62ff\u51fa\u6765\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u8def\u5f84\u4e0a\u7684\u64cd\u4f5c\u90fd\u5f62\u5982 $(x,y)$ \u8868\u793a $x$ \u65f6\u95f4\u4e4b\u540e\u8be5\u503c\u5e94\u8be5\u52a0\u4e0a $y$\uff0c\u8fd9\u4e2a\u53cd\u5e94\u5728\u7ebf\u6bb5\u6811\u4e0a\u5c31\u662f\u4e2a\u5355\u70b9\u4fee\u6539\uff0c\u904d\u5386\u5230\u53f6\u5b50\u8282\u70b9\u65f6\u5c31\u518d\u628a\u6302\u597d\u7684\u8be2\u95ee\u62ff\u51fa\u6765\u95ee\u4e00\u6b21\u533a\u95f4\u67e5\u8be2\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n \\log m + m \\log m)$\u3002               \n\n\u4e0d\u8fc7\u9700\u8981\u6ce8\u610f\u6570\u636e\u4e5f\u6709\u53ef\u80fd\u751f\u6210\u68ee\u6797\uff0c\u8fd9\u4e2a\u5c31\u5bf9\u6bcf\u4e2a\u6839\u8dd1\u4e00\u904d\u5373\u53ef\u3002       \n\n```cpp\n#include \"bits/stdc++.h\"\nusing namespace std;\nconst int Len = 1e6 + 5;\nint n,m;bool flag[Len],flaw[Len];\nstruct Edger\n{\n\tint id,lim,head[Len],cnt,siz[Len << 1];\n\tstruct node\n\t{\n\t\tint next,to;\n\t}edge[Len << 1];\n\tvoid add(int from,int to){edge[++ cnt].to = to;edge[cnt].next = head[from];head[from] = cnt;}\n}E1,E2;\nstruct UnionSet\n{\n\tint fa[Len];\n\tvoid makeSet(int x){for(int i = 1 ; i <= x ; i ++) fa[i] = i;}\n\tint findSet(int x){return fa[x] == x ? fa[x] : fa[x] = findSet(fa[x]);}\n}S1,S2;\nchar s[5];\nstruct Node\n{\n\tint add,tim;\n\tNode(){add = tim = 0;}\n\tNode(int ADD,int TIM){add = ADD , tim = TIM;} \n};\nbool cmp(Node x,Node y){return x.tim < y.tim;}\nvector<Node> v[Len][3];\nlong long Print[Len],sum[Len << 2];\nint x,y,maxn[Len << 2];;\n#define ls(x) x << 1\n#define rs(x) x << 1 | 1\nvoid push_up(int x)\n{\n\tsum[x] = sum[ls(x)] + sum[rs(x)];\n\tmaxn[x] = max(maxn[ls(x)] , maxn[rs(x)]);\n}\nvoid build(int p,int l,int r)\n{ \n\tsum[p] = maxn[p] = 0;\n\tif(l == r) return;\n\tint mid = (l + r) >> 1;\n\tbuild(ls(p) , l , mid);\n\tbuild(rs(p) , mid + 1 , r);\n}\nvoid updatetim(int p,int l,int r,int idx,int w)\n{\n\tif(l == r) \n\t{\n\t\tmaxn[p] = w;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(idx <= mid) updatetim(ls(p) , l , mid , idx , w);\n\telse updatetim(rs(p) , mid + 1 , r , idx , w);\n\tpush_up(p);\n}\nint Neartim(int p,int l,int r,int idx)\n{\n\t//if(idx == 8) printf(\"%d %d %d\\n\",l,r,maxn[p]);\n\tif(l == r) \n\t{\n\t\tif(!maxn[p]) return 0;\n\t\treturn l;\n\t}\n\tint mid = (l + r) >> 1 , res = 0;\n\tif(mid < idx) \n\t{\n\t\tres = max(res , maxn[ls(p)]);\n\t\tres = max(res , Neartim(rs(p) , mid + 1 , r , idx));\n\t\treturn res;\n\t}\n\treturn Neartim(ls(p) , l , mid , idx);\n}\nvoid updatesum(int p,int l,int r,int idx,int w)\n{\n\tif(l == r)\n\t{\n\t\tsum[p] += w;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(idx <= mid) updatesum(ls(p) , l , mid , idx , w);\n\telse updatesum(rs(p) , mid + 1 , r , idx , w);\n\tpush_up(p);\n}\nlong long querysum(int p,int l,int r,int nl,int nr)\n{\n\tif(nl <= l && nr >= r) return sum[p];\n\tint mid = (l + r) >> 1;long long res = 0;\n\tif(nl <= mid) res += querysum(ls(p) , l , mid , nl , nr);\n\tif(nr > mid) res += querysum(rs(p) , mid + 1 , r , nl , nr);\n\treturn res;\n}\nvoid dfs2(int x,int f)\n{\n\tflaw[x] |= 1;\n\tfor(int i = 0 ; i < v[x][1].size() ; i ++) \n\t{\n\t\t//if(x == 3) printf(\"###%d\\n\",v[x][1][i].tim);\n\t\tupdatetim(1 , 1 , m , v[x][1][i].tim , v[x][1][i].tim);\n\t}\n\tif(x <= n)\n\t{\n\t\tfor(int i = 0 ; i < v[x][2].size() ; i ++) \n\t\t{\n\t\t\tPrint[v[x][2][i].add] = Neartim(1 , 1 , m , v[x][2][i].tim);\n\t\t\t//if(Print[v[x][2][i].add] == -1) Print[v[x][2][i].add] = 0;\n\t\t\t//printf(\"%d %d\\n\",v[x][2][i].add,Print[v[x][2][i].add]);\n\t\t}\n\t}\n\tfor(int e = E2.head[x] ; e ; e = E2.edge[e].next)\n\t{\n\t\tint to = E2.edge[e].to;\n\t\tif(to == f) continue;\n\t\tdfs2(to , x);\n\t}\n\tfor(int i = 0 ; i < v[x][1].size() ; i ++) updatetim(1 , 1 , m , v[x][1][i].tim , 0);\n}\nvoid dfs1(int x,int f)\n{\n\tflaw[x] |= 1;\n\tfor(int i = 0 ; i < v[x][0].size() ; i ++) \n\t{\n\t\t//if(x == 3) printf(\"###%d %d\\n\",v[x][0][i].tim,v[x][0][i].add);\n\t\tupdatesum(1 , 1 , m , v[x][0][i].tim , v[x][0][i].add);\n\t}\n\tif(x <= n)\n\t{\n\t\tfor(int i = 0 ; i < v[x][2].size() ; i ++) \n\t\t{\n\t\t\tint num = Print[v[x][2][i].add];\n\t\t\tPrint[v[x][2][i].add] = querysum(1 , 1 , m , num + 1 , v[x][2][i].tim);\n\t\t}\n\t} \n\tfor(int e = E1.head[x] ; e ; e = E1.edge[e].next)\n\t{\n\t\tint to = E1.edge[e].to;\n\t\tif(to == f) continue;\n\t\tdfs1(to , x);\n\t}\n\tfor(int i = 0 ; i < v[x][0].size() ; i ++) updatesum(1 , 1 , m , v[x][0][i].tim , -v[x][0][i].add);\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tE1.id = n , E2.id = n;E1.lim = n << 1 , E2.lim = n << 1;\n\tfor(int i = 1 ; i <= n ; i ++) E1.siz[i] = E2.siz[i] = 1;\n\tS1.makeSet(E1.lim) , S2.makeSet(E2.lim);\n\tfor(int i = 1 ; i <= m ; i ++)\n\t{\n\t\tscanf(\"%s\",s + 1);\n\t\tif(s[1] == 'U') \n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);int u = S1.findSet(x) , v = S1.findSet(y); \n\t\t\tif(u == v) continue;\n\t\t\tS1.fa[u] = S1.fa[v] = ++ E1.id;\n\t\t\tE1.siz[E1.id] = E1.siz[u] + E1.siz[v];\n\t\t\tE1.add(E1.id , u) , E1.add(E1.id , v);\n\t\t}\n\t\telse if(s[1] == 'M') \n\t\t{\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\tint u = S2.findSet(x) , v = S2.findSet(y);\n\t\t\tif(u == v) continue;\n\t\t\tS2.fa[u] = S2.fa[v] = ++ E2.id;\n\t\t\tE2.siz[E2.id] = E2.siz[u] + E2.siz[v];\n\t\t\tE2.add(E2.id , u) , E2.add(E2.id , v);\n\t\t}\n\t\telse if(s[1] == 'A')\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tx = S1.findSet(x);\n\t\t\tv[x][0].push_back(Node(E1.siz[x] , i));\n\t\t}\n\t\telse if(s[1] == 'Z')\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tx = S2.findSet(x);\n\t\t\tv[x][1].push_back(Node(0 , i));\n\t\t}\n\t\telse if(s[1] == 'Q') \n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x][2].push_back(Node(i , i));\n\t\t\tflag[i] |= 1; \n\t\t}\n\t}\t\n\tbuild(1 , 1 , m);\n\tfor(int i = E2.id ; i >= 1 ; i --) if(!flaw[i]) dfs2(i , 0);\n\tfor(int i = 1 ; i <= E2.id ; i ++) flaw[i] = 0;\n\t//for(int i = 1 ; i <= m ; i ++) if(flag[i]) printf(\"###%lld\\n\",Print[i]);\n\tbuild(1 , 1 , m);\n\tfor(int i = E1.id ; i >= 1 ; i --) if(!flaw[i]) dfs1(i , 0);\n\tfor(int i = 1 ; i <= m ; i ++) if(flag[i]) printf(\"%lld\\n\",Print[i]); \n\treturn 0;\n}\n```",
        "postTime": 1632578722,
        "uid": 132533,
        "name": "Hakuoro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF571D Campus"
    }
]