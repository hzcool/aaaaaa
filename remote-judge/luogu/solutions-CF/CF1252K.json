[
    {
        "content": "### [\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/CF1252K)\n\n### \u601d\u8def\n\n\u5bf9\u4e8e $A = A + B$\uff0c$B = A + B$ \u8fd9\u79cd\u7684\u9012\u63a8\u5f0f\u53ef\u4ee5\u8003\u8651\u77e9\u9635\u52a0\u901f\u9012\u63a8\uff0c\u53ef\u5f97\uff1a\n\n$$\n\\left (\n\\begin{matrix}\nA + B & B\n\\end{matrix}\n\\right ) =\n\\left (\n\\begin{matrix}\nA & B\n\\end{matrix}\n\\right ) \n\\left (\n\\begin{matrix}\n1 & 0 \\\\\n1 & 1\n\\end{matrix}\n\\right )\n$$\n$$\n\\left (\n\\begin{matrix}\nA & A + B\n\\end{matrix}\n\\right ) =\n\\left (\n\\begin{matrix}\nA & B\n\\end{matrix}\n\\right ) \n\\left (\n\\begin{matrix}\n1 & 1 \\\\\n0 & 1\n\\end{matrix}\n\\right ) \n$$\n\n\u628a $A,B$ \u4e8c\u5143\u7ec4\u770b\u4f5c\u5355\u4f4d\u5411\u91cf $\\left ( \\begin{matrix} A & B \\end{matrix} \\right )$\uff0c\u8bbe $S_i$ \u5bf9\u5e94\u7684\u8f6c\u79fb\u77e9\u9635\u4e3a $G_i$\uff0c\u5219\u4e00\u6b21 ```F``` \u51fd\u6570\u64cd\u4f5c\u5f97\u5230\u7684 $A,B$ \u4e8c\u5143\u7ec4\u5bf9\u5e94\u7684\u5411\u91cf\u5c31\u662f\uff1a\n\n$$\n\\left ( \\begin{matrix} A & B \\end{matrix} \\right )\n\\prod_{i = l}^{r} G_i\n$$\n\n\u7531\u4e8e\u77e9\u9635\u4e58\u6cd5\u6ee1\u8db3\u7ed3\u5408\u5f8b\uff0c\u5bf9\u4e8e\u4e00\u6bb5\u533a\u95f4\u7684\u77e9\u9635\u7684\u4e58\u79ef\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u8003\u8651\u533a\u95f4\u53d6\u53cd\u64cd\u4f5c\u600e\u4e48\u5b9e\u73b0\uff0c\u6211\u4eec\u901a\u8fc7~~\u6253\u8868~~\u89c2\u5bdf\u4e0a\u65b9\u7ed9\u51fa\u7684\u4e24\u4e2a\u8f6c\u79fb\u77e9\u9635\uff0c\u53d1\u73b0\u5b83\u4eec\u90fd\u662f\u5bf9\u65b9\u65cb\u8f6c\u4e86 $180^{\\circ}$\u3002\u611f\u6027\u7406\u89e3\u4e00\u4e0b\uff0c\u8bbe\u6709\u77e9\u9635 $A,B,C$\uff0c\u6709\uff1a\n\n$$\nA =\n\\left (\n\\begin{matrix}\na_1 & b_1 \\\\\nc_1 & d_1\n\\end{matrix}\n\\right )\n$$\n$$\nB = \n\\left (\n\\begin{matrix}\na_2 & b_2 \\\\\nc_2 & d_2\n\\end{matrix}\n\\right )\n$$\n$$\nC = A \\times B =\n\\left (\n\\begin{matrix}\na_1a_2 + b_1c_2 & a_1b_2 + b_1d_2 \\\\\nc_1a_2 + d_1c_2 & c_1b_2 + d_1d_2\n\\end{matrix}\n\\right )\n$$\n\n\u8bbe $A'$\uff0c$B'$ \u4e3a $A$\uff0c$B$ \u5404\u65cb\u8f6c $180^{\\circ}$ \u540e\u7684\u77e9\u9635\uff0c\u6709:\n\n$$\nA' = \n\\left (\n\\begin{matrix}\nd_1 & c_1 \\\\\nb_1 & a_1\n\\end{matrix}\n\\right )\n$$\n$$\nB' = \n\\left (\n\\begin{matrix}\nd_2 & c_2 \\\\\nb_2 & a_2\n\\end{matrix}\n\\right )\n$$\n$$\nC' = A' \\times B' =\n\\left (\n\\begin{matrix}\nd_1d_2 + c_1b_2 & d_1c_2 + c_1a_2 \\\\\nb_1d_2 + a_1b_2 & b_1c_2 + a_1a_2\n\\end{matrix}\n\\right )\n$$\n\n\u53ef\u4ee5\u53d1\u73b0 $C'$ \u4e5f\u662f $C$ \u65cb\u8f6c $180^{\\circ}$ \u540e\u7684\u7ed3\u679c\uff0c\u6240\u4ee5\u63a8\u5e7f\u8fd9\u4e2a\u7ed3\u8bba\u5230 $A,B$ \u7684\u53cd\u8f6c\u64cd\u4f5c\u4e0a\uff0c\u5c31\u662f\u76f4\u63a5\u4ea4\u6362\u77e9\u9635\u5bf9\u89d2\u7ebf\u4e0a\u7684\u5143\u7d20\u3002\u5c31\u50cf\u7ef4\u62a401\u5e8f\u5217\u7684\u7ffb\u8f6c\u90a3\u6837\u7ef4\u62a4\u7ebf\u6bb5\u6811\u5c31\u884c\u4e86\u3002\u65f6\u95f4\u590d\u6742\u5ea6 $\\Theta (2 ^ 3 n \\log n)$ \u3002\n\n### Code\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define LL long long\n\nusing namespace std;\n\nconst int Mod = 1e9 + 7;\nconst int MAXN = 1e5 + 10, SIZE = 3;\nint n, q;\nchar s[MAXN];\n\nstruct Matrix{\n    int hig, wid;\n    LL num[SIZE][SIZE];\n\n    Matrix(){\n        hig = wid = 0;\n        memset(num, 0, sizeof(num));\n    }\n\n    Matrix operator * (const Matrix &b) const{\n        Matrix c;\n        c.hig = hig, c.wid = b.wid;\n        for(register int i = 1; i <= c.hig; i++){\n            for(register int k = 1; k <= b.hig; k++){\n                LL res = num[i][k];\n                for(register int j = 1; j <= c.wid; j++)\n                    c.num[i][j] = 1LL * (c.num[i][j] + res * b.num[k][j] % Mod) % Mod;\n            }\n        }\n\n        return c;\n    }\n\n    void Reverse(){\n        swap(num[1][1], num[2][2]);\n        swap(num[1][2], num[2][1]);\n    }\n}base, G1, G2, I;\n\nstruct Segment_Tree{\n    struct Tree{\n        int l, r;\n        Matrix sum;\n        int lazy;\n    }tr[MAXN << 2];\n\n    inline int lson(int rt){\n        return rt << 1;\n    }\n\n    inline int rson(int rt){\n        return rt << 1 | 1;\n    }\n\n    inline void Pushup(int rt){\n        tr[rt].sum = tr[lson(rt)].sum * tr[rson(rt)].sum;\n    }\n\n    void Build(int rt, int l, int r){\n        tr[rt].l = l, tr[rt].r = r;\n        if(l == r){\n            if(s[l] == 'A') tr[rt].sum = G1;\n            else tr[rt].sum = G2;\n            return;\n        }\n\n        int mid = (l + r) >> 1;\n        Build(lson(rt), l, mid);\n        Build(rson(rt), mid + 1, r);\n\n        Pushup(rt);\n    }\n\n    inline void Pushdwon(int rt){\n        if(tr[rt].lazy){\n            tr[lson(rt)].lazy ^= 1;\n            tr[rson(rt)].lazy ^= 1;\n            tr[lson(rt)].sum.Reverse();\n            tr[rson(rt)].sum.Reverse();\n            tr[rt].lazy = 0;\n        }\n    }\n\n    void Update_Rev(int rt, int l, int r){\n        if(tr[rt].l >= l && tr[rt].r <= r){\n            tr[rt].sum.Reverse();\n            tr[rt].lazy ^= 1;\n            return;\n        }\n\n        Pushdwon(rt);\n\n        int mid = (tr[rt].l + tr[rt].r) >> 1;\n        if(l <= mid) Update_Rev(lson(rt), l, r);\n        if(r > mid) Update_Rev(rson(rt), l, r);\n\n        Pushup(rt);\n    }\n\n    Matrix Query_Sum(int rt, int l, int r){\n        if(tr[rt].l >= l && tr[rt].r <= r) return tr[rt].sum;\n\n        Pushdwon(rt);\n\n        Matrix ans = base;\n        int mid = (tr[rt].l + tr[rt].r) >> 1;\n        if(l <= mid) ans = ans * Query_Sum(lson(rt), l, r);\n        if(r > mid) ans = ans * Query_Sum(rson(rt), l, r);\n\n        return ans;\n    }\n}S;\n\nvoid init(){\n    base.hig = base.wid = 2;\n    base.num[1][1] = base.num[2][2] = 1;\n    G1.hig = G1.wid = 2;\n    G1.num[1][1] = G1.num[2][1] = G1.num[2][2] = 1;\n    G2.hig = G2.wid = 2;\n    G2.num[1][1] = G2.num[1][2] = G2.num[2][2] = 1;\n    I.hig = 1, I.wid = 2;\n}\n\nint main(){\n    init();\n\n    scanf(\"%d%d\", &n, &q);\n    scanf(\"%s\", s + 1);\n\n    S.Build(1, 1, n);\n\n    for(register int i = 1; i <= q; i++){\n        int opt;\n        scanf(\"%d\", &opt);\n\n        if(opt == 1){\n            int l, r;\n            scanf(\"%d%d\", &l, &r);\n            S.Update_Rev(1, l, r);\n        }\n        else{\n            int l, r, a, b;\n            scanf(\"%d%d%d%d\", &l, &r, &a, &b);\n            I.num[1][1] = a, I.num[1][2] = b;\n            I = I * S.Query_Sum(1, l, r);\n            printf(\"%lld %lld\\n\", I.num[1][1], I.num[1][2]);\n        }\n    }\n\n    return 0;\n}\n```\n\n\u9a6c\u8702\u5197\u957f\uff0c\u4e0d\u559c\u52ff\u55b7\u3002",
        "postTime": 1667455114,
        "uid": 452407,
        "name": "TSTYFST",
        "ccfLevel": 6,
        "title": "CF1252K Addition Robot"
    },
    {
        "content": "\u76f4\u63a5\u505a\u662f\u96be\u7684\uff0c\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u4f3c\u4e4e\u53ef\u4ee5\u77e9\u9635\u4f18\u5316\u3002\n\n\u53ef\u4ee5\u53d1\u73b0 $\\begin{bmatrix} a+b&b \\end{bmatrix} = \\begin{bmatrix} a & b \\end{bmatrix} \\times \\begin{bmatrix} 1 & 0 \\\\ 1 & 1\\end{bmatrix}$\uff0c$\\begin{bmatrix} a & a + b \\end{bmatrix} = \\begin{bmatrix} a&b \\end{bmatrix} \\times \\begin{bmatrix} 1 & 1\\\\ 0 & 1\\end{bmatrix}$\u3002\n\n\u5bf9\u4e8e $S_i$ \u4e3a $\\texttt{A}$\uff0c\u90a3\u4e48\u4ee4 $p_i = \\begin{bmatrix} 1 & 0 \\\\ 1 & 1\\end{bmatrix}$\uff0c\u5426\u5219 $p_i = \\begin{bmatrix} 1 & 1\\\\ 0 & 1\\end{bmatrix}$\u3002\n\n\u90a3\u4e48\u5bf9\u4e8e\u8be2\u95ee $l, r, a, b$\uff0c\u5219\u6700\u7ec8\u77e9\u9635\u5e94\u8be5\u4e3a $\\begin{bmatrix} a & b \\end{bmatrix} \\times \\prod \\limits_{i=l}^r p_i$\u3002\n\n\u5bb9\u6613\u53d1\u73b0\u53ef\u4ee5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u4e58\u6cd5\u3002\n\n\u5bf9\u4e8e\u533a\u95f4\u53cd\u8f6c\uff0c\u53ea\u9700\u8981\u7ef4\u62a4\u533a\u95f4\u53cd\u8f6c\u540e\u7684\u4e58\u79ef\u548c\u53cd\u8f6c\u524d\u7684\u4e58\u79ef\uff0c\u53cd\u8f6c\u65f6\u4ea4\u6362\u4e24\u4e2a\u7ed3\u679c\u5373\u53ef\u3002\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <string>\nusing namespace std;\n\nconst int N = 1e5 + 5;\nconst long long MOD = 1e9 + 7;\nstring s;\nint n, m;\n\nstruct Matrix\n{\n\tlong long a[3][3];\n\tMatrix(long long ax, long long b, long long c, long long d)\n\t{\n\t\ta[1][1] = ax, a[1][2] = b, a[2][1] = c, a[2][2] = d;\n\t}\n\tMatrix()\n\t{\n\t\ta[0][0] = a[0][1] = a[0][2] = a[1][0] = a[1][1] = a[1][2] = a[2][0] = a[2][1] = a[2][2] = 0LL;\n\t}\n\tvoid Clear()\n\t{\n\t\ta[1][1] = -1LL;\n\t}\n\tfriend Matrix operator*(const Matrix& a, const Matrix& b)\n\t{\n\t\tif (a.a[1][1] == -1LL) return b;\n\t\tif (b.a[1][1] == -1LL) return a;\n\t\tMatrix c;\n\t\tfor (int i = 1; i <= 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= 2; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 1; k <= 2; k++)\n\t\t\t\t{\n\t\t\t\t\tc.a[i][j] = (c.a[i][j] + a.a[i][k] * b.a[k][j]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n};\n\nclass SegmentTree\n{\npublic:\n\tstruct Node\n\t{\n\t\tint l, r;\n\t\tMatrix ans1, ans2;\n\t\tbool revtag;\n\t}tr[N << 2];\n\tvoid pushup(int u)\n\t{\n\t\ttr[u].ans1 = tr[u << 1].ans1 * tr[u << 1 | 1].ans1;\n\t\ttr[u].ans2 = tr[u << 1].ans2 * tr[u << 1 | 1].ans2;\n\t}\n\tvoid pushdown(int u)\n\t{\n\t\tif (tr[u].revtag)\n\t\t{\n\t\t\ttr[u].revtag = 0;\n\t\t\tswap(tr[u << 1].ans1, tr[u << 1].ans2);\n\t\t\ttr[u << 1].revtag ^= 1;\n\t\t\tswap(tr[u << 1 | 1].ans1, tr[u << 1 | 1].ans2);\n\t\t\ttr[u << 1 | 1].revtag ^= 1;\n\t\t}\n\t}\n\tvoid build(int u, int l, int r)\n\t{\n\t\tif (l == r)\n\t\t{\n\t\t\ttr[u] = { l, r };\n\t\t\tchar c = s[l - 1];\n\t\t\tif (c == 'A')\n\t\t\t{\n\t\t\t\ttr[u].ans1 = Matrix(1LL, 0LL, 1LL, 1LL);\n\t\t\t\ttr[u].ans2 = Matrix(1LL, 1LL, 0LL, 1LL);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttr[u].ans2 = Matrix(1LL, 0LL, 1LL, 1LL);\n\t\t\t\ttr[u].ans1 = Matrix(1LL, 1LL, 0LL, 1LL);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\ttr[u] = { l, r };\n\t\tint mid = l + r >> 1;\n\t\tbuild(u << 1, l, mid);\n\t\tbuild(u << 1 | 1, mid + 1, r);\n\t\tpushup(u);\n\t}\n\tvoid update(int u, int l, int r)\n\t{\n\t\tif (tr[u].l >= l and tr[u].r <= r)\n\t\t{\n\t\t\ttr[u].revtag ^= 1;\n\t\t\tswap(tr[u].ans1, tr[u].ans2);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid = tr[u].l + tr[u].r >> 1;\n\t\tif (l <= mid) update(u << 1, l, r);\n\t\tif (r > mid) update(u << 1 | 1, l, r);\n\t\tpushup(u);\n\t}\n\tMatrix query(int u, int l, int r)\n\t{\n\t\tif (tr[u].l >= l and tr[u].r <= r)\n\t\t{\n\t\t\treturn tr[u].ans1;\n\t\t}\n\t\tpushdown(u);\n\t\tint mid = tr[u].l + tr[u].r >> 1;\n\t\tMatrix res;\n\t\tres.Clear();\n\t\tif (l <= mid) res = query(u << 1, l, r);\n\t\tif (r > mid) res = res * query(u << 1 | 1, l, r);\n\t\treturn res;\n\t}\n}tr;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n\tcin >> n >> m >> s;\n\ttr.build(1, 1, n);\n\twhile (m--)\n\t{\n\t\tint opt;\n\t\tcin >> opt;\n\t\tif (opt == 1)\n\t\t{\n\t\t\tint l, r;\n\t\t\tcin >> l >> r;\n\t\t\ttr.update(1, l, r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint l, r;\n\t\t\tlong long a, b;\n\t\t\tcin >> l >> r >> a >> b;\n\t\t\tMatrix res(a, b, 0LL, 0LL);\n\t\t\tres = res * tr.query(1, l, r);\n\t\t\tMatrix p = tr.query(1, l, r);\n\t\t\tprintf(\"%lld %lld\\n\", res.a[1][1], res.a[1][2]);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1684234227,
        "uid": 332914,
        "name": "happybob",
        "ccfLevel": 6,
        "title": "Addition Robot"
    },
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/solution/CF1252K)\n\n[\u53ef\u80fd\u66f4\u597d\u7684\u9605\u8bfb\u4f53\u9a8c](https://chenyu-w.github.io./2023/01/21/CF1252K%20Addition%20Robot/)\n\n## \u524d\u8a00\n\n\u7b2c\u4e00\u6b21\u505a\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u4e58\u6cd5\u7684\u9898\u76ee\uff0c\u7b97\u662f\u4e3a ddp \u6253\u57fa\u7840\u4e86\u5427\u3002\n\n## \u5206\u6790\n\n\u6ce8\u610f\u5230\n$$\n\\begin{bmatrix}\nA & B\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0\\\\\n1 & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA + B & B\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\nA & B\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 1\\\\\n0 & 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA & A + B\n\\end{bmatrix}\n$$\n\n\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u4e00\u4e2a\u533a\u95f4\u5185\u77e9\u9635\u4e58\u6cd5\u7684\u7b54\u6848\uff0c\u56e0\u4e3a\u5b57\u6bcd\u7c7b\u578b\u5355\u4e00\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u987a\u4fbf\u5b58\u4e00\u4e0b\u53cd\u8f6c\u5b57\u7b26\u540e\u7684\u7b54\u6848\uff0c\u4fee\u6539\u65f6\u4ea4\u6362\u5373\u53ef\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $O(n\\log n)$\uff0c\u5e26 $2^3$ \u7684\u5e38\u6570\u3002\n\n## \u4ee3\u7801\n\n```c++\n#include <bits/stdc++.h>\n#define L(i, j, k, l) for (int i = (j); i <= (k); i += (l))\n#define R(i, j, k, l) for (int i = (j); i >= (j); i -= (l))\nusing namespace std;\nconst int N = 1e5 + 10, mod = 1e9 + 7;\nstruct Matrix {\n\tint a[2][2];\n\tMatrix(int p = 0, int q = 0, int x = 0, int y = 0) {a[0][0] = p, a[0][1] = q, a[1][0] = x, a[1][1] = y;}\n\tMatrix operator*(Matrix b) {\n\t\tMatrix c;\n\t\tL(k, 0, 1, 1) L(i, 0, 1, 1) L(j, 0, 1, 1) c.a[i][j] = (c.a[i][j] + 1ll * a[i][k] * 1ll * b.a[k][j] % mod) % mod;\n\t\treturn c;\n\t}\n};\nstruct Sgt\n{\n\tint l, r, tag;\n\tMatrix res0, res1;\n} t[N << 2];\nchar s[N];\ninline int read() {\n\tint x = 0, y = 1; char c = getchar();\n\twhile (c < '0' || c > '9') {if (c == '-') y = -1; c = getchar();}\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * y;\n}\ninline void pushup(int p) {\n\tSgt &u = t[p], &l = t[p << 1], &r = t[p << 1 | 1];\n\tu.res0 = l.res0 * r.res0, u.res1 = l.res1 * r.res1;\n}\ninline void pushdown(int p) {\n\tif (t[p].tag) swap(t[p << 1].res0, t[p << 1].res1), t[p << 1].tag ^= 1, swap(t[p << 1 | 1].res0, t[p << 1 | 1].res1), t[p << 1 | 1].tag ^= 1, t[p].tag = 0;\n}\ninline void build(int p, int l, int r) {\n\tt[p].l = l, t[p].r = r;\n\tif (l == r) {\n\t\tt[p].res0 = Matrix(1, 0, 1, 1);\n\t\tt[p].res1 = Matrix(1, 1, 0, 1);\n\t\tif (s[l] == 'B')\n\t\t\tswap(t[p].res0, t[p].res1);\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(p << 1, l, mid), build(p << 1 | 1, mid + 1, r);\n\tpushup(p);\n}\ninline void modify(int p, int l, int r) {\n\tif (l <= t[p].l && t[p].r <= r) {\n\t\tswap(t[p].res0, t[p].res1), t[p].tag ^= 1;\n\t\treturn;\n\t}\n\tpushdown(p);\n\tint mid = (t[p].l + t[p].r) >> 1;\n\tif (l <= mid) modify(p << 1, l, r);\n\tif (r > mid) modify(p << 1 | 1, l, r);\n\tpushup(p);\n}\n\ninline Sgt merge(Sgt l, Sgt r) {\n\tSgt u;\n\tu.res0 = l.res0 * r.res0, u.res1 = l.res1 * r.res1;\n\treturn u;\n}\n\ninline Sgt query(int p, int l, int r) {\n\tif (l <= t[p].l && t[p].r <= r) return t[p];\n\tpushdown(p);\n\tint mid = (t[p].l + t[p].r) >> 1;\n\tif (l > mid) return query(p << 1 | 1, l, r);\n\tif (r <= mid) return query(p << 1, l, r);\n\treturn merge(query(p << 1, l, r), query(p << 1 | 1, l, r));\n}\n\nint main() {\n\tint n = read(), q = read();\n\tcin >> s + 1;\n\tbuild(1, 1, n);\n\twhile (q--) {\n\t\tint op = read(), l = read(), r = read();\n\t\tif (op == 1)\n\t\t\tmodify(1, l, r);\n\t\telse {\n\t\t\tMatrix a;\n\t\t\ta.a[0][0] = read(), a.a[0][1] = read();\n\t\t\ta = a * query(1, l, r).res0;\n\t\t\tprintf(\"%d %d\\n\", a.a[0][0], a.a[0][1]);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n",
        "postTime": 1674283535,
        "uid": 587248,
        "name": "wcywcywcywcy",
        "ccfLevel": 0,
        "title": "\u3010\u9898\u89e3\u3011CF1252K"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u4e2a\u548c\u5176\u4ed6\u9898\u89e3\u4e0d\u540c\u7684\u601d\u8def\uff0c\u53ef\u4ee5\u8fd0\u7528\u5728\u8fd9\u4e00\u7c7b\u9898\u4e2d\u3002\n\n\u7531\u4e8e\u77e9\u9635\u7684\u7ed3\u5408\u5f8b\u4e0e\u7ebf\u6bb5\u6811\u76f8\u5951\u5408\uff0c\u6211\u4eec\u8003\u8651\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4\u77e9\u9635\u4e58\u6cd5\u3002\n\n\u6211\u4eec\u6709\u4e0b\u5217\u7684\u5f0f\u5b50\uff1a\n\n$$\n\\begin{bmatrix}\nA&B\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1&0\\\\\n1&1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA+B&B\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\nA&B\n\\end{bmatrix}\n\\times\n\\begin{bmatrix}\n1&1\\\\\n0&1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA&A+B\n\\end{bmatrix}\n$$\n\n\u4f46\u5bf9\u4e8e\u53cd\u8f6c\u64cd\u4f5c\uff0c\u8003\u8651\u5230\u5b83\u53ea\u6709\u4e24\u79cd\u5b57\u6bcd\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u7ebf\u6bb5\u6811\u7684\u8282\u70b9\u4e0a\u5f00\u4e24\u4e2a\u77e9\u9635\u7ef4\u62a4\u8fd9\u4e2a\u533a\u95f4\u53cd\u8f6c\u524d\u4e0e\u53cd\u8f6c\u540e\u5206\u522b\u7684\u7b54\u6848\uff0c\u7136\u540e\u5f00\u4e00\u4e2a\u61d2\u6807\u8bb0\u7ef4\u62a4\u533a\u95f4\u662f\u5426\u53cd\u8f6c\u3002\n\n\u5f53\u6211\u4eec\u8fdb\u884c\u53cd\u8f6c\u64cd\u4f5c\u65f6\uff0c\u53ea\u9700\u8981\u4ea4\u6362\u4e24\u4e2a\u77e9\u9635\u7684\u503c\uff0c\u7136\u540e\u6253\u4e0a\u61d2\u6807\u8bb0\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u4e00\u4e9b\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4\u53cd\u8f6c\u64cd\u4f5c\u7684\u9898\u76ee\u53ef\u4ee5\u8003\u8651\u8fd9\u4e48\u505a\uff0c\u5305\u62ec\u4f46\u4e0d\u9650\u4e8e\u62ec\u53f7\u5e8f\u5217\u7b49\u7b49,\u7701\u53bb\u4e86\u63a8\u4e24\u4e2a\u77e9\u9635\u4e4b\u95f4\u5173\u7cfb\u7684\u65f6\u95f4\u3002\n\n```cpp\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define pb push_back\n\ninline int read() {\n\t\n\tint w = 1, s = 0; char c;\n\twhile(!isdigit(c = getchar())) if(c == '-') w = -1;\n\twhile(isdigit(c)) s = (s << 1) + (s << 3) + (c & 15), c = getchar();\n\treturn s * w;\n}\n\nvoid write(int x) {\n\t\n\tif(x < 0) x = -x, putchar('-');\n\tif(x > 9) write(x / 10);\n\tputchar(x % 10 + 48);\n}\n\ninline void writeln(int x) { write(x); putchar('\\n'); }\ninline void writel(int x) { write(x); putchar(' '); }\n\ninline int chkmax(int x, int y) { return x > y ? x : y; }\ninline int chkmin(int x, int y) { return x < y ? x : y; }\ninline void Swap(int &x, int &y) { x ^= y ^= x ^= y; }\n\nconst int N = 1e5 + 10;\nconst int p = 1e9 + 7;\n\nstruct Mat {\n\t\n\tint c[2][2];\n\n\tMat() { memset(c, 0, sizeof(c)); }\n};\n\nMat I;\n\ninline Mat operator * (Mat A, Mat B) {\n\t\n\tMat C;\n\tfor(int k = 0; k < 2; k ++ )\n\t\tfor(int i = 0; i < 2; i ++ )\n\t\t\tfor(int j = 0; j < 2; j ++ )\n\t\t\t\tC.c[i][j] = (C.c[i][j] + A.c[i][k] * B.c[k][j] % p) % p;\n\treturn C;\n}\n\nstruct Node { Mat ans0, ans1; int tag; } tr[N << 2];\n\n#define ls (x << 1)\n#define rs (x << 1 | 1)\n#define mid ((l + r) >> 1)\n\nchar str[N];\n\ninline void pushup(int x) {\n\n\ttr[x].ans0 = tr[ls].ans0 * tr[rs].ans0;\n\ttr[x].ans1 = tr[ls].ans1 * tr[rs].ans1;\n\treturn ;\n}\n\ninline Mat get(int a, int b, int c, int d) {\n\t\n\tMat ans;\n\tans.c[0][0] = a; ans.c[0][1] = b;\n\tans.c[1][0] = c; ans.c[1][1] = d;\n\treturn ans;\n}\n\nvoid build(int x, int l, int r) {\n\t\n\tif(l == r) {\n\t\ttr[x].ans0 = get(1, 0, 1, 1);\n\t\ttr[x].ans1 = get(1, 1, 0, 1);\n\t\tif(str[l] == 'B') swap(tr[x].ans0, tr[x].ans1);\n\t\treturn ;\n\t} build(ls, l, mid); build(rs, mid + 1, r);\n\tpushup(x); return ;\n}\n\ninline void pushdown(int x) {\n\t\n\tif(tr[x].tag) {\n\t\ttr[ls].tag ^= 1; tr[rs].tag ^= 1;\n\t\tswap(tr[ls].ans0, tr[ls].ans1);\n\t\tswap(tr[rs].ans0, tr[rs].ans1);\n\t\ttr[x].tag = 0;\n\t} return ;\n}\n\nvoid modify(int x, int nl, int nr, int l, int r) {\n\t\n\tif(nl <= l && r <= nr) {\n\t\tswap(tr[x].ans0, tr[x].ans1);\n\t\ttr[x].tag ^= 1;\n\t\treturn ;\n\t} pushdown(x);\n\tif(nl <= mid) modify(ls, nl, nr, l, mid);\n\tif(nr > mid) modify(rs, nl, nr, mid + 1, r);\n\tpushup(x); return ;\n}\n\nMat query(int x, int nl, int nr, int l, int r) {\n\t\n\tif(nl <= l && r <= nr) return tr[x].ans0;\n\tpushdown(x);\n\tMat ans = I;\n\tif(nl <= mid) ans = ans * query(ls, nl, nr, l, mid);\n\tif(nr > mid) ans = ans * query(rs, nl, nr, mid + 1, r);\n\treturn ans;\n}\n\nint n, q;\n\ninline void work() {\n\t\n\tI = get(1, 0, 0, 1);\n\tn = read(); q = read();\n\tscanf(\"%s\", str + 1);\n\tbuild(1, 1, n);\n\twhile(q -- ) {\n\t\tint op = read(), l = read(), r = read();\n\t\tif(op == 1) modify(1, l, r, 1, n);\n\t\telse {\n\t\t\tint a = read(), b = read();\n\t\t\tMat qwq = get(a, b, 0, 0), ans = query(1, l, r, 1, n);\n\t\t\tMat answ = qwq * ans;\n\t\t\twritel(answ.c[0][0]); writeln(answ.c[0][1]);\n\t\t}\n\t} return ;\n}\n\nsigned main() {\n\t\n\tint T = 1;\n\twhile(T -- ) work();\n\treturn 0;\n}\n```\n\n\u4e0b\u9762\u8fd9\u9053\u9898\u4e5f\u8fd0\u7528\u5230\u4e86\u76f8\u4f3c\u7684\u601d\u8def\u3002\n\n[CF1371F](https://www.luogu.com.cn/problem/CF1371F)",
        "postTime": 1668671408,
        "uid": 178519,
        "name": "tidongCrazy",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF1252K Addition Robot"
    },
    {
        "content": "\u5f88\u5bb9\u6613\u60f3\u5230\u7ebf\u6027\u53d8\u6362\uff0c\u7531\u4e8e\u77e9\u9635\u4e58\u6cd5\u6ee1\u8db3\u7ed3\u5408\u5f8b\uff0c\u6240\u4ee5\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u3002\n\n\u8003\u8651\u77e9\u9635\n\n$$\nA=\\left[\\begin{matrix}1 &1\\\\0&1\\end{matrix}\\right],\nB=\\left[\\begin{matrix}1 &0\\\\1&1\\end{matrix}\\right]\n$$\n\n\u56e0\u6b64\u4e00\u6b21\u53d8\u6362\u4e3a\n\n$$\n\\left[\\begin{matrix}a'\\\\ b'\\end{matrix} \\right]=M\\left[\\begin{matrix}a\\\\ b\\end{matrix} \\right],M\\isin\\{A,B\\}\n$$\n\n\u5bf9\u4e8e\u4e00\u6b21\u4fee\u6539\uff0c\u5c31\u662f\u628a\u533a\u95f4\u5185\u7684 $A,B$ \u4e92\u6362\uff0c\u7c7b\u6bd4\u7ebf\u6bb5\u6811\u533a\u95f4 0-1flip\uff0c\u6bcf\u4e2a\u533a\u95f4\u7ef4\u62a4\u4e24\u4e2a\u77e9\u9635\uff0c\u7ffb\u8f6c\u7684\u548c\u4e0d\u7ffb\u8f6c\u7684\u7d2f\u79ef\uff0c\u5728\u4e0b\u63a8\u7684\u65f6\u5019\u5c06\u5de6\u53f3\u513f\u5b50\u4e5f flip \u6389\uff1b\u67e5\u8be2\u7684\u8bdd\u5c31\u662f\u7528\u533a\u95f4\u77e9\u9635\u4e58\u79ef\u4e58\u4e0a\u521d\u59cb\u5411\u91cf\uff08\u56e0\u4e3a\u7ebf\u6027\u53d8\u6362\u4e2d\u77e9\u9635\u5199\u5728\u5411\u91cf\u5de6\u8fb9\uff0c\u6240\u4ee5\u6ce8\u610f\u7ef4\u62a4\u7684\u533a\u95f4\u7d2f\u79ef\u4e5f\u8981\u53cd\u8fc7\u6765\uff09\u3002\n\n\u867d\u7136\u8fd8\u6709 $A^{\\operatorname{T}}=B$ \u8fd9\u4e2a\u6027\u8d28\uff0c\u4f46\u662f\u8fd9\u4e2a\u505a\u6cd5\u5b8c\u5168\u7528\u4e0d\u4e0a\u4e86\uff08\u6240\u4ee5\u5047\u5982 $A$ \u548c $B$ \u6ca1\u6709\u4efb\u4f55\u7279\u6b8a\u6027\u8d28\u4e5f\u53ef\u4ee5\u505a\uff09\u3002\n\n[Code](https://www.luogu.com.cn/paste/4qjxzw4a)",
        "postTime": 1666583726,
        "uid": 134623,
        "name": "HyperSQ",
        "ccfLevel": 6,
        "title": "\u3010\u9898\u89e3\u3011CF1252K Addition Robot"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u7ef4\u62a4\u77e9\u9635\u7684\u6a21\u677f\u9898\uff0c\u7b2c\u4e00\u6b21\u9047\u5230\u8fd9\u6837\u7684\u9898\u6240\u4ee5\u8bb0\u5f55\u4e00\u4e0b\u3002\n\n\u8003\u8651\u8fd9\u4e2a $A=A+B,B=A+B$ \u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u77e9\u9635\u5904\u7406\u3002\n\n\u5982\u4e0b\u6784\u9020\u77e9\u9635\uff1a\n\n$$\n\\begin{bmatrix}\na \\ \\ b\n\\end{bmatrix}\n\\begin{bmatrix}\n1 \\ \\ 0\n\\\\\n1 \\ \\ 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na+b \\ \\ b\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\na \\ \\ b\n\\end{bmatrix}\n\\begin{bmatrix}\n1 \\ \\ 1\n\\\\\n0 \\ \\ 1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na \\ \\ a+b\n\\end{bmatrix}\n$$\n\n\u5bf9\u4e8e $A,B$ \u53cd\u8f6c\u7684\u64cd\u4f5c\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4ea4\u6362\u77e9\u9635\u4e2d\u7684\u5143\u7d20\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5bf9\u4e8e\u4e00\u6bb5\u533a\u95f4\u6240\u5bf9\u5e94\u7684\u77e9\u9635\n\n$$\n\\begin{bmatrix}\np \\ \\ q\n\\\\\nr \\ \\ s\n\\end{bmatrix}\n$$\n\n\u5c06\u8fd9\u6bb5\u533a\u95f4\u5185\u7684 $A,B$ \u53cd\u8f6c\u540e\uff0c\u5176\u5bf9\u5e94\u7684\u77e9\u9635\u4e3a\n\n$$\n\\begin{bmatrix}\ns \\ \\ r\n\\\\\nq \\ \\ p\n\\end{bmatrix}\n$$\n\n\u53ef\u4ee5\u4f7f\u7528\u6570\u5b66\u5f52\u7eb3\u6cd5\u5c1d\u8bd5\u8bc1\u660e\u8fd9\u4e00\u70b9\u3002\u8fd9\u91cc\u4e0d\u505a\u8bf4\u660e\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(2^3\\times Q \\log n)$\u3002\u5f3a\u8c03 $2^3$ \u662f\u4e3a\u4e86\u7a81\u51fa\u77e9\u9635\u4e58\u6cd5\u7684\u5e38\u6570\uff08\n\n\u8fd9\u9898\u8fd8\u662f\u7070\u7684\u554a\uff0c\u6211\u89c9\u5f97\u8bc4\u4e2a\u84dd\u7684\u633a\u597d\uff08\n\n```cpp\n/* stuff you should look for\n\t* int overflow, array bounds, uppercase/lowercase\n\t* special cases (n=1?)\n\t* do sth. instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n#include<cstdio>\n#include<algorithm>\nconst int mod=1e9+7;\nstruct matrix {\n\tmatrix() {a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;}\n\tinline void swap(int &x,int &y) {int tmp=x;x=y;y=tmp;}\n\tinline void reverse() {swap(a[0][0],a[1][1]); swap(a[1][0],a[0][1]);}\n\tint a[2][2];\n}A,B;\ninline matrix operator*(const matrix &x,const matrix &y) {\n\tmatrix res;\n\tfor(register int i=0;i<2;++i) {\n\t\tfor(register int j=0;j<2;++j) {\n\t\t\tfor(register int k=0;k<2;++k) {\n\t\t\t\t(res.a[i][j]+=x.a[i][k]*1ll*y.a[k][j]%mod)%=mod; \n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\nstruct SegmentTree {\n\t#define ls p<<1\n\t#define rs p<<1|1\n\tint n,tag[400005];\n\tmatrix mt[400005];\n\tinline void build(int p,int l,int r,char *s) {\n\t\ttag[p]=0;\n\t\tif(l==r) {\n\t\t\tmt[p]=(s[l]=='A'? A:B);\n\t\t\treturn;\n\t\t} \n\t\tint mid=l+r>>1;\n\t\tbuild(ls,l,mid,s); build(rs,mid+1,r,s);\n\t\tmt[p]=mt[ls]*mt[rs];\n\t}\n\tinline void init(int n,char *s) {this->n=n; build(1,1,n,s);}\n\tinline void spread(int p) {if(tag[p]) {mt[ls].reverse(); mt[rs].reverse(); tag[ls]^=1; tag[rs]^=1; tag[p]=0;}}\n\tinline void _modify(int p,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) {tag[p]^=1; mt[p].reverse(); return;}\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(L<=mid) _modify(ls,l,mid,L,R);\n\t\tif(R>mid) _modify(rs,mid+1,r,L,R);\n\t\tmt[p]=mt[ls]*mt[rs];\n\t}\n\tinline matrix _ask(int p,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) return mt[p];\n\t\tint mid=l+r>>1; spread(p);\n\t\tif(R<=mid) return _ask(ls,l,mid,L,R);\n\t\tif(L>mid) return _ask(rs,mid+1,r,L,R);\n\t\treturn _ask(ls,l,mid,L,mid)*_ask(rs,mid+1,r,mid+1,R);\n\t}\n\tinline void modify(int L,int R) {_modify(1,1,n,L,R);}\n\tinline std::pair<int,int> ask(int L,int R,int U,int V) {\n\t\tmatrix tmp; tmp.a[0][0]=U; tmp.a[0][1]=V;\n\t\tmatrix res=tmp*_ask(1,1,n,L,R); \n\t\treturn std::make_pair(res.a[0][0],res.a[0][1]);\n\t}\n}SGT;\nchar s[100005];\ninline int read() {\n\tregister int x=0,f=1;register char s=getchar();\n\twhile(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}\n\treturn x*f;\n}\nint main() {\n\tA.a[0][0]=1; A.a[0][1]=0;\n\tA.a[1][0]=1; A.a[1][1]=1;\n\tB.a[0][0]=1; B.a[0][1]=1;\n\tB.a[1][0]=0; B.a[1][1]=1;\n\tint n=read(),Q=read();\n\tscanf(\"%s\",s+1); SGT.init(n,s);\n\twhile(Q--) {\n\t\tint op=read(),l=read(),r=read();\n\t\tif(op==1) {\n\t\t\tSGT.modify(l,r);\n\t\t}\n\t\telse {\n\t\t\tint U=read(),V=read();\n\t\t\tstd::pair<int,int> res=SGT.ask(l,r,U,V);\n\t\t\tprintf(\"%d %d\\n\",res.first,res.second);\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1617367511,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF1252K\u3010Addition Robot\u3011"
    }
]