[
    {
        "content": "## Description\n\n\u6709$n$\u5802\u8bb2\u8bfe\uff0c$m$\u6b21\u7814\u8ba8\u4f1a\uff0c$x$\u4e2a\u9ad8\u6e05\u6295\u5f71\u4eea\u548c$y$\u4e2a\u666e\u901a\u6295\u5f71\u4eea\u3002\n\n\u6bcf\u5802\u8bb2\u8bfe\u5fc5\u987b\u4f7f\u7528\u4e00\u4e2a\u9ad8\u6e05\u6295\u5f71\u4eea\uff0c\u800c\u7814\u8ba8\u4f1a\u53ef\u4ee5\u4f7f\u7528\u666e\u901a\u6216\u9ad8\u6e05\u6295\u5f71\u4eea\u3002\n\n\u7b2c$i$\u5802\u8bb2\u8bfe\u65f6\u95f4\u5728$[a_i,b_i)$\uff0c\u7b2c$i$\u6b21\u7814\u8ba8\u4f1a\u5728\u65f6\u95f4\u5728$[p_i,q_i)$\uff0c\u4e00\u4e2a\u6295\u5f71\u4eea\u4e00\u6b21\u53ea\u80fd\u7528\u5728\u4e00\u4e2a\u5730\u65b9\uff0c\u4e14\u5728\u4f7f\u7528\u5b8c\u6bd5\u540e\u624d\u4f1a\u5f52\u8fd8\u3002\n\n\u6784\u9020\u4e3a\u6bcf\u8282\u8bb2\u8bfe/\u7814\u8ba8\u4f1a\u5206\u914d\u4e00\u4e2a\u6295\u5f71\u4eea\u7684\u65b9\u6848\u3002\n\n$n,m,x,y \\leq 300, a_i,b_i,p_i,q_i \\leq 10^6$\n\n## Solution\n\n\u8003\u8651\u5df2\u7ecf\u77e5\u9053\u4e86\u666e\u901a\u6295\u5f71\u4eea\u5982\u4f55\u5206\u914d\uff0c\u90a3\u4e48\u5b58\u5728\u5206\u914d\u9ad8\u6e05\u6295\u5f71\u4eea\u7684\u5408\u6cd5\u65b9\u6848\u7684\u5145\u8981\u6761\u4ef6\u662f\uff0c\u5bf9\u4e8e\u4efb\u610f\u6574\u6570$t$\uff0c\u65f6\u523b$t+0.5$\u6ee1\u8db3\u9700\u8981\u7528\u5230\u7684\u6295\u5f71\u4eea\u6570\u91cf\u4e0d\u8d85\u8fc7$x+y$\u3002\n\n\u90a3\u4e48\u8fd9\u610f\u5473\u7740\uff0c\u6211\u4eec\u53ea\u5173\u5fc3\u6bcf\u4e2a\u65f6\u523b\u5230\u5e95\u8981\u7528\u591a\u5c11\u6295\u5f71\u4eea\uff0c\u800c\u4e0d\u5173\u5fc3\u4ed6\u4eec\u5177\u4f53\u662f\u4ec0\u4e48\u3002\u8fd9\u542f\u53d1\u6211\u4eec\u60f3\u5230\u7f51\u7edc\u6d41\uff0c$1$\u5355\u4f4d\u6d41\u91cf\u4ee3\u8868\u666e\u901a\u6295\u5f71\u4eea\u5728\u6bcf\u4e2a\u65f6\u523b\u7684\u72b6\u6001\u3002\u8003\u8651\u6bcf\u4e2a\u65f6\u523b\u6700\u591a\u6709\u591a\u5c11\u666e\u901a\u6295\u5f71\u4eea\u662f\u7a7a\u95f2\u7684\uff0c\u663e\u7136\u662f$min(x,x+y-sum)$\uff0c\u5176\u4e2d$sum$\u662f\u8fd9\u4e2a\u65f6\u523b\u6240\u9700\u8981\u7684\u6295\u5f71\u4eea\uff0c\u5373\u6b64\u65f6\u81f3\u5c11\u6709$y-min(x,x+y-sum)$\u53f0\u6295\u5f71\u4eea\u88ab\u4f7f\u7528\u3002\n\n - \u5efa\u7acb\u4e00\u4e2a\u65f6\u95f4\u8f74\uff0c\u4e0a\u9762\u7684\u8282\u70b9\u4f9d\u6b21\u8868\u793a\u65f6\u523b$0,1,...,i,...$\u3002$i+0.5$\u5411$i+1.5$\u8fde\u6d41\u91cf\u4e3a$min(x,x+y-sum)$\u7684\u8fb9\uff0c\u5176\u4e2d$sum$\u662f\u65f6\u523b$i+0.5$\u6240\u9700\u8981\u7684\u6295\u5f71\u4eea\u3002\u65f6\u95f4\u8f74\u4e0a\u7684\u6d41\u91cf\u8868\u793a\u7a7a\u95f2\u3002\n - \u5bf9\u4e8e\u7814\u8ba8\u4f1a$i$\uff0c\u8fde\u8fb9$p_i\\to q_i$\uff0c\u6d41\u91cf\u4e3a$1$\u3002\u8868\u793a\u8fd9\u4e2a\u6295\u5f71\u4eea\u6b64\u65f6\u88ab\u6b21\u7814\u8ba8\u4f1a\u4f7f\u7528\u3002\n\n\u5b58\u5728\u5408\u6cd5\u89e3\u7684\u65b9\u6848\u5f53\u4e14\u4ec5\u5f53$0$\u5230$Inf$\u7684\u6d41\u91cf\u4e3a$y$\u3002\n\n\u5982\u4f55\u6784\u9020\u65b9\u6848\uff1f\u8003\u8651\u8dd1\u5b8c\u6700\u5927\u6d41\u540e\uff0c\u6bcf\u6b21\u4ece$t$\u5411$s$\u9000$1$\u6d41\u91cf\uff0c\u5982\u679c\u4e00\u6b21\u7814\u8ba8\u4f1a\u4f7f\u7528\u5f53\u524d\u7684\u6295\u5f71\u4eea\uff0c\u5f53\u524d\u4ec5\u5f53\u8fd9\u4e2a\u7814\u8ba8\u4f1a\u6240\u4ee3\u8868\u7684\u8fb9\u88ab\u8fd9\u4e2a\u6d41\u91cf\u7ecf\u8fc7\u3002\n\n\u5206\u914d\u9ad8\u6e05\u6295\u5f71\u4eea\u8d2a\u5fc3\u5373\u53ef\u3002\u603b\u65f6\u95f4\u590d\u6742\u5ea6$O(T(n+m)^2)$\n\n**tips:** \u9700\u8981\u628a\u65f6\u95f4\u79bb\u6563\u4fdd\u8bc1\u590d\u6742\u5ea6\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 605, Inf = 1 << 30;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nint n, m, A, B, x[maxn], y[maxn], *q[maxn << 1], ti;\nint vis[maxn], now[maxn], ans[maxn], sum[maxn << 1], Id[maxn];\nvector<int> vec[maxn << 1];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn * 5];\nint h[maxn << 1], cur[maxn << 1], dis[maxn << 1], tot;\n\ninline void add(int u, int v, int w)\n{\n\t//printf(\"%d %d %d\\n\", u, v, w);\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nbool bfs(int s, int t, int E)\n{\n\tstatic int u, l, r, q[maxn << 1];\n\tmemset(dis + 1, 0, sizeof(int) * ti);\n\tl = 0; q[r = 1] = s; dis[s] = 1;\n\twhile (l < r) {\n\t\tu = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif ((i & 1) != E && !dis[v] && e[i].cap) dis[v] = dis[u] + 1, q[++r] = v;\n\t}\n\treturn dis[t];\n}\n\nint dfs(int u, int t, int a, int E)\n{\n\tif (u == t || !a) return a;\n\tint flow = 0, f;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif ((i & 1) != E && dis[v] == dis[u] + 1 && (f = dfs(v, t, min(a, e[i].cap), E))) {\n\t\t\ta -= f; flow += f;\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint max_flow(int s, int t, int f, int E)\n{\n\tint res = 0;\n\twhile (bfs(s, t, E) && res < f) {\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * ti);\n\t\tres += dfs(s, t, f, E);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfreopen(\"arrange20.in\", \"r\", stdin);\n\tfreopen(\"B.out\", \"w\", stdout);\n\n\tint T = gi();\n\twhile (T--) {\n\t\tn = gi(); m = gi(); A = gi(); B = gi();\n\n\t\tint Min = -1e9, Max = 1e9 + 1;\n\t\tq[tot = 1] = &Min; q[++tot] = &Max;\n\t\tfor (int i = 1; i <= n; ++i) x[i] = gi(), y[i] = gi(), q[++tot] = x + i, q[++tot] = y + i;\n\t\tfor (int i = 1; i <= m; ++i) x[n + i] = gi(), y[n + i] = gi(), q[++tot] = x + n + i, q[++tot] = y + n + i;\n\t\tsort(q + 1, q + tot + 1, [](int *a, int *b) {return *a < *b;});\n\t\tti = 0;\n\t\tfor (int lst = -1, i = 1; i <= tot; ++i) {\n\t\t\tif (*q[i] == lst) *q[i] = ti;\n\t\t\telse lst = *q[i], *q[i] = ++ti;\n\t\t}\n\t\t\n\t\tmemset(sum + 1, 0, sizeof(int) * ti);\n\t\tfor (int i = 1; i <= n + m; ++i)\n\t\t\tfor (int j = x[i]; j < y[i]; ++j) ++sum[j];\n\t\t\n\t\ttot = 1; memset(h + 1, -1, sizeof(int) * ti);\n\t\tbool flg = 1;\n\t\tfor (int i = 1; i < ti; ++i) {\n\t\t\tif (A + B < sum[i]) {flg = 0; break;}\n\t\t\tadd(i, i + 1, min(B, A + B - sum[i]));\n\t\t}\n\t\tif (!flg) {puts(\"NO\"); continue;}\n\t\tfor (int i = n + 1; i <= n + m; ++i) add(x[i], y[i], 1), Id[i - n] = tot;\n\n\t\tif (max_flow(1, ti, Inf, -1) != B) puts(\"NO\");\n\t\telse {\n\t\t\tputs(\"YES\");\n\t\t\tmemset(vis + 1, 0, sizeof(int) * m);\n\t\t\tmemset(ans + 1, 0, sizeof(int) * (n + m));\n\t\t\tfor (int i = 1; i <= m; ++i) vis[i] = !e[Id[i]].cap;\n\t\t\tfor (int i = 1; i <= B; ++i) {\n\t\t\t\tmax_flow(ti, 1, 1, 0);\n\t\t\t\tfor (int j = 1; j <= m; ++j)\n\t\t\t\t\tif (!vis[j] && !e[Id[j]].cap) vis[j] = 1, ans[n + j] = A + i;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= ti; ++i) vec[i].clear();\n\t\t\tfor (int i = 1; i <= n + m; ++i) if (!ans[i]) vec[x[i]].push_back(i);\n\t\t\tmemset(now + 1, 0, sizeof(int) * A);\n\t\t\tfor (int i = 1; i <= ti; ++i)\n\t\t\t\tfor (int t : vec[i])\n\t\t\t\t\tfor (int j = 1; j <= A; ++j)\n\t\t\t\t\t\tif (y[now[j]] <= x[t]) {now[j] = t; ans[t] = j; break;}\n\t\t\tfor (int i = 1; i <= n; ++i) printf(\"%d \", ans[i]), assert(ans[i]);\n\t\t\tputs(\"\");\n\t\t\tfor (int i = 1; i <= m; ++i) printf(\"%d \", ans[n + i]), assert(ans[n + i]);\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n```",
        "postTime": 1576506052,
        "uid": 119899,
        "name": "dsidsi",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF1250K \u3010Projectors\u3011"
    },
    {
        "content": "\u5f88\u7ecf\u5178\u7684\u6700\u5927\u6d41\u5efa\u6a21\u9898\uff0c\u4f1a\u5efa\u6a21\u57fa\u672c\u4e0a\u5c31\u7ed3\u675f\u4e86\u3002\n\n# \u524d\u8a00\uff08\u5e9f\u8bdd\uff09\n\n- \u8fd9\u9898\u597d\u50cf\u8d2a\u5fc3\u53ef\u4ee5\u8fc7\uff08\u4e0d\u6e05\u695a\uff09\u3002\n- \u6709\u70b9\u5c0f\u5361\u5e38\u3002\n- \u4e3a\u4ec0\u4e48\u6d1b\u8c37\u7684 RemoteJudge \u6302\u4e86\u3002\n\n# Solution\n\n\u56e0\u4e3a\u4e24\u79cd\u8bfe\u90fd\u80fd\u7528\u9ad8\u6e05\u6295\u5f71\u4eea\uff0c\u6240\u4ee5\u5bf9\u4e8e\u9ad8\u6e05\u6295\u5f71\u4eea\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5224\u5176\u662f\u5426\u8db3\u591f\u4f9b\u7ed9\u6bcf\u4e2a\u65f6\u523b\u7684\u8bfe\uff0c\u7136\u540e\u5c31\u662f\u666e\u901a\u6295\u5f71\u4eea\u591f\u4e0d\u591f\u4ee5\u53ca\u662f\u5426\u5b58\u5728\u4e00\u79cd\u5408\u6cd5\u5b89\u6392\u3002\n\n\u6211\u4eec\u5c06\u65f6\u95f4\u8f74\u4e0a\u7684\u6d41\u91cf\u8bbe\u4e3a\u5269\u4f59\u7684\u666e\u901a\u6295\u5f71\u4eea\u7684\u6570\u91cf\uff0c\u7136\u540e\u5bf9\u6bcf\u4e2a\u7814\u8ba8\u8bfe\u7684\u8d77\u70b9\u7ec8\u70b9\u8fde\u8fb9\uff0c\u4e8e\u662f\u4e00\u4e2a\u5355\u4f4d\u7684\u6d41\u91cf\u5c31\u662f\u4e00\u53f0\u666e\u901a\u6295\u5f71\u4eea\uff0c\u5728\u65f6\u95f4\u8f74\u4e0a\u8bf4\u660e\u6ca1\u6709\u7528\uff0c\u5728\u7814\u8ba8\u8bfe\u7684\u8fb9\u4e0a\u8bf4\u660e\u8be5\u7814\u8ba8\u8bfe\u7528\u7684\u666e\u901a\u6295\u5f71\u4eea\u3002\u7531\u4e8e\u4e4b\u524d\u5df2\u7ecf\u5224\u65ad\u8fc7\u666e\u901a\u6295\u5f71\u4eea\u548c\u9ad8\u6e05\u6295\u5f71\u4eea\u7684\u6570\u91cf\u8db3\u591f\uff0c\u6240\u4ee5\u8fd9\u91cc\u4e0d\u7528\u62c5\u5fc3\u7814\u8ba8\u8bfe\u7684\u8fb9\u6d41\u4e0d\u5b8c\u7684\u60c5\u51b5\u3002\n\n\u6b64\u5904\u65f6\u95f4\u8f74\u4e0a\u7684\u8fb9\u6743\u5c31\u662f\u6700\u5927\u53ef\u80fd\u5269\u4f59\u7684\u666e\u901a\u6295\u5f71\u4eea\u6570\u3002\n\n\u4f46\u662f\u6ce8\u610f\uff1a\u6211\u4eec\u53ea\u5224\u65ad\u8fc7\u6bcf\u4e2a\u65f6\u95f4\u70b9\u4e0a\u662f\u5426\u8db3\u591f\uff0c\u4f46\u662f\u8fd9\u6837\u7684\u8d2a\u5fc3\u663e\u7136\u662f\u5047\u7684\uff0c\u53cd\u4f8b\u5c31\u662f\u5728\u521a\u597d\u5206\u914d\u5b8c\u7684\u60c5\u51b5\u4e0b\u7814\u8ba8\u4f1a\u7528\u7684\u666e\u901a\u6295\u5f71\u4eea\u662f\u65e0\u6cd5\u4e0e\u8bb2\u8bfe\u4ea4\u63a5\u7684\uff0c\u800c\u6211\u4eec\u4e4b\u524d\u53ea\u5224\u65ad\u4e86\u603b\u6570\u91cf\uff0c\u8fd9\u5c31\u5bfc\u81f4\u4e86\u8fd9\u4e2a\u7f51\u7edc\u7684\u6700\u5927\u6d41\u4e0d\u4e3a\u666e\u901a\u6295\u5f71\u4eea\u6570\uff0c\u8fd9\u6837\u4e5f\u662f\u6ca1\u6709\u5408\u6cd5\u5b89\u6392\u7684\u3002\n\n**Code**\n\n```cpp\n#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=20005,inf=0x7f7f7f7f;\nint tot,u,v,w,s,t,dis[N],cur[N],T,n,m,x,y,a[N],b[N],flag[N],top,stax[N],stay[N],topx,topy;\nint sumx[N],sumy[N],idx[N],pos[N];\nvector<int> vec1[N],vec2[N];\nstruct edge {\n\tint to,b,w;\n};vector<edge> G[N];\nvoid add(int u,int v,int w) {\n\tG[u].push_back((edge){v,G[v].size(),w});\n\tG[v].push_back((edge){u,G[u].size()-1,0});\n}\nbool bfs() {\n\tmemset(dis,0,sizeof(dis));\n\tfor(int i=1;i<=n;i++) cur[i]=0;\n\tdis[s]=1;\n\tqueue<int> qu;\n\tqu.push(s);\n\twhile(qu.size()) {\n\t\tint top=qu.front();qu.pop();\n\t\tfor(const auto &lxl:G[top]) {\n\t\t\tif(dis[lxl.to]==0&&lxl.w>0) {\n\t\t\t\tdis[lxl.to]=dis[top]+1;\n\t\t\t\tif(lxl.to==t) return 1;\n\t\t\t\tqu.push(lxl.to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=0;\n}\nint dfs(int p,int Max) {\n\tif(p==t) return Max;\n\tint tot=0;\n\tfor(int &i=cur[p];i!=G[p].size();i++) {\n\t\tif(dis[G[p][i].to]==dis[p]+1&&G[p][i].w>0) {\n\t\t\tint tmp=dfs(G[p][i].to,min(G[p][i].w,Max));\n\t\t\tif(tmp) {\n\t\t\t\ttot+=tmp;\n\t\t\t\tMax-=tmp;\n\t\t\t\tG[p][i].w-=tmp;\n\t\t\t\tG[G[p][i].to][G[p][i].b].w+=tmp;\n\t\t\t\tif(!Max) return tot;\n\t\t\t}else dis[G[p][i].to]=-1;\n\t\t}\n\t}\n\treturn tot;\n}\nvoid DINIC() {\n\twhile(bfs()) {\n\t\tmemset(cur,0,sizeof(cur));\n\t\ttot+=dfs(s,inf);\n\t}\n}\nsigned main() {\n\tcin >> T;\n\twhile(T--) {\n\t\tcin >> n >> m >> x >> y;\n\t\tfor(int i=1;i<=top;i++) vec1[i].clear(),vec2[i].clear();\n\t\ttop=0;\n\t\tfor(int i=1;i<=n+m+2;i++) G[i].clear();\n\t\tmemset(sumx,0,sizeof(sumx));\n\t\tmemset(sumy,0,sizeof(sumy));\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tflag[++top]=a[i];\n\t\t\tflag[++top]=b[i];\n\t\t}\n\t\tfor(int i=n+1;i<=n+m;i++) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\tflag[++top]=a[i];\n\t\t\tflag[++top]=b[i];\n\t\t}\n\t\tsort(flag+1,flag+top+1),top=unique(flag+1,flag+top+1)-flag-1;\n\t\tfor(int i=1;i<=n+m;i++) {\n\t\t\ta[i]=lower_bound(flag+1,flag+top+1,a[i])-flag;\n\t\t\tb[i]=lower_bound(flag+1,flag+top+1,b[i])-flag;\n\t\t\tif(i<=n) sumx[a[i]]++,sumx[b[i]]--;\n\t\t\telse sumy[a[i]]++,sumy[b[i]]--;\n\t\t\tvec1[a[i]].push_back(i);\n\t\t\tvec2[b[i]].push_back(i);\n\t\t}\n\t\tbool fffflag=0;\n\t\tfor(int i=1;i<=top;i++) {\n\t\t\tsumx[i]+=sumx[i-1],sumy[i]+=sumy[i-1];\n\t\t\tadd(i,i+1,min(y,x+y-sumx[i]-sumy[i]));\n\t\t\tif(sumx[i]>x||sumx[i]+sumy[i]>x+y) {\n\t\t\t\tputs(\"NO\");\n\t\t\t\tfffflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(fffflag) continue;\n\t\ts=top+1,t=s+1;\n\t\tadd(s,1,y),add(top,t,y);\n\t\tfor(int i=n+1;i<=n+m;i++) \n\t\t\tadd(a[i],b[i],1),idx[i]=G[a[i]].size()-1;\n\t\ttot=0;\n\t\tDINIC();\n\t\tif(tot!=y) {\n\t\t\tputs(\"NO\");\n\t\t\tcontinue;\n\t\t}\n\t\ttopx=topy=0;\n\t\tfor(int i=1;i<=x;i++) stax[++topx]=i;\n\t\tfor(int i=x+1;i<=x+y;i++) stay[++topy]=i;\n\t\tfor(int i=1;i<=top;i++) {\n\t\t\tfor(const auto &lxl:vec2[i]) {\n\t\t\t\tif(pos[lxl]<=x) stax[++topx]=pos[lxl];\n\t\t\t\telse stay[++topy]=pos[lxl];\n\t\t\t}\n\t\t\tfor(const auto &lxl:vec1[i]) {\n\t\t\t\tif(lxl<=n||G[a[lxl]][idx[lxl]].w) pos[lxl]=stax[topx--];\n\t\t\t\telse pos[lxl]=stay[topy--];\n\t\t\t}\n\t\t}\n\t\tputs(\"YES\");\n\t\tfor(int i=1;i<=n+m;i++) printf(\"%d \",pos[i]);\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n```",
        "postTime": 1671631750,
        "uid": 383791,
        "name": "Others",
        "ccfLevel": 7,
        "title": "CF1250K \u9898\u89e3"
    }
]