[
    {
        "content": "\n1. \u6807\u7b7e: \u4e3b\u5e2d\u6811, \u56fe\u8bba-\u6700\u77ed\u8def.  \n2. \u5927\u4f53\u8fc7\u7a0b\u548c\u666e\u901a\u7684\u6700\u77ed\u8def\u76f8\u5dee\u65e0\u51e0, \u4f46\u662f\u6700\u77ed\u8def\u8981\u6d89\u53ca\u5230\u5bf9\u6743\u503c\u7684\u4e24\u4e2a\u64cd\u4f5c:**\u6bd4\u8f83\u5927\u5c0f**\u548c**\u52a0\u6cd5**, \u8bbe\u8fd9\u4e24\u4e2a\u64cd\u4f5c\u7684\u590d\u6742\u5ea6\u5206\u522b\u4e3a$\\mathcal O(\\alpha)$\u548c$\\mathcal O(\\beta)$, \u5219\u7b97\u6cd5\u590d\u6742\u5ea6\u4e3a$\\mathcal O(\\alpha (n+m)\\log n+\\beta m)$, \u770b\u5f97\u51fa\u7528$10$\u8fdb\u5236\u9ad8\u7cbe\u5ea6\u6765\u7ef4\u62a4\u6743\u503c\u590d\u6742\u5ea6\u662f\u4e0d\u591f\u4f18\u79c0\u7684.  \n3. \u8fd9\u9053\u9898\u6709\u4e00\u4e2a\u663e\u7136\u8981\u88ab\u7528\u5230\u7684\u6027\u8d28:\u8fb9\u6743\u4e3a$2^x$, \u76f4\u63a5\u5c06\u6743\u503c(**\u8fd9\u91cc\u5305\u62ec\u8fb9\u6743\u548c\u70b9\u5230$s$\u8ddd\u79bb**)\u4e8c\u8fdb\u5236\u8868\u793a, \u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u5b57\u7b26\u4e32(\u9ad8\u4f4d\u4e0d\u8db3\u6dfb0). \u6bd4\u8f83\u6743\u503c\u5927\u5c0f, \u5b9e\u9645\u4e0a\u5c31\u662f\u6bd4\u8f83\u5b57\u7b26\u4e32\u7684\u5b57\u5178\u5e8f, \u8fd9\u4e2a\u53ef\u7528hash\u6c42LCP\u505a\u5230$\\mathcal O(\\log x)$, \u4f46\u52a0\u6cd5\u64cd\u4f5c\u8fd8\u662f$\\mathcal O(x)$\u7684.  \n4. \u53d1\u73b0\u52a0\u6cd5\u53ea\u6d89\u53ca\u5230\u67d0\u4e2a\u503c\u52a0\u4e0a\u4e00\u4e2a$2^x$(\u5373\u67d0\u4e2a\u70b9\u5230$s$\u7684**\u8ddd\u79bb**\u52a0\u4e0a\u67d0\u6761\u8fb9\u7684**\u8fb9\u6743**), \u5728\u4e8c\u8fdb\u5236\u4f4d\u4e0a\u7684\u4f53\u73b0\u5c31\u662f\u5c06\u67d0\u4e00\u6bb5$1$\u7f6e$0$\u518d\u5c06\u67d0\u4e2a$0$\u4fee\u6539\u4e3a$1$, \u8fd9\u4e2a\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u6765\u7ef4\u62a4, \u8003\u8651\u5230\u6211\u4eec\u4e0d\u80fd\u76f4\u63a5\u5728\u52a0\u6570\u4e0a\u4fee\u6539, \u6240\u4ee5\u6211\u4eec\u8981\u7528\u4e3b\u5e2d\u6811\u6765\u7ef4\u62a4, \u52a0\u6cd5\u64cd\u4f5c\u53d8\u4e3a\u533a\u95f4\u7f6e$0$\u548c\u5355\u70b9\u4fee\u6539\u4e3a$1$.   \n5. \u533a\u95f4\u7f6e$0$\u53ef\u4ee5\u901a\u8fc7\u5efa\u4e00\u68f5\u6ee1\u7684\u6240\u6709\u4f4d\u7f6e\u6743\u503c\u5747\u4e3a$0$\u7684\u7ebf\u6bb5\u6811, \u5c06\u9700\u8981\u7f6e$0$\u7684\u533a\u95f4\u8fde\u5230\u8fd9\u68f5\u6811\u4e0a\u6765\u5b9e\u73b0, \u8fd9\u91cc\u4e00\u6b21\u64cd\u4f5c\u65f6\u7a7a\u590d\u6742\u5ea6\u90fd\u662f$\\mathcal O(\\log x)$\u7684; \u6c42\u51fa\u9700\u8981\u7f6e$0$\u7684\u533a\u95f4\u65f6\u95f4\u4e0a\u53ef\u4ee5\u505a\u5230$\\mathcal O(\\log^2 x)$(\u4e8c\u5206\u533a\u95f4\u53e6\u4e00\u4e2a\u7aef\u70b9), \u6240\u4ee5\u52a0\u6cd5\u64cd\u4f5c\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u4f18\u5316\u5230\u4e86$\\mathcal O(\\log^2 x)$, \u603b\u7a7a\u95f4\u590d\u6742\u5ea6\u4e3a$\\mathcal O(m\\log x)$.  \n6. $n,m,x$\u540c\u7ea7\u6240\u4ee5\u590d\u6742\u5ea6\u4e3a$\\mathcal O(n\\log^2 n)$.\n\n```cpp\n#include <cstdio>\n#include <iostream>\n#define X 100040\n#define mod 1000000007\nusing namespace std;\n\nint n, m, s, t;\nint head[200005], nxt[400005], to[400005], cnt;\nint w[200005];\nunsigned long long base[200005], base1[200005];\n\nint read();\n\nvoid add(int f, int t, int wei) {\n    nxt[++cnt] = head[f], head[f] = cnt, to[cnt] = t;\n    w[cnt] = wei;\n    return;\n}\n\nint root[400005];\n\nstruct Seg {\n    int idcnt;\n    int ls[4000006], rs[4000006], tsum[4000006];\n    unsigned long long ths[4000006], ths1[4000006];\n\n    void update(int k) {\n        tsum[k] = tsum[ls[k]] + tsum[rs[k]];\n        ths[k] = (ths[ls[k]] + ths[rs[k]]) % mod;\n        ths1[k] = ths1[ls[k]] + ths1[rs[k]];\n        return;\n    }\n\n    int build(int l, int r, int v) {\n        int ret = ++idcnt;\n        if (l == r) {\n            tsum[ret] = v;\n            ths[ret] = base[l] * v, ths1[ret] = base1[l] * v;\n            return ret;\n        }\n        int mid = l + r >> 1;\n        ls[ret] = build(l, mid, v);\n        rs[ret] = build(mid + 1, r, v);\n        update(ret);\n        return ret;\n    }\n\n    int query(int l, int r, int k, int st, int en) {\n        if (st > r || en < l) return 0;\n        if (st <= l && en >= r) return tsum[k];\n        int mid = l + r >> 1;\n        return query(l, mid, ls[k], st, en) + query(mid + 1, r, rs[k], st, en);\n    }\n\n    int find(int l, int r, int k, int pos) {\n        if (l == r) return l;\n        int mid = l + r >> 1;\n        if (pos > mid) return find(mid + 1, r, rs[k], pos);\n        if (query(l, mid, ls[k], pos, mid) == mid - pos + 1)\n            return find(mid + 1, r, rs[k], mid + 1);\n        return find(l, mid, ls[k], pos);\n    }\n\n    int isrt(int l, int r, int k, int pos) {\n        int ret = ++idcnt;\n        ls[ret] = ls[k], rs[ret] = rs[k];\n        if (l == r) {\n            tsum[ret] = 1;\n            ths[ret] = base[l], ths1[ret] = base1[l];\n            return ret;\n        }\n        int mid = l + r >> 1;\n        if (pos <= mid)\n            ls[ret] = isrt(l, mid, ls[k], pos);\n        else\n            rs[ret] = isrt(mid + 1, r, rs[k], pos);\n        update(ret);\n        return ret;\n    }\n\n    int move(int l, int r, int k, int k1, int st, int en) {\n        if (st > r || en < l) return k;\n        if (st <= l && en >= r) return k1;\n        int ret = ++idcnt;\n        int mid = l + r >> 1;\n        ls[ret] = move(l, mid, ls[k], ls[k1], st, en);\n        rs[ret] = move(mid + 1, r, rs[k], rs[k1], st, en);\n        update(ret);\n        return ret;\n    }\n\n    int add(int rt, int w) {\n        int pos = find(0, X, rt, w);\n        int tmp = isrt(0, X, rt, pos);\n        if (pos == w) return tmp;\n        tmp = move(0, X, tmp, root[0], w, pos - 1);\n        return tmp;\n    }\n\n    bool sm(int k1, int k2) {\n        return tsum[k1] == tsum[k2] && ths[k1] == ths[k2] &&\n               ths1[k1] == ths1[k2];\n    }\n\n    bool cmp(int l, int r, int k1, int k2) {\n        if (l == r) return tsum[k1] <= tsum[k2];\n        int mid = l + r >> 1;\n        if (sm(rs[k1], rs[k2])) return cmp(l, mid, ls[k1], ls[k2]);\n        return cmp(mid + 1, r, rs[k1], rs[k2]);\n    }\n} seg;\n\nstruct heap {\n    int pu[400005], prt[400005];\n    int ch[400005][2], h[400005];\n    int idcnt, root, sz;\n\n    int merge(int x, int y) {\n        if (!x || !y) return x + y;\n        if (seg.cmp(0, X, prt[y], prt[x])) swap(x, y);\n        ch[x][1] = merge(ch[x][1], y);\n        if (h[ch[x][1]] > h[ch[x][0]]) swap(ch[x][0], ch[x][1]);\n        h[x] = h[ch[x][0]] + 1;\n        return x;\n    }\n\n    void push(int u, int rt) {\n        sz++;\n        pu[++idcnt] = u, prt[idcnt] = rt;\n        root = merge(idcnt, root);\n    }\n\n    void pop() { sz--, root = merge(ch[root][0], ch[root][1]); }\n\n    int top() { return pu[root]; }\n\n    bool empty() { return sz == 0; }\n} q;\n\nbool vis[200005];\nint pv[200005];\n\nint st[200005], top;\n\nvoid Dijkstra() {\n    int tmp = seg.build(0, X, 1);\n    for (int i = 1; i <= n; ++i) root[i] = tmp;\n    root[0] = root[s] = seg.build(0, X, 0);\n    q.push(s, root[s]);\n    while (!q.empty()) {\n        while (!q.empty() && vis[q.top()]) q.pop();\n        if (q.empty()) break;\n        int u = q.top();\n        vis[u] = 1;\n        q.pop();\n        for (int i = head[u]; i; i = nxt[i]) {\n            int v = to[i];\n            if (vis[v]) continue;\n            int trt = seg.add(root[u], w[i]);\n            if (seg.cmp(0, X, root[v], trt)) continue;\n            root[v] = trt, pv[v] = u;\n            q.push(v, root[v]);\n        }\n    }\n    if (root[t] == tmp) {\n        puts(\"-1\");\n    } else {\n        printf(\"%d\\n\", (int)seg.ths[root[t]]);\n        for (int u = t; u != s; u = pv[u]) {\n            st[++top] = u;\n        }\n        st[++top] = s;\n        printf(\"%d\\n\", top);\n        for (int i = top; i >= 1; --i) {\n            printf(\"%d \", st[i]);\n        }\n        puts(\"\");\n    }\n    return;\n}\n\nint main() {\n    n = read(), m = read();\n    base[0] = 1, base1[0] = 1;\n    for (int i = 1; i <= X; ++i)\n        base[i] = base[i - 1] * 2 % mod, base1[i] = base1[i - 1] * 17;\n    for (int i = 1; i <= m; ++i) {\n        int u = read(), v = read(), x = read();\n        add(u, v, x), add(v, u, x);\n    }\n    s = read(), t = read();\n    Dijkstra();\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = getchar();\n    while (isdigit(c)) x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n\n\n```\n",
        "postTime": 1554450927,
        "uid": 51237,
        "name": "Kinandra",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF464E \u3010The Classic Problem\u3011"
    },
    {
        "content": "\u6a21\u8fd0\u7b97\u4e0b\u7684\u6570\u503c\u96be\u4ee5\u6bd4\u8f83\u5927\u5c0f\uff0c\u4e14\u8fd9\u9053\u9898\u6d89\u53ca\u52a0\u6cd5\uff0c\u4e0d\u662f\u4e58\u6cd5\uff0c\u4e0d\u80fd\u4f7f\u7528\u5bf9\u6570\u653e\u7f29\uff0c\u53ea\u80fd\u7528\u9ad8\u7cbe\u5ea6\uff0c\u4f46\u76f4\u63a5\u4f7f\u7528\u5219\u65f6\u7a7a\u590d\u6742\u5ea6\u7206\u70b8\u3002\n\n#### \u8003\u8651\u4f18\u5316\u9ad8\u7cbe\u5ea6\n\n\u6ce8\u610f\u5230\u8fb9\u6743\u5168\u4e3a $2$ \u7684\u5e42\u6b21\uff0c\u8fd9\u63d0\u793a\u6211\u4eec\u7528\u4e8c\u8fdb\u5236\u8868\u793a\u6570\u503c\u3002\n\n\u8fd9\u91cc\u8bbe\u6570\u503c $val$ \u4e8c\u8fdb\u5236\u8868\u793a\u4e0b\u7b2c $i$ \u4f4d\u4e3a $val(i)$\uff0c\u6bcf\u6b21\u7ed9\u6570\u503c $val$ \u52a0 $2^x$ \u76f8\u5f53\u4e8e\u627e\u6700\u5c0f\u7684 $y$ \u4f7f\u5f97 $y>=x$ \u4e14 $val(y)=0$\uff0c\u7136\u540e\u8ba9 $x$ \u5230 $y$ \u4e4b\u95f4\u7684 $1$ \u5f52\u96f6\uff0c$val(y)$ \u7f6e\u4e3a $1$\u3002\n\n\u5f52\u96f6\u64cd\u4f5c\u76f8\u5f53\u4e8e\u533a\u95f4\u8986\u76d6\uff0c\u7f6e $1$ \u7684\u64cd\u4f5c\u76f8\u5f53\u4e8e\u5355\u70b9\u4fee\u6539\uff0c\u4e8e\u662f\u8003\u8651\u6bcf\u4e2a\u6570\u503c\u5747\u7528\u4e00\u9897\u6743\u503c\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5bfb\u627e $y$ \u5219\u53ef\u4ee5\u901a\u8fc7\u7ebf\u6bb5\u6811\u4e8c\u5206\u5b8c\u6210\uff0c\u4e09\u79cd\u64cd\u4f5c\u90fd\u53ef\u4ee5\u5355\u6b21 $O(\\log x)$ \u5b8c\u6210\u3002\n\n\u6bd4\u8f83\u7684\u8bdd\u5c31\u76f8\u5f53\u4e8e\u5b57\u5178\u5e8f\u6bd4\u8f83\uff0c\u5148\u627e\u5230\u4e24\u4e2a\u6570\u503c\u6700\u9ad8\u7684\u4e0d\u76f8\u540c\u7684\u4f4d\uff0c\u7136\u540e\u6bd4\u8f83\u90a3\u4e00\u4f4d\u7684\u5927\u5c0f\u5373\u53ef\uff0c\u8fd9\u4e00\u6b65\u5c31\u662f\u4e2a\u7ecf\u5178\u7684\u5b57\u7b26\u4e32\u7b97\u6cd5\uff0c\u7528 \u4e8c\u5206+ \u8fdb\u5236 $\\text{hash}$ \u5c31\u53ef\u4ee5\u4ee5\u5355\u6b21 $O(\\log x)$ \u5b8c\u6210\u3002\n\n\u8fdb\u5236 $hash$ \u6ee1\u8db3\u7ed3\u5408\u5f8b\u4e14\u53ef\u4ee5 $O(1)$ \u5feb\u901f\u5408\u5e76\u4e24\u4e2a\u5b50\u533a\u95f4\u7684\u8fdb\u5236 \uff0c\u4e8e$\\text{hash}$\u662f\u53ef\u4ee5\u5728\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a\u591a\u52a0\u4e00\u4e2a\u53d8\u91cf\u7ef4\u62a4\u6bcf\u4e2a\u8282\u70b9\u5bf9\u5e94\u533a\u95f4\u7684 $\\text{hash}$ \u503c\u3002 \n\n\u8fdb\u4e00\u6b65\u7684\uff0c\u56e0\u4e3a\u5728 $\\text{dijkstra}$ \u4e2d\u6d89\u53ca\u5230 $O(n+m)$ \u4e2a\u6570\u503c\uff0c\u5982\u679c\u6bcf\u4e2a\u6570\u503c\u90fd\u7528\u4e00\u9897\u6743\u503c\u7ebf\u6bb5\u6811\u5219\u70b8\u65f6\u7a7a\uff0c\u800c\u5355\u6b21\u7ed9\u6570\u503c\u52a0\u4e0a $2$ \u7684\u5e42\u6b21\u53ea\u4f1a\u5f71\u54cd\u6743\u503c\u7ebf\u6bb5\u6811\u4e0a $O(\\log x)$ \u4e2a\u8282\u70b9\uff0c\u663e\u7136\u53ef\u4ee5\u7528\u53ef\u6301\u4e45\u5316\u4f18\u5316\u65f6\u7a7a\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(m\\log m \\log x)$ \u3002\n\n\u601d\u8def\u8fd8\u662f\u5f88\u597d\u60f3\u7684\uff0c\u662f\u9053\u5047\u9ed1\u9898\u3002\n\n#### \u5177\u4f53\u5b9e\u73b0\n\n\u76f4\u63a5\u7528 $2$ \u4f5c\u4e3a\u8fdb\u5236 $\\text{hash}$ \u7684\u8fdb\u5236\uff0c$1000000007$ \u4f5c\u4e3a\u6a21\u6570\uff0c\u8fd9\u6837\u5728\u8f93\u51fa\u7b54\u6848\u65f6\u76f4\u63a5\u8f93\u51fa $\\text{hash}$ \u503c\u5c31\u884c\u4e86\u3002\n\n\u521d\u6b65\u5224\u8bfb\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u8282\u70b9\u9700\u8981\u4fdd\u5b58\u5de6\u513f\u5b50\u6307\u9488\uff0c\u53f3\u513f\u5b50\u6307\u9488\uff0c$\\text{hash}$ \u503c\uff0c\u533a\u95f4\u8986\u76d6\u61d2\u6807\u8bb0\uff0c\u533a\u95f4\u5185\u662f\u5426\u5168\u4e3a $1$ \u6807\u8bb0\u3002\n\n\u4e00\u822c\u6765\u8bf4\u652f\u6301\u533a\u95f4\u8986\u76d6\u64cd\u4f5c\u9700\u8981\u5e26\u4e0a\u61d2\u6807\u8bb0\uff0c\u4f46\u8fd9\u9898\u662f\u533a\u95f4\u5f52\u96f6\u64cd\u4f5c\uff0c\u4e14\u7528\u7684\u662f\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff0c\u5b8c\u5168\u6ca1\u5fc5\u8981\u5e26\u8fd9\u4e00\u61d2\u6807\u8bb0\uff0c\u56e0\u4e3a\u533a\u95f4\u5f52\u96f6\u64cd\u4f5c\u5c31\u76f8\u5f53\u4e8e\u8ba9\u8282\u70b9\u53d8\u6210 $none$\uff0c\u6240\u4ee5\u53ef\u4ee5\u7701\u53bb\u533a\u95f4\u8986\u76d6\u7684\u61d2\u6807\u8bb0\u3002\n\n\u5355\u70b9\u4fee\u6539\u4e5f\u5f88\u5957\u8def\u3002\n\n\u5bfb\u627e $y$ \u8fd9\u4e00\u6b65\u7528\u7ebf\u6811\u4e8c\u5206\u65f6\u9700\u8981\u5feb\u901f\u5224\u65ad\u67d0\u4e00\u8282\u70b9\u6240\u5bf9\u5e94\u7684\u533a\u95f4\u662f\u5426\u5168\u4e3a $1$\uff0c\u8003\u8651\u5230\u6211\u4eec\u90fd\u5df2\u7ecf\u7ef4\u62a4\u4e86\u533a\u95f4\u7684  \u503c$\\text{hash}$\u4e86\uff0c\u4f55\u4e0d\u597d\u597d\u5229\u7528\u5b83\uff0c\u6ca1\u5fc5\u8981\u518d\u591a\u52a0\u4e00\u4e2a\u5224\u65ad\u533a\u95f4\u5185\u662f\u5426\u4e3a\u5168 $1$ \u7684\u6807\u8bb0\u4e86\uff0c\u9884\u5904\u7406\u51fa\u6bcf\u4e2a\u957f\u5ea6\u7684\u5168 $1$ \u7684\u533a\u95f4\u5bf9\u5e94\u7684 $\\text{hash}$ \u503c\uff0c\u6bcf\u6b21\u5224\u65ad\u67d0\u4e2a\u533a\u95f4\u662f\u5426\u5168\u4e3a $1$ \u76f4\u63a5\u6bd4\u8f83 $\\text{hash}$ \u503c\u5c31\u884c\u4e86\u3002\n\n\u6bd4\u8f83\u64cd\u4f5c\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5c31\u884c\u4e86\u3002\n\n\u603b\u7ed3\u4e00\u4e0b\uff0c\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e2a\u8282\u70b9\u53ea\u9700\u4fdd\u5b58\u5de6\u513f\u5b50\u6307\u9488\uff0c\u53f3\u513f\u5b50\u6307\u9488\u548c $\\text{hash}$ \u503c\u3002\n\n\u5728 $\\text{dijkstra}$ \u65f6\uff0c\u7528 $dis(u)$ \u6765\u4ee3\u8868\u8282\u70b9 $u$ \u5230\u6e90\u70b9\u7684\u6700\u77ed\u8def\u957f\u5ea6\u6570\u503c\uff08\u5b9e\u9645\u4e0a\u5b58\u7684\u662f\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u6839\u8282\u70b9\uff09\uff0c\u679a\u4e3e\u8fb9\u65f6\u4e5f\u4f1a\u751f\u6210\u4e00\u4e2a\u4e34\u65f6\u6570\u503c $tmp = dis(u)+2^{x_{(u,v)}}$ \uff08\u4e5f\u662f\u4e00\u9897\u6743\u503c\u7ebf\u6bb5\u6811\uff09\u3002\n\n\u5f53 $tmp$ \u4e0e $dis(v)$ \u6bd4\u8f83\u5b8c\u540e\uff0c\u5176\u4e2d\u4e00\u4e2a\u6570\u503c\u5c31\u5e9f\u5f03\u4e86\uff0c\u56e0\u4e3a\u76ee\u524d\u80af\u5b9a\u6ca1\u6709\u4efb\u4f55\u6570\u503c\u662f\u901a\u8fc7 $tmp$ \u6216 $dis(v)$\u751f\u6210\u7684\uff0c\u751f\u6210\u90a3\u4e2a\u5e9f\u5f03\u6570\u503c\u6240\u65b0\u7528\u7684\u8282\u70b9\u90fd\u56de\u6536\u540e\u4e0d\u4f1a\u5f71\u54cd\u5230\u5176\u5b83\u6570\u503c\uff0c\u53ef\u4ee5\u56de\u6536\u518d\u5229\u7528\uff0c\u8003\u8651\u5982\u4f55\u56de\u6536\u8fd9\u4e9b\u8282\u70b9\u3002\n\n\u4e00\u5f00\u59cb\u6211\u8003\u8651\u7684\u662f\u4e3a $tmp$ \u548c\u6bcf\u4e2a $dis(*)$ \u5404\u5f00\u4e00\u4e2a ```vector``` \u4fdd\u5b58\u751f\u6210\u5b83\u6240\u65b0\u7528\u7684\u8282\u70b9\uff0c\u7136\u540e\u5728\u5b83\u5e9f\u5f03\u65f6\u518d\u5c06\u5bf9\u5e94 ```vector``` \u4e2d\u6240\u6709\u8282\u70b9\u56de\u6536\u3002\n\n\u7136\u540e $\\text{RE}$ \u4e86\uff0c```debug``` \u540e\u53d1\u73b0\u539f\u56e0\u5728\u4e8e\u82e5\u5e9f\u5f03\u7684\u6570\u503c\u662f $dis(v)$\uff0c\u5c3d\u7ba1\u6211\u56de\u6536\u4e86 $dis(v)$\uff0c\u4f46\u4f18\u5148\u961f\u5217\u4e2d\u4ecd\u5b58\u5728 $(v,dis(v))$ \u4e8c\u5143\u7ec4\uff0c\u4f46\u5173\u4e8e\u90a3\u4e2a\u88ab\u5e9f\u5f03\u7684\u6570\u503c\u7684\u6240\u6709\u6bd4\u8f83\u5df2\u7ecf\u5931\u6548\uff0c\u4e8e\u662f\u8fd9\u57fa\u4e8e\u6bd4\u8f83\u5b9e\u73b0\u7684 ```STL``` \u5c31\u5bfc\u81f4 $\\text{RE}$ \u4e86\u3002\n\n\u89e3\u51b3\u529e\u6cd5\u6709\u4e24\u4e2a\uff0c\u4e00\u662f\u653e\u5f03\u56de\u6536\u8282\u70b9\u7684\u60f3\u6cd5\uff0c\u4e8c\u662f\u7528 ```set``` \u4ee3\u66ff\u4f18\u5148\u961f\u5217\uff0c\u7136\u540e\u6bcf\u6b21\u5e9f\u5f03 $dis(v)$ \u524d\u5148\u4ece ```set``` \u91cc\u5220\u6389\u5bf9\u5e94\u7684\u4e8c\u5143\u7ec4 $(v,dis(v))$\u3002\n\n\u65e2\u7136\u90fd\u6253\u7b97\u56de\u6536\u8282\u70b9\u4e86\uff0c\u90a3\u5c31\u9009\u65b9\u6cd5\u4e8c\u5427\uff0c\u53cd\u6b63\u590d\u6742\u5ea6\u4ecd\u4e0d\u53d8\u3002\n\n\u7ecf\u8fc7\u4e00\u756a\u4ed4\u7ec6\u5206\u6790\u540e\uff0c\u53d1\u73b0\u81ea\u5df1\u8111\u6b8b\u4e86\uff0c\u5373\u4fbf\u56de\u6536\u4e86\u8282\u70b9\u7a7a\u95f4\u590d\u6742\u5ea6\u4e5f\u6ca1\u600e\u4e48\u964d\uff0c\u53ea\u4e0d\u8fc7\u662f\u4ece $O(m\\log x)$ \u53d8\u4e3a\u4e86 $O(n \\log x)$\uff0c\u4f46 $m$ \u4e0e $n$ \u540c\u9636\uff0c\u76f8\u5f53\u4e8e\u767d\u5fd9\u6d3b\u4e86\uff0c\u53ea\u6536\u83b7\u4e86\u4e00\u4e2a $\\text{RE}$ \u6280\u5de7\u3002\n\n```cpp\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <iostream>\n#include <assert.h>\n#include <vector>\n#include <set>\nusing namespace std;\n\n#define re register\n#define sf scanf\n#define pf printf\n#define nl() putchar('\\n')\n#define ms(x, val) memset(x, val, sizeof(x))\n#define ll long long\n#define _for(i, a, b) for(re int (i) = (a); (i) < (b); ++(i))\n#define _rfor(i, a, b) for(re int (i) = (a); (i) <= (b); ++(i))\n#define _fev(p, u) for(re int (p) = head[(u)]; (p); (p) = nex[(p)])\n#define inf 0x7fffffff\n#define maxn 101005\n#define maxnn 3100005\n#define mod 1000000007ll\n\nint rdnt(){\n\tre int x = 0, sign = 1;\n\tre char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') sign = -1; c = getchar(); }\n\twhile (c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (c ^ 48), c = getchar();\n\treturn x * sign;\n}\n\nbool vis[maxn]; //dijkstra \u7528\u7684 \nint\t\n\t//\u6a21 1000000007 \u610f\u4e49\u4e0b 2 \u7684\u5e42\u6b21 \n\tepw[maxn],\n\t\n\t//\u6a21 1000000007 \u610f\u4e49\u4e0b\u5168 1 \u533a\u95f4\u7684 hash \u503c \n\thsh_one[maxn], \n\n\t//\u6743\u503c\u7ebf\u6bb5\u503c\u57df \n\trg = maxn-5, \n\n\t//\u5185\u5b58\u6c60\uff0c\u7528\u4e8e\u56de\u6536\u8282\u70b9 \n\tpcnt = 0, \n\tpool[maxnn], \n\t\n\t//\u90bb\u63a5\u8868 \n\tecnt = 1, \n\thead[maxn],\n\tto[maxn*2], \n\tnex[maxn*2],\n\twe[maxn*2],\n\t\n\t//\u5355\u5143\u6700\u77ed\u8def\u6570\u7ec4\uff08\u5b9e\u9645\u4e0a\u5b58\u7684\u662f\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u6839\u8282\u70b9\u7f16\u53f7\uff09 \n\tdis[maxn],\n\t\n\t//\u8f93\u51fa\u8def\u5f84\u65b9\u6848\u7528\u7684 \n\ttop = 0,\n\tpath[maxn], //path(v) \u4ee3\u8868 v \u662f\u4ece\u54ea\u8f6c\u79fb\u8fc7\u6765\u7684 \n\tstk[maxn];\nvector<int>\n\ttmp_set, //\u7528\u6765\u88c5\u751f\u6210\u4e34\u65f6\u6570\u503c\u6240\u65b0\u7528\u7684\u7ebf\u6bb5\u6811\u8282\u70b9 \n\tseg_set[maxn]; //\u7528\u6765\u88c5\u751f\u6210 dis(v) \u6240\u65b0\u7528\u7684\u7ebf\u6bb5\u6811\u8282\u70b9 \nstruct Seg{ int lc, rc, hsh; } seg[maxnn]; //\u7ebf\u6bb5\u6811\u8282\u70b9\uff0c\u5206\u522b\u4ee3\u8868\u5de6\u3001\u53f3\u513f\u5b50\u6307\u9488\u548c hash \u503c \n#define lc(x) seg[x].lc\n#define rc(x) seg[x].rc\n#define hsh(x) seg[x].hsh\nstruct Par{ int u, d; };\nbool cmp(int x, int y, int tl, int tr);\ninline bool operator<(const Par &p1, const Par &p2){\n\t//\u56e0\u4e3a\u5220\u9664\u4e8c\u5143\u7ec4\u65f6\u8981\u7cbe\u786e\u67e5\u627e\u4e8c\u5143\u7ec4\uff0c\u6240\u4ee5\u65e0\u5411\u56fe\u8282\u70b9\u7684\u7f16\u53f7\u4e5f\u8981\u7eb3\u5165\u6bd4\u8f83\u8303\u56f4 \n\treturn (hsh(p1.d) != hsh(p2.d)) ? cmp(p1.d, p2.d, 1, rg) : p1.u < p2.u; \n}\nset<Par> pq; //set \u7248\u4f18\u5148\u961f\u5217 \n\nvoid add_edge(re int u, re int v, re int w){\n\tto[++ecnt] = v; nex[ecnt] = head[u]; head[u] = ecnt; we[ecnt] = w;\n\tto[++ecnt] = u; nex[ecnt] = head[v]; head[v] = ecnt; we[ecnt] = w;\n}\n\n//\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\u7ebf\u6bb5\u6811\u8282\u70b9\u5e76\u4ece nn \u62f7\u8d1d \nint new_node(re int nn){\n\tre int x = pool[pcnt--];\n\tseg[x] = seg[nn];\n\treturn x;\n}\n\n//\u56de\u6536\u5355\u4e2a\u7ebf\u6bb5\u6811\u8282\u70b9 \nvoid del(re int x){\n\tpool[++pcnt] = x;\n}\n\n//\u56de\u6536 vector \u91cc\u7684\u7ebf\u6bb5\u6811\u8282\u70b9 \nvoid clr(vector<int> &vec){\n\t_for(i, 0, vec.size()) del(vec[i]);\n\tvec.clear();\n}\n\n//\u7ebf\u6bb5\u6811 push up \nvoid ud(re int x, re int len){\n\thsh(x) = (hsh(lc(x)) + (ll)hsh(rc(x))*epw[len]%mod)%mod;\n}\n\n//\u6bd4\u8f83\u4e24\u4e2a\u6570\u503c\uff0c\u5373\u5224\u65ad x < y \nbool cmp(int x, int y, int tl, int tr){\n\tif (tl == tr) return hsh(x) < hsh(y);\n\tint mi = (tl+tr)>>1;\n\treturn (hsh(rc(x)) == hsh(rc(y))) ? cmp(lc(x), lc(y), tl, mi) : cmp(rc(x), rc(y), mi+1, tr);\n}\n\n//\u7ebf\u6bb5\u6811\u4e8c\u5206\u627e\u5230\u533a\u95f4 [l,r] \u5185\u7b2c\u4e00\u4e2a\u4e0d\u4e3a 0 \u7684\u4f4d\u7f6e \nint qry(int x, int l, int r, int tl, int tr){\n\tif (tl > r || tr < l || hsh(x) == hsh_one[tr-tl+1]) return -1;\n\tif (hsh(x) == 0) return max(l, tl);\n\tint mi = (tl+tr)>>1, tmp = qry(lc(x), l, r, tl, mi);\n\treturn (tmp > 0) ? tmp : qry(rc(x), l, r, mi+1, tr);\n}\n\n//\u533a\u95f4\u5f52\u96f6\u64cd\u4f5c\uff0c\u5e76\u5c06\u65b0\u7528\u7684\u8282\u70b9\u52a0\u5165\u5230 vec \u91cc\nvoid cover(int x, int &y, int l, int r, int tl, int tr, vector<int> &vec){\n\tif (l == tl && r == tr){ y = 0; return; }\n\tvec.push_back(y = new_node(x));\n\tint mi = (tl+tr)>>1;\n\tif (r <= mi) cover(lc(x), lc(y), l, r, tl, mi, vec);\n\telse if (l > mi) cover(rc(x), rc(y), l, r, mi+1, tr, vec);\n\telse cover(lc(x), lc(y), l, mi, tl, mi, vec), cover(rc(x), rc(y), mi+1, r, mi+1, tr, vec);\n\tud(y, mi-tl+1);\n}\n\n//\u5355\u70b9\u4fee\u6539\uff0c\u5e76\u5c06\u65b0\u7528\u7684\u8282\u70b9\u52a0\u5165\u5230 vec \u91cc\nvoid addn(int x, int &y, int p, int tl, int tr, vector<int> &vec){\n\tif (tl == tr){\n\t\tvec.push_back(y = new_node(0));\n\t\thsh(y) = 1;\n\t\treturn;\n\t}\n\tvec.push_back(y = new_node(x));\n\tint mi = (tl+tr)>>1;\n\tif (p <= mi) addn(lc(x), lc(y), p, tl, mi, vec);\n\telse addn(rc(x), rc(y), p, mi+1, tr, vec);\n\tud(y, mi-tl+1);\n}\n\n//\u6570\u503c x \u4e0a\u52a0\u5165 2^(w-1)\uff0c\u53ea\u6240\u4ee5 w-1 \u662f\u4e3a\u4e86\u8ba9\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u503c\u57df\u5927\u4e8e\u7b49\u4e8e 1 \n//\u8fd4\u56de\u751f\u6210\u7684\u6570\u503c\u5bf9\u5e94\u7684\u6743\u503c\u7ebf\u6bb5\u6811\u7684\u6839\u8282\u70b9 \nint add(re int x, re int w, vector<int> &vec){\n\tvec.clear();\n\tre int p = qry(x, w, rg, 1, rg), tmp = 0;\n\taddn(x, tmp, p, 1, rg, vec);\n\tif (p > w) cover(tmp, tmp, w, p-1, 1, rg, vec);\n\treturn tmp;\n}\n\nvoid dijkstra(re int n, re int s){\n\tre int u, v, d, tmp;\n\t_rfor(i, 1, n) dis[i] = -1;\n\tdis[s] = 0;\n\tpq.insert((Par){s, dis[s]});\n\twhile(!pq.empty()){\n\t\tauto it = pq.begin();\n\t\tu = it->u; d = it->d; pq.erase(it);\n\t\tif (vis[u]) continue;\n\t\tvis[u] = true;\n\t\t_fev(p, u){\n\t\t\tif (vis[v = to[p]]) continue;\n\t\t\ttmp = add(d, we[p], tmp_set);\n\t\t\tif (dis[v] == -1 || cmp(tmp, dis[v], 1, rg)){\n\t\t\t\tif (dis[v] != -1){\n\t\t\t\t\t//\u4ece set \u91cc\u7cbe\u786e\u5220\u9664 \n\t\t\t\t\tit = pq.find((Par){v, dis[v]});\n\t\t\t\t\tpq.erase(it);\n\t\t\t\t}\n\t\t\t\tpath[v] = u;\n\t\t\t\tdis[v] = tmp;\n\t\t\t\t//\u4ea4\u6362 vector \n\t\t\t\tswap(tmp_set, seg_set[v]);\n\t\t\t\tpq.insert((Par){v, dis[v]});\n\t\t\t}\n\t\t\t//\u56de\u6536\u8282\u70b9 \n\t\t\tclr(tmp_set);\n\t\t}\n\t}\n}\n\n//\u6c42\u51fa\u8def\u5f84\u65b9\u6848 \nvoid dfs(int s, int u){\n\tstk[top++] = u;\n\tif (u != s) dfs(s, path[u]);\n}\n\nint main(){\n\t#ifndef ONLINE_JUDGE\n\tfreopen(\"sample.in\", \"r\", stdin);\n\tfreopen(\"sample.out\", \"w\", stdout);\n\t#endif\n\t\n\t//\u9884\u5904\u7406 \n\thsh_one[0] = lc(0) = rc(0) = hsh(0) = 0; epw[0] = 1;\n\t_for(i, 1, maxnn) pool[++pcnt] = maxnn-i;\n\t_for(i, 1, maxn) epw[i] = (ll)epw[i-1]*2%mod, hsh_one[i] = (epw[i]+mod-1)%mod;\n\t\n\tre int n = rdnt(), m = rdnt(), s, t, u, v, w;\n\t_rfor(i, 1, m){\n\t\tu = rdnt(), v = rdnt(), w = rdnt();\n\t\tadd_edge(u, v, w+1);\n\t}\n\ts = rdnt(); t = rdnt();\n\tdijkstra(n, s);\n\n\tif (dis[t] == -1){ pf(\"-1\\n\"); return 0; }\n\tre int ans = hsh(dis[t]); top = 0;\n\tpf(\"%d\\n\", ans);\n\tdfs(s, t);\n\tpf(\"%d\\n\", top);\n\twhile(top){\n\t\tpf(\"%d\", stk[--top]);\n\t\tif (top)putchar(' ');\n\t}\n\tnl();\n\t\n\treturn 0;\n}\n\n```\n\n",
        "postTime": 1635511479,
        "uid": 474113,
        "name": "MoYuFang",
        "ccfLevel": 7,
        "title": "\u3010CF464E The Classic Problem\u3011\u9898\u89e3"
    },
    {
        "content": "## CF464E The Classic Problem \u9898\u89e3\n\n### \u603b\u4f53\u60c5\u51b5\n\n\u5927\u4f53\u4ecd\u662f\u4e3b\u5e2d\u6811+\u54c8\u5e0c\uff0c\u4f46\u5728\u8fdb\u4f4d\u5904\u7406\u65b9\u9762\u91c7\u7528\u4e86\u538b\u4f4d\u4f18\u5316\uff0c\u76ee\u524d\u5168\u8c37\u6700\u4f18\u89e3\uff082021.10.15\uff09\u3002\n\n### \u9898\u610f\u8fd9\u91cc\u4e0d\u518d\u8d58\u8ff0\n\n[CF464E The Classic Problem](https://www.luogu.com.cn/problem/CF464E)\n\n### \u6734\u7d20\u601d\u8def\n\n\u9996\u5148\u6700\u77ed\u8def\u53ef\u4ee5\u60f3\u5230 Dijkstra\u3002\n\n\u6211\u4eec\u9700\u8981\u652f\u6301\u4e24\u4e2a\u6570\u6bd4\u8f83\u5927\u5c0f\u548c\u52a0\u6cd5\u64cd\u4f5c\uff0c\u4f46\u95ee\u9898\u662f\u8fb9\u6743\u8303\u56f4\u592a\u5927\u65e0\u6cd5\u76f4\u63a5\u50a8\u5b58\uff0c\u5982\u679c\u7528\u9ad8\u7cbe\u5ea6\u7684\u8bdd\u65f6\u95f4\u590d\u6742\u5ea6\u53c8\u4f1a\u591a\u4e00\u4e2a $x$\uff0c\u96be\u4ee5\u627f\u53d7\u3002\n\n### \u8003\u8651\u4f18\u5316\n\n\u53d1\u73b0\u6bcf\u6b21\u66f4\u65b0\u957f\u5ea6\u65f6\uff0c\u5982\u4e00\u6761 $u\\to v$ \u7684\u8def\u5f84\uff0c\u53ef\u80fd\u4f1a\u4f7f $dis_v$ \u6210\u4e3a $dis_u$ \u52a0\u4e0a $2$ \u7684\u6b21\u5e42\uff0c\u5982\u679c\u5728\u4e8c\u8fdb\u5236\u4e0b\u7684\u8bdd\u53ef\u4ee5\u53d1\u73b0\u4e0d\u8003\u8651\u8fdb\u4f4d\u90a3\u4e48\u53d1\u751f\u53d8\u5316\u7684\u53ea\u6709\u4e00\u4f4d\u3002\u8fd9\u4e2a\u6027\u8d28\u53ef\u4ee5\u8ba9\u6211\u4eec\u60f3\u5230\u7528\u4e8c\u8fdb\u5236\u7684\u4e3b\u5e2d\u6811\u6765\u7ef4\u62a4 $dis$\u3002\n\n### \u6bd4\u8f83\u5927\u5c0f\n\n\u6bd4\u8f83\u5e38\u89c1\u7684\u95ee\u9898\uff0c\u6734\u7d20\u5730\u505a\u5373\u627e\u5230\u4e24\u4e2a\u6570\u4ece\u9ad8\u5230\u4f4e\u7b2c\u4e00\u4e2a\u4e0d\u4e00\u6837\u7684\u4f4d\u7f6e\u5e76\u4e14\u6bd4\u8f83\u5927\u5c0f\uff0c\u8fd9\u4e00\u6b65\u64cd\u4f5c\u53ef\u4ee5\u7528\u54c8\u5e0c\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u6765\u5b9e\u73b0\u3002\n\n### \u52a0\u6cd5\n\n\u521a\u624d\u6211\u4eec\u5206\u6790\u201c\u53ea\u6709\u4e00\u4f4d\u4ea7\u751f\u53d8\u5316\u201d\u524d\u63d0\u662f\u4e0d\u4ea7\u751f\u8fdb\u4f4d\u3002\u5bf9\u4e8e\u8fdb\u4f4d\uff0c\u6709\u4e00\u79cd\u505a\u6cd5\u5373\u627e\u5230\u5f53\u524d\u4f4d\u7f6e\u5411\u9ad8\u4f4d\u6700\u957f\u7684\u8fde\u7eed\u4e00\u6bb5\u4e00\u5e76\u5c06\u5176\u7f6e\u96f6\uff0c\u4e0b\u4e00\u4e2a\u96f6\u7684\u4f4d\u7f6e\u53d8\u6210\u4e00\uff0c\u4f46\u8fd9\u6837\u53ef\u80fd\u7ef4\u62a4\u8f83\u4e3a\u9ebb\u70e6\u5e76\u4e14\u8f83\u6162\uff0c\u8003\u8651\u4f18\u5316\u3002\n\n\u6211\u4eec\u521a\u624d\u63d0\u5230\u4e00\u6b21\u53ea\u52a0\u4e00\u4e2a $2$ \u7684\u6b21\u5e42\uff0c\u90a3\u6709\u4e2a\u6709\u8da3\u7684\u505a\u6cd5\uff0c\u5373\u4e8c\u8fdb\u5236\u538b\u4f4d\uff0c\u6bd4\u5982\u6211\u4eec\u6bcf $50$ \u4f4d\u538b\u6210\u4e00\u4f4d\uff0c\u90a3\u4e48\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u70b9\u5bf9\u5e94\u7684\u533a\u95f4\u5c31\u5206\u522b\u662f $[0,49],[50,99],...$ \u8fd9\u79cd\u3002\n\n\u6211\u4eec\u53d1\u73b0\u5982\u679c\u8fd9\u6837\u64cd\u4f5c\u8fdb\u4f4d\u64cd\u4f5c\u662f\u975e\u5e38\u5c11\u7684\uff0c\u56e0\u4e3a\u8fd9\u6837\u7684\u8bdd\u6bd4\u5982\u5728 $[0,49]$ \u8fd9\u4e2a\u533a\u95f4\u5185\u6700\u53ef\u80fd\u4ea7\u751f\u8fdb\u4f4d\u7684\u64cd\u4f5c\u662f\u52a0\u4e0a $2^{49}$\uff0c\u4f46\u6211\u4eec\u53d1\u73b0\u5982\u679c\u8fdb\u4f4d\u7684\u8bdd\u53ea\u4f1a\u5728 $[50,99]$ \u52a0\u4e0a $1$\uff0c\u8fd9\u6837\u7684\u8bdd\u5728\u4e0b\u4e00\u4f4d\u51e0\u4e4e\u662f\u4e0d\u4f1a\u4ea7\u751f\u8fdb\u4f4d\u7684\uff0c\u9664\u975e\u4e0b\u4e00\u4e2a\u533a\u95f4 $50$ \u4f4d\u5168\u90fd\u662f $1$\uff0c\u4f46\u8fd9\u6837\u4e5f\u53ea\u4f1a\u4ea7\u751f\u4e00\u6b21\u8fdb\u4f4d\u3002\n\n\u603b\u800c\u8a00\u4e4b\u5982\u679c\u628a $50$ \u4f4d\u538b\u5230\u4e00\u8d77\u7684\u8bdd\u8fdb\u4f4d\u64cd\u4f5c\u5c31\u4f1a\u975e\u5e38\u5c11\uff0c\u5b9e\u6d4b\u8fd9\u6837\u901f\u5ea6\u5feb\u5f97\u98de\u8d77\uff0c\u5f53\u573a\u51b2\u5230\u6700\u4f18\u89e3\u3002\n\n### \u5b9e\u73b0\u7ec6\u8282\n\n\u6ce8\u610f\u8fd9\u91cc\u4e3b\u5e2d\u6811\u6bd4\u8f83\u7684\u8bdd\u662f\u8981\u521b\u5efa\u65b0\u6839\u7684\uff0c\u4e5f\u5c31\u662f\u6bcf\u6b21\u6bd4\u8f83\u90fd\u4f1a\u4ea7\u751f\u4e00\u5b9a\u7684\u7a7a\u95f4\u6d88\u8017\uff0c\u90a3\u6211\u4eec\u5c31\u8981\u5c3d\u91cf\u51cf\u5c11\u6bd4\u8f83\u6b21\u6570\u3002\n\n\u6bcf\u6b21\u6211\u4eec\u628a\u70b9\u5165\u961f\u65f6\uff0c\u53ef\u80fd\u8fd8\u6ca1\u5904\u7406\u5c31\u88ab\u518d\u6b21\u5165\u961f\uff0c\u663e\u7136\u6bcf\u6b21\u5165\u961f\u5bf9\u5e94\u7684\u6839\u662f\u4e0d\u540c\u7684\uff0c\u6211\u4eec\u5728\u7ed3\u6784\u4f53\u91cc\u52a0\u4e00\u4e0b\u5165\u961f\u65f6\u7684\u6839\uff0c\u5982\u679c\u548c\u5f53\u524d\u6839\u4e0d\u540c\u8bf4\u660e\u88ab\u518d\u6b21\u5165\u961f\u4e86\uff0c\u5c31\u53ef\u4ee5\u76f4\u63a5\u8df3\u8fc7\u4e0d\u8fdb\u884c\u8ba1\u7b97\uff0c\u849f\u84bb\u56e0\u4e3a\u6ca1\u52a0\u8fd9\u4e2a\u4f18\u5316\u88ab\u5361\u4e86\u4e00\u4e2a\u591a\u5c0f\u65f6\uff08\u96fe\uff09\u3002\n\n### \u6700\u540e\n\n\u5176\u5b9e\u8fd9\u79cd\u65b9\u6cd5\u662f\u53ef\u4ee5\u88ab Hack \u6389\u7684\uff0c\u6bd4\u5982\u53ef\u4ee5\u4ece\u8d77\u70b9\u5f00\u59cb\u5230\u67d0\u4e2a\u70b9\u6765\u4e00\u6761\u94fe\uff0c\u8fb9\u6743\u4f9d\u6b21 $+1$\uff0c\u7136\u540e\u5728\u8fd9\u4e2a\u70b9\u518d\u63a5\u4e2a\u7c7b\u4f3c\u83ca\u82b1\u56fe\u7684\u4e1c\u897f\uff0c\u5404\u70b9\u518d\u8fde\u5411\u7ec8\u70b9\uff0c\u8fb9\u6743\u90fd\u662f $2^0$ \u5c31\u4f1a\u88ab\u5361\u6210 $O(n^2\\log n)$\u3002\n\n\u4e0d\u8fc7\u5584\u826f\u7684\u51fa\u9898\u4eba\u5e76\u6ca1\u6709\u5361\u8fd9\u79cd\u505a\u6cd5\uff0c\u5b9e\u9645\u4e0a\u771f\u7684\u8981\u5361\u7684\u8bdd\u52a0\u4e0a\u627e\u8fde\u7eed\u6bb5\u4e5f\u662f\u53ef\u4ee5\u901a\u8fc7\u7684\u3002\u5982\u679c\u4e0d\u662f\u5f88\u4e25\u683c\u5730\u6765\u5361\u8fd9\u79cd\u505a\u6cd5\u7684\u8bdd\u590d\u6742\u5ea6\u662f\u5f88\u96be\u9000\u5316\u7684\u3002\n\n### \u8d34\u4ee3\u7801\n\n```cpp\n#include <bits/stdc++.h>\n#define lint long long\n#define rint register int\nusing namespace std;\ninline lint read(){\n    char c;lint f=1,res=0;\n    while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;\n    while(isdigit(c))res=res*10+c-'0',c=getchar();\n    return res*f;\n}\nconst int N=1e5+5,M=2e5+5,B=50,R=2e3+5,P=1e7+5;\nconst lint md=1e9+7,bas=2333333;\nint hed[N],nxt[M],ver[M],w[M],ne=1;\ninline void ade(int u,int v,int _w){\n    ver[++ne]=v;\n    nxt[ne]=hed[u];\n    hed[u]=ne;\n    w[ne]=_w;\n}\ninline void adbe(int u,int v,int _w)\n    {ade(u,v,_w);ade(v,u,_w);}\nint n,m,s,t;\nint rt[N],tot=0;\nlint ans=0,pw[B+1],_pw[R];\nint ch[P][2],mx[P];\nlint hsh[P],pwb[N],sum[P];\ninline int cpy(int y){\n    int x=++tot;\n    if(y){\n        memcpy(ch[x],ch[y],sizeof ch[x]);\n        sum[x]=sum[y];mx[x]=mx[y];\n    }else mx[x]=-1;\n    return x;\n}\ninline lint qpow(lint x,lint y){\n    lint res=1;\n    while(y){\n        if(y&1)res=res*x%md;\n        x=x*x%md;y>>=1;\n    }return res;\n}\n//sum\u53ea\u5b58\u5728\u4e8e\u6700\u5e95\u5c42 \ninline void pushup(int x,int l,int r){\n    int lc=ch[x][0],rc=ch[x][1],mid=l+r>>1;\n    mx[x]=max(mx[lc],mx[rc]);\n    hsh[x]=(pwb[r-mid]*hsh[ch[x][1]]%md+hsh[ch[x][0]])%md;\n}\nvoid add(int x,int l,int r,int p,lint v){\n    if(l==r){\n        sum[x]+=v;hsh[x]=sum[x];\n        if(sum[x])mx[x]=l;\n        else mx[x]=-1;\n        return;\n    }int mid=l+r>>1;\n    if(p<=mid)add(ch[x][0]=cpy(ch[x][0]),l,mid,p,v);\n    else add(ch[x][1]=cpy(ch[x][1]),mid+1,r,p,v);\n    pushup(x,l,r);\n}\nlint gsum(int x,int l,int r,int p){\n    if(!x)return 0;\n    if(l==r)return sum[x];\n    int mid=l+r>>1;\n    if(p<=mid)return gsum(ch[x][0],l,mid,p);\n    else return gsum(ch[x][1],mid+1,r,p);\n}\n//\u83b7\u53d6\u6574\u68f5\u6811\u7b54\u6848\u5bf9md\u53d6\u6a21\u7684\u7ed3\u679c \n//\u7f16\u53f7\u4ece0\u5f00\u59cb\uff0c\u7b2c\u96f6\u6bb5\u5bf9\u5e94 [0,49] \nlint gans(int x,int l,int r){\n    if(!x||mx[x]==-1)return 0;\n    if(l==r)return sum[x]%md*_pw[l]%md;\n    lint mid=l+r>>1,res=0;\n    res+=gans(ch[x][0],l,mid);\n    res+=gans(ch[x][1],mid+1,r);\n    return res%md;\n}\n//\u5728u\u7684\u6839\u7684\u57fa\u7840\u4e0a\u52a0\u4e0a2^x\u4ea7\u751f\u4e00\u4e2a\u65b0\u6839 \ninline int upd(int u,int x){\n    int nrt=cpy(rt[u]);\n    add(nrt,0,R,x/B,pw[x%B]);\n    int p=x/B;lint tmp;\n    while((tmp=gsum(nrt,0,R,p))>=pw[B]){\n        add(nrt,0,R,p,tmp%pw[B]-tmp);\n        add(nrt,0,R,p+1,tmp/pw[B]);\n        ++p;\n    }return nrt;\n}\n//\u8fd4\u56dex\u7684\u503c\u662f\u5426\u5c0f\u4e8ey \nbool les(int x,int y,int l,int r){\n    if(mx[x]!=mx[y])return mx[x]<mx[y];\n    if(l==r)return sum[x]<sum[y];\n    int mid=l+r>>1;\n    if(hsh[ch[x][1]]!=hsh[ch[y][1]])\n        return les(ch[x][1],ch[y][1],mid+1,r);\n    else return les(ch[x][0],ch[y][0],l,mid);\n}\nstruct node{int id,rt;};\ninline bool operator>(node x,node y)\n    {return les(rt[y.id],rt[x.id],0,R);}\npriority_queue<node,vector<node>,greater<node> > q;\nint pre[N],rd[N],cnt;\ninline void Dijkstra(){\n    q.push(node{s,rt[s]});\n    while(!q.empty()){\n        node tp=q.top();\n        q.pop();int u=tp.id;\n        if(tp.rt!=rt[u])continue;\n        for(rint e=hed[u];e;e=nxt[e]){\n            int v=ver[e];\n            int tmp=upd(u,w[e]);\n            if(!rt[v]||les(tmp,rt[v],0,R)){\n                rt[v]=tmp;pre[v]=u;\n                q.push(node{v,rt[v]});\n            }\n        }\n    }\n    ep:if(!rt[t])ans=-1;\n    else ans=gans(rt[t],0,R);\n    int u=t;\n    while(u){\n        rd[++cnt]=u;\n        u=pre[u];\n    }\n}\ninline void init(){\n    pw[0]=1;pwb[0]=1;\n    for(rint i=1;i<=B;++i)\n        pw[i]=pw[i-1]*2;\n    for(rint i=1;i<N;++i)\n        pwb[i]=pwb[i-1]*bas%md;\n    _pw[0]=1;_pw[1]=qpow(2,B);\n    for(rint i=1;i<R;++i)\n    \t_pw[i]=_pw[i-1]*_pw[1]%md;\n    rt[s]=++tot;mx[s]=-1;\n}\nint main(){\n    n=read();m=read();\n    for(rint i=1;i<=m;++i){\n        int u=read(),v=read();\n        int _w=read();\n        adbe(u,v,_w);\n    }\n    s=read();t=read();\n    init();Dijkstra();\n    printf(\"%lld\\n\",ans);\n    if(ans==-1)return 0;\n    printf(\"%d\\n\",cnt);\n    for(rint i=cnt;i>=1;--i)\n        printf(\"%d \",rd[i]);\n    return 0;\n}\n```\n\n",
        "postTime": 1634289141,
        "uid": 206258,
        "name": "SDNetFriend",
        "ccfLevel": 7,
        "title": "CF464E The Classic Problem \u9898\u89e3"
    },
    {
        "content": "[CF \u4f20\u9001\u95e8\uff1aCF464E The Classic Problem](https://codeforces.com/problemset/problem/464/e)\n\n\u9996\u5148\u5728\u6b64\u611f\u8c22 @[orz_z](https://www.luogu.com.cn/user/257146) \u548c @[Albert_van](https://www.luogu.com.cn/user/326780) \u4e24\u4e2a\u5927\u4f6c\u7684\u5b66\u672f\u652f\u6301\u3002\n\n## Solution\n\n\u6700\u77ed\u8def + \u4e3b\u5e2d\u6811\u3002\n\n\u6700\u77ed\u8def\u4e0d\u7528\u8bf4\u4e86\uff0c\u4e3b\u8981\u8003\u8651\u5982\u4f55\u8ba1\u7b97\u90a3\u4e9b $2$ \u7684\u82e5\u5e72\u6b21\u65b9\u7684\u8fb9\u6743\u3002\u7ef4\u62a4\u8fb9\u6743\u4e0d\u592a\u53ef\u884c\uff0c\u6211\u4eec\u7ef4\u62a4\u6700\u77ed\u8def\u4e2d\u5230\u6bcf\u4e00\u4e2a\u8282\u70b9\u7684\u6700\u8fd1\u8ddd\u79bb $dis_i$\u3002\u6570\u636e\u5b9e\u5728\u592a\u5927\u4e86\uff0c\u9ad8\u7cbe\u5ea6\u663e\u7136\u4e0d\u884c\u3002\n\n\u5f80\u6570\u636e\u7ed3\u6784\u65b9\u9762\u60f3\uff0c\u53d1\u73b0\u82e5\u662f\u5bf9\u4e00\u4e2a\u8282\u70b9\u7684 $dis_i$ \u5efa\u4e00\u68f5\u7ebf\u6bb5\u6811\uff0c\u6211\u4eec\u8981\u5728\u4e0a\u9762\u7ef4\u62a4\u4ec0\u4e48\u3002\u663e\u7136\uff0c\u53ea\u6709\u76f8\u52a0\u548c\u6bd4\u5927\u5c0f\u3002\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4f4d\u4ee3\u8868\u6570\u503c\u4e8c\u8fdb\u5236\u4e0a\u7684\u6bcf\u4e00\u4f4d\uff0c\u521d\u59cb\u5168\u4e3a 0\u3002\n\n- \u76f8\u52a0\uff1a\n\n\t\u7531\u4e8e\u90fd\u662f $2$ \u7684\u82e5\u5e72\u6b21\u65b9\uff0c\u6240\u4ee5\u76f8\u52a0\u7684\u65f6\u5019\uff0c\u4e0d\u59a8\u8bb0\u52a0\u4e0a $2^x$\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u5c06\u4ece\u7b2c $x$ \u4e3a\u5f00\u59cb\u7684\u3001\u5411\u524d\u7684\u3001\u8fde\u7eed\u7684\u82e5\u5e72\u4e2a $1$ \u5168\u90e8\u66f4\u6539\u4e3a $0$\uff0c\u7136\u540e\u5728\u8fd9\u4e9b $0$ \u524d\u9762\u52a0 $1$\u3002\u6362\u8a00\u4e4b\uff0c\u533a\u95f4\u4fee\u6539 + \u5355\u70b9\u4fee\u6539\u3002\u90a3\u6bd4\u5927\u5c0f\u5462\uff1f\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u4e2d\u7684\u6bcf\u4e2a\u533a\u95f4\uff0c\u6211\u4eec\u90fd\u7ef4\u62a4\u8fd9\u4e2a\u533a\u95f4\u6240\u7ec4\u6210\u7684\u6570\u7684\u6570\u503c\uff0c\u7ef4\u62a4\u65b9\u5f0f\u662f\u54c8\u5e0c\u3002\n    \n- \u6bd4\u5927\u5c0f\uff1a\n\n\t\u5bf9\u4e8e\u4e24\u4e2a\u76f8\u540c\u957f\u5ea6\u7684\u4e0d\u540c\u533a\u95f4\uff0c**\u4e0d\u80fd\u76f4\u63a5\u6bd4\u8f83\u4e24\u8005\u7684\u54c8\u5e0c\u503c**\uff0c\u56e0\u4e3a**\u54c8\u5e0c\u53ea\u80fd\u786e\u5b9a\u4e24\u4e2a\u533a\u95f4\u76f8\u540c\uff0c\u4f46\u65e0\u6cd5\u6bd4\u5927\u5c0f**\u3002\u6240\u4ee5\u6211\u4eec\u8981\u627e\u5230\u4e24\u4e2a\u533a\u95f4\u7684\u6700\u957f\u76f8\u540c\u524d\u7f00\u7684\u540e\u4e00\u4f4d\uff0c\u6839\u636e\u8fd9\u4e00\u4f4d\u6765\u786e\u5b9a\u4e24\u4e2a\u533a\u95f4\u7684\u5927\u5c0f\u5173\u7cfb\u3002\n\n\u56e0\u4e3a\u662f\u8dd1\u6700\u77ed\u8def\uff0c\u6240\u4ee5\u6bcf\u4e2a\u8282\u70b9 $i$ \u7684 $dis$ \u503c\u662f\u7531\u67d0\u4e00\u4e2a\u4e0e\u81ea\u5df1\u76f4\u63a5\u8054\u901a\u7684\u8282\u70b9\u677e\u5f1b\u800c\u6765\u7684\uff08\u8d77\u70b9\u9664\u5916\uff09\uff0c\u6545\u4f7f\u7528\u4e3b\u5e2d\u6811\u3002\n\n\u6700\u540e\u8bb0\u5f55\u8def\u5f84\u8f83\u7b80\u5355\uff0c\u4e0d\u7ec6\u8bf4\u3002\n\n## Code\n\n$93$ \u884c\u7684 CF464E\uff0c\u4f60\u503c\u5f97\u62e5\u6709\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll; \n#define rep(i, a, b) for(register int i = a; i <= b; ++i)\n#define ls(x) t[x].ls\n#define rs(x) t[x].rs\n#define s(x) t[x].sum\n#define sz(x) t[x].sz\n#define h(x) t[x].hsh\n#define gmd mid=l+r>>1\nconst int maxn = 1e5 + 100, N = 1e5 + 20, mod = 1e9 + 7;\nint n, m, S, T, tot, u, v, w;\nint pw[maxn], rt[maxn], cnt, hd[maxn], pre[maxn], ot[maxn];\nbool vis[maxn];\nstruct node{\n\tint to, nxt, w;\n}e[maxn << 1]; \nstruct tree{\n\tint ls, rs, sum, sz; ll hsh;\n}t[maxn * 77];\ninline void add(int u, int v, int w){\n\tcnt++; e[cnt].to = v, e[cnt].nxt = hd[u], e[cnt].w = w, hd[u] = cnt; \n}\ninline void up(int x){\n\ts(x) = s(ls(x)) + s(rs(x));\n\th(x) = (pw[sz(ls(x))] * h(rs(x)) % mod + h(ls(x))) % mod;\n}\ninline void build(int &x, int l, int r){\n\tx = ++tot, sz(x) = r - l + 1;\n\tif(l == r) return;\n\tint mid = l + r >> 1; build(ls(x), l, mid), build(rs(x), mid + 1, r), up(x);\n}\ninline void upp(int &x, int lst, int l, int r, int pos){\n\tx = ++tot, t[x] = t[lst];\n\tif(l == r) {s(x) += 1, h(x) += 1; return;}\n\tint mid = l + r >> 1; if(pos <= mid) upp(ls(x), ls(lst), l, mid, pos); else upp(rs(x), rs(lst), mid + 1, r, pos); up(x);\n}\ninline void upr(int &x, int lst, int init, int l, int r, int L, int R){\n\tif(l >= L and r <= R) {x = init; return;}\n\tx = ++tot, t[x] = t[lst]; int mid = l + r >> 1;\n\tif(L <= mid) upr(ls(x), ls(lst), ls(init), l, mid, L, R); if(R > mid) upr(rs(x), rs(lst), rs(init), mid + 1, r, L, R); up(x);\n}\ninline int qry(int x, int l, int r, int L, int R){\n\tif(l >= L and r <= R) return s(x); int mid = l + r >> 1;\n\treturn (L <= mid ? qry(ls(x), l, mid, L, R) : 0) + (R > mid ? qry(rs(x), mid + 1, r, L, R) : 0);\n}\ninline int fnd(int x, int l, int r, int p, int num){\n\tif(l == r) return l; int mid = l + r >> 1; \n\tif(s(ls(x)) >= mid - p + 1 + num) return fnd(rs(x), mid + 1, r, p, num - s(ls(x))); else return fnd(ls(x), l, mid, p, num);\n}\ninline void mdf(int &x, int lst, int w){\n\tint c = w > 0 ? qry(lst, 0, N, 0, w - 1) : 0;int y = fnd(lst, 0, N, w, c);\n\tif(y > w) upr(x, lst, rt[0], 0, N, w, y - 1); else x = lst;\n\tupp(x, x, 0, N, y);\n}\ninline bool cmp(int a, int b, int l, int r){\n\tif(l == r) return s(a) > s(b); int mid = l + r >> 1;\n\tif(h(rs(a)) == h(rs(b))) return cmp(ls(a), ls(b), l, mid);\n\treturn cmp(rs(a), rs(b), mid + 1, r); \n}\ninline void Pre(){\n\tpw[0] = 1; rep(i, 1, N - 1) pw[i] = pw[i - 1] * 2ll % mod;\n}\nstruct que{\n\tint id, rt;\n\tbool operator <(const que &tt) const{return cmp(rt, tt.rt, 0, N);}\n}; priority_queue<que> q;\ninline void dijkstra(){\n\tbuild(rt[0], 0, N), rt[S] = rt[0], q.push({S, rt[S]});\n\twhile(!q.empty()){\n\t\tint u = q.top().id; q.pop();\n\t\tif(vis[u]) continue; vis[u] = 1;\n\t\tif(u == T) break;\n\t\tfor(int v, i = hd[u]; i; i = e[i].nxt){\n\t\t\tmdf(rt[n + 1], rt[u], e[i].w);\n\t\t\tif(!rt[v = e[i].to] or cmp(rt[v], rt[n + 1], 0, N)){\n\t\t\t\trt[v] = rt[n + 1], pre[v] = u; if(!vis[v]) q.push({v, rt[v]});\t\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\n\tPre(), scanf(\"%d%d\", &n, &m);\n\trep(i, 1, m) scanf(\"%d%d%d\", &u, &v, &w), add(u, v, w), add(v, u, w);\n\tscanf(\"%d%d\", &S, &T), dijkstra();\n\tif(!vis[T]){printf(\"-1\\n\"); return 0;} else printf(\"%lld\\n\", h(rt[T]));\n\tint p; p = ot[++ot[0]] = T;\n\twhile(p != S) \n\t\tp = pre[p], ot[++ot[0]] = p;\n\tprintf(\"%d\\n\", ot[0]);\n\tfor(int i = ot[0]; i; i--) printf(\"%d \", ot[i]);\n\treturn 0;\n}\n```\n\n\n------------\n\u611f\u8c22\u9605\u8bfb\u3002",
        "postTime": 1657956645,
        "uid": 469672,
        "name": "\u4f0d\u53c1\u58f9",
        "ccfLevel": 7,
        "title": "\u3010CF464E\u3011 The Classic Problem"
    },
    {
        "content": "**\u771f - \u9898\u89e3**  \n\u4eb2\u6d4b\u53ef\u4ee5\u901a\u8fc7\u8ba8\u8bba\u533a\u63d0\u5230\u7684 Hack \u6570\u636e\u3002\n\n\u8fd9\u662f\u9053\u4e3b\u5e2d\u6811 + Hash \u795e\u4ed9\u9898\u3002\n\n\u76f4\u89c2\u7684\u60f3\u6cd5\u662f\u9ad8\u7cbe\u5957 dijkstra \u3002  \n\u5982\u679c\u7528\u9ad8\u7cbe\uff0c\u9700\u8981\u7528\u5230 + \u548c < \u8fd0\u7b97\uff0c\u590d\u6742\u5ea6\u5747\u4e3a $ O(x) $\uff0c  \n\u603b\u590d\u6742\u5ea6 $O(m x log(n)) $  \n\n\u6709\u4e2a\u7279\u6b8a\u7684\u5730\u65b9\uff1a\u8fb9\u7684\u6743\u503c\u90fd\u662f 2 \u7684\u6574\u6b21\u5e42\u3002  \n\u90a3\u4e48\u7528\u4e8c\u8fdb\u5236\u8868\u793a\u6743\u503c\u7684\u8bdd\uff0c + \u8fd0\u7b97\u53ea\u4f1a\u52a0\u4e00\u4f4d\u3002  \n\u8003\u8651\u7528\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u7ef4\u62a4\u8fd9\u4e2a\u9ad8\u7cbe\u5ea6\uff0c  \n- '+' \u8fd0\u7b97\u4e8c\u5206\u627e\u5230\u4e00\u6bb5\u6700\u957f\u7684\u8fde\u7eed 1 \u533a\u95f4\u4fee\u6539\u4e3a 0 \u518d\u628a\u4e00\u4e2a 0 \u53d8\u6210 1 \u3002  \n- '<' \u8fd0\u7b97\u4e8c\u5206\u54c8\u5e0c\u503c\u627e\u5230 lcs \u518d\u5224\u65ad\u7b2c\u4e00\u4e2a\u4e0d\u540c\u7684\u4f4d\uff08\u7c7b\u4f3c\u4e8e\u54c8\u5e0c\u6bd4\u8f83\u5b57\u7b26\u4e32\u5927\u5c0f\uff09\u3002  \n\n\u6bcf\u4e2a\u8fd0\u7b97\u7684\u590d\u6742\u5ea6\u90fd\u662f $ O(log^2) $  \n\u4e0d\u5bf9\u554a\uff0c\u5957\u4e0a dijkstra \u603b\u590d\u6742\u5ea6\u6709\u4e09\u4e2a log \uff0c  \n\u4e8b\u5b9e\u4e0a < \u8fd0\u7b97\u53ef\u4ee5\u5229\u7528\u7ebf\u6bb5\u6570\u7684\u7ed3\u6784\u76f4\u63a5\u5728\u7ebf\u6bb5\u6811\u91cc\u9762\u9012\u5f52\uff08\u4e8c\u5206\uff09\uff0c\u4e00\u4e2a log \u3002  \n\u800c + \u8fd0\u7b97\u53ea\u4f1a\u7528\u5230 O(m) \u6b21\uff0c\u56e0\u6b64\u603b\u590d\u6742\u5ea6 $ O(m log(n) log(x) + m log^2(x)) $ \u3002\n\n```cpp\n#include <bits/stdc++.h>\n\ntypedef unsigned long long Hash;\n\nHash power(Hash x, int k) {\n\tHash res = 1;\n\twhile(k) {\n\t\tif(k & 1) res *= x;\n\t\tx *= x;\n\t\tk >>= 1;\n\t}\n\treturn res;\n}\n\nclass Tree {\nprivate:\n\tint L, R, sum;\n\tbool fuck_memory[4];\n\tHash hash, Rpow; // \u9700\u8981\u9884\u5904\u7406 Rpow, \u5426\u5219\u590d\u6742\u5ea6\u4f1a\u591a\u4e00\u4e2a log\n\tTree *lt, *rt;\n\tvoid update() {\n\t\tsum = lt -> sum + rt -> sum;\n\t\thash = lt -> hash * Rpow + rt -> hash;\n\t}\n\tvoid get_son() {\n\t\tint mid = (L + R) >> 1;\n\t\tif(lt == null) lt = new Tree(L, mid);\n\t\tif(rt == null) rt = new Tree(mid + 1, R);\n\t}\npublic:\n\tstatic Tree *const null;\n\tTree *lain(int p) {\n\t\tTree *node = new Tree(*this);\n\t\tif(L == R) {\n\t\t\tnode -> sum ++;\n\t\t\tnode -> hash ++;\n\t\t\treturn node;\n\t\t}\n\t\tint mid = (L + R) >> 1;\n\t\tget_son();\n\t\tif(p <= mid)\n\t\t\tnode -> lt = lt -> lain(p);\n\t\telse\n\t\t\tnode -> rt = rt -> lain(p);\n\t\tnode -> update();\n\t\treturn node;\n\t}\n\tTree *clear(int l, int r) {\n\t\tif(r < L or l > R) return this;\n\t\tTree *node = new Tree(*this);\n\t\tif(l <= L and R <= r) {\n\t\t\tnode -> sum = 0;\n\t\t\tnode -> hash = 0;\n\t\t\tnode -> lt = node -> rt = null;\n\t\t\treturn node;\n\t\t}\n\t\tget_son();\n\t\tnode -> lt = lt -> clear(l, r);\n\t\tnode -> rt = rt -> clear(l, r);\n\t\tnode -> update();\n\t\treturn node;\n\t}\n\tint query_sum(int l, int r) {\n\t\tif(not sum or r < L or l > R) return 0;\n\t\tif(l <= L and R <= r) return sum;\n\t\treturn lt -> query_sum(l, r) + rt -> query_sum(l, r);\n\t}\n\tstatic int cmp(Tree *a, Tree *b) {\n\t\tif(a -> hash == b -> hash) return 0;\n\t\tif(not a -> sum) return -1;\n\t\tif(not b -> sum) return 1;\n\t\tif(a -> L == b -> R)\n\t\t\treturn a -> sum < b -> sum ? -1 : 1;\n\t\tint rres = cmp(a -> rt, b -> rt);\n\t\tif(rres) return rres;\n\t\treturn cmp(a -> lt, b -> lt);\n\t}\n\tTree(int l, int r): L(l), R(r), sum(0), hash(0), lt(null), rt(null) {\n\t\tRpow = power(3, R - ((L + R) >> 1));\n\t}\n\tTree(): L(-1), R(-1), sum(0), hash(0), lt(nullptr), rt(nullptr) { }\n};\nTree *const Tree::null = new Tree();\n\nconst int maxn = 100050, maxv = 100100; // maxv \u7684\u503c\u5f00\u5c0f\u4f1a wei\nclass Value {\nprivate:\n\tTree *T;\npublic:\n\tbool operator < (Value an) const {\n\t\treturn Tree::cmp(T, an.T) == -1;\n\t}\n\tValue operator + (int k) {\n\t\tint l = k, r = maxv;\n\t\twhile(l < r) {\n\t\t\tint mid = (l + r) >> 1;\n\t\t\tif(T -> query_sum(k, mid) == mid - k + 1)\n\t\t\t\tl = mid + 1;\n\t\t\telse\n\t\t\t\tr = mid;\n\t\t}\n\t\tTree *node = T;\n\t\tif(k <= l - 1)\n\t\t\tnode = T -> clear(k, l - 1);\n\t\tnode = node -> lain(l);\n\t\treturn Value(node);\n\t}\n\tbool empty() { return T == Tree::null; }\n\tvoid init() {\n\t\tT = new Tree(0, maxv);\n\t}\n\tint fuck_ans() {\n\t\tint ans = 0, pp = 1, mod = 1000000007;\n\t\tfor(int i = 0; i <= maxv; i ++) {\n\t\t\tif(T -> query_sum(i, i))\n\t\t\t\t(ans += pp) %= mod;\n\t\t\t(pp <<= 1) %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\tValue(Tree *T = Tree::null): T(T) { }\n};\n\nstruct Edge {\n\tint to, val;\n\tEdge(int to, int val): to(to), val(val) { }\n};\nValue dist[maxn];\nint last[maxn];\nbool vis[maxn];\nstd::vector<Edge> G[maxn];\n\nvoid dijk(int s) {\n\ttypedef std::pair<Value, int> par;\n\tstd::priority_queue<par, std::vector<par>, std::greater<par>> q;\n\tdist[s].init();\n\tq.push(par(dist[s], s));\n\twhile(not q.empty()) {\n\t\tint u = q.top().second;\n\t\tq.pop();\n\t\tif(vis[u]) continue;\n\t\tvis[u] = true;\n\t\tfor(Edge &e : G[u])\n\t\t\tif(not vis[e.to]) {\n\t\t\t\tValue d = dist[u] + e.val;\n\t\t\t\tif(dist[e.to].empty() or d < dist[e.to]) {\n\t\t\t\t\tdist[e.to] = d;\n\t\t\t\t\tlast[e.to] = u;\n\t\t\t\t\tq.push(par(d, e.to));\n\t\t\t\t}\n\t\t\t}\n\t}\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tint n, m;\n\tstd::cin >> n >> m;\n\tfor(int i = 1; i <= m; i ++) {\n\t\tint u, v, w;\n\t\tstd::cin >> u >> v >> w;\n\t\tG[u].push_back(Edge(v, w));\n\t\tG[v].push_back(Edge(u, w));\n\t}\n\tint s, t;\n\tstd::cin >> s >> t;\n\tdijk(s);\n\tstd::vector<int> path;\n\tfor(int u = t; u; u = last[u])\n\t\tpath.push_back(u);\n\tif(path[path.size() - 1] == s) {\n\t\tstd::cout << dist[t].fuck_ans() << std::endl;\n\t\tstd::cout << path.size() << std::endl;\n\t\tfor(size_t i = path.size() - 1; i; i --)\n\t\t\tstd::cout << path[i] << ' ';\n\t\tstd::cout << path[0] << std::endl;\n\t} else {\n\t\tstd::cout << -1 << std::endl;\n\t}\n}\n```",
        "postTime": 1554448416,
        "uid": 52232,
        "name": "Kewth",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF464E \u3010The Classic Problem\u3011"
    },
    {
        "content": "\u8bdd\u8bf4\u5c45\u7136\u6ca1\u4eba\u53d1\u9898\u89e3\u2026\u2026\u8d76\u7d27\u6c34\u4e00\u53d1\n\n\u5148\u6253\u4e00\u53d1\u5e7f\u544a[blog](https://www.cnblogs.com/bztMinamoto/p/9404175.html)\n\n\u8dd1\u4e00\u8fb9dijstra\u5927\u5bb6\u5e94\u8be5\u90fd\u60f3\u7684\u5230\n\n\u4f46\u95ee\u9898\u662f\u7ef4\u62a4\u6700\u77ed\u8def\u7684\u8ddd\u79bb\u600e\u4e48\u5b9e\u73b0\n\n~~\u6211\u592a\u83dc\u4e86\u9664\u4e86python\u5565\u90fd\u60f3\u4e0d\u5230~~\n\n\u6211\u4eec\u53ef\u4ee5\u628a\u8ddd\u79bb\u62c6\u6210\u6bcf\u4e00\u4f4d\uff0c\u56e0\u4e3a\u6bcf\u4e00\u6b21\u53ea\u4f1a\u52a0\u4e0a\u4e00\u4e2a\u6570\uff0c\u76f4\u63a5\u5f00\u4e3b\u5e2d\u6811\u7ef4\u62a4\u5c31\u597d\u4e86\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4ec0\u4e48\u7684\u2026\u2026\u611f\u6027\u7406\u89e3\u4e00\u4e0b\u5c31\u597d\u4e86\n\n\u6bd4\u8f83\u5927\u5c0f\u76f4\u63a5\u4e8c\u5206\u54c8\u5e0c\n```\n//minamoto\n#include<bits/stdc++.h>\nusing namespace std;\n#define getc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\nchar buf[1<<21],*p1=buf,*p2=buf;\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ninline int read(){\n    #define num ch-'0'\n    char ch;bool flag=0;int res;\n    while(!isdigit(ch=getc()))\n    (ch=='-')&&(flag=true);\n    for(res=num;isdigit(ch=getc());res=res*10+num);\n    (flag)&&(res=-res);\n    #undef num\n    return res;\n}\nconst int N=1e5+5,mod=1e9+7;\nint n,m,head[N],Next[N<<1],ver[N<<1],edge[N<<1];\nint S,T,lim,b[N<<1],rt[N],Pre[N],tot,cnt;\nint L[N*120],R[N*120],sum[N*120];\ninline void add(int u,int v,int e){\n    ver[++tot]=v,Next[tot]=head[u],head[u]=tot,edge[tot]=e;\n    ver[++tot]=u,Next[tot]=head[v],head[v]=tot,edge[tot]=e;\n}\nbool cmp(int u,int v,int l,int r){\n    if(l==r) return sum[u]>sum[v];\n    int mid=(l+r)>>1;\n    if(sum[R[u]]==sum[R[v]]) return cmp(L[u],L[v],l,mid);\n    else return cmp(R[u],R[v],mid+1,r);\n}\nint update(int last,int &now,int l,int r,int k){\n    L[now=++cnt]=L[last],R[now]=R[last];\n    if(l==r){\n        sum[now]=sum[last]^1;\n        return sum[last];\n        //\u6bcf\u4e00\u4e2a\u8282\u70b9\u5b58\u7684\u53ea\u6709\u4e00\u4f4d\uff0c\u5982\u679c\u52a0\u4e4b\u524d\u662f1\u5c31\u8981\u8fdb\u4f4d \n    }\n    int mid=(l+r)>>1,res;\n    if(k>mid) res=update(R[last],R[now],mid+1,r,k);\n    else{\n        res=update(L[last],L[now],l,mid,k);\n        if(res) res=update(R[last],R[now],mid+1,r,k);\n    }\n    sum[now]=(1ll*sum[R[now]]*b[mid-l+1]+sum[L[now]])%mod;\n    return res;\n}\nstruct node{\n    int x,rt;\n    bool operator <(const node &b)const\n    {return cmp(rt,b.rt,0,lim);}\n};\npriority_queue<node> q;\nvoid dfs(int u,int dep){\n    if(u==S){printf(\"%d\\n%d \",dep,u);return;}\n    dfs(Pre[u],dep+1);\n    printf(\"%d \",u);\n}\nvoid print(int u){\n    printf(\"%d\\n\",sum[rt[u]]);\n    dfs(u,1);exit(0);\n}\nint main(){\n    //freopen(\"testdata.in\",\"r\",stdin);\n    n=read(),m=read();\n    for(int i=1;i<=m;++i){\n        int u,v,e;\n        u=read(),v=read(),e=read();\n        add(u,v,e);\n        cmax(lim,e);\n    }\n    lim+=100;\n    b[0]=1;for(int i=1;i<=lim;++i) b[i]=(1ll*b[i-1]<<1)%mod;\n    S=read(),T=read();\n    q.push((node){S,rt[S]});\n    while(!q.empty()){\n        node u=q.top();q.pop();\n        if(u.rt!=rt[u.x]) continue;\n        //\u5982\u679c\u4e0d\u4e00\u6837\uff0c\u8bf4\u660e\u5df2\u7ecf\u5728\u4e3b\u5e2d\u6811\u4e0a\u88ab\u4fee\u6539\u4e86\n        //\u5c31\u7ed9\u666e\u901a\u7684\u5224dijkstra\u4e00\u6837\u5c31\u597d\u4e86 \n        if(u.x==T) print(T);\n        for(int i=head[u.x];i;i=Next[i]){\n            int v=ver[i],RT;\n            update(u.rt,RT,0,lim,edge[i]);\n            if(!rt[v]||cmp(rt[v],RT,0,lim))\n            rt[v]=RT,q.push((node){v,rt[v]}),Pre[v]=u.x;\n        }\n    }\n    puts(\"-1\");\n    return 0;\n}\n```",
        "postTime": 1533182303,
        "uid": 41781,
        "name": "bztMinamoto",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF464E \u3010The Classic Problem\u3011"
    },
    {
        "content": "\u633a\u6709\u610f\u601d\u7684\u4e00\u9053\u9898\uff0c\u7ed3\u5408\u7684\u5f88\u5de7\u5999\u3002  \n\u9996\u5148\u8fd9\u4e2a\u9898\u8ba9\u6211\u4eec\u6c42 $s$ \u5230 $t$ \u7684\u6700\u77ed\u8def\uff0c\u80af\u5b9a\u662f\u8981\u7528\u4e00\u4e2a dijkstra \u6765\u8dd1\u51fa\u6765\u7684\u3002\u4f46\u8fd9\u9053\u9898\u7684\u8fb9\u6743\u975e\u5e38\u5927\uff0c\u800c\u4e14\u5982\u679c\u7528\u9ad8\u7cbe\u5ea6\u7684\u8bdd\u8981\u8d85\u65f6\uff0c\u6211\u4eec\u8003\u8651\u600e\u4e48\u4f18\u5316\u8fd9\u4e2a\u5b58\u50a8\u548c\u8f6c\u79fb\u3002  \n\u7531\u4e8e\u8fb9\u6743\u90fd\u662f $2$ \u7684\u82e5\u5e72\u6b21\u65b9\uff0c\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u7528\u4e00\u4e2a\u7ebf\u6bb5\u6811\u53bb\u5b58\u50a8\u3002\u4f46\u662f\u8fd9\u6837\u7a7a\u95f4\u5f88\u660e\u663e\u662f\u4f1a\u7206\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u7528\u4e00\u68f5\u53ef\u6301\u4e45\u5316\u7ebf\u6bb5\u6811\u53bb\u5b58\u50a8\u3002\u8fd9\u6837\uff0c\u5728\u8f6c\u79fb\u7684\u65f6\u5019\u6211\u4eec\u5c31\u53ef\u4ee5\u7ee7\u627f\u4ece\u800c\u7701\u4e0b\u5f88\u591a\u7a7a\u95f4\u3002  \n\u5b58\u50a8\u7684\u95ee\u9898\u89e3\u51b3\u4e86\uff0c\u73b0\u5728\u6211\u4eec\u6765\u89e3\u51b3 dijkstra \u4e2d\u7684\u6838\u5fc3\uff1a\u6bd4\u8f83\u548c\u8f6c\u79fb\u3002  \n### 1.\u6bd4\u8f83  \n\u6211\u4eec\u6709\u4e24\u68f5\u7ebf\u6bb5\u6811\uff0c\u91cc\u9762\u5b58\u50a8\u4e86\u8def\u5f84\u957f\u5ea6\uff0c\u8be5\u5982\u4f55\u6bd4\u8f83\u5462\uff1f  \n\u60f3\u5230\u5e73\u5e38\u7684\u5b57\u7b26\u4e32\u6bd4\u8f83\u600e\u4e48\u505a\uff1f\u53ef\u4ee5\u4e8c\u5206\u54c8\u5e0c\u3002\u5728\u8fd9\u91cc\u4e5f\u662f\u4e00\u6837\uff0c\u6211\u4eec\u5728\u7ebf\u6bb5\u6811\u4e0a\u6bcf\u4e2a\u8282\u70b9\u7ef4\u62a4\u4e00\u4e2a\u54c8\u5e0c\u503c\uff0c\u7136\u540e\u5728\u7ebf\u6bb5\u6811\u4e0a\u9762\u4e8c\u5206\u627e\u5230\u6700\u957f\u516c\u5171\u524d\u7f00\u3002\u6bd4\u8f83\u6700\u957f\u516c\u5171\u524d\u7f00\u7684\u4e0b\u4e00\u4f4d\u5c31\u662f\u7b54\u6848\u3002  \n### 2.\u8f6c\u79fb  \n\u5728\u666e\u901a\u7684 dijkstra \u4e2d\uff0c\u8f6c\u79fb\u662f\u7c7b\u4f3c\u4e8e `d[j]=d[u]+e[i].v`\u3002\u5728\u8fd9\u91cc\u6211\u4eec\u76f8\u5f53\u4e8e\u662f\u6267\u884c\u4e8c\u8fdb\u5236\u4e0b\u7684\u52a0\u6cd5\u3002  \n\u4e8c\u8fdb\u5236\u52a0\u6cd5\u4f1a\u4ea7\u751f\u8fdb\u4f4d\uff0c\u8fd9\u4e2a\u770b\u4f3c\u4e0d\u597d\u7ef4\u62a4\u3002\u4f46\u662f `e[i].v` \u662f $2$ \u7684\u82e5\u5e72\u6b21\u65b9\uff0c\u4e5f\u5c31\u662f\u8bf4\uff0c\u8fdb\u4f4d\u53ea\u4f1a\u53d6\u51fa\u6781\u957f\u7684\u4e00\u6bb5 $1$\uff0c\u628a\u5b83\u4eec\u8d4b\u503c\u6210 $0$\uff0c\u7136\u540e\u5c06\u4e0b\u4e00\u4f4d\u7f6e\u6210 $1$\u3002  \n\u8fd9\u6837\u5c31\u597d\u529e\u4e86\uff0c\u6211\u4eec\u7528\u7ebf\u6bb5\u6811\u4e8c\u5206\u53d6\u51fa\u6781\u957f\u7684\u4e00\u6bb5 $1$\uff0c\u7136\u540e\u533a\u95f4\u8d4b $0$\uff0c\u5355\u70b9\u8d4b $1$\uff0c\u8fd9\u4e9b\u7ebf\u6bb5\u6811\u90fd\u53ef\u4ee5\u652f\u6301\u3002\u4e8e\u662f\u8fd9\u9898\u5c31\u505a\u5b8c\u4e86\u3002  \n\n\u5728\u5b9e\u9645\u5b9e\u73b0\u4e2d\uff0c\u7531\u4e8e\u53d6\u51fa\u6781\u957f\u7684\u4e00\u6bb5 $1$ \u4e0d\u597d\u5199\u3002\u6211\u7528\u4e86\u4e8c\u5206+\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u4f46\u4e0d\u5f71\u54cd $O(n\\log ^2n)$ \u7684\u590d\u6742\u5ea6\u3002  \n\n```cpp\n#include<bits/stdc++.h>\n#define lc(x) t[x].c[0]\n#define rc(x) t[x].c[1]\nusing namespace std;\nconst int maxn=1e5+114,mod=1e9+7;\ntypedef long long ll;\ninline int read() {\n\tint x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9')c=getchar();\n\twhile(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n\treturn x;\n}\nstruct tree {\n\tint c[2];\n\tbool pd;\n\tll sum,has;\n} t[maxn*200];\nstruct edge {\n\tint next,to,v;\n} e[maxn*2];\nint rt[maxn],n,m,cnt,tot,mx,pre[maxn],zc[maxn],zcnt,h[maxn],S,T;\nll pw[maxn],pw2[maxn];\nbool vis[maxn];\nvoid addedge(int x,int y,int z) {\n\te[++tot].next=h[x];\n\te[tot].to=y;\n\te[tot].v=z;\n\th[x]=tot;\n}\nvoid dfscout(int id,int l,int r) {\n\tif(l==r)return cout<<t[id].pd,void();\n\tint mid=l+r>>1;\n\tdfscout(rc(id),mid+1,r),dfscout(lc(id),l,mid);\n}\nvoid pushup(int id) {\n\tt[id].pd=t[lc(id)].pd&t[rc(id)].pd;//pd\uff1a\u533a\u95f4\u662f\u5426\u5168\u4e3a1\n\tt[id].sum=(t[lc(id)].sum+t[rc(id)].sum)%mod;//\u533a\u95f4\u5b9e\u9645\u548c\n\tt[id].has=(t[lc(id)].has+t[rc(id)].has)%mod;//\u533a\u95f4\u54c8\u5e0c\u503c\n}\nvoid build(int &id,int l,int r,int v) {\n\tid=++cnt;\n\tif(l==r)return t[id].sum=pw[l]*v,t[id].has=pw2[l]*v,t[id].pd=v,void();\n\tint mid=l+r>>1;\n\tbuild(lc(id),l,mid,v),build(rc(id),mid+1,r,v);\n\tpushup(id);//\u5efa\u4e00\u68f5\u51680/\u51681\u6811\n}\nbool ask(int id,int l,int r,int L,int R) {\n\tif(!id)return 0;\n\tif(l>=L&&r<=R)return t[id].pd;\n\tint mid=l+r>>1;\n\tbool sum=1;\n\tif(L<=mid)sum&=ask(lc(id),l,mid,L,R);\n\tif(R>mid)sum&=ask(rc(id),mid+1,r,L,R);\n\treturn sum;//\u8be2\u95ee\u662f\u5426\u5168\u4e3a1\n}\nvoid clear(int &id,int o,int l,int r,int L,int R) {\n\tid=++cnt,t[id]=t[o];\n\tif(l>=L&&r<=R)return id=0,void();//\u56e0\u4e3a\u8d4b\u503c\u7684\u662f0\uff0c\u6240\u4ee5\u53ef\u4ee5\u4e22\u6389\u513f\u5b50\uff0c\u4e0d\u7528\u6807\u8bb0\u6c38\u4e45\u5316\n\tint mid=l+r>>1;\n\tif(L<=mid)clear(lc(id),lc(o),l,mid,L,R);\n\tif(R>mid)clear(rc(id),rc(o),mid+1,r,L,R);\n\tpushup(id);//\u533a\u95f4\u8d4b\u503c0\n}\nvoid add(int &id,int o,int l,int r,int v) {\n\tid=++cnt,t[id]=t[o];\n\tif(l==r)return t[id].sum=pw[l],t[id].has=pw2[l],t[id].pd=1,void();\n\tint mid=l+r>>1;\n\tv<=mid?add(lc(id),lc(o),l,mid,v):add(rc(id),rc(o),mid+1,r,v);\n\tpushup(id);//\u5355\u70b9\u8d4b\u503c1\n}\nvoid addone(int i,int v) {\n\tint l=v,r=mx,now=v-1;\n\twhile(l<=r) {\n\t\tint mid=l+r>>1;\n\t\tif(ask(rt[i],0,mx,v,mid))now=mid,l=mid+1;\n\t\telse r=mid-1;//\u4e8c\u5206\u6781\u957f\u6bb5\n\t}\n\trt[n+1]=rt[i];\n\tif(v<=now)clear(rt[n+1],rt[n+1],0,mx,v,now);\n\tadd(rt[n+1],rt[n+1],0,mx,now+1);\n}\nbool cmp(int a,int b,int l,int r) {\n\tif(l==r)return t[a].pd>t[b].pd;\n\tint mid=l+r>>1;\n\treturn t[rc(a)].sum!=t[rc(b)].sum&&t[rc(a)].has!=t[rc(b)].has?cmp(rc(a),rc(b),mid+1,r):cmp(lc(a),lc(b),l,mid);//\u5224\u65ad\u5927\u5c0f\n}\nstruct que {\n\tint id,v;\n\tque(int i,int V) {\n\t\tid=i,v=V;\n\t}\n\tfriend bool operator<(que a,que b) {\n\t\treturn cmp(a.v,b.v,0,mx);//\u4e00\u5b9a\u8981\u7528\u90a3\u4e2a\u65f6\u5019\u7684\u6839\u6765\u6bd4\u8f83\uff0c\u5426\u5219\u4f1a\u5bfc\u81f4push\u4e0d\u4e0a\u6765\uff01 \n\t}\n};\npriority_queue<que> q;\nvoid dijkstra() {\n\tbuild(rt[S],0,mx,0);\n\tbuild(rt[0],0,mx,1);\n\tfor(register int i=1; i<=n; i++)if(i!=S)rt[i]=rt[0];\n\tq.push(que(S,rt[S]));\n\twhile(!q.empty()) {\n\t\tint u=q.top().id;\n\t\tq.pop();\n\t\tif(vis[u])continue;\n\t\tvis[u]=1;\n\t\tif(u==T)break;\n\t\tfor(register int i=h[u]; i; i=e[i].next) {\n\t\t\tint j=e[i].to;//\u7528\u4e00\u4e2a\u4e34\u65f6\u7248\u672cn+1\u6765\u6bd4\u8f83\n\t\t\taddone(u,e[i].v);\n\t\t\tif(cmp(rt[j],rt[n+1],0,mx)) {\n\t\t\t\trt[j]=rt[n+1],pre[j]=u;\n\t\t\t\tif(!vis[j])q.push(que(j,rt[j]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tint x,y,z;\n\tn=read(),m=read();\n\tfor(register int i=1; i<=m; i++) {\n\t\tx=read(),y=read(),mx=max(mx,z=read());\n\t\taddedge(x,y,z);\n\t\taddedge(y,x,z);\n\t}\n\tS=read(),T=read();\n\tmx+=22,pw[0]=pw2[0]=1;\n\tfor(register int i=1; i<=mx; i++)pw[i]=pw[i-1]*2%mod,pw2[i]=pw2[i-1]*114%mod;\n\tdijkstra();\n\tif(t[rt[T]].pd) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tprintf(\"%lld\\n\",t[rt[T]].sum);\n\tzc[zcnt=1]=T;\n\twhile(T!=S)T=pre[T],zc[++zcnt]=T;\n\tprintf(\"%d\\n\",zcnt);\n\tfor(register int i=zcnt; i; i--)printf(\"%d%c\",zc[i],\" \\n\"[i==1]);//\u5012\u63a8\u65b9\u6848\n\treturn 0;\n}\n```",
        "postTime": 1623927432,
        "uid": 104324,
        "name": "abruce",
        "ccfLevel": 7,
        "title": "\u9898\u89e3--CF464E The Classic Problem"
    },
    {
        "content": "[$\\tt Link$](/problem/CF464E)\u3002\n\n\u4e0b\u9762\u7684\u8ba8\u8bba\u9ed8\u8ba4 $n,m,x_i$ \u540c\u9636\u3002\n\n\u8fd9\u4e2a\u95ee\u9898\u4e0e\u5e38\u89c4 $\\tt dij$\uff0c\u4ec5\u4ec5\u5dee\u5728\u9ad8\u7cbe\u5ea6\u3002\u800c $\\tt dij$ \u6240\u9700\u7684\u9ad8\u7cbe\u5ea6\u5982\u4e0b\uff1a\n\n+ $dis_u+w(u,v)$ \u4e2d\u7684\u52a0\u6cd5\uff0c\u5e94\u8be5\u6709 $m$ \u6b21\u3002\n+ $dis_u+w(u,v)$ \u4e0e $dis_v$ \u7684\u6bd4\u8f83\uff0c\u5e94\u8be5\u6709 $m\\log$ \u6b21\u3002\n\n\u8003\u8651\u6570\u636e\u7ed3\u6784\u7ef4\u62a4 $dis$ \u7684\u4e8c\u8fdb\u5236\u5206\u89e3\u3002\u76f4\u63a5\u7ef4\u62a4\u7a7a\u95f4\u662f $\\mathcal O(nx)$ \u7684\uff0c\u4f46\u662f $dis$ \u4e4b\u95f4\u4e92\u76f8\u8f6c\u79fb\u3001\u53d6 $\\min$\uff0c\u5fc5\u7136\u6709\u5f88\u591a\u4f4d\u662f\u76f8\u540c\u7684\uff0c\u4e8e\u662f\u8003\u8651\u4e3b\u5e2d\u6811\u3002\n\n\u5bf9\u4e8e\u52a0\u6cd5\uff0c\n1. \u627e\u5230\u5f53\u524d\u4f4d\u7f6e\u4e4b\u524d\u7684\u8fde\u7eed $1$ \u603b\u6570\uff0c\u8fd9\u4e00\u6b65\u53ef\u4ee5\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\n2. \u5c06\u8fd9\u4e00\u90e8\u5206 $1$ \u63a8\u5e73\u4e3a $0$\uff0c\u8fd9\u4e00\u90e8\u5206\u53ef\u4ee5\u5148\u7ef4\u62a4\u597d\u4e00\u68f5\u5168 $0$ \u7684\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u4f7f\u7528\u5176\u4e2d\u8282\u70b9\u66ff\u6362\u539f\u4e3b\u5e2d\u6811\u7684\u8282\u70b9\u5373\u53ef\u3002\n3. \u5728\u66f4\u524d\u4e00\u4f4d\u6dfb\u52a0 $1$\uff0c\u8fd9\u4e00\u90e8\u5206\u76f4\u63a5\u5355\u70b9\u4fee\u6539\u3002\n\n\u5bf9\u4e8e\u6bd4\u8f83\uff0c\n+ \u540c\u65f6\u4e24\u4e2a\u6307\u9488\u904d\u5386\u4e24\u68f5\u7ebf\u6bb5\u6811\n+ \u5982\u679c\u5de6\u5b50\u6811\u4e0d\u540c\uff0c\u90a3\u4e48\u6bd4\u8f83\u5de6\u5b50\u6811\uff0c\u5426\u5219\u6bd4\u8f83\u53f3\u5b50\u6811\n+ \u5224\u65ad\u4e24\u4e2a\u5b50\u6811\u662f\u5426\u76f8\u540c\uff0c\u53ef\u4ee5\u7ef4\u62a4\u5b50\u6811\u54c8\u5e0c\u503c\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n \n#define rep(i,a,b) for(int i = (a);i <= (b);++i)\n \nusing hsh = unsigned long long;\n \nconst int N = 1e5 + 5;\nconst int S = N * 60;\nconst hsh mod = 1e9 + 7;\nconst int X = 1e5 + 50;\n \nint n,m,s,t,rt[N],pre[N],dis[N]; bool vis[N];\nvector<pair<int,int> > G[N];\nhsh pow2[X + 10]; int fa[N],XX;\n \nint lc[S],rc[S],cc; hsh w[S]; bool i1[S];\n \n#define mid ((L + R) >> 1)\n#define ls lc[i],L,mid\n#define rs rc[i],mid + 1,R\n \nvoid psu(int i,int L,int R){\n\ti1[i] = i1[lc[i]] && i1[rc[i]];\n\tw[i] = (w[rc[i]] * pow2[mid - L + 1] % mod + w[lc[i]]) % mod;\n}\n \nvoid build(int &i,int L,int R,int x){\n\ti = ++cc;\n\tif(L == R) return void(i1[i] = w[i] = x);\n\tbuild(ls,x); build(rs,x); psu(i,L,R);\n}\n \nbool cmp(int i,int j,int L,int R){\n\tif(L == R) return w[i] > w[j];\n\treturn w[rc[i]] == w[rc[j]] ? cmp(lc[i],lc[j],L,mid) : cmp(rc[i],rc[j],mid + 1,R);\n}\n \nint fnd(int i,int L,int R){\n\tif(i1[i]) return R; if(L == R) return -1;\n\tint _ = fnd(ls); return _ == mid ? max(fnd(rs),mid) : _;\n}\n \nint pos(int i,int L,int R,int p){\n\tif(p <= L) return fnd(i,L,R);\n\tif(p > mid) return pos(rs,p);\n\tint _ = pos(ls,p); return _ == mid ? max(mid,pos(rs,p)) : _;\n}\n \nstruct node{\n\tint u,r;\n\tnode(int u = 0,int r = 0) : u(u),r(r){}\n\tbool operator<(const node &p) const { return cmp(r,p.r,0,XX); }\n};\n \nvoid chg(int &p,int i,int j,int L,int R,int l,int r){\n\tif(l <= L && R <= r) return void(p = j);\n\tp = ++cc; rc[p] = rc[i]; lc[p] = lc[i]; i1[p] = i1[i]; w[p] = w[i];\n\tif(l <= mid) chg(lc[p],lc[i],lc[j],L,mid,l,r);\n\tif(r > mid) chg(rc[p],rc[i],rc[j],mid + 1,R,l,r);\n\tpsu(p,L,R);\n}\n \nvoid upd(int &p,int i,int L,int R,int x){\n\tp = ++cc; rc[p] = rc[i]; lc[p] = lc[i]; i1[p] = i1[i]; w[p] = w[i];\n\tif(L == R) return void(i1[p] = w[p] = 1);\n\tx <= mid ? upd(lc[p],ls,x) : upd(rc[p],rs,x);\n\tpsu(p,L,R);\n}\n \nint pls(int rt,int v){\n\tint p = pos(rt,0,XX,v),RT = rt;\n\tif(p < 0) p = v - 1; else chg(RT,rt,::rt[0],0,XX,v,p);\n\tint ret; upd(ret,RT,0,XX,p + 1); return ret;\n}\n \npriority_queue<node> Q;\n \nvoid dij(){\n\tbuild(rt[0],0,XX,0);\n\tbuild(rt[n + 1],0,XX,1);\n\trep(i,1,n) rt[i] = rt[n + 1];\n\tQ.emplace(s,rt[s] = rt[0]);\n\twhile(!Q.empty()){\n\t\tint u = Q.top().u,r = Q.top().r; Q.pop();\n\t\tif(vis[u]) continue; vis[u] = 1;\n\t\tif(u == t) return;\n\t\tfor(auto e : G[u]){\n\t\t\tint v = e.first,w = e.second;\n\t\t\tint RT = pls(r,w);\n\t\t\tif(cmp(rt[v],RT,0,XX)){\n\t\t\t\tQ.emplace(v,rt[v] = RT),pre[v] = u;\n\t\t\t\tdis[v] = (dis[u] + pow2[w]) % mod;\n\t\t\t}\n\t\t}\n\t}\n}\n \nvoid print(){\n\tprintf(\"%d\\n\",dis[t]);\n\tdeque<int> P;\n\twhile(t != s) P.push_front(t),t = pre[t];\n\tP.push_front(s);\n\tprintf(\"%d\\n\",P.size());\n\tfor(int x : P) printf(\"%d \",x); printf(\"\\n\");\n}\n \nint fnd(int i){ return i == fa[i] ? i : fa[i] = fnd(fa[i]); }\n \nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,n) fa[i] = i;\n\trep(i,1,m){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tfa[fnd(u)] = fnd(v);\n\t\tG[u].emplace_back(v,w);\n\t\tG[v].emplace_back(u,w);\n\t\tXX = max(XX,w);\n\t}\n\tscanf(\"%d%d\",&s,&t);\n\tif(fnd(s) != fnd(t)) return printf(\"-1\\n\"),0;\n\tpow2[0] = 1; XX += 25;\n\trep(i,1,XX + 2) pow2[i] = (pow2[i - 1] * 2) % mod;\n\tdij(); print();\n\treturn 0;\n}\n```",
        "postTime": 1657883126,
        "uid": 368107,
        "name": "xfrvq",
        "ccfLevel": 7,
        "title": "CF464E The Classic Problem"
    },
    {
        "content": "### CF464E The Classic Problem\n\u6700\u77ed\u8def\uff0c\u663e\u7136\u4e0d\u5177\u5907\u5355 $\\log$ \u505a\u6cd5\uff0c\u8003\u8651\u7ef4\u62a4\u9ad8\u7cbe\u4e8c\u8fdb\u5236\u6570\uff0c\u652f\u6301\u5355\u70b9\u52a0\u4e00\u3002\n\n\u663e\u7136\u9ad8\u7cbe\u4e0d\u884c\uff0c\u7ef4\u62a4\u4e8c\u8fdb\u5236\u6570\u7684 `trie` \u8f83\u4e3a\u590d\u6742\uff0c\u8003\u8651\u672c\u8d28\u76f8\u540c\u7684\u503c\u57df\u7ebf\u6bb5\u6811\u3002\n\n\u652f\u6301\u6bd4\u8f83\u5927\u5c0f\u3001\u533a\u95f4\u8d4b\u96f6\u548c\u5355\u70b9\u8d4b\u4e00\u64cd\u4f5c\u3002\n\n\u5206\u522b\u60f3\uff0c\u6bd4\u8f83\u5927\u5c0f\uff0c\u5373\u7ef4\u62a4\u533a\u95f4\u54c8\u5e0c\u503c\uff0c\u5148\u6bd4\u8f83\u9ad8\u4f4d\u5927\u5c0f\u662f\u5426\u76f8\u540c\uff0c\u82e5\u76f8\u7b49\u9012\u5f52\u4f4e\u4f4d\uff1b\u5426\u5219\u9012\u5f52\u9ad8\u4f4d\u5224\u65ad\u3002\n\n\u5bf9\u4e8e\u533a\u95f4\u8d4b\u96f6\uff0c\u6c38\u4e45\u5316\u6807\u8bb0\u8fc7\u4e8e\u9ebb\u70e6\uff0c\u627e\u5230\u5bf9\u5e94\u7684 $\\log$ \u4e2a\u533a\u95f4\uff0c\u63a5\u4e0a\u63d0\u524d\u9884\u5904\u7406\u597d\u7684\u5168\u96f6\u5b50\u6811\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u5355\u70b9\u8d4b\u4e00\uff0c\u677f\u5b50\u4e0d\u8bb2\u3002\n\n\u6700\u540e\u8003\u8651\u7a7a\u95f4\u95ee\u9898\uff0c\u56de\u987e\u6700\u77ed\u8def\u7b97\u6cd5\u677e\u5f1b\uff0c$dis_v$ \u4f1a\u7528\u5230 $dis_u$ \u7edd\u5927\u90e8\u5206\u503c\uff0c\u53ef\u6301\u4e45\u5316\u4e00\u4e0b\u5373\u53ef\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n\\log^2 n)$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ha putchar(' ')\n#define he putchar('\\n')\ninline int read()\n{\n\tint x = 0;\n\tchar c = getchar();\n\twhile (c < '0' || c > '9')c = getchar();\n\twhile (c >= '0' && c <= '9')\n\t\tx = (x << 3) + (x << 1) + (c ^ 48), c = getchar();\n\treturn x;\n}\ninline void write(int x)\n{\n\tif(x < 0) putchar('-'), x = -x;\n\tif(x > 9) write(x / 10);\n\tputchar(x % 10 + 48);\n}\n#define lc(o) tr[o].lc\n#define rc(o) tr[o].rc\n#define s(o) tr[o].s\n#define si(o) tr[o].si\n#define hs(o) tr[o].hs\nconst int _ = 1e5 + 100, N = 1e5 + 20, mod = 1e9 + 7;\nint n, m, s, t, cnt, p2[_], rt[_];\nint tot, head[_], to[_ << 1], nxt[_ << 1], w[_ << 1];\nbool vis[_]; int zct, zc[_], pre[_];\nstruct abc\n{\n\tint s, si, lc, rc; ll hs;\n} tr[_ * 80];\nvoid add(int u, int v, int d) {to[++tot] = v, nxt[tot] = head[u], w[tot] = d, head[u] = tot;}\nvoid pushup(int o)\n{\n\ts(o) = s(lc(o)) + s(rc(o));\n\ths(o) = (p2[si(lc(o))] * hs(rc(o)) % mod + hs(lc(o))) % mod;\n}\nvoid build(int &o, int l, int r)\n{\n\to = ++cnt, si(o) = r - l + 1;\n\tif(l == r) return;\n\tint mid = (l + r) >> 1;\n\tbuild(lc(o), l, mid), build(rc(o), mid + 1, r);\n\tpushup(o);\n}\nvoid upd1(int &a, int b, int l, int r, int x)\n{\n\ta = ++cnt, tr[a] = tr[b];\n\tif(l == r) return s(a)++, hs(a)++, void();\n\tint mid = (l + r) >> 1;\n\tx <= mid ? upd1(lc(a), lc(b), l, mid, x) : upd1(rc(a), rc(b), mid + 1, r, x);\n\tpushup(a);\n}\nvoid upd2(int &a, int b, int p0, int l, int r, int L, int R)\n{\n\tif(L <= l && r <= R) return a = p0, void();\n\ta = ++cnt, tr[a] = tr[b];\n\tint mid = (l + r) >> 1;\n\tif(L <= mid) upd2(lc(a), lc(b), lc(p0), l, mid, L, R);\n\tif(R > mid) upd2(rc(a), rc(b), rc(p0), mid + 1, r, L, R);\n\tpushup(a);\n}\nint qry(int o, int l, int r, int L, int R)\n{\n\tif(L <= l && r <= R) return s(o);\n\tint mid = (l + r) >> 1, ret = 0;\n\tif(L <= mid) ret = qry(lc(o), l, mid, L, R);\n\tif(R > mid) ret += qry(rc(o), mid + 1, r, L, R);\n\treturn ret;\n}\nint find(int o, int l, int r, int x, int c)\n{\n\tif(l == r) return l;\n\tint mid = (l + r) >> 1;\n\tif(s(lc(o)) >= mid - x + 1 + c) return find(rc(o), mid + 1, r, x, c - s(lc(o)));\n\treturn find(lc(o), l, mid, x, c);\n}\nvoid upd(int &a, int b, int x)\n{\n\tint c = x > 0 ? qry(b, 0, N, 0, x - 1) : 0;\n\tint y = find(b, 0, N, x, c);\n\tif(y > x) upd2(a, b, rt[0], 0, N, x, y - 1);\n\telse a = b;\n\tupd1(a, a, 0, N, y);\n}\nbool cmp(int a, int b, int l, int r)\n{\n\tif(l == r) return s(a) > s(b);\n\tint mid = (l + r) >> 1;\n\tif(hs(rc(a)) == hs(rc(b))) return cmp(lc(a), lc(b), l, mid);\n\treturn cmp(rc(a), rc(b), mid + 1, r);\n}\nstruct Node\n{\n\tint id, rt;\n\tbool operator < (const Node &t) const{return cmp(rt, t.rt, 0, N);}\n}; priority_queue<Node> q;\nvoid dij(int s)\n{\n\tbuild(rt[0], 0, N), rt[s] = rt[0];\n\tq.push({s, rt[s]});\n\twhile(!q.empty())\n\t{\n\t\tint nw = q.top().id;\n\t\tq.pop();\n\t\tif(vis[nw]) continue;\n\t\tvis[nw] = 1;\n\t\tif(nw == t) break;\n\t\tfor(int i = head[nw]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tupd(rt[n + 1], rt[nw], w[i]);\n\t\t\tif(!rt[v] || cmp(rt[v], rt[n + 1], 0, N))\n\t\t\t{\n\t\t\t\trt[v] = rt[n + 1];\n\t\t\t\tpre[v] = nw;\n\t\t\t\tif(!vis[v]) q.push({v, rt[v]});\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\tp2[0] = 1; for(int i = 1; i < N; ++i) p2[i] = p2[i - 1] * 2ll % mod;\n\tn = read(), m = read();\n\tfor(int i = 1, u, v, w; i <= m; ++i)\n\t{\n\t\tu = read(), v = read(), w = read();\n\t\tadd(u, v, w), add(v, u, w);\n\t}\n\ts = read(), t = read();\n\tdij(s);\n\tif(!vis[t]) return write(-1), he, 0;\n\twrite(hs(rt[t])), he;\n\tzc[zct = 1] = t;\n\twhile(t != s)\n\t{\n\t\tt = pre[t];\n\t\tzc[++zct] = t;\n\t}\n\twrite(zct), he;\n\tfor(int i = zct; i >= 1; --i)\n\t\twrite(zc[i]), ha;\n\treturn 0;\n}\n```",
        "postTime": 1657800241,
        "uid": 257146,
        "name": "orz_z",
        "ccfLevel": 0,
        "title": "CF464E The Classic Problem"
    },
    {
        "content": "~~\u7b80\u76f4\u505a\u5f97\u723d\u70b8\u4e86~~\n\n[\u9898\u4f20](https://www.luogu.com.cn/problem/CF464E)\n\n\u4ee5\u4e0b\u4ee4 $n, m, w$ \u540c\u9636\u3002\n\n\u8fb9\u6743\u6052\u6b63\uff0c\u663e\u7136\u4f7f\u7528 dijkstra\uff0c\u73b0\u5728\u8981\u89e3\u51b3\u9ad8\u7cbe\u7684\u95ee\u9898\uff0c\u6211\u4eec\u9700\u8981\u652f\u6301\u7684\u64cd\u4f5c\u6709\uff1a\u9ad8\u7cbe\u52a0 \u4e0e \u6bd4\u8f83\u5927\u5c0f\u3002\n\n\u6bd4\u8f83\u80af\u5b9a\u4e0d\u80fd $O(n)$ \u6bd4\uff0c\u8003\u8651\u4e0a\u54c8\u5e0c+\u4e8c\u5206\uff0c\u8fd9\u6837\u5c31\u80fd\u505a\u5230\u6bd4\u8f83\u590d\u6742\u5ea6 $O(\\log n)$\u3002\n\n\u6ce8\u610f\u5230\u52a0\u6cd5\u64cd\u4f5c\u662f\u5728\u4e8c\u8fdb\u5236\u4e0b\u5355\u70b9\u52a0\uff0c\u6240\u4ee5\u53ea\u4f1a\u51fa\u73b0\u4ee5\u4e0b\u4e24\u79cd\u60c5\u51b5\uff1a\n\n1. \u539f\u6765\u7684\u4e8c\u8fdb\u5236\u4e32\u7b2c $w$ \u4f4d\u4e3a 0\uff0c\u4fee\u6539\u6210 1 \u5373\u53ef\uff1b\n\n1. \u539f\u6765\u7684\u4e8c\u8fdb\u5236\u4e32\u7b2c $w$ \u4f4d\u4e3a 1\uff0c\u9700\u8981\u8fdb\u4f4d\uff0c\u4f46\u4e5f\u6709\u53ef\u80fd\u4ea7\u751f\u8fde\u7eed\u5730\u8fdb\u4f4d\uff0c\u9700\u8981\u627e\u5230\u4ece $w$ \u4f4d\u5f00\u59cb\u7684\u6781\u957f 1 \u8fde\u7eed\u6bb5\uff0c\u5168\u90e8\u8d4b\u4e3a 0\uff0c\u518d\u628a\u524d\u4e00\u4f4d\u6539\u4e3a 1\u3002\n\n\u8003\u8651\u5230\u52a0\u4e86\u4e4b\u540e\u8fd8\u8981\u7ef4\u62a4\u4e00\u4e2a\u54c8\u5e0c\u503c\uff0c\u4e14\u4fee\u6539\u7684\u662f\u4e00\u6bb5\u533a\u95f4\uff0c\u4e0a\u7ebf\u6bb5\u6811\u7ef4\u62a4\uff0c\u5bf9\u4e8e\u6bcf\u4e00\u4e2a\u503c\u4e0a\u90fd\u653e\u4e0a\u4e00\u4e2a\u7ebf\u6bb5\u6811\uff0c\u4f46\u8fd9\u6837\u7a7a\u95f4\u592a\u5927\u5403\u4e0d\u6d88\u3002\n\n\u53c8\u60f3\u5230\u6211\u4eec\u662f\u5728\u4e00\u4e2a\u539f\u6765\u7684\u503c\u4e0a\u9762\u4fee\u6539\uff0c\u90a3\u4e48\u628a\u7ebf\u6bb5\u6811\u53ef\u6301\u4e45\u5316\uff0c\u6539\u6210\u4e3b\u5e2d\u6811\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6 $O(n \\log^2 n)$\u3002\n\n### Code\uff1a\n\n```cpp\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <cctype>\n#include <stdlib.h>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\nconst int INF=0x3f3f3f3f;\nconst unsigned int P=19260817;\nconst int mo=1e9+7;\ninline int read(){\n\tchar ch=getchar();int x=0, f=1;\n\twhile(!isdigit(ch)){if(ch=='-') f=-1; ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline void write(int x){\n    if(x<0) putchar('-'), x=-x;\n    if(x>9) write(x/10);\n    putchar(x%10+'0');\n}\ninline int ksm(int a, int b){\n\tint ret=1;\n\tfor(; b; b>>=1, a=1ll*a*a%mo)\n\t\tif(b&1) ret=1ll*ret*a%mo;\n\treturn ret;\n}\nconst int N=1e5+50;\nconst int S=100020;\nunsigned int H[S+5];\nint n, m, pre[N], msk[S+5], cnt, root[N];\n#define ls d[k].lc\n#define rs d[k].rc\n#define mid (l+r>>1) \nstruct Node{int lc, rc, cnt1;unsigned int hsah;}d[N*100];\ninline void pushup(int k, int len){\n\td[k].cnt1=d[ls].cnt1&d[rs].cnt1;\n\td[k].hsah=d[ls].hsah+d[rs].hsah*H[len];\n}\ninline void build(int &k, int l, int r, int v){\n\tk=++cnt;\n\tif(l==r){d[k].hsah=d[k].cnt1=v;return ;} \n\tbuild(ls, l, mid, v);build(rs, mid+1, r, v);\n\tpushup(k, mid-l+1);\n}\nint cmb(int a, int b){return a==b?0:(a<b?-1:1);}\ninline int CMP(int p, int q, int l, int r){\n\tif(l==r) return cmb(d[p].hsah, d[q].hsah);\n\tif(d[d[p].rc].hsah!=d[d[q].rc].hsah) return CMP(d[p].rc, d[q].rc, mid+1, r);\n\telse return CMP(d[p].lc, d[q].lc, l, mid);\n}\ninline int find(int k, int l, int r){//\u627e\u5230\u8fd9\u4e00\u6bb5\u5185\u6700\u53f3\u7684\uff08\u56e0\u4e3a\u7ebf\u6bb5\u6811\u4e0a\u7684\u4e32\u662f\u53cd\u8fc7\u6765\u7684\uff09 \n\tif(d[k].cnt1) return r;\n\tif(l==r) return -1;\n\tint L=find(ls, l, mid), R=-1;\n\tif(L==mid) R=find(rs, mid+1, r);\n\treturn max(L, R);\n}\ninline int position(int k, int l, int r, int x){\n\tif(x<=l) return find(k, l, r);int L=-1, R=-1;\n\tif(x<=mid){\n\t\tL=position(ls, l, mid, x);\n\t\tif(L==mid) R=position(rs, mid+1, r, x);\n\t\treturn max(L, R);\n\t}\n\telse return position(rs, mid+1, r, x);\n}\ninline void change(int &k, int X, int Y, int l, int r, int x, int y){\n\tif(x<=l&&r<=y){k=Y;return ;}\n\tk=++cnt;d[k]=d[X];\n\tif(x<=mid) change(ls, d[X].lc, d[Y].lc, l, mid, x, y);\n\tif(mid<y) change(rs, d[X].rc, d[Y].rc, mid+1, r, x, y);\n\treturn pushup(k, mid-l+1);\n}\ninline void modify(int &k, int pre, int l, int r, int x){\n\tk=++cnt;;d[k]=d[pre];if(l==r){d[k].cnt1=d[k].hsah=1;return ;}\n\tif(x<=mid) modify(ls, d[pre].lc, l, mid, x);\n\telse modify(rs, d[pre].rc, mid+1, r, x);\n\treturn pushup(k, mid-l+1);\n}\nint Add(int rt, int v){\n\tint pos=position(rt, 0, S, v);\n\tint ret=rt;\n\tif(pos<0) pos=v-1;\n\telse change(ret, rt, root[0], 0, S, v, pos);\n\tint ans;modify(ans, ret, 0, S, pos+1);\n\treturn ans;\n}\n#undef ls\n#undef rs\n#undef mid\nint h[N], tot, dis[N];\nbool vis[N]; \ndeque <int> ans;\nstruct Edge{int to, nxt, w;}e[N*2];\nvoid add(int x, int y, int z){e[++tot]=(Edge){y, h[x], z};h[x]=tot;}\nstruct data{\n\tint x, id;\n\tbool operator < (const data &X) const{return CMP(id, X.id, 1, S)>0;}\n};\nvoid dij(){\n\tbuild(root[0], 0, S, 0), build(root[n+1], 0, S, 1);\n\tint s=read(), t=read();root[s]=root[0];\n\tpriority_queue <data> Q;Q.push((data){s, root[s]});dis[s]=0;\n\tfor(int i=1; i<=n; i++)\n\t\tif(i!=s) root[i]=root[n+1];\n\twhile(!Q.empty()){\n\t\tdata pos=Q.top();Q.pop();\n\t\tint x=pos.x, id=pos.id;\n\t\tif(vis[x]) continue;vis[x]=1;\n\t\tfor(int i=h[x], v, w; i; i=e[i].nxt){\n\t\t\tv=e[i].to, w=e[i].w;\n\t\t\tint newrt=Add(id, w);\n\t\t\tif(CMP(newrt, root[v], 0, S)<0){\n//\t\t\t\tputs(\"Acepet\");\n\t\t\t\tdis[v]=(dis[x]+msk[w])%mo;\n\t\t\t\troot[v]=newrt, pre[v]=x;\n\t\t\t\tQ.push((data){v, root[v]});\n\t\t\t}\n\t\t}\n\t}\n\tif(vis[t]){\n\t\tprintf(\"%d\\n\", dis[t]);\n\t\twhile(t!=s) ans.push_back(t), t=pre[t];ans.push_back(s);\n\t\tprintf(\"%d\\n\", ans.size());\n\t\twhile(!ans.empty()) printf(\"%d \", ans.back()), ans.pop_back();\n\t\treturn ;\n\t}\n\tputs(\"-1\");\n}\nsigned main(){\n\tn=read(), m=read();\n\tfor(int i=1, x, y, z; i<=m; i++)\n\t\tx=read(), y=read(), z=read(),\n\t\tadd(x, y, z), add(y, x, z);\n\tmsk[0]=1, H[0]=1;\n\tfor(int i=1; i<=S; i++)\n\t\tmsk[i]=1ll*msk[i-1]*2%mo,\n\t\tH[i]=H[i-1]*P;\n\tdij();\n\treturn 0;\n}\n\n```\n",
        "postTime": 1630216836,
        "uid": 341102,
        "name": "ReKoJ",
        "ccfLevel": 0,
        "title": "CF464E The Classic Problem"
    },
    {
        "content": "\u6700\u77ed\u8def\uff0c\u4f46\u662f\u8fb9\u957f\u662f 2 \u7684\u5e42\u6b21\u3002\n\n\u5982\u679c\u786c\u5199\u9ad8\u7cbe\u5ea6\u80af\u5b9a\u8d85\u65f6\uff0c\u53c8\u56e0\u4e3a\u8f6c\u79fb\u662f\u4e00\u4e2a\u4e8c\u8fdb\u5236\u6570\u53ea\u5728\u67d0\u4e00\u4f4d $+1$\uff0c\u6240\u4ee5\u8003\u8651\u7528\u4e3b\u5e2d\u6811\u7684\u7ee7\u627f\u601d\u60f3\u7ef4\u62a4\u3002\n\n---\n\n### \u52a0\u6cd5\uff1a\n\n\u53ef\u80fd\u6709\u8fdb\u4f4d\u7684\u60c5\u51b5\uff0c\u8fd9\u4e2a\u65f6\u5019\u5c31\u9700\u8981\u627e\u5230\u7ebf\u6bb5\u6811\u4e0a\u7b2c\u4e00\u4e2a\u6bd4\u52a0\u7684\u6570\u4f4d\u9ad8\u4e14\u4e3a $0$ \u7684\u4f4d\u7f6e\uff0c\u53ef\u4ee5\u5728\u6bcf\u4e2a\u533a\u95f4\u4e0a\u7ef4\u62a4\u4e00\u4e2a\u662f\u5426\u4e3a\u5168 $1$ \u7684\u6807\u8bb0\uff0c\u5b9e\u73b0 $\\Theta(\\log^2 n)$ \u7684\u67e5\u627e\u3002\n\n\u627e\u5230\u4f4d\u7f6e\u540e\u5c06\u5f53\u524d\u4f4d $+1$\uff0c\u52a0\u6cd5\u4f4d\u5230\u5f53\u524d\u4f4d\u4e4b\u524d\u7684\u533a\u95f4\u7f6e\u4e3a $0$\u3002\n\n---\n\n### \u6bd4\u8f83\uff1a\n\n\u66b4\u529b\u9010\u4f4d\u6bd4\u8f83\u663e\u7136\u662f $\\Theta(n)$ \u7684\uff0c\u8003\u8651\u590d\u6742\u5ea6\u74f6\u9888\u5728\u54ea\u91cc\uff1a\u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d\u627e\u5230\u7b2c\u4e00\u4e2a**\u4e0d\u76f8\u540c**\u7684\u4f4d\u7f6e\uff0c\u6bd4\u8f83\u4e4b\u3002\n\n\u5982\u679c\u80fd\u5feb\u901f\u786e\u5b9a\u4e24\u4e2a\u533a\u95f4\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u6570\u662f\u5426\u5b8c\u5168\u76f8\u540c\uff0c\u5c31\u53ef\u4ee5\u7528\u4e8c\u5206\u5b9e\u73b0 $\\Theta(\\log n)$ \u7684\u6bd4\u8f83\u3002\n\n\u4e8e\u662f\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u6bcf\u4e2a\u533a\u95f4\u7ef4\u62a4\u5bf9\u5e94\u4e8c\u8fdb\u5236\u6570\u7684\u54c8\u5e0c\u503c\uff08\u53cc\u54c8\u5e0c\u4fdd\u9669\uff09\u3002\n\n\u9898\u76ee\u8be2\u95ee\u7684\u662f\u957f\u5ea6 $\\% (10^9+7)$ \u7684\u503c\uff0c\u90a3\u5176\u4e2d\u4e00\u4e2a hash \u53c2\u6570\u53ef\u4ee5\u9009 $base = 2,mod = 10^9+7$ \u7684\u65b9\u4fbf\u76f4\u63a5\u56de\u7b54\u3002\n\n### \u6700\u77ed\u8def\uff1a\n\ndijkstra \u5957\u4e0a\u6570\u636e\u7ed3\u6784\u5373\u53ef\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u70b9\u5165\u961f\u7684\u65f6\u5019\u9700\u8981\u5b58\u50a8\u5f53\u65f6\u5bf9\u5e94\u7684\u6811\u6839\uff0c\u56e0\u4e3a\u5728\u4e4b\u540e\u70b9\u7684\u8ddd\u79bb\u503c\u53ef\u80fd\u88ab\u66f4\u65b0\uff0c\u6811\u6839\u4f1a\u53d8\uff0c\u4f18\u5148\u961f\u5217\u7ef4\u62a4\u4f1a\u51fa\u9505\u3002\n\n[CODE](https://www.luogu.com.cn/paste/e8zraw0k)",
        "postTime": 1653094173,
        "uid": 90027,
        "name": "GG_jok_er",
        "ccfLevel": 0,
        "title": "CF464E The Classic Problem \u9898\u89e3"
    },
    {
        "content": "\u679c\u7136\u662f\u7ecf\u5178\u95ee\u9898\u3002\n\n\n------------\n\n\n\u9996\u5148\u6700\u77ed\u8def\u80af\u5b9a\u8fd8\u662f\u8981\u7528 dijkstra \uff0c\u53ef\u662f\u7531\u4e8e\u6570\u5b57\u5f88\u5927\uff0c\u4e0d\u80fd\u76f4\u63a5\u64cd\u4f5c\uff0c\u6211\u4eec\u8003\u8651\u7528\u6570\u636e\u7ed3\u6784\u6765\u8fdb\u884c\u7ef4\u62a4\u3002\n\n\n------------\n\n\u9996\u5148\u6211\u4eec\u8981\u652f\u6301\u7684\u64cd\u4f5c\u662f\u6bd4\u8f83\u4e24\u4e2a\u6570\u7684\u5927\u5c0f\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u7ecf\u5178\u5957\u8def\u5c31\u662f Hash \uff0c\u7136\u540e\u4e8c\u5206 LCP\u3002\n\n\n------------\n\n\n\u7136\u540e\u6211\u4eec\u8981\u652f\u6301\u7684\u662f\u5bf9\u67d0\u4e00\u4f4d\u52a0 $1$\uff0c\u7136\u540e\u590d\u5236\u3002\u7531\u4e8e\u6709\u8fd9\u4e2a\u590d\u5236\u64cd\u4f5c\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u4e3b\u5e2d\u6811\u8fdb\u884c\u7ef4\u62a4\u3002\u4f46\u662f\u8fd9\u4e2a\u52a0 $1$ \u53ef\u80fd\u4f1a\u9047\u5230\u8fdb\u4f4d\uff0c\u600e\u4e48\u624d\u80fd\u5feb\u901f\u5bf9\u67d0\u4e00\u4f4d\u52a0 $1$ \u5462\uff1f\n\n\u6211\u4eec\u8003\u8651\u7528\u7ebf\u6bb5\u6811\u4e8c\u5206\u67e5\u627e\u4ece\u4e00\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5411\u540e\u7684\u6700\u957f $1$ \u6bb5\u3002\u7136\u540e\u6211\u4eec\u7684\u64cd\u4f5c\u5c31\u53d8\u6210\u628a\u4e00\u6bb5\u533a\u95f4\u8d4b\u4e3a $0$\uff0c\u7136\u540e\u5355\u70b9\u4fee\u6539\u3002\n\n\u533a\u95f4\u8d4b\u503c\u76f4\u63a5\u628a\u513f\u5b50\u8fde\u5230\u8d77\u70b9\u6240\u4ee3\u8868\u7684\u7684\u90a3\u68f5\u6811\u4e0a\u5373\u53ef\u3002\n\n\u8f93\u51fa\u8def\u5f84\u7684\u8bdd\uff0c\u76f4\u63a5\u5728 dijkstra \u65f6\u8bb0\u5f55\u4e0a\u4e00\u4e2a\u7684\u70b9\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6 $O(n \\log^2 n )$\n\n\n------------\n\n\n\u6ce8\u610f\uff1a\n\n1. \u4e3b\u5e2d\u6811\u8981\u4ece $0$ \u5f00\u59cb\u7ef4\u62a4\uff0c\u6700\u5927\u503c\u8981\u7565\u5fae\u8d85\u8fc7 $10^5$\uff0c\u5982 $10^5+100$\uff0c\u56e0\u4e3a\u52a0\u548c\u540e\u53ef\u80fd\u4f1a\u8d85\u8fc7\u3002\n\n2. \u7528 dijkstra \u65f6\u8bbf\u95ee\u5230\u5df2\u7ecf\u6539\u8fc7\u7684\u8282\u70b9\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u4e0d\u7136\u8981\u591a\u6bd4\u4e00\u6b21\u5927\u5c0f\uff0c\u6d6a\u8d39\u7a7a\u95f4\u3002 \n\n\n------------\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n// Problem: CF464E The Classic Problem\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF464E\n// Memory Limit: 750 MB\n// Time Limit: 5000 ms\n// 2022-03-10 19:24:03\n// Author : louhao088\n#include<bits/stdc++.h>\nusing namespace std;\n//static char buf[1000000],*p1=buf,*p2=buf;\n//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++\n#define pi pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define mid (l+r>>1)\n#define lowbit (x&-x)\nconst int maxn=1e5+105,M=34005,mod=1e9+7,mod2=1396716913;\ninline int read()\n{\n\tchar ch=getchar();bool f=0;int x=0;\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);\n\tif(f==1)x=-x;return x;\n}\ninline void print(int x)\n{\n    static int a[55];int top=0;\n    if(x<0) putchar('-'),x=-x;\n    do{a[top++]=x%10,x/=10;}while(x);\n    while(top) putchar(a[--top]+48);\n}\nint n,m,x,y,z,S,T,rt[maxn],las[maxn],ans[maxn],g,ls[maxn*200],rs[maxn*200],sum[maxn*200],tot=0;\nbool vis[maxn];\nvector<pi>e[maxn];\nstruct Hash\n{\n\tint x,y;\n\tHash operator +(const Hash &k)const{return{(x+k.x)%mod,(y+k.y)%mod2};}\n\tHash operator -(const Hash &k)const{return{(x-k.x+mod)%mod,(y-k.y+mod2)%mod2};}\n\tHash operator *(const Hash &k)const{return{1ll*x*k.x%mod,1ll*y*k.y%mod2};}\n\tbool operator ==(const Hash &k)const{return x==k.x&&y==k.y;}\n}base,fac[maxn],s[maxn*200];\nbool cmp(int rt,int rt1,int l,int r)\n{\n\tif(l==r){return sum[rt]<sum[rt1];}\n\tif(s[rs[rt]]==s[rs[rt1]])return cmp(ls[rt],ls[rt1],l,mid);\n\telse return cmp(rs[rt],rs[rt1],mid+1,r);\n}\nint query(int rt,int l,int r,int L,int R)\n{\n\tif(l>R||r<L)return 0;\n\tif(l>=L&&r<=R)return sum[rt];\n\treturn query(ls[rt],l,mid,L,R)+query(rs[rt],mid+1,r,L,R);\n}\nvoid build(int &rt,int l,int r)\n{\n\trt=++tot;s[rt]={0,0};sum[rt]=0;\n\tif(l==r)return;build(ls[rt],l,mid);build(rs[rt],mid+1,r);\n}\nint find(int rt,int l,int r,int pos)\n{\n\tif(l==r)return l;\n\tif(mid<pos)return find(rs[rt],mid+1,r,pos);\n\telse if(query(rt,l,r,pos,mid)==mid-pos+1)return find(rs[rt],mid+1,r,mid+1);\n\telse return find(ls[rt],l,mid,pos);\n}\nvoid add(int &rt,int rt1,int l,int r,int pos)\n{\n\tif(l>pos||r<pos)return;rt=++tot;\n\tls[rt]=ls[rt1],rs[rt]=rs[rt1];s[rt]=s[rt1];sum[rt]=sum[rt1];\n\tif(l==r){s[rt]={1,1};sum[rt]=1;return;}\n\tadd(ls[rt],ls[rt1],l,mid,pos);add(rs[rt],rs[rt1],mid+1,r,pos);\n\ts[rt]=s[rs[rt]]*fac[mid-l+1]+s[ls[rt]];sum[rt]=sum[ls[rt]]+sum[rs[rt]];\n}\nvoid change(int &rt,int rt1,int rt2,int l,int r,int L,int R)\n{\n\tif(l>R||r<L)return;rt=++tot;\n\tls[rt]=ls[rt1],rs[rt]=rs[rt1];s[rt]=s[rt1];sum[rt]=sum[rt1];\n\tif(l>=L&&r<=R){ls[rt]=ls[rt2],rs[rt]=rs[rt2];s[rt]=s[rt2;sum[rt]=sum[rt2];return;}\n\tchange(ls[rt],ls[rt1],ls[rt2],l,mid,L,R);change(rs[rt],rs[rt1],rs[rt2],mid+1,r,L,R);\n\ts[rt]=s[rs[rt]]*fac[mid-l+1]+s[ls[rt]];sum[rt]=sum[ls[rt]]+sum[rs[rt]];\n}\nvoid upd(int &Rt,int rt1,int pos)\n{\n\tint x=find(rt1,0,n,pos);add(Rt,rt1,0,n,x);\n\tif(pos<x)change(Rt,Rt,rt[S],0,n,pos,x-1);\n}\nstruct node{int x,rt;bool operator < (const node &a)const{return cmp(a.rt,rt,0,n);}};\nvoid dij(int S)\n{\n\tpriority_queue<node>q;q.push({S,rt[S]});\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().x;q.pop();\n\t\tif(vis[x])continue;vis[x]=1;\n\t\tif(x==T)break;\n\t\tfor(auto i:e[x])\n\t\t{\n\t\t\tif(vis[i.fi])continue;\n\t\t\tint Rt;upd(Rt,rt[x],i.se);\n\t\t\tif(!rt[i.fi]||cmp(Rt,rt[i.fi],0,n))rt[i.fi]=Rt,q.push({i.fi,Rt}),las[i.fi]=x;\n\t\t}\n\t}\n\tif(!vis[T])puts(\"-1\"),exit(0);\n}\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tg=read(),m=read();\n\tfor(int i=1;i<=m;i++)\n\t\tx=read(),y=read(),z=read(),e[x].pb(mp(y,z)),e[y].pb(mp(x,z));\n\tn=1e5+50;base={2,17};fac[0]={1,1};\n\tfor(int i=1;i<=n;i++)fac[i]=fac[i-1]*base;\n\tS=read(),T=read();build(rt[S],0,n);dij(S);\n\tcout<<s[rt[T]].x<<endl;int cnt=0;\n\tfor(int i=T;i;i=las[i])ans[++cnt]=i;cout<<cnt<<endl;\n\tfor(int i=cnt;i>=1;i--)printf(\"%d \",ans[i]);\n \treturn 0;\n}\n\n\n```\n",
        "postTime": 1646984472,
        "uid": 343748,
        "name": "louhao088",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF464E The Classic Problem"
    },
    {
        "content": "\u6cbf\u7528 dij \u7684\u601d\u8def\uff0c\u5982\u679c\u76f4\u63a5\u7ef4\u62a4 $01$ \u4e32\u6bd4\u8f83\u548c\u5355\u70b9\u52a0\u90fd\u662f $O(x)$ \u7684\uff0c\u65e0\u6cd5\u627f\u53d7\u3002\u8003\u8651\u4ece\u9ad8\u5230\u4f4e\u5728 $01$ \u4e32\u4e0a\u5efa\u7acb\u4e00\u68f5\u52a8\u6001\u5f00\u70b9\u7684\u7ebf\u6bb5\u6811\uff0c\u7ef4\u62a4\u533a\u95f4\u54c8\u5e0c\u503c\uff0c\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5c31\u53ef\u4ee5\u505a\u5230\u5355\u6b21 $O(\\log n)$ \u6bd4\u8f83\u4e24\u4e2a\u4e32\u7684\u5927\u5c0f\u3002\u800c dij \u8fd8\u8981\u652f\u6301\u4e00\u4e2a\u64cd\u4f5c\u662f\u628a $dis_y$ \u4e0e $dis_x+v$ \u6bd4\u8f83\uff0c\u540e\u8005\u628a\u5355\u70b9\u52a0\u53ef\u6301\u4e45\u5316\u6389\uff0c\u989d\u5916\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u6240\u6709\u6570\u662f\u5426\u5747\u4e3a $1$ \u7684\u4fe1\u606f\uff0c\u5728\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\uff0c\u7528 $O(\\log n)$ \u6bb5\u533a\u95f4\u62fc\u51fa\u4ee5\u8be5\u70b9\u4e3a\u7ed3\u5c3e\u7684\u6781\u957f $1$ \u6bb5\uff0c\u5168\u90e8\u6e05\u96f6\u5e76\u628a\u4e0b\u4e00\u4e2a\u4f4d\u7f6e\u53d8\u6210 $1$\uff0c\u8fd9\u4e9b\u90fd\u662f\u7ecf\u5178\u7ebf\u6bb5\u6811\u64cd\u4f5c\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(m\\log^2n+m\\log n)$\u3002\n\n\u987a\u5e26\u4e00\u63d0\u8fd9\u9898\u8fd8\u6709\u5f88\u591a\u9634\u95f4\u6570\u636e\uff0c\u6bd4\u5982 $m=0$\uff0c$s=t$\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n//author:\u671b\u8fdc\u661f \n#include<bits/stdc++.h>\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define sml(x,y) (x=min(x,y))\n#define big(x,y) (x=max(x,y))\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define fo(i,x,y) for(int i=x;i<=y;++i)\n#define go(i,x,y) for(int i=x;i>=y;--i)\nusing namespace std;\null seed=chrono::system_clock::now().time_since_epoch().count();\nmt19937 rnd(seed);\ninline int rm(int x,int y){return rnd()%(y-x+1)+x;}\ninline int read(){ int x=0,f=1; unsigned char ch=getchar()-48; while(ch>9){ if(ch==253) f=-1; ch=getchar()-48; } while(ch<=9){ x=x*10+ch; ch=getchar()-48; } return x*f; }\ninline void out(int *a,int l,int r){fo(i,l,r) cout<<*(a+i)<<' ';puts(\"\");}\n\nconst int N=1.1e5+5,base1=3,base2=29,mod1=1e9+7,mod2=998244353;\nstruct Edge{\n\tint to,next,val;\n}e[N<<1];\nint pw1[N],pw2[N],n,m,head[N],tot,root[N],V,num;\n\nvoid connect(int x,int y,int v){\n\te[++tot]=(Edge){y,head[x],v};\n\thead[x]=tot; \n}\n\nstruct Node{\n\tint lt,rt,hx1,hx2,tag,ok;\n\tNode(){lt=rt=hx1=hx2=tag=ok=0;}\n\tvoid rep(){hx1=hx2=ok=0;tag=1;}\n\tvoid outit(){printf(\"%d,%d hx1=%d hx2=%d tag=%d ok=%d\\n\",lt,rt,hx1,hx2,tag,ok);} \n}tree[N*100];\n\n#define ls(x) tree[x].lt\n#define rs(x) tree[x].rt\nvoid push_up(int x,int l,int r){\n\ttree[x].ok=tree[ls(x)].ok&tree[rs(x)].ok;\n\tint mid=(l+r)>>1;\n\ttree[x].hx1=(tree[ls(x)].hx1+1ll*tree[rs(x)].hx1*pw1[mid-l+1])%mod1;\n\ttree[x].hx2=(tree[ls(x)].hx2+1ll*tree[rs(x)].hx2*pw2[mid-l+1])%mod2;\n}\n\nvoid push_down(int x){\n\tif(!tree[x].tag||!x) return;\n\ttree[++num]=tree[ls(x)];ls(x)=num;\n\ttree[++num]=tree[rs(x)];rs(x)=num;\n\ttree[ls(x)].rep();tree[rs(x)].rep();\n\ttree[x].tag=0;\n}\n\nstruct cmp{\n\tbool operator()(int x,int y)const{\n\t\tint l=1,r=V;\n\t\tx=root[x],y=root[y];\n\t\tif(tree[x].hx1==tree[y].hx1&&tree[x].hx2==tree[y].hx2) return x<y;\n\t\twhile(l<r){\n\t\t\tpush_down(x),push_down(y);\n\t\t\tif(tree[rs(x)].hx1!=tree[rs(y)].hx1||tree[rs(x)].hx2!=tree[rs(y)].hx2){\n\t\t\t\tx=rs(x),y=rs(y);\n\t\t\t\tl=(l+r)/2+1;\n\t\t\t}else x=ls(x),y=ls(y),r=(l+r)>>1;\n\t\t}\n\t\treturn tree[x].hx1<tree[y].hx1;\n\t}\n}A;\n//\u6ce8\u610f\u5728\u8fd9\u91cc\u662f\u5bf9 [1,V] \u5efa\u7ebf\u6bb5\u6811 \n\nvoid modify(int &x,int l,int r,int aim,int &y){//\u628a aim \u6539\u6210 1 \n\t//printf(\"modify(%d,%d,%d,%d,%d)\\n\",x,l,r,aim,y);\n\ty=++num;tree[y]=tree[x];\n\tif(l==r){\n\t\ttree[y].hx1=tree[y].hx2=tree[y].ok=1;\n\t\treturn;\n\t}\n\tpush_down(x),push_down(y);\n\tint mid=(l+r)>>1;\n\tif(aim<=mid) modify(ls(x),l,mid,aim,ls(y));\n\telse modify(rs(x),mid+1,r,aim,rs(y));\n\tpush_up(y,l,r);\n}\n\nint solve(int x,int l,int r,int L){\n\tif(!x) return max(l,L);\n\tif(tree[x].ok) return r+1;\n\tif(l==r) return l;\n\tpush_down(x);\n\tint mid=(l+r)>>1;\n\tif(L<=mid){\n\t\tint R=solve(ls(x),l,mid,L);\n\t\tif(R<=mid) return R;\n\t\treturn solve(rs(x),mid+1,r,L);\n\t}else return solve(rs(x),mid+1,r,L);\n}\n\nvoid update(int &x,int l,int r,int L,int R){\n\t//if(!x) x=++num;\n\ttree[++num]=tree[x];x=num;\n\t//printf(\"update(%d,%d,%d,%d,%d)\\n\",x,l,r,L,R);\n\tif(l>=L&&r<=R){\n\t\t//tree[++num]=tree[x];\n\t\t//\u53ef\u6301\u4e45\u5316\uff0c\u5373\u4f7f\u5728\u539f\u7248\u672c\u4e0a\u6539\u4e5f\u9700\u8981\u65b0\u5efa\u7ed3\u70b9\uff0c\u4e0d\u7136\u4f1a\u5f71\u54cd\u5176\u4ed6\u5171\u4eab\u8be5\u7ed3\u70b9\u7684\u7248\u672c \n\t\t//x=num;\n\t\t//printf(\"real upd is %d\\n\",x);\n\t\ttree[x].rep();\n\t\treturn;\n\t}\n\tpush_down(x);\n\tint mid=(l+r)>>1;\n\tif(L<=mid) update(ls(x),l,mid,L,R);\n\tif(R>mid) update(rs(x),mid+1,r,L,R);\n\tpush_up(x,l,r);\n}\n\nint mi[N],ans,pre[N];\n\nvoid dfs(int x,int l,int r){\n\t//printf(\"dfs(%d,%d,%d)\\n\",x,l,r);\n\tif(l==r){\n\t\t//printf(\"v=%d %d\\n\",tree[x].hx1,tree[x].ok);\n\t\tans=(ans+1ll*tree[x].hx1*mi[l-1])%mod1;\n\t\treturn;\n\t}\n\tpush_down(x);\n\tint mid=(l+r)>>1;\n\tdfs(ls(x),l,mid);\n\tdfs(rs(x),mid+1,r);\n}\n\nint dlt[N];\n\nvoid outit(){\n\tout(root,1,n);\n\tfo(i,1,num) cout<<i<<':',tree[i].outit();\n}\n\nsigned main(){\n\tcin>>n>>m;\n\tfo(i,1,m){\n\t\tint x=read(),y=read(),v=read()+1;\n\t\tconnect(x,y,v);\n\t\tconnect(y,x,v);\n\t\tbig(V,v);\n\t}\n\tif(m) V+=ceil(log2(m)+3);\n\telse V+=3;\n\tpw1[0]=pw2[0]=1;fo(i,1,V) pw1[i]=1ll*pw1[i-1]*base1%mod1,pw2[i]=1ll*pw2[i-1]*base2%mod2;\n\tmi[0]=1;fo(i,1,V) mi[i]=(mi[i-1]<<1)%mod1;\n\tset<int,cmp> q;\n\tint s=read(),t=read();\n\tif(s==t){\n\t\tprintf(\"0\\n1\\n%d\\n\",s);\n\t\treturn 0;\n\t}\n\troot[s]=++num;q.insert(s);\n\tfo(i,1,n) if(i!=s) modify(root[s],1,V,V,root[i]);\n\t//outit();\n\twhile(!q.empty()){\n\t\tint x=*(q.begin());q.erase(q.begin());\n\t\tif(dlt[x]) continue;\n\t\tdlt[x]=1;\n\t\tfor(int i=head[x];i;i=e[i].next){\n\t\t\tint p=e[i].to;\n\t\t\tif(dlt[p]) continue;\n\t\t\tint R=solve(root[x],1,V,e[i].val),y=0;\n\t\t\t//printf(\"%d->%d [%d,%d]\\n\",x,p,e[i].val,R);\n\t\t\tmodify(root[x],1,V,R,y);\n\t\t\t//printf(\"y=%d\\n\",y);\n\t\t\tif(R>e[i].val) update(y,1,V,e[i].val,R-1);\n\t\t\troot[n+1]=y;\n\t\t\tif(A(n+1,p)) q.erase(p),root[p]=y,q.insert(p),pre[p]=x;//puts(\"ok\"),\n\t\t\t//if(x==2&&p==3) outit();\n\t\t\t//if(x==3&&p==4) outit(); \t\t\n\t\t}\n\t}\n\tif(!pre[t]) return puts(\"-1\"),0;\n\t//outit();\n\tdfs(root[t],1,V);\n\tcout<<ans<<'\\n';\n\tvector<int> qaq;\n\tint x=t;\n\twhile(x){\n\t\tqaq.pb(x);\n\t\tx=pre[x];\n\t}\n\treverse(qaq.begin(),qaq.end());\n\tcout<<qaq.size()<<'\\n';\n\tfor(auto i:qaq) cout<<i<<' ';\n\treturn 0;\n}\n/*\n4 4\n1 4 2\n1 2 0\n2 3 0\n3 4 0\n1 4\n-------------------------------------------------\n3\n4\n1 2 3 4 \n*/\n\n```\n",
        "postTime": 1645439604,
        "uid": 238408,
        "name": "vectorwyx",
        "ccfLevel": 8,
        "title": "CF464E The Classic Problem"
    },
    {
        "content": "\u6211\u4eec\u53d1\u73b0,\u5982\u679c\u8fd9\u9898\u7684\u8fb9\u6743\u6ca1\u6709\u8fd9\u4e48\u5927,\u90a3\u8fd9\u5c31\u662f\u6700\u77ed\u8def\u677f\u5b50,\u4f46\u662f\u8fd9\u9898\u8fb9\u6743\u5927\u5230\u65e0\u6cd5\u76f4\u63a5\u6bd4\u8f83,\u4e8e\u662f\u6211\u4eec\u8003\u8651\u7528\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u53bb\u7ef4\u62a4\u5b83,\u6211\u4eec\u9700\u8981\u5b9e\u73b0\u6bd4\u8f83\u4ee5\u53ca\u52a0\u6cd5.\n\n\u6211\u4eec\u53ef\u4ee5\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u8fd9\u4e2a\u4e1c\u897f,\u6bcf\u4e2a\u8282\u70b9$[l,r]$\u8868\u793a$2^l-2^r,01$\u7684\u72b6\u6001.\n\n\u5bf9\u4e8e\u52a0\u6cd5,\u6211\u4eec\u9700\u8981\u60f3\u529e\u6cd5\u65b9\u4fbf\u7684\u5b9e\u73b0\u8fdb\u4f4d,\u8003\u8651\u5982\u4f55\u5b9e\u73b0\u8fd9\u4e2a\u4e1c\u897f,\u5bf9\u4e8e\u4e00\u4e2a\u533a\u95f4$l,r$\u5047\u8bbe\u67e5\u8be2\u70b9\u5728\u4e2d\u70b9\u53f3\u65b9,\u90a3\u4e48\u6211\u4eec\u5c31\u76f4\u63a5\u67e5\u8be2\u53f3\u533a\u95f4,\u5982\u679c\u67e5\u8be2\u70b9\u5728\u5de6\u65b9,\u6211\u4eec\u5c31\u5728$add$\u7684\u65f6\u5019\u8bb0\u4e00\u4e2a$0/1$\u8868\u793a\u662f\u5426\u8fdb\u4f4d\u7136\u540e\u5982\u679c\u8fdb\u4f4d\u5c31\u5728\u52a0\u4e00\u4e0b\u5c31\u597d\u4e86.\n\n\u5bf9\u4e8e\u6bd4\u8f83,\u6211\u4eec\u8003\u8651\u8bb0\u4e00\u4e2ahash\u503c,\u5982\u679c\u53f3\u533a\u95f4\u76f8\u540c\u5c31\u67e5\u8be2\u5de6\u533a\u95f4,\u5982\u679c\u4e0d\u540c\u5c31\u67e5\u8be2\u53f3\u533a\u95f4,\u7136\u540e\u5230\u5b50\u8282\u70b9\u65f6\u76f4\u63a5\u8fd4\u56de\u5927\u5c0f\u5173\u7cfb\u5373\u53ef.\n\n\u5b9e\u73b0\u975e\u5e38\u7b80\u4fbf(\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=514514,md=1e9+7;\nint hd[N],nt[N*2],to[N*2],d[N*2],pw2[N*2],rt[N],pr[N];\nint n,m,s,t,mx,tt=0,ct=0;\nvoid add(int x,int y,int z){nt[++ct]=hd[x];to[ct]=y;hd[x]=ct;d[ct]=z;}\nstruct seg{int ls,rs,w;}tr[N<<5];\nbool bij(int x,int y,int l,int r){\n\tif(l==r)return tr[x].w>tr[y].w;//\u5b50\u8282\u70b9\u8fd4\u56de\u5927\u5c0f\u5173\u7cfb\n\tint mi=(l+r)>>1;\n\tif(tr[tr[x].rs].w==tr[tr[y].rs].w)return bij(tr[x].ls,tr[y].ls,l,mi);//\u53f3\u533a\u95f4\u76f8\u540c\u67e5\u5de6\u8fb9\n\treturn bij(tr[x].rs,tr[y].rs,mi+1,r);\u53cd\u4e4b\u5219\u67e5\u53f3\u8fb9.\n}\nbool add(int x,int &y,int l,int r,int s){//bool\u503c\u8868\u793a\u662f\u5426\u8fdb\u4f4d\n\ty=++tt;tr[y]=tr[x];\n\tif(l==r){tr[y].w=tr[x].w^1;return tr[x].w;}\n\tint mi=(l+r)>>1,ty;\n\tif(s>mi)ty=add(tr[x].rs,tr[y].rs,mi+1,r,s);\n\telse{ty=add(tr[x].ls,tr[y].ls,l,mi,s);\n\t\tif(ty)ty=add(tr[x].rs,tr[y].rs,mi+1,r,mi+1);//\u8bb0\u5f97\u8fdb\u4f4d\u662f\u8fdb\u4f4d\u5230mi+1\n\t}tr[y].w=(1ll*tr[tr[y].rs].w*pw2[mi-l+1]+tr[tr[y].ls].w)%md;//\u8ba1\u7b97hash\u503c\n\treturn ty;\n}\nstruct pai{int x,rt;\n\tbool operator <(const pai &p)const{return bij(rt,p.rt,0,mx);}\n};\npriority_queue<pai>p;\nvoid dfs(int x,int d){\n\tif(x==s){printf(\"%d\\n%d \",d,x);return ;}\n\tdfs(pr[x],d+1);printf(\"%d \",x);\n}\nvoid put(int x){printf(\"%d\\n\",tr[rt[x]].w);dfs(x,1);exit(0);}\nint main(){scanf(\"%d%d\",&n,&m); \n\tint x,y,z;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadd(x,y,z);add(y,x,z);mx=max(mx,z);\n\t}mx+=114;pw2[0]=1;\n\tfor(int i=1;i<=mx;i++)pw2[i]=pw2[i-1]*2%md;\n\tscanf(\"%d%d\",&s,&t); \n\tp.push({s,rt[s]});//dijkstra\u677f\u5b50\n\twhile(!p.empty()){pai yy=p.top();p.pop();\n\t\tif(yy.rt!=rt[yy.x])continue;\n\t\tif(yy.x==t)put(t);\n\t\tfor(int i=hd[yy.x],ro;i;i=nt[i]){y=to[i],ro;\n\t\t\tadd(yy.rt,ro,0,mx,d[i]);\n\t\t\tif(!rt[y]||bij(rt[y],ro,0,mx))//\u5982\u679c\u4e4b\u524d\u6ca1\u8bbf\u95ee\u8fc7\u6216\u8005\u7b54\u6848\u66f4\u5c0f\u5c31\u66f4\u65b0\n\t\t\t\trt[y]=ro,p.push({y,rt[y]}),pr[y]=yy.x;\n\t\t}\n\t}puts(\"-1\");\n}\n \n```\n\n",
        "postTime": 1618407252,
        "uid": 53852,
        "name": "\u5f26\u5dfb\u3053\u3053\u308d",
        "ccfLevel": 0,
        "title": "CF464E The Classic Problem"
    },
    {
        "content": "## \u9898\u89e3\n\n[CF464E The Classic Problem](https://www.luogu.com.cn/problem/CF464E)\u3002\n\n\u9996\u5148\u8fb9\u6743\u662f\u4e8c\u8fdb\u5236\uff0c\u80af\u5b9a\u53ef\u4ee5\u8fde\u4e00\u6761\u94fe\u7136\u540e\u7ec4\u5408\u51fa\u4efb\u610f\u6570\uff0c\u8fd9\u6837\u7ec4\u5408\u4e4b\u540e\u5c31\u662f\u6b63\u7ecf\u6700\u77ed\u8def\u4e86\uff0c\u6240\u4ee5\u5728\u6700\u77ed\u8def\u8fd9\u65b9\u9762\u5927\u6982\u7387\u662f\u4e0d\u80fd\u4f9d\u9760\u4e8c\u8fdb\u5236\u6765\u8d70\u6377\u5f84\u3002\n\n\u8003\u8651 dijkstra \u7684\u8fc7\u7a0b\uff0c\u9700\u8981\u5728\u5806\u4e2d\u63d2\u5165\u548c\u63d0\u53d6\u4e00\u4e2a\u6570\u3002\u8bb0\u6bd4\u8f83\u4e24\u4e2a\u6570\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal O(A)$ \u7684\uff0c\u5219\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\mathcal O(An\\log n)$\u3002\u5728\u8dd1\u6700\u77ed\u8def\u7684\u8fc7\u7a0b\u4e2d\uff0c\u56e0\u4e3a\u8fb9\u6743\u4e3a\u6b63\uff0c\u6240\u4ee5\u6700\u540e\u80af\u5b9a\u662f\u7b80\u5355\u8def\u5f84\uff0c\u90a3\u4e48\u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u53ea\u4f1a\u88ab\u8d70\u8fc7\u4e00\u6b21\uff0c\u4f1a\u9020\u6210\u4e00\u6b21\u52a0\u6cd5\u8fd0\u7b97\u7684\u8d21\u732e\u3002\u8bb0\u52a0\u6cd5\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal O(B)$ \u7684\uff0c\u603b\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\mathcal O(mB)$ \u7684\u3002\n\n\u8003\u8651\u7528\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u7ef4\u62a4\u6570\uff0c\u8ba9\u8fd9\u4e24\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u5c3d\u53ef\u80fd\u5747\u8861\uff0c\u6216\u8005\u8fbe\u5230 $\\mathcal O(\\text{\u80fd\u8fc7})$\u3002\n\n\u56e0\u4e3a\u662f\u4e8c\u8fdb\u5236\uff0c\u628a\u6570\u770b\u6210 $\\texttt{01}$ \u4e32\uff0c\u5bf9\u4e8e\u6bd4\u8f83\u4e24\u4e2a\u6570\uff0c\u5982\u679c\u4e0d\u8003\u8651\u54c8\u5e0c\u51b2\u7a81\uff0c\u4ece\u6700\u9ad8\u4f4d\u5f00\u59cb\u4e8c\u5206/\u500d\u589e\u54c8\u5e0c\u5e94\u8be5\u662f\u4e00\u4e2a\u8f83\u4f18\u7684\u505a\u6cd5\uff0c\u6253\u5f00\u6807\u7b7e\u53d1\u73b0\u679c\u7136\u6709\u54c8\u5e0c\uff0c\u6ca1\u8dd1\u4e86\u3002\u6bd4\u8f83\u53ef\u4ee5\u505a\u5230 $\\mathcal O(\\log n)$\u3002\u8003\u8651\u7528\u4e3b\u5e2d\u6811\u7ef4\u62a4\u6570\u7684\u54c8\u5e0c\u503c\uff0c\u95ee\u9898\u5728\u4e8e\u5982\u4f55\u5904\u7406\u52a0\u6cd5\u3002\n\n\u6ce8\u610f\u5230\u8fd9\u91cc\u7684\u52a0\u6cd5\u662f\u53ea\u52a0\u4e00\u4f4d\uff08\u8fb9\u6743\u53ea\u6709\u4e00\u4f4d\uff09\uff0c\u5728\u6811\u4e0a\u7684\u8868\u73b0\u5e94\u8be5\u662f\u4ece $x_i$ \u5f00\u59cb\u627e\u5230\u4e00\u6bb5\u6781\u957f\u7684 $1$ \u6539\u4e3a $0$ \u5e76\u5c06\u4e0b\u4e00\u4f4d\u4fee\u6539\u4e3a $1$\uff0c\u4fee\u6539\u4f3c\u4e4e\u53ef\u4ee5\u5728\u4e3b\u5e2d\u6811\u4e0a $\\mathcal O(\\log n)$ \u66b4\u529b\u8dd1\uff08\u5982\u679c\u80fd\u8bb0\u7236\u4eb2\u7ed3\u70b9\u7684\u8bdd\uff09\uff0c\u5f53\u7136\u4e5f\u53ef\u4ee5\u4e8c\u5206 $\\mathcal O(\\log^2 n)$ \u8dd1\u3002\u4f46\uff0c\u4e3b\u5e2d\u6811\u533a\u95f4\u8986\u76d6\u4f1a\u5bc4\u3002\n\n\u8003\u8651\u5f00\u4e00\u68f5\u5168 $0$ \u7684\u5355\u4f4d\u5143\u6743\u503c\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u628a\u8981\u8986\u76d6\u7684\u533a\u95f4\u65b0\u5efa\u8282\u70b9\u7136\u540e\u63a5\u5230\u5355\u4f4d\u5143\u4e0a\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(\\log n)$\u3002\n\n\u603b\u65f6\u95f4\u590d\u6742\u5ea6 $\\mathcal O(n\\log X\\log n+m\\log^2 X)$\u3002[\u63d0\u4ea4\u8bb0\u5f55](https://codeforces.com/contest/464/submission/156161301)\u3002\n\n### Code\n\n```cpp\n// Problem: CF464E The Classic Problem\n// From: Luogu\n// URL: https://www.luogu.com.cn/problem/CF464E\n// Time: 2022-05-06 19:59\n// Author: lingfunny\n\n#include <bits/stdc++.h>\n#define LL long long\n#define ULL unsigned long long\nusing namespace std;\nconst int mxn = 1e5+100, X = 1e5+50, mod = 1e9+7, mxz = 1e7+10, md = 998244353;\n\nint n, m, S, T, conf[mxn], rpw[mxn], from[mxn], ans[mxn], top;\ntypedef pair<int, int> edge;\n#define ev first\n#define ew second\nvector <edge> G[mxn];\nint lc[mxz], rc[mxz], all[mxz], tot;\nULL hs[mxz], pw[mxn];\n#define mid ((L+R)>>1)\ninline void psup(int o, int L, int R) {\n\tall[o] = all[lc[o]] && all[rc[o]];\n\ths[o] = (hs[lc[o]] * pw[R-mid] + hs[rc[o]]) % md;\n}\nint Judge(int cl, int cr, int o, int L = 0, int R = X) {\n\tif((cl <= L && R <= cr) || !o) return all[o];\n\treturn (cl <= mid ? Judge(cl, cr, lc[o], L, mid) : 1) && (cr > mid ? Judge(cl, cr, rc[o], mid+1, R) : 1);\n}\nvoid Set(int p, int& o, int r, int L = 0, int R = X) {\n\tif(!o) o = ++tot;\n\tif(L == R) return all[o] = 1, hs[o] = 1, void();\n\tif(p <= mid) Set(p, lc[o], lc[r], L, mid), rc[o] = rc[r];\n\telse Set(p, rc[o], rc[r], mid+1, R), lc[o] = lc[r];\n\tpsup(o, L, R);\n}\ninline int copy(int u, int v) {\n\tlc[u] = lc[v], rc[u] = rc[v];\n\tall[u] = all[v], hs[u] = hs[v];\n\treturn u;\n}\nvoid cover(int cl, int cr, int& o, int L = 0, int R = X) {\n\tif(cl <= L && R <= cr) return o = 0, void();\n\tif(cl <= mid) {\n\t\tlc[o] = copy(++tot, lc[o]);\n\t\tcover(cl, cr, lc[o], L, mid);\n\t}\n\tif(cr > mid) {\n\t\trc[o] = copy(++tot, rc[o]);\n\t\tcover(cl, cr, rc[o], mid+1, R);\n\t}\n\tpsup(o, L, R);\n}\nint calc(int o, int L = 0, int R = X) {\n\tif(!o) return 0;\n\tif(L == R) return all[o]*rpw[L]%mod;\n\treturn (calc(lc[o], L, mid) + calc(rc[o], mid+1, R)) % mod;\n}\nstruct TreeNum {\n\tint rt;\n\tinline TreeNum(int x=0): rt(x) {}\n\tinline bool operator < (const TreeNum& rhs) const {\n\t\tint u = rt, v = rhs.rt, L = 0, R = X;\n\t\tif(hs[u] == hs[v]) return false;\n\t\twhile(L != R) {\n\t\t\twhile(hs[rc[u]] != hs[rc[v]]) u = rc[u], v = rc[v], L = mid+1;\n\t\t\tif(L != R) u = lc[u], v = lc[v], R = mid;\n\t\t}\n\t\treturn all[u] < all[v];\t// less\n\t}\n\tinline TreeNum operator + (const int& rhs) const {\n\t\tTreeNum New;\n\t\tint L = rhs, R = X, res = L;\n\t\twhile(L <= R) {\n\t\t\tif(Judge(rhs, mid, rt)) L = mid+1;\n\t\t\telse res = mid, R = mid-1;\n\t\t}\n\t\tassert(!Judge(res, res, rt));\n\t\tSet(res, New.rt, rt);\n\t\tif(rhs < res) cover(rhs, res-1, New.rt);\n\t\treturn New;\n\t}\n} dis[mxn], INF, A;\ntypedef pair<TreeNum, int> node;\n#define id second\npriority_queue <node, vector <node>, greater<node>> di;\n\nsigned main() {\n\tpw[0] = rpw[0] = 1;\n\tfor(int i = 1; i <= X; ++i) pw[i] = pw[i-1]*3 % md, rpw[i] = (rpw[i-1]<<1) % mod;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int x, y, z, i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d%d\", &x, &y, &z);\n\t\tG[x].emplace_back((edge){y, z});\n\t\tG[y].emplace_back((edge){x, z});\n\t}\n\tscanf(\"%d%d\", &S, &T);\n\tSet(X, INF.rt, 0); Set(X-1, INF.rt, INF.rt);\n\tfor(int i = 1; i <= n; ++i) if(i != S) dis[i] = INF;\n\tdi.push({dis[S], S});\n\twhile(di.size()) {\n\t\tint u = di.top().id; di.pop();\n\t\tif(conf[u]) continue;\n\t\tconf[u] = 1;\n\t\tfor(edge e: G[u]) if(!conf[e.ev]) {\n\t\t\tTreeNum x = dis[u] + e.ew;\t// O(Bm)\n\t\t\tif(x < dis[e.ev]) {\n\t\t\t\tdis[e.ev] = x; from[e.ev] = u;\n\t\t\t\tdi.push({dis[e.ev], e.ev});\t// O(Am log n)\n\t\t\t}\n\t\t}\n\t}\n\tif(!conf[T]) { puts(\"-1\"); return 0; }\n\tprintf(\"%d\\n\", calc(dis[T].rt));\n\twhile(T != S) ans[++top] = T, T = from[T];\n\tans[++top] = S; printf(\"%d\\n\", top);\n\tfor(int i = top; i; --i) printf(\"%d%c\", ans[i], \" \\n\"[i==1]);\n\treturn 0;\n}\n```",
        "postTime": 1651902879,
        "uid": 280800,
        "name": "lingfunny",
        "ccfLevel": 7,
        "title": "CF464E The Classic Problem \u9898\u89e3"
    },
    {
        "content": "\u4e3b\u8981\u505a\u6cd5\u5176\u4ed6\u9898\u89e3\u5199\u5f97\u5f88\u6e05\u695a\uff0c\u8fd9\u91cc\u5bf9\u4e8e\u52a0 $2^k$ \u64cd\u4f5c\u63d0\u4f9b\u5e38\u6570\u8f83\u5c0f\u7684\u4e00\u79cd\u505a\u6cd5\n\n~~\u867d\u7136 cf \u4e0d\u5361\u5e38~~\n\n\u73b0\u6709\u7684\u9898\u89e3\u5927\u591a\u662f\u4e8c\u5206\u4e86\u8fde\u7eed\u6bb5\u957f\u5ea6\uff0c\u7136\u540e\u7528\u5355\u70b9\u4fee\u6539\uff0c\u533a\u95f4\u63a8\u5e73\u6765\u505a\n\n\u6211\u7684\u505a\u6cd5\u662f\u5728\u7ebf\u6bb5\u6811\u4e0a\u8d70\u65f6\uff0c\u540c\u65f6\u7ef4\u62a4\u201d\u5f53\u524d\u8ba4\u4e3a\u8981\u52a0\u4e00\u201c\u7684\u4f4d\u7f6e\n\n\u5982\u679c\u5f53\u524d\u533a\u95f4\u4e3a $[l,r]$\uff0c\u201d\u5f53\u524d\u8ba4\u4e3a\u8981\u52a0\u4e00\u201c\u7684\u4f4d\u7f6e\u4e3a $\\text{lst}$:\n\n\u5728\u7ebf\u6bb5\u6811\u4e0a\u8d70\u65f6\uff0c\u5148\u8003\u8651\u5de6\u8fb9\uff0c\u540e\u8003\u8651\u53f3\u8fb9\uff0c\u5982\u679c $\\text{lst}$ \u5728\u76f8\u5e94\u533a\u95f4\u5185\u5c31\u8d70\n\n\u82e5 $[l,r]$ \u4e3a\u5168 $1$\uff0c\u90a3\u4e48 $\\text{lst}=r+1$\n\n\u5426\u5219\u82e5 $l=r$\uff0c\u8fd9\u65f6\u5fc5\u5b9a\u8fd9\u4e00\u4f4d\u8981\u52a0\u4e00\uff0c\u90a3\u4e48\u76f4\u63a5\u52a0\u4e00\u5e76\u8fd4\u56de\n\n\u8fd9\u6837\u5c31\u4e0d\u9700\u4e8c\u5206\u67e5\u8be2\u8fde\u7eed\u6bb5\u957f\u5ea6\u4e86\uff0c\u590d\u6742\u5ea6\u4e00\u6837\uff0c\u4f46\u662f\u5e38\u6570\u8f83\u5c0f\n\n\u8fd9\u90e8\u5206\u7684\u4ee3\u7801\uff08\u53e6\u5916\u8fd8\u7528\u5efa\u5168 0/1 \u6811\u7684\u65b9\u6cd5\u51cf\u5c11\u7a7a\u95f4\u6d88\u8017\uff0cR0\uff0cR1 \u5373\u4e3a 0/1 \u6811\u4e0a\u7684\u7ed3\u70b9\uff09\uff1a\n\n```cpp\nint lst;\ninline void set1(int R0,int R1,int &x,int l,int r){ // + 2^k\n\tif(lst<l||lst>r)return;\n\tif(l==lst&&tr[R1].hs==tr[x].hs){ // [l,r] \u5168\u4e3a1\n\t\tlst=r+1;\n\t\tx=R0;\n\t\treturn;\n\t}\n\telse if(l==r){ // \u627e\u5230\u5730\u65b9\uff0c\u8d4b\u4e3a1\n\t\tx=R1;\n\t\treturn;\n\t}\n\tclone(x);\n\tif(lst<=mi)set1(tr[R0].l,tr[R1].l,lson);\n\tif(lst>mi)set1(tr[R0].r,tr[R1].r,rson);\n\tup(x,l,r);\n}\nstruct Pos{\n\tint id,rt;\n\tinline Pos(int _id=0,int _rt=0){ id=_id; rt=_rt; }\n\tinline bool operator<(const Pos &b)const{\n\t\treturn cmp(R0,R1,b.rt,rt,0,d)==1;\n\t}\n};\nPos dis[N];\npriority_queue<Pos> Q;\nbool vis[N];\nint la[N];\ninline void dij(){\n\tfor(int i=1;i<=n;i++)dis[i].id=i;\n\tfor(int i=1;i<=n;i++)if(i!=s)dis[i].rt=R1;\n\tfor(int i=1;i<=n;i++)vis[i]=0;\n\tdis[s].rt=R0;\n\tQ.push(dis[s]);\n\twhile(!Q.empty()){\n\t\tPos u=Q.top(); Q.pop();\n\t\tif(vis[u.id])continue;\n\t\tvis[u.id]=1;\n\t\tfor(int i=h[u.id];i;i=nx[i]){\n\t\t\tint tc=cnt;\n\t\t\tint Rt=u.rt;\n\t\t\tlst=w[i]; // \u4ece w[i] \u5f00\u59cb\u627e\n\t\t\tset1(R0,R1,Rt,0,d); // + 2^w[i] \u64cd\u4f5c\n\t\t\tif(cmp(R0,R1,Rt,dis[to[i]].rt,0,d)==1){\n\t\t\t\tdis[to[i]].rt=u.rt;\n\t\t\t\tlst=w[i];\n\t\t\t\tla[to[i]]=u.id;\n\t\t\t\tdis[to[i]].rt=Rt;\n\t\t\t\tQ.push(dis[to[i]]);\n\t\t\t}\n\t\t\telse cnt=tc;\n\t\t}\n\t}\n}\n```",
        "postTime": 1626605585,
        "uid": 118743,
        "name": "ZZ\u4f5c\u8005",
        "ccfLevel": 7,
        "title": "CF464E The Classic Problem \u9898\u89e3"
    },
    {
        "content": "#### CF464E The Classic Problem\n\n\u7801\u519c\u6570\u636e\u7ed3\u6784\u9898\u3002\n\n\u7531\u4e8e$2^{100000}$\u6b21\u65b9\u8fc7\u5927\uff0c\u56e0\u6b64\u8003\u8651\u9ad8\u7cbe\u5ea6\u6700\u77ed\u8def\u3002\n\n\u4f46\u662f\u9ad8\u7cbe\u592a\u6162\u4e86\uff0c\u65e0\u6cd5\u901a\u8fc7\u6b64\u9898\u3002\n\n\u7136\u800c\u8fd9\u9053\u9898\u6709\u4e2a\u7279\u6b8a\u6027\u8d28\u5728\u4e8e\u8fb9\u6743\u90fd\u662f$2$\u7684\u6b21\u5e42\uff0c\u56e0\u6b64\u8003\u8651\u4e8c\u8fdb\u5236\u7684\u505a\u6cd5\u3002\n\n\u8003\u8651$dijkstra$\u9700\u8981\u7528\u5230\u7684\u64cd\u4f5c\uff0c\u5373\u9700\u8981\u652f\u6301\u4e24\u4e2a\u6570\u76f8\u52a0\u548c\u4e24\u4e2a\u6570\u7684\u6bd4\u8f83\u3002\n\n\u9996\u5148\u8003\u8651\u4e24\u4e2a\u6570\u76f8\u52a0\uff0c\u4e00\u4e2a$2$\u7684\u6b21\u5e42\u548c\u4e00\u4e2a\u6b63\u6574\u6570\u76f8\u52a0\uff0c\u624b\u73a9\u5373\u53ef\u53d1\u73b0\u5176\u672c\u8d28\u662f\u5148\u627e\u5230\u5bf9\u5e94\u7684\u4e8c\u8fdb\u5236\u4f4d\uff0c\u5982\u679c\u662f$0$\u5c31\u7f6e\u4e3a$1$\uff0c\u5982\u679c\u662f$1$\u5c31\u7f6e\u4e3a$0$\u5e76\u5c06\u5176\u524d\u8fb9\u7684\u4e00\u4e32$1$\u6539\u4e3a$0$\uff0c\u5728\u6700\u524d\u5934\u518d\u6dfb\u52a0\u4e00\u4e2a$0$\u3002\u56e0\u4e3a\u9700\u8981\u7528\u5230\u7684\u4f4d\u6570\u5f88\u5c11\u4f46\u662f\u70b9\u7684\u6570\u91cf\u5f88\u591a\uff0c\u6240\u4ee5\u53ea\u80fd\u7528\u4e3b\u5e2d\u6811\u6ca1\u6cd5\u7528\u7ebf\u6bb5\u6811\u3002\n\n\u8fd9\u91cc\u6709\u4e00\u70b9\u9ed1\u79d1\u6280\u5c31\u662f\u8bf4\uff0c\u4e00\u822c\u7684\u4e3b\u5e2d\u6811\u4e0d\u592a\u80fd\u652f\u6301\u533a\u95f4\u4fee\u6539\uff0c\u56e0\u6b64\u6211\u4eec\u53ef\u4ee5\u5efa\u4e00\u68f5\u5168\u96f6\u7684\u4e3b\u5e2d\u6811\uff0c\u53ea\u8981\u9700\u8981\u7f6e\u96f6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u628a\u5bf9\u5e94\u8282\u70b9\u8fde\u5230\u4e0a\u9762\uff0c\u5c31\u53ef\u4ee5\u5feb\u901f\u7f6e$0$\u4e86\u3002\n\n\u641e\u5b8c\u8fd9\u4e9b\u4ee5\u540e\uff0c\u76f4\u63a5\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u5373\u53ef\u627e\u5230\u4f4d\u7f6e\uff0c\u7136\u540e\u8fdb\u884c\u4e0a\u8ff0\u64cd\u4f5c\u5373\u53ef\u3002\n\n\u800c\u4e24\u4e2a\u6570\u6bd4\u8f83\u7684\u8bdd\u4e5f\u6bd4\u8f83\u9ebb\u70e6\uff0c\u56e0\u4e3a\u6211\u4eec\u9996\u5148\u9700\u8981\u6bd4\u8f83\u53f3\u5b50\u6811\u76f8\u4e0d\u76f8\u7b49\uff0c\u4f46\u5982\u679c\u53ea\u8bb0\u5f55$1$\u7684\u4e2a\u6570\u65e0\u6cd5\u6bd4\u8f83\uff0c\u56e0\u6b64\u8003\u8651\u8bb0\u5f55\u4e00\u4e2a$Hash$\u503c\uff0c\u6bd4\u8f83\u5b50\u6811\u76f8\u4e0d\u76f8\u7b49\u53ef\u4ee5\u76f4\u63a5\u6bd4\u8f83\u54c8\u5e0c\u503c\uff0c\u53ef\u4ee5\u5728$O(1)$\u5185\u5b8c\u6210\u6bd4\u8f83\u3002\n\n\u7136\u540e\u5957\u4e0a$Dijkstra$\u6a21\u677f\u5373\u53ef\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#define N 6000005\n#define M 200005\n#define mod 1000000007\n#define P 100055\n#define int long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\nint n,m,v[M],w[M],head[M],nxt[M],cnt,S,T;\nint lc[N],rc[N],sum[N],now,rt[M],pre[M],vis[M],ans[M],top;\nint Hash[N],bas[N];\nvoid init()\n{\n\tbas[0]=1ll;\n\tfor(int i=1;i<=P;i++)\n\t{\n\t\tbas[i]=bas[i-1]*2ll;\n\t\tbas[i]%=mod;\n\t}\n}\nvoid add(int a,int b,int c)\n{\n\tv[++cnt]=b;\n\tw[cnt]=c;\n\tnxt[cnt]=head[a];\n\thead[a]=cnt;\n}\nvoid pushup(int x)\n{\n\tsum[x]=sum[lc[x]]+sum[rc[x]];\n\tHash[x]=(Hash[lc[x]]+Hash[rc[x]])%mod;\n}\nint build(int l,int r,int val)\n{\n\tint x=++now;\n\tif(l==r)\n\t{\n\t\tHash[x]=bas[l]*val%mod;\n\t\tsum[x]=val;\n\t\treturn x;\n\t}\n\tint mid=(l+r)>>1;\n\tlc[x]=build(l,mid,val);\n\trc[x]=build(mid+1,r,val);\n\tpushup(x);\n\treturn x;\n}\nint query(int x,int l,int r,int ql,int qr)\n{\n\tif(l>=ql&&r<=qr)return sum[x];//l>=x&&r<=y\n\tint mid=(l+r)>>1;\n\tint res=0;\n\tif(ql<=mid)res+=query(lc[x],l,mid,ql,qr);\n\tif(qr>mid)res+=query(rc[x],mid+1,r,ql,qr);\n\treturn res;\n}\nint find(int x,int l,int r,int p)\n{\n\tif(l==r)return l;\n\tint mid=(l+r)>>1;\n\tif(p>mid)return find(rc[x],mid+1,r,p);\n\tif(query(lc[x],l,mid,p,mid)==mid-p+1)return find(rc[x],mid+1,r,mid+1);\n\treturn find(lc[x],l,mid,p);\n}\nint modify(int x,int l,int r,int p)\n{\n\tint u=++now;\n\tlc[u]=lc[x];rc[u]=rc[x];\n\tif(l==r)\n\t{\n\t\tsum[u]=1;\n\t\tHash[u]=bas[l];\n\t\treturn u;\n\t}\n\tint mid=(l+r)>>1;\n\tif(p<=mid)lc[u]=modify(lc[x],l,mid,p);\n\telse rc[u]=modify(rc[x],mid+1,r,p);\n\tpushup(u);\n\treturn u;\n}\nint move(int u1,int u2,int l,int r,int ql,int qr)\n{\n\tif(qr<l||ql>r)return u1;\n\tif(l>=ql&&r<=qr)return u2;\n\tint mid=(l+r)>>1;\n\tint u=++now;\n\tlc[u]=move(lc[u1],lc[u2],l,mid,ql,qr);\n\trc[u]=move(rc[u1],rc[u2],mid+1,r,ql,qr);\n\tpushup(u);\n\treturn u;\n}\nint Add(int Rt,int w)\n{\n\tint p=find(Rt,0,P,w);\n\t//cout<<\"!!!\"<<p<<\" \"<<endl;\n\tint tmp=modify(Rt,0,P,p);\n\t//cout<<tmp<<endl;\n\tif(p==w)return tmp;\n\ttmp=move(tmp,rt[0],0,P,w,p-1);\n\treturn tmp;\n}\nint same(int a,int b)\n{\n\treturn (sum[a]==sum[b]&&Hash[a]==Hash[b]);\n}\nint cmp(int a,int b,int l,int r)\n{\n\tif(l==r)return sum[a]<=sum[b];\n\tint mid=(l+r)>>1;\n\tif(same(rc[a],rc[b]))return cmp(lc[a],lc[b],l,mid);\n\telse return cmp(rc[a],rc[b],mid+1,r);\n}\nstruct info\n{\n\tint x,d;\n\tbool operator<(const info &B)const{\n\t\treturn cmp(B.d,d,0,P);\t\n\t};\n};\nvoid Dij()\n{\n\tpriority_queue<info>q;\n\tint tmp=build(0,P,1);\n\tfor(int i=1;i<=n;i++)rt[i]=tmp;\n\trt[0]=rt[S]=build(0,P,0);\n\tq.push((info){S,rt[S]});\n\t//for(int i=1;i<=10;i++)\n\t//{\n\t//\tcout<<i<<\" \"<<lc[i]<<\" \"<<rc[i]<<\" \"<<sum[i]<<\" \"<<Hash[i]<<endl;\n\t//}\n\twhile(!q.empty())\n\t{\n\t\twhile(!q.empty()&&vis[q.top().x])q.pop();\n\t\tif(q.empty())break;\n\t\tinfo c=q.top();\n\t\tq.pop();\n\t\tint x=c.x;\n\t\t//cout<<x<<endl;\n\t\tif(vis[x])continue;\n\t\tvis[x]=1;\n\t\tif(x==T)break;\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tif(!vis[v[i]])\n\t\t\t{\n\t\t\t\tint new_rt=Add(rt[x],w[i]);\n\t\t\t\t//cout<<new_rt<<endl;\n\t\t\t\tif(cmp(rt[v[i]],new_rt,0,P))continue;\n\t\t\t\trt[v[i]]=new_rt;pre[v[i]]=x;\n\t\t\t\tq.push((info){v[i],rt[v[i]]});\n\t\t\t}\n\t\t}\n\t}\n\tif(rt[T]==tmp)\n\t{\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\t//puts(\"ANSWER!!!!!!!!\");\n\t//for(int i=1;i<=n;i++)printf(\"%lld \",Hash[rt[i]]);\n\t//puts(\"\");\n\tprintf(\"%lld\\n\",Hash[rt[T]]%mod);\n\tfor(int u=T;u!=S;u=pre[u])ans[++top]=u;ans[++top]=S;\n\tprintf(\"%lld\\n\",top);\n\tfor(int i=top;i>=1;i--)printf(\"%lld \",ans[i]);\n}\nsigned main()\n{\n\t//freopen(\"A.out\",\"w\",stdout);\n\tn=read();m=read();init();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=read(),y=read(),z=read();\n\t\tadd(x,y,z);add(y,x,z);\n\t}\n\tS=read();T=read();\n\tDij();\n\treturn 0;;\n}\n```\n\n",
        "postTime": 1610633629,
        "uid": 179600,
        "name": "shao0320",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF464E \u3010The Classic Problem\u3011"
    },
    {
        "content": "\u8003\u8651\u9ad8\u7cbe\u5ea6\u6700\u77ed\u8def\uff0c\u53d1\u73b0\u5f88\u7b80\u5355\u4f46\u662f\u8fc7\u4e0d\u4e86\u3002\n\n\u7531\u4e8e\u5b83\u7ed9\u7684\u6027\u8d28 $2^x$\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u5230\u7528\u4e8c\u8fdb\u5236\u6765\u50a8\u5b58\u3002\n\n\u8fd9\u6837\u4e24\u4e2a\u4e4b\u95f4\u5dee\u7684\u4f4d\u6570\u5c31\u53ef\u63a7\u4e86\uff0c\u53ef\u4ee5\u4e3b\u5e2d\u6811\u7ef4\u62a4\u4e86\u3002\n\n1.\u6bd4\u8f83\u5927\u5c0f\n\n\u4f7f\u7528\u4e00\u4e0b $hash$ \u503c\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a $hash$ \u503c\u4e0d\u7b49\u7684\u5730\u65b9\uff0c\u7136\u540e\u770b\u770b\u54ea\u4e2a\u662f $0$ \u54ea\u4e2a\u662f $1$ \u5373\u53ef\u3002\n\n2.\u533a\u95f4\u8d4b\u503c\u4e3a0\n\n\u8fd9\u4e2a\u8fd8\u633a\u4eba\u7c7b\u667a\u6167\u7684\uff0c\u6211\u4eec\u8003\u8651\u5efa\u4e00\u4e2a\u5168 $0$ \u7684\u7ebf\u6bb5\u6811\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u8981\u7f6e\u4e3a $0$ \u7684\u533a\u95f4\u8fde\u5230\u54ea\u4e2a\u5168 $0$ \u7684\u7ebf\u6bb5\u6811\u5373\u53ef\u3002\n\n\u81f3\u4e8e\u627e\u5230\u7b2c\u4e00\u4e2a $0$ \uff0c\u6211\u4eec\u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206\u4e00\u4e0b\u5373\u53ef\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#define int long long\nusing namespace std;\nconst int NR=1e5+100;\nconst int mod=1e9+7;\nint add(int x,int y){return (x+y)%mod;}\nint mul(int x,int y){return x*y%mod;}\nint n,m,mx,a,b;\nint power[NR]; \nint root[NR],Len[NR];\nstruct Segment\n{\n\tint tot,siz[NR*51],hash[NR*51],ls[NR*51],rs[NR*51],Ans;\n\tvoid update(int rt,int t)\n\t{\n\t\tsiz[rt]=siz[ls[rt]]+siz[rs[rt]]; \n\t\thash[rt]=add(mul(hash[rs[rt]],power[t]),hash[ls[rt]]);\n\t}\n\tvoid build(int &rt,int l,int r)\n\t{\n\t\tif(!rt)rt=++tot;int mid=(l+r>>1);\n\t\tLen[r-l+1]=rt;if(l==r)return;\n\t\tbuild(ls[rt],l,mid),build(rs[rt],mid+1,r);\n\t}\n\tvoid build1(int &rt,int l,int r)\n\t{\n\t\tif(!rt)rt=++tot;int mid=(l+r>>1);\n\t\tif(l==r){hash[rt]=1;siz[rt]=1;return;}\n\t\tbuild1(ls[rt],l,mid),build1(rs[rt],mid+1,r);\n\t\tupdate(rt,mid-l+1);\n\t}\n\tvoid cover(int &rt,int p,int q,int l,int r)\n\t{\n\t\tif(p==l&&q==r){rt=Len[r-l+1];return;}int mid=(l+r>>1);\n\t\tint la=rt;rt=++tot;ls[rt]=ls[la],rs[rt]=rs[la];\n\t\tif(q<=mid)cover(ls[rt],p,q,l,mid);\n\t\telse if(p>mid)cover(rs[rt],p,q,mid+1,r);\n\t\telse cover(ls[rt],p,mid,l,mid),cover(rs[rt],mid+1,q,mid+1,r);\n\t\tupdate(rt,mid-l+1);\n\t}\n\tbool cmp(int x,int y,int l,int r)\n\t{\n\t\tif(l==r)return hash[x]<hash[y];int mid=(l+r>>1);\n\t\tif(hash[rs[x]]!=hash[rs[y]])return cmp(rs[x],rs[y],mid+1,r);\n\t\treturn cmp(ls[x],ls[y],l,mid);\n\t}\n\tvoid change(int &rt,int x,int l,int r)\n\t{\n\t\tint la=rt;rt=++tot;if(l==r){siz[rt]=hash[rt]=1;return;}\n\t\tls[rt]=ls[la],rs[rt]=rs[la];int mid=(l+r>>1);\n\t\tif(x<=mid)change(ls[rt],x,l,mid);\n\t\telse change(rs[rt],x,mid+1,r);\n\t\tupdate(rt,mid-l+1);\n\t}\n\tvoid find1(int rt,int l,int r)\n\t{\n//\t\tprintf(\"%lld %lld %lld\\n\",l,r,hash[rt]);\n\t\tif(l==r){Ans=l;return;}int mid=(l+r>>1);\n\t\tif(siz[ls[rt]]==mid-l+1)find1(rs[rt],mid+1,r);\n\t\telse find1(ls[rt],l,mid);\n\t}\n\tvoid find2(int rt,int p,int q,int l,int r)\n\t{\n\t\tif(Ans!=-1)return;int mid=(l+r>>1);\n\t\tif(p==l&&q==r){if(siz[rt]==r-l+1)return;find1(rt,l,r);return;}\n\t\tif(q<=mid)find2(ls[rt],p,q,l,mid);else if(p>mid)find2(rs[rt],p,q,mid+1,r);\n\t\telse{find2(ls[rt],p,mid,l,mid);if(Ans!=-1)return;find2(rs[rt],mid+1,q,mid+1,r);}\n\t}\n\tint find(int rt,int pos){Ans=-1;find2(root[rt],pos,mx,1,mx);return Ans;}\n\tvoid Add(int rt,int w){int x=find(rt,w);if(w<=x-1)cover(root[rt],w,x-1,1,mx);change(root[rt],x,1,mx);}\n}S;\nbool vis[NR];\nint pre[NR],ans[NR];\nint to[NR<<1],nxt[NR<<1],val[NR<<1],head[NR],tot=1;\nvoid add(int x,int y,int z){mx=max(mx,z+21);to[tot]=y;val[tot]=z;nxt[tot]=head[x];head[x]=tot++;}\nstruct Nd{int x,d;bool operator<(const Nd &A)const{return !S.cmp(d,A.d,1,mx);}};\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n\treturn x*f;\n}\nsigned main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"1.out\",\"w\",stdout);\n\tn=read(),m=read();mx=21;\n\tfor(int i=1,x,y,z;i<=m;i++)\n\t\tx=read(),y=read(),z=read()+1,add(x,y,z),add(y,x,z);mx=100020;\n\ta=read(),b=read();\n\tpower[0]=1;for(int i=1;i<=mx;i++)power[i]=mul(power[i-1],2);\n\tpriority_queue<Nd>q;Nd O;O.x=a;q.push(O);S.build(root[a],1,mx);\n\tS.build1(root[n+2],1,mx);for(int i=1;i<=n;i++)if(i!=a)root[i]=root[n+2];\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().x;q.pop();if(vis[x])continue;vis[x]=1;\n\t\tif(x==b)\n\t\t{\n\t\t\tint all=0,tt=x;while(x){ans[++all]=x;x=pre[x];}\n\t\t\tprintf(\"%lld\\n%lld\\n\",S.hash[root[tt]],all);\n\t\t\tfor(int i=all;i>=1;i--)printf(\"%lld \",ans[i]);\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=to[i];if(vis[y])continue;\n\t\t\troot[n+1]=root[x];S.Add(n+1,val[i]);\n\t\t\tif(S.cmp(root[n+1],root[y],1,mx))\n\t\t\t{\n\t\t\t\tpre[y]=x,root[y]=root[n+1];\n\t\t\t\tNd X;X.x=y,X.d=root[y];q.push(X);\n\t\t\t}\n\t\t}\n\t}puts(\"-1\");\n\treturn 0;\n}\n//I love Chtholly forever",
        "postTime": 1610541995,
        "uid": 97136,
        "name": "chenzida",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF464E \u3010The Classic Problem\u3011"
    }
]