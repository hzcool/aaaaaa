[
    {
        "content": "[$$\\large \\color{purple} My \\; Blog$$](https://www.cnblogs.com/p-b-p-b/p/10499952.html)\n\n-------------------------\n\n## \u601d\u8def\n\n\u770b\u5230\u6811\u4e0a\u8def\u5f84\u7684\u7edf\u8ba1\uff0c\u5bb9\u6613\u60f3\u5230\u70b9\u5206\u6cbb\u3002\n\n\u867d\u7136\u53ea\u6709\u4e00\u4e2a\u9650\u5236\uff0c\u4f46\u8fd9\u4e2a\u9650\u5236\u6bd4\u8f83\u9ebb\u70e6\uff0c\u6211\u4eec\u628a\u5b83\u62c6\u6210\u4e24\u4e2a\u3002\n\n\u8bbe\u9ed1\u8fb9\u6709$a$\u6761\uff0c\u767d\u8fb9\u6709$b$\u6761\uff0c\u90a3\u4e48\u6709\n\n$$2a\\geq b$$\n$$2b\\geq a$$\n\n\u5408\u5e76\u4e24\u6761\u8fb9\u65f6\uff0c\u8bbe\u539f\u6709\u7684\u662f$(a,b)$\uff0c\u8981\u52a0\u5165\u7684\u662f$(A,B)$\uff0c\u90a3\u4e48\u6709\n\n$$2(a+A)\\geq b+B \\Leftrightarrow 2A-B\\geq b-2a$$\n$$2(b+B)\\geq a+A \\Leftrightarrow 2B-A\\geq a-2b \\Leftrightarrow A-2B\\leq 2b-a$$\n\n\u4f46\u73b0\u5728\u6709\u4e24\u4e2a\u9650\u5236\uff0c\u4f3c\u4e4e\u8fd8\u8981CDQ\u5206\u6cbb\uff0c\u975e\u5e38\u9ebb\u70e6\u3002\n\n\u6ce8\u610f\u5230\u4e00\u4e2a\u6027\u8d28\uff1a\u53ea\u8981\u4e0d\u6ee1\u8db3\u7b2c\u4e00\u6761\uff0c\u5fc5\u7136\u6ee1\u8db3\u7b2c\u4e8c\u6761\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002\n\n\u90a3\u4e48\u53ef\u4ee5\u7528\u4e24\u4e2a\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u524d\u7f00\u79ef\uff0c\u6bcf\u6b21\u7528\u6ee1\u8db3\u7b2c\u4e00\u6761\u7684\u9664\u4ee5\u4e0d\u6ee1\u8db3\u7b2c\u4e8c\u6761\u7684\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6$O(n\\log ^2 n)$\uff1f$O(n\\log ^3 n)$\uff1f\u53cd\u6b63\u6bd4\u90a3\u4e9bCDQ\u5206\u6cbb\u7684\u8981\u5feb\u5c31\u5bf9\u4e86\u3002\n\n------------------------------\n\n## \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nclock_t t=clock();\nnamespace my_std{\n    using namespace std;\n    #define pii pair<int,int>\n    #define fir first\n    #define sec second\n    #define MP make_pair\n    #define rep(i,x,y) for (int i=(x);i<=(y);i++)\n    #define drep(i,x,y) for (int i=(x);i>=(y);i--)\n    #define go(x) for (int i=head[x];i;i=edge[i].nxt)\n    #define templ template<typename T>\n    #define sz 101100\n    #define mod 1000000007ll\n    typedef long long ll;\n    typedef double db;\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    templ inline T rnd(T l,T r) {return uniform_int_distribution<T>(l,r)(rng);}\n    templ inline bool chkmax(T &x,T y){return x<y?x=y,1:0;}\n    templ inline bool chkmin(T &x,T y){return x>y?x=y,1:0;}\n    templ inline void read(T& t)\n    {\n        t=0;char f=0,ch=getchar();double d=0.1;\n        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n        if(ch=='.'){ch=getchar();while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();}\n        t=(f?-t:t);\n    }\n    template<typename T,typename... Args>inline void read(T& t,Args&... args){read(t); read(args...);}\n    char __sr[1<<21],__z[20];int __C=-1,__Z=0;\n    inline void __Ot(){fwrite(__sr,1,__C+1,stdout),__C=-1;}\n    inline void print(register int x)\n    {\n    \tif (__C>1<<20) __Ot(); if (x<0) __sr[++__C]='-',x=-x;\n    \twhile (__z[++__Z]=x%10+48,x/=10);\n    \twhile (__sr[++__C]=__z[__Z],--__Z);__sr[++__C]='\\n';\n    }\n    void file()\n    {\n        #ifndef ONLINE_JUDGE\n        freopen(\"a.in\",\"r\",stdin);\n        #endif\n    }\n    inline void chktime()\n    {\n        #ifndef ONLINE_JUDGE\n        cout<<(clock()-t)/1000.0<<'\\n';\n        #endif\n    }\n    #ifdef mod\n    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x%mod) if (y&1) ret=ret*x%mod;return ret;}\n    ll inv(ll x){return ksm(x,mod-2);}\n    #else\n    ll ksm(ll x,int y){ll ret=1;for (;y;y>>=1,x=x*x) if (y&1) ret=ret*x;return ret;}\n    #endif\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n\nint n;\nstruct hh{int t;ll w;int nxt;int col;}edge[sz<<1];\nint head[sz],ecnt;\nvoid make_edge(int f,int t,ll w,int col)\n{\n\tedge[++ecnt]=(hh){t,w,head[f],col};\n\thead[f]=ecnt;\n\tedge[++ecnt]=(hh){f,w,head[t],col};\n\thead[t]=ecnt;\n}\n\nint T;\nstruct BIT\n{\n\tll prod[sz<<2];\n\tint size[sz<<2];\n\tint mark[sz<<2];\n\tvoid mul(int x,ll w)\n\t{\n\t\tx+=n*2;\n\t\twhile (x<=n*4) \n\t\t{\n\t\t\tif (mark[x]!=T) size[x]=0,prod[x]=1;\n\t\t\t++size[x],prod[x]=prod[x]*w%mod;mark[x]=T;\n\t\t\tx+=(x&(-x));\n\t\t}\n\t}\n\tvoid query(int x,ll &w1,int &w2)\n\t{\n\t\tw1=1,w2=0;x+=n*2;\n\t\twhile (x) \n\t\t{\n\t\t\tif (mark[x]==T) w1=w1*prod[x]%mod,w2+=size[x];\n\t\t\tx-=(x&(-x));\n\t\t}\n\t}\n}T1,T2;\n\nll ans=1;\n#define v edge[i].t\nbool vis[sz];\nint size[sz],mn,root,tot;\nvoid findroot(int x,int fa)\n{\n\tsize[x]=1;\n\tint S=-1;\n\tgo(x) if (v!=fa&&!vis[v])\n\t{\n\t\tfindroot(v,x);\n\t\tsize[x]+=size[v];\n\t\tchkmax(S,size[v]);\n\t}\n\tchkmax(S,tot-size[x]);\n\tif (chkmin(mn,S)) root=x;\n}\nstruct hhh{int aa,bb;ll w;};\nhhh s[sz];int cnt;\nvoid dfs(int x,int fa,int a,int b,ll w)\n{\n\ts[++cnt]=(hhh){2*a-b,2*b-a,w};\n\tgo(x) if (v!=fa&&!vis[v])\n\t{\n\t\tif (edge[i].col) dfs(v,x,a,b+1,w*edge[i].w%mod);\n\t\telse dfs(v,x,a+1,b,w*edge[i].w%mod);\n\t}\n}\nvoid calc(int x)\n{\n\t++T;T1.mul(0,1);T2.mul(0,1);\n\tgo(x) if (!vis[v])\n\t{\n\t\tcnt=0;\n\t\tif (edge[i].col) dfs(v,0,0,1,edge[i].w);\n\t\telse dfs(v,0,1,0,edge[i].w);\n\t\trep(i,1,cnt)\n\t\t{\n\t\t\tll w1;int w2;\n\t\t\tT1.query(s[i].aa,w1,w2);\n\t\t\tans=ans*w1%mod*ksm(s[i].w,w2)%mod;\n\t\t\tT2.query(-s[i].bb-1,w1,w2);\n\t\t\tans=ans*inv(w1*ksm(s[i].w,w2)%mod)%mod;\n\t\t}\n\t\trep(i,1,cnt) T1.mul(-s[i].aa,s[i].w),T2.mul(s[i].bb,s[i].w);\n\t}\n}\nvoid solve(int x)\n{\n\tvis[x]=1;\n\tcalc(x);\n\tint all=tot;\n\tgo(x) if (!vis[v])\n\t{\n\t\ttot=size[v];if (size[v]>size[x]) tot=all-size[x];mn=1e9;\n\t\tfindroot(v,0);\n\t\tsolve(root);\n\t}\n}\n#undef v\n\nint main()\n{\n\tfile();\n\tint x,y,z,c;\n\tread(n);\n\trep(i,1,n-1) read(x,y,z,c),make_edge(x,y,z,c);\n\ttot=n;mn=1e9;findroot(1,0);\n\tsolve(root);\n\tcout<<ans;\n\treturn 0;\n}\n```",
        "postTime": 1552101445,
        "uid": 76481,
        "name": "p_b_p_b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF833D \u3010Red-Black Cobweb\u3011"
    },
    {
        "content": "\u70b9\u5206\u6cbb\uff0c\u4e3b\u8981\u6ce8\u610f\u5230\u9650\u5236\u53ef\u4ee5\u524d\u7f00\u548c\u5dee\u5206\uff0c\u7528\u6811\u72b6\u6570\u7ec4\u7ef4\u62a4\u524d\u7f00\u548c\u4e0e\u524d\u7f00\u79ef\u3002\n\n\u505a\u6cd5\u7684\u53ef\u884c\u6027\uff1aw/b<1/2\u548cw/b>2\u7684\u8def\u5f84\u6ca1\u6709\u4ea4\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define int long long\n#define lowbit(x) x&(-x)\nusing namespace std;\ninline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}\ninline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}\ninline void writeln(int x){write(x); puts(\"\");}\nconst int INF=1e9,N=2e5+5,mod=1e9+7;\nstruct edge{\n\tint link,next,val,col;\n}e[N<<1];\nbool vis[N];\nint ans,tot,T,Fa[N],size[N],All,mn,n,rt,head[N];\ninline void add_edge(int u,int v,int w,int c){\n\te[++tot]=(edge){v,head[u],w,c}; head[u]=tot;\n}\ninline void insert(int u,int v,int w,int c){\n\tadd_edge(u,v,w,c); add_edge(v,u,w,c);\n}\ninline void init(){\n\tn=read();\n\tfor (int i=1;i<n;i++) {\n\t\tint u=read(),v=read(),w=read(),c=read();\n\t\tinsert(u,v,w,c);\n\t}\n}\nstruct tree{\n\tint mark[N<<2],bit1[N<<2],bit2[N<<2];\n\tvoid update(int x,int v){\n\t\tx+=n*2;\n\t\tfor (;x<=n*4;x+=lowbit(x)){\n\t\t\tif (mark[x]!=T){\n\t\t\t\tmark[x]=T; bit1[x]=0; bit2[x]=1;\n\t\t\t}\n\t\t\tbit1[x]++; bit2[x]=1ll*bit2[x]*v%mod;\n\t\t}\n\t} \n\tvoid query(int x,int &v1,int &v2){\n\t\tx+=n*2;\n\t\tfor (;x;x-=lowbit(x)){\n\t\t\tif (mark[x]==T){\n\t\t\t\tv2+=bit1[x];\n\t\t\t\tv1=1ll*v1*bit2[x]%mod;\n\t\t\t}\n\t\t}\n\t}\n}T0,T1;\nvoid getroot(int u,int fa){\n\tsize[u]=1; int mx=0; Fa[u]=fa;\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link;\n\t\tif (v!=fa&&!vis[v]){\n\t\t\tgetroot(v,u); size[u]+=size[v];\n\t\t\tmx=max(mx,size[v]);\n\t\t}\n\t} \n\tmx=max(All-size[u],mx);\n\tif (mx<mn) mn=mx,rt=u;\n}\nstruct node{\n\tint a,b,v;\n}q[N];\nvoid dfs(int u,int fa,int a,int b,int v){\n\tq[++tot]=(node){a*2-b,b*2-a,v};\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link;\n\t\tif (!vis[v]&&v!=fa){\n\t\t\tdfs(v,u,a+(e[i].col),b+(!e[i].col),1ll*v*e[i].val%mod);\n\t\t} \n\t} \n}\ninline int pow(int x,int k){\n\tint y=1;\n\tfor (;k;k>>=1,x=1ll*x*x%mod){\n\t\tif (k&1) y=1ll*y*x%mod;\n\t}\n\treturn y;\n}\ninline void calc(int u){\n\tT++; T0.update(0,1); T1.update(0,1);\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link; \n\t\tif (!vis[v]){\n\t\t\ttot=0; dfs(v,u,e[i].col,!e[i].col,e[i].val);\n\t\t\tfor (int j=1;j<=tot;j++){\n\t\t\t\tint s=0,t=0,tmp=1;\n\t\t\t\tT0.query(q[j].a,ans,s);\n\t\t\t\tT1.query(-q[j].b-1,tmp,t);\n\t\t\t\tans=1ll*ans*pow(tmp,mod-2)%mod;\n\t\t\t\tans=1ll*ans*pow(q[j].v,s-t)%mod;\n\t\t\t}\n\t\t\tfor (int j=1;j<=tot;j++){\n\t\t\t\tT0.update(-q[j].a,q[j].v);\n\t\t\t\tT1.update(q[j].b,q[j].v);\n\t\t\t}\n\t\t} \n\t}\n}\nvoid divide(int u){\n\tvis[u]=1; calc(u); int tmp=All;\n\tfor (int i=head[u];i;i=e[i].next){\n\t\tint v=e[i].link;\n\t\tif (!vis[v]){\n\t\t\tAll=(v==Fa[u])?tmp-size[u]:size[v];\n\t\t\tmn=INF; getroot(v,u); divide(rt);\n\t\t}\n\t}\n}\ninline void solve(){\n\tmn=INF; All=n; ans=1;\n\tgetroot(1,0); divide(rt);\n\twriteln(ans);\n}\nsigned main(){\n\tinit(); solve();\n\treturn 0;\n}\n```",
        "postTime": 1545014749,
        "uid": 34444,
        "name": "\u5927\u83dc\u9e21fks",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF833D \u3010Red-Black Cobweb\u3011"
    },
    {
        "content": "# \u9898\u76ee\n&emsp;&emsp;[$luogu$](https://www.luogu.com.cn/problem/CF833D).\n# \u9898\u89e3\n&emsp;&emsp;\u70b9\u5206\u6cbb\uff1f\u70b9\u5206\u6cbb\u662f\u62ff\u4e0d\u4e86\u6700\u5feb\u901f\u5ea6\u7684\u3002/xyx\n## \u8fb9\u5206\u6cbb\n&emsp;&emsp;\uff08\u57fa\u7840\u7b97\u6cd5\u8bb2\u89e3\uff0c\u4f1a\u7684\u8df3\u8fc7\u5427qwq\u3002\uff09\n### \u6982\u5ff5\n&emsp;&emsp;\u987e\u540d\u601d\u4e49\uff0c\u5728\u70b9\u5206\u6cbb\u7684\u601d\u60f3\u4e0a\uff0c\u8fb9\u5206\u6cbb\u6bcf\u6b21\u4ee5\u4e00\u6761\u6811\u8fb9\u4e3a\u5206\u6cbb\u4e2d\u5fc3\uff0c\u628a\u539f\u6811\u5206\u5272\u6b63\u4e24\u5757\uff0c\u7edf\u8ba1\u7ecf\u8fc7\u5206\u6cbb\u4e2d\u5fc3\u8fb9\u7684\u7b54\u6848\uff0c\u5c06\u5176\u5220\u53bb\uff0c\u5e76\u9012\u5f52\u5269\u4f59\u90e8\u5206\u3002  \n&emsp;&emsp;\u5982\u4f55\u53d6\u5206\u6cbb\u4e2d\u5fc3\u5462\uff1f\u7c7b\u6bd4\u70b9\u5206\u6cbb\uff0c\u5f53\u7136\u662f\u8981\u8ba9**\u8fb9\u4e24\u4fa7\u8f83\u5927\u8054\u901a\u5757\u6700\u5c0f**\u5566\u3002\n### \u5bfb\u627e\u5206\u6cbb\u4e2d\u5fc3\u8fb9\n&emsp;&emsp;\u6839\u636e\u4e0a\u6587\uff0c\u5c31\u6709\u8fd9\u6837\u4e00\u4e2a\u548c\u627e\u4e2d\u5fc3\u5dee\u4e0d\u591a\u7684\u4ee3\u7801...\n```cpp\n// s: \u5f53\u524d\u8054\u901a\u5757\u5927\u5c0f\uff1bmxs: \u5206\u6cbb\u4e2d\u5fc3\u4e24\u4fa7\u8f83\u5927\u8054\u901a\u5757\u5927\u5c0f\uff1brte: \u5206\u6cbb\u4e2d\u5fc3\u8fb9id\u3002\ninline void FindCent ( const int u, const int f, const int s, int& mxs, int& rte ) {\n\tSiz[u] = 1;\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ! Vis[i >> 1] && ( v = Graph[i].To ) ^ f ) {\n\t\t\tFindCent ( v, u, s, mxs, rte ), Siz[u] += Siz[v];\n\t\t\tif ( mxs > Max ( Siz[v], s - Siz[v] ) ) {\n\t\t\t\trte = i, mxs = Max ( Siz[v], s - Siz[v] );\n\t\t\t}\n\t\t}\n\t}\n}\n```\n### \u91cd\u5efa\u6811\n&emsp;&emsp;\u7136\u540e\uff0c\u4ed4\u7ec6\u4e00\u60f3\uff0c\u4e8b\u60c5\u5e76\u4e0d\u7b80\u5355...  \n&emsp;&emsp;\u5047\u8bbe\u539f\u6811\u662f\u4e00\u6735\uff08\uff1f\uff09\u83ca\u82b1\uff0c\u90a3\u4e48\u6bcf\u6b21\u8f83\u5927\u5757\u6700\u5c0f\u503c\u53ea\u80fd-1\uff0c\u8fd9\u6837\u9012\u5f52\u5c42\u6570\u5c31\u8fbe\u5230 $O(n)$ \u4e86\uff01  \n&emsp;&emsp;\u4e8e\u662f\uff0c\u6211\u4eec\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\uff0c\u5c1d\u8bd5\u63d2\u5165\u4e00\u4e9b\u865a\u62df\u7ed3\u70b9\uff0c\u5728**\u4fdd\u8bc1\u6811\u4e0a\u4fe1\u606f\uff08\u70b9\u6743\uff0c\u8ddd\u79bb\u7b49\uff09\u4e0d\u88ab\u7834\u574f**\u7684\u60c5\u51b5\u4e0b\uff0c\u4f7f\u539f\u6811\u53d8\u4e3a\u4e00\u9897\u4f18\u7f8e\u7684**\u4e8c\u53c9\u6811**\u3002\u4e5f\u5373\u662f**\u591a\u53c9\u8f6c\u4e8c\u53c9**\u64cd\u4f5c\u3002  \n&emsp;&emsp;\u600e\u6837\u8f6c\u6362\u5462\uff1f\u53e3\u80e1\u4e00\u4e0b\u7b97\u6cd5\u6d41\u7a0b...  \n1. \u4efb\u53d6\u4e00\u70b9\u786e\u5b9a\u539f\u6811\u7236\u5b50\u5173\u7cfb\u3002  \n\n1. \u5bf9\u4e8e\u7ed3\u70b9 $u$ \uff08\u4e0d\u8bba\u5176\u662f\u5426\u662f\u865a\u62df\u7ed3\u70b9\uff09\uff0c\u82e5\u5b69\u5b50\u4e0d\u591a\u4e8e $2$ \u4e2a\uff0c\u76f4\u63a5\u5411\u5b69\u5b50\u4eec\u8fde\u8fb9\uff1b\u5426\u5219\uff0c\u4ee4 $u$ \u8fde\u5411\u4e24\u4e2a\u65b0\u5efa\u7684\u865a\u62df\u7ed3\u70b9\uff0c\u5e76\u628a\u5b69\u5b50\u4eec\u6309\u5947\u5076\u6027\u5206\u914d\u7ed9\u8fd9\u4e24\u4e2a\u865a\u62df\u7ed3\u70b9\u3002  \n\n1. \u5faa\u73af\u8fdb\u884c\uff0c\u76f4\u5230\u5904\u7406\u5b8c\u6240\u6709\uff08\u865a\u62df\u6216\u5b9e\u9645\uff09\u7ed3\u70b9\u3002  \n\n&emsp;&emsp;~~\u522b\u7740\u6025\uff0c\u6211\u77e5\u9053\u6211\u8bed\u6587\u4e0d\u597d\uff0c\u770b\u4ee3\u7801\uff1a~~\n```cpp\ninline void Prepare ( const int u, const int f ) {\n\tSiz[u] = 1;\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ( v = Graph[i].To ) ^ f ) {\n        \t// \u6ce8\u610f\uff1a\u53ea\u5728G\u4e0a\u8fde\u51fa\u5916\u5411\u6811\u3002\n\t\t\tG[u].push_back ( { v, Graph[i].Cost, Graph[i].Color } );\n\t\t\tPrepare ( v, u ), Siz[u] += Siz[v];\n            // \u4e0b\u9762\u8fd9\u53e5\u522b\u7740\u6025w\uff0c\u4e0e\u5efa\u6811\u7b97\u6cd5\u65e0\u5173\u3002\n\t\t\tAns1 = 1LL * Ans1 * qkpow ( Graph[i].Cost, 1LL * Siz[v] * ( n - Siz[v] ) % ( MOD - 1 ) ) % MOD;\n\t\t}\n\t}\n}\n```\n\n```cpp\ninline void Rebuild () {\n// \u9996\u5148\u6e05\u7a7a\u539f\u6811\u4fe1\u606f\u3002\n\tCnte = 1;\n\tfor ( Int i = 1; i <= n; ++ i ) Head[i] = 0;\n// \u5faa\u73af\u8fdb\u884c\u3002\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tif ( G[i].size () <= 2u ) {\n\t\t\tfor ( VecE adj: G[i] ) AddEdge ( i, adj.To, adj.Cost, adj.Color );\n\t\t} else {\n        \t// \u65b0\u5efa\u4e24\u4e2a\u865a\u62df\u7ed3\u70b9\uff08\u5de6\u53f3\u513f\u5b50\uff09\u3002\n\t\t\tint lc = ++ n, rc = ++ n;\n            // \u8fde\u8fb9\uff0c\u6743\u8bbe\u4e3a1\uff0c\u4e0d\u5f71\u54cd\u8def\u5f84\u4e58\u79ef\u4fe1\u606f\uff1b\u989c\u8272\u4e3a-1\uff0c\u4e0d\u5f71\u54cd\u989c\u8272\u7edf\u8ba1\u3002\n\t\t\tAddEdge ( i, lc, 1, -1 ), AddEdge ( i, rc, 1, -1 );\n            \t\t// \u5206\u914d\u5b69\u5b50\u3002\n\t\t\tfor ( Int j = 0; j ^ G[i].size (); ++ j ) {\n\t\t\t\tif ( j & 1 ) G[lc].push_back ( G[i][j] );\n\t\t\t\telse G[rc].push_back ( G[i][j] );\n\t\t\t}\n\t\t}\n\t}\n}\n```\n&emsp;&emsp;\u7c7b\u6bd4\u7ebf\u6bb5\u6811\u7684\u6811\u5f62\uff0c\u53ef\u4ee5\u53d1\u73b0\u8fd9\u6837\u91cd\u5efa\u6811\u7684\u7a7a\u95f4\u662f\u539f\u6811\u7684\u81f3\u591a $4$ \u500d\u3002\u5728\u8fd9\u9897\u6811\u4e0a\uff0c\u6211\u4eec\u5c31\u80fd\u4fdd\u8bc1\u5206\u6cbb\u5c42\u6570\u5728 $O(n\\log n)$ \u7ea7\u522b\u5566\u3002\n### \u5206\u6cbb\u8fc7\u7a0b\n&emsp;&emsp;\u8fd8\u662f\u8ddf\u70b9\u5206\u6cbb\u5dee\u4e0d\u591a...\u4e0d\u8fc7\u6ce8\u610f\u5728\u7528\u94fe\u5f0f\u524d\u5411\u661f\u5b58\u56fe\u65f6\uff0c\u4e0b\u6807\u8981\u4ece\u5076\u6570\u5f00\u59cb\uff0c\u8fd9\u6837\u5bf9\u4e8e\u4e00\u6761\u8fb9 $i$\uff0c\u5c31\u80fd\u8f7b\u6613\u627e\u5230\u5b83\u7684\u53cd\u5411\u8fb9 $i\\oplus1$\u3002\uff08\u2018$\\oplus$\u2019\u4e3a\u5f02\u6216\u8fd0\u7b97\u3002\uff09\n```cpp\ninline void Solve ( const int u, const int s ) {\n\tint mxs = s + 5, rte;\n\tFindCent ( u, 0, s, mxs, rte );\n\tif ( mxs == s + 5 ) return ;\n\tVis[rte >> 1] = true;\n\tint x = Graph[rte].To, y = Graph[rte ^ 1].To;\n    /*** \u8fd9\u91cc\u5904\u7406\u7ecf\u8fc7<x,y>\u7684\u8def\u5f84\u7684\u8d21\u732e\u3002 ***/\n\tint t = Siz[x];\n\tSolve ( x, t ), Solve ( y, s - t );\n}\n```\n&emsp;&emsp;\u5176\u4e2d\uff0c\u5904\u7406\u8def\u5f84\u4fe1\u606f\u7684\u90e8\u5206\u5c31\u548c\u70b9\u5206\u6cbb\u5dee\u4e0d\u591a\u4e86\u3002\u4e0d\u8fc7\u7531\u4e8e\u53ea\u6709\u4e24\u90e8\u5206\u4fe1\u606f\uff0c\u5c31\u4e0d\u7528\u8003\u8651\u5982\u4f55\u5408\u5e76\u4fe1\u606f\u4e86\u3002  \n&emsp;&emsp;\u8d60\u9001\u677f\u5b50\uff1a[$bzoj2870$\uff08\u4f20\u9001\u95e8\u5230dark\uff09](https://darkbzoj.tk/problem/2870).\n## \u672c\u9898\u5206\u6790\n&emsp;&emsp;\u8003\u8651\u5bb9\u65a5\uff0c\u5148\u6c42\u51fa\u6240\u6709\u8def\u5f84\u8fb9\u6743\u79ef\u7684\u79ef\uff0c\u518d\u51cf\u53bb\u4e0d\u5408\u6cd5\u65b9\u6848\u3002  \n&emsp;&emsp;\u5bf9\u4e8e\u524d\u8005\uff0c\u4e00\u6761\u6743\u4e3a $w$\uff0c\u5de6\u53f3\u70b9\u6570\u5206\u522b\u4e3a $a,b$ \u7684\u8fb9\u7684\u8d21\u732e\u662f $w^{ab}$\u3002\u4e5f\u5373\u662f\u5de6\u53f3\u4efb\u53d6\u4e00\u5bf9\u70b9\uff0c\u90fd\u4f1a\u4ea7\u751f\u4e00\u6b21\u8d21\u732e\u3002\u6ce8\u610f\u5230\u6307\u6570\u53ef\u4ee5\u7528\u8d39\u9a6c\u5c0f\u5b9a\u7406 $\\bmod~(10^9+6)$\u3002\uff08\u4e0d\u8fc7\u6ca1\u4ec0\u4e48\u5fc5\u8981\u3002\uff09\u4e0a\u6587 `Prepare` \u51fd\u6570\u7684 `Ans1` \u5c31\u662f\u5728\u8ba1\u7b97\u8fd9\u4e2a\u4e1c\u897f\u3002  \n&emsp;&emsp;\u5bf9\u4e8e\u540e\u8005\uff0c\u5206\u7ea2\u591a\u4e8e\u9ed1\uff0c\u9ed1\u591a\u4e8e\u7ea2\u4e24\u79cd\u60c5\u51b5\u8ba8\u8bba\u3002\u5047\u8bbe\u4e24\u6bb5\u8def\u5f84\u7684\u7ea2\u9ed1\u6570\u91cf\u4e3a $(r_1,b_1),(r_2,b_2)$\uff0c \u7b2c\u4e00\u79cd\u60c5\u51b5\u6709\uff1a\n$$\nr_1+r_2>2(b_1+b_2)\n$$\n&emsp;&emsp;\u5206\u79bb\uff1a\n$$\nr_2-2b_2>2b_1-r_1\n$$\n&emsp;&emsp;\u628a\u5206\u6cbb\u4e2d\u5fc3\u8fb9\u4e00\u4fa7\u7684\u6240\u6709 $2b_1-r_1$ \u548c\u5176\u5bf9\u5e94\u8def\u5f84\u7684\u79ef\u6536\u96c6\u8d77\u6765\u5e76\u6309 $2b_1-r_1$ \u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u518d\u679a\u4e3e\u53e6\u4e00\u4fa7\u7684 $(r_2,b_2)$\uff0c\u4e8c\u5206\u51fa\u53ef\u4ee5\u5bf9\u5176\u8d21\u732e\u6700\u5927 $2b_1-r_1$ \u7684\u4f4d\u7f6e\uff0c\u90a3\u4e48\u8be5\u4f4d\u7f6e\u7684\u524d\u7f00\u79ef\u5c31\u662f\u5f53\u524d\u5206\u6cbb\u4e2d\u5fc3\u8fb9\u7684\u7b54\u6848\u3002  \n&emsp;&emsp;\u53e6\u4e00\u79cd\u60c5\u51b5\u540c\u7406\u3002  \n&emsp;&emsp;\u6240\u4ee5...\u5c31\u8fd9\u6837\u54af\u3002\n```cpp\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\n\n#define Int register int\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nconst int MAXN = 1e5, MAXND = MAXN << 2, INF = 0x3f3f3f3f, MOD = 1e9 + 7;\nint n, m, Ans1 = 1, Ans2 = 1, Cnte = 1, Head[MAXND + 5], Siz[MAXND + 5];\nbool Vis[MAXND + 5];\nvector<pii> R, B; // less than the other one.\n\nstruct VecE { int To, Cost, Color; };\nvector<VecE> G[MAXND + 5];\n\nstruct Edge { int To, Cost, Color, nxt; } Graph[MAXND * 2 + 5];\n\ninline int Max ( const int a, const int b ) { return a > b ? a : b; }\n\ninline int qkpow ( int a, int b, const int p = MOD ) {\n\tint ret = 1;\n\tfor ( ; b; a = 1LL * a * a % p, b >>= 1 ) ret = 1LL * ret * ( b & 1 ? a : 1 ) % p;\n\treturn ret;\n}\n\ninline void Link ( const int s, const int t, const int w, const int c ) {\n\tGraph[++ Cnte] = { t, w, c, Head[s] };\n\tHead[s] = Cnte;\n}\n\ninline void AddEdge ( const int u, const int v, const int w, const int c ) {\n\tLink ( u, v, w, c ), Link ( v, u, w, c );\n}\n\ninline void Prepare ( const int u, const int f ) {\n\tSiz[u] = 1;\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ( v = Graph[i].To ) ^ f ) {\n\t\t\tG[u].push_back ( { v, Graph[i].Cost, Graph[i].Color } );\n\t\t\tPrepare ( v, u ), Siz[u] += Siz[v];\n\t\t\tAns1 = 1LL * Ans1 * qkpow ( Graph[i].Cost, 1LL * Siz[v] * ( n - Siz[v] ) % ( MOD - 1 ) ) % MOD;\n\t\t}\n\t}\n}\n\ninline void Rebuild () {\n\tCnte = 1;\n\tfor ( Int i = 1; i <= n; ++ i ) Head[i] = 0;\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tif ( G[i].size () <= 2u ) {\n\t\t\tfor ( VecE adj: G[i] ) AddEdge ( i, adj.To, adj.Cost, adj.Color );\n\t\t} else {\n\t\t\tint lc = ++ n, rc = ++ n;\n\t\t\tAddEdge ( i, lc, 1, -1 ), AddEdge ( i, rc, 1, -1 );\n\t\t\tfor ( Int j = 0; j ^ G[i].size (); ++ j ) {\n\t\t\t\tif ( j & 1 ) G[lc].push_back ( G[i][j] );\n\t\t\t\telse G[rc].push_back ( G[i][j] );\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void FindCent ( const int u, const int f, const int s, int& mxs, int& rte ) {\n\tSiz[u] = 1;\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ! Vis[i >> 1] && ( v = Graph[i].To ) ^ f ) {\n\t\t\tFindCent ( v, u, s, mxs, rte ), Siz[u] += Siz[v];\n\t\t\tif ( mxs > Max ( Siz[v], s - Siz[v] ) ) {\n\t\t\t\trte = i, mxs = Max ( Siz[v], s - Siz[v] );\n\t\t\t}\n\t\t}\n\t}\n}\n\ninline void CollectDist ( const int u, const int f, const int cr, const int cb, const int ds ) {\n\tif ( u <= m ) R.push_back ( { 2 * cr - cb, ds } ), B.push_back ( { 2 * cb - cr, ds } );\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ! Vis[i >> 1] && ( v = Graph[i].To ) ^ f ) {\n\t\t\tCollectDist ( v, u, cr + ( Graph[i].Color == 0 ), cb + ( Graph[i].Color == 1 ), 1LL * ds * Graph[i].Cost % MOD );\n\t\t}\n\t}\n}\n\ninline void Calc ( const int u, const int f, const int cr, const int cb, const int ds ) {\n\tif ( u <= m ) {\n\t\tint t = lower_bound ( R.begin (), R.end (), pii { cb - 2 * cr, 0 } ) - R.begin ();\n\t\tAns2 = 1LL * Ans2 * qkpow ( ds, t ) % MOD * ( t ? R[t - 1].second : 1 ) % MOD;\n\t\tt = lower_bound ( B.begin (), B.end (), pii { cr - 2 * cb, 0 } ) - B.begin ();\n\t\tAns2 = 1LL * Ans2 * qkpow ( ds, t ) % MOD * ( t ? B[t - 1].second : 1 ) % MOD;\n\t}\n\tfor ( Int i = Head[u], v; i; i = Graph[i].nxt ) {\n\t\tif ( ! Vis[i >> 1] && ( v = Graph[i].To ) ^ f ) {\n\t\t\tCalc ( v, u, cr + ( Graph[i].Color == 0 ), cb + ( Graph[i].Color == 1 ), 1LL * ds * Graph[i].Cost % MOD );\n\t\t}\n\t}\n}\n\ninline void Solve ( const int u, const int s ) {\n\tint mxs = s + 5, rte;\n\tFindCent ( u, 0, s, mxs, rte );\n\tif ( mxs == s + 5 ) return ;\n\tVis[rte >> 1] = true;\n\tint x = Graph[rte].To, y = Graph[rte ^ 1].To;\n\tR.clear (), B.clear (), R.clear (), B.clear ();\n\tCollectDist ( x, 0, 0, 0, 1 );\n\tsort ( R.begin (), R.end () ), sort ( B.begin (), B.end () );\n\tif ( R.size () ) for ( Int i = 1; i ^ R.size (); ++ i ) R[i].second = 1LL * R[i - 1].second * R[i].second % MOD;\n\tif ( B.size () ) for ( Int i = 1; i ^ B.size (); ++ i ) B[i].second = 1LL * B[i - 1].second * B[i].second % MOD;\n\tCalc ( y, 0, Graph[rte].Color == 0, Graph[rte].Color == 1, Graph[rte].Cost );\n\tint t = Siz[x];\n\tSolve ( x, t ), Solve ( y, s - t );\n}\n\ninline void Work () {\n\tscanf ( \"%d\", &n ), m = n;\n\tfor ( Int i = 1, u, v, w, c; i ^ n; ++ i ) {\n\t\tscanf ( \"%d %d %d %d\", &u, &v, &w, &c );\n\t\tAddEdge ( u, v, w, c );\n\t}\n\tPrepare ( 1, 0 );\n\tRebuild ();\n#ifdef __DEBUG\n\tfor ( Int i = 1; i <= n; ++ i ) {\n\t\tfor ( Int j = Head[i]; j; j = Graph[j].nxt ) {\n\t\t\tprintf ( \"%d %d (%d,%d)\\n\", i, Graph[j].To, Graph[j].Cost, Graph[j].Color );\n\t\t}\n\t}\n#endif\n\tSolve ( 1, n );\n\tprintf ( \"%d\\n\", int ( 1LL * Ans1 * qkpow ( Ans2, MOD - 2 ) % MOD ) );\n}\n\nint main () {\n\tWork ();\n\treturn 0;\n}\n```\n&emsp;&emsp;\u622a\u6b62\u63d0\u4ea4\u65f6\uff0c\u6700\u4f18\u89e3 rk1\uff0c\u6bd4\u697c\u4e0b\u5feb\u8fd1 5s\u3002/xyx",
        "postTime": 1585384554,
        "uid": 123807,
        "name": "Rainybunny",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF833D \u3010Red-Black Cobweb\u3011& \u8fb9\u5206\u6cbb\u5c0f\u7ed3"
    },
    {
        "content": "\u5e7f\u544a\uff1a\u98df\u7528[$blog$](https://www.cnblogs.com/heyujun/p/10199924.html)\u4f53\u9a8c\u66f4\u4f73\n\n## \u9898\u89e3\n\n\u770b\u5230\u8fd9\u79cd\u7edf\u8ba1\u8def\u5f84\u7684\u9898\u76ee\u5f53\u7136\u662f\u6dc0\u7c89\u8d28\u5566\u3002\n\n\u8003\u8651\u8f6c\u5316\u4e00\u4e0b\u4fe1\u606f\uff0c\u8bbe\u4e00\u6761\u8def\u5f84\u4e0a\u6709\u7ea2\u70b9$a$\u4e2a\uff0c\u9ed1\u70b9$b$\u4e2a\n\n\u5219$2min(a,b)\\geq max(a,b)$\n\n$\\Leftrightarrow 2*a\\geq b$\u4e14$2*b\\geq a$\n\n\u73b0\u5728\u6211\u4eec\u9700\u8981\u5c06\u8fc7\u4e00\u4e2a\u70b9\u7684\u4e24\u6761\u8def\u5f84\u5408\u5e76\n\n\u8bbe\u7b2c\u4e00\u6761\u4e3a\u7ea2$a_1$\uff0c\u9ed1$b_1$\uff0c\u7b2c\u4e8c\u6761\u4e3a\u7ea2$a_2$\uff0c\u9ed1$b_2$\n\n\u5219\u6709\n\n$2(a_1+a_2)\\geq b_1+b_2$ \n\n$2(b_1+b_2)\\geq a_1+a_2  $\n\n\u5c06\u4e00\u4e2a\u4e0b\u6807\u7684\u653e\u4e00\u8fb9\u4ee5\u4fbf\u7ef4\u62a4\n\n$2a_2-b_2\\geq b_1-2a_1$\n\n$2b_2-a_2\\geq a_1-2b_1$\n\n\n\u6bcf\u6b21\u904d\u5386\u5b8c\u4e00\u9897\u5b50\u6811\uff0c\u6309\u65f6\u95f4\u52a0\u5165\u6240\u6709\u7684\u8def\u5f84\uff0c\u5c06\u4e0d\u7b49\u5f0f\u5de6\u8fb9\u770b\u4f5c\u67e5\u8be2\u4e8c\u7ef4\u5e73\u9762\uff0c\n\n\u53f3\u8fb9\u770b\u4f5c\u63d2\u5165\u5750\u6807\uff0c\u5c31\u662f\u4e00\u4e2a$cdq$\u5206\u6cbb\n\n\u590d\u6742\u5ea6\u662f$nlog^4$(\u56e0\u4e3a\u4e2d\u95f4\u8fd8\u6709\u5feb\u901f\u5e42),\u4f46\u5e38\u6570\u5f88\u5c0f\n\n\u4ee3\u7801\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> \n#include <cmath> \n#include <algorithm>\nusing namespace std;\ninline int gi() {\n\tregister int data = 0, w = 1;\n\tregister char ch = 0;\n\twhile (!isdigit(ch) && ch != '-') ch = getchar(); \n\tif (ch == '-') w = -1, ch = getchar();\n\twhile (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar();\n\treturn w * data; \n} \nconst int MAX_N = 1e5 + 5; \nconst int Mod = 1e9 + 7;\nint fpow(int x, int y) {\n\tint res = 1; \n\twhile (y) {\n\t\tif (y & 1) res = 1ll * res * x % Mod;\n\t\tx = 1ll * x * x % Mod;\n\t\ty >>= 1; \n\t} \n\treturn res; \n} \nstruct Point { int x, y, op, v; } ; \nbool operator < (const Point &l, const Point &r) { return (l.x == r.x) ? (l.y < r.y) : (l.x < r.x); } \nstruct Graph { int to, cost, col, next; } e[MAX_N << 1]; int fir[MAX_N], e_cnt = 0; \nvoid clearGraph() { memset(fir, -1, sizeof(fir)); e_cnt = 0; } \nvoid Add_Edge(int u, int v, int w, int c) {\n\te[e_cnt].to = v, e[e_cnt].cost = w, e[e_cnt].col = c, e[e_cnt].next = fir[u];\n\tfir[u] = e_cnt++;\n} \nint N, ans = 1, size[MAX_N]; \nbool used[MAX_N]; \nint centroid, sz, rmx, c1[MAX_N << 2], c2[MAX_N << 2]; \nPoint stk[MAX_N], q[MAX_N << 2]; \nint top, cnt; \ninline int lb(int x) { return x & -x; }\nvoid add(int x, int v) { while (x <= N * 4 + 1) c1[x] = 1ll * c1[x] * v % Mod, c2[x]++, x += lb(x); } \nint Sum(int x) { int res = 1; while (x > 0) res = 1ll * c1[x] * res % Mod, x -= lb(x); return res; } \nint Cnt(int x) { int res = 0; while (x > 0) res += c2[x], x -= lb(x); return res; } \nvoid Set(int x) { while (x <= N * 4 + 1) c1[x] = 1, c2[x] = 0, x += lb(x); } \nvoid search_centroid(int x, int fa) { \n    size[x] = 1; int mx = 0; \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; \n\t\tif (v == fa || used[v]) continue; \n\t\tsearch_centroid(v, x); \n\t\tsize[x] += size[v]; \n\t\tmx = max(mx, size[v]); \n\t} \n\tmx = max(mx, sz - size[x]); \n\tif (mx < rmx) rmx = mx, centroid = x; \n} \nvoid dfs(int x, int fa, int R, int B, int val) {\n\tstk[++top] = (Point){R, B, 0, val}; \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; \n\t\tif (v == fa || used[v]) continue; \n\t\tif (e[i].col == 0) dfs(v, x, R + 1, B, 1ll * val * e[i].cost % Mod); \n\t\telse if (e[i].col != 0) dfs(v, x, R, B + 1, 1ll * val * e[i].cost % Mod); \n\t} \n} \nvoid Div(int l, int r) { \n\tif (l >= r) return ; \n\tint mid = (l + r) >> 1; \n\tDiv(l, mid); Div(mid + 1, r);\n\tint j = l; \n\tfor (int i = mid + 1; i <= r; i++) { \n\t\tif (!q[i].op) continue; \n\t\twhile (q[j].x <= q[i].x && j <= mid) { if (!q[j].op) add(q[j].y, q[j].v); ++j; } \n\t\tans = 1ll * ans * Sum(q[i].y) % Mod * fpow(q[i].v, Cnt(q[i].y)) % Mod; \n\t}\n\tfor (int i = l; i < j; i++) if (!q[i].op) Set(q[i].y); \n\tinplace_merge(&q[l], &q[mid + 1], &q[r + 1]); \n} \nvoid solve(int x) {\n\tused[x] = 1;\n\tcnt = 0; int Pls = 2 * N + 1; \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to; \n\t\tif (used[v]) continue; \n\t\ttop = 0; \n\t\tif (e[i].col == 0) dfs(v, x, 1, 0, e[i].cost); \n\t\telse if (e[i].col == 1) dfs(v, x, 0, 1, e[i].cost); \n\t\tfor (int j = 1; j <= top; j++) {\n\t\t\tint a = stk[j].x, b = stk[j].y;\n            q[++cnt] = (Point){2 * a - b + Pls, 2 * b - a + Pls, 1, stk[j].v}; \n\t\t} \n\t\tfor (int j = 1; j <= top; j++) {\n\t\t\tint a = stk[j].x, b = stk[j].y; \n\t\t\tq[++cnt] = (Point){b - 2 * a + Pls, a - 2 * b + Pls, 0, stk[j].v};\n\t\t\tif (2 * min(a, b) >= max(a, b)) ans = 1ll * ans * stk[j].v % Mod; \n\t\t} \n\t} \n\tDiv(1, cnt); \n\tfor (int i = fir[x]; ~i; i = e[i].next) { \n\t\tint v = e[i].to;\n\t\tif (used[v]) continue; \n\t\tsz = rmx = size[v];\n\t\tsearch_centroid(v, x); \n\t\tsolve(centroid); \n\t} \n} \nint main () { \n\tclearGraph(); \n\tN = gi();\n\tfor (int i = 1; i < N; i++) {\n\t\tint u = gi(), v = gi(), w = gi(), c = gi();\n\t\tAdd_Edge(u, v, w, c); \n\t\tAdd_Edge(v, u, w, c); \n\t}\n\tfor (int i = 1; i <= 4 * N + 1; i++) c1[i] = 1, c2[i] = 0; \n\tsz = rmx = N; \n\tsearch_centroid(1, 0); \n\tsolve(centroid);\n\tprintf(\"%d\\n\", ans); \n\treturn 0; \n} \n```",
        "postTime": 1547692517,
        "uid": 42506,
        "name": "\u4f55\u4fde\u5747",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF833D \u3010Red-Black Cobweb\u3011"
    },
    {
        "content": "### [\u9898\u9762](http://codeforces.com/problemset/problem/833/D)\n\n### \u9898\u89e3\n\n\u70b9\u5206\u6cbb\u5927\u706b\u9898\u3002\u3002\u3002\n\n\u8bbe\u767d\u8fb9\u6570\u91cf\u4e3a$a$\uff0c\u9ed1\u8fb9\u4e3a$b$\uff0c\u5219$2min(a,b)\\geq max(a,b)$\n\n\u5373$2a\\geq b\\;\\&\\&2b\\geq a$\n\n\u8003\u8651\u70b9\u5206\u6cbb\u65f6\u5982\u4f55\u7edf\u8ba1\u7b54\u6848\uff1a\n\n$2(a_1 +a_2) \\geq b_1 + b_2$\n\n$\\therefore 2a_1-b_1\\geq b_2-2a_2$\n\n\u53e6\u5916\u4e00\u8fb9\u540c\u7406\n\n\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u6109\u5feb\u5730\u7528$sort+BIT$\u7edf\u8ba1\u7b54\u6848\u4e86\n\n\u4f46\u662f\u8def\u5f84\u6709\u53ef\u80fd\u91cd\u590d\u8ba1\u7b97\uff0c\u53ef\u4ee5\u5957\u4e00\u4e2a$CDQ$\u5206\u6cbb\u4ec0\u4e48\u7684\u6765\u641e\u4e00\u4e0b\n\n### \u4ee3\u7801\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define RG register\n#define clear(x, y) memset(x, y, sizeof(x));\n\nnamespace IO\n{\n\tconst int BUFSIZE = 1 << 20;\n\tchar ibuf[BUFSIZE], *is = ibuf, *it = ibuf;\n\tinline char getchar() { if (is == it) it = (is = ibuf) + fread(ibuf, 1, BUFSIZE, stdin); return *is++; }\n}\n\ninline int read()\n{\n\tint data = 0, w = 1;\n\tchar ch = IO::getchar();\n\twhile(ch != '-' && (ch < '0' || ch > '9')) ch = IO::getchar();\n\tif(ch == '-') w = -1, ch = IO::getchar();\n\twhile(ch >= '0' && ch <= '9') data = data * 10 + (ch ^ 48), ch = IO::getchar();\n\treturn data*w;\n}\n\nconst int maxn(1e5 + 10), Mod(1e9 + 7);\ninline int fastpow(int x, int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y & 1) ans = 1ll * ans * x % Mod;\n\t\tx = 1ll * x * x % Mod, y >>= 1;\n\t}\n\treturn ans;\n}\n\nstruct edge { int next, to, val, col; } e[maxn << 1];\nint n, head[maxn], e_num, size[maxn], Size, min, root;\nstruct qry { int r, b, v, o; } stk[maxn], q[maxn << 2];\nint top, cntq, cntup, csum[maxn << 2], cmul[maxn << 2], vis[maxn];\ninline bool cmpr(const qry &a, const qry &b)\n\t{ return a.r == b.r ? a.b < b.b : a.r < b.r; }\n\nvoid clean(int x)\n{\n\twhile(x <= (n << 2 | 1)) csum[x] = 0, cmul[x] = 1, x += x & -x;\n}\n\nvoid add(int x, int v)\n{\n\twhile(x <= (n << 2 | 1))\n\t\t++csum[x], cmul[x] = 1ll * cmul[x] * v % Mod, x += x & -x;\n}\n\nint query_sum(int x)\n{\n\tint ans = 0;\n\twhile(x) ans += csum[x], x -= x & -x;\n\treturn ans;\n}\n\nint query_mul(int x)\n{\n\tint ans = 1;\n\twhile(x) ans = 1ll * ans * cmul[x] % Mod, x -= x & -x;\n\treturn ans;\n}\n\ninline void add_edge(int from, int to, int val, int col)\n{\n\te[++e_num] = (edge) {head[from], to, val, col};\n\thead[from] = e_num;\n}\n\nvoid getRoot(int x, int fa)\n{\n\tsize[x] = 1; int tot = 0;\n\tfor(RG int i = head[x]; i; i = e[i].next)\n\t{\n\t\tint to = e[i].to; if(vis[to] || to == fa) continue;\n\t\tgetRoot(to, x); tot = std::max(tot, size[to]);\n\t\tsize[x] += size[to];\n\t}\n\ttot = std::max(tot, Size - size[x]);\n\tif(tot < min) min = tot, root = x;\n}\n\nvoid getVal(int x, int fa, int r, int b, int v)\n{\n\tstk[++top] = (qry) {r, b, v, 0};\n\tfor(RG int i = head[x]; i; i = e[i].next)\n\t{\n\t\tint to = e[i].to; if(vis[to] || to == fa) continue;\n\t\tgetVal(to, x, r + (!e[i].col), b + e[i].col, 1ll * v * e[i].val % Mod);\n\t}\n}\n\nint ans = 1;\nvoid CDQ(int l, int r)\n{\n\tif(l >= r) return;\n\tint mid = (l + r) >> 1;\n\tCDQ(l, mid); CDQ(mid + 1, r);\n\tint j = l;\n\tfor(RG int i = mid + 1; i <= r; i++)\n\t{\n\t\tif(!q[i].o) continue;\n\t\twhile(q[j].r <= q[i].r && j <= mid)\n\t\t{\n\t\t\tif(!q[j].o) add(q[j].b, q[j].v);\n\t\t\t++j;\n\t\t}\n\t\tans = 1ll * ans * query_mul(q[i].b) % Mod *\n\t\t\tfastpow(q[i].v, query_sum(q[i].b)) % Mod;\n\t}\n\tfor(RG int i = l; i < j; i++) if(!q[i].o) clean(q[i].b);\n\tstd::inplace_merge(q + l, q + mid + 1, q + r + 1, cmpr);\n}\n\nvoid calc(int x)\n{\n\tint PLUS = n << 1 | 1;\n\tcntq = cntup = 0;\n\tfor(RG int i = head[x]; i; i = e[i].next)\n\t{\n\t\tint to = e[i].to; if(vis[to]) continue;\n\t\ttop = 0; getVal(to, x, !e[i].col, e[i].col, e[i].val);\n\t\tfor(RG int j = 1; j <= top; j++)\n\t\t{\n\t\t\tint a = stk[j].r, b = stk[j].b, c = 2 * a - b, d = 2 * b - a;\n\t\t\tq[++cntq] = (qry) {c + PLUS, d + PLUS, stk[j].v, 1};\n\t\t}\n\t\tfor(RG int j = 1; j <= top; j++)\n\t\t{\n\t\t\tint a = stk[j].r, b = stk[j].b, c = 2 * a - b, d = 2 * b - a;\n\t\t\tq[++cntq] = (qry) {-c + PLUS, -d + PLUS, stk[j].v, 0};\n\t\t\tif(2 * std::min(a, b) >= std::max(a, b))\n\t\t\t\tans = 1ll * ans * stk[j].v % Mod;\n\t\t}\n\t}\n\tCDQ(1, cntq);\n}\n\nvoid dfs(int x)\n{\n\tvis[x] = 1; calc(x);\n\tfor(RG int i = head[x]; i; i = e[i].next)\n\t{\n\t\tint to = e[i].to; if(vis[to]) continue;\n\t\tSize = min = size[to]; getRoot(to, x); dfs(root);\n\t}\n}\n\nint main()\n{\n\tSize = min = n = read();\n\tfor(int i = 1, a, b, c, d; i < n; i++)\n\t\ta = read(), b = read(), c = read(), d = read(),\n\t\tadd_edge(a, b, c, d), add_edge(b, a, c, d);\n\tfor(RG int i = 1; i <= (n << 2 | 1); i++) csum[i] = 0, cmul[i] = 1;\n\tgetRoot(1, 0); dfs(root);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n```\n\n",
        "postTime": 1545630377,
        "uid": 46800,
        "name": "xgzc",
        "ccfLevel": 9,
        "title": "CF833D Red-Black Cobweb"
    }
]