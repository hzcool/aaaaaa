[
    {
        "content": "\u6211\u4eec\u9996\u5148\u5728\u539f\u4e32\u91cc\u627e\u51fa\u6240\u6709\u7684\u9650\u5236\u4e32\uff0c\u8fd9\u53ef\u4ee5\u4f7f\u7528\u5b57\u7b26\u4e32\u54c8\u5e0c\u5728 $O(nk)$ \u65f6\u95f4\u5185\u5b8c\u6210\uff0c\u8fd9\u513f $n$ \u662f\u539f\u4e32\u957f\u5ea6\uff0c $k$ \u662f\u9650\u5236\u7684\u5b57\u7b26\u4e32\u4e2a\u6570\u3002\n\n\u63a5\u7740\u5bf9\u6bcf\u4e2a\u5339\u914d\u6bb5\u5f00\u59cb\u7684\u4f4d\u7f6e\u8bb0\u5f55**\u4ee5\u8fd9\u4e2a\u70b9\u5f00\u59cb\u7684\u9650\u5236\u7684\u5b57\u7b26\u4e32\u4e2d\u53f3\u7aef\u70b9\u6700\u9760\u53f3\u7684\u4e00\u4e2a**\u3002\n\n\u63a5\u7740\u5012\u5e8f\u626b\u63cf\uff0c\u7ef4\u62a4\u5f53\u524d\u7b54\u6848\u6bb5\u7684\u53f3\u7aef\u70b9\uff0c\u82e5\u5b83\u5df2\u7ecf\u8986\u76d6\u4e86\u4e00\u4e2a\u9650\u5236\u4e32\uff0c\u628a\u5b83\u6539\u4e3a\u8fd9\u4e2a\u9650\u5236\u4e32\u53f3\u4fa7\u7aef\u70b9\u4e0b\u6807 $-1$ \u5c31\u597d\u4e86\u3002\n\n\u5982\u679c\u4e0d\u7528\u5b57\u7b26\u4e32\u54c8\u5e0c\u90a3\u590d\u6742\u5ea6\u662f $O(nkL)$\uff0c$L$ \u4e3a $b_i$ \u957f\u5ea6\uff0c\u5982\u679c\u6b63\u5e38\u51fa\u9898\u4eba\u7684\u8bdd\u80af\u5b9a\u4e0d\u4f1a\u653e\u8fc7\u53bb\u7684\u3002\n\n```cpp\n/* This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/. */\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#define repn(i, n) for (int i = 1; i <= (int)n; i++)\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define repr(i, m, n) for (int i = (int)m; i <= (int)n; i++)\n#define repd(i, m, n) for (int i = (int)m; i >= (int)n; i--)\n#define ttt template <typename T>\n#define chmax(a, b) a = max(a, b)\n#define chmin(a, b) a = min(a, b)\n#define eprintf(...) ;  // fprintf(stderr, __VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nttt inline T rd(T& x) {\n  x = 0;\n  T neg = 1;\n  char c = 0;\n  while (c < '0' || c > '9') {\n    if (c == '-') neg = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') {\n    x = x * 10 + c - 48;\n    c = getchar();\n  }\n  x *= neg;\n  return x;\n}\n// -------- Item Get Border Line! -----------\n// Don't forget to use long long if needed!\nusing ull = unsigned long long;\nconst int base = 13331;\nstruct Hasher {\n  ull h[100010], p[100010];\n  int n;\n  void initHash(string& s) {\n    n = s.length();\n    if (s.front() != '%') s = \"%\" + s;\n    p[0] = 1;\n    repn(i, n) {\n      h[i] = h[i - 1] * base + (s[i] - '0' + 1);\n      p[i] = p[i - 1] * base;\n    }\n  }\n  ull getRangeHash(int l, int r) { return h[r] - h[l - 1] * p[r - l + 1]; }\n  ull getHash(void) { return getRangeHash(1, n); }\n} H, h[11];\nint n, k;\nstring b[11];\nint len[11];\nint rightEnd[100010];\nint main() {\n  string s;\n  cin >> s;\n  n = s.length();\n  H.initHash(s);\n  rd(k);\n  repn(i, k) {\n    cin >> b[i];\n    len[i] = b[i].length();\n    h[i].initHash(b[i]);\n  }\n  // find all matching positions\n  memset(rightEnd, 0x3f, sizeof(rightEnd));\n  repn(j, k) {\n    repn(i, n) {\n      if (i + len[j] - 1 > n) break;\n      if (s[i] != b[j][1]) continue;\n      eprintf(\"i = %d, %llu, %llu\\n\", i, H.getRangeHash(i, i + len[j] - 1),\n              h[j].getHash());\n      if (H.getRangeHash(i, i + len[j] - 1) == h[j].getHash()) {\n        chmin(rightEnd[i], i + len[j] - 1);\n      }\n    }\n  }\n  // repn(i, n) sum[i] += sum[i - 1];\n  // repn(i, n) {eprintf(\"%d \", rightEnd[i]);} eprintf(\"\\n\");\n  int cur = n, ans = 0, ansi = 0;\n  repd(i, n, 1) {\n    if (rightEnd[i] <= cur) cur = rightEnd[i] - 1;\n    if (cur - i + 1 >= ans) {\n      ans = cur - i + 1;\n      ansi = i - 1;\n    }\n  }\n  printf(\"%d %d\\n\", ans, ansi);\n}\n```",
        "postTime": 1634399278,
        "uid": 87696,
        "name": "Lily_White",
        "ccfLevel": 6,
        "title": "CF79C"
    }
]