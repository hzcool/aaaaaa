[
    {
        "content": "\u9898\u610f\uff1a\u7ed9\u51fa\u4e00\u4e2a\u5b57\u7b26\u4e32 str\uff0c\u7136\u540e\u6709 n \u4e2a\u53ef\u4f9b\u4f7f\u7528\u7684\u5b57\u7b26\u4e32\uff0c\u73b0\u5728\u5728 n \u4e2a\u53ef\u7528\u5b57\u7b26\u4e32\u4e2d\u9009\u53d6\u4e00\u5b9a\u7684\u5b57\u7b26\u7ec4\u6210\u5b57\u7b26\u4e32 str\uff0c\u4ece\u7b2c i \u4e2a\u4e32\u4e2d\u62ff\u4e00\u4e2a\u5b57\u7b26\u7684\u4ee3\u4ef7\u662f i \u4e14\u6700\u591a\u62ff num[i] \u4e2a\uff0c\u6c42\u7ec4\u6210\u76ee\u6807\u5b57\u7b26\u4e32\u7684\u6700\u5c0f\u82b1\u8d39\n\n**\u601d\u8def\uff1a\u6700\u5c0f\u8d39\u7528\u6d41**\n\n\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u7ea7\u6e90\u70b9\u4e0e\u8d85\u7ea7\u6c47\u70b9\uff0c\u4ece\u6e90\u70b9\u5230 26 \u4e2a\u5b57\u7b26\u5efa\u8fb9\uff0c\u5bb9\u91cf\u8bb0\u4e3a\u5b57\u7b26\u4e32 str \u7684\u4e2a\u6570\uff0c\u8d39\u7528\u4e3a 0\uff0c\u7136\u540e\u5c06\u6bcf\u4e2a\u5b57\u7b26\u5411 n \u4e2a\u5b57\u7b26\u4e32\u5efa\u8fb9\uff0c\u5bf9\u4e8e\u7b2c i \u4e2a\u4e32\u6765\u8bf4\uff0c\u5bb9\u91cf\u4e3a\u8be5\u4e32\u4e2d\u76f8\u5e94\u5b57\u7b26\u7684\u4e2a\u6570\uff0c\u8d39\u7528\u4e3a i\uff0c\u6700\u540e\u5bf9\u6bcf\u4e2a\u6a21\u5f0f\u4e32\u5411\u6c47\u70b9\u5efa\u8fb9\uff0c\u5bb9\u91cf\u4e3a num[i]\uff0c\u8d39\u7528\u4e3a 0\n\nAC\u4ee3\u7801:\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nstruct Edge{\n    int from,to;\n    int cap,flow;\n    int cost;\n    int next;\n}edge[10001];\nint head[10001],tot,n;\nchar str[10001];\nint bucket[27];//str\u4e32\u4e2d\u5b57\u7b26\u4e2a\u6570\nint G[10001][27];//n\u4e2a\u5b57\u7b26\u4e32\u6bcf\u4e32\u7684\u5b57\u7b26\u4e2a\u6570\nint num[10001];//n\u4e2a\u5b57\u7b26\u4e32\u6bcf\u4e32\u6700\u591a\u53d6\u7684\u4e2a\u6570\nint pre[10001];//\u8bb0\u5f55\u4eceS\u5230i\u7684\u6700\u5c0f\u8d39\u7528\u8def\u5f84\u4e0a\u7684\u6700\u540e\u4e00\u6761\u5f27\u7f16\u53f7\nint dis[10001];\nbool vis[10001];\nbool SPFA(int S,int T) {\n    queue<int> Q;\n    memset(dis,INF,sizeof(dis));\n    memset(vis,false,sizeof(vis));\n    memset(pre,-1,sizeof(pre));\n    dis[S]=0;\n    Q.push(S);\n    while(!Q.empty()) {\n        int x=Q.front();\n        Q.pop();\n        vis[x]=false;\n        for(int i=head[x];i!=-1;i=edge[i].next) {\n            int y=edge[i].to;\n            int cost=edge[i].cost;\n            int cap=edge[i].cap;\n            int flow=edge[i].flow;\n            if(dis[y] > dis[x]+cost&&cap > flow) {\n                dis[y]=dis[x]+cost;\n                pre[y]=i;\n                if(!vis[y]){\n                    vis[y]=true;\n                    Q.push(y);\n                }\n            }\n        }\n    }\n    return pre[T]!=-1;\n}\nvoid MCMF(int S,int T,int &flow,int &cost){\n    flow=0;\n    cost=0;\n    while(SPFA(S,T)){//\u6bcf\u6b21\u5bfb\u627e\u82b1\u9500\u6700\u5c0f\u7684\u8def\u5f84\n        int minn=INF;\n        for(int i=pre[T];i!=-1;i=pre[edge[i^1].to])//\u5bfb\u627e\u6700\u5c0f\u589e\u5e7f\u6d41\n            minn=min(minn,edge[i].cap-edge[i].flow);\n        for(int i=pre[T];i!=-1;i=pre[edge[i^1].to]) {\n            edge[i].flow += minn;\n            edge[i^1].flow-=minn;\n            cost += edge[i].cost*minn;//\u589e\u5e7f\u6d41\u7684\u82b1\u9500\n        }\n        flow += minn;//\u603b\u6d41\u91cf\u589e\u52a0\n    }\n}\nvoid addEdge(int from,int to,int cap,int flow,int cost){\n    edge[tot].from=from;\n    edge[tot].to=to;\n    edge[tot].cap=cap;\n    edge[tot].flow=flow;\n    edge[tot].cost=cost;\n    edge[tot].next=head[from];\n    head[from]=tot++;\n}\nint main(){\n    scanf(\"%s\",str);\n    int len=strlen(str);\n    for(int i=0;i<len;i++)//\u7edf\u8ba1str\u4e32\u4e2d\u5b57\u7b26\u7684\u4e2a\u6570\n        bucket[str[i]-'a'+1]++;\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++){\n        char temp[10001];\n        scanf(\"%s%d\",temp,&num[i]);\n        int length=strlen(temp);\n        for(int j=0;j<length;j++)\n            G[i][temp[j]-'a'+1]++;//\u7edf\u8ba1\u7b2ci\u4e2a\u5b57\u7b26\u4e32\u4e2d\u5b57\u7b26\u7684\u4e2a\u6570\n    }\n    tot=0;\n    memset(head,-1,sizeof(head));\n    int S=0,T=26+n+1;\n    for(int i=1;i<=26;i++){\n        if (bucket[i] == 0) continue;\n        //\u6e90\u70b9\u523026\u4e2a\u5b57\u7b26\n        addEdge(S,i,bucket[i],0,0);//\u6b63\u5411\u8fb9\n        addEdge(i,S,0,0,0);//\u53cd\u5411\u8fb9\n        for(int j=1;j<=n;j++){\n            if (G[j][i] == 0) continue;\n            //26\u4e2a\u5b57\u7b26\u5230n\u4e2a\u5b57\u7b26\u4e32\n            addEdge(i,26+j,G[j][i],0,j);//\u6b63\u5411\u8fb9\n            addEdge(26+j,i,0,0,-j);//\u53cd\u5411\u8fb9\n        }\n    }\n    for(int i=1;i<=n;i++){//n\u4e2a\u5b57\u7b26\u4e32\u5230\u6c47\u70b9\n        addEdge(26+i,T,num[i],0,0);//\u6b63\u5411\u8fb9\n        addEdge(T,26+i,0,0,0);//\u53cd\u5411\u8fb9\n    }\n    int flow,cost;\n    MCMF(S,T,flow,cost);\n    if (flow != len)//\u4e0d\u6ee1\u6d41\n        printf(\"-1\\n\");\n    else//\u6ee1\u6d41\n        printf(\"%d\\n\",cost);\n    return 0;\n}\n\n```",
        "postTime": 1568516943,
        "uid": 14301,
        "name": "\u9152\u7b19\u9752\u6800",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF237E \u3010Build String\u3011"
    }
]