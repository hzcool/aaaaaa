[
    {
        "content": "[\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/CF793G)\n# \u9898\u76ee\u5927\u610f\n\u7ed9\u51fa\u4e00\u4e2a $n\\times n$ \u7684\u77e9\u9635\uff0c\u8981\u6c42\u9009\u51fa\u4e00\u4e9b\u683c\u5b50\uff0c\u4f7f\u5f97\u6bcf\u884c\u6bcf\u5217\u90fd\u5b58\u5728\u683c\u5b50\u3002\u4f46\u662f\u6709 $q$ \u4e2a\u77e9\u9635\u4e0d\u80fd\u9009\u683c\u5b50\u3002\n\n$n,q\\le 10^4$\n# \u601d\u8def\n\u90e8\u5206\u601d\u8def\u6765\u81ea\u4e8e @Rainybunny \u3002\u5728\u6b64\u771f\u8bda\u5730stO stO Orz Orz \uff08\u5927\u558a\u201cwxk\u725b\u903c\uff01\u201d\uff09\n\n\u9996\u5148\u4e0d\u96be\u770b\u51fa\uff0c\u5982\u679c\u6ca1\u6709\u9650\u5236\u7684\u8bdd\uff0c\u5c31\u76f8\u5f53\u4e8e\u6bcf\u4e00\u884c\u548c\u6bcf\u4e00\u5217\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u6e90\u70b9\u5411\u6bcf\u4e00\u884c\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u6bcf\u4e00\u5217\u5411\u6c47\u70b9\u8fde\u4e00\u6761\u5bb9\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u7b54\u6848\u5c31\u662f\u6700\u5927\u6d41\u3002\uff08\u5e94\u8be5\u5f88\u663e\u7136\u5427\u3002\u3002\u3002\uff09\u7136\u540e\u5982\u679c\u6709\u4e9b\u77e9\u9635\u4e0d\u80fd\u9009\u7684\u8bdd\uff0c\u90a3\u5c31\u90a3\u4e9b\u884c\u548c\u90a3\u4e9b\u5217\u4e0d\u8fde\u8fb9\u5c31\u597d\u4e86\u3002\n\n\u7136\u540e\u6211\u4eec\u53d1\u73b0 $n^2$ \u7684\u8fb9\u6570\u4f60\u76f4\u63a5\u6700\u5927\u6d41\u80fd\u8fc7\u51fa\u9898\u4eba\u80af\u5b9a\u4f1a\u8bf7\u60a8\u559d\u5361\u5e03\u5947\u8bfa\u548c\u62bd\u70df\uff0c\u7136\u540e\u6211\u4eec\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u6211\u4eec\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\u505a\u3002\u4e8e\u662f\u95ee\u9898\u5c31\u6765\u4e86\uff0c\u6211\u4eec\u5982\u4f55\u5feb\u901f\u77e5\u9053\u8be5\u8fde\u7684\u533a\u95f4\u3002\n\n\uff08\u4ee5\u4e0b\u601d\u8def\u6765\u81ea\u4e8e @Rainybunny\uff09\n\n\u6211\u4eec\u5176\u5b9e\u53ef\u4ee5\u7528\u626b\u63cf\u7ebf\uff0c\u6211\u4eec\u628a\u4e00\u4e2a\u9650\u5236\u77e9\u9635\u5206\u6210\u4e24\u6761\u76f4\u7ebf\uff0c\u7136\u540e\u6309\u6a2a\u5750\u6807\u6392\u5e8f\uff0c\u7ef4\u62a4\u6bcf\u4e00\u5217\u7684\u8f6e\u5ed3\uff0c\u4e5f\u5c31\u662f\u6700\u9760\u53f3\u7684\u70b9\uff0c\u7136\u540e\u5bf9\u4e8e\u4e00\u4e2a\u77e9\u9635\u7684\u5de6\u8fb9\uff08\u5de6\u9762\u7684\u8fb9\uff09\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u770b\u51fa\u53ef\u4ee5\u5206\u51fa\u54ea\u4e9b\u5757\uff0c\u5982\u56fe\uff1a\n\n![](https://i.loli.net/2020/08/06/7pL5K1DvWnaxG9u.png)\n\n\uff08\u7406\u89e3\u5927\u610f\u5c31\u597d\u4e86\uff09\n\n\u81f3\u4e8e\u4e00\u4e2a\u77e9\u9635\u7684\u53f3\u8fb9\uff0c\u5b83\u7684\u5f71\u54cd\u80af\u5b9a\u5c31\u662f\u5f71\u54cd\u90a3\u4e9b\u5217\u7684\u8f6e\u5ed3\u3002\n\n\u867d\u7136\u65f6\u95f4\u590d\u6742\u5ea6\u662f $\\Theta(n^2)$ \u7684\uff0c\u4f46\u662f\u5e76\u4e0d\u80fd\u8dd1\u6ee1\uff0c\u800c\u4e14\u8d3c\u5feb\u3002\n\n\u6ce8\u610f\uff1a**\u5982\u679c\u60a8\u7684\u6570\u7ec4\u5f88\u5927\uff0c\u4e0d\u8981memset**\uff0c\u6211\u5c31\u56e0\u4e3a\u8fd9\u4e2a\u95ee\u9898\u8c03\u4e86\u4e00\u4e2a\u665a\u4e0a\u3002\u3002\u3002\n# $\\texttt{Code}$\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define Int register int\n#define INF 0x3f3f3f3f\n#define MAXM 10000005\n#define MAXN 50005\n\nint n,q,S,T,top = 1,dep[MAXN],to[MAXM],wei[MAXM],nxt[MAXM],cur[MAXN],head[MAXN];\nvoid Add_Edge (int u,int v,int w){\n\tto[++ top] = v,wei[top] = w,nxt[top] = head[u],head[u] = top;\n\tto[++ top] = u,wei[top] = 0,nxt[top] = head[v],head[v] = top;\n} \nbool BFS (){\n\tfor (Int i = 1;i <= T;++ i) cur[i] = head[i],dep[i] = INF;\n\tqueue <int> q;while (!q.empty()) q.pop ();dep[S] = 0,q.push (S);\n\twhile (!q.empty()){\n\t\tint u = q.front();q.pop ();\n\t\tfor (Int i = head[u];i;i = nxt[i]){\n\t\t\tint v = to[i],w = wei[i];\n\t\t\tif (dep[v] == INF && w){\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tq.push (v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T] != INF;\n}\nint dfs (int u,int lim){\n\tif (u == T) return lim;\n\tint used = 0;\n\tfor (Int i = cur[u];i && lim;i = nxt[i]){\n\t\tcur[u] = i;int v = to[i],w = wei[i];\n\t\tif (dep[v] == dep[u] + 1 && w){\n\t\t\tint del = dfs (v,min (lim,w));\n\t\t\tused += del,lim -= del,wei[i] -= del,wei[i ^ 1] += del;\n\t\t}\n\t}\n\tif (used == 0) dep[u] = INF;\n\treturn used;\n}\nint Dinic (){\n\tint res = 0;\n\twhile (BFS ()) res += dfs (S,INF);\n\treturn res;\n}\nint sizt;\nint id (int l,int r,int type){return type * sizt + ((l + r) | (l != r));}\nvoid build (int l,int r,int type){\n\tint rt = id (l,r,type);\n\tif (l == r){\n\t\tif (type == 0) Add_Edge (S,rt,1);\n\t\tif (type == 1) Add_Edge (rt,T,1);\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild (l,mid,type),build (mid + 1,r,type);\n\tif (type == 0) Add_Edge (id (l,mid,type),rt,INF),Add_Edge (id (mid + 1,r,type),rt,INF);\n\telse Add_Edge (rt,id (l,mid,type),INF),Add_Edge (rt,id (mid + 1,r,type),INF);\n}\n\n#define PII pair<int,int>\n#define MP make_pair\n\nvoid modify (int l,int r,int type,int tl,int tr,vector<PII> &s){\n\tif (l >= tl && r <= tr) return s.push_back (MP (id (l,r,type),r - l + 1));\n\tint mid = (l + r) >> 1;\n\tif (tl <= mid) modify (l,mid,type,tl,tr,s);\n\tif (tr > mid) modify (mid + 1,r,type,tl,tr,s); \n}\nvoid update (int tl,int tr,int ql,int qr){\n\tstatic vector <PII> A,B;A.clear(),B.clear();\n\tmodify (1,n,0,tl,tr,A),modify (1,n,1,ql,qr,B);\n\tfor (Int i = 0;i < A.size();++ i) for (Int j = 0;j < B.size();++ j) Add_Edge (A[i].first,B[j].first,A[i].second * B[j].second);   \n}\n\ntemplate <typename T> inline void read (T &t){t = 0;char c = getchar();int f = 1;while (c < '0' || c > '9'){if (c == '-') f = -f;c = getchar();}while (c >= '0' && c <= '9'){t = (t << 3) + (t << 1) + c - '0';c = getchar();} t *= f;}\ntemplate <typename T,typename ... Args> inline void read (T &t,Args&... args){read (t);read (args...);}\ntemplate <typename T> inline void write (T x){if (x < 0){x = -x;putchar ('-');}if (x > 9) write (x / 10);putchar (x % 10 + '0');}\n\nstruct node{\n\tint r1,r2,c;bool type;\n\tbool operator < (const node &p)const{return c != p.c ? c < p.c : type < p.type;}\n}mat[MAXN];\nint lef[MAXN];\nvoid Scan (){//\u8f93\u5165+\u626b\u63cf\u7ebf \n\tread (n,q);int tot = 0;\n\tfor (Int i = 1,r1,r2,c1,c2;i <= q;++ i) read (r1,c1,r2,c2),mat[++ tot] = node {r1,r2,c1,0},mat[++ tot] = node {r1,r2,c2,1};\n\tmat[++ tot] = node {1,n,n + 1,0},mat[++ tot] = node {1,n,n + 1,1};\n\tsort (mat + 1,mat + tot + 1);\n\tsizt = id (n,n,0);\n\tS = sizt * 2 + 3,T = S + 1;\n\tbuild (1,n,0),build (1,n,1);\n\tfor (Int i = 1;i <= tot;++ i){\n\t\tif (mat[i].type == 1) for (Int j = mat[i].r1;j <= mat[i].r2;++ j) lef[j] = mat[i].c;\n\t\telse{\n\t\t\tfor (Int j = mat[i].r1,lasw = mat[i].c - 1,lash = 0;j <= mat[i].r2 + 1;++ j){\n\t\t\t\tif (j == mat[i].r2 + 1 || lef[j] ^ lasw){\n\t\t\t\t\tif (lasw + 1 < mat[i].c) update (lash,j - 1,lasw + 1,mat[i].c - 1);\n\t\t\t\t\tlasw = lef[j],lash = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} \n}\n\nsigned main(){\n\tScan ();\n\twrite (Dinic ()),putchar ('\\n');\n\treturn 0;\n}\n```\n",
        "postTime": 1596721787,
        "uid": 124781,
        "name": "Walking_Dead",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF793G \u3010Oleg and chess\u3011"
    },
    {
        "content": "\u6bd4\u8f83\u5957\u8def\u7684\u9898\n\n\u5982\u679c\u6ca1\u6709\u77e9\u9635\u7684\u9650\u5236\u5c31\u662f\u6bcf\u884c\u6bcf\u5217\u4e92\u76f8\u8fde\u8fb9\u8dd1\u6700\u5927\u5339\u914d\uff0c\u7981\u6b62\u7684\u70b9\u4e0d\u80fd\u8fde\u8fb9\uff0c\u4f46\u662f $n^2$ \u7684\u8fb9\u6570\u4f1a T\n\n\u89c2\u5bdf\u8fde\u8fb9\u53ef\u4ee5\u53d1\u73b0\u7edd\u5927\u90e8\u5206\u8fb9\u90fd\u662f\u4e00\u4e2a\u70b9\u8fde\u5411\u67d0\u4e00\u4e2a\u533a\u95f4\uff0c\u90a3\u5c31\u8003\u8651\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\n\n\u5177\u4f53\u7684\u53ef\u4ee5\u7528\u626b\u63cf\u7ebf\u7684\u601d\u8def\uff0c\u628a\u77e9\u9635\u5de6\u8fb9\u754c\u7684 $(y_1,y_2)$ \u7f6e\u4e3a\u4e0d\u80fd\u9009\uff0c\u53f3\u8fb9\u754c\u518d\u53bb\u6389\u9650\u5236\uff0c\u65b0\u5efa\u70b9\u5411\u8fd9\u4e00\u5217\u5185\u8fde\u8fb9\u5373\u53ef\n\n\u6ce8\u610f\u9700\u8981\u5148\u52a0\u540e\u5220\n\n\u8fb9\u6570\u4e3a $n\\log n$ \u7ea7\u522b\uff0c\u7f51\u7edc\u6d41\u8dd1\u4e0d\u6ee1\u6240\u4ee5\u80fd\u8fc7\n\n```cpp\n#include <array>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\nconst int N   = 1e4 + 5;\nconst int INF = 0x7f7f7f7f;\nstruct Graph {\n    struct Node {\n        int v, w, nxt;\n    };\n    std::vector<int> head;\n    std::vector<Node> edge;\n    Graph() {\n    }\n    Graph(int n) : head(n + 1, -1){};\n    void resize(int n) {\n        head.assign(n + 1, -1);\n    }\n    void add(int u, int v, int w) {\n        if (head.size() < u) {\n            head.reserve(u * 2);\n        }\n        edge.emplace_back(Node{v, w, head[u]});\n        head[u] = edge.size() - 1;\n    }\n\n    void add_flow(int u, int v, int w) {\n        add(u, v, w);\n        add(v, u, 0);\n    }\n};\nnamespace NetworkFlow {\nstd::vector<int> level;\nbool bfs(int S, int T, const Graph &G) {\n    level.assign(G.head.size(), 0);\n    level[S] = 1;\n    std::queue<int> q;\n    q.push(S);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = G.head[now]; ~i; i = G.edge[i].nxt) {\n            int v = G.edge[i].v;\n            if (!level[v] && G.edge[i].w) {\n                level[v] = level[now] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[T];\n}\nstd::vector<int> cur;\nint dfs(int x, int T, int maxflow, Graph &G) {\n    if (x == T) {\n        return maxflow;\n    }\n    int res = 0;\n    for (int i = cur[x]; ~i && res < maxflow; i = G.edge[i].nxt) {\n        cur[x] = i;\n        int v  = G.edge[i].v;\n        if (G.edge[i].w && level[v] == level[x] + 1) {\n            int x = dfs(v, T, std::min(G.edge[i].w, maxflow - res), G);\n            if (x) {\n                G.edge[i].w -= x;\n                G.edge[i ^ 1].w += x;\n                res += x;\n            }\n        }\n    }\n    if (res < maxflow) {\n        level[x] = -1;\n    }\n    return res;\n}\nint MaxFlow(const int S, const int T, const Graph &G) {\n    cur.resize(G.head.size());\n    level.resize(G.head.size());\n    Graph tmpG = G;\n    int res    = 0;\n    while (bfs(S, T, tmpG)) {\n        cur.assign(tmpG.head.begin(), tmpG.head.end());\n        int x;\n        while (x = dfs(S, T, INF, tmpG)) {\n            res += x;\n        }\n    }\n    return res;\n}\n} // namespace NetworkFlow\nint S, T;\nGraph G;\narray<int, N * 20> id, col;\nint idcnt;\nnamespace SegmentTree {\nusing namespace NetworkFlow;\n#define ls(x) (x * 2)\n#define rs(x) (x * 2 + 1)\nvoid build(int rt, int l, int r) {\n    if (l == r) {\n        id[rt] = l;\n        G.add_flow(l, T, 1);\n        col[rt] = l;\n        return;\n    }\n    id[rt] = col[rt] = ++idcnt;\n    int mid          = (l + r) / 2;\n    build(ls(rt), l, mid);\n    build(rs(rt), mid + 1, r);\n    G.add_flow(col[rt], col[ls(rt)], INF);\n    G.add_flow(col[rt], col[rs(rt)], INF);\n}\nvoid update(int rt, int l, int r, int L, int R, int v) {\n    if (L <= l && r <= R) {\n        if (v) {\n            id[rt] = col[rt];\n        } else {\n            id[rt] = -1;\n        }\n        return;\n    }\n    int mid = (l + r) / 2;\n    id[rt]  = ++idcnt;\n    if (L <= mid) {\n        update(ls(rt), l, mid, L, R, v);\n    }\n    if (mid < R) {\n        update(rs(rt), mid + 1, r, L, R, v);\n    }\n    if (id[ls(rt)] != -1) {\n        G.add_flow(id[rt], id[ls(rt)], INF);\n    }\n    if (id[rs(rt)] != -1) {\n        G.add_flow(id[rt], id[rs(rt)], INF);\n    }\n}\n#undef ls\n#undef rs\n} // namespace SegmentTree\nint n, q;\nvector<pair<int, int>> st[N], ed[N];\nint main() {\n    cin >> n >> q;\n    G.resize(n * 80);\n    S = idcnt = n + 1;\n    T         = S + 1;\n    for (int i = 1; i <= q; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        st[x1].emplace_back(make_pair(y1, y2));\n        ed[x2 + 1].emplace_back(make_pair(y1, y2));\n    }\n    SegmentTree::build(1, 1, n);\n    for (int i = 1; i <= n; i++) {\n        for (auto v : ed[i]) {\n            SegmentTree::update(1, 1, n, v.first, v.second, 1);\n        }\n        for (auto v : st[i]) {\n            SegmentTree::update(1, 1, n, v.first, v.second, 0);\n        }\n        if (id[1] != -1)\n            G.add_flow(S, id[1], 1);\n    }\n    cout << NetworkFlow::MaxFlow(S, T, G);\n    return 0;\n}\n// Asusetic eru quionours\n```",
        "postTime": 1625025351,
        "uid": 46099,
        "name": "YCS_GG",
        "ccfLevel": 0,
        "title": "CF793G Oleg and chess"
    },
    {
        "content": "\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\u7f51\u7edc\u6d41\u597d\u9898\u3002\n\n\n------------\n\n\u9996\u5148\u6211\u4eec\u5f88\u5bb9\u6613\u60f3\u51fa\u4e00\u4e2a\u5957\u8def\u7684\u7f51\u7edc\u6d41\u505a\u6cd5\uff0c\u76f4\u63a5\u628a\u539f\u70b9\u5411\u6a2a\u8f74\u8fde\u8fb9\uff0c\u7eb5\u8f74\u5411\u6c47\u70b9\u8fde\u8fb9\uff0c\u80fd\u9009\u7684\u70b9\u5219\u6a2a\u8f74\u5411\u7eb5\u8f74\u8fde\u8fb9\u3002\n\n\u4f46\u662f\u8fd9\u6837\u7684\u56fe\u662f $n^2$ \u7ea7\u522b\u7684\u5f88\u660e\u663e\u4e0d\u80fd\u901a\u8fc7\u3002\n\n\n------------\n\n\u8003\u8651\u7528\u7ebf\u6bb5\u6811\u4f18\u5316\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u7528\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6bcf\u4e2a\u6a2a\u8f74\u80fd\u9009\u7684\u7eb5\u8f74\u72b6\u6001\uff0c\u5177\u4f53\u7684\u8003\u8651\u5bf9\u6bcf\u4e2a\u77e9\u5f62\u7528\u7c7b\u4f3c\u626b\u63cf\u7ebf\u7684\u65b9\u6cd5\uff0c\u5dee\u5206\u7ebf\u6bb5\uff0c\u4ece\u524d\u5f80\u540e\u5728\u7ebf\u6bb5\u6811\u4e0a\u52a0\u5373\u53ef\uff0c\u5982\u679c\u90a3\u4e2a\u5b50\u6811\u6ca1\u6709\u88ab\u6807\u8bb0\u5c31\u8fde\u4e00\u6761\u7531\u5176\u7956\u5148\u5411\u5176\u6d41\u91cf\u4e3a 1 \u7684\u8fde\u8fb9\u3002\n\n\u7136\u540e\u6211\u4eec\u53d1\u73b0\u6211\u4eec\u5176\u5b9e\u53ea\u9700\u8981\u7ef4\u62a4\u56fe\u4e0a\u4fe1\u606f\uff0c\u6839\u672c\u4e0d\u7528\u52a8\u6001\u5f00\u70b9\u7ebf\u6bb5\u6811\uff0c\u53ea\u8981\u5bf9\u56fe\u4e0a\u7684\u70b9\u52a8\u6001\u5f00\u70b9\u5c31\u53ef\u4ee5\u4e86\u3002\u8fd9\u4e2a\u7528\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\u73b0\u5728\u7ebf\u6bb5\u6811\u4e0a\u8fd9\u4e2a\u8282\u70b9\u5728\u56fe\u4e0a\u4ee3\u8868\u7684\u70b9\u5373\u53ef\u3002\n\n\n------------\n\n\n\u8fd9\u6837\u5efa\u56fe\u70b9\u6570\u548c\u8fb9\u6570\u90fd\u662f $n \\log n$ \u7ea7\u522b\u7684\uff0c\u5efa\u5b8c\u56fe\u540e\u8dd1\u6700\u5927\u6d41\u5373\u53ef\u3002\n\n\u7531\u4e8e\u7f51\u7edc\u6d41\u8dd1\u4e0d\u6ee1\uff0c\u6574\u4e2a\u7a0b\u5e8f\u8dd1\u7684\u98de\u5feb\uff0c\u6700\u6162\u7684\u70b9\u4e5f\u5728 1s \u5de6\u53f3\u3002\n\n\n------------\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n// Problem: CF793G Oleg and chess\n// Contest: Luogu\n// URL: https://www.luogu.com.cn/problem/CF793G\n// Memory Limit: 250 MB\n// Time Limit: 6500 ms\n// 2022-02-14 11:30:23\n// Author : louhao088\n// \n// Powered by CP Editor (https://cpeditor.org)\n\n#include<bits/stdc++.h>\nusing namespace std;\n//static char buf[1000000],*p1=buf,*p2=buf;\n//#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,1000000,stdin),p1==p2)?EOF:*p1++\n#define pi pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ls (rt<<1)\n#define rs (rt<<1|1)\n#define mid (l+r>>1)\n#define lowbit (x&-x)\nconst int maxn=1e5+5,M=34005,inf=1e9;\ninline int read()\n{\n\tchar ch=getchar();bool f=0;int x=0;\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);\n\tif(f==1)x=-x;return x;\n}\ninline void print(int x)\n{\n    static int a[55];int top=0;\n    if(x<0) putchar('-'),x=-x;\n    do{a[top++]=x%10,x/=10;}while(x);\n    while(top) putchar(a[--top]+48);\n}\nint n,m,s,t,tot,tag[maxn*4],id[maxn*4],lx,ly,rx,ry;\nstruct node{int l,r,x;};\nvector<node>a[maxn];\nstruct Dinic\n{\n\tint head[maxn*20],to[maxn*40],nex[maxn*40],w[maxn*40],cnt=1,dis[maxn*20],cur[maxn*20],vis[maxn*20],sum,maxflow;\n\tvoid add(int x,int y,int z){to[++cnt]=y,w[cnt]=z,nex[cnt]=head[x],head[x]=cnt;\n\tto[++cnt]=x,w[cnt]=0,nex[cnt]=head[y],head[y]=cnt;}\n\tvoid clear(){memset(head,0,sizeof head),memset(cur,0,sizeof cur),cnt=1,maxflow=0;memset(vis,0,sizeof vis);}\n\tbool bfs()\n\t{\n\t\tfor(int i=1;i<=tot;i++)dis[i]=-1;\n\t\tqueue<int>q;q.push(s);cur[s]=head[s];dis[s]=0;\t\t\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint x=q.front();q.pop();\n\t\t\tfor(int i=head[x];i;i=nex[i])\n\t\t\t\tif(dis[to[i]]==-1&&w[i])\n\t\t\t\t\tdis[to[i]]=dis[x]+1,q.push(to[i]),cur[to[i]]=head[to[i]];\n\t\t}\n\t\treturn dis[t]!=-1;\n\t}\n\tint dfs(int x,int flow)\n\t{\n\t\tif(x==t)return flow;\n\t\tint sum=0;\n\t\tfor(int i=cur[x];i&&flow;i=nex[i])\n\t\t{\n\t\t\tcur[x]=i;\n\t\t\tif(w[i]&&dis[to[i]]==dis[x]+1)\n\t\t\t{\n\t\t\t\tint k=dfs(to[i],min(flow,w[i]));\n\t\t\t\tflow-=k,sum+=k;w[i]-=k,w[i^1]+=k;\n\t\t\t}\n\t\t}return sum;\n\t}\n\tvoid work()\n\t{\n\t\twhile(bfs())maxflow+=dfs(s,inf);\n\t}\n}G;\nvoid pushup(int rt)\n{\n\tid[rt]=++tot;\n\tif(!tag[ls])G.add(id[rt],id[ls],inf);\n\tif(!tag[rs])G.add(id[rt],id[rs],inf);\n}\nvoid build(int rt,int l,int r)\n{\n\tif(l==r){id[rt]=l+n;return;}\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n\tpushup(rt);\n}\nvoid change(int rt,int l,int r,int L,int R,int x)\n{\n\tif(l>R||r<L)return;\n\tif(l>=L&&r<=R){tag[rt]+=x;return;}\n\tchange(ls,l,mid,L,R,x);change(rs,mid+1,r,L,R,x);\n\tpushup(rt);\n}\nsigned main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read();tot=2*n+2,s=2*n+1,t=2*n+2;G.cnt=1;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tlx=read(),ly=read();rx=read(),ry=read();\n\t\ta[lx].pb((node){ly,ry,1}),a[rx+1].pb((node){ly,ry,-1});\n\t}\n\tfor(int i=1;i<=n;i++)G.add(s,i,1),G.add(i+n,t,1);\n\tbuild(1,1,n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(auto j:a[i])\n\t\t\tchange(1,1,n,j.l,j.r,j.x);\n\t\tif(!tag[1])G.add(i,id[1],inf);\n\t}\n\tG.work();cout<<G.maxflow<<endl;\n \treturn 0;\n}\n\n\n```\n",
        "postTime": 1644814970,
        "uid": 343748,
        "name": "louhao088",
        "ccfLevel": 9,
        "title": "\u9898\u89e3CF793G Oleg and chess"
    },
    {
        "content": "\u6ce8\u610f\u5230\u6bcf\u884c\u6bcf\u5217\u6700\u591a\u53ea\u9009\u62e9\u4e00\u4e2a\u68cb\u5b50\u7684\u9650\u5236\uff0c\u90a3\u4e48\u5c31\u662f\u7ecf\u5178\u7684\u5c06\u884c\u4e0e\u5217\u8fdb\u884c\u4e8c\u5206\u56fe\u5339\u914d\u3002\u4f46\u5982\u679c\u76f4\u63a5 $O(n^2)$ \u66b4\u529b\u8fde\u8fb9\u65f6\u95f4\u590d\u6742\u5ea6\u5c31\u7206\u70b8\u4e86\uff0c\u8003\u8651\u4f18\u5316\u5efa\u56fe\u3002\n\n\u8fd9\u4e2a \u300c\u77e9\u5f62\u4e4b\u5185\u4e0d\u80fd\u653e\u7f6e\u68cb\u5b50\u300d \u7684\u9650\u5236\u96be\u4ee5\u5904\u7406\uff0c\u6211\u4eec\u5e0c\u671b\u628a\u5b83\u8f6c\u5316\u4e3a \u300c\u53ea\u6709\u77e9\u5f62\u4e4b\u5185\u624d\u80fd\u653e\u7f6e\u68cb\u5b50\u300d\u7684\u5f62\u5f0f\u3002\n\n\u6ce8\u610f\u5230\uff0c\u4e00\u4e2a\u4e0d\u5408\u6cd5\u77e9\u5f62\u81f3\u591a\u4f1a\u5c06\u5e73\u9762\u5206\u5272\u6210\u65b0\u7684\u56db\u4e2a\u5408\u6cd5\u77e9\u5f62\uff08\u4e0a\u9762\uff0c\u4e0b\u9762\uff0c\u5de6\u8fb9\uff0c\u53f3\u8fb9\u5404\u4e00\u4e2a\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u4fdd\u8bc1\u4e86\u5408\u6cd5\u77e9\u5f62\u7684\u6570\u91cf\u5728 $O(q)$ \u7ea7\u522b\u3002\n\n\u5229\u7528\u626b\u63cf\u7ebf\uff0c\u5bf9\u4e8e\u626b\u63cf\u7ebf\u4e2d $[x_1,x_2]$ \u7684\u8fde\u7eed\u6bb5\uff0c\u5b83\u4f1a\u4e0e\u5f53\u524d\u6240\u6709\u5408\u6cd5\u7684 $[y_1,y_2]$ \u533a\u95f4\u6784\u6210\u4e00\u4e2a\u77e9\u5f62\u3002\u7ebf\u6bb5\u6811\u652f\u6301\u533a\u95f4\u8986\u76d6\u548c\u533a\u95f4\u67e5\u8be2\uff0c\u6240\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u4f18\u5316\u5efa\u56fe\u3002\u5728\u505a\u5b8c\u533a\u95f4\u8986\u76d6\u64cd\u4f5c\u540e\uff0c\u66b4\u529b\u5728\u6574\u68f5\u7ebf\u6bb5\u6811\u4e0a\u9762\u627e\u5230\u6781\u957f\u7684\u5408\u6cd5\u533a\u95f4\u5373\u53ef\u3002\n\n\u7531\u4e8e\u5408\u6cd5\u533a\u95f4\u7684\u603b\u6570\u4e3a $O(q)$\uff0c\u6240\u4ee5\u8fd9\u79cd\u66b4\u529b\u64cd\u4f5c\u5355\u6b21\u5747\u644a $O(\\log n)$\uff0c\u8fb9\u6570\u5728 $O(n+q\\log n)$ \u7ea7\u522b\u3002\u7f51\u7edc\u6d41\u8dd1\u7684\u5f88\u5feb\u3002\n\n```cpp\n#include<bits/stdc++.h>\n#define For(i,a,b) for(int i=(a);i<=(b);++i)\n#define Rof(i,a,b) for(int i=(a);i>=(b);--i)\nusing namespace std;\nconst int Maxn=2e6,Maxk=5e5,Maxc=1e4,inf=1e9;\n\ninline int read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0' || ch>'9')\n    {\n        if(ch=='-') f=-1;\n        ch=getchar();\n    }\n    while(ch>='0' && ch<='9')\n    {\n        x=x*10+ch-'0';\n        ch=getchar();\n    }\n    return x*f;\n}\n\nstruct Node{int to,nxt,w;} Edge[Maxn*2+5];\nint tot=1,Head[Maxk+5],cur[Maxk+5];\ninline void Addedge(int x,int y,int z)\n{\n    Edge[++tot]=(Node){y,Head[x],z},Head[x]=tot;\n    Edge[++tot]=(Node){x,Head[y],0},Head[y]=tot;\n}\n\nint n,m,s,t,maxf,id[Maxc*4+5][2];\nint f[Maxc*4+5],tag[Maxc*4+5];\nint dis[Maxk+5],vis[Maxk+5];\nstruct Square{int x1,y1,x2,y2;} sk[Maxc+5];\nvector<int> v,w[Maxc+5];\nqueue<int> q;\n#define ls(x) (x<<1)\n#define rs(x) (x<<1|1)\n\ninline int bfs()\n{\n    For(i,1,t) cur[i]=Head[i],dis[i]=vis[i]=0;\n    q.push(s),vis[s]=1;\n    while(!q.empty())\n    {\n        int x=q.front(); q.pop();\n        for(int i=Head[x];i;i=Edge[i].nxt)\n        {\n            int y=Edge[i].to;\n            if(!vis[y] && Edge[i].w)\n                vis[y]=1,dis[y]=dis[x]+1,q.push(y);\n        }\n    }\n    return vis[t];\n}\ninline int dfs(int x,int flow)\n{\n    if(!flow || x==t) {maxf+=flow; return flow;}\n    int used=0,res=0;\n    for(int i=cur[x];i && used<flow;i=Edge[i].nxt)\n    {\n        int y=Edge[i].to; cur[x]=i;\n        if(Edge[i].w && dis[y]==dis[x]+1)\n            if(res=dfs(y,min(flow-used,Edge[i].w)))\n                used+=res,Edge[i].w-=res,Edge[i^1].w+=res;\n    }\n    return used;\n}\ninline void Build(int l,int r,int p)\n{\n    f[p]=r-l+1,tag[p]=0;\n    if(l==r) {id[p][0]=l,id[p][1]=n+l; return;}\n    id[p][0]=++s,id[p][1]=++s;\n    int mid=(l+r)>>1;\n    Build(l,mid,ls(p)),Build(mid+1,r,rs(p));\n    Addedge(id[ls(p)][0],id[p][0],inf),Addedge(id[rs(p)][0],id[p][0],inf);\n    Addedge(id[p][1],id[ls(p)][1],inf),Addedge(id[p][1],id[rs(p)][1],inf);\n}\ninline void Link(int nl,int nr,int l,int r,int p,int k)\n{\n    if(l<=nl && nr<=r) {Addedge(id[p][0],k,inf); return;}\n    int mid=(nl+nr)>>1;\n    if(l<=mid) Link(nl,mid,l,r,ls(p),k);\n    if(r>mid) Link(mid+1,nr,l,r,rs(p),k);\n}\ninline void push_up(int p) {f[p]=(tag[p]?0:f[ls(p)]+f[rs(p)]);}\ninline void Modify(int nl,int nr,int l,int r,int p,int k)\n{\n    if(l<=nl && nr<=r)\n    {\n        tag[p]+=k;\n        if(nl==nr) f[p]=(!tag[p]);\n        else push_up(p);\n        return;\n    }\n    int mid=(nl+nr)>>1;\n    if(l<=mid) Modify(nl,mid,l,r,ls(p),k);\n    if(r>mid) Modify(mid+1,nr,l,r,rs(p),k);\n    push_up(p);\n}\ninline void Find(int l,int r,int p,int k)\n{\n    if(tag[p] || !f[p]) return;\n    if(f[p]==r-l+1) {Addedge(k,id[p][1],inf); return;}\n    int mid=(l+r)>>1;\n    Find(l,mid,ls(p),k),Find(mid+1,r,rs(p),k);\n}\n\nint main()\n{\n    n=read(),m=read(),s=n*2;\n    Build(1,n,1);\n    For(i,1,m)\n    {\n        int x1=read(),y1=read(),x2=read(),y2=read();\n        v.push_back(x1),v.push_back(x2+1);\n        sk[i]=(Square){x1,y1,x2,y2};\n        w[x1].push_back(i),w[x2+1].push_back(-i);\n    }\n    v.push_back(1),v.push_back(n+1);\n    sort(v.begin(),v.end()),v.erase(unique(v.begin(),v.end()),v.end());\n    for(int i=0;i+1<v.size();++i)\n    {\n        int l=v[i],r=v[i+1]-1,k=++s;\n        Link(1,n,l,r,1,k);\n        for(auto j:w[l])\n        {\n            int y1=sk[abs(j)].y1,y2=sk[abs(j)].y2;\n            if(j>0) Modify(1,n,y1,y2,1,1);\n            else Modify(1,n,y1,y2,1,-1);\n        }\n        Find(1,n,1,k);\n    }\n    ++s,t=s+1;\n    For(i,1,n) Addedge(s,i,1),Addedge(n+i,t,1);\n    while(bfs()) dfs(s,inf);\n    printf(\"%d\\n\",maxf);\n    return 0;\n}\n```",
        "postTime": 1673747064,
        "uid": 148913,
        "name": "Graphcity",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF793G\u3010Oleg and chess\u3011"
    }
]