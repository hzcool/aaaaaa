[
    {
        "content": "\u53e3\u80e1\u4e94\u79d2\u949f\uff0c\u5b9e\u73b0\u4e09\u5c0f\u65f6\u3002\n\n\u5bf9\u4e8e\u4e00\u5bf9\u7ebf\u6bb5 $l_1,l_2$\uff0c\u82e5 $l_1$ \u80fd\u4e0b\u964d\u5230 $l_2$\uff0c\u663e\u7136\u4ece\u7aef\u70b9\u4e0b\u964d\u6216\u4e0b\u964d\u5230\u7aef\u70b9\u66f4\u4f18\u3002\n\n\u5bf9\u591a\u8fb9\u5f62\u505a\u68af\u5f62\u5256\u5206\uff0c\u5c06\u5176\u5206\u6210\u82e5\u5e72\u4e2a\u4e0a\u5e95\u548c\u4e0b\u5e95\u5e73\u884c\u4e8e $y$ \u8f74\u7684\u68af\u5f62\u3002\u7531\u4e8e\u5207\u5206\u7684\u8fb9\u90fd\u7ecf\u8fc7\u9876\u70b9\uff0c\u6240\u4ee5\u663e\u7136\u8fd9\u6837\u7684\u68af\u5f62\u53ea\u6709 $O(n)$ \u4e2a\u3002\u6839\u636e\u521a\u521a\u7684\u7ed3\u8bba\uff0c\u6240\u6709\u7684\u4e0b\u964d\u8fb9\u90fd\u4f1a\u8fde\u5728\u68af\u5f62\u7684\u4e0a\u5e95\u548c\u4e0b\u5e95\u5904\uff0c\u76f4\u63a5\u66b4\u529b\u8fde\u8fb9\u8dd1 Dijkstra \u5373\u53ef\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u5c06\u6240\u6709\u7ebf\u6bb5\u6309 $x$ \u5750\u6807\u6392\u5e8f\uff0c\u4ece\u5de6\u5f80\u53f3\u626b\u63cf\u7ebf\u5373\u53ef\u3002\n\n\u8bb2\u4e00\u4e0b\u5b9e\u73b0\u7ec6\u8282\uff1a\n\n1. \u5b58\u76f4\u7ebf\u7684\u65f6\u5019\u5b58\u4e24\u4e2a\u7aef\u70b9\u4f1a\u7b80\u5355\u4e00\u70b9\u3002\n2. \u4e3a\u4e86\u5224\u65ad\u6bcf\u6761\u8fb9\u80fd\u4e0d\u80fd\u5411\u4e0a/\u5411\u4e0b\u8fde\u8fb9\uff0c\u9700\u8981\u5224\u65ad\u76f4\u7ebf\u4e0a/\u4e0b\u662f\u5426\u5728\u591a\u8fb9\u5f62\u5185\u3002\u8fd9\u4e2a\u9700\u8981\u5728\u63d2\u5165\u7684\u65f6\u5019\u6309\u7167\u659c\u7387\u63d2\u5165\uff0c\u5e76\u4ece\u4e0a\u4e00\u6761\u76f4\u7ebf\u8f6c\u79fb\u3002\n\n\u5b9e\u73b0\u7684\u4e0d\u662f\u5f88\u7cbe\u7ec6\u3002\n\n```cpp\nusing db = double;\n\nconst int max_n = 100000, max_nd = max_n * 4, max_e = max_n * 12;\nconst int INF = 20001;\n\nstruct point\n{\n\tdb x, y;\n}\na[max_n];\n\nstruct line\n{\n\tpoint s, t;\n\tbool operator<(const line& rhs) const {\n\t\treturn (s.y - t.y) * (rhs.s.x - rhs.t.x) > (s.x - t.x) * (rhs.s.y - rhs.t.y);\n\t}\n}\nln[max_n + 1];\ntuple<int, int, int, int> e[max_n * 4];\n\nint hd[max_nd], des[max_e], nxt[max_e], e_cnt = 0;\nbool dr[max_n], vis[max_nd];\ndb val[max_e], dis[max_nd];\n\nvoid _add(int s, int t, db vl)\n{\n\tdes[e_cnt] = t, val[e_cnt] = vl;\n\tnxt[e_cnt] = hd[s];\n\thd[s] = e_cnt++;\n}\nvoid add(int s, int t, db vl)\n{\n\t_add(s, t, vl);\n\t_add(t, s, vl);\n}\n\nstruct node\n{\n\tdb vl; int id;\n\tbool operator<(const node& rhs) const {\n\t\treturn vl > rhs.vl;\n\t}\n};\n\n#define EV_ADD 0\n#define EV_REMOVE -1\n#define EV_QUERY 1\n#define EV_QUERY2 -2\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t\n\tint n;\n\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i].x >> a[i].y;\n\t\n\tauto sqr = [&](db x) {\n\t\treturn x * x;\n\t};\n\tauto getdis = [&](point& l, point& r) {\n\t\treturn sqrt(sqr(l.x - r.x) + sqr(l.y - r.y));\n\t};\n\t\n\tint ind = 0;\n\tfill(hd, hd + n, -1);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tint j = (i + 1) % n;\n\t\tadd(i, j, getdis(a[i], a[j]));\n\t\t\n\t\tif (a[i].x != a[j].x)\n\t\t{\n\t\t\tln[i] = line{ a[j], a[i] };\n\t\t\t\n\t\t\tint st = a[i].x, ed = a[j].x, sty = a[i].y, edy = a[j].y;\n\t\t\tif (st > ed)\n\t\t\t\tswap(st, ed), swap(sty, edy), ln[i] = line{ a[i], a[j] };\n\t\t\t\n\t\t\te[ind++] = make_tuple(st, EV_ADD, sty, i);\n\t\t\te[ind++] = make_tuple(ed, EV_REMOVE, edy, i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\te[ind++] = make_tuple(a[i].x, EV_QUERY, -1, i);\n\t\te[ind++] = make_tuple(a[i].x, EV_QUERY2, -1, i);\n\t}\n\t\n\tint cx = -1;\n\tauto cmpslp = [&](int lp, int rp) {\n\t\tauto& [ls, lt] = ln[lp];\n\t\tauto& [rs, rt] = ln[rp];\n\t\treturn (ls.y - lt.y) * (rs.x - rt.x) < (rs.y - rt.y) * (ls.x - lt.x);\n\t};\n\tauto cmp = [&](int lp, int rp) {\n\t\tauto& [ls, lt] = ln[lp];\n\t\tauto& [rs, rt] = ln[rp];\n\t\tauto lv = (cx * (ls.y - lt.y) + (ls.x * lt.y - ls.y * lt.x)) * (rs.x - rt.x);\n\t\tauto rv = (cx * (rs.y - rt.y) + (rs.x * rt.y - rs.y * rt.x)) * (ls.x - lt.x);\n\t\treturn lv != rv ? lv < rv : cmpslp(lp, rp);\n\t};\n\tset<int, decltype(cmp)> st{cmp};\n\t\n\tsort(e, e + ind, [&](auto& lhs, auto& rhs) {\n\t\treturn get<0>(lhs) != get<0>(rhs) ? get<0>(lhs) < get<0>(rhs) : (\n\t\t\tget<1>(lhs) != get<1>(rhs) ? get<1>(lhs) < get<1>(rhs) : (\n\t\t\t\tget<2>(lhs) != get<2>(rhs) ? get<2>(lhs) < get<2>(rhs) :\n\t\t\t\t\tcmpslp(get<3>(lhs), get<3>(rhs))\n\t\t\t)\n\t\t);\n\t});\n\t\n\tauto makel = [&](line& l) {\n\t\treturn make_pair(\n\t\t\tdb(l.s.y - l.t.y) / (l.s.x - l.t.x),\n\t\t\tdb(l.s.x * l.t.y - l.s.y * l.t.x) / (l.s.x - l.t.x)\n\t\t);\n\t};\n\t\n\tint ndc = n;\n\tfor (int _ = 0; _ < ind; _++)\n\t{\n\t\tauto [_cx, ty, _$, id] = e[_];\n\t\tcx = _cx;\n\t\t\n\t\tif (ty == EV_REMOVE)\n\t\t\tst.erase(id);\n\t\telse if (ty == EV_QUERY || ty == EV_QUERY2)\n\t\t{\n\t\t\tln[n] = line{ a[id], point{ a[id].x - 1, -INF } };\n\t\t\tif (auto pr = st.lower_bound(n); pr != st.end() && dr[*pr])\n\t\t\t{\n\t\t\t\tint p = *pr;\n\t\t\t\tauto [k, b] = makel(ln[p]);\n\t\t\t\tpoint c = { a[id].x, k * a[id].x + b };\n\t\t\t\t\n\t\t\t\thd[ndc] = -1;\n\t\t\t\tadd(p, ndc, getdis(a[p], c));\n\t\t\t\tadd((p + 1) % n, ndc, getdis(a[(p + 1) % n], c));\n\t\t\t\t_add(ndc++, id, c.y - a[id].y);\n\t\t\t}\n\t\t\t\n\t\t\tln[n] = line{ a[id], point{ a[id].x - 1, INF } };\n\t\t\tif (auto pr = st.lower_bound(n); pr != st.begin() && !dr[*(--pr)])\n\t\t\t{\n\t\t\t\tint p = *pr;\n\t\t\t\tauto [k, b] = makel(ln[p]);\n\t\t\t\tpoint c = { a[id].x, k * a[id].x + b };\n\t\t\t\t\n\t\t\t\thd[ndc] = -1;\n\t\t\t\tadd(p, ndc, getdis(a[p], c));\n\t\t\t\tadd((p + 1) % n, ndc, getdis(a[(p + 1) % n], c));\n\t\t\t\t_add(id, ndc++, a[id].y - c.y);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tauto it = st.insert(id).first;\n\t\t\tif (it != st.begin())\n\t\t\t\tdr[id] = !dr[*prev(it)];\n\t\t}\n\t}\n\t\n\tint s, t;\n\t\n\tcin >> s >> t, s--, t--;\n\t\n\tpriority_queue<node> pq;\n\tpq.push(node{ 0, s });\n\t\n\tfill(dis, dis + ndc, INF * n);\n\tdis[s] = 0;\n\t\n\twhile (!pq.empty())\n\t{\n\t\tauto [_, cur] = pq.top();\n\t\tpq.pop();\n\t\t\n\t\tif (!vis[cur])\n\t\t{\n\t\t\tvis[cur] = true;\n\t\t\tfor (int p = hd[cur], dst; p != -1; p = nxt[p])\n\t\t\t{\n\t\t\t\tdst = des[p];\n\t\t\t\tif (dis[dst] > dis[cur] + val[p])\n\t\t\t\t{\n\t\t\t\t\tdis[dst] = dis[cur] + val[p];\n\t\t\t\t\tpq.push(node{ dis[dst], dst });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << dis[t] << endl;\n\t\n\treturn 0;\n}\n```",
        "postTime": 1685680899,
        "uid": 119491,
        "name": "5ab_juruo",
        "ccfLevel": 0,
        "title": "\u3010\u9898\u89e3\u3011CF223D Spider"
    }
]