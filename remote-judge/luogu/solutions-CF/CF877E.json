[
    {
        "content": "\u4e00\u6b21\u8fc7\u9898\u6765\u5199\u9898\u89e3\u3002\n\n\u8fd9\u9898\u4f60\u53ea\u9700\u8981\u4f1a\uff1a\n\n- \u5efa\u56fe\n- \u5b58dfs\u5e8f\n- \u7ebf\u6bb5\u6811\u677f\u5b50\n\n\u7136\u540e\u53ea\u8981\u80fd\u60f3\u5230\uff0c\u5c31\u53ef\u4ee5\u8fc7\u9898\u4e86\u3002\n\n$$\n\\quad\n$$\n\n\u8fd9\u79cd\u4e1c\u897f\u76f4\u63a5\u5728\u6811\u4e0a\u4e0d\u597d\u5feb\u901f\u7ef4\u62a4\uff0c\u6240\u4ee5\u6211\u4eec\u60f3\uff0c\u6362\u505a\u5728\u5e8f\u5217\u4e0a\uff0c\u6211\u4eec\u5982\u4f55\u7ef4\u62a4\uff1f\n\n\u5728\u6570\u5217\u4e0a\u7528\u7ebf\u6bb5\u6811\u660e\u663e\u5f88\u597d\u7ef4\u62a4\u3002\u5047\u8bbe\u4e00\u6bb5\u533a\u95f4\u957f\u5ea6\u4e3a $size$\uff0c$1$ \u7684\u4e2a\u6570\u4e3a $val$\uff0c\u5219\u663e\u7136\u53cd\u8f6c\u4e4b\u540e $1$ \u7684\u4e2a\u6570\u53d8\u4e3a\u4e86 $size-val$\u3002\u56e0\u6b64\u6211\u4eec\u53ea\u9700\u7565\u6539\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\u7684\u5ef6\u8fdf\u6807\u8bb0\u4e0b\u4f20\u51fd\u6570\u5373\u53ef\uff1a\n\n```cpp\nvoid spread(ll p){\n\tif(t[p].tag){\n\t\tt[p<<1].val=t[p<<1].size-t[p<<1].val;\n\t\tt[p<<1|1].val=t[p<<1|1].size-t[p<<1|1].val;\n\t\tt[p<<1].tag^=1,t[p<<1|1].tag^=1;\n\t\tt[p].tag=0;\n\t}\n}\n```\n\n\u601d\u8003\u5230\u8fd9\u4e00\u6b65\u8fd9\u9898\u5c31\u505a\u5b8c\u4e86\u4e00\u534a\u3002\u53e6\u4e00\u534a\u662f\u4ec0\u4e48\uff1f\n\n$$\n\\quad\n$$\n\n\u6211\u4eec\u73b0\u5728\u8981\u5c06\u6811\u4e0a\u95ee\u9898\u8f6c\u5316\u5230\u5e8f\u5217\u4e0a\u6765\u3002\u6211\u4eec\u6709\u4e00\u4e2a\u795e\u5947\u7684\u65b9\u6cd5\uff1a\u641c\u7d22\u3002\n\n\u6211\u4eec\u628a\u8282\u70b9 $u$ \u7684dfs\u5e8f\u62c6\u6210\u524d\u540e\u4e24\u90e8\u5206\uff0c\u7b2c\u4e00\u90e8\u5206\u4e3a\u65f6\u95f4\u6233 $dfn$\uff0c\u540e\u4e00\u90e8\u5206\u4e3a\u56de\u6eaf\u65f6\u7684\u7f16\u53f7 $out$\u3002\u6211\u4eec\u7528 $cnt$ \u8bb0\u5f55\u7f16\u53f7\uff0c\u5176\u4e2d\u7b2c\u4e00\u90e8\u5206\u9700\u8981 $++$ $cnt$\uff0c\u7b2c\u4e8c\u90e8\u5206\u4e0d\u9700\u8981\u3002\u6211\u4eec\u518d\u589e\u52a0\u4e00\u4e2a $num$ \u6570\u7ec4\u7528\u4e8e\u8bb0\u5f55\u65f6\u95f4\u6233\u4e3a $cnt$ \u7684\u8282\u70b9\u3002\n\n```cpp\nvoid dfs(ll u,ll fa){\n\tdfn[u]=++cnt,num[cnt]=u;\n\tfor(ll i=head[u];i;i=edge[i].nxt){\n\t\tll v=edge[i].to;\n\t\tif(v==fa)continue;\n\t\tdfs(v,u);\n\t}\n\tout[u]=cnt;\n}\n```\n\n\u8fd9\u6837\u641c\u7d22\u8fc7\u540e\uff0c\u6240\u5f97\u7684 $num$ \u6570\u7ec4\u7528\u4e8e\u5728\u5efa\u6811\u65f6\u5efa\u7acb\u8d77\u6811\u4e0a\u8282\u70b9\u548c\u5e8f\u5217\u5143\u7d20\u7684\u5bf9\u5e94\u4f4d\u7f6e\uff0c$dfn$ \u6570\u7ec4\u548c $out$ \u6570\u7ec4\u7528\u4e8e\u8bb0\u5f55\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u5728\u5e8f\u5217\u4e0a\u7684\u5bf9\u5e94\u5de6\u53f3\u7aef\u70b9\u3002\n\n\u8fd9\u6837\u6211\u4eec\u6210\u529f\u5c06\u6811\u4e0a\u95ee\u9898\u653e\u5230\u4e86\u5e8f\u5217\u4e0a\u6765\u3002\u6211\u4eec\u5b8c\u6210\u4e86\u8fd9\u9898\u7684\u53e6\u4e00\u534a\uff01\n\n$$\n\\quad\n$$\n\n\u5269\u4e0b\u7684\u4ee3\u7801\u5c31\u5f88\u597d\u7801\u51fa\u6765\u4e86\uff0c\u548c\u7ebf\u6bb5\u6811\u533a\u95f4\u4fee\u6539\u533a\u95f4\u67e5\u548c\u677f\u5b50\u5dee\u4e0d\u4e86\u591a\u5c11\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\ninline ll read()\n{\n\tll x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nconst int SIZE=200005;\nstruct Tree{ll l,r,val,size,tag;}t[SIZE*4];\nstruct Edge{ll to,nxt;}edge[SIZE];\nchar opt[15];\nll head[SIZE],tot,dfn[SIZE],out[SIZE],cnt,num[SIZE];\ninline void add(ll x,ll y)\n{\n\tedge[++tot].to=y,edge[tot].nxt=head[x],head[x]=tot;\n}\nll n,m,a[SIZE];\n\n//\u5bf9\u6811\u641c\u7d22 \nvoid dfs(ll u,ll fa)\n{\n\tdfn[u]=++cnt,num[cnt]=u;\n\tfor(ll i=head[u];i;i=edge[i].nxt)\n\t{\n\t\tll v=edge[i].to;\n\t\tif(v==fa)continue;\n\t\tdfs(v,u);\n\t}\n\tout[u]=cnt;\n}\n\n//\u4e0b\u4f20\u5ef6\u8fdf\u6807\u8bb0 \nvoid spread(ll p)\n{\n\tif(t[p].tag)\n\t{\n\t\tt[p<<1].val=t[p<<1].size-t[p<<1].val;\n\t\tt[p<<1|1].val=t[p<<1|1].size-t[p<<1|1].val;\n\t\tt[p<<1].tag^=1,t[p<<1|1].tag^=1;\n\t\tt[p].tag=0;\n\t}\n}\n\n//\u533a\u95f4\u4fee\uff0c\u53ea\u8981\u6709\u9012\u5f52\u5c31\u4e0b\u4f20\u6807\u8bb0 \nvoid change(ll p,ll l,ll r)\n{\n\tif(l<=t[p].l&&r>=t[p].r)\n\t{\n\t\tt[p].val=t[p].size-t[p].val,t[p].tag^=1;\n\t\treturn;\n\t}\n\tspread(p);\n\tint mid=t[p].l+t[p].r>>1;\n\tif(l<=mid)change(p<<1,l,r);\n\tif(r>mid)change(p<<1|1,l,r);\n\tt[p].val=t[p<<1].val+t[p<<1|1].val;\n\tt[p].size=t[p<<1].size+t[p<<1|1].size;\n}\n\n//\u533a\u95f4\u67e5\uff0c\u53ea\u8981\u6709\u9012\u5f52\u5c31\u4e0b\u4f20\u6807\u8bb0 \nll ask(ll p,ll l,ll r)\n{\n\tif(l<=t[p].l&&r>=t[p].r)\n\t\treturn t[p].val;\n\tspread(p);\n\tll mid=t[p].l+t[p].r>>1,ans=0;\n\tif(l<=mid)ans+=ask(p<<1,l,r);\n\tif(r>mid)ans+=ask(p<<1|1,l,r);\n\treturn ans;\n}\n\n//\u5efa\u6811\uff0c\u6ce8\u610fnum\u7684\u6620\u5c04 \nvoid build(ll p,ll l,ll r)\n{\n\tt[p].l=l,t[p].r=r;\n\tif(l==r)\n\t{\n\t\tt[p].val=a[num[l]],t[p].size=1;\n\t\treturn;\n\t}\n\tll mid=l+r>>1;\n\tbuild(p<<1,l,mid);\n\tbuild(p<<1|1,mid+1,r);\n\tt[p].val=t[p<<1].val+t[p<<1|1].val;\n\tt[p].size=t[p<<1].size+t[p<<1|1].size;\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint x=read();\n\t\tadd(x,i+1);\n\t}\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tdfs(1,1),build(1,1,n),m=read();\n\twhile(m--)\n\t{\n\t\tscanf(\"%s\",&opt);ll x;scanf(\"%lld\",&x);\n\t\tif(opt[0]=='g')\n\t\t\tprintf(\"%lld\\n\",ask(1,dfn[x],out[x]));\n\t\telse change(1,dfn[x],out[x]);\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1613463678,
        "uid": 246979,
        "name": "SalomeJLQ",
        "ccfLevel": 5,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "## \u524d\u8a00\n\n\u4e00\u9053\u5f88\u7b80\u5355\u7684\u9898\uff0c\u5f53\u4f60\u5237\u8fc7\u5176\u4ed6\u7684\u6811\u5256\u9898\uff0c\u4f60\u5c31\u4f1a\u53d1\u73b0\u8fd9\u9053\u9898\u662f\u5982\u6b64\u7684 So,Easy\"\n\n## \u9898\u610f\n\n\u4e24\u79cd\u64cd\u4f5c\uff0c\u4e00\u4e2a\u662f\u6c42\u5b50\u6811\u4e2d $1$ \u7684\u4e2a\u6570\uff0c\u53e6\u4e00\u79cd\u662f\u533a\u95f4\u53d6\u53cd\uff0c\u5373 $0$\u53d8\u4e3a$1$\n\n$1$\u53d8\u4e3a$0$\u3002\uff08~~\u5b66\u8fc7\u6811\u5256\u7684\u4e00\u773c\u5c31\u5207\u4e86\u96fe~~\uff09\n\n## \u524d\u7f6e\u829d\u58eb\n\n#### dfn\u5e8f \n\n \u5b9a\u4e49\uff1a \u8282\u70b9\u88ab\u904d\u5386\u7684\u987a\u5e8f\n \n \u6027\u8d28\uff1a 1. \u5b50\u6811\u4e2ddfn\u5e8f\u662f\u8fde\u7eed\u7684\u3002\n \n          2. \u4e00\u6761\u91cd\u94fe\u4e0adfn\u5e8f\u662f\u8fde\u7eed\u7684\uff08~~\u6ca1\u5b66\u8fc7\u6811\u5256\u7684\u8bf7\u81ea\u884c\u8df3\u8fc7~~\uff09\n## \u5206\u6790\n\n\u9996\u5148\uff0c\u6211\u4eec\u53ef\u4ee5\u904d\u5386\u6574\u68f5\u6811\uff0c\u6c42\u51fa\u6bcf\u4e2a\u70b9\u7684dfn\u5e8f\uff0c\u5728\u4ee5dfn\u5e8f\u5efa\u6811\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e00\uff0c\u6211\u4eec\u53ef\u4ee5\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f4\u548c\uff08\u7531\u6027\u8d281\u53ef\u5f97\u5b50\u6811\u7684dfn\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\n\n\u6240\u4ee5\u533a\u95f4\u4e5f\u662f\u8fde\u7eed\u7684\uff09\u3002\n\n\u5bf9\u4e8e\u64cd\u4f5c\u4e8c\uff0c\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u5e8f\u5217\u8fde\u7eed\u53d6\u4e24\u6b21\u53cd\uff0c\u5c31\u4f1a\u53d8\u4e3a\u539f\u6765\u7684\u5e8f\u5217\u3002\u6240\u4ee5\u6211\u4eec\n\n\u7ef4\u62a4\u4e00\u4e2atag\u6807\u8bb0\uff0c1\u8868\u793a\u672a\u53d6\u53cd\uff0c-1\u8868\u793a\u53d6\u53cd\u4e00\u6b21\u3002\u4e0b\u653e\u65f6\uff0c\u5b69\u5b50\u8282\u70b9\u7684tag\u76f4\u63a5\n\n\u4e58\u4ee5-1\u5c31\u884c\u4e86\uff0c\u533a\u95f4\u548c\u53d8\u4e3a\u533a\u95f4\u957f\u5ea6\u51cf\u53bb\u539f\u6765\u7684\u533a\u95f4\u548c\u3002\n\n## \u51e0\u4e2a\u8981\u6ce8\u610f\u7684\u70b9\n\n1. \u6807\u8bb0\u8981\u521d\u59cb\u5316\u4e3a1\uff0c\u800c\u4e0d\u662f0\n\n1. \u4e0b\u653e\u6807\u8bb0\u65f6\uff0c\u5b69\u5b50\u8282\u70b9\u7684\u6807\u8bb0\u8981\u4e58\u4ee5-1\uff0c\u800c\u4e0d\u662f\u53d8\u4e3a-1.\uff08\u56e0\u4e3a\u539f\u6765\u5b69\u5b50\u53ef\u80fd\n\n   \u8981\u53d6\u53cd\uff0c\u73b0\u5728\u5728\u53d6\u53cd\u4e00\u6b21\u7b49\u540c\u4e8e\u6ca1\u6709\u53d6\u53cd\uff09\u3002\n\n1. \u4e0b\u653e\u65f6\u533a\u95f4\u548c\u53d8\u4e3a\u533a\u95f4\u957f\u5ea6\u51cf\u53bb\u539f\u6765\u7684\u533a\u95f4\u548c\n\n~~\u597d\u50cf\u90fd\u662f\u6253\u6807\u8bb0\u51fa\u73b0\u7684\u95ee\u9898\uff08\u96fe\uff09~~\n\n## \u4ee3\u7801\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N = 2e5+10;\nchar opt[10];\nint n,v,t,x,tot,num;\nint dfn[N],w[N],a[N],size[N],head[N];\ninline int read()\n{\n\tint s = 0, w = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9'){if(ch == '-') w = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9'){s = s * 10+ch -'0'; ch = getchar();}\n\treturn s * w;\n}\nstruct node{int to,net;}e[N<<1];\nvoid add(int x,int y)\n{\n\te[++tot].to = y;\n\te[tot].net = head[x];\n\thead[x] = tot;\n}\nvoid dfs(int x,int fa)//dfs\u6c42dfs\u5e8f\n{\n\tsize[x] = 1; dfn[x] = ++num; w[dfn[x]] = a[x];\n\tfor(int i = head[x]; i; i = e[i].net)\n\t{\n        int to = e[i].to;\n        if(to == fa) continue;\n        dfs(to,x);\n        size[x] += size[to];\n\t}\n}\nstruct Tree\n{\n\tstruct node{\n\t\tint lc,rc;\n\t\tint tag,sum;\n\t}tr[N<<2];\n\t#define l(o) tr[o].lc\n\t#define r(o) tr[o].rc\n\t#define tag(o) tr[o].tag\n\t#define sum(o) tr[o].sum\n\tvoid up(int o)\n\t{\n\t\tsum(o) = sum(o<<1) + sum(o<<1|1);\n\t}\n\tvoid cover(int o)\n\t{\n\t\ttag(o) *= -1;\n\t\tsum(o) = (r(o) - l(o) + 1) - sum(o);\n\t}\n\tvoid down(int o)//\u4e0b\u653e\u6807\u8bb0\n\t{\n\t\tif(tag(o) == -1)\n\t\t{\n\t\t\tcover(o<<1); cover(o<<1|1);\n\t\t\ttag(o) = 1;\n\t\t}\n\t}\n\tvoid build(int o,int L,int R)\n\t{\n\t\tl(o) = L, r(o) = R; tag(o) = 1;//tag\u521d\u59cb\u5316\u4e00\u5b9a\u8981\u4e3a1\n\t\tif(L == R)\n\t\t{\n\t\t\tsum(o) = w[L]; return;\n\t\t}\n\t\tint mid = (L + R)>>1;\n\t\tbuild(o<<1,L,mid);\n\t\tbuild(o<<1|1,mid+1,R);\n\t\tup(o);\n\t}\n\tvoid chenge(int o,int L,int R)//\u533a\u95f4\u53d6\u53cd\n\t{\n        if(L <= l(o) && R >= r(o))\n        {\n        \tcover(o); return;\n        }\n        down(o);\n        int mid = (l(o) + r(o))>>1;\n        if(L <= mid) chenge(o<<1,L,R);\n        if(R > mid) chenge(o<<1|1,L,R);\n        up(o);\n\t}\n\tint ask(int o,int L,int R)//\u533a\u95f4\u548c\n\t{\n\t\tint ans = 0;\n\t\tif(L <= l(o) && R >= r(o)) {return sum(o);}\n\t\tdown(o);\n\t\tint mid = (l(o) + r(o))>>1;\n\t\tif(L <= mid) ans += ask(o<<1,L,R);\n\t\tif(R > mid) ans += ask(o<<1|1,L,R);\n\t\treturn ans;\n\t}\n}tree;\nint main()\n{\n   n = read();\n   for(int i = 2; i <= n; i++)//\u4e60\u60ef\u4e86\u4ece1\u5f00\u59cb\u7f16\u53f7\n   {\n   \t   v = read();\n   \t   add(v,i); add(i,v);\n   }\n   for(int i = 1; i <= n; i++) a[i] = read();\n   dfs(1,1); tree.build(1,1,n);\n   t = read();\n   while(t--)\n   {\n   \t   scanf(\"%s\",opt+1);\n   \t   x = read();\n   \t   if(opt[1] == 'g')//\u8be2\u95ee\u5b50\u68111\u7684\u4e2a\u6570\n   \t   {\n   \t   \t   printf(\"%d\\n\",tree.ask(1,dfn[x],dfn[x] + size[x] - 1));\n   \t   }\n   \t   if(opt[1] == 'p')//\u533a\u95f4\u53d6\u53cd\n   \t   {\n   \t   \t   tree.chenge(1,dfn[x],dfn[x] + size[x] - 1);\n   \t   }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1596186744,
        "uid": 248896,
        "name": "genshy",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "## \u4e00\u9053\u677f\u5b50\u9898\n\u5f53\u4f60$\\color{green}{AC}$\u4e86[Apple Tree](http://poj.org/problem?id=3321)\uff0c[\u3010\u6a21\u677f\u3011\u7ebf\u6bb5\u6811](https://www.luogu.com.cn/problem/P3372)\uff0c\u4f60\u4f1a\u53d1\u73b0\uff0c\u8fd9\u5c31\u662f\u4e00\u4e2a\u4e00\u773c\u9898\n### DFS\u5e8f\n\u6309\u7167\u6211\u4eec$\\texttt{dfs}$\u7684\u987a\u5e8f\u628a\u6811\u4e0a\u7684\u70b9\u6807\u53f7\uff0c\u6839\u636e\u6211\u4eec\u5bf9dfs\u7684\u4e86\u89e3\uff0c\u6211\u4eec\u77e5\u9053\uff0cdfs\u5728\u641c\u5b8c\u4e00\u9897\u6811\u524d\uff0c\u662f\u4e0d\u4f1a\u5f80\u4e0a\u8df3\u7684\uff0c\u56e0\u6b64\u6211\u4eec\u77e5\u9053\n\n**$x$\u7684\u5b50\u6811\u4e0a\u7684dfs\u5e8f\u662f\u8fde\u7eed\u7684\uff0c\u4e14$x$\u7684dfs\u5e8f\u6700\u5c0f**\n\n\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u628a\u5b50\u6811\u64cd\u4f5c\u6539\u53d8\u4e3a\u5e8f\u5217\u64cd\u4f5c\uff0c\u8bbe$dfn[x]$\u8868\u793ax\u7684dfs\u5e8f\uff0c$size[x]$\u8868\u793ax\u7684\u5b50\u6811\u7684\u5927\u5c0f\uff0c\u90a3\u4e48\u5bf9x\u7684\u5b50\u6811\u64cd\u4f5c\uff0c\u5c31\u7b49\u4ef7\u4e8e\u5bf9$dfn[x]\\to dfn[x]+size[x]-1$\u7684\u64cd\u4f5c\n\n\u4e8e\u662f\uff0c\u6211\u4eec\u6210\u529f\u7684\u628a\u6811\u4e0a\u95ee\u9898\u8f6c\u79fb\u5230\u4e86\u5e8f\u5217\u4e0a\n\n\n### \u7ebf\u6bb5\u6811\n\u6bd4\u8f83\u7b80\u5355\u7684\u7ebf\u6bb5\u6811,\u7a0d\u5fae\u9b54\u6539\u4e00\u4e0b\u677f\u5b50\u5c31ok\u4e86\n\uff08\u5177\u4f53\u770b\u4ee3\u7801\u5427\uff09\n\n```cpp\n#include<bits/stdc++.h>\nnamespace in{\n\tchar buf[1<<21],*p1=buf,*p2=buf;\n\tinline int getc(){\n\t    return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;\n\t}\n\ttemplate <typename T>inline void read(T& t){\n\t    t=0;int f=0;char ch=getc();\n\t    while (!isdigit(ch)){\n\t        if(ch=='-')f = 1;\n\t        ch=getc();\n\t    }\n\t    while(isdigit(ch)){\n   \t    \tt=t*10+ch-48;\n   \t    \tch = getc();\n   \t\t}\n\t\tif(f)t=-t;\n\t}\n\ttemplate <typename T,typename... Args> inline void read(T& t, Args&... args){\n\t    read(t);read(args...);\n\t}\n}\nnamespace out{\n\tchar buffer[1<<21];\n\tint p1=-1;\n\tconst int p2 = (1<<21)-1;\n\tinline void flush() {\n\t\tfwrite(buffer,1,p1+1,stdout),\n\t\tp1=-1;\n\t}\n\tinline void putc(const char &x) {\n\t\tif(p1==p2)flush();\n\t\tbuffer[++p1]=x;\n\t}\n\ttemplate <typename T>void write(T x) {\n\t\tstatic char buf[15];\n\t\tstatic int len=-1;\n\t\tif(x>=0){\n\t\t\tdo{\n    \t\t\tbuf[++len]=x%10+48,x/=10;\n    \t\t}while (x);\n\t\t}else{\n    \t\tputc('-');\n\t\t\tdo {\n    \t\t\tbuf[++len]=-(x%10)+48,x/=10;\n\t\t\t}while(x);\n\t\t}\n\t\twhile (len>=0)\n\t\t\tputc(buf[len]),--len;\n\t}\n}\nusing namespace std;\nconst int maxn=200000+10;\nstruct TREE{\n\tstruct node{\n\t\tint l,r;\n\t\tint tag,val;\n\t}tree[maxn<<2];\n\t#define l(x) tree[(x)].l\n\t#define r(x) tree[(x)].r\n\t#define mid(x) (tree[(x)].l+tree[(x)].r>>1)\n\t#define tag(x) tree[(x)].tag\n\t#define val(x) tree[(x)].val\n\t#define lson x<<1\n\t#define rson x<<1|1\n\tint a[maxn];\n\tvoid pushdown(int x){\n\t\tif(tag(x)){\n\t\t\ttag(lson)^=1,val(lson)=r(lson)-l(lson)+1-val(lson);\n\t\t\ttag(rson)^=1,val(rson)=r(rson)-l(rson)+1-val(rson);\n\t\t\ttag(x)=0;\n\t\t}\n\t} \n\tvoid pushup(int x){\n\t\tval(x)=val(lson)+val(rson);\n\t}\n\tvoid build(int x,int l,int r){\n\t\tl(x)=l,r(x)=r;tag(x)=0;\n\t\tif(l==r){val(x)=a[l];return;}\n\t\tbuild(lson,l(x),mid(x));\n\t\tbuild(rson,mid(x)+1,r(x));\n\t\tpushup(x);\n\t}\n\tvoid change(int x,int l,int r){//\u5c06[l,r]\u53d6\u53cd \n\t\tif(r<l(x)||r(x)<l)return;\n\t\tif(l<=l(x)&&r(x)<=r){\n\t\t\ttag(x)^=1;\n\t\t\tval(x)=r(x)-l(x)+1-val(x);\n\t\t\treturn;\n\t\t}\n\t\tpushdown(x);\n\t\tchange(lson,l,r);\n\t\tchange(rson,l,r);\n\t\tpushup(x);\n\t}\n\tint query(int x,int l,int r){\n\t\tif(r<l(x)||r(x)<l)return 0;\n\t\tif(l<=l(x)&&r(x)<=r)return val(x);\n\t\tpushdown(x);\n\t\treturn query(lson,l,r)+query(rson,l,r); \n\t}\n}T; \nint n,m,a;\nstruct Graph{\n\tstruct node{\n\t\tint v,nxt;\n\t}e[maxn<<1];\n\tint cnt,head[maxn];\n\tvoid add(int x,int y){e[++cnt]=(node){y,head[x]};head[x]=cnt;}\n\tint tot,dfn[maxn],size[maxn];\n\tvoid dfs(int x,int fa){\n\t\tdfn[x]=++tot,size[x]=1;\n\t\tfor(int i=head[x];i;i=e[i].nxt)\n\t\t\tif(e[i].v!=fa)dfs(e[i].v,x),size[x]+=size[e[i].v];\n\t}\n}G;\nchar get(){\n\tchar c=in::getc();\n\twhile(!isalpha(c))c=in::getc();\n\treturn c;\n}\nsigned main(){\n\t//freopen(\"in.cpp\",\"r\",stdin);\n\tin::read(n);\n\tfor(int i=1;i<n;i++)\n\t\tin::read(a),G.add(a,i+1);\n\tG.dfs(1,0);\n\tfor(int i=1;i<=n;i++)\n\t\tin::read(a),T.a[G.dfn[i]]=a;\n\tT.build(1,1,n);\n\tin::read(m);\n\twhile(m--){\n\t\tchar opt=get();\n\t\tint x;in::read(x);\n\t\tif(opt=='g'){\n\t\t\tout::write(T.query(1,G.dfn[x],G.dfn[x]+G.size[x]-1));\n\t\t\tout::putc('\\n');\t\n\t\t}\n\t\telse{\n\t\t\tT.change(1,G.dfn[x],G.dfn[x]+G.size[x]-1);\n\t\t}\n\t\t//for(int i=1;i<=n;i++)\n\t\t//\tout::write(T.query(1,i,i)),out::putc(' ');\n\t\t//out::putc('\\n');\n\t}\n\tout::flush();\n\treturn 0;\n}\n```",
        "postTime": 1593753032,
        "uid": 174304,
        "name": "jun\u5934\u5409\u5409",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "$ \\text {Solution} $\n\n$ \\text{\\small \u524d\u7f6e\u829d\u58eb\u2014\u2014\u8f7b\u91cd\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811} $\n\n____________\n\n\u8fd9\u9898\u4e5f\u7b97\u662f\u4e00\u9053\u5f88\u7ecf\u5178\u7684\u9898\u76ee\u4e86\uff0c\u5c31\u662f\u51e0\u4e2a\u6811\u94fe\u5256\u5206\u7684\u57fa\u672c\u5904\u7406\u65b9\u6cd5\uff0c\u5bf9\u6811\u94fe\u5256\u5206\u5404\u79cd\u64cd\u4f5c\u719f\u6089\u7684\u4eba\u5199\u8fd9\u4e2a\u9898\u5c31\u5341\u5206\u8f7b\u677e\u3002\u6211\u770b\u61c2\u8fd9\u4e2a\u9898\u76ee\u4ee5\u540e\uff0c\u53d1\u73b0\u8fd9\u4e2a\u9898\u6bd4\u8f83\u597d\u505a\uff0c\u4e8e\u662f\u5c31\u6765\u6c35\u9898\u89e3+\u6c35\u7d2b\u9898\u4e86\u3002\n\n\u672c\u9898\u7684\u64cd\u4f5c\u5f88\u660e\u786e\uff1a\n\n> 1. \u5bf9\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u8fdb\u884c\u5f02\u6216\u8fd0\u7b97\n\n> 2. \u6c42\u4e00\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u4e2d\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u548c\n\n\u770b\u5230\u5bf9\u5b50\u6811\u8fdb\u884c\u4fee\u6539\u4e0e\u67e5\u8be2\uff0c\u660e\u663e\u5c31\u662f\u6811\u94fe\u5256\u5206\u7684\u57fa\u672c\u64cd\u4f5c\u3002\u90a3\u4e48\uff0c\u5c06\u8fd9\u9897\u6811\u4e0a\u7684 $\\text{dfs}$ \u5e8f\u63d0\u51fa\u6765\u6254\u8fdb\u7ebf\u6bb5\u6811\u4e4b\u540e\uff0c\u7ebf\u6bb5\u6811\u4e2d\u7684\u533a\u95f4\u548c\u67e5\u8be2+\u533a\u95f4\u5f02\u6216\u4e5f\u662f\u5f88\u7ecf\u5178\u7684\u9898\u76ee\u3002\u6bd4\u8f83\u503c\u5f97\u4e00\u8bb2\u7684\u5730\u65b9\u5c31\u662f $\\text{pushdown}$ \u7684\u64cd\u4f5c\u4e86\u3002\n\n```cpp\nvoid pushdown(int ID){\n\tif(tree[ID].lazy){\n\t\ttree[ID].lazy^=1;\n\t\ttree[ID<<1].lazy^=1;\n\t\ttree[ID<<1|1].lazy^=1;\n\t\ttree[ID<<1].val=tree[ID<<1].len-tree[ID<<1].val;\n\t\ttree[ID<<1|1].val=tree[ID<<1|1].len-tree[ID<<1|1].val;\n\t}\n}\n```\n\n\u5bf9\u7ebf\u6bb5\u6811\u7684\u4e00\u4e2a\u533a\u95f4\u8fdb\u884c\u5f02\u6216\u64cd\u4f5c\u4ee5\u540e\uff0c\u56e0\u4e3a\u539f\u672c\u90a3\u68f5\u6811\u4e0a\u6240\u6709\u8282\u70b9\u7684\u6743\u503c\u4e0d\u662f ``1`` \u5c31\u662f ``0`` \uff0c\u6240\u4ee5\u4fee\u6539\u4e4b\u540e\u8be5\u533a\u95f4\u7684\u533a\u95f4\u548c\u5c31\u53d8\u6210\u4e86\u533a\u95f4\u7684\u957f\u5ea6\u51cf\u53bb\u539f\u672c\u7684\u533a\u95f4\u548c\u3002\n\n$ \\text {\\color{red} e.g. \\; \\; \u5047\u8bbe\u533a\u95f4\u4e2d\u7684\u5143\u7d20\u662f[0,0,1,0,1]\uff0c\u90a3\u4e48\u5b83\u7684\u533a\u95f4\u548c\u5c31\u662f2\uff0c\u957f\u5ea6\u662f5} $\n\n$ \\text {\\color{red} \u5982\u679c\u5bf9\u8fd9\u4e2a\u533a\u95f4\u8fdb\u884c\u53d6\u53cd\u64cd\u4f5c\uff0c\u5219\u64cd\u4f5c\u540e\u7684\u533a\u95f4\u5143\u7d20\u662f[1,1,0,1,0]} $\n\n$ \\text {\\color{red} \u5b83\u7684\u533a\u95f4\u548c\u5c31\u53d8\u6210\u4e86}{\\color{red} 5 - 2=3} $\n\n------------\n\n\u63a5\u4e0b\u6765\u5c31\u662f\u4ee3\u7801\u65f6\u95f4\u4e86\uff0c\u6811\u94fe\u5256\u5206\u548c\u7ebf\u6bb5\u6811\u7684\u5199\u6cd5\u5177\u4f53\u8bf7\u770b\u677f\u5b50\u9898\n\n```cpp\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\n// #define int long long\n\n/***************\u5feb\u8bfb***************/\n\nnamespace IO {\nchar buf[1<<21], *p1 = buf, *p2 = buf, buf1[1<<21];\ninline char gc () {return p1 == p2 && (p2 = (p1 = buf) + fread (buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++;}\n\n#ifndef ONLINE_JUDGE\n#endif\n\n#define gc getchar\n\ntemplate<class I>\ninline void read(I &x) {\n    x = 0; I f = 1; char c = gc();\n    while(c < '0' || c > '9') {if(c == '-') f = -1; c = gc(); }\n    while(c >= '0' && c <= '9') {x = x * 10 + c - '0'; c = gc(); }\n    x *= f;\n}\n\ntemplate<class I>\ninline void write(I x) {\n    if(x == 0) {putchar('0'); return;}\n    I tmp = x > 0 ? x : -x;\n    if(x < 0) putchar('-');\n    int cnt = 0;\n    while(tmp > 0) {\n        buf1[cnt++] = tmp % 10 + '0';\n        tmp /= 10;\n    }\n    while(cnt > 0) putchar(buf1[--cnt]);\n}\n\n#define in(x) read(x)\n#define outn(x) write(x), putchar('\\n')\n#define out(x) write(x), putchar(' ')\n\n} using namespace IO;\n\n/***************\u5feb\u8bfb***************/\n\n#define maxn 1000010\n\nstruct Edge{\n\tint start;\n\tint end;\n\tint val;\n\tint nexty;\n}edge[maxn];\n\nint link[maxn],edge_cnt;\n\nvoid add_edge(int u,int v,int w=0){\n\tedge[++edge_cnt]=(Edge){u,v,w,link[u]};\n\tlink[u]=edge_cnt;\n}\n\nint tot[maxn],top[maxn],depth[maxn];\nint fa[maxn],son[maxn],id[maxn];\nint a[maxn],b[maxn];\nint dfs_cnt;\n\nint dfs1(int now,int f,int dep){\n\tfa[now]=f;\n\tdepth[now]=dep;\n\ttot[now]=1;\n\tint maxson=-1;\n\tfor(int i=link[now];i;i=edge[i].nexty){\n\t\tif(edge[i].end==f){continue;}\n\t\ttot[now]+=dfs1(edge[i].end,now,dep+1);\n\t\tif(maxson<tot[edge[i].end]){\n\t\t\tmaxson=tot[edge[i].end];\n\t\t\tson[now]=edge[i].end;\n\t\t}\n\t}\n\treturn tot[now];\n}\n\nvoid dfs2(int now,int topf){\n\tid[now]=++dfs_cnt;\n\ta[dfs_cnt]=b[now];\n\ttop[now]=topf;\n\tif(!son[now]){return;}\n\tdfs2(son[now],topf);\n\tfor(int i=link[now];i;i=edge[i].nexty){\n\t\tif(!id[edge[i].end]){\n\t\t\tdfs2(edge[i].end,edge[i].end);\n\t\t}\n\t}\n}\n\nclass Segment_Fold{\n\tprivate:\n\t\tstruct Seg_Tree{\n\t\t\tint l,r;\n\t\t\tint len;\n\t\t\tint val;\n\t\t\tint lazy;\n\t\t}tree[maxn];\n\n\tpublic:\n\t\tvoid pushup(int ID){\n\t\t\ttree[ID].val=tree[ID<<1].val+tree[ID<<1|1].val;\n\t\t}\n\n\t\tvoid build(int ID,int l,int r){\n\t\t\ttree[ID].l=l,tree[ID].r=r;\n\t\t\ttree[ID].len=(r-l+1);\n\t\t\tif(l==r){\n\t\t\t\ttree[ID].val=a[l];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid=(l+r)>>1;\n\t\t\tbuild(ID<<1,l,mid);\n\t\t\tbuild(ID<<1|1,mid+1,r);\n\t\t\tpushup(ID);\n\t\t\treturn;\n\t\t}\n\n\t\tvoid pushdown(int ID){\n\t\t\tif(tree[ID].lazy){\n\t\t\t\ttree[ID].lazy^=1;\n\t\t\t\ttree[ID<<1].lazy^=1;\n\t\t\t\ttree[ID<<1|1].lazy^=1;\n\t\t\t\ttree[ID<<1].val=tree[ID<<1].len-tree[ID<<1].val;\n\t\t\t\ttree[ID<<1|1].val=tree[ID<<1|1].len-tree[ID<<1|1].val;\n\t\t\t}\n\t\t}\n\n\t\tvoid update(int ID,int l,int r){\n\t\t\tif(tree[ID].l>=l&&tree[ID].r<=r){\n\t\t\t\ttree[ID].lazy^=1;\n\t\t\t\ttree[ID].val=tree[ID].len-tree[ID].val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpushdown(ID);\n\t\t\tint mid=(tree[ID].l+tree[ID].r)>>1;\n\t\t\tif(l<=mid){\n\t\t\t\tupdate(ID<<1,l,r);\n\t\t\t} if(r>mid){\n\t\t\t\tupdate(ID<<1|1,l,r);\n\t\t\t}\n\t\t\tpushup(ID);\n\t\t\treturn;\n\t\t}\n\n\t\tvoid Tree_Update(int x,int y){\n\t\t\twhile(top[x]!=top[y]){\n\t\t\t\tif(depth[top[x]]<depth[top[y]]){\n\t\t\t\t\tstd::swap(x,y);\n\t\t\t\t}\n\t\t\t\tupdate(1,id[top[x]],id[x]);\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t\tif(depth[x]>depth[y]){\n\t\t\t\tstd::swap(x,y);\n\t\t\t}\n\t\t\tupdate(1,id[x],id[y]);\n\t\t\treturn;\n\t\t}\n\n\t\tint query(int ID,int l,int r){\n\t\t\tif(tree[ID].l>=l&&tree[ID].r<=r){\n\t\t\t\treturn tree[ID].val;\n\t\t\t}\n\t\t\tpushdown(ID);\n\t\t\tint mid=(tree[ID].l+tree[ID].r)>>1;\n\t\t\tint ans=0;\n\t\t\tif(l<=mid){\n\t\t\t\tans+=query(ID<<1,l,r);\n\t\t\t} if(r>mid){\n\t\t\t\tans+=query(ID<<1|1,l,r);\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\tint Tree_Query(int x,int y){\n\t\t\tint ans=0;\n\t\t\twhile(top[x]!=top[y]){\n\t\t\t\tif(depth[top[x]]<depth[top[y]]){\n\t\t\t\t\tstd::swap(x,y);\n\t\t\t\t}\n\t\t\t\tans+=query(1,id[top[x]],id[x]);\n\t\t\t\tx=fa[top[x]];\n\t\t\t}\n\t\t\tif(depth[x]>depth[y]){\n\t\t\t\tstd::swap(x,y);\n\t\t\t}\n\t\t\tans+=query(1,id[x],id[y]);\n\t\t\treturn ans;\n\t\t}\n}se;\n\nint root=1;\nint n,m;\n\nint main(){\n\tread(n);\n\tfor(int i=1,x;i<n;i++){\n\t\tread(x);\n\t\tadd_edge(x,i+1);\n\t}\n\tfor(int i=1;i<=n;i++){read(b[i]);}\n\tdfs1(root,0,1);\n\tdfs2(root,root);\n\tse.build(1,1,n);\n\tread(m);\n\tstd::string opt;\n\tint k;\n\twhile(m--){\n\t\tstd::cin>>opt;\n\t\tread(k);\n\t\tif(opt[0]=='g'){\n\t\t\toutn(se.query(1,id[k],id[k]+tot[k]-1));\n\t\t} else{\n\t\t\tse.update(1,id[k],id[k]+tot[k]-1);\n\t\t}\n\t}\n\treturn 0;\n}\n```\n\n$\\text{15}$\u5206\u949f\u7801\u5b8c\u4e00\u904d\u8fc7\u6311\u6218\u65e0 $\\text{bug}$\n\n\n![](bilibili:BV1sM4y1M7wX)",
        "postTime": 1625996572,
        "uid": 360930,
        "name": "Jairon314",
        "ccfLevel": 6,
        "title": "CF877E"
    },
    {
        "content": "## Description\n\n\u7ed9\u5b9a\u4e00\u68f5\u6743\u503c\u53ea\u80fd\u4e3a $1$ \u6216 $0$ \u7684\u6811\uff0c\u5bf9\u5176\u8fdb\u884c\u4e24\u79cd\u64cd\u4f5c\u3002\n\n\u4e00\u79cd\u662f\u5c06\u5176\u4e2d\u7684\u67d0\u68f5\u5b50\u6811\u53d6\u53cd\uff0c\u53e6\u4e00\u79cd\u662f\u8be2\u95ee\u67d0\u68f5\u5b50\u6811\u4e2d $1$ \u7684\u4e2a\u6570\u3002\n\n## Solution\n\n\u6bd4\u8f83\u677f\u7684\u7ebf\u6bb5\u6811\u3002\n\n\u663e\u7136\u7684\uff0c\u5047\u8bbe\u4e00\u68f5\u5927\u5c0f\u4e3a $x$ \u7684\u5b50\u6811\u4e2d\u6709 $y$ \u4e2a 1\uff0c\u90a3\u4e48\u8fd9\u68f5\u5b50\u6811\u53d6\u53cd\u540e\u5c31\u6709 $x-y$ \u4e2a $1$\u3002\n\n\u9898\u76ee\u53ea\u9700\u8981\u6211\u4eec\u7ef4\u62a4\u4e00\u79cd\u4fe1\u606f\uff0c\u7136\u540e\u8fd9\u79cd\u4fe1\u606f\u7684\u53d8\u6362\u53ea\u6709\u8fd9\u4e00\u79cd\u65b9\u6cd5\uff0c\u6240\u4ee5\u6211\u4eec\u77e5\u9053\u4e86\u8fd9\u4e2a\u6027\u8d28\u5c31\u53ef\u4ee5\u76f4\u63a5\u641e\u4e86\u3002\n\n\u6839\u636e\u533a\u95f4\u4fee\u6539\u7ef4\u62a4\u61d2\u6807\u8bb0\u7684\u539f\u7406\uff0c\u5f53\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u53d6\u53cd\u540e\uff0c\u5b83\u7684\u5de6\u53f3\u513f\u5b50\u90fd\u8981\u53d6\u53cd\uff0c\u56e0\u6b64\u61d2\u6807\u8bb0\u4e0b\u4f20\u65f6\u4e5f\u4e0d\u65ad\u53d6\u53cd\u5c31\u53ef\u4ee5\u4e86\u3002\n\n\u7136\u540e\u5c31\u505a\u5b8c\u4e86\u3002\n\n## Code\n\n```cpp\n#include<bits/stdc++.h>\n#define maxn 2001000\n#define INF 0x3f3f3f3f \n//#define int long long\n\nusing namespace std;\n\nint n,m,tot,cnt;\nint a[maxn],head[maxn],lazy[maxn];\nint sum[maxn],val[maxn],fa[maxn];\nint dfn[maxn],top[maxn],son[maxn];\nint dep[maxn],siz[maxn],pre[maxn];\nstruct edge{int fr,to,nxt;}e[maxn];\n\nint read(){\n\tint s=0,w=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=(s<<1)+(s<<3)+ch-'0';ch=getchar();}\n\treturn s*w;\n}\n\nvoid add(int fr,int to){\n    e[++tot].fr=fr;e[tot].to=to;\n    e[tot].nxt=head[fr];head[fr]=tot;\n}\n\nnamespace Seg{\n    #define ls x<<1\n    #define rs x<<1|1\n    void pushup(int x){\n        sum[x]=sum[ls]+sum[rs];\n    }\n    \n    void pushdown(int x,int ln,int rn){\n        if(!lazy[x]) return;\n        lazy[ls]^=1;\n        lazy[rs]^=1;\n        sum[ls]=ln-sum[ls];\n        sum[rs]=rn-sum[rs];\n        lazy[x]=0;\n    }\n    \n    void build(int x,int l,int r){\n        if(l==r){sum[x]=a[pre[l]];return;} \n        int mid=l+r>>1;\n        build(ls,l,mid);build(rs,mid+1,r);\n        pushup(x);\n    }\n    \n    void update(int x,int l,int r,int L,int R){\n        if(L<=l&&R>=r){sum[x]=r-l+1-sum[x],lazy[x]^=1;return;}\n        int mid=l+r>>1;pushdown(x,mid-l+1,r-mid);\n        if(L<=mid) update(ls,l,mid,L,R);\n        if(R>=mid+1) update(rs,mid+1,r,L,R);\n        pushup(x); \n    }\n    \n    int query(int x,int l,int r,int L,int R){\n        if(L<=l&&R>=r)return sum[x];\n        int mid=l+r>>1,ans=0;pushdown(x,mid-l+1,r-mid);\n        if(L<=mid) ans+=query(ls,l,mid,L,R);\n        if(R>=mid+1) ans+=query(rs,mid+1,r,L,R);\n        return ans;\n    }\n}\n\nnamespace Cut{\n    void dfs1(int x,int fat){\n        dep[x]=dep[fat]+1;\n        fa[x]=fat;siz[x]=1;\n        for(int i=head[x];i;i=e[i].nxt){\n            int to=e[i].to;\n            if(to==fat) continue;\n            dfs1(to,x);siz[x]+=siz[to];\n            if(siz[to]>siz[son[x]])son[x]=to;\n        }\n    }\n    \n    void dfs2(int x,int tp){\n        top[x]=tp;dfn[x]=++cnt;pre[cnt]=x;\n        if(son[x]) dfs2(son[x],tp);\n        for(int i=head[x];i;i=e[i].nxt){\n            int to=e[i].to;\n            if(to==fa[x]||to==son[x]) continue;\n            dfs2(to,to);\n        }\n    }\n}\n\nint main(){\n    n=read();\n    for(int i=2,fa;i<=n;i++) fa=read(),add(fa,i);\n    for(int i=1;i<=n;i++) a[i]=read();m=read();\n    Cut::dfs1(1,0);Cut::dfs2(1,1);Seg::build(1,1,n);\n    for(int i=1,pos;i<=m;i++){\n        string opt;cin>>opt;pos=read();\n        if(opt[0]=='g') printf(\"%d\\n\",Seg::query(1,1,n,dfn[pos],dfn[pos]+siz[pos]-1));\n        else if(opt[0]=='p') Seg::update(1,1,n,dfn[pos],dfn[pos]+siz[pos]-1);\n    }\n    return 0;\n}\n```\n",
        "postTime": 1618106418,
        "uid": 281497,
        "name": "KEBrantily",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "### \u7b80\u660e\u7684\u4ee3\u7801\n\n\u601d\u8def\u548c\u697c\u4e0b\u5927\u4f6c\u662f\u4e00\u6837\u7684\n\n _~~\u5927\u4f6c\u7801\u98ce\u96be\u4ee5\u606d\u7ef4~~_ \n\n#### dfs\u5e8f + \u7ebf\u6bb5\u6811\n\n\u8981\u6ce8\u610f\u8fd9\u91cclazy\u6570\u7ec4\u4f5c\u4e3a\u4e00\u4e2abool\u6807\u8bb0\u6267\u884c\u7684\u662f\u53d6\u53cd\u64cd\u4f5c\u3002\n\n\u5269\u4e0b\u7684\u8981\u70b9\u5728\u4ee3\u7801\u6ce8\u91ca\u91cc\n\n------------\n\n```cpp\n#include <cstdio>\n#define N 200005\nusing namespace std;\n\nint n, q, a[N];\n//\u90bb\u63a5\u94fe\u8868\u8bb0\u5f55\u5b50\u8282\u70b9\nint head[N], point[N], next[N], top = 1;\n//\u7ebf\u6bb5\u6811\u7684L,R\u6807\u8bb0(\u6bcf\u4e2a\u8282\u70b9\u5360\u57df)\n//P\u5728\u8fd9\u91cc\u8bb0\u5f55dfs\u5e8f\u5148\u540e\u987a\u5e8f\nint p[N], L[N], R[N], cnt, num;\nint tr[4 * N];//\u7ebf\u6bb5\u6811\nbool lazy[4 * N];//bool-lazy\u6570\u7ec4\n\nvoid insert(int u, int v) {//\u90bb\u63a5\u94fe\u8868\u63d2\u5165\n\tpoint[top] = v;\n\tnext[top] = head[u];\n\thead[u] = top++;\n}\n\nvoid dfs(int x) {//\u6c42dfs\u5e8f\n\tL[x] = ++cnt;\n\tp[cnt] = x;\n\tfor(int i = head[x];i;i = next[i])\n\t\tdfs(point[i]);\n\tR[x] = cnt;\n}\n\nvoid build(int l, int r, int x) {//\u5efa\u6811\n\tif(l == r) {\n\t\ttr[x] = a[p[++num]];//P\u6570\u7ec4\u7684\u4f5c\u7528\u4f53\u73b0\u51fa\u6765\u4e86\n\t\treturn;\n\t}\n\tint mid = l + r >> 1;\n\tbuild(l, mid, x << 1);\n\tbuild(mid + 1, r, x << 1 | 1);\n\ttr[x] = tr[x << 1] + tr[x << 1 | 1];//push_up\n}\n\nvoid push_down(int l, int r, int x) {//lazy-push_down\n\tint mid = l + r >> 1;\n\ttr[x << 1] = mid - l + 1 - tr[x << 1];//\u8ba1\u7b97\u53d6\u53cd\u540e\u8282\u70b9\u6570\n\ttr[x << 1 | 1] = r - mid - tr[x << 1 | 1];\n\tlazy[x << 1] = !lazy[x << 1];//!!\u53d6\u53cd\u64cd\u4f5c\n\tlazy[x << 1 | 1] = !lazy[x << 1 | 1];\n\tlazy[x] = 0;\n}\n\nint get(int l, int r, int x, int ls, int lr) {//\u8ba1\u7b97\u6570\u91cf\n\tif(l == ls && r == lr) {\n\t\treturn tr[x];\n\t}\n\tif(lazy[x]) push_down(l, r, x);\n\tint mid = l + r >> 1;\n\tif(lr <= mid) return get(l, mid, x << 1, ls, lr);\n\telse if(ls > mid) return get(mid + 1, r, x << 1 | 1, ls, lr);\n\telse {\n\t\treturn get(l, mid, x << 1, ls, mid) + get(mid + 1, r, x << 1 | 1, mid + 1, lr);\n\t}\n}\n\nvoid pow(int l, int r, int x, int ls, int lr) {//\u96c6\u4f53\u53d6\u53cd\n\tif(l == ls && r == lr) {\n\t\ttr[x] = r - l + 1 - tr[x];\n\t\tlazy[x] = !lazy[x];\n\t\treturn;\n\t}\n\tif(lazy[x]) push_down(l, r, x);\n\tint mid = l + r >> 1;\n\tif(lr <= mid) pow(l, mid, x << 1, ls, lr);\n\telse if(ls > mid) pow(mid + 1, r, x << 1 | 1, ls, lr);\n\telse {\n\t\tpow(l, mid, x << 1, ls, mid);\n\t\tpow(mid + 1, r, x << 1 | 1, mid + 1, lr);\n\t}\n\ttr[x] = tr[x << 1] + tr[x << 1 | 1];//!!push_up\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tint u;\n\tfor(int i = 2;i <= n;i++) {\n\t\tscanf(\"%d\", &u);\n\t\tinsert(u, i);//\u5efa\u6811\n\t}\n\tfor(int i = 1;i <= n;i++)\n\t\tscanf(\"%d\", a + i);\n\tdfs(1);\n\tbuild(1, cnt, 1);//\u5efa\u7ebf\u6bb5\u6811\n\tscanf(\"%d\", &q);\n\tchar op[10];\n\tint x;\n\twhile(q--) {\n\t\tscanf(\"%s%d\", op, &x);\n\t\tif(*op == 'p') pow(1, cnt, 1, L[x], R[x]);\n\t\telse printf(\"%d\\n\", get(1, cnt, 1, L[x], R[x]));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1558007432,
        "uid": 133236,
        "name": "saxiy",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "## Description\n\n\u7ed9\u4f60\u4e00\u68f5\u53ea\u6709 0 \u548c 1 \u7684\u6811\uff0c\u6709\u4e24\u4e2a\u64cd\u4f5c \uff1a\n\n+ \u8be2\u95ee\u4e00\u68f5\u5b50\u6811\u4e2d\u6709\u51e0\u4e2a 1\u3002\n+ \u628a\u4e00\u68f5\u5b50\u6811\u7684\u6570\u5b57\u53d6\u53cd\u3002\n\n$1 \\leq n,q \\leq 2 \\times 10 ^ 5$\u3002\n\n\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u6811\u94fe\u5256\u5206\u7684\u677f\u5b50\u9898\u3002\n\n## Solution\n\n\u524d\u7f6e\u77e5\u8bc6 \uff1a \u6811\u94fe\u5256\u5206\uff0c\u7ebf\u6bb5\u6811\u3002\n\n\u9996\u5148\uff0c\u5148\u7528\u6811\u5256\u8fdb\u884c\u6811\u4e0a dfs \u7684\u6807\u8bb0\u548c\u5b50\u6811\u7684\u7edf\u8ba1\uff0c\u8fd9\u91cc\u6709\u4e00\u4e2a\u6027\u8d28\uff0c\u5c31\u662f\u4e00\u9897\u5b50\u6811\u7684 dfs \u5e8f\u80af\u5b9a\u662f\u8fde\u7eed\u7684\u4e00\u4e32\uff0c\u6240\u4ee5\uff0c\u6211\u4eec\u7528 ```dfn[]``` \u8868\u793a dfs \u5e8f\uff0c\u7528 ```tot[]``` \u8868\u793a\u5b50\u6811\u5927\u5c0f\uff0c\u90a3\u4e48\u70b9 $x$ \u7684\u5b50\u6811\u5185\u7684\u70b9\u7684 dfs \u5e8f\u7684\u8303\u56f4\u5c31\u662f ```dfn[x] + tot[x] - 1```\u3002\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u5c31\u628a\u4e00\u4e2a\u7edf\u8ba1\u5b50\u6811\u7684\u95ee\u9898\u8f6c\u5316\u5230\u4e86\u4e00\u4e2a\u5e8f\u5217\u4e0a\u3002\n\n\u4e4b\u540e\u5c31\u76f4\u63a5\u641e\u4e00\u68f5\u7ebf\u6bb5\u6811\u5c31\u597d\u4e86\u3002\n\n\u6240\u4ee5\uff0c\u56e0\u4e3a\u53ea\u6709 0 \u548c 1\uff0c\u6240\u4ee5\u6211\u4eec\u5bf9\u4e8e\u6c42\u6709\u51e0\u4e2a 1\uff0c\u7ef4\u62a4\u4e00\u4e2a\u533a\u95f4\u548c\u5373\u53ef\u3002\n\n\u5bf9\u4e8e\u53d6\u53cd\u64cd\u4f5c\uff0c\u53d6\u5947\u6570\u6b21\u76f8\u5f53\u4e8e\u53d6\u53cd\uff0c\u53d6\u5076\u6570\u6b21\u76f8\u5f53\u4e8e\u4e0d\u53d8\uff0c\u5e76\u4e14\u53d6\u53cd\u540e\u7684\u533a\u95f4\u548c\u5c31\u662f\u533a\u95f4\u957f\u5ea6\u51cf\u53bb\u539f\u6765\u7684\u533a\u95f4\u548c\uff0c\u4e4b\u540e\u6253\u6807\u8bb0\u4e0b\u653e\uff0c\u90fd\u662f\u5e38\u89c4\u64cd\u4f5c\u4e86\u3002\n\n## Code \n\n```\n#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Maxk = 2e5 + 10;\nint dfn[Maxk],tot[Maxk],son[Maxk];\nint top[Maxk],deep[Maxk],fa[Maxk];\nint a[Maxk],b[Maxk];\nvector <int> E[Maxk];\nint n,m,cnt;\nstruct SegTree {\n  int l_,r_,sum_,tag_,Len_;\n}t[Maxk << 2];\ninline int read()\n{\n\tint s = 0, f = 0;char ch = getchar();\n\twhile (!isdigit(ch)) f |= ch == '-', ch = getchar();\n\twhile (isdigit(ch)) s = s * 10 + (ch ^ 48), ch = getchar();\n\treturn f ? -s : s;\n}\nvoid dfs1(int x,int f)\n{\n  deep[x] = deep[f] + 1;\n  fa[x] = f;\n  tot[x] = 1;\n  for(int i = 0;i < E[x].size();i ++) {\n    int y = E[x][i];\n    if(y == f) continue;\n    dfs1(y,x);\n    tot[x] += tot[y];\n    if(tot[y] > tot[son[x]]) son[x] = y;\n  }  \n} \nvoid dfs2(int x,int tf)\n{\n  dfn[x] = ++ cnt;  \n  a[cnt] = b[x];\n  top[x] = tf;\n  if(!son[x]) return;\n  dfs2(son[x],tf);\n  for(int i = 0;i < E[x].size();i ++) {\n    int y = E[x][i];\n    if(y == fa[x] || y == son[x]) continue;\n    dfs2(y,y); \n  } \n} \nvoid push_up(int i)\n{\n  t[i].sum_ = t[i << 1].sum_ + t[i << 1 | 1].sum_;\n}\nvoid build(int i,int l,int r)\n{\n  t[i].l_ = l;\n  t[i].r_ = r;\n  t[i].Len_ = r - l + 1;\n  if(l == r) {\n    t[i].sum_ = a[l];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  build(i << 1,l,mid);\n  build(i << 1 | 1,mid + 1,r);\n  push_up(i);\n}\nvoid push_down(int i)\n{\n  if(!t[i].tag_) return;\n  t[i << 1].sum_ = t[i << 1].Len_ - t[i << 1].sum_;\n  t[i << 1 | 1].sum_ = t[i << 1 | 1].Len_ - t[i << 1 | 1].sum_;\n  t[i << 1].tag_ ^= 1;\n  t[i << 1 | 1].tag_ ^= 1;\n  t[i].tag_ ^= 1;\n}\nvoid Change(int i,int l,int r)\n{\n  if(t[i].l_ >= l && t[i].r_ <= r) {\n    t[i].sum_ = t[i].Len_ - t[i].sum_;\n    t[i].tag_ ^= 1;\n    return;\n  }\n  push_down(i);\n  int mid = (t[i].l_ + t[i].r_) >> 1;\n  if(l <= mid) Change(i << 1,l,r);\n  if(r > mid) Change(i << 1 | 1,l,r);\n  push_up(i);\n} \nint Ask(int i,int l,int r)\n{\n  if(t[i].l_ >= l && t[i].r_ <= r) return t[i].sum_;\n  int Ans = 0,mid = (t[i].l_ + t[i].r_) >> 1;\n  push_down(i);\n  if(l <= mid) Ans += Ask(i << 1,l,r);\n  if(r > mid) Ans += Ask(i << 1 | 1,l,r);\n  return Ans; \n}\nsigned main()\n{\n  n = read();\n  for(int i = 1;i <= n - 1;i ++) {\n    int x = read();\n    E[x].push_back(i + 1);\n  }\n  for(int i = 1;i <= n;i ++) b[i] = read();\n  dfs1(1,0);\n  dfs2(1,1);\n  build(1,1,n);\n  m = read();\n  for(int i = 1;i <= m;i ++) {\n    string s;cin >> s;int x = read();\n    if(s[0] == 'g') printf(\"%d\\n\",Ask(1,dfn[x],dfn[x] + tot[x] - 1));\n    else if(s[0] == 'p') Change(1,dfn[x],dfn[x] + tot[x] - 1);\n  }\n  return 0;\n}\n```\n",
        "postTime": 1626160127,
        "uid": 381904,
        "name": "\u659c\u63fd\u6b8b\u7bab",
        "ccfLevel": 6,
        "title": "\u3010CF877E Danil and a Part-time Job\u3011\u9898\u89e3"
    },
    {
        "content": "\u6811\u94fe\u5256\u5206\n\n## \u601d\u8def\n\n\u8fd9\u662f\u4e00\u9053\u5f88\u7b80\u5355\u7684\u6811\u5256\u9898\uff0c\u82e5\u4e0d\u4f1a\u6811\u5256\uff0c\u70b9[\u8fd9\u91cc](https://www.luogu.com.cn/problem/P3384)\n\n\u6b64\u9898\u53ea\u8981\u5148\u7528\u6811\u5256\u5c06\u4ed6\u53d8\u6210\u7ebf\u6bb5\u6811\n\n\u6539\u53d8\u5b50\u6811\uff0c\u628a\u5b50\u6811\u53cd\u8f6c\u5373\u53ef\uff0c\u56e0\u4e3a\u5b50\u6811\u4e00\u5b9a\u5728\u4e00\u8d77\uff0c\u53ea\u8981\u5728\u7ebf\u6bb5\u6811\u4e0a\u64cd\u4f5c\u5373\u53ef\n\n```cpp\nvoid change(int rt,int l,int r)\n{\n\tif(tr[rt].l>r||tr[rt].r<l)return;\n\tif(tr[rt].l>=l&&tr[rt].r<=r)\n\t{\n\t\ttr[rt].num=tr[rt].r-tr[rt].l+1-tr[rt].num;\n\t\ttr[rt].tag=tr[rt].tag^1;return;\n\t}\n\tpush(rt);\n\tchange(ls,l,r),change(rs,l,r);\n\ttr[rt].num=(tr[ls].num+tr[rs].num);\n}\n```\n\n\u5176\u4f59\u53ea\u8981\u6ce8\u610f\u7ec6\u8282\u5373\u53ef\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n\tchar ch=getchar();bool f=0;int x=0;\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);\n\tif(f==1)x=-x;return x;\n}\n#define ls rt<<1\n#define rs rt<<1|1\nconst int maxn=500005;\nstruct edge\n{\n\tint v,nex;\n}e[maxn];\nstruct tree\n{\n\tint l,r,num,tag;\n}tr[maxn];\nint head[maxn],a[maxn],n,m,mod,r,op,x,y,cnt=0,z;\nint s[maxn],son[maxn],fa[maxn],h[maxn],top[maxn],id[maxn],idx=0,b[maxn];\nvoid add(int u,int v){e[++cnt].v=v,e[cnt].nex=head[u],head[u]=cnt; }\nvoid dfs1(int u)\n{\n\th[u]=h[fa[u]]+1;s[u]=1;\n\tfor(int i=head[u];i;i=e[i].nex)\n\t{\n\t\tint v=e[i].v;\n\t\tif(fa[u]==v)continue;\n\t\tfa[v]=u;dfs1(v);s[u]+=s[v];\n\t\tif(s[son[u]]<s[v])son[u]=v;\n\t}\n} \nvoid dfs2(int u,int topp)\n{\n\tid[u]=++idx;\n\tb[idx]=a[u];\n\ttop[u]=topp;\n\tif(son[u])dfs2(son[u],topp);\n\tfor(int i=head[u];i;i=e[i].nex)\n\t{\n\t\tint v=e[i].v;\n\t\tif(v==fa[u]||v==son[u])continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid push(int rt)\n{\n\tif(tr[rt].tag)\n\t\ttr[rs].tag=tr[rs].tag^1,tr[ls].tag=tr[ls].tag^1,\n\t\ttr[rs].num=tr[rs].r-tr[rs].l+1-tr[rs].num,\n\t\ttr[ls].num=tr[ls].r-tr[ls].l+1-tr[ls].num;\n\ttr[rt].tag=0;\n}\nvoid build(int rt,int l,int r)\n{\n\ttr[rt].l=l,tr[rt].r=r;tr[rt].tag=0;\n\tif(l==r)\n\t{\n\t\ttr[rt].num=b[l];return;\n\t}\n\tint mid=l+r>>1;\n\tbuild(ls,l,mid),build(rs,mid+1,r);\n\ttr[rt].num=tr[ls].num+tr[rs].num;\n}\nvoid change(int rt,int l,int r)\n{\n\tif(tr[rt].l>r||tr[rt].r<l)return;\n\tif(tr[rt].l>=l&&tr[rt].r<=r)\n\t{\n\t\ttr[rt].num=tr[rt].r-tr[rt].l+1-tr[rt].num;\n\t\ttr[rt].tag=tr[rt].tag^1;return;\n\t}\n\tpush(rt);\n\tchange(ls,l,r),change(rs,l,r);\n\ttr[rt].num=(tr[ls].num+tr[rs].num);\n}\nint query(int rt,int l,int r)\n{\n\tif(tr[rt].l>r||tr[rt].r<l)return 0;\n\tif(tr[rt].l>=l&&tr[rt].r<=r)return tr[rt].num;\n\tpush(rt);\n\treturn (query(ls,l,r)+query(rs,l,r));\n}\nchar c=0;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<n;i++)x=i+1,y=read(),add(x,y),add(y,x);\n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tdfs1(1),dfs2(1,1);\n\tbuild(1,1,n),m=read();\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\twhile(c!='p'&&c!='g')c=getchar();\n\t\tif(c=='p')\n\t\t\tx=read(),change(1,id[x],id[x]+s[x]-1);\n\t\tif(c=='g')\n\t\t\tx=read(),printf(\"%d\\n\",query(1,id[x],id[x]+s[x]-1));c=0;\n\t}\n\treturn 0;\n}\n```\n\n\n\n",
        "postTime": 1607761171,
        "uid": 343748,
        "name": "louhao088",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "\uff08\u65e5\u5e38\u804a\u5929\uff09\u4e00\u5929\u4fe9\u9898\u89e3\uff0c\u723d\u5440\u3002~~\u867d\u7136\u4e0d\u4e00\u5b9a\u80fd\u8fc7~~\n\n------------\n\n\n\u9898\u610f\uff1a\u6811\u5256\u88f8\u9898\u3002\n\n\n\n------------\n\n\u6253\u4e00\u4e2a\u6811\u5256\u3002\n\n1. pow\uff1a\u62ff\u533a\u95f4\u957f\u5ea6\u51cf\u53bb\u5f53\u524d1\u7684\u4e2a\u6570\uff1b\n\n2. get\uff1a\u6c42\u533a\u95f4\u548c\u3002\n\n3. \u61d2\u6807\u8bb0\uff1a\u5982\u679c\u6539\u8fc7\u4e24\u6b21\uff0c\u5373\u76f8\u5f53\u4e8e\u6ca1\u6539\u8fc7\u3002\uff08\u5982\u679c\u4f60\u4e0d\u4f1a\u4e8c\u8fdb\u5236\u7684\uff0c\u53ea\u8981\u62ff\u61d2\u6807\u8bb0%2\uff0c\u5c31\u53ef\u4ee5\uff09\u3002\n\n\u603b\u7ed3\uff0c\u6811\u5256\u88f8\u9898\u3002\n\n```cpp\n#include<bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nstruct node{\n\tint u,v;\n}a[2000500];\n\nint laz[2000500],cnt;\n\nint head[2000500],tree[2000500];\n\nint n,m,p,wt[2000500],cntt,son[2000500];\n\nint dep[2005000],top[2005000],w[2000500];\n\nint siz[2005000],fath[2005000],r,id[2000500];\n\nvoid add(int u,int v)\n{\n\ta[++cntt].u=head[u];\n\t\n\ta[cntt].v=v;\n\t\n\thead[u]=cntt;\n}\n\nvoid pushdown(int u,int l,int r)\n{\n\tif(laz[u]==0)return;\n\t\n\tint mid=(l+r)/2;\n\t\n\tlaz[u*2]=(laz[u*2]+laz[u])%2;\n\t\n\tlaz[u*2+1]=(laz[u*2+1]+laz[u])%2;\n\t\n\ttree[u*2]=-tree[u*2]+mid-l+1;\n\t\n\ttree[u*2+1]=-tree[u*2+1]+(r-mid);\n\t\n\tlaz[u]=0;\n\t\n\treturn;\n}\n\nvoid build(int u,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttree[u]=wt[l];\n\t\t\n\t\treturn;\n\t}\n    //cout<<u;\n\tint mid=(l+r)/2;\n\t\n\tbuild(u*2,l,mid);\n\t\n\tbuild(u*2+1,mid+1,r);\n\t\n\ttree[u]=tree[u*2]+tree[u*2+1]; \n\t//cout<<tree[u];\n}\n\nvoid update(int u,int l,int r,int x,int y,int z)\n{\n\tif(l>=x&&r<=y)\n\t{\n\t\tlaz[u]=(laz[u]+1)%2;\n\t\t\n\t\ttree[u]=-tree[u]+(r-l+1);\n\t\t\n\t\treturn;\n\t}\n\t\n\tint mid=(l+r)/2;\n\t\t//cout<<1;\n\tpushdown(u,l,r);\n\t\t\n\tif(x<=mid) update(u*2,l,mid,x,y,z);\n\t\n\tif(y>mid) update(u*2+1,mid+1,r,x,y,z);\n\t\n\ttree[u]=tree[u*2]+tree[u*2+1];\n}\n\nint query(int u,int l,int r,int x,int y)\n{\n\tif(l>=x&&r<=y) return tree[u];\n\t\n\tpushdown(u,l,r);\n\t\n\tint mid=(l+r)/2,ans=0;\n\t\n\tif(x<=mid) ans=(ans+query(u*2,l,mid,x,y));\n\t\n\tif(y>mid) ans=(ans+query(u*2+1,mid+1,r,x,y));\n\t\n\treturn ans;\n}\n\nint query1(int l,int r)\n{\n\tint ans=0;\n\t\n\twhile(top[l]!=top[r])\n\t{\n\t\tif(dep[top[l]]<dep[top[r]])swap(l,r);\n\t\t\n\t\tans=(ans+query(1,1,n,id[top[l]],id[l]))%p;\n\t\t\n\t\tl=fath[top[l]];\n\t}\n\t\n\tif(dep[l]>dep[r])swap(l,r);\n\t\n\tans=(ans+query(1,1,n,id[l],id[r]))%p;\n\t\n\treturn ans%p; \n}\n\nvoid add1(int l,int r,int t)\n{\n\tt%=p;\n\t\n\twhile(top[l]!=top[r])\n\t{\n\t\tif(dep[top[l]]<dep[top[r]])swap(l,r);\n\t\t\n\t\tupdate(1,1,n,id[top[l]],id[l],t);\n\t\t\n\t\tl=fath[top[l]];\n\t}\n\t\n\tif(dep[l]>dep[r])swap(l,r);\n\t\n\tupdate(1,1,n,id[l],id[r],t);\n}\n\nint query2(int u)\n{\n\treturn query(1,1,n,id[u],id[u]+siz[u]-1);\n}\n\nvoid add2(int u,int t)\n{\n\tupdate(1,1,n,id[u],id[u]+siz[u]-1,t);\n}\n\nvoid dfs1(int u,int fa,int deep)\n{\n\tdep[u]=deep;\n\t\n\tfath[u]=fa;\n\t\n\tsiz[u]=1;\n\t\n\tint mson=-1;\n\t\n\tfor(int i=head[u];i;i=a[i].u)\n\t{\n\t\tint v=a[i].v;\n\t\t\n\t\tif(v==fa)continue;\n\t\t\n\t\tdfs1(v,u,deep+1);\n\t\t\n\t\tsiz[u]+=siz[v];\n\t\t\n\t\tif(siz[v]>mson)\n\t\t{\n\t\t\tson[u]=v;\n\t\t\t\n\t\t\tmson=siz[v];\n\t\t}\n\t}\n}\n\nvoid dfs2(int u,int topu)\n{\n\tid[u]=++cnt;\n\t\n\twt[cnt]=w[u];\n\t\n\ttop[u]=topu;\n\t\n\tif(son[u]==0)return;\n\t\n\tdfs2(son[u],topu);\n\t\n\tfor(int i=head[u];i;i=a[i].u)\n\t{\n\t\tint v=a[i].v;\n\t\t\n\t\tif(v==fath[u]||v==son[u])continue;\n\t\t\n\t\tdfs2(v,v);\n\t}\n}\n\nsigned main()//\u4e3b\u7a0b\u5e8f \n{\n\tcin>>n;\n\t\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint x,y;\n\t\t\n\t\tcin>>x;\n\t\t\n\t\tadd(x,i);\n\t\t\n\t\tadd(i,x);\n\t}\n\t\n\tfor(int i=1;i<=n;i++) cin>>w[i];\n\t\n\tdfs1(1,0,1);\n\t\n\tdfs2(1,1);\n\t\n\tbuild(1,1,n);\n\t//cout<<tree[1];\n\tcin>>m;\n\t\n\twhile(m--)\n\t{\n\t\tstring opt;\n\t\t\n\t\tint x,y,z;\n\t\t\n\t\tcin>>opt;\n\t\t\n\t\tif(opt==\"pow\")\n\t\t{\n\t\t\tcin>>x;\n\t\t\t\n\t\t\tadd2(x,1);\n\t\t}\n\t\t\n\t\tif(opt==\"get\")\n\t\t{\n\t\t\tcin>>x;\n\t\t\t\n\t\t\tcout<<query2(x)<<endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n```\n\n",
        "postTime": 1569639408,
        "uid": 174026,
        "name": "\u6b27\u9e70",
        "ccfLevel": 0,
        "title": "CF877E Danil and a Part-time Job"
    },
    {
        "content": "**\u8fd9\u9053\u9898\u6709\u4e24\u4e2a\u64cd\u4f5c\uff0c\u5b50\u6811\u5f02\u6216\uff0c\u5b50\u6811\u67e5\u8be2\u4e00\u7684\u4e2a\u6570\uff0c\u53ef\u4ee5\u7528dfs\u5e8f+\u7ebf\u6bb5\u6811\u89e3\u51b3\uff0c\u5f02\u6216\u6807\u8bb0\u53ef\u4ee5\u901a\u8fc7tag[x]^=1\u6765\u8fdb\u884c\u4f20\u9012\uff0c\u6bcf\u6b21\u66f4\u6539\u76f8\u5f53\u4e8e\u5c06\u533a\u95f4\u5185\u6240\u6709\u76841\u6539\u4e3a0\uff0c\u6240\u6709\u76840\u6539\u4e3a1\uff0c\u8fd9\u6837\u76f8\u5f53\u4e8e\u628asum\u6539\u4e3asize-sum\uff0c\u53ef\u4ee5O(1)\u5b9e\u73b0**\n\n**\u4ee3\u7801\u5982\u4e0b\uff1a**\n```cpp\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lson root<<1\n#define rson root<<1|1\nusing namespace std;\n\nstruct node\n{\n\tint l,r,lazy,sum;\n} tr[800080];\n\nvector<int> g[200020];\nint id[200020],size[200020],c[200020],w[200020],tot;\n\nvoid push_up(int root)\n{\n\ttr[root].sum=tr[lson].sum+tr[rson].sum;\n}\n\nvoid push_down(int root)\n{\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\ttr[lson].sum=(mid-tr[root].l+1)-tr[lson].sum;\n\ttr[lson].lazy=1^tr[lson].lazy;\n\ttr[rson].sum=(tr[root].r-mid)-tr[rson].sum;\n\ttr[rson].lazy=1^tr[rson].lazy;\n\ttr[root].lazy=0;\n}\n\nvoid build(int root,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttr[root].l=l;\n\t\ttr[root].r=r;\n\t\ttr[root].sum=w[l];\n\t\treturn ;\n\t}\n\ttr[root].l=l;\n\ttr[root].r=r;\n\tint mid=(l+r)>>1;\n\tbuild(lson,l,mid);\n\tbuild(rson,mid+1,r);\n\tpush_up(root);\n}\n\nvoid update(int root,int l,int r,int val)\n{\n\tif(tr[root].l==l&&tr[root].r==r)\n\t{\n\t\ttr[root].sum=(tr[root].r-tr[root].l+1)-tr[root].sum;\n\t\ttr[root].lazy=tr[root].lazy^1;\n\t\treturn ;\n\t}\n\tif(tr[root].lazy)\n\t{\n\t\tpush_down(root);\n\t}\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\tif(l>mid)\n\t{\n\t\tupdate(rson,l,r,val);\n\t}\n\telse\n\t{\n\t\tif(mid>=r)\n\t\t{\n\t\t\tupdate(lson,l,r,val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(lson,l,mid,val);\n\t\t\tupdate(rson,mid+1,r,val);\n\t\t}\n\t}\n\tpush_up(root);\n}\n\nint query(int root,int l,int r)\n{\n\tif(tr[root].l==l&&tr[root].r==r)\n\t{\n\t\treturn tr[root].sum;\n\t}\n\tif(tr[root].lazy)\n\t{\n\t\tpush_down(root);\n\t}\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\tif(mid<l)\n\t{\n\t\treturn query(rson,l,r);\n\t}\n\telse\n\t{\n\t\tif(mid>=r)\n\t\t{\n\t\t\treturn query(lson,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn query(lson,l,mid)+query(rson,mid+1,r);\n\t\t}\n\t}\n}\n\nvoid dfs(int now,int f)\n{\n\tid[now]=++tot;\n\tw[tot]=c[now];\n\tsize[now]=1;\n\tfor(int i=0; i<g[now].size(); i++)\n\t{\n\t\tif(g[now][i]==f)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(g[now][i],now);\n\t\tsize[now]+=size[g[now][i]];\n\t}\n}\n\nvoid sub_update(int u,int val)\n{\n\tupdate(1,id[u],id[u]+size[u]-1,val);\n}\n\nint sub_query(int u)\n{\n\treturn query(1,id[u],id[u]+size[u]-1);\n}\n\nint main()\n{\n\tint n,m;\n\tscanf(\"%d\",&n);\n\tfor(int i=2; i<=n; i++)\n\t{\n\t\tint to;\n\t\tscanf(\"%d\",&to);\n\t\tg[to].push_back(i);\n\t\tg[i].push_back(to);\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tscanf(\"%d\",&c[i]);\n\t}\n\tdfs(1,0);\n\tbuild(1,1,n);\n\tscanf(\"%d\",&m);\n\tchar s[10];\n\tint val;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tscanf(\"\\n%s %d\",s,&val);\n\t\tif(s[0]=='g')\n\t\t{\n\t\t\tprintf(\"%d\\n\",sub_query(val));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsub_update(val,1);\n\t\t}\n\t}\n}\n```",
        "postTime": 1525694979,
        "uid": 48740,
        "name": "Styx",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    },
    {
        "content": "\u9898\u610f\uff1a\n\n\u7ed9\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u6bcf\u4e2a\u8282\u70b9\u6709\u4e00\u4e2a\u706f\uff0c\u706f\u53ef\u4eae\u53ef\u706d\u3002\n\n\u7ed9\u51fa $m$ \u4e2a\u64cd\u4f5c\uff0c\u5206\u4e3a\u4e24\u79cd\uff1a\n\n* \u5c06 $x$ \u53ca\u5176\u5b50\u6811\u7684\u706f\u53d8\u6210\u76f8\u53cd\u72b6\u6001\uff08\u4eae\u53d8\u706d\uff0c\u706d\u53d8\u4eae\uff09\uff1b\n* \u7edf\u8ba1 $x$ \u53ca\u5176\u5b50\u6811\u6709\u591a\u5c11\u4e2a\u706f\u662f\u4eae\u7684\u3002\n\n\u9898\u76ee\u8981\u6211\u4eec\u652f\u6301\u5b50\u6811\u5f02\u6216\uff0c\u5b50\u6811\u6c42\u548c\n\n\u8fd9\u7c7b\u5b50\u6811\u95ee\u9898\u53ef\u4ee5\u5f88\u597d\u7684\u7528 $dfs$ \u5e8f\u89e3\u51b3\n\n\u5b50\u6811\u5bf9\u5e94\u7740 $dfs$ \u5e8f\u7684\u4e00\u4e2a\u533a\u95f4\n\n\u533a\u95f4\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u5b8c\u6210\n\n\u8bb0\u5f55 $sz$ \u8868\u793a\u5b50\u6811\u5927\u5c0f\uff0c$v$ \u8868\u793a\u6709\u591a\u5c11\u4e2a\u4eae\n\n\u53d6\u53cd\u5c31\u662f $v = sz - v$\n\n\u5f04\u4e2a\u53d6\u53cd\u6807\u8bb0\u4e0b\u4f20\u5373\u53ef\n\n```cpp\n#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n//#define int long long\n#define rep(i, a, b) for (int i = (a); i <= (b); i++)\n#define per(i, a, b) for (int i = (a); i >= (b); i--)\n#define loop(s, v, it) for (s::iterator it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = e[i].nxt)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, sum) memset(a, sum, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(#x\".in\", \"r\", stdin),freopen(#x\".out\", \"w\", stdout)\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int N = 200010 ;\nconst int INF = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst int MOD = 1000000007 ;\nconst double eps = 1e-7 ;\nvoid print(int x) { cout << x << endl ; exit(0) ; }\nvoid PRINT(string x) { cout << x << endl ; exit(0) ; }\nvoid douout(double x){ printf(\"%lf\\n\", x + 0.0000000001) ; }\n\nchar op[10] ;\nint in[N], out[N], head[N], to[N], on[N] ;\nint n, m, top = 1, tim ;\n\nstruct Edge {\n\tint to, nxt ;\n} e[N << 1] ;\n\nvoid add(int a, int b) {\n\te[++top] = (Edge) {b, head[a]} ;\n\thead[a] = top ;\n}\n\nvoid dfs(int x, int fa) {\n\tin[x] = ++tim ; to[tim] = x ;\n\tcont(i, x) {\n\t\tint to = e[i].to ;\n\t\tif (to == fa) continue ;\n\t\tdfs(to, x) ;\n\t}\n\tout[x] = tim ;\n}\n\nstruct Segtree {\n\tint l, r, v, sz, tag ; // \u591a\u5c11\u5f00\u7740\uff0c\u5b50\u6811\u5927\u5c0f\u4e3a\u591a\u5c11\uff0c\u53d6\u53cd\u6807\u8bb0\n\t#define ls(x) x << 1\n\t#define rs(x) x << 1 | 1\n\t#define l(x) tr[x].l\n\t#define r(x) tr[x].r\n\t#define v(x) tr[x].v\n\t#define sz(x) tr[x].sz\n\t#define tag(x) tr[x].tag\n} tr[N << 2] ;\n\nvoid pushup(int x) {\n\tv(x) = v(ls(x)) + v(rs(x)) ;\n\tsz(x) = sz(ls(x)) + sz(rs(x)) ;\n}\n\nvoid pushdown(int x) {\n\tif (tag(x)) {\n\t\ttag(ls(x)) ^= 1 ;\n\t\ttag(rs(x)) ^= 1 ;\n\t\tv(ls(x)) = sz(ls(x)) - v(ls(x)) ;\n\t\tv(rs(x)) = sz(rs(x)) - v(rs(x)) ;\n\t\ttag(x) = 0 ;\n\t}\n}\n\nvoid build(int x, int l, int r) {\n\tl(x) = l, r(x) = r ;\n\tif (l == r) {\n\t\tv(x) = on[to[l]] ;\n\t\tsz(x) = 1 ;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1 ;\n\tbuild(ls(x), l, mid) ;\n\tbuild(rs(x), mid + 1, r) ;\n\tpushup(x) ;\n}\n\nvoid modify(int x, int l, int r) {\n\tif (l <= l(x) && r(x) <= r) {\n\t\tv(x) = sz(x) - v(x) ;\n\t\ttag(x) ^= 1 ;\n\t\treturn ;\n\t}\n\tpushdown(x) ;\n\tint mid = (l(x) + r(x)) >> 1 ;\n\tif (l <= mid) modify(ls(x), l, r) ;\n\tif (mid < r) modify(rs(x), l, r) ;\n\tpushup(x) ;\n}\n\nint query(int x, int l, int r) {\n\tif (l <= l(x) && r(x) <= r) return v(x) ;\n\tpushdown(x) ;\n\tint mid = (l(x) + r(x)) >> 1, ans = 0 ;\n\tif (l <= mid) ans += query(ls(x), l, r) ;\n\tif (mid < r) ans += query(rs(x), l, r) ;\n\treturn ans ;\n}\n\nsigned main(){\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n - 1) {\n\t\tint x ; scanf(\"%d\", &x) ;\n\t\tadd(x, i + 1) ;\n\t}\n\trep(i, 1, n) scanf(\"%d\", &on[i]) ;\n\tdfs(1, 1) ;\n\tbuild(1, 1, n) ;\n\tscanf(\"%d\", &m) ;\n\twhile (m--) {\n\t\tscanf(\"%s\", op + 1) ; int x ; scanf(\"%d\", &x) ;\n\t\tif (op[1] == 'g') printf(\"%d\\n\", query(1, in[x], out[x])) ;\n\t\telse modify(1, in[x], out[x]) ;\n\t}\n\treturn 0 ;\n}\n\n/*\n\u5199\u4ee3\u7801\u65f6\u8bf7\u6ce8\u610f\uff1a\n\t1.ll\uff1f\u6570\u7ec4\u5927\u5c0f\uff0c\u8fb9\u754c\uff1f\u6570\u636e\u8303\u56f4\uff1f\n\t2.\u7cbe\u5ea6\uff1f\n\t3.\u7279\u5224\uff1f\n\t4.\u81f3\u5c11\u505a\u4e00\u4e9b\n\u601d\u8003\u63d0\u9192\uff1a\n\t1.\u6700\u5927\u503c\u6700\u5c0f->\u4e8c\u5206\uff1f\n\t2.\u53ef\u4ee5\u8d2a\u5fc3\u4e48\uff1f\u4e0d\u884cdp\u53ef\u4ee5\u4e48\n\t3.\u53ef\u4ee5\u4f18\u5316\u4e48\n\t4.\u7ef4\u62a4\u533a\u95f4\u7528\u4ec0\u4e48\u6570\u636e\u7ed3\u6784\uff1f\n\t5.\u7edf\u8ba1\u65b9\u6848\u662f\u7528dp\uff1f\u6a21\u4e86\u4e48\uff1f\n\t6.\u9006\u5411\u601d\u7ef4\uff1f\n*/\n\n\n```\n",
        "postTime": 1550890436,
        "uid": 54900,
        "name": "__Hacheylight__",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF877E \u3010Danil and a Part-time Job\u3011"
    }
]