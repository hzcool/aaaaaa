[
    {
        "content": "\uff08\u5c0f\u6e05\u65b0\u6570\u636e\u7ed3\u6784 \u9002\u5408\u89e3\u538b \uff09 \n\n\u6570\u636e\u8303\u56f4\u4e2d \u5b57\u7b26\u4e32\u957f\u5ea6 $ <= 100 $ \n\n\u53ef\u4ee5\u8003\u8651\u4ece\u8fd9\u4e0a\u9762\u5165\u624b \n\n\u6811\u5256\u4e00\u624b \u4e00\u6761\u91cd\u94fe\u4e0a\u79bb\u7ebf\u8be2\u95ee \u91cd\u94fe\u4e4b\u95f4\u66b4\u529b\u5339\u914d \n\n\u66f4\u5177\u4f53\u7684 \uff1a \n\n\u91cd\u94fe\u4e0a\u7684\u8be2\u95ee\u6807\u8bb0 \u6309\u957f\u5ea6\u5206\u7c7b\u505a \n\n\u5047\u8bbe\u73b0\u5728\u6b63\u5728\u5904\u7406\u957f\u5ea6\u4e3a $l$ \u7684\u8be2\u95ee \n\n\u4e00\u4e2a\u70b9\u7684\u6743\u503c\u5c31\u662f\u5b83\u5411\u4e0a $l$ \u6b65\u5f62\u6210\u5b57\u7b26\u4e32\u7684hash\u503c \n\n\u8be2\u95ee\u5c31\u662f $logn$ \u4e2a\u533a\u95f4\u8be2\u95ee $ ( l , r , s ) $ $l$\u5230$r$\u533a\u95f4\u503c\u4e3a$s$\u7684\u4e2a\u6570 \n\n\u79bb\u6563\u5316\u4e00\u904d \u5dee\u5206\u4e00\u4e0b\u5c31OK\n\n\u7136\u540e\u4f60\u4f1a\u53d1\u73b0\u8fd9\u4e2a\u4e1c\u897f\u5927\u6982\u5e38\u6570\u5927 \u65f6\u95f4\u590d\u6742\u5ea6\u5927\u4e14\u4e11 \u6839\u672c\u4e0d\u60f3\u5199 \uff08 \u9e3d\u9e3d\u4eec\u6559\u6559 /kel \uff09 \n\n\u6211\u4eec\u8003\u8651\u66f4\u7b80\u5355\u7684\u89e3\u6cd5 \n\n\u5bf9\u6811\u5efa $SAM$ \u7ebf\u6bb5\u6811\u7ef4\u62a4$endpos$\u7684$dfn$\u5e8f \n\n\u8be2\u95ee\u4e32\u5339\u914d\u540e \u7528\u6811\u5256\u62c6\u6210\u82e5\u5e72\u4e2a\u8be2\u95ee\n\n\u5728 LCA \u5904\u8dd1\u5339\u914d KMP Hash\u90fd\u53ef\u4ee5 \n\n\u4e4b\u540e\u5c31\u4e0d\u9700\u8981\u4ec0\u4e48 $ S <= 100 $ \u7684\u6761\u4ef6 \n\n\u65f6\u95f4\u590d\u6742\u7684\u662f \u4e24\u4e2a log \u548c \u5b57\u7b26\u96c6\u7684\u957f\u5ea6 \u6bd4\u8f83\u4f18\u79c0 \n\n\uff08 \u5e7f\u4e49 SAM \u5efa\u6811\u662f\u5047\u7684 ? /yiw \u4e0d\u7ba1 \u5b83\u80fd\u591f\u8fc7\u9898 \uff09 \n\n```cpp\n#include<bits/stdc++.h> \n#define rg register \n#define fp( i , x , y ) for( rg int i=(x); i<=(y); ++i ) \n#define fq( i , x , y ) for( rg int i=(y); i>=(x); --i )  \n#define ls lson[k] \n#define rs rson[k] \nusing namespace std ; \nconst int N = 1e5+10 , M = 5e6 , L = 205 ;  \nint kmp[L] ; \nint n , pi[N] , a[N] ;  \nvector <int> v[N] , edge[N] ; \nint in_li[N] , in_tr[N] , top[N] , pre[N] , son[N] , sz[N] , dep[N] , tot1 ; \nstruct sam { \n  int tr[N*3][27] , fail[N*3] , len[N*3] , tot , tot2 ; \n  int rt[N*3] , s[M] , lson[M] , rson[M] ; \n  vector <int> vf[N*3] ; int val[N*3] ;  \n  void prep( ) { tot = pi[1] = 1 ; tot2 = 0 ; }  \n  void ins( int ax , int las , int x ) { \n    int u = ++tot , p = las ;  \n    len[u] = len[las] + 1 ; \n    for( ; p && !tr[p][x] ; p = fail[p] ) tr[p][x] = u ; \n    if( !p ) fail[u] = 1 ; \n    else { \n      int q = tr[p][x] ;  \n      if( len[q] == len[p] + 1 ) fail[u] = q ; \n\t  else { \n\t    int cq = ++tot ; \n\t    fail[cq] = fail[q] ; len[cq] = len[p] + 1 ; \n\t    fail[u] = fail[q] = cq ; \n\t    memcpy( tr[cq] , tr[q] , sizeof(tr[cq]) ) ; \n\t    for( ; p && tr[p][x] == q ; p = fail[p] ) tr[p][x] = cq ;  \n\t  } \n\t} \n\tpi[ax] = u ; val[u] = ax ; \n  } \n  void upd( int &k , int l , int r , int x ) { \n    int tk = ++tot2 ; \n\tlson[tk] = ls ; rson[tk] = rs ; k = tk ; \n    if( l == r ) { s[k] = 1 ; return ; } \n    int mid=l+r>>1 ; \n    if( x<=mid ) upd( ls , l , mid , x ) ; \n    else upd( rs , mid+1 , r , x ) ; \n    s[k] = s[ls] + s[rs] ; \n  } \n  int merge( int x , int y ) { \n    if( !x || !y ) return x + y ; \n\tint k = ++tot2 ; \n\tls = merge( lson[x] , lson[y] ) ; \n\trs = merge( rson[x] , rson[y] ) ; \n\ts[k] = s[ls] + s[rs] ; return k ; \n  } \n  int query( int k , int l , int r , int x , int y ) { \n    if( !k || x > y ) return 0 ; \n    if( x <= l && r <= y ) return s[k] ; \n    int mid=l+r>>1 , tp=0 ; \n    if( x<=mid ) tp += query( ls , l , mid , x , y ) ; \n    if( mid<y ) tp += query( rs , mid+1 , r , x , y ) ; \n    return tp ; \n  } \n  void dfs( int x ) { \n    int l = vf[x].size() , y ; \n    fp( i , 0 , l-1 ) { \n      y = vf[x][i] ; dfs( y ) ; \n      rt[x] = merge( rt[x] , rt[y] ) ; \n\t} \n\tif( val[x] ) upd( rt[x] , 1 , n , in_li[val[x]] ) ;  \n  } \n  void build( ) { \n    fp( i , 1 , tot ) vf[fail[i]].push_back(i) ; dfs( 1 ) ; \n  } \n} sa ; \nvoid add( int x , int y , int z ) { \n  v[x].push_back(y) ; edge[x].push_back(z) ; \n} \nvoid dfs1( int x , int _fa ) { \n  pre[x] = _fa ; \n  sz[x] = 1 ; \n  dep[x] = dep[_fa] + 1 ; \n  int l = v[x].size() , y , z ;  \n  fp( i , 0 , l-1 ) { \n    y = v[x][i] ; z = edge[x][i] ; \n    if( y == _fa ) continue ; \n    a[y] = z ; sa.ins( y , pi[x] , z ) ; \n    dfs1( y , x ) ;   \n    sz[x] += sz[y] ; \n    if( sz[son[x]] < sz[y] ) \n      son[x] = y ; \n  } \n} \nvoid dfs2( int x ) { \n  if( son[x] ) { \n    in_li[son[x]] = ++tot1 ; \n    in_tr[tot1] = son[x] ; \n    top[son[x]] = top[x] ; \n    dfs2( son[x] ) ; \n  } \n  int l = v[x].size() , y ; \n  fp( i , 0 , l-1 ) { \n    y = v[x][i] ; \n    if( y == pre[x] || y == son[x] ) continue ; \n\tin_li[y] = ++tot1 ; \n\tin_tr[tot1] = y ; top[y] = y ; \n\tdfs2( y ) ;  \n  } \n} \nint lca( int x , int y ) { \n  int fx = top[x] , fy = top[y] ; \n  while( fx != fy ) { \n    if( dep[fx] < dep[fy] ) swap( x , y ) , swap( fx , fy ) ; \n    x = pre[fx] ; fx = top[x] ; \n  }  \n  return ( dep[x] < dep[y] ? x : y ) ; \n} \nint ask_d( int x , int z , int d ) { \n  if( dep[x] - dep[z] + 1 <= d ) return -1 ; \n  int fx = top[x] ; \n  while( fx != top[z] ) {  \n    if( dep[fx] <= d + dep[z] ) break ; \n    x = pre[fx] ; fx = top[x] ; \n  } \n  return in_tr[ in_li[fx] + (d-dep[fx]+dep[z]) ] ; \n} \nint ask( int x , int z , int p ) { \n  if( z == -1 ) return 0 ;  \n  int fx = top[x] , ans = 0 ;  \n  while( fx != top[z] ) { \n    ans += sa.query( p , 1 , n , in_li[fx] , in_li[x] ) ; \n\tx = pre[fx] ; fx = top[x] ;  \n  } \n  ans += sa.query( p , 1 , n , in_li[z] , in_li[x] ) ; \n  return ans ; \n} \nsigned main( ) { \n  ios::sync_with_stdio(false) ; \n  cin.tie(0) ; \n  cin >> n ; \n  int x , y ; string z , tp , tp1 , tp2 ;  \n  fp( i , 1 , n-1 ) { \n    cin >> x >> y >> z ; \n    add( x , y , z[0]-'a' ) ; add( y , x , z[0]-'a' ) ; \n  } \n  sa.prep( ) ; \n  dfs1( 1 , 0 ) ; \n  in_li[1] = in_tr[1] = top[1] = tot1 = 1 ; \n  dfs2( 1 ) ; \n  sa.build( ) ; \n  int q ; cin >> q ; \n  while( q -- ) { \n    cin >> x >> y >> z ; \n    int ans = 0 , l1 = z.length() , c = lca( x , y ) ; \n    int fx = ask_d( x , c , l1 ) , fy = ask_d( y , c , l1 ) ; \n    int px = 1 , py = 1 ; \n    fq( i , 0 , l1-1 ) px = sa.tr[px][z[i]-'a'] ; \n    fp( i , 0 , l1-1 ) py = sa.tr[py][z[i]-'a'] ; \n\tans = ask( x , fx , sa.rt[px] ) + ask( y , fy , sa.rt[py] ) ; \n\tx = ( fx == -1 ? x : pre[fx] ) ; y = ( fy == -1 ? y : pre[fy] ) ; \n\ttp1 = \"\" ; tp2 = \"\" ; \n\tfor( ; x != c ; x = pre[x] ) tp1 += (char)(a[x]+'a'); \n\tfor( ; y != c ; y = pre[y] ) tp2 += (char)(a[y]+'a') ; \n\tint l2 = tp2.length() ; \n\tfp( i , 1 , l2/2 ) swap( tp2[i-1] , tp2[l2-i] ) ; \n\ttp = tp1 + tp2 ; int tl = tp.length() ; \n\ttp = \" \" + tp ; z = \" \" + z ; \n\tint j = 0 ; \n\tfp( i , 2 , l1 ) { \n\t  while( j && z[j+1] != z[i] ) j = kmp[j] ; \n\t  if( z[j+1] == z[i] ) j ++ ; kmp[i] = j ;    \n\t} \n\tj = 0 ; \n\tfp( i , 1 , tl ) { \n\t  while( j && z[j+1] != tp[i] ) j = kmp[j] ; \n\t  if( z[j+1] == tp[i] ) j ++ ; \n\t  if( j == l1 ) { ans ++ ; j = kmp[j] ; }  \n\t} \n\tcout << ans << '\\n' ; \n  } \n  return 0 ; \n} \n```\n",
        "postTime": 1611142700,
        "uid": 100114,
        "name": "hater",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1045J \u3010Moonwalk challenge\u3011"
    }
]