[
    {
        "content": "[\u9898\u76ee\u94fe\u63a5 CF1037H Security](https://www.luogu.com.cn/problem/CF1037H)\n\n\u505a\u6cd5\uff1aSAM\uff0c\u7ebf\u6bb5\u6811\uff08\u4e0d\u7528\u5408\u5e76\uff09\n\n## \u9898\u610f\u7b80\u8ff0\n\n&emsp;&emsp;\u7ed9\u51fa\u4e00\u4e2a\u6587\u672c\u4e32 $S$ \uff0c\u6709 $Q$ \u6b21\u8be2\u95ee\uff0c\u6bcf\u6b21\u8be2\u95ee\u7ed9\u51fa\u6a21\u5f0f\u4e32 $T$ \uff0c\u95ee\u5728 $S$ \u4e32\u4e2d $[l,r]$ \u533a\u95f4\u4e0a\u662f\u5426\u5b58\u5728\u6bd4 $T$ \u7684\u5b57\u5178\u5e8f\u5927\u7684\u5b50\u4e32\uff0c\u5982\u679c\u5b58\u5728\u8f93\u51fa\u5176\u4e2d\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u90a3\u4e2a\u5b50\u4e32\uff0c\u5426\u5219\u8f93\u51fa $-1$ \u3002$1\\le l\\le r \\le|S|\\le10^5,1\\le Q,\\sum|T|\\le 2\\times 10^5$ \u3002\n\n##  \u8d2a\u5fc3\u5206\u6790\n\n&emsp;&emsp;\u9996\u5148\u8003\u8651\u600e\u4e48\u6c42\u6700\u5c0f\u7684\u6bd4 $T$ \u5b57\u5178\u5e8f\u5927\u7684\u4e32\uff0c\u4e0d\u8003\u8651\u533a\u95f4\u9650\u5236\u3002\u8bbe\u5f53\u524d $T$ \u5728 $S$ \u4e0a\u6700\u5927\u5339\u914d\u957f\u5ea6\u4e3a $len$ \u3002\n\n- $len = |T|$ \uff0c\u5219\u5728 $T$ \u4e32\u540e\u62fc\u4e0a\u4e00\u4e2a\u5b57\u7b26 $c$ \u80af\u5b9a\u6bd4 $T$ \u5b57\u5178\u5e8f\u8981\u5927\uff0c\u6211\u4eec\u53ea\u9700\u5728 $S$ \u4e32\u4e2d\u627e\u5230\u4e00\u4e2a\u4e32\u4e3a $T+c$ ,\u5e76\u4f7f $c$ \u6700\u5c0f\u5373\u53ef\u3002\n- \u5426\u5219\uff0c$T[1,len]$ \u4e0a\u4e0e $S$ \u5339\u914d\uff0c\u4f46\u662f $T[1,len+1]$ \u4e0d\u5339\u914d\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u627e\u5230\u4e00\u4e2a\u6700\u5c0f\u5b57\u7b26 $c$\uff0c\u6ee1\u8db3 $c>T[len+1]$ \u4e14 $T[1,len]+c$ \u4e3a $S$ \u7684\u5b50\u4e32\uff0c\u90a3\u4e48 $T[1,len]+c$ \u5c31\u662f\u7b54\u6848\u4e86\u3002\u5982\u679c\u6ca1\u627e\u5230\u8fd9\u6837\u7684 $c$ ,\u5c06\u5339\u914d\u957f\u5ea6\u51cf\u4e00\uff0c\u91cd\u590d\u8fdb\u884c\u8fd9\u4e2a\u64cd\u4f5c\u3002\n- $len=0$ \u4e5f\u627e\u4e0d\u5230\u8fd9\u6837\u7684 $c$ ,\u53ea\u80fd\u8f93\u51fa $-1$ \u3002\n\n&emsp;&emsp;\u53ef\u4ee5\u7528\u53cd\u8bc1\u6cd5\u8bc1\u660e\u8fd9\u79cd\u6784\u9020\u65b9\u6cd5\u5f97\u5230\u7684\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\u6bd4 $T$ \u5b57\u5178\u5e8f\u5927\u7684\u4e32\u3002\u800c\u8981\u60f3\u77e5\u9053 $+c$ \u540e\u662f\u5426\u662f $S$ \u7684\u5b50\u4e32\uff08\u5373\u662f\u5426\u5b58\u5728\u5230 $c$ \u7684\u8f6c\u79fb\uff09\uff0c\u7528 SAM \u5c31\u597d\u5566\u3002\n\n## \u7ebf\u6bb5\u6811\u7ef4\u62a4\u4e8c\u7ef4\u504f\u5e8f\n\n&emsp;&emsp;\u8003\u8651\u600e\u4e48\u5b9e\u73b0\u533a\u95f4\u9650\u5236\u3002\u6211\u4eec\u60f3\u77e5\u9053 $S[l,r]$ \u4e0a\u662f\u5426\u80fd\u5339\u914d\u5b50\u4e32\uff0c\u81ea\u7136\u4e0d\u80fd\u6bcf\u4e2a\u533a\u95f4\u90fd\u5efa\u7acb\u4e00\u4e2a SAM\u3002\u6211\u4eec\u8981\u5728\u539f $S$ \u7684 SAM \u4e2d\u5224\u65ad\u5f53\u524d\u5339\u914d\u5230\u7684\u72b6\u6001\uff0c\u662f\u5426\u80fd\u88ab $[l,r]$ \u5b8c\u6574\u5305\u542b\u3002\u4e00\u4e2a\u72b6\u6001\u662f\u4e00\u4e9b\u5b50\u4e32\u7684\u7ed3\u675f\u4f4d\u7f6e\u7684\u96c6\u5408\uff0c\u5982\u679c\u5b58\u5728\u4e00\u4e2a\u7ed3\u675f\u4f4d\u7f6e $maxPos$ \uff0c\u6ee1\u8db3 $l \\le maxPos-len+1,maxPos\\le r$\uff0c\uff08$len$ \u4e3a\u5b50\u4e32\u957f\u5ea6\uff09\uff0c\u5219\u8bf4\u660e\u5728 $[l,r]$ \u533a\u95f4\u4e0a\u6709\u8be5\u5b50\u4e32\u3002\n\n&emsp;&emsp;\u89c2\u5bdf\u5230\u5982\u679c $r$ \u56fa\u5b9a\uff0c\u4f7f\u5f97\u6240\u6709\u7ed3\u675f\u4f4d\u7f6e\u90fd\u5c0f\u4e8e $r$ \uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8003\u8651  $l \\le maxPos-len+1$ \u90e8\u5206\u7684\u9650\u5236\u5373\u53ef\u3002 $maxPos$ \u8d8a\u5927\uff0c$maxPos-len+1$ \u8d8a\u5927\uff0c\u6ee1\u8db3\u5355\u8c03\u6027\uff0c\u6211\u4eec\u53ea\u9700\u628a\u4e00\u4e2a\u72b6\u6001\u7684\u6700\u5927\u7684\u7ed3\u675f\u4f4d\u7f6e\u627e\u51fa\u6765\u4f5c\u5224\u65ad\u5373\u53ef\u3002\u8fd9\u5c31\u662f\u7ecf\u5178\u7684\u4e8c\u7ef4\u504f\u5e8f\u95ee\u9898\u4e86\u3002\u6211\u4eec\u5148\u5c06\u8be2\u95ee\u6309\u7167\u53f3\u7aef\u70b9\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u5c06 $S[1,r]$ \u7684\u4f4d\u7f6e\u503c\u8fdb\u7ebf\u6bb5\u6811\uff0c\u8fd9\u6837\u627e\u6700\u5927\u7ed3\u675f\u4f4d\u7f6e\u65f6\u4fdd\u8bc1\u4e00\u5b9a\u662f\u6ee1\u8db3 $maxPos\\le r$ \u7684\u3002\n\n```c++\n    //\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u5c0f\u7684\u5728\u524d\n    sort(ques + 1, ques + 1 + n);\n    for(int i = 1,r = 1;i <= n;i++){\n        //\u504f\u5e8f\uff1a\u8ba9\u7ebf\u6bb5\u6811\u53ea\u7ef4\u62a4S\u4e32\u4e2d\u7684[1,ques[i].r],\u8fd9\u6837\u5728check\u67e5\u8be2\u65f6\u53ea\u9700\u5224\u65ad\u662f\u5426\u5927\u4e8e\u5de6\u7aef\u70b9ques[i].l\u5373\u53ef\n        for(; r <= ques[i].r; r ++)\n            update(1, 1, dfs_cnt, dfn[id[r]], r);\n        match_t(1, i, 1, ques[i].id);\n    }\n```\n\n&emsp;&emsp;\u8fd9\u91cc\u7ebf\u6bb5\u6811\u662f\u5efa\u7acb\u5728 SAM \u7684 parent \u6811\u7684 dfs \u5e8f\u4e0a\u7684\uff0c\u67e5\u8be2\u4e00\u4e2a\u72b6\u6001\u6240\u6709\u7ed3\u675f\u4f4d\u7f6e\u7684\u6700\u5927\u503c \u5373 \u67e5\u8be2\u5b83\u7684\u5b50\u6811\u4e0a\u6240\u6709\u72b6\u6001\u7684\u7ed3\u675f\u4f4d\u7f6e\u7684\u6700\u5927\u503c\u3002\u628a\u5b50\u6811\u8f6c\u5316\u4e3a\u4e00\u6bb5\u533a\u95f4\uff0c\u5c31\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u53cb\u597d\u5730\u8fdb\u884c\u533a\u95f4\u64cd\u4f5c\u4e86\u3002$id[i]$ \u662f\u4e00\u4e2a\u5e8f\u5217\u4e0b\u6807\u5230 SAM \u4e0a\u72b6\u6001\u7684\u6620\u5c04\u3002\u7136\u540e\u5c31\u662f\u5339\u914d\u8fc7\u7a0b\u4e86\uff0c\u770b\u5b8c\u6574\u4ee3\u7801\u5427~\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\n#define ls (now<<1)\n#define rs (now<<1)+1\n#define mid (l+r)/2\ntypedef long long ll;\nconst int N = 1e6+6;\nconst int M = 2e5+6;\nint n,dfn[N],high[N],dfs_cnt,mx[N << 1],id[N];\nint nxt[N][26],link[N],len[N],cnt = 1,las = 1;\nbool flag[N] = {0};\nstring ans[M];\nchar s[N],t[N],*inputT = t;\nvector<int>a[N];\n\nstruct node{\n    int l,r,id,len;\n    char *t;\n    bool operator<(const node &y )const{return r<y.r;}\n}ques[N];\n\nvoid insert(int c,int o){\n    int cur = ++cnt,p = las;\n    len[cur] = len[las] + 1;\n    las = cur;\n    id[o] = cur;\n    for(; p && !nxt[p][c] ; p = link[p])\n        nxt[p][c] = cur;\n    if(!p) link[cur] = 1;\n    else{\n        int q = nxt[p][c];\n        if(len[q] == len[p] + 1) link[cur] = q;\n        else{\n            int clone = ++cnt;\n            len[clone] = len[p] + 1;\n            link[clone] = link[q];\n            link[q] = link[cur] = clone;\n            memcpy(nxt[clone],nxt[q],sizeof(nxt[q]));\n            for(; nxt[p][c] == q;p = link[p])\n                nxt[p][c] = clone;\n        }\n    }\n}\n\n//\u6c42dfs\u5e8f\uff0cnow\u5b50\u6811\u8303\u56f4[dfn[now],high[now]]\nvoid dfs(int now){\n    dfn[now] = ++dfs_cnt;\n    for(auto to:a[now]) dfs(to);\n    high[now] = dfs_cnt;\n}\n\n//\u666e\u901a\u7ebf\u6bb5\u6811\u6c42\u533a\u95f4\u6700\u5927\u503c\nvoid update(int now,int l,int r,int x,int v){\n    if(l == r) {mx[now] = max(mx[now],v);return;}\n    if(x <= mid) update(ls,l,mid,x,v);\n    else update(rs,mid+1,r,x,v);\n    mx[now] = max(mx[ls],mx[rs]);\n}\n\nint query(int now,int l,int r,int x,int y){\n    if(x <= l && r <= y) return mx[now];\n    int an = 0;\n    if(x <= mid) an = query(ls,l,mid,x,y);\n    if(y > mid) an = max(an,query(rs,mid+1,r,x,y));\n    return an;\n}\n\n//\u67e5\u8be2\u5728now\u8282\u70b9\u5728SAM\u4e0a\u7684endpos\u96c6\u5408\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u70b9maxPos\u88ab[l,r]\u5b8c\u6574\u5305\u542b\n//\u56e0\u4e3a\u7ebf\u6bb5\u6811\u4e0a\u8282\u70b9\u90fd\u662f\u5c0f\u4e8er\u7684\uff0c\u6240\u4ee5\u53ea\u8981\u6ee1\u8db3maxPos-match_len+1 >= l,\u5373\u8bf4\u660e\u4ee5maxPos\u7ed3\u5c3e\uff0c\u957f\u5ea6\u4e3amatch_len\u7684\u4e32\u5728S\u4e32\u7684[l,r]\u4e2d\u5b8c\u6574\u51fa\u73b0\n//\u5229\u7528\u7ebf\u6bb5\u6811O(lgn)\u67e5\u8be2now\u5b50\u6811\u4e0a\uff08\u5728dfs\u5e8f\u4e2d\u662f\u4e00\u6bb5\u533a\u95f4\uff09\u7684S\u4e32\u4f4d\u7f6e\u7684\u6700\u5927\u503cmaxPos\nbool check(int l,int now,int match_len){\n    int maxPos = query(1, 1, dfs_cnt, dfn[now], high[now]);\n    if(maxPos - match_len + 1 >= l) return true;\n    else return false;\n}\n\n//now\uff1a\u5f53\u524dt\u4e32\u5df2\u7ecf\u5728SAM\u5339\u914d\u7684\u8282\u70b9\uff0co\uff1a\u67e5\u8be2\u5e8f\u53f7\uff0cindex:\u5f53\u524d\u8981\u5c1d\u8bd5\u5339\u914d\u7684t\u4e32\u7684\u4e0b\u6807\uff0cans_id\u79bb\u7ebf\u7684\u7b54\u6848\u7f16\u53f7\nbool match_t(int now,int o,int index,int ans_id){\n    //\u5982\u679c\u5df2\u7ecf\u5339\u914d\u5230t\u4e32\u672b\u5c3e\uff0c\u5c1d\u8bd5\u5728\u5176\u540e\u653e\u4e00\u4e2a\u5b57\u7b26\uff0c\u5982\u679c\u6210\u529f\u5c31\u80fd\u4e0et\u4e32\u62fc\u6210\u4e00\u4e2a\u6bd4t\u4e32\u5b57\u5178\u5e8f\u5927\u7684\u4e32\n    if(ques[o].len < index){\n        for(int i = 0;i < 26;i++)\n            if(nxt[now][i] && check(ques[o].l, nxt[now][i], index)){\n                flag[ans_id] = 1;         //flag\u6807\u8bb0\u65f6\u5019\u5df2\u627e\u5230\u4e00\u4e2a\u6bd4t\u4e32\u5b57\u5178\u5e8f\u5927\u7684\u4e32\n                ans[ans_id] += 'a'+ i;\n                return true;\n            }\n        return false;       //\u6ca1\u62fc\u6210\n    }\n    int c = ques[o].t[index] - 'a';\n    int next = nxt[now][c];\n    //\u5982\u679c\u5339\u914d\u4e0a\u4e86\uff0c\u5e76\u4e14\u4e5f\u88ab[l,r]\u533a\u95f4\u5305\u542b\u4e86\uff0c\u5728\u540e\u9762\u7684\u5339\u914d\u4e2d\u4e5f\u627e\u5230\u4e86\u6bd4t\u4e32\u5b57\u5178\u5e8f\u5927\u7684\u4e32\uff0c\u8fd9\u91cc\u5c31\u62fc\u4e0a\u4e0et\u4e32\u5339\u914d\u7684\u4e32\u5373\u53ef\n    if(next && check(ques[o].l, next, index) && match_t(next,o,index + 1,ans_id)){\n        ans[ans_id] += 'a' + c;\n        return true;\n    }\n    //\u5426\u5219\uff0c\u5982\u679c\u80fd\u62fc\u4e0a\u4e00\u4e2a\u6bd4c\u5927\u7684\u5b57\u7b26\uff0c\u4e00\u5b9a\u4e5f\u53ef\u4ee5\u5f97\u5230\u4e00\u4e2a\u6bd4t\u4e32\u5b57\u5178\u5e8f\u5927\u7684\u4e32\n    else{\n        for(int i = c + 1;i < 26;i++)\n            if(nxt[now][i] && check(ques[o].l, nxt[now][i], index)){\n                flag[ans_id] = 1;\n                ans[ans_id] += 'a'+ i;\n                return true;\n            }\n        return false;\n    }\n}\n\nint main(){\n    scanf(\"%s\",s+1);\n    int lens = strlen(s+1);\n    //\u5efaSAM\n    for(int i = 1;i <= lens;i++) insert(s[i]-'a',i);\n\n    //parent\u6811\u8fde\u8fb9\uff0c\u5efa\u7acbdfs\u5e8f\n    for(int i = 1;i <= cnt;i++) a[link[i]].push_back(i);\n    dfs(1);\n\n    scanf(\"%d\",&n);\n    //\u7528inputT\u6307\u9488\u4e32\u8054\u8d77\u5b57\u7b26\u4e32\uff0c\u9632\u6b62\u5f00\u591a\u4e2a\u5b57\u7b26\u4e32\u7206\u5185\u5b58\n    for(int i = 1;i <= n;i++){\n        scanf(\"%d %d %s\", &ques[i].l, &ques[i].r, inputT + 1);\n        ques[i].t = inputT;\n        ques[i].id = i;\n        ques[i].len = strlen(ques[i].t + 1);\n        inputT += ques[i].len + 1;\n    }\n    //\u6309\u7167\u53f3\u7aef\u70b9\u6392\u5e8f\uff0c\u5c0f\u7684\u5728\u524d\n    sort(ques + 1, ques + 1 + n);\n    for(int i = 1,r = 1;i <= n;i++){\n        //\u504f\u5e8f\uff1a\u8ba9\u7ebf\u6bb5\u6811\u53ea\u7ef4\u62a4S\u4e32\u4e2d\u7684[1,ques[i].r],\u8fd9\u6837\u5728check\u67e5\u8be2\u65f6\u53ea\u9700\u5224\u65ad\u662f\u5426\u5927\u4e8e\u5de6\u7aef\u70b9ques[i].l\u5373\u53ef\n        for(; r <= ques[i].r; r ++)\n            update(1, 1, dfs_cnt, dfn[id[r]], r);\n        match_t(1, i, 1, ques[i].id);\n    }\n\n    for(int i = 1;i <= n;i++) {\n        if(!flag[i]) printf(\"-1\\n\");\n        else{\n            //\u5012\u5e8f\u8f93\u51fa\u5b57\u7b26\u4e32\n            int l = ans[i].size();\n            for(int j = l - 1;j >= 0;j-- )\n                printf(\"%c\",ans[i][j]);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n\n```\n\n&emsp;&emsp;\u8fd9\u9898\u548c [P4770 [NOI2018] \u4f60\u7684\u540d\u5b57](https://www.luogu.com.cn/problem/P4770) \u505a\u6cd5\u5176\u5b9e\u662f\u5dee\u4e0d\u591a\u7684\uff0c\u4f46\u662f\u7531\u4e8e\u6211\u4e0d\u4f1a\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u90fd\u53ea\u4f1a\u7528\u4e00\u9897\u7ebf\u6bb5\u6811\u89e3\u51b3(\u00b0\u30fc\u00b0\u3003)\uff0c\u90a3\u65f6\u6211\u662f\u770b [\u8fd9\u4e2a\u9898\u89e3](https://www.luogu.com.cn/blog/van/solution-p4770) \u505a\u7684\u9898\uff0c\u5728\u8fd9\u91cc\u53c8\u7528\u4e0a\u4e86\uff0c\u505a\u5b8c\u8fd9\u9898\u53ef\u4ee5\u53bb\u6311\u6218\u300a\u4f60\u7684\u540d\u5b57\u300b\u5566\u3002\n\n[\u6b22\u8fce\u5230\u6211\u535a\u5ba2\u4e0a\u770b](https://www.cnblogs.com/ailanxier/p/14216115.html)\n\n",
        "postTime": 1609393726,
        "uid": 281293,
        "name": "ailanxier",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "[$\\tt{My\\ blog}$](https://ctz45562.github.io/2019/04/28/\u6d1b\u8c37-CF1037H-Security)\n\n[\u4f20\u9001\u95e8](https://www.luogu.org/problemnew/show/CF1037H)\n\n~~\u8bf4\u5b9e\u8bdd\u505a\u8fd9\u4e2a\u9898\u4e4b\u524d\u6211\u90fd\u4e0d\u77e5\u9053CF\u6709H\u9898~~\n\n\n\u5b57\u5178\u5e8f\u5c3d\u91cf\u5c0f\u53c8\u8981\u4e25\u683c\u5927\u4e8e\u6a21\u5f0f\u4e32\uff0c\u8bb0\u6a21\u5f0f\u4e32\u4e3a$S$\uff0c\u5219\u8d2a\u5fc3\u8ba9\u524d\u9762\u6700\u591a\u7684\u5b57\u7b26\u548c$S$\u76f8\u540c\uff0c\u5728\u540e\u9762\u518d\u8865\u4e00\u4e2a\u6bd4$S$\u5927\u4e14\u6700\u5c0f\u7684\u5b57\u7b26\u3002\n\n\u5219\u6700\u4f18\u7684\u65b9\u6848\u4e00\u5b9a\u662f\u5728$S$\u540e\u9762\u8865\u4e00\u4e2a\u5c3d\u53ef\u80fd\u5c0f\u7684\u5b57\u7b26\u3002\u5982\u679c\u8865\u4e0d\u4e86\uff0c\u5c31\u5012\u7740\u679a\u4e3e\u4f4d\u7f6e\uff0c\u5982\u679c\u5f53\u524d\u4f4d\u7f6e$i$\u80fd\u66ff\u6362\u4e3a\u4e00\u4e2a\u6bd4$S_i$\u5927\u7684\u5b57\u7b26\uff0c\u627e\u5230\u6700\u5c0f\u7684\u53ef\u66ff\u6362\u5b57\u7b26$c$\u6362\u6389\u5b83\u3002\u7b54\u6848\u5c31\u662f$S(1\\sim i-1)+'c'$\u3002\n\n\u4ee5\u4e0b\u7528\u201c\u597d\u70b9\u201d\u8868\u793a\u5305\u542b$[L,R]$\u5b50\u4e32\u7684\u8282\u70b9\u3002\n\n\u5148\u628a\u6bcd\u4e32\u7684$SAM$\u9020\u51fa\u6765\u3002\n\n\u5bf9\u6bcf\u4e2a\u6a21\u5f0f\u4e32\uff0c\u627e\u51fa\u4ec5\u8d70\u201c\u597d\u70b9\u201d\uff0c\u80fd\u5339\u914d\u7684\u6700\u5927\u957f\u5ea6$max\\_len$\u3002\u540c\u65f6\u627e\u51fa\u6bcf\u4e2a\u4f4d\u7f6e$i$\u6700\u5c0f\u7684\u5b57\u7b26$nex$\uff0c\u6ee1\u8db3$c>S_i$\u4e14\u4ece$i-1$\u5339\u914d\u7684\u8282\u70b9\u8d70$nex$\u8fb9\u7684\u513f\u5b50\u4e3a\u201c\u597d\u70b9\u201d\uff08\u6ca1\u6709\u4e3a$-1$\u3002\n\n\u4ece$max\\_len$\u5012\u7740\u679a\u4e3e\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u4e0d\u4e3a$-1$\u7684\u4f4d\u7f6e$i$\uff0c$S(1\\sim i-1)+nex_i$\u5373\u4e3a\u7b54\u6848\u3002\n\n\u81f3\u4e8e\u600e\u4e48\u5224\u65ad\u4e00\u4e2a\u8282\u70b9\u662f\u5426\u4e3a\u201c\u597d\u70b9\u201d\uff0c\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u83b7\u53d6\u6bcf\u4e2a\u8282\u70b9$endpos$\u7684\u6240\u6709\u5143\u7d20\u3002\u5047\u8bbe\u5f53\u524d\u8d70\u5230\u7684\u957f\u5ea6\u4e3a$i$\uff0c$endpos$\u4e2d\u5b58\u5728$pos$\u6ee1\u8db3$pos\\in [L,R]$\u4e14$pos-i+1\\in [L,R]$\u7684\u8282\u70b9\u4e3a\u201c\u597d\u70b9\u201d\u3002\u5408\u8d77\u6765\u5c31\u662f$pos\\in [L+i-1,R]$\u3002\n\n\u7a7a\u95f4$O(n\\log n)$\uff0c\u65f6\u95f4$O(26n\\log n)$\uff08\u5b9e\u9645\u60c5\u51b5\u8fdc\u8dd1\u4e0d\u6ee1\uff09\n\n\u4ee3\u7801\uff1a\n\n``` cpp\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n\n#define maxn 400005\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\ninline int read(){\n\tint x=0,y=0;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')y=1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn y?-x:x;\n}\n#define son(x,y) son[x][y]\n#define ls(x) ls[x]\n#define rs(x) rs[x]\nint h[maxn],root[maxn],ls[maxn<<5],rs[maxn<<5],all,num;\nint son[maxn][26],len[maxn],fa[maxn],nex[maxn],last=1,cnt=1,n,N;\nchar s[maxn];\nstruct edge{\n\tint pre,to;\n}e[maxn];\ninline void add(int from,int to){\n\te[++num].pre=h[from],h[from]=num,e[num].to=to;\n}\nvoid modify(int poi,int l,int r,int &node){\n\tnode=++all;\n\tif(l==r)return;\n\tint mid=l+r>>1;\n\tif(poi<=mid)modify(poi,l,mid,ls(node));\n\telse modify(poi,mid+1,r,rs(node));\t\n}\nint merge(int x,int y,int l,int r){\n\tif(!x||!y||l==r)return x|y;\n\tint ne=++all,mid=l+r>>1;\n\tls(ne)=merge(ls(x),ls(y),l,mid);\n\trs(ne)=merge(rs(x),rs(y),mid+1,r);\n\treturn ne;\n}\nbool ask(int L,int R,int l,int r,int node){\n\tif(!node)return 0;\n\tif(L<=l&&R>=r)return 1;\n\tint mid=l+r>>1;\n\tif(L<=mid&&ask(L,R,l,mid,ls(node)))return 1;\n\tif(R>mid&&ask(L,R,mid+1,r,rs(node)))return 1;\n\treturn 0;\n}//\u5bfb\u5473endpos\u5728[L,R]\u4e2d\u662f\u5426\u6709\u5143\u7d20\nvoid insert(int c){\n\tint p=last,ne=last=++cnt;\n\tmodify(len[ne]=len[p]+1,1,N,root[ne]);\n\twhile(p&&!son(p,c))son(p,c)=ne,p=fa[p];\n\tif(!p)fa[ne]=1;\n\telse {\n\t\tint q=son(p,c);\n\t\tif(len[q]==len[p]+1)fa[ne]=q;\n\t\telse {\n\t\t\tint sp=++cnt;\n\t\t\tmemcpy(son[sp],son[q],sizeof son[q]);\n\t\t\tfa[sp]=fa[q],len[sp]=len[p]+1,fa[q]=fa[ne]=sp;\n\t\t\twhile(p&&son(p,c)==q)son(p,c)=sp,p=fa[p];\n\t\t}\n\t}\n}\nvoid dfs(int node=1){\n\tint x;\n\tfor(register int i=h[node];i;i=e[i].pre)\n\t\tx=e[i].to,dfs(x),root[node]=merge(root[node],root[x],1,N);\n}//\u6c42endpos\u96c6\u5408\nint main(){\n\tscanf(\"%s\",s+1),N=strlen(s+1);\n\tfor(register int i=1;i<=N;++i)insert(s[i]-'a');\n\tfor(register int i=2;i<=cnt;++i)add(fa[i],i);\n\tdfs();\n\tint m=read(),l,r,node,x,i;\n\twhile(m--){\n\t\tl=read(),r=read(),node=1;\n\t\tscanf(\"%s\",s+1),n=strlen(s+1);\n\t\tfor(i=1;;++i){\n\t\t\tnex[i]=-1;\n\t\t\tfor(register int j=max(s[i]-'a'+1,0);j<26;++j){\n\t\t\t\tx=son(node,j);\n\t\t\t\tif(x&&ask(l+i-1,r,1,N,root[x])){\n\t\t\t\t\tnex[i]=j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tx=son(node,s[i]-'a');\n\t\t\tif(!x||i==n+1||!ask(l+i-1,r,1,N,root[x]))break;\n\t\t\tnode=x;\n\t\t}\n\t\twhile(i&&nex[i]==-1)--i;\n\t\tif(!i)puts(\"-1\");//\u627e\u4e0d\u5230\uff0c\u65e0\u89e3\n\t\telse {\n\t\t\tfor(register int j=1;j<i;++j)px(s[j]);\n\t\t\tpx(nex[i]+'a');\n\t\t\tpn;\n\t\t}\n\t}\n}\n```\n\n",
        "postTime": 1556458211,
        "uid": 111762,
        "name": "_ctz",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "\u849f\u84bb\u6211\u4e0d\u4f1a\u540e\u7f00\u81ea\u52a8\u673a\uff0c\u4e5f\u4e0d\u4f1a\u540e\u7f00\u6811QAQ  \n\u8fd9\u91cc\u7ed9\u51fa\u4e00\u4e2a\u540e\u7f00\u6570\u7ec4\u505a\u6cd5\u3002  \n\n- \u5bf9\u539f\u5e8f\u5217\u5efa\u7acb\u540e\u7f00\u6570\u7ec4\uff0c\u5bf9\u540e\u7f00\u6570\u7ec4\u5efa\u7acb\u4e3b\u5e2d\u6811\n- \u5bf9\u4e8e\u6bcf\u4e2a\u67e5\u8be2\u5e8f\u5217\uff0c\u679a\u4e3e\u7b54\u6848\u4e0e\u5b83\u7684lcp\uff0c\u518d\u679a\u4e3elcp+1\u5904\u7684\u5b57\u7b26\u3002\n- \u5bf9\u4e8e\u5f53\u524d\u679a\u4e3e\u7684\u524d\u7f00\uff0c\u5047\u8bbe\u5b83\u5728SA\u4e2d\u5bf9\u5e94\u7684\u533a\u95f4\u4e3a$[l, r]$\uff0c\u90a3\u4e48\u82e5\u5728\u524d\u7f00\u540e\u6dfb\u52a0\u4e00\u4e2a\u5b57\u7b26\uff0c\u6240\u5f97\u65b0\u5b57\u7b26\u4e32\u5bf9\u5e94\u7684\u533a\u95f4\u4e00\u5b9a\u662f$[l,r]$\u7684\u5b50\u533a\u95f4\u3002\u5728$[l,r]$\u91cc\u4e24\u6b21\u4e8c\u5206\u67e5\u627e\u5c31\u53ef\u4ee5\u627e\u5230\u65b0\u7684\u533a\u95f4\u3002\n- \u6211\u4eec\u679a\u4e3elcp\u7684\u65f6\u5019\uff0c\u8bb0\u5f55\u4e00\u4e0b\u5b83\u5728SA\u4e2d\u5bf9\u5e94\u7684\u533a\u95f4\u3002\u4e8e\u662f\u6211\u4eec\u679a\u4e3e\u4e0b\u4e00\u4e2a\u5b57\u7b26\u65f6\u53ef\u4ee5\u5feb\u901f\u5f97\u5230\u65b0\u7684\u533a\u95f4\u3002\u63a5\u7740\u501f\u52a9\u4e3b\u5e2d\u6811\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5224\u65adlcp\u52a0\u4e0a\u8be5\u5b57\u7b26\u6240\u5f97\u7684\u5b57\u7b26\u4e32\u662f\u5426\u5b58\u5728\u4e8e\u539f\u5b57\u7b26\u4e32\u4e2d\u3002\u82e5\u5b58\u5728\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u5c31\u662f\u4e00\u4e2a\u5408\u6cd5\u7b54\u6848\u3002\u663e\u7136\uff0clcp\u7684\u957f\u5ea6\u8d8a\u5927\uff0c\u7b54\u6848\u8d8a\u4f18\u3002\n- \u9700\u8981\u6ce8\u610f\u5904\u7406\u7b54\u6848\u4ee5\u67e5\u8be2\u7684\u5b57\u7b26\u4e32\u4e3a\u524d\u7f00\u7684\u60c5\u51b5  \n- \u7531\u4e8e\u4e8c\u5206\u548c\u7ebf\u6bb5\u6811\u90fd\u662f$\\text{O}(\\text{log}n)$\u7684\uff0c\u6240\u4ee5\u6700\u7ec8\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a$\\text{O}(26\\cdot n\\text{log}n)$\u3002  \n\n\u4e0b\u9762\u662f\u4ee3\u7801\u3002\u5b9e\u73b0\u5f97\u4e0d\u662f\u5f88\u6f02\u4eae\uff0c\u540e\u7f00\u6570\u7ec4\u548c\u7279\u5224\u90fd\u5199\u4e86\u4e2a$\\text{O}(n\\text{log}^2n)$\u7684QAQ \u5e38\u6570\u6709\u70b9\u5927\n```\n#include <cstdlib>\n#include <iostream>\n#include <cstdio>\n#include <math.h>\n#include <cstring>\n#include <time.h>\n#include <complex>\n#include <algorithm>\n#include <queue>\n#include <utility>\n\n#pragma GCC optimize(3)\n#pragma warning(disable:4996)\n#define lowbit(a) ((a)&-(a))\n\ntemplate<typename T> T min(T x, T y)\n{\n    return x < y ? x : y;\n}\ntemplate<typename T> T max(T x, T y)\n{\n    return x > y ? x : y;\n};\n\nstruct tree{\n    int l;\n    int r;\n    int sum;\n    tree *lson;\n    tree *rson;\n\n    tree(int L, int R)\n    {\n        l = L;\n        r = R;\n        sum = 0;\n        lson = rson = NULL;\n    }\n    void fixup()\n    {\n        sum = (lson ? lson->sum : 0) + (rson ? rson->sum : 0);\n    }\n    tree *modify(int id, int k)\n    {\n        tree *p = new tree(l, r);\n        *p = *this;\n        if(l == r)\n        {\n            p->sum += k;\n            return p;\n        }\n        int mid = (l + r) / 2;\n        if(id <= mid)\n            p->lson = lson ? lson->modify(id, k) : tree(l, mid).modify(id, k);\n        else\n            p->rson = rson ? rson->modify(id, k) : tree(mid + 1, r).modify(id, k);\n        p->fixup();\n        return p;\n    }\n    int query(int L, int R)\n    {\n        if(L > R)\n            return 0;\n        if(l >= L && r <= R)\n            return sum;\n        int mid = (l + r) / 2;\n        if(R <= mid)\n            return lson ? lson->query(L, R) : 0;\n        if(L > mid)\n            return rson ? rson->query(L, R) : 0;\n        return (lson ? lson->query(L, R) : 0) + (rson ? rson->query(L, R) : 0);\n    }\n};\n\nconst int MAXN = 200005;\nconst long long mod = 998244353;\nconst long long A = 10007;\n\nbool CMP(char *s1, char *s2)\n{\n    while (s1[0] && s2[0] && s1[0] == s2[0])\n        s1++, s2++;\n    return s1[0] < s2[0];\n}\nnamespace SA //\u4ece1\u5f00\u59cb\n{\n    char str[MAXN];\n    long long h[MAXN], po[MAXN];\n    int len, f[MAXN], rank[MAXN];\n    int lc[MAXN][25];\n    tree *T[MAXN];\n\n    long long hash(int l, int r)\n    {\n        return ((h[r] - h[l - 1] * po[r - l + 1]) % mod + mod) % mod;\n    }\n    int getlcp(int x, int y)\n    {\n        int l = 0, r = len + 1;\n        while (r - l > 1)\n        {\n            int mid = (l + r) / 2;\n            if (hash(x, x + mid - 1) == hash(y, y + mid - 1))\n                l = mid;\n            else\n                r = mid;\n        }\n        return l;\n    }\n    bool cmp(const int x, const int y)\n    {\n        int t = getlcp(x, y);\n        return str[x + t] < str[y + t];\n    }\n    void init()\n    {\n        scanf(\"%s\", str + 1);\n        len = strlen(str + 1);\n        po[0] = 1;\n        for (int i = 1; i < MAXN; i++)\n            po[i] = po[i - 1] * A % mod;\n        for (int i = 1; i < MAXN; i++)\n            h[i] = (h[i - 1] * A + str[i]) % mod;\n        for (int i = 1; i <= len; i++)\n            f[i] = i;\n        std::sort(f + 1, f + len + 1, cmp);\n        for (int i = 1; i <= len; i++)\n            rank[f[i]] = i;\n        for (int i = 2; i <= len; i++)\n            lc[i][0] = getlcp(f[i], f[i - 1]);\n        for (int i = 1; i < 25; i++)\n            for (int j = 1; j <= len; j++)\n                lc[j][i] = min(lc[j][i - 1], lc[min(len, j + (1 << (i - 1)))][i - 1]);\n\n        T[0] = new tree(1, len);\n        for(int i = 1; i <= len; i++)\n            T[i] = T[i - 1]->modify(f[i], 1);\n    }\n    int LCP(int x, int y)\n    {\n        int pl = min(rank[x], rank[y]);\n        int pr = max(rank[x], rank[y]);\n        if (pl == pr)\n            return len - pl + 1;\n        int t = 0;\n        while (1 << t <= pr - pl)\n            t++;\n        t--;\n        return min(lc[pl + 1][t], lc[pr - (1 << t) + 1][t]);\n    }\n    int find(char *s)\n    {\n        int L = strlen(s);\n        int l = 0, r = len + 1;\n        while (r - l > 1)\n        {\n            int mid = (l + r) / 2;\n            if (CMP(str + f[mid], s))\n                l = mid;\n            else\n                r = mid;\n        }\n        for (int i = 0; i < L; i++)\n            if (s[i] != str[f[r] + i])\n                return len + 1;\n        return f[r];\n    }\n    std::pair<int, int> get_range(char *s)\n    {\n        int L = strlen(s);\n        int p = find(s);\n        if(p == len + 1)\n            return std::make_pair(p, p);\n\n        p = rank[p];\n        std::pair<int, int> ret;\n        int l = p, r = len + 1;\n        while(r - l > 1)\n        {\n            int mid = (l + r) / 2;\n            if(LCP(f[p], f[mid]) >= L)\n                l = mid;\n            else\n                r = mid;\n        }\n        ret.second = l;\n\n        l = 0, r = p;\n        while(r - l > 1)\n        {\n            int mid = (l + r) / 2;\n            if(LCP(f[p], f[mid]) >= L)\n                r = mid;\n            else\n                l = mid;\n        }\n        ret.first = r;\n\n        return ret;\n    }\n};\n\nvoid query(char *s, int L, int R)\n{\n    std::pair<int, int> ran = SA::get_range(s);\n    int slen = strlen(s);\n    if(ran.first != SA::len + 1 && SA::T[ran.second]->query(L, R - slen) - SA::T[ran.first - 1]->query(L, R - slen))\n    {\n        int bl = ran.first - 1, br = ran.second;\n        while(br - bl > 1)\n        {\n            int mid = (bl + br) / 2;\n            if(SA::T[mid]->query(L, R - slen) - SA::T[ran.first - 1]->query(L, R - slen))\n                br = mid;\n            else\n                bl = mid;\n        }\n        for(int i = 0; i < slen + 1; i++)\n            printf(\"%c\", SA::str[SA::f[br] + i]);\n        printf(\"\\n\");\n        return;\n    }\n\n    ran = std::make_pair(1, SA::len);\n    int pos = 0;\n    char last = 0;\n    for(int i = 0; i < slen; i++)\n    {\n    \tfor(char c = s[i] + 1; c <= 'z'; c++)\n    \t{\n    \t\tstd::pair<int, int> tr;\n    \t\tint l = ran.first - 1, r = ran.second + 1;\n    \t\twhile(r - l > 1)\n    \t\t{\n    \t\t\tint mid = (l + r) / 2;\n                if(SA::str[SA::f[mid] + i] >= c)\n                    r = mid;\n                else\n                    l = mid;\t\t\n    \t\t}\n    \t\tif(r == ran.second + 1 || SA::str[SA::f[r] + i] != c)\n    \t\t\tcontinue;\n    \t\ttr.first = r;\n    \t\tl = ran.first - 1, r = ran.second + 1;\n    \t\twhile(r - l > 1)\n    \t\t{\n    \t\t\tint mid = (l + r) / 2;\n                if(SA::str[SA::f[mid] + i] > c)\n                    r = mid;\n                else\n                    l = mid;\t\n    \t\t}\n    \t\ttr.second = r - 1;\n    \t\t\n    \t\tif(SA::T[tr.second]->query(L, R - i) - SA::T[tr.first - 1]->query(L, R - i))\n    \t\t{\n                pos = i, last = c;\n                break;\t\t\t\n    \t\t}\n   \t\t}\n   \t\tint l = ran.first - 1, r = ran.second + 1;\n   \t\twhile(r - l > 1)\n   \t\t{\n   \t\t\tint mid = (l + r) / 2;\n            if(SA::str[SA::f[mid] + i] >= s[i])\n                r = mid;\n            else\n                l = mid;\n   \t\t}\n   \t\tif(r == ran.second + 1)\n   \t\t\tbreak;\n   \t\tl = ran.first - 1;\n   \t\tran.first = r;\n   \t\tr = ran.second + 1;\n   \t\twhile(r - l > 1)\n   \t\t{\n   \t\t\tint mid = (l + r) / 2;\n            if(SA::str[SA::f[mid] + i] > s[i])\n                r = mid;\n            else\n                l = mid;\n   \t\t}\n   \t\tran.second = r - 1;\n    }\n    if(last)\n    {\n    \tfor(int i = 0; i < pos; i++)\n            printf(\"%c\", s[i]);\n        printf(\"%c\\n\", last);\t\n    }\n    else\n    \tprintf(\"-1\\n\");\n}\n\nvoid solve()\n{\n    static char s[MAXN] = {};\n    int M, l, r;\n\n    scanf(\"%d\", &M);\n    while(M--)\n    {\n        scanf(\"%d %d %s\", &l, &r, s);\n        query(s, l, r);\n    }\n}\n\nint main()\n{\n    SA::init();\n    solve();\n\n    return 0;\n}\n```",
        "postTime": 1556560192,
        "uid": 64366,
        "name": "ddwqwq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "\n\n\u7ebf\u6bb5\u6811\u5408\u5e76\u7ef4\u62a4 SAM \u7684 right \u96c6\u5408\u597d\u9898\u3002\n\n\n------------\n\n\u9996\u5148\u6211\u4eec\u5148\u5957\u8def\u7684\u5efa\u51fa SAM\u3002\n\n\u5bf9\u4e8e\u6bcf\u4e2a\u8be2\u95ee\u4e32\uff0c\u6211\u4eec\u8981\u5728\u539f\u4e32\u4e2d\u6c42\u51fa\u4e00\u4e2a\u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u4e32\uff0c\u4f7f\u5f97\u5176\u5b57\u5178\u5e8f\u6bd4\u4ed6\u5927\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u8d2a\u5fc3\u505a\u6cd5\u3002\n\n\u6211\u4eec\u4ee4 $s$ \u4e3a\u8be2\u95ee\u4e32\u5728\u539f\u4e32 $[l,r]$  \u533a\u95f4\u5185\u80fd\u5339\u914d\u5230\u6700\u5927\u7684\u4e32\uff0c\u5982\u679c\u8be5\u957f\u5ea6\u4e4b\u540e\u6709\u6bd4\u8be2\u95ee\u5b57\u6bcd\u5927\u7684\u8fde\u63a5\uff0c\u90a3\u8be5\u4e32\u4e00\u5b9a\u662f\u6700\u5c0f\u7684\u3002\u5982\u679c\u4e0d\u80fd\u5339\u914d\uff0c\u5219\u5411\u4e0a\u8df3\u7236\u4eb2\uff0c\u76f4\u81f3\u53ef\u4ee5\u3002\n\n\n------------\n\n\u8003\u8651\u5982\u4f55\u5224\u65ad\u5982\u4f55\u80fd\u5411\u4e0b\u5339\u914d\uff0c\u8003\u8651\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u7684 right \u96c6\u5408\u3002\n\n\u5047\u5982\u5728\u539f\u4e32\u7684\u533a\u95f4\u662f $[l,r]$ \uff0c\u4f60\u73b0\u5728\u5df2\u7ecf\u8981\u5339\u914d\u7684\u957f\u5ea6\u4e3a $s$ \uff0c\u5728 SAM \u4e0a\u7684\u8282\u70b9\u4e3a $x$ \uff0c\u4f60\u60f3\u77e5\u9053\u5b83\u80fd\u4e0d\u80fd\u5339\u914d\u5230 $y$ \u8282\u70b9\u3002\u90a3\u6211\u4eec\u53ea\u8981\u5224\u65ad $y$ \u7684 right \u96c6\u5408\u4e2d\u662f\u5426\u5b58\u5728\u5143\u7d20\u5c5e\u4e8e $ [l+s,r]$ \u5373\u53ef\u3002\n\n\n------------\n\n\u65f6\u7a7a\u590d\u6742\u5ea6 $O(|S| \\log |S|)$ \uff0c\u4ee4 $|S|$\uff0c$|T|$ \u540c\u9636\u3002 \n\n\n------------\n\u4ee3\u7801\u5982\u4e0b\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define pi pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define mid (l+r>>1)\nconst int maxn=4e5+5,M=34005;\ninline int read(){\n\tchar ch=getchar();bool f=0;int x=0;\n\tfor(;!isdigit(ch);ch=getchar())if(ch=='-')f=1;\n\tfor(;isdigit(ch);ch=getchar())x=(x<<1)+(x<<3)+(ch^48);\n\tif(f==1)x=-x;return x;\n}\ninline void print(int x){\n    static int a[55];int top=0;\n    if(x<0) putchar('-'),x=-x;\n    do{a[top++]=x%10,x/=10;}while(x);\n    while(top) putchar(a[--top]+48);\n}\nint tot=0,n,m,l,r,lx,rx,q,ans[maxn],cnt=0,g;\nint ls[maxn*40],rs[maxn*40],rt[maxn];\nstruct node{int l,r,id;};vector<node>d[maxn];\nchar a[maxn],b[maxn]; \nvoid build(int &rt,int l,int r,int pos){\n\tif(l>pos||r<pos)return;if(!rt)rt=++tot;\n\tif(l==r){return;}\n\tbuild(ls[rt],l,mid,pos),build(rs[rt],mid+1,r,pos);\n}\nint merge(int x,int y,int l,int r){\n\tif(!x||!y)return x+y;int rt=++tot;\n\tif(l==r){return rt;}\n\tls[rt]=merge(ls[x],ls[y],l,mid);\n\trs[rt]=merge(rs[x],rs[y],mid+1,r);return rt;\n\treturn x;\n}\nint query(int rt,int l,int r,int L,int R){\n\tif(l>R||r<L||!rt)return 0;\n\tif(l>=L&&r<=R){return (r-l+1);}\n\treturn query(ls[rt],l,mid,L,R)+query(rs[rt],mid+1,r,L,R);\n}\nstruct Sam{\n\tint len[maxn],fa[maxn],ch[maxn][26],tot=1,las=1,pos[maxn];vector<int>e[maxn];\n\tvoid ins(int x,int id){\n\t\tint p=las,t=++tot;las=t;len[t]=len[p]+1;\n\t\tpos[t]=id;build(rt[t],1,n,id);\n\t\tfor(;!ch[p][x];p=fa[p])ch[p][x]=t;\n\t\tif(!p){fa[t]=1;return;}int q=ch[p][x];\n\t\tif(len[q]==len[p]+1){fa[t]=q;return;}\n\t\tlen[++tot]=len[p]+1,fa[tot]=fa[q],fa[q]=fa[t]=tot;pos[tot]=id;\n\t\tmemcpy(ch[tot],ch[q],sizeof ch[q]);\n\t\tfor(;ch[p][x]==q;p=fa[p])ch[p][x]=tot;\n\t}\n\tvoid dfs(int x){\n\t\tfor(auto i:e[x])\n\t\t\tdfs(i),rt[x]=merge(rt[x],rt[i],1,n);\n\t}\n\tvoid work(){\n\t\tfor(int i=2;i<=tot;i++)e[fa[i]].pb(i);\n\t\tdfs(1);\n\t}\n\tbool match(int l,int r,int len,int p){\n\t\tint c;if(len>g)c=-1;else c=b[len]-'a';\n\t\tif(c>=0&&ch[p][c]&&query(rt[ch[p][c]],1,n,l+len-1,r)&&match(l,r,len+1,ch[p][c]))\n\t\t\t{ans[++cnt]=c;return 1;}\n\t\tfor(int i=c+1;i<26;i++)\n\t\t\tif(ch[p][i]&&query(rt[ch[p][i]],1,n,l+len-1,r)){ans[++cnt]=i;return 1;}\n\t\treturn 0;\n\t}\n}sam;\nsigned main(){\n\tscanf(\"%s\",a+1);n=strlen(a+1);\n\tfor(int i=1;i<=n;i++)sam.ins(a[i]-'a',i);\n\tsam.work();m=read();\n\tfor(int i=1;i<=m;i++){\n\t\tl=read(),r=read(),scanf(\"%s\",b+1);\n\t\tcnt=0;g=strlen(b+1);\n\t\tif(sam.match(l,r,1,1)){\n\t\t\tfor(int j=cnt;j>=1;j--)printf(\"%c\",ans[j]+'a');puts(\"\");\n\t\t}\n\t\telse puts(\"-1\");\n\t}\n \treturn 0;\n}\n```\n\n\n\n",
        "postTime": 1649485199,
        "uid": 343748,
        "name": "louhao088",
        "ccfLevel": 9,
        "title": "CF1037H Security"
    },
    {
        "content": "\u63d0\u4f9b\u4e00\u4e2a\u5355 $\\log$ \u7684 SA \u505a\u6cd5\u3002\n\n\u5148\u628a\u6240\u6709\u7684\u4e32\u8fde\u8d77\u6765\u3002**\u8be2\u95ee\u4e32\u4e4b\u95f4\u7528\u5c0f\u4e8e `a` \u7684\u5b57\u7b26\u8fde\u63a5\u3002**\n\n\u679a\u4e3e $T$ \u7684\u524d\u7f00\uff0c\u5224\u65ad\u533a\u95f4\u4e2d\u662f\u5426\u5b58\u5728\u4e00\u4e2a\u5b50\u4e32\u6ee1\u8db3\u662f\u8fd9\u4e2a\u524d\u7f00\u52a0\u4e0a\u4e00\u4e2a\u5b57\u6bcd\uff0c\u6ee1\u8db3\u8fd9\u4e2a\u5b57\u6bcd\u5927\u4e8e $T$ \u7684\u524d\u7f00\u7684\u540e\u9762\u4e00\u4e2a\u5b57\u7b26\u3002\n\n\u5982\u679c\u524d\u7f00\u4e3a $T$ \u672c\u8eab\uff0c\u90a3\u4e48\u540e\u9762\u4e00\u4e2a\u5b57\u7b26\u662f\u6781\u5c0f\u7684\u3002\u8fd9\u4e2a\u663e\u7136\u6ee1\u8db3\u5b57\u5178\u5e8f\u7684\u5b9a\u4e49\u3002\n\n\u7136\u540e\u5c31\u8003\u8651\u5728 SA \u4e0a\u4e8c\u5206\u51fa\u4e00\u4e2a\u533a\u95f4\uff0c\u6ee1\u8db3\u533a\u95f4\u4e2d\u7684\u540e\u7f00\u4e0e $T$ \u7684 LCP \u957f\u5ea6**\u7b49\u4e8e**\u6b63\u5728\u679a\u4e3e\u7684 $T$ \u7684\u524d\u7f00\u957f\u5ea6 $len$\u3002\u8fd9\u4e2a\u53ef\u4ee5\u8bb0\u5f55\u4e00\u4e0b\u4e0a\u6b21\u4e8c\u5206\u7ed3\u679c\u3002\n\n\u7136\u540e\u6c42\u8fd9\u4e2a\u533a\u95f4\u4e2d\u6ee1\u8db3 $sa_i\\in [l,r-len]$ \u7684\u6700\u5c0f\u7684 $i$\u3002\n\n\u4e3b\u5e2d\u6811\u7ef4\u62a4\u540e\u7f00\u533a\u95f4\u6700\u5c0f\u503c\u5373\u53ef\u3002\u6216\u8005\u626b\u63cf\u7ebf\u3002\n\n[\u8bc4\u6d4b\u8bb0\u5f55](https://codeforces.com/contest/1037/submission/146886615)\n\n\u6211\u4e5f\u4e0d\u77e5\u9053\u4e3a\u4ec0\u4e48\u6211\u4e0d\u592a\u4f1a SAM \u7684\u5355 $\\log$ \u89e3\u6cd5\u3002SA \u7740\u91cd\u523b\u753b\u4e86\u5b57\u5178\u5e8f\u5173\u7cfb\uff0c\u662f\u89e3\u51b3\u672c\u9898\u975e\u5e38\u81ea\u7136\u7684\u5de5\u5177\u3002",
        "postTime": 1645239215,
        "uid": 203623,
        "name": "Ntokisq",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H Security"
    },
    {
        "content": "\u6b64\u9898\u53ef\u7528 AC \u81ea\u52a8\u673a\u89e3\u51b3\u3002\n\n\u9996\u5148\u8003\u8651\u4e00\u4e2a\u663e\u7136\u7684\u8d2a\u5fc3\u3002\n\n\u8bb0\u8be2\u95ee\u4e32\u4e3a $x$ \u7b54\u6848\u4e32\u4e3a $a$\uff0c\u4ece\u5927\u5230\u5c0f\u679a\u4e3e $x$ \u548c $a$ \u7684\u516c\u5171\u524d\u7f00\u957f\u5ea6 $l$\uff0c\u5219 $a$ \u4e32\u53ea\u53ef\u80fd\u662f $x$ \u7684\u957f\u5ea6\u4e3a $l$ \u7684\u524d\u7f00\u52a0\u4e0a\u4e00\u4e2a\u5927\u4e8e $x_{l+1}$ \u7684\u5b57\u7b26\u3002\u4ece\u5c0f\u5230\u5927\u679a\u4e3e\u52a0\u4e0a\u7684\u5b57\u7b26\uff0c\u5224\u65ad\u8fd9\u4e2a\u4e32\u5728 $s[l,r]$ \u4e2d\u662f\u5426\u51fa\u73b0\u8fc7\u5373\u53ef\u3002\n\n\u8fd9\u6837\u53ef\u80fd\u4f5c\u4e3a\u7b54\u6848\u7684 $a$ \u4e32\u5927\u7ea6\u53ea\u6709 $26\\sum|x|$ \u4e2a\uff0c\u5e76\u4e14\u8fd9\u4e9b\u4e32\u7684 trie \u6811\u7ed3\u70b9\u4e2a\u6570\u662f $26\\sum|x|$ \u7ea7\u522b\u3002\n\n\u5bf9\u8fd9\u4e2a trie \u6811\u5efa AC \u81ea\u52a8\u673a\uff0c\u5efa\u51fa fail \u6811\uff0c\u628a $s$ \u4e32\u653e\u5230\u81ea\u52a8\u673a\u4e0a\u5339\u914d\u3002\n\n\u5224\u65ad\u4e00\u4e2a\u957f\u5ea6\u4e3a $len$ \u7684\u4e32\u662f\u5426\u5728 $s[l,r]$ \u4e2d\u51fa\u73b0\u8fc7\uff0c\u5c31\u662f\u5224\u65ad\u5176\u5bf9\u5e94\u7684 AC \u81ea\u52a8\u673a\u7ed3\u70b9 $i$\uff0c\u662f\u5426\u662f $s[l+len-1,r]$ \u5bf9\u5e94\u7684\u67d0\u4e2a\u7ed3\u70b9\u7684 fail \u6811\u7956\u5148\u3002\n\n\u5339\u914d $s$ \u4e32\u65f6\uff0c\u5bf9\u6bcf\u4e2a\u7ecf\u8fc7\u7684\u7ed3\u70b9\u6253\u4e0a $+1$ \u6807\u8bb0\u3002\u5728\u5339\u914d\u5230 $s_{l+len-2}$ \u548c $s_r$ \u65f6\u5206\u522b\u6c42 $i$ \u7684\u5b50\u6811\u548c $suml,sumr$\uff0c\u82e5 $sumr\\neq suml$ \u5219\u6b64\u4e32\u51fa\u73b0\u8fc7\u3002\u5b50\u6811\u548c\u53ef\u4ee5\u7528\u6811\u72b6\u6570\u7ec4\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(26n(26+\\log n))$\uff0c\u74f6\u9888\u662f\u6784\u5efa AC \u81ea\u52a8\u673a\u548c\u6811\u72b6\u6570\u7ec4\u3002\n\n\u6240\u4ee5\u8fd9\u9053\u9898\u5c31\u505a\u5b8c\u4e86\uff1f\n\n\u7136\u540e\u4f60\u53d1\u73b0 AC \u81ea\u52a8\u673a\u7a7a\u95f4\u8981\u5f00 $26^2n$\uff0c\u76f4\u63a5 MLE \u4e86\u3002\n\n\u6ce8\u610f\u5230\u6570\u7ec4\u7684\u503c\u57df\u662f\u7ed3\u70b9\u6570\u91cf\u4e5f\u5c31\u662f $26n$\uff0c\u4e0d\u8d85\u8fc7 $2^{24}$\uff0c\u53ef\u4ee5\u7528\u4e09\u4e2a unsigned char \u5b58\u4e0b\uff0c\u7701\u4e86 $1/4$ \u7684\u7a7a\u95f4\u3002\n\n\u4f46\u662f\u7b97\u4e0a\u5176\u4ed6\u6570\u7ec4\u8fd8\u662f\u4f1a MLE\uff0c\u4e8e\u662f\u6539\u6210\u7528 vector \u5b58\u50a8\uff0c\u7528\u5b8c\u7684\u6570\u7ec4\u5185\u5b58\u91ca\u653e\u6389\uff0c\u5b9e\u73b0\u7cbe\u7ec6\u4e00\u70b9\u5c31\u4e0d\u4f1a MLE \u4e86\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5200099,M=2e5+9;\nstring s,x[M];\nvector<int>v[M],vc[M*2],ans[M*2],L[M/2],R[M/2],f,he,ne,tr,lp,rp,pos;\nqueue<int>qu;\nstruct P{\n\tunsigned char c1,c2,c3;\n\tbool emp(){return!(c1||c2||c3);}\n};\nstruct T{P c[26];};\nvector<T>t;\nint pti(const P&x){return(x.c1<<16)|(x.c2<<8)|x.c3;}\nP itp(int x){P a;a.c1=x>>16,a.c2=x>>8,a.c3=x;return a;}\nint dfn;\nvoid dfs(int x){//\u6c42fail\u6811dfs\u5e8f\n\tlp[x]=++dfn;\n\tfor(int i=he[x];i;i=ne[i])dfs(i);\n\trp[x]=dfn;\n}\nvoid add(int x){for(;x<=dfn;x+=x&-x)++tr[x];}\nint sum(int x){int r=0;for(;x;x-=x&-x)r+=tr[x];return r;}\nint get(int x){return sum(rp[x])-sum(lp[x]-1);}//\u6811\u72b6\u6570\u7ec4\nint main(){\n\tint q,i,l,r,o,j,k,now,y,z,ct=0,id=0;\n\tios::sync_with_stdio(0),cin>>s>>q,t.resize(N);\n\tfor(i=1;i<=q;++i){\n\t\tcin>>l>>r>>x[i],o=x[i].size(),k=min(o,r-l),x[i]+='a'-1,v[i].resize(k+1);\n\t\tfor(j=now=0;j<=k;++j){\n\t\t\tif(j){\n\t\t\t\tif(t[now].c[y].emp())t[now].c[y]=itp(++id);\n\t\t\t\tnow=pti(t[now].c[y]);\n\t\t\t}\n\t\t\tv[i][j]=++ct,L[l+j-1].push_back(ct),R[r].push_back(ct),y=x[i][j]-'a',vc[ct].resize(26-y-1);\n\t\t\tfor(z=y+1;z<26;++z){\n\t\t\t\tif(t[now].c[z].emp())t[now].c[z]=itp(++id);\n\t\t\t\tvc[ct][z-y-1]=pti(t[now].c[z]);\n\t\t\t}\n\t\t}\n\t}//\u5efatrie\u6811\n\tfor(i=0;i<26;++i)if(!t[0].c[i].emp())qu.push(pti(t[0].c[i]));\n\tfor(f.resize(id+2);qu.size();){\n\t\ti=qu.front(),qu.pop(),k=f[i];\n\t\tfor(j=0;j<26;++j)if(t[i].c[j].emp())t[i].c[j]=t[k].c[j];\n\t\telse y=pti(t[i].c[j]),f[y]=pti(t[k].c[j]),qu.push(y);\n\t}//\u5efaAC\u81ea\u52a8\u673a\n\tfor(o=s.size(),pos.resize(o+2),i=now=0;i<o;++i)now=pti(t[now].c[s[i]-'a']),pos[i+1]=now;\n\tt={},t.shrink_to_fit(),he.resize(id+2),ne=tr=lp=rp=he;//\u91ca\u653et\u7684\u5185\u5b58\n\tfor(i=1;i<=id;++i)ne[i]=he[f[i]],he[f[i]]=i;\n\tfor(i=1;i<=ct;++i)ans[i].resize(vc[i].size());\n\tfor(i=1,dfs(0);i<=o;++i){\n\t\tadd(lp[pos[i]]);\n\t\tfor(int j:L[i])for(y=vc[j].size(),k=0;k<y;++k)ans[j][k]=get(vc[j][k]);\n\t\tfor(int j:R[i])for(y=vc[j].size(),k=0;k<y;++k)ans[j][k]-=get(vc[j][k]);\n\t}//AC\u81ea\u52a8\u673a\u4e0a\u5339\u914d\n\tfor(i=1;i<=q;++i){\n\t\tfor(j=v[i].size()-1;~j;--j)for(k=v[i][j],z=vc[k].size(),y=0;y<z;++y)if(ans[k][y]){\n\t\t\tfor(o=0;o<j;++o)cout<<x[i][o];\n\t\t\tcout<<char(x[i][j]+y+1)<<'\\n';\n\t\t\tgoto gg;\n\t\t}\n\t\tcout<<\"-1\\n\";\n\t\tgg:;\n\t}//\u8f93\u51fa\n\treturn 0;\n}\n```",
        "postTime": 1629887899,
        "uid": 221955,
        "name": "panyf",
        "ccfLevel": 10,
        "title": "CF1037H Security\uff08AC \u81ea\u52a8\u673a\uff09"
    },
    {
        "content": "[CF1037H Security](https://www.luogu.com.cn/problem/CF1037H)\n\n$\\text{Solution:}$\n\n\u4ee3\u7801\u4e2d\u7ed9\u51fa\u4e86\u5c01\u88c5\u597d\u7684\u7ebf\u6bb5\u6811\u548c\u540e\u7f00\u81ea\u52a8\u673a\u3002\n\n\u8003\u8651\u6ca1\u6709 $L,R$ \u9650\u5236\u600e\u4e48\u505a\u3002\n\n\u663e\u7136\u76f4\u63a5\u5728\u4e0a\u9762\u8dd1\u5339\u914d\uff1a\u5148\u6309\u7167 $T$ \u6765\u8dd1\uff0c\u5982\u679c\u4e2d\u95f4\u53ea\u80fd\u627e\u5230\u6bd4\u4ed6\u5927\u7684\uff0c\u5c31\u76f4\u63a5\u8f93\u51fa\uff1b\u7136\u540e\u662f\u4e24\u79cd\u60c5\u51b5\uff1a\u4e00\u79cd\u662f\u5c06 $T$ \u5b8c\u6574\u5339\u914d\u5b8c\u4e86\uff0c\u53e6\u4e00\u79cd\u662f\u6211\u4eec\u4f9d\u9760\u8d70\u6700\u5c0f\u5b57\u7b26\u7684\u4e32\u540e\u9762\u5339\u914d\u4e0d\u4e0a\u4e86\u3002\n\n\u5148\u8003\u8651\u5339\u914d\u5b8c\u7684\u60c5\u51b5\uff1a\u9996\u5148\u5982\u679c\u5339\u914d\u5b8c\u4e86\uff0c\u5728\u540e\u9762\u5982\u679c\u53ef\u4ee5\u63a5\u4e0a\u4e00\u4e2a\u6700\u5c0f\u7684\u5b57\u7b26\u90a3\u5c31\u662f\u7b54\u6848\u4e86\u3002\u5148\u628a\u8fd9\u79cd\u60c5\u51b5\u5224\u65ad\u6389\u3002\n\n\u90a3\u63a5\u4e0b\u6765\u4e0a\u8ff0\u4e24\u79cd\u60c5\u51b5\u7684\u5904\u7406\u65b9\u5f0f\u662f\u4e00\u6837\u7684\uff1a\u8003\u8651\u8bb0\u5f55\u4ece\u6839\u8f6c\u79fb\u5230\u5f53\u524d\u5931\u914d\u6216\u8005\u662f\u5339\u914d\u7ed3\u675f\u7684\u70b9\u7684\u8def\u5f84\uff0c\u8003\u8651\u4ece\u540e\u5f80\u524d\u4e00\u4e2a\u4e2a\u66f4\u65b0\u662f\u5426\u80fd\u5230\u8fbe\u4e00\u4e2a\u5b57\u5178\u5e8f\u66f4\u5927\u7684\u70b9\u3002\u56e0\u4e3a\u4ece\u540e\u5f80\u524d\u4e00\u5b9a\u53ef\u4ee5\u4fdd\u8bc1\u5b57\u5178\u5e8f\u6700\u5c0f\u3002\n\n\u5982\u679c\u627e\u4e0d\u5230\u90a3\u5c31\u662f\u65e0\u89e3\uff0c\u8f93\u51fa $-1.$\n\n\u90a3\u5e26\u4e0a\u4e86\u9650\u5236\u600e\u4e48\u505a\uff1f\n\n\u90a3\u65e0\u975e\u662f\u5728\u5339\u914d\u7684\u65f6\u5019\u9700\u8981\u5224\u65ad\u80fd\u4e0d\u80fd\u8d70\u8fd9\u4e2a\u70b9\u3002\u8bbe\u5f53\u524d\u8d70\u5230\u8fd9\u4e2a\u70b9\u5df2\u7ecf\u5339\u914d\u7684\u957f\u5ea6\u4e3a $len,$ \u5219\u5982\u679c\u53ef\u4ee5\u5339\u914d\uff0c\u5c31\u9700\u8981\u6ee1\u8db3\u8fd9\u4e2a\u70b9\u4ee3\u8868\u7684 endpos \u5728\u533a\u95f4 $[l+len-1,r]$ \u4e2d\u51fa\u73b0\u8fc7\u3002\n\n\u90a3\u4e0b\u9762\u7684\u95ee\u9898\u5c31\u662f\u5982\u4f55\u7ef4\u62a4\u6bcf\u4e00\u4e2a\u70b9\u7684 endpos \u96c6\u5408\u4e86\u3002\u8003\u8651 parent \u6811\u7684\u6027\u8d28\uff1a\u8282\u70b9\u7684 endpos \u7b49\u4e8e\u5176\u5b69\u5b50\u7684 endpos \u96c6\u5408\u4e4b\u5e76\u3002\u800c\u540e\u7f00\u5bf9\u5e94\u7684\u8282\u70b9\u7684 endpos \u5c31\u662f\u540e\u7f00\u7684\u4f4d\u7f6e\u3002\n\n\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5728 parent \u6811\u4e0a\u8fdb\u884c\u7ebf\u6bb5\u6811\u5408\u5e76\uff0c\u7ef4\u62a4\u51fa\u6bcf\u4e00\u4e2a\u70b9\u7684 endpos \u96c6\u5408\u3002\u6ce8\u610f\u6bcf\u4e00\u4e2a\u70b9\u90fd\u8981\u6709\u4e00\u68f5\u81ea\u5df1\u7684\u6811\u3002\u5426\u5219\u7ed3\u6784\u662f\u9519\u7684\u3002\n\n\u90a3\u4e48\u6ce8\u610f\u7a7a\u95f4\u95ee\u9898\uff1a SAM \u7684\u7a7a\u95f4\u6700\u5927\u8fbe\u5230 $2n$ \u7ea7\u522b\uff0c\u672c\u9898\u5c31\u662f $2\\times 10^5,$ \u5bf9\u5e94\u7ebf\u6bb5\u6811\u5408\u5e76\u7a7a\u95f4\u7ea6\u4e3a $n\\log n,$ \u5373 $3.6\\times 10^6$ \u5de6\u53f3\u3002\n\n\u6240\u4ee5\u4e00\u5b9a\u8981\u7b97\u597d\u7a7a\u95f4\u3002\n\n\u5176\u4ed6\u7684\u7ec6\u8282\u5c31\u662f\u8ba1\u7b97\u533a\u95f4\u548c\u60c5\u51b5\u7279\u5224\u4e86\u3002\n\n\u52a8\u6001\u5f00\u70b9\u7684\u7ebf\u6bb5\u6811\u4e0d\u9700\u8981\u7ef4\u62a4\u4ec0\u4e48\u4e1c\u897f\uff0c\u7531\u4e8e\u6211\u4eec\u7684\u8be2\u95ee\u5c5e\u4e8e\u5b58\u5728\u6027\u8be2\u95ee\uff0c\u76f4\u63a5\u8be2\u95ee\u90a3\u4e2a\u533a\u95f4\u662f\u4e0d\u662f\u6709\u5efa\u7acb\u597d\u7684\u70b9\u5373\u53ef\u3002\n\n\u590d\u6742\u5ea6 $O(\\sum |T|\\log |S|)$\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e6+10;\nconst int SN=3e5+10;\nint n,slen,Alen;\nnamespace SGT{\n    int ls[N],rs[N],node;\n    void change(int &x,const int &L,const int &R,const int &pos){\n        if(!x)x=++node;\n        if(L==R){return;}\n        int mid=(L+R)>>1;\n        if(pos<=mid)change(ls[x],L,mid,pos);\n        else change(rs[x],mid+1,R,pos);\n    }\n    bool query(const int &x,const int &L,const int &R,const int &ql,const int &qr){\n        if(!x)return 0;\n        if(L>=ql&&R<=qr)return 1;\n        int mid=(L+R)>>1;\n        int res=0;\n        if(ql<=mid)res=query(ls[x],L,mid,ql,qr);\n        if(mid<qr)res|=query(rs[x],mid+1,R,ql,qr);\n        return res;\n    }\n    int merge(const int &x,const int &y){\n        if(!x||!y)return x|y;\n        int p=++node;\n        ls[p]=merge(ls[x],ls[y]);\n        rs[p]=merge(rs[x],rs[y]);\n        return p;\n    }\n}\nusing namespace SGT;\nnamespace SAM{\n    int len[SN],pa[SN],rt[SN],tot=1,last=1,ch[SN][26],edp[SN];\n    vector<int>G[SN];\n    void insert(const int &c){\n        int p=last;\n        int np=++tot;\n        last=tot;len[np]=len[p]+1;\n        for(;p&&!ch[p][c];p=pa[p])ch[p][c]=np;\n        if(!p)pa[np]=1;\n        else{\n            int q=ch[p][c];\n            if(len[q]==len[p]+1)pa[np]=q;\n            else{\n                int nq=++tot;\n                len[nq]=len[p]+1;\n                pa[nq]=pa[q];pa[q]=pa[np]=nq;\n                memcpy(ch[nq],ch[q],sizeof ch[q]);\n                for(;p&&ch[p][c]==q;p=pa[p])ch[p][c]=nq;\n            }\n        }\n    }\n    void dfs(int x){\n        if(edp[x]){\n            change(rt[x],1,Alen,edp[x]);\n        }\n        for(auto v:G[x]){\n            dfs(v);\n            rt[x]=merge(rt[x],rt[v]);\n        }\n    }\n    void BuildTree(){\n        for(int i=2;i<=tot;++i)G[pa[i]].push_back(i);\n        dfs(1);\n    }\n}\nusing namespace SAM;\nchar s[SN];\ninline void print(vector<char> A){\n    for(auto i:A)putchar(i);\n    puts(\"\");\n}\nchar check(int now,char T,int len,int l,int r){\n    int v=T-'a';\n    for(int i=v+1;i<26;++i){\n        if(ch[now][i]&&query(rt[ch[now][i]],1,Alen,l+len-1,r))return i+'a';\n    }\n    return '#';\n}\nvoid Mate(int l,int r){\n    int now=1;\n    vector<int>Path;\n    vector<char>Ans;\n    Path.push_back(1);\n    int len=0;\n    int Tag=0;\n    for(int i=1;i<=slen;++i){\n        int pos,ck=0;\n        for(pos=s[i]-'a';pos<26;++pos){\n            if(ch[now][pos]&&query(rt[ch[now][pos]],1,Alen,l+len,r)){ck=1;break;}\n        }\n        if(!ck){Tag=1;break;}\n        Ans.push_back(pos+'a');\n        if(pos!=s[i]-'a'){\n            print(Ans);\n            return;\n        }\n        Path.push_back(ch[now][pos]);\n        len++;\n        now=ch[now][pos];\n    }\n    if(Tag){\n        // puts(\"*******\");\n        int plen=(int)Path.size();\n        for(int i=plen-2;~i;--i){\n            char lat=check(Path[i],s[len-plen+1+i+1],len-plen+1+i+1,l,r);\n            Ans.pop_back();\n            if(lat=='#')continue;\n            else {Ans.push_back(lat);print(Ans);return;}\n        }\n        puts(\"-1\");\n        return;\n    }\n    for(int nxtpos=0;nxtpos<26;++nxtpos){\n        if(ch[now][nxtpos]&&query(rt[ch[now][nxtpos]],1,Alen,l+len,r)){\n            Ans.push_back(nxtpos+'a');\n            print(Ans);\n            return;\n        }\n    }\n    int plen=(int)Path.size();\n    for(int i=plen-2;~i;--i){\n        char lat=check(Path[i],s[slen-plen+1+i+1],slen-plen+1+i+1,l,r);\n        Ans.pop_back();\n        if(lat=='#')continue;\n        else {Ans.push_back(lat);print(Ans);return;}\n    }\n    puts(\"-1\");\n    return;\n}\nint main(){\n    scanf(\"%s\",s+1);\n    slen=strlen(s+1);Alen=slen;\n    for(int i=1;i<=slen;++i)insert(s[i]-'a');\n    // puts(\"insert\");\n    for(int i=1,now=1;i<=slen;++i){\n        int v=s[i]-'a';\n        now=ch[now][v];\n        edp[now]=i;\n    }\n    // puts(\"change\");\n    BuildTree();\n    // puts(\"BuildTree\");\n    scanf(\"%d\",&n);\n    while(n--){\n        int L,R;\n        scanf(\"%d%d\",&L,&R);\n        scanf(\"%s\",s+1);\n        slen=strlen(s+1);\n        Mate(L,R);\n    }\n    return 0;\n}\n```",
        "postTime": 1629629402,
        "uid": 128591,
        "name": "Refined_heart",
        "ccfLevel": 9,
        "title": "CF1037H Security \u9898\u89e3"
    },
    {
        "content": "\u8003\u8651\u4f7f\u7528 $SA$\uff0c\u5c06\u6240\u6709\u4e32\u9996\u5c3e\u76f8\u8fde\n\n\u8bbe $suf_i$ \u8868\u793a\u4ece $i$ \u5f00\u59cb\u7684\u540e\u7f00\n\n\u5bf9\u4e8e\u8be2\u95ee\u4e32 $T$ \uff0c\u95ee\u9898\u8f6c\u5316\u4e3a\u627e\u5230\u5b57\u5178\u5e8f\u6700\u5c0f\u7684 $i$\uff0c\u4f7f\u5f97 $i \\in [l,r],lcp(suf_i,T) \\leq r-i$\u3002\u8003\u8651\u679a\u4e3e $lcp(suf_i,T) = j$\uff0c\u90a3\u4e48 $i \\in [l,r-j]$\uff0c\u4e14 $rk_i > rk_T$\n\n\u5728 $rk$ \u6570\u7ec4\u4e0a\u4e8c\u5206\uff0c\u627e\u5230\u6070\u597d\u4f7f\u5f97 $lcp(T,suf_t) = j,rk_T < pl \\leq t \\leq pr$ \u7684 $pl$ \u548c $pr$\u3002\u4f7f\u7528\u503c\u57df\u4e3b\u5e2d\u6811\u5224\u65ad\u8be5\u533a\u95f4\u662f\u5426\u5b58\u5728\u89e3\u5373\u53ef\u3002\u5982\u679c $[pl,pr]$ \u533a\u95f4\u5b58\u5728\u89e3\uff0c\u518d\u5229\u7528\u4e3b\u5e2d\u6811\u4e8c\u5206\u3002\u8f93\u51fa\u662f\u5bb9\u6613\u7684\u3002\n\n\u8bbe\u603b\u4e32\u957f\u4e3a $n$\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n \\log n  + (\\sum|T|) \\log^2n )$\n\n[\u4ee3\u7801](https://codeforces.com/contest/1037/submission/126824976)",
        "postTime": 1629803267,
        "uid": 287850,
        "name": "ZSH_ZSH",
        "ccfLevel": 0,
        "title": "CF1037H"
    },
    {
        "content": "\u6765\u4e00\u53d1\u7b80\u5355\u597d\u5199\u7684\u540e\u7f00\u6570\u7ec4\u505a\u6cd5\u3002\n\n\u8003\u8651\u5c06\u539f\u95ee\u9898\u8f6c\u5316\u4e3a\u5224\u5b9a\u6027\u95ee\u9898\uff0c\u53ef\u4ee5\u679a\u4e3e\u7b54\u6848\u4e32\u548c $T$ \u7684 $\\text{lcp}$\uff0c\u56e0\u4e3a\u9700\u8981\u4fdd\u8bc1\u5b57\u5178\u5e8f\u4e25\u683c\u5927\u4e8e\uff0c\u9700\u8981\u518d\u5728\u672b\u5c3e\u6dfb\u52a0\u4e00\u4e2a\u6bd4 $T$ \u4e2d\u76f8\u5e94\u4f4d\u7f6e\u5927\u7684\u5b57\u6bcd\uff0c\u7136\u540e\u5224\u65ad\u5f97\u5230\u7684\u5b57\u7b26\u4e32\u6709\u6ca1\u6709\u5728 $S[L..R]$ \u4e2d\u51fa\u73b0\u8fc7\u5373\u53ef\u3002\n\n\u8fd9\u9898\u7684\u96be\u70b9\u5c31\u5728\u4e8e\u5982\u4f55\u5224\u65ad\uff0c\u6211\u4eec\u5c06\u5176\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\u6765\u505a\u3002\n\n\u4e00\u3001 \u627e\u5230\u5b57\u7b26\u4e32\u5728 $rank$ \u6570\u7ec4\u91cc\u5bf9\u5e94\u7684\u533a\u95f4\n\n\u82e5 $\\text{lcp}$ \u957f\u5ea6\u4e3a $k$ \u65f6\u5bf9\u5e94\u7684\u533a\u95f4\u4e3a $[l,r]$\uff0c\u90a3\u4e48\u5728 $\\text{lcp}$ \u540e\u6dfb\u52a0\u4e00\u4e2a\u5b57\u7b26\u5bf9\u5e94\u7684\u533a\u95f4\u5fc5\u5b9a\u4e3a $[l,r]$ \u7684\u5b50\u533a\u95f4\uff0c\u4e8e\u662f\u65b0\u533a\u95f4\u53ef\u4ee5\u901a\u8fc7\u4e24\u6b21\u4e8c\u5206\u5f97\u5230\u3002\n\n\u4e8c\u3001 \u5224\u65ad\u8be5\u533a\u95f4\u5185\u7684\u6570\u5bf9\u5e94\u7684 $sa$ \u503c\u6709\u65e0\u5728 $[L,R]$ \u5185\u7684\n\n\u8fd9\u4e2a\u662f\u7ecf\u5178\u7684\u4e3b\u5e2d\u6811\u95ee\u9898\uff0c\u5728\u672c\u9898\u7684\u6570\u636e\u8303\u56f4\u4e0b\u4e5f\u53ef\u4ee5\u4f7f\u7528\u5206\u5757\u6765\u89e3\u51b3\uff0c\u4ee5 $rank$ \u4e3a\u4e0b\u6807\uff0c\u5728\u5bf9\u5e94\u4f4d\u7f6e\u63d2\u5165 $sa$ \u503c\u5373\u53ef\u3002\n\n\u53e6\u5916\u8981\u6ce8\u610f\u7684\u5c31\u662f $T$ \u7684\u957f\u5ea6\u53ef\u80fd\u5927\u4e8e $R-L+1$\uff0c\u8fd9\u65f6 $\\text{lcp}$ \u53ea\u80fd\u679a\u4e3e\u5230\u524d $R-L+1$ \u4e2a\u5b57\u6bcd\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(26n\\log n)$\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nconst int maxn=4e5+10;\ntemplate<class T>inline void ckmax(T &x,const T &y){if(x<y)x=y;}\nnamespace SGT{\n\tstruct node{\n\t\tint ls,rs,sum;\n\t}t[maxn*20];\n\tint cur;\n\tint insert(int p,int l,int r,int k,int v){\n\t\tt[++cur]=t[p];\n\t\tp=cur;\n\t\tt[p].sum+=v;\n\t\tif(l==r)return p;\n\t\tri mid=l+r>>1;\n\t\tif(k<=mid)t[p].ls=insert(t[p].ls,l,mid,k,v);\n\t\telse t[p].rs=insert(t[p].rs,mid+1,r,k,v);\n\t\treturn p;\n\t}\n\tint query(int p1,int p2,int l,int r,int k){\n\t\tif(l==r)return t[p2].sum-t[p1].sum;\n\t\tri mid=l+r>>1;\n\t\tif(k<=mid)return query(t[p1].ls,t[p2].ls,l,mid,k);\n\t\telse return t[t[p2].ls].sum-t[t[p1].ls].sum+query(t[p1].rs,t[p2].rs,mid+1,r,k);\n\t}\n\tint n,rt[maxn];\n\tinline int query(int l,int r,int ql,int qr){\n\t\treturn query(rt[l-1],rt[r],0,n,qr)-query(rt[l-1],rt[r],0,n,ql-1);\n\t}\n}\nusing SGT::n;\nusing SGT::rt;\nint cnt[maxn],mx,rk[maxn],sa[maxn],tmp[maxn];\nchar s[maxn];\ninline void base_sort(){\n\tmemset(cnt,0,sizeof(int)*(mx+1));\n\tfor(ri i=1;i<=n;++i)++cnt[rk[i]];\n\tfor(ri i=1;i<=mx;++i)cnt[i]+=cnt[i-1];\n\tfor(ri i=n;i;--i)sa[cnt[rk[tmp[i]]]--]=tmp[i];\n}\ninline void suffix_sort(){\n\tfor(ri i=1;i<=n;++i)ckmax(mx,rk[i]=s[i]),tmp[i]=i;\n\tbase_sort();\n\tfor(ri len=1,dif=0;dif<n;len<<=1,mx=dif){\n\t\tri p=0;\n\t\tfor(ri i=n-len+1;i<=n;++i)tmp[++p]=i;\n\t\tfor(ri i=1;i<=n;++i)\n\t\t\tif(sa[i]>len)\n\t\t\t\ttmp[++p]=sa[i]-len;\n\t\tbase_sort();\n\t\tswap(rk,tmp);\n\t\trk[sa[1]]=dif=1;\n\t\tfor(ri i=2;i<=n;++i){\n\t\t\tif(tmp[sa[i-1]]!=tmp[sa[i]]||tmp[sa[i-1]+len]!=tmp[sa[i]+len])++dif;\n\t\t\trk[sa[i]]=dif;\n\t\t}\n\t}\n}\ninline int matchl(int l,int r,int len,char ch){\n\tri ret=-1;\n\twhile(l<=r){\n\t\tri mid=l+r>>1;\n\t\tif(s[sa[mid]+len-1]==ch)ret=mid,r=mid-1;\n\t\telse if(s[sa[mid]+len-1]>ch)r=mid-1;\n\t\telse l=mid+1;\n\t}\n\treturn ret;\n}\ninline int matchr(int l,int r,int len,char ch){\n\tri ret=-1;\n\twhile(l<=r){\n\t\tri mid=l+r>>1;\n\t\tif(s[sa[mid]+len-1]==ch)ret=mid,l=mid+1;\n\t\telse r=mid-1;\n\t}\n\treturn ret;\n}\nint m,len[maxn],pos[maxn],q,ql,qL[maxn],qr,qR[maxn];\nchar t[maxn];\nint main(){\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tsuffix_sort();\n\tfor(ri i=1;i<=n;++i)rt[i]=SGT::insert(rt[i-1],0,n,sa[i],1);\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tscanf(\"%d%d%s\",&ql,&qr,t+1);\n\t\tm=strlen(t+1);\n\t\tri ans1=-1,ans2=-1,L=1,R=n;\n\t\tfor(ri i=0;i<=min(m,qr-ql);++i){\n\t\t\tif(i){\n\t\t\t\tL=matchl(L,R,i,t[i]);\n\t\t\t\tif(L==-1)break;\n\t\t\t\tR=matchr(L,R,i,t[i]);\n\t\t\t}\n\t\t\tfor(ri j=max(t[i+1]+1,(int)'a');j<='z';++j){\n\t\t\t\tri tmp1=matchl(L,R,i+1,j);\n\t\t\t\tif(tmp1!=-1){\n\t\t\t\t\tri tmp2=matchr(tmp1,R,i+1,j);\n\t\t\t\t\tif(SGT::query(tmp1,tmp2,ql,qr-i)){\n\t\t\t\t\t\tans1=i,ans2=j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans1==-1||ans2==-1)puts(\"-1\");\n\t\telse{\n\t\t\tfor(ri i=1;i<=ans1;++i)putchar(t[i]);\n\t\t\tputchar(ans2),putchar(10);\n\t\t}\n\t\tfor(ri i=1;i<=m;++i)t[i]=0;\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1629720850,
        "uid": 67942,
        "name": "meyi",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "$\\text{SAM}$ + \u4e8c\u7ef4\u504f\u5e8f\u9898\u3002\n\n\u8003\u8651\u4e0d\u5b58\u5728 $[L,R]$ \u7ea6\u675f\u7684\u60c5\u51b5\uff0c\u5373\u5728\u539f\u4e32\u4e0a\u8dd1 $\\text{SAM}$\u3002\u5206\u51e0\u79cd\u60c5\u51b5\u8003\u8651\uff1a\n\n- \u6e90\u70b9\u65e0\u4e0d\u5c0f\u4e8e $T$ \u4e32\u7b2c\u4e00\u4e2a\u5b57\u6bcd\u7684\u8f6c\u79fb\u8fb9\u3002\n\n- \u6e90\u70b9\u51fa\u53d1\u7684\u4e00\u6761\u8def\u5f84\u4e0e $T$ \u4e32\u5b8c\u5168\u76f8\u540c\uff0c\u6700\u540e\u518d\u968f\u4fbf\u52a0\u4e0a\u4e00\u6761\u6700\u5c0f\u7684\u8f6c\u79fb\u8fb9\u3002\n\n- \u6e90\u70b9\u51fa\u53d1\u7684\u4e00\u6761\u8def\u5f84\u5728\u7ec8\u6b62\u5904\u5177\u6709\u5927\u4e8e $T$ \u4e32\u5bf9\u5e94\u4f4d\u7f6e\u7684\u8f6c\u79fb\u8fb9\uff0c\u5e76\u4e14\u8def\u5f84\u957f\u5ea6 $\\leq |T|$\n\n\u73b0\u5728\u8003\u8651\u6709 $[L,R]$ \u7ea6\u675f\u7684\u60c5\u51b5\u3002\u8bbe\u6211\u4eec\u5f53\u524d\u6240\u5728\u72b6\u6001\u4e3a $p$\uff0c\u8981\u8f6c\u79fb\u5230\u7684\u72b6\u6001\u4e3a $q$\u3002\u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u72b6\u6001\u662f\u5426\u5408\u6cd5\u5462\uff1f\u5bf9\u4e8e\u67d0\u4e2a\u72b6\u6001 $q$\uff0c\u5982\u679c\u5176 $\\mathrm{endpos}$ \u96c6\u5408\u4e2d\u5b58\u5728\u67d0\u4e2a\u4f4d\u7f6e $\\mathrm{pos}$\uff0c\u4ee4 $\\mathrm{pos}\\leq R,\\mathrm{pos}-\\mathrm{len}+1\\geq L$\uff0c\u90a3\u4e48\u5bf9\u4e8e\u957f\u5ea6\u4e3a $\\mathrm{len}$ \u7684\u4e32\uff0c\u8fd9\u4e2a\u72b6\u6001\u662f\u53ef\u8fbe\u7684\u3002\n\n\u4e0a\u9762\u90a3\u4e2a\u7ea6\u675f\u663e\u7136\u662f\u4e00\u4e2a\u4e8c\u7ef4\u504f\u5e8f\u95ee\u9898\u3002\u79bb\u7ebf\u5904\u7406\uff0c\u5c06\u6240\u6709\u8be2\u95ee\u6309 $R$ \u4ece\u5c0f\u5230\u5927\u6392\u5e8f\uff0c\u5728 $\\mathrm{lastpos}$ \u5373 $\\mathrm{endpos}$ \u4e2d\u6700\u5927\u7684\u5143\u7d20\u5904\u52a0\u5165\u8d21\u732e\uff0c\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 $\\mathrm{parent}$ \u6811\u4e0a\u5b50\u6811\u5185\u6700\u5927\u7684\u5f53\u524d $\\mathrm{pos}$\u3002\n  \n\u4e3a\u4ec0\u4e48\u662f\u5b50\u6811\u4e0a\u5462\uff1f\u56e0\u4e3a\u5bf9\u4e8e\u4e00\u4e2a\u72b6\u6001 $q$\uff0c\u5176\u5728 $\\text{parent}$ \u6811\u4e0a\u7684\u8282\u70b9 $q$ \u7684\u5b50\u6811\u5185\u5305\u542b\u4e86\u6240\u6709\u72b6\u6001 $q$ \u5bf9\u5e94\u7684\u5b57\u7b26\u4e32\u51fa\u73b0\u7684\u4f4d\u7f6e\u3002 \n  \n\u4e8e\u662f\u5c31\u505a\u5b8c\u4e86\u3002\u5b9e\u73b0\u7528\u4e86\u4e00\u4e9b\u795e\u5947\u7684\u4e1c\u897f\uff0c\u6bd4\u5982 $\\text{InputBuffer,OutputBuffer}$\uff0c\u907f\u514d\u4e86\u4f7f\u7528 $\\text{string}$\u3002\n  \n```cpp\n/* stuff you should look for\n\t* int overflow, array bounds, uppercase/lowercase\n\t* special cases (n=1?)\n\t* do sth. instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n\t* DON'T GET STUCK ON ONE APPROACH\n*/\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n#define ERRRRRR \"plz dont hash it,because we want to test this code again in the reality\"\nchar *Inbuf,*Outbuf;\ninline int read() {\n\tregister int x=0,f=1;register char s=getchar();\n\twhile(s>'9'||s<'0') {if(s=='-') f=-1;s=getchar();}\n\twhile(s>='0'&&s<='9') {x=x*10+s-'0';s=getchar();}\n\treturn x*f;\n}\nstruct SegmentTree {\n\t#define ls p<<1\n\t#define rs p<<1|1\n\tint sgt[800005];\n\tinline int max(const int &x,const int &y) {return x>y? x:y;}\n\tinline void change(int p,int l,int r,int x,int v) {\n\t\tif(l==r) {sgt[p]=max(sgt[p],v); return;}\n\t\tint mid=l+r>>1;\n\t\tif(x<=mid) change(ls,l,mid,x,v);\n\t\telse change(rs,mid+1,r,x,v);\n\t\tsgt[p]=max(sgt[ls],sgt[rs]);\n\t}\n\tinline int ask(int p,int l,int r,int L,int R) {\n\t\tif(L<=l&&r<=R) return sgt[p];\n\t\tint mid=l+r>>1,res=-1;\n\t\tif(L<=mid) res=max(res,ask(ls,l,mid,L,R));\n\t\tif(R>mid) res=max(res,ask(rs,mid+1,r,L,R));\n\t\treturn res;\n\t}\n}SGT;\nnamespace SAM {\n\tstruct node {\n\t\tint len,link;\n\t\tint trans[26];\n\t};\n\tint num,lst,tot,id[200005];\n\tint dfn[200005],high[200005];\n\tstd::vector<int> rev_link[200005];\n\tnode t[200005];\n\tinline void init() {\n\t\tnum=0,lst=0,tot=0; t[0].link=-1;\n\t}\n\tinline void extend(int c,int pos) {\n\t\tint p=lst,cur=++tot; t[cur].len=t[lst].len+1; \n\t\tid[pos]=cur;\n\t\twhile((~p)&&(!t[p].trans[c])) {\n\t\t\tt[p].trans[c]=cur;\n\t\t\tp=t[p].link;\n\t\t}\n\t\tif(!(~p)) {t[cur].link=0;}\n\t\telse {\n\t\t\tint q=t[p].trans[c];\n\t\t\tif(t[p].len+1==t[q].len) t[cur].link=q;\n\t\t\telse {\n\t\t\t\tint cln=++tot;\n\t\t\t\tt[cln]=t[q];\n\t\t\t\tt[cln].len=t[p].len+1;\n\t\t\t\twhile((~p)&&!(t[p].trans[c]^q)) {\n\t\t\t\t\tt[p].trans[c]=cln;\n\t\t\t\t\tp=t[p].link;\n\t\t\t\t}\n\t\t\t\tt[q].link=t[cur].link=cln;\n\t\t\t} \n\t\t}\n\t\tlst=cur;\n\t}\n\tinline void show() {\n\t\tfor(register int i=0;i<=tot;++i) {\n\t\t\tfor(register int j=0;j<26;++j) {\n\t\t\t\tint y=t[i].trans[j];\n\t\t\t\tif(y) printf(\"%d %d %c\\n\",i,y,j+'a');\n\t\t\t}\n\t\t}\n\t}\n\tinline void dfs(int x) {\n\t\tdfn[x]=++num;\n\t\tfor(register size_t i=0;i<rev_link[x].size();++i) dfs(rev_link[x][i]);\n\t\thigh[x]=num;\n\t}\n\tinline void prework() {for(register int i=1;i<=tot;++i) rev_link[t[i].link].push_back(i); dfs(0);}\n}\nstruct query {\n\tint id,L,R;\n\tchar *str;\n}ask[200005];\nchar *ansStr[200005];\nchar s[200005];\ninline bool cmp(const query &lhs,const query &rhs) {return lhs.R<rhs.R;}\ninline bool check(int p,int L,int mLen) {\n\tif(SGT.ask(1,1,SAM::num,SAM::dfn[p],SAM::high[p])-mLen+1>=L) return 1;\n\treturn 0;\n}\ninline char* work(int p,char *str,int L,int mLen) {\n\tif(!(*str)) {\n\t\tfor(register int i=0;i<26;++i) {\n\t\t\tint q=SAM::t[p].trans[i];\n\t\t\tif(q&&check(q,L,mLen+1)) {\n\t\t\t\t*Outbuf=i+'a'; ++Outbuf; return Outbuf;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint q=SAM::t[p].trans[(*str)-'a'];\n\tif(q&&check(q,L,mLen+1)&&work(q,str+1,L,mLen+1)) {\n\t\t*Outbuf=*str; ++Outbuf;\n\t\treturn Outbuf;\n\t}\n\tfor(register int i=(*str)+1-'a';i<26;++i) {\n\t\tq=SAM::t[p].trans[i];\n\t\tif(q&&check(q,L,mLen+1)) {\n\t\t\t*Outbuf=i+'a'; ++Outbuf;\n\t\t\treturn Outbuf;\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n    ERRRRRR;\n\tint n;\n\tscanf(\"%s\",s+1);\n\tn=strlen(s+1);\n\tint Q=read();\n\tInbuf=new char[1000000];\n\tOutbuf=new char[1000000];\n\tchar* testMark=Outbuf;\n\tmemset(Inbuf,0,sizeof(char)*1000000);\n\tmemset(Outbuf,0,sizeof(char)*1000000);\n\t++Outbuf; //++Inbuf;\n\tfor(register int i=1;i<=Q;++i) {\n\t\task[i].id=i;\n\t\task[i].L=read();\n\t\task[i].R=read();\n\t\tscanf(\"%s\",Inbuf);\n\t\tint len=strlen(Inbuf);\n\t\task[i].str=Inbuf;\n\t\tInbuf+=len+1;\n\t}\n\tSAM::init();\n\tfor(register int i=1;i<=n;++i) SAM::extend(s[i]-'a',i);\n\tSAM::prework();\n\tstd::sort(ask+1,ask+1+Q,cmp);\n\tfor(register int id=1,cur=1;id<=Q;++id) {\n\t\twhile(cur<=ask[id].R) {\n\t\t\tSGT.change(1,1,SAM::num,SAM::dfn[SAM::id[cur]],cur);\n\t\t\t++cur;\n\t\t}\n\t\tansStr[ask[id].id]=work(0,ask[id].str,ask[id].L,0); ++Outbuf;\n\t}\n\tfor(register int i=1;i<=Q;++i) {\n\t\tif(!ansStr[i]) printf(\"-1\\n\");\n\t\telse {\n\t\t\tchar *ptr=ansStr[i]-1;\n\t\t\twhile(ptr!=testMark&&(*ptr)) {putchar(*ptr); --ptr;} putchar('\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1623938098,
        "uid": 95244,
        "name": "tommymio",
        "ccfLevel": 6,
        "title": "CF1037H Editorial"
    },
    {
        "content": "\u4e0d\u4f1a\u7ebf\u6bb5\u6811\u5408\u5e76\u600e\u4e48\u529e\n\n\u90a3\u5c31\u786c\u4e0a\u4e3b\u5e2d\u6811\u554a\uff0c\u6811\u4e0a\u4e3b\u5e2d\u6811\u4e5f\u53ef\u4ee5\u7528\u6765\u7ef4\u62a4$endpos$\u96c6\u5408\n\n\u9996\u5148\u5148\u6765\u8003\u8651\u4e00\u4e0b$l=1,r=|S|$\u7684\u60c5\u51b5\u600e\u4e48\u505a\n\n\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u663e\u7136\u7684\u8d2a\u5fc3\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5728$SAM$\u4e0a\u5339\u914d\u8fd9\u4e2a\u5b57\u7b26\u4e32\uff0c\u4e00\u65e6\u65e0\u6cd5\u5339\u914d\u4e0b\u53bb\u6216\u8005\u5df2\u7ecf\u5339\u914d\u5b8c\u6210\u4e86\uff0c\u6211\u4eec\u5c31\u5f3a\u884c\u627e\u4e00\u6761\u5728\u8fd9\u4e2a\u4f4d\u7f6e\u4e0a\u5b57\u5178\u5e8f\u5927\u4e00\u4e9b\u7684\u4e00\u6761\u8f6c\u79fb\u5c31\u597d\u4e86\n\n\u73b0\u5728\u6709\u4e86$l,r$\u7684\u9650\u5236\uff0c\u6211\u4eec\u53ea\u9700\u8981\u4fdd\u8bc1\u6211\u4eec\u5230\u8fbe\u7684\u72b6\u6001\u5728$l,r$\u91cc\u51fa\u73b0\u8fc7\u4e86\u5c31\u597d\u4e86\uff0c\u4e8e\u662f\u6211\u4eec\u7528\u4e00\u4e2a\u4e3b\u5e2d\u6811\u6765\u7ef4\u62a4$parent$\u7684\u5b50\u6811\uff0c\u5c31\u53ef\u4ee5\u7ef4\u62a4\u51fa$endpos$\u96c6\u5408\u4e86\n\n\u6211\u4eec\u6bcf\u5f80\u4e0b\u5339\u914d\u4e00\u4f4d\uff0c\u5c31\u5c06$l++$\uff0c\u56e0\u4e3a\u4e4b\u524d\u5df2\u7ecf\u6709\u4e00\u4e9b\u957f\u5ea6\u4e86\uff0c\u6240\u4ee5$endpos$\u4e0d\u80fd\u53ea\u662f\u5927\u4e8e\u4e4b\u524d\u7684$l$\u4e86\n\n\u6309\u7167\u4e0a\u9762\u7684\u65b9\u6cd5\u6765\u5339\u914d\u5c31\u597d\u4e86\n\n\u4ee3\u7801\n\n```cpp\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define maxn 200005\n#define M 6000005\n#define re register\ninline int read()\n{\n\tchar c=getchar();int x=0;while(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') x=(x<<3)+(x<<1)+c-48,c=getchar();\n\treturn x;\n}\nstruct E{int v,nxt;}e[maxn];\nint lst=1,cnt=1,n,m,__,num,tot,ans,N;\nint l[M],r[M],d[M];\nint len[maxn],endpos[maxn],son[maxn][26],fa[maxn];\nint head[maxn],to[maxn],_to[maxn],sum[maxn],rt[maxn];\nchar S[maxn],out[maxn];\ninline void add(int x,int y){e[++num].v=y;e[num].nxt=head[x];head[x]=num;}\nvoid dfs(int x){to[x]=++__,_to[__]=x;sum[x]=1;for(re int i=head[x];i;i=e[i].nxt) dfs(e[i].v),sum[x]+=sum[e[i].v];}\ninline void ins(int c,int o)\n{\n\tint f=lst,p=++cnt; lst=p;\n\tlen[p]=len[f]+1,endpos[p]=o;\n\twhile(f&&!son[f][c]) son[f][c]=p,f=fa[f];\n\tif(!f) {fa[p]=1;return;}\n\tint x=son[f][c];\n\tif(len[f]+1==len[x]) {fa[p]=x;return;}\n\tint y=++cnt;\n\tlen[y]=len[f]+1,fa[y]=fa[x],fa[x]=fa[p]=y;\n\tfor(re int i=0;i<26;i++) son[y][i]=son[x][i];\n\twhile(f&&son[f][c]==x) son[f][c]=y,f=fa[f];\n}\nint change(int pre,int x,int y,int pos)\n{\n\tint root=++tot;\n\td[root]=d[pre]+1;\n\tif(x==y) return root;\n\tl[root]=l[pre],r[root]=r[pre];\n\tint mid=x+y>>1;\n\tif(pos<=mid) l[root]=change(l[pre],x,mid,pos);\n\t\telse r[root]=change(r[pre],mid+1,y,pos);\n\treturn root;\n}\nint query(int p1,int p2,int x,int y,int pos)\n{\n\tif(x==y) \n\t{\n\t\tif(pos==x) return d[p2]-d[p1];\n\t\treturn 0;\n\t}\n\tint mid=x+y>>1;\n\tif(pos<=mid) return query(l[p1],l[p2],x,mid,pos);\n\treturn d[l[p2]]-d[l[p1]]+query(r[p1],r[p2],mid+1,y,pos);\n}\ninline int check(int t,int x,int y)\n{\n\tint A=to[t],B=to[t]+sum[t]-1;\n\treturn query(rt[A-1],rt[B],1,N,y)-query(rt[A-1],rt[B],1,N,x-1);\n}\nint work(int now,int x,int y,int L)\n{\n\tint b=0;\n\tif(L==n+1) \n\t{\n\t\tfor(re int i=0;i<26;i++)\n\t\tif(son[now][i]&&check(son[now][i],x,y)) {ans=L,b=1,out[L]=i;break;}\n\t\treturn b;\n\t}\n\tif(son[now][S[L]-'a'])\n\t{\n\t\tint t=son[now][S[L]-'a'];\n\t\tif(check(t,x,y)) b=work(t,x+1,y,L+1);\n\t\tif(b) out[L]=S[L]-'a';\n\t}\n\tif(b) return b;\n\tfor(re int i=S[L]+1-'a';i<26;i++) \n\tif(son[now][i]&&check(son[now][i],x,y)) {ans=L,b=1,out[L]=i;break;}\n\treturn b;\n}\nint main()\n{\n\tscanf(\"%s\",S+1);n=strlen(S+1);N=n;\n\tfor(re int i=1;i<=n;i++) ins(S[i]-'a',i);\n\tfor(re int i=2;i<=cnt;i++) add(fa[i],i); dfs(1);\n\tfor(re int i=1;i<=cnt;i++)\n\t{\n\t\tif(endpos[_to[i]]) rt[i]=change(rt[i-1],1,n,endpos[_to[i]]);\n\t\t\telse rt[i]=rt[i-1];\n\t}\n\tm=read();int x,y;\n\twhile(m--)\n\t{\n\t\tx=read(),y=read();\n\t\tscanf(\"%s\",S+1);n=strlen(S+1);\n\t\tif(!work(1,x,y,1)) puts(\"-1\");\n\t\t\telse {for(re int i=1;i<=ans;i++) putchar(out[i]+'a');putchar(10);}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1547640443,
        "uid": 35178,
        "name": "asuldb",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "\u6765\u70b9\u4e0d\u9700\u8981\u540e\u7f00\u6570\u636e\u7ed3\u6784\u7684\u505a\u6cd5\u3002~~\u867d\u7136\u5176\u4e2d\u6709\u4e9b\u8fc7\u7a0b\u53ef\u4ee5\u7528\u540e\u7f00\u6570\u636e\u7ed3\u6784\u4f18\u5316\u3002~~\n\n\u9996\u5148\u6211\u4eec\u9700\u8981\u6ce8\u610f\u5230\u4e00\u4e2a\u6027\u8d28\uff1a\n\n- \u82e5\u6ee1\u8db3\u6761\u4ef6\u7684 $S_1$ \u5b58\u5728\uff0c\u5219 $|S_1| \\leq |T| + 1$\u3002\n\n\u53c8\u6ce8\u610f\u5230 $\\sum |T| \\leq 2 \\times 10^5$\uff0c\u8003\u8651\u6839\u53f7\u5206\u6cbb\u3002\u73b0\u5728\u6211\u4eec\u6709\u4e00\u4e2a\u9608\u503c $U$\u3002\n\n1. $|T| < U$\n\n\u8003\u8651\u5bf9\u6bcf\u4e2a $i \\leq U$\uff0c\u9884\u5904\u7406\u957f\u4e3a $i$ \u7684\u6240\u6709\u5b50\u4e32\u7684\u5b57\u5178\u5e8f\u5173\u7cfb\u3002\n\n\u4e3a\u4e86\u65b9\u4fbf\uff0c\u8fd9\u91cc\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u6392\u5e8f + \u4e8c\u5206\u54c8\u5e0c\u3002~~\u5efa\u8bae\u4f7f\u7528 `stable_sort`\u3002~~\n\n\u73b0\u5728\u6211\u4eec\u679a\u4e3e\u6700\u7ec8\u6240\u5f97 $S_1$ \u7684\u957f\u5ea6\uff0c\u6709 $|S_1| \\leq |T| + 1 \\leq U$\u3002\n\n\u5728\u5b58\u957f\u5ea6\u4e3a $|S_1|$ \u7684\u6240\u6709\u5b50\u4e32\u7684\u90a3\u4e2a\u5b57\u5178\u5e8f\u6392\u5e8f\u7684\u6570\u7ec4\u4e0a\u4e8c\u5206\u54c8\u5e0c\uff0c\u627e\u51fa\u7b2c\u4e00\u4e2a\u5b57\u5178\u5e8f\u4e25\u683c\u5927\u4e8e $T$ \u7684\u5b50\u4e32\uff0c\u5219\u5927\u4e8e\u7b49\u4e8e\u8fd9\u4e2a\u5b50\u4e32\u4e14\u5de6\u7aef\u70b9\u5728 $[L, R - |S_1| + 1]$ \u8303\u56f4\u5185\u7684\u5b50\u4e32\u90fd\u53ef\u4ee5\u9009\u3002\u8fd9\u4e2a\u79bb\u7ebf\u4e0b\u6765\u4e8c\u7ef4\u6570\u70b9\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(U(|S| + q) \\log^2 |S|)$\u3002\n\n2. $|T| \\geq U$\n\n\u6ee1\u8db3\u8be5\u6761\u4ef6\u7684\u8be2\u95ee\u6570\u91cf $\\leq \\dfrac{\\sum |T|}{U}$\uff0c\u5219\u66b4\u529b\u904d\u5386 $[L, R]$ \u4e2d\u7684\u6bcf\u4e2a\u5de6\u7aef\u70b9\u5e76\u4e8c\u5206\u54c8\u5e0c\u5373\u53ef\u3002\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(\\dfrac{|S| \\sum |T| \\log |S|}{U})$\u3002\n\n\u7efc\u4e0a\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(U(|S| + q) \\log^2 |S| + \\dfrac{|S| \\sum |T| \\log |S|}{U})$\uff0c\u5219 $U = \\sqrt{\\dfrac{|S| \\sum |T|}{(|S| + q) \\log |S|}}$ \u65f6\u53d6\u5f97\u6700\u4f18\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(\\sqrt{S(|S| + q) \\sum |T|} \\log^{\\frac{3}{2}} |S|)$\u3002\n\n\u4ee3\u7801\u5b9e\u73b0\u4e2d\u53d6 $U = 25$\u3002\u9700\u8981\u4e00\u4e9b\u5e38\u6570\u4f18\u5316\u548c\u5927\u91cf\u526a\u679d\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 2e5, seed = 998244353, mod = 1e9 + 7;\nint power[N + 7];\n\ninline int add(int x, int y){\n\treturn x + y >= mod ? x + y - mod : x + y;\n}\n\ninline int sub(int x, int y){\n\treturn x - y < 0 ? x - y + mod : x - y;\n}\n\ntypedef struct {\n\tint hash[N + 7];\n\t\n\tinline void init(char s[]){\n\t\tint len = strlen(&s[1]);\n\t\tfor (register int i = 1; i <= len; i++){\n\t\t\thash[i] = add(1ll * hash[i - 1] * seed % mod, s[i]);\n\t\t}\n\t}\n\t\n\tinline int get_hash(int l, int r){\n\t\treturn sub(hash[r], 1ll * hash[l - 1] * power[r - l + 1] % mod);\n\t}\n} Hash;\n\ntypedef struct Pair_tag {\n\tint first;\n\tint second;\n\tPair_tag(){}\n\tPair_tag(int first_, int second_){\n\t\tfirst = first_;\n\t\tsecond = second_;\n\t}\n} Pair;\n\ntypedef struct Query_tag {\n\tint id;\n\tint pos;\n\tint l;\n\tint r;\n\tQuery_tag(){}\n\tQuery_tag(int id_, int pos_, int l_, int r_){\n\t\tid = id_;\n\t\tpos = pos_;\n\t\tl = l_;\n\t\tr = r_;\n\t}\n} Query;\n\ntypedef struct {\n\tint l;\n\tint r;\n\tPair min;\n} Node;\n\nconst int M = 1e5 + 7, K = 4e5 + 7, thresold = 25;\nHash hashs, hashx;\nint cnt1[thresold + 7], cnt2[thresold + 7], ansl[N + 7], ansr[N + 7];\nchar s[M], x[N + 7];\nPair pr[thresold + 1][M];\nQuery query[thresold + 1][N + 7];\nNode tree[K];\nvector<Pair> v[N + 7];\n\nbool operator <(const Pair a, const Pair b){\n\treturn a.first < b.first;\n}\n\nbool operator <(const Query a, const Query b){\n\treturn a.pos > b.pos;\n}\n\ninline void init(){\n\tpower[0] = 1;\n\tfor (register int i = 1; i <= N; i++){\n\t\tpower[i] = 1ll * power[i - 1] * seed % mod;\n\t}\n}\n\ninline bool cmp1(Pair a, Pair b){\n\tint lena = a.second - a.first + 1, lenb = b.second - b.first + 1, r = min(lena, lenb), t = min(r - 1, 20), lcp = 0;\n\twhile (lcp < t && s[a.first + lcp] == s[b.first + lcp]) lcp++;\n\tif (s[a.first + lcp] != s[b.first + lcp]) return s[a.first + lcp] < s[b.first + lcp];\n\tint l = lcp + 1;\n\twhile (l <= r){\n\t\tint mid = (l + r) >> 1;\n\t\tif (hashs.get_hash(a.first, a.first + mid - 1) == hashs.get_hash(b.first, b.first + mid - 1)){\n\t\t\tl = mid + 1;\n\t\t\tlcp = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\tif (lcp == lena) return lena < lenb;\n\tif (lcp == lenb) return false;\n\treturn s[a.first + lcp] < s[b.first + lcp];\n}\n\ninline bool cmp2(int lenx, Pair a){\n\tint lena = a.second - a.first + 1, r = min(lenx, lena), t = min(r - 1, 20), lcp = 0;\n\twhile (lcp < t && x[lcp + 1] == s[a.first + lcp]) lcp++;\n\tif (x[lcp + 1] != s[a.first + lcp]) return x[lcp + 1] < s[a.first + lcp];\n\tint l = lcp + 1;\n\twhile (l <= r){\n\t\tint mid = (l + r) >> 1;\n\t\tif (hashx.hash[mid] == hashs.get_hash(a.first, a.first + mid - 1)){\n\t\t\tl = mid + 1;\n\t\t\tlcp = mid;\n\t\t} else {\n\t\t\tr = mid - 1;\n\t\t}\n\t}\n\tif (lcp == lenx) return lenx < lena;\n\tif (lcp == lena) return false;\n\treturn x[lcp + 1] < s[a.first + lcp];\n}\n\nvoid build1(int x, int l, int r){\n\ttree[x].l = l;\n\ttree[x].r = r;\n\tif (l == r) return;\n\tint mid = (l + r) >> 1;\n\tbuild1(x * 2, l, mid);\n\tbuild1(x * 2 + 1, mid + 1, r);\n}\n\nvoid build2(int x){\n\ttree[x].min = Pair(0x7fffffff, 0);\n\tif (tree[x].l == tree[x].r) return;\n\tbuild2(x * 2);\n\tbuild2(x * 2 + 1);\n}\n\nvoid modify(int x, int pos, Pair pr){\n\ttree[x].min = min(tree[x].min, pr);\n\tif (tree[x].l == tree[x].r) return;\n\tif (pos <= ((tree[x].l + tree[x].r) >> 1)){\n\t\tmodify(x * 2, pos, pr);\n\t} else {\n\t\tmodify(x * 2 + 1, pos, pr);\n\t}\n}\n\nPair get_min(int x, int l, int r){\n\tif (tree[x].min.first == 0x7fffffff || (l <= tree[x].l && tree[x].r <= r)) return tree[x].min;\n\tint mid = (tree[x].l + tree[x].r) >> 1;\n\tif (l > mid) return get_min(x * 2 + 1, l, r);\n\tif (r <= mid) return get_min(x * 2, l, r);\n\treturn min(get_min(x * 2, l, r), get_min(x * 2 + 1, l, r));\n}\n\nint main(){\n\tint lens, q;\n\tscanf(\"%s\", &s[1]);\n\tlens = strlen(&s[1]);\n\thashs.init(s);\n\tinit();\n\tfor (register int i = 1; i <= thresold; i++){\n\t\tfor (register int j = 1, k = i; k <= lens; j++, k++){\n\t\t\tpr[i][++cnt1[i]] = Pair(j, k);\n\t\t}\n\t\tstable_sort(pr[i] + 1, pr[i] + cnt1[i] + 1, cmp1);\n\t}\n\tscanf(\"%d\", &q);\n\tfor (register int i = 1; i <= q; i++){\n\t\tint l, r, lenx;\n\t\tscanf(\"%d %d %s\", &l, &r, &x[1]);\n\t\tlenx = strlen(&x[1]);\n\t\tansl[i] = ansr[i] = -1;\n\t\thashx.init(x);\n\t\tif (lenx < thresold){\n\t\t\tint up = min(lenx + 1, r - l + 1);\n\t\t\tfor (register int j = 1; j <= up; j++){\n\t\t\t\tint L = 1, R = cnt1[j], pos = -1;\n\t\t\t\twhile (L <= R){\n\t\t\t\t\tint mid = (L + R) >> 1;\n\t\t\t\t\tif (cmp2(lenx, pr[j][mid])){\n\t\t\t\t\t\tR = mid - 1;\n\t\t\t\t\t\tpos = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tL = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pos != -1) query[j][++cnt2[j]] = Query(i, pos, l, r - j + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (register int j = l; j <= r; j++){\n\t\t\t\tint R = min(lenx, r - j + 1), t = min(R - 1, 20), lcp = 0;\n\t\t\t\twhile (lcp < t && x[lcp + 1] == s[j + lcp]) lcp++;\n\t\t\t\tif (x[lcp + 1] == s[j + lcp]){\n\t\t\t\t\tint L = lcp + 1;\n\t\t\t\t\twhile (L <= R){\n\t\t\t\t\t\tint mid = (L + R) >> 1;\n\t\t\t\t\t\tif (hashs.get_hash(j, j + mid - 1) == hashx.hash[mid]){\n\t\t\t\t\t\t\tL = mid + 1;\n\t\t\t\t\t\t\tlcp = mid;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tR = mid - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lcp != r - j + 1 && (lcp == lenx || s[j + lcp] > x[lcp + 1]) && ((ansl[i] == -1 && ansr[i] == -1) || (cmp1(Pair(j, j + lcp), Pair(ansl[i], ansr[i]))))){\n\t\t\t\t\tansl[i] = j;\n\t\t\t\t\tansr[i] = j + lcp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbuild1(1, 1, lens);\n\tfor (register int i = 1; i <= thresold; i++){\n\t\tbuild2(1);\n\t\tsort(query[i] + 1, query[i] + cnt2[i] + 1);\n\t\tfor (register int j = cnt1[i], k = 1; j >= 1; j--){\n\t\t\tmodify(1, pr[i][j].first, Pair(j, pr[i][j].first));\n\t\t\twhile (k <= cnt2[i] && query[i][k].pos == j){\n\t\t\t\tint x = get_min(1, query[i][k].l, query[i][k].r).second;\n\t\t\t\tif (x != 0) v[query[i][k].id].push_back(Pair(x, x + i - 1));\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t}\n\tfor (register int i = 1; i <= q; i++){\n\t\tint size = v[i].size();\n\t\tfor (register int j = 0; j < size; j++){\n\t\t\tif ((ansl[i] == -1 && ansr[i] == -1) || (cmp1(Pair(v[i][j].first, v[i][j].second), Pair(ansl[i], ansr[i])))){\n\t\t\t\tansl[i] = v[i][j].first;\n\t\t\t\tansr[i] = v[i][j].second;\n\t\t\t}\n\t\t}\n\t\tif (ansl[i] == -1 && ansr[i] == -1){\n\t\t\tprintf(\"-1\");\n\t\t} else {\n\t\t\tfor (register int j = ansl[i]; j <= ansr[i]; j++){\n\t\t\t\tputchar(s[j]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1673521769,
        "uid": 201007,
        "name": "Leasier",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF1037H \u3010Security\u3011"
    },
    {
        "content": "### \u601d\u8def\n\n\u7ebf\u6bb5\u6811\u5408\u5e76$+\\text{sam}$\u3002\n\n\u8003\u8651\u6ca1\u6709 $\\text{l,r}$ \u7684\u9650\u5236\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u76f4\u63a5\u5728 $\\text{sam}$ \u4e0a\u8fdb\u884c\u8d2a\u5fc3\u7684\u6c42\u89e3\u3002\n\n\u5177\u4f53\u6765\u8bf4\uff0c\u6bcf\u4e00\u6b21\u5148\u6c42\u51fa\u6700\u957f\u7684\u524d\u7f00\uff0c\u4e00\u76f4\u5230\u6ca1\u6709\u5408\u6cd5\u7684\u5b57\u7b26\u65f6\uff0c\u5c31\u53ef\u4ee5\u7ec8\u6b62\u3002\n\n\u7136\u540e\u5728\u540e\u7f00\u4e2d\uff0c\u4ece\u540e\u5f80\u524d\u9009\u51fa\u7b2c\u4e00\u4e2a\u66f4\u5927\u7684\u5b57\u7b26\u3002\n\n\u82e5\u662f\u5230\u6839\u8282\u70b9\u65f6\uff0c\u8fd8\u6ca1\u6709\u627e\u51fa\u4e00\u4e2a\u5408\u6cd5\u7684\u65b9\u6848\uff0c\u90a3\u4e48\u5c31\u4ee3\u8868\u6b64\u65f6\u6ca1\u6709\u4e00\u4e2a\u5408\u6cd5\u7684\u89e3\u3002\n\n\u8003\u8651\u6709\u4e86 $\\text{l,r}$ \u7684\u9650\u5236\uff0c\u5982\u4f55\u6765\u6c42\u89e3\u3002\n\n\u8003\u8651\u6bcf\u4e00\u4e2a\u8282\u70b9\u90fd\u7ef4\u62a4\u7740\u4e00\u4e2a\u524d\u7f00\u7684 $\\text{endpos}$ \u7b49\u4ef7\u7c7b\u3002\n\n\u53ef\u4ee5\u4f7f\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u7ef4\u62a4\u51fa\u8fd9\u4e00\u4e2a\u4e1c\u897f\u3002\n\n\u67e5\u8be2\u65f6\u5c31\u53ef\u4ee5\u5728\u7ebf\u6bb5\u6811\u4e0a\u67e5\u8be2\u6b64\u65f6\u7684\u72b6\u6001\u662f\u5426\u53ef\u4ee5\u627e\u5230\u4efb\u610f\u4e00\u4e2a $\\text{l,r}$ \u4e2d\u7684\u72b6\u6001\u3002\n\n\u4ee3\u7801\u4e0d\u600e\u4e48\u597d\u5199\u3002\n\n\u5982\u679c\u4f60 $\\text{WA on test 9}$\uff0c\u53ef\u80fd\u662f\u4f60 $\\text{sam}$ \u5199\u9519\u4e86\u3002\n\n\u5982\u679c\u4f60 $\\text{TLE on test 10}$\uff0c\u53ef\u80fd\u662f\u4f60\u7ebf\u6bb5\u6811\u5199\u9519\u4e86\u6216\u8005\u6570\u7ec4\u5f00\u5c0f\u4e86\u3002\n\n~~\u4e0d\u8981\u95ee\u6211\u600e\u4e48\u77e5\u9053\u7684\u3002~~\n\n### Code\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200010;\n\nint n, m, cnt, tot = 1, last = 1;\nint tim, rt[N], stk[N], head[N];\nchar s[N];\n\nstruct edge { int to, nxt; } e[N * 2];\nstruct Node { int fa, len, to[26]; } d[N];\nstruct Tree { int son[2], val; } t[N * 32];\n\ninline int read()\n{\n    int asd = 0 , qwe = 1; char zxc;\n    while(!isdigit(zxc = getchar())) if(zxc == '-') qwe = -1;\n    while(isdigit(zxc)) asd = asd * 10 + zxc - '0' , zxc = getchar();\n    return asd * qwe;\n}\n\ninline void insert(int &p , int x , int l = 1 , int r = n)\n{\n    if(!p) p = ++tim;\n    t[p].val |= 1; if (l == r) return;\n    int mid = (l + r) / 2;\n    if(x <= mid) insert(t[p].son[0], x, l, mid);\n    else insert(t[p].son[1], x, mid + 1, r);\n}\n\ninline void add(int x, int y)\n{\n    e[++cnt] = {y, head[x]}, head[x] = cnt;\n}\n\ninline int merge(int x , int y)\n{\n    if(!x || !y) return x | y;\n    int pos = ++tim;\n    t[pos].son[0] = merge(t[x].son[0], t[y].son[0]);\n    t[pos].son[1] = merge(t[x].son[1], t[y].son[1]);\n    return pos;\n}\n\ninline int ask(int p , int ls , int rs , int l = 1,  int r = n)\n{\n    if (!p) return 0;\n    if(ls <= l && r <= rs) return 1;\n    int mid = (l + r) / 2;\n    if (ls <= mid && ask(t[p].son[0], ls, rs, l, mid)) return 1;\n    if(rs > mid && ask(t[p].son[1], ls, rs, mid + 1, r)) return 1; \n    return 0;\n}\n\ninline void dfs(int now)\n{\n    for (int i = head[now]; i; i = e[i].nxt)\n        dfs(e[i].to), rt[now] = merge(rt[now], rt[e[i].to]);\n}\n\ninline void extend(int x)\n{\n    int p = last, np = last = ++tot;\n    d[np].len = d[p].len + 1;\n    for (;p && !d[p].to[x];p = d[p].fa)\n        d[p].to[x] = np;\n    if(!p)\n        d[np].fa = 1;\n    else\n    {\n        int q = d[p].to[x];\n        if(d[p].len + 1 == d[q].len)\n            d[np].fa = q;\n        else\n        {\n            int nq = ++tot;\n            d[nq] = d[q], d[nq].len = d[p].len + 1;\n            d[q].fa = d[np].fa = nq;\n            for (; p && d[p].to[x] == q;p = d[p].fa)\n                d[p].to[x] = nq;\n        }\n    }\n}\n\ninline bool calc(int l , int r , int x , int len)\n{\n    int ls = l + len - 1;\n    if (ls > r) return 0;\n    else return ask(rt[x], ls, r);\n}\n\nint main()\n{\n    cin >> s, n = strlen(s);\n    for (int i = 1; i <= n; i++)\n        extend(s[i - 1] - 'a');\n    int p = 1;\n    for (int i = 1; i <= n; i++)\n        p = d[p].to[s[i - 1] - 'a'], insert(rt[p], i);\n    for (int i = 1; i <= tot;i++)\n        add(d[i].fa, i);\n    dfs(1), m = read();\n    while (m--)\n    {\n        int l = read(), r = read(); cin >> s;\n        int len = strlen(s), top = 0;\n        stk[top] = p = 1;\n        for (int j = 1; j <= len; j++)\n        {\n            int v = d[p].to[s[j - 1] - 'a'];\n            if (v && calc(l , r , v , j - 1)) stk[++top] = p = v;\n            else break;\n        }\n        s[len] = 'a' - 1; int last = 114514;\n        for (; last == 114514 && top >= 0; top--)\n        {\n            p = stk[top];\n            for (int j = s[top] + 1 - 'a'; j < 26; j++)\n            {\n                if (d[p].to[j] && calc(l, r, d[p].to[j], top + 1))\n                {\n                    last = j;\n                    break;\n                }\n            }\n        }\n        if (last == 114514)\n            puts(\"-1\");\n        else\n        {\n            for (int i = 0; i <= top;i++)\n                putchar(s[i]);\n            putchar(last + 'a'), putchar('\\n');\n        }\n    }\n    return 0;\n}\n```\n",
        "postTime": 1668077676,
        "uid": 320933,
        "name": "Mfeitveer",
        "ccfLevel": 0,
        "title": "CF1037H Security \u9898\u89e3"
    },
    {
        "content": "[\u9898\u9762](https://www.luogu.org/problemnew/show/CF1037H)\n\n\u540e\u7f00\u81ea\u52a8\u673a\u3002\n\n\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u9053\u9898\u3002\u9996\u5148\u7ebf\u6bb5\u6811\u5408\u5e76\u6c42\u51fa$right$\u96c6\u5408\uff0c\u7136\u540e\u6709\u4e00\u4e2a~~\u975e\u5e38\u5bb9\u6613\u7684~~\u8d2a\u5fc3\uff0c\u56e0\u4e3a\u5b57\u5178\u5e8f\u8981\u6c42\u6700\u5c0f\uff0c\u6240\u4ee5\u53ef\u4ee5\u4ece\u540e\u5f80\u524d\u5339\u914d\u3002\u63a5\u7740\u5c31\u505a\u5b8c\u4e86\u3002\u5bf9\u4e8e\u6bcf\u7ec4\u8be2\u95ee\uff0c\u8bb0\u5f55\u4e00\u4e0b$T$\u5728\u81ea\u52a8\u673a\u4e0a\u5339\u914d\u5230\u7684\u4f4d\u7f6e\uff0c\u7136\u540e\u4ece\u540e\u5f80\u524d\u679a\u4e3e\u6bcf\u4e00\u4f4d\uff0c\u5e76\u4e14\u679a\u4e3e\u6bcf\u4e00\u4f4d\u7684\u5b57\u7b26\uff0c\u5982\u679c\u5728$l$\u5230$r$\u7684$right$\u96c6\u5408\u91cc\uff0c\u8bf4\u660e\u662f\u53ef\u884c\u7684\uff0c\u5426\u5219\u7ee7\u7eed\u627e\u3002\u8fd9\u4e2a\u5224\u65ad\u53ef\u4ee5\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6389\uff0c\u4e8e\u662f\u5c31\u597d\u4e86\u3002\n\ncode:\n```\n//2018.11.16 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-15\ninline int read(){\n    res s=0;\n    bool w=0;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')w=1;ch=getchar();}\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return w?-s:s;\n}\ninline void _swap(res &x,res &y){\n    x^=y^=x^=y;\n}\ninline int _abs(const res &x){\n    return x>0?x:-x;\n}\ninline int _max(const res &x,const res &y){\n    return x>y?x:y;\n}\ninline int _min(const res &x,const res &y){\n    return x<y?x:y;\n}\nconst int N=2e5+10;\nnamespace MAIN{\n    struct SAM{\n        struct Sam{\n            int vis[26],par,len;\n        }sam[N<<1];\n        int cnt,las,rt;\n        SAM() {cnt=las=rt=1;}\n        inline void extend(const res &x){\n            res p=las,np=++cnt;\n            las=np,sam[np].len=sam[p].len+1;\n            for(;p&&!sam[p].vis[x];p=sam[p].par)sam[p].vis[x]=np;\n            if(!p)sam[np].par=rt;\n            else {\n                res q=sam[p].vis[x];\n                if(sam[q].len==sam[p].len+1)sam[np].par=q;\n                else {\n                    res nq=++cnt;\n                    memcpy(sam[nq].vis,sam[q].vis,sizeof(sam[nq].vis));\n                    sam[nq].len=sam[p].len+1,sam[nq].par=sam[q].par,sam[q].par=sam[np].par=nq;\n                    for(;p&&sam[p].vis[x]==q;p=sam[p].par)sam[p].vis[x]=nq;\n                }\n            }\n        }\n    }A;\n    int n;\n    char str[N];\n    int sum[N<<6],ls[N<<6],rs[N<<6],rt[N<<1],tot;\n    inline void pushup(const res &rt){\n        sum[rt]=sum[ls[rt]]+sum[rs[rt]];\n    }\n    void update(res &rt,const res &l,const res &r,const res &p){\n        if(!rt)rt=++tot;\n        if(l==r){sum[rt]++;return;}\n        res mid=(l+r)>>1;\n        if(p<=mid)update(ls[rt],l,mid,p);\n        else update(rs[rt],mid+1,r,p);\n        pushup(rt);\n    }\n    int query(const res &rt,const res &l,const res &r,const res &L,const res &R){\n        if(!rt)return 0;\n        if(L<=l&&r<=R)return sum[rt];\n        res mid=(l+r)>>1,ret=0;\n        if(L<=mid)ret+=query(ls[rt],l,mid,L,R);\n        if(R>mid)ret+=query(rs[rt],mid+1,r,L,R);\n        return ret;\n    }\n    int merge(const res &x,const res &y,const res &l,const res &r){\n        if(!x||!y)return x+y;\n        if(l==r){sum[x]+=sum[y];return x;}\n        res mid=(l+r)>>1,z=++tot;\n        ls[z]=merge(ls[x],ls[y],l,mid);\n        rs[z]=merge(rs[x],rs[y],mid+1,r);\n        pushup(z);\n        return z;\n    }\n    int buc[N<<1],rnk[N<<1];\n    int Q;\n    int pos[N<<1];\n    inline void MAIN(){\n        scanf(\"%s\",str+1);\n        Q=read();\n        n=strlen(str+1);\n        for(res i=1;i<=n;i++)A.extend(str[i]-'a'),update(rt[A.las],1,n,i);\n        for(res i=1;i<=A.cnt;i++)buc[A.sam[i].len]++;\n        for(res i=1;i<=A.cnt;i++)buc[i]+=buc[i-1];\n        for(res i=1;i<=A.cnt;i++)rnk[buc[A.sam[i].len]--]=i;\n        for(res i=A.cnt;i>1;i--)rt[A.sam[rnk[i]].par]=merge(rt[A.sam[rnk[i]].par],rt[rnk[i]],1,n);\n        pos[0]=1;\n        while(Q--){\n            res l=read(),r=read();\n            scanf(\"%s\",str+1);\n            res m=strlen(str+1),lim=m;\n            for(res i=1,now=1;i<=m;i++){\n                res x=str[i]-'a';\n                if(A.sam[now].vis[x])now=A.sam[now].vis[x],pos[i]=now;\n                else {lim=i-1;break;}\n            }\n            bool flag=0;\n            for(res i=lim;~i;i--){\n                if(flag)break;\n                for(res j=(i<m?str[i+1]-'a'+1:0);j<26;j++)\n                    if(query(rt[A.sam[pos[i]].vis[j]],1,n,l+i,r)){\n                        for(res k=1;k<=i;k++)putchar(str[k]);\n                        putchar(j+'a'),puts(\"\");\n                        flag=1;\n                        break;\n                    }\n            }\n            if(!flag)puts(\"-1\");\n        }\n    }\n}\nint main(){\n    MAIN::MAIN();\n    return 0;\n}\n```",
        "postTime": 1542351593,
        "uid": 32878,
        "name": "foreverlasting",
        "ccfLevel": 7,
        "title": "\u3010CF1037H\u3011Security"
    },
    {
        "content": "\u5176\u5b9e\u611f\u89c9\u9488\u5bf9\u8fd9\u9053\u9898\u800c\u8a00\uff0c\u540e\u7f00\u6570\u7ec4\u7684\u60f3\u6cd5\u81ea\u7136\u4f46\u662f\u786e\u5b9e\u6ca1\u6709 SAM \u7b80\u5355\u2026\u2026\n\n-------------------------------------\n\n\u6211\u4eec\u8d2a\u5fc3\uff0c\u5c3d\u91cf\u8ba9\u524d\u9762\u8d8a\u591a\u4f4d\u4e0e $T$ \u80fd\u5339\u914d\u6700\u540e\u518d\u5c1d\u8bd5\u8865\u4e0a\u4e00\u4e2a\u5927\u4e8e\u76f8\u5bf9\u4f4d\u7f6e\u7684\u5b57\u7b26\u3002\n\n\u627e\u5230\u6700\u540e\u4e00\u4e2a\u5728 $[L,R]$ \u7684\u5b50\u4e32\u4e2d\u7684 $T$ \u7684\u524d\u7f00 $[1,i]$\uff0c\u8fd9\u4e2a\u53ef\u4ee5\u7ebf\u6bb5\u6811\u5408\u5e76\u5f97\u5230\u6bcf\u4e2a\u70b9\u7684 endpos \u96c6\u5408\u7136\u540e\u8ba9 $T$ \u5728 SAM \u4e0a\u8dd1\u540e\u7f00\u6240\u5728\u7684\u72b6\u6001\u70b9\uff0c\u5728\u70b9\u7684\u7ebf\u6bb5\u6811\u4e0a\u533a\u95f4\u67e5\u4e00\u4e0b\u662f\u5426\u6709\u5408\u6cd5\u7684 endpos \u5373\u53ef\u3002\n\n\u63a5\u7740\u5012\u7740\u8003\u8651\u6bcf\u4e2a\u524d\u7f00\u80fd\u5426\u5f80\u540e\u9762\u6dfb\u52a0\u4e00\u4e2a\u5b57\u7b26\u5373\u53ef\uff0c\u8fd9\u91cc\u679a\u4e3e\u8fd9\u4e2a\u5b57\u7b26\u540e\u5f80\u540e\u9762\u52a0\u5c31\u597d\u4e86\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6 $O(26n \\log n)$\u3002\n\n```cpp\n/*\n\u7ebf\u6bb5\u6811\u5408\u5e76\u539f\u6765\u8fd8\u53ef\u4ee5\u5728\u7ebf\n\u4f46\u662f\u8fd9\u4e2a\u65f6\u95f4\u590d\u6742\u5ea6\u600e\u4e48\u7b97\u554a/yjw\n\u5982\u679c\u6709\u76f8\u540c\u7684\u70b9\u5c31\u591a\u5f00\u4e00\u4e2a\u70b9\u4f5c\u4e3a\u72ec\u7acb\u7ed3\u6784\n\u73b0\u5728\u662f\u5c5e\u4e8e\u6bcf\u6b21\u591a\u5f00\u4e00\u4e2a\u70b9\u4f46\u662f\u6254\u4e24\u4e2a\u70b9\uff0c\u6240\u4ee5\u7a7a\u95f4\u590d\u6742\u5ea6\u8fd8\u662f n \\log n \u7684\n\u65f6\u95f4\u590d\u6742\u5ea6\u7684\u8bdd\uff0c\u5c31\u662f\u7a7a\u95f4\u590d\u6742\u5ea6\uff08\u80fd\u8d70\u5230\u7684\u70b9\u7684\u6570\u91cf\uff09\n\u611f\u89c9\u8fd9\u4e2a\u505a\u6cd5\u6709\u70b9\u65e0\u654c \n*/\n#include \"bits/stdc++.h\"\nusing namespace std;\nconst int Len = 2e5 + 5;\nint n,m;\nstruct Node\n{\n\tint ch[28];\n\tint len,fa;\n\tNode(){len = fa = 0;memset(ch , 0 , sizeof ch);}\n};\nstruct node\n{\n\tint next,to;\n};\nstruct Seg\n{\n\tint lc[Len * 45],rc[Len * 45],tot;\n\tvoid update(int &p,int l,int r,int idx)\n\t{\n\t\tif(!p) p = ++ tot;\n\t\tif(l == r) return;\n\t\tint mid = (l + r) >> 1;\n\t\tif(idx <= mid) update(lc[p] , l , mid , idx);\n\t\telse update(rc[p] , mid + 1 , r , idx);\n\t}\n\tint query(int p,int l,int r,int nl,int nr)\n\t{\n\t\tif(!p) return 0;\n\t\tif(nl <= l && nr >= r) return 1;\n\t\tint mid = (l + r) >> 1 , res = 0;\n\t\tif(nl <= mid) res |= query(lc[p] , l , mid , nl , nr);\n\t\tif(nr > mid) res |= query(rc[p] , mid + 1 , r , nl , nr);\n\t\treturn res;\n\t}\n\tint merge(int x,int y)\n\t{\n\t\tif(!x || !y) return x + y;\n\t\tint p = ++ tot;\n\t\tlc[p] = merge(lc[x] , lc[y]);\n\t\trc[p] = merge(rc[x] , rc[y]);\n\t\treturn p;\n\t}\n}S1;\nstruct Suf_Auto\n{\n\tNode t[Len << 1];node edge[Len << 2];\n\tint tot,cnt,head[Len << 1],rt[Len << 1];\n\tSuf_Auto(){tot = 1;}\n\tvoid add(int from,int to)\n\t{\n\t\tedge[++ cnt].to = to;\n\t\tedge[cnt].next = head[from];\n\t\thead[from] = cnt;\n\t}\n\tinline int Add(int c,int lst,int IDX)\n\t{\n\t\tif(t[lst].ch[c])\n\t\t{\n\t\t\tint p = lst , q = t[lst].ch[c];\n\t\t\tif(t[q].len == t[p].len + 1){S1.update(rt[q] , 1 , n , IDX);return q;}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nq = ++ tot;t[nq] = t[q];\n\t\t\t\tt[nq].len = t[p].len + 1;\n\t\t\t\tt[q].fa = nq;\n\t\t\t\tfor( ; p && t[p].ch[c] == q ; p = t[p].fa) t[p].ch[c] = nq;\n\t\t\t\tS1.update(rt[nq] , 1 , n , IDX);\n\t\t\t\treturn nq;\t\n\t\t\t}\n\t\t}\t\n\t\tint p = lst;\n\t\tint np = lst = ++ tot;\n\t\tt[np].len = t[p].len + 1;\n\t\tfor( ; p && !t[p].ch[c] ; p = t[p].fa) t[p].ch[c] = np;\n\t\tif(!p) t[np].fa = 1;\n\t\telse\n\t\t{\n\t\t\tint q = t[p].ch[c];\n\t\t\tif(t[q].len == t[p].len + 1) t[np].fa = q;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint nq = ++ tot;t[nq] = t[q];\n\t\t\t\tt[nq].len = t[p].len + 1;\n\t\t\t\tt[q].fa = t[np].fa = nq;\n\t\t\t\tfor( ; p && t[p].ch[c] == q ; p = t[p].fa) t[p].ch[c] = nq;\t\n\t\t\t}\t\n\t\t}\n\t\tS1.update(rt[np] , 1 , n , IDX);\n\t\treturn np;\n\t}\n\tvoid dfs(int x,int f)\n\t{\n\t\tfor(int e = head[x] ; e ; e = edge[e].next)\n\t\t{\n\t\t\tint to = edge[e].to;\n\t\t\tif(to == f) continue;\n\t\t\tdfs(to , x);\n\t\t\trt[x] = S1.merge(rt[x] , rt[to]);\n\t\t}\n\t}\n\tvoid Build_Parent_Tree()\n\t{\n\t\tfor(int i = 2 ; i <= tot ; i ++) add(t[i].fa , i);\n\t\tdfs(1 , 0);\n\t}\n\tint nxt(int now,int c,int len,int L,int R)\n\t{\n\t\tif(!t[now].ch[c]) return 0;\n\t\tnow = t[now].ch[c];\n\t\tint nL = L + len - 1;\n\t\treturn S1.query(rt[now] , 1 , n , nL , R);\n\t}\n}At;\nvector<int> vr;\nchar s[Len],ss[Len];\nint main()\n{\n\tscanf(\"%s\",s + 1);\n\tn = strlen(s + 1);int lst = 1;\n\tfor(int i = 1 ; i <= n ; i ++) lst = At.Add(s[i] - 'a' , lst , i);\n\tAt.Build_Parent_Tree();\n\tint T;scanf(\"%d\",&T);\n\twhile(T --)\n\t{\n\t\tvr.clear();vr.push_back(1);\n\t\tint l,r;scanf(\"%d %d\",&l,&r);scanf(\"%s\",ss + 1);int rt = 1,lens = strlen(ss + 1);\n\t\tint IDX = 0;\n\t\tfor(int i = 1 ; i <= lens ; i ++) \n\t\t{\n\t\t\tif(At.nxt(rt , ss[i] - 'a' , i , l , r))\n\t\t\t{\n\t\t\t\trt = At.t[rt].ch[ss[i] - 'a'];\n\t\t\t\tvr.push_back(rt);\n\t\t\t\tIDX ++;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\t//printf(\"%d\\n\",IDX);\n\t\tbool flag = 0;\n\t\tfor(int i = vr.size() - 1 ; i >= 0 ; i --)\n\t\t{\n\t\t\tint pst = ss[IDX + 1] - 'a' , now = vr[i];\n\t\t\tif(IDX + 1 > lens) pst = -1;\n\t\t\tfor(int j = pst + 1 ; j < 26 ; j ++)\n\t\t\t{\n\t\t\t\tif(At.nxt(now , j , IDX + 1 , l , r)) \n\t\t\t\t{\n\t\t\t\t\tfor(int k = 1 ; k <= IDX ; k ++) putchar(ss[k]);\n\t\t\t\t\tputchar(j + 'a');\n\t\t\t\t\tputs(\"\");\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tIDX --;\n\t\t}\n\t\tif(!flag) puts(\"-1\");\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1647485604,
        "uid": 132533,
        "name": "Hakuoro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF1037H Security"
    },
    {
        "content": "## Description\r\n\r\n\u7ed9\u5b9a\u4e00\u4e2a\u6587\u672c\u4e32 $s$ \u548c\u8be2\u95ee\u6b21\u6570 $q$ \uff0c\u6bcf\u6b21\u7ed9\u5b9a\u5c0f\u6587\u672c\u4e32 $t$ \u548c\u4e00\u4e2a\u533a\u95f4 $l$ \u548c $r$ \uff0c\u6c42\u4e00\u4e2a\u5b57\u5178\u5e8f\u5c3d\u53ef\u80fd\u5c0f\u7684 $s ^ {'}$ \u4f7f\u5f97\u662f $s$ \u7684\u5b50\u4e32\u5e76\u4e14\u5b57\u5178\u5e8f\u4e25\u683c\u5927\u4e8e $t$ \u3002\r\n\r\n$|s|,\\ \\sum |t| \\leq 2 \\cdot 10 ^ 5,\\ \\ q\\leq 2\\cdot 10 ^ 5$\r\n\r\n## Solution\r\n\r\n\u597d\u50cf\u5bf9 $s ^ {'}$ \u7684\u8981\u6c42\u6709\u70b9\u591a\uff0c\u90a3\u5c31\u4ee5\u6700\u9ebb\u70e6\u7684\u5b50\u4e32\u4f5c\u4e3a\u51fa\u53d1\u6761\u4ef6\u3002\r\n\r\n\u4f1a\u53d1\u73b0\u8fd9\u9898\u80fd\u548c [\u4f60\u7684\u540d\u5b57](https://www.luogu.com.cn/problem/P4770 \"\u4f60\u7684\u540d\u5b57\") \u5957\u8def\u6781\u5ea6\u5730\u50cf\u3002\u540c\u6837\uff0c\u5148\u8003\u8651\u8be2\u95ee\u5168\u662f $s$ \u5168\u4e32\u600e\u4e48\u529e\u3002\r\n\r\n### situation 1\r\n\r\n\u65e2\u7136\u8981\u6c42\u5b57\u5178\u5e8f\u5fc5\u987b\u8981\u4e25\u683c\u5927\u4e8e $t$ \u4f46\u662f\u6700\u5c0f\uff0c\u6240\u4ee5\u7b54\u6848\u8981\u5c3d\u53ef\u80fd\u8d34\u8fd1 $t$ \u7684\u6837\u5b50\uff0c\u5c31\u76f8\u5f53\u4e8e $t$ \u7684\u4e00\u4e2a\u524d\u7f00\u52a0\u4e0a\u4e00\u4e2a $s$ \u4e0a\u6709\u8f6c\u79fb\u7684\uff0c\u52a0\u5b8c\u6bd4 $t$ \u5927\u7684\u5b57\u7b26\u3002\r\n\r\n\u6240\u4ee5\u5bf9 $s$ \u5efa\u7acb ${\\rm SAM}$ \uff0c\u7136\u540e\u6211\u4eec\u76f4\u63a5\u628a $t$ \u4e22\u4e0a\u53bb\u8dd1\u5339\u914d\uff0c\u5339\u914d\u4e0d\u4e0a\u5c31\u770b\u80fd\u4e0d\u80fd\u52a0\u4e00\u4e2a\u66f4\u5927\u7684\u5b57\u7b26\uff08\u5982\u679c $t$ \u4e5f\u662f $s$ \u7684\u5b50\u4e32\u5c31\u770b\u80fd\u4e0d\u80fd\u989d\u5916\u52a0\u4e00\u4e2a\u5b57\u7b26\uff09\uff0c\u5982\u679c\u6ca1\u6709\u5c31\u5f80\u524d\u4e00\u4f4d\u4e0a\u518d\u627e\uff0c\u5047\u5982\u8fd9\u6837\u5b50\u8fd8\u6ca1\u6709\u7b54\u6848\u90a3\u80af\u5b9a\u5c31\u662f\u65e0\u89e3\u4e86\u3002\r\n\r\n### situation 2\r\n\r\n\u5982\u679c\u662f\u533a\u95f4\u7684\u8bdd\uff0c\u53d1\u73b0\u6211\u4eec\u597d\u50cf\u9700\u8981 $endpos$ \uff0c\u4e0d\u7136\u53ef\u80fd\u4e00\u4e9b\u672c\u4e0d\u5728\u533a\u95f4\u5185\u7684\u4f4d\u7f6e\u4f1a\u5339\u914d\u4e0a\u3002\r\n\r\n\u90a3\u5c31\u8fd8\u662f\u7528\u7ebf\u6bb5\u6811\u5408\u5e76\u89e3\u51b3 $endpos$ \u95ee\u9898\uff0c\u6bcf\u6b21\u627e\u5339\u914d\uff0c\u627e\u5b57\u7b26\u90fd\u67e5\u8be2\u4e00\u904d\u662f\u5426\u5408\u6cd5\uff0c\u51c6\u786e\u70b9\u662f\u5de6\u7aef\u70b9\u5728 $L$ \u53f3\u8fb9\uff0c\u53f3\u7aef\u70b9\u5728 $R$ \u5de6\u8fb9\u624d\u5bf9\u3002\r\n\r\n### \u63d2\u4e00\u5634\r\n\r\n\u521a\u60f3\u7740\u8981\u7ee7\u7eed\u8bf4\u4ec0\u4e48\uff0c\u4f46\u662f\u53d1\u73b0\u8fd9\u6837\u5b50\u5c31\u5df2\u7ecf\u505a\u5b8c\u4e86\u3002\u3002\u751a\u81f3\u611f\u89c9 ${\\rm SAM}$ \u6709\u70b9\u7b97\u662f\u5927\u6750\u5c0f\u7528\u4e86\u5417\u3002\u3002\r\n\r\n\u4e0d\uff01\r\n\r\n\u8fd9\u662f\u7ebf\u6bb5\u6811\u5408\u5e76\u7ef4\u62a4 $endpos$ \u7684\u677f\u5b50\uff08\u8feb\u771f\r\n\r\n## Code\r\n\r\n```cpp\r\n/*\r\n\r\n*/\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\ntypedef long long ll;\r\nconst int N = 4e5 + 10, M = 4e6 + 10;\r\nint rt[N], tot, ls[M], rs[M], nxt[N];\r\ninline int read() {\r\n    char ch = getchar();\r\n    int s = 0, w = 1;\r\n    while (!isdigit(ch)) {if (ch == '-') w = -1; ch = getchar();}\r\n    while (isdigit(ch)) {s = (s << 3) + (s << 1) + (ch ^ 48); ch = getchar();}\r\n    return s * w;\r\n}\r\ninline void modify(int &now, int lt, int rt, int it) {\r\n    if (!now) now = ++tot;\r\n    if (lt == rt) return ;\r\n    int mid = (lt + rt) >> 1;\r\n    if (it <= mid) modify(ls[now], lt, mid, it);\r\n    else modify(rs[now], mid + 1, rt, it);\r\n}\r\ninline bool query(int now, int lt, int rt, int L, int R) {\r\n    if (!now) return 0;\r\n    if (L <= lt && rt <= R) return 1;\r\n    int mid = (lt + rt) >> 1, res = 0, ret = 0;\r\n    if (L <= mid) res = query(ls[now], lt, mid, L, R);\r\n    if (R > mid) ret = query(rs[now], mid + 1, rt, L, R);\r\n    return res | ret;\r\n}\r\ninline int merge(int u, int v, int lt, int rt) {\r\n    if (!u) return v;\r\n    if (!v) return u;\r\n    if (lt == rt) return u | v;\r\n    int mid = (lt + rt) >> 1, w = ++tot;\r\n    ls[w] = merge(ls[u], ls[v], lt, mid);\r\n    rs[w] = merge(rs[u], rs[v], mid + 1, rt);\r\n    return w;\r\n}\r\nstruct SAM {\r\n    int n, cnt, las, len[N], link[N], ch[N][26];\r\n    char s[N]; int tong[N], rk[N], mx[N];\r\n    inline void init() {\r\n        cnt = las = 1;\r\n        memset(ch[1], 0, sizeof(ch[1]));\r\n    }\r\n    inline void SAM_stru(int c) {\r\n        int cur = ++cnt, p = las;\r\n        memset(ch[cur], 0, sizeof(ch[cur]));\r\n        las = cur;\r\n        len[cur] = len[p] + 1;\r\n        while (p && !ch[p][c]) ch[p][c] = cur, p = link[p];\r\n        if (!p) {link[cur] = 1; return ;}\r\n        int q = ch[p][c];\r\n        if (len[p] + 1 == len[q]) {link[cur] = q; return ;}\r\n        int clo = ++cnt;\r\n        link[clo] = link[q]; len[clo] = len[p] + 1;\r\n        link[q] = link[cur] = clo;\r\n        memcpy(ch[clo], ch[q], sizeof(ch[clo]));\r\n        while (p && ch[p][c] == q) ch[p][c] = clo, p = link[p];\r\n    }\r\n    inline void Tong_sort() {\r\n        for (int i = 1; i <= cnt; ++i) ++tong[len[i]];\r\n        for (int i = 1; i <= cnt; ++i) tong[i] += tong[i - 1];\r\n        for (int i = 1; i <= cnt; ++i) rk[tong[len[i]]--] = i;\r\n        for (int i = cnt, v, u; i >= 1; --i) {\r\n            v = rk[i]; u = link[v];\r\n            rt[u] = merge(rt[u], rt[v], 0, n - 1);\r\n        }\r\n    }\r\n} s, t;\r\ninline void mian() {\r\n    int l = read() - 1, r = read() - 1;\r\n    scanf(\"%s\", t.s); t.n = strlen(t.s);\r\n    int v = 1, it = 0;\r\n    for (int i = 0, c; i <= t.n; ++i, it = i) {\r\n        nxt[i] = -1;\r\n        c = t.s[i] - 'a';\r\n        for (int j = max(c + 1, 0), u; j < 26; ++j) {\r\n            u = s.ch[v][j];\r\n            if (u && query(rt[u], 0, s.n - 1, l + i, r)) {\r\n                nxt[i] = j; break;\r\n            }\r\n        }\r\n        if (i == t.n || !s.ch[v][c] || !query(rt[s.ch[v][c]], 0, s.n - 1, l + i, r)) break;\r\n        v = s.ch[v][c];\r\n    }\r\n    while (~it && nxt[it] == -1) --it;\r\n    if (it == -1) return printf(\"-1\\n\"), void();\r\n    for (int i = 0; i < it; ++i) cout << t.s[i];\r\n    cout << (char)(nxt[it] + 'a') << \"\\n\";\r\n}\r\nint main() {\r\n    scanf(\"%s\", s.s); s.n = strlen(s.s); s.init();\r\n    for (int i = 0; i < s.n; ++i) {\r\n        s.SAM_stru(s.s[i] - 'a');\r\n        modify(rt[s.las], 0, s.n - 1, i);\r\n    }\r\n    s.Tong_sort();\r\n    int T = read();\r\n    while (T--) mian();\r\n    return 0;\r\n}\r\n```",
        "postTime": 1647432130,
        "uid": 206024,
        "name": "Illusory_dimes",
        "ccfLevel": 7,
        "title": "CF1037H Security \u9898\u89e3"
    },
    {
        "content": "## $\\text{Solution}$\n\n\u9996\u5148\u5bf9\u4e8e\u5b57\u5178\u5e8f\u6700\u5c0f\uff0c\u6211\u4eec\u53ef\u4ee5\u6765\u4e2a\u8d2a\u5fc3\uff1a\n\n\u5047\u5982\u662f $aab$ \uff0c\u90a3\u4e48\u6211\u4eec\u5148\u8003\u8651\u80fd\u4e0d\u80fd\u5728 $[L,R]$ \u5185\u5339\u914d\u5230   $aab$ \uff0c\u518d\u8003\u8651\u80fd\u5426\u518d\u6dfb\u4e0a\u4e00\u4e2a\u6700\u5c0f\u7684\u5b57\u6bcd\u3002\u5047\u5982\u4e0d\u884c\uff0c\u8fd4\u56de\u4e0a\u4e00\u6b65\uff0c\u627e\u4e00\u4e2a\u5927\u4e8e $b$ \u7684\u6700\u5c0f\u5b57\u6bcd\uff0c\u51d1\u51fa\u6765\u5c31\u5b57\u5178\u5e8f\u6700\u5927\u4e86\u3002\u4e0d\u884c\u7684\u8bdd\u5c31\u518d\u56de\u8df3\u3002\n\n\u603b\u7ed3\u4e0b\uff1a\n\n1. \u5047\u5982\u524d\u9762\u5168\u90e8\u4e00\u6a21\u4e00\u6837\u5339\u914d\u6210\u529f\uff0c\u4e14\u5168\u90e8\u5339\u914d\u5b8c\uff0c\u53ea\u9700\u8981\u770b\u80fd\u5426\u6dfb\u4e0a\u4e00\u4e2a\u6700\u5c0f\u7684\u5373\u53ef\u3002\n\n2. \u770b\u80fd\u5426\u5f53\u524d\u4f4d\u5339\u914d\u4e00\u6837\u7684\u3002\n\n3. \u80fd\u5426\u5339\u914d\u66f4\u5927\u7684\uff0c\u76f4\u63a5\u9000\u51fa\u3002\n\n\u6ce8\u610f\u4e0b\uff0c\u5b83\u4eec\u662f\u6709\u4f18\u5148\u7ea7\u7684\u3002\n\n\u90a3\u4e48\uff0c\u5bf9\u4e8e\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u6211\u4eec\u600e\u4e48\u8003\u8651\u5b83\u662f\u5426\u5728 $[L,R]$ \u51fa\u73b0\uff1f\n\n\u8003\u8651\u5f53\u524d\u5339\u914d\u5230 SAM \u7684 $p$ \u8282\u70b9\uff0c\u7136\u540e SAM \u7684\u7236\u4eb2\u662f\u513f\u5b50\u7684\u540e\u7f00\uff0c\u8bf4\u660e\u7236\u4eb2\u8fd9\u4e2a\u72b6\u6001\u5728\u513f\u5b50\u4e2d\u90fd\u6709\u51fa\u73b0\u8fc7\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u9700\u8981\u5224\u65ad\u4e0b\u8fd9\u4e2a\u5b50\u6811\u91cc\u6709\u6ca1\u6709\u5728 $[L,R]$ \u4e4b\u4e2d\u7684\u5373\u53ef\u3002\n\n\u8fd9\u91cc\u6211\u7ebf\u6bb5\u6811\u5408\u5e76\u4e0d\u719f\uff0c\u5199\u4e86\u4e2a\u4e3b\u5e2d\u6811+dfs\u5e8f\u3002\n\n## $\\text{Code}$\n```cpp\n#include <bits/stdc++.h>\n\n#define N (int)(3e5+5)\n\nusing namespace std;\n\nstruct edge {\n\tint nex,to;\n}e[N];\n\nchar s[N];\nint head[N],cnt,sz[N],val[N],fa[N],len[N],son[26][N],id[N],rk[N],rt[N],id_tot;\nint n,m,M,las=1,tot=1;\n\nvoid add_edge(int x,int y) {\n\te[++cnt].nex=head[x]; e[cnt].to=y;\n\thead[x]=cnt;\n}\n\nvoid ins(int c,int v) {\n\tint pre=las,x=++tot; las=x; len[x]=len[pre]+1; val[x]=v; \n\tfor(;pre&&!son[c][pre];pre=fa[pre]) son[c][pre]=x;\n\tint y=son[c][pre];\n\tif(!pre) fa[x]=1;\n\telse if(len[pre]+1==len[y]) fa[x]=y;\n\telse {\n\t\tint p=++tot; len[p]=len[pre]+1;\n\t\tfa[p]=fa[y]; fa[x]=fa[y]=p;\n\t\tfor(int i=0;i<26;i++) son[i][p]=son[i][y];\n\t\tfor(;pre&&son[c][pre]==y;pre=fa[pre]) son[c][pre]=p;\n\t}\n\t//return x;\n}\n\nint dtot=0;\nvoid dfs(int x) {\n\tid[x]=++dtot; rk[dtot]=x; sz[x]=1;\n\tfor(int i=head[x];i;i=e[i].nex) {\n\t\tint y=e[i].to;\n\t\tdfs(y); sz[x]+=sz[y];\n\t}\n}\n\nint ls[N*30],rs[N*30],sum[N*30],pos_tot=0;\n\nvoid update(int &cur,int pre,int l,int r,int x) {\n\tif(!cur) cur=++pos_tot;\n\tsum[cur]=sum[pre]+1;\n\tif(l==r) return ;\n\tint mid=(l+r)>>1;\n\tif(x<=mid) rs[cur]=rs[pre],update(ls[cur],ls[pre],l,mid,x);\n\telse ls[cur]=ls[pre],update(rs[cur],rs[pre],mid+1,r,x);\n}\n\nint query(int pre,int cur,int l,int r,int x) {\n\tif(l==r&&l==x) return sum[cur]-sum[pre];\n\tif(l==r) return 0;\n\tint mid=(l+r)>>1;\n\tif(x<=mid) return query(ls[pre],ls[cur],l,mid,x);\n\telse return sum[ls[cur]]-sum[ls[pre]]+query(rs[pre],rs[cur],mid+1,r,x);\n}\n\nchar ans[N];\nint ans_tot=0;\n\nbool check(int x,int L,int R) {\n\tint l=id[x],r=id[x]+sz[x]-1;\n//\tcout<<(char)(x+'a')<<' '<<L<<\" \"<<R<<\" \"<<query(rt[l-1],rt[r],1,n,R)-query(rt[l-1],rt[r],1,n,L-1)<<'\\n';\n\treturn query(rt[l-1],rt[r],1,M,R)-query(rt[l-1],rt[r],1,M,L-1)>0;\n}\n\nbool solve(int p,int x,int l,int r) {\t\n\tif(x==n+1) {\t\n\t\tfor(int i=0;i<26;i++) {\n\t\t\tif(son[i][p]&&check(son[i][p],l,r)) {\n\t\t\t\tans_tot=x; ans[ans_tot]=i; return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool fl=0;\n\tif(son[s[x]-'a'][p]) {\n\t\tint t=son[s[x]-'a'][p];\n\t\tif(check(t,l,r)) fl=solve(t,x+1,l+1,r);\n\t\tif(fl) ans[x]=s[x]-'a';\n\t}\t\t\n\tif(fl) return 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tfor(int i=s[x]-'a'+1;i<26;i++) {\n\t\tif(son[i][p]&&check(son[i][p],l,r)) {\n\t\t\tans_tot=x; ans[x]=i; return 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tscanf(\"%s%d\",s+1,&m); M=n=strlen(s+1);\n\tfor(int i=1;i<=n;i++) ins(s[i]-'a',i);\n\tfor(int i=2;i<=tot;i++) add_edge(fa[i],i);\n\tdfs(1); //build(1,1,tot);\n\tfor(int i=1;i<=tot;i++) {\n\t\tif(val[rk[i]]) update(rt[i],rt[i-1],1,n,val[rk[i]]);\n\t\telse rt[i]=rt[i-1];\n\t}\n\tfor(int i=1;i<=m;i++) {\n\t\tint L,R;\n\t\tscanf(\"%d%d%s\",&L,&R,s+1); n=strlen(s+1); ans_tot=0;\n\t\tif(solve(1,1,L,R)) {\n\t\t\tfor(int i=1;i<=ans_tot;i++) printf(\"%c\",ans[i]+'a');\n\t\t\tputs(\"\");\n\t\t} else puts(\"-1\");\n\t}\n\treturn 0;\n} \n```",
        "postTime": 1625790675,
        "uid": 125901,
        "name": "FxorG",
        "ccfLevel": 7,
        "title": "CF1037H Security"
    }
]