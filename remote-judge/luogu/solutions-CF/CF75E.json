[
    {
        "content": "\u8ba1\u7b97\u51e0\u4f55\u65b9\u6cd5\u5b58\u70b9\u3001\u7b97\u8fb9\u6765\u5efa\u56fe\uff0c\u7136\u540e\u8dd1\u4e00\u8fb9\u6700\u77ed\u8def\u5c31\u884c\u4e86\u3002\u8fd9\u9898\u6c34\u5230Floyd\u90fd\u80fd\u8fc7\u3002\u3002\u3002\n\t\n\u6211\u4eec\u5148\u8fde\u63a5\u8d77\u59cb\u70b9(s)\u548c\u7ec8\u70b9(t)\u3002\u5982\u679cst\u4e0d\u4e0e\u591a\u8fb9\u5f62\u76f8\u4ea4\u6216\u4e0e\u591a\u8fb9\u5f62\u7684\u4e00\u6761\u8fb9\u91cd\u5408\uff0c\u5219\u76f4\u63a5\u8f93\u51fast\u7684\u957f\u5ea6\u3002\u5426\u5219\uff0c\u5efa\u4e00\u4e2a\u7531s\u3001t\u3001st\u4e0e\u591a\u8fb9\u5f62\u7684\u4e24\u4e2a\u4ea4\u70b9\u3001\u591a\u8fb9\u5f62\u7684\u7aef\u70b9\u7ec4\u6210\u7684\u56fe\u3002\u82e5\u8fd9\u5f20\u56fe\u4e2d\u6709\u4e24\u70b9\u4e3a\u7aef\u70b9\u7684\u7ebf\u6bb5\u4e0d\u4e0e\u591a\u8fb9\u5f62\u76f8\u4ea4\uff0c\u5219\u8fd9\u4e24\u4e2a\u70b9\u4e4b\u95f4\u5efa\u4e00\u6761\u8fb9\u6743\u4e3a\u4ece\u4e00\u70b9\u8d70\u5230\u53e6\u4e00\u70b9\u8d39\u7528\u7684\u8fb9\u3002\u6700\u540e\u6c42s\u3001t\u4e24\u70b9\u7684\u6700\u77ed\u8def\u5373\u53ef\u3002\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n\n```\n#include <bits/stdc++.h>\n#define cross(a,b) ((conj(a)*(b)).imag())\n#define X real()\n#define Y imag()\nusing namespace std;\n\ntypedef complex<double> point;\n\nconst double eps = 1e-9;\n\nint cmp(double a, double b) {\n\tif (fabs(a - b) < eps)\n\t\treturn 0;\n\treturn a > b ? 1 : -1;\n}\n\nstruct set_cmp {\n\tbool operator()(const point &A, const point &B) const {\n\t\tif (cmp(A.X, B.X))\n\t\t\treturn A.X < B.X;\n\t\tif (cmp(A.Y, B.Y))\n\t\t\treturn A.Y < B.Y;\n\t\treturn 0;\n\t}\n};\n\ndouble len(point A, point B) {\n\treturn hypot(A.X - B.X, A.Y - B.Y);\n}\n\nbool segement(point A, point B, point R) {\n\treturn cmp(len(A, B), len(A, R) + len(B, R)) == 0;\n}\n\nbool inter(point A, point B, point P, point Q, point &R) {\n\tdouble d1 = cross(P-A,B-A);\n\tdouble d2 = cross(Q-A,B-A);\n\tif (cmp(d1, d2) == 0)\n\t\treturn false;\n\tR = (d1 * Q - d2 * P) / (d1 - d2);\n\tif (!segement(A, B, R) || !segement(P, Q, R))\n\t\treturn false;\n\treturn true;\n}\n\nint n;\npoint st, en;\nvector<point> pol;\n\ndouble g[34][34];\n\nint main() {\n\tint x, y;\n\tcin >> x >> y;\n\tst = point(x, y);\n\tcin >> x >> y;\n\ten = point(x, y);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x >> y;\n\t\tpol.push_back(point(x, y));\n\t}\n\tdouble ans = len(st, en);\n\tset<point, set_cmp> intrs;\n\tfor (int i = 0; i < n; i++) {\n\t\tpoint R;\n\t\tif (inter(st, en, pol[i], pol[(i + 1) % n], R))\n\t\t\tintrs.insert(R);\n\t}\n\tif (intrs.size() == 2) {\n\t\tpoint p1 = *intrs.begin();\n\t\tpoint p2 = *(++intrs.begin());\n\t\tfor (int i = 0; i < n + 4; i++) {\n\t\t\tfor (int j = 0; j < n + 4; j++)\n\t\t\t\tg[i][j] = 1 << 30;\n\t\t\tg[i][i] = 0;\n\t\t}\n\t\tif (cmp(len(p2, st), len(p1, st)) < 0)\n\t\t\tswap(p1, p2);\n\t\tg[0][2] = g[2][0] = len(st, p1);\n\t\tg[1][3] = g[3][1] = len(en, p2);\n\t\tg[2][3] = g[3][2] = len(p1, p2) * 2;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint i1 = i + 4;\n\t\t\tint i2 = (i + 1) % n + 4;\n\t\t\tg[i1][i2] = g[i2][i1] = len(pol[i1 - 4], pol[i2 - 4]);\n\t\t\tif (segement(pol[i1 - 4], pol[i2 - 4], p1)) {\n\t\t\t\tif (segement(pol[i1 - 4], pol[i2 - 4], p2)) return printf(\"%.9lf\\n\", ans),0;\n\t\t\t\tg[2][i1] = g[i1][2] = len(pol[i1 - 4], p1);\n\t\t\t\tg[2][i2] = g[i2][2] = len(pol[i2 - 4], p1);\n\t\t\t}\n\t\t\tif (segement(pol[i1 - 4], pol[i2 - 4], p2)) {\n\t\t\t\tg[3][i1] = g[i1][3] = len(pol[i1 - 4], p2);\n\t\t\t\tg[3][i2] = g[i2][3] = len(pol[i2 - 4], p2);\n\t\t\t}\n\t\t}\n\t\tn += 4;\n\t\tfor (int k = 0; k < n; k++)\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tg[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n\t\tans = g[0][1];\n\t}\n\tprintf(\"%.9lf\\n\", ans);\n}\n\n```",
        "postTime": 1545219601,
        "uid": 119553,
        "name": "rEdWhitE_uMbrElla",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF75E \u3010Ship's Shortest Path\u3011"
    }
]