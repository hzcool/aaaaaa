[
    {
        "content": "## [\u66f4\u597d\u7684\u9605\u8bfb](https://www.cnblogs.com/yzhang-rp-inf/p/9763060.html)\n\n#### \u539f\u9898\u4f20\u9001\u95e8\uff1a[CF343D Water Tree](https://www.luogu.org/problemnew/show/CF343D)\n\n#### \u8fd9\u660e\u663e\u662f\u5f31\u667a\u9898\n\n#### \u6811\u5256\u5957\u73c2\u6735\u8389\u6811\u591a\u7b80\u5355\u554a\n\n## \u524d\u7f6e\u829d\u58eb\uff1a\u73c2\u6735\u8389\u6811\n\n### [\u7a9d\u535a\u5ba2\u91cc\u5bf9\u73c2\u6735\u8389\u6811\u7684\u4ecb\u7ecd](https://www.cnblogs.com/yzhang-rp-inf/p/9443659.html )\n\n### \u6ca1\u4ec0\u4e48\u597d\u8bf4\u7684\u81ea\u5df1\u770b\u770b\u5427\n\n#### \u5148\u6811\u5256\u4e00\u4e0b\n\n#### \u7b2c\u4e00\u79cd\u64cd\u4f5c\uff0c\u628a\u4e00\u4e2a\u70b9\u7684\u5b50\u6811\u5168\u90e8\u53d8\u62101\n\n#### \u56e0\u4e3a\u505a\u4e86\u6811\u5256\uff0c\u6240\u4ee5\u73c2\u6735\u8389\u6811\u533a\u95f4\u8d4b\u503c\u5c31\u53ef\u4ee5\u4e86\n\n#### \u7b2c\u4e8c\u79cd\u64cd\u4f5c\u5c31\u91cd\u94fe\u5f80\u4e0a\u8df3\uff0c\u91cd\u94fe\u5168\u53d8\u62100\uff0c\u73c2\u6735\u8389\u6811\u4e5f\u80fd\u5b8c\u6210\n\n#### \u7b2c\u4e09\u79cd\u64cd\u4f5c\u76f4\u63a5split\u4e00\u4e0b\u5c31\u884c\n\n#### \u8fd9\u9053\u9898\u771f\u7684\u5f88\u7b80\u5355\uff0c\u7ec6\u8282\u770b\u4ee3\u7801~~\uff08\u73c2\u6735\u8389\u6811\u5b9e\u9645\u5c31\u662f\u4e00\u79cd\u66b4\u529b\uff09~~\n\n#### ~~\u56e0\u4e3a\u6570\u636e\u968f\u673a\uff0c\u6240\u4ee5\u6709\u53ef\u80fd\u4f1a\u6709\u70b9\u6162~~\n\n```cpp\n#pragma GCC optimize(\"O3\") \n#include <bits/stdc++.h>\n#define N 500005\nusing namespace std;\ninline int read()\n{\n    int f=1,x=0;char ch;\n    do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');\n    do{x=x*10+ch-'0';ch=getchar();}while(ch>='0'&&ch<='9');\n    return f*x;\n}\nstruct edge{\n    int to,next;\n}e[N<<1];\nint head[N],cnt=0;\ninline void add(register int u,register int v)\n{\n    e[++cnt]=(edge){v,head[u]};\n    head[u]=cnt;\n}\nint n,m;\nint size[N],l[N],son[N],dep[N],fa[N],top[N],tot=0;\ninline void dfs1(register int x)\n{\n    size[x]=1;\n    for(register int i=head[x];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(!dep[v])\n        {\n            dep[v]=dep[x]+1;\n            fa[v]=x;\n            dfs1(v);\n            size[x]+=size[v];\n            if(size[v]>size[son[x]])\n                son[x]=v;\n        }\n    }\n}\ninline void dfs2(register int x,register int t)\n{\n    l[x]=++tot;\n    top[x]=t;\n    if(son[x])\n        dfs2(son[x],t);\n    for(register int i=head[x];i;i=e[i].next)\n    {\n        int v=e[i].to;\n        if(v!=fa[x]&&v!=son[x])\n            dfs2(v,v);\n    }\n}\nstruct node\n{\n    int l,r;\n    mutable int v;\n    node(int L, int R=-1, int V=0):l(L), r(R), v(V) {}\n    bool operator<(const node& o) const\n    {\n        return l < o.l;\n    }\n};\nset<node> s;\n#define IT set<node>::iterator\nIT split(register int pos)\n{\n    IT it = s.lower_bound(node(pos));\n    if (it != s.end() && it->l == pos) \n        return it;\n    --it;\n    int L = it->l, R = it->r;\n    int V = it->v;\n    s.erase(it);\n    s.insert(node(L, pos-1, V));\n    return s.insert(node(pos, R, V)).first;\n}\ninline void assign_val(register int l,register int r,register int val)\n{\n    IT itr = split(r+1),itl = split(l);\n    s.erase(itl, itr);\n    s.insert(node(l, r, val));\n}\ninline void query(register int pos)\n{\n    IT itpos = split(pos);\n    printf(\"%d\\n\",itpos->v);\n}\ninline void cal(register int pos)\n{\n    int fpos=top[pos];\n    while(fpos!=1)\n    {\n        assign_val(l[fpos],l[pos],0);\n        pos=fa[fpos],fpos=top[pos];\n    }\n    assign_val(l[1],l[pos],0);\n}\nint main()\n{\n    n=read();\n    for(register int i=1;i<n;++i)\n    {\n        int u=read(),v=read();\n        add(u,v),add(v,u);\n    }\n    dep[1]=fa[1]=1;\n    dfs1(1);\n    dfs2(1,1);\n    s.insert(node(0,500000+233));\n    int m=read();\n    while(m--)\n    {\n        int opt=read(),pos=read();\n        if(opt==1)\n            assign_val(l[pos],l[pos]+size[pos]-1,1);\n        else if(opt==2)\n            cal(pos);\n        else\n            query(l[pos]);\n    }\n    return 0;\n}\n```",
        "postTime": 1539092118,
        "uid": 37881,
        "name": "yzhang",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "## \u4e00\u4e2a\u6811\u5256\u9898\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u5bf9\u4e8e\u7ebf\u6bb5\u6811\u7684\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0c\u7ef4\u62a4\u533a\u95f4\u8986\u76d6 \u548c \u533a\u95f4\u6e05\u7a7a \u5373\u53ef\n\n\u8fd9\u91cc\u91c7\u7528\u6570\u7ec4\u5199\u6cd5\uff0c\u6307\u9488\u5199\u6cd5\u8be6\u89c1[\u6211\u535a\u5ba2](https://www.luogu.org/blog/Treaker/#)\u5176\u4ed6\u6811\u5256\u9898\u3002\n\n\u987a\u4fbf\u63a8\u8350\u505a\u4e00\u4e0b\u6a21\u677f[\u3010\u6a21\u677f\u3011\u6811\u94fe\u5256\u5206](https://www.luogu.com.cn/problem/P3384)  \n\n\u5b8c\u6574\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include <iostream>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconst int N = 500500;\nint ls(int x) {return x << 1;}\nint rs(int x) {return x << 1 | 1;}\nint n , m , cnt;\nint head[N] , top[N] , fa[N] , dfn[N] , id[N] , size[N] , dep[N] , hs[N];\nint col[N << 2] , tag[N << 2];\nstruct Edge {int to , nxt;} e[N << 1];\nvoid add(int from,int to) \n{\n\te[++cnt] = (Edge){to,head[from]};\n\thead[from] = cnt;\n}\nvoid get_tree(int now)\n{\n\tsize[now] = 1;\n\tfor(int i = head[now];i;i = e[i].nxt)\n\t{\n\t\tint to = e[i].to;\n\t\tif(dep[to])\tcontinue;\n\t\tfa[to] = now;\n\t\tdep[to] = dep[now]  +1;\n\t\tget_tree(to);\n\t\tsize[now] += size[to];\n\t\tif(size[to] > size[hs[now]])\ths[now] = to;\n\t}\n}\nvoid dfs(int now,int topfa)\n{\n\tdfn[now] = ++cnt;\n\tid[cnt] = now;\n\ttop[now] = topfa;\n\tif(hs[now])\tdfs(hs[now],topfa);\n\tfor(int i = head[now];i;i = e[i].nxt)\n\t{\n\t\tint to = e[i].to;\n\t\tif(fa[now] == to || to == hs[now])\tcontinue;\n\t\tdfs(to,to);\n\t}\n}\nvoid push_down(int p,int l,int r)\n{\n\tcol[ls(p)] = col[rs(p)] = col[p];\n\ttag[ls(p)] = tag[rs(p)] = tag[p];\n\ttag[p] = -1;\n}\nvoid chenge(int p,int l,int r,int x,int y,int k)\n{\n\tif(x <= l && r <= y)\t\n\t{\n\t\tcol[p] = k;\n\t\ttag[p] = k;\n\t\treturn ;\n\t}\n\tint mid = (l + r) >> 1;\n\tif(tag[p] >= 0)\tpush_down(p,l,r);\n\tif(x <= mid)\tchenge(ls(p),l,mid,x,y,k);\n\tif(y > mid)\t\tchenge(rs(p),mid+1,r,x,y,k);\n}\nvoid sec_cover(int x,int y)\n{\n\twhile(top[x] != top[y])\n\t{\n\t\tif(dep[top[x]] < dep[top[y]])\tswap(x,y);\n\t\tchenge(1,1,n,dfn[top[x]],dfn[x],0);\n\t\tx = fa[top[x]];\n\t}\n\tif(dep[x] < dep[y])\tswap(x,y);\n\tchenge(1,1,n,dfn[y],dfn[x],0);\n}\nint query(int p,int l,int r,int x)\n{\n\tif(l == r)\treturn col[p];\n\tint mid = (l + r) >> 1;\n\tif(tag[p] >= 0)\tpush_down(p,l,r);\n\tif(x <= mid)\treturn query(ls(p),l,mid,x);\n\telse\treturn query(rs(p),mid+1,r,x);\n}\t\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 1 , x , y;i < n;i ++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);  add(y,x);\n\t}\n\tcnt = 0;  dep[1] = 1;\n\tget_tree(1);\n\tdfs(1,1);\n\tmemset(tag,-1,sizeof tag);\n\tscanf(\"%d\",&m);\n\tfor(int i = 1 , c , v;i <= m;i ++)\n\t{\n\t\tscanf(\"%d%d\",&c,&v);\n\t\tif(c == 1)\tchenge(1,1,n,dfn[v],dfn[v]+size[v]-1,1);\n\t\telse if(c == 2)\tsec_cover(1,v);\n\t\telse printf(\"%d\\n\",query(1,1,n,dfn[v]));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1568809801,
        "uid": 153898,
        "name": "Treaker",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "[$$\\huge\\texttt{\u5728\u672c\u4ebablog\u98df\u7528\u66f4\u4f73}$$](https://dilute.xyz/2019/03/29/Solutions/Solution-CF343D/)\n\n## \u4f3c\u4e4e\u83ab\u5f97\u4eba\u662f\u4e0d\u7528\u6811\u5256\u7684w\n\n~~\u4f46\u662f\u4e3a\u4ec0\u4e48\u7684\u4e00\u53ealog\u4e71\u641e\u88ab\u6811\u5256\u7684\u4e24\u53ealog\u7206\u8e29\u554a~~\n\n~~\u662f\u56e0\u4e3a\u6211\u5b9e\u73b0\u7684\u592a\u4e11\u4e86\u5417~~\n\n\u4e0d\u7ba1\u4e86\u76f4\u63a5\u8bb2\u505a\u6cd5\u597d\u4e86\n\n\u9996\u5148\uff0c\u6211\u4eec\u8003\u8651\u4e00\u4e2a\u5f88\u663e\u7136\u7684\u7ed3\u8bba\uff1a\n\n> \u5982\u679c\u6211\u4eec\u5bf9\u4e8e\u8282\u70b9x\u4ed6\u4e0a\u6b21\u88ab\u704c\u6c34\u7684\u65f6\u95f4\u4f4dx\uff0c\u4e0a\u6b21\u88ab\u6e05\u9664\u6c34\u7684\u65f6\u95f4\u662fy\n>\n> \u90a3\u4e48\u82e5\u6709x > y\u5219\u6b64\u65f6\u8fd9\u4e2a\u8282\u70b9\u6709\u6c34\n>\n> \u5426\u5219\u8fd9\u4e2a\u8282\u70b9\u6ca1\u6c34\n\n\u7136\u540e\u6211\u4eec\u518d\u8003\u8651\u5982\u4f55\u7ef4\u62a4x\u548cy\n\n\u6211\u4eec\u628a\u4e24\u79cd\u4fee\u6539\u5206\u522b\u8ba8\u8bba\uff0c\u5206\u522b\u7528\u6811\u4e0a\u5dee\u5206\u548c`dfs`\u5e8f\u7ef4\u62a4\uff0c\u5c31\u53ef\u4ee5\u6109\u5feb\u5730\u4ee5$O(n \\log n)$\u7684\u590d\u6742\u5ea6\u5207\u6389\u6b64\u9898\u3002\n\n\u5982\u679c\u4e0d\u4f1a\u7684\u53ef\u4ee5\u5177\u4f53\u770b\u4ee3\u7801\uff0c\u4e0d\u4f1a\u6811\u4e0a\u67e5\u5206\u7684\u53ef\u4ee5\u770b\u770b[\u8fd9\u9898](https://www.luogu.org/problemnew/show/P2936)\u5b66\u5b66\n\n## \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\n\n#define ll long long\n#define INF 2147483647\n#define lc(a) (a << 1)\n#define rc(a) (a << 1 | 1)\n\nint inp(){\n    char c = getchar();\n    while(c < '0' || c > '9')\n        c = getchar();\n    int sum = 0;\n    while(c >= '0' && c <= '9'){\n        sum = sum * 10 + c - '0';\n        c = getchar();\n    }\n    return sum;\n}\n\nstruct SEG_Tree{\n    struct SEG{\n        int l;\n        int r;\n        int max;\n        int lazy;\n    }t[2000000];\n    \n    void push_up(int cur){\n        t[cur].max = std::max(t[lc(cur)].max, t[rc(cur)].max);\n    }\n\n    void push_down(int cur){\n        if(!t[cur].lazy)\n            return ;\n        t[lc(cur)].max = t[rc(cur)].max = t[lc(cur)].lazy = t[rc(cur)].lazy = t[cur].lazy;\n        t[cur].lazy = 0;\n    }\n\n    void build(int cur, int l, int r){\n        t[cur].l = l;\n        t[cur].r = r;\n        t[cur].max = 0;\n        t[cur].lazy = 0;\n        if(l == r)\n            return ;\n        int mid = (l + r) >> 1;\n        build(lc(cur), l, mid);\n        build(rc(cur), mid + 1, r);\n    }\n\n    void modify(int cur, int l, int r, int c){\n        if(t[cur].l > r || t[cur].r < l)\n            return ;\n        if(t[cur].l >= l && t[cur].r <= r){\n            t[cur].max = c;\n            t[cur].lazy = c;\n            return ;\n        }\n        push_down(cur);\n        modify(lc(cur), l, r, c);\n        modify(rc(cur), l, r, c);\n        push_up(cur);\n    }\n\n    int query(int cur, int l, int r){\n        if(t[cur].l > r || t[cur].r < l)\n            return 0;\n        if(t[cur].l >= l && t[cur].r <= r)\n            return t[cur].max;\n        push_down(cur);\n        return std::max(query(lc(cur), l, r), query(rc(cur), l, r));\n    }\n}t1, t2;\nint dfn[500010], size[500010], head[500010], nxt[1000010], end[1000010];\nint cou = 0;\nvoid link(int a, int b){\n    nxt[++cou] = head[a];\n    head[a] = cou;\n    end[cou] = b;\n}\n\nint idx = 0;\nvoid dfs(int cur, int last){\n    dfn[cur] = ++idx;\n    size[cur] = 1;\n    for(int x = head[cur]; x != -1; x = nxt[x])\n        if(end[x] != last){\n            dfs(end[x], cur);\n            size[cur] += size[end[x]];\n        }\n}\n\nint main(){\n    memset(head, -1, sizeof(head));\n    int n = inp();\n    for(int i = 1; i < n; i++){\n        int u = inp();\n        int v = inp();\n        link(u, v);\n        link(v, u);\n    }\n    int m = inp();\n    dfs(1, 0);\n    t1.build(1, 1, n);\n    t2.build(1, 1, n);\n    for(int i = 1; i <= m; i++){\n        int op = inp();\n        if(op == 1){\n            int x = inp();\n            t1.modify(1, dfn[x], dfn[x] + size[x] - 1, i);\n        } else if(op == 2){\n            int x = inp();\n            t2.modify(1, dfn[x], dfn[x], i);\n        } else {\n            int x = inp();\n            int a1 = t1.query(1, dfn[x], dfn[x]);\n            int a2 = t2.query(1, dfn[x], dfn[x] + size[x] - 1);\n            // printf(\"%d %d\\n\", a1, a2);\n            if(a1 > a2)\n                printf(\"1\\n\");\n            else\n                printf(\"0\\n\");\n        }\n    }\n}\n```\n\n\n\n",
        "postTime": 1553870229,
        "uid": 36362,
        "name": "Dilute",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\u5176\u5b9e\u8fd9\u9898\u662f\u53ef\u4ee5\u4e0d\u7528\u6811\u94fe\u5256\u5206\u7684\uff0c\u7528dfs\u5e8f\u5efa\u51fa\u7ebf\u6bb5\u6811\u5c31\u53ef\u4ee5\u6c34\u8fc7\u3002\n\n\u4ee5\u4e0b\u662f\u8fc7\u7a0b\uff1a\n\n\u9996\u5148\uff0c\u6211\u4eec\u5148dfs\u4e00\u904d\uff0c\u6c42\u51fa\u4e00\u4e2a\u8282\u70b9\u7684dfs\u5e8f\u3001\u5b83\u7684\u7236\u4eb2\u8282\u70b9\u3001\u5b83\u7684\u5b50\u6811\u7684\u5927\u5c0f\u3002\n\n\u6211\u4eec\u53ef\u4ee5\u6839\u636edfs\u7684\u987a\u5e8f\u5efa\u4e00\u68f5\u7ebf\u6bb5\u6811\u3002dfs\u5e8f\u5c31\u5bf9\u5e94\u8fd9\u4e2a\u8282\u70b9\u5728\u7ebf\u6bb5\u4e0a\u7684\u7f16\u53f7\u3002\u7136\u540e\u6211\u4eec\u5bb9\u6613\u53d1\u73b0\uff0c\u8fd9\u4e2a\u8282\u70b9\u7684\u5b50\u6811\u5176\u5b9e\u5c31\u5bf9\u5e94\u7ebf\u6bb5\u6811\u4e0a\u7684\u4e00\u4e2a\u533a\u95f4\uff08\u53ef\u4ee5\u624b\u9020\u4e00\u4e2a\u6570\u636e\u6765\u770b\u4e00\u4e0b\uff0c\u8fd9\u4e2a\u533a\u95f4\u7684\u5de6\u53f3\u8282\u70b9\u662f\u4ec0\u4e48\uff09\u3002\n\n\u7136\u540e\uff0c\u4e0d\u5c31\u662f\u51e0\u4e2a\u7b80\u5355\u7684\u64cd\u4f5c\u4e86\u5417\uff1f\n\n\u5bf9\u4e8e\u64cd\u4f5c1\uff0c\u6211\u4eec\u628a\u8fd9\u68f5\u5b50\u6811\u5728\u7ebf\u6bb5\u6811\u4e0a\u7684\u533a\u95f4\u5168\u90e8\u6d82\u9ed1\uff08\u4e5f\u5c31\u662f\u6539\u4e3a1\uff09\n\n\u5bf9\u4e8e\u64cd\u4f5c2\uff0c\u76f4\u63a5\u628ax\u7684\u5bf9\u5e94\u533a\u95f4\u6539\u4e3a0\n\n\u5bf9\u4e8e\u64cd\u4f5c3\uff0c\u7528\u533a\u95f4\u6c42\u548c\uff0c\u7136\u540e\u770b\u7ed3\u679c\u662f\u5426\u7b49\u4e8e\u8fd9\u68f5\u5b50\u6811\u7684\u5927\u5c0f\uff0c\u56e0\u4e3a\u5bf9\u4e8e\u4e00\u4e2a\u8282\u70b9\uff0c\u53ea\u8981\u5b83\u6709\u4e00\u4e2a\u767d\u8272\u7684\u5b50\u8282\u70b9\uff0c\u5b83\u4e5f\u662f\u767d\u8272\u7684\u3002\uff08\u5177\u4f53\u53ef\u4ee5\u770b\u9898\u76ee\u7684\u64cd\u4f5c2\uff09\n\n\u6700\u540e\uff0c\u6211\u4eec\u8fd8\u8981\u5728\u64cd\u4f5c1\u52a0\u4e0a\u4e00\u4e2a\u7279\u5224\uff0c\u5982\u679c\u8fd9\u4e2ax\u4e0d\u4e3a\u6839\u8282\u70b9\uff0c\u800c\u4e14\u5b83\u7684\u5b50\u6811\u91cc\u9762\u6709\u767d\u8272\u7684\u8282\u70b9\uff0c\u6211\u4eec\u5c31\u7acb\u523b\u628a\u5b83\u8f6c\u79fb\u5230x\u7684\u7236\u8282\u70b9\u53bb\uff0c\u8fd9\u6837\u5b50\u5c31\u53ef\u4ee5\u907f\u514d\u67d0\u4e9b\u9519\u8bef\u4e86\uff08\u6211\u9519\u4e86\u597d\u51e0\u6b21\u5440\u3002\u3002\u3002\uff09\u3002\n\n```\n#include<cstdio>\n#include<cstring>\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define mid ((l+r)>>1) \nint n,q;\nint cnt1,num[500010],size[500010];\nint t[2000010],tag[2000010],fa[2000010];\nint head[500010],cnt;\nstruct edge{\n\tint next,go;\n}e[1000010];\nvoid add(int u,int v){e[++cnt]=(edge){head[u],v},head[u]=cnt;}\nvoid dfs(int u,int pre) //\u9884\u5904\u7406 \n{\n\tnum[u]=++cnt1,size[u]=1,fa[u]=pre;\n\tfor(int i=head[u];i;i=e[i].next)\n\t{\n\t\tint v=e[i].go;\n\t\tif(v!=pre)\n\t\t\tdfs(v,u),size[u]+=size[v];\n\t}\n\treturn ;\n}\nvoid pushdown(int k,int l,int r) //\u6807\u8bb0\u4e0b\u4f20 \n{\n\tif(tag[k]!=-1)\n\t{\n\t\ttag[ls]=tag[rs]=tag[k];\n\t\tt[ls]=tag[k]*(mid-l+1);\n\t\tt[rs]=tag[k]*(r-mid);\n\t\ttag[k]=-1;\n\t}\n\treturn ;\n}\nvoid change(int k,int l,int r,int x,int y,int val) //\u533a\u95f4\u4fee\u6539 \n{\n\tif(x<=l&&r<=y)\n\t{\n\t\tt[k]=(r-l+1)*val;\n\t\ttag[k]=val;\n\t\treturn ;\n\t}\n\tpushdown(k,l,r);\n\tif(x<=mid)\n\t\tchange(ls,l,mid,x,y,val);\n\tif(y>mid)\n\t\tchange(rs,mid+1,r,x,y,val);\n\tt[k]=t[ls]+t[rs];\n\treturn ;\n}\nint query(int k,int l,int r,int x,int y) //\u533a\u95f4\u6c42\u548c \n{\n\tif(x<=l&&r<=y)\n\t\treturn t[k];\n\tpushdown(k,l,r);\n\tint ret=0;\n\tif(x<=mid)\n\t\tret+=query(ls,l,mid,x,y);\n\tif(y>mid)\n\t\tret+=query(rs,mid+1,r,x,y);\n\treturn ret;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1,u,v;i<n;i++)\n\t{\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tadd(u,v),add(v,u);\n\t}\n\tdfs(1,0);\n\tmemset(tag,-1,sizeof(tag));\n\tscanf(\"%d\",&q);\n\tfor(int i=1,opt,x;i<=q;i++)\n\t{\n\t\tscanf(\"%d %d\",&opt,&x);\n\t\tif(opt==1)\n\t\t{\n\t\t\tif(x!=1&&query(1,1,n,num[x],num[x]+size[x]-1)<size[x]) //\u7279\u5224 \n\t\t\t\tchange(1,1,n,num[fa[x]],num[fa[x]],0);\n\t\t\tchange(1,1,n,num[x],num[x]+size[x]-1,1); //\u533a\u95f4\u4fee\u6539 \n\t\t}\n\t\telse if(opt==2)\n\t\t\tchange(1,1,n,num[x],num[x],0); //\u533a\u95f4\u4fee\u6539 \n\t\telse\n\t\t\tprintf(\"%d\\n\",query(1,1,n,num[x],num[x]+size[x]-1)==size[x]); //\u533a\u95f4\u6c42\u548c \n\t}\n\treturn 0; //\u7ed3\u675f \n}\n```\n",
        "postTime": 1567082008,
        "uid": 112557,
        "name": "UhhhQQQU",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "~~\u7136\u800c\u5e76\u4e0d\u4f1a\u73c2\u6735\u8389\u6811\uff0c\u4e5f\u4e0d\u4f1a\u73c2\u6735\u8389\u6811\u4e0a\u6811~~\n\n\u8fd9\u6811\u5256\u88f8\u9898\u554a!\u611f\u89c9\u96be\u5ea6\u5e94\u8be5\u662f\u63d0\u9ad8+/\u7701\u9009-\n\n\u6211\u4eec\u5c06\u8fd9\u68f5\u6811\u5256\u5b8c\u4e4b\u540e,\u518d\u770b\u4e09\u4e2a\u64cd\u4f5c\uff1a\n\n\u64cd\u4f5c1\uff1a\u533a\u95f4\u8986\u76d61\n\n\u64cd\u4f5c2\uff1a\u533a\u95f4\u8986\u76d60\n\n\u64cd\u4f5c3\uff1a\u5355\u70b9\u67e5\u8be2\n\n\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u533a\u95f41\u7684\u6570\u91cf\n\n\u5982\u679c\u4e2d\u9014\u8bbf\u95ee\u5230\u7684\u533a\u95f41\u7684\u6570\u91cf\u7b49\u4e8e\u533a\u95f4\u957f\u5ea6\uff0c\u76f4\u63a5\u8fd4\u56de1\uff0c\u5426\u5219\u8bbf\u95ee\u7ebf\u6bb5\u6811\u53f6\u5b50\u7ed3\u70b9\uff0c\u6ce8\u610flaz\u6570\u7ec4\u521d\u59cb\u503c\u4e3a-1,0\u4e3a0\u8986\u76d6\u6574\u4e2a\u533a\u95f4\uff0c1\u4e3a1\u8986\u76d6\u6574\u4e2a\u533a\u95f4\u3002\n\n\u8fd9\u6837down\u7684\u65f6\u5019\u53ef\u4ee5\u76f4\u63a5\u7528\u533a\u95f4\u957f\u5ea6\u4e58laz\uff0cdown\u5b8c\u4e4b\u540elaz\u56de\u5f52\u521d\u59cb\u503c-1\u3002\n\n\u7136\u540e\u5c31\u5b8c\u4e86\u3002\n\n```cpp\n#include<iostream>\n#include<cstdio>\n#define mid ((l+r)>>1)\n#define lson k<<1,l,mid\n#define rson k<<1|1,mid+1,r\n#define ls k<<1\n#define rs k<<1|1\nusing namespace std;\nconst int N=500005;\nint n,m,cnt,tot;\nint head[N],dep[N],fa[N],siz[N],son[N],id[N],top[N];\nint tr[N<<2],laz[N<<2];\nstruct node{\n\tint to,nxt;\n}e[N<<1];\ninline int read(){\n\tint s=0,w=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){s=s*10+ch-'0';ch=getchar();}\n\treturn s*w;\n}\ninline void add(int from,int to){\n\te[++cnt]=(node){to,head[from]};\n\thead[from]=cnt;\n}\nvoid dfs1(int x,int f,int deep){\n\tfa[x]=f;siz[x]=1;dep[x]=deep;\n\tint maxson=-1,to;\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t\tif(e[i].to!=f){\n\t\t\tto=e[i].to;\n\t\t\tdfs1(to,x,deep+1);\n\t\t\tsiz[x]+=siz[to];\n\t\t\tif(siz[to]>maxson)son[x]=to,maxson=siz[to];\n\t\t}\n}\nvoid dfs2(int x,int topf){\n\tid[x]=++tot;top[x]=topf;\n\tif(!son[x])return ;\n\tdfs2(son[x],topf);\n\tfor(int i=head[x];i;i=e[i].nxt)\n\t\tif(e[i].to!=fa[x]&&e[i].to!=son[x])\n\t\t\tdfs2(e[i].to,e[i].to);\n}\ninline void update(int k){\n\ttr[k]=tr[ls]+tr[rs];\n}\ninline void down(int k,int l,int r){\n\ttr[ls]=(mid-l+1)*laz[k];\n\ttr[rs]=(r-mid)*laz[k];\n\tlaz[ls]=laz[rs]=laz[k];\n\tlaz[k]=-1;\n}\nvoid change(int k,int l,int r,int x,int y,int z){\n\tif(x==l&&y==r){\n\t\ttr[k]=(r-l+1)*z;\n\t\tlaz[k]=z;\n\t\treturn ;\n\t}\n\tif(laz[k]!=-1)down(k,l,r);\n\tif(y<=mid)change(lson,x,y,z);\n\telse if(x>mid)change(rson,x,y,z);\n\telse change(lson,x,mid,z),change(rson,mid+1,y,z);\n\tupdate(k);\n}\nint ask(int k,int l,int r,int x){\n\tif(tr[k]==(r-l+1))return 1;\n\tif(l==r&&l==x){\n\t\treturn tr[k];\n\t}\n\tif(laz[k]!=-1)down(k,l,r);\n\tif(x<=mid)return ask(lson,x);\n\telse return ask(rson,x);\n}\ninline void chenge(int x,int y){\n\twhile(top[x]!=top[y]){\n        if(dep[top[x]]<dep[top[y]])swap(x,y);\n        change(1,1,n,id[top[x]],id[x],0);\n        x=fa[top[x]];\n    }\n    if(dep[x]>dep[y])swap(x,y);\n    change(1,1,n,id[x],id[y],0);\n}\nint main(){\n\tn=read();\n\tint x,y;\n\tfor(int i=1;i<n;++i){\n\t\tx=read();y=read();\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs1(1,0,1);\n\tdfs2(1,1);\n\tfor(int i=1;i<=(n<<2);++i)laz[i]=-1;\n\tm=read();\n\tint opt;\n\twhile(m--){\n\t\topt=read();x=read();\n\t\tif(opt==1)change(1,1,n,id[x],id[x]+siz[x]-1,1);\n\t\telse if(opt==2)chenge(x,1);\n\t\telse printf(\"%d\\n\",ask(1,1,n,id[x]));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1570539799,
        "uid": 151768,
        "name": "\u6d41\u901d\u4e36",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "[\u9898\u9762](https://www.luogu.com.cn/problem/CF343D)\n\n\u8fd9\u662f\u4e00\u9053\u6811\u5256\u7684\u88f8\u9898\n\n~~\uff08\u7b2c\u4e00\u6b21\u6c34\u7d2b\u9898\u6709\u70b9\u5feb\u4e50\uff09~~\n\n\u8fd9\u9053\u9898\u5176\u5b9e\u5c31\u662f\u8f7b\u91cd\u94fe\u5256\u5206\u7684\u64cd\u4f5c\u62ff\u51fa\u6765\u7f62\u4e86\n\n\u6211\u4eec\u770b\u5230\u8fd9\u9053\u9898\u533a\u95f4\u4fee\u6539\uff0c\u5355\u70b9\u67e5\u8be2\n\n\u4e0d\u96be\u60f3\u5230\u7ebf\u6bb5\u6811\u5427\n\n\u7136\u540e\u6211\u4eec\u53ef\u4ee5\u60f3\u5230\u8f7b\u91cd\u94fe\u5256\u5206\u90a3\u9053\u9898\n\n\u6211\u4eec\u4f1a\u53d1\u73b0\u64cd\u4f5c$1$\u5c31\u662f\u5c06$dfn[x]$~$dfn[x]+siz[x]-1$\u8fd9\u6bb5\u533a\u95f4\u90fd\u8d4b\u503c\u4e3a$1$\n\n\u8fd9\u6837\u7684\u8bdd\u6211\u4eec\u5c31\u53ef\u4ee5$O(log)$\u5730\u7ef4\u62a4\u4e86\n\n\u7136\u540e\u6211\u4eec\u8003\u8651\u4e00\u4e0b\u64cd\u4f5c$2$\u6211\u4eec\u53d1\u73b0\uff0c\u8df3\u91cd\u94fe\u5730\u8fc7\u7a0b\u5176\u5b9e\u5c31\u662f\u4e0d\u65ad\u5411$1$\u79fb\u52a8\u7684\u8fc7\n\u7a0b\n\n\u6240\u4ee5\u6211\u4eec\u5728\u6bcf\u6b21\u8df3\u91cd\u94fe\u7684\u65f6\u5019\uff0c\u987a\u4fbf\u5728\u7ebf\u6bb5\u6811\u4e0a\u4fee\u6539\u4e00\u4e0b\u503c\u5c31\u597d\u4e86\n\n\u64cd\u4f5c$3$\u5176\u5b9e\u5c31\u662f\u7ebf\u6bb5\u6811\u5355\u70b9\u67e5\u8be2 \n\n\u8bdd\u4e0d\u591a\u8bf4\uff0c\u76f4\u63a5\u653e\u4ee3\u7801\n```cpp\n#include<bits/stdc++.h>\t\t\nconst int N = 5e5 + 5;\nusing namespace std;\nint n, m, head[N], cnt, dfn[N], hev[N], dep[N], siz[N], top[N], sum, fa[N];\nstruct node{\n\tint u, v, nxt;\n}edge[N << 1];\nvoid add(int u, int v){\n\tedge[++ cnt].u = u;\n\tedge[cnt].v = v;\n\tedge[cnt].nxt = head[u];\n\thead[u] = cnt;\n}\nstruct tree{\n\tprotected:\n\t\t#define ls(o) (o << 1)\n\t\t#define rs(o) (o << 1 | 1)\n\t\t#define mid ((l + r) >> 1)\n\t\tint tr[N << 2], laz[N << 2];\n\t\tvoid up(int o){ tr[o] = tr[ls(o)] + tr[rs(o)];}\n\t\tvoid down(int o, int l, int r){\n\t\t\tlaz[ls(o)] = laz[rs(o)] = laz[o];\n\t\t\ttr[ls(o)] = laz[o] * (mid - l + 1);\n\t\t\ttr[rs(o)] = laz[o] * (r - mid);\n\t\t\tlaz[o] = -1;\n\t\t}\n\t\tvoid build(int o, int l, int r){\n\t\t\tif(l == r){ tr[o] = 0; return ;}\n\t\t\tbuild(ls(o), l, mid); build(rs(o), mid + 1, r);\n\t\t\tup(o);\n\t\t}\n\tpublic:\n\t\tvoid change(int o, int l, int r, int L, int R, int val){\n\t\t\tif(L <= l && r <= R){\n\t\t\t\ttr[o] = val * (r - l + 1); laz[o] = val;\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tif(laz[o] != -1) down(o, l, r);\n\t\t\tif(L <= mid) change(ls(o), l, mid, L, R, val);\n\t\t\tif(R > mid) change(rs(o), mid + 1, r, L, R, val);\n\t\t\tup(o);\n\t\t}\n\t\tint query(int o, int l, int r, int x){\n\t\t\tif(l == r){ return laz[o];}\n\t\t\tif(laz[o] != -1) down(o, l, r);\n\t\t\tif(x <= mid) return query(ls(o), l, mid, x);\n\t\t\telse return query(rs(o), mid + 1, r, x);\n\t\t}\n\t\tvoid cz(int x){ build(1, 1, x);}\n}St_tree;\nstruct Powtree{\n\tvoid Ps(int x){\n\t\tsiz[x] = 1;\n\t\tfor(int i = head[x]; i; i = edge[i].nxt){\n\t\t\tint to = edge[i].v;\n\t\t\tif(to == fa[x]) continue;\n\t\t\tdep[to] = dep[x] + 1;\n\t\t\tfa[to] = x;\n\t\t\tPs(to);\n\t\t\tsiz[x] += siz[to];\n\t\t\tif(siz[to] > siz[hev[x]]) hev[x] = to;\n\t\t}\n\t}\n\tvoid dfs(int x, int topp){\n\t\ttop[x] = topp;\n\t\tdfn[x] = ++ sum;\n\t\tif(hev[x]) dfs(hev[x], topp);\n\t\tfor(int i = head[x]; i; i = edge[i].nxt){\n\t\t\tint to = edge[i].v;\n\t\t\tif(to == fa[x] || to == hev[x]) continue;\n\t\t\tdfs(to, to);\n\t\t}\n\t}\n\tvoid cz(){\n\t\tdep[1] = 1;\n\t\tPs(1);\n\t\tdfs(1, 1);\n\t}\n}Pow_tree;\nint read(){\n\tint op = 0, opp = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9'){ if(ch == '-') opp = -1; ch = getchar();}\n\twhile(ch <= '9' && ch >= '0'){ op = (op << 1) + (op << 3) + (ch ^ 48); ch = getchar();}\n\treturn op * opp;\n}\nvoid Build_tree(){\n\tPow_tree.cz();\n\tSt_tree.cz(n);\n}\nvoid Jump(int x){\n\twhile(x){\n\t\tSt_tree.change(1, 1, n, dfn[top[x]], dfn[x], 0);\n\t\tx = fa[top[x]];\n\t}\n}\nvoid maiin(){\n\tn = read();\n\tfor(int i = 1, x, y; i < n; i ++){\n\t\tx = read(); y = read();\n\t\tadd(x, y); add(y, x);\n\t}\n\tBuild_tree();\n\tm = read();\n\tfor(int i = 1, x, y; i <= m; i ++){\n\t\tx = read(); y = read();\n\t\tif(x == 1) St_tree.change(1, 1, n, dfn[y], dfn[y] + siz[y] - 1, 1);\n\t\tif(x == 2) Jump(y);\n\t\tif(x == 3) printf(\"%d\\n\", St_tree.query(1, 1, n, dfn[y]));\n\t}\n}\nint main(){\n\tmaiin();\n\treturn 0;\n}\n```\n\n\u8fd9\u9053\u9898\u6709\u4e2a\u5730\u65b9\u5f88\u7ec6\u8282\uff0c\u5c31\u662f\u5728\u7ebf\u6bb5\u6811\u91cc\uff0c\u6ca1\u6709\u6807\u8bb0\u7684\u65f6\u5019\uff0c$laz$\u4f1a\u88ab\u6807\u8bb0\u4e3a$-1$\uff0c\u8fd9\u6837\u5c31\u4f1a\u9632\u6b62\u6ca1\u6709$0$\u7684\u6807\u8bb0\uff0c\u5374\u64cd\u4f5c\u4e2d\u4e0b\u653e\u4e86$0$\u7684\u6807\u8bb0\uff0c\u5bfc\u81f4\u4e86\u65e0\u6545\u7684$WA$\n",
        "postTime": 1596061608,
        "uid": 93669,
        "name": "Tethys",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "# \u73c2\u6735\u8389\u592a\u53ef\u7231\u4e86\uff01\n\n\u8fd9\u9053\u9898\u663e\u7136\u8981\u7528\u6811\u5256\uff0c\u4f46\u662f\u6211\u61d2\u5f97\u5199\u7ebf\u6bb5\u6811\uff0c\u600e\u4e48\u529e\uff1f\n\n\u5f53\u7136\u8981\u5148\u62ff\u73c2\u6735\u8389\u6811\u5c1d\u8bd5\u9a97\u9a97\u5206\u554a\uff01\n\n\u6811\u5256\u5b8c\u4e86\u4e4b\u540e\uff0c\u6240\u6709\u64cd\u4f5c\u90fd\u5f88\u7b80\u5355\u4e86\uff1a\u4e24\u4e2a\u533a\u95f4\u8986\u76d6\u3001\u4e00\u4e2a\u5355\u70b9\u67e5\u8be2\u3002\n\n\u533a\u95f4\u8986\u76d6\u662f\u73c2\u6735\u8389\u6811\u7684\u6838\u5fc3\u64cd\u4f5c\u554a\uff01\u90a3\u8fd9\u9898\u7528\u73c2\u6735\u8389\u6811\u53ea\u5957\u4e2a\u677f\u5b50\u5c31\u884c\u4e86\u3002\n\n**\u6ce8\u610f\u73c2\u6735\u8389\u6811\u53ea\u80fd\u5e94\u5bf9\u968f\u673a\u6570\u636e\u7684\u60c5\u51b5\uff01**\n\n\u5177\u4f53\u64cd\u4f5c\u89c1\u4ee3\u7801\uff1a\n\n```cpp\n#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,a,b) for(int i=(a);i>=(b);--i)\n#define grep(u) for(int ptr=last[u];ptr;ptr=pre[ptr])\nusing namespace std;\nconst int N=1e6+5;\nint n,target[N],pre[N],last[N],tot=0,q;\nint deep[N],bel[N],dfn[N],sz[N],fa[N],_dfnclock=0;\nvoid add(int u,int v) {\n    target[++tot]=v;\n    pre[tot]=last[u];\n    last[u]=tot;\n}\nvoid dfs1(int u,int f,int dep) {\n    deep[u]=dep;fa[u]=f;sz[u]=1;\n    grep(u) if(target[ptr]!=f) {\n        dfs1(target[ptr],u,dep+1);\n        sz[u]+=sz[target[ptr]];\n    }\n}\nvoid dfs2(int u,int chain) {\n    bel[u]=chain;\n    dfn[u]=++_dfnclock;\n    int maxx=0;\n    grep(u) if(deep[target[ptr]]==deep[u]+1&&sz[target[ptr]]>sz[maxx]) maxx=target[ptr];\n    if(maxx) dfs2(maxx,chain);\n    grep(u) if(deep[target[ptr]]==deep[u]+1&&maxx!=target[ptr]) dfs2(target[ptr],target[ptr]);\n}\nstruct node{\n    int l,r;\n    mutable int v;\n    node(int l,int r,int val):l(l),r(r),v(val){}\n    bool operator <(const node& rhs) const{\n        return l<rhs.l;\n    }\n};\ntypedef set<node>::iterator iter;\nset<node> odt;\niter split(int x) {\n    iter ii=odt.lower_bound(node(x,-1,-1));\n    if(ii!=odt.end()&&ii->l==x) return ii;\n    --ii;\n    int ll=ii->l,rr=ii->r,vv=ii->v;\n    odt.erase(ii);\n    odt.insert(node(ll,x-1,vv));\n    return odt.insert(node(x,rr,vv)).first;\n}\nvoid assign(int l,int r,int v) {\n    iter ri=split(r+1),li=split(l);\n    odt.erase(li,ri);\n    odt.insert(node(l,r,v));\n}\nvoid cover(int u,int v,int val) {\n    while(bel[u]!=bel[v]) {\n        if(deep[bel[u]]<deep[bel[v]]) swap(u,v);\n        assign(dfn[bel[u]],dfn[u],val);\n        u=fa[bel[u]];\n    }\n    if(deep[u]>deep[v]) swap(u,v);\n    assign(dfn[u],dfn[v],val);\n}\nint ask(int x) {\n    int ans=0;\n    iter ri=split(x+1),li=split(x);\n    for(;li!=ri;++li) ans+=li->v;\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n-1) {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        add(u,v);\n        add(v,u);\n    }\n    dfs1(1,0,1);\n    dfs2(1,1);\n    odt.insert(node(1,n,0));\n    scanf(\"%d\",&q);\n    rep(i,1,q) {\n        int cmd,v;\n        scanf(\"%d%d\",&cmd,&v);\n        if(cmd==1) {\n            assign(dfn[v],dfn[v]+sz[v]-1,1);\n        }\n        else if(cmd==2) {\n            cover(v,1,0);\n        }\n        else if(cmd==3) {\n            printf(\"%d\\n\",ask(dfn[v]));\n        }\n    }\n    return 0;\n}\n```",
        "postTime": 1586003056,
        "uid": 76156,
        "name": "henrytb",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\u5176\u5b9e\u5c31\u662f\u6811\u5256\u7684\u6a21\u677f\u9898\uff0c\u533a\u95f4\u8986\u76d6\u641e\u4e00\u641e\u5c31\u8fc7\u4e86\n\n\u5751\u70b9\uff1a1.\u533a\u95f4\u8986\u76d6\u65f6\u7684$lazy$\u6807\u8bb0\u9700\u8981\u8bbe\u4e3a-1 2.\u5355\u70b9\u4fee\u6539\u76f4\u63a5\u53d8\u6210\u533a\u95f4\u4fee\u6539\u5c31\u53ef\u4ee5\u4e86 3.\u4fee\u6539\u5b50\u6811\u7531\u4e8e\u6811\u5256\u7684\u987a\u5e8f\u662f\u8fde\u7eed\u7684\u533a\u95f4\uff0c\u76f4\u63a5\u4fee\u6539$id[x]~id[x]+size[x]-1$\u8fd9\u4e00\u6bb5\u533a\u95f4\u4e2d\u7684\u6570\u5373\u53ef\u3002\n\n\u8bdd\u4e0d\u591a\u8bf4\uff0c\u76f4\u63a5\u4e0a\u4ee3\u7801\uff0c~~\u5927\u4f6c\u4eec\u4e5f\u61d2\u5f97\u770b\uff0c\u8fd9\u4e48\u6c34\u7684\u9898~~\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e6+7;\nstruct node{\n\tint l,r,sum,lazy;\n}tree[maxn*4];\nstruct node1{\n\tint nxt,to;\n}edge[maxn*3];\nint head[maxn],cnt;\nint n,m,x,y;\nvoid add(int x,int y){\n\tedge[++cnt].nxt=head[x];\n\tedge[cnt].to=y;\n\thead[x]=cnt;\n}\nint fa[maxn],dep[maxn],id[maxn],val[maxn],size[maxn],son[maxn],top[maxn],Time;\nvoid dfs1(int x,int f){\n\tfa[x]=f;\n\tsize[x]=1;\n\tdep[x]=dep[f]+1;\n\tint maxson=-1;\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v==fa[x]) continue;\n\t\tdfs1(v,x);\n\t\tsize[x]+=size[v];\n\t\tif(size[v]>maxson){\n\t\t\tmaxson=size[v];\n\t\t\tson[x]=v;\n\t\t}\n\t}\n}\nvoid dfs2(int x,int topf){\n\ttop[x]=topf;\n\tid[x]=++Time;\n\tif(!son[x]) return;\n\tdfs2(son[x],topf);\n\tfor(int i=head[x];i;i=edge[i].nxt){\n\t\tint v=edge[i].to;\n\t\tif(v==son[x]||v==fa[x]) continue;\n\t\tdfs2(v,v);\n\t}\n}\nvoid build(int now,int l,int r){\n\ttree[now].l=l,tree[now].r=r,tree[now].lazy=-1;\n\tif(l==r) return;\n\tint mid=(l+r)>>1;\n\tbuild(now<<1,l,mid);\n\tbuild(now<<1|1,mid+1,r);\n}\nvoid pushdown(int now){\n\tif(tree[now].lazy!=-1){\n\t\ttree[now<<1].sum=(tree[now<<1].r-tree[now<<1].l+1)*tree[now].lazy;\n\t\ttree[now<<1|1].sum=(tree[now<<1|1].r-tree[now<<1|1].l+1)*tree[now].lazy;\n\t\ttree[now<<1].lazy=tree[now].lazy;\n\t\ttree[now<<1|1].lazy=tree[now].lazy;\n\t\ttree[now].lazy=-1;\n\t}\n}\nvoid update(int now,int l,int r,int v){\n\tif(tree[now].l>=l&&tree[now].r<=r){\n\t\ttree[now].sum=(tree[now].r-tree[now].l+1)*v;\n\t\ttree[now].lazy=v;\n\t\treturn;\n\t}\n\tpushdown(now);\n\tint mid=(tree[now].l+tree[now].r)>>1;\n\tif(l<=mid) update(now<<1,l,r,v);\n\tif(r>mid) update(now<<1|1,l,r,v);\n\ttree[now].sum=tree[now<<1].sum+tree[now<<1|1].sum;\n}\nint query(int now,int l,int r){\n\tif(tree[now].l>=l&&tree[now].r<=r) return tree[now].sum;\n\tpushdown(now);\n\tint mid=(tree[now].l+tree[now].r)>>1;\n\tint val=0;\n\tif(l<=mid) val+=query(now<<1,l,r);\n\tif(r>mid) val+=query(now<<1|1,l,r);\n\treturn val; \n}\nvoid link1(int x,int y,int v){\n\twhile(top[x]!=top[y]){\n\t\tif(dep[top[x]]<dep[top[y]]) swap(x,y);\n\t\tupdate(1,id[top[x]],id[x],v);\n\t\tx=fa[top[x]];\n\t}\n\tif(dep[x]<dep[y]) swap(x,y);\n\tupdate(1,id[y],id[x],v);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);add(y,x);\n\t}\n\tdfs1(1,0);dfs2(1,1);build(1,1,n);\n\tscanf(\"%d\",&m);\n\tint opt,ljb;\n\tfor(int i=1;i<=m;i++){\n\t\tscanf(\"%d%d\",&opt,&ljb);\n\t\tif(opt==1) update(1,id[ljb],id[ljb]+size[ljb]-1,1); \n\t\telse if(opt==2) link1(ljb,1,0);\n\t\telse printf(\"%d\\n\",query(1,id[ljb],id[ljb]));\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1565366160,
        "uid": 108746,
        "name": "JBLee",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "### \u9898\u76ee\n[CF343D Water Tree](https://www.luogu.com.cn/problem/CF343D)\n\n### \u601d\u8def\n\u6811\u94fe\u5256\u5206\u3002\n\u6837\u4f8b\u4e2d\u7684\u6811\u957f\u8fd9\u6837:\n\n![](https://cdn.luogu.com.cn/upload/image_hosting/7a68f6sv.png)\n\n\u52a0\u7c97\u7684\u662f\u7ecf\u8fc7 $dfs$ \u627e\u5230\u7684\u91cd\u513f\u5b50\u3002\u6240\u4ee5\u653e\u5230\u7ebf\u6bb5\u6811\u4e0a\u4e4b\u540e\u662f\u8fd9\u6837:\n![](https://cdn.luogu.com.cn/upload/image_hosting/p418z8vq.png)\n\n\u4ee5 $x$ \u4e3a\u6839\u7684\u5b50\u6811\u53ef\u4ee5\u7528 $dfn[x] \\sim dfn[x]+size[x]-1$ \u6765\u8868\u793a\u3002$1$ \u5230 $x$ \u7684\u8def\u5f84\uff1a\u5982\u679c $1$ \u548c $x$ \u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\u5c31\u628a $x$ \u8df3\u5230\u94fe\u9876\u7684\u7236\u4eb2\u7ed3\u70b9\u3002\u5982 $1$ \u548c $4$\uff0c\u56e0\u4e3a $4$ \u53f7\u70b9\u548c $1$ \u53f7\u70b9\u4e0d\u5728\u4e00\u6761\u91cd\u94fe\u4e0a\uff0c$4$ \u53f7\u70b9\u5148\u8df3\u5230 $2$ \u53f7\u70b9\uff0c\u5e76\u5728\u7ebf\u6bb5\u6811\u4e0a\u7ef4\u62a4 $dfn[top[4]] \\sim dfn[4]$\uff08top\u8868\u793a\u94fe\u9876\uff09\uff0c\u8fd9\u6837 $4$ \u53f7\u70b9\u8df3\u5230\u4e86 $2$ \u53f7\u70b9\u5e76\u4e14\u548c $1$ \u53f7\u70b9\u5728\u4e00\u6761\u94fe\u4e0a\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4 $dfn[1] \\sim dfn[2]$\u3002\n\n### Code\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<iostream>\n#include<algorithm>\n#define MAXN 500001\n\ninline void read(int &T) {\n\tint x=0;bool f=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=!f;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\tT=f?-x:x;\n}\n\nint n,q,dfn[MAXN],pre[MAXN],size[MAXN];\n\nnamespace Seg {\n\t#define lson now<<1\n\t#define rson now<<1|1\n\tstruct Node {\n\t\tint l,r,w,lazy;\n\t}tree[MAXN<<2];\n\tvoid pushdown(int now) {\n\t\ttree[lson].lazy=tree[now].lazy;\n\t\ttree[rson].lazy=tree[now].lazy;\n\t\ttree[lson].w=tree[now].lazy;\n\t\ttree[rson].w=tree[now].lazy;\n\t\ttree[now].lazy=-1;\n\t}\n\tvoid build(int l,int r,int now) {\n\t\ttree[now].l=l,tree[now].r=r;\n\t\ttree[now].lazy=-1;\n\t\tif(tree[now].l==tree[now].r) {\n\t\t\ttree[now].w=0;return;\n\t\t}\n\t\tint mid=(tree[now].l+tree[now].r)>>1;\n\t\tbuild(l,mid,lson),build(mid+1,r,rson);\n\t}\n\tvoid update(int x,int y,int k,int now) {\n\t\tif(tree[now].l>=x&&tree[now].r<=y) {\n\t\t\ttree[now].w=k,tree[now].lazy=k;\n\t\t\treturn;\n\t\t}\n\t\tif(tree[now].lazy!=-1) pushdown(now);\n\t\tint mid=(tree[now].l+tree[now].r)>>1;\n\t\tif(x<=mid) update(x,y,k,lson);\n\t\tif(y>mid) update(x,y,k,rson);\n\t}\n\tint ask(int x,int now) {\n\t\tif(tree[now].l==tree[now].r) return tree[now].w;\n\t\tif(tree[now].lazy!=-1) pushdown(now);\n\t\tint mid=(tree[now].l+tree[now].r)>>1;\n\t\tif(x<=mid) return ask(x,lson);\n\t\telse return ask(x,rson);\n\t}\n}\n\nnamespace Cut {\n\tint cnt,pthn,head[MAXN],dep[MAXN];\n\tint fa[MAXN],son[MAXN],top[MAXN];\n\tstruct Edge {\n\t\tint next,to;\n\t}pth[MAXN<<1];\n\tvoid add(int from,int to) {\n\t\tpth[++pthn].to=to,pth[pthn].next=head[from];\n\t\thead[from]=pthn;\n\t}\n\tvoid dfs1(int u,int father) {\n\t\tfa[u]=father,dep[u]=dep[father]+1,size[u]=1;\n\t\tfor(int i=head[u];i;i=pth[i].next) {\n\t\t\tint x=pth[i].to;\n\t\t\tif(x!=father) {\n\t\t\t\tdfs1(x,u),size[u]+=size[x];\n\t\t\t\tif(size[son[u]]<size[x]) son[u]=x;\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs2(int u,int tp) {\n\t\ttop[u]=tp,dfn[u]=++cnt,pre[cnt]=u;\n\t\tif(son[u]) dfs2(son[u],tp);\n\t\tfor(int i=head[u];i;i=pth[i].next) {\n\t\t\tint x=pth[i].to;\n\t\t\tif(x!=fa[u]&&x!=son[u]) dfs2(x,x);\n\t\t}\n\t}\n\tvoid change(int x,int y) {\n\t\twhile(top[x]!=top[y]) {\n\t\t\tif(dep[top[x]]<dep[top[y]]) std::swap(x,y);\n\t\t\tSeg::update(dfn[top[x]],dfn[x],0,1);\n\t\t\tx=fa[top[x]];\n\t\t}\n\t\tif(dep[x]>dep[y]) std::swap(x,y);\n\t\tSeg::update(dfn[x],dfn[y],0,1);\n\t}\n}\n\nint main() {\n\tread(n);\n\tfor(int i=1,u,v;i<n;++i) {\n\t\tread(u),read(v);\n\t\tCut::add(u,v),Cut::add(v,u);\n\t}\n\tCut::dfs1(1,1),Cut::dfs2(1,1),Seg::build(1,n,1);\n\tread(q);\n\tfor(int i=1,opt,x;i<=q;++i) {\n\t\tread(opt),read(x);\n\t\tif(opt==1) Seg::update(dfn[x],dfn[x]+size[x]-1,1,1);\n\t\telse if(opt==2) Cut::change(1,x);\n\t\telse printf(\"%d\\n\",Seg::ask(dfn[x],1));\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1589008678,
        "uid": 142110,
        "name": "yu__xuan",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "## \u4e00\u9053\u6811\u5256\u677f\u5b50\u9898\u3002\n\n- \u6ce8\u610f\u7ebf\u6bb5\u6811\u7684\u61d2\u6807\u8bb0\u521d\u59cb\u503c\u4e3a$-1$\uff0c\u5982\u679c\u662f$0$\uff0c\u90a3\u540e\u9762\u533a\u95f4\u5236\u7a7a\u6216\u533a\u95f4\u704c\u6c34\u5c31\u4f1a\u51fa\u95ee\u9898\u3002\n\n\u4e0d\u4f1a\u6811\u5256\u7684\u53ef\u4ee5\u53bb[\u6a21\u677f](https://www.luogu.com.cn/problem/P3384)\u770b\u770b\u3002\n\n$Code$\uff1a\n\n```cpp\n#include <iostream>\n#include <cstdio>\n#define mid (l+r>>1)\n#define ls x<<1,l,mid\n#define rs x<<1|1,mid+1,r\n#define R 1,1,n\nusing namespace std;\ninline int read(){\n\tregister int x=0,v=1,ch=getchar();\n\twhile(!isdigit(ch)){if(ch=='-')v=-1;ch=getchar();}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^'0');ch=getchar();}\n\treturn x*v;\n}\nconst int MAX=500005;\nint dep[MAX],siz[MAX],fa[MAX],son[MAX];\nint cnt,id[MAX],top[MAX],n,m;\nstruct E{int e,next;}e[MAX<<1];int tot=1,head[MAX];\ninline void Add(int u,int v){\n\te[tot]=(E){v,head[u]};\n\thead[u]=tot++;\n}\nstruct Node{int sum,tag;}tree[MAX<<2]; \nvoid dfs1(int x,int f){\n\tdep[x]=dep[f]+1;fa[x]=f,siz[x]=1;\n\tfor(register int i=head[x];i;i=e[i].next){\n\t\tif(e[i].e!=f){\n\t\t\tdfs1(e[i].e,x);\n\t\t\tsiz[x]+=siz[e[i].e];\n\t\t\tif(!son[x]||siz[e[i].e]>siz[son[x]])son[x]=e[i].e;\n\t\t}\n\t}\n}\nvoid dfs2(int x,int t){\n\tid[x]=++cnt,top[x]=t;\n\tif(son[x]){\n\t\tdfs2(son[x],t);\n\t\tfor(register int i=head[x];i;i=e[i].next){\n\t\t\tif(e[i].e!=fa[x]&&e[i].e!=son[x])dfs2(e[i].e,e[i].e);\n\t\t}\n\t}\n} \ninline void pushup(int x){\n\ttree[x].sum=tree[x<<1].sum+tree[x<<1|1].sum;\n}\ninline void pushdown(int x,int len){\n\tif(tree[x].tag==1){\n\t\ttree[x<<1]=(Node){(len-(len>>1)),1};\n\t\ttree[x<<1|1]=(Node){(len>>1),1};\n\t}\n\tif(tree[x].tag==0){\n\t\ttree[x<<1]=(Node){0,0};\n\t\ttree[x<<1|1]=(Node){0,0};\n\t} \n\ttree[x].tag=-1;\n}\nvoid build(int x,int l,int r){\n\ttree[x].tag=-1;\n\tif(l==r)return ;\n\tbuild(ls);build(rs);\n}\nvoid modify(int x,int l,int r,int s,int t,int v){\n\tif(s<=l&&r<=t){\n\t\ttree[x]=(Node){(r-l+1)*v,v};\n\t\treturn ;\n\t}\n\tpushdown(x,r-l+1);\n\tif(s<=mid)modify(ls,s,t,v);\n\tif(mid<t)modify(rs,s,t,v);\n\tpushup(x); \n}\nint query(int x,int l,int r,int s,int t){\n\tif(s<=l&&r<=t)return tree[x].sum;\n\tpushdown(x,r-l+1);register int res=0;\n\tif(s<=mid)res+=query(ls,s,t);\n\tif(mid<t)res+=query(rs,s,t);\n\treturn res;\n}\nvoid Tree_modify(int u,int v){\n\twhile(top[u]!=top[v]){\n\t\tif(dep[top[u]]<dep[top[v]])swap(u,v);\n\t\tmodify(R,id[top[u]],id[u],0);\n\t\tu=fa[top[u]];\n\t}\n\tif(dep[u]<dep[v])swap(u,v);\n\tmodify(R,id[v],id[u],0); \n}\nvoid Son_modify(int u){\n\tmodify(R,id[u],id[u]+siz[u]-1,1);\n}\nint s,t;\nint main(){\n\tn=read();\n\tfor(register int i=1;i<n;++i){\n\t\ts=read(),t=read();\n\t\tAdd(s,t);Add(t,s);\n\t}\n\tdfs1(1,0);dfs2(1,1);build(1,1,n); \n\tm=read();\n\twhile(m--){\n\t\ts=read(),t=read();\n\t\tif(s==1){\n\t\t\tSon_modify(t);\n\t\t}else if(s==2){\n\t\t\tTree_modify(t,1);\n\t\t}else{\n\t\t\tprintf(\"%d\\n\",query(R,id[t],id[t]));\n\t\t}\n\t}\n\treturn 0;\n}\n```\n",
        "postTime": 1581563901,
        "uid": 119062,
        "name": "Lates",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\u4e0d\u96be\u53d1\u73b0\uff0c\u9898\u76ee\u8981\u6211\u4eec\u7ef4\u62a4\u4ee5\u4e0b\u4e09\u79cd\u64cd\u4f5c\u3002\n\n1. \u94fe\u8d4b\u503c\n\n2. \u5b50\u6811\u8d4b\u503c\n\n3. \u5355\u70b9\u67e5\u8be2\n\n$ODT$ \u53ef\u4ee5\u5f88\u597d\u7684\u89e3\u51b3\u8fd9\u7c7b\u95ee\u9898\uff0c\u6211\u4eec\u53ea\u9700\u8981\u7528 $ODT$ \u6765\u7ef4\u62a4\u6811\u5256\u7684 $DFS$ \u5e8f\u5373\u53ef\u3002\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\ninline bool read(T &ret)\n{\n    char c;\n    int sgn;\n    if (c = getchar(), c == EOF)\n    {\n        return 0;\n    }\n    while (c != '-' && (c < '0' || c > '9'))\n    {\n        c = getchar();\n    }\n    sgn = (c == '-') ? -1 : 1;\n    ret = (c == '-') ? 0 : (c - '0');\n    while (c = getchar(), c >= '0' && c <= '9')\n    {\n        ret = ret * 10 + (c - '0');\n    }\n    ret *= sgn;\n    return 1;\n}\n\ntemplate <class T>\ninline void write(T x)\n{\n    if (x > 9)\n    {\n        write(x / 10);\n    }\n    putchar(x % 10 + '0');\n}\n\nconst int MAXN=1e6+10;\n\nstruct node\n{\n    int l,r;\n    mutable int v;\n    node(int L,int R=-1,int V=0):l(L),r(R),v(V) {}\n    bool operator <(const node &o) const\n    {\n        return l<o.l;\n    }\n};\n\nstruct edge\n{\n    int u,v,nex;\n};\n\nset<node> s;\nedge e[MAXN<<1];\nint head[MAXN],cnt=0;\nint dep[MAXN],sz[MAXN],son[MAXN],top[MAXN],fa[MAXN],id[MAXN],tot=0;\nint n,m;\n\ninline void add(int u,int v)\n{\n    e[++cnt].u=u;\n    e[cnt].v=v;\n    e[cnt].nex=head[u];\n    head[u]=cnt;\n}\n\ninline set<node>::iterator split(int pos)\n{\n    set<node>::iterator it=s.lower_bound(node(pos));\n    if(it!=s.end()&&it->l==pos)\n        return it;\n    --it;\n    int L=it->l,R=it->r,V=it->v;\n    s.erase(it);\n    s.insert(node(L,pos-1,V));\n    return s.insert(node(pos,R,V)).first;\n}\n\ninline void assignval(int l,int r,int v)\n{\n    set<node>::iterator itr=split(r+1),itl=split(l);\n    s.erase(itl,itr);\n    s.insert(node(l,r,v));\n}\n\ninline int sum(int pos)\n{\n    set<node>::iterator it=split(pos);\n    write(it->v);\n    putchar('\\n');\n}\n\nvoid dfs1(int u)\n{\n    sz[u]=1;\n    for(int i=head[u];i;i=e[i].nex)\n    {\n        int v=e[i].v;\n        if(v==fa[u]) continue;\n        dep[v]=dep[u]+1;\n        fa[v]=u;\n        dfs1(v);\n        sz[u]+=sz[v];\n        if(sz[v]>sz[son[u]])\n            son[u]=v;\n    }\n}\n\nvoid dfs2(int u,int tp)\n{\n    top[u]=tp;\n    id[u]=++tot;\n    if(!son[u])\n        return;\n    dfs2(son[u],tp);\n    for(int i=head[u];i;i=e[i].nex)\n    {\n        int v=e[i].v;\n        if(v!=fa[u]&&v!=son[u]) dfs2(v,v);\n    }\n}\n\ninline void update(int pos)\n{\n    int tpos=top[pos];\n    while(tpos!=1)\n    {\n        assignval(id[tpos],id[pos],0);\n        pos=fa[tpos],tpos=top[pos];\n    }\n    assignval(id[1],id[pos],0);\n}\n\nint main()\n{\n    read(n);\n    for(int i=1;i<n;i++)\n    {\n        int x,y;\n        read(x),read(y);\n        add(x,y);\n        add(y,x);\n    }\n    dfs1(1);\n    dfs2(1,1);\n    s.insert(node(0,500010));\n    read(m);\n    while(m--)\n    {\n        int op,sr;\n        read(op),read(sr);\n        if(op==1)\n            assignval(id[sr],id[sr]+sz[sr]-1,1);\n        else if(op==2)\n            update(sr);\n        else\n            sum(id[sr]);\n    }\n    return 0;\n}\n```\n",
        "postTime": 1570102882,
        "uid": 102473,
        "name": "Setsugesuka",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\u5f88\u6c34\u7684\u4e00\u9053\u9898 \u5927\u529b\u6811\u5256\u5c31\u5b8c\u4e8b\u4e86 nlog^2n\u8dd150w\u6700\u5927case\u624d700ms (\u6811\u5256\u5b9e\u9645\u4e0a\u8dd1\u4e0d\u6ee1\u7684\u590d\u6742\u5ea6)\u8fd9\u9898\u5c31\u662f\u5f88\u663e\u7136\u7684\u533a\u95f4\u8986\u76d6+\u6811\u5256 \u5982\u679c\u677f\u5b50\u5c01\u88c5\u7684\u597d\uff0c\u8fb9\u754c\u6761\u4ef6\u90fd\u6709\u826f\u6027\u7684\u5b9a\u4e49\uff0c\u8fd9\u9898\u751a\u81f3\u8fde\u7ec6\u8282\u96be\u5ea6\u90fd\u6ca1\u6709\u4e86\u3002\u3002\u3002 \u5982\u679c\u8fd8\u60f3\u66f4\u5feb\u7684\u8bdd\u4e0d\u5efa\u7acb\u5168\u5c40\u7ebf\u6bb5\u6811\u800c\u662f\u9488\u5bf9\u6bcf\u4e2a\u91cd\u94fe\u5efa\u7ebf\u6bb5\u6811\u5e94\u8be5\u5c31\u80fd\u5f97\u5230\u66f4\u4f18\u7684\u590d\u6742\u5ea6\u4e86 \u5982\u679c\u8003\u8651\u4ee3\u7801\u957f\u5ea6\u7684\u8bdd\u8fd8\u662f\u8003\u8651ODT+\u6811\u5256\u597d\uff081800ms\uff09\n\n\u7ebf\u6bb5\u6811+\u6811\u5256\u4ee3\u7801\uff1a\n\n```cpp\n\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<deque>\n#include<iomanip>\n#include<sstream>\n#include<stack>\n#include<iostream>\n#include<limits>\n#include<bitset>\n#include<list>\n#include<queue>\n#include<memory>\n#include<functional>\n#include<cstdio>\n#include<array>\nusing namespace std;\nusing namespace std;\nconst int N = 602000;\nnamespace tree_split1\n{\n\t//\u524d\u5411\u661f\u90e8\u5206\n\tstruct graph\n\t{\n\t\tint Begin[N * 2], to[N * 2], Next[N * 2], e, weight[N * 2];\n\t\tvoid add(int u, int v)\n\t\t{\n\t\t\tto[++e] = v;\n\t\t\tNext[e] = Begin[u];\n\t\t\tBegin[u] = e;\n\t\t}\n\t\tvoid add(int u, int v, int w)\n\t\t{\n\t\t\tto[++e] = v;\n\t\t\tNext[e] = Begin[u];\n\t\t\tBegin[u] = e;\n\t\t\tweight[e] = w;\n\t\t}\n\t\tvoid init_graph()\n\t\t{\n\t\t\te = 0;\n\t\t\tmemset(Begin, -1, sizeof(Begin));\n\t\t}\n\t};\n\tint id[N];\n\tclass tree_split\n\t{\n\tpublic:\n\t\tlong long dep[N], fa[N], top[N], size1[N], son[N], weight[N], new_weight[N];\n\t\tint len;\n\t\tgraph g;\n\t\ttree_split()\n\t\t{\n\t\t\tmemset(fa, 0, sizeof(fa));\n\t\t\tmemset(top, 0, sizeof(top));\n\t\t\tmemset(size1, 0, sizeof(size1));\n\t\t\tmemset(son, 0, sizeof(son));\n\t\t\tmemset(g.Begin, -1, sizeof(g.Begin));\n\t\t\tmemset(weight, 0, sizeof(weight));\n\t\t\tlen = 0;\n\t\t}\n\t\tvoid init(int root)\n\t\t{\n\t\t\tdep[root] = 0;\n\t\t\tdfs1(root, root);\n\t\t\tdfs2(root, root);\n\t\t}\n\t\tvoid add_weight(int i, int w)\n\t\t{\n\t\t\tweight[i] = w;\n\t\t}\n\t\tvoid add_edge(int u, int v)\n\t\t{\n\t\t\tg.add(u, v);\n\t\t\tg.add(v, u);\n\t\t}\n\t\tvoid dfs1(int u, int father)//\u4e00\u548c\u4e8c\u662f\u5b8c\u6574\u6811\u94fe\u5256\u5206\u7684\u9884\u5904\u7406\n\t\t{\n\t\t\tdep[u] = dep[father] + 1;\n\t\t\tfa[u] = father;\n\t\t\tsize1[u] = 1;\n\t\t\tfor (int i = g.Begin[u]; i != -1; i = g.Next[i])\n\t\t\t{\n\t\t\t\tif (g.to[i] != father)\n\t\t\t\t{\n\t\t\t\t\tdfs1(g.to[i], u);\n\t\t\t\t\tsize1[u] += size1[g.to[i]];\n\t\t\t\t\tif (size1[g.to[i]] > size1[son[u]])\n\t\t\t\t\t\tson[u] = g.to[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid dfs2(int u, int topf)\n\t\t{\n\t\t\tid[u] = ++len;\n\t\t\tnew_weight[len] = weight[u];\n\t\t\ttop[u] = topf;\n\t\t\tif (son[u] == 0)return;\n\t\t\tdfs2(son[u], topf);\n\t\t\tfor (int i = g.Begin[u]; i != -1; i = g.Next[i])\n\t\t\t{\n\t\t\t\tif (g.to[i] == fa[u] || g.to[i] == son[u]) continue;\n\t\t\t\tdfs2(g.to[i], g.to[i]);\n\t\t\t}\n\t\t}\n\t\tint find(int u)\n\t\t{\n\t\t\treturn top[u] = top[u] == u ? u : find(top[u]);\n\t\t}\n\t\tint LCA(int u, int v) {\n\t\t\tif (find(u) != find(v))\n\t\t\t\treturn dep[top[u]] > dep[top[v]] ? LCA(fa[top[u]], v) : LCA(u, fa[top[v]]);\n\t\t\telse return dep[u] > dep[v] ? v : u;\n\t\t}\n\t}tp;\n}\nusing namespace tree_split1;\nnamespace segment_tree\n{\n\t/**\n\t*    \u57fa\u7840\u90e8\u5206\n\t**/\n\tstruct node\n\t{\n\t\tint L, R, sum, sum2, modify;\n\t\tbool lazy;\n\t};\n\tstruct tree\n\t{\n\t\tnode tree_pool[N * 4];\n\t\tint pool[N];\n\t\tvoid clear_tree(int sum)\n\t\t{\n\t\t\tmemset(pool, 0, sizeof(pool));\n\t\t\tfor (int i = 0; i < sum * 4; ++i)\n\t\t\t\ttree_pool[i].lazy = false;\n\t\t}\n\t\tvoid update(int cur)\n\t\t{\n\t\t\ttree_pool[cur].sum = tree_pool[cur << 1].sum + tree_pool[(cur << 1) + 1].sum;\n\t\t}\n\t\tvoid build(int cur, int L, int R)\n\t\t{\n\t\t\tint mid = (L + R) / 2;\n\t\t\ttree_pool[cur].L = L;\n\t\t\ttree_pool[cur].R = R;\n\t\t\ttree_pool[cur].sum2 = 0;\n\t\t\ttree_pool[cur].modify = 0;\n\t\t\tif (L == R)\n\t\t\t{\n\t\t\t\ttree_pool[cur].sum = pool[L];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbuild(cur << 1, L, mid);\n\t\t\tbuild((cur << 1) + 1, mid + 1, R);\n\t\t\tupdate(cur);\n\t\t}\n\t\tvoid push_down_modify(int cur)\n\t\t{\n\t\t\ttree_pool[cur].sum = tree_pool[cur].sum2*(tree_pool[cur].R - tree_pool[cur].L + 1);\n\t\t\ttree_pool[cur].lazy = false;\n\t\t\tif (tree_pool[cur].L != tree_pool[cur].R)\n\t\t\t{\n\t\t\t\ttree_pool[cur << 1].lazy = true;\n\t\t\t\ttree_pool[(cur << 1) + 1].lazy = true;\n\t\t\t\ttree_pool[cur << 1].sum2 = tree_pool[cur].sum2;\n\t\t\t\ttree_pool[cur << 1].sum = tree_pool[cur << 1].sum2*(tree_pool[cur << 1].R - tree_pool[cur << 1].L + 1);\n\t\t\t\ttree_pool[(cur << 1) + 1].sum2 = tree_pool[cur].sum2;\n\t\t\t\ttree_pool[(cur << 1) + 1].sum = tree_pool[(cur << 1) + 1].sum2*(tree_pool[(cur << 1) + 1].R - tree_pool[(cur << 1) + 1].L + 1);\n\t\t\t}\n\t\t}\n\t\tvoid range_modify(int cur, int L, int R, int k)\n\t\t{\n\t\t\tint ans = 0, mid = (tree_pool[cur].L + tree_pool[cur].R) / 2;\n\t\t\tif (tree_pool[cur].lazy == true)\n\t\t\t\tpush_down_modify(cur);\n\t\t\tif (L == tree_pool[cur].L && R == tree_pool[cur].R)\n\t\t\t{\n\t\t\t\ttree_pool[cur].sum2 = k;\n\t\t\t\ttree_pool[cur].sum = k * (tree_pool[cur].R - tree_pool[cur].L + 1);\n\t\t\t\ttree_pool[cur].lazy = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (L <= mid && R > mid)\n\t\t\t{\n\t\t\t\trange_modify((cur << 1), L, mid, k);\n\t\t\t\trange_modify((cur << 1) + 1, mid + 1, R, k);\n\t\t\t}\n\t\t\telse if (R <= mid)\n\t\t\t\trange_modify((cur << 1), L, R, k);\n\t\t\telse if (L >= mid + 1)\n\t\t\t\trange_modify((cur << 1) + 1, L, R, k);\n\t\t\tupdate(cur);\n\t\t}\n\t\tint range_ask_sum_modify(int cur, int L, int R)\n\t\t{\n\t\t\tint ans = 0, mid = (tree_pool[cur].L + tree_pool[cur].R) / 2;\n\t\t\tif (tree_pool[cur].lazy)\n\t\t\t\tpush_down_modify(cur);\n\t\t\tif (L == tree_pool[cur].L && R == tree_pool[cur].R)\n\t\t\t\treturn tree_pool[cur].sum;\n\t\t\tif (L <= mid && R > mid)\n\t\t\t\tans += range_ask_sum_modify((cur << 1), L, mid) + range_ask_sum_modify((cur << 1) + 1, mid + 1, R);\n\t\t\telse if (R <= mid)\n\t\t\t\tans += range_ask_sum_modify((cur << 1), L, R);\n\t\t\telse if (L >= mid + 1)\n\t\t\t\tans += range_ask_sum_modify((cur << 1) + 1, L, R);\n\t\t\treturn ans;\n\t\t}\n\t}tree;\n}\nusing namespace segment_tree;\nstruct FastIO {\n\tstatic const int S = 1e7;\n\tint wpos;\n\tchar wbuf[S];\n\tFastIO() : wpos(0) {}\n\tinline int xchar() {\n\t\tstatic char buf[S];\n\t\tstatic int len = 0, pos = 0;\n\t\tif (pos == len)\n\t\t\tpos = 0, len = fread(buf, 1, S, stdin);\n\t\tif (pos == len) exit(0);\n\t\treturn buf[pos++];\n\t}\n\tinline int xuint() {\n\t\tint c = xchar(), x = 0;\n\t\twhile (c <= 32) c = xchar();\n\t\tfor (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n\t\treturn x;\n\t}\n\tinline int readint()\n\t{\n\t\tint s = 1, c = xchar(), x = 0;\n\t\twhile (c <= 32) c = xchar();\n\t\tif (c == '-') s = -1, c = xchar();\n\t\tfor (; '0' <= c && c <= '9'; c = xchar()) x = x * 10 + c - '0';\n\t\treturn x * s;\n\t}\n\tinline void xstring(char *s)\n\t{\n\t\tint c = xchar();\n\t\twhile (c <= 32) c = xchar();\n\t\tfor (; c > 32; c = xchar()) * s++ = c;\n\t\t*s = 0;\n\t}\n\tinline void wchar(int x)\n\t{\n\t\tif (wpos == S) fwrite(wbuf, 1, S, stdout), wpos = 0;\n\t\twbuf[wpos++] = x;\n\t}\n\tinline void wint(int x)\n\t{\n\t\tif (x < 0) wchar('-'), x = -x;\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n) s[n++] = '0' + x % 10, x /= 10;\n\t\twhile (n--) wchar(s[n]);\n\t\t//wchar('\\n');\n\t}\n\tinline void wint(long long x)\n\t{\n\t\tif (x < 0) wchar('-'), x = -x;\n\t\tchar s[24];\n\t\tint n = 0;\n\t\twhile (x || !n) s[n++] = '0' + x % 10, x /= 10;\n\t\twhile (n--) wchar(s[n]);\n\t\t//wchar('\\n');\n\t}\n\tinline void wstring(string &s)\n\t{\n\t\tfor (auto &p : s)\n\t\t\twchar(p);\n\t}\n\t~FastIO()\n\t{\n\t\tif (wpos) fwrite(wbuf, 1, wpos, stdout), wpos = 0;\n\t}\n} io;\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tint n, m, q,op,x,u,v;\n\tn = io.readint();\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tu = io.readint();\n\t\tv = io.readint();\n\t\ttp.add_edge(u, v);\n\t}\n\ttp.init(1);\n\ttree.clear_tree(n);\n\ttree.build(1, 1, n);\n\tq = io.readint();\n\twhile (q--)\n\t{\n\t\top = io.readint();\n\t\tx = io.readint();\n\t\tif (op == 1)\n\t\t\ttree.range_modify(1,id[x], id[x] + tp.size1[x] - 1, 1);\n\t\telse if (op == 2)\n\t\t{\n\t\t\tint y=tp.top[x];\n\t\t\twhile (y != 1)\n\t\t\t{\n\t\t\t\ttree.range_modify(1,id[y], id[x], 0);\n\t\t\t\tx = tp.fa[tp.top[x]];\n\t\t\t\ty = tp.top[x];\n\t\t\t}\n\t\t\ttree.range_modify(1,id[y], id[x], 0);\n\t\t}\n\t\telse\n\t\t\tio.wint(tree.range_ask_sum_modify(1,id[x], id[x])),io.wchar('\\n');\n\t}\n\treturn 0;\n}\n\n\n\n```\n",
        "postTime": 1555575976,
        "uid": 154957,
        "name": "qiyue7",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\u601d\u8def\uff1a\u6811\u94fe\u5256\u5206\n\n\u6811\u5256\u540e\uff0c\u968f\u4fbf\u778e\u505a\u505a\u4e0d\u5c31\u884c\u4e86\u5417\u2026\u2026\n\n\u8fd9\u91cc\u53ea\u8bf4\u51e0\u4e2a\u7ec6\u8282\n\n\u770b\u5230\u697c\u4e0b\u6709\u4eba\u8bf4\u53ea\u4f1a\u201c\u533a\u95f4\u52a0\u201d\u4e0d\u4f1a\u201c\u533a\u95f4\u8d4b\u503c\u201d\uff0c\u5176\u5b9e\u4e24\u8005\u5f88\u7c7b\u4f3c\uff0c\u628a+=\u6539\u6210=\u5c31\u884c\u4e86\n\n\u6211\u7684\u4ee3\u7801\u91cc\u5bf9\u4e8eadd\u6807\u8bb0\u662f\u8fd9\u4e48\u5904\u7406\u7684\uff1a\u82e5$add=-1$\uff0c\u8868\u793a\u6ca1\u6709\u6807\u8bb0\uff0c\u5426\u5219\u8868\u793a\u5bf9\u5e94\u6807\u8bb0\n\n\u53e6\u5916\u5355\u72ec\u5199\u5355\u70b9\u67e5\u8be2\u5f88\u9ebb\u70e6\uff0c\u4e8e\u662f\u6211\u5199\u7684\u662f\u533a\u95f4\u67e5\u8be2\uff08\u8c03\u7528\u65f6\u7c7b\u4f3c$query(i,i)$\uff09\n\n\u5199\u7684\u65f6\u5019\u72af\u4e86\u4e00\u4e2a$SB$\u9519\u8bef\uff1a\u5c45\u7136\u6ca1\u6709\u5efa\u7ebf\u6bb5\u6811\u5c31\u5f00\u59cb\u8dd1\u4e86\uff0c\u6b7b\u78d5\u6837\u4f8b\uff08\u83ab\u540d\u5c34\u5c2c\uff09\n\n~~\u6211\u624d\u4e0d\u4f1a\u544a\u8bc9\u4f60\u6211\u662f\u628a\u4e4b\u524d\u51e0\u9053\u6811\u5256\u4ee3\u7801\u62fc\u5728\u4e00\u8d77\u5462~~\n\n\u4ee3\u7801\uff1a\n\n```cpp\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint w[500001]={};\nvector<int> ed[500001]={};\nint fa[500001],dep[500001],sz[500001],son[500001],top[500001],seg[500001],rev[500001];\n\nvoid dfs_bas(int pos=1,int f=0)\n{\n    sz[pos]=1,fa[pos]=f,dep[pos]=dep[f]+1;\n    for(int i=0,v=0;i<ed[pos].size();i++)\n    {\n        v=ed[pos][i];\n        if(v!=f)\n        {\n            dfs_bas(v,pos);\n            sz[pos]+=sz[v];\n            if(sz[v]>sz[son[pos]])\n            {\n                son[pos]=v;\n            }\n        }\n    }\n}\nvoid dfs_sec(int pos=1,int f=0)\n{\n    if(son[pos])\n    {\n        seg[son[pos]]=++seg[0];\n        top[son[pos]]=top[pos];\n        rev[seg[0]]=son[pos];\n        dfs_sec(son[pos],pos);\n    }\n    for(int i=0,v=0;i<ed[pos].size();i++)\n    {\n        v=ed[pos][i];\n        if(top[v])\n        {\n            continue;\n        }\n        \n        seg[v]=++seg[0];\n        rev[seg[0]]=v;\n        top[v]=v;\n        dfs_sec(v,pos);\n    }\n}\n\nstruct nd\n{\n    int l,r,sum,add;\n}t[2000001]={};\nvoid build(int l,int r,int k=1)\n{\n    t[k].l=l,t[k].r=r,t[k].add=-1,t[k].sum=0;\n    if(l==r)\n    {\n        return;\n    }\n    int mid=(l+r)/2;\n    build(l,mid,k*2),build(mid+1,r,k*2+1);\n}\nvoid spread(int k)\n{\n    if(t[k].add==-1)\n    {\n        return;\n    }\n    t[k*2].sum=(t[k*2].r-t[k*2].l+1)*t[k].add,t[k*2+1].sum=(t[k*2+1].r-t[k*2+1].l+1)*t[k].add;\n    t[k*2].add=t[k*2+1].add=t[k].add;\n    t[k].add=-1;\n}\n\nint query(int l,int r,int k=1)\n{\n    if(l>t[k].r||r<t[k].l)\n    {\n        return 0;\n    }\n    if(l<=t[k].l&&r>=t[k].r)\n    {\n        return t[k].sum;\n    }\n    spread(k);\n    return query(l,r,k*2)+query(l,r,k*2+1);\n}\nvoid change(int l,int r,int v,int k=1)\n{\n    if(l>t[k].r||r<t[k].l)\n    {\n        return;\n    }\n    if(l<=t[k].l&&r>=t[k].r)\n    {\n        t[k].sum=v*(t[k].r-t[k].l+1),t[k].add=v;return;\n    }\n    spread(k);change(l,r,v,k*2),change(l,r,v,k*2+1);\n    t[k].sum=t[k*2].sum+t[k*2+1].sum;\n}\nint ask_road(int x,int y)\n{\n    int fx=top[x],fy=top[y],ans=0;\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])\n        {\n            swap(fx,fy),swap(x,y);\n        }\n        ans+=query(seg[fx],seg[x]);\n        x=fa[fx];fx=top[x];\n    }\n    if(dep[x]>dep[y])\n    {\n        swap(x,y);\n    }\n    return ans+query(seg[x],seg[y]);\n}\nvoid change_road(int x,int y,int v)\n{\n    int fx=top[x],fy=top[y];\n    while(fx!=fy)\n    {\n        if(dep[fx]<dep[fy])\n        {\n            swap(fx,fy),swap(x,y);\n        }\n        change(seg[fx],seg[x],v);\n        x=fa[fx];fx=top[x];\n    }\n    if(dep[x]>dep[y])\n    {\n        swap(x,y);\n    }\n    change(seg[x],seg[y],v);\n}\n\nint ask_sbt(int x)\n{\n    return query(seg[x],seg[x]+sz[x]-1);\n}\nvoid change_sbt(int x,int v)\n{\n    change(seg[x],seg[x]+sz[x]-1,v);\n}\n\nint main()\n{\n\tint n=0;scanf(\"%d\",&n);\n    for(int i=1,a=0,b=0;i<n;i++)\n    {\n        scanf(\"%d%d\",&a,&b);\n        ed[a].push_back(b),ed[b].push_back(a);\n    }\n    dfs_bas();\n    \n    \n    seg[0]=seg[1]=top[1]=rev[1]=1;\n    dfs_sec();\n    \n    build(1,n);//\u5343\u4e07\u522b\u5fd8\u4e86\u8fd9\u4e2a\uff01\uff01\uff01\n    \n    int q=0;scanf(\"%d\",&q);\n    int c=0,v=0;\n    while(q--)\n    {\n    \tscanf(\"%d%d\",&c,&v);\n    \tswitch(c)\n    \t{\n    \t\tcase 1:\n    \t\t\tchange_sbt(v,1);\n    \t\t\tbreak;\n    \t\tcase 2:\n    \t\t\tchange_road(1,v,0);\n    \t\t\tbreak;\n    \t\tcase 3:\n    \t\t\tprintf(\"%d\\n\",ask_road(v,v));\n    \t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1549529543,
        "uid": 112794,
        "name": "\u5468\u5b50\u8861",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "### @ Fuko_Ibuki orz !!! \u7adf\u7136\u7528\u4e86\u533a\u95f4\u8986\u76d6\u7684\u7ebf\u6bb5\u6811\uff0c\u4e0d\u6127\u662f\u5927\u4f6c\u554a\uff01\n\n\u50cf\u6211\u8fd9\u79cd\u849f\u84bb\u53ea\u4f1a\u7528\u6700\u7b80\u5355\u7684\u533a\u95f4\u52a0\u7ebf\u6bb5\u6811\u554aQAQ\n\n\u597d\u7684\uff0c\u5176\u5b9e\u5427\uff0c\u533a\u95f4\u52a0\u7ebf\u6bb5\u6811\u4e5f\u80fd\u5b8c\u5168\u80dc\u4efb\u8fd9\u8fd9\u9053\u9898\u7684\uff0c\u6bd5\u7adf\u662f\u5355\u70b9\u67e5\u8be2\u561b~\n\n\u4e4b\u540e\u5c31\u53ea\u662f\u6700\u57fa\u672c\u7684\u6811\u94fe\u5256\u5206\u64cd\u4f5c\uff1a\u8def\u5f84\u4fee\u6539\u548c\u5b50\u6811\u4fee\u6539\u4e86\uff0c\u67e5\u8be2\u662f\u5355\u70b9\u67e5\u8be2\u7684\uff0c\u8fdepush_up\u90fd\u4e0d\u7528\u5199\u554a\u2026\u2026\n\n\u590d\u6742\u5ea6\u7684\u8bdd\u5e94\u8be5\u662fnlognlogn\u7684\uff0c\u611f\u89c950w\u6709\u70b9\u865a\uff0c\u4f46\u4e8b\u5b9e\u4e0a\u6700\u5927\u7684\u70b9\u4e5f\u53ea\u8dd1\u4e86\u4e0d\u52301s\uff0c\u57fa\u672c\u4e0a\u8fd8\u662f\u7a33\u5f97\u5566\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define lson root<<1\n#define rson root<<1|1\nusing namespace std;\n\nstruct node\n{\n\tint l,r,sum,lazy;\n}tr[2000020];\nvector<int> g[500050];\nint deep[500050],size[500050],fa[500050],son[500050],id[500050],top[500050],cnt;\n\nvoid push_down(int root)\n{\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\ttr[lson].sum=tr[root].lazy*(mid-tr[root].l+1);\n\ttr[lson].lazy=tr[root].lazy;\n\ttr[rson].sum=tr[root].lazy*(tr[root].r-mid);\n\ttr[rson].lazy=tr[root].lazy;\n\ttr[root].lazy=-1;\n}\n\nvoid build(int root,int l,int r)\n{\n\tif(l==r)\n\t{\n\t\ttr[root].l=l;\n\t\ttr[root].r=r;\n\t\ttr[root].lazy=-1;\n\t\ttr[root].sum=0;\n\t\treturn ;\n\t}\n\ttr[root].l=l;\n\ttr[root].r=r;\n\ttr[root].lazy=-1;\n\tint mid=(l+r)>>1;\n\tbuild(lson,l,mid);\n\tbuild(rson,mid+1,r);\n}\n\nvoid update(int root,int l,int r,int val)\n{\n\tif(tr[root].l==l&&tr[root].r==r)\n\t{\n\t\ttr[root].sum=val;\n\t\ttr[root].lazy=val;\n\t\treturn ;\n\t}\n\tif(~tr[root].lazy)\n\t{\n\t\tpush_down(root);\n\t}\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\tif(mid<l)\n\t{\n\t\tupdate(rson,l,r,val);\n\t}\n\telse\n\t{\n\t\tif(mid>=r)\n\t\t{\n\t\t\tupdate(lson,l,r,val);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(lson,l,mid,val);\n\t\t\tupdate(rson,mid+1,r,val);\n\t\t}\n\t}\n}\n\nint query(int root,int l,int r)\n{\n\tif(tr[root].l==l&&tr[root].r==r)\n\t{\n\t\treturn tr[root].sum;\n\t}\n\tif(~tr[root].lazy)\n\t{\n\t\tpush_down(root);\n\t}\n\tint mid=(tr[root].l+tr[root].r)>>1;\n\tif(mid<l)\n\t{\n\t\treturn query(rson,l,r);\n\t}\n\telse\n\t{\n\t\tif(mid>=r)\n\t\t{\n\t\t\treturn query(lson,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn query(lson,l,mid)+query(rson,mid+1,r); \n\t\t}\n\t}\n}\n\nvoid dfs1(int now,int f,int dep)\n{\n\tfa[now]=f;\n\tsize[now]=1;\n\tdeep[now]=dep;\n\tint maxson=-1;\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\tif(g[now][i]==f)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs1(g[now][i],now,dep+1);\n\t\tsize[now]+=size[g[now][i]];\n\t\tif(size[g[now][i]]>maxson)\n\t\t{\n\t\t\tmaxson=size[g[now][i]];\n\t\t\tson[now]=g[now][i];\n\t\t}\n\t}\n}\n\nvoid dfs2(int now,int topf)\n{\n\tid[now]=++cnt;\n\ttop[now]=topf;\n\tif(!son[now])\n\t{\n\t\treturn ;\n\t}\n\tdfs2(son[now],topf);\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\tif(g[now][i]==son[now]||g[now][i]==fa[now])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tdfs2(g[now][i],g[now][i]);\n\t}\n}\n\nvoid sub_update(int x)\n{\n\tupdate(1,id[x],id[x]+size[x]-1,1);\n}\n\nvoid path_update(int u,int v)\n{\n\twhile(top[u]!=top[v])\n\t{\n\t\tif(deep[top[u]]<deep[top[v]])\n\t\t{\n\t\t\tswap(u,v);\n\t\t}\n\t\tupdate(1,id[top[u]],id[u],0);\n\t\tu=fa[top[u]];\n\t}\n\tif(deep[u]>deep[v])\n\t{\n\t\tswap(u,v);\n\t}\n\tupdate(1,id[u],id[v],0);\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint from,to;\n\t\tscanf(\"%d%d\",&from,&to);\n\t\tg[from].push_back(to);\n\t\tg[to].push_back(from);\n\t}\n\tdfs1(1,0,1);\n\tdfs2(1,1);\n\tbuild(1,1,n);\n\tint m;\n\tscanf(\"%d\",&m);\n\twhile(m--)\n\t{\n\t\tint kd,u;\n\t\tscanf(\"%d%d\",&kd,&u);\n\t\tif(kd==1)\n\t\t{\n\t\t\tsub_update(u);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(kd==2)\n\t\t\t{\n\t\t\t\tpath_update(1,u);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\",query(1,id[u],id[u]));\n\t\t\t}\n\t\t}\n\t}\n}\n\n```",
        "postTime": 1525672109,
        "uid": 48740,
        "name": "Styx",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    },
    {
        "content": "\n```cpp\n/*\n\u8fd9\u9898\u7684\u64cd\u4f5c,\u8be2\u95ee\u7684\u7c7b\u578b\u662f\u533a\u95f4\u8986\u76d6.\u4e00\u770b\u5c31\u77e5\u9053\u8fd9\u4e2a\u9898\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206(\u778e\u641e)\u8fc7\u53bb.\n\u6211\u5728\u673a\u623f\u5199\u4e8630\u5206\u949f,\u8c03\u4e86\u4e00\u4f1a,\u53d1\u73b0\u6211\u7406\u89e3\u9519\u4e86\u9898\u610f,\u64cd\u4f5c2\u662f\u6e05\u7a7a\u5230\u6839\u8282\u70b9\u7684\u8def\u5f84. \n(\u6ca1\u60f3\u5230\u6211\u628a\u64cd\u4f5c2\u7406\u89e3\u6210\u6e05\u7a7a\u5b50\u6811,\u64cd\u4f5c3\u7406\u89e3\u6210\u8be2\u95ee\u4ee5u\u4e3a\u6839\u7684\u5b50\u6811\u662f\u5426\u5168\u90fd\u662f\u6709\u6c34\u7684\u5f3a\u884c\u80fd\u8fc7\u6837\u4f8b)\n\u7136\u540e\u8fd8\u662f\u4e0d\u5bf9.\u540e\u6765\u6211\u770b\u5230\u4e86\u6211\u7ebf\u6bb5\u6811\u91cc\u7684push_down\u8fd9\u4e2a\u51fd\u6570,\u5927\u7b11\u4e0d\u6b62.\n\u6211\u4e0d\u77e5\u9053\u8fd9\u9898\u7684\u4ee3\u7801\u6709\u4ec0\u4e48\u597d\u89e3\u91ca\u7684,\u6a21\u677f\u91cc\u7684\u6bd4\u8fd9\u4e2a\u8fd8\u590d\u6742\u4e00\u4e9b.\n*/\n#include<bits/stdc++.h> //Ithea Myse Valgulious\nnamespace chtholly{\ntypedef long long ll;\n#define re0 register int\n#define rec register char\n#define rel register ll\n#define gc getchar\n#define pc putchar\n#define p32 pc(' ')\n#define pl puts(\"\")\n/*By Citrus*/\ninline int read(){\n  re0 x=0,f=1;rec c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=x*10+c-'0';\n  return x*(f?1:-1);\n  }\ninline void read(rel &x){\n  x=0;re0 f=1;rec c=gc();\n  for (;!isdigit(c);c=gc()) f^=c=='-';\n  for (;isdigit(c);c=gc()) x=x*10+c-'0';\n  x*=f?1:-1;\n  }\ntemplate <typename mitsuha>\ninline int write(mitsuha x){\n  if (!x) return pc(48);\n  if (x<0) x=-x,pc('-');\n  re0 bit[20],i,p=0;\n  for (;x;x/=10) bit[++p]=x%10;\n  for (i=p;i;--i) pc(bit[i]+48);\n  }\ninline char fuhao(){\n  rec c=gc();\n  for (;isspace(c);c=gc());\n  return c;\n  }\n}using namespace chtholly;\nusing namespace std;\nconst int yuzu=5e5;\ntypedef int fuko[yuzu|10];\nvector<int> lj[yuzu|10];\nint n,m;\n\nnamespace shu_lian_pou_fen{\nfuko sz,fa,dep,son,dfn,ord,top;int cnt;\n\nvoid dfs1(int u,int f){//\u6811\u5256\u4e13\u7528dfs\n  fa[u]=f,dep[u]=dep[f]+1,sz[u]=1;\n  for (int v:lj[u]) if (v^f){\n    dfs1(v,u),sz[u]+=sz[v];\n    if (sz[v]>sz[son[u]]) son[u]=v;\n    }\n  }\n\nvoid dfs2(int u,int _top){\n  top[u]=_top,dfn[u]=++cnt,ord[cnt]=u;\n  if (son[u]) dfs2(son[u],_top);\n  for (int v:lj[u]){\n    if (v^fa[u]&&v!=son[u]) dfs2(v,v);\n    }\n  }\n\ntypedef int yuki[yuzu<<2|13];\nstruct segtree{//\u7ebf\u6bb5\u6811\u5904\u7406\u533a\u95f4\u8986\u76d6.\n#define le rt<<1\n#define ri le|1\n#define ls le,l,mid\n#define rs ri,mid+1,r\nyuki val,lazy;\nvoid build(int rt=1,int l=1,int r=n){\n  lazy[rt]=-1;\n  if (l==r) val[rt]=0;\n  else{\n    int mid=l+r>>1;\n    build(ls),build(rs);\n    val[rt]=0;\n    }\n  }\nvoid push_down(int rt,int l,int r){\n  /*\u597d\u5427.\u8fd9\u91cc\u6ce8\u610f\u6807\u8bb0\u4e00\u5b9a\u8981\u5904\u7406\u6210-1.*/\n  if (~lazy[rt]){\n    lazy[le]=lazy[ri]=lazy[rt];\n    val[le]=val[ri]=lazy[rt];\n    lazy[rt]=-1;  \n    }\n  }\nvoid update(int ql,int qr,int v,int rt=1,int l=1,int r=n){\n  if (ql>r||qr<l) return;\n  if (ql<=l&&qr>=r) val[rt]=lazy[rt]=v;\n  else{  \n    int mid=l+r>>1;\n    push_down(rt,l,r);\n\tupdate(ql,qr,v,ls),update(ql,qr,v,rs);\n\t}\n  }\nint query(int u,int rt=1,int l=1,int r=n){\n  if (u<l||u>r) return 1;\n  if (l==r) return val[rt];\n  int mid=l+r>>1;\n  push_down(rt,l,r);\n  return query(u,ls)&query(u,rs);\n  }\n}my_;\n\nvoid update(int u,int v){\n  for (;top[u]!=top[v];u=fa[top[u]]){\n    if (dep[top[u]]<dep[top[v]]) swap(u,v);\n    my_.update(dfn[top[u]],dfn[u],0);//\u4e0d\u65ad\u5904\u7406u\u6240\u5728\u7684\u94fe\u5e76\u5411\u4e0a\u8df3.\n    }\n  if (dep[u]>dep[v]) swap(u,v);\n  my_.update(dfn[u],dfn[v],0);\n  }\n\nint main(){\n  re0 i;\n  n=read();\n  for (i=1;i<n;++i){\n    int u=read(),v=read();\n    lj[u].push_back(v);\n    lj[v].push_back(u);\n    }\n  dfs1(1,0),dfs2(1,1);\n  my_.build();\n  for (m=read();m--;){\n    int k=read(),u=read();\n    if (k==1){\n      my_.update(dfn[u],dfn[u]+sz[u]-1,1);\n\t  }\n\tif (k==2){\n\t  update(1,u);\n\t  }\n\tif (k==3){\n\t  write(my_.query(dfn[u])),pl;\n\t  }\n    }\n  }\n}\n\nint main(){\nshu_lian_pou_fen::main();\n}\n```\n\u8fd9\u4e2a\u9898\u6ca1\u6709\u6d1b\u8c37\u6a21\u677f\u96be,\u5c45\u7136\u653e\u5728div.1\u7684D,\u505a\u51fa\u67651000\u591a\u4eba\u4e5f\u662f\u6b63\u5e38\u7684.  \n\u5bf9\u6ca1\u9519,\u6211\u770b\u5230\u4e86\u6211\u5199\u7684push_down\u51fd\u6570,\u771f\u7684\u7b11\u51fa\u4e86\u58f0.\n```cpp\nvoid push_down(int rt,int l,int r){\n  if (~lazy[rt]){\n    lazy[l]=lazy[r]=lazy[rt];\n    val[l]=val[r]=lazy[rt];\n    lazy[rt]=-1;  \n    }\n  }\n```",
        "postTime": 1523630077,
        "uid": 49371,
        "name": "Fuko_Ibuki",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 CF343D \u3010Water Tree\u3011"
    }
]