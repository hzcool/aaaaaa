[
    {
        "content": "[\u5148\u5ba3\u4f20\u4e00\u4e0b\u535a\u5ba2(\u9003](https://waautomaton.tk/2018/08/14/loj-2732-%E9%A2%98%E8%A7%A3/)\n\n#### \u89e3\u6cd5\n&emsp;&emsp;\u8fd9\u9898\u6807\u7b97\u662f1\u4e2alog\u7684\u6811\u72b6\u6570\u7ec4\uff0c\u7136\u800c\u7531\u4e8e\u6570\u636e\u8303\u56f4\uff08\u4e5f\u8bb8\uff09\u6ca1\u5f00\u6ee1\uff0c\u672csb\u9009\u624b\u76f4\u63a5\u5199\u4e86\u83ab\u961f\u786c\u809b2e5\uff0c\u5dee\u70b9\u88ab\u5361\u5e38\u4e86\u3002\uff08atcoder\u4e0a\u6700\u6162\u7684\u70b9970ms\uff09  \n&emsp;&emsp;\u8003\u8651\u6211\u4eec\u662f\u5bf9\u4e00\u4e2a\u8bc4\u4ef7\u503c\u8be2\u95ee\uff0c\u628a\u8fd9\u4e2a\u503c\u4f5c\u4e3a\u4e00\u4e2a\u7ef4\u5ea6\uff0c\u7531\u4e8e\u6709\u4fee\u6539\u6240\u4ee5\u65f6\u95f4\u4e5f\u4f5c\u4e3a\u4e00\u4e2a\u7ef4\u5ea6\uff0c\u6211\u4eec\u5c31\u5f97\u5230\u4e86\u4e00\u4e2a\u4e8c\u7ef4\u7684\u83ab\u961f\u3002\u5176\u4e2d\u8bc4\u4ef7\u503c\u7ef4\u5ea6\u4e0a\u7684\u79fb\u52a8\u4f1a\u89e6\u53d1\u4e00\u6b21\u4fee\u6539\uff0c\u662f$O(1)$\u7684\uff0c\u65f6\u95f4\u4e0a\u7684\u79fb\u52a8\u5b8c\u6574\u7684\u79fb\u52a8\u4e00\u6b21\u4f1a\u89e6\u53d1$O(n)$\u6b21\u4fee\u6539\uff0c\u6240\u4ee5\u5747\u644a\u590d\u6742\u5ea6$O(1)$\u3002\u6240\u4ee5\u5206\u5757\u65f6\u5982\u679c\u8981\u6309\u65f6\u95f4\u8f74\u5206\u5757\uff0c\u5fc5\u987b\u6309\u8be5\u65f6\u95f4\u7684\u4fee\u6539\u6b21\u6570\u7684\u524d\u7f00\u548c\u5206\u5757\uff0c\u800c\u4e0d\u662f\u6309\u65f6\u95f4\u5206\u5757\u3002\n\n#### \u53c2\u8003\u4ee3\u7801\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\ntemplate <size_t _I_Buffer_Size = 1 << 23, size_t _O_Buffer_Size = 1 << 23>\nstruct IO_Tp\n{\n    //\u8fd9\u662f\u8bfb\u5165\u4f18\u5316\u677f\u5b50\uff0c\u4e3a\u4e86\u9605\u8bfb\u4f53\u9a8c\u6b64\u90e8\u5206\u5185\u5bb9\u7701\u7565\u3002\n};\n IO_Tp<1<<25,1<<25> IO;\nconst int maxn = 200000;\nstruct Change\n{\n    int p, before, after;\n} ch[maxn + 10];\nint a[maxn + 10];\nstruct Query\n{\n    int l, r, id;\n} q[maxn + 10];\nint qcnt, ccnt;\nint tong[3 * maxn + 10], tcnt;\nvector<int> pl[3 * maxn + 10];\nint n, m;\nint nans;\nint l = ccnt, r = tcnt;\nbool b[maxn + 10];\nvoid change(int p, int k)\n{\n    int cnt = 0;\n    if (b[p - 1])\n        ++cnt;\n    if (b[p + 1])\n        ++cnt;\n    if (k == 1) {\n        if (cnt == 0)\n            ++nans;\n        else if (cnt == 2)\n            --nans;\n\t\tmassert(!b[p]);\n        b[p] = true;\n    } else {\n        if (cnt == 0)\n            --nans;\n        else if (cnt == 2)\n            ++nans;\n\t\tmassert(b[p]);\n        b[p] = false;\n    }\n}\nvoid movl(int l, int k)\n{\n    if (ch[l].before <= r && ch[l].after > r)\n        change(ch[l].p, k);\n    else if (ch[l].before > r && ch[l].after <= r)\n        change(ch[l].p, k ^ 1);\n    if (k == 1) {\n        a[ch[l].p] = ch[l].after;\n    } else {\n        a[ch[l].p] = ch[l].before;\n    }\n}\nvoid movr(int r, int k)\n{\n    for (auto i : pl[r]) {\n        if (a[i] == r)\n            change(i, k);\n    }\n}\nint ans[maxn + 10];\nint sum[maxn+10];\nint main()\n{\n    iopen();\n    IO >> n >> m;\n    for (int i = 1; i <= n; ++i) {\n        IO >> a[i];\n        tong[++tcnt] = a[i];\n    }\n    for (int i = 1; i <= m; ++i) {\n        int op;\n        IO >> op;\n        if (op == 1) {\n            int b;\n            IO >> b;\n            --b;\n            tong[++tcnt] = b;\n            ++qcnt;\n            q[qcnt] = { ccnt, b, qcnt };\n        } else {\n            int p, after;\n            IO >> p >> after;\n            ch[++ccnt] = { p, a[p], after };\n            tong[++tcnt] = after;\n            a[p] = after;\n        }\n    }\n    sort(tong + 1, tong + 1 + tcnt);\n    tcnt = unique(tong + 1, tong + 1 + tcnt) - tong - 1;\n    for (int i = 1; i <= n; ++i) {\n        a[i] = lower_bound(tong + 1, tong + 1 + tcnt, a[i]) - tong;\n    }\n    for (int i = 1; i <= ccnt; ++i) {\n        ch[i].before = lower_bound(tong + 1, tong + 1 + tcnt, ch[i].before) - tong;\n        ch[i].after = lower_bound(tong + 1, tong + 1 + tcnt, ch[i].after) - tong;\n    }\n    for (int i = 1; i <= qcnt; ++i) {\n        q[i].r = lower_bound(tong + 1, tong + 1 + tcnt, q[i].r) - tong;\n    }\n    for (int i = 1; i <= n; ++i) {\n        pl[a[i]].push_back(i);\n    }\n    for (int i = 1; i <= ccnt; ++i) {\n        pl[ch[i].before].push_back(ch[i].p);\n    }\n\tfor(int i=1; i<=tcnt; ++i) {\n\t\tsort(pl[i].begin(),pl[i].end());\n\t\tint t=unique(pl[i].begin(),pl[i].end())-pl[i].begin();\n\t\twhile(pl[i].size()>t) pl[i].pop_back();\n\t\tsum[i]=sum[i-1]+t;\n\t}\n    int S = sqrt(sum[tcnt]);\n   sort(q + 1, q + 1 + qcnt, [S](const Query &a, const Query &b) {\n        if (sum[a.r] / S == sum[b.r] / S)\n            return (sum[a.r]/S %2 ==1)?a.l < b.l:a.l>b.l;\n        return sum[a.r] / S < sum[b.r] / S;\n    });\n    l = ccnt;\n    r = 0;\n    memset(b, true, sizeof(b));\n    b[0] = b[n + 1] = false;\n    nans = 1;\n    for (int i = 1; i <= qcnt; ++i) {\n        while (l < q[i].l)\n            movl(++l, 1);\n        while (l > q[i].l)\n            movl(l--, 0);\n        while (r < q[i].r)\n            movr(++r, 0);\n        while (r > q[i].r)\n            movr(r--, 1);\n        ans[q[i].id] = nans;\n    }\n    for (int i = 1; i <= qcnt; ++i) {\n        IO << ans[i] << '\\n';\n    }\n    return 0;\n}\n\n\n```\n",
        "postTime": 1542711080,
        "uid": 39219,
        "name": "WAAutoMaton",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT1828 \u3010\u96c7\u7528\u8a08\u753b\u3011"
    }
]