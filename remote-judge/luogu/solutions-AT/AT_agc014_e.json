[
    {
        "content": "**\u9898\u610f**  \n\u7ed9\u5b9a\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\uff0c\u4e00\u5f00\u59cb\u6240\u6709\u8fb9\u90fd\u662f\u84dd\u8272\u7684\u3002  \n\u6bcf\u6b21\u9009\u62e9\u4e00\u6761\u6240\u6709\u8fb9\u90fd\u662f\u84dd\u8272\u7684\u8def\u5f84\uff0c\u5220\u6389\u5176\u4e2d\u4e00\u6761\u8fb9\uff0c\u7136\u540e\u5728\u8def\u5f84\u7684\u4e24\u4e2a\u7aef\u70b9\u4e4b\u95f4\u8fde\u4e00\u6761\u7ea2\u8fb9\u3002\u6c42\u6700\u540e\u80fd\u4e0d\u80fd\u5f97\u5230\u76ee\u6807\u5f62\u6001\u7684\u7ea2\u6811\u3002  \n\n**\u9898\u89e3**  \n\n\n\n\u9898\u89e3\u533a\u51e0\u4e4e\u5168\u90e8\u90fd\u662f\u6811\u5256\u7684\u505a\u6cd5\uff0c\u552f\u4e00\u4e00\u7bc7[\u975e\u6811\u5256\u548c LCT \u7684\u9898\u89e3](https://www.luogu.com.cn/blog/user34444/solution-at2377)\u611f\u89c9\u8fc7\u4e8e\u7b80\u7565\u3002  \n\u63d0\u4f9b\u4e00\u4e2a\u4ee3\u7801\u7b80\u6d01\u505a\u6cd5\uff0c\u770b\u5230\u7684\u540c\u5b66\u9ebb\u70e6\u70b9\u4e2a\u8d5e\u9876\u4e0a\u53bb\u3002  \n\n~~\u50cf\u6211\u8fd9\u79cd\u61d2\u4eba\u8fde\u7ebf\u6bb5\u6811\u90fd\u61d2\u5f97\u5199\u4f1a\u53bb\u5199\u6811\u5256\uff1f~~  \n\n~~\u770b\u5230 Blue and Red Tree \u6211\u4eec\u5e94\u8be5\u60f3\u5230[\u5411\u5317\u65b9\u7684 Red and Blue Tree](https://www.luogu.com.cn/discuss/show/137272)\u3002~~  \n\n\u4e0d\u8fc7\u6211\u4eec\u786e\u5b9e\u53ef\u4ee5\u7528\u7ea2\u9ed1\u6811\uff08\u6307 `set` \u548c `map`\uff09 \u6765\u505a\u8fd9\u9053\u9898\u3002\uff08\u8349\uff09  \n\n\u8003\u8651\u5012\u63a8\uff0c\u6700\u540e\u4e00\u6761\u88ab\u66ff\u6362\u7684\u8fb9\uff0c\u4e00\u5b9a\u672c\u8eab\u5c31\u662f\u7ea2\u6811\u4e0a\u7684\u8fb9\uff0c\u7136\u540e\u8fd9\u4e2a\u65f6\u5019\u8fd9\u6761\u8fb9\u4e24\u8fb9\u7684\u8054\u901a\u5757\u4e00\u5b9a\u5df2\u7ecf\u5904\u7406\u597d\u4e86\u3002    \n\u518d\u8003\u8651\u8fd9\u4e24\u8fb9\u7684\u8054\u901a\u5757\u5728\u5f62\u6210\u53ef\u884c\u7684\u8054\u901a\u5757\u4e4b\u524d\uff0c\u4e00\u5b9a\u4e5f\u6709\u7c7b\u4f3c\u7684\u91cd\u8fb9\u8fdb\u884c\u4e86\u5904\u7406\u3002  \n\n\u7136\u540e\u6211\u4eec\u8003\u8651\uff0c\u4e0d\u505c\u8fdb\u884c\u8fd9\u6837\u7684\u5904\u7406\uff1a\u5982\u679c\u53d1\u73b0\u6709\u4e00\u6761\u8fb9\u65e2\u662f\u7ea2\u8fb9\u53c8\u662f\u84dd\u8fb9\uff0c\u6211\u4eec\u5c31\u5c06\u8fd9\u6761\u8fb9\u8fde\u63a5\u7684\u4e24\u4e2a\u70b9\u8fdb\u5408\u5e76\u6210\u4e00\u4e2a\u70b9\u3002\u5982\u679c\u6700\u540e\u80fd\u5408\u5e76\u6210 $1$ \u4e2a\u70b9\u8bf4\u660e\u53ef\u884c\u3002  \n\n\u53ef\u80fd\u6709\u70b9\u62bd\u8c61\uff0c\u8fd9\u91cc\u653e\u4e00\u4e0b\u6837\u4f8b $2$ \u7684\u524d\u4e09\u6b65\u8fc7\u7a0b\u3002  \n![](https://cdn.luogu.com.cn/upload/image_hosting/wnxol2s6.png)  \n![](https://cdn.luogu.com.cn/upload/image_hosting/8die6yug.png)  \n![](https://cdn.luogu.com.cn/upload/image_hosting/v76lpqwc.png)  \n\n\u5408\u5e76\u4e24\u4e2a\u70b9\u7684\u65f6\u5019\u6211\u4eec\u91c7\u7528\u542f\u53d1\u5f0f\u5408\u5e76\u6765\u4fdd\u8bc1\u590d\u6742\u5ea6\u3002\u5177\u4f53\u6765\u8bf4\u7ef4\u62a4\u6bcf\u4e2a\u70b9\u5bf9\u5e94\u51fa\u53bb\u7684\u8fb9\u96c6\u7684 `multiset`\uff0c\u7136\u540e\u9010\u4e2a\u52a0\u5165\u65b0\u8fb9\u5373\u53ef\u3002  \n\u7136\u540e\u6211\u4eec\u7528 `map` \u6765\u5224\u91cd\uff0c\u907f\u514d\u91cd\u590d\u5408\u5e76\u8fb9\u3002  \n\n\n\n\n**\u4ee3\u7801**  \n```cpp\nint n,l,r,cnt;\nmultiset<int> S[N];\nmap<pii,int> Map;\npii Q[N];\nvoid add(int x,int y){if (x>y) swap(x,y);if (x==y) return;if (++Map[mp(x,y)]==2) Q[++r]=mp(x,y);S[x].insert(y),S[y].insert(x);}\nsigned main()\n{\n    rd(n);for (int i=1,x,y;i<=2*n-2;i++) rd(x),rd(y),add(x,y);\n    while (cnt<n-1)\n    {\n        if (l>=r) {puts(\"NO\");return 0;}\n        l++;pii p=Q[l];if (!Map[p]) continue;\n        int u=p.fi,v=p.se;\n        if (S[u].size()<S[v].size()) swap(u,v);\n        for (int x:S[v]) {Map[mp(min(x,v),max(x,v))]=0;S[x].erase(S[x].find(v));add(x,u);}\n        S[v].clear();cnt++;\n    }\n    puts(\"YES\");\n}\n```\n\n",
        "postTime": 1630234781,
        "uid": 70132,
        "name": "AsunderSquall",
        "ccfLevel": 7,
        "title": "AGC014E"
    },
    {
        "content": "\u6211\u4eec\u89c2\u5bdf\u4fee\u6539\u6811\u7684\u64cd\u4f5c\uff1a\u9009\u62e9\u4e00\u6761\u8def\u5f84\uff0c\u5220\u6389\u5176\u4e2d\u4e00\u6761\u8fb9\uff0c\u518d\u8fde\u63a5\u4e24\u4e2a\u7aef\u70b9\u3002\u90a3\u4e48\u6211\u4eec\u6709\u4e00\u4e9b\u663e\u7136\u7684\u89c2\u5bdf\uff1a\n\n\u5982\u679c\u4e00\u6761\u8fb9\u5728\u4e24\u68f5\u6811\u4e2d\u90fd\u5b58\u5728\uff0c\u90a3\u4e48\u6211\u4eec\u80af\u5b9a\u4f1a\u5728\u6700\u540e\u9009\u62e9\u5b83\u7684\u4e24\u4e2a\u7aef\u70b9\uff0c\u4e14\u8fd9\u6837\u7684\u8fb9\u4e0d\u5f71\u54cd\u5224\u65ad\u3002\n\n\u6211\u4eec\u628a\u65b0\u6811\u4e0a\u7684\u8fb9\u5bf9\u5e94\u539f\u6811\u7684\u8def\u5f84\u627e\u51fa\u6765\uff0c\u6211\u4eec\u80fd\u591f\u9009\u62e9\u4e00\u6761\u8def\u5f84\uff0c\u5f53\u4e14\u4ec5\u5f53\u8fd9\u6761\u8def\u5f84\u4e0a\u5b58\u5728\u4e00\u6761\u53ef\u4ee5\u5220\u7684\u8fb9\uff0c\u53ea\u88ab\u8fd9\u4e2a\u8def\u5f84\u8986\u76d6\uff0c\u6b64\u65f6\u6211\u4eec\u9009\u62e9\u8fd9\u4e2a\u8def\u5f84\uff0c\u5220\u9664\u8fd9\u6761\u8fb9\u3002\n\n\u6211\u4eec\u9700\u8981\u7ef4\u62a4\u4ec0\u4e48\uff1f\u6bcf\u6761\u8fb9\u7684\u8986\u76d6\u6b21\u6570\uff1a\u6811\u5256\u89e3\u51b3\u3002\u90a3\u4e48\u5982\u4f55\u67e5\u8986\u76d6\u8fd9\u6761\u8fb9\u7684\u8def\u5f84\u7684\u7f16\u53f7\u5462\uff1f\u6211\u4eec\u5f53\u7136\u53ef\u4ee5\u66b4\u529b\u5730\u7528\u6570\u636e\u7ed3\u6784\u505a\uff0c\u4f46\u662f\u66f4\u597d\u7684\u662f\u2014\u2014**\u5728\u94fe\u4e0a\u6253\u5f02\u6216\u6807\u8bb0\uff01\u5f53\u4e00\u6761\u8fb9\u53ea\u88ab\u8986\u76d6\u4e00\u6b21\uff0c\u5b83\u7684\u5f02\u6216\u6807\u8bb0\u5c31\u662f\u5b83\u7684\u7f16\u53f7\uff01**\n\n\u597d\u50cf\u5b9e\u9645\u505a\u6cd5\u5f88\u7b80\u5355...\uff1a\u8003\u8651\u5728\u4e24\u68f5\u6811\u4e2d\u90fd\u5b58\u5728\u7684\u8fb9\uff0c\u5b83\u4eec\u4e0d\u5f71\u54cd\u7b54\u6848\uff0c\u6211\u4eec\u628a\u5b83\u4eec\u7f29\u70b9\u3002\u7136\u540e\u9012\u5f52\u5230\u5b50\u95ee\u9898\uff0c\u7ee7\u7eed\u8fdb\u884c\uff0c\u4e2d\u95f4\u7528\u5e76\u67e5\u96c6/\u542f\u53d1\u5f0f\u5408\u5e76\u7ef4\u62a4\u3002\n\n```cpp\n#define N 100005\n#define M N*4\n#define ls (x<<1)\n#define rs (x<<1|1)\nconst int rt=1,inf=1e9;\npii mn[M];\nint laz[M],xt[M];\nil void up(int x)\n{\n    mn[x]=min(mn[ls],mn[rs]);\n}\nil void give(int x,int v1,int v2)\n{\n    mn[x].fi+=v1,laz[x]+=v1,xt[x]^=v2;\n}\nil void down(int x)\n{\n    if(laz[x]||xt[x])\n    {\n        give(ls,laz[x],xt[x]),give(rs,laz[x],xt[x]);\n        laz[x]=xt[x]=0;\n    }\n}\nbool zer[N];\nvoid build(int x,int l,int r)\n{\n    if(l==r)\n    {\n        if(zer[l]) mn[x]=mp(0,l);\n        else mn[x]=mp(inf,l);\n        return;\n    }\n    gm; build(ls,l,mid),build(rs,mid+1,r);\n    up(x);\n}\nvoid upd(int x,int l,int r,int ql,int qr,int v1,int v2)\n{\n    if(ql<=l&&r<=qr) return give(x,v1,v2);\n    gm; down(x);\n    if(ql<=mid) upd(ls,l,mid,ql,qr,v1,v2);\n    if(qr>mid) upd(rs,mid+1,r,ql,qr,v1,v2);\n    up(x);\n}\nint ask(int x,int l,int r,int p)\n{\n    if(l==r) return xt[x];\n    gm; down(x);\n    if(p<=mid) return ask(ls,l,mid,p);\n    else return ask(rs,mid+1,r,p);\n}\nvoid upd2(int x,int l,int r,int p)\n{\n    if(l==r) {mn[x]=mp(inf,l); return;}\n    gm; down(x);\n    if(p<=mid) upd2(ls,l,mid,p);\n    else upd2(rs,mid+1,r,p);\n    up(x);\n}\nint n;\nvector<int> E[N];\nint dfn[N],dk,sz[N],hsn[N],fa[N],top[N],dep[N];\nvoid dfs(int x,int _fa)\n{\n    sz[x]=1,fa[x]=_fa,dep[x]=dep[_fa]+1;\n    for(solid v:E[x])\n    {\n        if(v==_fa) continue;\n        dfs(v,x); sz[x]+=sz[v];\n        if(sz[v]>sz[hsn[x]]) hsn[x]=v;\n    }\n}\nvoid efs(int x,int _tp)\n{\n    dfn[x]=++dk,top[x]=_tp;\n    if(hsn[x]) efs(hsn[x],_tp);\n    else return;\n    for(solid v:E[x])\n    {\n        if(v==fa[x]||v==hsn[x]) continue;\n        efs(v,v);\n    }\n}\nil void lineupd(int x,int y,int v1,int v2)\n{\n    while(top[x]!=top[y])\n    {\n        if(dep[top[x]]<dep[top[y]]) swap(x,y);\n        upd(rt,1,n,dfn[top[x]],dfn[x],v1,v2);\n        x=fa[top[x]];\n    }\n    if(x==y) return;\n    if(dfn[x]>dfn[y]) swap(x,y);\n    upd(rt,1,n,dfn[x]+1,dfn[y],v1,v2);\n}\nset< pii > hve,nwe;\nint ea[N],eb[N],cnt;\nsigned main()\n{\n#ifdef M207\n    freopen(\"in.in\",\"r\",stdin);\n    // freopen(\"ot.out\",\"w\",stdout);\n#endif\n    in(n);\n    for(ri i=1,a,b; i<n; ++i)\n    {\n        in(a,b);\n        E[a].pb(b),E[b].pb(a);\n        if(a>b) swap(a,b);\n        hve.insert(mp(a,b));\n    }\n    for(ri i=1; i<n; ++i)\n    {\n        ++cnt,in(ea[cnt],eb[cnt]);\n        if(ea[cnt]>eb[cnt]) swap(ea[cnt],eb[cnt]);\n        if(hve.count(mp(ea[cnt],eb[cnt]))) hve.erase(mp(ea[cnt],eb[cnt])),--cnt;\n    }\n    dfs(1,0);\n    efs(1,1);\n    for(ri i=2; i<=n; ++i)\n    {\n        int a=i,b=fa[i];\n        if(a>b) swap(a,b);\n        if(hve.count(mp(a,b))) zer[dfn[i]]=1;\n    }\n    build(rt,1,n);\n    for(ri i=1; i<=cnt; ++i) lineupd(ea[i],eb[i],1,i);\n    int del=0;\n    while(1)\n    {\n        pii tmp=mn[rt];\n        if(tmp.fi>1) break;\n        if(tmp.fi==0)\n        {\n            upd2(rt,1,n,tmp.se);\n            continue;\n        }\n        int t=ask(rt,1,n,tmp.se);\n        ++del;\n        lineupd(ea[t],eb[t],-1,t);\n    }\n    puts(del==cnt?\"YES\":\"NO\");\n    return 0;\n}\n```\n",
        "postTime": 1559690715,
        "uid": 58302,
        "name": "i207M",
        "ccfLevel": 0,
        "title": "\u5f02\u6216\u6807\u8bb0\u7684\u5e94\u7528-AT2377 Blue and Red Tree-\u89e3\u9898\u62a5\u544a"
    },
    {
        "content": "[$$\\large \\color{purple}My\\;Blog$$](https://www.cnblogs.com/p-b-p-b/p/10355976.html)\n\n-----------\n\n## \u601d\u8def\n\n\u5b98\u65b9\u9898\u89e3\u662f\u5012\u63a8\uff0c\u8fd9\u91cc\u63d0\u4f9b\u4e00\u79cd\u6b63\u63a8\u7684\u505a\u6cd5\u3002\n\n\u4e0d\u77e5\u9053\u4f60\u4eec\u662f\u600e\u4e48\u60f3\u5230\u5012\u63a8\u7684\u2026\u2026\u611f\u89c9\u6b63\u63a8\u66f4\u597d\u60f3\u554aQwQ~~\u5c31\u662f\u4e0d\u597d\u7801~~\n\n\u628a\u6bcf\u4e00\u6761\u7ea2\u8fb9\uff0c\u5c06\u5176\u8f6c\u5316\u4e3a\u84dd\u6811\u4e0a\u7684\u4e00\u6761\u8def\u5f84\u3002\u4e3a\u4e86\u8fde\u8fd9\u6761\u7ea2\u8fb9\uff0c\u9700\u8981\u4fdd\u8bc1\u8fd9\u6761\u8def\u5f84\u4ecd\u7136\u5b8c\u6574\u3002\n\n\u8003\u8651\u8fde\u5b8c\u4e4b\u540e\u8981\u5220\u6389\u7684\u90a3\u6761\u84dd\u8fb9\uff0c\u663e\u7136\u5b83\u53ea\u80fd\u88ab\u5f53\u524d\u8fde\u7684\u7ea2\u8def\u5f84\u8986\u76d6\u800c\u6ca1\u6709\u88ab\u5176\u4ed6\u8def\u5f84\u8986\u76d6\uff0c\u5426\u5219\u5c31\u73a9\u4e0d\u4e0b\u53bb\u4e86\u3002\n\n\u5373\uff1a\u6bcf\u6b21\u53ea\u80fd\u5220\u6389\u4e00\u6761\u88ab\u8986\u76d6\u4e00\u6b21\u7684\u84dd\u8fb9\u3002\n\n\u6709\u6ca1\u6709\u53ef\u80fd\u4e00\u6761\u84dd\u8fb9\u6ca1\u6709\u88ab\u8986\u76d6\u8fc7\u5462\uff1f\u663e\u7136\u662f\u4e0d\u53ef\u80fd\u7684\uff0c\u56e0\u4e3a\u6bcf\u6761\u84dd\u8fb9\u6700\u7ec8\u90fd\u8981\u5220\u53bb\uff0c\u82e5\u6ca1\u6709\u8986\u76d6\u8fc7\u5219\u65e0\u6cd5\u5220\u53bb\u3002\n\n\u90a3\u4e48\u505a\u6cd5\u5c31\u5f88\u663e\u7136\u4e86\uff1a\u6811\u5256\uff0c\u7ebf\u6bb5\u6811\u7ef4\u62a4\u6700\u5c0f\u503c\u548c\u8986\u76d6\u4e86\u8fd9\u4e2a\u533a\u95f4\u7684\u7ea2\u8fb9\u7f16\u53f7\u3002\u6bcf\u6b21\u627e\u4e00\u4e2a\u53ea\u88ab\u8986\u76d6\u4e86\u4e00\u6b21\u7684\u84dd\u8fb9\uff0c\u5220\u6389\u5b83\uff08\u5c06\u5b83\u7684\u503c\u8d4b\u4e3a$\\infty$\uff09\uff0c\u4e5f\u53bb\u9664\u90a3\u6761\u7ea2\u8fb9\u7684\u5f71\u54cd\u3002\u5982\u679c\u80fd\u505a\u5230\u6700\u540e\u5c31\u662f\u5408\u6cd5\uff0c\u5426\u5219\u4e0d\u5408\u6cd5\u3002\n\n\u7136\u800c\u6211\u592a\u4e45\u6ca1\u5199\u6811\u5256\uff0c\u800c\u4e14$n$\u548c$n-1$\u603b\u5206\u4e0d\u6e05\uff0c\u7ed3\u679c\u8d21\u732e\u4e86\u4e00\u9875\u7684\u8bc4\u6d4b\u8bb0\u5f55\u2026\u2026\n\n\u800c\u4e14\u5728~~\u6bd2\u7624\u7684~~\u6d1b\u8c37\u4e0a\u9009c++11\u4ea4\u5230AtCoder\u4e0a\u5c31\u53d8\u6210\u4e86c++14\u2026\u2026\u5bf9AtCoder\u4e0d\u719f\uff0c\u5404\u79cd\u5947\u602a\u7684\u9519\u8bef\u90fd\u6765\u4e86\u3002\n\n\u4ee3\u7801\u5de8\u4e11\uff0c\u51d1\u5408\u7740\u770b\u5427QwQ\n\n---------\n\n## \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nnamespace my_std{\n    using namespace std;\n    #define pii pair<int,int>\n    #define fir first\n    #define sec second\n    #define MP make_pair\n    #define rep(i,x,y) for (int i=(x);i<=(y);i++)\n    #define drep(i,x,y) for (int i=(x);i>=(y);i--)\n    #define go(x) for (int i=head[x];i;i=edge[i].nxt)\n    #define sz 101010 \n    typedef long long ll;\n    template<typename T>\n    inline void read(T& t)\n    {\n        t=0;char f=0,ch=getchar();\n        double d=0.1;\n        while(ch>'9'||ch<'0') f|=(ch=='-'),ch=getchar();\n        while(ch<='9'&&ch>='0') t=t*10+ch-48,ch=getchar();\n        if(ch=='.')\n        {\n            ch=getchar();\n            while(ch<='9'&&ch>='0') t+=d*(ch^48),d*=0.1,ch=getchar();\n        }\n        t=(f?-t:t);\n    }\n    template<typename T,typename... Args>\n    inline void read(T& t,Args&... args){read(t); read(args...);}\n//\tvoid file()\n//\t{\n//\t\t#ifndef ONLINE_JUDGE\n//\t\tfreopen(\"a.txt\",\"r\",stdin);\n//\t\t#endif\n//\t}\n//\tinline ll mul(ll a,ll b){ll d=(ll)(a*(double)b/mod+0.5);ll ret=a*b-d*mod;if (ret<0) ret+=mod;return ret;}\n}\nusing namespace my_std;\n//\tclock_t t=clock();\n\nint n;\nstruct hh{int t,nxt;}edge[sz<<1];\nint head[sz],ecnt;\nvoid make_edge(int f,int t)\n{\n    edge[++ecnt]=(hh){t,head[f]};\n    head[f]=ecnt;\n    edge[++ecnt]=(hh){f,head[t]};\n    head[t]=ecnt;\n}\nint size[sz],son[sz],top[sz],fa[sz],dep[sz],dfn[sz],cnt=-1;\n#define v edge[i].t\nvoid dfs1(int x,int fa)\n{\n    dep[x]=dep[::fa[x]=fa]+1;size[x]=1;\n    go(x) if (v!=fa)\n    {\n        dfs1(v,x);\n        size[x]+=size[v];\n        if (size[v]>size[son[x]]) son[x]=v;\n    }\n}\nvoid dfs2(int x,int fa,int tp)\n{\n    top[x]=tp;dfn[x]=++cnt;\n    if (son[x]) dfs2(son[x],x,tp);\n    go(x) if (v!=fa&&v!=son[x]) dfs2(v,x,v);\n}\n#undef v\n\nbool del[sz];\nint F[sz],T[sz];\nint mn[sz<<2],tag[sz<<2];\nvector<int>tr[sz<<2];\n#define ls k<<1\n#define rs k<<1|1\n#define lson ls,l,mid\n#define rson rs,mid+1,r\nvoid Add(int k,int t){tag[k]+=t;mn[k]+=t;}\nvoid pushdown(int k){int &t=tag[k]; if (!t) return; Add(ls,t); Add(rs,t); t=0; return;}\nvoid pushup(int k){mn[k]=min(mn[ls],mn[rs]);}\nvoid add(int k,int l,int r,int x,int y,int t)\n{\n    if (x<=l&&r<=y) return tr[k].push_back(t),Add(k,1);\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if (x<=mid) add(lson,x,y,t);\n    if (y>mid) add(rson,x,y,t);\n    pushup(k);\n}\nvoid change(int k,int l,int r,int x,int y,int s)\n{\n    if (x<=l&&r<=y) return Add(k,s);\n    pushdown(k);\n    int mid=(l+r)>>1;\n    if (x<=mid) change(lson,x,y,s);\n    if (y>mid) change(rson,x,y,s);\n    pushup(k);\n}\nint K;\nint getmn(int k,int l,int r)\n{\n    if (mn[k]>1) return -1; // -1 : don't have 1\n    int ret;\n    while (!tr[k].empty()&&del[tr[k].back()]) tr[k].pop_back();\n    ret=tr[k].empty()?0:tr[k].back(); // 0 : don't know which edge\n    if (l==r) return K=l,ret;\n    pushdown(k);\n    int mid=(l+r)>>1,cur;\n    cur=getmn(lson); if (cur!=-1) { if (cur) return cur; if (ret) return ret; }\n    cur=getmn(rson); if (cur!=-1) { if (cur) return cur; if (ret) return ret; }\n    return ret;\n}\n\nvoid add(int x,int y,int t)\n{\n    while (top[x]!=top[y])\n    {\n        if (dep[top[x]]<dep[top[y]]) swap(x,y);\n        add(1,1,n-1,dfn[top[x]],dfn[x],t);\n        x=fa[top[x]];\n    }\n    if (dfn[x]>dfn[y]) swap(x,y);\n    if (x!=y) add(1,1,n-1,dfn[x]+1,dfn[y],t);\n}\nvoid erase(int x,int y)\n{\n    while (top[x]!=top[y])\n    {\n        if (dep[top[x]]<dep[top[y]]) swap(x,y);\n        change(1,1,n-1,dfn[top[x]],dfn[x],-1);\n        x=fa[top[x]];\n    }\n    if (dfn[x]>dfn[y]) swap(x,y);\n    if (x!=y) change(1,1,n-1,dfn[x]+1,dfn[y],-1);\n}\nvoid del_mn()\n{\n    if (mn[1]!=1) puts(\"NO\"),exit(0);\n    int e=getmn(1,1,n-1);\n    del[e]=1;\n    change(1,1,n-1,K,K,sz);\n    erase(F[e],T[e]);\n}\n\n\nint main()\n{\n//\tfile();\n    int x,y;\n    scanf(\"%d\",&n);\n    rep(i,1,n-1) scanf(\"%d %d\",&x,&y),make_edge(x,y);\n    dfs1(1,0);dfs2(1,0,1);\n    rep(i,1,n-1) scanf(\"%d %d\",&x,&y),add(x,y,i),F[i]=x,T[i]=y;\n    rep(i,1,n-1) del_mn();\n    puts(\"YES\");\n//\tcout<<1.0*(clock()-t)/CLOCKS_PER_SEC;\n    return 0;\n}\n```",
        "postTime": 1549595806,
        "uid": 76481,
        "name": "p_b_p_b",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT2377 \u3010Blue and Red Tree\u3011"
    },
    {
        "content": "### \u9898\u610f\n\n\u6709\u4e00\u68f5 $n$ \u4e2a\u8282\u70b9\u7684\u6811\u548c $n-1$ \u6761\u8def\u5f84\uff0c\u4e00\u5f00\u59cb\u6811\u4e0a\u7684\u8fb9\u5168\u662f\u84dd\u8fb9\u3002\u6bcf\u4e00\u6b21\u53ef\u4ee5\u9009\u62e9\u4e00\u6761\u5168\u662f\u84dd\u8fb9\u7684\u8def\u5f84\uff0c\u5c06\u5176\u4e2d\u7684\u4e00\u6761\u66ff\u6362\u4e3a\u7ea2\u8fb9\u3002\u95ee\u6709\u6ca1\u6709\u65b9\u6cd5\u53ef\u4ee5\u5c06\u6811\u53d8\u6210\u5168\u662f\u7ea2\u8fb9\u7684\u6570\u3002\n\n$\\texttt{Data Range:}2\\leq n\\leq 10^5$\n\n### \u9898\u89e3\n\n\u8fd9\u9898\u6bd4\u8f83\u7b80\u5355\uff0c\u4f46\u662f\u4ee3\u7801\u5199\u8d77\u6765\u6bd4\u8f83\u6076\u5fc3\uff0c\u611f\u89c9\u522b\u7684\u9898\u89e3\u7684\u4ee3\u7801\u5199\u7684\u6bd4\u8f83\u5947\u8469\u3002\n\n\u5c06\u6240\u6709\u8def\u5f84\u770b\u6210\u5bf9\u8fb9\u7684\u8986\u76d6\uff0c\u90a3\u4e48\u6bcf\u4e00\u6b21\u80af\u5b9a\u662f\u9009\u53d6\u53ea\u88ab\u4e00\u6761\u8def\u5f84\u8986\u76d6\u7684\u8fb9\u53bb\u64cd\u4f5c\uff0c\u8fd9\u6837\u624d\u4e0d\u4f1a\u5bf9\u522b\u7684\u8def\u5f84\u9020\u6210\u5f71\u54cd\u3002\n\n\u6240\u4ee5\u53ef\u4ee5\u5148\u8def\u5f84\u8986\u76d6\uff0c\u6bcf\u6b21\u67e5\u8be2\u6240\u6709\u8fb9\u4e2d\u6709\u6ca1\u6709\u88ab\u8986\u76d6\u6b21\u6570\u4e3a $1$ \u7684\uff0c\u5982\u679c\u6ca1\u6709\u5c31\u4e0d\u884c\uff0c\u6709\u7684\u8bdd\u5c31\u66b4\u529b\u5bf9\u8fd9\u6761\u8fb9\u8fdb\u884c\u64cd\u4f5c\u3002\n\n\u8fd9\u4e9b\u64cd\u4f5c\u90fd\u53ef\u4ee5\u7528\u6811\u5256\u7ef4\u62a4\uff0c\u5177\u4f53\u7684\u8bdd\u5c31\u662f\u5c06\u7528 $u$ \u7684\u6743\u503c\u4ee3\u8868\u8fb9 $(u,fa_u)$ \u7684\u8986\u76d6\u6b21\u6570\uff0c\u7136\u540e\u7ef4\u62a4\u4e00\u4e0b\u6240\u6709\u8fb9\u88ab\u8986\u76d6\u6b21\u6570\u7684\u6700\u5c0f\u503c\u4ee5\u53ca\u6700\u5c0f\u503c\u51fa\u73b0\u7684\u4f4d\u7f6e\u3002\u540c\u65f6\u8fd8\u53ef\u4ee5\u7ef4\u62a4\u8986\u76d6\u4e86\u8fd9\u6761\u8fb9\u7684\u6240\u6709\u8def\u5f84\u7f16\u53f7\u7684\u5f02\u6216\u548c\uff0c\u8fd9\u6837\u5f53\u8fd9\u6761\u8fb9\u53ea\u88ab\u4e00\u6761\u8def\u5f84\u8986\u76d6\u7684\u65f6\u5019\u53ef\u4ee5\u65b9\u4fbf\u7684\u67e5\u8be2\u88ab\u54ea\u6761\u8def\u5f84\u8986\u76d6\u5230\u4e86\uff0c\u4e8e\u662f\u8fd9\u9898\u5c31\u5b8c\u4e86\u3002\n\n### \u4ee3\u7801\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef int ll;\ntypedef long long int li;\nconst ll MAXN=2e5+51,inf=0x3f3f3f3f;\nstruct Edge{\n\tll to,prev;\n};\nstruct SegmentTree{\n\tll l,r,xv,mn,p,tag,tag2;\n};\nEdge ed[MAXN<<1];\nSegmentTree tree[MAXN<<2];\nll n,from,to,tot,totd,c;\nll last[MAXN],fa[MAXN],depth[MAXN],sz[MAXN],hv[MAXN],dfn[MAXN];\nll rdfn[MAXN],top[MAXN],u[MAXN],v[MAXN];\ninline ll read()\n{\n    register ll num=0,neg=1;\n    register char ch=getchar();\n    while(!isdigit(ch)&&ch!='-')\n    {\n        ch=getchar();\n    }\n    if(ch=='-')\n    {\n        neg=-1;\n        ch=getchar();\n    }\n    while(isdigit(ch))\n    {\n        num=(num<<3)+(num<<1)+(ch-'0');\n        ch=getchar();\n    }\n    return num*neg;\n}\ninline void addEdge(ll from,ll to)\n{\n\ted[++tot].prev=last[from];\n\ted[tot].to=to;\n\tlast[from]=tot;\n}\ninline void dfs(ll node,ll f)\n{\n\tll mx=-1;\n\tdepth[node]=depth[fa[node]=f]+1,sz[node]=1;\n\tfor(register int i=last[node];i;i=ed[i].prev)\n\t{\n\t\tif(ed[i].to!=f)\n\t\t{\n\t\t\tdfs(ed[i].to,node),sz[node]+=sz[ed[i].to];\n\t\t\tsz[ed[i].to]>mx?mx=sz[hv[node]=ed[i].to]:1;\n\t\t}\n\t}\n}\ninline void dfs2(ll node,ll link)\n{\n\tll to;\n\trdfn[dfn[node]=++totd]=node,top[node]=link;\n\tif(!hv[node])\n\t{\n\t\treturn;\n\t}\n\tdfs2(hv[node],link);\n\tfor(register int i=last[node];i;i=ed[i].prev)\n\t{\n\t\t(to=ed[i].to)!=fa[node]&&to!=hv[node]?dfs2(to,to):(void)1;\n\t}\n}\n#define ls node<<1\n#define rs (node<<1)|1\ninline void update(ll node)\n{\n\ttree[node].mn=min(tree[ls].mn,tree[rs].mn);\n\ttree[node].p=tree[ls].mn<tree[rs].mn?tree[ls].p:tree[rs].p;\n\ttree[node].xv=tree[ls].mn<tree[rs].mn?tree[ls].xv:tree[rs].xv;\n}\ninline void create(ll l,ll r,ll node)\n{\n\ttree[node]=(SegmentTree){l,r,0,0,0,0,0};\n\tif(l==r)\n\t{\n\t\treturn (void)(tree[node].p=l);\n\t}\n\tll mid=(l+r)>>1;\n\tcreate(l,mid,ls),create(mid+1,r,rs),update(node);\n}\ninline void spread(ll node)\n{\n\tif(tree[node].tag)\n\t{\n\t\tll tag=tree[node].tag;\n\t\ttree[ls].mn+=tag,tree[rs].mn+=tag,tree[ls].tag+=tag,tree[rs].tag+=tag;\n\t\ttree[node].tag=0;\n\t}\n\tif(tree[node].tag2)\n\t{\n\t\tll tag=tree[node].tag2;\n\t\ttree[ls].xv^=tag,tree[rs].xv^=tag;\n\t\ttree[ls].tag2^=tag,tree[rs].tag2^=tag,tree[node].tag2=0;\n\t}\n}\ninline void add(ll l,ll r,ll val,ll c,ll node)\n{\n\tif(l<=tree[node].l&&r>=tree[node].r)\n\t{\n\t\ttree[node].xv^=c,tree[node].tag2^=c;\n\t\treturn (void)(tree[node].mn+=val,tree[node].tag+=val);\n\t}\n\tll mid=(tree[node].l+tree[node].r)>>1;\n\tspread(node);\n\tl<=mid?add(l,r,val,c,ls):(void)1,r>mid?add(l,r,val,c,rs):(void)1;\n\tupdate(node);\n}\ninline void add(ll x,ll y,ll val,ll c)\n{\n\twhile(top[x]!=top[y])\n\t{\n\t\tdepth[top[x]]<depth[top[y]]?swap(x,y):(void)1;\n\t\tadd(dfn[top[x]],dfn[x],val,c,1),x=fa[top[x]];\n\t}\n\tdepth[x]>depth[y]?swap(x,y):(void)1;\n\tx!=y?add(dfn[x]+1,dfn[y],val,c,1):(void)1;\n}\nint main()\n{\n\tn=read();\n\tfor(register int i=0;i<n-1;i++)\n\t{\n\t\tfrom=read(),to=read(),addEdge(from,to),addEdge(to,from);\n\t}\n\tdfs(1,0),dfs2(1,1),create(1,n,1),add(1,1,inf,0,1);\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tu[i]=read(),v[i]=read(),add(u[i],v[i],1,i);\n\t}\n\tfor(register int i=1;i<n;i++)\n\t{\n\t\tif(tree[1].mn!=1)\n\t\t{\n\t\t\treturn puts(\"NO\"),0;\n\t\t}\n\t\tc=tree[1].xv,add(tree[1].p,tree[1].p,inf,0,1),add(u[c],v[c],-1,c);\n\t}\n\tputs(\"YES\");\n}\n```",
        "postTime": 1605616791,
        "uid": 60990,
        "name": "Karry5307",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 AT2377 \u3010[AGC014E] Blue and Red Tree\u3011"
    },
    {
        "content": "\u5728\u535a\u5ba2\u56ed\u98df\u7528\u66f4\u4f73\uff1a[https://www.cnblogs.com/PinkRabbit/p/AGC014.html](https://www.cnblogs.com/PinkRabbit/p/AGC014.html)\u3002\n\n\u64cd\u4f5c\u5373\u662f\u5220\u53bb\u4e00\u6761\u84dd\u8fb9\uff0c\u7136\u540e\u52a0\u4e0a\u4e00\u6761\u7ea2\u8fb9\u4ee5\u8fde\u901a\u5220\u53bb\u540e\u7559\u4e0b\u7684\u4e24\u4e2a\u8fde\u901a\u5757\u3002\n\n\u6b64\u65f6\u52a0\u4e0a\u7684\u7ea2\u8fb9\u5fc5\u987b\u8981\u6ee1\u8db3\u5176\u4e24\u7aef\u70b9\u90fd\u5904\u5728\u5220\u84dd\u8fb9\u524d\uff0c\u90a3\u6761\u84dd\u8fb9\u6240\u5728\u7684\u901a\u8fc7\u84dd\u8fb9\u80fd\u5230\u8fbe\u7684\u8fde\u901a\u5b50\u56fe\u4e2d\u3002\n\n\u8003\u8651\u5220\u53bb\u7684\u7b2c\u4e00\u6761\u84dd\u8fb9\uff0c\u4ece\u84dd\u6811\u4e0a\u8003\u8651\uff0c\u663e\u7136\u90a3\u6761\u88ab\u52a0\u5165\u7684\u7ea2\u8fb9\u4e24\u7aef\u70b9\u5728\u84dd\u6811\u4e0a\u7ecf\u8fc7\u7684\u8def\u5f84\u8986\u76d6\u4e86\u8fd9\u6761\u84dd\u8fb9\u3002\n\n\u800c\u4e14\u6b64\u540e\u5c31\u4e0d\u80fd\u518d\u6709\u7ea2\u8fb9\u5bf9\u5e94\u7684\u8def\u5f84\u8986\u76d6\u8fd9\u6761\u84dd\u8fb9\u4e86\uff0c\u5426\u5219\u5c06\u8fdd\u53cd\u4e0a\u8ff0\u9650\u5236\u3002\n\n\u90a3\u4e48\u505a\u6cd5\u5c31\u547c\u4e4b\u6b32\u51fa\u4e86\uff1a\u53ea\u9700\u627e\u5230\u88ab\u8986\u76d6\u6b21\u6570\u6070\u597d\u4e3a $1$ \u7684\u84dd\u8fb9\uff0c\u4ee5\u53ca\u8986\u76d6\u5b83\u7684\u8def\u5f84\uff0c\u628a\u8def\u5f84\u7ecf\u8fc7\u7684\u84dd\u8fb9\u7684\u88ab\u8986\u76d6\u6b21\u6570\u51cf\u53bb $1$\u3002\n\n\u4e0d\u65ad\u91cd\u590d\u4e0a\u8ff0\u8fc7\u7a0b\u76f4\u5230\u6bcf\u6761\u84dd\u8fb9\u90fd\u88ab\u5220\u53bb\u5373\u53ef\uff0c\u5982\u679c\u8fc7\u7a0b\u4e2d\u627e\u4e0d\u5230\u5408\u6cd5\u7684\u84dd\u8fb9\u5219\u65e0\u6cd5\u6210\u529f\u53d8\u6362\u6210\u7ea2\u6811\u3002\n\n\u5177\u4f53\u5b9e\u73b0\u65f6\u4f7f\u7528\u6811\u94fe\u5256\u5206 + \u7ebf\u6bb5\u6811\u5bf9\u6bcf\u6761\u84dd\u8fb9\u7ef4\u62a4\u5b83\u7684\u88ab\u8986\u76d6\u6b21\u6570\uff0c\u4ee5\u53ca\u5c06\u5176\u8986\u76d6\u7684\u6240\u6709\u8def\u5f84\u7684\u7f16\u53f7\u7684\u5f02\u6216\u548c\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $\\mathcal O (N \\log^2 N)$\u3002\n\n```cpp\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nconst int Inf = 0x3f3f3f3f;\nconst int MN = 100005, MS = 1 << 18 | 7;\n\nint N, ex[MN], ey[MN];\nstd::vector<int> G[MN];\n\nint par[MN], dep[MN], siz[MN], pref[MN], top[MN], dfn[MN], dfc;\nvoid DFS0(int u, int p) {\n\tdep[u] = dep[par[u] = p] + 1, siz[u] = 1;\n\tfor (int v : G[u]) if (v != p) {\n\t\tDFS0(v, u);\n\t\tsiz[u] += siz[v];\n\t\tif (siz[pref[u]] < siz[v]) pref[u] = v;\n\t}\n}\nvoid DFS1(int u, int t) {\n\tdfn[u] = ++dfc, top[u] = t;\n\tif (pref[u]) DFS1(pref[u], t);\n\tfor (int v : G[u]) if (v != par[u] && v != pref[u]) DFS1(v, v);\n}\n\n#define li (i << 1)\n#define ri (li | 1)\n#define mid ((l + r) >> 1)\n#define ls li, l, mid\n#define rs ri, mid + 1, r\nstruct dat {\n\tint mn, v, i;\n\tdat() { mn = Inf; }\n\tdat(int z) { mn = v = 0, i = z; }\n\tdat(int x, int y, int z) { mn = x, v = y, i = z; }\n} tr[MS];\nstruct tag {\n\tint a, w;\n\ttag() { a = w = 0; }\n\ttag(int x, int y) { a = x, w = y; }\n} tg[MS];\ninline dat operator + (dat a, dat b) { return a.mn < b.mn ? a : b; }\ninline void operator += (tag &a, tag b) { a.a += b.a, a.w ^= b.w; }\ninline void operator += (dat &a, tag b) { a.mn += b.a, a.v ^= b.w; }\ninline void P(int i, tag x) { tr[i] += x, tg[i] += x; }\nvoid Pushdown(int i) { if (tg[i].a || tg[i].w) P(li, tg[i]), P(ri, tg[i]), tg[i] = tag(); }\nvoid Build(int i, int l, int r) {\n\tif (l == r) return tr[i] = dat(l), void();\n\tBuild(ls), Build(rs);\n\ttr[i] = tr[li] + tr[ri];\n}\nvoid Mdf(int i, int l, int r, int a, int b, tag x) {\n\tif (r < a || b < l) return ;\n\tif (a <= l && r <= b) return P(i, x);\n\tPushdown(i);\n\tMdf(ls, a, b, x), Mdf(rs, a, b, x);\n\ttr[i] = tr[li] + tr[ri];\n}\n\ninline void Modify(int x, int y, tag z) {\n\twhile (top[x] != top[y]) {\n\t\tif (dep[top[x]] < dep[top[y]]) std::swap(x, y);\n\t\tMdf(1, 1, N, dfn[top[x]], dfn[x], z);\n\t\tx = par[top[x]];\n\t}\n\tif (dep[x] > dep[y]) std::swap(x, y);\n\tif (x != y) Mdf(1, 1, N, dfn[x] + 1, dfn[y], z);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1, x, y; i < N; ++i) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tDFS0(1, 0), DFS1(1, 1);\n\tBuild(1, 1, N);\n\tMdf(1, 1, N, 1, 1, tag(Inf, 0));\n\tfor (int i = 1; i < N; ++i) {\n\t\tscanf(\"%d%d\", &ex[i], &ey[i]);\n\t\tModify(ex[i], ey[i], tag(1, i));\n\t}\n\tfor (int i = 1; i < N; ++i) {\n\t\tif (tr[1].mn != 1) return puts(\"NO\"), 0;\n\t\tint j = tr[1].v;\n\t\tMdf(1, 1, N, tr[1].i, tr[1].i, tag(Inf, 0));\n\t\tModify(ex[j], ey[j], tag(-1, j));\n\t}\n\tputs(\"YES\");\n\treturn 0;\n}\n```",
        "postTime": 1596369388,
        "uid": 10703,
        "name": "\u5c0f\u7c89\u5154",
        "ccfLevel": 10,
        "title": "\u9898\u89e3 AT2377 \u3010[AGC014E] Blue and Red Tree\u3011"
    },
    {
        "content": "\u9996\u5148\u53ef\u4ee5\u53d1\u73b0\u6700\u7ec8\u72b6\u6001\u66ff\u6362\u7684\u7ea2\u8fb9\u548c\u84dd\u8fb9\u4e00\u5b9a\u662f\u91cd\u8fb9\u3002\u628a\u8fd9\u6761\u8fb9\u4e24\u7aef\u7684\u8054\u901a\u5757\u770b\u6210\u4e00\u4e2a\u70b9\u3002\n\n\u5f80\u56de\u63a8\uff0c\u8981\u5f62\u6210\u8fd9\u4e24\u4e2a\u70b9\uff0c\u5fc5\u987b\u4e5f\u8981\u6709\u7c7b\u4f3c\u7684\u91cd\u8fb9\u3002\n\n\u8fd9\u6837\u5c31\u53ef\u4ee5\u5f97\u5230\u4e00\u79cd\u505a\u6cd5\u3002\u6bcf\u6b21\u628a\u91cd\u8fb9\u4e24\u7aef\u7684\u653e\u5165\u961f\u5217\uff0c\u5e76\u628a\u8fb9\u96c6\u5408\u5e76\uff08\u542f\u53d1\u5f0f\u5408\u5e76\uff09\uff0c\u628a\u8fd9\u4e24\u4e2a\u8054\u901a\u5757\u5408\u5e76\n\n\u518d\u628a\u91cd\u8fb9\u653e\u5165\uff0c\u76f4\u81f3\u66f4\u65b0\u5b8c\u6210\n\n```cpp\n#include<cstdio>\n#include<set>\n#include<map>\n#include<algorithm>\n#define mp(x,y) make_pair(x,y)\n#define pi pair<int,int>\nusing namespace std;\ninline int read(){int x=0,f=1,ch=getchar(); while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();} while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();} return x*f;}\ninline void write(int x){if (x<0) putchar('-'),x=-x; if (x>=10) write(x/10); putchar(x%10+'0');}\ninline void writeln(int x){write(x); puts(\"\");}\nconst int N=1e5+5;\nset<int >se[N];\nmap<pi,int> ma;\npi q[N];\nint n,h,t,fa[N];\ninline int getfa(int x){\n\treturn (fa[x]==x)?x:fa[x]=getfa(fa[x]);\n}\ninline void init(){\n\tn=read();\n\tfor (int i=1;i<=n*2-2;i++){\n\t\tint u=read(),v=read();\n\t\tse[u].insert(v); se[v].insert(u);\n\t\tma[mp(u,v)]++; ma[mp(v,u)]++;\n\t\tif (ma[mp(u,v)]==2) q[++t]=make_pair(u,v);\n\t}\n}\ninline void solve(){\n\tfor (int i=1;i<=n;i++) fa[i]=i;\n\tset<int >::iterator it;\n\twhile (h<t){\n\t\tint u=q[++h].first,v=q[h].second;\n\t\tu=getfa(u); v=getfa(v);\n\t\tse[u].erase(v); se[v].erase(u);\n\t\tif (se[u].size()<se[v].size()) swap(u,v);\n\t\tfor (it=se[v].begin();it!=se[v].end();++it){\n\t\t\tint to=(*it);\n\t\t\tma[mp(to,v)]=ma[mp(v,to)]=0;\n\t\t\tse[to].erase(v); se[to].insert(u);\n\t\t\tma[mp(to,u)]++; ma[mp(u,to)]++;\n\t\t\tif (ma[mp(to,u)]==2) q[++t]=make_pair(to,u);\n\t\t\tse[u].insert(to);\n\t\t}\n\t\tfa[v]=u;\n\t\tse[v].clear();\n\t}\n\tint s=0;\n\tfor (int i=1;i<=n;i++) s+=fa[i]==i;\n\tif (s==1) puts(\"YES\"); else puts(\"NO\");\n}\nint main(){\n\tinit(); solve();\n\treturn 0;\n}\n```",
        "postTime": 1539763351,
        "uid": 34444,
        "name": "\u5927\u83dc\u9e21fks",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT2377 \u3010Blue and Red Tree\u3011"
    },
    {
        "content": "\u611f\u89c9\u597d\u591a\u9898\u89e3\u90fd\u662f $\\log^2{n}$ \u7684\u7b97\u6cd5\uff0c\u8fd9\u91cc\u63d0\u4f9b\u4e00\u79cd $\\log{n}$ \u8fd8\u7279\u522b\u77ed\u7684\u5c0f\u6e05\u65b0\u7b97\u6cd5\u3002\n\n\u505a\u6cd5\u89e3\u91ca\u4e0d\u591a\u8d58\u8ff0\uff0c~~\u611f\u89c9\u5341\u5206\u663e\u7136~~\uff0c\u5176\u4ed6\u9898\u89e3\u90fd\u6709\u8be6\u7ec6\u8bf4\u660e\uff0c\u8fd9\u91cc\u4ec5\u7b80\u8981\u63d0\u4e00\u4e0b\u505a\u6cd5\uff1a\n\n- \u5bf9\u4e8e\u6bcf\u6761\u7ea2\u8fb9\u5bf9\u5e94\u5230\u84dd\u6811\u4e0a\u7684\u4e00\u6761\u8def\u5f84\uff0c\u5c06\u5176\u8def\u5f84\u8986\u76d6\u6b21\u6570 +1\u3002\n\n  \u6bcf\u6b21\u9009\u62e9\u4e00\u6761\u53ea\u88ab\u8986\u76d6\u4e00\u6b21\u7684\u84dd\u8fb9\uff0c\u5c06\u8986\u76d6\u5b83\u7684\u7ea2\u8fb9\u7684\u8d21\u732e\u6d88\u53bb\uff0c\u5982\u679c\u627e\u4e0d\u5230\u8fd9\u6837\u7684\u84dd\u8fb9\u8bf4\u660e\u6216\u662f\u5728\u6d88\u53bb\u67d0\u6761\u7ea2\u8fb9\u65f6\u5c06\u5176\u4ed6\u84dd\u8fb9\u51cf\u5230 0 \u4e86\u5219\u65e0\u89e3\u3002\n  \n  \u8fd9\u91cc\u627e\u8986\u76d6\u6b64\u84dd\u8fb9\u7684\u7ea2\u8fb9\u53ef\u4ee5\u7528\u5f02\u6216\u7b80\u5355\u5b9e\u73b0\u3002\n\n\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u6709\u663e\u7136\u7684\u6811\u5256\u5957\u7ebf\u6bb5\u6811\u7684 $\\log^2{n}$ \u505a\u6cd5\uff0c\u6bd2\u7624\u4e14\u5bf9\u63a5\u4e0b\u6765\u7684\u7b97\u6cd5\u6ca1\u6709\u5e2e\u52a9\uff0c\u4e0d\u4f5c\u8003\u8651\u3002\n\n\u5bf9\u4e8e\u8fd9\u79cd\u8fd1\u4e4e\u88f8\u7684\u8def\u5f84\u95ee\u9898\uff0c\u53ef\u4ee5\u5f88\u663e\u7136\u7684\u60f3\u5230 LCT\uff0c\u6ce8\u610f\u5230\u9664\u4e86\u4e00\u5f00\u59cb\u5c31\u53ea\u88ab\u8986\u76d6\u4e86\u4e00\u6b21\u7684\u84dd\u8fb9\uff0c\u5176\u4ed6\u7684\u84dd\u8fb9\u90fd\u662f\u5728\u6d88\u53bb\u7ea2\u8fb9\u8d21\u732e\u65f6\u51fa\u73b0\u7684\u3002\n\n\u8bbe\u5f53\u524d\u6d88\u53bb\u7ea2\u8fb9\u5bf9\u5e94\u8def\u5f84\u4e3a $l$\uff0c\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u4e0d\u65ad\u7684\u63d0\u53d6\u51fa $l$ \u5bf9\u5e94\u8def\u5f84\u4e0a\u8986\u76d6\u6b21\u6570\u4e3a 1 \u7684\u84dd\u8fb9\uff0c\u5c06\u8fd9\u6761\u84dd\u8fb9\u5bf9\u5e94\u7ea2\u8fb9\u8d21\u732e\u6d88\u53bb\u540e\u5176\u8986\u76d6\u6b21\u6570\u5c31\u53d8\u4e3a\u4e86 0\uff0c\u5c31\u53ef\u4ee5\u7ee7\u7eed\u5728 $l$ \u4e0a\u63d0\u65b0\u7684\u84dd\u8fb9\u4e86\u3002\n\n\u5bf9\u4e8e\u6bcf\u6b21\u6d88\u53bb\u7ea2\u8fb9\u5bf9\u5e94\u8def\u5f84\u8d21\u732e\u65f6\u5c06\u84dd\u8fb9\u63d0\u5b8c\uff0c\u8fd9\u6837\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u7b97\u6cd5\u7684\u6b63\u786e\u6027\u4e86\u3002\n\n\u5982\u679c\u8fd9\u6837\u505a\u6709\u4ebf\u4e9b\u5c0f\u7ec6\u8282\uff1a\n\n- \u9996\u5148\u662f\u4f60\u8981\u7528 LCT \u627e\u8986\u76d6\u6b21\u6570\u4e3a 1 \u7684\u8fb9\uff0c\u5982\u679c\u76f4\u63a5\u7528\u6700\u5c0f\u503c\u4f1a\u627e\u5230\u8986\u76d6\u6b21\u6570 0 \u7684\u8fb9\uff0c\u6240\u4ee5\u8981\u6ce8\u610f\u6d88\u53bb\u7ea2\u8fb9\u8d21\u732e\u65f6\u987a\u4fbf\u5c06\u5f53\u524d\u84dd\u8fb9\u6e05\u4e3a inf\uff0c\u90a3\u4e48\u5269\u4e0b\u7684\u5c31\u662f LCT \u677f\u5b50\u4e86\u3002\n\n- \u7136\u540e\u662f\u4f60\u5728\u6d88\u53bb $l$ \u8fd9\u6761\u8def\u5f84\u540e\u53ef\u80fd\u63d0\u51fa\u4e00\u4e9b\u65b0\u7684\u84dd\u8fb9\uff0c\u4f46\u63d0\u4e00\u6761\u84dd\u8fb9\u53c8\u8981\u6d88\u4e00\u6b21\u5176\u7ea2\u8fb9\u5bf9\u5e94\u8def\u5f84\uff0c\u4e8e\u662f\u662f\u4e2a\u9012\u5f52\u7684\u8fc7\u7a0b\uff0c\u5199\u4e2a\u51fd\u6570\u8fd8\u662f\u4e0d\u96be\u5b9e\u73b0\u3002\n\n- \u6700\u540e\u8fd8\u8981\u8bb0\u5f97\u5224\u65e0\u89e3\u3002\n\n\u8fd9\u6837\u5df2\u7ecf\u4e0d\u5931\u4e3a\u4e00\u79cd\u601d\u8def\u7b80\u5355\uff0c\u4ee3\u7801\u4e0d\u957f(\u4e00\u4e2a LCT \u677f\u5b50\u603b\u6bd4\u6811\u5256\u5957\u7ebf\u6bb5\u6811\u4e24\u4e2a\u6570\u636e\u7ed3\u6784\u77ed\u5427)\uff0c\u590d\u6742\u5ea6\u8fd8\u4f18\u79c0\u7684\u7b97\u6cd5\u4e86\uff0c\u4f46\u6211~~\u7531\u4e8e\u61d2~~\u5c06\u5176**\u8fdb\u4e00\u6b65\u7b80\u5316\u4e86**\u4e00\u4e0b\u3002\n\n\u5229\u7528 LCT \u4e2d\u662f Splay \u8fd9\u79cd\u4f18\u79c0\u7684\u5de5\u5177\uff0c\u6211\u4eec\u4e00\u6b21\u6d88\u53bb\u7ea2\u8fb9\u8d21\u732e\u65f6\u66b4\u529b DFS \u4e0b\u53bb\u627e Splay \u4e2d\uff0c\u4e5f\u5c31\u662f\u8fd9\u6761\u8def\u5f84\u4e0a\u7684\u84dd\u8fb9\u3002\n\n\u627e\u5230\u4e00\u4e2a Splay \u4e00\u4e2a\u6216\u662f\u627e\u5b8c\u518d\u628a\u5b83\u4eec\u90fd Splay \u4e0a\u6765\u90fd\u884c\uff0c\u8fd9\u6837\u4e5f\u5c31\u5229\u7528\u4e86 Splay \u7684\u5747\u644a\u590d\u6742\u5ea6\u66b4\u529b\u5730\u53d6\u51fa\u4e86\u6240\u6709\u84dd\u8fb9\u5e76\u4e14\u65f6\u95f4\u590d\u6742\u5ea6\u8fd8\u662f\u6b63\u786e\u7684 $O(n\\log{n})$\uff0c\u56e0\u4e3a\u6bcf\u6761\u84dd\u8fb9\u53ea\u4f1a\u88ab\u627e\u4e00\u6b21\u3002\n\n\u8fd9\u6837\u5c31\u6ca1\u6709\u4ec0\u4e48\u82b1\u91cc\u80e1\u54e8\u7684\u9012\u5f52\u4e86\uff0c\u5c31\u662f\u4e00\u4e2a\u66b4\u529b LCT(+Splay\u91cc\u9762\u81ea\u5e26) \u677f\u5b50\u6a21\u62df\u6700\u521d\u7684\u7b97\u6cd5\u6d41\u7a0b\uff0c\u8fd9\u6837\u505a\u4e5f\u5c31\u5e38\u6570\u7565\u5927\u800c\u5df2\uff0c\u4f46\u654c\u4e0d\u8fc7\u5b83\u4ee3\u7801\u7b80\u5355\u4e14\u7406\u8bba\u590d\u6742\u5ea6\u4e0a\u7684\u4f18\u52bf\u3002\n\n\u7531\u4e8e\u7b14\u8005\u6bd2\u7624\u7684\u7801\u98ce\u4ee3\u7801\u5c31\u4e0d\u653e\u4e86\uff0c\u4f46\u8fd9\u79cd\u5199\u6cd5\u662f\u771f\u7684\u53c8\u77ed\u53c8\u597d\u5199\u3002",
        "postTime": 1619183624,
        "uid": 158948,
        "name": "\u7ea6\u745f\u592b\u7528\u8111\u73a9",
        "ccfLevel": 0,
        "title": "AT2377 [AGC014E] Blue and Red Tree"
    },
    {
        "content": "\u6807\u7b7e:\u6811\u94fe\u5256\u5206.\n\n\u6211\u4eec\u53d1\u73b0\u5728\u539f\u6811(\u79f0\u4e3a**\u84dd\u6811**)\u4e0a\u5220\u9664\u4e00\u6761\u84dd\u8fb9, \u7136\u540e\u5728\u76ee\u6807\u6811(\u79f0\u4e3a**\u7ea2\u6811**)\u4e0a\u5220\u9664\u4e00\u6761\u7ea2\u8fb9\u7684\u64cd\u4f5c\u4e0e\u539f\u64cd\u4f5c\u662f\u7b49\u4ef7\u7684.\n\n\u6211\u4eec\u9700\u8981\u89c4\u5212\u597d\u6bcf\u6761\u7ea2\u8fb9\u7684\u5220\u9664\u987a\u5e8f, \u548c**\u6bcf\u6761\u7ea2\u8fb9\u5220\u9664\u65f6**\u5bf9\u5e94\u5220\u9664\u7684\u662f\u90a3\u6761\u84dd\u8fb9. \u53d1\u73b0\u5982\u679c**\u84dd\u6811**\u4e0a\u67d0\u6761\u8fb9\u88ab\u552f\u4e00\u4e00\u6761\u672a\u88ab\u5220\u9664\u7684\u7ea2\u8fb9\u8986\u76d6, \u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5220\u9664\u8fd9\u6761\u84dd\u8fb9\u548c\u5176\u5bf9\u5e94\u7684\u7ea2\u8fb9. \u82e5**\u84dd\u6811**\u4e0a\u6bcf\u6761\u8fb9\u90fd\u88ab\u81f3\u5c11\u4e24\u6761\u672a\u88ab\u6dfb\u52a0\u7684\u7ea2\u8fb9\u8986\u76d6, \u5220\u9664\u4efb\u610f\u4e00\u6761\u84dd\u8fb9\u53ea\u80fd\u5220\u9664\u8986\u76d6\u5176\u7684\u4e00\u6761\u7ea2\u8fb9, \u5e76\u4e14\u8986\u76d6\u5176\u7684\u53e6\u4e00\u6761\u7ea2\u8fb9\u65e0\u6cd5\u88ab\u5220\u9664, \u6240\u4ee5\u65e0\u89e3.\n\n\u4e8e\u662f\u53ef\u4ee5\u7528\u6811\u94fe\u5256\u5206\u6765\u7ef4\u62a4\u6bcf\u6761\u84dd\u8fb9\u88ab\u591a\u5c11\u6761\u7ea2\u8fb9\u8986\u76d6, \u6bcf\u6b21\u627e\u5230\u4e00\u6761\u53ea\u88ab\u8986\u76d6\u4e00\u6b21\u7684\u84dd\u8fb9, \u5220\u9664\u5176\u548c\u552f\u4e00\u8986\u76d6\u5176\u7684\u7ea2\u8fb9, \u5c31\u53ef\u4ee5\u89e3\u51b3\u4e86. \u4f46\u662f\u6211\u4eec\u77e5\u9053\u4e00\u6761\u84dd\u8fb9\u53ea\u88ab\u8986\u76d6\u4e00\u6b21\u65f6, \u5e94\u8be5\u5982\u4f55\u7ef4\u62a4\u8986\u76d6\u5176\u7684\u7ea2\u8fb9\u7684\u7f16\u53f7\u5462?.\n\n\u4e00\u79cd\u89e3\u51b3\u65b9\u6cd5\u662f**\u5f02\u6216\u548c**, \u6211\u4eec\u5229\u7528\u6811\u94fe\u5256\u5206\u5bf9\u4e8e**\u6bcf\u4e00\u6761\u84dd\u8fb9**\u7ef4\u62a4**\u8986\u76d6\u5176\u7684\u7ea2\u8fb9\u7f16\u53f7\u7684\u5f02\u6216\u548c**, \u5219\u5f53\u5176\u53ea\u88ab\u4e00\u6761\u7ea2\u8fb9\u8986\u76d6\u65f6, \u5f02\u6216\u548c\u5373\u4e3a\u8986\u76d6\u5176\u7ea2\u8fb9\u7684\u7f16\u53f7(\u663e\u7136\u7528**\u548c**\u6216**\u6a21\u5927\u7d20\u6570\u610f\u4e49\u4e0b\u7684\u79ef**\u4e5f\u662f\u53ef\u4ee5\u7684, \u4e0d\u8fc7\u5f02\u6216\u548c\u5728\u65f6\u95f4\u5e38\u6570\u65b9\u9762\u4e0a\u6709\u8f83\u5927\u4f18\u52bf).\n\n\u65f6\u95f4\u590d\u6742\u5ea6$\\mathcal O(n\\log n)$\n\n```cpp\n#include <bits/stdc++.h>\n#define root 1, n, 1, pre[top[u]], pre[u]\n#define ls l, mid, k << 1\n#define rs mid + 1, r, k << 1 | 1\n#define L k << 1\n#define R k << 1 | 1\nusing namespace std;\nint read();\n\nint n;\nvector<int> e[200005];\nvoid add(int f, int t) { e[f].push_back(t), e[t].push_back(f); }\nint fa[200005], dep[200005], sn[200005], sz[200005];\n\nvoid dfs1(int u) {\n\tsz[u] = 1;\n    for (vector<int>::iterator v = e[u].begin(); v != e[u].end(); v++)\n        if ((*v) != fa[u]) {\n\t\t\tdep[*v] = dep[u] + 1, fa[*v] = u, dfs1(*v);\n\t\t\tsz[u] += sz[*v], sn[u] = sz[sn[u]] < sz[*v] ? *v : sn[u];\n\t\t}\n}\n\nint pre[200005], top[200005], dfn;\nvoid dfs2(int u) {\n\tpre[u] = ++dfn;\n\tif (!sn[u]) return;\n\ttop[sn[u]] = top[u], dfs2(sn[u]);\n    for (vector<int>::iterator v = e[u].begin(); v != e[u].end(); v++)\n\t\tif ((*v) != fa[u] && (*v) != sn[u]) top[*v] = *v, dfs2(*v);\n}\n\nqueue<int> q;\n\nstruct Seg {\n\tint mn[400005], xsum[400005];\n\tint tag1[400005], tag2[400005];\n\tvoid Tag1(int k, int v) { mn[k] += v, tag1[k] += v; }\n\tvoid Tag2(int k, int v) { xsum[k] ^= v, tag2[k] ^= v; }\n\tvoid psd1(int k) { Tag1(L, tag1[k]), Tag1(R, tag1[k]), tag1[k] = 0;\t}\n\tvoid pi2(1, n, 1, pre[u] + 1, pre[v], id);\n}\n\nstruct E {\n\tint u, v;\n\tvoid init(int i) { modi(u = read(), v = read(), 1, i); }\n} p[200005];\n\nint main() {\n    n = read();\n    for (int i = 1; i < n; ++i) add(read(), read());\n    dep[1] = 1, dfs1(1), top[1] = 1, dfs2(1);\n    for (int i = 1, u, v; i < n; ++i) p[i].init(i);\n\tseg.mdi1(1, n, 1, 1, 1, 100000000),\tseg.work(1, n, 1);\n\tint cnt = 0;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tcerr << t << endl;\n\t\tq.pop(), cnt++, modi(p[t].u, p[t].v, -1, t), seg.work(1, n, 1);\n\t}\n    puts(cnt == n - 1 ? \"YES\" : \"NO\");\n    return 0;\n}\n\nint read() {\n    int x = 0, f = 1;\n    char c = getchar();\n    while (c < '0' || c > '9') f = (c == '-') ? -1 : f, c = getchar();\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\n\n```\n",
        "postTime": 1575792926,
        "uid": 51237,
        "name": "Kinandra",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT2377 \u3010Blue and Red Tree\u3011"
    },
    {
        "content": "\u7b2c\u4e00\u6b21\u770b\u5230\u8fd9\u4e48\u6c34\u7684$E$\uff0c\u6211\u7684\u65b9\u6cd5\u8ddf\u9898\u89e3\u4e0d\u540c\u3002  \n\u628a\u539f\u6811\u5efa\u51fa\u6765\uff0c\u628a\u76ee\u6807\u6811\u53d8\u6210\u539f\u6811\u4e0a\u7684$n-1$\u6761\u8def\u5f84\u3002  \n\u56e0\u4e3a\u52a0\u8fb9\u7684\u65f6\u5019\uff0c\u90a3\u6761\u8def\u5f84\u4e0a\u7684\u8fb9\u5fc5\u987b\u90fd\u8fd8\u5728\uff0c\u6240\u4ee5\u53ea\u7528\u6bcf\u6b21\u5220\u6389\u53ea\u88ab\u4e00\u6761\u8def\u5f84\u8986\u76d6\u7684\u8fb9\uff0c\u7136\u540e\u5220\u6389\u8fd9\u4e2a\u8def\u5f84\uff0c\u770b\u770b\u80fd\u5426\u91cd\u590d$n-1$\u6b21\u64cd\u4f5c\u5373\u53ef\u3002  \n\u7528\u8f7b\u91cd\u94fe\u5256\u5206+\u7ebf\u6bb5\u6811\u5b9e\u73b0\uff0c\u65f6\u95f4$O(n\\log^{2}_{}n)$\u3002  \n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,l,r) for(int i=l;i<=r;++i)\nconst int N=1e5+5,T=N*30;\nint nex[T],pre[T],tot,have[N],qx[N],qy[N];\nvector<int>lk[N];\nint n;\nint dfn[N],fa[N],deep[N],sz[N],son[N],top[N];\nnamespace TREE\n{\nint tot;\nnamespace DFS1\n{\nvoid dfs(int x,int fr)\n{\n\tfa[x]=fr;\n\tdeep[x]=deep[fr]+1;\n\tsz[x]=1;\n\tfor(auto y:lk[x])\n\tif(y!=fr)\n\t{\n\t\tdfs(y,x);\n\t\tsz[x]+=sz[y];\n\t\tif(sz[y]>sz[son[x]])son[x]=y;\n\t}\n}\n};\nnamespace DFS2\n{\nvoid dfs(int x,int ntop)\n{\n\ttop[x]=ntop;\n\tdfn[x]=++tot;\n\tif(!son[x])return ;\n\tdfs(son[x],ntop);\n\tfor(auto y:lk[x])\n\tif(y!=son[x]&&y!=fa[x])dfs(y,y);\n}\n};\nvoid init()\n{\n\tDFS1::dfs(1,0);\n\ttot=-1;\n\tDFS2::dfs(1,1);\n}\n};\nint mn[N*4],ad[N*4];\nint ql,qr;\n#define in (ql<=l&&qr>=r)\n#define out (ql>r||qr<l)\n#define mid ((l+r)/2)\n#define cl (k*2)\n#define cr (cl+1)\nnamespace SEG\n{\nint n;\nvoid up(int k)\n{\n\tmn[k]=min(mn[cl],mn[cr])+ad[k];\n}\nnamespace ADD\n{\nvoid dfs(int k,int l,int r)\n{\n\tif(in)\n\t{\n\t\t++tot;\n\t\tpre[nex[tot]=nex[k]]=tot;\n\t\tpre[tot]=k;\n\t\tnex[k]=tot;\n\t\t\n\t\t++ad[k];++mn[k];\n\t\treturn ;\n\t}\n\tif(out)return ;\n\tdfs(cl,l,mid);\n\tdfs(cr,mid+1,r);\n\tup(k);\n}\n};\nnamespace DEL\n{\nvoid dfs(int k,int l,int r)\n{\n\tif(in)\n\t{\n\t\t--ad[k];--mn[k];\n\t\treturn ;\n\t}\n\tif(out)return ;\n\tdfs(cl,l,mid);\n\tdfs(cr,mid+1,r);\n\tup(k);\n}\n};\nvoid add(int l,int r)\n{\n\tql=l;qr=r;\n\tADD::dfs(1,1,n);\n}\nvoid del(int l,int r)\n{\n\tql=l;qr=r;\n\tDEL::dfs(1,1,n);\n}\nint get_mn()\n{\n\tint k=1,l=1,r=n;\n\twhile(l!=r)\n\tif(mn[cl]<mn[cr])\n\t{\n\t\tk=cl;\n\t\tr=mid;\n\t}\n\telse\n\t{\n\t\tk=cr;\n\t\tl=mid+1;\n\t}\n\treturn k;\n}\n};\n#define fx top[x]\n#define fy top[y]\nvoid add(int x,int y)\n{\n\twhile(fx!=fy)\n\t{\n\t\tif(deep[fx]<deep[fy])swap(x,y);\n\t\tSEG::add(dfn[fx],dfn[x]);\n\t\tx=fa[fx];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tSEG::add(dfn[x]+1,dfn[y]);\n}\nvoid del(int x,int y)\n{\n\twhile(fx!=fy)\n\t{\n\t\tif(deep[fx]<deep[fy])swap(x,y);\n\t\tSEG::del(dfn[fx],dfn[x]);\n\t\tx=fa[fx];\n\t}\n\tif(dfn[x]>dfn[y])swap(x,y);\n\tSEG::del(dfn[x]+1,dfn[y]);\n}\n#undef fx\n#undef fy\nvoid del_mn()\n{\n\tint k=SEG::get_mn();\n\tmn[k]=N;\n\tint i=nex[k];\n\twhile(k>>=1)\n\t{\n\t\tSEG::up(k);\n\t\tif(!i)i=nex[k];\n\t}\n\ti=lower_bound(have+1,have+n,i)-have;\n//\tcerr<<i<<endl;\n\trep(x,have[i-1]+1,have[i])\n\t{\n\t\tpre[nex[x]]=pre[x];\n\t\tnex[pre[x]]=nex[x];\n\t}\n\tdel(qx[i],qy[i]);\n}\n\nint main()\n{\n\tfreopen(\"1.in\",\"r\",stdin);freopen(\"1.out\",\"w\",stdout);\n\tcin>>n;SEG::n=n-1;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tlk[x].push_back(y);lk[y].push_back(x);\n\t}\n\tTREE::init();\n\thave[0]=tot=N*4;\n\trep(i,1,n-1)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\thave[i]=tot;\n\t\tqx[i]=x;qy[i]=y;\n\t}\n\trep(tmp,1,n-1)\n\t{\n\t\tif(mn[1]!=1)\n\t\t{\n\t\t\tputs(\"NO\");\n\t\t\texit(0);\n\t\t}\n\t\tdel_mn();\n\t}\n\tputs(\"YES\");\n}\n```",
        "postTime": 1528111913,
        "uid": 9168,
        "name": "kczno1",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT2377 \u3010Blue and Red Tree\u3011"
    },
    {
        "content": "# Blue and Red Tree\u9898\u89e3\n\u9996\u5148\uff0c\u6211\u4eec\u5f88\u5bb9\u6613\u53d1\u73b0\u5728\u4e24\u68f5\u6811\u4e0a\u8fde\u63a5\u76f8\u540c\u7684\u70b9\u7684\u8fb9\u65e0\u9700\u5220\u53bb\u3002\n\n\u63a5\u7740\uff0c\u9996\u5148\u5220\u90a3\u6761\u8fb9\uff1f\n\n\u6211\u4eec\u628a\u7ea2\u6811\u4e0a\u4e0d\u4e0e\u84dd\u6811\u91cd\u5408\u7684\u8fb9\u770b\u4f5c\u8986\u76d6\u84dd\u6811\u8fb9\u7684\u8def\u5f84\uff0c\n\n\u90a3\u4e48\uff0c\u6211\u4eec\u9996\u5148\u5220\u9664\u88ab\u7ea2\u6811\u8fb9\u8986\u76d6\u591a\u6b21\u7684\u8fb9\u4e48\uff1f\n\n\u80af\u5b9a\u4e0d\u884c\uff0c\u5220\u9664\u8fd9\u6761\u8fb9\u540e\uff0c\u5c31\u4e0d\u5b58\u5728\u6784\u6210\u5176\u4ed6\u8986\u76d6\u8fd9\u6761\u84dd\u8fb9\u7684\u7ea2\u8fb9\u6240\u9700\u7684\u84dd\u8fb9\u94fe\u4e86\u3002\n\n\u6240\u4ee5\uff0c\u6211\u4eec\u6bcf\u6b21\u627e\u51fa\u53ea\u88ab\u8986\u76d6\u4e00\u6b21\u7684\u84dd\u8fb9\uff0c\u5220\u53bb\u8986\u76d6\u5b83\u7684\u7ea2\u904d\uff0c\u5e76\u53bb\u9664\u7ea2\n\u8fb9\u5f71\u54cd\uff0c\u5982\u679c\u505a\u5230\u6700\u540e\uff0c\u81ea\u7136\u53ef\u4ee5\u3002\n\n### \u4ee3\u7801\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define lc (x<<1)\n#define rc (x<<1|1) \nusing namespace std;\nconst int N=60006,inf=1e9,mod=201314;\nint n,m,t1,t2,t3,cnt=0,dfn=0,tot=0,f[N],a[N],d[N],son[N],siz[N],num[N],top[N],lazy[N<<2],w[N<<2],head[N],ans[N];\nstruct xd{int i,flag,x,y;}q[N<<1];\nstruct edge{int nxt,to;}e[N<<1];\ninline void add(int u,int v){e[++cnt].nxt=head[u],e[cnt].to=v,head[u]=cnt;}\ninline int read(){\n   int T=0,F=1; char ch=getchar();\n   while(ch<'0'||ch>'9'){if(ch=='-') F=-1; ch=getchar();}\n   while(ch>='0'&&ch<='9') T=(T<<3)+(T<<1)+(ch-48),ch=getchar();\n   return F*T;\n}\nvoid dfs(int x){\n     d[x]=d[f[x]]+1,siz[x]=1; int maxt=0,maxa=-1;\n     for(int i=head[x];i;i=e[i].nxt){\n            dfs(e[i].to),siz[x]+=siz[e[i].to];\n            if(maxa<siz[e[i].to]) maxt=e[i].to,maxa=siz[maxt];\n         } \n     son[x]=maxt;\n}\nvoid dfs2(int x,int topx){\n     num[x]=++dfn,top[x]=topx; \n     if(son[x]) dfs2(son[x],topx);\n     for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=f[x]&&e[i].to!=son[x]) dfs2(e[i].to,e[i].to); \n}\nvoid pushdown(int x,int len){if(lazy[x]) lazy[lc]=(lazy[lc]+lazy[x])%mod,lazy[rc]=(lazy[rc]+lazy[x])%mod,w[lc]=(w[lc]+lazy[x]*(len-(len>>1))%mod)%mod,w[rc]=(w[rc]+lazy[x]*(len>>1)%mod)%mod,lazy[x]=0;}\nvoid update(int l,int r,int p,int q,int x,int y){\n     if(p<=l&&r<=q){w[x]=(w[x]+(r-l+1)*y%mod)%mod,lazy[x]=(lazy[x]+y)%mod; return;}\n     pushdown(x,r-l+1);\n     int mid=l+r>>1;\n     if(p<=mid) update(l,mid,p,q,lc,y);\n     if(q>mid) update(mid+1,r,p,q,rc,y);\n     w[x]=(w[lc]+w[rc])%mod;\n}\nint query(int l,int r,int p,int q,int x){\n     if(p<=l&&r<=q) return w[x];\n     pushdown(x,r-l+1);\n     int mid=l+r>>1,ans=0;\n     if(p<=mid) ans=query(l,mid,p,q,lc);\n     if(q>mid) ans=(ans+query(mid+1,r,p,q,rc))%mod;\n     return ans;\n}\nvoid lj_update(int x,int y){\n    while(top[x]!=top[y]){\n         if(d[top[x]]<d[top[y]]) swap(x,y);\n         update(1,n,num[top[x]],num[x],1,1);\n         x=f[top[x]];\n    }\n    if(d[x]>d[y]) swap(x,y);\n    update(1,n,num[x],num[y],1,1); \n}\nint lj_query(int x,int y){\n    int ans=0;\n    while(top[x]!=top[y]){\n         if(d[top[x]]<d[top[y]]) swap(x,y);\n         ans=(ans+query(1,n,num[top[x]],num[x],1))%mod;\n         x=f[top[x]];\n    }\n    if(d[x]>d[y]) swap(x,y);\n    ans=(ans+query(1,n,num[x],num[y],1))%mod; \n    return ans;\n}\nbool cmp(xd u,xd v){return u.x<v.x;}\nint main(){\n    n=read(),m=read();\n    for(int i=2;i<=n;++i) f[i]=read()+1,add(f[i],i);\n    dfs(1),dfs2(1,1);\n    for(int i=1;i<=m;++i){\n        t1=read(),t2=read()+1,t3=read()+1;\n        q[++tot].flag=0,q[tot].i=i,q[tot].x=t1,q[tot].y=t3;\n        q[++tot].flag=1,q[tot].i=i,q[tot].x=t2,q[tot].y=t3; \n    }\n    sort(q+1,q+tot+1,cmp),q[0].x=0;\n    for(int i=1;i<=tot;++i){\n        for(int j=q[i-1].x+1;j<=q[i].x;++j)\n            lj_update(1,j);\n        if(!q[i].flag) ans[q[i].i]=-lj_query(1,q[i].y);\n        else ans[q[i].i]=(ans[q[i].i]+lj_query(1,q[i].y)+mod)%mod;\n    }\n    for(int i=1;i<=m;++i) printf(\"%d\\n\",ans[i]);\n    return 0;\n}  \n```",
        "postTime": 1566645531,
        "uid": 44180,
        "name": "ljk123",
        "ccfLevel": 0,
        "title": "Blue and Red Tree\u9898\u89e3"
    }
]