[
    {
        "content": "## [\u9898\u76ee\u4f20\u9001\u95e8](https://www.luogu.com.cn/problem/AT1221)\n\n\u9898\u76ee\u5927\u610f\uff1a\n\n\u5bf9\u4e8e\u4e00\u4e2a\u77e9\u9635\uff0c\u6c42$a$\u5230$b$\u4e24\u70b9\u95f4\u57ce\u5e02\u4e4b\u95f4\u6700\u5927\u7684\u8ddd\u79bb.\n\n~~\u5f88\u5bb9\u6613~~\u60f3\u5230\u628a\u77e9\u9635\u6254\u5230\u56fe\u4e0a\u3002\n\n~~\u5f88\u5bb9\u6613~~\u60f3\u5230\u628a\u56fe\u6254\u5230\u6811\u4e0a\u3002\n\n~~\u5f88\u5bb9\u6613~~\u60f3\u5230\u7528\u500d\u589e\u5904\u7406\u6700\u5927\u503c\u3002\n\n-  \u5982\u4f55\u5c06\u77e9\u9635\u8f6c\u5316\u4e3a\u4e00\u4e2a\u56fe\uff1f\uff1f\n\n    \u6211\u4eec\u53ef\u4ee5\u8dd1\u4e00\u904d$bfs$\u3002\uff08\u7c7b\u4f3c\u4e8e\u53cc\u6e90$bf$s\u8dd1\u591a\u6e90$bfs$\uff09\n\n   \u5148\u5c06\u8bfb\u5165\u7684\u70b9\u90fd\u5165\u961f\uff0c\u7136\u540e\u5c06\u5176\u62d3\u5c55\uff0c\u6211\u4eec\u77e5\u9053$JOI$\u541b\u4ed6\u5e76\u4e0d\u50bb\uff0c\u80af\u5b9a\u4e0d\u4f1a\u7ed5\u6765\u7ed5\u53bb\uff0c\u4e8e\u662f\u8054\u901a\u5757\u6700\u5148\u76f8\u4ea4\u7684\u70b9\u80af\u5b9a\u662f\u5219\u6b63\u5e38\u7684\u9053\u8def$zzz$\u3002\n\n   \u7528\u7ed3\u6784\u4f53\u6765\u5b58\u50a8\u8d77\u70b9\u7ec8\u70b9\u548c\u8fb9\u6743(~~\u56e0\u4e3a\u6211\u4eec\u4e00\u4f1a\u8981\u8dd1\u6700\u5927\u751f\u6210\u6811~~)\n\n```cpp\nvoid bfs()\n{\n\twhile(!q.empty()) {\n\t\tE now=q.front(); \n\t\tq.pop();\n\t\tint x=now.x;\n\t\tint y=now.y;\n\t\tv[x][y]=1;\n\t\tfor(int i=1;i<=4;i++) {\n\t\t\tint xx=x+dx[i];\n\t\t\tint yy=y+dy[i];\n\t\t\tif(xx<1||xx>n||yy<1||yy>m||a[xx][yy]=='#'||v[xx][yy])\tcontinue;\n\t\t\tv[x][y]=1;\n\t\t\tif(!b[xx][yy]) {\n\t\t\t\tb[xx][yy]=b[x][y];\n\t\t\t\tdis[xx][yy]=dis[x][y]+1;\n\t\t\t\tq.push((E){xx,yy});\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(b[xx][yy]!=b[x][y]) \n\t\t\t{\n\t\t\t\te[++cnt].from=b[xx][yy];\n\t\t\t\te[cnt].to=b[x][y];\n\t\t\t\te[cnt].w=dis[xx][yy]+dis[x][y];\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n- \u5982\u4f55\u628a\u56fe\u6254\u5230\u6811\u4e0a\uff1f\uff1f\n\n\t$MST$\n\n\t\u65e2\u7136\u60f3\u8981\u4f7f\u6c34\u58f6\u6700\u5c0f\uff0c\u90a3\u4e9b\u6bd4\u8f83\u5927\u7684\u8fb9\u5c31\u5c3d\u91cf\u522b\u8d70\u561b\uff0c\u8d2a\u5fc3\u4e00\u4e0b\u3002\n\n\t\u5c31\u901a\u8fc7 $Kruskal$ \u5904\u7406\u51fa\u6765\u6700\u5c0f\u751f\u6210\u6811\u3002\n\n```cpp\nfor(int i=1;i<=p;i++)\tfa[i]=i;\n\tsort(e+1,e+cnt+1,cmp);\n\tfor(int i=1;i<=cnt;i++) \n\t{\n\t\tint fx=find(e[i].from);\n\t\tint fy=find(e[i].to);\n\t\tif(fx==fy)\tcontinue;\n\t\tfa[fy]=fx;\n\t\tk++;\n\t\tins(e[i].from,e[i].to,e[i].w);\n\t\tins(e[i].to,e[i].from,e[i].w);\n\t\tif(k==p-1)\tbreak;\n\t}\n```\n\n- \u5982\u4f55\u500d\u589e\u5904\u7406\u6700\u5927\u8fb9\u6743\uff1f\uff1f\n\n\t\u8bb0\u5f55 $f[u][i]$\u8868\u793a\u4eceu\u8df3$2^{i}$\u5230\u8fbe\u7684\u70b9\u3002\n\n\t$t[u][i]$\u5c31\u662f\u4eceu\u5230$2^{i}$\u7684\u6700\u5927\u8fb9\u6743\u4e86\u3002\n    \n    \u5c31\u50cf\u8dd1 $LCA$ \u4e00\u6837\u8dd1\u6700\u5927\u8fb9\u6743\u5c31\u53ef\u4ee5\u4e86\u3002\n\n```cpp\nvid dfs(int x,int father,int deep)\n{\n\tdep[x]=deep; used[x]=1;\n\tfor(int i=fir[x];i;i=nex[i]) {\n\t\tint p=poi[i];\n\t\tif(p==father)\tcontinue;\n\t\tf[p][0]=x;\n\t\tt[p][0]=val[i];\n\t\tdfs(p,x,deep+1);\n\t}\n}\nvoid Dp() {\n\tfor(int j=1;j<=19;j++)\n\tfor(int i=1;i<=p;i++)\n\t\tf[i][j]=f[f[i][j-1]][j-1],\n\t\tt[i][j]=max(t[i][j-1],t[f[i][j-1]][j-1]);\n}\nint Lca(int x,int y)\n{\n\tif(find(fa[x])!=find(fa[y])) return -1;\n\tint ans=0;\n\tif(dep[x]<dep[y])\tswap(x,y);\n\tfor(int i=18;i>=0;i--)\t\n\t\tif(dep[f[x][i]]>=dep[y])\n\t\t\tans=max(ans,t[x][i]),x=f[x][i];\n\tif(x==y)\treturn ans;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(f[x][i]==f[y][i]||!f[x][i]||!f[y][i])\tcontinue;\n\t\tans=max(ans,max(t[x][i],t[y][i]));\n\t\tx=f[x][i]; y=f[y][i];\n\t}\n\tans=max(ans,max(t[x][0],t[y][0]));\n\treturn ans;\n}\n```\n## \u6ce8\u610f\u4e8b\u9879\uff1a\n\n1. \u8dd1\u51fa\u6765\u53ef\u80fd\u662f\u4e2a\u68ee\u6797\uff0c\u4e8e\u662f\u8981\u4ece\u91cc\u9762\u6bcf\u4e00\u68f5\u6811\u4e0a\u8dd1$dfs$\u3002\n\n2. \u5148\u53d6$max$\u518d\u8df3\uff0c\u4e0d\u7136\u4f1a\u6709\u6ca1\u53d6\u5230\u6700\u5927\u503c\u7684\u8fb9\u3002\n\n**\u5173\u4e8e$-1$\uff1a\u4e0d\u5728\u4e00\u4e2a\u5e76\u67e5\u96c6\u91cc\u9762\u3002**\n\n\u4ee3\u7801\u5982\u4e0b\uff1a\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\n#define N 5000010\n#define M 10010\nusing namespace std;\nint re() {\n\tint p=0; char i=getchar();\n\twhile(i<'0'||i>'9')\ti=getchar();\n\twhile(i>='0'&&i<='9')\tp=p*10+i-'0',i=getchar();\n\treturn p;\n}\nint n,m,p,T,sum,cnt,k;\nchar a[M][M];\nint dis[M][M],b[M][M],fa[N];\nint fir[N],nex[N],poi[N],val[N];\nint dep[N],f[N][20],t[N][20];\nbool v[M][M],used[N];\nconst int dx[]={0,1,-1,0,0}; const int dy[]={0,0,0,1,-1};\nstruct zy {\n\tint from,to;\n\tint w;\n}e[N];\nstruct E {\n\tint x,y;\n}que[N];\nqueue<E > q;\nvoid ins(int x,int y,int z) {\n\tnex[++sum]=fir[x];\n\tpoi[sum]=y;\n\tval[sum]=z;\n\tfir[x]=sum;\n}\nvoid bfs()\n{\n\twhile(!q.empty()) {\n\t\tE now=q.front(); \n\t\tq.pop();\n\t\tint x=now.x;\n\t\tint y=now.y;\n\t\tv[x][y]=1;\n\t\tfor(int i=1;i<=4;i++) {\n\t\t\tint xx=x+dx[i];\n\t\t\tint yy=y+dy[i];\n\t\t\tif(xx<1||xx>n||yy<1||yy>m||a[xx][yy]=='#'||v[xx][yy])\tcontinue;\n\t\t\tv[x][y]=1;\n\t\t\tif(!b[xx][yy]) {\n\t\t\t\tb[xx][yy]=b[x][y];\n\t\t\t\tdis[xx][yy]=dis[x][y]+1;\n\t\t\t\tq.push((E){xx,yy});\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif(b[xx][yy]!=b[x][y]) \n\t\t\t{\n\t\t\t\te[++cnt].from=b[xx][yy];\n\t\t\t\te[cnt].to=b[x][y];\n\t\t\t\te[cnt].w=dis[xx][yy]+dis[x][y];\n\t\t\t}\n\t\t}\n\t}\n}\nbool cmp(zy x,zy y) {\n\treturn x.w<y.w;\n}\nint find(int x) {\n\tif(fa[x]!=x)\treturn fa[x]=find(fa[x]);\n\treturn fa[x];\n}\nvoid dfs(int x,int father,int deep)\n{\n\tdep[x]=deep; used[x]=1;\n\tfor(int i=fir[x];i;i=nex[i]) {\n\t\tint p=poi[i];\n\t\tif(p==father)\tcontinue;\n\t\tf[p][0]=x;\n\t\tt[p][0]=val[i];\n\t\tdfs(p,x,deep+1);\n\t}\n}\nvoid Dp() {\n\tfor(int j=1;j<=19;j++)\n\tfor(int i=1;i<=p;i++)\n\t\tf[i][j]=f[f[i][j-1]][j-1],\n\t\tt[i][j]=max(t[i][j-1],t[f[i][j-1]][j-1]);\n}\nint Lca(int x,int y)\n{\n\tif(find(fa[x])!=find(fa[y])) return -1;\n\tint ans=0;\n\tif(dep[x]<dep[y])\tswap(x,y);\n\tfor(int i=18;i>=0;i--)\t\n\t\tif(dep[f[x][i]]>=dep[y])\n\t\t\tans=max(ans,t[x][i]),x=f[x][i];\n\tif(x==y)\treturn ans;\n\tfor(int i=19;i>=0;i--)\n\t{\n\t\tif(f[x][i]==f[y][i]||!f[x][i]||!f[y][i])\tcontinue;\n\t\tans=max(ans,max(t[x][i],t[y][i]));\n\t\tx=f[x][i]; y=f[y][i];\n\t}\n\tans=max(ans,max(t[x][0],t[y][0]));\n\treturn ans;\n}\nint main()\n{\n\tn=re(); m=re(); p=re(); T=re();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\tcin>>a[i][j];\n\tfor(int i=1;i<=p;i++) {\n\t\tint X,Y;\n\t\tX=re(); Y=re();\n\t\tb[X][Y]=i;\n\t\tq.push((E){X,Y});\n\t}\n\tbfs();\n\tfor(int i=1;i<=p;i++)\tfa[i]=i;\n\tsort(e+1,e+cnt+1,cmp);\n\tfor(int i=1;i<=cnt;i++) \n\t{\n\t\tint fx=find(e[i].from);\n\t\tint fy=find(e[i].to);\n\t\tif(fx==fy)\tcontinue;\n\t\tfa[fy]=fx;\n\t\tk++;\n\t\tins(e[i].from,e[i].to,e[i].w);\n\t\tins(e[i].to,e[i].from,e[i].w);\n\t\tif(k==p-1)\tbreak;\n\t}\n\tfor(int i=1;i<=p;i++)\n\t\tif(!used[i])\tdfs(i,0,1);\n\tDp();\n\twhile(T--) {\n\t\tint x,y;\n\t\tx=re(); y=re();\n\t\tprintf(\"%d\\n\",Lca(x,y));\n\t}\n\treturn 0;\n}\n```\n\u53e6\uff1a\n\n\u53ef\u4ee5\u5148\u505a\u4e00\u4e0b[\u6b64\u9898](https://www.luogu.com.cn/problem/P1967)\u3002\n\n----\n\n\u5982\u6709\u4e0d\u59a5\u6216\u8005\u662f\u4e0d\u660e\u767d\u7684\uff0c\u6b22\u8fce\u6307\u51fa\uff01\n\n\u671b\u7ba1\u7406\u5927\u5927\u901a\u8fc7\u3002",
        "postTime": 1610871396,
        "uid": 233816,
        "name": "_zy_",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    },
    {
        "content": "\u9996\u5148\uff0c\u6211\u4eec\u6765\u8bc1\u660e\u4e00\u4e2a\u6027\u8d28\uff1a\n\n\u5bf9\u4e8e\u4e00\u4e2a\u56fe\uff0c\u5176\u4e2d\u4efb\u610f\u4e24\u4e2a\u70b9\u95f4\u7684\u8def\u5f84\u6211\u4eec\u8bb0\u4e3a $p$\u3002\u6bcf\u4e2a\u8def\u5f84\u4e0a\u6700\u5927\u7684\u6743\u503c\u4e3a $q$\u3002\u5219\u6ee1\u8db3 $q$ \u6700\u5c0f\u7684\u8def\u5f84 $p_0$ \u4e00\u5b9a\u5728\u539f\u56fe\u7684\u6700\u5c0f\u751f\u6210\u6811\uff08\u68ee\u6797\uff09\u4e0a\u3002\n\n\u6211\u4eec\u8bbe\u8fd9\u9897\u6700\u5c0f\u751f\u6210\u6811\uff08\u68ee\u6797\uff09\u4e3a $T$\uff0c\u4e24\u70b9\u95f4\u8def\u5f84 $p$ \u4e0a\u7684\u6700\u5927\u503c\u4e3a $\\max(p)$\u3002\u5047\u8bbe $p$ \u4e0d\u662f $T$ \u4e0a\u7684\u8def\u5f84\uff0c\u5219\u4e00\u5b9a\u5b58\u5728\u4e00\u6761\u8def\u5f84 $p_1$ \u4f7f\u5f97 $\\max(p_1)$ \u6bd4 $\\max(p)$ \u66f4\u5c0f\u3002\u6211\u4eec\u8003\u8651\u5c06 $p_1$ \u52a0\u5165 $T$\u3002\n\n\u5c06\u8fd9\u4e2a\u8def\u5f84\u52a0\u5165\u540e\uff0c\u4e00\u5b9a\u4f1a\u5728\u539f\u6811\u4e0a\u51fa\u73b0\u4e00\u4e2a\u73af\uff0c\u800c\u8fd9\u4e2a\u73af\u4e0a\u7684\u6700\u5927\u503c\u4e00\u5b9a\u4e3a $\\max(p)$\u3002\n\n\u4f60\u4f1a\u60ca\u8bb6\u7684\u53d1\u73b0\uff0c\u5982\u679c\u5220\u6389\u90a3\u6761\u6743\u503c\u4e3a $\\max(p)$ \u7684\u8fb9\uff0c\u4f60\u4f1a\u5f97\u5230\u4e00\u9897\u65b0\u7684\u6811\uff0c\u800c\u660e\u663e\u8fd9\u624d\u662f\u771f\u6b63\u7684\u6700\u5c0f\u751f\u6210\u6811\u3002\n\n\u63a8\u51fa\u77db\u76fe\uff01\u539f\u6027\u8d28\u5f97\u8bc1\u3002\n\n\u90a3\u4e48\u6211\u4eec\u73b0\u5728\u5f97\u5230\u4e86\u8fd9\u6837\u4e00\u4e2a\u6027\u8d28\uff0c\u62bd\u8c61\u6982\u62ec\u51fa\u6765\u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u7684\u7b54\u6848\u4e00\u5b9a\u5728\u539f\u56fe\u7684 **\u6700\u5c0f\u751f\u6210\u6811\uff08\u68ee\u6797\uff09** \u4e0a\uff0c\u56e0\u4e3a\u6811\u4e0a\u4e24\u70b9\u8def\u5f84\u552f\u4e00\uff0c\u6240\u4ee5\u7b54\u6848\u5c31\u662f\u4e24\u70b9\u95f4\u8def\u5f84\u4e0a\u7684\u6700\u5927\u8fb9\u3002\u8fd9\u663e\u7136\u53ef\u4ee5 **\u6811\u4e0a\u500d\u589e** \u89e3\u51b3\u3002\n\n\u6700\u540e\u8bb2\u8bb2\u9884\u5904\u7406\uff0c\u4e5f\u5c31\u662f\u5982\u4f55\u53bb\u5efa\u56fe\u3002\u5f88\u663e\u7136\uff0c\u66b4\u529b **BFS** \u662f\u4e0d\u53ef\u53d6\u7684\u3002\u4e8e\u662f\u6211\u4eec\u8003\u8651\u66f4\u9ad8\u6548\u7684\u9884\u5904\u7406\u65b9\u6cd5\u3002\n\n\u5176\u5b9e\u8fd8\u662f BFS\uff0c\u7c7b\u53cc\u5411 BFS\u3002\u6211\u4eec\u9996\u5148\u5c06\u6240\u6709\u7684\u57ce\u5e02\u88c5\u5165 BFS \u7684\u961f\u5217\uff0c\u7136\u540e\u540c\u65f6\u5f00\u59cb\u8fdb\u884c\u6269\u5c55\u3002\u5bf9\u4e00\u4e2a\u70b9\u6211\u4eec\u6253\u4e24\u79cd\u6807\u8bb0\uff1a$flag$ \u8868\u793a\u8fd9\u4e2a\u70b9\u662f\u7531\u54ea\u4e2a\u57ce\u5e02\u7b2c\u4e00\u6b21\u8d70\u5230\u7684\uff0c$ans$ \u8868\u793a\u7b2c\u4e00\u4e2a\u8d70\u5230\u8fd9\u4e2a\u70b9\u7684\u57ce\u5e02\u5230\u5b83\u7684\u8ddd\u79bb\u3002\u90a3\u4e48\u5bf9\u4e8e\u5f53\u524d\u6269\u5c55\u5230\u7684\u8282\u70b9\uff0c\u5b83\u7684\u6807\u8bb0\u6709\u4e24\u79cd\u60c5\u51b5\u3002\n\n\u5047\u8bbe\u4e0a\u4e00\u4e2a\u70b9\u4e3a $v$\uff0c\u5f53\u524d\u70b9\u4e3a $u$\u3002\n\n* $ans_u$ \u91cc\u6ca1\u6709\u503c\uff0c\u4e5f\u5c31\u662f\u8bf4\u5f53\u524d\u662f\u7b2c\u4e00\u6b21\u8d70\u5230\uff0c\u66f4\u65b0 $flag_u$ \u7ee7\u7eed\u6269\u5c55\u5373\u53ef\u3002\n\n```cpp\nans[u] = ans[v] + 1;\nflag[u] = flag[v];\n```\n\n* ans \u91cc\u6709\u503c\uff0c\u4e5f\u5c31\u662f\u8bf4\u4e4b\u524d\u6709\u57ce\u5e02\u6269\u5c55\u5230\u4e86\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u5c06\u5f53\u524d\u8fd9\u4e2a\u57ce\u5e02\u548c\u4e4b\u524d\u6269\u5c55\u7684\u57ce\u5e02\u8fdb\u884c\u8fde\u8fb9\uff0c\u6743\u503c\u5c31\u662f\u4e0a\u4e00\u4e2a\u70b9\u548c\u8fd9\u4e2a\u70b9\u7684 $ans$ \u4e4b\u548c\u3002\n\n```cpp\nAdd_Edge(flag[u], flag[v], ans[u] + ans[v]);\n```\n\n\u7136\u540e\u6309\u6b63\u5e38 BFS \u7ee7\u7eed\u904d\u5386\u5373\u53ef\uff0c\u5b8c\u7ed3\u6492\u82b1\u3002\n\n\uff08\u4ee3\u7801\u7565\u663e\u5197\u957f\uff0c\u4ec5\u4f9b\u53c2\u8003\u3002\n\n```cpp\n#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint read() {\n    int k = 1, x = 0;\n    char s = getchar();\n    while (s < '0' || s > '9') {\n        if (s == '-')\n            k = -1;\n        s = getchar();\n    }\n    while (s >= '0' && s <= '9') {\n        x = (x << 3) + (x << 1) + s - '0';\n        s = getchar();\n    }\n    return x * k;\n}\n\nvoid write(int x) {\n    if(x < 0) {\n    \tputchar('-');\n\t\tx = -x;\n    }\n    if(x > 9)\n\t\twrite(x / 10);\n    putchar(x % 10 + '0');\n}\n\nvoid print(int x, char s) {\n\twrite(x);\n\tputchar(s);\n}\n\nint Max(int x, int y) { return x > y ? x : y; }\nint Min(int x, int y) { return x < y ? x : y; }\nvoid Swap(int &X, int &Y) {\n    int t = X;\n    X = Y;\n    Y = t;\n}\n\nconst int MAXN = 2e3 + 5;\nconst int MAXL = 4e6 + 5;\nint mp[MAXN][MAXN], h, w, p;\nchar s[MAXN];\n\nstruct node {\n    int x, y;\n    node() {}\n    node(int X, int Y) {\n        x = X;\n        y = Y;\n    }\n};\n\nstruct edge {\n    int u, v, w;\n    edge() {}\n    edge(int U, int V, int W) {\n        u = U;\n        v = V;\n        w = W;\n    }\n} e[MAXL];\nint len = 0;\n\nint dx[4] = { 1, -1, 0, 0 };\nint dy[4] = { 0, 0, 1, -1 };\nint ans[MAXN][MAXN], flag[MAXN][MAXN];\nqueue<node> q;\n\nvoid bfs() {\n    while (!q.empty()) {\n        node now = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int cx = now.x + dx[i];\n            int cy = now.y + dy[i];\n            if (cx < 1 || cx > h)\n                continue;\n            if (cy < 1 || cy > w)\n                continue;\n            if (mp[cx][cy])\n                continue;\n            if (ans[cx][cy] == -1) {\n                ans[cx][cy] = ans[now.x][now.y] + 1;\n                flag[cx][cy] = flag[now.x][now.y];\n                q.push(node(cx, cy));\n            } else if (flag[cx][cy] != flag[now.x][now.y])\n                e[++len] = edge(flag[now.x][now.y], flag[cx][cy], ans[cx][cy] + ans[now.x][now.y]);\n        }\n    }\n}\n\nstruct data {\n    int ma, fa;\n    data() {}\n    data(int Ma, int Fa) {\n        ma = Ma;\n        fa = Fa;\n    }\n} f[MAXL][25];\n\nint fa[MAXL];\n\nbool cmp(edge x, edge y) { return x.w < y.w; }\n\nvoid Make_Set(int n) {\n    for (int i = 1; i <= n; i++) fa[i] = i;\n}\n\nint Find_Set(int x) {\n    if (fa[x] == x)\n        return x;\n    return fa[x] = Find_Set(fa[x]);\n}\n\nstruct graph {\n    int v, w;\n    graph() {}\n    graph(int V, int W) {\n        v = V;\n        w = W;\n    }\n};\n\nvector<graph> g[MAXL];\n\nvoid Add_Edge(int u, int v, int w) {\n    g[u].push_back(graph(v, w));\n    g[v].push_back(graph(u, w));\n}\n\nvoid kruskal() {\n    Make_Set(p);\n    sort(e + 1, e + len + 1, cmp);\n    for (int i = 1; i <= len; i++) {\n        int S = Find_Set(e[i].u), E = Find_Set(e[i].v);\n        if (S == E)\n            continue;\n        Add_Edge(S, E, e[i].w);\n        fa[S] = E;\n    }\n}\n\nint dep[MAXL];\n\nvoid dfs(int x, int fa) {\n    for (int i = 0; i < g[x].size(); i++) {\n        int v = g[x][i].v;\n        if (v == fa)\n            continue;\n        dep[v] = dep[x] + 1;\n        f[v][0].fa = x;\n        f[v][0].ma = g[x][i].w;\n        for (int j = 0; j <= 20; j++) {\n            f[v][j + 1].fa = f[f[v][j].fa][j].fa;\n            f[v][j + 1].ma = Max(f[v][j].ma, f[f[v][j].fa][j].ma);\n        }\n        dfs(v, x);\n    }\n}\n\nint lca(int x, int y) {\n    if (dep[x] < dep[y])\n        Swap(x, y);\n    int ans = 0;\n    for (int i = 20; i >= 0; i--)\n        if (dep[f[x][i].fa] >= dep[y]) {\n            ans = Max(ans, f[x][i].ma);\n            x = f[x][i].fa;\n        }\n    if (x == y)\n        return ans;\n    for (int i = 20; i >= 0; i--)\n        if (f[x][i].fa != f[y][i].fa) {\n            ans = Max(ans, f[x][i].ma);\n            ans = Max(ans, f[y][i].ma);\n            x = f[x][i].fa;\n            y = f[y][i].fa;\n        }\n    ans = Max(ans, f[x][0].ma);\n    ans = Max(ans, f[y][0].ma);\n    return ans;\n}\n\nint main() {\n//    freopen(\"04-04.in\", \"r\", stdin);\n//    freopen(\"ans1.out\", \"w\", stdout);\n    int Q;\n    h = read(), w = read(), p = read(), Q = read();\n    for (int i = 1; i <= h; i++) {\n        scanf(\"%s\", s + 1);\n        for (int j = 1; j <= w; j++)\n            if (s[j] == '.')\n                mp[i][j] = 0;\n            else\n                mp[i][j] = 1;\n    }\n    memset(ans, -1, sizeof ans);\n    for (int i = 1; i <= p; i++) {\n        int x = read(), y = read();\n        flag[x][y] = i;\n        ans[x][y] = 0;\n        q.push(node(x, y));\n    }\n    bfs();\n    //\tprintf(\"%d\\n\", len);\n    kruskal();\n    for (int i = 1; i <= p; i++)\n        if (fa[i] == i)\n            dfs(i, -1);\n    for (int i = 1; i <= Q; i++) {\n        int x = read(), y = read();\n        if (Find_Set(x) != Find_Set(y))\n            print(-1, '\\n');\n        else\n            print(lca(x, y), '\\n');\n    }\n    return 0;\n}\n```",
        "postTime": 1609238960,
        "uid": 266779,
        "name": "STrAduts",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    },
    {
        "content": "[\u9898\u76ee\u94fe\u63a5](https://www.luogu.com.cn/problem/AT1221)\n\n\u770b\u5230\u9898\u89e3\u533a\u90fd\u662f$Kruskal$\u91cd\u6784\u6811\u7684\u9898\u89e3\uff0c\u6211\u6765\u4e00\u53d1\u5e73\u6613\u8fd1\u4eba\u7684$Lca$\u500d\u589e\u9898\u89e3qwq\u3002\n\n\u5bb9\u6613\u60f3\u5230\u653e\u5230\u56fe\u4e0a\u6765\u505a\u3002\n\n\u53d1\u73b0\u6bcf\u4e00\u6b21\u8be2\u95ee\u7684\u90fd\u662f\u5efa\u7b51\u7269\u3002 \u5982\u679c\u628a\u5efa\u7b51\u7269\u770b\u6210\u70b9\uff0c\u4e5f\u5c31\u662f\u8bf4\u5bf9\u4e8e\u4efb\u610f\u4e24\u4e2a\u70b9\u4e4b\u95f4\uff0c \u80af\u5b9a\u6709**\u82e5\u5e72\u6761**\u8def\u5f84\u3002 \u5176\u4e2d\u80af\u5b9a\u6709\u4e00\u6761\u6700\u4f18\u7684\uff0c\u4e5f\u5c31\u662f\u8bf4**\u5176\u4f59**\u7684\u8def\u5f84\u90fd\u662f\u4e0d\u9700\u8981\u7684\uff0c \u6211\u4eec\u5173\u5fc3\u7684\u53ea\u662f\u6700\u4f18\u7684\u90a3\u4e00\u6761\u3002 \u628a\u8fd9\u4e9b\u8fb9**\u5220\u53bb**\uff0c \u6211\u4eec\u5c31\u4f1a~~\u60ca\u8bb6~~\u7684\u53d1\u73b0\u6240\u6709\u7684\u5efa\u7b51\u7269\u8fde\u6210\u4e86\u4e00\u68f5\u6811!\n\n\u56e0\u6b64\u6211\u4eec\u8981\u6c42\u7684\u5c31\u662f\u8fd9\u5f20\u7f51\u683c\u56fe\u7684$MST$\u4e86\u3002 \u5bf9\u4e8e\u6bcf\u4e00\u6761\u8fb9\u7684\u957f\u5ea6\uff0c \u6211\u4eec\u53ef\u4ee5\u591a\u6e90 $bfs$ \u6765\u6c42\u3002 \u6700\u65e9\u5373\u6700\u4f18\u3002 \u5982\u679c\u4e24\u4e2a\u6e90\u70b9\u6240\u6269\u5f20\u5230\u7684\u70b9\u76f8\u4ea4\u4e86\uff0c \u90a3\u4e48\u8fd9\u4e00\u6761\u8fb9\u7684\u957f\u5ea6\u5c31\u662f\u4e24\u4e2a\u6e90\u70b9\u5230\u8be5\u70b9\u8ddd\u79bb\u548c\u3002 \u628a\n\u6240\u6709\u7684\u8fb9\u538b\u5165\u5806\u91cc\uff0c \u6700\u540e\u5e76\u67e5\u96c6\u6765\u5b9e\u73b0 $Kruskal$ \u5373\u53ef\u3002\n\n\u4e8e\u662f\u5c31\u5f97\u5230\u4e86\u4e00\u68f5\u6811\uff0c \u5bf9\u4e8e\u6bcf\u4e00\u6b21\u8be2\u95ee\u8fd9\u68f5\u6811\u7684\u8282\u70b9 $x,y$ \u4e4b\u95f4\u7684\u6700\u5927\u8ddd\u79bb\u3002 \u6211\u4eec\u53ef\u4ee5\u5728 $Lca$ \u7684\u540c\n\u65f6\u500d\u589e\u89e3\u51b3\u4e86qwq!~~\u7c7b\u4f3c\u4e8e[\u8d27\u8f66\u8fd0\u8f93](https://www.luogu.com.cn/problem/P1967)~~\u3002\n\n### $Code$\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nconst int N = 2e3 + 10;\nconst int Q = 2e5 + 10;\nint h,w,p,qq,sum;\nint first[Q],d[N][N],star[N][N],f[Q][21],dis[Q][21],dep[Q];\nint father[Q];\nint fx[5] = {0 , 1 , -1 , 0 , 0};\nint fy[5] = {0 , 0 , 0 , 1 , -1};\nstring s[N];\nchar dt[N][N];\nbool v[Q],b[N][N];\nvoid in(int &x) {\n\tx = 0;\n\tchar ee = getchar();\n\twhile(ee < '0' || ee > '9') ee = getchar();\n\twhile(ee >= '0' && ee <= '9') x = (x << 1) + (x << 3) + ee - '0' , ee = getchar();\n} struct NO\n{int x,y;} Node[N * N],Build[N * N];\nstruct queue {\n\tint head,tail;\n\tNO a[N * N];\n\tvoid clear() {\n\t\thead = tail = 0;\n\t}\n\tvoid push(NO x) {\n\t\ta[tail++] = x;\n\t}\n\tNO front() {\n\t\treturn a[head];\n\t}\n\tvoid pop() {\n\t\thead++;\n\t}\n\tbool empty() {\n\t\treturn head == tail ? true : false;\n\t}\n} q;\nstruct E {\n\tint next;\n\tint to;\n\tint w;\n\tvoid add(int x , int y , int w_) {\n\t\tnext = first[x];\n\t\tto = y;\n\t\tw = w_;\n\t\tfirst[x] = sum;\n\t}\n} e[Q * 2];\nstruct Edge {\n\tint l,r,w;\n\tbool operator < (const Edge b) const {\n\t\treturn w > b.w;\n\t}\n};\npriority_queue<Edge> G;\ninline int find(int x) {\n\treturn father[x] == x ? x : father[x] = find(father[x]);\n}\nvoid bfs() {\n\twhile(!q.empty()) {\n\t\tNO top = q.front();\n\t\tq.pop();\n\t\tint x = top.x;\n\t\tint y = top.y;\n\t\tb[x][y] = 1;\n\t\tfor(int i = 1 ; i <= 4 ; i++) {\n\t\t\tint xx = x + fx[i];\n\t\t\tint yy = y + fy[i];\n\t\t\tif(xx <= 0 || xx > h || yy <= 0 || yy > w || dt[xx][yy] == '#' || b[xx][yy])\n\t\t\t\tcontinue;\n\t\t\tb[x][y] = 1;\n\t\t\tif(!star[xx][yy]) {\n\t\t\t\tstar[xx][yy] = star[x][y];\n\t\t\t\td[xx][yy] = d[x][y] + 1;\n\t\t\t\tq.push((NO) {\n\t\t\t\t\txx , yy\n\t\t\t\t});\n\t\t\t} else if(star[xx][yy] != star[x][y])\n\t\t\t\tG.push((Edge) {\n\t\t\t\tstar[x][y] , star[xx][yy] , d[xx][yy] + d[x][y]\n\t\t\t});\n\t\t}\n\t}\n} void Kruskal() {\n\twhile(!G.empty()) {\n\t\tEdge now = G.top();\n\t\tG.pop();\n\t\tint x = now.l;\n\t\tint y = now.r;\n\t\tint fx = find(x);\n\t\tint fy = find(y);\n\t\tif(fx == fy) continue;\n\t\tfather[fx] = fy;\n\t\te[++sum].add(x , y , now.w);\n\t\te[++sum].add(y , x , now.w);\n\t}\n} void dfs(int x , int fa) {\n\tdep[x] = dep[fa] + 1;\n\tv[x] = 1;\n\tf[x][0] = fa;\n\tfor(int i = first[x] ; i ; i = e[i].next) {\n\t\tint to = e[i].to;\n\t\tif(to == fa) continue;\n\t\tdis[to][0] = e[i].w;\n\t\tdfs(to , x);\n\t}\n} void Dp() {\n\tfor(int j = 1; j <= 20; j++)\n\t\tfor(int i = 1; i <=p ; i++) {\n\t\t\tf[i][j] = f[f[i][j - 1]][j - 1];\n\t\t\tdis[i][j] = max(dis[f[i][j - 1]][j - 1] , dis[i][j - 1]);\n\t\t}\n} int Lca(int x , int y) {\n\tint ans = 0;\n\tif(dep[x] < dep[y]) swap(x , y);\n\tfor(int i = 20; i >= 0; i--)\n\t\tif(dep[f[x][i]] >= dep[y]) {\n\t\t\tans =max(ans , dis[x][i]);\n\t\t\tx = f[x][i];\n\t\t}\n\tif(x == y) return ans;\n\tfor(int i = 20; i >= 0; i--)\n\t\tif(f[x][i] && f[y][i])\n\t\t\tif(f[x][i] != f[y][i]) {\n\t\t\t\tans =max(ans , max(dis[y][i] , dis[x][i]));\n\t\t\t\tx = f[x][i];\n\t\t\t\ty = f[y][i];\n\t\t\t}\n\treturn max(ans , max(dis[x][0] , dis[y][0]));\n} int main() {\n//\tfreopen(\"2.in\",\"r\",stdin);\n//\tfreopen(\"2.out\",\"w\",stdout);\n\tin(h);\n\tin(w);\n\tin(p);\n\tin(qq);\n\tfor(int i = 1; i <= h; i++)\n\t\tcin>>s[i];\n\tfor(int i = 1; i <= h; i++)\n\t\tfor(int j = 0; j < w; j++)\n\t\t\tdt[i][j + 1] = s[i][j];\n\tfor(int i = 1; i <= p; i++) {\n\t\tin(Build[i].x);\n\t\tin(Build[i].y);\n\t\tint ai = Build[i].x;\n\t\tint bi = Build[i].y;\n\t\tstar[ai][bi] = i;\n\t\tfather[i] = i;\n\t\tq.push((NO) {\n\t\t\tai , bi\n\t\t});\n\t} bfs();\n\tKruskal();\n\tfor(int i = 1; i <= p; i++)\n\t\tif(!v[star[Build[i].x][Build[i].y]])\n\t\t\tdfs(star[Build[i].x][Build[i].y] , 0);\n\tDp();\n\tfor(int i = 1; i <= qq; i++) {\n\t\tint x,y;\n\t\tin(x);\n\t\tin(y);\n\t\tif(find(x) != find(y)) printf(\"-1\\n\");\n\t\telse printf(\"%d\\n\",Lca(x , y));\n\t} return 0;\n}\n```",
        "postTime": 1603673118,
        "uid": 232191,
        "name": "NXYorz",
        "ccfLevel": 6,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    },
    {
        "content": "\u5199\u4e00\u7bc7\u9898\u89e3\u8bc1\u660e\u4e00\u4e0b\uff0c\u7b97\u662f\u5bf9\u9898\u89e3\u533a\u5199\u8fd9\u79cd\u505a\u6cd5\u7684\u8001\u54e5\u4eec\u7684\u8865\u5145\u3002\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a\u514b\u9c81\u65af\u5361\u5c14\u91cd\u6784\u6811\u3002\n\n\u7531\u4e8e\u9898\u76ee\u9650\u5236\u4e86\u662f\u4e2a\u7f51\u683c\u56fe\u5e76\u4e14\u8fb9\u6743\u4e3a $1$ \u6216\u8005 $0$ \uff0c\u53ef\u4ee5\u76f4\u63a5 BFS\u3002\n\n\u7136\u540e\u5bf9\u4e8e\u6bcf\u4e2a\u975e\u57ce\u5e02\u8282\u70b9\u8bb0\u5f55\u79bb\u5b83\u6700\u8fd1\u7684\u57ce\u5e02\u8282\u70b9\uff0c\u5bf9\u4e8e BFS \u5f53\u524d\u8003\u8651\u7684\u4e24\u4e2a\u70b9\u3002\u5982\u679c\u6709\u4e00\u4e2a\u8fd8\u6ca1\u88ab\u57ce\u5e02\u8282\u70b9\u8986\u76d6\uff0c\u90a3\u4e48\u5c31\u8986\u76d6\u8fd9\u4e2a\u8282\u70b9\uff0c\u5982\u679c\u88ab\u4e0d\u540c\u57ce\u5e02\u8282\u70b9\u8986\u76d6\u5c31\u4fdd\u7559\u8fd9\u6761\u8fb9\uff0c\u8fb9\u6743\u53d8\u4e3a\u4e24\u8005 dis \u503c\u4e4b\u548c\uff0c dis \u503c\u8868\u793a\u79bb\u81ea\u5df1\u6700\u8fd1\u7684\u57ce\u5e02\u7684\u8ddd\u79bb\uff0c\u518d\u628a\u8fd9\u4e9b\u8fb9\u8dd1\u4e00\u6b21\u6700\u5c0f\u751f\u6210\u6811\uff0c\u5efa\u51fa\u91cd\u6784\u6811\uff0c\u6bcf\u6b21\u8be2\u95ee\u5373\u67e5\u8be2\u4e24\u8005 LCA \u7684\u70b9\u6743\uff0c\u8fd9\u4e9b\u4e1c\u897f\u5927\u5bb6\u53ef\u4ee5\u53bb\u770b [Query_LCA\n\u7684\u9898\u89e3](https://www.luogu.com.cn/blog/AlFepular/solution-at1221)\u3002\u6211\u60f3\u8865\u5145\u4e00\u4e0b\u4e00\u4e2a\u7ec6\u8282\uff1a\n\n\u8003\u8651\u5982\u679c\u5f53\u524d\u8fd9\u6761\u8fb9\u8fde\u63a5\u7740\u4e00\u4e2a\u57ce\u5e02\u548c\u4e00\u4e2a\u539f\u91ce\uff0c\u90a3\u4e48\u5176\u5b9e\u539f\u91ce\u5230\u57ce\u5e02\u7684\u8fb9\u6743\u5e94\u8be5\u662f $0$ \uff0c\u4f46\u662f\u6211\u4eec\u5e76\u6ca1\u6709\u5224\u8fd9\u79cd\u60c5\u51b5\uff0c\u4e3a\u4ec0\u4e48\u5462\uff1f\u8003\u8651\u4e00\u6761\u8def\u5f84\u4e0a\u8981\u8d70\u5230\u67d0\u4e2a\u57ce\u5e02\uff0c\u4f46\u662f\u6211\u4eec\u6709\u4e00\u4e2a\u7ed3\u8bba\uff1a\u5148\u8d70\u5230\u8fd9\u4e2a\u70b9\u7684\u6700\u8fd1\u57ce\u5e02\u8865\u5145\u6c34\uff0c\u7136\u540e\u518d\u8d70\u56de\u6765\uff0c\u8fd9\u6837\u4e00\u5b9a\u6700\u4f18\uff0c\u8fd9\u4e2a\u7ed3\u8bba\u4e5f\u662f\u975e\u5e38\u597d\u8bc1\u7684\uff0c\u9650\u4e8e\u7bc7\u5e45\u5c31\u4e0d\u5199\u4e86\uff0c\u5982\u679c\u6709\u7591\u60d1\u53ef\u4ee5\u79c1\u4fe1\u627e\u6211\u3002\u8fd9\u6837\u4e00\u6765\u4f60\u56de\u5230\u539f\u91ce\u7684\u8fc7\u7a0b\u4e2d\u4e00\u5b9a\u81f3\u5c11\u7ecf\u8fc7\u4e86\u4e00\u4e2a $1$\uff0c\u800c\u4e14\u8fd9\u9898\u6bd4\u8f83\u7279\u6b8a\u4e4b\u5904\u662f\u8fb9\u6743\u56fa\u5b9a\u4e3a $1$\uff0c\u6240\u4ee5\u6700\u4f18\u65b9\u6848\u4e00\u5b9a\u662f\u4f1a\u8d70\u5230\u57ce\u5e02\u518d\u8d70\u56de\u6765\u518d\u8d70\u8fc7\u53bb\uff0c\u90a3\u4e48 $0$ \u8fd9\u6761\u8fb9\u4e00\u5b9a\u6ca1\u6709\u7528\u4e86\u3002\u6240\u4ee5\u8fde\u6210 $1$ \u4e00\u5b9a\u6ca1\u6709\u95ee\u9898\u3002",
        "postTime": 1630937026,
        "uid": 282751,
        "name": "cryozwq",
        "ccfLevel": 7,
        "title": "\u9898\u89e3 AT1221"
    },
    {
        "content": "\u524d\u7f6e\u829d\u58eb\uff1a[bfs](https://oi-wiki.org/graph/bfs/)\u3001[Kruskal \u91cd\u6784\u6811](https://www.cnblogs.com/zwfymqz/p/9683523.html)\n\n\u663e\u7136\u53ef\u4ee5\u66b4\u529b\u5efa\u8fb9\uff0c\u5373\uff1a\u8bbe $dis_u$ \u8868\u793a $u$ \u5230\u79bb $u$ \u6700\u8fd1\u7684\u5efa\u7b51\u7269\u7684\u8ddd\u79bb\uff0c\u5bf9\u4e8e\u4e24\u4e2a\u683c\u5b50 $u, v$\uff0c\u5efa\u8fb9 $u \\to v$\uff0c\u8fb9\u6743\u4e3a $dis_u + dis_v$\u3002$dis_v$ \u53ef\u4ee5\u7528\u53cc\u7aef\u961f\u5217 bfs \u6c42\u51fa\u3002\n\n\u6709\u4eba\u8bf4\uff0c\u8fd9\u4e0d\u5bf9\uff0c\u56e0\u4e3a\u6765\u53bb\u7684\u8fb9\u6743\u53ef\u80fd\u4e0d\u540c\uff0c\u4f46\u53ef\u4ee5\u8bc1\u660e\u5b83**\u6ca1\u6709\u5f71\u54cd**\u3002\n\n\u8bc1\u660e\uff1a\u5047\u8bbe $u$ \u548c $v$ \u5747\u4e3a\u539f\u91ce\u6216\u5efa\u7b51\u7269\uff0c\u663e\u7136\u6210\u7acb\uff1b\u8bbe\u79bb $u$ \u6700\u8fd1\u7684\u5efa\u7b51\u7269\u4e3a $building_u$\uff0c\u5047\u8bbe $u$ \u4e3a\u5efa\u7b51\u7269\uff0c$v$ \u4e3a\u539f\u91ce\uff0c\u5219\u4ece $u$ \u5230 $v$ \u9700\u8981\u6d88\u8017 $1$ \u7684\u6c34\u91cf\uff0c\u4ece $v$ \u5230 $building_v$ \u9700\u8981\u6d88\u8017 $dis_v - 1$ \u7684\u6c34\u91cf\uff0c\u5219\u8fb9\u6743\u5e94\u4e3a $dis_v$\u3002\u7531\u4e8e $dis_u = 0$\uff0c\u539f\u5f0f\u6210\u7acb\u3002\n\n\u4f46\u662f\u8fd9\u6837\u505a\u4f1a\u88ab\u5361\u7a7a\u95f4\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u5728 bfs \u7684\u540c\u65f6\u5efa\u8fb9\u3002\u4f46\u8fd9\u6837\u8c8c\u4f3c\u8fd8\u4f1a\u88ab\u5361\u7a7a\u95f4\u3002\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8003\u8651**\u7f29\u70b9**\uff0c\u5373\u5c06\u6700\u8fd1\u5efa\u7b51\u7269\u76f8\u540c\u7684\u539f\u91ce\u7f29\u6210\u4e00\u4e2a\u70b9\u3002\n\n\u5efa\u5b8c\u56fe\u540e\u8dd1 Kruskal \u91cd\u6784\u6811\uff08\u8fb9\u6743\u4ece\u5c0f\u5230\u5927\uff09\uff0c\u67e5\u8be2\u65f6\u76f4\u63a5\u67e5 LCA \u5373\u53ef\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n\nusing namespace std;\n\ntypedef struct Set_tag {\n\tint x;\n\tint y;\n\tSet_tag(int x_, int y_){\n\t\tx = x_;\n\t\ty = y_;\n\t}\n} Set;\n\ntypedef struct {\n\tint start;\n\tint end;\n\tint dis;\n} Edge1;\n\ntypedef struct {\n\tint nxt;\n\tint end;\n} Edge2;\n\nconst int N = 2e5 + 7, M = 4, K = 8e6 + 7, P = 22, Q = 2e3 + 7, R = 1.6e7 + 7;\nint dot_cnt, edge_cnt = 0;\nint city[N], dx[M + 7] = {0, -1, 0, 0, 1}, dy[M + 7] = {0, 0, -1, 1, 0}, dis[K], belong[K], root[K], head[K], depth[K], fa[K][P + 1];\nchar mp[Q][Q];\nbool mark[Q][Q], vis[Q][Q];\nEdge1 edge1[R];\nEdge2 edge2[K];\ndeque<Set> q;\n\nbool operator <(const Edge1 a, const Edge1 b){\n\treturn a.dis < b.dis;\n}\n\ninline void init(int n){\n\tfor (register int i = 1; i <= n; i++){\n\t\troot[i] = i;\n\t}\n}\n\ninline int bfs(int h, int w){\n\tint n = 0;\n\tfor (register int i = 1; i <= h; i++){\n\t\tfor (register int j = 1; j <= w; j++){\n\t\t\tint id = w * (i - 1) + j;\n\t\t\tif (mark[i][j]){\n\t\t\t\tdis[id] = 0;\n\t\t\t\tbelong[id] = id;\n\t\t\t\tq.push_back(Set(i, j));\n\t\t\t} else {\n\t\t\t\tdis[id] = 0x7fffffff;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!q.empty()){\n\t\tint cur_x, cur_y;\n\t\tSet cur = q.front();\n\t\tq.pop_front();\n\t\tcur_x = cur.x;\n\t\tcur_y = cur.y;\n\t\tif (vis[cur_x][cur_y]) continue;\n\t\tint id = w * (cur_x - 1) + cur_y;\n\t\tvis[cur_x][cur_y] = true;\n\t\tfor (register int i = 1; i <= M; i++){\n\t\t\tint new_x = cur_x + dx[i], new_y = cur_y + dy[i], new_id = w * (new_x - 1) + new_y;\n\t\t\tif (new_x >= 1 && new_x <= h && new_y >= 1 && new_y <= w && mp[new_x][new_y] == '.' && belong[id] != belong[new_id]){\n\t\t\t\tif (belong[new_id] == 0){\n\t\t\t\t\tbelong[new_id] = belong[id];\n\t\t\t\t\tdis[new_id] = dis[id] + (mark[new_x][new_y] ? 0 : 1);\n\t\t\t\t\tif (mark[new_x][new_y]){\n\t\t\t\t\t\tq.push_front(Set(new_x, new_y));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tq.push_back(Set(new_x, new_y));\n\t\t\t\t\t}\n\t\t\t\t} else if (belong[id] != belong[new_id]){\n\t\t\t\t\tn++;\n\t\t\t\t\tedge1[n].start = belong[id];\n\t\t\t\t\tedge1[n].end = belong[new_id];\n\t\t\t\t\tedge1[n].dis = dis[id] + dis[new_id];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn n;\n}\n\nint get_root(int x){\n\tif (root[x] == x) return x;\n\treturn root[x] = get_root(root[x]);\n}\n\ninline void add_edge(int start, int end){\n\tedge_cnt++;\n\tedge2[edge_cnt].nxt = head[start];\n\thead[start] = edge_cnt;\n\tedge2[edge_cnt].end = end;\n}\n\ninline void kruskal(int n){\n\tint m = dot_cnt * 2 - 1;\n\tfor (register int i = 1; i <= n; i++){\n\t\tint x_root = get_root(edge1[i].start), y_root = get_root(edge1[i].end);\n\t\tif (x_root != y_root){\n\t\t\tdot_cnt++;\n\t\t\troot[x_root] = root[y_root] = dot_cnt;\n\t\t\tdis[dot_cnt] = edge1[i].dis;\n\t\t\tadd_edge(dot_cnt, x_root);\n\t\t\tadd_edge(dot_cnt, y_root);\n\t\t\tif (dot_cnt == m) break;\n\t\t}\n\t}\n}\n\nvoid dfs(int u, int father){\n\tint t;\n\tdepth[u] = depth[father] + 1;\n\tt = log2(depth[u]);\n\tfa[u][0] = father;\n\tfor (register int i = 1; i <= t; i++){\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\t}\n\tfor (register int i = head[u]; i != 0; i = edge2[i].nxt){\n\t\tdfs(edge2[i].end, u);\n\t}\n}\n\ninline int lca(int u, int v){\n\tif (depth[u] < depth[v]) swap(u, v);\n\twhile (depth[u] > depth[v]) u = fa[u][(int)log2(depth[u] - depth[v])];\n\tif (u == v) return u;\n\tfor (register int i = log2(depth[u]); i >= 0; i--){\n\t\tif (fa[u][i] != fa[v][i]){\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\nint main(){\n\tint h, w, p, q, n;\n\tcin >> h >> w >> p >> q;\n\tdot_cnt = h * w;\n\tinit(dot_cnt * 2 - 1);\n\tfor (register int i = 1; i <= h; i++){\n\t\tcin >> &mp[i][1];\n\t}\n\tfor (register int i = 1; i <= p; i++){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tcity[i] = w * (a - 1) + b;\n\t\tmark[a][b] = true;\n\t}\n\tn = bfs(h, w);\n\tsort(edge1 + 1, edge1 + n + 1);\n\tkruskal(n);\n\tfor (register int i = 1; i <= dot_cnt; i++){\n\t\tif (get_root(i) == i) dfs(i, 0);\n\t}\n\tfor (register int i = 1; i <= q; i++){\n\t\tint s, t;\n\t\tcin >> s >> t;\n\t\ts = belong[city[s]];\n\t\tt = belong[city[t]];\n\t\tif (get_root(s) != get_root(t)){\n\t\t\tcout << -1 << endl;\n\t\t} else {\n\t\t\tcout << dis[lca(s, t)] << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n```",
        "postTime": 1630935789,
        "uid": 201007,
        "name": "Leasier",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    },
    {
        "content": "[\u8fd9\u91cc\u770b\u9898\u9762](https://www.luogu.com.cn/problem/AT1221)\n\n### \u4e00\u53e5\u8bdd\u9898\u610f\n\n\u6709\u4e00\u5757 $n\\times m$ \u7684\u5730\uff0c\u4e0a\u9762\u6709\u4e0d\u80fd\u901a\u884c `#` \uff0c\u53ef\u4ee5\u901a\u884c\u7684 `.`\uff0c\u6709 $w$ \u4e2a\u5efa\u7b51\u7269\u3002\n\n\u4f60\u6bcf\u6b21\u4ece\u4e00\u4e2a\u5efa\u7b51\u7269\u51fa\u53d1\uff0c\u5230\u53e6\u4e00\u4e2a\u5efa\u7b51\u7269\u7684\u4ee3\u4ef7\u662f\u4e2d\u95f4\u7684\u683c\u5b50\u6570\u3002\n\n\u8ba9\u4f60\u6c42\u4ece $s_i$ \u5efa\u7b51\u7269\u51fa\u53d1\u5230 $t_i$ \u7684\u5efa\u7b51\u7269\u6240\u7ecf\u8fc7\u6240\u6709\u8def\u7ebf\u4e2d\uff0c\u6700\u5927\u4ee3\u4ef7\u6700\u5c0f\u7684\u90a3\u4e2a\u4ee3\u4ef7\u3002\n\n$1\\le n,m\\le 2000,1\\le m,q \\le 10^5$\u3002\uff08\u5e0c\u671b\u7ba1\u7406\u5458\u5427\u6570\u636e\u8303\u56f4\u3001\u6570\u636e\u7ea6\u675f\u52a0\u4e0a\uff09\u3002\n\n### \u601d\u8def\n\n\u8fd9\u4e0d\u663e\u7136\u662f\u6c42\u4e00\u4e2a MST \u4e2d\uff0ca \u5230 b \u6240\u6709\u6743\u503c\u6700\u5927\u7684\u561b\uff1f\n\n\u8fd9\u4e0d\u663e\u7136\u662f kruskal \u91cd\u6784\u6811\u561b\uff1f\uff08\u4e0d\u4f1a\u7684\u53ef\u4ee5[\u5de6\u8f6c](https://www.cnblogs.com/zwfymqz/p/9683523.html)\uff09\n\n\u90a3\u8fd9\u6837\u6211\u4eec\u53c8\u8981\u4fdd\u8bc1\u8fb9\u6743\u4ece\u5c0f\u5230\u5927\u554a\uff0c\u5982\u679c\u66b4\u529b\u6dfb\u8fb9\u7684\u8bdd\u4f1a\u6dfb $w^2$ \u6761\u8fb9\uff0c\u663e\u7136\u4f1a T\u3002\n\n\u8fd9\u91cc\u6211\u4eec\u8981\u5b66\u4f1a~~\u7075\u6d3b~~\u601d\u8003\uff0ckruskal \u7684\u8bdd\u4e0d\u662f\u53ea\u9700\u8981\u6700\u5c0f\u7684\u90a3\u51e0\u6761\u8fb9\u561b\uff0c\u6211\u8981\u4f60\u5927\u7684\u5e72\u561b\uff1f\n\n\u8fd9\u6837\u5c31\u53ef\u4ee5\u51cf\u53bb\u5f88\u591a\u65f6\u95f4\u4e86\u3002\n\n\u8fd9\u91cc\u53c8\u662f\u4e00\u4e2a\u795e\u5947\u7684\u7b97\u6cd5\uff1a\u591a\u6e90 BFS\u3002\n\n\u5982\u679c\u628a\u6240\u6709\u7684\u5efa\u7b51\u7269\u90fd\u4f5c\u4e3a\u8d77\u70b9\u5f00\u59cb BFS \u7684\u8bdd\uff0c**\u4f3c\u4e4e**\u5c31\u53ef\u4ee5\u4fdd\u8bc1\u8fb9\u6743\u5355\u8c03\u6027\u4e86\uff01\n\n\u624b\u52a8\u6a21\u62df\u4e00\u4e0b\uff0c\u591a\u6e90 BFS \u5f80\u5916\u6269\u5f20\u50cf\u4ec0\u4e48\uff1f\n\n\u591a\u4e2a\u533a\u57df\u4e00\u8d77\u5f80\u5916\u6269\u5f20\u76f4\u81f3\u5408\u5e76\uff01\u50cf\u201c\u6c34\u6ef4\u6269\u6563\u201d\uff01\n\n\u5f53\u6bcf\u4e2a\u6c34\u6ef4\u78b0\u5230\u7684\u65f6\u5019\uff0c\u5c31\u628a\u4ed6\u4eec\u8fde\u8d77\u6765\uff0c\u8fd9\u6837\u4e00\u5b9a\u662f\u6700\u4f18\u7684\uff08\u6700\u77ed\u7684\uff09\u3002\n\n\u7ed9\u6bcf\u4e2a BFS \u5230\u7684\u70b9\u6253\u4e0a\u6807\u8bb0\uff0c\u663e\u7136\u7b2c\u4e00\u4e2a\u5230\u8fbe\u8fd9\u91cc\u7684\u70b9\u662f\u6700\u4f18\u7684\uff08\u7b2c\u4e8c\u4e2a\u6c34\u6ef4\u6269\u6563\u5230\u8fd9\u4e2a\u683c\u5b50\u7684\u4e0d\u7b97\u6570 23333 \uff09\u3002\n\n\u7531\u4e8e\u6709\u963b\u788d\uff0c\u5f00\u4e00\u4e2a dis \u8bb0\u5f55\u6700\u8fd1\u7684\u5efa\u7b51\u7269\u5230\u4ed6\u7684\u8ddd\u79bb\u3002\u5f53\u4e24\u4e2a\u78b0\u5230\u7684\u65f6\u5019\u5c31\u5f53\u524d\u6b65\u6570+dis \u4f5c\u4e3a\u8fb9\u6743\u3002\uff08\u4e24\u8fb9\u6269\u6563\uff09\n\n\u8fd9\u6837\u5c31\u53ef\u505a\u4e86\uff0c\u521a\u597d\u8fd9\u9898\u6570\u636e\u4e5f\u4e0d\u600e\u4e48\u6b7b\uff0c\u76f4\u63a5\u500d\u589e LCA \u5373\u53ef\u3002\n\n### Code:\n\n```cpp\n// \u9119\u4eba\u7801\u98ce\u4e0d\u6e05\u723d\u8bf7\u89c1\u8c05\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2005, M = 800005;\nconst int dx[10] = {0, 0, 0, -1, 1};\nconst int dy[10] = {0, 1, -1, 0, 0};\nstruct edg {\n    int a, b, w;\n    bool operator < (const edg &a1) const {\n        return w < a1.w;\n    }\n} ed[N * N];\nstruct edge {\n    int to, next;\n} e[M * 2];\nstruct node {\n    int id, x, y, w;\n    node(int iid, int xx, int yy, int ww) {\n        id = iid, x = xx, y = yy, w = ww;\n    };\n};\nint cnt, n, m, w, q, xx, yy, fa[M], x[M], y[M], val[M], dep[M], id[N][N], head[M * 2];\nint ql, qr, tot, vis[M], dis[N][N], f[M][20];\nchar c[N][N];\ninline int find(int u) {\n    if (u == fa[u])\n        return u;\n\n    return fa[u] = find(fa[u]);\n}\ninline void add(int from, int to) {\n    e[++cnt] = (edge) {\n        to, head[from]\n    };\n    head[from] = cnt;\n}\ninline void dfs(int u, int fat) {\n    dep[u] = dep[fat] + 1;\n    f[u][0] = fat;\n    vis[u] = 1;\n\n    for (int i = 1; i < 20; i++)\n        f[u][i] = f[f[u][i - 1]][i - 1];\n\n    for (int v, i = head[u]; i; i = e[i].next)\n        if ((v = e[i].to) != fat)\n            dfs(v, u);\n\n    return;\n}\ninline int lca(int x, int y) {\n    if (dep[x] < dep[y])\n        swap(x, y);\n\n    for (int i = 19; ~i; --i)\n        if (dep[x] - dep[y] >= (1 << i))\n            x = f[x][i];\n\n    if (x == y)\n        return x;\n\n    for (int i = 19; ~i; --i)\n        if (f[x][i] != f[y][i])\n            x = f[x][i], y = f[y][i];\n\n    return f[x][0];\n}\nint main() {\n    queue<node> qq;\n    scanf(\"%d%d%d%d\", &n, &m, &w, &q);\n\n    for (int i = 1; i < M; i++)\n        fa[i] = i;\n\n    for (int i = 1; i <= n; i++)\n        scanf(\"%s\", c[i] + 1);\n\n    for (int i = 1; i <= w; i++)\n        scanf(\"%d%d\", &x[i], &y[i]), qq.push(node(id[x[i]][y[i]] = i, x[i], y[i], 0));\n\n    while (!qq.empty()) {\n        node k = qq.front();\n        qq.pop();\n        id[k.x][k.y] = k.id;\n\n        for (int i = 1; i <= 4; i++) {\n            int tx = dx[i] + k.x, ty = dy[i] + k.y;\n\n            if (tx <= 0 || tx > n || ty <= 0 || ty > m || c[tx][ty] == '#')\n                continue;\n\n            if (id[tx][ty]) {\n                if (id[tx][ty] != id[k.x][k.y])\n                    ed[++tot] = (edg) {\n                    id[k.x][k.y], id[tx][ty], k.w + dis[tx][ty]\n                };\n            } else\n                qq.push(node(id[tx][ty] = k.id, tx, ty, dis[tx][ty] = k.w + 1));\n        }\n    }\n\n    sort(ed + 1, ed + tot + 1);\n\n    for (int i = 1; i <= tot; i++) {\n        int ex = find(ed[i].a), ey = find(ed[i].b);\n\n        if (ex != ey)\n            add(ex, ++w), add(ey, w), add(w, ex), add(w, ey), fa[ex] = fa[ey] = w, val[w] = ed[i].w;\n    }\n\n    for (int i = 1; i <= w; i++)\n        if (!vis[i])\n            dfs(find(i), 0);\n\n    for (int i = 1; i <= q; i++) {\n        scanf(\"%d%d\", &ql, &qr);\n\n        if (find(ql) != find(qr))\n            puts(\"-1\");\n        else\n            printf(\"%d\\n\", val[lca(ql, qr)]);\n    }\n\n    return 0;\n}\n```\n\n### \u603b\u7ed3\n\n\u8981\u6709\u7206\u70b8\u6027\u601d\u7ef4\uff0c\u8fd9\u4e2a\u601d\u8def\u4e0d\u884c\u8d76\u7d27\u6362\uff0c\u4e0d\u8981\u6b7b\u78d5\u6ca1\u6709\u610f\u601d\uff01\n\n\u8981\u6709\u521b\u65b0\u6027\u601d\u7ef4\uff0c\u611f\u89c9\u81ea\u5df1\u4f18\u5316\u4e0d\u884c\u6a21\u62df\u8bf4\u4e0d\u5b9a\u4f1a\u7ed9\u81ea\u5df1\u4e00\u4e9b\u601d\u8def\u3002\n\n\u8fd8\u6709 too_late \u53ef\u7231\uff01",
        "postTime": 1606636292,
        "uid": 115857,
        "name": "resound_WANYI_13Ell",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    },
    {
        "content": "## Solution:\n\n\u8003\u8651\u628a\u7ed9\u5b9a\u7684\u5730\u56fe\u5efa\u51fa\u56fe\u6765\uff0c\u90a3\u4e48\u8be2\u95ee\u5b9e\u9645\u4e0a\u5c31\u662f\u8be2\u95ee\u56fe\u4e0a\u4e24\u70b9\u6240\u6709\u8def\u5f84\u4e2d\u6700\u5927\u8fb9\u6743\u7684\u6700\u5c0f\u503c\n\n\u8be2\u95ee\u662f\u4e00\u4e2a\u8001\u95ee\u9898\u4e86\uff0c\u628a\u8fb9\u6309\u6743\u5347\u5e8f\u6392\u5217\uff0c\u7528kruskal\u91cd\u6784\u6811\uff0c\u7b54\u6848\u5373\u4e3a\u6811\u4e0a\u4e24\u70b9lca\u7684\u70b9\u6743\n\n\u8003\u8651\u5982\u4f55\u5efa\u56fe\uff0c\u6211\u4eec\u7528\u4e00\u4e2abfs\u6765\u5efa\u56fe\u5373\u53ef\uff0c\u6bcf\u6b21\u6269\u5c55\u5230\u4e00\u4e2a\u88ab\u5176\u4ed6\u57ce\u5e02\u6269\u5c55\u8fc7\u7684\u70b9\uff0c\u5c31\u52a0\u5165\u4e00\u6761\u8fb9\n\n\u56e0\u4e3a\u4e0d\u77e5\u9053\u6709\u591a\u5c11\u6761\u8fb9\uff0c\u6211\u4eec\u7528vector\u6765\u5b58\u8fb9\uff0c\u6ce8\u610f\u5224\u65ad\u4e24\u70b9\u662f\u5426\u5728\u4e00\u4e2a\u8fde\u901a\u5757\u5185\uff0c\u6ce8\u610f\u8def\u5f84\u538b\u7f29(\u4e0d\u80fd\u76f4\u63a5\u7528fa[x]\u554a)\n\n## Code:\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=4e5+11;\nconst int M=2e3+11;\nconst int dx[]={0,1,-1,0};\nconst int dy[]={1,0,0,-1};\nstruct E{int x,y,val;};\nchar s[M][M];\nint n,m,P,Q,col[M][M],dis[M][M];\nint v[N],rt[N],dep[N],f[N][20];\nint tot,fa[N],block;\nbitset<N> vis;\nqueue<E> q;\nvector<E> edge;\nvector<int> g[N];\ninline bool cmp(E u,E v){return u.val<v.val;}\ninline bool in(int x,int y,int id){\n    if(s[x][y]=='#'||col[x][y]==id) return 0;\n    if(x<1||x>n||y<1||y>m) return 0;\n    return 1;\n}\nint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\nvoid ins(int x,int y){g[x].push_back(y);}\nvoid bfs(){\n    while(!q.empty()){\n        E u=q.front();q.pop();\n        int x=u.x,y=u.y;\n        for(int i=0;i<4;i++){\n            int nx=x+dx[i],ny=y+dy[i];\n            if(!in(nx,ny,col[x][y])) continue;\n            if(col[nx][ny]){\n                int id1=col[x][y],id2=col[nx][ny];\n                int Dis=dis[x][y]+dis[nx][ny];\n                edge.push_back((E){id1,id2,Dis});\n            }else{\n                col[nx][ny]=col[x][y];\n                dis[nx][ny]=dis[x][y]+1;\n                q.push(E{nx,ny,0});\n            }\n        }\n    }\n    sort(edge.begin(),edge.end(),cmp);\n}\nvoid kruskal(){\n    tot=P;\n    for(int i=1;i<=P*2;i++) fa[i]=i;\n    for(int i=0;i<edge.size();i++){\n        int x=edge[i].x,y=edge[i].y;\n        x=find(x),y=find(y);\n        if(x==y) continue;\n        int z=edge[i].val;\n        ++tot;v[tot]=z;\n        ins(x,tot),ins(tot,x);\n        ins(y,tot),ins(tot,y);\n        fa[x]=fa[y]=tot;\n    }\n    for(int i=1;i<=tot;i++) find(i);\n    for(int i=1;i<=tot;i++)\n        if(!vis[fa[i]]) rt[++block]=fa[i],vis[fa[i]]=1;\n}\nvoid dfs(int x){\n    for(int i=0;i<g[x].size();i++){\n        int y=g[x][i];\n        if(y==f[x][0]) continue;\n        f[y][0]=x,dep[y]=dep[x]+1;\n        dfs(y);\n    }\n}\nvoid trans(){\n    for(int i=1;i<=19;i++)\n        for(int j=1;j<=tot;j++)\n            f[j][i]=f[f[j][i-1]][i-1];\n}\nint lca(int x,int y){\n    if(fa[x]!=fa[y]) return 0;\n    if(dep[y]>dep[x]) swap(x,y);\n    for(int i=19;i>=0;i--)\n        if(dep[f[x][i]]>=dep[y]) x=f[x][i];\n    if(x==y) return x;\n    for(int i=19;i>=0;i--)\n        if(f[x][i]!=f[y][i]) x=f[x][i],y=f[y][i];\n    return f[x][0];\n}\nint read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}\n    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}\n    return x*f;\n}\nsigned main(){\n    freopen(\"water.in\",\"r\",stdin);\n    freopen(\"water.out\",\"w\",stdout);\n    n=read(),m=read();\n    P=read(),Q=read();\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",s[i]+1);\n    for(int i=1;i<=P;i++){\n        int x=read(),y=read();\n        col[x][y]=i;\n        q.push((E){x,y,0});\n    }\n    bfs();kruskal();\n    for(int i=1;i<=block;i++) dfs(rt[i]);\n    trans();v[0]=-1;\n    for(int i=1;i<=Q;i++){\n        int x=read(),y=read();\n        printf(\"%d\\n\",v[lca(x,y)]);\n    }\n    return 0;\n}\n```",
        "postTime": 1572405885,
        "uid": 73702,
        "name": "DQYdqy",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT1221 \u3010\u6c34\u7b52\u3011"
    }
]