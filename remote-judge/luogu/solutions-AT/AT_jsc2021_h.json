[
    {
        "content": "\u8fd9\u73a9\u610f\u663e\u7136\u662f\u4e00\u4e2a\u57fa\u73af\u6811\u3002\n\n\u9996\u5148\u8003\u8651\u6811\u4e0a\u7684\u60c5\u51b5\u3002\u4e0d\u96be\u53d1\u73b0 $x \\to y$ \u8def\u5f84\u4e0a\u6240\u6709\u7684\u6811\u8fb9\u90fd\u9700\u8981\u7ecf\u8fc7\u3002\u6811\u4e0a\u5dee\u5206\u5373\u53ef\u3002\n\n\u63a5\u4e0b\u6765\u8003\u8651\u73af\u4e0a\u7684\u60c5\u51b5\u3002\u8bbe\u67d0\u6761\u8def\u5f84\u5728\u73af\u4e0a\u4ece $p \\to q$\uff0c\u5219\u94a6\u5b9a\u73af\u7684\u65b9\u5411\u540e\uff0c\u6211\u4eec\u5b9e\u9645\u4e0a\u6709\u4e24\u79cd\u8d70\u7684\u65b9\u5f0f\uff1a\u6b63\u7740\u8d70\u548c\u53cd\u7740\u8d70\u3002\n\n\u7136\u540e\u5c31\u662f\u4e00\u4e2a~~\u6211\u8fd8\u4e0d\u548b\u4f1a\u7684~~\u7ecf\u5178\u5957\u8def\uff1a\n\n- \u73af\u4e0a\u4e00\u5b9a**\u5b58\u5728**\u4e00\u6761\u8fb9\uff0c\u4f7f\u5f97\u6ca1\u6709\u4efb\u4f55\u4e00\u6761\u8def\u5f84\u7ecf\u8fc7\u3002\n\n\u8bc1\u660e\u662f\u663e\u7136\u7684\uff0c\u56e0\u4e3a\u6211\u4eec\u53ef\u4ee5\u628a\u5176\u4e2d\u4e00\u6761\u8def\u5f84\u6362\u4e00\u4e2a\u65b9\u5411\u4f7f\u5f97\u5c11\u4e00\u6761\u8fb9\u3002\n\n\u4e8e\u662f\u6211\u4eec\u53ef\u4ee5\u8003\u8651\u679a\u4e3e\u4e00\u6761\u8fb9\u4e0d\u8981\uff0c\u7136\u540e\u6bcf\u6761\u8def\u5f84\u7684\u65b9\u5411\u5df2\u7ecf\u56fa\u5b9a\uff0c\u7136\u540e\u5c31\u8f6c\u5316\u6210\u4e86\u533a\u95f4\u8986\u76d6\u95ee\u9898\u3002\u5177\u4f53\u5730\uff0c\u628a\u6240\u6709\u73af\u4e0a\u7684\u533a\u95f4\u79bb\u7ebf\u4e0b\u6765\uff0c\u5728\u533a\u95f4\u7aef\u70b9\u5904\u533a\u95f4 $\\pm 1$\u3002\n\n\u7528\u7ebf\u6bb5\u6811\u7ef4\u62a4\u5373\u53ef\u3002\u8fd9\u91cc\u6211\u7a0d\u5fae\u63d0\u4e00\u4e0b\u4e00\u79cd\u6bd4\u8f83\u7b80\u5355\u7684\u5b9e\u73b0\uff1a\n\n- \u56e0\u4e3a\u6211\u4eec\u7ef4\u62a4\u7684\u533a\u95f4\u8986\u76d6\u6b21\u6570\u65f6\u523b $> 0$\uff0c\u4e8b\u5b9e\u4e0a\u6211\u4eec\u53ef\u4ee5\u4e0d `pushdown`\u3002\n- \u4fee\u6539\u65f6\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u6781\u5927\u88ab\u8986\u76d6\u533a\u95f4\uff0c\u76f4\u63a5\u4ee4\u5176 $cnt \\leftarrow cnt \\pm 1$\u3002\n- \u66f4\u65b0\u65f6\uff0c\u82e5\u5f53\u524d\u533a\u95f4\u88ab\u8986\u76d6\u8fc7\uff0c\u4ee4\u5f53\u524d\u533a\u95f4\u548c\u4e3a\u5176\u6574\u4f53\u533a\u95f4\u548c\uff1b\u5426\u5219\uff0c\u7ee7\u627f\u513f\u5b50\u4fe1\u606f\u3002\n\n\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a $O(n \\log n)$\u3002\u6ce8\u610f\u4e0d\u8981\u5bf9\u53f6\u5b50 `update` \u65f6\u8bbf\u95ee\u5230 $2x, 2x + 1$\u3002\n\n\u4ee3\u7801\uff1a\n```cpp\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef struct {\n\tint nxt;\n\tint end;\n\tint dis;\n} Edge;\n\ntypedef struct {\n\tint l;\n\tint r;\n\tint cnt;\n\tll sum1;\n\tll sum2;\n} Node;\n\nint cnt = 0;\nint root[200007], head[200007], fa[200007][27], up[200007], depth[200007], belong[200007], diff[200007], l[200007], r[200007];\nbool mark[200007];\nEdge edge[400007];\nNode tree[1600007];\npair<int, int> pr[200007];\nvector<pair<int, int> > v[200007];\n\ninline void init(int n){\n\tfor (register int i = 1; i <= n; i++){\n\t\troot[i] = i;\n\t}\n}\n\nint get_root(int x){\n\tif (root[x] == x) return x;\n\treturn root[x] = get_root(root[x]);\n}\n\ninline void add_edge(int start, int end, int dis){\n\tcnt++;\n\tedge[cnt].nxt = head[start];\n\thead[start] = cnt;\n\tedge[cnt].end = end;\n\tedge[cnt].dis = dis;\n}\n\nvoid dfs1(int u, int father){\n\tfa[u][0] = father;\n\tfor (register int i = head[u]; i != 0; i = edge[i].nxt){\n\t\tint x = edge[i].end;\n\t\tif (x != father){\n\t\t\tup[x] = edge[i].dis;\n\t\t\tdfs1(x, u);\n\t\t}\n\t}\n}\n\nvoid dfs2(int u, int father, int cur_belong){\n\tint t;\n\tdepth[u] = depth[father] + 1;\n\tt = log2(depth[u]);\n\tbelong[u] = cur_belong;\n\tfa[u][0] = father;\n\tfor (register int i = 1; i <= t; i++){\n\t\tfa[u][i] = fa[fa[u][i - 1]][i - 1];\n\t}\n\tfor (register int i = head[u]; i != 0; i = edge[i].nxt){\n\t\tint x = edge[i].end;\n\t\tif (x != father && !mark[x]){\n\t\t\tup[x] = edge[i].dis;\n\t\t\tdfs2(x, u, cur_belong);\n\t\t}\n\t}\n}\n\ninline int lca(int u, int v){\n\tif (depth[u] < depth[v]) swap(u, v);\n\twhile (depth[u] > depth[v]) u = fa[u][(int)log2(depth[u] - depth[v])];\n\tif (u == v) return u;\n\tfor (register int i = log2(depth[u]); i >= 0; i--){\n\t\tif (fa[u][i] != fa[v][i]){\n\t\t\tu = fa[u][i];\n\t\t\tv = fa[v][i];\n\t\t}\n\t}\n\treturn fa[u][0];\n}\n\ninline void update1(int x){\n\ttree[x].sum1 = tree[x * 2].sum1 + tree[x * 2 + 1].sum1;\n}\n\nvoid build(int x, int l, int r){\n\ttree[x].l = l;\n\ttree[x].r = r;\n\tif (l == r){\n\t\ttree[x].sum1 = pr[l].second;\n\t\treturn;\n\t}\n\tint mid = (l + r) >> 1;\n\tbuild(x * 2, l, mid);\n\tbuild(x * 2 + 1, mid + 1, r);\n\tupdate1(x);\n}\n\ninline void update2(int x){\n\tif (tree[x].cnt > 0){\n\t\ttree[x].sum2 = tree[x].sum1;\n\t} else if (tree[x].l == tree[x].r){\n\t\ttree[x].sum2 = 0;\n\t} else {\n\t\ttree[x].sum2 = tree[x * 2].sum2 + tree[x * 2 + 1].sum2;\n\t}\n}\n\nvoid add(int x, int l, int r, int k){\n\tif (l > r) return;\n\tif (l <= tree[x].l && tree[x].r <= r){\n\t\ttree[x].cnt += k;\n\t} else {\n\t\tint mid = (tree[x].l + tree[x].r) >> 1;\n\t\tif (l <= mid) add(x * 2, l, r, k);\n\t\tif (r > mid) add(x * 2 + 1, l, r, k);\n\t}\n\tupdate2(x);\n}\n\nll dfs3(int u){\n\tll ans = 0;\n\tfor (register int i = head[u]; i != 0; i = edge[i].nxt){\n\t\tint x = edge[i].end;\n\t\tif (x != fa[u][0] && !mark[x]){\n\t\t\tans += dfs3(x);\n\t\t\tdiff[u] += diff[x];\n\t\t}\n\t}\n\tif (diff[u] > 0) ans += up[u];\n\treturn ans;\n}\n\nint main(){\n\tint n, m, loopu, loopv, loopw, cnt = 0;\n\tll ans = 0x7fffffffffffffffll;\n\tscanf(\"%d %d\", &n, &m);\n\tinit(n);\n\tfor (register int i = 1; i <= n; i++){\n\t\tint a, c, i_root, a_root;\n\t\tscanf(\"%d %d\", &a, &c);\n\t\ti_root = get_root(i);\n\t\ta_root = get_root(a);\n\t\tif (i_root == a_root){\n\t\t\tloopu = i;\n\t\t\tloopv = a;\n\t\t\tloopw = c;\n\t\t} else {\n\t\t\troot[i_root] = a_root;\n\t\t\tadd_edge(i, a, c);\n\t\t\tadd_edge(a, i, c);\n\t\t}\n\t}\n\tdfs1(loopu, 0);\n\twhile (loopv != 0){\n\t\tpr[++cnt] = make_pair(loopv, up[loopv]);\n\t\tmark[loopv] = true;\n\t\tloopv = fa[loopv][0];\n\t}\n\tpr[cnt].second = loopw;\n\tfor (register int i = 1; i <= cnt; i++){\n\t\tup[pr[i].first] = 0;\n\t\tdfs2(pr[i].first, 0, i);\n\t}\n\tbuild(1, 1, cnt);\n\tfor (register int i = 1; i <= m; i++){\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tdiff[x]++;\n\t\tdiff[y]++;\n\t\tif (belong[x] == belong[y]){\n\t\t\tdiff[lca(x, y)] -= 2;\n\t\t} else {\n\t\t\tl[i] = belong[x];\n\t\t\tr[i] = belong[y];\n\t\t\tif (l[i] > r[i]) swap(l[i], r[i]);\n\t\t\tadd(1, l[i], r[i] - 1, 1);\n\t\t\tv[l[i]].push_back(make_pair(i, 1));\n\t\t\tv[r[i]].push_back(make_pair(i, -1));\n\t\t}\n\t}\n\tfor (register int i = 1; i <= cnt; i++){\n\t\tint size = v[i].size();\n\t\tfor (register int j = 0; j < size; j++){\n\t\t\tint x = v[i][j].first;\n\t\t\tif (v[i][j].second == 1){\n\t\t\t\tadd(1, 1, l[x] - 1, 1);\n\t\t\t\tadd(1, r[x], cnt, 1);\n\t\t\t\tadd(1, l[x], r[x] - 1, -1);\n\t\t\t} else {\n\t\t\t\tadd(1, l[x], r[x] - 1, 1);\n\t\t\t\tadd(1, 1, l[x] - 1, -1);\n\t\t\t\tadd(1, r[x], cnt, -1);\n\t\t\t}\n\t\t}\n\t\tans = min(ans, tree[1].sum2);\n\t}\n\tfor (register int i = 1; i <= cnt; i++){\n\t\tans += dfs3(pr[i].first);\n\t}\n\tcout << ans;\n\treturn 0;\n}\n```",
        "postTime": 1677678105,
        "uid": 201007,
        "name": "Leasier",
        "ccfLevel": 8,
        "title": "\u9898\u89e3 [JSC2021] Shipping"
    }
]