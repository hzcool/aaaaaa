[
    {
        "content": "AT1031 Reverse a Road II [Luogu](https://www.luogu.com.cn/problem/AT1031) | [AtCoder](https://atcoder.jp/contests/jag2014autumn/tasks/icpc2014autumn_f)\n\n\u524d\u7f6e\u77e5\u8bc6\uff1a[P3376 \u3010\u6a21\u677f\u3011\u7f51\u7edc\u6700\u5927\u6d41](https://www.luogu.com.cn/problem/P3376)\n\n\u56e0\u4e3a\u6bcf\u6761\u8fb9\u6700\u591a\u53ea\u80fd\u8d70\u4e00\u904d\uff0c\u6240\u4ee5\u5efa\u4e00\u6761\u5bb9\u91cf\u4e3a $1$ \u7684\u8fb9\uff0c\u8dd1\u4e00\u904d\u6700\u5927\u6d41\u3002\n\n\u8003\u8651\u5c06 $s$ \u80fd\u6269\u5c55\u5230\u7684\u8282\u70b9\u6254\u8fdb $\\text{set}_s$\uff0c\u5c06\u80fd\u6269\u5c55\u5230 $t$ \u7684\u8282\u70b9\u6254\u8fdb $\\text{set}_t$\uff0c\u679a\u4e3e\u6b8b\u91cf\u7f51\u7edc\u4e0a\u7684\u8fb9 $e$\uff0c\u5982\u679c $u \\in \\text{set}_t \\land v \\in \\text{set}_s$\uff0c\u90a3\u4e48\u53cd\u8f6c\u8fd9\u6761\u8fb9\u5c31\u80fd\u591f\u6784\u6210\u4e00\u6761 $s \\to t$ \u7684\u5408\u6cd5\u8def\u5f84\uff0c\u7d2f\u52a0 $tot$\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 2022;\nconst int maxm = 20222;\n\nstruct edge { int to, nxt, flow; }  e[maxm];\nint cnt=1, head[maxn], dis[maxn], cur[maxn];\nbool sets[maxn], sett[maxn];\nint n, m, s, t, tot, ans;\n\nvoid add(int u, int v, int w) {\n    e[++cnt] = {v, head[u], w}; head[u] = cnt;\n    e[++cnt] = {u, head[v], 0}; head[v] = cnt;\n}\n\nbool bfs(int s, int t) {\n    memset(dis, 0, sizeof dis);\n    memcpy(cur, head, sizeof head);\n    int x;  queue<int> q;\n    q.push (s); dis[s] = 1;\n    while (!q.empty()) {\n        x = q.front(); q.pop();\n        for (int i = head[x]; i; i = e[i].nxt) {\n            if (e[i].flow && !dis[e[i].to]) {\n                dis[e[i].to] = dis[x] + 1;\n                q.push(e[i].to);\n                if (e[i].to == t) return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint dfs(int x, int flow) {\n    if (x == t) return flow;\n    int rest = flow; int i;\n    for (i = cur[x]; i; i = e[i].nxt) {\n        if (e[i].flow && dis[e[i].to] == dis[x] + 1) {\n            int k = dfs(e[i].to, min(rest, (int)e[i].flow));\n            if (!k) dis[e[i].to] = -1;\n            e[ i ].flow -= k;\n            e[i^1].flow += k;\n            if (!(rest -= k)) break;\n        }\n    }\n    cur[x] = i;\n    return flow - rest;\n}\n\nint Dinic() {\n    int maxflow = 0;\n    while (bfs (s, t))\n        maxflow += dfs(s, INT_MAX);\n    return maxflow;\n}\n\nvoid calc() {\n    queue<int> q;\n    q.push(s); sets[s] = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; i; i = e[i].nxt) {\n            int v = e[i].to;\n            if (!sets[v] && e[i].flow) {\n                sets[v] = 1, q.push(v);\n            }\n        }\n    }\n    q.push(t); sett[t] = 1;\n    while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (int i = head[u]; i; i = e[i].nxt) {\n            int v = e[i].to;\n            if (!sett[v] && !e[i].flow) {\n                sett[v] = 1, q.push(v);\n            }\n        }\n    }\n    for (int i = 2; i <= cnt; i += 2) {\n        int u = e[i^1].to, v = e[i].to;\n        if (e[i].flow && sets[v] && sett[u]) tot++;\n    }\n    if (tot) ans++;\n}\n\nvoid clear() {\n    cnt = 1; ans = tot = 0;\n    memset(head, 0, sizeof head);\n    memset(sets, 0, sizeof sets);\n    memset(sett, 0, sizeof sett);\n}\n\nint main() {\n    while(1) {\n        scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n        if (!n && !m && !s && !t) return 0;\n        clear();\n        for (int i = 1; i <= m; i++) {\n            int u, v; scanf(\"%d %d\", &u, &v);\n            add(u, v, 1);\n        }\n        ans = Dinic(), calc();\n        printf(\"%d %d\\n\", ans, tot);\n    }\n}\n```\n\n",
        "postTime": 1663894072,
        "uid": 581312,
        "name": "zerc",
        "ccfLevel": 4,
        "title": "\u9898\u89e3 AT1031 Reverse a Road II"
    }
]