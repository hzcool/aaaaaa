[
    {
        "content": "\u554f\u984c\u6982\u8981\n\n\u6a21\u62df\u5806\u6808\u7684\u95ee\u9898\u3002\n\u4f46\u662f\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e00\u6761\u6307\u4ee4\u63d2\u5165\u5f88\u591a\u76f8\u540c\u7684\u6570\u5b57\u6216\u5f39\u51fa\u5f88\u591a\u3002\n\u6b64\u5916\uff0c\u56de\u7b54\u5806\u6808\u4e2d\u6570\u5b57\u6570\u91cf\u548c\u5806\u6808\u9876\u90e8\u5143\u7d20\u7684\u67e5\u8be2\u662f\u6df7\u5408\u7684\u3002\n\u53e6\u5916\uff0c\u6808\u7684\u5927\u5c0f\u662f\u56fa\u5b9a\u7684\uff0c\u5982\u679c\u8d85\u51fa\u5927\u5c0f\uff0c\u6216\u8005\u4ece\u7a7a\u6808\u4e2d\u5f39\u51fa\u6216\u8005\u5f15\u7528\u6808\u9876\u5143\u7d20\uff0c\u5c31\u4f1a\u62a5\u9519\u5e76\u505c\u6b62\u3002\n\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u95ee\u9898\u6587\u672c\u3002\n\n\u89e3\u6cd5\n\n\u53ea\u505a\u6a21\u62df\u3002\n\u52a0\u591a\u4e86\uff0c\u4e00\u4e2a\u4e00\u4e2a\u505a\u5c31\u662fTLE\u3002\n\u6ce8\u610f\u6ea2\u51fa\uff0c\u56e0\u4e3a\u5806\u6808\u7684\u5927\u5c0f\u8fbe\u5230\u4e86\u53ef\u4ee5\u7528\u5e26\u7b26\u53f7\u7684 32 \u4f4d\u6574\u6570\u8868\u793a\u7684\u9650\u5236\u3002\uff08\u4f7f\u7528 64 \u4f4d\u6574\u6570\u66f4\u5bb9\u6613\uff0c\u4e0d\u7528\u62c5\u5fc3\u3002\uff09\n\n\nC++\u6e90\u4ee3\u7801\uff1a\n```c\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<algorithm>\n#include<string>\n#include<utility>\n#include<iostream>\n#include<cmath>\n#include<cassert>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define ll long long\n\nll read_int(ll mn, ll mx, char next){\n  ll c, fg = 1, res = 0;\n  c=getchar();\n  if(c=='-') fg = -1, c = getchar();\n  assert('0'<=c && c<='9');\n  res = c - '0';\n  for(;;){\n    c = getchar();\n    if(c==next) break;\n    assert(res!=0);\n    assert('0'<=c && c<='9');\n    res = res * 10 + (c - '0');\n  }\n  res *= fg;\n  assert(mn<=res && res<=mx);\n  return res;\n}\n\nstring read_string(int mx_len, char *next){\n  int c;\n  string res;\n\n  for(;;){\n    c = getchar();\n    if(c==' ' || c=='\\n'){ *next = c; break; }\n    assert(c != EOF);\n    res += c;\n    assert( res.size() <= mx_len );\n  }\n\n  return res;\n}\n\n\nint main(){\n  int Q; ll L;\n\n  int i, j, k;\n  static int st[100000], num[100000]; int depth; ll size;\n  string query;\n  int N, M;\n  int fin = 0;\n  char c;\n\n  Q = read_int(1, 100000, ' ');\n  L = read_int(1, 2147483647, '\\n');\n\n  depth = size = 0;\n\n  while(Q--){\n    query = read_string(10, &c);\n    if(query == \"Push\"){\n      assert(c == ' ');\n      N = read_int(1, 100000, ' ');\n      M = read_int(-(1<<20), 1<<20, '\\n');\n      if(fin) continue;\n      if(size + N > L){ fin = 2; continue; }\n      st[depth] = M;\n      num[depth] = N;\n      size += N;\n      depth++;\n    } else if(query == \"Pop\"){\n      assert(c == ' ');\n      N = read_int(1, 100000, '\\n');\n      if(fin) continue;\n      if(size < N){ fin = 1; continue; }\n      size -= N;\n      while(N && num[depth-1] <= N){\n        N -= num[depth-1];\n        depth--;\n      }\n      if(N) num[depth-1] -= N;\n    } else if(query == \"Top\"){\n      assert(c == '\\n');\n      if(fin) continue;\n      if(size==0){ fin=1; continue; }\n      printf(\"%d\\n\",st[depth-1]);\n    } else if(query == \"Size\"){\n      assert(c == '\\n');\n      if(fin) continue;\n      printf(\"%d\\n\", size);\n    } else {\n      assert(0);\n    }\n  }\n\n  if(fin==0) puts(\"SAFE\");\n  if(fin==1) puts(\"EMPTY\");\n  if(fin==2) puts(\"FULL\");\n\n  {\n    char c;\n    assert( scanf(\"%c\",&c)!= 1 );\n  }\n  return 0;\n}\n```\n\n\n  \n  \n  \n  \u5b8c\uff01",
        "postTime": 1660093111,
        "uid": 765457,
        "name": "fourGS",
        "ccfLevel": 0,
        "title": "\u9898\u89e3"
    }
]