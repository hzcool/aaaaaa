[
    {
        "content": "\u9996\u5148\u663e\u7136\u53ef\u4ee5\u60f3\u5230\u66b4\u529b\u5efa\u51fa\u4e8c\u5206\u56fe\u4e4b\u540e\u8dd1\u8d39\u7528\u6d41\uff0c\u4f46\u662f\u8fb9\u6570\u6709$O(n^2)$\u6761\uff0c\u6bd4\u8f83\u7206\u70b8\uff0c\u8003\u8651\u4f18\u5316\u3002\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u66fc\u54c8\u987f\u8ddd\u79bb\u6709\u4e00\u4e2a\u975e\u5e38\u597d\u7684\u6027\u8d28\uff0c\u5c31\u662f\u628a\u7edd\u5bf9\u503c\u62c6\u5f00\uff0c\u4e00\u5171\u6709\u56db\u79cd\u60c5\u51b5\uff0c\u8fd9\u56db\u79cd\u60c5\u51b5\u7684\u6700\u5927\u503c\u4e00\u5b9a\u662f\u8fd9\u4e2a\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u503c\u3002\n\n\u5177\u4f53\u5730\u8bf4\uff0c\u5c31\u662f\uff1a\n$$\n|x_1-x_2|+|y_1-y_2|=max\\{ \nx_1-x_2+y_1-y_2,\nx_1-x_2-y_1+y_2,\n-x_1+x_2+y_1-y_2,\n-x_1+x_2-y_1+y_2\n\\}\n$$\n\u90a3\u4e48\u53ef\u4ee5\u5c06\u4e24\u4e2a\u70b9\u72ec\u7acb\u5730\u6765\u770b\uff0c\u4e5f\u5c31\u662f\uff1a\n$$\n|x_1-x_2|+|y_1-y_2|=max\\{\n(x_1+y_1)+(-x_2-y_2),\n(x_1-y_1)+(-x_2+y_2),\n(-x_1+y_1)+(x_2-y_2),\n(-x_1-y_1)+(x_2+y_2)\n\\}\n$$\n\u90a3\u4e48\u65e2\u7136\u53ef\u4ee5\u62c6\u5f00\u6765\u770b\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u4e0d\u7528\u4e24\u4e24\u8fde\u8fb9\u4e86\uff0c\u5728\u5de6\u53f3\u4e24\u6392\u70b9\u4e2d\u95f4\u5f00$4$\u4e2a\u65b0\u70b9\uff0c\u7136\u540e\u4ece\u5de6\u8fb9\u5230\u5b83\uff0c\u4ece\u5b83\u5230\u5de6\u8fb9\u5206\u522b\u8fde\u4e0a$4$\u79cd\u8fb9\uff08\u8bb0\u5f97\u6309\u987a\u5e8f\uff09\uff0c\u7136\u540e\u76f4\u63a5\u8dd1\u8d39\u7528\u6d41\u5373\u53ef\uff0c\u8fb9\u6570\u88ab\u964d\u5230$O(n)$\u7ea7\u522b\u3001\n\n**\u4f46\u662f\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u66fc\u54c8\u987f\u8ddd\u79bb\u8fd9\u4e2a\u6027\u8d28\u4e0d\u9002\u7528\u4e8e\u6700\u5c0f\u503c**\u3002\n\ncode\uff1a\n```cpp\n#include<bits/stdc++.h>\n#define maxn 1010\n#define inf 1000000007\nusing namespace std;\ntypedef long long ll;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,p1,p2,p3,p4,s,t;\nint head[maxn*2],nxt[maxn*20],to[maxn*20],c[maxn*20],v[maxn*20],tot=1;\nvoid add(int x,int y,int z,int u)\n{\n    ++tot;\n    nxt[tot]=head[x];\n    head[x]=tot;\n    to[tot]=y;\n    c[tot]=z;\n    v[tot]=u;\n}\nvoid addx(int x,int y,int z,int u)\n{\n    add(x,y,z,u);\n    add(y,x,0,-u);\n}\nll ans;\nll dis[maxn*2];\nint pre[maxn*2],pre_num[maxn*2],vis[maxn*2];\nqueue<int>q;\nint spfa()\n{\n    for(int i=1;i<=t;i++)  dis[i]=-1e16;\n    q.push(s);dis[s]=0;vis[s]=1;\n    while(q.size())\n    {\n        int now=q.front();q.pop();vis[now]=0;\n        for(int i=head[now];i;i=nxt[i])\n        {\n            if(dis[to[i]]<dis[now]+v[i]&&c[i])\n            {\n                dis[to[i]]=dis[now]+v[i];\n                pre[to[i]]=now;\n                pre_num[to[i]]=i;\n                if(!vis[to[i]])  q.push(to[i]),vis[to[i]]=1;\n            }\n        }\n    }\n    if(dis[t]==-1e16)  return 0;\n    int di=inf;\n    for(int i=t;i!=s;i=pre[i])  di=min(di,c[pre_num[i]]);\n    for(int i=t;i!=s;i=pre[i])  c[pre_num[i]]-=di,c[pre_num[i]^1]+=di;\n    ans+=dis[t]*di;\n    return di;\n}\nint main()\n{\n    n=read();p1=2*n+1;p2=p1+1;p3=p2+1;p4=p3+1;s=p4+1;t=s+1;\n    for(int i=1;i<=n;i++)\n    {\n        int x=read(),y=read(),z=read();\n        addx(s,i,z,0);\n        addx(i,p1,inf,x+y);\n        addx(i,p2,inf,x-y);\n        addx(i,p3,inf,-x+y);\n        addx(i,p4,inf,-x-y);\n    }\n    for(int i=1;i<=n;i++)\n    {\n        int x=read(),y=read(),z=read();\n        addx(i+n,t,z,0);\n        addx(p1,i+n,inf,-x-y);\n        addx(p2,i+n,inf,-x+y);\n        addx(p3,i+n,inf,x-y);\n        addx(p4,i+n,inf,x+y);\n    }\n    while(spfa()){};\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n```",
        "postTime": 1583131436,
        "uid": 46396,
        "name": "justin_cao",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 AT4994 \u3010[AGC034D] Manhattan Max Matching\u3011"
    },
    {
        "content": "\u663e\u7136\u7ea2\u7403\u53ea\u80fd\u5339\u914d\u84dd\u7403\uff0c\u6240\u4ee5\u8bf4\u8fd9\u662f\u4e00\u4e2a\u4e8c\u5206\u56fe\u5e26\u6743\u5339\u914d\u4ee5\u53ca\u6709\u6d41\u91cf\u9650\u5236\uff08\u5176\u5b9e\u4e5f\u53ef\u4ee5\u62c6\u5f00\u5176\u5b9e\u4e00\u6837\uff0c\u53cd\u6b63\u53ea\u6709 $10$\uff09\uff0c\u8003\u8651\u8d39\u7528\u6d41\u3002\n\n\u56e0\u4e3a $n \\leq 10^3$ \u652f\u6491\u4e0d\u4e86 $O(n^2)$ \u7ea7\u522b\u7684\u8fb9\u6570\u3002\u6240\u4ee5\u8bf4\u8003\u8651\u4f18\u5316\u3002\n\n\u601d\u8003\u4e00\u4e0b\u4e00\u822c\u7684\u4e8c\u5206\u56fe\u5e26\u6743\u5339\u914d\uff0c\u6211\u4eec\u7684\u4f18\u5316\u662f\u52a0\u4e00\u4e2a\u4e2d\u8f6c\u70b9\u3002\u539f\u56e0\u662f\u6211\u4eec\u4e0d\u9700\u8981\u77e5\u9053\u5230\u5e95\u8c01\u8fde\u7684\u662f\u8c01\uff0c\u53ea\u9700\u8981\u5bf9\u5e94\u7684\u52a0\u4e0a\u8d21\u732e\u5373\u53ef\u3002\n\n\u518d\u8fd4\u56de\u6765\u770b\u8fd9\u4e2a\u9898\uff0c\u663e\u7136\u6211\u4eec\u4e0d\u80fd\u51ed\u501f\u4e00\u4e2a\u4e2d\u8f6c\u70b9\u5c31\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u56e0\u4e3a\u53ef\u80fd\u4f60\u9009\u7684\u4e24\u4e2a\u70b9\u6240\u52a0\u4e0a\u7684\u8d21\u732e\u4e0d\u662f\u8fd9\u4e2a\u4e1c\u897f\u3002\u8003\u8651\u4e00\u4e0b\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6027\u8d28\u3002\n\n\u66fc\u54c8\u987f\u8ddd\u79bb\u5b9a\u4e49\uff1a\u7ed9\u5b9a\u4e24\u4e2a\u70b9 $A,B$\uff0c\u4e24\u70b9\u95f4\u7684\u66fc\u54c8\u987f\u8ddd\u79bb $dis(A,B)$ \u4e3a\uff1a\n\n$$\ndis(A,B) = |x_A - x_B| + |y_A - y_B|\n$$\n\n\u8003\u8651\u5c06\u8fd9\u4e2a\u7edd\u5bf9\u503c\u51fd\u6570\u62c6\u5f00\uff08\u8bf7\u81ea\u884c\u79fb\u9879\uff09\uff0c\u5f97\u5230\uff1a\n\n$$\ndis(A,B)=\n\\begin{cases}\n(x_A+y_A) - (x_B+y_B),x_A \\geq x_B \u2227 y_A \\geq y_B\\\\\n(-x_A+y_A) - (-x_B+y_B),x_A \\leq x_B \u2227 y_A \\geq y_B\\\\\n(x_A-y_A) - (x_B-y_B),x_A \\geq x_B \u2227 y_A \\leq y_B\\\\\n(-x_A-y_A) - (-x_B-y_B),x_A \\leq x_B \u2227 y_A \\leq y_B\\\\\n\\end{cases}\n$$\n\n\u53ef\u4ee5\u53d1\u73b0\uff0c\u6bcf\u4e00\u79cd\u60c5\u51b5\u91cc\u9762\u7684\u62ec\u53f7\u91cc\u9762\u7684\u5f62\u5f0f\u90fd\u8ddf\u53e6\u5916\u4e00\u4e2a\u62ec\u53f7\u5185\u7684\u5f62\u5f0f\u7c7b\u4f3c\uff0c\u5e76\u4e14\u53ea\u8ddf\u4e00\u4e2a\u70b9\u6709\u5173\uff0c\u5c31\u53ef\u4ee5\u66f4\u65b9\u4fbf\u5730\u52a0\u8fb9\u5e76\u4e14\u4f7f\u5f97\u4e0a\u9762\u7684\u95ee\u9898\u89e3\u51b3\u3002\u4e8e\u662f\u65b0\u5f00 $4$ \u4e2a\u70b9\uff0c\u5206\u522b\u5bf9\u5e94\u4e0a\u9762\u7684\u60c5\u51b5\uff0c\u5bf9\u5e94\u8fde\u8fb9\u5373\u53ef\u3002\u5177\u4f53\u53ef\u4ee5\u770b\u4ee3\u7801\u3002\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL n,cnt=1,s,t,to[3000005],val[3000005],siz[2021],nxt[3000005],cst[3000005],ntw[2021],lid[2021],pre[2021],dis[2021];\nbool vis[2021];\nvoid addEdge(LL u,LL v,LL w,LL x)\n{\n\t++cnt;\n\tto[cnt]=v;\n\tval[cnt]=w;\n\tcst[cnt]=x;\n\tnxt[cnt]=siz[u];\n\tsiz[u]=cnt;\n\tswap(u,v);\n\tw=0,x=-x;\n\t++cnt;\n\tto[cnt]=v;\n\tval[cnt]=w;\n\tcst[cnt]=x;\n\tnxt[cnt]=siz[u];\n\tsiz[u]=cnt;\n}\nbool bfs(LL p)\n{\n\tmemset(dis,63,sizeof dis);\n\tqueue<LL> Q;\n\tQ.push(p);\n\tntw[p]=2e8;\n\tdis[p]=0;\n\twhile(!Q.empty())\n\t{\n\t\tLL now=Q.front();\n\t\tQ.pop();\n\t\tvis[now]=false;\n\t\tfor(LL i=siz[now];i;i=nxt[i])\n\t\t{\n\t\t\tif(val[i] && cst[i]+dis[now]<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=cst[i]+dis[now];\n\t\t\t\tif(!vis[to[i]])\tQ.push(to[i]),vis[to[i]]=true;\n\t\t\t\tntw[to[i]]=min(val[i],ntw[now]);\n\t\t\t\tlid[to[i]]=i;\n\t\t\t\tpre[to[i]]=now;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[0]!=dis[t];\n}\nstruct Ball{\n\tLL x,y,c;\n\tBall(LL X=0,LL Y=0,LL C=0){x=X,y=Y,c=C;}\n}a[1005],b[1005];\nLL Abs(LL x){return x>0?x:-x;}\nLL dist_mht(Ball x,Ball y){return Abs(x.x-y.x)+Abs(x.y-y.y);}\nLL ts[5];\nLL vec1[]={0,1,-1,1,-1},vec2[]={0,1,1,-1,-1};\nint main(){\n\tscanf(\"%lld\",&n);\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tLL x,y,c;\n\t\tscanf(\"%lld %lld %lld\",&x,&y,&c);\n\t\ta[i]=Ball(x,y,c);\n\t}\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\tLL x,y,c;\n\t\tscanf(\"%lld %lld %lld\",&x,&y,&c);\n\t\tb[i]=Ball(x,y,c);\n\t}\n\ts=2*n+1,t=s+1;\n\tts[1]=t+1;\n\tts[2]=ts[1]+1;\n\tts[3]=ts[2]+1;\n\tts[4]=ts[3]+1;\n\tfor(LL i=1;i<=n;++i)\n\t{\n\t\taddEdge(s,i,a[i].c,0);\n\t\taddEdge(i+n,t,b[i].c,0);\n\t\tfor(LL j=1;j<=4;++j)\n\t\t{\n\t\t\tLL vl=a[i].x*vec1[j]+a[i].y*vec2[j];\n\t\t\taddEdge(i,ts[j],1e7,-vl);\n\t\t}\n\t\tfor(LL j=1;j<=4;++j)\n\t\t{\n\t\t\tLL vl=b[i].x*vec1[j]+b[i].y*vec2[j];\n\t\t\taddEdge(ts[j],i+n,1e7,vl);\n\t\t}\n\t}\n\tLL cost=0;\n\twhile(bfs(s))\n\t{\n\t\tcost+=ntw[t]*dis[t];\n\t\tint now=t;\n\t\twhile(now!=s)\n\t\t{\n\t\t\tval[lid[now]]-=ntw[t];\n\t\t\tval[lid[now]^1]+=ntw[t];\n\t\t\tnow=pre[now];\n\t\t}\n\t}\n\tprintf(\"%lld\",-cost);\n\treturn 0;\n}\n```",
        "postTime": 1610174504,
        "uid": 184977,
        "name": "pomelo_nene",
        "ccfLevel": 9,
        "title": "\u9898\u89e3 AT4994 \u3010[AGC034D] Manhattan Max Matching\u3011"
    },
    {
        "content": "## \u9898\u610f\n\u6709 $N$ \u4e2a\u70b9\u4e0a\u9762\u6709\u82e5\u5e72\u4e2a\u84dd\u7403\uff0c\u6709 $N$ \u4e2a\u70b9\u4e0a\u9762\u6709\u82e5\u5e72\u4e2a\u7ea2\u7403\u3002\n\n\u4fdd\u8bc1\u84dd\u7403\u548c\u7ea2\u7403\u7684\u6570\u91cf\u4e00\u6837\u3002\n\n\u6bcf\u4e2a\u84dd\u7403\u548c\u7ea2\u7403\u5339\u914d\u7684\u4ef7\u503c\u662f\u66fc\u54c8\u987f\u8ddd\u79bb\uff0c\u6c42\u6700\u5927\u7684\u5339\u914d\u4ef7\u503c\u3002\n\n$N \\leq 10^3$\n\n## \u9898\u89e3\n\u5f88\u7ecf\u5178\u7684\u62c6\u7b26\u53f7\u3002\n\n$\\texttt{distance(i,j)} = \\max\\{x_i-x_j+y_i-y_j,x_j-x_i+y_i-y_j,x_i-x_j+y_j-y_i,x_j-x_i+y_j-y_i\\}$\n\n\u53d1\u73b0 $x_i$ \u548c $x_j$ \u5f02\u53f7\uff0c\u6240\u4ee5\u6211\u4eec\u5c31\u53ef\u4ee5\u76f4\u63a5\u679a\u4e3e\u4e00\u4e2a\u72b6\u6001 $h$\uff0c\u5982\u679c $i$ \u9009\u4e86 $h$ \u8fd9\u4e2a\u72b6\u6001\uff0c\u90a3\u4e48 $j$ \u9700\u8981\u9009 $h_i \\oplus 3$ \u8fd9\u4e2a\u72b6\u6001\uff08\u5c31\u662f\u7b26\u53f7\u4f4d\u53d6\u53cd\uff09\uff0c\u8fd9\u5bb9\u6613\u53d1\u73b0\u548c\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u662f\u4e00\u6837\u7684\uff0c\u53ea\u662f\u7528\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u4f1a\u8dd1\u51fa\u4e00\u4e2a\u8d1f\u6570\uff08\u4e5f\u5c31\u662f\u6bcf\u6b21\u9009\u7684\u90fd\u662f $-\\texttt{distance(i,j)}$\uff09\uff0c\u6240\u4ee5\u6211\u4eec\u6700\u540e\u8981\u8f93\u51fa \u6700\u5c0f\u8d39\u7528 $\\times (-1)$\u3002\n\n\u8fd8\u6bd4\u8f83\u597d\u5199\u3002\n\n```cpp\n#include <bits/stdc++.h>\n#define rep(i, x, y) for (int i = x; i < y; i++)\n#define all(v) begin(v), end(v)\nusing namespace std;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<class T>\nistream &operator>> (istream &in, vector<T> &v) {\n for (auto &x : v) {\n  in >> x;\n }\n return in;\n}\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\nnamespace Flow {\n#define int long long\nint S, T;\nvoid Set(int _S, int _T) { S = _S, T = _T; }\nstruct Edge_t {\n\tint v, nxt, w, cost;\n\tEdge_t(int V = 0, int Nxt = 0, int W = 0, int Cost = 0) {\n\t\tv = V, nxt = Nxt, w = W, cost = Cost;\n\t}\n};\nstd::vector<Edge_t> e(2);\nstd::vector<int> head;\nvoid add(int u, int v, int w, int cost) {\n\tif (u >= (int)head.size()) {\n\t\thead.resize(u + 127);\n\t}\n\te.emplace_back(v, head[u], w, cost);\n\thead[u] = (int)e.size() - 1;\n}\nvoid addedge(int u, int v, int w, int cost) {\n\tadd(u, v, w, cost);\n\tadd(v, u, 0, -cost);\n}\nconstexpr long long inf = 1e18;\nstd::queue<int> q;\nstd::vector<int> dep;\nstd::vector<int> cur;\nstd::vector<bool> inq;\nbool bfs() {\n\tdep.assign(head.size(), inf);\n\tinq.assign(head.size(), false);\n\tcur = head;\n\tq.emplace(S), dep[S] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); inq[u] = false;\n\t\tfor (int i = head[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && dep[v] > dep[u] + e[i].cost) {\n\t\t\t\tdep[v] = dep[u] + e[i].cost;\n\t\t\t\tif (!inq[v]) {\n\t\t\t\t\tinq[v] = true;\n\t\t\t\t\tq.emplace(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T] < inf;\n}\nint dfs(int u, int flow) {\n\tif (!flow) {\n\t\treturn 0;\n\t} else if (u == T) {\n\t\treturn flow;\n\t} else {\n\t\tinq[u] = true;\n\t\tint f = 0;\n\t\tfor (int &i = cur[u], rf; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (!inq[v] && dep[v] == dep[u] + e[i].cost && (rf = dfs(v, std::min(flow, e[i].w)))) {\n\t\t\t\tflow -= rf, f += rf;\n\t\t\t\te[i].w -= rf, e[i ^ 1].w += rf;\n\t\t\t\tif (flow == 0) {\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n}\nstd::pair<int, int> dinic() {\n\tint ans = 0, res = 0;\n\twhile (bfs()) {\n\t\tint tmp = dfs(S, inf);\n\t\tans += tmp;\n\t\tres += dep[T] * tmp;\n\t}\n\treturn std::make_pair(ans, res);\n}\n#undef int\n}\nusing namespace Flow;\nint main() {\n cin.tie(nullptr)->sync_with_stdio(false);\n int n;\n cin >> n;\n int tot=0;\n int s=++tot;\n int t=++tot;\n vector<int>p(4);\n for(auto&x:p)x=++tot; \n Set(s,t);\n rep(i,0,n){\n  int x,y,k;\n  cin>>x>>y>>k;\n  ++tot;\n  addedge(s,tot,k,0);\n  rep(h,0,4){\n   int xx=(h&1)?x:-x;\n   int yy=(h&2)?y:-y;\n   addedge(tot,p[h],inf,xx+yy);\n  }\n }\n rep(i,0,n){\n  int x,y,k;\n  cin>>x>>y>>k;\n  ++tot;\n  addedge(tot,t,k,0);\n  rep(h,0,4){\n   int xx=(h&1)?-x:x;\n   int yy=(h&2)?-y:y;\n   addedge(p[h],tot,inf,xx+yy);\n  }\n }\n cout<<-dinic().second<<\"\\n\";\n}\n```",
        "postTime": 1630672494,
        "uid": 96580,
        "name": "SXNhdW5veWE",
        "ccfLevel": 7,
        "title": "AT4994 [AGC034D] Manhattan Max Matching"
    },
    {
        "content": "\u8003\u573a\u7684\u4e00\u9053\u9898\uff0c\u6ca1\u6ce8\u610f\u5230 $O(n ^ 2)$ \u5efa\u56fe\u4f1a\u6302\u6240\u4ee5\u4ee5\u4e3a\u662f\u4e00\u9053\u6c34\u9898\u5c31\u76f4\u63a5\u83bd\u8fc7\u53bb\u4e86\uff0c\u8003\u540e\u5f00\u59cb\u540e\u6094\u2026\u2026      \n\n$O(n ^ 2)$ \u5efa\u56fe\u5f88\u6c34\uff0c\u5c31\u4e0d\u8bf4\u4e86\uff0c\u5c3d\u7ba1\u7f51\u7edc\u6d41\u65f6\u95f4\u590d\u6742\u5ea6\u5f88\u7384\u5b66\uff0c\u4f46\u662f~~\u8279~~ $1e6$ \u7684\u8fb9\u6570\u636e\u4e0d\u5f97\u4e0d\u8bf4\u8fd8\u662f\u5f88\u56f0\u96be\u2026\u2026      \n\n\u6240\u4ee5\u8003\u8651\u66fc\u54c8\u987f\u8ddd\u79bb\u7684\u6027\u8d28\uff0c\u8bb0\u5f97\u4e4b\u524d\u5de8\u4f6c $CLJ$ \u8fd8\u7ed9\u6211\u8bb2\u8fc7\u8fd9\u73a9\u610f\u513f\u53ef\u4ee5\u62ff\u6765\u62c6 $max$ \u81ea\u5df1\u8fd8\u6ca1\u53bb\u60f3\u2026\u2026      \n\n\u6211\u4eec\u9996\u5148\u89c2\u5bdf\u5f0f\u5b50 $|x_1 - x_2| + |y_1 - y_2|$ \u3002     \n\n\u6839\u636e\u7edd\u5bf9\u503c\u6027\u8d28\uff0c\u5982\u679c\u6211\u4eec\u8bef\u628a\u5176\u4e2d\u4e00\u9879\u7b97\u6210\u8d1f\u6570\uff0c\u90a3\u4e48\u6574\u4f53\u503c\u5c31\u4f1a\u53d8\u5c0f\uff0c\u6240\u4ee5\u8bf4\u6211\u4eec\u53ea\u8981\u5206\u7c7b\u8ba8\u8bba\u4e00\u4e0b\u51e0\u79cd\u60c5\u51b5\u7136\u540e\u53d6 $max$ \u5373\u53ef\uff1a     \n\n- $|x_1 - x_2| + |y_1 - y_2| = max(x_1 - x_2 + y_1 - y_2 ,x_2 - x_1 + y_1 - y_2,x_1 - x_2 + y_2 - y_1,x_2 - x_1 + y_2 - y_1)$      \n\n\u5f00\u56db\u4e2a\u70b9\u8868\u793a\u8fd9\u56db\u79cd\u8fde\u8fb9\uff0c$x_1,y_1$ \u9879\u548c $x_2,y_2$ \u9879\u5206\u522b\u653e\u5728\u56db\u4e2a\u70b9\u7684\u5de6\u53f3\u4e24\u8fb9\uff0c\u8fd9\u6837\u53d8\u7684\u4e2a\u6570\u5c31\u88ab\u4f18\u5316\u5230\u4e86 $8n$ \u6761\uff0c\u800c\u6839\u636e\u8d39\u7528\u6d41\u6027\u8d28\uff0c\u6211\u4eec\u80af\u5b9a\u4f1a\u9009\u53d6\u6700\u957f\u7684\u4e00\u6761\u8fb9\uff0c\u5373\u81ea\u52a8\u6267\u884c $max$ \u64cd\u4f5c\u3002      \n\n\u63a5\u7740\u8dd1\u6700\u5927\u8d39\u7528\u6d41\u3002     \n\n```cpp\n#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define int long long\nconst int Len = 1e4 + 5,Inf = 1e18;\nbool vis[Len];\nint n,m,cnt = 1,head[Len],dis[Len],pre[Len],aug[Len],mincost,maxflow,p[15],s,t;\nstruct node\n{\n\tint next,to,flow,w;\n}edge[Len << 1];\nvoid add(int from,int to,int flow,int w)\n{\n\tedge[++ cnt].to = to;\n\tedge[cnt].next = head[from];\n\tedge[cnt].flow = flow;\n\tedge[cnt].w = -w;\n\thead[from] = cnt;\t\n}\nbool SPFA()\n{\n\tqueue<int> q;\n\tmemset(aug , 0 , sizeof aug);\n\tmemset(vis , 0 , sizeof vis);\n\tfor(int i = 1 ; i <= t ; i ++) dis[i] = Inf;\n\tdis[s] = 0 , vis[s] = 1 , aug[s] = Inf;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint p = q.front() ; q.pop();\n\t\tvis[p] = 0;\n\t\tfor(int e = head[p] ; e ; e = edge[e].next)\n\t\t{\n\t\t\tint to = edge[e].to;\n\t\t\tif(dis[to] > dis[p] + edge[e].w && edge[e].flow)\n\t\t\t{\n\t\t\t\tdis[to] = dis[p] + edge[e].w;\n\t\t\t\tpre[to] = e;\n\t\t\t\taug[to] = min(aug[p] , edge[e].flow);\n\t\t\t\tif(!vis[to]) q.push(to) , vis[to] ^= 1;\n\t\t\t} \n\t\t}\n\t}\n\tif(dis[t] == Inf) return 0; \n\treturn 1;\n}\nvoid E_K()\n{\n\tmincost = maxflow = 0;\n\twhile(SPFA())\n\t{\n\t\tint x = t , E;\n\t\tmaxflow += aug[t];\n\t\tmincost += aug[t] * dis[t];\n\t\twhile(x != s)\n\t\t{\n\t\t\tE = pre[x];\n\t\t\tedge[E].flow -= aug[t];\n\t\t\tedge[E ^ 1].flow += aug[t];\n\t\t\tx = edge[E ^ 1].to;\t\n\t\t}\t\n\t}\n}\nsigned main()\n{\n\tscanf(\"%lld\",&n);\n\tp[1] = (n << 1) + 1;for(int i = 2 ; i <= 4 ; i ++) p[i] = p[i - 1] + 1;\n\ts = p[4] + 1 , t = s + 1;\n\tfor(int i = 1 ; i <= n ; i ++)\n\t{\n\t\tint x,y,z;\n\t\tscanf(\"%lld %lld %lld\",&x,&y,&z);\n\t\tadd(s , i , z , 0) , add(i , s , 0 , 0);\n\t\tadd(i , p[1] , Inf , x + y) , add(p[1] , i , 0 , -(x + y));\n\t\tadd(i , p[2] , Inf , x - y) , add(p[2] , i , 0 , -(x - y));\n\t\tadd(i , p[3] , Inf , -x + y) , add(p[3] , i , 0 , x - y);\n\t\tadd(i , p[4] , Inf , -x - y) , add(p[4] , i , 0 , x + y);\n\t}\n\tfor(int i = 1 ; i <= n ; i ++)\n\t{\n\t\tint x,y,z;scanf(\"%lld %lld %lld\",&x,&y,&z);\n\t\tadd(i + n , t , z , 0) , add(t , i + n , 0 , 0);\n\t\tadd(p[1] , i + n , Inf , -x - y) , add(i + n , p[1] , 0 , x + y);\n\t\tadd(p[2] , i + n , Inf , y - x) , add(i + n , p[2] , 0 , x - y);\n\t\tadd(p[3] , i + n , Inf , x - y) , add(i + n , p[3] , 0 , y - x);\n\t\tadd(p[4] , i + n , Inf , x + y) , add(i + n , p[4] , 0 , -x - y);\n\t}\n\tE_K();\n\tprintf(\"%lld\\n\",-mincost);\n\treturn 0;\n}\n```\n",
        "postTime": 1610171524,
        "uid": 132533,
        "name": "Hakuoro",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT4994 \u3010[AGC034D] Manhattan Max Matching\u3011"
    },
    {
        "content": "### AGC 034D\n#### Solution\n\u4e0d\u96be\u60f3\u5230\u8d39\u7528\u6d41\uff0c\u4f46\u662f\u82e5\u76f4\u63a5\u5efa\u56fe\uff0c\u5219\u8fb9\u6570\u4f1a\u8fbe\u5230$\\mathcal O(n^2)$\uff0c\u4e0d\u53ef\u901a\u8fc7\u3002\n\n\u6ce8\u610f\u5230$|x_i\u2212x_j|+|y_i\u2212y_j|=max(x_i+y_i\u2212x_j\u2212y_j,x_i\u2212xj-y_i+y_j,-x_i+x_j+y_i\u2212y_j,-x_i+x_j\u2212y_i+y_j)$\n\n\u90a3\u4e48\u6211\u4eec\u53ef\u4ee5\u5efa\u56db\u4e2a\u4e2d\u95f4\u70b9\u5206\u522b\u4ee3\u8868\u4e0a\u9762\u56db\u79cd\u60c5\u51b5\uff0c\u6bcf\u4e2a\u70b9\u5411\u8fd9\u56db\u4e2a\u4e2d\u95f4\u70b9\u8fde\u8fb9\uff0c\u5bb9\u91cf\u4e3a$1$\uff0c\u8fd9\u6837\u8fb9\u6570\u5c31\u964d\u5230$\\mathcal O(n)$\u4e86\uff0c\u7531\u4e8e\u662f\u6700\u5927\u8d39\u7528\uff0c\u6240\u4ee5\u4fdd\u8bc1\u4e86\u8fd9\u6837\u505a\u7684\u6b63\u786e\u6027\u3002\n\n\u6700\u540e\u8dd1\u4e2a\u6700\u5927\u8d39\u7528\u6700\u5927\u6d41\u5373\u53ef\u3002\n#### Code\n```cpp\nint S,T,tot,n;\nint p[5];\n\nstruct MinCostMaxFlow{\n    int len;\n    int head[MAXN],in[MAXN],id[MAXN],pre[MAXN]; ll dis[MAXN];\n    queue<int> q;\n\n    MinCostMaxFlow() {len = 1; memset(head,-1,sizeof(head));}\n\n    struct Edge{\n        int to,next,flow,cost;\n    } e[MAXN << 1];\n    \n    void add_edge(int u,int v,int flow,int cost){\n        e[++len] = (Edge){v,head[u],flow,cost};\n        head[u] = len;\n        e[++len] = (Edge){u,head[v],0,-cost};\n        head[v] = len;\n    }\n\n    bool spfa(){\n        for(int i = 1;i <= tot;i++) dis[i] = llINF, id[i] = pre[i] = in[i] = 0;\n        in[S] = 1; q.push(S); dis[S] = 0;\n        while(!q.empty()){\n            int u = q.front(); q.pop(); in[u] = 0;\n            for(int i = head[u];i != -1;i = e[i].next){\n                int v = e[i].to;\n                if(e[i].flow && dis[v] > dis[u] + e[i].cost){\n                    dis[v] = dis[u] + e[i].cost;\n                    pre[v] = u; id[v] = i;\n                    if(!in[v]) in[v] = 1, q.push(v);\n                }\n            }\n        }\n        return dis[T] != llINF;\n    }\n\n    ll EK(){\n        ll minCost = 0;\n        while(spfa()){\n            int mi = INF;\n            for(int i = T;i != S;i = pre[i]) checkMin(mi,e[id[i]].flow);\n            for(int i = T;i != S;i = pre[i]) e[id[i]].flow -= mi, e[id[i] ^ 1].flow += mi;\n            minCost += (ll)mi * dis[T];\n        }\n        return minCost;\n    }\n} mcmf;\n\nint main(){\n    scanf(\"%d\",&n); tot = (n << 1);\n    for(int i = 1;i <= 4;i++) p[i] = ++tot;\n    S = ++tot; T = ++tot;\n    for(int i = 1,x,y,c;i <= n;i++){\n        scanf(\"%d%d%d\",&x,&y,&c);\n        mcmf.add_edge(S,i,c,0);\n        mcmf.add_edge(i,p[1],INF,-x - y);\n        mcmf.add_edge(i,p[2],INF,-x + y);\n        mcmf.add_edge(i,p[3],INF,x - y);\n        mcmf.add_edge(i,p[4],INF,x + y);\n    }\n    for(int i = 1,x,y,c;i <= n;i++){\n        scanf(\"%d%d%d\",&x,&y,&c);\n        mcmf.add_edge(i + n,T,c,0);\n        mcmf.add_edge(p[1],i + n,INF,x + y);\n        mcmf.add_edge(p[2],i + n,INF,x - y);\n        mcmf.add_edge(p[3],i + n,INF,-x + y);\n        mcmf.add_edge(p[4],i + n,INF,-x - y);\n    }\n    printf(\"%lld\\n\",-mcmf.EK());\n    return 0;\n}\n```",
        "postTime": 1612763458,
        "uid": 108894,
        "name": "\u5173\u6000\u4ed6\u4eba",
        "ccfLevel": 0,
        "title": "\u9898\u89e3 AT4994 \u3010[AGC034D] Manhattan Max Matching\u3011"
    }
]