{
    "description": "[problemUrl]: https://atcoder.jp/contests/jag2018summer-day2/tasks/jag2018summer_day2_d\n\nFirst, you are given a positive integer $ MOD $.\n\nYou have a knapsack, this is empty at first.\n\nYou have to perform $ Q $ queries.\n\n- In each query, you have first to perform either `ADD` or `REMOVE` operation, and then perform `FIND` operation.\n- `ADD` operation : You are given positive integers $ w,\\ v $. You put the cookie whose weight is $ w $ and whose value is $ v $ to the knapsack.\n- `REMOVE` operation : You take out the cookie with the smallest weight from the knapsack and eat it.\n- `FIND` operation : You are given non-negative integers $ l,\\ r $. You answer the following question:\n  \n  \n  - Can you choose cookies from the knapsack so that the sum $ X $ of the weights of selected cookies satisfies $ l\\ \\leq\\ (X\\ {\\rm\\ mod}\\ MOD)\\ \\leq\\ r $\n  - If you can't, output `-1`.\n  - Otherwise, output the maximum sum of the values of selected cookies.",
    "inputFormat": "Input is given from Standard Input in the following format:\n\n> $ MOD $ $ Q $ $ t'_1 $ $ w'_1 $ $ v'_1 $ $ l'_1 $ $ r'_1 $ $ t'_2 $ $ w'_2 $ $ v'_2 $ $ l'_2 $ $ r'_2 $ : $ t'_Q $ $ w'_Q $ $ v'_Q $ $ l'_Q $ $ r'_Q $\n\n- $ 0\\ \\leq\\ t'_i,\\ w'_i,\\ v'_i,\\ l'_i,\\ r'_1\\ \\leq\\ 2^{30}\\ -\\ 1 $\n- Queries are **Online Query**. You can get $ t_i,\\ w_i,\\ v_i,\\ l_i,\\ r_i $ by decoding $ t'_i,\\ w'_i,\\ v'_i,\\ l'_i,\\ r'_i $.\n- $ t_i $ is query type.\n  \n  \n  - When $ t_i\\ =\\ 1 $, it involves `ADD` operation + `FIND` operation.\n  - When $ t_i\\ =\\ 2 $, it involves `REMOVE` operation + `FIND` operation.\n- When $ t_i\\ =\\ 2 $, you can assume that $ w_i=0 $ and $ v_i\\ =\\ 0 $.",
    "outputFormat": "Print results of `FIND` operation, one per line.",
    "samples": [
        [
            "10\r\n7\r\n281614559 249378726 433981056 466775634 683612866\r\n727071329 787572584 591471796 328464426 757737734\r\n279580343 240336097 538846427 808491898 224313807\r\n222498984 42804452 371605808 667115067 791865961\r\n68683864 1045549765 515479514 1067782238 349547144\r\n907343711 381772625 149003422 879314974 953881571\r\n883899098 700164610 414212891 752949213 972845634",
            "10\r\n0\r\n-1\r\n21\r\n-1\r\n11\r\n111"
        ],
        [
            "7\r\n20\r\n281614559 249378726 433981094 466775639 683612870\r\n59536386 999828879 241246766 434670565 174365647\r\n172060134 848462699 857413429 182122460 807914643\r\n808426426 600772095 829463884 974102196 354283529\r\n370037909 1024921880 664216868 194331103 140834169\r\n917331875 242953442 205247688 335469789 1055568137\r\n823475244 641321246 617915164 160300810 1073617378\r\n892669150 939175632 904628449 606339993 1059849410\r\n829170894 436718235 288920513 228195002 55212938\r\n772189413 373108543 94133155 610930061 513937768\r\n986619331 175674265 812546186 865335970 605634588\r\n880196843 1071068047 723408215 587598264 380801783\r\n393196081 141080294 584230885 135343295 661927186\r\n5740819 967233824 22597607 888639499 467454437\r\n365679801 515258603 989059385 962028117 761163096\r\n357270919 737051059 569528959 935653628 70506031\r\n869282414 947492121 280522456 96822010 856514221\r\n155948699 826430734 291243254 381421299 617876780\r\n980891674 833928389 1048677341 522527723 223764850\r\n50617939 963598173 281959650 499436870 47455938",
            "0\r\n134\r\n90\r\n158\r\n-1\r\n22\r\n238\r\n269\r\n179\r\n189\r\n121\r\n53\r\n41\r\n41\r\n-1\r\n58\r\n-1\r\n84\r\n-1\r\n149"
        ]
    ],
    "hint": "### Constraints\n\n- $ 2\\ \\leq\\ MOD\\ \\leq\\ 500 $\n- $ 1\\ \\leq\\ Q\\ \\leq\\ 100,000 $\n- $ 1\\ \\leq\\ w_i,\\ v_i\\ \\leq\\ 10^9 $\n- $ 0\\ \\leq\\ l_i\\ \\leq\\ r_i\\ \\leq\\ MOD-1 $\n- The cookie given by an `ADD` operation is strictly heavier than any cookie which was added by a previous `ADD` operation.\n- When executing `REMOVE` operation, the knapsack isn't empty.\n- Queries are **Online Query**. Queries are encrypted as described later.\n\n### Decryption\n\nWe prepare the decryption code with C++11 (or later), Java, D, C#.\n\nUse `class Crypto` for decryption, the code of `class Crypto` is below.\n\nC++\n\n ```\n#include <cstdint> //uint8_t, uint32_t\n\nclass Crypto {\npublic:    \n    Crypto() {\n        sm = cnt = 0;\n        seed();\n    }\n\n    int decode(int z) {\n        z ^= next();\n        z ^= (next() << 8);\n        z ^= (next() << 16);\n        z ^= (next() << 22);\n        return z;\n    }\n\n    void query(long long z) {\n        const long long B = 425481007;\n        const long long MD = 1000000007;\n        cnt++;\n        sm = ((sm * B % MD + z) % MD + MD) % MD;\n        seed();\n    }\nprivate: \n    long long sm;\n    int cnt;\n\n    uint8_t data[256];\n    int I, J;\n\n    void swap_data(int i, int j) {\n        uint8_t tmp = data[i];\n        data[i] = data[j];\n        data[j] = tmp;    \n    }\n\n    void seed() {\n        uint8_t key[8];\n        for (int i = 0; i < 4; i++) {\n            key[i] = (sm >> (i * 8));\n        }\n        for (int i = 0; i < 4; i++) {\n            key[i+4] = (cnt >> (i * 8));\n        }\n\n        for (int i = 0; i < 256; i++) {\n            data[i] = i;\n        }\n        I = J = 0;\n\n        int j = 0;\n        for (int i = 0; i < 256; i++) {\n            j = (j + data[i] + key[i%8]) % 256;\n            swap_data(i, j);\n        }\n    }\n\n    uint8_t next() {\n        I = (I+1) % 256;\n        J = (J + data[I]) % 256;\n        swap_data(I, J);\n        return data[(data[I] + data[J]) % 256];\n    }\n};\n```\n\nJava\n\n ```\npublic class Main {\n    public static class Crypto {\n        public Crypto() {\n            sm = cnt = 0;\n            seed();\n        }\n        public int decode(int z) {\n            z ^= next();\n            z ^= (next() << 8);\n            z ^= (next() << 16);\n            z ^= (next() << 22);\n            return z;\n        }\n        public void query(long z) {\n            final long B = 425481007;\n            final long MD = 1000000007;\n            cnt++;\n            sm = ((sm * B % MD + z) % MD + MD) % MD;\n            seed();\n        }\n\n        long sm;\n        int cnt;\n\n        byte data[] = new byte[256];\n        int I, J;\n\n        int asUint(byte x) {\n            int y = x;\n            return y & 0xff;\n        }\n        void seed() {\n            byte key[] = new byte[8];\n            for (int i = 0; i < 4; i++) {\n                key[i] = (byte)(sm >>> (i * 8));\n            }\n            for (int i = 0; i < 4; i++) {\n                key[i+4] = (byte)(cnt >>> (i * 8));\n            }\n\n            for (int i = 0; i < 256; i++) {\n                data[i] = (byte)i;\n            }\n            I = J = 0;\n\n            int j = 0;\n            for (int i = 0; i < 256; i++) {\n                j = (j + asUint(data[i]) + asUint(key[i % 8])) % 256;\n                byte tmp = data[i];\n                data[i] = data[j];\n                data[j] = tmp;\n            }\n        }\n        int next() {\n            I = (I+1) % 256;\n            J = (J+asUint(data[I])) % 256;\n            byte tmp = data[I];\n            data[I] = data[J];\n            data[J] = tmp;\n            return asUint(data[(asUint(data[I]) + asUint(data[J])) % 256]);\n        }\n    }\n    public static void main(String[] args) {\n        ...\n    }\n}\n```\n\nD\n\n ```\nclass Crypto {\npublic:\n    this() {\n        sm = cnt = 0;\n        seed();\n    }\n\n    int decode(int z) {\n        z ^= next();\n        z ^= (next() << 8);\n        z ^= (next() << 16);\n        z ^= (next() << 22);\n        return z;\n    }\n\n    void query(long z) {\n        immutable static long B = 425481007;\n        immutable static long MD = (10^^9)+7;\n        cnt++;\n        sm = ((sm * B % MD + z) % MD + MD) % MD;\n        seed();\n    }\nprivate:\n    import std.algorithm : swap;\n    long sm;\n    int cnt;\n\n    ubyte[256] data;\n    int I, J;\n    void seed() {\n        ubyte[8] key;\n        foreach (i; 0..4) {\n            key[i] = cast(ubyte)(sm >> (i*8));\n        }\n        foreach (i; 0..4) {\n            key[i+4] = cast(ubyte)(cnt >> (i*8));\n        }\n\n        foreach (i; 0..256) {\n            data[i] = cast(ubyte)(i);\n        }\n        I = J = 0;\n\n        int j = 0;\n        foreach (int i; 0..256) {\n            j = (j + data[i] + key[i%8]) % 256;\n            swap(data[i], data[j]);\n        }        \n    }\n\n    ubyte next() {\n        I = (I+1) % 256;\n        J = (J + data[I]) % 256;\n        swap(data[I], data[J]);\n        return data[(data[I] + data[J]) % 256];\n    }\n}\n```\n\nC#\n\n ```\nclass Crypto {\n    public Crypto() {\n        sm = cnt = 0;\n        data = new byte[256];\n        seed();\n    }\n\n    public int decode(int z) {\n        z ^= next();\n        z ^= (next() << 8);\n        z ^= (next() << 16);\n        z ^= (next() << 22);\n        return z;\n    }\n\n    public void query(long z) {\n        const long B = 425481007;\n        const long MD = 1000000007;\n        cnt++;\n        sm = ((sm * B % MD + z) % MD + MD) % MD;\n        seed();\n    }\n\n    long sm;\n    int cnt;\n\n    byte[] data;\n    int I, J;\n\n    void seed() {\n        byte[] key = new byte[8];\n        for (int i = 0; i < 4; i++) {\n            key[i] = (byte)(sm >> (i*8));\n        }\n        for (int i = 0; i < 4; i++) {\n            key[i+4] = (byte)(cnt >> (i*8));\n        }\n\n        for (int i = 0; i < 256; i++) {\n            data[i] = (byte)i;\n        }\n        I = J = 0;\n\n        int j = 0;\n        for (int i = 0; i < 256; i++) {\n            j = (j + data[i] + key[i%8]) % 256;\n            byte tmp = data[i];\n            data[i] = data[j];\n            data[j] = tmp;\n        }\n    }\n\n    byte next() {\n        I = (I+1) % 256;\n        J = (J + data[I]) % 256;\n        byte tmp = data[I];\n        data[I] = data[J];\n        data[J] = tmp;\n        return data[(data[I] + data[J]) % 256];\n    }\n}\n```\n\nThe procedure of decrypto:\n\n- First, you make an instance of `class Crypto`.\n- In each query,\n  - call the `decode` function for each of $ t',\\ w',\\ v',\\ l',\\ r' $ in order. The return values are $ t,\\ w,\\ v,\\ l,\\ r $.\n  - call the `query` function with the result of the `FIND` operation.\n\nThe sample code of C++ is below.\n\n ```\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint> //uint8_t, uint32_t\n\nclass Crypto {\n    ...\n};\n\nint main() {\n    int MOD, Q;\n    scanf(\"%d %d\", &MOD, &Q);\n    Crypto c;\n    for (int i = 0; i < Q; i++) {\n        int t, w, v, l, r;\n        scanf(\"%d %d %d %d %d\", &t, &w, &v, &l, &r);\n        t = c.decode(t);\n        w = c.decode(w);\n        v = c.decode(v);\n        l = c.decode(l);\n        r = c.decode(r);\n        if (t == 1) {\n            (add candy(w, v))\n        } else {\n            (delete candy)\n        }\n        long long ans = (answer for query(l, r));\n        c.query(ans);\n        printf(\"%lld\\n\", ans);\n    }\n}\n```\n\nThe sample codes of Java, D, C# are below.\n\nJava\n\n ```\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n    public static class Crypto {\n        ...\n    }    \n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in); //!!warning!! : Java's scanner is slow\n        PrintWriter out = new PrintWriter(System.out);\n        int MOD = in.nextInt();\n        int Q = in.nextInt();\n\n        Crypto c = new Crypto();\n        for (int i = 0; i < Q; i++) {\n            int t, w, v, l, r;\n            t = c.decode(in.nextInt());\n            w = c.decode(in.nextInt());\n            v = c.decode(in.nextInt());\n            l = c.decode(in.nextInt());\n            r = c.decode(in.nextInt());\n            if (t == 1) {\n                (add candy(w, v))\n            } else {\n                (delete candy)\n            }\n            long ans = (answer for query(l, r));\n            c.query(ans);\n            out.println(ans);\n        }\n        out.flush();\n    }\n}\n```\n\nD\n\n ```\nclass Crypto {\n    ...\n}\nint main() {\n    import std.stdio;\n    int MOD, Q;\n    readf(\"%d\\n%d\\n\", &MOD, &Q);\n    Crypto c = new Crypto();\n    foreach (i; 0..Q) {\n        int t, w, v, l, r;\n        readf(\"%d %d %d %d %d\\n\", &t, &w, &v, &l, &r);\n        t = c.decode(t);\n        w = c.decode(w);\n        v = c.decode(v);\n        l = c.decode(l);\n        r = c.decode(r);\n        if (t == 1) {\n            (add candy(w, v))\n        } else {\n            (delete candy)\n        }\n        long ans = (answer for query(l, r));\n        c.query(ans);\n        writeln(ans);\n    }\n    return 0;\n}\n```\n\nC#\n\n ```\nusing System;\nusing System.IO;\n\nclass Crypto {\n    ...\n}\nclass Myon {\n    static void Main() {\n        var writer = new StreamWriter(Console.OpenStandardOutput()){AutoFlush = false}; //fast writer\n        Console.SetOut(writer);\n\n        int MOD = int.Parse(Console.ReadLine());\n        int Q = int.Parse(Console.ReadLine());\n        Crypto c = new Crypto();\n        for (int i = 0; i < Q; i++) {\n            var inputs = Console.ReadLine().Split(' ');\n            int t, w, v, l, r;\n            t = c.decode(int.Parse(inputs[0]));\n            w = c.decode(int.Parse(inputs[1]));\n            v = c.decode(int.Parse(inputs[2]));\n            l = c.decode(int.Parse(inputs[3]));\n            r = c.decode(int.Parse(inputs[4]));\n            if (t == 1) {\n                (add candy(w, v))\n            } else {\n                (delete candy)\n            }\n            long ans = (answer for query(l, r));\n            c.query(ans);\n            Console.WriteLine(ans);\n        }\n        Console.Out.Flush();\n    }\n}\n```\n\nRemark:\n\n- You don't need to find vulnerability of this encryption.\n- `class Crypto` consume time at most about $ 200 $ ms when $ Q\\ =\\ 100,000 $.\n\n### Sample Explanation 1\n\nThe result of decoding this input is as follows. ``` 10 7 1 5 10 5 5 2 0 0 0 9 1 7 10 2 4 1 12 11 9 9 2 0 0 1 1 1 22 10 2 3 1 32 100 4 4 ``` Knapsack Selected Cookies (w, v) = {(5, 10)} {(5, 10)} {} {} {(7, 10)} -1 {(7, 10), (12, 11)} {(7, 10), (12, 11)} {(12, 11)} -1 {(12, 11), (22, 10)} {(12, 11)} {(12, 11), (22, 10), (32, 100)} {(12, 11), (32, 100)}\n\n### Sample Explanation 2\n\nThe result of decoding this input is as follows. ``` 7 20 1 5 44 0 1 1 11 90 0 3 2 0 0 3 4 1 18 68 1 6 1 25 32 2 3 1 31 22 2 3 1 32 26 1 5 1 36 31 3 6 2 0 0 2 5 1 43 10 3 6 2 0 0 5 6 2 0 0 3 4 2 0 0 2 4 2 0 0 1 5 2 0 0 3 5 1 49 48 0 4 2 0 0 1 5 1 50 36 0 6 1 56 48 3 5 1 59 17 3 5 ```"
}